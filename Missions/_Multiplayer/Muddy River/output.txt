// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitHc ;
   8: CALL_OW 19
// InitUc ;
  12: CALL_OW 18
// InitBc ;
  16: CALL_OW 21
// InitVariables ;
  20: CALL 318 0 0
// InitMultiplayer ;
  24: CALL 579 0 0
// InitMacro ;
  28: CALL 47062 0 0
// if debug then
  32: LD_EXP 1
  36: IFFALSE 45
// FogOff ( 1 ) ;
  38: LD_INT 1
  40: PPUSH
  41: CALL_OW 344
// PrepareNature ( 3 , 3 , 9 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  45: LD_INT 3
  47: PPUSH
  48: LD_INT 3
  50: PPUSH
  51: LD_INT 9
  53: PPUSH
  54: LD_INT 2
  56: PPUSH
  57: LD_INT 2
  59: PPUSH
  60: LD_INT 1
  62: PPUSH
  63: LD_INT 5
  65: PPUSH
  66: LD_INT 18
  68: PPUSH
  69: LD_INT 19
  71: PPUSH
  72: CALL 42473 0 9
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  76: LD_INT 2
  78: PPUSH
  79: CALL 1857 0 1
  83: PPUSH
  84: CALL 5825 0 1
// Multiplayer_Start ;
  88: CALL 3734 0 0
// MC_Start ( ) ;
  92: CALL 49174 0 0
// Multiplayer_End ;
  96: CALL 3858 0 0
// end ;
 100: END
// export function CustomInitMacro ; var i ; begin
 101: LD_INT 0
 103: PPUSH
 104: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 105: LD_INT 1
 107: PPUSH
 108: LD_INT 8
 110: PUSH
 111: LD_INT 10
 113: PUSH
 114: LD_INT 12
 116: PUSH
 117: EMPTY
 118: LIST
 119: LIST
 120: LIST
 121: PUSH
 122: LD_OWVAR 67
 126: ARRAY
 127: PPUSH
 128: LD_INT 3
 130: PPUSH
 131: CALL 70423 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 135: LD_INT 2
 137: PPUSH
 138: LD_INT 6
 140: PUSH
 141: LD_INT 8
 143: PUSH
 144: LD_INT 9
 146: PUSH
 147: EMPTY
 148: LIST
 149: LIST
 150: LIST
 151: PUSH
 152: LD_OWVAR 67
 156: ARRAY
 157: PPUSH
 158: LD_INT 2
 160: PPUSH
 161: CALL 70423 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 165: LD_INT 3
 167: PPUSH
 168: LD_INT 6
 170: PUSH
 171: LD_INT 7
 173: PUSH
 174: LD_INT 9
 176: PUSH
 177: EMPTY
 178: LIST
 179: LIST
 180: LIST
 181: PUSH
 182: LD_OWVAR 67
 186: ARRAY
 187: PPUSH
 188: LD_INT 1
 190: PPUSH
 191: CALL 70423 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 195: LD_INT 4
 197: PPUSH
 198: LD_INT 6
 200: PUSH
 201: LD_INT 7
 203: PUSH
 204: LD_INT 9
 206: PUSH
 207: EMPTY
 208: LIST
 209: LIST
 210: LIST
 211: PUSH
 212: LD_OWVAR 67
 216: ARRAY
 217: PPUSH
 218: LD_INT 25
 220: PPUSH
 221: CALL 70423 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south ] ;
 225: LD_ADDR_EXP 66
 229: PUSH
 230: LD_INT 20
 232: PUSH
 233: LD_INT 21
 235: PUSH
 236: LD_INT 22
 238: PUSH
 239: LD_INT 24
 241: PUSH
 242: EMPTY
 243: LIST
 244: LIST
 245: LIST
 246: LIST
 247: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south ] ;
 248: LD_ADDR_EXP 67
 252: PUSH
 253: LD_INT 35
 255: PUSH
 256: LD_INT 34
 258: PUSH
 259: LD_INT 36
 261: PUSH
 262: LD_INT 33
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: LIST
 269: LIST
 270: ST_TO_ADDR
// for i = 1 to mc_bases do
 271: LD_ADDR_VAR 0 2
 275: PUSH
 276: DOUBLE
 277: LD_INT 1
 279: DEC
 280: ST_TO_ADDR
 281: LD_EXP 42
 285: PUSH
 286: FOR_TO
 287: IFFALSE 311
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 289: LD_VAR 0 2
 293: PPUSH
 294: LD_EXP 37
 298: PUSH
 299: LD_VAR 0 2
 303: ARRAY
 304: PPUSH
 305: CALL 70849 0 2
 309: GO 286
 311: POP
 312: POP
// end ;
 313: LD_VAR 0 1
 317: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 318: LD_INT 0
 320: PPUSH
// debug := false ;
 321: LD_ADDR_EXP 1
 325: PUSH
 326: LD_INT 0
 328: ST_TO_ADDR
// side_bot := 2 ;
 329: LD_ADDR_EXP 3
 333: PUSH
 334: LD_INT 2
 336: ST_TO_ADDR
// artifact_get := false ;
 337: LD_ADDR_EXP 4
 341: PUSH
 342: LD_INT 0
 344: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 345: LD_ADDR_EXP 5
 349: PUSH
 350: LD_STRING base_a
 352: PUSH
 353: LD_STRING base_b
 355: PUSH
 356: LD_STRING base_c
 358: PUSH
 359: LD_STRING base_d
 361: PUSH
 362: LD_STRING base_e
 364: PUSH
 365: LD_STRING base_f
 367: PUSH
 368: LD_STRING base_g
 370: PUSH
 371: LD_STRING base_h
 373: PUSH
 374: LD_STRING base_i
 376: PUSH
 377: LD_STRING base_j
 379: PUSH
 380: LD_STRING base_k
 382: PUSH
 383: LD_STRING base_l
 385: PUSH
 386: LD_STRING base_m
 388: PUSH
 389: LD_STRING base_n
 391: PUSH
 392: LD_STRING base_o
 394: PUSH
 395: LD_STRING base_p
 397: PUSH
 398: LD_STRING base_r
 400: PUSH
 401: LD_STRING base_s
 403: PUSH
 404: LD_STRING base_t
 406: PUSH
 407: LD_STRING base_u
 409: PUSH
 410: LD_STRING base_w
 412: PUSH
 413: LD_STRING base_x
 415: PUSH
 416: LD_STRING base_y
 418: PUSH
 419: LD_STRING base_z
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: ST_TO_ADDR
// end ;
 448: LD_VAR 0 1
 452: RET
// every 0 0$01 trigger game and not debug_strings do
 453: LD_EXP 2
 457: PUSH
 458: LD_OWVAR 48
 462: NOT
 463: AND
 464: IFFALSE 480
 466: GO 468
 468: DISABLE
// begin enable ;
 469: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 470: LD_ADDR_OWVAR 47
 474: PUSH
 475: CALL 4559 0 0
 479: ST_TO_ADDR
// end ;
 480: END
// function Debuger ; var i ; begin
 481: LD_INT 0
 483: PPUSH
 484: PPUSH
// if not debug then
 485: LD_EXP 1
 489: NOT
 490: IFFALSE 494
// exit ;
 492: GO 566
// game_speed := 5 ;
 494: LD_ADDR_OWVAR 65
 498: PUSH
 499: LD_INT 5
 501: ST_TO_ADDR
// uc_side := 1 ;
 502: LD_ADDR_OWVAR 20
 506: PUSH
 507: LD_INT 1
 509: ST_TO_ADDR
// uc_nation := 1 ;
 510: LD_ADDR_OWVAR 21
 514: PUSH
 515: LD_INT 1
 517: ST_TO_ADDR
// for i = 1 to 10 do
 518: LD_ADDR_VAR 0 2
 522: PUSH
 523: DOUBLE
 524: LD_INT 1
 526: DEC
 527: ST_TO_ADDR
 528: LD_INT 10
 530: PUSH
 531: FOR_TO
 532: IFFALSE 564
// begin PrepareHuman ( false , 1 , 10 ) ;
 534: LD_INT 0
 536: PPUSH
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 10
 542: PPUSH
 543: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 547: CALL_OW 44
 551: PPUSH
 552: LD_INT 9
 554: PPUSH
 555: LD_INT 0
 557: PPUSH
 558: CALL_OW 49
// end ;
 562: GO 531
 564: POP
 565: POP
// end ;
 566: LD_VAR 0 1
 570: RET
// export function CustomEvent ( event ) ; begin
 571: LD_INT 0
 573: PPUSH
// end ; end_of_file
 574: LD_VAR 0 2
 578: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 579: LD_INT 0
 581: PPUSH
 582: PPUSH
 583: PPUSH
 584: PPUSH
 585: PPUSH
// multi_settings_counter := 6 ;
 586: LD_ADDR_EXP 18
 590: PUSH
 591: LD_INT 6
 593: ST_TO_ADDR
// if multiplayer then
 594: LD_OWVAR 4
 598: IFFALSE 776
// begin your_side := mp_player_side ;
 600: LD_ADDR_OWVAR 2
 604: PUSH
 605: LD_OWVAR 7
 609: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 610: LD_ADDR_EXP 6
 614: PUSH
 615: LD_OWVAR 6
 619: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 620: LD_ADDR_EXP 7
 624: PUSH
 625: LD_OWVAR 17
 629: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 630: LD_ADDR_EXP 8
 634: PUSH
 635: LD_OWVAR 15
 639: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 640: LD_ADDR_EXP 9
 644: PUSH
 645: LD_OWVAR 16
 649: ST_TO_ADDR
// multi_teams := [ [ ] ] ;
 650: LD_ADDR_EXP 10
 654: PUSH
 655: EMPTY
 656: PUSH
 657: EMPTY
 658: LIST
 659: ST_TO_ADDR
// for i in mp_teams do
 660: LD_ADDR_VAR 0 2
 664: PUSH
 665: LD_OWVAR 12
 669: PUSH
 670: FOR_IN
 671: IFFALSE 712
// multi_teams := Replace ( multi_teams , 1 , multi_teams [ 1 ] union i [ 1 ] ) ;
 673: LD_ADDR_EXP 10
 677: PUSH
 678: LD_EXP 10
 682: PPUSH
 683: LD_INT 1
 685: PPUSH
 686: LD_EXP 10
 690: PUSH
 691: LD_INT 1
 693: ARRAY
 694: PUSH
 695: LD_VAR 0 2
 699: PUSH
 700: LD_INT 1
 702: ARRAY
 703: UNION
 704: PPUSH
 705: CALL_OW 1
 709: ST_TO_ADDR
 710: GO 670
 712: POP
 713: POP
// for i = 1 to multi_settings_counter do
 714: LD_ADDR_VAR 0 2
 718: PUSH
 719: DOUBLE
 720: LD_INT 1
 722: DEC
 723: ST_TO_ADDR
 724: LD_EXP 18
 728: PUSH
 729: FOR_TO
 730: IFFALSE 772
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 732: LD_ADDR_EXP 17
 736: PUSH
 737: LD_EXP 17
 741: PPUSH
 742: LD_EXP 17
 746: PUSH
 747: LD_INT 1
 749: PLUS
 750: PPUSH
 751: LD_VAR 0 2
 755: PPUSH
 756: CALL_OW 426
 760: PUSH
 761: LD_INT 1
 763: PLUS
 764: PPUSH
 765: CALL_OW 2
 769: ST_TO_ADDR
 770: GO 729
 772: POP
 773: POP
// end else
 774: GO 962
// begin your_side := 1 ;
 776: LD_ADDR_OWVAR 2
 780: PUSH
 781: LD_INT 1
 783: ST_TO_ADDR
// multi_gametype := 1 ;
 784: LD_ADDR_EXP 6
 788: PUSH
 789: LD_INT 1
 791: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 792: LD_ADDR_EXP 7
 796: PUSH
 797: LD_INT 2
 799: PUSH
 800: LD_INT 0
 802: PUSH
 803: LD_INT 0
 805: PUSH
 806: LD_INT 3
 808: PUSH
 809: LD_INT 0
 811: PUSH
 812: LD_INT 0
 814: PUSH
 815: LD_INT 1
 817: PUSH
 818: LD_INT 0
 820: PUSH
 821: EMPTY
 822: LIST
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 831: LD_ADDR_EXP 8
 835: PUSH
 836: LD_INT 1
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 0
 844: PUSH
 845: LD_INT 1
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 0
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 0
 859: PUSH
 860: EMPTY
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 870: LD_ADDR_EXP 9
 874: PUSH
 875: LD_INT 1
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 0
 883: PUSH
 884: LD_INT 1
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 0
 892: PUSH
 893: LD_INT 1
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: EMPTY
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: LIST
 908: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 909: LD_ADDR_EXP 10
 913: PUSH
 914: LD_INT 1
 916: PUSH
 917: LD_INT 4
 919: PUSH
 920: LD_INT 7
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: EMPTY
 929: LIST
 930: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 931: LD_ADDR_EXP 17
 935: PUSH
 936: LD_INT 2
 938: PUSH
 939: LD_INT 2
 941: PUSH
 942: LD_INT 1
 944: PUSH
 945: LD_INT 3
 947: PUSH
 948: LD_INT 1
 950: PUSH
 951: LD_INT 1
 953: PUSH
 954: EMPTY
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: LIST
 960: LIST
 961: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 962: LD_ADDR_EXP 11
 966: PUSH
 967: LD_INT 0
 969: PUSH
 970: LD_INT 0
 972: PUSH
 973: LD_INT 0
 975: PUSH
 976: LD_INT 0
 978: PUSH
 979: LD_INT 0
 981: PUSH
 982: LD_INT 0
 984: PUSH
 985: LD_INT 0
 987: PUSH
 988: LD_INT 0
 990: PUSH
 991: EMPTY
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: LIST
1000: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1001: LD_ADDR_EXP 14
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: LD_INT 0
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1040: LD_ADDR_EXP 25
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: LD_INT 0
1068: PUSH
1069: EMPTY
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: ST_TO_ADDR
// multi_teamgame := true ;
1079: LD_ADDR_EXP 15
1083: PUSH
1084: LD_INT 1
1086: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1087: LD_ADDR_EXP 13
1091: PUSH
1092: LD_INT 1
1094: PUSH
1095: EMPTY
1096: LIST
1097: ST_TO_ADDR
// multi_custom_commanders := true ;
1098: LD_ADDR_EXP 16
1102: PUSH
1103: LD_INT 1
1105: ST_TO_ADDR
// multi_commanders := [ ] ;
1106: LD_ADDR_EXP 24
1110: PUSH
1111: EMPTY
1112: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1113: LD_ADDR_EXP 27
1117: PUSH
1118: EMPTY
1119: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1120: LD_ADDR_EXP 28
1124: PUSH
1125: LD_INT 0
1127: ST_TO_ADDR
// multi_players_amount := 0 ;
1128: LD_ADDR_EXP 26
1132: PUSH
1133: LD_INT 0
1135: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1136: LD_ADDR_EXP 12
1140: PUSH
1141: LD_INT 9
1143: PUSH
1144: LD_INT 8
1146: PUSH
1147: EMPTY
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 26
1156: PUSH
1157: EMPTY
1158: LIST
1159: LIST
1160: PUSH
1161: LD_INT 29
1163: PUSH
1164: LD_INT 28
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: PUSH
1171: EMPTY
1172: LIST
1173: LIST
1174: LIST
1175: ST_TO_ADDR
// for i = 1 to 8 do
1176: LD_ADDR_VAR 0 2
1180: PUSH
1181: DOUBLE
1182: LD_INT 1
1184: DEC
1185: ST_TO_ADDR
1186: LD_INT 8
1188: PUSH
1189: FOR_TO
1190: IFFALSE 1519
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1192: LD_VAR 0 2
1196: PPUSH
1197: CALL_OW 530
1201: IFFALSE 1359
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1203: LD_ADDR_EXP 11
1207: PUSH
1208: LD_EXP 11
1212: PPUSH
1213: LD_VAR 0 2
1217: PPUSH
1218: LD_INT 1
1220: PPUSH
1221: CALL_OW 1
1225: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1226: LD_ADDR_EXP 9
1230: PUSH
1231: LD_EXP 9
1235: PPUSH
1236: LD_VAR 0 2
1240: PPUSH
1241: LD_INT 0
1243: PPUSH
1244: CALL_OW 1
1248: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1249: LD_ADDR_EXP 7
1253: PUSH
1254: LD_EXP 7
1258: PPUSH
1259: LD_VAR 0 2
1263: PPUSH
1264: LD_INT 0
1266: PPUSH
1267: CALL_OW 1
1271: ST_TO_ADDR
// for j = 1 to multi_teams do
1272: LD_ADDR_VAR 0 3
1276: PUSH
1277: DOUBLE
1278: LD_INT 1
1280: DEC
1281: ST_TO_ADDR
1282: LD_EXP 10
1286: PUSH
1287: FOR_TO
1288: IFFALSE 1357
// begin if i in multi_teams [ j ] then
1290: LD_VAR 0 2
1294: PUSH
1295: LD_EXP 10
1299: PUSH
1300: LD_VAR 0 3
1304: ARRAY
1305: IN
1306: IFFALSE 1355
// begin tmp := multi_teams [ j ] diff i ;
1308: LD_ADDR_VAR 0 5
1312: PUSH
1313: LD_EXP 10
1317: PUSH
1318: LD_VAR 0 3
1322: ARRAY
1323: PUSH
1324: LD_VAR 0 2
1328: DIFF
1329: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1330: LD_ADDR_EXP 10
1334: PUSH
1335: LD_EXP 10
1339: PPUSH
1340: LD_VAR 0 3
1344: PPUSH
1345: LD_VAR 0 5
1349: PPUSH
1350: CALL_OW 1
1354: ST_TO_ADDR
// end ; end ;
1355: GO 1287
1357: POP
1358: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1359: LD_EXP 9
1363: PUSH
1364: LD_VAR 0 2
1368: ARRAY
1369: PUSH
1370: LD_EXP 9
1374: PUSH
1375: LD_VAR 0 2
1379: ARRAY
1380: PUSH
1381: LD_EXP 13
1385: IN
1386: NOT
1387: AND
1388: IFFALSE 1429
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1390: LD_ADDR_EXP 9
1394: PUSH
1395: LD_EXP 9
1399: PPUSH
1400: LD_VAR 0 2
1404: PPUSH
1405: LD_EXP 13
1409: PUSH
1410: LD_INT 1
1412: PPUSH
1413: LD_EXP 13
1417: PPUSH
1418: CALL_OW 12
1422: ARRAY
1423: PPUSH
1424: CALL_OW 1
1428: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1429: LD_EXP 9
1433: PUSH
1434: LD_VAR 0 2
1438: ARRAY
1439: NOT
1440: PUSH
1441: LD_EXP 7
1445: PUSH
1446: LD_VAR 0 2
1450: ARRAY
1451: NOT
1452: AND
1453: PUSH
1454: LD_EXP 11
1458: PUSH
1459: LD_VAR 0 2
1463: ARRAY
1464: NOT
1465: AND
1466: IFFALSE 1491
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1468: LD_ADDR_EXP 14
1472: PUSH
1473: LD_EXP 14
1477: PPUSH
1478: LD_VAR 0 2
1482: PPUSH
1483: LD_INT 1
1485: PPUSH
1486: CALL_OW 1
1490: ST_TO_ADDR
// if multi_sides [ i ] then
1491: LD_EXP 7
1495: PUSH
1496: LD_VAR 0 2
1500: ARRAY
1501: IFFALSE 1517
// multi_players_amount := multi_players_amount + 1 ;
1503: LD_ADDR_EXP 26
1507: PUSH
1508: LD_EXP 26
1512: PUSH
1513: LD_INT 1
1515: PLUS
1516: ST_TO_ADDR
// end ;
1517: GO 1189
1519: POP
1520: POP
// for i in multi_teams do
1521: LD_ADDR_VAR 0 2
1525: PUSH
1526: LD_EXP 10
1530: PUSH
1531: FOR_IN
1532: IFFALSE 1640
// begin for j = 2 to i do
1534: LD_ADDR_VAR 0 3
1538: PUSH
1539: DOUBLE
1540: LD_INT 2
1542: DEC
1543: ST_TO_ADDR
1544: LD_VAR 0 2
1548: PUSH
1549: FOR_TO
1550: IFFALSE 1636
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1552: LD_VAR 0 2
1556: PUSH
1557: LD_VAR 0 3
1561: ARRAY
1562: PPUSH
1563: LD_VAR 0 2
1567: PUSH
1568: LD_INT 1
1570: ARRAY
1571: PPUSH
1572: CALL_OW 343
// for x = 1 to j - 1 do
1576: LD_ADDR_VAR 0 4
1580: PUSH
1581: DOUBLE
1582: LD_INT 1
1584: DEC
1585: ST_TO_ADDR
1586: LD_VAR 0 3
1590: PUSH
1591: LD_INT 1
1593: MINUS
1594: PUSH
1595: FOR_TO
1596: IFFALSE 1632
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1598: LD_VAR 0 2
1602: PUSH
1603: LD_VAR 0 3
1607: ARRAY
1608: PPUSH
1609: LD_VAR 0 2
1613: PUSH
1614: LD_VAR 0 4
1618: ARRAY
1619: PPUSH
1620: LD_INT 1
1622: PPUSH
1623: LD_INT 1
1625: PPUSH
1626: CALL_OW 80
1630: GO 1595
1632: POP
1633: POP
// end ;
1634: GO 1549
1636: POP
1637: POP
// end ;
1638: GO 1531
1640: POP
1641: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1642: LD_ADDR_OWVAR 67
1646: PUSH
1647: LD_INT 1
1649: PUSH
1650: LD_INT 2
1652: PUSH
1653: LD_INT 3
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: PUSH
1661: LD_EXP 17
1665: PUSH
1666: LD_INT 1
1668: ARRAY
1669: ARRAY
1670: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1671: LD_ADDR_EXP 19
1675: PUSH
1676: LD_INT 9
1678: PUSH
1679: LD_INT 12
1681: PUSH
1682: LD_INT 15
1684: PUSH
1685: LD_INT 18
1687: PUSH
1688: EMPTY
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: PUSH
1694: LD_EXP 17
1698: PUSH
1699: LD_INT 2
1701: ARRAY
1702: ARRAY
1703: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1704: LD_ADDR_EXP 20
1708: PUSH
1709: LD_INT 5
1711: PUSH
1712: LD_INT 7
1714: PUSH
1715: LD_INT 9
1717: PUSH
1718: EMPTY
1719: LIST
1720: LIST
1721: LIST
1722: PUSH
1723: LD_EXP 17
1727: PUSH
1728: LD_INT 3
1730: ARRAY
1731: ARRAY
1732: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1733: LD_ADDR_EXP 21
1737: PUSH
1738: LD_INT 6000
1740: PUSH
1741: LD_INT 1575
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 8000
1750: PUSH
1751: LD_INT 1260
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: PUSH
1758: LD_INT 10000
1760: PUSH
1761: LD_INT 770
1763: PUSH
1764: EMPTY
1765: LIST
1766: LIST
1767: PUSH
1768: LD_INT 15000
1770: PUSH
1771: LD_INT 770
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: EMPTY
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: PUSH
1784: LD_EXP 17
1788: PUSH
1789: LD_INT 4
1791: ARRAY
1792: ARRAY
1793: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1794: LD_ADDR_EXP 22
1798: PUSH
1799: LD_INT 6
1801: PUSH
1802: LD_INT 8
1804: PUSH
1805: LD_INT 10
1807: PUSH
1808: EMPTY
1809: LIST
1810: LIST
1811: LIST
1812: PUSH
1813: LD_EXP 17
1817: PUSH
1818: LD_INT 5
1820: ARRAY
1821: ARRAY
1822: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1823: LD_ADDR_EXP 23
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 1
1833: PUSH
1834: LD_INT 2
1836: PUSH
1837: EMPTY
1838: LIST
1839: LIST
1840: LIST
1841: PUSH
1842: LD_EXP 17
1846: PUSH
1847: LD_INT 6
1849: ARRAY
1850: ARRAY
1851: ST_TO_ADDR
// end ;
1852: LD_VAR 0 1
1856: RET
// export function Multiplayer_SetBotSide ( prefer_side ) ; var i ; begin
1857: LD_INT 0
1859: PPUSH
1860: PPUSH
// ResetFog ;
1861: CALL_OW 335
// if not multi_bots then
1865: LD_EXP 14
1869: NOT
1870: IFFALSE 1874
// exit ;
1872: GO 1946
// if multi_bots [ prefer_side ] then
1874: LD_EXP 14
1878: PUSH
1879: LD_VAR 0 1
1883: ARRAY
1884: IFFALSE 1898
// begin result := prefer_side ;
1886: LD_ADDR_VAR 0 2
1890: PUSH
1891: LD_VAR 0 1
1895: ST_TO_ADDR
// exit ;
1896: GO 1946
// end ; for i = 1 to multi_bots do
1898: LD_ADDR_VAR 0 3
1902: PUSH
1903: DOUBLE
1904: LD_INT 1
1906: DEC
1907: ST_TO_ADDR
1908: LD_EXP 14
1912: PUSH
1913: FOR_TO
1914: IFFALSE 1944
// if multi_bots [ i ] then
1916: LD_EXP 14
1920: PUSH
1921: LD_VAR 0 3
1925: ARRAY
1926: IFFALSE 1942
// begin result := i ;
1928: LD_ADDR_VAR 0 2
1932: PUSH
1933: LD_VAR 0 3
1937: ST_TO_ADDR
// exit ;
1938: POP
1939: POP
1940: GO 1946
// end ;
1942: GO 1913
1944: POP
1945: POP
// end ;
1946: LD_VAR 0 2
1950: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1951: LD_INT 0
1953: PPUSH
// uc_side := side ;
1954: LD_ADDR_OWVAR 20
1958: PUSH
1959: LD_VAR 0 1
1963: ST_TO_ADDR
// uc_nation := 1 ;
1964: LD_ADDR_OWVAR 21
1968: PUSH
1969: LD_INT 1
1971: ST_TO_ADDR
// hc_importance := 100 ;
1972: LD_ADDR_OWVAR 32
1976: PUSH
1977: LD_INT 100
1979: ST_TO_ADDR
// hc_class := 1 ;
1980: LD_ADDR_OWVAR 28
1984: PUSH
1985: LD_INT 1
1987: ST_TO_ADDR
// if num = 1 then
1988: LD_VAR 0 2
1992: PUSH
1993: LD_INT 1
1995: EQUAL
1996: IFFALSE 2078
// begin hc_gallery := us ;
1998: LD_ADDR_OWVAR 33
2002: PUSH
2003: LD_STRING us
2005: ST_TO_ADDR
// hc_face_number := 5 ;
2006: LD_ADDR_OWVAR 34
2010: PUSH
2011: LD_INT 5
2013: ST_TO_ADDR
// hc_name := John Macmilan ;
2014: LD_ADDR_OWVAR 26
2018: PUSH
2019: LD_STRING John Macmilan
2021: ST_TO_ADDR
// hc_sex := sex_male ;
2022: LD_ADDR_OWVAR 27
2026: PUSH
2027: LD_INT 1
2029: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2030: LD_ADDR_OWVAR 31
2034: PUSH
2035: LD_INT 7
2037: PUSH
2038: LD_INT 2
2040: PUSH
2041: LD_INT 4
2043: PUSH
2044: LD_INT 4
2046: PUSH
2047: EMPTY
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2053: LD_ADDR_OWVAR 29
2057: PUSH
2058: LD_INT 11
2060: PUSH
2061: LD_INT 10
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: ST_TO_ADDR
// result := CreateHuman ;
2068: LD_ADDR_VAR 0 3
2072: PUSH
2073: CALL_OW 44
2077: ST_TO_ADDR
// end ; if num = 2 then
2078: LD_VAR 0 2
2082: PUSH
2083: LD_INT 2
2085: EQUAL
2086: IFFALSE 2168
// begin hc_gallery := us ;
2088: LD_ADDR_OWVAR 33
2092: PUSH
2093: LD_STRING us
2095: ST_TO_ADDR
// hc_face_number := 2 ;
2096: LD_ADDR_OWVAR 34
2100: PUSH
2101: LD_INT 2
2103: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2104: LD_ADDR_OWVAR 26
2108: PUSH
2109: LD_STRING Lucy Donaldson
2111: ST_TO_ADDR
// hc_sex := sex_female ;
2112: LD_ADDR_OWVAR 27
2116: PUSH
2117: LD_INT 2
2119: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2120: LD_ADDR_OWVAR 31
2124: PUSH
2125: LD_INT 6
2127: PUSH
2128: LD_INT 3
2130: PUSH
2131: LD_INT 4
2133: PUSH
2134: LD_INT 3
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2143: LD_ADDR_OWVAR 29
2147: PUSH
2148: LD_INT 9
2150: PUSH
2151: LD_INT 12
2153: PUSH
2154: EMPTY
2155: LIST
2156: LIST
2157: ST_TO_ADDR
// result := CreateHuman ;
2158: LD_ADDR_VAR 0 3
2162: PUSH
2163: CALL_OW 44
2167: ST_TO_ADDR
// end ; if num = 3 then
2168: LD_VAR 0 2
2172: PUSH
2173: LD_INT 3
2175: EQUAL
2176: IFFALSE 2258
// begin hc_gallery := us ;
2178: LD_ADDR_OWVAR 33
2182: PUSH
2183: LD_STRING us
2185: ST_TO_ADDR
// hc_face_number := 7 ;
2186: LD_ADDR_OWVAR 34
2190: PUSH
2191: LD_INT 7
2193: ST_TO_ADDR
// hc_name := Arthur Powell ;
2194: LD_ADDR_OWVAR 26
2198: PUSH
2199: LD_STRING Arthur Powell
2201: ST_TO_ADDR
// hc_sex := sex_male ;
2202: LD_ADDR_OWVAR 27
2206: PUSH
2207: LD_INT 1
2209: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2210: LD_ADDR_OWVAR 31
2214: PUSH
2215: LD_INT 8
2217: PUSH
2218: LD_INT 2
2220: PUSH
2221: LD_INT 5
2223: PUSH
2224: LD_INT 2
2226: PUSH
2227: EMPTY
2228: LIST
2229: LIST
2230: LIST
2231: LIST
2232: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2233: LD_ADDR_OWVAR 29
2237: PUSH
2238: LD_INT 10
2240: PUSH
2241: LD_INT 11
2243: PUSH
2244: EMPTY
2245: LIST
2246: LIST
2247: ST_TO_ADDR
// result := CreateHuman ;
2248: LD_ADDR_VAR 0 3
2252: PUSH
2253: CALL_OW 44
2257: ST_TO_ADDR
// end ; end ;
2258: LD_VAR 0 3
2262: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2263: LD_INT 0
2265: PPUSH
2266: PPUSH
2267: PPUSH
2268: PPUSH
2269: PPUSH
2270: PPUSH
2271: PPUSH
2272: PPUSH
2273: PPUSH
// for i = 1 to 8 do
2274: LD_ADDR_VAR 0 2
2278: PUSH
2279: DOUBLE
2280: LD_INT 1
2282: DEC
2283: ST_TO_ADDR
2284: LD_INT 8
2286: PUSH
2287: FOR_TO
2288: IFFALSE 3178
// begin if not multi_sides [ i ] then
2290: LD_EXP 7
2294: PUSH
2295: LD_VAR 0 2
2299: ARRAY
2300: NOT
2301: IFFALSE 2305
// continue ;
2303: GO 2287
// if multi_custom_commanders then
2305: LD_EXP 16
2309: IFFALSE 2401
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2311: LD_ADDR_VAR 0 5
2315: PUSH
2316: LD_VAR 0 2
2320: PPUSH
2321: LD_EXP 7
2325: PUSH
2326: LD_VAR 0 2
2330: ARRAY
2331: PPUSH
2332: CALL 1951 0 2
2336: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2337: LD_ADDR_EXP 24
2341: PUSH
2342: LD_EXP 24
2346: PPUSH
2347: LD_EXP 24
2351: PUSH
2352: LD_INT 1
2354: PLUS
2355: PPUSH
2356: LD_VAR 0 5
2360: PPUSH
2361: CALL_OW 2
2365: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2366: LD_VAR 0 5
2370: PPUSH
2371: LD_EXP 12
2375: PUSH
2376: LD_EXP 7
2380: PUSH
2381: LD_VAR 0 2
2385: ARRAY
2386: ARRAY
2387: PUSH
2388: LD_INT 1
2390: ARRAY
2391: PPUSH
2392: LD_INT 0
2394: PPUSH
2395: CALL_OW 49
// end else
2399: GO 2612
// begin uc_side := i ;
2401: LD_ADDR_OWVAR 20
2405: PUSH
2406: LD_VAR 0 2
2410: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2411: LD_ADDR_OWVAR 21
2415: PUSH
2416: LD_EXP 9
2420: PUSH
2421: LD_VAR 0 2
2425: ARRAY
2426: ST_TO_ADDR
// hc_importance := 100 ;
2427: LD_ADDR_OWVAR 32
2431: PUSH
2432: LD_INT 100
2434: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2435: LD_INT 0
2437: PPUSH
2438: LD_INT 1
2440: PPUSH
2441: LD_EXP 20
2445: PPUSH
2446: CALL_OW 380
// if multiplayer then
2450: LD_OWVAR 4
2454: IFFALSE 2512
// begin hc_name := mp_sides_players_names [ i ] ;
2456: LD_ADDR_OWVAR 26
2460: PUSH
2461: LD_OWVAR 19
2465: PUSH
2466: LD_VAR 0 2
2470: ARRAY
2471: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2472: LD_ADDR_OWVAR 33
2476: PUSH
2477: LD_STRING MULTIAVATARS
2479: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2480: LD_ADDR_OWVAR 34
2484: PUSH
2485: LD_VAR 0 2
2489: PPUSH
2490: CALL_OW 525
2494: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2495: LD_ADDR_OWVAR 27
2499: PUSH
2500: LD_VAR 0 2
2504: PPUSH
2505: CALL_OW 526
2509: ST_TO_ADDR
// end else
2510: GO 2544
// begin hc_gallery :=  ;
2512: LD_ADDR_OWVAR 33
2516: PUSH
2517: LD_STRING 
2519: ST_TO_ADDR
// hc_name :=  ;
2520: LD_ADDR_OWVAR 26
2524: PUSH
2525: LD_STRING 
2527: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2528: LD_ADDR_OWVAR 27
2532: PUSH
2533: LD_INT 1
2535: PPUSH
2536: LD_INT 2
2538: PPUSH
2539: CALL_OW 12
2543: ST_TO_ADDR
// end ; un := CreateHuman ;
2544: LD_ADDR_VAR 0 5
2548: PUSH
2549: CALL_OW 44
2553: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2554: LD_VAR 0 5
2558: PPUSH
2559: LD_EXP 12
2563: PUSH
2564: LD_EXP 7
2568: PUSH
2569: LD_VAR 0 2
2573: ARRAY
2574: ARRAY
2575: PUSH
2576: LD_INT 1
2578: ARRAY
2579: PPUSH
2580: LD_INT 0
2582: PPUSH
2583: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2587: LD_ADDR_EXP 24
2591: PUSH
2592: LD_EXP 24
2596: PPUSH
2597: LD_VAR 0 2
2601: PPUSH
2602: LD_VAR 0 5
2606: PPUSH
2607: CALL_OW 1
2611: ST_TO_ADDR
// end ; InitHc ;
2612: CALL_OW 19
// InitUc ;
2616: CALL_OW 18
// uc_side := i ;
2620: LD_ADDR_OWVAR 20
2624: PUSH
2625: LD_VAR 0 2
2629: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2630: LD_ADDR_OWVAR 21
2634: PUSH
2635: LD_EXP 9
2639: PUSH
2640: LD_VAR 0 2
2644: ARRAY
2645: ST_TO_ADDR
// hc_gallery :=  ;
2646: LD_ADDR_OWVAR 33
2650: PUSH
2651: LD_STRING 
2653: ST_TO_ADDR
// hc_name :=  ;
2654: LD_ADDR_OWVAR 26
2658: PUSH
2659: LD_STRING 
2661: ST_TO_ADDR
// hc_importance := 0 ;
2662: LD_ADDR_OWVAR 32
2666: PUSH
2667: LD_INT 0
2669: ST_TO_ADDR
// cl := 1 ;
2670: LD_ADDR_VAR 0 4
2674: PUSH
2675: LD_INT 1
2677: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2678: LD_ADDR_VAR 0 3
2682: PUSH
2683: DOUBLE
2684: LD_INT 2
2686: DEC
2687: ST_TO_ADDR
2688: LD_EXP 19
2692: PUSH
2693: FOR_TO
2694: IFFALSE 3066
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2696: LD_VAR 0 3
2700: PUSH
2701: LD_INT 1
2703: MINUS
2704: PUSH
2705: LD_EXP 19
2709: PUSH
2710: LD_INT 1
2712: MINUS
2713: PUSH
2714: LD_INT 4
2716: DIVREAL
2717: MOD
2718: PUSH
2719: LD_INT 0
2721: EQUAL
2722: IFFALSE 2738
// cl := cl + 1 ;
2724: LD_ADDR_VAR 0 4
2728: PUSH
2729: LD_VAR 0 4
2733: PUSH
2734: LD_INT 1
2736: PLUS
2737: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2738: LD_INT 0
2740: PPUSH
2741: LD_VAR 0 4
2745: PPUSH
2746: LD_EXP 20
2750: PPUSH
2751: CALL_OW 380
// un := CreateHuman ;
2755: LD_ADDR_VAR 0 5
2759: PUSH
2760: CALL_OW 44
2764: ST_TO_ADDR
// if j > copy then
2765: LD_VAR 0 3
2769: PUSH
2770: LD_VAR 0 8
2774: GREATER
2775: IFFALSE 2804
// copy := Replace ( copy , j , un ) else
2777: LD_ADDR_VAR 0 8
2781: PUSH
2782: LD_VAR 0 8
2786: PPUSH
2787: LD_VAR 0 3
2791: PPUSH
2792: LD_VAR 0 5
2796: PPUSH
2797: CALL_OW 1
2801: ST_TO_ADDR
2802: GO 2886
// begin CopySkills ( copy [ j ] , un ) ;
2804: LD_VAR 0 8
2808: PUSH
2809: LD_VAR 0 3
2813: ARRAY
2814: PPUSH
2815: LD_VAR 0 5
2819: PPUSH
2820: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2824: LD_VAR 0 5
2828: PPUSH
2829: LD_INT 2
2831: PPUSH
2832: LD_VAR 0 8
2836: PUSH
2837: LD_VAR 0 3
2841: ARRAY
2842: PPUSH
2843: LD_INT 2
2845: PPUSH
2846: CALL_OW 260
2850: PPUSH
2851: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2855: LD_VAR 0 5
2859: PPUSH
2860: LD_INT 1
2862: PPUSH
2863: LD_VAR 0 8
2867: PUSH
2868: LD_VAR 0 3
2872: ARRAY
2873: PPUSH
2874: LD_INT 1
2876: PPUSH
2877: CALL_OW 260
2881: PPUSH
2882: CALL_OW 239
// end ; if multi_pos_area then
2886: LD_EXP 12
2890: IFFALSE 3064
// begin if GetClass ( un ) = 3 then
2892: LD_VAR 0 5
2896: PPUSH
2897: CALL_OW 257
2901: PUSH
2902: LD_INT 3
2904: EQUAL
2905: IFFALSE 3031
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2907: LD_INT 3
2909: PUSH
2910: LD_INT 2
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: PUSH
2917: LD_VAR 0 3
2921: PUSH
2922: LD_INT 2
2924: MOD
2925: PUSH
2926: LD_INT 1
2928: PLUS
2929: ARRAY
2930: PPUSH
2931: LD_INT 2
2933: PPUSH
2934: LD_INT 1
2936: PPUSH
2937: LD_INT 5
2939: PUSH
2940: LD_INT 4
2942: PUSH
2943: LD_INT 3
2945: PUSH
2946: EMPTY
2947: LIST
2948: LIST
2949: LIST
2950: PUSH
2951: LD_VAR 0 3
2955: PUSH
2956: LD_INT 3
2958: MOD
2959: PUSH
2960: LD_INT 1
2962: PLUS
2963: ARRAY
2964: PPUSH
2965: LD_INT 100
2967: PPUSH
2968: CALL 14682 0 5
// veh := CreateVehicle ;
2972: LD_ADDR_VAR 0 6
2976: PUSH
2977: CALL_OW 45
2981: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
2982: LD_VAR 0 6
2986: PPUSH
2987: LD_EXP 12
2991: PUSH
2992: LD_EXP 7
2996: PUSH
2997: LD_VAR 0 2
3001: ARRAY
3002: ARRAY
3003: PUSH
3004: LD_INT 2
3006: ARRAY
3007: PPUSH
3008: LD_INT 0
3010: PPUSH
3011: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3015: LD_VAR 0 5
3019: PPUSH
3020: LD_VAR 0 6
3024: PPUSH
3025: CALL_OW 52
// continue ;
3029: GO 2693
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3031: LD_VAR 0 5
3035: PPUSH
3036: LD_EXP 12
3040: PUSH
3041: LD_EXP 7
3045: PUSH
3046: LD_VAR 0 2
3050: ARRAY
3051: ARRAY
3052: PUSH
3053: LD_INT 1
3055: ARRAY
3056: PPUSH
3057: LD_INT 0
3059: PPUSH
3060: CALL_OW 49
// end ; end ;
3064: GO 2693
3066: POP
3067: POP
// for j = 1 to 3 do
3068: LD_ADDR_VAR 0 3
3072: PUSH
3073: DOUBLE
3074: LD_INT 1
3076: DEC
3077: ST_TO_ADDR
3078: LD_INT 3
3080: PUSH
3081: FOR_TO
3082: IFFALSE 3174
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3084: LD_INT 2
3086: PUSH
3087: LD_INT 3
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PUSH
3094: LD_INT 1
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: CALL_OW 12
3104: ARRAY
3105: PPUSH
3106: LD_INT 2
3108: PPUSH
3109: LD_INT 3
3111: PPUSH
3112: LD_INT 11
3114: PUSH
3115: LD_INT 7
3117: PUSH
3118: LD_INT 4
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: LIST
3125: PUSH
3126: LD_VAR 0 3
3130: ARRAY
3131: PPUSH
3132: LD_INT 100
3134: PPUSH
3135: CALL 14682 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3139: CALL_OW 45
3143: PPUSH
3144: LD_EXP 12
3148: PUSH
3149: LD_EXP 7
3153: PUSH
3154: LD_VAR 0 2
3158: ARRAY
3159: ARRAY
3160: PUSH
3161: LD_INT 1
3163: ARRAY
3164: PPUSH
3165: LD_INT 0
3167: PPUSH
3168: CALL_OW 49
// end ;
3172: GO 3081
3174: POP
3175: POP
// end ;
3176: GO 2287
3178: POP
3179: POP
// end ;
3180: LD_VAR 0 1
3184: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3185: LD_INT 0
3187: PPUSH
3188: PPUSH
3189: PPUSH
3190: PPUSH
3191: PPUSH
// if not multi_support then
3192: LD_EXP 23
3196: NOT
3197: IFFALSE 3201
// exit ;
3199: GO 3729
// result := [ ] ;
3201: LD_ADDR_VAR 0 1
3205: PUSH
3206: EMPTY
3207: ST_TO_ADDR
// for i = 1 to 8 do
3208: LD_ADDR_VAR 0 2
3212: PUSH
3213: DOUBLE
3214: LD_INT 1
3216: DEC
3217: ST_TO_ADDR
3218: LD_INT 8
3220: PUSH
3221: FOR_TO
3222: IFFALSE 3727
// begin if multi_sides [ i ] then
3224: LD_EXP 7
3228: PUSH
3229: LD_VAR 0 2
3233: ARRAY
3234: IFFALSE 3725
// begin tmp := [ ] ;
3236: LD_ADDR_VAR 0 5
3240: PUSH
3241: EMPTY
3242: ST_TO_ADDR
// if multi_support = 1 then
3243: LD_EXP 23
3247: PUSH
3248: LD_INT 1
3250: EQUAL
3251: IFFALSE 3419
// begin uc_side := i ;
3253: LD_ADDR_OWVAR 20
3257: PUSH
3258: LD_VAR 0 2
3262: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3263: LD_ADDR_OWVAR 21
3267: PUSH
3268: LD_EXP 9
3272: PUSH
3273: LD_VAR 0 2
3277: ARRAY
3278: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3279: LD_INT 3
3281: PPUSH
3282: LD_INT 1
3284: PPUSH
3285: LD_INT 3
3287: PPUSH
3288: LD_INT 11
3290: PPUSH
3291: LD_INT 40
3293: PPUSH
3294: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3298: LD_ADDR_VAR 0 5
3302: PUSH
3303: LD_VAR 0 5
3307: PUSH
3308: CALL_OW 45
3312: ADD
3313: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3314: LD_INT 2
3316: PPUSH
3317: LD_INT 1
3319: PPUSH
3320: LD_INT 3
3322: PPUSH
3323: LD_INT 5
3325: PPUSH
3326: LD_INT 40
3328: PPUSH
3329: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3333: LD_ADDR_VAR 0 5
3337: PUSH
3338: LD_VAR 0 5
3342: PUSH
3343: CALL_OW 45
3347: ADD
3348: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3349: LD_INT 2
3351: PPUSH
3352: LD_INT 3
3354: PPUSH
3355: LD_INT 3
3357: PPUSH
3358: LD_INT 4
3360: PPUSH
3361: LD_INT 40
3363: PPUSH
3364: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3368: LD_ADDR_VAR 0 5
3372: PUSH
3373: LD_VAR 0 5
3377: PUSH
3378: CALL_OW 45
3382: ADD
3383: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3384: LD_INT 3
3386: PPUSH
3387: LD_INT 2
3389: PPUSH
3390: LD_INT 3
3392: PPUSH
3393: LD_INT 9
3395: PPUSH
3396: LD_INT 40
3398: PPUSH
3399: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3403: LD_ADDR_VAR 0 5
3407: PUSH
3408: LD_VAR 0 5
3412: PUSH
3413: CALL_OW 45
3417: ADD
3418: ST_TO_ADDR
// end ; if multi_support = 2 then
3419: LD_EXP 23
3423: PUSH
3424: LD_INT 2
3426: EQUAL
3427: IFFALSE 3700
// begin uc_side := i ;
3429: LD_ADDR_OWVAR 20
3433: PUSH
3434: LD_VAR 0 2
3438: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3439: LD_ADDR_OWVAR 21
3443: PUSH
3444: LD_EXP 9
3448: PUSH
3449: LD_VAR 0 2
3453: ARRAY
3454: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3455: LD_INT 3
3457: PPUSH
3458: LD_INT 1
3460: PPUSH
3461: LD_INT 3
3463: PPUSH
3464: LD_INT 11
3466: PPUSH
3467: LD_INT 40
3469: PPUSH
3470: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3474: LD_ADDR_VAR 0 5
3478: PUSH
3479: LD_VAR 0 5
3483: PUSH
3484: CALL_OW 45
3488: ADD
3489: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3490: LD_INT 3
3492: PPUSH
3493: LD_INT 3
3495: PPUSH
3496: LD_INT 3
3498: PPUSH
3499: LD_INT 12
3501: PPUSH
3502: LD_INT 40
3504: PPUSH
3505: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3509: LD_ADDR_VAR 0 5
3513: PUSH
3514: LD_VAR 0 5
3518: PUSH
3519: CALL_OW 45
3523: ADD
3524: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3525: LD_INT 2
3527: PPUSH
3528: LD_INT 3
3530: PPUSH
3531: LD_INT 3
3533: PPUSH
3534: LD_INT 5
3536: PPUSH
3537: LD_INT 40
3539: PPUSH
3540: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3544: LD_ADDR_VAR 0 5
3548: PUSH
3549: LD_VAR 0 5
3553: PUSH
3554: CALL_OW 45
3558: ADD
3559: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3560: LD_INT 4
3562: PPUSH
3563: LD_INT 1
3565: PPUSH
3566: LD_INT 3
3568: PPUSH
3569: LD_INT 6
3571: PPUSH
3572: LD_INT 40
3574: PPUSH
3575: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3579: LD_ADDR_VAR 0 5
3583: PUSH
3584: LD_VAR 0 5
3588: PUSH
3589: CALL_OW 45
3593: ADD
3594: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3595: LD_INT 2
3597: PPUSH
3598: LD_INT 3
3600: PPUSH
3601: LD_INT 3
3603: PPUSH
3604: LD_INT 9
3606: PPUSH
3607: LD_INT 40
3609: PPUSH
3610: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3614: LD_ADDR_VAR 0 5
3618: PUSH
3619: LD_VAR 0 5
3623: PUSH
3624: CALL_OW 45
3628: ADD
3629: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3630: LD_INT 2
3632: PPUSH
3633: LD_INT 3
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 9
3641: PPUSH
3642: LD_INT 40
3644: PPUSH
3645: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3649: LD_ADDR_VAR 0 5
3653: PUSH
3654: LD_VAR 0 5
3658: PUSH
3659: CALL_OW 45
3663: ADD
3664: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3665: LD_INT 4
3667: PPUSH
3668: LD_INT 1
3670: PPUSH
3671: LD_INT 3
3673: PPUSH
3674: LD_INT 6
3676: PPUSH
3677: LD_INT 40
3679: PPUSH
3680: CALL 14682 0 5
// tmp := tmp ^ CreateVehicle ;
3684: LD_ADDR_VAR 0 5
3688: PUSH
3689: LD_VAR 0 5
3693: PUSH
3694: CALL_OW 45
3698: ADD
3699: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3700: LD_ADDR_VAR 0 1
3704: PUSH
3705: LD_VAR 0 1
3709: PPUSH
3710: LD_VAR 0 2
3714: PPUSH
3715: LD_VAR 0 5
3719: PPUSH
3720: CALL_OW 2
3724: ST_TO_ADDR
// end ; end ;
3725: GO 3221
3727: POP
3728: POP
// end ;
3729: LD_VAR 0 1
3733: RET
// export function Multiplayer_Start ( ) ; begin
3734: LD_INT 0
3736: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3737: CALL 2263 0 0
// Multiplayer_InitPointSystem ( ) ;
3741: CALL 4658 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3745: LD_INT 20
3747: PPUSH
3748: CALL 4834 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3752: LD_INT 150
3754: PPUSH
3755: CALL 4834 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3759: LD_INT 5
3761: PPUSH
3762: CALL 4834 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3766: LD_INT 40
3768: NEG
3769: PPUSH
3770: CALL 4834 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3774: LD_INT 200
3776: PPUSH
3777: CALL 4834 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3781: LD_INT 2
3783: PPUSH
3784: CALL 4834 0 1
// Multiplayer_SpawnArtifact ;
3788: CALL 5274 0 0
// if multi_support then
3792: LD_EXP 23
3796: IFFALSE 3808
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3798: LD_ADDR_EXP 27
3802: PUSH
3803: CALL 3185 0 0
3807: ST_TO_ADDR
// game := true ;
3808: LD_ADDR_EXP 2
3812: PUSH
3813: LD_INT 1
3815: ST_TO_ADDR
// if multi_sides [ your_side ] then
3816: LD_EXP 7
3820: PUSH
3821: LD_OWVAR 2
3825: ARRAY
3826: IFFALSE 3853
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3828: LD_INT 22
3830: PUSH
3831: LD_OWVAR 2
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: PPUSH
3840: CALL_OW 69
3844: PUSH
3845: LD_INT 1
3847: ARRAY
3848: PPUSH
3849: CALL_OW 87
// end ;
3853: LD_VAR 0 1
3857: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3858: LD_INT 0
3860: PPUSH
3861: PPUSH
3862: PPUSH
3863: PPUSH
3864: PPUSH
// reinforcements_arrive := 0 ;
3865: LD_ADDR_VAR 0 5
3869: PUSH
3870: LD_INT 0
3872: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3873: LD_INT 35
3875: PPUSH
3876: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3880: LD_OWVAR 1
3884: PUSH
3885: LD_INT 21000
3887: GREATER
3888: PUSH
3889: LD_EXP 28
3893: NOT
3894: AND
3895: PUSH
3896: LD_EXP 23
3900: PUSH
3901: LD_INT 1
3903: EQUAL
3904: AND
3905: IFFALSE 4100
// begin multi_reinforcements_spawned := 1 ;
3907: LD_ADDR_EXP 28
3911: PUSH
3912: LD_INT 1
3914: ST_TO_ADDR
// for i = 1 to 8 do
3915: LD_ADDR_VAR 0 2
3919: PUSH
3920: DOUBLE
3921: LD_INT 1
3923: DEC
3924: ST_TO_ADDR
3925: LD_INT 8
3927: PUSH
3928: FOR_TO
3929: IFFALSE 4088
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3931: LD_EXP 7
3935: PUSH
3936: LD_VAR 0 2
3940: ARRAY
3941: PUSH
3942: LD_EXP 25
3946: PUSH
3947: LD_VAR 0 2
3951: ARRAY
3952: NOT
3953: AND
3954: PUSH
3955: LD_EXP 27
3959: PUSH
3960: LD_VAR 0 2
3964: ARRAY
3965: AND
3966: IFFALSE 4086
// begin tmp := multi_reinforcements [ i ] ;
3968: LD_ADDR_VAR 0 4
3972: PUSH
3973: LD_EXP 27
3977: PUSH
3978: LD_VAR 0 2
3982: ARRAY
3983: ST_TO_ADDR
// for j = 1 to 4 do
3984: LD_ADDR_VAR 0 3
3988: PUSH
3989: DOUBLE
3990: LD_INT 1
3992: DEC
3993: ST_TO_ADDR
3994: LD_INT 4
3996: PUSH
3997: FOR_TO
3998: IFFALSE 4059
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4000: LD_VAR 0 4
4004: PUSH
4005: LD_VAR 0 3
4009: ARRAY
4010: PPUSH
4011: LD_EXP 12
4015: PUSH
4016: LD_EXP 7
4020: PUSH
4021: LD_VAR 0 2
4025: ARRAY
4026: ARRAY
4027: PUSH
4028: LD_INT 2
4030: ARRAY
4031: PPUSH
4032: LD_INT 0
4034: PPUSH
4035: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4039: LD_ADDR_VAR 0 4
4043: PUSH
4044: LD_VAR 0 4
4048: PPUSH
4049: LD_INT 1
4051: PPUSH
4052: CALL_OW 3
4056: ST_TO_ADDR
// end ;
4057: GO 3997
4059: POP
4060: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4061: LD_ADDR_EXP 27
4065: PUSH
4066: LD_EXP 27
4070: PPUSH
4071: LD_VAR 0 2
4075: PPUSH
4076: LD_VAR 0 4
4080: PPUSH
4081: CALL_OW 1
4085: ST_TO_ADDR
// end ; end ;
4086: GO 3928
4088: POP
4089: POP
// reinforcements_arrive := tick ;
4090: LD_ADDR_VAR 0 5
4094: PUSH
4095: LD_OWVAR 1
4099: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4100: LD_VAR 0 5
4104: PUSH
4105: LD_INT 21000
4107: PLUS
4108: PUSH
4109: LD_OWVAR 1
4113: LESS
4114: PUSH
4115: LD_EXP 28
4119: PUSH
4120: LD_INT 1
4122: EQUAL
4123: AND
4124: PUSH
4125: LD_EXP 23
4129: PUSH
4130: LD_INT 2
4132: EQUAL
4133: AND
4134: IFFALSE 4319
// begin multi_reinforcements_spawned := 2 ;
4136: LD_ADDR_EXP 28
4140: PUSH
4141: LD_INT 2
4143: ST_TO_ADDR
// for i = 1 to 8 do
4144: LD_ADDR_VAR 0 2
4148: PUSH
4149: DOUBLE
4150: LD_INT 1
4152: DEC
4153: ST_TO_ADDR
4154: LD_INT 8
4156: PUSH
4157: FOR_TO
4158: IFFALSE 4317
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4160: LD_EXP 7
4164: PUSH
4165: LD_VAR 0 2
4169: ARRAY
4170: PUSH
4171: LD_EXP 25
4175: PUSH
4176: LD_VAR 0 2
4180: ARRAY
4181: NOT
4182: AND
4183: PUSH
4184: LD_EXP 27
4188: PUSH
4189: LD_VAR 0 2
4193: ARRAY
4194: AND
4195: IFFALSE 4315
// begin tmp := multi_reinforcements [ i ] ;
4197: LD_ADDR_VAR 0 4
4201: PUSH
4202: LD_EXP 27
4206: PUSH
4207: LD_VAR 0 2
4211: ARRAY
4212: ST_TO_ADDR
// for j = 1 to 3 do
4213: LD_ADDR_VAR 0 3
4217: PUSH
4218: DOUBLE
4219: LD_INT 1
4221: DEC
4222: ST_TO_ADDR
4223: LD_INT 3
4225: PUSH
4226: FOR_TO
4227: IFFALSE 4288
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4229: LD_VAR 0 4
4233: PUSH
4234: LD_VAR 0 3
4238: ARRAY
4239: PPUSH
4240: LD_EXP 12
4244: PUSH
4245: LD_EXP 7
4249: PUSH
4250: LD_VAR 0 2
4254: ARRAY
4255: ARRAY
4256: PUSH
4257: LD_INT 2
4259: ARRAY
4260: PPUSH
4261: LD_INT 0
4263: PPUSH
4264: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4268: LD_ADDR_VAR 0 4
4272: PUSH
4273: LD_VAR 0 4
4277: PPUSH
4278: LD_INT 1
4280: PPUSH
4281: CALL_OW 3
4285: ST_TO_ADDR
// end ;
4286: GO 4226
4288: POP
4289: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4290: LD_ADDR_EXP 27
4294: PUSH
4295: LD_EXP 27
4299: PPUSH
4300: LD_VAR 0 2
4304: PPUSH
4305: LD_VAR 0 4
4309: PPUSH
4310: CALL_OW 1
4314: ST_TO_ADDR
// end ; end ;
4315: GO 4157
4317: POP
4318: POP
// end ; if not multi_custom_commanders then
4319: LD_EXP 16
4323: NOT
4324: IFFALSE 4437
// begin for i = 1 to 8 do
4326: LD_ADDR_VAR 0 2
4330: PUSH
4331: DOUBLE
4332: LD_INT 1
4334: DEC
4335: ST_TO_ADDR
4336: LD_INT 8
4338: PUSH
4339: FOR_TO
4340: IFFALSE 4411
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4342: LD_INT 22
4344: PUSH
4345: LD_VAR 0 2
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PPUSH
4354: CALL_OW 69
4358: PUSH
4359: LD_INT 0
4361: EQUAL
4362: PUSH
4363: LD_EXP 25
4367: PUSH
4368: LD_VAR 0 2
4372: ARRAY
4373: NOT
4374: AND
4375: IFFALSE 4409
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4377: LD_ADDR_EXP 25
4381: PUSH
4382: LD_EXP 25
4386: PPUSH
4387: LD_VAR 0 2
4391: PPUSH
4392: LD_INT 1
4394: PPUSH
4395: CALL_OW 1
4399: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4400: LD_VAR 0 2
4404: PPUSH
4405: CALL 4904 0 1
// end ; end ;
4409: GO 4339
4411: POP
4412: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4413: LD_EXP 25
4417: PPUSH
4418: CALL 11956 0 1
4422: PUSH
4423: LD_EXP 7
4427: PPUSH
4428: CALL 11956 0 1
4432: EQUAL
4433: IFFALSE 4437
// break ;
4435: GO 4472
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4437: LD_INT 22
4439: PUSH
4440: LD_EXP 3
4444: PUSH
4445: EMPTY
4446: LIST
4447: LIST
4448: PPUSH
4449: CALL_OW 69
4453: PUSH
4454: LD_INT 0
4456: EQUAL
4457: PUSH
4458: LD_EXP 2
4462: AND
4463: PUSH
4464: LD_EXP 24
4468: NOT
4469: OR
4470: IFFALSE 3873
// game := false ;
4472: LD_ADDR_EXP 2
4476: PUSH
4477: LD_INT 0
4479: ST_TO_ADDR
// for i = 1 to 8 do
4480: LD_ADDR_VAR 0 2
4484: PUSH
4485: DOUBLE
4486: LD_INT 1
4488: DEC
4489: ST_TO_ADDR
4490: LD_INT 8
4492: PUSH
4493: FOR_TO
4494: IFFALSE 4530
// begin if multi_sides [ i ] then
4496: LD_EXP 7
4500: PUSH
4501: LD_VAR 0 2
4505: ARRAY
4506: IFFALSE 4528
// SetMultiScore ( i , multi_points [ i ] ) ;
4508: LD_VAR 0 2
4512: PPUSH
4513: LD_EXP 29
4517: PUSH
4518: LD_VAR 0 2
4522: ARRAY
4523: PPUSH
4524: CALL_OW 506
// end ;
4528: GO 4493
4530: POP
4531: POP
// if multi_loosers [ your_side ] then
4532: LD_EXP 25
4536: PUSH
4537: LD_OWVAR 2
4541: ARRAY
4542: IFFALSE 4550
// YouLostInMultiplayer else
4544: CALL_OW 107
4548: GO 4554
// YouWinInMultiplayer ;
4550: CALL_OW 106
// end ;
4554: LD_VAR 0 1
4558: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4559: LD_INT 0
4561: PPUSH
4562: PPUSH
// result := [ #tick , tick ] ;
4563: LD_ADDR_VAR 0 1
4567: PUSH
4568: LD_STRING #tick
4570: PUSH
4571: LD_OWVAR 1
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: ST_TO_ADDR
// for i = 1 to 8 do
4580: LD_ADDR_VAR 0 2
4584: PUSH
4585: DOUBLE
4586: LD_INT 1
4588: DEC
4589: ST_TO_ADDR
4590: LD_INT 8
4592: PUSH
4593: FOR_TO
4594: IFFALSE 4651
// begin if multi_sides [ i ] then
4596: LD_EXP 7
4600: PUSH
4601: LD_VAR 0 2
4605: ARRAY
4606: IFFALSE 4649
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4608: LD_ADDR_VAR 0 1
4612: PUSH
4613: LD_VAR 0 1
4617: PUSH
4618: LD_STRING #coop-points
4620: PUSH
4621: LD_VAR 0 2
4625: PUSH
4626: LD_VAR 0 2
4630: PUSH
4631: LD_EXP 29
4635: PUSH
4636: LD_VAR 0 2
4640: ARRAY
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: LIST
4646: LIST
4647: ADD
4648: ST_TO_ADDR
// end ; end ;
4649: GO 4593
4651: POP
4652: POP
// end ;
4653: LD_VAR 0 1
4657: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4658: LD_INT 0
4660: PPUSH
4661: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4662: LD_ADDR_EXP 29
4666: PUSH
4667: LD_INT 0
4669: PUSH
4670: LD_INT 0
4672: PUSH
4673: LD_INT 0
4675: PUSH
4676: LD_INT 0
4678: PUSH
4679: LD_INT 0
4681: PUSH
4682: LD_INT 0
4684: PUSH
4685: LD_INT 0
4687: PUSH
4688: LD_INT 0
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: LIST
4695: LIST
4696: LIST
4697: LIST
4698: LIST
4699: LIST
4700: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4701: LD_ADDR_EXP 30
4705: PUSH
4706: EMPTY
4707: ST_TO_ADDR
// end ;
4708: LD_VAR 0 1
4712: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4713: LD_INT 0
4715: PPUSH
// if not multi_points or not side or side > 8 then
4716: LD_EXP 29
4720: NOT
4721: PUSH
4722: LD_VAR 0 1
4726: NOT
4727: OR
4728: PUSH
4729: LD_VAR 0 1
4733: PUSH
4734: LD_INT 8
4736: GREATER
4737: OR
4738: IFFALSE 4742
// exit ;
4740: GO 4779
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4742: LD_ADDR_EXP 29
4746: PUSH
4747: LD_EXP 29
4751: PPUSH
4752: LD_VAR 0 1
4756: PPUSH
4757: LD_EXP 29
4761: PUSH
4762: LD_VAR 0 1
4766: ARRAY
4767: PUSH
4768: LD_VAR 0 2
4772: PLUS
4773: PPUSH
4774: CALL_OW 1
4778: ST_TO_ADDR
// end ;
4779: LD_VAR 0 3
4783: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4784: LD_INT 0
4786: PPUSH
// if not multi_points or not side or side > 8 then
4787: LD_EXP 29
4791: NOT
4792: PUSH
4793: LD_VAR 0 1
4797: NOT
4798: OR
4799: PUSH
4800: LD_VAR 0 1
4804: PUSH
4805: LD_INT 8
4807: GREATER
4808: OR
4809: IFFALSE 4813
// exit ;
4811: GO 4829
// result := multi_points [ side ] ;
4813: LD_ADDR_VAR 0 2
4817: PUSH
4818: LD_EXP 29
4822: PUSH
4823: LD_VAR 0 1
4827: ARRAY
4828: ST_TO_ADDR
// end ;
4829: LD_VAR 0 2
4833: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4834: LD_INT 0
4836: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4837: LD_ADDR_EXP 30
4841: PUSH
4842: LD_EXP 30
4846: PPUSH
4847: LD_EXP 30
4851: PUSH
4852: LD_INT 1
4854: PLUS
4855: PPUSH
4856: LD_VAR 0 1
4860: PPUSH
4861: CALL_OW 2
4865: ST_TO_ADDR
// end ;
4866: LD_VAR 0 2
4870: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4871: LD_INT 0
4873: PPUSH
// if not id then
4874: LD_VAR 0 1
4878: NOT
4879: IFFALSE 4883
// exit ;
4881: GO 4899
// result := multi_points_conditions [ id ] ;
4883: LD_ADDR_VAR 0 2
4887: PUSH
4888: LD_EXP 30
4892: PUSH
4893: LD_VAR 0 1
4897: ARRAY
4898: ST_TO_ADDR
// end ;
4899: LD_VAR 0 2
4903: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4904: LD_INT 0
4906: PPUSH
4907: PPUSH
4908: PPUSH
4909: PPUSH
4910: PPUSH
// players := [ ] ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: EMPTY
4917: ST_TO_ADDR
// for i = 1 to 8 do
4918: LD_ADDR_VAR 0 4
4922: PUSH
4923: DOUBLE
4924: LD_INT 1
4926: DEC
4927: ST_TO_ADDR
4928: LD_INT 8
4930: PUSH
4931: FOR_TO
4932: IFFALSE 4991
// begin if i = side then
4934: LD_VAR 0 4
4938: PUSH
4939: LD_VAR 0 1
4943: EQUAL
4944: IFFALSE 4948
// continue ;
4946: GO 4931
// if multi_sides [ i ] and not multi_loosers [ i ] then
4948: LD_EXP 7
4952: PUSH
4953: LD_VAR 0 4
4957: ARRAY
4958: PUSH
4959: LD_EXP 25
4963: PUSH
4964: LD_VAR 0 4
4968: ARRAY
4969: NOT
4970: AND
4971: IFFALSE 4989
// players := players ^ i ;
4973: LD_ADDR_VAR 0 3
4977: PUSH
4978: LD_VAR 0 3
4982: PUSH
4983: LD_VAR 0 4
4987: ADD
4988: ST_TO_ADDR
// end ;
4989: GO 4931
4991: POP
4992: POP
// if not players then
4993: LD_VAR 0 3
4997: NOT
4998: IFFALSE 5002
// exit ;
5000: GO 5269
// if players = 1 then
5002: LD_VAR 0 3
5006: PUSH
5007: LD_INT 1
5009: EQUAL
5010: IFFALSE 5071
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5012: LD_ADDR_VAR 0 4
5016: PUSH
5017: LD_INT 22
5019: PUSH
5020: LD_VAR 0 1
5024: PUSH
5025: EMPTY
5026: LIST
5027: LIST
5028: PUSH
5029: LD_INT 51
5031: PUSH
5032: EMPTY
5033: LIST
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PPUSH
5039: CALL_OW 69
5043: PUSH
5044: FOR_IN
5045: IFFALSE 5067
// SetSide ( i , players [ 1 ] ) ;
5047: LD_VAR 0 4
5051: PPUSH
5052: LD_VAR 0 3
5056: PUSH
5057: LD_INT 1
5059: ARRAY
5060: PPUSH
5061: CALL_OW 235
5065: GO 5044
5067: POP
5068: POP
// end else
5069: GO 5269
// begin j := 1 ;
5071: LD_ADDR_VAR 0 5
5075: PUSH
5076: LD_INT 1
5078: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5079: LD_ADDR_VAR 0 4
5083: PUSH
5084: LD_INT 22
5086: PUSH
5087: LD_VAR 0 1
5091: PUSH
5092: EMPTY
5093: LIST
5094: LIST
5095: PUSH
5096: LD_INT 2
5098: PUSH
5099: LD_INT 21
5101: PUSH
5102: LD_INT 1
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 51
5111: PUSH
5112: EMPTY
5113: LIST
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 21
5121: PUSH
5122: LD_INT 2
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PPUSH
5138: CALL_OW 69
5142: PUSH
5143: FOR_IN
5144: IFFALSE 5267
// begin SetSide ( i , players [ j ] ) ;
5146: LD_VAR 0 4
5150: PPUSH
5151: LD_VAR 0 3
5155: PUSH
5156: LD_VAR 0 5
5160: ARRAY
5161: PPUSH
5162: CALL_OW 235
// if IsDrivenBy ( i ) then
5166: LD_VAR 0 4
5170: PPUSH
5171: CALL_OW 311
5175: IFFALSE 5202
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5177: LD_VAR 0 4
5181: PPUSH
5182: CALL_OW 311
5186: PPUSH
5187: LD_VAR 0 3
5191: PUSH
5192: LD_VAR 0 5
5196: ARRAY
5197: PPUSH
5198: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5202: LD_VAR 0 4
5206: PPUSH
5207: CALL_OW 310
5211: PPUSH
5212: CALL_OW 247
5216: PUSH
5217: LD_INT 3
5219: EQUAL
5220: IFFALSE 5231
// ComExitBuilding ( i ) ;
5222: LD_VAR 0 4
5226: PPUSH
5227: CALL_OW 122
// j := j + 1 ;
5231: LD_ADDR_VAR 0 5
5235: PUSH
5236: LD_VAR 0 5
5240: PUSH
5241: LD_INT 1
5243: PLUS
5244: ST_TO_ADDR
// if j > players then
5245: LD_VAR 0 5
5249: PUSH
5250: LD_VAR 0 3
5254: GREATER
5255: IFFALSE 5265
// j := 1 ;
5257: LD_ADDR_VAR 0 5
5261: PUSH
5262: LD_INT 1
5264: ST_TO_ADDR
// end ;
5265: GO 5143
5267: POP
5268: POP
// end ; end ;
5269: LD_VAR 0 2
5273: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5274: LD_INT 0
5276: PPUSH
5277: PPUSH
5278: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5279: LD_ADDR_VAR 0 3
5283: PUSH
5284: LD_INT 5
5286: PUSH
5287: LD_INT 10
5289: PUSH
5290: EMPTY
5291: LIST
5292: LIST
5293: PUSH
5294: LD_INT 120
5296: PUSH
5297: LD_INT 2
5299: PUSH
5300: EMPTY
5301: LIST
5302: LIST
5303: PUSH
5304: LD_INT 101
5306: PUSH
5307: LD_INT 8
5309: PUSH
5310: EMPTY
5311: LIST
5312: LIST
5313: PUSH
5314: LD_INT 27
5316: PUSH
5317: LD_INT 4
5319: PUSH
5320: EMPTY
5321: LIST
5322: LIST
5323: PUSH
5324: EMPTY
5325: LIST
5326: LIST
5327: LIST
5328: LIST
5329: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5330: LD_ADDR_VAR 0 2
5334: PUSH
5335: LD_INT 1
5337: PPUSH
5338: LD_VAR 0 3
5342: PPUSH
5343: CALL_OW 12
5347: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5348: LD_INT 4
5350: PPUSH
5351: LD_INT 5
5353: PPUSH
5354: LD_VAR 0 3
5358: PUSH
5359: LD_VAR 0 2
5363: ARRAY
5364: PUSH
5365: LD_INT 1
5367: ARRAY
5368: PPUSH
5369: LD_VAR 0 3
5373: PUSH
5374: LD_VAR 0 2
5378: ARRAY
5379: PUSH
5380: LD_INT 2
5382: ARRAY
5383: PPUSH
5384: LD_INT 0
5386: PPUSH
5387: CALL_OW 58
// end ;
5391: LD_VAR 0 1
5395: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5396: LD_INT 0
5398: PPUSH
// if not side or side > 8 then
5399: LD_VAR 0 1
5403: NOT
5404: PUSH
5405: LD_VAR 0 1
5409: PUSH
5410: LD_INT 8
5412: GREATER
5413: OR
5414: IFFALSE 5418
// exit ;
5416: GO 5435
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5418: LD_VAR 0 1
5422: PPUSH
5423: LD_INT 6
5425: PPUSH
5426: CALL 4871 0 1
5430: PPUSH
5431: CALL 4713 0 2
// end ;
5435: LD_VAR 0 2
5439: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5440: LD_INT 0
5442: PPUSH
// if not side or side > 8 then
5443: LD_VAR 0 1
5447: NOT
5448: PUSH
5449: LD_VAR 0 1
5453: PUSH
5454: LD_INT 8
5456: GREATER
5457: OR
5458: IFFALSE 5462
// exit ;
5460: GO 5479
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5462: LD_VAR 0 1
5466: PPUSH
5467: LD_INT 4
5469: PPUSH
5470: CALL 4871 0 1
5474: PPUSH
5475: CALL 4713 0 2
// end ;
5479: LD_VAR 0 2
5483: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5484: LD_INT 0
5486: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5487: LD_VAR 0 1
5491: NOT
5492: PUSH
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 8
5500: GREATER
5501: OR
5502: PUSH
5503: LD_VAR 0 2
5507: PUSH
5508: LD_INT 2
5510: PUSH
5511: LD_INT 6
5513: PUSH
5514: LD_INT 36
5516: PUSH
5517: LD_INT 0
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: LIST
5524: LIST
5525: IN
5526: NOT
5527: OR
5528: IFFALSE 5532
// exit ;
5530: GO 5549
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5532: LD_VAR 0 1
5536: PPUSH
5537: LD_INT 3
5539: PPUSH
5540: CALL 4871 0 1
5544: PPUSH
5545: CALL 4713 0 2
// end ;
5549: LD_VAR 0 3
5553: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5554: LD_INT 0
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
5560: PPUSH
5561: PPUSH
// if not un then
5562: LD_VAR 0 1
5566: NOT
5567: IFFALSE 5571
// exit ;
5569: GO 5795
// if not points then
5571: LD_VAR 0 2
5575: NOT
5576: IFFALSE 5593
// gained_points := Multiplayer_GetCondition ( 1 ) else
5578: LD_ADDR_VAR 0 8
5582: PUSH
5583: LD_INT 1
5585: PPUSH
5586: CALL 4871 0 1
5590: ST_TO_ADDR
5591: GO 5603
// gained_points := points ;
5593: LD_ADDR_VAR 0 8
5597: PUSH
5598: LD_VAR 0 2
5602: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5603: LD_ADDR_VAR 0 6
5607: PUSH
5608: LD_VAR 0 1
5612: PPUSH
5613: CALL_OW 503
5617: ST_TO_ADDR
// if last_shoot > - 1 then
5618: LD_VAR 0 6
5622: PUSH
5623: LD_INT 1
5625: NEG
5626: GREATER
5627: IFFALSE 5639
// begin side := last_shoot ;
5629: LD_ADDR_VAR 0 4
5633: PUSH
5634: LD_VAR 0 6
5638: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5639: LD_ADDR_VAR 0 7
5643: PUSH
5644: LD_OWVAR 3
5648: PUSH
5649: LD_INT 22
5651: PUSH
5652: LD_VAR 0 1
5656: PPUSH
5657: CALL_OW 255
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PPUSH
5666: CALL_OW 69
5670: DIFF
5671: PPUSH
5672: LD_VAR 0 1
5676: PPUSH
5677: CALL_OW 74
5681: ST_TO_ADDR
// if nearest_unit then
5682: LD_VAR 0 7
5686: IFFALSE 5703
// side2 := GetSide ( nearest_unit ) ;
5688: LD_ADDR_VAR 0 5
5692: PUSH
5693: LD_VAR 0 7
5697: PPUSH
5698: CALL_OW 255
5702: ST_TO_ADDR
// if not side and not side2 then
5703: LD_VAR 0 4
5707: NOT
5708: PUSH
5709: LD_VAR 0 5
5713: NOT
5714: AND
5715: IFFALSE 5719
// exit ;
5717: GO 5795
// if side = side2 then
5719: LD_VAR 0 4
5723: PUSH
5724: LD_VAR 0 5
5728: EQUAL
5729: IFFALSE 5747
// Multiplayer_AddPoints ( side , gained_points ) else
5731: LD_VAR 0 4
5735: PPUSH
5736: LD_VAR 0 8
5740: PPUSH
5741: CALL 4713 0 2
5745: GO 5795
// begin if side then
5747: LD_VAR 0 4
5751: IFFALSE 5771
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5753: LD_VAR 0 4
5757: PPUSH
5758: LD_VAR 0 8
5762: PUSH
5763: LD_INT 2
5765: DIV
5766: PPUSH
5767: CALL 4713 0 2
// if side2 then
5771: LD_VAR 0 5
5775: IFFALSE 5795
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5777: LD_VAR 0 5
5781: PPUSH
5782: LD_VAR 0 8
5786: PUSH
5787: LD_INT 2
5789: DIV
5790: PPUSH
5791: CALL 4713 0 2
// end ; end ;
5795: LD_VAR 0 3
5799: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5800: LD_INT 0
5802: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5803: LD_VAR 0 1
5807: PPUSH
5808: LD_INT 2
5810: PPUSH
5811: CALL 4871 0 1
5815: PPUSH
5816: CALL 4713 0 2
// end ; end_of_file
5820: LD_VAR 0 2
5824: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5825: LD_INT 0
5827: PPUSH
5828: PPUSH
5829: PPUSH
5830: PPUSH
5831: PPUSH
5832: PPUSH
5833: PPUSH
5834: PPUSH
5835: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5836: LD_ADDR_VAR 0 9
5840: PUSH
5841: LD_INT 22
5843: PUSH
5844: LD_INT 2
5846: PUSH
5847: EMPTY
5848: LIST
5849: LIST
5850: PPUSH
5851: CALL_OW 69
5855: ST_TO_ADDR
// side_bot := side ;
5856: LD_ADDR_EXP 3
5860: PUSH
5861: LD_VAR 0 1
5865: ST_TO_ADDR
// if tmp and side <> 2 then
5866: LD_VAR 0 9
5870: PUSH
5871: LD_VAR 0 1
5875: PUSH
5876: LD_INT 2
5878: NONEQUAL
5879: AND
5880: IFFALSE 5913
// for i in tmp do
5882: LD_ADDR_VAR 0 3
5886: PUSH
5887: LD_VAR 0 9
5891: PUSH
5892: FOR_IN
5893: IFFALSE 5911
// SetSide ( i , side ) ;
5895: LD_VAR 0 3
5899: PPUSH
5900: LD_VAR 0 1
5904: PPUSH
5905: CALL_OW 235
5909: GO 5892
5911: POP
5912: POP
// techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5913: LD_ADDR_VAR 0 10
5917: PUSH
5918: LD_INT 11
5920: PUSH
5921: LD_INT 4
5923: PUSH
5924: LD_INT 3
5926: PUSH
5927: LD_INT 5
5929: PUSH
5930: LD_INT 66
5932: PUSH
5933: LD_INT 67
5935: PUSH
5936: LD_INT 53
5938: PUSH
5939: LD_INT 18
5941: PUSH
5942: LD_INT 40
5944: PUSH
5945: LD_INT 22
5947: PUSH
5948: LD_INT 72
5950: PUSH
5951: LD_INT 55
5953: PUSH
5954: EMPTY
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: ST_TO_ADDR
// for i in techs do
5968: LD_ADDR_VAR 0 3
5972: PUSH
5973: LD_VAR 0 10
5977: PUSH
5978: FOR_IN
5979: IFFALSE 6000
// SetTech ( i , side , state_researched ) ;
5981: LD_VAR 0 3
5985: PPUSH
5986: LD_VAR 0 1
5990: PPUSH
5991: LD_INT 2
5993: PPUSH
5994: CALL_OW 322
5998: GO 5978
6000: POP
6001: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6002: LD_ADDR_VAR 0 8
6006: PUSH
6007: LD_INT 6
6009: PUSH
6010: LD_INT 7
6012: PUSH
6013: LD_INT 8
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: PUSH
6021: LD_OWVAR 67
6025: ARRAY
6026: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6027: LD_INT 69
6029: PUSH
6030: EMPTY
6031: LIST
6032: PPUSH
6033: LD_INT 141
6035: PPUSH
6036: CALL_OW 169
// Wait ( 1 ) ;
6040: LD_INT 1
6042: PPUSH
6043: CALL_OW 67
// uc_side := side ;
6047: LD_ADDR_OWVAR 20
6051: PUSH
6052: LD_VAR 0 1
6056: ST_TO_ADDR
// uc_nation := 2 ;
6057: LD_ADDR_OWVAR 21
6061: PUSH
6062: LD_INT 2
6064: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
6065: LD_ADDR_EXP 33
6069: PUSH
6070: LD_INT 94
6072: PPUSH
6073: LD_INT 35
6075: PPUSH
6076: LD_STRING dammam
6078: PPUSH
6079: LD_VAR 0 8
6083: PPUSH
6084: LD_INT 10000
6086: PUSH
6087: LD_INT 1000
6089: PUSH
6090: LD_INT 300
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: LIST
6097: PPUSH
6098: LD_INT 12
6100: PUSH
6101: LD_INT 2
6103: PUSH
6104: LD_INT 3
6106: PUSH
6107: LD_INT 4
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_OWVAR 67
6119: ARRAY
6120: PUSH
6121: LD_INT 1
6123: NEG
6124: PUSH
6125: LD_INT 4
6127: PUSH
6128: EMPTY
6129: LIST
6130: LIST
6131: LIST
6132: LIST
6133: PPUSH
6134: CALL 18091 0 6
6138: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , area_base_north ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
6139: LD_ADDR_EXP 33
6143: PUSH
6144: LD_EXP 33
6148: PUSH
6149: LD_INT 122
6151: PPUSH
6152: LD_INT 35
6154: PPUSH
6155: LD_STRING 
6157: PPUSH
6158: LD_VAR 0 8
6162: PPUSH
6163: LD_INT 500
6165: PUSH
6166: LD_INT 60
6168: PUSH
6169: LD_INT 0
6171: PUSH
6172: EMPTY
6173: LIST
6174: LIST
6175: LIST
6176: PPUSH
6177: LD_INT 8
6179: PUSH
6180: LD_INT 2
6182: PUSH
6183: LD_INT 3
6185: PUSH
6186: LD_INT 4
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: LIST
6193: PUSH
6194: LD_OWVAR 67
6198: ARRAY
6199: PUSH
6200: LD_INT 2
6202: PUSH
6203: LD_INT 0
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: LIST
6210: LIST
6211: PPUSH
6212: CALL 18091 0 6
6216: UNION
6217: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
6218: LD_ADDR_EXP 31
6222: PUSH
6223: LD_INT 45
6225: PPUSH
6226: LD_INT 34
6228: PPUSH
6229: LD_STRING jeddah
6231: PPUSH
6232: LD_VAR 0 8
6236: PPUSH
6237: LD_INT 700
6239: PUSH
6240: LD_INT 300
6242: PUSH
6243: LD_INT 10
6245: PUSH
6246: EMPTY
6247: LIST
6248: LIST
6249: LIST
6250: PPUSH
6251: LD_INT 10
6253: PUSH
6254: LD_INT 4
6256: PUSH
6257: LD_INT 3
6259: PUSH
6260: LD_INT 2
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: PPUSH
6269: CALL 18091 0 6
6273: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6274: LD_ADDR_EXP 32
6278: PUSH
6279: LD_INT 7
6281: PPUSH
6282: LD_INT 33
6284: PPUSH
6285: LD_STRING riyadh
6287: PPUSH
6288: LD_VAR 0 8
6292: PPUSH
6293: LD_INT 500
6295: PUSH
6296: LD_INT 60
6298: PUSH
6299: LD_INT 0
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: PPUSH
6307: LD_INT 4
6309: PUSH
6310: LD_INT 2
6312: PUSH
6313: LD_INT 3
6315: PUSH
6316: LD_INT 1
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PPUSH
6325: CALL 18091 0 6
6329: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
6330: LD_ADDR_EXP 34
6334: PUSH
6335: LD_INT 69
6337: PPUSH
6338: LD_INT 36
6340: PPUSH
6341: LD_STRING 
6343: PPUSH
6344: LD_VAR 0 8
6348: PPUSH
6349: LD_INT 500
6351: PUSH
6352: LD_INT 50
6354: PUSH
6355: LD_INT 0
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: PPUSH
6363: LD_INT 10
6365: PUSH
6366: LD_INT 2
6368: PUSH
6369: LD_INT 3
6371: PUSH
6372: LD_INT 1
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: LIST
6379: LIST
6380: PPUSH
6381: CALL 18091 0 6
6385: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south ] ;
6386: LD_ADDR_EXP 42
6390: PUSH
6391: LD_EXP 33
6395: PUSH
6396: LD_EXP 31
6400: PUSH
6401: LD_EXP 34
6405: PUSH
6406: LD_EXP 32
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6417: LD_ADDR_OWVAR 37
6421: PUSH
6422: LD_INT 14
6424: ST_TO_ADDR
// vc_engine := engine_siberite ;
6425: LD_ADDR_OWVAR 39
6429: PUSH
6430: LD_INT 3
6432: ST_TO_ADDR
// vc_control := control_manual ;
6433: LD_ADDR_OWVAR 38
6437: PUSH
6438: LD_INT 1
6440: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6441: LD_ADDR_OWVAR 40
6445: PUSH
6446: LD_INT 31
6448: ST_TO_ADDR
// for i = 1 to 5 do
6449: LD_ADDR_VAR 0 3
6453: PUSH
6454: DOUBLE
6455: LD_INT 1
6457: DEC
6458: ST_TO_ADDR
6459: LD_INT 5
6461: PUSH
6462: FOR_TO
6463: IFFALSE 6732
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6465: LD_ADDR_VAR 0 5
6469: PUSH
6470: LD_INT 156
6472: PUSH
6473: LD_INT 15
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: PUSH
6480: LD_INT 12
6482: PUSH
6483: LD_INT 7
6485: PUSH
6486: EMPTY
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_VAR 0 3
6498: PUSH
6499: LD_INT 2
6501: MOD
6502: PUSH
6503: LD_INT 1
6505: PLUS
6506: ARRAY
6507: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6508: LD_INT 0
6510: PPUSH
6511: LD_INT 3
6513: PPUSH
6514: LD_VAR 0 8
6518: PPUSH
6519: CALL_OW 380
// un := CreateVehicle ;
6523: LD_ADDR_VAR 0 6
6527: PUSH
6528: CALL_OW 45
6532: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6533: LD_VAR 0 6
6537: PPUSH
6538: LD_INT 0
6540: PPUSH
6541: LD_INT 5
6543: PPUSH
6544: CALL_OW 12
6548: PPUSH
6549: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6553: LD_VAR 0 6
6557: PPUSH
6558: LD_VAR 0 5
6562: PUSH
6563: LD_INT 1
6565: ARRAY
6566: PPUSH
6567: LD_VAR 0 5
6571: PUSH
6572: LD_INT 2
6574: ARRAY
6575: PPUSH
6576: LD_INT 6
6578: PPUSH
6579: LD_INT 0
6581: PPUSH
6582: CALL_OW 50
// un2 := CreateHuman ;
6586: LD_ADDR_VAR 0 7
6590: PUSH
6591: CALL_OW 44
6595: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6596: LD_VAR 0 7
6600: PPUSH
6601: LD_VAR 0 6
6605: PPUSH
6606: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6610: LD_ADDR_EXP 42
6614: PUSH
6615: LD_EXP 42
6619: PPUSH
6620: LD_VAR 0 3
6624: PUSH
6625: LD_INT 2
6627: MOD
6628: PUSH
6629: LD_INT 1
6631: PLUS
6632: PUSH
6633: LD_EXP 42
6637: PUSH
6638: LD_VAR 0 3
6642: PUSH
6643: LD_INT 2
6645: MOD
6646: PUSH
6647: LD_INT 1
6649: PLUS
6650: ARRAY
6651: PUSH
6652: LD_INT 1
6654: PLUS
6655: PUSH
6656: EMPTY
6657: LIST
6658: LIST
6659: PPUSH
6660: LD_VAR 0 6
6664: PPUSH
6665: CALL 14804 0 3
6669: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6670: LD_ADDR_EXP 42
6674: PUSH
6675: LD_EXP 42
6679: PPUSH
6680: LD_VAR 0 3
6684: PUSH
6685: LD_INT 2
6687: MOD
6688: PUSH
6689: LD_INT 1
6691: PLUS
6692: PUSH
6693: LD_EXP 42
6697: PUSH
6698: LD_VAR 0 3
6702: PUSH
6703: LD_INT 2
6705: MOD
6706: PUSH
6707: LD_INT 1
6709: PLUS
6710: ARRAY
6711: PUSH
6712: LD_INT 1
6714: PLUS
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: PPUSH
6720: LD_VAR 0 7
6724: PPUSH
6725: CALL 14804 0 3
6729: ST_TO_ADDR
// end ;
6730: GO 6462
6732: POP
6733: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6734: LD_ADDR_VAR 0 3
6738: PUSH
6739: LD_INT 22
6741: PUSH
6742: LD_EXP 3
6746: PUSH
6747: EMPTY
6748: LIST
6749: LIST
6750: PUSH
6751: LD_INT 30
6753: PUSH
6754: LD_INT 31
6756: PUSH
6757: EMPTY
6758: LIST
6759: LIST
6760: PUSH
6761: LD_INT 58
6763: PUSH
6764: EMPTY
6765: LIST
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: LIST
6771: PPUSH
6772: CALL_OW 69
6776: PUSH
6777: FOR_IN
6778: IFFALSE 6903
// begin if GetBase ( i ) then
6780: LD_VAR 0 3
6784: PPUSH
6785: CALL_OW 274
6789: IFFALSE 6793
// continue ;
6791: GO 6777
// d := GetDir ( i ) ;
6793: LD_ADDR_VAR 0 4
6797: PUSH
6798: LD_VAR 0 3
6802: PPUSH
6803: CALL_OW 254
6807: ST_TO_ADDR
// if d < 3 then
6808: LD_VAR 0 4
6812: PUSH
6813: LD_INT 3
6815: LESS
6816: IFFALSE 6834
// d := d + 3 else
6818: LD_ADDR_VAR 0 4
6822: PUSH
6823: LD_VAR 0 4
6827: PUSH
6828: LD_INT 3
6830: PLUS
6831: ST_TO_ADDR
6832: GO 6848
// d := d - 3 ;
6834: LD_ADDR_VAR 0 4
6838: PUSH
6839: LD_VAR 0 4
6843: PUSH
6844: LD_INT 3
6846: MINUS
6847: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6848: LD_INT 0
6850: PPUSH
6851: LD_INT 8
6853: PPUSH
6854: LD_VAR 0 8
6858: PPUSH
6859: CALL_OW 380
// un := CreateHuman ;
6863: LD_ADDR_VAR 0 6
6867: PUSH
6868: CALL_OW 44
6872: ST_TO_ADDR
// SetDir ( un , d ) ;
6873: LD_VAR 0 6
6877: PPUSH
6878: LD_VAR 0 4
6882: PPUSH
6883: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6887: LD_VAR 0 6
6891: PPUSH
6892: LD_VAR 0 3
6896: PPUSH
6897: CALL_OW 52
// end ;
6901: GO 6777
6903: POP
6904: POP
// ar_force_tmp := [ ] ;
6905: LD_ADDR_EXP 35
6909: PUSH
6910: EMPTY
6911: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6912: LD_INT 1
6914: PPUSH
6915: LD_INT 1
6917: PPUSH
6918: LD_VAR 0 8
6922: PPUSH
6923: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6927: LD_ADDR_OWVAR 33
6931: PUSH
6932: LD_STRING SecondCharsGal
6934: ST_TO_ADDR
// hc_face_number := 4 ;
6935: LD_ADDR_OWVAR 34
6939: PUSH
6940: LD_INT 4
6942: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6943: LD_ADDR_EXP 35
6947: PUSH
6948: LD_EXP 35
6952: PPUSH
6953: LD_INT 1
6955: PPUSH
6956: CALL_OW 44
6960: PPUSH
6961: CALL_OW 1
6965: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6966: LD_INT 2
6968: PPUSH
6969: LD_INT 4
6971: PPUSH
6972: LD_VAR 0 8
6976: PPUSH
6977: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6981: LD_ADDR_OWVAR 33
6985: PUSH
6986: LD_STRING SecondCharsGal
6988: ST_TO_ADDR
// hc_face_number := 15 ;
6989: LD_ADDR_OWVAR 34
6993: PUSH
6994: LD_INT 15
6996: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6997: LD_ADDR_EXP 35
7001: PUSH
7002: LD_EXP 35
7006: PPUSH
7007: LD_INT 2
7009: PPUSH
7010: CALL_OW 44
7014: PPUSH
7015: CALL_OW 1
7019: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7020: LD_INT 2
7022: PPUSH
7023: LD_INT 4
7025: PPUSH
7026: LD_VAR 0 8
7030: PPUSH
7031: CALL_OW 380
// hc_gallery :=  ;
7035: LD_ADDR_OWVAR 33
7039: PUSH
7040: LD_STRING 
7042: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7043: LD_ADDR_EXP 35
7047: PUSH
7048: LD_EXP 35
7052: PPUSH
7053: LD_INT 3
7055: PPUSH
7056: CALL_OW 44
7060: PPUSH
7061: CALL_OW 1
7065: ST_TO_ADDR
// hc_sex := sex_male ;
7066: LD_ADDR_OWVAR 27
7070: PUSH
7071: LD_INT 1
7073: ST_TO_ADDR
// hc_class = 11 ;
7074: LD_ADDR_OWVAR 28
7078: PUSH
7079: LD_INT 11
7081: ST_TO_ADDR
// hc_gallery = sandar ;
7082: LD_ADDR_OWVAR 33
7086: PUSH
7087: LD_STRING sandar
7089: ST_TO_ADDR
// hc_face_number = 33 ;
7090: LD_ADDR_OWVAR 34
7094: PUSH
7095: LD_INT 33
7097: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7098: LD_ADDR_OWVAR 26
7102: PUSH
7103: LD_STRING Thabit Muhair Saliba
7105: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7106: LD_ADDR_OWVAR 31
7110: PUSH
7111: LD_INT 5
7113: PUSH
7114: LD_INT 5
7116: PUSH
7117: LD_INT 3
7119: PUSH
7120: LD_INT 3
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: ST_TO_ADDR
// Saliba = CreateHuman ;
7129: LD_ADDR_EXP 38
7133: PUSH
7134: CALL_OW 44
7138: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7139: LD_EXP 38
7143: PPUSH
7144: LD_INT 7
7146: PPUSH
7147: CALL_OW 52
// hc_name := Dietrich Gensher ;
7151: LD_ADDR_OWVAR 26
7155: PUSH
7156: LD_STRING Dietrich Gensher
7158: ST_TO_ADDR
// hc_class := 1 ;
7159: LD_ADDR_OWVAR 28
7163: PUSH
7164: LD_INT 1
7166: ST_TO_ADDR
// hc_gallery := sandar ;
7167: LD_ADDR_OWVAR 33
7171: PUSH
7172: LD_STRING sandar
7174: ST_TO_ADDR
// hc_face_number := 2 ;
7175: LD_ADDR_OWVAR 34
7179: PUSH
7180: LD_INT 2
7182: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7183: LD_ADDR_OWVAR 31
7187: PUSH
7188: LD_INT 10
7190: PUSH
7191: LD_INT 6
7193: PUSH
7194: LD_INT 5
7196: PUSH
7197: LD_INT 4
7199: PUSH
7200: EMPTY
7201: LIST
7202: LIST
7203: LIST
7204: LIST
7205: ST_TO_ADDR
// Gensher := CreateHuman ;
7206: LD_ADDR_EXP 39
7210: PUSH
7211: CALL_OW 44
7215: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7216: LD_EXP 39
7220: PPUSH
7221: LD_INT 94
7223: PPUSH
7224: CALL_OW 52
// InitHc ;
7228: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7232: LD_ADDR_EXP 37
7236: PUSH
7237: EMPTY
7238: PUSH
7239: EMPTY
7240: PUSH
7241: EMPTY
7242: PUSH
7243: EMPTY
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: LIST
7249: LIST
7250: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7251: LD_ADDR_VAR 0 4
7255: PUSH
7256: DOUBLE
7257: LD_INT 1
7259: DEC
7260: ST_TO_ADDR
7261: LD_INT 3
7263: PUSH
7264: LD_INT 3
7266: PUSH
7267: LD_INT 4
7269: PUSH
7270: EMPTY
7271: LIST
7272: LIST
7273: LIST
7274: PUSH
7275: LD_OWVAR 67
7279: ARRAY
7280: PUSH
7281: FOR_TO
7282: IFFALSE 7500
// for i = 1 to 4 do
7284: LD_ADDR_VAR 0 3
7288: PUSH
7289: DOUBLE
7290: LD_INT 1
7292: DEC
7293: ST_TO_ADDR
7294: LD_INT 4
7296: PUSH
7297: FOR_TO
7298: IFFALSE 7496
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7300: LD_INT 14
7302: PPUSH
7303: LD_INT 3
7305: PUSH
7306: LD_INT 2
7308: PUSH
7309: EMPTY
7310: LIST
7311: LIST
7312: PUSH
7313: LD_INT 1
7315: PPUSH
7316: LD_INT 2
7318: PPUSH
7319: CALL_OW 12
7323: ARRAY
7324: PPUSH
7325: LD_INT 1
7327: PUSH
7328: LD_INT 5
7330: PUSH
7331: EMPTY
7332: LIST
7333: LIST
7334: PUSH
7335: LD_INT 1
7337: PPUSH
7338: LD_INT 2
7340: PPUSH
7341: CALL_OW 12
7345: ARRAY
7346: PPUSH
7347: LD_INT 25
7349: PUSH
7350: LD_INT 27
7352: PUSH
7353: LD_INT 26
7355: PUSH
7356: LD_INT 28
7358: PUSH
7359: EMPTY
7360: LIST
7361: LIST
7362: LIST
7363: LIST
7364: PUSH
7365: LD_INT 1
7367: PPUSH
7368: LD_INT 4
7370: PPUSH
7371: CALL_OW 12
7375: ARRAY
7376: PPUSH
7377: LD_INT 100
7379: PPUSH
7380: CALL 14682 0 5
// un := CreateVehicle ;
7384: LD_ADDR_VAR 0 6
7388: PUSH
7389: CALL_OW 45
7393: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7394: LD_ADDR_EXP 37
7398: PUSH
7399: LD_EXP 37
7403: PPUSH
7404: LD_VAR 0 3
7408: PUSH
7409: LD_EXP 37
7413: PUSH
7414: LD_VAR 0 3
7418: ARRAY
7419: PUSH
7420: LD_INT 1
7422: PLUS
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: PPUSH
7428: LD_VAR 0 6
7432: PPUSH
7433: CALL 14804 0 3
7437: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7438: LD_VAR 0 6
7442: PPUSH
7443: LD_INT 0
7445: PPUSH
7446: LD_INT 5
7448: PPUSH
7449: CALL_OW 12
7453: PPUSH
7454: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7458: LD_VAR 0 6
7462: PPUSH
7463: LD_INT 20
7465: PUSH
7466: LD_INT 21
7468: PUSH
7469: LD_INT 22
7471: PUSH
7472: LD_INT 24
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: LIST
7479: LIST
7480: PUSH
7481: LD_VAR 0 3
7485: ARRAY
7486: PPUSH
7487: LD_INT 0
7489: PPUSH
7490: CALL_OW 49
// end ;
7494: GO 7297
7496: POP
7497: POP
7498: GO 7281
7500: POP
7501: POP
// InitHc ;
7502: CALL_OW 19
// end ;
7506: LD_VAR 0 2
7510: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7511: LD_INT 94
7513: PPUSH
7514: CALL_OW 302
7518: PUSH
7519: LD_INT 94
7521: PPUSH
7522: CALL_OW 255
7526: PUSH
7527: LD_EXP 3
7531: EQUAL
7532: AND
7533: IFFALSE 8242
7535: GO 7537
7537: DISABLE
7538: LD_INT 0
7540: PPUSH
7541: PPUSH
7542: PPUSH
7543: PPUSH
7544: PPUSH
7545: PPUSH
7546: PPUSH
7547: PPUSH
7548: PPUSH
7549: PPUSH
// begin enable ;
7550: ENABLE
// base := 1 ;
7551: LD_ADDR_VAR 0 4
7555: PUSH
7556: LD_INT 1
7558: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7559: LD_ADDR_VAR 0 7
7563: PUSH
7564: LD_INT 0
7566: PUSH
7567: LD_INT 0
7569: PUSH
7570: LD_INT 0
7572: PUSH
7573: LD_INT 0
7575: PUSH
7576: LD_INT 1
7578: PUSH
7579: LD_INT 0
7581: PUSH
7582: LD_INT 0
7584: PUSH
7585: LD_INT 0
7587: PUSH
7588: LD_INT 1
7590: PUSH
7591: LD_INT 0
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: LIST
7598: LIST
7599: LIST
7600: LIST
7601: LIST
7602: LIST
7603: LIST
7604: LIST
7605: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7606: LD_ADDR_VAR 0 6
7610: PUSH
7611: LD_INT 28
7613: PUSH
7614: LD_INT 14
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: LD_INT 107
7623: PUSH
7624: LD_INT 119
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: LD_INT 127
7633: PUSH
7634: LD_INT 97
7636: PUSH
7637: EMPTY
7638: LIST
7639: LIST
7640: PUSH
7641: LD_INT 185
7643: PUSH
7644: LD_INT 127
7646: PUSH
7647: EMPTY
7648: LIST
7649: LIST
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: LIST
7655: LIST
7656: ST_TO_ADDR
// target := 0 ;
7657: LD_ADDR_VAR 0 9
7661: PUSH
7662: LD_INT 0
7664: ST_TO_ADDR
// x := 0 ;
7665: LD_ADDR_VAR 0 3
7669: PUSH
7670: LD_INT 0
7672: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7673: LD_ADDR_VAR 0 5
7677: PUSH
7678: LD_INT 14
7680: PUSH
7681: LD_INT 1
7683: PUSH
7684: LD_INT 2
7686: PUSH
7687: LD_INT 28
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: LIST
7694: LIST
7695: PUSH
7696: LD_INT 14
7698: PUSH
7699: LD_INT 1
7701: PUSH
7702: LD_INT 2
7704: PUSH
7705: LD_INT 25
7707: PUSH
7708: EMPTY
7709: LIST
7710: LIST
7711: LIST
7712: LIST
7713: PUSH
7714: LD_INT 14
7716: PUSH
7717: LD_INT 1
7719: PUSH
7720: LD_INT 2
7722: PUSH
7723: LD_INT 28
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: LIST
7730: LIST
7731: PUSH
7732: LD_INT 14
7734: PUSH
7735: LD_INT 1
7737: PUSH
7738: LD_INT 2
7740: PUSH
7741: LD_INT 29
7743: PUSH
7744: EMPTY
7745: LIST
7746: LIST
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: ST_TO_ADDR
// if Difficulty > 1 then
7756: LD_OWVAR 67
7760: PUSH
7761: LD_INT 1
7763: GREATER
7764: IFFALSE 7861
// for i = 1 to Difficulty + 2 do
7766: LD_ADDR_VAR 0 1
7770: PUSH
7771: DOUBLE
7772: LD_INT 1
7774: DEC
7775: ST_TO_ADDR
7776: LD_OWVAR 67
7780: PUSH
7781: LD_INT 2
7783: PLUS
7784: PUSH
7785: FOR_TO
7786: IFFALSE 7859
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7788: LD_ADDR_VAR 0 5
7792: PUSH
7793: LD_VAR 0 5
7797: PPUSH
7798: LD_VAR 0 5
7802: PUSH
7803: LD_INT 1
7805: PLUS
7806: PPUSH
7807: LD_INT 14
7809: PUSH
7810: LD_INT 1
7812: PUSH
7813: LD_INT 2
7815: PUSH
7816: LD_INT 28
7818: PUSH
7819: LD_INT 27
7821: PUSH
7822: LD_INT 27
7824: PUSH
7825: LD_INT 29
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: LIST
7832: LIST
7833: PUSH
7834: LD_INT 1
7836: PPUSH
7837: LD_INT 4
7839: PPUSH
7840: CALL_OW 12
7844: ARRAY
7845: PUSH
7846: EMPTY
7847: LIST
7848: LIST
7849: LIST
7850: LIST
7851: PPUSH
7852: CALL_OW 2
7856: ST_TO_ADDR
7857: GO 7785
7859: POP
7860: POP
// MC_SetProduceList ( base , tmp ) ;
7861: LD_VAR 0 4
7865: PPUSH
7866: LD_VAR 0 5
7870: PPUSH
7871: CALL 70741 0 2
// repeat wait ( 0 0$1 ) ;
7875: LD_INT 35
7877: PPUSH
7878: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7882: LD_VAR 0 4
7886: PPUSH
7887: CALL 71137 0 1
7891: PUSH
7892: LD_INT 0
7894: EQUAL
7895: IFFALSE 7875
// wait ( 0 0$10 ) ;
7897: LD_INT 350
7899: PPUSH
7900: CALL_OW 67
// for i = 1 to coords do
7904: LD_ADDR_VAR 0 1
7908: PUSH
7909: DOUBLE
7910: LD_INT 1
7912: DEC
7913: ST_TO_ADDR
7914: LD_VAR 0 6
7918: PUSH
7919: FOR_TO
7920: IFFALSE 8008
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7922: LD_ADDR_VAR 0 2
7926: PUSH
7927: LD_EXP 3
7931: PPUSH
7932: LD_VAR 0 6
7936: PUSH
7937: LD_VAR 0 1
7941: ARRAY
7942: PUSH
7943: LD_INT 1
7945: ARRAY
7946: PPUSH
7947: LD_VAR 0 6
7951: PUSH
7952: LD_VAR 0 1
7956: ARRAY
7957: PUSH
7958: LD_INT 2
7960: ARRAY
7961: PPUSH
7962: LD_INT 35
7964: PPUSH
7965: CALL 15700 0 4
7969: PUSH
7970: LD_INT 4
7972: ARRAY
7973: ST_TO_ADDR
// if t > x then
7974: LD_VAR 0 2
7978: PUSH
7979: LD_VAR 0 3
7983: GREATER
7984: IFFALSE 8006
// begin x := t ;
7986: LD_ADDR_VAR 0 3
7990: PUSH
7991: LD_VAR 0 2
7995: ST_TO_ADDR
// target := i ;
7996: LD_ADDR_VAR 0 9
8000: PUSH
8001: LD_VAR 0 1
8005: ST_TO_ADDR
// end ; end ;
8006: GO 7919
8008: POP
8009: POP
// case target of 1 :
8010: LD_VAR 0 9
8014: PUSH
8015: LD_INT 1
8017: DOUBLE
8018: EQUAL
8019: IFTRUE 8023
8021: GO 8055
8023: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8024: LD_ADDR_VAR 0 10
8028: PUSH
8029: LD_INT 60
8031: PUSH
8032: LD_INT 8
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: PUSH
8039: LD_INT 28
8041: PUSH
8042: LD_INT 15
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PUSH
8049: EMPTY
8050: LIST
8051: LIST
8052: ST_TO_ADDR
8053: GO 8176
8055: LD_INT 2
8057: DOUBLE
8058: EQUAL
8059: IFTRUE 8063
8061: GO 8095
8063: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8064: LD_ADDR_VAR 0 10
8068: PUSH
8069: LD_INT 52
8071: PUSH
8072: LD_INT 11
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: PUSH
8079: LD_INT 76
8081: PUSH
8082: LD_INT 90
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: ST_TO_ADDR
8093: GO 8176
8095: LD_INT 3
8097: DOUBLE
8098: EQUAL
8099: IFTRUE 8103
8101: GO 8135
8103: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8104: LD_ADDR_VAR 0 10
8108: PUSH
8109: LD_INT 129
8111: PUSH
8112: LD_INT 66
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: LD_INT 130
8121: PUSH
8122: LD_INT 97
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: ST_TO_ADDR
8133: GO 8176
8135: LD_INT 4
8137: DOUBLE
8138: EQUAL
8139: IFTRUE 8143
8141: GO 8175
8143: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8144: LD_ADDR_VAR 0 10
8148: PUSH
8149: LD_INT 156
8151: PUSH
8152: LD_INT 87
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: PUSH
8159: LD_INT 183
8161: PUSH
8162: LD_INT 127
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: ST_TO_ADDR
8173: GO 8176
8175: POP
// if not _target then
8176: LD_VAR 0 10
8180: NOT
8181: IFFALSE 8212
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8183: LD_ADDR_VAR 0 10
8187: PUSH
8188: LD_INT 52
8190: PUSH
8191: LD_INT 11
8193: PUSH
8194: EMPTY
8195: LIST
8196: LIST
8197: PUSH
8198: LD_INT 76
8200: PUSH
8201: LD_INT 90
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PUSH
8208: EMPTY
8209: LIST
8210: LIST
8211: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8212: LD_VAR 0 4
8216: PPUSH
8217: LD_EXP 61
8221: PUSH
8222: LD_VAR 0 4
8226: ARRAY
8227: PPUSH
8228: LD_VAR 0 10
8232: PPUSH
8233: LD_VAR 0 7
8237: PPUSH
8238: CALL 70974 0 4
// end ;
8242: PPOPN 10
8244: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8245: LD_INT 45
8247: PPUSH
8248: CALL_OW 302
8252: PUSH
8253: LD_INT 45
8255: PPUSH
8256: CALL_OW 255
8260: PUSH
8261: LD_EXP 3
8265: EQUAL
8266: AND
8267: PUSH
8268: LD_EXP 26
8272: PUSH
8273: LD_INT 3
8275: EQUAL
8276: PUSH
8277: LD_INT 94
8279: PPUSH
8280: CALL_OW 301
8284: OR
8285: PUSH
8286: LD_INT 94
8288: PPUSH
8289: CALL_OW 255
8293: PUSH
8294: LD_EXP 3
8298: NONEQUAL
8299: OR
8300: AND
8301: IFFALSE 8887
8303: GO 8305
8305: DISABLE
8306: LD_INT 0
8308: PPUSH
8309: PPUSH
8310: PPUSH
8311: PPUSH
8312: PPUSH
8313: PPUSH
8314: PPUSH
8315: PPUSH
8316: PPUSH
8317: PPUSH
// begin enable ;
8318: ENABLE
// base := 2 ;
8319: LD_ADDR_VAR 0 4
8323: PUSH
8324: LD_INT 2
8326: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8327: LD_ADDR_VAR 0 7
8331: PUSH
8332: LD_INT 0
8334: PUSH
8335: LD_INT 0
8337: PUSH
8338: LD_INT 0
8340: PUSH
8341: LD_INT 0
8343: PUSH
8344: LD_INT 1
8346: PUSH
8347: LD_INT 0
8349: PUSH
8350: LD_INT 0
8352: PUSH
8353: LD_INT 0
8355: PUSH
8356: LD_INT 1
8358: PUSH
8359: LD_INT 0
8361: PUSH
8362: EMPTY
8363: LIST
8364: LIST
8365: LIST
8366: LIST
8367: LIST
8368: LIST
8369: LIST
8370: LIST
8371: LIST
8372: LIST
8373: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8374: LD_ADDR_VAR 0 6
8378: PUSH
8379: LD_INT 101
8381: PUSH
8382: LD_INT 110
8384: PUSH
8385: EMPTY
8386: LIST
8387: LIST
8388: PUSH
8389: LD_INT 100
8391: PUSH
8392: LD_INT 21
8394: PUSH
8395: EMPTY
8396: LIST
8397: LIST
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: ST_TO_ADDR
// target := 0 ;
8403: LD_ADDR_VAR 0 9
8407: PUSH
8408: LD_INT 0
8410: ST_TO_ADDR
// x := 0 ;
8411: LD_ADDR_VAR 0 3
8415: PUSH
8416: LD_INT 0
8418: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8419: LD_ADDR_VAR 0 5
8423: PUSH
8424: LD_INT 14
8426: PUSH
8427: LD_INT 1
8429: PUSH
8430: LD_INT 2
8432: PUSH
8433: LD_INT 28
8435: PUSH
8436: EMPTY
8437: LIST
8438: LIST
8439: LIST
8440: LIST
8441: PUSH
8442: LD_INT 14
8444: PUSH
8445: LD_INT 1
8447: PUSH
8448: LD_INT 2
8450: PUSH
8451: LD_INT 25
8453: PUSH
8454: EMPTY
8455: LIST
8456: LIST
8457: LIST
8458: LIST
8459: PUSH
8460: LD_INT 14
8462: PUSH
8463: LD_INT 1
8465: PUSH
8466: LD_INT 2
8468: PUSH
8469: LD_INT 28
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: EMPTY
8479: LIST
8480: LIST
8481: LIST
8482: ST_TO_ADDR
// if Difficulty > 1 then
8483: LD_OWVAR 67
8487: PUSH
8488: LD_INT 1
8490: GREATER
8491: IFFALSE 8586
// for i = 1 to Difficulty + 1 do
8493: LD_ADDR_VAR 0 1
8497: PUSH
8498: DOUBLE
8499: LD_INT 1
8501: DEC
8502: ST_TO_ADDR
8503: LD_OWVAR 67
8507: PUSH
8508: LD_INT 1
8510: PLUS
8511: PUSH
8512: FOR_TO
8513: IFFALSE 8584
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8515: LD_ADDR_VAR 0 5
8519: PUSH
8520: LD_VAR 0 5
8524: PPUSH
8525: LD_VAR 0 5
8529: PUSH
8530: LD_INT 1
8532: PLUS
8533: PPUSH
8534: LD_INT 14
8536: PUSH
8537: LD_INT 1
8539: PUSH
8540: LD_INT 2
8542: PUSH
8543: LD_INT 28
8545: PUSH
8546: LD_INT 27
8548: PUSH
8549: LD_INT 27
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: LIST
8556: PUSH
8557: LD_VAR 0 1
8561: PUSH
8562: LD_INT 2
8564: MOD
8565: PUSH
8566: LD_INT 1
8568: PLUS
8569: ARRAY
8570: PUSH
8571: EMPTY
8572: LIST
8573: LIST
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 2
8581: ST_TO_ADDR
8582: GO 8512
8584: POP
8585: POP
// MC_SetProduceList ( base , tmp ) ;
8586: LD_VAR 0 4
8590: PPUSH
8591: LD_VAR 0 5
8595: PPUSH
8596: CALL 70741 0 2
// repeat wait ( 0 0$1 ) ;
8600: LD_INT 35
8602: PPUSH
8603: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8607: LD_VAR 0 4
8611: PPUSH
8612: CALL 71137 0 1
8616: PUSH
8617: LD_INT 0
8619: EQUAL
8620: IFFALSE 8600
// wait ( 0 0$10 ) ;
8622: LD_INT 350
8624: PPUSH
8625: CALL_OW 67
// for i = 1 to coords do
8629: LD_ADDR_VAR 0 1
8633: PUSH
8634: DOUBLE
8635: LD_INT 1
8637: DEC
8638: ST_TO_ADDR
8639: LD_VAR 0 6
8643: PUSH
8644: FOR_TO
8645: IFFALSE 8733
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8647: LD_ADDR_VAR 0 2
8651: PUSH
8652: LD_EXP 3
8656: PPUSH
8657: LD_VAR 0 6
8661: PUSH
8662: LD_VAR 0 1
8666: ARRAY
8667: PUSH
8668: LD_INT 1
8670: ARRAY
8671: PPUSH
8672: LD_VAR 0 6
8676: PUSH
8677: LD_VAR 0 1
8681: ARRAY
8682: PUSH
8683: LD_INT 2
8685: ARRAY
8686: PPUSH
8687: LD_INT 35
8689: PPUSH
8690: CALL 15700 0 4
8694: PUSH
8695: LD_INT 4
8697: ARRAY
8698: ST_TO_ADDR
// if t > x then
8699: LD_VAR 0 2
8703: PUSH
8704: LD_VAR 0 3
8708: GREATER
8709: IFFALSE 8731
// begin x := t ;
8711: LD_ADDR_VAR 0 3
8715: PUSH
8716: LD_VAR 0 2
8720: ST_TO_ADDR
// target := i ;
8721: LD_ADDR_VAR 0 9
8725: PUSH
8726: LD_VAR 0 1
8730: ST_TO_ADDR
// end ; end ;
8731: GO 8644
8733: POP
8734: POP
// case target of 1 :
8735: LD_VAR 0 9
8739: PUSH
8740: LD_INT 1
8742: DOUBLE
8743: EQUAL
8744: IFTRUE 8748
8746: GO 8780
8748: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8749: LD_ADDR_VAR 0 10
8753: PUSH
8754: LD_INT 49
8756: PUSH
8757: LD_INT 35
8759: PUSH
8760: EMPTY
8761: LIST
8762: LIST
8763: PUSH
8764: LD_INT 76
8766: PUSH
8767: LD_INT 90
8769: PUSH
8770: EMPTY
8771: LIST
8772: LIST
8773: PUSH
8774: EMPTY
8775: LIST
8776: LIST
8777: ST_TO_ADDR
8778: GO 8821
8780: LD_INT 2
8782: DOUBLE
8783: EQUAL
8784: IFTRUE 8788
8786: GO 8820
8788: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8789: LD_ADDR_VAR 0 10
8793: PUSH
8794: LD_INT 79
8796: PUSH
8797: LD_INT 13
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 100
8806: PUSH
8807: LD_INT 22
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: EMPTY
8815: LIST
8816: LIST
8817: ST_TO_ADDR
8818: GO 8821
8820: POP
// if not _target then
8821: LD_VAR 0 10
8825: NOT
8826: IFFALSE 8857
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8828: LD_ADDR_VAR 0 10
8832: PUSH
8833: LD_INT 49
8835: PUSH
8836: LD_INT 35
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: PUSH
8843: LD_INT 76
8845: PUSH
8846: LD_INT 90
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8857: LD_VAR 0 4
8861: PPUSH
8862: LD_EXP 61
8866: PUSH
8867: LD_VAR 0 4
8871: ARRAY
8872: PPUSH
8873: LD_VAR 0 10
8877: PPUSH
8878: LD_VAR 0 7
8882: PPUSH
8883: CALL 70974 0 4
// end ; end_of_file
8887: PPOPN 10
8889: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8890: LD_INT 0
8892: PPUSH
8893: PPUSH
// begin if artifact_get then
8894: LD_EXP 4
8898: IFFALSE 8902
// exit ;
8900: GO 8924
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8902: LD_VAR 0 1
8906: PPUSH
8907: CALL_OW 255
8911: PPUSH
8912: CALL 5800 0 1
// artifact_get := true ;
8916: LD_ADDR_EXP 4
8920: PUSH
8921: LD_INT 1
8923: ST_TO_ADDR
// end ;
8924: PPOPN 4
8926: END
// on UnitDestroyed ( un ) do var i , side ;
8927: LD_INT 0
8929: PPUSH
8930: PPUSH
// begin side := GetSide ( un ) ;
8931: LD_ADDR_VAR 0 3
8935: PUSH
8936: LD_VAR 0 1
8940: PPUSH
8941: CALL_OW 255
8945: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8946: LD_VAR 0 3
8950: PUSH
8951: LD_EXP 68
8955: IN
8956: NOT
8957: PUSH
8958: LD_EXP 7
8962: PUSH
8963: LD_VAR 0 3
8967: ARRAY
8968: AND
8969: IFFALSE 8995
// if GetType ( un ) = unit_human then
8971: LD_VAR 0 1
8975: PPUSH
8976: CALL_OW 247
8980: PUSH
8981: LD_INT 1
8983: EQUAL
8984: IFFALSE 8995
// MultiplayerEvent_HumanLost ( side ) ;
8986: LD_VAR 0 3
8990: PPUSH
8991: CALL 5440 0 1
// if side in mc_sides then
8995: LD_VAR 0 3
8999: PUSH
9000: LD_EXP 68
9004: IN
9005: IFFALSE 9050
// if un <> Gensher then
9007: LD_VAR 0 1
9011: PUSH
9012: LD_EXP 39
9016: NONEQUAL
9017: IFFALSE 9033
// MultiplayerEvent_UnitKilled ( un , false ) else
9019: LD_VAR 0 1
9023: PPUSH
9024: LD_INT 0
9026: PPUSH
9027: CALL 5554 0 2
9031: GO 9050
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9033: LD_VAR 0 1
9037: PPUSH
9038: LD_INT 5
9040: PPUSH
9041: CALL 4871 0 1
9045: PPUSH
9046: CALL 5554 0 2
// if multi_commanders and multi_custom_commanders then
9050: LD_EXP 24
9054: PUSH
9055: LD_EXP 16
9059: AND
9060: IFFALSE 9122
// if un in multi_commanders then
9062: LD_VAR 0 1
9066: PUSH
9067: LD_EXP 24
9071: IN
9072: IFFALSE 9122
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9074: LD_ADDR_EXP 25
9078: PUSH
9079: LD_EXP 25
9083: PPUSH
9084: LD_VAR 0 3
9088: PPUSH
9089: LD_INT 1
9091: PPUSH
9092: CALL_OW 1
9096: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9097: LD_ADDR_EXP 24
9101: PUSH
9102: LD_EXP 24
9106: PUSH
9107: LD_VAR 0 1
9111: DIFF
9112: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9113: LD_VAR 0 3
9117: PPUSH
9118: CALL 4904 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9122: LD_VAR 0 1
9126: PPUSH
9127: CALL 74200 0 1
// end ;
9131: PPOPN 3
9133: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9134: LD_VAR 0 1
9138: PPUSH
9139: LD_VAR 0 2
9143: PPUSH
9144: CALL 76534 0 2
// end ;
9148: PPOPN 2
9150: END
// on BuildingComplete ( building ) do var i , j ;
9151: LD_INT 0
9153: PPUSH
9154: PPUSH
// begin if GetSide ( building ) in mc_sides then
9155: LD_VAR 0 1
9159: PPUSH
9160: CALL_OW 255
9164: PUSH
9165: LD_EXP 68
9169: IN
9170: IFFALSE 9196
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9172: LD_VAR 0 1
9176: PPUSH
9177: CALL_OW 255
9181: PPUSH
9182: LD_VAR 0 1
9186: PPUSH
9187: CALL_OW 266
9191: PPUSH
9192: CALL 5484 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9196: LD_VAR 0 1
9200: PPUSH
9201: CALL_OW 266
9205: PUSH
9206: LD_INT 0
9208: EQUAL
9209: PUSH
9210: LD_VAR 0 1
9214: PPUSH
9215: CALL_OW 255
9219: PUSH
9220: LD_EXP 68
9224: IN
9225: NOT
9226: AND
9227: PUSH
9228: LD_EXP 5
9232: AND
9233: IFFALSE 9271
// begin SetBName ( building , base_names [ 1 ] ) ;
9235: LD_VAR 0 1
9239: PPUSH
9240: LD_EXP 5
9244: PUSH
9245: LD_INT 1
9247: ARRAY
9248: PPUSH
9249: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9253: LD_ADDR_EXP 5
9257: PUSH
9258: LD_EXP 5
9262: PPUSH
9263: LD_INT 1
9265: PPUSH
9266: CALL_OW 3
9270: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9271: LD_VAR 0 1
9275: PPUSH
9276: CALL 75843 0 1
// end ;
9280: PPOPN 3
9282: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9283: LD_VAR 0 1
9287: PPUSH
9288: LD_VAR 0 2
9292: PPUSH
9293: CALL 73896 0 2
// end ;
9297: PPOPN 2
9299: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9300: LD_VAR 0 1
9304: PPUSH
9305: LD_VAR 0 2
9309: PPUSH
9310: LD_VAR 0 3
9314: PPUSH
9315: LD_VAR 0 4
9319: PPUSH
9320: LD_VAR 0 5
9324: PPUSH
9325: CALL 73516 0 5
// end ;
9329: PPOPN 5
9331: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9332: LD_INT 0
9334: PPUSH
9335: PPUSH
9336: PPUSH
// begin side := GetSide ( vehicle ) ;
9337: LD_ADDR_VAR 0 4
9341: PUSH
9342: LD_VAR 0 1
9346: PPUSH
9347: CALL_OW 255
9351: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9352: LD_VAR 0 4
9356: PUSH
9357: LD_EXP 68
9361: IN
9362: NOT
9363: PUSH
9364: LD_EXP 7
9368: PUSH
9369: LD_VAR 0 4
9373: ARRAY
9374: AND
9375: IFFALSE 9386
// MultiplayerEvent_Produced ( side ) ;
9377: LD_VAR 0 4
9381: PPUSH
9382: CALL 5396 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9386: LD_VAR 0 1
9390: PPUSH
9391: LD_VAR 0 2
9395: PPUSH
9396: CALL 73106 0 2
// end ;
9400: PPOPN 5
9402: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9403: LD_VAR 0 1
9407: PPUSH
9408: LD_VAR 0 2
9412: PPUSH
9413: LD_VAR 0 3
9417: PPUSH
9418: LD_VAR 0 4
9422: PPUSH
9423: CALL 72944 0 4
// end ;
9427: PPOPN 4
9429: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9430: LD_VAR 0 1
9434: PPUSH
9435: LD_VAR 0 2
9439: PPUSH
9440: LD_VAR 0 3
9444: PPUSH
9445: CALL 72719 0 3
// end ;
9449: PPOPN 3
9451: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9452: LD_VAR 0 1
9456: PPUSH
9457: LD_VAR 0 2
9461: PPUSH
9462: CALL 72604 0 2
// end ;
9466: PPOPN 2
9468: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9469: LD_VAR 0 1
9473: PPUSH
9474: LD_VAR 0 2
9478: PPUSH
9479: CALL 76795 0 2
// end ;
9483: PPOPN 2
9485: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9486: LD_VAR 0 1
9490: PPUSH
9491: LD_VAR 0 2
9495: PPUSH
9496: LD_VAR 0 3
9500: PPUSH
9501: LD_VAR 0 4
9505: PPUSH
9506: CALL 77011 0 4
// end ; end_of_file
9510: PPOPN 4
9512: END
// every 0 0$1 trigger game do
9513: LD_EXP 2
9517: IFFALSE 9562
9519: GO 9521
9521: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9522: LD_INT 7
9524: PUSH
9525: LD_INT 6
9527: PUSH
9528: LD_INT 4
9530: PUSH
9531: LD_INT 6
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: PPUSH
9540: LD_EXP 21
9544: PUSH
9545: LD_INT 2
9547: ARRAY
9548: PPUSH
9549: LD_EXP 21
9553: PUSH
9554: LD_INT 1
9556: ARRAY
9557: PPUSH
9558: CALL 9563 0 3
9562: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9563: LD_INT 0
9565: PPUSH
9566: PPUSH
9567: PPUSH
9568: PPUSH
// if not areas then
9569: LD_VAR 0 1
9573: NOT
9574: IFFALSE 9578
// exit ;
9576: GO 9853
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9578: LD_ADDR_VAR 0 7
9582: PUSH
9583: LD_INT 31
9585: PUSH
9586: LD_INT 32
9588: PUSH
9589: LD_INT 30
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: LIST
9596: ST_TO_ADDR
// repeat wait ( time ) ;
9597: LD_VAR 0 2
9601: PPUSH
9602: CALL_OW 67
// x := 5 ;
9606: LD_ADDR_VAR 0 6
9610: PUSH
9611: LD_INT 5
9613: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9614: LD_OWVAR 1
9618: PUSH
9619: LD_INT 42000
9621: PUSH
9622: LD_INT 37800
9624: PUSH
9625: LD_INT 29400
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: LIST
9632: PUSH
9633: LD_OWVAR 67
9637: ARRAY
9638: LESS
9639: IFFALSE 9711
// begin for i = 1 to multi_sides do
9641: LD_ADDR_VAR 0 5
9645: PUSH
9646: DOUBLE
9647: LD_INT 1
9649: DEC
9650: ST_TO_ADDR
9651: LD_EXP 7
9655: PUSH
9656: FOR_TO
9657: IFFALSE 9702
// if multi_sides [ i ] then
9659: LD_EXP 7
9663: PUSH
9664: LD_VAR 0 5
9668: ARRAY
9669: IFFALSE 9700
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9671: LD_VAR 0 6
9675: PPUSH
9676: LD_VAR 0 7
9680: PUSH
9681: LD_EXP 7
9685: PUSH
9686: LD_VAR 0 5
9690: ARRAY
9691: ARRAY
9692: PPUSH
9693: LD_INT 1
9695: PPUSH
9696: CALL_OW 55
9700: GO 9656
9702: POP
9703: POP
// wait ( 0 0$6 ) ;
9704: LD_INT 210
9706: PPUSH
9707: CALL_OW 67
// end ; for i in areas do
9711: LD_ADDR_VAR 0 5
9715: PUSH
9716: LD_VAR 0 1
9720: PUSH
9721: FOR_IN
9722: IFFALSE 9750
// begin wait ( 0 0$6 ) ;
9724: LD_INT 210
9726: PPUSH
9727: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9731: LD_VAR 0 6
9735: PPUSH
9736: LD_VAR 0 5
9740: PPUSH
9741: LD_INT 1
9743: PPUSH
9744: CALL_OW 55
// end ;
9748: GO 9721
9750: POP
9751: POP
// time := time + 0 0$2 ;
9752: LD_ADDR_VAR 0 2
9756: PUSH
9757: LD_VAR 0 2
9761: PUSH
9762: LD_INT 70
9764: PLUS
9765: ST_TO_ADDR
// amount := amount - x * 10 ;
9766: LD_ADDR_VAR 0 3
9770: PUSH
9771: LD_VAR 0 3
9775: PUSH
9776: LD_VAR 0 6
9780: PUSH
9781: LD_INT 10
9783: MUL
9784: MINUS
9785: ST_TO_ADDR
// x := x - 1 ;
9786: LD_ADDR_VAR 0 6
9790: PUSH
9791: LD_VAR 0 6
9795: PUSH
9796: LD_INT 1
9798: MINUS
9799: ST_TO_ADDR
// if x = 0 then
9800: LD_VAR 0 6
9804: PUSH
9805: LD_INT 0
9807: EQUAL
9808: IFFALSE 9818
// x := 5 ;
9810: LD_ADDR_VAR 0 6
9814: PUSH
9815: LD_INT 5
9817: ST_TO_ADDR
// if time > 4 4$00 then
9818: LD_VAR 0 2
9822: PUSH
9823: LD_INT 8400
9825: GREATER
9826: IFFALSE 9836
// time := 0 0$40 ;
9828: LD_ADDR_VAR 0 2
9832: PUSH
9833: LD_INT 1400
9835: ST_TO_ADDR
// until not game or amount <= 0 ;
9836: LD_EXP 2
9840: NOT
9841: PUSH
9842: LD_VAR 0 3
9846: PUSH
9847: LD_INT 0
9849: LESSEQUAL
9850: OR
9851: IFFALSE 9597
// end ; end_of_file
9853: LD_VAR 0 4
9857: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9858: LD_INT 0
9860: PPUSH
9861: PPUSH
// if exist_mode then
9862: LD_VAR 0 2
9866: IFFALSE 9891
// unit := CreateCharacter ( prefix & ident ) else
9868: LD_ADDR_VAR 0 5
9872: PUSH
9873: LD_VAR 0 3
9877: PUSH
9878: LD_VAR 0 1
9882: STR
9883: PPUSH
9884: CALL_OW 34
9888: ST_TO_ADDR
9889: GO 9906
// unit := NewCharacter ( ident ) ;
9891: LD_ADDR_VAR 0 5
9895: PUSH
9896: LD_VAR 0 1
9900: PPUSH
9901: CALL_OW 25
9905: ST_TO_ADDR
// result := unit ;
9906: LD_ADDR_VAR 0 4
9910: PUSH
9911: LD_VAR 0 5
9915: ST_TO_ADDR
// end ;
9916: LD_VAR 0 4
9920: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9921: LD_INT 0
9923: PPUSH
9924: PPUSH
// if not side or not nation then
9925: LD_VAR 0 1
9929: NOT
9930: PUSH
9931: LD_VAR 0 2
9935: NOT
9936: OR
9937: IFFALSE 9941
// exit ;
9939: GO 10705
// case nation of nation_american :
9941: LD_VAR 0 2
9945: PUSH
9946: LD_INT 1
9948: DOUBLE
9949: EQUAL
9950: IFTRUE 9954
9952: GO 10168
9954: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9955: LD_ADDR_VAR 0 4
9959: PUSH
9960: LD_INT 35
9962: PUSH
9963: LD_INT 45
9965: PUSH
9966: LD_INT 46
9968: PUSH
9969: LD_INT 47
9971: PUSH
9972: LD_INT 82
9974: PUSH
9975: LD_INT 83
9977: PUSH
9978: LD_INT 84
9980: PUSH
9981: LD_INT 85
9983: PUSH
9984: LD_INT 86
9986: PUSH
9987: LD_INT 1
9989: PUSH
9990: LD_INT 2
9992: PUSH
9993: LD_INT 6
9995: PUSH
9996: LD_INT 15
9998: PUSH
9999: LD_INT 16
10001: PUSH
10002: LD_INT 7
10004: PUSH
10005: LD_INT 12
10007: PUSH
10008: LD_INT 13
10010: PUSH
10011: LD_INT 10
10013: PUSH
10014: LD_INT 14
10016: PUSH
10017: LD_INT 20
10019: PUSH
10020: LD_INT 21
10022: PUSH
10023: LD_INT 22
10025: PUSH
10026: LD_INT 25
10028: PUSH
10029: LD_INT 32
10031: PUSH
10032: LD_INT 27
10034: PUSH
10035: LD_INT 36
10037: PUSH
10038: LD_INT 69
10040: PUSH
10041: LD_INT 39
10043: PUSH
10044: LD_INT 34
10046: PUSH
10047: LD_INT 40
10049: PUSH
10050: LD_INT 48
10052: PUSH
10053: LD_INT 49
10055: PUSH
10056: LD_INT 50
10058: PUSH
10059: LD_INT 51
10061: PUSH
10062: LD_INT 52
10064: PUSH
10065: LD_INT 53
10067: PUSH
10068: LD_INT 54
10070: PUSH
10071: LD_INT 55
10073: PUSH
10074: LD_INT 56
10076: PUSH
10077: LD_INT 57
10079: PUSH
10080: LD_INT 58
10082: PUSH
10083: LD_INT 59
10085: PUSH
10086: LD_INT 60
10088: PUSH
10089: LD_INT 61
10091: PUSH
10092: LD_INT 62
10094: PUSH
10095: LD_INT 80
10097: PUSH
10098: LD_INT 82
10100: PUSH
10101: LD_INT 83
10103: PUSH
10104: LD_INT 84
10106: PUSH
10107: LD_INT 85
10109: PUSH
10110: LD_INT 86
10112: PUSH
10113: EMPTY
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: ST_TO_ADDR
10166: GO 10629
10168: LD_INT 2
10170: DOUBLE
10171: EQUAL
10172: IFTRUE 10176
10174: GO 10398
10176: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
10177: LD_ADDR_VAR 0 4
10181: PUSH
10182: LD_INT 35
10184: PUSH
10185: LD_INT 45
10187: PUSH
10188: LD_INT 46
10190: PUSH
10191: LD_INT 47
10193: PUSH
10194: LD_INT 82
10196: PUSH
10197: LD_INT 83
10199: PUSH
10200: LD_INT 84
10202: PUSH
10203: LD_INT 85
10205: PUSH
10206: LD_INT 87
10208: PUSH
10209: LD_INT 70
10211: PUSH
10212: LD_INT 1
10214: PUSH
10215: LD_INT 11
10217: PUSH
10218: LD_INT 3
10220: PUSH
10221: LD_INT 4
10223: PUSH
10224: LD_INT 5
10226: PUSH
10227: LD_INT 6
10229: PUSH
10230: LD_INT 15
10232: PUSH
10233: LD_INT 18
10235: PUSH
10236: LD_INT 7
10238: PUSH
10239: LD_INT 17
10241: PUSH
10242: LD_INT 8
10244: PUSH
10245: LD_INT 20
10247: PUSH
10248: LD_INT 21
10250: PUSH
10251: LD_INT 22
10253: PUSH
10254: LD_INT 72
10256: PUSH
10257: LD_INT 26
10259: PUSH
10260: LD_INT 69
10262: PUSH
10263: LD_INT 39
10265: PUSH
10266: LD_INT 40
10268: PUSH
10269: LD_INT 41
10271: PUSH
10272: LD_INT 42
10274: PUSH
10275: LD_INT 43
10277: PUSH
10278: LD_INT 48
10280: PUSH
10281: LD_INT 49
10283: PUSH
10284: LD_INT 50
10286: PUSH
10287: LD_INT 51
10289: PUSH
10290: LD_INT 52
10292: PUSH
10293: LD_INT 53
10295: PUSH
10296: LD_INT 54
10298: PUSH
10299: LD_INT 55
10301: PUSH
10302: LD_INT 56
10304: PUSH
10305: LD_INT 60
10307: PUSH
10308: LD_INT 61
10310: PUSH
10311: LD_INT 62
10313: PUSH
10314: LD_INT 66
10316: PUSH
10317: LD_INT 67
10319: PUSH
10320: LD_INT 68
10322: PUSH
10323: LD_INT 81
10325: PUSH
10326: LD_INT 82
10328: PUSH
10329: LD_INT 83
10331: PUSH
10332: LD_INT 84
10334: PUSH
10335: LD_INT 85
10337: PUSH
10338: LD_INT 87
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: LIST
10393: LIST
10394: LIST
10395: ST_TO_ADDR
10396: GO 10629
10398: LD_INT 3
10400: DOUBLE
10401: EQUAL
10402: IFTRUE 10406
10404: GO 10628
10406: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10407: LD_ADDR_VAR 0 4
10411: PUSH
10412: LD_INT 46
10414: PUSH
10415: LD_INT 47
10417: PUSH
10418: LD_INT 1
10420: PUSH
10421: LD_INT 2
10423: PUSH
10424: LD_INT 82
10426: PUSH
10427: LD_INT 83
10429: PUSH
10430: LD_INT 84
10432: PUSH
10433: LD_INT 85
10435: PUSH
10436: LD_INT 86
10438: PUSH
10439: LD_INT 11
10441: PUSH
10442: LD_INT 9
10444: PUSH
10445: LD_INT 20
10447: PUSH
10448: LD_INT 19
10450: PUSH
10451: LD_INT 21
10453: PUSH
10454: LD_INT 24
10456: PUSH
10457: LD_INT 22
10459: PUSH
10460: LD_INT 25
10462: PUSH
10463: LD_INT 28
10465: PUSH
10466: LD_INT 29
10468: PUSH
10469: LD_INT 30
10471: PUSH
10472: LD_INT 31
10474: PUSH
10475: LD_INT 37
10477: PUSH
10478: LD_INT 38
10480: PUSH
10481: LD_INT 32
10483: PUSH
10484: LD_INT 27
10486: PUSH
10487: LD_INT 33
10489: PUSH
10490: LD_INT 69
10492: PUSH
10493: LD_INT 39
10495: PUSH
10496: LD_INT 34
10498: PUSH
10499: LD_INT 40
10501: PUSH
10502: LD_INT 71
10504: PUSH
10505: LD_INT 23
10507: PUSH
10508: LD_INT 44
10510: PUSH
10511: LD_INT 48
10513: PUSH
10514: LD_INT 49
10516: PUSH
10517: LD_INT 50
10519: PUSH
10520: LD_INT 51
10522: PUSH
10523: LD_INT 52
10525: PUSH
10526: LD_INT 53
10528: PUSH
10529: LD_INT 54
10531: PUSH
10532: LD_INT 55
10534: PUSH
10535: LD_INT 56
10537: PUSH
10538: LD_INT 57
10540: PUSH
10541: LD_INT 58
10543: PUSH
10544: LD_INT 59
10546: PUSH
10547: LD_INT 63
10549: PUSH
10550: LD_INT 64
10552: PUSH
10553: LD_INT 65
10555: PUSH
10556: LD_INT 82
10558: PUSH
10559: LD_INT 83
10561: PUSH
10562: LD_INT 84
10564: PUSH
10565: LD_INT 85
10567: PUSH
10568: LD_INT 86
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: LIST
10623: LIST
10624: LIST
10625: ST_TO_ADDR
10626: GO 10629
10628: POP
// if state > - 1 and state < 3 then
10629: LD_VAR 0 3
10633: PUSH
10634: LD_INT 1
10636: NEG
10637: GREATER
10638: PUSH
10639: LD_VAR 0 3
10643: PUSH
10644: LD_INT 3
10646: LESS
10647: AND
10648: IFFALSE 10705
// for i in result do
10650: LD_ADDR_VAR 0 5
10654: PUSH
10655: LD_VAR 0 4
10659: PUSH
10660: FOR_IN
10661: IFFALSE 10703
// if GetTech ( i , side ) <> state then
10663: LD_VAR 0 5
10667: PPUSH
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL_OW 321
10677: PUSH
10678: LD_VAR 0 3
10682: NONEQUAL
10683: IFFALSE 10701
// result := result diff i ;
10685: LD_ADDR_VAR 0 4
10689: PUSH
10690: LD_VAR 0 4
10694: PUSH
10695: LD_VAR 0 5
10699: DIFF
10700: ST_TO_ADDR
10701: GO 10660
10703: POP
10704: POP
// end ;
10705: LD_VAR 0 4
10709: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10710: LD_INT 0
10712: PPUSH
10713: PPUSH
10714: PPUSH
// result := true ;
10715: LD_ADDR_VAR 0 3
10719: PUSH
10720: LD_INT 1
10722: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10723: LD_ADDR_VAR 0 5
10727: PUSH
10728: LD_VAR 0 2
10732: PPUSH
10733: CALL_OW 480
10737: ST_TO_ADDR
// if not tmp then
10738: LD_VAR 0 5
10742: NOT
10743: IFFALSE 10747
// exit ;
10745: GO 10796
// for i in tmp do
10747: LD_ADDR_VAR 0 4
10751: PUSH
10752: LD_VAR 0 5
10756: PUSH
10757: FOR_IN
10758: IFFALSE 10794
// if GetTech ( i , side ) <> state_researched then
10760: LD_VAR 0 4
10764: PPUSH
10765: LD_VAR 0 1
10769: PPUSH
10770: CALL_OW 321
10774: PUSH
10775: LD_INT 2
10777: NONEQUAL
10778: IFFALSE 10792
// begin result := false ;
10780: LD_ADDR_VAR 0 3
10784: PUSH
10785: LD_INT 0
10787: ST_TO_ADDR
// exit ;
10788: POP
10789: POP
10790: GO 10796
// end ;
10792: GO 10757
10794: POP
10795: POP
// end ;
10796: LD_VAR 0 3
10800: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10801: LD_INT 0
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
10813: PPUSH
10814: PPUSH
10815: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10816: LD_VAR 0 1
10820: NOT
10821: PUSH
10822: LD_VAR 0 1
10826: PPUSH
10827: CALL_OW 257
10831: PUSH
10832: LD_INT 9
10834: NONEQUAL
10835: OR
10836: IFFALSE 10840
// exit ;
10838: GO 11413
// side := GetSide ( unit ) ;
10840: LD_ADDR_VAR 0 9
10844: PUSH
10845: LD_VAR 0 1
10849: PPUSH
10850: CALL_OW 255
10854: ST_TO_ADDR
// tech_space := tech_spacanom ;
10855: LD_ADDR_VAR 0 12
10859: PUSH
10860: LD_INT 29
10862: ST_TO_ADDR
// tech_time := tech_taurad ;
10863: LD_ADDR_VAR 0 13
10867: PUSH
10868: LD_INT 28
10870: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10871: LD_ADDR_VAR 0 11
10875: PUSH
10876: LD_VAR 0 1
10880: PPUSH
10881: CALL_OW 310
10885: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10886: LD_VAR 0 11
10890: PPUSH
10891: CALL_OW 247
10895: PUSH
10896: LD_INT 2
10898: EQUAL
10899: IFFALSE 10903
// exit ;
10901: GO 11413
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10903: LD_ADDR_VAR 0 8
10907: PUSH
10908: LD_INT 81
10910: PUSH
10911: LD_VAR 0 9
10915: PUSH
10916: EMPTY
10917: LIST
10918: LIST
10919: PUSH
10920: LD_INT 3
10922: PUSH
10923: LD_INT 21
10925: PUSH
10926: LD_INT 3
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: PUSH
10937: EMPTY
10938: LIST
10939: LIST
10940: PPUSH
10941: CALL_OW 69
10945: ST_TO_ADDR
// if not tmp then
10946: LD_VAR 0 8
10950: NOT
10951: IFFALSE 10955
// exit ;
10953: GO 11413
// if in_unit then
10955: LD_VAR 0 11
10959: IFFALSE 10983
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10961: LD_ADDR_VAR 0 10
10965: PUSH
10966: LD_VAR 0 8
10970: PPUSH
10971: LD_VAR 0 11
10975: PPUSH
10976: CALL_OW 74
10980: ST_TO_ADDR
10981: GO 11003
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10983: LD_ADDR_VAR 0 10
10987: PUSH
10988: LD_VAR 0 8
10992: PPUSH
10993: LD_VAR 0 1
10997: PPUSH
10998: CALL_OW 74
11002: ST_TO_ADDR
// if not enemy then
11003: LD_VAR 0 10
11007: NOT
11008: IFFALSE 11012
// exit ;
11010: GO 11413
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11012: LD_VAR 0 11
11016: PUSH
11017: LD_VAR 0 11
11021: PPUSH
11022: LD_VAR 0 10
11026: PPUSH
11027: CALL_OW 296
11031: PUSH
11032: LD_INT 13
11034: GREATER
11035: AND
11036: PUSH
11037: LD_VAR 0 1
11041: PPUSH
11042: LD_VAR 0 10
11046: PPUSH
11047: CALL_OW 296
11051: PUSH
11052: LD_INT 12
11054: GREATER
11055: OR
11056: IFFALSE 11060
// exit ;
11058: GO 11413
// missile := [ 1 ] ;
11060: LD_ADDR_VAR 0 14
11064: PUSH
11065: LD_INT 1
11067: PUSH
11068: EMPTY
11069: LIST
11070: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11071: LD_VAR 0 9
11075: PPUSH
11076: LD_VAR 0 12
11080: PPUSH
11081: CALL_OW 325
11085: IFFALSE 11114
// missile := Insert ( missile , missile + 1 , 2 ) ;
11087: LD_ADDR_VAR 0 14
11091: PUSH
11092: LD_VAR 0 14
11096: PPUSH
11097: LD_VAR 0 14
11101: PUSH
11102: LD_INT 1
11104: PLUS
11105: PPUSH
11106: LD_INT 2
11108: PPUSH
11109: CALL_OW 2
11113: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11114: LD_VAR 0 9
11118: PPUSH
11119: LD_VAR 0 13
11123: PPUSH
11124: CALL_OW 325
11128: PUSH
11129: LD_VAR 0 10
11133: PPUSH
11134: CALL_OW 255
11138: PPUSH
11139: LD_VAR 0 13
11143: PPUSH
11144: CALL_OW 325
11148: NOT
11149: AND
11150: IFFALSE 11179
// missile := Insert ( missile , missile + 1 , 3 ) ;
11152: LD_ADDR_VAR 0 14
11156: PUSH
11157: LD_VAR 0 14
11161: PPUSH
11162: LD_VAR 0 14
11166: PUSH
11167: LD_INT 1
11169: PLUS
11170: PPUSH
11171: LD_INT 3
11173: PPUSH
11174: CALL_OW 2
11178: ST_TO_ADDR
// if missile < 2 then
11179: LD_VAR 0 14
11183: PUSH
11184: LD_INT 2
11186: LESS
11187: IFFALSE 11191
// exit ;
11189: GO 11413
// x := GetX ( enemy ) ;
11191: LD_ADDR_VAR 0 4
11195: PUSH
11196: LD_VAR 0 10
11200: PPUSH
11201: CALL_OW 250
11205: ST_TO_ADDR
// y := GetY ( enemy ) ;
11206: LD_ADDR_VAR 0 5
11210: PUSH
11211: LD_VAR 0 10
11215: PPUSH
11216: CALL_OW 251
11220: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11221: LD_ADDR_VAR 0 6
11225: PUSH
11226: LD_VAR 0 4
11230: PUSH
11231: LD_INT 1
11233: NEG
11234: PPUSH
11235: LD_INT 1
11237: PPUSH
11238: CALL_OW 12
11242: PLUS
11243: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11244: LD_ADDR_VAR 0 7
11248: PUSH
11249: LD_VAR 0 5
11253: PUSH
11254: LD_INT 1
11256: NEG
11257: PPUSH
11258: LD_INT 1
11260: PPUSH
11261: CALL_OW 12
11265: PLUS
11266: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11267: LD_VAR 0 6
11271: PPUSH
11272: LD_VAR 0 7
11276: PPUSH
11277: CALL_OW 488
11281: NOT
11282: IFFALSE 11304
// begin _x := x ;
11284: LD_ADDR_VAR 0 6
11288: PUSH
11289: LD_VAR 0 4
11293: ST_TO_ADDR
// _y := y ;
11294: LD_ADDR_VAR 0 7
11298: PUSH
11299: LD_VAR 0 5
11303: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11304: LD_ADDR_VAR 0 3
11308: PUSH
11309: LD_INT 1
11311: PPUSH
11312: LD_VAR 0 14
11316: PPUSH
11317: CALL_OW 12
11321: ST_TO_ADDR
// case i of 1 :
11322: LD_VAR 0 3
11326: PUSH
11327: LD_INT 1
11329: DOUBLE
11330: EQUAL
11331: IFTRUE 11335
11333: GO 11352
11335: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11336: LD_VAR 0 1
11340: PPUSH
11341: LD_VAR 0 10
11345: PPUSH
11346: CALL_OW 115
11350: GO 11413
11352: LD_INT 2
11354: DOUBLE
11355: EQUAL
11356: IFTRUE 11360
11358: GO 11382
11360: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11361: LD_VAR 0 1
11365: PPUSH
11366: LD_VAR 0 6
11370: PPUSH
11371: LD_VAR 0 7
11375: PPUSH
11376: CALL_OW 153
11380: GO 11413
11382: LD_INT 3
11384: DOUBLE
11385: EQUAL
11386: IFTRUE 11390
11388: GO 11412
11390: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11391: LD_VAR 0 1
11395: PPUSH
11396: LD_VAR 0 6
11400: PPUSH
11401: LD_VAR 0 7
11405: PPUSH
11406: CALL_OW 154
11410: GO 11413
11412: POP
// end ;
11413: LD_VAR 0 2
11417: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11418: LD_INT 0
11420: PPUSH
11421: PPUSH
11422: PPUSH
11423: PPUSH
11424: PPUSH
11425: PPUSH
// if not unit or not building then
11426: LD_VAR 0 1
11430: NOT
11431: PUSH
11432: LD_VAR 0 2
11436: NOT
11437: OR
11438: IFFALSE 11442
// exit ;
11440: GO 11600
// x := GetX ( building ) ;
11442: LD_ADDR_VAR 0 5
11446: PUSH
11447: LD_VAR 0 2
11451: PPUSH
11452: CALL_OW 250
11456: ST_TO_ADDR
// y := GetY ( building ) ;
11457: LD_ADDR_VAR 0 6
11461: PUSH
11462: LD_VAR 0 2
11466: PPUSH
11467: CALL_OW 251
11471: ST_TO_ADDR
// for i = 0 to 5 do
11472: LD_ADDR_VAR 0 4
11476: PUSH
11477: DOUBLE
11478: LD_INT 0
11480: DEC
11481: ST_TO_ADDR
11482: LD_INT 5
11484: PUSH
11485: FOR_TO
11486: IFFALSE 11598
// begin _x := ShiftX ( x , i , 3 ) ;
11488: LD_ADDR_VAR 0 7
11492: PUSH
11493: LD_VAR 0 5
11497: PPUSH
11498: LD_VAR 0 4
11502: PPUSH
11503: LD_INT 3
11505: PPUSH
11506: CALL_OW 272
11510: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11511: LD_ADDR_VAR 0 8
11515: PUSH
11516: LD_VAR 0 6
11520: PPUSH
11521: LD_VAR 0 4
11525: PPUSH
11526: LD_INT 3
11528: PPUSH
11529: CALL_OW 273
11533: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11534: LD_VAR 0 7
11538: PPUSH
11539: LD_VAR 0 8
11543: PPUSH
11544: CALL_OW 488
11548: NOT
11549: IFFALSE 11553
// continue ;
11551: GO 11485
// if HexInfo ( _x , _y ) = 0 then
11553: LD_VAR 0 7
11557: PPUSH
11558: LD_VAR 0 8
11562: PPUSH
11563: CALL_OW 428
11567: PUSH
11568: LD_INT 0
11570: EQUAL
11571: IFFALSE 11596
// begin ComMoveXY ( unit , _x , _y ) ;
11573: LD_VAR 0 1
11577: PPUSH
11578: LD_VAR 0 7
11582: PPUSH
11583: LD_VAR 0 8
11587: PPUSH
11588: CALL_OW 111
// exit ;
11592: POP
11593: POP
11594: GO 11600
// end ; end ;
11596: GO 11485
11598: POP
11599: POP
// end ;
11600: LD_VAR 0 3
11604: RET
// export function ScanBase ( side , base_area ) ; begin
11605: LD_INT 0
11607: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11608: LD_ADDR_VAR 0 3
11612: PUSH
11613: LD_VAR 0 2
11617: PPUSH
11618: LD_INT 81
11620: PUSH
11621: LD_VAR 0 1
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: PPUSH
11630: CALL_OW 70
11634: ST_TO_ADDR
// end ;
11635: LD_VAR 0 3
11639: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11640: LD_INT 0
11642: PPUSH
11643: PPUSH
11644: PPUSH
11645: PPUSH
// result := false ;
11646: LD_ADDR_VAR 0 2
11650: PUSH
11651: LD_INT 0
11653: ST_TO_ADDR
// side := GetSide ( unit ) ;
11654: LD_ADDR_VAR 0 3
11658: PUSH
11659: LD_VAR 0 1
11663: PPUSH
11664: CALL_OW 255
11668: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11669: LD_ADDR_VAR 0 4
11673: PUSH
11674: LD_VAR 0 1
11678: PPUSH
11679: CALL_OW 248
11683: ST_TO_ADDR
// case nat of 1 :
11684: LD_VAR 0 4
11688: PUSH
11689: LD_INT 1
11691: DOUBLE
11692: EQUAL
11693: IFTRUE 11697
11695: GO 11708
11697: POP
// tech := tech_lassight ; 2 :
11698: LD_ADDR_VAR 0 5
11702: PUSH
11703: LD_INT 12
11705: ST_TO_ADDR
11706: GO 11747
11708: LD_INT 2
11710: DOUBLE
11711: EQUAL
11712: IFTRUE 11716
11714: GO 11727
11716: POP
// tech := tech_mortar ; 3 :
11717: LD_ADDR_VAR 0 5
11721: PUSH
11722: LD_INT 41
11724: ST_TO_ADDR
11725: GO 11747
11727: LD_INT 3
11729: DOUBLE
11730: EQUAL
11731: IFTRUE 11735
11733: GO 11746
11735: POP
// tech := tech_bazooka ; end ;
11736: LD_ADDR_VAR 0 5
11740: PUSH
11741: LD_INT 44
11743: ST_TO_ADDR
11744: GO 11747
11746: POP
// if Researched ( side , tech ) then
11747: LD_VAR 0 3
11751: PPUSH
11752: LD_VAR 0 5
11756: PPUSH
11757: CALL_OW 325
11761: IFFALSE 11788
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11763: LD_ADDR_VAR 0 2
11767: PUSH
11768: LD_INT 5
11770: PUSH
11771: LD_INT 8
11773: PUSH
11774: LD_INT 9
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: LIST
11781: PUSH
11782: LD_VAR 0 4
11786: ARRAY
11787: ST_TO_ADDR
// end ;
11788: LD_VAR 0 2
11792: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11793: LD_INT 0
11795: PPUSH
11796: PPUSH
11797: PPUSH
// if not mines then
11798: LD_VAR 0 2
11802: NOT
11803: IFFALSE 11807
// exit ;
11805: GO 11951
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11807: LD_ADDR_VAR 0 5
11811: PUSH
11812: LD_INT 81
11814: PUSH
11815: LD_VAR 0 1
11819: PUSH
11820: EMPTY
11821: LIST
11822: LIST
11823: PUSH
11824: LD_INT 3
11826: PUSH
11827: LD_INT 21
11829: PUSH
11830: LD_INT 3
11832: PUSH
11833: EMPTY
11834: LIST
11835: LIST
11836: PUSH
11837: EMPTY
11838: LIST
11839: LIST
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PPUSH
11845: CALL_OW 69
11849: ST_TO_ADDR
// for i in mines do
11850: LD_ADDR_VAR 0 4
11854: PUSH
11855: LD_VAR 0 2
11859: PUSH
11860: FOR_IN
11861: IFFALSE 11949
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11863: LD_VAR 0 4
11867: PUSH
11868: LD_INT 1
11870: ARRAY
11871: PPUSH
11872: LD_VAR 0 4
11876: PUSH
11877: LD_INT 2
11879: ARRAY
11880: PPUSH
11881: CALL_OW 458
11885: NOT
11886: IFFALSE 11890
// continue ;
11888: GO 11860
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11890: LD_VAR 0 4
11894: PUSH
11895: LD_INT 1
11897: ARRAY
11898: PPUSH
11899: LD_VAR 0 4
11903: PUSH
11904: LD_INT 2
11906: ARRAY
11907: PPUSH
11908: CALL_OW 428
11912: PUSH
11913: LD_VAR 0 5
11917: IN
11918: IFFALSE 11947
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11920: LD_VAR 0 4
11924: PUSH
11925: LD_INT 1
11927: ARRAY
11928: PPUSH
11929: LD_VAR 0 4
11933: PUSH
11934: LD_INT 2
11936: ARRAY
11937: PPUSH
11938: LD_VAR 0 1
11942: PPUSH
11943: CALL_OW 456
// end ;
11947: GO 11860
11949: POP
11950: POP
// end ;
11951: LD_VAR 0 3
11955: RET
// export function Count ( array ) ; var i ; begin
11956: LD_INT 0
11958: PPUSH
11959: PPUSH
// result := 0 ;
11960: LD_ADDR_VAR 0 2
11964: PUSH
11965: LD_INT 0
11967: ST_TO_ADDR
// for i in array do
11968: LD_ADDR_VAR 0 3
11972: PUSH
11973: LD_VAR 0 1
11977: PUSH
11978: FOR_IN
11979: IFFALSE 12003
// if i then
11981: LD_VAR 0 3
11985: IFFALSE 12001
// result := result + 1 ;
11987: LD_ADDR_VAR 0 2
11991: PUSH
11992: LD_VAR 0 2
11996: PUSH
11997: LD_INT 1
11999: PLUS
12000: ST_TO_ADDR
12001: GO 11978
12003: POP
12004: POP
// end ;
12005: LD_VAR 0 2
12009: RET
// export function IsEmpty ( building ) ; begin
12010: LD_INT 0
12012: PPUSH
// if not building then
12013: LD_VAR 0 1
12017: NOT
12018: IFFALSE 12022
// exit ;
12020: GO 12065
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12022: LD_ADDR_VAR 0 2
12026: PUSH
12027: LD_VAR 0 1
12031: PUSH
12032: LD_INT 22
12034: PUSH
12035: LD_VAR 0 1
12039: PPUSH
12040: CALL_OW 255
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: PUSH
12049: LD_INT 58
12051: PUSH
12052: EMPTY
12053: LIST
12054: PUSH
12055: EMPTY
12056: LIST
12057: LIST
12058: PPUSH
12059: CALL_OW 69
12063: IN
12064: ST_TO_ADDR
// end ;
12065: LD_VAR 0 2
12069: RET
// export function IsNotFull ( building ) ; begin
12070: LD_INT 0
12072: PPUSH
// if not building then
12073: LD_VAR 0 1
12077: NOT
12078: IFFALSE 12082
// exit ;
12080: GO 12101
// result := UnitsInside ( building ) < 6 ;
12082: LD_ADDR_VAR 0 2
12086: PUSH
12087: LD_VAR 0 1
12091: PPUSH
12092: CALL_OW 313
12096: PUSH
12097: LD_INT 6
12099: LESS
12100: ST_TO_ADDR
// end ;
12101: LD_VAR 0 2
12105: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12106: LD_INT 0
12108: PPUSH
12109: PPUSH
12110: PPUSH
12111: PPUSH
// tmp := [ ] ;
12112: LD_ADDR_VAR 0 3
12116: PUSH
12117: EMPTY
12118: ST_TO_ADDR
// list := [ ] ;
12119: LD_ADDR_VAR 0 5
12123: PUSH
12124: EMPTY
12125: ST_TO_ADDR
// for i = 16 to 25 do
12126: LD_ADDR_VAR 0 4
12130: PUSH
12131: DOUBLE
12132: LD_INT 16
12134: DEC
12135: ST_TO_ADDR
12136: LD_INT 25
12138: PUSH
12139: FOR_TO
12140: IFFALSE 12213
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12142: LD_ADDR_VAR 0 3
12146: PUSH
12147: LD_VAR 0 3
12151: PUSH
12152: LD_INT 22
12154: PUSH
12155: LD_VAR 0 1
12159: PPUSH
12160: CALL_OW 255
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 91
12171: PUSH
12172: LD_VAR 0 1
12176: PUSH
12177: LD_INT 6
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: LIST
12184: PUSH
12185: LD_INT 30
12187: PUSH
12188: LD_VAR 0 4
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: LIST
12201: PUSH
12202: EMPTY
12203: LIST
12204: PPUSH
12205: CALL_OW 69
12209: ADD
12210: ST_TO_ADDR
12211: GO 12139
12213: POP
12214: POP
// for i = 1 to tmp do
12215: LD_ADDR_VAR 0 4
12219: PUSH
12220: DOUBLE
12221: LD_INT 1
12223: DEC
12224: ST_TO_ADDR
12225: LD_VAR 0 3
12229: PUSH
12230: FOR_TO
12231: IFFALSE 12319
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12233: LD_ADDR_VAR 0 5
12237: PUSH
12238: LD_VAR 0 5
12242: PUSH
12243: LD_VAR 0 3
12247: PUSH
12248: LD_VAR 0 4
12252: ARRAY
12253: PPUSH
12254: CALL_OW 266
12258: PUSH
12259: LD_VAR 0 3
12263: PUSH
12264: LD_VAR 0 4
12268: ARRAY
12269: PPUSH
12270: CALL_OW 250
12274: PUSH
12275: LD_VAR 0 3
12279: PUSH
12280: LD_VAR 0 4
12284: ARRAY
12285: PPUSH
12286: CALL_OW 251
12290: PUSH
12291: LD_VAR 0 3
12295: PUSH
12296: LD_VAR 0 4
12300: ARRAY
12301: PPUSH
12302: CALL_OW 254
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: LIST
12311: LIST
12312: PUSH
12313: EMPTY
12314: LIST
12315: ADD
12316: ST_TO_ADDR
12317: GO 12230
12319: POP
12320: POP
// result := list ;
12321: LD_ADDR_VAR 0 2
12325: PUSH
12326: LD_VAR 0 5
12330: ST_TO_ADDR
// end ;
12331: LD_VAR 0 2
12335: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12336: LD_INT 0
12338: PPUSH
12339: PPUSH
12340: PPUSH
12341: PPUSH
12342: PPUSH
12343: PPUSH
12344: PPUSH
// if not factory then
12345: LD_VAR 0 1
12349: NOT
12350: IFFALSE 12354
// exit ;
12352: GO 12947
// if control = control_apeman then
12354: LD_VAR 0 4
12358: PUSH
12359: LD_INT 5
12361: EQUAL
12362: IFFALSE 12471
// begin tmp := UnitsInside ( factory ) ;
12364: LD_ADDR_VAR 0 8
12368: PUSH
12369: LD_VAR 0 1
12373: PPUSH
12374: CALL_OW 313
12378: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12379: LD_VAR 0 8
12383: PPUSH
12384: LD_INT 25
12386: PUSH
12387: LD_INT 12
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PPUSH
12394: CALL_OW 72
12398: NOT
12399: IFFALSE 12409
// control := control_manual ;
12401: LD_ADDR_VAR 0 4
12405: PUSH
12406: LD_INT 1
12408: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12409: LD_ADDR_VAR 0 8
12413: PUSH
12414: LD_VAR 0 1
12418: PPUSH
12419: CALL 12106 0 1
12423: ST_TO_ADDR
// if tmp then
12424: LD_VAR 0 8
12428: IFFALSE 12471
// begin for i in tmp do
12430: LD_ADDR_VAR 0 7
12434: PUSH
12435: LD_VAR 0 8
12439: PUSH
12440: FOR_IN
12441: IFFALSE 12469
// if i [ 1 ] = b_ext_radio then
12443: LD_VAR 0 7
12447: PUSH
12448: LD_INT 1
12450: ARRAY
12451: PUSH
12452: LD_INT 22
12454: EQUAL
12455: IFFALSE 12467
// begin control := control_remote ;
12457: LD_ADDR_VAR 0 4
12461: PUSH
12462: LD_INT 2
12464: ST_TO_ADDR
// break ;
12465: GO 12469
// end ;
12467: GO 12440
12469: POP
12470: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12471: LD_VAR 0 1
12475: PPUSH
12476: LD_VAR 0 2
12480: PPUSH
12481: LD_VAR 0 3
12485: PPUSH
12486: LD_VAR 0 4
12490: PPUSH
12491: LD_VAR 0 5
12495: PPUSH
12496: CALL_OW 448
12500: IFFALSE 12535
// begin result := [ chassis , engine , control , weapon ] ;
12502: LD_ADDR_VAR 0 6
12506: PUSH
12507: LD_VAR 0 2
12511: PUSH
12512: LD_VAR 0 3
12516: PUSH
12517: LD_VAR 0 4
12521: PUSH
12522: LD_VAR 0 5
12526: PUSH
12527: EMPTY
12528: LIST
12529: LIST
12530: LIST
12531: LIST
12532: ST_TO_ADDR
// exit ;
12533: GO 12947
// end ; _chassis := AvailableChassisList ( factory ) ;
12535: LD_ADDR_VAR 0 9
12539: PUSH
12540: LD_VAR 0 1
12544: PPUSH
12545: CALL_OW 475
12549: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12550: LD_ADDR_VAR 0 11
12554: PUSH
12555: LD_VAR 0 1
12559: PPUSH
12560: CALL_OW 476
12564: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12565: LD_ADDR_VAR 0 12
12569: PUSH
12570: LD_VAR 0 1
12574: PPUSH
12575: CALL_OW 477
12579: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12580: LD_ADDR_VAR 0 10
12584: PUSH
12585: LD_VAR 0 1
12589: PPUSH
12590: CALL_OW 478
12594: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12595: LD_VAR 0 9
12599: NOT
12600: PUSH
12601: LD_VAR 0 11
12605: NOT
12606: OR
12607: PUSH
12608: LD_VAR 0 12
12612: NOT
12613: OR
12614: PUSH
12615: LD_VAR 0 10
12619: NOT
12620: OR
12621: IFFALSE 12656
// begin result := [ chassis , engine , control , weapon ] ;
12623: LD_ADDR_VAR 0 6
12627: PUSH
12628: LD_VAR 0 2
12632: PUSH
12633: LD_VAR 0 3
12637: PUSH
12638: LD_VAR 0 4
12642: PUSH
12643: LD_VAR 0 5
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: LIST
12652: LIST
12653: ST_TO_ADDR
// exit ;
12654: GO 12947
// end ; if not chassis in _chassis then
12656: LD_VAR 0 2
12660: PUSH
12661: LD_VAR 0 9
12665: IN
12666: NOT
12667: IFFALSE 12693
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12669: LD_ADDR_VAR 0 2
12673: PUSH
12674: LD_VAR 0 9
12678: PUSH
12679: LD_INT 1
12681: PPUSH
12682: LD_VAR 0 9
12686: PPUSH
12687: CALL_OW 12
12691: ARRAY
12692: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12693: LD_VAR 0 2
12697: PPUSH
12698: LD_VAR 0 3
12702: PPUSH
12703: CALL 12952 0 2
12707: NOT
12708: IFFALSE 12767
// repeat engine := _engine [ 1 ] ;
12710: LD_ADDR_VAR 0 3
12714: PUSH
12715: LD_VAR 0 11
12719: PUSH
12720: LD_INT 1
12722: ARRAY
12723: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12724: LD_ADDR_VAR 0 11
12728: PUSH
12729: LD_VAR 0 11
12733: PPUSH
12734: LD_INT 1
12736: PPUSH
12737: CALL_OW 3
12741: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12742: LD_VAR 0 2
12746: PPUSH
12747: LD_VAR 0 3
12751: PPUSH
12752: CALL 12952 0 2
12756: PUSH
12757: LD_VAR 0 11
12761: PUSH
12762: EMPTY
12763: EQUAL
12764: OR
12765: IFFALSE 12710
// if not control in _control then
12767: LD_VAR 0 4
12771: PUSH
12772: LD_VAR 0 12
12776: IN
12777: NOT
12778: IFFALSE 12804
// control := _control [ rand ( 1 , _control ) ] ;
12780: LD_ADDR_VAR 0 4
12784: PUSH
12785: LD_VAR 0 12
12789: PUSH
12790: LD_INT 1
12792: PPUSH
12793: LD_VAR 0 12
12797: PPUSH
12798: CALL_OW 12
12802: ARRAY
12803: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12804: LD_VAR 0 2
12808: PPUSH
12809: LD_VAR 0 5
12813: PPUSH
12814: CALL 13172 0 2
12818: NOT
12819: IFFALSE 12878
// repeat weapon := _weapon [ 1 ] ;
12821: LD_ADDR_VAR 0 5
12825: PUSH
12826: LD_VAR 0 10
12830: PUSH
12831: LD_INT 1
12833: ARRAY
12834: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12835: LD_ADDR_VAR 0 10
12839: PUSH
12840: LD_VAR 0 10
12844: PPUSH
12845: LD_INT 1
12847: PPUSH
12848: CALL_OW 3
12852: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12853: LD_VAR 0 2
12857: PPUSH
12858: LD_VAR 0 5
12862: PPUSH
12863: CALL 13172 0 2
12867: PUSH
12868: LD_VAR 0 10
12872: PUSH
12873: EMPTY
12874: EQUAL
12875: OR
12876: IFFALSE 12821
// result := [ ] ;
12878: LD_ADDR_VAR 0 6
12882: PUSH
12883: EMPTY
12884: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12885: LD_VAR 0 1
12889: PPUSH
12890: LD_VAR 0 2
12894: PPUSH
12895: LD_VAR 0 3
12899: PPUSH
12900: LD_VAR 0 4
12904: PPUSH
12905: LD_VAR 0 5
12909: PPUSH
12910: CALL_OW 448
12914: IFFALSE 12947
// result := [ chassis , engine , control , weapon ] ;
12916: LD_ADDR_VAR 0 6
12920: PUSH
12921: LD_VAR 0 2
12925: PUSH
12926: LD_VAR 0 3
12930: PUSH
12931: LD_VAR 0 4
12935: PUSH
12936: LD_VAR 0 5
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: ST_TO_ADDR
// end ;
12947: LD_VAR 0 6
12951: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12952: LD_INT 0
12954: PPUSH
// if not chassis or not engine then
12955: LD_VAR 0 1
12959: NOT
12960: PUSH
12961: LD_VAR 0 2
12965: NOT
12966: OR
12967: IFFALSE 12971
// exit ;
12969: GO 13167
// case engine of engine_solar :
12971: LD_VAR 0 2
12975: PUSH
12976: LD_INT 2
12978: DOUBLE
12979: EQUAL
12980: IFTRUE 12984
12982: GO 13022
12984: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12985: LD_ADDR_VAR 0 3
12989: PUSH
12990: LD_INT 11
12992: PUSH
12993: LD_INT 12
12995: PUSH
12996: LD_INT 13
12998: PUSH
12999: LD_INT 14
13001: PUSH
13002: LD_INT 1
13004: PUSH
13005: LD_INT 2
13007: PUSH
13008: LD_INT 3
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: ST_TO_ADDR
13020: GO 13151
13022: LD_INT 1
13024: DOUBLE
13025: EQUAL
13026: IFTRUE 13030
13028: GO 13092
13030: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13031: LD_ADDR_VAR 0 3
13035: PUSH
13036: LD_INT 11
13038: PUSH
13039: LD_INT 12
13041: PUSH
13042: LD_INT 13
13044: PUSH
13045: LD_INT 14
13047: PUSH
13048: LD_INT 1
13050: PUSH
13051: LD_INT 2
13053: PUSH
13054: LD_INT 3
13056: PUSH
13057: LD_INT 4
13059: PUSH
13060: LD_INT 5
13062: PUSH
13063: LD_INT 21
13065: PUSH
13066: LD_INT 23
13068: PUSH
13069: LD_INT 22
13071: PUSH
13072: LD_INT 24
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: LIST
13087: LIST
13088: LIST
13089: ST_TO_ADDR
13090: GO 13151
13092: LD_INT 3
13094: DOUBLE
13095: EQUAL
13096: IFTRUE 13100
13098: GO 13150
13100: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13101: LD_ADDR_VAR 0 3
13105: PUSH
13106: LD_INT 13
13108: PUSH
13109: LD_INT 14
13111: PUSH
13112: LD_INT 2
13114: PUSH
13115: LD_INT 3
13117: PUSH
13118: LD_INT 4
13120: PUSH
13121: LD_INT 5
13123: PUSH
13124: LD_INT 21
13126: PUSH
13127: LD_INT 22
13129: PUSH
13130: LD_INT 23
13132: PUSH
13133: LD_INT 24
13135: PUSH
13136: EMPTY
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: ST_TO_ADDR
13148: GO 13151
13150: POP
// result := ( chassis in result ) ;
13151: LD_ADDR_VAR 0 3
13155: PUSH
13156: LD_VAR 0 1
13160: PUSH
13161: LD_VAR 0 3
13165: IN
13166: ST_TO_ADDR
// end ;
13167: LD_VAR 0 3
13171: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13172: LD_INT 0
13174: PPUSH
// if not chassis or not weapon then
13175: LD_VAR 0 1
13179: NOT
13180: PUSH
13181: LD_VAR 0 2
13185: NOT
13186: OR
13187: IFFALSE 13191
// exit ;
13189: GO 14217
// case weapon of us_machine_gun :
13191: LD_VAR 0 2
13195: PUSH
13196: LD_INT 2
13198: DOUBLE
13199: EQUAL
13200: IFTRUE 13204
13202: GO 13234
13204: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13205: LD_ADDR_VAR 0 3
13209: PUSH
13210: LD_INT 1
13212: PUSH
13213: LD_INT 2
13215: PUSH
13216: LD_INT 3
13218: PUSH
13219: LD_INT 4
13221: PUSH
13222: LD_INT 5
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: ST_TO_ADDR
13232: GO 14201
13234: LD_INT 3
13236: DOUBLE
13237: EQUAL
13238: IFTRUE 13242
13240: GO 13272
13242: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13243: LD_ADDR_VAR 0 3
13247: PUSH
13248: LD_INT 1
13250: PUSH
13251: LD_INT 2
13253: PUSH
13254: LD_INT 3
13256: PUSH
13257: LD_INT 4
13259: PUSH
13260: LD_INT 5
13262: PUSH
13263: EMPTY
13264: LIST
13265: LIST
13266: LIST
13267: LIST
13268: LIST
13269: ST_TO_ADDR
13270: GO 14201
13272: LD_INT 11
13274: DOUBLE
13275: EQUAL
13276: IFTRUE 13280
13278: GO 13310
13280: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13281: LD_ADDR_VAR 0 3
13285: PUSH
13286: LD_INT 1
13288: PUSH
13289: LD_INT 2
13291: PUSH
13292: LD_INT 3
13294: PUSH
13295: LD_INT 4
13297: PUSH
13298: LD_INT 5
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: LIST
13305: LIST
13306: LIST
13307: ST_TO_ADDR
13308: GO 14201
13310: LD_INT 4
13312: DOUBLE
13313: EQUAL
13314: IFTRUE 13318
13316: GO 13344
13318: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13319: LD_ADDR_VAR 0 3
13323: PUSH
13324: LD_INT 2
13326: PUSH
13327: LD_INT 3
13329: PUSH
13330: LD_INT 4
13332: PUSH
13333: LD_INT 5
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: ST_TO_ADDR
13342: GO 14201
13344: LD_INT 5
13346: DOUBLE
13347: EQUAL
13348: IFTRUE 13352
13350: GO 13378
13352: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13353: LD_ADDR_VAR 0 3
13357: PUSH
13358: LD_INT 2
13360: PUSH
13361: LD_INT 3
13363: PUSH
13364: LD_INT 4
13366: PUSH
13367: LD_INT 5
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: ST_TO_ADDR
13376: GO 14201
13378: LD_INT 9
13380: DOUBLE
13381: EQUAL
13382: IFTRUE 13386
13384: GO 13412
13386: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13387: LD_ADDR_VAR 0 3
13391: PUSH
13392: LD_INT 2
13394: PUSH
13395: LD_INT 3
13397: PUSH
13398: LD_INT 4
13400: PUSH
13401: LD_INT 5
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: LIST
13408: LIST
13409: ST_TO_ADDR
13410: GO 14201
13412: LD_INT 7
13414: DOUBLE
13415: EQUAL
13416: IFTRUE 13420
13418: GO 13446
13420: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13421: LD_ADDR_VAR 0 3
13425: PUSH
13426: LD_INT 2
13428: PUSH
13429: LD_INT 3
13431: PUSH
13432: LD_INT 4
13434: PUSH
13435: LD_INT 5
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: LIST
13442: LIST
13443: ST_TO_ADDR
13444: GO 14201
13446: LD_INT 12
13448: DOUBLE
13449: EQUAL
13450: IFTRUE 13454
13452: GO 13480
13454: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13455: LD_ADDR_VAR 0 3
13459: PUSH
13460: LD_INT 2
13462: PUSH
13463: LD_INT 3
13465: PUSH
13466: LD_INT 4
13468: PUSH
13469: LD_INT 5
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: LIST
13476: LIST
13477: ST_TO_ADDR
13478: GO 14201
13480: LD_INT 13
13482: DOUBLE
13483: EQUAL
13484: IFTRUE 13488
13486: GO 13514
13488: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13489: LD_ADDR_VAR 0 3
13493: PUSH
13494: LD_INT 2
13496: PUSH
13497: LD_INT 3
13499: PUSH
13500: LD_INT 4
13502: PUSH
13503: LD_INT 5
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: LIST
13510: LIST
13511: ST_TO_ADDR
13512: GO 14201
13514: LD_INT 14
13516: DOUBLE
13517: EQUAL
13518: IFTRUE 13522
13520: GO 13540
13522: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13523: LD_ADDR_VAR 0 3
13527: PUSH
13528: LD_INT 4
13530: PUSH
13531: LD_INT 5
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: ST_TO_ADDR
13538: GO 14201
13540: LD_INT 6
13542: DOUBLE
13543: EQUAL
13544: IFTRUE 13548
13546: GO 13566
13548: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13549: LD_ADDR_VAR 0 3
13553: PUSH
13554: LD_INT 4
13556: PUSH
13557: LD_INT 5
13559: PUSH
13560: EMPTY
13561: LIST
13562: LIST
13563: ST_TO_ADDR
13564: GO 14201
13566: LD_INT 10
13568: DOUBLE
13569: EQUAL
13570: IFTRUE 13574
13572: GO 13592
13574: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13575: LD_ADDR_VAR 0 3
13579: PUSH
13580: LD_INT 4
13582: PUSH
13583: LD_INT 5
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: ST_TO_ADDR
13590: GO 14201
13592: LD_INT 22
13594: DOUBLE
13595: EQUAL
13596: IFTRUE 13600
13598: GO 13626
13600: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13601: LD_ADDR_VAR 0 3
13605: PUSH
13606: LD_INT 11
13608: PUSH
13609: LD_INT 12
13611: PUSH
13612: LD_INT 13
13614: PUSH
13615: LD_INT 14
13617: PUSH
13618: EMPTY
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: ST_TO_ADDR
13624: GO 14201
13626: LD_INT 23
13628: DOUBLE
13629: EQUAL
13630: IFTRUE 13634
13632: GO 13660
13634: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13635: LD_ADDR_VAR 0 3
13639: PUSH
13640: LD_INT 11
13642: PUSH
13643: LD_INT 12
13645: PUSH
13646: LD_INT 13
13648: PUSH
13649: LD_INT 14
13651: PUSH
13652: EMPTY
13653: LIST
13654: LIST
13655: LIST
13656: LIST
13657: ST_TO_ADDR
13658: GO 14201
13660: LD_INT 24
13662: DOUBLE
13663: EQUAL
13664: IFTRUE 13668
13666: GO 13694
13668: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13669: LD_ADDR_VAR 0 3
13673: PUSH
13674: LD_INT 11
13676: PUSH
13677: LD_INT 12
13679: PUSH
13680: LD_INT 13
13682: PUSH
13683: LD_INT 14
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: ST_TO_ADDR
13692: GO 14201
13694: LD_INT 30
13696: DOUBLE
13697: EQUAL
13698: IFTRUE 13702
13700: GO 13728
13702: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13703: LD_ADDR_VAR 0 3
13707: PUSH
13708: LD_INT 11
13710: PUSH
13711: LD_INT 12
13713: PUSH
13714: LD_INT 13
13716: PUSH
13717: LD_INT 14
13719: PUSH
13720: EMPTY
13721: LIST
13722: LIST
13723: LIST
13724: LIST
13725: ST_TO_ADDR
13726: GO 14201
13728: LD_INT 25
13730: DOUBLE
13731: EQUAL
13732: IFTRUE 13736
13734: GO 13754
13736: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13737: LD_ADDR_VAR 0 3
13741: PUSH
13742: LD_INT 13
13744: PUSH
13745: LD_INT 14
13747: PUSH
13748: EMPTY
13749: LIST
13750: LIST
13751: ST_TO_ADDR
13752: GO 14201
13754: LD_INT 27
13756: DOUBLE
13757: EQUAL
13758: IFTRUE 13762
13760: GO 13780
13762: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13763: LD_ADDR_VAR 0 3
13767: PUSH
13768: LD_INT 13
13770: PUSH
13771: LD_INT 14
13773: PUSH
13774: EMPTY
13775: LIST
13776: LIST
13777: ST_TO_ADDR
13778: GO 14201
13780: LD_INT 28
13782: DOUBLE
13783: EQUAL
13784: IFTRUE 13788
13786: GO 13806
13788: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13789: LD_ADDR_VAR 0 3
13793: PUSH
13794: LD_INT 13
13796: PUSH
13797: LD_INT 14
13799: PUSH
13800: EMPTY
13801: LIST
13802: LIST
13803: ST_TO_ADDR
13804: GO 14201
13806: LD_INT 29
13808: DOUBLE
13809: EQUAL
13810: IFTRUE 13814
13812: GO 13832
13814: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13815: LD_ADDR_VAR 0 3
13819: PUSH
13820: LD_INT 13
13822: PUSH
13823: LD_INT 14
13825: PUSH
13826: EMPTY
13827: LIST
13828: LIST
13829: ST_TO_ADDR
13830: GO 14201
13832: LD_INT 31
13834: DOUBLE
13835: EQUAL
13836: IFTRUE 13840
13838: GO 13858
13840: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13841: LD_ADDR_VAR 0 3
13845: PUSH
13846: LD_INT 13
13848: PUSH
13849: LD_INT 14
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: ST_TO_ADDR
13856: GO 14201
13858: LD_INT 26
13860: DOUBLE
13861: EQUAL
13862: IFTRUE 13866
13864: GO 13884
13866: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13867: LD_ADDR_VAR 0 3
13871: PUSH
13872: LD_INT 13
13874: PUSH
13875: LD_INT 14
13877: PUSH
13878: EMPTY
13879: LIST
13880: LIST
13881: ST_TO_ADDR
13882: GO 14201
13884: LD_INT 42
13886: DOUBLE
13887: EQUAL
13888: IFTRUE 13892
13890: GO 13918
13892: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13893: LD_ADDR_VAR 0 3
13897: PUSH
13898: LD_INT 21
13900: PUSH
13901: LD_INT 22
13903: PUSH
13904: LD_INT 23
13906: PUSH
13907: LD_INT 24
13909: PUSH
13910: EMPTY
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: ST_TO_ADDR
13916: GO 14201
13918: LD_INT 43
13920: DOUBLE
13921: EQUAL
13922: IFTRUE 13926
13924: GO 13952
13926: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13927: LD_ADDR_VAR 0 3
13931: PUSH
13932: LD_INT 21
13934: PUSH
13935: LD_INT 22
13937: PUSH
13938: LD_INT 23
13940: PUSH
13941: LD_INT 24
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: ST_TO_ADDR
13950: GO 14201
13952: LD_INT 44
13954: DOUBLE
13955: EQUAL
13956: IFTRUE 13960
13958: GO 13986
13960: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13961: LD_ADDR_VAR 0 3
13965: PUSH
13966: LD_INT 21
13968: PUSH
13969: LD_INT 22
13971: PUSH
13972: LD_INT 23
13974: PUSH
13975: LD_INT 24
13977: PUSH
13978: EMPTY
13979: LIST
13980: LIST
13981: LIST
13982: LIST
13983: ST_TO_ADDR
13984: GO 14201
13986: LD_INT 45
13988: DOUBLE
13989: EQUAL
13990: IFTRUE 13994
13992: GO 14020
13994: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13995: LD_ADDR_VAR 0 3
13999: PUSH
14000: LD_INT 21
14002: PUSH
14003: LD_INT 22
14005: PUSH
14006: LD_INT 23
14008: PUSH
14009: LD_INT 24
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: ST_TO_ADDR
14018: GO 14201
14020: LD_INT 49
14022: DOUBLE
14023: EQUAL
14024: IFTRUE 14028
14026: GO 14054
14028: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14029: LD_ADDR_VAR 0 3
14033: PUSH
14034: LD_INT 21
14036: PUSH
14037: LD_INT 22
14039: PUSH
14040: LD_INT 23
14042: PUSH
14043: LD_INT 24
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: LIST
14050: LIST
14051: ST_TO_ADDR
14052: GO 14201
14054: LD_INT 51
14056: DOUBLE
14057: EQUAL
14058: IFTRUE 14062
14060: GO 14088
14062: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14063: LD_ADDR_VAR 0 3
14067: PUSH
14068: LD_INT 21
14070: PUSH
14071: LD_INT 22
14073: PUSH
14074: LD_INT 23
14076: PUSH
14077: LD_INT 24
14079: PUSH
14080: EMPTY
14081: LIST
14082: LIST
14083: LIST
14084: LIST
14085: ST_TO_ADDR
14086: GO 14201
14088: LD_INT 52
14090: DOUBLE
14091: EQUAL
14092: IFTRUE 14096
14094: GO 14122
14096: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14097: LD_ADDR_VAR 0 3
14101: PUSH
14102: LD_INT 21
14104: PUSH
14105: LD_INT 22
14107: PUSH
14108: LD_INT 23
14110: PUSH
14111: LD_INT 24
14113: PUSH
14114: EMPTY
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: ST_TO_ADDR
14120: GO 14201
14122: LD_INT 53
14124: DOUBLE
14125: EQUAL
14126: IFTRUE 14130
14128: GO 14148
14130: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14131: LD_ADDR_VAR 0 3
14135: PUSH
14136: LD_INT 23
14138: PUSH
14139: LD_INT 24
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: ST_TO_ADDR
14146: GO 14201
14148: LD_INT 46
14150: DOUBLE
14151: EQUAL
14152: IFTRUE 14156
14154: GO 14174
14156: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14157: LD_ADDR_VAR 0 3
14161: PUSH
14162: LD_INT 23
14164: PUSH
14165: LD_INT 24
14167: PUSH
14168: EMPTY
14169: LIST
14170: LIST
14171: ST_TO_ADDR
14172: GO 14201
14174: LD_INT 47
14176: DOUBLE
14177: EQUAL
14178: IFTRUE 14182
14180: GO 14200
14182: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14183: LD_ADDR_VAR 0 3
14187: PUSH
14188: LD_INT 23
14190: PUSH
14191: LD_INT 24
14193: PUSH
14194: EMPTY
14195: LIST
14196: LIST
14197: ST_TO_ADDR
14198: GO 14201
14200: POP
// result := ( chassis in result ) ;
14201: LD_ADDR_VAR 0 3
14205: PUSH
14206: LD_VAR 0 1
14210: PUSH
14211: LD_VAR 0 3
14215: IN
14216: ST_TO_ADDR
// end ;
14217: LD_VAR 0 3
14221: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14222: LD_INT 0
14224: PPUSH
14225: PPUSH
14226: PPUSH
14227: PPUSH
14228: PPUSH
14229: PPUSH
14230: PPUSH
// result := array ;
14231: LD_ADDR_VAR 0 5
14235: PUSH
14236: LD_VAR 0 1
14240: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14241: LD_VAR 0 1
14245: NOT
14246: PUSH
14247: LD_VAR 0 2
14251: NOT
14252: OR
14253: PUSH
14254: LD_VAR 0 3
14258: NOT
14259: OR
14260: PUSH
14261: LD_VAR 0 2
14265: PUSH
14266: LD_VAR 0 1
14270: GREATER
14271: OR
14272: PUSH
14273: LD_VAR 0 3
14277: PUSH
14278: LD_VAR 0 1
14282: GREATER
14283: OR
14284: IFFALSE 14288
// exit ;
14286: GO 14584
// if direction then
14288: LD_VAR 0 4
14292: IFFALSE 14356
// begin d := 1 ;
14294: LD_ADDR_VAR 0 9
14298: PUSH
14299: LD_INT 1
14301: ST_TO_ADDR
// if i_from > i_to then
14302: LD_VAR 0 2
14306: PUSH
14307: LD_VAR 0 3
14311: GREATER
14312: IFFALSE 14338
// length := ( array - i_from ) + i_to else
14314: LD_ADDR_VAR 0 11
14318: PUSH
14319: LD_VAR 0 1
14323: PUSH
14324: LD_VAR 0 2
14328: MINUS
14329: PUSH
14330: LD_VAR 0 3
14334: PLUS
14335: ST_TO_ADDR
14336: GO 14354
// length := i_to - i_from ;
14338: LD_ADDR_VAR 0 11
14342: PUSH
14343: LD_VAR 0 3
14347: PUSH
14348: LD_VAR 0 2
14352: MINUS
14353: ST_TO_ADDR
// end else
14354: GO 14417
// begin d := - 1 ;
14356: LD_ADDR_VAR 0 9
14360: PUSH
14361: LD_INT 1
14363: NEG
14364: ST_TO_ADDR
// if i_from > i_to then
14365: LD_VAR 0 2
14369: PUSH
14370: LD_VAR 0 3
14374: GREATER
14375: IFFALSE 14395
// length := i_from - i_to else
14377: LD_ADDR_VAR 0 11
14381: PUSH
14382: LD_VAR 0 2
14386: PUSH
14387: LD_VAR 0 3
14391: MINUS
14392: ST_TO_ADDR
14393: GO 14417
// length := ( array - i_to ) + i_from ;
14395: LD_ADDR_VAR 0 11
14399: PUSH
14400: LD_VAR 0 1
14404: PUSH
14405: LD_VAR 0 3
14409: MINUS
14410: PUSH
14411: LD_VAR 0 2
14415: PLUS
14416: ST_TO_ADDR
// end ; if not length then
14417: LD_VAR 0 11
14421: NOT
14422: IFFALSE 14426
// exit ;
14424: GO 14584
// tmp := array ;
14426: LD_ADDR_VAR 0 10
14430: PUSH
14431: LD_VAR 0 1
14435: ST_TO_ADDR
// for i = 1 to length do
14436: LD_ADDR_VAR 0 6
14440: PUSH
14441: DOUBLE
14442: LD_INT 1
14444: DEC
14445: ST_TO_ADDR
14446: LD_VAR 0 11
14450: PUSH
14451: FOR_TO
14452: IFFALSE 14572
// begin for j = 1 to array do
14454: LD_ADDR_VAR 0 7
14458: PUSH
14459: DOUBLE
14460: LD_INT 1
14462: DEC
14463: ST_TO_ADDR
14464: LD_VAR 0 1
14468: PUSH
14469: FOR_TO
14470: IFFALSE 14558
// begin k := j + d ;
14472: LD_ADDR_VAR 0 8
14476: PUSH
14477: LD_VAR 0 7
14481: PUSH
14482: LD_VAR 0 9
14486: PLUS
14487: ST_TO_ADDR
// if k > array then
14488: LD_VAR 0 8
14492: PUSH
14493: LD_VAR 0 1
14497: GREATER
14498: IFFALSE 14508
// k := 1 ;
14500: LD_ADDR_VAR 0 8
14504: PUSH
14505: LD_INT 1
14507: ST_TO_ADDR
// if not k then
14508: LD_VAR 0 8
14512: NOT
14513: IFFALSE 14525
// k := array ;
14515: LD_ADDR_VAR 0 8
14519: PUSH
14520: LD_VAR 0 1
14524: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14525: LD_ADDR_VAR 0 10
14529: PUSH
14530: LD_VAR 0 10
14534: PPUSH
14535: LD_VAR 0 8
14539: PPUSH
14540: LD_VAR 0 1
14544: PUSH
14545: LD_VAR 0 7
14549: ARRAY
14550: PPUSH
14551: CALL_OW 1
14555: ST_TO_ADDR
// end ;
14556: GO 14469
14558: POP
14559: POP
// array := tmp ;
14560: LD_ADDR_VAR 0 1
14564: PUSH
14565: LD_VAR 0 10
14569: ST_TO_ADDR
// end ;
14570: GO 14451
14572: POP
14573: POP
// result := array ;
14574: LD_ADDR_VAR 0 5
14578: PUSH
14579: LD_VAR 0 1
14583: ST_TO_ADDR
// end ;
14584: LD_VAR 0 5
14588: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14589: LD_INT 0
14591: PPUSH
14592: PPUSH
// result := 0 ;
14593: LD_ADDR_VAR 0 3
14597: PUSH
14598: LD_INT 0
14600: ST_TO_ADDR
// if not array or not value in array then
14601: LD_VAR 0 1
14605: NOT
14606: PUSH
14607: LD_VAR 0 2
14611: PUSH
14612: LD_VAR 0 1
14616: IN
14617: NOT
14618: OR
14619: IFFALSE 14623
// exit ;
14621: GO 14677
// for i = 1 to array do
14623: LD_ADDR_VAR 0 4
14627: PUSH
14628: DOUBLE
14629: LD_INT 1
14631: DEC
14632: ST_TO_ADDR
14633: LD_VAR 0 1
14637: PUSH
14638: FOR_TO
14639: IFFALSE 14675
// if value = array [ i ] then
14641: LD_VAR 0 2
14645: PUSH
14646: LD_VAR 0 1
14650: PUSH
14651: LD_VAR 0 4
14655: ARRAY
14656: EQUAL
14657: IFFALSE 14673
// begin result := i ;
14659: LD_ADDR_VAR 0 3
14663: PUSH
14664: LD_VAR 0 4
14668: ST_TO_ADDR
// exit ;
14669: POP
14670: POP
14671: GO 14677
// end ;
14673: GO 14638
14675: POP
14676: POP
// end ;
14677: LD_VAR 0 3
14681: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14682: LD_INT 0
14684: PPUSH
// vc_chassis := chassis ;
14685: LD_ADDR_OWVAR 37
14689: PUSH
14690: LD_VAR 0 1
14694: ST_TO_ADDR
// vc_engine := engine ;
14695: LD_ADDR_OWVAR 39
14699: PUSH
14700: LD_VAR 0 2
14704: ST_TO_ADDR
// vc_control := control ;
14705: LD_ADDR_OWVAR 38
14709: PUSH
14710: LD_VAR 0 3
14714: ST_TO_ADDR
// vc_weapon := weapon ;
14715: LD_ADDR_OWVAR 40
14719: PUSH
14720: LD_VAR 0 4
14724: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14725: LD_ADDR_OWVAR 41
14729: PUSH
14730: LD_VAR 0 5
14734: ST_TO_ADDR
// end ;
14735: LD_VAR 0 6
14739: RET
// export function WantPlant ( unit ) ; var task ; begin
14740: LD_INT 0
14742: PPUSH
14743: PPUSH
// result := false ;
14744: LD_ADDR_VAR 0 2
14748: PUSH
14749: LD_INT 0
14751: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14752: LD_ADDR_VAR 0 3
14756: PUSH
14757: LD_VAR 0 1
14761: PPUSH
14762: CALL_OW 437
14766: ST_TO_ADDR
// if task then
14767: LD_VAR 0 3
14771: IFFALSE 14799
// if task [ 1 ] [ 1 ] = p then
14773: LD_VAR 0 3
14777: PUSH
14778: LD_INT 1
14780: ARRAY
14781: PUSH
14782: LD_INT 1
14784: ARRAY
14785: PUSH
14786: LD_STRING p
14788: EQUAL
14789: IFFALSE 14799
// result := true ;
14791: LD_ADDR_VAR 0 2
14795: PUSH
14796: LD_INT 1
14798: ST_TO_ADDR
// end ;
14799: LD_VAR 0 2
14803: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14804: LD_INT 0
14806: PPUSH
14807: PPUSH
14808: PPUSH
14809: PPUSH
// if pos < 1 then
14810: LD_VAR 0 2
14814: PUSH
14815: LD_INT 1
14817: LESS
14818: IFFALSE 14822
// exit ;
14820: GO 15125
// if pos = 1 then
14822: LD_VAR 0 2
14826: PUSH
14827: LD_INT 1
14829: EQUAL
14830: IFFALSE 14863
// result := Replace ( arr , pos [ 1 ] , value ) else
14832: LD_ADDR_VAR 0 4
14836: PUSH
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_VAR 0 2
14846: PUSH
14847: LD_INT 1
14849: ARRAY
14850: PPUSH
14851: LD_VAR 0 3
14855: PPUSH
14856: CALL_OW 1
14860: ST_TO_ADDR
14861: GO 15125
// begin tmp := arr ;
14863: LD_ADDR_VAR 0 6
14867: PUSH
14868: LD_VAR 0 1
14872: ST_TO_ADDR
// s_arr := [ tmp ] ;
14873: LD_ADDR_VAR 0 7
14877: PUSH
14878: LD_VAR 0 6
14882: PUSH
14883: EMPTY
14884: LIST
14885: ST_TO_ADDR
// for i = 1 to pos - 1 do
14886: LD_ADDR_VAR 0 5
14890: PUSH
14891: DOUBLE
14892: LD_INT 1
14894: DEC
14895: ST_TO_ADDR
14896: LD_VAR 0 2
14900: PUSH
14901: LD_INT 1
14903: MINUS
14904: PUSH
14905: FOR_TO
14906: IFFALSE 14951
// begin tmp := tmp [ pos [ i ] ] ;
14908: LD_ADDR_VAR 0 6
14912: PUSH
14913: LD_VAR 0 6
14917: PUSH
14918: LD_VAR 0 2
14922: PUSH
14923: LD_VAR 0 5
14927: ARRAY
14928: ARRAY
14929: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14930: LD_ADDR_VAR 0 7
14934: PUSH
14935: LD_VAR 0 7
14939: PUSH
14940: LD_VAR 0 6
14944: PUSH
14945: EMPTY
14946: LIST
14947: ADD
14948: ST_TO_ADDR
// end ;
14949: GO 14905
14951: POP
14952: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14953: LD_ADDR_VAR 0 6
14957: PUSH
14958: LD_VAR 0 6
14962: PPUSH
14963: LD_VAR 0 2
14967: PUSH
14968: LD_VAR 0 2
14972: ARRAY
14973: PPUSH
14974: LD_VAR 0 3
14978: PPUSH
14979: CALL_OW 1
14983: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14984: LD_ADDR_VAR 0 7
14988: PUSH
14989: LD_VAR 0 7
14993: PPUSH
14994: LD_VAR 0 7
14998: PPUSH
14999: LD_VAR 0 6
15003: PPUSH
15004: CALL_OW 1
15008: ST_TO_ADDR
// for i = s_arr downto 2 do
15009: LD_ADDR_VAR 0 5
15013: PUSH
15014: DOUBLE
15015: LD_VAR 0 7
15019: INC
15020: ST_TO_ADDR
15021: LD_INT 2
15023: PUSH
15024: FOR_DOWNTO
15025: IFFALSE 15109
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15027: LD_ADDR_VAR 0 6
15031: PUSH
15032: LD_VAR 0 7
15036: PUSH
15037: LD_VAR 0 5
15041: PUSH
15042: LD_INT 1
15044: MINUS
15045: ARRAY
15046: PPUSH
15047: LD_VAR 0 2
15051: PUSH
15052: LD_VAR 0 5
15056: PUSH
15057: LD_INT 1
15059: MINUS
15060: ARRAY
15061: PPUSH
15062: LD_VAR 0 7
15066: PUSH
15067: LD_VAR 0 5
15071: ARRAY
15072: PPUSH
15073: CALL_OW 1
15077: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15078: LD_ADDR_VAR 0 7
15082: PUSH
15083: LD_VAR 0 7
15087: PPUSH
15088: LD_VAR 0 5
15092: PUSH
15093: LD_INT 1
15095: MINUS
15096: PPUSH
15097: LD_VAR 0 6
15101: PPUSH
15102: CALL_OW 1
15106: ST_TO_ADDR
// end ;
15107: GO 15024
15109: POP
15110: POP
// result := s_arr [ 1 ] ;
15111: LD_ADDR_VAR 0 4
15115: PUSH
15116: LD_VAR 0 7
15120: PUSH
15121: LD_INT 1
15123: ARRAY
15124: ST_TO_ADDR
// end ; end ;
15125: LD_VAR 0 4
15129: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15130: LD_INT 0
15132: PPUSH
15133: PPUSH
// if not list then
15134: LD_VAR 0 1
15138: NOT
15139: IFFALSE 15143
// exit ;
15141: GO 15234
// i := list [ pos1 ] ;
15143: LD_ADDR_VAR 0 5
15147: PUSH
15148: LD_VAR 0 1
15152: PUSH
15153: LD_VAR 0 2
15157: ARRAY
15158: ST_TO_ADDR
// if not i then
15159: LD_VAR 0 5
15163: NOT
15164: IFFALSE 15168
// exit ;
15166: GO 15234
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15168: LD_ADDR_VAR 0 1
15172: PUSH
15173: LD_VAR 0 1
15177: PPUSH
15178: LD_VAR 0 2
15182: PPUSH
15183: LD_VAR 0 1
15187: PUSH
15188: LD_VAR 0 3
15192: ARRAY
15193: PPUSH
15194: CALL_OW 1
15198: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15199: LD_ADDR_VAR 0 1
15203: PUSH
15204: LD_VAR 0 1
15208: PPUSH
15209: LD_VAR 0 3
15213: PPUSH
15214: LD_VAR 0 5
15218: PPUSH
15219: CALL_OW 1
15223: ST_TO_ADDR
// result := list ;
15224: LD_ADDR_VAR 0 4
15228: PUSH
15229: LD_VAR 0 1
15233: ST_TO_ADDR
// end ;
15234: LD_VAR 0 4
15238: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15239: LD_INT 0
15241: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15242: LD_ADDR_VAR 0 5
15246: PUSH
15247: LD_VAR 0 1
15251: PPUSH
15252: CALL_OW 250
15256: PPUSH
15257: LD_VAR 0 1
15261: PPUSH
15262: CALL_OW 251
15266: PPUSH
15267: LD_VAR 0 2
15271: PPUSH
15272: LD_VAR 0 3
15276: PPUSH
15277: LD_VAR 0 4
15281: PPUSH
15282: CALL 15292 0 5
15286: ST_TO_ADDR
// end ;
15287: LD_VAR 0 5
15291: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15292: LD_INT 0
15294: PPUSH
15295: PPUSH
15296: PPUSH
15297: PPUSH
// if not list then
15298: LD_VAR 0 3
15302: NOT
15303: IFFALSE 15307
// exit ;
15305: GO 15695
// result := [ ] ;
15307: LD_ADDR_VAR 0 6
15311: PUSH
15312: EMPTY
15313: ST_TO_ADDR
// for i in list do
15314: LD_ADDR_VAR 0 7
15318: PUSH
15319: LD_VAR 0 3
15323: PUSH
15324: FOR_IN
15325: IFFALSE 15527
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15327: LD_ADDR_VAR 0 9
15331: PUSH
15332: LD_VAR 0 7
15336: PPUSH
15337: LD_VAR 0 1
15341: PPUSH
15342: LD_VAR 0 2
15346: PPUSH
15347: CALL_OW 297
15351: ST_TO_ADDR
// if not result then
15352: LD_VAR 0 6
15356: NOT
15357: IFFALSE 15383
// result := [ [ i , tmp ] ] else
15359: LD_ADDR_VAR 0 6
15363: PUSH
15364: LD_VAR 0 7
15368: PUSH
15369: LD_VAR 0 9
15373: PUSH
15374: EMPTY
15375: LIST
15376: LIST
15377: PUSH
15378: EMPTY
15379: LIST
15380: ST_TO_ADDR
15381: GO 15525
// begin if result [ result ] [ 2 ] < tmp then
15383: LD_VAR 0 6
15387: PUSH
15388: LD_VAR 0 6
15392: ARRAY
15393: PUSH
15394: LD_INT 2
15396: ARRAY
15397: PUSH
15398: LD_VAR 0 9
15402: LESS
15403: IFFALSE 15445
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15405: LD_ADDR_VAR 0 6
15409: PUSH
15410: LD_VAR 0 6
15414: PPUSH
15415: LD_VAR 0 6
15419: PUSH
15420: LD_INT 1
15422: PLUS
15423: PPUSH
15424: LD_VAR 0 7
15428: PUSH
15429: LD_VAR 0 9
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PPUSH
15438: CALL_OW 2
15442: ST_TO_ADDR
15443: GO 15525
// for j = 1 to result do
15445: LD_ADDR_VAR 0 8
15449: PUSH
15450: DOUBLE
15451: LD_INT 1
15453: DEC
15454: ST_TO_ADDR
15455: LD_VAR 0 6
15459: PUSH
15460: FOR_TO
15461: IFFALSE 15523
// begin if tmp < result [ j ] [ 2 ] then
15463: LD_VAR 0 9
15467: PUSH
15468: LD_VAR 0 6
15472: PUSH
15473: LD_VAR 0 8
15477: ARRAY
15478: PUSH
15479: LD_INT 2
15481: ARRAY
15482: LESS
15483: IFFALSE 15521
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15485: LD_ADDR_VAR 0 6
15489: PUSH
15490: LD_VAR 0 6
15494: PPUSH
15495: LD_VAR 0 8
15499: PPUSH
15500: LD_VAR 0 7
15504: PUSH
15505: LD_VAR 0 9
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: PPUSH
15514: CALL_OW 2
15518: ST_TO_ADDR
// break ;
15519: GO 15523
// end ; end ;
15521: GO 15460
15523: POP
15524: POP
// end ; end ;
15525: GO 15324
15527: POP
15528: POP
// if result and not asc then
15529: LD_VAR 0 6
15533: PUSH
15534: LD_VAR 0 4
15538: NOT
15539: AND
15540: IFFALSE 15615
// begin tmp := result ;
15542: LD_ADDR_VAR 0 9
15546: PUSH
15547: LD_VAR 0 6
15551: ST_TO_ADDR
// for i = tmp downto 1 do
15552: LD_ADDR_VAR 0 7
15556: PUSH
15557: DOUBLE
15558: LD_VAR 0 9
15562: INC
15563: ST_TO_ADDR
15564: LD_INT 1
15566: PUSH
15567: FOR_DOWNTO
15568: IFFALSE 15613
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15570: LD_ADDR_VAR 0 6
15574: PUSH
15575: LD_VAR 0 6
15579: PPUSH
15580: LD_VAR 0 9
15584: PUSH
15585: LD_VAR 0 7
15589: MINUS
15590: PUSH
15591: LD_INT 1
15593: PLUS
15594: PPUSH
15595: LD_VAR 0 9
15599: PUSH
15600: LD_VAR 0 7
15604: ARRAY
15605: PPUSH
15606: CALL_OW 1
15610: ST_TO_ADDR
15611: GO 15567
15613: POP
15614: POP
// end ; tmp := [ ] ;
15615: LD_ADDR_VAR 0 9
15619: PUSH
15620: EMPTY
15621: ST_TO_ADDR
// if mode then
15622: LD_VAR 0 5
15626: IFFALSE 15695
// begin for i = 1 to result do
15628: LD_ADDR_VAR 0 7
15632: PUSH
15633: DOUBLE
15634: LD_INT 1
15636: DEC
15637: ST_TO_ADDR
15638: LD_VAR 0 6
15642: PUSH
15643: FOR_TO
15644: IFFALSE 15683
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15646: LD_ADDR_VAR 0 9
15650: PUSH
15651: LD_VAR 0 9
15655: PPUSH
15656: LD_VAR 0 7
15660: PPUSH
15661: LD_VAR 0 6
15665: PUSH
15666: LD_VAR 0 7
15670: ARRAY
15671: PUSH
15672: LD_INT 1
15674: ARRAY
15675: PPUSH
15676: CALL_OW 1
15680: ST_TO_ADDR
15681: GO 15643
15683: POP
15684: POP
// result := tmp ;
15685: LD_ADDR_VAR 0 6
15689: PUSH
15690: LD_VAR 0 9
15694: ST_TO_ADDR
// end ; end ;
15695: LD_VAR 0 6
15699: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15700: LD_INT 0
15702: PPUSH
15703: PPUSH
15704: PPUSH
15705: PPUSH
15706: PPUSH
15707: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15708: LD_ADDR_VAR 0 5
15712: PUSH
15713: LD_INT 0
15715: PUSH
15716: LD_INT 0
15718: PUSH
15719: LD_INT 0
15721: PUSH
15722: EMPTY
15723: PUSH
15724: EMPTY
15725: LIST
15726: LIST
15727: LIST
15728: LIST
15729: ST_TO_ADDR
// if not x or not y then
15730: LD_VAR 0 2
15734: NOT
15735: PUSH
15736: LD_VAR 0 3
15740: NOT
15741: OR
15742: IFFALSE 15746
// exit ;
15744: GO 17392
// if not range then
15746: LD_VAR 0 4
15750: NOT
15751: IFFALSE 15761
// range := 10 ;
15753: LD_ADDR_VAR 0 4
15757: PUSH
15758: LD_INT 10
15760: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15761: LD_ADDR_VAR 0 8
15765: PUSH
15766: LD_INT 81
15768: PUSH
15769: LD_VAR 0 1
15773: PUSH
15774: EMPTY
15775: LIST
15776: LIST
15777: PUSH
15778: LD_INT 92
15780: PUSH
15781: LD_VAR 0 2
15785: PUSH
15786: LD_VAR 0 3
15790: PUSH
15791: LD_VAR 0 4
15795: PUSH
15796: EMPTY
15797: LIST
15798: LIST
15799: LIST
15800: LIST
15801: PUSH
15802: LD_INT 3
15804: PUSH
15805: LD_INT 21
15807: PUSH
15808: LD_INT 3
15810: PUSH
15811: EMPTY
15812: LIST
15813: LIST
15814: PUSH
15815: EMPTY
15816: LIST
15817: LIST
15818: PUSH
15819: EMPTY
15820: LIST
15821: LIST
15822: LIST
15823: PPUSH
15824: CALL_OW 69
15828: ST_TO_ADDR
// if not tmp then
15829: LD_VAR 0 8
15833: NOT
15834: IFFALSE 15838
// exit ;
15836: GO 17392
// for i in tmp do
15838: LD_ADDR_VAR 0 6
15842: PUSH
15843: LD_VAR 0 8
15847: PUSH
15848: FOR_IN
15849: IFFALSE 17367
// begin points := [ 0 , 0 , 0 ] ;
15851: LD_ADDR_VAR 0 9
15855: PUSH
15856: LD_INT 0
15858: PUSH
15859: LD_INT 0
15861: PUSH
15862: LD_INT 0
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: LIST
15869: ST_TO_ADDR
// bpoints := 1 ;
15870: LD_ADDR_VAR 0 10
15874: PUSH
15875: LD_INT 1
15877: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15878: LD_VAR 0 6
15882: PPUSH
15883: CALL_OW 247
15887: PUSH
15888: LD_INT 1
15890: DOUBLE
15891: EQUAL
15892: IFTRUE 15896
15894: GO 16474
15896: POP
// begin if GetClass ( i ) = 1 then
15897: LD_VAR 0 6
15901: PPUSH
15902: CALL_OW 257
15906: PUSH
15907: LD_INT 1
15909: EQUAL
15910: IFFALSE 15931
// points := [ 10 , 5 , 3 ] ;
15912: LD_ADDR_VAR 0 9
15916: PUSH
15917: LD_INT 10
15919: PUSH
15920: LD_INT 5
15922: PUSH
15923: LD_INT 3
15925: PUSH
15926: EMPTY
15927: LIST
15928: LIST
15929: LIST
15930: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15931: LD_VAR 0 6
15935: PPUSH
15936: CALL_OW 257
15940: PUSH
15941: LD_INT 2
15943: PUSH
15944: LD_INT 3
15946: PUSH
15947: LD_INT 4
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: LIST
15954: IN
15955: IFFALSE 15976
// points := [ 3 , 2 , 1 ] ;
15957: LD_ADDR_VAR 0 9
15961: PUSH
15962: LD_INT 3
15964: PUSH
15965: LD_INT 2
15967: PUSH
15968: LD_INT 1
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: LIST
15975: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15976: LD_VAR 0 6
15980: PPUSH
15981: CALL_OW 257
15985: PUSH
15986: LD_INT 5
15988: EQUAL
15989: IFFALSE 16010
// points := [ 130 , 5 , 2 ] ;
15991: LD_ADDR_VAR 0 9
15995: PUSH
15996: LD_INT 130
15998: PUSH
15999: LD_INT 5
16001: PUSH
16002: LD_INT 2
16004: PUSH
16005: EMPTY
16006: LIST
16007: LIST
16008: LIST
16009: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16010: LD_VAR 0 6
16014: PPUSH
16015: CALL_OW 257
16019: PUSH
16020: LD_INT 8
16022: EQUAL
16023: IFFALSE 16044
// points := [ 35 , 35 , 30 ] ;
16025: LD_ADDR_VAR 0 9
16029: PUSH
16030: LD_INT 35
16032: PUSH
16033: LD_INT 35
16035: PUSH
16036: LD_INT 30
16038: PUSH
16039: EMPTY
16040: LIST
16041: LIST
16042: LIST
16043: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16044: LD_VAR 0 6
16048: PPUSH
16049: CALL_OW 257
16053: PUSH
16054: LD_INT 9
16056: EQUAL
16057: IFFALSE 16078
// points := [ 20 , 55 , 40 ] ;
16059: LD_ADDR_VAR 0 9
16063: PUSH
16064: LD_INT 20
16066: PUSH
16067: LD_INT 55
16069: PUSH
16070: LD_INT 40
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: LIST
16077: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16078: LD_VAR 0 6
16082: PPUSH
16083: CALL_OW 257
16087: PUSH
16088: LD_INT 12
16090: PUSH
16091: LD_INT 16
16093: PUSH
16094: EMPTY
16095: LIST
16096: LIST
16097: IN
16098: IFFALSE 16119
// points := [ 5 , 3 , 2 ] ;
16100: LD_ADDR_VAR 0 9
16104: PUSH
16105: LD_INT 5
16107: PUSH
16108: LD_INT 3
16110: PUSH
16111: LD_INT 2
16113: PUSH
16114: EMPTY
16115: LIST
16116: LIST
16117: LIST
16118: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16119: LD_VAR 0 6
16123: PPUSH
16124: CALL_OW 257
16128: PUSH
16129: LD_INT 17
16131: EQUAL
16132: IFFALSE 16153
// points := [ 100 , 50 , 75 ] ;
16134: LD_ADDR_VAR 0 9
16138: PUSH
16139: LD_INT 100
16141: PUSH
16142: LD_INT 50
16144: PUSH
16145: LD_INT 75
16147: PUSH
16148: EMPTY
16149: LIST
16150: LIST
16151: LIST
16152: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16153: LD_VAR 0 6
16157: PPUSH
16158: CALL_OW 257
16162: PUSH
16163: LD_INT 15
16165: EQUAL
16166: IFFALSE 16187
// points := [ 10 , 5 , 3 ] ;
16168: LD_ADDR_VAR 0 9
16172: PUSH
16173: LD_INT 10
16175: PUSH
16176: LD_INT 5
16178: PUSH
16179: LD_INT 3
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: LIST
16186: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16187: LD_VAR 0 6
16191: PPUSH
16192: CALL_OW 257
16196: PUSH
16197: LD_INT 14
16199: EQUAL
16200: IFFALSE 16221
// points := [ 10 , 0 , 0 ] ;
16202: LD_ADDR_VAR 0 9
16206: PUSH
16207: LD_INT 10
16209: PUSH
16210: LD_INT 0
16212: PUSH
16213: LD_INT 0
16215: PUSH
16216: EMPTY
16217: LIST
16218: LIST
16219: LIST
16220: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16221: LD_VAR 0 6
16225: PPUSH
16226: CALL_OW 257
16230: PUSH
16231: LD_INT 11
16233: EQUAL
16234: IFFALSE 16255
// points := [ 30 , 10 , 5 ] ;
16236: LD_ADDR_VAR 0 9
16240: PUSH
16241: LD_INT 30
16243: PUSH
16244: LD_INT 10
16246: PUSH
16247: LD_INT 5
16249: PUSH
16250: EMPTY
16251: LIST
16252: LIST
16253: LIST
16254: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16255: LD_VAR 0 1
16259: PPUSH
16260: LD_INT 5
16262: PPUSH
16263: CALL_OW 321
16267: PUSH
16268: LD_INT 2
16270: EQUAL
16271: IFFALSE 16288
// bpoints := bpoints * 1.8 ;
16273: LD_ADDR_VAR 0 10
16277: PUSH
16278: LD_VAR 0 10
16282: PUSH
16283: LD_REAL  1.80000000000000E+0000
16286: MUL
16287: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16288: LD_VAR 0 6
16292: PPUSH
16293: CALL_OW 257
16297: PUSH
16298: LD_INT 1
16300: PUSH
16301: LD_INT 2
16303: PUSH
16304: LD_INT 3
16306: PUSH
16307: LD_INT 4
16309: PUSH
16310: EMPTY
16311: LIST
16312: LIST
16313: LIST
16314: LIST
16315: IN
16316: PUSH
16317: LD_VAR 0 1
16321: PPUSH
16322: LD_INT 51
16324: PPUSH
16325: CALL_OW 321
16329: PUSH
16330: LD_INT 2
16332: EQUAL
16333: AND
16334: IFFALSE 16351
// bpoints := bpoints * 1.2 ;
16336: LD_ADDR_VAR 0 10
16340: PUSH
16341: LD_VAR 0 10
16345: PUSH
16346: LD_REAL  1.20000000000000E+0000
16349: MUL
16350: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16351: LD_VAR 0 6
16355: PPUSH
16356: CALL_OW 257
16360: PUSH
16361: LD_INT 5
16363: PUSH
16364: LD_INT 7
16366: PUSH
16367: LD_INT 9
16369: PUSH
16370: EMPTY
16371: LIST
16372: LIST
16373: LIST
16374: IN
16375: PUSH
16376: LD_VAR 0 1
16380: PPUSH
16381: LD_INT 52
16383: PPUSH
16384: CALL_OW 321
16388: PUSH
16389: LD_INT 2
16391: EQUAL
16392: AND
16393: IFFALSE 16410
// bpoints := bpoints * 1.5 ;
16395: LD_ADDR_VAR 0 10
16399: PUSH
16400: LD_VAR 0 10
16404: PUSH
16405: LD_REAL  1.50000000000000E+0000
16408: MUL
16409: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16410: LD_VAR 0 1
16414: PPUSH
16415: LD_INT 66
16417: PPUSH
16418: CALL_OW 321
16422: PUSH
16423: LD_INT 2
16425: EQUAL
16426: IFFALSE 16443
// bpoints := bpoints * 1.1 ;
16428: LD_ADDR_VAR 0 10
16432: PUSH
16433: LD_VAR 0 10
16437: PUSH
16438: LD_REAL  1.10000000000000E+0000
16441: MUL
16442: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16443: LD_ADDR_VAR 0 10
16447: PUSH
16448: LD_VAR 0 10
16452: PUSH
16453: LD_VAR 0 6
16457: PPUSH
16458: LD_INT 1
16460: PPUSH
16461: CALL_OW 259
16465: PUSH
16466: LD_REAL  1.15000000000000E+0000
16469: MUL
16470: MUL
16471: ST_TO_ADDR
// end ; unit_vehicle :
16472: GO 17296
16474: LD_INT 2
16476: DOUBLE
16477: EQUAL
16478: IFTRUE 16482
16480: GO 17284
16482: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16483: LD_VAR 0 6
16487: PPUSH
16488: CALL_OW 264
16492: PUSH
16493: LD_INT 2
16495: PUSH
16496: LD_INT 42
16498: PUSH
16499: LD_INT 24
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: LIST
16506: IN
16507: IFFALSE 16528
// points := [ 25 , 5 , 3 ] ;
16509: LD_ADDR_VAR 0 9
16513: PUSH
16514: LD_INT 25
16516: PUSH
16517: LD_INT 5
16519: PUSH
16520: LD_INT 3
16522: PUSH
16523: EMPTY
16524: LIST
16525: LIST
16526: LIST
16527: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16528: LD_VAR 0 6
16532: PPUSH
16533: CALL_OW 264
16537: PUSH
16538: LD_INT 4
16540: PUSH
16541: LD_INT 43
16543: PUSH
16544: LD_INT 25
16546: PUSH
16547: EMPTY
16548: LIST
16549: LIST
16550: LIST
16551: IN
16552: IFFALSE 16573
// points := [ 40 , 15 , 5 ] ;
16554: LD_ADDR_VAR 0 9
16558: PUSH
16559: LD_INT 40
16561: PUSH
16562: LD_INT 15
16564: PUSH
16565: LD_INT 5
16567: PUSH
16568: EMPTY
16569: LIST
16570: LIST
16571: LIST
16572: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16573: LD_VAR 0 6
16577: PPUSH
16578: CALL_OW 264
16582: PUSH
16583: LD_INT 3
16585: PUSH
16586: LD_INT 23
16588: PUSH
16589: EMPTY
16590: LIST
16591: LIST
16592: IN
16593: IFFALSE 16614
// points := [ 7 , 25 , 8 ] ;
16595: LD_ADDR_VAR 0 9
16599: PUSH
16600: LD_INT 7
16602: PUSH
16603: LD_INT 25
16605: PUSH
16606: LD_INT 8
16608: PUSH
16609: EMPTY
16610: LIST
16611: LIST
16612: LIST
16613: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16614: LD_VAR 0 6
16618: PPUSH
16619: CALL_OW 264
16623: PUSH
16624: LD_INT 5
16626: PUSH
16627: LD_INT 27
16629: PUSH
16630: LD_INT 44
16632: PUSH
16633: EMPTY
16634: LIST
16635: LIST
16636: LIST
16637: IN
16638: IFFALSE 16659
// points := [ 14 , 50 , 16 ] ;
16640: LD_ADDR_VAR 0 9
16644: PUSH
16645: LD_INT 14
16647: PUSH
16648: LD_INT 50
16650: PUSH
16651: LD_INT 16
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: LIST
16658: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16659: LD_VAR 0 6
16663: PPUSH
16664: CALL_OW 264
16668: PUSH
16669: LD_INT 6
16671: PUSH
16672: LD_INT 46
16674: PUSH
16675: EMPTY
16676: LIST
16677: LIST
16678: IN
16679: IFFALSE 16700
// points := [ 32 , 120 , 70 ] ;
16681: LD_ADDR_VAR 0 9
16685: PUSH
16686: LD_INT 32
16688: PUSH
16689: LD_INT 120
16691: PUSH
16692: LD_INT 70
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: LIST
16699: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
16700: LD_VAR 0 6
16704: PPUSH
16705: CALL_OW 264
16709: PUSH
16710: LD_INT 7
16712: PUSH
16713: LD_INT 28
16715: PUSH
16716: LD_INT 45
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: LIST
16723: IN
16724: IFFALSE 16745
// points := [ 35 , 20 , 45 ] ;
16726: LD_ADDR_VAR 0 9
16730: PUSH
16731: LD_INT 35
16733: PUSH
16734: LD_INT 20
16736: PUSH
16737: LD_INT 45
16739: PUSH
16740: EMPTY
16741: LIST
16742: LIST
16743: LIST
16744: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16745: LD_VAR 0 6
16749: PPUSH
16750: CALL_OW 264
16754: PUSH
16755: LD_INT 47
16757: PUSH
16758: EMPTY
16759: LIST
16760: IN
16761: IFFALSE 16782
// points := [ 67 , 45 , 75 ] ;
16763: LD_ADDR_VAR 0 9
16767: PUSH
16768: LD_INT 67
16770: PUSH
16771: LD_INT 45
16773: PUSH
16774: LD_INT 75
16776: PUSH
16777: EMPTY
16778: LIST
16779: LIST
16780: LIST
16781: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16782: LD_VAR 0 6
16786: PPUSH
16787: CALL_OW 264
16791: PUSH
16792: LD_INT 26
16794: PUSH
16795: EMPTY
16796: LIST
16797: IN
16798: IFFALSE 16819
// points := [ 120 , 30 , 80 ] ;
16800: LD_ADDR_VAR 0 9
16804: PUSH
16805: LD_INT 120
16807: PUSH
16808: LD_INT 30
16810: PUSH
16811: LD_INT 80
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: LIST
16818: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16819: LD_VAR 0 6
16823: PPUSH
16824: CALL_OW 264
16828: PUSH
16829: LD_INT 22
16831: PUSH
16832: EMPTY
16833: LIST
16834: IN
16835: IFFALSE 16856
// points := [ 40 , 1 , 1 ] ;
16837: LD_ADDR_VAR 0 9
16841: PUSH
16842: LD_INT 40
16844: PUSH
16845: LD_INT 1
16847: PUSH
16848: LD_INT 1
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: LIST
16855: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16856: LD_VAR 0 6
16860: PPUSH
16861: CALL_OW 264
16865: PUSH
16866: LD_INT 29
16868: PUSH
16869: EMPTY
16870: LIST
16871: IN
16872: IFFALSE 16893
// points := [ 70 , 200 , 400 ] ;
16874: LD_ADDR_VAR 0 9
16878: PUSH
16879: LD_INT 70
16881: PUSH
16882: LD_INT 200
16884: PUSH
16885: LD_INT 400
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: LIST
16892: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16893: LD_VAR 0 6
16897: PPUSH
16898: CALL_OW 264
16902: PUSH
16903: LD_INT 14
16905: PUSH
16906: LD_INT 53
16908: PUSH
16909: EMPTY
16910: LIST
16911: LIST
16912: IN
16913: IFFALSE 16934
// points := [ 40 , 10 , 20 ] ;
16915: LD_ADDR_VAR 0 9
16919: PUSH
16920: LD_INT 40
16922: PUSH
16923: LD_INT 10
16925: PUSH
16926: LD_INT 20
16928: PUSH
16929: EMPTY
16930: LIST
16931: LIST
16932: LIST
16933: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16934: LD_VAR 0 6
16938: PPUSH
16939: CALL_OW 264
16943: PUSH
16944: LD_INT 9
16946: PUSH
16947: EMPTY
16948: LIST
16949: IN
16950: IFFALSE 16971
// points := [ 5 , 70 , 20 ] ;
16952: LD_ADDR_VAR 0 9
16956: PUSH
16957: LD_INT 5
16959: PUSH
16960: LD_INT 70
16962: PUSH
16963: LD_INT 20
16965: PUSH
16966: EMPTY
16967: LIST
16968: LIST
16969: LIST
16970: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16971: LD_VAR 0 6
16975: PPUSH
16976: CALL_OW 264
16980: PUSH
16981: LD_INT 10
16983: PUSH
16984: EMPTY
16985: LIST
16986: IN
16987: IFFALSE 17008
// points := [ 35 , 110 , 70 ] ;
16989: LD_ADDR_VAR 0 9
16993: PUSH
16994: LD_INT 35
16996: PUSH
16997: LD_INT 110
16999: PUSH
17000: LD_INT 70
17002: PUSH
17003: EMPTY
17004: LIST
17005: LIST
17006: LIST
17007: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17008: LD_VAR 0 6
17012: PPUSH
17013: CALL_OW 265
17017: PUSH
17018: LD_INT 25
17020: EQUAL
17021: IFFALSE 17042
// points := [ 80 , 65 , 100 ] ;
17023: LD_ADDR_VAR 0 9
17027: PUSH
17028: LD_INT 80
17030: PUSH
17031: LD_INT 65
17033: PUSH
17034: LD_INT 100
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: LIST
17041: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17042: LD_VAR 0 6
17046: PPUSH
17047: CALL_OW 263
17051: PUSH
17052: LD_INT 1
17054: EQUAL
17055: IFFALSE 17090
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17057: LD_ADDR_VAR 0 10
17061: PUSH
17062: LD_VAR 0 10
17066: PUSH
17067: LD_VAR 0 6
17071: PPUSH
17072: CALL_OW 311
17076: PPUSH
17077: LD_INT 3
17079: PPUSH
17080: CALL_OW 259
17084: PUSH
17085: LD_INT 4
17087: MUL
17088: MUL
17089: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17090: LD_VAR 0 6
17094: PPUSH
17095: CALL_OW 263
17099: PUSH
17100: LD_INT 2
17102: EQUAL
17103: IFFALSE 17154
// begin j := IsControledBy ( i ) ;
17105: LD_ADDR_VAR 0 7
17109: PUSH
17110: LD_VAR 0 6
17114: PPUSH
17115: CALL_OW 312
17119: ST_TO_ADDR
// if j then
17120: LD_VAR 0 7
17124: IFFALSE 17154
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17126: LD_ADDR_VAR 0 10
17130: PUSH
17131: LD_VAR 0 10
17135: PUSH
17136: LD_VAR 0 7
17140: PPUSH
17141: LD_INT 3
17143: PPUSH
17144: CALL_OW 259
17148: PUSH
17149: LD_INT 3
17151: MUL
17152: MUL
17153: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17154: LD_VAR 0 6
17158: PPUSH
17159: CALL_OW 264
17163: PUSH
17164: LD_INT 5
17166: PUSH
17167: LD_INT 6
17169: PUSH
17170: LD_INT 46
17172: PUSH
17173: LD_INT 44
17175: PUSH
17176: LD_INT 47
17178: PUSH
17179: LD_INT 45
17181: PUSH
17182: LD_INT 28
17184: PUSH
17185: LD_INT 7
17187: PUSH
17188: LD_INT 27
17190: PUSH
17191: LD_INT 29
17193: PUSH
17194: EMPTY
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: IN
17206: PUSH
17207: LD_VAR 0 1
17211: PPUSH
17212: LD_INT 52
17214: PPUSH
17215: CALL_OW 321
17219: PUSH
17220: LD_INT 2
17222: EQUAL
17223: AND
17224: IFFALSE 17241
// bpoints := bpoints * 1.2 ;
17226: LD_ADDR_VAR 0 10
17230: PUSH
17231: LD_VAR 0 10
17235: PUSH
17236: LD_REAL  1.20000000000000E+0000
17239: MUL
17240: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17241: LD_VAR 0 6
17245: PPUSH
17246: CALL_OW 264
17250: PUSH
17251: LD_INT 6
17253: PUSH
17254: LD_INT 46
17256: PUSH
17257: LD_INT 47
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: LIST
17264: IN
17265: IFFALSE 17282
// bpoints := bpoints * 1.2 ;
17267: LD_ADDR_VAR 0 10
17271: PUSH
17272: LD_VAR 0 10
17276: PUSH
17277: LD_REAL  1.20000000000000E+0000
17280: MUL
17281: ST_TO_ADDR
// end ; unit_building :
17282: GO 17296
17284: LD_INT 3
17286: DOUBLE
17287: EQUAL
17288: IFTRUE 17292
17290: GO 17295
17292: POP
// ; end ;
17293: GO 17296
17295: POP
// for j = 1 to 3 do
17296: LD_ADDR_VAR 0 7
17300: PUSH
17301: DOUBLE
17302: LD_INT 1
17304: DEC
17305: ST_TO_ADDR
17306: LD_INT 3
17308: PUSH
17309: FOR_TO
17310: IFFALSE 17363
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17312: LD_ADDR_VAR 0 5
17316: PUSH
17317: LD_VAR 0 5
17321: PPUSH
17322: LD_VAR 0 7
17326: PPUSH
17327: LD_VAR 0 5
17331: PUSH
17332: LD_VAR 0 7
17336: ARRAY
17337: PUSH
17338: LD_VAR 0 9
17342: PUSH
17343: LD_VAR 0 7
17347: ARRAY
17348: PUSH
17349: LD_VAR 0 10
17353: MUL
17354: PLUS
17355: PPUSH
17356: CALL_OW 1
17360: ST_TO_ADDR
17361: GO 17309
17363: POP
17364: POP
// end ;
17365: GO 15848
17367: POP
17368: POP
// result := Replace ( result , 4 , tmp ) ;
17369: LD_ADDR_VAR 0 5
17373: PUSH
17374: LD_VAR 0 5
17378: PPUSH
17379: LD_INT 4
17381: PPUSH
17382: LD_VAR 0 8
17386: PPUSH
17387: CALL_OW 1
17391: ST_TO_ADDR
// end ;
17392: LD_VAR 0 5
17396: RET
// export function DangerAtRange ( unit , range ) ; begin
17397: LD_INT 0
17399: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17400: LD_ADDR_VAR 0 3
17404: PUSH
17405: LD_VAR 0 1
17409: PPUSH
17410: CALL_OW 255
17414: PPUSH
17415: LD_VAR 0 1
17419: PPUSH
17420: CALL_OW 250
17424: PPUSH
17425: LD_VAR 0 1
17429: PPUSH
17430: CALL_OW 251
17434: PPUSH
17435: LD_VAR 0 2
17439: PPUSH
17440: CALL 15700 0 4
17444: ST_TO_ADDR
// end ;
17445: LD_VAR 0 3
17449: RET
// export function DangerInArea ( side , area ) ; begin
17450: LD_INT 0
17452: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17453: LD_ADDR_VAR 0 3
17457: PUSH
17458: LD_VAR 0 2
17462: PPUSH
17463: LD_INT 81
17465: PUSH
17466: LD_VAR 0 1
17470: PUSH
17471: EMPTY
17472: LIST
17473: LIST
17474: PPUSH
17475: CALL_OW 70
17479: ST_TO_ADDR
// end ;
17480: LD_VAR 0 3
17484: RET
// export function IsExtension ( b ) ; begin
17485: LD_INT 0
17487: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17488: LD_ADDR_VAR 0 2
17492: PUSH
17493: LD_VAR 0 1
17497: PUSH
17498: LD_INT 23
17500: PUSH
17501: LD_INT 20
17503: PUSH
17504: LD_INT 22
17506: PUSH
17507: LD_INT 17
17509: PUSH
17510: LD_INT 24
17512: PUSH
17513: LD_INT 21
17515: PUSH
17516: LD_INT 19
17518: PUSH
17519: LD_INT 16
17521: PUSH
17522: LD_INT 25
17524: PUSH
17525: LD_INT 18
17527: PUSH
17528: EMPTY
17529: LIST
17530: LIST
17531: LIST
17532: LIST
17533: LIST
17534: LIST
17535: LIST
17536: LIST
17537: LIST
17538: LIST
17539: IN
17540: ST_TO_ADDR
// end ;
17541: LD_VAR 0 2
17545: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
17546: LD_INT 0
17548: PPUSH
17549: PPUSH
17550: PPUSH
// result := [ ] ;
17551: LD_ADDR_VAR 0 3
17555: PUSH
17556: EMPTY
17557: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17558: LD_ADDR_VAR 0 4
17562: PUSH
17563: LD_VAR 0 2
17567: PPUSH
17568: LD_INT 21
17570: PUSH
17571: LD_INT 3
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: PPUSH
17578: CALL_OW 70
17582: ST_TO_ADDR
// if not tmp then
17583: LD_VAR 0 4
17587: NOT
17588: IFFALSE 17592
// exit ;
17590: GO 17650
// for i in tmp do
17592: LD_ADDR_VAR 0 5
17596: PUSH
17597: LD_VAR 0 4
17601: PUSH
17602: FOR_IN
17603: IFFALSE 17638
// if GetBase ( i ) <> base then
17605: LD_VAR 0 5
17609: PPUSH
17610: CALL_OW 274
17614: PUSH
17615: LD_VAR 0 1
17619: NONEQUAL
17620: IFFALSE 17636
// ComLinkToBase ( base , i ) ;
17622: LD_VAR 0 1
17626: PPUSH
17627: LD_VAR 0 5
17631: PPUSH
17632: CALL_OW 169
17636: GO 17602
17638: POP
17639: POP
// result := tmp ;
17640: LD_ADDR_VAR 0 3
17644: PUSH
17645: LD_VAR 0 4
17649: ST_TO_ADDR
// end ;
17650: LD_VAR 0 3
17654: RET
// export function ComComplete ( unit , b ) ; var i ; begin
17655: LD_INT 0
17657: PPUSH
17658: PPUSH
// if BuildingStatus ( b ) = bs_build then
17659: LD_VAR 0 2
17663: PPUSH
17664: CALL_OW 461
17668: PUSH
17669: LD_INT 1
17671: EQUAL
17672: IFFALSE 17732
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17674: LD_VAR 0 1
17678: PPUSH
17679: LD_STRING h
17681: PUSH
17682: LD_VAR 0 2
17686: PPUSH
17687: CALL_OW 250
17691: PUSH
17692: LD_VAR 0 2
17696: PPUSH
17697: CALL_OW 251
17701: PUSH
17702: LD_VAR 0 2
17706: PUSH
17707: LD_INT 0
17709: PUSH
17710: LD_INT 0
17712: PUSH
17713: LD_INT 0
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: LIST
17720: LIST
17721: LIST
17722: LIST
17723: LIST
17724: PUSH
17725: EMPTY
17726: LIST
17727: PPUSH
17728: CALL_OW 446
// end ;
17732: LD_VAR 0 3
17736: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17737: LD_INT 0
17739: PPUSH
17740: PPUSH
17741: PPUSH
17742: PPUSH
17743: PPUSH
17744: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17745: LD_VAR 0 1
17749: NOT
17750: PUSH
17751: LD_VAR 0 1
17755: PPUSH
17756: CALL_OW 263
17760: PUSH
17761: LD_INT 2
17763: EQUAL
17764: NOT
17765: OR
17766: IFFALSE 17770
// exit ;
17768: GO 18086
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17770: LD_ADDR_VAR 0 6
17774: PUSH
17775: LD_INT 22
17777: PUSH
17778: LD_VAR 0 1
17782: PPUSH
17783: CALL_OW 255
17787: PUSH
17788: EMPTY
17789: LIST
17790: LIST
17791: PUSH
17792: LD_INT 2
17794: PUSH
17795: LD_INT 30
17797: PUSH
17798: LD_INT 36
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PUSH
17805: LD_INT 34
17807: PUSH
17808: LD_INT 31
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: PUSH
17815: EMPTY
17816: LIST
17817: LIST
17818: LIST
17819: PUSH
17820: EMPTY
17821: LIST
17822: LIST
17823: PPUSH
17824: CALL_OW 69
17828: ST_TO_ADDR
// if not tmp then
17829: LD_VAR 0 6
17833: NOT
17834: IFFALSE 17838
// exit ;
17836: GO 18086
// result := [ ] ;
17838: LD_ADDR_VAR 0 2
17842: PUSH
17843: EMPTY
17844: ST_TO_ADDR
// for i in tmp do
17845: LD_ADDR_VAR 0 3
17849: PUSH
17850: LD_VAR 0 6
17854: PUSH
17855: FOR_IN
17856: IFFALSE 17927
// begin t := UnitsInside ( i ) ;
17858: LD_ADDR_VAR 0 4
17862: PUSH
17863: LD_VAR 0 3
17867: PPUSH
17868: CALL_OW 313
17872: ST_TO_ADDR
// if t then
17873: LD_VAR 0 4
17877: IFFALSE 17925
// for j in t do
17879: LD_ADDR_VAR 0 7
17883: PUSH
17884: LD_VAR 0 4
17888: PUSH
17889: FOR_IN
17890: IFFALSE 17923
// result := Insert ( result , result + 1 , j ) ;
17892: LD_ADDR_VAR 0 2
17896: PUSH
17897: LD_VAR 0 2
17901: PPUSH
17902: LD_VAR 0 2
17906: PUSH
17907: LD_INT 1
17909: PLUS
17910: PPUSH
17911: LD_VAR 0 7
17915: PPUSH
17916: CALL_OW 2
17920: ST_TO_ADDR
17921: GO 17889
17923: POP
17924: POP
// end ;
17925: GO 17855
17927: POP
17928: POP
// if not result then
17929: LD_VAR 0 2
17933: NOT
17934: IFFALSE 17938
// exit ;
17936: GO 18086
// mech := result [ 1 ] ;
17938: LD_ADDR_VAR 0 5
17942: PUSH
17943: LD_VAR 0 2
17947: PUSH
17948: LD_INT 1
17950: ARRAY
17951: ST_TO_ADDR
// if result > 1 then
17952: LD_VAR 0 2
17956: PUSH
17957: LD_INT 1
17959: GREATER
17960: IFFALSE 18072
// for i = 2 to result do
17962: LD_ADDR_VAR 0 3
17966: PUSH
17967: DOUBLE
17968: LD_INT 2
17970: DEC
17971: ST_TO_ADDR
17972: LD_VAR 0 2
17976: PUSH
17977: FOR_TO
17978: IFFALSE 18070
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
17980: LD_ADDR_VAR 0 4
17984: PUSH
17985: LD_VAR 0 2
17989: PUSH
17990: LD_VAR 0 3
17994: ARRAY
17995: PPUSH
17996: LD_INT 3
17998: PPUSH
17999: CALL_OW 259
18003: PUSH
18004: LD_VAR 0 2
18008: PUSH
18009: LD_VAR 0 3
18013: ARRAY
18014: PPUSH
18015: CALL_OW 432
18019: MINUS
18020: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18021: LD_VAR 0 4
18025: PUSH
18026: LD_VAR 0 5
18030: PPUSH
18031: LD_INT 3
18033: PPUSH
18034: CALL_OW 259
18038: PUSH
18039: LD_VAR 0 5
18043: PPUSH
18044: CALL_OW 432
18048: MINUS
18049: GREATEREQUAL
18050: IFFALSE 18068
// mech := result [ i ] ;
18052: LD_ADDR_VAR 0 5
18056: PUSH
18057: LD_VAR 0 2
18061: PUSH
18062: LD_VAR 0 3
18066: ARRAY
18067: ST_TO_ADDR
// end ;
18068: GO 17977
18070: POP
18071: POP
// ComLinkTo ( vehicle , mech ) ;
18072: LD_VAR 0 1
18076: PPUSH
18077: LD_VAR 0 5
18081: PPUSH
18082: CALL_OW 135
// end ;
18086: LD_VAR 0 2
18090: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18091: LD_INT 0
18093: PPUSH
18094: PPUSH
18095: PPUSH
18096: PPUSH
18097: PPUSH
18098: PPUSH
18099: PPUSH
18100: PPUSH
18101: PPUSH
18102: PPUSH
18103: PPUSH
18104: PPUSH
18105: PPUSH
// result := [ ] ;
18106: LD_ADDR_VAR 0 7
18110: PUSH
18111: EMPTY
18112: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18113: LD_VAR 0 1
18117: PPUSH
18118: CALL_OW 266
18122: PUSH
18123: LD_INT 0
18125: PUSH
18126: LD_INT 1
18128: PUSH
18129: EMPTY
18130: LIST
18131: LIST
18132: IN
18133: NOT
18134: IFFALSE 18138
// exit ;
18136: GO 19769
// if name then
18138: LD_VAR 0 3
18142: IFFALSE 18158
// SetBName ( base_dep , name ) ;
18144: LD_VAR 0 1
18148: PPUSH
18149: LD_VAR 0 3
18153: PPUSH
18154: CALL_OW 500
// base := GetBase ( base_dep ) ;
18158: LD_ADDR_VAR 0 15
18162: PUSH
18163: LD_VAR 0 1
18167: PPUSH
18168: CALL_OW 274
18172: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18173: LD_ADDR_VAR 0 16
18177: PUSH
18178: LD_VAR 0 1
18182: PPUSH
18183: CALL_OW 255
18187: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18188: LD_ADDR_VAR 0 17
18192: PUSH
18193: LD_VAR 0 1
18197: PPUSH
18198: CALL_OW 248
18202: ST_TO_ADDR
// if sources then
18203: LD_VAR 0 5
18207: IFFALSE 18254
// for i = 1 to 3 do
18209: LD_ADDR_VAR 0 8
18213: PUSH
18214: DOUBLE
18215: LD_INT 1
18217: DEC
18218: ST_TO_ADDR
18219: LD_INT 3
18221: PUSH
18222: FOR_TO
18223: IFFALSE 18252
// AddResourceType ( base , i , sources [ i ] ) ;
18225: LD_VAR 0 15
18229: PPUSH
18230: LD_VAR 0 8
18234: PPUSH
18235: LD_VAR 0 5
18239: PUSH
18240: LD_VAR 0 8
18244: ARRAY
18245: PPUSH
18246: CALL_OW 276
18250: GO 18222
18252: POP
18253: POP
// buildings := GetBaseBuildings ( base , area ) ;
18254: LD_ADDR_VAR 0 18
18258: PUSH
18259: LD_VAR 0 15
18263: PPUSH
18264: LD_VAR 0 2
18268: PPUSH
18269: CALL 17546 0 2
18273: ST_TO_ADDR
// InitHc ;
18274: CALL_OW 19
// InitUc ;
18278: CALL_OW 18
// uc_side := side ;
18282: LD_ADDR_OWVAR 20
18286: PUSH
18287: LD_VAR 0 16
18291: ST_TO_ADDR
// uc_nation := nation ;
18292: LD_ADDR_OWVAR 21
18296: PUSH
18297: LD_VAR 0 17
18301: ST_TO_ADDR
// if buildings then
18302: LD_VAR 0 18
18306: IFFALSE 19628
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18308: LD_ADDR_VAR 0 19
18312: PUSH
18313: LD_VAR 0 18
18317: PPUSH
18318: LD_INT 2
18320: PUSH
18321: LD_INT 30
18323: PUSH
18324: LD_INT 29
18326: PUSH
18327: EMPTY
18328: LIST
18329: LIST
18330: PUSH
18331: LD_INT 30
18333: PUSH
18334: LD_INT 30
18336: PUSH
18337: EMPTY
18338: LIST
18339: LIST
18340: PUSH
18341: EMPTY
18342: LIST
18343: LIST
18344: LIST
18345: PPUSH
18346: CALL_OW 72
18350: ST_TO_ADDR
// if tmp then
18351: LD_VAR 0 19
18355: IFFALSE 18403
// for i in tmp do
18357: LD_ADDR_VAR 0 8
18361: PUSH
18362: LD_VAR 0 19
18366: PUSH
18367: FOR_IN
18368: IFFALSE 18401
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18370: LD_VAR 0 8
18374: PPUSH
18375: CALL_OW 250
18379: PPUSH
18380: LD_VAR 0 8
18384: PPUSH
18385: CALL_OW 251
18389: PPUSH
18390: LD_VAR 0 16
18394: PPUSH
18395: CALL_OW 441
18399: GO 18367
18401: POP
18402: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18403: LD_VAR 0 18
18407: PPUSH
18408: LD_INT 2
18410: PUSH
18411: LD_INT 30
18413: PUSH
18414: LD_INT 32
18416: PUSH
18417: EMPTY
18418: LIST
18419: LIST
18420: PUSH
18421: LD_INT 30
18423: PUSH
18424: LD_INT 33
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: LIST
18435: PPUSH
18436: CALL_OW 72
18440: IFFALSE 18528
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18442: LD_ADDR_VAR 0 8
18446: PUSH
18447: LD_VAR 0 18
18451: PPUSH
18452: LD_INT 2
18454: PUSH
18455: LD_INT 30
18457: PUSH
18458: LD_INT 32
18460: PUSH
18461: EMPTY
18462: LIST
18463: LIST
18464: PUSH
18465: LD_INT 30
18467: PUSH
18468: LD_INT 33
18470: PUSH
18471: EMPTY
18472: LIST
18473: LIST
18474: PUSH
18475: EMPTY
18476: LIST
18477: LIST
18478: LIST
18479: PPUSH
18480: CALL_OW 72
18484: PUSH
18485: FOR_IN
18486: IFFALSE 18526
// begin if not GetBWeapon ( i ) then
18488: LD_VAR 0 8
18492: PPUSH
18493: CALL_OW 269
18497: NOT
18498: IFFALSE 18524
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18500: LD_VAR 0 8
18504: PPUSH
18505: LD_VAR 0 8
18509: PPUSH
18510: LD_VAR 0 2
18514: PPUSH
18515: CALL 19774 0 2
18519: PPUSH
18520: CALL_OW 431
// end ;
18524: GO 18485
18526: POP
18527: POP
// end ; for i = 1 to personel do
18528: LD_ADDR_VAR 0 8
18532: PUSH
18533: DOUBLE
18534: LD_INT 1
18536: DEC
18537: ST_TO_ADDR
18538: LD_VAR 0 6
18542: PUSH
18543: FOR_TO
18544: IFFALSE 19608
// begin if i > 4 then
18546: LD_VAR 0 8
18550: PUSH
18551: LD_INT 4
18553: GREATER
18554: IFFALSE 18558
// break ;
18556: GO 19608
// case i of 1 :
18558: LD_VAR 0 8
18562: PUSH
18563: LD_INT 1
18565: DOUBLE
18566: EQUAL
18567: IFTRUE 18571
18569: GO 18651
18571: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18572: LD_ADDR_VAR 0 12
18576: PUSH
18577: LD_VAR 0 18
18581: PPUSH
18582: LD_INT 22
18584: PUSH
18585: LD_VAR 0 16
18589: PUSH
18590: EMPTY
18591: LIST
18592: LIST
18593: PUSH
18594: LD_INT 58
18596: PUSH
18597: EMPTY
18598: LIST
18599: PUSH
18600: LD_INT 2
18602: PUSH
18603: LD_INT 30
18605: PUSH
18606: LD_INT 32
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: LD_INT 30
18615: PUSH
18616: LD_INT 4
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: PUSH
18623: LD_INT 30
18625: PUSH
18626: LD_INT 5
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: LIST
18637: LIST
18638: PUSH
18639: EMPTY
18640: LIST
18641: LIST
18642: LIST
18643: PPUSH
18644: CALL_OW 72
18648: ST_TO_ADDR
18649: GO 18873
18651: LD_INT 2
18653: DOUBLE
18654: EQUAL
18655: IFTRUE 18659
18657: GO 18721
18659: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18660: LD_ADDR_VAR 0 12
18664: PUSH
18665: LD_VAR 0 18
18669: PPUSH
18670: LD_INT 22
18672: PUSH
18673: LD_VAR 0 16
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: PUSH
18682: LD_INT 2
18684: PUSH
18685: LD_INT 30
18687: PUSH
18688: LD_INT 0
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PUSH
18695: LD_INT 30
18697: PUSH
18698: LD_INT 1
18700: PUSH
18701: EMPTY
18702: LIST
18703: LIST
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: LIST
18709: PUSH
18710: EMPTY
18711: LIST
18712: LIST
18713: PPUSH
18714: CALL_OW 72
18718: ST_TO_ADDR
18719: GO 18873
18721: LD_INT 3
18723: DOUBLE
18724: EQUAL
18725: IFTRUE 18729
18727: GO 18791
18729: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18730: LD_ADDR_VAR 0 12
18734: PUSH
18735: LD_VAR 0 18
18739: PPUSH
18740: LD_INT 22
18742: PUSH
18743: LD_VAR 0 16
18747: PUSH
18748: EMPTY
18749: LIST
18750: LIST
18751: PUSH
18752: LD_INT 2
18754: PUSH
18755: LD_INT 30
18757: PUSH
18758: LD_INT 2
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: PUSH
18765: LD_INT 30
18767: PUSH
18768: LD_INT 3
18770: PUSH
18771: EMPTY
18772: LIST
18773: LIST
18774: PUSH
18775: EMPTY
18776: LIST
18777: LIST
18778: LIST
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: PPUSH
18784: CALL_OW 72
18788: ST_TO_ADDR
18789: GO 18873
18791: LD_INT 4
18793: DOUBLE
18794: EQUAL
18795: IFTRUE 18799
18797: GO 18872
18799: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18800: LD_ADDR_VAR 0 12
18804: PUSH
18805: LD_VAR 0 18
18809: PPUSH
18810: LD_INT 22
18812: PUSH
18813: LD_VAR 0 16
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: PUSH
18822: LD_INT 2
18824: PUSH
18825: LD_INT 30
18827: PUSH
18828: LD_INT 6
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: PUSH
18835: LD_INT 30
18837: PUSH
18838: LD_INT 7
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 30
18847: PUSH
18848: LD_INT 8
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: LIST
18859: LIST
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: PPUSH
18865: CALL_OW 72
18869: ST_TO_ADDR
18870: GO 18873
18872: POP
// if i = 1 then
18873: LD_VAR 0 8
18877: PUSH
18878: LD_INT 1
18880: EQUAL
18881: IFFALSE 18992
// begin tmp := [ ] ;
18883: LD_ADDR_VAR 0 19
18887: PUSH
18888: EMPTY
18889: ST_TO_ADDR
// for j in f do
18890: LD_ADDR_VAR 0 9
18894: PUSH
18895: LD_VAR 0 12
18899: PUSH
18900: FOR_IN
18901: IFFALSE 18974
// if GetBType ( j ) = b_bunker then
18903: LD_VAR 0 9
18907: PPUSH
18908: CALL_OW 266
18912: PUSH
18913: LD_INT 32
18915: EQUAL
18916: IFFALSE 18943
// tmp := Insert ( tmp , 1 , j ) else
18918: LD_ADDR_VAR 0 19
18922: PUSH
18923: LD_VAR 0 19
18927: PPUSH
18928: LD_INT 1
18930: PPUSH
18931: LD_VAR 0 9
18935: PPUSH
18936: CALL_OW 2
18940: ST_TO_ADDR
18941: GO 18972
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18943: LD_ADDR_VAR 0 19
18947: PUSH
18948: LD_VAR 0 19
18952: PPUSH
18953: LD_VAR 0 19
18957: PUSH
18958: LD_INT 1
18960: PLUS
18961: PPUSH
18962: LD_VAR 0 9
18966: PPUSH
18967: CALL_OW 2
18971: ST_TO_ADDR
18972: GO 18900
18974: POP
18975: POP
// if tmp then
18976: LD_VAR 0 19
18980: IFFALSE 18992
// f := tmp ;
18982: LD_ADDR_VAR 0 12
18986: PUSH
18987: LD_VAR 0 19
18991: ST_TO_ADDR
// end ; x := personel [ i ] ;
18992: LD_ADDR_VAR 0 13
18996: PUSH
18997: LD_VAR 0 6
19001: PUSH
19002: LD_VAR 0 8
19006: ARRAY
19007: ST_TO_ADDR
// if x = - 1 then
19008: LD_VAR 0 13
19012: PUSH
19013: LD_INT 1
19015: NEG
19016: EQUAL
19017: IFFALSE 19226
// begin for j in f do
19019: LD_ADDR_VAR 0 9
19023: PUSH
19024: LD_VAR 0 12
19028: PUSH
19029: FOR_IN
19030: IFFALSE 19222
// repeat InitHc ;
19032: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19036: LD_VAR 0 9
19040: PPUSH
19041: CALL_OW 266
19045: PUSH
19046: LD_INT 5
19048: EQUAL
19049: IFFALSE 19119
// begin if UnitsInside ( j ) < 3 then
19051: LD_VAR 0 9
19055: PPUSH
19056: CALL_OW 313
19060: PUSH
19061: LD_INT 3
19063: LESS
19064: IFFALSE 19100
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19066: LD_INT 0
19068: PPUSH
19069: LD_INT 5
19071: PUSH
19072: LD_INT 8
19074: PUSH
19075: LD_INT 9
19077: PUSH
19078: EMPTY
19079: LIST
19080: LIST
19081: LIST
19082: PUSH
19083: LD_VAR 0 17
19087: ARRAY
19088: PPUSH
19089: LD_VAR 0 4
19093: PPUSH
19094: CALL_OW 380
19098: GO 19117
// PrepareHuman ( false , i , skill ) ;
19100: LD_INT 0
19102: PPUSH
19103: LD_VAR 0 8
19107: PPUSH
19108: LD_VAR 0 4
19112: PPUSH
19113: CALL_OW 380
// end else
19117: GO 19136
// PrepareHuman ( false , i , skill ) ;
19119: LD_INT 0
19121: PPUSH
19122: LD_VAR 0 8
19126: PPUSH
19127: LD_VAR 0 4
19131: PPUSH
19132: CALL_OW 380
// un := CreateHuman ;
19136: LD_ADDR_VAR 0 14
19140: PUSH
19141: CALL_OW 44
19145: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19146: LD_ADDR_VAR 0 7
19150: PUSH
19151: LD_VAR 0 7
19155: PPUSH
19156: LD_INT 1
19158: PPUSH
19159: LD_VAR 0 14
19163: PPUSH
19164: CALL_OW 2
19168: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19169: LD_VAR 0 14
19173: PPUSH
19174: LD_VAR 0 9
19178: PPUSH
19179: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19183: LD_VAR 0 9
19187: PPUSH
19188: CALL_OW 313
19192: PUSH
19193: LD_INT 6
19195: EQUAL
19196: PUSH
19197: LD_VAR 0 9
19201: PPUSH
19202: CALL_OW 266
19206: PUSH
19207: LD_INT 32
19209: PUSH
19210: LD_INT 31
19212: PUSH
19213: EMPTY
19214: LIST
19215: LIST
19216: IN
19217: OR
19218: IFFALSE 19032
19220: GO 19029
19222: POP
19223: POP
// end else
19224: GO 19606
// for j = 1 to x do
19226: LD_ADDR_VAR 0 9
19230: PUSH
19231: DOUBLE
19232: LD_INT 1
19234: DEC
19235: ST_TO_ADDR
19236: LD_VAR 0 13
19240: PUSH
19241: FOR_TO
19242: IFFALSE 19604
// begin InitHc ;
19244: CALL_OW 19
// if not f then
19248: LD_VAR 0 12
19252: NOT
19253: IFFALSE 19342
// begin PrepareHuman ( false , i , skill ) ;
19255: LD_INT 0
19257: PPUSH
19258: LD_VAR 0 8
19262: PPUSH
19263: LD_VAR 0 4
19267: PPUSH
19268: CALL_OW 380
// un := CreateHuman ;
19272: LD_ADDR_VAR 0 14
19276: PUSH
19277: CALL_OW 44
19281: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19282: LD_ADDR_VAR 0 7
19286: PUSH
19287: LD_VAR 0 7
19291: PPUSH
19292: LD_INT 1
19294: PPUSH
19295: LD_VAR 0 14
19299: PPUSH
19300: CALL_OW 2
19304: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19305: LD_VAR 0 14
19309: PPUSH
19310: LD_VAR 0 1
19314: PPUSH
19315: CALL_OW 250
19319: PPUSH
19320: LD_VAR 0 1
19324: PPUSH
19325: CALL_OW 251
19329: PPUSH
19330: LD_INT 10
19332: PPUSH
19333: LD_INT 0
19335: PPUSH
19336: CALL_OW 50
// continue ;
19340: GO 19241
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19342: LD_VAR 0 12
19346: PUSH
19347: LD_INT 1
19349: ARRAY
19350: PPUSH
19351: CALL_OW 313
19355: PUSH
19356: LD_VAR 0 12
19360: PUSH
19361: LD_INT 1
19363: ARRAY
19364: PPUSH
19365: CALL_OW 266
19369: PUSH
19370: LD_INT 32
19372: PUSH
19373: LD_INT 31
19375: PUSH
19376: EMPTY
19377: LIST
19378: LIST
19379: IN
19380: AND
19381: PUSH
19382: LD_VAR 0 12
19386: PUSH
19387: LD_INT 1
19389: ARRAY
19390: PPUSH
19391: CALL_OW 313
19395: PUSH
19396: LD_INT 6
19398: EQUAL
19399: OR
19400: IFFALSE 19420
// f := Delete ( f , 1 ) ;
19402: LD_ADDR_VAR 0 12
19406: PUSH
19407: LD_VAR 0 12
19411: PPUSH
19412: LD_INT 1
19414: PPUSH
19415: CALL_OW 3
19419: ST_TO_ADDR
// if not f then
19420: LD_VAR 0 12
19424: NOT
19425: IFFALSE 19443
// begin x := x + 2 ;
19427: LD_ADDR_VAR 0 13
19431: PUSH
19432: LD_VAR 0 13
19436: PUSH
19437: LD_INT 2
19439: PLUS
19440: ST_TO_ADDR
// continue ;
19441: GO 19241
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19443: LD_VAR 0 12
19447: PUSH
19448: LD_INT 1
19450: ARRAY
19451: PPUSH
19452: CALL_OW 266
19456: PUSH
19457: LD_INT 5
19459: EQUAL
19460: IFFALSE 19534
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19462: LD_VAR 0 12
19466: PUSH
19467: LD_INT 1
19469: ARRAY
19470: PPUSH
19471: CALL_OW 313
19475: PUSH
19476: LD_INT 3
19478: LESS
19479: IFFALSE 19515
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19481: LD_INT 0
19483: PPUSH
19484: LD_INT 5
19486: PUSH
19487: LD_INT 8
19489: PUSH
19490: LD_INT 9
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: LIST
19497: PUSH
19498: LD_VAR 0 17
19502: ARRAY
19503: PPUSH
19504: LD_VAR 0 4
19508: PPUSH
19509: CALL_OW 380
19513: GO 19532
// PrepareHuman ( false , i , skill ) ;
19515: LD_INT 0
19517: PPUSH
19518: LD_VAR 0 8
19522: PPUSH
19523: LD_VAR 0 4
19527: PPUSH
19528: CALL_OW 380
// end else
19532: GO 19551
// PrepareHuman ( false , i , skill ) ;
19534: LD_INT 0
19536: PPUSH
19537: LD_VAR 0 8
19541: PPUSH
19542: LD_VAR 0 4
19546: PPUSH
19547: CALL_OW 380
// un := CreateHuman ;
19551: LD_ADDR_VAR 0 14
19555: PUSH
19556: CALL_OW 44
19560: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19561: LD_ADDR_VAR 0 7
19565: PUSH
19566: LD_VAR 0 7
19570: PPUSH
19571: LD_INT 1
19573: PPUSH
19574: LD_VAR 0 14
19578: PPUSH
19579: CALL_OW 2
19583: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19584: LD_VAR 0 14
19588: PPUSH
19589: LD_VAR 0 12
19593: PUSH
19594: LD_INT 1
19596: ARRAY
19597: PPUSH
19598: CALL_OW 52
// end ;
19602: GO 19241
19604: POP
19605: POP
// end ;
19606: GO 18543
19608: POP
19609: POP
// result := result ^ buildings ;
19610: LD_ADDR_VAR 0 7
19614: PUSH
19615: LD_VAR 0 7
19619: PUSH
19620: LD_VAR 0 18
19624: ADD
19625: ST_TO_ADDR
// end else
19626: GO 19769
// begin for i = 1 to personel do
19628: LD_ADDR_VAR 0 8
19632: PUSH
19633: DOUBLE
19634: LD_INT 1
19636: DEC
19637: ST_TO_ADDR
19638: LD_VAR 0 6
19642: PUSH
19643: FOR_TO
19644: IFFALSE 19767
// begin if i > 4 then
19646: LD_VAR 0 8
19650: PUSH
19651: LD_INT 4
19653: GREATER
19654: IFFALSE 19658
// break ;
19656: GO 19767
// x := personel [ i ] ;
19658: LD_ADDR_VAR 0 13
19662: PUSH
19663: LD_VAR 0 6
19667: PUSH
19668: LD_VAR 0 8
19672: ARRAY
19673: ST_TO_ADDR
// if x = - 1 then
19674: LD_VAR 0 13
19678: PUSH
19679: LD_INT 1
19681: NEG
19682: EQUAL
19683: IFFALSE 19687
// continue ;
19685: GO 19643
// PrepareHuman ( false , i , skill ) ;
19687: LD_INT 0
19689: PPUSH
19690: LD_VAR 0 8
19694: PPUSH
19695: LD_VAR 0 4
19699: PPUSH
19700: CALL_OW 380
// un := CreateHuman ;
19704: LD_ADDR_VAR 0 14
19708: PUSH
19709: CALL_OW 44
19713: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19714: LD_VAR 0 14
19718: PPUSH
19719: LD_VAR 0 1
19723: PPUSH
19724: CALL_OW 250
19728: PPUSH
19729: LD_VAR 0 1
19733: PPUSH
19734: CALL_OW 251
19738: PPUSH
19739: LD_INT 10
19741: PPUSH
19742: LD_INT 0
19744: PPUSH
19745: CALL_OW 50
// result := result ^ un ;
19749: LD_ADDR_VAR 0 7
19753: PUSH
19754: LD_VAR 0 7
19758: PUSH
19759: LD_VAR 0 14
19763: ADD
19764: ST_TO_ADDR
// end ;
19765: GO 19643
19767: POP
19768: POP
// end ; end ;
19769: LD_VAR 0 7
19773: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19774: LD_INT 0
19776: PPUSH
19777: PPUSH
19778: PPUSH
19779: PPUSH
19780: PPUSH
19781: PPUSH
19782: PPUSH
19783: PPUSH
19784: PPUSH
19785: PPUSH
19786: PPUSH
19787: PPUSH
19788: PPUSH
19789: PPUSH
19790: PPUSH
19791: PPUSH
// result := false ;
19792: LD_ADDR_VAR 0 3
19796: PUSH
19797: LD_INT 0
19799: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19800: LD_VAR 0 1
19804: NOT
19805: PUSH
19806: LD_VAR 0 1
19810: PPUSH
19811: CALL_OW 266
19815: PUSH
19816: LD_INT 32
19818: PUSH
19819: LD_INT 33
19821: PUSH
19822: EMPTY
19823: LIST
19824: LIST
19825: IN
19826: NOT
19827: OR
19828: IFFALSE 19832
// exit ;
19830: GO 20968
// nat := GetNation ( tower ) ;
19832: LD_ADDR_VAR 0 12
19836: PUSH
19837: LD_VAR 0 1
19841: PPUSH
19842: CALL_OW 248
19846: ST_TO_ADDR
// side := GetSide ( tower ) ;
19847: LD_ADDR_VAR 0 16
19851: PUSH
19852: LD_VAR 0 1
19856: PPUSH
19857: CALL_OW 255
19861: ST_TO_ADDR
// x := GetX ( tower ) ;
19862: LD_ADDR_VAR 0 10
19866: PUSH
19867: LD_VAR 0 1
19871: PPUSH
19872: CALL_OW 250
19876: ST_TO_ADDR
// y := GetY ( tower ) ;
19877: LD_ADDR_VAR 0 11
19881: PUSH
19882: LD_VAR 0 1
19886: PPUSH
19887: CALL_OW 251
19891: ST_TO_ADDR
// if not x or not y then
19892: LD_VAR 0 10
19896: NOT
19897: PUSH
19898: LD_VAR 0 11
19902: NOT
19903: OR
19904: IFFALSE 19908
// exit ;
19906: GO 20968
// weapon := 0 ;
19908: LD_ADDR_VAR 0 18
19912: PUSH
19913: LD_INT 0
19915: ST_TO_ADDR
// fac_list := [ ] ;
19916: LD_ADDR_VAR 0 17
19920: PUSH
19921: EMPTY
19922: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
19923: LD_ADDR_VAR 0 6
19927: PUSH
19928: LD_VAR 0 1
19932: PPUSH
19933: CALL_OW 274
19937: PPUSH
19938: LD_VAR 0 2
19942: PPUSH
19943: CALL 17546 0 2
19947: PPUSH
19948: LD_INT 30
19950: PUSH
19951: LD_INT 3
19953: PUSH
19954: EMPTY
19955: LIST
19956: LIST
19957: PPUSH
19958: CALL_OW 72
19962: ST_TO_ADDR
// if not factories then
19963: LD_VAR 0 6
19967: NOT
19968: IFFALSE 19972
// exit ;
19970: GO 20968
// for i in factories do
19972: LD_ADDR_VAR 0 8
19976: PUSH
19977: LD_VAR 0 6
19981: PUSH
19982: FOR_IN
19983: IFFALSE 20008
// fac_list := fac_list union AvailableWeaponList ( i ) ;
19985: LD_ADDR_VAR 0 17
19989: PUSH
19990: LD_VAR 0 17
19994: PUSH
19995: LD_VAR 0 8
19999: PPUSH
20000: CALL_OW 478
20004: UNION
20005: ST_TO_ADDR
20006: GO 19982
20008: POP
20009: POP
// if not fac_list then
20010: LD_VAR 0 17
20014: NOT
20015: IFFALSE 20019
// exit ;
20017: GO 20968
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20019: LD_ADDR_VAR 0 5
20023: PUSH
20024: LD_INT 4
20026: PUSH
20027: LD_INT 5
20029: PUSH
20030: LD_INT 9
20032: PUSH
20033: LD_INT 10
20035: PUSH
20036: LD_INT 6
20038: PUSH
20039: LD_INT 7
20041: PUSH
20042: LD_INT 11
20044: PUSH
20045: EMPTY
20046: LIST
20047: LIST
20048: LIST
20049: LIST
20050: LIST
20051: LIST
20052: LIST
20053: PUSH
20054: LD_INT 27
20056: PUSH
20057: LD_INT 28
20059: PUSH
20060: LD_INT 26
20062: PUSH
20063: LD_INT 30
20065: PUSH
20066: EMPTY
20067: LIST
20068: LIST
20069: LIST
20070: LIST
20071: PUSH
20072: LD_INT 43
20074: PUSH
20075: LD_INT 44
20077: PUSH
20078: LD_INT 46
20080: PUSH
20081: LD_INT 45
20083: PUSH
20084: LD_INT 47
20086: PUSH
20087: LD_INT 49
20089: PUSH
20090: EMPTY
20091: LIST
20092: LIST
20093: LIST
20094: LIST
20095: LIST
20096: LIST
20097: PUSH
20098: EMPTY
20099: LIST
20100: LIST
20101: LIST
20102: PUSH
20103: LD_VAR 0 12
20107: ARRAY
20108: ST_TO_ADDR
// for i in list do
20109: LD_ADDR_VAR 0 8
20113: PUSH
20114: LD_VAR 0 5
20118: PUSH
20119: FOR_IN
20120: IFFALSE 20153
// if not i in fac_list then
20122: LD_VAR 0 8
20126: PUSH
20127: LD_VAR 0 17
20131: IN
20132: NOT
20133: IFFALSE 20151
// list := list diff i ;
20135: LD_ADDR_VAR 0 5
20139: PUSH
20140: LD_VAR 0 5
20144: PUSH
20145: LD_VAR 0 8
20149: DIFF
20150: ST_TO_ADDR
20151: GO 20119
20153: POP
20154: POP
// if not list then
20155: LD_VAR 0 5
20159: NOT
20160: IFFALSE 20164
// exit ;
20162: GO 20968
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20164: LD_VAR 0 12
20168: PUSH
20169: LD_INT 3
20171: EQUAL
20172: PUSH
20173: LD_INT 49
20175: PUSH
20176: LD_VAR 0 5
20180: IN
20181: AND
20182: PUSH
20183: LD_INT 31
20185: PPUSH
20186: LD_VAR 0 16
20190: PPUSH
20191: CALL_OW 321
20195: PUSH
20196: LD_INT 2
20198: EQUAL
20199: AND
20200: IFFALSE 20260
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20202: LD_INT 22
20204: PUSH
20205: LD_VAR 0 16
20209: PUSH
20210: EMPTY
20211: LIST
20212: LIST
20213: PUSH
20214: LD_INT 35
20216: PUSH
20217: LD_INT 49
20219: PUSH
20220: EMPTY
20221: LIST
20222: LIST
20223: PUSH
20224: LD_INT 91
20226: PUSH
20227: LD_VAR 0 1
20231: PUSH
20232: LD_INT 10
20234: PUSH
20235: EMPTY
20236: LIST
20237: LIST
20238: LIST
20239: PUSH
20240: EMPTY
20241: LIST
20242: LIST
20243: LIST
20244: PPUSH
20245: CALL_OW 69
20249: NOT
20250: IFFALSE 20260
// weapon := ru_time_lapser ;
20252: LD_ADDR_VAR 0 18
20256: PUSH
20257: LD_INT 49
20259: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20260: LD_VAR 0 12
20264: PUSH
20265: LD_INT 1
20267: PUSH
20268: LD_INT 2
20270: PUSH
20271: EMPTY
20272: LIST
20273: LIST
20274: IN
20275: PUSH
20276: LD_INT 11
20278: PUSH
20279: LD_VAR 0 5
20283: IN
20284: PUSH
20285: LD_INT 30
20287: PUSH
20288: LD_VAR 0 5
20292: IN
20293: OR
20294: AND
20295: PUSH
20296: LD_INT 6
20298: PPUSH
20299: LD_VAR 0 16
20303: PPUSH
20304: CALL_OW 321
20308: PUSH
20309: LD_INT 2
20311: EQUAL
20312: AND
20313: IFFALSE 20478
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20315: LD_INT 22
20317: PUSH
20318: LD_VAR 0 16
20322: PUSH
20323: EMPTY
20324: LIST
20325: LIST
20326: PUSH
20327: LD_INT 2
20329: PUSH
20330: LD_INT 35
20332: PUSH
20333: LD_INT 11
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: PUSH
20340: LD_INT 35
20342: PUSH
20343: LD_INT 30
20345: PUSH
20346: EMPTY
20347: LIST
20348: LIST
20349: PUSH
20350: EMPTY
20351: LIST
20352: LIST
20353: LIST
20354: PUSH
20355: LD_INT 91
20357: PUSH
20358: LD_VAR 0 1
20362: PUSH
20363: LD_INT 18
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: LIST
20370: PUSH
20371: EMPTY
20372: LIST
20373: LIST
20374: LIST
20375: PPUSH
20376: CALL_OW 69
20380: NOT
20381: PUSH
20382: LD_INT 22
20384: PUSH
20385: LD_VAR 0 16
20389: PUSH
20390: EMPTY
20391: LIST
20392: LIST
20393: PUSH
20394: LD_INT 2
20396: PUSH
20397: LD_INT 30
20399: PUSH
20400: LD_INT 32
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: PUSH
20407: LD_INT 30
20409: PUSH
20410: LD_INT 33
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: PUSH
20422: LD_INT 91
20424: PUSH
20425: LD_VAR 0 1
20429: PUSH
20430: LD_INT 12
20432: PUSH
20433: EMPTY
20434: LIST
20435: LIST
20436: LIST
20437: PUSH
20438: EMPTY
20439: LIST
20440: LIST
20441: LIST
20442: PUSH
20443: EMPTY
20444: LIST
20445: PPUSH
20446: CALL_OW 69
20450: PUSH
20451: LD_INT 2
20453: GREATER
20454: AND
20455: IFFALSE 20478
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20457: LD_ADDR_VAR 0 18
20461: PUSH
20462: LD_INT 11
20464: PUSH
20465: LD_INT 30
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: PUSH
20472: LD_VAR 0 12
20476: ARRAY
20477: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20478: LD_VAR 0 18
20482: NOT
20483: PUSH
20484: LD_INT 40
20486: PPUSH
20487: LD_VAR 0 16
20491: PPUSH
20492: CALL_OW 321
20496: PUSH
20497: LD_INT 2
20499: EQUAL
20500: AND
20501: PUSH
20502: LD_INT 7
20504: PUSH
20505: LD_VAR 0 5
20509: IN
20510: PUSH
20511: LD_INT 28
20513: PUSH
20514: LD_VAR 0 5
20518: IN
20519: OR
20520: PUSH
20521: LD_INT 45
20523: PUSH
20524: LD_VAR 0 5
20528: IN
20529: OR
20530: AND
20531: IFFALSE 20785
// begin hex := GetHexInfo ( x , y ) ;
20533: LD_ADDR_VAR 0 4
20537: PUSH
20538: LD_VAR 0 10
20542: PPUSH
20543: LD_VAR 0 11
20547: PPUSH
20548: CALL_OW 546
20552: ST_TO_ADDR
// if hex [ 1 ] then
20553: LD_VAR 0 4
20557: PUSH
20558: LD_INT 1
20560: ARRAY
20561: IFFALSE 20565
// exit ;
20563: GO 20968
// height := hex [ 2 ] ;
20565: LD_ADDR_VAR 0 15
20569: PUSH
20570: LD_VAR 0 4
20574: PUSH
20575: LD_INT 2
20577: ARRAY
20578: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20579: LD_ADDR_VAR 0 14
20583: PUSH
20584: LD_INT 0
20586: PUSH
20587: LD_INT 2
20589: PUSH
20590: LD_INT 3
20592: PUSH
20593: LD_INT 5
20595: PUSH
20596: EMPTY
20597: LIST
20598: LIST
20599: LIST
20600: LIST
20601: ST_TO_ADDR
// for i in tmp do
20602: LD_ADDR_VAR 0 8
20606: PUSH
20607: LD_VAR 0 14
20611: PUSH
20612: FOR_IN
20613: IFFALSE 20783
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20615: LD_ADDR_VAR 0 9
20619: PUSH
20620: LD_VAR 0 10
20624: PPUSH
20625: LD_VAR 0 8
20629: PPUSH
20630: LD_INT 5
20632: PPUSH
20633: CALL_OW 272
20637: PUSH
20638: LD_VAR 0 11
20642: PPUSH
20643: LD_VAR 0 8
20647: PPUSH
20648: LD_INT 5
20650: PPUSH
20651: CALL_OW 273
20655: PUSH
20656: EMPTY
20657: LIST
20658: LIST
20659: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20660: LD_VAR 0 9
20664: PUSH
20665: LD_INT 1
20667: ARRAY
20668: PPUSH
20669: LD_VAR 0 9
20673: PUSH
20674: LD_INT 2
20676: ARRAY
20677: PPUSH
20678: CALL_OW 488
20682: IFFALSE 20781
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20684: LD_ADDR_VAR 0 4
20688: PUSH
20689: LD_VAR 0 9
20693: PUSH
20694: LD_INT 1
20696: ARRAY
20697: PPUSH
20698: LD_VAR 0 9
20702: PUSH
20703: LD_INT 2
20705: ARRAY
20706: PPUSH
20707: CALL_OW 546
20711: ST_TO_ADDR
// if hex [ 1 ] then
20712: LD_VAR 0 4
20716: PUSH
20717: LD_INT 1
20719: ARRAY
20720: IFFALSE 20724
// continue ;
20722: GO 20612
// h := hex [ 2 ] ;
20724: LD_ADDR_VAR 0 13
20728: PUSH
20729: LD_VAR 0 4
20733: PUSH
20734: LD_INT 2
20736: ARRAY
20737: ST_TO_ADDR
// if h + 7 < height then
20738: LD_VAR 0 13
20742: PUSH
20743: LD_INT 7
20745: PLUS
20746: PUSH
20747: LD_VAR 0 15
20751: LESS
20752: IFFALSE 20781
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20754: LD_ADDR_VAR 0 18
20758: PUSH
20759: LD_INT 7
20761: PUSH
20762: LD_INT 28
20764: PUSH
20765: LD_INT 45
20767: PUSH
20768: EMPTY
20769: LIST
20770: LIST
20771: LIST
20772: PUSH
20773: LD_VAR 0 12
20777: ARRAY
20778: ST_TO_ADDR
// break ;
20779: GO 20783
// end ; end ; end ;
20781: GO 20612
20783: POP
20784: POP
// end ; if not weapon then
20785: LD_VAR 0 18
20789: NOT
20790: IFFALSE 20850
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20792: LD_ADDR_VAR 0 5
20796: PUSH
20797: LD_VAR 0 5
20801: PUSH
20802: LD_INT 11
20804: PUSH
20805: LD_INT 30
20807: PUSH
20808: LD_INT 49
20810: PUSH
20811: EMPTY
20812: LIST
20813: LIST
20814: LIST
20815: DIFF
20816: ST_TO_ADDR
// if not list then
20817: LD_VAR 0 5
20821: NOT
20822: IFFALSE 20826
// exit ;
20824: GO 20968
// weapon := list [ rand ( 1 , list ) ] ;
20826: LD_ADDR_VAR 0 18
20830: PUSH
20831: LD_VAR 0 5
20835: PUSH
20836: LD_INT 1
20838: PPUSH
20839: LD_VAR 0 5
20843: PPUSH
20844: CALL_OW 12
20848: ARRAY
20849: ST_TO_ADDR
// end ; if weapon then
20850: LD_VAR 0 18
20854: IFFALSE 20968
// begin tmp := CostOfWeapon ( weapon ) ;
20856: LD_ADDR_VAR 0 14
20860: PUSH
20861: LD_VAR 0 18
20865: PPUSH
20866: CALL_OW 451
20870: ST_TO_ADDR
// j := GetBase ( tower ) ;
20871: LD_ADDR_VAR 0 9
20875: PUSH
20876: LD_VAR 0 1
20880: PPUSH
20881: CALL_OW 274
20885: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20886: LD_VAR 0 9
20890: PPUSH
20891: LD_INT 1
20893: PPUSH
20894: CALL_OW 275
20898: PUSH
20899: LD_VAR 0 14
20903: PUSH
20904: LD_INT 1
20906: ARRAY
20907: GREATEREQUAL
20908: PUSH
20909: LD_VAR 0 9
20913: PPUSH
20914: LD_INT 2
20916: PPUSH
20917: CALL_OW 275
20921: PUSH
20922: LD_VAR 0 14
20926: PUSH
20927: LD_INT 2
20929: ARRAY
20930: GREATEREQUAL
20931: AND
20932: PUSH
20933: LD_VAR 0 9
20937: PPUSH
20938: LD_INT 3
20940: PPUSH
20941: CALL_OW 275
20945: PUSH
20946: LD_VAR 0 14
20950: PUSH
20951: LD_INT 3
20953: ARRAY
20954: GREATEREQUAL
20955: AND
20956: IFFALSE 20968
// result := weapon ;
20958: LD_ADDR_VAR 0 3
20962: PUSH
20963: LD_VAR 0 18
20967: ST_TO_ADDR
// end ; end ;
20968: LD_VAR 0 3
20972: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
20973: LD_INT 0
20975: PPUSH
20976: PPUSH
// result := true ;
20977: LD_ADDR_VAR 0 3
20981: PUSH
20982: LD_INT 1
20984: ST_TO_ADDR
// if array1 = array2 then
20985: LD_VAR 0 1
20989: PUSH
20990: LD_VAR 0 2
20994: EQUAL
20995: IFFALSE 21055
// begin for i = 1 to array1 do
20997: LD_ADDR_VAR 0 4
21001: PUSH
21002: DOUBLE
21003: LD_INT 1
21005: DEC
21006: ST_TO_ADDR
21007: LD_VAR 0 1
21011: PUSH
21012: FOR_TO
21013: IFFALSE 21051
// if array1 [ i ] <> array2 [ i ] then
21015: LD_VAR 0 1
21019: PUSH
21020: LD_VAR 0 4
21024: ARRAY
21025: PUSH
21026: LD_VAR 0 2
21030: PUSH
21031: LD_VAR 0 4
21035: ARRAY
21036: NONEQUAL
21037: IFFALSE 21049
// begin result := false ;
21039: LD_ADDR_VAR 0 3
21043: PUSH
21044: LD_INT 0
21046: ST_TO_ADDR
// break ;
21047: GO 21051
// end ;
21049: GO 21012
21051: POP
21052: POP
// end else
21053: GO 21063
// result := false ;
21055: LD_ADDR_VAR 0 3
21059: PUSH
21060: LD_INT 0
21062: ST_TO_ADDR
// end ;
21063: LD_VAR 0 3
21067: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21068: LD_INT 0
21070: PPUSH
21071: PPUSH
21072: PPUSH
// pom := GetBase ( fac ) ;
21073: LD_ADDR_VAR 0 5
21077: PUSH
21078: LD_VAR 0 1
21082: PPUSH
21083: CALL_OW 274
21087: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21088: LD_ADDR_VAR 0 4
21092: PUSH
21093: LD_VAR 0 2
21097: PUSH
21098: LD_INT 1
21100: ARRAY
21101: PPUSH
21102: LD_VAR 0 2
21106: PUSH
21107: LD_INT 2
21109: ARRAY
21110: PPUSH
21111: LD_VAR 0 2
21115: PUSH
21116: LD_INT 3
21118: ARRAY
21119: PPUSH
21120: LD_VAR 0 2
21124: PUSH
21125: LD_INT 4
21127: ARRAY
21128: PPUSH
21129: CALL_OW 449
21133: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21134: LD_ADDR_VAR 0 3
21138: PUSH
21139: LD_VAR 0 5
21143: PPUSH
21144: LD_INT 1
21146: PPUSH
21147: CALL_OW 275
21151: PUSH
21152: LD_VAR 0 4
21156: PUSH
21157: LD_INT 1
21159: ARRAY
21160: GREATEREQUAL
21161: PUSH
21162: LD_VAR 0 5
21166: PPUSH
21167: LD_INT 2
21169: PPUSH
21170: CALL_OW 275
21174: PUSH
21175: LD_VAR 0 4
21179: PUSH
21180: LD_INT 2
21182: ARRAY
21183: GREATEREQUAL
21184: AND
21185: PUSH
21186: LD_VAR 0 5
21190: PPUSH
21191: LD_INT 3
21193: PPUSH
21194: CALL_OW 275
21198: PUSH
21199: LD_VAR 0 4
21203: PUSH
21204: LD_INT 3
21206: ARRAY
21207: GREATEREQUAL
21208: AND
21209: ST_TO_ADDR
// end ;
21210: LD_VAR 0 3
21214: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21215: LD_INT 0
21217: PPUSH
21218: PPUSH
21219: PPUSH
21220: PPUSH
// pom := GetBase ( building ) ;
21221: LD_ADDR_VAR 0 3
21225: PUSH
21226: LD_VAR 0 1
21230: PPUSH
21231: CALL_OW 274
21235: ST_TO_ADDR
// if not pom then
21236: LD_VAR 0 3
21240: NOT
21241: IFFALSE 21245
// exit ;
21243: GO 21415
// btype := GetBType ( building ) ;
21245: LD_ADDR_VAR 0 5
21249: PUSH
21250: LD_VAR 0 1
21254: PPUSH
21255: CALL_OW 266
21259: ST_TO_ADDR
// if btype = b_armoury then
21260: LD_VAR 0 5
21264: PUSH
21265: LD_INT 4
21267: EQUAL
21268: IFFALSE 21278
// btype := b_barracks ;
21270: LD_ADDR_VAR 0 5
21274: PUSH
21275: LD_INT 5
21277: ST_TO_ADDR
// if btype = b_depot then
21278: LD_VAR 0 5
21282: PUSH
21283: LD_INT 0
21285: EQUAL
21286: IFFALSE 21296
// btype := b_warehouse ;
21288: LD_ADDR_VAR 0 5
21292: PUSH
21293: LD_INT 1
21295: ST_TO_ADDR
// if btype = b_workshop then
21296: LD_VAR 0 5
21300: PUSH
21301: LD_INT 2
21303: EQUAL
21304: IFFALSE 21314
// btype := b_factory ;
21306: LD_ADDR_VAR 0 5
21310: PUSH
21311: LD_INT 3
21313: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21314: LD_ADDR_VAR 0 4
21318: PUSH
21319: LD_VAR 0 5
21323: PPUSH
21324: LD_VAR 0 1
21328: PPUSH
21329: CALL_OW 248
21333: PPUSH
21334: CALL_OW 450
21338: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21339: LD_ADDR_VAR 0 2
21343: PUSH
21344: LD_VAR 0 3
21348: PPUSH
21349: LD_INT 1
21351: PPUSH
21352: CALL_OW 275
21356: PUSH
21357: LD_VAR 0 4
21361: PUSH
21362: LD_INT 1
21364: ARRAY
21365: GREATEREQUAL
21366: PUSH
21367: LD_VAR 0 3
21371: PPUSH
21372: LD_INT 2
21374: PPUSH
21375: CALL_OW 275
21379: PUSH
21380: LD_VAR 0 4
21384: PUSH
21385: LD_INT 2
21387: ARRAY
21388: GREATEREQUAL
21389: AND
21390: PUSH
21391: LD_VAR 0 3
21395: PPUSH
21396: LD_INT 3
21398: PPUSH
21399: CALL_OW 275
21403: PUSH
21404: LD_VAR 0 4
21408: PUSH
21409: LD_INT 3
21411: ARRAY
21412: GREATEREQUAL
21413: AND
21414: ST_TO_ADDR
// end ;
21415: LD_VAR 0 2
21419: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21420: LD_INT 0
21422: PPUSH
21423: PPUSH
21424: PPUSH
// pom := GetBase ( building ) ;
21425: LD_ADDR_VAR 0 4
21429: PUSH
21430: LD_VAR 0 1
21434: PPUSH
21435: CALL_OW 274
21439: ST_TO_ADDR
// if not pom then
21440: LD_VAR 0 4
21444: NOT
21445: IFFALSE 21449
// exit ;
21447: GO 21550
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21449: LD_ADDR_VAR 0 5
21453: PUSH
21454: LD_VAR 0 2
21458: PPUSH
21459: LD_VAR 0 1
21463: PPUSH
21464: CALL_OW 248
21468: PPUSH
21469: CALL_OW 450
21473: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21474: LD_ADDR_VAR 0 3
21478: PUSH
21479: LD_VAR 0 4
21483: PPUSH
21484: LD_INT 1
21486: PPUSH
21487: CALL_OW 275
21491: PUSH
21492: LD_VAR 0 5
21496: PUSH
21497: LD_INT 1
21499: ARRAY
21500: GREATEREQUAL
21501: PUSH
21502: LD_VAR 0 4
21506: PPUSH
21507: LD_INT 2
21509: PPUSH
21510: CALL_OW 275
21514: PUSH
21515: LD_VAR 0 5
21519: PUSH
21520: LD_INT 2
21522: ARRAY
21523: GREATEREQUAL
21524: AND
21525: PUSH
21526: LD_VAR 0 4
21530: PPUSH
21531: LD_INT 3
21533: PPUSH
21534: CALL_OW 275
21538: PUSH
21539: LD_VAR 0 5
21543: PUSH
21544: LD_INT 3
21546: ARRAY
21547: GREATEREQUAL
21548: AND
21549: ST_TO_ADDR
// end ;
21550: LD_VAR 0 3
21554: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
21555: LD_INT 0
21557: PPUSH
21558: PPUSH
21559: PPUSH
21560: PPUSH
21561: PPUSH
21562: PPUSH
21563: PPUSH
21564: PPUSH
21565: PPUSH
21566: PPUSH
// result := false ;
21567: LD_ADDR_VAR 0 6
21571: PUSH
21572: LD_INT 0
21574: ST_TO_ADDR
// if not base or not btype or not x or not y then
21575: LD_VAR 0 1
21579: NOT
21580: PUSH
21581: LD_VAR 0 2
21585: NOT
21586: OR
21587: PUSH
21588: LD_VAR 0 3
21592: NOT
21593: OR
21594: PUSH
21595: LD_VAR 0 4
21599: NOT
21600: OR
21601: IFFALSE 21605
// exit ;
21603: GO 22214
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
21605: LD_ADDR_VAR 0 12
21609: PUSH
21610: LD_VAR 0 2
21614: PPUSH
21615: LD_VAR 0 3
21619: PPUSH
21620: LD_VAR 0 4
21624: PPUSH
21625: LD_VAR 0 5
21629: PPUSH
21630: LD_VAR 0 1
21634: PUSH
21635: LD_INT 1
21637: ARRAY
21638: PPUSH
21639: CALL_OW 248
21643: PPUSH
21644: LD_INT 0
21646: PPUSH
21647: CALL 23051 0 6
21651: ST_TO_ADDR
// if not hexes then
21652: LD_VAR 0 12
21656: NOT
21657: IFFALSE 21661
// exit ;
21659: GO 22214
// for i = 1 to hexes do
21661: LD_ADDR_VAR 0 7
21665: PUSH
21666: DOUBLE
21667: LD_INT 1
21669: DEC
21670: ST_TO_ADDR
21671: LD_VAR 0 12
21675: PUSH
21676: FOR_TO
21677: IFFALSE 22212
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21679: LD_ADDR_VAR 0 11
21683: PUSH
21684: LD_VAR 0 12
21688: PUSH
21689: LD_VAR 0 7
21693: ARRAY
21694: PUSH
21695: LD_INT 1
21697: ARRAY
21698: PPUSH
21699: LD_VAR 0 12
21703: PUSH
21704: LD_VAR 0 7
21708: ARRAY
21709: PUSH
21710: LD_INT 2
21712: ARRAY
21713: PPUSH
21714: CALL_OW 428
21718: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21719: LD_VAR 0 12
21723: PUSH
21724: LD_VAR 0 7
21728: ARRAY
21729: PUSH
21730: LD_INT 1
21732: ARRAY
21733: PPUSH
21734: LD_VAR 0 12
21738: PUSH
21739: LD_VAR 0 7
21743: ARRAY
21744: PUSH
21745: LD_INT 2
21747: ARRAY
21748: PPUSH
21749: CALL_OW 351
21753: PUSH
21754: LD_VAR 0 12
21758: PUSH
21759: LD_VAR 0 7
21763: ARRAY
21764: PUSH
21765: LD_INT 1
21767: ARRAY
21768: PPUSH
21769: LD_VAR 0 12
21773: PUSH
21774: LD_VAR 0 7
21778: ARRAY
21779: PUSH
21780: LD_INT 2
21782: ARRAY
21783: PPUSH
21784: CALL_OW 488
21788: NOT
21789: OR
21790: PUSH
21791: LD_VAR 0 11
21795: PPUSH
21796: CALL_OW 247
21800: PUSH
21801: LD_INT 3
21803: EQUAL
21804: OR
21805: IFFALSE 21811
// exit ;
21807: POP
21808: POP
21809: GO 22214
// if not tmp or not tmp in base then
21811: LD_VAR 0 11
21815: NOT
21816: PUSH
21817: LD_VAR 0 11
21821: PUSH
21822: LD_VAR 0 1
21826: IN
21827: NOT
21828: OR
21829: IFFALSE 21833
// continue ;
21831: GO 21676
// result := true ;
21833: LD_ADDR_VAR 0 6
21837: PUSH
21838: LD_INT 1
21840: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21841: LD_ADDR_VAR 0 15
21845: PUSH
21846: LD_VAR 0 1
21850: PPUSH
21851: LD_INT 22
21853: PUSH
21854: LD_VAR 0 11
21858: PPUSH
21859: CALL_OW 255
21863: PUSH
21864: EMPTY
21865: LIST
21866: LIST
21867: PUSH
21868: LD_INT 2
21870: PUSH
21871: LD_INT 30
21873: PUSH
21874: LD_INT 0
21876: PUSH
21877: EMPTY
21878: LIST
21879: LIST
21880: PUSH
21881: LD_INT 30
21883: PUSH
21884: LD_INT 1
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: EMPTY
21892: LIST
21893: LIST
21894: LIST
21895: PUSH
21896: EMPTY
21897: LIST
21898: LIST
21899: PPUSH
21900: CALL_OW 72
21904: ST_TO_ADDR
// if dep then
21905: LD_VAR 0 15
21909: IFFALSE 22045
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
21911: LD_ADDR_VAR 0 14
21915: PUSH
21916: LD_VAR 0 15
21920: PUSH
21921: LD_INT 1
21923: ARRAY
21924: PPUSH
21925: CALL_OW 250
21929: PPUSH
21930: LD_VAR 0 15
21934: PUSH
21935: LD_INT 1
21937: ARRAY
21938: PPUSH
21939: CALL_OW 254
21943: PPUSH
21944: LD_INT 5
21946: PPUSH
21947: CALL_OW 272
21951: PUSH
21952: LD_VAR 0 15
21956: PUSH
21957: LD_INT 1
21959: ARRAY
21960: PPUSH
21961: CALL_OW 251
21965: PPUSH
21966: LD_VAR 0 15
21970: PUSH
21971: LD_INT 1
21973: ARRAY
21974: PPUSH
21975: CALL_OW 254
21979: PPUSH
21980: LD_INT 5
21982: PPUSH
21983: CALL_OW 273
21987: PUSH
21988: EMPTY
21989: LIST
21990: LIST
21991: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
21992: LD_VAR 0 14
21996: PUSH
21997: LD_INT 1
21999: ARRAY
22000: PPUSH
22001: LD_VAR 0 14
22005: PUSH
22006: LD_INT 2
22008: ARRAY
22009: PPUSH
22010: CALL_OW 488
22014: IFFALSE 22045
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22016: LD_VAR 0 11
22020: PPUSH
22021: LD_VAR 0 14
22025: PUSH
22026: LD_INT 1
22028: ARRAY
22029: PPUSH
22030: LD_VAR 0 14
22034: PUSH
22035: LD_INT 2
22037: ARRAY
22038: PPUSH
22039: CALL_OW 111
// continue ;
22043: GO 21676
// end ; end ; r := GetDir ( tmp ) ;
22045: LD_ADDR_VAR 0 13
22049: PUSH
22050: LD_VAR 0 11
22054: PPUSH
22055: CALL_OW 254
22059: ST_TO_ADDR
// if r = 5 then
22060: LD_VAR 0 13
22064: PUSH
22065: LD_INT 5
22067: EQUAL
22068: IFFALSE 22078
// r := 0 ;
22070: LD_ADDR_VAR 0 13
22074: PUSH
22075: LD_INT 0
22077: ST_TO_ADDR
// for j = r to 5 do
22078: LD_ADDR_VAR 0 8
22082: PUSH
22083: DOUBLE
22084: LD_VAR 0 13
22088: DEC
22089: ST_TO_ADDR
22090: LD_INT 5
22092: PUSH
22093: FOR_TO
22094: IFFALSE 22208
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22096: LD_ADDR_VAR 0 9
22100: PUSH
22101: LD_VAR 0 11
22105: PPUSH
22106: CALL_OW 250
22110: PPUSH
22111: LD_VAR 0 8
22115: PPUSH
22116: LD_INT 2
22118: PPUSH
22119: CALL_OW 272
22123: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22124: LD_ADDR_VAR 0 10
22128: PUSH
22129: LD_VAR 0 11
22133: PPUSH
22134: CALL_OW 251
22138: PPUSH
22139: LD_VAR 0 8
22143: PPUSH
22144: LD_INT 2
22146: PPUSH
22147: CALL_OW 273
22151: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22152: LD_VAR 0 9
22156: PPUSH
22157: LD_VAR 0 10
22161: PPUSH
22162: CALL_OW 488
22166: PUSH
22167: LD_VAR 0 9
22171: PPUSH
22172: LD_VAR 0 10
22176: PPUSH
22177: CALL_OW 428
22181: NOT
22182: AND
22183: IFFALSE 22206
// begin ComMoveXY ( tmp , _x , _y ) ;
22185: LD_VAR 0 11
22189: PPUSH
22190: LD_VAR 0 9
22194: PPUSH
22195: LD_VAR 0 10
22199: PPUSH
22200: CALL_OW 111
// break ;
22204: GO 22208
// end ; end ;
22206: GO 22093
22208: POP
22209: POP
// end ;
22210: GO 21676
22212: POP
22213: POP
// end ;
22214: LD_VAR 0 6
22218: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
22219: LD_INT 0
22221: PPUSH
22222: PPUSH
22223: PPUSH
22224: PPUSH
22225: PPUSH
22226: PPUSH
22227: PPUSH
22228: PPUSH
22229: PPUSH
22230: PPUSH
// result := false ;
22231: LD_ADDR_VAR 0 6
22235: PUSH
22236: LD_INT 0
22238: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22239: LD_VAR 0 1
22243: NOT
22244: PUSH
22245: LD_VAR 0 1
22249: PPUSH
22250: CALL_OW 266
22254: PUSH
22255: LD_INT 0
22257: PUSH
22258: LD_INT 1
22260: PUSH
22261: EMPTY
22262: LIST
22263: LIST
22264: IN
22265: NOT
22266: OR
22267: PUSH
22268: LD_VAR 0 2
22272: NOT
22273: OR
22274: PUSH
22275: LD_VAR 0 5
22279: PUSH
22280: LD_INT 0
22282: PUSH
22283: LD_INT 1
22285: PUSH
22286: LD_INT 2
22288: PUSH
22289: LD_INT 3
22291: PUSH
22292: LD_INT 4
22294: PUSH
22295: LD_INT 5
22297: PUSH
22298: EMPTY
22299: LIST
22300: LIST
22301: LIST
22302: LIST
22303: LIST
22304: LIST
22305: IN
22306: NOT
22307: OR
22308: PUSH
22309: LD_VAR 0 3
22313: PPUSH
22314: LD_VAR 0 4
22318: PPUSH
22319: CALL_OW 488
22323: NOT
22324: OR
22325: IFFALSE 22329
// exit ;
22327: GO 23046
// pom := GetBase ( depot ) ;
22329: LD_ADDR_VAR 0 10
22333: PUSH
22334: LD_VAR 0 1
22338: PPUSH
22339: CALL_OW 274
22343: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
22344: LD_ADDR_VAR 0 11
22348: PUSH
22349: LD_VAR 0 2
22353: PPUSH
22354: LD_VAR 0 1
22358: PPUSH
22359: CALL_OW 248
22363: PPUSH
22364: CALL_OW 450
22368: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
22369: LD_VAR 0 10
22373: PPUSH
22374: LD_INT 1
22376: PPUSH
22377: CALL_OW 275
22381: PUSH
22382: LD_VAR 0 11
22386: PUSH
22387: LD_INT 1
22389: ARRAY
22390: GREATEREQUAL
22391: PUSH
22392: LD_VAR 0 10
22396: PPUSH
22397: LD_INT 2
22399: PPUSH
22400: CALL_OW 275
22404: PUSH
22405: LD_VAR 0 11
22409: PUSH
22410: LD_INT 2
22412: ARRAY
22413: GREATEREQUAL
22414: AND
22415: PUSH
22416: LD_VAR 0 10
22420: PPUSH
22421: LD_INT 3
22423: PPUSH
22424: CALL_OW 275
22428: PUSH
22429: LD_VAR 0 11
22433: PUSH
22434: LD_INT 3
22436: ARRAY
22437: GREATEREQUAL
22438: AND
22439: NOT
22440: IFFALSE 22444
// exit ;
22442: GO 23046
// if GetBType ( depot ) = b_depot then
22444: LD_VAR 0 1
22448: PPUSH
22449: CALL_OW 266
22453: PUSH
22454: LD_INT 0
22456: EQUAL
22457: IFFALSE 22469
// dist := 28 else
22459: LD_ADDR_VAR 0 14
22463: PUSH
22464: LD_INT 28
22466: ST_TO_ADDR
22467: GO 22477
// dist := 36 ;
22469: LD_ADDR_VAR 0 14
22473: PUSH
22474: LD_INT 36
22476: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
22477: LD_VAR 0 1
22481: PPUSH
22482: LD_VAR 0 3
22486: PPUSH
22487: LD_VAR 0 4
22491: PPUSH
22492: CALL_OW 297
22496: PUSH
22497: LD_VAR 0 14
22501: GREATER
22502: IFFALSE 22506
// exit ;
22504: GO 23046
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
22506: LD_ADDR_VAR 0 12
22510: PUSH
22511: LD_VAR 0 2
22515: PPUSH
22516: LD_VAR 0 3
22520: PPUSH
22521: LD_VAR 0 4
22525: PPUSH
22526: LD_VAR 0 5
22530: PPUSH
22531: LD_VAR 0 1
22535: PPUSH
22536: CALL_OW 248
22540: PPUSH
22541: LD_INT 0
22543: PPUSH
22544: CALL 23051 0 6
22548: ST_TO_ADDR
// if not hexes then
22549: LD_VAR 0 12
22553: NOT
22554: IFFALSE 22558
// exit ;
22556: GO 23046
// hex := GetHexInfo ( x , y ) ;
22558: LD_ADDR_VAR 0 15
22562: PUSH
22563: LD_VAR 0 3
22567: PPUSH
22568: LD_VAR 0 4
22572: PPUSH
22573: CALL_OW 546
22577: ST_TO_ADDR
// if hex [ 1 ] then
22578: LD_VAR 0 15
22582: PUSH
22583: LD_INT 1
22585: ARRAY
22586: IFFALSE 22590
// exit ;
22588: GO 23046
// height := hex [ 2 ] ;
22590: LD_ADDR_VAR 0 13
22594: PUSH
22595: LD_VAR 0 15
22599: PUSH
22600: LD_INT 2
22602: ARRAY
22603: ST_TO_ADDR
// for i = 1 to hexes do
22604: LD_ADDR_VAR 0 7
22608: PUSH
22609: DOUBLE
22610: LD_INT 1
22612: DEC
22613: ST_TO_ADDR
22614: LD_VAR 0 12
22618: PUSH
22619: FOR_TO
22620: IFFALSE 22950
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
22622: LD_VAR 0 12
22626: PUSH
22627: LD_VAR 0 7
22631: ARRAY
22632: PUSH
22633: LD_INT 1
22635: ARRAY
22636: PPUSH
22637: LD_VAR 0 12
22641: PUSH
22642: LD_VAR 0 7
22646: ARRAY
22647: PUSH
22648: LD_INT 2
22650: ARRAY
22651: PPUSH
22652: CALL_OW 488
22656: NOT
22657: PUSH
22658: LD_VAR 0 12
22662: PUSH
22663: LD_VAR 0 7
22667: ARRAY
22668: PUSH
22669: LD_INT 1
22671: ARRAY
22672: PPUSH
22673: LD_VAR 0 12
22677: PUSH
22678: LD_VAR 0 7
22682: ARRAY
22683: PUSH
22684: LD_INT 2
22686: ARRAY
22687: PPUSH
22688: CALL_OW 428
22692: PUSH
22693: LD_INT 0
22695: GREATER
22696: OR
22697: PUSH
22698: LD_VAR 0 12
22702: PUSH
22703: LD_VAR 0 7
22707: ARRAY
22708: PUSH
22709: LD_INT 1
22711: ARRAY
22712: PPUSH
22713: LD_VAR 0 12
22717: PUSH
22718: LD_VAR 0 7
22722: ARRAY
22723: PUSH
22724: LD_INT 2
22726: ARRAY
22727: PPUSH
22728: CALL_OW 351
22732: OR
22733: IFFALSE 22739
// exit ;
22735: POP
22736: POP
22737: GO 23046
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22739: LD_ADDR_VAR 0 8
22743: PUSH
22744: LD_VAR 0 12
22748: PUSH
22749: LD_VAR 0 7
22753: ARRAY
22754: PUSH
22755: LD_INT 1
22757: ARRAY
22758: PPUSH
22759: LD_VAR 0 12
22763: PUSH
22764: LD_VAR 0 7
22768: ARRAY
22769: PUSH
22770: LD_INT 2
22772: ARRAY
22773: PPUSH
22774: CALL_OW 546
22778: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
22779: LD_VAR 0 8
22783: PUSH
22784: LD_INT 1
22786: ARRAY
22787: PUSH
22788: LD_VAR 0 8
22792: PUSH
22793: LD_INT 2
22795: ARRAY
22796: PUSH
22797: LD_VAR 0 13
22801: PUSH
22802: LD_INT 2
22804: PLUS
22805: GREATER
22806: OR
22807: PUSH
22808: LD_VAR 0 8
22812: PUSH
22813: LD_INT 2
22815: ARRAY
22816: PUSH
22817: LD_VAR 0 13
22821: PUSH
22822: LD_INT 2
22824: MINUS
22825: LESS
22826: OR
22827: PUSH
22828: LD_VAR 0 8
22832: PUSH
22833: LD_INT 3
22835: ARRAY
22836: PUSH
22837: LD_INT 0
22839: PUSH
22840: LD_INT 8
22842: PUSH
22843: LD_INT 9
22845: PUSH
22846: LD_INT 10
22848: PUSH
22849: LD_INT 11
22851: PUSH
22852: LD_INT 12
22854: PUSH
22855: LD_INT 13
22857: PUSH
22858: LD_INT 16
22860: PUSH
22861: LD_INT 17
22863: PUSH
22864: LD_INT 18
22866: PUSH
22867: LD_INT 19
22869: PUSH
22870: LD_INT 20
22872: PUSH
22873: LD_INT 21
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: LIST
22880: LIST
22881: LIST
22882: LIST
22883: LIST
22884: LIST
22885: LIST
22886: LIST
22887: LIST
22888: LIST
22889: LIST
22890: IN
22891: NOT
22892: OR
22893: PUSH
22894: LD_VAR 0 8
22898: PUSH
22899: LD_INT 5
22901: ARRAY
22902: NOT
22903: OR
22904: PUSH
22905: LD_VAR 0 8
22909: PUSH
22910: LD_INT 6
22912: ARRAY
22913: PUSH
22914: LD_INT 1
22916: PUSH
22917: LD_INT 2
22919: PUSH
22920: LD_INT 7
22922: PUSH
22923: LD_INT 9
22925: PUSH
22926: LD_INT 10
22928: PUSH
22929: LD_INT 11
22931: PUSH
22932: EMPTY
22933: LIST
22934: LIST
22935: LIST
22936: LIST
22937: LIST
22938: LIST
22939: IN
22940: NOT
22941: OR
22942: IFFALSE 22948
// exit ;
22944: POP
22945: POP
22946: GO 23046
// end ;
22948: GO 22619
22950: POP
22951: POP
// side := GetSide ( depot ) ;
22952: LD_ADDR_VAR 0 9
22956: PUSH
22957: LD_VAR 0 1
22961: PPUSH
22962: CALL_OW 255
22966: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
22967: LD_VAR 0 9
22971: PPUSH
22972: LD_VAR 0 3
22976: PPUSH
22977: LD_VAR 0 4
22981: PPUSH
22982: LD_INT 20
22984: PPUSH
22985: CALL 15700 0 4
22989: PUSH
22990: LD_INT 4
22992: ARRAY
22993: IFFALSE 22997
// exit ;
22995: GO 23046
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
22997: LD_VAR 0 2
23001: PUSH
23002: LD_INT 29
23004: PUSH
23005: LD_INT 30
23007: PUSH
23008: EMPTY
23009: LIST
23010: LIST
23011: IN
23012: PUSH
23013: LD_VAR 0 3
23017: PPUSH
23018: LD_VAR 0 4
23022: PPUSH
23023: LD_VAR 0 9
23027: PPUSH
23028: CALL_OW 440
23032: NOT
23033: AND
23034: IFFALSE 23038
// exit ;
23036: GO 23046
// result := true ;
23038: LD_ADDR_VAR 0 6
23042: PUSH
23043: LD_INT 1
23045: ST_TO_ADDR
// end ;
23046: LD_VAR 0 6
23050: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23051: LD_INT 0
23053: PPUSH
23054: PPUSH
23055: PPUSH
23056: PPUSH
23057: PPUSH
23058: PPUSH
23059: PPUSH
23060: PPUSH
23061: PPUSH
23062: PPUSH
23063: PPUSH
23064: PPUSH
23065: PPUSH
23066: PPUSH
23067: PPUSH
23068: PPUSH
23069: PPUSH
23070: PPUSH
23071: PPUSH
23072: PPUSH
23073: PPUSH
23074: PPUSH
23075: PPUSH
23076: PPUSH
23077: PPUSH
23078: PPUSH
23079: PPUSH
23080: PPUSH
23081: PPUSH
23082: PPUSH
23083: PPUSH
23084: PPUSH
23085: PPUSH
23086: PPUSH
23087: PPUSH
23088: PPUSH
23089: PPUSH
23090: PPUSH
23091: PPUSH
23092: PPUSH
23093: PPUSH
23094: PPUSH
23095: PPUSH
23096: PPUSH
23097: PPUSH
23098: PPUSH
23099: PPUSH
23100: PPUSH
23101: PPUSH
23102: PPUSH
23103: PPUSH
23104: PPUSH
23105: PPUSH
23106: PPUSH
23107: PPUSH
23108: PPUSH
23109: PPUSH
23110: PPUSH
// result = [ ] ;
23111: LD_ADDR_VAR 0 7
23115: PUSH
23116: EMPTY
23117: ST_TO_ADDR
// temp_list = [ ] ;
23118: LD_ADDR_VAR 0 9
23122: PUSH
23123: EMPTY
23124: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23125: LD_VAR 0 4
23129: PUSH
23130: LD_INT 0
23132: PUSH
23133: LD_INT 1
23135: PUSH
23136: LD_INT 2
23138: PUSH
23139: LD_INT 3
23141: PUSH
23142: LD_INT 4
23144: PUSH
23145: LD_INT 5
23147: PUSH
23148: EMPTY
23149: LIST
23150: LIST
23151: LIST
23152: LIST
23153: LIST
23154: LIST
23155: IN
23156: NOT
23157: PUSH
23158: LD_VAR 0 1
23162: PUSH
23163: LD_INT 0
23165: PUSH
23166: LD_INT 1
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: IN
23173: PUSH
23174: LD_VAR 0 5
23178: PUSH
23179: LD_INT 1
23181: PUSH
23182: LD_INT 2
23184: PUSH
23185: LD_INT 3
23187: PUSH
23188: EMPTY
23189: LIST
23190: LIST
23191: LIST
23192: IN
23193: NOT
23194: AND
23195: OR
23196: IFFALSE 23200
// exit ;
23198: GO 41591
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23200: LD_VAR 0 1
23204: PUSH
23205: LD_INT 6
23207: PUSH
23208: LD_INT 7
23210: PUSH
23211: LD_INT 8
23213: PUSH
23214: LD_INT 13
23216: PUSH
23217: LD_INT 12
23219: PUSH
23220: LD_INT 15
23222: PUSH
23223: LD_INT 11
23225: PUSH
23226: LD_INT 14
23228: PUSH
23229: LD_INT 10
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: LIST
23239: LIST
23240: LIST
23241: LIST
23242: IN
23243: IFFALSE 23253
// btype = b_lab ;
23245: LD_ADDR_VAR 0 1
23249: PUSH
23250: LD_INT 6
23252: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23253: LD_VAR 0 6
23257: PUSH
23258: LD_INT 0
23260: PUSH
23261: LD_INT 1
23263: PUSH
23264: LD_INT 2
23266: PUSH
23267: EMPTY
23268: LIST
23269: LIST
23270: LIST
23271: IN
23272: NOT
23273: PUSH
23274: LD_VAR 0 1
23278: PUSH
23279: LD_INT 0
23281: PUSH
23282: LD_INT 1
23284: PUSH
23285: LD_INT 2
23287: PUSH
23288: LD_INT 3
23290: PUSH
23291: LD_INT 6
23293: PUSH
23294: LD_INT 36
23296: PUSH
23297: LD_INT 4
23299: PUSH
23300: LD_INT 5
23302: PUSH
23303: LD_INT 31
23305: PUSH
23306: LD_INT 32
23308: PUSH
23309: LD_INT 33
23311: PUSH
23312: EMPTY
23313: LIST
23314: LIST
23315: LIST
23316: LIST
23317: LIST
23318: LIST
23319: LIST
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: IN
23325: NOT
23326: PUSH
23327: LD_VAR 0 6
23331: PUSH
23332: LD_INT 1
23334: EQUAL
23335: AND
23336: OR
23337: PUSH
23338: LD_VAR 0 1
23342: PUSH
23343: LD_INT 2
23345: PUSH
23346: LD_INT 3
23348: PUSH
23349: EMPTY
23350: LIST
23351: LIST
23352: IN
23353: NOT
23354: PUSH
23355: LD_VAR 0 6
23359: PUSH
23360: LD_INT 2
23362: EQUAL
23363: AND
23364: OR
23365: IFFALSE 23375
// mode = 0 ;
23367: LD_ADDR_VAR 0 6
23371: PUSH
23372: LD_INT 0
23374: ST_TO_ADDR
// case mode of 0 :
23375: LD_VAR 0 6
23379: PUSH
23380: LD_INT 0
23382: DOUBLE
23383: EQUAL
23384: IFTRUE 23388
23386: GO 34841
23388: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
23389: LD_ADDR_VAR 0 11
23393: PUSH
23394: LD_INT 0
23396: PUSH
23397: LD_INT 0
23399: PUSH
23400: EMPTY
23401: LIST
23402: LIST
23403: PUSH
23404: LD_INT 0
23406: PUSH
23407: LD_INT 1
23409: NEG
23410: PUSH
23411: EMPTY
23412: LIST
23413: LIST
23414: PUSH
23415: LD_INT 1
23417: PUSH
23418: LD_INT 0
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: PUSH
23425: LD_INT 1
23427: PUSH
23428: LD_INT 1
23430: PUSH
23431: EMPTY
23432: LIST
23433: LIST
23434: PUSH
23435: LD_INT 0
23437: PUSH
23438: LD_INT 1
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: PUSH
23445: LD_INT 1
23447: NEG
23448: PUSH
23449: LD_INT 0
23451: PUSH
23452: EMPTY
23453: LIST
23454: LIST
23455: PUSH
23456: LD_INT 1
23458: NEG
23459: PUSH
23460: LD_INT 1
23462: NEG
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: PUSH
23468: LD_INT 1
23470: NEG
23471: PUSH
23472: LD_INT 2
23474: NEG
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: PUSH
23480: LD_INT 0
23482: PUSH
23483: LD_INT 2
23485: NEG
23486: PUSH
23487: EMPTY
23488: LIST
23489: LIST
23490: PUSH
23491: LD_INT 1
23493: PUSH
23494: LD_INT 1
23496: NEG
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: PUSH
23502: LD_INT 1
23504: PUSH
23505: LD_INT 2
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: PUSH
23512: LD_INT 0
23514: PUSH
23515: LD_INT 2
23517: PUSH
23518: EMPTY
23519: LIST
23520: LIST
23521: PUSH
23522: LD_INT 1
23524: NEG
23525: PUSH
23526: LD_INT 1
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PUSH
23533: LD_INT 1
23535: PUSH
23536: LD_INT 3
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: PUSH
23543: LD_INT 0
23545: PUSH
23546: LD_INT 3
23548: PUSH
23549: EMPTY
23550: LIST
23551: LIST
23552: PUSH
23553: LD_INT 1
23555: NEG
23556: PUSH
23557: LD_INT 2
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: EMPTY
23565: LIST
23566: LIST
23567: LIST
23568: LIST
23569: LIST
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: LIST
23575: LIST
23576: LIST
23577: LIST
23578: LIST
23579: LIST
23580: LIST
23581: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
23582: LD_ADDR_VAR 0 12
23586: PUSH
23587: LD_INT 0
23589: PUSH
23590: LD_INT 0
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: PUSH
23597: LD_INT 0
23599: PUSH
23600: LD_INT 1
23602: NEG
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: PUSH
23608: LD_INT 1
23610: PUSH
23611: LD_INT 0
23613: PUSH
23614: EMPTY
23615: LIST
23616: LIST
23617: PUSH
23618: LD_INT 1
23620: PUSH
23621: LD_INT 1
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: PUSH
23628: LD_INT 0
23630: PUSH
23631: LD_INT 1
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: PUSH
23638: LD_INT 1
23640: NEG
23641: PUSH
23642: LD_INT 0
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PUSH
23649: LD_INT 1
23651: NEG
23652: PUSH
23653: LD_INT 1
23655: NEG
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: PUSH
23661: LD_INT 1
23663: PUSH
23664: LD_INT 1
23666: NEG
23667: PUSH
23668: EMPTY
23669: LIST
23670: LIST
23671: PUSH
23672: LD_INT 2
23674: PUSH
23675: LD_INT 0
23677: PUSH
23678: EMPTY
23679: LIST
23680: LIST
23681: PUSH
23682: LD_INT 2
23684: PUSH
23685: LD_INT 1
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: PUSH
23692: LD_INT 1
23694: NEG
23695: PUSH
23696: LD_INT 1
23698: PUSH
23699: EMPTY
23700: LIST
23701: LIST
23702: PUSH
23703: LD_INT 2
23705: NEG
23706: PUSH
23707: LD_INT 0
23709: PUSH
23710: EMPTY
23711: LIST
23712: LIST
23713: PUSH
23714: LD_INT 2
23716: NEG
23717: PUSH
23718: LD_INT 1
23720: NEG
23721: PUSH
23722: EMPTY
23723: LIST
23724: LIST
23725: PUSH
23726: LD_INT 2
23728: NEG
23729: PUSH
23730: LD_INT 1
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: PUSH
23737: LD_INT 3
23739: NEG
23740: PUSH
23741: LD_INT 0
23743: PUSH
23744: EMPTY
23745: LIST
23746: LIST
23747: PUSH
23748: LD_INT 3
23750: NEG
23751: PUSH
23752: LD_INT 1
23754: NEG
23755: PUSH
23756: EMPTY
23757: LIST
23758: LIST
23759: PUSH
23760: EMPTY
23761: LIST
23762: LIST
23763: LIST
23764: LIST
23765: LIST
23766: LIST
23767: LIST
23768: LIST
23769: LIST
23770: LIST
23771: LIST
23772: LIST
23773: LIST
23774: LIST
23775: LIST
23776: LIST
23777: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
23778: LD_ADDR_VAR 0 13
23782: PUSH
23783: LD_INT 0
23785: PUSH
23786: LD_INT 0
23788: PUSH
23789: EMPTY
23790: LIST
23791: LIST
23792: PUSH
23793: LD_INT 0
23795: PUSH
23796: LD_INT 1
23798: NEG
23799: PUSH
23800: EMPTY
23801: LIST
23802: LIST
23803: PUSH
23804: LD_INT 1
23806: PUSH
23807: LD_INT 0
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: PUSH
23814: LD_INT 1
23816: PUSH
23817: LD_INT 1
23819: PUSH
23820: EMPTY
23821: LIST
23822: LIST
23823: PUSH
23824: LD_INT 0
23826: PUSH
23827: LD_INT 1
23829: PUSH
23830: EMPTY
23831: LIST
23832: LIST
23833: PUSH
23834: LD_INT 1
23836: NEG
23837: PUSH
23838: LD_INT 0
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: PUSH
23845: LD_INT 1
23847: NEG
23848: PUSH
23849: LD_INT 1
23851: NEG
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: PUSH
23857: LD_INT 1
23859: NEG
23860: PUSH
23861: LD_INT 2
23863: NEG
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: PUSH
23869: LD_INT 2
23871: PUSH
23872: LD_INT 1
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: PUSH
23879: LD_INT 2
23881: PUSH
23882: LD_INT 2
23884: PUSH
23885: EMPTY
23886: LIST
23887: LIST
23888: PUSH
23889: LD_INT 1
23891: PUSH
23892: LD_INT 2
23894: PUSH
23895: EMPTY
23896: LIST
23897: LIST
23898: PUSH
23899: LD_INT 2
23901: NEG
23902: PUSH
23903: LD_INT 1
23905: NEG
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: PUSH
23911: LD_INT 2
23913: NEG
23914: PUSH
23915: LD_INT 2
23917: NEG
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: PUSH
23923: LD_INT 2
23925: NEG
23926: PUSH
23927: LD_INT 3
23929: NEG
23930: PUSH
23931: EMPTY
23932: LIST
23933: LIST
23934: PUSH
23935: LD_INT 3
23937: NEG
23938: PUSH
23939: LD_INT 2
23941: NEG
23942: PUSH
23943: EMPTY
23944: LIST
23945: LIST
23946: PUSH
23947: LD_INT 3
23949: NEG
23950: PUSH
23951: LD_INT 3
23953: NEG
23954: PUSH
23955: EMPTY
23956: LIST
23957: LIST
23958: PUSH
23959: EMPTY
23960: LIST
23961: LIST
23962: LIST
23963: LIST
23964: LIST
23965: LIST
23966: LIST
23967: LIST
23968: LIST
23969: LIST
23970: LIST
23971: LIST
23972: LIST
23973: LIST
23974: LIST
23975: LIST
23976: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
23977: LD_ADDR_VAR 0 14
23981: PUSH
23982: LD_INT 0
23984: PUSH
23985: LD_INT 0
23987: PUSH
23988: EMPTY
23989: LIST
23990: LIST
23991: PUSH
23992: LD_INT 0
23994: PUSH
23995: LD_INT 1
23997: NEG
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: PUSH
24003: LD_INT 1
24005: PUSH
24006: LD_INT 0
24008: PUSH
24009: EMPTY
24010: LIST
24011: LIST
24012: PUSH
24013: LD_INT 1
24015: PUSH
24016: LD_INT 1
24018: PUSH
24019: EMPTY
24020: LIST
24021: LIST
24022: PUSH
24023: LD_INT 0
24025: PUSH
24026: LD_INT 1
24028: PUSH
24029: EMPTY
24030: LIST
24031: LIST
24032: PUSH
24033: LD_INT 1
24035: NEG
24036: PUSH
24037: LD_INT 0
24039: PUSH
24040: EMPTY
24041: LIST
24042: LIST
24043: PUSH
24044: LD_INT 1
24046: NEG
24047: PUSH
24048: LD_INT 1
24050: NEG
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: PUSH
24056: LD_INT 1
24058: NEG
24059: PUSH
24060: LD_INT 2
24062: NEG
24063: PUSH
24064: EMPTY
24065: LIST
24066: LIST
24067: PUSH
24068: LD_INT 0
24070: PUSH
24071: LD_INT 2
24073: NEG
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: PUSH
24079: LD_INT 1
24081: PUSH
24082: LD_INT 1
24084: NEG
24085: PUSH
24086: EMPTY
24087: LIST
24088: LIST
24089: PUSH
24090: LD_INT 1
24092: PUSH
24093: LD_INT 2
24095: PUSH
24096: EMPTY
24097: LIST
24098: LIST
24099: PUSH
24100: LD_INT 0
24102: PUSH
24103: LD_INT 2
24105: PUSH
24106: EMPTY
24107: LIST
24108: LIST
24109: PUSH
24110: LD_INT 1
24112: NEG
24113: PUSH
24114: LD_INT 1
24116: PUSH
24117: EMPTY
24118: LIST
24119: LIST
24120: PUSH
24121: LD_INT 1
24123: NEG
24124: PUSH
24125: LD_INT 3
24127: NEG
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: PUSH
24133: LD_INT 0
24135: PUSH
24136: LD_INT 3
24138: NEG
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: LD_INT 1
24146: PUSH
24147: LD_INT 2
24149: NEG
24150: PUSH
24151: EMPTY
24152: LIST
24153: LIST
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: LIST
24159: LIST
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: LIST
24165: LIST
24166: LIST
24167: LIST
24168: LIST
24169: LIST
24170: LIST
24171: LIST
24172: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24173: LD_ADDR_VAR 0 15
24177: PUSH
24178: LD_INT 0
24180: PUSH
24181: LD_INT 0
24183: PUSH
24184: EMPTY
24185: LIST
24186: LIST
24187: PUSH
24188: LD_INT 0
24190: PUSH
24191: LD_INT 1
24193: NEG
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: PUSH
24199: LD_INT 1
24201: PUSH
24202: LD_INT 0
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: LD_INT 1
24211: PUSH
24212: LD_INT 1
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: PUSH
24219: LD_INT 0
24221: PUSH
24222: LD_INT 1
24224: PUSH
24225: EMPTY
24226: LIST
24227: LIST
24228: PUSH
24229: LD_INT 1
24231: NEG
24232: PUSH
24233: LD_INT 0
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: PUSH
24240: LD_INT 1
24242: NEG
24243: PUSH
24244: LD_INT 1
24246: NEG
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: PUSH
24252: LD_INT 1
24254: PUSH
24255: LD_INT 1
24257: NEG
24258: PUSH
24259: EMPTY
24260: LIST
24261: LIST
24262: PUSH
24263: LD_INT 2
24265: PUSH
24266: LD_INT 0
24268: PUSH
24269: EMPTY
24270: LIST
24271: LIST
24272: PUSH
24273: LD_INT 2
24275: PUSH
24276: LD_INT 1
24278: PUSH
24279: EMPTY
24280: LIST
24281: LIST
24282: PUSH
24283: LD_INT 1
24285: NEG
24286: PUSH
24287: LD_INT 1
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: PUSH
24294: LD_INT 2
24296: NEG
24297: PUSH
24298: LD_INT 0
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PUSH
24305: LD_INT 2
24307: NEG
24308: PUSH
24309: LD_INT 1
24311: NEG
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: PUSH
24317: LD_INT 2
24319: PUSH
24320: LD_INT 1
24322: NEG
24323: PUSH
24324: EMPTY
24325: LIST
24326: LIST
24327: PUSH
24328: LD_INT 3
24330: PUSH
24331: LD_INT 0
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PUSH
24338: LD_INT 3
24340: PUSH
24341: LD_INT 1
24343: PUSH
24344: EMPTY
24345: LIST
24346: LIST
24347: PUSH
24348: EMPTY
24349: LIST
24350: LIST
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: LIST
24356: LIST
24357: LIST
24358: LIST
24359: LIST
24360: LIST
24361: LIST
24362: LIST
24363: LIST
24364: LIST
24365: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
24366: LD_ADDR_VAR 0 16
24370: PUSH
24371: LD_INT 0
24373: PUSH
24374: LD_INT 0
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: PUSH
24381: LD_INT 0
24383: PUSH
24384: LD_INT 1
24386: NEG
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PUSH
24392: LD_INT 1
24394: PUSH
24395: LD_INT 0
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: PUSH
24402: LD_INT 1
24404: PUSH
24405: LD_INT 1
24407: PUSH
24408: EMPTY
24409: LIST
24410: LIST
24411: PUSH
24412: LD_INT 0
24414: PUSH
24415: LD_INT 1
24417: PUSH
24418: EMPTY
24419: LIST
24420: LIST
24421: PUSH
24422: LD_INT 1
24424: NEG
24425: PUSH
24426: LD_INT 0
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: PUSH
24433: LD_INT 1
24435: NEG
24436: PUSH
24437: LD_INT 1
24439: NEG
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: PUSH
24445: LD_INT 1
24447: NEG
24448: PUSH
24449: LD_INT 2
24451: NEG
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: PUSH
24457: LD_INT 2
24459: PUSH
24460: LD_INT 1
24462: PUSH
24463: EMPTY
24464: LIST
24465: LIST
24466: PUSH
24467: LD_INT 2
24469: PUSH
24470: LD_INT 2
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PUSH
24477: LD_INT 1
24479: PUSH
24480: LD_INT 2
24482: PUSH
24483: EMPTY
24484: LIST
24485: LIST
24486: PUSH
24487: LD_INT 2
24489: NEG
24490: PUSH
24491: LD_INT 1
24493: NEG
24494: PUSH
24495: EMPTY
24496: LIST
24497: LIST
24498: PUSH
24499: LD_INT 2
24501: NEG
24502: PUSH
24503: LD_INT 2
24505: NEG
24506: PUSH
24507: EMPTY
24508: LIST
24509: LIST
24510: PUSH
24511: LD_INT 3
24513: PUSH
24514: LD_INT 2
24516: PUSH
24517: EMPTY
24518: LIST
24519: LIST
24520: PUSH
24521: LD_INT 3
24523: PUSH
24524: LD_INT 3
24526: PUSH
24527: EMPTY
24528: LIST
24529: LIST
24530: PUSH
24531: LD_INT 2
24533: PUSH
24534: LD_INT 3
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: LIST
24545: LIST
24546: LIST
24547: LIST
24548: LIST
24549: LIST
24550: LIST
24551: LIST
24552: LIST
24553: LIST
24554: LIST
24555: LIST
24556: LIST
24557: LIST
24558: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24559: LD_ADDR_VAR 0 17
24563: PUSH
24564: LD_INT 0
24566: PUSH
24567: LD_INT 0
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: LD_INT 0
24576: PUSH
24577: LD_INT 1
24579: NEG
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: PUSH
24585: LD_INT 1
24587: PUSH
24588: LD_INT 0
24590: PUSH
24591: EMPTY
24592: LIST
24593: LIST
24594: PUSH
24595: LD_INT 1
24597: PUSH
24598: LD_INT 1
24600: PUSH
24601: EMPTY
24602: LIST
24603: LIST
24604: PUSH
24605: LD_INT 0
24607: PUSH
24608: LD_INT 1
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PUSH
24615: LD_INT 1
24617: NEG
24618: PUSH
24619: LD_INT 0
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: PUSH
24626: LD_INT 1
24628: NEG
24629: PUSH
24630: LD_INT 1
24632: NEG
24633: PUSH
24634: EMPTY
24635: LIST
24636: LIST
24637: PUSH
24638: LD_INT 1
24640: NEG
24641: PUSH
24642: LD_INT 2
24644: NEG
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PUSH
24650: LD_INT 0
24652: PUSH
24653: LD_INT 2
24655: NEG
24656: PUSH
24657: EMPTY
24658: LIST
24659: LIST
24660: PUSH
24661: LD_INT 1
24663: PUSH
24664: LD_INT 1
24666: NEG
24667: PUSH
24668: EMPTY
24669: LIST
24670: LIST
24671: PUSH
24672: LD_INT 2
24674: PUSH
24675: LD_INT 0
24677: PUSH
24678: EMPTY
24679: LIST
24680: LIST
24681: PUSH
24682: LD_INT 2
24684: PUSH
24685: LD_INT 1
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: PUSH
24692: LD_INT 2
24694: PUSH
24695: LD_INT 2
24697: PUSH
24698: EMPTY
24699: LIST
24700: LIST
24701: PUSH
24702: LD_INT 1
24704: PUSH
24705: LD_INT 2
24707: PUSH
24708: EMPTY
24709: LIST
24710: LIST
24711: PUSH
24712: LD_INT 0
24714: PUSH
24715: LD_INT 2
24717: PUSH
24718: EMPTY
24719: LIST
24720: LIST
24721: PUSH
24722: LD_INT 1
24724: NEG
24725: PUSH
24726: LD_INT 1
24728: PUSH
24729: EMPTY
24730: LIST
24731: LIST
24732: PUSH
24733: LD_INT 2
24735: NEG
24736: PUSH
24737: LD_INT 0
24739: PUSH
24740: EMPTY
24741: LIST
24742: LIST
24743: PUSH
24744: LD_INT 2
24746: NEG
24747: PUSH
24748: LD_INT 1
24750: NEG
24751: PUSH
24752: EMPTY
24753: LIST
24754: LIST
24755: PUSH
24756: LD_INT 2
24758: NEG
24759: PUSH
24760: LD_INT 2
24762: NEG
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: PUSH
24768: EMPTY
24769: LIST
24770: LIST
24771: LIST
24772: LIST
24773: LIST
24774: LIST
24775: LIST
24776: LIST
24777: LIST
24778: LIST
24779: LIST
24780: LIST
24781: LIST
24782: LIST
24783: LIST
24784: LIST
24785: LIST
24786: LIST
24787: LIST
24788: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24789: LD_ADDR_VAR 0 18
24793: PUSH
24794: LD_INT 0
24796: PUSH
24797: LD_INT 0
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: PUSH
24804: LD_INT 0
24806: PUSH
24807: LD_INT 1
24809: NEG
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 1
24817: PUSH
24818: LD_INT 0
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 1
24827: PUSH
24828: LD_INT 1
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: LD_INT 0
24837: PUSH
24838: LD_INT 1
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: PUSH
24845: LD_INT 1
24847: NEG
24848: PUSH
24849: LD_INT 0
24851: PUSH
24852: EMPTY
24853: LIST
24854: LIST
24855: PUSH
24856: LD_INT 1
24858: NEG
24859: PUSH
24860: LD_INT 1
24862: NEG
24863: PUSH
24864: EMPTY
24865: LIST
24866: LIST
24867: PUSH
24868: LD_INT 1
24870: NEG
24871: PUSH
24872: LD_INT 2
24874: NEG
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 0
24882: PUSH
24883: LD_INT 2
24885: NEG
24886: PUSH
24887: EMPTY
24888: LIST
24889: LIST
24890: PUSH
24891: LD_INT 1
24893: PUSH
24894: LD_INT 1
24896: NEG
24897: PUSH
24898: EMPTY
24899: LIST
24900: LIST
24901: PUSH
24902: LD_INT 2
24904: PUSH
24905: LD_INT 0
24907: PUSH
24908: EMPTY
24909: LIST
24910: LIST
24911: PUSH
24912: LD_INT 2
24914: PUSH
24915: LD_INT 1
24917: PUSH
24918: EMPTY
24919: LIST
24920: LIST
24921: PUSH
24922: LD_INT 2
24924: PUSH
24925: LD_INT 2
24927: PUSH
24928: EMPTY
24929: LIST
24930: LIST
24931: PUSH
24932: LD_INT 1
24934: PUSH
24935: LD_INT 2
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PUSH
24942: LD_INT 0
24944: PUSH
24945: LD_INT 2
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PUSH
24952: LD_INT 1
24954: NEG
24955: PUSH
24956: LD_INT 1
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: PUSH
24963: LD_INT 2
24965: NEG
24966: PUSH
24967: LD_INT 0
24969: PUSH
24970: EMPTY
24971: LIST
24972: LIST
24973: PUSH
24974: LD_INT 2
24976: NEG
24977: PUSH
24978: LD_INT 1
24980: NEG
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: PUSH
24986: LD_INT 2
24988: NEG
24989: PUSH
24990: LD_INT 2
24992: NEG
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: LIST
25002: LIST
25003: LIST
25004: LIST
25005: LIST
25006: LIST
25007: LIST
25008: LIST
25009: LIST
25010: LIST
25011: LIST
25012: LIST
25013: LIST
25014: LIST
25015: LIST
25016: LIST
25017: LIST
25018: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25019: LD_ADDR_VAR 0 19
25023: PUSH
25024: LD_INT 0
25026: PUSH
25027: LD_INT 0
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: PUSH
25034: LD_INT 0
25036: PUSH
25037: LD_INT 1
25039: NEG
25040: PUSH
25041: EMPTY
25042: LIST
25043: LIST
25044: PUSH
25045: LD_INT 1
25047: PUSH
25048: LD_INT 0
25050: PUSH
25051: EMPTY
25052: LIST
25053: LIST
25054: PUSH
25055: LD_INT 1
25057: PUSH
25058: LD_INT 1
25060: PUSH
25061: EMPTY
25062: LIST
25063: LIST
25064: PUSH
25065: LD_INT 0
25067: PUSH
25068: LD_INT 1
25070: PUSH
25071: EMPTY
25072: LIST
25073: LIST
25074: PUSH
25075: LD_INT 1
25077: NEG
25078: PUSH
25079: LD_INT 0
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: PUSH
25086: LD_INT 1
25088: NEG
25089: PUSH
25090: LD_INT 1
25092: NEG
25093: PUSH
25094: EMPTY
25095: LIST
25096: LIST
25097: PUSH
25098: LD_INT 1
25100: NEG
25101: PUSH
25102: LD_INT 2
25104: NEG
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: PUSH
25110: LD_INT 0
25112: PUSH
25113: LD_INT 2
25115: NEG
25116: PUSH
25117: EMPTY
25118: LIST
25119: LIST
25120: PUSH
25121: LD_INT 1
25123: PUSH
25124: LD_INT 1
25126: NEG
25127: PUSH
25128: EMPTY
25129: LIST
25130: LIST
25131: PUSH
25132: LD_INT 2
25134: PUSH
25135: LD_INT 0
25137: PUSH
25138: EMPTY
25139: LIST
25140: LIST
25141: PUSH
25142: LD_INT 2
25144: PUSH
25145: LD_INT 1
25147: PUSH
25148: EMPTY
25149: LIST
25150: LIST
25151: PUSH
25152: LD_INT 2
25154: PUSH
25155: LD_INT 2
25157: PUSH
25158: EMPTY
25159: LIST
25160: LIST
25161: PUSH
25162: LD_INT 1
25164: PUSH
25165: LD_INT 2
25167: PUSH
25168: EMPTY
25169: LIST
25170: LIST
25171: PUSH
25172: LD_INT 0
25174: PUSH
25175: LD_INT 2
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 1
25184: NEG
25185: PUSH
25186: LD_INT 1
25188: PUSH
25189: EMPTY
25190: LIST
25191: LIST
25192: PUSH
25193: LD_INT 2
25195: NEG
25196: PUSH
25197: LD_INT 0
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: PUSH
25204: LD_INT 2
25206: NEG
25207: PUSH
25208: LD_INT 1
25210: NEG
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: PUSH
25216: LD_INT 2
25218: NEG
25219: PUSH
25220: LD_INT 2
25222: NEG
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: PUSH
25228: EMPTY
25229: LIST
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25249: LD_ADDR_VAR 0 20
25253: PUSH
25254: LD_INT 0
25256: PUSH
25257: LD_INT 0
25259: PUSH
25260: EMPTY
25261: LIST
25262: LIST
25263: PUSH
25264: LD_INT 0
25266: PUSH
25267: LD_INT 1
25269: NEG
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: PUSH
25275: LD_INT 1
25277: PUSH
25278: LD_INT 0
25280: PUSH
25281: EMPTY
25282: LIST
25283: LIST
25284: PUSH
25285: LD_INT 1
25287: PUSH
25288: LD_INT 1
25290: PUSH
25291: EMPTY
25292: LIST
25293: LIST
25294: PUSH
25295: LD_INT 0
25297: PUSH
25298: LD_INT 1
25300: PUSH
25301: EMPTY
25302: LIST
25303: LIST
25304: PUSH
25305: LD_INT 1
25307: NEG
25308: PUSH
25309: LD_INT 0
25311: PUSH
25312: EMPTY
25313: LIST
25314: LIST
25315: PUSH
25316: LD_INT 1
25318: NEG
25319: PUSH
25320: LD_INT 1
25322: NEG
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: PUSH
25328: LD_INT 1
25330: NEG
25331: PUSH
25332: LD_INT 2
25334: NEG
25335: PUSH
25336: EMPTY
25337: LIST
25338: LIST
25339: PUSH
25340: LD_INT 0
25342: PUSH
25343: LD_INT 2
25345: NEG
25346: PUSH
25347: EMPTY
25348: LIST
25349: LIST
25350: PUSH
25351: LD_INT 1
25353: PUSH
25354: LD_INT 1
25356: NEG
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: LD_INT 2
25364: PUSH
25365: LD_INT 0
25367: PUSH
25368: EMPTY
25369: LIST
25370: LIST
25371: PUSH
25372: LD_INT 2
25374: PUSH
25375: LD_INT 1
25377: PUSH
25378: EMPTY
25379: LIST
25380: LIST
25381: PUSH
25382: LD_INT 2
25384: PUSH
25385: LD_INT 2
25387: PUSH
25388: EMPTY
25389: LIST
25390: LIST
25391: PUSH
25392: LD_INT 1
25394: PUSH
25395: LD_INT 2
25397: PUSH
25398: EMPTY
25399: LIST
25400: LIST
25401: PUSH
25402: LD_INT 0
25404: PUSH
25405: LD_INT 2
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 1
25414: NEG
25415: PUSH
25416: LD_INT 1
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PUSH
25423: LD_INT 2
25425: NEG
25426: PUSH
25427: LD_INT 0
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: PUSH
25434: LD_INT 2
25436: NEG
25437: PUSH
25438: LD_INT 1
25440: NEG
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: PUSH
25446: LD_INT 2
25448: NEG
25449: PUSH
25450: LD_INT 2
25452: NEG
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: EMPTY
25459: LIST
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: LIST
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: LIST
25476: LIST
25477: LIST
25478: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25479: LD_ADDR_VAR 0 21
25483: PUSH
25484: LD_INT 0
25486: PUSH
25487: LD_INT 0
25489: PUSH
25490: EMPTY
25491: LIST
25492: LIST
25493: PUSH
25494: LD_INT 0
25496: PUSH
25497: LD_INT 1
25499: NEG
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PUSH
25505: LD_INT 1
25507: PUSH
25508: LD_INT 0
25510: PUSH
25511: EMPTY
25512: LIST
25513: LIST
25514: PUSH
25515: LD_INT 1
25517: PUSH
25518: LD_INT 1
25520: PUSH
25521: EMPTY
25522: LIST
25523: LIST
25524: PUSH
25525: LD_INT 0
25527: PUSH
25528: LD_INT 1
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: PUSH
25535: LD_INT 1
25537: NEG
25538: PUSH
25539: LD_INT 0
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 1
25548: NEG
25549: PUSH
25550: LD_INT 1
25552: NEG
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: PUSH
25558: LD_INT 1
25560: NEG
25561: PUSH
25562: LD_INT 2
25564: NEG
25565: PUSH
25566: EMPTY
25567: LIST
25568: LIST
25569: PUSH
25570: LD_INT 0
25572: PUSH
25573: LD_INT 2
25575: NEG
25576: PUSH
25577: EMPTY
25578: LIST
25579: LIST
25580: PUSH
25581: LD_INT 1
25583: PUSH
25584: LD_INT 1
25586: NEG
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: PUSH
25592: LD_INT 2
25594: PUSH
25595: LD_INT 0
25597: PUSH
25598: EMPTY
25599: LIST
25600: LIST
25601: PUSH
25602: LD_INT 2
25604: PUSH
25605: LD_INT 1
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: PUSH
25612: LD_INT 2
25614: PUSH
25615: LD_INT 2
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PUSH
25622: LD_INT 1
25624: PUSH
25625: LD_INT 2
25627: PUSH
25628: EMPTY
25629: LIST
25630: LIST
25631: PUSH
25632: LD_INT 0
25634: PUSH
25635: LD_INT 2
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 1
25644: NEG
25645: PUSH
25646: LD_INT 1
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 2
25655: NEG
25656: PUSH
25657: LD_INT 0
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 2
25666: NEG
25667: PUSH
25668: LD_INT 1
25670: NEG
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: LD_INT 2
25678: NEG
25679: PUSH
25680: LD_INT 2
25682: NEG
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: EMPTY
25689: LIST
25690: LIST
25691: LIST
25692: LIST
25693: LIST
25694: LIST
25695: LIST
25696: LIST
25697: LIST
25698: LIST
25699: LIST
25700: LIST
25701: LIST
25702: LIST
25703: LIST
25704: LIST
25705: LIST
25706: LIST
25707: LIST
25708: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25709: LD_ADDR_VAR 0 22
25713: PUSH
25714: LD_INT 0
25716: PUSH
25717: LD_INT 0
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: PUSH
25724: LD_INT 0
25726: PUSH
25727: LD_INT 1
25729: NEG
25730: PUSH
25731: EMPTY
25732: LIST
25733: LIST
25734: PUSH
25735: LD_INT 1
25737: PUSH
25738: LD_INT 0
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: PUSH
25745: LD_INT 1
25747: PUSH
25748: LD_INT 1
25750: PUSH
25751: EMPTY
25752: LIST
25753: LIST
25754: PUSH
25755: LD_INT 0
25757: PUSH
25758: LD_INT 1
25760: PUSH
25761: EMPTY
25762: LIST
25763: LIST
25764: PUSH
25765: LD_INT 1
25767: NEG
25768: PUSH
25769: LD_INT 0
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: LD_INT 1
25778: NEG
25779: PUSH
25780: LD_INT 1
25782: NEG
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: PUSH
25788: LD_INT 1
25790: NEG
25791: PUSH
25792: LD_INT 2
25794: NEG
25795: PUSH
25796: EMPTY
25797: LIST
25798: LIST
25799: PUSH
25800: LD_INT 0
25802: PUSH
25803: LD_INT 2
25805: NEG
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: PUSH
25811: LD_INT 1
25813: PUSH
25814: LD_INT 1
25816: NEG
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: LD_INT 2
25824: PUSH
25825: LD_INT 0
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PUSH
25832: LD_INT 2
25834: PUSH
25835: LD_INT 1
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: PUSH
25842: LD_INT 2
25844: PUSH
25845: LD_INT 2
25847: PUSH
25848: EMPTY
25849: LIST
25850: LIST
25851: PUSH
25852: LD_INT 1
25854: PUSH
25855: LD_INT 2
25857: PUSH
25858: EMPTY
25859: LIST
25860: LIST
25861: PUSH
25862: LD_INT 0
25864: PUSH
25865: LD_INT 2
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: PUSH
25872: LD_INT 1
25874: NEG
25875: PUSH
25876: LD_INT 1
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 2
25885: NEG
25886: PUSH
25887: LD_INT 0
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: LD_INT 2
25896: NEG
25897: PUSH
25898: LD_INT 1
25900: NEG
25901: PUSH
25902: EMPTY
25903: LIST
25904: LIST
25905: PUSH
25906: LD_INT 2
25908: NEG
25909: PUSH
25910: LD_INT 2
25912: NEG
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PUSH
25918: EMPTY
25919: LIST
25920: LIST
25921: LIST
25922: LIST
25923: LIST
25924: LIST
25925: LIST
25926: LIST
25927: LIST
25928: LIST
25929: LIST
25930: LIST
25931: LIST
25932: LIST
25933: LIST
25934: LIST
25935: LIST
25936: LIST
25937: LIST
25938: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
25939: LD_ADDR_VAR 0 23
25943: PUSH
25944: LD_INT 0
25946: PUSH
25947: LD_INT 0
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: PUSH
25954: LD_INT 0
25956: PUSH
25957: LD_INT 1
25959: NEG
25960: PUSH
25961: EMPTY
25962: LIST
25963: LIST
25964: PUSH
25965: LD_INT 1
25967: PUSH
25968: LD_INT 0
25970: PUSH
25971: EMPTY
25972: LIST
25973: LIST
25974: PUSH
25975: LD_INT 1
25977: PUSH
25978: LD_INT 1
25980: PUSH
25981: EMPTY
25982: LIST
25983: LIST
25984: PUSH
25985: LD_INT 0
25987: PUSH
25988: LD_INT 1
25990: PUSH
25991: EMPTY
25992: LIST
25993: LIST
25994: PUSH
25995: LD_INT 1
25997: NEG
25998: PUSH
25999: LD_INT 0
26001: PUSH
26002: EMPTY
26003: LIST
26004: LIST
26005: PUSH
26006: LD_INT 1
26008: NEG
26009: PUSH
26010: LD_INT 1
26012: NEG
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: PUSH
26018: LD_INT 1
26020: NEG
26021: PUSH
26022: LD_INT 2
26024: NEG
26025: PUSH
26026: EMPTY
26027: LIST
26028: LIST
26029: PUSH
26030: LD_INT 0
26032: PUSH
26033: LD_INT 2
26035: NEG
26036: PUSH
26037: EMPTY
26038: LIST
26039: LIST
26040: PUSH
26041: LD_INT 1
26043: PUSH
26044: LD_INT 1
26046: NEG
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: PUSH
26052: LD_INT 2
26054: PUSH
26055: LD_INT 0
26057: PUSH
26058: EMPTY
26059: LIST
26060: LIST
26061: PUSH
26062: LD_INT 2
26064: PUSH
26065: LD_INT 1
26067: PUSH
26068: EMPTY
26069: LIST
26070: LIST
26071: PUSH
26072: LD_INT 2
26074: PUSH
26075: LD_INT 2
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: PUSH
26082: LD_INT 1
26084: PUSH
26085: LD_INT 2
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 0
26094: PUSH
26095: LD_INT 2
26097: PUSH
26098: EMPTY
26099: LIST
26100: LIST
26101: PUSH
26102: LD_INT 1
26104: NEG
26105: PUSH
26106: LD_INT 1
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 2
26115: NEG
26116: PUSH
26117: LD_INT 0
26119: PUSH
26120: EMPTY
26121: LIST
26122: LIST
26123: PUSH
26124: LD_INT 2
26126: NEG
26127: PUSH
26128: LD_INT 1
26130: NEG
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 2
26138: NEG
26139: PUSH
26140: LD_INT 2
26142: NEG
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: LD_INT 2
26150: NEG
26151: PUSH
26152: LD_INT 3
26154: NEG
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PUSH
26160: LD_INT 1
26162: NEG
26163: PUSH
26164: LD_INT 3
26166: NEG
26167: PUSH
26168: EMPTY
26169: LIST
26170: LIST
26171: PUSH
26172: LD_INT 1
26174: PUSH
26175: LD_INT 2
26177: NEG
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 2
26185: PUSH
26186: LD_INT 1
26188: NEG
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: LIST
26198: LIST
26199: LIST
26200: LIST
26201: LIST
26202: LIST
26203: LIST
26204: LIST
26205: LIST
26206: LIST
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: LIST
26216: LIST
26217: LIST
26218: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26219: LD_ADDR_VAR 0 24
26223: PUSH
26224: LD_INT 0
26226: PUSH
26227: LD_INT 0
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 0
26236: PUSH
26237: LD_INT 1
26239: NEG
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: LD_INT 1
26247: PUSH
26248: LD_INT 0
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: LD_INT 1
26257: PUSH
26258: LD_INT 1
26260: PUSH
26261: EMPTY
26262: LIST
26263: LIST
26264: PUSH
26265: LD_INT 0
26267: PUSH
26268: LD_INT 1
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: LD_INT 1
26277: NEG
26278: PUSH
26279: LD_INT 0
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: LD_INT 1
26288: NEG
26289: PUSH
26290: LD_INT 1
26292: NEG
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: PUSH
26298: LD_INT 1
26300: NEG
26301: PUSH
26302: LD_INT 2
26304: NEG
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: PUSH
26310: LD_INT 0
26312: PUSH
26313: LD_INT 2
26315: NEG
26316: PUSH
26317: EMPTY
26318: LIST
26319: LIST
26320: PUSH
26321: LD_INT 1
26323: PUSH
26324: LD_INT 1
26326: NEG
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 2
26334: PUSH
26335: LD_INT 0
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: LD_INT 2
26344: PUSH
26345: LD_INT 1
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: LD_INT 2
26354: PUSH
26355: LD_INT 2
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: PUSH
26362: LD_INT 1
26364: PUSH
26365: LD_INT 2
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: PUSH
26372: LD_INT 0
26374: PUSH
26375: LD_INT 2
26377: PUSH
26378: EMPTY
26379: LIST
26380: LIST
26381: PUSH
26382: LD_INT 1
26384: NEG
26385: PUSH
26386: LD_INT 1
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PUSH
26393: LD_INT 2
26395: NEG
26396: PUSH
26397: LD_INT 0
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: PUSH
26404: LD_INT 2
26406: NEG
26407: PUSH
26408: LD_INT 1
26410: NEG
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: LD_INT 2
26418: NEG
26419: PUSH
26420: LD_INT 2
26422: NEG
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 1
26430: PUSH
26431: LD_INT 2
26433: NEG
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: PUSH
26439: LD_INT 2
26441: PUSH
26442: LD_INT 1
26444: NEG
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 3
26452: PUSH
26453: LD_INT 1
26455: PUSH
26456: EMPTY
26457: LIST
26458: LIST
26459: PUSH
26460: LD_INT 3
26462: PUSH
26463: LD_INT 2
26465: PUSH
26466: EMPTY
26467: LIST
26468: LIST
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: LIST
26474: LIST
26475: LIST
26476: LIST
26477: LIST
26478: LIST
26479: LIST
26480: LIST
26481: LIST
26482: LIST
26483: LIST
26484: LIST
26485: LIST
26486: LIST
26487: LIST
26488: LIST
26489: LIST
26490: LIST
26491: LIST
26492: LIST
26493: LIST
26494: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
26495: LD_ADDR_VAR 0 25
26499: PUSH
26500: LD_INT 0
26502: PUSH
26503: LD_INT 0
26505: PUSH
26506: EMPTY
26507: LIST
26508: LIST
26509: PUSH
26510: LD_INT 0
26512: PUSH
26513: LD_INT 1
26515: NEG
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: PUSH
26521: LD_INT 1
26523: PUSH
26524: LD_INT 0
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 1
26533: PUSH
26534: LD_INT 1
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 0
26543: PUSH
26544: LD_INT 1
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PUSH
26551: LD_INT 1
26553: NEG
26554: PUSH
26555: LD_INT 0
26557: PUSH
26558: EMPTY
26559: LIST
26560: LIST
26561: PUSH
26562: LD_INT 1
26564: NEG
26565: PUSH
26566: LD_INT 1
26568: NEG
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: LD_INT 1
26576: NEG
26577: PUSH
26578: LD_INT 2
26580: NEG
26581: PUSH
26582: EMPTY
26583: LIST
26584: LIST
26585: PUSH
26586: LD_INT 0
26588: PUSH
26589: LD_INT 2
26591: NEG
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: PUSH
26597: LD_INT 1
26599: PUSH
26600: LD_INT 1
26602: NEG
26603: PUSH
26604: EMPTY
26605: LIST
26606: LIST
26607: PUSH
26608: LD_INT 2
26610: PUSH
26611: LD_INT 0
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PUSH
26618: LD_INT 2
26620: PUSH
26621: LD_INT 1
26623: PUSH
26624: EMPTY
26625: LIST
26626: LIST
26627: PUSH
26628: LD_INT 2
26630: PUSH
26631: LD_INT 2
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: LD_INT 1
26640: PUSH
26641: LD_INT 2
26643: PUSH
26644: EMPTY
26645: LIST
26646: LIST
26647: PUSH
26648: LD_INT 0
26650: PUSH
26651: LD_INT 2
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: LD_INT 1
26660: NEG
26661: PUSH
26662: LD_INT 1
26664: PUSH
26665: EMPTY
26666: LIST
26667: LIST
26668: PUSH
26669: LD_INT 2
26671: NEG
26672: PUSH
26673: LD_INT 0
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: PUSH
26680: LD_INT 2
26682: NEG
26683: PUSH
26684: LD_INT 1
26686: NEG
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: PUSH
26692: LD_INT 2
26694: NEG
26695: PUSH
26696: LD_INT 2
26698: NEG
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: PUSH
26704: LD_INT 3
26706: PUSH
26707: LD_INT 1
26709: PUSH
26710: EMPTY
26711: LIST
26712: LIST
26713: PUSH
26714: LD_INT 3
26716: PUSH
26717: LD_INT 2
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: PUSH
26724: LD_INT 2
26726: PUSH
26727: LD_INT 3
26729: PUSH
26730: EMPTY
26731: LIST
26732: LIST
26733: PUSH
26734: LD_INT 1
26736: PUSH
26737: LD_INT 3
26739: PUSH
26740: EMPTY
26741: LIST
26742: LIST
26743: PUSH
26744: EMPTY
26745: LIST
26746: LIST
26747: LIST
26748: LIST
26749: LIST
26750: LIST
26751: LIST
26752: LIST
26753: LIST
26754: LIST
26755: LIST
26756: LIST
26757: LIST
26758: LIST
26759: LIST
26760: LIST
26761: LIST
26762: LIST
26763: LIST
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
26769: LD_ADDR_VAR 0 26
26773: PUSH
26774: LD_INT 0
26776: PUSH
26777: LD_INT 0
26779: PUSH
26780: EMPTY
26781: LIST
26782: LIST
26783: PUSH
26784: LD_INT 0
26786: PUSH
26787: LD_INT 1
26789: NEG
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: PUSH
26795: LD_INT 1
26797: PUSH
26798: LD_INT 0
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 1
26807: PUSH
26808: LD_INT 1
26810: PUSH
26811: EMPTY
26812: LIST
26813: LIST
26814: PUSH
26815: LD_INT 0
26817: PUSH
26818: LD_INT 1
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: PUSH
26825: LD_INT 1
26827: NEG
26828: PUSH
26829: LD_INT 0
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 1
26838: NEG
26839: PUSH
26840: LD_INT 1
26842: NEG
26843: PUSH
26844: EMPTY
26845: LIST
26846: LIST
26847: PUSH
26848: LD_INT 1
26850: NEG
26851: PUSH
26852: LD_INT 2
26854: NEG
26855: PUSH
26856: EMPTY
26857: LIST
26858: LIST
26859: PUSH
26860: LD_INT 0
26862: PUSH
26863: LD_INT 2
26865: NEG
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 1
26873: PUSH
26874: LD_INT 1
26876: NEG
26877: PUSH
26878: EMPTY
26879: LIST
26880: LIST
26881: PUSH
26882: LD_INT 2
26884: PUSH
26885: LD_INT 0
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: PUSH
26892: LD_INT 2
26894: PUSH
26895: LD_INT 1
26897: PUSH
26898: EMPTY
26899: LIST
26900: LIST
26901: PUSH
26902: LD_INT 2
26904: PUSH
26905: LD_INT 2
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 1
26914: PUSH
26915: LD_INT 2
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: PUSH
26922: LD_INT 0
26924: PUSH
26925: LD_INT 2
26927: PUSH
26928: EMPTY
26929: LIST
26930: LIST
26931: PUSH
26932: LD_INT 1
26934: NEG
26935: PUSH
26936: LD_INT 1
26938: PUSH
26939: EMPTY
26940: LIST
26941: LIST
26942: PUSH
26943: LD_INT 2
26945: NEG
26946: PUSH
26947: LD_INT 0
26949: PUSH
26950: EMPTY
26951: LIST
26952: LIST
26953: PUSH
26954: LD_INT 2
26956: NEG
26957: PUSH
26958: LD_INT 1
26960: NEG
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: LD_INT 2
26968: NEG
26969: PUSH
26970: LD_INT 2
26972: NEG
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: PUSH
26978: LD_INT 2
26980: PUSH
26981: LD_INT 3
26983: PUSH
26984: EMPTY
26985: LIST
26986: LIST
26987: PUSH
26988: LD_INT 1
26990: PUSH
26991: LD_INT 3
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: LD_INT 1
27000: NEG
27001: PUSH
27002: LD_INT 2
27004: PUSH
27005: EMPTY
27006: LIST
27007: LIST
27008: PUSH
27009: LD_INT 2
27011: NEG
27012: PUSH
27013: LD_INT 1
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: LIST
27026: LIST
27027: LIST
27028: LIST
27029: LIST
27030: LIST
27031: LIST
27032: LIST
27033: LIST
27034: LIST
27035: LIST
27036: LIST
27037: LIST
27038: LIST
27039: LIST
27040: LIST
27041: LIST
27042: LIST
27043: LIST
27044: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27045: LD_ADDR_VAR 0 27
27049: PUSH
27050: LD_INT 0
27052: PUSH
27053: LD_INT 0
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: LD_INT 0
27062: PUSH
27063: LD_INT 1
27065: NEG
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: LD_INT 1
27073: PUSH
27074: LD_INT 0
27076: PUSH
27077: EMPTY
27078: LIST
27079: LIST
27080: PUSH
27081: LD_INT 1
27083: PUSH
27084: LD_INT 1
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: PUSH
27091: LD_INT 0
27093: PUSH
27094: LD_INT 1
27096: PUSH
27097: EMPTY
27098: LIST
27099: LIST
27100: PUSH
27101: LD_INT 1
27103: NEG
27104: PUSH
27105: LD_INT 0
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: PUSH
27112: LD_INT 1
27114: NEG
27115: PUSH
27116: LD_INT 1
27118: NEG
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PUSH
27124: LD_INT 1
27126: NEG
27127: PUSH
27128: LD_INT 2
27130: NEG
27131: PUSH
27132: EMPTY
27133: LIST
27134: LIST
27135: PUSH
27136: LD_INT 0
27138: PUSH
27139: LD_INT 2
27141: NEG
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PUSH
27147: LD_INT 1
27149: PUSH
27150: LD_INT 1
27152: NEG
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 2
27160: PUSH
27161: LD_INT 0
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 2
27170: PUSH
27171: LD_INT 1
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PUSH
27178: LD_INT 2
27180: PUSH
27181: LD_INT 2
27183: PUSH
27184: EMPTY
27185: LIST
27186: LIST
27187: PUSH
27188: LD_INT 1
27190: PUSH
27191: LD_INT 2
27193: PUSH
27194: EMPTY
27195: LIST
27196: LIST
27197: PUSH
27198: LD_INT 0
27200: PUSH
27201: LD_INT 2
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PUSH
27208: LD_INT 1
27210: NEG
27211: PUSH
27212: LD_INT 1
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: PUSH
27219: LD_INT 2
27221: NEG
27222: PUSH
27223: LD_INT 0
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PUSH
27230: LD_INT 2
27232: NEG
27233: PUSH
27234: LD_INT 1
27236: NEG
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: LD_INT 2
27244: NEG
27245: PUSH
27246: LD_INT 2
27248: NEG
27249: PUSH
27250: EMPTY
27251: LIST
27252: LIST
27253: PUSH
27254: LD_INT 1
27256: NEG
27257: PUSH
27258: LD_INT 2
27260: PUSH
27261: EMPTY
27262: LIST
27263: LIST
27264: PUSH
27265: LD_INT 2
27267: NEG
27268: PUSH
27269: LD_INT 1
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: LD_INT 3
27278: NEG
27279: PUSH
27280: LD_INT 1
27282: NEG
27283: PUSH
27284: EMPTY
27285: LIST
27286: LIST
27287: PUSH
27288: LD_INT 3
27290: NEG
27291: PUSH
27292: LD_INT 2
27294: NEG
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: PUSH
27300: EMPTY
27301: LIST
27302: LIST
27303: LIST
27304: LIST
27305: LIST
27306: LIST
27307: LIST
27308: LIST
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: LIST
27324: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27325: LD_ADDR_VAR 0 28
27329: PUSH
27330: LD_INT 0
27332: PUSH
27333: LD_INT 0
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: LD_INT 0
27342: PUSH
27343: LD_INT 1
27345: NEG
27346: PUSH
27347: EMPTY
27348: LIST
27349: LIST
27350: PUSH
27351: LD_INT 1
27353: PUSH
27354: LD_INT 0
27356: PUSH
27357: EMPTY
27358: LIST
27359: LIST
27360: PUSH
27361: LD_INT 1
27363: PUSH
27364: LD_INT 1
27366: PUSH
27367: EMPTY
27368: LIST
27369: LIST
27370: PUSH
27371: LD_INT 0
27373: PUSH
27374: LD_INT 1
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: PUSH
27381: LD_INT 1
27383: NEG
27384: PUSH
27385: LD_INT 0
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: PUSH
27392: LD_INT 1
27394: NEG
27395: PUSH
27396: LD_INT 1
27398: NEG
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: PUSH
27404: LD_INT 1
27406: NEG
27407: PUSH
27408: LD_INT 2
27410: NEG
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: PUSH
27416: LD_INT 0
27418: PUSH
27419: LD_INT 2
27421: NEG
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: PUSH
27427: LD_INT 1
27429: PUSH
27430: LD_INT 1
27432: NEG
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: PUSH
27438: LD_INT 2
27440: PUSH
27441: LD_INT 0
27443: PUSH
27444: EMPTY
27445: LIST
27446: LIST
27447: PUSH
27448: LD_INT 2
27450: PUSH
27451: LD_INT 1
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PUSH
27458: LD_INT 2
27460: PUSH
27461: LD_INT 2
27463: PUSH
27464: EMPTY
27465: LIST
27466: LIST
27467: PUSH
27468: LD_INT 1
27470: PUSH
27471: LD_INT 2
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: PUSH
27478: LD_INT 0
27480: PUSH
27481: LD_INT 2
27483: PUSH
27484: EMPTY
27485: LIST
27486: LIST
27487: PUSH
27488: LD_INT 1
27490: NEG
27491: PUSH
27492: LD_INT 1
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: PUSH
27499: LD_INT 2
27501: NEG
27502: PUSH
27503: LD_INT 0
27505: PUSH
27506: EMPTY
27507: LIST
27508: LIST
27509: PUSH
27510: LD_INT 2
27512: NEG
27513: PUSH
27514: LD_INT 1
27516: NEG
27517: PUSH
27518: EMPTY
27519: LIST
27520: LIST
27521: PUSH
27522: LD_INT 2
27524: NEG
27525: PUSH
27526: LD_INT 2
27528: NEG
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 2
27536: NEG
27537: PUSH
27538: LD_INT 3
27540: NEG
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PUSH
27546: LD_INT 1
27548: NEG
27549: PUSH
27550: LD_INT 3
27552: NEG
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: LD_INT 3
27560: NEG
27561: PUSH
27562: LD_INT 1
27564: NEG
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: PUSH
27570: LD_INT 3
27572: NEG
27573: PUSH
27574: LD_INT 2
27576: NEG
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: LIST
27600: LIST
27601: LIST
27602: LIST
27603: LIST
27604: LIST
27605: LIST
27606: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27607: LD_ADDR_VAR 0 29
27611: PUSH
27612: LD_INT 0
27614: PUSH
27615: LD_INT 0
27617: PUSH
27618: EMPTY
27619: LIST
27620: LIST
27621: PUSH
27622: LD_INT 0
27624: PUSH
27625: LD_INT 1
27627: NEG
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 1
27635: PUSH
27636: LD_INT 0
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: LD_INT 1
27645: PUSH
27646: LD_INT 1
27648: PUSH
27649: EMPTY
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 0
27655: PUSH
27656: LD_INT 1
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: LD_INT 1
27665: NEG
27666: PUSH
27667: LD_INT 0
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PUSH
27674: LD_INT 1
27676: NEG
27677: PUSH
27678: LD_INT 1
27680: NEG
27681: PUSH
27682: EMPTY
27683: LIST
27684: LIST
27685: PUSH
27686: LD_INT 1
27688: NEG
27689: PUSH
27690: LD_INT 2
27692: NEG
27693: PUSH
27694: EMPTY
27695: LIST
27696: LIST
27697: PUSH
27698: LD_INT 0
27700: PUSH
27701: LD_INT 2
27703: NEG
27704: PUSH
27705: EMPTY
27706: LIST
27707: LIST
27708: PUSH
27709: LD_INT 1
27711: PUSH
27712: LD_INT 1
27714: NEG
27715: PUSH
27716: EMPTY
27717: LIST
27718: LIST
27719: PUSH
27720: LD_INT 2
27722: PUSH
27723: LD_INT 0
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: PUSH
27730: LD_INT 2
27732: PUSH
27733: LD_INT 1
27735: PUSH
27736: EMPTY
27737: LIST
27738: LIST
27739: PUSH
27740: LD_INT 1
27742: PUSH
27743: LD_INT 2
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: PUSH
27750: LD_INT 0
27752: PUSH
27753: LD_INT 2
27755: PUSH
27756: EMPTY
27757: LIST
27758: LIST
27759: PUSH
27760: LD_INT 1
27762: NEG
27763: PUSH
27764: LD_INT 1
27766: PUSH
27767: EMPTY
27768: LIST
27769: LIST
27770: PUSH
27771: LD_INT 2
27773: NEG
27774: PUSH
27775: LD_INT 1
27777: NEG
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 2
27785: NEG
27786: PUSH
27787: LD_INT 2
27789: NEG
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PUSH
27795: LD_INT 2
27797: NEG
27798: PUSH
27799: LD_INT 3
27801: NEG
27802: PUSH
27803: EMPTY
27804: LIST
27805: LIST
27806: PUSH
27807: LD_INT 2
27809: PUSH
27810: LD_INT 1
27812: NEG
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: LD_INT 3
27820: PUSH
27821: LD_INT 1
27823: PUSH
27824: EMPTY
27825: LIST
27826: LIST
27827: PUSH
27828: LD_INT 1
27830: PUSH
27831: LD_INT 3
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 1
27840: NEG
27841: PUSH
27842: LD_INT 2
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: PUSH
27849: LD_INT 3
27851: NEG
27852: PUSH
27853: LD_INT 2
27855: NEG
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: LIST
27865: LIST
27866: LIST
27867: LIST
27868: LIST
27869: LIST
27870: LIST
27871: LIST
27872: LIST
27873: LIST
27874: LIST
27875: LIST
27876: LIST
27877: LIST
27878: LIST
27879: LIST
27880: LIST
27881: LIST
27882: LIST
27883: LIST
27884: LIST
27885: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
27886: LD_ADDR_VAR 0 30
27890: PUSH
27891: LD_INT 0
27893: PUSH
27894: LD_INT 0
27896: PUSH
27897: EMPTY
27898: LIST
27899: LIST
27900: PUSH
27901: LD_INT 0
27903: PUSH
27904: LD_INT 1
27906: NEG
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 1
27914: PUSH
27915: LD_INT 0
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: LD_INT 1
27924: PUSH
27925: LD_INT 1
27927: PUSH
27928: EMPTY
27929: LIST
27930: LIST
27931: PUSH
27932: LD_INT 0
27934: PUSH
27935: LD_INT 1
27937: PUSH
27938: EMPTY
27939: LIST
27940: LIST
27941: PUSH
27942: LD_INT 1
27944: NEG
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: EMPTY
27950: LIST
27951: LIST
27952: PUSH
27953: LD_INT 1
27955: NEG
27956: PUSH
27957: LD_INT 1
27959: NEG
27960: PUSH
27961: EMPTY
27962: LIST
27963: LIST
27964: PUSH
27965: LD_INT 1
27967: NEG
27968: PUSH
27969: LD_INT 2
27971: NEG
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: LD_INT 2
27982: NEG
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: PUSH
27988: LD_INT 1
27990: PUSH
27991: LD_INT 1
27993: NEG
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: PUSH
27999: LD_INT 2
28001: PUSH
28002: LD_INT 0
28004: PUSH
28005: EMPTY
28006: LIST
28007: LIST
28008: PUSH
28009: LD_INT 2
28011: PUSH
28012: LD_INT 1
28014: PUSH
28015: EMPTY
28016: LIST
28017: LIST
28018: PUSH
28019: LD_INT 2
28021: PUSH
28022: LD_INT 2
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: LD_INT 1
28031: PUSH
28032: LD_INT 2
28034: PUSH
28035: EMPTY
28036: LIST
28037: LIST
28038: PUSH
28039: LD_INT 1
28041: NEG
28042: PUSH
28043: LD_INT 1
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PUSH
28050: LD_INT 2
28052: NEG
28053: PUSH
28054: LD_INT 0
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: LD_INT 2
28063: NEG
28064: PUSH
28065: LD_INT 1
28067: NEG
28068: PUSH
28069: EMPTY
28070: LIST
28071: LIST
28072: PUSH
28073: LD_INT 1
28075: NEG
28076: PUSH
28077: LD_INT 3
28079: NEG
28080: PUSH
28081: EMPTY
28082: LIST
28083: LIST
28084: PUSH
28085: LD_INT 1
28087: PUSH
28088: LD_INT 2
28090: NEG
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: LD_INT 3
28098: PUSH
28099: LD_INT 2
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: LD_INT 2
28108: PUSH
28109: LD_INT 3
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 2
28118: NEG
28119: PUSH
28120: LD_INT 1
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: LD_INT 3
28129: NEG
28130: PUSH
28131: LD_INT 1
28133: NEG
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: EMPTY
28140: LIST
28141: LIST
28142: LIST
28143: LIST
28144: LIST
28145: LIST
28146: LIST
28147: LIST
28148: LIST
28149: LIST
28150: LIST
28151: LIST
28152: LIST
28153: LIST
28154: LIST
28155: LIST
28156: LIST
28157: LIST
28158: LIST
28159: LIST
28160: LIST
28161: LIST
28162: LIST
28163: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28164: LD_ADDR_VAR 0 31
28168: PUSH
28169: LD_INT 0
28171: PUSH
28172: LD_INT 0
28174: PUSH
28175: EMPTY
28176: LIST
28177: LIST
28178: PUSH
28179: LD_INT 0
28181: PUSH
28182: LD_INT 1
28184: NEG
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: PUSH
28190: LD_INT 1
28192: PUSH
28193: LD_INT 0
28195: PUSH
28196: EMPTY
28197: LIST
28198: LIST
28199: PUSH
28200: LD_INT 1
28202: PUSH
28203: LD_INT 1
28205: PUSH
28206: EMPTY
28207: LIST
28208: LIST
28209: PUSH
28210: LD_INT 0
28212: PUSH
28213: LD_INT 1
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: PUSH
28220: LD_INT 1
28222: NEG
28223: PUSH
28224: LD_INT 0
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: LD_INT 1
28233: NEG
28234: PUSH
28235: LD_INT 1
28237: NEG
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: PUSH
28243: LD_INT 1
28245: NEG
28246: PUSH
28247: LD_INT 2
28249: NEG
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: PUSH
28255: LD_INT 1
28257: PUSH
28258: LD_INT 1
28260: NEG
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 2
28268: PUSH
28269: LD_INT 0
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 2
28278: PUSH
28279: LD_INT 1
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 2
28288: PUSH
28289: LD_INT 2
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: PUSH
28296: LD_INT 1
28298: PUSH
28299: LD_INT 2
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 0
28308: PUSH
28309: LD_INT 2
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: LD_INT 1
28318: NEG
28319: PUSH
28320: LD_INT 1
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PUSH
28327: LD_INT 2
28329: NEG
28330: PUSH
28331: LD_INT 1
28333: NEG
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: LD_INT 2
28341: NEG
28342: PUSH
28343: LD_INT 2
28345: NEG
28346: PUSH
28347: EMPTY
28348: LIST
28349: LIST
28350: PUSH
28351: LD_INT 2
28353: NEG
28354: PUSH
28355: LD_INT 3
28357: NEG
28358: PUSH
28359: EMPTY
28360: LIST
28361: LIST
28362: PUSH
28363: LD_INT 2
28365: PUSH
28366: LD_INT 1
28368: NEG
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: LD_INT 3
28376: PUSH
28377: LD_INT 1
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: PUSH
28384: LD_INT 1
28386: PUSH
28387: LD_INT 3
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 1
28396: NEG
28397: PUSH
28398: LD_INT 2
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PUSH
28405: LD_INT 3
28407: NEG
28408: PUSH
28409: LD_INT 2
28411: NEG
28412: PUSH
28413: EMPTY
28414: LIST
28415: LIST
28416: PUSH
28417: EMPTY
28418: LIST
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: LIST
28435: LIST
28436: LIST
28437: LIST
28438: LIST
28439: LIST
28440: LIST
28441: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28442: LD_ADDR_VAR 0 32
28446: PUSH
28447: LD_INT 0
28449: PUSH
28450: LD_INT 0
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PUSH
28457: LD_INT 0
28459: PUSH
28460: LD_INT 1
28462: NEG
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 1
28470: PUSH
28471: LD_INT 0
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 1
28480: PUSH
28481: LD_INT 1
28483: PUSH
28484: EMPTY
28485: LIST
28486: LIST
28487: PUSH
28488: LD_INT 0
28490: PUSH
28491: LD_INT 1
28493: PUSH
28494: EMPTY
28495: LIST
28496: LIST
28497: PUSH
28498: LD_INT 1
28500: NEG
28501: PUSH
28502: LD_INT 0
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: PUSH
28509: LD_INT 1
28511: NEG
28512: PUSH
28513: LD_INT 1
28515: NEG
28516: PUSH
28517: EMPTY
28518: LIST
28519: LIST
28520: PUSH
28521: LD_INT 1
28523: NEG
28524: PUSH
28525: LD_INT 2
28527: NEG
28528: PUSH
28529: EMPTY
28530: LIST
28531: LIST
28532: PUSH
28533: LD_INT 0
28535: PUSH
28536: LD_INT 2
28538: NEG
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 1
28546: PUSH
28547: LD_INT 1
28549: NEG
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 2
28557: PUSH
28558: LD_INT 1
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: PUSH
28565: LD_INT 2
28567: PUSH
28568: LD_INT 2
28570: PUSH
28571: EMPTY
28572: LIST
28573: LIST
28574: PUSH
28575: LD_INT 1
28577: PUSH
28578: LD_INT 2
28580: PUSH
28581: EMPTY
28582: LIST
28583: LIST
28584: PUSH
28585: LD_INT 0
28587: PUSH
28588: LD_INT 2
28590: PUSH
28591: EMPTY
28592: LIST
28593: LIST
28594: PUSH
28595: LD_INT 1
28597: NEG
28598: PUSH
28599: LD_INT 1
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 2
28608: NEG
28609: PUSH
28610: LD_INT 0
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PUSH
28617: LD_INT 2
28619: NEG
28620: PUSH
28621: LD_INT 1
28623: NEG
28624: PUSH
28625: EMPTY
28626: LIST
28627: LIST
28628: PUSH
28629: LD_INT 1
28631: NEG
28632: PUSH
28633: LD_INT 3
28635: NEG
28636: PUSH
28637: EMPTY
28638: LIST
28639: LIST
28640: PUSH
28641: LD_INT 1
28643: PUSH
28644: LD_INT 2
28646: NEG
28647: PUSH
28648: EMPTY
28649: LIST
28650: LIST
28651: PUSH
28652: LD_INT 3
28654: PUSH
28655: LD_INT 2
28657: PUSH
28658: EMPTY
28659: LIST
28660: LIST
28661: PUSH
28662: LD_INT 2
28664: PUSH
28665: LD_INT 3
28667: PUSH
28668: EMPTY
28669: LIST
28670: LIST
28671: PUSH
28672: LD_INT 2
28674: NEG
28675: PUSH
28676: LD_INT 1
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: LD_INT 3
28685: NEG
28686: PUSH
28687: LD_INT 1
28689: NEG
28690: PUSH
28691: EMPTY
28692: LIST
28693: LIST
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: LIST
28699: LIST
28700: LIST
28701: LIST
28702: LIST
28703: LIST
28704: LIST
28705: LIST
28706: LIST
28707: LIST
28708: LIST
28709: LIST
28710: LIST
28711: LIST
28712: LIST
28713: LIST
28714: LIST
28715: LIST
28716: LIST
28717: LIST
28718: LIST
28719: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28720: LD_ADDR_VAR 0 33
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: LD_INT 0
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: LD_INT 0
28737: PUSH
28738: LD_INT 1
28740: NEG
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: PUSH
28746: LD_INT 1
28748: PUSH
28749: LD_INT 0
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: PUSH
28756: LD_INT 1
28758: PUSH
28759: LD_INT 1
28761: PUSH
28762: EMPTY
28763: LIST
28764: LIST
28765: PUSH
28766: LD_INT 0
28768: PUSH
28769: LD_INT 1
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 1
28778: NEG
28779: PUSH
28780: LD_INT 0
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: LD_INT 1
28789: NEG
28790: PUSH
28791: LD_INT 1
28793: NEG
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: LD_INT 1
28801: NEG
28802: PUSH
28803: LD_INT 2
28805: NEG
28806: PUSH
28807: EMPTY
28808: LIST
28809: LIST
28810: PUSH
28811: LD_INT 1
28813: PUSH
28814: LD_INT 1
28816: NEG
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: PUSH
28822: LD_INT 2
28824: PUSH
28825: LD_INT 0
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PUSH
28832: LD_INT 2
28834: PUSH
28835: LD_INT 1
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 1
28844: PUSH
28845: LD_INT 2
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: PUSH
28852: LD_INT 0
28854: PUSH
28855: LD_INT 2
28857: PUSH
28858: EMPTY
28859: LIST
28860: LIST
28861: PUSH
28862: LD_INT 1
28864: NEG
28865: PUSH
28866: LD_INT 1
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 2
28875: NEG
28876: PUSH
28877: LD_INT 0
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 2
28886: NEG
28887: PUSH
28888: LD_INT 1
28890: NEG
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 2
28898: NEG
28899: PUSH
28900: LD_INT 2
28902: NEG
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: PUSH
28908: LD_INT 2
28910: NEG
28911: PUSH
28912: LD_INT 3
28914: NEG
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 2
28922: PUSH
28923: LD_INT 1
28925: NEG
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: LD_INT 3
28933: PUSH
28934: LD_INT 1
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: LD_INT 3
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 1
28953: NEG
28954: PUSH
28955: LD_INT 2
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 3
28964: NEG
28965: PUSH
28966: LD_INT 2
28968: NEG
28969: PUSH
28970: EMPTY
28971: LIST
28972: LIST
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: LIST
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: LIST
28993: LIST
28994: LIST
28995: LIST
28996: LIST
28997: LIST
28998: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28999: LD_ADDR_VAR 0 34
29003: PUSH
29004: LD_INT 0
29006: PUSH
29007: LD_INT 0
29009: PUSH
29010: EMPTY
29011: LIST
29012: LIST
29013: PUSH
29014: LD_INT 0
29016: PUSH
29017: LD_INT 1
29019: NEG
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: PUSH
29025: LD_INT 1
29027: PUSH
29028: LD_INT 0
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: PUSH
29035: LD_INT 1
29037: PUSH
29038: LD_INT 1
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: LD_INT 1
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: LD_INT 1
29057: NEG
29058: PUSH
29059: LD_INT 0
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 1
29068: NEG
29069: PUSH
29070: LD_INT 1
29072: NEG
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 1
29080: NEG
29081: PUSH
29082: LD_INT 2
29084: NEG
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 0
29092: PUSH
29093: LD_INT 2
29095: NEG
29096: PUSH
29097: EMPTY
29098: LIST
29099: LIST
29100: PUSH
29101: LD_INT 1
29103: PUSH
29104: LD_INT 1
29106: NEG
29107: PUSH
29108: EMPTY
29109: LIST
29110: LIST
29111: PUSH
29112: LD_INT 2
29114: PUSH
29115: LD_INT 1
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: LD_INT 2
29124: PUSH
29125: LD_INT 2
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 1
29134: PUSH
29135: LD_INT 2
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 1
29144: NEG
29145: PUSH
29146: LD_INT 1
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 2
29155: NEG
29156: PUSH
29157: LD_INT 0
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PUSH
29164: LD_INT 2
29166: NEG
29167: PUSH
29168: LD_INT 1
29170: NEG
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: PUSH
29176: LD_INT 2
29178: NEG
29179: PUSH
29180: LD_INT 2
29182: NEG
29183: PUSH
29184: EMPTY
29185: LIST
29186: LIST
29187: PUSH
29188: LD_INT 1
29190: NEG
29191: PUSH
29192: LD_INT 3
29194: NEG
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 1
29202: PUSH
29203: LD_INT 2
29205: NEG
29206: PUSH
29207: EMPTY
29208: LIST
29209: LIST
29210: PUSH
29211: LD_INT 3
29213: PUSH
29214: LD_INT 2
29216: PUSH
29217: EMPTY
29218: LIST
29219: LIST
29220: PUSH
29221: LD_INT 2
29223: PUSH
29224: LD_INT 3
29226: PUSH
29227: EMPTY
29228: LIST
29229: LIST
29230: PUSH
29231: LD_INT 2
29233: NEG
29234: PUSH
29235: LD_INT 1
29237: PUSH
29238: EMPTY
29239: LIST
29240: LIST
29241: PUSH
29242: LD_INT 3
29244: NEG
29245: PUSH
29246: LD_INT 1
29248: NEG
29249: PUSH
29250: EMPTY
29251: LIST
29252: LIST
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: LIST
29258: LIST
29259: LIST
29260: LIST
29261: LIST
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: LIST
29267: LIST
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29279: LD_ADDR_VAR 0 35
29283: PUSH
29284: LD_INT 0
29286: PUSH
29287: LD_INT 0
29289: PUSH
29290: EMPTY
29291: LIST
29292: LIST
29293: PUSH
29294: LD_INT 0
29296: PUSH
29297: LD_INT 1
29299: NEG
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: LD_INT 1
29307: PUSH
29308: LD_INT 0
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 1
29317: PUSH
29318: LD_INT 1
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 0
29327: PUSH
29328: LD_INT 1
29330: PUSH
29331: EMPTY
29332: LIST
29333: LIST
29334: PUSH
29335: LD_INT 1
29337: NEG
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 1
29348: NEG
29349: PUSH
29350: LD_INT 1
29352: NEG
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: PUSH
29358: LD_INT 2
29360: PUSH
29361: LD_INT 1
29363: PUSH
29364: EMPTY
29365: LIST
29366: LIST
29367: PUSH
29368: LD_INT 2
29370: NEG
29371: PUSH
29372: LD_INT 1
29374: NEG
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: EMPTY
29381: LIST
29382: LIST
29383: LIST
29384: LIST
29385: LIST
29386: LIST
29387: LIST
29388: LIST
29389: LIST
29390: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29391: LD_ADDR_VAR 0 36
29395: PUSH
29396: LD_INT 0
29398: PUSH
29399: LD_INT 0
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PUSH
29406: LD_INT 0
29408: PUSH
29409: LD_INT 1
29411: NEG
29412: PUSH
29413: EMPTY
29414: LIST
29415: LIST
29416: PUSH
29417: LD_INT 1
29419: PUSH
29420: LD_INT 0
29422: PUSH
29423: EMPTY
29424: LIST
29425: LIST
29426: PUSH
29427: LD_INT 1
29429: PUSH
29430: LD_INT 1
29432: PUSH
29433: EMPTY
29434: LIST
29435: LIST
29436: PUSH
29437: LD_INT 0
29439: PUSH
29440: LD_INT 1
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: LD_INT 1
29449: NEG
29450: PUSH
29451: LD_INT 0
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 1
29460: NEG
29461: PUSH
29462: LD_INT 1
29464: NEG
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: PUSH
29470: LD_INT 1
29472: NEG
29473: PUSH
29474: LD_INT 2
29476: NEG
29477: PUSH
29478: EMPTY
29479: LIST
29480: LIST
29481: PUSH
29482: LD_INT 1
29484: PUSH
29485: LD_INT 2
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: EMPTY
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29503: LD_ADDR_VAR 0 37
29507: PUSH
29508: LD_INT 0
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PUSH
29518: LD_INT 0
29520: PUSH
29521: LD_INT 1
29523: NEG
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: LD_INT 1
29531: PUSH
29532: LD_INT 0
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PUSH
29539: LD_INT 1
29541: PUSH
29542: LD_INT 1
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PUSH
29549: LD_INT 0
29551: PUSH
29552: LD_INT 1
29554: PUSH
29555: EMPTY
29556: LIST
29557: LIST
29558: PUSH
29559: LD_INT 1
29561: NEG
29562: PUSH
29563: LD_INT 0
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PUSH
29570: LD_INT 1
29572: NEG
29573: PUSH
29574: LD_INT 1
29576: NEG
29577: PUSH
29578: EMPTY
29579: LIST
29580: LIST
29581: PUSH
29582: LD_INT 1
29584: PUSH
29585: LD_INT 1
29587: NEG
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 1
29595: NEG
29596: PUSH
29597: LD_INT 1
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: EMPTY
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29615: LD_ADDR_VAR 0 38
29619: PUSH
29620: LD_INT 0
29622: PUSH
29623: LD_INT 0
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 0
29632: PUSH
29633: LD_INT 1
29635: NEG
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: LD_INT 0
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: PUSH
29661: LD_INT 0
29663: PUSH
29664: LD_INT 1
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: PUSH
29671: LD_INT 1
29673: NEG
29674: PUSH
29675: LD_INT 0
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 1
29684: NEG
29685: PUSH
29686: LD_INT 1
29688: NEG
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 2
29696: PUSH
29697: LD_INT 1
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: LD_INT 1
29710: NEG
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: LIST
29720: LIST
29721: LIST
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29727: LD_ADDR_VAR 0 39
29731: PUSH
29732: LD_INT 0
29734: PUSH
29735: LD_INT 0
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: LD_INT 0
29744: PUSH
29745: LD_INT 1
29747: NEG
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 1
29755: PUSH
29756: LD_INT 0
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 1
29765: PUSH
29766: LD_INT 1
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 0
29775: PUSH
29776: LD_INT 1
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: LD_INT 1
29785: NEG
29786: PUSH
29787: LD_INT 0
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: LD_INT 1
29796: NEG
29797: PUSH
29798: LD_INT 1
29800: NEG
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 1
29808: NEG
29809: PUSH
29810: LD_INT 2
29812: NEG
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 1
29820: PUSH
29821: LD_INT 2
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: LIST
29832: LIST
29833: LIST
29834: LIST
29835: LIST
29836: LIST
29837: LIST
29838: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29839: LD_ADDR_VAR 0 40
29843: PUSH
29844: LD_INT 0
29846: PUSH
29847: LD_INT 0
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: LD_INT 0
29856: PUSH
29857: LD_INT 1
29859: NEG
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 1
29867: PUSH
29868: LD_INT 0
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 1
29877: PUSH
29878: LD_INT 1
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PUSH
29885: LD_INT 0
29887: PUSH
29888: LD_INT 1
29890: PUSH
29891: EMPTY
29892: LIST
29893: LIST
29894: PUSH
29895: LD_INT 1
29897: NEG
29898: PUSH
29899: LD_INT 0
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 1
29908: NEG
29909: PUSH
29910: LD_INT 1
29912: NEG
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 1
29920: PUSH
29921: LD_INT 1
29923: NEG
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: NEG
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: LIST
29944: LIST
29945: LIST
29946: LIST
29947: LIST
29948: LIST
29949: LIST
29950: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29951: LD_ADDR_VAR 0 41
29955: PUSH
29956: LD_INT 0
29958: PUSH
29959: LD_INT 0
29961: PUSH
29962: EMPTY
29963: LIST
29964: LIST
29965: PUSH
29966: LD_INT 0
29968: PUSH
29969: LD_INT 1
29971: NEG
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 1
29979: PUSH
29980: LD_INT 0
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 1
29989: PUSH
29990: LD_INT 1
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 0
29999: PUSH
30000: LD_INT 1
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 1
30009: NEG
30010: PUSH
30011: LD_INT 0
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 1
30020: NEG
30021: PUSH
30022: LD_INT 1
30024: NEG
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 1
30032: NEG
30033: PUSH
30034: LD_INT 2
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 1
30044: PUSH
30045: LD_INT 1
30047: NEG
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 2
30055: PUSH
30056: LD_INT 0
30058: PUSH
30059: EMPTY
30060: LIST
30061: LIST
30062: PUSH
30063: LD_INT 2
30065: PUSH
30066: LD_INT 1
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 2
30075: PUSH
30076: LD_INT 2
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 1
30085: PUSH
30086: LD_INT 2
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 1
30095: NEG
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 2
30106: NEG
30107: PUSH
30108: LD_INT 0
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 2
30117: NEG
30118: PUSH
30119: LD_INT 1
30121: NEG
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 2
30129: NEG
30130: PUSH
30131: LD_INT 2
30133: NEG
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: LD_INT 2
30141: NEG
30142: PUSH
30143: LD_INT 3
30145: NEG
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: PUSH
30151: LD_INT 2
30153: PUSH
30154: LD_INT 1
30156: NEG
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 3
30164: PUSH
30165: LD_INT 0
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 3
30174: PUSH
30175: LD_INT 1
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 3
30184: PUSH
30185: LD_INT 2
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 3
30194: PUSH
30195: LD_INT 3
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: PUSH
30202: LD_INT 2
30204: PUSH
30205: LD_INT 3
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 2
30214: NEG
30215: PUSH
30216: LD_INT 1
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 3
30225: NEG
30226: PUSH
30227: LD_INT 0
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 3
30236: NEG
30237: PUSH
30238: LD_INT 1
30240: NEG
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 3
30248: NEG
30249: PUSH
30250: LD_INT 2
30252: NEG
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 3
30260: NEG
30261: PUSH
30262: LD_INT 3
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: LIST
30299: LIST
30300: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30301: LD_ADDR_VAR 0 42
30305: PUSH
30306: LD_INT 0
30308: PUSH
30309: LD_INT 0
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: LD_INT 0
30318: PUSH
30319: LD_INT 1
30321: NEG
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 1
30329: PUSH
30330: LD_INT 0
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 1
30339: PUSH
30340: LD_INT 1
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 0
30349: PUSH
30350: LD_INT 1
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: LD_INT 1
30359: NEG
30360: PUSH
30361: LD_INT 0
30363: PUSH
30364: EMPTY
30365: LIST
30366: LIST
30367: PUSH
30368: LD_INT 1
30370: NEG
30371: PUSH
30372: LD_INT 1
30374: NEG
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 1
30382: NEG
30383: PUSH
30384: LD_INT 2
30386: NEG
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 0
30394: PUSH
30395: LD_INT 2
30397: NEG
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 1
30405: PUSH
30406: LD_INT 1
30408: NEG
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: PUSH
30414: LD_INT 2
30416: PUSH
30417: LD_INT 1
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 2
30426: PUSH
30427: LD_INT 2
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: PUSH
30437: LD_INT 2
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: LD_INT 0
30446: PUSH
30447: LD_INT 2
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 1
30456: NEG
30457: PUSH
30458: LD_INT 1
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 2
30467: NEG
30468: PUSH
30469: LD_INT 1
30471: NEG
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 2
30479: NEG
30480: PUSH
30481: LD_INT 2
30483: NEG
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 2
30491: NEG
30492: PUSH
30493: LD_INT 3
30495: NEG
30496: PUSH
30497: EMPTY
30498: LIST
30499: LIST
30500: PUSH
30501: LD_INT 1
30503: NEG
30504: PUSH
30505: LD_INT 3
30507: NEG
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 0
30515: PUSH
30516: LD_INT 3
30518: NEG
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: LD_INT 1
30526: PUSH
30527: LD_INT 2
30529: NEG
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 3
30537: PUSH
30538: LD_INT 2
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 3
30547: PUSH
30548: LD_INT 3
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 2
30557: PUSH
30558: LD_INT 3
30560: PUSH
30561: EMPTY
30562: LIST
30563: LIST
30564: PUSH
30565: LD_INT 1
30567: PUSH
30568: LD_INT 3
30570: PUSH
30571: EMPTY
30572: LIST
30573: LIST
30574: PUSH
30575: LD_INT 0
30577: PUSH
30578: LD_INT 3
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: LD_INT 1
30587: NEG
30588: PUSH
30589: LD_INT 2
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: LD_INT 3
30598: NEG
30599: PUSH
30600: LD_INT 2
30602: NEG
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: LD_INT 3
30610: NEG
30611: PUSH
30612: LD_INT 3
30614: NEG
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: EMPTY
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30651: LD_ADDR_VAR 0 43
30655: PUSH
30656: LD_INT 0
30658: PUSH
30659: LD_INT 0
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: PUSH
30666: LD_INT 0
30668: PUSH
30669: LD_INT 1
30671: NEG
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PUSH
30677: LD_INT 1
30679: PUSH
30680: LD_INT 0
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 1
30689: PUSH
30690: LD_INT 1
30692: PUSH
30693: EMPTY
30694: LIST
30695: LIST
30696: PUSH
30697: LD_INT 0
30699: PUSH
30700: LD_INT 1
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 1
30709: NEG
30710: PUSH
30711: LD_INT 0
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 1
30720: NEG
30721: PUSH
30722: LD_INT 1
30724: NEG
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 1
30732: NEG
30733: PUSH
30734: LD_INT 2
30736: NEG
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 0
30744: PUSH
30745: LD_INT 2
30747: NEG
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 1
30755: PUSH
30756: LD_INT 1
30758: NEG
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 2
30766: PUSH
30767: LD_INT 0
30769: PUSH
30770: EMPTY
30771: LIST
30772: LIST
30773: PUSH
30774: LD_INT 2
30776: PUSH
30777: LD_INT 1
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: LD_INT 2
30789: PUSH
30790: EMPTY
30791: LIST
30792: LIST
30793: PUSH
30794: LD_INT 0
30796: PUSH
30797: LD_INT 2
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 1
30806: NEG
30807: PUSH
30808: LD_INT 1
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 2
30817: NEG
30818: PUSH
30819: LD_INT 0
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 2
30828: NEG
30829: PUSH
30830: LD_INT 1
30832: NEG
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 1
30840: NEG
30841: PUSH
30842: LD_INT 3
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 0
30852: PUSH
30853: LD_INT 3
30855: NEG
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 1
30863: PUSH
30864: LD_INT 2
30866: NEG
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: LD_INT 2
30874: PUSH
30875: LD_INT 1
30877: NEG
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 3
30885: PUSH
30886: LD_INT 0
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 3
30895: PUSH
30896: LD_INT 1
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 1
30905: PUSH
30906: LD_INT 3
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 0
30915: PUSH
30916: LD_INT 3
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 1
30925: NEG
30926: PUSH
30927: LD_INT 2
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 2
30936: NEG
30937: PUSH
30938: LD_INT 1
30940: PUSH
30941: EMPTY
30942: LIST
30943: LIST
30944: PUSH
30945: LD_INT 3
30947: NEG
30948: PUSH
30949: LD_INT 0
30951: PUSH
30952: EMPTY
30953: LIST
30954: LIST
30955: PUSH
30956: LD_INT 3
30958: NEG
30959: PUSH
30960: LD_INT 1
30962: NEG
30963: PUSH
30964: EMPTY
30965: LIST
30966: LIST
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30999: LD_ADDR_VAR 0 44
31003: PUSH
31004: LD_INT 0
31006: PUSH
31007: LD_INT 0
31009: PUSH
31010: EMPTY
31011: LIST
31012: LIST
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: LD_INT 1
31019: NEG
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 1
31027: PUSH
31028: LD_INT 0
31030: PUSH
31031: EMPTY
31032: LIST
31033: LIST
31034: PUSH
31035: LD_INT 1
31037: PUSH
31038: LD_INT 1
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: LD_INT 1
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 1
31057: NEG
31058: PUSH
31059: LD_INT 0
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: LD_INT 1
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 1
31080: NEG
31081: PUSH
31082: LD_INT 2
31084: NEG
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 1
31092: PUSH
31093: LD_INT 1
31095: NEG
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 2
31103: PUSH
31104: LD_INT 0
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 2
31113: PUSH
31114: LD_INT 1
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 2
31123: PUSH
31124: LD_INT 2
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PUSH
31131: LD_INT 1
31133: PUSH
31134: LD_INT 2
31136: PUSH
31137: EMPTY
31138: LIST
31139: LIST
31140: PUSH
31141: LD_INT 1
31143: NEG
31144: PUSH
31145: LD_INT 1
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 2
31154: NEG
31155: PUSH
31156: LD_INT 0
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: LD_INT 2
31165: NEG
31166: PUSH
31167: LD_INT 1
31169: NEG
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: LD_INT 2
31181: NEG
31182: PUSH
31183: EMPTY
31184: LIST
31185: LIST
31186: PUSH
31187: LD_INT 2
31189: NEG
31190: PUSH
31191: LD_INT 3
31193: NEG
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 2
31201: PUSH
31202: LD_INT 1
31204: NEG
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 3
31212: PUSH
31213: LD_INT 0
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: LD_INT 3
31222: PUSH
31223: LD_INT 1
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 3
31232: PUSH
31233: LD_INT 2
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 3
31242: PUSH
31243: LD_INT 3
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 2
31252: PUSH
31253: LD_INT 3
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PUSH
31260: LD_INT 2
31262: NEG
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 3
31273: NEG
31274: PUSH
31275: LD_INT 0
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 3
31284: NEG
31285: PUSH
31286: LD_INT 1
31288: NEG
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: LD_INT 3
31296: NEG
31297: PUSH
31298: LD_INT 2
31300: NEG
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 3
31308: NEG
31309: PUSH
31310: LD_INT 3
31312: NEG
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: LIST
31345: LIST
31346: LIST
31347: LIST
31348: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31349: LD_ADDR_VAR 0 45
31353: PUSH
31354: LD_INT 0
31356: PUSH
31357: LD_INT 0
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 0
31366: PUSH
31367: LD_INT 1
31369: NEG
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 1
31377: PUSH
31378: LD_INT 0
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 1
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: LD_INT 1
31400: PUSH
31401: EMPTY
31402: LIST
31403: LIST
31404: PUSH
31405: LD_INT 1
31407: NEG
31408: PUSH
31409: LD_INT 0
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: PUSH
31416: LD_INT 1
31418: NEG
31419: PUSH
31420: LD_INT 1
31422: NEG
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 1
31430: NEG
31431: PUSH
31432: LD_INT 2
31434: NEG
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 0
31442: PUSH
31443: LD_INT 2
31445: NEG
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: LD_INT 1
31456: NEG
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 2
31464: PUSH
31465: LD_INT 1
31467: PUSH
31468: EMPTY
31469: LIST
31470: LIST
31471: PUSH
31472: LD_INT 2
31474: PUSH
31475: LD_INT 2
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 1
31484: PUSH
31485: LD_INT 2
31487: PUSH
31488: EMPTY
31489: LIST
31490: LIST
31491: PUSH
31492: LD_INT 0
31494: PUSH
31495: LD_INT 2
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 1
31504: NEG
31505: PUSH
31506: LD_INT 1
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: LD_INT 2
31515: NEG
31516: PUSH
31517: LD_INT 1
31519: NEG
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 2
31527: NEG
31528: PUSH
31529: LD_INT 2
31531: NEG
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 2
31539: NEG
31540: PUSH
31541: LD_INT 3
31543: NEG
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 1
31551: NEG
31552: PUSH
31553: LD_INT 3
31555: NEG
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 0
31563: PUSH
31564: LD_INT 3
31566: NEG
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 1
31574: PUSH
31575: LD_INT 2
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 3
31585: PUSH
31586: LD_INT 2
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 3
31595: PUSH
31596: LD_INT 3
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 2
31605: PUSH
31606: LD_INT 3
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 1
31615: PUSH
31616: LD_INT 3
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: PUSH
31623: LD_INT 0
31625: PUSH
31626: LD_INT 3
31628: PUSH
31629: EMPTY
31630: LIST
31631: LIST
31632: PUSH
31633: LD_INT 1
31635: NEG
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 3
31646: NEG
31647: PUSH
31648: LD_INT 2
31650: NEG
31651: PUSH
31652: EMPTY
31653: LIST
31654: LIST
31655: PUSH
31656: LD_INT 3
31658: NEG
31659: PUSH
31660: LD_INT 3
31662: NEG
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: LIST
31692: LIST
31693: LIST
31694: LIST
31695: LIST
31696: LIST
31697: LIST
31698: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31699: LD_ADDR_VAR 0 46
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: LD_INT 0
31709: PUSH
31710: EMPTY
31711: LIST
31712: LIST
31713: PUSH
31714: LD_INT 0
31716: PUSH
31717: LD_INT 1
31719: NEG
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 1
31727: PUSH
31728: LD_INT 0
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 1
31737: PUSH
31738: LD_INT 1
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PUSH
31745: LD_INT 0
31747: PUSH
31748: LD_INT 1
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 1
31757: NEG
31758: PUSH
31759: LD_INT 0
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 1
31768: NEG
31769: PUSH
31770: LD_INT 1
31772: NEG
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 1
31780: NEG
31781: PUSH
31782: LD_INT 2
31784: NEG
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 0
31792: PUSH
31793: LD_INT 2
31795: NEG
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 1
31803: PUSH
31804: LD_INT 1
31806: NEG
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 2
31814: PUSH
31815: LD_INT 0
31817: PUSH
31818: EMPTY
31819: LIST
31820: LIST
31821: PUSH
31822: LD_INT 2
31824: PUSH
31825: LD_INT 1
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 1
31834: PUSH
31835: LD_INT 2
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 0
31844: PUSH
31845: LD_INT 2
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 1
31854: NEG
31855: PUSH
31856: LD_INT 1
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 2
31865: NEG
31866: PUSH
31867: LD_INT 0
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: LD_INT 2
31876: NEG
31877: PUSH
31878: LD_INT 1
31880: NEG
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: PUSH
31886: LD_INT 1
31888: NEG
31889: PUSH
31890: LD_INT 3
31892: NEG
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: LD_INT 0
31900: PUSH
31901: LD_INT 3
31903: NEG
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PUSH
31909: LD_INT 1
31911: PUSH
31912: LD_INT 2
31914: NEG
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PUSH
31920: LD_INT 2
31922: PUSH
31923: LD_INT 1
31925: NEG
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 3
31933: PUSH
31934: LD_INT 0
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 3
31943: PUSH
31944: LD_INT 1
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 1
31953: PUSH
31954: LD_INT 3
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 0
31963: PUSH
31964: LD_INT 3
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 1
31973: NEG
31974: PUSH
31975: LD_INT 2
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: LD_INT 2
31984: NEG
31985: PUSH
31986: LD_INT 1
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 3
31995: NEG
31996: PUSH
31997: LD_INT 0
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: LD_INT 3
32006: NEG
32007: PUSH
32008: LD_INT 1
32010: NEG
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32047: LD_ADDR_VAR 0 47
32051: PUSH
32052: LD_INT 0
32054: PUSH
32055: LD_INT 0
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: PUSH
32062: LD_INT 0
32064: PUSH
32065: LD_INT 1
32067: NEG
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 1
32075: PUSH
32076: LD_INT 0
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 1
32085: PUSH
32086: LD_INT 1
32088: PUSH
32089: EMPTY
32090: LIST
32091: LIST
32092: PUSH
32093: LD_INT 0
32095: PUSH
32096: LD_INT 1
32098: PUSH
32099: EMPTY
32100: LIST
32101: LIST
32102: PUSH
32103: LD_INT 1
32105: NEG
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 1
32116: NEG
32117: PUSH
32118: LD_INT 1
32120: NEG
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 1
32128: NEG
32129: PUSH
32130: LD_INT 2
32132: NEG
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 0
32140: PUSH
32141: LD_INT 2
32143: NEG
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: LD_INT 1
32151: PUSH
32152: LD_INT 1
32154: NEG
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 2
32162: NEG
32163: PUSH
32164: LD_INT 1
32166: NEG
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 2
32174: NEG
32175: PUSH
32176: LD_INT 2
32178: NEG
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32198: LD_ADDR_VAR 0 48
32202: PUSH
32203: LD_INT 0
32205: PUSH
32206: LD_INT 0
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 0
32215: PUSH
32216: LD_INT 1
32218: NEG
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: LD_INT 1
32226: PUSH
32227: LD_INT 0
32229: PUSH
32230: EMPTY
32231: LIST
32232: LIST
32233: PUSH
32234: LD_INT 1
32236: PUSH
32237: LD_INT 1
32239: PUSH
32240: EMPTY
32241: LIST
32242: LIST
32243: PUSH
32244: LD_INT 0
32246: PUSH
32247: LD_INT 1
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 1
32256: NEG
32257: PUSH
32258: LD_INT 0
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: LD_INT 1
32267: NEG
32268: PUSH
32269: LD_INT 1
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 1
32279: NEG
32280: PUSH
32281: LD_INT 2
32283: NEG
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 0
32291: PUSH
32292: LD_INT 2
32294: NEG
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: LD_INT 1
32305: NEG
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: LD_INT 2
32313: PUSH
32314: LD_INT 0
32316: PUSH
32317: EMPTY
32318: LIST
32319: LIST
32320: PUSH
32321: LD_INT 2
32323: PUSH
32324: LD_INT 1
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
32345: LD_ADDR_VAR 0 49
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: LD_INT 0
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 1
32383: PUSH
32384: LD_INT 1
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 0
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 1
32403: NEG
32404: PUSH
32405: LD_INT 0
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 1
32414: NEG
32415: PUSH
32416: LD_INT 1
32418: NEG
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 1
32426: PUSH
32427: LD_INT 1
32429: NEG
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 2
32437: PUSH
32438: LD_INT 0
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 2
32447: PUSH
32448: LD_INT 1
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 2
32457: PUSH
32458: LD_INT 2
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PUSH
32465: LD_INT 1
32467: PUSH
32468: LD_INT 2
32470: PUSH
32471: EMPTY
32472: LIST
32473: LIST
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32489: LD_ADDR_VAR 0 50
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: LD_INT 0
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PUSH
32504: LD_INT 0
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: LD_INT 1
32517: PUSH
32518: LD_INT 0
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 1
32527: PUSH
32528: LD_INT 1
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 0
32537: PUSH
32538: LD_INT 1
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 1
32547: NEG
32548: PUSH
32549: LD_INT 0
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 1
32558: NEG
32559: PUSH
32560: LD_INT 1
32562: NEG
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: PUSH
32568: LD_INT 2
32570: PUSH
32571: LD_INT 1
32573: PUSH
32574: EMPTY
32575: LIST
32576: LIST
32577: PUSH
32578: LD_INT 2
32580: PUSH
32581: LD_INT 2
32583: PUSH
32584: EMPTY
32585: LIST
32586: LIST
32587: PUSH
32588: LD_INT 1
32590: PUSH
32591: LD_INT 2
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: LD_INT 0
32600: PUSH
32601: LD_INT 2
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 1
32610: NEG
32611: PUSH
32612: LD_INT 1
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: LIST
32623: LIST
32624: LIST
32625: LIST
32626: LIST
32627: LIST
32628: LIST
32629: LIST
32630: LIST
32631: LIST
32632: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32633: LD_ADDR_VAR 0 51
32637: PUSH
32638: LD_INT 0
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 0
32650: PUSH
32651: LD_INT 1
32653: NEG
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 1
32661: PUSH
32662: LD_INT 0
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PUSH
32669: LD_INT 1
32671: PUSH
32672: LD_INT 1
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 1
32691: NEG
32692: PUSH
32693: LD_INT 0
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 1
32702: NEG
32703: PUSH
32704: LD_INT 1
32706: NEG
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: PUSH
32715: LD_INT 2
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 0
32724: PUSH
32725: LD_INT 2
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: NEG
32735: PUSH
32736: LD_INT 1
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 2
32745: NEG
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: EMPTY
32751: LIST
32752: LIST
32753: PUSH
32754: LD_INT 2
32756: NEG
32757: PUSH
32758: LD_INT 1
32760: NEG
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: EMPTY
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32780: LD_ADDR_VAR 0 52
32784: PUSH
32785: LD_INT 0
32787: PUSH
32788: LD_INT 0
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 0
32797: PUSH
32798: LD_INT 1
32800: NEG
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 1
32808: PUSH
32809: LD_INT 0
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 1
32818: PUSH
32819: LD_INT 1
32821: PUSH
32822: EMPTY
32823: LIST
32824: LIST
32825: PUSH
32826: LD_INT 0
32828: PUSH
32829: LD_INT 1
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PUSH
32836: LD_INT 1
32838: NEG
32839: PUSH
32840: LD_INT 0
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 1
32849: NEG
32850: PUSH
32851: LD_INT 1
32853: NEG
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 1
32861: NEG
32862: PUSH
32863: LD_INT 2
32865: NEG
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 1
32873: NEG
32874: PUSH
32875: LD_INT 1
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 2
32884: NEG
32885: PUSH
32886: LD_INT 0
32888: PUSH
32889: EMPTY
32890: LIST
32891: LIST
32892: PUSH
32893: LD_INT 2
32895: NEG
32896: PUSH
32897: LD_INT 1
32899: NEG
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: PUSH
32905: LD_INT 2
32907: NEG
32908: PUSH
32909: LD_INT 2
32911: NEG
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32931: LD_ADDR_VAR 0 53
32935: PUSH
32936: LD_INT 0
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: EMPTY
32943: LIST
32944: LIST
32945: PUSH
32946: LD_INT 0
32948: PUSH
32949: LD_INT 1
32951: NEG
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 1
32959: PUSH
32960: LD_INT 0
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: PUSH
32970: LD_INT 1
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 0
32979: PUSH
32980: LD_INT 1
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 1
32989: NEG
32990: PUSH
32991: LD_INT 0
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 1
33000: NEG
33001: PUSH
33002: LD_INT 1
33004: NEG
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: LD_INT 2
33016: NEG
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 0
33024: PUSH
33025: LD_INT 2
33027: NEG
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 1
33035: PUSH
33036: LD_INT 1
33038: NEG
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: PUSH
33044: LD_INT 2
33046: PUSH
33047: LD_INT 0
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 2
33056: PUSH
33057: LD_INT 1
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 2
33066: PUSH
33067: LD_INT 2
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 1
33076: PUSH
33077: LD_INT 2
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: LD_INT 2
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: PUSH
33094: LD_INT 1
33096: NEG
33097: PUSH
33098: LD_INT 1
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 2
33107: NEG
33108: PUSH
33109: LD_INT 0
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 2
33118: NEG
33119: PUSH
33120: LD_INT 1
33122: NEG
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 2
33130: NEG
33131: PUSH
33132: LD_INT 2
33134: NEG
33135: PUSH
33136: EMPTY
33137: LIST
33138: LIST
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33161: LD_ADDR_VAR 0 54
33165: PUSH
33166: LD_INT 0
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 0
33178: PUSH
33179: LD_INT 1
33181: NEG
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 1
33189: PUSH
33190: LD_INT 0
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: LD_INT 1
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 0
33209: PUSH
33210: LD_INT 1
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 1
33219: NEG
33220: PUSH
33221: LD_INT 0
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 1
33230: NEG
33231: PUSH
33232: LD_INT 1
33234: NEG
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: PUSH
33240: LD_INT 1
33242: NEG
33243: PUSH
33244: LD_INT 2
33246: NEG
33247: PUSH
33248: EMPTY
33249: LIST
33250: LIST
33251: PUSH
33252: LD_INT 0
33254: PUSH
33255: LD_INT 2
33257: NEG
33258: PUSH
33259: EMPTY
33260: LIST
33261: LIST
33262: PUSH
33263: LD_INT 1
33265: PUSH
33266: LD_INT 1
33268: NEG
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 2
33276: PUSH
33277: LD_INT 0
33279: PUSH
33280: EMPTY
33281: LIST
33282: LIST
33283: PUSH
33284: LD_INT 2
33286: PUSH
33287: LD_INT 1
33289: PUSH
33290: EMPTY
33291: LIST
33292: LIST
33293: PUSH
33294: LD_INT 2
33296: PUSH
33297: LD_INT 2
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 1
33306: PUSH
33307: LD_INT 2
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 0
33316: PUSH
33317: LD_INT 2
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 1
33326: NEG
33327: PUSH
33328: LD_INT 1
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: PUSH
33335: LD_INT 2
33337: NEG
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: EMPTY
33343: LIST
33344: LIST
33345: PUSH
33346: LD_INT 2
33348: NEG
33349: PUSH
33350: LD_INT 1
33352: NEG
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 2
33360: NEG
33361: PUSH
33362: LD_INT 2
33364: NEG
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33391: LD_ADDR_VAR 0 55
33395: PUSH
33396: LD_INT 0
33398: PUSH
33399: LD_INT 0
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 0
33408: PUSH
33409: LD_INT 1
33411: NEG
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 1
33419: PUSH
33420: LD_INT 0
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: LD_INT 1
33429: PUSH
33430: LD_INT 1
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: PUSH
33437: LD_INT 0
33439: PUSH
33440: LD_INT 1
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 1
33449: NEG
33450: PUSH
33451: LD_INT 0
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: LD_INT 1
33460: NEG
33461: PUSH
33462: LD_INT 1
33464: NEG
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 1
33472: NEG
33473: PUSH
33474: LD_INT 2
33476: NEG
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 0
33484: PUSH
33485: LD_INT 2
33487: NEG
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: LD_INT 1
33495: PUSH
33496: LD_INT 1
33498: NEG
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 2
33506: PUSH
33507: LD_INT 0
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 2
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: PUSH
33527: LD_INT 2
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 1
33536: PUSH
33537: LD_INT 2
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 0
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 1
33556: NEG
33557: PUSH
33558: LD_INT 1
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 2
33567: NEG
33568: PUSH
33569: LD_INT 0
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 2
33578: NEG
33579: PUSH
33580: LD_INT 1
33582: NEG
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 2
33590: NEG
33591: PUSH
33592: LD_INT 2
33594: NEG
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: EMPTY
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: LIST
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33621: LD_ADDR_VAR 0 56
33625: PUSH
33626: LD_INT 0
33628: PUSH
33629: LD_INT 0
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 0
33638: PUSH
33639: LD_INT 1
33641: NEG
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: LD_INT 0
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 1
33659: PUSH
33660: LD_INT 1
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 0
33669: PUSH
33670: LD_INT 1
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 1
33679: NEG
33680: PUSH
33681: LD_INT 0
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 1
33690: NEG
33691: PUSH
33692: LD_INT 1
33694: NEG
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 1
33702: NEG
33703: PUSH
33704: LD_INT 2
33706: NEG
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: PUSH
33712: LD_INT 0
33714: PUSH
33715: LD_INT 2
33717: NEG
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 1
33725: PUSH
33726: LD_INT 1
33728: NEG
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 2
33736: PUSH
33737: LD_INT 0
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 2
33746: PUSH
33747: LD_INT 1
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 2
33756: PUSH
33757: LD_INT 2
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 1
33766: PUSH
33767: LD_INT 2
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 0
33776: PUSH
33777: LD_INT 2
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: LD_INT 1
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 2
33797: NEG
33798: PUSH
33799: LD_INT 0
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: LD_INT 1
33812: NEG
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 2
33820: NEG
33821: PUSH
33822: LD_INT 2
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33851: LD_ADDR_VAR 0 57
33855: PUSH
33856: LD_INT 0
33858: PUSH
33859: LD_INT 0
33861: PUSH
33862: EMPTY
33863: LIST
33864: LIST
33865: PUSH
33866: LD_INT 0
33868: PUSH
33869: LD_INT 1
33871: NEG
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 1
33879: PUSH
33880: LD_INT 0
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 1
33889: PUSH
33890: LD_INT 1
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 1
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 1
33909: NEG
33910: PUSH
33911: LD_INT 0
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: NEG
33921: PUSH
33922: LD_INT 1
33924: NEG
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 1
33932: NEG
33933: PUSH
33934: LD_INT 2
33936: NEG
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: LD_INT 2
33947: NEG
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 1
33955: PUSH
33956: LD_INT 1
33958: NEG
33959: PUSH
33960: EMPTY
33961: LIST
33962: LIST
33963: PUSH
33964: LD_INT 2
33966: PUSH
33967: LD_INT 0
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 2
33976: PUSH
33977: LD_INT 1
33979: PUSH
33980: EMPTY
33981: LIST
33982: LIST
33983: PUSH
33984: LD_INT 2
33986: PUSH
33987: LD_INT 2
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: LD_INT 2
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 0
34006: PUSH
34007: LD_INT 2
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 1
34016: NEG
34017: PUSH
34018: LD_INT 1
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: NEG
34028: PUSH
34029: LD_INT 0
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 2
34038: NEG
34039: PUSH
34040: LD_INT 1
34042: NEG
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 2
34050: NEG
34051: PUSH
34052: LD_INT 2
34054: NEG
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34081: LD_ADDR_VAR 0 58
34085: PUSH
34086: LD_INT 0
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 0
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: PUSH
34110: LD_INT 0
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 1
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 0
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 1
34139: NEG
34140: PUSH
34141: LD_INT 0
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: LD_INT 1
34154: NEG
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: PUSH
34160: LD_INT 1
34162: NEG
34163: PUSH
34164: LD_INT 2
34166: NEG
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 0
34174: PUSH
34175: LD_INT 2
34177: NEG
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 1
34185: PUSH
34186: LD_INT 1
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: PUSH
34197: LD_INT 0
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 2
34206: PUSH
34207: LD_INT 1
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 2
34216: PUSH
34217: LD_INT 2
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: PUSH
34227: LD_INT 2
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 0
34236: PUSH
34237: LD_INT 2
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: LD_INT 1
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 2
34257: NEG
34258: PUSH
34259: LD_INT 0
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 2
34268: NEG
34269: PUSH
34270: LD_INT 1
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 2
34280: NEG
34281: PUSH
34282: LD_INT 2
34284: NEG
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: LIST
34294: LIST
34295: LIST
34296: LIST
34297: LIST
34298: LIST
34299: LIST
34300: LIST
34301: LIST
34302: LIST
34303: LIST
34304: LIST
34305: LIST
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34311: LD_ADDR_VAR 0 59
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: LD_INT 0
34321: PUSH
34322: EMPTY
34323: LIST
34324: LIST
34325: PUSH
34326: LD_INT 0
34328: PUSH
34329: LD_INT 1
34331: NEG
34332: PUSH
34333: EMPTY
34334: LIST
34335: LIST
34336: PUSH
34337: LD_INT 1
34339: PUSH
34340: LD_INT 0
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: LD_INT 1
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 0
34359: PUSH
34360: LD_INT 1
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 1
34369: NEG
34370: PUSH
34371: LD_INT 0
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: LD_INT 1
34380: NEG
34381: PUSH
34382: LD_INT 1
34384: NEG
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34399: LD_ADDR_VAR 0 60
34403: PUSH
34404: LD_INT 0
34406: PUSH
34407: LD_INT 0
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PUSH
34414: LD_INT 0
34416: PUSH
34417: LD_INT 1
34419: NEG
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 1
34427: PUSH
34428: LD_INT 0
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: LD_INT 1
34437: PUSH
34438: LD_INT 1
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: LD_INT 1
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 1
34457: NEG
34458: PUSH
34459: LD_INT 0
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: LIST
34482: LIST
34483: LIST
34484: LIST
34485: LIST
34486: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34487: LD_ADDR_VAR 0 61
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: LD_INT 0
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 0
34504: PUSH
34505: LD_INT 1
34507: NEG
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: LD_INT 1
34515: PUSH
34516: LD_INT 0
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: LD_INT 1
34525: PUSH
34526: LD_INT 1
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 0
34535: PUSH
34536: LD_INT 1
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 1
34545: NEG
34546: PUSH
34547: LD_INT 0
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 1
34556: NEG
34557: PUSH
34558: LD_INT 1
34560: NEG
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: LIST
34570: LIST
34571: LIST
34572: LIST
34573: LIST
34574: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34575: LD_ADDR_VAR 0 62
34579: PUSH
34580: LD_INT 0
34582: PUSH
34583: LD_INT 0
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 0
34592: PUSH
34593: LD_INT 1
34595: NEG
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 1
34603: PUSH
34604: LD_INT 0
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 1
34613: PUSH
34614: LD_INT 1
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 0
34623: PUSH
34624: LD_INT 1
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 1
34633: NEG
34634: PUSH
34635: LD_INT 0
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 1
34644: NEG
34645: PUSH
34646: LD_INT 1
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34663: LD_ADDR_VAR 0 63
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: LD_INT 0
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 0
34680: PUSH
34681: LD_INT 1
34683: NEG
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 1
34691: PUSH
34692: LD_INT 0
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 1
34701: PUSH
34702: LD_INT 1
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 0
34711: PUSH
34712: LD_INT 1
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 1
34721: NEG
34722: PUSH
34723: LD_INT 0
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: LD_INT 1
34736: NEG
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: LIST
34749: LIST
34750: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34751: LD_ADDR_VAR 0 64
34755: PUSH
34756: LD_INT 0
34758: PUSH
34759: LD_INT 0
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 0
34768: PUSH
34769: LD_INT 1
34771: NEG
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 1
34779: PUSH
34780: LD_INT 0
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 1
34789: PUSH
34790: LD_INT 1
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: LD_INT 1
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 1
34809: NEG
34810: PUSH
34811: LD_INT 0
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 1
34820: NEG
34821: PUSH
34822: LD_INT 1
34824: NEG
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: ST_TO_ADDR
// end ; 1 :
34839: GO 40736
34841: LD_INT 1
34843: DOUBLE
34844: EQUAL
34845: IFTRUE 34849
34847: GO 37472
34849: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34850: LD_ADDR_VAR 0 11
34854: PUSH
34855: LD_INT 1
34857: NEG
34858: PUSH
34859: LD_INT 3
34861: NEG
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PUSH
34867: LD_INT 0
34869: PUSH
34870: LD_INT 3
34872: NEG
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: LD_INT 2
34883: NEG
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: LIST
34893: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34894: LD_ADDR_VAR 0 12
34898: PUSH
34899: LD_INT 2
34901: PUSH
34902: LD_INT 1
34904: NEG
34905: PUSH
34906: EMPTY
34907: LIST
34908: LIST
34909: PUSH
34910: LD_INT 3
34912: PUSH
34913: LD_INT 0
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: PUSH
34920: LD_INT 3
34922: PUSH
34923: LD_INT 1
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: LIST
34934: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34935: LD_ADDR_VAR 0 13
34939: PUSH
34940: LD_INT 3
34942: PUSH
34943: LD_INT 2
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 3
34952: PUSH
34953: LD_INT 3
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 2
34962: PUSH
34963: LD_INT 3
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: LIST
34974: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34975: LD_ADDR_VAR 0 14
34979: PUSH
34980: LD_INT 1
34982: PUSH
34983: LD_INT 3
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 0
34992: PUSH
34993: LD_INT 3
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 1
35002: NEG
35003: PUSH
35004: LD_INT 2
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: LIST
35015: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35016: LD_ADDR_VAR 0 15
35020: PUSH
35021: LD_INT 2
35023: NEG
35024: PUSH
35025: LD_INT 1
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: PUSH
35032: LD_INT 3
35034: NEG
35035: PUSH
35036: LD_INT 0
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 3
35045: NEG
35046: PUSH
35047: LD_INT 1
35049: NEG
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: LIST
35059: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35060: LD_ADDR_VAR 0 16
35064: PUSH
35065: LD_INT 2
35067: NEG
35068: PUSH
35069: LD_INT 3
35071: NEG
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 3
35079: NEG
35080: PUSH
35081: LD_INT 2
35083: NEG
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 3
35091: NEG
35092: PUSH
35093: LD_INT 3
35095: NEG
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: LIST
35105: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35106: LD_ADDR_VAR 0 17
35110: PUSH
35111: LD_INT 1
35113: NEG
35114: PUSH
35115: LD_INT 3
35117: NEG
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: LD_INT 0
35125: PUSH
35126: LD_INT 3
35128: NEG
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: LD_INT 2
35139: NEG
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: LIST
35149: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35150: LD_ADDR_VAR 0 18
35154: PUSH
35155: LD_INT 2
35157: PUSH
35158: LD_INT 1
35160: NEG
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 3
35168: PUSH
35169: LD_INT 0
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 3
35178: PUSH
35179: LD_INT 1
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: LIST
35190: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35191: LD_ADDR_VAR 0 19
35195: PUSH
35196: LD_INT 3
35198: PUSH
35199: LD_INT 2
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 3
35208: PUSH
35209: LD_INT 3
35211: PUSH
35212: EMPTY
35213: LIST
35214: LIST
35215: PUSH
35216: LD_INT 2
35218: PUSH
35219: LD_INT 3
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: LIST
35230: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35231: LD_ADDR_VAR 0 20
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: LD_INT 3
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 0
35248: PUSH
35249: LD_INT 3
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 1
35258: NEG
35259: PUSH
35260: LD_INT 2
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: LIST
35271: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35272: LD_ADDR_VAR 0 21
35276: PUSH
35277: LD_INT 2
35279: NEG
35280: PUSH
35281: LD_INT 1
35283: PUSH
35284: EMPTY
35285: LIST
35286: LIST
35287: PUSH
35288: LD_INT 3
35290: NEG
35291: PUSH
35292: LD_INT 0
35294: PUSH
35295: EMPTY
35296: LIST
35297: LIST
35298: PUSH
35299: LD_INT 3
35301: NEG
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: LIST
35315: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35316: LD_ADDR_VAR 0 22
35320: PUSH
35321: LD_INT 2
35323: NEG
35324: PUSH
35325: LD_INT 3
35327: NEG
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 3
35335: NEG
35336: PUSH
35337: LD_INT 2
35339: NEG
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PUSH
35345: LD_INT 3
35347: NEG
35348: PUSH
35349: LD_INT 3
35351: NEG
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: LIST
35361: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
35362: LD_ADDR_VAR 0 23
35366: PUSH
35367: LD_INT 0
35369: PUSH
35370: LD_INT 3
35372: NEG
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 1
35380: NEG
35381: PUSH
35382: LD_INT 4
35384: NEG
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 1
35392: PUSH
35393: LD_INT 3
35395: NEG
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: LIST
35405: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
35406: LD_ADDR_VAR 0 24
35410: PUSH
35411: LD_INT 3
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 3
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 4
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: LIST
35446: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
35447: LD_ADDR_VAR 0 25
35451: PUSH
35452: LD_INT 3
35454: PUSH
35455: LD_INT 3
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 4
35464: PUSH
35465: LD_INT 3
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 3
35474: PUSH
35475: LD_INT 4
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: LIST
35486: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
35487: LD_ADDR_VAR 0 26
35491: PUSH
35492: LD_INT 0
35494: PUSH
35495: LD_INT 3
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PUSH
35502: LD_INT 1
35504: PUSH
35505: LD_INT 4
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: LD_INT 3
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: LIST
35527: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
35528: LD_ADDR_VAR 0 27
35532: PUSH
35533: LD_INT 3
35535: NEG
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: PUSH
35544: LD_INT 3
35546: NEG
35547: PUSH
35548: LD_INT 1
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 4
35557: NEG
35558: PUSH
35559: LD_INT 1
35561: NEG
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: LIST
35571: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
35572: LD_ADDR_VAR 0 28
35576: PUSH
35577: LD_INT 3
35579: NEG
35580: PUSH
35581: LD_INT 3
35583: NEG
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 3
35591: NEG
35592: PUSH
35593: LD_INT 4
35595: NEG
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 4
35603: NEG
35604: PUSH
35605: LD_INT 3
35607: NEG
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: LIST
35617: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
35618: LD_ADDR_VAR 0 29
35622: PUSH
35623: LD_INT 1
35625: NEG
35626: PUSH
35627: LD_INT 3
35629: NEG
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: LD_INT 0
35637: PUSH
35638: LD_INT 3
35640: NEG
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 1
35648: PUSH
35649: LD_INT 2
35651: NEG
35652: PUSH
35653: EMPTY
35654: LIST
35655: LIST
35656: PUSH
35657: LD_INT 1
35659: NEG
35660: PUSH
35661: LD_INT 4
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 0
35671: PUSH
35672: LD_INT 4
35674: NEG
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: LD_INT 3
35685: NEG
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 1
35693: NEG
35694: PUSH
35695: LD_INT 5
35697: NEG
35698: PUSH
35699: EMPTY
35700: LIST
35701: LIST
35702: PUSH
35703: LD_INT 0
35705: PUSH
35706: LD_INT 5
35708: NEG
35709: PUSH
35710: EMPTY
35711: LIST
35712: LIST
35713: PUSH
35714: LD_INT 1
35716: PUSH
35717: LD_INT 4
35719: NEG
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 1
35727: NEG
35728: PUSH
35729: LD_INT 6
35731: NEG
35732: PUSH
35733: EMPTY
35734: LIST
35735: LIST
35736: PUSH
35737: LD_INT 0
35739: PUSH
35740: LD_INT 6
35742: NEG
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: LD_INT 1
35750: PUSH
35751: LD_INT 5
35753: NEG
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
35773: LD_ADDR_VAR 0 30
35777: PUSH
35778: LD_INT 2
35780: PUSH
35781: LD_INT 1
35783: NEG
35784: PUSH
35785: EMPTY
35786: LIST
35787: LIST
35788: PUSH
35789: LD_INT 3
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 3
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 3
35811: PUSH
35812: LD_INT 1
35814: NEG
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 4
35822: PUSH
35823: LD_INT 0
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 4
35832: PUSH
35833: LD_INT 1
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 4
35842: PUSH
35843: LD_INT 1
35845: NEG
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 5
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 5
35863: PUSH
35864: LD_INT 1
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 5
35873: PUSH
35874: LD_INT 1
35876: NEG
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 6
35884: PUSH
35885: LD_INT 0
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 6
35894: PUSH
35895: LD_INT 1
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: LIST
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
35916: LD_ADDR_VAR 0 31
35920: PUSH
35921: LD_INT 3
35923: PUSH
35924: LD_INT 2
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 3
35933: PUSH
35934: LD_INT 3
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: PUSH
35941: LD_INT 2
35943: PUSH
35944: LD_INT 3
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 4
35953: PUSH
35954: LD_INT 3
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 4
35963: PUSH
35964: LD_INT 4
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 3
35973: PUSH
35974: LD_INT 4
35976: PUSH
35977: EMPTY
35978: LIST
35979: LIST
35980: PUSH
35981: LD_INT 5
35983: PUSH
35984: LD_INT 4
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: LD_INT 5
35993: PUSH
35994: LD_INT 5
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 4
36003: PUSH
36004: LD_INT 5
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 6
36013: PUSH
36014: LD_INT 5
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 6
36023: PUSH
36024: LD_INT 6
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 5
36033: PUSH
36034: LD_INT 6
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: LIST
36052: LIST
36053: LIST
36054: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36055: LD_ADDR_VAR 0 32
36059: PUSH
36060: LD_INT 1
36062: PUSH
36063: LD_INT 3
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 0
36072: PUSH
36073: LD_INT 3
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: LD_INT 1
36082: NEG
36083: PUSH
36084: LD_INT 2
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 1
36093: PUSH
36094: LD_INT 4
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 0
36103: PUSH
36104: LD_INT 4
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 1
36113: NEG
36114: PUSH
36115: LD_INT 3
36117: PUSH
36118: EMPTY
36119: LIST
36120: LIST
36121: PUSH
36122: LD_INT 1
36124: PUSH
36125: LD_INT 5
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: LD_INT 5
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 1
36144: NEG
36145: PUSH
36146: LD_INT 4
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: LD_INT 6
36158: PUSH
36159: EMPTY
36160: LIST
36161: LIST
36162: PUSH
36163: LD_INT 0
36165: PUSH
36166: LD_INT 6
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 1
36175: NEG
36176: PUSH
36177: LD_INT 5
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36198: LD_ADDR_VAR 0 33
36202: PUSH
36203: LD_INT 2
36205: NEG
36206: PUSH
36207: LD_INT 1
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 3
36216: NEG
36217: PUSH
36218: LD_INT 0
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 3
36227: NEG
36228: PUSH
36229: LD_INT 1
36231: NEG
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 3
36239: NEG
36240: PUSH
36241: LD_INT 1
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: LD_INT 4
36250: NEG
36251: PUSH
36252: LD_INT 0
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 4
36261: NEG
36262: PUSH
36263: LD_INT 1
36265: NEG
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: LD_INT 4
36273: NEG
36274: PUSH
36275: LD_INT 1
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 5
36284: NEG
36285: PUSH
36286: LD_INT 0
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: PUSH
36293: LD_INT 5
36295: NEG
36296: PUSH
36297: LD_INT 1
36299: NEG
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 5
36307: NEG
36308: PUSH
36309: LD_INT 1
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 6
36318: NEG
36319: PUSH
36320: LD_INT 0
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 6
36329: NEG
36330: PUSH
36331: LD_INT 1
36333: NEG
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: LIST
36346: LIST
36347: LIST
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
36353: LD_ADDR_VAR 0 34
36357: PUSH
36358: LD_INT 2
36360: NEG
36361: PUSH
36362: LD_INT 3
36364: NEG
36365: PUSH
36366: EMPTY
36367: LIST
36368: LIST
36369: PUSH
36370: LD_INT 3
36372: NEG
36373: PUSH
36374: LD_INT 2
36376: NEG
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 3
36384: NEG
36385: PUSH
36386: LD_INT 3
36388: NEG
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 3
36396: NEG
36397: PUSH
36398: LD_INT 4
36400: NEG
36401: PUSH
36402: EMPTY
36403: LIST
36404: LIST
36405: PUSH
36406: LD_INT 4
36408: NEG
36409: PUSH
36410: LD_INT 3
36412: NEG
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 4
36420: NEG
36421: PUSH
36422: LD_INT 4
36424: NEG
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 4
36432: NEG
36433: PUSH
36434: LD_INT 5
36436: NEG
36437: PUSH
36438: EMPTY
36439: LIST
36440: LIST
36441: PUSH
36442: LD_INT 5
36444: NEG
36445: PUSH
36446: LD_INT 4
36448: NEG
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: PUSH
36454: LD_INT 5
36456: NEG
36457: PUSH
36458: LD_INT 5
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 5
36468: NEG
36469: PUSH
36470: LD_INT 6
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 6
36480: NEG
36481: PUSH
36482: LD_INT 5
36484: NEG
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 6
36492: NEG
36493: PUSH
36494: LD_INT 6
36496: NEG
36497: PUSH
36498: EMPTY
36499: LIST
36500: LIST
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
36516: LD_ADDR_VAR 0 41
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: LD_INT 2
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: LD_INT 3
36538: NEG
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 1
36546: PUSH
36547: LD_INT 2
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: LIST
36559: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
36560: LD_ADDR_VAR 0 42
36564: PUSH
36565: LD_INT 2
36567: PUSH
36568: LD_INT 0
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 2
36577: PUSH
36578: LD_INT 1
36580: NEG
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 3
36588: PUSH
36589: LD_INT 1
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: LIST
36600: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
36601: LD_ADDR_VAR 0 43
36605: PUSH
36606: LD_INT 2
36608: PUSH
36609: LD_INT 2
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 3
36618: PUSH
36619: LD_INT 2
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: PUSH
36626: LD_INT 2
36628: PUSH
36629: LD_INT 3
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: LIST
36640: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
36641: LD_ADDR_VAR 0 44
36645: PUSH
36646: LD_INT 0
36648: PUSH
36649: LD_INT 2
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: LD_INT 1
36658: PUSH
36659: LD_INT 3
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: LD_INT 1
36668: NEG
36669: PUSH
36670: LD_INT 2
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: LIST
36681: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36682: LD_ADDR_VAR 0 45
36686: PUSH
36687: LD_INT 2
36689: NEG
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 2
36700: NEG
36701: PUSH
36702: LD_INT 1
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 3
36711: NEG
36712: PUSH
36713: LD_INT 1
36715: NEG
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: EMPTY
36722: LIST
36723: LIST
36724: LIST
36725: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
36726: LD_ADDR_VAR 0 46
36730: PUSH
36731: LD_INT 2
36733: NEG
36734: PUSH
36735: LD_INT 2
36737: NEG
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 2
36745: NEG
36746: PUSH
36747: LD_INT 3
36749: NEG
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 3
36757: NEG
36758: PUSH
36759: LD_INT 2
36761: NEG
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: LIST
36771: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
36772: LD_ADDR_VAR 0 47
36776: PUSH
36777: LD_INT 2
36779: NEG
36780: PUSH
36781: LD_INT 3
36783: NEG
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 1
36791: NEG
36792: PUSH
36793: LD_INT 3
36795: NEG
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36805: LD_ADDR_VAR 0 48
36809: PUSH
36810: LD_INT 1
36812: PUSH
36813: LD_INT 2
36815: NEG
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 2
36823: PUSH
36824: LD_INT 1
36826: NEG
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
36836: LD_ADDR_VAR 0 49
36840: PUSH
36841: LD_INT 3
36843: PUSH
36844: LD_INT 1
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: LD_INT 3
36853: PUSH
36854: LD_INT 2
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
36865: LD_ADDR_VAR 0 50
36869: PUSH
36870: LD_INT 2
36872: PUSH
36873: LD_INT 3
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 1
36882: PUSH
36883: LD_INT 3
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36894: LD_ADDR_VAR 0 51
36898: PUSH
36899: LD_INT 1
36901: NEG
36902: PUSH
36903: LD_INT 2
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 2
36912: NEG
36913: PUSH
36914: LD_INT 1
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36925: LD_ADDR_VAR 0 52
36929: PUSH
36930: LD_INT 3
36932: NEG
36933: PUSH
36934: LD_INT 1
36936: NEG
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 3
36944: NEG
36945: PUSH
36946: LD_INT 2
36948: NEG
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36958: LD_ADDR_VAR 0 53
36962: PUSH
36963: LD_INT 1
36965: NEG
36966: PUSH
36967: LD_INT 3
36969: NEG
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PUSH
36975: LD_INT 0
36977: PUSH
36978: LD_INT 3
36980: NEG
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 1
36988: PUSH
36989: LD_INT 2
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: LIST
37001: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37002: LD_ADDR_VAR 0 54
37006: PUSH
37007: LD_INT 2
37009: PUSH
37010: LD_INT 1
37012: NEG
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 3
37020: PUSH
37021: LD_INT 0
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 3
37030: PUSH
37031: LD_INT 1
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: LIST
37042: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37043: LD_ADDR_VAR 0 55
37047: PUSH
37048: LD_INT 3
37050: PUSH
37051: LD_INT 2
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 3
37060: PUSH
37061: LD_INT 3
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 2
37070: PUSH
37071: LD_INT 3
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: LIST
37082: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37083: LD_ADDR_VAR 0 56
37087: PUSH
37088: LD_INT 1
37090: PUSH
37091: LD_INT 3
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 0
37100: PUSH
37101: LD_INT 3
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 1
37110: NEG
37111: PUSH
37112: LD_INT 2
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: LIST
37123: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37124: LD_ADDR_VAR 0 57
37128: PUSH
37129: LD_INT 2
37131: NEG
37132: PUSH
37133: LD_INT 1
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 3
37142: NEG
37143: PUSH
37144: LD_INT 0
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 3
37153: NEG
37154: PUSH
37155: LD_INT 1
37157: NEG
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: LIST
37167: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37168: LD_ADDR_VAR 0 58
37172: PUSH
37173: LD_INT 2
37175: NEG
37176: PUSH
37177: LD_INT 3
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 3
37187: NEG
37188: PUSH
37189: LD_INT 2
37191: NEG
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 3
37199: NEG
37200: PUSH
37201: LD_INT 3
37203: NEG
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: LIST
37213: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37214: LD_ADDR_VAR 0 59
37218: PUSH
37219: LD_INT 1
37221: NEG
37222: PUSH
37223: LD_INT 2
37225: NEG
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 0
37233: PUSH
37234: LD_INT 2
37236: NEG
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 1
37244: PUSH
37245: LD_INT 1
37247: NEG
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: LIST
37257: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37258: LD_ADDR_VAR 0 60
37262: PUSH
37263: LD_INT 1
37265: PUSH
37266: LD_INT 1
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 2
37276: PUSH
37277: LD_INT 0
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 2
37286: PUSH
37287: LD_INT 1
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: LIST
37298: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37299: LD_ADDR_VAR 0 61
37303: PUSH
37304: LD_INT 2
37306: PUSH
37307: LD_INT 1
37309: PUSH
37310: EMPTY
37311: LIST
37312: LIST
37313: PUSH
37314: LD_INT 2
37316: PUSH
37317: LD_INT 2
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 1
37326: PUSH
37327: LD_INT 2
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: LIST
37338: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37339: LD_ADDR_VAR 0 62
37343: PUSH
37344: LD_INT 1
37346: PUSH
37347: LD_INT 2
37349: PUSH
37350: EMPTY
37351: LIST
37352: LIST
37353: PUSH
37354: LD_INT 0
37356: PUSH
37357: LD_INT 2
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: LD_INT 1
37366: NEG
37367: PUSH
37368: LD_INT 1
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: LIST
37379: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37380: LD_ADDR_VAR 0 63
37384: PUSH
37385: LD_INT 1
37387: NEG
37388: PUSH
37389: LD_INT 1
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 2
37398: NEG
37399: PUSH
37400: LD_INT 0
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: LD_INT 2
37409: NEG
37410: PUSH
37411: LD_INT 1
37413: NEG
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: EMPTY
37420: LIST
37421: LIST
37422: LIST
37423: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37424: LD_ADDR_VAR 0 64
37428: PUSH
37429: LD_INT 1
37431: NEG
37432: PUSH
37433: LD_INT 2
37435: NEG
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 2
37443: NEG
37444: PUSH
37445: LD_INT 1
37447: NEG
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 2
37455: NEG
37456: PUSH
37457: LD_INT 2
37459: NEG
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: LIST
37469: ST_TO_ADDR
// end ; 2 :
37470: GO 40736
37472: LD_INT 2
37474: DOUBLE
37475: EQUAL
37476: IFTRUE 37480
37478: GO 40735
37480: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
37481: LD_ADDR_VAR 0 29
37485: PUSH
37486: LD_INT 4
37488: PUSH
37489: LD_INT 0
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 4
37498: PUSH
37499: LD_INT 1
37501: NEG
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: LD_INT 5
37509: PUSH
37510: LD_INT 0
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 5
37519: PUSH
37520: LD_INT 1
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 4
37529: PUSH
37530: LD_INT 1
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 3
37539: PUSH
37540: LD_INT 0
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 3
37549: PUSH
37550: LD_INT 1
37552: NEG
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: LD_INT 3
37560: PUSH
37561: LD_INT 2
37563: NEG
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: PUSH
37569: LD_INT 5
37571: PUSH
37572: LD_INT 2
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 3
37581: PUSH
37582: LD_INT 3
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 3
37591: PUSH
37592: LD_INT 2
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 4
37601: PUSH
37602: LD_INT 3
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 4
37611: PUSH
37612: LD_INT 4
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 3
37621: PUSH
37622: LD_INT 4
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 2
37631: PUSH
37632: LD_INT 3
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 2
37641: PUSH
37642: LD_INT 2
37644: PUSH
37645: EMPTY
37646: LIST
37647: LIST
37648: PUSH
37649: LD_INT 4
37651: PUSH
37652: LD_INT 2
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 2
37661: PUSH
37662: LD_INT 4
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: PUSH
37669: LD_INT 0
37671: PUSH
37672: LD_INT 4
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 0
37681: PUSH
37682: LD_INT 3
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 1
37691: PUSH
37692: LD_INT 4
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: PUSH
37702: LD_INT 5
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 0
37711: PUSH
37712: LD_INT 5
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 1
37721: NEG
37722: PUSH
37723: LD_INT 4
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 1
37732: NEG
37733: PUSH
37734: LD_INT 3
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: LD_INT 5
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PUSH
37751: LD_INT 2
37753: NEG
37754: PUSH
37755: LD_INT 3
37757: PUSH
37758: EMPTY
37759: LIST
37760: LIST
37761: PUSH
37762: LD_INT 3
37764: NEG
37765: PUSH
37766: LD_INT 0
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PUSH
37773: LD_INT 3
37775: NEG
37776: PUSH
37777: LD_INT 1
37779: NEG
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 2
37787: NEG
37788: PUSH
37789: LD_INT 0
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: LD_INT 1
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 3
37809: NEG
37810: PUSH
37811: LD_INT 1
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: PUSH
37818: LD_INT 4
37820: NEG
37821: PUSH
37822: LD_INT 0
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 4
37831: NEG
37832: PUSH
37833: LD_INT 1
37835: NEG
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 4
37843: NEG
37844: PUSH
37845: LD_INT 2
37847: NEG
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 2
37855: NEG
37856: PUSH
37857: LD_INT 2
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 4
37866: NEG
37867: PUSH
37868: LD_INT 4
37870: NEG
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PUSH
37876: LD_INT 4
37878: NEG
37879: PUSH
37880: LD_INT 5
37882: NEG
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 3
37890: NEG
37891: PUSH
37892: LD_INT 4
37894: NEG
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 3
37902: NEG
37903: PUSH
37904: LD_INT 3
37906: NEG
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 4
37914: NEG
37915: PUSH
37916: LD_INT 3
37918: NEG
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 5
37926: NEG
37927: PUSH
37928: LD_INT 4
37930: NEG
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: LD_INT 5
37938: NEG
37939: PUSH
37940: LD_INT 5
37942: NEG
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 3
37950: NEG
37951: PUSH
37952: LD_INT 5
37954: NEG
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 5
37962: NEG
37963: PUSH
37964: LD_INT 3
37966: NEG
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: LIST
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: LIST
38008: LIST
38009: LIST
38010: LIST
38011: LIST
38012: LIST
38013: LIST
38014: LIST
38015: LIST
38016: LIST
38017: LIST
38018: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38019: LD_ADDR_VAR 0 30
38023: PUSH
38024: LD_INT 4
38026: PUSH
38027: LD_INT 4
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: LD_INT 4
38036: PUSH
38037: LD_INT 3
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 5
38046: PUSH
38047: LD_INT 4
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 5
38056: PUSH
38057: LD_INT 5
38059: PUSH
38060: EMPTY
38061: LIST
38062: LIST
38063: PUSH
38064: LD_INT 4
38066: PUSH
38067: LD_INT 5
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: LD_INT 3
38076: PUSH
38077: LD_INT 4
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 3
38086: PUSH
38087: LD_INT 3
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 5
38096: PUSH
38097: LD_INT 3
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: PUSH
38104: LD_INT 3
38106: PUSH
38107: LD_INT 5
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: PUSH
38114: LD_INT 0
38116: PUSH
38117: LD_INT 3
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PUSH
38124: LD_INT 0
38126: PUSH
38127: LD_INT 2
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: PUSH
38137: LD_INT 3
38139: PUSH
38140: EMPTY
38141: LIST
38142: LIST
38143: PUSH
38144: LD_INT 1
38146: PUSH
38147: LD_INT 4
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 0
38156: PUSH
38157: LD_INT 4
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 1
38166: NEG
38167: PUSH
38168: LD_INT 3
38170: PUSH
38171: EMPTY
38172: LIST
38173: LIST
38174: PUSH
38175: LD_INT 1
38177: NEG
38178: PUSH
38179: LD_INT 2
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: PUSH
38186: LD_INT 2
38188: PUSH
38189: LD_INT 4
38191: PUSH
38192: EMPTY
38193: LIST
38194: LIST
38195: PUSH
38196: LD_INT 2
38198: NEG
38199: PUSH
38200: LD_INT 2
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 4
38209: NEG
38210: PUSH
38211: LD_INT 0
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 4
38220: NEG
38221: PUSH
38222: LD_INT 1
38224: NEG
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 3
38232: NEG
38233: PUSH
38234: LD_INT 0
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 3
38243: NEG
38244: PUSH
38245: LD_INT 1
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: LD_INT 4
38254: NEG
38255: PUSH
38256: LD_INT 1
38258: PUSH
38259: EMPTY
38260: LIST
38261: LIST
38262: PUSH
38263: LD_INT 5
38265: NEG
38266: PUSH
38267: LD_INT 0
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 5
38276: NEG
38277: PUSH
38278: LD_INT 1
38280: NEG
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 5
38288: NEG
38289: PUSH
38290: LD_INT 2
38292: NEG
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 3
38300: NEG
38301: PUSH
38302: LD_INT 2
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 3
38311: NEG
38312: PUSH
38313: LD_INT 3
38315: NEG
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 3
38323: NEG
38324: PUSH
38325: LD_INT 4
38327: NEG
38328: PUSH
38329: EMPTY
38330: LIST
38331: LIST
38332: PUSH
38333: LD_INT 2
38335: NEG
38336: PUSH
38337: LD_INT 3
38339: NEG
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: PUSH
38345: LD_INT 2
38347: NEG
38348: PUSH
38349: LD_INT 2
38351: NEG
38352: PUSH
38353: EMPTY
38354: LIST
38355: LIST
38356: PUSH
38357: LD_INT 3
38359: NEG
38360: PUSH
38361: LD_INT 2
38363: NEG
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 4
38371: NEG
38372: PUSH
38373: LD_INT 3
38375: NEG
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 4
38383: NEG
38384: PUSH
38385: LD_INT 4
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 2
38395: NEG
38396: PUSH
38397: LD_INT 4
38399: NEG
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 4
38407: NEG
38408: PUSH
38409: LD_INT 2
38411: NEG
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 0
38419: PUSH
38420: LD_INT 4
38422: NEG
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 0
38430: PUSH
38431: LD_INT 5
38433: NEG
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: PUSH
38439: LD_INT 1
38441: PUSH
38442: LD_INT 4
38444: NEG
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 1
38452: PUSH
38453: LD_INT 3
38455: NEG
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: PUSH
38461: LD_INT 0
38463: PUSH
38464: LD_INT 3
38466: NEG
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: LD_INT 4
38478: NEG
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 1
38486: NEG
38487: PUSH
38488: LD_INT 5
38490: NEG
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 2
38498: PUSH
38499: LD_INT 3
38501: NEG
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: LD_INT 5
38513: NEG
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: LIST
38526: LIST
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: LIST
38540: LIST
38541: LIST
38542: LIST
38543: LIST
38544: LIST
38545: LIST
38546: LIST
38547: LIST
38548: LIST
38549: LIST
38550: LIST
38551: LIST
38552: LIST
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
38566: LD_ADDR_VAR 0 31
38570: PUSH
38571: LD_INT 0
38573: PUSH
38574: LD_INT 4
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: LD_INT 0
38583: PUSH
38584: LD_INT 3
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: LD_INT 1
38593: PUSH
38594: LD_INT 4
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 1
38603: PUSH
38604: LD_INT 5
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 0
38613: PUSH
38614: LD_INT 5
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: LD_INT 1
38623: NEG
38624: PUSH
38625: LD_INT 4
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 1
38634: NEG
38635: PUSH
38636: LD_INT 3
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 2
38645: PUSH
38646: LD_INT 5
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 2
38655: NEG
38656: PUSH
38657: LD_INT 3
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 3
38666: NEG
38667: PUSH
38668: LD_INT 0
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: LD_INT 3
38677: NEG
38678: PUSH
38679: LD_INT 1
38681: NEG
38682: PUSH
38683: EMPTY
38684: LIST
38685: LIST
38686: PUSH
38687: LD_INT 2
38689: NEG
38690: PUSH
38691: LD_INT 0
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 2
38700: NEG
38701: PUSH
38702: LD_INT 1
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 3
38711: NEG
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 4
38722: NEG
38723: PUSH
38724: LD_INT 0
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 4
38733: NEG
38734: PUSH
38735: LD_INT 1
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 4
38745: NEG
38746: PUSH
38747: LD_INT 2
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 2
38757: NEG
38758: PUSH
38759: LD_INT 2
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 4
38768: NEG
38769: PUSH
38770: LD_INT 4
38772: NEG
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 4
38780: NEG
38781: PUSH
38782: LD_INT 5
38784: NEG
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 3
38792: NEG
38793: PUSH
38794: LD_INT 4
38796: NEG
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 3
38804: NEG
38805: PUSH
38806: LD_INT 3
38808: NEG
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 4
38816: NEG
38817: PUSH
38818: LD_INT 3
38820: NEG
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 5
38828: NEG
38829: PUSH
38830: LD_INT 4
38832: NEG
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: PUSH
38838: LD_INT 5
38840: NEG
38841: PUSH
38842: LD_INT 5
38844: NEG
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 3
38852: NEG
38853: PUSH
38854: LD_INT 5
38856: NEG
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 5
38864: NEG
38865: PUSH
38866: LD_INT 3
38868: NEG
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 0
38876: PUSH
38877: LD_INT 3
38879: NEG
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 0
38887: PUSH
38888: LD_INT 4
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: LD_INT 1
38898: PUSH
38899: LD_INT 3
38901: NEG
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: LD_INT 2
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 0
38920: PUSH
38921: LD_INT 2
38923: NEG
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 1
38931: NEG
38932: PUSH
38933: LD_INT 3
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 1
38943: NEG
38944: PUSH
38945: LD_INT 4
38947: NEG
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 2
38955: PUSH
38956: LD_INT 2
38958: NEG
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PUSH
38964: LD_INT 2
38966: NEG
38967: PUSH
38968: LD_INT 4
38970: NEG
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: PUSH
38976: LD_INT 4
38978: PUSH
38979: LD_INT 0
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 4
38988: PUSH
38989: LD_INT 1
38991: NEG
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PUSH
38997: LD_INT 5
38999: PUSH
39000: LD_INT 0
39002: PUSH
39003: EMPTY
39004: LIST
39005: LIST
39006: PUSH
39007: LD_INT 5
39009: PUSH
39010: LD_INT 1
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 4
39019: PUSH
39020: LD_INT 1
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 3
39029: PUSH
39030: LD_INT 0
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PUSH
39037: LD_INT 3
39039: PUSH
39040: LD_INT 1
39042: NEG
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: LD_INT 3
39050: PUSH
39051: LD_INT 2
39053: NEG
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: PUSH
39059: LD_INT 5
39061: PUSH
39062: LD_INT 2
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: LIST
39087: LIST
39088: LIST
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: LIST
39115: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39116: LD_ADDR_VAR 0 32
39120: PUSH
39121: LD_INT 4
39123: NEG
39124: PUSH
39125: LD_INT 0
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 4
39134: NEG
39135: PUSH
39136: LD_INT 1
39138: NEG
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 3
39146: NEG
39147: PUSH
39148: LD_INT 0
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 3
39157: NEG
39158: PUSH
39159: LD_INT 1
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 4
39168: NEG
39169: PUSH
39170: LD_INT 1
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 5
39179: NEG
39180: PUSH
39181: LD_INT 0
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: LD_INT 5
39190: NEG
39191: PUSH
39192: LD_INT 1
39194: NEG
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 5
39202: NEG
39203: PUSH
39204: LD_INT 2
39206: NEG
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 3
39214: NEG
39215: PUSH
39216: LD_INT 2
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: LD_INT 3
39225: NEG
39226: PUSH
39227: LD_INT 3
39229: NEG
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 3
39237: NEG
39238: PUSH
39239: LD_INT 4
39241: NEG
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 2
39249: NEG
39250: PUSH
39251: LD_INT 3
39253: NEG
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: LD_INT 2
39261: NEG
39262: PUSH
39263: LD_INT 2
39265: NEG
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: PUSH
39271: LD_INT 3
39273: NEG
39274: PUSH
39275: LD_INT 2
39277: NEG
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: LD_INT 4
39285: NEG
39286: PUSH
39287: LD_INT 3
39289: NEG
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 4
39297: NEG
39298: PUSH
39299: LD_INT 4
39301: NEG
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: LD_INT 2
39309: NEG
39310: PUSH
39311: LD_INT 4
39313: NEG
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 4
39321: NEG
39322: PUSH
39323: LD_INT 2
39325: NEG
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: LD_INT 0
39333: PUSH
39334: LD_INT 4
39336: NEG
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 0
39344: PUSH
39345: LD_INT 5
39347: NEG
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 1
39355: PUSH
39356: LD_INT 4
39358: NEG
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 1
39366: PUSH
39367: LD_INT 3
39369: NEG
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 0
39377: PUSH
39378: LD_INT 3
39380: NEG
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PUSH
39386: LD_INT 1
39388: NEG
39389: PUSH
39390: LD_INT 4
39392: NEG
39393: PUSH
39394: EMPTY
39395: LIST
39396: LIST
39397: PUSH
39398: LD_INT 1
39400: NEG
39401: PUSH
39402: LD_INT 5
39404: NEG
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: LD_INT 2
39412: PUSH
39413: LD_INT 3
39415: NEG
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 2
39423: NEG
39424: PUSH
39425: LD_INT 5
39427: NEG
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 3
39435: PUSH
39436: LD_INT 0
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 3
39445: PUSH
39446: LD_INT 1
39448: NEG
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 4
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 4
39466: PUSH
39467: LD_INT 1
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 3
39476: PUSH
39477: LD_INT 1
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: LD_INT 0
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 2
39496: PUSH
39497: LD_INT 1
39499: NEG
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 2
39507: PUSH
39508: LD_INT 2
39510: NEG
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PUSH
39516: LD_INT 4
39518: PUSH
39519: LD_INT 2
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 4
39528: PUSH
39529: LD_INT 4
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 4
39538: PUSH
39539: LD_INT 3
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 5
39548: PUSH
39549: LD_INT 4
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 5
39558: PUSH
39559: LD_INT 5
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 4
39568: PUSH
39569: LD_INT 5
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 3
39578: PUSH
39579: LD_INT 4
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 3
39588: PUSH
39589: LD_INT 3
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 5
39598: PUSH
39599: LD_INT 3
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 3
39608: PUSH
39609: LD_INT 5
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: LIST
39658: LIST
39659: LIST
39660: LIST
39661: LIST
39662: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
39663: LD_ADDR_VAR 0 33
39667: PUSH
39668: LD_INT 4
39670: NEG
39671: PUSH
39672: LD_INT 4
39674: NEG
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 4
39682: NEG
39683: PUSH
39684: LD_INT 5
39686: NEG
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 3
39694: NEG
39695: PUSH
39696: LD_INT 4
39698: NEG
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 3
39706: NEG
39707: PUSH
39708: LD_INT 3
39710: NEG
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 4
39718: NEG
39719: PUSH
39720: LD_INT 3
39722: NEG
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: PUSH
39728: LD_INT 5
39730: NEG
39731: PUSH
39732: LD_INT 4
39734: NEG
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: LD_INT 5
39742: NEG
39743: PUSH
39744: LD_INT 5
39746: NEG
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 3
39754: NEG
39755: PUSH
39756: LD_INT 5
39758: NEG
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 5
39766: NEG
39767: PUSH
39768: LD_INT 3
39770: NEG
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 0
39778: PUSH
39779: LD_INT 3
39781: NEG
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PUSH
39787: LD_INT 0
39789: PUSH
39790: LD_INT 4
39792: NEG
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: LD_INT 1
39800: PUSH
39801: LD_INT 3
39803: NEG
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 1
39811: PUSH
39812: LD_INT 2
39814: NEG
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 0
39822: PUSH
39823: LD_INT 2
39825: NEG
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 1
39833: NEG
39834: PUSH
39835: LD_INT 3
39837: NEG
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: LD_INT 1
39845: NEG
39846: PUSH
39847: LD_INT 4
39849: NEG
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 2
39857: PUSH
39858: LD_INT 2
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 2
39868: NEG
39869: PUSH
39870: LD_INT 4
39872: NEG
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: PUSH
39878: LD_INT 4
39880: PUSH
39881: LD_INT 0
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 4
39890: PUSH
39891: LD_INT 1
39893: NEG
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 5
39901: PUSH
39902: LD_INT 0
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 5
39911: PUSH
39912: LD_INT 1
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 4
39921: PUSH
39922: LD_INT 1
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 3
39931: PUSH
39932: LD_INT 0
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 3
39941: PUSH
39942: LD_INT 1
39944: NEG
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 3
39952: PUSH
39953: LD_INT 2
39955: NEG
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 5
39963: PUSH
39964: LD_INT 2
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 3
39973: PUSH
39974: LD_INT 3
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 3
39983: PUSH
39984: LD_INT 2
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 4
39993: PUSH
39994: LD_INT 3
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 4
40003: PUSH
40004: LD_INT 4
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: LD_INT 3
40013: PUSH
40014: LD_INT 4
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 2
40023: PUSH
40024: LD_INT 3
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 2
40033: PUSH
40034: LD_INT 2
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 4
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 2
40053: PUSH
40054: LD_INT 4
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 0
40063: PUSH
40064: LD_INT 4
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 0
40073: PUSH
40074: LD_INT 3
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 1
40083: PUSH
40084: LD_INT 4
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: LD_INT 5
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 0
40103: PUSH
40104: LD_INT 5
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 1
40113: NEG
40114: PUSH
40115: LD_INT 4
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: LD_INT 1
40124: NEG
40125: PUSH
40126: LD_INT 3
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: LD_INT 2
40135: PUSH
40136: LD_INT 5
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 2
40145: NEG
40146: PUSH
40147: LD_INT 3
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: LIST
40162: LIST
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40201: LD_ADDR_VAR 0 34
40205: PUSH
40206: LD_INT 0
40208: PUSH
40209: LD_INT 4
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 0
40219: PUSH
40220: LD_INT 5
40222: NEG
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 1
40230: PUSH
40231: LD_INT 4
40233: NEG
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 1
40241: PUSH
40242: LD_INT 3
40244: NEG
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 0
40252: PUSH
40253: LD_INT 3
40255: NEG
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 1
40263: NEG
40264: PUSH
40265: LD_INT 4
40267: NEG
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: LD_INT 1
40275: NEG
40276: PUSH
40277: LD_INT 5
40279: NEG
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 2
40287: PUSH
40288: LD_INT 3
40290: NEG
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 2
40298: NEG
40299: PUSH
40300: LD_INT 5
40302: NEG
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 3
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: EMPTY
40315: LIST
40316: LIST
40317: PUSH
40318: LD_INT 3
40320: PUSH
40321: LD_INT 1
40323: NEG
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 4
40331: PUSH
40332: LD_INT 0
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 4
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: LD_INT 3
40351: PUSH
40352: LD_INT 1
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: LD_INT 2
40361: PUSH
40362: LD_INT 0
40364: PUSH
40365: EMPTY
40366: LIST
40367: LIST
40368: PUSH
40369: LD_INT 2
40371: PUSH
40372: LD_INT 1
40374: NEG
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: LD_INT 2
40382: PUSH
40383: LD_INT 2
40385: NEG
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 4
40393: PUSH
40394: LD_INT 2
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 4
40403: PUSH
40404: LD_INT 4
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 4
40413: PUSH
40414: LD_INT 3
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 5
40423: PUSH
40424: LD_INT 4
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 5
40433: PUSH
40434: LD_INT 5
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 4
40443: PUSH
40444: LD_INT 5
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 3
40453: PUSH
40454: LD_INT 4
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 3
40463: PUSH
40464: LD_INT 3
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 5
40473: PUSH
40474: LD_INT 3
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 3
40483: PUSH
40484: LD_INT 5
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 0
40493: PUSH
40494: LD_INT 3
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 0
40503: PUSH
40504: LD_INT 2
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 1
40513: PUSH
40514: LD_INT 3
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: LD_INT 4
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 0
40533: PUSH
40534: LD_INT 4
40536: PUSH
40537: EMPTY
40538: LIST
40539: LIST
40540: PUSH
40541: LD_INT 1
40543: NEG
40544: PUSH
40545: LD_INT 3
40547: PUSH
40548: EMPTY
40549: LIST
40550: LIST
40551: PUSH
40552: LD_INT 1
40554: NEG
40555: PUSH
40556: LD_INT 2
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 2
40565: PUSH
40566: LD_INT 4
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 2
40575: NEG
40576: PUSH
40577: LD_INT 2
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 4
40586: NEG
40587: PUSH
40588: LD_INT 0
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 4
40597: NEG
40598: PUSH
40599: LD_INT 1
40601: NEG
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 3
40609: NEG
40610: PUSH
40611: LD_INT 0
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: LD_INT 3
40620: NEG
40621: PUSH
40622: LD_INT 1
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 4
40631: NEG
40632: PUSH
40633: LD_INT 1
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 5
40642: NEG
40643: PUSH
40644: LD_INT 0
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 5
40653: NEG
40654: PUSH
40655: LD_INT 1
40657: NEG
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 5
40665: NEG
40666: PUSH
40667: LD_INT 2
40669: NEG
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 3
40677: NEG
40678: PUSH
40679: LD_INT 2
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: LIST
40728: LIST
40729: LIST
40730: LIST
40731: LIST
40732: ST_TO_ADDR
// end ; end ;
40733: GO 40736
40735: POP
// case btype of b_depot , b_warehouse :
40736: LD_VAR 0 1
40740: PUSH
40741: LD_INT 0
40743: DOUBLE
40744: EQUAL
40745: IFTRUE 40755
40747: LD_INT 1
40749: DOUBLE
40750: EQUAL
40751: IFTRUE 40755
40753: GO 40956
40755: POP
// case nation of nation_american :
40756: LD_VAR 0 5
40760: PUSH
40761: LD_INT 1
40763: DOUBLE
40764: EQUAL
40765: IFTRUE 40769
40767: GO 40825
40769: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
40770: LD_ADDR_VAR 0 9
40774: PUSH
40775: LD_VAR 0 11
40779: PUSH
40780: LD_VAR 0 12
40784: PUSH
40785: LD_VAR 0 13
40789: PUSH
40790: LD_VAR 0 14
40794: PUSH
40795: LD_VAR 0 15
40799: PUSH
40800: LD_VAR 0 16
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: LIST
40809: LIST
40810: LIST
40811: LIST
40812: PUSH
40813: LD_VAR 0 4
40817: PUSH
40818: LD_INT 1
40820: PLUS
40821: ARRAY
40822: ST_TO_ADDR
40823: GO 40954
40825: LD_INT 2
40827: DOUBLE
40828: EQUAL
40829: IFTRUE 40833
40831: GO 40889
40833: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
40834: LD_ADDR_VAR 0 9
40838: PUSH
40839: LD_VAR 0 17
40843: PUSH
40844: LD_VAR 0 18
40848: PUSH
40849: LD_VAR 0 19
40853: PUSH
40854: LD_VAR 0 20
40858: PUSH
40859: LD_VAR 0 21
40863: PUSH
40864: LD_VAR 0 22
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: LIST
40873: LIST
40874: LIST
40875: LIST
40876: PUSH
40877: LD_VAR 0 4
40881: PUSH
40882: LD_INT 1
40884: PLUS
40885: ARRAY
40886: ST_TO_ADDR
40887: GO 40954
40889: LD_INT 3
40891: DOUBLE
40892: EQUAL
40893: IFTRUE 40897
40895: GO 40953
40897: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
40898: LD_ADDR_VAR 0 9
40902: PUSH
40903: LD_VAR 0 23
40907: PUSH
40908: LD_VAR 0 24
40912: PUSH
40913: LD_VAR 0 25
40917: PUSH
40918: LD_VAR 0 26
40922: PUSH
40923: LD_VAR 0 27
40927: PUSH
40928: LD_VAR 0 28
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: LIST
40937: LIST
40938: LIST
40939: LIST
40940: PUSH
40941: LD_VAR 0 4
40945: PUSH
40946: LD_INT 1
40948: PLUS
40949: ARRAY
40950: ST_TO_ADDR
40951: GO 40954
40953: POP
40954: GO 41509
40956: LD_INT 2
40958: DOUBLE
40959: EQUAL
40960: IFTRUE 40970
40962: LD_INT 3
40964: DOUBLE
40965: EQUAL
40966: IFTRUE 40970
40968: GO 41026
40970: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
40971: LD_ADDR_VAR 0 9
40975: PUSH
40976: LD_VAR 0 29
40980: PUSH
40981: LD_VAR 0 30
40985: PUSH
40986: LD_VAR 0 31
40990: PUSH
40991: LD_VAR 0 32
40995: PUSH
40996: LD_VAR 0 33
41000: PUSH
41001: LD_VAR 0 34
41005: PUSH
41006: EMPTY
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: PUSH
41014: LD_VAR 0 4
41018: PUSH
41019: LD_INT 1
41021: PLUS
41022: ARRAY
41023: ST_TO_ADDR
41024: GO 41509
41026: LD_INT 16
41028: DOUBLE
41029: EQUAL
41030: IFTRUE 41088
41032: LD_INT 17
41034: DOUBLE
41035: EQUAL
41036: IFTRUE 41088
41038: LD_INT 18
41040: DOUBLE
41041: EQUAL
41042: IFTRUE 41088
41044: LD_INT 19
41046: DOUBLE
41047: EQUAL
41048: IFTRUE 41088
41050: LD_INT 22
41052: DOUBLE
41053: EQUAL
41054: IFTRUE 41088
41056: LD_INT 20
41058: DOUBLE
41059: EQUAL
41060: IFTRUE 41088
41062: LD_INT 21
41064: DOUBLE
41065: EQUAL
41066: IFTRUE 41088
41068: LD_INT 23
41070: DOUBLE
41071: EQUAL
41072: IFTRUE 41088
41074: LD_INT 24
41076: DOUBLE
41077: EQUAL
41078: IFTRUE 41088
41080: LD_INT 25
41082: DOUBLE
41083: EQUAL
41084: IFTRUE 41088
41086: GO 41144
41088: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41089: LD_ADDR_VAR 0 9
41093: PUSH
41094: LD_VAR 0 35
41098: PUSH
41099: LD_VAR 0 36
41103: PUSH
41104: LD_VAR 0 37
41108: PUSH
41109: LD_VAR 0 38
41113: PUSH
41114: LD_VAR 0 39
41118: PUSH
41119: LD_VAR 0 40
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: LIST
41128: LIST
41129: LIST
41130: LIST
41131: PUSH
41132: LD_VAR 0 4
41136: PUSH
41137: LD_INT 1
41139: PLUS
41140: ARRAY
41141: ST_TO_ADDR
41142: GO 41509
41144: LD_INT 6
41146: DOUBLE
41147: EQUAL
41148: IFTRUE 41200
41150: LD_INT 7
41152: DOUBLE
41153: EQUAL
41154: IFTRUE 41200
41156: LD_INT 8
41158: DOUBLE
41159: EQUAL
41160: IFTRUE 41200
41162: LD_INT 13
41164: DOUBLE
41165: EQUAL
41166: IFTRUE 41200
41168: LD_INT 12
41170: DOUBLE
41171: EQUAL
41172: IFTRUE 41200
41174: LD_INT 15
41176: DOUBLE
41177: EQUAL
41178: IFTRUE 41200
41180: LD_INT 11
41182: DOUBLE
41183: EQUAL
41184: IFTRUE 41200
41186: LD_INT 14
41188: DOUBLE
41189: EQUAL
41190: IFTRUE 41200
41192: LD_INT 10
41194: DOUBLE
41195: EQUAL
41196: IFTRUE 41200
41198: GO 41256
41200: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41201: LD_ADDR_VAR 0 9
41205: PUSH
41206: LD_VAR 0 41
41210: PUSH
41211: LD_VAR 0 42
41215: PUSH
41216: LD_VAR 0 43
41220: PUSH
41221: LD_VAR 0 44
41225: PUSH
41226: LD_VAR 0 45
41230: PUSH
41231: LD_VAR 0 46
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: PUSH
41244: LD_VAR 0 4
41248: PUSH
41249: LD_INT 1
41251: PLUS
41252: ARRAY
41253: ST_TO_ADDR
41254: GO 41509
41256: LD_INT 36
41258: DOUBLE
41259: EQUAL
41260: IFTRUE 41264
41262: GO 41320
41264: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
41265: LD_ADDR_VAR 0 9
41269: PUSH
41270: LD_VAR 0 47
41274: PUSH
41275: LD_VAR 0 48
41279: PUSH
41280: LD_VAR 0 49
41284: PUSH
41285: LD_VAR 0 50
41289: PUSH
41290: LD_VAR 0 51
41294: PUSH
41295: LD_VAR 0 52
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: LIST
41304: LIST
41305: LIST
41306: LIST
41307: PUSH
41308: LD_VAR 0 4
41312: PUSH
41313: LD_INT 1
41315: PLUS
41316: ARRAY
41317: ST_TO_ADDR
41318: GO 41509
41320: LD_INT 4
41322: DOUBLE
41323: EQUAL
41324: IFTRUE 41346
41326: LD_INT 5
41328: DOUBLE
41329: EQUAL
41330: IFTRUE 41346
41332: LD_INT 34
41334: DOUBLE
41335: EQUAL
41336: IFTRUE 41346
41338: LD_INT 37
41340: DOUBLE
41341: EQUAL
41342: IFTRUE 41346
41344: GO 41402
41346: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
41347: LD_ADDR_VAR 0 9
41351: PUSH
41352: LD_VAR 0 53
41356: PUSH
41357: LD_VAR 0 54
41361: PUSH
41362: LD_VAR 0 55
41366: PUSH
41367: LD_VAR 0 56
41371: PUSH
41372: LD_VAR 0 57
41376: PUSH
41377: LD_VAR 0 58
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: LIST
41386: LIST
41387: LIST
41388: LIST
41389: PUSH
41390: LD_VAR 0 4
41394: PUSH
41395: LD_INT 1
41397: PLUS
41398: ARRAY
41399: ST_TO_ADDR
41400: GO 41509
41402: LD_INT 31
41404: DOUBLE
41405: EQUAL
41406: IFTRUE 41452
41408: LD_INT 32
41410: DOUBLE
41411: EQUAL
41412: IFTRUE 41452
41414: LD_INT 33
41416: DOUBLE
41417: EQUAL
41418: IFTRUE 41452
41420: LD_INT 27
41422: DOUBLE
41423: EQUAL
41424: IFTRUE 41452
41426: LD_INT 26
41428: DOUBLE
41429: EQUAL
41430: IFTRUE 41452
41432: LD_INT 28
41434: DOUBLE
41435: EQUAL
41436: IFTRUE 41452
41438: LD_INT 29
41440: DOUBLE
41441: EQUAL
41442: IFTRUE 41452
41444: LD_INT 30
41446: DOUBLE
41447: EQUAL
41448: IFTRUE 41452
41450: GO 41508
41452: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
41453: LD_ADDR_VAR 0 9
41457: PUSH
41458: LD_VAR 0 59
41462: PUSH
41463: LD_VAR 0 60
41467: PUSH
41468: LD_VAR 0 61
41472: PUSH
41473: LD_VAR 0 62
41477: PUSH
41478: LD_VAR 0 63
41482: PUSH
41483: LD_VAR 0 64
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: LIST
41492: LIST
41493: LIST
41494: LIST
41495: PUSH
41496: LD_VAR 0 4
41500: PUSH
41501: LD_INT 1
41503: PLUS
41504: ARRAY
41505: ST_TO_ADDR
41506: GO 41509
41508: POP
// temp_list2 = [ ] ;
41509: LD_ADDR_VAR 0 10
41513: PUSH
41514: EMPTY
41515: ST_TO_ADDR
// for i in temp_list do
41516: LD_ADDR_VAR 0 8
41520: PUSH
41521: LD_VAR 0 9
41525: PUSH
41526: FOR_IN
41527: IFFALSE 41579
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
41529: LD_ADDR_VAR 0 10
41533: PUSH
41534: LD_VAR 0 10
41538: PUSH
41539: LD_VAR 0 8
41543: PUSH
41544: LD_INT 1
41546: ARRAY
41547: PUSH
41548: LD_VAR 0 2
41552: PLUS
41553: PUSH
41554: LD_VAR 0 8
41558: PUSH
41559: LD_INT 2
41561: ARRAY
41562: PUSH
41563: LD_VAR 0 3
41567: PLUS
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: EMPTY
41574: LIST
41575: ADD
41576: ST_TO_ADDR
41577: GO 41526
41579: POP
41580: POP
// result = temp_list2 ;
41581: LD_ADDR_VAR 0 7
41585: PUSH
41586: LD_VAR 0 10
41590: ST_TO_ADDR
// end ;
41591: LD_VAR 0 7
41595: RET
// export function EnemyInRange ( unit , dist ) ; begin
41596: LD_INT 0
41598: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
41599: LD_ADDR_VAR 0 3
41603: PUSH
41604: LD_VAR 0 1
41608: PPUSH
41609: CALL_OW 255
41613: PPUSH
41614: LD_VAR 0 1
41618: PPUSH
41619: CALL_OW 250
41623: PPUSH
41624: LD_VAR 0 1
41628: PPUSH
41629: CALL_OW 251
41633: PPUSH
41634: LD_VAR 0 2
41638: PPUSH
41639: CALL 15700 0 4
41643: PUSH
41644: LD_INT 4
41646: ARRAY
41647: ST_TO_ADDR
// end ;
41648: LD_VAR 0 3
41652: RET
// export function PlayerSeeMe ( unit ) ; begin
41653: LD_INT 0
41655: PPUSH
// result := See ( your_side , unit ) ;
41656: LD_ADDR_VAR 0 2
41660: PUSH
41661: LD_OWVAR 2
41665: PPUSH
41666: LD_VAR 0 1
41670: PPUSH
41671: CALL_OW 292
41675: ST_TO_ADDR
// end ;
41676: LD_VAR 0 2
41680: RET
// export function ReverseDir ( unit ) ; begin
41681: LD_INT 0
41683: PPUSH
// if not unit then
41684: LD_VAR 0 1
41688: NOT
41689: IFFALSE 41693
// exit ;
41691: GO 41716
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
41693: LD_ADDR_VAR 0 2
41697: PUSH
41698: LD_VAR 0 1
41702: PPUSH
41703: CALL_OW 254
41707: PUSH
41708: LD_INT 3
41710: PLUS
41711: PUSH
41712: LD_INT 6
41714: MOD
41715: ST_TO_ADDR
// end ;
41716: LD_VAR 0 2
41720: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
41721: LD_INT 0
41723: PPUSH
41724: PPUSH
41725: PPUSH
41726: PPUSH
41727: PPUSH
// if not hexes then
41728: LD_VAR 0 2
41732: NOT
41733: IFFALSE 41737
// exit ;
41735: GO 41885
// dist := 9999 ;
41737: LD_ADDR_VAR 0 5
41741: PUSH
41742: LD_INT 9999
41744: ST_TO_ADDR
// for i = 1 to hexes do
41745: LD_ADDR_VAR 0 4
41749: PUSH
41750: DOUBLE
41751: LD_INT 1
41753: DEC
41754: ST_TO_ADDR
41755: LD_VAR 0 2
41759: PUSH
41760: FOR_TO
41761: IFFALSE 41873
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
41763: LD_VAR 0 1
41767: PPUSH
41768: LD_VAR 0 2
41772: PUSH
41773: LD_VAR 0 4
41777: ARRAY
41778: PUSH
41779: LD_INT 1
41781: ARRAY
41782: PPUSH
41783: LD_VAR 0 2
41787: PUSH
41788: LD_VAR 0 4
41792: ARRAY
41793: PUSH
41794: LD_INT 2
41796: ARRAY
41797: PPUSH
41798: CALL_OW 297
41802: PUSH
41803: LD_VAR 0 5
41807: LESS
41808: IFFALSE 41871
// begin hex := hexes [ i ] ;
41810: LD_ADDR_VAR 0 7
41814: PUSH
41815: LD_VAR 0 2
41819: PUSH
41820: LD_VAR 0 4
41824: ARRAY
41825: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
41826: LD_ADDR_VAR 0 5
41830: PUSH
41831: LD_VAR 0 1
41835: PPUSH
41836: LD_VAR 0 2
41840: PUSH
41841: LD_VAR 0 4
41845: ARRAY
41846: PUSH
41847: LD_INT 1
41849: ARRAY
41850: PPUSH
41851: LD_VAR 0 2
41855: PUSH
41856: LD_VAR 0 4
41860: ARRAY
41861: PUSH
41862: LD_INT 2
41864: ARRAY
41865: PPUSH
41866: CALL_OW 297
41870: ST_TO_ADDR
// end ; end ;
41871: GO 41760
41873: POP
41874: POP
// result := hex ;
41875: LD_ADDR_VAR 0 3
41879: PUSH
41880: LD_VAR 0 7
41884: ST_TO_ADDR
// end ;
41885: LD_VAR 0 3
41889: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
41890: LD_INT 0
41892: PPUSH
41893: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
41894: LD_VAR 0 1
41898: NOT
41899: PUSH
41900: LD_VAR 0 1
41904: PUSH
41905: LD_INT 21
41907: PUSH
41908: LD_INT 2
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 23
41917: PUSH
41918: LD_INT 2
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PPUSH
41929: CALL_OW 69
41933: IN
41934: NOT
41935: OR
41936: IFFALSE 41940
// exit ;
41938: GO 41987
// for i = 1 to 3 do
41940: LD_ADDR_VAR 0 3
41944: PUSH
41945: DOUBLE
41946: LD_INT 1
41948: DEC
41949: ST_TO_ADDR
41950: LD_INT 3
41952: PUSH
41953: FOR_TO
41954: IFFALSE 41985
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
41956: LD_VAR 0 1
41960: PPUSH
41961: CALL_OW 250
41965: PPUSH
41966: LD_VAR 0 1
41970: PPUSH
41971: CALL_OW 251
41975: PPUSH
41976: LD_INT 1
41978: PPUSH
41979: CALL_OW 453
41983: GO 41953
41985: POP
41986: POP
// end ;
41987: LD_VAR 0 2
41991: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
41992: LD_INT 0
41994: PPUSH
41995: PPUSH
41996: PPUSH
41997: PPUSH
41998: PPUSH
41999: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42000: LD_VAR 0 1
42004: NOT
42005: PUSH
42006: LD_VAR 0 2
42010: NOT
42011: OR
42012: PUSH
42013: LD_VAR 0 1
42017: PPUSH
42018: CALL_OW 314
42022: OR
42023: IFFALSE 42027
// exit ;
42025: GO 42468
// x := GetX ( enemy_unit ) ;
42027: LD_ADDR_VAR 0 7
42031: PUSH
42032: LD_VAR 0 2
42036: PPUSH
42037: CALL_OW 250
42041: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42042: LD_ADDR_VAR 0 8
42046: PUSH
42047: LD_VAR 0 2
42051: PPUSH
42052: CALL_OW 251
42056: ST_TO_ADDR
// if not x or not y then
42057: LD_VAR 0 7
42061: NOT
42062: PUSH
42063: LD_VAR 0 8
42067: NOT
42068: OR
42069: IFFALSE 42073
// exit ;
42071: GO 42468
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42073: LD_ADDR_VAR 0 6
42077: PUSH
42078: LD_VAR 0 7
42082: PPUSH
42083: LD_INT 0
42085: PPUSH
42086: LD_INT 4
42088: PPUSH
42089: CALL_OW 272
42093: PUSH
42094: LD_VAR 0 8
42098: PPUSH
42099: LD_INT 0
42101: PPUSH
42102: LD_INT 4
42104: PPUSH
42105: CALL_OW 273
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: PUSH
42114: LD_VAR 0 7
42118: PPUSH
42119: LD_INT 1
42121: PPUSH
42122: LD_INT 4
42124: PPUSH
42125: CALL_OW 272
42129: PUSH
42130: LD_VAR 0 8
42134: PPUSH
42135: LD_INT 1
42137: PPUSH
42138: LD_INT 4
42140: PPUSH
42141: CALL_OW 273
42145: PUSH
42146: EMPTY
42147: LIST
42148: LIST
42149: PUSH
42150: LD_VAR 0 7
42154: PPUSH
42155: LD_INT 2
42157: PPUSH
42158: LD_INT 4
42160: PPUSH
42161: CALL_OW 272
42165: PUSH
42166: LD_VAR 0 8
42170: PPUSH
42171: LD_INT 2
42173: PPUSH
42174: LD_INT 4
42176: PPUSH
42177: CALL_OW 273
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: LD_VAR 0 7
42190: PPUSH
42191: LD_INT 3
42193: PPUSH
42194: LD_INT 4
42196: PPUSH
42197: CALL_OW 272
42201: PUSH
42202: LD_VAR 0 8
42206: PPUSH
42207: LD_INT 3
42209: PPUSH
42210: LD_INT 4
42212: PPUSH
42213: CALL_OW 273
42217: PUSH
42218: EMPTY
42219: LIST
42220: LIST
42221: PUSH
42222: LD_VAR 0 7
42226: PPUSH
42227: LD_INT 4
42229: PPUSH
42230: LD_INT 4
42232: PPUSH
42233: CALL_OW 272
42237: PUSH
42238: LD_VAR 0 8
42242: PPUSH
42243: LD_INT 4
42245: PPUSH
42246: LD_INT 4
42248: PPUSH
42249: CALL_OW 273
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: LD_VAR 0 7
42262: PPUSH
42263: LD_INT 5
42265: PPUSH
42266: LD_INT 4
42268: PPUSH
42269: CALL_OW 272
42273: PUSH
42274: LD_VAR 0 8
42278: PPUSH
42279: LD_INT 5
42281: PPUSH
42282: LD_INT 4
42284: PPUSH
42285: CALL_OW 273
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: ST_TO_ADDR
// for i = tmp downto 1 do
42302: LD_ADDR_VAR 0 4
42306: PUSH
42307: DOUBLE
42308: LD_VAR 0 6
42312: INC
42313: ST_TO_ADDR
42314: LD_INT 1
42316: PUSH
42317: FOR_DOWNTO
42318: IFFALSE 42419
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
42320: LD_VAR 0 6
42324: PUSH
42325: LD_VAR 0 4
42329: ARRAY
42330: PUSH
42331: LD_INT 1
42333: ARRAY
42334: PPUSH
42335: LD_VAR 0 6
42339: PUSH
42340: LD_VAR 0 4
42344: ARRAY
42345: PUSH
42346: LD_INT 2
42348: ARRAY
42349: PPUSH
42350: CALL_OW 488
42354: NOT
42355: PUSH
42356: LD_VAR 0 6
42360: PUSH
42361: LD_VAR 0 4
42365: ARRAY
42366: PUSH
42367: LD_INT 1
42369: ARRAY
42370: PPUSH
42371: LD_VAR 0 6
42375: PUSH
42376: LD_VAR 0 4
42380: ARRAY
42381: PUSH
42382: LD_INT 2
42384: ARRAY
42385: PPUSH
42386: CALL_OW 428
42390: PUSH
42391: LD_INT 0
42393: NONEQUAL
42394: OR
42395: IFFALSE 42417
// tmp := Delete ( tmp , i ) ;
42397: LD_ADDR_VAR 0 6
42401: PUSH
42402: LD_VAR 0 6
42406: PPUSH
42407: LD_VAR 0 4
42411: PPUSH
42412: CALL_OW 3
42416: ST_TO_ADDR
42417: GO 42317
42419: POP
42420: POP
// j := GetClosestHex ( unit , tmp ) ;
42421: LD_ADDR_VAR 0 5
42425: PUSH
42426: LD_VAR 0 1
42430: PPUSH
42431: LD_VAR 0 6
42435: PPUSH
42436: CALL 41721 0 2
42440: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
42441: LD_VAR 0 1
42445: PPUSH
42446: LD_VAR 0 5
42450: PUSH
42451: LD_INT 1
42453: ARRAY
42454: PPUSH
42455: LD_VAR 0 5
42459: PUSH
42460: LD_INT 2
42462: ARRAY
42463: PPUSH
42464: CALL_OW 111
// end ;
42468: LD_VAR 0 3
42472: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
42473: LD_INT 0
42475: PPUSH
42476: PPUSH
42477: PPUSH
// uc_side = 0 ;
42478: LD_ADDR_OWVAR 20
42482: PUSH
42483: LD_INT 0
42485: ST_TO_ADDR
// uc_nation = 0 ;
42486: LD_ADDR_OWVAR 21
42490: PUSH
42491: LD_INT 0
42493: ST_TO_ADDR
// InitHc_All ( ) ;
42494: CALL_OW 584
// InitVc ;
42498: CALL_OW 20
// if mastodonts then
42502: LD_VAR 0 6
42506: IFFALSE 42573
// for i = 1 to mastodonts do
42508: LD_ADDR_VAR 0 11
42512: PUSH
42513: DOUBLE
42514: LD_INT 1
42516: DEC
42517: ST_TO_ADDR
42518: LD_VAR 0 6
42522: PUSH
42523: FOR_TO
42524: IFFALSE 42571
// begin vc_chassis := 31 ;
42526: LD_ADDR_OWVAR 37
42530: PUSH
42531: LD_INT 31
42533: ST_TO_ADDR
// vc_control := control_rider ;
42534: LD_ADDR_OWVAR 38
42538: PUSH
42539: LD_INT 4
42541: ST_TO_ADDR
// animal := CreateVehicle ;
42542: LD_ADDR_VAR 0 12
42546: PUSH
42547: CALL_OW 45
42551: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42552: LD_VAR 0 12
42556: PPUSH
42557: LD_VAR 0 8
42561: PPUSH
42562: LD_INT 0
42564: PPUSH
42565: CALL 44761 0 3
// end ;
42569: GO 42523
42571: POP
42572: POP
// if horses then
42573: LD_VAR 0 5
42577: IFFALSE 42644
// for i = 1 to horses do
42579: LD_ADDR_VAR 0 11
42583: PUSH
42584: DOUBLE
42585: LD_INT 1
42587: DEC
42588: ST_TO_ADDR
42589: LD_VAR 0 5
42593: PUSH
42594: FOR_TO
42595: IFFALSE 42642
// begin hc_class := 21 ;
42597: LD_ADDR_OWVAR 28
42601: PUSH
42602: LD_INT 21
42604: ST_TO_ADDR
// hc_gallery :=  ;
42605: LD_ADDR_OWVAR 33
42609: PUSH
42610: LD_STRING 
42612: ST_TO_ADDR
// animal := CreateHuman ;
42613: LD_ADDR_VAR 0 12
42617: PUSH
42618: CALL_OW 44
42622: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42623: LD_VAR 0 12
42627: PPUSH
42628: LD_VAR 0 8
42632: PPUSH
42633: LD_INT 0
42635: PPUSH
42636: CALL 44761 0 3
// end ;
42640: GO 42594
42642: POP
42643: POP
// if birds then
42644: LD_VAR 0 1
42648: IFFALSE 42715
// for i = 1 to birds do
42650: LD_ADDR_VAR 0 11
42654: PUSH
42655: DOUBLE
42656: LD_INT 1
42658: DEC
42659: ST_TO_ADDR
42660: LD_VAR 0 1
42664: PUSH
42665: FOR_TO
42666: IFFALSE 42713
// begin hc_class = 18 ;
42668: LD_ADDR_OWVAR 28
42672: PUSH
42673: LD_INT 18
42675: ST_TO_ADDR
// hc_gallery =  ;
42676: LD_ADDR_OWVAR 33
42680: PUSH
42681: LD_STRING 
42683: ST_TO_ADDR
// animal := CreateHuman ;
42684: LD_ADDR_VAR 0 12
42688: PUSH
42689: CALL_OW 44
42693: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42694: LD_VAR 0 12
42698: PPUSH
42699: LD_VAR 0 8
42703: PPUSH
42704: LD_INT 0
42706: PPUSH
42707: CALL 44761 0 3
// end ;
42711: GO 42665
42713: POP
42714: POP
// if tigers then
42715: LD_VAR 0 2
42719: IFFALSE 42803
// for i = 1 to tigers do
42721: LD_ADDR_VAR 0 11
42725: PUSH
42726: DOUBLE
42727: LD_INT 1
42729: DEC
42730: ST_TO_ADDR
42731: LD_VAR 0 2
42735: PUSH
42736: FOR_TO
42737: IFFALSE 42801
// begin hc_class = class_tiger ;
42739: LD_ADDR_OWVAR 28
42743: PUSH
42744: LD_INT 14
42746: ST_TO_ADDR
// hc_gallery =  ;
42747: LD_ADDR_OWVAR 33
42751: PUSH
42752: LD_STRING 
42754: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
42755: LD_ADDR_OWVAR 35
42759: PUSH
42760: LD_INT 7
42762: NEG
42763: PPUSH
42764: LD_INT 7
42766: PPUSH
42767: CALL_OW 12
42771: ST_TO_ADDR
// animal := CreateHuman ;
42772: LD_ADDR_VAR 0 12
42776: PUSH
42777: CALL_OW 44
42781: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42782: LD_VAR 0 12
42786: PPUSH
42787: LD_VAR 0 8
42791: PPUSH
42792: LD_INT 0
42794: PPUSH
42795: CALL 44761 0 3
// end ;
42799: GO 42736
42801: POP
42802: POP
// if apemans then
42803: LD_VAR 0 3
42807: IFFALSE 42930
// for i = 1 to apemans do
42809: LD_ADDR_VAR 0 11
42813: PUSH
42814: DOUBLE
42815: LD_INT 1
42817: DEC
42818: ST_TO_ADDR
42819: LD_VAR 0 3
42823: PUSH
42824: FOR_TO
42825: IFFALSE 42928
// begin hc_class = class_apeman ;
42827: LD_ADDR_OWVAR 28
42831: PUSH
42832: LD_INT 12
42834: ST_TO_ADDR
// hc_gallery =  ;
42835: LD_ADDR_OWVAR 33
42839: PUSH
42840: LD_STRING 
42842: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
42843: LD_ADDR_OWVAR 35
42847: PUSH
42848: LD_INT 5
42850: NEG
42851: PPUSH
42852: LD_INT 5
42854: PPUSH
42855: CALL_OW 12
42859: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
42860: LD_ADDR_OWVAR 31
42864: PUSH
42865: LD_INT 1
42867: PPUSH
42868: LD_INT 3
42870: PPUSH
42871: CALL_OW 12
42875: PUSH
42876: LD_INT 1
42878: PPUSH
42879: LD_INT 3
42881: PPUSH
42882: CALL_OW 12
42886: PUSH
42887: LD_INT 0
42889: PUSH
42890: LD_INT 0
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: LIST
42897: LIST
42898: ST_TO_ADDR
// animal := CreateHuman ;
42899: LD_ADDR_VAR 0 12
42903: PUSH
42904: CALL_OW 44
42908: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42909: LD_VAR 0 12
42913: PPUSH
42914: LD_VAR 0 8
42918: PPUSH
42919: LD_INT 0
42921: PPUSH
42922: CALL 44761 0 3
// end ;
42926: GO 42824
42928: POP
42929: POP
// if enchidnas then
42930: LD_VAR 0 4
42934: IFFALSE 43001
// for i = 1 to enchidnas do
42936: LD_ADDR_VAR 0 11
42940: PUSH
42941: DOUBLE
42942: LD_INT 1
42944: DEC
42945: ST_TO_ADDR
42946: LD_VAR 0 4
42950: PUSH
42951: FOR_TO
42952: IFFALSE 42999
// begin hc_class = 13 ;
42954: LD_ADDR_OWVAR 28
42958: PUSH
42959: LD_INT 13
42961: ST_TO_ADDR
// hc_gallery =  ;
42962: LD_ADDR_OWVAR 33
42966: PUSH
42967: LD_STRING 
42969: ST_TO_ADDR
// animal := CreateHuman ;
42970: LD_ADDR_VAR 0 12
42974: PUSH
42975: CALL_OW 44
42979: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42980: LD_VAR 0 12
42984: PPUSH
42985: LD_VAR 0 8
42989: PPUSH
42990: LD_INT 0
42992: PPUSH
42993: CALL 44761 0 3
// end ;
42997: GO 42951
42999: POP
43000: POP
// if fishes then
43001: LD_VAR 0 7
43005: IFFALSE 43072
// for i = 1 to fishes do
43007: LD_ADDR_VAR 0 11
43011: PUSH
43012: DOUBLE
43013: LD_INT 1
43015: DEC
43016: ST_TO_ADDR
43017: LD_VAR 0 7
43021: PUSH
43022: FOR_TO
43023: IFFALSE 43070
// begin hc_class = 20 ;
43025: LD_ADDR_OWVAR 28
43029: PUSH
43030: LD_INT 20
43032: ST_TO_ADDR
// hc_gallery =  ;
43033: LD_ADDR_OWVAR 33
43037: PUSH
43038: LD_STRING 
43040: ST_TO_ADDR
// animal := CreateHuman ;
43041: LD_ADDR_VAR 0 12
43045: PUSH
43046: CALL_OW 44
43050: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43051: LD_VAR 0 12
43055: PPUSH
43056: LD_VAR 0 9
43060: PPUSH
43061: LD_INT 0
43063: PPUSH
43064: CALL 44761 0 3
// end ;
43068: GO 43022
43070: POP
43071: POP
// end ;
43072: LD_VAR 0 10
43076: RET
// export function WantHeal ( sci , unit ) ; begin
43077: LD_INT 0
43079: PPUSH
// if GetTaskList ( sci ) > 0 then
43080: LD_VAR 0 1
43084: PPUSH
43085: CALL_OW 437
43089: PUSH
43090: LD_INT 0
43092: GREATER
43093: IFFALSE 43163
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43095: LD_VAR 0 1
43099: PPUSH
43100: CALL_OW 437
43104: PUSH
43105: LD_INT 1
43107: ARRAY
43108: PUSH
43109: LD_INT 1
43111: ARRAY
43112: PUSH
43113: LD_STRING l
43115: EQUAL
43116: PUSH
43117: LD_VAR 0 1
43121: PPUSH
43122: CALL_OW 437
43126: PUSH
43127: LD_INT 1
43129: ARRAY
43130: PUSH
43131: LD_INT 4
43133: ARRAY
43134: PUSH
43135: LD_VAR 0 2
43139: EQUAL
43140: AND
43141: IFFALSE 43153
// result := true else
43143: LD_ADDR_VAR 0 3
43147: PUSH
43148: LD_INT 1
43150: ST_TO_ADDR
43151: GO 43161
// result := false ;
43153: LD_ADDR_VAR 0 3
43157: PUSH
43158: LD_INT 0
43160: ST_TO_ADDR
// end else
43161: GO 43171
// result := false ;
43163: LD_ADDR_VAR 0 3
43167: PUSH
43168: LD_INT 0
43170: ST_TO_ADDR
// end ;
43171: LD_VAR 0 3
43175: RET
// export function HealTarget ( sci ) ; begin
43176: LD_INT 0
43178: PPUSH
// if not sci then
43179: LD_VAR 0 1
43183: NOT
43184: IFFALSE 43188
// exit ;
43186: GO 43253
// result := 0 ;
43188: LD_ADDR_VAR 0 2
43192: PUSH
43193: LD_INT 0
43195: ST_TO_ADDR
// if GetTaskList ( sci ) then
43196: LD_VAR 0 1
43200: PPUSH
43201: CALL_OW 437
43205: IFFALSE 43253
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43207: LD_VAR 0 1
43211: PPUSH
43212: CALL_OW 437
43216: PUSH
43217: LD_INT 1
43219: ARRAY
43220: PUSH
43221: LD_INT 1
43223: ARRAY
43224: PUSH
43225: LD_STRING l
43227: EQUAL
43228: IFFALSE 43253
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43230: LD_ADDR_VAR 0 2
43234: PUSH
43235: LD_VAR 0 1
43239: PPUSH
43240: CALL_OW 437
43244: PUSH
43245: LD_INT 1
43247: ARRAY
43248: PUSH
43249: LD_INT 4
43251: ARRAY
43252: ST_TO_ADDR
// end ;
43253: LD_VAR 0 2
43257: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43258: LD_INT 0
43260: PPUSH
43261: PPUSH
43262: PPUSH
43263: PPUSH
// if not base_units then
43264: LD_VAR 0 1
43268: NOT
43269: IFFALSE 43273
// exit ;
43271: GO 43360
// result := false ;
43273: LD_ADDR_VAR 0 2
43277: PUSH
43278: LD_INT 0
43280: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
43281: LD_ADDR_VAR 0 5
43285: PUSH
43286: LD_VAR 0 1
43290: PPUSH
43291: LD_INT 21
43293: PUSH
43294: LD_INT 3
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PPUSH
43301: CALL_OW 72
43305: ST_TO_ADDR
// if not tmp then
43306: LD_VAR 0 5
43310: NOT
43311: IFFALSE 43315
// exit ;
43313: GO 43360
// for i in tmp do
43315: LD_ADDR_VAR 0 3
43319: PUSH
43320: LD_VAR 0 5
43324: PUSH
43325: FOR_IN
43326: IFFALSE 43358
// begin result := EnemyInRange ( i , 22 ) ;
43328: LD_ADDR_VAR 0 2
43332: PUSH
43333: LD_VAR 0 3
43337: PPUSH
43338: LD_INT 22
43340: PPUSH
43341: CALL 41596 0 2
43345: ST_TO_ADDR
// if result then
43346: LD_VAR 0 2
43350: IFFALSE 43356
// exit ;
43352: POP
43353: POP
43354: GO 43360
// end ;
43356: GO 43325
43358: POP
43359: POP
// end ;
43360: LD_VAR 0 2
43364: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
43365: LD_INT 0
43367: PPUSH
43368: PPUSH
// if not units then
43369: LD_VAR 0 1
43373: NOT
43374: IFFALSE 43378
// exit ;
43376: GO 43448
// result := [ ] ;
43378: LD_ADDR_VAR 0 3
43382: PUSH
43383: EMPTY
43384: ST_TO_ADDR
// for i in units do
43385: LD_ADDR_VAR 0 4
43389: PUSH
43390: LD_VAR 0 1
43394: PUSH
43395: FOR_IN
43396: IFFALSE 43446
// if GetTag ( i ) = tag then
43398: LD_VAR 0 4
43402: PPUSH
43403: CALL_OW 110
43407: PUSH
43408: LD_VAR 0 2
43412: EQUAL
43413: IFFALSE 43444
// result := Insert ( result , result + 1 , i ) ;
43415: LD_ADDR_VAR 0 3
43419: PUSH
43420: LD_VAR 0 3
43424: PPUSH
43425: LD_VAR 0 3
43429: PUSH
43430: LD_INT 1
43432: PLUS
43433: PPUSH
43434: LD_VAR 0 4
43438: PPUSH
43439: CALL_OW 2
43443: ST_TO_ADDR
43444: GO 43395
43446: POP
43447: POP
// end ;
43448: LD_VAR 0 3
43452: RET
// export function IsDriver ( un ) ; begin
43453: LD_INT 0
43455: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
43456: LD_ADDR_VAR 0 2
43460: PUSH
43461: LD_VAR 0 1
43465: PUSH
43466: LD_INT 55
43468: PUSH
43469: EMPTY
43470: LIST
43471: PPUSH
43472: CALL_OW 69
43476: IN
43477: ST_TO_ADDR
// end ;
43478: LD_VAR 0 2
43482: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
43483: LD_INT 0
43485: PPUSH
43486: PPUSH
// list := [ ] ;
43487: LD_ADDR_VAR 0 5
43491: PUSH
43492: EMPTY
43493: ST_TO_ADDR
// case d of 0 :
43494: LD_VAR 0 3
43498: PUSH
43499: LD_INT 0
43501: DOUBLE
43502: EQUAL
43503: IFTRUE 43507
43505: GO 43640
43507: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
43508: LD_ADDR_VAR 0 5
43512: PUSH
43513: LD_VAR 0 1
43517: PUSH
43518: LD_INT 4
43520: MINUS
43521: PUSH
43522: LD_VAR 0 2
43526: PUSH
43527: LD_INT 4
43529: MINUS
43530: PUSH
43531: LD_INT 2
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: LIST
43538: PUSH
43539: LD_VAR 0 1
43543: PUSH
43544: LD_INT 3
43546: MINUS
43547: PUSH
43548: LD_VAR 0 2
43552: PUSH
43553: LD_INT 1
43555: PUSH
43556: EMPTY
43557: LIST
43558: LIST
43559: LIST
43560: PUSH
43561: LD_VAR 0 1
43565: PUSH
43566: LD_INT 4
43568: PLUS
43569: PUSH
43570: LD_VAR 0 2
43574: PUSH
43575: LD_INT 4
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: LIST
43582: PUSH
43583: LD_VAR 0 1
43587: PUSH
43588: LD_INT 3
43590: PLUS
43591: PUSH
43592: LD_VAR 0 2
43596: PUSH
43597: LD_INT 3
43599: PLUS
43600: PUSH
43601: LD_INT 5
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: LIST
43608: PUSH
43609: LD_VAR 0 1
43613: PUSH
43614: LD_VAR 0 2
43618: PUSH
43619: LD_INT 4
43621: PLUS
43622: PUSH
43623: LD_INT 0
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: LIST
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: LIST
43635: LIST
43636: LIST
43637: ST_TO_ADDR
// end ; 1 :
43638: GO 44338
43640: LD_INT 1
43642: DOUBLE
43643: EQUAL
43644: IFTRUE 43648
43646: GO 43781
43648: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
43649: LD_ADDR_VAR 0 5
43653: PUSH
43654: LD_VAR 0 1
43658: PUSH
43659: LD_VAR 0 2
43663: PUSH
43664: LD_INT 4
43666: MINUS
43667: PUSH
43668: LD_INT 3
43670: PUSH
43671: EMPTY
43672: LIST
43673: LIST
43674: LIST
43675: PUSH
43676: LD_VAR 0 1
43680: PUSH
43681: LD_INT 3
43683: MINUS
43684: PUSH
43685: LD_VAR 0 2
43689: PUSH
43690: LD_INT 3
43692: MINUS
43693: PUSH
43694: LD_INT 2
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: LIST
43701: PUSH
43702: LD_VAR 0 1
43706: PUSH
43707: LD_INT 4
43709: MINUS
43710: PUSH
43711: LD_VAR 0 2
43715: PUSH
43716: LD_INT 1
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: LIST
43723: PUSH
43724: LD_VAR 0 1
43728: PUSH
43729: LD_VAR 0 2
43733: PUSH
43734: LD_INT 3
43736: PLUS
43737: PUSH
43738: LD_INT 0
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: LIST
43745: PUSH
43746: LD_VAR 0 1
43750: PUSH
43751: LD_INT 4
43753: PLUS
43754: PUSH
43755: LD_VAR 0 2
43759: PUSH
43760: LD_INT 4
43762: PLUS
43763: PUSH
43764: LD_INT 5
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: LIST
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: LIST
43776: LIST
43777: LIST
43778: ST_TO_ADDR
// end ; 2 :
43779: GO 44338
43781: LD_INT 2
43783: DOUBLE
43784: EQUAL
43785: IFTRUE 43789
43787: GO 43918
43789: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
43790: LD_ADDR_VAR 0 5
43794: PUSH
43795: LD_VAR 0 1
43799: PUSH
43800: LD_VAR 0 2
43804: PUSH
43805: LD_INT 3
43807: MINUS
43808: PUSH
43809: LD_INT 3
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: LIST
43816: PUSH
43817: LD_VAR 0 1
43821: PUSH
43822: LD_INT 4
43824: PLUS
43825: PUSH
43826: LD_VAR 0 2
43830: PUSH
43831: LD_INT 4
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: LIST
43838: PUSH
43839: LD_VAR 0 1
43843: PUSH
43844: LD_VAR 0 2
43848: PUSH
43849: LD_INT 4
43851: PLUS
43852: PUSH
43853: LD_INT 0
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: LIST
43860: PUSH
43861: LD_VAR 0 1
43865: PUSH
43866: LD_INT 3
43868: MINUS
43869: PUSH
43870: LD_VAR 0 2
43874: PUSH
43875: LD_INT 1
43877: PUSH
43878: EMPTY
43879: LIST
43880: LIST
43881: LIST
43882: PUSH
43883: LD_VAR 0 1
43887: PUSH
43888: LD_INT 4
43890: MINUS
43891: PUSH
43892: LD_VAR 0 2
43896: PUSH
43897: LD_INT 4
43899: MINUS
43900: PUSH
43901: LD_INT 2
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: LIST
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: ST_TO_ADDR
// end ; 3 :
43916: GO 44338
43918: LD_INT 3
43920: DOUBLE
43921: EQUAL
43922: IFTRUE 43926
43924: GO 44059
43926: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
43927: LD_ADDR_VAR 0 5
43931: PUSH
43932: LD_VAR 0 1
43936: PUSH
43937: LD_INT 3
43939: PLUS
43940: PUSH
43941: LD_VAR 0 2
43945: PUSH
43946: LD_INT 4
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: LIST
43953: PUSH
43954: LD_VAR 0 1
43958: PUSH
43959: LD_INT 4
43961: PLUS
43962: PUSH
43963: LD_VAR 0 2
43967: PUSH
43968: LD_INT 4
43970: PLUS
43971: PUSH
43972: LD_INT 5
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: LIST
43979: PUSH
43980: LD_VAR 0 1
43984: PUSH
43985: LD_INT 4
43987: MINUS
43988: PUSH
43989: LD_VAR 0 2
43993: PUSH
43994: LD_INT 1
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: LIST
44001: PUSH
44002: LD_VAR 0 1
44006: PUSH
44007: LD_VAR 0 2
44011: PUSH
44012: LD_INT 4
44014: MINUS
44015: PUSH
44016: LD_INT 3
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: LIST
44023: PUSH
44024: LD_VAR 0 1
44028: PUSH
44029: LD_INT 3
44031: MINUS
44032: PUSH
44033: LD_VAR 0 2
44037: PUSH
44038: LD_INT 3
44040: MINUS
44041: PUSH
44042: LD_INT 2
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: LIST
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: LIST
44054: LIST
44055: LIST
44056: ST_TO_ADDR
// end ; 4 :
44057: GO 44338
44059: LD_INT 4
44061: DOUBLE
44062: EQUAL
44063: IFTRUE 44067
44065: GO 44200
44067: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44068: LD_ADDR_VAR 0 5
44072: PUSH
44073: LD_VAR 0 1
44077: PUSH
44078: LD_VAR 0 2
44082: PUSH
44083: LD_INT 4
44085: PLUS
44086: PUSH
44087: LD_INT 0
44089: PUSH
44090: EMPTY
44091: LIST
44092: LIST
44093: LIST
44094: PUSH
44095: LD_VAR 0 1
44099: PUSH
44100: LD_INT 3
44102: PLUS
44103: PUSH
44104: LD_VAR 0 2
44108: PUSH
44109: LD_INT 3
44111: PLUS
44112: PUSH
44113: LD_INT 5
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: LIST
44120: PUSH
44121: LD_VAR 0 1
44125: PUSH
44126: LD_INT 4
44128: PLUS
44129: PUSH
44130: LD_VAR 0 2
44134: PUSH
44135: LD_INT 4
44137: PUSH
44138: EMPTY
44139: LIST
44140: LIST
44141: LIST
44142: PUSH
44143: LD_VAR 0 1
44147: PUSH
44148: LD_VAR 0 2
44152: PUSH
44153: LD_INT 3
44155: MINUS
44156: PUSH
44157: LD_INT 3
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: LIST
44164: PUSH
44165: LD_VAR 0 1
44169: PUSH
44170: LD_INT 4
44172: MINUS
44173: PUSH
44174: LD_VAR 0 2
44178: PUSH
44179: LD_INT 4
44181: MINUS
44182: PUSH
44183: LD_INT 2
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: LIST
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: LIST
44195: LIST
44196: LIST
44197: ST_TO_ADDR
// end ; 5 :
44198: GO 44338
44200: LD_INT 5
44202: DOUBLE
44203: EQUAL
44204: IFTRUE 44208
44206: GO 44337
44208: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44209: LD_ADDR_VAR 0 5
44213: PUSH
44214: LD_VAR 0 1
44218: PUSH
44219: LD_INT 4
44221: MINUS
44222: PUSH
44223: LD_VAR 0 2
44227: PUSH
44228: LD_INT 1
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: LIST
44235: PUSH
44236: LD_VAR 0 1
44240: PUSH
44241: LD_VAR 0 2
44245: PUSH
44246: LD_INT 4
44248: MINUS
44249: PUSH
44250: LD_INT 3
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: LIST
44257: PUSH
44258: LD_VAR 0 1
44262: PUSH
44263: LD_INT 4
44265: PLUS
44266: PUSH
44267: LD_VAR 0 2
44271: PUSH
44272: LD_INT 4
44274: PLUS
44275: PUSH
44276: LD_INT 5
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: LIST
44283: PUSH
44284: LD_VAR 0 1
44288: PUSH
44289: LD_INT 3
44291: PLUS
44292: PUSH
44293: LD_VAR 0 2
44297: PUSH
44298: LD_INT 4
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: LIST
44305: PUSH
44306: LD_VAR 0 1
44310: PUSH
44311: LD_VAR 0 2
44315: PUSH
44316: LD_INT 3
44318: PLUS
44319: PUSH
44320: LD_INT 0
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: LIST
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: ST_TO_ADDR
// end ; end ;
44335: GO 44338
44337: POP
// result := list ;
44338: LD_ADDR_VAR 0 4
44342: PUSH
44343: LD_VAR 0 5
44347: ST_TO_ADDR
// end ;
44348: LD_VAR 0 4
44352: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
44353: LD_INT 0
44355: PPUSH
44356: PPUSH
44357: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
44358: LD_VAR 0 1
44362: NOT
44363: PUSH
44364: LD_VAR 0 2
44368: PUSH
44369: LD_INT 1
44371: PUSH
44372: LD_INT 2
44374: PUSH
44375: LD_INT 3
44377: PUSH
44378: LD_INT 4
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: IN
44387: NOT
44388: OR
44389: IFFALSE 44393
// exit ;
44391: GO 44485
// tmp := [ ] ;
44393: LD_ADDR_VAR 0 5
44397: PUSH
44398: EMPTY
44399: ST_TO_ADDR
// for i in units do
44400: LD_ADDR_VAR 0 4
44404: PUSH
44405: LD_VAR 0 1
44409: PUSH
44410: FOR_IN
44411: IFFALSE 44454
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
44413: LD_ADDR_VAR 0 5
44417: PUSH
44418: LD_VAR 0 5
44422: PPUSH
44423: LD_VAR 0 5
44427: PUSH
44428: LD_INT 1
44430: PLUS
44431: PPUSH
44432: LD_VAR 0 4
44436: PPUSH
44437: LD_VAR 0 2
44441: PPUSH
44442: CALL_OW 259
44446: PPUSH
44447: CALL_OW 2
44451: ST_TO_ADDR
44452: GO 44410
44454: POP
44455: POP
// if not tmp then
44456: LD_VAR 0 5
44460: NOT
44461: IFFALSE 44465
// exit ;
44463: GO 44485
// result := SortListByListDesc ( units , tmp ) ;
44465: LD_ADDR_VAR 0 3
44469: PUSH
44470: LD_VAR 0 1
44474: PPUSH
44475: LD_VAR 0 5
44479: PPUSH
44480: CALL_OW 77
44484: ST_TO_ADDR
// end ;
44485: LD_VAR 0 3
44489: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
44490: LD_INT 0
44492: PPUSH
44493: PPUSH
44494: PPUSH
// result := false ;
44495: LD_ADDR_VAR 0 3
44499: PUSH
44500: LD_INT 0
44502: ST_TO_ADDR
// x := GetX ( building ) ;
44503: LD_ADDR_VAR 0 4
44507: PUSH
44508: LD_VAR 0 2
44512: PPUSH
44513: CALL_OW 250
44517: ST_TO_ADDR
// y := GetY ( building ) ;
44518: LD_ADDR_VAR 0 5
44522: PUSH
44523: LD_VAR 0 2
44527: PPUSH
44528: CALL_OW 251
44532: ST_TO_ADDR
// if not building or not x or not y then
44533: LD_VAR 0 2
44537: NOT
44538: PUSH
44539: LD_VAR 0 4
44543: NOT
44544: OR
44545: PUSH
44546: LD_VAR 0 5
44550: NOT
44551: OR
44552: IFFALSE 44556
// exit ;
44554: GO 44648
// if GetTaskList ( unit ) then
44556: LD_VAR 0 1
44560: PPUSH
44561: CALL_OW 437
44565: IFFALSE 44648
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44567: LD_STRING e
44569: PUSH
44570: LD_VAR 0 1
44574: PPUSH
44575: CALL_OW 437
44579: PUSH
44580: LD_INT 1
44582: ARRAY
44583: PUSH
44584: LD_INT 1
44586: ARRAY
44587: EQUAL
44588: PUSH
44589: LD_VAR 0 4
44593: PUSH
44594: LD_VAR 0 1
44598: PPUSH
44599: CALL_OW 437
44603: PUSH
44604: LD_INT 1
44606: ARRAY
44607: PUSH
44608: LD_INT 2
44610: ARRAY
44611: EQUAL
44612: AND
44613: PUSH
44614: LD_VAR 0 5
44618: PUSH
44619: LD_VAR 0 1
44623: PPUSH
44624: CALL_OW 437
44628: PUSH
44629: LD_INT 1
44631: ARRAY
44632: PUSH
44633: LD_INT 3
44635: ARRAY
44636: EQUAL
44637: AND
44638: IFFALSE 44648
// result := true end ;
44640: LD_ADDR_VAR 0 3
44644: PUSH
44645: LD_INT 1
44647: ST_TO_ADDR
// end ;
44648: LD_VAR 0 3
44652: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
44653: LD_INT 0
44655: PPUSH
// result := false ;
44656: LD_ADDR_VAR 0 4
44660: PUSH
44661: LD_INT 0
44663: ST_TO_ADDR
// if GetTaskList ( unit ) then
44664: LD_VAR 0 1
44668: PPUSH
44669: CALL_OW 437
44673: IFFALSE 44756
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44675: LD_STRING M
44677: PUSH
44678: LD_VAR 0 1
44682: PPUSH
44683: CALL_OW 437
44687: PUSH
44688: LD_INT 1
44690: ARRAY
44691: PUSH
44692: LD_INT 1
44694: ARRAY
44695: EQUAL
44696: PUSH
44697: LD_VAR 0 2
44701: PUSH
44702: LD_VAR 0 1
44706: PPUSH
44707: CALL_OW 437
44711: PUSH
44712: LD_INT 1
44714: ARRAY
44715: PUSH
44716: LD_INT 2
44718: ARRAY
44719: EQUAL
44720: AND
44721: PUSH
44722: LD_VAR 0 3
44726: PUSH
44727: LD_VAR 0 1
44731: PPUSH
44732: CALL_OW 437
44736: PUSH
44737: LD_INT 1
44739: ARRAY
44740: PUSH
44741: LD_INT 3
44743: ARRAY
44744: EQUAL
44745: AND
44746: IFFALSE 44756
// result := true ;
44748: LD_ADDR_VAR 0 4
44752: PUSH
44753: LD_INT 1
44755: ST_TO_ADDR
// end ; end ;
44756: LD_VAR 0 4
44760: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
44761: LD_INT 0
44763: PPUSH
44764: PPUSH
44765: PPUSH
44766: PPUSH
// if not unit or not area then
44767: LD_VAR 0 1
44771: NOT
44772: PUSH
44773: LD_VAR 0 2
44777: NOT
44778: OR
44779: IFFALSE 44783
// exit ;
44781: GO 44947
// tmp := AreaToList ( area , i ) ;
44783: LD_ADDR_VAR 0 6
44787: PUSH
44788: LD_VAR 0 2
44792: PPUSH
44793: LD_VAR 0 5
44797: PPUSH
44798: CALL_OW 517
44802: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
44803: LD_ADDR_VAR 0 5
44807: PUSH
44808: DOUBLE
44809: LD_INT 1
44811: DEC
44812: ST_TO_ADDR
44813: LD_VAR 0 6
44817: PUSH
44818: LD_INT 1
44820: ARRAY
44821: PUSH
44822: FOR_TO
44823: IFFALSE 44945
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
44825: LD_ADDR_VAR 0 7
44829: PUSH
44830: LD_VAR 0 6
44834: PUSH
44835: LD_INT 1
44837: ARRAY
44838: PUSH
44839: LD_VAR 0 5
44843: ARRAY
44844: PUSH
44845: LD_VAR 0 6
44849: PUSH
44850: LD_INT 2
44852: ARRAY
44853: PUSH
44854: LD_VAR 0 5
44858: ARRAY
44859: PUSH
44860: EMPTY
44861: LIST
44862: LIST
44863: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
44864: LD_VAR 0 7
44868: PUSH
44869: LD_INT 1
44871: ARRAY
44872: PPUSH
44873: LD_VAR 0 7
44877: PUSH
44878: LD_INT 2
44880: ARRAY
44881: PPUSH
44882: CALL_OW 428
44886: PUSH
44887: LD_INT 0
44889: EQUAL
44890: IFFALSE 44943
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
44892: LD_VAR 0 1
44896: PPUSH
44897: LD_VAR 0 7
44901: PUSH
44902: LD_INT 1
44904: ARRAY
44905: PPUSH
44906: LD_VAR 0 7
44910: PUSH
44911: LD_INT 2
44913: ARRAY
44914: PPUSH
44915: LD_VAR 0 3
44919: PPUSH
44920: CALL_OW 48
// result := IsPlaced ( unit ) ;
44924: LD_ADDR_VAR 0 4
44928: PUSH
44929: LD_VAR 0 1
44933: PPUSH
44934: CALL_OW 305
44938: ST_TO_ADDR
// exit ;
44939: POP
44940: POP
44941: GO 44947
// end ; end ;
44943: GO 44822
44945: POP
44946: POP
// end ;
44947: LD_VAR 0 4
44951: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
44952: LD_INT 0
44954: PPUSH
44955: PPUSH
44956: PPUSH
// if not side or side > 8 then
44957: LD_VAR 0 1
44961: NOT
44962: PUSH
44963: LD_VAR 0 1
44967: PUSH
44968: LD_INT 8
44970: GREATER
44971: OR
44972: IFFALSE 44976
// exit ;
44974: GO 45163
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
44976: LD_ADDR_VAR 0 4
44980: PUSH
44981: LD_INT 22
44983: PUSH
44984: LD_VAR 0 1
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 21
44995: PUSH
44996: LD_INT 3
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PPUSH
45007: CALL_OW 69
45011: ST_TO_ADDR
// if not tmp then
45012: LD_VAR 0 4
45016: NOT
45017: IFFALSE 45021
// exit ;
45019: GO 45163
// enable_addtolog := true ;
45021: LD_ADDR_OWVAR 81
45025: PUSH
45026: LD_INT 1
45028: ST_TO_ADDR
// AddToLog ( [ ) ;
45029: LD_STRING [
45031: PPUSH
45032: CALL_OW 561
// for i in tmp do
45036: LD_ADDR_VAR 0 3
45040: PUSH
45041: LD_VAR 0 4
45045: PUSH
45046: FOR_IN
45047: IFFALSE 45154
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45049: LD_STRING [
45051: PUSH
45052: LD_VAR 0 3
45056: PPUSH
45057: CALL_OW 266
45061: STR
45062: PUSH
45063: LD_STRING , 
45065: STR
45066: PUSH
45067: LD_VAR 0 3
45071: PPUSH
45072: CALL_OW 250
45076: STR
45077: PUSH
45078: LD_STRING , 
45080: STR
45081: PUSH
45082: LD_VAR 0 3
45086: PPUSH
45087: CALL_OW 251
45091: STR
45092: PUSH
45093: LD_STRING , 
45095: STR
45096: PUSH
45097: LD_VAR 0 3
45101: PPUSH
45102: CALL_OW 254
45106: STR
45107: PUSH
45108: LD_STRING , 
45110: STR
45111: PUSH
45112: LD_VAR 0 3
45116: PPUSH
45117: LD_INT 1
45119: PPUSH
45120: CALL_OW 268
45124: STR
45125: PUSH
45126: LD_STRING , 
45128: STR
45129: PUSH
45130: LD_VAR 0 3
45134: PPUSH
45135: LD_INT 2
45137: PPUSH
45138: CALL_OW 268
45142: STR
45143: PUSH
45144: LD_STRING ],
45146: STR
45147: PPUSH
45148: CALL_OW 561
// end ;
45152: GO 45046
45154: POP
45155: POP
// AddToLog ( ]; ) ;
45156: LD_STRING ];
45158: PPUSH
45159: CALL_OW 561
// end ;
45163: LD_VAR 0 2
45167: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45168: LD_INT 0
45170: PPUSH
45171: PPUSH
45172: PPUSH
45173: PPUSH
45174: PPUSH
// if not area or not rate or not max then
45175: LD_VAR 0 1
45179: NOT
45180: PUSH
45181: LD_VAR 0 2
45185: NOT
45186: OR
45187: PUSH
45188: LD_VAR 0 4
45192: NOT
45193: OR
45194: IFFALSE 45198
// exit ;
45196: GO 45390
// while 1 do
45198: LD_INT 1
45200: IFFALSE 45390
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45202: LD_ADDR_VAR 0 9
45206: PUSH
45207: LD_VAR 0 1
45211: PPUSH
45212: LD_INT 1
45214: PPUSH
45215: CALL_OW 287
45219: PUSH
45220: LD_INT 10
45222: MUL
45223: ST_TO_ADDR
// r := rate / 10 ;
45224: LD_ADDR_VAR 0 7
45228: PUSH
45229: LD_VAR 0 2
45233: PUSH
45234: LD_INT 10
45236: DIVREAL
45237: ST_TO_ADDR
// time := 1 1$00 ;
45238: LD_ADDR_VAR 0 8
45242: PUSH
45243: LD_INT 2100
45245: ST_TO_ADDR
// if amount < min then
45246: LD_VAR 0 9
45250: PUSH
45251: LD_VAR 0 3
45255: LESS
45256: IFFALSE 45274
// r := r * 2 else
45258: LD_ADDR_VAR 0 7
45262: PUSH
45263: LD_VAR 0 7
45267: PUSH
45268: LD_INT 2
45270: MUL
45271: ST_TO_ADDR
45272: GO 45300
// if amount > max then
45274: LD_VAR 0 9
45278: PUSH
45279: LD_VAR 0 4
45283: GREATER
45284: IFFALSE 45300
// r := r / 2 ;
45286: LD_ADDR_VAR 0 7
45290: PUSH
45291: LD_VAR 0 7
45295: PUSH
45296: LD_INT 2
45298: DIVREAL
45299: ST_TO_ADDR
// time := time / r ;
45300: LD_ADDR_VAR 0 8
45304: PUSH
45305: LD_VAR 0 8
45309: PUSH
45310: LD_VAR 0 7
45314: DIVREAL
45315: ST_TO_ADDR
// if time < 0 then
45316: LD_VAR 0 8
45320: PUSH
45321: LD_INT 0
45323: LESS
45324: IFFALSE 45341
// time := time * - 1 ;
45326: LD_ADDR_VAR 0 8
45330: PUSH
45331: LD_VAR 0 8
45335: PUSH
45336: LD_INT 1
45338: NEG
45339: MUL
45340: ST_TO_ADDR
// wait ( time ) ;
45341: LD_VAR 0 8
45345: PPUSH
45346: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
45350: LD_INT 35
45352: PPUSH
45353: LD_INT 875
45355: PPUSH
45356: CALL_OW 12
45360: PPUSH
45361: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
45365: LD_INT 1
45367: PPUSH
45368: LD_INT 5
45370: PPUSH
45371: CALL_OW 12
45375: PPUSH
45376: LD_VAR 0 1
45380: PPUSH
45381: LD_INT 1
45383: PPUSH
45384: CALL_OW 55
// end ;
45388: GO 45198
// end ;
45390: LD_VAR 0 5
45394: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
45395: LD_INT 0
45397: PPUSH
45398: PPUSH
45399: PPUSH
45400: PPUSH
45401: PPUSH
45402: PPUSH
45403: PPUSH
45404: PPUSH
// if not turrets or not factories then
45405: LD_VAR 0 1
45409: NOT
45410: PUSH
45411: LD_VAR 0 2
45415: NOT
45416: OR
45417: IFFALSE 45421
// exit ;
45419: GO 45728
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
45421: LD_ADDR_VAR 0 10
45425: PUSH
45426: LD_INT 5
45428: PUSH
45429: LD_INT 6
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: PUSH
45436: LD_INT 2
45438: PUSH
45439: LD_INT 4
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: LD_INT 3
45448: PUSH
45449: LD_INT 5
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: EMPTY
45457: LIST
45458: LIST
45459: LIST
45460: PUSH
45461: LD_INT 24
45463: PUSH
45464: LD_INT 25
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: LD_INT 23
45473: PUSH
45474: LD_INT 27
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: LD_INT 42
45487: PUSH
45488: LD_INT 43
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: PUSH
45495: LD_INT 44
45497: PUSH
45498: LD_INT 46
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: PUSH
45505: LD_INT 45
45507: PUSH
45508: LD_INT 47
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: LIST
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: LIST
45524: ST_TO_ADDR
// result := [ ] ;
45525: LD_ADDR_VAR 0 3
45529: PUSH
45530: EMPTY
45531: ST_TO_ADDR
// for i in turrets do
45532: LD_ADDR_VAR 0 4
45536: PUSH
45537: LD_VAR 0 1
45541: PUSH
45542: FOR_IN
45543: IFFALSE 45726
// begin nat := GetNation ( i ) ;
45545: LD_ADDR_VAR 0 7
45549: PUSH
45550: LD_VAR 0 4
45554: PPUSH
45555: CALL_OW 248
45559: ST_TO_ADDR
// weapon := 0 ;
45560: LD_ADDR_VAR 0 8
45564: PUSH
45565: LD_INT 0
45567: ST_TO_ADDR
// if not nat then
45568: LD_VAR 0 7
45572: NOT
45573: IFFALSE 45577
// continue ;
45575: GO 45542
// for j in list [ nat ] do
45577: LD_ADDR_VAR 0 5
45581: PUSH
45582: LD_VAR 0 10
45586: PUSH
45587: LD_VAR 0 7
45591: ARRAY
45592: PUSH
45593: FOR_IN
45594: IFFALSE 45635
// if GetBWeapon ( i ) = j [ 1 ] then
45596: LD_VAR 0 4
45600: PPUSH
45601: CALL_OW 269
45605: PUSH
45606: LD_VAR 0 5
45610: PUSH
45611: LD_INT 1
45613: ARRAY
45614: EQUAL
45615: IFFALSE 45633
// begin weapon := j [ 2 ] ;
45617: LD_ADDR_VAR 0 8
45621: PUSH
45622: LD_VAR 0 5
45626: PUSH
45627: LD_INT 2
45629: ARRAY
45630: ST_TO_ADDR
// break ;
45631: GO 45635
// end ;
45633: GO 45593
45635: POP
45636: POP
// if not weapon then
45637: LD_VAR 0 8
45641: NOT
45642: IFFALSE 45646
// continue ;
45644: GO 45542
// for k in factories do
45646: LD_ADDR_VAR 0 6
45650: PUSH
45651: LD_VAR 0 2
45655: PUSH
45656: FOR_IN
45657: IFFALSE 45722
// begin weapons := AvailableWeaponList ( k ) ;
45659: LD_ADDR_VAR 0 9
45663: PUSH
45664: LD_VAR 0 6
45668: PPUSH
45669: CALL_OW 478
45673: ST_TO_ADDR
// if not weapons then
45674: LD_VAR 0 9
45678: NOT
45679: IFFALSE 45683
// continue ;
45681: GO 45656
// if weapon in weapons then
45683: LD_VAR 0 8
45687: PUSH
45688: LD_VAR 0 9
45692: IN
45693: IFFALSE 45720
// begin result := [ i , weapon ] ;
45695: LD_ADDR_VAR 0 3
45699: PUSH
45700: LD_VAR 0 4
45704: PUSH
45705: LD_VAR 0 8
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: ST_TO_ADDR
// exit ;
45714: POP
45715: POP
45716: POP
45717: POP
45718: GO 45728
// end ; end ;
45720: GO 45656
45722: POP
45723: POP
// end ;
45724: GO 45542
45726: POP
45727: POP
// end ;
45728: LD_VAR 0 3
45732: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
45733: LD_INT 0
45735: PPUSH
// if not side or side > 8 then
45736: LD_VAR 0 3
45740: NOT
45741: PUSH
45742: LD_VAR 0 3
45746: PUSH
45747: LD_INT 8
45749: GREATER
45750: OR
45751: IFFALSE 45755
// exit ;
45753: GO 45814
// if not range then
45755: LD_VAR 0 4
45759: NOT
45760: IFFALSE 45771
// range := - 12 ;
45762: LD_ADDR_VAR 0 4
45766: PUSH
45767: LD_INT 12
45769: NEG
45770: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
45771: LD_VAR 0 1
45775: PPUSH
45776: LD_VAR 0 2
45780: PPUSH
45781: LD_VAR 0 3
45785: PPUSH
45786: LD_VAR 0 4
45790: PPUSH
45791: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
45795: LD_VAR 0 1
45799: PPUSH
45800: LD_VAR 0 2
45804: PPUSH
45805: LD_VAR 0 3
45809: PPUSH
45810: CALL_OW 331
// end ;
45814: LD_VAR 0 5
45818: RET
// export function Video ( mode ) ; begin
45819: LD_INT 0
45821: PPUSH
// ingame_video = mode ;
45822: LD_ADDR_OWVAR 52
45826: PUSH
45827: LD_VAR 0 1
45831: ST_TO_ADDR
// interface_hidden = mode ;
45832: LD_ADDR_OWVAR 54
45836: PUSH
45837: LD_VAR 0 1
45841: ST_TO_ADDR
// end ;
45842: LD_VAR 0 2
45846: RET
// export function Join ( array , element ) ; begin
45847: LD_INT 0
45849: PPUSH
// result := Replace ( array , array + 1 , element ) ;
45850: LD_ADDR_VAR 0 3
45854: PUSH
45855: LD_VAR 0 1
45859: PPUSH
45860: LD_VAR 0 1
45864: PUSH
45865: LD_INT 1
45867: PLUS
45868: PPUSH
45869: LD_VAR 0 2
45873: PPUSH
45874: CALL_OW 1
45878: ST_TO_ADDR
// end ;
45879: LD_VAR 0 3
45883: RET
// export function JoinUnion ( array , element ) ; begin
45884: LD_INT 0
45886: PPUSH
// result := array union element ;
45887: LD_ADDR_VAR 0 3
45891: PUSH
45892: LD_VAR 0 1
45896: PUSH
45897: LD_VAR 0 2
45901: UNION
45902: ST_TO_ADDR
// end ;
45903: LD_VAR 0 3
45907: RET
// export function GetBehemoths ( side ) ; begin
45908: LD_INT 0
45910: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
45911: LD_ADDR_VAR 0 2
45915: PUSH
45916: LD_INT 22
45918: PUSH
45919: LD_VAR 0 1
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: LD_INT 31
45930: PUSH
45931: LD_INT 25
45933: PUSH
45934: EMPTY
45935: LIST
45936: LIST
45937: PUSH
45938: EMPTY
45939: LIST
45940: LIST
45941: PPUSH
45942: CALL_OW 69
45946: ST_TO_ADDR
// end ;
45947: LD_VAR 0 2
45951: RET
// export function Shuffle ( array ) ; var i , index ; begin
45952: LD_INT 0
45954: PPUSH
45955: PPUSH
45956: PPUSH
// result := [ ] ;
45957: LD_ADDR_VAR 0 2
45961: PUSH
45962: EMPTY
45963: ST_TO_ADDR
// if not array then
45964: LD_VAR 0 1
45968: NOT
45969: IFFALSE 45973
// exit ;
45971: GO 46072
// Randomize ;
45973: CALL_OW 10
// for i = array downto 1 do
45977: LD_ADDR_VAR 0 3
45981: PUSH
45982: DOUBLE
45983: LD_VAR 0 1
45987: INC
45988: ST_TO_ADDR
45989: LD_INT 1
45991: PUSH
45992: FOR_DOWNTO
45993: IFFALSE 46070
// begin index := rand ( 1 , array ) ;
45995: LD_ADDR_VAR 0 4
45999: PUSH
46000: LD_INT 1
46002: PPUSH
46003: LD_VAR 0 1
46007: PPUSH
46008: CALL_OW 12
46012: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46013: LD_ADDR_VAR 0 2
46017: PUSH
46018: LD_VAR 0 2
46022: PPUSH
46023: LD_VAR 0 2
46027: PUSH
46028: LD_INT 1
46030: PLUS
46031: PPUSH
46032: LD_VAR 0 1
46036: PUSH
46037: LD_VAR 0 4
46041: ARRAY
46042: PPUSH
46043: CALL_OW 2
46047: ST_TO_ADDR
// array := Delete ( array , index ) ;
46048: LD_ADDR_VAR 0 1
46052: PUSH
46053: LD_VAR 0 1
46057: PPUSH
46058: LD_VAR 0 4
46062: PPUSH
46063: CALL_OW 3
46067: ST_TO_ADDR
// end ;
46068: GO 45992
46070: POP
46071: POP
// end ;
46072: LD_VAR 0 2
46076: RET
// export function GetBaseMaterials ( base ) ; begin
46077: LD_INT 0
46079: PPUSH
// result := [ 0 , 0 , 0 ] ;
46080: LD_ADDR_VAR 0 2
46084: PUSH
46085: LD_INT 0
46087: PUSH
46088: LD_INT 0
46090: PUSH
46091: LD_INT 0
46093: PUSH
46094: EMPTY
46095: LIST
46096: LIST
46097: LIST
46098: ST_TO_ADDR
// if not base then
46099: LD_VAR 0 1
46103: NOT
46104: IFFALSE 46108
// exit ;
46106: GO 46157
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46108: LD_ADDR_VAR 0 2
46112: PUSH
46113: LD_VAR 0 1
46117: PPUSH
46118: LD_INT 1
46120: PPUSH
46121: CALL_OW 275
46125: PUSH
46126: LD_VAR 0 1
46130: PPUSH
46131: LD_INT 2
46133: PPUSH
46134: CALL_OW 275
46138: PUSH
46139: LD_VAR 0 1
46143: PPUSH
46144: LD_INT 3
46146: PPUSH
46147: CALL_OW 275
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: LIST
46156: ST_TO_ADDR
// end ;
46157: LD_VAR 0 2
46161: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46162: LD_INT 0
46164: PPUSH
46165: PPUSH
// result := array ;
46166: LD_ADDR_VAR 0 3
46170: PUSH
46171: LD_VAR 0 1
46175: ST_TO_ADDR
// if size > 0 then
46176: LD_VAR 0 2
46180: PUSH
46181: LD_INT 0
46183: GREATER
46184: IFFALSE 46230
// for i := array downto size do
46186: LD_ADDR_VAR 0 4
46190: PUSH
46191: DOUBLE
46192: LD_VAR 0 1
46196: INC
46197: ST_TO_ADDR
46198: LD_VAR 0 2
46202: PUSH
46203: FOR_DOWNTO
46204: IFFALSE 46228
// result := Delete ( result , result ) ;
46206: LD_ADDR_VAR 0 3
46210: PUSH
46211: LD_VAR 0 3
46215: PPUSH
46216: LD_VAR 0 3
46220: PPUSH
46221: CALL_OW 3
46225: ST_TO_ADDR
46226: GO 46203
46228: POP
46229: POP
// end ;
46230: LD_VAR 0 3
46234: RET
// export function ComExit ( unit ) ; var tmp ; begin
46235: LD_INT 0
46237: PPUSH
46238: PPUSH
// if not IsInUnit ( unit ) then
46239: LD_VAR 0 1
46243: PPUSH
46244: CALL_OW 310
46248: NOT
46249: IFFALSE 46253
// exit ;
46251: GO 46313
// tmp := IsInUnit ( unit ) ;
46253: LD_ADDR_VAR 0 3
46257: PUSH
46258: LD_VAR 0 1
46262: PPUSH
46263: CALL_OW 310
46267: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
46268: LD_VAR 0 3
46272: PPUSH
46273: CALL_OW 247
46277: PUSH
46278: LD_INT 2
46280: EQUAL
46281: IFFALSE 46294
// ComExitVehicle ( unit ) else
46283: LD_VAR 0 1
46287: PPUSH
46288: CALL_OW 121
46292: GO 46303
// ComExitBuilding ( unit ) ;
46294: LD_VAR 0 1
46298: PPUSH
46299: CALL_OW 122
// result := tmp ;
46303: LD_ADDR_VAR 0 2
46307: PUSH
46308: LD_VAR 0 3
46312: ST_TO_ADDR
// end ;
46313: LD_VAR 0 2
46317: RET
// export function ResetHc ; begin
46318: LD_INT 0
46320: PPUSH
// InitHc ;
46321: CALL_OW 19
// hc_importance := 0 ;
46325: LD_ADDR_OWVAR 32
46329: PUSH
46330: LD_INT 0
46332: ST_TO_ADDR
// end ;
46333: LD_VAR 0 1
46337: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
46338: LD_INT 0
46340: PPUSH
46341: PPUSH
46342: PPUSH
// _x := ( x1 + x2 ) div 2 ;
46343: LD_ADDR_VAR 0 6
46347: PUSH
46348: LD_VAR 0 1
46352: PUSH
46353: LD_VAR 0 3
46357: PLUS
46358: PUSH
46359: LD_INT 2
46361: DIV
46362: ST_TO_ADDR
// if _x < 0 then
46363: LD_VAR 0 6
46367: PUSH
46368: LD_INT 0
46370: LESS
46371: IFFALSE 46388
// _x := _x * - 1 ;
46373: LD_ADDR_VAR 0 6
46377: PUSH
46378: LD_VAR 0 6
46382: PUSH
46383: LD_INT 1
46385: NEG
46386: MUL
46387: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
46388: LD_ADDR_VAR 0 7
46392: PUSH
46393: LD_VAR 0 2
46397: PUSH
46398: LD_VAR 0 4
46402: PLUS
46403: PUSH
46404: LD_INT 2
46406: DIV
46407: ST_TO_ADDR
// if _y < 0 then
46408: LD_VAR 0 7
46412: PUSH
46413: LD_INT 0
46415: LESS
46416: IFFALSE 46433
// _y := _y * - 1 ;
46418: LD_ADDR_VAR 0 7
46422: PUSH
46423: LD_VAR 0 7
46427: PUSH
46428: LD_INT 1
46430: NEG
46431: MUL
46432: ST_TO_ADDR
// result := [ _x , _y ] ;
46433: LD_ADDR_VAR 0 5
46437: PUSH
46438: LD_VAR 0 6
46442: PUSH
46443: LD_VAR 0 7
46447: PUSH
46448: EMPTY
46449: LIST
46450: LIST
46451: ST_TO_ADDR
// end ;
46452: LD_VAR 0 5
46456: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
46457: LD_INT 0
46459: PPUSH
46460: PPUSH
46461: PPUSH
46462: PPUSH
// task := GetTaskList ( unit ) ;
46463: LD_ADDR_VAR 0 7
46467: PUSH
46468: LD_VAR 0 1
46472: PPUSH
46473: CALL_OW 437
46477: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
46478: LD_VAR 0 7
46482: NOT
46483: PUSH
46484: LD_VAR 0 1
46488: PPUSH
46489: LD_VAR 0 2
46493: PPUSH
46494: CALL_OW 308
46498: NOT
46499: AND
46500: IFFALSE 46504
// exit ;
46502: GO 46622
// if IsInArea ( unit , area ) then
46504: LD_VAR 0 1
46508: PPUSH
46509: LD_VAR 0 2
46513: PPUSH
46514: CALL_OW 308
46518: IFFALSE 46536
// begin ComMoveToArea ( unit , goAway ) ;
46520: LD_VAR 0 1
46524: PPUSH
46525: LD_VAR 0 3
46529: PPUSH
46530: CALL_OW 113
// exit ;
46534: GO 46622
// end ; if task [ 1 ] [ 1 ] <> M then
46536: LD_VAR 0 7
46540: PUSH
46541: LD_INT 1
46543: ARRAY
46544: PUSH
46545: LD_INT 1
46547: ARRAY
46548: PUSH
46549: LD_STRING M
46551: NONEQUAL
46552: IFFALSE 46556
// exit ;
46554: GO 46622
// x := task [ 1 ] [ 2 ] ;
46556: LD_ADDR_VAR 0 5
46560: PUSH
46561: LD_VAR 0 7
46565: PUSH
46566: LD_INT 1
46568: ARRAY
46569: PUSH
46570: LD_INT 2
46572: ARRAY
46573: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
46574: LD_ADDR_VAR 0 6
46578: PUSH
46579: LD_VAR 0 7
46583: PUSH
46584: LD_INT 1
46586: ARRAY
46587: PUSH
46588: LD_INT 3
46590: ARRAY
46591: ST_TO_ADDR
// if InArea ( x , y , area ) then
46592: LD_VAR 0 5
46596: PPUSH
46597: LD_VAR 0 6
46601: PPUSH
46602: LD_VAR 0 2
46606: PPUSH
46607: CALL_OW 309
46611: IFFALSE 46622
// ComStop ( unit ) ;
46613: LD_VAR 0 1
46617: PPUSH
46618: CALL_OW 141
// end ;
46622: LD_VAR 0 4
46626: RET
// export function Abs ( value ) ; begin
46627: LD_INT 0
46629: PPUSH
// result := value ;
46630: LD_ADDR_VAR 0 2
46634: PUSH
46635: LD_VAR 0 1
46639: ST_TO_ADDR
// if value < 0 then
46640: LD_VAR 0 1
46644: PUSH
46645: LD_INT 0
46647: LESS
46648: IFFALSE 46665
// result := value * - 1 ;
46650: LD_ADDR_VAR 0 2
46654: PUSH
46655: LD_VAR 0 1
46659: PUSH
46660: LD_INT 1
46662: NEG
46663: MUL
46664: ST_TO_ADDR
// end ;
46665: LD_VAR 0 2
46669: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
46670: LD_INT 0
46672: PPUSH
46673: PPUSH
46674: PPUSH
46675: PPUSH
46676: PPUSH
46677: PPUSH
46678: PPUSH
46679: PPUSH
// if not unit or not building then
46680: LD_VAR 0 1
46684: NOT
46685: PUSH
46686: LD_VAR 0 2
46690: NOT
46691: OR
46692: IFFALSE 46696
// exit ;
46694: GO 46922
// x := GetX ( building ) ;
46696: LD_ADDR_VAR 0 4
46700: PUSH
46701: LD_VAR 0 2
46705: PPUSH
46706: CALL_OW 250
46710: ST_TO_ADDR
// y := GetY ( building ) ;
46711: LD_ADDR_VAR 0 6
46715: PUSH
46716: LD_VAR 0 2
46720: PPUSH
46721: CALL_OW 251
46725: ST_TO_ADDR
// d := GetDir ( building ) ;
46726: LD_ADDR_VAR 0 8
46730: PUSH
46731: LD_VAR 0 2
46735: PPUSH
46736: CALL_OW 254
46740: ST_TO_ADDR
// r := 4 ;
46741: LD_ADDR_VAR 0 9
46745: PUSH
46746: LD_INT 4
46748: ST_TO_ADDR
// for i := 1 to 5 do
46749: LD_ADDR_VAR 0 10
46753: PUSH
46754: DOUBLE
46755: LD_INT 1
46757: DEC
46758: ST_TO_ADDR
46759: LD_INT 5
46761: PUSH
46762: FOR_TO
46763: IFFALSE 46920
// begin _x := ShiftX ( x , d , r + i ) ;
46765: LD_ADDR_VAR 0 5
46769: PUSH
46770: LD_VAR 0 4
46774: PPUSH
46775: LD_VAR 0 8
46779: PPUSH
46780: LD_VAR 0 9
46784: PUSH
46785: LD_VAR 0 10
46789: PLUS
46790: PPUSH
46791: CALL_OW 272
46795: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
46796: LD_ADDR_VAR 0 7
46800: PUSH
46801: LD_VAR 0 6
46805: PPUSH
46806: LD_VAR 0 8
46810: PPUSH
46811: LD_VAR 0 9
46815: PUSH
46816: LD_VAR 0 10
46820: PLUS
46821: PPUSH
46822: CALL_OW 273
46826: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
46827: LD_VAR 0 5
46831: PPUSH
46832: LD_VAR 0 7
46836: PPUSH
46837: CALL_OW 488
46841: PUSH
46842: LD_VAR 0 5
46846: PPUSH
46847: LD_VAR 0 7
46851: PPUSH
46852: CALL_OW 428
46856: PPUSH
46857: CALL_OW 247
46861: PUSH
46862: LD_INT 3
46864: PUSH
46865: LD_INT 2
46867: PUSH
46868: EMPTY
46869: LIST
46870: LIST
46871: IN
46872: NOT
46873: AND
46874: IFFALSE 46918
// begin ComMoveXY ( unit , _x , _y ) ;
46876: LD_VAR 0 1
46880: PPUSH
46881: LD_VAR 0 5
46885: PPUSH
46886: LD_VAR 0 7
46890: PPUSH
46891: CALL_OW 111
// result := [ _x , _y ] ;
46895: LD_ADDR_VAR 0 3
46899: PUSH
46900: LD_VAR 0 5
46904: PUSH
46905: LD_VAR 0 7
46909: PUSH
46910: EMPTY
46911: LIST
46912: LIST
46913: ST_TO_ADDR
// exit ;
46914: POP
46915: POP
46916: GO 46922
// end ; end ;
46918: GO 46762
46920: POP
46921: POP
// end ;
46922: LD_VAR 0 3
46926: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
46927: LD_INT 0
46929: PPUSH
46930: PPUSH
46931: PPUSH
// result := 0 ;
46932: LD_ADDR_VAR 0 3
46936: PUSH
46937: LD_INT 0
46939: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
46940: LD_VAR 0 1
46944: PUSH
46945: LD_INT 0
46947: LESS
46948: PUSH
46949: LD_VAR 0 1
46953: PUSH
46954: LD_INT 8
46956: GREATER
46957: OR
46958: PUSH
46959: LD_VAR 0 2
46963: PUSH
46964: LD_INT 0
46966: LESS
46967: OR
46968: PUSH
46969: LD_VAR 0 2
46973: PUSH
46974: LD_INT 8
46976: GREATER
46977: OR
46978: IFFALSE 46982
// exit ;
46980: GO 47057
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
46982: LD_ADDR_VAR 0 4
46986: PUSH
46987: LD_INT 22
46989: PUSH
46990: LD_VAR 0 2
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PPUSH
46999: CALL_OW 69
47003: PUSH
47004: FOR_IN
47005: IFFALSE 47055
// begin un := UnitShoot ( i ) ;
47007: LD_ADDR_VAR 0 5
47011: PUSH
47012: LD_VAR 0 4
47016: PPUSH
47017: CALL_OW 504
47021: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47022: LD_VAR 0 5
47026: PPUSH
47027: CALL_OW 255
47031: PUSH
47032: LD_VAR 0 1
47036: EQUAL
47037: IFFALSE 47053
// begin result := un ;
47039: LD_ADDR_VAR 0 3
47043: PUSH
47044: LD_VAR 0 5
47048: ST_TO_ADDR
// exit ;
47049: POP
47050: POP
47051: GO 47057
// end ; end ;
47053: GO 47004
47055: POP
47056: POP
// end ; end_of_file
47057: LD_VAR 0 3
47061: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
47062: LD_INT 0
47064: PPUSH
47065: PPUSH
// skirmish := false ;
47066: LD_ADDR_EXP 40
47070: PUSH
47071: LD_INT 0
47073: ST_TO_ADDR
// debug_mc := false ;
47074: LD_ADDR_EXP 41
47078: PUSH
47079: LD_INT 0
47081: ST_TO_ADDR
// mc_bases := [ ] ;
47082: LD_ADDR_EXP 42
47086: PUSH
47087: EMPTY
47088: ST_TO_ADDR
// mc_sides := [ ] ;
47089: LD_ADDR_EXP 68
47093: PUSH
47094: EMPTY
47095: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
47096: LD_ADDR_EXP 43
47100: PUSH
47101: EMPTY
47102: ST_TO_ADDR
// mc_building_repairs := [ ] ;
47103: LD_ADDR_EXP 44
47107: PUSH
47108: EMPTY
47109: ST_TO_ADDR
// mc_need_heal := [ ] ;
47110: LD_ADDR_EXP 45
47114: PUSH
47115: EMPTY
47116: ST_TO_ADDR
// mc_healers := [ ] ;
47117: LD_ADDR_EXP 46
47121: PUSH
47122: EMPTY
47123: ST_TO_ADDR
// mc_build_list := [ ] ;
47124: LD_ADDR_EXP 47
47128: PUSH
47129: EMPTY
47130: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
47131: LD_ADDR_EXP 74
47135: PUSH
47136: EMPTY
47137: ST_TO_ADDR
// mc_builders := [ ] ;
47138: LD_ADDR_EXP 48
47142: PUSH
47143: EMPTY
47144: ST_TO_ADDR
// mc_construct_list := [ ] ;
47145: LD_ADDR_EXP 49
47149: PUSH
47150: EMPTY
47151: ST_TO_ADDR
// mc_turret_list := [ ] ;
47152: LD_ADDR_EXP 50
47156: PUSH
47157: EMPTY
47158: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
47159: LD_ADDR_EXP 51
47163: PUSH
47164: EMPTY
47165: ST_TO_ADDR
// mc_miners := [ ] ;
47166: LD_ADDR_EXP 56
47170: PUSH
47171: EMPTY
47172: ST_TO_ADDR
// mc_mines := [ ] ;
47173: LD_ADDR_EXP 55
47177: PUSH
47178: EMPTY
47179: ST_TO_ADDR
// mc_minefields := [ ] ;
47180: LD_ADDR_EXP 57
47184: PUSH
47185: EMPTY
47186: ST_TO_ADDR
// mc_crates := [ ] ;
47187: LD_ADDR_EXP 58
47191: PUSH
47192: EMPTY
47193: ST_TO_ADDR
// mc_crates_collector := [ ] ;
47194: LD_ADDR_EXP 59
47198: PUSH
47199: EMPTY
47200: ST_TO_ADDR
// mc_crates_area := [ ] ;
47201: LD_ADDR_EXP 60
47205: PUSH
47206: EMPTY
47207: ST_TO_ADDR
// mc_vehicles := [ ] ;
47208: LD_ADDR_EXP 61
47212: PUSH
47213: EMPTY
47214: ST_TO_ADDR
// mc_attack := [ ] ;
47215: LD_ADDR_EXP 62
47219: PUSH
47220: EMPTY
47221: ST_TO_ADDR
// mc_produce := [ ] ;
47222: LD_ADDR_EXP 63
47226: PUSH
47227: EMPTY
47228: ST_TO_ADDR
// mc_defender := [ ] ;
47229: LD_ADDR_EXP 64
47233: PUSH
47234: EMPTY
47235: ST_TO_ADDR
// mc_parking := [ ] ;
47236: LD_ADDR_EXP 66
47240: PUSH
47241: EMPTY
47242: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
47243: LD_ADDR_EXP 52
47247: PUSH
47248: EMPTY
47249: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
47250: LD_ADDR_EXP 54
47254: PUSH
47255: EMPTY
47256: ST_TO_ADDR
// mc_scan := [ ] ;
47257: LD_ADDR_EXP 65
47261: PUSH
47262: EMPTY
47263: ST_TO_ADDR
// mc_scan_area := [ ] ;
47264: LD_ADDR_EXP 67
47268: PUSH
47269: EMPTY
47270: ST_TO_ADDR
// mc_tech := [ ] ;
47271: LD_ADDR_EXP 69
47275: PUSH
47276: EMPTY
47277: ST_TO_ADDR
// mc_class := [ ] ;
47278: LD_ADDR_EXP 83
47282: PUSH
47283: EMPTY
47284: ST_TO_ADDR
// mc_class_case_use := [ ] ;
47285: LD_ADDR_EXP 84
47289: PUSH
47290: EMPTY
47291: ST_TO_ADDR
// end ;
47292: LD_VAR 0 1
47296: RET
// export function MC_Kill ( base ) ; begin
47297: LD_INT 0
47299: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
47300: LD_ADDR_EXP 42
47304: PUSH
47305: LD_EXP 42
47309: PPUSH
47310: LD_VAR 0 1
47314: PPUSH
47315: EMPTY
47316: PPUSH
47317: CALL_OW 1
47321: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
47322: LD_ADDR_EXP 43
47326: PUSH
47327: LD_EXP 43
47331: PPUSH
47332: LD_VAR 0 1
47336: PPUSH
47337: EMPTY
47338: PPUSH
47339: CALL_OW 1
47343: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
47344: LD_ADDR_EXP 44
47348: PUSH
47349: LD_EXP 44
47353: PPUSH
47354: LD_VAR 0 1
47358: PPUSH
47359: EMPTY
47360: PPUSH
47361: CALL_OW 1
47365: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
47366: LD_ADDR_EXP 45
47370: PUSH
47371: LD_EXP 45
47375: PPUSH
47376: LD_VAR 0 1
47380: PPUSH
47381: EMPTY
47382: PPUSH
47383: CALL_OW 1
47387: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
47388: LD_ADDR_EXP 46
47392: PUSH
47393: LD_EXP 46
47397: PPUSH
47398: LD_VAR 0 1
47402: PPUSH
47403: EMPTY
47404: PPUSH
47405: CALL_OW 1
47409: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
47410: LD_ADDR_EXP 47
47414: PUSH
47415: LD_EXP 47
47419: PPUSH
47420: LD_VAR 0 1
47424: PPUSH
47425: EMPTY
47426: PPUSH
47427: CALL_OW 1
47431: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
47432: LD_ADDR_EXP 48
47436: PUSH
47437: LD_EXP 48
47441: PPUSH
47442: LD_VAR 0 1
47446: PPUSH
47447: EMPTY
47448: PPUSH
47449: CALL_OW 1
47453: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
47454: LD_ADDR_EXP 49
47458: PUSH
47459: LD_EXP 49
47463: PPUSH
47464: LD_VAR 0 1
47468: PPUSH
47469: EMPTY
47470: PPUSH
47471: CALL_OW 1
47475: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
47476: LD_ADDR_EXP 50
47480: PUSH
47481: LD_EXP 50
47485: PPUSH
47486: LD_VAR 0 1
47490: PPUSH
47491: EMPTY
47492: PPUSH
47493: CALL_OW 1
47497: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
47498: LD_ADDR_EXP 51
47502: PUSH
47503: LD_EXP 51
47507: PPUSH
47508: LD_VAR 0 1
47512: PPUSH
47513: EMPTY
47514: PPUSH
47515: CALL_OW 1
47519: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
47520: LD_ADDR_EXP 52
47524: PUSH
47525: LD_EXP 52
47529: PPUSH
47530: LD_VAR 0 1
47534: PPUSH
47535: EMPTY
47536: PPUSH
47537: CALL_OW 1
47541: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
47542: LD_ADDR_EXP 53
47546: PUSH
47547: LD_EXP 53
47551: PPUSH
47552: LD_VAR 0 1
47556: PPUSH
47557: LD_INT 0
47559: PPUSH
47560: CALL_OW 1
47564: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
47565: LD_ADDR_EXP 54
47569: PUSH
47570: LD_EXP 54
47574: PPUSH
47575: LD_VAR 0 1
47579: PPUSH
47580: EMPTY
47581: PPUSH
47582: CALL_OW 1
47586: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
47587: LD_ADDR_EXP 55
47591: PUSH
47592: LD_EXP 55
47596: PPUSH
47597: LD_VAR 0 1
47601: PPUSH
47602: EMPTY
47603: PPUSH
47604: CALL_OW 1
47608: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
47609: LD_ADDR_EXP 56
47613: PUSH
47614: LD_EXP 56
47618: PPUSH
47619: LD_VAR 0 1
47623: PPUSH
47624: EMPTY
47625: PPUSH
47626: CALL_OW 1
47630: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
47631: LD_ADDR_EXP 57
47635: PUSH
47636: LD_EXP 57
47640: PPUSH
47641: LD_VAR 0 1
47645: PPUSH
47646: EMPTY
47647: PPUSH
47648: CALL_OW 1
47652: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
47653: LD_ADDR_EXP 58
47657: PUSH
47658: LD_EXP 58
47662: PPUSH
47663: LD_VAR 0 1
47667: PPUSH
47668: EMPTY
47669: PPUSH
47670: CALL_OW 1
47674: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
47675: LD_ADDR_EXP 59
47679: PUSH
47680: LD_EXP 59
47684: PPUSH
47685: LD_VAR 0 1
47689: PPUSH
47690: EMPTY
47691: PPUSH
47692: CALL_OW 1
47696: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
47697: LD_ADDR_EXP 60
47701: PUSH
47702: LD_EXP 60
47706: PPUSH
47707: LD_VAR 0 1
47711: PPUSH
47712: EMPTY
47713: PPUSH
47714: CALL_OW 1
47718: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
47719: LD_ADDR_EXP 61
47723: PUSH
47724: LD_EXP 61
47728: PPUSH
47729: LD_VAR 0 1
47733: PPUSH
47734: EMPTY
47735: PPUSH
47736: CALL_OW 1
47740: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
47741: LD_ADDR_EXP 62
47745: PUSH
47746: LD_EXP 62
47750: PPUSH
47751: LD_VAR 0 1
47755: PPUSH
47756: EMPTY
47757: PPUSH
47758: CALL_OW 1
47762: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
47763: LD_ADDR_EXP 63
47767: PUSH
47768: LD_EXP 63
47772: PPUSH
47773: LD_VAR 0 1
47777: PPUSH
47778: EMPTY
47779: PPUSH
47780: CALL_OW 1
47784: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
47785: LD_ADDR_EXP 64
47789: PUSH
47790: LD_EXP 64
47794: PPUSH
47795: LD_VAR 0 1
47799: PPUSH
47800: EMPTY
47801: PPUSH
47802: CALL_OW 1
47806: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
47807: LD_ADDR_EXP 65
47811: PUSH
47812: LD_EXP 65
47816: PPUSH
47817: LD_VAR 0 1
47821: PPUSH
47822: EMPTY
47823: PPUSH
47824: CALL_OW 1
47828: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
47829: LD_ADDR_EXP 66
47833: PUSH
47834: LD_EXP 66
47838: PPUSH
47839: LD_VAR 0 1
47843: PPUSH
47844: EMPTY
47845: PPUSH
47846: CALL_OW 1
47850: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
47851: LD_ADDR_EXP 67
47855: PUSH
47856: LD_EXP 67
47860: PPUSH
47861: LD_VAR 0 1
47865: PPUSH
47866: EMPTY
47867: PPUSH
47868: CALL_OW 1
47872: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
47873: LD_ADDR_EXP 69
47877: PUSH
47878: LD_EXP 69
47882: PPUSH
47883: LD_VAR 0 1
47887: PPUSH
47888: EMPTY
47889: PPUSH
47890: CALL_OW 1
47894: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
47895: LD_ADDR_EXP 71
47899: PUSH
47900: LD_EXP 71
47904: PPUSH
47905: LD_VAR 0 1
47909: PPUSH
47910: EMPTY
47911: PPUSH
47912: CALL_OW 1
47916: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
47917: LD_ADDR_EXP 72
47921: PUSH
47922: LD_EXP 72
47926: PPUSH
47927: LD_VAR 0 1
47931: PPUSH
47932: EMPTY
47933: PPUSH
47934: CALL_OW 1
47938: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
47939: LD_ADDR_EXP 73
47943: PUSH
47944: LD_EXP 73
47948: PPUSH
47949: LD_VAR 0 1
47953: PPUSH
47954: EMPTY
47955: PPUSH
47956: CALL_OW 1
47960: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
47961: LD_ADDR_EXP 74
47965: PUSH
47966: LD_EXP 74
47970: PPUSH
47971: LD_VAR 0 1
47975: PPUSH
47976: EMPTY
47977: PPUSH
47978: CALL_OW 1
47982: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
47983: LD_ADDR_EXP 75
47987: PUSH
47988: LD_EXP 75
47992: PPUSH
47993: LD_VAR 0 1
47997: PPUSH
47998: EMPTY
47999: PPUSH
48000: CALL_OW 1
48004: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48005: LD_ADDR_EXP 76
48009: PUSH
48010: LD_EXP 76
48014: PPUSH
48015: LD_VAR 0 1
48019: PPUSH
48020: EMPTY
48021: PPUSH
48022: CALL_OW 1
48026: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48027: LD_ADDR_EXP 77
48031: PUSH
48032: LD_EXP 77
48036: PPUSH
48037: LD_VAR 0 1
48041: PPUSH
48042: EMPTY
48043: PPUSH
48044: CALL_OW 1
48048: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48049: LD_ADDR_EXP 78
48053: PUSH
48054: LD_EXP 78
48058: PPUSH
48059: LD_VAR 0 1
48063: PPUSH
48064: EMPTY
48065: PPUSH
48066: CALL_OW 1
48070: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48071: LD_ADDR_EXP 79
48075: PUSH
48076: LD_EXP 79
48080: PPUSH
48081: LD_VAR 0 1
48085: PPUSH
48086: EMPTY
48087: PPUSH
48088: CALL_OW 1
48092: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48093: LD_ADDR_EXP 80
48097: PUSH
48098: LD_EXP 80
48102: PPUSH
48103: LD_VAR 0 1
48107: PPUSH
48108: EMPTY
48109: PPUSH
48110: CALL_OW 1
48114: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
48115: LD_ADDR_EXP 81
48119: PUSH
48120: LD_EXP 81
48124: PPUSH
48125: LD_VAR 0 1
48129: PPUSH
48130: EMPTY
48131: PPUSH
48132: CALL_OW 1
48136: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
48137: LD_ADDR_EXP 82
48141: PUSH
48142: LD_EXP 82
48146: PPUSH
48147: LD_VAR 0 1
48151: PPUSH
48152: EMPTY
48153: PPUSH
48154: CALL_OW 1
48158: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
48159: LD_ADDR_EXP 83
48163: PUSH
48164: LD_EXP 83
48168: PPUSH
48169: LD_VAR 0 1
48173: PPUSH
48174: EMPTY
48175: PPUSH
48176: CALL_OW 1
48180: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
48181: LD_ADDR_EXP 84
48185: PUSH
48186: LD_EXP 84
48190: PPUSH
48191: LD_VAR 0 1
48195: PPUSH
48196: LD_INT 0
48198: PPUSH
48199: CALL_OW 1
48203: ST_TO_ADDR
// end ;
48204: LD_VAR 0 2
48208: RET
// export function MC_Add ( side , units ) ; var base ; begin
48209: LD_INT 0
48211: PPUSH
48212: PPUSH
// base := mc_bases + 1 ;
48213: LD_ADDR_VAR 0 4
48217: PUSH
48218: LD_EXP 42
48222: PUSH
48223: LD_INT 1
48225: PLUS
48226: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
48227: LD_ADDR_EXP 68
48231: PUSH
48232: LD_EXP 68
48236: PPUSH
48237: LD_VAR 0 4
48241: PPUSH
48242: LD_VAR 0 1
48246: PPUSH
48247: CALL_OW 1
48251: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
48252: LD_ADDR_EXP 42
48256: PUSH
48257: LD_EXP 42
48261: PPUSH
48262: LD_VAR 0 4
48266: PPUSH
48267: LD_VAR 0 2
48271: PPUSH
48272: CALL_OW 1
48276: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
48277: LD_ADDR_EXP 43
48281: PUSH
48282: LD_EXP 43
48286: PPUSH
48287: LD_VAR 0 4
48291: PPUSH
48292: EMPTY
48293: PPUSH
48294: CALL_OW 1
48298: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
48299: LD_ADDR_EXP 44
48303: PUSH
48304: LD_EXP 44
48308: PPUSH
48309: LD_VAR 0 4
48313: PPUSH
48314: EMPTY
48315: PPUSH
48316: CALL_OW 1
48320: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
48321: LD_ADDR_EXP 45
48325: PUSH
48326: LD_EXP 45
48330: PPUSH
48331: LD_VAR 0 4
48335: PPUSH
48336: EMPTY
48337: PPUSH
48338: CALL_OW 1
48342: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
48343: LD_ADDR_EXP 46
48347: PUSH
48348: LD_EXP 46
48352: PPUSH
48353: LD_VAR 0 4
48357: PPUSH
48358: EMPTY
48359: PPUSH
48360: CALL_OW 1
48364: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
48365: LD_ADDR_EXP 47
48369: PUSH
48370: LD_EXP 47
48374: PPUSH
48375: LD_VAR 0 4
48379: PPUSH
48380: EMPTY
48381: PPUSH
48382: CALL_OW 1
48386: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48387: LD_ADDR_EXP 48
48391: PUSH
48392: LD_EXP 48
48396: PPUSH
48397: LD_VAR 0 4
48401: PPUSH
48402: EMPTY
48403: PPUSH
48404: CALL_OW 1
48408: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
48409: LD_ADDR_EXP 49
48413: PUSH
48414: LD_EXP 49
48418: PPUSH
48419: LD_VAR 0 4
48423: PPUSH
48424: EMPTY
48425: PPUSH
48426: CALL_OW 1
48430: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
48431: LD_ADDR_EXP 50
48435: PUSH
48436: LD_EXP 50
48440: PPUSH
48441: LD_VAR 0 4
48445: PPUSH
48446: EMPTY
48447: PPUSH
48448: CALL_OW 1
48452: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
48453: LD_ADDR_EXP 51
48457: PUSH
48458: LD_EXP 51
48462: PPUSH
48463: LD_VAR 0 4
48467: PPUSH
48468: EMPTY
48469: PPUSH
48470: CALL_OW 1
48474: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48475: LD_ADDR_EXP 52
48479: PUSH
48480: LD_EXP 52
48484: PPUSH
48485: LD_VAR 0 4
48489: PPUSH
48490: EMPTY
48491: PPUSH
48492: CALL_OW 1
48496: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
48497: LD_ADDR_EXP 53
48501: PUSH
48502: LD_EXP 53
48506: PPUSH
48507: LD_VAR 0 4
48511: PPUSH
48512: LD_INT 0
48514: PPUSH
48515: CALL_OW 1
48519: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48520: LD_ADDR_EXP 54
48524: PUSH
48525: LD_EXP 54
48529: PPUSH
48530: LD_VAR 0 4
48534: PPUSH
48535: EMPTY
48536: PPUSH
48537: CALL_OW 1
48541: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48542: LD_ADDR_EXP 55
48546: PUSH
48547: LD_EXP 55
48551: PPUSH
48552: LD_VAR 0 4
48556: PPUSH
48557: EMPTY
48558: PPUSH
48559: CALL_OW 1
48563: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
48564: LD_ADDR_EXP 56
48568: PUSH
48569: LD_EXP 56
48573: PPUSH
48574: LD_VAR 0 4
48578: PPUSH
48579: EMPTY
48580: PPUSH
48581: CALL_OW 1
48585: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
48586: LD_ADDR_EXP 57
48590: PUSH
48591: LD_EXP 57
48595: PPUSH
48596: LD_VAR 0 4
48600: PPUSH
48601: EMPTY
48602: PPUSH
48603: CALL_OW 1
48607: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
48608: LD_ADDR_EXP 58
48612: PUSH
48613: LD_EXP 58
48617: PPUSH
48618: LD_VAR 0 4
48622: PPUSH
48623: EMPTY
48624: PPUSH
48625: CALL_OW 1
48629: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
48630: LD_ADDR_EXP 59
48634: PUSH
48635: LD_EXP 59
48639: PPUSH
48640: LD_VAR 0 4
48644: PPUSH
48645: EMPTY
48646: PPUSH
48647: CALL_OW 1
48651: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
48652: LD_ADDR_EXP 60
48656: PUSH
48657: LD_EXP 60
48661: PPUSH
48662: LD_VAR 0 4
48666: PPUSH
48667: EMPTY
48668: PPUSH
48669: CALL_OW 1
48673: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
48674: LD_ADDR_EXP 61
48678: PUSH
48679: LD_EXP 61
48683: PPUSH
48684: LD_VAR 0 4
48688: PPUSH
48689: EMPTY
48690: PPUSH
48691: CALL_OW 1
48695: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
48696: LD_ADDR_EXP 62
48700: PUSH
48701: LD_EXP 62
48705: PPUSH
48706: LD_VAR 0 4
48710: PPUSH
48711: EMPTY
48712: PPUSH
48713: CALL_OW 1
48717: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
48718: LD_ADDR_EXP 63
48722: PUSH
48723: LD_EXP 63
48727: PPUSH
48728: LD_VAR 0 4
48732: PPUSH
48733: EMPTY
48734: PPUSH
48735: CALL_OW 1
48739: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
48740: LD_ADDR_EXP 64
48744: PUSH
48745: LD_EXP 64
48749: PPUSH
48750: LD_VAR 0 4
48754: PPUSH
48755: EMPTY
48756: PPUSH
48757: CALL_OW 1
48761: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
48762: LD_ADDR_EXP 65
48766: PUSH
48767: LD_EXP 65
48771: PPUSH
48772: LD_VAR 0 4
48776: PPUSH
48777: EMPTY
48778: PPUSH
48779: CALL_OW 1
48783: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
48784: LD_ADDR_EXP 66
48788: PUSH
48789: LD_EXP 66
48793: PPUSH
48794: LD_VAR 0 4
48798: PPUSH
48799: EMPTY
48800: PPUSH
48801: CALL_OW 1
48805: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
48806: LD_ADDR_EXP 67
48810: PUSH
48811: LD_EXP 67
48815: PPUSH
48816: LD_VAR 0 4
48820: PPUSH
48821: EMPTY
48822: PPUSH
48823: CALL_OW 1
48827: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
48828: LD_ADDR_EXP 69
48832: PUSH
48833: LD_EXP 69
48837: PPUSH
48838: LD_VAR 0 4
48842: PPUSH
48843: EMPTY
48844: PPUSH
48845: CALL_OW 1
48849: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
48850: LD_ADDR_EXP 71
48854: PUSH
48855: LD_EXP 71
48859: PPUSH
48860: LD_VAR 0 4
48864: PPUSH
48865: EMPTY
48866: PPUSH
48867: CALL_OW 1
48871: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
48872: LD_ADDR_EXP 72
48876: PUSH
48877: LD_EXP 72
48881: PPUSH
48882: LD_VAR 0 4
48886: PPUSH
48887: EMPTY
48888: PPUSH
48889: CALL_OW 1
48893: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48894: LD_ADDR_EXP 73
48898: PUSH
48899: LD_EXP 73
48903: PPUSH
48904: LD_VAR 0 4
48908: PPUSH
48909: EMPTY
48910: PPUSH
48911: CALL_OW 1
48915: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48916: LD_ADDR_EXP 74
48920: PUSH
48921: LD_EXP 74
48925: PPUSH
48926: LD_VAR 0 4
48930: PPUSH
48931: EMPTY
48932: PPUSH
48933: CALL_OW 1
48937: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
48938: LD_ADDR_EXP 75
48942: PUSH
48943: LD_EXP 75
48947: PPUSH
48948: LD_VAR 0 4
48952: PPUSH
48953: EMPTY
48954: PPUSH
48955: CALL_OW 1
48959: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48960: LD_ADDR_EXP 76
48964: PUSH
48965: LD_EXP 76
48969: PPUSH
48970: LD_VAR 0 4
48974: PPUSH
48975: EMPTY
48976: PPUSH
48977: CALL_OW 1
48981: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48982: LD_ADDR_EXP 77
48986: PUSH
48987: LD_EXP 77
48991: PPUSH
48992: LD_VAR 0 4
48996: PPUSH
48997: EMPTY
48998: PPUSH
48999: CALL_OW 1
49003: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
49004: LD_ADDR_EXP 78
49008: PUSH
49009: LD_EXP 78
49013: PPUSH
49014: LD_VAR 0 4
49018: PPUSH
49019: EMPTY
49020: PPUSH
49021: CALL_OW 1
49025: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
49026: LD_ADDR_EXP 79
49030: PUSH
49031: LD_EXP 79
49035: PPUSH
49036: LD_VAR 0 4
49040: PPUSH
49041: EMPTY
49042: PPUSH
49043: CALL_OW 1
49047: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
49048: LD_ADDR_EXP 80
49052: PUSH
49053: LD_EXP 80
49057: PPUSH
49058: LD_VAR 0 4
49062: PPUSH
49063: EMPTY
49064: PPUSH
49065: CALL_OW 1
49069: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49070: LD_ADDR_EXP 81
49074: PUSH
49075: LD_EXP 81
49079: PPUSH
49080: LD_VAR 0 4
49084: PPUSH
49085: EMPTY
49086: PPUSH
49087: CALL_OW 1
49091: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49092: LD_ADDR_EXP 82
49096: PUSH
49097: LD_EXP 82
49101: PPUSH
49102: LD_VAR 0 4
49106: PPUSH
49107: EMPTY
49108: PPUSH
49109: CALL_OW 1
49113: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49114: LD_ADDR_EXP 83
49118: PUSH
49119: LD_EXP 83
49123: PPUSH
49124: LD_VAR 0 4
49128: PPUSH
49129: EMPTY
49130: PPUSH
49131: CALL_OW 1
49135: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49136: LD_ADDR_EXP 84
49140: PUSH
49141: LD_EXP 84
49145: PPUSH
49146: LD_VAR 0 4
49150: PPUSH
49151: LD_INT 0
49153: PPUSH
49154: CALL_OW 1
49158: ST_TO_ADDR
// result := base ;
49159: LD_ADDR_VAR 0 3
49163: PUSH
49164: LD_VAR 0 4
49168: ST_TO_ADDR
// end ;
49169: LD_VAR 0 3
49173: RET
// export function MC_Start ( ) ; var i ; begin
49174: LD_INT 0
49176: PPUSH
49177: PPUSH
// for i = 1 to mc_bases do
49178: LD_ADDR_VAR 0 2
49182: PUSH
49183: DOUBLE
49184: LD_INT 1
49186: DEC
49187: ST_TO_ADDR
49188: LD_EXP 42
49192: PUSH
49193: FOR_TO
49194: IFFALSE 50271
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
49196: LD_ADDR_EXP 42
49200: PUSH
49201: LD_EXP 42
49205: PPUSH
49206: LD_VAR 0 2
49210: PPUSH
49211: LD_EXP 42
49215: PUSH
49216: LD_VAR 0 2
49220: ARRAY
49221: PUSH
49222: LD_INT 0
49224: DIFF
49225: PPUSH
49226: CALL_OW 1
49230: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
49231: LD_ADDR_EXP 43
49235: PUSH
49236: LD_EXP 43
49240: PPUSH
49241: LD_VAR 0 2
49245: PPUSH
49246: EMPTY
49247: PPUSH
49248: CALL_OW 1
49252: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49253: LD_ADDR_EXP 44
49257: PUSH
49258: LD_EXP 44
49262: PPUSH
49263: LD_VAR 0 2
49267: PPUSH
49268: EMPTY
49269: PPUSH
49270: CALL_OW 1
49274: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
49275: LD_ADDR_EXP 45
49279: PUSH
49280: LD_EXP 45
49284: PPUSH
49285: LD_VAR 0 2
49289: PPUSH
49290: EMPTY
49291: PPUSH
49292: CALL_OW 1
49296: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
49297: LD_ADDR_EXP 46
49301: PUSH
49302: LD_EXP 46
49306: PPUSH
49307: LD_VAR 0 2
49311: PPUSH
49312: EMPTY
49313: PUSH
49314: EMPTY
49315: PUSH
49316: EMPTY
49317: LIST
49318: LIST
49319: PPUSH
49320: CALL_OW 1
49324: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
49325: LD_ADDR_EXP 47
49329: PUSH
49330: LD_EXP 47
49334: PPUSH
49335: LD_VAR 0 2
49339: PPUSH
49340: EMPTY
49341: PPUSH
49342: CALL_OW 1
49346: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
49347: LD_ADDR_EXP 74
49351: PUSH
49352: LD_EXP 74
49356: PPUSH
49357: LD_VAR 0 2
49361: PPUSH
49362: EMPTY
49363: PPUSH
49364: CALL_OW 1
49368: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
49369: LD_ADDR_EXP 48
49373: PUSH
49374: LD_EXP 48
49378: PPUSH
49379: LD_VAR 0 2
49383: PPUSH
49384: EMPTY
49385: PPUSH
49386: CALL_OW 1
49390: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
49391: LD_ADDR_EXP 49
49395: PUSH
49396: LD_EXP 49
49400: PPUSH
49401: LD_VAR 0 2
49405: PPUSH
49406: EMPTY
49407: PPUSH
49408: CALL_OW 1
49412: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
49413: LD_ADDR_EXP 50
49417: PUSH
49418: LD_EXP 50
49422: PPUSH
49423: LD_VAR 0 2
49427: PPUSH
49428: LD_EXP 42
49432: PUSH
49433: LD_VAR 0 2
49437: ARRAY
49438: PPUSH
49439: LD_INT 2
49441: PUSH
49442: LD_INT 30
49444: PUSH
49445: LD_INT 32
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: PUSH
49452: LD_INT 30
49454: PUSH
49455: LD_INT 33
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: EMPTY
49463: LIST
49464: LIST
49465: LIST
49466: PPUSH
49467: CALL_OW 72
49471: PPUSH
49472: CALL_OW 1
49476: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
49477: LD_ADDR_EXP 51
49481: PUSH
49482: LD_EXP 51
49486: PPUSH
49487: LD_VAR 0 2
49491: PPUSH
49492: LD_EXP 42
49496: PUSH
49497: LD_VAR 0 2
49501: ARRAY
49502: PPUSH
49503: LD_INT 2
49505: PUSH
49506: LD_INT 30
49508: PUSH
49509: LD_INT 32
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: PUSH
49516: LD_INT 30
49518: PUSH
49519: LD_INT 31
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: LIST
49530: PUSH
49531: LD_INT 58
49533: PUSH
49534: EMPTY
49535: LIST
49536: PUSH
49537: EMPTY
49538: LIST
49539: LIST
49540: PPUSH
49541: CALL_OW 72
49545: PPUSH
49546: CALL_OW 1
49550: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
49551: LD_ADDR_EXP 52
49555: PUSH
49556: LD_EXP 52
49560: PPUSH
49561: LD_VAR 0 2
49565: PPUSH
49566: EMPTY
49567: PPUSH
49568: CALL_OW 1
49572: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
49573: LD_ADDR_EXP 56
49577: PUSH
49578: LD_EXP 56
49582: PPUSH
49583: LD_VAR 0 2
49587: PPUSH
49588: EMPTY
49589: PPUSH
49590: CALL_OW 1
49594: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
49595: LD_ADDR_EXP 55
49599: PUSH
49600: LD_EXP 55
49604: PPUSH
49605: LD_VAR 0 2
49609: PPUSH
49610: EMPTY
49611: PPUSH
49612: CALL_OW 1
49616: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
49617: LD_ADDR_EXP 57
49621: PUSH
49622: LD_EXP 57
49626: PPUSH
49627: LD_VAR 0 2
49631: PPUSH
49632: EMPTY
49633: PPUSH
49634: CALL_OW 1
49638: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
49639: LD_ADDR_EXP 58
49643: PUSH
49644: LD_EXP 58
49648: PPUSH
49649: LD_VAR 0 2
49653: PPUSH
49654: EMPTY
49655: PPUSH
49656: CALL_OW 1
49660: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
49661: LD_ADDR_EXP 59
49665: PUSH
49666: LD_EXP 59
49670: PPUSH
49671: LD_VAR 0 2
49675: PPUSH
49676: EMPTY
49677: PPUSH
49678: CALL_OW 1
49682: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
49683: LD_ADDR_EXP 60
49687: PUSH
49688: LD_EXP 60
49692: PPUSH
49693: LD_VAR 0 2
49697: PPUSH
49698: EMPTY
49699: PPUSH
49700: CALL_OW 1
49704: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
49705: LD_ADDR_EXP 61
49709: PUSH
49710: LD_EXP 61
49714: PPUSH
49715: LD_VAR 0 2
49719: PPUSH
49720: EMPTY
49721: PPUSH
49722: CALL_OW 1
49726: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49727: LD_ADDR_EXP 62
49731: PUSH
49732: LD_EXP 62
49736: PPUSH
49737: LD_VAR 0 2
49741: PPUSH
49742: EMPTY
49743: PPUSH
49744: CALL_OW 1
49748: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
49749: LD_ADDR_EXP 63
49753: PUSH
49754: LD_EXP 63
49758: PPUSH
49759: LD_VAR 0 2
49763: PPUSH
49764: EMPTY
49765: PPUSH
49766: CALL_OW 1
49770: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
49771: LD_ADDR_EXP 64
49775: PUSH
49776: LD_EXP 64
49780: PPUSH
49781: LD_VAR 0 2
49785: PPUSH
49786: EMPTY
49787: PPUSH
49788: CALL_OW 1
49792: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
49793: LD_ADDR_EXP 53
49797: PUSH
49798: LD_EXP 53
49802: PPUSH
49803: LD_VAR 0 2
49807: PPUSH
49808: LD_INT 0
49810: PPUSH
49811: CALL_OW 1
49815: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
49816: LD_ADDR_EXP 66
49820: PUSH
49821: LD_EXP 66
49825: PPUSH
49826: LD_VAR 0 2
49830: PPUSH
49831: LD_INT 0
49833: PPUSH
49834: CALL_OW 1
49838: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49839: LD_ADDR_EXP 54
49843: PUSH
49844: LD_EXP 54
49848: PPUSH
49849: LD_VAR 0 2
49853: PPUSH
49854: EMPTY
49855: PPUSH
49856: CALL_OW 1
49860: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
49861: LD_ADDR_EXP 65
49865: PUSH
49866: LD_EXP 65
49870: PPUSH
49871: LD_VAR 0 2
49875: PPUSH
49876: LD_INT 0
49878: PPUSH
49879: CALL_OW 1
49883: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
49884: LD_ADDR_EXP 67
49888: PUSH
49889: LD_EXP 67
49893: PPUSH
49894: LD_VAR 0 2
49898: PPUSH
49899: EMPTY
49900: PPUSH
49901: CALL_OW 1
49905: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
49906: LD_ADDR_EXP 70
49910: PUSH
49911: LD_EXP 70
49915: PPUSH
49916: LD_VAR 0 2
49920: PPUSH
49921: LD_INT 0
49923: PPUSH
49924: CALL_OW 1
49928: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
49929: LD_ADDR_EXP 71
49933: PUSH
49934: LD_EXP 71
49938: PPUSH
49939: LD_VAR 0 2
49943: PPUSH
49944: EMPTY
49945: PPUSH
49946: CALL_OW 1
49950: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49951: LD_ADDR_EXP 72
49955: PUSH
49956: LD_EXP 72
49960: PPUSH
49961: LD_VAR 0 2
49965: PPUSH
49966: EMPTY
49967: PPUSH
49968: CALL_OW 1
49972: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49973: LD_ADDR_EXP 73
49977: PUSH
49978: LD_EXP 73
49982: PPUSH
49983: LD_VAR 0 2
49987: PPUSH
49988: EMPTY
49989: PPUSH
49990: CALL_OW 1
49994: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
49995: LD_ADDR_EXP 75
49999: PUSH
50000: LD_EXP 75
50004: PPUSH
50005: LD_VAR 0 2
50009: PPUSH
50010: LD_EXP 42
50014: PUSH
50015: LD_VAR 0 2
50019: ARRAY
50020: PPUSH
50021: LD_INT 2
50023: PUSH
50024: LD_INT 30
50026: PUSH
50027: LD_INT 6
50029: PUSH
50030: EMPTY
50031: LIST
50032: LIST
50033: PUSH
50034: LD_INT 30
50036: PUSH
50037: LD_INT 7
50039: PUSH
50040: EMPTY
50041: LIST
50042: LIST
50043: PUSH
50044: LD_INT 30
50046: PUSH
50047: LD_INT 8
50049: PUSH
50050: EMPTY
50051: LIST
50052: LIST
50053: PUSH
50054: EMPTY
50055: LIST
50056: LIST
50057: LIST
50058: LIST
50059: PPUSH
50060: CALL_OW 72
50064: PPUSH
50065: CALL_OW 1
50069: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
50070: LD_ADDR_EXP 76
50074: PUSH
50075: LD_EXP 76
50079: PPUSH
50080: LD_VAR 0 2
50084: PPUSH
50085: EMPTY
50086: PPUSH
50087: CALL_OW 1
50091: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
50092: LD_ADDR_EXP 77
50096: PUSH
50097: LD_EXP 77
50101: PPUSH
50102: LD_VAR 0 2
50106: PPUSH
50107: EMPTY
50108: PPUSH
50109: CALL_OW 1
50113: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
50114: LD_ADDR_EXP 78
50118: PUSH
50119: LD_EXP 78
50123: PPUSH
50124: LD_VAR 0 2
50128: PPUSH
50129: EMPTY
50130: PPUSH
50131: CALL_OW 1
50135: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
50136: LD_ADDR_EXP 79
50140: PUSH
50141: LD_EXP 79
50145: PPUSH
50146: LD_VAR 0 2
50150: PPUSH
50151: EMPTY
50152: PPUSH
50153: CALL_OW 1
50157: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50158: LD_ADDR_EXP 80
50162: PUSH
50163: LD_EXP 80
50167: PPUSH
50168: LD_VAR 0 2
50172: PPUSH
50173: EMPTY
50174: PPUSH
50175: CALL_OW 1
50179: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
50180: LD_ADDR_EXP 81
50184: PUSH
50185: LD_EXP 81
50189: PPUSH
50190: LD_VAR 0 2
50194: PPUSH
50195: EMPTY
50196: PPUSH
50197: CALL_OW 1
50201: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
50202: LD_ADDR_EXP 82
50206: PUSH
50207: LD_EXP 82
50211: PPUSH
50212: LD_VAR 0 2
50216: PPUSH
50217: EMPTY
50218: PPUSH
50219: CALL_OW 1
50223: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
50224: LD_ADDR_EXP 83
50228: PUSH
50229: LD_EXP 83
50233: PPUSH
50234: LD_VAR 0 2
50238: PPUSH
50239: EMPTY
50240: PPUSH
50241: CALL_OW 1
50245: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
50246: LD_ADDR_EXP 84
50250: PUSH
50251: LD_EXP 84
50255: PPUSH
50256: LD_VAR 0 2
50260: PPUSH
50261: LD_INT 0
50263: PPUSH
50264: CALL_OW 1
50268: ST_TO_ADDR
// end ;
50269: GO 49193
50271: POP
50272: POP
// MC_InitSides ( ) ;
50273: CALL 50559 0 0
// MC_InitResearch ( ) ;
50277: CALL 50298 0 0
// CustomInitMacro ( ) ;
50281: CALL 101 0 0
// skirmish := true ;
50285: LD_ADDR_EXP 40
50289: PUSH
50290: LD_INT 1
50292: ST_TO_ADDR
// end ;
50293: LD_VAR 0 1
50297: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
50298: LD_INT 0
50300: PPUSH
50301: PPUSH
50302: PPUSH
50303: PPUSH
50304: PPUSH
50305: PPUSH
// if not mc_bases then
50306: LD_EXP 42
50310: NOT
50311: IFFALSE 50315
// exit ;
50313: GO 50554
// for i = 1 to 8 do
50315: LD_ADDR_VAR 0 2
50319: PUSH
50320: DOUBLE
50321: LD_INT 1
50323: DEC
50324: ST_TO_ADDR
50325: LD_INT 8
50327: PUSH
50328: FOR_TO
50329: IFFALSE 50355
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
50331: LD_ADDR_EXP 69
50335: PUSH
50336: LD_EXP 69
50340: PPUSH
50341: LD_VAR 0 2
50345: PPUSH
50346: EMPTY
50347: PPUSH
50348: CALL_OW 1
50352: ST_TO_ADDR
50353: GO 50328
50355: POP
50356: POP
// tmp := [ ] ;
50357: LD_ADDR_VAR 0 5
50361: PUSH
50362: EMPTY
50363: ST_TO_ADDR
// for i = 1 to mc_sides do
50364: LD_ADDR_VAR 0 2
50368: PUSH
50369: DOUBLE
50370: LD_INT 1
50372: DEC
50373: ST_TO_ADDR
50374: LD_EXP 68
50378: PUSH
50379: FOR_TO
50380: IFFALSE 50438
// if not mc_sides [ i ] in tmp then
50382: LD_EXP 68
50386: PUSH
50387: LD_VAR 0 2
50391: ARRAY
50392: PUSH
50393: LD_VAR 0 5
50397: IN
50398: NOT
50399: IFFALSE 50436
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
50401: LD_ADDR_VAR 0 5
50405: PUSH
50406: LD_VAR 0 5
50410: PPUSH
50411: LD_VAR 0 5
50415: PUSH
50416: LD_INT 1
50418: PLUS
50419: PPUSH
50420: LD_EXP 68
50424: PUSH
50425: LD_VAR 0 2
50429: ARRAY
50430: PPUSH
50431: CALL_OW 2
50435: ST_TO_ADDR
50436: GO 50379
50438: POP
50439: POP
// if not tmp then
50440: LD_VAR 0 5
50444: NOT
50445: IFFALSE 50449
// exit ;
50447: GO 50554
// for j in tmp do
50449: LD_ADDR_VAR 0 3
50453: PUSH
50454: LD_VAR 0 5
50458: PUSH
50459: FOR_IN
50460: IFFALSE 50552
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
50462: LD_ADDR_VAR 0 6
50466: PUSH
50467: LD_INT 22
50469: PUSH
50470: LD_VAR 0 3
50474: PUSH
50475: EMPTY
50476: LIST
50477: LIST
50478: PPUSH
50479: CALL_OW 69
50483: ST_TO_ADDR
// if not un then
50484: LD_VAR 0 6
50488: NOT
50489: IFFALSE 50493
// continue ;
50491: GO 50459
// nation := GetNation ( un [ 1 ] ) ;
50493: LD_ADDR_VAR 0 4
50497: PUSH
50498: LD_VAR 0 6
50502: PUSH
50503: LD_INT 1
50505: ARRAY
50506: PPUSH
50507: CALL_OW 248
50511: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
50512: LD_ADDR_EXP 69
50516: PUSH
50517: LD_EXP 69
50521: PPUSH
50522: LD_VAR 0 3
50526: PPUSH
50527: LD_VAR 0 3
50531: PPUSH
50532: LD_VAR 0 4
50536: PPUSH
50537: LD_INT 1
50539: PPUSH
50540: CALL 9921 0 3
50544: PPUSH
50545: CALL_OW 1
50549: ST_TO_ADDR
// end ;
50550: GO 50459
50552: POP
50553: POP
// end ;
50554: LD_VAR 0 1
50558: RET
// export function MC_InitSides ( ) ; var i ; begin
50559: LD_INT 0
50561: PPUSH
50562: PPUSH
// if not mc_bases then
50563: LD_EXP 42
50567: NOT
50568: IFFALSE 50572
// exit ;
50570: GO 50646
// for i = 1 to mc_bases do
50572: LD_ADDR_VAR 0 2
50576: PUSH
50577: DOUBLE
50578: LD_INT 1
50580: DEC
50581: ST_TO_ADDR
50582: LD_EXP 42
50586: PUSH
50587: FOR_TO
50588: IFFALSE 50644
// if mc_bases [ i ] then
50590: LD_EXP 42
50594: PUSH
50595: LD_VAR 0 2
50599: ARRAY
50600: IFFALSE 50642
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
50602: LD_ADDR_EXP 68
50606: PUSH
50607: LD_EXP 68
50611: PPUSH
50612: LD_VAR 0 2
50616: PPUSH
50617: LD_EXP 42
50621: PUSH
50622: LD_VAR 0 2
50626: ARRAY
50627: PUSH
50628: LD_INT 1
50630: ARRAY
50631: PPUSH
50632: CALL_OW 255
50636: PPUSH
50637: CALL_OW 1
50641: ST_TO_ADDR
50642: GO 50587
50644: POP
50645: POP
// end ;
50646: LD_VAR 0 1
50650: RET
// every 0 0$01 trigger skirmish do
50651: LD_EXP 40
50655: IFFALSE 50809
50657: GO 50659
50659: DISABLE
// begin enable ;
50660: ENABLE
// MC_CheckBuildings ( ) ;
50661: CALL 55307 0 0
// MC_CheckPeopleLife ( ) ;
50665: CALL 55432 0 0
// RaiseSailEvent ( 100 ) ;
50669: LD_INT 100
50671: PPUSH
50672: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
50676: LD_INT 103
50678: PPUSH
50679: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
50683: LD_INT 104
50685: PPUSH
50686: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
50690: LD_INT 105
50692: PPUSH
50693: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
50697: LD_INT 106
50699: PPUSH
50700: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
50704: LD_INT 107
50706: PPUSH
50707: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
50711: LD_INT 108
50713: PPUSH
50714: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
50718: LD_INT 109
50720: PPUSH
50721: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
50725: LD_INT 110
50727: PPUSH
50728: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
50732: LD_INT 111
50734: PPUSH
50735: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
50739: LD_INT 112
50741: PPUSH
50742: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
50746: LD_INT 113
50748: PPUSH
50749: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
50753: LD_INT 120
50755: PPUSH
50756: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
50760: LD_INT 121
50762: PPUSH
50763: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
50767: LD_INT 122
50769: PPUSH
50770: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
50774: LD_INT 123
50776: PPUSH
50777: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
50781: LD_INT 124
50783: PPUSH
50784: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
50788: LD_INT 125
50790: PPUSH
50791: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
50795: LD_INT 126
50797: PPUSH
50798: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
50802: LD_INT 200
50804: PPUSH
50805: CALL_OW 427
// end ;
50809: END
// on SailEvent ( event ) do begin if event < 100 then
50810: LD_VAR 0 1
50814: PUSH
50815: LD_INT 100
50817: LESS
50818: IFFALSE 50829
// CustomEvent ( event ) ;
50820: LD_VAR 0 1
50824: PPUSH
50825: CALL 571 0 1
// if event = 100 then
50829: LD_VAR 0 1
50833: PUSH
50834: LD_INT 100
50836: EQUAL
50837: IFFALSE 50843
// MC_ClassManager ( ) ;
50839: CALL 51235 0 0
// if event = 101 then
50843: LD_VAR 0 1
50847: PUSH
50848: LD_INT 101
50850: EQUAL
50851: IFFALSE 50857
// MC_RepairBuildings ( ) ;
50853: CALL 56017 0 0
// if event = 102 then
50857: LD_VAR 0 1
50861: PUSH
50862: LD_INT 102
50864: EQUAL
50865: IFFALSE 50871
// MC_Heal ( ) ;
50867: CALL 56902 0 0
// if event = 103 then
50871: LD_VAR 0 1
50875: PUSH
50876: LD_INT 103
50878: EQUAL
50879: IFFALSE 50885
// MC_Build ( ) ;
50881: CALL 57324 0 0
// if event = 104 then
50885: LD_VAR 0 1
50889: PUSH
50890: LD_INT 104
50892: EQUAL
50893: IFFALSE 50899
// MC_TurretWeapon ( ) ;
50895: CALL 58937 0 0
// if event = 105 then
50899: LD_VAR 0 1
50903: PUSH
50904: LD_INT 105
50906: EQUAL
50907: IFFALSE 50913
// MC_BuildUpgrade ( ) ;
50909: CALL 58488 0 0
// if event = 106 then
50913: LD_VAR 0 1
50917: PUSH
50918: LD_INT 106
50920: EQUAL
50921: IFFALSE 50927
// MC_PlantMines ( ) ;
50923: CALL 59367 0 0
// if event = 107 then
50927: LD_VAR 0 1
50931: PUSH
50932: LD_INT 107
50934: EQUAL
50935: IFFALSE 50941
// MC_CollectCrates ( ) ;
50937: CALL 60165 0 0
// if event = 108 then
50941: LD_VAR 0 1
50945: PUSH
50946: LD_INT 108
50948: EQUAL
50949: IFFALSE 50955
// MC_LinkRemoteControl ( ) ;
50951: CALL 61941 0 0
// if event = 109 then
50955: LD_VAR 0 1
50959: PUSH
50960: LD_INT 109
50962: EQUAL
50963: IFFALSE 50969
// MC_ProduceVehicle ( ) ;
50965: CALL 62122 0 0
// if event = 110 then
50969: LD_VAR 0 1
50973: PUSH
50974: LD_INT 110
50976: EQUAL
50977: IFFALSE 50983
// MC_SendAttack ( ) ;
50979: CALL 62588 0 0
// if event = 111 then
50983: LD_VAR 0 1
50987: PUSH
50988: LD_INT 111
50990: EQUAL
50991: IFFALSE 50997
// MC_Defend ( ) ;
50993: CALL 62696 0 0
// if event = 112 then
50997: LD_VAR 0 1
51001: PUSH
51002: LD_INT 112
51004: EQUAL
51005: IFFALSE 51011
// MC_Research ( ) ;
51007: CALL 63323 0 0
// if event = 113 then
51011: LD_VAR 0 1
51015: PUSH
51016: LD_INT 113
51018: EQUAL
51019: IFFALSE 51025
// MC_MinesTrigger ( ) ;
51021: CALL 64437 0 0
// if event = 120 then
51025: LD_VAR 0 1
51029: PUSH
51030: LD_INT 120
51032: EQUAL
51033: IFFALSE 51039
// MC_RepairVehicle ( ) ;
51035: CALL 64536 0 0
// if event = 121 then
51039: LD_VAR 0 1
51043: PUSH
51044: LD_INT 121
51046: EQUAL
51047: IFFALSE 51053
// MC_TameApe ( ) ;
51049: CALL 65266 0 0
// if event = 122 then
51053: LD_VAR 0 1
51057: PUSH
51058: LD_INT 122
51060: EQUAL
51061: IFFALSE 51067
// MC_ChangeApeClass ( ) ;
51063: CALL 66095 0 0
// if event = 123 then
51067: LD_VAR 0 1
51071: PUSH
51072: LD_INT 123
51074: EQUAL
51075: IFFALSE 51081
// MC_Bazooka ( ) ;
51077: CALL 66745 0 0
// if event = 124 then
51081: LD_VAR 0 1
51085: PUSH
51086: LD_INT 124
51088: EQUAL
51089: IFFALSE 51095
// MC_TeleportExit ( ) ;
51091: CALL 66943 0 0
// if event = 125 then
51095: LD_VAR 0 1
51099: PUSH
51100: LD_INT 125
51102: EQUAL
51103: IFFALSE 51109
// MC_Deposits ( ) ;
51105: CALL 67590 0 0
// if event = 126 then
51109: LD_VAR 0 1
51113: PUSH
51114: LD_INT 126
51116: EQUAL
51117: IFFALSE 51123
// MC_RemoteDriver ( ) ;
51119: CALL 68215 0 0
// if event = 200 then
51123: LD_VAR 0 1
51127: PUSH
51128: LD_INT 200
51130: EQUAL
51131: IFFALSE 51137
// MC_Idle ( ) ;
51133: CALL 70164 0 0
// end ;
51137: PPOPN 1
51139: END
// export function MC_Reset ( base , tag ) ; var i ; begin
51140: LD_INT 0
51142: PPUSH
51143: PPUSH
// if not mc_bases [ base ] or not tag then
51144: LD_EXP 42
51148: PUSH
51149: LD_VAR 0 1
51153: ARRAY
51154: NOT
51155: PUSH
51156: LD_VAR 0 2
51160: NOT
51161: OR
51162: IFFALSE 51166
// exit ;
51164: GO 51230
// for i in mc_bases [ base ] union mc_ape [ base ] do
51166: LD_ADDR_VAR 0 4
51170: PUSH
51171: LD_EXP 42
51175: PUSH
51176: LD_VAR 0 1
51180: ARRAY
51181: PUSH
51182: LD_EXP 71
51186: PUSH
51187: LD_VAR 0 1
51191: ARRAY
51192: UNION
51193: PUSH
51194: FOR_IN
51195: IFFALSE 51228
// if GetTag ( i ) = tag then
51197: LD_VAR 0 4
51201: PPUSH
51202: CALL_OW 110
51206: PUSH
51207: LD_VAR 0 2
51211: EQUAL
51212: IFFALSE 51226
// SetTag ( i , 0 ) ;
51214: LD_VAR 0 4
51218: PPUSH
51219: LD_INT 0
51221: PPUSH
51222: CALL_OW 109
51226: GO 51194
51228: POP
51229: POP
// end ;
51230: LD_VAR 0 3
51234: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
51235: LD_INT 0
51237: PPUSH
51238: PPUSH
51239: PPUSH
51240: PPUSH
51241: PPUSH
51242: PPUSH
51243: PPUSH
51244: PPUSH
// if not mc_bases then
51245: LD_EXP 42
51249: NOT
51250: IFFALSE 51254
// exit ;
51252: GO 51712
// for i = 1 to mc_bases do
51254: LD_ADDR_VAR 0 2
51258: PUSH
51259: DOUBLE
51260: LD_INT 1
51262: DEC
51263: ST_TO_ADDR
51264: LD_EXP 42
51268: PUSH
51269: FOR_TO
51270: IFFALSE 51710
// begin tmp := MC_ClassCheckReq ( i ) ;
51272: LD_ADDR_VAR 0 4
51276: PUSH
51277: LD_VAR 0 2
51281: PPUSH
51282: CALL 51717 0 1
51286: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
51287: LD_ADDR_EXP 83
51291: PUSH
51292: LD_EXP 83
51296: PPUSH
51297: LD_VAR 0 2
51301: PPUSH
51302: LD_VAR 0 4
51306: PPUSH
51307: CALL_OW 1
51311: ST_TO_ADDR
// if not tmp then
51312: LD_VAR 0 4
51316: NOT
51317: IFFALSE 51321
// continue ;
51319: GO 51269
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
51321: LD_ADDR_VAR 0 6
51325: PUSH
51326: LD_EXP 42
51330: PUSH
51331: LD_VAR 0 2
51335: ARRAY
51336: PPUSH
51337: LD_INT 2
51339: PUSH
51340: LD_INT 30
51342: PUSH
51343: LD_INT 4
51345: PUSH
51346: EMPTY
51347: LIST
51348: LIST
51349: PUSH
51350: LD_INT 30
51352: PUSH
51353: LD_INT 5
51355: PUSH
51356: EMPTY
51357: LIST
51358: LIST
51359: PUSH
51360: EMPTY
51361: LIST
51362: LIST
51363: LIST
51364: PPUSH
51365: CALL_OW 72
51369: PUSH
51370: LD_EXP 42
51374: PUSH
51375: LD_VAR 0 2
51379: ARRAY
51380: PPUSH
51381: LD_INT 2
51383: PUSH
51384: LD_INT 30
51386: PUSH
51387: LD_INT 0
51389: PUSH
51390: EMPTY
51391: LIST
51392: LIST
51393: PUSH
51394: LD_INT 30
51396: PUSH
51397: LD_INT 1
51399: PUSH
51400: EMPTY
51401: LIST
51402: LIST
51403: PUSH
51404: EMPTY
51405: LIST
51406: LIST
51407: LIST
51408: PPUSH
51409: CALL_OW 72
51413: PUSH
51414: LD_EXP 42
51418: PUSH
51419: LD_VAR 0 2
51423: ARRAY
51424: PPUSH
51425: LD_INT 30
51427: PUSH
51428: LD_INT 3
51430: PUSH
51431: EMPTY
51432: LIST
51433: LIST
51434: PPUSH
51435: CALL_OW 72
51439: PUSH
51440: LD_EXP 42
51444: PUSH
51445: LD_VAR 0 2
51449: ARRAY
51450: PPUSH
51451: LD_INT 2
51453: PUSH
51454: LD_INT 30
51456: PUSH
51457: LD_INT 6
51459: PUSH
51460: EMPTY
51461: LIST
51462: LIST
51463: PUSH
51464: LD_INT 30
51466: PUSH
51467: LD_INT 7
51469: PUSH
51470: EMPTY
51471: LIST
51472: LIST
51473: PUSH
51474: LD_INT 30
51476: PUSH
51477: LD_INT 8
51479: PUSH
51480: EMPTY
51481: LIST
51482: LIST
51483: PUSH
51484: EMPTY
51485: LIST
51486: LIST
51487: LIST
51488: LIST
51489: PPUSH
51490: CALL_OW 72
51494: PUSH
51495: EMPTY
51496: LIST
51497: LIST
51498: LIST
51499: LIST
51500: ST_TO_ADDR
// for j = 1 to 4 do
51501: LD_ADDR_VAR 0 3
51505: PUSH
51506: DOUBLE
51507: LD_INT 1
51509: DEC
51510: ST_TO_ADDR
51511: LD_INT 4
51513: PUSH
51514: FOR_TO
51515: IFFALSE 51706
// begin if not tmp [ j ] then
51517: LD_VAR 0 4
51521: PUSH
51522: LD_VAR 0 3
51526: ARRAY
51527: NOT
51528: IFFALSE 51532
// continue ;
51530: GO 51514
// for p in tmp [ j ] do
51532: LD_ADDR_VAR 0 5
51536: PUSH
51537: LD_VAR 0 4
51541: PUSH
51542: LD_VAR 0 3
51546: ARRAY
51547: PUSH
51548: FOR_IN
51549: IFFALSE 51702
// begin if not b [ j ] then
51551: LD_VAR 0 6
51555: PUSH
51556: LD_VAR 0 3
51560: ARRAY
51561: NOT
51562: IFFALSE 51566
// break ;
51564: GO 51702
// e := 0 ;
51566: LD_ADDR_VAR 0 7
51570: PUSH
51571: LD_INT 0
51573: ST_TO_ADDR
// for k in b [ j ] do
51574: LD_ADDR_VAR 0 8
51578: PUSH
51579: LD_VAR 0 6
51583: PUSH
51584: LD_VAR 0 3
51588: ARRAY
51589: PUSH
51590: FOR_IN
51591: IFFALSE 51618
// if IsNotFull ( k ) then
51593: LD_VAR 0 8
51597: PPUSH
51598: CALL 12070 0 1
51602: IFFALSE 51616
// begin e := k ;
51604: LD_ADDR_VAR 0 7
51608: PUSH
51609: LD_VAR 0 8
51613: ST_TO_ADDR
// break ;
51614: GO 51618
// end ;
51616: GO 51590
51618: POP
51619: POP
// if e and not UnitGoingToBuilding ( p , e ) then
51620: LD_VAR 0 7
51624: PUSH
51625: LD_VAR 0 5
51629: PPUSH
51630: LD_VAR 0 7
51634: PPUSH
51635: CALL 44490 0 2
51639: NOT
51640: AND
51641: IFFALSE 51700
// begin if IsInUnit ( p ) then
51643: LD_VAR 0 5
51647: PPUSH
51648: CALL_OW 310
51652: IFFALSE 51663
// ComExitBuilding ( p ) ;
51654: LD_VAR 0 5
51658: PPUSH
51659: CALL_OW 122
// ComEnterUnit ( p , e ) ;
51663: LD_VAR 0 5
51667: PPUSH
51668: LD_VAR 0 7
51672: PPUSH
51673: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
51677: LD_VAR 0 5
51681: PPUSH
51682: LD_VAR 0 3
51686: PPUSH
51687: CALL_OW 183
// AddComExitBuilding ( p ) ;
51691: LD_VAR 0 5
51695: PPUSH
51696: CALL_OW 182
// end ; end ;
51700: GO 51548
51702: POP
51703: POP
// end ;
51704: GO 51514
51706: POP
51707: POP
// end ;
51708: GO 51269
51710: POP
51711: POP
// end ;
51712: LD_VAR 0 1
51716: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
51717: LD_INT 0
51719: PPUSH
51720: PPUSH
51721: PPUSH
51722: PPUSH
51723: PPUSH
51724: PPUSH
51725: PPUSH
51726: PPUSH
51727: PPUSH
51728: PPUSH
51729: PPUSH
51730: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51731: LD_VAR 0 1
51735: NOT
51736: PUSH
51737: LD_EXP 42
51741: PUSH
51742: LD_VAR 0 1
51746: ARRAY
51747: NOT
51748: OR
51749: PUSH
51750: LD_EXP 42
51754: PUSH
51755: LD_VAR 0 1
51759: ARRAY
51760: PPUSH
51761: LD_INT 2
51763: PUSH
51764: LD_INT 30
51766: PUSH
51767: LD_INT 0
51769: PUSH
51770: EMPTY
51771: LIST
51772: LIST
51773: PUSH
51774: LD_INT 30
51776: PUSH
51777: LD_INT 1
51779: PUSH
51780: EMPTY
51781: LIST
51782: LIST
51783: PUSH
51784: EMPTY
51785: LIST
51786: LIST
51787: LIST
51788: PPUSH
51789: CALL_OW 72
51793: NOT
51794: OR
51795: IFFALSE 51799
// exit ;
51797: GO 55302
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51799: LD_ADDR_VAR 0 4
51803: PUSH
51804: LD_EXP 42
51808: PUSH
51809: LD_VAR 0 1
51813: ARRAY
51814: PPUSH
51815: LD_INT 2
51817: PUSH
51818: LD_INT 25
51820: PUSH
51821: LD_INT 1
51823: PUSH
51824: EMPTY
51825: LIST
51826: LIST
51827: PUSH
51828: LD_INT 25
51830: PUSH
51831: LD_INT 2
51833: PUSH
51834: EMPTY
51835: LIST
51836: LIST
51837: PUSH
51838: LD_INT 25
51840: PUSH
51841: LD_INT 3
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: PUSH
51848: LD_INT 25
51850: PUSH
51851: LD_INT 4
51853: PUSH
51854: EMPTY
51855: LIST
51856: LIST
51857: PUSH
51858: LD_INT 25
51860: PUSH
51861: LD_INT 5
51863: PUSH
51864: EMPTY
51865: LIST
51866: LIST
51867: PUSH
51868: LD_INT 25
51870: PUSH
51871: LD_INT 8
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: PUSH
51878: LD_INT 25
51880: PUSH
51881: LD_INT 9
51883: PUSH
51884: EMPTY
51885: LIST
51886: LIST
51887: PUSH
51888: EMPTY
51889: LIST
51890: LIST
51891: LIST
51892: LIST
51893: LIST
51894: LIST
51895: LIST
51896: LIST
51897: PPUSH
51898: CALL_OW 72
51902: ST_TO_ADDR
// if not tmp then
51903: LD_VAR 0 4
51907: NOT
51908: IFFALSE 51912
// exit ;
51910: GO 55302
// for i in tmp do
51912: LD_ADDR_VAR 0 3
51916: PUSH
51917: LD_VAR 0 4
51921: PUSH
51922: FOR_IN
51923: IFFALSE 51954
// if GetTag ( i ) then
51925: LD_VAR 0 3
51929: PPUSH
51930: CALL_OW 110
51934: IFFALSE 51952
// tmp := tmp diff i ;
51936: LD_ADDR_VAR 0 4
51940: PUSH
51941: LD_VAR 0 4
51945: PUSH
51946: LD_VAR 0 3
51950: DIFF
51951: ST_TO_ADDR
51952: GO 51922
51954: POP
51955: POP
// if not tmp then
51956: LD_VAR 0 4
51960: NOT
51961: IFFALSE 51965
// exit ;
51963: GO 55302
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51965: LD_ADDR_VAR 0 5
51969: PUSH
51970: LD_EXP 42
51974: PUSH
51975: LD_VAR 0 1
51979: ARRAY
51980: PPUSH
51981: LD_INT 2
51983: PUSH
51984: LD_INT 25
51986: PUSH
51987: LD_INT 1
51989: PUSH
51990: EMPTY
51991: LIST
51992: LIST
51993: PUSH
51994: LD_INT 25
51996: PUSH
51997: LD_INT 5
51999: PUSH
52000: EMPTY
52001: LIST
52002: LIST
52003: PUSH
52004: LD_INT 25
52006: PUSH
52007: LD_INT 8
52009: PUSH
52010: EMPTY
52011: LIST
52012: LIST
52013: PUSH
52014: LD_INT 25
52016: PUSH
52017: LD_INT 9
52019: PUSH
52020: EMPTY
52021: LIST
52022: LIST
52023: PUSH
52024: EMPTY
52025: LIST
52026: LIST
52027: LIST
52028: LIST
52029: LIST
52030: PPUSH
52031: CALL_OW 72
52035: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
52036: LD_ADDR_VAR 0 6
52040: PUSH
52041: LD_EXP 42
52045: PUSH
52046: LD_VAR 0 1
52050: ARRAY
52051: PPUSH
52052: LD_INT 25
52054: PUSH
52055: LD_INT 2
52057: PUSH
52058: EMPTY
52059: LIST
52060: LIST
52061: PPUSH
52062: CALL_OW 72
52066: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52067: LD_ADDR_VAR 0 7
52071: PUSH
52072: LD_EXP 42
52076: PUSH
52077: LD_VAR 0 1
52081: ARRAY
52082: PPUSH
52083: LD_INT 25
52085: PUSH
52086: LD_INT 3
52088: PUSH
52089: EMPTY
52090: LIST
52091: LIST
52092: PPUSH
52093: CALL_OW 72
52097: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
52098: LD_ADDR_VAR 0 8
52102: PUSH
52103: LD_EXP 42
52107: PUSH
52108: LD_VAR 0 1
52112: ARRAY
52113: PPUSH
52114: LD_INT 25
52116: PUSH
52117: LD_INT 4
52119: PUSH
52120: EMPTY
52121: LIST
52122: LIST
52123: PUSH
52124: LD_INT 24
52126: PUSH
52127: LD_INT 251
52129: PUSH
52130: EMPTY
52131: LIST
52132: LIST
52133: PUSH
52134: EMPTY
52135: LIST
52136: LIST
52137: PPUSH
52138: CALL_OW 72
52142: ST_TO_ADDR
// if mc_scan [ base ] then
52143: LD_EXP 65
52147: PUSH
52148: LD_VAR 0 1
52152: ARRAY
52153: IFFALSE 52614
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
52155: LD_ADDR_EXP 84
52159: PUSH
52160: LD_EXP 84
52164: PPUSH
52165: LD_VAR 0 1
52169: PPUSH
52170: LD_INT 4
52172: PPUSH
52173: CALL_OW 1
52177: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52178: LD_ADDR_VAR 0 12
52182: PUSH
52183: LD_EXP 42
52187: PUSH
52188: LD_VAR 0 1
52192: ARRAY
52193: PPUSH
52194: LD_INT 2
52196: PUSH
52197: LD_INT 30
52199: PUSH
52200: LD_INT 4
52202: PUSH
52203: EMPTY
52204: LIST
52205: LIST
52206: PUSH
52207: LD_INT 30
52209: PUSH
52210: LD_INT 5
52212: PUSH
52213: EMPTY
52214: LIST
52215: LIST
52216: PUSH
52217: EMPTY
52218: LIST
52219: LIST
52220: LIST
52221: PPUSH
52222: CALL_OW 72
52226: ST_TO_ADDR
// if not b then
52227: LD_VAR 0 12
52231: NOT
52232: IFFALSE 52236
// exit ;
52234: GO 55302
// p := [ ] ;
52236: LD_ADDR_VAR 0 11
52240: PUSH
52241: EMPTY
52242: ST_TO_ADDR
// if sci >= 2 then
52243: LD_VAR 0 8
52247: PUSH
52248: LD_INT 2
52250: GREATEREQUAL
52251: IFFALSE 52282
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
52253: LD_ADDR_VAR 0 8
52257: PUSH
52258: LD_VAR 0 8
52262: PUSH
52263: LD_INT 1
52265: ARRAY
52266: PUSH
52267: LD_VAR 0 8
52271: PUSH
52272: LD_INT 2
52274: ARRAY
52275: PUSH
52276: EMPTY
52277: LIST
52278: LIST
52279: ST_TO_ADDR
52280: GO 52343
// if sci = 1 then
52282: LD_VAR 0 8
52286: PUSH
52287: LD_INT 1
52289: EQUAL
52290: IFFALSE 52311
// sci := [ sci [ 1 ] ] else
52292: LD_ADDR_VAR 0 8
52296: PUSH
52297: LD_VAR 0 8
52301: PUSH
52302: LD_INT 1
52304: ARRAY
52305: PUSH
52306: EMPTY
52307: LIST
52308: ST_TO_ADDR
52309: GO 52343
// if sci = 0 then
52311: LD_VAR 0 8
52315: PUSH
52316: LD_INT 0
52318: EQUAL
52319: IFFALSE 52343
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
52321: LD_ADDR_VAR 0 11
52325: PUSH
52326: LD_VAR 0 4
52330: PPUSH
52331: LD_INT 4
52333: PPUSH
52334: CALL 44353 0 2
52338: PUSH
52339: LD_INT 1
52341: ARRAY
52342: ST_TO_ADDR
// if eng > 4 then
52343: LD_VAR 0 6
52347: PUSH
52348: LD_INT 4
52350: GREATER
52351: IFFALSE 52397
// for i = eng downto 4 do
52353: LD_ADDR_VAR 0 3
52357: PUSH
52358: DOUBLE
52359: LD_VAR 0 6
52363: INC
52364: ST_TO_ADDR
52365: LD_INT 4
52367: PUSH
52368: FOR_DOWNTO
52369: IFFALSE 52395
// eng := eng diff eng [ i ] ;
52371: LD_ADDR_VAR 0 6
52375: PUSH
52376: LD_VAR 0 6
52380: PUSH
52381: LD_VAR 0 6
52385: PUSH
52386: LD_VAR 0 3
52390: ARRAY
52391: DIFF
52392: ST_TO_ADDR
52393: GO 52368
52395: POP
52396: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
52397: LD_ADDR_VAR 0 4
52401: PUSH
52402: LD_VAR 0 4
52406: PUSH
52407: LD_VAR 0 5
52411: PUSH
52412: LD_VAR 0 6
52416: UNION
52417: PUSH
52418: LD_VAR 0 7
52422: UNION
52423: PUSH
52424: LD_VAR 0 8
52428: UNION
52429: DIFF
52430: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
52431: LD_ADDR_VAR 0 13
52435: PUSH
52436: LD_EXP 42
52440: PUSH
52441: LD_VAR 0 1
52445: ARRAY
52446: PPUSH
52447: LD_INT 2
52449: PUSH
52450: LD_INT 30
52452: PUSH
52453: LD_INT 32
52455: PUSH
52456: EMPTY
52457: LIST
52458: LIST
52459: PUSH
52460: LD_INT 30
52462: PUSH
52463: LD_INT 31
52465: PUSH
52466: EMPTY
52467: LIST
52468: LIST
52469: PUSH
52470: EMPTY
52471: LIST
52472: LIST
52473: LIST
52474: PPUSH
52475: CALL_OW 72
52479: PUSH
52480: LD_EXP 42
52484: PUSH
52485: LD_VAR 0 1
52489: ARRAY
52490: PPUSH
52491: LD_INT 2
52493: PUSH
52494: LD_INT 30
52496: PUSH
52497: LD_INT 4
52499: PUSH
52500: EMPTY
52501: LIST
52502: LIST
52503: PUSH
52504: LD_INT 30
52506: PUSH
52507: LD_INT 5
52509: PUSH
52510: EMPTY
52511: LIST
52512: LIST
52513: PUSH
52514: EMPTY
52515: LIST
52516: LIST
52517: LIST
52518: PPUSH
52519: CALL_OW 72
52523: PUSH
52524: LD_INT 6
52526: MUL
52527: PLUS
52528: ST_TO_ADDR
// if bcount < tmp then
52529: LD_VAR 0 13
52533: PUSH
52534: LD_VAR 0 4
52538: LESS
52539: IFFALSE 52585
// for i = tmp downto bcount do
52541: LD_ADDR_VAR 0 3
52545: PUSH
52546: DOUBLE
52547: LD_VAR 0 4
52551: INC
52552: ST_TO_ADDR
52553: LD_VAR 0 13
52557: PUSH
52558: FOR_DOWNTO
52559: IFFALSE 52583
// tmp := Delete ( tmp , tmp ) ;
52561: LD_ADDR_VAR 0 4
52565: PUSH
52566: LD_VAR 0 4
52570: PPUSH
52571: LD_VAR 0 4
52575: PPUSH
52576: CALL_OW 3
52580: ST_TO_ADDR
52581: GO 52558
52583: POP
52584: POP
// result := [ tmp , 0 , 0 , p ] ;
52585: LD_ADDR_VAR 0 2
52589: PUSH
52590: LD_VAR 0 4
52594: PUSH
52595: LD_INT 0
52597: PUSH
52598: LD_INT 0
52600: PUSH
52601: LD_VAR 0 11
52605: PUSH
52606: EMPTY
52607: LIST
52608: LIST
52609: LIST
52610: LIST
52611: ST_TO_ADDR
// exit ;
52612: GO 55302
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52614: LD_EXP 42
52618: PUSH
52619: LD_VAR 0 1
52623: ARRAY
52624: PPUSH
52625: LD_INT 2
52627: PUSH
52628: LD_INT 30
52630: PUSH
52631: LD_INT 6
52633: PUSH
52634: EMPTY
52635: LIST
52636: LIST
52637: PUSH
52638: LD_INT 30
52640: PUSH
52641: LD_INT 7
52643: PUSH
52644: EMPTY
52645: LIST
52646: LIST
52647: PUSH
52648: LD_INT 30
52650: PUSH
52651: LD_INT 8
52653: PUSH
52654: EMPTY
52655: LIST
52656: LIST
52657: PUSH
52658: EMPTY
52659: LIST
52660: LIST
52661: LIST
52662: LIST
52663: PPUSH
52664: CALL_OW 72
52668: NOT
52669: PUSH
52670: LD_EXP 42
52674: PUSH
52675: LD_VAR 0 1
52679: ARRAY
52680: PPUSH
52681: LD_INT 30
52683: PUSH
52684: LD_INT 3
52686: PUSH
52687: EMPTY
52688: LIST
52689: LIST
52690: PPUSH
52691: CALL_OW 72
52695: NOT
52696: AND
52697: IFFALSE 52769
// begin if eng = tmp then
52699: LD_VAR 0 6
52703: PUSH
52704: LD_VAR 0 4
52708: EQUAL
52709: IFFALSE 52713
// exit ;
52711: GO 55302
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
52713: LD_ADDR_EXP 84
52717: PUSH
52718: LD_EXP 84
52722: PPUSH
52723: LD_VAR 0 1
52727: PPUSH
52728: LD_INT 1
52730: PPUSH
52731: CALL_OW 1
52735: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
52736: LD_ADDR_VAR 0 2
52740: PUSH
52741: LD_INT 0
52743: PUSH
52744: LD_VAR 0 4
52748: PUSH
52749: LD_VAR 0 6
52753: DIFF
52754: PUSH
52755: LD_INT 0
52757: PUSH
52758: LD_INT 0
52760: PUSH
52761: EMPTY
52762: LIST
52763: LIST
52764: LIST
52765: LIST
52766: ST_TO_ADDR
// exit ;
52767: GO 55302
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52769: LD_EXP 69
52773: PUSH
52774: LD_EXP 68
52778: PUSH
52779: LD_VAR 0 1
52783: ARRAY
52784: ARRAY
52785: PUSH
52786: LD_EXP 42
52790: PUSH
52791: LD_VAR 0 1
52795: ARRAY
52796: PPUSH
52797: LD_INT 2
52799: PUSH
52800: LD_INT 30
52802: PUSH
52803: LD_INT 6
52805: PUSH
52806: EMPTY
52807: LIST
52808: LIST
52809: PUSH
52810: LD_INT 30
52812: PUSH
52813: LD_INT 7
52815: PUSH
52816: EMPTY
52817: LIST
52818: LIST
52819: PUSH
52820: LD_INT 30
52822: PUSH
52823: LD_INT 8
52825: PUSH
52826: EMPTY
52827: LIST
52828: LIST
52829: PUSH
52830: EMPTY
52831: LIST
52832: LIST
52833: LIST
52834: LIST
52835: PPUSH
52836: CALL_OW 72
52840: AND
52841: PUSH
52842: LD_EXP 42
52846: PUSH
52847: LD_VAR 0 1
52851: ARRAY
52852: PPUSH
52853: LD_INT 30
52855: PUSH
52856: LD_INT 3
52858: PUSH
52859: EMPTY
52860: LIST
52861: LIST
52862: PPUSH
52863: CALL_OW 72
52867: NOT
52868: AND
52869: IFFALSE 53083
// begin if sci >= 6 then
52871: LD_VAR 0 8
52875: PUSH
52876: LD_INT 6
52878: GREATEREQUAL
52879: IFFALSE 52883
// exit ;
52881: GO 55302
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
52883: LD_ADDR_EXP 84
52887: PUSH
52888: LD_EXP 84
52892: PPUSH
52893: LD_VAR 0 1
52897: PPUSH
52898: LD_INT 2
52900: PPUSH
52901: CALL_OW 1
52905: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
52906: LD_ADDR_VAR 0 9
52910: PUSH
52911: LD_VAR 0 4
52915: PUSH
52916: LD_VAR 0 8
52920: DIFF
52921: PPUSH
52922: LD_INT 4
52924: PPUSH
52925: CALL 44353 0 2
52929: ST_TO_ADDR
// p := [ ] ;
52930: LD_ADDR_VAR 0 11
52934: PUSH
52935: EMPTY
52936: ST_TO_ADDR
// if sci < 6 and sort > 6 then
52937: LD_VAR 0 8
52941: PUSH
52942: LD_INT 6
52944: LESS
52945: PUSH
52946: LD_VAR 0 9
52950: PUSH
52951: LD_INT 6
52953: GREATER
52954: AND
52955: IFFALSE 53036
// begin for i = 1 to 6 - sci do
52957: LD_ADDR_VAR 0 3
52961: PUSH
52962: DOUBLE
52963: LD_INT 1
52965: DEC
52966: ST_TO_ADDR
52967: LD_INT 6
52969: PUSH
52970: LD_VAR 0 8
52974: MINUS
52975: PUSH
52976: FOR_TO
52977: IFFALSE 53032
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
52979: LD_ADDR_VAR 0 11
52983: PUSH
52984: LD_VAR 0 11
52988: PPUSH
52989: LD_VAR 0 11
52993: PUSH
52994: LD_INT 1
52996: PLUS
52997: PPUSH
52998: LD_VAR 0 9
53002: PUSH
53003: LD_INT 1
53005: ARRAY
53006: PPUSH
53007: CALL_OW 2
53011: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
53012: LD_ADDR_VAR 0 9
53016: PUSH
53017: LD_VAR 0 9
53021: PPUSH
53022: LD_INT 1
53024: PPUSH
53025: CALL_OW 3
53029: ST_TO_ADDR
// end ;
53030: GO 52976
53032: POP
53033: POP
// end else
53034: GO 53056
// if sort then
53036: LD_VAR 0 9
53040: IFFALSE 53056
// p := sort [ 1 ] ;
53042: LD_ADDR_VAR 0 11
53046: PUSH
53047: LD_VAR 0 9
53051: PUSH
53052: LD_INT 1
53054: ARRAY
53055: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
53056: LD_ADDR_VAR 0 2
53060: PUSH
53061: LD_INT 0
53063: PUSH
53064: LD_INT 0
53066: PUSH
53067: LD_INT 0
53069: PUSH
53070: LD_VAR 0 11
53074: PUSH
53075: EMPTY
53076: LIST
53077: LIST
53078: LIST
53079: LIST
53080: ST_TO_ADDR
// exit ;
53081: GO 55302
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53083: LD_EXP 69
53087: PUSH
53088: LD_EXP 68
53092: PUSH
53093: LD_VAR 0 1
53097: ARRAY
53098: ARRAY
53099: PUSH
53100: LD_EXP 42
53104: PUSH
53105: LD_VAR 0 1
53109: ARRAY
53110: PPUSH
53111: LD_INT 2
53113: PUSH
53114: LD_INT 30
53116: PUSH
53117: LD_INT 6
53119: PUSH
53120: EMPTY
53121: LIST
53122: LIST
53123: PUSH
53124: LD_INT 30
53126: PUSH
53127: LD_INT 7
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: PUSH
53134: LD_INT 30
53136: PUSH
53137: LD_INT 8
53139: PUSH
53140: EMPTY
53141: LIST
53142: LIST
53143: PUSH
53144: EMPTY
53145: LIST
53146: LIST
53147: LIST
53148: LIST
53149: PPUSH
53150: CALL_OW 72
53154: AND
53155: PUSH
53156: LD_EXP 42
53160: PUSH
53161: LD_VAR 0 1
53165: ARRAY
53166: PPUSH
53167: LD_INT 30
53169: PUSH
53170: LD_INT 3
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: PPUSH
53177: CALL_OW 72
53181: AND
53182: IFFALSE 53916
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
53184: LD_ADDR_EXP 84
53188: PUSH
53189: LD_EXP 84
53193: PPUSH
53194: LD_VAR 0 1
53198: PPUSH
53199: LD_INT 3
53201: PPUSH
53202: CALL_OW 1
53206: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53207: LD_ADDR_VAR 0 2
53211: PUSH
53212: LD_INT 0
53214: PUSH
53215: LD_INT 0
53217: PUSH
53218: LD_INT 0
53220: PUSH
53221: LD_INT 0
53223: PUSH
53224: EMPTY
53225: LIST
53226: LIST
53227: LIST
53228: LIST
53229: ST_TO_ADDR
// if not eng then
53230: LD_VAR 0 6
53234: NOT
53235: IFFALSE 53298
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
53237: LD_ADDR_VAR 0 11
53241: PUSH
53242: LD_VAR 0 4
53246: PPUSH
53247: LD_INT 2
53249: PPUSH
53250: CALL 44353 0 2
53254: PUSH
53255: LD_INT 1
53257: ARRAY
53258: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
53259: LD_ADDR_VAR 0 2
53263: PUSH
53264: LD_VAR 0 2
53268: PPUSH
53269: LD_INT 2
53271: PPUSH
53272: LD_VAR 0 11
53276: PPUSH
53277: CALL_OW 1
53281: ST_TO_ADDR
// tmp := tmp diff p ;
53282: LD_ADDR_VAR 0 4
53286: PUSH
53287: LD_VAR 0 4
53291: PUSH
53292: LD_VAR 0 11
53296: DIFF
53297: ST_TO_ADDR
// end ; if tmp and sci < 6 then
53298: LD_VAR 0 4
53302: PUSH
53303: LD_VAR 0 8
53307: PUSH
53308: LD_INT 6
53310: LESS
53311: AND
53312: IFFALSE 53500
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
53314: LD_ADDR_VAR 0 9
53318: PUSH
53319: LD_VAR 0 4
53323: PUSH
53324: LD_VAR 0 8
53328: PUSH
53329: LD_VAR 0 7
53333: UNION
53334: DIFF
53335: PPUSH
53336: LD_INT 4
53338: PPUSH
53339: CALL 44353 0 2
53343: ST_TO_ADDR
// p := [ ] ;
53344: LD_ADDR_VAR 0 11
53348: PUSH
53349: EMPTY
53350: ST_TO_ADDR
// if sort then
53351: LD_VAR 0 9
53355: IFFALSE 53471
// for i = 1 to 6 - sci do
53357: LD_ADDR_VAR 0 3
53361: PUSH
53362: DOUBLE
53363: LD_INT 1
53365: DEC
53366: ST_TO_ADDR
53367: LD_INT 6
53369: PUSH
53370: LD_VAR 0 8
53374: MINUS
53375: PUSH
53376: FOR_TO
53377: IFFALSE 53469
// begin if i = sort then
53379: LD_VAR 0 3
53383: PUSH
53384: LD_VAR 0 9
53388: EQUAL
53389: IFFALSE 53393
// break ;
53391: GO 53469
// if GetClass ( i ) = 4 then
53393: LD_VAR 0 3
53397: PPUSH
53398: CALL_OW 257
53402: PUSH
53403: LD_INT 4
53405: EQUAL
53406: IFFALSE 53410
// continue ;
53408: GO 53376
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53410: LD_ADDR_VAR 0 11
53414: PUSH
53415: LD_VAR 0 11
53419: PPUSH
53420: LD_VAR 0 11
53424: PUSH
53425: LD_INT 1
53427: PLUS
53428: PPUSH
53429: LD_VAR 0 9
53433: PUSH
53434: LD_VAR 0 3
53438: ARRAY
53439: PPUSH
53440: CALL_OW 2
53444: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53445: LD_ADDR_VAR 0 4
53449: PUSH
53450: LD_VAR 0 4
53454: PUSH
53455: LD_VAR 0 9
53459: PUSH
53460: LD_VAR 0 3
53464: ARRAY
53465: DIFF
53466: ST_TO_ADDR
// end ;
53467: GO 53376
53469: POP
53470: POP
// if p then
53471: LD_VAR 0 11
53475: IFFALSE 53500
// result := Replace ( result , 4 , p ) ;
53477: LD_ADDR_VAR 0 2
53481: PUSH
53482: LD_VAR 0 2
53486: PPUSH
53487: LD_INT 4
53489: PPUSH
53490: LD_VAR 0 11
53494: PPUSH
53495: CALL_OW 1
53499: ST_TO_ADDR
// end ; if tmp and mech < 6 then
53500: LD_VAR 0 4
53504: PUSH
53505: LD_VAR 0 7
53509: PUSH
53510: LD_INT 6
53512: LESS
53513: AND
53514: IFFALSE 53702
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
53516: LD_ADDR_VAR 0 9
53520: PUSH
53521: LD_VAR 0 4
53525: PUSH
53526: LD_VAR 0 8
53530: PUSH
53531: LD_VAR 0 7
53535: UNION
53536: DIFF
53537: PPUSH
53538: LD_INT 3
53540: PPUSH
53541: CALL 44353 0 2
53545: ST_TO_ADDR
// p := [ ] ;
53546: LD_ADDR_VAR 0 11
53550: PUSH
53551: EMPTY
53552: ST_TO_ADDR
// if sort then
53553: LD_VAR 0 9
53557: IFFALSE 53673
// for i = 1 to 6 - mech do
53559: LD_ADDR_VAR 0 3
53563: PUSH
53564: DOUBLE
53565: LD_INT 1
53567: DEC
53568: ST_TO_ADDR
53569: LD_INT 6
53571: PUSH
53572: LD_VAR 0 7
53576: MINUS
53577: PUSH
53578: FOR_TO
53579: IFFALSE 53671
// begin if i = sort then
53581: LD_VAR 0 3
53585: PUSH
53586: LD_VAR 0 9
53590: EQUAL
53591: IFFALSE 53595
// break ;
53593: GO 53671
// if GetClass ( i ) = 3 then
53595: LD_VAR 0 3
53599: PPUSH
53600: CALL_OW 257
53604: PUSH
53605: LD_INT 3
53607: EQUAL
53608: IFFALSE 53612
// continue ;
53610: GO 53578
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53612: LD_ADDR_VAR 0 11
53616: PUSH
53617: LD_VAR 0 11
53621: PPUSH
53622: LD_VAR 0 11
53626: PUSH
53627: LD_INT 1
53629: PLUS
53630: PPUSH
53631: LD_VAR 0 9
53635: PUSH
53636: LD_VAR 0 3
53640: ARRAY
53641: PPUSH
53642: CALL_OW 2
53646: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53647: LD_ADDR_VAR 0 4
53651: PUSH
53652: LD_VAR 0 4
53656: PUSH
53657: LD_VAR 0 9
53661: PUSH
53662: LD_VAR 0 3
53666: ARRAY
53667: DIFF
53668: ST_TO_ADDR
// end ;
53669: GO 53578
53671: POP
53672: POP
// if p then
53673: LD_VAR 0 11
53677: IFFALSE 53702
// result := Replace ( result , 3 , p ) ;
53679: LD_ADDR_VAR 0 2
53683: PUSH
53684: LD_VAR 0 2
53688: PPUSH
53689: LD_INT 3
53691: PPUSH
53692: LD_VAR 0 11
53696: PPUSH
53697: CALL_OW 1
53701: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
53702: LD_VAR 0 4
53706: PUSH
53707: LD_INT 6
53709: GREATER
53710: PUSH
53711: LD_VAR 0 6
53715: PUSH
53716: LD_INT 6
53718: LESS
53719: AND
53720: IFFALSE 53914
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
53722: LD_ADDR_VAR 0 9
53726: PUSH
53727: LD_VAR 0 4
53731: PUSH
53732: LD_VAR 0 8
53736: PUSH
53737: LD_VAR 0 7
53741: UNION
53742: PUSH
53743: LD_VAR 0 6
53747: UNION
53748: DIFF
53749: PPUSH
53750: LD_INT 2
53752: PPUSH
53753: CALL 44353 0 2
53757: ST_TO_ADDR
// p := [ ] ;
53758: LD_ADDR_VAR 0 11
53762: PUSH
53763: EMPTY
53764: ST_TO_ADDR
// if sort then
53765: LD_VAR 0 9
53769: IFFALSE 53885
// for i = 1 to 6 - eng do
53771: LD_ADDR_VAR 0 3
53775: PUSH
53776: DOUBLE
53777: LD_INT 1
53779: DEC
53780: ST_TO_ADDR
53781: LD_INT 6
53783: PUSH
53784: LD_VAR 0 6
53788: MINUS
53789: PUSH
53790: FOR_TO
53791: IFFALSE 53883
// begin if i = sort then
53793: LD_VAR 0 3
53797: PUSH
53798: LD_VAR 0 9
53802: EQUAL
53803: IFFALSE 53807
// break ;
53805: GO 53883
// if GetClass ( i ) = 2 then
53807: LD_VAR 0 3
53811: PPUSH
53812: CALL_OW 257
53816: PUSH
53817: LD_INT 2
53819: EQUAL
53820: IFFALSE 53824
// continue ;
53822: GO 53790
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53824: LD_ADDR_VAR 0 11
53828: PUSH
53829: LD_VAR 0 11
53833: PPUSH
53834: LD_VAR 0 11
53838: PUSH
53839: LD_INT 1
53841: PLUS
53842: PPUSH
53843: LD_VAR 0 9
53847: PUSH
53848: LD_VAR 0 3
53852: ARRAY
53853: PPUSH
53854: CALL_OW 2
53858: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53859: LD_ADDR_VAR 0 4
53863: PUSH
53864: LD_VAR 0 4
53868: PUSH
53869: LD_VAR 0 9
53873: PUSH
53874: LD_VAR 0 3
53878: ARRAY
53879: DIFF
53880: ST_TO_ADDR
// end ;
53881: GO 53790
53883: POP
53884: POP
// if p then
53885: LD_VAR 0 11
53889: IFFALSE 53914
// result := Replace ( result , 2 , p ) ;
53891: LD_ADDR_VAR 0 2
53895: PUSH
53896: LD_VAR 0 2
53900: PPUSH
53901: LD_INT 2
53903: PPUSH
53904: LD_VAR 0 11
53908: PPUSH
53909: CALL_OW 1
53913: ST_TO_ADDR
// end ; exit ;
53914: GO 55302
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
53916: LD_EXP 69
53920: PUSH
53921: LD_EXP 68
53925: PUSH
53926: LD_VAR 0 1
53930: ARRAY
53931: ARRAY
53932: NOT
53933: PUSH
53934: LD_EXP 42
53938: PUSH
53939: LD_VAR 0 1
53943: ARRAY
53944: PPUSH
53945: LD_INT 30
53947: PUSH
53948: LD_INT 3
53950: PUSH
53951: EMPTY
53952: LIST
53953: LIST
53954: PPUSH
53955: CALL_OW 72
53959: AND
53960: PUSH
53961: LD_EXP 47
53965: PUSH
53966: LD_VAR 0 1
53970: ARRAY
53971: AND
53972: IFFALSE 54580
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
53974: LD_ADDR_EXP 84
53978: PUSH
53979: LD_EXP 84
53983: PPUSH
53984: LD_VAR 0 1
53988: PPUSH
53989: LD_INT 5
53991: PPUSH
53992: CALL_OW 1
53996: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53997: LD_ADDR_VAR 0 2
54001: PUSH
54002: LD_INT 0
54004: PUSH
54005: LD_INT 0
54007: PUSH
54008: LD_INT 0
54010: PUSH
54011: LD_INT 0
54013: PUSH
54014: EMPTY
54015: LIST
54016: LIST
54017: LIST
54018: LIST
54019: ST_TO_ADDR
// if sci > 1 then
54020: LD_VAR 0 8
54024: PUSH
54025: LD_INT 1
54027: GREATER
54028: IFFALSE 54056
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
54030: LD_ADDR_VAR 0 4
54034: PUSH
54035: LD_VAR 0 4
54039: PUSH
54040: LD_VAR 0 8
54044: PUSH
54045: LD_VAR 0 8
54049: PUSH
54050: LD_INT 1
54052: ARRAY
54053: DIFF
54054: DIFF
54055: ST_TO_ADDR
// if tmp and not sci then
54056: LD_VAR 0 4
54060: PUSH
54061: LD_VAR 0 8
54065: NOT
54066: AND
54067: IFFALSE 54136
// begin sort := SortBySkill ( tmp , 4 ) ;
54069: LD_ADDR_VAR 0 9
54073: PUSH
54074: LD_VAR 0 4
54078: PPUSH
54079: LD_INT 4
54081: PPUSH
54082: CALL 44353 0 2
54086: ST_TO_ADDR
// if sort then
54087: LD_VAR 0 9
54091: IFFALSE 54107
// p := sort [ 1 ] ;
54093: LD_ADDR_VAR 0 11
54097: PUSH
54098: LD_VAR 0 9
54102: PUSH
54103: LD_INT 1
54105: ARRAY
54106: ST_TO_ADDR
// if p then
54107: LD_VAR 0 11
54111: IFFALSE 54136
// result := Replace ( result , 4 , p ) ;
54113: LD_ADDR_VAR 0 2
54117: PUSH
54118: LD_VAR 0 2
54122: PPUSH
54123: LD_INT 4
54125: PPUSH
54126: LD_VAR 0 11
54130: PPUSH
54131: CALL_OW 1
54135: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54136: LD_ADDR_VAR 0 4
54140: PUSH
54141: LD_VAR 0 4
54145: PUSH
54146: LD_VAR 0 7
54150: DIFF
54151: ST_TO_ADDR
// if tmp and mech < 6 then
54152: LD_VAR 0 4
54156: PUSH
54157: LD_VAR 0 7
54161: PUSH
54162: LD_INT 6
54164: LESS
54165: AND
54166: IFFALSE 54354
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54168: LD_ADDR_VAR 0 9
54172: PUSH
54173: LD_VAR 0 4
54177: PUSH
54178: LD_VAR 0 8
54182: PUSH
54183: LD_VAR 0 7
54187: UNION
54188: DIFF
54189: PPUSH
54190: LD_INT 3
54192: PPUSH
54193: CALL 44353 0 2
54197: ST_TO_ADDR
// p := [ ] ;
54198: LD_ADDR_VAR 0 11
54202: PUSH
54203: EMPTY
54204: ST_TO_ADDR
// if sort then
54205: LD_VAR 0 9
54209: IFFALSE 54325
// for i = 1 to 6 - mech do
54211: LD_ADDR_VAR 0 3
54215: PUSH
54216: DOUBLE
54217: LD_INT 1
54219: DEC
54220: ST_TO_ADDR
54221: LD_INT 6
54223: PUSH
54224: LD_VAR 0 7
54228: MINUS
54229: PUSH
54230: FOR_TO
54231: IFFALSE 54323
// begin if i = sort then
54233: LD_VAR 0 3
54237: PUSH
54238: LD_VAR 0 9
54242: EQUAL
54243: IFFALSE 54247
// break ;
54245: GO 54323
// if GetClass ( i ) = 3 then
54247: LD_VAR 0 3
54251: PPUSH
54252: CALL_OW 257
54256: PUSH
54257: LD_INT 3
54259: EQUAL
54260: IFFALSE 54264
// continue ;
54262: GO 54230
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54264: LD_ADDR_VAR 0 11
54268: PUSH
54269: LD_VAR 0 11
54273: PPUSH
54274: LD_VAR 0 11
54278: PUSH
54279: LD_INT 1
54281: PLUS
54282: PPUSH
54283: LD_VAR 0 9
54287: PUSH
54288: LD_VAR 0 3
54292: ARRAY
54293: PPUSH
54294: CALL_OW 2
54298: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54299: LD_ADDR_VAR 0 4
54303: PUSH
54304: LD_VAR 0 4
54308: PUSH
54309: LD_VAR 0 9
54313: PUSH
54314: LD_VAR 0 3
54318: ARRAY
54319: DIFF
54320: ST_TO_ADDR
// end ;
54321: GO 54230
54323: POP
54324: POP
// if p then
54325: LD_VAR 0 11
54329: IFFALSE 54354
// result := Replace ( result , 3 , p ) ;
54331: LD_ADDR_VAR 0 2
54335: PUSH
54336: LD_VAR 0 2
54340: PPUSH
54341: LD_INT 3
54343: PPUSH
54344: LD_VAR 0 11
54348: PPUSH
54349: CALL_OW 1
54353: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54354: LD_ADDR_VAR 0 4
54358: PUSH
54359: LD_VAR 0 4
54363: PUSH
54364: LD_VAR 0 6
54368: DIFF
54369: ST_TO_ADDR
// if tmp and eng < 6 then
54370: LD_VAR 0 4
54374: PUSH
54375: LD_VAR 0 6
54379: PUSH
54380: LD_INT 6
54382: LESS
54383: AND
54384: IFFALSE 54578
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54386: LD_ADDR_VAR 0 9
54390: PUSH
54391: LD_VAR 0 4
54395: PUSH
54396: LD_VAR 0 8
54400: PUSH
54401: LD_VAR 0 7
54405: UNION
54406: PUSH
54407: LD_VAR 0 6
54411: UNION
54412: DIFF
54413: PPUSH
54414: LD_INT 2
54416: PPUSH
54417: CALL 44353 0 2
54421: ST_TO_ADDR
// p := [ ] ;
54422: LD_ADDR_VAR 0 11
54426: PUSH
54427: EMPTY
54428: ST_TO_ADDR
// if sort then
54429: LD_VAR 0 9
54433: IFFALSE 54549
// for i = 1 to 6 - eng do
54435: LD_ADDR_VAR 0 3
54439: PUSH
54440: DOUBLE
54441: LD_INT 1
54443: DEC
54444: ST_TO_ADDR
54445: LD_INT 6
54447: PUSH
54448: LD_VAR 0 6
54452: MINUS
54453: PUSH
54454: FOR_TO
54455: IFFALSE 54547
// begin if i = sort then
54457: LD_VAR 0 3
54461: PUSH
54462: LD_VAR 0 9
54466: EQUAL
54467: IFFALSE 54471
// break ;
54469: GO 54547
// if GetClass ( i ) = 2 then
54471: LD_VAR 0 3
54475: PPUSH
54476: CALL_OW 257
54480: PUSH
54481: LD_INT 2
54483: EQUAL
54484: IFFALSE 54488
// continue ;
54486: GO 54454
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54488: LD_ADDR_VAR 0 11
54492: PUSH
54493: LD_VAR 0 11
54497: PPUSH
54498: LD_VAR 0 11
54502: PUSH
54503: LD_INT 1
54505: PLUS
54506: PPUSH
54507: LD_VAR 0 9
54511: PUSH
54512: LD_VAR 0 3
54516: ARRAY
54517: PPUSH
54518: CALL_OW 2
54522: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54523: LD_ADDR_VAR 0 4
54527: PUSH
54528: LD_VAR 0 4
54532: PUSH
54533: LD_VAR 0 9
54537: PUSH
54538: LD_VAR 0 3
54542: ARRAY
54543: DIFF
54544: ST_TO_ADDR
// end ;
54545: GO 54454
54547: POP
54548: POP
// if p then
54549: LD_VAR 0 11
54553: IFFALSE 54578
// result := Replace ( result , 2 , p ) ;
54555: LD_ADDR_VAR 0 2
54559: PUSH
54560: LD_VAR 0 2
54564: PPUSH
54565: LD_INT 2
54567: PPUSH
54568: LD_VAR 0 11
54572: PPUSH
54573: CALL_OW 1
54577: ST_TO_ADDR
// end ; exit ;
54578: GO 55302
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
54580: LD_EXP 69
54584: PUSH
54585: LD_EXP 68
54589: PUSH
54590: LD_VAR 0 1
54594: ARRAY
54595: ARRAY
54596: NOT
54597: PUSH
54598: LD_EXP 42
54602: PUSH
54603: LD_VAR 0 1
54607: ARRAY
54608: PPUSH
54609: LD_INT 30
54611: PUSH
54612: LD_INT 3
54614: PUSH
54615: EMPTY
54616: LIST
54617: LIST
54618: PPUSH
54619: CALL_OW 72
54623: AND
54624: PUSH
54625: LD_EXP 47
54629: PUSH
54630: LD_VAR 0 1
54634: ARRAY
54635: NOT
54636: AND
54637: IFFALSE 55302
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
54639: LD_ADDR_EXP 84
54643: PUSH
54644: LD_EXP 84
54648: PPUSH
54649: LD_VAR 0 1
54653: PPUSH
54654: LD_INT 6
54656: PPUSH
54657: CALL_OW 1
54661: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54662: LD_ADDR_VAR 0 2
54666: PUSH
54667: LD_INT 0
54669: PUSH
54670: LD_INT 0
54672: PUSH
54673: LD_INT 0
54675: PUSH
54676: LD_INT 0
54678: PUSH
54679: EMPTY
54680: LIST
54681: LIST
54682: LIST
54683: LIST
54684: ST_TO_ADDR
// if sci >= 1 then
54685: LD_VAR 0 8
54689: PUSH
54690: LD_INT 1
54692: GREATEREQUAL
54693: IFFALSE 54715
// tmp := tmp diff sci [ 1 ] ;
54695: LD_ADDR_VAR 0 4
54699: PUSH
54700: LD_VAR 0 4
54704: PUSH
54705: LD_VAR 0 8
54709: PUSH
54710: LD_INT 1
54712: ARRAY
54713: DIFF
54714: ST_TO_ADDR
// if tmp and not sci then
54715: LD_VAR 0 4
54719: PUSH
54720: LD_VAR 0 8
54724: NOT
54725: AND
54726: IFFALSE 54795
// begin sort := SortBySkill ( tmp , 4 ) ;
54728: LD_ADDR_VAR 0 9
54732: PUSH
54733: LD_VAR 0 4
54737: PPUSH
54738: LD_INT 4
54740: PPUSH
54741: CALL 44353 0 2
54745: ST_TO_ADDR
// if sort then
54746: LD_VAR 0 9
54750: IFFALSE 54766
// p := sort [ 1 ] ;
54752: LD_ADDR_VAR 0 11
54756: PUSH
54757: LD_VAR 0 9
54761: PUSH
54762: LD_INT 1
54764: ARRAY
54765: ST_TO_ADDR
// if p then
54766: LD_VAR 0 11
54770: IFFALSE 54795
// result := Replace ( result , 4 , p ) ;
54772: LD_ADDR_VAR 0 2
54776: PUSH
54777: LD_VAR 0 2
54781: PPUSH
54782: LD_INT 4
54784: PPUSH
54785: LD_VAR 0 11
54789: PPUSH
54790: CALL_OW 1
54794: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54795: LD_ADDR_VAR 0 4
54799: PUSH
54800: LD_VAR 0 4
54804: PUSH
54805: LD_VAR 0 7
54809: DIFF
54810: ST_TO_ADDR
// if tmp and mech < 6 then
54811: LD_VAR 0 4
54815: PUSH
54816: LD_VAR 0 7
54820: PUSH
54821: LD_INT 6
54823: LESS
54824: AND
54825: IFFALSE 55007
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
54827: LD_ADDR_VAR 0 9
54831: PUSH
54832: LD_VAR 0 4
54836: PUSH
54837: LD_VAR 0 7
54841: DIFF
54842: PPUSH
54843: LD_INT 3
54845: PPUSH
54846: CALL 44353 0 2
54850: ST_TO_ADDR
// p := [ ] ;
54851: LD_ADDR_VAR 0 11
54855: PUSH
54856: EMPTY
54857: ST_TO_ADDR
// if sort then
54858: LD_VAR 0 9
54862: IFFALSE 54978
// for i = 1 to 6 - mech do
54864: LD_ADDR_VAR 0 3
54868: PUSH
54869: DOUBLE
54870: LD_INT 1
54872: DEC
54873: ST_TO_ADDR
54874: LD_INT 6
54876: PUSH
54877: LD_VAR 0 7
54881: MINUS
54882: PUSH
54883: FOR_TO
54884: IFFALSE 54976
// begin if i = sort then
54886: LD_VAR 0 3
54890: PUSH
54891: LD_VAR 0 9
54895: EQUAL
54896: IFFALSE 54900
// break ;
54898: GO 54976
// if GetClass ( i ) = 3 then
54900: LD_VAR 0 3
54904: PPUSH
54905: CALL_OW 257
54909: PUSH
54910: LD_INT 3
54912: EQUAL
54913: IFFALSE 54917
// continue ;
54915: GO 54883
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54917: LD_ADDR_VAR 0 11
54921: PUSH
54922: LD_VAR 0 11
54926: PPUSH
54927: LD_VAR 0 11
54931: PUSH
54932: LD_INT 1
54934: PLUS
54935: PPUSH
54936: LD_VAR 0 9
54940: PUSH
54941: LD_VAR 0 3
54945: ARRAY
54946: PPUSH
54947: CALL_OW 2
54951: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54952: LD_ADDR_VAR 0 4
54956: PUSH
54957: LD_VAR 0 4
54961: PUSH
54962: LD_VAR 0 9
54966: PUSH
54967: LD_VAR 0 3
54971: ARRAY
54972: DIFF
54973: ST_TO_ADDR
// end ;
54974: GO 54883
54976: POP
54977: POP
// if p then
54978: LD_VAR 0 11
54982: IFFALSE 55007
// result := Replace ( result , 3 , p ) ;
54984: LD_ADDR_VAR 0 2
54988: PUSH
54989: LD_VAR 0 2
54993: PPUSH
54994: LD_INT 3
54996: PPUSH
54997: LD_VAR 0 11
55001: PPUSH
55002: CALL_OW 1
55006: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
55007: LD_ADDR_VAR 0 4
55011: PUSH
55012: LD_VAR 0 4
55016: PUSH
55017: LD_VAR 0 6
55021: DIFF
55022: ST_TO_ADDR
// if tmp and eng < 4 then
55023: LD_VAR 0 4
55027: PUSH
55028: LD_VAR 0 6
55032: PUSH
55033: LD_INT 4
55035: LESS
55036: AND
55037: IFFALSE 55227
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
55039: LD_ADDR_VAR 0 9
55043: PUSH
55044: LD_VAR 0 4
55048: PUSH
55049: LD_VAR 0 7
55053: PUSH
55054: LD_VAR 0 6
55058: UNION
55059: DIFF
55060: PPUSH
55061: LD_INT 2
55063: PPUSH
55064: CALL 44353 0 2
55068: ST_TO_ADDR
// p := [ ] ;
55069: LD_ADDR_VAR 0 11
55073: PUSH
55074: EMPTY
55075: ST_TO_ADDR
// if sort then
55076: LD_VAR 0 9
55080: IFFALSE 55196
// for i = 1 to 4 - eng do
55082: LD_ADDR_VAR 0 3
55086: PUSH
55087: DOUBLE
55088: LD_INT 1
55090: DEC
55091: ST_TO_ADDR
55092: LD_INT 4
55094: PUSH
55095: LD_VAR 0 6
55099: MINUS
55100: PUSH
55101: FOR_TO
55102: IFFALSE 55194
// begin if i = sort then
55104: LD_VAR 0 3
55108: PUSH
55109: LD_VAR 0 9
55113: EQUAL
55114: IFFALSE 55118
// break ;
55116: GO 55194
// if GetClass ( i ) = 2 then
55118: LD_VAR 0 3
55122: PPUSH
55123: CALL_OW 257
55127: PUSH
55128: LD_INT 2
55130: EQUAL
55131: IFFALSE 55135
// continue ;
55133: GO 55101
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55135: LD_ADDR_VAR 0 11
55139: PUSH
55140: LD_VAR 0 11
55144: PPUSH
55145: LD_VAR 0 11
55149: PUSH
55150: LD_INT 1
55152: PLUS
55153: PPUSH
55154: LD_VAR 0 9
55158: PUSH
55159: LD_VAR 0 3
55163: ARRAY
55164: PPUSH
55165: CALL_OW 2
55169: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55170: LD_ADDR_VAR 0 4
55174: PUSH
55175: LD_VAR 0 4
55179: PUSH
55180: LD_VAR 0 9
55184: PUSH
55185: LD_VAR 0 3
55189: ARRAY
55190: DIFF
55191: ST_TO_ADDR
// end ;
55192: GO 55101
55194: POP
55195: POP
// if p then
55196: LD_VAR 0 11
55200: IFFALSE 55225
// result := Replace ( result , 2 , p ) ;
55202: LD_ADDR_VAR 0 2
55206: PUSH
55207: LD_VAR 0 2
55211: PPUSH
55212: LD_INT 2
55214: PPUSH
55215: LD_VAR 0 11
55219: PPUSH
55220: CALL_OW 1
55224: ST_TO_ADDR
// end else
55225: GO 55271
// for i = eng downto 5 do
55227: LD_ADDR_VAR 0 3
55231: PUSH
55232: DOUBLE
55233: LD_VAR 0 6
55237: INC
55238: ST_TO_ADDR
55239: LD_INT 5
55241: PUSH
55242: FOR_DOWNTO
55243: IFFALSE 55269
// tmp := tmp union eng [ i ] ;
55245: LD_ADDR_VAR 0 4
55249: PUSH
55250: LD_VAR 0 4
55254: PUSH
55255: LD_VAR 0 6
55259: PUSH
55260: LD_VAR 0 3
55264: ARRAY
55265: UNION
55266: ST_TO_ADDR
55267: GO 55242
55269: POP
55270: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
55271: LD_ADDR_VAR 0 2
55275: PUSH
55276: LD_VAR 0 2
55280: PPUSH
55281: LD_INT 1
55283: PPUSH
55284: LD_VAR 0 4
55288: PUSH
55289: LD_VAR 0 5
55293: DIFF
55294: PPUSH
55295: CALL_OW 1
55299: ST_TO_ADDR
// exit ;
55300: GO 55302
// end ; end ;
55302: LD_VAR 0 2
55306: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
55307: LD_INT 0
55309: PPUSH
55310: PPUSH
55311: PPUSH
// if not mc_bases then
55312: LD_EXP 42
55316: NOT
55317: IFFALSE 55321
// exit ;
55319: GO 55427
// for i = 1 to mc_bases do
55321: LD_ADDR_VAR 0 2
55325: PUSH
55326: DOUBLE
55327: LD_INT 1
55329: DEC
55330: ST_TO_ADDR
55331: LD_EXP 42
55335: PUSH
55336: FOR_TO
55337: IFFALSE 55418
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55339: LD_ADDR_VAR 0 3
55343: PUSH
55344: LD_EXP 42
55348: PUSH
55349: LD_VAR 0 2
55353: ARRAY
55354: PPUSH
55355: LD_INT 21
55357: PUSH
55358: LD_INT 3
55360: PUSH
55361: EMPTY
55362: LIST
55363: LIST
55364: PUSH
55365: LD_INT 3
55367: PUSH
55368: LD_INT 24
55370: PUSH
55371: LD_INT 1000
55373: PUSH
55374: EMPTY
55375: LIST
55376: LIST
55377: PUSH
55378: EMPTY
55379: LIST
55380: LIST
55381: PUSH
55382: EMPTY
55383: LIST
55384: LIST
55385: PPUSH
55386: CALL_OW 72
55390: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
55391: LD_ADDR_EXP 43
55395: PUSH
55396: LD_EXP 43
55400: PPUSH
55401: LD_VAR 0 2
55405: PPUSH
55406: LD_VAR 0 3
55410: PPUSH
55411: CALL_OW 1
55415: ST_TO_ADDR
// end ;
55416: GO 55336
55418: POP
55419: POP
// RaiseSailEvent ( 101 ) ;
55420: LD_INT 101
55422: PPUSH
55423: CALL_OW 427
// end ;
55427: LD_VAR 0 1
55431: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
55432: LD_INT 0
55434: PPUSH
55435: PPUSH
55436: PPUSH
55437: PPUSH
55438: PPUSH
55439: PPUSH
55440: PPUSH
// if not mc_bases then
55441: LD_EXP 42
55445: NOT
55446: IFFALSE 55450
// exit ;
55448: GO 56012
// for i = 1 to mc_bases do
55450: LD_ADDR_VAR 0 2
55454: PUSH
55455: DOUBLE
55456: LD_INT 1
55458: DEC
55459: ST_TO_ADDR
55460: LD_EXP 42
55464: PUSH
55465: FOR_TO
55466: IFFALSE 56003
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
55468: LD_ADDR_VAR 0 5
55472: PUSH
55473: LD_EXP 42
55477: PUSH
55478: LD_VAR 0 2
55482: ARRAY
55483: PUSH
55484: LD_EXP 71
55488: PUSH
55489: LD_VAR 0 2
55493: ARRAY
55494: UNION
55495: PPUSH
55496: LD_INT 21
55498: PUSH
55499: LD_INT 1
55501: PUSH
55502: EMPTY
55503: LIST
55504: LIST
55505: PUSH
55506: LD_INT 1
55508: PUSH
55509: LD_INT 3
55511: PUSH
55512: LD_INT 54
55514: PUSH
55515: EMPTY
55516: LIST
55517: PUSH
55518: EMPTY
55519: LIST
55520: LIST
55521: PUSH
55522: LD_INT 3
55524: PUSH
55525: LD_INT 24
55527: PUSH
55528: LD_INT 800
55530: PUSH
55531: EMPTY
55532: LIST
55533: LIST
55534: PUSH
55535: EMPTY
55536: LIST
55537: LIST
55538: PUSH
55539: EMPTY
55540: LIST
55541: LIST
55542: LIST
55543: PUSH
55544: EMPTY
55545: LIST
55546: LIST
55547: PPUSH
55548: CALL_OW 72
55552: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
55553: LD_ADDR_VAR 0 6
55557: PUSH
55558: LD_EXP 42
55562: PUSH
55563: LD_VAR 0 2
55567: ARRAY
55568: PPUSH
55569: LD_INT 21
55571: PUSH
55572: LD_INT 1
55574: PUSH
55575: EMPTY
55576: LIST
55577: LIST
55578: PUSH
55579: LD_INT 1
55581: PUSH
55582: LD_INT 3
55584: PUSH
55585: LD_INT 54
55587: PUSH
55588: EMPTY
55589: LIST
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PUSH
55595: LD_INT 3
55597: PUSH
55598: LD_INT 24
55600: PUSH
55601: LD_INT 250
55603: PUSH
55604: EMPTY
55605: LIST
55606: LIST
55607: PUSH
55608: EMPTY
55609: LIST
55610: LIST
55611: PUSH
55612: EMPTY
55613: LIST
55614: LIST
55615: LIST
55616: PUSH
55617: EMPTY
55618: LIST
55619: LIST
55620: PPUSH
55621: CALL_OW 72
55625: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
55626: LD_ADDR_VAR 0 7
55630: PUSH
55631: LD_VAR 0 5
55635: PUSH
55636: LD_VAR 0 6
55640: DIFF
55641: ST_TO_ADDR
// if not need_heal_1 then
55642: LD_VAR 0 6
55646: NOT
55647: IFFALSE 55680
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
55649: LD_ADDR_EXP 45
55653: PUSH
55654: LD_EXP 45
55658: PPUSH
55659: LD_VAR 0 2
55663: PUSH
55664: LD_INT 1
55666: PUSH
55667: EMPTY
55668: LIST
55669: LIST
55670: PPUSH
55671: EMPTY
55672: PPUSH
55673: CALL 14804 0 3
55677: ST_TO_ADDR
55678: GO 55750
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
55680: LD_ADDR_EXP 45
55684: PUSH
55685: LD_EXP 45
55689: PPUSH
55690: LD_VAR 0 2
55694: PUSH
55695: LD_INT 1
55697: PUSH
55698: EMPTY
55699: LIST
55700: LIST
55701: PPUSH
55702: LD_EXP 45
55706: PUSH
55707: LD_VAR 0 2
55711: ARRAY
55712: PUSH
55713: LD_INT 1
55715: ARRAY
55716: PPUSH
55717: LD_INT 3
55719: PUSH
55720: LD_INT 24
55722: PUSH
55723: LD_INT 1000
55725: PUSH
55726: EMPTY
55727: LIST
55728: LIST
55729: PUSH
55730: EMPTY
55731: LIST
55732: LIST
55733: PPUSH
55734: CALL_OW 72
55738: PUSH
55739: LD_VAR 0 6
55743: UNION
55744: PPUSH
55745: CALL 14804 0 3
55749: ST_TO_ADDR
// if not need_heal_2 then
55750: LD_VAR 0 7
55754: NOT
55755: IFFALSE 55788
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
55757: LD_ADDR_EXP 45
55761: PUSH
55762: LD_EXP 45
55766: PPUSH
55767: LD_VAR 0 2
55771: PUSH
55772: LD_INT 2
55774: PUSH
55775: EMPTY
55776: LIST
55777: LIST
55778: PPUSH
55779: EMPTY
55780: PPUSH
55781: CALL 14804 0 3
55785: ST_TO_ADDR
55786: GO 55820
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
55788: LD_ADDR_EXP 45
55792: PUSH
55793: LD_EXP 45
55797: PPUSH
55798: LD_VAR 0 2
55802: PUSH
55803: LD_INT 2
55805: PUSH
55806: EMPTY
55807: LIST
55808: LIST
55809: PPUSH
55810: LD_VAR 0 7
55814: PPUSH
55815: CALL 14804 0 3
55819: ST_TO_ADDR
// if need_heal_2 then
55820: LD_VAR 0 7
55824: IFFALSE 55985
// for j in need_heal_2 do
55826: LD_ADDR_VAR 0 3
55830: PUSH
55831: LD_VAR 0 7
55835: PUSH
55836: FOR_IN
55837: IFFALSE 55983
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55839: LD_ADDR_VAR 0 5
55843: PUSH
55844: LD_EXP 42
55848: PUSH
55849: LD_VAR 0 2
55853: ARRAY
55854: PPUSH
55855: LD_INT 2
55857: PUSH
55858: LD_INT 30
55860: PUSH
55861: LD_INT 6
55863: PUSH
55864: EMPTY
55865: LIST
55866: LIST
55867: PUSH
55868: LD_INT 30
55870: PUSH
55871: LD_INT 7
55873: PUSH
55874: EMPTY
55875: LIST
55876: LIST
55877: PUSH
55878: LD_INT 30
55880: PUSH
55881: LD_INT 8
55883: PUSH
55884: EMPTY
55885: LIST
55886: LIST
55887: PUSH
55888: LD_INT 30
55890: PUSH
55891: LD_INT 0
55893: PUSH
55894: EMPTY
55895: LIST
55896: LIST
55897: PUSH
55898: LD_INT 30
55900: PUSH
55901: LD_INT 1
55903: PUSH
55904: EMPTY
55905: LIST
55906: LIST
55907: PUSH
55908: EMPTY
55909: LIST
55910: LIST
55911: LIST
55912: LIST
55913: LIST
55914: LIST
55915: PPUSH
55916: CALL_OW 72
55920: ST_TO_ADDR
// if tmp then
55921: LD_VAR 0 5
55925: IFFALSE 55981
// begin k := NearestUnitToUnit ( tmp , j ) ;
55927: LD_ADDR_VAR 0 4
55931: PUSH
55932: LD_VAR 0 5
55936: PPUSH
55937: LD_VAR 0 3
55941: PPUSH
55942: CALL_OW 74
55946: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
55947: LD_VAR 0 3
55951: PPUSH
55952: LD_VAR 0 4
55956: PPUSH
55957: CALL_OW 296
55961: PUSH
55962: LD_INT 5
55964: GREATER
55965: IFFALSE 55981
// ComMoveToNearbyEntrance ( j , k ) ;
55967: LD_VAR 0 3
55971: PPUSH
55972: LD_VAR 0 4
55976: PPUSH
55977: CALL 46670 0 2
// end ; end ;
55981: GO 55836
55983: POP
55984: POP
// if not need_heal_1 and not need_heal_2 then
55985: LD_VAR 0 6
55989: NOT
55990: PUSH
55991: LD_VAR 0 7
55995: NOT
55996: AND
55997: IFFALSE 56001
// continue ;
55999: GO 55465
// end ;
56001: GO 55465
56003: POP
56004: POP
// RaiseSailEvent ( 102 ) ;
56005: LD_INT 102
56007: PPUSH
56008: CALL_OW 427
// end ;
56012: LD_VAR 0 1
56016: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
56017: LD_INT 0
56019: PPUSH
56020: PPUSH
56021: PPUSH
56022: PPUSH
56023: PPUSH
56024: PPUSH
56025: PPUSH
56026: PPUSH
// if not mc_bases then
56027: LD_EXP 42
56031: NOT
56032: IFFALSE 56036
// exit ;
56034: GO 56897
// for i = 1 to mc_bases do
56036: LD_ADDR_VAR 0 2
56040: PUSH
56041: DOUBLE
56042: LD_INT 1
56044: DEC
56045: ST_TO_ADDR
56046: LD_EXP 42
56050: PUSH
56051: FOR_TO
56052: IFFALSE 56895
// begin if not mc_building_need_repair [ i ] then
56054: LD_EXP 43
56058: PUSH
56059: LD_VAR 0 2
56063: ARRAY
56064: NOT
56065: IFFALSE 56252
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
56067: LD_ADDR_VAR 0 6
56071: PUSH
56072: LD_EXP 61
56076: PUSH
56077: LD_VAR 0 2
56081: ARRAY
56082: PPUSH
56083: LD_INT 3
56085: PUSH
56086: LD_INT 24
56088: PUSH
56089: LD_INT 1000
56091: PUSH
56092: EMPTY
56093: LIST
56094: LIST
56095: PUSH
56096: EMPTY
56097: LIST
56098: LIST
56099: PUSH
56100: LD_INT 2
56102: PUSH
56103: LD_INT 34
56105: PUSH
56106: LD_INT 13
56108: PUSH
56109: EMPTY
56110: LIST
56111: LIST
56112: PUSH
56113: LD_INT 34
56115: PUSH
56116: LD_INT 52
56118: PUSH
56119: EMPTY
56120: LIST
56121: LIST
56122: PUSH
56123: LD_INT 34
56125: PUSH
56126: LD_EXP 91
56130: PUSH
56131: EMPTY
56132: LIST
56133: LIST
56134: PUSH
56135: EMPTY
56136: LIST
56137: LIST
56138: LIST
56139: LIST
56140: PUSH
56141: EMPTY
56142: LIST
56143: LIST
56144: PPUSH
56145: CALL_OW 72
56149: ST_TO_ADDR
// if cranes then
56150: LD_VAR 0 6
56154: IFFALSE 56216
// for j in cranes do
56156: LD_ADDR_VAR 0 3
56160: PUSH
56161: LD_VAR 0 6
56165: PUSH
56166: FOR_IN
56167: IFFALSE 56214
// if not IsInArea ( j , mc_parking [ i ] ) then
56169: LD_VAR 0 3
56173: PPUSH
56174: LD_EXP 66
56178: PUSH
56179: LD_VAR 0 2
56183: ARRAY
56184: PPUSH
56185: CALL_OW 308
56189: NOT
56190: IFFALSE 56212
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56192: LD_VAR 0 3
56196: PPUSH
56197: LD_EXP 66
56201: PUSH
56202: LD_VAR 0 2
56206: ARRAY
56207: PPUSH
56208: CALL_OW 113
56212: GO 56166
56214: POP
56215: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56216: LD_ADDR_EXP 44
56220: PUSH
56221: LD_EXP 44
56225: PPUSH
56226: LD_VAR 0 2
56230: PPUSH
56231: EMPTY
56232: PPUSH
56233: CALL_OW 1
56237: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
56238: LD_VAR 0 2
56242: PPUSH
56243: LD_INT 101
56245: PPUSH
56246: CALL 51140 0 2
// continue ;
56250: GO 56051
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
56252: LD_ADDR_EXP 48
56256: PUSH
56257: LD_EXP 48
56261: PPUSH
56262: LD_VAR 0 2
56266: PPUSH
56267: EMPTY
56268: PPUSH
56269: CALL_OW 1
56273: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
56274: LD_VAR 0 2
56278: PPUSH
56279: LD_INT 103
56281: PPUSH
56282: CALL 51140 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
56286: LD_ADDR_VAR 0 5
56290: PUSH
56291: LD_EXP 42
56295: PUSH
56296: LD_VAR 0 2
56300: ARRAY
56301: PUSH
56302: LD_EXP 71
56306: PUSH
56307: LD_VAR 0 2
56311: ARRAY
56312: UNION
56313: PPUSH
56314: LD_INT 2
56316: PUSH
56317: LD_INT 25
56319: PUSH
56320: LD_INT 2
56322: PUSH
56323: EMPTY
56324: LIST
56325: LIST
56326: PUSH
56327: LD_INT 25
56329: PUSH
56330: LD_INT 16
56332: PUSH
56333: EMPTY
56334: LIST
56335: LIST
56336: PUSH
56337: EMPTY
56338: LIST
56339: LIST
56340: LIST
56341: PUSH
56342: EMPTY
56343: LIST
56344: PPUSH
56345: CALL_OW 72
56349: PUSH
56350: LD_EXP 45
56354: PUSH
56355: LD_VAR 0 2
56359: ARRAY
56360: PUSH
56361: LD_INT 1
56363: ARRAY
56364: PUSH
56365: LD_EXP 45
56369: PUSH
56370: LD_VAR 0 2
56374: ARRAY
56375: PUSH
56376: LD_INT 2
56378: ARRAY
56379: UNION
56380: DIFF
56381: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
56382: LD_ADDR_VAR 0 6
56386: PUSH
56387: LD_EXP 61
56391: PUSH
56392: LD_VAR 0 2
56396: ARRAY
56397: PPUSH
56398: LD_INT 2
56400: PUSH
56401: LD_INT 34
56403: PUSH
56404: LD_INT 13
56406: PUSH
56407: EMPTY
56408: LIST
56409: LIST
56410: PUSH
56411: LD_INT 34
56413: PUSH
56414: LD_INT 52
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: PUSH
56421: LD_INT 34
56423: PUSH
56424: LD_EXP 91
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: PUSH
56433: EMPTY
56434: LIST
56435: LIST
56436: LIST
56437: LIST
56438: PPUSH
56439: CALL_OW 72
56443: ST_TO_ADDR
// if cranes then
56444: LD_VAR 0 6
56448: IFFALSE 56584
// begin for j in cranes do
56450: LD_ADDR_VAR 0 3
56454: PUSH
56455: LD_VAR 0 6
56459: PUSH
56460: FOR_IN
56461: IFFALSE 56582
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
56463: LD_VAR 0 3
56467: PPUSH
56468: CALL_OW 256
56472: PUSH
56473: LD_INT 1000
56475: EQUAL
56476: PUSH
56477: LD_VAR 0 3
56481: PPUSH
56482: CALL_OW 314
56486: NOT
56487: AND
56488: IFFALSE 56522
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
56490: LD_VAR 0 3
56494: PPUSH
56495: LD_EXP 43
56499: PUSH
56500: LD_VAR 0 2
56504: ARRAY
56505: PPUSH
56506: LD_VAR 0 3
56510: PPUSH
56511: CALL_OW 74
56515: PPUSH
56516: CALL_OW 130
56520: GO 56580
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
56522: LD_VAR 0 3
56526: PPUSH
56527: CALL_OW 256
56531: PUSH
56532: LD_INT 500
56534: LESS
56535: PUSH
56536: LD_VAR 0 3
56540: PPUSH
56541: LD_EXP 66
56545: PUSH
56546: LD_VAR 0 2
56550: ARRAY
56551: PPUSH
56552: CALL_OW 308
56556: NOT
56557: AND
56558: IFFALSE 56580
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56560: LD_VAR 0 3
56564: PPUSH
56565: LD_EXP 66
56569: PUSH
56570: LD_VAR 0 2
56574: ARRAY
56575: PPUSH
56576: CALL_OW 113
// end ;
56580: GO 56460
56582: POP
56583: POP
// end ; if tmp > 3 then
56584: LD_VAR 0 5
56588: PUSH
56589: LD_INT 3
56591: GREATER
56592: IFFALSE 56612
// tmp := ShrinkArray ( tmp , 4 ) ;
56594: LD_ADDR_VAR 0 5
56598: PUSH
56599: LD_VAR 0 5
56603: PPUSH
56604: LD_INT 4
56606: PPUSH
56607: CALL 46162 0 2
56611: ST_TO_ADDR
// if not tmp then
56612: LD_VAR 0 5
56616: NOT
56617: IFFALSE 56621
// continue ;
56619: GO 56051
// for j in tmp do
56621: LD_ADDR_VAR 0 3
56625: PUSH
56626: LD_VAR 0 5
56630: PUSH
56631: FOR_IN
56632: IFFALSE 56891
// begin if IsInUnit ( j ) then
56634: LD_VAR 0 3
56638: PPUSH
56639: CALL_OW 310
56643: IFFALSE 56654
// ComExitBuilding ( j ) ;
56645: LD_VAR 0 3
56649: PPUSH
56650: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
56654: LD_VAR 0 3
56658: PUSH
56659: LD_EXP 44
56663: PUSH
56664: LD_VAR 0 2
56668: ARRAY
56669: IN
56670: NOT
56671: IFFALSE 56729
// begin SetTag ( j , 101 ) ;
56673: LD_VAR 0 3
56677: PPUSH
56678: LD_INT 101
56680: PPUSH
56681: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
56685: LD_ADDR_EXP 44
56689: PUSH
56690: LD_EXP 44
56694: PPUSH
56695: LD_VAR 0 2
56699: PUSH
56700: LD_EXP 44
56704: PUSH
56705: LD_VAR 0 2
56709: ARRAY
56710: PUSH
56711: LD_INT 1
56713: PLUS
56714: PUSH
56715: EMPTY
56716: LIST
56717: LIST
56718: PPUSH
56719: LD_VAR 0 3
56723: PPUSH
56724: CALL 14804 0 3
56728: ST_TO_ADDR
// end ; wait ( 1 ) ;
56729: LD_INT 1
56731: PPUSH
56732: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
56736: LD_ADDR_VAR 0 7
56740: PUSH
56741: LD_EXP 43
56745: PUSH
56746: LD_VAR 0 2
56750: ARRAY
56751: ST_TO_ADDR
// if mc_scan [ i ] then
56752: LD_EXP 65
56756: PUSH
56757: LD_VAR 0 2
56761: ARRAY
56762: IFFALSE 56824
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
56764: LD_ADDR_VAR 0 7
56768: PUSH
56769: LD_EXP 43
56773: PUSH
56774: LD_VAR 0 2
56778: ARRAY
56779: PPUSH
56780: LD_INT 3
56782: PUSH
56783: LD_INT 30
56785: PUSH
56786: LD_INT 32
56788: PUSH
56789: EMPTY
56790: LIST
56791: LIST
56792: PUSH
56793: LD_INT 30
56795: PUSH
56796: LD_INT 33
56798: PUSH
56799: EMPTY
56800: LIST
56801: LIST
56802: PUSH
56803: LD_INT 30
56805: PUSH
56806: LD_INT 31
56808: PUSH
56809: EMPTY
56810: LIST
56811: LIST
56812: PUSH
56813: EMPTY
56814: LIST
56815: LIST
56816: LIST
56817: LIST
56818: PPUSH
56819: CALL_OW 72
56823: ST_TO_ADDR
// if not to_repair_tmp then
56824: LD_VAR 0 7
56828: NOT
56829: IFFALSE 56833
// continue ;
56831: GO 56631
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
56833: LD_ADDR_VAR 0 8
56837: PUSH
56838: LD_VAR 0 7
56842: PPUSH
56843: LD_VAR 0 3
56847: PPUSH
56848: CALL_OW 74
56852: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
56853: LD_VAR 0 8
56857: PPUSH
56858: LD_INT 16
56860: PPUSH
56861: CALL 17397 0 2
56865: PUSH
56866: LD_INT 4
56868: ARRAY
56869: PUSH
56870: LD_INT 10
56872: LESS
56873: IFFALSE 56889
// ComRepairBuilding ( j , to_repair ) ;
56875: LD_VAR 0 3
56879: PPUSH
56880: LD_VAR 0 8
56884: PPUSH
56885: CALL_OW 130
// end ;
56889: GO 56631
56891: POP
56892: POP
// end ;
56893: GO 56051
56895: POP
56896: POP
// end ;
56897: LD_VAR 0 1
56901: RET
// export function MC_Heal ; var i , j , tmp ; begin
56902: LD_INT 0
56904: PPUSH
56905: PPUSH
56906: PPUSH
56907: PPUSH
// if not mc_bases then
56908: LD_EXP 42
56912: NOT
56913: IFFALSE 56917
// exit ;
56915: GO 57319
// for i = 1 to mc_bases do
56917: LD_ADDR_VAR 0 2
56921: PUSH
56922: DOUBLE
56923: LD_INT 1
56925: DEC
56926: ST_TO_ADDR
56927: LD_EXP 42
56931: PUSH
56932: FOR_TO
56933: IFFALSE 57317
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
56935: LD_EXP 45
56939: PUSH
56940: LD_VAR 0 2
56944: ARRAY
56945: PUSH
56946: LD_INT 1
56948: ARRAY
56949: NOT
56950: PUSH
56951: LD_EXP 45
56955: PUSH
56956: LD_VAR 0 2
56960: ARRAY
56961: PUSH
56962: LD_INT 2
56964: ARRAY
56965: NOT
56966: AND
56967: IFFALSE 57005
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
56969: LD_ADDR_EXP 46
56973: PUSH
56974: LD_EXP 46
56978: PPUSH
56979: LD_VAR 0 2
56983: PPUSH
56984: EMPTY
56985: PPUSH
56986: CALL_OW 1
56990: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
56991: LD_VAR 0 2
56995: PPUSH
56996: LD_INT 102
56998: PPUSH
56999: CALL 51140 0 2
// continue ;
57003: GO 56932
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57005: LD_ADDR_VAR 0 4
57009: PUSH
57010: LD_EXP 42
57014: PUSH
57015: LD_VAR 0 2
57019: ARRAY
57020: PPUSH
57021: LD_INT 25
57023: PUSH
57024: LD_INT 4
57026: PUSH
57027: EMPTY
57028: LIST
57029: LIST
57030: PPUSH
57031: CALL_OW 72
57035: ST_TO_ADDR
// if not tmp then
57036: LD_VAR 0 4
57040: NOT
57041: IFFALSE 57045
// continue ;
57043: GO 56932
// if mc_taming [ i ] then
57045: LD_EXP 73
57049: PUSH
57050: LD_VAR 0 2
57054: ARRAY
57055: IFFALSE 57079
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57057: LD_ADDR_EXP 73
57061: PUSH
57062: LD_EXP 73
57066: PPUSH
57067: LD_VAR 0 2
57071: PPUSH
57072: EMPTY
57073: PPUSH
57074: CALL_OW 1
57078: ST_TO_ADDR
// for j in tmp do
57079: LD_ADDR_VAR 0 3
57083: PUSH
57084: LD_VAR 0 4
57088: PUSH
57089: FOR_IN
57090: IFFALSE 57313
// begin if IsInUnit ( j ) then
57092: LD_VAR 0 3
57096: PPUSH
57097: CALL_OW 310
57101: IFFALSE 57112
// ComExitBuilding ( j ) ;
57103: LD_VAR 0 3
57107: PPUSH
57108: CALL_OW 122
// if not j in mc_healers [ i ] then
57112: LD_VAR 0 3
57116: PUSH
57117: LD_EXP 46
57121: PUSH
57122: LD_VAR 0 2
57126: ARRAY
57127: IN
57128: NOT
57129: IFFALSE 57175
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
57131: LD_ADDR_EXP 46
57135: PUSH
57136: LD_EXP 46
57140: PPUSH
57141: LD_VAR 0 2
57145: PUSH
57146: LD_EXP 46
57150: PUSH
57151: LD_VAR 0 2
57155: ARRAY
57156: PUSH
57157: LD_INT 1
57159: PLUS
57160: PUSH
57161: EMPTY
57162: LIST
57163: LIST
57164: PPUSH
57165: LD_VAR 0 3
57169: PPUSH
57170: CALL 14804 0 3
57174: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
57175: LD_VAR 0 3
57179: PPUSH
57180: CALL_OW 110
57184: PUSH
57185: LD_INT 102
57187: NONEQUAL
57188: IFFALSE 57202
// SetTag ( j , 102 ) ;
57190: LD_VAR 0 3
57194: PPUSH
57195: LD_INT 102
57197: PPUSH
57198: CALL_OW 109
// Wait ( 3 ) ;
57202: LD_INT 3
57204: PPUSH
57205: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
57209: LD_EXP 45
57213: PUSH
57214: LD_VAR 0 2
57218: ARRAY
57219: PUSH
57220: LD_INT 1
57222: ARRAY
57223: IFFALSE 57255
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
57225: LD_VAR 0 3
57229: PPUSH
57230: LD_EXP 45
57234: PUSH
57235: LD_VAR 0 2
57239: ARRAY
57240: PUSH
57241: LD_INT 1
57243: ARRAY
57244: PUSH
57245: LD_INT 1
57247: ARRAY
57248: PPUSH
57249: CALL_OW 128
57253: GO 57311
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
57255: LD_VAR 0 3
57259: PPUSH
57260: CALL_OW 314
57264: NOT
57265: PUSH
57266: LD_EXP 45
57270: PUSH
57271: LD_VAR 0 2
57275: ARRAY
57276: PUSH
57277: LD_INT 2
57279: ARRAY
57280: AND
57281: IFFALSE 57311
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
57283: LD_VAR 0 3
57287: PPUSH
57288: LD_EXP 45
57292: PUSH
57293: LD_VAR 0 2
57297: ARRAY
57298: PUSH
57299: LD_INT 2
57301: ARRAY
57302: PUSH
57303: LD_INT 1
57305: ARRAY
57306: PPUSH
57307: CALL_OW 128
// end ;
57311: GO 57089
57313: POP
57314: POP
// end ;
57315: GO 56932
57317: POP
57318: POP
// end ;
57319: LD_VAR 0 1
57323: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
57324: LD_INT 0
57326: PPUSH
57327: PPUSH
57328: PPUSH
57329: PPUSH
57330: PPUSH
// if not mc_bases then
57331: LD_EXP 42
57335: NOT
57336: IFFALSE 57340
// exit ;
57338: GO 58483
// for i = 1 to mc_bases do
57340: LD_ADDR_VAR 0 2
57344: PUSH
57345: DOUBLE
57346: LD_INT 1
57348: DEC
57349: ST_TO_ADDR
57350: LD_EXP 42
57354: PUSH
57355: FOR_TO
57356: IFFALSE 58481
// begin if mc_scan [ i ] then
57358: LD_EXP 65
57362: PUSH
57363: LD_VAR 0 2
57367: ARRAY
57368: IFFALSE 57372
// continue ;
57370: GO 57355
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
57372: LD_EXP 47
57376: PUSH
57377: LD_VAR 0 2
57381: ARRAY
57382: NOT
57383: PUSH
57384: LD_EXP 49
57388: PUSH
57389: LD_VAR 0 2
57393: ARRAY
57394: NOT
57395: AND
57396: PUSH
57397: LD_EXP 48
57401: PUSH
57402: LD_VAR 0 2
57406: ARRAY
57407: AND
57408: IFFALSE 57446
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
57410: LD_ADDR_EXP 48
57414: PUSH
57415: LD_EXP 48
57419: PPUSH
57420: LD_VAR 0 2
57424: PPUSH
57425: EMPTY
57426: PPUSH
57427: CALL_OW 1
57431: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
57432: LD_VAR 0 2
57436: PPUSH
57437: LD_INT 103
57439: PPUSH
57440: CALL 51140 0 2
// continue ;
57444: GO 57355
// end ; if mc_construct_list [ i ] then
57446: LD_EXP 49
57450: PUSH
57451: LD_VAR 0 2
57455: ARRAY
57456: IFFALSE 57676
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
57458: LD_ADDR_VAR 0 4
57462: PUSH
57463: LD_EXP 42
57467: PUSH
57468: LD_VAR 0 2
57472: ARRAY
57473: PPUSH
57474: LD_INT 25
57476: PUSH
57477: LD_INT 2
57479: PUSH
57480: EMPTY
57481: LIST
57482: LIST
57483: PPUSH
57484: CALL_OW 72
57488: PUSH
57489: LD_EXP 44
57493: PUSH
57494: LD_VAR 0 2
57498: ARRAY
57499: DIFF
57500: ST_TO_ADDR
// if not tmp then
57501: LD_VAR 0 4
57505: NOT
57506: IFFALSE 57510
// continue ;
57508: GO 57355
// for j in tmp do
57510: LD_ADDR_VAR 0 3
57514: PUSH
57515: LD_VAR 0 4
57519: PUSH
57520: FOR_IN
57521: IFFALSE 57672
// begin if not mc_builders [ i ] then
57523: LD_EXP 48
57527: PUSH
57528: LD_VAR 0 2
57532: ARRAY
57533: NOT
57534: IFFALSE 57592
// begin SetTag ( j , 103 ) ;
57536: LD_VAR 0 3
57540: PPUSH
57541: LD_INT 103
57543: PPUSH
57544: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
57548: LD_ADDR_EXP 48
57552: PUSH
57553: LD_EXP 48
57557: PPUSH
57558: LD_VAR 0 2
57562: PUSH
57563: LD_EXP 48
57567: PUSH
57568: LD_VAR 0 2
57572: ARRAY
57573: PUSH
57574: LD_INT 1
57576: PLUS
57577: PUSH
57578: EMPTY
57579: LIST
57580: LIST
57581: PPUSH
57582: LD_VAR 0 3
57586: PPUSH
57587: CALL 14804 0 3
57591: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
57592: LD_VAR 0 3
57596: PPUSH
57597: CALL_OW 310
57601: IFFALSE 57612
// ComExitBuilding ( j ) ;
57603: LD_VAR 0 3
57607: PPUSH
57608: CALL_OW 122
// wait ( 3 ) ;
57612: LD_INT 3
57614: PPUSH
57615: CALL_OW 67
// if not mc_construct_list [ i ] then
57619: LD_EXP 49
57623: PUSH
57624: LD_VAR 0 2
57628: ARRAY
57629: NOT
57630: IFFALSE 57634
// break ;
57632: GO 57672
// if not HasTask ( j ) then
57634: LD_VAR 0 3
57638: PPUSH
57639: CALL_OW 314
57643: NOT
57644: IFFALSE 57670
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
57646: LD_VAR 0 3
57650: PPUSH
57651: LD_EXP 49
57655: PUSH
57656: LD_VAR 0 2
57660: ARRAY
57661: PUSH
57662: LD_INT 1
57664: ARRAY
57665: PPUSH
57666: CALL 17655 0 2
// end ;
57670: GO 57520
57672: POP
57673: POP
// end else
57674: GO 58479
// if mc_build_list [ i ] then
57676: LD_EXP 47
57680: PUSH
57681: LD_VAR 0 2
57685: ARRAY
57686: IFFALSE 58479
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57688: LD_ADDR_VAR 0 5
57692: PUSH
57693: LD_EXP 42
57697: PUSH
57698: LD_VAR 0 2
57702: ARRAY
57703: PPUSH
57704: LD_INT 2
57706: PUSH
57707: LD_INT 30
57709: PUSH
57710: LD_INT 0
57712: PUSH
57713: EMPTY
57714: LIST
57715: LIST
57716: PUSH
57717: LD_INT 30
57719: PUSH
57720: LD_INT 1
57722: PUSH
57723: EMPTY
57724: LIST
57725: LIST
57726: PUSH
57727: EMPTY
57728: LIST
57729: LIST
57730: LIST
57731: PPUSH
57732: CALL_OW 72
57736: ST_TO_ADDR
// if depot then
57737: LD_VAR 0 5
57741: IFFALSE 57759
// depot := depot [ 1 ] else
57743: LD_ADDR_VAR 0 5
57747: PUSH
57748: LD_VAR 0 5
57752: PUSH
57753: LD_INT 1
57755: ARRAY
57756: ST_TO_ADDR
57757: GO 57767
// depot := 0 ;
57759: LD_ADDR_VAR 0 5
57763: PUSH
57764: LD_INT 0
57766: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
57767: LD_EXP 47
57771: PUSH
57772: LD_VAR 0 2
57776: ARRAY
57777: PUSH
57778: LD_INT 1
57780: ARRAY
57781: PUSH
57782: LD_INT 1
57784: ARRAY
57785: PPUSH
57786: CALL 17485 0 1
57790: PUSH
57791: LD_EXP 42
57795: PUSH
57796: LD_VAR 0 2
57800: ARRAY
57801: PPUSH
57802: LD_INT 2
57804: PUSH
57805: LD_INT 30
57807: PUSH
57808: LD_INT 2
57810: PUSH
57811: EMPTY
57812: LIST
57813: LIST
57814: PUSH
57815: LD_INT 30
57817: PUSH
57818: LD_INT 3
57820: PUSH
57821: EMPTY
57822: LIST
57823: LIST
57824: PUSH
57825: EMPTY
57826: LIST
57827: LIST
57828: LIST
57829: PPUSH
57830: CALL_OW 72
57834: NOT
57835: AND
57836: IFFALSE 57941
// begin for j = 1 to mc_build_list [ i ] do
57838: LD_ADDR_VAR 0 3
57842: PUSH
57843: DOUBLE
57844: LD_INT 1
57846: DEC
57847: ST_TO_ADDR
57848: LD_EXP 47
57852: PUSH
57853: LD_VAR 0 2
57857: ARRAY
57858: PUSH
57859: FOR_TO
57860: IFFALSE 57939
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
57862: LD_EXP 47
57866: PUSH
57867: LD_VAR 0 2
57871: ARRAY
57872: PUSH
57873: LD_VAR 0 3
57877: ARRAY
57878: PUSH
57879: LD_INT 1
57881: ARRAY
57882: PUSH
57883: LD_INT 2
57885: EQUAL
57886: IFFALSE 57937
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
57888: LD_ADDR_EXP 47
57892: PUSH
57893: LD_EXP 47
57897: PPUSH
57898: LD_VAR 0 2
57902: PPUSH
57903: LD_EXP 47
57907: PUSH
57908: LD_VAR 0 2
57912: ARRAY
57913: PPUSH
57914: LD_VAR 0 3
57918: PPUSH
57919: LD_INT 1
57921: PPUSH
57922: LD_INT 0
57924: PPUSH
57925: CALL 14222 0 4
57929: PPUSH
57930: CALL_OW 1
57934: ST_TO_ADDR
// break ;
57935: GO 57939
// end ;
57937: GO 57859
57939: POP
57940: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
57941: LD_EXP 47
57945: PUSH
57946: LD_VAR 0 2
57950: ARRAY
57951: PUSH
57952: LD_INT 1
57954: ARRAY
57955: PUSH
57956: LD_INT 1
57958: ARRAY
57959: PUSH
57960: LD_INT 0
57962: EQUAL
57963: PUSH
57964: LD_VAR 0 5
57968: PUSH
57969: LD_VAR 0 5
57973: PPUSH
57974: LD_EXP 47
57978: PUSH
57979: LD_VAR 0 2
57983: ARRAY
57984: PUSH
57985: LD_INT 1
57987: ARRAY
57988: PUSH
57989: LD_INT 1
57991: ARRAY
57992: PPUSH
57993: LD_EXP 47
57997: PUSH
57998: LD_VAR 0 2
58002: ARRAY
58003: PUSH
58004: LD_INT 1
58006: ARRAY
58007: PUSH
58008: LD_INT 2
58010: ARRAY
58011: PPUSH
58012: LD_EXP 47
58016: PUSH
58017: LD_VAR 0 2
58021: ARRAY
58022: PUSH
58023: LD_INT 1
58025: ARRAY
58026: PUSH
58027: LD_INT 3
58029: ARRAY
58030: PPUSH
58031: LD_EXP 47
58035: PUSH
58036: LD_VAR 0 2
58040: ARRAY
58041: PUSH
58042: LD_INT 1
58044: ARRAY
58045: PUSH
58046: LD_INT 4
58048: ARRAY
58049: PPUSH
58050: CALL 22219 0 5
58054: AND
58055: OR
58056: IFFALSE 58337
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58058: LD_ADDR_VAR 0 4
58062: PUSH
58063: LD_EXP 42
58067: PUSH
58068: LD_VAR 0 2
58072: ARRAY
58073: PPUSH
58074: LD_INT 25
58076: PUSH
58077: LD_INT 2
58079: PUSH
58080: EMPTY
58081: LIST
58082: LIST
58083: PPUSH
58084: CALL_OW 72
58088: PUSH
58089: LD_EXP 44
58093: PUSH
58094: LD_VAR 0 2
58098: ARRAY
58099: DIFF
58100: ST_TO_ADDR
// if not tmp then
58101: LD_VAR 0 4
58105: NOT
58106: IFFALSE 58110
// continue ;
58108: GO 57355
// for j in tmp do
58110: LD_ADDR_VAR 0 3
58114: PUSH
58115: LD_VAR 0 4
58119: PUSH
58120: FOR_IN
58121: IFFALSE 58333
// begin if not mc_builders [ i ] then
58123: LD_EXP 48
58127: PUSH
58128: LD_VAR 0 2
58132: ARRAY
58133: NOT
58134: IFFALSE 58192
// begin SetTag ( j , 103 ) ;
58136: LD_VAR 0 3
58140: PPUSH
58141: LD_INT 103
58143: PPUSH
58144: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58148: LD_ADDR_EXP 48
58152: PUSH
58153: LD_EXP 48
58157: PPUSH
58158: LD_VAR 0 2
58162: PUSH
58163: LD_EXP 48
58167: PUSH
58168: LD_VAR 0 2
58172: ARRAY
58173: PUSH
58174: LD_INT 1
58176: PLUS
58177: PUSH
58178: EMPTY
58179: LIST
58180: LIST
58181: PPUSH
58182: LD_VAR 0 3
58186: PPUSH
58187: CALL 14804 0 3
58191: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58192: LD_VAR 0 3
58196: PPUSH
58197: CALL_OW 310
58201: IFFALSE 58212
// ComExitBuilding ( j ) ;
58203: LD_VAR 0 3
58207: PPUSH
58208: CALL_OW 122
// wait ( 3 ) ;
58212: LD_INT 3
58214: PPUSH
58215: CALL_OW 67
// if not mc_build_list [ i ] then
58219: LD_EXP 47
58223: PUSH
58224: LD_VAR 0 2
58228: ARRAY
58229: NOT
58230: IFFALSE 58234
// break ;
58232: GO 58333
// if not HasTask ( j ) then
58234: LD_VAR 0 3
58238: PPUSH
58239: CALL_OW 314
58243: NOT
58244: IFFALSE 58331
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
58246: LD_VAR 0 3
58250: PPUSH
58251: LD_EXP 47
58255: PUSH
58256: LD_VAR 0 2
58260: ARRAY
58261: PUSH
58262: LD_INT 1
58264: ARRAY
58265: PUSH
58266: LD_INT 1
58268: ARRAY
58269: PPUSH
58270: LD_EXP 47
58274: PUSH
58275: LD_VAR 0 2
58279: ARRAY
58280: PUSH
58281: LD_INT 1
58283: ARRAY
58284: PUSH
58285: LD_INT 2
58287: ARRAY
58288: PPUSH
58289: LD_EXP 47
58293: PUSH
58294: LD_VAR 0 2
58298: ARRAY
58299: PUSH
58300: LD_INT 1
58302: ARRAY
58303: PUSH
58304: LD_INT 3
58306: ARRAY
58307: PPUSH
58308: LD_EXP 47
58312: PUSH
58313: LD_VAR 0 2
58317: ARRAY
58318: PUSH
58319: LD_INT 1
58321: ARRAY
58322: PUSH
58323: LD_INT 4
58325: ARRAY
58326: PPUSH
58327: CALL_OW 145
// end ;
58331: GO 58120
58333: POP
58334: POP
// end else
58335: GO 58479
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
58337: LD_EXP 42
58341: PUSH
58342: LD_VAR 0 2
58346: ARRAY
58347: PPUSH
58348: LD_EXP 47
58352: PUSH
58353: LD_VAR 0 2
58357: ARRAY
58358: PUSH
58359: LD_INT 1
58361: ARRAY
58362: PUSH
58363: LD_INT 1
58365: ARRAY
58366: PPUSH
58367: LD_EXP 47
58371: PUSH
58372: LD_VAR 0 2
58376: ARRAY
58377: PUSH
58378: LD_INT 1
58380: ARRAY
58381: PUSH
58382: LD_INT 2
58384: ARRAY
58385: PPUSH
58386: LD_EXP 47
58390: PUSH
58391: LD_VAR 0 2
58395: ARRAY
58396: PUSH
58397: LD_INT 1
58399: ARRAY
58400: PUSH
58401: LD_INT 3
58403: ARRAY
58404: PPUSH
58405: LD_EXP 47
58409: PUSH
58410: LD_VAR 0 2
58414: ARRAY
58415: PUSH
58416: LD_INT 1
58418: ARRAY
58419: PUSH
58420: LD_INT 4
58422: ARRAY
58423: PPUSH
58424: CALL 21555 0 5
58428: NOT
58429: IFFALSE 58479
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
58431: LD_ADDR_EXP 47
58435: PUSH
58436: LD_EXP 47
58440: PPUSH
58441: LD_VAR 0 2
58445: PPUSH
58446: LD_EXP 47
58450: PUSH
58451: LD_VAR 0 2
58455: ARRAY
58456: PPUSH
58457: LD_INT 1
58459: PPUSH
58460: LD_INT 1
58462: NEG
58463: PPUSH
58464: LD_INT 0
58466: PPUSH
58467: CALL 14222 0 4
58471: PPUSH
58472: CALL_OW 1
58476: ST_TO_ADDR
// continue ;
58477: GO 57355
// end ; end ; end ;
58479: GO 57355
58481: POP
58482: POP
// end ;
58483: LD_VAR 0 1
58487: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
58488: LD_INT 0
58490: PPUSH
58491: PPUSH
58492: PPUSH
58493: PPUSH
58494: PPUSH
58495: PPUSH
// if not mc_bases then
58496: LD_EXP 42
58500: NOT
58501: IFFALSE 58505
// exit ;
58503: GO 58932
// for i = 1 to mc_bases do
58505: LD_ADDR_VAR 0 2
58509: PUSH
58510: DOUBLE
58511: LD_INT 1
58513: DEC
58514: ST_TO_ADDR
58515: LD_EXP 42
58519: PUSH
58520: FOR_TO
58521: IFFALSE 58930
// begin tmp := mc_build_upgrade [ i ] ;
58523: LD_ADDR_VAR 0 4
58527: PUSH
58528: LD_EXP 74
58532: PUSH
58533: LD_VAR 0 2
58537: ARRAY
58538: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
58539: LD_ADDR_VAR 0 6
58543: PUSH
58544: LD_EXP 75
58548: PUSH
58549: LD_VAR 0 2
58553: ARRAY
58554: PPUSH
58555: LD_INT 2
58557: PUSH
58558: LD_INT 30
58560: PUSH
58561: LD_INT 6
58563: PUSH
58564: EMPTY
58565: LIST
58566: LIST
58567: PUSH
58568: LD_INT 30
58570: PUSH
58571: LD_INT 7
58573: PUSH
58574: EMPTY
58575: LIST
58576: LIST
58577: PUSH
58578: EMPTY
58579: LIST
58580: LIST
58581: LIST
58582: PPUSH
58583: CALL_OW 72
58587: ST_TO_ADDR
// if not tmp and not lab then
58588: LD_VAR 0 4
58592: NOT
58593: PUSH
58594: LD_VAR 0 6
58598: NOT
58599: AND
58600: IFFALSE 58604
// continue ;
58602: GO 58520
// if tmp then
58604: LD_VAR 0 4
58608: IFFALSE 58728
// for j in tmp do
58610: LD_ADDR_VAR 0 3
58614: PUSH
58615: LD_VAR 0 4
58619: PUSH
58620: FOR_IN
58621: IFFALSE 58726
// begin if UpgradeCost ( j ) then
58623: LD_VAR 0 3
58627: PPUSH
58628: CALL 21215 0 1
58632: IFFALSE 58724
// begin ComUpgrade ( j ) ;
58634: LD_VAR 0 3
58638: PPUSH
58639: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
58643: LD_ADDR_EXP 74
58647: PUSH
58648: LD_EXP 74
58652: PPUSH
58653: LD_VAR 0 2
58657: PPUSH
58658: LD_EXP 74
58662: PUSH
58663: LD_VAR 0 2
58667: ARRAY
58668: PUSH
58669: LD_VAR 0 3
58673: DIFF
58674: PPUSH
58675: CALL_OW 1
58679: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58680: LD_ADDR_EXP 49
58684: PUSH
58685: LD_EXP 49
58689: PPUSH
58690: LD_VAR 0 2
58694: PUSH
58695: LD_EXP 49
58699: PUSH
58700: LD_VAR 0 2
58704: ARRAY
58705: PUSH
58706: LD_INT 1
58708: PLUS
58709: PUSH
58710: EMPTY
58711: LIST
58712: LIST
58713: PPUSH
58714: LD_VAR 0 3
58718: PPUSH
58719: CALL 14804 0 3
58723: ST_TO_ADDR
// end ; end ;
58724: GO 58620
58726: POP
58727: POP
// if not lab or not mc_lab_upgrade [ i ] then
58728: LD_VAR 0 6
58732: NOT
58733: PUSH
58734: LD_EXP 76
58738: PUSH
58739: LD_VAR 0 2
58743: ARRAY
58744: NOT
58745: OR
58746: IFFALSE 58750
// continue ;
58748: GO 58520
// for j in lab do
58750: LD_ADDR_VAR 0 3
58754: PUSH
58755: LD_VAR 0 6
58759: PUSH
58760: FOR_IN
58761: IFFALSE 58926
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
58763: LD_VAR 0 3
58767: PPUSH
58768: CALL_OW 266
58772: PUSH
58773: LD_INT 6
58775: PUSH
58776: LD_INT 7
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: IN
58783: PUSH
58784: LD_VAR 0 3
58788: PPUSH
58789: CALL_OW 461
58793: PUSH
58794: LD_INT 1
58796: NONEQUAL
58797: AND
58798: IFFALSE 58924
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
58800: LD_VAR 0 3
58804: PPUSH
58805: LD_EXP 76
58809: PUSH
58810: LD_VAR 0 2
58814: ARRAY
58815: PUSH
58816: LD_INT 1
58818: ARRAY
58819: PPUSH
58820: CALL 21420 0 2
58824: IFFALSE 58924
// begin ComCancel ( j ) ;
58826: LD_VAR 0 3
58830: PPUSH
58831: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
58835: LD_VAR 0 3
58839: PPUSH
58840: LD_EXP 76
58844: PUSH
58845: LD_VAR 0 2
58849: ARRAY
58850: PUSH
58851: LD_INT 1
58853: ARRAY
58854: PPUSH
58855: CALL_OW 207
// if not j in mc_construct_list [ i ] then
58859: LD_VAR 0 3
58863: PUSH
58864: LD_EXP 49
58868: PUSH
58869: LD_VAR 0 2
58873: ARRAY
58874: IN
58875: NOT
58876: IFFALSE 58922
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58878: LD_ADDR_EXP 49
58882: PUSH
58883: LD_EXP 49
58887: PPUSH
58888: LD_VAR 0 2
58892: PUSH
58893: LD_EXP 49
58897: PUSH
58898: LD_VAR 0 2
58902: ARRAY
58903: PUSH
58904: LD_INT 1
58906: PLUS
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: PPUSH
58912: LD_VAR 0 3
58916: PPUSH
58917: CALL 14804 0 3
58921: ST_TO_ADDR
// break ;
58922: GO 58926
// end ; end ; end ;
58924: GO 58760
58926: POP
58927: POP
// end ;
58928: GO 58520
58930: POP
58931: POP
// end ;
58932: LD_VAR 0 1
58936: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
58937: LD_INT 0
58939: PPUSH
58940: PPUSH
58941: PPUSH
58942: PPUSH
58943: PPUSH
58944: PPUSH
58945: PPUSH
58946: PPUSH
58947: PPUSH
// if not mc_bases then
58948: LD_EXP 42
58952: NOT
58953: IFFALSE 58957
// exit ;
58955: GO 59362
// for i = 1 to mc_bases do
58957: LD_ADDR_VAR 0 2
58961: PUSH
58962: DOUBLE
58963: LD_INT 1
58965: DEC
58966: ST_TO_ADDR
58967: LD_EXP 42
58971: PUSH
58972: FOR_TO
58973: IFFALSE 59360
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
58975: LD_EXP 50
58979: PUSH
58980: LD_VAR 0 2
58984: ARRAY
58985: NOT
58986: PUSH
58987: LD_EXP 42
58991: PUSH
58992: LD_VAR 0 2
58996: ARRAY
58997: PPUSH
58998: LD_INT 30
59000: PUSH
59001: LD_INT 3
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: PPUSH
59008: CALL_OW 72
59012: NOT
59013: OR
59014: IFFALSE 59018
// continue ;
59016: GO 58972
// busy := false ;
59018: LD_ADDR_VAR 0 8
59022: PUSH
59023: LD_INT 0
59025: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59026: LD_ADDR_VAR 0 4
59030: PUSH
59031: LD_EXP 42
59035: PUSH
59036: LD_VAR 0 2
59040: ARRAY
59041: PPUSH
59042: LD_INT 30
59044: PUSH
59045: LD_INT 3
59047: PUSH
59048: EMPTY
59049: LIST
59050: LIST
59051: PPUSH
59052: CALL_OW 72
59056: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
59057: LD_ADDR_VAR 0 6
59061: PUSH
59062: LD_EXP 50
59066: PUSH
59067: LD_VAR 0 2
59071: ARRAY
59072: PPUSH
59073: LD_INT 2
59075: PUSH
59076: LD_INT 30
59078: PUSH
59079: LD_INT 32
59081: PUSH
59082: EMPTY
59083: LIST
59084: LIST
59085: PUSH
59086: LD_INT 30
59088: PUSH
59089: LD_INT 33
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: LIST
59100: PPUSH
59101: CALL_OW 72
59105: ST_TO_ADDR
// if not t then
59106: LD_VAR 0 6
59110: NOT
59111: IFFALSE 59115
// continue ;
59113: GO 58972
// for j in tmp do
59115: LD_ADDR_VAR 0 3
59119: PUSH
59120: LD_VAR 0 4
59124: PUSH
59125: FOR_IN
59126: IFFALSE 59156
// if not BuildingStatus ( j ) = bs_idle then
59128: LD_VAR 0 3
59132: PPUSH
59133: CALL_OW 461
59137: PUSH
59138: LD_INT 2
59140: EQUAL
59141: NOT
59142: IFFALSE 59154
// begin busy := true ;
59144: LD_ADDR_VAR 0 8
59148: PUSH
59149: LD_INT 1
59151: ST_TO_ADDR
// break ;
59152: GO 59156
// end ;
59154: GO 59125
59156: POP
59157: POP
// if busy then
59158: LD_VAR 0 8
59162: IFFALSE 59166
// continue ;
59164: GO 58972
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
59166: LD_ADDR_VAR 0 7
59170: PUSH
59171: LD_VAR 0 6
59175: PPUSH
59176: LD_INT 35
59178: PUSH
59179: LD_INT 0
59181: PUSH
59182: EMPTY
59183: LIST
59184: LIST
59185: PPUSH
59186: CALL_OW 72
59190: ST_TO_ADDR
// if tw then
59191: LD_VAR 0 7
59195: IFFALSE 59272
// begin tw := tw [ 1 ] ;
59197: LD_ADDR_VAR 0 7
59201: PUSH
59202: LD_VAR 0 7
59206: PUSH
59207: LD_INT 1
59209: ARRAY
59210: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
59211: LD_ADDR_VAR 0 9
59215: PUSH
59216: LD_VAR 0 7
59220: PPUSH
59221: LD_EXP 67
59225: PUSH
59226: LD_VAR 0 2
59230: ARRAY
59231: PPUSH
59232: CALL 19774 0 2
59236: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
59237: LD_EXP 81
59241: PUSH
59242: LD_VAR 0 2
59246: ARRAY
59247: IFFALSE 59270
// if not weapon in mc_allowed_tower_weapons [ i ] then
59249: LD_VAR 0 9
59253: PUSH
59254: LD_EXP 81
59258: PUSH
59259: LD_VAR 0 2
59263: ARRAY
59264: IN
59265: NOT
59266: IFFALSE 59270
// continue ;
59268: GO 58972
// end else
59270: GO 59335
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
59272: LD_ADDR_VAR 0 5
59276: PUSH
59277: LD_EXP 50
59281: PUSH
59282: LD_VAR 0 2
59286: ARRAY
59287: PPUSH
59288: LD_VAR 0 4
59292: PPUSH
59293: CALL 45395 0 2
59297: ST_TO_ADDR
// if not tmp2 then
59298: LD_VAR 0 5
59302: NOT
59303: IFFALSE 59307
// continue ;
59305: GO 58972
// tw := tmp2 [ 1 ] ;
59307: LD_ADDR_VAR 0 7
59311: PUSH
59312: LD_VAR 0 5
59316: PUSH
59317: LD_INT 1
59319: ARRAY
59320: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
59321: LD_ADDR_VAR 0 9
59325: PUSH
59326: LD_VAR 0 5
59330: PUSH
59331: LD_INT 2
59333: ARRAY
59334: ST_TO_ADDR
// end ; if not weapon then
59335: LD_VAR 0 9
59339: NOT
59340: IFFALSE 59344
// continue ;
59342: GO 58972
// ComPlaceWeapon ( tw , weapon ) ;
59344: LD_VAR 0 7
59348: PPUSH
59349: LD_VAR 0 9
59353: PPUSH
59354: CALL_OW 148
// end ;
59358: GO 58972
59360: POP
59361: POP
// end ;
59362: LD_VAR 0 1
59366: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
59367: LD_INT 0
59369: PPUSH
59370: PPUSH
59371: PPUSH
59372: PPUSH
59373: PPUSH
59374: PPUSH
// if not mc_bases then
59375: LD_EXP 42
59379: NOT
59380: IFFALSE 59384
// exit ;
59382: GO 60160
// for i = 1 to mc_bases do
59384: LD_ADDR_VAR 0 2
59388: PUSH
59389: DOUBLE
59390: LD_INT 1
59392: DEC
59393: ST_TO_ADDR
59394: LD_EXP 42
59398: PUSH
59399: FOR_TO
59400: IFFALSE 60158
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
59402: LD_EXP 55
59406: PUSH
59407: LD_VAR 0 2
59411: ARRAY
59412: NOT
59413: PUSH
59414: LD_EXP 55
59418: PUSH
59419: LD_VAR 0 2
59423: ARRAY
59424: PUSH
59425: LD_EXP 56
59429: PUSH
59430: LD_VAR 0 2
59434: ARRAY
59435: EQUAL
59436: OR
59437: PUSH
59438: LD_EXP 65
59442: PUSH
59443: LD_VAR 0 2
59447: ARRAY
59448: OR
59449: IFFALSE 59453
// continue ;
59451: GO 59399
// if mc_miners [ i ] then
59453: LD_EXP 56
59457: PUSH
59458: LD_VAR 0 2
59462: ARRAY
59463: IFFALSE 59845
// begin for j = mc_miners [ i ] downto 1 do
59465: LD_ADDR_VAR 0 3
59469: PUSH
59470: DOUBLE
59471: LD_EXP 56
59475: PUSH
59476: LD_VAR 0 2
59480: ARRAY
59481: INC
59482: ST_TO_ADDR
59483: LD_INT 1
59485: PUSH
59486: FOR_DOWNTO
59487: IFFALSE 59843
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
59489: LD_EXP 56
59493: PUSH
59494: LD_VAR 0 2
59498: ARRAY
59499: PUSH
59500: LD_VAR 0 3
59504: ARRAY
59505: PPUSH
59506: CALL_OW 301
59510: PUSH
59511: LD_EXP 56
59515: PUSH
59516: LD_VAR 0 2
59520: ARRAY
59521: PUSH
59522: LD_VAR 0 3
59526: ARRAY
59527: PPUSH
59528: CALL_OW 257
59532: PUSH
59533: LD_INT 1
59535: NONEQUAL
59536: OR
59537: IFFALSE 59600
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
59539: LD_ADDR_VAR 0 5
59543: PUSH
59544: LD_EXP 56
59548: PUSH
59549: LD_VAR 0 2
59553: ARRAY
59554: PUSH
59555: LD_EXP 56
59559: PUSH
59560: LD_VAR 0 2
59564: ARRAY
59565: PUSH
59566: LD_VAR 0 3
59570: ARRAY
59571: DIFF
59572: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
59573: LD_ADDR_EXP 56
59577: PUSH
59578: LD_EXP 56
59582: PPUSH
59583: LD_VAR 0 2
59587: PPUSH
59588: LD_VAR 0 5
59592: PPUSH
59593: CALL_OW 1
59597: ST_TO_ADDR
// continue ;
59598: GO 59486
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
59600: LD_EXP 56
59604: PUSH
59605: LD_VAR 0 2
59609: ARRAY
59610: PUSH
59611: LD_VAR 0 3
59615: ARRAY
59616: PPUSH
59617: CALL_OW 257
59621: PUSH
59622: LD_INT 1
59624: EQUAL
59625: PUSH
59626: LD_EXP 56
59630: PUSH
59631: LD_VAR 0 2
59635: ARRAY
59636: PUSH
59637: LD_VAR 0 3
59641: ARRAY
59642: PPUSH
59643: CALL_OW 459
59647: NOT
59648: AND
59649: PUSH
59650: LD_EXP 56
59654: PUSH
59655: LD_VAR 0 2
59659: ARRAY
59660: PUSH
59661: LD_VAR 0 3
59665: ARRAY
59666: PPUSH
59667: CALL_OW 314
59671: NOT
59672: AND
59673: IFFALSE 59841
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
59675: LD_EXP 56
59679: PUSH
59680: LD_VAR 0 2
59684: ARRAY
59685: PUSH
59686: LD_VAR 0 3
59690: ARRAY
59691: PPUSH
59692: CALL_OW 310
59696: IFFALSE 59719
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
59698: LD_EXP 56
59702: PUSH
59703: LD_VAR 0 2
59707: ARRAY
59708: PUSH
59709: LD_VAR 0 3
59713: ARRAY
59714: PPUSH
59715: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
59719: LD_EXP 56
59723: PUSH
59724: LD_VAR 0 2
59728: ARRAY
59729: PUSH
59730: LD_VAR 0 3
59734: ARRAY
59735: PPUSH
59736: CALL_OW 314
59740: NOT
59741: IFFALSE 59841
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
59743: LD_EXP 56
59747: PUSH
59748: LD_VAR 0 2
59752: ARRAY
59753: PUSH
59754: LD_VAR 0 3
59758: ARRAY
59759: PPUSH
59760: LD_EXP 55
59764: PUSH
59765: LD_VAR 0 2
59769: ARRAY
59770: PUSH
59771: LD_VAR 0 3
59775: PUSH
59776: LD_EXP 55
59780: PUSH
59781: LD_VAR 0 2
59785: ARRAY
59786: MOD
59787: PUSH
59788: LD_INT 1
59790: PLUS
59791: ARRAY
59792: PUSH
59793: LD_INT 1
59795: ARRAY
59796: PPUSH
59797: LD_EXP 55
59801: PUSH
59802: LD_VAR 0 2
59806: ARRAY
59807: PUSH
59808: LD_VAR 0 3
59812: PUSH
59813: LD_EXP 55
59817: PUSH
59818: LD_VAR 0 2
59822: ARRAY
59823: MOD
59824: PUSH
59825: LD_INT 1
59827: PLUS
59828: ARRAY
59829: PUSH
59830: LD_INT 2
59832: ARRAY
59833: PPUSH
59834: LD_INT 0
59836: PPUSH
59837: CALL_OW 193
// end ; end ;
59841: GO 59486
59843: POP
59844: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
59845: LD_ADDR_VAR 0 5
59849: PUSH
59850: LD_EXP 42
59854: PUSH
59855: LD_VAR 0 2
59859: ARRAY
59860: PPUSH
59861: LD_INT 2
59863: PUSH
59864: LD_INT 30
59866: PUSH
59867: LD_INT 4
59869: PUSH
59870: EMPTY
59871: LIST
59872: LIST
59873: PUSH
59874: LD_INT 30
59876: PUSH
59877: LD_INT 5
59879: PUSH
59880: EMPTY
59881: LIST
59882: LIST
59883: PUSH
59884: LD_INT 30
59886: PUSH
59887: LD_INT 32
59889: PUSH
59890: EMPTY
59891: LIST
59892: LIST
59893: PUSH
59894: EMPTY
59895: LIST
59896: LIST
59897: LIST
59898: LIST
59899: PPUSH
59900: CALL_OW 72
59904: ST_TO_ADDR
// if not tmp then
59905: LD_VAR 0 5
59909: NOT
59910: IFFALSE 59914
// continue ;
59912: GO 59399
// list := [ ] ;
59914: LD_ADDR_VAR 0 6
59918: PUSH
59919: EMPTY
59920: ST_TO_ADDR
// for j in tmp do
59921: LD_ADDR_VAR 0 3
59925: PUSH
59926: LD_VAR 0 5
59930: PUSH
59931: FOR_IN
59932: IFFALSE 60001
// begin for k in UnitsInside ( j ) do
59934: LD_ADDR_VAR 0 4
59938: PUSH
59939: LD_VAR 0 3
59943: PPUSH
59944: CALL_OW 313
59948: PUSH
59949: FOR_IN
59950: IFFALSE 59997
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
59952: LD_VAR 0 4
59956: PPUSH
59957: CALL_OW 257
59961: PUSH
59962: LD_INT 1
59964: EQUAL
59965: PUSH
59966: LD_VAR 0 4
59970: PPUSH
59971: CALL_OW 459
59975: NOT
59976: AND
59977: IFFALSE 59995
// list := list ^ k ;
59979: LD_ADDR_VAR 0 6
59983: PUSH
59984: LD_VAR 0 6
59988: PUSH
59989: LD_VAR 0 4
59993: ADD
59994: ST_TO_ADDR
59995: GO 59949
59997: POP
59998: POP
// end ;
59999: GO 59931
60001: POP
60002: POP
// list := list diff mc_miners [ i ] ;
60003: LD_ADDR_VAR 0 6
60007: PUSH
60008: LD_VAR 0 6
60012: PUSH
60013: LD_EXP 56
60017: PUSH
60018: LD_VAR 0 2
60022: ARRAY
60023: DIFF
60024: ST_TO_ADDR
// if not list then
60025: LD_VAR 0 6
60029: NOT
60030: IFFALSE 60034
// continue ;
60032: GO 59399
// k := mc_mines [ i ] - mc_miners [ i ] ;
60034: LD_ADDR_VAR 0 4
60038: PUSH
60039: LD_EXP 55
60043: PUSH
60044: LD_VAR 0 2
60048: ARRAY
60049: PUSH
60050: LD_EXP 56
60054: PUSH
60055: LD_VAR 0 2
60059: ARRAY
60060: MINUS
60061: ST_TO_ADDR
// if k > list then
60062: LD_VAR 0 4
60066: PUSH
60067: LD_VAR 0 6
60071: GREATER
60072: IFFALSE 60084
// k := list ;
60074: LD_ADDR_VAR 0 4
60078: PUSH
60079: LD_VAR 0 6
60083: ST_TO_ADDR
// for j = 1 to k do
60084: LD_ADDR_VAR 0 3
60088: PUSH
60089: DOUBLE
60090: LD_INT 1
60092: DEC
60093: ST_TO_ADDR
60094: LD_VAR 0 4
60098: PUSH
60099: FOR_TO
60100: IFFALSE 60154
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
60102: LD_ADDR_EXP 56
60106: PUSH
60107: LD_EXP 56
60111: PPUSH
60112: LD_VAR 0 2
60116: PUSH
60117: LD_EXP 56
60121: PUSH
60122: LD_VAR 0 2
60126: ARRAY
60127: PUSH
60128: LD_INT 1
60130: PLUS
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PPUSH
60136: LD_VAR 0 6
60140: PUSH
60141: LD_VAR 0 3
60145: ARRAY
60146: PPUSH
60147: CALL 14804 0 3
60151: ST_TO_ADDR
60152: GO 60099
60154: POP
60155: POP
// end ;
60156: GO 59399
60158: POP
60159: POP
// end ;
60160: LD_VAR 0 1
60164: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
60165: LD_INT 0
60167: PPUSH
60168: PPUSH
60169: PPUSH
60170: PPUSH
60171: PPUSH
60172: PPUSH
60173: PPUSH
60174: PPUSH
60175: PPUSH
60176: PPUSH
// if not mc_bases then
60177: LD_EXP 42
60181: NOT
60182: IFFALSE 60186
// exit ;
60184: GO 61936
// for i = 1 to mc_bases do
60186: LD_ADDR_VAR 0 2
60190: PUSH
60191: DOUBLE
60192: LD_INT 1
60194: DEC
60195: ST_TO_ADDR
60196: LD_EXP 42
60200: PUSH
60201: FOR_TO
60202: IFFALSE 61934
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
60204: LD_EXP 42
60208: PUSH
60209: LD_VAR 0 2
60213: ARRAY
60214: NOT
60215: PUSH
60216: LD_EXP 49
60220: PUSH
60221: LD_VAR 0 2
60225: ARRAY
60226: OR
60227: IFFALSE 60231
// continue ;
60229: GO 60201
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
60231: LD_EXP 58
60235: PUSH
60236: LD_VAR 0 2
60240: ARRAY
60241: NOT
60242: PUSH
60243: LD_EXP 59
60247: PUSH
60248: LD_VAR 0 2
60252: ARRAY
60253: AND
60254: IFFALSE 60292
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60256: LD_ADDR_EXP 59
60260: PUSH
60261: LD_EXP 59
60265: PPUSH
60266: LD_VAR 0 2
60270: PPUSH
60271: EMPTY
60272: PPUSH
60273: CALL_OW 1
60277: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
60278: LD_VAR 0 2
60282: PPUSH
60283: LD_INT 107
60285: PPUSH
60286: CALL 51140 0 2
// continue ;
60290: GO 60201
// end ; target := [ ] ;
60292: LD_ADDR_VAR 0 6
60296: PUSH
60297: EMPTY
60298: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
60299: LD_ADDR_VAR 0 3
60303: PUSH
60304: DOUBLE
60305: LD_EXP 58
60309: PUSH
60310: LD_VAR 0 2
60314: ARRAY
60315: INC
60316: ST_TO_ADDR
60317: LD_INT 1
60319: PUSH
60320: FOR_DOWNTO
60321: IFFALSE 60581
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
60323: LD_EXP 58
60327: PUSH
60328: LD_VAR 0 2
60332: ARRAY
60333: PUSH
60334: LD_VAR 0 3
60338: ARRAY
60339: PUSH
60340: LD_INT 2
60342: ARRAY
60343: PPUSH
60344: LD_EXP 58
60348: PUSH
60349: LD_VAR 0 2
60353: ARRAY
60354: PUSH
60355: LD_VAR 0 3
60359: ARRAY
60360: PUSH
60361: LD_INT 3
60363: ARRAY
60364: PPUSH
60365: CALL_OW 488
60369: PUSH
60370: LD_EXP 58
60374: PUSH
60375: LD_VAR 0 2
60379: ARRAY
60380: PUSH
60381: LD_VAR 0 3
60385: ARRAY
60386: PUSH
60387: LD_INT 2
60389: ARRAY
60390: PPUSH
60391: LD_EXP 58
60395: PUSH
60396: LD_VAR 0 2
60400: ARRAY
60401: PUSH
60402: LD_VAR 0 3
60406: ARRAY
60407: PUSH
60408: LD_INT 3
60410: ARRAY
60411: PPUSH
60412: CALL_OW 284
60416: PUSH
60417: LD_INT 0
60419: EQUAL
60420: AND
60421: IFFALSE 60476
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
60423: LD_ADDR_VAR 0 5
60427: PUSH
60428: LD_EXP 58
60432: PUSH
60433: LD_VAR 0 2
60437: ARRAY
60438: PPUSH
60439: LD_VAR 0 3
60443: PPUSH
60444: CALL_OW 3
60448: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
60449: LD_ADDR_EXP 58
60453: PUSH
60454: LD_EXP 58
60458: PPUSH
60459: LD_VAR 0 2
60463: PPUSH
60464: LD_VAR 0 5
60468: PPUSH
60469: CALL_OW 1
60473: ST_TO_ADDR
// continue ;
60474: GO 60320
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
60476: LD_EXP 42
60480: PUSH
60481: LD_VAR 0 2
60485: ARRAY
60486: PUSH
60487: LD_INT 1
60489: ARRAY
60490: PPUSH
60491: CALL_OW 255
60495: PPUSH
60496: LD_EXP 58
60500: PUSH
60501: LD_VAR 0 2
60505: ARRAY
60506: PUSH
60507: LD_VAR 0 3
60511: ARRAY
60512: PUSH
60513: LD_INT 2
60515: ARRAY
60516: PPUSH
60517: LD_EXP 58
60521: PUSH
60522: LD_VAR 0 2
60526: ARRAY
60527: PUSH
60528: LD_VAR 0 3
60532: ARRAY
60533: PUSH
60534: LD_INT 3
60536: ARRAY
60537: PPUSH
60538: LD_INT 30
60540: PPUSH
60541: CALL 15700 0 4
60545: PUSH
60546: LD_INT 4
60548: ARRAY
60549: PUSH
60550: LD_INT 0
60552: EQUAL
60553: IFFALSE 60579
// begin target := mc_crates [ i ] [ j ] ;
60555: LD_ADDR_VAR 0 6
60559: PUSH
60560: LD_EXP 58
60564: PUSH
60565: LD_VAR 0 2
60569: ARRAY
60570: PUSH
60571: LD_VAR 0 3
60575: ARRAY
60576: ST_TO_ADDR
// break ;
60577: GO 60581
// end ; end ;
60579: GO 60320
60581: POP
60582: POP
// if not target then
60583: LD_VAR 0 6
60587: NOT
60588: IFFALSE 60592
// continue ;
60590: GO 60201
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
60592: LD_ADDR_VAR 0 7
60596: PUSH
60597: LD_EXP 61
60601: PUSH
60602: LD_VAR 0 2
60606: ARRAY
60607: PPUSH
60608: LD_INT 2
60610: PUSH
60611: LD_INT 3
60613: PUSH
60614: LD_INT 58
60616: PUSH
60617: EMPTY
60618: LIST
60619: PUSH
60620: EMPTY
60621: LIST
60622: LIST
60623: PUSH
60624: LD_INT 61
60626: PUSH
60627: EMPTY
60628: LIST
60629: PUSH
60630: LD_INT 33
60632: PUSH
60633: LD_INT 5
60635: PUSH
60636: EMPTY
60637: LIST
60638: LIST
60639: PUSH
60640: LD_INT 33
60642: PUSH
60643: LD_INT 3
60645: PUSH
60646: EMPTY
60647: LIST
60648: LIST
60649: PUSH
60650: EMPTY
60651: LIST
60652: LIST
60653: LIST
60654: LIST
60655: LIST
60656: PUSH
60657: LD_INT 2
60659: PUSH
60660: LD_INT 34
60662: PUSH
60663: LD_INT 32
60665: PUSH
60666: EMPTY
60667: LIST
60668: LIST
60669: PUSH
60670: LD_INT 34
60672: PUSH
60673: LD_INT 51
60675: PUSH
60676: EMPTY
60677: LIST
60678: LIST
60679: PUSH
60680: LD_INT 34
60682: PUSH
60683: LD_INT 12
60685: PUSH
60686: EMPTY
60687: LIST
60688: LIST
60689: PUSH
60690: EMPTY
60691: LIST
60692: LIST
60693: LIST
60694: LIST
60695: PUSH
60696: EMPTY
60697: LIST
60698: LIST
60699: PPUSH
60700: CALL_OW 72
60704: ST_TO_ADDR
// if not cargo then
60705: LD_VAR 0 7
60709: NOT
60710: IFFALSE 61353
// begin if mc_crates_collector [ i ] < 5 then
60712: LD_EXP 59
60716: PUSH
60717: LD_VAR 0 2
60721: ARRAY
60722: PUSH
60723: LD_INT 5
60725: LESS
60726: IFFALSE 61092
// begin if mc_ape [ i ] then
60728: LD_EXP 71
60732: PUSH
60733: LD_VAR 0 2
60737: ARRAY
60738: IFFALSE 60785
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
60740: LD_ADDR_VAR 0 5
60744: PUSH
60745: LD_EXP 71
60749: PUSH
60750: LD_VAR 0 2
60754: ARRAY
60755: PPUSH
60756: LD_INT 25
60758: PUSH
60759: LD_INT 16
60761: PUSH
60762: EMPTY
60763: LIST
60764: LIST
60765: PUSH
60766: LD_INT 24
60768: PUSH
60769: LD_INT 750
60771: PUSH
60772: EMPTY
60773: LIST
60774: LIST
60775: PUSH
60776: EMPTY
60777: LIST
60778: LIST
60779: PPUSH
60780: CALL_OW 72
60784: ST_TO_ADDR
// if not tmp then
60785: LD_VAR 0 5
60789: NOT
60790: IFFALSE 60837
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
60792: LD_ADDR_VAR 0 5
60796: PUSH
60797: LD_EXP 42
60801: PUSH
60802: LD_VAR 0 2
60806: ARRAY
60807: PPUSH
60808: LD_INT 25
60810: PUSH
60811: LD_INT 2
60813: PUSH
60814: EMPTY
60815: LIST
60816: LIST
60817: PUSH
60818: LD_INT 24
60820: PUSH
60821: LD_INT 750
60823: PUSH
60824: EMPTY
60825: LIST
60826: LIST
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: PPUSH
60832: CALL_OW 72
60836: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
60837: LD_EXP 71
60841: PUSH
60842: LD_VAR 0 2
60846: ARRAY
60847: PUSH
60848: LD_EXP 42
60852: PUSH
60853: LD_VAR 0 2
60857: ARRAY
60858: PPUSH
60859: LD_INT 25
60861: PUSH
60862: LD_INT 2
60864: PUSH
60865: EMPTY
60866: LIST
60867: LIST
60868: PUSH
60869: LD_INT 24
60871: PUSH
60872: LD_INT 750
60874: PUSH
60875: EMPTY
60876: LIST
60877: LIST
60878: PUSH
60879: EMPTY
60880: LIST
60881: LIST
60882: PPUSH
60883: CALL_OW 72
60887: AND
60888: PUSH
60889: LD_VAR 0 5
60893: PUSH
60894: LD_INT 5
60896: LESS
60897: AND
60898: IFFALSE 60980
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
60900: LD_ADDR_VAR 0 3
60904: PUSH
60905: LD_EXP 42
60909: PUSH
60910: LD_VAR 0 2
60914: ARRAY
60915: PPUSH
60916: LD_INT 25
60918: PUSH
60919: LD_INT 2
60921: PUSH
60922: EMPTY
60923: LIST
60924: LIST
60925: PUSH
60926: LD_INT 24
60928: PUSH
60929: LD_INT 750
60931: PUSH
60932: EMPTY
60933: LIST
60934: LIST
60935: PUSH
60936: EMPTY
60937: LIST
60938: LIST
60939: PPUSH
60940: CALL_OW 72
60944: PUSH
60945: FOR_IN
60946: IFFALSE 60978
// begin tmp := tmp union j ;
60948: LD_ADDR_VAR 0 5
60952: PUSH
60953: LD_VAR 0 5
60957: PUSH
60958: LD_VAR 0 3
60962: UNION
60963: ST_TO_ADDR
// if tmp >= 5 then
60964: LD_VAR 0 5
60968: PUSH
60969: LD_INT 5
60971: GREATEREQUAL
60972: IFFALSE 60976
// break ;
60974: GO 60978
// end ;
60976: GO 60945
60978: POP
60979: POP
// end ; if not tmp then
60980: LD_VAR 0 5
60984: NOT
60985: IFFALSE 60989
// continue ;
60987: GO 60201
// for j in tmp do
60989: LD_ADDR_VAR 0 3
60993: PUSH
60994: LD_VAR 0 5
60998: PUSH
60999: FOR_IN
61000: IFFALSE 61090
// if not GetTag ( j ) then
61002: LD_VAR 0 3
61006: PPUSH
61007: CALL_OW 110
61011: NOT
61012: IFFALSE 61088
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
61014: LD_ADDR_EXP 59
61018: PUSH
61019: LD_EXP 59
61023: PPUSH
61024: LD_VAR 0 2
61028: PUSH
61029: LD_EXP 59
61033: PUSH
61034: LD_VAR 0 2
61038: ARRAY
61039: PUSH
61040: LD_INT 1
61042: PLUS
61043: PUSH
61044: EMPTY
61045: LIST
61046: LIST
61047: PPUSH
61048: LD_VAR 0 3
61052: PPUSH
61053: CALL 14804 0 3
61057: ST_TO_ADDR
// SetTag ( j , 107 ) ;
61058: LD_VAR 0 3
61062: PPUSH
61063: LD_INT 107
61065: PPUSH
61066: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
61070: LD_EXP 59
61074: PUSH
61075: LD_VAR 0 2
61079: ARRAY
61080: PUSH
61081: LD_INT 5
61083: GREATEREQUAL
61084: IFFALSE 61088
// break ;
61086: GO 61090
// end ;
61088: GO 60999
61090: POP
61091: POP
// end ; if mc_crates_collector [ i ] and target then
61092: LD_EXP 59
61096: PUSH
61097: LD_VAR 0 2
61101: ARRAY
61102: PUSH
61103: LD_VAR 0 6
61107: AND
61108: IFFALSE 61351
// begin if mc_crates_collector [ i ] < target [ 1 ] then
61110: LD_EXP 59
61114: PUSH
61115: LD_VAR 0 2
61119: ARRAY
61120: PUSH
61121: LD_VAR 0 6
61125: PUSH
61126: LD_INT 1
61128: ARRAY
61129: LESS
61130: IFFALSE 61150
// tmp := mc_crates_collector [ i ] else
61132: LD_ADDR_VAR 0 5
61136: PUSH
61137: LD_EXP 59
61141: PUSH
61142: LD_VAR 0 2
61146: ARRAY
61147: ST_TO_ADDR
61148: GO 61164
// tmp := target [ 1 ] ;
61150: LD_ADDR_VAR 0 5
61154: PUSH
61155: LD_VAR 0 6
61159: PUSH
61160: LD_INT 1
61162: ARRAY
61163: ST_TO_ADDR
// k := 0 ;
61164: LD_ADDR_VAR 0 4
61168: PUSH
61169: LD_INT 0
61171: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
61172: LD_ADDR_VAR 0 3
61176: PUSH
61177: LD_EXP 59
61181: PUSH
61182: LD_VAR 0 2
61186: ARRAY
61187: PUSH
61188: FOR_IN
61189: IFFALSE 61349
// begin k := k + 1 ;
61191: LD_ADDR_VAR 0 4
61195: PUSH
61196: LD_VAR 0 4
61200: PUSH
61201: LD_INT 1
61203: PLUS
61204: ST_TO_ADDR
// if k > tmp then
61205: LD_VAR 0 4
61209: PUSH
61210: LD_VAR 0 5
61214: GREATER
61215: IFFALSE 61219
// break ;
61217: GO 61349
// if not GetClass ( j ) in [ 2 , 16 ] then
61219: LD_VAR 0 3
61223: PPUSH
61224: CALL_OW 257
61228: PUSH
61229: LD_INT 2
61231: PUSH
61232: LD_INT 16
61234: PUSH
61235: EMPTY
61236: LIST
61237: LIST
61238: IN
61239: NOT
61240: IFFALSE 61293
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
61242: LD_ADDR_EXP 59
61246: PUSH
61247: LD_EXP 59
61251: PPUSH
61252: LD_VAR 0 2
61256: PPUSH
61257: LD_EXP 59
61261: PUSH
61262: LD_VAR 0 2
61266: ARRAY
61267: PUSH
61268: LD_VAR 0 3
61272: DIFF
61273: PPUSH
61274: CALL_OW 1
61278: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61279: LD_VAR 0 3
61283: PPUSH
61284: LD_INT 0
61286: PPUSH
61287: CALL_OW 109
// continue ;
61291: GO 61188
// end ; if IsInUnit ( j ) then
61293: LD_VAR 0 3
61297: PPUSH
61298: CALL_OW 310
61302: IFFALSE 61313
// ComExitBuilding ( j ) ;
61304: LD_VAR 0 3
61308: PPUSH
61309: CALL_OW 122
// wait ( 3 ) ;
61313: LD_INT 3
61315: PPUSH
61316: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61320: LD_VAR 0 3
61324: PPUSH
61325: LD_VAR 0 6
61329: PUSH
61330: LD_INT 2
61332: ARRAY
61333: PPUSH
61334: LD_VAR 0 6
61338: PUSH
61339: LD_INT 3
61341: ARRAY
61342: PPUSH
61343: CALL_OW 117
// end ;
61347: GO 61188
61349: POP
61350: POP
// end ; end else
61351: GO 61932
// begin for j in cargo do
61353: LD_ADDR_VAR 0 3
61357: PUSH
61358: LD_VAR 0 7
61362: PUSH
61363: FOR_IN
61364: IFFALSE 61930
// begin if GetTag ( j ) <> 0 then
61366: LD_VAR 0 3
61370: PPUSH
61371: CALL_OW 110
61375: PUSH
61376: LD_INT 0
61378: NONEQUAL
61379: IFFALSE 61383
// continue ;
61381: GO 61363
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
61383: LD_VAR 0 3
61387: PPUSH
61388: CALL_OW 256
61392: PUSH
61393: LD_INT 1000
61395: LESS
61396: PUSH
61397: LD_VAR 0 3
61401: PPUSH
61402: LD_EXP 66
61406: PUSH
61407: LD_VAR 0 2
61411: ARRAY
61412: PPUSH
61413: CALL_OW 308
61417: NOT
61418: AND
61419: IFFALSE 61441
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61421: LD_VAR 0 3
61425: PPUSH
61426: LD_EXP 66
61430: PUSH
61431: LD_VAR 0 2
61435: ARRAY
61436: PPUSH
61437: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
61441: LD_VAR 0 3
61445: PPUSH
61446: CALL_OW 256
61450: PUSH
61451: LD_INT 1000
61453: LESS
61454: PUSH
61455: LD_VAR 0 3
61459: PPUSH
61460: LD_EXP 66
61464: PUSH
61465: LD_VAR 0 2
61469: ARRAY
61470: PPUSH
61471: CALL_OW 308
61475: AND
61476: IFFALSE 61480
// continue ;
61478: GO 61363
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
61480: LD_VAR 0 3
61484: PPUSH
61485: CALL_OW 262
61489: PUSH
61490: LD_INT 2
61492: EQUAL
61493: PUSH
61494: LD_VAR 0 3
61498: PPUSH
61499: CALL_OW 261
61503: PUSH
61504: LD_INT 15
61506: LESS
61507: AND
61508: IFFALSE 61512
// continue ;
61510: GO 61363
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
61512: LD_VAR 0 3
61516: PPUSH
61517: CALL_OW 262
61521: PUSH
61522: LD_INT 1
61524: EQUAL
61525: PUSH
61526: LD_VAR 0 3
61530: PPUSH
61531: CALL_OW 261
61535: PUSH
61536: LD_INT 10
61538: LESS
61539: AND
61540: IFFALSE 61869
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61542: LD_ADDR_VAR 0 8
61546: PUSH
61547: LD_EXP 42
61551: PUSH
61552: LD_VAR 0 2
61556: ARRAY
61557: PPUSH
61558: LD_INT 2
61560: PUSH
61561: LD_INT 30
61563: PUSH
61564: LD_INT 0
61566: PUSH
61567: EMPTY
61568: LIST
61569: LIST
61570: PUSH
61571: LD_INT 30
61573: PUSH
61574: LD_INT 1
61576: PUSH
61577: EMPTY
61578: LIST
61579: LIST
61580: PUSH
61581: EMPTY
61582: LIST
61583: LIST
61584: LIST
61585: PPUSH
61586: CALL_OW 72
61590: ST_TO_ADDR
// if not depot then
61591: LD_VAR 0 8
61595: NOT
61596: IFFALSE 61600
// continue ;
61598: GO 61363
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
61600: LD_VAR 0 3
61604: PPUSH
61605: LD_VAR 0 8
61609: PPUSH
61610: LD_VAR 0 3
61614: PPUSH
61615: CALL_OW 74
61619: PPUSH
61620: CALL_OW 296
61624: PUSH
61625: LD_INT 6
61627: LESS
61628: IFFALSE 61644
// SetFuel ( j , 100 ) else
61630: LD_VAR 0 3
61634: PPUSH
61635: LD_INT 100
61637: PPUSH
61638: CALL_OW 240
61642: GO 61869
// if GetFuel ( j ) = 0 then
61644: LD_VAR 0 3
61648: PPUSH
61649: CALL_OW 261
61653: PUSH
61654: LD_INT 0
61656: EQUAL
61657: IFFALSE 61869
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
61659: LD_ADDR_EXP 61
61663: PUSH
61664: LD_EXP 61
61668: PPUSH
61669: LD_VAR 0 2
61673: PPUSH
61674: LD_EXP 61
61678: PUSH
61679: LD_VAR 0 2
61683: ARRAY
61684: PUSH
61685: LD_VAR 0 3
61689: DIFF
61690: PPUSH
61691: CALL_OW 1
61695: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
61696: LD_VAR 0 3
61700: PPUSH
61701: CALL_OW 263
61705: PUSH
61706: LD_INT 1
61708: EQUAL
61709: IFFALSE 61725
// ComExitVehicle ( IsInUnit ( j ) ) ;
61711: LD_VAR 0 3
61715: PPUSH
61716: CALL_OW 310
61720: PPUSH
61721: CALL_OW 121
// if GetControl ( j ) = control_remote then
61725: LD_VAR 0 3
61729: PPUSH
61730: CALL_OW 263
61734: PUSH
61735: LD_INT 2
61737: EQUAL
61738: IFFALSE 61749
// ComUnlink ( j ) ;
61740: LD_VAR 0 3
61744: PPUSH
61745: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
61749: LD_ADDR_VAR 0 9
61753: PUSH
61754: LD_VAR 0 2
61758: PPUSH
61759: LD_INT 3
61761: PPUSH
61762: CALL 71244 0 2
61766: ST_TO_ADDR
// if fac then
61767: LD_VAR 0 9
61771: IFFALSE 61867
// begin for k in fac do
61773: LD_ADDR_VAR 0 4
61777: PUSH
61778: LD_VAR 0 9
61782: PUSH
61783: FOR_IN
61784: IFFALSE 61865
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
61786: LD_ADDR_VAR 0 10
61790: PUSH
61791: LD_VAR 0 9
61795: PPUSH
61796: LD_VAR 0 3
61800: PPUSH
61801: CALL_OW 265
61805: PPUSH
61806: LD_VAR 0 3
61810: PPUSH
61811: CALL_OW 262
61815: PPUSH
61816: LD_VAR 0 3
61820: PPUSH
61821: CALL_OW 263
61825: PPUSH
61826: LD_VAR 0 3
61830: PPUSH
61831: CALL_OW 264
61835: PPUSH
61836: CALL 12336 0 5
61840: ST_TO_ADDR
// if components then
61841: LD_VAR 0 10
61845: IFFALSE 61863
// begin MC_InsertProduceList ( i , components ) ;
61847: LD_VAR 0 2
61851: PPUSH
61852: LD_VAR 0 10
61856: PPUSH
61857: CALL 70789 0 2
// break ;
61861: GO 61865
// end ; end ;
61863: GO 61783
61865: POP
61866: POP
// end ; continue ;
61867: GO 61363
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
61869: LD_VAR 0 3
61873: PPUSH
61874: LD_INT 1
61876: PPUSH
61877: CALL_OW 289
61881: PUSH
61882: LD_INT 100
61884: LESS
61885: PUSH
61886: LD_VAR 0 3
61890: PPUSH
61891: CALL_OW 314
61895: NOT
61896: AND
61897: IFFALSE 61926
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61899: LD_VAR 0 3
61903: PPUSH
61904: LD_VAR 0 6
61908: PUSH
61909: LD_INT 2
61911: ARRAY
61912: PPUSH
61913: LD_VAR 0 6
61917: PUSH
61918: LD_INT 3
61920: ARRAY
61921: PPUSH
61922: CALL_OW 117
// break ;
61926: GO 61930
// end ;
61928: GO 61363
61930: POP
61931: POP
// end ; end ;
61932: GO 60201
61934: POP
61935: POP
// end ;
61936: LD_VAR 0 1
61940: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
61941: LD_INT 0
61943: PPUSH
61944: PPUSH
61945: PPUSH
61946: PPUSH
// if not mc_bases then
61947: LD_EXP 42
61951: NOT
61952: IFFALSE 61956
// exit ;
61954: GO 62117
// for i = 1 to mc_bases do
61956: LD_ADDR_VAR 0 2
61960: PUSH
61961: DOUBLE
61962: LD_INT 1
61964: DEC
61965: ST_TO_ADDR
61966: LD_EXP 42
61970: PUSH
61971: FOR_TO
61972: IFFALSE 62115
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
61974: LD_ADDR_VAR 0 4
61978: PUSH
61979: LD_EXP 61
61983: PUSH
61984: LD_VAR 0 2
61988: ARRAY
61989: PUSH
61990: LD_EXP 64
61994: PUSH
61995: LD_VAR 0 2
61999: ARRAY
62000: UNION
62001: PPUSH
62002: LD_INT 33
62004: PUSH
62005: LD_INT 2
62007: PUSH
62008: EMPTY
62009: LIST
62010: LIST
62011: PPUSH
62012: CALL_OW 72
62016: ST_TO_ADDR
// if tmp then
62017: LD_VAR 0 4
62021: IFFALSE 62113
// for j in tmp do
62023: LD_ADDR_VAR 0 3
62027: PUSH
62028: LD_VAR 0 4
62032: PUSH
62033: FOR_IN
62034: IFFALSE 62111
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
62036: LD_VAR 0 3
62040: PPUSH
62041: CALL_OW 312
62045: NOT
62046: PUSH
62047: LD_VAR 0 3
62051: PPUSH
62052: CALL_OW 256
62056: PUSH
62057: LD_INT 250
62059: GREATEREQUAL
62060: AND
62061: IFFALSE 62074
// Connect ( j ) else
62063: LD_VAR 0 3
62067: PPUSH
62068: CALL 17737 0 1
62072: GO 62109
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
62074: LD_VAR 0 3
62078: PPUSH
62079: CALL_OW 256
62083: PUSH
62084: LD_INT 250
62086: LESS
62087: PUSH
62088: LD_VAR 0 3
62092: PPUSH
62093: CALL_OW 312
62097: AND
62098: IFFALSE 62109
// ComUnlink ( j ) ;
62100: LD_VAR 0 3
62104: PPUSH
62105: CALL_OW 136
62109: GO 62033
62111: POP
62112: POP
// end ;
62113: GO 61971
62115: POP
62116: POP
// end ;
62117: LD_VAR 0 1
62121: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
62122: LD_INT 0
62124: PPUSH
62125: PPUSH
62126: PPUSH
62127: PPUSH
62128: PPUSH
// if not mc_bases then
62129: LD_EXP 42
62133: NOT
62134: IFFALSE 62138
// exit ;
62136: GO 62583
// for i = 1 to mc_bases do
62138: LD_ADDR_VAR 0 2
62142: PUSH
62143: DOUBLE
62144: LD_INT 1
62146: DEC
62147: ST_TO_ADDR
62148: LD_EXP 42
62152: PUSH
62153: FOR_TO
62154: IFFALSE 62581
// begin if not mc_produce [ i ] then
62156: LD_EXP 63
62160: PUSH
62161: LD_VAR 0 2
62165: ARRAY
62166: NOT
62167: IFFALSE 62171
// continue ;
62169: GO 62153
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62171: LD_ADDR_VAR 0 5
62175: PUSH
62176: LD_EXP 42
62180: PUSH
62181: LD_VAR 0 2
62185: ARRAY
62186: PPUSH
62187: LD_INT 30
62189: PUSH
62190: LD_INT 3
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: PPUSH
62197: CALL_OW 72
62201: ST_TO_ADDR
// if not fac then
62202: LD_VAR 0 5
62206: NOT
62207: IFFALSE 62211
// continue ;
62209: GO 62153
// for j in fac do
62211: LD_ADDR_VAR 0 3
62215: PUSH
62216: LD_VAR 0 5
62220: PUSH
62221: FOR_IN
62222: IFFALSE 62577
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
62224: LD_VAR 0 3
62228: PPUSH
62229: CALL_OW 461
62233: PUSH
62234: LD_INT 2
62236: NONEQUAL
62237: PUSH
62238: LD_VAR 0 3
62242: PPUSH
62243: LD_INT 15
62245: PPUSH
62246: CALL 17397 0 2
62250: PUSH
62251: LD_INT 4
62253: ARRAY
62254: OR
62255: IFFALSE 62259
// continue ;
62257: GO 62221
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
62259: LD_VAR 0 3
62263: PPUSH
62264: LD_EXP 63
62268: PUSH
62269: LD_VAR 0 2
62273: ARRAY
62274: PUSH
62275: LD_INT 1
62277: ARRAY
62278: PUSH
62279: LD_INT 1
62281: ARRAY
62282: PPUSH
62283: LD_EXP 63
62287: PUSH
62288: LD_VAR 0 2
62292: ARRAY
62293: PUSH
62294: LD_INT 1
62296: ARRAY
62297: PUSH
62298: LD_INT 2
62300: ARRAY
62301: PPUSH
62302: LD_EXP 63
62306: PUSH
62307: LD_VAR 0 2
62311: ARRAY
62312: PUSH
62313: LD_INT 1
62315: ARRAY
62316: PUSH
62317: LD_INT 3
62319: ARRAY
62320: PPUSH
62321: LD_EXP 63
62325: PUSH
62326: LD_VAR 0 2
62330: ARRAY
62331: PUSH
62332: LD_INT 1
62334: ARRAY
62335: PUSH
62336: LD_INT 4
62338: ARRAY
62339: PPUSH
62340: CALL_OW 448
62344: PUSH
62345: LD_VAR 0 3
62349: PPUSH
62350: LD_EXP 63
62354: PUSH
62355: LD_VAR 0 2
62359: ARRAY
62360: PUSH
62361: LD_INT 1
62363: ARRAY
62364: PUSH
62365: LD_INT 1
62367: ARRAY
62368: PUSH
62369: LD_EXP 63
62373: PUSH
62374: LD_VAR 0 2
62378: ARRAY
62379: PUSH
62380: LD_INT 1
62382: ARRAY
62383: PUSH
62384: LD_INT 2
62386: ARRAY
62387: PUSH
62388: LD_EXP 63
62392: PUSH
62393: LD_VAR 0 2
62397: ARRAY
62398: PUSH
62399: LD_INT 1
62401: ARRAY
62402: PUSH
62403: LD_INT 3
62405: ARRAY
62406: PUSH
62407: LD_EXP 63
62411: PUSH
62412: LD_VAR 0 2
62416: ARRAY
62417: PUSH
62418: LD_INT 1
62420: ARRAY
62421: PUSH
62422: LD_INT 4
62424: ARRAY
62425: PUSH
62426: EMPTY
62427: LIST
62428: LIST
62429: LIST
62430: LIST
62431: PPUSH
62432: CALL 21068 0 2
62436: AND
62437: IFFALSE 62575
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
62439: LD_VAR 0 3
62443: PPUSH
62444: LD_EXP 63
62448: PUSH
62449: LD_VAR 0 2
62453: ARRAY
62454: PUSH
62455: LD_INT 1
62457: ARRAY
62458: PUSH
62459: LD_INT 1
62461: ARRAY
62462: PPUSH
62463: LD_EXP 63
62467: PUSH
62468: LD_VAR 0 2
62472: ARRAY
62473: PUSH
62474: LD_INT 1
62476: ARRAY
62477: PUSH
62478: LD_INT 2
62480: ARRAY
62481: PPUSH
62482: LD_EXP 63
62486: PUSH
62487: LD_VAR 0 2
62491: ARRAY
62492: PUSH
62493: LD_INT 1
62495: ARRAY
62496: PUSH
62497: LD_INT 3
62499: ARRAY
62500: PPUSH
62501: LD_EXP 63
62505: PUSH
62506: LD_VAR 0 2
62510: ARRAY
62511: PUSH
62512: LD_INT 1
62514: ARRAY
62515: PUSH
62516: LD_INT 4
62518: ARRAY
62519: PPUSH
62520: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
62524: LD_ADDR_VAR 0 4
62528: PUSH
62529: LD_EXP 63
62533: PUSH
62534: LD_VAR 0 2
62538: ARRAY
62539: PPUSH
62540: LD_INT 1
62542: PPUSH
62543: CALL_OW 3
62547: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62548: LD_ADDR_EXP 63
62552: PUSH
62553: LD_EXP 63
62557: PPUSH
62558: LD_VAR 0 2
62562: PPUSH
62563: LD_VAR 0 4
62567: PPUSH
62568: CALL_OW 1
62572: ST_TO_ADDR
// break ;
62573: GO 62577
// end ; end ;
62575: GO 62221
62577: POP
62578: POP
// end ;
62579: GO 62153
62581: POP
62582: POP
// end ;
62583: LD_VAR 0 1
62587: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
62588: LD_INT 0
62590: PPUSH
62591: PPUSH
62592: PPUSH
// if not mc_bases then
62593: LD_EXP 42
62597: NOT
62598: IFFALSE 62602
// exit ;
62600: GO 62691
// for i = 1 to mc_bases do
62602: LD_ADDR_VAR 0 2
62606: PUSH
62607: DOUBLE
62608: LD_INT 1
62610: DEC
62611: ST_TO_ADDR
62612: LD_EXP 42
62616: PUSH
62617: FOR_TO
62618: IFFALSE 62689
// begin if mc_attack [ i ] then
62620: LD_EXP 62
62624: PUSH
62625: LD_VAR 0 2
62629: ARRAY
62630: IFFALSE 62687
// begin tmp := mc_attack [ i ] [ 1 ] ;
62632: LD_ADDR_VAR 0 3
62636: PUSH
62637: LD_EXP 62
62641: PUSH
62642: LD_VAR 0 2
62646: ARRAY
62647: PUSH
62648: LD_INT 1
62650: ARRAY
62651: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62652: LD_ADDR_EXP 62
62656: PUSH
62657: LD_EXP 62
62661: PPUSH
62662: LD_VAR 0 2
62666: PPUSH
62667: EMPTY
62668: PPUSH
62669: CALL_OW 1
62673: ST_TO_ADDR
// Attack ( tmp ) ;
62674: LD_VAR 0 3
62678: PPUSH
62679: CALL 77296 0 1
// exit ;
62683: POP
62684: POP
62685: GO 62691
// end ; end ;
62687: GO 62617
62689: POP
62690: POP
// end ;
62691: LD_VAR 0 1
62695: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
62696: LD_INT 0
62698: PPUSH
62699: PPUSH
62700: PPUSH
62701: PPUSH
62702: PPUSH
62703: PPUSH
62704: PPUSH
// if not mc_bases then
62705: LD_EXP 42
62709: NOT
62710: IFFALSE 62714
// exit ;
62712: GO 63318
// for i = 1 to mc_bases do
62714: LD_ADDR_VAR 0 2
62718: PUSH
62719: DOUBLE
62720: LD_INT 1
62722: DEC
62723: ST_TO_ADDR
62724: LD_EXP 42
62728: PUSH
62729: FOR_TO
62730: IFFALSE 63316
// begin if not mc_bases [ i ] then
62732: LD_EXP 42
62736: PUSH
62737: LD_VAR 0 2
62741: ARRAY
62742: NOT
62743: IFFALSE 62747
// continue ;
62745: GO 62729
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
62747: LD_ADDR_VAR 0 7
62751: PUSH
62752: LD_EXP 42
62756: PUSH
62757: LD_VAR 0 2
62761: ARRAY
62762: PUSH
62763: LD_INT 1
62765: ARRAY
62766: PPUSH
62767: CALL 11640 0 1
62771: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
62772: LD_ADDR_EXP 65
62776: PUSH
62777: LD_EXP 65
62781: PPUSH
62782: LD_VAR 0 2
62786: PPUSH
62787: LD_EXP 42
62791: PUSH
62792: LD_VAR 0 2
62796: ARRAY
62797: PUSH
62798: LD_INT 1
62800: ARRAY
62801: PPUSH
62802: CALL_OW 255
62806: PPUSH
62807: LD_EXP 67
62811: PUSH
62812: LD_VAR 0 2
62816: ARRAY
62817: PPUSH
62818: CALL 11605 0 2
62822: PPUSH
62823: CALL_OW 1
62827: ST_TO_ADDR
// if not mc_scan [ i ] then
62828: LD_EXP 65
62832: PUSH
62833: LD_VAR 0 2
62837: ARRAY
62838: NOT
62839: IFFALSE 62994
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62841: LD_ADDR_VAR 0 4
62845: PUSH
62846: LD_EXP 42
62850: PUSH
62851: LD_VAR 0 2
62855: ARRAY
62856: PPUSH
62857: LD_INT 2
62859: PUSH
62860: LD_INT 25
62862: PUSH
62863: LD_INT 5
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PUSH
62870: LD_INT 25
62872: PUSH
62873: LD_INT 8
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: LD_INT 25
62882: PUSH
62883: LD_INT 9
62885: PUSH
62886: EMPTY
62887: LIST
62888: LIST
62889: PUSH
62890: EMPTY
62891: LIST
62892: LIST
62893: LIST
62894: LIST
62895: PPUSH
62896: CALL_OW 72
62900: ST_TO_ADDR
// if not tmp then
62901: LD_VAR 0 4
62905: NOT
62906: IFFALSE 62910
// continue ;
62908: GO 62729
// for j in tmp do
62910: LD_ADDR_VAR 0 3
62914: PUSH
62915: LD_VAR 0 4
62919: PUSH
62920: FOR_IN
62921: IFFALSE 62992
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
62923: LD_VAR 0 3
62927: PPUSH
62928: CALL_OW 310
62932: PPUSH
62933: CALL_OW 266
62937: PUSH
62938: LD_INT 5
62940: EQUAL
62941: PUSH
62942: LD_VAR 0 3
62946: PPUSH
62947: CALL_OW 257
62951: PUSH
62952: LD_INT 1
62954: EQUAL
62955: AND
62956: PUSH
62957: LD_VAR 0 3
62961: PPUSH
62962: CALL_OW 459
62966: NOT
62967: AND
62968: PUSH
62969: LD_VAR 0 7
62973: AND
62974: IFFALSE 62990
// ComChangeProfession ( j , class ) ;
62976: LD_VAR 0 3
62980: PPUSH
62981: LD_VAR 0 7
62985: PPUSH
62986: CALL_OW 123
62990: GO 62920
62992: POP
62993: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
62994: LD_EXP 65
62998: PUSH
62999: LD_VAR 0 2
63003: ARRAY
63004: PUSH
63005: LD_EXP 64
63009: PUSH
63010: LD_VAR 0 2
63014: ARRAY
63015: NOT
63016: AND
63017: PUSH
63018: LD_EXP 42
63022: PUSH
63023: LD_VAR 0 2
63027: ARRAY
63028: PPUSH
63029: LD_INT 30
63031: PUSH
63032: LD_INT 32
63034: PUSH
63035: EMPTY
63036: LIST
63037: LIST
63038: PPUSH
63039: CALL_OW 72
63043: NOT
63044: AND
63045: PUSH
63046: LD_EXP 42
63050: PUSH
63051: LD_VAR 0 2
63055: ARRAY
63056: PPUSH
63057: LD_INT 2
63059: PUSH
63060: LD_INT 30
63062: PUSH
63063: LD_INT 4
63065: PUSH
63066: EMPTY
63067: LIST
63068: LIST
63069: PUSH
63070: LD_INT 30
63072: PUSH
63073: LD_INT 5
63075: PUSH
63076: EMPTY
63077: LIST
63078: LIST
63079: PUSH
63080: EMPTY
63081: LIST
63082: LIST
63083: LIST
63084: PPUSH
63085: CALL_OW 72
63089: NOT
63090: AND
63091: IFFALSE 63223
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63093: LD_ADDR_VAR 0 4
63097: PUSH
63098: LD_EXP 42
63102: PUSH
63103: LD_VAR 0 2
63107: ARRAY
63108: PPUSH
63109: LD_INT 2
63111: PUSH
63112: LD_INT 25
63114: PUSH
63115: LD_INT 1
63117: PUSH
63118: EMPTY
63119: LIST
63120: LIST
63121: PUSH
63122: LD_INT 25
63124: PUSH
63125: LD_INT 5
63127: PUSH
63128: EMPTY
63129: LIST
63130: LIST
63131: PUSH
63132: LD_INT 25
63134: PUSH
63135: LD_INT 8
63137: PUSH
63138: EMPTY
63139: LIST
63140: LIST
63141: PUSH
63142: LD_INT 25
63144: PUSH
63145: LD_INT 9
63147: PUSH
63148: EMPTY
63149: LIST
63150: LIST
63151: PUSH
63152: EMPTY
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: LIST
63158: PPUSH
63159: CALL_OW 72
63163: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
63164: LD_ADDR_VAR 0 4
63168: PUSH
63169: LD_VAR 0 4
63173: PUSH
63174: LD_VAR 0 4
63178: PPUSH
63179: LD_INT 18
63181: PPUSH
63182: CALL 43365 0 2
63186: DIFF
63187: ST_TO_ADDR
// if tmp then
63188: LD_VAR 0 4
63192: IFFALSE 63223
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
63194: LD_VAR 0 2
63198: PPUSH
63199: LD_VAR 0 4
63203: PPUSH
63204: LD_EXP 67
63208: PUSH
63209: LD_VAR 0 2
63213: ARRAY
63214: PPUSH
63215: CALL 82005 0 3
// exit ;
63219: POP
63220: POP
63221: GO 63318
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
63223: LD_EXP 65
63227: PUSH
63228: LD_VAR 0 2
63232: ARRAY
63233: PUSH
63234: LD_EXP 64
63238: PUSH
63239: LD_VAR 0 2
63243: ARRAY
63244: AND
63245: IFFALSE 63314
// begin tmp := mc_defender [ i ] ;
63247: LD_ADDR_VAR 0 4
63251: PUSH
63252: LD_EXP 64
63256: PUSH
63257: LD_VAR 0 2
63261: ARRAY
63262: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63263: LD_ADDR_EXP 64
63267: PUSH
63268: LD_EXP 64
63272: PPUSH
63273: LD_VAR 0 2
63277: PPUSH
63278: EMPTY
63279: PPUSH
63280: CALL_OW 1
63284: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
63285: LD_VAR 0 2
63289: PPUSH
63290: LD_VAR 0 4
63294: PPUSH
63295: LD_EXP 65
63299: PUSH
63300: LD_VAR 0 2
63304: ARRAY
63305: PPUSH
63306: CALL 82566 0 3
// exit ;
63310: POP
63311: POP
63312: GO 63318
// end ; end ;
63314: GO 62729
63316: POP
63317: POP
// end ;
63318: LD_VAR 0 1
63322: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
63323: LD_INT 0
63325: PPUSH
63326: PPUSH
63327: PPUSH
63328: PPUSH
63329: PPUSH
63330: PPUSH
63331: PPUSH
63332: PPUSH
63333: PPUSH
63334: PPUSH
63335: PPUSH
// if not mc_bases then
63336: LD_EXP 42
63340: NOT
63341: IFFALSE 63345
// exit ;
63343: GO 64432
// for i = 1 to mc_bases do
63345: LD_ADDR_VAR 0 2
63349: PUSH
63350: DOUBLE
63351: LD_INT 1
63353: DEC
63354: ST_TO_ADDR
63355: LD_EXP 42
63359: PUSH
63360: FOR_TO
63361: IFFALSE 64430
// begin tmp := mc_lab [ i ] ;
63363: LD_ADDR_VAR 0 6
63367: PUSH
63368: LD_EXP 75
63372: PUSH
63373: LD_VAR 0 2
63377: ARRAY
63378: ST_TO_ADDR
// if not tmp then
63379: LD_VAR 0 6
63383: NOT
63384: IFFALSE 63388
// continue ;
63386: GO 63360
// idle_lab := 0 ;
63388: LD_ADDR_VAR 0 11
63392: PUSH
63393: LD_INT 0
63395: ST_TO_ADDR
// for j in tmp do
63396: LD_ADDR_VAR 0 3
63400: PUSH
63401: LD_VAR 0 6
63405: PUSH
63406: FOR_IN
63407: IFFALSE 64426
// begin researching := false ;
63409: LD_ADDR_VAR 0 10
63413: PUSH
63414: LD_INT 0
63416: ST_TO_ADDR
// side := GetSide ( j ) ;
63417: LD_ADDR_VAR 0 4
63421: PUSH
63422: LD_VAR 0 3
63426: PPUSH
63427: CALL_OW 255
63431: ST_TO_ADDR
// if not mc_tech [ side ] then
63432: LD_EXP 69
63436: PUSH
63437: LD_VAR 0 4
63441: ARRAY
63442: NOT
63443: IFFALSE 63447
// continue ;
63445: GO 63406
// if BuildingStatus ( j ) = bs_idle then
63447: LD_VAR 0 3
63451: PPUSH
63452: CALL_OW 461
63456: PUSH
63457: LD_INT 2
63459: EQUAL
63460: IFFALSE 63648
// begin if idle_lab and UnitsInside ( j ) < 6 then
63462: LD_VAR 0 11
63466: PUSH
63467: LD_VAR 0 3
63471: PPUSH
63472: CALL_OW 313
63476: PUSH
63477: LD_INT 6
63479: LESS
63480: AND
63481: IFFALSE 63552
// begin tmp2 := UnitsInside ( idle_lab ) ;
63483: LD_ADDR_VAR 0 9
63487: PUSH
63488: LD_VAR 0 11
63492: PPUSH
63493: CALL_OW 313
63497: ST_TO_ADDR
// if tmp2 then
63498: LD_VAR 0 9
63502: IFFALSE 63544
// for x in tmp2 do
63504: LD_ADDR_VAR 0 7
63508: PUSH
63509: LD_VAR 0 9
63513: PUSH
63514: FOR_IN
63515: IFFALSE 63542
// begin ComExitBuilding ( x ) ;
63517: LD_VAR 0 7
63521: PPUSH
63522: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
63526: LD_VAR 0 7
63530: PPUSH
63531: LD_VAR 0 3
63535: PPUSH
63536: CALL_OW 180
// end ;
63540: GO 63514
63542: POP
63543: POP
// idle_lab := 0 ;
63544: LD_ADDR_VAR 0 11
63548: PUSH
63549: LD_INT 0
63551: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
63552: LD_ADDR_VAR 0 5
63556: PUSH
63557: LD_EXP 69
63561: PUSH
63562: LD_VAR 0 4
63566: ARRAY
63567: PUSH
63568: FOR_IN
63569: IFFALSE 63629
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
63571: LD_VAR 0 3
63575: PPUSH
63576: LD_VAR 0 5
63580: PPUSH
63581: CALL_OW 430
63585: PUSH
63586: LD_VAR 0 4
63590: PPUSH
63591: LD_VAR 0 5
63595: PPUSH
63596: CALL 10710 0 2
63600: AND
63601: IFFALSE 63627
// begin researching := true ;
63603: LD_ADDR_VAR 0 10
63607: PUSH
63608: LD_INT 1
63610: ST_TO_ADDR
// ComResearch ( j , t ) ;
63611: LD_VAR 0 3
63615: PPUSH
63616: LD_VAR 0 5
63620: PPUSH
63621: CALL_OW 124
// break ;
63625: GO 63629
// end ;
63627: GO 63568
63629: POP
63630: POP
// if not researching then
63631: LD_VAR 0 10
63635: NOT
63636: IFFALSE 63648
// idle_lab := j ;
63638: LD_ADDR_VAR 0 11
63642: PUSH
63643: LD_VAR 0 3
63647: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
63648: LD_VAR 0 3
63652: PPUSH
63653: CALL_OW 461
63657: PUSH
63658: LD_INT 10
63660: EQUAL
63661: IFFALSE 64249
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
63663: LD_EXP 71
63667: PUSH
63668: LD_VAR 0 2
63672: ARRAY
63673: NOT
63674: PUSH
63675: LD_EXP 72
63679: PUSH
63680: LD_VAR 0 2
63684: ARRAY
63685: NOT
63686: AND
63687: PUSH
63688: LD_EXP 69
63692: PUSH
63693: LD_VAR 0 4
63697: ARRAY
63698: PUSH
63699: LD_INT 1
63701: GREATER
63702: AND
63703: IFFALSE 63834
// begin ComCancel ( j ) ;
63705: LD_VAR 0 3
63709: PPUSH
63710: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
63714: LD_ADDR_EXP 69
63718: PUSH
63719: LD_EXP 69
63723: PPUSH
63724: LD_VAR 0 4
63728: PPUSH
63729: LD_EXP 69
63733: PUSH
63734: LD_VAR 0 4
63738: ARRAY
63739: PPUSH
63740: LD_EXP 69
63744: PUSH
63745: LD_VAR 0 4
63749: ARRAY
63750: PUSH
63751: LD_INT 1
63753: MINUS
63754: PPUSH
63755: LD_EXP 69
63759: PUSH
63760: LD_VAR 0 4
63764: ARRAY
63765: PPUSH
63766: LD_INT 0
63768: PPUSH
63769: CALL 14222 0 4
63773: PPUSH
63774: CALL_OW 1
63778: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
63779: LD_ADDR_EXP 69
63783: PUSH
63784: LD_EXP 69
63788: PPUSH
63789: LD_VAR 0 4
63793: PPUSH
63794: LD_EXP 69
63798: PUSH
63799: LD_VAR 0 4
63803: ARRAY
63804: PPUSH
63805: LD_EXP 69
63809: PUSH
63810: LD_VAR 0 4
63814: ARRAY
63815: PPUSH
63816: LD_INT 1
63818: PPUSH
63819: LD_INT 0
63821: PPUSH
63822: CALL 14222 0 4
63826: PPUSH
63827: CALL_OW 1
63831: ST_TO_ADDR
// continue ;
63832: GO 63406
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
63834: LD_EXP 71
63838: PUSH
63839: LD_VAR 0 2
63843: ARRAY
63844: PUSH
63845: LD_EXP 72
63849: PUSH
63850: LD_VAR 0 2
63854: ARRAY
63855: NOT
63856: AND
63857: IFFALSE 63984
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
63859: LD_ADDR_EXP 72
63863: PUSH
63864: LD_EXP 72
63868: PPUSH
63869: LD_VAR 0 2
63873: PUSH
63874: LD_EXP 72
63878: PUSH
63879: LD_VAR 0 2
63883: ARRAY
63884: PUSH
63885: LD_INT 1
63887: PLUS
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PPUSH
63893: LD_EXP 71
63897: PUSH
63898: LD_VAR 0 2
63902: ARRAY
63903: PUSH
63904: LD_INT 1
63906: ARRAY
63907: PPUSH
63908: CALL 14804 0 3
63912: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
63913: LD_EXP 71
63917: PUSH
63918: LD_VAR 0 2
63922: ARRAY
63923: PUSH
63924: LD_INT 1
63926: ARRAY
63927: PPUSH
63928: LD_INT 112
63930: PPUSH
63931: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
63935: LD_ADDR_VAR 0 9
63939: PUSH
63940: LD_EXP 71
63944: PUSH
63945: LD_VAR 0 2
63949: ARRAY
63950: PPUSH
63951: LD_INT 1
63953: PPUSH
63954: CALL_OW 3
63958: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
63959: LD_ADDR_EXP 71
63963: PUSH
63964: LD_EXP 71
63968: PPUSH
63969: LD_VAR 0 2
63973: PPUSH
63974: LD_VAR 0 9
63978: PPUSH
63979: CALL_OW 1
63983: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
63984: LD_EXP 71
63988: PUSH
63989: LD_VAR 0 2
63993: ARRAY
63994: PUSH
63995: LD_EXP 72
63999: PUSH
64000: LD_VAR 0 2
64004: ARRAY
64005: AND
64006: PUSH
64007: LD_EXP 72
64011: PUSH
64012: LD_VAR 0 2
64016: ARRAY
64017: PUSH
64018: LD_INT 1
64020: ARRAY
64021: PPUSH
64022: CALL_OW 310
64026: NOT
64027: AND
64028: PUSH
64029: LD_VAR 0 3
64033: PPUSH
64034: CALL_OW 313
64038: PUSH
64039: LD_INT 6
64041: EQUAL
64042: AND
64043: IFFALSE 64099
// begin tmp2 := UnitsInside ( j ) ;
64045: LD_ADDR_VAR 0 9
64049: PUSH
64050: LD_VAR 0 3
64054: PPUSH
64055: CALL_OW 313
64059: ST_TO_ADDR
// if tmp2 = 6 then
64060: LD_VAR 0 9
64064: PUSH
64065: LD_INT 6
64067: EQUAL
64068: IFFALSE 64099
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
64070: LD_VAR 0 9
64074: PUSH
64075: LD_INT 1
64077: ARRAY
64078: PPUSH
64079: LD_INT 112
64081: PPUSH
64082: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
64086: LD_VAR 0 9
64090: PUSH
64091: LD_INT 1
64093: ARRAY
64094: PPUSH
64095: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
64099: LD_EXP 72
64103: PUSH
64104: LD_VAR 0 2
64108: ARRAY
64109: PUSH
64110: LD_EXP 72
64114: PUSH
64115: LD_VAR 0 2
64119: ARRAY
64120: PUSH
64121: LD_INT 1
64123: ARRAY
64124: PPUSH
64125: CALL_OW 314
64129: NOT
64130: AND
64131: PUSH
64132: LD_EXP 72
64136: PUSH
64137: LD_VAR 0 2
64141: ARRAY
64142: PUSH
64143: LD_INT 1
64145: ARRAY
64146: PPUSH
64147: CALL_OW 310
64151: NOT
64152: AND
64153: IFFALSE 64179
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
64155: LD_EXP 72
64159: PUSH
64160: LD_VAR 0 2
64164: ARRAY
64165: PUSH
64166: LD_INT 1
64168: ARRAY
64169: PPUSH
64170: LD_VAR 0 3
64174: PPUSH
64175: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
64179: LD_EXP 72
64183: PUSH
64184: LD_VAR 0 2
64188: ARRAY
64189: PUSH
64190: LD_INT 1
64192: ARRAY
64193: PPUSH
64194: CALL_OW 310
64198: PUSH
64199: LD_EXP 72
64203: PUSH
64204: LD_VAR 0 2
64208: ARRAY
64209: PUSH
64210: LD_INT 1
64212: ARRAY
64213: PPUSH
64214: CALL_OW 310
64218: PPUSH
64219: CALL_OW 461
64223: PUSH
64224: LD_INT 3
64226: NONEQUAL
64227: AND
64228: IFFALSE 64249
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
64230: LD_EXP 72
64234: PUSH
64235: LD_VAR 0 2
64239: ARRAY
64240: PUSH
64241: LD_INT 1
64243: ARRAY
64244: PPUSH
64245: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
64249: LD_VAR 0 3
64253: PPUSH
64254: CALL_OW 461
64258: PUSH
64259: LD_INT 6
64261: EQUAL
64262: PUSH
64263: LD_VAR 0 6
64267: PUSH
64268: LD_INT 1
64270: GREATER
64271: AND
64272: IFFALSE 64424
// begin sci := [ ] ;
64274: LD_ADDR_VAR 0 8
64278: PUSH
64279: EMPTY
64280: ST_TO_ADDR
// for x in ( tmp diff j ) do
64281: LD_ADDR_VAR 0 7
64285: PUSH
64286: LD_VAR 0 6
64290: PUSH
64291: LD_VAR 0 3
64295: DIFF
64296: PUSH
64297: FOR_IN
64298: IFFALSE 64350
// begin if sci = 6 then
64300: LD_VAR 0 8
64304: PUSH
64305: LD_INT 6
64307: EQUAL
64308: IFFALSE 64312
// break ;
64310: GO 64350
// if BuildingStatus ( x ) = bs_idle then
64312: LD_VAR 0 7
64316: PPUSH
64317: CALL_OW 461
64321: PUSH
64322: LD_INT 2
64324: EQUAL
64325: IFFALSE 64348
// sci := sci ^ UnitsInside ( x ) ;
64327: LD_ADDR_VAR 0 8
64331: PUSH
64332: LD_VAR 0 8
64336: PUSH
64337: LD_VAR 0 7
64341: PPUSH
64342: CALL_OW 313
64346: ADD
64347: ST_TO_ADDR
// end ;
64348: GO 64297
64350: POP
64351: POP
// if not sci then
64352: LD_VAR 0 8
64356: NOT
64357: IFFALSE 64361
// continue ;
64359: GO 63406
// for x in sci do
64361: LD_ADDR_VAR 0 7
64365: PUSH
64366: LD_VAR 0 8
64370: PUSH
64371: FOR_IN
64372: IFFALSE 64422
// if IsInUnit ( x ) and not HasTask ( x ) then
64374: LD_VAR 0 7
64378: PPUSH
64379: CALL_OW 310
64383: PUSH
64384: LD_VAR 0 7
64388: PPUSH
64389: CALL_OW 314
64393: NOT
64394: AND
64395: IFFALSE 64420
// begin ComExitBuilding ( x ) ;
64397: LD_VAR 0 7
64401: PPUSH
64402: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
64406: LD_VAR 0 7
64410: PPUSH
64411: LD_VAR 0 3
64415: PPUSH
64416: CALL_OW 180
// end ;
64420: GO 64371
64422: POP
64423: POP
// end ; end ;
64424: GO 63406
64426: POP
64427: POP
// end ;
64428: GO 63360
64430: POP
64431: POP
// end ;
64432: LD_VAR 0 1
64436: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
64437: LD_INT 0
64439: PPUSH
64440: PPUSH
// if not mc_bases then
64441: LD_EXP 42
64445: NOT
64446: IFFALSE 64450
// exit ;
64448: GO 64531
// for i = 1 to mc_bases do
64450: LD_ADDR_VAR 0 2
64454: PUSH
64455: DOUBLE
64456: LD_INT 1
64458: DEC
64459: ST_TO_ADDR
64460: LD_EXP 42
64464: PUSH
64465: FOR_TO
64466: IFFALSE 64529
// if mc_mines [ i ] and mc_miners [ i ] then
64468: LD_EXP 55
64472: PUSH
64473: LD_VAR 0 2
64477: ARRAY
64478: PUSH
64479: LD_EXP 56
64483: PUSH
64484: LD_VAR 0 2
64488: ARRAY
64489: AND
64490: IFFALSE 64527
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
64492: LD_EXP 56
64496: PUSH
64497: LD_VAR 0 2
64501: ARRAY
64502: PUSH
64503: LD_INT 1
64505: ARRAY
64506: PPUSH
64507: CALL_OW 255
64511: PPUSH
64512: LD_EXP 55
64516: PUSH
64517: LD_VAR 0 2
64521: ARRAY
64522: PPUSH
64523: CALL 11793 0 2
64527: GO 64465
64529: POP
64530: POP
// end ;
64531: LD_VAR 0 1
64535: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
64536: LD_INT 0
64538: PPUSH
64539: PPUSH
64540: PPUSH
64541: PPUSH
64542: PPUSH
64543: PPUSH
64544: PPUSH
64545: PPUSH
// if not mc_bases or not mc_parking then
64546: LD_EXP 42
64550: NOT
64551: PUSH
64552: LD_EXP 66
64556: NOT
64557: OR
64558: IFFALSE 64562
// exit ;
64560: GO 65261
// for i = 1 to mc_bases do
64562: LD_ADDR_VAR 0 2
64566: PUSH
64567: DOUBLE
64568: LD_INT 1
64570: DEC
64571: ST_TO_ADDR
64572: LD_EXP 42
64576: PUSH
64577: FOR_TO
64578: IFFALSE 65259
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
64580: LD_EXP 42
64584: PUSH
64585: LD_VAR 0 2
64589: ARRAY
64590: NOT
64591: PUSH
64592: LD_EXP 66
64596: PUSH
64597: LD_VAR 0 2
64601: ARRAY
64602: NOT
64603: OR
64604: IFFALSE 64608
// continue ;
64606: GO 64577
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64608: LD_ADDR_VAR 0 5
64612: PUSH
64613: LD_EXP 42
64617: PUSH
64618: LD_VAR 0 2
64622: ARRAY
64623: PUSH
64624: LD_INT 1
64626: ARRAY
64627: PPUSH
64628: CALL_OW 255
64632: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64633: LD_ADDR_VAR 0 6
64637: PUSH
64638: LD_EXP 42
64642: PUSH
64643: LD_VAR 0 2
64647: ARRAY
64648: PPUSH
64649: LD_INT 30
64651: PUSH
64652: LD_INT 3
64654: PUSH
64655: EMPTY
64656: LIST
64657: LIST
64658: PPUSH
64659: CALL_OW 72
64663: ST_TO_ADDR
// if not fac then
64664: LD_VAR 0 6
64668: NOT
64669: IFFALSE 64720
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64671: LD_ADDR_VAR 0 6
64675: PUSH
64676: LD_EXP 42
64680: PUSH
64681: LD_VAR 0 2
64685: ARRAY
64686: PPUSH
64687: LD_INT 2
64689: PUSH
64690: LD_INT 30
64692: PUSH
64693: LD_INT 0
64695: PUSH
64696: EMPTY
64697: LIST
64698: LIST
64699: PUSH
64700: LD_INT 30
64702: PUSH
64703: LD_INT 1
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: PUSH
64710: EMPTY
64711: LIST
64712: LIST
64713: LIST
64714: PPUSH
64715: CALL_OW 72
64719: ST_TO_ADDR
// if not fac then
64720: LD_VAR 0 6
64724: NOT
64725: IFFALSE 64729
// continue ;
64727: GO 64577
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64729: LD_ADDR_VAR 0 7
64733: PUSH
64734: LD_EXP 66
64738: PUSH
64739: LD_VAR 0 2
64743: ARRAY
64744: PPUSH
64745: LD_INT 22
64747: PUSH
64748: LD_VAR 0 5
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: PUSH
64757: LD_INT 21
64759: PUSH
64760: LD_INT 2
64762: PUSH
64763: EMPTY
64764: LIST
64765: LIST
64766: PUSH
64767: LD_INT 3
64769: PUSH
64770: LD_INT 24
64772: PUSH
64773: LD_INT 1000
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: PUSH
64780: EMPTY
64781: LIST
64782: LIST
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: LIST
64788: PPUSH
64789: CALL_OW 70
64793: ST_TO_ADDR
// for j in fac do
64794: LD_ADDR_VAR 0 3
64798: PUSH
64799: LD_VAR 0 6
64803: PUSH
64804: FOR_IN
64805: IFFALSE 64886
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64807: LD_ADDR_VAR 0 7
64811: PUSH
64812: LD_VAR 0 7
64816: PUSH
64817: LD_INT 22
64819: PUSH
64820: LD_VAR 0 5
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 91
64831: PUSH
64832: LD_VAR 0 3
64836: PUSH
64837: LD_INT 15
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: LIST
64844: PUSH
64845: LD_INT 21
64847: PUSH
64848: LD_INT 2
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: LD_INT 3
64857: PUSH
64858: LD_INT 24
64860: PUSH
64861: LD_INT 1000
64863: PUSH
64864: EMPTY
64865: LIST
64866: LIST
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: PUSH
64872: EMPTY
64873: LIST
64874: LIST
64875: LIST
64876: LIST
64877: PPUSH
64878: CALL_OW 69
64882: UNION
64883: ST_TO_ADDR
64884: GO 64804
64886: POP
64887: POP
// if not vehs then
64888: LD_VAR 0 7
64892: NOT
64893: IFFALSE 64919
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64895: LD_ADDR_EXP 54
64899: PUSH
64900: LD_EXP 54
64904: PPUSH
64905: LD_VAR 0 2
64909: PPUSH
64910: EMPTY
64911: PPUSH
64912: CALL_OW 1
64916: ST_TO_ADDR
// continue ;
64917: GO 64577
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64919: LD_ADDR_VAR 0 8
64923: PUSH
64924: LD_EXP 42
64928: PUSH
64929: LD_VAR 0 2
64933: ARRAY
64934: PPUSH
64935: LD_INT 30
64937: PUSH
64938: LD_INT 3
64940: PUSH
64941: EMPTY
64942: LIST
64943: LIST
64944: PPUSH
64945: CALL_OW 72
64949: ST_TO_ADDR
// if tmp then
64950: LD_VAR 0 8
64954: IFFALSE 65057
// begin for j in tmp do
64956: LD_ADDR_VAR 0 3
64960: PUSH
64961: LD_VAR 0 8
64965: PUSH
64966: FOR_IN
64967: IFFALSE 65055
// for k in UnitsInside ( j ) do
64969: LD_ADDR_VAR 0 4
64973: PUSH
64974: LD_VAR 0 3
64978: PPUSH
64979: CALL_OW 313
64983: PUSH
64984: FOR_IN
64985: IFFALSE 65051
// if k then
64987: LD_VAR 0 4
64991: IFFALSE 65049
// if not k in mc_repair_vehicle [ i ] then
64993: LD_VAR 0 4
64997: PUSH
64998: LD_EXP 54
65002: PUSH
65003: LD_VAR 0 2
65007: ARRAY
65008: IN
65009: NOT
65010: IFFALSE 65049
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
65012: LD_ADDR_EXP 54
65016: PUSH
65017: LD_EXP 54
65021: PPUSH
65022: LD_VAR 0 2
65026: PPUSH
65027: LD_EXP 54
65031: PUSH
65032: LD_VAR 0 2
65036: ARRAY
65037: PUSH
65038: LD_VAR 0 4
65042: UNION
65043: PPUSH
65044: CALL_OW 1
65048: ST_TO_ADDR
65049: GO 64984
65051: POP
65052: POP
65053: GO 64966
65055: POP
65056: POP
// end ; if not mc_repair_vehicle [ i ] then
65057: LD_EXP 54
65061: PUSH
65062: LD_VAR 0 2
65066: ARRAY
65067: NOT
65068: IFFALSE 65072
// continue ;
65070: GO 64577
// for j in mc_repair_vehicle [ i ] do
65072: LD_ADDR_VAR 0 3
65076: PUSH
65077: LD_EXP 54
65081: PUSH
65082: LD_VAR 0 2
65086: ARRAY
65087: PUSH
65088: FOR_IN
65089: IFFALSE 65255
// begin if GetClass ( j ) <> 3 then
65091: LD_VAR 0 3
65095: PPUSH
65096: CALL_OW 257
65100: PUSH
65101: LD_INT 3
65103: NONEQUAL
65104: IFFALSE 65145
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
65106: LD_ADDR_EXP 54
65110: PUSH
65111: LD_EXP 54
65115: PPUSH
65116: LD_VAR 0 2
65120: PPUSH
65121: LD_EXP 54
65125: PUSH
65126: LD_VAR 0 2
65130: ARRAY
65131: PUSH
65132: LD_VAR 0 3
65136: DIFF
65137: PPUSH
65138: CALL_OW 1
65142: ST_TO_ADDR
// continue ;
65143: GO 65088
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
65145: LD_VAR 0 3
65149: PPUSH
65150: CALL_OW 311
65154: NOT
65155: PUSH
65156: LD_VAR 0 3
65160: PUSH
65161: LD_EXP 45
65165: PUSH
65166: LD_VAR 0 2
65170: ARRAY
65171: PUSH
65172: LD_INT 1
65174: ARRAY
65175: IN
65176: NOT
65177: AND
65178: PUSH
65179: LD_VAR 0 3
65183: PUSH
65184: LD_EXP 45
65188: PUSH
65189: LD_VAR 0 2
65193: ARRAY
65194: PUSH
65195: LD_INT 2
65197: ARRAY
65198: IN
65199: NOT
65200: AND
65201: IFFALSE 65253
// begin if IsInUnit ( j ) then
65203: LD_VAR 0 3
65207: PPUSH
65208: CALL_OW 310
65212: IFFALSE 65223
// ComExitBuilding ( j ) ;
65214: LD_VAR 0 3
65218: PPUSH
65219: CALL_OW 122
// if not HasTask ( j ) then
65223: LD_VAR 0 3
65227: PPUSH
65228: CALL_OW 314
65232: NOT
65233: IFFALSE 65253
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
65235: LD_VAR 0 3
65239: PPUSH
65240: LD_VAR 0 7
65244: PUSH
65245: LD_INT 1
65247: ARRAY
65248: PPUSH
65249: CALL_OW 189
// end ; end ;
65253: GO 65088
65255: POP
65256: POP
// end ;
65257: GO 64577
65259: POP
65260: POP
// end ;
65261: LD_VAR 0 1
65265: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
65266: LD_INT 0
65268: PPUSH
65269: PPUSH
65270: PPUSH
65271: PPUSH
65272: PPUSH
65273: PPUSH
65274: PPUSH
65275: PPUSH
65276: PPUSH
65277: PPUSH
65278: PPUSH
// if not mc_bases then
65279: LD_EXP 42
65283: NOT
65284: IFFALSE 65288
// exit ;
65286: GO 66090
// for i = 1 to mc_bases do
65288: LD_ADDR_VAR 0 2
65292: PUSH
65293: DOUBLE
65294: LD_INT 1
65296: DEC
65297: ST_TO_ADDR
65298: LD_EXP 42
65302: PUSH
65303: FOR_TO
65304: IFFALSE 66088
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
65306: LD_EXP 70
65310: PUSH
65311: LD_VAR 0 2
65315: ARRAY
65316: NOT
65317: PUSH
65318: LD_EXP 45
65322: PUSH
65323: LD_VAR 0 2
65327: ARRAY
65328: PUSH
65329: LD_INT 1
65331: ARRAY
65332: OR
65333: PUSH
65334: LD_EXP 45
65338: PUSH
65339: LD_VAR 0 2
65343: ARRAY
65344: PUSH
65345: LD_INT 2
65347: ARRAY
65348: OR
65349: PUSH
65350: LD_EXP 68
65354: PUSH
65355: LD_VAR 0 2
65359: ARRAY
65360: PPUSH
65361: LD_INT 1
65363: PPUSH
65364: CALL_OW 325
65368: NOT
65369: OR
65370: PUSH
65371: LD_EXP 65
65375: PUSH
65376: LD_VAR 0 2
65380: ARRAY
65381: OR
65382: IFFALSE 65386
// continue ;
65384: GO 65303
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
65386: LD_ADDR_VAR 0 8
65390: PUSH
65391: LD_EXP 42
65395: PUSH
65396: LD_VAR 0 2
65400: ARRAY
65401: PPUSH
65402: LD_INT 25
65404: PUSH
65405: LD_INT 4
65407: PUSH
65408: EMPTY
65409: LIST
65410: LIST
65411: PUSH
65412: LD_INT 50
65414: PUSH
65415: EMPTY
65416: LIST
65417: PUSH
65418: LD_INT 3
65420: PUSH
65421: LD_INT 60
65423: PUSH
65424: EMPTY
65425: LIST
65426: PUSH
65427: EMPTY
65428: LIST
65429: LIST
65430: PUSH
65431: EMPTY
65432: LIST
65433: LIST
65434: LIST
65435: PPUSH
65436: CALL_OW 72
65440: PUSH
65441: LD_EXP 46
65445: PUSH
65446: LD_VAR 0 2
65450: ARRAY
65451: DIFF
65452: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65453: LD_ADDR_VAR 0 9
65457: PUSH
65458: LD_EXP 42
65462: PUSH
65463: LD_VAR 0 2
65467: ARRAY
65468: PPUSH
65469: LD_INT 2
65471: PUSH
65472: LD_INT 30
65474: PUSH
65475: LD_INT 0
65477: PUSH
65478: EMPTY
65479: LIST
65480: LIST
65481: PUSH
65482: LD_INT 30
65484: PUSH
65485: LD_INT 1
65487: PUSH
65488: EMPTY
65489: LIST
65490: LIST
65491: PUSH
65492: EMPTY
65493: LIST
65494: LIST
65495: LIST
65496: PPUSH
65497: CALL_OW 72
65501: ST_TO_ADDR
// if not tmp or not dep then
65502: LD_VAR 0 8
65506: NOT
65507: PUSH
65508: LD_VAR 0 9
65512: NOT
65513: OR
65514: IFFALSE 65518
// continue ;
65516: GO 65303
// side := GetSide ( tmp [ 1 ] ) ;
65518: LD_ADDR_VAR 0 11
65522: PUSH
65523: LD_VAR 0 8
65527: PUSH
65528: LD_INT 1
65530: ARRAY
65531: PPUSH
65532: CALL_OW 255
65536: ST_TO_ADDR
// dep := dep [ 1 ] ;
65537: LD_ADDR_VAR 0 9
65541: PUSH
65542: LD_VAR 0 9
65546: PUSH
65547: LD_INT 1
65549: ARRAY
65550: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
65551: LD_ADDR_VAR 0 7
65555: PUSH
65556: LD_EXP 70
65560: PUSH
65561: LD_VAR 0 2
65565: ARRAY
65566: PPUSH
65567: LD_INT 22
65569: PUSH
65570: LD_INT 0
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: PUSH
65577: LD_INT 25
65579: PUSH
65580: LD_INT 12
65582: PUSH
65583: EMPTY
65584: LIST
65585: LIST
65586: PUSH
65587: EMPTY
65588: LIST
65589: LIST
65590: PPUSH
65591: CALL_OW 70
65595: PUSH
65596: LD_INT 22
65598: PUSH
65599: LD_INT 0
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: PUSH
65606: LD_INT 25
65608: PUSH
65609: LD_INT 12
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: PUSH
65616: LD_INT 91
65618: PUSH
65619: LD_VAR 0 9
65623: PUSH
65624: LD_INT 20
65626: PUSH
65627: EMPTY
65628: LIST
65629: LIST
65630: LIST
65631: PUSH
65632: EMPTY
65633: LIST
65634: LIST
65635: LIST
65636: PPUSH
65637: CALL_OW 69
65641: UNION
65642: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
65643: LD_ADDR_VAR 0 10
65647: PUSH
65648: LD_EXP 70
65652: PUSH
65653: LD_VAR 0 2
65657: ARRAY
65658: PPUSH
65659: LD_INT 81
65661: PUSH
65662: LD_VAR 0 11
65666: PUSH
65667: EMPTY
65668: LIST
65669: LIST
65670: PPUSH
65671: CALL_OW 70
65675: ST_TO_ADDR
// if not apes or danger_at_area then
65676: LD_VAR 0 7
65680: NOT
65681: PUSH
65682: LD_VAR 0 10
65686: OR
65687: IFFALSE 65737
// begin if mc_taming [ i ] then
65689: LD_EXP 73
65693: PUSH
65694: LD_VAR 0 2
65698: ARRAY
65699: IFFALSE 65735
// begin MC_Reset ( i , 121 ) ;
65701: LD_VAR 0 2
65705: PPUSH
65706: LD_INT 121
65708: PPUSH
65709: CALL 51140 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65713: LD_ADDR_EXP 73
65717: PUSH
65718: LD_EXP 73
65722: PPUSH
65723: LD_VAR 0 2
65727: PPUSH
65728: EMPTY
65729: PPUSH
65730: CALL_OW 1
65734: ST_TO_ADDR
// end ; continue ;
65735: GO 65303
// end ; for j in tmp do
65737: LD_ADDR_VAR 0 3
65741: PUSH
65742: LD_VAR 0 8
65746: PUSH
65747: FOR_IN
65748: IFFALSE 66084
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
65750: LD_VAR 0 3
65754: PUSH
65755: LD_EXP 73
65759: PUSH
65760: LD_VAR 0 2
65764: ARRAY
65765: IN
65766: NOT
65767: PUSH
65768: LD_EXP 73
65772: PUSH
65773: LD_VAR 0 2
65777: ARRAY
65778: PUSH
65779: LD_INT 3
65781: LESS
65782: AND
65783: IFFALSE 65841
// begin SetTag ( j , 121 ) ;
65785: LD_VAR 0 3
65789: PPUSH
65790: LD_INT 121
65792: PPUSH
65793: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
65797: LD_ADDR_EXP 73
65801: PUSH
65802: LD_EXP 73
65806: PPUSH
65807: LD_VAR 0 2
65811: PUSH
65812: LD_EXP 73
65816: PUSH
65817: LD_VAR 0 2
65821: ARRAY
65822: PUSH
65823: LD_INT 1
65825: PLUS
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PPUSH
65831: LD_VAR 0 3
65835: PPUSH
65836: CALL 14804 0 3
65840: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
65841: LD_VAR 0 3
65845: PUSH
65846: LD_EXP 73
65850: PUSH
65851: LD_VAR 0 2
65855: ARRAY
65856: IN
65857: IFFALSE 66082
// begin if GetClass ( j ) <> 4 then
65859: LD_VAR 0 3
65863: PPUSH
65864: CALL_OW 257
65868: PUSH
65869: LD_INT 4
65871: NONEQUAL
65872: IFFALSE 65925
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
65874: LD_ADDR_EXP 73
65878: PUSH
65879: LD_EXP 73
65883: PPUSH
65884: LD_VAR 0 2
65888: PPUSH
65889: LD_EXP 73
65893: PUSH
65894: LD_VAR 0 2
65898: ARRAY
65899: PUSH
65900: LD_VAR 0 3
65904: DIFF
65905: PPUSH
65906: CALL_OW 1
65910: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65911: LD_VAR 0 3
65915: PPUSH
65916: LD_INT 0
65918: PPUSH
65919: CALL_OW 109
// continue ;
65923: GO 65747
// end ; if IsInUnit ( j ) then
65925: LD_VAR 0 3
65929: PPUSH
65930: CALL_OW 310
65934: IFFALSE 65945
// ComExitBuilding ( j ) ;
65936: LD_VAR 0 3
65940: PPUSH
65941: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
65945: LD_ADDR_VAR 0 6
65949: PUSH
65950: LD_VAR 0 7
65954: PPUSH
65955: LD_VAR 0 3
65959: PPUSH
65960: CALL_OW 74
65964: ST_TO_ADDR
// if not ape then
65965: LD_VAR 0 6
65969: NOT
65970: IFFALSE 65974
// break ;
65972: GO 66084
// x := GetX ( ape ) ;
65974: LD_ADDR_VAR 0 4
65978: PUSH
65979: LD_VAR 0 6
65983: PPUSH
65984: CALL_OW 250
65988: ST_TO_ADDR
// y := GetY ( ape ) ;
65989: LD_ADDR_VAR 0 5
65993: PUSH
65994: LD_VAR 0 6
65998: PPUSH
65999: CALL_OW 251
66003: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66004: LD_VAR 0 4
66008: PPUSH
66009: LD_VAR 0 5
66013: PPUSH
66014: CALL_OW 488
66018: NOT
66019: PUSH
66020: LD_VAR 0 11
66024: PPUSH
66025: LD_VAR 0 4
66029: PPUSH
66030: LD_VAR 0 5
66034: PPUSH
66035: LD_INT 20
66037: PPUSH
66038: CALL 15700 0 4
66042: PUSH
66043: LD_INT 4
66045: ARRAY
66046: OR
66047: IFFALSE 66051
// break ;
66049: GO 66084
// if not HasTask ( j ) then
66051: LD_VAR 0 3
66055: PPUSH
66056: CALL_OW 314
66060: NOT
66061: IFFALSE 66082
// ComTameXY ( j , x , y ) ;
66063: LD_VAR 0 3
66067: PPUSH
66068: LD_VAR 0 4
66072: PPUSH
66073: LD_VAR 0 5
66077: PPUSH
66078: CALL_OW 131
// end ; end ;
66082: GO 65747
66084: POP
66085: POP
// end ;
66086: GO 65303
66088: POP
66089: POP
// end ;
66090: LD_VAR 0 1
66094: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
66095: LD_INT 0
66097: PPUSH
66098: PPUSH
66099: PPUSH
66100: PPUSH
66101: PPUSH
66102: PPUSH
66103: PPUSH
66104: PPUSH
// if not mc_bases then
66105: LD_EXP 42
66109: NOT
66110: IFFALSE 66114
// exit ;
66112: GO 66740
// for i = 1 to mc_bases do
66114: LD_ADDR_VAR 0 2
66118: PUSH
66119: DOUBLE
66120: LD_INT 1
66122: DEC
66123: ST_TO_ADDR
66124: LD_EXP 42
66128: PUSH
66129: FOR_TO
66130: IFFALSE 66738
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
66132: LD_EXP 71
66136: PUSH
66137: LD_VAR 0 2
66141: ARRAY
66142: NOT
66143: PUSH
66144: LD_EXP 71
66148: PUSH
66149: LD_VAR 0 2
66153: ARRAY
66154: PPUSH
66155: LD_INT 25
66157: PUSH
66158: LD_INT 12
66160: PUSH
66161: EMPTY
66162: LIST
66163: LIST
66164: PPUSH
66165: CALL_OW 72
66169: NOT
66170: OR
66171: IFFALSE 66175
// continue ;
66173: GO 66129
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
66175: LD_ADDR_VAR 0 5
66179: PUSH
66180: LD_EXP 71
66184: PUSH
66185: LD_VAR 0 2
66189: ARRAY
66190: PUSH
66191: LD_INT 1
66193: ARRAY
66194: PPUSH
66195: CALL_OW 255
66199: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
66200: LD_VAR 0 5
66204: PPUSH
66205: LD_INT 2
66207: PPUSH
66208: CALL_OW 325
66212: IFFALSE 66465
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66214: LD_ADDR_VAR 0 4
66218: PUSH
66219: LD_EXP 71
66223: PUSH
66224: LD_VAR 0 2
66228: ARRAY
66229: PPUSH
66230: LD_INT 25
66232: PUSH
66233: LD_INT 16
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PPUSH
66240: CALL_OW 72
66244: ST_TO_ADDR
// if tmp < 6 then
66245: LD_VAR 0 4
66249: PUSH
66250: LD_INT 6
66252: LESS
66253: IFFALSE 66465
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66255: LD_ADDR_VAR 0 6
66259: PUSH
66260: LD_EXP 42
66264: PUSH
66265: LD_VAR 0 2
66269: ARRAY
66270: PPUSH
66271: LD_INT 2
66273: PUSH
66274: LD_INT 30
66276: PUSH
66277: LD_INT 0
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PUSH
66284: LD_INT 30
66286: PUSH
66287: LD_INT 1
66289: PUSH
66290: EMPTY
66291: LIST
66292: LIST
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: LIST
66298: PPUSH
66299: CALL_OW 72
66303: ST_TO_ADDR
// if depot then
66304: LD_VAR 0 6
66308: IFFALSE 66465
// begin selected := 0 ;
66310: LD_ADDR_VAR 0 7
66314: PUSH
66315: LD_INT 0
66317: ST_TO_ADDR
// for j in depot do
66318: LD_ADDR_VAR 0 3
66322: PUSH
66323: LD_VAR 0 6
66327: PUSH
66328: FOR_IN
66329: IFFALSE 66360
// begin if UnitsInside ( j ) < 6 then
66331: LD_VAR 0 3
66335: PPUSH
66336: CALL_OW 313
66340: PUSH
66341: LD_INT 6
66343: LESS
66344: IFFALSE 66358
// begin selected := j ;
66346: LD_ADDR_VAR 0 7
66350: PUSH
66351: LD_VAR 0 3
66355: ST_TO_ADDR
// break ;
66356: GO 66360
// end ; end ;
66358: GO 66328
66360: POP
66361: POP
// if selected then
66362: LD_VAR 0 7
66366: IFFALSE 66465
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66368: LD_ADDR_VAR 0 3
66372: PUSH
66373: LD_EXP 71
66377: PUSH
66378: LD_VAR 0 2
66382: ARRAY
66383: PPUSH
66384: LD_INT 25
66386: PUSH
66387: LD_INT 12
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: PPUSH
66394: CALL_OW 72
66398: PUSH
66399: FOR_IN
66400: IFFALSE 66463
// if not HasTask ( j ) then
66402: LD_VAR 0 3
66406: PPUSH
66407: CALL_OW 314
66411: NOT
66412: IFFALSE 66461
// begin if not IsInUnit ( j ) then
66414: LD_VAR 0 3
66418: PPUSH
66419: CALL_OW 310
66423: NOT
66424: IFFALSE 66440
// ComEnterUnit ( j , selected ) ;
66426: LD_VAR 0 3
66430: PPUSH
66431: LD_VAR 0 7
66435: PPUSH
66436: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
66440: LD_VAR 0 3
66444: PPUSH
66445: LD_INT 16
66447: PPUSH
66448: CALL_OW 183
// AddComExitBuilding ( j ) ;
66452: LD_VAR 0 3
66456: PPUSH
66457: CALL_OW 182
// end ;
66461: GO 66399
66463: POP
66464: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
66465: LD_VAR 0 5
66469: PPUSH
66470: LD_INT 11
66472: PPUSH
66473: CALL_OW 325
66477: IFFALSE 66736
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66479: LD_ADDR_VAR 0 4
66483: PUSH
66484: LD_EXP 71
66488: PUSH
66489: LD_VAR 0 2
66493: ARRAY
66494: PPUSH
66495: LD_INT 25
66497: PUSH
66498: LD_INT 16
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PPUSH
66505: CALL_OW 72
66509: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
66510: LD_VAR 0 4
66514: PUSH
66515: LD_INT 6
66517: GREATEREQUAL
66518: PUSH
66519: LD_VAR 0 5
66523: PPUSH
66524: LD_INT 2
66526: PPUSH
66527: CALL_OW 325
66531: NOT
66532: OR
66533: IFFALSE 66736
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66535: LD_ADDR_VAR 0 8
66539: PUSH
66540: LD_EXP 42
66544: PUSH
66545: LD_VAR 0 2
66549: ARRAY
66550: PPUSH
66551: LD_INT 2
66553: PUSH
66554: LD_INT 30
66556: PUSH
66557: LD_INT 4
66559: PUSH
66560: EMPTY
66561: LIST
66562: LIST
66563: PUSH
66564: LD_INT 30
66566: PUSH
66567: LD_INT 5
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: LIST
66578: PPUSH
66579: CALL_OW 72
66583: ST_TO_ADDR
// if barracks then
66584: LD_VAR 0 8
66588: IFFALSE 66736
// begin selected := 0 ;
66590: LD_ADDR_VAR 0 7
66594: PUSH
66595: LD_INT 0
66597: ST_TO_ADDR
// for j in barracks do
66598: LD_ADDR_VAR 0 3
66602: PUSH
66603: LD_VAR 0 8
66607: PUSH
66608: FOR_IN
66609: IFFALSE 66640
// begin if UnitsInside ( j ) < 6 then
66611: LD_VAR 0 3
66615: PPUSH
66616: CALL_OW 313
66620: PUSH
66621: LD_INT 6
66623: LESS
66624: IFFALSE 66638
// begin selected := j ;
66626: LD_ADDR_VAR 0 7
66630: PUSH
66631: LD_VAR 0 3
66635: ST_TO_ADDR
// break ;
66636: GO 66640
// end ; end ;
66638: GO 66608
66640: POP
66641: POP
// if selected then
66642: LD_VAR 0 7
66646: IFFALSE 66736
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66648: LD_ADDR_VAR 0 3
66652: PUSH
66653: LD_EXP 71
66657: PUSH
66658: LD_VAR 0 2
66662: ARRAY
66663: PPUSH
66664: LD_INT 25
66666: PUSH
66667: LD_INT 12
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: PPUSH
66674: CALL_OW 72
66678: PUSH
66679: FOR_IN
66680: IFFALSE 66734
// if not IsInUnit ( j ) and not HasTask ( j ) then
66682: LD_VAR 0 3
66686: PPUSH
66687: CALL_OW 310
66691: NOT
66692: PUSH
66693: LD_VAR 0 3
66697: PPUSH
66698: CALL_OW 314
66702: NOT
66703: AND
66704: IFFALSE 66732
// begin ComEnterUnit ( j , selected ) ;
66706: LD_VAR 0 3
66710: PPUSH
66711: LD_VAR 0 7
66715: PPUSH
66716: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
66720: LD_VAR 0 3
66724: PPUSH
66725: LD_INT 15
66727: PPUSH
66728: CALL_OW 183
// end ;
66732: GO 66679
66734: POP
66735: POP
// end ; end ; end ; end ; end ;
66736: GO 66129
66738: POP
66739: POP
// end ;
66740: LD_VAR 0 1
66744: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
66745: LD_INT 0
66747: PPUSH
66748: PPUSH
66749: PPUSH
66750: PPUSH
// if not mc_bases then
66751: LD_EXP 42
66755: NOT
66756: IFFALSE 66760
// exit ;
66758: GO 66938
// for i = 1 to mc_bases do
66760: LD_ADDR_VAR 0 2
66764: PUSH
66765: DOUBLE
66766: LD_INT 1
66768: DEC
66769: ST_TO_ADDR
66770: LD_EXP 42
66774: PUSH
66775: FOR_TO
66776: IFFALSE 66936
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
66778: LD_ADDR_VAR 0 4
66782: PUSH
66783: LD_EXP 42
66787: PUSH
66788: LD_VAR 0 2
66792: ARRAY
66793: PPUSH
66794: LD_INT 25
66796: PUSH
66797: LD_INT 9
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PPUSH
66804: CALL_OW 72
66808: ST_TO_ADDR
// if not tmp then
66809: LD_VAR 0 4
66813: NOT
66814: IFFALSE 66818
// continue ;
66816: GO 66775
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
66818: LD_EXP 68
66822: PUSH
66823: LD_VAR 0 2
66827: ARRAY
66828: PPUSH
66829: LD_INT 29
66831: PPUSH
66832: CALL_OW 325
66836: NOT
66837: PUSH
66838: LD_EXP 68
66842: PUSH
66843: LD_VAR 0 2
66847: ARRAY
66848: PPUSH
66849: LD_INT 28
66851: PPUSH
66852: CALL_OW 325
66856: NOT
66857: AND
66858: IFFALSE 66862
// continue ;
66860: GO 66775
// for j in tmp do
66862: LD_ADDR_VAR 0 3
66866: PUSH
66867: LD_VAR 0 4
66871: PUSH
66872: FOR_IN
66873: IFFALSE 66932
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
66875: LD_VAR 0 3
66879: PUSH
66880: LD_EXP 45
66884: PUSH
66885: LD_VAR 0 2
66889: ARRAY
66890: PUSH
66891: LD_INT 1
66893: ARRAY
66894: IN
66895: NOT
66896: PUSH
66897: LD_VAR 0 3
66901: PUSH
66902: LD_EXP 45
66906: PUSH
66907: LD_VAR 0 2
66911: ARRAY
66912: PUSH
66913: LD_INT 2
66915: ARRAY
66916: IN
66917: NOT
66918: AND
66919: IFFALSE 66930
// ComSpaceTimeShoot ( j ) ;
66921: LD_VAR 0 3
66925: PPUSH
66926: CALL 10801 0 1
66930: GO 66872
66932: POP
66933: POP
// end ;
66934: GO 66775
66936: POP
66937: POP
// end ;
66938: LD_VAR 0 1
66942: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
66943: LD_INT 0
66945: PPUSH
66946: PPUSH
66947: PPUSH
66948: PPUSH
66949: PPUSH
66950: PPUSH
66951: PPUSH
66952: PPUSH
66953: PPUSH
// if not mc_bases then
66954: LD_EXP 42
66958: NOT
66959: IFFALSE 66963
// exit ;
66961: GO 67585
// for i = 1 to mc_bases do
66963: LD_ADDR_VAR 0 2
66967: PUSH
66968: DOUBLE
66969: LD_INT 1
66971: DEC
66972: ST_TO_ADDR
66973: LD_EXP 42
66977: PUSH
66978: FOR_TO
66979: IFFALSE 67583
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
66981: LD_EXP 77
66985: PUSH
66986: LD_VAR 0 2
66990: ARRAY
66991: NOT
66992: PUSH
66993: LD_INT 38
66995: PPUSH
66996: LD_EXP 68
67000: PUSH
67001: LD_VAR 0 2
67005: ARRAY
67006: PPUSH
67007: CALL_OW 321
67011: PUSH
67012: LD_INT 2
67014: NONEQUAL
67015: OR
67016: IFFALSE 67020
// continue ;
67018: GO 66978
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
67020: LD_ADDR_VAR 0 8
67024: PUSH
67025: LD_EXP 42
67029: PUSH
67030: LD_VAR 0 2
67034: ARRAY
67035: PPUSH
67036: LD_INT 30
67038: PUSH
67039: LD_INT 34
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PPUSH
67046: CALL_OW 72
67050: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
67051: LD_ADDR_VAR 0 9
67055: PUSH
67056: LD_EXP 42
67060: PUSH
67061: LD_VAR 0 2
67065: ARRAY
67066: PPUSH
67067: LD_INT 25
67069: PUSH
67070: LD_INT 4
67072: PUSH
67073: EMPTY
67074: LIST
67075: LIST
67076: PPUSH
67077: CALL_OW 72
67081: PPUSH
67082: LD_INT 0
67084: PPUSH
67085: CALL 43365 0 2
67089: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
67090: LD_VAR 0 9
67094: NOT
67095: PUSH
67096: LD_VAR 0 8
67100: NOT
67101: OR
67102: PUSH
67103: LD_EXP 42
67107: PUSH
67108: LD_VAR 0 2
67112: ARRAY
67113: PPUSH
67114: LD_INT 124
67116: PPUSH
67117: CALL 43365 0 2
67121: OR
67122: IFFALSE 67126
// continue ;
67124: GO 66978
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
67126: LD_EXP 78
67130: PUSH
67131: LD_VAR 0 2
67135: ARRAY
67136: PUSH
67137: LD_EXP 77
67141: PUSH
67142: LD_VAR 0 2
67146: ARRAY
67147: LESS
67148: PUSH
67149: LD_EXP 78
67153: PUSH
67154: LD_VAR 0 2
67158: ARRAY
67159: PUSH
67160: LD_VAR 0 8
67164: LESS
67165: AND
67166: IFFALSE 67581
// begin tmp := sci [ 1 ] ;
67168: LD_ADDR_VAR 0 7
67172: PUSH
67173: LD_VAR 0 9
67177: PUSH
67178: LD_INT 1
67180: ARRAY
67181: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
67182: LD_VAR 0 7
67186: PPUSH
67187: LD_INT 124
67189: PPUSH
67190: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
67194: LD_ADDR_VAR 0 3
67198: PUSH
67199: DOUBLE
67200: LD_EXP 77
67204: PUSH
67205: LD_VAR 0 2
67209: ARRAY
67210: INC
67211: ST_TO_ADDR
67212: LD_EXP 77
67216: PUSH
67217: LD_VAR 0 2
67221: ARRAY
67222: PUSH
67223: FOR_DOWNTO
67224: IFFALSE 67567
// begin if IsInUnit ( tmp ) then
67226: LD_VAR 0 7
67230: PPUSH
67231: CALL_OW 310
67235: IFFALSE 67246
// ComExitBuilding ( tmp ) ;
67237: LD_VAR 0 7
67241: PPUSH
67242: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
67246: LD_INT 35
67248: PPUSH
67249: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
67253: LD_VAR 0 7
67257: PPUSH
67258: CALL_OW 310
67262: NOT
67263: PUSH
67264: LD_VAR 0 7
67268: PPUSH
67269: CALL_OW 314
67273: NOT
67274: AND
67275: IFFALSE 67246
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
67277: LD_ADDR_VAR 0 6
67281: PUSH
67282: LD_VAR 0 7
67286: PPUSH
67287: CALL_OW 250
67291: PUSH
67292: LD_VAR 0 7
67296: PPUSH
67297: CALL_OW 251
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
67306: LD_INT 35
67308: PPUSH
67309: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
67313: LD_ADDR_VAR 0 4
67317: PUSH
67318: LD_EXP 77
67322: PUSH
67323: LD_VAR 0 2
67327: ARRAY
67328: PUSH
67329: LD_VAR 0 3
67333: ARRAY
67334: PUSH
67335: LD_INT 1
67337: ARRAY
67338: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
67339: LD_ADDR_VAR 0 5
67343: PUSH
67344: LD_EXP 77
67348: PUSH
67349: LD_VAR 0 2
67353: ARRAY
67354: PUSH
67355: LD_VAR 0 3
67359: ARRAY
67360: PUSH
67361: LD_INT 2
67363: ARRAY
67364: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
67365: LD_VAR 0 7
67369: PPUSH
67370: LD_INT 10
67372: PPUSH
67373: CALL 17397 0 2
67377: PUSH
67378: LD_INT 4
67380: ARRAY
67381: IFFALSE 67419
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
67383: LD_VAR 0 7
67387: PPUSH
67388: LD_VAR 0 6
67392: PUSH
67393: LD_INT 1
67395: ARRAY
67396: PPUSH
67397: LD_VAR 0 6
67401: PUSH
67402: LD_INT 2
67404: ARRAY
67405: PPUSH
67406: CALL_OW 111
// wait ( 0 0$10 ) ;
67410: LD_INT 350
67412: PPUSH
67413: CALL_OW 67
// end else
67417: GO 67445
// begin ComMoveXY ( tmp , x , y ) ;
67419: LD_VAR 0 7
67423: PPUSH
67424: LD_VAR 0 4
67428: PPUSH
67429: LD_VAR 0 5
67433: PPUSH
67434: CALL_OW 111
// wait ( 0 0$3 ) ;
67438: LD_INT 105
67440: PPUSH
67441: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
67445: LD_VAR 0 7
67449: PPUSH
67450: LD_VAR 0 4
67454: PPUSH
67455: LD_VAR 0 5
67459: PPUSH
67460: CALL_OW 307
67464: IFFALSE 67306
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
67466: LD_VAR 0 7
67470: PPUSH
67471: LD_VAR 0 4
67475: PPUSH
67476: LD_VAR 0 5
67480: PPUSH
67481: LD_VAR 0 8
67485: PUSH
67486: LD_VAR 0 3
67490: ARRAY
67491: PPUSH
67492: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
67496: LD_INT 35
67498: PPUSH
67499: CALL_OW 67
// until not HasTask ( tmp ) ;
67503: LD_VAR 0 7
67507: PPUSH
67508: CALL_OW 314
67512: NOT
67513: IFFALSE 67496
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
67515: LD_ADDR_EXP 78
67519: PUSH
67520: LD_EXP 78
67524: PPUSH
67525: LD_VAR 0 2
67529: PUSH
67530: LD_EXP 78
67534: PUSH
67535: LD_VAR 0 2
67539: ARRAY
67540: PUSH
67541: LD_INT 1
67543: PLUS
67544: PUSH
67545: EMPTY
67546: LIST
67547: LIST
67548: PPUSH
67549: LD_VAR 0 8
67553: PUSH
67554: LD_VAR 0 3
67558: ARRAY
67559: PPUSH
67560: CALL 14804 0 3
67564: ST_TO_ADDR
// end ;
67565: GO 67223
67567: POP
67568: POP
// MC_Reset ( i , 124 ) ;
67569: LD_VAR 0 2
67573: PPUSH
67574: LD_INT 124
67576: PPUSH
67577: CALL 51140 0 2
// end ; end ;
67581: GO 66978
67583: POP
67584: POP
// end ;
67585: LD_VAR 0 1
67589: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
67590: LD_INT 0
67592: PPUSH
67593: PPUSH
67594: PPUSH
// if not mc_bases then
67595: LD_EXP 42
67599: NOT
67600: IFFALSE 67604
// exit ;
67602: GO 68210
// for i = 1 to mc_bases do
67604: LD_ADDR_VAR 0 2
67608: PUSH
67609: DOUBLE
67610: LD_INT 1
67612: DEC
67613: ST_TO_ADDR
67614: LD_EXP 42
67618: PUSH
67619: FOR_TO
67620: IFFALSE 68208
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67622: LD_ADDR_VAR 0 3
67626: PUSH
67627: LD_EXP 42
67631: PUSH
67632: LD_VAR 0 2
67636: ARRAY
67637: PPUSH
67638: LD_INT 25
67640: PUSH
67641: LD_INT 4
67643: PUSH
67644: EMPTY
67645: LIST
67646: LIST
67647: PPUSH
67648: CALL_OW 72
67652: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67653: LD_VAR 0 3
67657: NOT
67658: PUSH
67659: LD_EXP 79
67663: PUSH
67664: LD_VAR 0 2
67668: ARRAY
67669: NOT
67670: OR
67671: PUSH
67672: LD_EXP 42
67676: PUSH
67677: LD_VAR 0 2
67681: ARRAY
67682: PPUSH
67683: LD_INT 2
67685: PUSH
67686: LD_INT 30
67688: PUSH
67689: LD_INT 0
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 30
67698: PUSH
67699: LD_INT 1
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: EMPTY
67707: LIST
67708: LIST
67709: LIST
67710: PPUSH
67711: CALL_OW 72
67715: NOT
67716: OR
67717: IFFALSE 67767
// begin if mc_deposits_finder [ i ] then
67719: LD_EXP 80
67723: PUSH
67724: LD_VAR 0 2
67728: ARRAY
67729: IFFALSE 67765
// begin MC_Reset ( i , 125 ) ;
67731: LD_VAR 0 2
67735: PPUSH
67736: LD_INT 125
67738: PPUSH
67739: CALL 51140 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67743: LD_ADDR_EXP 80
67747: PUSH
67748: LD_EXP 80
67752: PPUSH
67753: LD_VAR 0 2
67757: PPUSH
67758: EMPTY
67759: PPUSH
67760: CALL_OW 1
67764: ST_TO_ADDR
// end ; continue ;
67765: GO 67619
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
67767: LD_EXP 79
67771: PUSH
67772: LD_VAR 0 2
67776: ARRAY
67777: PUSH
67778: LD_INT 1
67780: ARRAY
67781: PUSH
67782: LD_INT 3
67784: ARRAY
67785: PUSH
67786: LD_INT 1
67788: EQUAL
67789: PUSH
67790: LD_INT 20
67792: PPUSH
67793: LD_EXP 68
67797: PUSH
67798: LD_VAR 0 2
67802: ARRAY
67803: PPUSH
67804: CALL_OW 321
67808: PUSH
67809: LD_INT 2
67811: NONEQUAL
67812: AND
67813: IFFALSE 67863
// begin if mc_deposits_finder [ i ] then
67815: LD_EXP 80
67819: PUSH
67820: LD_VAR 0 2
67824: ARRAY
67825: IFFALSE 67861
// begin MC_Reset ( i , 125 ) ;
67827: LD_VAR 0 2
67831: PPUSH
67832: LD_INT 125
67834: PPUSH
67835: CALL 51140 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67839: LD_ADDR_EXP 80
67843: PUSH
67844: LD_EXP 80
67848: PPUSH
67849: LD_VAR 0 2
67853: PPUSH
67854: EMPTY
67855: PPUSH
67856: CALL_OW 1
67860: ST_TO_ADDR
// end ; continue ;
67861: GO 67619
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
67863: LD_EXP 79
67867: PUSH
67868: LD_VAR 0 2
67872: ARRAY
67873: PUSH
67874: LD_INT 1
67876: ARRAY
67877: PUSH
67878: LD_INT 1
67880: ARRAY
67881: PPUSH
67882: LD_EXP 79
67886: PUSH
67887: LD_VAR 0 2
67891: ARRAY
67892: PUSH
67893: LD_INT 1
67895: ARRAY
67896: PUSH
67897: LD_INT 2
67899: ARRAY
67900: PPUSH
67901: LD_EXP 68
67905: PUSH
67906: LD_VAR 0 2
67910: ARRAY
67911: PPUSH
67912: CALL_OW 440
67916: IFFALSE 67959
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
67918: LD_ADDR_EXP 79
67922: PUSH
67923: LD_EXP 79
67927: PPUSH
67928: LD_VAR 0 2
67932: PPUSH
67933: LD_EXP 79
67937: PUSH
67938: LD_VAR 0 2
67942: ARRAY
67943: PPUSH
67944: LD_INT 1
67946: PPUSH
67947: CALL_OW 3
67951: PPUSH
67952: CALL_OW 1
67956: ST_TO_ADDR
67957: GO 68206
// begin if not mc_deposits_finder [ i ] then
67959: LD_EXP 80
67963: PUSH
67964: LD_VAR 0 2
67968: ARRAY
67969: NOT
67970: IFFALSE 68022
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
67972: LD_ADDR_EXP 80
67976: PUSH
67977: LD_EXP 80
67981: PPUSH
67982: LD_VAR 0 2
67986: PPUSH
67987: LD_VAR 0 3
67991: PUSH
67992: LD_INT 1
67994: ARRAY
67995: PUSH
67996: EMPTY
67997: LIST
67998: PPUSH
67999: CALL_OW 1
68003: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
68004: LD_VAR 0 3
68008: PUSH
68009: LD_INT 1
68011: ARRAY
68012: PPUSH
68013: LD_INT 125
68015: PPUSH
68016: CALL_OW 109
// end else
68020: GO 68206
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
68022: LD_EXP 80
68026: PUSH
68027: LD_VAR 0 2
68031: ARRAY
68032: PUSH
68033: LD_INT 1
68035: ARRAY
68036: PPUSH
68037: CALL_OW 310
68041: IFFALSE 68064
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
68043: LD_EXP 80
68047: PUSH
68048: LD_VAR 0 2
68052: ARRAY
68053: PUSH
68054: LD_INT 1
68056: ARRAY
68057: PPUSH
68058: CALL_OW 122
68062: GO 68206
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
68064: LD_EXP 80
68068: PUSH
68069: LD_VAR 0 2
68073: ARRAY
68074: PUSH
68075: LD_INT 1
68077: ARRAY
68078: PPUSH
68079: CALL_OW 314
68083: NOT
68084: PUSH
68085: LD_EXP 80
68089: PUSH
68090: LD_VAR 0 2
68094: ARRAY
68095: PUSH
68096: LD_INT 1
68098: ARRAY
68099: PPUSH
68100: LD_EXP 79
68104: PUSH
68105: LD_VAR 0 2
68109: ARRAY
68110: PUSH
68111: LD_INT 1
68113: ARRAY
68114: PUSH
68115: LD_INT 1
68117: ARRAY
68118: PPUSH
68119: LD_EXP 79
68123: PUSH
68124: LD_VAR 0 2
68128: ARRAY
68129: PUSH
68130: LD_INT 1
68132: ARRAY
68133: PUSH
68134: LD_INT 2
68136: ARRAY
68137: PPUSH
68138: CALL_OW 297
68142: PUSH
68143: LD_INT 6
68145: GREATER
68146: AND
68147: IFFALSE 68206
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
68149: LD_EXP 80
68153: PUSH
68154: LD_VAR 0 2
68158: ARRAY
68159: PUSH
68160: LD_INT 1
68162: ARRAY
68163: PPUSH
68164: LD_EXP 79
68168: PUSH
68169: LD_VAR 0 2
68173: ARRAY
68174: PUSH
68175: LD_INT 1
68177: ARRAY
68178: PUSH
68179: LD_INT 1
68181: ARRAY
68182: PPUSH
68183: LD_EXP 79
68187: PUSH
68188: LD_VAR 0 2
68192: ARRAY
68193: PUSH
68194: LD_INT 1
68196: ARRAY
68197: PUSH
68198: LD_INT 2
68200: ARRAY
68201: PPUSH
68202: CALL_OW 111
// end ; end ; end ;
68206: GO 67619
68208: POP
68209: POP
// end ;
68210: LD_VAR 0 1
68214: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
68215: LD_INT 0
68217: PPUSH
68218: PPUSH
68219: PPUSH
68220: PPUSH
68221: PPUSH
68222: PPUSH
68223: PPUSH
68224: PPUSH
68225: PPUSH
68226: PPUSH
68227: PPUSH
// if not mc_bases then
68228: LD_EXP 42
68232: NOT
68233: IFFALSE 68237
// exit ;
68235: GO 69177
// for i = 1 to mc_bases do
68237: LD_ADDR_VAR 0 2
68241: PUSH
68242: DOUBLE
68243: LD_INT 1
68245: DEC
68246: ST_TO_ADDR
68247: LD_EXP 42
68251: PUSH
68252: FOR_TO
68253: IFFALSE 69175
// begin if not mc_bases [ i ] or mc_scan [ i ] then
68255: LD_EXP 42
68259: PUSH
68260: LD_VAR 0 2
68264: ARRAY
68265: NOT
68266: PUSH
68267: LD_EXP 65
68271: PUSH
68272: LD_VAR 0 2
68276: ARRAY
68277: OR
68278: IFFALSE 68282
// continue ;
68280: GO 68252
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
68282: LD_ADDR_VAR 0 7
68286: PUSH
68287: LD_EXP 42
68291: PUSH
68292: LD_VAR 0 2
68296: ARRAY
68297: PUSH
68298: LD_INT 1
68300: ARRAY
68301: PPUSH
68302: CALL_OW 248
68306: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
68307: LD_VAR 0 7
68311: PUSH
68312: LD_INT 3
68314: EQUAL
68315: PUSH
68316: LD_EXP 61
68320: PUSH
68321: LD_VAR 0 2
68325: ARRAY
68326: PUSH
68327: LD_EXP 64
68331: PUSH
68332: LD_VAR 0 2
68336: ARRAY
68337: UNION
68338: PPUSH
68339: LD_INT 33
68341: PUSH
68342: LD_INT 2
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PPUSH
68349: CALL_OW 72
68353: NOT
68354: OR
68355: IFFALSE 68359
// continue ;
68357: GO 68252
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
68359: LD_ADDR_VAR 0 9
68363: PUSH
68364: LD_EXP 42
68368: PUSH
68369: LD_VAR 0 2
68373: ARRAY
68374: PPUSH
68375: LD_INT 30
68377: PUSH
68378: LD_INT 36
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PPUSH
68385: CALL_OW 72
68389: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
68390: LD_ADDR_VAR 0 10
68394: PUSH
68395: LD_EXP 61
68399: PUSH
68400: LD_VAR 0 2
68404: ARRAY
68405: PPUSH
68406: LD_INT 34
68408: PUSH
68409: LD_INT 31
68411: PUSH
68412: EMPTY
68413: LIST
68414: LIST
68415: PPUSH
68416: CALL_OW 72
68420: ST_TO_ADDR
// if not cts and not mcts then
68421: LD_VAR 0 9
68425: NOT
68426: PUSH
68427: LD_VAR 0 10
68431: NOT
68432: AND
68433: IFFALSE 68437
// continue ;
68435: GO 68252
// x := cts ;
68437: LD_ADDR_VAR 0 11
68441: PUSH
68442: LD_VAR 0 9
68446: ST_TO_ADDR
// if not x then
68447: LD_VAR 0 11
68451: NOT
68452: IFFALSE 68464
// x := mcts ;
68454: LD_ADDR_VAR 0 11
68458: PUSH
68459: LD_VAR 0 10
68463: ST_TO_ADDR
// if not x then
68464: LD_VAR 0 11
68468: NOT
68469: IFFALSE 68473
// continue ;
68471: GO 68252
// if mc_remote_driver [ i ] then
68473: LD_EXP 82
68477: PUSH
68478: LD_VAR 0 2
68482: ARRAY
68483: IFFALSE 68870
// for j in mc_remote_driver [ i ] do
68485: LD_ADDR_VAR 0 3
68489: PUSH
68490: LD_EXP 82
68494: PUSH
68495: LD_VAR 0 2
68499: ARRAY
68500: PUSH
68501: FOR_IN
68502: IFFALSE 68868
// begin if GetClass ( j ) <> 3 then
68504: LD_VAR 0 3
68508: PPUSH
68509: CALL_OW 257
68513: PUSH
68514: LD_INT 3
68516: NONEQUAL
68517: IFFALSE 68570
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
68519: LD_ADDR_EXP 82
68523: PUSH
68524: LD_EXP 82
68528: PPUSH
68529: LD_VAR 0 2
68533: PPUSH
68534: LD_EXP 82
68538: PUSH
68539: LD_VAR 0 2
68543: ARRAY
68544: PUSH
68545: LD_VAR 0 3
68549: DIFF
68550: PPUSH
68551: CALL_OW 1
68555: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68556: LD_VAR 0 3
68560: PPUSH
68561: LD_INT 0
68563: PPUSH
68564: CALL_OW 109
// continue ;
68568: GO 68501
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
68570: LD_EXP 61
68574: PUSH
68575: LD_VAR 0 2
68579: ARRAY
68580: PPUSH
68581: LD_INT 34
68583: PUSH
68584: LD_INT 31
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 58
68593: PUSH
68594: EMPTY
68595: LIST
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: PPUSH
68601: CALL_OW 72
68605: PUSH
68606: LD_VAR 0 3
68610: PPUSH
68611: CALL 43453 0 1
68615: NOT
68616: AND
68617: IFFALSE 68688
// begin if IsInUnit ( j ) then
68619: LD_VAR 0 3
68623: PPUSH
68624: CALL_OW 310
68628: IFFALSE 68639
// ComExitBuilding ( j ) ;
68630: LD_VAR 0 3
68634: PPUSH
68635: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
68639: LD_VAR 0 3
68643: PPUSH
68644: LD_EXP 61
68648: PUSH
68649: LD_VAR 0 2
68653: ARRAY
68654: PPUSH
68655: LD_INT 34
68657: PUSH
68658: LD_INT 31
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: LD_INT 58
68667: PUSH
68668: EMPTY
68669: LIST
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: PPUSH
68675: CALL_OW 72
68679: PUSH
68680: LD_INT 1
68682: ARRAY
68683: PPUSH
68684: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
68688: LD_VAR 0 3
68692: PPUSH
68693: CALL_OW 310
68697: NOT
68698: PUSH
68699: LD_VAR 0 3
68703: PPUSH
68704: CALL_OW 310
68708: PPUSH
68709: CALL_OW 266
68713: PUSH
68714: LD_INT 36
68716: NONEQUAL
68717: PUSH
68718: LD_VAR 0 3
68722: PPUSH
68723: CALL 43453 0 1
68727: NOT
68728: AND
68729: OR
68730: IFFALSE 68866
// begin if IsInUnit ( j ) then
68732: LD_VAR 0 3
68736: PPUSH
68737: CALL_OW 310
68741: IFFALSE 68752
// ComExitBuilding ( j ) ;
68743: LD_VAR 0 3
68747: PPUSH
68748: CALL_OW 122
// ct := 0 ;
68752: LD_ADDR_VAR 0 8
68756: PUSH
68757: LD_INT 0
68759: ST_TO_ADDR
// for k in x do
68760: LD_ADDR_VAR 0 4
68764: PUSH
68765: LD_VAR 0 11
68769: PUSH
68770: FOR_IN
68771: IFFALSE 68844
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
68773: LD_VAR 0 4
68777: PPUSH
68778: CALL_OW 264
68782: PUSH
68783: LD_INT 31
68785: EQUAL
68786: PUSH
68787: LD_VAR 0 4
68791: PPUSH
68792: CALL_OW 311
68796: NOT
68797: AND
68798: PUSH
68799: LD_VAR 0 4
68803: PPUSH
68804: CALL_OW 266
68808: PUSH
68809: LD_INT 36
68811: EQUAL
68812: PUSH
68813: LD_VAR 0 4
68817: PPUSH
68818: CALL_OW 313
68822: PUSH
68823: LD_INT 3
68825: LESS
68826: AND
68827: OR
68828: IFFALSE 68842
// begin ct := k ;
68830: LD_ADDR_VAR 0 8
68834: PUSH
68835: LD_VAR 0 4
68839: ST_TO_ADDR
// break ;
68840: GO 68844
// end ;
68842: GO 68770
68844: POP
68845: POP
// if ct then
68846: LD_VAR 0 8
68850: IFFALSE 68866
// ComEnterUnit ( j , ct ) ;
68852: LD_VAR 0 3
68856: PPUSH
68857: LD_VAR 0 8
68861: PPUSH
68862: CALL_OW 120
// end ; end ;
68866: GO 68501
68868: POP
68869: POP
// places := 0 ;
68870: LD_ADDR_VAR 0 5
68874: PUSH
68875: LD_INT 0
68877: ST_TO_ADDR
// for j = 1 to x do
68878: LD_ADDR_VAR 0 3
68882: PUSH
68883: DOUBLE
68884: LD_INT 1
68886: DEC
68887: ST_TO_ADDR
68888: LD_VAR 0 11
68892: PUSH
68893: FOR_TO
68894: IFFALSE 68970
// if GetWeapon ( x [ j ] ) = ar_control_tower then
68896: LD_VAR 0 11
68900: PUSH
68901: LD_VAR 0 3
68905: ARRAY
68906: PPUSH
68907: CALL_OW 264
68911: PUSH
68912: LD_INT 31
68914: EQUAL
68915: IFFALSE 68933
// places := places + 1 else
68917: LD_ADDR_VAR 0 5
68921: PUSH
68922: LD_VAR 0 5
68926: PUSH
68927: LD_INT 1
68929: PLUS
68930: ST_TO_ADDR
68931: GO 68968
// if GetBType ( x [ j ] ) = b_control_tower then
68933: LD_VAR 0 11
68937: PUSH
68938: LD_VAR 0 3
68942: ARRAY
68943: PPUSH
68944: CALL_OW 266
68948: PUSH
68949: LD_INT 36
68951: EQUAL
68952: IFFALSE 68968
// places := places + 3 ;
68954: LD_ADDR_VAR 0 5
68958: PUSH
68959: LD_VAR 0 5
68963: PUSH
68964: LD_INT 3
68966: PLUS
68967: ST_TO_ADDR
68968: GO 68893
68970: POP
68971: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
68972: LD_VAR 0 5
68976: PUSH
68977: LD_INT 0
68979: EQUAL
68980: PUSH
68981: LD_VAR 0 5
68985: PUSH
68986: LD_EXP 82
68990: PUSH
68991: LD_VAR 0 2
68995: ARRAY
68996: LESSEQUAL
68997: OR
68998: IFFALSE 69002
// continue ;
69000: GO 68252
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
69002: LD_ADDR_VAR 0 6
69006: PUSH
69007: LD_EXP 42
69011: PUSH
69012: LD_VAR 0 2
69016: ARRAY
69017: PPUSH
69018: LD_INT 25
69020: PUSH
69021: LD_INT 3
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PPUSH
69028: CALL_OW 72
69032: PUSH
69033: LD_EXP 82
69037: PUSH
69038: LD_VAR 0 2
69042: ARRAY
69043: DIFF
69044: PPUSH
69045: LD_INT 3
69047: PPUSH
69048: CALL 44353 0 2
69052: ST_TO_ADDR
// for j in tmp do
69053: LD_ADDR_VAR 0 3
69057: PUSH
69058: LD_VAR 0 6
69062: PUSH
69063: FOR_IN
69064: IFFALSE 69099
// if GetTag ( j ) > 0 then
69066: LD_VAR 0 3
69070: PPUSH
69071: CALL_OW 110
69075: PUSH
69076: LD_INT 0
69078: GREATER
69079: IFFALSE 69097
// tmp := tmp diff j ;
69081: LD_ADDR_VAR 0 6
69085: PUSH
69086: LD_VAR 0 6
69090: PUSH
69091: LD_VAR 0 3
69095: DIFF
69096: ST_TO_ADDR
69097: GO 69063
69099: POP
69100: POP
// if not tmp then
69101: LD_VAR 0 6
69105: NOT
69106: IFFALSE 69110
// continue ;
69108: GO 68252
// if places then
69110: LD_VAR 0 5
69114: IFFALSE 69173
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
69116: LD_ADDR_EXP 82
69120: PUSH
69121: LD_EXP 82
69125: PPUSH
69126: LD_VAR 0 2
69130: PPUSH
69131: LD_EXP 82
69135: PUSH
69136: LD_VAR 0 2
69140: ARRAY
69141: PUSH
69142: LD_VAR 0 6
69146: PUSH
69147: LD_INT 1
69149: ARRAY
69150: UNION
69151: PPUSH
69152: CALL_OW 1
69156: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
69157: LD_VAR 0 6
69161: PUSH
69162: LD_INT 1
69164: ARRAY
69165: PPUSH
69166: LD_INT 126
69168: PPUSH
69169: CALL_OW 109
// end ; end ;
69173: GO 68252
69175: POP
69176: POP
// end ;
69177: LD_VAR 0 1
69181: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
69182: LD_INT 0
69184: PPUSH
69185: PPUSH
69186: PPUSH
69187: PPUSH
69188: PPUSH
69189: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
69190: LD_VAR 0 1
69194: NOT
69195: PUSH
69196: LD_VAR 0 2
69200: NOT
69201: OR
69202: PUSH
69203: LD_VAR 0 3
69207: NOT
69208: OR
69209: PUSH
69210: LD_VAR 0 4
69214: PUSH
69215: LD_INT 1
69217: PUSH
69218: LD_INT 2
69220: PUSH
69221: LD_INT 3
69223: PUSH
69224: LD_INT 4
69226: PUSH
69227: LD_INT 5
69229: PUSH
69230: LD_INT 8
69232: PUSH
69233: LD_INT 9
69235: PUSH
69236: LD_INT 15
69238: PUSH
69239: LD_INT 16
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: LIST
69246: LIST
69247: LIST
69248: LIST
69249: LIST
69250: LIST
69251: LIST
69252: IN
69253: NOT
69254: OR
69255: IFFALSE 69259
// exit ;
69257: GO 70159
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
69259: LD_ADDR_VAR 0 2
69263: PUSH
69264: LD_VAR 0 2
69268: PPUSH
69269: LD_INT 21
69271: PUSH
69272: LD_INT 3
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PUSH
69279: LD_INT 24
69281: PUSH
69282: LD_INT 250
69284: PUSH
69285: EMPTY
69286: LIST
69287: LIST
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PPUSH
69293: CALL_OW 72
69297: ST_TO_ADDR
// case class of 1 , 15 :
69298: LD_VAR 0 4
69302: PUSH
69303: LD_INT 1
69305: DOUBLE
69306: EQUAL
69307: IFTRUE 69317
69309: LD_INT 15
69311: DOUBLE
69312: EQUAL
69313: IFTRUE 69317
69315: GO 69402
69317: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
69318: LD_ADDR_VAR 0 8
69322: PUSH
69323: LD_VAR 0 2
69327: PPUSH
69328: LD_INT 2
69330: PUSH
69331: LD_INT 30
69333: PUSH
69334: LD_INT 32
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PUSH
69341: LD_INT 30
69343: PUSH
69344: LD_INT 31
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: LIST
69355: PPUSH
69356: CALL_OW 72
69360: PUSH
69361: LD_VAR 0 2
69365: PPUSH
69366: LD_INT 2
69368: PUSH
69369: LD_INT 30
69371: PUSH
69372: LD_INT 4
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 30
69381: PUSH
69382: LD_INT 5
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: LIST
69393: PPUSH
69394: CALL_OW 72
69398: ADD
69399: ST_TO_ADDR
69400: GO 69648
69402: LD_INT 2
69404: DOUBLE
69405: EQUAL
69406: IFTRUE 69416
69408: LD_INT 16
69410: DOUBLE
69411: EQUAL
69412: IFTRUE 69416
69414: GO 69462
69416: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
69417: LD_ADDR_VAR 0 8
69421: PUSH
69422: LD_VAR 0 2
69426: PPUSH
69427: LD_INT 2
69429: PUSH
69430: LD_INT 30
69432: PUSH
69433: LD_INT 0
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 30
69442: PUSH
69443: LD_INT 1
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: LIST
69454: PPUSH
69455: CALL_OW 72
69459: ST_TO_ADDR
69460: GO 69648
69462: LD_INT 3
69464: DOUBLE
69465: EQUAL
69466: IFTRUE 69470
69468: GO 69516
69470: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
69471: LD_ADDR_VAR 0 8
69475: PUSH
69476: LD_VAR 0 2
69480: PPUSH
69481: LD_INT 2
69483: PUSH
69484: LD_INT 30
69486: PUSH
69487: LD_INT 2
69489: PUSH
69490: EMPTY
69491: LIST
69492: LIST
69493: PUSH
69494: LD_INT 30
69496: PUSH
69497: LD_INT 3
69499: PUSH
69500: EMPTY
69501: LIST
69502: LIST
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: LIST
69508: PPUSH
69509: CALL_OW 72
69513: ST_TO_ADDR
69514: GO 69648
69516: LD_INT 4
69518: DOUBLE
69519: EQUAL
69520: IFTRUE 69524
69522: GO 69581
69524: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
69525: LD_ADDR_VAR 0 8
69529: PUSH
69530: LD_VAR 0 2
69534: PPUSH
69535: LD_INT 2
69537: PUSH
69538: LD_INT 30
69540: PUSH
69541: LD_INT 6
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 30
69550: PUSH
69551: LD_INT 7
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: PUSH
69558: LD_INT 30
69560: PUSH
69561: LD_INT 8
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: LIST
69572: LIST
69573: PPUSH
69574: CALL_OW 72
69578: ST_TO_ADDR
69579: GO 69648
69581: LD_INT 5
69583: DOUBLE
69584: EQUAL
69585: IFTRUE 69601
69587: LD_INT 8
69589: DOUBLE
69590: EQUAL
69591: IFTRUE 69601
69593: LD_INT 9
69595: DOUBLE
69596: EQUAL
69597: IFTRUE 69601
69599: GO 69647
69601: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
69602: LD_ADDR_VAR 0 8
69606: PUSH
69607: LD_VAR 0 2
69611: PPUSH
69612: LD_INT 2
69614: PUSH
69615: LD_INT 30
69617: PUSH
69618: LD_INT 4
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 30
69627: PUSH
69628: LD_INT 5
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: LIST
69639: PPUSH
69640: CALL_OW 72
69644: ST_TO_ADDR
69645: GO 69648
69647: POP
// if not tmp then
69648: LD_VAR 0 8
69652: NOT
69653: IFFALSE 69657
// exit ;
69655: GO 70159
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
69657: LD_VAR 0 4
69661: PUSH
69662: LD_INT 1
69664: PUSH
69665: LD_INT 15
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: IN
69672: PUSH
69673: LD_EXP 51
69677: PUSH
69678: LD_VAR 0 1
69682: ARRAY
69683: AND
69684: IFFALSE 69840
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
69686: LD_ADDR_VAR 0 9
69690: PUSH
69691: LD_EXP 51
69695: PUSH
69696: LD_VAR 0 1
69700: ARRAY
69701: PUSH
69702: LD_INT 1
69704: ARRAY
69705: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
69706: LD_VAR 0 9
69710: PUSH
69711: LD_EXP 52
69715: PUSH
69716: LD_VAR 0 1
69720: ARRAY
69721: IN
69722: NOT
69723: IFFALSE 69838
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
69725: LD_ADDR_EXP 52
69729: PUSH
69730: LD_EXP 52
69734: PPUSH
69735: LD_VAR 0 1
69739: PUSH
69740: LD_EXP 52
69744: PUSH
69745: LD_VAR 0 1
69749: ARRAY
69750: PUSH
69751: LD_INT 1
69753: PLUS
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: PPUSH
69759: LD_VAR 0 9
69763: PPUSH
69764: CALL 14804 0 3
69768: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
69769: LD_ADDR_EXP 51
69773: PUSH
69774: LD_EXP 51
69778: PPUSH
69779: LD_VAR 0 1
69783: PPUSH
69784: LD_EXP 51
69788: PUSH
69789: LD_VAR 0 1
69793: ARRAY
69794: PUSH
69795: LD_VAR 0 9
69799: DIFF
69800: PPUSH
69801: CALL_OW 1
69805: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
69806: LD_VAR 0 3
69810: PPUSH
69811: LD_EXP 52
69815: PUSH
69816: LD_VAR 0 1
69820: ARRAY
69821: PUSH
69822: LD_EXP 52
69826: PUSH
69827: LD_VAR 0 1
69831: ARRAY
69832: ARRAY
69833: PPUSH
69834: CALL_OW 120
// end ; exit ;
69838: GO 70159
// end ; if tmp > 1 then
69840: LD_VAR 0 8
69844: PUSH
69845: LD_INT 1
69847: GREATER
69848: IFFALSE 69952
// for i = 2 to tmp do
69850: LD_ADDR_VAR 0 6
69854: PUSH
69855: DOUBLE
69856: LD_INT 2
69858: DEC
69859: ST_TO_ADDR
69860: LD_VAR 0 8
69864: PUSH
69865: FOR_TO
69866: IFFALSE 69950
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
69868: LD_VAR 0 8
69872: PUSH
69873: LD_VAR 0 6
69877: ARRAY
69878: PPUSH
69879: CALL_OW 461
69883: PUSH
69884: LD_INT 6
69886: EQUAL
69887: IFFALSE 69948
// begin x := tmp [ i ] ;
69889: LD_ADDR_VAR 0 9
69893: PUSH
69894: LD_VAR 0 8
69898: PUSH
69899: LD_VAR 0 6
69903: ARRAY
69904: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
69905: LD_ADDR_VAR 0 8
69909: PUSH
69910: LD_VAR 0 8
69914: PPUSH
69915: LD_VAR 0 6
69919: PPUSH
69920: CALL_OW 3
69924: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
69925: LD_ADDR_VAR 0 8
69929: PUSH
69930: LD_VAR 0 8
69934: PPUSH
69935: LD_INT 1
69937: PPUSH
69938: LD_VAR 0 9
69942: PPUSH
69943: CALL_OW 2
69947: ST_TO_ADDR
// end ;
69948: GO 69865
69950: POP
69951: POP
// for i in tmp do
69952: LD_ADDR_VAR 0 6
69956: PUSH
69957: LD_VAR 0 8
69961: PUSH
69962: FOR_IN
69963: IFFALSE 70032
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
69965: LD_VAR 0 6
69969: PPUSH
69970: CALL_OW 313
69974: PUSH
69975: LD_INT 6
69977: LESS
69978: PUSH
69979: LD_VAR 0 6
69983: PPUSH
69984: CALL_OW 266
69988: PUSH
69989: LD_INT 31
69991: PUSH
69992: LD_INT 32
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: IN
69999: NOT
70000: AND
70001: PUSH
70002: LD_VAR 0 6
70006: PPUSH
70007: CALL_OW 313
70011: PUSH
70012: LD_INT 0
70014: EQUAL
70015: OR
70016: IFFALSE 70030
// begin j := i ;
70018: LD_ADDR_VAR 0 7
70022: PUSH
70023: LD_VAR 0 6
70027: ST_TO_ADDR
// break ;
70028: GO 70032
// end ; end ;
70030: GO 69962
70032: POP
70033: POP
// if j then
70034: LD_VAR 0 7
70038: IFFALSE 70056
// ComEnterUnit ( unit , j ) else
70040: LD_VAR 0 3
70044: PPUSH
70045: LD_VAR 0 7
70049: PPUSH
70050: CALL_OW 120
70054: GO 70159
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70056: LD_ADDR_VAR 0 10
70060: PUSH
70061: LD_VAR 0 2
70065: PPUSH
70066: LD_INT 2
70068: PUSH
70069: LD_INT 30
70071: PUSH
70072: LD_INT 0
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 30
70081: PUSH
70082: LD_INT 1
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: LIST
70093: PPUSH
70094: CALL_OW 72
70098: ST_TO_ADDR
// if depot then
70099: LD_VAR 0 10
70103: IFFALSE 70159
// begin depot := NearestUnitToUnit ( depot , unit ) ;
70105: LD_ADDR_VAR 0 10
70109: PUSH
70110: LD_VAR 0 10
70114: PPUSH
70115: LD_VAR 0 3
70119: PPUSH
70120: CALL_OW 74
70124: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
70125: LD_VAR 0 3
70129: PPUSH
70130: LD_VAR 0 10
70134: PPUSH
70135: CALL_OW 296
70139: PUSH
70140: LD_INT 10
70142: GREATER
70143: IFFALSE 70159
// ComStandNearbyBuilding ( unit , depot ) ;
70145: LD_VAR 0 3
70149: PPUSH
70150: LD_VAR 0 10
70154: PPUSH
70155: CALL 11418 0 2
// end ; end ; end ;
70159: LD_VAR 0 5
70163: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
70164: LD_INT 0
70166: PPUSH
70167: PPUSH
70168: PPUSH
70169: PPUSH
// if not mc_bases then
70170: LD_EXP 42
70174: NOT
70175: IFFALSE 70179
// exit ;
70177: GO 70418
// for i = 1 to mc_bases do
70179: LD_ADDR_VAR 0 2
70183: PUSH
70184: DOUBLE
70185: LD_INT 1
70187: DEC
70188: ST_TO_ADDR
70189: LD_EXP 42
70193: PUSH
70194: FOR_TO
70195: IFFALSE 70416
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
70197: LD_ADDR_VAR 0 4
70201: PUSH
70202: LD_EXP 42
70206: PUSH
70207: LD_VAR 0 2
70211: ARRAY
70212: PPUSH
70213: LD_INT 21
70215: PUSH
70216: LD_INT 1
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PPUSH
70223: CALL_OW 72
70227: PUSH
70228: LD_EXP 71
70232: PUSH
70233: LD_VAR 0 2
70237: ARRAY
70238: UNION
70239: ST_TO_ADDR
// if not tmp then
70240: LD_VAR 0 4
70244: NOT
70245: IFFALSE 70249
// continue ;
70247: GO 70194
// for j in tmp do
70249: LD_ADDR_VAR 0 3
70253: PUSH
70254: LD_VAR 0 4
70258: PUSH
70259: FOR_IN
70260: IFFALSE 70412
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
70262: LD_VAR 0 3
70266: PPUSH
70267: CALL_OW 110
70271: NOT
70272: PUSH
70273: LD_VAR 0 3
70277: PPUSH
70278: CALL_OW 314
70282: NOT
70283: AND
70284: PUSH
70285: LD_VAR 0 3
70289: PPUSH
70290: CALL_OW 311
70294: NOT
70295: AND
70296: PUSH
70297: LD_VAR 0 3
70301: PPUSH
70302: CALL_OW 310
70306: NOT
70307: AND
70308: PUSH
70309: LD_VAR 0 3
70313: PUSH
70314: LD_EXP 45
70318: PUSH
70319: LD_VAR 0 2
70323: ARRAY
70324: PUSH
70325: LD_INT 1
70327: ARRAY
70328: IN
70329: NOT
70330: AND
70331: PUSH
70332: LD_VAR 0 3
70336: PUSH
70337: LD_EXP 45
70341: PUSH
70342: LD_VAR 0 2
70346: ARRAY
70347: PUSH
70348: LD_INT 2
70350: ARRAY
70351: IN
70352: NOT
70353: AND
70354: PUSH
70355: LD_VAR 0 3
70359: PUSH
70360: LD_EXP 54
70364: PUSH
70365: LD_VAR 0 2
70369: ARRAY
70370: IN
70371: NOT
70372: AND
70373: IFFALSE 70410
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
70375: LD_VAR 0 2
70379: PPUSH
70380: LD_EXP 42
70384: PUSH
70385: LD_VAR 0 2
70389: ARRAY
70390: PPUSH
70391: LD_VAR 0 3
70395: PPUSH
70396: LD_VAR 0 3
70400: PPUSH
70401: CALL_OW 257
70405: PPUSH
70406: CALL 69182 0 4
// end ;
70410: GO 70259
70412: POP
70413: POP
// end ;
70414: GO 70194
70416: POP
70417: POP
// end ;
70418: LD_VAR 0 1
70422: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
70423: LD_INT 0
70425: PPUSH
70426: PPUSH
70427: PPUSH
70428: PPUSH
70429: PPUSH
70430: PPUSH
// if not mc_bases [ base ] then
70431: LD_EXP 42
70435: PUSH
70436: LD_VAR 0 1
70440: ARRAY
70441: NOT
70442: IFFALSE 70446
// exit ;
70444: GO 70628
// tmp := [ ] ;
70446: LD_ADDR_VAR 0 6
70450: PUSH
70451: EMPTY
70452: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
70453: LD_ADDR_VAR 0 7
70457: PUSH
70458: LD_VAR 0 3
70462: PPUSH
70463: LD_INT 0
70465: PPUSH
70466: CALL_OW 517
70470: ST_TO_ADDR
// if not list then
70471: LD_VAR 0 7
70475: NOT
70476: IFFALSE 70480
// exit ;
70478: GO 70628
// for i = 1 to amount do
70480: LD_ADDR_VAR 0 5
70484: PUSH
70485: DOUBLE
70486: LD_INT 1
70488: DEC
70489: ST_TO_ADDR
70490: LD_VAR 0 2
70494: PUSH
70495: FOR_TO
70496: IFFALSE 70576
// begin x := rand ( 1 , list [ 1 ] ) ;
70498: LD_ADDR_VAR 0 8
70502: PUSH
70503: LD_INT 1
70505: PPUSH
70506: LD_VAR 0 7
70510: PUSH
70511: LD_INT 1
70513: ARRAY
70514: PPUSH
70515: CALL_OW 12
70519: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
70520: LD_ADDR_VAR 0 6
70524: PUSH
70525: LD_VAR 0 6
70529: PPUSH
70530: LD_VAR 0 5
70534: PPUSH
70535: LD_VAR 0 7
70539: PUSH
70540: LD_INT 1
70542: ARRAY
70543: PUSH
70544: LD_VAR 0 8
70548: ARRAY
70549: PUSH
70550: LD_VAR 0 7
70554: PUSH
70555: LD_INT 2
70557: ARRAY
70558: PUSH
70559: LD_VAR 0 8
70563: ARRAY
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PPUSH
70569: CALL_OW 1
70573: ST_TO_ADDR
// end ;
70574: GO 70495
70576: POP
70577: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
70578: LD_ADDR_EXP 55
70582: PUSH
70583: LD_EXP 55
70587: PPUSH
70588: LD_VAR 0 1
70592: PPUSH
70593: LD_VAR 0 6
70597: PPUSH
70598: CALL_OW 1
70602: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
70603: LD_ADDR_EXP 57
70607: PUSH
70608: LD_EXP 57
70612: PPUSH
70613: LD_VAR 0 1
70617: PPUSH
70618: LD_VAR 0 3
70622: PPUSH
70623: CALL_OW 1
70627: ST_TO_ADDR
// end ;
70628: LD_VAR 0 4
70632: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
70633: LD_INT 0
70635: PPUSH
// if not mc_bases [ base ] then
70636: LD_EXP 42
70640: PUSH
70641: LD_VAR 0 1
70645: ARRAY
70646: NOT
70647: IFFALSE 70651
// exit ;
70649: GO 70676
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
70651: LD_ADDR_EXP 47
70655: PUSH
70656: LD_EXP 47
70660: PPUSH
70661: LD_VAR 0 1
70665: PPUSH
70666: LD_VAR 0 2
70670: PPUSH
70671: CALL_OW 1
70675: ST_TO_ADDR
// end ;
70676: LD_VAR 0 3
70680: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
70681: LD_INT 0
70683: PPUSH
// if not mc_bases [ base ] then
70684: LD_EXP 42
70688: PUSH
70689: LD_VAR 0 1
70693: ARRAY
70694: NOT
70695: IFFALSE 70699
// exit ;
70697: GO 70736
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
70699: LD_ADDR_EXP 47
70703: PUSH
70704: LD_EXP 47
70708: PPUSH
70709: LD_VAR 0 1
70713: PPUSH
70714: LD_EXP 47
70718: PUSH
70719: LD_VAR 0 1
70723: ARRAY
70724: PUSH
70725: LD_VAR 0 2
70729: UNION
70730: PPUSH
70731: CALL_OW 1
70735: ST_TO_ADDR
// end ;
70736: LD_VAR 0 3
70740: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
70741: LD_INT 0
70743: PPUSH
// if not mc_bases [ base ] then
70744: LD_EXP 42
70748: PUSH
70749: LD_VAR 0 1
70753: ARRAY
70754: NOT
70755: IFFALSE 70759
// exit ;
70757: GO 70784
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
70759: LD_ADDR_EXP 63
70763: PUSH
70764: LD_EXP 63
70768: PPUSH
70769: LD_VAR 0 1
70773: PPUSH
70774: LD_VAR 0 2
70778: PPUSH
70779: CALL_OW 1
70783: ST_TO_ADDR
// end ;
70784: LD_VAR 0 3
70788: RET
// export function MC_InsertProduceList ( base , components ) ; begin
70789: LD_INT 0
70791: PPUSH
// if not mc_bases [ base ] then
70792: LD_EXP 42
70796: PUSH
70797: LD_VAR 0 1
70801: ARRAY
70802: NOT
70803: IFFALSE 70807
// exit ;
70805: GO 70844
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
70807: LD_ADDR_EXP 63
70811: PUSH
70812: LD_EXP 63
70816: PPUSH
70817: LD_VAR 0 1
70821: PPUSH
70822: LD_EXP 63
70826: PUSH
70827: LD_VAR 0 1
70831: ARRAY
70832: PUSH
70833: LD_VAR 0 2
70837: ADD
70838: PPUSH
70839: CALL_OW 1
70843: ST_TO_ADDR
// end ;
70844: LD_VAR 0 3
70848: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
70849: LD_INT 0
70851: PPUSH
// if not mc_bases [ base ] then
70852: LD_EXP 42
70856: PUSH
70857: LD_VAR 0 1
70861: ARRAY
70862: NOT
70863: IFFALSE 70867
// exit ;
70865: GO 70921
// mc_defender := Replace ( mc_defender , base , deflist ) ;
70867: LD_ADDR_EXP 64
70871: PUSH
70872: LD_EXP 64
70876: PPUSH
70877: LD_VAR 0 1
70881: PPUSH
70882: LD_VAR 0 2
70886: PPUSH
70887: CALL_OW 1
70891: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
70892: LD_ADDR_EXP 53
70896: PUSH
70897: LD_EXP 53
70901: PPUSH
70902: LD_VAR 0 1
70906: PPUSH
70907: LD_VAR 0 2
70911: PUSH
70912: LD_INT 0
70914: PLUS
70915: PPUSH
70916: CALL_OW 1
70920: ST_TO_ADDR
// end ;
70921: LD_VAR 0 3
70925: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
70926: LD_INT 0
70928: PPUSH
// if not mc_bases [ base ] then
70929: LD_EXP 42
70933: PUSH
70934: LD_VAR 0 1
70938: ARRAY
70939: NOT
70940: IFFALSE 70944
// exit ;
70942: GO 70969
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
70944: LD_ADDR_EXP 53
70948: PUSH
70949: LD_EXP 53
70953: PPUSH
70954: LD_VAR 0 1
70958: PPUSH
70959: LD_VAR 0 2
70963: PPUSH
70964: CALL_OW 1
70968: ST_TO_ADDR
// end ;
70969: LD_VAR 0 3
70973: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
70974: LD_INT 0
70976: PPUSH
70977: PPUSH
70978: PPUSH
70979: PPUSH
// if not mc_bases [ base ] then
70980: LD_EXP 42
70984: PUSH
70985: LD_VAR 0 1
70989: ARRAY
70990: NOT
70991: IFFALSE 70995
// exit ;
70993: GO 71060
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
70995: LD_ADDR_EXP 62
70999: PUSH
71000: LD_EXP 62
71004: PPUSH
71005: LD_VAR 0 1
71009: PUSH
71010: LD_EXP 62
71014: PUSH
71015: LD_VAR 0 1
71019: ARRAY
71020: PUSH
71021: LD_INT 1
71023: PLUS
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PPUSH
71029: LD_VAR 0 1
71033: PUSH
71034: LD_VAR 0 2
71038: PUSH
71039: LD_VAR 0 3
71043: PUSH
71044: LD_VAR 0 4
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: LIST
71053: LIST
71054: PPUSH
71055: CALL 14804 0 3
71059: ST_TO_ADDR
// end ;
71060: LD_VAR 0 5
71064: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
71065: LD_INT 0
71067: PPUSH
// if not mc_bases [ base ] then
71068: LD_EXP 42
71072: PUSH
71073: LD_VAR 0 1
71077: ARRAY
71078: NOT
71079: IFFALSE 71083
// exit ;
71081: GO 71108
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
71083: LD_ADDR_EXP 79
71087: PUSH
71088: LD_EXP 79
71092: PPUSH
71093: LD_VAR 0 1
71097: PPUSH
71098: LD_VAR 0 2
71102: PPUSH
71103: CALL_OW 1
71107: ST_TO_ADDR
// end ;
71108: LD_VAR 0 3
71112: RET
// export function MC_GetMinesField ( base ) ; begin
71113: LD_INT 0
71115: PPUSH
// result := mc_mines [ base ] ;
71116: LD_ADDR_VAR 0 2
71120: PUSH
71121: LD_EXP 55
71125: PUSH
71126: LD_VAR 0 1
71130: ARRAY
71131: ST_TO_ADDR
// end ;
71132: LD_VAR 0 2
71136: RET
// export function MC_GetProduceList ( base ) ; begin
71137: LD_INT 0
71139: PPUSH
// result := mc_produce [ base ] ;
71140: LD_ADDR_VAR 0 2
71144: PUSH
71145: LD_EXP 63
71149: PUSH
71150: LD_VAR 0 1
71154: ARRAY
71155: ST_TO_ADDR
// end ;
71156: LD_VAR 0 2
71160: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
71161: LD_INT 0
71163: PPUSH
71164: PPUSH
// if not mc_bases then
71165: LD_EXP 42
71169: NOT
71170: IFFALSE 71174
// exit ;
71172: GO 71239
// if mc_bases [ base ] then
71174: LD_EXP 42
71178: PUSH
71179: LD_VAR 0 1
71183: ARRAY
71184: IFFALSE 71239
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71186: LD_ADDR_VAR 0 3
71190: PUSH
71191: LD_EXP 42
71195: PUSH
71196: LD_VAR 0 1
71200: ARRAY
71201: PPUSH
71202: LD_INT 30
71204: PUSH
71205: LD_VAR 0 2
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PPUSH
71214: CALL_OW 72
71218: ST_TO_ADDR
// if result then
71219: LD_VAR 0 3
71223: IFFALSE 71239
// result := result [ 1 ] ;
71225: LD_ADDR_VAR 0 3
71229: PUSH
71230: LD_VAR 0 3
71234: PUSH
71235: LD_INT 1
71237: ARRAY
71238: ST_TO_ADDR
// end ; end ;
71239: LD_VAR 0 3
71243: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
71244: LD_INT 0
71246: PPUSH
71247: PPUSH
// if not mc_bases then
71248: LD_EXP 42
71252: NOT
71253: IFFALSE 71257
// exit ;
71255: GO 71302
// if mc_bases [ base ] then
71257: LD_EXP 42
71261: PUSH
71262: LD_VAR 0 1
71266: ARRAY
71267: IFFALSE 71302
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71269: LD_ADDR_VAR 0 3
71273: PUSH
71274: LD_EXP 42
71278: PUSH
71279: LD_VAR 0 1
71283: ARRAY
71284: PPUSH
71285: LD_INT 30
71287: PUSH
71288: LD_VAR 0 2
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PPUSH
71297: CALL_OW 72
71301: ST_TO_ADDR
// end ;
71302: LD_VAR 0 3
71306: RET
// export function MC_SetTame ( base , area ) ; begin
71307: LD_INT 0
71309: PPUSH
// if not mc_bases or not base then
71310: LD_EXP 42
71314: NOT
71315: PUSH
71316: LD_VAR 0 1
71320: NOT
71321: OR
71322: IFFALSE 71326
// exit ;
71324: GO 71351
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
71326: LD_ADDR_EXP 70
71330: PUSH
71331: LD_EXP 70
71335: PPUSH
71336: LD_VAR 0 1
71340: PPUSH
71341: LD_VAR 0 2
71345: PPUSH
71346: CALL_OW 1
71350: ST_TO_ADDR
// end ;
71351: LD_VAR 0 3
71355: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
71356: LD_INT 0
71358: PPUSH
71359: PPUSH
// if not mc_bases or not base then
71360: LD_EXP 42
71364: NOT
71365: PUSH
71366: LD_VAR 0 1
71370: NOT
71371: OR
71372: IFFALSE 71376
// exit ;
71374: GO 71478
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71376: LD_ADDR_VAR 0 4
71380: PUSH
71381: LD_EXP 42
71385: PUSH
71386: LD_VAR 0 1
71390: ARRAY
71391: PPUSH
71392: LD_INT 30
71394: PUSH
71395: LD_VAR 0 2
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PPUSH
71404: CALL_OW 72
71408: ST_TO_ADDR
// if not tmp then
71409: LD_VAR 0 4
71413: NOT
71414: IFFALSE 71418
// exit ;
71416: GO 71478
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
71418: LD_ADDR_EXP 74
71422: PUSH
71423: LD_EXP 74
71427: PPUSH
71428: LD_VAR 0 1
71432: PPUSH
71433: LD_EXP 74
71437: PUSH
71438: LD_VAR 0 1
71442: ARRAY
71443: PPUSH
71444: LD_EXP 74
71448: PUSH
71449: LD_VAR 0 1
71453: ARRAY
71454: PUSH
71455: LD_INT 1
71457: PLUS
71458: PPUSH
71459: LD_VAR 0 4
71463: PUSH
71464: LD_INT 1
71466: ARRAY
71467: PPUSH
71468: CALL_OW 2
71472: PPUSH
71473: CALL_OW 1
71477: ST_TO_ADDR
// end ;
71478: LD_VAR 0 3
71482: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
71483: LD_INT 0
71485: PPUSH
71486: PPUSH
// if not mc_bases or not base or not kinds then
71487: LD_EXP 42
71491: NOT
71492: PUSH
71493: LD_VAR 0 1
71497: NOT
71498: OR
71499: PUSH
71500: LD_VAR 0 2
71504: NOT
71505: OR
71506: IFFALSE 71510
// exit ;
71508: GO 71571
// for i in kinds do
71510: LD_ADDR_VAR 0 4
71514: PUSH
71515: LD_VAR 0 2
71519: PUSH
71520: FOR_IN
71521: IFFALSE 71569
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
71523: LD_ADDR_EXP 76
71527: PUSH
71528: LD_EXP 76
71532: PPUSH
71533: LD_VAR 0 1
71537: PUSH
71538: LD_EXP 76
71542: PUSH
71543: LD_VAR 0 1
71547: ARRAY
71548: PUSH
71549: LD_INT 1
71551: PLUS
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PPUSH
71557: LD_VAR 0 4
71561: PPUSH
71562: CALL 14804 0 3
71566: ST_TO_ADDR
71567: GO 71520
71569: POP
71570: POP
// end ;
71571: LD_VAR 0 3
71575: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
71576: LD_INT 0
71578: PPUSH
// if not mc_bases or not base or not areas then
71579: LD_EXP 42
71583: NOT
71584: PUSH
71585: LD_VAR 0 1
71589: NOT
71590: OR
71591: PUSH
71592: LD_VAR 0 2
71596: NOT
71597: OR
71598: IFFALSE 71602
// exit ;
71600: GO 71627
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
71602: LD_ADDR_EXP 60
71606: PUSH
71607: LD_EXP 60
71611: PPUSH
71612: LD_VAR 0 1
71616: PPUSH
71617: LD_VAR 0 2
71621: PPUSH
71622: CALL_OW 1
71626: ST_TO_ADDR
// end ;
71627: LD_VAR 0 3
71631: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
71632: LD_INT 0
71634: PPUSH
// if not mc_bases or not base or not teleports_exit then
71635: LD_EXP 42
71639: NOT
71640: PUSH
71641: LD_VAR 0 1
71645: NOT
71646: OR
71647: PUSH
71648: LD_VAR 0 2
71652: NOT
71653: OR
71654: IFFALSE 71658
// exit ;
71656: GO 71683
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
71658: LD_ADDR_EXP 77
71662: PUSH
71663: LD_EXP 77
71667: PPUSH
71668: LD_VAR 0 1
71672: PPUSH
71673: LD_VAR 0 2
71677: PPUSH
71678: CALL_OW 1
71682: ST_TO_ADDR
// end ;
71683: LD_VAR 0 3
71687: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
71688: LD_INT 0
71690: PPUSH
71691: PPUSH
71692: PPUSH
// if not mc_bases or not base or not ext_list then
71693: LD_EXP 42
71697: NOT
71698: PUSH
71699: LD_VAR 0 1
71703: NOT
71704: OR
71705: PUSH
71706: LD_VAR 0 5
71710: NOT
71711: OR
71712: IFFALSE 71716
// exit ;
71714: GO 71889
// tmp := GetFacExtXYD ( x , y , d ) ;
71716: LD_ADDR_VAR 0 8
71720: PUSH
71721: LD_VAR 0 2
71725: PPUSH
71726: LD_VAR 0 3
71730: PPUSH
71731: LD_VAR 0 4
71735: PPUSH
71736: CALL 43483 0 3
71740: ST_TO_ADDR
// if not tmp then
71741: LD_VAR 0 8
71745: NOT
71746: IFFALSE 71750
// exit ;
71748: GO 71889
// for i in tmp do
71750: LD_ADDR_VAR 0 7
71754: PUSH
71755: LD_VAR 0 8
71759: PUSH
71760: FOR_IN
71761: IFFALSE 71887
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
71763: LD_ADDR_EXP 47
71767: PUSH
71768: LD_EXP 47
71772: PPUSH
71773: LD_VAR 0 1
71777: PPUSH
71778: LD_EXP 47
71782: PUSH
71783: LD_VAR 0 1
71787: ARRAY
71788: PPUSH
71789: LD_EXP 47
71793: PUSH
71794: LD_VAR 0 1
71798: ARRAY
71799: PUSH
71800: LD_INT 1
71802: PLUS
71803: PPUSH
71804: LD_VAR 0 5
71808: PUSH
71809: LD_INT 1
71811: ARRAY
71812: PUSH
71813: LD_VAR 0 7
71817: PUSH
71818: LD_INT 1
71820: ARRAY
71821: PUSH
71822: LD_VAR 0 7
71826: PUSH
71827: LD_INT 2
71829: ARRAY
71830: PUSH
71831: LD_VAR 0 7
71835: PUSH
71836: LD_INT 3
71838: ARRAY
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: LIST
71844: LIST
71845: PPUSH
71846: CALL_OW 2
71850: PPUSH
71851: CALL_OW 1
71855: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
71856: LD_ADDR_VAR 0 5
71860: PUSH
71861: LD_VAR 0 5
71865: PPUSH
71866: LD_INT 1
71868: PPUSH
71869: CALL_OW 3
71873: ST_TO_ADDR
// if not ext_list then
71874: LD_VAR 0 5
71878: NOT
71879: IFFALSE 71885
// exit ;
71881: POP
71882: POP
71883: GO 71889
// end ;
71885: GO 71760
71887: POP
71888: POP
// end ;
71889: LD_VAR 0 6
71893: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
71894: LD_INT 0
71896: PPUSH
// if not mc_bases or not base or not weapon_list then
71897: LD_EXP 42
71901: NOT
71902: PUSH
71903: LD_VAR 0 1
71907: NOT
71908: OR
71909: PUSH
71910: LD_VAR 0 2
71914: NOT
71915: OR
71916: IFFALSE 71920
// exit ;
71918: GO 71945
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
71920: LD_ADDR_EXP 81
71924: PUSH
71925: LD_EXP 81
71929: PPUSH
71930: LD_VAR 0 1
71934: PPUSH
71935: LD_VAR 0 2
71939: PPUSH
71940: CALL_OW 1
71944: ST_TO_ADDR
// end ;
71945: LD_VAR 0 3
71949: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
71950: LD_INT 0
71952: PPUSH
// if not mc_bases or not base or not tech_list then
71953: LD_EXP 42
71957: NOT
71958: PUSH
71959: LD_VAR 0 1
71963: NOT
71964: OR
71965: PUSH
71966: LD_VAR 0 2
71970: NOT
71971: OR
71972: IFFALSE 71976
// exit ;
71974: GO 72001
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
71976: LD_ADDR_EXP 69
71980: PUSH
71981: LD_EXP 69
71985: PPUSH
71986: LD_VAR 0 1
71990: PPUSH
71991: LD_VAR 0 2
71995: PPUSH
71996: CALL_OW 1
72000: ST_TO_ADDR
// end ;
72001: LD_VAR 0 3
72005: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
72006: LD_INT 0
72008: PPUSH
// if not mc_bases or not parking_area or not base then
72009: LD_EXP 42
72013: NOT
72014: PUSH
72015: LD_VAR 0 2
72019: NOT
72020: OR
72021: PUSH
72022: LD_VAR 0 1
72026: NOT
72027: OR
72028: IFFALSE 72032
// exit ;
72030: GO 72057
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
72032: LD_ADDR_EXP 66
72036: PUSH
72037: LD_EXP 66
72041: PPUSH
72042: LD_VAR 0 1
72046: PPUSH
72047: LD_VAR 0 2
72051: PPUSH
72052: CALL_OW 1
72056: ST_TO_ADDR
// end ;
72057: LD_VAR 0 3
72061: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
72062: LD_INT 0
72064: PPUSH
// if not mc_bases or not base or not scan_area then
72065: LD_EXP 42
72069: NOT
72070: PUSH
72071: LD_VAR 0 1
72075: NOT
72076: OR
72077: PUSH
72078: LD_VAR 0 2
72082: NOT
72083: OR
72084: IFFALSE 72088
// exit ;
72086: GO 72113
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
72088: LD_ADDR_EXP 67
72092: PUSH
72093: LD_EXP 67
72097: PPUSH
72098: LD_VAR 0 1
72102: PPUSH
72103: LD_VAR 0 2
72107: PPUSH
72108: CALL_OW 1
72112: ST_TO_ADDR
// end ;
72113: LD_VAR 0 3
72117: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
72118: LD_INT 0
72120: PPUSH
72121: PPUSH
// if not mc_bases or not base then
72122: LD_EXP 42
72126: NOT
72127: PUSH
72128: LD_VAR 0 1
72132: NOT
72133: OR
72134: IFFALSE 72138
// exit ;
72136: GO 72202
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
72138: LD_ADDR_VAR 0 3
72142: PUSH
72143: LD_INT 1
72145: PUSH
72146: LD_INT 2
72148: PUSH
72149: LD_INT 3
72151: PUSH
72152: LD_INT 4
72154: PUSH
72155: LD_INT 11
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: LIST
72162: LIST
72163: LIST
72164: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
72165: LD_ADDR_EXP 69
72169: PUSH
72170: LD_EXP 69
72174: PPUSH
72175: LD_VAR 0 1
72179: PPUSH
72180: LD_EXP 69
72184: PUSH
72185: LD_VAR 0 1
72189: ARRAY
72190: PUSH
72191: LD_VAR 0 3
72195: DIFF
72196: PPUSH
72197: CALL_OW 1
72201: ST_TO_ADDR
// end ;
72202: LD_VAR 0 2
72206: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
72207: LD_INT 0
72209: PPUSH
// result := mc_vehicles [ base ] ;
72210: LD_ADDR_VAR 0 3
72214: PUSH
72215: LD_EXP 61
72219: PUSH
72220: LD_VAR 0 1
72224: ARRAY
72225: ST_TO_ADDR
// if onlyCombat then
72226: LD_VAR 0 2
72230: IFFALSE 72408
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
72232: LD_ADDR_VAR 0 3
72236: PUSH
72237: LD_VAR 0 3
72241: PUSH
72242: LD_VAR 0 3
72246: PPUSH
72247: LD_INT 2
72249: PUSH
72250: LD_INT 34
72252: PUSH
72253: LD_INT 12
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: LD_INT 34
72262: PUSH
72263: LD_INT 51
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: PUSH
72270: LD_INT 34
72272: PUSH
72273: LD_EXP 86
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 34
72284: PUSH
72285: LD_INT 32
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 34
72294: PUSH
72295: LD_INT 13
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 34
72304: PUSH
72305: LD_INT 52
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 34
72314: PUSH
72315: LD_EXP 91
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: LD_INT 34
72326: PUSH
72327: LD_INT 14
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 34
72336: PUSH
72337: LD_INT 53
72339: PUSH
72340: EMPTY
72341: LIST
72342: LIST
72343: PUSH
72344: LD_INT 34
72346: PUSH
72347: LD_EXP 85
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: LD_INT 34
72358: PUSH
72359: LD_INT 31
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 34
72368: PUSH
72369: LD_INT 48
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: LD_INT 34
72378: PUSH
72379: LD_INT 8
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: EMPTY
72387: LIST
72388: LIST
72389: LIST
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: PPUSH
72402: CALL_OW 72
72406: DIFF
72407: ST_TO_ADDR
// end ; end_of_file
72408: LD_VAR 0 3
72412: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
72413: LD_INT 0
72415: PPUSH
72416: PPUSH
72417: PPUSH
// if not mc_bases or not skirmish then
72418: LD_EXP 42
72422: NOT
72423: PUSH
72424: LD_EXP 40
72428: NOT
72429: OR
72430: IFFALSE 72434
// exit ;
72432: GO 72599
// for i = 1 to mc_bases do
72434: LD_ADDR_VAR 0 4
72438: PUSH
72439: DOUBLE
72440: LD_INT 1
72442: DEC
72443: ST_TO_ADDR
72444: LD_EXP 42
72448: PUSH
72449: FOR_TO
72450: IFFALSE 72597
// begin if sci in mc_bases [ i ] then
72452: LD_VAR 0 2
72456: PUSH
72457: LD_EXP 42
72461: PUSH
72462: LD_VAR 0 4
72466: ARRAY
72467: IN
72468: IFFALSE 72595
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
72470: LD_ADDR_EXP 71
72474: PUSH
72475: LD_EXP 71
72479: PPUSH
72480: LD_VAR 0 4
72484: PUSH
72485: LD_EXP 71
72489: PUSH
72490: LD_VAR 0 4
72494: ARRAY
72495: PUSH
72496: LD_INT 1
72498: PLUS
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: PPUSH
72504: LD_VAR 0 1
72508: PPUSH
72509: CALL 14804 0 3
72513: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
72514: LD_ADDR_VAR 0 5
72518: PUSH
72519: LD_EXP 42
72523: PUSH
72524: LD_VAR 0 4
72528: ARRAY
72529: PPUSH
72530: LD_INT 2
72532: PUSH
72533: LD_INT 30
72535: PUSH
72536: LD_INT 0
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: LD_INT 30
72545: PUSH
72546: LD_INT 1
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: LIST
72557: PPUSH
72558: CALL_OW 72
72562: PPUSH
72563: LD_VAR 0 1
72567: PPUSH
72568: CALL_OW 74
72572: ST_TO_ADDR
// if tmp then
72573: LD_VAR 0 5
72577: IFFALSE 72593
// ComStandNearbyBuilding ( ape , tmp ) ;
72579: LD_VAR 0 1
72583: PPUSH
72584: LD_VAR 0 5
72588: PPUSH
72589: CALL 11418 0 2
// break ;
72593: GO 72597
// end ; end ;
72595: GO 72449
72597: POP
72598: POP
// end ;
72599: LD_VAR 0 3
72603: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
72604: LD_INT 0
72606: PPUSH
72607: PPUSH
72608: PPUSH
// if not mc_bases or not skirmish then
72609: LD_EXP 42
72613: NOT
72614: PUSH
72615: LD_EXP 40
72619: NOT
72620: OR
72621: IFFALSE 72625
// exit ;
72623: GO 72714
// for i = 1 to mc_bases do
72625: LD_ADDR_VAR 0 4
72629: PUSH
72630: DOUBLE
72631: LD_INT 1
72633: DEC
72634: ST_TO_ADDR
72635: LD_EXP 42
72639: PUSH
72640: FOR_TO
72641: IFFALSE 72712
// begin if building in mc_busy_turret_list [ i ] then
72643: LD_VAR 0 1
72647: PUSH
72648: LD_EXP 52
72652: PUSH
72653: LD_VAR 0 4
72657: ARRAY
72658: IN
72659: IFFALSE 72710
// begin tmp := mc_busy_turret_list [ i ] diff building ;
72661: LD_ADDR_VAR 0 5
72665: PUSH
72666: LD_EXP 52
72670: PUSH
72671: LD_VAR 0 4
72675: ARRAY
72676: PUSH
72677: LD_VAR 0 1
72681: DIFF
72682: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
72683: LD_ADDR_EXP 52
72687: PUSH
72688: LD_EXP 52
72692: PPUSH
72693: LD_VAR 0 4
72697: PPUSH
72698: LD_VAR 0 5
72702: PPUSH
72703: CALL_OW 1
72707: ST_TO_ADDR
// break ;
72708: GO 72712
// end ; end ;
72710: GO 72640
72712: POP
72713: POP
// end ;
72714: LD_VAR 0 3
72718: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
72719: LD_INT 0
72721: PPUSH
72722: PPUSH
72723: PPUSH
// if not mc_bases or not skirmish then
72724: LD_EXP 42
72728: NOT
72729: PUSH
72730: LD_EXP 40
72734: NOT
72735: OR
72736: IFFALSE 72740
// exit ;
72738: GO 72939
// for i = 1 to mc_bases do
72740: LD_ADDR_VAR 0 5
72744: PUSH
72745: DOUBLE
72746: LD_INT 1
72748: DEC
72749: ST_TO_ADDR
72750: LD_EXP 42
72754: PUSH
72755: FOR_TO
72756: IFFALSE 72937
// if building in mc_bases [ i ] then
72758: LD_VAR 0 1
72762: PUSH
72763: LD_EXP 42
72767: PUSH
72768: LD_VAR 0 5
72772: ARRAY
72773: IN
72774: IFFALSE 72935
// begin tmp := mc_bases [ i ] diff building ;
72776: LD_ADDR_VAR 0 6
72780: PUSH
72781: LD_EXP 42
72785: PUSH
72786: LD_VAR 0 5
72790: ARRAY
72791: PUSH
72792: LD_VAR 0 1
72796: DIFF
72797: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
72798: LD_ADDR_EXP 42
72802: PUSH
72803: LD_EXP 42
72807: PPUSH
72808: LD_VAR 0 5
72812: PPUSH
72813: LD_VAR 0 6
72817: PPUSH
72818: CALL_OW 1
72822: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
72823: LD_VAR 0 1
72827: PUSH
72828: LD_EXP 50
72832: PUSH
72833: LD_VAR 0 5
72837: ARRAY
72838: IN
72839: IFFALSE 72878
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
72841: LD_ADDR_EXP 50
72845: PUSH
72846: LD_EXP 50
72850: PPUSH
72851: LD_VAR 0 5
72855: PPUSH
72856: LD_EXP 50
72860: PUSH
72861: LD_VAR 0 5
72865: ARRAY
72866: PUSH
72867: LD_VAR 0 1
72871: DIFF
72872: PPUSH
72873: CALL_OW 1
72877: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
72878: LD_VAR 0 1
72882: PUSH
72883: LD_EXP 51
72887: PUSH
72888: LD_VAR 0 5
72892: ARRAY
72893: IN
72894: IFFALSE 72933
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
72896: LD_ADDR_EXP 51
72900: PUSH
72901: LD_EXP 51
72905: PPUSH
72906: LD_VAR 0 5
72910: PPUSH
72911: LD_EXP 51
72915: PUSH
72916: LD_VAR 0 5
72920: ARRAY
72921: PUSH
72922: LD_VAR 0 1
72926: DIFF
72927: PPUSH
72928: CALL_OW 1
72932: ST_TO_ADDR
// break ;
72933: GO 72937
// end ;
72935: GO 72755
72937: POP
72938: POP
// end ;
72939: LD_VAR 0 4
72943: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
72944: LD_INT 0
72946: PPUSH
72947: PPUSH
72948: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
72949: LD_EXP 42
72953: NOT
72954: PUSH
72955: LD_EXP 40
72959: NOT
72960: OR
72961: PUSH
72962: LD_VAR 0 3
72966: PUSH
72967: LD_EXP 68
72971: IN
72972: NOT
72973: OR
72974: IFFALSE 72978
// exit ;
72976: GO 73101
// for i = 1 to mc_vehicles do
72978: LD_ADDR_VAR 0 6
72982: PUSH
72983: DOUBLE
72984: LD_INT 1
72986: DEC
72987: ST_TO_ADDR
72988: LD_EXP 61
72992: PUSH
72993: FOR_TO
72994: IFFALSE 73099
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
72996: LD_VAR 0 2
73000: PUSH
73001: LD_EXP 61
73005: PUSH
73006: LD_VAR 0 6
73010: ARRAY
73011: IN
73012: PUSH
73013: LD_VAR 0 1
73017: PUSH
73018: LD_EXP 61
73022: PUSH
73023: LD_VAR 0 6
73027: ARRAY
73028: IN
73029: OR
73030: IFFALSE 73097
// begin tmp := mc_vehicles [ i ] diff old ;
73032: LD_ADDR_VAR 0 7
73036: PUSH
73037: LD_EXP 61
73041: PUSH
73042: LD_VAR 0 6
73046: ARRAY
73047: PUSH
73048: LD_VAR 0 2
73052: DIFF
73053: ST_TO_ADDR
// tmp := tmp diff new ;
73054: LD_ADDR_VAR 0 7
73058: PUSH
73059: LD_VAR 0 7
73063: PUSH
73064: LD_VAR 0 1
73068: DIFF
73069: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
73070: LD_ADDR_EXP 61
73074: PUSH
73075: LD_EXP 61
73079: PPUSH
73080: LD_VAR 0 6
73084: PPUSH
73085: LD_VAR 0 7
73089: PPUSH
73090: CALL_OW 1
73094: ST_TO_ADDR
// break ;
73095: GO 73099
// end ;
73097: GO 72993
73099: POP
73100: POP
// end ;
73101: LD_VAR 0 5
73105: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
73106: LD_INT 0
73108: PPUSH
73109: PPUSH
73110: PPUSH
73111: PPUSH
// if not mc_bases or not skirmish then
73112: LD_EXP 42
73116: NOT
73117: PUSH
73118: LD_EXP 40
73122: NOT
73123: OR
73124: IFFALSE 73128
// exit ;
73126: GO 73511
// side := GetSide ( vehicle ) ;
73128: LD_ADDR_VAR 0 5
73132: PUSH
73133: LD_VAR 0 1
73137: PPUSH
73138: CALL_OW 255
73142: ST_TO_ADDR
// for i = 1 to mc_bases do
73143: LD_ADDR_VAR 0 4
73147: PUSH
73148: DOUBLE
73149: LD_INT 1
73151: DEC
73152: ST_TO_ADDR
73153: LD_EXP 42
73157: PUSH
73158: FOR_TO
73159: IFFALSE 73509
// begin if factory in mc_bases [ i ] then
73161: LD_VAR 0 2
73165: PUSH
73166: LD_EXP 42
73170: PUSH
73171: LD_VAR 0 4
73175: ARRAY
73176: IN
73177: IFFALSE 73507
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
73179: LD_EXP 64
73183: PUSH
73184: LD_VAR 0 4
73188: ARRAY
73189: PUSH
73190: LD_EXP 53
73194: PUSH
73195: LD_VAR 0 4
73199: ARRAY
73200: LESS
73201: PUSH
73202: LD_VAR 0 1
73206: PPUSH
73207: CALL_OW 264
73211: PUSH
73212: LD_INT 31
73214: PUSH
73215: LD_INT 32
73217: PUSH
73218: LD_INT 51
73220: PUSH
73221: LD_EXP 86
73225: PUSH
73226: LD_INT 12
73228: PUSH
73229: LD_INT 30
73231: PUSH
73232: LD_EXP 85
73236: PUSH
73237: LD_INT 11
73239: PUSH
73240: LD_INT 53
73242: PUSH
73243: LD_INT 14
73245: PUSH
73246: LD_EXP 89
73250: PUSH
73251: LD_INT 29
73253: PUSH
73254: LD_EXP 87
73258: PUSH
73259: LD_INT 13
73261: PUSH
73262: LD_INT 52
73264: PUSH
73265: LD_EXP 91
73269: PUSH
73270: LD_INT 48
73272: PUSH
73273: LD_INT 8
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: IN
73296: NOT
73297: AND
73298: IFFALSE 73346
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
73300: LD_ADDR_EXP 64
73304: PUSH
73305: LD_EXP 64
73309: PPUSH
73310: LD_VAR 0 4
73314: PUSH
73315: LD_EXP 64
73319: PUSH
73320: LD_VAR 0 4
73324: ARRAY
73325: PUSH
73326: LD_INT 1
73328: PLUS
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PPUSH
73334: LD_VAR 0 1
73338: PPUSH
73339: CALL 14804 0 3
73343: ST_TO_ADDR
73344: GO 73390
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
73346: LD_ADDR_EXP 61
73350: PUSH
73351: LD_EXP 61
73355: PPUSH
73356: LD_VAR 0 4
73360: PUSH
73361: LD_EXP 61
73365: PUSH
73366: LD_VAR 0 4
73370: ARRAY
73371: PUSH
73372: LD_INT 1
73374: PLUS
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PPUSH
73380: LD_VAR 0 1
73384: PPUSH
73385: CALL 14804 0 3
73389: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
73390: LD_VAR 0 1
73394: PPUSH
73395: CALL_OW 263
73399: PUSH
73400: LD_INT 2
73402: EQUAL
73403: IFFALSE 73423
// begin repeat wait ( 0 0$1 ) ;
73405: LD_INT 35
73407: PPUSH
73408: CALL_OW 67
// until IsControledBy ( vehicle ) ;
73412: LD_VAR 0 1
73416: PPUSH
73417: CALL_OW 312
73421: IFFALSE 73405
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
73423: LD_VAR 0 1
73427: PPUSH
73428: LD_EXP 66
73432: PUSH
73433: LD_VAR 0 4
73437: ARRAY
73438: PPUSH
73439: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
73443: LD_VAR 0 1
73447: PPUSH
73448: CALL_OW 263
73452: PUSH
73453: LD_INT 1
73455: NONEQUAL
73456: IFFALSE 73460
// break ;
73458: GO 73509
// repeat wait ( 0 0$1 ) ;
73460: LD_INT 35
73462: PPUSH
73463: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
73467: LD_VAR 0 1
73471: PPUSH
73472: LD_EXP 66
73476: PUSH
73477: LD_VAR 0 4
73481: ARRAY
73482: PPUSH
73483: CALL_OW 308
73487: IFFALSE 73460
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
73489: LD_VAR 0 1
73493: PPUSH
73494: CALL_OW 311
73498: PPUSH
73499: CALL_OW 121
// exit ;
73503: POP
73504: POP
73505: GO 73511
// end ; end ;
73507: GO 73158
73509: POP
73510: POP
// end ;
73511: LD_VAR 0 3
73515: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
73516: LD_INT 0
73518: PPUSH
73519: PPUSH
73520: PPUSH
73521: PPUSH
// if not mc_bases or not skirmish then
73522: LD_EXP 42
73526: NOT
73527: PUSH
73528: LD_EXP 40
73532: NOT
73533: OR
73534: IFFALSE 73538
// exit ;
73536: GO 73891
// repeat wait ( 0 0$1 ) ;
73538: LD_INT 35
73540: PPUSH
73541: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
73545: LD_VAR 0 2
73549: PPUSH
73550: LD_VAR 0 3
73554: PPUSH
73555: CALL_OW 284
73559: IFFALSE 73538
// if GetResourceTypeXY ( x , y ) = mat_artefact then
73561: LD_VAR 0 2
73565: PPUSH
73566: LD_VAR 0 3
73570: PPUSH
73571: CALL_OW 283
73575: PUSH
73576: LD_INT 4
73578: EQUAL
73579: IFFALSE 73583
// exit ;
73581: GO 73891
// for i = 1 to mc_bases do
73583: LD_ADDR_VAR 0 7
73587: PUSH
73588: DOUBLE
73589: LD_INT 1
73591: DEC
73592: ST_TO_ADDR
73593: LD_EXP 42
73597: PUSH
73598: FOR_TO
73599: IFFALSE 73889
// begin if mc_crates_area [ i ] then
73601: LD_EXP 60
73605: PUSH
73606: LD_VAR 0 7
73610: ARRAY
73611: IFFALSE 73722
// for j in mc_crates_area [ i ] do
73613: LD_ADDR_VAR 0 8
73617: PUSH
73618: LD_EXP 60
73622: PUSH
73623: LD_VAR 0 7
73627: ARRAY
73628: PUSH
73629: FOR_IN
73630: IFFALSE 73720
// if InArea ( x , y , j ) then
73632: LD_VAR 0 2
73636: PPUSH
73637: LD_VAR 0 3
73641: PPUSH
73642: LD_VAR 0 8
73646: PPUSH
73647: CALL_OW 309
73651: IFFALSE 73718
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73653: LD_ADDR_EXP 58
73657: PUSH
73658: LD_EXP 58
73662: PPUSH
73663: LD_VAR 0 7
73667: PUSH
73668: LD_EXP 58
73672: PUSH
73673: LD_VAR 0 7
73677: ARRAY
73678: PUSH
73679: LD_INT 1
73681: PLUS
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PPUSH
73687: LD_VAR 0 4
73691: PUSH
73692: LD_VAR 0 2
73696: PUSH
73697: LD_VAR 0 3
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: LIST
73706: PPUSH
73707: CALL 14804 0 3
73711: ST_TO_ADDR
// exit ;
73712: POP
73713: POP
73714: POP
73715: POP
73716: GO 73891
// end ;
73718: GO 73629
73720: POP
73721: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73722: LD_ADDR_VAR 0 9
73726: PUSH
73727: LD_EXP 42
73731: PUSH
73732: LD_VAR 0 7
73736: ARRAY
73737: PPUSH
73738: LD_INT 2
73740: PUSH
73741: LD_INT 30
73743: PUSH
73744: LD_INT 0
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: PUSH
73751: LD_INT 30
73753: PUSH
73754: LD_INT 1
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: LIST
73765: PPUSH
73766: CALL_OW 72
73770: ST_TO_ADDR
// if not depot then
73771: LD_VAR 0 9
73775: NOT
73776: IFFALSE 73780
// continue ;
73778: GO 73598
// for j in depot do
73780: LD_ADDR_VAR 0 8
73784: PUSH
73785: LD_VAR 0 9
73789: PUSH
73790: FOR_IN
73791: IFFALSE 73885
// if GetDistUnitXY ( j , x , y ) < 30 then
73793: LD_VAR 0 8
73797: PPUSH
73798: LD_VAR 0 2
73802: PPUSH
73803: LD_VAR 0 3
73807: PPUSH
73808: CALL_OW 297
73812: PUSH
73813: LD_INT 30
73815: LESS
73816: IFFALSE 73883
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73818: LD_ADDR_EXP 58
73822: PUSH
73823: LD_EXP 58
73827: PPUSH
73828: LD_VAR 0 7
73832: PUSH
73833: LD_EXP 58
73837: PUSH
73838: LD_VAR 0 7
73842: ARRAY
73843: PUSH
73844: LD_INT 1
73846: PLUS
73847: PUSH
73848: EMPTY
73849: LIST
73850: LIST
73851: PPUSH
73852: LD_VAR 0 4
73856: PUSH
73857: LD_VAR 0 2
73861: PUSH
73862: LD_VAR 0 3
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: LIST
73871: PPUSH
73872: CALL 14804 0 3
73876: ST_TO_ADDR
// exit ;
73877: POP
73878: POP
73879: POP
73880: POP
73881: GO 73891
// end ;
73883: GO 73790
73885: POP
73886: POP
// end ;
73887: GO 73598
73889: POP
73890: POP
// end ;
73891: LD_VAR 0 6
73895: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
73896: LD_INT 0
73898: PPUSH
73899: PPUSH
73900: PPUSH
73901: PPUSH
// if not mc_bases or not skirmish then
73902: LD_EXP 42
73906: NOT
73907: PUSH
73908: LD_EXP 40
73912: NOT
73913: OR
73914: IFFALSE 73918
// exit ;
73916: GO 74195
// side := GetSide ( lab ) ;
73918: LD_ADDR_VAR 0 4
73922: PUSH
73923: LD_VAR 0 2
73927: PPUSH
73928: CALL_OW 255
73932: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
73933: LD_VAR 0 4
73937: PUSH
73938: LD_EXP 68
73942: IN
73943: NOT
73944: PUSH
73945: LD_EXP 69
73949: NOT
73950: OR
73951: PUSH
73952: LD_EXP 42
73956: NOT
73957: OR
73958: IFFALSE 73962
// exit ;
73960: GO 74195
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
73962: LD_ADDR_EXP 69
73966: PUSH
73967: LD_EXP 69
73971: PPUSH
73972: LD_VAR 0 4
73976: PPUSH
73977: LD_EXP 69
73981: PUSH
73982: LD_VAR 0 4
73986: ARRAY
73987: PUSH
73988: LD_VAR 0 1
73992: DIFF
73993: PPUSH
73994: CALL_OW 1
73998: ST_TO_ADDR
// for i = 1 to mc_bases do
73999: LD_ADDR_VAR 0 5
74003: PUSH
74004: DOUBLE
74005: LD_INT 1
74007: DEC
74008: ST_TO_ADDR
74009: LD_EXP 42
74013: PUSH
74014: FOR_TO
74015: IFFALSE 74193
// begin if lab in mc_bases [ i ] then
74017: LD_VAR 0 2
74021: PUSH
74022: LD_EXP 42
74026: PUSH
74027: LD_VAR 0 5
74031: ARRAY
74032: IN
74033: IFFALSE 74191
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
74035: LD_VAR 0 1
74039: PUSH
74040: LD_INT 11
74042: PUSH
74043: LD_INT 4
74045: PUSH
74046: LD_INT 3
74048: PUSH
74049: LD_INT 2
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: IN
74058: PUSH
74059: LD_EXP 72
74063: PUSH
74064: LD_VAR 0 5
74068: ARRAY
74069: AND
74070: IFFALSE 74191
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
74072: LD_ADDR_VAR 0 6
74076: PUSH
74077: LD_EXP 72
74081: PUSH
74082: LD_VAR 0 5
74086: ARRAY
74087: PUSH
74088: LD_INT 1
74090: ARRAY
74091: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74092: LD_ADDR_EXP 72
74096: PUSH
74097: LD_EXP 72
74101: PPUSH
74102: LD_VAR 0 5
74106: PPUSH
74107: EMPTY
74108: PPUSH
74109: CALL_OW 1
74113: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
74114: LD_VAR 0 6
74118: PPUSH
74119: LD_INT 0
74121: PPUSH
74122: CALL_OW 109
// ComExitBuilding ( tmp ) ;
74126: LD_VAR 0 6
74130: PPUSH
74131: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
74135: LD_ADDR_EXP 71
74139: PUSH
74140: LD_EXP 71
74144: PPUSH
74145: LD_VAR 0 5
74149: PPUSH
74150: LD_EXP 71
74154: PUSH
74155: LD_VAR 0 5
74159: ARRAY
74160: PPUSH
74161: LD_INT 1
74163: PPUSH
74164: LD_VAR 0 6
74168: PPUSH
74169: CALL_OW 2
74173: PPUSH
74174: CALL_OW 1
74178: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
74179: LD_VAR 0 5
74183: PPUSH
74184: LD_INT 112
74186: PPUSH
74187: CALL 51140 0 2
// end ; end ; end ;
74191: GO 74014
74193: POP
74194: POP
// end ;
74195: LD_VAR 0 3
74199: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
74200: LD_INT 0
74202: PPUSH
74203: PPUSH
74204: PPUSH
74205: PPUSH
74206: PPUSH
74207: PPUSH
74208: PPUSH
74209: PPUSH
// if not mc_bases or not skirmish then
74210: LD_EXP 42
74214: NOT
74215: PUSH
74216: LD_EXP 40
74220: NOT
74221: OR
74222: IFFALSE 74226
// exit ;
74224: GO 75597
// for i = 1 to mc_bases do
74226: LD_ADDR_VAR 0 3
74230: PUSH
74231: DOUBLE
74232: LD_INT 1
74234: DEC
74235: ST_TO_ADDR
74236: LD_EXP 42
74240: PUSH
74241: FOR_TO
74242: IFFALSE 75595
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
74244: LD_VAR 0 1
74248: PUSH
74249: LD_EXP 42
74253: PUSH
74254: LD_VAR 0 3
74258: ARRAY
74259: IN
74260: PUSH
74261: LD_VAR 0 1
74265: PUSH
74266: LD_EXP 49
74270: PUSH
74271: LD_VAR 0 3
74275: ARRAY
74276: IN
74277: OR
74278: PUSH
74279: LD_VAR 0 1
74283: PUSH
74284: LD_EXP 64
74288: PUSH
74289: LD_VAR 0 3
74293: ARRAY
74294: IN
74295: OR
74296: PUSH
74297: LD_VAR 0 1
74301: PUSH
74302: LD_EXP 61
74306: PUSH
74307: LD_VAR 0 3
74311: ARRAY
74312: IN
74313: OR
74314: PUSH
74315: LD_VAR 0 1
74319: PUSH
74320: LD_EXP 71
74324: PUSH
74325: LD_VAR 0 3
74329: ARRAY
74330: IN
74331: OR
74332: PUSH
74333: LD_VAR 0 1
74337: PUSH
74338: LD_EXP 72
74342: PUSH
74343: LD_VAR 0 3
74347: ARRAY
74348: IN
74349: OR
74350: IFFALSE 75593
// begin if un in mc_ape [ i ] then
74352: LD_VAR 0 1
74356: PUSH
74357: LD_EXP 71
74361: PUSH
74362: LD_VAR 0 3
74366: ARRAY
74367: IN
74368: IFFALSE 74407
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
74370: LD_ADDR_EXP 71
74374: PUSH
74375: LD_EXP 71
74379: PPUSH
74380: LD_VAR 0 3
74384: PPUSH
74385: LD_EXP 71
74389: PUSH
74390: LD_VAR 0 3
74394: ARRAY
74395: PUSH
74396: LD_VAR 0 1
74400: DIFF
74401: PPUSH
74402: CALL_OW 1
74406: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
74407: LD_VAR 0 1
74411: PUSH
74412: LD_EXP 72
74416: PUSH
74417: LD_VAR 0 3
74421: ARRAY
74422: IN
74423: IFFALSE 74447
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74425: LD_ADDR_EXP 72
74429: PUSH
74430: LD_EXP 72
74434: PPUSH
74435: LD_VAR 0 3
74439: PPUSH
74440: EMPTY
74441: PPUSH
74442: CALL_OW 1
74446: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
74447: LD_VAR 0 1
74451: PPUSH
74452: CALL_OW 247
74456: PUSH
74457: LD_INT 2
74459: EQUAL
74460: PUSH
74461: LD_VAR 0 1
74465: PPUSH
74466: CALL_OW 110
74470: PUSH
74471: LD_INT 20
74473: EQUAL
74474: PUSH
74475: LD_VAR 0 1
74479: PUSH
74480: LD_EXP 64
74484: PUSH
74485: LD_VAR 0 3
74489: ARRAY
74490: IN
74491: OR
74492: PUSH
74493: LD_VAR 0 1
74497: PPUSH
74498: CALL_OW 264
74502: PUSH
74503: LD_INT 12
74505: PUSH
74506: LD_INT 51
74508: PUSH
74509: LD_EXP 86
74513: PUSH
74514: LD_INT 32
74516: PUSH
74517: LD_INT 13
74519: PUSH
74520: LD_INT 52
74522: PUSH
74523: LD_INT 31
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: LIST
74530: LIST
74531: LIST
74532: LIST
74533: LIST
74534: IN
74535: OR
74536: AND
74537: IFFALSE 74845
// begin if un in mc_defender [ i ] then
74539: LD_VAR 0 1
74543: PUSH
74544: LD_EXP 64
74548: PUSH
74549: LD_VAR 0 3
74553: ARRAY
74554: IN
74555: IFFALSE 74594
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
74557: LD_ADDR_EXP 64
74561: PUSH
74562: LD_EXP 64
74566: PPUSH
74567: LD_VAR 0 3
74571: PPUSH
74572: LD_EXP 64
74576: PUSH
74577: LD_VAR 0 3
74581: ARRAY
74582: PUSH
74583: LD_VAR 0 1
74587: DIFF
74588: PPUSH
74589: CALL_OW 1
74593: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
74594: LD_ADDR_VAR 0 8
74598: PUSH
74599: LD_VAR 0 3
74603: PPUSH
74604: LD_INT 3
74606: PPUSH
74607: CALL 71244 0 2
74611: ST_TO_ADDR
// if fac then
74612: LD_VAR 0 8
74616: IFFALSE 74845
// begin for j in fac do
74618: LD_ADDR_VAR 0 4
74622: PUSH
74623: LD_VAR 0 8
74627: PUSH
74628: FOR_IN
74629: IFFALSE 74843
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
74631: LD_ADDR_VAR 0 9
74635: PUSH
74636: LD_VAR 0 8
74640: PPUSH
74641: LD_VAR 0 1
74645: PPUSH
74646: CALL_OW 265
74650: PPUSH
74651: LD_VAR 0 1
74655: PPUSH
74656: CALL_OW 262
74660: PPUSH
74661: LD_VAR 0 1
74665: PPUSH
74666: CALL_OW 263
74670: PPUSH
74671: LD_VAR 0 1
74675: PPUSH
74676: CALL_OW 264
74680: PPUSH
74681: CALL 12336 0 5
74685: ST_TO_ADDR
// if components then
74686: LD_VAR 0 9
74690: IFFALSE 74841
// begin if GetWeapon ( un ) = ar_control_tower then
74692: LD_VAR 0 1
74696: PPUSH
74697: CALL_OW 264
74701: PUSH
74702: LD_INT 31
74704: EQUAL
74705: IFFALSE 74822
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
74707: LD_VAR 0 1
74711: PPUSH
74712: CALL_OW 311
74716: PPUSH
74717: LD_INT 0
74719: PPUSH
74720: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
74724: LD_ADDR_EXP 82
74728: PUSH
74729: LD_EXP 82
74733: PPUSH
74734: LD_VAR 0 3
74738: PPUSH
74739: LD_EXP 82
74743: PUSH
74744: LD_VAR 0 3
74748: ARRAY
74749: PUSH
74750: LD_VAR 0 1
74754: PPUSH
74755: CALL_OW 311
74759: DIFF
74760: PPUSH
74761: CALL_OW 1
74765: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
74766: LD_ADDR_VAR 0 7
74770: PUSH
74771: LD_EXP 63
74775: PUSH
74776: LD_VAR 0 3
74780: ARRAY
74781: PPUSH
74782: LD_INT 1
74784: PPUSH
74785: LD_VAR 0 9
74789: PPUSH
74790: CALL_OW 2
74794: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
74795: LD_ADDR_EXP 63
74799: PUSH
74800: LD_EXP 63
74804: PPUSH
74805: LD_VAR 0 3
74809: PPUSH
74810: LD_VAR 0 7
74814: PPUSH
74815: CALL_OW 1
74819: ST_TO_ADDR
// end else
74820: GO 74839
// MC_InsertProduceList ( i , [ components ] ) ;
74822: LD_VAR 0 3
74826: PPUSH
74827: LD_VAR 0 9
74831: PUSH
74832: EMPTY
74833: LIST
74834: PPUSH
74835: CALL 70789 0 2
// break ;
74839: GO 74843
// end ; end ;
74841: GO 74628
74843: POP
74844: POP
// end ; end ; if GetType ( un ) = unit_building then
74845: LD_VAR 0 1
74849: PPUSH
74850: CALL_OW 247
74854: PUSH
74855: LD_INT 3
74857: EQUAL
74858: IFFALSE 75261
// begin btype := GetBType ( un ) ;
74860: LD_ADDR_VAR 0 5
74864: PUSH
74865: LD_VAR 0 1
74869: PPUSH
74870: CALL_OW 266
74874: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
74875: LD_VAR 0 5
74879: PUSH
74880: LD_INT 29
74882: PUSH
74883: LD_INT 30
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: IN
74890: IFFALSE 74963
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
74892: LD_VAR 0 1
74896: PPUSH
74897: CALL_OW 250
74901: PPUSH
74902: LD_VAR 0 1
74906: PPUSH
74907: CALL_OW 251
74911: PPUSH
74912: LD_VAR 0 1
74916: PPUSH
74917: CALL_OW 255
74921: PPUSH
74922: CALL_OW 440
74926: NOT
74927: IFFALSE 74963
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
74929: LD_VAR 0 1
74933: PPUSH
74934: CALL_OW 250
74938: PPUSH
74939: LD_VAR 0 1
74943: PPUSH
74944: CALL_OW 251
74948: PPUSH
74949: LD_VAR 0 1
74953: PPUSH
74954: CALL_OW 255
74958: PPUSH
74959: CALL_OW 441
// end ; if btype = b_warehouse then
74963: LD_VAR 0 5
74967: PUSH
74968: LD_INT 1
74970: EQUAL
74971: IFFALSE 74989
// begin btype := b_depot ;
74973: LD_ADDR_VAR 0 5
74977: PUSH
74978: LD_INT 0
74980: ST_TO_ADDR
// pos := 1 ;
74981: LD_ADDR_VAR 0 6
74985: PUSH
74986: LD_INT 1
74988: ST_TO_ADDR
// end ; if btype = b_factory then
74989: LD_VAR 0 5
74993: PUSH
74994: LD_INT 3
74996: EQUAL
74997: IFFALSE 75015
// begin btype := b_workshop ;
74999: LD_ADDR_VAR 0 5
75003: PUSH
75004: LD_INT 2
75006: ST_TO_ADDR
// pos := 1 ;
75007: LD_ADDR_VAR 0 6
75011: PUSH
75012: LD_INT 1
75014: ST_TO_ADDR
// end ; if btype = b_barracks then
75015: LD_VAR 0 5
75019: PUSH
75020: LD_INT 5
75022: EQUAL
75023: IFFALSE 75033
// btype := b_armoury ;
75025: LD_ADDR_VAR 0 5
75029: PUSH
75030: LD_INT 4
75032: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
75033: LD_VAR 0 5
75037: PUSH
75038: LD_INT 7
75040: PUSH
75041: LD_INT 8
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: IN
75048: IFFALSE 75058
// btype := b_lab ;
75050: LD_ADDR_VAR 0 5
75054: PUSH
75055: LD_INT 6
75057: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
75058: LD_ADDR_EXP 47
75062: PUSH
75063: LD_EXP 47
75067: PPUSH
75068: LD_VAR 0 3
75072: PUSH
75073: LD_EXP 47
75077: PUSH
75078: LD_VAR 0 3
75082: ARRAY
75083: PUSH
75084: LD_INT 1
75086: PLUS
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PPUSH
75092: LD_VAR 0 5
75096: PUSH
75097: LD_VAR 0 1
75101: PPUSH
75102: CALL_OW 250
75106: PUSH
75107: LD_VAR 0 1
75111: PPUSH
75112: CALL_OW 251
75116: PUSH
75117: LD_VAR 0 1
75121: PPUSH
75122: CALL_OW 254
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: PPUSH
75133: CALL 14804 0 3
75137: ST_TO_ADDR
// if pos = 1 then
75138: LD_VAR 0 6
75142: PUSH
75143: LD_INT 1
75145: EQUAL
75146: IFFALSE 75261
// begin tmp := mc_build_list [ i ] ;
75148: LD_ADDR_VAR 0 7
75152: PUSH
75153: LD_EXP 47
75157: PUSH
75158: LD_VAR 0 3
75162: ARRAY
75163: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75164: LD_VAR 0 7
75168: PPUSH
75169: LD_INT 2
75171: PUSH
75172: LD_INT 30
75174: PUSH
75175: LD_INT 0
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 30
75184: PUSH
75185: LD_INT 1
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: LIST
75196: PPUSH
75197: CALL_OW 72
75201: IFFALSE 75211
// pos := 2 ;
75203: LD_ADDR_VAR 0 6
75207: PUSH
75208: LD_INT 2
75210: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
75211: LD_ADDR_VAR 0 7
75215: PUSH
75216: LD_VAR 0 7
75220: PPUSH
75221: LD_VAR 0 6
75225: PPUSH
75226: LD_VAR 0 7
75230: PPUSH
75231: CALL 15130 0 3
75235: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
75236: LD_ADDR_EXP 47
75240: PUSH
75241: LD_EXP 47
75245: PPUSH
75246: LD_VAR 0 3
75250: PPUSH
75251: LD_VAR 0 7
75255: PPUSH
75256: CALL_OW 1
75260: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
75261: LD_VAR 0 1
75265: PUSH
75266: LD_EXP 42
75270: PUSH
75271: LD_VAR 0 3
75275: ARRAY
75276: IN
75277: IFFALSE 75316
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
75279: LD_ADDR_EXP 42
75283: PUSH
75284: LD_EXP 42
75288: PPUSH
75289: LD_VAR 0 3
75293: PPUSH
75294: LD_EXP 42
75298: PUSH
75299: LD_VAR 0 3
75303: ARRAY
75304: PUSH
75305: LD_VAR 0 1
75309: DIFF
75310: PPUSH
75311: CALL_OW 1
75315: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
75316: LD_VAR 0 1
75320: PUSH
75321: LD_EXP 49
75325: PUSH
75326: LD_VAR 0 3
75330: ARRAY
75331: IN
75332: IFFALSE 75371
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
75334: LD_ADDR_EXP 49
75338: PUSH
75339: LD_EXP 49
75343: PPUSH
75344: LD_VAR 0 3
75348: PPUSH
75349: LD_EXP 49
75353: PUSH
75354: LD_VAR 0 3
75358: ARRAY
75359: PUSH
75360: LD_VAR 0 1
75364: DIFF
75365: PPUSH
75366: CALL_OW 1
75370: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
75371: LD_VAR 0 1
75375: PUSH
75376: LD_EXP 61
75380: PUSH
75381: LD_VAR 0 3
75385: ARRAY
75386: IN
75387: IFFALSE 75426
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
75389: LD_ADDR_EXP 61
75393: PUSH
75394: LD_EXP 61
75398: PPUSH
75399: LD_VAR 0 3
75403: PPUSH
75404: LD_EXP 61
75408: PUSH
75409: LD_VAR 0 3
75413: ARRAY
75414: PUSH
75415: LD_VAR 0 1
75419: DIFF
75420: PPUSH
75421: CALL_OW 1
75425: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
75426: LD_VAR 0 1
75430: PUSH
75431: LD_EXP 64
75435: PUSH
75436: LD_VAR 0 3
75440: ARRAY
75441: IN
75442: IFFALSE 75481
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
75444: LD_ADDR_EXP 64
75448: PUSH
75449: LD_EXP 64
75453: PPUSH
75454: LD_VAR 0 3
75458: PPUSH
75459: LD_EXP 64
75463: PUSH
75464: LD_VAR 0 3
75468: ARRAY
75469: PUSH
75470: LD_VAR 0 1
75474: DIFF
75475: PPUSH
75476: CALL_OW 1
75480: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
75481: LD_VAR 0 1
75485: PUSH
75486: LD_EXP 51
75490: PUSH
75491: LD_VAR 0 3
75495: ARRAY
75496: IN
75497: IFFALSE 75536
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
75499: LD_ADDR_EXP 51
75503: PUSH
75504: LD_EXP 51
75508: PPUSH
75509: LD_VAR 0 3
75513: PPUSH
75514: LD_EXP 51
75518: PUSH
75519: LD_VAR 0 3
75523: ARRAY
75524: PUSH
75525: LD_VAR 0 1
75529: DIFF
75530: PPUSH
75531: CALL_OW 1
75535: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
75536: LD_VAR 0 1
75540: PUSH
75541: LD_EXP 50
75545: PUSH
75546: LD_VAR 0 3
75550: ARRAY
75551: IN
75552: IFFALSE 75591
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
75554: LD_ADDR_EXP 50
75558: PUSH
75559: LD_EXP 50
75563: PPUSH
75564: LD_VAR 0 3
75568: PPUSH
75569: LD_EXP 50
75573: PUSH
75574: LD_VAR 0 3
75578: ARRAY
75579: PUSH
75580: LD_VAR 0 1
75584: DIFF
75585: PPUSH
75586: CALL_OW 1
75590: ST_TO_ADDR
// end ; break ;
75591: GO 75595
// end ;
75593: GO 74241
75595: POP
75596: POP
// end ;
75597: LD_VAR 0 2
75601: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
75602: LD_INT 0
75604: PPUSH
75605: PPUSH
75606: PPUSH
// if not mc_bases or not skirmish then
75607: LD_EXP 42
75611: NOT
75612: PUSH
75613: LD_EXP 40
75617: NOT
75618: OR
75619: IFFALSE 75623
// exit ;
75621: GO 75838
// for i = 1 to mc_bases do
75623: LD_ADDR_VAR 0 3
75627: PUSH
75628: DOUBLE
75629: LD_INT 1
75631: DEC
75632: ST_TO_ADDR
75633: LD_EXP 42
75637: PUSH
75638: FOR_TO
75639: IFFALSE 75836
// begin if building in mc_construct_list [ i ] then
75641: LD_VAR 0 1
75645: PUSH
75646: LD_EXP 49
75650: PUSH
75651: LD_VAR 0 3
75655: ARRAY
75656: IN
75657: IFFALSE 75834
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75659: LD_ADDR_EXP 49
75663: PUSH
75664: LD_EXP 49
75668: PPUSH
75669: LD_VAR 0 3
75673: PPUSH
75674: LD_EXP 49
75678: PUSH
75679: LD_VAR 0 3
75683: ARRAY
75684: PUSH
75685: LD_VAR 0 1
75689: DIFF
75690: PPUSH
75691: CALL_OW 1
75695: ST_TO_ADDR
// if building in mc_lab [ i ] then
75696: LD_VAR 0 1
75700: PUSH
75701: LD_EXP 75
75705: PUSH
75706: LD_VAR 0 3
75710: ARRAY
75711: IN
75712: IFFALSE 75767
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
75714: LD_ADDR_EXP 76
75718: PUSH
75719: LD_EXP 76
75723: PPUSH
75724: LD_VAR 0 3
75728: PPUSH
75729: LD_EXP 76
75733: PUSH
75734: LD_VAR 0 3
75738: ARRAY
75739: PPUSH
75740: LD_INT 1
75742: PPUSH
75743: LD_EXP 76
75747: PUSH
75748: LD_VAR 0 3
75752: ARRAY
75753: PPUSH
75754: LD_INT 0
75756: PPUSH
75757: CALL 14222 0 4
75761: PPUSH
75762: CALL_OW 1
75766: ST_TO_ADDR
// if not building in mc_bases [ i ] then
75767: LD_VAR 0 1
75771: PUSH
75772: LD_EXP 42
75776: PUSH
75777: LD_VAR 0 3
75781: ARRAY
75782: IN
75783: NOT
75784: IFFALSE 75830
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
75786: LD_ADDR_EXP 42
75790: PUSH
75791: LD_EXP 42
75795: PPUSH
75796: LD_VAR 0 3
75800: PUSH
75801: LD_EXP 42
75805: PUSH
75806: LD_VAR 0 3
75810: ARRAY
75811: PUSH
75812: LD_INT 1
75814: PLUS
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: PPUSH
75820: LD_VAR 0 1
75824: PPUSH
75825: CALL 14804 0 3
75829: ST_TO_ADDR
// exit ;
75830: POP
75831: POP
75832: GO 75838
// end ; end ;
75834: GO 75638
75836: POP
75837: POP
// end ;
75838: LD_VAR 0 2
75842: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
75843: LD_INT 0
75845: PPUSH
75846: PPUSH
75847: PPUSH
75848: PPUSH
75849: PPUSH
75850: PPUSH
75851: PPUSH
// if not mc_bases or not skirmish then
75852: LD_EXP 42
75856: NOT
75857: PUSH
75858: LD_EXP 40
75862: NOT
75863: OR
75864: IFFALSE 75868
// exit ;
75866: GO 76529
// for i = 1 to mc_bases do
75868: LD_ADDR_VAR 0 3
75872: PUSH
75873: DOUBLE
75874: LD_INT 1
75876: DEC
75877: ST_TO_ADDR
75878: LD_EXP 42
75882: PUSH
75883: FOR_TO
75884: IFFALSE 76527
// begin if building in mc_construct_list [ i ] then
75886: LD_VAR 0 1
75890: PUSH
75891: LD_EXP 49
75895: PUSH
75896: LD_VAR 0 3
75900: ARRAY
75901: IN
75902: IFFALSE 76525
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75904: LD_ADDR_EXP 49
75908: PUSH
75909: LD_EXP 49
75913: PPUSH
75914: LD_VAR 0 3
75918: PPUSH
75919: LD_EXP 49
75923: PUSH
75924: LD_VAR 0 3
75928: ARRAY
75929: PUSH
75930: LD_VAR 0 1
75934: DIFF
75935: PPUSH
75936: CALL_OW 1
75940: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
75941: LD_ADDR_EXP 42
75945: PUSH
75946: LD_EXP 42
75950: PPUSH
75951: LD_VAR 0 3
75955: PUSH
75956: LD_EXP 42
75960: PUSH
75961: LD_VAR 0 3
75965: ARRAY
75966: PUSH
75967: LD_INT 1
75969: PLUS
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PPUSH
75975: LD_VAR 0 1
75979: PPUSH
75980: CALL 14804 0 3
75984: ST_TO_ADDR
// btype := GetBType ( building ) ;
75985: LD_ADDR_VAR 0 5
75989: PUSH
75990: LD_VAR 0 1
75994: PPUSH
75995: CALL_OW 266
75999: ST_TO_ADDR
// side := GetSide ( building ) ;
76000: LD_ADDR_VAR 0 8
76004: PUSH
76005: LD_VAR 0 1
76009: PPUSH
76010: CALL_OW 255
76014: ST_TO_ADDR
// if btype = b_lab then
76015: LD_VAR 0 5
76019: PUSH
76020: LD_INT 6
76022: EQUAL
76023: IFFALSE 76073
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
76025: LD_ADDR_EXP 75
76029: PUSH
76030: LD_EXP 75
76034: PPUSH
76035: LD_VAR 0 3
76039: PUSH
76040: LD_EXP 75
76044: PUSH
76045: LD_VAR 0 3
76049: ARRAY
76050: PUSH
76051: LD_INT 1
76053: PLUS
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PPUSH
76059: LD_VAR 0 1
76063: PPUSH
76064: CALL 14804 0 3
76068: ST_TO_ADDR
// exit ;
76069: POP
76070: POP
76071: GO 76529
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
76073: LD_VAR 0 5
76077: PUSH
76078: LD_INT 0
76080: PUSH
76081: LD_INT 2
76083: PUSH
76084: LD_INT 4
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: LIST
76091: IN
76092: IFFALSE 76216
// begin if btype = b_armoury then
76094: LD_VAR 0 5
76098: PUSH
76099: LD_INT 4
76101: EQUAL
76102: IFFALSE 76112
// btype := b_barracks ;
76104: LD_ADDR_VAR 0 5
76108: PUSH
76109: LD_INT 5
76111: ST_TO_ADDR
// if btype = b_depot then
76112: LD_VAR 0 5
76116: PUSH
76117: LD_INT 0
76119: EQUAL
76120: IFFALSE 76130
// btype := b_warehouse ;
76122: LD_ADDR_VAR 0 5
76126: PUSH
76127: LD_INT 1
76129: ST_TO_ADDR
// if btype = b_workshop then
76130: LD_VAR 0 5
76134: PUSH
76135: LD_INT 2
76137: EQUAL
76138: IFFALSE 76148
// btype := b_factory ;
76140: LD_ADDR_VAR 0 5
76144: PUSH
76145: LD_INT 3
76147: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
76148: LD_VAR 0 5
76152: PPUSH
76153: LD_VAR 0 8
76157: PPUSH
76158: CALL_OW 323
76162: PUSH
76163: LD_INT 1
76165: EQUAL
76166: IFFALSE 76212
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
76168: LD_ADDR_EXP 74
76172: PUSH
76173: LD_EXP 74
76177: PPUSH
76178: LD_VAR 0 3
76182: PUSH
76183: LD_EXP 74
76187: PUSH
76188: LD_VAR 0 3
76192: ARRAY
76193: PUSH
76194: LD_INT 1
76196: PLUS
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PPUSH
76202: LD_VAR 0 1
76206: PPUSH
76207: CALL 14804 0 3
76211: ST_TO_ADDR
// exit ;
76212: POP
76213: POP
76214: GO 76529
// end ; if btype in [ b_bunker , b_turret ] then
76216: LD_VAR 0 5
76220: PUSH
76221: LD_INT 32
76223: PUSH
76224: LD_INT 33
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: IN
76231: IFFALSE 76521
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
76233: LD_ADDR_EXP 50
76237: PUSH
76238: LD_EXP 50
76242: PPUSH
76243: LD_VAR 0 3
76247: PUSH
76248: LD_EXP 50
76252: PUSH
76253: LD_VAR 0 3
76257: ARRAY
76258: PUSH
76259: LD_INT 1
76261: PLUS
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PPUSH
76267: LD_VAR 0 1
76271: PPUSH
76272: CALL 14804 0 3
76276: ST_TO_ADDR
// if btype = b_bunker then
76277: LD_VAR 0 5
76281: PUSH
76282: LD_INT 32
76284: EQUAL
76285: IFFALSE 76521
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76287: LD_ADDR_EXP 51
76291: PUSH
76292: LD_EXP 51
76296: PPUSH
76297: LD_VAR 0 3
76301: PUSH
76302: LD_EXP 51
76306: PUSH
76307: LD_VAR 0 3
76311: ARRAY
76312: PUSH
76313: LD_INT 1
76315: PLUS
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PPUSH
76321: LD_VAR 0 1
76325: PPUSH
76326: CALL 14804 0 3
76330: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
76331: LD_ADDR_VAR 0 6
76335: PUSH
76336: LD_EXP 42
76340: PUSH
76341: LD_VAR 0 3
76345: ARRAY
76346: PPUSH
76347: LD_INT 25
76349: PUSH
76350: LD_INT 1
76352: PUSH
76353: EMPTY
76354: LIST
76355: LIST
76356: PUSH
76357: LD_INT 3
76359: PUSH
76360: LD_INT 54
76362: PUSH
76363: EMPTY
76364: LIST
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: PUSH
76370: EMPTY
76371: LIST
76372: LIST
76373: PPUSH
76374: CALL_OW 72
76378: ST_TO_ADDR
// if tmp then
76379: LD_VAR 0 6
76383: IFFALSE 76389
// exit ;
76385: POP
76386: POP
76387: GO 76529
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76389: LD_ADDR_VAR 0 6
76393: PUSH
76394: LD_EXP 42
76398: PUSH
76399: LD_VAR 0 3
76403: ARRAY
76404: PPUSH
76405: LD_INT 2
76407: PUSH
76408: LD_INT 30
76410: PUSH
76411: LD_INT 4
76413: PUSH
76414: EMPTY
76415: LIST
76416: LIST
76417: PUSH
76418: LD_INT 30
76420: PUSH
76421: LD_INT 5
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: LIST
76432: PPUSH
76433: CALL_OW 72
76437: ST_TO_ADDR
// if not tmp then
76438: LD_VAR 0 6
76442: NOT
76443: IFFALSE 76449
// exit ;
76445: POP
76446: POP
76447: GO 76529
// for j in tmp do
76449: LD_ADDR_VAR 0 4
76453: PUSH
76454: LD_VAR 0 6
76458: PUSH
76459: FOR_IN
76460: IFFALSE 76519
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
76462: LD_ADDR_VAR 0 7
76466: PUSH
76467: LD_VAR 0 4
76471: PPUSH
76472: CALL_OW 313
76476: PPUSH
76477: LD_INT 25
76479: PUSH
76480: LD_INT 1
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PPUSH
76487: CALL_OW 72
76491: ST_TO_ADDR
// if units then
76492: LD_VAR 0 7
76496: IFFALSE 76517
// begin ComExitBuilding ( units [ 1 ] ) ;
76498: LD_VAR 0 7
76502: PUSH
76503: LD_INT 1
76505: ARRAY
76506: PPUSH
76507: CALL_OW 122
// exit ;
76511: POP
76512: POP
76513: POP
76514: POP
76515: GO 76529
// end ; end ;
76517: GO 76459
76519: POP
76520: POP
// end ; end ; exit ;
76521: POP
76522: POP
76523: GO 76529
// end ; end ;
76525: GO 75883
76527: POP
76528: POP
// end ;
76529: LD_VAR 0 2
76533: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
76534: LD_INT 0
76536: PPUSH
76537: PPUSH
76538: PPUSH
76539: PPUSH
76540: PPUSH
76541: PPUSH
76542: PPUSH
// if not mc_bases or not skirmish then
76543: LD_EXP 42
76547: NOT
76548: PUSH
76549: LD_EXP 40
76553: NOT
76554: OR
76555: IFFALSE 76559
// exit ;
76557: GO 76790
// btype := GetBType ( building ) ;
76559: LD_ADDR_VAR 0 6
76563: PUSH
76564: LD_VAR 0 1
76568: PPUSH
76569: CALL_OW 266
76573: ST_TO_ADDR
// x := GetX ( building ) ;
76574: LD_ADDR_VAR 0 7
76578: PUSH
76579: LD_VAR 0 1
76583: PPUSH
76584: CALL_OW 250
76588: ST_TO_ADDR
// y := GetY ( building ) ;
76589: LD_ADDR_VAR 0 8
76593: PUSH
76594: LD_VAR 0 1
76598: PPUSH
76599: CALL_OW 251
76603: ST_TO_ADDR
// d := GetDir ( building ) ;
76604: LD_ADDR_VAR 0 9
76608: PUSH
76609: LD_VAR 0 1
76613: PPUSH
76614: CALL_OW 254
76618: ST_TO_ADDR
// for i = 1 to mc_bases do
76619: LD_ADDR_VAR 0 4
76623: PUSH
76624: DOUBLE
76625: LD_INT 1
76627: DEC
76628: ST_TO_ADDR
76629: LD_EXP 42
76633: PUSH
76634: FOR_TO
76635: IFFALSE 76788
// begin if not mc_build_list [ i ] then
76637: LD_EXP 47
76641: PUSH
76642: LD_VAR 0 4
76646: ARRAY
76647: NOT
76648: IFFALSE 76652
// continue ;
76650: GO 76634
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
76652: LD_VAR 0 6
76656: PUSH
76657: LD_VAR 0 7
76661: PUSH
76662: LD_VAR 0 8
76666: PUSH
76667: LD_VAR 0 9
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: PPUSH
76678: LD_EXP 47
76682: PUSH
76683: LD_VAR 0 4
76687: ARRAY
76688: PUSH
76689: LD_INT 1
76691: ARRAY
76692: PPUSH
76693: CALL 20973 0 2
76697: IFFALSE 76786
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
76699: LD_ADDR_EXP 47
76703: PUSH
76704: LD_EXP 47
76708: PPUSH
76709: LD_VAR 0 4
76713: PPUSH
76714: LD_EXP 47
76718: PUSH
76719: LD_VAR 0 4
76723: ARRAY
76724: PPUSH
76725: LD_INT 1
76727: PPUSH
76728: CALL_OW 3
76732: PPUSH
76733: CALL_OW 1
76737: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
76738: LD_ADDR_EXP 49
76742: PUSH
76743: LD_EXP 49
76747: PPUSH
76748: LD_VAR 0 4
76752: PUSH
76753: LD_EXP 49
76757: PUSH
76758: LD_VAR 0 4
76762: ARRAY
76763: PUSH
76764: LD_INT 1
76766: PLUS
76767: PUSH
76768: EMPTY
76769: LIST
76770: LIST
76771: PPUSH
76772: LD_VAR 0 1
76776: PPUSH
76777: CALL 14804 0 3
76781: ST_TO_ADDR
// exit ;
76782: POP
76783: POP
76784: GO 76790
// end ; end ;
76786: GO 76634
76788: POP
76789: POP
// end ;
76790: LD_VAR 0 3
76794: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
76795: LD_INT 0
76797: PPUSH
76798: PPUSH
76799: PPUSH
// if not mc_bases or not skirmish then
76800: LD_EXP 42
76804: NOT
76805: PUSH
76806: LD_EXP 40
76810: NOT
76811: OR
76812: IFFALSE 76816
// exit ;
76814: GO 77006
// for i = 1 to mc_bases do
76816: LD_ADDR_VAR 0 4
76820: PUSH
76821: DOUBLE
76822: LD_INT 1
76824: DEC
76825: ST_TO_ADDR
76826: LD_EXP 42
76830: PUSH
76831: FOR_TO
76832: IFFALSE 76919
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
76834: LD_VAR 0 1
76838: PUSH
76839: LD_EXP 50
76843: PUSH
76844: LD_VAR 0 4
76848: ARRAY
76849: IN
76850: PUSH
76851: LD_VAR 0 1
76855: PUSH
76856: LD_EXP 51
76860: PUSH
76861: LD_VAR 0 4
76865: ARRAY
76866: IN
76867: NOT
76868: AND
76869: IFFALSE 76917
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76871: LD_ADDR_EXP 51
76875: PUSH
76876: LD_EXP 51
76880: PPUSH
76881: LD_VAR 0 4
76885: PUSH
76886: LD_EXP 51
76890: PUSH
76891: LD_VAR 0 4
76895: ARRAY
76896: PUSH
76897: LD_INT 1
76899: PLUS
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: PPUSH
76905: LD_VAR 0 1
76909: PPUSH
76910: CALL 14804 0 3
76914: ST_TO_ADDR
// break ;
76915: GO 76919
// end ; end ;
76917: GO 76831
76919: POP
76920: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
76921: LD_VAR 0 1
76925: PPUSH
76926: CALL_OW 257
76930: PUSH
76931: LD_EXP 68
76935: IN
76936: PUSH
76937: LD_VAR 0 1
76941: PPUSH
76942: CALL_OW 266
76946: PUSH
76947: LD_INT 5
76949: EQUAL
76950: AND
76951: PUSH
76952: LD_VAR 0 2
76956: PPUSH
76957: CALL_OW 110
76961: PUSH
76962: LD_INT 18
76964: NONEQUAL
76965: AND
76966: IFFALSE 77006
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
76968: LD_VAR 0 2
76972: PPUSH
76973: CALL_OW 257
76977: PUSH
76978: LD_INT 5
76980: PUSH
76981: LD_INT 8
76983: PUSH
76984: LD_INT 9
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: LIST
76991: IN
76992: IFFALSE 77006
// SetClass ( unit , 1 ) ;
76994: LD_VAR 0 2
76998: PPUSH
76999: LD_INT 1
77001: PPUSH
77002: CALL_OW 336
// end ;
77006: LD_VAR 0 3
77010: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
77011: LD_INT 0
77013: PPUSH
77014: PPUSH
// if not mc_bases or not skirmish then
77015: LD_EXP 42
77019: NOT
77020: PUSH
77021: LD_EXP 40
77025: NOT
77026: OR
77027: IFFALSE 77031
// exit ;
77029: GO 77147
// if GetLives ( abandoned_vehicle ) > 250 then
77031: LD_VAR 0 2
77035: PPUSH
77036: CALL_OW 256
77040: PUSH
77041: LD_INT 250
77043: GREATER
77044: IFFALSE 77048
// exit ;
77046: GO 77147
// for i = 1 to mc_bases do
77048: LD_ADDR_VAR 0 6
77052: PUSH
77053: DOUBLE
77054: LD_INT 1
77056: DEC
77057: ST_TO_ADDR
77058: LD_EXP 42
77062: PUSH
77063: FOR_TO
77064: IFFALSE 77145
// begin if driver in mc_bases [ i ] then
77066: LD_VAR 0 1
77070: PUSH
77071: LD_EXP 42
77075: PUSH
77076: LD_VAR 0 6
77080: ARRAY
77081: IN
77082: IFFALSE 77143
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
77084: LD_VAR 0 1
77088: PPUSH
77089: LD_EXP 42
77093: PUSH
77094: LD_VAR 0 6
77098: ARRAY
77099: PPUSH
77100: LD_INT 2
77102: PUSH
77103: LD_INT 30
77105: PUSH
77106: LD_INT 0
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: LD_INT 30
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: LIST
77127: PPUSH
77128: CALL_OW 72
77132: PUSH
77133: LD_INT 1
77135: ARRAY
77136: PPUSH
77137: CALL 46670 0 2
// break ;
77141: GO 77145
// end ; end ;
77143: GO 77063
77145: POP
77146: POP
// end ; end_of_file
77147: LD_VAR 0 5
77151: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
77152: LD_INT 0
77154: PPUSH
// ar_miner := 81 ;
77155: LD_ADDR_EXP 92
77159: PUSH
77160: LD_INT 81
77162: ST_TO_ADDR
// ar_crane := 88 ;
77163: LD_ADDR_EXP 91
77167: PUSH
77168: LD_INT 88
77170: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
77171: LD_ADDR_EXP 86
77175: PUSH
77176: LD_INT 89
77178: ST_TO_ADDR
// us_hack := 99 ;
77179: LD_ADDR_EXP 87
77183: PUSH
77184: LD_INT 99
77186: ST_TO_ADDR
// us_artillery := 97 ;
77187: LD_ADDR_EXP 88
77191: PUSH
77192: LD_INT 97
77194: ST_TO_ADDR
// ar_bio_bomb := 91 ;
77195: LD_ADDR_EXP 89
77199: PUSH
77200: LD_INT 91
77202: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
77203: LD_ADDR_EXP 90
77207: PUSH
77208: LD_INT 92
77210: ST_TO_ADDR
// ru_radar := 98 ;
77211: LD_ADDR_EXP 85
77215: PUSH
77216: LD_INT 98
77218: ST_TO_ADDR
// tech_Artillery := 80 ;
77219: LD_ADDR_EXP 93
77223: PUSH
77224: LD_INT 80
77226: ST_TO_ADDR
// tech_RadMat := 81 ;
77227: LD_ADDR_EXP 94
77231: PUSH
77232: LD_INT 81
77234: ST_TO_ADDR
// tech_BasicTools := 82 ;
77235: LD_ADDR_EXP 95
77239: PUSH
77240: LD_INT 82
77242: ST_TO_ADDR
// tech_Cargo := 83 ;
77243: LD_ADDR_EXP 96
77247: PUSH
77248: LD_INT 83
77250: ST_TO_ADDR
// tech_Track := 84 ;
77251: LD_ADDR_EXP 97
77255: PUSH
77256: LD_INT 84
77258: ST_TO_ADDR
// tech_Crane := 85 ;
77259: LD_ADDR_EXP 98
77263: PUSH
77264: LD_INT 85
77266: ST_TO_ADDR
// tech_Bulldozer := 86 ;
77267: LD_ADDR_EXP 99
77271: PUSH
77272: LD_INT 86
77274: ST_TO_ADDR
// tech_Hovercraft := 87 ;
77275: LD_ADDR_EXP 100
77279: PUSH
77280: LD_INT 87
77282: ST_TO_ADDR
// end ;
77283: LD_VAR 0 1
77287: RET
// every 1 do
77288: GO 77290
77290: DISABLE
// InitGlobalVariables ; end_of_file
77291: CALL 77152 0 0
77295: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
77296: LD_INT 0
77298: PPUSH
77299: PPUSH
77300: PPUSH
77301: PPUSH
77302: PPUSH
77303: PPUSH
77304: PPUSH
77305: PPUSH
77306: PPUSH
77307: PPUSH
77308: PPUSH
77309: PPUSH
77310: PPUSH
77311: PPUSH
77312: PPUSH
77313: PPUSH
77314: PPUSH
77315: PPUSH
77316: PPUSH
77317: PPUSH
77318: PPUSH
77319: PPUSH
77320: PPUSH
77321: PPUSH
77322: PPUSH
77323: PPUSH
77324: PPUSH
77325: PPUSH
77326: PPUSH
77327: PPUSH
77328: PPUSH
77329: PPUSH
77330: PPUSH
77331: PPUSH
// if not list then
77332: LD_VAR 0 1
77336: NOT
77337: IFFALSE 77341
// exit ;
77339: GO 82000
// base := list [ 1 ] ;
77341: LD_ADDR_VAR 0 3
77345: PUSH
77346: LD_VAR 0 1
77350: PUSH
77351: LD_INT 1
77353: ARRAY
77354: ST_TO_ADDR
// group := list [ 2 ] ;
77355: LD_ADDR_VAR 0 4
77359: PUSH
77360: LD_VAR 0 1
77364: PUSH
77365: LD_INT 2
77367: ARRAY
77368: ST_TO_ADDR
// path := list [ 3 ] ;
77369: LD_ADDR_VAR 0 5
77373: PUSH
77374: LD_VAR 0 1
77378: PUSH
77379: LD_INT 3
77381: ARRAY
77382: ST_TO_ADDR
// flags := list [ 4 ] ;
77383: LD_ADDR_VAR 0 6
77387: PUSH
77388: LD_VAR 0 1
77392: PUSH
77393: LD_INT 4
77395: ARRAY
77396: ST_TO_ADDR
// mined := [ ] ;
77397: LD_ADDR_VAR 0 27
77401: PUSH
77402: EMPTY
77403: ST_TO_ADDR
// bombed := [ ] ;
77404: LD_ADDR_VAR 0 28
77408: PUSH
77409: EMPTY
77410: ST_TO_ADDR
// healers := [ ] ;
77411: LD_ADDR_VAR 0 31
77415: PUSH
77416: EMPTY
77417: ST_TO_ADDR
// to_heal := [ ] ;
77418: LD_ADDR_VAR 0 30
77422: PUSH
77423: EMPTY
77424: ST_TO_ADDR
// repairs := [ ] ;
77425: LD_ADDR_VAR 0 33
77429: PUSH
77430: EMPTY
77431: ST_TO_ADDR
// to_repair := [ ] ;
77432: LD_ADDR_VAR 0 32
77436: PUSH
77437: EMPTY
77438: ST_TO_ADDR
// if not group or not path then
77439: LD_VAR 0 4
77443: NOT
77444: PUSH
77445: LD_VAR 0 5
77449: NOT
77450: OR
77451: IFFALSE 77455
// exit ;
77453: GO 82000
// side := GetSide ( group [ 1 ] ) ;
77455: LD_ADDR_VAR 0 35
77459: PUSH
77460: LD_VAR 0 4
77464: PUSH
77465: LD_INT 1
77467: ARRAY
77468: PPUSH
77469: CALL_OW 255
77473: ST_TO_ADDR
// if flags then
77474: LD_VAR 0 6
77478: IFFALSE 77622
// begin f_ignore_area := flags [ 1 ] ;
77480: LD_ADDR_VAR 0 17
77484: PUSH
77485: LD_VAR 0 6
77489: PUSH
77490: LD_INT 1
77492: ARRAY
77493: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77494: LD_ADDR_VAR 0 18
77498: PUSH
77499: LD_VAR 0 6
77503: PUSH
77504: LD_INT 2
77506: ARRAY
77507: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77508: LD_ADDR_VAR 0 19
77512: PUSH
77513: LD_VAR 0 6
77517: PUSH
77518: LD_INT 3
77520: ARRAY
77521: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77522: LD_ADDR_VAR 0 20
77526: PUSH
77527: LD_VAR 0 6
77531: PUSH
77532: LD_INT 4
77534: ARRAY
77535: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
77536: LD_ADDR_VAR 0 21
77540: PUSH
77541: LD_VAR 0 6
77545: PUSH
77546: LD_INT 5
77548: ARRAY
77549: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
77550: LD_ADDR_VAR 0 22
77554: PUSH
77555: LD_VAR 0 6
77559: PUSH
77560: LD_INT 6
77562: ARRAY
77563: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
77564: LD_ADDR_VAR 0 23
77568: PUSH
77569: LD_VAR 0 6
77573: PUSH
77574: LD_INT 7
77576: ARRAY
77577: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
77578: LD_ADDR_VAR 0 24
77582: PUSH
77583: LD_VAR 0 6
77587: PUSH
77588: LD_INT 8
77590: ARRAY
77591: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
77592: LD_ADDR_VAR 0 25
77596: PUSH
77597: LD_VAR 0 6
77601: PUSH
77602: LD_INT 9
77604: ARRAY
77605: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
77606: LD_ADDR_VAR 0 26
77610: PUSH
77611: LD_VAR 0 6
77615: PUSH
77616: LD_INT 10
77618: ARRAY
77619: ST_TO_ADDR
// end else
77620: GO 77702
// begin f_ignore_area := false ;
77622: LD_ADDR_VAR 0 17
77626: PUSH
77627: LD_INT 0
77629: ST_TO_ADDR
// f_capture := false ;
77630: LD_ADDR_VAR 0 18
77634: PUSH
77635: LD_INT 0
77637: ST_TO_ADDR
// f_ignore_civ := false ;
77638: LD_ADDR_VAR 0 19
77642: PUSH
77643: LD_INT 0
77645: ST_TO_ADDR
// f_murder := false ;
77646: LD_ADDR_VAR 0 20
77650: PUSH
77651: LD_INT 0
77653: ST_TO_ADDR
// f_mines := false ;
77654: LD_ADDR_VAR 0 21
77658: PUSH
77659: LD_INT 0
77661: ST_TO_ADDR
// f_repair := false ;
77662: LD_ADDR_VAR 0 22
77666: PUSH
77667: LD_INT 0
77669: ST_TO_ADDR
// f_heal := false ;
77670: LD_ADDR_VAR 0 23
77674: PUSH
77675: LD_INT 0
77677: ST_TO_ADDR
// f_spacetime := false ;
77678: LD_ADDR_VAR 0 24
77682: PUSH
77683: LD_INT 0
77685: ST_TO_ADDR
// f_attack_depot := false ;
77686: LD_ADDR_VAR 0 25
77690: PUSH
77691: LD_INT 0
77693: ST_TO_ADDR
// f_crawl := false ;
77694: LD_ADDR_VAR 0 26
77698: PUSH
77699: LD_INT 0
77701: ST_TO_ADDR
// end ; if f_heal then
77702: LD_VAR 0 23
77706: IFFALSE 77733
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
77708: LD_ADDR_VAR 0 31
77712: PUSH
77713: LD_VAR 0 4
77717: PPUSH
77718: LD_INT 25
77720: PUSH
77721: LD_INT 4
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PPUSH
77728: CALL_OW 72
77732: ST_TO_ADDR
// if f_repair then
77733: LD_VAR 0 22
77737: IFFALSE 77764
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
77739: LD_ADDR_VAR 0 33
77743: PUSH
77744: LD_VAR 0 4
77748: PPUSH
77749: LD_INT 25
77751: PUSH
77752: LD_INT 3
77754: PUSH
77755: EMPTY
77756: LIST
77757: LIST
77758: PPUSH
77759: CALL_OW 72
77763: ST_TO_ADDR
// units_path := [ ] ;
77764: LD_ADDR_VAR 0 16
77768: PUSH
77769: EMPTY
77770: ST_TO_ADDR
// for i = 1 to group do
77771: LD_ADDR_VAR 0 7
77775: PUSH
77776: DOUBLE
77777: LD_INT 1
77779: DEC
77780: ST_TO_ADDR
77781: LD_VAR 0 4
77785: PUSH
77786: FOR_TO
77787: IFFALSE 77816
// units_path := Replace ( units_path , i , path ) ;
77789: LD_ADDR_VAR 0 16
77793: PUSH
77794: LD_VAR 0 16
77798: PPUSH
77799: LD_VAR 0 7
77803: PPUSH
77804: LD_VAR 0 5
77808: PPUSH
77809: CALL_OW 1
77813: ST_TO_ADDR
77814: GO 77786
77816: POP
77817: POP
// repeat for i = group downto 1 do
77818: LD_ADDR_VAR 0 7
77822: PUSH
77823: DOUBLE
77824: LD_VAR 0 4
77828: INC
77829: ST_TO_ADDR
77830: LD_INT 1
77832: PUSH
77833: FOR_DOWNTO
77834: IFFALSE 81956
// begin wait ( 5 ) ;
77836: LD_INT 5
77838: PPUSH
77839: CALL_OW 67
// tmp := [ ] ;
77843: LD_ADDR_VAR 0 14
77847: PUSH
77848: EMPTY
77849: ST_TO_ADDR
// attacking := false ;
77850: LD_ADDR_VAR 0 29
77854: PUSH
77855: LD_INT 0
77857: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
77858: LD_VAR 0 4
77862: PUSH
77863: LD_VAR 0 7
77867: ARRAY
77868: PPUSH
77869: CALL_OW 301
77873: PUSH
77874: LD_VAR 0 4
77878: PUSH
77879: LD_VAR 0 7
77883: ARRAY
77884: NOT
77885: OR
77886: IFFALSE 77995
// begin if GetType ( group [ i ] ) = unit_human then
77888: LD_VAR 0 4
77892: PUSH
77893: LD_VAR 0 7
77897: ARRAY
77898: PPUSH
77899: CALL_OW 247
77903: PUSH
77904: LD_INT 1
77906: EQUAL
77907: IFFALSE 77953
// begin to_heal := to_heal diff group [ i ] ;
77909: LD_ADDR_VAR 0 30
77913: PUSH
77914: LD_VAR 0 30
77918: PUSH
77919: LD_VAR 0 4
77923: PUSH
77924: LD_VAR 0 7
77928: ARRAY
77929: DIFF
77930: ST_TO_ADDR
// healers := healers diff group [ i ] ;
77931: LD_ADDR_VAR 0 31
77935: PUSH
77936: LD_VAR 0 31
77940: PUSH
77941: LD_VAR 0 4
77945: PUSH
77946: LD_VAR 0 7
77950: ARRAY
77951: DIFF
77952: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
77953: LD_ADDR_VAR 0 4
77957: PUSH
77958: LD_VAR 0 4
77962: PPUSH
77963: LD_VAR 0 7
77967: PPUSH
77968: CALL_OW 3
77972: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
77973: LD_ADDR_VAR 0 16
77977: PUSH
77978: LD_VAR 0 16
77982: PPUSH
77983: LD_VAR 0 7
77987: PPUSH
77988: CALL_OW 3
77992: ST_TO_ADDR
// continue ;
77993: GO 77833
// end ; if f_repair then
77995: LD_VAR 0 22
77999: IFFALSE 78488
// begin if GetType ( group [ i ] ) = unit_vehicle then
78001: LD_VAR 0 4
78005: PUSH
78006: LD_VAR 0 7
78010: ARRAY
78011: PPUSH
78012: CALL_OW 247
78016: PUSH
78017: LD_INT 2
78019: EQUAL
78020: IFFALSE 78210
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
78022: LD_VAR 0 4
78026: PUSH
78027: LD_VAR 0 7
78031: ARRAY
78032: PPUSH
78033: CALL_OW 256
78037: PUSH
78038: LD_INT 700
78040: LESS
78041: PUSH
78042: LD_VAR 0 4
78046: PUSH
78047: LD_VAR 0 7
78051: ARRAY
78052: PUSH
78053: LD_VAR 0 32
78057: IN
78058: NOT
78059: AND
78060: IFFALSE 78084
// to_repair := to_repair union group [ i ] ;
78062: LD_ADDR_VAR 0 32
78066: PUSH
78067: LD_VAR 0 32
78071: PUSH
78072: LD_VAR 0 4
78076: PUSH
78077: LD_VAR 0 7
78081: ARRAY
78082: UNION
78083: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78084: LD_VAR 0 4
78088: PUSH
78089: LD_VAR 0 7
78093: ARRAY
78094: PPUSH
78095: CALL_OW 256
78099: PUSH
78100: LD_INT 1000
78102: EQUAL
78103: PUSH
78104: LD_VAR 0 4
78108: PUSH
78109: LD_VAR 0 7
78113: ARRAY
78114: PUSH
78115: LD_VAR 0 32
78119: IN
78120: AND
78121: IFFALSE 78145
// to_repair := to_repair diff group [ i ] ;
78123: LD_ADDR_VAR 0 32
78127: PUSH
78128: LD_VAR 0 32
78132: PUSH
78133: LD_VAR 0 4
78137: PUSH
78138: LD_VAR 0 7
78142: ARRAY
78143: DIFF
78144: ST_TO_ADDR
// if group [ i ] in to_repair then
78145: LD_VAR 0 4
78149: PUSH
78150: LD_VAR 0 7
78154: ARRAY
78155: PUSH
78156: LD_VAR 0 32
78160: IN
78161: IFFALSE 78208
// begin if not IsInArea ( group [ i ] , f_repair ) then
78163: LD_VAR 0 4
78167: PUSH
78168: LD_VAR 0 7
78172: ARRAY
78173: PPUSH
78174: LD_VAR 0 22
78178: PPUSH
78179: CALL_OW 308
78183: NOT
78184: IFFALSE 78206
// ComMoveToArea ( group [ i ] , f_repair ) ;
78186: LD_VAR 0 4
78190: PUSH
78191: LD_VAR 0 7
78195: ARRAY
78196: PPUSH
78197: LD_VAR 0 22
78201: PPUSH
78202: CALL_OW 113
// continue ;
78206: GO 77833
// end ; end else
78208: GO 78488
// if group [ i ] in repairs then
78210: LD_VAR 0 4
78214: PUSH
78215: LD_VAR 0 7
78219: ARRAY
78220: PUSH
78221: LD_VAR 0 33
78225: IN
78226: IFFALSE 78488
// begin if IsInUnit ( group [ i ] ) then
78228: LD_VAR 0 4
78232: PUSH
78233: LD_VAR 0 7
78237: ARRAY
78238: PPUSH
78239: CALL_OW 310
78243: IFFALSE 78311
// begin z := IsInUnit ( group [ i ] ) ;
78245: LD_ADDR_VAR 0 13
78249: PUSH
78250: LD_VAR 0 4
78254: PUSH
78255: LD_VAR 0 7
78259: ARRAY
78260: PPUSH
78261: CALL_OW 310
78265: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
78266: LD_VAR 0 13
78270: PUSH
78271: LD_VAR 0 32
78275: IN
78276: PUSH
78277: LD_VAR 0 13
78281: PPUSH
78282: LD_VAR 0 22
78286: PPUSH
78287: CALL_OW 308
78291: AND
78292: IFFALSE 78309
// ComExitVehicle ( group [ i ] ) ;
78294: LD_VAR 0 4
78298: PUSH
78299: LD_VAR 0 7
78303: ARRAY
78304: PPUSH
78305: CALL_OW 121
// end else
78309: GO 78488
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
78311: LD_ADDR_VAR 0 13
78315: PUSH
78316: LD_VAR 0 4
78320: PPUSH
78321: LD_INT 95
78323: PUSH
78324: LD_VAR 0 22
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: PUSH
78333: LD_INT 58
78335: PUSH
78336: EMPTY
78337: LIST
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PPUSH
78343: CALL_OW 72
78347: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
78348: LD_VAR 0 4
78352: PUSH
78353: LD_VAR 0 7
78357: ARRAY
78358: PPUSH
78359: CALL_OW 314
78363: NOT
78364: IFFALSE 78486
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
78366: LD_ADDR_VAR 0 10
78370: PUSH
78371: LD_VAR 0 13
78375: PPUSH
78376: LD_VAR 0 4
78380: PUSH
78381: LD_VAR 0 7
78385: ARRAY
78386: PPUSH
78387: CALL_OW 74
78391: ST_TO_ADDR
// if not x then
78392: LD_VAR 0 10
78396: NOT
78397: IFFALSE 78401
// continue ;
78399: GO 77833
// if GetLives ( x ) < 1000 then
78401: LD_VAR 0 10
78405: PPUSH
78406: CALL_OW 256
78410: PUSH
78411: LD_INT 1000
78413: LESS
78414: IFFALSE 78438
// ComRepairVehicle ( group [ i ] , x ) else
78416: LD_VAR 0 4
78420: PUSH
78421: LD_VAR 0 7
78425: ARRAY
78426: PPUSH
78427: LD_VAR 0 10
78431: PPUSH
78432: CALL_OW 129
78436: GO 78486
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
78438: LD_VAR 0 23
78442: PUSH
78443: LD_VAR 0 4
78447: PUSH
78448: LD_VAR 0 7
78452: ARRAY
78453: PPUSH
78454: CALL_OW 256
78458: PUSH
78459: LD_INT 1000
78461: LESS
78462: AND
78463: NOT
78464: IFFALSE 78486
// ComEnterUnit ( group [ i ] , x ) ;
78466: LD_VAR 0 4
78470: PUSH
78471: LD_VAR 0 7
78475: ARRAY
78476: PPUSH
78477: LD_VAR 0 10
78481: PPUSH
78482: CALL_OW 120
// end ; continue ;
78486: GO 77833
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78488: LD_VAR 0 23
78492: PUSH
78493: LD_VAR 0 4
78497: PUSH
78498: LD_VAR 0 7
78502: ARRAY
78503: PPUSH
78504: CALL_OW 247
78508: PUSH
78509: LD_INT 1
78511: EQUAL
78512: AND
78513: IFFALSE 78991
// begin if group [ i ] in healers then
78515: LD_VAR 0 4
78519: PUSH
78520: LD_VAR 0 7
78524: ARRAY
78525: PUSH
78526: LD_VAR 0 31
78530: IN
78531: IFFALSE 78804
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78533: LD_VAR 0 4
78537: PUSH
78538: LD_VAR 0 7
78542: ARRAY
78543: PPUSH
78544: LD_VAR 0 23
78548: PPUSH
78549: CALL_OW 308
78553: NOT
78554: PUSH
78555: LD_VAR 0 4
78559: PUSH
78560: LD_VAR 0 7
78564: ARRAY
78565: PPUSH
78566: CALL_OW 314
78570: NOT
78571: AND
78572: IFFALSE 78596
// ComMoveToArea ( group [ i ] , f_heal ) else
78574: LD_VAR 0 4
78578: PUSH
78579: LD_VAR 0 7
78583: ARRAY
78584: PPUSH
78585: LD_VAR 0 23
78589: PPUSH
78590: CALL_OW 113
78594: GO 78802
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
78596: LD_VAR 0 4
78600: PUSH
78601: LD_VAR 0 7
78605: ARRAY
78606: PPUSH
78607: CALL 43176 0 1
78611: PPUSH
78612: CALL_OW 256
78616: PUSH
78617: LD_INT 1000
78619: EQUAL
78620: IFFALSE 78639
// ComStop ( group [ i ] ) else
78622: LD_VAR 0 4
78626: PUSH
78627: LD_VAR 0 7
78631: ARRAY
78632: PPUSH
78633: CALL_OW 141
78637: GO 78802
// if not HasTask ( group [ i ] ) and to_heal then
78639: LD_VAR 0 4
78643: PUSH
78644: LD_VAR 0 7
78648: ARRAY
78649: PPUSH
78650: CALL_OW 314
78654: NOT
78655: PUSH
78656: LD_VAR 0 30
78660: AND
78661: IFFALSE 78802
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
78663: LD_ADDR_VAR 0 13
78667: PUSH
78668: LD_VAR 0 30
78672: PPUSH
78673: LD_INT 3
78675: PUSH
78676: LD_INT 54
78678: PUSH
78679: EMPTY
78680: LIST
78681: PUSH
78682: EMPTY
78683: LIST
78684: LIST
78685: PPUSH
78686: CALL_OW 72
78690: PPUSH
78691: LD_VAR 0 4
78695: PUSH
78696: LD_VAR 0 7
78700: ARRAY
78701: PPUSH
78702: CALL_OW 74
78706: ST_TO_ADDR
// if z then
78707: LD_VAR 0 13
78711: IFFALSE 78802
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
78713: LD_INT 91
78715: PUSH
78716: LD_VAR 0 13
78720: PUSH
78721: LD_INT 10
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 81
78731: PUSH
78732: LD_VAR 0 13
78736: PPUSH
78737: CALL_OW 255
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: PPUSH
78750: CALL_OW 69
78754: PUSH
78755: LD_INT 0
78757: EQUAL
78758: IFFALSE 78782
// ComHeal ( group [ i ] , z ) else
78760: LD_VAR 0 4
78764: PUSH
78765: LD_VAR 0 7
78769: ARRAY
78770: PPUSH
78771: LD_VAR 0 13
78775: PPUSH
78776: CALL_OW 128
78780: GO 78802
// ComMoveToArea ( group [ i ] , f_heal ) ;
78782: LD_VAR 0 4
78786: PUSH
78787: LD_VAR 0 7
78791: ARRAY
78792: PPUSH
78793: LD_VAR 0 23
78797: PPUSH
78798: CALL_OW 113
// end ; continue ;
78802: GO 77833
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
78804: LD_VAR 0 4
78808: PUSH
78809: LD_VAR 0 7
78813: ARRAY
78814: PPUSH
78815: CALL_OW 256
78819: PUSH
78820: LD_INT 700
78822: LESS
78823: PUSH
78824: LD_VAR 0 4
78828: PUSH
78829: LD_VAR 0 7
78833: ARRAY
78834: PUSH
78835: LD_VAR 0 30
78839: IN
78840: NOT
78841: AND
78842: IFFALSE 78866
// to_heal := to_heal union group [ i ] ;
78844: LD_ADDR_VAR 0 30
78848: PUSH
78849: LD_VAR 0 30
78853: PUSH
78854: LD_VAR 0 4
78858: PUSH
78859: LD_VAR 0 7
78863: ARRAY
78864: UNION
78865: ST_TO_ADDR
// if group [ i ] in to_heal then
78866: LD_VAR 0 4
78870: PUSH
78871: LD_VAR 0 7
78875: ARRAY
78876: PUSH
78877: LD_VAR 0 30
78881: IN
78882: IFFALSE 78991
// begin if GetLives ( group [ i ] ) = 1000 then
78884: LD_VAR 0 4
78888: PUSH
78889: LD_VAR 0 7
78893: ARRAY
78894: PPUSH
78895: CALL_OW 256
78899: PUSH
78900: LD_INT 1000
78902: EQUAL
78903: IFFALSE 78929
// to_heal := to_heal diff group [ i ] else
78905: LD_ADDR_VAR 0 30
78909: PUSH
78910: LD_VAR 0 30
78914: PUSH
78915: LD_VAR 0 4
78919: PUSH
78920: LD_VAR 0 7
78924: ARRAY
78925: DIFF
78926: ST_TO_ADDR
78927: GO 78991
// begin if not IsInArea ( group [ i ] , to_heal ) then
78929: LD_VAR 0 4
78933: PUSH
78934: LD_VAR 0 7
78938: ARRAY
78939: PPUSH
78940: LD_VAR 0 30
78944: PPUSH
78945: CALL_OW 308
78949: NOT
78950: IFFALSE 78974
// ComMoveToArea ( group [ i ] , f_heal ) else
78952: LD_VAR 0 4
78956: PUSH
78957: LD_VAR 0 7
78961: ARRAY
78962: PPUSH
78963: LD_VAR 0 23
78967: PPUSH
78968: CALL_OW 113
78972: GO 78989
// ComHold ( group [ i ] ) ;
78974: LD_VAR 0 4
78978: PUSH
78979: LD_VAR 0 7
78983: ARRAY
78984: PPUSH
78985: CALL_OW 140
// continue ;
78989: GO 77833
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
78991: LD_VAR 0 4
78995: PUSH
78996: LD_VAR 0 7
79000: ARRAY
79001: PPUSH
79002: LD_INT 10
79004: PPUSH
79005: CALL 41596 0 2
79009: NOT
79010: PUSH
79011: LD_VAR 0 16
79015: PUSH
79016: LD_VAR 0 7
79020: ARRAY
79021: PUSH
79022: EMPTY
79023: EQUAL
79024: NOT
79025: AND
79026: IFFALSE 79292
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
79028: LD_VAR 0 4
79032: PUSH
79033: LD_VAR 0 7
79037: ARRAY
79038: PPUSH
79039: CALL_OW 262
79043: PUSH
79044: LD_INT 1
79046: PUSH
79047: LD_INT 2
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: IN
79054: IFFALSE 79095
// if GetFuel ( group [ i ] ) < 10 then
79056: LD_VAR 0 4
79060: PUSH
79061: LD_VAR 0 7
79065: ARRAY
79066: PPUSH
79067: CALL_OW 261
79071: PUSH
79072: LD_INT 10
79074: LESS
79075: IFFALSE 79095
// SetFuel ( group [ i ] , 12 ) ;
79077: LD_VAR 0 4
79081: PUSH
79082: LD_VAR 0 7
79086: ARRAY
79087: PPUSH
79088: LD_INT 12
79090: PPUSH
79091: CALL_OW 240
// if units_path [ i ] then
79095: LD_VAR 0 16
79099: PUSH
79100: LD_VAR 0 7
79104: ARRAY
79105: IFFALSE 79290
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
79107: LD_VAR 0 4
79111: PUSH
79112: LD_VAR 0 7
79116: ARRAY
79117: PPUSH
79118: LD_VAR 0 16
79122: PUSH
79123: LD_VAR 0 7
79127: ARRAY
79128: PUSH
79129: LD_INT 1
79131: ARRAY
79132: PUSH
79133: LD_INT 1
79135: ARRAY
79136: PPUSH
79137: LD_VAR 0 16
79141: PUSH
79142: LD_VAR 0 7
79146: ARRAY
79147: PUSH
79148: LD_INT 1
79150: ARRAY
79151: PUSH
79152: LD_INT 2
79154: ARRAY
79155: PPUSH
79156: CALL_OW 297
79160: PUSH
79161: LD_INT 6
79163: GREATER
79164: IFFALSE 79239
// begin if not HasTask ( group [ i ] ) then
79166: LD_VAR 0 4
79170: PUSH
79171: LD_VAR 0 7
79175: ARRAY
79176: PPUSH
79177: CALL_OW 314
79181: NOT
79182: IFFALSE 79237
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
79184: LD_VAR 0 4
79188: PUSH
79189: LD_VAR 0 7
79193: ARRAY
79194: PPUSH
79195: LD_VAR 0 16
79199: PUSH
79200: LD_VAR 0 7
79204: ARRAY
79205: PUSH
79206: LD_INT 1
79208: ARRAY
79209: PUSH
79210: LD_INT 1
79212: ARRAY
79213: PPUSH
79214: LD_VAR 0 16
79218: PUSH
79219: LD_VAR 0 7
79223: ARRAY
79224: PUSH
79225: LD_INT 1
79227: ARRAY
79228: PUSH
79229: LD_INT 2
79231: ARRAY
79232: PPUSH
79233: CALL_OW 114
// end else
79237: GO 79290
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
79239: LD_ADDR_VAR 0 15
79243: PUSH
79244: LD_VAR 0 16
79248: PUSH
79249: LD_VAR 0 7
79253: ARRAY
79254: PPUSH
79255: LD_INT 1
79257: PPUSH
79258: CALL_OW 3
79262: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
79263: LD_ADDR_VAR 0 16
79267: PUSH
79268: LD_VAR 0 16
79272: PPUSH
79273: LD_VAR 0 7
79277: PPUSH
79278: LD_VAR 0 15
79282: PPUSH
79283: CALL_OW 1
79287: ST_TO_ADDR
// continue ;
79288: GO 77833
// end ; end ; end else
79290: GO 81954
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
79292: LD_ADDR_VAR 0 14
79296: PUSH
79297: LD_INT 81
79299: PUSH
79300: LD_VAR 0 4
79304: PUSH
79305: LD_VAR 0 7
79309: ARRAY
79310: PPUSH
79311: CALL_OW 255
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PPUSH
79320: CALL_OW 69
79324: ST_TO_ADDR
// if not tmp then
79325: LD_VAR 0 14
79329: NOT
79330: IFFALSE 79334
// continue ;
79332: GO 77833
// if f_ignore_area then
79334: LD_VAR 0 17
79338: IFFALSE 79426
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
79340: LD_ADDR_VAR 0 15
79344: PUSH
79345: LD_VAR 0 14
79349: PPUSH
79350: LD_INT 3
79352: PUSH
79353: LD_INT 92
79355: PUSH
79356: LD_VAR 0 17
79360: PUSH
79361: LD_INT 1
79363: ARRAY
79364: PUSH
79365: LD_VAR 0 17
79369: PUSH
79370: LD_INT 2
79372: ARRAY
79373: PUSH
79374: LD_VAR 0 17
79378: PUSH
79379: LD_INT 3
79381: ARRAY
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: PPUSH
79393: CALL_OW 72
79397: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79398: LD_VAR 0 14
79402: PUSH
79403: LD_VAR 0 15
79407: DIFF
79408: IFFALSE 79426
// tmp := tmp diff tmp2 ;
79410: LD_ADDR_VAR 0 14
79414: PUSH
79415: LD_VAR 0 14
79419: PUSH
79420: LD_VAR 0 15
79424: DIFF
79425: ST_TO_ADDR
// end ; if not f_murder then
79426: LD_VAR 0 20
79430: NOT
79431: IFFALSE 79489
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
79433: LD_ADDR_VAR 0 15
79437: PUSH
79438: LD_VAR 0 14
79442: PPUSH
79443: LD_INT 3
79445: PUSH
79446: LD_INT 50
79448: PUSH
79449: EMPTY
79450: LIST
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PPUSH
79456: CALL_OW 72
79460: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79461: LD_VAR 0 14
79465: PUSH
79466: LD_VAR 0 15
79470: DIFF
79471: IFFALSE 79489
// tmp := tmp diff tmp2 ;
79473: LD_ADDR_VAR 0 14
79477: PUSH
79478: LD_VAR 0 14
79482: PUSH
79483: LD_VAR 0 15
79487: DIFF
79488: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79489: LD_ADDR_VAR 0 14
79493: PUSH
79494: LD_VAR 0 4
79498: PUSH
79499: LD_VAR 0 7
79503: ARRAY
79504: PPUSH
79505: LD_VAR 0 14
79509: PPUSH
79510: LD_INT 1
79512: PPUSH
79513: LD_INT 1
79515: PPUSH
79516: CALL 15239 0 4
79520: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79521: LD_VAR 0 4
79525: PUSH
79526: LD_VAR 0 7
79530: ARRAY
79531: PPUSH
79532: CALL_OW 257
79536: PUSH
79537: LD_INT 1
79539: EQUAL
79540: IFFALSE 79988
// begin if WantPlant ( group [ i ] ) then
79542: LD_VAR 0 4
79546: PUSH
79547: LD_VAR 0 7
79551: ARRAY
79552: PPUSH
79553: CALL 14740 0 1
79557: IFFALSE 79561
// continue ;
79559: GO 77833
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
79561: LD_VAR 0 18
79565: PUSH
79566: LD_VAR 0 4
79570: PUSH
79571: LD_VAR 0 7
79575: ARRAY
79576: PPUSH
79577: CALL_OW 310
79581: NOT
79582: AND
79583: PUSH
79584: LD_VAR 0 14
79588: PUSH
79589: LD_INT 1
79591: ARRAY
79592: PUSH
79593: LD_VAR 0 14
79597: PPUSH
79598: LD_INT 21
79600: PUSH
79601: LD_INT 2
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 58
79610: PUSH
79611: EMPTY
79612: LIST
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: PPUSH
79618: CALL_OW 72
79622: IN
79623: AND
79624: IFFALSE 79660
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
79626: LD_VAR 0 4
79630: PUSH
79631: LD_VAR 0 7
79635: ARRAY
79636: PPUSH
79637: LD_VAR 0 14
79641: PUSH
79642: LD_INT 1
79644: ARRAY
79645: PPUSH
79646: CALL_OW 120
// attacking := true ;
79650: LD_ADDR_VAR 0 29
79654: PUSH
79655: LD_INT 1
79657: ST_TO_ADDR
// continue ;
79658: GO 77833
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
79660: LD_VAR 0 26
79664: PUSH
79665: LD_VAR 0 4
79669: PUSH
79670: LD_VAR 0 7
79674: ARRAY
79675: PPUSH
79676: CALL_OW 257
79680: PUSH
79681: LD_INT 1
79683: EQUAL
79684: AND
79685: PUSH
79686: LD_VAR 0 4
79690: PUSH
79691: LD_VAR 0 7
79695: ARRAY
79696: PPUSH
79697: CALL_OW 256
79701: PUSH
79702: LD_INT 800
79704: LESS
79705: AND
79706: PUSH
79707: LD_VAR 0 4
79711: PUSH
79712: LD_VAR 0 7
79716: ARRAY
79717: PPUSH
79718: CALL_OW 318
79722: NOT
79723: AND
79724: IFFALSE 79741
// ComCrawl ( group [ i ] ) ;
79726: LD_VAR 0 4
79730: PUSH
79731: LD_VAR 0 7
79735: ARRAY
79736: PPUSH
79737: CALL_OW 137
// if f_mines then
79741: LD_VAR 0 21
79745: IFFALSE 79988
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
79747: LD_VAR 0 14
79751: PUSH
79752: LD_INT 1
79754: ARRAY
79755: PPUSH
79756: CALL_OW 247
79760: PUSH
79761: LD_INT 3
79763: EQUAL
79764: PUSH
79765: LD_VAR 0 14
79769: PUSH
79770: LD_INT 1
79772: ARRAY
79773: PUSH
79774: LD_VAR 0 27
79778: IN
79779: NOT
79780: AND
79781: IFFALSE 79988
// begin x := GetX ( tmp [ 1 ] ) ;
79783: LD_ADDR_VAR 0 10
79787: PUSH
79788: LD_VAR 0 14
79792: PUSH
79793: LD_INT 1
79795: ARRAY
79796: PPUSH
79797: CALL_OW 250
79801: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
79802: LD_ADDR_VAR 0 11
79806: PUSH
79807: LD_VAR 0 14
79811: PUSH
79812: LD_INT 1
79814: ARRAY
79815: PPUSH
79816: CALL_OW 251
79820: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
79821: LD_ADDR_VAR 0 12
79825: PUSH
79826: LD_VAR 0 4
79830: PUSH
79831: LD_VAR 0 7
79835: ARRAY
79836: PPUSH
79837: CALL 41681 0 1
79841: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
79842: LD_VAR 0 4
79846: PUSH
79847: LD_VAR 0 7
79851: ARRAY
79852: PPUSH
79853: LD_VAR 0 10
79857: PPUSH
79858: LD_VAR 0 11
79862: PPUSH
79863: LD_VAR 0 14
79867: PUSH
79868: LD_INT 1
79870: ARRAY
79871: PPUSH
79872: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
79876: LD_VAR 0 4
79880: PUSH
79881: LD_VAR 0 7
79885: ARRAY
79886: PPUSH
79887: LD_VAR 0 10
79891: PPUSH
79892: LD_VAR 0 12
79896: PPUSH
79897: LD_INT 7
79899: PPUSH
79900: CALL_OW 272
79904: PPUSH
79905: LD_VAR 0 11
79909: PPUSH
79910: LD_VAR 0 12
79914: PPUSH
79915: LD_INT 7
79917: PPUSH
79918: CALL_OW 273
79922: PPUSH
79923: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
79927: LD_VAR 0 4
79931: PUSH
79932: LD_VAR 0 7
79936: ARRAY
79937: PPUSH
79938: LD_INT 71
79940: PPUSH
79941: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
79945: LD_ADDR_VAR 0 27
79949: PUSH
79950: LD_VAR 0 27
79954: PPUSH
79955: LD_VAR 0 27
79959: PUSH
79960: LD_INT 1
79962: PLUS
79963: PPUSH
79964: LD_VAR 0 14
79968: PUSH
79969: LD_INT 1
79971: ARRAY
79972: PPUSH
79973: CALL_OW 1
79977: ST_TO_ADDR
// attacking := true ;
79978: LD_ADDR_VAR 0 29
79982: PUSH
79983: LD_INT 1
79985: ST_TO_ADDR
// continue ;
79986: GO 77833
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
79988: LD_VAR 0 4
79992: PUSH
79993: LD_VAR 0 7
79997: ARRAY
79998: PPUSH
79999: CALL_OW 257
80003: PUSH
80004: LD_INT 17
80006: EQUAL
80007: PUSH
80008: LD_VAR 0 4
80012: PUSH
80013: LD_VAR 0 7
80017: ARRAY
80018: PPUSH
80019: CALL_OW 110
80023: PUSH
80024: LD_INT 71
80026: EQUAL
80027: NOT
80028: AND
80029: IFFALSE 80175
// begin attacking := false ;
80031: LD_ADDR_VAR 0 29
80035: PUSH
80036: LD_INT 0
80038: ST_TO_ADDR
// k := 5 ;
80039: LD_ADDR_VAR 0 9
80043: PUSH
80044: LD_INT 5
80046: ST_TO_ADDR
// if tmp < k then
80047: LD_VAR 0 14
80051: PUSH
80052: LD_VAR 0 9
80056: LESS
80057: IFFALSE 80069
// k := tmp ;
80059: LD_ADDR_VAR 0 9
80063: PUSH
80064: LD_VAR 0 14
80068: ST_TO_ADDR
// for j = 1 to k do
80069: LD_ADDR_VAR 0 8
80073: PUSH
80074: DOUBLE
80075: LD_INT 1
80077: DEC
80078: ST_TO_ADDR
80079: LD_VAR 0 9
80083: PUSH
80084: FOR_TO
80085: IFFALSE 80173
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80087: LD_VAR 0 14
80091: PUSH
80092: LD_VAR 0 8
80096: ARRAY
80097: PUSH
80098: LD_VAR 0 14
80102: PPUSH
80103: LD_INT 58
80105: PUSH
80106: EMPTY
80107: LIST
80108: PPUSH
80109: CALL_OW 72
80113: IN
80114: NOT
80115: IFFALSE 80171
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80117: LD_VAR 0 4
80121: PUSH
80122: LD_VAR 0 7
80126: ARRAY
80127: PPUSH
80128: LD_VAR 0 14
80132: PUSH
80133: LD_VAR 0 8
80137: ARRAY
80138: PPUSH
80139: CALL_OW 115
// attacking := true ;
80143: LD_ADDR_VAR 0 29
80147: PUSH
80148: LD_INT 1
80150: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
80151: LD_VAR 0 4
80155: PUSH
80156: LD_VAR 0 7
80160: ARRAY
80161: PPUSH
80162: LD_INT 71
80164: PPUSH
80165: CALL_OW 109
// continue ;
80169: GO 80084
// end ; end ;
80171: GO 80084
80173: POP
80174: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
80175: LD_VAR 0 4
80179: PUSH
80180: LD_VAR 0 7
80184: ARRAY
80185: PPUSH
80186: CALL_OW 257
80190: PUSH
80191: LD_INT 8
80193: EQUAL
80194: PUSH
80195: LD_VAR 0 4
80199: PUSH
80200: LD_VAR 0 7
80204: ARRAY
80205: PPUSH
80206: CALL_OW 264
80210: PUSH
80211: LD_INT 28
80213: PUSH
80214: LD_INT 45
80216: PUSH
80217: LD_INT 7
80219: PUSH
80220: LD_INT 47
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: LIST
80227: LIST
80228: IN
80229: OR
80230: IFFALSE 80486
// begin attacking := false ;
80232: LD_ADDR_VAR 0 29
80236: PUSH
80237: LD_INT 0
80239: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
80240: LD_VAR 0 14
80244: PUSH
80245: LD_INT 1
80247: ARRAY
80248: PPUSH
80249: CALL_OW 266
80253: PUSH
80254: LD_INT 32
80256: PUSH
80257: LD_INT 31
80259: PUSH
80260: LD_INT 33
80262: PUSH
80263: LD_INT 4
80265: PUSH
80266: LD_INT 5
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: IN
80276: IFFALSE 80462
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
80278: LD_ADDR_VAR 0 9
80282: PUSH
80283: LD_VAR 0 14
80287: PUSH
80288: LD_INT 1
80290: ARRAY
80291: PPUSH
80292: CALL_OW 266
80296: PPUSH
80297: LD_VAR 0 14
80301: PUSH
80302: LD_INT 1
80304: ARRAY
80305: PPUSH
80306: CALL_OW 250
80310: PPUSH
80311: LD_VAR 0 14
80315: PUSH
80316: LD_INT 1
80318: ARRAY
80319: PPUSH
80320: CALL_OW 251
80324: PPUSH
80325: LD_VAR 0 14
80329: PUSH
80330: LD_INT 1
80332: ARRAY
80333: PPUSH
80334: CALL_OW 254
80338: PPUSH
80339: LD_VAR 0 14
80343: PUSH
80344: LD_INT 1
80346: ARRAY
80347: PPUSH
80348: CALL_OW 248
80352: PPUSH
80353: LD_INT 0
80355: PPUSH
80356: CALL 23051 0 6
80360: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
80361: LD_ADDR_VAR 0 8
80365: PUSH
80366: LD_VAR 0 4
80370: PUSH
80371: LD_VAR 0 7
80375: ARRAY
80376: PPUSH
80377: LD_VAR 0 9
80381: PPUSH
80382: CALL 41721 0 2
80386: ST_TO_ADDR
// if j then
80387: LD_VAR 0 8
80391: IFFALSE 80460
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80393: LD_VAR 0 8
80397: PUSH
80398: LD_INT 1
80400: ARRAY
80401: PPUSH
80402: LD_VAR 0 8
80406: PUSH
80407: LD_INT 2
80409: ARRAY
80410: PPUSH
80411: CALL_OW 488
80415: IFFALSE 80460
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
80417: LD_VAR 0 4
80421: PUSH
80422: LD_VAR 0 7
80426: ARRAY
80427: PPUSH
80428: LD_VAR 0 8
80432: PUSH
80433: LD_INT 1
80435: ARRAY
80436: PPUSH
80437: LD_VAR 0 8
80441: PUSH
80442: LD_INT 2
80444: ARRAY
80445: PPUSH
80446: CALL_OW 116
// attacking := true ;
80450: LD_ADDR_VAR 0 29
80454: PUSH
80455: LD_INT 1
80457: ST_TO_ADDR
// continue ;
80458: GO 77833
// end ; end else
80460: GO 80486
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80462: LD_VAR 0 4
80466: PUSH
80467: LD_VAR 0 7
80471: ARRAY
80472: PPUSH
80473: LD_VAR 0 14
80477: PUSH
80478: LD_INT 1
80480: ARRAY
80481: PPUSH
80482: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80486: LD_VAR 0 4
80490: PUSH
80491: LD_VAR 0 7
80495: ARRAY
80496: PPUSH
80497: CALL_OW 265
80501: PUSH
80502: LD_INT 11
80504: EQUAL
80505: IFFALSE 80783
// begin k := 10 ;
80507: LD_ADDR_VAR 0 9
80511: PUSH
80512: LD_INT 10
80514: ST_TO_ADDR
// x := 0 ;
80515: LD_ADDR_VAR 0 10
80519: PUSH
80520: LD_INT 0
80522: ST_TO_ADDR
// if tmp < k then
80523: LD_VAR 0 14
80527: PUSH
80528: LD_VAR 0 9
80532: LESS
80533: IFFALSE 80545
// k := tmp ;
80535: LD_ADDR_VAR 0 9
80539: PUSH
80540: LD_VAR 0 14
80544: ST_TO_ADDR
// for j = k downto 1 do
80545: LD_ADDR_VAR 0 8
80549: PUSH
80550: DOUBLE
80551: LD_VAR 0 9
80555: INC
80556: ST_TO_ADDR
80557: LD_INT 1
80559: PUSH
80560: FOR_DOWNTO
80561: IFFALSE 80636
// begin if GetType ( tmp [ j ] ) = unit_human then
80563: LD_VAR 0 14
80567: PUSH
80568: LD_VAR 0 8
80572: ARRAY
80573: PPUSH
80574: CALL_OW 247
80578: PUSH
80579: LD_INT 1
80581: EQUAL
80582: IFFALSE 80634
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
80584: LD_VAR 0 4
80588: PUSH
80589: LD_VAR 0 7
80593: ARRAY
80594: PPUSH
80595: LD_VAR 0 14
80599: PUSH
80600: LD_VAR 0 8
80604: ARRAY
80605: PPUSH
80606: CALL 41992 0 2
// x := tmp [ j ] ;
80610: LD_ADDR_VAR 0 10
80614: PUSH
80615: LD_VAR 0 14
80619: PUSH
80620: LD_VAR 0 8
80624: ARRAY
80625: ST_TO_ADDR
// attacking := true ;
80626: LD_ADDR_VAR 0 29
80630: PUSH
80631: LD_INT 1
80633: ST_TO_ADDR
// end ; end ;
80634: GO 80560
80636: POP
80637: POP
// if not x then
80638: LD_VAR 0 10
80642: NOT
80643: IFFALSE 80783
// begin attacking := true ;
80645: LD_ADDR_VAR 0 29
80649: PUSH
80650: LD_INT 1
80652: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
80653: LD_VAR 0 4
80657: PUSH
80658: LD_VAR 0 7
80662: ARRAY
80663: PPUSH
80664: CALL_OW 250
80668: PPUSH
80669: LD_VAR 0 4
80673: PUSH
80674: LD_VAR 0 7
80678: ARRAY
80679: PPUSH
80680: CALL_OW 251
80684: PPUSH
80685: CALL_OW 546
80689: PUSH
80690: LD_INT 2
80692: ARRAY
80693: PUSH
80694: LD_VAR 0 14
80698: PUSH
80699: LD_INT 1
80701: ARRAY
80702: PPUSH
80703: CALL_OW 250
80707: PPUSH
80708: LD_VAR 0 14
80712: PUSH
80713: LD_INT 1
80715: ARRAY
80716: PPUSH
80717: CALL_OW 251
80721: PPUSH
80722: CALL_OW 546
80726: PUSH
80727: LD_INT 2
80729: ARRAY
80730: EQUAL
80731: IFFALSE 80759
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
80733: LD_VAR 0 4
80737: PUSH
80738: LD_VAR 0 7
80742: ARRAY
80743: PPUSH
80744: LD_VAR 0 14
80748: PUSH
80749: LD_INT 1
80751: ARRAY
80752: PPUSH
80753: CALL 41992 0 2
80757: GO 80783
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80759: LD_VAR 0 4
80763: PUSH
80764: LD_VAR 0 7
80768: ARRAY
80769: PPUSH
80770: LD_VAR 0 14
80774: PUSH
80775: LD_INT 1
80777: ARRAY
80778: PPUSH
80779: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
80783: LD_VAR 0 4
80787: PUSH
80788: LD_VAR 0 7
80792: ARRAY
80793: PPUSH
80794: CALL_OW 264
80798: PUSH
80799: LD_INT 29
80801: EQUAL
80802: IFFALSE 81168
// begin if WantsToAttack ( group [ i ] ) in bombed then
80804: LD_VAR 0 4
80808: PUSH
80809: LD_VAR 0 7
80813: ARRAY
80814: PPUSH
80815: CALL_OW 319
80819: PUSH
80820: LD_VAR 0 28
80824: IN
80825: IFFALSE 80829
// continue ;
80827: GO 77833
// k := 8 ;
80829: LD_ADDR_VAR 0 9
80833: PUSH
80834: LD_INT 8
80836: ST_TO_ADDR
// x := 0 ;
80837: LD_ADDR_VAR 0 10
80841: PUSH
80842: LD_INT 0
80844: ST_TO_ADDR
// if tmp < k then
80845: LD_VAR 0 14
80849: PUSH
80850: LD_VAR 0 9
80854: LESS
80855: IFFALSE 80867
// k := tmp ;
80857: LD_ADDR_VAR 0 9
80861: PUSH
80862: LD_VAR 0 14
80866: ST_TO_ADDR
// for j = 1 to k do
80867: LD_ADDR_VAR 0 8
80871: PUSH
80872: DOUBLE
80873: LD_INT 1
80875: DEC
80876: ST_TO_ADDR
80877: LD_VAR 0 9
80881: PUSH
80882: FOR_TO
80883: IFFALSE 81015
// begin if GetType ( tmp [ j ] ) = unit_building then
80885: LD_VAR 0 14
80889: PUSH
80890: LD_VAR 0 8
80894: ARRAY
80895: PPUSH
80896: CALL_OW 247
80900: PUSH
80901: LD_INT 3
80903: EQUAL
80904: IFFALSE 81013
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
80906: LD_VAR 0 14
80910: PUSH
80911: LD_VAR 0 8
80915: ARRAY
80916: PUSH
80917: LD_VAR 0 28
80921: IN
80922: NOT
80923: PUSH
80924: LD_VAR 0 14
80928: PUSH
80929: LD_VAR 0 8
80933: ARRAY
80934: PPUSH
80935: CALL_OW 313
80939: AND
80940: IFFALSE 81013
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80942: LD_VAR 0 4
80946: PUSH
80947: LD_VAR 0 7
80951: ARRAY
80952: PPUSH
80953: LD_VAR 0 14
80957: PUSH
80958: LD_VAR 0 8
80962: ARRAY
80963: PPUSH
80964: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
80968: LD_ADDR_VAR 0 28
80972: PUSH
80973: LD_VAR 0 28
80977: PPUSH
80978: LD_VAR 0 28
80982: PUSH
80983: LD_INT 1
80985: PLUS
80986: PPUSH
80987: LD_VAR 0 14
80991: PUSH
80992: LD_VAR 0 8
80996: ARRAY
80997: PPUSH
80998: CALL_OW 1
81002: ST_TO_ADDR
// attacking := true ;
81003: LD_ADDR_VAR 0 29
81007: PUSH
81008: LD_INT 1
81010: ST_TO_ADDR
// break ;
81011: GO 81015
// end ; end ;
81013: GO 80882
81015: POP
81016: POP
// if not attacking and f_attack_depot then
81017: LD_VAR 0 29
81021: NOT
81022: PUSH
81023: LD_VAR 0 25
81027: AND
81028: IFFALSE 81123
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81030: LD_ADDR_VAR 0 13
81034: PUSH
81035: LD_VAR 0 14
81039: PPUSH
81040: LD_INT 2
81042: PUSH
81043: LD_INT 30
81045: PUSH
81046: LD_INT 0
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 30
81055: PUSH
81056: LD_INT 1
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: LIST
81067: PPUSH
81068: CALL_OW 72
81072: ST_TO_ADDR
// if z then
81073: LD_VAR 0 13
81077: IFFALSE 81123
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81079: LD_VAR 0 4
81083: PUSH
81084: LD_VAR 0 7
81088: ARRAY
81089: PPUSH
81090: LD_VAR 0 13
81094: PPUSH
81095: LD_VAR 0 4
81099: PUSH
81100: LD_VAR 0 7
81104: ARRAY
81105: PPUSH
81106: CALL_OW 74
81110: PPUSH
81111: CALL_OW 115
// attacking := true ;
81115: LD_ADDR_VAR 0 29
81119: PUSH
81120: LD_INT 1
81122: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
81123: LD_VAR 0 4
81127: PUSH
81128: LD_VAR 0 7
81132: ARRAY
81133: PPUSH
81134: CALL_OW 256
81138: PUSH
81139: LD_INT 500
81141: LESS
81142: IFFALSE 81168
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81144: LD_VAR 0 4
81148: PUSH
81149: LD_VAR 0 7
81153: ARRAY
81154: PPUSH
81155: LD_VAR 0 14
81159: PUSH
81160: LD_INT 1
81162: ARRAY
81163: PPUSH
81164: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
81168: LD_VAR 0 4
81172: PUSH
81173: LD_VAR 0 7
81177: ARRAY
81178: PPUSH
81179: CALL_OW 264
81183: PUSH
81184: LD_INT 49
81186: EQUAL
81187: IFFALSE 81308
// begin if not HasTask ( group [ i ] ) then
81189: LD_VAR 0 4
81193: PUSH
81194: LD_VAR 0 7
81198: ARRAY
81199: PPUSH
81200: CALL_OW 314
81204: NOT
81205: IFFALSE 81308
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
81207: LD_ADDR_VAR 0 9
81211: PUSH
81212: LD_INT 81
81214: PUSH
81215: LD_VAR 0 4
81219: PUSH
81220: LD_VAR 0 7
81224: ARRAY
81225: PPUSH
81226: CALL_OW 255
81230: PUSH
81231: EMPTY
81232: LIST
81233: LIST
81234: PPUSH
81235: CALL_OW 69
81239: PPUSH
81240: LD_VAR 0 4
81244: PUSH
81245: LD_VAR 0 7
81249: ARRAY
81250: PPUSH
81251: CALL_OW 74
81255: ST_TO_ADDR
// if k then
81256: LD_VAR 0 9
81260: IFFALSE 81308
// if GetDistUnits ( group [ i ] , k ) > 10 then
81262: LD_VAR 0 4
81266: PUSH
81267: LD_VAR 0 7
81271: ARRAY
81272: PPUSH
81273: LD_VAR 0 9
81277: PPUSH
81278: CALL_OW 296
81282: PUSH
81283: LD_INT 10
81285: GREATER
81286: IFFALSE 81308
// ComMoveUnit ( group [ i ] , k ) ;
81288: LD_VAR 0 4
81292: PUSH
81293: LD_VAR 0 7
81297: ARRAY
81298: PPUSH
81299: LD_VAR 0 9
81303: PPUSH
81304: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81308: LD_VAR 0 4
81312: PUSH
81313: LD_VAR 0 7
81317: ARRAY
81318: PPUSH
81319: CALL_OW 256
81323: PUSH
81324: LD_INT 250
81326: LESS
81327: PUSH
81328: LD_VAR 0 4
81332: PUSH
81333: LD_VAR 0 7
81337: ARRAY
81338: PUSH
81339: LD_INT 21
81341: PUSH
81342: LD_INT 2
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 23
81351: PUSH
81352: LD_INT 2
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: EMPTY
81360: LIST
81361: LIST
81362: PPUSH
81363: CALL_OW 69
81367: IN
81368: AND
81369: IFFALSE 81494
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
81371: LD_ADDR_VAR 0 9
81375: PUSH
81376: LD_OWVAR 3
81380: PUSH
81381: LD_VAR 0 4
81385: PUSH
81386: LD_VAR 0 7
81390: ARRAY
81391: DIFF
81392: PPUSH
81393: LD_VAR 0 4
81397: PUSH
81398: LD_VAR 0 7
81402: ARRAY
81403: PPUSH
81404: CALL_OW 74
81408: ST_TO_ADDR
// if not k then
81409: LD_VAR 0 9
81413: NOT
81414: IFFALSE 81418
// continue ;
81416: GO 77833
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
81418: LD_VAR 0 9
81422: PUSH
81423: LD_INT 81
81425: PUSH
81426: LD_VAR 0 4
81430: PUSH
81431: LD_VAR 0 7
81435: ARRAY
81436: PPUSH
81437: CALL_OW 255
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: PPUSH
81446: CALL_OW 69
81450: IN
81451: PUSH
81452: LD_VAR 0 9
81456: PPUSH
81457: LD_VAR 0 4
81461: PUSH
81462: LD_VAR 0 7
81466: ARRAY
81467: PPUSH
81468: CALL_OW 296
81472: PUSH
81473: LD_INT 5
81475: LESS
81476: AND
81477: IFFALSE 81494
// ComAutodestruct ( group [ i ] ) ;
81479: LD_VAR 0 4
81483: PUSH
81484: LD_VAR 0 7
81488: ARRAY
81489: PPUSH
81490: CALL 41890 0 1
// end ; if f_attack_depot then
81494: LD_VAR 0 25
81498: IFFALSE 81610
// begin k := 6 ;
81500: LD_ADDR_VAR 0 9
81504: PUSH
81505: LD_INT 6
81507: ST_TO_ADDR
// if tmp < k then
81508: LD_VAR 0 14
81512: PUSH
81513: LD_VAR 0 9
81517: LESS
81518: IFFALSE 81530
// k := tmp ;
81520: LD_ADDR_VAR 0 9
81524: PUSH
81525: LD_VAR 0 14
81529: ST_TO_ADDR
// for j = 1 to k do
81530: LD_ADDR_VAR 0 8
81534: PUSH
81535: DOUBLE
81536: LD_INT 1
81538: DEC
81539: ST_TO_ADDR
81540: LD_VAR 0 9
81544: PUSH
81545: FOR_TO
81546: IFFALSE 81608
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
81548: LD_VAR 0 8
81552: PPUSH
81553: CALL_OW 266
81557: PUSH
81558: LD_INT 0
81560: PUSH
81561: LD_INT 1
81563: PUSH
81564: EMPTY
81565: LIST
81566: LIST
81567: IN
81568: IFFALSE 81606
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81570: LD_VAR 0 4
81574: PUSH
81575: LD_VAR 0 7
81579: ARRAY
81580: PPUSH
81581: LD_VAR 0 14
81585: PUSH
81586: LD_VAR 0 8
81590: ARRAY
81591: PPUSH
81592: CALL_OW 115
// attacking := true ;
81596: LD_ADDR_VAR 0 29
81600: PUSH
81601: LD_INT 1
81603: ST_TO_ADDR
// break ;
81604: GO 81608
// end ;
81606: GO 81545
81608: POP
81609: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
81610: LD_VAR 0 4
81614: PUSH
81615: LD_VAR 0 7
81619: ARRAY
81620: PPUSH
81621: CALL_OW 302
81625: PUSH
81626: LD_VAR 0 29
81630: NOT
81631: AND
81632: IFFALSE 81954
// begin if GetTag ( group [ i ] ) = 71 then
81634: LD_VAR 0 4
81638: PUSH
81639: LD_VAR 0 7
81643: ARRAY
81644: PPUSH
81645: CALL_OW 110
81649: PUSH
81650: LD_INT 71
81652: EQUAL
81653: IFFALSE 81694
// begin if HasTask ( group [ i ] ) then
81655: LD_VAR 0 4
81659: PUSH
81660: LD_VAR 0 7
81664: ARRAY
81665: PPUSH
81666: CALL_OW 314
81670: IFFALSE 81676
// continue else
81672: GO 77833
81674: GO 81694
// SetTag ( group [ i ] , 0 ) ;
81676: LD_VAR 0 4
81680: PUSH
81681: LD_VAR 0 7
81685: ARRAY
81686: PPUSH
81687: LD_INT 0
81689: PPUSH
81690: CALL_OW 109
// end ; k := 8 ;
81694: LD_ADDR_VAR 0 9
81698: PUSH
81699: LD_INT 8
81701: ST_TO_ADDR
// x := 0 ;
81702: LD_ADDR_VAR 0 10
81706: PUSH
81707: LD_INT 0
81709: ST_TO_ADDR
// if tmp < k then
81710: LD_VAR 0 14
81714: PUSH
81715: LD_VAR 0 9
81719: LESS
81720: IFFALSE 81732
// k := tmp ;
81722: LD_ADDR_VAR 0 9
81726: PUSH
81727: LD_VAR 0 14
81731: ST_TO_ADDR
// for j = 1 to k do
81732: LD_ADDR_VAR 0 8
81736: PUSH
81737: DOUBLE
81738: LD_INT 1
81740: DEC
81741: ST_TO_ADDR
81742: LD_VAR 0 9
81746: PUSH
81747: FOR_TO
81748: IFFALSE 81846
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
81750: LD_VAR 0 14
81754: PUSH
81755: LD_VAR 0 8
81759: ARRAY
81760: PPUSH
81761: CALL_OW 247
81765: PUSH
81766: LD_INT 1
81768: EQUAL
81769: PUSH
81770: LD_VAR 0 14
81774: PUSH
81775: LD_VAR 0 8
81779: ARRAY
81780: PPUSH
81781: CALL_OW 256
81785: PUSH
81786: LD_INT 250
81788: LESS
81789: PUSH
81790: LD_VAR 0 20
81794: AND
81795: PUSH
81796: LD_VAR 0 20
81800: NOT
81801: PUSH
81802: LD_VAR 0 14
81806: PUSH
81807: LD_VAR 0 8
81811: ARRAY
81812: PPUSH
81813: CALL_OW 256
81817: PUSH
81818: LD_INT 250
81820: GREATEREQUAL
81821: AND
81822: OR
81823: AND
81824: IFFALSE 81844
// begin x := tmp [ j ] ;
81826: LD_ADDR_VAR 0 10
81830: PUSH
81831: LD_VAR 0 14
81835: PUSH
81836: LD_VAR 0 8
81840: ARRAY
81841: ST_TO_ADDR
// break ;
81842: GO 81846
// end ;
81844: GO 81747
81846: POP
81847: POP
// if x then
81848: LD_VAR 0 10
81852: IFFALSE 81876
// ComAttackUnit ( group [ i ] , x ) else
81854: LD_VAR 0 4
81858: PUSH
81859: LD_VAR 0 7
81863: ARRAY
81864: PPUSH
81865: LD_VAR 0 10
81869: PPUSH
81870: CALL_OW 115
81874: GO 81900
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81876: LD_VAR 0 4
81880: PUSH
81881: LD_VAR 0 7
81885: ARRAY
81886: PPUSH
81887: LD_VAR 0 14
81891: PUSH
81892: LD_INT 1
81894: ARRAY
81895: PPUSH
81896: CALL_OW 115
// if not HasTask ( group [ i ] ) then
81900: LD_VAR 0 4
81904: PUSH
81905: LD_VAR 0 7
81909: ARRAY
81910: PPUSH
81911: CALL_OW 314
81915: NOT
81916: IFFALSE 81954
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
81918: LD_VAR 0 4
81922: PUSH
81923: LD_VAR 0 7
81927: ARRAY
81928: PPUSH
81929: LD_VAR 0 14
81933: PPUSH
81934: LD_VAR 0 4
81938: PUSH
81939: LD_VAR 0 7
81943: ARRAY
81944: PPUSH
81945: CALL_OW 74
81949: PPUSH
81950: CALL_OW 115
// end ; end ; end ;
81954: GO 77833
81956: POP
81957: POP
// wait ( 0 0$2 ) ;
81958: LD_INT 70
81960: PPUSH
81961: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
81965: LD_VAR 0 4
81969: NOT
81970: PUSH
81971: LD_VAR 0 4
81975: PUSH
81976: EMPTY
81977: EQUAL
81978: OR
81979: PUSH
81980: LD_INT 81
81982: PUSH
81983: LD_VAR 0 35
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PPUSH
81992: CALL_OW 69
81996: NOT
81997: OR
81998: IFFALSE 77818
// end ;
82000: LD_VAR 0 2
82004: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
82005: LD_INT 0
82007: PPUSH
82008: PPUSH
82009: PPUSH
82010: PPUSH
82011: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
82012: LD_VAR 0 1
82016: NOT
82017: PUSH
82018: LD_EXP 42
82022: PUSH
82023: LD_VAR 0 1
82027: ARRAY
82028: NOT
82029: OR
82030: PUSH
82031: LD_VAR 0 2
82035: NOT
82036: OR
82037: PUSH
82038: LD_VAR 0 3
82042: NOT
82043: OR
82044: IFFALSE 82048
// exit ;
82046: GO 82561
// side := mc_sides [ base ] ;
82048: LD_ADDR_VAR 0 6
82052: PUSH
82053: LD_EXP 68
82057: PUSH
82058: LD_VAR 0 1
82062: ARRAY
82063: ST_TO_ADDR
// if not side then
82064: LD_VAR 0 6
82068: NOT
82069: IFFALSE 82073
// exit ;
82071: GO 82561
// for i in solds do
82073: LD_ADDR_VAR 0 7
82077: PUSH
82078: LD_VAR 0 2
82082: PUSH
82083: FOR_IN
82084: IFFALSE 82145
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
82086: LD_VAR 0 7
82090: PPUSH
82091: CALL_OW 310
82095: PPUSH
82096: CALL_OW 266
82100: PUSH
82101: LD_INT 32
82103: PUSH
82104: LD_INT 31
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: IN
82111: IFFALSE 82131
// solds := solds diff i else
82113: LD_ADDR_VAR 0 2
82117: PUSH
82118: LD_VAR 0 2
82122: PUSH
82123: LD_VAR 0 7
82127: DIFF
82128: ST_TO_ADDR
82129: GO 82143
// SetTag ( i , 18 ) ;
82131: LD_VAR 0 7
82135: PPUSH
82136: LD_INT 18
82138: PPUSH
82139: CALL_OW 109
82143: GO 82083
82145: POP
82146: POP
// if not solds then
82147: LD_VAR 0 2
82151: NOT
82152: IFFALSE 82156
// exit ;
82154: GO 82561
// repeat wait ( 0 0$2 ) ;
82156: LD_INT 70
82158: PPUSH
82159: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
82163: LD_ADDR_VAR 0 5
82167: PUSH
82168: LD_VAR 0 6
82172: PPUSH
82173: LD_VAR 0 3
82177: PPUSH
82178: CALL 11605 0 2
82182: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82183: LD_EXP 42
82187: PUSH
82188: LD_VAR 0 1
82192: ARRAY
82193: NOT
82194: PUSH
82195: LD_EXP 42
82199: PUSH
82200: LD_VAR 0 1
82204: ARRAY
82205: PUSH
82206: EMPTY
82207: EQUAL
82208: OR
82209: IFFALSE 82246
// begin for i in solds do
82211: LD_ADDR_VAR 0 7
82215: PUSH
82216: LD_VAR 0 2
82220: PUSH
82221: FOR_IN
82222: IFFALSE 82235
// ComStop ( i ) ;
82224: LD_VAR 0 7
82228: PPUSH
82229: CALL_OW 141
82233: GO 82221
82235: POP
82236: POP
// solds := [ ] ;
82237: LD_ADDR_VAR 0 2
82241: PUSH
82242: EMPTY
82243: ST_TO_ADDR
// exit ;
82244: GO 82561
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
82246: LD_VAR 0 5
82250: NOT
82251: PUSH
82252: LD_VAR 0 5
82256: PUSH
82257: LD_INT 3
82259: GREATER
82260: OR
82261: PUSH
82262: LD_EXP 64
82266: PUSH
82267: LD_VAR 0 1
82271: ARRAY
82272: OR
82273: IFFALSE 82314
// begin for i in solds do
82275: LD_ADDR_VAR 0 7
82279: PUSH
82280: LD_VAR 0 2
82284: PUSH
82285: FOR_IN
82286: IFFALSE 82310
// if HasTask ( i ) then
82288: LD_VAR 0 7
82292: PPUSH
82293: CALL_OW 314
82297: IFFALSE 82308
// ComStop ( i ) ;
82299: LD_VAR 0 7
82303: PPUSH
82304: CALL_OW 141
82308: GO 82285
82310: POP
82311: POP
// break ;
82312: GO 82549
// end ; for i in solds do
82314: LD_ADDR_VAR 0 7
82318: PUSH
82319: LD_VAR 0 2
82323: PUSH
82324: FOR_IN
82325: IFFALSE 82541
// begin if IsInUnit ( i ) then
82327: LD_VAR 0 7
82331: PPUSH
82332: CALL_OW 310
82336: IFFALSE 82347
// ComExitBuilding ( i ) ;
82338: LD_VAR 0 7
82342: PPUSH
82343: CALL_OW 122
// if GetLives ( i ) > 333 then
82347: LD_VAR 0 7
82351: PPUSH
82352: CALL_OW 256
82356: PUSH
82357: LD_INT 333
82359: GREATER
82360: IFFALSE 82388
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
82362: LD_VAR 0 7
82366: PPUSH
82367: LD_VAR 0 5
82371: PPUSH
82372: LD_VAR 0 7
82376: PPUSH
82377: CALL_OW 74
82381: PPUSH
82382: CALL_OW 115
82386: GO 82539
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
82388: LD_ADDR_VAR 0 8
82392: PUSH
82393: LD_EXP 42
82397: PUSH
82398: LD_VAR 0 1
82402: ARRAY
82403: PPUSH
82404: LD_INT 2
82406: PUSH
82407: LD_INT 30
82409: PUSH
82410: LD_INT 0
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 30
82419: PUSH
82420: LD_INT 1
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: LD_INT 30
82429: PUSH
82430: LD_INT 6
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: EMPTY
82438: LIST
82439: LIST
82440: LIST
82441: LIST
82442: PPUSH
82443: CALL_OW 72
82447: PPUSH
82448: LD_VAR 0 7
82452: PPUSH
82453: CALL_OW 74
82457: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
82458: LD_VAR 0 7
82462: PPUSH
82463: LD_VAR 0 8
82467: PPUSH
82468: CALL_OW 250
82472: PPUSH
82473: LD_INT 3
82475: PPUSH
82476: LD_INT 5
82478: PPUSH
82479: CALL_OW 272
82483: PPUSH
82484: LD_VAR 0 8
82488: PPUSH
82489: CALL_OW 251
82493: PPUSH
82494: LD_INT 3
82496: PPUSH
82497: LD_INT 5
82499: PPUSH
82500: CALL_OW 273
82504: PPUSH
82505: CALL_OW 111
// SetTag ( i , 0 ) ;
82509: LD_VAR 0 7
82513: PPUSH
82514: LD_INT 0
82516: PPUSH
82517: CALL_OW 109
// solds := solds diff i ;
82521: LD_ADDR_VAR 0 2
82525: PUSH
82526: LD_VAR 0 2
82530: PUSH
82531: LD_VAR 0 7
82535: DIFF
82536: ST_TO_ADDR
// continue ;
82537: GO 82324
// end ; end ;
82539: GO 82324
82541: POP
82542: POP
// until solds ;
82543: LD_VAR 0 2
82547: IFFALSE 82156
// MC_Reset ( base , 18 ) ;
82549: LD_VAR 0 1
82553: PPUSH
82554: LD_INT 18
82556: PPUSH
82557: CALL 51140 0 2
// end ;
82561: LD_VAR 0 4
82565: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
82566: LD_INT 0
82568: PPUSH
82569: PPUSH
82570: PPUSH
82571: PPUSH
82572: PPUSH
82573: PPUSH
82574: PPUSH
82575: PPUSH
82576: PPUSH
82577: PPUSH
82578: PPUSH
82579: PPUSH
82580: PPUSH
82581: PPUSH
82582: PPUSH
82583: PPUSH
82584: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
82585: LD_ADDR_VAR 0 13
82589: PUSH
82590: LD_EXP 42
82594: PUSH
82595: LD_VAR 0 1
82599: ARRAY
82600: PPUSH
82601: LD_INT 25
82603: PUSH
82604: LD_INT 3
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PPUSH
82611: CALL_OW 72
82615: ST_TO_ADDR
// if mc_remote_driver [ base ] then
82616: LD_EXP 82
82620: PUSH
82621: LD_VAR 0 1
82625: ARRAY
82626: IFFALSE 82650
// mechs := mechs diff mc_remote_driver [ base ] ;
82628: LD_ADDR_VAR 0 13
82632: PUSH
82633: LD_VAR 0 13
82637: PUSH
82638: LD_EXP 82
82642: PUSH
82643: LD_VAR 0 1
82647: ARRAY
82648: DIFF
82649: ST_TO_ADDR
// for i in mechs do
82650: LD_ADDR_VAR 0 5
82654: PUSH
82655: LD_VAR 0 13
82659: PUSH
82660: FOR_IN
82661: IFFALSE 82696
// if GetTag ( i ) > 0 then
82663: LD_VAR 0 5
82667: PPUSH
82668: CALL_OW 110
82672: PUSH
82673: LD_INT 0
82675: GREATER
82676: IFFALSE 82694
// mechs := mechs diff i ;
82678: LD_ADDR_VAR 0 13
82682: PUSH
82683: LD_VAR 0 13
82687: PUSH
82688: LD_VAR 0 5
82692: DIFF
82693: ST_TO_ADDR
82694: GO 82660
82696: POP
82697: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
82698: LD_ADDR_VAR 0 9
82702: PUSH
82703: LD_EXP 42
82707: PUSH
82708: LD_VAR 0 1
82712: ARRAY
82713: PPUSH
82714: LD_INT 2
82716: PUSH
82717: LD_INT 25
82719: PUSH
82720: LD_INT 1
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 25
82729: PUSH
82730: LD_INT 5
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 25
82739: PUSH
82740: LD_INT 8
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: PUSH
82747: LD_INT 25
82749: PUSH
82750: LD_INT 9
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: PPUSH
82764: CALL_OW 72
82768: ST_TO_ADDR
// if not defenders and not solds then
82769: LD_VAR 0 2
82773: NOT
82774: PUSH
82775: LD_VAR 0 9
82779: NOT
82780: AND
82781: IFFALSE 82785
// exit ;
82783: GO 84475
// depot_under_attack := false ;
82785: LD_ADDR_VAR 0 17
82789: PUSH
82790: LD_INT 0
82792: ST_TO_ADDR
// sold_defenders := [ ] ;
82793: LD_ADDR_VAR 0 18
82797: PUSH
82798: EMPTY
82799: ST_TO_ADDR
// if mechs then
82800: LD_VAR 0 13
82804: IFFALSE 82957
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
82806: LD_ADDR_VAR 0 5
82810: PUSH
82811: LD_VAR 0 2
82815: PPUSH
82816: LD_INT 21
82818: PUSH
82819: LD_INT 2
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: PPUSH
82826: CALL_OW 72
82830: PUSH
82831: FOR_IN
82832: IFFALSE 82955
// begin if GetTag ( i ) <> 20 then
82834: LD_VAR 0 5
82838: PPUSH
82839: CALL_OW 110
82843: PUSH
82844: LD_INT 20
82846: NONEQUAL
82847: IFFALSE 82861
// SetTag ( i , 20 ) ;
82849: LD_VAR 0 5
82853: PPUSH
82854: LD_INT 20
82856: PPUSH
82857: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
82861: LD_VAR 0 5
82865: PPUSH
82866: CALL_OW 263
82870: PUSH
82871: LD_INT 1
82873: EQUAL
82874: PUSH
82875: LD_VAR 0 5
82879: PPUSH
82880: CALL_OW 311
82884: NOT
82885: AND
82886: IFFALSE 82953
// begin un := mechs [ 1 ] ;
82888: LD_ADDR_VAR 0 11
82892: PUSH
82893: LD_VAR 0 13
82897: PUSH
82898: LD_INT 1
82900: ARRAY
82901: ST_TO_ADDR
// ComExit ( un ) ;
82902: LD_VAR 0 11
82906: PPUSH
82907: CALL 46235 0 1
// AddComEnterUnit ( un , i ) ;
82911: LD_VAR 0 11
82915: PPUSH
82916: LD_VAR 0 5
82920: PPUSH
82921: CALL_OW 180
// SetTag ( un , 19 ) ;
82925: LD_VAR 0 11
82929: PPUSH
82930: LD_INT 19
82932: PPUSH
82933: CALL_OW 109
// mechs := mechs diff un ;
82937: LD_ADDR_VAR 0 13
82941: PUSH
82942: LD_VAR 0 13
82946: PUSH
82947: LD_VAR 0 11
82951: DIFF
82952: ST_TO_ADDR
// end ; end ;
82953: GO 82831
82955: POP
82956: POP
// if solds then
82957: LD_VAR 0 9
82961: IFFALSE 83020
// for i in solds do
82963: LD_ADDR_VAR 0 5
82967: PUSH
82968: LD_VAR 0 9
82972: PUSH
82973: FOR_IN
82974: IFFALSE 83018
// if not GetTag ( i ) then
82976: LD_VAR 0 5
82980: PPUSH
82981: CALL_OW 110
82985: NOT
82986: IFFALSE 83016
// begin defenders := defenders union i ;
82988: LD_ADDR_VAR 0 2
82992: PUSH
82993: LD_VAR 0 2
82997: PUSH
82998: LD_VAR 0 5
83002: UNION
83003: ST_TO_ADDR
// SetTag ( i , 18 ) ;
83004: LD_VAR 0 5
83008: PPUSH
83009: LD_INT 18
83011: PPUSH
83012: CALL_OW 109
// end ;
83016: GO 82973
83018: POP
83019: POP
// repeat wait ( 0 0$2 ) ;
83020: LD_INT 70
83022: PPUSH
83023: CALL_OW 67
// enemy := mc_scan [ base ] ;
83027: LD_ADDR_VAR 0 3
83031: PUSH
83032: LD_EXP 65
83036: PUSH
83037: LD_VAR 0 1
83041: ARRAY
83042: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83043: LD_EXP 42
83047: PUSH
83048: LD_VAR 0 1
83052: ARRAY
83053: NOT
83054: PUSH
83055: LD_EXP 42
83059: PUSH
83060: LD_VAR 0 1
83064: ARRAY
83065: PUSH
83066: EMPTY
83067: EQUAL
83068: OR
83069: IFFALSE 83106
// begin for i in defenders do
83071: LD_ADDR_VAR 0 5
83075: PUSH
83076: LD_VAR 0 2
83080: PUSH
83081: FOR_IN
83082: IFFALSE 83095
// ComStop ( i ) ;
83084: LD_VAR 0 5
83088: PPUSH
83089: CALL_OW 141
83093: GO 83081
83095: POP
83096: POP
// defenders := [ ] ;
83097: LD_ADDR_VAR 0 2
83101: PUSH
83102: EMPTY
83103: ST_TO_ADDR
// exit ;
83104: GO 84475
// end ; for i in defenders do
83106: LD_ADDR_VAR 0 5
83110: PUSH
83111: LD_VAR 0 2
83115: PUSH
83116: FOR_IN
83117: IFFALSE 83935
// begin e := NearestUnitToUnit ( enemy , i ) ;
83119: LD_ADDR_VAR 0 14
83123: PUSH
83124: LD_VAR 0 3
83128: PPUSH
83129: LD_VAR 0 5
83133: PPUSH
83134: CALL_OW 74
83138: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83139: LD_ADDR_VAR 0 8
83143: PUSH
83144: LD_EXP 42
83148: PUSH
83149: LD_VAR 0 1
83153: ARRAY
83154: PPUSH
83155: LD_INT 2
83157: PUSH
83158: LD_INT 30
83160: PUSH
83161: LD_INT 0
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 30
83170: PUSH
83171: LD_INT 1
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: LIST
83182: PPUSH
83183: CALL_OW 72
83187: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
83188: LD_ADDR_VAR 0 17
83192: PUSH
83193: LD_VAR 0 8
83197: NOT
83198: PUSH
83199: LD_VAR 0 8
83203: PPUSH
83204: LD_INT 3
83206: PUSH
83207: LD_INT 24
83209: PUSH
83210: LD_INT 600
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: PPUSH
83221: CALL_OW 72
83225: OR
83226: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
83227: LD_VAR 0 5
83231: PPUSH
83232: CALL_OW 247
83236: PUSH
83237: LD_INT 2
83239: DOUBLE
83240: EQUAL
83241: IFTRUE 83245
83243: GO 83641
83245: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
83246: LD_VAR 0 5
83250: PPUSH
83251: CALL_OW 256
83255: PUSH
83256: LD_INT 650
83258: GREATER
83259: PUSH
83260: LD_VAR 0 5
83264: PPUSH
83265: LD_VAR 0 14
83269: PPUSH
83270: CALL_OW 296
83274: PUSH
83275: LD_INT 40
83277: LESS
83278: PUSH
83279: LD_VAR 0 14
83283: PPUSH
83284: LD_EXP 67
83288: PUSH
83289: LD_VAR 0 1
83293: ARRAY
83294: PPUSH
83295: CALL_OW 308
83299: OR
83300: AND
83301: IFFALSE 83423
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
83303: LD_VAR 0 5
83307: PPUSH
83308: CALL_OW 262
83312: PUSH
83313: LD_INT 1
83315: EQUAL
83316: PUSH
83317: LD_VAR 0 5
83321: PPUSH
83322: CALL_OW 261
83326: PUSH
83327: LD_INT 30
83329: LESS
83330: AND
83331: PUSH
83332: LD_VAR 0 8
83336: AND
83337: IFFALSE 83407
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
83339: LD_VAR 0 5
83343: PPUSH
83344: LD_VAR 0 8
83348: PPUSH
83349: LD_VAR 0 5
83353: PPUSH
83354: CALL_OW 74
83358: PPUSH
83359: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
83363: LD_VAR 0 5
83367: PPUSH
83368: LD_VAR 0 8
83372: PPUSH
83373: LD_VAR 0 5
83377: PPUSH
83378: CALL_OW 74
83382: PPUSH
83383: CALL_OW 296
83387: PUSH
83388: LD_INT 6
83390: LESS
83391: IFFALSE 83405
// SetFuel ( i , 100 ) ;
83393: LD_VAR 0 5
83397: PPUSH
83398: LD_INT 100
83400: PPUSH
83401: CALL_OW 240
// end else
83405: GO 83421
// ComAttackUnit ( i , e ) ;
83407: LD_VAR 0 5
83411: PPUSH
83412: LD_VAR 0 14
83416: PPUSH
83417: CALL_OW 115
// end else
83421: GO 83524
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
83423: LD_VAR 0 14
83427: PPUSH
83428: LD_EXP 67
83432: PUSH
83433: LD_VAR 0 1
83437: ARRAY
83438: PPUSH
83439: CALL_OW 308
83443: NOT
83444: PUSH
83445: LD_VAR 0 5
83449: PPUSH
83450: LD_VAR 0 14
83454: PPUSH
83455: CALL_OW 296
83459: PUSH
83460: LD_INT 40
83462: GREATEREQUAL
83463: AND
83464: PUSH
83465: LD_VAR 0 5
83469: PPUSH
83470: CALL_OW 256
83474: PUSH
83475: LD_INT 650
83477: LESSEQUAL
83478: OR
83479: PUSH
83480: LD_VAR 0 5
83484: PPUSH
83485: LD_EXP 66
83489: PUSH
83490: LD_VAR 0 1
83494: ARRAY
83495: PPUSH
83496: CALL_OW 308
83500: NOT
83501: AND
83502: IFFALSE 83524
// ComMoveToArea ( i , mc_parking [ base ] ) ;
83504: LD_VAR 0 5
83508: PPUSH
83509: LD_EXP 66
83513: PUSH
83514: LD_VAR 0 1
83518: ARRAY
83519: PPUSH
83520: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
83524: LD_VAR 0 5
83528: PPUSH
83529: CALL_OW 256
83533: PUSH
83534: LD_INT 998
83536: LESS
83537: PUSH
83538: LD_VAR 0 5
83542: PPUSH
83543: CALL_OW 263
83547: PUSH
83548: LD_INT 1
83550: EQUAL
83551: AND
83552: PUSH
83553: LD_VAR 0 5
83557: PPUSH
83558: CALL_OW 311
83562: AND
83563: PUSH
83564: LD_VAR 0 5
83568: PPUSH
83569: LD_EXP 66
83573: PUSH
83574: LD_VAR 0 1
83578: ARRAY
83579: PPUSH
83580: CALL_OW 308
83584: AND
83585: IFFALSE 83639
// begin mech := IsDrivenBy ( i ) ;
83587: LD_ADDR_VAR 0 10
83591: PUSH
83592: LD_VAR 0 5
83596: PPUSH
83597: CALL_OW 311
83601: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
83602: LD_VAR 0 10
83606: PPUSH
83607: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
83611: LD_VAR 0 10
83615: PPUSH
83616: LD_VAR 0 5
83620: PPUSH
83621: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
83625: LD_VAR 0 10
83629: PPUSH
83630: LD_VAR 0 5
83634: PPUSH
83635: CALL_OW 180
// end ; end ; unit_human :
83639: GO 83906
83641: LD_INT 1
83643: DOUBLE
83644: EQUAL
83645: IFTRUE 83649
83647: GO 83905
83649: POP
// begin b := IsInUnit ( i ) ;
83650: LD_ADDR_VAR 0 19
83654: PUSH
83655: LD_VAR 0 5
83659: PPUSH
83660: CALL_OW 310
83664: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
83665: LD_ADDR_VAR 0 20
83669: PUSH
83670: LD_VAR 0 19
83674: NOT
83675: PUSH
83676: LD_VAR 0 19
83680: PPUSH
83681: CALL_OW 266
83685: PUSH
83686: LD_INT 32
83688: PUSH
83689: LD_INT 31
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: IN
83696: OR
83697: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
83698: LD_VAR 0 17
83702: PUSH
83703: LD_VAR 0 2
83707: PPUSH
83708: LD_INT 21
83710: PUSH
83711: LD_INT 2
83713: PUSH
83714: EMPTY
83715: LIST
83716: LIST
83717: PPUSH
83718: CALL_OW 72
83722: PUSH
83723: LD_INT 1
83725: LESSEQUAL
83726: OR
83727: PUSH
83728: LD_VAR 0 20
83732: AND
83733: PUSH
83734: LD_VAR 0 5
83738: PUSH
83739: LD_VAR 0 18
83743: IN
83744: NOT
83745: AND
83746: IFFALSE 83839
// begin if b then
83748: LD_VAR 0 19
83752: IFFALSE 83801
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
83754: LD_VAR 0 19
83758: PPUSH
83759: LD_VAR 0 3
83763: PPUSH
83764: LD_VAR 0 19
83768: PPUSH
83769: CALL_OW 74
83773: PPUSH
83774: CALL_OW 296
83778: PUSH
83779: LD_INT 10
83781: LESS
83782: PUSH
83783: LD_VAR 0 19
83787: PPUSH
83788: CALL_OW 461
83792: PUSH
83793: LD_INT 7
83795: NONEQUAL
83796: AND
83797: IFFALSE 83801
// continue ;
83799: GO 83116
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
83801: LD_ADDR_VAR 0 18
83805: PUSH
83806: LD_VAR 0 18
83810: PPUSH
83811: LD_VAR 0 18
83815: PUSH
83816: LD_INT 1
83818: PLUS
83819: PPUSH
83820: LD_VAR 0 5
83824: PPUSH
83825: CALL_OW 1
83829: ST_TO_ADDR
// ComExitBuilding ( i ) ;
83830: LD_VAR 0 5
83834: PPUSH
83835: CALL_OW 122
// end ; if sold_defenders then
83839: LD_VAR 0 18
83843: IFFALSE 83903
// if i in sold_defenders then
83845: LD_VAR 0 5
83849: PUSH
83850: LD_VAR 0 18
83854: IN
83855: IFFALSE 83903
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
83857: LD_VAR 0 5
83861: PPUSH
83862: CALL_OW 314
83866: NOT
83867: PUSH
83868: LD_VAR 0 5
83872: PPUSH
83873: LD_VAR 0 14
83877: PPUSH
83878: CALL_OW 296
83882: PUSH
83883: LD_INT 30
83885: LESS
83886: AND
83887: IFFALSE 83903
// ComAttackUnit ( i , e ) ;
83889: LD_VAR 0 5
83893: PPUSH
83894: LD_VAR 0 14
83898: PPUSH
83899: CALL_OW 115
// end ; end ; end ;
83903: GO 83906
83905: POP
// if IsDead ( i ) then
83906: LD_VAR 0 5
83910: PPUSH
83911: CALL_OW 301
83915: IFFALSE 83933
// defenders := defenders diff i ;
83917: LD_ADDR_VAR 0 2
83921: PUSH
83922: LD_VAR 0 2
83926: PUSH
83927: LD_VAR 0 5
83931: DIFF
83932: ST_TO_ADDR
// end ;
83933: GO 83116
83935: POP
83936: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
83937: LD_VAR 0 3
83941: NOT
83942: PUSH
83943: LD_VAR 0 2
83947: NOT
83948: OR
83949: PUSH
83950: LD_EXP 42
83954: PUSH
83955: LD_VAR 0 1
83959: ARRAY
83960: NOT
83961: OR
83962: IFFALSE 83020
// MC_Reset ( base , 18 ) ;
83964: LD_VAR 0 1
83968: PPUSH
83969: LD_INT 18
83971: PPUSH
83972: CALL 51140 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
83976: LD_ADDR_VAR 0 2
83980: PUSH
83981: LD_VAR 0 2
83985: PUSH
83986: LD_VAR 0 2
83990: PPUSH
83991: LD_INT 2
83993: PUSH
83994: LD_INT 25
83996: PUSH
83997: LD_INT 1
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: PUSH
84004: LD_INT 25
84006: PUSH
84007: LD_INT 5
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: PUSH
84014: LD_INT 25
84016: PUSH
84017: LD_INT 8
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PUSH
84024: LD_INT 25
84026: PUSH
84027: LD_INT 9
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: LIST
84038: LIST
84039: LIST
84040: PPUSH
84041: CALL_OW 72
84045: DIFF
84046: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
84047: LD_VAR 0 3
84051: NOT
84052: PUSH
84053: LD_VAR 0 2
84057: PPUSH
84058: LD_INT 21
84060: PUSH
84061: LD_INT 2
84063: PUSH
84064: EMPTY
84065: LIST
84066: LIST
84067: PPUSH
84068: CALL_OW 72
84072: AND
84073: IFFALSE 84411
// begin tmp := FilterByTag ( defenders , 19 ) ;
84075: LD_ADDR_VAR 0 12
84079: PUSH
84080: LD_VAR 0 2
84084: PPUSH
84085: LD_INT 19
84087: PPUSH
84088: CALL 43365 0 2
84092: ST_TO_ADDR
// if tmp then
84093: LD_VAR 0 12
84097: IFFALSE 84167
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
84099: LD_ADDR_VAR 0 12
84103: PUSH
84104: LD_VAR 0 12
84108: PPUSH
84109: LD_INT 25
84111: PUSH
84112: LD_INT 3
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PPUSH
84119: CALL_OW 72
84123: ST_TO_ADDR
// if tmp then
84124: LD_VAR 0 12
84128: IFFALSE 84167
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
84130: LD_ADDR_EXP 54
84134: PUSH
84135: LD_EXP 54
84139: PPUSH
84140: LD_VAR 0 1
84144: PPUSH
84145: LD_EXP 54
84149: PUSH
84150: LD_VAR 0 1
84154: ARRAY
84155: PUSH
84156: LD_VAR 0 12
84160: UNION
84161: PPUSH
84162: CALL_OW 1
84166: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
84167: LD_VAR 0 1
84171: PPUSH
84172: LD_INT 19
84174: PPUSH
84175: CALL 51140 0 2
// repeat wait ( 0 0$1 ) ;
84179: LD_INT 35
84181: PPUSH
84182: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84186: LD_EXP 42
84190: PUSH
84191: LD_VAR 0 1
84195: ARRAY
84196: NOT
84197: PUSH
84198: LD_EXP 42
84202: PUSH
84203: LD_VAR 0 1
84207: ARRAY
84208: PUSH
84209: EMPTY
84210: EQUAL
84211: OR
84212: IFFALSE 84249
// begin for i in defenders do
84214: LD_ADDR_VAR 0 5
84218: PUSH
84219: LD_VAR 0 2
84223: PUSH
84224: FOR_IN
84225: IFFALSE 84238
// ComStop ( i ) ;
84227: LD_VAR 0 5
84231: PPUSH
84232: CALL_OW 141
84236: GO 84224
84238: POP
84239: POP
// defenders := [ ] ;
84240: LD_ADDR_VAR 0 2
84244: PUSH
84245: EMPTY
84246: ST_TO_ADDR
// exit ;
84247: GO 84475
// end ; for i in defenders do
84249: LD_ADDR_VAR 0 5
84253: PUSH
84254: LD_VAR 0 2
84258: PUSH
84259: FOR_IN
84260: IFFALSE 84349
// begin if not IsInArea ( i , mc_parking [ base ] ) then
84262: LD_VAR 0 5
84266: PPUSH
84267: LD_EXP 66
84271: PUSH
84272: LD_VAR 0 1
84276: ARRAY
84277: PPUSH
84278: CALL_OW 308
84282: NOT
84283: IFFALSE 84307
// ComMoveToArea ( i , mc_parking [ base ] ) else
84285: LD_VAR 0 5
84289: PPUSH
84290: LD_EXP 66
84294: PUSH
84295: LD_VAR 0 1
84299: ARRAY
84300: PPUSH
84301: CALL_OW 113
84305: GO 84347
// if GetControl ( i ) = control_manual then
84307: LD_VAR 0 5
84311: PPUSH
84312: CALL_OW 263
84316: PUSH
84317: LD_INT 1
84319: EQUAL
84320: IFFALSE 84347
// if IsDrivenBy ( i ) then
84322: LD_VAR 0 5
84326: PPUSH
84327: CALL_OW 311
84331: IFFALSE 84347
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
84333: LD_VAR 0 5
84337: PPUSH
84338: CALL_OW 311
84342: PPUSH
84343: CALL_OW 121
// end ;
84347: GO 84259
84349: POP
84350: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
84351: LD_VAR 0 2
84355: PPUSH
84356: LD_INT 95
84358: PUSH
84359: LD_EXP 66
84363: PUSH
84364: LD_VAR 0 1
84368: ARRAY
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: PPUSH
84374: CALL_OW 72
84378: PUSH
84379: LD_VAR 0 2
84383: EQUAL
84384: PUSH
84385: LD_EXP 65
84389: PUSH
84390: LD_VAR 0 1
84394: ARRAY
84395: OR
84396: PUSH
84397: LD_EXP 42
84401: PUSH
84402: LD_VAR 0 1
84406: ARRAY
84407: NOT
84408: OR
84409: IFFALSE 84179
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
84411: LD_ADDR_EXP 64
84415: PUSH
84416: LD_EXP 64
84420: PPUSH
84421: LD_VAR 0 1
84425: PPUSH
84426: LD_VAR 0 2
84430: PPUSH
84431: LD_INT 21
84433: PUSH
84434: LD_INT 2
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PPUSH
84441: CALL_OW 72
84445: PPUSH
84446: CALL_OW 1
84450: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
84451: LD_VAR 0 1
84455: PPUSH
84456: LD_INT 19
84458: PPUSH
84459: CALL 51140 0 2
// MC_Reset ( base , 20 ) ;
84463: LD_VAR 0 1
84467: PPUSH
84468: LD_INT 20
84470: PPUSH
84471: CALL 51140 0 2
// end ; end_of_file
84475: LD_VAR 0 4
84479: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
84480: LD_INT 0
84482: PPUSH
84483: PPUSH
84484: PPUSH
84485: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
84486: LD_VAR 0 1
84490: PPUSH
84491: CALL_OW 264
84495: PUSH
84496: LD_EXP 89
84500: EQUAL
84501: IFFALSE 84573
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
84503: LD_INT 68
84505: PPUSH
84506: LD_VAR 0 1
84510: PPUSH
84511: CALL_OW 255
84515: PPUSH
84516: CALL_OW 321
84520: PUSH
84521: LD_INT 2
84523: EQUAL
84524: IFFALSE 84536
// eff := 70 else
84526: LD_ADDR_VAR 0 4
84530: PUSH
84531: LD_INT 70
84533: ST_TO_ADDR
84534: GO 84544
// eff := 30 ;
84536: LD_ADDR_VAR 0 4
84540: PUSH
84541: LD_INT 30
84543: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
84544: LD_VAR 0 1
84548: PPUSH
84549: CALL_OW 250
84553: PPUSH
84554: LD_VAR 0 1
84558: PPUSH
84559: CALL_OW 251
84563: PPUSH
84564: LD_VAR 0 4
84568: PPUSH
84569: CALL_OW 495
// end ; end ;
84573: LD_VAR 0 2
84577: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
84578: LD_INT 0
84580: PPUSH
// end ;
84581: LD_VAR 0 4
84585: RET
// export function SOS_Command ( cmd ) ; begin
84586: LD_INT 0
84588: PPUSH
// end ;
84589: LD_VAR 0 2
84593: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
84594: LD_INT 0
84596: PPUSH
// if cmd = 121 then
84597: LD_VAR 0 1
84601: PUSH
84602: LD_INT 121
84604: EQUAL
84605: IFFALSE 84607
// end ;
84607: LD_VAR 0 6
84611: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
84612: LD_INT 0
84614: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
84615: LD_VAR 0 1
84619: PUSH
84620: LD_INT 250
84622: EQUAL
84623: PUSH
84624: LD_VAR 0 2
84628: PPUSH
84629: CALL_OW 264
84633: PUSH
84634: LD_EXP 92
84638: EQUAL
84639: AND
84640: IFFALSE 84661
// MinerPlaceMine ( unit , x , y ) ;
84642: LD_VAR 0 2
84646: PPUSH
84647: LD_VAR 0 4
84651: PPUSH
84652: LD_VAR 0 5
84656: PPUSH
84657: CALL 87036 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
84661: LD_VAR 0 1
84665: PUSH
84666: LD_INT 251
84668: EQUAL
84669: PUSH
84670: LD_VAR 0 2
84674: PPUSH
84675: CALL_OW 264
84679: PUSH
84680: LD_EXP 92
84684: EQUAL
84685: AND
84686: IFFALSE 84707
// MinerDetonateMine ( unit , x , y ) ;
84688: LD_VAR 0 2
84692: PPUSH
84693: LD_VAR 0 4
84697: PPUSH
84698: LD_VAR 0 5
84702: PPUSH
84703: CALL 87313 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
84707: LD_VAR 0 1
84711: PUSH
84712: LD_INT 252
84714: EQUAL
84715: PUSH
84716: LD_VAR 0 2
84720: PPUSH
84721: CALL_OW 264
84725: PUSH
84726: LD_EXP 92
84730: EQUAL
84731: AND
84732: IFFALSE 84753
// MinerCreateMinefield ( unit , x , y ) ;
84734: LD_VAR 0 2
84738: PPUSH
84739: LD_VAR 0 4
84743: PPUSH
84744: LD_VAR 0 5
84748: PPUSH
84749: CALL 87730 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
84753: LD_VAR 0 1
84757: PUSH
84758: LD_INT 253
84760: EQUAL
84761: PUSH
84762: LD_VAR 0 2
84766: PPUSH
84767: CALL_OW 257
84771: PUSH
84772: LD_INT 5
84774: EQUAL
84775: AND
84776: IFFALSE 84797
// ComBinocular ( unit , x , y ) ;
84778: LD_VAR 0 2
84782: PPUSH
84783: LD_VAR 0 4
84787: PPUSH
84788: LD_VAR 0 5
84792: PPUSH
84793: CALL 88101 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
84797: LD_VAR 0 1
84801: PUSH
84802: LD_INT 254
84804: EQUAL
84805: PUSH
84806: LD_VAR 0 2
84810: PPUSH
84811: CALL_OW 264
84815: PUSH
84816: LD_EXP 87
84820: EQUAL
84821: AND
84822: PUSH
84823: LD_VAR 0 3
84827: PPUSH
84828: CALL_OW 263
84832: PUSH
84833: LD_INT 3
84835: EQUAL
84836: AND
84837: IFFALSE 84853
// HackDestroyVehicle ( unit , selectedUnit ) ;
84839: LD_VAR 0 2
84843: PPUSH
84844: LD_VAR 0 3
84848: PPUSH
84849: CALL 86396 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
84853: LD_VAR 0 1
84857: PUSH
84858: LD_INT 255
84860: EQUAL
84861: PUSH
84862: LD_VAR 0 2
84866: PPUSH
84867: CALL_OW 264
84871: PUSH
84872: LD_INT 14
84874: PUSH
84875: LD_INT 53
84877: PUSH
84878: EMPTY
84879: LIST
84880: LIST
84881: IN
84882: AND
84883: PUSH
84884: LD_VAR 0 4
84888: PPUSH
84889: LD_VAR 0 5
84893: PPUSH
84894: CALL_OW 488
84898: AND
84899: IFFALSE 84923
// CutTreeXYR ( unit , x , y , 12 ) ;
84901: LD_VAR 0 2
84905: PPUSH
84906: LD_VAR 0 4
84910: PPUSH
84911: LD_VAR 0 5
84915: PPUSH
84916: LD_INT 12
84918: PPUSH
84919: CALL 84962 0 4
// end ;
84923: LD_VAR 0 6
84927: RET
// export initPlantMineScript , plantMineList ; every 1 trigger not initPlantMineScript do
84928: LD_EXP 101
84932: NOT
84933: IFFALSE 84953
84935: GO 84937
84937: DISABLE
// begin initPlantMineScript := true ;
84938: LD_ADDR_EXP 101
84942: PUSH
84943: LD_INT 1
84945: ST_TO_ADDR
// plantMineList := [ ] ;
84946: LD_ADDR_EXP 102
84950: PUSH
84951: EMPTY
84952: ST_TO_ADDR
// end ;
84953: END
// export function ComGroupPlantMineXY ( units , x , y ) ; begin
84954: LD_INT 0
84956: PPUSH
// end ;
84957: LD_VAR 0 4
84961: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
84962: LD_INT 0
84964: PPUSH
84965: PPUSH
84966: PPUSH
84967: PPUSH
84968: PPUSH
84969: PPUSH
84970: PPUSH
84971: PPUSH
84972: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
84973: LD_VAR 0 1
84977: NOT
84978: PUSH
84979: LD_VAR 0 2
84983: PPUSH
84984: LD_VAR 0 3
84988: PPUSH
84989: CALL_OW 488
84993: NOT
84994: OR
84995: PUSH
84996: LD_VAR 0 4
85000: NOT
85001: OR
85002: IFFALSE 85006
// exit ;
85004: GO 85346
// list := [ ] ;
85006: LD_ADDR_VAR 0 13
85010: PUSH
85011: EMPTY
85012: ST_TO_ADDR
// if x - r < 0 then
85013: LD_VAR 0 2
85017: PUSH
85018: LD_VAR 0 4
85022: MINUS
85023: PUSH
85024: LD_INT 0
85026: LESS
85027: IFFALSE 85039
// min_x := 0 else
85029: LD_ADDR_VAR 0 7
85033: PUSH
85034: LD_INT 0
85036: ST_TO_ADDR
85037: GO 85055
// min_x := x - r ;
85039: LD_ADDR_VAR 0 7
85043: PUSH
85044: LD_VAR 0 2
85048: PUSH
85049: LD_VAR 0 4
85053: MINUS
85054: ST_TO_ADDR
// if y - r < 0 then
85055: LD_VAR 0 3
85059: PUSH
85060: LD_VAR 0 4
85064: MINUS
85065: PUSH
85066: LD_INT 0
85068: LESS
85069: IFFALSE 85081
// min_y := 0 else
85071: LD_ADDR_VAR 0 8
85075: PUSH
85076: LD_INT 0
85078: ST_TO_ADDR
85079: GO 85097
// min_y := y - r ;
85081: LD_ADDR_VAR 0 8
85085: PUSH
85086: LD_VAR 0 3
85090: PUSH
85091: LD_VAR 0 4
85095: MINUS
85096: ST_TO_ADDR
// max_x := x + r ;
85097: LD_ADDR_VAR 0 9
85101: PUSH
85102: LD_VAR 0 2
85106: PUSH
85107: LD_VAR 0 4
85111: PLUS
85112: ST_TO_ADDR
// max_y := y + r ;
85113: LD_ADDR_VAR 0 10
85117: PUSH
85118: LD_VAR 0 3
85122: PUSH
85123: LD_VAR 0 4
85127: PLUS
85128: ST_TO_ADDR
// for _x = min_x to max_x do
85129: LD_ADDR_VAR 0 11
85133: PUSH
85134: DOUBLE
85135: LD_VAR 0 7
85139: DEC
85140: ST_TO_ADDR
85141: LD_VAR 0 9
85145: PUSH
85146: FOR_TO
85147: IFFALSE 85264
// for _y = min_y to max_y do
85149: LD_ADDR_VAR 0 12
85153: PUSH
85154: DOUBLE
85155: LD_VAR 0 8
85159: DEC
85160: ST_TO_ADDR
85161: LD_VAR 0 10
85165: PUSH
85166: FOR_TO
85167: IFFALSE 85260
// begin if not ValidHex ( _x , _y ) then
85169: LD_VAR 0 11
85173: PPUSH
85174: LD_VAR 0 12
85178: PPUSH
85179: CALL_OW 488
85183: NOT
85184: IFFALSE 85188
// continue ;
85186: GO 85166
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
85188: LD_VAR 0 11
85192: PPUSH
85193: LD_VAR 0 12
85197: PPUSH
85198: CALL_OW 351
85202: PUSH
85203: LD_VAR 0 11
85207: PPUSH
85208: LD_VAR 0 12
85212: PPUSH
85213: CALL_OW 554
85217: AND
85218: IFFALSE 85258
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
85220: LD_ADDR_VAR 0 13
85224: PUSH
85225: LD_VAR 0 13
85229: PPUSH
85230: LD_VAR 0 13
85234: PUSH
85235: LD_INT 1
85237: PLUS
85238: PPUSH
85239: LD_VAR 0 11
85243: PUSH
85244: LD_VAR 0 12
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PPUSH
85253: CALL_OW 2
85257: ST_TO_ADDR
// end ;
85258: GO 85166
85260: POP
85261: POP
85262: GO 85146
85264: POP
85265: POP
// if not list then
85266: LD_VAR 0 13
85270: NOT
85271: IFFALSE 85275
// exit ;
85273: GO 85346
// for i in list do
85275: LD_ADDR_VAR 0 6
85279: PUSH
85280: LD_VAR 0 13
85284: PUSH
85285: FOR_IN
85286: IFFALSE 85344
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
85288: LD_VAR 0 1
85292: PPUSH
85293: LD_STRING M
85295: PUSH
85296: LD_VAR 0 6
85300: PUSH
85301: LD_INT 1
85303: ARRAY
85304: PUSH
85305: LD_VAR 0 6
85309: PUSH
85310: LD_INT 2
85312: ARRAY
85313: PUSH
85314: LD_INT 0
85316: PUSH
85317: LD_INT 0
85319: PUSH
85320: LD_INT 0
85322: PUSH
85323: LD_INT 0
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: LIST
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: PUSH
85335: EMPTY
85336: LIST
85337: PPUSH
85338: CALL_OW 447
85342: GO 85285
85344: POP
85345: POP
// end ;
85346: LD_VAR 0 5
85350: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
85351: LD_EXP 103
85355: NOT
85356: IFFALSE 85406
85358: GO 85360
85360: DISABLE
// begin initHack := true ;
85361: LD_ADDR_EXP 103
85365: PUSH
85366: LD_INT 1
85368: ST_TO_ADDR
// hackTanks := [ ] ;
85369: LD_ADDR_EXP 104
85373: PUSH
85374: EMPTY
85375: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
85376: LD_ADDR_EXP 105
85380: PUSH
85381: EMPTY
85382: ST_TO_ADDR
// hackLimit := 3 ;
85383: LD_ADDR_EXP 106
85387: PUSH
85388: LD_INT 3
85390: ST_TO_ADDR
// hackDist := 12 ;
85391: LD_ADDR_EXP 107
85395: PUSH
85396: LD_INT 12
85398: ST_TO_ADDR
// hackCounter := [ ] ;
85399: LD_ADDR_EXP 108
85403: PUSH
85404: EMPTY
85405: ST_TO_ADDR
// end ;
85406: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
85407: LD_EXP 103
85411: PUSH
85412: LD_INT 34
85414: PUSH
85415: LD_EXP 87
85419: PUSH
85420: EMPTY
85421: LIST
85422: LIST
85423: PPUSH
85424: CALL_OW 69
85428: AND
85429: IFFALSE 85684
85431: GO 85433
85433: DISABLE
85434: LD_INT 0
85436: PPUSH
85437: PPUSH
// begin enable ;
85438: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
85439: LD_ADDR_VAR 0 1
85443: PUSH
85444: LD_INT 34
85446: PUSH
85447: LD_EXP 87
85451: PUSH
85452: EMPTY
85453: LIST
85454: LIST
85455: PPUSH
85456: CALL_OW 69
85460: PUSH
85461: FOR_IN
85462: IFFALSE 85682
// begin if not i in hackTanks then
85464: LD_VAR 0 1
85468: PUSH
85469: LD_EXP 104
85473: IN
85474: NOT
85475: IFFALSE 85558
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
85477: LD_ADDR_EXP 104
85481: PUSH
85482: LD_EXP 104
85486: PPUSH
85487: LD_EXP 104
85491: PUSH
85492: LD_INT 1
85494: PLUS
85495: PPUSH
85496: LD_VAR 0 1
85500: PPUSH
85501: CALL_OW 1
85505: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
85506: LD_ADDR_EXP 105
85510: PUSH
85511: LD_EXP 105
85515: PPUSH
85516: LD_EXP 105
85520: PUSH
85521: LD_INT 1
85523: PLUS
85524: PPUSH
85525: EMPTY
85526: PPUSH
85527: CALL_OW 1
85531: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
85532: LD_ADDR_EXP 108
85536: PUSH
85537: LD_EXP 108
85541: PPUSH
85542: LD_EXP 108
85546: PUSH
85547: LD_INT 1
85549: PLUS
85550: PPUSH
85551: EMPTY
85552: PPUSH
85553: CALL_OW 1
85557: ST_TO_ADDR
// end ; if not IsOk ( i ) then
85558: LD_VAR 0 1
85562: PPUSH
85563: CALL_OW 302
85567: NOT
85568: IFFALSE 85581
// begin HackUnlinkAll ( i ) ;
85570: LD_VAR 0 1
85574: PPUSH
85575: CALL 85687 0 1
// continue ;
85579: GO 85461
// end ; HackCheckCapturedStatus ( i ) ;
85581: LD_VAR 0 1
85585: PPUSH
85586: CALL 86130 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
85590: LD_ADDR_VAR 0 2
85594: PUSH
85595: LD_INT 81
85597: PUSH
85598: LD_VAR 0 1
85602: PPUSH
85603: CALL_OW 255
85607: PUSH
85608: EMPTY
85609: LIST
85610: LIST
85611: PUSH
85612: LD_INT 33
85614: PUSH
85615: LD_INT 3
85617: PUSH
85618: EMPTY
85619: LIST
85620: LIST
85621: PUSH
85622: LD_INT 91
85624: PUSH
85625: LD_VAR 0 1
85629: PUSH
85630: LD_EXP 107
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: LIST
85639: PUSH
85640: LD_INT 50
85642: PUSH
85643: EMPTY
85644: LIST
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: LIST
85650: LIST
85651: PPUSH
85652: CALL_OW 69
85656: ST_TO_ADDR
// if not tmp then
85657: LD_VAR 0 2
85661: NOT
85662: IFFALSE 85666
// continue ;
85664: GO 85461
// HackLink ( i , tmp ) ;
85666: LD_VAR 0 1
85670: PPUSH
85671: LD_VAR 0 2
85675: PPUSH
85676: CALL 85823 0 2
// end ;
85680: GO 85461
85682: POP
85683: POP
// end ;
85684: PPOPN 2
85686: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
85687: LD_INT 0
85689: PPUSH
85690: PPUSH
85691: PPUSH
// if not hack in hackTanks then
85692: LD_VAR 0 1
85696: PUSH
85697: LD_EXP 104
85701: IN
85702: NOT
85703: IFFALSE 85707
// exit ;
85705: GO 85818
// index := GetElementIndex ( hackTanks , hack ) ;
85707: LD_ADDR_VAR 0 4
85711: PUSH
85712: LD_EXP 104
85716: PPUSH
85717: LD_VAR 0 1
85721: PPUSH
85722: CALL 14589 0 2
85726: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
85727: LD_EXP 105
85731: PUSH
85732: LD_VAR 0 4
85736: ARRAY
85737: IFFALSE 85818
// begin for i in hackTanksCaptured [ index ] do
85739: LD_ADDR_VAR 0 3
85743: PUSH
85744: LD_EXP 105
85748: PUSH
85749: LD_VAR 0 4
85753: ARRAY
85754: PUSH
85755: FOR_IN
85756: IFFALSE 85782
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
85758: LD_VAR 0 3
85762: PUSH
85763: LD_INT 1
85765: ARRAY
85766: PPUSH
85767: LD_VAR 0 3
85771: PUSH
85772: LD_INT 2
85774: ARRAY
85775: PPUSH
85776: CALL_OW 235
85780: GO 85755
85782: POP
85783: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
85784: LD_ADDR_EXP 105
85788: PUSH
85789: LD_EXP 105
85793: PPUSH
85794: LD_VAR 0 4
85798: PPUSH
85799: EMPTY
85800: PPUSH
85801: CALL_OW 1
85805: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
85806: LD_VAR 0 1
85810: PPUSH
85811: LD_INT 0
85813: PPUSH
85814: CALL_OW 505
// end ; end ;
85818: LD_VAR 0 2
85822: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
85823: LD_INT 0
85825: PPUSH
85826: PPUSH
85827: PPUSH
// if not hack in hackTanks or not vehicles then
85828: LD_VAR 0 1
85832: PUSH
85833: LD_EXP 104
85837: IN
85838: NOT
85839: PUSH
85840: LD_VAR 0 2
85844: NOT
85845: OR
85846: IFFALSE 85850
// exit ;
85848: GO 86125
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
85850: LD_ADDR_VAR 0 2
85854: PUSH
85855: LD_VAR 0 1
85859: PPUSH
85860: LD_VAR 0 2
85864: PPUSH
85865: LD_INT 1
85867: PPUSH
85868: LD_INT 1
85870: PPUSH
85871: CALL 15239 0 4
85875: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
85876: LD_ADDR_VAR 0 5
85880: PUSH
85881: LD_EXP 104
85885: PPUSH
85886: LD_VAR 0 1
85890: PPUSH
85891: CALL 14589 0 2
85895: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
85896: LD_EXP 105
85900: PUSH
85901: LD_VAR 0 5
85905: ARRAY
85906: PUSH
85907: LD_EXP 106
85911: LESS
85912: IFFALSE 86101
// begin for i := 1 to vehicles do
85914: LD_ADDR_VAR 0 4
85918: PUSH
85919: DOUBLE
85920: LD_INT 1
85922: DEC
85923: ST_TO_ADDR
85924: LD_VAR 0 2
85928: PUSH
85929: FOR_TO
85930: IFFALSE 86099
// begin if hackTanksCaptured [ index ] = hackLimit then
85932: LD_EXP 105
85936: PUSH
85937: LD_VAR 0 5
85941: ARRAY
85942: PUSH
85943: LD_EXP 106
85947: EQUAL
85948: IFFALSE 85952
// break ;
85950: GO 86099
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
85952: LD_ADDR_EXP 108
85956: PUSH
85957: LD_EXP 108
85961: PPUSH
85962: LD_VAR 0 5
85966: PPUSH
85967: LD_EXP 108
85971: PUSH
85972: LD_VAR 0 5
85976: ARRAY
85977: PUSH
85978: LD_INT 1
85980: PLUS
85981: PPUSH
85982: CALL_OW 1
85986: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
85987: LD_ADDR_EXP 105
85991: PUSH
85992: LD_EXP 105
85996: PPUSH
85997: LD_VAR 0 5
86001: PUSH
86002: LD_EXP 105
86006: PUSH
86007: LD_VAR 0 5
86011: ARRAY
86012: PUSH
86013: LD_INT 1
86015: PLUS
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PPUSH
86021: LD_VAR 0 2
86025: PUSH
86026: LD_VAR 0 4
86030: ARRAY
86031: PUSH
86032: LD_VAR 0 2
86036: PUSH
86037: LD_VAR 0 4
86041: ARRAY
86042: PPUSH
86043: CALL_OW 255
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: PPUSH
86052: CALL 14804 0 3
86056: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
86057: LD_VAR 0 2
86061: PUSH
86062: LD_VAR 0 4
86066: ARRAY
86067: PPUSH
86068: LD_VAR 0 1
86072: PPUSH
86073: CALL_OW 255
86077: PPUSH
86078: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
86082: LD_VAR 0 2
86086: PUSH
86087: LD_VAR 0 4
86091: ARRAY
86092: PPUSH
86093: CALL_OW 141
// end ;
86097: GO 85929
86099: POP
86100: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86101: LD_VAR 0 1
86105: PPUSH
86106: LD_EXP 105
86110: PUSH
86111: LD_VAR 0 5
86115: ARRAY
86116: PUSH
86117: LD_INT 0
86119: PLUS
86120: PPUSH
86121: CALL_OW 505
// end ;
86125: LD_VAR 0 3
86129: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
86130: LD_INT 0
86132: PPUSH
86133: PPUSH
86134: PPUSH
86135: PPUSH
// if not hack in hackTanks then
86136: LD_VAR 0 1
86140: PUSH
86141: LD_EXP 104
86145: IN
86146: NOT
86147: IFFALSE 86151
// exit ;
86149: GO 86391
// index := GetElementIndex ( hackTanks , hack ) ;
86151: LD_ADDR_VAR 0 4
86155: PUSH
86156: LD_EXP 104
86160: PPUSH
86161: LD_VAR 0 1
86165: PPUSH
86166: CALL 14589 0 2
86170: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
86171: LD_ADDR_VAR 0 3
86175: PUSH
86176: DOUBLE
86177: LD_EXP 105
86181: PUSH
86182: LD_VAR 0 4
86186: ARRAY
86187: INC
86188: ST_TO_ADDR
86189: LD_INT 1
86191: PUSH
86192: FOR_DOWNTO
86193: IFFALSE 86365
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
86195: LD_ADDR_VAR 0 5
86199: PUSH
86200: LD_EXP 105
86204: PUSH
86205: LD_VAR 0 4
86209: ARRAY
86210: PUSH
86211: LD_VAR 0 3
86215: ARRAY
86216: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
86217: LD_VAR 0 5
86221: PUSH
86222: LD_INT 1
86224: ARRAY
86225: PPUSH
86226: CALL_OW 302
86230: NOT
86231: PUSH
86232: LD_VAR 0 5
86236: PUSH
86237: LD_INT 1
86239: ARRAY
86240: PPUSH
86241: CALL_OW 255
86245: PUSH
86246: LD_VAR 0 1
86250: PPUSH
86251: CALL_OW 255
86255: NONEQUAL
86256: OR
86257: IFFALSE 86363
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
86259: LD_VAR 0 5
86263: PUSH
86264: LD_INT 1
86266: ARRAY
86267: PPUSH
86268: CALL_OW 305
86272: PUSH
86273: LD_VAR 0 5
86277: PUSH
86278: LD_INT 1
86280: ARRAY
86281: PPUSH
86282: CALL_OW 255
86286: PUSH
86287: LD_VAR 0 1
86291: PPUSH
86292: CALL_OW 255
86296: EQUAL
86297: AND
86298: IFFALSE 86322
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
86300: LD_VAR 0 5
86304: PUSH
86305: LD_INT 1
86307: ARRAY
86308: PPUSH
86309: LD_VAR 0 5
86313: PUSH
86314: LD_INT 2
86316: ARRAY
86317: PPUSH
86318: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
86322: LD_ADDR_EXP 105
86326: PUSH
86327: LD_EXP 105
86331: PPUSH
86332: LD_VAR 0 4
86336: PPUSH
86337: LD_EXP 105
86341: PUSH
86342: LD_VAR 0 4
86346: ARRAY
86347: PPUSH
86348: LD_VAR 0 3
86352: PPUSH
86353: CALL_OW 3
86357: PPUSH
86358: CALL_OW 1
86362: ST_TO_ADDR
// end ; end ;
86363: GO 86192
86365: POP
86366: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86367: LD_VAR 0 1
86371: PPUSH
86372: LD_EXP 105
86376: PUSH
86377: LD_VAR 0 4
86381: ARRAY
86382: PUSH
86383: LD_INT 0
86385: PLUS
86386: PPUSH
86387: CALL_OW 505
// end ;
86391: LD_VAR 0 2
86395: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
86396: LD_INT 0
86398: PPUSH
86399: PPUSH
86400: PPUSH
86401: PPUSH
// if not hack in hackTanks then
86402: LD_VAR 0 1
86406: PUSH
86407: LD_EXP 104
86411: IN
86412: NOT
86413: IFFALSE 86417
// exit ;
86415: GO 86502
// index := GetElementIndex ( hackTanks , hack ) ;
86417: LD_ADDR_VAR 0 5
86421: PUSH
86422: LD_EXP 104
86426: PPUSH
86427: LD_VAR 0 1
86431: PPUSH
86432: CALL 14589 0 2
86436: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
86437: LD_ADDR_VAR 0 4
86441: PUSH
86442: DOUBLE
86443: LD_INT 1
86445: DEC
86446: ST_TO_ADDR
86447: LD_EXP 105
86451: PUSH
86452: LD_VAR 0 5
86456: ARRAY
86457: PUSH
86458: FOR_TO
86459: IFFALSE 86500
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
86461: LD_EXP 105
86465: PUSH
86466: LD_VAR 0 5
86470: ARRAY
86471: PUSH
86472: LD_VAR 0 4
86476: ARRAY
86477: PUSH
86478: LD_INT 1
86480: ARRAY
86481: PUSH
86482: LD_VAR 0 2
86486: EQUAL
86487: IFFALSE 86498
// KillUnit ( vehicle ) ;
86489: LD_VAR 0 2
86493: PPUSH
86494: CALL_OW 66
86498: GO 86458
86500: POP
86501: POP
// end ;
86502: LD_VAR 0 3
86506: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
86507: LD_EXP 109
86511: NOT
86512: IFFALSE 86547
86514: GO 86516
86516: DISABLE
// begin initMiner := true ;
86517: LD_ADDR_EXP 109
86521: PUSH
86522: LD_INT 1
86524: ST_TO_ADDR
// minersList := [ ] ;
86525: LD_ADDR_EXP 110
86529: PUSH
86530: EMPTY
86531: ST_TO_ADDR
// minerMinesList := [ ] ;
86532: LD_ADDR_EXP 111
86536: PUSH
86537: EMPTY
86538: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
86539: LD_ADDR_EXP 112
86543: PUSH
86544: LD_INT 5
86546: ST_TO_ADDR
// end ;
86547: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
86548: LD_EXP 109
86552: PUSH
86553: LD_INT 34
86555: PUSH
86556: LD_EXP 92
86560: PUSH
86561: EMPTY
86562: LIST
86563: LIST
86564: PPUSH
86565: CALL_OW 69
86569: AND
86570: IFFALSE 87033
86572: GO 86574
86574: DISABLE
86575: LD_INT 0
86577: PPUSH
86578: PPUSH
86579: PPUSH
86580: PPUSH
// begin enable ;
86581: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
86582: LD_ADDR_VAR 0 1
86586: PUSH
86587: LD_INT 34
86589: PUSH
86590: LD_EXP 92
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: PPUSH
86599: CALL_OW 69
86603: PUSH
86604: FOR_IN
86605: IFFALSE 86677
// begin if not i in minersList then
86607: LD_VAR 0 1
86611: PUSH
86612: LD_EXP 110
86616: IN
86617: NOT
86618: IFFALSE 86675
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
86620: LD_ADDR_EXP 110
86624: PUSH
86625: LD_EXP 110
86629: PPUSH
86630: LD_EXP 110
86634: PUSH
86635: LD_INT 1
86637: PLUS
86638: PPUSH
86639: LD_VAR 0 1
86643: PPUSH
86644: CALL_OW 1
86648: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
86649: LD_ADDR_EXP 111
86653: PUSH
86654: LD_EXP 111
86658: PPUSH
86659: LD_EXP 111
86663: PUSH
86664: LD_INT 1
86666: PLUS
86667: PPUSH
86668: EMPTY
86669: PPUSH
86670: CALL_OW 1
86674: ST_TO_ADDR
// end end ;
86675: GO 86604
86677: POP
86678: POP
// for i := minerMinesList downto 1 do
86679: LD_ADDR_VAR 0 1
86683: PUSH
86684: DOUBLE
86685: LD_EXP 111
86689: INC
86690: ST_TO_ADDR
86691: LD_INT 1
86693: PUSH
86694: FOR_DOWNTO
86695: IFFALSE 87031
// begin if IsLive ( minersList [ i ] ) then
86697: LD_EXP 110
86701: PUSH
86702: LD_VAR 0 1
86706: ARRAY
86707: PPUSH
86708: CALL_OW 300
86712: IFFALSE 86740
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
86714: LD_EXP 110
86718: PUSH
86719: LD_VAR 0 1
86723: ARRAY
86724: PPUSH
86725: LD_EXP 111
86729: PUSH
86730: LD_VAR 0 1
86734: ARRAY
86735: PPUSH
86736: CALL_OW 505
// if not minerMinesList [ i ] then
86740: LD_EXP 111
86744: PUSH
86745: LD_VAR 0 1
86749: ARRAY
86750: NOT
86751: IFFALSE 86755
// continue ;
86753: GO 86694
// for j := minerMinesList [ i ] downto 1 do
86755: LD_ADDR_VAR 0 2
86759: PUSH
86760: DOUBLE
86761: LD_EXP 111
86765: PUSH
86766: LD_VAR 0 1
86770: ARRAY
86771: INC
86772: ST_TO_ADDR
86773: LD_INT 1
86775: PUSH
86776: FOR_DOWNTO
86777: IFFALSE 87027
// begin side := GetSide ( minersList [ i ] ) ;
86779: LD_ADDR_VAR 0 3
86783: PUSH
86784: LD_EXP 110
86788: PUSH
86789: LD_VAR 0 1
86793: ARRAY
86794: PPUSH
86795: CALL_OW 255
86799: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
86800: LD_ADDR_VAR 0 4
86804: PUSH
86805: LD_EXP 111
86809: PUSH
86810: LD_VAR 0 1
86814: ARRAY
86815: PUSH
86816: LD_VAR 0 2
86820: ARRAY
86821: PUSH
86822: LD_INT 1
86824: ARRAY
86825: PPUSH
86826: LD_EXP 111
86830: PUSH
86831: LD_VAR 0 1
86835: ARRAY
86836: PUSH
86837: LD_VAR 0 2
86841: ARRAY
86842: PUSH
86843: LD_INT 2
86845: ARRAY
86846: PPUSH
86847: CALL_OW 428
86851: ST_TO_ADDR
// if not tmp then
86852: LD_VAR 0 4
86856: NOT
86857: IFFALSE 86861
// continue ;
86859: GO 86776
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
86861: LD_VAR 0 4
86865: PUSH
86866: LD_INT 81
86868: PUSH
86869: LD_VAR 0 3
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PPUSH
86878: CALL_OW 69
86882: IN
86883: PUSH
86884: LD_EXP 111
86888: PUSH
86889: LD_VAR 0 1
86893: ARRAY
86894: PUSH
86895: LD_VAR 0 2
86899: ARRAY
86900: PUSH
86901: LD_INT 1
86903: ARRAY
86904: PPUSH
86905: LD_EXP 111
86909: PUSH
86910: LD_VAR 0 1
86914: ARRAY
86915: PUSH
86916: LD_VAR 0 2
86920: ARRAY
86921: PUSH
86922: LD_INT 2
86924: ARRAY
86925: PPUSH
86926: CALL_OW 458
86930: AND
86931: IFFALSE 87025
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
86933: LD_EXP 111
86937: PUSH
86938: LD_VAR 0 1
86942: ARRAY
86943: PUSH
86944: LD_VAR 0 2
86948: ARRAY
86949: PUSH
86950: LD_INT 1
86952: ARRAY
86953: PPUSH
86954: LD_EXP 111
86958: PUSH
86959: LD_VAR 0 1
86963: ARRAY
86964: PUSH
86965: LD_VAR 0 2
86969: ARRAY
86970: PUSH
86971: LD_INT 2
86973: ARRAY
86974: PPUSH
86975: LD_VAR 0 3
86979: PPUSH
86980: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
86984: LD_ADDR_EXP 111
86988: PUSH
86989: LD_EXP 111
86993: PPUSH
86994: LD_VAR 0 1
86998: PPUSH
86999: LD_EXP 111
87003: PUSH
87004: LD_VAR 0 1
87008: ARRAY
87009: PPUSH
87010: LD_VAR 0 2
87014: PPUSH
87015: CALL_OW 3
87019: PPUSH
87020: CALL_OW 1
87024: ST_TO_ADDR
// end ; end ;
87025: GO 86776
87027: POP
87028: POP
// end ;
87029: GO 86694
87031: POP
87032: POP
// end ;
87033: PPOPN 4
87035: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
87036: LD_INT 0
87038: PPUSH
87039: PPUSH
// result := false ;
87040: LD_ADDR_VAR 0 4
87044: PUSH
87045: LD_INT 0
87047: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
87048: LD_VAR 0 1
87052: PPUSH
87053: CALL_OW 264
87057: PUSH
87058: LD_EXP 92
87062: EQUAL
87063: NOT
87064: IFFALSE 87068
// exit ;
87066: GO 87308
// index := GetElementIndex ( minersList , unit ) ;
87068: LD_ADDR_VAR 0 5
87072: PUSH
87073: LD_EXP 110
87077: PPUSH
87078: LD_VAR 0 1
87082: PPUSH
87083: CALL 14589 0 2
87087: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
87088: LD_EXP 111
87092: PUSH
87093: LD_VAR 0 5
87097: ARRAY
87098: PUSH
87099: LD_EXP 112
87103: GREATEREQUAL
87104: IFFALSE 87108
// exit ;
87106: GO 87308
// ComMoveXY ( unit , x , y ) ;
87108: LD_VAR 0 1
87112: PPUSH
87113: LD_VAR 0 2
87117: PPUSH
87118: LD_VAR 0 3
87122: PPUSH
87123: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
87127: LD_INT 35
87129: PPUSH
87130: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
87134: LD_VAR 0 1
87138: PPUSH
87139: LD_VAR 0 2
87143: PPUSH
87144: LD_VAR 0 3
87148: PPUSH
87149: CALL 44653 0 3
87153: NOT
87154: PUSH
87155: LD_VAR 0 1
87159: PPUSH
87160: CALL_OW 314
87164: AND
87165: IFFALSE 87169
// exit ;
87167: GO 87308
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
87169: LD_VAR 0 2
87173: PPUSH
87174: LD_VAR 0 3
87178: PPUSH
87179: CALL_OW 428
87183: PUSH
87184: LD_VAR 0 1
87188: EQUAL
87189: PUSH
87190: LD_VAR 0 1
87194: PPUSH
87195: CALL_OW 314
87199: NOT
87200: AND
87201: IFFALSE 87127
// PlaySoundXY ( x , y , PlantMine ) ;
87203: LD_VAR 0 2
87207: PPUSH
87208: LD_VAR 0 3
87212: PPUSH
87213: LD_STRING PlantMine
87215: PPUSH
87216: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
87220: LD_VAR 0 2
87224: PPUSH
87225: LD_VAR 0 3
87229: PPUSH
87230: LD_VAR 0 1
87234: PPUSH
87235: CALL_OW 255
87239: PPUSH
87240: LD_INT 0
87242: PPUSH
87243: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
87247: LD_ADDR_EXP 111
87251: PUSH
87252: LD_EXP 111
87256: PPUSH
87257: LD_VAR 0 5
87261: PUSH
87262: LD_EXP 111
87266: PUSH
87267: LD_VAR 0 5
87271: ARRAY
87272: PUSH
87273: LD_INT 1
87275: PLUS
87276: PUSH
87277: EMPTY
87278: LIST
87279: LIST
87280: PPUSH
87281: LD_VAR 0 2
87285: PUSH
87286: LD_VAR 0 3
87290: PUSH
87291: EMPTY
87292: LIST
87293: LIST
87294: PPUSH
87295: CALL 14804 0 3
87299: ST_TO_ADDR
// result := true ;
87300: LD_ADDR_VAR 0 4
87304: PUSH
87305: LD_INT 1
87307: ST_TO_ADDR
// end ;
87308: LD_VAR 0 4
87312: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
87313: LD_INT 0
87315: PPUSH
87316: PPUSH
87317: PPUSH
// if not unit in minersList then
87318: LD_VAR 0 1
87322: PUSH
87323: LD_EXP 110
87327: IN
87328: NOT
87329: IFFALSE 87333
// exit ;
87331: GO 87725
// index := GetElementIndex ( minersList , unit ) ;
87333: LD_ADDR_VAR 0 6
87337: PUSH
87338: LD_EXP 110
87342: PPUSH
87343: LD_VAR 0 1
87347: PPUSH
87348: CALL 14589 0 2
87352: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
87353: LD_ADDR_VAR 0 5
87357: PUSH
87358: DOUBLE
87359: LD_EXP 111
87363: PUSH
87364: LD_VAR 0 6
87368: ARRAY
87369: INC
87370: ST_TO_ADDR
87371: LD_INT 1
87373: PUSH
87374: FOR_DOWNTO
87375: IFFALSE 87536
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
87377: LD_EXP 111
87381: PUSH
87382: LD_VAR 0 6
87386: ARRAY
87387: PUSH
87388: LD_VAR 0 5
87392: ARRAY
87393: PUSH
87394: LD_INT 1
87396: ARRAY
87397: PUSH
87398: LD_VAR 0 2
87402: EQUAL
87403: PUSH
87404: LD_EXP 111
87408: PUSH
87409: LD_VAR 0 6
87413: ARRAY
87414: PUSH
87415: LD_VAR 0 5
87419: ARRAY
87420: PUSH
87421: LD_INT 2
87423: ARRAY
87424: PUSH
87425: LD_VAR 0 3
87429: EQUAL
87430: AND
87431: IFFALSE 87534
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87433: LD_EXP 111
87437: PUSH
87438: LD_VAR 0 6
87442: ARRAY
87443: PUSH
87444: LD_VAR 0 5
87448: ARRAY
87449: PUSH
87450: LD_INT 1
87452: ARRAY
87453: PPUSH
87454: LD_EXP 111
87458: PUSH
87459: LD_VAR 0 6
87463: ARRAY
87464: PUSH
87465: LD_VAR 0 5
87469: ARRAY
87470: PUSH
87471: LD_INT 2
87473: ARRAY
87474: PPUSH
87475: LD_VAR 0 1
87479: PPUSH
87480: CALL_OW 255
87484: PPUSH
87485: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87489: LD_ADDR_EXP 111
87493: PUSH
87494: LD_EXP 111
87498: PPUSH
87499: LD_VAR 0 6
87503: PPUSH
87504: LD_EXP 111
87508: PUSH
87509: LD_VAR 0 6
87513: ARRAY
87514: PPUSH
87515: LD_VAR 0 5
87519: PPUSH
87520: CALL_OW 3
87524: PPUSH
87525: CALL_OW 1
87529: ST_TO_ADDR
// exit ;
87530: POP
87531: POP
87532: GO 87725
// end ; end ;
87534: GO 87374
87536: POP
87537: POP
// for i := minerMinesList [ index ] downto 1 do
87538: LD_ADDR_VAR 0 5
87542: PUSH
87543: DOUBLE
87544: LD_EXP 111
87548: PUSH
87549: LD_VAR 0 6
87553: ARRAY
87554: INC
87555: ST_TO_ADDR
87556: LD_INT 1
87558: PUSH
87559: FOR_DOWNTO
87560: IFFALSE 87723
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
87562: LD_EXP 111
87566: PUSH
87567: LD_VAR 0 6
87571: ARRAY
87572: PUSH
87573: LD_VAR 0 5
87577: ARRAY
87578: PUSH
87579: LD_INT 1
87581: ARRAY
87582: PPUSH
87583: LD_EXP 111
87587: PUSH
87588: LD_VAR 0 6
87592: ARRAY
87593: PUSH
87594: LD_VAR 0 5
87598: ARRAY
87599: PUSH
87600: LD_INT 2
87602: ARRAY
87603: PPUSH
87604: LD_VAR 0 2
87608: PPUSH
87609: LD_VAR 0 3
87613: PPUSH
87614: CALL_OW 298
87618: PUSH
87619: LD_INT 6
87621: LESS
87622: IFFALSE 87721
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87624: LD_EXP 111
87628: PUSH
87629: LD_VAR 0 6
87633: ARRAY
87634: PUSH
87635: LD_VAR 0 5
87639: ARRAY
87640: PUSH
87641: LD_INT 1
87643: ARRAY
87644: PPUSH
87645: LD_EXP 111
87649: PUSH
87650: LD_VAR 0 6
87654: ARRAY
87655: PUSH
87656: LD_VAR 0 5
87660: ARRAY
87661: PUSH
87662: LD_INT 2
87664: ARRAY
87665: PPUSH
87666: LD_VAR 0 1
87670: PPUSH
87671: CALL_OW 255
87675: PPUSH
87676: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87680: LD_ADDR_EXP 111
87684: PUSH
87685: LD_EXP 111
87689: PPUSH
87690: LD_VAR 0 6
87694: PPUSH
87695: LD_EXP 111
87699: PUSH
87700: LD_VAR 0 6
87704: ARRAY
87705: PPUSH
87706: LD_VAR 0 5
87710: PPUSH
87711: CALL_OW 3
87715: PPUSH
87716: CALL_OW 1
87720: ST_TO_ADDR
// end ; end ;
87721: GO 87559
87723: POP
87724: POP
// end ;
87725: LD_VAR 0 4
87729: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
87730: LD_INT 0
87732: PPUSH
87733: PPUSH
87734: PPUSH
87735: PPUSH
87736: PPUSH
87737: PPUSH
87738: PPUSH
87739: PPUSH
87740: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
87741: LD_VAR 0 1
87745: PPUSH
87746: CALL_OW 264
87750: PUSH
87751: LD_EXP 92
87755: EQUAL
87756: NOT
87757: PUSH
87758: LD_VAR 0 1
87762: PUSH
87763: LD_EXP 110
87767: IN
87768: NOT
87769: OR
87770: IFFALSE 87774
// exit ;
87772: GO 88096
// index := GetElementIndex ( minersList , unit ) ;
87774: LD_ADDR_VAR 0 6
87778: PUSH
87779: LD_EXP 110
87783: PPUSH
87784: LD_VAR 0 1
87788: PPUSH
87789: CALL 14589 0 2
87793: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
87794: LD_ADDR_VAR 0 8
87798: PUSH
87799: LD_EXP 112
87803: PUSH
87804: LD_EXP 111
87808: PUSH
87809: LD_VAR 0 6
87813: ARRAY
87814: MINUS
87815: ST_TO_ADDR
// if not minesFreeAmount then
87816: LD_VAR 0 8
87820: NOT
87821: IFFALSE 87825
// exit ;
87823: GO 88096
// tmp := [ ] ;
87825: LD_ADDR_VAR 0 7
87829: PUSH
87830: EMPTY
87831: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
87832: LD_ADDR_VAR 0 5
87836: PUSH
87837: DOUBLE
87838: LD_INT 1
87840: DEC
87841: ST_TO_ADDR
87842: LD_VAR 0 8
87846: PUSH
87847: FOR_TO
87848: IFFALSE 88043
// begin _d := rand ( 0 , 5 ) ;
87850: LD_ADDR_VAR 0 11
87854: PUSH
87855: LD_INT 0
87857: PPUSH
87858: LD_INT 5
87860: PPUSH
87861: CALL_OW 12
87865: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
87866: LD_ADDR_VAR 0 12
87870: PUSH
87871: LD_INT 2
87873: PPUSH
87874: LD_INT 6
87876: PPUSH
87877: CALL_OW 12
87881: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
87882: LD_ADDR_VAR 0 9
87886: PUSH
87887: LD_VAR 0 2
87891: PPUSH
87892: LD_VAR 0 11
87896: PPUSH
87897: LD_VAR 0 12
87901: PPUSH
87902: CALL_OW 272
87906: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
87907: LD_ADDR_VAR 0 10
87911: PUSH
87912: LD_VAR 0 3
87916: PPUSH
87917: LD_VAR 0 11
87921: PPUSH
87922: LD_VAR 0 12
87926: PPUSH
87927: CALL_OW 273
87931: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
87932: LD_VAR 0 9
87936: PPUSH
87937: LD_VAR 0 10
87941: PPUSH
87942: CALL_OW 488
87946: PUSH
87947: LD_VAR 0 9
87951: PUSH
87952: LD_VAR 0 10
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_VAR 0 7
87965: IN
87966: NOT
87967: AND
87968: PUSH
87969: LD_VAR 0 9
87973: PPUSH
87974: LD_VAR 0 10
87978: PPUSH
87979: CALL_OW 458
87983: NOT
87984: AND
87985: IFFALSE 88027
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
87987: LD_ADDR_VAR 0 7
87991: PUSH
87992: LD_VAR 0 7
87996: PPUSH
87997: LD_VAR 0 7
88001: PUSH
88002: LD_INT 1
88004: PLUS
88005: PPUSH
88006: LD_VAR 0 9
88010: PUSH
88011: LD_VAR 0 10
88015: PUSH
88016: EMPTY
88017: LIST
88018: LIST
88019: PPUSH
88020: CALL_OW 1
88024: ST_TO_ADDR
88025: GO 88041
// i := i - 1 ;
88027: LD_ADDR_VAR 0 5
88031: PUSH
88032: LD_VAR 0 5
88036: PUSH
88037: LD_INT 1
88039: MINUS
88040: ST_TO_ADDR
// end ;
88041: GO 87847
88043: POP
88044: POP
// for i in tmp do
88045: LD_ADDR_VAR 0 5
88049: PUSH
88050: LD_VAR 0 7
88054: PUSH
88055: FOR_IN
88056: IFFALSE 88094
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
88058: LD_VAR 0 1
88062: PPUSH
88063: LD_VAR 0 5
88067: PUSH
88068: LD_INT 1
88070: ARRAY
88071: PPUSH
88072: LD_VAR 0 5
88076: PUSH
88077: LD_INT 2
88079: ARRAY
88080: PPUSH
88081: CALL 87036 0 3
88085: NOT
88086: IFFALSE 88092
// exit ;
88088: POP
88089: POP
88090: GO 88096
88092: GO 88055
88094: POP
88095: POP
// end ;
88096: LD_VAR 0 4
88100: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
88101: LD_INT 0
88103: PPUSH
88104: PPUSH
88105: PPUSH
88106: PPUSH
88107: PPUSH
88108: PPUSH
88109: PPUSH
// if not GetClass ( unit ) = class_sniper then
88110: LD_VAR 0 1
88114: PPUSH
88115: CALL_OW 257
88119: PUSH
88120: LD_INT 5
88122: EQUAL
88123: NOT
88124: IFFALSE 88128
// exit ;
88126: GO 88516
// dist := 8 ;
88128: LD_ADDR_VAR 0 5
88132: PUSH
88133: LD_INT 8
88135: ST_TO_ADDR
// viewRange := 12 ;
88136: LD_ADDR_VAR 0 7
88140: PUSH
88141: LD_INT 12
88143: ST_TO_ADDR
// side := GetSide ( unit ) ;
88144: LD_ADDR_VAR 0 6
88148: PUSH
88149: LD_VAR 0 1
88153: PPUSH
88154: CALL_OW 255
88158: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
88159: LD_INT 61
88161: PPUSH
88162: LD_VAR 0 6
88166: PPUSH
88167: CALL_OW 321
88171: PUSH
88172: LD_INT 2
88174: EQUAL
88175: IFFALSE 88185
// viewRange := 16 ;
88177: LD_ADDR_VAR 0 7
88181: PUSH
88182: LD_INT 16
88184: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
88185: LD_VAR 0 1
88189: PPUSH
88190: LD_VAR 0 2
88194: PPUSH
88195: LD_VAR 0 3
88199: PPUSH
88200: CALL_OW 297
88204: PUSH
88205: LD_VAR 0 5
88209: GREATER
88210: IFFALSE 88289
// begin ComMoveXY ( unit , x , y ) ;
88212: LD_VAR 0 1
88216: PPUSH
88217: LD_VAR 0 2
88221: PPUSH
88222: LD_VAR 0 3
88226: PPUSH
88227: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
88231: LD_INT 35
88233: PPUSH
88234: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
88238: LD_VAR 0 1
88242: PPUSH
88243: LD_VAR 0 2
88247: PPUSH
88248: LD_VAR 0 3
88252: PPUSH
88253: CALL 44653 0 3
88257: NOT
88258: IFFALSE 88262
// exit ;
88260: GO 88516
// until GetDistUnitXY ( unit , x , y ) < dist ;
88262: LD_VAR 0 1
88266: PPUSH
88267: LD_VAR 0 2
88271: PPUSH
88272: LD_VAR 0 3
88276: PPUSH
88277: CALL_OW 297
88281: PUSH
88282: LD_VAR 0 5
88286: LESS
88287: IFFALSE 88231
// end ; ComTurnXY ( unit , x , y ) ;
88289: LD_VAR 0 1
88293: PPUSH
88294: LD_VAR 0 2
88298: PPUSH
88299: LD_VAR 0 3
88303: PPUSH
88304: CALL_OW 118
// wait ( 5 ) ;
88308: LD_INT 5
88310: PPUSH
88311: CALL_OW 67
// _d := GetDir ( unit ) ;
88315: LD_ADDR_VAR 0 10
88319: PUSH
88320: LD_VAR 0 1
88324: PPUSH
88325: CALL_OW 254
88329: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
88330: LD_ADDR_VAR 0 8
88334: PUSH
88335: LD_VAR 0 1
88339: PPUSH
88340: CALL_OW 250
88344: PPUSH
88345: LD_VAR 0 10
88349: PPUSH
88350: LD_VAR 0 5
88354: PPUSH
88355: CALL_OW 272
88359: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
88360: LD_ADDR_VAR 0 9
88364: PUSH
88365: LD_VAR 0 1
88369: PPUSH
88370: CALL_OW 251
88374: PPUSH
88375: LD_VAR 0 10
88379: PPUSH
88380: LD_VAR 0 5
88384: PPUSH
88385: CALL_OW 273
88389: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88390: LD_VAR 0 8
88394: PPUSH
88395: LD_VAR 0 9
88399: PPUSH
88400: CALL_OW 488
88404: NOT
88405: IFFALSE 88409
// exit ;
88407: GO 88516
// ComAnimCustom ( unit , 1 ) ;
88409: LD_VAR 0 1
88413: PPUSH
88414: LD_INT 1
88416: PPUSH
88417: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
88421: LD_VAR 0 8
88425: PPUSH
88426: LD_VAR 0 9
88430: PPUSH
88431: LD_VAR 0 6
88435: PPUSH
88436: LD_VAR 0 7
88440: PPUSH
88441: CALL_OW 330
// repeat wait ( 1 ) ;
88445: LD_INT 1
88447: PPUSH
88448: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
88452: LD_VAR 0 1
88456: PPUSH
88457: CALL_OW 316
88461: PUSH
88462: LD_VAR 0 1
88466: PPUSH
88467: CALL_OW 314
88471: OR
88472: PUSH
88473: LD_VAR 0 1
88477: PPUSH
88478: CALL_OW 302
88482: NOT
88483: OR
88484: PUSH
88485: LD_VAR 0 1
88489: PPUSH
88490: CALL_OW 301
88494: OR
88495: IFFALSE 88445
// RemoveSeeing ( _x , _y , side ) ;
88497: LD_VAR 0 8
88501: PPUSH
88502: LD_VAR 0 9
88506: PPUSH
88507: LD_VAR 0 6
88511: PPUSH
88512: CALL_OW 331
// end ; end_of_file
88516: LD_VAR 0 4
88520: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
88521: LD_VAR 0 1
88525: PUSH
88526: LD_INT 200
88528: DOUBLE
88529: GREATEREQUAL
88530: IFFALSE 88538
88532: LD_INT 299
88534: DOUBLE
88535: LESSEQUAL
88536: IFTRUE 88540
88538: GO 88572
88540: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
88541: LD_VAR 0 1
88545: PPUSH
88546: LD_VAR 0 2
88550: PPUSH
88551: LD_VAR 0 3
88555: PPUSH
88556: LD_VAR 0 4
88560: PPUSH
88561: LD_VAR 0 5
88565: PPUSH
88566: CALL 84612 0 5
88570: GO 88649
88572: LD_INT 300
88574: DOUBLE
88575: GREATEREQUAL
88576: IFFALSE 88584
88578: LD_INT 399
88580: DOUBLE
88581: LESSEQUAL
88582: IFTRUE 88586
88584: GO 88648
88586: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
88587: LD_VAR 0 1
88591: PPUSH
88592: LD_VAR 0 2
88596: PPUSH
88597: LD_VAR 0 3
88601: PPUSH
88602: LD_VAR 0 4
88606: PPUSH
88607: LD_VAR 0 5
88611: PPUSH
88612: LD_VAR 0 6
88616: PPUSH
88617: LD_VAR 0 7
88621: PPUSH
88622: LD_VAR 0 8
88626: PPUSH
88627: LD_VAR 0 9
88631: PPUSH
88632: LD_VAR 0 10
88636: PPUSH
88637: LD_VAR 0 11
88641: PPUSH
88642: CALL 99839 0 11
88646: GO 88649
88648: POP
// end ; end_of_file
88649: PPOPN 11
88651: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
88652: LD_VAR 0 2
88656: PUSH
88657: LD_INT 100
88659: EQUAL
88660: IFFALSE 89609
// begin if not StreamModeActive then
88662: LD_EXP 113
88666: NOT
88667: IFFALSE 88677
// StreamModeActive := true ;
88669: LD_ADDR_EXP 113
88673: PUSH
88674: LD_INT 1
88676: ST_TO_ADDR
// if p3 = 0 then
88677: LD_VAR 0 3
88681: PUSH
88682: LD_INT 0
88684: EQUAL
88685: IFFALSE 88691
// InitStreamMode ;
88687: CALL 89767 0 0
// if p3 = 1 then
88691: LD_VAR 0 3
88695: PUSH
88696: LD_INT 1
88698: EQUAL
88699: IFFALSE 88709
// sRocket := true ;
88701: LD_ADDR_EXP 118
88705: PUSH
88706: LD_INT 1
88708: ST_TO_ADDR
// if p3 = 2 then
88709: LD_VAR 0 3
88713: PUSH
88714: LD_INT 2
88716: EQUAL
88717: IFFALSE 88727
// sSpeed := true ;
88719: LD_ADDR_EXP 117
88723: PUSH
88724: LD_INT 1
88726: ST_TO_ADDR
// if p3 = 3 then
88727: LD_VAR 0 3
88731: PUSH
88732: LD_INT 3
88734: EQUAL
88735: IFFALSE 88745
// sEngine := true ;
88737: LD_ADDR_EXP 119
88741: PUSH
88742: LD_INT 1
88744: ST_TO_ADDR
// if p3 = 4 then
88745: LD_VAR 0 3
88749: PUSH
88750: LD_INT 4
88752: EQUAL
88753: IFFALSE 88763
// sSpec := true ;
88755: LD_ADDR_EXP 116
88759: PUSH
88760: LD_INT 1
88762: ST_TO_ADDR
// if p3 = 5 then
88763: LD_VAR 0 3
88767: PUSH
88768: LD_INT 5
88770: EQUAL
88771: IFFALSE 88781
// sLevel := true ;
88773: LD_ADDR_EXP 120
88777: PUSH
88778: LD_INT 1
88780: ST_TO_ADDR
// if p3 = 6 then
88781: LD_VAR 0 3
88785: PUSH
88786: LD_INT 6
88788: EQUAL
88789: IFFALSE 88799
// sArmoury := true ;
88791: LD_ADDR_EXP 121
88795: PUSH
88796: LD_INT 1
88798: ST_TO_ADDR
// if p3 = 7 then
88799: LD_VAR 0 3
88803: PUSH
88804: LD_INT 7
88806: EQUAL
88807: IFFALSE 88817
// sRadar := true ;
88809: LD_ADDR_EXP 122
88813: PUSH
88814: LD_INT 1
88816: ST_TO_ADDR
// if p3 = 8 then
88817: LD_VAR 0 3
88821: PUSH
88822: LD_INT 8
88824: EQUAL
88825: IFFALSE 88835
// sBunker := true ;
88827: LD_ADDR_EXP 123
88831: PUSH
88832: LD_INT 1
88834: ST_TO_ADDR
// if p3 = 9 then
88835: LD_VAR 0 3
88839: PUSH
88840: LD_INT 9
88842: EQUAL
88843: IFFALSE 88853
// sHack := true ;
88845: LD_ADDR_EXP 124
88849: PUSH
88850: LD_INT 1
88852: ST_TO_ADDR
// if p3 = 10 then
88853: LD_VAR 0 3
88857: PUSH
88858: LD_INT 10
88860: EQUAL
88861: IFFALSE 88871
// sFire := true ;
88863: LD_ADDR_EXP 125
88867: PUSH
88868: LD_INT 1
88870: ST_TO_ADDR
// if p3 = 11 then
88871: LD_VAR 0 3
88875: PUSH
88876: LD_INT 11
88878: EQUAL
88879: IFFALSE 88889
// sRefresh := true ;
88881: LD_ADDR_EXP 126
88885: PUSH
88886: LD_INT 1
88888: ST_TO_ADDR
// if p3 = 12 then
88889: LD_VAR 0 3
88893: PUSH
88894: LD_INT 12
88896: EQUAL
88897: IFFALSE 88907
// sExp := true ;
88899: LD_ADDR_EXP 127
88903: PUSH
88904: LD_INT 1
88906: ST_TO_ADDR
// if p3 = 13 then
88907: LD_VAR 0 3
88911: PUSH
88912: LD_INT 13
88914: EQUAL
88915: IFFALSE 88925
// sDepot := true ;
88917: LD_ADDR_EXP 128
88921: PUSH
88922: LD_INT 1
88924: ST_TO_ADDR
// if p3 = 14 then
88925: LD_VAR 0 3
88929: PUSH
88930: LD_INT 14
88932: EQUAL
88933: IFFALSE 88943
// sFlag := true ;
88935: LD_ADDR_EXP 129
88939: PUSH
88940: LD_INT 1
88942: ST_TO_ADDR
// if p3 = 15 then
88943: LD_VAR 0 3
88947: PUSH
88948: LD_INT 15
88950: EQUAL
88951: IFFALSE 88961
// sKamikadze := true ;
88953: LD_ADDR_EXP 137
88957: PUSH
88958: LD_INT 1
88960: ST_TO_ADDR
// if p3 = 16 then
88961: LD_VAR 0 3
88965: PUSH
88966: LD_INT 16
88968: EQUAL
88969: IFFALSE 88979
// sTroll := true ;
88971: LD_ADDR_EXP 138
88975: PUSH
88976: LD_INT 1
88978: ST_TO_ADDR
// if p3 = 17 then
88979: LD_VAR 0 3
88983: PUSH
88984: LD_INT 17
88986: EQUAL
88987: IFFALSE 88997
// sSlow := true ;
88989: LD_ADDR_EXP 139
88993: PUSH
88994: LD_INT 1
88996: ST_TO_ADDR
// if p3 = 18 then
88997: LD_VAR 0 3
89001: PUSH
89002: LD_INT 18
89004: EQUAL
89005: IFFALSE 89015
// sLack := true ;
89007: LD_ADDR_EXP 140
89011: PUSH
89012: LD_INT 1
89014: ST_TO_ADDR
// if p3 = 19 then
89015: LD_VAR 0 3
89019: PUSH
89020: LD_INT 19
89022: EQUAL
89023: IFFALSE 89033
// sTank := true ;
89025: LD_ADDR_EXP 142
89029: PUSH
89030: LD_INT 1
89032: ST_TO_ADDR
// if p3 = 20 then
89033: LD_VAR 0 3
89037: PUSH
89038: LD_INT 20
89040: EQUAL
89041: IFFALSE 89051
// sRemote := true ;
89043: LD_ADDR_EXP 143
89047: PUSH
89048: LD_INT 1
89050: ST_TO_ADDR
// if p3 = 21 then
89051: LD_VAR 0 3
89055: PUSH
89056: LD_INT 21
89058: EQUAL
89059: IFFALSE 89069
// sPowell := true ;
89061: LD_ADDR_EXP 144
89065: PUSH
89066: LD_INT 1
89068: ST_TO_ADDR
// if p3 = 22 then
89069: LD_VAR 0 3
89073: PUSH
89074: LD_INT 22
89076: EQUAL
89077: IFFALSE 89087
// sTeleport := true ;
89079: LD_ADDR_EXP 147
89083: PUSH
89084: LD_INT 1
89086: ST_TO_ADDR
// if p3 = 23 then
89087: LD_VAR 0 3
89091: PUSH
89092: LD_INT 23
89094: EQUAL
89095: IFFALSE 89105
// sOilTower := true ;
89097: LD_ADDR_EXP 149
89101: PUSH
89102: LD_INT 1
89104: ST_TO_ADDR
// if p3 = 24 then
89105: LD_VAR 0 3
89109: PUSH
89110: LD_INT 24
89112: EQUAL
89113: IFFALSE 89123
// sShovel := true ;
89115: LD_ADDR_EXP 150
89119: PUSH
89120: LD_INT 1
89122: ST_TO_ADDR
// if p3 = 25 then
89123: LD_VAR 0 3
89127: PUSH
89128: LD_INT 25
89130: EQUAL
89131: IFFALSE 89141
// sSheik := true ;
89133: LD_ADDR_EXP 151
89137: PUSH
89138: LD_INT 1
89140: ST_TO_ADDR
// if p3 = 26 then
89141: LD_VAR 0 3
89145: PUSH
89146: LD_INT 26
89148: EQUAL
89149: IFFALSE 89159
// sEarthquake := true ;
89151: LD_ADDR_EXP 153
89155: PUSH
89156: LD_INT 1
89158: ST_TO_ADDR
// if p3 = 27 then
89159: LD_VAR 0 3
89163: PUSH
89164: LD_INT 27
89166: EQUAL
89167: IFFALSE 89177
// sAI := true ;
89169: LD_ADDR_EXP 154
89173: PUSH
89174: LD_INT 1
89176: ST_TO_ADDR
// if p3 = 28 then
89177: LD_VAR 0 3
89181: PUSH
89182: LD_INT 28
89184: EQUAL
89185: IFFALSE 89195
// sCargo := true ;
89187: LD_ADDR_EXP 157
89191: PUSH
89192: LD_INT 1
89194: ST_TO_ADDR
// if p3 = 29 then
89195: LD_VAR 0 3
89199: PUSH
89200: LD_INT 29
89202: EQUAL
89203: IFFALSE 89213
// sDLaser := true ;
89205: LD_ADDR_EXP 158
89209: PUSH
89210: LD_INT 1
89212: ST_TO_ADDR
// if p3 = 30 then
89213: LD_VAR 0 3
89217: PUSH
89218: LD_INT 30
89220: EQUAL
89221: IFFALSE 89231
// sExchange := true ;
89223: LD_ADDR_EXP 159
89227: PUSH
89228: LD_INT 1
89230: ST_TO_ADDR
// if p3 = 31 then
89231: LD_VAR 0 3
89235: PUSH
89236: LD_INT 31
89238: EQUAL
89239: IFFALSE 89249
// sFac := true ;
89241: LD_ADDR_EXP 160
89245: PUSH
89246: LD_INT 1
89248: ST_TO_ADDR
// if p3 = 32 then
89249: LD_VAR 0 3
89253: PUSH
89254: LD_INT 32
89256: EQUAL
89257: IFFALSE 89267
// sPower := true ;
89259: LD_ADDR_EXP 161
89263: PUSH
89264: LD_INT 1
89266: ST_TO_ADDR
// if p3 = 33 then
89267: LD_VAR 0 3
89271: PUSH
89272: LD_INT 33
89274: EQUAL
89275: IFFALSE 89285
// sRandom := true ;
89277: LD_ADDR_EXP 162
89281: PUSH
89282: LD_INT 1
89284: ST_TO_ADDR
// if p3 = 34 then
89285: LD_VAR 0 3
89289: PUSH
89290: LD_INT 34
89292: EQUAL
89293: IFFALSE 89303
// sShield := true ;
89295: LD_ADDR_EXP 163
89299: PUSH
89300: LD_INT 1
89302: ST_TO_ADDR
// if p3 = 35 then
89303: LD_VAR 0 3
89307: PUSH
89308: LD_INT 35
89310: EQUAL
89311: IFFALSE 89321
// sTime := true ;
89313: LD_ADDR_EXP 164
89317: PUSH
89318: LD_INT 1
89320: ST_TO_ADDR
// if p3 = 36 then
89321: LD_VAR 0 3
89325: PUSH
89326: LD_INT 36
89328: EQUAL
89329: IFFALSE 89339
// sTools := true ;
89331: LD_ADDR_EXP 165
89335: PUSH
89336: LD_INT 1
89338: ST_TO_ADDR
// if p3 = 101 then
89339: LD_VAR 0 3
89343: PUSH
89344: LD_INT 101
89346: EQUAL
89347: IFFALSE 89357
// sSold := true ;
89349: LD_ADDR_EXP 130
89353: PUSH
89354: LD_INT 1
89356: ST_TO_ADDR
// if p3 = 102 then
89357: LD_VAR 0 3
89361: PUSH
89362: LD_INT 102
89364: EQUAL
89365: IFFALSE 89375
// sDiff := true ;
89367: LD_ADDR_EXP 131
89371: PUSH
89372: LD_INT 1
89374: ST_TO_ADDR
// if p3 = 103 then
89375: LD_VAR 0 3
89379: PUSH
89380: LD_INT 103
89382: EQUAL
89383: IFFALSE 89393
// sFog := true ;
89385: LD_ADDR_EXP 134
89389: PUSH
89390: LD_INT 1
89392: ST_TO_ADDR
// if p3 = 104 then
89393: LD_VAR 0 3
89397: PUSH
89398: LD_INT 104
89400: EQUAL
89401: IFFALSE 89411
// sReset := true ;
89403: LD_ADDR_EXP 135
89407: PUSH
89408: LD_INT 1
89410: ST_TO_ADDR
// if p3 = 105 then
89411: LD_VAR 0 3
89415: PUSH
89416: LD_INT 105
89418: EQUAL
89419: IFFALSE 89429
// sSun := true ;
89421: LD_ADDR_EXP 136
89425: PUSH
89426: LD_INT 1
89428: ST_TO_ADDR
// if p3 = 106 then
89429: LD_VAR 0 3
89433: PUSH
89434: LD_INT 106
89436: EQUAL
89437: IFFALSE 89447
// sTiger := true ;
89439: LD_ADDR_EXP 132
89443: PUSH
89444: LD_INT 1
89446: ST_TO_ADDR
// if p3 = 107 then
89447: LD_VAR 0 3
89451: PUSH
89452: LD_INT 107
89454: EQUAL
89455: IFFALSE 89465
// sBomb := true ;
89457: LD_ADDR_EXP 133
89461: PUSH
89462: LD_INT 1
89464: ST_TO_ADDR
// if p3 = 108 then
89465: LD_VAR 0 3
89469: PUSH
89470: LD_INT 108
89472: EQUAL
89473: IFFALSE 89483
// sWound := true ;
89475: LD_ADDR_EXP 141
89479: PUSH
89480: LD_INT 1
89482: ST_TO_ADDR
// if p3 = 109 then
89483: LD_VAR 0 3
89487: PUSH
89488: LD_INT 109
89490: EQUAL
89491: IFFALSE 89501
// sBetray := true ;
89493: LD_ADDR_EXP 145
89497: PUSH
89498: LD_INT 1
89500: ST_TO_ADDR
// if p3 = 110 then
89501: LD_VAR 0 3
89505: PUSH
89506: LD_INT 110
89508: EQUAL
89509: IFFALSE 89519
// sContamin := true ;
89511: LD_ADDR_EXP 146
89515: PUSH
89516: LD_INT 1
89518: ST_TO_ADDR
// if p3 = 111 then
89519: LD_VAR 0 3
89523: PUSH
89524: LD_INT 111
89526: EQUAL
89527: IFFALSE 89537
// sOil := true ;
89529: LD_ADDR_EXP 148
89533: PUSH
89534: LD_INT 1
89536: ST_TO_ADDR
// if p3 = 112 then
89537: LD_VAR 0 3
89541: PUSH
89542: LD_INT 112
89544: EQUAL
89545: IFFALSE 89555
// sStu := true ;
89547: LD_ADDR_EXP 152
89551: PUSH
89552: LD_INT 1
89554: ST_TO_ADDR
// if p3 = 113 then
89555: LD_VAR 0 3
89559: PUSH
89560: LD_INT 113
89562: EQUAL
89563: IFFALSE 89573
// sBazooka := true ;
89565: LD_ADDR_EXP 155
89569: PUSH
89570: LD_INT 1
89572: ST_TO_ADDR
// if p3 = 114 then
89573: LD_VAR 0 3
89577: PUSH
89578: LD_INT 114
89580: EQUAL
89581: IFFALSE 89591
// sMortar := true ;
89583: LD_ADDR_EXP 156
89587: PUSH
89588: LD_INT 1
89590: ST_TO_ADDR
// if p3 = 115 then
89591: LD_VAR 0 3
89595: PUSH
89596: LD_INT 115
89598: EQUAL
89599: IFFALSE 89609
// sRanger := true ;
89601: LD_ADDR_EXP 166
89605: PUSH
89606: LD_INT 1
89608: ST_TO_ADDR
// end ; if p2 = 101 then
89609: LD_VAR 0 2
89613: PUSH
89614: LD_INT 101
89616: EQUAL
89617: IFFALSE 89745
// begin case p3 of 1 :
89619: LD_VAR 0 3
89623: PUSH
89624: LD_INT 1
89626: DOUBLE
89627: EQUAL
89628: IFTRUE 89632
89630: GO 89639
89632: POP
// hHackUnlimitedResources ; 2 :
89633: CALL 100780 0 0
89637: GO 89745
89639: LD_INT 2
89641: DOUBLE
89642: EQUAL
89643: IFTRUE 89647
89645: GO 89654
89647: POP
// hHackSetLevel10 ; 3 :
89648: CALL 100913 0 0
89652: GO 89745
89654: LD_INT 3
89656: DOUBLE
89657: EQUAL
89658: IFTRUE 89662
89660: GO 89669
89662: POP
// hHackSetLevel10YourUnits ; 4 :
89663: CALL 100998 0 0
89667: GO 89745
89669: LD_INT 4
89671: DOUBLE
89672: EQUAL
89673: IFTRUE 89677
89675: GO 89684
89677: POP
// hHackInvincible ; 5 :
89678: CALL 101446 0 0
89682: GO 89745
89684: LD_INT 5
89686: DOUBLE
89687: EQUAL
89688: IFTRUE 89692
89690: GO 89699
89692: POP
// hHackInvisible ; 6 :
89693: CALL 101557 0 0
89697: GO 89745
89699: LD_INT 6
89701: DOUBLE
89702: EQUAL
89703: IFTRUE 89707
89705: GO 89714
89707: POP
// hHackChangeYourSide ; 7 :
89708: CALL 101614 0 0
89712: GO 89745
89714: LD_INT 7
89716: DOUBLE
89717: EQUAL
89718: IFTRUE 89722
89720: GO 89729
89722: POP
// hHackChangeUnitSide ; 8 :
89723: CALL 101656 0 0
89727: GO 89745
89729: LD_INT 8
89731: DOUBLE
89732: EQUAL
89733: IFTRUE 89737
89735: GO 89744
89737: POP
// hHackFog ; end ;
89738: CALL 101757 0 0
89742: GO 89745
89744: POP
// end ; end ;
89745: PPOPN 6
89747: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
89748: GO 89750
89750: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
89751: LD_STRING initStreamRollete();
89753: PPUSH
89754: CALL_OW 559
// InitStreamMode ;
89758: CALL 89767 0 0
// DefineStreamItems ( ) ;
89762: CALL 90207 0 0
// end ;
89766: END
// function InitStreamMode ; begin
89767: LD_INT 0
89769: PPUSH
// streamModeActive := false ;
89770: LD_ADDR_EXP 113
89774: PUSH
89775: LD_INT 0
89777: ST_TO_ADDR
// normalCounter := 36 ;
89778: LD_ADDR_EXP 114
89782: PUSH
89783: LD_INT 36
89785: ST_TO_ADDR
// hardcoreCounter := 16 ;
89786: LD_ADDR_EXP 115
89790: PUSH
89791: LD_INT 16
89793: ST_TO_ADDR
// sRocket := false ;
89794: LD_ADDR_EXP 118
89798: PUSH
89799: LD_INT 0
89801: ST_TO_ADDR
// sSpeed := false ;
89802: LD_ADDR_EXP 117
89806: PUSH
89807: LD_INT 0
89809: ST_TO_ADDR
// sEngine := false ;
89810: LD_ADDR_EXP 119
89814: PUSH
89815: LD_INT 0
89817: ST_TO_ADDR
// sSpec := false ;
89818: LD_ADDR_EXP 116
89822: PUSH
89823: LD_INT 0
89825: ST_TO_ADDR
// sLevel := false ;
89826: LD_ADDR_EXP 120
89830: PUSH
89831: LD_INT 0
89833: ST_TO_ADDR
// sArmoury := false ;
89834: LD_ADDR_EXP 121
89838: PUSH
89839: LD_INT 0
89841: ST_TO_ADDR
// sRadar := false ;
89842: LD_ADDR_EXP 122
89846: PUSH
89847: LD_INT 0
89849: ST_TO_ADDR
// sBunker := false ;
89850: LD_ADDR_EXP 123
89854: PUSH
89855: LD_INT 0
89857: ST_TO_ADDR
// sHack := false ;
89858: LD_ADDR_EXP 124
89862: PUSH
89863: LD_INT 0
89865: ST_TO_ADDR
// sFire := false ;
89866: LD_ADDR_EXP 125
89870: PUSH
89871: LD_INT 0
89873: ST_TO_ADDR
// sRefresh := false ;
89874: LD_ADDR_EXP 126
89878: PUSH
89879: LD_INT 0
89881: ST_TO_ADDR
// sExp := false ;
89882: LD_ADDR_EXP 127
89886: PUSH
89887: LD_INT 0
89889: ST_TO_ADDR
// sDepot := false ;
89890: LD_ADDR_EXP 128
89894: PUSH
89895: LD_INT 0
89897: ST_TO_ADDR
// sFlag := false ;
89898: LD_ADDR_EXP 129
89902: PUSH
89903: LD_INT 0
89905: ST_TO_ADDR
// sKamikadze := false ;
89906: LD_ADDR_EXP 137
89910: PUSH
89911: LD_INT 0
89913: ST_TO_ADDR
// sTroll := false ;
89914: LD_ADDR_EXP 138
89918: PUSH
89919: LD_INT 0
89921: ST_TO_ADDR
// sSlow := false ;
89922: LD_ADDR_EXP 139
89926: PUSH
89927: LD_INT 0
89929: ST_TO_ADDR
// sLack := false ;
89930: LD_ADDR_EXP 140
89934: PUSH
89935: LD_INT 0
89937: ST_TO_ADDR
// sTank := false ;
89938: LD_ADDR_EXP 142
89942: PUSH
89943: LD_INT 0
89945: ST_TO_ADDR
// sRemote := false ;
89946: LD_ADDR_EXP 143
89950: PUSH
89951: LD_INT 0
89953: ST_TO_ADDR
// sPowell := false ;
89954: LD_ADDR_EXP 144
89958: PUSH
89959: LD_INT 0
89961: ST_TO_ADDR
// sTeleport := false ;
89962: LD_ADDR_EXP 147
89966: PUSH
89967: LD_INT 0
89969: ST_TO_ADDR
// sOilTower := false ;
89970: LD_ADDR_EXP 149
89974: PUSH
89975: LD_INT 0
89977: ST_TO_ADDR
// sShovel := false ;
89978: LD_ADDR_EXP 150
89982: PUSH
89983: LD_INT 0
89985: ST_TO_ADDR
// sSheik := false ;
89986: LD_ADDR_EXP 151
89990: PUSH
89991: LD_INT 0
89993: ST_TO_ADDR
// sEarthquake := false ;
89994: LD_ADDR_EXP 153
89998: PUSH
89999: LD_INT 0
90001: ST_TO_ADDR
// sAI := false ;
90002: LD_ADDR_EXP 154
90006: PUSH
90007: LD_INT 0
90009: ST_TO_ADDR
// sCargo := false ;
90010: LD_ADDR_EXP 157
90014: PUSH
90015: LD_INT 0
90017: ST_TO_ADDR
// sDLaser := false ;
90018: LD_ADDR_EXP 158
90022: PUSH
90023: LD_INT 0
90025: ST_TO_ADDR
// sExchange := false ;
90026: LD_ADDR_EXP 159
90030: PUSH
90031: LD_INT 0
90033: ST_TO_ADDR
// sFac := false ;
90034: LD_ADDR_EXP 160
90038: PUSH
90039: LD_INT 0
90041: ST_TO_ADDR
// sPower := false ;
90042: LD_ADDR_EXP 161
90046: PUSH
90047: LD_INT 0
90049: ST_TO_ADDR
// sRandom := false ;
90050: LD_ADDR_EXP 162
90054: PUSH
90055: LD_INT 0
90057: ST_TO_ADDR
// sShield := false ;
90058: LD_ADDR_EXP 163
90062: PUSH
90063: LD_INT 0
90065: ST_TO_ADDR
// sTime := false ;
90066: LD_ADDR_EXP 164
90070: PUSH
90071: LD_INT 0
90073: ST_TO_ADDR
// sTools := false ;
90074: LD_ADDR_EXP 165
90078: PUSH
90079: LD_INT 0
90081: ST_TO_ADDR
// sSold := false ;
90082: LD_ADDR_EXP 130
90086: PUSH
90087: LD_INT 0
90089: ST_TO_ADDR
// sDiff := false ;
90090: LD_ADDR_EXP 131
90094: PUSH
90095: LD_INT 0
90097: ST_TO_ADDR
// sFog := false ;
90098: LD_ADDR_EXP 134
90102: PUSH
90103: LD_INT 0
90105: ST_TO_ADDR
// sReset := false ;
90106: LD_ADDR_EXP 135
90110: PUSH
90111: LD_INT 0
90113: ST_TO_ADDR
// sSun := false ;
90114: LD_ADDR_EXP 136
90118: PUSH
90119: LD_INT 0
90121: ST_TO_ADDR
// sTiger := false ;
90122: LD_ADDR_EXP 132
90126: PUSH
90127: LD_INT 0
90129: ST_TO_ADDR
// sBomb := false ;
90130: LD_ADDR_EXP 133
90134: PUSH
90135: LD_INT 0
90137: ST_TO_ADDR
// sWound := false ;
90138: LD_ADDR_EXP 141
90142: PUSH
90143: LD_INT 0
90145: ST_TO_ADDR
// sBetray := false ;
90146: LD_ADDR_EXP 145
90150: PUSH
90151: LD_INT 0
90153: ST_TO_ADDR
// sContamin := false ;
90154: LD_ADDR_EXP 146
90158: PUSH
90159: LD_INT 0
90161: ST_TO_ADDR
// sOil := false ;
90162: LD_ADDR_EXP 148
90166: PUSH
90167: LD_INT 0
90169: ST_TO_ADDR
// sStu := false ;
90170: LD_ADDR_EXP 152
90174: PUSH
90175: LD_INT 0
90177: ST_TO_ADDR
// sBazooka := false ;
90178: LD_ADDR_EXP 155
90182: PUSH
90183: LD_INT 0
90185: ST_TO_ADDR
// sMortar := false ;
90186: LD_ADDR_EXP 156
90190: PUSH
90191: LD_INT 0
90193: ST_TO_ADDR
// sRanger := false ;
90194: LD_ADDR_EXP 166
90198: PUSH
90199: LD_INT 0
90201: ST_TO_ADDR
// end ;
90202: LD_VAR 0 1
90206: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
90207: LD_INT 0
90209: PPUSH
90210: PPUSH
90211: PPUSH
90212: PPUSH
90213: PPUSH
// result := [ ] ;
90214: LD_ADDR_VAR 0 1
90218: PUSH
90219: EMPTY
90220: ST_TO_ADDR
// if campaign_id = 1 then
90221: LD_OWVAR 69
90225: PUSH
90226: LD_INT 1
90228: EQUAL
90229: IFFALSE 93167
// begin case mission_number of 1 :
90231: LD_OWVAR 70
90235: PUSH
90236: LD_INT 1
90238: DOUBLE
90239: EQUAL
90240: IFTRUE 90244
90242: GO 90308
90244: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
90245: LD_ADDR_VAR 0 1
90249: PUSH
90250: LD_INT 2
90252: PUSH
90253: LD_INT 4
90255: PUSH
90256: LD_INT 11
90258: PUSH
90259: LD_INT 12
90261: PUSH
90262: LD_INT 15
90264: PUSH
90265: LD_INT 16
90267: PUSH
90268: LD_INT 22
90270: PUSH
90271: LD_INT 23
90273: PUSH
90274: LD_INT 26
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: PUSH
90288: LD_INT 101
90290: PUSH
90291: LD_INT 102
90293: PUSH
90294: LD_INT 106
90296: PUSH
90297: EMPTY
90298: LIST
90299: LIST
90300: LIST
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: ST_TO_ADDR
90306: GO 93165
90308: LD_INT 2
90310: DOUBLE
90311: EQUAL
90312: IFTRUE 90316
90314: GO 90388
90316: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
90317: LD_ADDR_VAR 0 1
90321: PUSH
90322: LD_INT 2
90324: PUSH
90325: LD_INT 4
90327: PUSH
90328: LD_INT 11
90330: PUSH
90331: LD_INT 12
90333: PUSH
90334: LD_INT 15
90336: PUSH
90337: LD_INT 16
90339: PUSH
90340: LD_INT 22
90342: PUSH
90343: LD_INT 23
90345: PUSH
90346: LD_INT 26
90348: PUSH
90349: EMPTY
90350: LIST
90351: LIST
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: LIST
90357: LIST
90358: LIST
90359: PUSH
90360: LD_INT 101
90362: PUSH
90363: LD_INT 102
90365: PUSH
90366: LD_INT 105
90368: PUSH
90369: LD_INT 106
90371: PUSH
90372: LD_INT 108
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: ST_TO_ADDR
90386: GO 93165
90388: LD_INT 3
90390: DOUBLE
90391: EQUAL
90392: IFTRUE 90396
90394: GO 90472
90396: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
90397: LD_ADDR_VAR 0 1
90401: PUSH
90402: LD_INT 2
90404: PUSH
90405: LD_INT 4
90407: PUSH
90408: LD_INT 5
90410: PUSH
90411: LD_INT 11
90413: PUSH
90414: LD_INT 12
90416: PUSH
90417: LD_INT 15
90419: PUSH
90420: LD_INT 16
90422: PUSH
90423: LD_INT 22
90425: PUSH
90426: LD_INT 26
90428: PUSH
90429: LD_INT 36
90431: PUSH
90432: EMPTY
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: PUSH
90444: LD_INT 101
90446: PUSH
90447: LD_INT 102
90449: PUSH
90450: LD_INT 105
90452: PUSH
90453: LD_INT 106
90455: PUSH
90456: LD_INT 108
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: ST_TO_ADDR
90470: GO 93165
90472: LD_INT 4
90474: DOUBLE
90475: EQUAL
90476: IFTRUE 90480
90478: GO 90564
90480: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
90481: LD_ADDR_VAR 0 1
90485: PUSH
90486: LD_INT 2
90488: PUSH
90489: LD_INT 4
90491: PUSH
90492: LD_INT 5
90494: PUSH
90495: LD_INT 8
90497: PUSH
90498: LD_INT 11
90500: PUSH
90501: LD_INT 12
90503: PUSH
90504: LD_INT 15
90506: PUSH
90507: LD_INT 16
90509: PUSH
90510: LD_INT 22
90512: PUSH
90513: LD_INT 23
90515: PUSH
90516: LD_INT 26
90518: PUSH
90519: LD_INT 36
90521: PUSH
90522: EMPTY
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: LIST
90533: LIST
90534: LIST
90535: PUSH
90536: LD_INT 101
90538: PUSH
90539: LD_INT 102
90541: PUSH
90542: LD_INT 105
90544: PUSH
90545: LD_INT 106
90547: PUSH
90548: LD_INT 108
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: ST_TO_ADDR
90562: GO 93165
90564: LD_INT 5
90566: DOUBLE
90567: EQUAL
90568: IFTRUE 90572
90570: GO 90672
90572: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
90573: LD_ADDR_VAR 0 1
90577: PUSH
90578: LD_INT 2
90580: PUSH
90581: LD_INT 4
90583: PUSH
90584: LD_INT 5
90586: PUSH
90587: LD_INT 6
90589: PUSH
90590: LD_INT 8
90592: PUSH
90593: LD_INT 11
90595: PUSH
90596: LD_INT 12
90598: PUSH
90599: LD_INT 15
90601: PUSH
90602: LD_INT 16
90604: PUSH
90605: LD_INT 22
90607: PUSH
90608: LD_INT 23
90610: PUSH
90611: LD_INT 25
90613: PUSH
90614: LD_INT 26
90616: PUSH
90617: LD_INT 36
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 101
90638: PUSH
90639: LD_INT 102
90641: PUSH
90642: LD_INT 105
90644: PUSH
90645: LD_INT 106
90647: PUSH
90648: LD_INT 108
90650: PUSH
90651: LD_INT 109
90653: PUSH
90654: LD_INT 112
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: ST_TO_ADDR
90670: GO 93165
90672: LD_INT 6
90674: DOUBLE
90675: EQUAL
90676: IFTRUE 90680
90678: GO 90800
90680: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
90681: LD_ADDR_VAR 0 1
90685: PUSH
90686: LD_INT 2
90688: PUSH
90689: LD_INT 4
90691: PUSH
90692: LD_INT 5
90694: PUSH
90695: LD_INT 6
90697: PUSH
90698: LD_INT 8
90700: PUSH
90701: LD_INT 11
90703: PUSH
90704: LD_INT 12
90706: PUSH
90707: LD_INT 15
90709: PUSH
90710: LD_INT 16
90712: PUSH
90713: LD_INT 20
90715: PUSH
90716: LD_INT 21
90718: PUSH
90719: LD_INT 22
90721: PUSH
90722: LD_INT 23
90724: PUSH
90725: LD_INT 25
90727: PUSH
90728: LD_INT 26
90730: PUSH
90731: LD_INT 30
90733: PUSH
90734: LD_INT 31
90736: PUSH
90737: LD_INT 32
90739: PUSH
90740: LD_INT 36
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: LIST
90750: LIST
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: PUSH
90764: LD_INT 101
90766: PUSH
90767: LD_INT 102
90769: PUSH
90770: LD_INT 105
90772: PUSH
90773: LD_INT 106
90775: PUSH
90776: LD_INT 108
90778: PUSH
90779: LD_INT 109
90781: PUSH
90782: LD_INT 112
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: ST_TO_ADDR
90798: GO 93165
90800: LD_INT 7
90802: DOUBLE
90803: EQUAL
90804: IFTRUE 90808
90806: GO 90908
90808: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
90809: LD_ADDR_VAR 0 1
90813: PUSH
90814: LD_INT 2
90816: PUSH
90817: LD_INT 4
90819: PUSH
90820: LD_INT 5
90822: PUSH
90823: LD_INT 7
90825: PUSH
90826: LD_INT 11
90828: PUSH
90829: LD_INT 12
90831: PUSH
90832: LD_INT 15
90834: PUSH
90835: LD_INT 16
90837: PUSH
90838: LD_INT 20
90840: PUSH
90841: LD_INT 21
90843: PUSH
90844: LD_INT 22
90846: PUSH
90847: LD_INT 23
90849: PUSH
90850: LD_INT 25
90852: PUSH
90853: LD_INT 26
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: PUSH
90872: LD_INT 101
90874: PUSH
90875: LD_INT 102
90877: PUSH
90878: LD_INT 103
90880: PUSH
90881: LD_INT 105
90883: PUSH
90884: LD_INT 106
90886: PUSH
90887: LD_INT 108
90889: PUSH
90890: LD_INT 112
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: LIST
90900: LIST
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: ST_TO_ADDR
90906: GO 93165
90908: LD_INT 8
90910: DOUBLE
90911: EQUAL
90912: IFTRUE 90916
90914: GO 91044
90916: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
90917: LD_ADDR_VAR 0 1
90921: PUSH
90922: LD_INT 2
90924: PUSH
90925: LD_INT 4
90927: PUSH
90928: LD_INT 5
90930: PUSH
90931: LD_INT 6
90933: PUSH
90934: LD_INT 7
90936: PUSH
90937: LD_INT 8
90939: PUSH
90940: LD_INT 11
90942: PUSH
90943: LD_INT 12
90945: PUSH
90946: LD_INT 15
90948: PUSH
90949: LD_INT 16
90951: PUSH
90952: LD_INT 20
90954: PUSH
90955: LD_INT 21
90957: PUSH
90958: LD_INT 22
90960: PUSH
90961: LD_INT 23
90963: PUSH
90964: LD_INT 25
90966: PUSH
90967: LD_INT 26
90969: PUSH
90970: LD_INT 30
90972: PUSH
90973: LD_INT 31
90975: PUSH
90976: LD_INT 32
90978: PUSH
90979: LD_INT 36
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: PUSH
91004: LD_INT 101
91006: PUSH
91007: LD_INT 102
91009: PUSH
91010: LD_INT 103
91012: PUSH
91013: LD_INT 105
91015: PUSH
91016: LD_INT 106
91018: PUSH
91019: LD_INT 108
91021: PUSH
91022: LD_INT 109
91024: PUSH
91025: LD_INT 112
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: ST_TO_ADDR
91042: GO 93165
91044: LD_INT 9
91046: DOUBLE
91047: EQUAL
91048: IFTRUE 91052
91050: GO 91188
91052: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
91053: LD_ADDR_VAR 0 1
91057: PUSH
91058: LD_INT 2
91060: PUSH
91061: LD_INT 4
91063: PUSH
91064: LD_INT 5
91066: PUSH
91067: LD_INT 6
91069: PUSH
91070: LD_INT 7
91072: PUSH
91073: LD_INT 8
91075: PUSH
91076: LD_INT 11
91078: PUSH
91079: LD_INT 12
91081: PUSH
91082: LD_INT 15
91084: PUSH
91085: LD_INT 16
91087: PUSH
91088: LD_INT 20
91090: PUSH
91091: LD_INT 21
91093: PUSH
91094: LD_INT 22
91096: PUSH
91097: LD_INT 23
91099: PUSH
91100: LD_INT 25
91102: PUSH
91103: LD_INT 26
91105: PUSH
91106: LD_INT 28
91108: PUSH
91109: LD_INT 30
91111: PUSH
91112: LD_INT 31
91114: PUSH
91115: LD_INT 32
91117: PUSH
91118: LD_INT 36
91120: PUSH
91121: EMPTY
91122: LIST
91123: LIST
91124: LIST
91125: LIST
91126: LIST
91127: LIST
91128: LIST
91129: LIST
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: LIST
91135: LIST
91136: LIST
91137: LIST
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: LIST
91143: PUSH
91144: LD_INT 101
91146: PUSH
91147: LD_INT 102
91149: PUSH
91150: LD_INT 103
91152: PUSH
91153: LD_INT 105
91155: PUSH
91156: LD_INT 106
91158: PUSH
91159: LD_INT 108
91161: PUSH
91162: LD_INT 109
91164: PUSH
91165: LD_INT 112
91167: PUSH
91168: LD_INT 114
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: ST_TO_ADDR
91186: GO 93165
91188: LD_INT 10
91190: DOUBLE
91191: EQUAL
91192: IFTRUE 91196
91194: GO 91380
91196: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
91197: LD_ADDR_VAR 0 1
91201: PUSH
91202: LD_INT 2
91204: PUSH
91205: LD_INT 4
91207: PUSH
91208: LD_INT 5
91210: PUSH
91211: LD_INT 6
91213: PUSH
91214: LD_INT 7
91216: PUSH
91217: LD_INT 8
91219: PUSH
91220: LD_INT 9
91222: PUSH
91223: LD_INT 10
91225: PUSH
91226: LD_INT 11
91228: PUSH
91229: LD_INT 12
91231: PUSH
91232: LD_INT 13
91234: PUSH
91235: LD_INT 14
91237: PUSH
91238: LD_INT 15
91240: PUSH
91241: LD_INT 16
91243: PUSH
91244: LD_INT 17
91246: PUSH
91247: LD_INT 18
91249: PUSH
91250: LD_INT 19
91252: PUSH
91253: LD_INT 20
91255: PUSH
91256: LD_INT 21
91258: PUSH
91259: LD_INT 22
91261: PUSH
91262: LD_INT 23
91264: PUSH
91265: LD_INT 24
91267: PUSH
91268: LD_INT 25
91270: PUSH
91271: LD_INT 26
91273: PUSH
91274: LD_INT 28
91276: PUSH
91277: LD_INT 30
91279: PUSH
91280: LD_INT 31
91282: PUSH
91283: LD_INT 32
91285: PUSH
91286: LD_INT 36
91288: PUSH
91289: EMPTY
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: PUSH
91320: LD_INT 101
91322: PUSH
91323: LD_INT 102
91325: PUSH
91326: LD_INT 103
91328: PUSH
91329: LD_INT 104
91331: PUSH
91332: LD_INT 105
91334: PUSH
91335: LD_INT 106
91337: PUSH
91338: LD_INT 107
91340: PUSH
91341: LD_INT 108
91343: PUSH
91344: LD_INT 109
91346: PUSH
91347: LD_INT 110
91349: PUSH
91350: LD_INT 111
91352: PUSH
91353: LD_INT 112
91355: PUSH
91356: LD_INT 114
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: LIST
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: ST_TO_ADDR
91378: GO 93165
91380: LD_INT 11
91382: DOUBLE
91383: EQUAL
91384: IFTRUE 91388
91386: GO 91580
91388: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
91389: LD_ADDR_VAR 0 1
91393: PUSH
91394: LD_INT 2
91396: PUSH
91397: LD_INT 3
91399: PUSH
91400: LD_INT 4
91402: PUSH
91403: LD_INT 5
91405: PUSH
91406: LD_INT 6
91408: PUSH
91409: LD_INT 7
91411: PUSH
91412: LD_INT 8
91414: PUSH
91415: LD_INT 9
91417: PUSH
91418: LD_INT 10
91420: PUSH
91421: LD_INT 11
91423: PUSH
91424: LD_INT 12
91426: PUSH
91427: LD_INT 13
91429: PUSH
91430: LD_INT 14
91432: PUSH
91433: LD_INT 15
91435: PUSH
91436: LD_INT 16
91438: PUSH
91439: LD_INT 17
91441: PUSH
91442: LD_INT 18
91444: PUSH
91445: LD_INT 19
91447: PUSH
91448: LD_INT 20
91450: PUSH
91451: LD_INT 21
91453: PUSH
91454: LD_INT 22
91456: PUSH
91457: LD_INT 23
91459: PUSH
91460: LD_INT 24
91462: PUSH
91463: LD_INT 25
91465: PUSH
91466: LD_INT 26
91468: PUSH
91469: LD_INT 28
91471: PUSH
91472: LD_INT 30
91474: PUSH
91475: LD_INT 31
91477: PUSH
91478: LD_INT 32
91480: PUSH
91481: LD_INT 34
91483: PUSH
91484: LD_INT 36
91486: PUSH
91487: EMPTY
91488: LIST
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: LIST
91502: LIST
91503: LIST
91504: LIST
91505: LIST
91506: LIST
91507: LIST
91508: LIST
91509: LIST
91510: LIST
91511: LIST
91512: LIST
91513: LIST
91514: LIST
91515: LIST
91516: LIST
91517: LIST
91518: LIST
91519: PUSH
91520: LD_INT 101
91522: PUSH
91523: LD_INT 102
91525: PUSH
91526: LD_INT 103
91528: PUSH
91529: LD_INT 104
91531: PUSH
91532: LD_INT 105
91534: PUSH
91535: LD_INT 106
91537: PUSH
91538: LD_INT 107
91540: PUSH
91541: LD_INT 108
91543: PUSH
91544: LD_INT 109
91546: PUSH
91547: LD_INT 110
91549: PUSH
91550: LD_INT 111
91552: PUSH
91553: LD_INT 112
91555: PUSH
91556: LD_INT 114
91558: PUSH
91559: EMPTY
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: ST_TO_ADDR
91578: GO 93165
91580: LD_INT 12
91582: DOUBLE
91583: EQUAL
91584: IFTRUE 91588
91586: GO 91796
91588: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
91589: LD_ADDR_VAR 0 1
91593: PUSH
91594: LD_INT 1
91596: PUSH
91597: LD_INT 2
91599: PUSH
91600: LD_INT 3
91602: PUSH
91603: LD_INT 4
91605: PUSH
91606: LD_INT 5
91608: PUSH
91609: LD_INT 6
91611: PUSH
91612: LD_INT 7
91614: PUSH
91615: LD_INT 8
91617: PUSH
91618: LD_INT 9
91620: PUSH
91621: LD_INT 10
91623: PUSH
91624: LD_INT 11
91626: PUSH
91627: LD_INT 12
91629: PUSH
91630: LD_INT 13
91632: PUSH
91633: LD_INT 14
91635: PUSH
91636: LD_INT 15
91638: PUSH
91639: LD_INT 16
91641: PUSH
91642: LD_INT 17
91644: PUSH
91645: LD_INT 18
91647: PUSH
91648: LD_INT 19
91650: PUSH
91651: LD_INT 20
91653: PUSH
91654: LD_INT 21
91656: PUSH
91657: LD_INT 22
91659: PUSH
91660: LD_INT 23
91662: PUSH
91663: LD_INT 24
91665: PUSH
91666: LD_INT 25
91668: PUSH
91669: LD_INT 26
91671: PUSH
91672: LD_INT 27
91674: PUSH
91675: LD_INT 28
91677: PUSH
91678: LD_INT 30
91680: PUSH
91681: LD_INT 31
91683: PUSH
91684: LD_INT 32
91686: PUSH
91687: LD_INT 33
91689: PUSH
91690: LD_INT 34
91692: PUSH
91693: LD_INT 36
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: LIST
91700: LIST
91701: LIST
91702: LIST
91703: LIST
91704: LIST
91705: LIST
91706: LIST
91707: LIST
91708: LIST
91709: LIST
91710: LIST
91711: LIST
91712: LIST
91713: LIST
91714: LIST
91715: LIST
91716: LIST
91717: LIST
91718: LIST
91719: LIST
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 101
91734: PUSH
91735: LD_INT 102
91737: PUSH
91738: LD_INT 103
91740: PUSH
91741: LD_INT 104
91743: PUSH
91744: LD_INT 105
91746: PUSH
91747: LD_INT 106
91749: PUSH
91750: LD_INT 107
91752: PUSH
91753: LD_INT 108
91755: PUSH
91756: LD_INT 109
91758: PUSH
91759: LD_INT 110
91761: PUSH
91762: LD_INT 111
91764: PUSH
91765: LD_INT 112
91767: PUSH
91768: LD_INT 113
91770: PUSH
91771: LD_INT 114
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: ST_TO_ADDR
91794: GO 93165
91796: LD_INT 13
91798: DOUBLE
91799: EQUAL
91800: IFTRUE 91804
91802: GO 92000
91804: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
91805: LD_ADDR_VAR 0 1
91809: PUSH
91810: LD_INT 1
91812: PUSH
91813: LD_INT 2
91815: PUSH
91816: LD_INT 3
91818: PUSH
91819: LD_INT 4
91821: PUSH
91822: LD_INT 5
91824: PUSH
91825: LD_INT 8
91827: PUSH
91828: LD_INT 9
91830: PUSH
91831: LD_INT 10
91833: PUSH
91834: LD_INT 11
91836: PUSH
91837: LD_INT 12
91839: PUSH
91840: LD_INT 14
91842: PUSH
91843: LD_INT 15
91845: PUSH
91846: LD_INT 16
91848: PUSH
91849: LD_INT 17
91851: PUSH
91852: LD_INT 18
91854: PUSH
91855: LD_INT 19
91857: PUSH
91858: LD_INT 20
91860: PUSH
91861: LD_INT 21
91863: PUSH
91864: LD_INT 22
91866: PUSH
91867: LD_INT 23
91869: PUSH
91870: LD_INT 24
91872: PUSH
91873: LD_INT 25
91875: PUSH
91876: LD_INT 26
91878: PUSH
91879: LD_INT 27
91881: PUSH
91882: LD_INT 28
91884: PUSH
91885: LD_INT 30
91887: PUSH
91888: LD_INT 31
91890: PUSH
91891: LD_INT 32
91893: PUSH
91894: LD_INT 33
91896: PUSH
91897: LD_INT 34
91899: PUSH
91900: LD_INT 36
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: LIST
91929: LIST
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: PUSH
91936: LD_INT 101
91938: PUSH
91939: LD_INT 102
91941: PUSH
91942: LD_INT 103
91944: PUSH
91945: LD_INT 104
91947: PUSH
91948: LD_INT 105
91950: PUSH
91951: LD_INT 106
91953: PUSH
91954: LD_INT 107
91956: PUSH
91957: LD_INT 108
91959: PUSH
91960: LD_INT 109
91962: PUSH
91963: LD_INT 110
91965: PUSH
91966: LD_INT 111
91968: PUSH
91969: LD_INT 112
91971: PUSH
91972: LD_INT 113
91974: PUSH
91975: LD_INT 114
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: ST_TO_ADDR
91998: GO 93165
92000: LD_INT 14
92002: DOUBLE
92003: EQUAL
92004: IFTRUE 92008
92006: GO 92220
92008: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
92009: LD_ADDR_VAR 0 1
92013: PUSH
92014: LD_INT 1
92016: PUSH
92017: LD_INT 2
92019: PUSH
92020: LD_INT 3
92022: PUSH
92023: LD_INT 4
92025: PUSH
92026: LD_INT 5
92028: PUSH
92029: LD_INT 6
92031: PUSH
92032: LD_INT 7
92034: PUSH
92035: LD_INT 8
92037: PUSH
92038: LD_INT 9
92040: PUSH
92041: LD_INT 10
92043: PUSH
92044: LD_INT 11
92046: PUSH
92047: LD_INT 12
92049: PUSH
92050: LD_INT 13
92052: PUSH
92053: LD_INT 14
92055: PUSH
92056: LD_INT 15
92058: PUSH
92059: LD_INT 16
92061: PUSH
92062: LD_INT 17
92064: PUSH
92065: LD_INT 18
92067: PUSH
92068: LD_INT 19
92070: PUSH
92071: LD_INT 20
92073: PUSH
92074: LD_INT 21
92076: PUSH
92077: LD_INT 22
92079: PUSH
92080: LD_INT 23
92082: PUSH
92083: LD_INT 24
92085: PUSH
92086: LD_INT 25
92088: PUSH
92089: LD_INT 26
92091: PUSH
92092: LD_INT 27
92094: PUSH
92095: LD_INT 28
92097: PUSH
92098: LD_INT 29
92100: PUSH
92101: LD_INT 30
92103: PUSH
92104: LD_INT 31
92106: PUSH
92107: LD_INT 32
92109: PUSH
92110: LD_INT 33
92112: PUSH
92113: LD_INT 34
92115: PUSH
92116: LD_INT 36
92118: PUSH
92119: EMPTY
92120: LIST
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: LIST
92142: LIST
92143: LIST
92144: LIST
92145: LIST
92146: LIST
92147: LIST
92148: LIST
92149: LIST
92150: LIST
92151: LIST
92152: LIST
92153: LIST
92154: LIST
92155: PUSH
92156: LD_INT 101
92158: PUSH
92159: LD_INT 102
92161: PUSH
92162: LD_INT 103
92164: PUSH
92165: LD_INT 104
92167: PUSH
92168: LD_INT 105
92170: PUSH
92171: LD_INT 106
92173: PUSH
92174: LD_INT 107
92176: PUSH
92177: LD_INT 108
92179: PUSH
92180: LD_INT 109
92182: PUSH
92183: LD_INT 110
92185: PUSH
92186: LD_INT 111
92188: PUSH
92189: LD_INT 112
92191: PUSH
92192: LD_INT 113
92194: PUSH
92195: LD_INT 114
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: LIST
92202: LIST
92203: LIST
92204: LIST
92205: LIST
92206: LIST
92207: LIST
92208: LIST
92209: LIST
92210: LIST
92211: LIST
92212: LIST
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: ST_TO_ADDR
92218: GO 93165
92220: LD_INT 15
92222: DOUBLE
92223: EQUAL
92224: IFTRUE 92228
92226: GO 92440
92228: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
92229: LD_ADDR_VAR 0 1
92233: PUSH
92234: LD_INT 1
92236: PUSH
92237: LD_INT 2
92239: PUSH
92240: LD_INT 3
92242: PUSH
92243: LD_INT 4
92245: PUSH
92246: LD_INT 5
92248: PUSH
92249: LD_INT 6
92251: PUSH
92252: LD_INT 7
92254: PUSH
92255: LD_INT 8
92257: PUSH
92258: LD_INT 9
92260: PUSH
92261: LD_INT 10
92263: PUSH
92264: LD_INT 11
92266: PUSH
92267: LD_INT 12
92269: PUSH
92270: LD_INT 13
92272: PUSH
92273: LD_INT 14
92275: PUSH
92276: LD_INT 15
92278: PUSH
92279: LD_INT 16
92281: PUSH
92282: LD_INT 17
92284: PUSH
92285: LD_INT 18
92287: PUSH
92288: LD_INT 19
92290: PUSH
92291: LD_INT 20
92293: PUSH
92294: LD_INT 21
92296: PUSH
92297: LD_INT 22
92299: PUSH
92300: LD_INT 23
92302: PUSH
92303: LD_INT 24
92305: PUSH
92306: LD_INT 25
92308: PUSH
92309: LD_INT 26
92311: PUSH
92312: LD_INT 27
92314: PUSH
92315: LD_INT 28
92317: PUSH
92318: LD_INT 29
92320: PUSH
92321: LD_INT 30
92323: PUSH
92324: LD_INT 31
92326: PUSH
92327: LD_INT 32
92329: PUSH
92330: LD_INT 33
92332: PUSH
92333: LD_INT 34
92335: PUSH
92336: LD_INT 36
92338: PUSH
92339: EMPTY
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: LIST
92347: LIST
92348: LIST
92349: LIST
92350: LIST
92351: LIST
92352: LIST
92353: LIST
92354: LIST
92355: LIST
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 101
92378: PUSH
92379: LD_INT 102
92381: PUSH
92382: LD_INT 103
92384: PUSH
92385: LD_INT 104
92387: PUSH
92388: LD_INT 105
92390: PUSH
92391: LD_INT 106
92393: PUSH
92394: LD_INT 107
92396: PUSH
92397: LD_INT 108
92399: PUSH
92400: LD_INT 109
92402: PUSH
92403: LD_INT 110
92405: PUSH
92406: LD_INT 111
92408: PUSH
92409: LD_INT 112
92411: PUSH
92412: LD_INT 113
92414: PUSH
92415: LD_INT 114
92417: PUSH
92418: EMPTY
92419: LIST
92420: LIST
92421: LIST
92422: LIST
92423: LIST
92424: LIST
92425: LIST
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: PUSH
92434: EMPTY
92435: LIST
92436: LIST
92437: ST_TO_ADDR
92438: GO 93165
92440: LD_INT 16
92442: DOUBLE
92443: EQUAL
92444: IFTRUE 92448
92446: GO 92572
92448: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
92449: LD_ADDR_VAR 0 1
92453: PUSH
92454: LD_INT 2
92456: PUSH
92457: LD_INT 4
92459: PUSH
92460: LD_INT 5
92462: PUSH
92463: LD_INT 7
92465: PUSH
92466: LD_INT 11
92468: PUSH
92469: LD_INT 12
92471: PUSH
92472: LD_INT 15
92474: PUSH
92475: LD_INT 16
92477: PUSH
92478: LD_INT 20
92480: PUSH
92481: LD_INT 21
92483: PUSH
92484: LD_INT 22
92486: PUSH
92487: LD_INT 23
92489: PUSH
92490: LD_INT 25
92492: PUSH
92493: LD_INT 26
92495: PUSH
92496: LD_INT 30
92498: PUSH
92499: LD_INT 31
92501: PUSH
92502: LD_INT 32
92504: PUSH
92505: LD_INT 33
92507: PUSH
92508: LD_INT 34
92510: PUSH
92511: EMPTY
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: PUSH
92532: LD_INT 101
92534: PUSH
92535: LD_INT 102
92537: PUSH
92538: LD_INT 103
92540: PUSH
92541: LD_INT 106
92543: PUSH
92544: LD_INT 108
92546: PUSH
92547: LD_INT 112
92549: PUSH
92550: LD_INT 113
92552: PUSH
92553: LD_INT 114
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: ST_TO_ADDR
92570: GO 93165
92572: LD_INT 17
92574: DOUBLE
92575: EQUAL
92576: IFTRUE 92580
92578: GO 92792
92580: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
92581: LD_ADDR_VAR 0 1
92585: PUSH
92586: LD_INT 1
92588: PUSH
92589: LD_INT 2
92591: PUSH
92592: LD_INT 3
92594: PUSH
92595: LD_INT 4
92597: PUSH
92598: LD_INT 5
92600: PUSH
92601: LD_INT 6
92603: PUSH
92604: LD_INT 7
92606: PUSH
92607: LD_INT 8
92609: PUSH
92610: LD_INT 9
92612: PUSH
92613: LD_INT 10
92615: PUSH
92616: LD_INT 11
92618: PUSH
92619: LD_INT 12
92621: PUSH
92622: LD_INT 13
92624: PUSH
92625: LD_INT 14
92627: PUSH
92628: LD_INT 15
92630: PUSH
92631: LD_INT 16
92633: PUSH
92634: LD_INT 17
92636: PUSH
92637: LD_INT 18
92639: PUSH
92640: LD_INT 19
92642: PUSH
92643: LD_INT 20
92645: PUSH
92646: LD_INT 21
92648: PUSH
92649: LD_INT 22
92651: PUSH
92652: LD_INT 23
92654: PUSH
92655: LD_INT 24
92657: PUSH
92658: LD_INT 25
92660: PUSH
92661: LD_INT 26
92663: PUSH
92664: LD_INT 27
92666: PUSH
92667: LD_INT 28
92669: PUSH
92670: LD_INT 29
92672: PUSH
92673: LD_INT 30
92675: PUSH
92676: LD_INT 31
92678: PUSH
92679: LD_INT 32
92681: PUSH
92682: LD_INT 33
92684: PUSH
92685: LD_INT 34
92687: PUSH
92688: LD_INT 36
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: LIST
92716: LIST
92717: LIST
92718: LIST
92719: LIST
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: PUSH
92728: LD_INT 101
92730: PUSH
92731: LD_INT 102
92733: PUSH
92734: LD_INT 103
92736: PUSH
92737: LD_INT 104
92739: PUSH
92740: LD_INT 105
92742: PUSH
92743: LD_INT 106
92745: PUSH
92746: LD_INT 107
92748: PUSH
92749: LD_INT 108
92751: PUSH
92752: LD_INT 109
92754: PUSH
92755: LD_INT 110
92757: PUSH
92758: LD_INT 111
92760: PUSH
92761: LD_INT 112
92763: PUSH
92764: LD_INT 113
92766: PUSH
92767: LD_INT 114
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: ST_TO_ADDR
92790: GO 93165
92792: LD_INT 18
92794: DOUBLE
92795: EQUAL
92796: IFTRUE 92800
92798: GO 92936
92800: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
92801: LD_ADDR_VAR 0 1
92805: PUSH
92806: LD_INT 2
92808: PUSH
92809: LD_INT 4
92811: PUSH
92812: LD_INT 5
92814: PUSH
92815: LD_INT 7
92817: PUSH
92818: LD_INT 11
92820: PUSH
92821: LD_INT 12
92823: PUSH
92824: LD_INT 15
92826: PUSH
92827: LD_INT 16
92829: PUSH
92830: LD_INT 20
92832: PUSH
92833: LD_INT 21
92835: PUSH
92836: LD_INT 22
92838: PUSH
92839: LD_INT 23
92841: PUSH
92842: LD_INT 25
92844: PUSH
92845: LD_INT 26
92847: PUSH
92848: LD_INT 30
92850: PUSH
92851: LD_INT 31
92853: PUSH
92854: LD_INT 32
92856: PUSH
92857: LD_INT 33
92859: PUSH
92860: LD_INT 34
92862: PUSH
92863: LD_INT 35
92865: PUSH
92866: LD_INT 36
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: PUSH
92892: LD_INT 101
92894: PUSH
92895: LD_INT 102
92897: PUSH
92898: LD_INT 103
92900: PUSH
92901: LD_INT 106
92903: PUSH
92904: LD_INT 108
92906: PUSH
92907: LD_INT 112
92909: PUSH
92910: LD_INT 113
92912: PUSH
92913: LD_INT 114
92915: PUSH
92916: LD_INT 115
92918: PUSH
92919: EMPTY
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: ST_TO_ADDR
92934: GO 93165
92936: LD_INT 19
92938: DOUBLE
92939: EQUAL
92940: IFTRUE 92944
92942: GO 93164
92944: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
92945: LD_ADDR_VAR 0 1
92949: PUSH
92950: LD_INT 1
92952: PUSH
92953: LD_INT 2
92955: PUSH
92956: LD_INT 3
92958: PUSH
92959: LD_INT 4
92961: PUSH
92962: LD_INT 5
92964: PUSH
92965: LD_INT 6
92967: PUSH
92968: LD_INT 7
92970: PUSH
92971: LD_INT 8
92973: PUSH
92974: LD_INT 9
92976: PUSH
92977: LD_INT 10
92979: PUSH
92980: LD_INT 11
92982: PUSH
92983: LD_INT 12
92985: PUSH
92986: LD_INT 13
92988: PUSH
92989: LD_INT 14
92991: PUSH
92992: LD_INT 15
92994: PUSH
92995: LD_INT 16
92997: PUSH
92998: LD_INT 17
93000: PUSH
93001: LD_INT 18
93003: PUSH
93004: LD_INT 19
93006: PUSH
93007: LD_INT 20
93009: PUSH
93010: LD_INT 21
93012: PUSH
93013: LD_INT 22
93015: PUSH
93016: LD_INT 23
93018: PUSH
93019: LD_INT 24
93021: PUSH
93022: LD_INT 25
93024: PUSH
93025: LD_INT 26
93027: PUSH
93028: LD_INT 27
93030: PUSH
93031: LD_INT 28
93033: PUSH
93034: LD_INT 29
93036: PUSH
93037: LD_INT 30
93039: PUSH
93040: LD_INT 31
93042: PUSH
93043: LD_INT 32
93045: PUSH
93046: LD_INT 33
93048: PUSH
93049: LD_INT 34
93051: PUSH
93052: LD_INT 35
93054: PUSH
93055: LD_INT 36
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: LIST
93064: LIST
93065: LIST
93066: LIST
93067: LIST
93068: LIST
93069: LIST
93070: LIST
93071: LIST
93072: LIST
93073: LIST
93074: LIST
93075: LIST
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: PUSH
93096: LD_INT 101
93098: PUSH
93099: LD_INT 102
93101: PUSH
93102: LD_INT 103
93104: PUSH
93105: LD_INT 104
93107: PUSH
93108: LD_INT 105
93110: PUSH
93111: LD_INT 106
93113: PUSH
93114: LD_INT 107
93116: PUSH
93117: LD_INT 108
93119: PUSH
93120: LD_INT 109
93122: PUSH
93123: LD_INT 110
93125: PUSH
93126: LD_INT 111
93128: PUSH
93129: LD_INT 112
93131: PUSH
93132: LD_INT 113
93134: PUSH
93135: LD_INT 114
93137: PUSH
93138: LD_INT 115
93140: PUSH
93141: EMPTY
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: PUSH
93158: EMPTY
93159: LIST
93160: LIST
93161: ST_TO_ADDR
93162: GO 93165
93164: POP
// end else
93165: GO 93384
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
93167: LD_ADDR_VAR 0 1
93171: PUSH
93172: LD_INT 1
93174: PUSH
93175: LD_INT 2
93177: PUSH
93178: LD_INT 3
93180: PUSH
93181: LD_INT 4
93183: PUSH
93184: LD_INT 5
93186: PUSH
93187: LD_INT 6
93189: PUSH
93190: LD_INT 7
93192: PUSH
93193: LD_INT 8
93195: PUSH
93196: LD_INT 9
93198: PUSH
93199: LD_INT 10
93201: PUSH
93202: LD_INT 11
93204: PUSH
93205: LD_INT 12
93207: PUSH
93208: LD_INT 13
93210: PUSH
93211: LD_INT 14
93213: PUSH
93214: LD_INT 15
93216: PUSH
93217: LD_INT 16
93219: PUSH
93220: LD_INT 17
93222: PUSH
93223: LD_INT 18
93225: PUSH
93226: LD_INT 19
93228: PUSH
93229: LD_INT 20
93231: PUSH
93232: LD_INT 21
93234: PUSH
93235: LD_INT 22
93237: PUSH
93238: LD_INT 23
93240: PUSH
93241: LD_INT 24
93243: PUSH
93244: LD_INT 25
93246: PUSH
93247: LD_INT 26
93249: PUSH
93250: LD_INT 27
93252: PUSH
93253: LD_INT 28
93255: PUSH
93256: LD_INT 29
93258: PUSH
93259: LD_INT 30
93261: PUSH
93262: LD_INT 31
93264: PUSH
93265: LD_INT 32
93267: PUSH
93268: LD_INT 33
93270: PUSH
93271: LD_INT 34
93273: PUSH
93274: LD_INT 35
93276: PUSH
93277: LD_INT 36
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: LIST
93303: LIST
93304: LIST
93305: LIST
93306: LIST
93307: LIST
93308: LIST
93309: LIST
93310: LIST
93311: LIST
93312: LIST
93313: LIST
93314: LIST
93315: LIST
93316: LIST
93317: PUSH
93318: LD_INT 101
93320: PUSH
93321: LD_INT 102
93323: PUSH
93324: LD_INT 103
93326: PUSH
93327: LD_INT 104
93329: PUSH
93330: LD_INT 105
93332: PUSH
93333: LD_INT 106
93335: PUSH
93336: LD_INT 107
93338: PUSH
93339: LD_INT 108
93341: PUSH
93342: LD_INT 109
93344: PUSH
93345: LD_INT 110
93347: PUSH
93348: LD_INT 111
93350: PUSH
93351: LD_INT 112
93353: PUSH
93354: LD_INT 113
93356: PUSH
93357: LD_INT 114
93359: PUSH
93360: LD_INT 115
93362: PUSH
93363: EMPTY
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: PUSH
93380: EMPTY
93381: LIST
93382: LIST
93383: ST_TO_ADDR
// if result then
93384: LD_VAR 0 1
93388: IFFALSE 93677
// begin normal :=  ;
93390: LD_ADDR_VAR 0 3
93394: PUSH
93395: LD_STRING 
93397: ST_TO_ADDR
// hardcore :=  ;
93398: LD_ADDR_VAR 0 4
93402: PUSH
93403: LD_STRING 
93405: ST_TO_ADDR
// for i = 1 to normalCounter do
93406: LD_ADDR_VAR 0 5
93410: PUSH
93411: DOUBLE
93412: LD_INT 1
93414: DEC
93415: ST_TO_ADDR
93416: LD_EXP 114
93420: PUSH
93421: FOR_TO
93422: IFFALSE 93523
// begin tmp := 0 ;
93424: LD_ADDR_VAR 0 2
93428: PUSH
93429: LD_STRING 0
93431: ST_TO_ADDR
// if result [ 1 ] then
93432: LD_VAR 0 1
93436: PUSH
93437: LD_INT 1
93439: ARRAY
93440: IFFALSE 93505
// if result [ 1 ] [ 1 ] = i then
93442: LD_VAR 0 1
93446: PUSH
93447: LD_INT 1
93449: ARRAY
93450: PUSH
93451: LD_INT 1
93453: ARRAY
93454: PUSH
93455: LD_VAR 0 5
93459: EQUAL
93460: IFFALSE 93505
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93462: LD_ADDR_VAR 0 1
93466: PUSH
93467: LD_VAR 0 1
93471: PPUSH
93472: LD_INT 1
93474: PPUSH
93475: LD_VAR 0 1
93479: PUSH
93480: LD_INT 1
93482: ARRAY
93483: PPUSH
93484: LD_INT 1
93486: PPUSH
93487: CALL_OW 3
93491: PPUSH
93492: CALL_OW 1
93496: ST_TO_ADDR
// tmp := 1 ;
93497: LD_ADDR_VAR 0 2
93501: PUSH
93502: LD_STRING 1
93504: ST_TO_ADDR
// end ; normal := normal & tmp ;
93505: LD_ADDR_VAR 0 3
93509: PUSH
93510: LD_VAR 0 3
93514: PUSH
93515: LD_VAR 0 2
93519: STR
93520: ST_TO_ADDR
// end ;
93521: GO 93421
93523: POP
93524: POP
// for i = 1 to hardcoreCounter do
93525: LD_ADDR_VAR 0 5
93529: PUSH
93530: DOUBLE
93531: LD_INT 1
93533: DEC
93534: ST_TO_ADDR
93535: LD_EXP 115
93539: PUSH
93540: FOR_TO
93541: IFFALSE 93646
// begin tmp := 0 ;
93543: LD_ADDR_VAR 0 2
93547: PUSH
93548: LD_STRING 0
93550: ST_TO_ADDR
// if result [ 2 ] then
93551: LD_VAR 0 1
93555: PUSH
93556: LD_INT 2
93558: ARRAY
93559: IFFALSE 93628
// if result [ 2 ] [ 1 ] = 100 + i then
93561: LD_VAR 0 1
93565: PUSH
93566: LD_INT 2
93568: ARRAY
93569: PUSH
93570: LD_INT 1
93572: ARRAY
93573: PUSH
93574: LD_INT 100
93576: PUSH
93577: LD_VAR 0 5
93581: PLUS
93582: EQUAL
93583: IFFALSE 93628
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93585: LD_ADDR_VAR 0 1
93589: PUSH
93590: LD_VAR 0 1
93594: PPUSH
93595: LD_INT 2
93597: PPUSH
93598: LD_VAR 0 1
93602: PUSH
93603: LD_INT 2
93605: ARRAY
93606: PPUSH
93607: LD_INT 1
93609: PPUSH
93610: CALL_OW 3
93614: PPUSH
93615: CALL_OW 1
93619: ST_TO_ADDR
// tmp := 1 ;
93620: LD_ADDR_VAR 0 2
93624: PUSH
93625: LD_STRING 1
93627: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93628: LD_ADDR_VAR 0 4
93632: PUSH
93633: LD_VAR 0 4
93637: PUSH
93638: LD_VAR 0 2
93642: STR
93643: ST_TO_ADDR
// end ;
93644: GO 93540
93646: POP
93647: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
93648: LD_STRING getStreamItemsFromMission("
93650: PUSH
93651: LD_VAR 0 3
93655: STR
93656: PUSH
93657: LD_STRING ","
93659: STR
93660: PUSH
93661: LD_VAR 0 4
93665: STR
93666: PUSH
93667: LD_STRING ")
93669: STR
93670: PPUSH
93671: CALL_OW 559
// end else
93675: GO 93684
// ToLua ( getStreamItemsFromMission("","") ) ;
93677: LD_STRING getStreamItemsFromMission("","")
93679: PPUSH
93680: CALL_OW 559
// end ;
93684: LD_VAR 0 1
93688: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93689: LD_EXP 113
93693: PUSH
93694: LD_EXP 118
93698: AND
93699: IFFALSE 93823
93701: GO 93703
93703: DISABLE
93704: LD_INT 0
93706: PPUSH
93707: PPUSH
// begin enable ;
93708: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93709: LD_ADDR_VAR 0 2
93713: PUSH
93714: LD_INT 22
93716: PUSH
93717: LD_OWVAR 2
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: PUSH
93726: LD_INT 2
93728: PUSH
93729: LD_INT 34
93731: PUSH
93732: LD_INT 7
93734: PUSH
93735: EMPTY
93736: LIST
93737: LIST
93738: PUSH
93739: LD_INT 34
93741: PUSH
93742: LD_INT 45
93744: PUSH
93745: EMPTY
93746: LIST
93747: LIST
93748: PUSH
93749: LD_INT 34
93751: PUSH
93752: LD_INT 28
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: PUSH
93759: LD_INT 34
93761: PUSH
93762: LD_INT 47
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: PUSH
93769: EMPTY
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: PUSH
93776: EMPTY
93777: LIST
93778: LIST
93779: PPUSH
93780: CALL_OW 69
93784: ST_TO_ADDR
// if not tmp then
93785: LD_VAR 0 2
93789: NOT
93790: IFFALSE 93794
// exit ;
93792: GO 93823
// for i in tmp do
93794: LD_ADDR_VAR 0 1
93798: PUSH
93799: LD_VAR 0 2
93803: PUSH
93804: FOR_IN
93805: IFFALSE 93821
// begin SetLives ( i , 0 ) ;
93807: LD_VAR 0 1
93811: PPUSH
93812: LD_INT 0
93814: PPUSH
93815: CALL_OW 234
// end ;
93819: GO 93804
93821: POP
93822: POP
// end ;
93823: PPOPN 2
93825: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93826: LD_EXP 113
93830: PUSH
93831: LD_EXP 119
93835: AND
93836: IFFALSE 93920
93838: GO 93840
93840: DISABLE
93841: LD_INT 0
93843: PPUSH
93844: PPUSH
// begin enable ;
93845: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93846: LD_ADDR_VAR 0 2
93850: PUSH
93851: LD_INT 22
93853: PUSH
93854: LD_OWVAR 2
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: PUSH
93863: LD_INT 32
93865: PUSH
93866: LD_INT 3
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PPUSH
93877: CALL_OW 69
93881: ST_TO_ADDR
// if not tmp then
93882: LD_VAR 0 2
93886: NOT
93887: IFFALSE 93891
// exit ;
93889: GO 93920
// for i in tmp do
93891: LD_ADDR_VAR 0 1
93895: PUSH
93896: LD_VAR 0 2
93900: PUSH
93901: FOR_IN
93902: IFFALSE 93918
// begin SetLives ( i , 0 ) ;
93904: LD_VAR 0 1
93908: PPUSH
93909: LD_INT 0
93911: PPUSH
93912: CALL_OW 234
// end ;
93916: GO 93901
93918: POP
93919: POP
// end ;
93920: PPOPN 2
93922: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93923: LD_EXP 113
93927: PUSH
93928: LD_EXP 116
93932: AND
93933: IFFALSE 94026
93935: GO 93937
93937: DISABLE
93938: LD_INT 0
93940: PPUSH
// begin enable ;
93941: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93942: LD_ADDR_VAR 0 1
93946: PUSH
93947: LD_INT 22
93949: PUSH
93950: LD_OWVAR 2
93954: PUSH
93955: EMPTY
93956: LIST
93957: LIST
93958: PUSH
93959: LD_INT 2
93961: PUSH
93962: LD_INT 25
93964: PUSH
93965: LD_INT 5
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 25
93974: PUSH
93975: LD_INT 9
93977: PUSH
93978: EMPTY
93979: LIST
93980: LIST
93981: PUSH
93982: LD_INT 25
93984: PUSH
93985: LD_INT 8
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: PPUSH
94002: CALL_OW 69
94006: PUSH
94007: FOR_IN
94008: IFFALSE 94024
// begin SetClass ( i , 1 ) ;
94010: LD_VAR 0 1
94014: PPUSH
94015: LD_INT 1
94017: PPUSH
94018: CALL_OW 336
// end ;
94022: GO 94007
94024: POP
94025: POP
// end ;
94026: PPOPN 1
94028: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
94029: LD_EXP 113
94033: PUSH
94034: LD_EXP 117
94038: AND
94039: PUSH
94040: LD_OWVAR 65
94044: PUSH
94045: LD_INT 7
94047: LESS
94048: AND
94049: IFFALSE 94063
94051: GO 94053
94053: DISABLE
// begin enable ;
94054: ENABLE
// game_speed := 7 ;
94055: LD_ADDR_OWVAR 65
94059: PUSH
94060: LD_INT 7
94062: ST_TO_ADDR
// end ;
94063: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
94064: LD_EXP 113
94068: PUSH
94069: LD_EXP 120
94073: AND
94074: IFFALSE 94276
94076: GO 94078
94078: DISABLE
94079: LD_INT 0
94081: PPUSH
94082: PPUSH
94083: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
94084: LD_ADDR_VAR 0 3
94088: PUSH
94089: LD_INT 81
94091: PUSH
94092: LD_OWVAR 2
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: LD_INT 21
94103: PUSH
94104: LD_INT 1
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PPUSH
94115: CALL_OW 69
94119: ST_TO_ADDR
// if not tmp then
94120: LD_VAR 0 3
94124: NOT
94125: IFFALSE 94129
// exit ;
94127: GO 94276
// if tmp > 5 then
94129: LD_VAR 0 3
94133: PUSH
94134: LD_INT 5
94136: GREATER
94137: IFFALSE 94149
// k := 5 else
94139: LD_ADDR_VAR 0 2
94143: PUSH
94144: LD_INT 5
94146: ST_TO_ADDR
94147: GO 94159
// k := tmp ;
94149: LD_ADDR_VAR 0 2
94153: PUSH
94154: LD_VAR 0 3
94158: ST_TO_ADDR
// for i := 1 to k do
94159: LD_ADDR_VAR 0 1
94163: PUSH
94164: DOUBLE
94165: LD_INT 1
94167: DEC
94168: ST_TO_ADDR
94169: LD_VAR 0 2
94173: PUSH
94174: FOR_TO
94175: IFFALSE 94274
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94177: LD_VAR 0 3
94181: PUSH
94182: LD_VAR 0 1
94186: ARRAY
94187: PPUSH
94188: LD_VAR 0 1
94192: PUSH
94193: LD_INT 4
94195: MOD
94196: PUSH
94197: LD_INT 1
94199: PLUS
94200: PPUSH
94201: CALL_OW 259
94205: PUSH
94206: LD_INT 10
94208: LESS
94209: IFFALSE 94272
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94211: LD_VAR 0 3
94215: PUSH
94216: LD_VAR 0 1
94220: ARRAY
94221: PPUSH
94222: LD_VAR 0 1
94226: PUSH
94227: LD_INT 4
94229: MOD
94230: PUSH
94231: LD_INT 1
94233: PLUS
94234: PPUSH
94235: LD_VAR 0 3
94239: PUSH
94240: LD_VAR 0 1
94244: ARRAY
94245: PPUSH
94246: LD_VAR 0 1
94250: PUSH
94251: LD_INT 4
94253: MOD
94254: PUSH
94255: LD_INT 1
94257: PLUS
94258: PPUSH
94259: CALL_OW 259
94263: PUSH
94264: LD_INT 1
94266: PLUS
94267: PPUSH
94268: CALL_OW 237
94272: GO 94174
94274: POP
94275: POP
// end ;
94276: PPOPN 3
94278: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94279: LD_EXP 113
94283: PUSH
94284: LD_EXP 121
94288: AND
94289: IFFALSE 94309
94291: GO 94293
94293: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94294: LD_INT 4
94296: PPUSH
94297: LD_OWVAR 2
94301: PPUSH
94302: LD_INT 0
94304: PPUSH
94305: CALL_OW 324
94309: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94310: LD_EXP 113
94314: PUSH
94315: LD_EXP 150
94319: AND
94320: IFFALSE 94340
94322: GO 94324
94324: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94325: LD_INT 19
94327: PPUSH
94328: LD_OWVAR 2
94332: PPUSH
94333: LD_INT 0
94335: PPUSH
94336: CALL_OW 324
94340: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94341: LD_EXP 113
94345: PUSH
94346: LD_EXP 122
94350: AND
94351: IFFALSE 94453
94353: GO 94355
94355: DISABLE
94356: LD_INT 0
94358: PPUSH
94359: PPUSH
// begin enable ;
94360: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94361: LD_ADDR_VAR 0 2
94365: PUSH
94366: LD_INT 22
94368: PUSH
94369: LD_OWVAR 2
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 2
94380: PUSH
94381: LD_INT 34
94383: PUSH
94384: LD_INT 11
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 34
94393: PUSH
94394: LD_INT 30
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: LIST
94405: PUSH
94406: EMPTY
94407: LIST
94408: LIST
94409: PPUSH
94410: CALL_OW 69
94414: ST_TO_ADDR
// if not tmp then
94415: LD_VAR 0 2
94419: NOT
94420: IFFALSE 94424
// exit ;
94422: GO 94453
// for i in tmp do
94424: LD_ADDR_VAR 0 1
94428: PUSH
94429: LD_VAR 0 2
94433: PUSH
94434: FOR_IN
94435: IFFALSE 94451
// begin SetLives ( i , 0 ) ;
94437: LD_VAR 0 1
94441: PPUSH
94442: LD_INT 0
94444: PPUSH
94445: CALL_OW 234
// end ;
94449: GO 94434
94451: POP
94452: POP
// end ;
94453: PPOPN 2
94455: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94456: LD_EXP 113
94460: PUSH
94461: LD_EXP 123
94465: AND
94466: IFFALSE 94486
94468: GO 94470
94470: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94471: LD_INT 32
94473: PPUSH
94474: LD_OWVAR 2
94478: PPUSH
94479: LD_INT 0
94481: PPUSH
94482: CALL_OW 324
94486: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94487: LD_EXP 113
94491: PUSH
94492: LD_EXP 124
94496: AND
94497: IFFALSE 94678
94499: GO 94501
94501: DISABLE
94502: LD_INT 0
94504: PPUSH
94505: PPUSH
94506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
94507: LD_ADDR_VAR 0 2
94511: PUSH
94512: LD_INT 22
94514: PUSH
94515: LD_OWVAR 2
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: PUSH
94524: LD_INT 33
94526: PUSH
94527: LD_INT 3
94529: PUSH
94530: EMPTY
94531: LIST
94532: LIST
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: PPUSH
94538: CALL_OW 69
94542: ST_TO_ADDR
// if not tmp then
94543: LD_VAR 0 2
94547: NOT
94548: IFFALSE 94552
// exit ;
94550: GO 94678
// side := 0 ;
94552: LD_ADDR_VAR 0 3
94556: PUSH
94557: LD_INT 0
94559: ST_TO_ADDR
// for i := 1 to 8 do
94560: LD_ADDR_VAR 0 1
94564: PUSH
94565: DOUBLE
94566: LD_INT 1
94568: DEC
94569: ST_TO_ADDR
94570: LD_INT 8
94572: PUSH
94573: FOR_TO
94574: IFFALSE 94622
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94576: LD_OWVAR 2
94580: PUSH
94581: LD_VAR 0 1
94585: NONEQUAL
94586: PUSH
94587: LD_OWVAR 2
94591: PPUSH
94592: LD_VAR 0 1
94596: PPUSH
94597: CALL_OW 81
94601: PUSH
94602: LD_INT 2
94604: EQUAL
94605: AND
94606: IFFALSE 94620
// begin side := i ;
94608: LD_ADDR_VAR 0 3
94612: PUSH
94613: LD_VAR 0 1
94617: ST_TO_ADDR
// break ;
94618: GO 94622
// end ;
94620: GO 94573
94622: POP
94623: POP
// if not side then
94624: LD_VAR 0 3
94628: NOT
94629: IFFALSE 94633
// exit ;
94631: GO 94678
// for i := 1 to tmp do
94633: LD_ADDR_VAR 0 1
94637: PUSH
94638: DOUBLE
94639: LD_INT 1
94641: DEC
94642: ST_TO_ADDR
94643: LD_VAR 0 2
94647: PUSH
94648: FOR_TO
94649: IFFALSE 94676
// if Prob ( 60 ) then
94651: LD_INT 60
94653: PPUSH
94654: CALL_OW 13
94658: IFFALSE 94674
// SetSide ( i , side ) ;
94660: LD_VAR 0 1
94664: PPUSH
94665: LD_VAR 0 3
94669: PPUSH
94670: CALL_OW 235
94674: GO 94648
94676: POP
94677: POP
// end ;
94678: PPOPN 3
94680: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94681: LD_EXP 113
94685: PUSH
94686: LD_EXP 126
94690: AND
94691: IFFALSE 94810
94693: GO 94695
94695: DISABLE
94696: LD_INT 0
94698: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94699: LD_ADDR_VAR 0 1
94703: PUSH
94704: LD_INT 22
94706: PUSH
94707: LD_OWVAR 2
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: PUSH
94716: LD_INT 21
94718: PUSH
94719: LD_INT 1
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 3
94728: PUSH
94729: LD_INT 23
94731: PUSH
94732: LD_INT 0
94734: PUSH
94735: EMPTY
94736: LIST
94737: LIST
94738: PUSH
94739: EMPTY
94740: LIST
94741: LIST
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: LIST
94747: PPUSH
94748: CALL_OW 69
94752: PUSH
94753: FOR_IN
94754: IFFALSE 94808
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94756: LD_VAR 0 1
94760: PPUSH
94761: CALL_OW 257
94765: PUSH
94766: LD_INT 1
94768: PUSH
94769: LD_INT 2
94771: PUSH
94772: LD_INT 3
94774: PUSH
94775: LD_INT 4
94777: PUSH
94778: EMPTY
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: IN
94784: IFFALSE 94806
// SetClass ( un , rand ( 1 , 4 ) ) ;
94786: LD_VAR 0 1
94790: PPUSH
94791: LD_INT 1
94793: PPUSH
94794: LD_INT 4
94796: PPUSH
94797: CALL_OW 12
94801: PPUSH
94802: CALL_OW 336
94806: GO 94753
94808: POP
94809: POP
// end ;
94810: PPOPN 1
94812: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94813: LD_EXP 113
94817: PUSH
94818: LD_EXP 125
94822: AND
94823: IFFALSE 94902
94825: GO 94827
94827: DISABLE
94828: LD_INT 0
94830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94831: LD_ADDR_VAR 0 1
94835: PUSH
94836: LD_INT 22
94838: PUSH
94839: LD_OWVAR 2
94843: PUSH
94844: EMPTY
94845: LIST
94846: LIST
94847: PUSH
94848: LD_INT 21
94850: PUSH
94851: LD_INT 3
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PPUSH
94862: CALL_OW 69
94866: ST_TO_ADDR
// if not tmp then
94867: LD_VAR 0 1
94871: NOT
94872: IFFALSE 94876
// exit ;
94874: GO 94902
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94876: LD_VAR 0 1
94880: PUSH
94881: LD_INT 1
94883: PPUSH
94884: LD_VAR 0 1
94888: PPUSH
94889: CALL_OW 12
94893: ARRAY
94894: PPUSH
94895: LD_INT 100
94897: PPUSH
94898: CALL_OW 234
// end ;
94902: PPOPN 1
94904: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94905: LD_EXP 113
94909: PUSH
94910: LD_EXP 127
94914: AND
94915: IFFALSE 95013
94917: GO 94919
94919: DISABLE
94920: LD_INT 0
94922: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94923: LD_ADDR_VAR 0 1
94927: PUSH
94928: LD_INT 22
94930: PUSH
94931: LD_OWVAR 2
94935: PUSH
94936: EMPTY
94937: LIST
94938: LIST
94939: PUSH
94940: LD_INT 21
94942: PUSH
94943: LD_INT 1
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: EMPTY
94951: LIST
94952: LIST
94953: PPUSH
94954: CALL_OW 69
94958: ST_TO_ADDR
// if not tmp then
94959: LD_VAR 0 1
94963: NOT
94964: IFFALSE 94968
// exit ;
94966: GO 95013
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94968: LD_VAR 0 1
94972: PUSH
94973: LD_INT 1
94975: PPUSH
94976: LD_VAR 0 1
94980: PPUSH
94981: CALL_OW 12
94985: ARRAY
94986: PPUSH
94987: LD_INT 1
94989: PPUSH
94990: LD_INT 4
94992: PPUSH
94993: CALL_OW 12
94997: PPUSH
94998: LD_INT 3000
95000: PPUSH
95001: LD_INT 9000
95003: PPUSH
95004: CALL_OW 12
95008: PPUSH
95009: CALL_OW 492
// end ;
95013: PPOPN 1
95015: END
// every 0 0$1 trigger StreamModeActive and sDepot do
95016: LD_EXP 113
95020: PUSH
95021: LD_EXP 128
95025: AND
95026: IFFALSE 95046
95028: GO 95030
95030: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
95031: LD_INT 1
95033: PPUSH
95034: LD_OWVAR 2
95038: PPUSH
95039: LD_INT 0
95041: PPUSH
95042: CALL_OW 324
95046: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
95047: LD_EXP 113
95051: PUSH
95052: LD_EXP 129
95056: AND
95057: IFFALSE 95140
95059: GO 95061
95061: DISABLE
95062: LD_INT 0
95064: PPUSH
95065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95066: LD_ADDR_VAR 0 2
95070: PUSH
95071: LD_INT 22
95073: PUSH
95074: LD_OWVAR 2
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PUSH
95083: LD_INT 21
95085: PUSH
95086: LD_INT 3
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: PUSH
95093: EMPTY
95094: LIST
95095: LIST
95096: PPUSH
95097: CALL_OW 69
95101: ST_TO_ADDR
// if not tmp then
95102: LD_VAR 0 2
95106: NOT
95107: IFFALSE 95111
// exit ;
95109: GO 95140
// for i in tmp do
95111: LD_ADDR_VAR 0 1
95115: PUSH
95116: LD_VAR 0 2
95120: PUSH
95121: FOR_IN
95122: IFFALSE 95138
// SetBLevel ( i , 10 ) ;
95124: LD_VAR 0 1
95128: PPUSH
95129: LD_INT 10
95131: PPUSH
95132: CALL_OW 241
95136: GO 95121
95138: POP
95139: POP
// end ;
95140: PPOPN 2
95142: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95143: LD_EXP 113
95147: PUSH
95148: LD_EXP 130
95152: AND
95153: IFFALSE 95264
95155: GO 95157
95157: DISABLE
95158: LD_INT 0
95160: PPUSH
95161: PPUSH
95162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95163: LD_ADDR_VAR 0 3
95167: PUSH
95168: LD_INT 22
95170: PUSH
95171: LD_OWVAR 2
95175: PUSH
95176: EMPTY
95177: LIST
95178: LIST
95179: PUSH
95180: LD_INT 25
95182: PUSH
95183: LD_INT 1
95185: PUSH
95186: EMPTY
95187: LIST
95188: LIST
95189: PUSH
95190: EMPTY
95191: LIST
95192: LIST
95193: PPUSH
95194: CALL_OW 69
95198: ST_TO_ADDR
// if not tmp then
95199: LD_VAR 0 3
95203: NOT
95204: IFFALSE 95208
// exit ;
95206: GO 95264
// un := tmp [ rand ( 1 , tmp ) ] ;
95208: LD_ADDR_VAR 0 2
95212: PUSH
95213: LD_VAR 0 3
95217: PUSH
95218: LD_INT 1
95220: PPUSH
95221: LD_VAR 0 3
95225: PPUSH
95226: CALL_OW 12
95230: ARRAY
95231: ST_TO_ADDR
// if Crawls ( un ) then
95232: LD_VAR 0 2
95236: PPUSH
95237: CALL_OW 318
95241: IFFALSE 95252
// ComWalk ( un ) ;
95243: LD_VAR 0 2
95247: PPUSH
95248: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95252: LD_VAR 0 2
95256: PPUSH
95257: LD_INT 5
95259: PPUSH
95260: CALL_OW 336
// end ;
95264: PPOPN 3
95266: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
95267: LD_EXP 113
95271: PUSH
95272: LD_EXP 131
95276: AND
95277: PUSH
95278: LD_OWVAR 67
95282: PUSH
95283: LD_INT 3
95285: LESS
95286: AND
95287: IFFALSE 95306
95289: GO 95291
95291: DISABLE
// Difficulty := Difficulty + 1 ;
95292: LD_ADDR_OWVAR 67
95296: PUSH
95297: LD_OWVAR 67
95301: PUSH
95302: LD_INT 1
95304: PLUS
95305: ST_TO_ADDR
95306: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95307: LD_EXP 113
95311: PUSH
95312: LD_EXP 132
95316: AND
95317: IFFALSE 95420
95319: GO 95321
95321: DISABLE
95322: LD_INT 0
95324: PPUSH
// begin for i := 1 to 5 do
95325: LD_ADDR_VAR 0 1
95329: PUSH
95330: DOUBLE
95331: LD_INT 1
95333: DEC
95334: ST_TO_ADDR
95335: LD_INT 5
95337: PUSH
95338: FOR_TO
95339: IFFALSE 95418
// begin uc_nation := nation_nature ;
95341: LD_ADDR_OWVAR 21
95345: PUSH
95346: LD_INT 0
95348: ST_TO_ADDR
// uc_side := 0 ;
95349: LD_ADDR_OWVAR 20
95353: PUSH
95354: LD_INT 0
95356: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95357: LD_ADDR_OWVAR 29
95361: PUSH
95362: LD_INT 12
95364: PUSH
95365: LD_INT 12
95367: PUSH
95368: EMPTY
95369: LIST
95370: LIST
95371: ST_TO_ADDR
// hc_agressivity := 20 ;
95372: LD_ADDR_OWVAR 35
95376: PUSH
95377: LD_INT 20
95379: ST_TO_ADDR
// hc_class := class_tiger ;
95380: LD_ADDR_OWVAR 28
95384: PUSH
95385: LD_INT 14
95387: ST_TO_ADDR
// hc_gallery :=  ;
95388: LD_ADDR_OWVAR 33
95392: PUSH
95393: LD_STRING 
95395: ST_TO_ADDR
// hc_name :=  ;
95396: LD_ADDR_OWVAR 26
95400: PUSH
95401: LD_STRING 
95403: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95404: CALL_OW 44
95408: PPUSH
95409: LD_INT 0
95411: PPUSH
95412: CALL_OW 51
// end ;
95416: GO 95338
95418: POP
95419: POP
// end ;
95420: PPOPN 1
95422: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95423: LD_EXP 113
95427: PUSH
95428: LD_EXP 133
95432: AND
95433: IFFALSE 95442
95435: GO 95437
95437: DISABLE
// StreamSibBomb ;
95438: CALL 95443 0 0
95442: END
// export function StreamSibBomb ; var i , x , y ; begin
95443: LD_INT 0
95445: PPUSH
95446: PPUSH
95447: PPUSH
95448: PPUSH
// result := false ;
95449: LD_ADDR_VAR 0 1
95453: PUSH
95454: LD_INT 0
95456: ST_TO_ADDR
// for i := 1 to 16 do
95457: LD_ADDR_VAR 0 2
95461: PUSH
95462: DOUBLE
95463: LD_INT 1
95465: DEC
95466: ST_TO_ADDR
95467: LD_INT 16
95469: PUSH
95470: FOR_TO
95471: IFFALSE 95670
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95473: LD_ADDR_VAR 0 3
95477: PUSH
95478: LD_INT 10
95480: PUSH
95481: LD_INT 20
95483: PUSH
95484: LD_INT 30
95486: PUSH
95487: LD_INT 40
95489: PUSH
95490: LD_INT 50
95492: PUSH
95493: LD_INT 60
95495: PUSH
95496: LD_INT 70
95498: PUSH
95499: LD_INT 80
95501: PUSH
95502: LD_INT 90
95504: PUSH
95505: LD_INT 100
95507: PUSH
95508: LD_INT 110
95510: PUSH
95511: LD_INT 120
95513: PUSH
95514: LD_INT 130
95516: PUSH
95517: LD_INT 140
95519: PUSH
95520: LD_INT 150
95522: PUSH
95523: EMPTY
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: PUSH
95540: LD_INT 1
95542: PPUSH
95543: LD_INT 15
95545: PPUSH
95546: CALL_OW 12
95550: ARRAY
95551: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95552: LD_ADDR_VAR 0 4
95556: PUSH
95557: LD_INT 10
95559: PUSH
95560: LD_INT 20
95562: PUSH
95563: LD_INT 30
95565: PUSH
95566: LD_INT 40
95568: PUSH
95569: LD_INT 50
95571: PUSH
95572: LD_INT 60
95574: PUSH
95575: LD_INT 70
95577: PUSH
95578: LD_INT 80
95580: PUSH
95581: LD_INT 90
95583: PUSH
95584: LD_INT 100
95586: PUSH
95587: LD_INT 110
95589: PUSH
95590: LD_INT 120
95592: PUSH
95593: LD_INT 130
95595: PUSH
95596: LD_INT 140
95598: PUSH
95599: LD_INT 150
95601: PUSH
95602: EMPTY
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: PUSH
95619: LD_INT 1
95621: PPUSH
95622: LD_INT 15
95624: PPUSH
95625: CALL_OW 12
95629: ARRAY
95630: ST_TO_ADDR
// if ValidHex ( x , y ) then
95631: LD_VAR 0 3
95635: PPUSH
95636: LD_VAR 0 4
95640: PPUSH
95641: CALL_OW 488
95645: IFFALSE 95668
// begin result := [ x , y ] ;
95647: LD_ADDR_VAR 0 1
95651: PUSH
95652: LD_VAR 0 3
95656: PUSH
95657: LD_VAR 0 4
95661: PUSH
95662: EMPTY
95663: LIST
95664: LIST
95665: ST_TO_ADDR
// break ;
95666: GO 95670
// end ; end ;
95668: GO 95470
95670: POP
95671: POP
// if result then
95672: LD_VAR 0 1
95676: IFFALSE 95736
// begin ToLua ( playSibBomb() ) ;
95678: LD_STRING playSibBomb()
95680: PPUSH
95681: CALL_OW 559
// wait ( 0 0$14 ) ;
95685: LD_INT 490
95687: PPUSH
95688: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95692: LD_VAR 0 1
95696: PUSH
95697: LD_INT 1
95699: ARRAY
95700: PPUSH
95701: LD_VAR 0 1
95705: PUSH
95706: LD_INT 2
95708: ARRAY
95709: PPUSH
95710: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95714: LD_VAR 0 1
95718: PUSH
95719: LD_INT 1
95721: ARRAY
95722: PPUSH
95723: LD_VAR 0 1
95727: PUSH
95728: LD_INT 2
95730: ARRAY
95731: PPUSH
95732: CALL_OW 429
// end ; end ;
95736: LD_VAR 0 1
95740: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95741: LD_EXP 113
95745: PUSH
95746: LD_EXP 135
95750: AND
95751: IFFALSE 95763
95753: GO 95755
95755: DISABLE
// YouLost (  ) ;
95756: LD_STRING 
95758: PPUSH
95759: CALL_OW 104
95763: END
// every 0 0$1 trigger StreamModeActive and sFog do
95764: LD_EXP 113
95768: PUSH
95769: LD_EXP 134
95773: AND
95774: IFFALSE 95788
95776: GO 95778
95778: DISABLE
// FogOff ( your_side ) ;
95779: LD_OWVAR 2
95783: PPUSH
95784: CALL_OW 344
95788: END
// every 0 0$1 trigger StreamModeActive and sSun do
95789: LD_EXP 113
95793: PUSH
95794: LD_EXP 136
95798: AND
95799: IFFALSE 95827
95801: GO 95803
95803: DISABLE
// begin solar_recharge_percent := 0 ;
95804: LD_ADDR_OWVAR 79
95808: PUSH
95809: LD_INT 0
95811: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95812: LD_INT 10500
95814: PPUSH
95815: CALL_OW 67
// solar_recharge_percent := 100 ;
95819: LD_ADDR_OWVAR 79
95823: PUSH
95824: LD_INT 100
95826: ST_TO_ADDR
// end ;
95827: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95828: LD_EXP 113
95832: PUSH
95833: LD_EXP 137
95837: AND
95838: IFFALSE 96077
95840: GO 95842
95842: DISABLE
95843: LD_INT 0
95845: PPUSH
95846: PPUSH
95847: PPUSH
// begin tmp := [ ] ;
95848: LD_ADDR_VAR 0 3
95852: PUSH
95853: EMPTY
95854: ST_TO_ADDR
// for i := 1 to 6 do
95855: LD_ADDR_VAR 0 1
95859: PUSH
95860: DOUBLE
95861: LD_INT 1
95863: DEC
95864: ST_TO_ADDR
95865: LD_INT 6
95867: PUSH
95868: FOR_TO
95869: IFFALSE 95974
// begin uc_nation := nation_nature ;
95871: LD_ADDR_OWVAR 21
95875: PUSH
95876: LD_INT 0
95878: ST_TO_ADDR
// uc_side := 0 ;
95879: LD_ADDR_OWVAR 20
95883: PUSH
95884: LD_INT 0
95886: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95887: LD_ADDR_OWVAR 29
95891: PUSH
95892: LD_INT 12
95894: PUSH
95895: LD_INT 12
95897: PUSH
95898: EMPTY
95899: LIST
95900: LIST
95901: ST_TO_ADDR
// hc_agressivity := 20 ;
95902: LD_ADDR_OWVAR 35
95906: PUSH
95907: LD_INT 20
95909: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95910: LD_ADDR_OWVAR 28
95914: PUSH
95915: LD_INT 17
95917: ST_TO_ADDR
// hc_gallery :=  ;
95918: LD_ADDR_OWVAR 33
95922: PUSH
95923: LD_STRING 
95925: ST_TO_ADDR
// hc_name :=  ;
95926: LD_ADDR_OWVAR 26
95930: PUSH
95931: LD_STRING 
95933: ST_TO_ADDR
// un := CreateHuman ;
95934: LD_ADDR_VAR 0 2
95938: PUSH
95939: CALL_OW 44
95943: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95944: LD_VAR 0 2
95948: PPUSH
95949: LD_INT 1
95951: PPUSH
95952: CALL_OW 51
// tmp := tmp ^ un ;
95956: LD_ADDR_VAR 0 3
95960: PUSH
95961: LD_VAR 0 3
95965: PUSH
95966: LD_VAR 0 2
95970: ADD
95971: ST_TO_ADDR
// end ;
95972: GO 95868
95974: POP
95975: POP
// repeat wait ( 0 0$1 ) ;
95976: LD_INT 35
95978: PPUSH
95979: CALL_OW 67
// for un in tmp do
95983: LD_ADDR_VAR 0 2
95987: PUSH
95988: LD_VAR 0 3
95992: PUSH
95993: FOR_IN
95994: IFFALSE 96068
// begin if IsDead ( un ) then
95996: LD_VAR 0 2
96000: PPUSH
96001: CALL_OW 301
96005: IFFALSE 96025
// begin tmp := tmp diff un ;
96007: LD_ADDR_VAR 0 3
96011: PUSH
96012: LD_VAR 0 3
96016: PUSH
96017: LD_VAR 0 2
96021: DIFF
96022: ST_TO_ADDR
// continue ;
96023: GO 95993
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
96025: LD_VAR 0 2
96029: PPUSH
96030: LD_INT 3
96032: PUSH
96033: LD_INT 22
96035: PUSH
96036: LD_INT 0
96038: PUSH
96039: EMPTY
96040: LIST
96041: LIST
96042: PUSH
96043: EMPTY
96044: LIST
96045: LIST
96046: PPUSH
96047: CALL_OW 69
96051: PPUSH
96052: LD_VAR 0 2
96056: PPUSH
96057: CALL_OW 74
96061: PPUSH
96062: CALL_OW 115
// end ;
96066: GO 95993
96068: POP
96069: POP
// until not tmp ;
96070: LD_VAR 0 3
96074: NOT
96075: IFFALSE 95976
// end ;
96077: PPOPN 3
96079: END
// every 0 0$1 trigger StreamModeActive and sTroll do
96080: LD_EXP 113
96084: PUSH
96085: LD_EXP 138
96089: AND
96090: IFFALSE 96144
96092: GO 96094
96094: DISABLE
// begin ToLua ( displayTroll(); ) ;
96095: LD_STRING displayTroll();
96097: PPUSH
96098: CALL_OW 559
// wait ( 3 3$00 ) ;
96102: LD_INT 6300
96104: PPUSH
96105: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96109: LD_STRING hideTroll();
96111: PPUSH
96112: CALL_OW 559
// wait ( 1 1$00 ) ;
96116: LD_INT 2100
96118: PPUSH
96119: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96123: LD_STRING displayTroll();
96125: PPUSH
96126: CALL_OW 559
// wait ( 1 1$00 ) ;
96130: LD_INT 2100
96132: PPUSH
96133: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96137: LD_STRING hideTroll();
96139: PPUSH
96140: CALL_OW 559
// end ;
96144: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96145: LD_EXP 113
96149: PUSH
96150: LD_EXP 139
96154: AND
96155: IFFALSE 96218
96157: GO 96159
96159: DISABLE
96160: LD_INT 0
96162: PPUSH
// begin p := 0 ;
96163: LD_ADDR_VAR 0 1
96167: PUSH
96168: LD_INT 0
96170: ST_TO_ADDR
// repeat game_speed := 1 ;
96171: LD_ADDR_OWVAR 65
96175: PUSH
96176: LD_INT 1
96178: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96179: LD_INT 35
96181: PPUSH
96182: CALL_OW 67
// p := p + 1 ;
96186: LD_ADDR_VAR 0 1
96190: PUSH
96191: LD_VAR 0 1
96195: PUSH
96196: LD_INT 1
96198: PLUS
96199: ST_TO_ADDR
// until p >= 60 ;
96200: LD_VAR 0 1
96204: PUSH
96205: LD_INT 60
96207: GREATEREQUAL
96208: IFFALSE 96171
// game_speed := 4 ;
96210: LD_ADDR_OWVAR 65
96214: PUSH
96215: LD_INT 4
96217: ST_TO_ADDR
// end ;
96218: PPOPN 1
96220: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96221: LD_EXP 113
96225: PUSH
96226: LD_EXP 140
96230: AND
96231: IFFALSE 96377
96233: GO 96235
96235: DISABLE
96236: LD_INT 0
96238: PPUSH
96239: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96240: LD_ADDR_VAR 0 1
96244: PUSH
96245: LD_INT 22
96247: PUSH
96248: LD_OWVAR 2
96252: PUSH
96253: EMPTY
96254: LIST
96255: LIST
96256: PUSH
96257: LD_INT 2
96259: PUSH
96260: LD_INT 30
96262: PUSH
96263: LD_INT 0
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 30
96272: PUSH
96273: LD_INT 1
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: EMPTY
96281: LIST
96282: LIST
96283: LIST
96284: PUSH
96285: EMPTY
96286: LIST
96287: LIST
96288: PPUSH
96289: CALL_OW 69
96293: ST_TO_ADDR
// if not depot then
96294: LD_VAR 0 1
96298: NOT
96299: IFFALSE 96303
// exit ;
96301: GO 96377
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96303: LD_ADDR_VAR 0 2
96307: PUSH
96308: LD_VAR 0 1
96312: PUSH
96313: LD_INT 1
96315: PPUSH
96316: LD_VAR 0 1
96320: PPUSH
96321: CALL_OW 12
96325: ARRAY
96326: PPUSH
96327: CALL_OW 274
96331: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96332: LD_VAR 0 2
96336: PPUSH
96337: LD_INT 1
96339: PPUSH
96340: LD_INT 0
96342: PPUSH
96343: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96347: LD_VAR 0 2
96351: PPUSH
96352: LD_INT 2
96354: PPUSH
96355: LD_INT 0
96357: PPUSH
96358: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96362: LD_VAR 0 2
96366: PPUSH
96367: LD_INT 3
96369: PPUSH
96370: LD_INT 0
96372: PPUSH
96373: CALL_OW 277
// end ;
96377: PPOPN 2
96379: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96380: LD_EXP 113
96384: PUSH
96385: LD_EXP 141
96389: AND
96390: IFFALSE 96487
96392: GO 96394
96394: DISABLE
96395: LD_INT 0
96397: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96398: LD_ADDR_VAR 0 1
96402: PUSH
96403: LD_INT 22
96405: PUSH
96406: LD_OWVAR 2
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PUSH
96415: LD_INT 21
96417: PUSH
96418: LD_INT 1
96420: PUSH
96421: EMPTY
96422: LIST
96423: LIST
96424: PUSH
96425: LD_INT 3
96427: PUSH
96428: LD_INT 23
96430: PUSH
96431: LD_INT 0
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: PUSH
96438: EMPTY
96439: LIST
96440: LIST
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: LIST
96446: PPUSH
96447: CALL_OW 69
96451: ST_TO_ADDR
// if not tmp then
96452: LD_VAR 0 1
96456: NOT
96457: IFFALSE 96461
// exit ;
96459: GO 96487
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96461: LD_VAR 0 1
96465: PUSH
96466: LD_INT 1
96468: PPUSH
96469: LD_VAR 0 1
96473: PPUSH
96474: CALL_OW 12
96478: ARRAY
96479: PPUSH
96480: LD_INT 200
96482: PPUSH
96483: CALL_OW 234
// end ;
96487: PPOPN 1
96489: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96490: LD_EXP 113
96494: PUSH
96495: LD_EXP 142
96499: AND
96500: IFFALSE 96579
96502: GO 96504
96504: DISABLE
96505: LD_INT 0
96507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
96508: LD_ADDR_VAR 0 1
96512: PUSH
96513: LD_INT 22
96515: PUSH
96516: LD_OWVAR 2
96520: PUSH
96521: EMPTY
96522: LIST
96523: LIST
96524: PUSH
96525: LD_INT 21
96527: PUSH
96528: LD_INT 2
96530: PUSH
96531: EMPTY
96532: LIST
96533: LIST
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PPUSH
96539: CALL_OW 69
96543: ST_TO_ADDR
// if not tmp then
96544: LD_VAR 0 1
96548: NOT
96549: IFFALSE 96553
// exit ;
96551: GO 96579
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96553: LD_VAR 0 1
96557: PUSH
96558: LD_INT 1
96560: PPUSH
96561: LD_VAR 0 1
96565: PPUSH
96566: CALL_OW 12
96570: ARRAY
96571: PPUSH
96572: LD_INT 60
96574: PPUSH
96575: CALL_OW 234
// end ;
96579: PPOPN 1
96581: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96582: LD_EXP 113
96586: PUSH
96587: LD_EXP 143
96591: AND
96592: IFFALSE 96691
96594: GO 96596
96596: DISABLE
96597: LD_INT 0
96599: PPUSH
96600: PPUSH
// begin enable ;
96601: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96602: LD_ADDR_VAR 0 1
96606: PUSH
96607: LD_INT 22
96609: PUSH
96610: LD_OWVAR 2
96614: PUSH
96615: EMPTY
96616: LIST
96617: LIST
96618: PUSH
96619: LD_INT 61
96621: PUSH
96622: EMPTY
96623: LIST
96624: PUSH
96625: LD_INT 33
96627: PUSH
96628: LD_INT 2
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: EMPTY
96636: LIST
96637: LIST
96638: LIST
96639: PPUSH
96640: CALL_OW 69
96644: ST_TO_ADDR
// if not tmp then
96645: LD_VAR 0 1
96649: NOT
96650: IFFALSE 96654
// exit ;
96652: GO 96691
// for i in tmp do
96654: LD_ADDR_VAR 0 2
96658: PUSH
96659: LD_VAR 0 1
96663: PUSH
96664: FOR_IN
96665: IFFALSE 96689
// if IsControledBy ( i ) then
96667: LD_VAR 0 2
96671: PPUSH
96672: CALL_OW 312
96676: IFFALSE 96687
// ComUnlink ( i ) ;
96678: LD_VAR 0 2
96682: PPUSH
96683: CALL_OW 136
96687: GO 96664
96689: POP
96690: POP
// end ;
96691: PPOPN 2
96693: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96694: LD_EXP 113
96698: PUSH
96699: LD_EXP 144
96703: AND
96704: IFFALSE 96844
96706: GO 96708
96708: DISABLE
96709: LD_INT 0
96711: PPUSH
96712: PPUSH
// begin ToLua ( displayPowell(); ) ;
96713: LD_STRING displayPowell();
96715: PPUSH
96716: CALL_OW 559
// uc_side := 0 ;
96720: LD_ADDR_OWVAR 20
96724: PUSH
96725: LD_INT 0
96727: ST_TO_ADDR
// uc_nation := 2 ;
96728: LD_ADDR_OWVAR 21
96732: PUSH
96733: LD_INT 2
96735: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96736: LD_ADDR_OWVAR 37
96740: PUSH
96741: LD_INT 14
96743: ST_TO_ADDR
// vc_engine := engine_siberite ;
96744: LD_ADDR_OWVAR 39
96748: PUSH
96749: LD_INT 3
96751: ST_TO_ADDR
// vc_control := control_apeman ;
96752: LD_ADDR_OWVAR 38
96756: PUSH
96757: LD_INT 5
96759: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96760: LD_ADDR_OWVAR 40
96764: PUSH
96765: LD_INT 29
96767: ST_TO_ADDR
// un := CreateVehicle ;
96768: LD_ADDR_VAR 0 2
96772: PUSH
96773: CALL_OW 45
96777: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96778: LD_VAR 0 2
96782: PPUSH
96783: LD_INT 1
96785: PPUSH
96786: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96790: LD_INT 35
96792: PPUSH
96793: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96797: LD_VAR 0 2
96801: PPUSH
96802: LD_INT 22
96804: PUSH
96805: LD_OWVAR 2
96809: PUSH
96810: EMPTY
96811: LIST
96812: LIST
96813: PPUSH
96814: CALL_OW 69
96818: PPUSH
96819: LD_VAR 0 2
96823: PPUSH
96824: CALL_OW 74
96828: PPUSH
96829: CALL_OW 115
// until IsDead ( un ) ;
96833: LD_VAR 0 2
96837: PPUSH
96838: CALL_OW 301
96842: IFFALSE 96790
// end ;
96844: PPOPN 2
96846: END
// every 0 0$1 trigger StreamModeActive and sStu do
96847: LD_EXP 113
96851: PUSH
96852: LD_EXP 152
96856: AND
96857: IFFALSE 96873
96859: GO 96861
96861: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96862: LD_STRING displayStucuk();
96864: PPUSH
96865: CALL_OW 559
// ResetFog ;
96869: CALL_OW 335
// end ;
96873: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96874: LD_EXP 113
96878: PUSH
96879: LD_EXP 145
96883: AND
96884: IFFALSE 97025
96886: GO 96888
96888: DISABLE
96889: LD_INT 0
96891: PPUSH
96892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96893: LD_ADDR_VAR 0 2
96897: PUSH
96898: LD_INT 22
96900: PUSH
96901: LD_OWVAR 2
96905: PUSH
96906: EMPTY
96907: LIST
96908: LIST
96909: PUSH
96910: LD_INT 21
96912: PUSH
96913: LD_INT 1
96915: PUSH
96916: EMPTY
96917: LIST
96918: LIST
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: PPUSH
96924: CALL_OW 69
96928: ST_TO_ADDR
// if not tmp then
96929: LD_VAR 0 2
96933: NOT
96934: IFFALSE 96938
// exit ;
96936: GO 97025
// un := tmp [ rand ( 1 , tmp ) ] ;
96938: LD_ADDR_VAR 0 1
96942: PUSH
96943: LD_VAR 0 2
96947: PUSH
96948: LD_INT 1
96950: PPUSH
96951: LD_VAR 0 2
96955: PPUSH
96956: CALL_OW 12
96960: ARRAY
96961: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96962: LD_VAR 0 1
96966: PPUSH
96967: LD_INT 0
96969: PPUSH
96970: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96974: LD_VAR 0 1
96978: PPUSH
96979: LD_OWVAR 3
96983: PUSH
96984: LD_VAR 0 1
96988: DIFF
96989: PPUSH
96990: LD_VAR 0 1
96994: PPUSH
96995: CALL_OW 74
96999: PPUSH
97000: CALL_OW 115
// wait ( 0 0$20 ) ;
97004: LD_INT 700
97006: PPUSH
97007: CALL_OW 67
// SetSide ( un , your_side ) ;
97011: LD_VAR 0 1
97015: PPUSH
97016: LD_OWVAR 2
97020: PPUSH
97021: CALL_OW 235
// end ;
97025: PPOPN 2
97027: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
97028: LD_EXP 113
97032: PUSH
97033: LD_EXP 146
97037: AND
97038: IFFALSE 97144
97040: GO 97042
97042: DISABLE
97043: LD_INT 0
97045: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97046: LD_ADDR_VAR 0 1
97050: PUSH
97051: LD_INT 22
97053: PUSH
97054: LD_OWVAR 2
97058: PUSH
97059: EMPTY
97060: LIST
97061: LIST
97062: PUSH
97063: LD_INT 2
97065: PUSH
97066: LD_INT 30
97068: PUSH
97069: LD_INT 0
97071: PUSH
97072: EMPTY
97073: LIST
97074: LIST
97075: PUSH
97076: LD_INT 30
97078: PUSH
97079: LD_INT 1
97081: PUSH
97082: EMPTY
97083: LIST
97084: LIST
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: LIST
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: PPUSH
97095: CALL_OW 69
97099: ST_TO_ADDR
// if not depot then
97100: LD_VAR 0 1
97104: NOT
97105: IFFALSE 97109
// exit ;
97107: GO 97144
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97109: LD_VAR 0 1
97113: PUSH
97114: LD_INT 1
97116: ARRAY
97117: PPUSH
97118: CALL_OW 250
97122: PPUSH
97123: LD_VAR 0 1
97127: PUSH
97128: LD_INT 1
97130: ARRAY
97131: PPUSH
97132: CALL_OW 251
97136: PPUSH
97137: LD_INT 70
97139: PPUSH
97140: CALL_OW 495
// end ;
97144: PPOPN 1
97146: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97147: LD_EXP 113
97151: PUSH
97152: LD_EXP 147
97156: AND
97157: IFFALSE 97368
97159: GO 97161
97161: DISABLE
97162: LD_INT 0
97164: PPUSH
97165: PPUSH
97166: PPUSH
97167: PPUSH
97168: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97169: LD_ADDR_VAR 0 5
97173: PUSH
97174: LD_INT 22
97176: PUSH
97177: LD_OWVAR 2
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: LD_INT 21
97188: PUSH
97189: LD_INT 1
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: EMPTY
97197: LIST
97198: LIST
97199: PPUSH
97200: CALL_OW 69
97204: ST_TO_ADDR
// if not tmp then
97205: LD_VAR 0 5
97209: NOT
97210: IFFALSE 97214
// exit ;
97212: GO 97368
// for i in tmp do
97214: LD_ADDR_VAR 0 1
97218: PUSH
97219: LD_VAR 0 5
97223: PUSH
97224: FOR_IN
97225: IFFALSE 97366
// begin d := rand ( 0 , 5 ) ;
97227: LD_ADDR_VAR 0 4
97231: PUSH
97232: LD_INT 0
97234: PPUSH
97235: LD_INT 5
97237: PPUSH
97238: CALL_OW 12
97242: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97243: LD_ADDR_VAR 0 2
97247: PUSH
97248: LD_VAR 0 1
97252: PPUSH
97253: CALL_OW 250
97257: PPUSH
97258: LD_VAR 0 4
97262: PPUSH
97263: LD_INT 3
97265: PPUSH
97266: LD_INT 12
97268: PPUSH
97269: CALL_OW 12
97273: PPUSH
97274: CALL_OW 272
97278: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97279: LD_ADDR_VAR 0 3
97283: PUSH
97284: LD_VAR 0 1
97288: PPUSH
97289: CALL_OW 251
97293: PPUSH
97294: LD_VAR 0 4
97298: PPUSH
97299: LD_INT 3
97301: PPUSH
97302: LD_INT 12
97304: PPUSH
97305: CALL_OW 12
97309: PPUSH
97310: CALL_OW 273
97314: ST_TO_ADDR
// if ValidHex ( x , y ) then
97315: LD_VAR 0 2
97319: PPUSH
97320: LD_VAR 0 3
97324: PPUSH
97325: CALL_OW 488
97329: IFFALSE 97364
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97331: LD_VAR 0 1
97335: PPUSH
97336: LD_VAR 0 2
97340: PPUSH
97341: LD_VAR 0 3
97345: PPUSH
97346: LD_INT 3
97348: PPUSH
97349: LD_INT 6
97351: PPUSH
97352: CALL_OW 12
97356: PPUSH
97357: LD_INT 1
97359: PPUSH
97360: CALL_OW 483
// end ;
97364: GO 97224
97366: POP
97367: POP
// end ;
97368: PPOPN 5
97370: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97371: LD_EXP 113
97375: PUSH
97376: LD_EXP 148
97380: AND
97381: IFFALSE 97475
97383: GO 97385
97385: DISABLE
97386: LD_INT 0
97388: PPUSH
97389: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97390: LD_ADDR_VAR 0 2
97394: PUSH
97395: LD_INT 22
97397: PUSH
97398: LD_OWVAR 2
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 32
97409: PUSH
97410: LD_INT 1
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 21
97419: PUSH
97420: LD_INT 2
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: PUSH
97427: EMPTY
97428: LIST
97429: LIST
97430: LIST
97431: PPUSH
97432: CALL_OW 69
97436: ST_TO_ADDR
// if not tmp then
97437: LD_VAR 0 2
97441: NOT
97442: IFFALSE 97446
// exit ;
97444: GO 97475
// for i in tmp do
97446: LD_ADDR_VAR 0 1
97450: PUSH
97451: LD_VAR 0 2
97455: PUSH
97456: FOR_IN
97457: IFFALSE 97473
// SetFuel ( i , 0 ) ;
97459: LD_VAR 0 1
97463: PPUSH
97464: LD_INT 0
97466: PPUSH
97467: CALL_OW 240
97471: GO 97456
97473: POP
97474: POP
// end ;
97475: PPOPN 2
97477: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97478: LD_EXP 113
97482: PUSH
97483: LD_EXP 149
97487: AND
97488: IFFALSE 97554
97490: GO 97492
97492: DISABLE
97493: LD_INT 0
97495: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97496: LD_ADDR_VAR 0 1
97500: PUSH
97501: LD_INT 22
97503: PUSH
97504: LD_OWVAR 2
97508: PUSH
97509: EMPTY
97510: LIST
97511: LIST
97512: PUSH
97513: LD_INT 30
97515: PUSH
97516: LD_INT 29
97518: PUSH
97519: EMPTY
97520: LIST
97521: LIST
97522: PUSH
97523: EMPTY
97524: LIST
97525: LIST
97526: PPUSH
97527: CALL_OW 69
97531: ST_TO_ADDR
// if not tmp then
97532: LD_VAR 0 1
97536: NOT
97537: IFFALSE 97541
// exit ;
97539: GO 97554
// DestroyUnit ( tmp [ 1 ] ) ;
97541: LD_VAR 0 1
97545: PUSH
97546: LD_INT 1
97548: ARRAY
97549: PPUSH
97550: CALL_OW 65
// end ;
97554: PPOPN 1
97556: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97557: LD_EXP 113
97561: PUSH
97562: LD_EXP 151
97566: AND
97567: IFFALSE 97696
97569: GO 97571
97571: DISABLE
97572: LD_INT 0
97574: PPUSH
// begin uc_side := 0 ;
97575: LD_ADDR_OWVAR 20
97579: PUSH
97580: LD_INT 0
97582: ST_TO_ADDR
// uc_nation := nation_arabian ;
97583: LD_ADDR_OWVAR 21
97587: PUSH
97588: LD_INT 2
97590: ST_TO_ADDR
// hc_gallery :=  ;
97591: LD_ADDR_OWVAR 33
97595: PUSH
97596: LD_STRING 
97598: ST_TO_ADDR
// hc_name :=  ;
97599: LD_ADDR_OWVAR 26
97603: PUSH
97604: LD_STRING 
97606: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97607: LD_INT 1
97609: PPUSH
97610: LD_INT 11
97612: PPUSH
97613: LD_INT 10
97615: PPUSH
97616: CALL_OW 380
// un := CreateHuman ;
97620: LD_ADDR_VAR 0 1
97624: PUSH
97625: CALL_OW 44
97629: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97630: LD_VAR 0 1
97634: PPUSH
97635: LD_INT 1
97637: PPUSH
97638: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97642: LD_INT 35
97644: PPUSH
97645: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97649: LD_VAR 0 1
97653: PPUSH
97654: LD_INT 22
97656: PUSH
97657: LD_OWVAR 2
97661: PUSH
97662: EMPTY
97663: LIST
97664: LIST
97665: PPUSH
97666: CALL_OW 69
97670: PPUSH
97671: LD_VAR 0 1
97675: PPUSH
97676: CALL_OW 74
97680: PPUSH
97681: CALL_OW 115
// until IsDead ( un ) ;
97685: LD_VAR 0 1
97689: PPUSH
97690: CALL_OW 301
97694: IFFALSE 97642
// end ;
97696: PPOPN 1
97698: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97699: LD_EXP 113
97703: PUSH
97704: LD_EXP 153
97708: AND
97709: IFFALSE 97721
97711: GO 97713
97713: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97714: LD_STRING earthquake(getX(game), 0, 32)
97716: PPUSH
97717: CALL_OW 559
97721: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97722: LD_EXP 113
97726: PUSH
97727: LD_EXP 154
97731: AND
97732: IFFALSE 97823
97734: GO 97736
97736: DISABLE
97737: LD_INT 0
97739: PPUSH
// begin enable ;
97740: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97741: LD_ADDR_VAR 0 1
97745: PUSH
97746: LD_INT 22
97748: PUSH
97749: LD_OWVAR 2
97753: PUSH
97754: EMPTY
97755: LIST
97756: LIST
97757: PUSH
97758: LD_INT 21
97760: PUSH
97761: LD_INT 2
97763: PUSH
97764: EMPTY
97765: LIST
97766: LIST
97767: PUSH
97768: LD_INT 33
97770: PUSH
97771: LD_INT 3
97773: PUSH
97774: EMPTY
97775: LIST
97776: LIST
97777: PUSH
97778: EMPTY
97779: LIST
97780: LIST
97781: LIST
97782: PPUSH
97783: CALL_OW 69
97787: ST_TO_ADDR
// if not tmp then
97788: LD_VAR 0 1
97792: NOT
97793: IFFALSE 97797
// exit ;
97795: GO 97823
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97797: LD_VAR 0 1
97801: PUSH
97802: LD_INT 1
97804: PPUSH
97805: LD_VAR 0 1
97809: PPUSH
97810: CALL_OW 12
97814: ARRAY
97815: PPUSH
97816: LD_INT 1
97818: PPUSH
97819: CALL_OW 234
// end ;
97823: PPOPN 1
97825: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97826: LD_EXP 113
97830: PUSH
97831: LD_EXP 155
97835: AND
97836: IFFALSE 97977
97838: GO 97840
97840: DISABLE
97841: LD_INT 0
97843: PPUSH
97844: PPUSH
97845: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97846: LD_ADDR_VAR 0 3
97850: PUSH
97851: LD_INT 22
97853: PUSH
97854: LD_OWVAR 2
97858: PUSH
97859: EMPTY
97860: LIST
97861: LIST
97862: PUSH
97863: LD_INT 25
97865: PUSH
97866: LD_INT 1
97868: PUSH
97869: EMPTY
97870: LIST
97871: LIST
97872: PUSH
97873: EMPTY
97874: LIST
97875: LIST
97876: PPUSH
97877: CALL_OW 69
97881: ST_TO_ADDR
// if not tmp then
97882: LD_VAR 0 3
97886: NOT
97887: IFFALSE 97891
// exit ;
97889: GO 97977
// un := tmp [ rand ( 1 , tmp ) ] ;
97891: LD_ADDR_VAR 0 2
97895: PUSH
97896: LD_VAR 0 3
97900: PUSH
97901: LD_INT 1
97903: PPUSH
97904: LD_VAR 0 3
97908: PPUSH
97909: CALL_OW 12
97913: ARRAY
97914: ST_TO_ADDR
// if Crawls ( un ) then
97915: LD_VAR 0 2
97919: PPUSH
97920: CALL_OW 318
97924: IFFALSE 97935
// ComWalk ( un ) ;
97926: LD_VAR 0 2
97930: PPUSH
97931: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97935: LD_VAR 0 2
97939: PPUSH
97940: LD_INT 9
97942: PPUSH
97943: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97947: LD_INT 28
97949: PPUSH
97950: LD_OWVAR 2
97954: PPUSH
97955: LD_INT 2
97957: PPUSH
97958: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97962: LD_INT 29
97964: PPUSH
97965: LD_OWVAR 2
97969: PPUSH
97970: LD_INT 2
97972: PPUSH
97973: CALL_OW 322
// end ;
97977: PPOPN 3
97979: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97980: LD_EXP 113
97984: PUSH
97985: LD_EXP 156
97989: AND
97990: IFFALSE 98101
97992: GO 97994
97994: DISABLE
97995: LD_INT 0
97997: PPUSH
97998: PPUSH
97999: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98000: LD_ADDR_VAR 0 3
98004: PUSH
98005: LD_INT 22
98007: PUSH
98008: LD_OWVAR 2
98012: PUSH
98013: EMPTY
98014: LIST
98015: LIST
98016: PUSH
98017: LD_INT 25
98019: PUSH
98020: LD_INT 1
98022: PUSH
98023: EMPTY
98024: LIST
98025: LIST
98026: PUSH
98027: EMPTY
98028: LIST
98029: LIST
98030: PPUSH
98031: CALL_OW 69
98035: ST_TO_ADDR
// if not tmp then
98036: LD_VAR 0 3
98040: NOT
98041: IFFALSE 98045
// exit ;
98043: GO 98101
// un := tmp [ rand ( 1 , tmp ) ] ;
98045: LD_ADDR_VAR 0 2
98049: PUSH
98050: LD_VAR 0 3
98054: PUSH
98055: LD_INT 1
98057: PPUSH
98058: LD_VAR 0 3
98062: PPUSH
98063: CALL_OW 12
98067: ARRAY
98068: ST_TO_ADDR
// if Crawls ( un ) then
98069: LD_VAR 0 2
98073: PPUSH
98074: CALL_OW 318
98078: IFFALSE 98089
// ComWalk ( un ) ;
98080: LD_VAR 0 2
98084: PPUSH
98085: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98089: LD_VAR 0 2
98093: PPUSH
98094: LD_INT 8
98096: PPUSH
98097: CALL_OW 336
// end ;
98101: PPOPN 3
98103: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
98104: LD_EXP 113
98108: PUSH
98109: LD_EXP 157
98113: AND
98114: IFFALSE 98258
98116: GO 98118
98118: DISABLE
98119: LD_INT 0
98121: PPUSH
98122: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98123: LD_ADDR_VAR 0 2
98127: PUSH
98128: LD_INT 22
98130: PUSH
98131: LD_OWVAR 2
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PUSH
98140: LD_INT 21
98142: PUSH
98143: LD_INT 2
98145: PUSH
98146: EMPTY
98147: LIST
98148: LIST
98149: PUSH
98150: LD_INT 2
98152: PUSH
98153: LD_INT 34
98155: PUSH
98156: LD_INT 12
98158: PUSH
98159: EMPTY
98160: LIST
98161: LIST
98162: PUSH
98163: LD_INT 34
98165: PUSH
98166: LD_INT 51
98168: PUSH
98169: EMPTY
98170: LIST
98171: LIST
98172: PUSH
98173: LD_INT 34
98175: PUSH
98176: LD_INT 32
98178: PUSH
98179: EMPTY
98180: LIST
98181: LIST
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: PUSH
98189: EMPTY
98190: LIST
98191: LIST
98192: LIST
98193: PPUSH
98194: CALL_OW 69
98198: ST_TO_ADDR
// if not tmp then
98199: LD_VAR 0 2
98203: NOT
98204: IFFALSE 98208
// exit ;
98206: GO 98258
// for i in tmp do
98208: LD_ADDR_VAR 0 1
98212: PUSH
98213: LD_VAR 0 2
98217: PUSH
98218: FOR_IN
98219: IFFALSE 98256
// if GetCargo ( i , mat_artifact ) = 0 then
98221: LD_VAR 0 1
98225: PPUSH
98226: LD_INT 4
98228: PPUSH
98229: CALL_OW 289
98233: PUSH
98234: LD_INT 0
98236: EQUAL
98237: IFFALSE 98254
// SetCargo ( i , mat_siberit , 100 ) ;
98239: LD_VAR 0 1
98243: PPUSH
98244: LD_INT 3
98246: PPUSH
98247: LD_INT 100
98249: PPUSH
98250: CALL_OW 290
98254: GO 98218
98256: POP
98257: POP
// end ;
98258: PPOPN 2
98260: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98261: LD_EXP 113
98265: PUSH
98266: LD_EXP 158
98270: AND
98271: IFFALSE 98454
98273: GO 98275
98275: DISABLE
98276: LD_INT 0
98278: PPUSH
98279: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98280: LD_ADDR_VAR 0 2
98284: PUSH
98285: LD_INT 22
98287: PUSH
98288: LD_OWVAR 2
98292: PUSH
98293: EMPTY
98294: LIST
98295: LIST
98296: PPUSH
98297: CALL_OW 69
98301: ST_TO_ADDR
// if not tmp then
98302: LD_VAR 0 2
98306: NOT
98307: IFFALSE 98311
// exit ;
98309: GO 98454
// for i := 1 to 2 do
98311: LD_ADDR_VAR 0 1
98315: PUSH
98316: DOUBLE
98317: LD_INT 1
98319: DEC
98320: ST_TO_ADDR
98321: LD_INT 2
98323: PUSH
98324: FOR_TO
98325: IFFALSE 98452
// begin uc_side := your_side ;
98327: LD_ADDR_OWVAR 20
98331: PUSH
98332: LD_OWVAR 2
98336: ST_TO_ADDR
// uc_nation := nation_american ;
98337: LD_ADDR_OWVAR 21
98341: PUSH
98342: LD_INT 1
98344: ST_TO_ADDR
// vc_chassis := us_morphling ;
98345: LD_ADDR_OWVAR 37
98349: PUSH
98350: LD_INT 5
98352: ST_TO_ADDR
// vc_engine := engine_siberite ;
98353: LD_ADDR_OWVAR 39
98357: PUSH
98358: LD_INT 3
98360: ST_TO_ADDR
// vc_control := control_computer ;
98361: LD_ADDR_OWVAR 38
98365: PUSH
98366: LD_INT 3
98368: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98369: LD_ADDR_OWVAR 40
98373: PUSH
98374: LD_INT 10
98376: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98377: LD_VAR 0 2
98381: PUSH
98382: LD_INT 1
98384: ARRAY
98385: PPUSH
98386: CALL_OW 310
98390: NOT
98391: IFFALSE 98438
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98393: CALL_OW 45
98397: PPUSH
98398: LD_VAR 0 2
98402: PUSH
98403: LD_INT 1
98405: ARRAY
98406: PPUSH
98407: CALL_OW 250
98411: PPUSH
98412: LD_VAR 0 2
98416: PUSH
98417: LD_INT 1
98419: ARRAY
98420: PPUSH
98421: CALL_OW 251
98425: PPUSH
98426: LD_INT 12
98428: PPUSH
98429: LD_INT 1
98431: PPUSH
98432: CALL_OW 50
98436: GO 98450
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98438: CALL_OW 45
98442: PPUSH
98443: LD_INT 1
98445: PPUSH
98446: CALL_OW 51
// end ;
98450: GO 98324
98452: POP
98453: POP
// end ;
98454: PPOPN 2
98456: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98457: LD_EXP 113
98461: PUSH
98462: LD_EXP 159
98466: AND
98467: IFFALSE 98689
98469: GO 98471
98471: DISABLE
98472: LD_INT 0
98474: PPUSH
98475: PPUSH
98476: PPUSH
98477: PPUSH
98478: PPUSH
98479: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98480: LD_ADDR_VAR 0 6
98484: PUSH
98485: LD_INT 22
98487: PUSH
98488: LD_OWVAR 2
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: PUSH
98497: LD_INT 21
98499: PUSH
98500: LD_INT 1
98502: PUSH
98503: EMPTY
98504: LIST
98505: LIST
98506: PUSH
98507: LD_INT 3
98509: PUSH
98510: LD_INT 23
98512: PUSH
98513: LD_INT 0
98515: PUSH
98516: EMPTY
98517: LIST
98518: LIST
98519: PUSH
98520: EMPTY
98521: LIST
98522: LIST
98523: PUSH
98524: EMPTY
98525: LIST
98526: LIST
98527: LIST
98528: PPUSH
98529: CALL_OW 69
98533: ST_TO_ADDR
// if not tmp then
98534: LD_VAR 0 6
98538: NOT
98539: IFFALSE 98543
// exit ;
98541: GO 98689
// s1 := rand ( 1 , 4 ) ;
98543: LD_ADDR_VAR 0 2
98547: PUSH
98548: LD_INT 1
98550: PPUSH
98551: LD_INT 4
98553: PPUSH
98554: CALL_OW 12
98558: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98559: LD_ADDR_VAR 0 4
98563: PUSH
98564: LD_VAR 0 6
98568: PUSH
98569: LD_INT 1
98571: ARRAY
98572: PPUSH
98573: LD_VAR 0 2
98577: PPUSH
98578: CALL_OW 259
98582: ST_TO_ADDR
// if s1 = 1 then
98583: LD_VAR 0 2
98587: PUSH
98588: LD_INT 1
98590: EQUAL
98591: IFFALSE 98611
// s2 := rand ( 2 , 4 ) else
98593: LD_ADDR_VAR 0 3
98597: PUSH
98598: LD_INT 2
98600: PPUSH
98601: LD_INT 4
98603: PPUSH
98604: CALL_OW 12
98608: ST_TO_ADDR
98609: GO 98619
// s2 := 1 ;
98611: LD_ADDR_VAR 0 3
98615: PUSH
98616: LD_INT 1
98618: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98619: LD_ADDR_VAR 0 5
98623: PUSH
98624: LD_VAR 0 6
98628: PUSH
98629: LD_INT 1
98631: ARRAY
98632: PPUSH
98633: LD_VAR 0 3
98637: PPUSH
98638: CALL_OW 259
98642: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98643: LD_VAR 0 6
98647: PUSH
98648: LD_INT 1
98650: ARRAY
98651: PPUSH
98652: LD_VAR 0 2
98656: PPUSH
98657: LD_VAR 0 5
98661: PPUSH
98662: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98666: LD_VAR 0 6
98670: PUSH
98671: LD_INT 1
98673: ARRAY
98674: PPUSH
98675: LD_VAR 0 3
98679: PPUSH
98680: LD_VAR 0 4
98684: PPUSH
98685: CALL_OW 237
// end ;
98689: PPOPN 6
98691: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98692: LD_EXP 113
98696: PUSH
98697: LD_EXP 160
98701: AND
98702: IFFALSE 98781
98704: GO 98706
98706: DISABLE
98707: LD_INT 0
98709: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98710: LD_ADDR_VAR 0 1
98714: PUSH
98715: LD_INT 22
98717: PUSH
98718: LD_OWVAR 2
98722: PUSH
98723: EMPTY
98724: LIST
98725: LIST
98726: PUSH
98727: LD_INT 30
98729: PUSH
98730: LD_INT 3
98732: PUSH
98733: EMPTY
98734: LIST
98735: LIST
98736: PUSH
98737: EMPTY
98738: LIST
98739: LIST
98740: PPUSH
98741: CALL_OW 69
98745: ST_TO_ADDR
// if not tmp then
98746: LD_VAR 0 1
98750: NOT
98751: IFFALSE 98755
// exit ;
98753: GO 98781
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98755: LD_VAR 0 1
98759: PUSH
98760: LD_INT 1
98762: PPUSH
98763: LD_VAR 0 1
98767: PPUSH
98768: CALL_OW 12
98772: ARRAY
98773: PPUSH
98774: LD_INT 1
98776: PPUSH
98777: CALL_OW 234
// end ;
98781: PPOPN 1
98783: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98784: LD_EXP 113
98788: PUSH
98789: LD_EXP 161
98793: AND
98794: IFFALSE 98906
98796: GO 98798
98798: DISABLE
98799: LD_INT 0
98801: PPUSH
98802: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98803: LD_ADDR_VAR 0 2
98807: PUSH
98808: LD_INT 22
98810: PUSH
98811: LD_OWVAR 2
98815: PUSH
98816: EMPTY
98817: LIST
98818: LIST
98819: PUSH
98820: LD_INT 2
98822: PUSH
98823: LD_INT 30
98825: PUSH
98826: LD_INT 27
98828: PUSH
98829: EMPTY
98830: LIST
98831: LIST
98832: PUSH
98833: LD_INT 30
98835: PUSH
98836: LD_INT 26
98838: PUSH
98839: EMPTY
98840: LIST
98841: LIST
98842: PUSH
98843: LD_INT 30
98845: PUSH
98846: LD_INT 28
98848: PUSH
98849: EMPTY
98850: LIST
98851: LIST
98852: PUSH
98853: EMPTY
98854: LIST
98855: LIST
98856: LIST
98857: LIST
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: PPUSH
98863: CALL_OW 69
98867: ST_TO_ADDR
// if not tmp then
98868: LD_VAR 0 2
98872: NOT
98873: IFFALSE 98877
// exit ;
98875: GO 98906
// for i in tmp do
98877: LD_ADDR_VAR 0 1
98881: PUSH
98882: LD_VAR 0 2
98886: PUSH
98887: FOR_IN
98888: IFFALSE 98904
// SetLives ( i , 1 ) ;
98890: LD_VAR 0 1
98894: PPUSH
98895: LD_INT 1
98897: PPUSH
98898: CALL_OW 234
98902: GO 98887
98904: POP
98905: POP
// end ;
98906: PPOPN 2
98908: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98909: LD_EXP 113
98913: PUSH
98914: LD_EXP 162
98918: AND
98919: IFFALSE 99193
98921: GO 98923
98923: DISABLE
98924: LD_INT 0
98926: PPUSH
98927: PPUSH
98928: PPUSH
// begin i := rand ( 1 , 7 ) ;
98929: LD_ADDR_VAR 0 1
98933: PUSH
98934: LD_INT 1
98936: PPUSH
98937: LD_INT 7
98939: PPUSH
98940: CALL_OW 12
98944: ST_TO_ADDR
// case i of 1 :
98945: LD_VAR 0 1
98949: PUSH
98950: LD_INT 1
98952: DOUBLE
98953: EQUAL
98954: IFTRUE 98958
98956: GO 98968
98958: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98959: LD_STRING earthquake(getX(game), 0, 32)
98961: PPUSH
98962: CALL_OW 559
98966: GO 99193
98968: LD_INT 2
98970: DOUBLE
98971: EQUAL
98972: IFTRUE 98976
98974: GO 98990
98976: POP
// begin ToLua ( displayStucuk(); ) ;
98977: LD_STRING displayStucuk();
98979: PPUSH
98980: CALL_OW 559
// ResetFog ;
98984: CALL_OW 335
// end ; 3 :
98988: GO 99193
98990: LD_INT 3
98992: DOUBLE
98993: EQUAL
98994: IFTRUE 98998
98996: GO 99102
98998: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98999: LD_ADDR_VAR 0 2
99003: PUSH
99004: LD_INT 22
99006: PUSH
99007: LD_OWVAR 2
99011: PUSH
99012: EMPTY
99013: LIST
99014: LIST
99015: PUSH
99016: LD_INT 25
99018: PUSH
99019: LD_INT 1
99021: PUSH
99022: EMPTY
99023: LIST
99024: LIST
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: PPUSH
99030: CALL_OW 69
99034: ST_TO_ADDR
// if not tmp then
99035: LD_VAR 0 2
99039: NOT
99040: IFFALSE 99044
// exit ;
99042: GO 99193
// un := tmp [ rand ( 1 , tmp ) ] ;
99044: LD_ADDR_VAR 0 3
99048: PUSH
99049: LD_VAR 0 2
99053: PUSH
99054: LD_INT 1
99056: PPUSH
99057: LD_VAR 0 2
99061: PPUSH
99062: CALL_OW 12
99066: ARRAY
99067: ST_TO_ADDR
// if Crawls ( un ) then
99068: LD_VAR 0 3
99072: PPUSH
99073: CALL_OW 318
99077: IFFALSE 99088
// ComWalk ( un ) ;
99079: LD_VAR 0 3
99083: PPUSH
99084: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99088: LD_VAR 0 3
99092: PPUSH
99093: LD_INT 8
99095: PPUSH
99096: CALL_OW 336
// end ; 4 :
99100: GO 99193
99102: LD_INT 4
99104: DOUBLE
99105: EQUAL
99106: IFTRUE 99110
99108: GO 99171
99110: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99111: LD_ADDR_VAR 0 2
99115: PUSH
99116: LD_INT 22
99118: PUSH
99119: LD_OWVAR 2
99123: PUSH
99124: EMPTY
99125: LIST
99126: LIST
99127: PUSH
99128: LD_INT 30
99130: PUSH
99131: LD_INT 29
99133: PUSH
99134: EMPTY
99135: LIST
99136: LIST
99137: PUSH
99138: EMPTY
99139: LIST
99140: LIST
99141: PPUSH
99142: CALL_OW 69
99146: ST_TO_ADDR
// if not tmp then
99147: LD_VAR 0 2
99151: NOT
99152: IFFALSE 99156
// exit ;
99154: GO 99193
// DestroyUnit ( tmp [ 1 ] ) ;
99156: LD_VAR 0 2
99160: PUSH
99161: LD_INT 1
99163: ARRAY
99164: PPUSH
99165: CALL_OW 65
// end ; 5 .. 7 :
99169: GO 99193
99171: LD_INT 5
99173: DOUBLE
99174: GREATEREQUAL
99175: IFFALSE 99183
99177: LD_INT 7
99179: DOUBLE
99180: LESSEQUAL
99181: IFTRUE 99185
99183: GO 99192
99185: POP
// StreamSibBomb ; end ;
99186: CALL 95443 0 0
99190: GO 99193
99192: POP
// end ;
99193: PPOPN 3
99195: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99196: LD_EXP 113
99200: PUSH
99201: LD_EXP 163
99205: AND
99206: IFFALSE 99362
99208: GO 99210
99210: DISABLE
99211: LD_INT 0
99213: PPUSH
99214: PPUSH
99215: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99216: LD_ADDR_VAR 0 2
99220: PUSH
99221: LD_INT 81
99223: PUSH
99224: LD_OWVAR 2
99228: PUSH
99229: EMPTY
99230: LIST
99231: LIST
99232: PUSH
99233: LD_INT 2
99235: PUSH
99236: LD_INT 21
99238: PUSH
99239: LD_INT 1
99241: PUSH
99242: EMPTY
99243: LIST
99244: LIST
99245: PUSH
99246: LD_INT 21
99248: PUSH
99249: LD_INT 2
99251: PUSH
99252: EMPTY
99253: LIST
99254: LIST
99255: PUSH
99256: EMPTY
99257: LIST
99258: LIST
99259: LIST
99260: PUSH
99261: EMPTY
99262: LIST
99263: LIST
99264: PPUSH
99265: CALL_OW 69
99269: ST_TO_ADDR
// if not tmp then
99270: LD_VAR 0 2
99274: NOT
99275: IFFALSE 99279
// exit ;
99277: GO 99362
// p := 0 ;
99279: LD_ADDR_VAR 0 3
99283: PUSH
99284: LD_INT 0
99286: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99287: LD_INT 35
99289: PPUSH
99290: CALL_OW 67
// p := p + 1 ;
99294: LD_ADDR_VAR 0 3
99298: PUSH
99299: LD_VAR 0 3
99303: PUSH
99304: LD_INT 1
99306: PLUS
99307: ST_TO_ADDR
// for i in tmp do
99308: LD_ADDR_VAR 0 1
99312: PUSH
99313: LD_VAR 0 2
99317: PUSH
99318: FOR_IN
99319: IFFALSE 99350
// if GetLives ( i ) < 1000 then
99321: LD_VAR 0 1
99325: PPUSH
99326: CALL_OW 256
99330: PUSH
99331: LD_INT 1000
99333: LESS
99334: IFFALSE 99348
// SetLives ( i , 1000 ) ;
99336: LD_VAR 0 1
99340: PPUSH
99341: LD_INT 1000
99343: PPUSH
99344: CALL_OW 234
99348: GO 99318
99350: POP
99351: POP
// until p > 20 ;
99352: LD_VAR 0 3
99356: PUSH
99357: LD_INT 20
99359: GREATER
99360: IFFALSE 99287
// end ;
99362: PPOPN 3
99364: END
// every 0 0$1 trigger StreamModeActive and sTime do
99365: LD_EXP 113
99369: PUSH
99370: LD_EXP 164
99374: AND
99375: IFFALSE 99410
99377: GO 99379
99379: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99380: LD_INT 28
99382: PPUSH
99383: LD_OWVAR 2
99387: PPUSH
99388: LD_INT 2
99390: PPUSH
99391: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99395: LD_INT 30
99397: PPUSH
99398: LD_OWVAR 2
99402: PPUSH
99403: LD_INT 2
99405: PPUSH
99406: CALL_OW 322
// end ;
99410: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99411: LD_EXP 113
99415: PUSH
99416: LD_EXP 165
99420: AND
99421: IFFALSE 99542
99423: GO 99425
99425: DISABLE
99426: LD_INT 0
99428: PPUSH
99429: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99430: LD_ADDR_VAR 0 2
99434: PUSH
99435: LD_INT 22
99437: PUSH
99438: LD_OWVAR 2
99442: PUSH
99443: EMPTY
99444: LIST
99445: LIST
99446: PUSH
99447: LD_INT 21
99449: PUSH
99450: LD_INT 1
99452: PUSH
99453: EMPTY
99454: LIST
99455: LIST
99456: PUSH
99457: LD_INT 3
99459: PUSH
99460: LD_INT 23
99462: PUSH
99463: LD_INT 0
99465: PUSH
99466: EMPTY
99467: LIST
99468: LIST
99469: PUSH
99470: EMPTY
99471: LIST
99472: LIST
99473: PUSH
99474: EMPTY
99475: LIST
99476: LIST
99477: LIST
99478: PPUSH
99479: CALL_OW 69
99483: ST_TO_ADDR
// if not tmp then
99484: LD_VAR 0 2
99488: NOT
99489: IFFALSE 99493
// exit ;
99491: GO 99542
// for i in tmp do
99493: LD_ADDR_VAR 0 1
99497: PUSH
99498: LD_VAR 0 2
99502: PUSH
99503: FOR_IN
99504: IFFALSE 99540
// begin if Crawls ( i ) then
99506: LD_VAR 0 1
99510: PPUSH
99511: CALL_OW 318
99515: IFFALSE 99526
// ComWalk ( i ) ;
99517: LD_VAR 0 1
99521: PPUSH
99522: CALL_OW 138
// SetClass ( i , 2 ) ;
99526: LD_VAR 0 1
99530: PPUSH
99531: LD_INT 2
99533: PPUSH
99534: CALL_OW 336
// end ;
99538: GO 99503
99540: POP
99541: POP
// end ;
99542: PPOPN 2
99544: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99545: LD_EXP 113
99549: PUSH
99550: LD_EXP 166
99554: AND
99555: IFFALSE 99836
99557: GO 99559
99559: DISABLE
99560: LD_INT 0
99562: PPUSH
99563: PPUSH
99564: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99565: LD_OWVAR 2
99569: PPUSH
99570: LD_INT 9
99572: PPUSH
99573: LD_INT 1
99575: PPUSH
99576: LD_INT 1
99578: PPUSH
99579: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99583: LD_INT 9
99585: PPUSH
99586: LD_OWVAR 2
99590: PPUSH
99591: CALL_OW 343
// uc_side := 9 ;
99595: LD_ADDR_OWVAR 20
99599: PUSH
99600: LD_INT 9
99602: ST_TO_ADDR
// uc_nation := 2 ;
99603: LD_ADDR_OWVAR 21
99607: PUSH
99608: LD_INT 2
99610: ST_TO_ADDR
// hc_name := Dark Warrior ;
99611: LD_ADDR_OWVAR 26
99615: PUSH
99616: LD_STRING Dark Warrior
99618: ST_TO_ADDR
// hc_gallery :=  ;
99619: LD_ADDR_OWVAR 33
99623: PUSH
99624: LD_STRING 
99626: ST_TO_ADDR
// hc_noskilllimit := true ;
99627: LD_ADDR_OWVAR 76
99631: PUSH
99632: LD_INT 1
99634: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99635: LD_ADDR_OWVAR 31
99639: PUSH
99640: LD_INT 30
99642: PUSH
99643: LD_INT 30
99645: PUSH
99646: LD_INT 30
99648: PUSH
99649: LD_INT 30
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: ST_TO_ADDR
// un := CreateHuman ;
99658: LD_ADDR_VAR 0 3
99662: PUSH
99663: CALL_OW 44
99667: ST_TO_ADDR
// hc_noskilllimit := false ;
99668: LD_ADDR_OWVAR 76
99672: PUSH
99673: LD_INT 0
99675: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99676: LD_VAR 0 3
99680: PPUSH
99681: LD_INT 1
99683: PPUSH
99684: CALL_OW 51
// p := 0 ;
99688: LD_ADDR_VAR 0 2
99692: PUSH
99693: LD_INT 0
99695: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99696: LD_INT 35
99698: PPUSH
99699: CALL_OW 67
// p := p + 1 ;
99703: LD_ADDR_VAR 0 2
99707: PUSH
99708: LD_VAR 0 2
99712: PUSH
99713: LD_INT 1
99715: PLUS
99716: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99717: LD_VAR 0 3
99721: PPUSH
99722: CALL_OW 256
99726: PUSH
99727: LD_INT 1000
99729: LESS
99730: IFFALSE 99744
// SetLives ( un , 1000 ) ;
99732: LD_VAR 0 3
99736: PPUSH
99737: LD_INT 1000
99739: PPUSH
99740: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99744: LD_VAR 0 3
99748: PPUSH
99749: LD_INT 81
99751: PUSH
99752: LD_OWVAR 2
99756: PUSH
99757: EMPTY
99758: LIST
99759: LIST
99760: PUSH
99761: LD_INT 91
99763: PUSH
99764: LD_VAR 0 3
99768: PUSH
99769: LD_INT 30
99771: PUSH
99772: EMPTY
99773: LIST
99774: LIST
99775: LIST
99776: PUSH
99777: EMPTY
99778: LIST
99779: LIST
99780: PPUSH
99781: CALL_OW 69
99785: PPUSH
99786: LD_VAR 0 3
99790: PPUSH
99791: CALL_OW 74
99795: PPUSH
99796: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
99800: LD_VAR 0 2
99804: PUSH
99805: LD_INT 60
99807: GREATER
99808: PUSH
99809: LD_VAR 0 3
99813: PPUSH
99814: CALL_OW 301
99818: OR
99819: IFFALSE 99696
// if un then
99821: LD_VAR 0 3
99825: IFFALSE 99836
// RemoveUnit ( un ) ;
99827: LD_VAR 0 3
99831: PPUSH
99832: CALL_OW 64
// end ;
99836: PPOPN 3
99838: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99839: LD_INT 0
99841: PPUSH
// case cmd of 301 :
99842: LD_VAR 0 1
99846: PUSH
99847: LD_INT 301
99849: DOUBLE
99850: EQUAL
99851: IFTRUE 99855
99853: GO 99887
99855: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99856: LD_VAR 0 6
99860: PPUSH
99861: LD_VAR 0 7
99865: PPUSH
99866: LD_VAR 0 8
99870: PPUSH
99871: LD_VAR 0 4
99875: PPUSH
99876: LD_VAR 0 5
99880: PPUSH
99881: CALL 101088 0 5
99885: GO 100008
99887: LD_INT 302
99889: DOUBLE
99890: EQUAL
99891: IFTRUE 99895
99893: GO 99932
99895: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99896: LD_VAR 0 6
99900: PPUSH
99901: LD_VAR 0 7
99905: PPUSH
99906: LD_VAR 0 8
99910: PPUSH
99911: LD_VAR 0 9
99915: PPUSH
99916: LD_VAR 0 4
99920: PPUSH
99921: LD_VAR 0 5
99925: PPUSH
99926: CALL 101179 0 6
99930: GO 100008
99932: LD_INT 303
99934: DOUBLE
99935: EQUAL
99936: IFTRUE 99940
99938: GO 99977
99940: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99941: LD_VAR 0 6
99945: PPUSH
99946: LD_VAR 0 7
99950: PPUSH
99951: LD_VAR 0 8
99955: PPUSH
99956: LD_VAR 0 9
99960: PPUSH
99961: LD_VAR 0 4
99965: PPUSH
99966: LD_VAR 0 5
99970: PPUSH
99971: CALL 100013 0 6
99975: GO 100008
99977: LD_INT 304
99979: DOUBLE
99980: EQUAL
99981: IFTRUE 99985
99983: GO 100007
99985: POP
// hHackTeleport ( unit , x , y ) ; end ;
99986: LD_VAR 0 2
99990: PPUSH
99991: LD_VAR 0 4
99995: PPUSH
99996: LD_VAR 0 5
100000: PPUSH
100001: CALL 101772 0 3
100005: GO 100008
100007: POP
// end ;
100008: LD_VAR 0 12
100012: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
100013: LD_INT 0
100015: PPUSH
100016: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
100017: LD_VAR 0 1
100021: PUSH
100022: LD_INT 1
100024: LESS
100025: PUSH
100026: LD_VAR 0 1
100030: PUSH
100031: LD_INT 3
100033: GREATER
100034: OR
100035: PUSH
100036: LD_VAR 0 5
100040: PPUSH
100041: LD_VAR 0 6
100045: PPUSH
100046: CALL_OW 428
100050: OR
100051: IFFALSE 100055
// exit ;
100053: GO 100775
// uc_side := your_side ;
100055: LD_ADDR_OWVAR 20
100059: PUSH
100060: LD_OWVAR 2
100064: ST_TO_ADDR
// uc_nation := nation ;
100065: LD_ADDR_OWVAR 21
100069: PUSH
100070: LD_VAR 0 1
100074: ST_TO_ADDR
// bc_level = 1 ;
100075: LD_ADDR_OWVAR 43
100079: PUSH
100080: LD_INT 1
100082: ST_TO_ADDR
// case btype of 1 :
100083: LD_VAR 0 2
100087: PUSH
100088: LD_INT 1
100090: DOUBLE
100091: EQUAL
100092: IFTRUE 100096
100094: GO 100107
100096: POP
// bc_type := b_depot ; 2 :
100097: LD_ADDR_OWVAR 42
100101: PUSH
100102: LD_INT 0
100104: ST_TO_ADDR
100105: GO 100719
100107: LD_INT 2
100109: DOUBLE
100110: EQUAL
100111: IFTRUE 100115
100113: GO 100126
100115: POP
// bc_type := b_warehouse ; 3 :
100116: LD_ADDR_OWVAR 42
100120: PUSH
100121: LD_INT 1
100123: ST_TO_ADDR
100124: GO 100719
100126: LD_INT 3
100128: DOUBLE
100129: EQUAL
100130: IFTRUE 100134
100132: GO 100145
100134: POP
// bc_type := b_lab ; 4 .. 9 :
100135: LD_ADDR_OWVAR 42
100139: PUSH
100140: LD_INT 6
100142: ST_TO_ADDR
100143: GO 100719
100145: LD_INT 4
100147: DOUBLE
100148: GREATEREQUAL
100149: IFFALSE 100157
100151: LD_INT 9
100153: DOUBLE
100154: LESSEQUAL
100155: IFTRUE 100159
100157: GO 100211
100159: POP
// begin bc_type := b_lab_half ;
100160: LD_ADDR_OWVAR 42
100164: PUSH
100165: LD_INT 7
100167: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100168: LD_ADDR_OWVAR 44
100172: PUSH
100173: LD_INT 10
100175: PUSH
100176: LD_INT 11
100178: PUSH
100179: LD_INT 12
100181: PUSH
100182: LD_INT 15
100184: PUSH
100185: LD_INT 14
100187: PUSH
100188: LD_INT 13
100190: PUSH
100191: EMPTY
100192: LIST
100193: LIST
100194: LIST
100195: LIST
100196: LIST
100197: LIST
100198: PUSH
100199: LD_VAR 0 2
100203: PUSH
100204: LD_INT 3
100206: MINUS
100207: ARRAY
100208: ST_TO_ADDR
// end ; 10 .. 13 :
100209: GO 100719
100211: LD_INT 10
100213: DOUBLE
100214: GREATEREQUAL
100215: IFFALSE 100223
100217: LD_INT 13
100219: DOUBLE
100220: LESSEQUAL
100221: IFTRUE 100225
100223: GO 100302
100225: POP
// begin bc_type := b_lab_full ;
100226: LD_ADDR_OWVAR 42
100230: PUSH
100231: LD_INT 8
100233: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
100234: LD_ADDR_OWVAR 44
100238: PUSH
100239: LD_INT 10
100241: PUSH
100242: LD_INT 12
100244: PUSH
100245: LD_INT 14
100247: PUSH
100248: LD_INT 13
100250: PUSH
100251: EMPTY
100252: LIST
100253: LIST
100254: LIST
100255: LIST
100256: PUSH
100257: LD_VAR 0 2
100261: PUSH
100262: LD_INT 9
100264: MINUS
100265: ARRAY
100266: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100267: LD_ADDR_OWVAR 45
100271: PUSH
100272: LD_INT 11
100274: PUSH
100275: LD_INT 15
100277: PUSH
100278: LD_INT 12
100280: PUSH
100281: LD_INT 15
100283: PUSH
100284: EMPTY
100285: LIST
100286: LIST
100287: LIST
100288: LIST
100289: PUSH
100290: LD_VAR 0 2
100294: PUSH
100295: LD_INT 9
100297: MINUS
100298: ARRAY
100299: ST_TO_ADDR
// end ; 14 :
100300: GO 100719
100302: LD_INT 14
100304: DOUBLE
100305: EQUAL
100306: IFTRUE 100310
100308: GO 100321
100310: POP
// bc_type := b_workshop ; 15 :
100311: LD_ADDR_OWVAR 42
100315: PUSH
100316: LD_INT 2
100318: ST_TO_ADDR
100319: GO 100719
100321: LD_INT 15
100323: DOUBLE
100324: EQUAL
100325: IFTRUE 100329
100327: GO 100340
100329: POP
// bc_type := b_factory ; 16 :
100330: LD_ADDR_OWVAR 42
100334: PUSH
100335: LD_INT 3
100337: ST_TO_ADDR
100338: GO 100719
100340: LD_INT 16
100342: DOUBLE
100343: EQUAL
100344: IFTRUE 100348
100346: GO 100359
100348: POP
// bc_type := b_ext_gun ; 17 :
100349: LD_ADDR_OWVAR 42
100353: PUSH
100354: LD_INT 17
100356: ST_TO_ADDR
100357: GO 100719
100359: LD_INT 17
100361: DOUBLE
100362: EQUAL
100363: IFTRUE 100367
100365: GO 100395
100367: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100368: LD_ADDR_OWVAR 42
100372: PUSH
100373: LD_INT 19
100375: PUSH
100376: LD_INT 23
100378: PUSH
100379: LD_INT 19
100381: PUSH
100382: EMPTY
100383: LIST
100384: LIST
100385: LIST
100386: PUSH
100387: LD_VAR 0 1
100391: ARRAY
100392: ST_TO_ADDR
100393: GO 100719
100395: LD_INT 18
100397: DOUBLE
100398: EQUAL
100399: IFTRUE 100403
100401: GO 100414
100403: POP
// bc_type := b_ext_radar ; 19 :
100404: LD_ADDR_OWVAR 42
100408: PUSH
100409: LD_INT 20
100411: ST_TO_ADDR
100412: GO 100719
100414: LD_INT 19
100416: DOUBLE
100417: EQUAL
100418: IFTRUE 100422
100420: GO 100433
100422: POP
// bc_type := b_ext_radio ; 20 :
100423: LD_ADDR_OWVAR 42
100427: PUSH
100428: LD_INT 22
100430: ST_TO_ADDR
100431: GO 100719
100433: LD_INT 20
100435: DOUBLE
100436: EQUAL
100437: IFTRUE 100441
100439: GO 100452
100441: POP
// bc_type := b_ext_siberium ; 21 :
100442: LD_ADDR_OWVAR 42
100446: PUSH
100447: LD_INT 21
100449: ST_TO_ADDR
100450: GO 100719
100452: LD_INT 21
100454: DOUBLE
100455: EQUAL
100456: IFTRUE 100460
100458: GO 100471
100460: POP
// bc_type := b_ext_computer ; 22 :
100461: LD_ADDR_OWVAR 42
100465: PUSH
100466: LD_INT 24
100468: ST_TO_ADDR
100469: GO 100719
100471: LD_INT 22
100473: DOUBLE
100474: EQUAL
100475: IFTRUE 100479
100477: GO 100490
100479: POP
// bc_type := b_ext_track ; 23 :
100480: LD_ADDR_OWVAR 42
100484: PUSH
100485: LD_INT 16
100487: ST_TO_ADDR
100488: GO 100719
100490: LD_INT 23
100492: DOUBLE
100493: EQUAL
100494: IFTRUE 100498
100496: GO 100509
100498: POP
// bc_type := b_ext_laser ; 24 :
100499: LD_ADDR_OWVAR 42
100503: PUSH
100504: LD_INT 25
100506: ST_TO_ADDR
100507: GO 100719
100509: LD_INT 24
100511: DOUBLE
100512: EQUAL
100513: IFTRUE 100517
100515: GO 100528
100517: POP
// bc_type := b_control_tower ; 25 :
100518: LD_ADDR_OWVAR 42
100522: PUSH
100523: LD_INT 36
100525: ST_TO_ADDR
100526: GO 100719
100528: LD_INT 25
100530: DOUBLE
100531: EQUAL
100532: IFTRUE 100536
100534: GO 100547
100536: POP
// bc_type := b_breastwork ; 26 :
100537: LD_ADDR_OWVAR 42
100541: PUSH
100542: LD_INT 31
100544: ST_TO_ADDR
100545: GO 100719
100547: LD_INT 26
100549: DOUBLE
100550: EQUAL
100551: IFTRUE 100555
100553: GO 100566
100555: POP
// bc_type := b_bunker ; 27 :
100556: LD_ADDR_OWVAR 42
100560: PUSH
100561: LD_INT 32
100563: ST_TO_ADDR
100564: GO 100719
100566: LD_INT 27
100568: DOUBLE
100569: EQUAL
100570: IFTRUE 100574
100572: GO 100585
100574: POP
// bc_type := b_turret ; 28 :
100575: LD_ADDR_OWVAR 42
100579: PUSH
100580: LD_INT 33
100582: ST_TO_ADDR
100583: GO 100719
100585: LD_INT 28
100587: DOUBLE
100588: EQUAL
100589: IFTRUE 100593
100591: GO 100604
100593: POP
// bc_type := b_armoury ; 29 :
100594: LD_ADDR_OWVAR 42
100598: PUSH
100599: LD_INT 4
100601: ST_TO_ADDR
100602: GO 100719
100604: LD_INT 29
100606: DOUBLE
100607: EQUAL
100608: IFTRUE 100612
100610: GO 100623
100612: POP
// bc_type := b_barracks ; 30 :
100613: LD_ADDR_OWVAR 42
100617: PUSH
100618: LD_INT 5
100620: ST_TO_ADDR
100621: GO 100719
100623: LD_INT 30
100625: DOUBLE
100626: EQUAL
100627: IFTRUE 100631
100629: GO 100642
100631: POP
// bc_type := b_solar_power ; 31 :
100632: LD_ADDR_OWVAR 42
100636: PUSH
100637: LD_INT 27
100639: ST_TO_ADDR
100640: GO 100719
100642: LD_INT 31
100644: DOUBLE
100645: EQUAL
100646: IFTRUE 100650
100648: GO 100661
100650: POP
// bc_type := b_oil_power ; 32 :
100651: LD_ADDR_OWVAR 42
100655: PUSH
100656: LD_INT 26
100658: ST_TO_ADDR
100659: GO 100719
100661: LD_INT 32
100663: DOUBLE
100664: EQUAL
100665: IFTRUE 100669
100667: GO 100680
100669: POP
// bc_type := b_siberite_power ; 33 :
100670: LD_ADDR_OWVAR 42
100674: PUSH
100675: LD_INT 28
100677: ST_TO_ADDR
100678: GO 100719
100680: LD_INT 33
100682: DOUBLE
100683: EQUAL
100684: IFTRUE 100688
100686: GO 100699
100688: POP
// bc_type := b_oil_mine ; 34 :
100689: LD_ADDR_OWVAR 42
100693: PUSH
100694: LD_INT 29
100696: ST_TO_ADDR
100697: GO 100719
100699: LD_INT 34
100701: DOUBLE
100702: EQUAL
100703: IFTRUE 100707
100705: GO 100718
100707: POP
// bc_type := b_siberite_mine ; end ;
100708: LD_ADDR_OWVAR 42
100712: PUSH
100713: LD_INT 30
100715: ST_TO_ADDR
100716: GO 100719
100718: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100719: LD_ADDR_VAR 0 8
100723: PUSH
100724: LD_VAR 0 5
100728: PPUSH
100729: LD_VAR 0 6
100733: PPUSH
100734: LD_VAR 0 3
100738: PPUSH
100739: CALL_OW 47
100743: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100744: LD_OWVAR 42
100748: PUSH
100749: LD_INT 32
100751: PUSH
100752: LD_INT 33
100754: PUSH
100755: EMPTY
100756: LIST
100757: LIST
100758: IN
100759: IFFALSE 100775
// PlaceWeaponTurret ( b , weapon ) ;
100761: LD_VAR 0 8
100765: PPUSH
100766: LD_VAR 0 4
100770: PPUSH
100771: CALL_OW 431
// end ;
100775: LD_VAR 0 7
100779: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100780: LD_INT 0
100782: PPUSH
100783: PPUSH
100784: PPUSH
100785: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100786: LD_ADDR_VAR 0 4
100790: PUSH
100791: LD_INT 22
100793: PUSH
100794: LD_OWVAR 2
100798: PUSH
100799: EMPTY
100800: LIST
100801: LIST
100802: PUSH
100803: LD_INT 2
100805: PUSH
100806: LD_INT 30
100808: PUSH
100809: LD_INT 0
100811: PUSH
100812: EMPTY
100813: LIST
100814: LIST
100815: PUSH
100816: LD_INT 30
100818: PUSH
100819: LD_INT 1
100821: PUSH
100822: EMPTY
100823: LIST
100824: LIST
100825: PUSH
100826: EMPTY
100827: LIST
100828: LIST
100829: LIST
100830: PUSH
100831: EMPTY
100832: LIST
100833: LIST
100834: PPUSH
100835: CALL_OW 69
100839: ST_TO_ADDR
// if not tmp then
100840: LD_VAR 0 4
100844: NOT
100845: IFFALSE 100849
// exit ;
100847: GO 100908
// for i in tmp do
100849: LD_ADDR_VAR 0 2
100853: PUSH
100854: LD_VAR 0 4
100858: PUSH
100859: FOR_IN
100860: IFFALSE 100906
// for j = 1 to 3 do
100862: LD_ADDR_VAR 0 3
100866: PUSH
100867: DOUBLE
100868: LD_INT 1
100870: DEC
100871: ST_TO_ADDR
100872: LD_INT 3
100874: PUSH
100875: FOR_TO
100876: IFFALSE 100902
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100878: LD_VAR 0 2
100882: PPUSH
100883: CALL_OW 274
100887: PPUSH
100888: LD_VAR 0 3
100892: PPUSH
100893: LD_INT 99999
100895: PPUSH
100896: CALL_OW 277
100900: GO 100875
100902: POP
100903: POP
100904: GO 100859
100906: POP
100907: POP
// end ;
100908: LD_VAR 0 1
100912: RET
// export function hHackSetLevel10 ; var i , j ; begin
100913: LD_INT 0
100915: PPUSH
100916: PPUSH
100917: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100918: LD_ADDR_VAR 0 2
100922: PUSH
100923: LD_INT 21
100925: PUSH
100926: LD_INT 1
100928: PUSH
100929: EMPTY
100930: LIST
100931: LIST
100932: PPUSH
100933: CALL_OW 69
100937: PUSH
100938: FOR_IN
100939: IFFALSE 100991
// if IsSelected ( i ) then
100941: LD_VAR 0 2
100945: PPUSH
100946: CALL_OW 306
100950: IFFALSE 100989
// begin for j := 1 to 4 do
100952: LD_ADDR_VAR 0 3
100956: PUSH
100957: DOUBLE
100958: LD_INT 1
100960: DEC
100961: ST_TO_ADDR
100962: LD_INT 4
100964: PUSH
100965: FOR_TO
100966: IFFALSE 100987
// SetSkill ( i , j , 10 ) ;
100968: LD_VAR 0 2
100972: PPUSH
100973: LD_VAR 0 3
100977: PPUSH
100978: LD_INT 10
100980: PPUSH
100981: CALL_OW 237
100985: GO 100965
100987: POP
100988: POP
// end ;
100989: GO 100938
100991: POP
100992: POP
// end ;
100993: LD_VAR 0 1
100997: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100998: LD_INT 0
101000: PPUSH
101001: PPUSH
101002: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
101003: LD_ADDR_VAR 0 2
101007: PUSH
101008: LD_INT 22
101010: PUSH
101011: LD_OWVAR 2
101015: PUSH
101016: EMPTY
101017: LIST
101018: LIST
101019: PUSH
101020: LD_INT 21
101022: PUSH
101023: LD_INT 1
101025: PUSH
101026: EMPTY
101027: LIST
101028: LIST
101029: PUSH
101030: EMPTY
101031: LIST
101032: LIST
101033: PPUSH
101034: CALL_OW 69
101038: PUSH
101039: FOR_IN
101040: IFFALSE 101081
// begin for j := 1 to 4 do
101042: LD_ADDR_VAR 0 3
101046: PUSH
101047: DOUBLE
101048: LD_INT 1
101050: DEC
101051: ST_TO_ADDR
101052: LD_INT 4
101054: PUSH
101055: FOR_TO
101056: IFFALSE 101077
// SetSkill ( i , j , 10 ) ;
101058: LD_VAR 0 2
101062: PPUSH
101063: LD_VAR 0 3
101067: PPUSH
101068: LD_INT 10
101070: PPUSH
101071: CALL_OW 237
101075: GO 101055
101077: POP
101078: POP
// end ;
101079: GO 101039
101081: POP
101082: POP
// end ;
101083: LD_VAR 0 1
101087: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
101088: LD_INT 0
101090: PPUSH
// uc_side := your_side ;
101091: LD_ADDR_OWVAR 20
101095: PUSH
101096: LD_OWVAR 2
101100: ST_TO_ADDR
// uc_nation := nation ;
101101: LD_ADDR_OWVAR 21
101105: PUSH
101106: LD_VAR 0 1
101110: ST_TO_ADDR
// InitHc ;
101111: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101115: LD_INT 0
101117: PPUSH
101118: LD_VAR 0 2
101122: PPUSH
101123: LD_VAR 0 3
101127: PPUSH
101128: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101132: LD_VAR 0 4
101136: PPUSH
101137: LD_VAR 0 5
101141: PPUSH
101142: CALL_OW 428
101146: PUSH
101147: LD_INT 0
101149: EQUAL
101150: IFFALSE 101174
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101152: CALL_OW 44
101156: PPUSH
101157: LD_VAR 0 4
101161: PPUSH
101162: LD_VAR 0 5
101166: PPUSH
101167: LD_INT 1
101169: PPUSH
101170: CALL_OW 48
// end ;
101174: LD_VAR 0 6
101178: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101179: LD_INT 0
101181: PPUSH
101182: PPUSH
// uc_side := your_side ;
101183: LD_ADDR_OWVAR 20
101187: PUSH
101188: LD_OWVAR 2
101192: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101193: LD_VAR 0 1
101197: PUSH
101198: LD_INT 1
101200: PUSH
101201: LD_INT 2
101203: PUSH
101204: LD_INT 3
101206: PUSH
101207: LD_INT 4
101209: PUSH
101210: LD_INT 5
101212: PUSH
101213: EMPTY
101214: LIST
101215: LIST
101216: LIST
101217: LIST
101218: LIST
101219: IN
101220: IFFALSE 101232
// uc_nation := nation_american else
101222: LD_ADDR_OWVAR 21
101226: PUSH
101227: LD_INT 1
101229: ST_TO_ADDR
101230: GO 101275
// if chassis in [ 11 , 12 , 13 , 14 ] then
101232: LD_VAR 0 1
101236: PUSH
101237: LD_INT 11
101239: PUSH
101240: LD_INT 12
101242: PUSH
101243: LD_INT 13
101245: PUSH
101246: LD_INT 14
101248: PUSH
101249: EMPTY
101250: LIST
101251: LIST
101252: LIST
101253: LIST
101254: IN
101255: IFFALSE 101267
// uc_nation := nation_arabian else
101257: LD_ADDR_OWVAR 21
101261: PUSH
101262: LD_INT 2
101264: ST_TO_ADDR
101265: GO 101275
// uc_nation := nation_russian ;
101267: LD_ADDR_OWVAR 21
101271: PUSH
101272: LD_INT 3
101274: ST_TO_ADDR
// vc_chassis := chassis ;
101275: LD_ADDR_OWVAR 37
101279: PUSH
101280: LD_VAR 0 1
101284: ST_TO_ADDR
// vc_engine := engine ;
101285: LD_ADDR_OWVAR 39
101289: PUSH
101290: LD_VAR 0 2
101294: ST_TO_ADDR
// vc_control := control ;
101295: LD_ADDR_OWVAR 38
101299: PUSH
101300: LD_VAR 0 3
101304: ST_TO_ADDR
// vc_weapon := weapon ;
101305: LD_ADDR_OWVAR 40
101309: PUSH
101310: LD_VAR 0 4
101314: ST_TO_ADDR
// un := CreateVehicle ;
101315: LD_ADDR_VAR 0 8
101319: PUSH
101320: CALL_OW 45
101324: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101325: LD_VAR 0 8
101329: PPUSH
101330: LD_INT 0
101332: PPUSH
101333: LD_INT 5
101335: PPUSH
101336: CALL_OW 12
101340: PPUSH
101341: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101345: LD_VAR 0 8
101349: PPUSH
101350: LD_VAR 0 5
101354: PPUSH
101355: LD_VAR 0 6
101359: PPUSH
101360: LD_INT 1
101362: PPUSH
101363: CALL_OW 48
// end ;
101367: LD_VAR 0 7
101371: RET
// export hInvincible ; every 1 do
101372: GO 101374
101374: DISABLE
// hInvincible := [ ] ;
101375: LD_ADDR_EXP 167
101379: PUSH
101380: EMPTY
101381: ST_TO_ADDR
101382: END
// every 10 do var i ;
101383: GO 101385
101385: DISABLE
101386: LD_INT 0
101388: PPUSH
// begin enable ;
101389: ENABLE
// if not hInvincible then
101390: LD_EXP 167
101394: NOT
101395: IFFALSE 101399
// exit ;
101397: GO 101443
// for i in hInvincible do
101399: LD_ADDR_VAR 0 1
101403: PUSH
101404: LD_EXP 167
101408: PUSH
101409: FOR_IN
101410: IFFALSE 101441
// if GetLives ( i ) < 1000 then
101412: LD_VAR 0 1
101416: PPUSH
101417: CALL_OW 256
101421: PUSH
101422: LD_INT 1000
101424: LESS
101425: IFFALSE 101439
// SetLives ( i , 1000 ) ;
101427: LD_VAR 0 1
101431: PPUSH
101432: LD_INT 1000
101434: PPUSH
101435: CALL_OW 234
101439: GO 101409
101441: POP
101442: POP
// end ;
101443: PPOPN 1
101445: END
// export function hHackInvincible ; var i ; begin
101446: LD_INT 0
101448: PPUSH
101449: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101450: LD_ADDR_VAR 0 2
101454: PUSH
101455: LD_INT 2
101457: PUSH
101458: LD_INT 21
101460: PUSH
101461: LD_INT 1
101463: PUSH
101464: EMPTY
101465: LIST
101466: LIST
101467: PUSH
101468: LD_INT 21
101470: PUSH
101471: LD_INT 2
101473: PUSH
101474: EMPTY
101475: LIST
101476: LIST
101477: PUSH
101478: EMPTY
101479: LIST
101480: LIST
101481: LIST
101482: PPUSH
101483: CALL_OW 69
101487: PUSH
101488: FOR_IN
101489: IFFALSE 101550
// if IsSelected ( i ) then
101491: LD_VAR 0 2
101495: PPUSH
101496: CALL_OW 306
101500: IFFALSE 101548
// begin if i in hInvincible then
101502: LD_VAR 0 2
101506: PUSH
101507: LD_EXP 167
101511: IN
101512: IFFALSE 101532
// hInvincible := hInvincible diff i else
101514: LD_ADDR_EXP 167
101518: PUSH
101519: LD_EXP 167
101523: PUSH
101524: LD_VAR 0 2
101528: DIFF
101529: ST_TO_ADDR
101530: GO 101548
// hInvincible := hInvincible union i ;
101532: LD_ADDR_EXP 167
101536: PUSH
101537: LD_EXP 167
101541: PUSH
101542: LD_VAR 0 2
101546: UNION
101547: ST_TO_ADDR
// end ;
101548: GO 101488
101550: POP
101551: POP
// end ;
101552: LD_VAR 0 1
101556: RET
// export function hHackInvisible ; var i , j ; begin
101557: LD_INT 0
101559: PPUSH
101560: PPUSH
101561: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101562: LD_ADDR_VAR 0 2
101566: PUSH
101567: LD_INT 21
101569: PUSH
101570: LD_INT 1
101572: PUSH
101573: EMPTY
101574: LIST
101575: LIST
101576: PPUSH
101577: CALL_OW 69
101581: PUSH
101582: FOR_IN
101583: IFFALSE 101607
// if IsSelected ( i ) then
101585: LD_VAR 0 2
101589: PPUSH
101590: CALL_OW 306
101594: IFFALSE 101605
// ComForceInvisible ( i ) ;
101596: LD_VAR 0 2
101600: PPUSH
101601: CALL_OW 496
101605: GO 101582
101607: POP
101608: POP
// end ;
101609: LD_VAR 0 1
101613: RET
// export function hHackChangeYourSide ; begin
101614: LD_INT 0
101616: PPUSH
// if your_side = 8 then
101617: LD_OWVAR 2
101621: PUSH
101622: LD_INT 8
101624: EQUAL
101625: IFFALSE 101637
// your_side := 0 else
101627: LD_ADDR_OWVAR 2
101631: PUSH
101632: LD_INT 0
101634: ST_TO_ADDR
101635: GO 101651
// your_side := your_side + 1 ;
101637: LD_ADDR_OWVAR 2
101641: PUSH
101642: LD_OWVAR 2
101646: PUSH
101647: LD_INT 1
101649: PLUS
101650: ST_TO_ADDR
// end ;
101651: LD_VAR 0 1
101655: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101656: LD_INT 0
101658: PPUSH
101659: PPUSH
101660: PPUSH
// for i in all_units do
101661: LD_ADDR_VAR 0 2
101665: PUSH
101666: LD_OWVAR 3
101670: PUSH
101671: FOR_IN
101672: IFFALSE 101750
// if IsSelected ( i ) then
101674: LD_VAR 0 2
101678: PPUSH
101679: CALL_OW 306
101683: IFFALSE 101748
// begin j := GetSide ( i ) ;
101685: LD_ADDR_VAR 0 3
101689: PUSH
101690: LD_VAR 0 2
101694: PPUSH
101695: CALL_OW 255
101699: ST_TO_ADDR
// if j = 8 then
101700: LD_VAR 0 3
101704: PUSH
101705: LD_INT 8
101707: EQUAL
101708: IFFALSE 101720
// j := 0 else
101710: LD_ADDR_VAR 0 3
101714: PUSH
101715: LD_INT 0
101717: ST_TO_ADDR
101718: GO 101734
// j := j + 1 ;
101720: LD_ADDR_VAR 0 3
101724: PUSH
101725: LD_VAR 0 3
101729: PUSH
101730: LD_INT 1
101732: PLUS
101733: ST_TO_ADDR
// SetSide ( i , j ) ;
101734: LD_VAR 0 2
101738: PPUSH
101739: LD_VAR 0 3
101743: PPUSH
101744: CALL_OW 235
// end ;
101748: GO 101671
101750: POP
101751: POP
// end ;
101752: LD_VAR 0 1
101756: RET
// export function hHackFog ; begin
101757: LD_INT 0
101759: PPUSH
// FogOff ( true ) ;
101760: LD_INT 1
101762: PPUSH
101763: CALL_OW 344
// end ;
101767: LD_VAR 0 1
101771: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101772: LD_INT 0
101774: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101775: LD_VAR 0 1
101779: PPUSH
101780: LD_VAR 0 2
101784: PPUSH
101785: LD_VAR 0 3
101789: PPUSH
101790: LD_INT 1
101792: PPUSH
101793: LD_INT 1
101795: PPUSH
101796: CALL_OW 483
// CenterOnXY ( x , y ) ;
101800: LD_VAR 0 2
101804: PPUSH
101805: LD_VAR 0 3
101809: PPUSH
101810: CALL_OW 84
// end ;
101814: LD_VAR 0 4
101818: RET
