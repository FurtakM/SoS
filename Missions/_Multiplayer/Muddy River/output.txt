// starting begin ResetFog ;
   0: NOP4
// InitHc ;
   4: NOP4
// InitUc ;
   8: NOP4
// InitBc ;
  12: NOP4
// InitVariables ;
  16: NOP4
// InitMultiplayer ;
  20: NOP4
// InitMacro ;
  24: NOP4
// if debug then
  28: NOP4
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: NOP4
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: NOP4
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: NOP4
  79: PPUSH
  80: NOP4
// Multiplayer_Start ;
  84: NOP4
// MC_Start ( ) ;
  88: NOP4
// Multiplayer_End ;
  92: NOP4
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: NOP4
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: NOP4
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: NOP4
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: NOP4
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: NOP4
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: NOP4
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: NOP4
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: NOP4
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: NOP4
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: NOP4
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: NOP4
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: NOP4
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: NOP4
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: NOP4
 325: PPUSH
 326: NOP4
 330: PUSH
 331: NOP4
 335: ARRAY
 336: PPUSH
 337: NOP4
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := 1 ;
 353: NOP4
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: NOP4
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: NOP4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: NOP4
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: NOP4
 489: PUSH
 490: NOP4
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: NOP4
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: NOP4
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: NOP4
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: NOP4
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: NOP4
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: NOP4
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: NOP4
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: NOP4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: NOP4
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: NOP4
 646: PUSH
 647: NOP4
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: NOP4
 656: PUSH
 657: NOP4
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: NOP4
 666: PUSH
 667: NOP4
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: NOP4
 676: PUSH
 677: NOP4
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: NOP4
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: NOP4
 693: PUSH
 694: NOP4
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: NOP4
 706: PUSH
 707: NOP4
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: NOP4
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: NOP4
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: NOP4
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: NOP4
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: NOP4
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: NOP4
 772: PUSH
 773: NOP4
 777: PPUSH
 778: NOP4
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: NOP4
 791: PPUSH
 792: NOP4
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: NOP4
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: NOP4
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: NOP4
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: NOP4
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: NOP4
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: NOP4
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: NOP4
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: NOP4
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: NOP4
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: NOP4
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: NOP4
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: NOP4
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: NOP4
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: NOP4
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: NOP4
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: NOP4
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: NOP4
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: NOP4
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: NOP4
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: NOP4
1232: PPUSH
1233: NOP4
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: NOP4
1243: PUSH
1244: NOP4
1248: PPUSH
1249: NOP4
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: NOP4
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: NOP4
1266: PUSH
1267: NOP4
1271: PPUSH
1272: NOP4
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: NOP4
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: NOP4
1289: PUSH
1290: NOP4
1294: PPUSH
1295: NOP4
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: NOP4
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: NOP4
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: NOP4
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: NOP4
1330: PUSH
1331: NOP4
1335: PUSH
1336: NOP4
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: NOP4
1348: PUSH
1349: NOP4
1353: PUSH
1354: NOP4
1358: ARRAY
1359: PUSH
1360: NOP4
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: NOP4
1370: PUSH
1371: NOP4
1375: PPUSH
1376: NOP4
1380: PPUSH
1381: NOP4
1385: PPUSH
1386: NOP4
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: NOP4
1399: PUSH
1400: NOP4
1404: ARRAY
1405: PUSH
1406: NOP4
1410: PUSH
1411: NOP4
1415: ARRAY
1416: PUSH
1417: NOP4
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: NOP4
1430: PUSH
1431: NOP4
1435: PPUSH
1436: NOP4
1440: PPUSH
1441: NOP4
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: NOP4
1453: PPUSH
1454: NOP4
1458: ARRAY
1459: PPUSH
1460: NOP4
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: NOP4
1469: PUSH
1470: NOP4
1474: ARRAY
1475: NOT
1476: PUSH
1477: NOP4
1481: PUSH
1482: NOP4
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: NOP4
1494: PUSH
1495: NOP4
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: NOP4
1508: PUSH
1509: NOP4
1513: PPUSH
1514: NOP4
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: NOP4
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: NOP4
1531: PUSH
1532: NOP4
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: NOP4
1543: PUSH
1544: NOP4
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: NOP4
1561: PUSH
1562: NOP4
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: NOP4
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: NOP4
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: NOP4
1592: PUSH
1593: NOP4
1597: ARRAY
1598: PPUSH
1599: NOP4
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: NOP4
// for x = 1 to j - 1 do
1612: NOP4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: NOP4
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: NOP4
1638: PUSH
1639: NOP4
1643: ARRAY
1644: PPUSH
1645: NOP4
1649: PUSH
1650: NOP4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: NOP4
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: NOP4
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: NOP4
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: NOP4
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: NOP4
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: NOP4
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: NOP4
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: NOP4
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: NOP4
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: NOP4
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: NOP4
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: NOP4
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: NOP4
1901: PUSH
1902: NOP4
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: NOP4
1914: PUSH
1915: NOP4
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: NOP4
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: NOP4
1942: PUSH
1943: NOP4
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: NOP4
1955: PUSH
1956: NOP4
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: NOP4
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: NOP4
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: NOP4
2095: PUSH
2096: NOP4
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: NOP4
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: NOP4
2185: PUSH
2186: NOP4
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: NOP4
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: NOP4
2275: PUSH
2276: NOP4
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: NOP4
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: NOP4
2317: PUSH
2318: NOP4
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: NOP4
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: NOP4
2338: PUSH
2339: NOP4
2343: PPUSH
2344: NOP4
2348: PUSH
2349: NOP4
2353: ARRAY
2354: PPUSH
2355: NOP4
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: NOP4
2364: PUSH
2365: NOP4
2369: PPUSH
2370: NOP4
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: NOP4
2383: PPUSH
2384: NOP4
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: NOP4
2393: PPUSH
2394: NOP4
2398: PUSH
2399: NOP4
2403: PUSH
2404: NOP4
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: NOP4
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: NOP4
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: NOP4
2443: PUSH
2444: NOP4
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: NOP4
2468: PPUSH
2469: NOP4
// if multiplayer then
2473: NOP4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: NOP4
2488: PUSH
2489: NOP4
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: NOP4
2512: PPUSH
2513: NOP4
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: NOP4
2527: PPUSH
2528: NOP4
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: NOP4
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: NOP4
2571: PUSH
2572: NOP4
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: NOP4
2581: PPUSH
2582: NOP4
2586: PUSH
2587: NOP4
2591: PUSH
2592: NOP4
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: NOP4
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: NOP4
2614: PUSH
2615: NOP4
2619: PPUSH
2620: NOP4
2624: PPUSH
2625: NOP4
2629: PPUSH
2630: NOP4
2634: ST_TO_ADDR
// end ; InitHc ;
2635: NOP4
// InitUc ;
2639: NOP4
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: NOP4
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: NOP4
2662: PUSH
2663: NOP4
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: NOP4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: NOP4
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: NOP4
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: NOP4
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: NOP4
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: NOP4
2751: PUSH
2752: NOP4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: NOP4
2768: PPUSH
2769: NOP4
2773: PPUSH
2774: NOP4
// un := CreateHuman ;
2778: NOP4
2782: PUSH
2783: NOP4
2787: ST_TO_ADDR
// if j > copy then
2788: NOP4
2792: PUSH
2793: NOP4
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: NOP4
2804: PUSH
2805: NOP4
2809: PPUSH
2810: NOP4
2814: PPUSH
2815: NOP4
2819: PPUSH
2820: NOP4
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: NOP4
2831: PUSH
2832: NOP4
2836: ARRAY
2837: PPUSH
2838: NOP4
2842: PPUSH
2843: NOP4
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: NOP4
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: NOP4
2859: PUSH
2860: NOP4
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: NOP4
2873: PPUSH
2874: NOP4
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: NOP4
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: NOP4
2890: PUSH
2891: NOP4
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: NOP4
2904: PPUSH
2905: NOP4
// end ; if multi_pos_area then
2909: NOP4
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: NOP4
2919: PPUSH
2920: NOP4
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: NOP4
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: NOP4
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: NOP4
// veh := CreateVehicle ;
2995: NOP4
2999: PUSH
3000: NOP4
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: NOP4
3009: PPUSH
3010: NOP4
3014: PUSH
3015: NOP4
3019: PUSH
3020: NOP4
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: NOP4
// PlaceHumanInUnit ( un , veh ) ;
3038: NOP4
3042: PPUSH
3043: NOP4
3047: PPUSH
3048: NOP4
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: NOP4
3058: PPUSH
3059: NOP4
3063: PUSH
3064: NOP4
3068: PUSH
3069: NOP4
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: NOP4
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: NOP4
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: NOP4
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: NOP4
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: NOP4
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: NOP4
3166: PPUSH
3167: NOP4
3171: PUSH
3172: NOP4
3176: PUSH
3177: NOP4
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: NOP4
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: NOP4
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: NOP4
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: NOP4
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: NOP4
3251: PUSH
3252: NOP4
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: NOP4
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: NOP4
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: NOP4
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: NOP4
3295: PUSH
3296: NOP4
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: NOP4
// tmp := tmp ^ CreateVehicle ;
3321: NOP4
3325: PUSH
3326: NOP4
3330: PUSH
3331: NOP4
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: NOP4
// tmp := tmp ^ CreateVehicle ;
3356: NOP4
3360: PUSH
3361: NOP4
3365: PUSH
3366: NOP4
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: NOP4
// tmp := tmp ^ CreateVehicle ;
3391: NOP4
3395: PUSH
3396: NOP4
3400: PUSH
3401: NOP4
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: NOP4
// tmp := tmp ^ CreateVehicle ;
3426: NOP4
3430: PUSH
3431: NOP4
3435: PUSH
3436: NOP4
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: NOP4
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: NOP4
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: NOP4
3471: PUSH
3472: NOP4
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: NOP4
// tmp := tmp ^ CreateVehicle ;
3497: NOP4
3501: PUSH
3502: NOP4
3506: PUSH
3507: NOP4
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: NOP4
// tmp := tmp ^ CreateVehicle ;
3532: NOP4
3536: PUSH
3537: NOP4
3541: PUSH
3542: NOP4
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: NOP4
// tmp := tmp ^ CreateVehicle ;
3567: NOP4
3571: PUSH
3572: NOP4
3576: PUSH
3577: NOP4
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: NOP4
// tmp := tmp ^ CreateVehicle ;
3602: NOP4
3606: PUSH
3607: NOP4
3611: PUSH
3612: NOP4
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: NOP4
// tmp := tmp ^ CreateVehicle ;
3637: NOP4
3641: PUSH
3642: NOP4
3646: PUSH
3647: NOP4
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: NOP4
// tmp := tmp ^ CreateVehicle ;
3672: NOP4
3676: PUSH
3677: NOP4
3681: PUSH
3682: NOP4
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: NOP4
// tmp := tmp ^ CreateVehicle ;
3707: NOP4
3711: PUSH
3712: NOP4
3716: PUSH
3717: NOP4
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: NOP4
3727: PUSH
3728: NOP4
3732: PPUSH
3733: NOP4
3737: PPUSH
3738: NOP4
3742: PPUSH
3743: NOP4
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: NOP4
// Multiplayer_InitPointSystem ( ) ;
3764: NOP4
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: NOP4
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: NOP4
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: NOP4
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: NOP4
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: NOP4
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: NOP4
// Multiplayer_SpawnArtifact ;
3811: NOP4
// if multi_support then
3815: NOP4
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: NOP4
3825: PUSH
3826: NOP4
3830: ST_TO_ADDR
// game := true ;
3831: NOP4
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: NOP4
3843: PUSH
3844: NOP4
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: NOP4
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: NOP4
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: NOP4
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: NOP4
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: NOP4
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: NOP4
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: NOP4
3916: NOT
3917: AND
3918: PUSH
3919: NOP4
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: NOP4
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: NOP4
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: NOP4
3958: PUSH
3959: NOP4
3963: ARRAY
3964: PUSH
3965: NOP4
3969: PUSH
3970: NOP4
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: NOP4
3982: PUSH
3983: NOP4
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: NOP4
3995: PUSH
3996: NOP4
4000: PUSH
4001: NOP4
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: NOP4
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: NOP4
4027: PUSH
4028: NOP4
4032: ARRAY
4033: PPUSH
4034: NOP4
4038: PUSH
4039: NOP4
4043: PUSH
4044: NOP4
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: NOP4
// tmp := Delete ( tmp , 1 ) ;
4062: NOP4
4066: PUSH
4067: NOP4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: NOP4
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: NOP4
4088: PUSH
4089: NOP4
4093: PPUSH
4094: NOP4
4098: PPUSH
4099: NOP4
4103: PPUSH
4104: NOP4
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: NOP4
4117: PUSH
4118: NOP4
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: NOP4
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: NOP4
4136: LESS
4137: PUSH
4138: NOP4
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: NOP4
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: NOP4
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: NOP4
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: NOP4
4187: PUSH
4188: NOP4
4192: ARRAY
4193: PUSH
4194: NOP4
4198: PUSH
4199: NOP4
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: NOP4
4211: PUSH
4212: NOP4
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: NOP4
4224: PUSH
4225: NOP4
4229: PUSH
4230: NOP4
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: NOP4
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: NOP4
4256: PUSH
4257: NOP4
4261: ARRAY
4262: PPUSH
4263: NOP4
4267: PUSH
4268: NOP4
4272: PUSH
4273: NOP4
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: NOP4
// tmp := Delete ( tmp , 1 ) ;
4291: NOP4
4295: PUSH
4296: NOP4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: NOP4
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: NOP4
4317: PUSH
4318: NOP4
4322: PPUSH
4323: NOP4
4327: PPUSH
4328: NOP4
4332: PPUSH
4333: NOP4
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: NOP4
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: NOP4
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: NOP4
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: NOP4
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: NOP4
4390: PUSH
4391: NOP4
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: NOP4
4404: PUSH
4405: NOP4
4409: PPUSH
4410: NOP4
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: NOP4
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: NOP4
4427: PPUSH
4428: NOP4
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: NOP4
4440: PPUSH
4441: NOP4
4445: PUSH
4446: NOP4
4450: PPUSH
4451: NOP4
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: NOP4
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: NOP4
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: NOP4
4485: AND
4486: PUSH
4487: NOP4
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: NOP4
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: NOP4
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: NOP4
4523: PUSH
4524: NOP4
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: NOP4
4535: PPUSH
4536: NOP4
4540: PUSH
4541: NOP4
4545: ARRAY
4546: PPUSH
4547: NOP4
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: NOP4
4559: PUSH
4560: NOP4
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: NOP4
4571: GO 4577
// YouWinInMultiplayer ;
4573: NOP4
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: NOP4
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: NOP4
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: NOP4
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: NOP4
4623: PUSH
4624: NOP4
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: NOP4
4635: PUSH
4636: NOP4
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: NOP4
4648: PUSH
4649: NOP4
4653: PUSH
4654: NOP4
4658: PUSH
4659: NOP4
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: NOP4
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: NOP4
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: NOP4
4743: NOT
4744: PUSH
4745: NOP4
4749: NOT
4750: OR
4751: PUSH
4752: NOP4
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: NOP4
4769: PUSH
4770: NOP4
4774: PPUSH
4775: NOP4
4779: PPUSH
4780: NOP4
4784: PUSH
4785: NOP4
4789: ARRAY
4790: PUSH
4791: NOP4
4795: PLUS
4796: PPUSH
4797: NOP4
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: NOP4
4814: NOT
4815: PUSH
4816: NOP4
4820: NOT
4821: OR
4822: PUSH
4823: NOP4
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: NOP4
4840: PUSH
4841: NOP4
4845: PUSH
4846: NOP4
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: NOP4
4864: PUSH
4865: NOP4
4869: PPUSH
4870: NOP4
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: NOP4
4883: PPUSH
4884: NOP4
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: NOP4
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: NOP4
4910: PUSH
4911: NOP4
4915: PUSH
4916: NOP4
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: NOP4
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: NOP4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: NOP4
4961: PUSH
4962: NOP4
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: NOP4
4975: PUSH
4976: NOP4
4980: ARRAY
4981: PUSH
4982: NOP4
4986: PUSH
4987: NOP4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: NOP4
5000: PUSH
5001: NOP4
5005: PUSH
5006: NOP4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: NOP4
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: NOP4
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: NOP4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: NOP4
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: NOP4
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: NOP4
5074: PPUSH
5075: NOP4
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: NOP4
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: NOP4
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: NOP4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: NOP4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: NOP4
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: NOP4
5173: PPUSH
5174: NOP4
5178: PUSH
5179: NOP4
5183: ARRAY
5184: PPUSH
5185: NOP4
// if IsDrivenBy ( i ) then
5189: NOP4
5193: PPUSH
5194: NOP4
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: NOP4
5204: PPUSH
5205: NOP4
5209: PPUSH
5210: NOP4
5214: PUSH
5215: NOP4
5219: ARRAY
5220: PPUSH
5221: NOP4
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: NOP4
5229: PPUSH
5230: NOP4
5234: PPUSH
5235: NOP4
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: NOP4
5249: PPUSH
5250: NOP4
// j := j + 1 ;
5254: NOP4
5258: PUSH
5259: NOP4
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: NOP4
5272: PUSH
5273: NOP4
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: NOP4
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: NOP4
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: NOP4
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: NOP4
5365: PPUSH
5366: NOP4
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: NOP4
5381: PUSH
5382: NOP4
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: NOP4
5396: PUSH
5397: NOP4
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: NOP4
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: NOP4
5426: NOT
5427: PUSH
5428: NOP4
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: NOP4
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: NOP4
5453: PPUSH
5454: NOP4
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: NOP4
5470: NOT
5471: PUSH
5472: NOP4
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: NOP4
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: NOP4
5497: PPUSH
5498: NOP4
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: NOP4
5514: NOT
5515: PUSH
5516: NOP4
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: NOP4
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: NOP4
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: NOP4
5567: PPUSH
5568: NOP4
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: NOP4
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: NOP4
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: NOP4
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: NOP4
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: NOP4
5620: PUSH
5621: NOP4
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: NOP4
5630: PUSH
5631: NOP4
5635: PPUSH
5636: NOP4
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: NOP4
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: NOP4
5656: PUSH
5657: NOP4
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: NOP4
5666: PUSH
5667: NOP4
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: NOP4
5679: PPUSH
5680: NOP4
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: NOP4
5693: DIFF
5694: PPUSH
5695: NOP4
5699: PPUSH
5700: NOP4
5704: ST_TO_ADDR
// if nearest_unit then
5705: NOP4
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: NOP4
5715: PUSH
5716: NOP4
5720: PPUSH
5721: NOP4
5725: ST_TO_ADDR
// if not side and not side2 then
5726: NOP4
5730: NOT
5731: PUSH
5732: NOP4
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: NOP4
5746: PUSH
5747: NOP4
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: NOP4
5758: PPUSH
5759: NOP4
5763: PPUSH
5764: NOP4
5768: GO 5818
// begin if side then
5770: NOP4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: NOP4
5780: PPUSH
5781: NOP4
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: NOP4
// if side2 then
5794: NOP4
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: NOP4
5804: PPUSH
5805: NOP4
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: NOP4
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: NOP4
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: NOP4
5838: PPUSH
5839: NOP4
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: NOP4
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: NOP4
5878: ST_TO_ADDR
// side_bot := side ;
5879: NOP4
5883: PUSH
5884: NOP4
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: NOP4
5893: PUSH
5894: NOP4
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: NOP4
5909: PUSH
5910: NOP4
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: NOP4
5922: PPUSH
5923: NOP4
5927: PPUSH
5928: NOP4
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: NOP4
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: NOP4
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: NOP4
5999: PUSH
6000: NOP4
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: NOP4
6012: PPUSH
6013: NOP4
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: NOP4
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: NOP4
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: NOP4
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: NOP4
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: NOP4
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: NOP4
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: NOP4
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: NOP4
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: NOP4
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: NOP4
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: NOP4
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: NOP4
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: NOP4
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: NOP4
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: NOP4
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: NOP4
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: NOP4
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: NOP4
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: NOP4
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: NOP4
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: NOP4
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: NOP4
6377: PUSH
6378: NOP4
6382: PUSH
6383: NOP4
6387: PUSH
6388: NOP4
6392: PUSH
6393: NOP4
6397: PUSH
6398: NOP4
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: NOP4
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: NOP4
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: NOP4
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: NOP4
6511: PPUSH
6512: NOP4
// un := CreateVehicle ;
6516: NOP4
6520: PUSH
6521: NOP4
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: NOP4
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: NOP4
6541: PPUSH
6542: NOP4
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: NOP4
6550: PPUSH
6551: NOP4
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: NOP4
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: NOP4
// un2 := CreateHuman ;
6579: NOP4
6583: PUSH
6584: NOP4
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: NOP4
6593: PPUSH
6594: NOP4
6598: PPUSH
6599: NOP4
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: NOP4
6607: PUSH
6608: NOP4
6612: PPUSH
6613: NOP4
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: NOP4
6630: PUSH
6631: NOP4
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: NOP4
6657: PPUSH
6658: NOP4
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: NOP4
6667: PUSH
6668: NOP4
6672: PPUSH
6673: NOP4
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: NOP4
6690: PUSH
6691: NOP4
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: NOP4
6717: PPUSH
6718: NOP4
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: NOP4
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: NOP4
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: NOP4
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: NOP4
6777: PPUSH
6778: NOP4
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: NOP4
6790: PUSH
6791: NOP4
6795: PPUSH
6796: NOP4
6800: ST_TO_ADDR
// if d < 3 then
6801: NOP4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: NOP4
6815: PUSH
6816: NOP4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: NOP4
6831: PUSH
6832: NOP4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: NOP4
6851: PPUSH
6852: NOP4
// un := CreateHuman ;
6856: NOP4
6860: PUSH
6861: NOP4
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: NOP4
6870: PPUSH
6871: NOP4
6875: PPUSH
6876: NOP4
// PlaceHumanInUnit ( un , i ) ;
6880: NOP4
6884: PPUSH
6885: NOP4
6889: PPUSH
6890: NOP4
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: NOP4
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: NOP4
6915: PPUSH
6916: NOP4
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: NOP4
6940: PUSH
6941: NOP4
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: NOP4
6953: PPUSH
6954: NOP4
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: NOP4
6969: PPUSH
6970: NOP4
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: NOP4
6994: PUSH
6995: NOP4
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: NOP4
7007: PPUSH
7008: NOP4
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: NOP4
7023: PPUSH
7024: NOP4
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: NOP4
7040: PUSH
7041: NOP4
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: NOP4
7053: PPUSH
7054: NOP4
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: NOP4
7126: PUSH
7127: NOP4
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: NOP4
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: NOP4
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: NOP4
7203: PUSH
7204: NOP4
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: NOP4
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: NOP4
// InitHc ;
7221: NOP4
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: NOP4
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: NOP4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: NOP4
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: NOP4
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: NOP4
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: NOP4
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: NOP4
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: NOP4
// un := CreateVehicle ;
7377: NOP4
7381: PUSH
7382: NOP4
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: NOP4
7391: PUSH
7392: NOP4
7396: PPUSH
7397: NOP4
7401: PUSH
7402: NOP4
7406: PUSH
7407: NOP4
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: NOP4
7425: PPUSH
7426: NOP4
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: NOP4
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: NOP4
7446: PPUSH
7447: NOP4
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: NOP4
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: NOP4
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: NOP4
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: NOP4
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: NOP4
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: NOP4
7519: PUSH
7520: NOP4
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: NOP4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: NOP4
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: NOP4
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: NOP4
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: NOP4
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: NOP4
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: NOP4
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: NOP4
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: NOP4
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: NOP4
7785: PUSH
7786: NOP4
7790: PPUSH
7791: NOP4
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: NOP4
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: NOP4
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: NOP4
7858: PPUSH
7859: NOP4
7863: PPUSH
7864: NOP4
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: NOP4
// until MC_GetProduceList ( base ) = 0 ;
7875: NOP4
7879: PPUSH
7880: NOP4
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: NOP4
// for i = 1 to coords do
7897: NOP4
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: NOP4
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: NOP4
7919: PUSH
7920: NOP4
7924: PPUSH
7925: NOP4
7929: PUSH
7930: NOP4
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: NOP4
7944: PUSH
7945: NOP4
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: NOP4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: NOP4
7971: PUSH
7972: NOP4
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: NOP4
7983: PUSH
7984: NOP4
7988: ST_TO_ADDR
// target := i ;
7989: NOP4
7993: PUSH
7994: NOP4
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: NOP4
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: NOP4
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: NOP4
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: NOP4
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: NOP4
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: NOP4
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: NOP4
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: NOP4
8209: PPUSH
8210: NOP4
8214: PUSH
8215: NOP4
8219: ARRAY
8220: PPUSH
8221: NOP4
8225: PPUSH
8226: NOP4
8230: PPUSH
8231: NOP4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: NOP4
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: NOP4
8253: PUSH
8254: NOP4
8258: EQUAL
8259: AND
8260: PUSH
8261: NOP4
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: NOP4
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: NOP4
8286: PUSH
8287: NOP4
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: NOP4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: NOP4
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: NOP4
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: NOP4
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: NOP4
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: NOP4
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: NOP4
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: NOP4
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: NOP4
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: NOP4
8512: PUSH
8513: NOP4
8517: PPUSH
8518: NOP4
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: NOP4
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: NOP4
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: NOP4
8583: PPUSH
8584: NOP4
8588: PPUSH
8589: NOP4
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: NOP4
// until MC_GetProduceList ( base ) = 0 ;
8600: NOP4
8604: PPUSH
8605: NOP4
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: NOP4
// for i = 1 to coords do
8622: NOP4
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: NOP4
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: NOP4
8644: PUSH
8645: NOP4
8649: PPUSH
8650: NOP4
8654: PUSH
8655: NOP4
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: NOP4
8669: PUSH
8670: NOP4
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: NOP4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: NOP4
8696: PUSH
8697: NOP4
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: NOP4
8708: PUSH
8709: NOP4
8713: ST_TO_ADDR
// target := i ;
8714: NOP4
8718: PUSH
8719: NOP4
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: NOP4
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: NOP4
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: NOP4
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: NOP4
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: NOP4
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: NOP4
8854: PPUSH
8855: NOP4
8859: PUSH
8860: NOP4
8864: ARRAY
8865: PPUSH
8866: NOP4
8870: PPUSH
8871: NOP4
8875: PPUSH
8876: NOP4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: NOP4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: NOP4
8899: PPUSH
8900: NOP4
8904: PPUSH
8905: NOP4
// artifact_get := true ;
8909: NOP4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: NOP4
8928: PUSH
8929: NOP4
8933: PPUSH
8934: NOP4
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: NOP4
8943: PUSH
8944: NOP4
8948: IN
8949: NOT
8950: PUSH
8951: NOP4
8955: PUSH
8956: NOP4
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: NOP4
8968: PPUSH
8969: NOP4
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: NOP4
8983: PPUSH
8984: NOP4
// if side in mc_sides then
8988: NOP4
8992: PUSH
8993: NOP4
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: NOP4
9004: PUSH
9005: NOP4
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: NOP4
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: NOP4
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: NOP4
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: NOP4
9038: PPUSH
9039: NOP4
// if multi_commanders and multi_custom_commanders then
9043: NOP4
9047: PUSH
9048: NOP4
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: NOP4
9059: PUSH
9060: NOP4
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: NOP4
9071: PUSH
9072: NOP4
9076: PPUSH
9077: NOP4
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: NOP4
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: NOP4
9094: PUSH
9095: NOP4
9099: PUSH
9100: NOP4
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: NOP4
9110: PPUSH
9111: NOP4
// end ; MCE_UnitDestroyed ( un ) ;
9115: NOP4
9119: PPUSH
9120: NOP4
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: NOP4
9131: PPUSH
9132: NOP4
9136: PPUSH
9137: NOP4
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: NOP4
9152: PPUSH
9153: NOP4
9157: PUSH
9158: NOP4
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: NOP4
9169: PPUSH
9170: NOP4
9174: PPUSH
9175: NOP4
9179: PPUSH
9180: NOP4
9184: PPUSH
9185: NOP4
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: NOP4
9193: PPUSH
9194: NOP4
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: NOP4
9207: PPUSH
9208: NOP4
9212: PUSH
9213: NOP4
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: NOP4
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: NOP4
9232: PPUSH
9233: NOP4
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: NOP4
// base_names := Delete ( base_names , 1 ) ;
9246: NOP4
9250: PUSH
9251: NOP4
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: NOP4
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: NOP4
9268: PPUSH
9269: NOP4
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: NOP4
9280: PPUSH
9281: NOP4
9285: PPUSH
9286: NOP4
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: NOP4
9297: PPUSH
9298: NOP4
9302: PPUSH
9303: NOP4
9307: PPUSH
9308: NOP4
9312: PPUSH
9313: NOP4
9317: PPUSH
9318: NOP4
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: NOP4
9334: PUSH
9335: NOP4
9339: PPUSH
9340: NOP4
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: NOP4
9349: PUSH
9350: NOP4
9354: IN
9355: NOT
9356: PUSH
9357: NOP4
9361: PUSH
9362: NOP4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: NOP4
9374: PPUSH
9375: NOP4
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: NOP4
9383: PPUSH
9384: NOP4
9388: PPUSH
9389: NOP4
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: NOP4
9400: PPUSH
9401: NOP4
9405: PPUSH
9406: NOP4
9410: PPUSH
9411: NOP4
9415: PPUSH
9416: NOP4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: NOP4
9427: PPUSH
9428: NOP4
9432: PPUSH
9433: NOP4
9437: PPUSH
9438: NOP4
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: NOP4
9449: PPUSH
9450: NOP4
9454: PPUSH
9455: NOP4
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: NOP4
9466: PPUSH
9467: NOP4
9471: PPUSH
9472: NOP4
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: NOP4
9483: PPUSH
9484: NOP4
9488: PPUSH
9489: NOP4
9493: PPUSH
9494: NOP4
9498: PPUSH
9499: NOP4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: NOP4
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: NOP4
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: NOP4
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: NOP4
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: NOP4
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: NOP4
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: NOP4
9594: PPUSH
9595: NOP4
// x := 5 ;
9599: NOP4
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: NOP4
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: NOP4
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: NOP4
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: NOP4
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: NOP4
9656: PUSH
9657: NOP4
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: NOP4
9668: PPUSH
9669: NOP4
9673: PUSH
9674: NOP4
9678: PUSH
9679: NOP4
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: NOP4
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: NOP4
// end ; for i in areas do
9704: NOP4
9708: PUSH
9709: NOP4
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: NOP4
// CreateCratesArea ( x , i , true ) ;
9724: NOP4
9728: PPUSH
9729: NOP4
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: NOP4
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: NOP4
9749: PUSH
9750: NOP4
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: NOP4
9763: PUSH
9764: NOP4
9768: PUSH
9769: NOP4
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: NOP4
9783: PUSH
9784: NOP4
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: NOP4
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: NOP4
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: NOP4
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: NOP4
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: NOP4
9833: NOT
9834: PUSH
9835: NOP4
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: NOP4
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: NOP4
9865: PUSH
9866: NOP4
9870: PUSH
9871: NOP4
9875: STR
9876: PPUSH
9877: NOP4
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: NOP4
9888: PUSH
9889: NOP4
9893: PPUSH
9894: NOP4
9898: ST_TO_ADDR
// result := unit ;
9899: NOP4
9903: PUSH
9904: NOP4
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: NOP4
9922: NOT
9923: PUSH
9924: NOP4
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10702
// case nation of nation_american :
9934: NOP4
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: NOP4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10626
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10395
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10170: NOP4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: LD_INT 88
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: ST_TO_ADDR
10393: GO 10626
10395: LD_INT 3
10397: DOUBLE
10398: EQUAL
10399: IFTRUE 10403
10401: GO 10625
10403: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10404: NOP4
10408: PUSH
10409: LD_INT 46
10411: PUSH
10412: LD_INT 47
10414: PUSH
10415: LD_INT 1
10417: PUSH
10418: LD_INT 2
10420: PUSH
10421: LD_INT 82
10423: PUSH
10424: LD_INT 83
10426: PUSH
10427: LD_INT 84
10429: PUSH
10430: LD_INT 85
10432: PUSH
10433: LD_INT 86
10435: PUSH
10436: LD_INT 11
10438: PUSH
10439: LD_INT 9
10441: PUSH
10442: LD_INT 20
10444: PUSH
10445: LD_INT 19
10447: PUSH
10448: LD_INT 21
10450: PUSH
10451: LD_INT 24
10453: PUSH
10454: LD_INT 22
10456: PUSH
10457: LD_INT 25
10459: PUSH
10460: LD_INT 28
10462: PUSH
10463: LD_INT 29
10465: PUSH
10466: LD_INT 30
10468: PUSH
10469: LD_INT 31
10471: PUSH
10472: LD_INT 37
10474: PUSH
10475: LD_INT 38
10477: PUSH
10478: LD_INT 32
10480: PUSH
10481: LD_INT 27
10483: PUSH
10484: LD_INT 33
10486: PUSH
10487: LD_INT 69
10489: PUSH
10490: LD_INT 39
10492: PUSH
10493: LD_INT 34
10495: PUSH
10496: LD_INT 40
10498: PUSH
10499: LD_INT 71
10501: PUSH
10502: LD_INT 23
10504: PUSH
10505: LD_INT 44
10507: PUSH
10508: LD_INT 48
10510: PUSH
10511: LD_INT 49
10513: PUSH
10514: LD_INT 50
10516: PUSH
10517: LD_INT 51
10519: PUSH
10520: LD_INT 52
10522: PUSH
10523: LD_INT 53
10525: PUSH
10526: LD_INT 54
10528: PUSH
10529: LD_INT 55
10531: PUSH
10532: LD_INT 56
10534: PUSH
10535: LD_INT 57
10537: PUSH
10538: LD_INT 58
10540: PUSH
10541: LD_INT 59
10543: PUSH
10544: LD_INT 63
10546: PUSH
10547: LD_INT 64
10549: PUSH
10550: LD_INT 65
10552: PUSH
10553: LD_INT 82
10555: PUSH
10556: LD_INT 83
10558: PUSH
10559: LD_INT 84
10561: PUSH
10562: LD_INT 85
10564: PUSH
10565: LD_INT 86
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: ST_TO_ADDR
10623: GO 10626
10625: POP
// if state > - 1 and state < 3 then
10626: NOP4
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: GREATER
10635: PUSH
10636: NOP4
10640: PUSH
10641: LD_INT 3
10643: LESS
10644: AND
10645: IFFALSE 10702
// for i in result do
10647: NOP4
10651: PUSH
10652: NOP4
10656: PUSH
10657: FOR_IN
10658: IFFALSE 10700
// if GetTech ( i , side ) <> state then
10660: NOP4
10664: PPUSH
10665: NOP4
10669: PPUSH
10670: NOP4
10674: PUSH
10675: NOP4
10679: NONEQUAL
10680: IFFALSE 10698
// result := result diff i ;
10682: NOP4
10686: PUSH
10687: NOP4
10691: PUSH
10692: NOP4
10696: DIFF
10697: ST_TO_ADDR
10698: GO 10657
10700: POP
10701: POP
// end ;
10702: LD_VAR 0 4
10706: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// result := true ;
10712: NOP4
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10720: NOP4
10724: PUSH
10725: NOP4
10729: PPUSH
10730: NOP4
10734: ST_TO_ADDR
// if not tmp then
10735: NOP4
10739: NOT
10740: IFFALSE 10744
// exit ;
10742: GO 10793
// for i in tmp do
10744: NOP4
10748: PUSH
10749: NOP4
10753: PUSH
10754: FOR_IN
10755: IFFALSE 10791
// if GetTech ( i , side ) <> state_researched then
10757: NOP4
10761: PPUSH
10762: NOP4
10766: PPUSH
10767: NOP4
10771: PUSH
10772: LD_INT 2
10774: NONEQUAL
10775: IFFALSE 10789
// begin result := false ;
10777: NOP4
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// exit ;
10785: POP
10786: POP
10787: GO 10793
// end ;
10789: GO 10754
10791: POP
10792: POP
// end ;
10793: LD_VAR 0 3
10797: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10798: LD_INT 0
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10813: NOP4
10817: NOT
10818: PUSH
10819: NOP4
10823: PPUSH
10824: NOP4
10828: PUSH
10829: LD_INT 9
10831: NONEQUAL
10832: OR
10833: IFFALSE 10837
// exit ;
10835: GO 11410
// side := GetSide ( unit ) ;
10837: NOP4
10841: PUSH
10842: NOP4
10846: PPUSH
10847: NOP4
10851: ST_TO_ADDR
// tech_space := tech_spacanom ;
10852: NOP4
10856: PUSH
10857: LD_INT 29
10859: ST_TO_ADDR
// tech_time := tech_taurad ;
10860: NOP4
10864: PUSH
10865: LD_INT 28
10867: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10868: NOP4
10872: PUSH
10873: NOP4
10877: PPUSH
10878: NOP4
10882: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10883: NOP4
10887: PPUSH
10888: NOP4
10892: PUSH
10893: LD_INT 2
10895: EQUAL
10896: IFFALSE 10900
// exit ;
10898: GO 11410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10900: NOP4
10904: PUSH
10905: LD_INT 81
10907: PUSH
10908: NOP4
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PUSH
10917: LD_INT 3
10919: PUSH
10920: LD_INT 21
10922: PUSH
10923: LD_INT 3
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PPUSH
10938: NOP4
10942: ST_TO_ADDR
// if not tmp then
10943: NOP4
10947: NOT
10948: IFFALSE 10952
// exit ;
10950: GO 11410
// if in_unit then
10952: NOP4
10956: IFFALSE 10980
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10958: NOP4
10962: PUSH
10963: NOP4
10967: PPUSH
10968: NOP4
10972: PPUSH
10973: NOP4
10977: ST_TO_ADDR
10978: GO 11000
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10980: NOP4
10984: PUSH
10985: NOP4
10989: PPUSH
10990: NOP4
10994: PPUSH
10995: NOP4
10999: ST_TO_ADDR
// if not enemy then
11000: NOP4
11004: NOT
11005: IFFALSE 11009
// exit ;
11007: GO 11410
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11009: NOP4
11013: PUSH
11014: NOP4
11018: PPUSH
11019: NOP4
11023: PPUSH
11024: NOP4
11028: PUSH
11029: LD_INT 13
11031: GREATER
11032: AND
11033: PUSH
11034: NOP4
11038: PPUSH
11039: NOP4
11043: PPUSH
11044: NOP4
11048: PUSH
11049: LD_INT 12
11051: GREATER
11052: OR
11053: IFFALSE 11057
// exit ;
11055: GO 11410
// missile := [ 1 ] ;
11057: NOP4
11061: PUSH
11062: LD_INT 1
11064: PUSH
11065: EMPTY
11066: LIST
11067: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11068: NOP4
11072: PPUSH
11073: NOP4
11077: PPUSH
11078: NOP4
11082: IFFALSE 11111
// missile := Replace ( missile , missile + 1 , 2 ) ;
11084: NOP4
11088: PUSH
11089: NOP4
11093: PPUSH
11094: NOP4
11098: PUSH
11099: LD_INT 1
11101: PLUS
11102: PPUSH
11103: LD_INT 2
11105: PPUSH
11106: NOP4
11110: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11111: NOP4
11115: PPUSH
11116: NOP4
11120: PPUSH
11121: NOP4
11125: PUSH
11126: NOP4
11130: PPUSH
11131: NOP4
11135: PPUSH
11136: NOP4
11140: PPUSH
11141: NOP4
11145: NOT
11146: AND
11147: IFFALSE 11176
// missile := Replace ( missile , missile + 1 , 3 ) ;
11149: NOP4
11153: PUSH
11154: NOP4
11158: PPUSH
11159: NOP4
11163: PUSH
11164: LD_INT 1
11166: PLUS
11167: PPUSH
11168: LD_INT 3
11170: PPUSH
11171: NOP4
11175: ST_TO_ADDR
// if missile < 2 then
11176: NOP4
11180: PUSH
11181: LD_INT 2
11183: LESS
11184: IFFALSE 11188
// exit ;
11186: GO 11410
// x := GetX ( enemy ) ;
11188: NOP4
11192: PUSH
11193: NOP4
11197: PPUSH
11198: NOP4
11202: ST_TO_ADDR
// y := GetY ( enemy ) ;
11203: NOP4
11207: PUSH
11208: NOP4
11212: PPUSH
11213: NOP4
11217: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11218: NOP4
11222: PUSH
11223: NOP4
11227: PUSH
11228: LD_INT 1
11230: NEG
11231: PPUSH
11232: LD_INT 1
11234: PPUSH
11235: NOP4
11239: PLUS
11240: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11241: NOP4
11245: PUSH
11246: NOP4
11250: PUSH
11251: LD_INT 1
11253: NEG
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: NOP4
11262: PLUS
11263: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11264: NOP4
11268: PPUSH
11269: NOP4
11273: PPUSH
11274: NOP4
11278: NOT
11279: IFFALSE 11301
// begin _x := x ;
11281: NOP4
11285: PUSH
11286: NOP4
11290: ST_TO_ADDR
// _y := y ;
11291: NOP4
11295: PUSH
11296: NOP4
11300: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11301: NOP4
11305: PUSH
11306: LD_INT 1
11308: PPUSH
11309: NOP4
11313: PPUSH
11314: NOP4
11318: ST_TO_ADDR
// case i of 1 :
11319: NOP4
11323: PUSH
11324: LD_INT 1
11326: DOUBLE
11327: EQUAL
11328: IFTRUE 11332
11330: GO 11349
11332: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11333: NOP4
11337: PPUSH
11338: NOP4
11342: PPUSH
11343: NOP4
11347: GO 11410
11349: LD_INT 2
11351: DOUBLE
11352: EQUAL
11353: IFTRUE 11357
11355: GO 11379
11357: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11358: NOP4
11362: PPUSH
11363: NOP4
11367: PPUSH
11368: NOP4
11372: PPUSH
11373: NOP4
11377: GO 11410
11379: LD_INT 3
11381: DOUBLE
11382: EQUAL
11383: IFTRUE 11387
11385: GO 11409
11387: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11388: NOP4
11392: PPUSH
11393: NOP4
11397: PPUSH
11398: NOP4
11402: PPUSH
11403: NOP4
11407: GO 11410
11409: POP
// end ;
11410: LD_VAR 0 2
11414: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11415: LD_INT 0
11417: PPUSH
11418: PPUSH
11419: PPUSH
11420: PPUSH
11421: PPUSH
11422: PPUSH
// if not unit or not building then
11423: NOP4
11427: NOT
11428: PUSH
11429: NOP4
11433: NOT
11434: OR
11435: IFFALSE 11439
// exit ;
11437: GO 11597
// x := GetX ( building ) ;
11439: NOP4
11443: PUSH
11444: NOP4
11448: PPUSH
11449: NOP4
11453: ST_TO_ADDR
// y := GetY ( building ) ;
11454: NOP4
11458: PUSH
11459: NOP4
11463: PPUSH
11464: NOP4
11468: ST_TO_ADDR
// for i = 0 to 5 do
11469: NOP4
11473: PUSH
11474: DOUBLE
11475: LD_INT 0
11477: DEC
11478: ST_TO_ADDR
11479: LD_INT 5
11481: PUSH
11482: FOR_TO
11483: IFFALSE 11595
// begin _x := ShiftX ( x , i , 3 ) ;
11485: NOP4
11489: PUSH
11490: NOP4
11494: PPUSH
11495: NOP4
11499: PPUSH
11500: LD_INT 3
11502: PPUSH
11503: NOP4
11507: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11508: NOP4
11512: PUSH
11513: NOP4
11517: PPUSH
11518: NOP4
11522: PPUSH
11523: LD_INT 3
11525: PPUSH
11526: NOP4
11530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11531: NOP4
11535: PPUSH
11536: NOP4
11540: PPUSH
11541: NOP4
11545: NOT
11546: IFFALSE 11550
// continue ;
11548: GO 11482
// if HexInfo ( _x , _y ) = 0 then
11550: NOP4
11554: PPUSH
11555: NOP4
11559: PPUSH
11560: NOP4
11564: PUSH
11565: LD_INT 0
11567: EQUAL
11568: IFFALSE 11593
// begin ComMoveXY ( unit , _x , _y ) ;
11570: NOP4
11574: PPUSH
11575: NOP4
11579: PPUSH
11580: NOP4
11584: PPUSH
11585: NOP4
// exit ;
11589: POP
11590: POP
11591: GO 11597
// end ; end ;
11593: GO 11482
11595: POP
11596: POP
// end ;
11597: LD_VAR 0 3
11601: RET
// export function ScanBase ( side , base_area ) ; begin
11602: LD_INT 0
11604: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11605: NOP4
11609: PUSH
11610: NOP4
11614: PPUSH
11615: LD_INT 81
11617: PUSH
11618: NOP4
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PPUSH
11627: NOP4
11631: ST_TO_ADDR
// end ;
11632: LD_VAR 0 3
11636: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11637: LD_INT 0
11639: PPUSH
11640: PPUSH
11641: PPUSH
11642: PPUSH
// result := false ;
11643: NOP4
11647: PUSH
11648: LD_INT 0
11650: ST_TO_ADDR
// side := GetSide ( unit ) ;
11651: NOP4
11655: PUSH
11656: NOP4
11660: PPUSH
11661: NOP4
11665: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11666: NOP4
11670: PUSH
11671: NOP4
11675: PPUSH
11676: NOP4
11680: ST_TO_ADDR
// case nat of 1 :
11681: NOP4
11685: PUSH
11686: LD_INT 1
11688: DOUBLE
11689: EQUAL
11690: IFTRUE 11694
11692: GO 11705
11694: POP
// tech := tech_lassight ; 2 :
11695: NOP4
11699: PUSH
11700: LD_INT 12
11702: ST_TO_ADDR
11703: GO 11744
11705: LD_INT 2
11707: DOUBLE
11708: EQUAL
11709: IFTRUE 11713
11711: GO 11724
11713: POP
// tech := tech_mortar ; 3 :
11714: NOP4
11718: PUSH
11719: LD_INT 41
11721: ST_TO_ADDR
11722: GO 11744
11724: LD_INT 3
11726: DOUBLE
11727: EQUAL
11728: IFTRUE 11732
11730: GO 11743
11732: POP
// tech := tech_bazooka ; end ;
11733: NOP4
11737: PUSH
11738: LD_INT 44
11740: ST_TO_ADDR
11741: GO 11744
11743: POP
// if Researched ( side , tech ) then
11744: NOP4
11748: PPUSH
11749: NOP4
11753: PPUSH
11754: NOP4
11758: IFFALSE 11785
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11760: NOP4
11764: PUSH
11765: LD_INT 5
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: LD_INT 9
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: LIST
11778: PUSH
11779: NOP4
11783: ARRAY
11784: ST_TO_ADDR
// end ;
11785: LD_VAR 0 2
11789: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11790: LD_INT 0
11792: PPUSH
11793: PPUSH
11794: PPUSH
// if not mines then
11795: NOP4
11799: NOT
11800: IFFALSE 11804
// exit ;
11802: GO 11948
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11804: NOP4
11808: PUSH
11809: LD_INT 81
11811: PUSH
11812: NOP4
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: LD_INT 3
11823: PUSH
11824: LD_INT 21
11826: PUSH
11827: LD_INT 3
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PPUSH
11842: NOP4
11846: ST_TO_ADDR
// for i in mines do
11847: NOP4
11851: PUSH
11852: NOP4
11856: PUSH
11857: FOR_IN
11858: IFFALSE 11946
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11860: NOP4
11864: PUSH
11865: LD_INT 1
11867: ARRAY
11868: PPUSH
11869: NOP4
11873: PUSH
11874: LD_INT 2
11876: ARRAY
11877: PPUSH
11878: NOP4
11882: NOT
11883: IFFALSE 11887
// continue ;
11885: GO 11857
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11887: NOP4
11891: PUSH
11892: LD_INT 1
11894: ARRAY
11895: PPUSH
11896: NOP4
11900: PUSH
11901: LD_INT 2
11903: ARRAY
11904: PPUSH
11905: NOP4
11909: PUSH
11910: NOP4
11914: IN
11915: IFFALSE 11944
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11917: NOP4
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: NOP4
11930: PUSH
11931: LD_INT 2
11933: ARRAY
11934: PPUSH
11935: NOP4
11939: PPUSH
11940: NOP4
// end ;
11944: GO 11857
11946: POP
11947: POP
// end ;
11948: LD_VAR 0 3
11952: RET
// export function Count ( array ) ; var i ; begin
11953: LD_INT 0
11955: PPUSH
11956: PPUSH
// result := 0 ;
11957: NOP4
11961: PUSH
11962: LD_INT 0
11964: ST_TO_ADDR
// for i in array do
11965: NOP4
11969: PUSH
11970: NOP4
11974: PUSH
11975: FOR_IN
11976: IFFALSE 12000
// if i then
11978: NOP4
11982: IFFALSE 11998
// result := result + 1 ;
11984: NOP4
11988: PUSH
11989: NOP4
11993: PUSH
11994: LD_INT 1
11996: PLUS
11997: ST_TO_ADDR
11998: GO 11975
12000: POP
12001: POP
// end ;
12002: LD_VAR 0 2
12006: RET
// export function IsEmpty ( building ) ; begin
12007: LD_INT 0
12009: PPUSH
// if not building then
12010: NOP4
12014: NOT
12015: IFFALSE 12019
// exit ;
12017: GO 12062
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12019: NOP4
12023: PUSH
12024: NOP4
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: NOP4
12036: PPUSH
12037: NOP4
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 58
12048: PUSH
12049: EMPTY
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PPUSH
12056: NOP4
12060: IN
12061: ST_TO_ADDR
// end ;
12062: LD_VAR 0 2
12066: RET
// export function IsNotFull ( building ) ; var places ; begin
12067: LD_INT 0
12069: PPUSH
12070: PPUSH
// if not building then
12071: NOP4
12075: NOT
12076: IFFALSE 12080
// exit ;
12078: GO 12251
// result := false ;
12080: NOP4
12084: PUSH
12085: LD_INT 0
12087: ST_TO_ADDR
// places := 0 ;
12088: NOP4
12092: PUSH
12093: LD_INT 0
12095: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
12096: NOP4
12100: PPUSH
12101: NOP4
12105: PUSH
12106: LD_INT 0
12108: DOUBLE
12109: EQUAL
12110: IFTRUE 12168
12112: LD_INT 1
12114: DOUBLE
12115: EQUAL
12116: IFTRUE 12168
12118: LD_INT 6
12120: DOUBLE
12121: EQUAL
12122: IFTRUE 12168
12124: LD_INT 7
12126: DOUBLE
12127: EQUAL
12128: IFTRUE 12168
12130: LD_INT 8
12132: DOUBLE
12133: EQUAL
12134: IFTRUE 12168
12136: LD_INT 4
12138: DOUBLE
12139: EQUAL
12140: IFTRUE 12168
12142: LD_INT 5
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12168
12148: LD_INT 2
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12168
12154: LD_INT 3
12156: DOUBLE
12157: EQUAL
12158: IFTRUE 12168
12160: LD_INT 35
12162: DOUBLE
12163: EQUAL
12164: IFTRUE 12168
12166: GO 12179
12168: POP
// places := 6 ; b_bunker , b_breastwork :
12169: NOP4
12173: PUSH
12174: LD_INT 6
12176: ST_TO_ADDR
12177: GO 12224
12179: LD_INT 32
12181: DOUBLE
12182: EQUAL
12183: IFTRUE 12193
12185: LD_INT 31
12187: DOUBLE
12188: EQUAL
12189: IFTRUE 12193
12191: GO 12204
12193: POP
// places := 1 ; b_control_tower :
12194: NOP4
12198: PUSH
12199: LD_INT 1
12201: ST_TO_ADDR
12202: GO 12224
12204: LD_INT 36
12206: DOUBLE
12207: EQUAL
12208: IFTRUE 12212
12210: GO 12223
12212: POP
// places := 3 ; end ;
12213: NOP4
12217: PUSH
12218: LD_INT 3
12220: ST_TO_ADDR
12221: GO 12224
12223: POP
// if places then
12224: NOP4
12228: IFFALSE 12251
// result := UnitsInside ( building ) < places ;
12230: NOP4
12234: PUSH
12235: NOP4
12239: PPUSH
12240: NOP4
12244: PUSH
12245: NOP4
12249: LESS
12250: ST_TO_ADDR
// end ;
12251: LD_VAR 0 2
12255: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12256: LD_INT 0
12258: PPUSH
12259: PPUSH
12260: PPUSH
12261: PPUSH
// tmp := [ ] ;
12262: NOP4
12266: PUSH
12267: EMPTY
12268: ST_TO_ADDR
// list := [ ] ;
12269: NOP4
12273: PUSH
12274: EMPTY
12275: ST_TO_ADDR
// for i = 16 to 25 do
12276: NOP4
12280: PUSH
12281: DOUBLE
12282: LD_INT 16
12284: DEC
12285: ST_TO_ADDR
12286: LD_INT 25
12288: PUSH
12289: FOR_TO
12290: IFFALSE 12363
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12292: NOP4
12296: PUSH
12297: NOP4
12301: PUSH
12302: LD_INT 22
12304: PUSH
12305: NOP4
12309: PPUSH
12310: NOP4
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 91
12321: PUSH
12322: NOP4
12326: PUSH
12327: LD_INT 6
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: LIST
12334: PUSH
12335: LD_INT 30
12337: PUSH
12338: NOP4
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: LIST
12351: PUSH
12352: EMPTY
12353: LIST
12354: PPUSH
12355: NOP4
12359: ADD
12360: ST_TO_ADDR
12361: GO 12289
12363: POP
12364: POP
// for i = 1 to tmp do
12365: NOP4
12369: PUSH
12370: DOUBLE
12371: LD_INT 1
12373: DEC
12374: ST_TO_ADDR
12375: NOP4
12379: PUSH
12380: FOR_TO
12381: IFFALSE 12469
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12383: NOP4
12387: PUSH
12388: NOP4
12392: PUSH
12393: NOP4
12397: PUSH
12398: NOP4
12402: ARRAY
12403: PPUSH
12404: NOP4
12408: PUSH
12409: NOP4
12413: PUSH
12414: NOP4
12418: ARRAY
12419: PPUSH
12420: NOP4
12424: PUSH
12425: NOP4
12429: PUSH
12430: NOP4
12434: ARRAY
12435: PPUSH
12436: NOP4
12440: PUSH
12441: NOP4
12445: PUSH
12446: NOP4
12450: ARRAY
12451: PPUSH
12452: NOP4
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: PUSH
12463: EMPTY
12464: LIST
12465: ADD
12466: ST_TO_ADDR
12467: GO 12380
12469: POP
12470: POP
// result := list ;
12471: NOP4
12475: PUSH
12476: NOP4
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 2
12485: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
12491: PPUSH
12492: PPUSH
12493: PPUSH
12494: PPUSH
// if not factory then
12495: NOP4
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 13097
// if control = control_apeman then
12504: NOP4
12508: PUSH
12509: LD_INT 5
12511: EQUAL
12512: IFFALSE 12621
// begin tmp := UnitsInside ( factory ) ;
12514: NOP4
12518: PUSH
12519: NOP4
12523: PPUSH
12524: NOP4
12528: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12529: NOP4
12533: PPUSH
12534: LD_INT 25
12536: PUSH
12537: LD_INT 12
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: PPUSH
12544: NOP4
12548: NOT
12549: IFFALSE 12559
// control := control_manual ;
12551: NOP4
12555: PUSH
12556: LD_INT 1
12558: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12559: NOP4
12563: PUSH
12564: NOP4
12568: PPUSH
12569: NOP4
12573: ST_TO_ADDR
// if tmp then
12574: NOP4
12578: IFFALSE 12621
// begin for i in tmp do
12580: NOP4
12584: PUSH
12585: NOP4
12589: PUSH
12590: FOR_IN
12591: IFFALSE 12619
// if i [ 1 ] = b_ext_radio then
12593: NOP4
12597: PUSH
12598: LD_INT 1
12600: ARRAY
12601: PUSH
12602: LD_INT 22
12604: EQUAL
12605: IFFALSE 12617
// begin control := control_remote ;
12607: NOP4
12611: PUSH
12612: LD_INT 2
12614: ST_TO_ADDR
// break ;
12615: GO 12619
// end ;
12617: GO 12590
12619: POP
12620: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12621: NOP4
12625: PPUSH
12626: NOP4
12630: PPUSH
12631: NOP4
12635: PPUSH
12636: NOP4
12640: PPUSH
12641: NOP4
12645: PPUSH
12646: NOP4
12650: IFFALSE 12685
// begin result := [ chassis , engine , control , weapon ] ;
12652: NOP4
12656: PUSH
12657: NOP4
12661: PUSH
12662: NOP4
12666: PUSH
12667: NOP4
12671: PUSH
12672: NOP4
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: ST_TO_ADDR
// exit ;
12683: GO 13097
// end ; _chassis := AvailableChassisList ( factory ) ;
12685: NOP4
12689: PUSH
12690: NOP4
12694: PPUSH
12695: NOP4
12699: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12700: NOP4
12704: PUSH
12705: NOP4
12709: PPUSH
12710: NOP4
12714: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12715: NOP4
12719: PUSH
12720: NOP4
12724: PPUSH
12725: NOP4
12729: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12730: NOP4
12734: PUSH
12735: NOP4
12739: PPUSH
12740: NOP4
12744: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12745: NOP4
12749: NOT
12750: PUSH
12751: NOP4
12755: NOT
12756: OR
12757: PUSH
12758: NOP4
12762: NOT
12763: OR
12764: PUSH
12765: NOP4
12769: NOT
12770: OR
12771: IFFALSE 12806
// begin result := [ chassis , engine , control , weapon ] ;
12773: NOP4
12777: PUSH
12778: NOP4
12782: PUSH
12783: NOP4
12787: PUSH
12788: NOP4
12792: PUSH
12793: NOP4
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: ST_TO_ADDR
// exit ;
12804: GO 13097
// end ; if not chassis in _chassis then
12806: NOP4
12810: PUSH
12811: NOP4
12815: IN
12816: NOT
12817: IFFALSE 12843
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12819: NOP4
12823: PUSH
12824: NOP4
12828: PUSH
12829: LD_INT 1
12831: PPUSH
12832: NOP4
12836: PPUSH
12837: NOP4
12841: ARRAY
12842: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12843: NOP4
12847: PPUSH
12848: NOP4
12852: PPUSH
12853: NOP4
12857: NOT
12858: IFFALSE 12917
// repeat engine := _engine [ 1 ] ;
12860: NOP4
12864: PUSH
12865: NOP4
12869: PUSH
12870: LD_INT 1
12872: ARRAY
12873: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12874: NOP4
12878: PUSH
12879: NOP4
12883: PPUSH
12884: LD_INT 1
12886: PPUSH
12887: NOP4
12891: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12892: NOP4
12896: PPUSH
12897: NOP4
12901: PPUSH
12902: NOP4
12906: PUSH
12907: NOP4
12911: PUSH
12912: EMPTY
12913: EQUAL
12914: OR
12915: IFFALSE 12860
// if not control in _control then
12917: NOP4
12921: PUSH
12922: NOP4
12926: IN
12927: NOT
12928: IFFALSE 12954
// control := _control [ rand ( 1 , _control ) ] ;
12930: NOP4
12934: PUSH
12935: NOP4
12939: PUSH
12940: LD_INT 1
12942: PPUSH
12943: NOP4
12947: PPUSH
12948: NOP4
12952: ARRAY
12953: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12954: NOP4
12958: PPUSH
12959: NOP4
12963: PPUSH
12964: NOP4
12968: NOT
12969: IFFALSE 13028
// repeat weapon := _weapon [ 1 ] ;
12971: NOP4
12975: PUSH
12976: NOP4
12980: PUSH
12981: LD_INT 1
12983: ARRAY
12984: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12985: NOP4
12989: PUSH
12990: NOP4
12994: PPUSH
12995: LD_INT 1
12997: PPUSH
12998: NOP4
13002: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
13003: NOP4
13007: PPUSH
13008: NOP4
13012: PPUSH
13013: NOP4
13017: PUSH
13018: NOP4
13022: PUSH
13023: EMPTY
13024: EQUAL
13025: OR
13026: IFFALSE 12971
// result := [ ] ;
13028: NOP4
13032: PUSH
13033: EMPTY
13034: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13035: NOP4
13039: PPUSH
13040: NOP4
13044: PPUSH
13045: NOP4
13049: PPUSH
13050: NOP4
13054: PPUSH
13055: NOP4
13059: PPUSH
13060: NOP4
13064: IFFALSE 13097
// result := [ chassis , engine , control , weapon ] ;
13066: NOP4
13070: PUSH
13071: NOP4
13075: PUSH
13076: NOP4
13080: PUSH
13081: NOP4
13085: PUSH
13086: NOP4
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: ST_TO_ADDR
// end ;
13097: LD_VAR 0 6
13101: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
13102: LD_INT 0
13104: PPUSH
// if not chassis or not engine then
13105: NOP4
13109: NOT
13110: PUSH
13111: NOP4
13115: NOT
13116: OR
13117: IFFALSE 13121
// exit ;
13119: GO 13317
// case engine of engine_solar :
13121: NOP4
13125: PUSH
13126: LD_INT 2
13128: DOUBLE
13129: EQUAL
13130: IFTRUE 13134
13132: GO 13172
13134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
13135: NOP4
13139: PUSH
13140: LD_INT 11
13142: PUSH
13143: LD_INT 12
13145: PUSH
13146: LD_INT 13
13148: PUSH
13149: LD_INT 14
13151: PUSH
13152: LD_INT 1
13154: PUSH
13155: LD_INT 2
13157: PUSH
13158: LD_INT 3
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: ST_TO_ADDR
13170: GO 13301
13172: LD_INT 1
13174: DOUBLE
13175: EQUAL
13176: IFTRUE 13180
13178: GO 13242
13180: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13181: NOP4
13185: PUSH
13186: LD_INT 11
13188: PUSH
13189: LD_INT 12
13191: PUSH
13192: LD_INT 13
13194: PUSH
13195: LD_INT 14
13197: PUSH
13198: LD_INT 1
13200: PUSH
13201: LD_INT 2
13203: PUSH
13204: LD_INT 3
13206: PUSH
13207: LD_INT 4
13209: PUSH
13210: LD_INT 5
13212: PUSH
13213: LD_INT 21
13215: PUSH
13216: LD_INT 23
13218: PUSH
13219: LD_INT 22
13221: PUSH
13222: LD_INT 24
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: ST_TO_ADDR
13240: GO 13301
13242: LD_INT 3
13244: DOUBLE
13245: EQUAL
13246: IFTRUE 13250
13248: GO 13300
13250: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13251: NOP4
13255: PUSH
13256: LD_INT 13
13258: PUSH
13259: LD_INT 14
13261: PUSH
13262: LD_INT 2
13264: PUSH
13265: LD_INT 3
13267: PUSH
13268: LD_INT 4
13270: PUSH
13271: LD_INT 5
13273: PUSH
13274: LD_INT 21
13276: PUSH
13277: LD_INT 22
13279: PUSH
13280: LD_INT 23
13282: PUSH
13283: LD_INT 24
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: LIST
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: LIST
13297: ST_TO_ADDR
13298: GO 13301
13300: POP
// result := ( chassis in result ) ;
13301: NOP4
13305: PUSH
13306: NOP4
13310: PUSH
13311: NOP4
13315: IN
13316: ST_TO_ADDR
// end ;
13317: LD_VAR 0 3
13321: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13322: LD_INT 0
13324: PPUSH
// if not chassis or not weapon then
13325: NOP4
13329: NOT
13330: PUSH
13331: NOP4
13335: NOT
13336: OR
13337: IFFALSE 13341
// exit ;
13339: GO 14403
// case weapon of us_machine_gun :
13341: NOP4
13345: PUSH
13346: LD_INT 2
13348: DOUBLE
13349: EQUAL
13350: IFTRUE 13354
13352: GO 13384
13354: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13355: NOP4
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: LD_INT 2
13365: PUSH
13366: LD_INT 3
13368: PUSH
13369: LD_INT 4
13371: PUSH
13372: LD_INT 5
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: ST_TO_ADDR
13382: GO 14387
13384: LD_INT 3
13386: DOUBLE
13387: EQUAL
13388: IFTRUE 13392
13390: GO 13422
13392: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13393: NOP4
13397: PUSH
13398: LD_INT 1
13400: PUSH
13401: LD_INT 2
13403: PUSH
13404: LD_INT 3
13406: PUSH
13407: LD_INT 4
13409: PUSH
13410: LD_INT 5
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: ST_TO_ADDR
13420: GO 14387
13422: LD_INT 11
13424: DOUBLE
13425: EQUAL
13426: IFTRUE 13430
13428: GO 13460
13430: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13431: NOP4
13435: PUSH
13436: LD_INT 1
13438: PUSH
13439: LD_INT 2
13441: PUSH
13442: LD_INT 3
13444: PUSH
13445: LD_INT 4
13447: PUSH
13448: LD_INT 5
13450: PUSH
13451: EMPTY
13452: LIST
13453: LIST
13454: LIST
13455: LIST
13456: LIST
13457: ST_TO_ADDR
13458: GO 14387
13460: LD_INT 4
13462: DOUBLE
13463: EQUAL
13464: IFTRUE 13468
13466: GO 13494
13468: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13469: NOP4
13473: PUSH
13474: LD_INT 2
13476: PUSH
13477: LD_INT 3
13479: PUSH
13480: LD_INT 4
13482: PUSH
13483: LD_INT 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: LIST
13490: LIST
13491: ST_TO_ADDR
13492: GO 14387
13494: LD_INT 5
13496: DOUBLE
13497: EQUAL
13498: IFTRUE 13502
13500: GO 13528
13502: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13503: NOP4
13507: PUSH
13508: LD_INT 2
13510: PUSH
13511: LD_INT 3
13513: PUSH
13514: LD_INT 4
13516: PUSH
13517: LD_INT 5
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: LIST
13524: LIST
13525: ST_TO_ADDR
13526: GO 14387
13528: LD_INT 9
13530: DOUBLE
13531: EQUAL
13532: IFTRUE 13536
13534: GO 13562
13536: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13537: NOP4
13541: PUSH
13542: LD_INT 2
13544: PUSH
13545: LD_INT 3
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: LD_INT 5
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: LIST
13558: LIST
13559: ST_TO_ADDR
13560: GO 14387
13562: LD_INT 7
13564: DOUBLE
13565: EQUAL
13566: IFTRUE 13570
13568: GO 13596
13570: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13571: NOP4
13575: PUSH
13576: LD_INT 2
13578: PUSH
13579: LD_INT 3
13581: PUSH
13582: LD_INT 4
13584: PUSH
13585: LD_INT 5
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: ST_TO_ADDR
13594: GO 14387
13596: LD_INT 12
13598: DOUBLE
13599: EQUAL
13600: IFTRUE 13604
13602: GO 13630
13604: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13605: NOP4
13609: PUSH
13610: LD_INT 2
13612: PUSH
13613: LD_INT 3
13615: PUSH
13616: LD_INT 4
13618: PUSH
13619: LD_INT 5
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: ST_TO_ADDR
13628: GO 14387
13630: LD_INT 13
13632: DOUBLE
13633: EQUAL
13634: IFTRUE 13638
13636: GO 13664
13638: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13639: NOP4
13643: PUSH
13644: LD_INT 2
13646: PUSH
13647: LD_INT 3
13649: PUSH
13650: LD_INT 4
13652: PUSH
13653: LD_INT 5
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: ST_TO_ADDR
13662: GO 14387
13664: LD_INT 14
13666: DOUBLE
13667: EQUAL
13668: IFTRUE 13672
13670: GO 13690
13672: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13673: NOP4
13677: PUSH
13678: LD_INT 4
13680: PUSH
13681: LD_INT 5
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: ST_TO_ADDR
13688: GO 14387
13690: LD_INT 6
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13716
13698: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13699: NOP4
13703: PUSH
13704: LD_INT 4
13706: PUSH
13707: LD_INT 5
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: ST_TO_ADDR
13714: GO 14387
13716: LD_INT 10
13718: DOUBLE
13719: EQUAL
13720: IFTRUE 13724
13722: GO 13742
13724: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13725: NOP4
13729: PUSH
13730: LD_INT 4
13732: PUSH
13733: LD_INT 5
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: ST_TO_ADDR
13740: GO 14387
13742: LD_INT 22
13744: DOUBLE
13745: EQUAL
13746: IFTRUE 13750
13748: GO 13776
13750: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13751: NOP4
13755: PUSH
13756: LD_INT 11
13758: PUSH
13759: LD_INT 12
13761: PUSH
13762: LD_INT 13
13764: PUSH
13765: LD_INT 14
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: ST_TO_ADDR
13774: GO 14387
13776: LD_INT 23
13778: DOUBLE
13779: EQUAL
13780: IFTRUE 13784
13782: GO 13810
13784: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13785: NOP4
13789: PUSH
13790: LD_INT 11
13792: PUSH
13793: LD_INT 12
13795: PUSH
13796: LD_INT 13
13798: PUSH
13799: LD_INT 14
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: ST_TO_ADDR
13808: GO 14387
13810: LD_INT 24
13812: DOUBLE
13813: EQUAL
13814: IFTRUE 13818
13816: GO 13844
13818: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13819: NOP4
13823: PUSH
13824: LD_INT 11
13826: PUSH
13827: LD_INT 12
13829: PUSH
13830: LD_INT 13
13832: PUSH
13833: LD_INT 14
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: ST_TO_ADDR
13842: GO 14387
13844: LD_INT 30
13846: DOUBLE
13847: EQUAL
13848: IFTRUE 13852
13850: GO 13878
13852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13853: NOP4
13857: PUSH
13858: LD_INT 11
13860: PUSH
13861: LD_INT 12
13863: PUSH
13864: LD_INT 13
13866: PUSH
13867: LD_INT 14
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: ST_TO_ADDR
13876: GO 14387
13878: LD_INT 25
13880: DOUBLE
13881: EQUAL
13882: IFTRUE 13886
13884: GO 13904
13886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13887: NOP4
13891: PUSH
13892: LD_INT 13
13894: PUSH
13895: LD_INT 14
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: ST_TO_ADDR
13902: GO 14387
13904: LD_INT 27
13906: DOUBLE
13907: EQUAL
13908: IFTRUE 13912
13910: GO 13930
13912: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13913: NOP4
13917: PUSH
13918: LD_INT 13
13920: PUSH
13921: LD_INT 14
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: ST_TO_ADDR
13928: GO 14387
13930: NOP4
13934: DOUBLE
13935: EQUAL
13936: IFTRUE 13940
13938: GO 13966
13940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13941: NOP4
13945: PUSH
13946: LD_INT 11
13948: PUSH
13949: LD_INT 12
13951: PUSH
13952: LD_INT 13
13954: PUSH
13955: LD_INT 14
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: ST_TO_ADDR
13964: GO 14387
13966: LD_INT 28
13968: DOUBLE
13969: EQUAL
13970: IFTRUE 13974
13972: GO 13992
13974: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13975: NOP4
13979: PUSH
13980: LD_INT 13
13982: PUSH
13983: LD_INT 14
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: ST_TO_ADDR
13990: GO 14387
13992: LD_INT 29
13994: DOUBLE
13995: EQUAL
13996: IFTRUE 14000
13998: GO 14018
14000: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
14001: NOP4
14005: PUSH
14006: LD_INT 13
14008: PUSH
14009: LD_INT 14
14011: PUSH
14012: EMPTY
14013: LIST
14014: LIST
14015: ST_TO_ADDR
14016: GO 14387
14018: LD_INT 31
14020: DOUBLE
14021: EQUAL
14022: IFTRUE 14026
14024: GO 14044
14026: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
14027: NOP4
14031: PUSH
14032: LD_INT 13
14034: PUSH
14035: LD_INT 14
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: ST_TO_ADDR
14042: GO 14387
14044: LD_INT 26
14046: DOUBLE
14047: EQUAL
14048: IFTRUE 14052
14050: GO 14070
14052: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
14053: NOP4
14057: PUSH
14058: LD_INT 13
14060: PUSH
14061: LD_INT 14
14063: PUSH
14064: EMPTY
14065: LIST
14066: LIST
14067: ST_TO_ADDR
14068: GO 14387
14070: LD_INT 42
14072: DOUBLE
14073: EQUAL
14074: IFTRUE 14078
14076: GO 14104
14078: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
14079: NOP4
14083: PUSH
14084: LD_INT 21
14086: PUSH
14087: LD_INT 22
14089: PUSH
14090: LD_INT 23
14092: PUSH
14093: LD_INT 24
14095: PUSH
14096: EMPTY
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: ST_TO_ADDR
14102: GO 14387
14104: LD_INT 43
14106: DOUBLE
14107: EQUAL
14108: IFTRUE 14112
14110: GO 14138
14112: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
14113: NOP4
14117: PUSH
14118: LD_INT 21
14120: PUSH
14121: LD_INT 22
14123: PUSH
14124: LD_INT 23
14126: PUSH
14127: LD_INT 24
14129: PUSH
14130: EMPTY
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: ST_TO_ADDR
14136: GO 14387
14138: LD_INT 44
14140: DOUBLE
14141: EQUAL
14142: IFTRUE 14146
14144: GO 14172
14146: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
14147: NOP4
14151: PUSH
14152: LD_INT 21
14154: PUSH
14155: LD_INT 22
14157: PUSH
14158: LD_INT 23
14160: PUSH
14161: LD_INT 24
14163: PUSH
14164: EMPTY
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: ST_TO_ADDR
14170: GO 14387
14172: LD_INT 45
14174: DOUBLE
14175: EQUAL
14176: IFTRUE 14180
14178: GO 14206
14180: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14181: NOP4
14185: PUSH
14186: LD_INT 21
14188: PUSH
14189: LD_INT 22
14191: PUSH
14192: LD_INT 23
14194: PUSH
14195: LD_INT 24
14197: PUSH
14198: EMPTY
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: ST_TO_ADDR
14204: GO 14387
14206: LD_INT 49
14208: DOUBLE
14209: EQUAL
14210: IFTRUE 14214
14212: GO 14240
14214: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14215: NOP4
14219: PUSH
14220: LD_INT 21
14222: PUSH
14223: LD_INT 22
14225: PUSH
14226: LD_INT 23
14228: PUSH
14229: LD_INT 24
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: ST_TO_ADDR
14238: GO 14387
14240: LD_INT 51
14242: DOUBLE
14243: EQUAL
14244: IFTRUE 14248
14246: GO 14274
14248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14249: NOP4
14253: PUSH
14254: LD_INT 21
14256: PUSH
14257: LD_INT 22
14259: PUSH
14260: LD_INT 23
14262: PUSH
14263: LD_INT 24
14265: PUSH
14266: EMPTY
14267: LIST
14268: LIST
14269: LIST
14270: LIST
14271: ST_TO_ADDR
14272: GO 14387
14274: LD_INT 52
14276: DOUBLE
14277: EQUAL
14278: IFTRUE 14282
14280: GO 14308
14282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14283: NOP4
14287: PUSH
14288: LD_INT 21
14290: PUSH
14291: LD_INT 22
14293: PUSH
14294: LD_INT 23
14296: PUSH
14297: LD_INT 24
14299: PUSH
14300: EMPTY
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: ST_TO_ADDR
14306: GO 14387
14308: LD_INT 53
14310: DOUBLE
14311: EQUAL
14312: IFTRUE 14316
14314: GO 14334
14316: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14317: NOP4
14321: PUSH
14322: LD_INT 23
14324: PUSH
14325: LD_INT 24
14327: PUSH
14328: EMPTY
14329: LIST
14330: LIST
14331: ST_TO_ADDR
14332: GO 14387
14334: LD_INT 46
14336: DOUBLE
14337: EQUAL
14338: IFTRUE 14342
14340: GO 14360
14342: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14343: NOP4
14347: PUSH
14348: LD_INT 23
14350: PUSH
14351: LD_INT 24
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: ST_TO_ADDR
14358: GO 14387
14360: LD_INT 47
14362: DOUBLE
14363: EQUAL
14364: IFTRUE 14368
14366: GO 14386
14368: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14369: NOP4
14373: PUSH
14374: LD_INT 23
14376: PUSH
14377: LD_INT 24
14379: PUSH
14380: EMPTY
14381: LIST
14382: LIST
14383: ST_TO_ADDR
14384: GO 14387
14386: POP
// result := ( chassis in result ) ;
14387: NOP4
14391: PUSH
14392: NOP4
14396: PUSH
14397: NOP4
14401: IN
14402: ST_TO_ADDR
// end ;
14403: LD_VAR 0 3
14407: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14408: LD_INT 0
14410: PPUSH
14411: PPUSH
14412: PPUSH
14413: PPUSH
14414: PPUSH
14415: PPUSH
14416: PPUSH
// result := array ;
14417: NOP4
14421: PUSH
14422: NOP4
14426: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14427: NOP4
14431: NOT
14432: PUSH
14433: NOP4
14437: NOT
14438: OR
14439: PUSH
14440: NOP4
14444: NOT
14445: OR
14446: PUSH
14447: NOP4
14451: PUSH
14452: NOP4
14456: GREATER
14457: OR
14458: PUSH
14459: NOP4
14463: PUSH
14464: NOP4
14468: GREATER
14469: OR
14470: IFFALSE 14474
// exit ;
14472: GO 14770
// if direction then
14474: NOP4
14478: IFFALSE 14542
// begin d := 1 ;
14480: NOP4
14484: PUSH
14485: LD_INT 1
14487: ST_TO_ADDR
// if i_from > i_to then
14488: NOP4
14492: PUSH
14493: NOP4
14497: GREATER
14498: IFFALSE 14524
// length := ( array - i_from ) + i_to else
14500: NOP4
14504: PUSH
14505: NOP4
14509: PUSH
14510: NOP4
14514: MINUS
14515: PUSH
14516: NOP4
14520: PLUS
14521: ST_TO_ADDR
14522: GO 14540
// length := i_to - i_from ;
14524: NOP4
14528: PUSH
14529: NOP4
14533: PUSH
14534: NOP4
14538: MINUS
14539: ST_TO_ADDR
// end else
14540: GO 14603
// begin d := - 1 ;
14542: NOP4
14546: PUSH
14547: LD_INT 1
14549: NEG
14550: ST_TO_ADDR
// if i_from > i_to then
14551: NOP4
14555: PUSH
14556: NOP4
14560: GREATER
14561: IFFALSE 14581
// length := i_from - i_to else
14563: NOP4
14567: PUSH
14568: NOP4
14572: PUSH
14573: NOP4
14577: MINUS
14578: ST_TO_ADDR
14579: GO 14603
// length := ( array - i_to ) + i_from ;
14581: NOP4
14585: PUSH
14586: NOP4
14590: PUSH
14591: NOP4
14595: MINUS
14596: PUSH
14597: NOP4
14601: PLUS
14602: ST_TO_ADDR
// end ; if not length then
14603: NOP4
14607: NOT
14608: IFFALSE 14612
// exit ;
14610: GO 14770
// tmp := array ;
14612: NOP4
14616: PUSH
14617: NOP4
14621: ST_TO_ADDR
// for i = 1 to length do
14622: NOP4
14626: PUSH
14627: DOUBLE
14628: LD_INT 1
14630: DEC
14631: ST_TO_ADDR
14632: NOP4
14636: PUSH
14637: FOR_TO
14638: IFFALSE 14758
// begin for j = 1 to array do
14640: NOP4
14644: PUSH
14645: DOUBLE
14646: LD_INT 1
14648: DEC
14649: ST_TO_ADDR
14650: NOP4
14654: PUSH
14655: FOR_TO
14656: IFFALSE 14744
// begin k := j + d ;
14658: NOP4
14662: PUSH
14663: NOP4
14667: PUSH
14668: NOP4
14672: PLUS
14673: ST_TO_ADDR
// if k > array then
14674: NOP4
14678: PUSH
14679: NOP4
14683: GREATER
14684: IFFALSE 14694
// k := 1 ;
14686: NOP4
14690: PUSH
14691: LD_INT 1
14693: ST_TO_ADDR
// if not k then
14694: NOP4
14698: NOT
14699: IFFALSE 14711
// k := array ;
14701: NOP4
14705: PUSH
14706: NOP4
14710: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14711: NOP4
14715: PUSH
14716: NOP4
14720: PPUSH
14721: NOP4
14725: PPUSH
14726: NOP4
14730: PUSH
14731: NOP4
14735: ARRAY
14736: PPUSH
14737: NOP4
14741: ST_TO_ADDR
// end ;
14742: GO 14655
14744: POP
14745: POP
// array := tmp ;
14746: NOP4
14750: PUSH
14751: NOP4
14755: ST_TO_ADDR
// end ;
14756: GO 14637
14758: POP
14759: POP
// result := array ;
14760: NOP4
14764: PUSH
14765: NOP4
14769: ST_TO_ADDR
// end ;
14770: LD_VAR 0 5
14774: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14775: LD_INT 0
14777: PPUSH
14778: PPUSH
// result := 0 ;
14779: NOP4
14783: PUSH
14784: LD_INT 0
14786: ST_TO_ADDR
// if not array or not value in array then
14787: NOP4
14791: NOT
14792: PUSH
14793: NOP4
14797: PUSH
14798: NOP4
14802: IN
14803: NOT
14804: OR
14805: IFFALSE 14809
// exit ;
14807: GO 14863
// for i = 1 to array do
14809: NOP4
14813: PUSH
14814: DOUBLE
14815: LD_INT 1
14817: DEC
14818: ST_TO_ADDR
14819: NOP4
14823: PUSH
14824: FOR_TO
14825: IFFALSE 14861
// if value = array [ i ] then
14827: NOP4
14831: PUSH
14832: NOP4
14836: PUSH
14837: NOP4
14841: ARRAY
14842: EQUAL
14843: IFFALSE 14859
// begin result := i ;
14845: NOP4
14849: PUSH
14850: NOP4
14854: ST_TO_ADDR
// exit ;
14855: POP
14856: POP
14857: GO 14863
// end ;
14859: GO 14824
14861: POP
14862: POP
// end ;
14863: LD_VAR 0 3
14867: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14868: LD_INT 0
14870: PPUSH
// vc_chassis := chassis ;
14871: LD_ADDR_OWVAR 37
14875: PUSH
14876: NOP4
14880: ST_TO_ADDR
// vc_engine := engine ;
14881: LD_ADDR_OWVAR 39
14885: PUSH
14886: NOP4
14890: ST_TO_ADDR
// vc_control := control ;
14891: LD_ADDR_OWVAR 38
14895: PUSH
14896: NOP4
14900: ST_TO_ADDR
// vc_weapon := weapon ;
14901: LD_ADDR_OWVAR 40
14905: PUSH
14906: NOP4
14910: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14911: LD_ADDR_OWVAR 41
14915: PUSH
14916: NOP4
14920: ST_TO_ADDR
// end ;
14921: LD_VAR 0 6
14925: RET
// export function WantPlant ( unit ) ; var task ; begin
14926: LD_INT 0
14928: PPUSH
14929: PPUSH
// result := false ;
14930: NOP4
14934: PUSH
14935: LD_INT 0
14937: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14938: NOP4
14942: PUSH
14943: NOP4
14947: PPUSH
14948: NOP4
14952: ST_TO_ADDR
// if task then
14953: NOP4
14957: IFFALSE 14985
// if task [ 1 ] [ 1 ] = p then
14959: NOP4
14963: PUSH
14964: LD_INT 1
14966: ARRAY
14967: PUSH
14968: LD_INT 1
14970: ARRAY
14971: PUSH
14972: LD_STRING p
14974: EQUAL
14975: IFFALSE 14985
// result := true ;
14977: NOP4
14981: PUSH
14982: LD_INT 1
14984: ST_TO_ADDR
// end ;
14985: LD_VAR 0 2
14989: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14990: LD_INT 0
14992: PPUSH
14993: PPUSH
14994: PPUSH
14995: PPUSH
// if pos < 1 then
14996: NOP4
15000: PUSH
15001: LD_INT 1
15003: LESS
15004: IFFALSE 15008
// exit ;
15006: GO 15311
// if pos = 1 then
15008: NOP4
15012: PUSH
15013: LD_INT 1
15015: EQUAL
15016: IFFALSE 15049
// result := Replace ( arr , pos [ 1 ] , value ) else
15018: NOP4
15022: PUSH
15023: NOP4
15027: PPUSH
15028: NOP4
15032: PUSH
15033: LD_INT 1
15035: ARRAY
15036: PPUSH
15037: NOP4
15041: PPUSH
15042: NOP4
15046: ST_TO_ADDR
15047: GO 15311
// begin tmp := arr ;
15049: NOP4
15053: PUSH
15054: NOP4
15058: ST_TO_ADDR
// s_arr := [ tmp ] ;
15059: NOP4
15063: PUSH
15064: NOP4
15068: PUSH
15069: EMPTY
15070: LIST
15071: ST_TO_ADDR
// for i = 1 to pos - 1 do
15072: NOP4
15076: PUSH
15077: DOUBLE
15078: LD_INT 1
15080: DEC
15081: ST_TO_ADDR
15082: NOP4
15086: PUSH
15087: LD_INT 1
15089: MINUS
15090: PUSH
15091: FOR_TO
15092: IFFALSE 15137
// begin tmp := tmp [ pos [ i ] ] ;
15094: NOP4
15098: PUSH
15099: NOP4
15103: PUSH
15104: NOP4
15108: PUSH
15109: NOP4
15113: ARRAY
15114: ARRAY
15115: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
15116: NOP4
15120: PUSH
15121: NOP4
15125: PUSH
15126: NOP4
15130: PUSH
15131: EMPTY
15132: LIST
15133: ADD
15134: ST_TO_ADDR
// end ;
15135: GO 15091
15137: POP
15138: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
15139: NOP4
15143: PUSH
15144: NOP4
15148: PPUSH
15149: NOP4
15153: PUSH
15154: NOP4
15158: ARRAY
15159: PPUSH
15160: NOP4
15164: PPUSH
15165: NOP4
15169: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15170: NOP4
15174: PUSH
15175: NOP4
15179: PPUSH
15180: NOP4
15184: PPUSH
15185: NOP4
15189: PPUSH
15190: NOP4
15194: ST_TO_ADDR
// for i = s_arr downto 2 do
15195: NOP4
15199: PUSH
15200: DOUBLE
15201: NOP4
15205: INC
15206: ST_TO_ADDR
15207: LD_INT 2
15209: PUSH
15210: FOR_DOWNTO
15211: IFFALSE 15295
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15213: NOP4
15217: PUSH
15218: NOP4
15222: PUSH
15223: NOP4
15227: PUSH
15228: LD_INT 1
15230: MINUS
15231: ARRAY
15232: PPUSH
15233: NOP4
15237: PUSH
15238: NOP4
15242: PUSH
15243: LD_INT 1
15245: MINUS
15246: ARRAY
15247: PPUSH
15248: NOP4
15252: PUSH
15253: NOP4
15257: ARRAY
15258: PPUSH
15259: NOP4
15263: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15264: NOP4
15268: PUSH
15269: NOP4
15273: PPUSH
15274: NOP4
15278: PUSH
15279: LD_INT 1
15281: MINUS
15282: PPUSH
15283: NOP4
15287: PPUSH
15288: NOP4
15292: ST_TO_ADDR
// end ;
15293: GO 15210
15295: POP
15296: POP
// result := s_arr [ 1 ] ;
15297: NOP4
15301: PUSH
15302: NOP4
15306: PUSH
15307: LD_INT 1
15309: ARRAY
15310: ST_TO_ADDR
// end ; end ;
15311: LD_VAR 0 4
15315: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15316: LD_INT 0
15318: PPUSH
15319: PPUSH
// if not list then
15320: NOP4
15324: NOT
15325: IFFALSE 15329
// exit ;
15327: GO 15420
// i := list [ pos1 ] ;
15329: NOP4
15333: PUSH
15334: NOP4
15338: PUSH
15339: NOP4
15343: ARRAY
15344: ST_TO_ADDR
// if not i then
15345: NOP4
15349: NOT
15350: IFFALSE 15354
// exit ;
15352: GO 15420
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15354: NOP4
15358: PUSH
15359: NOP4
15363: PPUSH
15364: NOP4
15368: PPUSH
15369: NOP4
15373: PUSH
15374: NOP4
15378: ARRAY
15379: PPUSH
15380: NOP4
15384: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15385: NOP4
15389: PUSH
15390: NOP4
15394: PPUSH
15395: NOP4
15399: PPUSH
15400: NOP4
15404: PPUSH
15405: NOP4
15409: ST_TO_ADDR
// result := list ;
15410: NOP4
15414: PUSH
15415: NOP4
15419: ST_TO_ADDR
// end ;
15420: LD_VAR 0 4
15424: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15425: LD_INT 0
15427: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15428: NOP4
15432: PUSH
15433: NOP4
15437: PPUSH
15438: NOP4
15442: PPUSH
15443: NOP4
15447: PPUSH
15448: NOP4
15452: PPUSH
15453: NOP4
15457: PPUSH
15458: NOP4
15462: PPUSH
15463: NOP4
15467: PPUSH
15468: NOP4
15472: ST_TO_ADDR
// end ;
15473: LD_VAR 0 5
15477: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15478: LD_INT 0
15480: PPUSH
15481: PPUSH
15482: PPUSH
15483: PPUSH
// if not list then
15484: NOP4
15488: NOT
15489: IFFALSE 15493
// exit ;
15491: GO 15881
// result := [ ] ;
15493: NOP4
15497: PUSH
15498: EMPTY
15499: ST_TO_ADDR
// for i in list do
15500: NOP4
15504: PUSH
15505: NOP4
15509: PUSH
15510: FOR_IN
15511: IFFALSE 15713
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15513: NOP4
15517: PUSH
15518: NOP4
15522: PPUSH
15523: NOP4
15527: PPUSH
15528: NOP4
15532: PPUSH
15533: NOP4
15537: ST_TO_ADDR
// if not result then
15538: NOP4
15542: NOT
15543: IFFALSE 15569
// result := [ [ i , tmp ] ] else
15545: NOP4
15549: PUSH
15550: NOP4
15554: PUSH
15555: NOP4
15559: PUSH
15560: EMPTY
15561: LIST
15562: LIST
15563: PUSH
15564: EMPTY
15565: LIST
15566: ST_TO_ADDR
15567: GO 15711
// begin if result [ result ] [ 2 ] < tmp then
15569: NOP4
15573: PUSH
15574: NOP4
15578: ARRAY
15579: PUSH
15580: LD_INT 2
15582: ARRAY
15583: PUSH
15584: NOP4
15588: LESS
15589: IFFALSE 15631
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15591: NOP4
15595: PUSH
15596: NOP4
15600: PPUSH
15601: NOP4
15605: PUSH
15606: LD_INT 1
15608: PLUS
15609: PPUSH
15610: NOP4
15614: PUSH
15615: NOP4
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: PPUSH
15624: NOP4
15628: ST_TO_ADDR
15629: GO 15711
// for j = 1 to result do
15631: NOP4
15635: PUSH
15636: DOUBLE
15637: LD_INT 1
15639: DEC
15640: ST_TO_ADDR
15641: NOP4
15645: PUSH
15646: FOR_TO
15647: IFFALSE 15709
// begin if tmp < result [ j ] [ 2 ] then
15649: NOP4
15653: PUSH
15654: NOP4
15658: PUSH
15659: NOP4
15663: ARRAY
15664: PUSH
15665: LD_INT 2
15667: ARRAY
15668: LESS
15669: IFFALSE 15707
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15671: NOP4
15675: PUSH
15676: NOP4
15680: PPUSH
15681: NOP4
15685: PPUSH
15686: NOP4
15690: PUSH
15691: NOP4
15695: PUSH
15696: EMPTY
15697: LIST
15698: LIST
15699: PPUSH
15700: NOP4
15704: ST_TO_ADDR
// break ;
15705: GO 15709
// end ; end ;
15707: GO 15646
15709: POP
15710: POP
// end ; end ;
15711: GO 15510
15713: POP
15714: POP
// if result and not asc then
15715: NOP4
15719: PUSH
15720: NOP4
15724: NOT
15725: AND
15726: IFFALSE 15801
// begin tmp := result ;
15728: NOP4
15732: PUSH
15733: NOP4
15737: ST_TO_ADDR
// for i = tmp downto 1 do
15738: NOP4
15742: PUSH
15743: DOUBLE
15744: NOP4
15748: INC
15749: ST_TO_ADDR
15750: LD_INT 1
15752: PUSH
15753: FOR_DOWNTO
15754: IFFALSE 15799
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15756: NOP4
15760: PUSH
15761: NOP4
15765: PPUSH
15766: NOP4
15770: PUSH
15771: NOP4
15775: MINUS
15776: PUSH
15777: LD_INT 1
15779: PLUS
15780: PPUSH
15781: NOP4
15785: PUSH
15786: NOP4
15790: ARRAY
15791: PPUSH
15792: NOP4
15796: ST_TO_ADDR
15797: GO 15753
15799: POP
15800: POP
// end ; tmp := [ ] ;
15801: NOP4
15805: PUSH
15806: EMPTY
15807: ST_TO_ADDR
// if mode then
15808: NOP4
15812: IFFALSE 15881
// begin for i = 1 to result do
15814: NOP4
15818: PUSH
15819: DOUBLE
15820: LD_INT 1
15822: DEC
15823: ST_TO_ADDR
15824: NOP4
15828: PUSH
15829: FOR_TO
15830: IFFALSE 15869
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15832: NOP4
15836: PUSH
15837: NOP4
15841: PPUSH
15842: NOP4
15846: PPUSH
15847: NOP4
15851: PUSH
15852: NOP4
15856: ARRAY
15857: PUSH
15858: LD_INT 1
15860: ARRAY
15861: PPUSH
15862: NOP4
15866: ST_TO_ADDR
15867: GO 15829
15869: POP
15870: POP
// result := tmp ;
15871: NOP4
15875: PUSH
15876: NOP4
15880: ST_TO_ADDR
// end ; end ;
15881: LD_VAR 0 6
15885: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15886: LD_INT 0
15888: PPUSH
15889: PPUSH
15890: PPUSH
15891: PPUSH
15892: PPUSH
15893: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15894: NOP4
15898: PUSH
15899: LD_INT 0
15901: PUSH
15902: LD_INT 0
15904: PUSH
15905: LD_INT 0
15907: PUSH
15908: EMPTY
15909: PUSH
15910: EMPTY
15911: LIST
15912: LIST
15913: LIST
15914: LIST
15915: ST_TO_ADDR
// if not x or not y then
15916: NOP4
15920: NOT
15921: PUSH
15922: NOP4
15926: NOT
15927: OR
15928: IFFALSE 15932
// exit ;
15930: GO 17584
// if not range then
15932: NOP4
15936: NOT
15937: IFFALSE 15947
// range := 10 ;
15939: NOP4
15943: PUSH
15944: LD_INT 10
15946: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15947: NOP4
15951: PUSH
15952: LD_INT 81
15954: PUSH
15955: NOP4
15959: PUSH
15960: EMPTY
15961: LIST
15962: LIST
15963: PUSH
15964: LD_INT 92
15966: PUSH
15967: NOP4
15971: PUSH
15972: NOP4
15976: PUSH
15977: NOP4
15981: PUSH
15982: EMPTY
15983: LIST
15984: LIST
15985: LIST
15986: LIST
15987: PUSH
15988: LD_INT 3
15990: PUSH
15991: LD_INT 21
15993: PUSH
15994: LD_INT 3
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: PUSH
16001: EMPTY
16002: LIST
16003: LIST
16004: PUSH
16005: EMPTY
16006: LIST
16007: LIST
16008: LIST
16009: PPUSH
16010: NOP4
16014: ST_TO_ADDR
// if not tmp then
16015: NOP4
16019: NOT
16020: IFFALSE 16024
// exit ;
16022: GO 17584
// for i in tmp do
16024: NOP4
16028: PUSH
16029: NOP4
16033: PUSH
16034: FOR_IN
16035: IFFALSE 17559
// begin points := [ 0 , 0 , 0 ] ;
16037: NOP4
16041: PUSH
16042: LD_INT 0
16044: PUSH
16045: LD_INT 0
16047: PUSH
16048: LD_INT 0
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: LIST
16055: ST_TO_ADDR
// bpoints := 1 ;
16056: NOP4
16060: PUSH
16061: LD_INT 1
16063: ST_TO_ADDR
// case GetType ( i ) of unit_human :
16064: NOP4
16068: PPUSH
16069: NOP4
16073: PUSH
16074: LD_INT 1
16076: DOUBLE
16077: EQUAL
16078: IFTRUE 16082
16080: GO 16660
16082: POP
// begin if GetClass ( i ) = 1 then
16083: NOP4
16087: PPUSH
16088: NOP4
16092: PUSH
16093: LD_INT 1
16095: EQUAL
16096: IFFALSE 16117
// points := [ 10 , 5 , 3 ] ;
16098: NOP4
16102: PUSH
16103: LD_INT 10
16105: PUSH
16106: LD_INT 5
16108: PUSH
16109: LD_INT 3
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: LIST
16116: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16117: NOP4
16121: PPUSH
16122: NOP4
16126: PUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 3
16132: PUSH
16133: LD_INT 4
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: LIST
16140: IN
16141: IFFALSE 16162
// points := [ 3 , 2 , 1 ] ;
16143: NOP4
16147: PUSH
16148: LD_INT 3
16150: PUSH
16151: LD_INT 2
16153: PUSH
16154: LD_INT 1
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: LIST
16161: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16162: NOP4
16166: PPUSH
16167: NOP4
16171: PUSH
16172: LD_INT 5
16174: EQUAL
16175: IFFALSE 16196
// points := [ 130 , 5 , 2 ] ;
16177: NOP4
16181: PUSH
16182: LD_INT 130
16184: PUSH
16185: LD_INT 5
16187: PUSH
16188: LD_INT 2
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: LIST
16195: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16196: NOP4
16200: PPUSH
16201: NOP4
16205: PUSH
16206: LD_INT 8
16208: EQUAL
16209: IFFALSE 16230
// points := [ 35 , 35 , 30 ] ;
16211: NOP4
16215: PUSH
16216: LD_INT 35
16218: PUSH
16219: LD_INT 35
16221: PUSH
16222: LD_INT 30
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: LIST
16229: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16230: NOP4
16234: PPUSH
16235: NOP4
16239: PUSH
16240: LD_INT 9
16242: EQUAL
16243: IFFALSE 16264
// points := [ 20 , 55 , 40 ] ;
16245: NOP4
16249: PUSH
16250: LD_INT 20
16252: PUSH
16253: LD_INT 55
16255: PUSH
16256: LD_INT 40
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: LIST
16263: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16264: NOP4
16268: PPUSH
16269: NOP4
16273: PUSH
16274: LD_INT 12
16276: PUSH
16277: LD_INT 16
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: IN
16284: IFFALSE 16305
// points := [ 5 , 3 , 2 ] ;
16286: NOP4
16290: PUSH
16291: LD_INT 5
16293: PUSH
16294: LD_INT 3
16296: PUSH
16297: LD_INT 2
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: LIST
16304: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16305: NOP4
16309: PPUSH
16310: NOP4
16314: PUSH
16315: LD_INT 17
16317: EQUAL
16318: IFFALSE 16339
// points := [ 100 , 50 , 75 ] ;
16320: NOP4
16324: PUSH
16325: LD_INT 100
16327: PUSH
16328: LD_INT 50
16330: PUSH
16331: LD_INT 75
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: LIST
16338: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16339: NOP4
16343: PPUSH
16344: NOP4
16348: PUSH
16349: LD_INT 15
16351: EQUAL
16352: IFFALSE 16373
// points := [ 10 , 5 , 3 ] ;
16354: NOP4
16358: PUSH
16359: LD_INT 10
16361: PUSH
16362: LD_INT 5
16364: PUSH
16365: LD_INT 3
16367: PUSH
16368: EMPTY
16369: LIST
16370: LIST
16371: LIST
16372: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16373: NOP4
16377: PPUSH
16378: NOP4
16382: PUSH
16383: LD_INT 14
16385: EQUAL
16386: IFFALSE 16407
// points := [ 10 , 0 , 0 ] ;
16388: NOP4
16392: PUSH
16393: LD_INT 10
16395: PUSH
16396: LD_INT 0
16398: PUSH
16399: LD_INT 0
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: LIST
16406: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16407: NOP4
16411: PPUSH
16412: NOP4
16416: PUSH
16417: LD_INT 11
16419: EQUAL
16420: IFFALSE 16441
// points := [ 30 , 10 , 5 ] ;
16422: NOP4
16426: PUSH
16427: LD_INT 30
16429: PUSH
16430: LD_INT 10
16432: PUSH
16433: LD_INT 5
16435: PUSH
16436: EMPTY
16437: LIST
16438: LIST
16439: LIST
16440: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16441: NOP4
16445: PPUSH
16446: LD_INT 5
16448: PPUSH
16449: NOP4
16453: PUSH
16454: LD_INT 2
16456: EQUAL
16457: IFFALSE 16474
// bpoints := bpoints * 1.8 ;
16459: NOP4
16463: PUSH
16464: NOP4
16468: PUSH
16469: LD_REAL  1.80000000000000E+0000
16472: MUL
16473: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16474: NOP4
16478: PPUSH
16479: NOP4
16483: PUSH
16484: LD_INT 1
16486: PUSH
16487: LD_INT 2
16489: PUSH
16490: LD_INT 3
16492: PUSH
16493: LD_INT 4
16495: PUSH
16496: EMPTY
16497: LIST
16498: LIST
16499: LIST
16500: LIST
16501: IN
16502: PUSH
16503: NOP4
16507: PPUSH
16508: LD_INT 51
16510: PPUSH
16511: NOP4
16515: PUSH
16516: LD_INT 2
16518: EQUAL
16519: AND
16520: IFFALSE 16537
// bpoints := bpoints * 1.2 ;
16522: NOP4
16526: PUSH
16527: NOP4
16531: PUSH
16532: LD_REAL  1.20000000000000E+0000
16535: MUL
16536: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16537: NOP4
16541: PPUSH
16542: NOP4
16546: PUSH
16547: LD_INT 5
16549: PUSH
16550: LD_INT 7
16552: PUSH
16553: LD_INT 9
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: LIST
16560: IN
16561: PUSH
16562: NOP4
16566: PPUSH
16567: LD_INT 52
16569: PPUSH
16570: NOP4
16574: PUSH
16575: LD_INT 2
16577: EQUAL
16578: AND
16579: IFFALSE 16596
// bpoints := bpoints * 1.5 ;
16581: NOP4
16585: PUSH
16586: NOP4
16590: PUSH
16591: LD_REAL  1.50000000000000E+0000
16594: MUL
16595: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16596: NOP4
16600: PPUSH
16601: LD_INT 66
16603: PPUSH
16604: NOP4
16608: PUSH
16609: LD_INT 2
16611: EQUAL
16612: IFFALSE 16629
// bpoints := bpoints * 1.1 ;
16614: NOP4
16618: PUSH
16619: NOP4
16623: PUSH
16624: LD_REAL  1.10000000000000E+0000
16627: MUL
16628: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16629: NOP4
16633: PUSH
16634: NOP4
16638: PUSH
16639: NOP4
16643: PPUSH
16644: LD_INT 1
16646: PPUSH
16647: NOP4
16651: PUSH
16652: LD_REAL  1.15000000000000E+0000
16655: MUL
16656: MUL
16657: ST_TO_ADDR
// end ; unit_vehicle :
16658: GO 17488
16660: LD_INT 2
16662: DOUBLE
16663: EQUAL
16664: IFTRUE 16668
16666: GO 17476
16668: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16669: NOP4
16673: PPUSH
16674: NOP4
16678: PUSH
16679: LD_INT 2
16681: PUSH
16682: LD_INT 42
16684: PUSH
16685: LD_INT 24
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: LIST
16692: IN
16693: IFFALSE 16714
// points := [ 25 , 5 , 3 ] ;
16695: NOP4
16699: PUSH
16700: LD_INT 25
16702: PUSH
16703: LD_INT 5
16705: PUSH
16706: LD_INT 3
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16714: NOP4
16718: PPUSH
16719: NOP4
16723: PUSH
16724: LD_INT 4
16726: PUSH
16727: LD_INT 43
16729: PUSH
16730: LD_INT 25
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: LIST
16737: IN
16738: IFFALSE 16759
// points := [ 40 , 15 , 5 ] ;
16740: NOP4
16744: PUSH
16745: LD_INT 40
16747: PUSH
16748: LD_INT 15
16750: PUSH
16751: LD_INT 5
16753: PUSH
16754: EMPTY
16755: LIST
16756: LIST
16757: LIST
16758: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16759: NOP4
16763: PPUSH
16764: NOP4
16768: PUSH
16769: LD_INT 3
16771: PUSH
16772: LD_INT 23
16774: PUSH
16775: EMPTY
16776: LIST
16777: LIST
16778: IN
16779: IFFALSE 16800
// points := [ 7 , 25 , 8 ] ;
16781: NOP4
16785: PUSH
16786: LD_INT 7
16788: PUSH
16789: LD_INT 25
16791: PUSH
16792: LD_INT 8
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: LIST
16799: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16800: NOP4
16804: PPUSH
16805: NOP4
16809: PUSH
16810: LD_INT 5
16812: PUSH
16813: LD_INT 27
16815: PUSH
16816: LD_INT 44
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: IN
16824: IFFALSE 16845
// points := [ 14 , 50 , 16 ] ;
16826: NOP4
16830: PUSH
16831: LD_INT 14
16833: PUSH
16834: LD_INT 50
16836: PUSH
16837: LD_INT 16
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16845: NOP4
16849: PPUSH
16850: NOP4
16854: PUSH
16855: LD_INT 6
16857: PUSH
16858: LD_INT 46
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: IN
16865: IFFALSE 16886
// points := [ 32 , 120 , 70 ] ;
16867: NOP4
16871: PUSH
16872: LD_INT 32
16874: PUSH
16875: LD_INT 120
16877: PUSH
16878: LD_INT 70
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: LIST
16885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16886: NOP4
16890: PPUSH
16891: NOP4
16895: PUSH
16896: LD_INT 7
16898: PUSH
16899: LD_INT 28
16901: PUSH
16902: LD_INT 45
16904: PUSH
16905: NOP4
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: IN
16916: IFFALSE 16937
// points := [ 35 , 20 , 45 ] ;
16918: NOP4
16922: PUSH
16923: LD_INT 35
16925: PUSH
16926: LD_INT 20
16928: PUSH
16929: LD_INT 45
16931: PUSH
16932: EMPTY
16933: LIST
16934: LIST
16935: LIST
16936: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16937: NOP4
16941: PPUSH
16942: NOP4
16946: PUSH
16947: LD_INT 47
16949: PUSH
16950: EMPTY
16951: LIST
16952: IN
16953: IFFALSE 16974
// points := [ 67 , 45 , 75 ] ;
16955: NOP4
16959: PUSH
16960: LD_INT 67
16962: PUSH
16963: LD_INT 45
16965: PUSH
16966: LD_INT 75
16968: PUSH
16969: EMPTY
16970: LIST
16971: LIST
16972: LIST
16973: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16974: NOP4
16978: PPUSH
16979: NOP4
16983: PUSH
16984: LD_INT 26
16986: PUSH
16987: EMPTY
16988: LIST
16989: IN
16990: IFFALSE 17011
// points := [ 120 , 30 , 80 ] ;
16992: NOP4
16996: PUSH
16997: LD_INT 120
16999: PUSH
17000: LD_INT 30
17002: PUSH
17003: LD_INT 80
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: LIST
17010: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
17011: NOP4
17015: PPUSH
17016: NOP4
17020: PUSH
17021: LD_INT 22
17023: PUSH
17024: EMPTY
17025: LIST
17026: IN
17027: IFFALSE 17048
// points := [ 40 , 1 , 1 ] ;
17029: NOP4
17033: PUSH
17034: LD_INT 40
17036: PUSH
17037: LD_INT 1
17039: PUSH
17040: LD_INT 1
17042: PUSH
17043: EMPTY
17044: LIST
17045: LIST
17046: LIST
17047: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
17048: NOP4
17052: PPUSH
17053: NOP4
17057: PUSH
17058: LD_INT 29
17060: PUSH
17061: EMPTY
17062: LIST
17063: IN
17064: IFFALSE 17085
// points := [ 70 , 200 , 400 ] ;
17066: NOP4
17070: PUSH
17071: LD_INT 70
17073: PUSH
17074: LD_INT 200
17076: PUSH
17077: LD_INT 400
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: LIST
17084: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17085: NOP4
17089: PPUSH
17090: NOP4
17094: PUSH
17095: LD_INT 14
17097: PUSH
17098: LD_INT 53
17100: PUSH
17101: EMPTY
17102: LIST
17103: LIST
17104: IN
17105: IFFALSE 17126
// points := [ 40 , 10 , 20 ] ;
17107: NOP4
17111: PUSH
17112: LD_INT 40
17114: PUSH
17115: LD_INT 10
17117: PUSH
17118: LD_INT 20
17120: PUSH
17121: EMPTY
17122: LIST
17123: LIST
17124: LIST
17125: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17126: NOP4
17130: PPUSH
17131: NOP4
17135: PUSH
17136: LD_INT 9
17138: PUSH
17139: EMPTY
17140: LIST
17141: IN
17142: IFFALSE 17163
// points := [ 5 , 70 , 20 ] ;
17144: NOP4
17148: PUSH
17149: LD_INT 5
17151: PUSH
17152: LD_INT 70
17154: PUSH
17155: LD_INT 20
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: LIST
17162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17163: NOP4
17167: PPUSH
17168: NOP4
17172: PUSH
17173: LD_INT 10
17175: PUSH
17176: EMPTY
17177: LIST
17178: IN
17179: IFFALSE 17200
// points := [ 35 , 110 , 70 ] ;
17181: NOP4
17185: PUSH
17186: LD_INT 35
17188: PUSH
17189: LD_INT 110
17191: PUSH
17192: LD_INT 70
17194: PUSH
17195: EMPTY
17196: LIST
17197: LIST
17198: LIST
17199: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17200: NOP4
17204: PPUSH
17205: NOP4
17209: PUSH
17210: LD_INT 25
17212: EQUAL
17213: IFFALSE 17234
// points := [ 80 , 65 , 100 ] ;
17215: NOP4
17219: PUSH
17220: LD_INT 80
17222: PUSH
17223: LD_INT 65
17225: PUSH
17226: LD_INT 100
17228: PUSH
17229: EMPTY
17230: LIST
17231: LIST
17232: LIST
17233: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17234: NOP4
17238: PPUSH
17239: NOP4
17243: PUSH
17244: LD_INT 1
17246: EQUAL
17247: IFFALSE 17282
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17249: NOP4
17253: PUSH
17254: NOP4
17258: PUSH
17259: NOP4
17263: PPUSH
17264: NOP4
17268: PPUSH
17269: LD_INT 3
17271: PPUSH
17272: NOP4
17276: PUSH
17277: LD_INT 4
17279: MUL
17280: MUL
17281: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17282: NOP4
17286: PPUSH
17287: NOP4
17291: PUSH
17292: LD_INT 2
17294: EQUAL
17295: IFFALSE 17346
// begin j := IsControledBy ( i ) ;
17297: NOP4
17301: PUSH
17302: NOP4
17306: PPUSH
17307: NOP4
17311: ST_TO_ADDR
// if j then
17312: NOP4
17316: IFFALSE 17346
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17318: NOP4
17322: PUSH
17323: NOP4
17327: PUSH
17328: NOP4
17332: PPUSH
17333: LD_INT 3
17335: PPUSH
17336: NOP4
17340: PUSH
17341: LD_INT 3
17343: MUL
17344: MUL
17345: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17346: NOP4
17350: PPUSH
17351: NOP4
17355: PUSH
17356: LD_INT 5
17358: PUSH
17359: LD_INT 6
17361: PUSH
17362: LD_INT 46
17364: PUSH
17365: LD_INT 44
17367: PUSH
17368: LD_INT 47
17370: PUSH
17371: LD_INT 45
17373: PUSH
17374: LD_INT 28
17376: PUSH
17377: LD_INT 7
17379: PUSH
17380: LD_INT 27
17382: PUSH
17383: LD_INT 29
17385: PUSH
17386: EMPTY
17387: LIST
17388: LIST
17389: LIST
17390: LIST
17391: LIST
17392: LIST
17393: LIST
17394: LIST
17395: LIST
17396: LIST
17397: IN
17398: PUSH
17399: NOP4
17403: PPUSH
17404: LD_INT 52
17406: PPUSH
17407: NOP4
17411: PUSH
17412: LD_INT 2
17414: EQUAL
17415: AND
17416: IFFALSE 17433
// bpoints := bpoints * 1.2 ;
17418: NOP4
17422: PUSH
17423: NOP4
17427: PUSH
17428: LD_REAL  1.20000000000000E+0000
17431: MUL
17432: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17433: NOP4
17437: PPUSH
17438: NOP4
17442: PUSH
17443: LD_INT 6
17445: PUSH
17446: LD_INT 46
17448: PUSH
17449: LD_INT 47
17451: PUSH
17452: EMPTY
17453: LIST
17454: LIST
17455: LIST
17456: IN
17457: IFFALSE 17474
// bpoints := bpoints * 1.2 ;
17459: NOP4
17463: PUSH
17464: NOP4
17468: PUSH
17469: LD_REAL  1.20000000000000E+0000
17472: MUL
17473: ST_TO_ADDR
// end ; unit_building :
17474: GO 17488
17476: LD_INT 3
17478: DOUBLE
17479: EQUAL
17480: IFTRUE 17484
17482: GO 17487
17484: POP
// ; end ;
17485: GO 17488
17487: POP
// for j = 1 to 3 do
17488: NOP4
17492: PUSH
17493: DOUBLE
17494: LD_INT 1
17496: DEC
17497: ST_TO_ADDR
17498: LD_INT 3
17500: PUSH
17501: FOR_TO
17502: IFFALSE 17555
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17504: NOP4
17508: PUSH
17509: NOP4
17513: PPUSH
17514: NOP4
17518: PPUSH
17519: NOP4
17523: PUSH
17524: NOP4
17528: ARRAY
17529: PUSH
17530: NOP4
17534: PUSH
17535: NOP4
17539: ARRAY
17540: PUSH
17541: NOP4
17545: MUL
17546: PLUS
17547: PPUSH
17548: NOP4
17552: ST_TO_ADDR
17553: GO 17501
17555: POP
17556: POP
// end ;
17557: GO 16034
17559: POP
17560: POP
// result := Replace ( result , 4 , tmp ) ;
17561: NOP4
17565: PUSH
17566: NOP4
17570: PPUSH
17571: LD_INT 4
17573: PPUSH
17574: NOP4
17578: PPUSH
17579: NOP4
17583: ST_TO_ADDR
// end ;
17584: LD_VAR 0 5
17588: RET
// export function DangerAtRange ( unit , range ) ; begin
17589: LD_INT 0
17591: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17592: NOP4
17596: PUSH
17597: NOP4
17601: PPUSH
17602: NOP4
17606: PPUSH
17607: NOP4
17611: PPUSH
17612: NOP4
17616: PPUSH
17617: NOP4
17621: PPUSH
17622: NOP4
17626: PPUSH
17627: NOP4
17631: PPUSH
17632: NOP4
17636: ST_TO_ADDR
// end ;
17637: LD_VAR 0 3
17641: RET
// export function DangerInArea ( side , area ) ; begin
17642: LD_INT 0
17644: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17645: NOP4
17649: PUSH
17650: NOP4
17654: PPUSH
17655: LD_INT 81
17657: PUSH
17658: NOP4
17662: PUSH
17663: EMPTY
17664: LIST
17665: LIST
17666: PPUSH
17667: NOP4
17671: ST_TO_ADDR
// end ;
17672: LD_VAR 0 3
17676: RET
// export function IsExtension ( b ) ; begin
17677: LD_INT 0
17679: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17680: NOP4
17684: PUSH
17685: NOP4
17689: PUSH
17690: LD_INT 23
17692: PUSH
17693: LD_INT 20
17695: PUSH
17696: LD_INT 22
17698: PUSH
17699: LD_INT 17
17701: PUSH
17702: LD_INT 24
17704: PUSH
17705: LD_INT 21
17707: PUSH
17708: LD_INT 19
17710: PUSH
17711: LD_INT 16
17713: PUSH
17714: LD_INT 25
17716: PUSH
17717: LD_INT 18
17719: PUSH
17720: EMPTY
17721: LIST
17722: LIST
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: LIST
17728: LIST
17729: LIST
17730: LIST
17731: IN
17732: ST_TO_ADDR
// end ;
17733: LD_VAR 0 2
17737: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17738: LD_INT 0
17740: PPUSH
17741: PPUSH
17742: PPUSH
// result := [ ] ;
17743: NOP4
17747: PUSH
17748: EMPTY
17749: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17750: NOP4
17754: PUSH
17755: NOP4
17759: PPUSH
17760: LD_INT 21
17762: PUSH
17763: LD_INT 3
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: PPUSH
17770: NOP4
17774: ST_TO_ADDR
// if not tmp then
17775: NOP4
17779: NOT
17780: IFFALSE 17784
// exit ;
17782: GO 17848
// if checkLink then
17784: NOP4
17788: IFFALSE 17838
// begin for i in tmp do
17790: NOP4
17794: PUSH
17795: NOP4
17799: PUSH
17800: FOR_IN
17801: IFFALSE 17836
// if GetBase ( i ) <> base then
17803: NOP4
17807: PPUSH
17808: NOP4
17812: PUSH
17813: NOP4
17817: NONEQUAL
17818: IFFALSE 17834
// ComLinkToBase ( base , i ) ;
17820: NOP4
17824: PPUSH
17825: NOP4
17829: PPUSH
17830: NOP4
17834: GO 17800
17836: POP
17837: POP
// end ; result := tmp ;
17838: NOP4
17842: PUSH
17843: NOP4
17847: ST_TO_ADDR
// end ;
17848: LD_VAR 0 4
17852: RET
// export function ComComplete ( units , b ) ; var i ; begin
17853: LD_INT 0
17855: PPUSH
17856: PPUSH
// if not units then
17857: NOP4
17861: NOT
17862: IFFALSE 17866
// exit ;
17864: GO 17956
// for i in units do
17866: NOP4
17870: PUSH
17871: NOP4
17875: PUSH
17876: FOR_IN
17877: IFFALSE 17954
// if BuildingStatus ( b ) = bs_build then
17879: NOP4
17883: PPUSH
17884: NOP4
17888: PUSH
17889: LD_INT 1
17891: EQUAL
17892: IFFALSE 17952
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17894: NOP4
17898: PPUSH
17899: LD_STRING h
17901: PUSH
17902: NOP4
17906: PPUSH
17907: NOP4
17911: PUSH
17912: NOP4
17916: PPUSH
17917: NOP4
17921: PUSH
17922: NOP4
17926: PUSH
17927: LD_INT 0
17929: PUSH
17930: LD_INT 0
17932: PUSH
17933: LD_INT 0
17935: PUSH
17936: EMPTY
17937: LIST
17938: LIST
17939: LIST
17940: LIST
17941: LIST
17942: LIST
17943: LIST
17944: PUSH
17945: EMPTY
17946: LIST
17947: PPUSH
17948: NOP4
17952: GO 17876
17954: POP
17955: POP
// end ;
17956: LD_VAR 0 3
17960: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17961: LD_INT 0
17963: PPUSH
17964: PPUSH
17965: PPUSH
17966: PPUSH
17967: PPUSH
17968: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17969: NOP4
17973: NOT
17974: PUSH
17975: NOP4
17979: PPUSH
17980: NOP4
17984: PUSH
17985: LD_INT 2
17987: NONEQUAL
17988: OR
17989: IFFALSE 17993
// exit ;
17991: GO 18309
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17993: NOP4
17997: PUSH
17998: LD_INT 22
18000: PUSH
18001: NOP4
18005: PPUSH
18006: NOP4
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: PUSH
18015: LD_INT 2
18017: PUSH
18018: LD_INT 30
18020: PUSH
18021: LD_INT 36
18023: PUSH
18024: EMPTY
18025: LIST
18026: LIST
18027: PUSH
18028: LD_INT 34
18030: PUSH
18031: LD_INT 31
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: PUSH
18038: EMPTY
18039: LIST
18040: LIST
18041: LIST
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: PPUSH
18047: NOP4
18051: ST_TO_ADDR
// if not tmp then
18052: NOP4
18056: NOT
18057: IFFALSE 18061
// exit ;
18059: GO 18309
// result := [ ] ;
18061: NOP4
18065: PUSH
18066: EMPTY
18067: ST_TO_ADDR
// for i in tmp do
18068: NOP4
18072: PUSH
18073: NOP4
18077: PUSH
18078: FOR_IN
18079: IFFALSE 18150
// begin t := UnitsInside ( i ) ;
18081: NOP4
18085: PUSH
18086: NOP4
18090: PPUSH
18091: NOP4
18095: ST_TO_ADDR
// if t then
18096: NOP4
18100: IFFALSE 18148
// for j in t do
18102: NOP4
18106: PUSH
18107: NOP4
18111: PUSH
18112: FOR_IN
18113: IFFALSE 18146
// result := Replace ( result , result + 1 , j ) ;
18115: NOP4
18119: PUSH
18120: NOP4
18124: PPUSH
18125: NOP4
18129: PUSH
18130: LD_INT 1
18132: PLUS
18133: PPUSH
18134: NOP4
18138: PPUSH
18139: NOP4
18143: ST_TO_ADDR
18144: GO 18112
18146: POP
18147: POP
// end ;
18148: GO 18078
18150: POP
18151: POP
// if not result then
18152: NOP4
18156: NOT
18157: IFFALSE 18161
// exit ;
18159: GO 18309
// mech := result [ 1 ] ;
18161: NOP4
18165: PUSH
18166: NOP4
18170: PUSH
18171: LD_INT 1
18173: ARRAY
18174: ST_TO_ADDR
// if result > 1 then
18175: NOP4
18179: PUSH
18180: LD_INT 1
18182: GREATER
18183: IFFALSE 18295
// begin for i = 2 to result do
18185: NOP4
18189: PUSH
18190: DOUBLE
18191: LD_INT 2
18193: DEC
18194: ST_TO_ADDR
18195: NOP4
18199: PUSH
18200: FOR_TO
18201: IFFALSE 18293
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18203: NOP4
18207: PUSH
18208: NOP4
18212: PUSH
18213: NOP4
18217: ARRAY
18218: PPUSH
18219: LD_INT 3
18221: PPUSH
18222: NOP4
18226: PUSH
18227: NOP4
18231: PUSH
18232: NOP4
18236: ARRAY
18237: PPUSH
18238: NOP4
18242: MINUS
18243: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18244: NOP4
18248: PUSH
18249: NOP4
18253: PPUSH
18254: LD_INT 3
18256: PPUSH
18257: NOP4
18261: PUSH
18262: NOP4
18266: PPUSH
18267: NOP4
18271: MINUS
18272: GREATEREQUAL
18273: IFFALSE 18291
// mech := result [ i ] ;
18275: NOP4
18279: PUSH
18280: NOP4
18284: PUSH
18285: NOP4
18289: ARRAY
18290: ST_TO_ADDR
// end ;
18291: GO 18200
18293: POP
18294: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18295: NOP4
18299: PPUSH
18300: NOP4
18304: PPUSH
18305: NOP4
// end ;
18309: LD_VAR 0 2
18313: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18314: LD_INT 0
18316: PPUSH
18317: PPUSH
18318: PPUSH
18319: PPUSH
18320: PPUSH
18321: PPUSH
18322: PPUSH
18323: PPUSH
18324: PPUSH
18325: PPUSH
18326: PPUSH
18327: PPUSH
18328: PPUSH
// result := [ ] ;
18329: NOP4
18333: PUSH
18334: EMPTY
18335: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18336: NOP4
18340: PPUSH
18341: NOP4
18345: PUSH
18346: LD_INT 0
18348: PUSH
18349: LD_INT 1
18351: PUSH
18352: EMPTY
18353: LIST
18354: LIST
18355: IN
18356: NOT
18357: IFFALSE 18361
// exit ;
18359: GO 19995
// if name then
18361: NOP4
18365: IFFALSE 18381
// SetBName ( base_dep , name ) ;
18367: NOP4
18371: PPUSH
18372: NOP4
18376: PPUSH
18377: NOP4
// base := GetBase ( base_dep ) ;
18381: NOP4
18385: PUSH
18386: NOP4
18390: PPUSH
18391: NOP4
18395: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18396: NOP4
18400: PUSH
18401: NOP4
18405: PPUSH
18406: NOP4
18410: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18411: NOP4
18415: PUSH
18416: NOP4
18420: PPUSH
18421: NOP4
18425: ST_TO_ADDR
// if sources then
18426: NOP4
18430: IFFALSE 18477
// for i = 1 to 3 do
18432: NOP4
18436: PUSH
18437: DOUBLE
18438: LD_INT 1
18440: DEC
18441: ST_TO_ADDR
18442: LD_INT 3
18444: PUSH
18445: FOR_TO
18446: IFFALSE 18475
// AddResourceType ( base , i , sources [ i ] ) ;
18448: NOP4
18452: PPUSH
18453: NOP4
18457: PPUSH
18458: NOP4
18462: PUSH
18463: NOP4
18467: ARRAY
18468: PPUSH
18469: NOP4
18473: GO 18445
18475: POP
18476: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18477: NOP4
18481: PUSH
18482: NOP4
18486: PPUSH
18487: NOP4
18491: PPUSH
18492: LD_INT 1
18494: PPUSH
18495: NOP4
18499: ST_TO_ADDR
// InitHc ;
18500: NOP4
// InitUc ;
18504: NOP4
// uc_side := side ;
18508: LD_ADDR_OWVAR 20
18512: PUSH
18513: NOP4
18517: ST_TO_ADDR
// uc_nation := nation ;
18518: LD_ADDR_OWVAR 21
18522: PUSH
18523: NOP4
18527: ST_TO_ADDR
// if buildings then
18528: NOP4
18532: IFFALSE 19854
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18534: NOP4
18538: PUSH
18539: NOP4
18543: PPUSH
18544: LD_INT 2
18546: PUSH
18547: LD_INT 30
18549: PUSH
18550: LD_INT 29
18552: PUSH
18553: EMPTY
18554: LIST
18555: LIST
18556: PUSH
18557: LD_INT 30
18559: PUSH
18560: LD_INT 30
18562: PUSH
18563: EMPTY
18564: LIST
18565: LIST
18566: PUSH
18567: EMPTY
18568: LIST
18569: LIST
18570: LIST
18571: PPUSH
18572: NOP4
18576: ST_TO_ADDR
// if tmp then
18577: NOP4
18581: IFFALSE 18629
// for i in tmp do
18583: NOP4
18587: PUSH
18588: NOP4
18592: PUSH
18593: FOR_IN
18594: IFFALSE 18627
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18596: NOP4
18600: PPUSH
18601: NOP4
18605: PPUSH
18606: NOP4
18610: PPUSH
18611: NOP4
18615: PPUSH
18616: NOP4
18620: PPUSH
18621: NOP4
18625: GO 18593
18627: POP
18628: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18629: NOP4
18633: PPUSH
18634: LD_INT 2
18636: PUSH
18637: LD_INT 30
18639: PUSH
18640: LD_INT 32
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PUSH
18647: LD_INT 30
18649: PUSH
18650: LD_INT 33
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: PUSH
18657: EMPTY
18658: LIST
18659: LIST
18660: LIST
18661: PPUSH
18662: NOP4
18666: IFFALSE 18754
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18668: NOP4
18672: PUSH
18673: NOP4
18677: PPUSH
18678: LD_INT 2
18680: PUSH
18681: LD_INT 30
18683: PUSH
18684: LD_INT 32
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 30
18693: PUSH
18694: LD_INT 33
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: PUSH
18701: EMPTY
18702: LIST
18703: LIST
18704: LIST
18705: PPUSH
18706: NOP4
18710: PUSH
18711: FOR_IN
18712: IFFALSE 18752
// begin if not GetBWeapon ( i ) then
18714: NOP4
18718: PPUSH
18719: NOP4
18723: NOT
18724: IFFALSE 18750
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18726: NOP4
18730: PPUSH
18731: NOP4
18735: PPUSH
18736: NOP4
18740: PPUSH
18741: NOP4
18745: PPUSH
18746: NOP4
// end ;
18750: GO 18711
18752: POP
18753: POP
// end ; for i = 1 to personel do
18754: NOP4
18758: PUSH
18759: DOUBLE
18760: LD_INT 1
18762: DEC
18763: ST_TO_ADDR
18764: NOP4
18768: PUSH
18769: FOR_TO
18770: IFFALSE 19834
// begin if i > 4 then
18772: NOP4
18776: PUSH
18777: LD_INT 4
18779: GREATER
18780: IFFALSE 18784
// break ;
18782: GO 19834
// case i of 1 :
18784: NOP4
18788: PUSH
18789: LD_INT 1
18791: DOUBLE
18792: EQUAL
18793: IFTRUE 18797
18795: GO 18877
18797: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18798: NOP4
18802: PUSH
18803: NOP4
18807: PPUSH
18808: LD_INT 22
18810: PUSH
18811: NOP4
18815: PUSH
18816: EMPTY
18817: LIST
18818: LIST
18819: PUSH
18820: LD_INT 58
18822: PUSH
18823: EMPTY
18824: LIST
18825: PUSH
18826: LD_INT 2
18828: PUSH
18829: LD_INT 30
18831: PUSH
18832: LD_INT 32
18834: PUSH
18835: EMPTY
18836: LIST
18837: LIST
18838: PUSH
18839: LD_INT 30
18841: PUSH
18842: LD_INT 4
18844: PUSH
18845: EMPTY
18846: LIST
18847: LIST
18848: PUSH
18849: LD_INT 30
18851: PUSH
18852: LD_INT 5
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: LIST
18863: LIST
18864: PUSH
18865: EMPTY
18866: LIST
18867: LIST
18868: LIST
18869: PPUSH
18870: NOP4
18874: ST_TO_ADDR
18875: GO 19099
18877: LD_INT 2
18879: DOUBLE
18880: EQUAL
18881: IFTRUE 18885
18883: GO 18947
18885: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18886: NOP4
18890: PUSH
18891: NOP4
18895: PPUSH
18896: LD_INT 22
18898: PUSH
18899: NOP4
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 2
18910: PUSH
18911: LD_INT 30
18913: PUSH
18914: LD_INT 0
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: PUSH
18921: LD_INT 30
18923: PUSH
18924: LD_INT 1
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: LIST
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: PPUSH
18940: NOP4
18944: ST_TO_ADDR
18945: GO 19099
18947: LD_INT 3
18949: DOUBLE
18950: EQUAL
18951: IFTRUE 18955
18953: GO 19017
18955: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18956: NOP4
18960: PUSH
18961: NOP4
18965: PPUSH
18966: LD_INT 22
18968: PUSH
18969: NOP4
18973: PUSH
18974: EMPTY
18975: LIST
18976: LIST
18977: PUSH
18978: LD_INT 2
18980: PUSH
18981: LD_INT 30
18983: PUSH
18984: LD_INT 2
18986: PUSH
18987: EMPTY
18988: LIST
18989: LIST
18990: PUSH
18991: LD_INT 30
18993: PUSH
18994: LD_INT 3
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: PUSH
19001: EMPTY
19002: LIST
19003: LIST
19004: LIST
19005: PUSH
19006: EMPTY
19007: LIST
19008: LIST
19009: PPUSH
19010: NOP4
19014: ST_TO_ADDR
19015: GO 19099
19017: LD_INT 4
19019: DOUBLE
19020: EQUAL
19021: IFTRUE 19025
19023: GO 19098
19025: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
19026: NOP4
19030: PUSH
19031: NOP4
19035: PPUSH
19036: LD_INT 22
19038: PUSH
19039: NOP4
19043: PUSH
19044: EMPTY
19045: LIST
19046: LIST
19047: PUSH
19048: LD_INT 2
19050: PUSH
19051: LD_INT 30
19053: PUSH
19054: LD_INT 6
19056: PUSH
19057: EMPTY
19058: LIST
19059: LIST
19060: PUSH
19061: LD_INT 30
19063: PUSH
19064: LD_INT 7
19066: PUSH
19067: EMPTY
19068: LIST
19069: LIST
19070: PUSH
19071: LD_INT 30
19073: PUSH
19074: LD_INT 8
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: PUSH
19081: EMPTY
19082: LIST
19083: LIST
19084: LIST
19085: LIST
19086: PUSH
19087: EMPTY
19088: LIST
19089: LIST
19090: PPUSH
19091: NOP4
19095: ST_TO_ADDR
19096: GO 19099
19098: POP
// if i = 1 then
19099: NOP4
19103: PUSH
19104: LD_INT 1
19106: EQUAL
19107: IFFALSE 19218
// begin tmp := [ ] ;
19109: NOP4
19113: PUSH
19114: EMPTY
19115: ST_TO_ADDR
// for j in f do
19116: NOP4
19120: PUSH
19121: NOP4
19125: PUSH
19126: FOR_IN
19127: IFFALSE 19200
// if GetBType ( j ) = b_bunker then
19129: NOP4
19133: PPUSH
19134: NOP4
19138: PUSH
19139: LD_INT 32
19141: EQUAL
19142: IFFALSE 19169
// tmp := Insert ( tmp , 1 , j ) else
19144: NOP4
19148: PUSH
19149: NOP4
19153: PPUSH
19154: LD_INT 1
19156: PPUSH
19157: NOP4
19161: PPUSH
19162: NOP4
19166: ST_TO_ADDR
19167: GO 19198
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19169: NOP4
19173: PUSH
19174: NOP4
19178: PPUSH
19179: NOP4
19183: PUSH
19184: LD_INT 1
19186: PLUS
19187: PPUSH
19188: NOP4
19192: PPUSH
19193: NOP4
19197: ST_TO_ADDR
19198: GO 19126
19200: POP
19201: POP
// if tmp then
19202: NOP4
19206: IFFALSE 19218
// f := tmp ;
19208: NOP4
19212: PUSH
19213: NOP4
19217: ST_TO_ADDR
// end ; x := personel [ i ] ;
19218: NOP4
19222: PUSH
19223: NOP4
19227: PUSH
19228: NOP4
19232: ARRAY
19233: ST_TO_ADDR
// if x = - 1 then
19234: NOP4
19238: PUSH
19239: LD_INT 1
19241: NEG
19242: EQUAL
19243: IFFALSE 19452
// begin for j in f do
19245: NOP4
19249: PUSH
19250: NOP4
19254: PUSH
19255: FOR_IN
19256: IFFALSE 19448
// repeat InitHc ;
19258: NOP4
// if GetBType ( j ) = b_barracks then
19262: NOP4
19266: PPUSH
19267: NOP4
19271: PUSH
19272: LD_INT 5
19274: EQUAL
19275: IFFALSE 19345
// begin if UnitsInside ( j ) < 3 then
19277: NOP4
19281: PPUSH
19282: NOP4
19286: PUSH
19287: LD_INT 3
19289: LESS
19290: IFFALSE 19326
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19292: LD_INT 0
19294: PPUSH
19295: LD_INT 5
19297: PUSH
19298: LD_INT 8
19300: PUSH
19301: LD_INT 9
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: LIST
19308: PUSH
19309: NOP4
19313: ARRAY
19314: PPUSH
19315: NOP4
19319: PPUSH
19320: NOP4
19324: GO 19343
// PrepareHuman ( false , i , skill ) ;
19326: LD_INT 0
19328: PPUSH
19329: NOP4
19333: PPUSH
19334: NOP4
19338: PPUSH
19339: NOP4
// end else
19343: GO 19362
// PrepareHuman ( false , i , skill ) ;
19345: LD_INT 0
19347: PPUSH
19348: NOP4
19352: PPUSH
19353: NOP4
19357: PPUSH
19358: NOP4
// un := CreateHuman ;
19362: NOP4
19366: PUSH
19367: NOP4
19371: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19372: NOP4
19376: PUSH
19377: NOP4
19381: PPUSH
19382: LD_INT 1
19384: PPUSH
19385: NOP4
19389: PPUSH
19390: NOP4
19394: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19395: NOP4
19399: PPUSH
19400: NOP4
19404: PPUSH
19405: NOP4
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19409: NOP4
19413: PPUSH
19414: NOP4
19418: PUSH
19419: LD_INT 6
19421: EQUAL
19422: PUSH
19423: NOP4
19427: PPUSH
19428: NOP4
19432: PUSH
19433: LD_INT 32
19435: PUSH
19436: LD_INT 31
19438: PUSH
19439: EMPTY
19440: LIST
19441: LIST
19442: IN
19443: OR
19444: IFFALSE 19258
19446: GO 19255
19448: POP
19449: POP
// end else
19450: GO 19832
// for j = 1 to x do
19452: NOP4
19456: PUSH
19457: DOUBLE
19458: LD_INT 1
19460: DEC
19461: ST_TO_ADDR
19462: NOP4
19466: PUSH
19467: FOR_TO
19468: IFFALSE 19830
// begin InitHc ;
19470: NOP4
// if not f then
19474: NOP4
19478: NOT
19479: IFFALSE 19568
// begin PrepareHuman ( false , i , skill ) ;
19481: LD_INT 0
19483: PPUSH
19484: NOP4
19488: PPUSH
19489: NOP4
19493: PPUSH
19494: NOP4
// un := CreateHuman ;
19498: NOP4
19502: PUSH
19503: NOP4
19507: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19508: NOP4
19512: PUSH
19513: NOP4
19517: PPUSH
19518: LD_INT 1
19520: PPUSH
19521: NOP4
19525: PPUSH
19526: NOP4
19530: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19531: NOP4
19535: PPUSH
19536: NOP4
19540: PPUSH
19541: NOP4
19545: PPUSH
19546: NOP4
19550: PPUSH
19551: NOP4
19555: PPUSH
19556: LD_INT 10
19558: PPUSH
19559: LD_INT 0
19561: PPUSH
19562: NOP4
// continue ;
19566: GO 19467
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19568: NOP4
19572: PUSH
19573: LD_INT 1
19575: ARRAY
19576: PPUSH
19577: NOP4
19581: PUSH
19582: NOP4
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PPUSH
19591: NOP4
19595: PUSH
19596: LD_INT 32
19598: PUSH
19599: LD_INT 31
19601: PUSH
19602: EMPTY
19603: LIST
19604: LIST
19605: IN
19606: AND
19607: PUSH
19608: NOP4
19612: PUSH
19613: LD_INT 1
19615: ARRAY
19616: PPUSH
19617: NOP4
19621: PUSH
19622: LD_INT 6
19624: EQUAL
19625: OR
19626: IFFALSE 19646
// f := Delete ( f , 1 ) ;
19628: NOP4
19632: PUSH
19633: NOP4
19637: PPUSH
19638: LD_INT 1
19640: PPUSH
19641: NOP4
19645: ST_TO_ADDR
// if not f then
19646: NOP4
19650: NOT
19651: IFFALSE 19669
// begin x := x + 2 ;
19653: NOP4
19657: PUSH
19658: NOP4
19662: PUSH
19663: LD_INT 2
19665: PLUS
19666: ST_TO_ADDR
// continue ;
19667: GO 19467
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19669: NOP4
19673: PUSH
19674: LD_INT 1
19676: ARRAY
19677: PPUSH
19678: NOP4
19682: PUSH
19683: LD_INT 5
19685: EQUAL
19686: IFFALSE 19760
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19688: NOP4
19692: PUSH
19693: LD_INT 1
19695: ARRAY
19696: PPUSH
19697: NOP4
19701: PUSH
19702: LD_INT 3
19704: LESS
19705: IFFALSE 19741
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19707: LD_INT 0
19709: PPUSH
19710: LD_INT 5
19712: PUSH
19713: LD_INT 8
19715: PUSH
19716: LD_INT 9
19718: PUSH
19719: EMPTY
19720: LIST
19721: LIST
19722: LIST
19723: PUSH
19724: NOP4
19728: ARRAY
19729: PPUSH
19730: NOP4
19734: PPUSH
19735: NOP4
19739: GO 19758
// PrepareHuman ( false , i , skill ) ;
19741: LD_INT 0
19743: PPUSH
19744: NOP4
19748: PPUSH
19749: NOP4
19753: PPUSH
19754: NOP4
// end else
19758: GO 19777
// PrepareHuman ( false , i , skill ) ;
19760: LD_INT 0
19762: PPUSH
19763: NOP4
19767: PPUSH
19768: NOP4
19772: PPUSH
19773: NOP4
// un := CreateHuman ;
19777: NOP4
19781: PUSH
19782: NOP4
19786: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19787: NOP4
19791: PUSH
19792: NOP4
19796: PPUSH
19797: LD_INT 1
19799: PPUSH
19800: NOP4
19804: PPUSH
19805: NOP4
19809: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19810: NOP4
19814: PPUSH
19815: NOP4
19819: PUSH
19820: LD_INT 1
19822: ARRAY
19823: PPUSH
19824: NOP4
// end ;
19828: GO 19467
19830: POP
19831: POP
// end ;
19832: GO 18769
19834: POP
19835: POP
// result := result ^ buildings ;
19836: NOP4
19840: PUSH
19841: NOP4
19845: PUSH
19846: NOP4
19850: ADD
19851: ST_TO_ADDR
// end else
19852: GO 19995
// begin for i = 1 to personel do
19854: NOP4
19858: PUSH
19859: DOUBLE
19860: LD_INT 1
19862: DEC
19863: ST_TO_ADDR
19864: NOP4
19868: PUSH
19869: FOR_TO
19870: IFFALSE 19993
// begin if i > 4 then
19872: NOP4
19876: PUSH
19877: LD_INT 4
19879: GREATER
19880: IFFALSE 19884
// break ;
19882: GO 19993
// x := personel [ i ] ;
19884: NOP4
19888: PUSH
19889: NOP4
19893: PUSH
19894: NOP4
19898: ARRAY
19899: ST_TO_ADDR
// if x = - 1 then
19900: NOP4
19904: PUSH
19905: LD_INT 1
19907: NEG
19908: EQUAL
19909: IFFALSE 19913
// continue ;
19911: GO 19869
// PrepareHuman ( false , i , skill ) ;
19913: LD_INT 0
19915: PPUSH
19916: NOP4
19920: PPUSH
19921: NOP4
19925: PPUSH
19926: NOP4
// un := CreateHuman ;
19930: NOP4
19934: PUSH
19935: NOP4
19939: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19940: NOP4
19944: PPUSH
19945: NOP4
19949: PPUSH
19950: NOP4
19954: PPUSH
19955: NOP4
19959: PPUSH
19960: NOP4
19964: PPUSH
19965: LD_INT 10
19967: PPUSH
19968: LD_INT 0
19970: PPUSH
19971: NOP4
// result := result ^ un ;
19975: NOP4
19979: PUSH
19980: NOP4
19984: PUSH
19985: NOP4
19989: ADD
19990: ST_TO_ADDR
// end ;
19991: GO 19869
19993: POP
19994: POP
// end ; end ;
19995: LD_VAR 0 7
19999: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
20000: LD_INT 0
20002: PPUSH
20003: PPUSH
20004: PPUSH
20005: PPUSH
20006: PPUSH
20007: PPUSH
20008: PPUSH
20009: PPUSH
20010: PPUSH
20011: PPUSH
20012: PPUSH
20013: PPUSH
20014: PPUSH
20015: PPUSH
20016: PPUSH
20017: PPUSH
// result := false ;
20018: NOP4
20022: PUSH
20023: LD_INT 0
20025: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
20026: NOP4
20030: NOT
20031: PUSH
20032: NOP4
20036: PPUSH
20037: NOP4
20041: PUSH
20042: LD_INT 32
20044: PUSH
20045: LD_INT 33
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: IN
20052: NOT
20053: OR
20054: IFFALSE 20058
// exit ;
20056: GO 21167
// nat := GetNation ( tower ) ;
20058: NOP4
20062: PUSH
20063: NOP4
20067: PPUSH
20068: NOP4
20072: ST_TO_ADDR
// side := GetSide ( tower ) ;
20073: NOP4
20077: PUSH
20078: NOP4
20082: PPUSH
20083: NOP4
20087: ST_TO_ADDR
// x := GetX ( tower ) ;
20088: NOP4
20092: PUSH
20093: NOP4
20097: PPUSH
20098: NOP4
20102: ST_TO_ADDR
// y := GetY ( tower ) ;
20103: NOP4
20107: PUSH
20108: NOP4
20112: PPUSH
20113: NOP4
20117: ST_TO_ADDR
// if not x or not y then
20118: NOP4
20122: NOT
20123: PUSH
20124: NOP4
20128: NOT
20129: OR
20130: IFFALSE 20134
// exit ;
20132: GO 21167
// weapon := 0 ;
20134: NOP4
20138: PUSH
20139: LD_INT 0
20141: ST_TO_ADDR
// fac_list := [ ] ;
20142: NOP4
20146: PUSH
20147: EMPTY
20148: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20149: NOP4
20153: PUSH
20154: NOP4
20158: PPUSH
20159: NOP4
20163: PPUSH
20164: NOP4
20168: PPUSH
20169: LD_INT 0
20171: PPUSH
20172: NOP4
20176: PPUSH
20177: LD_INT 30
20179: PUSH
20180: LD_INT 3
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: PPUSH
20187: NOP4
20191: ST_TO_ADDR
// if not factories then
20192: NOP4
20196: NOT
20197: IFFALSE 20201
// exit ;
20199: GO 21167
// for i in factories do
20201: NOP4
20205: PUSH
20206: NOP4
20210: PUSH
20211: FOR_IN
20212: IFFALSE 20237
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20214: NOP4
20218: PUSH
20219: NOP4
20223: PUSH
20224: NOP4
20228: PPUSH
20229: NOP4
20233: UNION
20234: ST_TO_ADDR
20235: GO 20211
20237: POP
20238: POP
// if not fac_list then
20239: NOP4
20243: NOT
20244: IFFALSE 20248
// exit ;
20246: GO 21167
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20248: NOP4
20252: PUSH
20253: LD_INT 4
20255: PUSH
20256: LD_INT 5
20258: PUSH
20259: LD_INT 9
20261: PUSH
20262: LD_INT 10
20264: PUSH
20265: LD_INT 6
20267: PUSH
20268: LD_INT 7
20270: PUSH
20271: LD_INT 11
20273: PUSH
20274: EMPTY
20275: LIST
20276: LIST
20277: LIST
20278: LIST
20279: LIST
20280: LIST
20281: LIST
20282: PUSH
20283: LD_INT 27
20285: PUSH
20286: LD_INT 28
20288: PUSH
20289: LD_INT 26
20291: PUSH
20292: LD_INT 30
20294: PUSH
20295: EMPTY
20296: LIST
20297: LIST
20298: LIST
20299: LIST
20300: PUSH
20301: LD_INT 43
20303: PUSH
20304: LD_INT 44
20306: PUSH
20307: LD_INT 46
20309: PUSH
20310: LD_INT 45
20312: PUSH
20313: LD_INT 47
20315: PUSH
20316: LD_INT 49
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: LIST
20331: PUSH
20332: NOP4
20336: ARRAY
20337: ST_TO_ADDR
// list := list isect fac_list ;
20338: NOP4
20342: PUSH
20343: NOP4
20347: PUSH
20348: NOP4
20352: ISECT
20353: ST_TO_ADDR
// if not list then
20354: NOP4
20358: NOT
20359: IFFALSE 20363
// exit ;
20361: GO 21167
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20363: NOP4
20367: PUSH
20368: LD_INT 3
20370: EQUAL
20371: PUSH
20372: LD_INT 49
20374: PUSH
20375: NOP4
20379: IN
20380: AND
20381: PUSH
20382: LD_INT 31
20384: PPUSH
20385: NOP4
20389: PPUSH
20390: NOP4
20394: PUSH
20395: LD_INT 2
20397: EQUAL
20398: AND
20399: IFFALSE 20459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20401: LD_INT 22
20403: PUSH
20404: NOP4
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: PUSH
20413: LD_INT 35
20415: PUSH
20416: LD_INT 49
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: PUSH
20423: LD_INT 91
20425: PUSH
20426: NOP4
20430: PUSH
20431: LD_INT 10
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: LIST
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: PPUSH
20444: NOP4
20448: NOT
20449: IFFALSE 20459
// weapon := ru_time_lapser ;
20451: NOP4
20455: PUSH
20456: LD_INT 49
20458: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20459: NOP4
20463: PUSH
20464: LD_INT 1
20466: PUSH
20467: LD_INT 2
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: IN
20474: PUSH
20475: LD_INT 11
20477: PUSH
20478: NOP4
20482: IN
20483: PUSH
20484: LD_INT 30
20486: PUSH
20487: NOP4
20491: IN
20492: OR
20493: AND
20494: PUSH
20495: LD_INT 6
20497: PPUSH
20498: NOP4
20502: PPUSH
20503: NOP4
20507: PUSH
20508: LD_INT 2
20510: EQUAL
20511: AND
20512: IFFALSE 20677
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20514: LD_INT 22
20516: PUSH
20517: NOP4
20521: PUSH
20522: EMPTY
20523: LIST
20524: LIST
20525: PUSH
20526: LD_INT 2
20528: PUSH
20529: LD_INT 35
20531: PUSH
20532: LD_INT 11
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: PUSH
20539: LD_INT 35
20541: PUSH
20542: LD_INT 30
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: LIST
20553: PUSH
20554: LD_INT 91
20556: PUSH
20557: NOP4
20561: PUSH
20562: LD_INT 18
20564: PUSH
20565: EMPTY
20566: LIST
20567: LIST
20568: LIST
20569: PUSH
20570: EMPTY
20571: LIST
20572: LIST
20573: LIST
20574: PPUSH
20575: NOP4
20579: NOT
20580: PUSH
20581: LD_INT 22
20583: PUSH
20584: NOP4
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: PUSH
20593: LD_INT 2
20595: PUSH
20596: LD_INT 30
20598: PUSH
20599: LD_INT 32
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: LD_INT 30
20608: PUSH
20609: LD_INT 33
20611: PUSH
20612: EMPTY
20613: LIST
20614: LIST
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: LIST
20620: PUSH
20621: LD_INT 91
20623: PUSH
20624: NOP4
20628: PUSH
20629: LD_INT 12
20631: PUSH
20632: EMPTY
20633: LIST
20634: LIST
20635: LIST
20636: PUSH
20637: EMPTY
20638: LIST
20639: LIST
20640: LIST
20641: PUSH
20642: EMPTY
20643: LIST
20644: PPUSH
20645: NOP4
20649: PUSH
20650: LD_INT 2
20652: GREATER
20653: AND
20654: IFFALSE 20677
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20656: NOP4
20660: PUSH
20661: LD_INT 11
20663: PUSH
20664: LD_INT 30
20666: PUSH
20667: EMPTY
20668: LIST
20669: LIST
20670: PUSH
20671: NOP4
20675: ARRAY
20676: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20677: NOP4
20681: NOT
20682: PUSH
20683: LD_INT 40
20685: PPUSH
20686: NOP4
20690: PPUSH
20691: NOP4
20695: PUSH
20696: LD_INT 2
20698: EQUAL
20699: AND
20700: PUSH
20701: LD_INT 7
20703: PUSH
20704: NOP4
20708: IN
20709: PUSH
20710: LD_INT 28
20712: PUSH
20713: NOP4
20717: IN
20718: OR
20719: PUSH
20720: LD_INT 45
20722: PUSH
20723: NOP4
20727: IN
20728: OR
20729: AND
20730: IFFALSE 20984
// begin hex := GetHexInfo ( x , y ) ;
20732: NOP4
20736: PUSH
20737: NOP4
20741: PPUSH
20742: NOP4
20746: PPUSH
20747: NOP4
20751: ST_TO_ADDR
// if hex [ 1 ] then
20752: NOP4
20756: PUSH
20757: LD_INT 1
20759: ARRAY
20760: IFFALSE 20764
// exit ;
20762: GO 21167
// height := hex [ 2 ] ;
20764: NOP4
20768: PUSH
20769: NOP4
20773: PUSH
20774: LD_INT 2
20776: ARRAY
20777: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20778: NOP4
20782: PUSH
20783: LD_INT 0
20785: PUSH
20786: LD_INT 2
20788: PUSH
20789: LD_INT 3
20791: PUSH
20792: LD_INT 5
20794: PUSH
20795: EMPTY
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: ST_TO_ADDR
// for i in tmp do
20801: NOP4
20805: PUSH
20806: NOP4
20810: PUSH
20811: FOR_IN
20812: IFFALSE 20982
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20814: NOP4
20818: PUSH
20819: NOP4
20823: PPUSH
20824: NOP4
20828: PPUSH
20829: LD_INT 5
20831: PPUSH
20832: NOP4
20836: PUSH
20837: NOP4
20841: PPUSH
20842: NOP4
20846: PPUSH
20847: LD_INT 5
20849: PPUSH
20850: NOP4
20854: PUSH
20855: EMPTY
20856: LIST
20857: LIST
20858: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20859: NOP4
20863: PUSH
20864: LD_INT 1
20866: ARRAY
20867: PPUSH
20868: NOP4
20872: PUSH
20873: LD_INT 2
20875: ARRAY
20876: PPUSH
20877: NOP4
20881: IFFALSE 20980
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20883: NOP4
20887: PUSH
20888: NOP4
20892: PUSH
20893: LD_INT 1
20895: ARRAY
20896: PPUSH
20897: NOP4
20901: PUSH
20902: LD_INT 2
20904: ARRAY
20905: PPUSH
20906: NOP4
20910: ST_TO_ADDR
// if hex [ 1 ] then
20911: NOP4
20915: PUSH
20916: LD_INT 1
20918: ARRAY
20919: IFFALSE 20923
// continue ;
20921: GO 20811
// h := hex [ 2 ] ;
20923: NOP4
20927: PUSH
20928: NOP4
20932: PUSH
20933: LD_INT 2
20935: ARRAY
20936: ST_TO_ADDR
// if h + 7 < height then
20937: NOP4
20941: PUSH
20942: LD_INT 7
20944: PLUS
20945: PUSH
20946: NOP4
20950: LESS
20951: IFFALSE 20980
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20953: NOP4
20957: PUSH
20958: LD_INT 7
20960: PUSH
20961: LD_INT 28
20963: PUSH
20964: LD_INT 45
20966: PUSH
20967: EMPTY
20968: LIST
20969: LIST
20970: LIST
20971: PUSH
20972: NOP4
20976: ARRAY
20977: ST_TO_ADDR
// break ;
20978: GO 20982
// end ; end ; end ;
20980: GO 20811
20982: POP
20983: POP
// end ; if not weapon then
20984: NOP4
20988: NOT
20989: IFFALSE 21049
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20991: NOP4
20995: PUSH
20996: NOP4
21000: PUSH
21001: LD_INT 11
21003: PUSH
21004: LD_INT 30
21006: PUSH
21007: LD_INT 49
21009: PUSH
21010: EMPTY
21011: LIST
21012: LIST
21013: LIST
21014: DIFF
21015: ST_TO_ADDR
// if not list then
21016: NOP4
21020: NOT
21021: IFFALSE 21025
// exit ;
21023: GO 21167
// weapon := list [ rand ( 1 , list ) ] ;
21025: NOP4
21029: PUSH
21030: NOP4
21034: PUSH
21035: LD_INT 1
21037: PPUSH
21038: NOP4
21042: PPUSH
21043: NOP4
21047: ARRAY
21048: ST_TO_ADDR
// end ; if weapon then
21049: NOP4
21053: IFFALSE 21167
// begin tmp := CostOfWeapon ( weapon ) ;
21055: NOP4
21059: PUSH
21060: NOP4
21064: PPUSH
21065: NOP4
21069: ST_TO_ADDR
// j := GetBase ( tower ) ;
21070: NOP4
21074: PUSH
21075: NOP4
21079: PPUSH
21080: NOP4
21084: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21085: NOP4
21089: PPUSH
21090: LD_INT 1
21092: PPUSH
21093: NOP4
21097: PUSH
21098: NOP4
21102: PUSH
21103: LD_INT 1
21105: ARRAY
21106: GREATEREQUAL
21107: PUSH
21108: NOP4
21112: PPUSH
21113: LD_INT 2
21115: PPUSH
21116: NOP4
21120: PUSH
21121: NOP4
21125: PUSH
21126: LD_INT 2
21128: ARRAY
21129: GREATEREQUAL
21130: AND
21131: PUSH
21132: NOP4
21136: PPUSH
21137: LD_INT 3
21139: PPUSH
21140: NOP4
21144: PUSH
21145: NOP4
21149: PUSH
21150: LD_INT 3
21152: ARRAY
21153: GREATEREQUAL
21154: AND
21155: IFFALSE 21167
// result := weapon ;
21157: NOP4
21161: PUSH
21162: NOP4
21166: ST_TO_ADDR
// end ; end ;
21167: LD_VAR 0 3
21171: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21172: LD_INT 0
21174: PPUSH
21175: PPUSH
// result := true ;
21176: NOP4
21180: PUSH
21181: LD_INT 1
21183: ST_TO_ADDR
// if array1 = array2 then
21184: NOP4
21188: PUSH
21189: NOP4
21193: EQUAL
21194: IFFALSE 21254
// begin for i = 1 to array1 do
21196: NOP4
21200: PUSH
21201: DOUBLE
21202: LD_INT 1
21204: DEC
21205: ST_TO_ADDR
21206: NOP4
21210: PUSH
21211: FOR_TO
21212: IFFALSE 21250
// if array1 [ i ] <> array2 [ i ] then
21214: NOP4
21218: PUSH
21219: NOP4
21223: ARRAY
21224: PUSH
21225: NOP4
21229: PUSH
21230: NOP4
21234: ARRAY
21235: NONEQUAL
21236: IFFALSE 21248
// begin result := false ;
21238: NOP4
21242: PUSH
21243: LD_INT 0
21245: ST_TO_ADDR
// break ;
21246: GO 21250
// end ;
21248: GO 21211
21250: POP
21251: POP
// end else
21252: GO 21262
// result := false ;
21254: NOP4
21258: PUSH
21259: LD_INT 0
21261: ST_TO_ADDR
// end ;
21262: LD_VAR 0 3
21266: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21267: LD_INT 0
21269: PPUSH
21270: PPUSH
// if not array1 or not array2 then
21271: NOP4
21275: NOT
21276: PUSH
21277: NOP4
21281: NOT
21282: OR
21283: IFFALSE 21287
// exit ;
21285: GO 21351
// result := true ;
21287: NOP4
21291: PUSH
21292: LD_INT 1
21294: ST_TO_ADDR
// for i = 1 to array1 do
21295: NOP4
21299: PUSH
21300: DOUBLE
21301: LD_INT 1
21303: DEC
21304: ST_TO_ADDR
21305: NOP4
21309: PUSH
21310: FOR_TO
21311: IFFALSE 21349
// if array1 [ i ] <> array2 [ i ] then
21313: NOP4
21317: PUSH
21318: NOP4
21322: ARRAY
21323: PUSH
21324: NOP4
21328: PUSH
21329: NOP4
21333: ARRAY
21334: NONEQUAL
21335: IFFALSE 21347
// begin result := false ;
21337: NOP4
21341: PUSH
21342: LD_INT 0
21344: ST_TO_ADDR
// break ;
21345: GO 21349
// end ;
21347: GO 21310
21349: POP
21350: POP
// end ;
21351: LD_VAR 0 3
21355: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21356: LD_INT 0
21358: PPUSH
21359: PPUSH
21360: PPUSH
// pom := GetBase ( fac ) ;
21361: NOP4
21365: PUSH
21366: NOP4
21370: PPUSH
21371: NOP4
21375: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21376: NOP4
21380: PUSH
21381: NOP4
21385: PUSH
21386: LD_INT 1
21388: ARRAY
21389: PPUSH
21390: NOP4
21394: PUSH
21395: LD_INT 2
21397: ARRAY
21398: PPUSH
21399: NOP4
21403: PUSH
21404: LD_INT 3
21406: ARRAY
21407: PPUSH
21408: NOP4
21412: PUSH
21413: LD_INT 4
21415: ARRAY
21416: PPUSH
21417: NOP4
21421: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21422: NOP4
21426: PUSH
21427: NOP4
21431: PPUSH
21432: LD_INT 1
21434: PPUSH
21435: NOP4
21439: PUSH
21440: NOP4
21444: PUSH
21445: LD_INT 1
21447: ARRAY
21448: GREATEREQUAL
21449: PUSH
21450: NOP4
21454: PPUSH
21455: LD_INT 2
21457: PPUSH
21458: NOP4
21462: PUSH
21463: NOP4
21467: PUSH
21468: LD_INT 2
21470: ARRAY
21471: GREATEREQUAL
21472: AND
21473: PUSH
21474: NOP4
21478: PPUSH
21479: LD_INT 3
21481: PPUSH
21482: NOP4
21486: PUSH
21487: NOP4
21491: PUSH
21492: LD_INT 3
21494: ARRAY
21495: GREATEREQUAL
21496: AND
21497: ST_TO_ADDR
// end ;
21498: LD_VAR 0 3
21502: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21503: LD_INT 0
21505: PPUSH
21506: PPUSH
21507: PPUSH
21508: PPUSH
// pom := GetBase ( building ) ;
21509: NOP4
21513: PUSH
21514: NOP4
21518: PPUSH
21519: NOP4
21523: ST_TO_ADDR
// if not pom then
21524: NOP4
21528: NOT
21529: IFFALSE 21533
// exit ;
21531: GO 21703
// btype := GetBType ( building ) ;
21533: NOP4
21537: PUSH
21538: NOP4
21542: PPUSH
21543: NOP4
21547: ST_TO_ADDR
// if btype = b_armoury then
21548: NOP4
21552: PUSH
21553: LD_INT 4
21555: EQUAL
21556: IFFALSE 21566
// btype := b_barracks ;
21558: NOP4
21562: PUSH
21563: LD_INT 5
21565: ST_TO_ADDR
// if btype = b_depot then
21566: NOP4
21570: PUSH
21571: LD_INT 0
21573: EQUAL
21574: IFFALSE 21584
// btype := b_warehouse ;
21576: NOP4
21580: PUSH
21581: LD_INT 1
21583: ST_TO_ADDR
// if btype = b_workshop then
21584: NOP4
21588: PUSH
21589: LD_INT 2
21591: EQUAL
21592: IFFALSE 21602
// btype := b_factory ;
21594: NOP4
21598: PUSH
21599: LD_INT 3
21601: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21602: NOP4
21606: PUSH
21607: NOP4
21611: PPUSH
21612: NOP4
21616: PPUSH
21617: NOP4
21621: PPUSH
21622: NOP4
21626: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21627: NOP4
21631: PUSH
21632: NOP4
21636: PPUSH
21637: LD_INT 1
21639: PPUSH
21640: NOP4
21644: PUSH
21645: NOP4
21649: PUSH
21650: LD_INT 1
21652: ARRAY
21653: GREATEREQUAL
21654: PUSH
21655: NOP4
21659: PPUSH
21660: LD_INT 2
21662: PPUSH
21663: NOP4
21667: PUSH
21668: NOP4
21672: PUSH
21673: LD_INT 2
21675: ARRAY
21676: GREATEREQUAL
21677: AND
21678: PUSH
21679: NOP4
21683: PPUSH
21684: LD_INT 3
21686: PPUSH
21687: NOP4
21691: PUSH
21692: NOP4
21696: PUSH
21697: LD_INT 3
21699: ARRAY
21700: GREATEREQUAL
21701: AND
21702: ST_TO_ADDR
// end ;
21703: LD_VAR 0 2
21707: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21708: LD_INT 0
21710: PPUSH
21711: PPUSH
21712: PPUSH
// pom := GetBase ( building ) ;
21713: NOP4
21717: PUSH
21718: NOP4
21722: PPUSH
21723: NOP4
21727: ST_TO_ADDR
// if not pom then
21728: NOP4
21732: NOT
21733: IFFALSE 21737
// exit ;
21735: GO 21838
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21737: NOP4
21741: PUSH
21742: NOP4
21746: PPUSH
21747: NOP4
21751: PPUSH
21752: NOP4
21756: PPUSH
21757: NOP4
21761: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21762: NOP4
21766: PUSH
21767: NOP4
21771: PPUSH
21772: LD_INT 1
21774: PPUSH
21775: NOP4
21779: PUSH
21780: NOP4
21784: PUSH
21785: LD_INT 1
21787: ARRAY
21788: GREATEREQUAL
21789: PUSH
21790: NOP4
21794: PPUSH
21795: LD_INT 2
21797: PPUSH
21798: NOP4
21802: PUSH
21803: NOP4
21807: PUSH
21808: LD_INT 2
21810: ARRAY
21811: GREATEREQUAL
21812: AND
21813: PUSH
21814: NOP4
21818: PPUSH
21819: LD_INT 3
21821: PPUSH
21822: NOP4
21826: PUSH
21827: NOP4
21831: PUSH
21832: LD_INT 3
21834: ARRAY
21835: GREATEREQUAL
21836: AND
21837: ST_TO_ADDR
// end ;
21838: LD_VAR 0 3
21842: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21843: LD_INT 0
21845: PPUSH
21846: PPUSH
21847: PPUSH
21848: PPUSH
21849: PPUSH
21850: PPUSH
21851: PPUSH
21852: PPUSH
21853: PPUSH
21854: PPUSH
21855: PPUSH
// result := false ;
21856: NOP4
21860: PUSH
21861: LD_INT 0
21863: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21864: NOP4
21868: NOT
21869: PUSH
21870: NOP4
21874: NOT
21875: OR
21876: PUSH
21877: NOP4
21881: NOT
21882: OR
21883: PUSH
21884: NOP4
21888: NOT
21889: OR
21890: IFFALSE 21894
// exit ;
21892: GO 22708
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21894: NOP4
21898: PUSH
21899: NOP4
21903: PPUSH
21904: NOP4
21908: PPUSH
21909: NOP4
21913: PPUSH
21914: NOP4
21918: PPUSH
21919: NOP4
21923: PUSH
21924: LD_INT 1
21926: ARRAY
21927: PPUSH
21928: NOP4
21932: PPUSH
21933: LD_INT 0
21935: PPUSH
21936: NOP4
21940: ST_TO_ADDR
// if not hexes then
21941: NOP4
21945: NOT
21946: IFFALSE 21950
// exit ;
21948: GO 22708
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21950: NOP4
21954: PUSH
21955: NOP4
21959: PPUSH
21960: LD_INT 22
21962: PUSH
21963: NOP4
21967: PPUSH
21968: NOP4
21972: PUSH
21973: EMPTY
21974: LIST
21975: LIST
21976: PUSH
21977: LD_INT 2
21979: PUSH
21980: LD_INT 30
21982: PUSH
21983: LD_INT 0
21985: PUSH
21986: EMPTY
21987: LIST
21988: LIST
21989: PUSH
21990: LD_INT 30
21992: PUSH
21993: LD_INT 1
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: LIST
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: PPUSH
22009: NOP4
22013: ST_TO_ADDR
// for i = 1 to hexes do
22014: NOP4
22018: PUSH
22019: DOUBLE
22020: LD_INT 1
22022: DEC
22023: ST_TO_ADDR
22024: NOP4
22028: PUSH
22029: FOR_TO
22030: IFFALSE 22706
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22032: NOP4
22036: PUSH
22037: NOP4
22041: PUSH
22042: NOP4
22046: ARRAY
22047: PUSH
22048: LD_INT 1
22050: ARRAY
22051: PPUSH
22052: NOP4
22056: PUSH
22057: NOP4
22061: ARRAY
22062: PUSH
22063: LD_INT 2
22065: ARRAY
22066: PPUSH
22067: NOP4
22071: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
22072: NOP4
22076: PUSH
22077: NOP4
22081: ARRAY
22082: PUSH
22083: LD_INT 1
22085: ARRAY
22086: PPUSH
22087: NOP4
22091: PUSH
22092: NOP4
22096: ARRAY
22097: PUSH
22098: LD_INT 2
22100: ARRAY
22101: PPUSH
22102: NOP4
22106: PUSH
22107: NOP4
22111: PUSH
22112: NOP4
22116: ARRAY
22117: PUSH
22118: LD_INT 1
22120: ARRAY
22121: PPUSH
22122: NOP4
22126: PUSH
22127: NOP4
22131: ARRAY
22132: PUSH
22133: LD_INT 2
22135: ARRAY
22136: PPUSH
22137: NOP4
22141: NOT
22142: OR
22143: PUSH
22144: NOP4
22148: PPUSH
22149: NOP4
22153: PUSH
22154: LD_INT 3
22156: EQUAL
22157: OR
22158: IFFALSE 22164
// exit ;
22160: POP
22161: POP
22162: GO 22708
// if not tmp then
22164: NOP4
22168: NOT
22169: IFFALSE 22173
// continue ;
22171: GO 22029
// result := true ;
22173: NOP4
22177: PUSH
22178: LD_INT 1
22180: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22181: NOP4
22185: PUSH
22186: NOP4
22190: PPUSH
22191: NOP4
22195: PUSH
22196: LD_INT 2
22198: EQUAL
22199: AND
22200: PUSH
22201: NOP4
22205: PPUSH
22206: NOP4
22210: PUSH
22211: LD_INT 1
22213: EQUAL
22214: AND
22215: IFFALSE 22379
// begin if IsDrivenBy ( tmp ) then
22217: NOP4
22221: PPUSH
22222: NOP4
22226: IFFALSE 22230
// continue ;
22228: GO 22029
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22230: NOP4
22234: PPUSH
22235: LD_INT 3
22237: PUSH
22238: LD_INT 60
22240: PUSH
22241: EMPTY
22242: LIST
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: PUSH
22248: LD_INT 3
22250: PUSH
22251: LD_INT 55
22253: PUSH
22254: EMPTY
22255: LIST
22256: PUSH
22257: EMPTY
22258: LIST
22259: LIST
22260: PUSH
22261: EMPTY
22262: LIST
22263: LIST
22264: PPUSH
22265: NOP4
22269: IFFALSE 22377
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22271: NOP4
22275: PUSH
22276: NOP4
22280: PPUSH
22281: LD_INT 3
22283: PUSH
22284: LD_INT 60
22286: PUSH
22287: EMPTY
22288: LIST
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: PUSH
22294: LD_INT 3
22296: PUSH
22297: LD_INT 55
22299: PUSH
22300: EMPTY
22301: LIST
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: PUSH
22307: EMPTY
22308: LIST
22309: LIST
22310: PPUSH
22311: NOP4
22315: PUSH
22316: LD_INT 1
22318: ARRAY
22319: ST_TO_ADDR
// if IsInUnit ( driver ) then
22320: NOP4
22324: PPUSH
22325: NOP4
22329: IFFALSE 22340
// ComExit ( driver ) ;
22331: NOP4
22335: PPUSH
22336: NOP4
// AddComEnterUnit ( driver , tmp ) ;
22340: NOP4
22344: PPUSH
22345: NOP4
22349: PPUSH
22350: NOP4
// AddComMoveToArea ( driver , parking ) ;
22354: NOP4
22358: PPUSH
22359: NOP4
22363: PPUSH
22364: NOP4
// AddComExitVehicle ( driver ) ;
22368: NOP4
22372: PPUSH
22373: NOP4
// end ; continue ;
22377: GO 22029
// end ; if not cleaners or not tmp in cleaners then
22379: NOP4
22383: NOT
22384: PUSH
22385: NOP4
22389: PUSH
22390: NOP4
22394: IN
22395: NOT
22396: OR
22397: IFFALSE 22704
// begin if dep then
22399: NOP4
22403: IFFALSE 22539
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22405: NOP4
22409: PUSH
22410: NOP4
22414: PUSH
22415: LD_INT 1
22417: ARRAY
22418: PPUSH
22419: NOP4
22423: PPUSH
22424: NOP4
22428: PUSH
22429: LD_INT 1
22431: ARRAY
22432: PPUSH
22433: NOP4
22437: PPUSH
22438: LD_INT 5
22440: PPUSH
22441: NOP4
22445: PUSH
22446: NOP4
22450: PUSH
22451: LD_INT 1
22453: ARRAY
22454: PPUSH
22455: NOP4
22459: PPUSH
22460: NOP4
22464: PUSH
22465: LD_INT 1
22467: ARRAY
22468: PPUSH
22469: NOP4
22473: PPUSH
22474: LD_INT 5
22476: PPUSH
22477: NOP4
22481: PUSH
22482: EMPTY
22483: LIST
22484: LIST
22485: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22486: NOP4
22490: PUSH
22491: LD_INT 1
22493: ARRAY
22494: PPUSH
22495: NOP4
22499: PUSH
22500: LD_INT 2
22502: ARRAY
22503: PPUSH
22504: NOP4
22508: IFFALSE 22539
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22510: NOP4
22514: PPUSH
22515: NOP4
22519: PUSH
22520: LD_INT 1
22522: ARRAY
22523: PPUSH
22524: NOP4
22528: PUSH
22529: LD_INT 2
22531: ARRAY
22532: PPUSH
22533: NOP4
// continue ;
22537: GO 22029
// end ; end ; r := GetDir ( tmp ) ;
22539: NOP4
22543: PUSH
22544: NOP4
22548: PPUSH
22549: NOP4
22553: ST_TO_ADDR
// if r = 5 then
22554: NOP4
22558: PUSH
22559: LD_INT 5
22561: EQUAL
22562: IFFALSE 22572
// r := 0 ;
22564: NOP4
22568: PUSH
22569: LD_INT 0
22571: ST_TO_ADDR
// for j = r to 5 do
22572: NOP4
22576: PUSH
22577: DOUBLE
22578: NOP4
22582: DEC
22583: ST_TO_ADDR
22584: LD_INT 5
22586: PUSH
22587: FOR_TO
22588: IFFALSE 22702
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22590: NOP4
22594: PUSH
22595: NOP4
22599: PPUSH
22600: NOP4
22604: PPUSH
22605: NOP4
22609: PPUSH
22610: LD_INT 2
22612: PPUSH
22613: NOP4
22617: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22618: NOP4
22622: PUSH
22623: NOP4
22627: PPUSH
22628: NOP4
22632: PPUSH
22633: NOP4
22637: PPUSH
22638: LD_INT 2
22640: PPUSH
22641: NOP4
22645: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22646: NOP4
22650: PPUSH
22651: NOP4
22655: PPUSH
22656: NOP4
22660: PUSH
22661: NOP4
22665: PPUSH
22666: NOP4
22670: PPUSH
22671: NOP4
22675: NOT
22676: AND
22677: IFFALSE 22700
// begin ComMoveXY ( tmp , _x , _y ) ;
22679: NOP4
22683: PPUSH
22684: NOP4
22688: PPUSH
22689: NOP4
22693: PPUSH
22694: NOP4
// break ;
22698: GO 22702
// end ; end ;
22700: GO 22587
22702: POP
22703: POP
// end ; end ;
22704: GO 22029
22706: POP
22707: POP
// end ;
22708: LD_VAR 0 8
22712: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22713: LD_INT 0
22715: PPUSH
// result := true ;
22716: NOP4
22720: PUSH
22721: LD_INT 1
22723: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22724: NOP4
22728: PUSH
22729: LD_INT 24
22731: DOUBLE
22732: EQUAL
22733: IFTRUE 22743
22735: LD_INT 33
22737: DOUBLE
22738: EQUAL
22739: IFTRUE 22743
22741: GO 22768
22743: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22744: NOP4
22748: PUSH
22749: LD_INT 32
22751: PPUSH
22752: NOP4
22756: PPUSH
22757: NOP4
22761: PUSH
22762: LD_INT 2
22764: EQUAL
22765: ST_TO_ADDR
22766: GO 23088
22768: LD_INT 20
22770: DOUBLE
22771: EQUAL
22772: IFTRUE 22776
22774: GO 22801
22776: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22777: NOP4
22781: PUSH
22782: LD_INT 6
22784: PPUSH
22785: NOP4
22789: PPUSH
22790: NOP4
22794: PUSH
22795: LD_INT 2
22797: EQUAL
22798: ST_TO_ADDR
22799: GO 23088
22801: LD_INT 22
22803: DOUBLE
22804: EQUAL
22805: IFTRUE 22815
22807: LD_INT 36
22809: DOUBLE
22810: EQUAL
22811: IFTRUE 22815
22813: GO 22840
22815: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22816: NOP4
22820: PUSH
22821: LD_INT 15
22823: PPUSH
22824: NOP4
22828: PPUSH
22829: NOP4
22833: PUSH
22834: LD_INT 2
22836: EQUAL
22837: ST_TO_ADDR
22838: GO 23088
22840: LD_INT 30
22842: DOUBLE
22843: EQUAL
22844: IFTRUE 22848
22846: GO 22873
22848: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22849: NOP4
22853: PUSH
22854: LD_INT 20
22856: PPUSH
22857: NOP4
22861: PPUSH
22862: NOP4
22866: PUSH
22867: LD_INT 2
22869: EQUAL
22870: ST_TO_ADDR
22871: GO 23088
22873: LD_INT 28
22875: DOUBLE
22876: EQUAL
22877: IFTRUE 22887
22879: LD_INT 21
22881: DOUBLE
22882: EQUAL
22883: IFTRUE 22887
22885: GO 22912
22887: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22888: NOP4
22892: PUSH
22893: LD_INT 21
22895: PPUSH
22896: NOP4
22900: PPUSH
22901: NOP4
22905: PUSH
22906: LD_INT 2
22908: EQUAL
22909: ST_TO_ADDR
22910: GO 23088
22912: LD_INT 16
22914: DOUBLE
22915: EQUAL
22916: IFTRUE 22920
22918: GO 22947
22920: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22921: NOP4
22925: PUSH
22926: NOP4
22930: PPUSH
22931: NOP4
22935: PPUSH
22936: NOP4
22940: PUSH
22941: LD_INT 2
22943: EQUAL
22944: ST_TO_ADDR
22945: GO 23088
22947: LD_INT 19
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22961
22953: LD_INT 23
22955: DOUBLE
22956: EQUAL
22957: IFTRUE 22961
22959: GO 22988
22961: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22962: NOP4
22966: PUSH
22967: NOP4
22971: PPUSH
22972: NOP4
22976: PPUSH
22977: NOP4
22981: PUSH
22982: LD_INT 2
22984: EQUAL
22985: ST_TO_ADDR
22986: GO 23088
22988: LD_INT 17
22990: DOUBLE
22991: EQUAL
22992: IFTRUE 22996
22994: GO 23021
22996: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22997: NOP4
23001: PUSH
23002: LD_INT 39
23004: PPUSH
23005: NOP4
23009: PPUSH
23010: NOP4
23014: PUSH
23015: LD_INT 2
23017: EQUAL
23018: ST_TO_ADDR
23019: GO 23088
23021: LD_INT 18
23023: DOUBLE
23024: EQUAL
23025: IFTRUE 23029
23027: GO 23054
23029: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
23030: NOP4
23034: PUSH
23035: LD_INT 40
23037: PPUSH
23038: NOP4
23042: PPUSH
23043: NOP4
23047: PUSH
23048: LD_INT 2
23050: EQUAL
23051: ST_TO_ADDR
23052: GO 23088
23054: LD_INT 27
23056: DOUBLE
23057: EQUAL
23058: IFTRUE 23062
23060: GO 23087
23062: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
23063: NOP4
23067: PUSH
23068: LD_INT 35
23070: PPUSH
23071: NOP4
23075: PPUSH
23076: NOP4
23080: PUSH
23081: LD_INT 2
23083: EQUAL
23084: ST_TO_ADDR
23085: GO 23088
23087: POP
// end ;
23088: LD_VAR 0 3
23092: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23093: LD_INT 0
23095: PPUSH
23096: PPUSH
23097: PPUSH
23098: PPUSH
23099: PPUSH
23100: PPUSH
23101: PPUSH
23102: PPUSH
23103: PPUSH
23104: PPUSH
23105: PPUSH
// result := false ;
23106: NOP4
23110: PUSH
23111: LD_INT 0
23113: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23114: NOP4
23118: NOT
23119: PUSH
23120: NOP4
23124: PPUSH
23125: NOP4
23129: PUSH
23130: LD_INT 0
23132: PUSH
23133: LD_INT 1
23135: PUSH
23136: EMPTY
23137: LIST
23138: LIST
23139: IN
23140: NOT
23141: OR
23142: PUSH
23143: NOP4
23147: NOT
23148: OR
23149: PUSH
23150: NOP4
23154: PUSH
23155: LD_INT 0
23157: PUSH
23158: LD_INT 1
23160: PUSH
23161: LD_INT 2
23163: PUSH
23164: LD_INT 3
23166: PUSH
23167: LD_INT 4
23169: PUSH
23170: LD_INT 5
23172: PUSH
23173: EMPTY
23174: LIST
23175: LIST
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: IN
23181: NOT
23182: OR
23183: PUSH
23184: NOP4
23188: PPUSH
23189: NOP4
23193: PPUSH
23194: NOP4
23198: NOT
23199: OR
23200: IFFALSE 23204
// exit ;
23202: GO 23940
// side := GetSide ( depot ) ;
23204: NOP4
23208: PUSH
23209: NOP4
23213: PPUSH
23214: NOP4
23218: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23219: NOP4
23223: PPUSH
23224: NOP4
23228: PPUSH
23229: NOP4
23233: NOT
23234: IFFALSE 23238
// exit ;
23236: GO 23940
// pom := GetBase ( depot ) ;
23238: NOP4
23242: PUSH
23243: NOP4
23247: PPUSH
23248: NOP4
23252: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23253: NOP4
23257: PUSH
23258: NOP4
23262: PPUSH
23263: NOP4
23267: PPUSH
23268: NOP4
23272: PPUSH
23273: NOP4
23277: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23278: NOP4
23282: PPUSH
23283: LD_INT 1
23285: PPUSH
23286: NOP4
23290: PUSH
23291: NOP4
23295: PUSH
23296: LD_INT 1
23298: ARRAY
23299: GREATEREQUAL
23300: PUSH
23301: NOP4
23305: PPUSH
23306: LD_INT 2
23308: PPUSH
23309: NOP4
23313: PUSH
23314: NOP4
23318: PUSH
23319: LD_INT 2
23321: ARRAY
23322: GREATEREQUAL
23323: AND
23324: PUSH
23325: NOP4
23329: PPUSH
23330: LD_INT 3
23332: PPUSH
23333: NOP4
23337: PUSH
23338: NOP4
23342: PUSH
23343: LD_INT 3
23345: ARRAY
23346: GREATEREQUAL
23347: AND
23348: NOT
23349: IFFALSE 23353
// exit ;
23351: GO 23940
// if GetBType ( depot ) = b_depot then
23353: NOP4
23357: PPUSH
23358: NOP4
23362: PUSH
23363: LD_INT 0
23365: EQUAL
23366: IFFALSE 23378
// dist := 28 else
23368: NOP4
23372: PUSH
23373: LD_INT 28
23375: ST_TO_ADDR
23376: GO 23386
// dist := 36 ;
23378: NOP4
23382: PUSH
23383: LD_INT 36
23385: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23386: NOP4
23390: PPUSH
23391: NOP4
23395: PPUSH
23396: NOP4
23400: PPUSH
23401: NOP4
23405: PUSH
23406: NOP4
23410: GREATER
23411: IFFALSE 23415
// exit ;
23413: GO 23940
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23415: NOP4
23419: PUSH
23420: NOP4
23424: PPUSH
23425: NOP4
23429: PPUSH
23430: NOP4
23434: PPUSH
23435: NOP4
23439: PPUSH
23440: NOP4
23444: PPUSH
23445: NOP4
23449: PPUSH
23450: LD_INT 0
23452: PPUSH
23453: NOP4
23457: ST_TO_ADDR
// if not hexes then
23458: NOP4
23462: NOT
23463: IFFALSE 23467
// exit ;
23465: GO 23940
// hex := GetHexInfo ( x , y ) ;
23467: NOP4
23471: PUSH
23472: NOP4
23476: PPUSH
23477: NOP4
23481: PPUSH
23482: NOP4
23486: ST_TO_ADDR
// if hex [ 1 ] then
23487: NOP4
23491: PUSH
23492: LD_INT 1
23494: ARRAY
23495: IFFALSE 23499
// exit ;
23497: GO 23940
// height := hex [ 2 ] ;
23499: NOP4
23503: PUSH
23504: NOP4
23508: PUSH
23509: LD_INT 2
23511: ARRAY
23512: ST_TO_ADDR
// for i = 1 to hexes do
23513: NOP4
23517: PUSH
23518: DOUBLE
23519: LD_INT 1
23521: DEC
23522: ST_TO_ADDR
23523: NOP4
23527: PUSH
23528: FOR_TO
23529: IFFALSE 23859
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23531: NOP4
23535: PUSH
23536: NOP4
23540: ARRAY
23541: PUSH
23542: LD_INT 1
23544: ARRAY
23545: PPUSH
23546: NOP4
23550: PUSH
23551: NOP4
23555: ARRAY
23556: PUSH
23557: LD_INT 2
23559: ARRAY
23560: PPUSH
23561: NOP4
23565: NOT
23566: PUSH
23567: NOP4
23571: PUSH
23572: NOP4
23576: ARRAY
23577: PUSH
23578: LD_INT 1
23580: ARRAY
23581: PPUSH
23582: NOP4
23586: PUSH
23587: NOP4
23591: ARRAY
23592: PUSH
23593: LD_INT 2
23595: ARRAY
23596: PPUSH
23597: NOP4
23601: PUSH
23602: LD_INT 0
23604: GREATER
23605: OR
23606: PUSH
23607: NOP4
23611: PUSH
23612: NOP4
23616: ARRAY
23617: PUSH
23618: LD_INT 1
23620: ARRAY
23621: PPUSH
23622: NOP4
23626: PUSH
23627: NOP4
23631: ARRAY
23632: PUSH
23633: LD_INT 2
23635: ARRAY
23636: PPUSH
23637: NOP4
23641: OR
23642: IFFALSE 23648
// exit ;
23644: POP
23645: POP
23646: GO 23940
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23648: NOP4
23652: PUSH
23653: NOP4
23657: PUSH
23658: NOP4
23662: ARRAY
23663: PUSH
23664: LD_INT 1
23666: ARRAY
23667: PPUSH
23668: NOP4
23672: PUSH
23673: NOP4
23677: ARRAY
23678: PUSH
23679: LD_INT 2
23681: ARRAY
23682: PPUSH
23683: NOP4
23687: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23688: NOP4
23692: PUSH
23693: LD_INT 1
23695: ARRAY
23696: PUSH
23697: NOP4
23701: PUSH
23702: LD_INT 2
23704: ARRAY
23705: PUSH
23706: NOP4
23710: PUSH
23711: LD_INT 2
23713: PLUS
23714: GREATER
23715: OR
23716: PUSH
23717: NOP4
23721: PUSH
23722: LD_INT 2
23724: ARRAY
23725: PUSH
23726: NOP4
23730: PUSH
23731: LD_INT 2
23733: MINUS
23734: LESS
23735: OR
23736: PUSH
23737: NOP4
23741: PUSH
23742: LD_INT 3
23744: ARRAY
23745: PUSH
23746: LD_INT 0
23748: PUSH
23749: LD_INT 8
23751: PUSH
23752: LD_INT 9
23754: PUSH
23755: LD_INT 10
23757: PUSH
23758: LD_INT 11
23760: PUSH
23761: LD_INT 12
23763: PUSH
23764: LD_INT 13
23766: PUSH
23767: LD_INT 16
23769: PUSH
23770: LD_INT 17
23772: PUSH
23773: LD_INT 18
23775: PUSH
23776: LD_INT 19
23778: PUSH
23779: LD_INT 20
23781: PUSH
23782: LD_INT 21
23784: PUSH
23785: EMPTY
23786: LIST
23787: LIST
23788: LIST
23789: LIST
23790: LIST
23791: LIST
23792: LIST
23793: LIST
23794: LIST
23795: LIST
23796: LIST
23797: LIST
23798: LIST
23799: IN
23800: NOT
23801: OR
23802: PUSH
23803: NOP4
23807: PUSH
23808: LD_INT 5
23810: ARRAY
23811: NOT
23812: OR
23813: PUSH
23814: NOP4
23818: PUSH
23819: LD_INT 6
23821: ARRAY
23822: PUSH
23823: LD_INT 1
23825: PUSH
23826: LD_INT 2
23828: PUSH
23829: LD_INT 7
23831: PUSH
23832: LD_INT 9
23834: PUSH
23835: LD_INT 10
23837: PUSH
23838: LD_INT 11
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: LIST
23845: LIST
23846: LIST
23847: LIST
23848: IN
23849: NOT
23850: OR
23851: IFFALSE 23857
// exit ;
23853: POP
23854: POP
23855: GO 23940
// end ;
23857: GO 23528
23859: POP
23860: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23861: NOP4
23865: PPUSH
23866: NOP4
23870: PPUSH
23871: NOP4
23875: PPUSH
23876: LD_INT 20
23878: PPUSH
23879: NOP4
23883: PUSH
23884: LD_INT 4
23886: ARRAY
23887: IFFALSE 23891
// exit ;
23889: GO 23940
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23891: NOP4
23895: PUSH
23896: LD_INT 29
23898: PUSH
23899: LD_INT 30
23901: PUSH
23902: EMPTY
23903: LIST
23904: LIST
23905: IN
23906: PUSH
23907: NOP4
23911: PPUSH
23912: NOP4
23916: PPUSH
23917: NOP4
23921: PPUSH
23922: NOP4
23926: NOT
23927: AND
23928: IFFALSE 23932
// exit ;
23930: GO 23940
// result := true ;
23932: NOP4
23936: PUSH
23937: LD_INT 1
23939: ST_TO_ADDR
// end ;
23940: LD_VAR 0 6
23944: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23945: LD_INT 0
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
23960: PPUSH
23961: PPUSH
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
23976: PPUSH
23977: PPUSH
23978: PPUSH
23979: PPUSH
23980: PPUSH
23981: PPUSH
23982: PPUSH
23983: PPUSH
23984: PPUSH
23985: PPUSH
23986: PPUSH
23987: PPUSH
23988: PPUSH
23989: PPUSH
23990: PPUSH
23991: PPUSH
23992: PPUSH
23993: PPUSH
23994: PPUSH
23995: PPUSH
23996: PPUSH
23997: PPUSH
23998: PPUSH
23999: PPUSH
24000: PPUSH
24001: PPUSH
24002: PPUSH
24003: PPUSH
24004: PPUSH
// result = [ ] ;
24005: NOP4
24009: PUSH
24010: EMPTY
24011: ST_TO_ADDR
// temp_list = [ ] ;
24012: NOP4
24016: PUSH
24017: EMPTY
24018: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
24019: NOP4
24023: PUSH
24024: LD_INT 0
24026: PUSH
24027: LD_INT 1
24029: PUSH
24030: LD_INT 2
24032: PUSH
24033: LD_INT 3
24035: PUSH
24036: LD_INT 4
24038: PUSH
24039: LD_INT 5
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: LIST
24046: LIST
24047: LIST
24048: LIST
24049: IN
24050: NOT
24051: PUSH
24052: NOP4
24056: PUSH
24057: LD_INT 0
24059: PUSH
24060: LD_INT 1
24062: PUSH
24063: EMPTY
24064: LIST
24065: LIST
24066: IN
24067: PUSH
24068: NOP4
24072: PUSH
24073: LD_INT 1
24075: PUSH
24076: LD_INT 2
24078: PUSH
24079: LD_INT 3
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: LIST
24086: IN
24087: NOT
24088: AND
24089: OR
24090: IFFALSE 24094
// exit ;
24092: GO 42485
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24094: NOP4
24098: PUSH
24099: LD_INT 6
24101: PUSH
24102: LD_INT 7
24104: PUSH
24105: LD_INT 8
24107: PUSH
24108: LD_INT 13
24110: PUSH
24111: LD_INT 12
24113: PUSH
24114: LD_INT 15
24116: PUSH
24117: LD_INT 11
24119: PUSH
24120: LD_INT 14
24122: PUSH
24123: LD_INT 10
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: IN
24137: IFFALSE 24147
// btype = b_lab ;
24139: NOP4
24143: PUSH
24144: LD_INT 6
24146: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24147: NOP4
24151: PUSH
24152: LD_INT 0
24154: PUSH
24155: LD_INT 1
24157: PUSH
24158: LD_INT 2
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: LIST
24165: IN
24166: NOT
24167: PUSH
24168: NOP4
24172: PUSH
24173: LD_INT 0
24175: PUSH
24176: LD_INT 1
24178: PUSH
24179: LD_INT 2
24181: PUSH
24182: LD_INT 3
24184: PUSH
24185: LD_INT 6
24187: PUSH
24188: LD_INT 36
24190: PUSH
24191: LD_INT 4
24193: PUSH
24194: LD_INT 5
24196: PUSH
24197: LD_INT 31
24199: PUSH
24200: LD_INT 32
24202: PUSH
24203: LD_INT 33
24205: PUSH
24206: EMPTY
24207: LIST
24208: LIST
24209: LIST
24210: LIST
24211: LIST
24212: LIST
24213: LIST
24214: LIST
24215: LIST
24216: LIST
24217: LIST
24218: IN
24219: NOT
24220: PUSH
24221: NOP4
24225: PUSH
24226: LD_INT 1
24228: EQUAL
24229: AND
24230: OR
24231: PUSH
24232: NOP4
24236: PUSH
24237: LD_INT 2
24239: PUSH
24240: LD_INT 3
24242: PUSH
24243: EMPTY
24244: LIST
24245: LIST
24246: IN
24247: NOT
24248: PUSH
24249: NOP4
24253: PUSH
24254: LD_INT 2
24256: EQUAL
24257: AND
24258: OR
24259: IFFALSE 24269
// mode = 0 ;
24261: NOP4
24265: PUSH
24266: LD_INT 0
24268: ST_TO_ADDR
// case mode of 0 :
24269: NOP4
24273: PUSH
24274: LD_INT 0
24276: DOUBLE
24277: EQUAL
24278: IFTRUE 24282
24280: GO 35735
24282: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24283: NOP4
24287: PUSH
24288: LD_INT 0
24290: PUSH
24291: LD_INT 0
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: PUSH
24298: LD_INT 0
24300: PUSH
24301: LD_INT 1
24303: NEG
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: PUSH
24309: LD_INT 1
24311: PUSH
24312: LD_INT 0
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PUSH
24319: LD_INT 1
24321: PUSH
24322: LD_INT 1
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: LD_INT 0
24331: PUSH
24332: LD_INT 1
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: LD_INT 1
24341: NEG
24342: PUSH
24343: LD_INT 0
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: PUSH
24350: LD_INT 1
24352: NEG
24353: PUSH
24354: LD_INT 1
24356: NEG
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: PUSH
24362: LD_INT 1
24364: NEG
24365: PUSH
24366: LD_INT 2
24368: NEG
24369: PUSH
24370: EMPTY
24371: LIST
24372: LIST
24373: PUSH
24374: LD_INT 0
24376: PUSH
24377: LD_INT 2
24379: NEG
24380: PUSH
24381: EMPTY
24382: LIST
24383: LIST
24384: PUSH
24385: LD_INT 1
24387: PUSH
24388: LD_INT 1
24390: NEG
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: PUSH
24396: LD_INT 1
24398: PUSH
24399: LD_INT 2
24401: PUSH
24402: EMPTY
24403: LIST
24404: LIST
24405: PUSH
24406: LD_INT 0
24408: PUSH
24409: LD_INT 2
24411: PUSH
24412: EMPTY
24413: LIST
24414: LIST
24415: PUSH
24416: LD_INT 1
24418: NEG
24419: PUSH
24420: LD_INT 1
24422: PUSH
24423: EMPTY
24424: LIST
24425: LIST
24426: PUSH
24427: LD_INT 1
24429: PUSH
24430: LD_INT 3
24432: PUSH
24433: EMPTY
24434: LIST
24435: LIST
24436: PUSH
24437: LD_INT 0
24439: PUSH
24440: LD_INT 3
24442: PUSH
24443: EMPTY
24444: LIST
24445: LIST
24446: PUSH
24447: LD_INT 1
24449: NEG
24450: PUSH
24451: LD_INT 2
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: PUSH
24458: EMPTY
24459: LIST
24460: LIST
24461: LIST
24462: LIST
24463: LIST
24464: LIST
24465: LIST
24466: LIST
24467: LIST
24468: LIST
24469: LIST
24470: LIST
24471: LIST
24472: LIST
24473: LIST
24474: LIST
24475: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24476: NOP4
24480: PUSH
24481: LD_INT 0
24483: PUSH
24484: LD_INT 0
24486: PUSH
24487: EMPTY
24488: LIST
24489: LIST
24490: PUSH
24491: LD_INT 0
24493: PUSH
24494: LD_INT 1
24496: NEG
24497: PUSH
24498: EMPTY
24499: LIST
24500: LIST
24501: PUSH
24502: LD_INT 1
24504: PUSH
24505: LD_INT 0
24507: PUSH
24508: EMPTY
24509: LIST
24510: LIST
24511: PUSH
24512: LD_INT 1
24514: PUSH
24515: LD_INT 1
24517: PUSH
24518: EMPTY
24519: LIST
24520: LIST
24521: PUSH
24522: LD_INT 0
24524: PUSH
24525: LD_INT 1
24527: PUSH
24528: EMPTY
24529: LIST
24530: LIST
24531: PUSH
24532: LD_INT 1
24534: NEG
24535: PUSH
24536: LD_INT 0
24538: PUSH
24539: EMPTY
24540: LIST
24541: LIST
24542: PUSH
24543: LD_INT 1
24545: NEG
24546: PUSH
24547: LD_INT 1
24549: NEG
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: PUSH
24555: LD_INT 1
24557: PUSH
24558: LD_INT 1
24560: NEG
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PUSH
24566: LD_INT 2
24568: PUSH
24569: LD_INT 0
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: PUSH
24576: LD_INT 2
24578: PUSH
24579: LD_INT 1
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 1
24588: NEG
24589: PUSH
24590: LD_INT 1
24592: PUSH
24593: EMPTY
24594: LIST
24595: LIST
24596: PUSH
24597: LD_INT 2
24599: NEG
24600: PUSH
24601: LD_INT 0
24603: PUSH
24604: EMPTY
24605: LIST
24606: LIST
24607: PUSH
24608: LD_INT 2
24610: NEG
24611: PUSH
24612: LD_INT 1
24614: NEG
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 2
24622: NEG
24623: PUSH
24624: LD_INT 1
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: LD_INT 3
24633: NEG
24634: PUSH
24635: LD_INT 0
24637: PUSH
24638: EMPTY
24639: LIST
24640: LIST
24641: PUSH
24642: LD_INT 3
24644: NEG
24645: PUSH
24646: LD_INT 1
24648: NEG
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: LIST
24658: LIST
24659: LIST
24660: LIST
24661: LIST
24662: LIST
24663: LIST
24664: LIST
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: LIST
24670: LIST
24671: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24672: NOP4
24676: PUSH
24677: LD_INT 0
24679: PUSH
24680: LD_INT 0
24682: PUSH
24683: EMPTY
24684: LIST
24685: LIST
24686: PUSH
24687: LD_INT 0
24689: PUSH
24690: LD_INT 1
24692: NEG
24693: PUSH
24694: EMPTY
24695: LIST
24696: LIST
24697: PUSH
24698: LD_INT 1
24700: PUSH
24701: LD_INT 0
24703: PUSH
24704: EMPTY
24705: LIST
24706: LIST
24707: PUSH
24708: LD_INT 1
24710: PUSH
24711: LD_INT 1
24713: PUSH
24714: EMPTY
24715: LIST
24716: LIST
24717: PUSH
24718: LD_INT 0
24720: PUSH
24721: LD_INT 1
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: PUSH
24728: LD_INT 1
24730: NEG
24731: PUSH
24732: LD_INT 0
24734: PUSH
24735: EMPTY
24736: LIST
24737: LIST
24738: PUSH
24739: LD_INT 1
24741: NEG
24742: PUSH
24743: LD_INT 1
24745: NEG
24746: PUSH
24747: EMPTY
24748: LIST
24749: LIST
24750: PUSH
24751: LD_INT 1
24753: NEG
24754: PUSH
24755: LD_INT 2
24757: NEG
24758: PUSH
24759: EMPTY
24760: LIST
24761: LIST
24762: PUSH
24763: LD_INT 2
24765: PUSH
24766: LD_INT 1
24768: PUSH
24769: EMPTY
24770: LIST
24771: LIST
24772: PUSH
24773: LD_INT 2
24775: PUSH
24776: LD_INT 2
24778: PUSH
24779: EMPTY
24780: LIST
24781: LIST
24782: PUSH
24783: LD_INT 1
24785: PUSH
24786: LD_INT 2
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: PUSH
24793: LD_INT 2
24795: NEG
24796: PUSH
24797: LD_INT 1
24799: NEG
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: LD_INT 2
24807: NEG
24808: PUSH
24809: LD_INT 2
24811: NEG
24812: PUSH
24813: EMPTY
24814: LIST
24815: LIST
24816: PUSH
24817: LD_INT 2
24819: NEG
24820: PUSH
24821: LD_INT 3
24823: NEG
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PUSH
24829: LD_INT 3
24831: NEG
24832: PUSH
24833: LD_INT 2
24835: NEG
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 3
24843: NEG
24844: PUSH
24845: LD_INT 3
24847: NEG
24848: PUSH
24849: EMPTY
24850: LIST
24851: LIST
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: LIST
24862: LIST
24863: LIST
24864: LIST
24865: LIST
24866: LIST
24867: LIST
24868: LIST
24869: LIST
24870: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24871: NOP4
24875: PUSH
24876: LD_INT 0
24878: PUSH
24879: LD_INT 0
24881: PUSH
24882: EMPTY
24883: LIST
24884: LIST
24885: PUSH
24886: LD_INT 0
24888: PUSH
24889: LD_INT 1
24891: NEG
24892: PUSH
24893: EMPTY
24894: LIST
24895: LIST
24896: PUSH
24897: LD_INT 1
24899: PUSH
24900: LD_INT 0
24902: PUSH
24903: EMPTY
24904: LIST
24905: LIST
24906: PUSH
24907: LD_INT 1
24909: PUSH
24910: LD_INT 1
24912: PUSH
24913: EMPTY
24914: LIST
24915: LIST
24916: PUSH
24917: LD_INT 0
24919: PUSH
24920: LD_INT 1
24922: PUSH
24923: EMPTY
24924: LIST
24925: LIST
24926: PUSH
24927: LD_INT 1
24929: NEG
24930: PUSH
24931: LD_INT 0
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: PUSH
24938: LD_INT 1
24940: NEG
24941: PUSH
24942: LD_INT 1
24944: NEG
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: PUSH
24950: LD_INT 1
24952: NEG
24953: PUSH
24954: LD_INT 2
24956: NEG
24957: PUSH
24958: EMPTY
24959: LIST
24960: LIST
24961: PUSH
24962: LD_INT 0
24964: PUSH
24965: LD_INT 2
24967: NEG
24968: PUSH
24969: EMPTY
24970: LIST
24971: LIST
24972: PUSH
24973: LD_INT 1
24975: PUSH
24976: LD_INT 1
24978: NEG
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: PUSH
24984: LD_INT 1
24986: PUSH
24987: LD_INT 2
24989: PUSH
24990: EMPTY
24991: LIST
24992: LIST
24993: PUSH
24994: LD_INT 0
24996: PUSH
24997: LD_INT 2
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: PUSH
25004: LD_INT 1
25006: NEG
25007: PUSH
25008: LD_INT 1
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 1
25017: NEG
25018: PUSH
25019: LD_INT 3
25021: NEG
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: PUSH
25027: LD_INT 0
25029: PUSH
25030: LD_INT 3
25032: NEG
25033: PUSH
25034: EMPTY
25035: LIST
25036: LIST
25037: PUSH
25038: LD_INT 1
25040: PUSH
25041: LD_INT 2
25043: NEG
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: EMPTY
25050: LIST
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: LIST
25056: LIST
25057: LIST
25058: LIST
25059: LIST
25060: LIST
25061: LIST
25062: LIST
25063: LIST
25064: LIST
25065: LIST
25066: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
25067: NOP4
25071: PUSH
25072: LD_INT 0
25074: PUSH
25075: LD_INT 0
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 0
25084: PUSH
25085: LD_INT 1
25087: NEG
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 1
25095: PUSH
25096: LD_INT 0
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PUSH
25103: LD_INT 1
25105: PUSH
25106: LD_INT 1
25108: PUSH
25109: EMPTY
25110: LIST
25111: LIST
25112: PUSH
25113: LD_INT 0
25115: PUSH
25116: LD_INT 1
25118: PUSH
25119: EMPTY
25120: LIST
25121: LIST
25122: PUSH
25123: LD_INT 1
25125: NEG
25126: PUSH
25127: LD_INT 0
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: PUSH
25134: LD_INT 1
25136: NEG
25137: PUSH
25138: LD_INT 1
25140: NEG
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PUSH
25146: LD_INT 1
25148: PUSH
25149: LD_INT 1
25151: NEG
25152: PUSH
25153: EMPTY
25154: LIST
25155: LIST
25156: PUSH
25157: LD_INT 2
25159: PUSH
25160: LD_INT 0
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: PUSH
25167: LD_INT 2
25169: PUSH
25170: LD_INT 1
25172: PUSH
25173: EMPTY
25174: LIST
25175: LIST
25176: PUSH
25177: LD_INT 1
25179: NEG
25180: PUSH
25181: LD_INT 1
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PUSH
25188: LD_INT 2
25190: NEG
25191: PUSH
25192: LD_INT 0
25194: PUSH
25195: EMPTY
25196: LIST
25197: LIST
25198: PUSH
25199: LD_INT 2
25201: NEG
25202: PUSH
25203: LD_INT 1
25205: NEG
25206: PUSH
25207: EMPTY
25208: LIST
25209: LIST
25210: PUSH
25211: LD_INT 2
25213: PUSH
25214: LD_INT 1
25216: NEG
25217: PUSH
25218: EMPTY
25219: LIST
25220: LIST
25221: PUSH
25222: LD_INT 3
25224: PUSH
25225: LD_INT 0
25227: PUSH
25228: EMPTY
25229: LIST
25230: LIST
25231: PUSH
25232: LD_INT 3
25234: PUSH
25235: LD_INT 1
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: LIST
25254: LIST
25255: LIST
25256: LIST
25257: LIST
25258: LIST
25259: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25260: NOP4
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: PUSH
25275: LD_INT 0
25277: PUSH
25278: LD_INT 1
25280: NEG
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: PUSH
25286: LD_INT 1
25288: PUSH
25289: LD_INT 0
25291: PUSH
25292: EMPTY
25293: LIST
25294: LIST
25295: PUSH
25296: LD_INT 1
25298: PUSH
25299: LD_INT 1
25301: PUSH
25302: EMPTY
25303: LIST
25304: LIST
25305: PUSH
25306: LD_INT 0
25308: PUSH
25309: LD_INT 1
25311: PUSH
25312: EMPTY
25313: LIST
25314: LIST
25315: PUSH
25316: LD_INT 1
25318: NEG
25319: PUSH
25320: LD_INT 0
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: PUSH
25327: LD_INT 1
25329: NEG
25330: PUSH
25331: LD_INT 1
25333: NEG
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 1
25341: NEG
25342: PUSH
25343: LD_INT 2
25345: NEG
25346: PUSH
25347: EMPTY
25348: LIST
25349: LIST
25350: PUSH
25351: LD_INT 2
25353: PUSH
25354: LD_INT 1
25356: PUSH
25357: EMPTY
25358: LIST
25359: LIST
25360: PUSH
25361: LD_INT 2
25363: PUSH
25364: LD_INT 2
25366: PUSH
25367: EMPTY
25368: LIST
25369: LIST
25370: PUSH
25371: LD_INT 1
25373: PUSH
25374: LD_INT 2
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: PUSH
25381: LD_INT 2
25383: NEG
25384: PUSH
25385: LD_INT 1
25387: NEG
25388: PUSH
25389: EMPTY
25390: LIST
25391: LIST
25392: PUSH
25393: LD_INT 2
25395: NEG
25396: PUSH
25397: LD_INT 2
25399: NEG
25400: PUSH
25401: EMPTY
25402: LIST
25403: LIST
25404: PUSH
25405: LD_INT 3
25407: PUSH
25408: LD_INT 2
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: PUSH
25415: LD_INT 3
25417: PUSH
25418: LD_INT 3
25420: PUSH
25421: EMPTY
25422: LIST
25423: LIST
25424: PUSH
25425: LD_INT 2
25427: PUSH
25428: LD_INT 3
25430: PUSH
25431: EMPTY
25432: LIST
25433: LIST
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: LIST
25439: LIST
25440: LIST
25441: LIST
25442: LIST
25443: LIST
25444: LIST
25445: LIST
25446: LIST
25447: LIST
25448: LIST
25449: LIST
25450: LIST
25451: LIST
25452: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25453: NOP4
25457: PUSH
25458: LD_INT 0
25460: PUSH
25461: LD_INT 0
25463: PUSH
25464: EMPTY
25465: LIST
25466: LIST
25467: PUSH
25468: LD_INT 0
25470: PUSH
25471: LD_INT 1
25473: NEG
25474: PUSH
25475: EMPTY
25476: LIST
25477: LIST
25478: PUSH
25479: LD_INT 1
25481: PUSH
25482: LD_INT 0
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: PUSH
25489: LD_INT 1
25491: PUSH
25492: LD_INT 1
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: PUSH
25499: LD_INT 0
25501: PUSH
25502: LD_INT 1
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PUSH
25509: LD_INT 1
25511: NEG
25512: PUSH
25513: LD_INT 0
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 1
25522: NEG
25523: PUSH
25524: LD_INT 1
25526: NEG
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: PUSH
25532: LD_INT 1
25534: NEG
25535: PUSH
25536: LD_INT 2
25538: NEG
25539: PUSH
25540: EMPTY
25541: LIST
25542: LIST
25543: PUSH
25544: LD_INT 0
25546: PUSH
25547: LD_INT 2
25549: NEG
25550: PUSH
25551: EMPTY
25552: LIST
25553: LIST
25554: PUSH
25555: LD_INT 1
25557: PUSH
25558: LD_INT 1
25560: NEG
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 2
25568: PUSH
25569: LD_INT 0
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 2
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 2
25588: PUSH
25589: LD_INT 2
25591: PUSH
25592: EMPTY
25593: LIST
25594: LIST
25595: PUSH
25596: LD_INT 1
25598: PUSH
25599: LD_INT 2
25601: PUSH
25602: EMPTY
25603: LIST
25604: LIST
25605: PUSH
25606: LD_INT 0
25608: PUSH
25609: LD_INT 2
25611: PUSH
25612: EMPTY
25613: LIST
25614: LIST
25615: PUSH
25616: LD_INT 1
25618: NEG
25619: PUSH
25620: LD_INT 1
25622: PUSH
25623: EMPTY
25624: LIST
25625: LIST
25626: PUSH
25627: LD_INT 2
25629: NEG
25630: PUSH
25631: LD_INT 0
25633: PUSH
25634: EMPTY
25635: LIST
25636: LIST
25637: PUSH
25638: LD_INT 2
25640: NEG
25641: PUSH
25642: LD_INT 1
25644: NEG
25645: PUSH
25646: EMPTY
25647: LIST
25648: LIST
25649: PUSH
25650: LD_INT 2
25652: NEG
25653: PUSH
25654: LD_INT 2
25656: NEG
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: LIST
25672: LIST
25673: LIST
25674: LIST
25675: LIST
25676: LIST
25677: LIST
25678: LIST
25679: LIST
25680: LIST
25681: LIST
25682: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25683: NOP4
25687: PUSH
25688: LD_INT 0
25690: PUSH
25691: LD_INT 0
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 0
25700: PUSH
25701: LD_INT 1
25703: NEG
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: PUSH
25709: LD_INT 1
25711: PUSH
25712: LD_INT 0
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: PUSH
25719: LD_INT 1
25721: PUSH
25722: LD_INT 1
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PUSH
25729: LD_INT 0
25731: PUSH
25732: LD_INT 1
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: LD_INT 1
25741: NEG
25742: PUSH
25743: LD_INT 0
25745: PUSH
25746: EMPTY
25747: LIST
25748: LIST
25749: PUSH
25750: LD_INT 1
25752: NEG
25753: PUSH
25754: LD_INT 1
25756: NEG
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PUSH
25762: LD_INT 1
25764: NEG
25765: PUSH
25766: LD_INT 2
25768: NEG
25769: PUSH
25770: EMPTY
25771: LIST
25772: LIST
25773: PUSH
25774: LD_INT 0
25776: PUSH
25777: LD_INT 2
25779: NEG
25780: PUSH
25781: EMPTY
25782: LIST
25783: LIST
25784: PUSH
25785: LD_INT 1
25787: PUSH
25788: LD_INT 1
25790: NEG
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 2
25798: PUSH
25799: LD_INT 0
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 2
25808: PUSH
25809: LD_INT 1
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: LD_INT 2
25818: PUSH
25819: LD_INT 2
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PUSH
25826: LD_INT 1
25828: PUSH
25829: LD_INT 2
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: PUSH
25836: LD_INT 0
25838: PUSH
25839: LD_INT 2
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: PUSH
25846: LD_INT 1
25848: NEG
25849: PUSH
25850: LD_INT 1
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: PUSH
25857: LD_INT 2
25859: NEG
25860: PUSH
25861: LD_INT 0
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: PUSH
25868: LD_INT 2
25870: NEG
25871: PUSH
25872: LD_INT 1
25874: NEG
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: LD_INT 2
25882: NEG
25883: PUSH
25884: LD_INT 2
25886: NEG
25887: PUSH
25888: EMPTY
25889: LIST
25890: LIST
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: LIST
25898: LIST
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: LIST
25904: LIST
25905: LIST
25906: LIST
25907: LIST
25908: LIST
25909: LIST
25910: LIST
25911: LIST
25912: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25913: NOP4
25917: PUSH
25918: LD_INT 0
25920: PUSH
25921: LD_INT 0
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: LD_INT 0
25930: PUSH
25931: LD_INT 1
25933: NEG
25934: PUSH
25935: EMPTY
25936: LIST
25937: LIST
25938: PUSH
25939: LD_INT 1
25941: PUSH
25942: LD_INT 0
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: PUSH
25949: LD_INT 1
25951: PUSH
25952: LD_INT 1
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: PUSH
25959: LD_INT 0
25961: PUSH
25962: LD_INT 1
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: LD_INT 1
25971: NEG
25972: PUSH
25973: LD_INT 0
25975: PUSH
25976: EMPTY
25977: LIST
25978: LIST
25979: PUSH
25980: LD_INT 1
25982: NEG
25983: PUSH
25984: LD_INT 1
25986: NEG
25987: PUSH
25988: EMPTY
25989: LIST
25990: LIST
25991: PUSH
25992: LD_INT 1
25994: NEG
25995: PUSH
25996: LD_INT 2
25998: NEG
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 0
26006: PUSH
26007: LD_INT 2
26009: NEG
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: PUSH
26015: LD_INT 1
26017: PUSH
26018: LD_INT 1
26020: NEG
26021: PUSH
26022: EMPTY
26023: LIST
26024: LIST
26025: PUSH
26026: LD_INT 2
26028: PUSH
26029: LD_INT 0
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: LD_INT 2
26038: PUSH
26039: LD_INT 1
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 2
26048: PUSH
26049: LD_INT 2
26051: PUSH
26052: EMPTY
26053: LIST
26054: LIST
26055: PUSH
26056: LD_INT 1
26058: PUSH
26059: LD_INT 2
26061: PUSH
26062: EMPTY
26063: LIST
26064: LIST
26065: PUSH
26066: LD_INT 0
26068: PUSH
26069: LD_INT 2
26071: PUSH
26072: EMPTY
26073: LIST
26074: LIST
26075: PUSH
26076: LD_INT 1
26078: NEG
26079: PUSH
26080: LD_INT 1
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 2
26089: NEG
26090: PUSH
26091: LD_INT 0
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: PUSH
26098: LD_INT 2
26100: NEG
26101: PUSH
26102: LD_INT 1
26104: NEG
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: PUSH
26110: LD_INT 2
26112: NEG
26113: PUSH
26114: LD_INT 2
26116: NEG
26117: PUSH
26118: EMPTY
26119: LIST
26120: LIST
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: LIST
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: LIST
26131: LIST
26132: LIST
26133: LIST
26134: LIST
26135: LIST
26136: LIST
26137: LIST
26138: LIST
26139: LIST
26140: LIST
26141: LIST
26142: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26143: NOP4
26147: PUSH
26148: LD_INT 0
26150: PUSH
26151: LD_INT 0
26153: PUSH
26154: EMPTY
26155: LIST
26156: LIST
26157: PUSH
26158: LD_INT 0
26160: PUSH
26161: LD_INT 1
26163: NEG
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: PUSH
26169: LD_INT 1
26171: PUSH
26172: LD_INT 0
26174: PUSH
26175: EMPTY
26176: LIST
26177: LIST
26178: PUSH
26179: LD_INT 1
26181: PUSH
26182: LD_INT 1
26184: PUSH
26185: EMPTY
26186: LIST
26187: LIST
26188: PUSH
26189: LD_INT 0
26191: PUSH
26192: LD_INT 1
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: LD_INT 1
26201: NEG
26202: PUSH
26203: LD_INT 0
26205: PUSH
26206: EMPTY
26207: LIST
26208: LIST
26209: PUSH
26210: LD_INT 1
26212: NEG
26213: PUSH
26214: LD_INT 1
26216: NEG
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 1
26224: NEG
26225: PUSH
26226: LD_INT 2
26228: NEG
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 0
26236: PUSH
26237: LD_INT 2
26239: NEG
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: LD_INT 1
26247: PUSH
26248: LD_INT 1
26250: NEG
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: LD_INT 2
26258: PUSH
26259: LD_INT 0
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: LD_INT 2
26268: PUSH
26269: LD_INT 1
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 2
26278: PUSH
26279: LD_INT 2
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: LD_INT 1
26288: PUSH
26289: LD_INT 2
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: PUSH
26296: LD_INT 0
26298: PUSH
26299: LD_INT 2
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: LD_INT 1
26308: NEG
26309: PUSH
26310: LD_INT 1
26312: PUSH
26313: EMPTY
26314: LIST
26315: LIST
26316: PUSH
26317: LD_INT 2
26319: NEG
26320: PUSH
26321: LD_INT 0
26323: PUSH
26324: EMPTY
26325: LIST
26326: LIST
26327: PUSH
26328: LD_INT 2
26330: NEG
26331: PUSH
26332: LD_INT 1
26334: NEG
26335: PUSH
26336: EMPTY
26337: LIST
26338: LIST
26339: PUSH
26340: LD_INT 2
26342: NEG
26343: PUSH
26344: LD_INT 2
26346: NEG
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: LIST
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: LIST
26365: LIST
26366: LIST
26367: LIST
26368: LIST
26369: LIST
26370: LIST
26371: LIST
26372: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26373: NOP4
26377: PUSH
26378: LD_INT 0
26380: PUSH
26381: LD_INT 0
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 0
26390: PUSH
26391: LD_INT 1
26393: NEG
26394: PUSH
26395: EMPTY
26396: LIST
26397: LIST
26398: PUSH
26399: LD_INT 1
26401: PUSH
26402: LD_INT 0
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 1
26411: PUSH
26412: LD_INT 1
26414: PUSH
26415: EMPTY
26416: LIST
26417: LIST
26418: PUSH
26419: LD_INT 0
26421: PUSH
26422: LD_INT 1
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PUSH
26429: LD_INT 1
26431: NEG
26432: PUSH
26433: LD_INT 0
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: LD_INT 1
26442: NEG
26443: PUSH
26444: LD_INT 1
26446: NEG
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: PUSH
26452: LD_INT 1
26454: NEG
26455: PUSH
26456: LD_INT 2
26458: NEG
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: LD_INT 0
26466: PUSH
26467: LD_INT 2
26469: NEG
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: LD_INT 1
26477: PUSH
26478: LD_INT 1
26480: NEG
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 2
26488: PUSH
26489: LD_INT 0
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: LD_INT 2
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 2
26508: PUSH
26509: LD_INT 2
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 1
26518: PUSH
26519: LD_INT 2
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 0
26528: PUSH
26529: LD_INT 2
26531: PUSH
26532: EMPTY
26533: LIST
26534: LIST
26535: PUSH
26536: LD_INT 1
26538: NEG
26539: PUSH
26540: LD_INT 1
26542: PUSH
26543: EMPTY
26544: LIST
26545: LIST
26546: PUSH
26547: LD_INT 2
26549: NEG
26550: PUSH
26551: LD_INT 0
26553: PUSH
26554: EMPTY
26555: LIST
26556: LIST
26557: PUSH
26558: LD_INT 2
26560: NEG
26561: PUSH
26562: LD_INT 1
26564: NEG
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: PUSH
26570: LD_INT 2
26572: NEG
26573: PUSH
26574: LD_INT 2
26576: NEG
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: EMPTY
26583: LIST
26584: LIST
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: LIST
26590: LIST
26591: LIST
26592: LIST
26593: LIST
26594: LIST
26595: LIST
26596: LIST
26597: LIST
26598: LIST
26599: LIST
26600: LIST
26601: LIST
26602: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26603: NOP4
26607: PUSH
26608: LD_INT 0
26610: PUSH
26611: LD_INT 0
26613: PUSH
26614: EMPTY
26615: LIST
26616: LIST
26617: PUSH
26618: LD_INT 0
26620: PUSH
26621: LD_INT 1
26623: NEG
26624: PUSH
26625: EMPTY
26626: LIST
26627: LIST
26628: PUSH
26629: LD_INT 1
26631: PUSH
26632: LD_INT 0
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: PUSH
26639: LD_INT 1
26641: PUSH
26642: LD_INT 1
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: PUSH
26649: LD_INT 0
26651: PUSH
26652: LD_INT 1
26654: PUSH
26655: EMPTY
26656: LIST
26657: LIST
26658: PUSH
26659: LD_INT 1
26661: NEG
26662: PUSH
26663: LD_INT 0
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PUSH
26670: LD_INT 1
26672: NEG
26673: PUSH
26674: LD_INT 1
26676: NEG
26677: PUSH
26678: EMPTY
26679: LIST
26680: LIST
26681: PUSH
26682: LD_INT 1
26684: NEG
26685: PUSH
26686: LD_INT 2
26688: NEG
26689: PUSH
26690: EMPTY
26691: LIST
26692: LIST
26693: PUSH
26694: LD_INT 0
26696: PUSH
26697: LD_INT 2
26699: NEG
26700: PUSH
26701: EMPTY
26702: LIST
26703: LIST
26704: PUSH
26705: LD_INT 1
26707: PUSH
26708: LD_INT 1
26710: NEG
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 2
26718: PUSH
26719: LD_INT 0
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 2
26728: PUSH
26729: LD_INT 1
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 2
26738: PUSH
26739: LD_INT 2
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: LD_INT 1
26748: PUSH
26749: LD_INT 2
26751: PUSH
26752: EMPTY
26753: LIST
26754: LIST
26755: PUSH
26756: LD_INT 0
26758: PUSH
26759: LD_INT 2
26761: PUSH
26762: EMPTY
26763: LIST
26764: LIST
26765: PUSH
26766: LD_INT 1
26768: NEG
26769: PUSH
26770: LD_INT 1
26772: PUSH
26773: EMPTY
26774: LIST
26775: LIST
26776: PUSH
26777: LD_INT 2
26779: NEG
26780: PUSH
26781: LD_INT 0
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: LD_INT 2
26790: NEG
26791: PUSH
26792: LD_INT 1
26794: NEG
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 2
26802: NEG
26803: PUSH
26804: LD_INT 2
26806: NEG
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: LIST
26821: LIST
26822: LIST
26823: LIST
26824: LIST
26825: LIST
26826: LIST
26827: LIST
26828: LIST
26829: LIST
26830: LIST
26831: LIST
26832: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26833: NOP4
26837: PUSH
26838: LD_INT 0
26840: PUSH
26841: LD_INT 0
26843: PUSH
26844: EMPTY
26845: LIST
26846: LIST
26847: PUSH
26848: LD_INT 0
26850: PUSH
26851: LD_INT 1
26853: NEG
26854: PUSH
26855: EMPTY
26856: LIST
26857: LIST
26858: PUSH
26859: LD_INT 1
26861: PUSH
26862: LD_INT 0
26864: PUSH
26865: EMPTY
26866: LIST
26867: LIST
26868: PUSH
26869: LD_INT 1
26871: PUSH
26872: LD_INT 1
26874: PUSH
26875: EMPTY
26876: LIST
26877: LIST
26878: PUSH
26879: LD_INT 0
26881: PUSH
26882: LD_INT 1
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 1
26891: NEG
26892: PUSH
26893: LD_INT 0
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 1
26902: NEG
26903: PUSH
26904: LD_INT 1
26906: NEG
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 1
26914: NEG
26915: PUSH
26916: LD_INT 2
26918: NEG
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 0
26926: PUSH
26927: LD_INT 2
26929: NEG
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: LD_INT 1
26937: PUSH
26938: LD_INT 1
26940: NEG
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 2
26948: PUSH
26949: LD_INT 0
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: LD_INT 2
26958: PUSH
26959: LD_INT 1
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: LD_INT 2
26968: PUSH
26969: LD_INT 2
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: PUSH
26976: LD_INT 1
26978: PUSH
26979: LD_INT 2
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: LD_INT 0
26988: PUSH
26989: LD_INT 2
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: LD_INT 1
26998: NEG
26999: PUSH
27000: LD_INT 1
27002: PUSH
27003: EMPTY
27004: LIST
27005: LIST
27006: PUSH
27007: LD_INT 2
27009: NEG
27010: PUSH
27011: LD_INT 0
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: PUSH
27018: LD_INT 2
27020: NEG
27021: PUSH
27022: LD_INT 1
27024: NEG
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 2
27032: NEG
27033: PUSH
27034: LD_INT 2
27036: NEG
27037: PUSH
27038: EMPTY
27039: LIST
27040: LIST
27041: PUSH
27042: LD_INT 2
27044: NEG
27045: PUSH
27046: LD_INT 3
27048: NEG
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: LD_INT 1
27056: NEG
27057: PUSH
27058: LD_INT 3
27060: NEG
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: LD_INT 1
27068: PUSH
27069: LD_INT 2
27071: NEG
27072: PUSH
27073: EMPTY
27074: LIST
27075: LIST
27076: PUSH
27077: LD_INT 2
27079: PUSH
27080: LD_INT 1
27082: NEG
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: LIST
27105: LIST
27106: LIST
27107: LIST
27108: LIST
27109: LIST
27110: LIST
27111: LIST
27112: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27113: NOP4
27117: PUSH
27118: LD_INT 0
27120: PUSH
27121: LD_INT 0
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 0
27130: PUSH
27131: LD_INT 1
27133: NEG
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PUSH
27139: LD_INT 1
27141: PUSH
27142: LD_INT 0
27144: PUSH
27145: EMPTY
27146: LIST
27147: LIST
27148: PUSH
27149: LD_INT 1
27151: PUSH
27152: LD_INT 1
27154: PUSH
27155: EMPTY
27156: LIST
27157: LIST
27158: PUSH
27159: LD_INT 0
27161: PUSH
27162: LD_INT 1
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: NEG
27172: PUSH
27173: LD_INT 0
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 1
27182: NEG
27183: PUSH
27184: LD_INT 1
27186: NEG
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PUSH
27192: LD_INT 1
27194: NEG
27195: PUSH
27196: LD_INT 2
27198: NEG
27199: PUSH
27200: EMPTY
27201: LIST
27202: LIST
27203: PUSH
27204: LD_INT 0
27206: PUSH
27207: LD_INT 2
27209: NEG
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: PUSH
27215: LD_INT 1
27217: PUSH
27218: LD_INT 1
27220: NEG
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: LD_INT 2
27228: PUSH
27229: LD_INT 0
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: LD_INT 2
27238: PUSH
27239: LD_INT 1
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: LD_INT 2
27248: PUSH
27249: LD_INT 2
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 1
27258: PUSH
27259: LD_INT 2
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 0
27268: PUSH
27269: LD_INT 2
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: LD_INT 1
27278: NEG
27279: PUSH
27280: LD_INT 1
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: LD_INT 2
27289: NEG
27290: PUSH
27291: LD_INT 0
27293: PUSH
27294: EMPTY
27295: LIST
27296: LIST
27297: PUSH
27298: LD_INT 2
27300: NEG
27301: PUSH
27302: LD_INT 1
27304: NEG
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: PUSH
27310: LD_INT 2
27312: NEG
27313: PUSH
27314: LD_INT 2
27316: NEG
27317: PUSH
27318: EMPTY
27319: LIST
27320: LIST
27321: PUSH
27322: LD_INT 1
27324: PUSH
27325: LD_INT 2
27327: NEG
27328: PUSH
27329: EMPTY
27330: LIST
27331: LIST
27332: PUSH
27333: LD_INT 2
27335: PUSH
27336: LD_INT 1
27338: NEG
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 3
27346: PUSH
27347: LD_INT 1
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 3
27356: PUSH
27357: LD_INT 2
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: EMPTY
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: LIST
27374: LIST
27375: LIST
27376: LIST
27377: LIST
27378: LIST
27379: LIST
27380: LIST
27381: LIST
27382: LIST
27383: LIST
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27389: NOP4
27393: PUSH
27394: LD_INT 0
27396: PUSH
27397: LD_INT 0
27399: PUSH
27400: EMPTY
27401: LIST
27402: LIST
27403: PUSH
27404: LD_INT 0
27406: PUSH
27407: LD_INT 1
27409: NEG
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: PUSH
27415: LD_INT 1
27417: PUSH
27418: LD_INT 0
27420: PUSH
27421: EMPTY
27422: LIST
27423: LIST
27424: PUSH
27425: LD_INT 1
27427: PUSH
27428: LD_INT 1
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: PUSH
27435: LD_INT 0
27437: PUSH
27438: LD_INT 1
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 1
27447: NEG
27448: PUSH
27449: LD_INT 0
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: PUSH
27456: LD_INT 1
27458: NEG
27459: PUSH
27460: LD_INT 1
27462: NEG
27463: PUSH
27464: EMPTY
27465: LIST
27466: LIST
27467: PUSH
27468: LD_INT 1
27470: NEG
27471: PUSH
27472: LD_INT 2
27474: NEG
27475: PUSH
27476: EMPTY
27477: LIST
27478: LIST
27479: PUSH
27480: LD_INT 0
27482: PUSH
27483: LD_INT 2
27485: NEG
27486: PUSH
27487: EMPTY
27488: LIST
27489: LIST
27490: PUSH
27491: LD_INT 1
27493: PUSH
27494: LD_INT 1
27496: NEG
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: LD_INT 2
27504: PUSH
27505: LD_INT 0
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 2
27514: PUSH
27515: LD_INT 1
27517: PUSH
27518: EMPTY
27519: LIST
27520: LIST
27521: PUSH
27522: LD_INT 2
27524: PUSH
27525: LD_INT 2
27527: PUSH
27528: EMPTY
27529: LIST
27530: LIST
27531: PUSH
27532: LD_INT 1
27534: PUSH
27535: LD_INT 2
27537: PUSH
27538: EMPTY
27539: LIST
27540: LIST
27541: PUSH
27542: LD_INT 0
27544: PUSH
27545: LD_INT 2
27547: PUSH
27548: EMPTY
27549: LIST
27550: LIST
27551: PUSH
27552: LD_INT 1
27554: NEG
27555: PUSH
27556: LD_INT 1
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: LD_INT 2
27565: NEG
27566: PUSH
27567: LD_INT 0
27569: PUSH
27570: EMPTY
27571: LIST
27572: LIST
27573: PUSH
27574: LD_INT 2
27576: NEG
27577: PUSH
27578: LD_INT 1
27580: NEG
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: PUSH
27586: LD_INT 2
27588: NEG
27589: PUSH
27590: LD_INT 2
27592: NEG
27593: PUSH
27594: EMPTY
27595: LIST
27596: LIST
27597: PUSH
27598: LD_INT 3
27600: PUSH
27601: LD_INT 1
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: LD_INT 3
27610: PUSH
27611: LD_INT 2
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 2
27620: PUSH
27621: LD_INT 3
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PUSH
27628: LD_INT 1
27630: PUSH
27631: LD_INT 3
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PUSH
27638: EMPTY
27639: LIST
27640: LIST
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: LIST
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: LIST
27654: LIST
27655: LIST
27656: LIST
27657: LIST
27658: LIST
27659: LIST
27660: LIST
27661: LIST
27662: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27663: NOP4
27667: PUSH
27668: LD_INT 0
27670: PUSH
27671: LD_INT 0
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: PUSH
27678: LD_INT 0
27680: PUSH
27681: LD_INT 1
27683: NEG
27684: PUSH
27685: EMPTY
27686: LIST
27687: LIST
27688: PUSH
27689: LD_INT 1
27691: PUSH
27692: LD_INT 0
27694: PUSH
27695: EMPTY
27696: LIST
27697: LIST
27698: PUSH
27699: LD_INT 1
27701: PUSH
27702: LD_INT 1
27704: PUSH
27705: EMPTY
27706: LIST
27707: LIST
27708: PUSH
27709: LD_INT 0
27711: PUSH
27712: LD_INT 1
27714: PUSH
27715: EMPTY
27716: LIST
27717: LIST
27718: PUSH
27719: LD_INT 1
27721: NEG
27722: PUSH
27723: LD_INT 0
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: PUSH
27730: LD_INT 1
27732: NEG
27733: PUSH
27734: LD_INT 1
27736: NEG
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: LD_INT 1
27744: NEG
27745: PUSH
27746: LD_INT 2
27748: NEG
27749: PUSH
27750: EMPTY
27751: LIST
27752: LIST
27753: PUSH
27754: LD_INT 0
27756: PUSH
27757: LD_INT 2
27759: NEG
27760: PUSH
27761: EMPTY
27762: LIST
27763: LIST
27764: PUSH
27765: LD_INT 1
27767: PUSH
27768: LD_INT 1
27770: NEG
27771: PUSH
27772: EMPTY
27773: LIST
27774: LIST
27775: PUSH
27776: LD_INT 2
27778: PUSH
27779: LD_INT 0
27781: PUSH
27782: EMPTY
27783: LIST
27784: LIST
27785: PUSH
27786: LD_INT 2
27788: PUSH
27789: LD_INT 1
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: LD_INT 2
27798: PUSH
27799: LD_INT 2
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: LD_INT 1
27808: PUSH
27809: LD_INT 2
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: PUSH
27816: LD_INT 0
27818: PUSH
27819: LD_INT 2
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: LD_INT 1
27828: NEG
27829: PUSH
27830: LD_INT 1
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: LD_INT 2
27839: NEG
27840: PUSH
27841: LD_INT 0
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 2
27850: NEG
27851: PUSH
27852: LD_INT 1
27854: NEG
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PUSH
27860: LD_INT 2
27862: NEG
27863: PUSH
27864: LD_INT 2
27866: NEG
27867: PUSH
27868: EMPTY
27869: LIST
27870: LIST
27871: PUSH
27872: LD_INT 2
27874: PUSH
27875: LD_INT 3
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: PUSH
27882: LD_INT 1
27884: PUSH
27885: LD_INT 3
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: LD_INT 1
27894: NEG
27895: PUSH
27896: LD_INT 2
27898: PUSH
27899: EMPTY
27900: LIST
27901: LIST
27902: PUSH
27903: LD_INT 2
27905: NEG
27906: PUSH
27907: LD_INT 1
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: PUSH
27914: EMPTY
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: LIST
27920: LIST
27921: LIST
27922: LIST
27923: LIST
27924: LIST
27925: LIST
27926: LIST
27927: LIST
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: LIST
27933: LIST
27934: LIST
27935: LIST
27936: LIST
27937: LIST
27938: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27939: NOP4
27943: PUSH
27944: LD_INT 0
27946: PUSH
27947: LD_INT 0
27949: PUSH
27950: EMPTY
27951: LIST
27952: LIST
27953: PUSH
27954: LD_INT 0
27956: PUSH
27957: LD_INT 1
27959: NEG
27960: PUSH
27961: EMPTY
27962: LIST
27963: LIST
27964: PUSH
27965: LD_INT 1
27967: PUSH
27968: LD_INT 0
27970: PUSH
27971: EMPTY
27972: LIST
27973: LIST
27974: PUSH
27975: LD_INT 1
27977: PUSH
27978: LD_INT 1
27980: PUSH
27981: EMPTY
27982: LIST
27983: LIST
27984: PUSH
27985: LD_INT 0
27987: PUSH
27988: LD_INT 1
27990: PUSH
27991: EMPTY
27992: LIST
27993: LIST
27994: PUSH
27995: LD_INT 1
27997: NEG
27998: PUSH
27999: LD_INT 0
28001: PUSH
28002: EMPTY
28003: LIST
28004: LIST
28005: PUSH
28006: LD_INT 1
28008: NEG
28009: PUSH
28010: LD_INT 1
28012: NEG
28013: PUSH
28014: EMPTY
28015: LIST
28016: LIST
28017: PUSH
28018: LD_INT 1
28020: NEG
28021: PUSH
28022: LD_INT 2
28024: NEG
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: LD_INT 0
28032: PUSH
28033: LD_INT 2
28035: NEG
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: LD_INT 1
28043: PUSH
28044: LD_INT 1
28046: NEG
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: LD_INT 2
28054: PUSH
28055: LD_INT 0
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: LD_INT 2
28064: PUSH
28065: LD_INT 1
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 2
28074: PUSH
28075: LD_INT 2
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: PUSH
28082: LD_INT 1
28084: PUSH
28085: LD_INT 2
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 0
28094: PUSH
28095: LD_INT 2
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 1
28104: NEG
28105: PUSH
28106: LD_INT 1
28108: PUSH
28109: EMPTY
28110: LIST
28111: LIST
28112: PUSH
28113: LD_INT 2
28115: NEG
28116: PUSH
28117: LD_INT 0
28119: PUSH
28120: EMPTY
28121: LIST
28122: LIST
28123: PUSH
28124: LD_INT 2
28126: NEG
28127: PUSH
28128: LD_INT 1
28130: NEG
28131: PUSH
28132: EMPTY
28133: LIST
28134: LIST
28135: PUSH
28136: LD_INT 2
28138: NEG
28139: PUSH
28140: LD_INT 2
28142: NEG
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: LD_INT 1
28150: NEG
28151: PUSH
28152: LD_INT 2
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PUSH
28159: LD_INT 2
28161: NEG
28162: PUSH
28163: LD_INT 1
28165: PUSH
28166: EMPTY
28167: LIST
28168: LIST
28169: PUSH
28170: LD_INT 3
28172: NEG
28173: PUSH
28174: LD_INT 1
28176: NEG
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 3
28184: NEG
28185: PUSH
28186: LD_INT 2
28188: NEG
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: LIST
28212: LIST
28213: LIST
28214: LIST
28215: LIST
28216: LIST
28217: LIST
28218: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28219: NOP4
28223: PUSH
28224: LD_INT 0
28226: PUSH
28227: LD_INT 0
28229: PUSH
28230: EMPTY
28231: LIST
28232: LIST
28233: PUSH
28234: LD_INT 0
28236: PUSH
28237: LD_INT 1
28239: NEG
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: PUSH
28245: LD_INT 1
28247: PUSH
28248: LD_INT 0
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: PUSH
28255: LD_INT 1
28257: PUSH
28258: LD_INT 1
28260: PUSH
28261: EMPTY
28262: LIST
28263: LIST
28264: PUSH
28265: LD_INT 0
28267: PUSH
28268: LD_INT 1
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: PUSH
28275: LD_INT 1
28277: NEG
28278: PUSH
28279: LD_INT 0
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 1
28288: NEG
28289: PUSH
28290: LD_INT 1
28292: NEG
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 1
28300: NEG
28301: PUSH
28302: LD_INT 2
28304: NEG
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 0
28312: PUSH
28313: LD_INT 2
28315: NEG
28316: PUSH
28317: EMPTY
28318: LIST
28319: LIST
28320: PUSH
28321: LD_INT 1
28323: PUSH
28324: LD_INT 1
28326: NEG
28327: PUSH
28328: EMPTY
28329: LIST
28330: LIST
28331: PUSH
28332: LD_INT 2
28334: PUSH
28335: LD_INT 0
28337: PUSH
28338: EMPTY
28339: LIST
28340: LIST
28341: PUSH
28342: LD_INT 2
28344: PUSH
28345: LD_INT 1
28347: PUSH
28348: EMPTY
28349: LIST
28350: LIST
28351: PUSH
28352: LD_INT 2
28354: PUSH
28355: LD_INT 2
28357: PUSH
28358: EMPTY
28359: LIST
28360: LIST
28361: PUSH
28362: LD_INT 1
28364: PUSH
28365: LD_INT 2
28367: PUSH
28368: EMPTY
28369: LIST
28370: LIST
28371: PUSH
28372: LD_INT 0
28374: PUSH
28375: LD_INT 2
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 1
28384: NEG
28385: PUSH
28386: LD_INT 1
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PUSH
28393: LD_INT 2
28395: NEG
28396: PUSH
28397: LD_INT 0
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 2
28406: NEG
28407: PUSH
28408: LD_INT 1
28410: NEG
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: LD_INT 2
28418: NEG
28419: PUSH
28420: LD_INT 2
28422: NEG
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: LD_INT 2
28430: NEG
28431: PUSH
28432: LD_INT 3
28434: NEG
28435: PUSH
28436: EMPTY
28437: LIST
28438: LIST
28439: PUSH
28440: LD_INT 1
28442: NEG
28443: PUSH
28444: LD_INT 3
28446: NEG
28447: PUSH
28448: EMPTY
28449: LIST
28450: LIST
28451: PUSH
28452: LD_INT 3
28454: NEG
28455: PUSH
28456: LD_INT 1
28458: NEG
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: PUSH
28464: LD_INT 3
28466: NEG
28467: PUSH
28468: LD_INT 2
28470: NEG
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: LIST
28495: LIST
28496: LIST
28497: LIST
28498: LIST
28499: LIST
28500: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28501: NOP4
28505: PUSH
28506: LD_INT 0
28508: PUSH
28509: LD_INT 0
28511: PUSH
28512: EMPTY
28513: LIST
28514: LIST
28515: PUSH
28516: LD_INT 0
28518: PUSH
28519: LD_INT 1
28521: NEG
28522: PUSH
28523: EMPTY
28524: LIST
28525: LIST
28526: PUSH
28527: LD_INT 1
28529: PUSH
28530: LD_INT 0
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: PUSH
28537: LD_INT 1
28539: PUSH
28540: LD_INT 1
28542: PUSH
28543: EMPTY
28544: LIST
28545: LIST
28546: PUSH
28547: LD_INT 0
28549: PUSH
28550: LD_INT 1
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PUSH
28557: LD_INT 1
28559: NEG
28560: PUSH
28561: LD_INT 0
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: PUSH
28568: LD_INT 1
28570: NEG
28571: PUSH
28572: LD_INT 1
28574: NEG
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 1
28582: NEG
28583: PUSH
28584: LD_INT 2
28586: NEG
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 2
28597: NEG
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: LD_INT 1
28608: NEG
28609: PUSH
28610: EMPTY
28611: LIST
28612: LIST
28613: PUSH
28614: LD_INT 2
28616: PUSH
28617: LD_INT 0
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 2
28626: PUSH
28627: LD_INT 1
28629: PUSH
28630: EMPTY
28631: LIST
28632: LIST
28633: PUSH
28634: LD_INT 1
28636: PUSH
28637: LD_INT 2
28639: PUSH
28640: EMPTY
28641: LIST
28642: LIST
28643: PUSH
28644: LD_INT 0
28646: PUSH
28647: LD_INT 2
28649: PUSH
28650: EMPTY
28651: LIST
28652: LIST
28653: PUSH
28654: LD_INT 1
28656: NEG
28657: PUSH
28658: LD_INT 1
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: LD_INT 2
28667: NEG
28668: PUSH
28669: LD_INT 1
28671: NEG
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: NEG
28680: PUSH
28681: LD_INT 2
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 2
28691: NEG
28692: PUSH
28693: LD_INT 3
28695: NEG
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 2
28703: PUSH
28704: LD_INT 1
28706: NEG
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 3
28714: PUSH
28715: LD_INT 1
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 1
28724: PUSH
28725: LD_INT 3
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: LD_INT 2
28738: PUSH
28739: EMPTY
28740: LIST
28741: LIST
28742: PUSH
28743: LD_INT 3
28745: NEG
28746: PUSH
28747: LD_INT 2
28749: NEG
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: LIST
28773: LIST
28774: LIST
28775: LIST
28776: LIST
28777: LIST
28778: LIST
28779: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28780: NOP4
28784: PUSH
28785: LD_INT 0
28787: PUSH
28788: LD_INT 0
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: LD_INT 0
28797: PUSH
28798: LD_INT 1
28800: NEG
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 1
28808: PUSH
28809: LD_INT 0
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 1
28818: PUSH
28819: LD_INT 1
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 0
28828: PUSH
28829: LD_INT 1
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PUSH
28836: LD_INT 1
28838: NEG
28839: PUSH
28840: LD_INT 0
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 1
28849: NEG
28850: PUSH
28851: LD_INT 1
28853: NEG
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: PUSH
28859: LD_INT 1
28861: NEG
28862: PUSH
28863: LD_INT 2
28865: NEG
28866: PUSH
28867: EMPTY
28868: LIST
28869: LIST
28870: PUSH
28871: LD_INT 0
28873: PUSH
28874: LD_INT 2
28876: NEG
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 1
28884: PUSH
28885: LD_INT 1
28887: NEG
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 2
28895: PUSH
28896: LD_INT 0
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: LD_INT 2
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 2
28915: PUSH
28916: LD_INT 2
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: LD_INT 1
28925: PUSH
28926: LD_INT 2
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 1
28935: NEG
28936: PUSH
28937: LD_INT 1
28939: PUSH
28940: EMPTY
28941: LIST
28942: LIST
28943: PUSH
28944: LD_INT 2
28946: NEG
28947: PUSH
28948: LD_INT 0
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 2
28957: NEG
28958: PUSH
28959: LD_INT 1
28961: NEG
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 1
28969: NEG
28970: PUSH
28971: LD_INT 3
28973: NEG
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 1
28981: PUSH
28982: LD_INT 2
28984: NEG
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 3
28992: PUSH
28993: LD_INT 2
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 2
29002: PUSH
29003: LD_INT 3
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: PUSH
29010: LD_INT 2
29012: NEG
29013: PUSH
29014: LD_INT 1
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: PUSH
29021: LD_INT 3
29023: NEG
29024: PUSH
29025: LD_INT 1
29027: NEG
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: LIST
29053: LIST
29054: LIST
29055: LIST
29056: LIST
29057: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29058: NOP4
29062: PUSH
29063: LD_INT 0
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: EMPTY
29070: LIST
29071: LIST
29072: PUSH
29073: LD_INT 0
29075: PUSH
29076: LD_INT 1
29078: NEG
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 1
29086: PUSH
29087: LD_INT 0
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: PUSH
29094: LD_INT 1
29096: PUSH
29097: LD_INT 1
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 0
29106: PUSH
29107: LD_INT 1
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: PUSH
29114: LD_INT 1
29116: NEG
29117: PUSH
29118: LD_INT 0
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: PUSH
29129: LD_INT 1
29131: NEG
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 1
29139: NEG
29140: PUSH
29141: LD_INT 2
29143: NEG
29144: PUSH
29145: EMPTY
29146: LIST
29147: LIST
29148: PUSH
29149: LD_INT 1
29151: PUSH
29152: LD_INT 1
29154: NEG
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 2
29162: PUSH
29163: LD_INT 0
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 2
29172: PUSH
29173: LD_INT 1
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PUSH
29180: LD_INT 2
29182: PUSH
29183: LD_INT 2
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 1
29192: PUSH
29193: LD_INT 2
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 0
29202: PUSH
29203: LD_INT 2
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 1
29212: NEG
29213: PUSH
29214: LD_INT 1
29216: PUSH
29217: EMPTY
29218: LIST
29219: LIST
29220: PUSH
29221: LD_INT 2
29223: NEG
29224: PUSH
29225: LD_INT 1
29227: NEG
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: LD_INT 2
29235: NEG
29236: PUSH
29237: LD_INT 2
29239: NEG
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 2
29247: NEG
29248: PUSH
29249: LD_INT 3
29251: NEG
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 2
29259: PUSH
29260: LD_INT 1
29262: NEG
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 3
29270: PUSH
29271: LD_INT 1
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 1
29280: PUSH
29281: LD_INT 3
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: LD_INT 2
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PUSH
29299: LD_INT 3
29301: NEG
29302: PUSH
29303: LD_INT 2
29305: NEG
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: LIST
29333: LIST
29334: LIST
29335: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29336: NOP4
29340: PUSH
29341: LD_INT 0
29343: PUSH
29344: LD_INT 0
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: PUSH
29351: LD_INT 0
29353: PUSH
29354: LD_INT 1
29356: NEG
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: LD_INT 0
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 1
29374: PUSH
29375: LD_INT 1
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 0
29384: PUSH
29385: LD_INT 1
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: LD_INT 1
29394: NEG
29395: PUSH
29396: LD_INT 0
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 1
29405: NEG
29406: PUSH
29407: LD_INT 1
29409: NEG
29410: PUSH
29411: EMPTY
29412: LIST
29413: LIST
29414: PUSH
29415: LD_INT 1
29417: NEG
29418: PUSH
29419: LD_INT 2
29421: NEG
29422: PUSH
29423: EMPTY
29424: LIST
29425: LIST
29426: PUSH
29427: LD_INT 0
29429: PUSH
29430: LD_INT 2
29432: NEG
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: LD_INT 1
29440: PUSH
29441: LD_INT 1
29443: NEG
29444: PUSH
29445: EMPTY
29446: LIST
29447: LIST
29448: PUSH
29449: LD_INT 2
29451: PUSH
29452: LD_INT 1
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 2
29461: PUSH
29462: LD_INT 2
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: LD_INT 1
29471: PUSH
29472: LD_INT 2
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 0
29481: PUSH
29482: LD_INT 2
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: NEG
29492: PUSH
29493: LD_INT 1
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PUSH
29500: LD_INT 2
29502: NEG
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 2
29513: NEG
29514: PUSH
29515: LD_INT 1
29517: NEG
29518: PUSH
29519: EMPTY
29520: LIST
29521: LIST
29522: PUSH
29523: LD_INT 1
29525: NEG
29526: PUSH
29527: LD_INT 3
29529: NEG
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 1
29537: PUSH
29538: LD_INT 2
29540: NEG
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 3
29548: PUSH
29549: LD_INT 2
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 2
29558: PUSH
29559: LD_INT 3
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: NEG
29569: PUSH
29570: LD_INT 1
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: PUSH
29577: LD_INT 3
29579: NEG
29580: PUSH
29581: LD_INT 1
29583: NEG
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29614: NOP4
29618: PUSH
29619: LD_INT 0
29621: PUSH
29622: LD_INT 0
29624: PUSH
29625: EMPTY
29626: LIST
29627: LIST
29628: PUSH
29629: LD_INT 0
29631: PUSH
29632: LD_INT 1
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 1
29642: PUSH
29643: LD_INT 0
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 1
29652: PUSH
29653: LD_INT 1
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 0
29662: PUSH
29663: LD_INT 1
29665: PUSH
29666: EMPTY
29667: LIST
29668: LIST
29669: PUSH
29670: LD_INT 1
29672: NEG
29673: PUSH
29674: LD_INT 0
29676: PUSH
29677: EMPTY
29678: LIST
29679: LIST
29680: PUSH
29681: LD_INT 1
29683: NEG
29684: PUSH
29685: LD_INT 1
29687: NEG
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: LD_INT 1
29695: NEG
29696: PUSH
29697: LD_INT 2
29699: NEG
29700: PUSH
29701: EMPTY
29702: LIST
29703: LIST
29704: PUSH
29705: LD_INT 1
29707: PUSH
29708: LD_INT 1
29710: NEG
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 2
29718: PUSH
29719: LD_INT 0
29721: PUSH
29722: EMPTY
29723: LIST
29724: LIST
29725: PUSH
29726: LD_INT 2
29728: PUSH
29729: LD_INT 1
29731: PUSH
29732: EMPTY
29733: LIST
29734: LIST
29735: PUSH
29736: LD_INT 1
29738: PUSH
29739: LD_INT 2
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: LD_INT 2
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 1
29758: NEG
29759: PUSH
29760: LD_INT 1
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 2
29769: NEG
29770: PUSH
29771: LD_INT 0
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 2
29780: NEG
29781: PUSH
29782: LD_INT 1
29784: NEG
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 2
29792: NEG
29793: PUSH
29794: LD_INT 2
29796: NEG
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: LD_INT 2
29804: NEG
29805: PUSH
29806: LD_INT 3
29808: NEG
29809: PUSH
29810: EMPTY
29811: LIST
29812: LIST
29813: PUSH
29814: LD_INT 2
29816: PUSH
29817: LD_INT 1
29819: NEG
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: PUSH
29825: LD_INT 3
29827: PUSH
29828: LD_INT 1
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: PUSH
29835: LD_INT 1
29837: PUSH
29838: LD_INT 3
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: LD_INT 1
29847: NEG
29848: PUSH
29849: LD_INT 2
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: PUSH
29856: LD_INT 3
29858: NEG
29859: PUSH
29860: LD_INT 2
29862: NEG
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29893: NOP4
29897: PUSH
29898: LD_INT 0
29900: PUSH
29901: LD_INT 0
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 0
29910: PUSH
29911: LD_INT 1
29913: NEG
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PUSH
29919: LD_INT 1
29921: PUSH
29922: LD_INT 0
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: LD_INT 1
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 0
29941: PUSH
29942: LD_INT 1
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 1
29951: NEG
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: LD_INT 1
29966: NEG
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 1
29974: NEG
29975: PUSH
29976: LD_INT 2
29978: NEG
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 0
29986: PUSH
29987: LD_INT 2
29989: NEG
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: LD_INT 1
29997: PUSH
29998: LD_INT 1
30000: NEG
30001: PUSH
30002: EMPTY
30003: LIST
30004: LIST
30005: PUSH
30006: LD_INT 2
30008: PUSH
30009: LD_INT 1
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 2
30018: PUSH
30019: LD_INT 2
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 1
30028: PUSH
30029: LD_INT 2
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 1
30038: NEG
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 2
30049: NEG
30050: PUSH
30051: LD_INT 0
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 2
30060: NEG
30061: PUSH
30062: LD_INT 1
30064: NEG
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: PUSH
30070: LD_INT 2
30072: NEG
30073: PUSH
30074: LD_INT 2
30076: NEG
30077: PUSH
30078: EMPTY
30079: LIST
30080: LIST
30081: PUSH
30082: LD_INT 1
30084: NEG
30085: PUSH
30086: LD_INT 3
30088: NEG
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 1
30096: PUSH
30097: LD_INT 2
30099: NEG
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PUSH
30105: LD_INT 3
30107: PUSH
30108: LD_INT 2
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 2
30117: PUSH
30118: LD_INT 3
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 2
30127: NEG
30128: PUSH
30129: LD_INT 1
30131: PUSH
30132: EMPTY
30133: LIST
30134: LIST
30135: PUSH
30136: LD_INT 3
30138: NEG
30139: PUSH
30140: LD_INT 1
30142: NEG
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: LIST
30170: LIST
30171: LIST
30172: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30173: NOP4
30177: PUSH
30178: LD_INT 0
30180: PUSH
30181: LD_INT 0
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 0
30190: PUSH
30191: LD_INT 1
30193: NEG
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 1
30201: PUSH
30202: LD_INT 0
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PUSH
30209: LD_INT 1
30211: PUSH
30212: LD_INT 1
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: LD_INT 1
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PUSH
30229: LD_INT 1
30231: NEG
30232: PUSH
30233: LD_INT 0
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: PUSH
30240: LD_INT 1
30242: NEG
30243: PUSH
30244: LD_INT 1
30246: NEG
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 2
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: LD_INT 1
30268: NEG
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30285: NOP4
30289: PUSH
30290: LD_INT 0
30292: PUSH
30293: LD_INT 0
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 0
30302: PUSH
30303: LD_INT 1
30305: NEG
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: PUSH
30314: LD_INT 0
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PUSH
30321: LD_INT 1
30323: PUSH
30324: LD_INT 1
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 0
30333: PUSH
30334: LD_INT 1
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PUSH
30341: LD_INT 1
30343: NEG
30344: PUSH
30345: LD_INT 0
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: LD_INT 1
30358: NEG
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 1
30366: NEG
30367: PUSH
30368: LD_INT 2
30370: NEG
30371: PUSH
30372: EMPTY
30373: LIST
30374: LIST
30375: PUSH
30376: LD_INT 1
30378: PUSH
30379: LD_INT 2
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30397: NOP4
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: LD_INT 0
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: LD_INT 0
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 1
30425: PUSH
30426: LD_INT 0
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: PUSH
30433: LD_INT 1
30435: PUSH
30436: LD_INT 1
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 0
30445: PUSH
30446: LD_INT 1
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 1
30455: NEG
30456: PUSH
30457: LD_INT 0
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 1
30466: NEG
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: PUSH
30479: LD_INT 1
30481: NEG
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PUSH
30487: LD_INT 1
30489: NEG
30490: PUSH
30491: LD_INT 1
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30509: NOP4
30513: PUSH
30514: LD_INT 0
30516: PUSH
30517: LD_INT 0
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: LD_INT 0
30526: PUSH
30527: LD_INT 1
30529: NEG
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: LD_INT 0
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 1
30547: PUSH
30548: LD_INT 1
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: LD_INT 1
30560: PUSH
30561: EMPTY
30562: LIST
30563: LIST
30564: PUSH
30565: LD_INT 1
30567: NEG
30568: PUSH
30569: LD_INT 0
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 1
30578: NEG
30579: PUSH
30580: LD_INT 1
30582: NEG
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: PUSH
30588: LD_INT 2
30590: PUSH
30591: LD_INT 1
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 2
30600: NEG
30601: PUSH
30602: LD_INT 1
30604: NEG
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30621: NOP4
30625: PUSH
30626: LD_INT 0
30628: PUSH
30629: LD_INT 0
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 0
30638: PUSH
30639: LD_INT 1
30641: NEG
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: PUSH
30650: LD_INT 0
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: LD_INT 1
30659: PUSH
30660: LD_INT 1
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 0
30669: PUSH
30670: LD_INT 1
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: PUSH
30677: LD_INT 1
30679: NEG
30680: PUSH
30681: LD_INT 0
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: NEG
30691: PUSH
30692: LD_INT 1
30694: NEG
30695: PUSH
30696: EMPTY
30697: LIST
30698: LIST
30699: PUSH
30700: LD_INT 1
30702: NEG
30703: PUSH
30704: LD_INT 2
30706: NEG
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 1
30714: PUSH
30715: LD_INT 2
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: LIST
30728: LIST
30729: LIST
30730: LIST
30731: LIST
30732: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30733: NOP4
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: LD_INT 0
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: LD_INT 1
30753: NEG
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 1
30761: PUSH
30762: LD_INT 0
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 1
30771: PUSH
30772: LD_INT 1
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: LD_INT 0
30781: PUSH
30782: LD_INT 1
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PUSH
30789: LD_INT 1
30791: NEG
30792: PUSH
30793: LD_INT 0
30795: PUSH
30796: EMPTY
30797: LIST
30798: LIST
30799: PUSH
30800: LD_INT 1
30802: NEG
30803: PUSH
30804: LD_INT 1
30806: NEG
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 1
30814: PUSH
30815: LD_INT 1
30817: NEG
30818: PUSH
30819: EMPTY
30820: LIST
30821: LIST
30822: PUSH
30823: LD_INT 1
30825: NEG
30826: PUSH
30827: LD_INT 1
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: LIST
30838: LIST
30839: LIST
30840: LIST
30841: LIST
30842: LIST
30843: LIST
30844: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30845: NOP4
30849: PUSH
30850: LD_INT 0
30852: PUSH
30853: LD_INT 0
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 0
30862: PUSH
30863: LD_INT 1
30865: NEG
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 1
30873: PUSH
30874: LD_INT 0
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 1
30883: PUSH
30884: LD_INT 1
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 0
30893: PUSH
30894: LD_INT 1
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 1
30903: NEG
30904: PUSH
30905: LD_INT 0
30907: PUSH
30908: EMPTY
30909: LIST
30910: LIST
30911: PUSH
30912: LD_INT 1
30914: NEG
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 1
30926: NEG
30927: PUSH
30928: LD_INT 2
30930: NEG
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 1
30938: PUSH
30939: LD_INT 1
30941: NEG
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 2
30949: PUSH
30950: LD_INT 0
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 2
30959: PUSH
30960: LD_INT 1
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 2
30969: PUSH
30970: LD_INT 2
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 1
30979: PUSH
30980: LD_INT 2
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 1
30989: NEG
30990: PUSH
30991: LD_INT 1
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 2
31000: NEG
31001: PUSH
31002: LD_INT 0
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: LD_INT 2
31011: NEG
31012: PUSH
31013: LD_INT 1
31015: NEG
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 2
31023: NEG
31024: PUSH
31025: LD_INT 2
31027: NEG
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 2
31035: NEG
31036: PUSH
31037: LD_INT 3
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 2
31047: PUSH
31048: LD_INT 1
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 3
31058: PUSH
31059: LD_INT 0
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 3
31068: PUSH
31069: LD_INT 1
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: LD_INT 3
31078: PUSH
31079: LD_INT 2
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 3
31088: PUSH
31089: LD_INT 3
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 2
31098: PUSH
31099: LD_INT 3
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 2
31108: NEG
31109: PUSH
31110: LD_INT 1
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 3
31119: NEG
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 3
31130: NEG
31131: PUSH
31132: LD_INT 1
31134: NEG
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 3
31142: NEG
31143: PUSH
31144: LD_INT 2
31146: NEG
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 3
31154: NEG
31155: PUSH
31156: LD_INT 3
31158: NEG
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: LIST
31189: LIST
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31195: NOP4
31199: PUSH
31200: LD_INT 0
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 0
31212: PUSH
31213: LD_INT 1
31215: NEG
31216: PUSH
31217: EMPTY
31218: LIST
31219: LIST
31220: PUSH
31221: LD_INT 1
31223: PUSH
31224: LD_INT 0
31226: PUSH
31227: EMPTY
31228: LIST
31229: LIST
31230: PUSH
31231: LD_INT 1
31233: PUSH
31234: LD_INT 1
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: PUSH
31241: LD_INT 0
31243: PUSH
31244: LD_INT 1
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 1
31253: NEG
31254: PUSH
31255: LD_INT 0
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 1
31264: NEG
31265: PUSH
31266: LD_INT 1
31268: NEG
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 1
31276: NEG
31277: PUSH
31278: LD_INT 2
31280: NEG
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 0
31288: PUSH
31289: LD_INT 2
31291: NEG
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 1
31299: PUSH
31300: LD_INT 1
31302: NEG
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: LD_INT 2
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: LD_INT 2
31320: PUSH
31321: LD_INT 2
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 1
31330: PUSH
31331: LD_INT 2
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 0
31340: PUSH
31341: LD_INT 2
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 1
31350: NEG
31351: PUSH
31352: LD_INT 1
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: LD_INT 2
31361: NEG
31362: PUSH
31363: LD_INT 1
31365: NEG
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 2
31373: NEG
31374: PUSH
31375: LD_INT 2
31377: NEG
31378: PUSH
31379: EMPTY
31380: LIST
31381: LIST
31382: PUSH
31383: LD_INT 2
31385: NEG
31386: PUSH
31387: LD_INT 3
31389: NEG
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 1
31397: NEG
31398: PUSH
31399: LD_INT 3
31401: NEG
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: LD_INT 3
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: LD_INT 2
31423: NEG
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 3
31431: PUSH
31432: LD_INT 2
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: PUSH
31439: LD_INT 3
31441: PUSH
31442: LD_INT 3
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: PUSH
31449: LD_INT 2
31451: PUSH
31452: LD_INT 3
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 1
31461: PUSH
31462: LD_INT 3
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: LD_INT 3
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: LD_INT 1
31481: NEG
31482: PUSH
31483: LD_INT 2
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 3
31492: NEG
31493: PUSH
31494: LD_INT 2
31496: NEG
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 3
31504: NEG
31505: PUSH
31506: LD_INT 3
31508: NEG
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31545: NOP4
31549: PUSH
31550: LD_INT 0
31552: PUSH
31553: LD_INT 0
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: LD_INT 1
31565: NEG
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 1
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 1
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 0
31593: PUSH
31594: LD_INT 1
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 1
31603: NEG
31604: PUSH
31605: LD_INT 0
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 1
31614: NEG
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 1
31626: NEG
31627: PUSH
31628: LD_INT 2
31630: NEG
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 0
31638: PUSH
31639: LD_INT 2
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 1
31652: NEG
31653: PUSH
31654: EMPTY
31655: LIST
31656: LIST
31657: PUSH
31658: LD_INT 2
31660: PUSH
31661: LD_INT 0
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PUSH
31668: LD_INT 2
31670: PUSH
31671: LD_INT 1
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: LD_INT 1
31680: PUSH
31681: LD_INT 2
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 0
31690: PUSH
31691: LD_INT 2
31693: PUSH
31694: EMPTY
31695: LIST
31696: LIST
31697: PUSH
31698: LD_INT 1
31700: NEG
31701: PUSH
31702: LD_INT 1
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 2
31711: NEG
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: LD_INT 2
31722: NEG
31723: PUSH
31724: LD_INT 1
31726: NEG
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 1
31734: NEG
31735: PUSH
31736: LD_INT 3
31738: NEG
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 0
31746: PUSH
31747: LD_INT 3
31749: NEG
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 1
31757: PUSH
31758: LD_INT 2
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 2
31768: PUSH
31769: LD_INT 1
31771: NEG
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 3
31779: PUSH
31780: LD_INT 0
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 3
31789: PUSH
31790: LD_INT 1
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 1
31799: PUSH
31800: LD_INT 3
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 0
31809: PUSH
31810: LD_INT 3
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: NEG
31820: PUSH
31821: LD_INT 2
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 2
31830: NEG
31831: PUSH
31832: LD_INT 1
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 3
31841: NEG
31842: PUSH
31843: LD_INT 0
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 3
31852: NEG
31853: PUSH
31854: LD_INT 1
31856: NEG
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: LIST
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: LIST
31885: LIST
31886: LIST
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31893: NOP4
31897: PUSH
31898: LD_INT 0
31900: PUSH
31901: LD_INT 0
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 0
31910: PUSH
31911: LD_INT 1
31913: NEG
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 1
31921: PUSH
31922: LD_INT 0
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 1
31931: PUSH
31932: LD_INT 1
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 0
31941: PUSH
31942: LD_INT 1
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 1
31951: NEG
31952: PUSH
31953: LD_INT 0
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: NEG
31963: PUSH
31964: LD_INT 1
31966: NEG
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 1
31974: NEG
31975: PUSH
31976: LD_INT 2
31978: NEG
31979: PUSH
31980: EMPTY
31981: LIST
31982: LIST
31983: PUSH
31984: LD_INT 1
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: PUSH
31995: LD_INT 2
31997: PUSH
31998: LD_INT 0
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 2
32007: PUSH
32008: LD_INT 1
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 2
32017: PUSH
32018: LD_INT 2
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 1
32027: PUSH
32028: LD_INT 2
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 1
32037: NEG
32038: PUSH
32039: LD_INT 1
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 2
32048: NEG
32049: PUSH
32050: LD_INT 0
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 2
32059: NEG
32060: PUSH
32061: LD_INT 1
32063: NEG
32064: PUSH
32065: EMPTY
32066: LIST
32067: LIST
32068: PUSH
32069: LD_INT 2
32071: NEG
32072: PUSH
32073: LD_INT 2
32075: NEG
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 2
32083: NEG
32084: PUSH
32085: LD_INT 3
32087: NEG
32088: PUSH
32089: EMPTY
32090: LIST
32091: LIST
32092: PUSH
32093: LD_INT 2
32095: PUSH
32096: LD_INT 1
32098: NEG
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 3
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 3
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 3
32126: PUSH
32127: LD_INT 2
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PUSH
32134: LD_INT 3
32136: PUSH
32137: LD_INT 3
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 2
32146: PUSH
32147: LD_INT 3
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 2
32156: NEG
32157: PUSH
32158: LD_INT 1
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 3
32167: NEG
32168: PUSH
32169: LD_INT 0
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 3
32178: NEG
32179: PUSH
32180: LD_INT 1
32182: NEG
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 3
32190: NEG
32191: PUSH
32192: LD_INT 2
32194: NEG
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 3
32202: NEG
32203: PUSH
32204: LD_INT 3
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32243: NOP4
32247: PUSH
32248: LD_INT 0
32250: PUSH
32251: LD_INT 0
32253: PUSH
32254: EMPTY
32255: LIST
32256: LIST
32257: PUSH
32258: LD_INT 0
32260: PUSH
32261: LD_INT 1
32263: NEG
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 1
32271: PUSH
32272: LD_INT 0
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 1
32281: PUSH
32282: LD_INT 1
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 0
32291: PUSH
32292: LD_INT 1
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 1
32301: NEG
32302: PUSH
32303: LD_INT 0
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 1
32312: NEG
32313: PUSH
32314: LD_INT 1
32316: NEG
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: LD_INT 2
32328: NEG
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 0
32336: PUSH
32337: LD_INT 2
32339: NEG
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 1
32347: PUSH
32348: LD_INT 1
32350: NEG
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 2
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 2
32368: PUSH
32369: LD_INT 2
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: PUSH
32379: LD_INT 2
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 0
32388: PUSH
32389: LD_INT 2
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 1
32398: NEG
32399: PUSH
32400: LD_INT 1
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 2
32409: NEG
32410: PUSH
32411: LD_INT 1
32413: NEG
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 2
32421: NEG
32422: PUSH
32423: LD_INT 2
32425: NEG
32426: PUSH
32427: EMPTY
32428: LIST
32429: LIST
32430: PUSH
32431: LD_INT 2
32433: NEG
32434: PUSH
32435: LD_INT 3
32437: NEG
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 1
32445: NEG
32446: PUSH
32447: LD_INT 3
32449: NEG
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 0
32457: PUSH
32458: LD_INT 3
32460: NEG
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 1
32468: PUSH
32469: LD_INT 2
32471: NEG
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 3
32479: PUSH
32480: LD_INT 2
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 3
32489: PUSH
32490: LD_INT 3
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: LD_INT 2
32499: PUSH
32500: LD_INT 3
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: PUSH
32510: LD_INT 3
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 0
32519: PUSH
32520: LD_INT 3
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 1
32529: NEG
32530: PUSH
32531: LD_INT 2
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: PUSH
32538: LD_INT 3
32540: NEG
32541: PUSH
32542: LD_INT 2
32544: NEG
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 3
32552: NEG
32553: PUSH
32554: LD_INT 3
32556: NEG
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: LIST
32566: LIST
32567: LIST
32568: LIST
32569: LIST
32570: LIST
32571: LIST
32572: LIST
32573: LIST
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32593: NOP4
32597: PUSH
32598: LD_INT 0
32600: PUSH
32601: LD_INT 0
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 0
32610: PUSH
32611: LD_INT 1
32613: NEG
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 1
32621: PUSH
32622: LD_INT 0
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PUSH
32629: LD_INT 1
32631: PUSH
32632: LD_INT 1
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 0
32641: PUSH
32642: LD_INT 1
32644: PUSH
32645: EMPTY
32646: LIST
32647: LIST
32648: PUSH
32649: LD_INT 1
32651: NEG
32652: PUSH
32653: LD_INT 0
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 1
32662: NEG
32663: PUSH
32664: LD_INT 1
32666: NEG
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 1
32674: NEG
32675: PUSH
32676: LD_INT 2
32678: NEG
32679: PUSH
32680: EMPTY
32681: LIST
32682: LIST
32683: PUSH
32684: LD_INT 0
32686: PUSH
32687: LD_INT 2
32689: NEG
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 1
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: EMPTY
32703: LIST
32704: LIST
32705: PUSH
32706: LD_INT 2
32708: PUSH
32709: LD_INT 0
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 2
32718: PUSH
32719: LD_INT 1
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 1
32728: PUSH
32729: LD_INT 2
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 0
32738: PUSH
32739: LD_INT 2
32741: PUSH
32742: EMPTY
32743: LIST
32744: LIST
32745: PUSH
32746: LD_INT 1
32748: NEG
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 2
32759: NEG
32760: PUSH
32761: LD_INT 0
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 2
32770: NEG
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 1
32782: NEG
32783: PUSH
32784: LD_INT 3
32786: NEG
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 0
32794: PUSH
32795: LD_INT 3
32797: NEG
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 1
32805: PUSH
32806: LD_INT 2
32808: NEG
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PUSH
32814: LD_INT 2
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: LD_INT 3
32827: PUSH
32828: LD_INT 0
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: PUSH
32835: LD_INT 3
32837: PUSH
32838: LD_INT 1
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 1
32847: PUSH
32848: LD_INT 3
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 0
32857: PUSH
32858: LD_INT 3
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 1
32867: NEG
32868: PUSH
32869: LD_INT 2
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 2
32878: NEG
32879: PUSH
32880: LD_INT 1
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 3
32889: NEG
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 3
32900: NEG
32901: PUSH
32902: LD_INT 1
32904: NEG
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32941: NOP4
32945: PUSH
32946: LD_INT 0
32948: PUSH
32949: LD_INT 0
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: PUSH
32970: LD_INT 0
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 1
32979: PUSH
32980: LD_INT 1
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 0
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 1
32999: NEG
33000: PUSH
33001: LD_INT 0
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 1
33010: NEG
33011: PUSH
33012: LD_INT 1
33014: NEG
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 1
33022: NEG
33023: PUSH
33024: LD_INT 2
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 0
33034: PUSH
33035: LD_INT 2
33037: NEG
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 1
33048: NEG
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 2
33056: NEG
33057: PUSH
33058: LD_INT 1
33060: NEG
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: PUSH
33066: LD_INT 2
33068: NEG
33069: PUSH
33070: LD_INT 2
33072: NEG
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: LIST
33086: LIST
33087: LIST
33088: LIST
33089: LIST
33090: LIST
33091: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33092: NOP4
33096: PUSH
33097: LD_INT 0
33099: PUSH
33100: LD_INT 0
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 0
33109: PUSH
33110: LD_INT 1
33112: NEG
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: LD_INT 1
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 1
33130: PUSH
33131: LD_INT 1
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 0
33140: PUSH
33141: LD_INT 1
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 1
33150: NEG
33151: PUSH
33152: LD_INT 0
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PUSH
33159: LD_INT 1
33161: NEG
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 1
33173: NEG
33174: PUSH
33175: LD_INT 2
33177: NEG
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: LD_INT 2
33188: NEG
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 1
33196: PUSH
33197: LD_INT 1
33199: NEG
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 2
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 2
33217: PUSH
33218: LD_INT 1
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33239: NOP4
33243: PUSH
33244: LD_INT 0
33246: PUSH
33247: LD_INT 0
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 0
33256: PUSH
33257: LD_INT 1
33259: NEG
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 1
33267: PUSH
33268: LD_INT 0
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 1
33277: PUSH
33278: LD_INT 1
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 0
33287: PUSH
33288: LD_INT 1
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: NEG
33298: PUSH
33299: LD_INT 0
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 1
33308: NEG
33309: PUSH
33310: LD_INT 1
33312: NEG
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 1
33320: PUSH
33321: LD_INT 1
33323: NEG
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 2
33331: PUSH
33332: LD_INT 0
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 2
33341: PUSH
33342: LD_INT 1
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: PUSH
33352: LD_INT 2
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: LD_INT 2
33364: PUSH
33365: EMPTY
33366: LIST
33367: LIST
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33383: NOP4
33387: PUSH
33388: LD_INT 0
33390: PUSH
33391: LD_INT 0
33393: PUSH
33394: EMPTY
33395: LIST
33396: LIST
33397: PUSH
33398: LD_INT 0
33400: PUSH
33401: LD_INT 1
33403: NEG
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 1
33411: PUSH
33412: LD_INT 0
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PUSH
33419: LD_INT 1
33421: PUSH
33422: LD_INT 1
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 0
33431: PUSH
33432: LD_INT 1
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: LD_INT 1
33441: NEG
33442: PUSH
33443: LD_INT 0
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: LD_INT 1
33452: NEG
33453: PUSH
33454: LD_INT 1
33456: NEG
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PUSH
33462: LD_INT 2
33464: PUSH
33465: LD_INT 1
33467: PUSH
33468: EMPTY
33469: LIST
33470: LIST
33471: PUSH
33472: LD_INT 2
33474: PUSH
33475: LD_INT 2
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 1
33484: PUSH
33485: LD_INT 2
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 0
33494: PUSH
33495: LD_INT 2
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 1
33504: NEG
33505: PUSH
33506: LD_INT 1
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: LIST
33521: LIST
33522: LIST
33523: LIST
33524: LIST
33525: LIST
33526: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33527: NOP4
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: LD_INT 0
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 0
33544: PUSH
33545: LD_INT 1
33547: NEG
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 1
33555: PUSH
33556: LD_INT 0
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 1
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 0
33575: PUSH
33576: LD_INT 1
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 1
33585: NEG
33586: PUSH
33587: LD_INT 0
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 1
33596: NEG
33597: PUSH
33598: LD_INT 1
33600: NEG
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 1
33608: PUSH
33609: LD_INT 2
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 0
33618: PUSH
33619: LD_INT 2
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 1
33628: NEG
33629: PUSH
33630: LD_INT 1
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 2
33650: NEG
33651: PUSH
33652: LD_INT 1
33654: NEG
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: EMPTY
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: LIST
33666: LIST
33667: LIST
33668: LIST
33669: LIST
33670: LIST
33671: LIST
33672: LIST
33673: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33674: NOP4
33678: PUSH
33679: LD_INT 0
33681: PUSH
33682: LD_INT 0
33684: PUSH
33685: EMPTY
33686: LIST
33687: LIST
33688: PUSH
33689: LD_INT 0
33691: PUSH
33692: LD_INT 1
33694: NEG
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 1
33702: PUSH
33703: LD_INT 0
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 1
33712: PUSH
33713: LD_INT 1
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 0
33722: PUSH
33723: LD_INT 1
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 1
33732: NEG
33733: PUSH
33734: LD_INT 0
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 1
33743: NEG
33744: PUSH
33745: LD_INT 1
33747: NEG
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 1
33755: NEG
33756: PUSH
33757: LD_INT 2
33759: NEG
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: PUSH
33765: LD_INT 1
33767: NEG
33768: PUSH
33769: LD_INT 1
33771: PUSH
33772: EMPTY
33773: LIST
33774: LIST
33775: PUSH
33776: LD_INT 2
33778: NEG
33779: PUSH
33780: LD_INT 0
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 2
33789: NEG
33790: PUSH
33791: LD_INT 1
33793: NEG
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 2
33801: NEG
33802: PUSH
33803: LD_INT 2
33805: NEG
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33825: NOP4
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 1
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: LD_INT 1
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 1
33883: NEG
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 1
33894: NEG
33895: PUSH
33896: LD_INT 1
33898: NEG
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 1
33906: NEG
33907: PUSH
33908: LD_INT 2
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 0
33918: PUSH
33919: LD_INT 2
33921: NEG
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: LD_INT 1
33932: NEG
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 2
33940: PUSH
33941: LD_INT 0
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 2
33950: PUSH
33951: LD_INT 1
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 2
33960: PUSH
33961: LD_INT 2
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 1
33970: PUSH
33971: LD_INT 2
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 0
33980: PUSH
33981: LD_INT 2
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 1
33990: NEG
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: PUSH
33999: LD_INT 2
34001: NEG
34002: PUSH
34003: LD_INT 0
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 2
34012: NEG
34013: PUSH
34014: LD_INT 1
34016: NEG
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 2
34024: NEG
34025: PUSH
34026: LD_INT 2
34028: NEG
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34055: NOP4
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 0
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 0
34072: PUSH
34073: LD_INT 1
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 0
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 1
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 0
34103: PUSH
34104: LD_INT 1
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: LD_INT 1
34113: NEG
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: LD_INT 1
34128: NEG
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: LD_INT 2
34140: NEG
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 0
34148: PUSH
34149: LD_INT 2
34151: NEG
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 1
34159: PUSH
34160: LD_INT 1
34162: NEG
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 2
34170: PUSH
34171: LD_INT 0
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 2
34180: PUSH
34181: LD_INT 1
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 2
34190: PUSH
34191: LD_INT 2
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 1
34200: PUSH
34201: LD_INT 2
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: LD_INT 2
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: LD_INT 1
34220: NEG
34221: PUSH
34222: LD_INT 1
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 2
34231: NEG
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 2
34242: NEG
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 2
34254: NEG
34255: PUSH
34256: LD_INT 2
34258: NEG
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34285: NOP4
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: LD_INT 1
34305: NEG
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: PUSH
34314: LD_INT 0
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 1
34323: PUSH
34324: LD_INT 1
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 1
34343: NEG
34344: PUSH
34345: LD_INT 0
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: NEG
34355: PUSH
34356: LD_INT 1
34358: NEG
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 2
34370: NEG
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 0
34378: PUSH
34379: LD_INT 2
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 1
34392: NEG
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: LD_INT 0
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 2
34420: PUSH
34421: LD_INT 2
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: PUSH
34431: LD_INT 2
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 0
34440: PUSH
34441: LD_INT 2
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 1
34450: NEG
34451: PUSH
34452: LD_INT 1
34454: PUSH
34455: EMPTY
34456: LIST
34457: LIST
34458: PUSH
34459: LD_INT 2
34461: NEG
34462: PUSH
34463: LD_INT 0
34465: PUSH
34466: EMPTY
34467: LIST
34468: LIST
34469: PUSH
34470: LD_INT 2
34472: NEG
34473: PUSH
34474: LD_INT 1
34476: NEG
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 2
34484: NEG
34485: PUSH
34486: LD_INT 2
34488: NEG
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: LIST
34501: LIST
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: LIST
34507: LIST
34508: LIST
34509: LIST
34510: LIST
34511: LIST
34512: LIST
34513: LIST
34514: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34515: NOP4
34519: PUSH
34520: LD_INT 0
34522: PUSH
34523: LD_INT 0
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: LD_INT 1
34535: NEG
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 1
34543: PUSH
34544: LD_INT 0
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: PUSH
34551: LD_INT 1
34553: PUSH
34554: LD_INT 1
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 0
34563: PUSH
34564: LD_INT 1
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 1
34573: NEG
34574: PUSH
34575: LD_INT 0
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: LD_INT 1
34588: NEG
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: LD_INT 2
34600: NEG
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 0
34608: PUSH
34609: LD_INT 2
34611: NEG
34612: PUSH
34613: EMPTY
34614: LIST
34615: LIST
34616: PUSH
34617: LD_INT 1
34619: PUSH
34620: LD_INT 1
34622: NEG
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: LD_INT 0
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 2
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 2
34650: PUSH
34651: LD_INT 2
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: LD_INT 2
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: LD_INT 2
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 1
34680: NEG
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 2
34691: NEG
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 2
34702: NEG
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 2
34714: NEG
34715: PUSH
34716: LD_INT 2
34718: NEG
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34745: NOP4
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: LD_INT 0
34755: PUSH
34756: EMPTY
34757: LIST
34758: LIST
34759: PUSH
34760: LD_INT 0
34762: PUSH
34763: LD_INT 1
34765: NEG
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: PUSH
34774: LD_INT 0
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 1
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 0
34793: PUSH
34794: LD_INT 1
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: LD_INT 1
34803: NEG
34804: PUSH
34805: LD_INT 0
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 1
34814: NEG
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 1
34826: NEG
34827: PUSH
34828: LD_INT 2
34830: NEG
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 0
34838: PUSH
34839: LD_INT 2
34841: NEG
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 1
34849: PUSH
34850: LD_INT 1
34852: NEG
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: PUSH
34861: LD_INT 0
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 2
34870: PUSH
34871: LD_INT 1
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 2
34880: PUSH
34881: LD_INT 2
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: LD_INT 2
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PUSH
34898: LD_INT 0
34900: PUSH
34901: LD_INT 2
34903: PUSH
34904: EMPTY
34905: LIST
34906: LIST
34907: PUSH
34908: LD_INT 1
34910: NEG
34911: PUSH
34912: LD_INT 1
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: LD_INT 0
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 2
34932: NEG
34933: PUSH
34934: LD_INT 1
34936: NEG
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 2
34944: NEG
34945: PUSH
34946: LD_INT 2
34948: NEG
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: LIST
34973: LIST
34974: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34975: NOP4
34979: PUSH
34980: LD_INT 0
34982: PUSH
34983: LD_INT 0
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 0
34992: PUSH
34993: LD_INT 1
34995: NEG
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 1
35003: PUSH
35004: LD_INT 0
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 1
35013: PUSH
35014: LD_INT 1
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 0
35023: PUSH
35024: LD_INT 1
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: NEG
35034: PUSH
35035: LD_INT 0
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 1
35044: NEG
35045: PUSH
35046: LD_INT 1
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 1
35056: NEG
35057: PUSH
35058: LD_INT 2
35060: NEG
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 0
35068: PUSH
35069: LD_INT 2
35071: NEG
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: PUSH
35080: LD_INT 1
35082: NEG
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 2
35090: PUSH
35091: LD_INT 0
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 2
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 2
35110: PUSH
35111: LD_INT 2
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: PUSH
35121: LD_INT 2
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 0
35130: PUSH
35131: LD_INT 2
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 1
35140: NEG
35141: PUSH
35142: LD_INT 1
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 2
35151: NEG
35152: PUSH
35153: LD_INT 0
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 2
35162: NEG
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 2
35174: NEG
35175: PUSH
35176: LD_INT 2
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: LIST
35197: LIST
35198: LIST
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: LIST
35204: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35205: NOP4
35209: PUSH
35210: LD_INT 0
35212: PUSH
35213: LD_INT 0
35215: PUSH
35216: EMPTY
35217: LIST
35218: LIST
35219: PUSH
35220: LD_INT 0
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 1
35243: PUSH
35244: LD_INT 1
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 0
35253: PUSH
35254: LD_INT 1
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 1
35263: NEG
35264: PUSH
35265: LD_INT 0
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: LD_INT 1
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: EMPTY
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35293: NOP4
35297: PUSH
35298: LD_INT 0
35300: PUSH
35301: LD_INT 0
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 0
35310: PUSH
35311: LD_INT 1
35313: NEG
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: PUSH
35319: LD_INT 1
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: LD_INT 1
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 0
35341: PUSH
35342: LD_INT 1
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 1
35351: NEG
35352: PUSH
35353: LD_INT 0
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 1
35362: NEG
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: LIST
35376: LIST
35377: LIST
35378: LIST
35379: LIST
35380: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35381: NOP4
35385: PUSH
35386: LD_INT 0
35388: PUSH
35389: LD_INT 0
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 0
35398: PUSH
35399: LD_INT 1
35401: NEG
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: LD_INT 1
35409: PUSH
35410: LD_INT 0
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PUSH
35417: LD_INT 1
35419: PUSH
35420: LD_INT 1
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: LD_INT 0
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 1
35439: NEG
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: NEG
35451: PUSH
35452: LD_INT 1
35454: NEG
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35469: NOP4
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: LD_INT 0
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 0
35486: PUSH
35487: LD_INT 1
35489: NEG
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 1
35497: PUSH
35498: LD_INT 0
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 1
35507: PUSH
35508: LD_INT 1
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: LD_INT 1
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 0
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: PUSH
35536: LD_INT 1
35538: NEG
35539: PUSH
35540: LD_INT 1
35542: NEG
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: LIST
35552: LIST
35553: LIST
35554: LIST
35555: LIST
35556: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35557: NOP4
35561: PUSH
35562: LD_INT 0
35564: PUSH
35565: LD_INT 0
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 0
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: LD_INT 0
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 1
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 0
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 1
35615: NEG
35616: PUSH
35617: LD_INT 0
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 1
35626: NEG
35627: PUSH
35628: LD_INT 1
35630: NEG
35631: PUSH
35632: EMPTY
35633: LIST
35634: LIST
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35645: NOP4
35649: PUSH
35650: LD_INT 0
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: LD_INT 1
35665: NEG
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: PUSH
35674: LD_INT 0
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: LD_INT 1
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 1
35714: NEG
35715: PUSH
35716: LD_INT 1
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: ST_TO_ADDR
// end ; 1 :
35733: GO 41630
35735: LD_INT 1
35737: DOUBLE
35738: EQUAL
35739: IFTRUE 35743
35741: GO 38366
35743: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35744: NOP4
35748: PUSH
35749: LD_INT 1
35751: NEG
35752: PUSH
35753: LD_INT 3
35755: NEG
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: LD_INT 3
35766: NEG
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: PUSH
35775: LD_INT 2
35777: NEG
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: LIST
35787: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35788: NOP4
35792: PUSH
35793: LD_INT 2
35795: PUSH
35796: LD_INT 1
35798: NEG
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 3
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 3
35816: PUSH
35817: LD_INT 1
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: LIST
35828: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35829: NOP4
35833: PUSH
35834: LD_INT 3
35836: PUSH
35837: LD_INT 2
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 3
35846: PUSH
35847: LD_INT 3
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 2
35856: PUSH
35857: LD_INT 3
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: LIST
35868: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35869: NOP4
35873: PUSH
35874: LD_INT 1
35876: PUSH
35877: LD_INT 3
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 0
35886: PUSH
35887: LD_INT 3
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 1
35896: NEG
35897: PUSH
35898: LD_INT 2
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: LIST
35909: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35910: NOP4
35914: PUSH
35915: LD_INT 2
35917: NEG
35918: PUSH
35919: LD_INT 1
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 3
35928: NEG
35929: PUSH
35930: LD_INT 0
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 3
35939: NEG
35940: PUSH
35941: LD_INT 1
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: LIST
35953: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35954: NOP4
35958: PUSH
35959: LD_INT 2
35961: NEG
35962: PUSH
35963: LD_INT 3
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 3
35973: NEG
35974: PUSH
35975: LD_INT 2
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 3
35985: NEG
35986: PUSH
35987: LD_INT 3
35989: NEG
35990: PUSH
35991: EMPTY
35992: LIST
35993: LIST
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: LIST
35999: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36000: NOP4
36004: PUSH
36005: LD_INT 1
36007: NEG
36008: PUSH
36009: LD_INT 3
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 0
36019: PUSH
36020: LD_INT 3
36022: NEG
36023: PUSH
36024: EMPTY
36025: LIST
36026: LIST
36027: PUSH
36028: LD_INT 1
36030: PUSH
36031: LD_INT 2
36033: NEG
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: LIST
36043: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36044: NOP4
36048: PUSH
36049: LD_INT 2
36051: PUSH
36052: LD_INT 1
36054: NEG
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 3
36062: PUSH
36063: LD_INT 0
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 3
36072: PUSH
36073: LD_INT 1
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: LIST
36084: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36085: NOP4
36089: PUSH
36090: LD_INT 3
36092: PUSH
36093: LD_INT 2
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: PUSH
36100: LD_INT 3
36102: PUSH
36103: LD_INT 3
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: LD_INT 2
36112: PUSH
36113: LD_INT 3
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: LIST
36124: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36125: NOP4
36129: PUSH
36130: LD_INT 1
36132: PUSH
36133: LD_INT 3
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 0
36142: PUSH
36143: LD_INT 3
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 1
36152: NEG
36153: PUSH
36154: LD_INT 2
36156: PUSH
36157: EMPTY
36158: LIST
36159: LIST
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: LIST
36165: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36166: NOP4
36170: PUSH
36171: LD_INT 2
36173: NEG
36174: PUSH
36175: LD_INT 1
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 3
36184: NEG
36185: PUSH
36186: LD_INT 0
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 3
36195: NEG
36196: PUSH
36197: LD_INT 1
36199: NEG
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: LIST
36209: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36210: NOP4
36214: PUSH
36215: LD_INT 2
36217: NEG
36218: PUSH
36219: LD_INT 3
36221: NEG
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 3
36229: NEG
36230: PUSH
36231: LD_INT 2
36233: NEG
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 3
36241: NEG
36242: PUSH
36243: LD_INT 3
36245: NEG
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: LIST
36255: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36256: NOP4
36260: PUSH
36261: LD_INT 0
36263: PUSH
36264: LD_INT 3
36266: NEG
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: LD_INT 1
36274: NEG
36275: PUSH
36276: LD_INT 4
36278: NEG
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 1
36286: PUSH
36287: LD_INT 3
36289: NEG
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: LIST
36299: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36300: NOP4
36304: PUSH
36305: LD_INT 3
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 3
36317: PUSH
36318: LD_INT 1
36320: NEG
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: PUSH
36326: LD_INT 4
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: LIST
36340: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36341: NOP4
36345: PUSH
36346: LD_INT 3
36348: PUSH
36349: LD_INT 3
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 4
36358: PUSH
36359: LD_INT 3
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 3
36368: PUSH
36369: LD_INT 4
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: LIST
36380: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36381: NOP4
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: LD_INT 3
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 1
36398: PUSH
36399: LD_INT 4
36401: PUSH
36402: EMPTY
36403: LIST
36404: LIST
36405: PUSH
36406: LD_INT 1
36408: NEG
36409: PUSH
36410: LD_INT 3
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: LIST
36421: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36422: NOP4
36426: PUSH
36427: LD_INT 3
36429: NEG
36430: PUSH
36431: LD_INT 0
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 3
36440: NEG
36441: PUSH
36442: LD_INT 1
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 4
36451: NEG
36452: PUSH
36453: LD_INT 1
36455: NEG
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: LIST
36465: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36466: NOP4
36470: PUSH
36471: LD_INT 3
36473: NEG
36474: PUSH
36475: LD_INT 3
36477: NEG
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 3
36485: NEG
36486: PUSH
36487: LD_INT 4
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 4
36497: NEG
36498: PUSH
36499: LD_INT 3
36501: NEG
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: LIST
36511: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36512: NOP4
36516: PUSH
36517: LD_INT 1
36519: NEG
36520: PUSH
36521: LD_INT 3
36523: NEG
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: LD_INT 3
36534: NEG
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 1
36542: PUSH
36543: LD_INT 2
36545: NEG
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 1
36553: NEG
36554: PUSH
36555: LD_INT 4
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: LD_INT 4
36568: NEG
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 1
36576: PUSH
36577: LD_INT 3
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 1
36587: NEG
36588: PUSH
36589: LD_INT 5
36591: NEG
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 0
36599: PUSH
36600: LD_INT 5
36602: NEG
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: LD_INT 4
36613: NEG
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 1
36621: NEG
36622: PUSH
36623: LD_INT 6
36625: NEG
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 0
36633: PUSH
36634: LD_INT 6
36636: NEG
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 1
36644: PUSH
36645: LD_INT 5
36647: NEG
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: EMPTY
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36667: NOP4
36671: PUSH
36672: LD_INT 2
36674: PUSH
36675: LD_INT 1
36677: NEG
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 3
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 3
36695: PUSH
36696: LD_INT 1
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 3
36705: PUSH
36706: LD_INT 1
36708: NEG
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 4
36716: PUSH
36717: LD_INT 0
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 4
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 4
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 5
36747: PUSH
36748: LD_INT 0
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 5
36757: PUSH
36758: LD_INT 1
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 5
36767: PUSH
36768: LD_INT 1
36770: NEG
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 6
36778: PUSH
36779: LD_INT 0
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 6
36788: PUSH
36789: LD_INT 1
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: LIST
36804: LIST
36805: LIST
36806: LIST
36807: LIST
36808: LIST
36809: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36810: NOP4
36814: PUSH
36815: LD_INT 3
36817: PUSH
36818: LD_INT 2
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 3
36827: PUSH
36828: LD_INT 3
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 2
36837: PUSH
36838: LD_INT 3
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 4
36847: PUSH
36848: LD_INT 3
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 4
36857: PUSH
36858: LD_INT 4
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 3
36867: PUSH
36868: LD_INT 4
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 5
36877: PUSH
36878: LD_INT 4
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 5
36887: PUSH
36888: LD_INT 5
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 4
36897: PUSH
36898: LD_INT 5
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 6
36907: PUSH
36908: LD_INT 5
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 6
36917: PUSH
36918: LD_INT 6
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 5
36927: PUSH
36928: LD_INT 6
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: LIST
36948: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36949: NOP4
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: LD_INT 3
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PUSH
36964: LD_INT 0
36966: PUSH
36967: LD_INT 3
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 1
36976: NEG
36977: PUSH
36978: LD_INT 2
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: PUSH
36988: LD_INT 4
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 0
36997: PUSH
36998: LD_INT 4
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 1
37007: NEG
37008: PUSH
37009: LD_INT 3
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: LD_INT 5
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: LD_INT 0
37028: PUSH
37029: LD_INT 5
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 1
37038: NEG
37039: PUSH
37040: LD_INT 4
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 1
37049: PUSH
37050: LD_INT 6
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 0
37059: PUSH
37060: LD_INT 6
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 1
37069: NEG
37070: PUSH
37071: LD_INT 5
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: LIST
37091: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37092: NOP4
37096: PUSH
37097: LD_INT 2
37099: NEG
37100: PUSH
37101: LD_INT 1
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 3
37110: NEG
37111: PUSH
37112: LD_INT 0
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 3
37121: NEG
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 3
37133: NEG
37134: PUSH
37135: LD_INT 1
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PUSH
37142: LD_INT 4
37144: NEG
37145: PUSH
37146: LD_INT 0
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: LD_INT 4
37155: NEG
37156: PUSH
37157: LD_INT 1
37159: NEG
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: PUSH
37165: LD_INT 4
37167: NEG
37168: PUSH
37169: LD_INT 1
37171: PUSH
37172: EMPTY
37173: LIST
37174: LIST
37175: PUSH
37176: LD_INT 5
37178: NEG
37179: PUSH
37180: LD_INT 0
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: LD_INT 5
37189: NEG
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: LD_INT 5
37201: NEG
37202: PUSH
37203: LD_INT 1
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 6
37212: NEG
37213: PUSH
37214: LD_INT 0
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: LD_INT 6
37223: NEG
37224: PUSH
37225: LD_INT 1
37227: NEG
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: LIST
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: LIST
37245: LIST
37246: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37247: NOP4
37251: PUSH
37252: LD_INT 2
37254: NEG
37255: PUSH
37256: LD_INT 3
37258: NEG
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: PUSH
37264: LD_INT 3
37266: NEG
37267: PUSH
37268: LD_INT 2
37270: NEG
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 3
37278: NEG
37279: PUSH
37280: LD_INT 3
37282: NEG
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 3
37290: NEG
37291: PUSH
37292: LD_INT 4
37294: NEG
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 4
37302: NEG
37303: PUSH
37304: LD_INT 3
37306: NEG
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 4
37314: NEG
37315: PUSH
37316: LD_INT 4
37318: NEG
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 4
37326: NEG
37327: PUSH
37328: LD_INT 5
37330: NEG
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: LD_INT 5
37338: NEG
37339: PUSH
37340: LD_INT 4
37342: NEG
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: PUSH
37348: LD_INT 5
37350: NEG
37351: PUSH
37352: LD_INT 5
37354: NEG
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: LD_INT 5
37362: NEG
37363: PUSH
37364: LD_INT 6
37366: NEG
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 6
37374: NEG
37375: PUSH
37376: LD_INT 5
37378: NEG
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 6
37386: NEG
37387: PUSH
37388: LD_INT 6
37390: NEG
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37410: NOP4
37414: PUSH
37415: LD_INT 0
37417: PUSH
37418: LD_INT 2
37420: NEG
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 1
37428: NEG
37429: PUSH
37430: LD_INT 3
37432: NEG
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 1
37440: PUSH
37441: LD_INT 2
37443: NEG
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: LIST
37453: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37454: NOP4
37458: PUSH
37459: LD_INT 2
37461: PUSH
37462: LD_INT 0
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 2
37471: PUSH
37472: LD_INT 1
37474: NEG
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 3
37482: PUSH
37483: LD_INT 1
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: LIST
37494: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37495: NOP4
37499: PUSH
37500: LD_INT 2
37502: PUSH
37503: LD_INT 2
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 3
37512: PUSH
37513: LD_INT 2
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 2
37522: PUSH
37523: LD_INT 3
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: LIST
37534: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37535: NOP4
37539: PUSH
37540: LD_INT 0
37542: PUSH
37543: LD_INT 2
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 1
37552: PUSH
37553: LD_INT 3
37555: PUSH
37556: EMPTY
37557: LIST
37558: LIST
37559: PUSH
37560: LD_INT 1
37562: NEG
37563: PUSH
37564: LD_INT 2
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: LIST
37575: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37576: NOP4
37580: PUSH
37581: LD_INT 2
37583: NEG
37584: PUSH
37585: LD_INT 0
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 2
37594: NEG
37595: PUSH
37596: LD_INT 1
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: PUSH
37603: LD_INT 3
37605: NEG
37606: PUSH
37607: LD_INT 1
37609: NEG
37610: PUSH
37611: EMPTY
37612: LIST
37613: LIST
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: LIST
37619: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37620: NOP4
37624: PUSH
37625: LD_INT 2
37627: NEG
37628: PUSH
37629: LD_INT 2
37631: NEG
37632: PUSH
37633: EMPTY
37634: LIST
37635: LIST
37636: PUSH
37637: LD_INT 2
37639: NEG
37640: PUSH
37641: LD_INT 3
37643: NEG
37644: PUSH
37645: EMPTY
37646: LIST
37647: LIST
37648: PUSH
37649: LD_INT 3
37651: NEG
37652: PUSH
37653: LD_INT 2
37655: NEG
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: LIST
37665: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37666: NOP4
37670: PUSH
37671: LD_INT 2
37673: NEG
37674: PUSH
37675: LD_INT 3
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 1
37685: NEG
37686: PUSH
37687: LD_INT 3
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37699: NOP4
37703: PUSH
37704: LD_INT 1
37706: PUSH
37707: LD_INT 2
37709: NEG
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PUSH
37715: LD_INT 2
37717: PUSH
37718: LD_INT 1
37720: NEG
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37730: NOP4
37734: PUSH
37735: LD_INT 3
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 3
37747: PUSH
37748: LD_INT 2
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37759: NOP4
37763: PUSH
37764: LD_INT 2
37766: PUSH
37767: LD_INT 3
37769: PUSH
37770: EMPTY
37771: LIST
37772: LIST
37773: PUSH
37774: LD_INT 1
37776: PUSH
37777: LD_INT 3
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37788: NOP4
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: LD_INT 2
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 2
37806: NEG
37807: PUSH
37808: LD_INT 1
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37819: NOP4
37823: PUSH
37824: LD_INT 3
37826: NEG
37827: PUSH
37828: LD_INT 1
37830: NEG
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 3
37838: NEG
37839: PUSH
37840: LD_INT 2
37842: NEG
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: EMPTY
37849: LIST
37850: LIST
37851: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37852: NOP4
37856: PUSH
37857: LD_INT 1
37859: NEG
37860: PUSH
37861: LD_INT 3
37863: NEG
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 0
37871: PUSH
37872: LD_INT 3
37874: NEG
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 1
37882: PUSH
37883: LD_INT 2
37885: NEG
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: LIST
37895: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37896: NOP4
37900: PUSH
37901: LD_INT 2
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 3
37914: PUSH
37915: LD_INT 0
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 3
37924: PUSH
37925: LD_INT 1
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: LIST
37936: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37937: NOP4
37941: PUSH
37942: LD_INT 3
37944: PUSH
37945: LD_INT 2
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 3
37954: PUSH
37955: LD_INT 3
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 2
37964: PUSH
37965: LD_INT 3
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: LIST
37976: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37977: NOP4
37981: PUSH
37982: LD_INT 1
37984: PUSH
37985: LD_INT 3
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 0
37994: PUSH
37995: LD_INT 3
37997: PUSH
37998: EMPTY
37999: LIST
38000: LIST
38001: PUSH
38002: LD_INT 1
38004: NEG
38005: PUSH
38006: LD_INT 2
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: LIST
38017: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38018: NOP4
38022: PUSH
38023: LD_INT 2
38025: NEG
38026: PUSH
38027: LD_INT 1
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: LD_INT 3
38036: NEG
38037: PUSH
38038: LD_INT 0
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 3
38047: NEG
38048: PUSH
38049: LD_INT 1
38051: NEG
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: LIST
38061: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38062: NOP4
38066: PUSH
38067: LD_INT 2
38069: NEG
38070: PUSH
38071: LD_INT 3
38073: NEG
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 3
38081: NEG
38082: PUSH
38083: LD_INT 2
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 3
38093: NEG
38094: PUSH
38095: LD_INT 3
38097: NEG
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: LIST
38107: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38108: NOP4
38112: PUSH
38113: LD_INT 1
38115: NEG
38116: PUSH
38117: LD_INT 2
38119: NEG
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 0
38127: PUSH
38128: LD_INT 2
38130: NEG
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: PUSH
38139: LD_INT 1
38141: NEG
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: LIST
38151: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38152: NOP4
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: LD_INT 1
38162: NEG
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 2
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 2
38180: PUSH
38181: LD_INT 1
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: LIST
38192: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38193: NOP4
38197: PUSH
38198: LD_INT 2
38200: PUSH
38201: LD_INT 1
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 2
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: PUSH
38221: LD_INT 2
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: LIST
38232: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38233: NOP4
38237: PUSH
38238: LD_INT 1
38240: PUSH
38241: LD_INT 2
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: LD_INT 2
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: LD_INT 1
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: LIST
38273: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38274: NOP4
38278: PUSH
38279: LD_INT 1
38281: NEG
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 2
38292: NEG
38293: PUSH
38294: LD_INT 0
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 2
38303: NEG
38304: PUSH
38305: LD_INT 1
38307: NEG
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: LIST
38317: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38318: NOP4
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: LD_INT 2
38329: NEG
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 2
38337: NEG
38338: PUSH
38339: LD_INT 1
38341: NEG
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 2
38349: NEG
38350: PUSH
38351: LD_INT 2
38353: NEG
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: LIST
38363: ST_TO_ADDR
// end ; 2 :
38364: GO 41630
38366: LD_INT 2
38368: DOUBLE
38369: EQUAL
38370: IFTRUE 38374
38372: GO 41629
38374: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38375: NOP4
38379: PUSH
38380: LD_INT 4
38382: PUSH
38383: LD_INT 0
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 4
38392: PUSH
38393: LD_INT 1
38395: NEG
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 5
38403: PUSH
38404: LD_INT 0
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: LD_INT 5
38413: PUSH
38414: LD_INT 1
38416: PUSH
38417: EMPTY
38418: LIST
38419: LIST
38420: PUSH
38421: LD_INT 4
38423: PUSH
38424: LD_INT 1
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 3
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 3
38443: PUSH
38444: LD_INT 1
38446: NEG
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 3
38454: PUSH
38455: LD_INT 2
38457: NEG
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 5
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 3
38475: PUSH
38476: LD_INT 3
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 3
38485: PUSH
38486: LD_INT 2
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 4
38495: PUSH
38496: LD_INT 3
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 4
38505: PUSH
38506: LD_INT 4
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 3
38515: PUSH
38516: LD_INT 4
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 2
38525: PUSH
38526: LD_INT 3
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 2
38535: PUSH
38536: LD_INT 2
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 4
38545: PUSH
38546: LD_INT 2
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 2
38555: PUSH
38556: LD_INT 4
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: LD_INT 0
38565: PUSH
38566: LD_INT 4
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PUSH
38573: LD_INT 0
38575: PUSH
38576: LD_INT 3
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 1
38585: PUSH
38586: LD_INT 4
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 1
38595: PUSH
38596: LD_INT 5
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 0
38605: PUSH
38606: LD_INT 5
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: PUSH
38613: LD_INT 1
38615: NEG
38616: PUSH
38617: LD_INT 4
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 1
38626: NEG
38627: PUSH
38628: LD_INT 3
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 2
38637: PUSH
38638: LD_INT 5
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 2
38647: NEG
38648: PUSH
38649: LD_INT 3
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 3
38658: NEG
38659: PUSH
38660: LD_INT 0
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 3
38669: NEG
38670: PUSH
38671: LD_INT 1
38673: NEG
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 2
38681: NEG
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 2
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PUSH
38701: LD_INT 3
38703: NEG
38704: PUSH
38705: LD_INT 1
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 4
38714: NEG
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: LD_INT 4
38725: NEG
38726: PUSH
38727: LD_INT 1
38729: NEG
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 4
38737: NEG
38738: PUSH
38739: LD_INT 2
38741: NEG
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 2
38749: NEG
38750: PUSH
38751: LD_INT 2
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 4
38760: NEG
38761: PUSH
38762: LD_INT 4
38764: NEG
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 4
38772: NEG
38773: PUSH
38774: LD_INT 5
38776: NEG
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 3
38784: NEG
38785: PUSH
38786: LD_INT 4
38788: NEG
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 3
38796: NEG
38797: PUSH
38798: LD_INT 3
38800: NEG
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 4
38808: NEG
38809: PUSH
38810: LD_INT 3
38812: NEG
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 5
38820: NEG
38821: PUSH
38822: LD_INT 4
38824: NEG
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 5
38832: NEG
38833: PUSH
38834: LD_INT 5
38836: NEG
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 3
38844: NEG
38845: PUSH
38846: LD_INT 5
38848: NEG
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 5
38856: NEG
38857: PUSH
38858: LD_INT 3
38860: NEG
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: LIST
38907: LIST
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38913: NOP4
38917: PUSH
38918: LD_INT 4
38920: PUSH
38921: LD_INT 4
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 4
38930: PUSH
38931: LD_INT 3
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 5
38940: PUSH
38941: LD_INT 4
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 5
38950: PUSH
38951: LD_INT 5
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 4
38960: PUSH
38961: LD_INT 5
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 3
38970: PUSH
38971: LD_INT 4
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 3
38980: PUSH
38981: LD_INT 3
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 5
38990: PUSH
38991: LD_INT 3
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 3
39000: PUSH
39001: LD_INT 5
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: LD_INT 3
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 0
39020: PUSH
39021: LD_INT 2
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: LD_INT 3
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 1
39040: PUSH
39041: LD_INT 4
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: LD_INT 0
39050: PUSH
39051: LD_INT 4
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: LD_INT 3
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 1
39071: NEG
39072: PUSH
39073: LD_INT 2
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PUSH
39080: LD_INT 2
39082: PUSH
39083: LD_INT 4
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: LD_INT 2
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 4
39103: NEG
39104: PUSH
39105: LD_INT 0
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 4
39114: NEG
39115: PUSH
39116: LD_INT 1
39118: NEG
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 3
39126: NEG
39127: PUSH
39128: LD_INT 0
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 3
39137: NEG
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 4
39148: NEG
39149: PUSH
39150: LD_INT 1
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 5
39159: NEG
39160: PUSH
39161: LD_INT 0
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 5
39170: NEG
39171: PUSH
39172: LD_INT 1
39174: NEG
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 5
39182: NEG
39183: PUSH
39184: LD_INT 2
39186: NEG
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 3
39194: NEG
39195: PUSH
39196: LD_INT 2
39198: PUSH
39199: EMPTY
39200: LIST
39201: LIST
39202: PUSH
39203: LD_INT 3
39205: NEG
39206: PUSH
39207: LD_INT 3
39209: NEG
39210: PUSH
39211: EMPTY
39212: LIST
39213: LIST
39214: PUSH
39215: LD_INT 3
39217: NEG
39218: PUSH
39219: LD_INT 4
39221: NEG
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PUSH
39227: LD_INT 2
39229: NEG
39230: PUSH
39231: LD_INT 3
39233: NEG
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 2
39241: NEG
39242: PUSH
39243: LD_INT 2
39245: NEG
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 3
39253: NEG
39254: PUSH
39255: LD_INT 2
39257: NEG
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: LD_INT 4
39265: NEG
39266: PUSH
39267: LD_INT 3
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 4
39277: NEG
39278: PUSH
39279: LD_INT 4
39281: NEG
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 2
39289: NEG
39290: PUSH
39291: LD_INT 4
39293: NEG
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 4
39301: NEG
39302: PUSH
39303: LD_INT 2
39305: NEG
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: PUSH
39311: LD_INT 0
39313: PUSH
39314: LD_INT 4
39316: NEG
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 0
39324: PUSH
39325: LD_INT 5
39327: NEG
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: PUSH
39336: LD_INT 4
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 1
39346: PUSH
39347: LD_INT 3
39349: NEG
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 0
39357: PUSH
39358: LD_INT 3
39360: NEG
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 1
39368: NEG
39369: PUSH
39370: LD_INT 4
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: NEG
39381: PUSH
39382: LD_INT 5
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 2
39392: PUSH
39393: LD_INT 3
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 2
39403: NEG
39404: PUSH
39405: LD_INT 5
39407: NEG
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: LIST
39422: LIST
39423: LIST
39424: LIST
39425: LIST
39426: LIST
39427: LIST
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: LIST
39438: LIST
39439: LIST
39440: LIST
39441: LIST
39442: LIST
39443: LIST
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: LIST
39459: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39460: NOP4
39464: PUSH
39465: LD_INT 0
39467: PUSH
39468: LD_INT 4
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: LD_INT 0
39477: PUSH
39478: LD_INT 3
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: LD_INT 1
39487: PUSH
39488: LD_INT 4
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 1
39497: PUSH
39498: LD_INT 5
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 0
39507: PUSH
39508: LD_INT 5
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 1
39517: NEG
39518: PUSH
39519: LD_INT 4
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 1
39528: NEG
39529: PUSH
39530: LD_INT 3
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: PUSH
39537: LD_INT 2
39539: PUSH
39540: LD_INT 5
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: LD_INT 2
39549: NEG
39550: PUSH
39551: LD_INT 3
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: LD_INT 3
39560: NEG
39561: PUSH
39562: LD_INT 0
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 3
39571: NEG
39572: PUSH
39573: LD_INT 1
39575: NEG
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 2
39583: NEG
39584: PUSH
39585: LD_INT 0
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 2
39594: NEG
39595: PUSH
39596: LD_INT 1
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 3
39605: NEG
39606: PUSH
39607: LD_INT 1
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 4
39616: NEG
39617: PUSH
39618: LD_INT 0
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 4
39627: NEG
39628: PUSH
39629: LD_INT 1
39631: NEG
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 4
39639: NEG
39640: PUSH
39641: LD_INT 2
39643: NEG
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 2
39651: NEG
39652: PUSH
39653: LD_INT 2
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: LD_INT 4
39662: NEG
39663: PUSH
39664: LD_INT 4
39666: NEG
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 4
39674: NEG
39675: PUSH
39676: LD_INT 5
39678: NEG
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 3
39686: NEG
39687: PUSH
39688: LD_INT 4
39690: NEG
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 3
39698: NEG
39699: PUSH
39700: LD_INT 3
39702: NEG
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 4
39710: NEG
39711: PUSH
39712: LD_INT 3
39714: NEG
39715: PUSH
39716: EMPTY
39717: LIST
39718: LIST
39719: PUSH
39720: LD_INT 5
39722: NEG
39723: PUSH
39724: LD_INT 4
39726: NEG
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 5
39734: NEG
39735: PUSH
39736: LD_INT 5
39738: NEG
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: LD_INT 3
39746: NEG
39747: PUSH
39748: LD_INT 5
39750: NEG
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 5
39758: NEG
39759: PUSH
39760: LD_INT 3
39762: NEG
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 0
39770: PUSH
39771: LD_INT 3
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 0
39781: PUSH
39782: LD_INT 4
39784: NEG
39785: PUSH
39786: EMPTY
39787: LIST
39788: LIST
39789: PUSH
39790: LD_INT 1
39792: PUSH
39793: LD_INT 3
39795: NEG
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 1
39803: PUSH
39804: LD_INT 2
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 0
39814: PUSH
39815: LD_INT 2
39817: NEG
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: LD_INT 1
39825: NEG
39826: PUSH
39827: LD_INT 3
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 1
39837: NEG
39838: PUSH
39839: LD_INT 4
39841: NEG
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 2
39849: PUSH
39850: LD_INT 2
39852: NEG
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: LD_INT 2
39860: NEG
39861: PUSH
39862: LD_INT 4
39864: NEG
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: PUSH
39870: LD_INT 4
39872: PUSH
39873: LD_INT 0
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: LD_INT 4
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 5
39893: PUSH
39894: LD_INT 0
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 5
39903: PUSH
39904: LD_INT 1
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: PUSH
39911: LD_INT 4
39913: PUSH
39914: LD_INT 1
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 3
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 3
39933: PUSH
39934: LD_INT 1
39936: NEG
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 3
39944: PUSH
39945: LD_INT 2
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 5
39955: PUSH
39956: LD_INT 2
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
40010: NOP4
40014: PUSH
40015: LD_INT 4
40017: NEG
40018: PUSH
40019: LD_INT 0
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 4
40028: NEG
40029: PUSH
40030: LD_INT 1
40032: NEG
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 3
40040: NEG
40041: PUSH
40042: LD_INT 0
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 3
40051: NEG
40052: PUSH
40053: LD_INT 1
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 4
40062: NEG
40063: PUSH
40064: LD_INT 1
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 5
40073: NEG
40074: PUSH
40075: LD_INT 0
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 5
40084: NEG
40085: PUSH
40086: LD_INT 1
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 5
40096: NEG
40097: PUSH
40098: LD_INT 2
40100: NEG
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 3
40108: NEG
40109: PUSH
40110: LD_INT 2
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: LD_INT 3
40119: NEG
40120: PUSH
40121: LD_INT 3
40123: NEG
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 3
40131: NEG
40132: PUSH
40133: LD_INT 4
40135: NEG
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 2
40143: NEG
40144: PUSH
40145: LD_INT 3
40147: NEG
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 2
40155: NEG
40156: PUSH
40157: LD_INT 2
40159: NEG
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PUSH
40165: LD_INT 3
40167: NEG
40168: PUSH
40169: LD_INT 2
40171: NEG
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 4
40179: NEG
40180: PUSH
40181: LD_INT 3
40183: NEG
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 4
40191: NEG
40192: PUSH
40193: LD_INT 4
40195: NEG
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: LD_INT 2
40203: NEG
40204: PUSH
40205: LD_INT 4
40207: NEG
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 4
40215: NEG
40216: PUSH
40217: LD_INT 2
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 0
40227: PUSH
40228: LD_INT 4
40230: NEG
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 0
40238: PUSH
40239: LD_INT 5
40241: NEG
40242: PUSH
40243: EMPTY
40244: LIST
40245: LIST
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: LD_INT 4
40252: NEG
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: LD_INT 1
40260: PUSH
40261: LD_INT 3
40263: NEG
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 0
40271: PUSH
40272: LD_INT 3
40274: NEG
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 1
40282: NEG
40283: PUSH
40284: LD_INT 4
40286: NEG
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: LD_INT 1
40294: NEG
40295: PUSH
40296: LD_INT 5
40298: NEG
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: LD_INT 2
40306: PUSH
40307: LD_INT 3
40309: NEG
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 2
40317: NEG
40318: PUSH
40319: LD_INT 5
40321: NEG
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 3
40329: PUSH
40330: LD_INT 0
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 3
40339: PUSH
40340: LD_INT 1
40342: NEG
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 4
40350: PUSH
40351: LD_INT 0
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: LD_INT 4
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 3
40370: PUSH
40371: LD_INT 1
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: LD_INT 2
40380: PUSH
40381: LD_INT 0
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: PUSH
40388: LD_INT 2
40390: PUSH
40391: LD_INT 1
40393: NEG
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: LD_INT 2
40401: PUSH
40402: LD_INT 2
40404: NEG
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 4
40412: PUSH
40413: LD_INT 2
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 4
40422: PUSH
40423: LD_INT 4
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 4
40432: PUSH
40433: LD_INT 3
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 5
40442: PUSH
40443: LD_INT 4
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 5
40452: PUSH
40453: LD_INT 5
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 4
40462: PUSH
40463: LD_INT 5
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 3
40472: PUSH
40473: LD_INT 4
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 3
40482: PUSH
40483: LD_INT 3
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 5
40492: PUSH
40493: LD_INT 3
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 3
40502: PUSH
40503: LD_INT 5
40505: PUSH
40506: EMPTY
40507: LIST
40508: LIST
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: LIST
40514: LIST
40515: LIST
40516: LIST
40517: LIST
40518: LIST
40519: LIST
40520: LIST
40521: LIST
40522: LIST
40523: LIST
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40557: NOP4
40561: PUSH
40562: LD_INT 4
40564: NEG
40565: PUSH
40566: LD_INT 4
40568: NEG
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 4
40576: NEG
40577: PUSH
40578: LD_INT 5
40580: NEG
40581: PUSH
40582: EMPTY
40583: LIST
40584: LIST
40585: PUSH
40586: LD_INT 3
40588: NEG
40589: PUSH
40590: LD_INT 4
40592: NEG
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: PUSH
40598: LD_INT 3
40600: NEG
40601: PUSH
40602: LD_INT 3
40604: NEG
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 4
40612: NEG
40613: PUSH
40614: LD_INT 3
40616: NEG
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 5
40624: NEG
40625: PUSH
40626: LD_INT 4
40628: NEG
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 5
40636: NEG
40637: PUSH
40638: LD_INT 5
40640: NEG
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 3
40648: NEG
40649: PUSH
40650: LD_INT 5
40652: NEG
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 5
40660: NEG
40661: PUSH
40662: LD_INT 3
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 0
40672: PUSH
40673: LD_INT 3
40675: NEG
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 0
40683: PUSH
40684: LD_INT 4
40686: NEG
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 1
40694: PUSH
40695: LD_INT 3
40697: NEG
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 1
40705: PUSH
40706: LD_INT 2
40708: NEG
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 0
40716: PUSH
40717: LD_INT 2
40719: NEG
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 3
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: NEG
40740: PUSH
40741: LD_INT 4
40743: NEG
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: LD_INT 2
40751: PUSH
40752: LD_INT 2
40754: NEG
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 2
40762: NEG
40763: PUSH
40764: LD_INT 4
40766: NEG
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 4
40774: PUSH
40775: LD_INT 0
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 4
40784: PUSH
40785: LD_INT 1
40787: NEG
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 5
40795: PUSH
40796: LD_INT 0
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 5
40805: PUSH
40806: LD_INT 1
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 4
40815: PUSH
40816: LD_INT 1
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 3
40825: PUSH
40826: LD_INT 0
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 3
40835: PUSH
40836: LD_INT 1
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 3
40846: PUSH
40847: LD_INT 2
40849: NEG
40850: PUSH
40851: EMPTY
40852: LIST
40853: LIST
40854: PUSH
40855: LD_INT 5
40857: PUSH
40858: LD_INT 2
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 3
40867: PUSH
40868: LD_INT 3
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 3
40877: PUSH
40878: LD_INT 2
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 4
40887: PUSH
40888: LD_INT 3
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: LD_INT 4
40897: PUSH
40898: LD_INT 4
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 3
40907: PUSH
40908: LD_INT 4
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 2
40917: PUSH
40918: LD_INT 3
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 2
40927: PUSH
40928: LD_INT 2
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 4
40937: PUSH
40938: LD_INT 2
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 2
40947: PUSH
40948: LD_INT 4
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: LD_INT 4
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: LD_INT 0
40967: PUSH
40968: LD_INT 3
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 1
40977: PUSH
40978: LD_INT 4
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 1
40987: PUSH
40988: LD_INT 5
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: LD_INT 0
40997: PUSH
40998: LD_INT 5
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: LD_INT 1
41007: NEG
41008: PUSH
41009: LD_INT 4
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 1
41018: NEG
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 2
41029: PUSH
41030: LD_INT 5
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 2
41039: NEG
41040: PUSH
41041: LD_INT 3
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: LIST
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41095: NOP4
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: LD_INT 4
41105: NEG
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 0
41113: PUSH
41114: LD_INT 5
41116: NEG
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PUSH
41122: LD_INT 1
41124: PUSH
41125: LD_INT 4
41127: NEG
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: PUSH
41133: LD_INT 1
41135: PUSH
41136: LD_INT 3
41138: NEG
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 0
41146: PUSH
41147: LD_INT 3
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: LD_INT 1
41157: NEG
41158: PUSH
41159: LD_INT 4
41161: NEG
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 1
41169: NEG
41170: PUSH
41171: LD_INT 5
41173: NEG
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: PUSH
41179: LD_INT 2
41181: PUSH
41182: LD_INT 3
41184: NEG
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 2
41192: NEG
41193: PUSH
41194: LD_INT 5
41196: NEG
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 3
41204: PUSH
41205: LD_INT 0
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 3
41214: PUSH
41215: LD_INT 1
41217: NEG
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 4
41225: PUSH
41226: LD_INT 0
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 4
41235: PUSH
41236: LD_INT 1
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 3
41245: PUSH
41246: LD_INT 1
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: LD_INT 2
41255: PUSH
41256: LD_INT 0
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: LD_INT 2
41265: PUSH
41266: LD_INT 1
41268: NEG
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 2
41276: PUSH
41277: LD_INT 2
41279: NEG
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 4
41287: PUSH
41288: LD_INT 2
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: LD_INT 4
41297: PUSH
41298: LD_INT 4
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: LD_INT 4
41307: PUSH
41308: LD_INT 3
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 5
41317: PUSH
41318: LD_INT 4
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 5
41327: PUSH
41328: LD_INT 5
41330: PUSH
41331: EMPTY
41332: LIST
41333: LIST
41334: PUSH
41335: LD_INT 4
41337: PUSH
41338: LD_INT 5
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 3
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: LD_INT 3
41357: PUSH
41358: LD_INT 3
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 5
41367: PUSH
41368: LD_INT 3
41370: PUSH
41371: EMPTY
41372: LIST
41373: LIST
41374: PUSH
41375: LD_INT 3
41377: PUSH
41378: LD_INT 5
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: LD_INT 3
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 0
41397: PUSH
41398: LD_INT 2
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: LD_INT 1
41407: PUSH
41408: LD_INT 3
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 1
41417: PUSH
41418: LD_INT 4
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: LD_INT 0
41427: PUSH
41428: LD_INT 4
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: PUSH
41435: LD_INT 1
41437: NEG
41438: PUSH
41439: LD_INT 3
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: LD_INT 1
41448: NEG
41449: PUSH
41450: LD_INT 2
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 2
41459: PUSH
41460: LD_INT 4
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 2
41469: NEG
41470: PUSH
41471: LD_INT 2
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 4
41480: NEG
41481: PUSH
41482: LD_INT 0
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 4
41491: NEG
41492: PUSH
41493: LD_INT 1
41495: NEG
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PUSH
41501: LD_INT 3
41503: NEG
41504: PUSH
41505: LD_INT 0
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 3
41514: NEG
41515: PUSH
41516: LD_INT 1
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 4
41525: NEG
41526: PUSH
41527: LD_INT 1
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 5
41536: NEG
41537: PUSH
41538: LD_INT 0
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 5
41547: NEG
41548: PUSH
41549: LD_INT 1
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 5
41559: NEG
41560: PUSH
41561: LD_INT 2
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 3
41571: NEG
41572: PUSH
41573: LD_INT 2
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: LIST
41621: LIST
41622: LIST
41623: LIST
41624: LIST
41625: LIST
41626: ST_TO_ADDR
// end ; end ;
41627: GO 41630
41629: POP
// case btype of b_depot , b_warehouse :
41630: NOP4
41634: PUSH
41635: LD_INT 0
41637: DOUBLE
41638: EQUAL
41639: IFTRUE 41649
41641: LD_INT 1
41643: DOUBLE
41644: EQUAL
41645: IFTRUE 41649
41647: GO 41850
41649: POP
// case nation of nation_american :
41650: NOP4
41654: PUSH
41655: LD_INT 1
41657: DOUBLE
41658: EQUAL
41659: IFTRUE 41663
41661: GO 41719
41663: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41664: NOP4
41668: PUSH
41669: NOP4
41673: PUSH
41674: NOP4
41678: PUSH
41679: NOP4
41683: PUSH
41684: NOP4
41688: PUSH
41689: NOP4
41693: PUSH
41694: NOP4
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: LIST
41703: LIST
41704: LIST
41705: LIST
41706: PUSH
41707: NOP4
41711: PUSH
41712: LD_INT 1
41714: PLUS
41715: ARRAY
41716: ST_TO_ADDR
41717: GO 41848
41719: LD_INT 2
41721: DOUBLE
41722: EQUAL
41723: IFTRUE 41727
41725: GO 41783
41727: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41728: NOP4
41732: PUSH
41733: NOP4
41737: PUSH
41738: NOP4
41742: PUSH
41743: NOP4
41747: PUSH
41748: NOP4
41752: PUSH
41753: NOP4
41757: PUSH
41758: NOP4
41762: PUSH
41763: EMPTY
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: PUSH
41771: NOP4
41775: PUSH
41776: LD_INT 1
41778: PLUS
41779: ARRAY
41780: ST_TO_ADDR
41781: GO 41848
41783: LD_INT 3
41785: DOUBLE
41786: EQUAL
41787: IFTRUE 41791
41789: GO 41847
41791: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41792: NOP4
41796: PUSH
41797: NOP4
41801: PUSH
41802: NOP4
41806: PUSH
41807: NOP4
41811: PUSH
41812: NOP4
41816: PUSH
41817: NOP4
41821: PUSH
41822: NOP4
41826: PUSH
41827: EMPTY
41828: LIST
41829: LIST
41830: LIST
41831: LIST
41832: LIST
41833: LIST
41834: PUSH
41835: NOP4
41839: PUSH
41840: LD_INT 1
41842: PLUS
41843: ARRAY
41844: ST_TO_ADDR
41845: GO 41848
41847: POP
41848: GO 42403
41850: LD_INT 2
41852: DOUBLE
41853: EQUAL
41854: IFTRUE 41864
41856: LD_INT 3
41858: DOUBLE
41859: EQUAL
41860: IFTRUE 41864
41862: GO 41920
41864: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41865: NOP4
41869: PUSH
41870: NOP4
41874: PUSH
41875: NOP4
41879: PUSH
41880: NOP4
41884: PUSH
41885: NOP4
41889: PUSH
41890: NOP4
41894: PUSH
41895: NOP4
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: LIST
41904: LIST
41905: LIST
41906: LIST
41907: PUSH
41908: NOP4
41912: PUSH
41913: LD_INT 1
41915: PLUS
41916: ARRAY
41917: ST_TO_ADDR
41918: GO 42403
41920: LD_INT 16
41922: DOUBLE
41923: EQUAL
41924: IFTRUE 41982
41926: LD_INT 17
41928: DOUBLE
41929: EQUAL
41930: IFTRUE 41982
41932: LD_INT 18
41934: DOUBLE
41935: EQUAL
41936: IFTRUE 41982
41938: LD_INT 19
41940: DOUBLE
41941: EQUAL
41942: IFTRUE 41982
41944: LD_INT 22
41946: DOUBLE
41947: EQUAL
41948: IFTRUE 41982
41950: LD_INT 20
41952: DOUBLE
41953: EQUAL
41954: IFTRUE 41982
41956: LD_INT 21
41958: DOUBLE
41959: EQUAL
41960: IFTRUE 41982
41962: LD_INT 23
41964: DOUBLE
41965: EQUAL
41966: IFTRUE 41982
41968: LD_INT 24
41970: DOUBLE
41971: EQUAL
41972: IFTRUE 41982
41974: LD_INT 25
41976: DOUBLE
41977: EQUAL
41978: IFTRUE 41982
41980: GO 42038
41982: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41983: NOP4
41987: PUSH
41988: NOP4
41992: PUSH
41993: NOP4
41997: PUSH
41998: NOP4
42002: PUSH
42003: NOP4
42007: PUSH
42008: NOP4
42012: PUSH
42013: NOP4
42017: PUSH
42018: EMPTY
42019: LIST
42020: LIST
42021: LIST
42022: LIST
42023: LIST
42024: LIST
42025: PUSH
42026: NOP4
42030: PUSH
42031: LD_INT 1
42033: PLUS
42034: ARRAY
42035: ST_TO_ADDR
42036: GO 42403
42038: LD_INT 6
42040: DOUBLE
42041: EQUAL
42042: IFTRUE 42094
42044: LD_INT 7
42046: DOUBLE
42047: EQUAL
42048: IFTRUE 42094
42050: LD_INT 8
42052: DOUBLE
42053: EQUAL
42054: IFTRUE 42094
42056: LD_INT 13
42058: DOUBLE
42059: EQUAL
42060: IFTRUE 42094
42062: LD_INT 12
42064: DOUBLE
42065: EQUAL
42066: IFTRUE 42094
42068: LD_INT 15
42070: DOUBLE
42071: EQUAL
42072: IFTRUE 42094
42074: LD_INT 11
42076: DOUBLE
42077: EQUAL
42078: IFTRUE 42094
42080: LD_INT 14
42082: DOUBLE
42083: EQUAL
42084: IFTRUE 42094
42086: LD_INT 10
42088: DOUBLE
42089: EQUAL
42090: IFTRUE 42094
42092: GO 42150
42094: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42095: NOP4
42099: PUSH
42100: NOP4
42104: PUSH
42105: NOP4
42109: PUSH
42110: NOP4
42114: PUSH
42115: NOP4
42119: PUSH
42120: NOP4
42124: PUSH
42125: NOP4
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: PUSH
42138: NOP4
42142: PUSH
42143: LD_INT 1
42145: PLUS
42146: ARRAY
42147: ST_TO_ADDR
42148: GO 42403
42150: LD_INT 36
42152: DOUBLE
42153: EQUAL
42154: IFTRUE 42158
42156: GO 42214
42158: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42159: NOP4
42163: PUSH
42164: NOP4
42168: PUSH
42169: NOP4
42173: PUSH
42174: NOP4
42178: PUSH
42179: NOP4
42183: PUSH
42184: NOP4
42188: PUSH
42189: NOP4
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: LIST
42198: LIST
42199: LIST
42200: LIST
42201: PUSH
42202: NOP4
42206: PUSH
42207: LD_INT 1
42209: PLUS
42210: ARRAY
42211: ST_TO_ADDR
42212: GO 42403
42214: LD_INT 4
42216: DOUBLE
42217: EQUAL
42218: IFTRUE 42240
42220: LD_INT 5
42222: DOUBLE
42223: EQUAL
42224: IFTRUE 42240
42226: LD_INT 34
42228: DOUBLE
42229: EQUAL
42230: IFTRUE 42240
42232: LD_INT 37
42234: DOUBLE
42235: EQUAL
42236: IFTRUE 42240
42238: GO 42296
42240: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42241: NOP4
42245: PUSH
42246: NOP4
42250: PUSH
42251: NOP4
42255: PUSH
42256: NOP4
42260: PUSH
42261: NOP4
42265: PUSH
42266: NOP4
42270: PUSH
42271: NOP4
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: PUSH
42284: NOP4
42288: PUSH
42289: LD_INT 1
42291: PLUS
42292: ARRAY
42293: ST_TO_ADDR
42294: GO 42403
42296: LD_INT 31
42298: DOUBLE
42299: EQUAL
42300: IFTRUE 42346
42302: LD_INT 32
42304: DOUBLE
42305: EQUAL
42306: IFTRUE 42346
42308: LD_INT 33
42310: DOUBLE
42311: EQUAL
42312: IFTRUE 42346
42314: LD_INT 27
42316: DOUBLE
42317: EQUAL
42318: IFTRUE 42346
42320: LD_INT 26
42322: DOUBLE
42323: EQUAL
42324: IFTRUE 42346
42326: LD_INT 28
42328: DOUBLE
42329: EQUAL
42330: IFTRUE 42346
42332: LD_INT 29
42334: DOUBLE
42335: EQUAL
42336: IFTRUE 42346
42338: LD_INT 30
42340: DOUBLE
42341: EQUAL
42342: IFTRUE 42346
42344: GO 42402
42346: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42347: NOP4
42351: PUSH
42352: NOP4
42356: PUSH
42357: NOP4
42361: PUSH
42362: NOP4
42366: PUSH
42367: NOP4
42371: PUSH
42372: NOP4
42376: PUSH
42377: NOP4
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: LIST
42386: LIST
42387: LIST
42388: LIST
42389: PUSH
42390: NOP4
42394: PUSH
42395: LD_INT 1
42397: PLUS
42398: ARRAY
42399: ST_TO_ADDR
42400: GO 42403
42402: POP
// temp_list2 = [ ] ;
42403: NOP4
42407: PUSH
42408: EMPTY
42409: ST_TO_ADDR
// for i in temp_list do
42410: NOP4
42414: PUSH
42415: NOP4
42419: PUSH
42420: FOR_IN
42421: IFFALSE 42473
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42423: NOP4
42427: PUSH
42428: NOP4
42432: PUSH
42433: NOP4
42437: PUSH
42438: LD_INT 1
42440: ARRAY
42441: PUSH
42442: NOP4
42446: PLUS
42447: PUSH
42448: NOP4
42452: PUSH
42453: LD_INT 2
42455: ARRAY
42456: PUSH
42457: NOP4
42461: PLUS
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PUSH
42467: EMPTY
42468: LIST
42469: ADD
42470: ST_TO_ADDR
42471: GO 42420
42473: POP
42474: POP
// result = temp_list2 ;
42475: NOP4
42479: PUSH
42480: NOP4
42484: ST_TO_ADDR
// end ;
42485: LD_VAR 0 7
42489: RET
// export function EnemyInRange ( unit , dist ) ; begin
42490: LD_INT 0
42492: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42493: NOP4
42497: PUSH
42498: NOP4
42502: PPUSH
42503: NOP4
42507: PPUSH
42508: NOP4
42512: PPUSH
42513: NOP4
42517: PPUSH
42518: NOP4
42522: PPUSH
42523: NOP4
42527: PPUSH
42528: NOP4
42532: PPUSH
42533: NOP4
42537: PUSH
42538: LD_INT 4
42540: ARRAY
42541: ST_TO_ADDR
// end ;
42542: LD_VAR 0 3
42546: RET
// export function PlayerSeeMe ( unit ) ; begin
42547: LD_INT 0
42549: PPUSH
// result := See ( your_side , unit ) ;
42550: NOP4
42554: PUSH
42555: NOP4
42559: PPUSH
42560: NOP4
42564: PPUSH
42565: NOP4
42569: ST_TO_ADDR
// end ;
42570: LD_VAR 0 2
42574: RET
// export function ReverseDir ( unit ) ; begin
42575: LD_INT 0
42577: PPUSH
// if not unit then
42578: NOP4
42582: NOT
42583: IFFALSE 42587
// exit ;
42585: GO 42610
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42587: NOP4
42591: PUSH
42592: NOP4
42596: PPUSH
42597: NOP4
42601: PUSH
42602: LD_INT 3
42604: PLUS
42605: PUSH
42606: LD_INT 6
42608: MOD
42609: ST_TO_ADDR
// end ;
42610: LD_VAR 0 2
42614: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
42615: LD_INT 0
42617: PPUSH
42618: PPUSH
42619: PPUSH
42620: PPUSH
42621: PPUSH
42622: PPUSH
// if not unit or not hexes then
42623: NOP4
42627: NOT
42628: PUSH
42629: NOP4
42633: NOT
42634: OR
42635: IFFALSE 42639
// exit ;
42637: GO 42762
// dist := 9999 ;
42639: NOP4
42643: PUSH
42644: LD_INT 9999
42646: ST_TO_ADDR
// for i = 1 to hexes do
42647: NOP4
42651: PUSH
42652: DOUBLE
42653: LD_INT 1
42655: DEC
42656: ST_TO_ADDR
42657: NOP4
42661: PUSH
42662: FOR_TO
42663: IFFALSE 42750
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42665: NOP4
42669: PUSH
42670: NOP4
42674: PPUSH
42675: NOP4
42679: PUSH
42680: NOP4
42684: ARRAY
42685: PUSH
42686: LD_INT 1
42688: ARRAY
42689: PPUSH
42690: NOP4
42694: PUSH
42695: NOP4
42699: ARRAY
42700: PUSH
42701: LD_INT 2
42703: ARRAY
42704: PPUSH
42705: NOP4
42709: ST_TO_ADDR
// if tdist < dist then
42710: NOP4
42714: PUSH
42715: NOP4
42719: LESS
42720: IFFALSE 42748
// begin hex := hexes [ i ] ;
42722: NOP4
42726: PUSH
42727: NOP4
42731: PUSH
42732: NOP4
42736: ARRAY
42737: ST_TO_ADDR
// dist := tdist ;
42738: NOP4
42742: PUSH
42743: NOP4
42747: ST_TO_ADDR
// end ; end ;
42748: GO 42662
42750: POP
42751: POP
// result := hex ;
42752: NOP4
42756: PUSH
42757: NOP4
42761: ST_TO_ADDR
// end ;
42762: LD_VAR 0 3
42766: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42767: LD_INT 0
42769: PPUSH
42770: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42771: NOP4
42775: NOT
42776: PUSH
42777: NOP4
42781: PUSH
42782: LD_INT 21
42784: PUSH
42785: LD_INT 2
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 23
42794: PUSH
42795: LD_INT 2
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: PPUSH
42806: NOP4
42810: IN
42811: NOT
42812: OR
42813: IFFALSE 42817
// exit ;
42815: GO 42864
// for i = 1 to 3 do
42817: NOP4
42821: PUSH
42822: DOUBLE
42823: LD_INT 1
42825: DEC
42826: ST_TO_ADDR
42827: LD_INT 3
42829: PUSH
42830: FOR_TO
42831: IFFALSE 42862
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42833: NOP4
42837: PPUSH
42838: NOP4
42842: PPUSH
42843: NOP4
42847: PPUSH
42848: NOP4
42852: PPUSH
42853: LD_INT 1
42855: PPUSH
42856: NOP4
42860: GO 42830
42862: POP
42863: POP
// end ;
42864: LD_VAR 0 2
42868: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42869: LD_INT 0
42871: PPUSH
42872: PPUSH
42873: PPUSH
42874: PPUSH
42875: PPUSH
42876: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42877: NOP4
42881: NOT
42882: PUSH
42883: NOP4
42887: NOT
42888: OR
42889: PUSH
42890: NOP4
42894: PPUSH
42895: NOP4
42899: OR
42900: IFFALSE 42904
// exit ;
42902: GO 43345
// x := GetX ( enemy_unit ) ;
42904: NOP4
42908: PUSH
42909: NOP4
42913: PPUSH
42914: NOP4
42918: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42919: NOP4
42923: PUSH
42924: NOP4
42928: PPUSH
42929: NOP4
42933: ST_TO_ADDR
// if not x or not y then
42934: NOP4
42938: NOT
42939: PUSH
42940: NOP4
42944: NOT
42945: OR
42946: IFFALSE 42950
// exit ;
42948: GO 43345
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42950: NOP4
42954: PUSH
42955: NOP4
42959: PPUSH
42960: LD_INT 0
42962: PPUSH
42963: LD_INT 4
42965: PPUSH
42966: NOP4
42970: PUSH
42971: NOP4
42975: PPUSH
42976: LD_INT 0
42978: PPUSH
42979: LD_INT 4
42981: PPUSH
42982: NOP4
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: NOP4
42995: PPUSH
42996: LD_INT 1
42998: PPUSH
42999: LD_INT 4
43001: PPUSH
43002: NOP4
43006: PUSH
43007: NOP4
43011: PPUSH
43012: LD_INT 1
43014: PPUSH
43015: LD_INT 4
43017: PPUSH
43018: NOP4
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: NOP4
43031: PPUSH
43032: LD_INT 2
43034: PPUSH
43035: LD_INT 4
43037: PPUSH
43038: NOP4
43042: PUSH
43043: NOP4
43047: PPUSH
43048: LD_INT 2
43050: PPUSH
43051: LD_INT 4
43053: PPUSH
43054: NOP4
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: NOP4
43067: PPUSH
43068: LD_INT 3
43070: PPUSH
43071: LD_INT 4
43073: PPUSH
43074: NOP4
43078: PUSH
43079: NOP4
43083: PPUSH
43084: LD_INT 3
43086: PPUSH
43087: LD_INT 4
43089: PPUSH
43090: NOP4
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: NOP4
43103: PPUSH
43104: LD_INT 4
43106: PPUSH
43107: LD_INT 4
43109: PPUSH
43110: NOP4
43114: PUSH
43115: NOP4
43119: PPUSH
43120: LD_INT 4
43122: PPUSH
43123: LD_INT 4
43125: PPUSH
43126: NOP4
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: NOP4
43139: PPUSH
43140: LD_INT 5
43142: PPUSH
43143: LD_INT 4
43145: PPUSH
43146: NOP4
43150: PUSH
43151: NOP4
43155: PPUSH
43156: LD_INT 5
43158: PPUSH
43159: LD_INT 4
43161: PPUSH
43162: NOP4
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: LIST
43175: LIST
43176: LIST
43177: LIST
43178: ST_TO_ADDR
// for i = tmp downto 1 do
43179: NOP4
43183: PUSH
43184: DOUBLE
43185: NOP4
43189: INC
43190: ST_TO_ADDR
43191: LD_INT 1
43193: PUSH
43194: FOR_DOWNTO
43195: IFFALSE 43296
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43197: NOP4
43201: PUSH
43202: NOP4
43206: ARRAY
43207: PUSH
43208: LD_INT 1
43210: ARRAY
43211: PPUSH
43212: NOP4
43216: PUSH
43217: NOP4
43221: ARRAY
43222: PUSH
43223: LD_INT 2
43225: ARRAY
43226: PPUSH
43227: NOP4
43231: NOT
43232: PUSH
43233: NOP4
43237: PUSH
43238: NOP4
43242: ARRAY
43243: PUSH
43244: LD_INT 1
43246: ARRAY
43247: PPUSH
43248: NOP4
43252: PUSH
43253: NOP4
43257: ARRAY
43258: PUSH
43259: LD_INT 2
43261: ARRAY
43262: PPUSH
43263: NOP4
43267: PUSH
43268: LD_INT 0
43270: NONEQUAL
43271: OR
43272: IFFALSE 43294
// tmp := Delete ( tmp , i ) ;
43274: NOP4
43278: PUSH
43279: NOP4
43283: PPUSH
43284: NOP4
43288: PPUSH
43289: NOP4
43293: ST_TO_ADDR
43294: GO 43194
43296: POP
43297: POP
// j := GetClosestHex ( unit , tmp ) ;
43298: NOP4
43302: PUSH
43303: NOP4
43307: PPUSH
43308: NOP4
43312: PPUSH
43313: NOP4
43317: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43318: NOP4
43322: PPUSH
43323: NOP4
43327: PUSH
43328: LD_INT 1
43330: ARRAY
43331: PPUSH
43332: NOP4
43336: PUSH
43337: LD_INT 2
43339: ARRAY
43340: PPUSH
43341: NOP4
// end ;
43345: LD_VAR 0 3
43349: RET
// export function PrepareApemanSoldier ( ) ; begin
43350: LD_INT 0
43352: PPUSH
// uc_nation := 0 ;
43353: LD_ADDR_OWVAR 21
43357: PUSH
43358: LD_INT 0
43360: ST_TO_ADDR
// hc_sex := sex_male ;
43361: LD_ADDR_OWVAR 27
43365: PUSH
43366: LD_INT 1
43368: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
43369: LD_ADDR_OWVAR 28
43373: PUSH
43374: LD_INT 15
43376: ST_TO_ADDR
// hc_gallery :=  ;
43377: LD_ADDR_OWVAR 33
43381: PUSH
43382: LD_STRING 
43384: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43385: LD_ADDR_OWVAR 31
43389: PUSH
43390: LD_INT 0
43392: PPUSH
43393: LD_INT 3
43395: PPUSH
43396: NOP4
43400: PUSH
43401: LD_INT 0
43403: PPUSH
43404: LD_INT 3
43406: PPUSH
43407: NOP4
43411: PUSH
43412: LD_INT 0
43414: PUSH
43415: LD_INT 0
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: LIST
43422: LIST
43423: ST_TO_ADDR
// end ;
43424: LD_VAR 0 1
43428: RET
// export function PrepareApemanEngineer ( ) ; begin
43429: LD_INT 0
43431: PPUSH
// uc_nation := 0 ;
43432: LD_ADDR_OWVAR 21
43436: PUSH
43437: LD_INT 0
43439: ST_TO_ADDR
// hc_sex := sex_male ;
43440: LD_ADDR_OWVAR 27
43444: PUSH
43445: LD_INT 1
43447: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
43448: LD_ADDR_OWVAR 28
43452: PUSH
43453: LD_INT 16
43455: ST_TO_ADDR
// hc_gallery :=  ;
43456: LD_ADDR_OWVAR 33
43460: PUSH
43461: LD_STRING 
43463: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43464: LD_ADDR_OWVAR 31
43468: PUSH
43469: LD_INT 0
43471: PPUSH
43472: LD_INT 3
43474: PPUSH
43475: NOP4
43479: PUSH
43480: LD_INT 0
43482: PPUSH
43483: LD_INT 3
43485: PPUSH
43486: NOP4
43490: PUSH
43491: LD_INT 0
43493: PUSH
43494: LD_INT 0
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: ST_TO_ADDR
// end ;
43503: LD_VAR 0 1
43507: RET
// export function PrepareApeman ( agressivity ) ; begin
43508: LD_INT 0
43510: PPUSH
// uc_side := 0 ;
43511: LD_ADDR_OWVAR 20
43515: PUSH
43516: LD_INT 0
43518: ST_TO_ADDR
// uc_nation := 0 ;
43519: LD_ADDR_OWVAR 21
43523: PUSH
43524: LD_INT 0
43526: ST_TO_ADDR
// hc_sex := sex_male ;
43527: LD_ADDR_OWVAR 27
43531: PUSH
43532: LD_INT 1
43534: ST_TO_ADDR
// hc_class := class_apeman ;
43535: LD_ADDR_OWVAR 28
43539: PUSH
43540: LD_INT 12
43542: ST_TO_ADDR
// hc_gallery :=  ;
43543: LD_ADDR_OWVAR 33
43547: PUSH
43548: LD_STRING 
43550: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43551: LD_ADDR_OWVAR 35
43555: PUSH
43556: NOP4
43560: NEG
43561: PPUSH
43562: NOP4
43566: PPUSH
43567: NOP4
43571: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43572: LD_ADDR_OWVAR 31
43576: PUSH
43577: LD_INT 0
43579: PPUSH
43580: LD_INT 3
43582: PPUSH
43583: NOP4
43587: PUSH
43588: LD_INT 0
43590: PPUSH
43591: LD_INT 3
43593: PPUSH
43594: NOP4
43598: PUSH
43599: LD_INT 0
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: ST_TO_ADDR
// end ;
43611: LD_VAR 0 2
43615: RET
// export function PrepareTiger ( agressivity ) ; begin
43616: LD_INT 0
43618: PPUSH
// uc_side := 0 ;
43619: LD_ADDR_OWVAR 20
43623: PUSH
43624: LD_INT 0
43626: ST_TO_ADDR
// uc_nation := 0 ;
43627: LD_ADDR_OWVAR 21
43631: PUSH
43632: LD_INT 0
43634: ST_TO_ADDR
// hc_class := class_tiger ;
43635: LD_ADDR_OWVAR 28
43639: PUSH
43640: LD_INT 14
43642: ST_TO_ADDR
// hc_gallery :=  ;
43643: LD_ADDR_OWVAR 33
43647: PUSH
43648: LD_STRING 
43650: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43651: LD_ADDR_OWVAR 35
43655: PUSH
43656: NOP4
43660: NEG
43661: PPUSH
43662: NOP4
43666: PPUSH
43667: NOP4
43671: ST_TO_ADDR
// end ;
43672: LD_VAR 0 2
43676: RET
// export function PrepareEnchidna ( ) ; begin
43677: LD_INT 0
43679: PPUSH
// uc_side := 0 ;
43680: LD_ADDR_OWVAR 20
43684: PUSH
43685: LD_INT 0
43687: ST_TO_ADDR
// uc_nation := 0 ;
43688: LD_ADDR_OWVAR 21
43692: PUSH
43693: LD_INT 0
43695: ST_TO_ADDR
// hc_class := class_baggie ;
43696: LD_ADDR_OWVAR 28
43700: PUSH
43701: LD_INT 13
43703: ST_TO_ADDR
// hc_gallery :=  ;
43704: LD_ADDR_OWVAR 33
43708: PUSH
43709: LD_STRING 
43711: ST_TO_ADDR
// end ;
43712: LD_VAR 0 1
43716: RET
// export function PrepareFrog ( ) ; begin
43717: LD_INT 0
43719: PPUSH
// uc_side := 0 ;
43720: LD_ADDR_OWVAR 20
43724: PUSH
43725: LD_INT 0
43727: ST_TO_ADDR
// uc_nation := 0 ;
43728: LD_ADDR_OWVAR 21
43732: PUSH
43733: LD_INT 0
43735: ST_TO_ADDR
// hc_class := class_frog ;
43736: LD_ADDR_OWVAR 28
43740: PUSH
43741: LD_INT 19
43743: ST_TO_ADDR
// hc_gallery :=  ;
43744: LD_ADDR_OWVAR 33
43748: PUSH
43749: LD_STRING 
43751: ST_TO_ADDR
// end ;
43752: LD_VAR 0 1
43756: RET
// export function PrepareFish ( ) ; begin
43757: LD_INT 0
43759: PPUSH
// uc_side := 0 ;
43760: LD_ADDR_OWVAR 20
43764: PUSH
43765: LD_INT 0
43767: ST_TO_ADDR
// uc_nation := 0 ;
43768: LD_ADDR_OWVAR 21
43772: PUSH
43773: LD_INT 0
43775: ST_TO_ADDR
// hc_class := class_fish ;
43776: LD_ADDR_OWVAR 28
43780: PUSH
43781: LD_INT 20
43783: ST_TO_ADDR
// hc_gallery :=  ;
43784: LD_ADDR_OWVAR 33
43788: PUSH
43789: LD_STRING 
43791: ST_TO_ADDR
// end ;
43792: LD_VAR 0 1
43796: RET
// export function PrepareBird ( ) ; begin
43797: LD_INT 0
43799: PPUSH
// uc_side := 0 ;
43800: LD_ADDR_OWVAR 20
43804: PUSH
43805: LD_INT 0
43807: ST_TO_ADDR
// uc_nation := 0 ;
43808: LD_ADDR_OWVAR 21
43812: PUSH
43813: LD_INT 0
43815: ST_TO_ADDR
// hc_class := class_phororhacos ;
43816: LD_ADDR_OWVAR 28
43820: PUSH
43821: LD_INT 18
43823: ST_TO_ADDR
// hc_gallery :=  ;
43824: LD_ADDR_OWVAR 33
43828: PUSH
43829: LD_STRING 
43831: ST_TO_ADDR
// end ;
43832: LD_VAR 0 1
43836: RET
// export function PrepareHorse ( ) ; begin
43837: LD_INT 0
43839: PPUSH
// uc_side := 0 ;
43840: LD_ADDR_OWVAR 20
43844: PUSH
43845: LD_INT 0
43847: ST_TO_ADDR
// uc_nation := 0 ;
43848: LD_ADDR_OWVAR 21
43852: PUSH
43853: LD_INT 0
43855: ST_TO_ADDR
// hc_class := class_horse ;
43856: LD_ADDR_OWVAR 28
43860: PUSH
43861: LD_INT 21
43863: ST_TO_ADDR
// hc_gallery :=  ;
43864: LD_ADDR_OWVAR 33
43868: PUSH
43869: LD_STRING 
43871: ST_TO_ADDR
// end ;
43872: LD_VAR 0 1
43876: RET
// export function PrepareMastodont ( ) ; begin
43877: LD_INT 0
43879: PPUSH
// uc_side := 0 ;
43880: LD_ADDR_OWVAR 20
43884: PUSH
43885: LD_INT 0
43887: ST_TO_ADDR
// uc_nation := 0 ;
43888: LD_ADDR_OWVAR 21
43892: PUSH
43893: LD_INT 0
43895: ST_TO_ADDR
// vc_chassis := class_mastodont ;
43896: LD_ADDR_OWVAR 37
43900: PUSH
43901: LD_INT 31
43903: ST_TO_ADDR
// vc_control := control_rider ;
43904: LD_ADDR_OWVAR 38
43908: PUSH
43909: LD_INT 4
43911: ST_TO_ADDR
// end ;
43912: LD_VAR 0 1
43916: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43917: LD_INT 0
43919: PPUSH
43920: PPUSH
43921: PPUSH
// uc_side = 0 ;
43922: LD_ADDR_OWVAR 20
43926: PUSH
43927: LD_INT 0
43929: ST_TO_ADDR
// uc_nation = 0 ;
43930: LD_ADDR_OWVAR 21
43934: PUSH
43935: LD_INT 0
43937: ST_TO_ADDR
// InitHc_All ( ) ;
43938: NOP4
// InitVc ;
43942: NOP4
// if mastodonts then
43946: NOP4
43950: IFFALSE 44017
// for i = 1 to mastodonts do
43952: NOP4
43956: PUSH
43957: DOUBLE
43958: LD_INT 1
43960: DEC
43961: ST_TO_ADDR
43962: NOP4
43966: PUSH
43967: FOR_TO
43968: IFFALSE 44015
// begin vc_chassis := 31 ;
43970: LD_ADDR_OWVAR 37
43974: PUSH
43975: LD_INT 31
43977: ST_TO_ADDR
// vc_control := control_rider ;
43978: LD_ADDR_OWVAR 38
43982: PUSH
43983: LD_INT 4
43985: ST_TO_ADDR
// animal := CreateVehicle ;
43986: NOP4
43990: PUSH
43991: NOP4
43995: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43996: NOP4
44000: PPUSH
44001: NOP4
44005: PPUSH
44006: LD_INT 0
44008: PPUSH
44009: NOP4
// end ;
44013: GO 43967
44015: POP
44016: POP
// if horses then
44017: NOP4
44021: IFFALSE 44088
// for i = 1 to horses do
44023: NOP4
44027: PUSH
44028: DOUBLE
44029: LD_INT 1
44031: DEC
44032: ST_TO_ADDR
44033: NOP4
44037: PUSH
44038: FOR_TO
44039: IFFALSE 44086
// begin hc_class := 21 ;
44041: LD_ADDR_OWVAR 28
44045: PUSH
44046: LD_INT 21
44048: ST_TO_ADDR
// hc_gallery :=  ;
44049: LD_ADDR_OWVAR 33
44053: PUSH
44054: LD_STRING 
44056: ST_TO_ADDR
// animal := CreateHuman ;
44057: NOP4
44061: PUSH
44062: NOP4
44066: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44067: NOP4
44071: PPUSH
44072: NOP4
44076: PPUSH
44077: LD_INT 0
44079: PPUSH
44080: NOP4
// end ;
44084: GO 44038
44086: POP
44087: POP
// if birds then
44088: NOP4
44092: IFFALSE 44159
// for i = 1 to birds do
44094: NOP4
44098: PUSH
44099: DOUBLE
44100: LD_INT 1
44102: DEC
44103: ST_TO_ADDR
44104: NOP4
44108: PUSH
44109: FOR_TO
44110: IFFALSE 44157
// begin hc_class = 18 ;
44112: LD_ADDR_OWVAR 28
44116: PUSH
44117: LD_INT 18
44119: ST_TO_ADDR
// hc_gallery =  ;
44120: LD_ADDR_OWVAR 33
44124: PUSH
44125: LD_STRING 
44127: ST_TO_ADDR
// animal := CreateHuman ;
44128: NOP4
44132: PUSH
44133: NOP4
44137: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44138: NOP4
44142: PPUSH
44143: NOP4
44147: PPUSH
44148: LD_INT 0
44150: PPUSH
44151: NOP4
// end ;
44155: GO 44109
44157: POP
44158: POP
// if tigers then
44159: NOP4
44163: IFFALSE 44247
// for i = 1 to tigers do
44165: NOP4
44169: PUSH
44170: DOUBLE
44171: LD_INT 1
44173: DEC
44174: ST_TO_ADDR
44175: NOP4
44179: PUSH
44180: FOR_TO
44181: IFFALSE 44245
// begin hc_class = class_tiger ;
44183: LD_ADDR_OWVAR 28
44187: PUSH
44188: LD_INT 14
44190: ST_TO_ADDR
// hc_gallery =  ;
44191: LD_ADDR_OWVAR 33
44195: PUSH
44196: LD_STRING 
44198: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44199: LD_ADDR_OWVAR 35
44203: PUSH
44204: LD_INT 7
44206: NEG
44207: PPUSH
44208: LD_INT 7
44210: PPUSH
44211: NOP4
44215: ST_TO_ADDR
// animal := CreateHuman ;
44216: NOP4
44220: PUSH
44221: NOP4
44225: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44226: NOP4
44230: PPUSH
44231: NOP4
44235: PPUSH
44236: LD_INT 0
44238: PPUSH
44239: NOP4
// end ;
44243: GO 44180
44245: POP
44246: POP
// if apemans then
44247: NOP4
44251: IFFALSE 44374
// for i = 1 to apemans do
44253: NOP4
44257: PUSH
44258: DOUBLE
44259: LD_INT 1
44261: DEC
44262: ST_TO_ADDR
44263: NOP4
44267: PUSH
44268: FOR_TO
44269: IFFALSE 44372
// begin hc_class = class_apeman ;
44271: LD_ADDR_OWVAR 28
44275: PUSH
44276: LD_INT 12
44278: ST_TO_ADDR
// hc_gallery =  ;
44279: LD_ADDR_OWVAR 33
44283: PUSH
44284: LD_STRING 
44286: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44287: LD_ADDR_OWVAR 35
44291: PUSH
44292: LD_INT 2
44294: NEG
44295: PPUSH
44296: LD_INT 2
44298: PPUSH
44299: NOP4
44303: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44304: LD_ADDR_OWVAR 31
44308: PUSH
44309: LD_INT 1
44311: PPUSH
44312: LD_INT 3
44314: PPUSH
44315: NOP4
44319: PUSH
44320: LD_INT 1
44322: PPUSH
44323: LD_INT 3
44325: PPUSH
44326: NOP4
44330: PUSH
44331: LD_INT 0
44333: PUSH
44334: LD_INT 0
44336: PUSH
44337: EMPTY
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: ST_TO_ADDR
// animal := CreateHuman ;
44343: NOP4
44347: PUSH
44348: NOP4
44352: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44353: NOP4
44357: PPUSH
44358: NOP4
44362: PPUSH
44363: LD_INT 0
44365: PPUSH
44366: NOP4
// end ;
44370: GO 44268
44372: POP
44373: POP
// if enchidnas then
44374: NOP4
44378: IFFALSE 44445
// for i = 1 to enchidnas do
44380: NOP4
44384: PUSH
44385: DOUBLE
44386: LD_INT 1
44388: DEC
44389: ST_TO_ADDR
44390: NOP4
44394: PUSH
44395: FOR_TO
44396: IFFALSE 44443
// begin hc_class = 13 ;
44398: LD_ADDR_OWVAR 28
44402: PUSH
44403: LD_INT 13
44405: ST_TO_ADDR
// hc_gallery =  ;
44406: LD_ADDR_OWVAR 33
44410: PUSH
44411: LD_STRING 
44413: ST_TO_ADDR
// animal := CreateHuman ;
44414: NOP4
44418: PUSH
44419: NOP4
44423: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44424: NOP4
44428: PPUSH
44429: NOP4
44433: PPUSH
44434: LD_INT 0
44436: PPUSH
44437: NOP4
// end ;
44441: GO 44395
44443: POP
44444: POP
// if fishes then
44445: NOP4
44449: IFFALSE 44516
// for i = 1 to fishes do
44451: NOP4
44455: PUSH
44456: DOUBLE
44457: LD_INT 1
44459: DEC
44460: ST_TO_ADDR
44461: NOP4
44465: PUSH
44466: FOR_TO
44467: IFFALSE 44514
// begin hc_class = 20 ;
44469: LD_ADDR_OWVAR 28
44473: PUSH
44474: LD_INT 20
44476: ST_TO_ADDR
// hc_gallery =  ;
44477: LD_ADDR_OWVAR 33
44481: PUSH
44482: LD_STRING 
44484: ST_TO_ADDR
// animal := CreateHuman ;
44485: NOP4
44489: PUSH
44490: NOP4
44494: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44495: NOP4
44499: PPUSH
44500: NOP4
44504: PPUSH
44505: LD_INT 0
44507: PPUSH
44508: NOP4
// end ;
44512: GO 44466
44514: POP
44515: POP
// end ;
44516: LD_VAR 0 10
44520: RET
// export function WantHeal ( sci , unit ) ; begin
44521: LD_INT 0
44523: PPUSH
// if GetTaskList ( sci ) > 0 then
44524: NOP4
44528: PPUSH
44529: NOP4
44533: PUSH
44534: LD_INT 0
44536: GREATER
44537: IFFALSE 44607
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44539: NOP4
44543: PPUSH
44544: NOP4
44548: PUSH
44549: LD_INT 1
44551: ARRAY
44552: PUSH
44553: LD_INT 1
44555: ARRAY
44556: PUSH
44557: LD_STRING l
44559: EQUAL
44560: PUSH
44561: NOP4
44565: PPUSH
44566: NOP4
44570: PUSH
44571: LD_INT 1
44573: ARRAY
44574: PUSH
44575: LD_INT 4
44577: ARRAY
44578: PUSH
44579: NOP4
44583: EQUAL
44584: AND
44585: IFFALSE 44597
// result := true else
44587: NOP4
44591: PUSH
44592: LD_INT 1
44594: ST_TO_ADDR
44595: GO 44605
// result := false ;
44597: NOP4
44601: PUSH
44602: LD_INT 0
44604: ST_TO_ADDR
// end else
44605: GO 44615
// result := false ;
44607: NOP4
44611: PUSH
44612: LD_INT 0
44614: ST_TO_ADDR
// end ;
44615: LD_VAR 0 3
44619: RET
// export function HealTarget ( sci ) ; begin
44620: LD_INT 0
44622: PPUSH
// if not sci then
44623: NOP4
44627: NOT
44628: IFFALSE 44632
// exit ;
44630: GO 44697
// result := 0 ;
44632: NOP4
44636: PUSH
44637: LD_INT 0
44639: ST_TO_ADDR
// if GetTaskList ( sci ) then
44640: NOP4
44644: PPUSH
44645: NOP4
44649: IFFALSE 44697
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44651: NOP4
44655: PPUSH
44656: NOP4
44660: PUSH
44661: LD_INT 1
44663: ARRAY
44664: PUSH
44665: LD_INT 1
44667: ARRAY
44668: PUSH
44669: LD_STRING l
44671: EQUAL
44672: IFFALSE 44697
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44674: NOP4
44678: PUSH
44679: NOP4
44683: PPUSH
44684: NOP4
44688: PUSH
44689: LD_INT 1
44691: ARRAY
44692: PUSH
44693: LD_INT 4
44695: ARRAY
44696: ST_TO_ADDR
// end ;
44697: LD_VAR 0 2
44701: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44702: LD_INT 0
44704: PPUSH
44705: PPUSH
44706: PPUSH
44707: PPUSH
// if not base_units then
44708: NOP4
44712: NOT
44713: IFFALSE 44717
// exit ;
44715: GO 44804
// result := false ;
44717: NOP4
44721: PUSH
44722: LD_INT 0
44724: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44725: NOP4
44729: PUSH
44730: NOP4
44734: PPUSH
44735: LD_INT 21
44737: PUSH
44738: LD_INT 3
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PPUSH
44745: NOP4
44749: ST_TO_ADDR
// if not tmp then
44750: NOP4
44754: NOT
44755: IFFALSE 44759
// exit ;
44757: GO 44804
// for i in tmp do
44759: NOP4
44763: PUSH
44764: NOP4
44768: PUSH
44769: FOR_IN
44770: IFFALSE 44802
// begin result := EnemyInRange ( i , 22 ) ;
44772: NOP4
44776: PUSH
44777: NOP4
44781: PPUSH
44782: LD_INT 22
44784: PPUSH
44785: NOP4
44789: ST_TO_ADDR
// if result then
44790: NOP4
44794: IFFALSE 44800
// exit ;
44796: POP
44797: POP
44798: GO 44804
// end ;
44800: GO 44769
44802: POP
44803: POP
// end ;
44804: LD_VAR 0 2
44808: RET
// export function FilterByTag ( units , tag ) ; begin
44809: LD_INT 0
44811: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
44812: NOP4
44816: PUSH
44817: NOP4
44821: PPUSH
44822: LD_INT 120
44824: PUSH
44825: NOP4
44829: PUSH
44830: EMPTY
44831: LIST
44832: LIST
44833: PPUSH
44834: NOP4
44838: ST_TO_ADDR
// end ;
44839: LD_VAR 0 3
44843: RET
// export function IsDriver ( un ) ; begin
44844: LD_INT 0
44846: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44847: NOP4
44851: PUSH
44852: NOP4
44856: PUSH
44857: LD_INT 55
44859: PUSH
44860: EMPTY
44861: LIST
44862: PPUSH
44863: NOP4
44867: IN
44868: ST_TO_ADDR
// end ;
44869: LD_VAR 0 2
44873: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44874: LD_INT 0
44876: PPUSH
44877: PPUSH
// list := [ ] ;
44878: NOP4
44882: PUSH
44883: EMPTY
44884: ST_TO_ADDR
// case d of 0 :
44885: NOP4
44889: PUSH
44890: LD_INT 0
44892: DOUBLE
44893: EQUAL
44894: IFTRUE 44898
44896: GO 45031
44898: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44899: NOP4
44903: PUSH
44904: NOP4
44908: PUSH
44909: LD_INT 4
44911: MINUS
44912: PUSH
44913: NOP4
44917: PUSH
44918: LD_INT 4
44920: MINUS
44921: PUSH
44922: LD_INT 2
44924: PUSH
44925: EMPTY
44926: LIST
44927: LIST
44928: LIST
44929: PUSH
44930: NOP4
44934: PUSH
44935: LD_INT 3
44937: MINUS
44938: PUSH
44939: NOP4
44943: PUSH
44944: LD_INT 1
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: LIST
44951: PUSH
44952: NOP4
44956: PUSH
44957: LD_INT 4
44959: PLUS
44960: PUSH
44961: NOP4
44965: PUSH
44966: LD_INT 4
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: LIST
44973: PUSH
44974: NOP4
44978: PUSH
44979: LD_INT 3
44981: PLUS
44982: PUSH
44983: NOP4
44987: PUSH
44988: LD_INT 3
44990: PLUS
44991: PUSH
44992: LD_INT 5
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: LIST
44999: PUSH
45000: NOP4
45004: PUSH
45005: NOP4
45009: PUSH
45010: LD_INT 4
45012: PLUS
45013: PUSH
45014: LD_INT 0
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: LIST
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: LIST
45026: LIST
45027: LIST
45028: ST_TO_ADDR
// end ; 1 :
45029: GO 45729
45031: LD_INT 1
45033: DOUBLE
45034: EQUAL
45035: IFTRUE 45039
45037: GO 45172
45039: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45040: NOP4
45044: PUSH
45045: NOP4
45049: PUSH
45050: NOP4
45054: PUSH
45055: LD_INT 4
45057: MINUS
45058: PUSH
45059: LD_INT 3
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: LIST
45066: PUSH
45067: NOP4
45071: PUSH
45072: LD_INT 3
45074: MINUS
45075: PUSH
45076: NOP4
45080: PUSH
45081: LD_INT 3
45083: MINUS
45084: PUSH
45085: LD_INT 2
45087: PUSH
45088: EMPTY
45089: LIST
45090: LIST
45091: LIST
45092: PUSH
45093: NOP4
45097: PUSH
45098: LD_INT 4
45100: MINUS
45101: PUSH
45102: NOP4
45106: PUSH
45107: LD_INT 1
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: LIST
45114: PUSH
45115: NOP4
45119: PUSH
45120: NOP4
45124: PUSH
45125: LD_INT 3
45127: PLUS
45128: PUSH
45129: LD_INT 0
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: LIST
45136: PUSH
45137: NOP4
45141: PUSH
45142: LD_INT 4
45144: PLUS
45145: PUSH
45146: NOP4
45150: PUSH
45151: LD_INT 4
45153: PLUS
45154: PUSH
45155: LD_INT 5
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: LIST
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: LIST
45169: ST_TO_ADDR
// end ; 2 :
45170: GO 45729
45172: LD_INT 2
45174: DOUBLE
45175: EQUAL
45176: IFTRUE 45180
45178: GO 45309
45180: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45181: NOP4
45185: PUSH
45186: NOP4
45190: PUSH
45191: NOP4
45195: PUSH
45196: LD_INT 3
45198: MINUS
45199: PUSH
45200: LD_INT 3
45202: PUSH
45203: EMPTY
45204: LIST
45205: LIST
45206: LIST
45207: PUSH
45208: NOP4
45212: PUSH
45213: LD_INT 4
45215: PLUS
45216: PUSH
45217: NOP4
45221: PUSH
45222: LD_INT 4
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: LIST
45229: PUSH
45230: NOP4
45234: PUSH
45235: NOP4
45239: PUSH
45240: LD_INT 4
45242: PLUS
45243: PUSH
45244: LD_INT 0
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: LIST
45251: PUSH
45252: NOP4
45256: PUSH
45257: LD_INT 3
45259: MINUS
45260: PUSH
45261: NOP4
45265: PUSH
45266: LD_INT 1
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: LIST
45273: PUSH
45274: NOP4
45278: PUSH
45279: LD_INT 4
45281: MINUS
45282: PUSH
45283: NOP4
45287: PUSH
45288: LD_INT 4
45290: MINUS
45291: PUSH
45292: LD_INT 2
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: LIST
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: LIST
45304: LIST
45305: LIST
45306: ST_TO_ADDR
// end ; 3 :
45307: GO 45729
45309: LD_INT 3
45311: DOUBLE
45312: EQUAL
45313: IFTRUE 45317
45315: GO 45450
45317: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45318: NOP4
45322: PUSH
45323: NOP4
45327: PUSH
45328: LD_INT 3
45330: PLUS
45331: PUSH
45332: NOP4
45336: PUSH
45337: LD_INT 4
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: LIST
45344: PUSH
45345: NOP4
45349: PUSH
45350: LD_INT 4
45352: PLUS
45353: PUSH
45354: NOP4
45358: PUSH
45359: LD_INT 4
45361: PLUS
45362: PUSH
45363: LD_INT 5
45365: PUSH
45366: EMPTY
45367: LIST
45368: LIST
45369: LIST
45370: PUSH
45371: NOP4
45375: PUSH
45376: LD_INT 4
45378: MINUS
45379: PUSH
45380: NOP4
45384: PUSH
45385: LD_INT 1
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: LIST
45392: PUSH
45393: NOP4
45397: PUSH
45398: NOP4
45402: PUSH
45403: LD_INT 4
45405: MINUS
45406: PUSH
45407: LD_INT 3
45409: PUSH
45410: EMPTY
45411: LIST
45412: LIST
45413: LIST
45414: PUSH
45415: NOP4
45419: PUSH
45420: LD_INT 3
45422: MINUS
45423: PUSH
45424: NOP4
45428: PUSH
45429: LD_INT 3
45431: MINUS
45432: PUSH
45433: LD_INT 2
45435: PUSH
45436: EMPTY
45437: LIST
45438: LIST
45439: LIST
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: ST_TO_ADDR
// end ; 4 :
45448: GO 45729
45450: LD_INT 4
45452: DOUBLE
45453: EQUAL
45454: IFTRUE 45458
45456: GO 45591
45458: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45459: NOP4
45463: PUSH
45464: NOP4
45468: PUSH
45469: NOP4
45473: PUSH
45474: LD_INT 4
45476: PLUS
45477: PUSH
45478: LD_INT 0
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: LIST
45485: PUSH
45486: NOP4
45490: PUSH
45491: LD_INT 3
45493: PLUS
45494: PUSH
45495: NOP4
45499: PUSH
45500: LD_INT 3
45502: PLUS
45503: PUSH
45504: LD_INT 5
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: LIST
45511: PUSH
45512: NOP4
45516: PUSH
45517: LD_INT 4
45519: PLUS
45520: PUSH
45521: NOP4
45525: PUSH
45526: LD_INT 4
45528: PUSH
45529: EMPTY
45530: LIST
45531: LIST
45532: LIST
45533: PUSH
45534: NOP4
45538: PUSH
45539: NOP4
45543: PUSH
45544: LD_INT 3
45546: MINUS
45547: PUSH
45548: LD_INT 3
45550: PUSH
45551: EMPTY
45552: LIST
45553: LIST
45554: LIST
45555: PUSH
45556: NOP4
45560: PUSH
45561: LD_INT 4
45563: MINUS
45564: PUSH
45565: NOP4
45569: PUSH
45570: LD_INT 4
45572: MINUS
45573: PUSH
45574: LD_INT 2
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: LIST
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: ST_TO_ADDR
// end ; 5 :
45589: GO 45729
45591: LD_INT 5
45593: DOUBLE
45594: EQUAL
45595: IFTRUE 45599
45597: GO 45728
45599: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45600: NOP4
45604: PUSH
45605: NOP4
45609: PUSH
45610: LD_INT 4
45612: MINUS
45613: PUSH
45614: NOP4
45618: PUSH
45619: LD_INT 1
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: LIST
45626: PUSH
45627: NOP4
45631: PUSH
45632: NOP4
45636: PUSH
45637: LD_INT 4
45639: MINUS
45640: PUSH
45641: LD_INT 3
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: LIST
45648: PUSH
45649: NOP4
45653: PUSH
45654: LD_INT 4
45656: PLUS
45657: PUSH
45658: NOP4
45662: PUSH
45663: LD_INT 4
45665: PLUS
45666: PUSH
45667: LD_INT 5
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: LIST
45674: PUSH
45675: NOP4
45679: PUSH
45680: LD_INT 3
45682: PLUS
45683: PUSH
45684: NOP4
45688: PUSH
45689: LD_INT 4
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: LIST
45696: PUSH
45697: NOP4
45701: PUSH
45702: NOP4
45706: PUSH
45707: LD_INT 3
45709: PLUS
45710: PUSH
45711: LD_INT 0
45713: PUSH
45714: EMPTY
45715: LIST
45716: LIST
45717: LIST
45718: PUSH
45719: EMPTY
45720: LIST
45721: LIST
45722: LIST
45723: LIST
45724: LIST
45725: ST_TO_ADDR
// end ; end ;
45726: GO 45729
45728: POP
// result := list ;
45729: NOP4
45733: PUSH
45734: NOP4
45738: ST_TO_ADDR
// end ;
45739: LD_VAR 0 4
45743: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45744: LD_INT 0
45746: PPUSH
45747: PPUSH
45748: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45749: NOP4
45753: NOT
45754: PUSH
45755: NOP4
45759: PUSH
45760: LD_INT 1
45762: PUSH
45763: LD_INT 2
45765: PUSH
45766: LD_INT 3
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: LIST
45776: LIST
45777: IN
45778: NOT
45779: OR
45780: IFFALSE 45784
// exit ;
45782: GO 45876
// tmp := [ ] ;
45784: NOP4
45788: PUSH
45789: EMPTY
45790: ST_TO_ADDR
// for i in units do
45791: NOP4
45795: PUSH
45796: NOP4
45800: PUSH
45801: FOR_IN
45802: IFFALSE 45845
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
45804: NOP4
45808: PUSH
45809: NOP4
45813: PPUSH
45814: NOP4
45818: PUSH
45819: LD_INT 1
45821: PLUS
45822: PPUSH
45823: NOP4
45827: PPUSH
45828: NOP4
45832: PPUSH
45833: NOP4
45837: PPUSH
45838: NOP4
45842: ST_TO_ADDR
45843: GO 45801
45845: POP
45846: POP
// if not tmp then
45847: NOP4
45851: NOT
45852: IFFALSE 45856
// exit ;
45854: GO 45876
// result := SortListByListDesc ( units , tmp ) ;
45856: NOP4
45860: PUSH
45861: NOP4
45865: PPUSH
45866: NOP4
45870: PPUSH
45871: NOP4
45875: ST_TO_ADDR
// end ;
45876: LD_VAR 0 3
45880: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45881: LD_INT 0
45883: PPUSH
45884: PPUSH
45885: PPUSH
// result := false ;
45886: NOP4
45890: PUSH
45891: LD_INT 0
45893: ST_TO_ADDR
// x := GetX ( building ) ;
45894: NOP4
45898: PUSH
45899: NOP4
45903: PPUSH
45904: NOP4
45908: ST_TO_ADDR
// y := GetY ( building ) ;
45909: NOP4
45913: PUSH
45914: NOP4
45918: PPUSH
45919: NOP4
45923: ST_TO_ADDR
// if not building or not x or not y then
45924: NOP4
45928: NOT
45929: PUSH
45930: NOP4
45934: NOT
45935: OR
45936: PUSH
45937: NOP4
45941: NOT
45942: OR
45943: IFFALSE 45947
// exit ;
45945: GO 46039
// if GetTaskList ( unit ) then
45947: NOP4
45951: PPUSH
45952: NOP4
45956: IFFALSE 46039
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45958: LD_STRING e
45960: PUSH
45961: NOP4
45965: PPUSH
45966: NOP4
45970: PUSH
45971: LD_INT 1
45973: ARRAY
45974: PUSH
45975: LD_INT 1
45977: ARRAY
45978: EQUAL
45979: PUSH
45980: NOP4
45984: PUSH
45985: NOP4
45989: PPUSH
45990: NOP4
45994: PUSH
45995: LD_INT 1
45997: ARRAY
45998: PUSH
45999: LD_INT 2
46001: ARRAY
46002: EQUAL
46003: AND
46004: PUSH
46005: NOP4
46009: PUSH
46010: NOP4
46014: PPUSH
46015: NOP4
46019: PUSH
46020: LD_INT 1
46022: ARRAY
46023: PUSH
46024: LD_INT 3
46026: ARRAY
46027: EQUAL
46028: AND
46029: IFFALSE 46039
// result := true end ;
46031: NOP4
46035: PUSH
46036: LD_INT 1
46038: ST_TO_ADDR
// end ;
46039: LD_VAR 0 3
46043: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46044: LD_INT 0
46046: PPUSH
// result := false ;
46047: NOP4
46051: PUSH
46052: LD_INT 0
46054: ST_TO_ADDR
// if GetTaskList ( unit ) then
46055: NOP4
46059: PPUSH
46060: NOP4
46064: IFFALSE 46147
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46066: LD_STRING M
46068: PUSH
46069: NOP4
46073: PPUSH
46074: NOP4
46078: PUSH
46079: LD_INT 1
46081: ARRAY
46082: PUSH
46083: LD_INT 1
46085: ARRAY
46086: EQUAL
46087: PUSH
46088: NOP4
46092: PUSH
46093: NOP4
46097: PPUSH
46098: NOP4
46102: PUSH
46103: LD_INT 1
46105: ARRAY
46106: PUSH
46107: LD_INT 2
46109: ARRAY
46110: EQUAL
46111: AND
46112: PUSH
46113: NOP4
46117: PUSH
46118: NOP4
46122: PPUSH
46123: NOP4
46127: PUSH
46128: LD_INT 1
46130: ARRAY
46131: PUSH
46132: LD_INT 3
46134: ARRAY
46135: EQUAL
46136: AND
46137: IFFALSE 46147
// result := true ;
46139: NOP4
46143: PUSH
46144: LD_INT 1
46146: ST_TO_ADDR
// end ; end ;
46147: LD_VAR 0 4
46151: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46152: LD_INT 0
46154: PPUSH
46155: PPUSH
46156: PPUSH
46157: PPUSH
// if not unit or not area then
46158: NOP4
46162: NOT
46163: PUSH
46164: NOP4
46168: NOT
46169: OR
46170: IFFALSE 46174
// exit ;
46172: GO 46338
// tmp := AreaToList ( area , i ) ;
46174: NOP4
46178: PUSH
46179: NOP4
46183: PPUSH
46184: NOP4
46188: PPUSH
46189: NOP4
46193: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46194: NOP4
46198: PUSH
46199: DOUBLE
46200: LD_INT 1
46202: DEC
46203: ST_TO_ADDR
46204: NOP4
46208: PUSH
46209: LD_INT 1
46211: ARRAY
46212: PUSH
46213: FOR_TO
46214: IFFALSE 46336
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46216: NOP4
46220: PUSH
46221: NOP4
46225: PUSH
46226: LD_INT 1
46228: ARRAY
46229: PUSH
46230: NOP4
46234: ARRAY
46235: PUSH
46236: NOP4
46240: PUSH
46241: LD_INT 2
46243: ARRAY
46244: PUSH
46245: NOP4
46249: ARRAY
46250: PUSH
46251: EMPTY
46252: LIST
46253: LIST
46254: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46255: NOP4
46259: PUSH
46260: LD_INT 1
46262: ARRAY
46263: PPUSH
46264: NOP4
46268: PUSH
46269: LD_INT 2
46271: ARRAY
46272: PPUSH
46273: NOP4
46277: PUSH
46278: LD_INT 0
46280: EQUAL
46281: IFFALSE 46334
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46283: NOP4
46287: PPUSH
46288: NOP4
46292: PUSH
46293: LD_INT 1
46295: ARRAY
46296: PPUSH
46297: NOP4
46301: PUSH
46302: LD_INT 2
46304: ARRAY
46305: PPUSH
46306: NOP4
46310: PPUSH
46311: NOP4
// result := IsPlaced ( unit ) ;
46315: NOP4
46319: PUSH
46320: NOP4
46324: PPUSH
46325: NOP4
46329: ST_TO_ADDR
// exit ;
46330: POP
46331: POP
46332: GO 46338
// end ; end ;
46334: GO 46213
46336: POP
46337: POP
// end ;
46338: LD_VAR 0 4
46342: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46343: LD_INT 0
46345: PPUSH
46346: PPUSH
46347: PPUSH
// if not side or side > 8 then
46348: NOP4
46352: NOT
46353: PUSH
46354: NOP4
46358: PUSH
46359: LD_INT 8
46361: GREATER
46362: OR
46363: IFFALSE 46367
// exit ;
46365: GO 46554
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46367: NOP4
46371: PUSH
46372: LD_INT 22
46374: PUSH
46375: NOP4
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: LD_INT 21
46386: PUSH
46387: LD_INT 3
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: PUSH
46394: EMPTY
46395: LIST
46396: LIST
46397: PPUSH
46398: NOP4
46402: ST_TO_ADDR
// if not tmp then
46403: NOP4
46407: NOT
46408: IFFALSE 46412
// exit ;
46410: GO 46554
// enable_addtolog := true ;
46412: LD_ADDR_OWVAR 81
46416: PUSH
46417: LD_INT 1
46419: ST_TO_ADDR
// AddToLog ( [ ) ;
46420: LD_STRING [
46422: PPUSH
46423: NOP4
// for i in tmp do
46427: NOP4
46431: PUSH
46432: NOP4
46436: PUSH
46437: FOR_IN
46438: IFFALSE 46545
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46440: LD_STRING [
46442: PUSH
46443: NOP4
46447: PPUSH
46448: NOP4
46452: STR
46453: PUSH
46454: LD_STRING , 
46456: STR
46457: PUSH
46458: NOP4
46462: PPUSH
46463: NOP4
46467: STR
46468: PUSH
46469: LD_STRING , 
46471: STR
46472: PUSH
46473: NOP4
46477: PPUSH
46478: NOP4
46482: STR
46483: PUSH
46484: LD_STRING , 
46486: STR
46487: PUSH
46488: NOP4
46492: PPUSH
46493: NOP4
46497: STR
46498: PUSH
46499: LD_STRING , 
46501: STR
46502: PUSH
46503: NOP4
46507: PPUSH
46508: LD_INT 1
46510: PPUSH
46511: NOP4
46515: STR
46516: PUSH
46517: LD_STRING , 
46519: STR
46520: PUSH
46521: NOP4
46525: PPUSH
46526: LD_INT 2
46528: PPUSH
46529: NOP4
46533: STR
46534: PUSH
46535: LD_STRING ],
46537: STR
46538: PPUSH
46539: NOP4
// end ;
46543: GO 46437
46545: POP
46546: POP
// AddToLog ( ]; ) ;
46547: LD_STRING ];
46549: PPUSH
46550: NOP4
// end ;
46554: LD_VAR 0 2
46558: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46559: LD_INT 0
46561: PPUSH
46562: PPUSH
46563: PPUSH
46564: PPUSH
46565: PPUSH
// if not area or not rate or not max then
46566: NOP4
46570: NOT
46571: PUSH
46572: NOP4
46576: NOT
46577: OR
46578: PUSH
46579: NOP4
46583: NOT
46584: OR
46585: IFFALSE 46589
// exit ;
46587: GO 46778
// while 1 do
46589: LD_INT 1
46591: IFFALSE 46778
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46593: NOP4
46597: PUSH
46598: NOP4
46602: PPUSH
46603: LD_INT 1
46605: PPUSH
46606: NOP4
46610: PUSH
46611: LD_INT 10
46613: MUL
46614: ST_TO_ADDR
// r := rate / 10 ;
46615: NOP4
46619: PUSH
46620: NOP4
46624: PUSH
46625: LD_INT 10
46627: DIVREAL
46628: ST_TO_ADDR
// time := 1 1$00 ;
46629: NOP4
46633: PUSH
46634: LD_INT 2100
46636: ST_TO_ADDR
// if amount < min then
46637: NOP4
46641: PUSH
46642: NOP4
46646: LESS
46647: IFFALSE 46665
// r := r * 2 else
46649: NOP4
46653: PUSH
46654: NOP4
46658: PUSH
46659: LD_INT 2
46661: MUL
46662: ST_TO_ADDR
46663: GO 46691
// if amount > max then
46665: NOP4
46669: PUSH
46670: NOP4
46674: GREATER
46675: IFFALSE 46691
// r := r / 2 ;
46677: NOP4
46681: PUSH
46682: NOP4
46686: PUSH
46687: LD_INT 2
46689: DIVREAL
46690: ST_TO_ADDR
// time := time / r ;
46691: NOP4
46695: PUSH
46696: NOP4
46700: PUSH
46701: NOP4
46705: DIVREAL
46706: ST_TO_ADDR
// if time < 0 then
46707: NOP4
46711: PUSH
46712: LD_INT 0
46714: LESS
46715: IFFALSE 46732
// time := time * - 1 ;
46717: NOP4
46721: PUSH
46722: NOP4
46726: PUSH
46727: LD_INT 1
46729: NEG
46730: MUL
46731: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
46732: NOP4
46736: PUSH
46737: LD_INT 35
46739: PPUSH
46740: LD_INT 875
46742: PPUSH
46743: NOP4
46747: PLUS
46748: PPUSH
46749: NOP4
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46753: LD_INT 1
46755: PPUSH
46756: LD_INT 5
46758: PPUSH
46759: NOP4
46763: PPUSH
46764: NOP4
46768: PPUSH
46769: LD_INT 1
46771: PPUSH
46772: NOP4
// end ;
46776: GO 46589
// end ;
46778: LD_VAR 0 5
46782: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46783: LD_INT 0
46785: PPUSH
46786: PPUSH
46787: PPUSH
46788: PPUSH
46789: PPUSH
46790: PPUSH
46791: PPUSH
46792: PPUSH
// if not turrets or not factories then
46793: NOP4
46797: NOT
46798: PUSH
46799: NOP4
46803: NOT
46804: OR
46805: IFFALSE 46809
// exit ;
46807: GO 47116
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46809: NOP4
46813: PUSH
46814: LD_INT 5
46816: PUSH
46817: LD_INT 6
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 2
46826: PUSH
46827: LD_INT 4
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: LD_INT 3
46836: PUSH
46837: LD_INT 5
46839: PUSH
46840: EMPTY
46841: LIST
46842: LIST
46843: PUSH
46844: EMPTY
46845: LIST
46846: LIST
46847: LIST
46848: PUSH
46849: LD_INT 24
46851: PUSH
46852: LD_INT 25
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: LD_INT 23
46861: PUSH
46862: LD_INT 27
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: EMPTY
46870: LIST
46871: LIST
46872: PUSH
46873: LD_INT 42
46875: PUSH
46876: LD_INT 43
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: PUSH
46883: LD_INT 44
46885: PUSH
46886: LD_INT 46
46888: PUSH
46889: EMPTY
46890: LIST
46891: LIST
46892: PUSH
46893: LD_INT 45
46895: PUSH
46896: LD_INT 47
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: LIST
46907: PUSH
46908: EMPTY
46909: LIST
46910: LIST
46911: LIST
46912: ST_TO_ADDR
// result := [ ] ;
46913: NOP4
46917: PUSH
46918: EMPTY
46919: ST_TO_ADDR
// for i in turrets do
46920: NOP4
46924: PUSH
46925: NOP4
46929: PUSH
46930: FOR_IN
46931: IFFALSE 47114
// begin nat := GetNation ( i ) ;
46933: NOP4
46937: PUSH
46938: NOP4
46942: PPUSH
46943: NOP4
46947: ST_TO_ADDR
// weapon := 0 ;
46948: NOP4
46952: PUSH
46953: LD_INT 0
46955: ST_TO_ADDR
// if not nat then
46956: NOP4
46960: NOT
46961: IFFALSE 46965
// continue ;
46963: GO 46930
// for j in list [ nat ] do
46965: NOP4
46969: PUSH
46970: NOP4
46974: PUSH
46975: NOP4
46979: ARRAY
46980: PUSH
46981: FOR_IN
46982: IFFALSE 47023
// if GetBWeapon ( i ) = j [ 1 ] then
46984: NOP4
46988: PPUSH
46989: NOP4
46993: PUSH
46994: NOP4
46998: PUSH
46999: LD_INT 1
47001: ARRAY
47002: EQUAL
47003: IFFALSE 47021
// begin weapon := j [ 2 ] ;
47005: NOP4
47009: PUSH
47010: NOP4
47014: PUSH
47015: LD_INT 2
47017: ARRAY
47018: ST_TO_ADDR
// break ;
47019: GO 47023
// end ;
47021: GO 46981
47023: POP
47024: POP
// if not weapon then
47025: NOP4
47029: NOT
47030: IFFALSE 47034
// continue ;
47032: GO 46930
// for k in factories do
47034: NOP4
47038: PUSH
47039: NOP4
47043: PUSH
47044: FOR_IN
47045: IFFALSE 47110
// begin weapons := AvailableWeaponList ( k ) ;
47047: NOP4
47051: PUSH
47052: NOP4
47056: PPUSH
47057: NOP4
47061: ST_TO_ADDR
// if not weapons then
47062: NOP4
47066: NOT
47067: IFFALSE 47071
// continue ;
47069: GO 47044
// if weapon in weapons then
47071: NOP4
47075: PUSH
47076: NOP4
47080: IN
47081: IFFALSE 47108
// begin result := [ i , weapon ] ;
47083: NOP4
47087: PUSH
47088: NOP4
47092: PUSH
47093: NOP4
47097: PUSH
47098: EMPTY
47099: LIST
47100: LIST
47101: ST_TO_ADDR
// exit ;
47102: POP
47103: POP
47104: POP
47105: POP
47106: GO 47116
// end ; end ;
47108: GO 47044
47110: POP
47111: POP
// end ;
47112: GO 46930
47114: POP
47115: POP
// end ;
47116: LD_VAR 0 3
47120: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47121: LD_INT 0
47123: PPUSH
// if not side or side > 8 then
47124: NOP4
47128: NOT
47129: PUSH
47130: NOP4
47134: PUSH
47135: LD_INT 8
47137: GREATER
47138: OR
47139: IFFALSE 47143
// exit ;
47141: GO 47202
// if not range then
47143: NOP4
47147: NOT
47148: IFFALSE 47159
// range := - 12 ;
47150: NOP4
47154: PUSH
47155: LD_INT 12
47157: NEG
47158: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47159: NOP4
47163: PPUSH
47164: NOP4
47168: PPUSH
47169: NOP4
47173: PPUSH
47174: NOP4
47178: PPUSH
47179: NOP4
// RemoveSeeing ( x , y , side ) ;
47183: NOP4
47187: PPUSH
47188: NOP4
47192: PPUSH
47193: NOP4
47197: PPUSH
47198: NOP4
// end ;
47202: LD_VAR 0 5
47206: RET
// export function Video ( mode ) ; begin
47207: LD_INT 0
47209: PPUSH
// ingame_video = mode ;
47210: LD_ADDR_OWVAR 52
47214: PUSH
47215: NOP4
47219: ST_TO_ADDR
// interface_hidden = mode ;
47220: LD_ADDR_OWVAR 54
47224: PUSH
47225: NOP4
47229: ST_TO_ADDR
// end ;
47230: LD_VAR 0 2
47234: RET
// export function Join ( array , element ) ; begin
47235: LD_INT 0
47237: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47238: NOP4
47242: PUSH
47243: NOP4
47247: PPUSH
47248: NOP4
47252: PUSH
47253: LD_INT 1
47255: PLUS
47256: PPUSH
47257: NOP4
47261: PPUSH
47262: NOP4
47266: ST_TO_ADDR
// end ;
47267: LD_VAR 0 3
47271: RET
// export function JoinUnion ( array , element ) ; begin
47272: LD_INT 0
47274: PPUSH
// result := array union element ;
47275: NOP4
47279: PUSH
47280: NOP4
47284: PUSH
47285: NOP4
47289: UNION
47290: ST_TO_ADDR
// end ;
47291: LD_VAR 0 3
47295: RET
// export function GetBehemoths ( side ) ; begin
47296: LD_INT 0
47298: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
47299: NOP4
47303: PUSH
47304: LD_INT 22
47306: PUSH
47307: NOP4
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: PUSH
47316: LD_INT 31
47318: PUSH
47319: LD_INT 25
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: PPUSH
47330: NOP4
47334: ST_TO_ADDR
// end ;
47335: LD_VAR 0 2
47339: RET
// export function Shuffle ( array ) ; var i , index ; begin
47340: LD_INT 0
47342: PPUSH
47343: PPUSH
47344: PPUSH
// result := [ ] ;
47345: NOP4
47349: PUSH
47350: EMPTY
47351: ST_TO_ADDR
// if not array then
47352: NOP4
47356: NOT
47357: IFFALSE 47361
// exit ;
47359: GO 47460
// Randomize ;
47361: NOP4
// for i = array downto 1 do
47365: NOP4
47369: PUSH
47370: DOUBLE
47371: NOP4
47375: INC
47376: ST_TO_ADDR
47377: LD_INT 1
47379: PUSH
47380: FOR_DOWNTO
47381: IFFALSE 47458
// begin index := rand ( 1 , array ) ;
47383: NOP4
47387: PUSH
47388: LD_INT 1
47390: PPUSH
47391: NOP4
47395: PPUSH
47396: NOP4
47400: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47401: NOP4
47405: PUSH
47406: NOP4
47410: PPUSH
47411: NOP4
47415: PUSH
47416: LD_INT 1
47418: PLUS
47419: PPUSH
47420: NOP4
47424: PUSH
47425: NOP4
47429: ARRAY
47430: PPUSH
47431: NOP4
47435: ST_TO_ADDR
// array := Delete ( array , index ) ;
47436: NOP4
47440: PUSH
47441: NOP4
47445: PPUSH
47446: NOP4
47450: PPUSH
47451: NOP4
47455: ST_TO_ADDR
// end ;
47456: GO 47380
47458: POP
47459: POP
// end ;
47460: LD_VAR 0 2
47464: RET
// export function GetBaseMaterials ( base ) ; begin
47465: LD_INT 0
47467: PPUSH
// result := [ 0 , 0 , 0 ] ;
47468: NOP4
47472: PUSH
47473: LD_INT 0
47475: PUSH
47476: LD_INT 0
47478: PUSH
47479: LD_INT 0
47481: PUSH
47482: EMPTY
47483: LIST
47484: LIST
47485: LIST
47486: ST_TO_ADDR
// if not base then
47487: NOP4
47491: NOT
47492: IFFALSE 47496
// exit ;
47494: GO 47545
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47496: NOP4
47500: PUSH
47501: NOP4
47505: PPUSH
47506: LD_INT 1
47508: PPUSH
47509: NOP4
47513: PUSH
47514: NOP4
47518: PPUSH
47519: LD_INT 2
47521: PPUSH
47522: NOP4
47526: PUSH
47527: NOP4
47531: PPUSH
47532: LD_INT 3
47534: PPUSH
47535: NOP4
47539: PUSH
47540: EMPTY
47541: LIST
47542: LIST
47543: LIST
47544: ST_TO_ADDR
// end ;
47545: LD_VAR 0 2
47549: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47550: LD_INT 0
47552: PPUSH
47553: PPUSH
// result := array ;
47554: NOP4
47558: PUSH
47559: NOP4
47563: ST_TO_ADDR
// if size >= result then
47564: NOP4
47568: PUSH
47569: NOP4
47573: GREATEREQUAL
47574: IFFALSE 47578
// exit ;
47576: GO 47628
// if size then
47578: NOP4
47582: IFFALSE 47628
// for i := array downto size do
47584: NOP4
47588: PUSH
47589: DOUBLE
47590: NOP4
47594: INC
47595: ST_TO_ADDR
47596: NOP4
47600: PUSH
47601: FOR_DOWNTO
47602: IFFALSE 47626
// result := Delete ( result , result ) ;
47604: NOP4
47608: PUSH
47609: NOP4
47613: PPUSH
47614: NOP4
47618: PPUSH
47619: NOP4
47623: ST_TO_ADDR
47624: GO 47601
47626: POP
47627: POP
// end ;
47628: LD_VAR 0 3
47632: RET
// export function ComExit ( unit ) ; var tmp ; begin
47633: LD_INT 0
47635: PPUSH
47636: PPUSH
// if not IsInUnit ( unit ) then
47637: NOP4
47641: PPUSH
47642: NOP4
47646: NOT
47647: IFFALSE 47651
// exit ;
47649: GO 47711
// tmp := IsInUnit ( unit ) ;
47651: NOP4
47655: PUSH
47656: NOP4
47660: PPUSH
47661: NOP4
47665: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47666: NOP4
47670: PPUSH
47671: NOP4
47675: PUSH
47676: LD_INT 2
47678: EQUAL
47679: IFFALSE 47692
// ComExitVehicle ( unit ) else
47681: NOP4
47685: PPUSH
47686: NOP4
47690: GO 47701
// ComExitBuilding ( unit ) ;
47692: NOP4
47696: PPUSH
47697: NOP4
// result := tmp ;
47701: NOP4
47705: PUSH
47706: NOP4
47710: ST_TO_ADDR
// end ;
47711: LD_VAR 0 2
47715: RET
// export function ComExitAll ( units ) ; var i ; begin
47716: LD_INT 0
47718: PPUSH
47719: PPUSH
// if not units then
47720: NOP4
47724: NOT
47725: IFFALSE 47729
// exit ;
47727: GO 47755
// for i in units do
47729: NOP4
47733: PUSH
47734: NOP4
47738: PUSH
47739: FOR_IN
47740: IFFALSE 47753
// ComExit ( i ) ;
47742: NOP4
47746: PPUSH
47747: NOP4
47751: GO 47739
47753: POP
47754: POP
// end ;
47755: LD_VAR 0 2
47759: RET
// export function ResetHc ; begin
47760: LD_INT 0
47762: PPUSH
// InitHc ;
47763: NOP4
// hc_importance := 0 ;
47767: LD_ADDR_OWVAR 32
47771: PUSH
47772: LD_INT 0
47774: ST_TO_ADDR
// end ;
47775: LD_VAR 0 1
47779: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47780: LD_INT 0
47782: PPUSH
47783: PPUSH
47784: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47785: NOP4
47789: PUSH
47790: NOP4
47794: PUSH
47795: NOP4
47799: PLUS
47800: PUSH
47801: LD_INT 2
47803: DIV
47804: ST_TO_ADDR
// if _x < 0 then
47805: NOP4
47809: PUSH
47810: LD_INT 0
47812: LESS
47813: IFFALSE 47830
// _x := _x * - 1 ;
47815: NOP4
47819: PUSH
47820: NOP4
47824: PUSH
47825: LD_INT 1
47827: NEG
47828: MUL
47829: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47830: NOP4
47834: PUSH
47835: NOP4
47839: PUSH
47840: NOP4
47844: PLUS
47845: PUSH
47846: LD_INT 2
47848: DIV
47849: ST_TO_ADDR
// if _y < 0 then
47850: NOP4
47854: PUSH
47855: LD_INT 0
47857: LESS
47858: IFFALSE 47875
// _y := _y * - 1 ;
47860: NOP4
47864: PUSH
47865: NOP4
47869: PUSH
47870: LD_INT 1
47872: NEG
47873: MUL
47874: ST_TO_ADDR
// result := [ _x , _y ] ;
47875: NOP4
47879: PUSH
47880: NOP4
47884: PUSH
47885: NOP4
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: ST_TO_ADDR
// end ;
47894: LD_VAR 0 5
47898: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47899: LD_INT 0
47901: PPUSH
47902: PPUSH
47903: PPUSH
47904: PPUSH
// task := GetTaskList ( unit ) ;
47905: NOP4
47909: PUSH
47910: NOP4
47914: PPUSH
47915: NOP4
47919: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47920: NOP4
47924: NOT
47925: PUSH
47926: NOP4
47930: PPUSH
47931: NOP4
47935: PPUSH
47936: NOP4
47940: NOT
47941: AND
47942: IFFALSE 47946
// exit ;
47944: GO 48064
// if IsInArea ( unit , area ) then
47946: NOP4
47950: PPUSH
47951: NOP4
47955: PPUSH
47956: NOP4
47960: IFFALSE 47978
// begin ComMoveToArea ( unit , goAway ) ;
47962: NOP4
47966: PPUSH
47967: NOP4
47971: PPUSH
47972: NOP4
// exit ;
47976: GO 48064
// end ; if task [ 1 ] [ 1 ] <> M then
47978: NOP4
47982: PUSH
47983: LD_INT 1
47985: ARRAY
47986: PUSH
47987: LD_INT 1
47989: ARRAY
47990: PUSH
47991: LD_STRING M
47993: NONEQUAL
47994: IFFALSE 47998
// exit ;
47996: GO 48064
// x := task [ 1 ] [ 2 ] ;
47998: NOP4
48002: PUSH
48003: NOP4
48007: PUSH
48008: LD_INT 1
48010: ARRAY
48011: PUSH
48012: LD_INT 2
48014: ARRAY
48015: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48016: NOP4
48020: PUSH
48021: NOP4
48025: PUSH
48026: LD_INT 1
48028: ARRAY
48029: PUSH
48030: LD_INT 3
48032: ARRAY
48033: ST_TO_ADDR
// if InArea ( x , y , area ) then
48034: NOP4
48038: PPUSH
48039: NOP4
48043: PPUSH
48044: NOP4
48048: PPUSH
48049: NOP4
48053: IFFALSE 48064
// ComStop ( unit ) ;
48055: NOP4
48059: PPUSH
48060: NOP4
// end ;
48064: LD_VAR 0 4
48068: RET
// export function Abs ( value ) ; begin
48069: LD_INT 0
48071: PPUSH
// result := value ;
48072: NOP4
48076: PUSH
48077: NOP4
48081: ST_TO_ADDR
// if value < 0 then
48082: NOP4
48086: PUSH
48087: LD_INT 0
48089: LESS
48090: IFFALSE 48107
// result := value * - 1 ;
48092: NOP4
48096: PUSH
48097: NOP4
48101: PUSH
48102: LD_INT 1
48104: NEG
48105: MUL
48106: ST_TO_ADDR
// end ;
48107: LD_VAR 0 2
48111: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48112: LD_INT 0
48114: PPUSH
48115: PPUSH
48116: PPUSH
48117: PPUSH
48118: PPUSH
48119: PPUSH
48120: PPUSH
48121: PPUSH
// if not unit or not building then
48122: NOP4
48126: NOT
48127: PUSH
48128: NOP4
48132: NOT
48133: OR
48134: IFFALSE 48138
// exit ;
48136: GO 48364
// x := GetX ( building ) ;
48138: NOP4
48142: PUSH
48143: NOP4
48147: PPUSH
48148: NOP4
48152: ST_TO_ADDR
// y := GetY ( building ) ;
48153: NOP4
48157: PUSH
48158: NOP4
48162: PPUSH
48163: NOP4
48167: ST_TO_ADDR
// d := GetDir ( building ) ;
48168: NOP4
48172: PUSH
48173: NOP4
48177: PPUSH
48178: NOP4
48182: ST_TO_ADDR
// r := 4 ;
48183: NOP4
48187: PUSH
48188: LD_INT 4
48190: ST_TO_ADDR
// for i := 1 to 5 do
48191: NOP4
48195: PUSH
48196: DOUBLE
48197: LD_INT 1
48199: DEC
48200: ST_TO_ADDR
48201: LD_INT 5
48203: PUSH
48204: FOR_TO
48205: IFFALSE 48362
// begin _x := ShiftX ( x , d , r + i ) ;
48207: NOP4
48211: PUSH
48212: NOP4
48216: PPUSH
48217: NOP4
48221: PPUSH
48222: NOP4
48226: PUSH
48227: NOP4
48231: PLUS
48232: PPUSH
48233: NOP4
48237: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48238: NOP4
48242: PUSH
48243: NOP4
48247: PPUSH
48248: NOP4
48252: PPUSH
48253: NOP4
48257: PUSH
48258: NOP4
48262: PLUS
48263: PPUSH
48264: NOP4
48268: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48269: NOP4
48273: PPUSH
48274: NOP4
48278: PPUSH
48279: NOP4
48283: PUSH
48284: NOP4
48288: PPUSH
48289: NOP4
48293: PPUSH
48294: NOP4
48298: PPUSH
48299: NOP4
48303: PUSH
48304: LD_INT 3
48306: PUSH
48307: LD_INT 2
48309: PUSH
48310: EMPTY
48311: LIST
48312: LIST
48313: IN
48314: NOT
48315: AND
48316: IFFALSE 48360
// begin ComMoveXY ( unit , _x , _y ) ;
48318: NOP4
48322: PPUSH
48323: NOP4
48327: PPUSH
48328: NOP4
48332: PPUSH
48333: NOP4
// result := [ _x , _y ] ;
48337: NOP4
48341: PUSH
48342: NOP4
48346: PUSH
48347: NOP4
48351: PUSH
48352: EMPTY
48353: LIST
48354: LIST
48355: ST_TO_ADDR
// exit ;
48356: POP
48357: POP
48358: GO 48364
// end ; end ;
48360: GO 48204
48362: POP
48363: POP
// end ;
48364: LD_VAR 0 3
48368: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48369: LD_INT 0
48371: PPUSH
48372: PPUSH
48373: PPUSH
// result := 0 ;
48374: NOP4
48378: PUSH
48379: LD_INT 0
48381: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48382: NOP4
48386: PUSH
48387: LD_INT 0
48389: LESS
48390: PUSH
48391: NOP4
48395: PUSH
48396: LD_INT 8
48398: GREATER
48399: OR
48400: PUSH
48401: NOP4
48405: PUSH
48406: LD_INT 0
48408: LESS
48409: OR
48410: PUSH
48411: NOP4
48415: PUSH
48416: LD_INT 8
48418: GREATER
48419: OR
48420: IFFALSE 48424
// exit ;
48422: GO 48499
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48424: NOP4
48428: PUSH
48429: LD_INT 22
48431: PUSH
48432: NOP4
48436: PUSH
48437: EMPTY
48438: LIST
48439: LIST
48440: PPUSH
48441: NOP4
48445: PUSH
48446: FOR_IN
48447: IFFALSE 48497
// begin un := UnitShoot ( i ) ;
48449: NOP4
48453: PUSH
48454: NOP4
48458: PPUSH
48459: NOP4
48463: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48464: NOP4
48468: PPUSH
48469: NOP4
48473: PUSH
48474: NOP4
48478: EQUAL
48479: IFFALSE 48495
// begin result := un ;
48481: NOP4
48485: PUSH
48486: NOP4
48490: ST_TO_ADDR
// exit ;
48491: POP
48492: POP
48493: GO 48499
// end ; end ;
48495: GO 48446
48497: POP
48498: POP
// end ;
48499: LD_VAR 0 3
48503: RET
// export function GetCargoBay ( units ) ; begin
48504: LD_INT 0
48506: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48507: NOP4
48511: PUSH
48512: NOP4
48516: PPUSH
48517: LD_INT 2
48519: PUSH
48520: LD_INT 34
48522: PUSH
48523: LD_INT 12
48525: PUSH
48526: EMPTY
48527: LIST
48528: LIST
48529: PUSH
48530: LD_INT 34
48532: PUSH
48533: LD_INT 51
48535: PUSH
48536: EMPTY
48537: LIST
48538: LIST
48539: PUSH
48540: LD_INT 34
48542: PUSH
48543: LD_INT 32
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PUSH
48550: LD_INT 34
48552: PUSH
48553: NOP4
48557: PUSH
48558: EMPTY
48559: LIST
48560: LIST
48561: PUSH
48562: EMPTY
48563: LIST
48564: LIST
48565: LIST
48566: LIST
48567: LIST
48568: PPUSH
48569: NOP4
48573: ST_TO_ADDR
// end ;
48574: LD_VAR 0 2
48578: RET
// export function Negate ( value ) ; begin
48579: LD_INT 0
48581: PPUSH
// result := not value ;
48582: NOP4
48586: PUSH
48587: NOP4
48591: NOT
48592: ST_TO_ADDR
// end ;
48593: LD_VAR 0 2
48597: RET
// export function Inc ( value ) ; begin
48598: LD_INT 0
48600: PPUSH
// result := value + 1 ;
48601: NOP4
48605: PUSH
48606: NOP4
48610: PUSH
48611: LD_INT 1
48613: PLUS
48614: ST_TO_ADDR
// end ;
48615: LD_VAR 0 2
48619: RET
// export function Dec ( value ) ; begin
48620: LD_INT 0
48622: PPUSH
// result := value - 1 ;
48623: NOP4
48627: PUSH
48628: NOP4
48632: PUSH
48633: LD_INT 1
48635: MINUS
48636: ST_TO_ADDR
// end ;
48637: LD_VAR 0 2
48641: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
48642: LD_INT 0
48644: PPUSH
48645: PPUSH
48646: PPUSH
48647: PPUSH
48648: PPUSH
48649: PPUSH
48650: PPUSH
48651: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
48652: NOP4
48656: PPUSH
48657: NOP4
48661: PPUSH
48662: NOP4
48666: NOT
48667: PUSH
48668: NOP4
48672: PPUSH
48673: NOP4
48677: PPUSH
48678: NOP4
48682: NOT
48683: OR
48684: IFFALSE 48697
// begin result := - 1 ;
48686: NOP4
48690: PUSH
48691: LD_INT 1
48693: NEG
48694: ST_TO_ADDR
// exit ;
48695: GO 48932
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
48697: NOP4
48701: PUSH
48702: NOP4
48706: PPUSH
48707: NOP4
48711: PPUSH
48712: NOP4
48716: PPUSH
48717: NOP4
48721: PPUSH
48722: NOP4
48726: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
48727: NOP4
48731: PUSH
48732: NOP4
48736: PPUSH
48737: NOP4
48741: PPUSH
48742: NOP4
48746: PUSH
48747: LD_INT 1
48749: ARRAY
48750: PPUSH
48751: NOP4
48755: PUSH
48756: LD_INT 2
48758: ARRAY
48759: PPUSH
48760: NOP4
48764: ST_TO_ADDR
// distance := 9999 ;
48765: NOP4
48769: PUSH
48770: LD_INT 9999
48772: ST_TO_ADDR
// for i := 0 to 5 do
48773: NOP4
48777: PUSH
48778: DOUBLE
48779: LD_INT 0
48781: DEC
48782: ST_TO_ADDR
48783: LD_INT 5
48785: PUSH
48786: FOR_TO
48787: IFFALSE 48930
// begin _x := ShiftX ( x1 , i , centerDist ) ;
48789: NOP4
48793: PUSH
48794: NOP4
48798: PPUSH
48799: NOP4
48803: PPUSH
48804: NOP4
48808: PPUSH
48809: NOP4
48813: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
48814: NOP4
48818: PUSH
48819: NOP4
48823: PPUSH
48824: NOP4
48828: PPUSH
48829: NOP4
48833: PPUSH
48834: NOP4
48838: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48839: NOP4
48843: PPUSH
48844: NOP4
48848: PPUSH
48849: NOP4
48853: NOT
48854: IFFALSE 48858
// continue ;
48856: GO 48786
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
48858: NOP4
48862: PUSH
48863: NOP4
48867: PUSH
48868: LD_INT 1
48870: ARRAY
48871: PPUSH
48872: NOP4
48876: PUSH
48877: LD_INT 2
48879: ARRAY
48880: PPUSH
48881: NOP4
48885: PPUSH
48886: NOP4
48890: PPUSH
48891: NOP4
48895: ST_TO_ADDR
// if tmp < distance then
48896: NOP4
48900: PUSH
48901: NOP4
48905: LESS
48906: IFFALSE 48928
// begin result := i ;
48908: NOP4
48912: PUSH
48913: NOP4
48917: ST_TO_ADDR
// distance := tmp ;
48918: NOP4
48922: PUSH
48923: NOP4
48927: ST_TO_ADDR
// end ; end ;
48928: GO 48786
48930: POP
48931: POP
// end ;
48932: LD_VAR 0 5
48936: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48937: LD_INT 0
48939: PPUSH
48940: PPUSH
// if not driver or not IsInUnit ( driver ) then
48941: NOP4
48945: NOT
48946: PUSH
48947: NOP4
48951: PPUSH
48952: NOP4
48956: NOT
48957: OR
48958: IFFALSE 48962
// exit ;
48960: GO 49052
// vehicle := IsInUnit ( driver ) ;
48962: NOP4
48966: PUSH
48967: NOP4
48971: PPUSH
48972: NOP4
48976: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48977: NOP4
48981: PPUSH
48982: LD_STRING \
48984: PUSH
48985: LD_INT 0
48987: PUSH
48988: LD_INT 0
48990: PUSH
48991: LD_INT 0
48993: PUSH
48994: LD_INT 0
48996: PUSH
48997: LD_INT 0
48999: PUSH
49000: LD_INT 0
49002: PUSH
49003: EMPTY
49004: LIST
49005: LIST
49006: LIST
49007: LIST
49008: LIST
49009: LIST
49010: LIST
49011: PUSH
49012: LD_STRING E
49014: PUSH
49015: LD_INT 0
49017: PUSH
49018: LD_INT 0
49020: PUSH
49021: NOP4
49025: PUSH
49026: LD_INT 0
49028: PUSH
49029: LD_INT 0
49031: PUSH
49032: LD_INT 0
49034: PUSH
49035: EMPTY
49036: LIST
49037: LIST
49038: LIST
49039: LIST
49040: LIST
49041: LIST
49042: LIST
49043: PUSH
49044: EMPTY
49045: LIST
49046: LIST
49047: PPUSH
49048: NOP4
// end ;
49052: LD_VAR 0 2
49056: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49057: LD_INT 0
49059: PPUSH
49060: PPUSH
// if not driver or not IsInUnit ( driver ) then
49061: NOP4
49065: NOT
49066: PUSH
49067: NOP4
49071: PPUSH
49072: NOP4
49076: NOT
49077: OR
49078: IFFALSE 49082
// exit ;
49080: GO 49172
// vehicle := IsInUnit ( driver ) ;
49082: NOP4
49086: PUSH
49087: NOP4
49091: PPUSH
49092: NOP4
49096: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49097: NOP4
49101: PPUSH
49102: LD_STRING \
49104: PUSH
49105: LD_INT 0
49107: PUSH
49108: LD_INT 0
49110: PUSH
49111: LD_INT 0
49113: PUSH
49114: LD_INT 0
49116: PUSH
49117: LD_INT 0
49119: PUSH
49120: LD_INT 0
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: LIST
49127: LIST
49128: LIST
49129: LIST
49130: LIST
49131: PUSH
49132: LD_STRING E
49134: PUSH
49135: LD_INT 0
49137: PUSH
49138: LD_INT 0
49140: PUSH
49141: NOP4
49145: PUSH
49146: LD_INT 0
49148: PUSH
49149: LD_INT 0
49151: PUSH
49152: LD_INT 0
49154: PUSH
49155: EMPTY
49156: LIST
49157: LIST
49158: LIST
49159: LIST
49160: LIST
49161: LIST
49162: LIST
49163: PUSH
49164: EMPTY
49165: LIST
49166: LIST
49167: PPUSH
49168: NOP4
// end ;
49172: LD_VAR 0 2
49176: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49177: LD_INT 0
49179: PPUSH
49180: PPUSH
49181: PPUSH
// tmp := [ ] ;
49182: NOP4
49186: PUSH
49187: EMPTY
49188: ST_TO_ADDR
// for i in units do
49189: NOP4
49193: PUSH
49194: NOP4
49198: PUSH
49199: FOR_IN
49200: IFFALSE 49238
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49202: NOP4
49206: PUSH
49207: NOP4
49211: PPUSH
49212: NOP4
49216: PUSH
49217: LD_INT 1
49219: PLUS
49220: PPUSH
49221: NOP4
49225: PPUSH
49226: NOP4
49230: PPUSH
49231: NOP4
49235: ST_TO_ADDR
49236: GO 49199
49238: POP
49239: POP
// if not tmp then
49240: NOP4
49244: NOT
49245: IFFALSE 49249
// exit ;
49247: GO 49297
// if asc then
49249: NOP4
49253: IFFALSE 49277
// result := SortListByListAsc ( units , tmp ) else
49255: NOP4
49259: PUSH
49260: NOP4
49264: PPUSH
49265: NOP4
49269: PPUSH
49270: NOP4
49274: ST_TO_ADDR
49275: GO 49297
// result := SortListByListDesc ( units , tmp ) ;
49277: NOP4
49281: PUSH
49282: NOP4
49286: PPUSH
49287: NOP4
49291: PPUSH
49292: NOP4
49296: ST_TO_ADDR
// end ;
49297: LD_VAR 0 3
49301: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49302: LD_INT 0
49304: PPUSH
49305: PPUSH
// task := GetTaskList ( mech ) ;
49306: NOP4
49310: PUSH
49311: NOP4
49315: PPUSH
49316: NOP4
49320: ST_TO_ADDR
// if not task then
49321: NOP4
49325: NOT
49326: IFFALSE 49330
// exit ;
49328: GO 49372
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49330: NOP4
49334: PUSH
49335: NOP4
49339: PUSH
49340: LD_INT 1
49342: ARRAY
49343: PUSH
49344: LD_INT 1
49346: ARRAY
49347: PUSH
49348: LD_STRING r
49350: EQUAL
49351: PUSH
49352: NOP4
49356: PUSH
49357: LD_INT 1
49359: ARRAY
49360: PUSH
49361: LD_INT 4
49363: ARRAY
49364: PUSH
49365: NOP4
49369: EQUAL
49370: AND
49371: ST_TO_ADDR
// end ;
49372: LD_VAR 0 3
49376: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49377: LD_INT 0
49379: PPUSH
// SetDir ( unit , d ) ;
49380: NOP4
49384: PPUSH
49385: NOP4
49389: PPUSH
49390: NOP4
// PlaceUnitXY ( unit , x , y , mode ) ;
49394: NOP4
49398: PPUSH
49399: NOP4
49403: PPUSH
49404: NOP4
49408: PPUSH
49409: NOP4
49413: PPUSH
49414: NOP4
// end ;
49418: LD_VAR 0 6
49422: RET
// export function ToNaturalNumber ( number ) ; begin
49423: LD_INT 0
49425: PPUSH
// result := number div 1 ;
49426: NOP4
49430: PUSH
49431: NOP4
49435: PUSH
49436: LD_INT 1
49438: DIV
49439: ST_TO_ADDR
// if number < 0 then
49440: NOP4
49444: PUSH
49445: LD_INT 0
49447: LESS
49448: IFFALSE 49458
// result := 0 ;
49450: NOP4
49454: PUSH
49455: LD_INT 0
49457: ST_TO_ADDR
// end ;
49458: LD_VAR 0 2
49462: RET
// export function SortByClass ( units , class ) ; var un ; begin
49463: LD_INT 0
49465: PPUSH
49466: PPUSH
// if not units or not class then
49467: NOP4
49471: NOT
49472: PUSH
49473: NOP4
49477: NOT
49478: OR
49479: IFFALSE 49483
// exit ;
49481: GO 49578
// result := [ ] ;
49483: NOP4
49487: PUSH
49488: EMPTY
49489: ST_TO_ADDR
// for un in units do
49490: NOP4
49494: PUSH
49495: NOP4
49499: PUSH
49500: FOR_IN
49501: IFFALSE 49576
// if GetClass ( un ) = class then
49503: NOP4
49507: PPUSH
49508: NOP4
49512: PUSH
49513: NOP4
49517: EQUAL
49518: IFFALSE 49545
// result := Insert ( result , 1 , un ) else
49520: NOP4
49524: PUSH
49525: NOP4
49529: PPUSH
49530: LD_INT 1
49532: PPUSH
49533: NOP4
49537: PPUSH
49538: NOP4
49542: ST_TO_ADDR
49543: GO 49574
// result := Replace ( result , result + 1 , un ) ;
49545: NOP4
49549: PUSH
49550: NOP4
49554: PPUSH
49555: NOP4
49559: PUSH
49560: LD_INT 1
49562: PLUS
49563: PPUSH
49564: NOP4
49568: PPUSH
49569: NOP4
49573: ST_TO_ADDR
49574: GO 49500
49576: POP
49577: POP
// end ;
49578: LD_VAR 0 3
49582: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
49583: LD_INT 0
49585: PPUSH
49586: PPUSH
49587: PPUSH
49588: PPUSH
49589: PPUSH
49590: PPUSH
49591: PPUSH
// result := [ ] ;
49592: NOP4
49596: PUSH
49597: EMPTY
49598: ST_TO_ADDR
// if x - r < 0 then
49599: NOP4
49603: PUSH
49604: NOP4
49608: MINUS
49609: PUSH
49610: LD_INT 0
49612: LESS
49613: IFFALSE 49625
// min_x := 0 else
49615: NOP4
49619: PUSH
49620: LD_INT 0
49622: ST_TO_ADDR
49623: GO 49641
// min_x := x - r ;
49625: NOP4
49629: PUSH
49630: NOP4
49634: PUSH
49635: NOP4
49639: MINUS
49640: ST_TO_ADDR
// if y - r < 0 then
49641: NOP4
49645: PUSH
49646: NOP4
49650: MINUS
49651: PUSH
49652: LD_INT 0
49654: LESS
49655: IFFALSE 49667
// min_y := 0 else
49657: NOP4
49661: PUSH
49662: LD_INT 0
49664: ST_TO_ADDR
49665: GO 49683
// min_y := y - r ;
49667: NOP4
49671: PUSH
49672: NOP4
49676: PUSH
49677: NOP4
49681: MINUS
49682: ST_TO_ADDR
// max_x := x + r ;
49683: NOP4
49687: PUSH
49688: NOP4
49692: PUSH
49693: NOP4
49697: PLUS
49698: ST_TO_ADDR
// max_y := y + r ;
49699: NOP4
49703: PUSH
49704: NOP4
49708: PUSH
49709: NOP4
49713: PLUS
49714: ST_TO_ADDR
// for _x = min_x to max_x do
49715: NOP4
49719: PUSH
49720: DOUBLE
49721: NOP4
49725: DEC
49726: ST_TO_ADDR
49727: NOP4
49731: PUSH
49732: FOR_TO
49733: IFFALSE 49834
// for _y = min_y to max_y do
49735: NOP4
49739: PUSH
49740: DOUBLE
49741: NOP4
49745: DEC
49746: ST_TO_ADDR
49747: NOP4
49751: PUSH
49752: FOR_TO
49753: IFFALSE 49830
// begin if not ValidHex ( _x , _y ) then
49755: NOP4
49759: PPUSH
49760: NOP4
49764: PPUSH
49765: NOP4
49769: NOT
49770: IFFALSE 49774
// continue ;
49772: GO 49752
// if GetResourceTypeXY ( _x , _y ) then
49774: NOP4
49778: PPUSH
49779: NOP4
49783: PPUSH
49784: NOP4
49788: IFFALSE 49828
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
49790: NOP4
49794: PUSH
49795: NOP4
49799: PPUSH
49800: NOP4
49804: PUSH
49805: LD_INT 1
49807: PLUS
49808: PPUSH
49809: NOP4
49813: PUSH
49814: NOP4
49818: PUSH
49819: EMPTY
49820: LIST
49821: LIST
49822: PPUSH
49823: NOP4
49827: ST_TO_ADDR
// end ;
49828: GO 49752
49830: POP
49831: POP
49832: GO 49732
49834: POP
49835: POP
// end ;
49836: LD_VAR 0 4
49840: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
49841: LD_INT 0
49843: PPUSH
49844: PPUSH
49845: PPUSH
49846: PPUSH
49847: PPUSH
49848: PPUSH
49849: PPUSH
49850: PPUSH
// if not units then
49851: NOP4
49855: NOT
49856: IFFALSE 49860
// exit ;
49858: GO 50386
// result := UnitFilter ( units , [ f_ok ] ) ;
49860: NOP4
49864: PUSH
49865: NOP4
49869: PPUSH
49870: LD_INT 50
49872: PUSH
49873: EMPTY
49874: LIST
49875: PPUSH
49876: NOP4
49880: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49881: NOP4
49885: PUSH
49886: NOP4
49890: PUSH
49891: LD_INT 1
49893: ARRAY
49894: PPUSH
49895: NOP4
49899: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
49900: NOP4
49904: PUSH
49905: LD_INT 29
49907: PUSH
49908: NOP4
49912: PUSH
49913: LD_INT 49
49915: PUSH
49916: EMPTY
49917: LIST
49918: LIST
49919: LIST
49920: ST_TO_ADDR
// if not result then
49921: NOP4
49925: NOT
49926: IFFALSE 49930
// exit ;
49928: GO 50386
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
49930: NOP4
49934: PUSH
49935: LD_INT 81
49937: PUSH
49938: NOP4
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: PPUSH
49947: NOP4
49951: ST_TO_ADDR
// for i in result do
49952: NOP4
49956: PUSH
49957: NOP4
49961: PUSH
49962: FOR_IN
49963: IFFALSE 50384
// begin tag := GetTag ( i ) + 1 ;
49965: NOP4
49969: PUSH
49970: NOP4
49974: PPUSH
49975: NOP4
49979: PUSH
49980: LD_INT 1
49982: PLUS
49983: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
49984: NOP4
49988: PUSH
49989: NOP4
49993: PPUSH
49994: NOP4
49998: PPUSH
49999: NOP4
50003: PPUSH
50004: NOP4
50008: PPUSH
50009: LD_INT 6
50011: PPUSH
50012: NOP4
50016: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50017: NOP4
50021: PPUSH
50022: NOP4
50026: PUSH
50027: LD_INT 2
50029: EQUAL
50030: PUSH
50031: NOP4
50035: AND
50036: PUSH
50037: NOP4
50041: PPUSH
50042: NOP4
50046: PUSH
50047: NOP4
50051: IN
50052: NOT
50053: AND
50054: IFFALSE 50093
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50056: NOP4
50060: PPUSH
50061: NOP4
50065: PUSH
50066: LD_INT 1
50068: ARRAY
50069: PUSH
50070: LD_INT 1
50072: ARRAY
50073: PPUSH
50074: NOP4
50078: PUSH
50079: LD_INT 1
50081: ARRAY
50082: PUSH
50083: LD_INT 2
50085: ARRAY
50086: PPUSH
50087: NOP4
50091: GO 50382
// if path > tag then
50093: NOP4
50097: PUSH
50098: NOP4
50102: GREATER
50103: IFFALSE 50311
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
50105: NOP4
50109: PUSH
50110: NOP4
50114: PPUSH
50115: LD_INT 91
50117: PUSH
50118: NOP4
50122: PUSH
50123: LD_INT 8
50125: PUSH
50126: EMPTY
50127: LIST
50128: LIST
50129: LIST
50130: PPUSH
50131: NOP4
50135: ST_TO_ADDR
// if nearEnemy then
50136: NOP4
50140: IFFALSE 50209
// begin if GetWeapon ( i ) = ru_time_lapser then
50142: NOP4
50146: PPUSH
50147: NOP4
50151: PUSH
50152: LD_INT 49
50154: EQUAL
50155: IFFALSE 50183
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50157: NOP4
50161: PPUSH
50162: NOP4
50166: PPUSH
50167: NOP4
50171: PPUSH
50172: NOP4
50176: PPUSH
50177: NOP4
50181: GO 50207
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
50183: NOP4
50187: PPUSH
50188: NOP4
50192: PPUSH
50193: NOP4
50197: PPUSH
50198: NOP4
50202: PPUSH
50203: NOP4
// end else
50207: GO 50309
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50209: NOP4
50213: PPUSH
50214: NOP4
50218: PUSH
50219: NOP4
50223: ARRAY
50224: PUSH
50225: LD_INT 1
50227: ARRAY
50228: PPUSH
50229: NOP4
50233: PUSH
50234: NOP4
50238: ARRAY
50239: PUSH
50240: LD_INT 2
50242: ARRAY
50243: PPUSH
50244: NOP4
50248: PUSH
50249: LD_INT 6
50251: GREATER
50252: IFFALSE 50295
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50254: NOP4
50258: PPUSH
50259: NOP4
50263: PUSH
50264: NOP4
50268: ARRAY
50269: PUSH
50270: LD_INT 1
50272: ARRAY
50273: PPUSH
50274: NOP4
50278: PUSH
50279: NOP4
50283: ARRAY
50284: PUSH
50285: LD_INT 2
50287: ARRAY
50288: PPUSH
50289: NOP4
50293: GO 50309
// SetTag ( i , tag ) ;
50295: NOP4
50299: PPUSH
50300: NOP4
50304: PPUSH
50305: NOP4
// end else
50309: GO 50382
// if enemy then
50311: NOP4
50315: IFFALSE 50382
// begin if GetWeapon ( i ) = ru_time_lapser then
50317: NOP4
50321: PPUSH
50322: NOP4
50326: PUSH
50327: LD_INT 49
50329: EQUAL
50330: IFFALSE 50358
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
50332: NOP4
50336: PPUSH
50337: NOP4
50341: PPUSH
50342: NOP4
50346: PPUSH
50347: NOP4
50351: PPUSH
50352: NOP4
50356: GO 50382
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50358: NOP4
50362: PPUSH
50363: NOP4
50367: PPUSH
50368: NOP4
50372: PPUSH
50373: NOP4
50377: PPUSH
50378: NOP4
// end ; end ;
50382: GO 49962
50384: POP
50385: POP
// end ;
50386: LD_VAR 0 3
50390: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50391: LD_INT 0
50393: PPUSH
50394: PPUSH
50395: PPUSH
// if not unit or IsInUnit ( unit ) then
50396: NOP4
50400: NOT
50401: PUSH
50402: NOP4
50406: PPUSH
50407: NOP4
50411: OR
50412: IFFALSE 50416
// exit ;
50414: GO 50507
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50416: NOP4
50420: PUSH
50421: NOP4
50425: PPUSH
50426: NOP4
50430: PPUSH
50431: NOP4
50435: PPUSH
50436: LD_INT 1
50438: PPUSH
50439: NOP4
50443: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50444: NOP4
50448: PUSH
50449: NOP4
50453: PPUSH
50454: NOP4
50458: PPUSH
50459: NOP4
50463: PPUSH
50464: LD_INT 1
50466: PPUSH
50467: NOP4
50471: ST_TO_ADDR
// if ValidHex ( x , y ) then
50472: NOP4
50476: PPUSH
50477: NOP4
50481: PPUSH
50482: NOP4
50486: IFFALSE 50507
// ComTurnXY ( unit , x , y ) ;
50488: NOP4
50492: PPUSH
50493: NOP4
50497: PPUSH
50498: NOP4
50502: PPUSH
50503: NOP4
// end ;
50507: LD_VAR 0 3
50511: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50512: LD_INT 0
50514: PPUSH
50515: PPUSH
// result := false ;
50516: NOP4
50520: PUSH
50521: LD_INT 0
50523: ST_TO_ADDR
// if not units then
50524: NOP4
50528: NOT
50529: IFFALSE 50533
// exit ;
50531: GO 50578
// for i in units do
50533: NOP4
50537: PUSH
50538: NOP4
50542: PUSH
50543: FOR_IN
50544: IFFALSE 50576
// if See ( side , i ) then
50546: NOP4
50550: PPUSH
50551: NOP4
50555: PPUSH
50556: NOP4
50560: IFFALSE 50574
// begin result := true ;
50562: NOP4
50566: PUSH
50567: LD_INT 1
50569: ST_TO_ADDR
// exit ;
50570: POP
50571: POP
50572: GO 50578
// end ;
50574: GO 50543
50576: POP
50577: POP
// end ;
50578: LD_VAR 0 3
50582: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50583: LD_INT 0
50585: PPUSH
50586: PPUSH
50587: PPUSH
50588: PPUSH
// if not unit or not points then
50589: NOP4
50593: NOT
50594: PUSH
50595: NOP4
50599: NOT
50600: OR
50601: IFFALSE 50605
// exit ;
50603: GO 50695
// dist := 99999 ;
50605: NOP4
50609: PUSH
50610: LD_INT 99999
50612: ST_TO_ADDR
// for i in points do
50613: NOP4
50617: PUSH
50618: NOP4
50622: PUSH
50623: FOR_IN
50624: IFFALSE 50693
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
50626: NOP4
50630: PUSH
50631: NOP4
50635: PPUSH
50636: NOP4
50640: PUSH
50641: LD_INT 1
50643: ARRAY
50644: PPUSH
50645: NOP4
50649: PUSH
50650: LD_INT 2
50652: ARRAY
50653: PPUSH
50654: NOP4
50658: ST_TO_ADDR
// if tmpDist < dist then
50659: NOP4
50663: PUSH
50664: NOP4
50668: LESS
50669: IFFALSE 50691
// begin result := i ;
50671: NOP4
50675: PUSH
50676: NOP4
50680: ST_TO_ADDR
// dist := tmpDist ;
50681: NOP4
50685: PUSH
50686: NOP4
50690: ST_TO_ADDR
// end ; end ;
50691: GO 50623
50693: POP
50694: POP
// end ;
50695: LD_VAR 0 3
50699: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
50700: LD_INT 0
50702: PPUSH
// uc_side := side ;
50703: LD_ADDR_OWVAR 20
50707: PUSH
50708: NOP4
50712: ST_TO_ADDR
// uc_nation := 3 ;
50713: LD_ADDR_OWVAR 21
50717: PUSH
50718: LD_INT 3
50720: ST_TO_ADDR
// vc_chassis := 25 ;
50721: LD_ADDR_OWVAR 37
50725: PUSH
50726: LD_INT 25
50728: ST_TO_ADDR
// vc_engine := engine_siberite ;
50729: LD_ADDR_OWVAR 39
50733: PUSH
50734: LD_INT 3
50736: ST_TO_ADDR
// vc_control := control_computer ;
50737: LD_ADDR_OWVAR 38
50741: PUSH
50742: LD_INT 3
50744: ST_TO_ADDR
// vc_weapon := 59 ;
50745: LD_ADDR_OWVAR 40
50749: PUSH
50750: LD_INT 59
50752: ST_TO_ADDR
// result := CreateVehicle ;
50753: NOP4
50757: PUSH
50758: NOP4
50762: ST_TO_ADDR
// SetDir ( result , d ) ;
50763: NOP4
50767: PPUSH
50768: NOP4
50772: PPUSH
50773: NOP4
// PlaceUnitXY ( result , x , y , false ) ;
50777: NOP4
50781: PPUSH
50782: NOP4
50786: PPUSH
50787: NOP4
50791: PPUSH
50792: LD_INT 0
50794: PPUSH
50795: NOP4
// end ;
50799: LD_VAR 0 5
50803: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
50804: LD_INT 0
50806: PPUSH
50807: PPUSH
50808: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
50809: NOP4
50813: PUSH
50814: LD_INT 0
50816: PUSH
50817: LD_INT 0
50819: PUSH
50820: LD_INT 0
50822: PUSH
50823: LD_INT 0
50825: PUSH
50826: EMPTY
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
50832: NOP4
50836: NOT
50837: PUSH
50838: NOP4
50842: PPUSH
50843: NOP4
50847: PUSH
50848: LD_INT 12
50850: PUSH
50851: LD_INT 51
50853: PUSH
50854: LD_INT 32
50856: PUSH
50857: NOP4
50861: PUSH
50862: EMPTY
50863: LIST
50864: LIST
50865: LIST
50866: LIST
50867: IN
50868: NOT
50869: OR
50870: IFFALSE 50874
// exit ;
50872: GO 50972
// for i := 1 to 3 do
50874: NOP4
50878: PUSH
50879: DOUBLE
50880: LD_INT 1
50882: DEC
50883: ST_TO_ADDR
50884: LD_INT 3
50886: PUSH
50887: FOR_TO
50888: IFFALSE 50970
// begin tmp := GetCargo ( cargo , i ) ;
50890: NOP4
50894: PUSH
50895: NOP4
50899: PPUSH
50900: NOP4
50904: PPUSH
50905: NOP4
50909: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
50910: NOP4
50914: PUSH
50915: NOP4
50919: PPUSH
50920: NOP4
50924: PPUSH
50925: NOP4
50929: PPUSH
50930: NOP4
50934: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
50935: NOP4
50939: PUSH
50940: NOP4
50944: PPUSH
50945: LD_INT 4
50947: PPUSH
50948: NOP4
50952: PUSH
50953: LD_INT 4
50955: ARRAY
50956: PUSH
50957: NOP4
50961: PLUS
50962: PPUSH
50963: NOP4
50967: ST_TO_ADDR
// end ;
50968: GO 50887
50970: POP
50971: POP
// end ;
50972: LD_VAR 0 2
50976: RET
// export function Length ( array ) ; begin
50977: LD_INT 0
50979: PPUSH
// result := array + 0 ;
50980: NOP4
50984: PUSH
50985: NOP4
50989: PUSH
50990: LD_INT 0
50992: PLUS
50993: ST_TO_ADDR
// end ;
50994: LD_VAR 0 2
50998: RET
// export function PrepareArray ( array ) ; begin
50999: LD_INT 0
51001: PPUSH
// result := array diff 0 ;
51002: NOP4
51006: PUSH
51007: NOP4
51011: PUSH
51012: LD_INT 0
51014: DIFF
51015: ST_TO_ADDR
// if not result [ 1 ] then
51016: NOP4
51020: PUSH
51021: LD_INT 1
51023: ARRAY
51024: NOT
51025: IFFALSE 51045
// result := Delete ( result , 1 ) ;
51027: NOP4
51031: PUSH
51032: NOP4
51036: PPUSH
51037: LD_INT 1
51039: PPUSH
51040: NOP4
51044: ST_TO_ADDR
// end ; end_of_file
51045: LD_VAR 0 2
51049: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
51050: LD_INT 0
51052: PPUSH
51053: PPUSH
// skirmish := false ;
51054: NOP4
51058: PUSH
51059: LD_INT 0
51061: ST_TO_ADDR
// debug_mc := false ;
51062: NOP4
51066: PUSH
51067: LD_INT 0
51069: ST_TO_ADDR
// mc_bases := [ ] ;
51070: NOP4
51074: PUSH
51075: EMPTY
51076: ST_TO_ADDR
// mc_sides := [ ] ;
51077: NOP4
51081: PUSH
51082: EMPTY
51083: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51084: NOP4
51088: PUSH
51089: EMPTY
51090: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51091: NOP4
51095: PUSH
51096: EMPTY
51097: ST_TO_ADDR
// mc_need_heal := [ ] ;
51098: NOP4
51102: PUSH
51103: EMPTY
51104: ST_TO_ADDR
// mc_healers := [ ] ;
51105: NOP4
51109: PUSH
51110: EMPTY
51111: ST_TO_ADDR
// mc_build_list := [ ] ;
51112: NOP4
51116: PUSH
51117: EMPTY
51118: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51119: NOP4
51123: PUSH
51124: EMPTY
51125: ST_TO_ADDR
// mc_builders := [ ] ;
51126: NOP4
51130: PUSH
51131: EMPTY
51132: ST_TO_ADDR
// mc_construct_list := [ ] ;
51133: NOP4
51137: PUSH
51138: EMPTY
51139: ST_TO_ADDR
// mc_turret_list := [ ] ;
51140: NOP4
51144: PUSH
51145: EMPTY
51146: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51147: NOP4
51151: PUSH
51152: EMPTY
51153: ST_TO_ADDR
// mc_miners := [ ] ;
51154: NOP4
51158: PUSH
51159: EMPTY
51160: ST_TO_ADDR
// mc_mines := [ ] ;
51161: NOP4
51165: PUSH
51166: EMPTY
51167: ST_TO_ADDR
// mc_minefields := [ ] ;
51168: NOP4
51172: PUSH
51173: EMPTY
51174: ST_TO_ADDR
// mc_crates := [ ] ;
51175: NOP4
51179: PUSH
51180: EMPTY
51181: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51182: NOP4
51186: PUSH
51187: EMPTY
51188: ST_TO_ADDR
// mc_crates_area := [ ] ;
51189: NOP4
51193: PUSH
51194: EMPTY
51195: ST_TO_ADDR
// mc_vehicles := [ ] ;
51196: NOP4
51200: PUSH
51201: EMPTY
51202: ST_TO_ADDR
// mc_attack := [ ] ;
51203: NOP4
51207: PUSH
51208: EMPTY
51209: ST_TO_ADDR
// mc_produce := [ ] ;
51210: NOP4
51214: PUSH
51215: EMPTY
51216: ST_TO_ADDR
// mc_defender := [ ] ;
51217: NOP4
51221: PUSH
51222: EMPTY
51223: ST_TO_ADDR
// mc_parking := [ ] ;
51224: NOP4
51228: PUSH
51229: EMPTY
51230: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51231: NOP4
51235: PUSH
51236: EMPTY
51237: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51238: NOP4
51242: PUSH
51243: EMPTY
51244: ST_TO_ADDR
// mc_scan := [ ] ;
51245: NOP4
51249: PUSH
51250: EMPTY
51251: ST_TO_ADDR
// mc_scan_area := [ ] ;
51252: NOP4
51256: PUSH
51257: EMPTY
51258: ST_TO_ADDR
// mc_tech := [ ] ;
51259: NOP4
51263: PUSH
51264: EMPTY
51265: ST_TO_ADDR
// mc_class := [ ] ;
51266: NOP4
51270: PUSH
51271: EMPTY
51272: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51273: NOP4
51277: PUSH
51278: EMPTY
51279: ST_TO_ADDR
// mc_is_defending := [ ] ;
51280: NOP4
51284: PUSH
51285: EMPTY
51286: ST_TO_ADDR
// end ;
51287: LD_VAR 0 1
51291: RET
// export function MC_Kill ( base ) ; begin
51292: LD_INT 0
51294: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51295: NOP4
51299: PUSH
51300: NOP4
51304: PPUSH
51305: NOP4
51309: PPUSH
51310: EMPTY
51311: PPUSH
51312: NOP4
51316: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51317: NOP4
51321: PUSH
51322: NOP4
51326: PPUSH
51327: NOP4
51331: PPUSH
51332: EMPTY
51333: PPUSH
51334: NOP4
51338: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51339: NOP4
51343: PUSH
51344: NOP4
51348: PPUSH
51349: NOP4
51353: PPUSH
51354: EMPTY
51355: PPUSH
51356: NOP4
51360: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51361: NOP4
51365: PUSH
51366: NOP4
51370: PPUSH
51371: NOP4
51375: PPUSH
51376: EMPTY
51377: PPUSH
51378: NOP4
51382: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51383: NOP4
51387: PUSH
51388: NOP4
51392: PPUSH
51393: NOP4
51397: PPUSH
51398: EMPTY
51399: PPUSH
51400: NOP4
51404: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51405: NOP4
51409: PUSH
51410: NOP4
51414: PPUSH
51415: NOP4
51419: PPUSH
51420: EMPTY
51421: PPUSH
51422: NOP4
51426: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51427: NOP4
51431: PUSH
51432: NOP4
51436: PPUSH
51437: NOP4
51441: PPUSH
51442: EMPTY
51443: PPUSH
51444: NOP4
51448: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51449: NOP4
51453: PUSH
51454: NOP4
51458: PPUSH
51459: NOP4
51463: PPUSH
51464: EMPTY
51465: PPUSH
51466: NOP4
51470: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51471: NOP4
51475: PUSH
51476: NOP4
51480: PPUSH
51481: NOP4
51485: PPUSH
51486: EMPTY
51487: PPUSH
51488: NOP4
51492: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51493: NOP4
51497: PUSH
51498: NOP4
51502: PPUSH
51503: NOP4
51507: PPUSH
51508: EMPTY
51509: PPUSH
51510: NOP4
51514: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51515: NOP4
51519: PUSH
51520: NOP4
51524: PPUSH
51525: NOP4
51529: PPUSH
51530: EMPTY
51531: PPUSH
51532: NOP4
51536: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51537: NOP4
51541: PUSH
51542: NOP4
51546: PPUSH
51547: NOP4
51551: PPUSH
51552: LD_INT 0
51554: PPUSH
51555: NOP4
51559: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51560: NOP4
51564: PUSH
51565: NOP4
51569: PPUSH
51570: NOP4
51574: PPUSH
51575: EMPTY
51576: PPUSH
51577: NOP4
51581: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51582: NOP4
51586: PUSH
51587: NOP4
51591: PPUSH
51592: NOP4
51596: PPUSH
51597: EMPTY
51598: PPUSH
51599: NOP4
51603: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51604: NOP4
51608: PUSH
51609: NOP4
51613: PPUSH
51614: NOP4
51618: PPUSH
51619: EMPTY
51620: PPUSH
51621: NOP4
51625: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51626: NOP4
51630: PUSH
51631: NOP4
51635: PPUSH
51636: NOP4
51640: PPUSH
51641: EMPTY
51642: PPUSH
51643: NOP4
51647: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51648: NOP4
51652: PUSH
51653: NOP4
51657: PPUSH
51658: NOP4
51662: PPUSH
51663: EMPTY
51664: PPUSH
51665: NOP4
51669: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51670: NOP4
51674: PUSH
51675: NOP4
51679: PPUSH
51680: NOP4
51684: PPUSH
51685: EMPTY
51686: PPUSH
51687: NOP4
51691: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51692: NOP4
51696: PUSH
51697: NOP4
51701: PPUSH
51702: NOP4
51706: PPUSH
51707: EMPTY
51708: PPUSH
51709: NOP4
51713: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51714: NOP4
51718: PUSH
51719: NOP4
51723: PPUSH
51724: NOP4
51728: PPUSH
51729: EMPTY
51730: PPUSH
51731: NOP4
51735: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51736: NOP4
51740: PUSH
51741: NOP4
51745: PPUSH
51746: NOP4
51750: PPUSH
51751: EMPTY
51752: PPUSH
51753: NOP4
51757: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51758: NOP4
51762: PUSH
51763: NOP4
51767: PPUSH
51768: NOP4
51772: PPUSH
51773: EMPTY
51774: PPUSH
51775: NOP4
51779: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51780: NOP4
51784: PUSH
51785: NOP4
51789: PPUSH
51790: NOP4
51794: PPUSH
51795: EMPTY
51796: PPUSH
51797: NOP4
51801: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51802: NOP4
51806: PUSH
51807: NOP4
51811: PPUSH
51812: NOP4
51816: PPUSH
51817: EMPTY
51818: PPUSH
51819: NOP4
51823: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51824: NOP4
51828: PUSH
51829: NOP4
51833: PPUSH
51834: NOP4
51838: PPUSH
51839: EMPTY
51840: PPUSH
51841: NOP4
51845: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51846: NOP4
51850: PUSH
51851: NOP4
51855: PPUSH
51856: NOP4
51860: PPUSH
51861: EMPTY
51862: PPUSH
51863: NOP4
51867: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51868: NOP4
51872: PUSH
51873: NOP4
51877: PPUSH
51878: NOP4
51882: PPUSH
51883: EMPTY
51884: PPUSH
51885: NOP4
51889: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51890: NOP4
51894: PUSH
51895: NOP4
51899: PPUSH
51900: NOP4
51904: PPUSH
51905: EMPTY
51906: PPUSH
51907: NOP4
51911: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51912: NOP4
51916: PUSH
51917: NOP4
51921: PPUSH
51922: NOP4
51926: PPUSH
51927: EMPTY
51928: PPUSH
51929: NOP4
51933: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51934: NOP4
51938: PUSH
51939: NOP4
51943: PPUSH
51944: NOP4
51948: PPUSH
51949: EMPTY
51950: PPUSH
51951: NOP4
51955: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51956: NOP4
51960: PUSH
51961: NOP4
51965: PPUSH
51966: NOP4
51970: PPUSH
51971: EMPTY
51972: PPUSH
51973: NOP4
51977: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51978: NOP4
51982: PUSH
51983: NOP4
51987: PPUSH
51988: NOP4
51992: PPUSH
51993: EMPTY
51994: PPUSH
51995: NOP4
51999: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52000: NOP4
52004: PUSH
52005: NOP4
52009: PPUSH
52010: NOP4
52014: PPUSH
52015: EMPTY
52016: PPUSH
52017: NOP4
52021: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52022: NOP4
52026: PUSH
52027: NOP4
52031: PPUSH
52032: NOP4
52036: PPUSH
52037: EMPTY
52038: PPUSH
52039: NOP4
52043: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52044: NOP4
52048: PUSH
52049: NOP4
52053: PPUSH
52054: NOP4
52058: PPUSH
52059: EMPTY
52060: PPUSH
52061: NOP4
52065: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52066: NOP4
52070: PUSH
52071: NOP4
52075: PPUSH
52076: NOP4
52080: PPUSH
52081: EMPTY
52082: PPUSH
52083: NOP4
52087: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52088: NOP4
52092: PUSH
52093: NOP4
52097: PPUSH
52098: NOP4
52102: PPUSH
52103: EMPTY
52104: PPUSH
52105: NOP4
52109: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52110: NOP4
52114: PUSH
52115: NOP4
52119: PPUSH
52120: NOP4
52124: PPUSH
52125: EMPTY
52126: PPUSH
52127: NOP4
52131: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52132: NOP4
52136: PUSH
52137: NOP4
52141: PPUSH
52142: NOP4
52146: PPUSH
52147: EMPTY
52148: PPUSH
52149: NOP4
52153: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52154: NOP4
52158: PUSH
52159: NOP4
52163: PPUSH
52164: NOP4
52168: PPUSH
52169: EMPTY
52170: PPUSH
52171: NOP4
52175: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52176: NOP4
52180: PUSH
52181: NOP4
52185: PPUSH
52186: NOP4
52190: PPUSH
52191: LD_INT 0
52193: PPUSH
52194: NOP4
52198: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52199: NOP4
52203: PUSH
52204: NOP4
52208: PPUSH
52209: NOP4
52213: PPUSH
52214: LD_INT 0
52216: PPUSH
52217: NOP4
52221: ST_TO_ADDR
// end ;
52222: LD_VAR 0 2
52226: RET
// export function MC_Add ( side , units ) ; var base ; begin
52227: LD_INT 0
52229: PPUSH
52230: PPUSH
// base := mc_bases + 1 ;
52231: NOP4
52235: PUSH
52236: NOP4
52240: PUSH
52241: LD_INT 1
52243: PLUS
52244: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52245: NOP4
52249: PUSH
52250: NOP4
52254: PPUSH
52255: NOP4
52259: PPUSH
52260: NOP4
52264: PPUSH
52265: NOP4
52269: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52270: NOP4
52274: PUSH
52275: NOP4
52279: PPUSH
52280: NOP4
52284: PPUSH
52285: NOP4
52289: PPUSH
52290: NOP4
52294: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52295: NOP4
52299: PUSH
52300: NOP4
52304: PPUSH
52305: NOP4
52309: PPUSH
52310: EMPTY
52311: PPUSH
52312: NOP4
52316: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52317: NOP4
52321: PUSH
52322: NOP4
52326: PPUSH
52327: NOP4
52331: PPUSH
52332: EMPTY
52333: PPUSH
52334: NOP4
52338: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52339: NOP4
52343: PUSH
52344: NOP4
52348: PPUSH
52349: NOP4
52353: PPUSH
52354: EMPTY
52355: PPUSH
52356: NOP4
52360: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52361: NOP4
52365: PUSH
52366: NOP4
52370: PPUSH
52371: NOP4
52375: PPUSH
52376: EMPTY
52377: PPUSH
52378: NOP4
52382: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52383: NOP4
52387: PUSH
52388: NOP4
52392: PPUSH
52393: NOP4
52397: PPUSH
52398: EMPTY
52399: PPUSH
52400: NOP4
52404: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52405: NOP4
52409: PUSH
52410: NOP4
52414: PPUSH
52415: NOP4
52419: PPUSH
52420: EMPTY
52421: PPUSH
52422: NOP4
52426: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52427: NOP4
52431: PUSH
52432: NOP4
52436: PPUSH
52437: NOP4
52441: PPUSH
52442: EMPTY
52443: PPUSH
52444: NOP4
52448: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52449: NOP4
52453: PUSH
52454: NOP4
52458: PPUSH
52459: NOP4
52463: PPUSH
52464: EMPTY
52465: PPUSH
52466: NOP4
52470: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52471: NOP4
52475: PUSH
52476: NOP4
52480: PPUSH
52481: NOP4
52485: PPUSH
52486: EMPTY
52487: PPUSH
52488: NOP4
52492: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52493: NOP4
52497: PUSH
52498: NOP4
52502: PPUSH
52503: NOP4
52507: PPUSH
52508: EMPTY
52509: PPUSH
52510: NOP4
52514: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52515: NOP4
52519: PUSH
52520: NOP4
52524: PPUSH
52525: NOP4
52529: PPUSH
52530: LD_INT 0
52532: PPUSH
52533: NOP4
52537: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52538: NOP4
52542: PUSH
52543: NOP4
52547: PPUSH
52548: NOP4
52552: PPUSH
52553: EMPTY
52554: PPUSH
52555: NOP4
52559: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52560: NOP4
52564: PUSH
52565: NOP4
52569: PPUSH
52570: NOP4
52574: PPUSH
52575: EMPTY
52576: PPUSH
52577: NOP4
52581: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52582: NOP4
52586: PUSH
52587: NOP4
52591: PPUSH
52592: NOP4
52596: PPUSH
52597: EMPTY
52598: PPUSH
52599: NOP4
52603: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52604: NOP4
52608: PUSH
52609: NOP4
52613: PPUSH
52614: NOP4
52618: PPUSH
52619: EMPTY
52620: PPUSH
52621: NOP4
52625: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52626: NOP4
52630: PUSH
52631: NOP4
52635: PPUSH
52636: NOP4
52640: PPUSH
52641: EMPTY
52642: PPUSH
52643: NOP4
52647: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52648: NOP4
52652: PUSH
52653: NOP4
52657: PPUSH
52658: NOP4
52662: PPUSH
52663: EMPTY
52664: PPUSH
52665: NOP4
52669: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52670: NOP4
52674: PUSH
52675: NOP4
52679: PPUSH
52680: NOP4
52684: PPUSH
52685: EMPTY
52686: PPUSH
52687: NOP4
52691: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52692: NOP4
52696: PUSH
52697: NOP4
52701: PPUSH
52702: NOP4
52706: PPUSH
52707: EMPTY
52708: PPUSH
52709: NOP4
52713: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52714: NOP4
52718: PUSH
52719: NOP4
52723: PPUSH
52724: NOP4
52728: PPUSH
52729: EMPTY
52730: PPUSH
52731: NOP4
52735: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52736: NOP4
52740: PUSH
52741: NOP4
52745: PPUSH
52746: NOP4
52750: PPUSH
52751: EMPTY
52752: PPUSH
52753: NOP4
52757: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52758: NOP4
52762: PUSH
52763: NOP4
52767: PPUSH
52768: NOP4
52772: PPUSH
52773: EMPTY
52774: PPUSH
52775: NOP4
52779: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52780: NOP4
52784: PUSH
52785: NOP4
52789: PPUSH
52790: NOP4
52794: PPUSH
52795: EMPTY
52796: PPUSH
52797: NOP4
52801: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52802: NOP4
52806: PUSH
52807: NOP4
52811: PPUSH
52812: NOP4
52816: PPUSH
52817: EMPTY
52818: PPUSH
52819: NOP4
52823: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52824: NOP4
52828: PUSH
52829: NOP4
52833: PPUSH
52834: NOP4
52838: PPUSH
52839: EMPTY
52840: PPUSH
52841: NOP4
52845: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52846: NOP4
52850: PUSH
52851: NOP4
52855: PPUSH
52856: NOP4
52860: PPUSH
52861: EMPTY
52862: PPUSH
52863: NOP4
52867: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52868: NOP4
52872: PUSH
52873: NOP4
52877: PPUSH
52878: NOP4
52882: PPUSH
52883: EMPTY
52884: PPUSH
52885: NOP4
52889: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52890: NOP4
52894: PUSH
52895: NOP4
52899: PPUSH
52900: NOP4
52904: PPUSH
52905: EMPTY
52906: PPUSH
52907: NOP4
52911: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52912: NOP4
52916: PUSH
52917: NOP4
52921: PPUSH
52922: NOP4
52926: PPUSH
52927: EMPTY
52928: PPUSH
52929: NOP4
52933: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52934: NOP4
52938: PUSH
52939: NOP4
52943: PPUSH
52944: NOP4
52948: PPUSH
52949: EMPTY
52950: PPUSH
52951: NOP4
52955: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52956: NOP4
52960: PUSH
52961: NOP4
52965: PPUSH
52966: NOP4
52970: PPUSH
52971: EMPTY
52972: PPUSH
52973: NOP4
52977: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52978: NOP4
52982: PUSH
52983: NOP4
52987: PPUSH
52988: NOP4
52992: PPUSH
52993: EMPTY
52994: PPUSH
52995: NOP4
52999: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53000: NOP4
53004: PUSH
53005: NOP4
53009: PPUSH
53010: NOP4
53014: PPUSH
53015: EMPTY
53016: PPUSH
53017: NOP4
53021: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53022: NOP4
53026: PUSH
53027: NOP4
53031: PPUSH
53032: NOP4
53036: PPUSH
53037: EMPTY
53038: PPUSH
53039: NOP4
53043: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53044: NOP4
53048: PUSH
53049: NOP4
53053: PPUSH
53054: NOP4
53058: PPUSH
53059: EMPTY
53060: PPUSH
53061: NOP4
53065: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53066: NOP4
53070: PUSH
53071: NOP4
53075: PPUSH
53076: NOP4
53080: PPUSH
53081: EMPTY
53082: PPUSH
53083: NOP4
53087: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53088: NOP4
53092: PUSH
53093: NOP4
53097: PPUSH
53098: NOP4
53102: PPUSH
53103: EMPTY
53104: PPUSH
53105: NOP4
53109: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53110: NOP4
53114: PUSH
53115: NOP4
53119: PPUSH
53120: NOP4
53124: PPUSH
53125: EMPTY
53126: PPUSH
53127: NOP4
53131: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53132: NOP4
53136: PUSH
53137: NOP4
53141: PPUSH
53142: NOP4
53146: PPUSH
53147: EMPTY
53148: PPUSH
53149: NOP4
53153: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53154: NOP4
53158: PUSH
53159: NOP4
53163: PPUSH
53164: NOP4
53168: PPUSH
53169: LD_INT 0
53171: PPUSH
53172: NOP4
53176: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53177: NOP4
53181: PUSH
53182: NOP4
53186: PPUSH
53187: NOP4
53191: PPUSH
53192: LD_INT 0
53194: PPUSH
53195: NOP4
53199: ST_TO_ADDR
// result := base ;
53200: NOP4
53204: PUSH
53205: NOP4
53209: ST_TO_ADDR
// end ;
53210: LD_VAR 0 3
53214: RET
// export function MC_Start ( ) ; var i ; begin
53215: LD_INT 0
53217: PPUSH
53218: PPUSH
// for i = 1 to mc_bases do
53219: NOP4
53223: PUSH
53224: DOUBLE
53225: LD_INT 1
53227: DEC
53228: ST_TO_ADDR
53229: NOP4
53233: PUSH
53234: FOR_TO
53235: IFFALSE 54335
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53237: NOP4
53241: PUSH
53242: NOP4
53246: PPUSH
53247: NOP4
53251: PPUSH
53252: NOP4
53256: PUSH
53257: NOP4
53261: ARRAY
53262: PUSH
53263: LD_INT 0
53265: DIFF
53266: PPUSH
53267: NOP4
53271: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53272: NOP4
53276: PUSH
53277: NOP4
53281: PPUSH
53282: NOP4
53286: PPUSH
53287: EMPTY
53288: PPUSH
53289: NOP4
53293: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53294: NOP4
53298: PUSH
53299: NOP4
53303: PPUSH
53304: NOP4
53308: PPUSH
53309: EMPTY
53310: PPUSH
53311: NOP4
53315: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53316: NOP4
53320: PUSH
53321: NOP4
53325: PPUSH
53326: NOP4
53330: PPUSH
53331: EMPTY
53332: PPUSH
53333: NOP4
53337: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53338: NOP4
53342: PUSH
53343: NOP4
53347: PPUSH
53348: NOP4
53352: PPUSH
53353: EMPTY
53354: PUSH
53355: EMPTY
53356: PUSH
53357: EMPTY
53358: LIST
53359: LIST
53360: PPUSH
53361: NOP4
53365: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53366: NOP4
53370: PUSH
53371: NOP4
53375: PPUSH
53376: NOP4
53380: PPUSH
53381: EMPTY
53382: PPUSH
53383: NOP4
53387: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53388: NOP4
53392: PUSH
53393: NOP4
53397: PPUSH
53398: NOP4
53402: PPUSH
53403: EMPTY
53404: PPUSH
53405: NOP4
53409: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53410: NOP4
53414: PUSH
53415: NOP4
53419: PPUSH
53420: NOP4
53424: PPUSH
53425: EMPTY
53426: PPUSH
53427: NOP4
53431: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53432: NOP4
53436: PUSH
53437: NOP4
53441: PPUSH
53442: NOP4
53446: PPUSH
53447: EMPTY
53448: PPUSH
53449: NOP4
53453: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53454: NOP4
53458: PUSH
53459: NOP4
53463: PPUSH
53464: NOP4
53468: PPUSH
53469: NOP4
53473: PUSH
53474: NOP4
53478: ARRAY
53479: PPUSH
53480: LD_INT 2
53482: PUSH
53483: LD_INT 30
53485: PUSH
53486: LD_INT 32
53488: PUSH
53489: EMPTY
53490: LIST
53491: LIST
53492: PUSH
53493: LD_INT 30
53495: PUSH
53496: LD_INT 33
53498: PUSH
53499: EMPTY
53500: LIST
53501: LIST
53502: PUSH
53503: EMPTY
53504: LIST
53505: LIST
53506: LIST
53507: PPUSH
53508: NOP4
53512: PPUSH
53513: NOP4
53517: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53518: NOP4
53522: PUSH
53523: NOP4
53527: PPUSH
53528: NOP4
53532: PPUSH
53533: NOP4
53537: PUSH
53538: NOP4
53542: ARRAY
53543: PPUSH
53544: LD_INT 2
53546: PUSH
53547: LD_INT 30
53549: PUSH
53550: LD_INT 32
53552: PUSH
53553: EMPTY
53554: LIST
53555: LIST
53556: PUSH
53557: LD_INT 30
53559: PUSH
53560: LD_INT 31
53562: PUSH
53563: EMPTY
53564: LIST
53565: LIST
53566: PUSH
53567: EMPTY
53568: LIST
53569: LIST
53570: LIST
53571: PUSH
53572: LD_INT 58
53574: PUSH
53575: EMPTY
53576: LIST
53577: PUSH
53578: EMPTY
53579: LIST
53580: LIST
53581: PPUSH
53582: NOP4
53586: PPUSH
53587: NOP4
53591: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53592: NOP4
53596: PUSH
53597: NOP4
53601: PPUSH
53602: NOP4
53606: PPUSH
53607: EMPTY
53608: PPUSH
53609: NOP4
53613: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53614: NOP4
53618: PUSH
53619: NOP4
53623: PPUSH
53624: NOP4
53628: PPUSH
53629: EMPTY
53630: PPUSH
53631: NOP4
53635: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53636: NOP4
53640: PUSH
53641: NOP4
53645: PPUSH
53646: NOP4
53650: PPUSH
53651: EMPTY
53652: PPUSH
53653: NOP4
53657: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53658: NOP4
53662: PUSH
53663: NOP4
53667: PPUSH
53668: NOP4
53672: PPUSH
53673: EMPTY
53674: PPUSH
53675: NOP4
53679: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53680: NOP4
53684: PUSH
53685: NOP4
53689: PPUSH
53690: NOP4
53694: PPUSH
53695: EMPTY
53696: PPUSH
53697: NOP4
53701: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53702: NOP4
53706: PUSH
53707: NOP4
53711: PPUSH
53712: NOP4
53716: PPUSH
53717: EMPTY
53718: PPUSH
53719: NOP4
53723: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53724: NOP4
53728: PUSH
53729: NOP4
53733: PPUSH
53734: NOP4
53738: PPUSH
53739: EMPTY
53740: PPUSH
53741: NOP4
53745: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53746: NOP4
53750: PUSH
53751: NOP4
53755: PPUSH
53756: NOP4
53760: PPUSH
53761: EMPTY
53762: PPUSH
53763: NOP4
53767: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53768: NOP4
53772: PUSH
53773: NOP4
53777: PPUSH
53778: NOP4
53782: PPUSH
53783: EMPTY
53784: PPUSH
53785: NOP4
53789: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53790: NOP4
53794: PUSH
53795: NOP4
53799: PPUSH
53800: NOP4
53804: PPUSH
53805: EMPTY
53806: PPUSH
53807: NOP4
53811: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53812: NOP4
53816: PUSH
53817: NOP4
53821: PPUSH
53822: NOP4
53826: PPUSH
53827: EMPTY
53828: PPUSH
53829: NOP4
53833: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53834: NOP4
53838: PUSH
53839: NOP4
53843: PPUSH
53844: NOP4
53848: PPUSH
53849: LD_INT 0
53851: PPUSH
53852: NOP4
53856: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53857: NOP4
53861: PUSH
53862: NOP4
53866: PPUSH
53867: NOP4
53871: PPUSH
53872: LD_INT 0
53874: PPUSH
53875: NOP4
53879: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53880: NOP4
53884: PUSH
53885: NOP4
53889: PPUSH
53890: NOP4
53894: PPUSH
53895: EMPTY
53896: PPUSH
53897: NOP4
53901: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53902: NOP4
53906: PUSH
53907: NOP4
53911: PPUSH
53912: NOP4
53916: PPUSH
53917: LD_INT 0
53919: PPUSH
53920: NOP4
53924: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53925: NOP4
53929: PUSH
53930: NOP4
53934: PPUSH
53935: NOP4
53939: PPUSH
53940: EMPTY
53941: PPUSH
53942: NOP4
53946: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53947: NOP4
53951: PUSH
53952: NOP4
53956: PPUSH
53957: NOP4
53961: PPUSH
53962: LD_INT 0
53964: PPUSH
53965: NOP4
53969: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53970: NOP4
53974: PUSH
53975: NOP4
53979: PPUSH
53980: NOP4
53984: PPUSH
53985: EMPTY
53986: PPUSH
53987: NOP4
53991: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53992: NOP4
53996: PUSH
53997: NOP4
54001: PPUSH
54002: NOP4
54006: PPUSH
54007: EMPTY
54008: PPUSH
54009: NOP4
54013: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54014: NOP4
54018: PUSH
54019: NOP4
54023: PPUSH
54024: NOP4
54028: PPUSH
54029: EMPTY
54030: PPUSH
54031: NOP4
54035: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54036: NOP4
54040: PUSH
54041: NOP4
54045: PPUSH
54046: NOP4
54050: PPUSH
54051: NOP4
54055: PUSH
54056: NOP4
54060: ARRAY
54061: PPUSH
54062: LD_INT 2
54064: PUSH
54065: LD_INT 30
54067: PUSH
54068: LD_INT 6
54070: PUSH
54071: EMPTY
54072: LIST
54073: LIST
54074: PUSH
54075: LD_INT 30
54077: PUSH
54078: LD_INT 7
54080: PUSH
54081: EMPTY
54082: LIST
54083: LIST
54084: PUSH
54085: LD_INT 30
54087: PUSH
54088: LD_INT 8
54090: PUSH
54091: EMPTY
54092: LIST
54093: LIST
54094: PUSH
54095: EMPTY
54096: LIST
54097: LIST
54098: LIST
54099: LIST
54100: PPUSH
54101: NOP4
54105: PPUSH
54106: NOP4
54110: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54111: NOP4
54115: PUSH
54116: NOP4
54120: PPUSH
54121: NOP4
54125: PPUSH
54126: EMPTY
54127: PPUSH
54128: NOP4
54132: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54133: NOP4
54137: PUSH
54138: NOP4
54142: PPUSH
54143: NOP4
54147: PPUSH
54148: EMPTY
54149: PPUSH
54150: NOP4
54154: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54155: NOP4
54159: PUSH
54160: NOP4
54164: PPUSH
54165: NOP4
54169: PPUSH
54170: EMPTY
54171: PPUSH
54172: NOP4
54176: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54177: NOP4
54181: PUSH
54182: NOP4
54186: PPUSH
54187: NOP4
54191: PPUSH
54192: EMPTY
54193: PPUSH
54194: NOP4
54198: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54199: NOP4
54203: PUSH
54204: NOP4
54208: PPUSH
54209: NOP4
54213: PPUSH
54214: EMPTY
54215: PPUSH
54216: NOP4
54220: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54221: NOP4
54225: PUSH
54226: NOP4
54230: PPUSH
54231: NOP4
54235: PPUSH
54236: EMPTY
54237: PPUSH
54238: NOP4
54242: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54243: NOP4
54247: PUSH
54248: NOP4
54252: PPUSH
54253: NOP4
54257: PPUSH
54258: EMPTY
54259: PPUSH
54260: NOP4
54264: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54265: NOP4
54269: PUSH
54270: NOP4
54274: PPUSH
54275: NOP4
54279: PPUSH
54280: EMPTY
54281: PPUSH
54282: NOP4
54286: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54287: NOP4
54291: PUSH
54292: NOP4
54296: PPUSH
54297: NOP4
54301: PPUSH
54302: LD_INT 0
54304: PPUSH
54305: NOP4
54309: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54310: NOP4
54314: PUSH
54315: NOP4
54319: PPUSH
54320: NOP4
54324: PPUSH
54325: LD_INT 0
54327: PPUSH
54328: NOP4
54332: ST_TO_ADDR
// end ;
54333: GO 53234
54335: POP
54336: POP
// MC_InitSides ( ) ;
54337: NOP4
// MC_InitResearch ( ) ;
54341: NOP4
// CustomInitMacro ( ) ;
54345: NOP4
// skirmish := true ;
54349: NOP4
54353: PUSH
54354: LD_INT 1
54356: ST_TO_ADDR
// end ;
54357: LD_VAR 0 1
54361: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54362: LD_INT 0
54364: PPUSH
54365: PPUSH
54366: PPUSH
54367: PPUSH
54368: PPUSH
54369: PPUSH
// if not mc_bases then
54370: NOP4
54374: NOT
54375: IFFALSE 54379
// exit ;
54377: GO 54618
// for i = 1 to 8 do
54379: NOP4
54383: PUSH
54384: DOUBLE
54385: LD_INT 1
54387: DEC
54388: ST_TO_ADDR
54389: LD_INT 8
54391: PUSH
54392: FOR_TO
54393: IFFALSE 54419
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54395: NOP4
54399: PUSH
54400: NOP4
54404: PPUSH
54405: NOP4
54409: PPUSH
54410: EMPTY
54411: PPUSH
54412: NOP4
54416: ST_TO_ADDR
54417: GO 54392
54419: POP
54420: POP
// tmp := [ ] ;
54421: NOP4
54425: PUSH
54426: EMPTY
54427: ST_TO_ADDR
// for i = 1 to mc_sides do
54428: NOP4
54432: PUSH
54433: DOUBLE
54434: LD_INT 1
54436: DEC
54437: ST_TO_ADDR
54438: NOP4
54442: PUSH
54443: FOR_TO
54444: IFFALSE 54502
// if not mc_sides [ i ] in tmp then
54446: NOP4
54450: PUSH
54451: NOP4
54455: ARRAY
54456: PUSH
54457: NOP4
54461: IN
54462: NOT
54463: IFFALSE 54500
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54465: NOP4
54469: PUSH
54470: NOP4
54474: PPUSH
54475: NOP4
54479: PUSH
54480: LD_INT 1
54482: PLUS
54483: PPUSH
54484: NOP4
54488: PUSH
54489: NOP4
54493: ARRAY
54494: PPUSH
54495: NOP4
54499: ST_TO_ADDR
54500: GO 54443
54502: POP
54503: POP
// if not tmp then
54504: NOP4
54508: NOT
54509: IFFALSE 54513
// exit ;
54511: GO 54618
// for j in tmp do
54513: NOP4
54517: PUSH
54518: NOP4
54522: PUSH
54523: FOR_IN
54524: IFFALSE 54616
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54526: NOP4
54530: PUSH
54531: LD_INT 22
54533: PUSH
54534: NOP4
54538: PUSH
54539: EMPTY
54540: LIST
54541: LIST
54542: PPUSH
54543: NOP4
54547: ST_TO_ADDR
// if not un then
54548: NOP4
54552: NOT
54553: IFFALSE 54557
// continue ;
54555: GO 54523
// nation := GetNation ( un [ 1 ] ) ;
54557: NOP4
54561: PUSH
54562: NOP4
54566: PUSH
54567: LD_INT 1
54569: ARRAY
54570: PPUSH
54571: NOP4
54575: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54576: NOP4
54580: PUSH
54581: NOP4
54585: PPUSH
54586: NOP4
54590: PPUSH
54591: NOP4
54595: PPUSH
54596: NOP4
54600: PPUSH
54601: LD_INT 1
54603: PPUSH
54604: NOP4
54608: PPUSH
54609: NOP4
54613: ST_TO_ADDR
// end ;
54614: GO 54523
54616: POP
54617: POP
// end ;
54618: LD_VAR 0 1
54622: RET
// export function MC_InitSides ( ) ; var i ; begin
54623: LD_INT 0
54625: PPUSH
54626: PPUSH
// if not mc_bases then
54627: NOP4
54631: NOT
54632: IFFALSE 54636
// exit ;
54634: GO 54710
// for i = 1 to mc_bases do
54636: NOP4
54640: PUSH
54641: DOUBLE
54642: LD_INT 1
54644: DEC
54645: ST_TO_ADDR
54646: NOP4
54650: PUSH
54651: FOR_TO
54652: IFFALSE 54708
// if mc_bases [ i ] then
54654: NOP4
54658: PUSH
54659: NOP4
54663: ARRAY
54664: IFFALSE 54706
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54666: NOP4
54670: PUSH
54671: NOP4
54675: PPUSH
54676: NOP4
54680: PPUSH
54681: NOP4
54685: PUSH
54686: NOP4
54690: ARRAY
54691: PUSH
54692: LD_INT 1
54694: ARRAY
54695: PPUSH
54696: NOP4
54700: PPUSH
54701: NOP4
54705: ST_TO_ADDR
54706: GO 54651
54708: POP
54709: POP
// end ;
54710: LD_VAR 0 1
54714: RET
// every 0 0$03 trigger skirmish do
54715: NOP4
54719: IFFALSE 54873
54721: GO 54723
54723: DISABLE
// begin enable ;
54724: ENABLE
// MC_CheckBuildings ( ) ;
54725: NOP4
// MC_CheckPeopleLife ( ) ;
54729: NOP4
// RaiseSailEvent ( 100 ) ;
54733: LD_INT 100
54735: PPUSH
54736: NOP4
// RaiseSailEvent ( 103 ) ;
54740: LD_INT 103
54742: PPUSH
54743: NOP4
// RaiseSailEvent ( 104 ) ;
54747: LD_INT 104
54749: PPUSH
54750: NOP4
// RaiseSailEvent ( 105 ) ;
54754: LD_INT 105
54756: PPUSH
54757: NOP4
// RaiseSailEvent ( 106 ) ;
54761: LD_INT 106
54763: PPUSH
54764: NOP4
// RaiseSailEvent ( 107 ) ;
54768: LD_INT 107
54770: PPUSH
54771: NOP4
// RaiseSailEvent ( 108 ) ;
54775: LD_INT 108
54777: PPUSH
54778: NOP4
// RaiseSailEvent ( 109 ) ;
54782: LD_INT 109
54784: PPUSH
54785: NOP4
// RaiseSailEvent ( 110 ) ;
54789: LD_INT 110
54791: PPUSH
54792: NOP4
// RaiseSailEvent ( 111 ) ;
54796: LD_INT 111
54798: PPUSH
54799: NOP4
// RaiseSailEvent ( 112 ) ;
54803: LD_INT 112
54805: PPUSH
54806: NOP4
// RaiseSailEvent ( 113 ) ;
54810: LD_INT 113
54812: PPUSH
54813: NOP4
// RaiseSailEvent ( 120 ) ;
54817: LD_INT 120
54819: PPUSH
54820: NOP4
// RaiseSailEvent ( 121 ) ;
54824: LD_INT 121
54826: PPUSH
54827: NOP4
// RaiseSailEvent ( 122 ) ;
54831: LD_INT 122
54833: PPUSH
54834: NOP4
// RaiseSailEvent ( 123 ) ;
54838: LD_INT 123
54840: PPUSH
54841: NOP4
// RaiseSailEvent ( 124 ) ;
54845: LD_INT 124
54847: PPUSH
54848: NOP4
// RaiseSailEvent ( 125 ) ;
54852: LD_INT 125
54854: PPUSH
54855: NOP4
// RaiseSailEvent ( 126 ) ;
54859: LD_INT 126
54861: PPUSH
54862: NOP4
// RaiseSailEvent ( 200 ) ;
54866: LD_INT 200
54868: PPUSH
54869: NOP4
// end ;
54873: END
// on SailEvent ( event ) do begin if event < 100 then
54874: NOP4
54878: PUSH
54879: LD_INT 100
54881: LESS
54882: IFFALSE 54893
// CustomEvent ( event ) ;
54884: NOP4
54888: PPUSH
54889: NOP4
// if event = 100 then
54893: NOP4
54897: PUSH
54898: LD_INT 100
54900: EQUAL
54901: IFFALSE 54907
// MC_ClassManager ( ) ;
54903: NOP4
// if event = 101 then
54907: NOP4
54911: PUSH
54912: LD_INT 101
54914: EQUAL
54915: IFFALSE 54921
// MC_RepairBuildings ( ) ;
54917: NOP4
// if event = 102 then
54921: NOP4
54925: PUSH
54926: LD_INT 102
54928: EQUAL
54929: IFFALSE 54935
// MC_Heal ( ) ;
54931: NOP4
// if event = 103 then
54935: NOP4
54939: PUSH
54940: LD_INT 103
54942: EQUAL
54943: IFFALSE 54949
// MC_Build ( ) ;
54945: NOP4
// if event = 104 then
54949: NOP4
54953: PUSH
54954: LD_INT 104
54956: EQUAL
54957: IFFALSE 54963
// MC_TurretWeapon ( ) ;
54959: NOP4
// if event = 105 then
54963: NOP4
54967: PUSH
54968: LD_INT 105
54970: EQUAL
54971: IFFALSE 54977
// MC_BuildUpgrade ( ) ;
54973: NOP4
// if event = 106 then
54977: NOP4
54981: PUSH
54982: LD_INT 106
54984: EQUAL
54985: IFFALSE 54991
// MC_PlantMines ( ) ;
54987: NOP4
// if event = 107 then
54991: NOP4
54995: PUSH
54996: LD_INT 107
54998: EQUAL
54999: IFFALSE 55005
// MC_CollectCrates ( ) ;
55001: NOP4
// if event = 108 then
55005: NOP4
55009: PUSH
55010: LD_INT 108
55012: EQUAL
55013: IFFALSE 55019
// MC_LinkRemoteControl ( ) ;
55015: NOP4
// if event = 109 then
55019: NOP4
55023: PUSH
55024: LD_INT 109
55026: EQUAL
55027: IFFALSE 55033
// MC_ProduceVehicle ( ) ;
55029: NOP4
// if event = 110 then
55033: NOP4
55037: PUSH
55038: LD_INT 110
55040: EQUAL
55041: IFFALSE 55047
// MC_SendAttack ( ) ;
55043: NOP4
// if event = 111 then
55047: NOP4
55051: PUSH
55052: LD_INT 111
55054: EQUAL
55055: IFFALSE 55061
// MC_Defend ( ) ;
55057: NOP4
// if event = 112 then
55061: NOP4
55065: PUSH
55066: LD_INT 112
55068: EQUAL
55069: IFFALSE 55075
// MC_Research ( ) ;
55071: NOP4
// if event = 113 then
55075: NOP4
55079: PUSH
55080: LD_INT 113
55082: EQUAL
55083: IFFALSE 55089
// MC_MinesTrigger ( ) ;
55085: NOP4
// if event = 120 then
55089: NOP4
55093: PUSH
55094: LD_INT 120
55096: EQUAL
55097: IFFALSE 55103
// MC_RepairVehicle ( ) ;
55099: NOP4
// if event = 121 then
55103: NOP4
55107: PUSH
55108: LD_INT 121
55110: EQUAL
55111: IFFALSE 55117
// MC_TameApe ( ) ;
55113: NOP4
// if event = 122 then
55117: NOP4
55121: PUSH
55122: LD_INT 122
55124: EQUAL
55125: IFFALSE 55131
// MC_ChangeApeClass ( ) ;
55127: NOP4
// if event = 123 then
55131: NOP4
55135: PUSH
55136: LD_INT 123
55138: EQUAL
55139: IFFALSE 55145
// MC_Bazooka ( ) ;
55141: NOP4
// if event = 124 then
55145: NOP4
55149: PUSH
55150: LD_INT 124
55152: EQUAL
55153: IFFALSE 55159
// MC_TeleportExit ( ) ;
55155: NOP4
// if event = 125 then
55159: NOP4
55163: PUSH
55164: LD_INT 125
55166: EQUAL
55167: IFFALSE 55173
// MC_Deposits ( ) ;
55169: NOP4
// if event = 126 then
55173: NOP4
55177: PUSH
55178: LD_INT 126
55180: EQUAL
55181: IFFALSE 55187
// MC_RemoteDriver ( ) ;
55183: NOP4
// if event = 200 then
55187: NOP4
55191: PUSH
55192: LD_INT 200
55194: EQUAL
55195: IFFALSE 55201
// MC_Idle ( ) ;
55197: NOP4
// end ;
55201: PPOPN 1
55203: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55204: LD_INT 0
55206: PPUSH
55207: PPUSH
// if not mc_bases [ base ] or not tag then
55208: NOP4
55212: PUSH
55213: NOP4
55217: ARRAY
55218: NOT
55219: PUSH
55220: NOP4
55224: NOT
55225: OR
55226: IFFALSE 55230
// exit ;
55228: GO 55294
// for i in mc_bases [ base ] union mc_ape [ base ] do
55230: NOP4
55234: PUSH
55235: NOP4
55239: PUSH
55240: NOP4
55244: ARRAY
55245: PUSH
55246: NOP4
55250: PUSH
55251: NOP4
55255: ARRAY
55256: UNION
55257: PUSH
55258: FOR_IN
55259: IFFALSE 55292
// if GetTag ( i ) = tag then
55261: NOP4
55265: PPUSH
55266: NOP4
55270: PUSH
55271: NOP4
55275: EQUAL
55276: IFFALSE 55290
// SetTag ( i , 0 ) ;
55278: NOP4
55282: PPUSH
55283: LD_INT 0
55285: PPUSH
55286: NOP4
55290: GO 55258
55292: POP
55293: POP
// end ;
55294: LD_VAR 0 3
55298: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55299: LD_INT 0
55301: PPUSH
55302: PPUSH
55303: PPUSH
55304: PPUSH
55305: PPUSH
55306: PPUSH
55307: PPUSH
55308: PPUSH
// if not mc_bases then
55309: NOP4
55313: NOT
55314: IFFALSE 55318
// exit ;
55316: GO 55776
// for i = 1 to mc_bases do
55318: NOP4
55322: PUSH
55323: DOUBLE
55324: LD_INT 1
55326: DEC
55327: ST_TO_ADDR
55328: NOP4
55332: PUSH
55333: FOR_TO
55334: IFFALSE 55774
// begin tmp := MC_ClassCheckReq ( i ) ;
55336: NOP4
55340: PUSH
55341: NOP4
55345: PPUSH
55346: NOP4
55350: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55351: NOP4
55355: PUSH
55356: NOP4
55360: PPUSH
55361: NOP4
55365: PPUSH
55366: NOP4
55370: PPUSH
55371: NOP4
55375: ST_TO_ADDR
// if not tmp then
55376: NOP4
55380: NOT
55381: IFFALSE 55385
// continue ;
55383: GO 55333
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55385: NOP4
55389: PUSH
55390: NOP4
55394: PUSH
55395: NOP4
55399: ARRAY
55400: PPUSH
55401: LD_INT 2
55403: PUSH
55404: LD_INT 30
55406: PUSH
55407: LD_INT 4
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: PUSH
55414: LD_INT 30
55416: PUSH
55417: LD_INT 5
55419: PUSH
55420: EMPTY
55421: LIST
55422: LIST
55423: PUSH
55424: EMPTY
55425: LIST
55426: LIST
55427: LIST
55428: PPUSH
55429: NOP4
55433: PUSH
55434: NOP4
55438: PUSH
55439: NOP4
55443: ARRAY
55444: PPUSH
55445: LD_INT 2
55447: PUSH
55448: LD_INT 30
55450: PUSH
55451: LD_INT 0
55453: PUSH
55454: EMPTY
55455: LIST
55456: LIST
55457: PUSH
55458: LD_INT 30
55460: PUSH
55461: LD_INT 1
55463: PUSH
55464: EMPTY
55465: LIST
55466: LIST
55467: PUSH
55468: EMPTY
55469: LIST
55470: LIST
55471: LIST
55472: PPUSH
55473: NOP4
55477: PUSH
55478: NOP4
55482: PUSH
55483: NOP4
55487: ARRAY
55488: PPUSH
55489: LD_INT 30
55491: PUSH
55492: LD_INT 3
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: PPUSH
55499: NOP4
55503: PUSH
55504: NOP4
55508: PUSH
55509: NOP4
55513: ARRAY
55514: PPUSH
55515: LD_INT 2
55517: PUSH
55518: LD_INT 30
55520: PUSH
55521: LD_INT 6
55523: PUSH
55524: EMPTY
55525: LIST
55526: LIST
55527: PUSH
55528: LD_INT 30
55530: PUSH
55531: LD_INT 7
55533: PUSH
55534: EMPTY
55535: LIST
55536: LIST
55537: PUSH
55538: LD_INT 30
55540: PUSH
55541: LD_INT 8
55543: PUSH
55544: EMPTY
55545: LIST
55546: LIST
55547: PUSH
55548: EMPTY
55549: LIST
55550: LIST
55551: LIST
55552: LIST
55553: PPUSH
55554: NOP4
55558: PUSH
55559: EMPTY
55560: LIST
55561: LIST
55562: LIST
55563: LIST
55564: ST_TO_ADDR
// for j = 1 to 4 do
55565: NOP4
55569: PUSH
55570: DOUBLE
55571: LD_INT 1
55573: DEC
55574: ST_TO_ADDR
55575: LD_INT 4
55577: PUSH
55578: FOR_TO
55579: IFFALSE 55770
// begin if not tmp [ j ] then
55581: NOP4
55585: PUSH
55586: NOP4
55590: ARRAY
55591: NOT
55592: IFFALSE 55596
// continue ;
55594: GO 55578
// for p in tmp [ j ] do
55596: NOP4
55600: PUSH
55601: NOP4
55605: PUSH
55606: NOP4
55610: ARRAY
55611: PUSH
55612: FOR_IN
55613: IFFALSE 55766
// begin if not b [ j ] then
55615: NOP4
55619: PUSH
55620: NOP4
55624: ARRAY
55625: NOT
55626: IFFALSE 55630
// break ;
55628: GO 55766
// e := 0 ;
55630: NOP4
55634: PUSH
55635: LD_INT 0
55637: ST_TO_ADDR
// for k in b [ j ] do
55638: NOP4
55642: PUSH
55643: NOP4
55647: PUSH
55648: NOP4
55652: ARRAY
55653: PUSH
55654: FOR_IN
55655: IFFALSE 55682
// if IsNotFull ( k ) then
55657: NOP4
55661: PPUSH
55662: NOP4
55666: IFFALSE 55680
// begin e := k ;
55668: NOP4
55672: PUSH
55673: NOP4
55677: ST_TO_ADDR
// break ;
55678: GO 55682
// end ;
55680: GO 55654
55682: POP
55683: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55684: NOP4
55688: PUSH
55689: NOP4
55693: PPUSH
55694: NOP4
55698: PPUSH
55699: NOP4
55703: NOT
55704: AND
55705: IFFALSE 55764
// begin if IsInUnit ( p ) then
55707: NOP4
55711: PPUSH
55712: NOP4
55716: IFFALSE 55727
// ComExitBuilding ( p ) ;
55718: NOP4
55722: PPUSH
55723: NOP4
// ComEnterUnit ( p , e ) ;
55727: NOP4
55731: PPUSH
55732: NOP4
55736: PPUSH
55737: NOP4
// AddComChangeProfession ( p , j ) ;
55741: NOP4
55745: PPUSH
55746: NOP4
55750: PPUSH
55751: NOP4
// AddComExitBuilding ( p ) ;
55755: NOP4
55759: PPUSH
55760: NOP4
// end ; end ;
55764: GO 55612
55766: POP
55767: POP
// end ;
55768: GO 55578
55770: POP
55771: POP
// end ;
55772: GO 55333
55774: POP
55775: POP
// end ;
55776: LD_VAR 0 1
55780: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55781: LD_INT 0
55783: PPUSH
55784: PPUSH
55785: PPUSH
55786: PPUSH
55787: PPUSH
55788: PPUSH
55789: PPUSH
55790: PPUSH
55791: PPUSH
55792: PPUSH
55793: PPUSH
55794: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55795: NOP4
55799: NOT
55800: PUSH
55801: NOP4
55805: PUSH
55806: NOP4
55810: ARRAY
55811: NOT
55812: OR
55813: PUSH
55814: NOP4
55818: PUSH
55819: NOP4
55823: ARRAY
55824: PPUSH
55825: LD_INT 2
55827: PUSH
55828: LD_INT 30
55830: PUSH
55831: LD_INT 0
55833: PUSH
55834: EMPTY
55835: LIST
55836: LIST
55837: PUSH
55838: LD_INT 30
55840: PUSH
55841: LD_INT 1
55843: PUSH
55844: EMPTY
55845: LIST
55846: LIST
55847: PUSH
55848: EMPTY
55849: LIST
55850: LIST
55851: LIST
55852: PPUSH
55853: NOP4
55857: NOT
55858: OR
55859: IFFALSE 55863
// exit ;
55861: GO 59366
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55863: NOP4
55867: PUSH
55868: NOP4
55872: PUSH
55873: NOP4
55877: ARRAY
55878: PPUSH
55879: LD_INT 2
55881: PUSH
55882: LD_INT 25
55884: PUSH
55885: LD_INT 1
55887: PUSH
55888: EMPTY
55889: LIST
55890: LIST
55891: PUSH
55892: LD_INT 25
55894: PUSH
55895: LD_INT 2
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: PUSH
55902: LD_INT 25
55904: PUSH
55905: LD_INT 3
55907: PUSH
55908: EMPTY
55909: LIST
55910: LIST
55911: PUSH
55912: LD_INT 25
55914: PUSH
55915: LD_INT 4
55917: PUSH
55918: EMPTY
55919: LIST
55920: LIST
55921: PUSH
55922: LD_INT 25
55924: PUSH
55925: LD_INT 5
55927: PUSH
55928: EMPTY
55929: LIST
55930: LIST
55931: PUSH
55932: LD_INT 25
55934: PUSH
55935: LD_INT 8
55937: PUSH
55938: EMPTY
55939: LIST
55940: LIST
55941: PUSH
55942: LD_INT 25
55944: PUSH
55945: LD_INT 9
55947: PUSH
55948: EMPTY
55949: LIST
55950: LIST
55951: PUSH
55952: EMPTY
55953: LIST
55954: LIST
55955: LIST
55956: LIST
55957: LIST
55958: LIST
55959: LIST
55960: LIST
55961: PPUSH
55962: NOP4
55966: ST_TO_ADDR
// if not tmp then
55967: NOP4
55971: NOT
55972: IFFALSE 55976
// exit ;
55974: GO 59366
// for i in tmp do
55976: NOP4
55980: PUSH
55981: NOP4
55985: PUSH
55986: FOR_IN
55987: IFFALSE 56018
// if GetTag ( i ) then
55989: NOP4
55993: PPUSH
55994: NOP4
55998: IFFALSE 56016
// tmp := tmp diff i ;
56000: NOP4
56004: PUSH
56005: NOP4
56009: PUSH
56010: NOP4
56014: DIFF
56015: ST_TO_ADDR
56016: GO 55986
56018: POP
56019: POP
// if not tmp then
56020: NOP4
56024: NOT
56025: IFFALSE 56029
// exit ;
56027: GO 59366
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56029: NOP4
56033: PUSH
56034: NOP4
56038: PUSH
56039: NOP4
56043: ARRAY
56044: PPUSH
56045: LD_INT 2
56047: PUSH
56048: LD_INT 25
56050: PUSH
56051: LD_INT 1
56053: PUSH
56054: EMPTY
56055: LIST
56056: LIST
56057: PUSH
56058: LD_INT 25
56060: PUSH
56061: LD_INT 5
56063: PUSH
56064: EMPTY
56065: LIST
56066: LIST
56067: PUSH
56068: LD_INT 25
56070: PUSH
56071: LD_INT 8
56073: PUSH
56074: EMPTY
56075: LIST
56076: LIST
56077: PUSH
56078: LD_INT 25
56080: PUSH
56081: LD_INT 9
56083: PUSH
56084: EMPTY
56085: LIST
56086: LIST
56087: PUSH
56088: EMPTY
56089: LIST
56090: LIST
56091: LIST
56092: LIST
56093: LIST
56094: PPUSH
56095: NOP4
56099: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56100: NOP4
56104: PUSH
56105: NOP4
56109: PUSH
56110: NOP4
56114: ARRAY
56115: PPUSH
56116: LD_INT 25
56118: PUSH
56119: LD_INT 2
56121: PUSH
56122: EMPTY
56123: LIST
56124: LIST
56125: PPUSH
56126: NOP4
56130: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56131: NOP4
56135: PUSH
56136: NOP4
56140: PUSH
56141: NOP4
56145: ARRAY
56146: PPUSH
56147: LD_INT 25
56149: PUSH
56150: LD_INT 3
56152: PUSH
56153: EMPTY
56154: LIST
56155: LIST
56156: PPUSH
56157: NOP4
56161: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56162: NOP4
56166: PUSH
56167: NOP4
56171: PUSH
56172: NOP4
56176: ARRAY
56177: PPUSH
56178: LD_INT 25
56180: PUSH
56181: LD_INT 4
56183: PUSH
56184: EMPTY
56185: LIST
56186: LIST
56187: PUSH
56188: LD_INT 24
56190: PUSH
56191: LD_INT 251
56193: PUSH
56194: EMPTY
56195: LIST
56196: LIST
56197: PUSH
56198: EMPTY
56199: LIST
56200: LIST
56201: PPUSH
56202: NOP4
56206: ST_TO_ADDR
// if mc_is_defending [ base ] then
56207: NOP4
56211: PUSH
56212: NOP4
56216: ARRAY
56217: IFFALSE 56678
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56219: NOP4
56223: PUSH
56224: NOP4
56228: PPUSH
56229: NOP4
56233: PPUSH
56234: LD_INT 4
56236: PPUSH
56237: NOP4
56241: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56242: NOP4
56246: PUSH
56247: NOP4
56251: PUSH
56252: NOP4
56256: ARRAY
56257: PPUSH
56258: LD_INT 2
56260: PUSH
56261: LD_INT 30
56263: PUSH
56264: LD_INT 4
56266: PUSH
56267: EMPTY
56268: LIST
56269: LIST
56270: PUSH
56271: LD_INT 30
56273: PUSH
56274: LD_INT 5
56276: PUSH
56277: EMPTY
56278: LIST
56279: LIST
56280: PUSH
56281: EMPTY
56282: LIST
56283: LIST
56284: LIST
56285: PPUSH
56286: NOP4
56290: ST_TO_ADDR
// if not b then
56291: NOP4
56295: NOT
56296: IFFALSE 56300
// exit ;
56298: GO 59366
// p := [ ] ;
56300: NOP4
56304: PUSH
56305: EMPTY
56306: ST_TO_ADDR
// if sci >= 2 then
56307: NOP4
56311: PUSH
56312: LD_INT 2
56314: GREATEREQUAL
56315: IFFALSE 56346
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56317: NOP4
56321: PUSH
56322: NOP4
56326: PUSH
56327: LD_INT 1
56329: ARRAY
56330: PUSH
56331: NOP4
56335: PUSH
56336: LD_INT 2
56338: ARRAY
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: ST_TO_ADDR
56344: GO 56407
// if sci = 1 then
56346: NOP4
56350: PUSH
56351: LD_INT 1
56353: EQUAL
56354: IFFALSE 56375
// sci := [ sci [ 1 ] ] else
56356: NOP4
56360: PUSH
56361: NOP4
56365: PUSH
56366: LD_INT 1
56368: ARRAY
56369: PUSH
56370: EMPTY
56371: LIST
56372: ST_TO_ADDR
56373: GO 56407
// if sci = 0 then
56375: NOP4
56379: PUSH
56380: LD_INT 0
56382: EQUAL
56383: IFFALSE 56407
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56385: NOP4
56389: PUSH
56390: NOP4
56394: PPUSH
56395: LD_INT 4
56397: PPUSH
56398: NOP4
56402: PUSH
56403: LD_INT 1
56405: ARRAY
56406: ST_TO_ADDR
// if eng > 4 then
56407: NOP4
56411: PUSH
56412: LD_INT 4
56414: GREATER
56415: IFFALSE 56461
// for i = eng downto 4 do
56417: NOP4
56421: PUSH
56422: DOUBLE
56423: NOP4
56427: INC
56428: ST_TO_ADDR
56429: LD_INT 4
56431: PUSH
56432: FOR_DOWNTO
56433: IFFALSE 56459
// eng := eng diff eng [ i ] ;
56435: NOP4
56439: PUSH
56440: NOP4
56444: PUSH
56445: NOP4
56449: PUSH
56450: NOP4
56454: ARRAY
56455: DIFF
56456: ST_TO_ADDR
56457: GO 56432
56459: POP
56460: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56461: NOP4
56465: PUSH
56466: NOP4
56470: PUSH
56471: NOP4
56475: PUSH
56476: NOP4
56480: UNION
56481: PUSH
56482: NOP4
56486: UNION
56487: PUSH
56488: NOP4
56492: UNION
56493: DIFF
56494: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56495: NOP4
56499: PUSH
56500: NOP4
56504: PUSH
56505: NOP4
56509: ARRAY
56510: PPUSH
56511: LD_INT 2
56513: PUSH
56514: LD_INT 30
56516: PUSH
56517: LD_INT 32
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: PUSH
56524: LD_INT 30
56526: PUSH
56527: LD_INT 31
56529: PUSH
56530: EMPTY
56531: LIST
56532: LIST
56533: PUSH
56534: EMPTY
56535: LIST
56536: LIST
56537: LIST
56538: PPUSH
56539: NOP4
56543: PUSH
56544: NOP4
56548: PUSH
56549: NOP4
56553: ARRAY
56554: PPUSH
56555: LD_INT 2
56557: PUSH
56558: LD_INT 30
56560: PUSH
56561: LD_INT 4
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: PUSH
56568: LD_INT 30
56570: PUSH
56571: LD_INT 5
56573: PUSH
56574: EMPTY
56575: LIST
56576: LIST
56577: PUSH
56578: EMPTY
56579: LIST
56580: LIST
56581: LIST
56582: PPUSH
56583: NOP4
56587: PUSH
56588: LD_INT 6
56590: MUL
56591: PLUS
56592: ST_TO_ADDR
// if bcount < tmp then
56593: NOP4
56597: PUSH
56598: NOP4
56602: LESS
56603: IFFALSE 56649
// for i = tmp downto bcount do
56605: NOP4
56609: PUSH
56610: DOUBLE
56611: NOP4
56615: INC
56616: ST_TO_ADDR
56617: NOP4
56621: PUSH
56622: FOR_DOWNTO
56623: IFFALSE 56647
// tmp := Delete ( tmp , tmp ) ;
56625: NOP4
56629: PUSH
56630: NOP4
56634: PPUSH
56635: NOP4
56639: PPUSH
56640: NOP4
56644: ST_TO_ADDR
56645: GO 56622
56647: POP
56648: POP
// result := [ tmp , 0 , 0 , p ] ;
56649: NOP4
56653: PUSH
56654: NOP4
56658: PUSH
56659: LD_INT 0
56661: PUSH
56662: LD_INT 0
56664: PUSH
56665: NOP4
56669: PUSH
56670: EMPTY
56671: LIST
56672: LIST
56673: LIST
56674: LIST
56675: ST_TO_ADDR
// exit ;
56676: GO 59366
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56678: NOP4
56682: PUSH
56683: NOP4
56687: ARRAY
56688: PPUSH
56689: LD_INT 2
56691: PUSH
56692: LD_INT 30
56694: PUSH
56695: LD_INT 6
56697: PUSH
56698: EMPTY
56699: LIST
56700: LIST
56701: PUSH
56702: LD_INT 30
56704: PUSH
56705: LD_INT 7
56707: PUSH
56708: EMPTY
56709: LIST
56710: LIST
56711: PUSH
56712: LD_INT 30
56714: PUSH
56715: LD_INT 8
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: PUSH
56722: EMPTY
56723: LIST
56724: LIST
56725: LIST
56726: LIST
56727: PPUSH
56728: NOP4
56732: NOT
56733: PUSH
56734: NOP4
56738: PUSH
56739: NOP4
56743: ARRAY
56744: PPUSH
56745: LD_INT 30
56747: PUSH
56748: LD_INT 3
56750: PUSH
56751: EMPTY
56752: LIST
56753: LIST
56754: PPUSH
56755: NOP4
56759: NOT
56760: AND
56761: IFFALSE 56833
// begin if eng = tmp then
56763: NOP4
56767: PUSH
56768: NOP4
56772: EQUAL
56773: IFFALSE 56777
// exit ;
56775: GO 59366
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56777: NOP4
56781: PUSH
56782: NOP4
56786: PPUSH
56787: NOP4
56791: PPUSH
56792: LD_INT 1
56794: PPUSH
56795: NOP4
56799: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56800: NOP4
56804: PUSH
56805: LD_INT 0
56807: PUSH
56808: NOP4
56812: PUSH
56813: NOP4
56817: DIFF
56818: PUSH
56819: LD_INT 0
56821: PUSH
56822: LD_INT 0
56824: PUSH
56825: EMPTY
56826: LIST
56827: LIST
56828: LIST
56829: LIST
56830: ST_TO_ADDR
// exit ;
56831: GO 59366
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56833: NOP4
56837: PUSH
56838: NOP4
56842: PUSH
56843: NOP4
56847: ARRAY
56848: ARRAY
56849: PUSH
56850: NOP4
56854: PUSH
56855: NOP4
56859: ARRAY
56860: PPUSH
56861: LD_INT 2
56863: PUSH
56864: LD_INT 30
56866: PUSH
56867: LD_INT 6
56869: PUSH
56870: EMPTY
56871: LIST
56872: LIST
56873: PUSH
56874: LD_INT 30
56876: PUSH
56877: LD_INT 7
56879: PUSH
56880: EMPTY
56881: LIST
56882: LIST
56883: PUSH
56884: LD_INT 30
56886: PUSH
56887: LD_INT 8
56889: PUSH
56890: EMPTY
56891: LIST
56892: LIST
56893: PUSH
56894: EMPTY
56895: LIST
56896: LIST
56897: LIST
56898: LIST
56899: PPUSH
56900: NOP4
56904: AND
56905: PUSH
56906: NOP4
56910: PUSH
56911: NOP4
56915: ARRAY
56916: PPUSH
56917: LD_INT 30
56919: PUSH
56920: LD_INT 3
56922: PUSH
56923: EMPTY
56924: LIST
56925: LIST
56926: PPUSH
56927: NOP4
56931: NOT
56932: AND
56933: IFFALSE 57147
// begin if sci >= 6 then
56935: NOP4
56939: PUSH
56940: LD_INT 6
56942: GREATEREQUAL
56943: IFFALSE 56947
// exit ;
56945: GO 59366
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56947: NOP4
56951: PUSH
56952: NOP4
56956: PPUSH
56957: NOP4
56961: PPUSH
56962: LD_INT 2
56964: PPUSH
56965: NOP4
56969: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56970: NOP4
56974: PUSH
56975: NOP4
56979: PUSH
56980: NOP4
56984: DIFF
56985: PPUSH
56986: LD_INT 4
56988: PPUSH
56989: NOP4
56993: ST_TO_ADDR
// p := [ ] ;
56994: NOP4
56998: PUSH
56999: EMPTY
57000: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57001: NOP4
57005: PUSH
57006: LD_INT 6
57008: LESS
57009: PUSH
57010: NOP4
57014: PUSH
57015: LD_INT 6
57017: GREATER
57018: AND
57019: IFFALSE 57100
// begin for i = 1 to 6 - sci do
57021: NOP4
57025: PUSH
57026: DOUBLE
57027: LD_INT 1
57029: DEC
57030: ST_TO_ADDR
57031: LD_INT 6
57033: PUSH
57034: NOP4
57038: MINUS
57039: PUSH
57040: FOR_TO
57041: IFFALSE 57096
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57043: NOP4
57047: PUSH
57048: NOP4
57052: PPUSH
57053: NOP4
57057: PUSH
57058: LD_INT 1
57060: PLUS
57061: PPUSH
57062: NOP4
57066: PUSH
57067: LD_INT 1
57069: ARRAY
57070: PPUSH
57071: NOP4
57075: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57076: NOP4
57080: PUSH
57081: NOP4
57085: PPUSH
57086: LD_INT 1
57088: PPUSH
57089: NOP4
57093: ST_TO_ADDR
// end ;
57094: GO 57040
57096: POP
57097: POP
// end else
57098: GO 57120
// if sort then
57100: NOP4
57104: IFFALSE 57120
// p := sort [ 1 ] ;
57106: NOP4
57110: PUSH
57111: NOP4
57115: PUSH
57116: LD_INT 1
57118: ARRAY
57119: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57120: NOP4
57124: PUSH
57125: LD_INT 0
57127: PUSH
57128: LD_INT 0
57130: PUSH
57131: LD_INT 0
57133: PUSH
57134: NOP4
57138: PUSH
57139: EMPTY
57140: LIST
57141: LIST
57142: LIST
57143: LIST
57144: ST_TO_ADDR
// exit ;
57145: GO 59366
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57147: NOP4
57151: PUSH
57152: NOP4
57156: PUSH
57157: NOP4
57161: ARRAY
57162: ARRAY
57163: PUSH
57164: NOP4
57168: PUSH
57169: NOP4
57173: ARRAY
57174: PPUSH
57175: LD_INT 2
57177: PUSH
57178: LD_INT 30
57180: PUSH
57181: LD_INT 6
57183: PUSH
57184: EMPTY
57185: LIST
57186: LIST
57187: PUSH
57188: LD_INT 30
57190: PUSH
57191: LD_INT 7
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PUSH
57198: LD_INT 30
57200: PUSH
57201: LD_INT 8
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PUSH
57208: EMPTY
57209: LIST
57210: LIST
57211: LIST
57212: LIST
57213: PPUSH
57214: NOP4
57218: AND
57219: PUSH
57220: NOP4
57224: PUSH
57225: NOP4
57229: ARRAY
57230: PPUSH
57231: LD_INT 30
57233: PUSH
57234: LD_INT 3
57236: PUSH
57237: EMPTY
57238: LIST
57239: LIST
57240: PPUSH
57241: NOP4
57245: AND
57246: IFFALSE 57980
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57248: NOP4
57252: PUSH
57253: NOP4
57257: PPUSH
57258: NOP4
57262: PPUSH
57263: LD_INT 3
57265: PPUSH
57266: NOP4
57270: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57271: NOP4
57275: PUSH
57276: LD_INT 0
57278: PUSH
57279: LD_INT 0
57281: PUSH
57282: LD_INT 0
57284: PUSH
57285: LD_INT 0
57287: PUSH
57288: EMPTY
57289: LIST
57290: LIST
57291: LIST
57292: LIST
57293: ST_TO_ADDR
// if not eng then
57294: NOP4
57298: NOT
57299: IFFALSE 57362
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57301: NOP4
57305: PUSH
57306: NOP4
57310: PPUSH
57311: LD_INT 2
57313: PPUSH
57314: NOP4
57318: PUSH
57319: LD_INT 1
57321: ARRAY
57322: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57323: NOP4
57327: PUSH
57328: NOP4
57332: PPUSH
57333: LD_INT 2
57335: PPUSH
57336: NOP4
57340: PPUSH
57341: NOP4
57345: ST_TO_ADDR
// tmp := tmp diff p ;
57346: NOP4
57350: PUSH
57351: NOP4
57355: PUSH
57356: NOP4
57360: DIFF
57361: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57362: NOP4
57366: PUSH
57367: NOP4
57371: PUSH
57372: LD_INT 6
57374: LESS
57375: AND
57376: IFFALSE 57564
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57378: NOP4
57382: PUSH
57383: NOP4
57387: PUSH
57388: NOP4
57392: PUSH
57393: NOP4
57397: UNION
57398: DIFF
57399: PPUSH
57400: LD_INT 4
57402: PPUSH
57403: NOP4
57407: ST_TO_ADDR
// p := [ ] ;
57408: NOP4
57412: PUSH
57413: EMPTY
57414: ST_TO_ADDR
// if sort then
57415: NOP4
57419: IFFALSE 57535
// for i = 1 to 6 - sci do
57421: NOP4
57425: PUSH
57426: DOUBLE
57427: LD_INT 1
57429: DEC
57430: ST_TO_ADDR
57431: LD_INT 6
57433: PUSH
57434: NOP4
57438: MINUS
57439: PUSH
57440: FOR_TO
57441: IFFALSE 57533
// begin if i = sort then
57443: NOP4
57447: PUSH
57448: NOP4
57452: EQUAL
57453: IFFALSE 57457
// break ;
57455: GO 57533
// if GetClass ( i ) = 4 then
57457: NOP4
57461: PPUSH
57462: NOP4
57466: PUSH
57467: LD_INT 4
57469: EQUAL
57470: IFFALSE 57474
// continue ;
57472: GO 57440
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57474: NOP4
57478: PUSH
57479: NOP4
57483: PPUSH
57484: NOP4
57488: PUSH
57489: LD_INT 1
57491: PLUS
57492: PPUSH
57493: NOP4
57497: PUSH
57498: NOP4
57502: ARRAY
57503: PPUSH
57504: NOP4
57508: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57509: NOP4
57513: PUSH
57514: NOP4
57518: PUSH
57519: NOP4
57523: PUSH
57524: NOP4
57528: ARRAY
57529: DIFF
57530: ST_TO_ADDR
// end ;
57531: GO 57440
57533: POP
57534: POP
// if p then
57535: NOP4
57539: IFFALSE 57564
// result := Replace ( result , 4 , p ) ;
57541: NOP4
57545: PUSH
57546: NOP4
57550: PPUSH
57551: LD_INT 4
57553: PPUSH
57554: NOP4
57558: PPUSH
57559: NOP4
57563: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57564: NOP4
57568: PUSH
57569: NOP4
57573: PUSH
57574: LD_INT 6
57576: LESS
57577: AND
57578: IFFALSE 57766
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57580: NOP4
57584: PUSH
57585: NOP4
57589: PUSH
57590: NOP4
57594: PUSH
57595: NOP4
57599: UNION
57600: DIFF
57601: PPUSH
57602: LD_INT 3
57604: PPUSH
57605: NOP4
57609: ST_TO_ADDR
// p := [ ] ;
57610: NOP4
57614: PUSH
57615: EMPTY
57616: ST_TO_ADDR
// if sort then
57617: NOP4
57621: IFFALSE 57737
// for i = 1 to 6 - mech do
57623: NOP4
57627: PUSH
57628: DOUBLE
57629: LD_INT 1
57631: DEC
57632: ST_TO_ADDR
57633: LD_INT 6
57635: PUSH
57636: NOP4
57640: MINUS
57641: PUSH
57642: FOR_TO
57643: IFFALSE 57735
// begin if i = sort then
57645: NOP4
57649: PUSH
57650: NOP4
57654: EQUAL
57655: IFFALSE 57659
// break ;
57657: GO 57735
// if GetClass ( i ) = 3 then
57659: NOP4
57663: PPUSH
57664: NOP4
57668: PUSH
57669: LD_INT 3
57671: EQUAL
57672: IFFALSE 57676
// continue ;
57674: GO 57642
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57676: NOP4
57680: PUSH
57681: NOP4
57685: PPUSH
57686: NOP4
57690: PUSH
57691: LD_INT 1
57693: PLUS
57694: PPUSH
57695: NOP4
57699: PUSH
57700: NOP4
57704: ARRAY
57705: PPUSH
57706: NOP4
57710: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57711: NOP4
57715: PUSH
57716: NOP4
57720: PUSH
57721: NOP4
57725: PUSH
57726: NOP4
57730: ARRAY
57731: DIFF
57732: ST_TO_ADDR
// end ;
57733: GO 57642
57735: POP
57736: POP
// if p then
57737: NOP4
57741: IFFALSE 57766
// result := Replace ( result , 3 , p ) ;
57743: NOP4
57747: PUSH
57748: NOP4
57752: PPUSH
57753: LD_INT 3
57755: PPUSH
57756: NOP4
57760: PPUSH
57761: NOP4
57765: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57766: NOP4
57770: PUSH
57771: LD_INT 6
57773: GREATER
57774: PUSH
57775: NOP4
57779: PUSH
57780: LD_INT 6
57782: LESS
57783: AND
57784: IFFALSE 57978
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57786: NOP4
57790: PUSH
57791: NOP4
57795: PUSH
57796: NOP4
57800: PUSH
57801: NOP4
57805: UNION
57806: PUSH
57807: NOP4
57811: UNION
57812: DIFF
57813: PPUSH
57814: LD_INT 2
57816: PPUSH
57817: NOP4
57821: ST_TO_ADDR
// p := [ ] ;
57822: NOP4
57826: PUSH
57827: EMPTY
57828: ST_TO_ADDR
// if sort then
57829: NOP4
57833: IFFALSE 57949
// for i = 1 to 6 - eng do
57835: NOP4
57839: PUSH
57840: DOUBLE
57841: LD_INT 1
57843: DEC
57844: ST_TO_ADDR
57845: LD_INT 6
57847: PUSH
57848: NOP4
57852: MINUS
57853: PUSH
57854: FOR_TO
57855: IFFALSE 57947
// begin if i = sort then
57857: NOP4
57861: PUSH
57862: NOP4
57866: EQUAL
57867: IFFALSE 57871
// break ;
57869: GO 57947
// if GetClass ( i ) = 2 then
57871: NOP4
57875: PPUSH
57876: NOP4
57880: PUSH
57881: LD_INT 2
57883: EQUAL
57884: IFFALSE 57888
// continue ;
57886: GO 57854
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57888: NOP4
57892: PUSH
57893: NOP4
57897: PPUSH
57898: NOP4
57902: PUSH
57903: LD_INT 1
57905: PLUS
57906: PPUSH
57907: NOP4
57911: PUSH
57912: NOP4
57916: ARRAY
57917: PPUSH
57918: NOP4
57922: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57923: NOP4
57927: PUSH
57928: NOP4
57932: PUSH
57933: NOP4
57937: PUSH
57938: NOP4
57942: ARRAY
57943: DIFF
57944: ST_TO_ADDR
// end ;
57945: GO 57854
57947: POP
57948: POP
// if p then
57949: NOP4
57953: IFFALSE 57978
// result := Replace ( result , 2 , p ) ;
57955: NOP4
57959: PUSH
57960: NOP4
57964: PPUSH
57965: LD_INT 2
57967: PPUSH
57968: NOP4
57972: PPUSH
57973: NOP4
57977: ST_TO_ADDR
// end ; exit ;
57978: GO 59366
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57980: NOP4
57984: PUSH
57985: NOP4
57989: PUSH
57990: NOP4
57994: ARRAY
57995: ARRAY
57996: NOT
57997: PUSH
57998: NOP4
58002: PUSH
58003: NOP4
58007: ARRAY
58008: PPUSH
58009: LD_INT 30
58011: PUSH
58012: LD_INT 3
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: PPUSH
58019: NOP4
58023: AND
58024: PUSH
58025: NOP4
58029: PUSH
58030: NOP4
58034: ARRAY
58035: AND
58036: IFFALSE 58644
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58038: NOP4
58042: PUSH
58043: NOP4
58047: PPUSH
58048: NOP4
58052: PPUSH
58053: LD_INT 5
58055: PPUSH
58056: NOP4
58060: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58061: NOP4
58065: PUSH
58066: LD_INT 0
58068: PUSH
58069: LD_INT 0
58071: PUSH
58072: LD_INT 0
58074: PUSH
58075: LD_INT 0
58077: PUSH
58078: EMPTY
58079: LIST
58080: LIST
58081: LIST
58082: LIST
58083: ST_TO_ADDR
// if sci > 1 then
58084: NOP4
58088: PUSH
58089: LD_INT 1
58091: GREATER
58092: IFFALSE 58120
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58094: NOP4
58098: PUSH
58099: NOP4
58103: PUSH
58104: NOP4
58108: PUSH
58109: NOP4
58113: PUSH
58114: LD_INT 1
58116: ARRAY
58117: DIFF
58118: DIFF
58119: ST_TO_ADDR
// if tmp and not sci then
58120: NOP4
58124: PUSH
58125: NOP4
58129: NOT
58130: AND
58131: IFFALSE 58200
// begin sort := SortBySkill ( tmp , 4 ) ;
58133: NOP4
58137: PUSH
58138: NOP4
58142: PPUSH
58143: LD_INT 4
58145: PPUSH
58146: NOP4
58150: ST_TO_ADDR
// if sort then
58151: NOP4
58155: IFFALSE 58171
// p := sort [ 1 ] ;
58157: NOP4
58161: PUSH
58162: NOP4
58166: PUSH
58167: LD_INT 1
58169: ARRAY
58170: ST_TO_ADDR
// if p then
58171: NOP4
58175: IFFALSE 58200
// result := Replace ( result , 4 , p ) ;
58177: NOP4
58181: PUSH
58182: NOP4
58186: PPUSH
58187: LD_INT 4
58189: PPUSH
58190: NOP4
58194: PPUSH
58195: NOP4
58199: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58200: NOP4
58204: PUSH
58205: NOP4
58209: PUSH
58210: NOP4
58214: DIFF
58215: ST_TO_ADDR
// if tmp and mech < 6 then
58216: NOP4
58220: PUSH
58221: NOP4
58225: PUSH
58226: LD_INT 6
58228: LESS
58229: AND
58230: IFFALSE 58418
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58232: NOP4
58236: PUSH
58237: NOP4
58241: PUSH
58242: NOP4
58246: PUSH
58247: NOP4
58251: UNION
58252: DIFF
58253: PPUSH
58254: LD_INT 3
58256: PPUSH
58257: NOP4
58261: ST_TO_ADDR
// p := [ ] ;
58262: NOP4
58266: PUSH
58267: EMPTY
58268: ST_TO_ADDR
// if sort then
58269: NOP4
58273: IFFALSE 58389
// for i = 1 to 6 - mech do
58275: NOP4
58279: PUSH
58280: DOUBLE
58281: LD_INT 1
58283: DEC
58284: ST_TO_ADDR
58285: LD_INT 6
58287: PUSH
58288: NOP4
58292: MINUS
58293: PUSH
58294: FOR_TO
58295: IFFALSE 58387
// begin if i = sort then
58297: NOP4
58301: PUSH
58302: NOP4
58306: EQUAL
58307: IFFALSE 58311
// break ;
58309: GO 58387
// if GetClass ( i ) = 3 then
58311: NOP4
58315: PPUSH
58316: NOP4
58320: PUSH
58321: LD_INT 3
58323: EQUAL
58324: IFFALSE 58328
// continue ;
58326: GO 58294
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58328: NOP4
58332: PUSH
58333: NOP4
58337: PPUSH
58338: NOP4
58342: PUSH
58343: LD_INT 1
58345: PLUS
58346: PPUSH
58347: NOP4
58351: PUSH
58352: NOP4
58356: ARRAY
58357: PPUSH
58358: NOP4
58362: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58363: NOP4
58367: PUSH
58368: NOP4
58372: PUSH
58373: NOP4
58377: PUSH
58378: NOP4
58382: ARRAY
58383: DIFF
58384: ST_TO_ADDR
// end ;
58385: GO 58294
58387: POP
58388: POP
// if p then
58389: NOP4
58393: IFFALSE 58418
// result := Replace ( result , 3 , p ) ;
58395: NOP4
58399: PUSH
58400: NOP4
58404: PPUSH
58405: LD_INT 3
58407: PPUSH
58408: NOP4
58412: PPUSH
58413: NOP4
58417: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58418: NOP4
58422: PUSH
58423: NOP4
58427: PUSH
58428: NOP4
58432: DIFF
58433: ST_TO_ADDR
// if tmp and eng < 6 then
58434: NOP4
58438: PUSH
58439: NOP4
58443: PUSH
58444: LD_INT 6
58446: LESS
58447: AND
58448: IFFALSE 58642
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58450: NOP4
58454: PUSH
58455: NOP4
58459: PUSH
58460: NOP4
58464: PUSH
58465: NOP4
58469: UNION
58470: PUSH
58471: NOP4
58475: UNION
58476: DIFF
58477: PPUSH
58478: LD_INT 2
58480: PPUSH
58481: NOP4
58485: ST_TO_ADDR
// p := [ ] ;
58486: NOP4
58490: PUSH
58491: EMPTY
58492: ST_TO_ADDR
// if sort then
58493: NOP4
58497: IFFALSE 58613
// for i = 1 to 6 - eng do
58499: NOP4
58503: PUSH
58504: DOUBLE
58505: LD_INT 1
58507: DEC
58508: ST_TO_ADDR
58509: LD_INT 6
58511: PUSH
58512: NOP4
58516: MINUS
58517: PUSH
58518: FOR_TO
58519: IFFALSE 58611
// begin if i = sort then
58521: NOP4
58525: PUSH
58526: NOP4
58530: EQUAL
58531: IFFALSE 58535
// break ;
58533: GO 58611
// if GetClass ( i ) = 2 then
58535: NOP4
58539: PPUSH
58540: NOP4
58544: PUSH
58545: LD_INT 2
58547: EQUAL
58548: IFFALSE 58552
// continue ;
58550: GO 58518
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58552: NOP4
58556: PUSH
58557: NOP4
58561: PPUSH
58562: NOP4
58566: PUSH
58567: LD_INT 1
58569: PLUS
58570: PPUSH
58571: NOP4
58575: PUSH
58576: NOP4
58580: ARRAY
58581: PPUSH
58582: NOP4
58586: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58587: NOP4
58591: PUSH
58592: NOP4
58596: PUSH
58597: NOP4
58601: PUSH
58602: NOP4
58606: ARRAY
58607: DIFF
58608: ST_TO_ADDR
// end ;
58609: GO 58518
58611: POP
58612: POP
// if p then
58613: NOP4
58617: IFFALSE 58642
// result := Replace ( result , 2 , p ) ;
58619: NOP4
58623: PUSH
58624: NOP4
58628: PPUSH
58629: LD_INT 2
58631: PPUSH
58632: NOP4
58636: PPUSH
58637: NOP4
58641: ST_TO_ADDR
// end ; exit ;
58642: GO 59366
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58644: NOP4
58648: PUSH
58649: NOP4
58653: PUSH
58654: NOP4
58658: ARRAY
58659: ARRAY
58660: NOT
58661: PUSH
58662: NOP4
58666: PUSH
58667: NOP4
58671: ARRAY
58672: PPUSH
58673: LD_INT 30
58675: PUSH
58676: LD_INT 3
58678: PUSH
58679: EMPTY
58680: LIST
58681: LIST
58682: PPUSH
58683: NOP4
58687: AND
58688: PUSH
58689: NOP4
58693: PUSH
58694: NOP4
58698: ARRAY
58699: NOT
58700: AND
58701: IFFALSE 59366
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58703: NOP4
58707: PUSH
58708: NOP4
58712: PPUSH
58713: NOP4
58717: PPUSH
58718: LD_INT 6
58720: PPUSH
58721: NOP4
58725: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58726: NOP4
58730: PUSH
58731: LD_INT 0
58733: PUSH
58734: LD_INT 0
58736: PUSH
58737: LD_INT 0
58739: PUSH
58740: LD_INT 0
58742: PUSH
58743: EMPTY
58744: LIST
58745: LIST
58746: LIST
58747: LIST
58748: ST_TO_ADDR
// if sci >= 1 then
58749: NOP4
58753: PUSH
58754: LD_INT 1
58756: GREATEREQUAL
58757: IFFALSE 58779
// tmp := tmp diff sci [ 1 ] ;
58759: NOP4
58763: PUSH
58764: NOP4
58768: PUSH
58769: NOP4
58773: PUSH
58774: LD_INT 1
58776: ARRAY
58777: DIFF
58778: ST_TO_ADDR
// if tmp and not sci then
58779: NOP4
58783: PUSH
58784: NOP4
58788: NOT
58789: AND
58790: IFFALSE 58859
// begin sort := SortBySkill ( tmp , 4 ) ;
58792: NOP4
58796: PUSH
58797: NOP4
58801: PPUSH
58802: LD_INT 4
58804: PPUSH
58805: NOP4
58809: ST_TO_ADDR
// if sort then
58810: NOP4
58814: IFFALSE 58830
// p := sort [ 1 ] ;
58816: NOP4
58820: PUSH
58821: NOP4
58825: PUSH
58826: LD_INT 1
58828: ARRAY
58829: ST_TO_ADDR
// if p then
58830: NOP4
58834: IFFALSE 58859
// result := Replace ( result , 4 , p ) ;
58836: NOP4
58840: PUSH
58841: NOP4
58845: PPUSH
58846: LD_INT 4
58848: PPUSH
58849: NOP4
58853: PPUSH
58854: NOP4
58858: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58859: NOP4
58863: PUSH
58864: NOP4
58868: PUSH
58869: NOP4
58873: DIFF
58874: ST_TO_ADDR
// if tmp and mech < 6 then
58875: NOP4
58879: PUSH
58880: NOP4
58884: PUSH
58885: LD_INT 6
58887: LESS
58888: AND
58889: IFFALSE 59071
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58891: NOP4
58895: PUSH
58896: NOP4
58900: PUSH
58901: NOP4
58905: DIFF
58906: PPUSH
58907: LD_INT 3
58909: PPUSH
58910: NOP4
58914: ST_TO_ADDR
// p := [ ] ;
58915: NOP4
58919: PUSH
58920: EMPTY
58921: ST_TO_ADDR
// if sort then
58922: NOP4
58926: IFFALSE 59042
// for i = 1 to 6 - mech do
58928: NOP4
58932: PUSH
58933: DOUBLE
58934: LD_INT 1
58936: DEC
58937: ST_TO_ADDR
58938: LD_INT 6
58940: PUSH
58941: NOP4
58945: MINUS
58946: PUSH
58947: FOR_TO
58948: IFFALSE 59040
// begin if i = sort then
58950: NOP4
58954: PUSH
58955: NOP4
58959: EQUAL
58960: IFFALSE 58964
// break ;
58962: GO 59040
// if GetClass ( i ) = 3 then
58964: NOP4
58968: PPUSH
58969: NOP4
58973: PUSH
58974: LD_INT 3
58976: EQUAL
58977: IFFALSE 58981
// continue ;
58979: GO 58947
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58981: NOP4
58985: PUSH
58986: NOP4
58990: PPUSH
58991: NOP4
58995: PUSH
58996: LD_INT 1
58998: PLUS
58999: PPUSH
59000: NOP4
59004: PUSH
59005: NOP4
59009: ARRAY
59010: PPUSH
59011: NOP4
59015: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59016: NOP4
59020: PUSH
59021: NOP4
59025: PUSH
59026: NOP4
59030: PUSH
59031: NOP4
59035: ARRAY
59036: DIFF
59037: ST_TO_ADDR
// end ;
59038: GO 58947
59040: POP
59041: POP
// if p then
59042: NOP4
59046: IFFALSE 59071
// result := Replace ( result , 3 , p ) ;
59048: NOP4
59052: PUSH
59053: NOP4
59057: PPUSH
59058: LD_INT 3
59060: PPUSH
59061: NOP4
59065: PPUSH
59066: NOP4
59070: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59071: NOP4
59075: PUSH
59076: NOP4
59080: PUSH
59081: NOP4
59085: DIFF
59086: ST_TO_ADDR
// if tmp and eng < 4 then
59087: NOP4
59091: PUSH
59092: NOP4
59096: PUSH
59097: LD_INT 4
59099: LESS
59100: AND
59101: IFFALSE 59291
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59103: NOP4
59107: PUSH
59108: NOP4
59112: PUSH
59113: NOP4
59117: PUSH
59118: NOP4
59122: UNION
59123: DIFF
59124: PPUSH
59125: LD_INT 2
59127: PPUSH
59128: NOP4
59132: ST_TO_ADDR
// p := [ ] ;
59133: NOP4
59137: PUSH
59138: EMPTY
59139: ST_TO_ADDR
// if sort then
59140: NOP4
59144: IFFALSE 59260
// for i = 1 to 4 - eng do
59146: NOP4
59150: PUSH
59151: DOUBLE
59152: LD_INT 1
59154: DEC
59155: ST_TO_ADDR
59156: LD_INT 4
59158: PUSH
59159: NOP4
59163: MINUS
59164: PUSH
59165: FOR_TO
59166: IFFALSE 59258
// begin if i = sort then
59168: NOP4
59172: PUSH
59173: NOP4
59177: EQUAL
59178: IFFALSE 59182
// break ;
59180: GO 59258
// if GetClass ( i ) = 2 then
59182: NOP4
59186: PPUSH
59187: NOP4
59191: PUSH
59192: LD_INT 2
59194: EQUAL
59195: IFFALSE 59199
// continue ;
59197: GO 59165
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59199: NOP4
59203: PUSH
59204: NOP4
59208: PPUSH
59209: NOP4
59213: PUSH
59214: LD_INT 1
59216: PLUS
59217: PPUSH
59218: NOP4
59222: PUSH
59223: NOP4
59227: ARRAY
59228: PPUSH
59229: NOP4
59233: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59234: NOP4
59238: PUSH
59239: NOP4
59243: PUSH
59244: NOP4
59248: PUSH
59249: NOP4
59253: ARRAY
59254: DIFF
59255: ST_TO_ADDR
// end ;
59256: GO 59165
59258: POP
59259: POP
// if p then
59260: NOP4
59264: IFFALSE 59289
// result := Replace ( result , 2 , p ) ;
59266: NOP4
59270: PUSH
59271: NOP4
59275: PPUSH
59276: LD_INT 2
59278: PPUSH
59279: NOP4
59283: PPUSH
59284: NOP4
59288: ST_TO_ADDR
// end else
59289: GO 59335
// for i = eng downto 5 do
59291: NOP4
59295: PUSH
59296: DOUBLE
59297: NOP4
59301: INC
59302: ST_TO_ADDR
59303: LD_INT 5
59305: PUSH
59306: FOR_DOWNTO
59307: IFFALSE 59333
// tmp := tmp union eng [ i ] ;
59309: NOP4
59313: PUSH
59314: NOP4
59318: PUSH
59319: NOP4
59323: PUSH
59324: NOP4
59328: ARRAY
59329: UNION
59330: ST_TO_ADDR
59331: GO 59306
59333: POP
59334: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59335: NOP4
59339: PUSH
59340: NOP4
59344: PPUSH
59345: LD_INT 1
59347: PPUSH
59348: NOP4
59352: PUSH
59353: NOP4
59357: DIFF
59358: PPUSH
59359: NOP4
59363: ST_TO_ADDR
// exit ;
59364: GO 59366
// end ; end ;
59366: LD_VAR 0 2
59370: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59371: LD_INT 0
59373: PPUSH
59374: PPUSH
59375: PPUSH
// if not mc_bases then
59376: NOP4
59380: NOT
59381: IFFALSE 59385
// exit ;
59383: GO 59527
// for i = 1 to mc_bases do
59385: NOP4
59389: PUSH
59390: DOUBLE
59391: LD_INT 1
59393: DEC
59394: ST_TO_ADDR
59395: NOP4
59399: PUSH
59400: FOR_TO
59401: IFFALSE 59518
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59403: NOP4
59407: PUSH
59408: NOP4
59412: PUSH
59413: NOP4
59417: ARRAY
59418: PPUSH
59419: LD_INT 21
59421: PUSH
59422: LD_INT 3
59424: PUSH
59425: EMPTY
59426: LIST
59427: LIST
59428: PUSH
59429: LD_INT 3
59431: PUSH
59432: LD_INT 2
59434: PUSH
59435: LD_INT 30
59437: PUSH
59438: LD_INT 29
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: PUSH
59445: LD_INT 30
59447: PUSH
59448: LD_INT 30
59450: PUSH
59451: EMPTY
59452: LIST
59453: LIST
59454: PUSH
59455: EMPTY
59456: LIST
59457: LIST
59458: LIST
59459: PUSH
59460: EMPTY
59461: LIST
59462: LIST
59463: PUSH
59464: LD_INT 3
59466: PUSH
59467: LD_INT 24
59469: PUSH
59470: LD_INT 1000
59472: PUSH
59473: EMPTY
59474: LIST
59475: LIST
59476: PUSH
59477: EMPTY
59478: LIST
59479: LIST
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: LIST
59485: PPUSH
59486: NOP4
59490: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59491: NOP4
59495: PUSH
59496: NOP4
59500: PPUSH
59501: NOP4
59505: PPUSH
59506: NOP4
59510: PPUSH
59511: NOP4
59515: ST_TO_ADDR
// end ;
59516: GO 59400
59518: POP
59519: POP
// RaiseSailEvent ( 101 ) ;
59520: LD_INT 101
59522: PPUSH
59523: NOP4
// end ;
59527: LD_VAR 0 1
59531: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59532: LD_INT 0
59534: PPUSH
59535: PPUSH
59536: PPUSH
59537: PPUSH
59538: PPUSH
59539: PPUSH
59540: PPUSH
// if not mc_bases then
59541: NOP4
59545: NOT
59546: IFFALSE 59550
// exit ;
59548: GO 60112
// for i = 1 to mc_bases do
59550: NOP4
59554: PUSH
59555: DOUBLE
59556: LD_INT 1
59558: DEC
59559: ST_TO_ADDR
59560: NOP4
59564: PUSH
59565: FOR_TO
59566: IFFALSE 60103
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59568: NOP4
59572: PUSH
59573: NOP4
59577: PUSH
59578: NOP4
59582: ARRAY
59583: PUSH
59584: NOP4
59588: PUSH
59589: NOP4
59593: ARRAY
59594: UNION
59595: PPUSH
59596: LD_INT 21
59598: PUSH
59599: LD_INT 1
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: PUSH
59606: LD_INT 1
59608: PUSH
59609: LD_INT 3
59611: PUSH
59612: LD_INT 54
59614: PUSH
59615: EMPTY
59616: LIST
59617: PUSH
59618: EMPTY
59619: LIST
59620: LIST
59621: PUSH
59622: LD_INT 3
59624: PUSH
59625: LD_INT 24
59627: PUSH
59628: LD_INT 1000
59630: PUSH
59631: EMPTY
59632: LIST
59633: LIST
59634: PUSH
59635: EMPTY
59636: LIST
59637: LIST
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: LIST
59643: PUSH
59644: EMPTY
59645: LIST
59646: LIST
59647: PPUSH
59648: NOP4
59652: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59653: NOP4
59657: PUSH
59658: NOP4
59662: PUSH
59663: NOP4
59667: ARRAY
59668: PPUSH
59669: LD_INT 21
59671: PUSH
59672: LD_INT 1
59674: PUSH
59675: EMPTY
59676: LIST
59677: LIST
59678: PUSH
59679: LD_INT 1
59681: PUSH
59682: LD_INT 3
59684: PUSH
59685: LD_INT 54
59687: PUSH
59688: EMPTY
59689: LIST
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: PUSH
59695: LD_INT 3
59697: PUSH
59698: LD_INT 24
59700: PUSH
59701: LD_INT 250
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: PUSH
59712: EMPTY
59713: LIST
59714: LIST
59715: LIST
59716: PUSH
59717: EMPTY
59718: LIST
59719: LIST
59720: PPUSH
59721: NOP4
59725: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59726: NOP4
59730: PUSH
59731: NOP4
59735: PUSH
59736: NOP4
59740: DIFF
59741: ST_TO_ADDR
// if not need_heal_1 then
59742: NOP4
59746: NOT
59747: IFFALSE 59780
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59749: NOP4
59753: PUSH
59754: NOP4
59758: PPUSH
59759: NOP4
59763: PUSH
59764: LD_INT 1
59766: PUSH
59767: EMPTY
59768: LIST
59769: LIST
59770: PPUSH
59771: EMPTY
59772: PPUSH
59773: NOP4
59777: ST_TO_ADDR
59778: GO 59850
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59780: NOP4
59784: PUSH
59785: NOP4
59789: PPUSH
59790: NOP4
59794: PUSH
59795: LD_INT 1
59797: PUSH
59798: EMPTY
59799: LIST
59800: LIST
59801: PPUSH
59802: NOP4
59806: PUSH
59807: NOP4
59811: ARRAY
59812: PUSH
59813: LD_INT 1
59815: ARRAY
59816: PPUSH
59817: LD_INT 3
59819: PUSH
59820: LD_INT 24
59822: PUSH
59823: LD_INT 1000
59825: PUSH
59826: EMPTY
59827: LIST
59828: LIST
59829: PUSH
59830: EMPTY
59831: LIST
59832: LIST
59833: PPUSH
59834: NOP4
59838: PUSH
59839: NOP4
59843: UNION
59844: PPUSH
59845: NOP4
59849: ST_TO_ADDR
// if not need_heal_2 then
59850: NOP4
59854: NOT
59855: IFFALSE 59888
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59857: NOP4
59861: PUSH
59862: NOP4
59866: PPUSH
59867: NOP4
59871: PUSH
59872: LD_INT 2
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: PPUSH
59879: EMPTY
59880: PPUSH
59881: NOP4
59885: ST_TO_ADDR
59886: GO 59920
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59888: NOP4
59892: PUSH
59893: NOP4
59897: PPUSH
59898: NOP4
59902: PUSH
59903: LD_INT 2
59905: PUSH
59906: EMPTY
59907: LIST
59908: LIST
59909: PPUSH
59910: NOP4
59914: PPUSH
59915: NOP4
59919: ST_TO_ADDR
// if need_heal_2 then
59920: NOP4
59924: IFFALSE 60085
// for j in need_heal_2 do
59926: NOP4
59930: PUSH
59931: NOP4
59935: PUSH
59936: FOR_IN
59937: IFFALSE 60083
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59939: NOP4
59943: PUSH
59944: NOP4
59948: PUSH
59949: NOP4
59953: ARRAY
59954: PPUSH
59955: LD_INT 2
59957: PUSH
59958: LD_INT 30
59960: PUSH
59961: LD_INT 6
59963: PUSH
59964: EMPTY
59965: LIST
59966: LIST
59967: PUSH
59968: LD_INT 30
59970: PUSH
59971: LD_INT 7
59973: PUSH
59974: EMPTY
59975: LIST
59976: LIST
59977: PUSH
59978: LD_INT 30
59980: PUSH
59981: LD_INT 8
59983: PUSH
59984: EMPTY
59985: LIST
59986: LIST
59987: PUSH
59988: LD_INT 30
59990: PUSH
59991: LD_INT 0
59993: PUSH
59994: EMPTY
59995: LIST
59996: LIST
59997: PUSH
59998: LD_INT 30
60000: PUSH
60001: LD_INT 1
60003: PUSH
60004: EMPTY
60005: LIST
60006: LIST
60007: PUSH
60008: EMPTY
60009: LIST
60010: LIST
60011: LIST
60012: LIST
60013: LIST
60014: LIST
60015: PPUSH
60016: NOP4
60020: ST_TO_ADDR
// if tmp then
60021: NOP4
60025: IFFALSE 60081
// begin k := NearestUnitToUnit ( tmp , j ) ;
60027: NOP4
60031: PUSH
60032: NOP4
60036: PPUSH
60037: NOP4
60041: PPUSH
60042: NOP4
60046: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60047: NOP4
60051: PPUSH
60052: NOP4
60056: PPUSH
60057: NOP4
60061: PUSH
60062: LD_INT 5
60064: GREATER
60065: IFFALSE 60081
// ComMoveToNearbyEntrance ( j , k ) ;
60067: NOP4
60071: PPUSH
60072: NOP4
60076: PPUSH
60077: NOP4
// end ; end ;
60081: GO 59936
60083: POP
60084: POP
// if not need_heal_1 and not need_heal_2 then
60085: NOP4
60089: NOT
60090: PUSH
60091: NOP4
60095: NOT
60096: AND
60097: IFFALSE 60101
// continue ;
60099: GO 59565
// end ;
60101: GO 59565
60103: POP
60104: POP
// RaiseSailEvent ( 102 ) ;
60105: LD_INT 102
60107: PPUSH
60108: NOP4
// end ;
60112: LD_VAR 0 1
60116: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60117: LD_INT 0
60119: PPUSH
60120: PPUSH
60121: PPUSH
60122: PPUSH
60123: PPUSH
60124: PPUSH
60125: PPUSH
60126: PPUSH
// if not mc_bases then
60127: NOP4
60131: NOT
60132: IFFALSE 60136
// exit ;
60134: GO 61019
// for i = 1 to mc_bases do
60136: NOP4
60140: PUSH
60141: DOUBLE
60142: LD_INT 1
60144: DEC
60145: ST_TO_ADDR
60146: NOP4
60150: PUSH
60151: FOR_TO
60152: IFFALSE 61017
// begin if not mc_building_need_repair [ i ] then
60154: NOP4
60158: PUSH
60159: NOP4
60163: ARRAY
60164: NOT
60165: IFFALSE 60352
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60167: NOP4
60171: PUSH
60172: NOP4
60176: PUSH
60177: NOP4
60181: ARRAY
60182: PPUSH
60183: LD_INT 3
60185: PUSH
60186: LD_INT 24
60188: PUSH
60189: LD_INT 1000
60191: PUSH
60192: EMPTY
60193: LIST
60194: LIST
60195: PUSH
60196: EMPTY
60197: LIST
60198: LIST
60199: PUSH
60200: LD_INT 2
60202: PUSH
60203: LD_INT 34
60205: PUSH
60206: LD_INT 13
60208: PUSH
60209: EMPTY
60210: LIST
60211: LIST
60212: PUSH
60213: LD_INT 34
60215: PUSH
60216: LD_INT 52
60218: PUSH
60219: EMPTY
60220: LIST
60221: LIST
60222: PUSH
60223: LD_INT 34
60225: PUSH
60226: NOP4
60230: PUSH
60231: EMPTY
60232: LIST
60233: LIST
60234: PUSH
60235: EMPTY
60236: LIST
60237: LIST
60238: LIST
60239: LIST
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: PPUSH
60245: NOP4
60249: ST_TO_ADDR
// if cranes then
60250: NOP4
60254: IFFALSE 60316
// for j in cranes do
60256: NOP4
60260: PUSH
60261: NOP4
60265: PUSH
60266: FOR_IN
60267: IFFALSE 60314
// if not IsInArea ( j , mc_parking [ i ] ) then
60269: NOP4
60273: PPUSH
60274: NOP4
60278: PUSH
60279: NOP4
60283: ARRAY
60284: PPUSH
60285: NOP4
60289: NOT
60290: IFFALSE 60312
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60292: NOP4
60296: PPUSH
60297: NOP4
60301: PUSH
60302: NOP4
60306: ARRAY
60307: PPUSH
60308: NOP4
60312: GO 60266
60314: POP
60315: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60316: NOP4
60320: PUSH
60321: NOP4
60325: PPUSH
60326: NOP4
60330: PPUSH
60331: EMPTY
60332: PPUSH
60333: NOP4
60337: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60338: NOP4
60342: PPUSH
60343: LD_INT 101
60345: PPUSH
60346: NOP4
// continue ;
60350: GO 60151
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60352: NOP4
60356: PUSH
60357: NOP4
60361: PPUSH
60362: NOP4
60366: PPUSH
60367: EMPTY
60368: PPUSH
60369: NOP4
60373: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60374: NOP4
60378: PPUSH
60379: LD_INT 103
60381: PPUSH
60382: NOP4
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60386: NOP4
60390: PUSH
60391: NOP4
60395: PUSH
60396: NOP4
60400: ARRAY
60401: PUSH
60402: NOP4
60406: PUSH
60407: NOP4
60411: ARRAY
60412: UNION
60413: PPUSH
60414: LD_INT 2
60416: PUSH
60417: LD_INT 25
60419: PUSH
60420: LD_INT 2
60422: PUSH
60423: EMPTY
60424: LIST
60425: LIST
60426: PUSH
60427: LD_INT 25
60429: PUSH
60430: LD_INT 16
60432: PUSH
60433: EMPTY
60434: LIST
60435: LIST
60436: PUSH
60437: EMPTY
60438: LIST
60439: LIST
60440: LIST
60441: PUSH
60442: EMPTY
60443: LIST
60444: PPUSH
60445: NOP4
60449: ST_TO_ADDR
// if mc_need_heal [ i ] then
60450: NOP4
60454: PUSH
60455: NOP4
60459: ARRAY
60460: IFFALSE 60504
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60462: NOP4
60466: PUSH
60467: NOP4
60471: PUSH
60472: NOP4
60476: PUSH
60477: NOP4
60481: ARRAY
60482: PUSH
60483: LD_INT 1
60485: ARRAY
60486: PUSH
60487: NOP4
60491: PUSH
60492: NOP4
60496: ARRAY
60497: PUSH
60498: LD_INT 2
60500: ARRAY
60501: UNION
60502: DIFF
60503: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60504: NOP4
60508: PUSH
60509: NOP4
60513: PUSH
60514: NOP4
60518: ARRAY
60519: PPUSH
60520: LD_INT 2
60522: PUSH
60523: LD_INT 34
60525: PUSH
60526: LD_INT 13
60528: PUSH
60529: EMPTY
60530: LIST
60531: LIST
60532: PUSH
60533: LD_INT 34
60535: PUSH
60536: LD_INT 52
60538: PUSH
60539: EMPTY
60540: LIST
60541: LIST
60542: PUSH
60543: LD_INT 34
60545: PUSH
60546: NOP4
60550: PUSH
60551: EMPTY
60552: LIST
60553: LIST
60554: PUSH
60555: EMPTY
60556: LIST
60557: LIST
60558: LIST
60559: LIST
60560: PPUSH
60561: NOP4
60565: ST_TO_ADDR
// if cranes then
60566: NOP4
60570: IFFALSE 60706
// begin for j in cranes do
60572: NOP4
60576: PUSH
60577: NOP4
60581: PUSH
60582: FOR_IN
60583: IFFALSE 60704
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60585: NOP4
60589: PPUSH
60590: NOP4
60594: PUSH
60595: LD_INT 1000
60597: EQUAL
60598: PUSH
60599: NOP4
60603: PPUSH
60604: NOP4
60608: NOT
60609: AND
60610: IFFALSE 60644
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60612: NOP4
60616: PPUSH
60617: NOP4
60621: PUSH
60622: NOP4
60626: ARRAY
60627: PPUSH
60628: NOP4
60632: PPUSH
60633: NOP4
60637: PPUSH
60638: NOP4
60642: GO 60702
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60644: NOP4
60648: PPUSH
60649: NOP4
60653: PUSH
60654: LD_INT 500
60656: LESS
60657: PUSH
60658: NOP4
60662: PPUSH
60663: NOP4
60667: PUSH
60668: NOP4
60672: ARRAY
60673: PPUSH
60674: NOP4
60678: NOT
60679: AND
60680: IFFALSE 60702
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60682: NOP4
60686: PPUSH
60687: NOP4
60691: PUSH
60692: NOP4
60696: ARRAY
60697: PPUSH
60698: NOP4
// end ;
60702: GO 60582
60704: POP
60705: POP
// end ; if tmp > 3 then
60706: NOP4
60710: PUSH
60711: LD_INT 3
60713: GREATER
60714: IFFALSE 60734
// tmp := ShrinkArray ( tmp , 4 ) ;
60716: NOP4
60720: PUSH
60721: NOP4
60725: PPUSH
60726: LD_INT 4
60728: PPUSH
60729: NOP4
60733: ST_TO_ADDR
// if not tmp then
60734: NOP4
60738: NOT
60739: IFFALSE 60743
// continue ;
60741: GO 60151
// for j in tmp do
60743: NOP4
60747: PUSH
60748: NOP4
60752: PUSH
60753: FOR_IN
60754: IFFALSE 61013
// begin if IsInUnit ( j ) then
60756: NOP4
60760: PPUSH
60761: NOP4
60765: IFFALSE 60776
// ComExitBuilding ( j ) ;
60767: NOP4
60771: PPUSH
60772: NOP4
// if not j in mc_building_repairs [ i ] then
60776: NOP4
60780: PUSH
60781: NOP4
60785: PUSH
60786: NOP4
60790: ARRAY
60791: IN
60792: NOT
60793: IFFALSE 60851
// begin SetTag ( j , 101 ) ;
60795: NOP4
60799: PPUSH
60800: LD_INT 101
60802: PPUSH
60803: NOP4
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60807: NOP4
60811: PUSH
60812: NOP4
60816: PPUSH
60817: NOP4
60821: PUSH
60822: NOP4
60826: PUSH
60827: NOP4
60831: ARRAY
60832: PUSH
60833: LD_INT 1
60835: PLUS
60836: PUSH
60837: EMPTY
60838: LIST
60839: LIST
60840: PPUSH
60841: NOP4
60845: PPUSH
60846: NOP4
60850: ST_TO_ADDR
// end ; wait ( 1 ) ;
60851: LD_INT 1
60853: PPUSH
60854: NOP4
// to_repair_tmp := mc_building_need_repair [ i ] ;
60858: NOP4
60862: PUSH
60863: NOP4
60867: PUSH
60868: NOP4
60872: ARRAY
60873: ST_TO_ADDR
// if mc_scan [ i ] then
60874: NOP4
60878: PUSH
60879: NOP4
60883: ARRAY
60884: IFFALSE 60946
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60886: NOP4
60890: PUSH
60891: NOP4
60895: PUSH
60896: NOP4
60900: ARRAY
60901: PPUSH
60902: LD_INT 3
60904: PUSH
60905: LD_INT 30
60907: PUSH
60908: LD_INT 32
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: PUSH
60915: LD_INT 30
60917: PUSH
60918: LD_INT 33
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: PUSH
60925: LD_INT 30
60927: PUSH
60928: LD_INT 31
60930: PUSH
60931: EMPTY
60932: LIST
60933: LIST
60934: PUSH
60935: EMPTY
60936: LIST
60937: LIST
60938: LIST
60939: LIST
60940: PPUSH
60941: NOP4
60945: ST_TO_ADDR
// if not to_repair_tmp then
60946: NOP4
60950: NOT
60951: IFFALSE 60955
// continue ;
60953: GO 60753
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60955: NOP4
60959: PUSH
60960: NOP4
60964: PPUSH
60965: NOP4
60969: PPUSH
60970: NOP4
60974: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60975: NOP4
60979: PPUSH
60980: LD_INT 16
60982: PPUSH
60983: NOP4
60987: PUSH
60988: LD_INT 4
60990: ARRAY
60991: PUSH
60992: LD_INT 10
60994: LESS
60995: IFFALSE 61011
// ComRepairBuilding ( j , to_repair ) ;
60997: NOP4
61001: PPUSH
61002: NOP4
61006: PPUSH
61007: NOP4
// end ;
61011: GO 60753
61013: POP
61014: POP
// end ;
61015: GO 60151
61017: POP
61018: POP
// end ;
61019: LD_VAR 0 1
61023: RET
// export function MC_Heal ; var i , j , tmp ; begin
61024: LD_INT 0
61026: PPUSH
61027: PPUSH
61028: PPUSH
61029: PPUSH
// if not mc_bases then
61030: NOP4
61034: NOT
61035: IFFALSE 61039
// exit ;
61037: GO 61441
// for i = 1 to mc_bases do
61039: NOP4
61043: PUSH
61044: DOUBLE
61045: LD_INT 1
61047: DEC
61048: ST_TO_ADDR
61049: NOP4
61053: PUSH
61054: FOR_TO
61055: IFFALSE 61439
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61057: NOP4
61061: PUSH
61062: NOP4
61066: ARRAY
61067: PUSH
61068: LD_INT 1
61070: ARRAY
61071: NOT
61072: PUSH
61073: NOP4
61077: PUSH
61078: NOP4
61082: ARRAY
61083: PUSH
61084: LD_INT 2
61086: ARRAY
61087: NOT
61088: AND
61089: IFFALSE 61127
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61091: NOP4
61095: PUSH
61096: NOP4
61100: PPUSH
61101: NOP4
61105: PPUSH
61106: EMPTY
61107: PPUSH
61108: NOP4
61112: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61113: NOP4
61117: PPUSH
61118: LD_INT 102
61120: PPUSH
61121: NOP4
// continue ;
61125: GO 61054
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61127: NOP4
61131: PUSH
61132: NOP4
61136: PUSH
61137: NOP4
61141: ARRAY
61142: PPUSH
61143: LD_INT 25
61145: PUSH
61146: LD_INT 4
61148: PUSH
61149: EMPTY
61150: LIST
61151: LIST
61152: PPUSH
61153: NOP4
61157: ST_TO_ADDR
// if not tmp then
61158: NOP4
61162: NOT
61163: IFFALSE 61167
// continue ;
61165: GO 61054
// if mc_taming [ i ] then
61167: NOP4
61171: PUSH
61172: NOP4
61176: ARRAY
61177: IFFALSE 61201
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61179: NOP4
61183: PUSH
61184: NOP4
61188: PPUSH
61189: NOP4
61193: PPUSH
61194: EMPTY
61195: PPUSH
61196: NOP4
61200: ST_TO_ADDR
// for j in tmp do
61201: NOP4
61205: PUSH
61206: NOP4
61210: PUSH
61211: FOR_IN
61212: IFFALSE 61435
// begin if IsInUnit ( j ) then
61214: NOP4
61218: PPUSH
61219: NOP4
61223: IFFALSE 61234
// ComExitBuilding ( j ) ;
61225: NOP4
61229: PPUSH
61230: NOP4
// if not j in mc_healers [ i ] then
61234: NOP4
61238: PUSH
61239: NOP4
61243: PUSH
61244: NOP4
61248: ARRAY
61249: IN
61250: NOT
61251: IFFALSE 61297
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61253: NOP4
61257: PUSH
61258: NOP4
61262: PPUSH
61263: NOP4
61267: PUSH
61268: NOP4
61272: PUSH
61273: NOP4
61277: ARRAY
61278: PUSH
61279: LD_INT 1
61281: PLUS
61282: PUSH
61283: EMPTY
61284: LIST
61285: LIST
61286: PPUSH
61287: NOP4
61291: PPUSH
61292: NOP4
61296: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61297: NOP4
61301: PPUSH
61302: NOP4
61306: PUSH
61307: LD_INT 102
61309: NONEQUAL
61310: IFFALSE 61324
// SetTag ( j , 102 ) ;
61312: NOP4
61316: PPUSH
61317: LD_INT 102
61319: PPUSH
61320: NOP4
// Wait ( 3 ) ;
61324: LD_INT 3
61326: PPUSH
61327: NOP4
// if mc_need_heal [ i ] [ 1 ] then
61331: NOP4
61335: PUSH
61336: NOP4
61340: ARRAY
61341: PUSH
61342: LD_INT 1
61344: ARRAY
61345: IFFALSE 61377
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61347: NOP4
61351: PPUSH
61352: NOP4
61356: PUSH
61357: NOP4
61361: ARRAY
61362: PUSH
61363: LD_INT 1
61365: ARRAY
61366: PUSH
61367: LD_INT 1
61369: ARRAY
61370: PPUSH
61371: NOP4
61375: GO 61433
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61377: NOP4
61381: PPUSH
61382: NOP4
61386: NOT
61387: PUSH
61388: NOP4
61392: PUSH
61393: NOP4
61397: ARRAY
61398: PUSH
61399: LD_INT 2
61401: ARRAY
61402: AND
61403: IFFALSE 61433
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61405: NOP4
61409: PPUSH
61410: NOP4
61414: PUSH
61415: NOP4
61419: ARRAY
61420: PUSH
61421: LD_INT 2
61423: ARRAY
61424: PUSH
61425: LD_INT 1
61427: ARRAY
61428: PPUSH
61429: NOP4
// end ;
61433: GO 61211
61435: POP
61436: POP
// end ;
61437: GO 61054
61439: POP
61440: POP
// end ;
61441: LD_VAR 0 1
61445: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61446: LD_INT 0
61448: PPUSH
61449: PPUSH
61450: PPUSH
61451: PPUSH
61452: PPUSH
// if not mc_bases then
61453: NOP4
61457: NOT
61458: IFFALSE 61462
// exit ;
61460: GO 62633
// for i = 1 to mc_bases do
61462: NOP4
61466: PUSH
61467: DOUBLE
61468: LD_INT 1
61470: DEC
61471: ST_TO_ADDR
61472: NOP4
61476: PUSH
61477: FOR_TO
61478: IFFALSE 62631
// begin if mc_scan [ i ] then
61480: NOP4
61484: PUSH
61485: NOP4
61489: ARRAY
61490: IFFALSE 61494
// continue ;
61492: GO 61477
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61494: NOP4
61498: PUSH
61499: NOP4
61503: ARRAY
61504: NOT
61505: PUSH
61506: NOP4
61510: PUSH
61511: NOP4
61515: ARRAY
61516: NOT
61517: AND
61518: PUSH
61519: NOP4
61523: PUSH
61524: NOP4
61528: ARRAY
61529: AND
61530: IFFALSE 61568
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61532: NOP4
61536: PUSH
61537: NOP4
61541: PPUSH
61542: NOP4
61546: PPUSH
61547: EMPTY
61548: PPUSH
61549: NOP4
61553: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61554: NOP4
61558: PPUSH
61559: LD_INT 103
61561: PPUSH
61562: NOP4
// continue ;
61566: GO 61477
// end ; if mc_construct_list [ i ] then
61568: NOP4
61572: PUSH
61573: NOP4
61577: ARRAY
61578: IFFALSE 61798
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61580: NOP4
61584: PUSH
61585: NOP4
61589: PUSH
61590: NOP4
61594: ARRAY
61595: PPUSH
61596: LD_INT 25
61598: PUSH
61599: LD_INT 2
61601: PUSH
61602: EMPTY
61603: LIST
61604: LIST
61605: PPUSH
61606: NOP4
61610: PUSH
61611: NOP4
61615: PUSH
61616: NOP4
61620: ARRAY
61621: DIFF
61622: ST_TO_ADDR
// if not tmp then
61623: NOP4
61627: NOT
61628: IFFALSE 61632
// continue ;
61630: GO 61477
// for j in tmp do
61632: NOP4
61636: PUSH
61637: NOP4
61641: PUSH
61642: FOR_IN
61643: IFFALSE 61794
// begin if not mc_builders [ i ] then
61645: NOP4
61649: PUSH
61650: NOP4
61654: ARRAY
61655: NOT
61656: IFFALSE 61714
// begin SetTag ( j , 103 ) ;
61658: NOP4
61662: PPUSH
61663: LD_INT 103
61665: PPUSH
61666: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61670: NOP4
61674: PUSH
61675: NOP4
61679: PPUSH
61680: NOP4
61684: PUSH
61685: NOP4
61689: PUSH
61690: NOP4
61694: ARRAY
61695: PUSH
61696: LD_INT 1
61698: PLUS
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: PPUSH
61704: NOP4
61708: PPUSH
61709: NOP4
61713: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61714: NOP4
61718: PPUSH
61719: NOP4
61723: IFFALSE 61734
// ComExitBuilding ( j ) ;
61725: NOP4
61729: PPUSH
61730: NOP4
// wait ( 3 ) ;
61734: LD_INT 3
61736: PPUSH
61737: NOP4
// if not mc_construct_list [ i ] then
61741: NOP4
61745: PUSH
61746: NOP4
61750: ARRAY
61751: NOT
61752: IFFALSE 61756
// break ;
61754: GO 61794
// if not HasTask ( j ) then
61756: NOP4
61760: PPUSH
61761: NOP4
61765: NOT
61766: IFFALSE 61792
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61768: NOP4
61772: PPUSH
61773: NOP4
61777: PUSH
61778: NOP4
61782: ARRAY
61783: PUSH
61784: LD_INT 1
61786: ARRAY
61787: PPUSH
61788: NOP4
// end ;
61792: GO 61642
61794: POP
61795: POP
// end else
61796: GO 62629
// if mc_build_list [ i ] then
61798: NOP4
61802: PUSH
61803: NOP4
61807: ARRAY
61808: IFFALSE 62629
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61810: NOP4
61814: PUSH
61815: NOP4
61819: PUSH
61820: NOP4
61824: ARRAY
61825: PPUSH
61826: LD_INT 2
61828: PUSH
61829: LD_INT 30
61831: PUSH
61832: LD_INT 0
61834: PUSH
61835: EMPTY
61836: LIST
61837: LIST
61838: PUSH
61839: LD_INT 30
61841: PUSH
61842: LD_INT 1
61844: PUSH
61845: EMPTY
61846: LIST
61847: LIST
61848: PUSH
61849: EMPTY
61850: LIST
61851: LIST
61852: LIST
61853: PPUSH
61854: NOP4
61858: ST_TO_ADDR
// if depot then
61859: NOP4
61863: IFFALSE 61881
// depot := depot [ 1 ] else
61865: NOP4
61869: PUSH
61870: NOP4
61874: PUSH
61875: LD_INT 1
61877: ARRAY
61878: ST_TO_ADDR
61879: GO 61889
// depot := 0 ;
61881: NOP4
61885: PUSH
61886: LD_INT 0
61888: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61889: NOP4
61893: PUSH
61894: NOP4
61898: ARRAY
61899: PUSH
61900: LD_INT 1
61902: ARRAY
61903: PUSH
61904: LD_INT 1
61906: ARRAY
61907: PPUSH
61908: NOP4
61912: PUSH
61913: NOP4
61917: PUSH
61918: NOP4
61922: ARRAY
61923: PPUSH
61924: LD_INT 2
61926: PUSH
61927: LD_INT 30
61929: PUSH
61930: LD_INT 2
61932: PUSH
61933: EMPTY
61934: LIST
61935: LIST
61936: PUSH
61937: LD_INT 30
61939: PUSH
61940: LD_INT 3
61942: PUSH
61943: EMPTY
61944: LIST
61945: LIST
61946: PUSH
61947: EMPTY
61948: LIST
61949: LIST
61950: LIST
61951: PPUSH
61952: NOP4
61956: NOT
61957: AND
61958: IFFALSE 62063
// begin for j = 1 to mc_build_list [ i ] do
61960: NOP4
61964: PUSH
61965: DOUBLE
61966: LD_INT 1
61968: DEC
61969: ST_TO_ADDR
61970: NOP4
61974: PUSH
61975: NOP4
61979: ARRAY
61980: PUSH
61981: FOR_TO
61982: IFFALSE 62061
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61984: NOP4
61988: PUSH
61989: NOP4
61993: ARRAY
61994: PUSH
61995: NOP4
61999: ARRAY
62000: PUSH
62001: LD_INT 1
62003: ARRAY
62004: PUSH
62005: LD_INT 2
62007: EQUAL
62008: IFFALSE 62059
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62010: NOP4
62014: PUSH
62015: NOP4
62019: PPUSH
62020: NOP4
62024: PPUSH
62025: NOP4
62029: PUSH
62030: NOP4
62034: ARRAY
62035: PPUSH
62036: NOP4
62040: PPUSH
62041: LD_INT 1
62043: PPUSH
62044: LD_INT 0
62046: PPUSH
62047: NOP4
62051: PPUSH
62052: NOP4
62056: ST_TO_ADDR
// break ;
62057: GO 62061
// end ;
62059: GO 61981
62061: POP
62062: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62063: NOP4
62067: PUSH
62068: NOP4
62072: ARRAY
62073: PUSH
62074: LD_INT 1
62076: ARRAY
62077: PUSH
62078: LD_INT 1
62080: ARRAY
62081: PUSH
62082: LD_INT 0
62084: EQUAL
62085: PUSH
62086: NOP4
62090: PUSH
62091: NOP4
62095: PPUSH
62096: NOP4
62100: PUSH
62101: NOP4
62105: ARRAY
62106: PUSH
62107: LD_INT 1
62109: ARRAY
62110: PUSH
62111: LD_INT 1
62113: ARRAY
62114: PPUSH
62115: NOP4
62119: PUSH
62120: NOP4
62124: ARRAY
62125: PUSH
62126: LD_INT 1
62128: ARRAY
62129: PUSH
62130: LD_INT 2
62132: ARRAY
62133: PPUSH
62134: NOP4
62138: PUSH
62139: NOP4
62143: ARRAY
62144: PUSH
62145: LD_INT 1
62147: ARRAY
62148: PUSH
62149: LD_INT 3
62151: ARRAY
62152: PPUSH
62153: NOP4
62157: PUSH
62158: NOP4
62162: ARRAY
62163: PUSH
62164: LD_INT 1
62166: ARRAY
62167: PUSH
62168: LD_INT 4
62170: ARRAY
62171: PPUSH
62172: NOP4
62176: AND
62177: OR
62178: IFFALSE 62459
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62180: NOP4
62184: PUSH
62185: NOP4
62189: PUSH
62190: NOP4
62194: ARRAY
62195: PPUSH
62196: LD_INT 25
62198: PUSH
62199: LD_INT 2
62201: PUSH
62202: EMPTY
62203: LIST
62204: LIST
62205: PPUSH
62206: NOP4
62210: PUSH
62211: NOP4
62215: PUSH
62216: NOP4
62220: ARRAY
62221: DIFF
62222: ST_TO_ADDR
// if not tmp then
62223: NOP4
62227: NOT
62228: IFFALSE 62232
// continue ;
62230: GO 61477
// for j in tmp do
62232: NOP4
62236: PUSH
62237: NOP4
62241: PUSH
62242: FOR_IN
62243: IFFALSE 62455
// begin if not mc_builders [ i ] then
62245: NOP4
62249: PUSH
62250: NOP4
62254: ARRAY
62255: NOT
62256: IFFALSE 62314
// begin SetTag ( j , 103 ) ;
62258: NOP4
62262: PPUSH
62263: LD_INT 103
62265: PPUSH
62266: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62270: NOP4
62274: PUSH
62275: NOP4
62279: PPUSH
62280: NOP4
62284: PUSH
62285: NOP4
62289: PUSH
62290: NOP4
62294: ARRAY
62295: PUSH
62296: LD_INT 1
62298: PLUS
62299: PUSH
62300: EMPTY
62301: LIST
62302: LIST
62303: PPUSH
62304: NOP4
62308: PPUSH
62309: NOP4
62313: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62314: NOP4
62318: PPUSH
62319: NOP4
62323: IFFALSE 62334
// ComExitBuilding ( j ) ;
62325: NOP4
62329: PPUSH
62330: NOP4
// wait ( 3 ) ;
62334: LD_INT 3
62336: PPUSH
62337: NOP4
// if not mc_build_list [ i ] then
62341: NOP4
62345: PUSH
62346: NOP4
62350: ARRAY
62351: NOT
62352: IFFALSE 62356
// break ;
62354: GO 62455
// if not HasTask ( j ) then
62356: NOP4
62360: PPUSH
62361: NOP4
62365: NOT
62366: IFFALSE 62453
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62368: NOP4
62372: PPUSH
62373: NOP4
62377: PUSH
62378: NOP4
62382: ARRAY
62383: PUSH
62384: LD_INT 1
62386: ARRAY
62387: PUSH
62388: LD_INT 1
62390: ARRAY
62391: PPUSH
62392: NOP4
62396: PUSH
62397: NOP4
62401: ARRAY
62402: PUSH
62403: LD_INT 1
62405: ARRAY
62406: PUSH
62407: LD_INT 2
62409: ARRAY
62410: PPUSH
62411: NOP4
62415: PUSH
62416: NOP4
62420: ARRAY
62421: PUSH
62422: LD_INT 1
62424: ARRAY
62425: PUSH
62426: LD_INT 3
62428: ARRAY
62429: PPUSH
62430: NOP4
62434: PUSH
62435: NOP4
62439: ARRAY
62440: PUSH
62441: LD_INT 1
62443: ARRAY
62444: PUSH
62445: LD_INT 4
62447: ARRAY
62448: PPUSH
62449: NOP4
// end ;
62453: GO 62242
62455: POP
62456: POP
// end else
62457: GO 62629
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62459: NOP4
62463: PUSH
62464: NOP4
62468: ARRAY
62469: PPUSH
62470: NOP4
62474: PUSH
62475: NOP4
62479: ARRAY
62480: PUSH
62481: LD_INT 1
62483: ARRAY
62484: PUSH
62485: LD_INT 1
62487: ARRAY
62488: PPUSH
62489: NOP4
62493: PUSH
62494: NOP4
62498: ARRAY
62499: PUSH
62500: LD_INT 1
62502: ARRAY
62503: PUSH
62504: LD_INT 2
62506: ARRAY
62507: PPUSH
62508: NOP4
62512: PUSH
62513: NOP4
62517: ARRAY
62518: PUSH
62519: LD_INT 1
62521: ARRAY
62522: PUSH
62523: LD_INT 3
62525: ARRAY
62526: PPUSH
62527: NOP4
62531: PUSH
62532: NOP4
62536: ARRAY
62537: PUSH
62538: LD_INT 1
62540: ARRAY
62541: PUSH
62542: LD_INT 4
62544: ARRAY
62545: PPUSH
62546: NOP4
62550: PUSH
62551: NOP4
62555: ARRAY
62556: PPUSH
62557: LD_INT 21
62559: PUSH
62560: LD_INT 3
62562: PUSH
62563: EMPTY
62564: LIST
62565: LIST
62566: PPUSH
62567: NOP4
62571: PPUSH
62572: EMPTY
62573: PPUSH
62574: NOP4
62578: NOT
62579: IFFALSE 62629
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62581: NOP4
62585: PUSH
62586: NOP4
62590: PPUSH
62591: NOP4
62595: PPUSH
62596: NOP4
62600: PUSH
62601: NOP4
62605: ARRAY
62606: PPUSH
62607: LD_INT 1
62609: PPUSH
62610: LD_INT 1
62612: NEG
62613: PPUSH
62614: LD_INT 0
62616: PPUSH
62617: NOP4
62621: PPUSH
62622: NOP4
62626: ST_TO_ADDR
// continue ;
62627: GO 61477
// end ; end ; end ;
62629: GO 61477
62631: POP
62632: POP
// end ;
62633: LD_VAR 0 1
62637: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62638: LD_INT 0
62640: PPUSH
62641: PPUSH
62642: PPUSH
62643: PPUSH
62644: PPUSH
62645: PPUSH
// if not mc_bases then
62646: NOP4
62650: NOT
62651: IFFALSE 62655
// exit ;
62653: GO 63082
// for i = 1 to mc_bases do
62655: NOP4
62659: PUSH
62660: DOUBLE
62661: LD_INT 1
62663: DEC
62664: ST_TO_ADDR
62665: NOP4
62669: PUSH
62670: FOR_TO
62671: IFFALSE 63080
// begin tmp := mc_build_upgrade [ i ] ;
62673: NOP4
62677: PUSH
62678: NOP4
62682: PUSH
62683: NOP4
62687: ARRAY
62688: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62689: NOP4
62693: PUSH
62694: NOP4
62698: PUSH
62699: NOP4
62703: ARRAY
62704: PPUSH
62705: LD_INT 2
62707: PUSH
62708: LD_INT 30
62710: PUSH
62711: LD_INT 6
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: PUSH
62718: LD_INT 30
62720: PUSH
62721: LD_INT 7
62723: PUSH
62724: EMPTY
62725: LIST
62726: LIST
62727: PUSH
62728: EMPTY
62729: LIST
62730: LIST
62731: LIST
62732: PPUSH
62733: NOP4
62737: ST_TO_ADDR
// if not tmp and not lab then
62738: NOP4
62742: NOT
62743: PUSH
62744: NOP4
62748: NOT
62749: AND
62750: IFFALSE 62754
// continue ;
62752: GO 62670
// if tmp then
62754: NOP4
62758: IFFALSE 62878
// for j in tmp do
62760: NOP4
62764: PUSH
62765: NOP4
62769: PUSH
62770: FOR_IN
62771: IFFALSE 62876
// begin if UpgradeCost ( j ) then
62773: NOP4
62777: PPUSH
62778: NOP4
62782: IFFALSE 62874
// begin ComUpgrade ( j ) ;
62784: NOP4
62788: PPUSH
62789: NOP4
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62793: NOP4
62797: PUSH
62798: NOP4
62802: PPUSH
62803: NOP4
62807: PPUSH
62808: NOP4
62812: PUSH
62813: NOP4
62817: ARRAY
62818: PUSH
62819: NOP4
62823: DIFF
62824: PPUSH
62825: NOP4
62829: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62830: NOP4
62834: PUSH
62835: NOP4
62839: PPUSH
62840: NOP4
62844: PUSH
62845: NOP4
62849: PUSH
62850: NOP4
62854: ARRAY
62855: PUSH
62856: LD_INT 1
62858: PLUS
62859: PUSH
62860: EMPTY
62861: LIST
62862: LIST
62863: PPUSH
62864: NOP4
62868: PPUSH
62869: NOP4
62873: ST_TO_ADDR
// end ; end ;
62874: GO 62770
62876: POP
62877: POP
// if not lab or not mc_lab_upgrade [ i ] then
62878: NOP4
62882: NOT
62883: PUSH
62884: NOP4
62888: PUSH
62889: NOP4
62893: ARRAY
62894: NOT
62895: OR
62896: IFFALSE 62900
// continue ;
62898: GO 62670
// for j in lab do
62900: NOP4
62904: PUSH
62905: NOP4
62909: PUSH
62910: FOR_IN
62911: IFFALSE 63076
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62913: NOP4
62917: PPUSH
62918: NOP4
62922: PUSH
62923: LD_INT 6
62925: PUSH
62926: LD_INT 7
62928: PUSH
62929: EMPTY
62930: LIST
62931: LIST
62932: IN
62933: PUSH
62934: NOP4
62938: PPUSH
62939: NOP4
62943: PUSH
62944: LD_INT 1
62946: NONEQUAL
62947: AND
62948: IFFALSE 63074
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62950: NOP4
62954: PPUSH
62955: NOP4
62959: PUSH
62960: NOP4
62964: ARRAY
62965: PUSH
62966: LD_INT 1
62968: ARRAY
62969: PPUSH
62970: NOP4
62974: IFFALSE 63074
// begin ComCancel ( j ) ;
62976: NOP4
62980: PPUSH
62981: NOP4
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62985: NOP4
62989: PPUSH
62990: NOP4
62994: PUSH
62995: NOP4
62999: ARRAY
63000: PUSH
63001: LD_INT 1
63003: ARRAY
63004: PPUSH
63005: NOP4
// if not j in mc_construct_list [ i ] then
63009: NOP4
63013: PUSH
63014: NOP4
63018: PUSH
63019: NOP4
63023: ARRAY
63024: IN
63025: NOT
63026: IFFALSE 63072
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63028: NOP4
63032: PUSH
63033: NOP4
63037: PPUSH
63038: NOP4
63042: PUSH
63043: NOP4
63047: PUSH
63048: NOP4
63052: ARRAY
63053: PUSH
63054: LD_INT 1
63056: PLUS
63057: PUSH
63058: EMPTY
63059: LIST
63060: LIST
63061: PPUSH
63062: NOP4
63066: PPUSH
63067: NOP4
63071: ST_TO_ADDR
// break ;
63072: GO 63076
// end ; end ; end ;
63074: GO 62910
63076: POP
63077: POP
// end ;
63078: GO 62670
63080: POP
63081: POP
// end ;
63082: LD_VAR 0 1
63086: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63087: LD_INT 0
63089: PPUSH
63090: PPUSH
63091: PPUSH
63092: PPUSH
63093: PPUSH
63094: PPUSH
63095: PPUSH
63096: PPUSH
63097: PPUSH
// if not mc_bases then
63098: NOP4
63102: NOT
63103: IFFALSE 63107
// exit ;
63105: GO 63512
// for i = 1 to mc_bases do
63107: NOP4
63111: PUSH
63112: DOUBLE
63113: LD_INT 1
63115: DEC
63116: ST_TO_ADDR
63117: NOP4
63121: PUSH
63122: FOR_TO
63123: IFFALSE 63510
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63125: NOP4
63129: PUSH
63130: NOP4
63134: ARRAY
63135: NOT
63136: PUSH
63137: NOP4
63141: PUSH
63142: NOP4
63146: ARRAY
63147: PPUSH
63148: LD_INT 30
63150: PUSH
63151: LD_INT 3
63153: PUSH
63154: EMPTY
63155: LIST
63156: LIST
63157: PPUSH
63158: NOP4
63162: NOT
63163: OR
63164: IFFALSE 63168
// continue ;
63166: GO 63122
// busy := false ;
63168: NOP4
63172: PUSH
63173: LD_INT 0
63175: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63176: NOP4
63180: PUSH
63181: NOP4
63185: PUSH
63186: NOP4
63190: ARRAY
63191: PPUSH
63192: LD_INT 30
63194: PUSH
63195: LD_INT 3
63197: PUSH
63198: EMPTY
63199: LIST
63200: LIST
63201: PPUSH
63202: NOP4
63206: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63207: NOP4
63211: PUSH
63212: NOP4
63216: PUSH
63217: NOP4
63221: ARRAY
63222: PPUSH
63223: LD_INT 2
63225: PUSH
63226: LD_INT 30
63228: PUSH
63229: LD_INT 32
63231: PUSH
63232: EMPTY
63233: LIST
63234: LIST
63235: PUSH
63236: LD_INT 30
63238: PUSH
63239: LD_INT 33
63241: PUSH
63242: EMPTY
63243: LIST
63244: LIST
63245: PUSH
63246: EMPTY
63247: LIST
63248: LIST
63249: LIST
63250: PPUSH
63251: NOP4
63255: ST_TO_ADDR
// if not t then
63256: NOP4
63260: NOT
63261: IFFALSE 63265
// continue ;
63263: GO 63122
// for j in tmp do
63265: NOP4
63269: PUSH
63270: NOP4
63274: PUSH
63275: FOR_IN
63276: IFFALSE 63306
// if not BuildingStatus ( j ) = bs_idle then
63278: NOP4
63282: PPUSH
63283: NOP4
63287: PUSH
63288: LD_INT 2
63290: EQUAL
63291: NOT
63292: IFFALSE 63304
// begin busy := true ;
63294: NOP4
63298: PUSH
63299: LD_INT 1
63301: ST_TO_ADDR
// break ;
63302: GO 63306
// end ;
63304: GO 63275
63306: POP
63307: POP
// if busy then
63308: NOP4
63312: IFFALSE 63316
// continue ;
63314: GO 63122
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63316: NOP4
63320: PUSH
63321: NOP4
63325: PPUSH
63326: LD_INT 35
63328: PUSH
63329: LD_INT 0
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PPUSH
63336: NOP4
63340: ST_TO_ADDR
// if tw then
63341: NOP4
63345: IFFALSE 63422
// begin tw := tw [ 1 ] ;
63347: NOP4
63351: PUSH
63352: NOP4
63356: PUSH
63357: LD_INT 1
63359: ARRAY
63360: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63361: NOP4
63365: PUSH
63366: NOP4
63370: PPUSH
63371: NOP4
63375: PUSH
63376: NOP4
63380: ARRAY
63381: PPUSH
63382: NOP4
63386: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63387: NOP4
63391: PUSH
63392: NOP4
63396: ARRAY
63397: IFFALSE 63420
// if not weapon in mc_allowed_tower_weapons [ i ] then
63399: NOP4
63403: PUSH
63404: NOP4
63408: PUSH
63409: NOP4
63413: ARRAY
63414: IN
63415: NOT
63416: IFFALSE 63420
// continue ;
63418: GO 63122
// end else
63420: GO 63485
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63422: NOP4
63426: PUSH
63427: NOP4
63431: PUSH
63432: NOP4
63436: ARRAY
63437: PPUSH
63438: NOP4
63442: PPUSH
63443: NOP4
63447: ST_TO_ADDR
// if not tmp2 then
63448: NOP4
63452: NOT
63453: IFFALSE 63457
// continue ;
63455: GO 63122
// tw := tmp2 [ 1 ] ;
63457: NOP4
63461: PUSH
63462: NOP4
63466: PUSH
63467: LD_INT 1
63469: ARRAY
63470: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63471: NOP4
63475: PUSH
63476: NOP4
63480: PUSH
63481: LD_INT 2
63483: ARRAY
63484: ST_TO_ADDR
// end ; if not weapon then
63485: NOP4
63489: NOT
63490: IFFALSE 63494
// continue ;
63492: GO 63122
// ComPlaceWeapon ( tw , weapon ) ;
63494: NOP4
63498: PPUSH
63499: NOP4
63503: PPUSH
63504: NOP4
// end ;
63508: GO 63122
63510: POP
63511: POP
// end ;
63512: LD_VAR 0 1
63516: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63517: LD_INT 0
63519: PPUSH
63520: PPUSH
63521: PPUSH
63522: PPUSH
63523: PPUSH
63524: PPUSH
63525: PPUSH
// if not mc_bases then
63526: NOP4
63530: NOT
63531: IFFALSE 63535
// exit ;
63533: GO 64303
// for i = 1 to mc_bases do
63535: NOP4
63539: PUSH
63540: DOUBLE
63541: LD_INT 1
63543: DEC
63544: ST_TO_ADDR
63545: NOP4
63549: PUSH
63550: FOR_TO
63551: IFFALSE 64301
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63553: NOP4
63557: PUSH
63558: NOP4
63562: ARRAY
63563: NOT
63564: PUSH
63565: NOP4
63569: PUSH
63570: NOP4
63574: ARRAY
63575: PUSH
63576: NOP4
63580: PUSH
63581: NOP4
63585: ARRAY
63586: EQUAL
63587: OR
63588: PUSH
63589: NOP4
63593: PUSH
63594: NOP4
63598: ARRAY
63599: OR
63600: IFFALSE 63604
// continue ;
63602: GO 63550
// if mc_miners [ i ] then
63604: NOP4
63608: PUSH
63609: NOP4
63613: ARRAY
63614: IFFALSE 63988
// begin for j = mc_miners [ i ] downto 1 do
63616: NOP4
63620: PUSH
63621: DOUBLE
63622: NOP4
63626: PUSH
63627: NOP4
63631: ARRAY
63632: INC
63633: ST_TO_ADDR
63634: LD_INT 1
63636: PUSH
63637: FOR_DOWNTO
63638: IFFALSE 63986
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63640: NOP4
63644: PUSH
63645: NOP4
63649: ARRAY
63650: PUSH
63651: NOP4
63655: ARRAY
63656: PPUSH
63657: NOP4
63661: PUSH
63662: NOP4
63666: PUSH
63667: NOP4
63671: ARRAY
63672: PUSH
63673: NOP4
63677: ARRAY
63678: PPUSH
63679: NOP4
63683: PUSH
63684: LD_INT 1
63686: NONEQUAL
63687: OR
63688: IFFALSE 63751
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63690: NOP4
63694: PUSH
63695: NOP4
63699: PUSH
63700: NOP4
63704: ARRAY
63705: PUSH
63706: NOP4
63710: PUSH
63711: NOP4
63715: ARRAY
63716: PUSH
63717: NOP4
63721: ARRAY
63722: DIFF
63723: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63724: NOP4
63728: PUSH
63729: NOP4
63733: PPUSH
63734: NOP4
63738: PPUSH
63739: NOP4
63743: PPUSH
63744: NOP4
63748: ST_TO_ADDR
// continue ;
63749: GO 63637
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63751: NOP4
63755: PUSH
63756: NOP4
63760: ARRAY
63761: PUSH
63762: NOP4
63766: ARRAY
63767: PPUSH
63768: NOP4
63772: PUSH
63773: LD_INT 1
63775: EQUAL
63776: PUSH
63777: NOP4
63781: PUSH
63782: NOP4
63786: ARRAY
63787: PUSH
63788: NOP4
63792: ARRAY
63793: PPUSH
63794: NOP4
63798: NOT
63799: AND
63800: PUSH
63801: NOP4
63805: PUSH
63806: NOP4
63810: ARRAY
63811: PUSH
63812: NOP4
63816: ARRAY
63817: PPUSH
63818: NOP4
63822: NOT
63823: AND
63824: IFFALSE 63984
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63826: NOP4
63830: PUSH
63831: NOP4
63835: ARRAY
63836: PUSH
63837: NOP4
63841: ARRAY
63842: PPUSH
63843: NOP4
63847: IFFALSE 63870
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63849: NOP4
63853: PUSH
63854: NOP4
63858: ARRAY
63859: PUSH
63860: NOP4
63864: ARRAY
63865: PPUSH
63866: NOP4
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63870: NOP4
63874: PUSH
63875: NOP4
63879: ARRAY
63880: PUSH
63881: NOP4
63885: ARRAY
63886: PPUSH
63887: NOP4
63891: NOT
63892: IFFALSE 63984
// begin r := rand ( 1 , mc_mines [ i ] ) ;
63894: NOP4
63898: PUSH
63899: LD_INT 1
63901: PPUSH
63902: NOP4
63906: PUSH
63907: NOP4
63911: ARRAY
63912: PPUSH
63913: NOP4
63917: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
63918: NOP4
63922: PUSH
63923: NOP4
63927: ARRAY
63928: PUSH
63929: NOP4
63933: ARRAY
63934: PPUSH
63935: NOP4
63939: PUSH
63940: NOP4
63944: ARRAY
63945: PUSH
63946: NOP4
63950: ARRAY
63951: PUSH
63952: LD_INT 1
63954: ARRAY
63955: PPUSH
63956: NOP4
63960: PUSH
63961: NOP4
63965: ARRAY
63966: PUSH
63967: NOP4
63971: ARRAY
63972: PUSH
63973: LD_INT 2
63975: ARRAY
63976: PPUSH
63977: LD_INT 0
63979: PPUSH
63980: NOP4
// end ; end ; end ;
63984: GO 63637
63986: POP
63987: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63988: NOP4
63992: PUSH
63993: NOP4
63997: PUSH
63998: NOP4
64002: ARRAY
64003: PPUSH
64004: LD_INT 2
64006: PUSH
64007: LD_INT 30
64009: PUSH
64010: LD_INT 4
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: LD_INT 30
64019: PUSH
64020: LD_INT 5
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: LD_INT 30
64029: PUSH
64030: LD_INT 32
64032: PUSH
64033: EMPTY
64034: LIST
64035: LIST
64036: PUSH
64037: EMPTY
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: PPUSH
64043: NOP4
64047: ST_TO_ADDR
// if not tmp then
64048: NOP4
64052: NOT
64053: IFFALSE 64057
// continue ;
64055: GO 63550
// list := [ ] ;
64057: NOP4
64061: PUSH
64062: EMPTY
64063: ST_TO_ADDR
// for j in tmp do
64064: NOP4
64068: PUSH
64069: NOP4
64073: PUSH
64074: FOR_IN
64075: IFFALSE 64144
// begin for k in UnitsInside ( j ) do
64077: NOP4
64081: PUSH
64082: NOP4
64086: PPUSH
64087: NOP4
64091: PUSH
64092: FOR_IN
64093: IFFALSE 64140
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64095: NOP4
64099: PPUSH
64100: NOP4
64104: PUSH
64105: LD_INT 1
64107: EQUAL
64108: PUSH
64109: NOP4
64113: PPUSH
64114: NOP4
64118: NOT
64119: AND
64120: IFFALSE 64138
// list := list ^ k ;
64122: NOP4
64126: PUSH
64127: NOP4
64131: PUSH
64132: NOP4
64136: ADD
64137: ST_TO_ADDR
64138: GO 64092
64140: POP
64141: POP
// end ;
64142: GO 64074
64144: POP
64145: POP
// list := list diff mc_miners [ i ] ;
64146: NOP4
64150: PUSH
64151: NOP4
64155: PUSH
64156: NOP4
64160: PUSH
64161: NOP4
64165: ARRAY
64166: DIFF
64167: ST_TO_ADDR
// if not list then
64168: NOP4
64172: NOT
64173: IFFALSE 64177
// continue ;
64175: GO 63550
// k := mc_mines [ i ] - mc_miners [ i ] ;
64177: NOP4
64181: PUSH
64182: NOP4
64186: PUSH
64187: NOP4
64191: ARRAY
64192: PUSH
64193: NOP4
64197: PUSH
64198: NOP4
64202: ARRAY
64203: MINUS
64204: ST_TO_ADDR
// if k > list then
64205: NOP4
64209: PUSH
64210: NOP4
64214: GREATER
64215: IFFALSE 64227
// k := list ;
64217: NOP4
64221: PUSH
64222: NOP4
64226: ST_TO_ADDR
// for j = 1 to k do
64227: NOP4
64231: PUSH
64232: DOUBLE
64233: LD_INT 1
64235: DEC
64236: ST_TO_ADDR
64237: NOP4
64241: PUSH
64242: FOR_TO
64243: IFFALSE 64297
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64245: NOP4
64249: PUSH
64250: NOP4
64254: PPUSH
64255: NOP4
64259: PUSH
64260: NOP4
64264: PUSH
64265: NOP4
64269: ARRAY
64270: PUSH
64271: LD_INT 1
64273: PLUS
64274: PUSH
64275: EMPTY
64276: LIST
64277: LIST
64278: PPUSH
64279: NOP4
64283: PUSH
64284: NOP4
64288: ARRAY
64289: PPUSH
64290: NOP4
64294: ST_TO_ADDR
64295: GO 64242
64297: POP
64298: POP
// end ;
64299: GO 63550
64301: POP
64302: POP
// end ;
64303: LD_VAR 0 1
64307: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64308: LD_INT 0
64310: PPUSH
64311: PPUSH
64312: PPUSH
64313: PPUSH
64314: PPUSH
64315: PPUSH
64316: PPUSH
64317: PPUSH
64318: PPUSH
64319: PPUSH
64320: PPUSH
// if not mc_bases then
64321: NOP4
64325: NOT
64326: IFFALSE 64330
// exit ;
64328: GO 66153
// for i = 1 to mc_bases do
64330: NOP4
64334: PUSH
64335: DOUBLE
64336: LD_INT 1
64338: DEC
64339: ST_TO_ADDR
64340: NOP4
64344: PUSH
64345: FOR_TO
64346: IFFALSE 66151
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64348: NOP4
64352: PUSH
64353: NOP4
64357: ARRAY
64358: NOT
64359: PUSH
64360: NOP4
64364: PUSH
64365: NOP4
64369: ARRAY
64370: OR
64371: IFFALSE 64375
// continue ;
64373: GO 64345
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64375: NOP4
64379: PUSH
64380: NOP4
64384: ARRAY
64385: NOT
64386: PUSH
64387: NOP4
64391: PUSH
64392: NOP4
64396: ARRAY
64397: AND
64398: IFFALSE 64436
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64400: NOP4
64404: PUSH
64405: NOP4
64409: PPUSH
64410: NOP4
64414: PPUSH
64415: EMPTY
64416: PPUSH
64417: NOP4
64421: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64422: NOP4
64426: PPUSH
64427: LD_INT 107
64429: PPUSH
64430: NOP4
// continue ;
64434: GO 64345
// end ; target := [ ] ;
64436: NOP4
64440: PUSH
64441: EMPTY
64442: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64443: NOP4
64447: PUSH
64448: NOP4
64452: PUSH
64453: NOP4
64457: ARRAY
64458: PUSH
64459: LD_INT 1
64461: ARRAY
64462: PPUSH
64463: NOP4
64467: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64468: NOP4
64472: PUSH
64473: NOP4
64477: PUSH
64478: NOP4
64482: ARRAY
64483: PPUSH
64484: LD_INT 2
64486: PUSH
64487: LD_INT 30
64489: PUSH
64490: LD_INT 0
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: LD_INT 30
64499: PUSH
64500: LD_INT 1
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: PUSH
64507: EMPTY
64508: LIST
64509: LIST
64510: LIST
64511: PPUSH
64512: NOP4
64516: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64517: NOP4
64521: PUSH
64522: DOUBLE
64523: NOP4
64527: PUSH
64528: NOP4
64532: ARRAY
64533: INC
64534: ST_TO_ADDR
64535: LD_INT 1
64537: PUSH
64538: FOR_DOWNTO
64539: IFFALSE 64784
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64541: NOP4
64545: PUSH
64546: NOP4
64550: ARRAY
64551: PUSH
64552: NOP4
64556: ARRAY
64557: PUSH
64558: LD_INT 2
64560: ARRAY
64561: PPUSH
64562: NOP4
64566: PUSH
64567: NOP4
64571: ARRAY
64572: PUSH
64573: NOP4
64577: ARRAY
64578: PUSH
64579: LD_INT 3
64581: ARRAY
64582: PPUSH
64583: NOP4
64587: PUSH
64588: NOP4
64592: PUSH
64593: NOP4
64597: ARRAY
64598: PUSH
64599: NOP4
64603: ARRAY
64604: PUSH
64605: LD_INT 2
64607: ARRAY
64608: PPUSH
64609: NOP4
64613: PUSH
64614: NOP4
64618: ARRAY
64619: PUSH
64620: NOP4
64624: ARRAY
64625: PUSH
64626: LD_INT 3
64628: ARRAY
64629: PPUSH
64630: NOP4
64634: PUSH
64635: LD_INT 0
64637: EQUAL
64638: AND
64639: IFFALSE 64694
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64641: NOP4
64645: PUSH
64646: NOP4
64650: PUSH
64651: NOP4
64655: ARRAY
64656: PPUSH
64657: NOP4
64661: PPUSH
64662: NOP4
64666: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64667: NOP4
64671: PUSH
64672: NOP4
64676: PPUSH
64677: NOP4
64681: PPUSH
64682: NOP4
64686: PPUSH
64687: NOP4
64691: ST_TO_ADDR
// continue ;
64692: GO 64538
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64694: NOP4
64698: PPUSH
64699: NOP4
64703: PUSH
64704: NOP4
64708: ARRAY
64709: PUSH
64710: NOP4
64714: ARRAY
64715: PUSH
64716: LD_INT 2
64718: ARRAY
64719: PPUSH
64720: NOP4
64724: PUSH
64725: NOP4
64729: ARRAY
64730: PUSH
64731: NOP4
64735: ARRAY
64736: PUSH
64737: LD_INT 3
64739: ARRAY
64740: PPUSH
64741: LD_INT 30
64743: PPUSH
64744: NOP4
64748: PUSH
64749: LD_INT 4
64751: ARRAY
64752: PUSH
64753: LD_INT 0
64755: EQUAL
64756: IFFALSE 64782
// begin target := mc_crates [ i ] [ j ] ;
64758: NOP4
64762: PUSH
64763: NOP4
64767: PUSH
64768: NOP4
64772: ARRAY
64773: PUSH
64774: NOP4
64778: ARRAY
64779: ST_TO_ADDR
// break ;
64780: GO 64784
// end ; end ;
64782: GO 64538
64784: POP
64785: POP
// if not target then
64786: NOP4
64790: NOT
64791: IFFALSE 64795
// continue ;
64793: GO 64345
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64795: NOP4
64799: PUSH
64800: NOP4
64804: PUSH
64805: NOP4
64809: ARRAY
64810: PPUSH
64811: LD_INT 2
64813: PUSH
64814: LD_INT 3
64816: PUSH
64817: LD_INT 58
64819: PUSH
64820: EMPTY
64821: LIST
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: PUSH
64827: LD_INT 61
64829: PUSH
64830: EMPTY
64831: LIST
64832: PUSH
64833: LD_INT 33
64835: PUSH
64836: LD_INT 5
64838: PUSH
64839: EMPTY
64840: LIST
64841: LIST
64842: PUSH
64843: LD_INT 33
64845: PUSH
64846: LD_INT 3
64848: PUSH
64849: EMPTY
64850: LIST
64851: LIST
64852: PUSH
64853: EMPTY
64854: LIST
64855: LIST
64856: LIST
64857: LIST
64858: LIST
64859: PUSH
64860: LD_INT 2
64862: PUSH
64863: LD_INT 34
64865: PUSH
64866: LD_INT 32
64868: PUSH
64869: EMPTY
64870: LIST
64871: LIST
64872: PUSH
64873: LD_INT 34
64875: PUSH
64876: LD_INT 51
64878: PUSH
64879: EMPTY
64880: LIST
64881: LIST
64882: PUSH
64883: LD_INT 34
64885: PUSH
64886: LD_INT 12
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: PUSH
64893: EMPTY
64894: LIST
64895: LIST
64896: LIST
64897: LIST
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PPUSH
64903: NOP4
64907: ST_TO_ADDR
// if not cargo then
64908: NOP4
64912: NOT
64913: IFFALSE 65619
// begin if mc_crates_collector [ i ] < 5 then
64915: NOP4
64919: PUSH
64920: NOP4
64924: ARRAY
64925: PUSH
64926: LD_INT 5
64928: LESS
64929: IFFALSE 65295
// begin if mc_ape [ i ] then
64931: NOP4
64935: PUSH
64936: NOP4
64940: ARRAY
64941: IFFALSE 64988
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64943: NOP4
64947: PUSH
64948: NOP4
64952: PUSH
64953: NOP4
64957: ARRAY
64958: PPUSH
64959: LD_INT 25
64961: PUSH
64962: LD_INT 16
64964: PUSH
64965: EMPTY
64966: LIST
64967: LIST
64968: PUSH
64969: LD_INT 24
64971: PUSH
64972: LD_INT 750
64974: PUSH
64975: EMPTY
64976: LIST
64977: LIST
64978: PUSH
64979: EMPTY
64980: LIST
64981: LIST
64982: PPUSH
64983: NOP4
64987: ST_TO_ADDR
// if not tmp then
64988: NOP4
64992: NOT
64993: IFFALSE 65040
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64995: NOP4
64999: PUSH
65000: NOP4
65004: PUSH
65005: NOP4
65009: ARRAY
65010: PPUSH
65011: LD_INT 25
65013: PUSH
65014: LD_INT 2
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: PUSH
65021: LD_INT 24
65023: PUSH
65024: LD_INT 750
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PUSH
65031: EMPTY
65032: LIST
65033: LIST
65034: PPUSH
65035: NOP4
65039: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65040: NOP4
65044: PUSH
65045: NOP4
65049: ARRAY
65050: PUSH
65051: NOP4
65055: PUSH
65056: NOP4
65060: ARRAY
65061: PPUSH
65062: LD_INT 25
65064: PUSH
65065: LD_INT 2
65067: PUSH
65068: EMPTY
65069: LIST
65070: LIST
65071: PUSH
65072: LD_INT 24
65074: PUSH
65075: LD_INT 750
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: PUSH
65082: EMPTY
65083: LIST
65084: LIST
65085: PPUSH
65086: NOP4
65090: AND
65091: PUSH
65092: NOP4
65096: PUSH
65097: LD_INT 5
65099: LESS
65100: AND
65101: IFFALSE 65183
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65103: NOP4
65107: PUSH
65108: NOP4
65112: PUSH
65113: NOP4
65117: ARRAY
65118: PPUSH
65119: LD_INT 25
65121: PUSH
65122: LD_INT 2
65124: PUSH
65125: EMPTY
65126: LIST
65127: LIST
65128: PUSH
65129: LD_INT 24
65131: PUSH
65132: LD_INT 750
65134: PUSH
65135: EMPTY
65136: LIST
65137: LIST
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: PPUSH
65143: NOP4
65147: PUSH
65148: FOR_IN
65149: IFFALSE 65181
// begin tmp := tmp union j ;
65151: NOP4
65155: PUSH
65156: NOP4
65160: PUSH
65161: NOP4
65165: UNION
65166: ST_TO_ADDR
// if tmp >= 5 then
65167: NOP4
65171: PUSH
65172: LD_INT 5
65174: GREATEREQUAL
65175: IFFALSE 65179
// break ;
65177: GO 65181
// end ;
65179: GO 65148
65181: POP
65182: POP
// end ; if not tmp then
65183: NOP4
65187: NOT
65188: IFFALSE 65192
// continue ;
65190: GO 64345
// for j in tmp do
65192: NOP4
65196: PUSH
65197: NOP4
65201: PUSH
65202: FOR_IN
65203: IFFALSE 65293
// if not GetTag ( j ) then
65205: NOP4
65209: PPUSH
65210: NOP4
65214: NOT
65215: IFFALSE 65291
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65217: NOP4
65221: PUSH
65222: NOP4
65226: PPUSH
65227: NOP4
65231: PUSH
65232: NOP4
65236: PUSH
65237: NOP4
65241: ARRAY
65242: PUSH
65243: LD_INT 1
65245: PLUS
65246: PUSH
65247: EMPTY
65248: LIST
65249: LIST
65250: PPUSH
65251: NOP4
65255: PPUSH
65256: NOP4
65260: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65261: NOP4
65265: PPUSH
65266: LD_INT 107
65268: PPUSH
65269: NOP4
// if mc_crates_collector [ i ] >= 5 then
65273: NOP4
65277: PUSH
65278: NOP4
65282: ARRAY
65283: PUSH
65284: LD_INT 5
65286: GREATEREQUAL
65287: IFFALSE 65291
// break ;
65289: GO 65293
// end ;
65291: GO 65202
65293: POP
65294: POP
// end ; if mc_crates_collector [ i ] and target then
65295: NOP4
65299: PUSH
65300: NOP4
65304: ARRAY
65305: PUSH
65306: NOP4
65310: AND
65311: IFFALSE 65617
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65313: NOP4
65317: PUSH
65318: NOP4
65322: ARRAY
65323: PUSH
65324: NOP4
65328: PUSH
65329: LD_INT 1
65331: ARRAY
65332: LESS
65333: IFFALSE 65353
// tmp := mc_crates_collector [ i ] else
65335: NOP4
65339: PUSH
65340: NOP4
65344: PUSH
65345: NOP4
65349: ARRAY
65350: ST_TO_ADDR
65351: GO 65367
// tmp := target [ 1 ] ;
65353: NOP4
65357: PUSH
65358: NOP4
65362: PUSH
65363: LD_INT 1
65365: ARRAY
65366: ST_TO_ADDR
// k := 0 ;
65367: NOP4
65371: PUSH
65372: LD_INT 0
65374: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65375: NOP4
65379: PUSH
65380: NOP4
65384: PUSH
65385: NOP4
65389: ARRAY
65390: PUSH
65391: FOR_IN
65392: IFFALSE 65615
// begin k := k + 1 ;
65394: NOP4
65398: PUSH
65399: NOP4
65403: PUSH
65404: LD_INT 1
65406: PLUS
65407: ST_TO_ADDR
// if k > tmp then
65408: NOP4
65412: PUSH
65413: NOP4
65417: GREATER
65418: IFFALSE 65422
// break ;
65420: GO 65615
// if not GetClass ( j ) in [ 2 , 16 ] then
65422: NOP4
65426: PPUSH
65427: NOP4
65431: PUSH
65432: LD_INT 2
65434: PUSH
65435: LD_INT 16
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: IN
65442: NOT
65443: IFFALSE 65496
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65445: NOP4
65449: PUSH
65450: NOP4
65454: PPUSH
65455: NOP4
65459: PPUSH
65460: NOP4
65464: PUSH
65465: NOP4
65469: ARRAY
65470: PUSH
65471: NOP4
65475: DIFF
65476: PPUSH
65477: NOP4
65481: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65482: NOP4
65486: PPUSH
65487: LD_INT 0
65489: PPUSH
65490: NOP4
// continue ;
65494: GO 65391
// end ; if IsInUnit ( j ) then
65496: NOP4
65500: PPUSH
65501: NOP4
65505: IFFALSE 65516
// ComExitBuilding ( j ) ;
65507: NOP4
65511: PPUSH
65512: NOP4
// wait ( 3 ) ;
65516: LD_INT 3
65518: PPUSH
65519: NOP4
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65523: NOP4
65527: PPUSH
65528: NOP4
65532: PUSH
65533: NOP4
65537: PPUSH
65538: NOP4
65542: PUSH
65543: LD_INT 2
65545: ARRAY
65546: PPUSH
65547: NOP4
65551: PUSH
65552: LD_INT 3
65554: ARRAY
65555: PPUSH
65556: LD_INT 30
65558: PPUSH
65559: NOP4
65563: PUSH
65564: LD_INT 4
65566: ARRAY
65567: AND
65568: IFFALSE 65586
// ComStandNearbyBuilding ( j , depot ) else
65570: NOP4
65574: PPUSH
65575: NOP4
65579: PPUSH
65580: NOP4
65584: GO 65613
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65586: NOP4
65590: PPUSH
65591: NOP4
65595: PUSH
65596: LD_INT 2
65598: ARRAY
65599: PPUSH
65600: NOP4
65604: PUSH
65605: LD_INT 3
65607: ARRAY
65608: PPUSH
65609: NOP4
// end ;
65613: GO 65391
65615: POP
65616: POP
// end ; end else
65617: GO 66149
// begin for j in cargo do
65619: NOP4
65623: PUSH
65624: NOP4
65628: PUSH
65629: FOR_IN
65630: IFFALSE 66147
// begin if GetTag ( j ) <> 0 then
65632: NOP4
65636: PPUSH
65637: NOP4
65641: PUSH
65642: LD_INT 0
65644: NONEQUAL
65645: IFFALSE 65649
// continue ;
65647: GO 65629
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65649: NOP4
65653: PPUSH
65654: NOP4
65658: PUSH
65659: LD_INT 1000
65661: LESS
65662: PUSH
65663: NOP4
65667: PPUSH
65668: NOP4
65672: PUSH
65673: NOP4
65677: ARRAY
65678: PPUSH
65679: NOP4
65683: NOT
65684: AND
65685: IFFALSE 65707
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65687: NOP4
65691: PPUSH
65692: NOP4
65696: PUSH
65697: NOP4
65701: ARRAY
65702: PPUSH
65703: NOP4
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65707: NOP4
65711: PPUSH
65712: NOP4
65716: PUSH
65717: LD_INT 1000
65719: LESS
65720: PUSH
65721: NOP4
65725: PPUSH
65726: NOP4
65730: PUSH
65731: NOP4
65735: ARRAY
65736: PPUSH
65737: NOP4
65741: AND
65742: IFFALSE 65746
// continue ;
65744: GO 65629
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65746: NOP4
65750: PPUSH
65751: NOP4
65755: PUSH
65756: LD_INT 2
65758: EQUAL
65759: PUSH
65760: NOP4
65764: PPUSH
65765: NOP4
65769: PUSH
65770: LD_INT 15
65772: LESS
65773: AND
65774: IFFALSE 65778
// continue ;
65776: GO 65629
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65778: NOP4
65782: PPUSH
65783: NOP4
65787: PUSH
65788: LD_INT 1
65790: EQUAL
65791: PUSH
65792: NOP4
65796: PPUSH
65797: NOP4
65801: PUSH
65802: LD_INT 10
65804: LESS
65805: AND
65806: IFFALSE 66086
// begin if not depot then
65808: NOP4
65812: NOT
65813: IFFALSE 65817
// continue ;
65815: GO 65629
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65817: NOP4
65821: PPUSH
65822: NOP4
65826: PPUSH
65827: NOP4
65831: PPUSH
65832: NOP4
65836: PPUSH
65837: NOP4
65841: PUSH
65842: LD_INT 6
65844: LESS
65845: IFFALSE 65861
// SetFuel ( j , 100 ) else
65847: NOP4
65851: PPUSH
65852: LD_INT 100
65854: PPUSH
65855: NOP4
65859: GO 66086
// if GetFuel ( j ) = 0 then
65861: NOP4
65865: PPUSH
65866: NOP4
65870: PUSH
65871: LD_INT 0
65873: EQUAL
65874: IFFALSE 66086
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65876: NOP4
65880: PUSH
65881: NOP4
65885: PPUSH
65886: NOP4
65890: PPUSH
65891: NOP4
65895: PUSH
65896: NOP4
65900: ARRAY
65901: PUSH
65902: NOP4
65906: DIFF
65907: PPUSH
65908: NOP4
65912: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65913: NOP4
65917: PPUSH
65918: NOP4
65922: PUSH
65923: LD_INT 1
65925: EQUAL
65926: IFFALSE 65942
// ComExitVehicle ( IsInUnit ( j ) ) ;
65928: NOP4
65932: PPUSH
65933: NOP4
65937: PPUSH
65938: NOP4
// if GetControl ( j ) = control_remote then
65942: NOP4
65946: PPUSH
65947: NOP4
65951: PUSH
65952: LD_INT 2
65954: EQUAL
65955: IFFALSE 65966
// ComUnlink ( j ) ;
65957: NOP4
65961: PPUSH
65962: NOP4
// fac := MC_GetBuildings ( i , b_factory ) ;
65966: NOP4
65970: PUSH
65971: NOP4
65975: PPUSH
65976: LD_INT 3
65978: PPUSH
65979: NOP4
65983: ST_TO_ADDR
// if fac then
65984: NOP4
65988: IFFALSE 66084
// begin for k in fac do
65990: NOP4
65994: PUSH
65995: NOP4
65999: PUSH
66000: FOR_IN
66001: IFFALSE 66082
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66003: NOP4
66007: PUSH
66008: NOP4
66012: PPUSH
66013: NOP4
66017: PPUSH
66018: NOP4
66022: PPUSH
66023: NOP4
66027: PPUSH
66028: NOP4
66032: PPUSH
66033: NOP4
66037: PPUSH
66038: NOP4
66042: PPUSH
66043: NOP4
66047: PPUSH
66048: NOP4
66052: PPUSH
66053: NOP4
66057: ST_TO_ADDR
// if components then
66058: NOP4
66062: IFFALSE 66080
// begin MC_InsertProduceList ( i , components ) ;
66064: NOP4
66068: PPUSH
66069: NOP4
66073: PPUSH
66074: NOP4
// break ;
66078: GO 66082
// end ; end ;
66080: GO 66000
66082: POP
66083: POP
// end ; continue ;
66084: GO 65629
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66086: NOP4
66090: PPUSH
66091: LD_INT 1
66093: PPUSH
66094: NOP4
66098: PUSH
66099: LD_INT 100
66101: LESS
66102: PUSH
66103: NOP4
66107: PPUSH
66108: NOP4
66112: NOT
66113: AND
66114: IFFALSE 66143
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66116: NOP4
66120: PPUSH
66121: NOP4
66125: PUSH
66126: LD_INT 2
66128: ARRAY
66129: PPUSH
66130: NOP4
66134: PUSH
66135: LD_INT 3
66137: ARRAY
66138: PPUSH
66139: NOP4
// break ;
66143: GO 66147
// end ;
66145: GO 65629
66147: POP
66148: POP
// end ; end ;
66149: GO 64345
66151: POP
66152: POP
// end ;
66153: LD_VAR 0 1
66157: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66158: LD_INT 0
66160: PPUSH
66161: PPUSH
66162: PPUSH
66163: PPUSH
// if not mc_bases then
66164: NOP4
66168: NOT
66169: IFFALSE 66173
// exit ;
66171: GO 66334
// for i = 1 to mc_bases do
66173: NOP4
66177: PUSH
66178: DOUBLE
66179: LD_INT 1
66181: DEC
66182: ST_TO_ADDR
66183: NOP4
66187: PUSH
66188: FOR_TO
66189: IFFALSE 66332
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66191: NOP4
66195: PUSH
66196: NOP4
66200: PUSH
66201: NOP4
66205: ARRAY
66206: PUSH
66207: NOP4
66211: PUSH
66212: NOP4
66216: ARRAY
66217: UNION
66218: PPUSH
66219: LD_INT 33
66221: PUSH
66222: LD_INT 2
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: PPUSH
66229: NOP4
66233: ST_TO_ADDR
// if tmp then
66234: NOP4
66238: IFFALSE 66330
// for j in tmp do
66240: NOP4
66244: PUSH
66245: NOP4
66249: PUSH
66250: FOR_IN
66251: IFFALSE 66328
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66253: NOP4
66257: PPUSH
66258: NOP4
66262: NOT
66263: PUSH
66264: NOP4
66268: PPUSH
66269: NOP4
66273: PUSH
66274: LD_INT 250
66276: GREATEREQUAL
66277: AND
66278: IFFALSE 66291
// Connect ( j ) else
66280: NOP4
66284: PPUSH
66285: NOP4
66289: GO 66326
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66291: NOP4
66295: PPUSH
66296: NOP4
66300: PUSH
66301: LD_INT 250
66303: LESS
66304: PUSH
66305: NOP4
66309: PPUSH
66310: NOP4
66314: AND
66315: IFFALSE 66326
// ComUnlink ( j ) ;
66317: NOP4
66321: PPUSH
66322: NOP4
66326: GO 66250
66328: POP
66329: POP
// end ;
66330: GO 66188
66332: POP
66333: POP
// end ;
66334: LD_VAR 0 1
66338: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66339: LD_INT 0
66341: PPUSH
66342: PPUSH
66343: PPUSH
66344: PPUSH
66345: PPUSH
// if not mc_bases then
66346: NOP4
66350: NOT
66351: IFFALSE 66355
// exit ;
66353: GO 66800
// for i = 1 to mc_bases do
66355: NOP4
66359: PUSH
66360: DOUBLE
66361: LD_INT 1
66363: DEC
66364: ST_TO_ADDR
66365: NOP4
66369: PUSH
66370: FOR_TO
66371: IFFALSE 66798
// begin if not mc_produce [ i ] then
66373: NOP4
66377: PUSH
66378: NOP4
66382: ARRAY
66383: NOT
66384: IFFALSE 66388
// continue ;
66386: GO 66370
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66388: NOP4
66392: PUSH
66393: NOP4
66397: PUSH
66398: NOP4
66402: ARRAY
66403: PPUSH
66404: LD_INT 30
66406: PUSH
66407: LD_INT 3
66409: PUSH
66410: EMPTY
66411: LIST
66412: LIST
66413: PPUSH
66414: NOP4
66418: ST_TO_ADDR
// if not fac then
66419: NOP4
66423: NOT
66424: IFFALSE 66428
// continue ;
66426: GO 66370
// for j in fac do
66428: NOP4
66432: PUSH
66433: NOP4
66437: PUSH
66438: FOR_IN
66439: IFFALSE 66794
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66441: NOP4
66445: PPUSH
66446: NOP4
66450: PUSH
66451: LD_INT 2
66453: NONEQUAL
66454: PUSH
66455: NOP4
66459: PPUSH
66460: LD_INT 15
66462: PPUSH
66463: NOP4
66467: PUSH
66468: LD_INT 4
66470: ARRAY
66471: OR
66472: IFFALSE 66476
// continue ;
66474: GO 66438
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66476: NOP4
66480: PPUSH
66481: NOP4
66485: PUSH
66486: NOP4
66490: ARRAY
66491: PUSH
66492: LD_INT 1
66494: ARRAY
66495: PUSH
66496: LD_INT 1
66498: ARRAY
66499: PPUSH
66500: NOP4
66504: PUSH
66505: NOP4
66509: ARRAY
66510: PUSH
66511: LD_INT 1
66513: ARRAY
66514: PUSH
66515: LD_INT 2
66517: ARRAY
66518: PPUSH
66519: NOP4
66523: PUSH
66524: NOP4
66528: ARRAY
66529: PUSH
66530: LD_INT 1
66532: ARRAY
66533: PUSH
66534: LD_INT 3
66536: ARRAY
66537: PPUSH
66538: NOP4
66542: PUSH
66543: NOP4
66547: ARRAY
66548: PUSH
66549: LD_INT 1
66551: ARRAY
66552: PUSH
66553: LD_INT 4
66555: ARRAY
66556: PPUSH
66557: NOP4
66561: PUSH
66562: NOP4
66566: PPUSH
66567: NOP4
66571: PUSH
66572: NOP4
66576: ARRAY
66577: PUSH
66578: LD_INT 1
66580: ARRAY
66581: PUSH
66582: LD_INT 1
66584: ARRAY
66585: PUSH
66586: NOP4
66590: PUSH
66591: NOP4
66595: ARRAY
66596: PUSH
66597: LD_INT 1
66599: ARRAY
66600: PUSH
66601: LD_INT 2
66603: ARRAY
66604: PUSH
66605: NOP4
66609: PUSH
66610: NOP4
66614: ARRAY
66615: PUSH
66616: LD_INT 1
66618: ARRAY
66619: PUSH
66620: LD_INT 3
66622: ARRAY
66623: PUSH
66624: NOP4
66628: PUSH
66629: NOP4
66633: ARRAY
66634: PUSH
66635: LD_INT 1
66637: ARRAY
66638: PUSH
66639: LD_INT 4
66641: ARRAY
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: PPUSH
66649: NOP4
66653: AND
66654: IFFALSE 66792
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66656: NOP4
66660: PPUSH
66661: NOP4
66665: PUSH
66666: NOP4
66670: ARRAY
66671: PUSH
66672: LD_INT 1
66674: ARRAY
66675: PUSH
66676: LD_INT 1
66678: ARRAY
66679: PPUSH
66680: NOP4
66684: PUSH
66685: NOP4
66689: ARRAY
66690: PUSH
66691: LD_INT 1
66693: ARRAY
66694: PUSH
66695: LD_INT 2
66697: ARRAY
66698: PPUSH
66699: NOP4
66703: PUSH
66704: NOP4
66708: ARRAY
66709: PUSH
66710: LD_INT 1
66712: ARRAY
66713: PUSH
66714: LD_INT 3
66716: ARRAY
66717: PPUSH
66718: NOP4
66722: PUSH
66723: NOP4
66727: ARRAY
66728: PUSH
66729: LD_INT 1
66731: ARRAY
66732: PUSH
66733: LD_INT 4
66735: ARRAY
66736: PPUSH
66737: NOP4
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66741: NOP4
66745: PUSH
66746: NOP4
66750: PUSH
66751: NOP4
66755: ARRAY
66756: PPUSH
66757: LD_INT 1
66759: PPUSH
66760: NOP4
66764: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66765: NOP4
66769: PUSH
66770: NOP4
66774: PPUSH
66775: NOP4
66779: PPUSH
66780: NOP4
66784: PPUSH
66785: NOP4
66789: ST_TO_ADDR
// break ;
66790: GO 66794
// end ; end ;
66792: GO 66438
66794: POP
66795: POP
// end ;
66796: GO 66370
66798: POP
66799: POP
// end ;
66800: LD_VAR 0 1
66804: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66805: LD_INT 0
66807: PPUSH
66808: PPUSH
66809: PPUSH
// if not mc_bases then
66810: NOP4
66814: NOT
66815: IFFALSE 66819
// exit ;
66817: GO 66908
// for i = 1 to mc_bases do
66819: NOP4
66823: PUSH
66824: DOUBLE
66825: LD_INT 1
66827: DEC
66828: ST_TO_ADDR
66829: NOP4
66833: PUSH
66834: FOR_TO
66835: IFFALSE 66906
// begin if mc_attack [ i ] then
66837: NOP4
66841: PUSH
66842: NOP4
66846: ARRAY
66847: IFFALSE 66904
// begin tmp := mc_attack [ i ] [ 1 ] ;
66849: NOP4
66853: PUSH
66854: NOP4
66858: PUSH
66859: NOP4
66863: ARRAY
66864: PUSH
66865: LD_INT 1
66867: ARRAY
66868: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66869: NOP4
66873: PUSH
66874: NOP4
66878: PPUSH
66879: NOP4
66883: PPUSH
66884: EMPTY
66885: PPUSH
66886: NOP4
66890: ST_TO_ADDR
// Attack ( tmp ) ;
66891: NOP4
66895: PPUSH
66896: NOP4
// exit ;
66900: POP
66901: POP
66902: GO 66908
// end ; end ;
66904: GO 66834
66906: POP
66907: POP
// end ;
66908: LD_VAR 0 1
66912: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66913: LD_INT 0
66915: PPUSH
66916: PPUSH
66917: PPUSH
66918: PPUSH
66919: PPUSH
66920: PPUSH
66921: PPUSH
// if not mc_bases then
66922: NOP4
66926: NOT
66927: IFFALSE 66931
// exit ;
66929: GO 67788
// for i = 1 to mc_bases do
66931: NOP4
66935: PUSH
66936: DOUBLE
66937: LD_INT 1
66939: DEC
66940: ST_TO_ADDR
66941: NOP4
66945: PUSH
66946: FOR_TO
66947: IFFALSE 67786
// begin if not mc_bases [ i ] then
66949: NOP4
66953: PUSH
66954: NOP4
66958: ARRAY
66959: NOT
66960: IFFALSE 66964
// continue ;
66962: GO 66946
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66964: NOP4
66968: PUSH
66969: NOP4
66973: PUSH
66974: NOP4
66978: ARRAY
66979: PUSH
66980: LD_INT 1
66982: ARRAY
66983: PPUSH
66984: NOP4
66988: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66989: NOP4
66993: PUSH
66994: NOP4
66998: PPUSH
66999: NOP4
67003: PPUSH
67004: NOP4
67008: PUSH
67009: NOP4
67013: ARRAY
67014: PUSH
67015: LD_INT 1
67017: ARRAY
67018: PPUSH
67019: NOP4
67023: PPUSH
67024: NOP4
67028: PUSH
67029: NOP4
67033: ARRAY
67034: PPUSH
67035: NOP4
67039: PPUSH
67040: NOP4
67044: ST_TO_ADDR
// if not mc_scan [ i ] then
67045: NOP4
67049: PUSH
67050: NOP4
67054: ARRAY
67055: NOT
67056: IFFALSE 67234
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67058: NOP4
67062: PUSH
67063: NOP4
67067: PPUSH
67068: NOP4
67072: PPUSH
67073: LD_INT 0
67075: PPUSH
67076: NOP4
67080: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67081: NOP4
67085: PUSH
67086: NOP4
67090: PUSH
67091: NOP4
67095: ARRAY
67096: PPUSH
67097: LD_INT 2
67099: PUSH
67100: LD_INT 25
67102: PUSH
67103: LD_INT 5
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 25
67112: PUSH
67113: LD_INT 8
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 25
67122: PUSH
67123: LD_INT 9
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: LIST
67134: LIST
67135: PPUSH
67136: NOP4
67140: ST_TO_ADDR
// if not tmp then
67141: NOP4
67145: NOT
67146: IFFALSE 67150
// continue ;
67148: GO 66946
// for j in tmp do
67150: NOP4
67154: PUSH
67155: NOP4
67159: PUSH
67160: FOR_IN
67161: IFFALSE 67232
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67163: NOP4
67167: PPUSH
67168: NOP4
67172: PPUSH
67173: NOP4
67177: PUSH
67178: LD_INT 5
67180: EQUAL
67181: PUSH
67182: NOP4
67186: PPUSH
67187: NOP4
67191: PUSH
67192: LD_INT 1
67194: EQUAL
67195: AND
67196: PUSH
67197: NOP4
67201: PPUSH
67202: NOP4
67206: NOT
67207: AND
67208: PUSH
67209: NOP4
67213: AND
67214: IFFALSE 67230
// ComChangeProfession ( j , class ) ;
67216: NOP4
67220: PPUSH
67221: NOP4
67225: PPUSH
67226: NOP4
67230: GO 67160
67232: POP
67233: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67234: NOP4
67238: PUSH
67239: NOP4
67243: ARRAY
67244: PUSH
67245: NOP4
67249: PUSH
67250: NOP4
67254: ARRAY
67255: NOT
67256: AND
67257: PUSH
67258: NOP4
67262: PUSH
67263: NOP4
67267: ARRAY
67268: NOT
67269: AND
67270: PUSH
67271: NOP4
67275: PUSH
67276: NOP4
67280: ARRAY
67281: PPUSH
67282: LD_INT 50
67284: PUSH
67285: EMPTY
67286: LIST
67287: PUSH
67288: LD_INT 2
67290: PUSH
67291: LD_INT 30
67293: PUSH
67294: LD_INT 32
67296: PUSH
67297: EMPTY
67298: LIST
67299: LIST
67300: PUSH
67301: LD_INT 30
67303: PUSH
67304: LD_INT 33
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 30
67313: PUSH
67314: LD_INT 4
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 30
67323: PUSH
67324: LD_INT 5
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: EMPTY
67332: LIST
67333: LIST
67334: LIST
67335: LIST
67336: LIST
67337: PUSH
67338: EMPTY
67339: LIST
67340: LIST
67341: PPUSH
67342: NOP4
67346: PUSH
67347: LD_INT 4
67349: LESS
67350: PUSH
67351: NOP4
67355: PUSH
67356: NOP4
67360: ARRAY
67361: PPUSH
67362: LD_INT 3
67364: PUSH
67365: LD_INT 24
67367: PUSH
67368: LD_INT 1000
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: PUSH
67379: LD_INT 2
67381: PUSH
67382: LD_INT 30
67384: PUSH
67385: LD_INT 0
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: PUSH
67392: LD_INT 30
67394: PUSH
67395: LD_INT 1
67397: PUSH
67398: EMPTY
67399: LIST
67400: LIST
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: LIST
67406: PUSH
67407: EMPTY
67408: LIST
67409: LIST
67410: PPUSH
67411: NOP4
67415: OR
67416: AND
67417: IFFALSE 67668
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67419: NOP4
67423: PUSH
67424: NOP4
67428: PPUSH
67429: NOP4
67433: PPUSH
67434: LD_INT 1
67436: PPUSH
67437: NOP4
67441: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67442: NOP4
67446: PUSH
67447: NOP4
67451: PUSH
67452: NOP4
67456: ARRAY
67457: PPUSH
67458: LD_INT 2
67460: PUSH
67461: LD_INT 25
67463: PUSH
67464: LD_INT 1
67466: PUSH
67467: EMPTY
67468: LIST
67469: LIST
67470: PUSH
67471: LD_INT 25
67473: PUSH
67474: LD_INT 5
67476: PUSH
67477: EMPTY
67478: LIST
67479: LIST
67480: PUSH
67481: LD_INT 25
67483: PUSH
67484: LD_INT 8
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: PUSH
67491: LD_INT 25
67493: PUSH
67494: LD_INT 9
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: LIST
67505: LIST
67506: LIST
67507: PPUSH
67508: NOP4
67512: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67513: NOP4
67517: PUSH
67518: NOP4
67522: PUSH
67523: NOP4
67527: PPUSH
67528: LD_INT 18
67530: PPUSH
67531: NOP4
67535: DIFF
67536: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67537: NOP4
67541: NOT
67542: PUSH
67543: NOP4
67547: PUSH
67548: NOP4
67552: ARRAY
67553: PPUSH
67554: LD_INT 2
67556: PUSH
67557: LD_INT 30
67559: PUSH
67560: LD_INT 4
67562: PUSH
67563: EMPTY
67564: LIST
67565: LIST
67566: PUSH
67567: LD_INT 30
67569: PUSH
67570: LD_INT 5
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: LIST
67581: PPUSH
67582: NOP4
67586: NOT
67587: AND
67588: IFFALSE 67650
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67590: NOP4
67594: PUSH
67595: NOP4
67599: PUSH
67600: NOP4
67604: ARRAY
67605: PPUSH
67606: LD_INT 2
67608: PUSH
67609: LD_INT 25
67611: PUSH
67612: LD_INT 2
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: LD_INT 25
67621: PUSH
67622: LD_INT 3
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: LD_INT 25
67631: PUSH
67632: LD_INT 4
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: PUSH
67639: EMPTY
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: PPUSH
67645: NOP4
67649: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67650: NOP4
67654: PPUSH
67655: NOP4
67659: PPUSH
67660: NOP4
// exit ;
67664: POP
67665: POP
67666: GO 67788
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67668: NOP4
67672: PUSH
67673: NOP4
67677: ARRAY
67678: PUSH
67679: NOP4
67683: PUSH
67684: NOP4
67688: ARRAY
67689: NOT
67690: AND
67691: PUSH
67692: NOP4
67696: PUSH
67697: NOP4
67701: ARRAY
67702: AND
67703: IFFALSE 67784
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67705: NOP4
67709: PUSH
67710: NOP4
67714: PPUSH
67715: NOP4
67719: PPUSH
67720: LD_INT 1
67722: PPUSH
67723: NOP4
67727: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67728: NOP4
67732: PUSH
67733: NOP4
67737: PUSH
67738: NOP4
67742: ARRAY
67743: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67744: NOP4
67748: PUSH
67749: NOP4
67753: PPUSH
67754: NOP4
67758: PPUSH
67759: EMPTY
67760: PPUSH
67761: NOP4
67765: ST_TO_ADDR
// Defend ( i , tmp ) ;
67766: NOP4
67770: PPUSH
67771: NOP4
67775: PPUSH
67776: NOP4
// exit ;
67780: POP
67781: POP
67782: GO 67788
// end ; end ;
67784: GO 66946
67786: POP
67787: POP
// end ;
67788: LD_VAR 0 1
67792: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67793: LD_INT 0
67795: PPUSH
67796: PPUSH
67797: PPUSH
67798: PPUSH
67799: PPUSH
67800: PPUSH
67801: PPUSH
67802: PPUSH
67803: PPUSH
67804: PPUSH
67805: PPUSH
// if not mc_bases then
67806: NOP4
67810: NOT
67811: IFFALSE 67815
// exit ;
67813: GO 68902
// for i = 1 to mc_bases do
67815: NOP4
67819: PUSH
67820: DOUBLE
67821: LD_INT 1
67823: DEC
67824: ST_TO_ADDR
67825: NOP4
67829: PUSH
67830: FOR_TO
67831: IFFALSE 68900
// begin tmp := mc_lab [ i ] ;
67833: NOP4
67837: PUSH
67838: NOP4
67842: PUSH
67843: NOP4
67847: ARRAY
67848: ST_TO_ADDR
// if not tmp then
67849: NOP4
67853: NOT
67854: IFFALSE 67858
// continue ;
67856: GO 67830
// idle_lab := 0 ;
67858: NOP4
67862: PUSH
67863: LD_INT 0
67865: ST_TO_ADDR
// for j in tmp do
67866: NOP4
67870: PUSH
67871: NOP4
67875: PUSH
67876: FOR_IN
67877: IFFALSE 68896
// begin researching := false ;
67879: NOP4
67883: PUSH
67884: LD_INT 0
67886: ST_TO_ADDR
// side := GetSide ( j ) ;
67887: NOP4
67891: PUSH
67892: NOP4
67896: PPUSH
67897: NOP4
67901: ST_TO_ADDR
// if not mc_tech [ side ] then
67902: NOP4
67906: PUSH
67907: NOP4
67911: ARRAY
67912: NOT
67913: IFFALSE 67917
// continue ;
67915: GO 67876
// if BuildingStatus ( j ) = bs_idle then
67917: NOP4
67921: PPUSH
67922: NOP4
67926: PUSH
67927: LD_INT 2
67929: EQUAL
67930: IFFALSE 68118
// begin if idle_lab and UnitsInside ( j ) < 6 then
67932: NOP4
67936: PUSH
67937: NOP4
67941: PPUSH
67942: NOP4
67946: PUSH
67947: LD_INT 6
67949: LESS
67950: AND
67951: IFFALSE 68022
// begin tmp2 := UnitsInside ( idle_lab ) ;
67953: NOP4
67957: PUSH
67958: NOP4
67962: PPUSH
67963: NOP4
67967: ST_TO_ADDR
// if tmp2 then
67968: NOP4
67972: IFFALSE 68014
// for x in tmp2 do
67974: NOP4
67978: PUSH
67979: NOP4
67983: PUSH
67984: FOR_IN
67985: IFFALSE 68012
// begin ComExitBuilding ( x ) ;
67987: NOP4
67991: PPUSH
67992: NOP4
// AddComEnterUnit ( x , j ) ;
67996: NOP4
68000: PPUSH
68001: NOP4
68005: PPUSH
68006: NOP4
// end ;
68010: GO 67984
68012: POP
68013: POP
// idle_lab := 0 ;
68014: NOP4
68018: PUSH
68019: LD_INT 0
68021: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68022: NOP4
68026: PUSH
68027: NOP4
68031: PUSH
68032: NOP4
68036: ARRAY
68037: PUSH
68038: FOR_IN
68039: IFFALSE 68099
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68041: NOP4
68045: PPUSH
68046: NOP4
68050: PPUSH
68051: NOP4
68055: PUSH
68056: NOP4
68060: PPUSH
68061: NOP4
68065: PPUSH
68066: NOP4
68070: AND
68071: IFFALSE 68097
// begin researching := true ;
68073: NOP4
68077: PUSH
68078: LD_INT 1
68080: ST_TO_ADDR
// ComResearch ( j , t ) ;
68081: NOP4
68085: PPUSH
68086: NOP4
68090: PPUSH
68091: NOP4
// break ;
68095: GO 68099
// end ;
68097: GO 68038
68099: POP
68100: POP
// if not researching then
68101: NOP4
68105: NOT
68106: IFFALSE 68118
// idle_lab := j ;
68108: NOP4
68112: PUSH
68113: NOP4
68117: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68118: NOP4
68122: PPUSH
68123: NOP4
68127: PUSH
68128: LD_INT 10
68130: EQUAL
68131: IFFALSE 68719
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68133: NOP4
68137: PUSH
68138: NOP4
68142: ARRAY
68143: NOT
68144: PUSH
68145: NOP4
68149: PUSH
68150: NOP4
68154: ARRAY
68155: NOT
68156: AND
68157: PUSH
68158: NOP4
68162: PUSH
68163: NOP4
68167: ARRAY
68168: PUSH
68169: LD_INT 1
68171: GREATER
68172: AND
68173: IFFALSE 68304
// begin ComCancel ( j ) ;
68175: NOP4
68179: PPUSH
68180: NOP4
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68184: NOP4
68188: PUSH
68189: NOP4
68193: PPUSH
68194: NOP4
68198: PPUSH
68199: NOP4
68203: PUSH
68204: NOP4
68208: ARRAY
68209: PPUSH
68210: NOP4
68214: PUSH
68215: NOP4
68219: ARRAY
68220: PUSH
68221: LD_INT 1
68223: MINUS
68224: PPUSH
68225: NOP4
68229: PUSH
68230: NOP4
68234: ARRAY
68235: PPUSH
68236: LD_INT 0
68238: PPUSH
68239: NOP4
68243: PPUSH
68244: NOP4
68248: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68249: NOP4
68253: PUSH
68254: NOP4
68258: PPUSH
68259: NOP4
68263: PPUSH
68264: NOP4
68268: PUSH
68269: NOP4
68273: ARRAY
68274: PPUSH
68275: NOP4
68279: PUSH
68280: NOP4
68284: ARRAY
68285: PPUSH
68286: LD_INT 1
68288: PPUSH
68289: LD_INT 0
68291: PPUSH
68292: NOP4
68296: PPUSH
68297: NOP4
68301: ST_TO_ADDR
// continue ;
68302: GO 67876
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68304: NOP4
68308: PUSH
68309: NOP4
68313: ARRAY
68314: PUSH
68315: NOP4
68319: PUSH
68320: NOP4
68324: ARRAY
68325: NOT
68326: AND
68327: IFFALSE 68454
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68329: NOP4
68333: PUSH
68334: NOP4
68338: PPUSH
68339: NOP4
68343: PUSH
68344: NOP4
68348: PUSH
68349: NOP4
68353: ARRAY
68354: PUSH
68355: LD_INT 1
68357: PLUS
68358: PUSH
68359: EMPTY
68360: LIST
68361: LIST
68362: PPUSH
68363: NOP4
68367: PUSH
68368: NOP4
68372: ARRAY
68373: PUSH
68374: LD_INT 1
68376: ARRAY
68377: PPUSH
68378: NOP4
68382: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68383: NOP4
68387: PUSH
68388: NOP4
68392: ARRAY
68393: PUSH
68394: LD_INT 1
68396: ARRAY
68397: PPUSH
68398: LD_INT 112
68400: PPUSH
68401: NOP4
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68405: NOP4
68409: PUSH
68410: NOP4
68414: PUSH
68415: NOP4
68419: ARRAY
68420: PPUSH
68421: LD_INT 1
68423: PPUSH
68424: NOP4
68428: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68429: NOP4
68433: PUSH
68434: NOP4
68438: PPUSH
68439: NOP4
68443: PPUSH
68444: NOP4
68448: PPUSH
68449: NOP4
68453: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68454: NOP4
68458: PUSH
68459: NOP4
68463: ARRAY
68464: PUSH
68465: NOP4
68469: PUSH
68470: NOP4
68474: ARRAY
68475: AND
68476: PUSH
68477: NOP4
68481: PUSH
68482: NOP4
68486: ARRAY
68487: PUSH
68488: LD_INT 1
68490: ARRAY
68491: PPUSH
68492: NOP4
68496: NOT
68497: AND
68498: PUSH
68499: NOP4
68503: PPUSH
68504: NOP4
68508: PUSH
68509: LD_INT 6
68511: EQUAL
68512: AND
68513: IFFALSE 68569
// begin tmp2 := UnitsInside ( j ) ;
68515: NOP4
68519: PUSH
68520: NOP4
68524: PPUSH
68525: NOP4
68529: ST_TO_ADDR
// if tmp2 = 6 then
68530: NOP4
68534: PUSH
68535: LD_INT 6
68537: EQUAL
68538: IFFALSE 68569
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68540: NOP4
68544: PUSH
68545: LD_INT 1
68547: ARRAY
68548: PPUSH
68549: LD_INT 112
68551: PPUSH
68552: NOP4
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68556: NOP4
68560: PUSH
68561: LD_INT 1
68563: ARRAY
68564: PPUSH
68565: NOP4
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68569: NOP4
68573: PUSH
68574: NOP4
68578: ARRAY
68579: PUSH
68580: NOP4
68584: PUSH
68585: NOP4
68589: ARRAY
68590: PUSH
68591: LD_INT 1
68593: ARRAY
68594: PPUSH
68595: NOP4
68599: NOT
68600: AND
68601: PUSH
68602: NOP4
68606: PUSH
68607: NOP4
68611: ARRAY
68612: PUSH
68613: LD_INT 1
68615: ARRAY
68616: PPUSH
68617: NOP4
68621: NOT
68622: AND
68623: IFFALSE 68649
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68625: NOP4
68629: PUSH
68630: NOP4
68634: ARRAY
68635: PUSH
68636: LD_INT 1
68638: ARRAY
68639: PPUSH
68640: NOP4
68644: PPUSH
68645: NOP4
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68649: NOP4
68653: PUSH
68654: NOP4
68658: ARRAY
68659: PUSH
68660: LD_INT 1
68662: ARRAY
68663: PPUSH
68664: NOP4
68668: PUSH
68669: NOP4
68673: PUSH
68674: NOP4
68678: ARRAY
68679: PUSH
68680: LD_INT 1
68682: ARRAY
68683: PPUSH
68684: NOP4
68688: PPUSH
68689: NOP4
68693: PUSH
68694: LD_INT 3
68696: NONEQUAL
68697: AND
68698: IFFALSE 68719
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68700: NOP4
68704: PUSH
68705: NOP4
68709: ARRAY
68710: PUSH
68711: LD_INT 1
68713: ARRAY
68714: PPUSH
68715: NOP4
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68719: NOP4
68723: PPUSH
68724: NOP4
68728: PUSH
68729: LD_INT 6
68731: EQUAL
68732: PUSH
68733: NOP4
68737: PUSH
68738: LD_INT 1
68740: GREATER
68741: AND
68742: IFFALSE 68894
// begin sci := [ ] ;
68744: NOP4
68748: PUSH
68749: EMPTY
68750: ST_TO_ADDR
// for x in ( tmp diff j ) do
68751: NOP4
68755: PUSH
68756: NOP4
68760: PUSH
68761: NOP4
68765: DIFF
68766: PUSH
68767: FOR_IN
68768: IFFALSE 68820
// begin if sci = 6 then
68770: NOP4
68774: PUSH
68775: LD_INT 6
68777: EQUAL
68778: IFFALSE 68782
// break ;
68780: GO 68820
// if BuildingStatus ( x ) = bs_idle then
68782: NOP4
68786: PPUSH
68787: NOP4
68791: PUSH
68792: LD_INT 2
68794: EQUAL
68795: IFFALSE 68818
// sci := sci ^ UnitsInside ( x ) ;
68797: NOP4
68801: PUSH
68802: NOP4
68806: PUSH
68807: NOP4
68811: PPUSH
68812: NOP4
68816: ADD
68817: ST_TO_ADDR
// end ;
68818: GO 68767
68820: POP
68821: POP
// if not sci then
68822: NOP4
68826: NOT
68827: IFFALSE 68831
// continue ;
68829: GO 67876
// for x in sci do
68831: NOP4
68835: PUSH
68836: NOP4
68840: PUSH
68841: FOR_IN
68842: IFFALSE 68892
// if IsInUnit ( x ) and not HasTask ( x ) then
68844: NOP4
68848: PPUSH
68849: NOP4
68853: PUSH
68854: NOP4
68858: PPUSH
68859: NOP4
68863: NOT
68864: AND
68865: IFFALSE 68890
// begin ComExitBuilding ( x ) ;
68867: NOP4
68871: PPUSH
68872: NOP4
// AddComEnterUnit ( x , j ) ;
68876: NOP4
68880: PPUSH
68881: NOP4
68885: PPUSH
68886: NOP4
// end ;
68890: GO 68841
68892: POP
68893: POP
// end ; end ;
68894: GO 67876
68896: POP
68897: POP
// end ;
68898: GO 67830
68900: POP
68901: POP
// end ;
68902: LD_VAR 0 1
68906: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68907: LD_INT 0
68909: PPUSH
68910: PPUSH
// if not mc_bases then
68911: NOP4
68915: NOT
68916: IFFALSE 68920
// exit ;
68918: GO 69001
// for i = 1 to mc_bases do
68920: NOP4
68924: PUSH
68925: DOUBLE
68926: LD_INT 1
68928: DEC
68929: ST_TO_ADDR
68930: NOP4
68934: PUSH
68935: FOR_TO
68936: IFFALSE 68999
// if mc_mines [ i ] and mc_miners [ i ] then
68938: NOP4
68942: PUSH
68943: NOP4
68947: ARRAY
68948: PUSH
68949: NOP4
68953: PUSH
68954: NOP4
68958: ARRAY
68959: AND
68960: IFFALSE 68997
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68962: NOP4
68966: PUSH
68967: NOP4
68971: ARRAY
68972: PUSH
68973: LD_INT 1
68975: ARRAY
68976: PPUSH
68977: NOP4
68981: PPUSH
68982: NOP4
68986: PUSH
68987: NOP4
68991: ARRAY
68992: PPUSH
68993: NOP4
68997: GO 68935
68999: POP
69000: POP
// end ;
69001: LD_VAR 0 1
69005: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69006: LD_INT 0
69008: PPUSH
69009: PPUSH
69010: PPUSH
69011: PPUSH
69012: PPUSH
69013: PPUSH
69014: PPUSH
69015: PPUSH
// if not mc_bases or not mc_parking then
69016: NOP4
69020: NOT
69021: PUSH
69022: NOP4
69026: NOT
69027: OR
69028: IFFALSE 69032
// exit ;
69030: GO 69742
// for i = 1 to mc_bases do
69032: NOP4
69036: PUSH
69037: DOUBLE
69038: LD_INT 1
69040: DEC
69041: ST_TO_ADDR
69042: NOP4
69046: PUSH
69047: FOR_TO
69048: IFFALSE 69740
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69050: NOP4
69054: PUSH
69055: NOP4
69059: ARRAY
69060: NOT
69061: PUSH
69062: NOP4
69066: PUSH
69067: NOP4
69071: ARRAY
69072: NOT
69073: OR
69074: IFFALSE 69078
// continue ;
69076: GO 69047
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69078: NOP4
69082: PUSH
69083: NOP4
69087: PUSH
69088: NOP4
69092: ARRAY
69093: PUSH
69094: LD_INT 1
69096: ARRAY
69097: PPUSH
69098: NOP4
69102: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69103: NOP4
69107: PUSH
69108: NOP4
69112: PUSH
69113: NOP4
69117: ARRAY
69118: PPUSH
69119: LD_INT 30
69121: PUSH
69122: LD_INT 3
69124: PUSH
69125: EMPTY
69126: LIST
69127: LIST
69128: PPUSH
69129: NOP4
69133: ST_TO_ADDR
// if not fac then
69134: NOP4
69138: NOT
69139: IFFALSE 69190
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69141: NOP4
69145: PUSH
69146: NOP4
69150: PUSH
69151: NOP4
69155: ARRAY
69156: PPUSH
69157: LD_INT 2
69159: PUSH
69160: LD_INT 30
69162: PUSH
69163: LD_INT 0
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: PUSH
69170: LD_INT 30
69172: PUSH
69173: LD_INT 1
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: LIST
69184: PPUSH
69185: NOP4
69189: ST_TO_ADDR
// if not fac then
69190: NOP4
69194: NOT
69195: IFFALSE 69199
// continue ;
69197: GO 69047
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69199: NOP4
69203: PUSH
69204: NOP4
69208: PUSH
69209: NOP4
69213: ARRAY
69214: PPUSH
69215: LD_INT 22
69217: PUSH
69218: NOP4
69222: PUSH
69223: EMPTY
69224: LIST
69225: LIST
69226: PUSH
69227: LD_INT 21
69229: PUSH
69230: LD_INT 2
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 3
69239: PUSH
69240: LD_INT 24
69242: PUSH
69243: LD_INT 1000
69245: PUSH
69246: EMPTY
69247: LIST
69248: LIST
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: LIST
69258: PPUSH
69259: NOP4
69263: ST_TO_ADDR
// for j in fac do
69264: NOP4
69268: PUSH
69269: NOP4
69273: PUSH
69274: FOR_IN
69275: IFFALSE 69356
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69277: NOP4
69281: PUSH
69282: NOP4
69286: PUSH
69287: LD_INT 22
69289: PUSH
69290: NOP4
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 91
69301: PUSH
69302: NOP4
69306: PUSH
69307: LD_INT 15
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: LIST
69314: PUSH
69315: LD_INT 21
69317: PUSH
69318: LD_INT 2
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 3
69327: PUSH
69328: LD_INT 24
69330: PUSH
69331: LD_INT 1000
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: EMPTY
69339: LIST
69340: LIST
69341: PUSH
69342: EMPTY
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: PPUSH
69348: NOP4
69352: UNION
69353: ST_TO_ADDR
69354: GO 69274
69356: POP
69357: POP
// if not vehs then
69358: NOP4
69362: NOT
69363: IFFALSE 69389
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69365: NOP4
69369: PUSH
69370: NOP4
69374: PPUSH
69375: NOP4
69379: PPUSH
69380: EMPTY
69381: PPUSH
69382: NOP4
69386: ST_TO_ADDR
// continue ;
69387: GO 69047
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69389: NOP4
69393: PUSH
69394: NOP4
69398: PUSH
69399: NOP4
69403: ARRAY
69404: PPUSH
69405: LD_INT 30
69407: PUSH
69408: LD_INT 3
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PPUSH
69415: NOP4
69419: ST_TO_ADDR
// if tmp then
69420: NOP4
69424: IFFALSE 69527
// begin for j in tmp do
69426: NOP4
69430: PUSH
69431: NOP4
69435: PUSH
69436: FOR_IN
69437: IFFALSE 69525
// for k in UnitsInside ( j ) do
69439: NOP4
69443: PUSH
69444: NOP4
69448: PPUSH
69449: NOP4
69453: PUSH
69454: FOR_IN
69455: IFFALSE 69521
// if k then
69457: NOP4
69461: IFFALSE 69519
// if not k in mc_repair_vehicle [ i ] then
69463: NOP4
69467: PUSH
69468: NOP4
69472: PUSH
69473: NOP4
69477: ARRAY
69478: IN
69479: NOT
69480: IFFALSE 69519
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69482: NOP4
69486: PUSH
69487: NOP4
69491: PPUSH
69492: NOP4
69496: PPUSH
69497: NOP4
69501: PUSH
69502: NOP4
69506: ARRAY
69507: PUSH
69508: NOP4
69512: UNION
69513: PPUSH
69514: NOP4
69518: ST_TO_ADDR
69519: GO 69454
69521: POP
69522: POP
69523: GO 69436
69525: POP
69526: POP
// end ; if not mc_repair_vehicle [ i ] then
69527: NOP4
69531: PUSH
69532: NOP4
69536: ARRAY
69537: NOT
69538: IFFALSE 69542
// continue ;
69540: GO 69047
// for j in mc_repair_vehicle [ i ] do
69542: NOP4
69546: PUSH
69547: NOP4
69551: PUSH
69552: NOP4
69556: ARRAY
69557: PUSH
69558: FOR_IN
69559: IFFALSE 69736
// begin if GetClass ( j ) <> 3 then
69561: NOP4
69565: PPUSH
69566: NOP4
69570: PUSH
69571: LD_INT 3
69573: NONEQUAL
69574: IFFALSE 69615
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69576: NOP4
69580: PUSH
69581: NOP4
69585: PPUSH
69586: NOP4
69590: PPUSH
69591: NOP4
69595: PUSH
69596: NOP4
69600: ARRAY
69601: PUSH
69602: NOP4
69606: DIFF
69607: PPUSH
69608: NOP4
69612: ST_TO_ADDR
// continue ;
69613: GO 69558
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69615: NOP4
69619: PPUSH
69620: NOP4
69624: NOT
69625: PUSH
69626: NOP4
69630: PUSH
69631: NOP4
69635: PUSH
69636: NOP4
69640: ARRAY
69641: PUSH
69642: LD_INT 1
69644: ARRAY
69645: IN
69646: NOT
69647: AND
69648: PUSH
69649: NOP4
69653: PUSH
69654: NOP4
69658: PUSH
69659: NOP4
69663: ARRAY
69664: PUSH
69665: LD_INT 2
69667: ARRAY
69668: IN
69669: NOT
69670: AND
69671: IFFALSE 69734
// begin if IsInUnit ( j ) then
69673: NOP4
69677: PPUSH
69678: NOP4
69682: IFFALSE 69695
// ComExitBuilding ( j ) else
69684: NOP4
69688: PPUSH
69689: NOP4
69693: GO 69734
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69695: NOP4
69699: PPUSH
69700: NOP4
69704: PUSH
69705: LD_INT 1
69707: ARRAY
69708: PPUSH
69709: NOP4
69713: NOT
69714: IFFALSE 69734
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
69716: NOP4
69720: PPUSH
69721: NOP4
69725: PUSH
69726: LD_INT 1
69728: ARRAY
69729: PPUSH
69730: NOP4
// end ; end ;
69734: GO 69558
69736: POP
69737: POP
// end ;
69738: GO 69047
69740: POP
69741: POP
// end ;
69742: LD_VAR 0 1
69746: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69747: LD_INT 0
69749: PPUSH
69750: PPUSH
69751: PPUSH
69752: PPUSH
69753: PPUSH
69754: PPUSH
69755: PPUSH
69756: PPUSH
69757: PPUSH
69758: PPUSH
69759: PPUSH
// if not mc_bases then
69760: NOP4
69764: NOT
69765: IFFALSE 69769
// exit ;
69767: GO 70571
// for i = 1 to mc_bases do
69769: NOP4
69773: PUSH
69774: DOUBLE
69775: LD_INT 1
69777: DEC
69778: ST_TO_ADDR
69779: NOP4
69783: PUSH
69784: FOR_TO
69785: IFFALSE 70569
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69787: NOP4
69791: PUSH
69792: NOP4
69796: ARRAY
69797: NOT
69798: PUSH
69799: NOP4
69803: PUSH
69804: NOP4
69808: ARRAY
69809: PUSH
69810: LD_INT 1
69812: ARRAY
69813: OR
69814: PUSH
69815: NOP4
69819: PUSH
69820: NOP4
69824: ARRAY
69825: PUSH
69826: LD_INT 2
69828: ARRAY
69829: OR
69830: PUSH
69831: NOP4
69835: PUSH
69836: NOP4
69840: ARRAY
69841: PPUSH
69842: LD_INT 1
69844: PPUSH
69845: NOP4
69849: NOT
69850: OR
69851: PUSH
69852: NOP4
69856: PUSH
69857: NOP4
69861: ARRAY
69862: OR
69863: IFFALSE 69867
// continue ;
69865: GO 69784
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69867: NOP4
69871: PUSH
69872: NOP4
69876: PUSH
69877: NOP4
69881: ARRAY
69882: PPUSH
69883: LD_INT 25
69885: PUSH
69886: LD_INT 4
69888: PUSH
69889: EMPTY
69890: LIST
69891: LIST
69892: PUSH
69893: LD_INT 50
69895: PUSH
69896: EMPTY
69897: LIST
69898: PUSH
69899: LD_INT 3
69901: PUSH
69902: LD_INT 60
69904: PUSH
69905: EMPTY
69906: LIST
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: EMPTY
69913: LIST
69914: LIST
69915: LIST
69916: PPUSH
69917: NOP4
69921: PUSH
69922: NOP4
69926: PUSH
69927: NOP4
69931: ARRAY
69932: DIFF
69933: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69934: NOP4
69938: PUSH
69939: NOP4
69943: PUSH
69944: NOP4
69948: ARRAY
69949: PPUSH
69950: LD_INT 2
69952: PUSH
69953: LD_INT 30
69955: PUSH
69956: LD_INT 0
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: LD_INT 30
69965: PUSH
69966: LD_INT 1
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: LIST
69977: PPUSH
69978: NOP4
69982: ST_TO_ADDR
// if not tmp or not dep then
69983: NOP4
69987: NOT
69988: PUSH
69989: NOP4
69993: NOT
69994: OR
69995: IFFALSE 69999
// continue ;
69997: GO 69784
// side := GetSide ( tmp [ 1 ] ) ;
69999: NOP4
70003: PUSH
70004: NOP4
70008: PUSH
70009: LD_INT 1
70011: ARRAY
70012: PPUSH
70013: NOP4
70017: ST_TO_ADDR
// dep := dep [ 1 ] ;
70018: NOP4
70022: PUSH
70023: NOP4
70027: PUSH
70028: LD_INT 1
70030: ARRAY
70031: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70032: NOP4
70036: PUSH
70037: NOP4
70041: PUSH
70042: NOP4
70046: ARRAY
70047: PPUSH
70048: LD_INT 22
70050: PUSH
70051: LD_INT 0
70053: PUSH
70054: EMPTY
70055: LIST
70056: LIST
70057: PUSH
70058: LD_INT 25
70060: PUSH
70061: LD_INT 12
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PPUSH
70072: NOP4
70076: PUSH
70077: LD_INT 22
70079: PUSH
70080: LD_INT 0
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 25
70089: PUSH
70090: LD_INT 12
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PUSH
70097: LD_INT 91
70099: PUSH
70100: NOP4
70104: PUSH
70105: LD_INT 20
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: LIST
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: LIST
70117: PPUSH
70118: NOP4
70122: UNION
70123: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70124: NOP4
70128: PUSH
70129: NOP4
70133: PUSH
70134: NOP4
70138: ARRAY
70139: PPUSH
70140: LD_INT 81
70142: PUSH
70143: NOP4
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PPUSH
70152: NOP4
70156: ST_TO_ADDR
// if not apes or danger_at_area then
70157: NOP4
70161: NOT
70162: PUSH
70163: NOP4
70167: OR
70168: IFFALSE 70218
// begin if mc_taming [ i ] then
70170: NOP4
70174: PUSH
70175: NOP4
70179: ARRAY
70180: IFFALSE 70216
// begin MC_Reset ( i , 121 ) ;
70182: NOP4
70186: PPUSH
70187: LD_INT 121
70189: PPUSH
70190: NOP4
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70194: NOP4
70198: PUSH
70199: NOP4
70203: PPUSH
70204: NOP4
70208: PPUSH
70209: EMPTY
70210: PPUSH
70211: NOP4
70215: ST_TO_ADDR
// end ; continue ;
70216: GO 69784
// end ; for j in tmp do
70218: NOP4
70222: PUSH
70223: NOP4
70227: PUSH
70228: FOR_IN
70229: IFFALSE 70565
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70231: NOP4
70235: PUSH
70236: NOP4
70240: PUSH
70241: NOP4
70245: ARRAY
70246: IN
70247: NOT
70248: PUSH
70249: NOP4
70253: PUSH
70254: NOP4
70258: ARRAY
70259: PUSH
70260: LD_INT 3
70262: LESS
70263: AND
70264: IFFALSE 70322
// begin SetTag ( j , 121 ) ;
70266: NOP4
70270: PPUSH
70271: LD_INT 121
70273: PPUSH
70274: NOP4
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70278: NOP4
70282: PUSH
70283: NOP4
70287: PPUSH
70288: NOP4
70292: PUSH
70293: NOP4
70297: PUSH
70298: NOP4
70302: ARRAY
70303: PUSH
70304: LD_INT 1
70306: PLUS
70307: PUSH
70308: EMPTY
70309: LIST
70310: LIST
70311: PPUSH
70312: NOP4
70316: PPUSH
70317: NOP4
70321: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70322: NOP4
70326: PUSH
70327: NOP4
70331: PUSH
70332: NOP4
70336: ARRAY
70337: IN
70338: IFFALSE 70563
// begin if GetClass ( j ) <> 4 then
70340: NOP4
70344: PPUSH
70345: NOP4
70349: PUSH
70350: LD_INT 4
70352: NONEQUAL
70353: IFFALSE 70406
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70355: NOP4
70359: PUSH
70360: NOP4
70364: PPUSH
70365: NOP4
70369: PPUSH
70370: NOP4
70374: PUSH
70375: NOP4
70379: ARRAY
70380: PUSH
70381: NOP4
70385: DIFF
70386: PPUSH
70387: NOP4
70391: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70392: NOP4
70396: PPUSH
70397: LD_INT 0
70399: PPUSH
70400: NOP4
// continue ;
70404: GO 70228
// end ; if IsInUnit ( j ) then
70406: NOP4
70410: PPUSH
70411: NOP4
70415: IFFALSE 70426
// ComExitBuilding ( j ) ;
70417: NOP4
70421: PPUSH
70422: NOP4
// ape := NearestUnitToUnit ( apes , j ) ;
70426: NOP4
70430: PUSH
70431: NOP4
70435: PPUSH
70436: NOP4
70440: PPUSH
70441: NOP4
70445: ST_TO_ADDR
// if not ape then
70446: NOP4
70450: NOT
70451: IFFALSE 70455
// break ;
70453: GO 70565
// x := GetX ( ape ) ;
70455: NOP4
70459: PUSH
70460: NOP4
70464: PPUSH
70465: NOP4
70469: ST_TO_ADDR
// y := GetY ( ape ) ;
70470: NOP4
70474: PUSH
70475: NOP4
70479: PPUSH
70480: NOP4
70484: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70485: NOP4
70489: PPUSH
70490: NOP4
70494: PPUSH
70495: NOP4
70499: NOT
70500: PUSH
70501: NOP4
70505: PPUSH
70506: NOP4
70510: PPUSH
70511: NOP4
70515: PPUSH
70516: LD_INT 20
70518: PPUSH
70519: NOP4
70523: PUSH
70524: LD_INT 4
70526: ARRAY
70527: OR
70528: IFFALSE 70532
// break ;
70530: GO 70565
// if not HasTask ( j ) then
70532: NOP4
70536: PPUSH
70537: NOP4
70541: NOT
70542: IFFALSE 70563
// ComTameXY ( j , x , y ) ;
70544: NOP4
70548: PPUSH
70549: NOP4
70553: PPUSH
70554: NOP4
70558: PPUSH
70559: NOP4
// end ; end ;
70563: GO 70228
70565: POP
70566: POP
// end ;
70567: GO 69784
70569: POP
70570: POP
// end ;
70571: LD_VAR 0 1
70575: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70576: LD_INT 0
70578: PPUSH
70579: PPUSH
70580: PPUSH
70581: PPUSH
70582: PPUSH
70583: PPUSH
70584: PPUSH
70585: PPUSH
// if not mc_bases then
70586: NOP4
70590: NOT
70591: IFFALSE 70595
// exit ;
70593: GO 71221
// for i = 1 to mc_bases do
70595: NOP4
70599: PUSH
70600: DOUBLE
70601: LD_INT 1
70603: DEC
70604: ST_TO_ADDR
70605: NOP4
70609: PUSH
70610: FOR_TO
70611: IFFALSE 71219
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70613: NOP4
70617: PUSH
70618: NOP4
70622: ARRAY
70623: NOT
70624: PUSH
70625: NOP4
70629: PUSH
70630: NOP4
70634: ARRAY
70635: PPUSH
70636: LD_INT 25
70638: PUSH
70639: LD_INT 12
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: PPUSH
70646: NOP4
70650: NOT
70651: OR
70652: IFFALSE 70656
// continue ;
70654: GO 70610
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70656: NOP4
70660: PUSH
70661: NOP4
70665: PUSH
70666: NOP4
70670: ARRAY
70671: PUSH
70672: LD_INT 1
70674: ARRAY
70675: PPUSH
70676: NOP4
70680: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70681: NOP4
70685: PPUSH
70686: LD_INT 2
70688: PPUSH
70689: NOP4
70693: IFFALSE 70946
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70695: NOP4
70699: PUSH
70700: NOP4
70704: PUSH
70705: NOP4
70709: ARRAY
70710: PPUSH
70711: LD_INT 25
70713: PUSH
70714: LD_INT 16
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PPUSH
70721: NOP4
70725: ST_TO_ADDR
// if tmp < 6 then
70726: NOP4
70730: PUSH
70731: LD_INT 6
70733: LESS
70734: IFFALSE 70946
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70736: NOP4
70740: PUSH
70741: NOP4
70745: PUSH
70746: NOP4
70750: ARRAY
70751: PPUSH
70752: LD_INT 2
70754: PUSH
70755: LD_INT 30
70757: PUSH
70758: LD_INT 0
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 30
70767: PUSH
70768: LD_INT 1
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: LIST
70779: PPUSH
70780: NOP4
70784: ST_TO_ADDR
// if depot then
70785: NOP4
70789: IFFALSE 70946
// begin selected := 0 ;
70791: NOP4
70795: PUSH
70796: LD_INT 0
70798: ST_TO_ADDR
// for j in depot do
70799: NOP4
70803: PUSH
70804: NOP4
70808: PUSH
70809: FOR_IN
70810: IFFALSE 70841
// begin if UnitsInside ( j ) < 6 then
70812: NOP4
70816: PPUSH
70817: NOP4
70821: PUSH
70822: LD_INT 6
70824: LESS
70825: IFFALSE 70839
// begin selected := j ;
70827: NOP4
70831: PUSH
70832: NOP4
70836: ST_TO_ADDR
// break ;
70837: GO 70841
// end ; end ;
70839: GO 70809
70841: POP
70842: POP
// if selected then
70843: NOP4
70847: IFFALSE 70946
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70849: NOP4
70853: PUSH
70854: NOP4
70858: PUSH
70859: NOP4
70863: ARRAY
70864: PPUSH
70865: LD_INT 25
70867: PUSH
70868: LD_INT 12
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PPUSH
70875: NOP4
70879: PUSH
70880: FOR_IN
70881: IFFALSE 70944
// if not HasTask ( j ) then
70883: NOP4
70887: PPUSH
70888: NOP4
70892: NOT
70893: IFFALSE 70942
// begin if not IsInUnit ( j ) then
70895: NOP4
70899: PPUSH
70900: NOP4
70904: NOT
70905: IFFALSE 70921
// ComEnterUnit ( j , selected ) ;
70907: NOP4
70911: PPUSH
70912: NOP4
70916: PPUSH
70917: NOP4
// AddComChangeProfession ( j , 16 ) ;
70921: NOP4
70925: PPUSH
70926: LD_INT 16
70928: PPUSH
70929: NOP4
// AddComExitBuilding ( j ) ;
70933: NOP4
70937: PPUSH
70938: NOP4
// end ;
70942: GO 70880
70944: POP
70945: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70946: NOP4
70950: PPUSH
70951: LD_INT 11
70953: PPUSH
70954: NOP4
70958: IFFALSE 71217
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70960: NOP4
70964: PUSH
70965: NOP4
70969: PUSH
70970: NOP4
70974: ARRAY
70975: PPUSH
70976: LD_INT 25
70978: PUSH
70979: LD_INT 16
70981: PUSH
70982: EMPTY
70983: LIST
70984: LIST
70985: PPUSH
70986: NOP4
70990: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
70991: NOP4
70995: PUSH
70996: LD_INT 6
70998: GREATEREQUAL
70999: PUSH
71000: NOP4
71004: PPUSH
71005: LD_INT 2
71007: PPUSH
71008: NOP4
71012: NOT
71013: OR
71014: IFFALSE 71217
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71016: NOP4
71020: PUSH
71021: NOP4
71025: PUSH
71026: NOP4
71030: ARRAY
71031: PPUSH
71032: LD_INT 2
71034: PUSH
71035: LD_INT 30
71037: PUSH
71038: LD_INT 4
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 30
71047: PUSH
71048: LD_INT 5
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: LIST
71059: PPUSH
71060: NOP4
71064: ST_TO_ADDR
// if barracks then
71065: NOP4
71069: IFFALSE 71217
// begin selected := 0 ;
71071: NOP4
71075: PUSH
71076: LD_INT 0
71078: ST_TO_ADDR
// for j in barracks do
71079: NOP4
71083: PUSH
71084: NOP4
71088: PUSH
71089: FOR_IN
71090: IFFALSE 71121
// begin if UnitsInside ( j ) < 6 then
71092: NOP4
71096: PPUSH
71097: NOP4
71101: PUSH
71102: LD_INT 6
71104: LESS
71105: IFFALSE 71119
// begin selected := j ;
71107: NOP4
71111: PUSH
71112: NOP4
71116: ST_TO_ADDR
// break ;
71117: GO 71121
// end ; end ;
71119: GO 71089
71121: POP
71122: POP
// if selected then
71123: NOP4
71127: IFFALSE 71217
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71129: NOP4
71133: PUSH
71134: NOP4
71138: PUSH
71139: NOP4
71143: ARRAY
71144: PPUSH
71145: LD_INT 25
71147: PUSH
71148: LD_INT 12
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PPUSH
71155: NOP4
71159: PUSH
71160: FOR_IN
71161: IFFALSE 71215
// if not IsInUnit ( j ) and not HasTask ( j ) then
71163: NOP4
71167: PPUSH
71168: NOP4
71172: NOT
71173: PUSH
71174: NOP4
71178: PPUSH
71179: NOP4
71183: NOT
71184: AND
71185: IFFALSE 71213
// begin ComEnterUnit ( j , selected ) ;
71187: NOP4
71191: PPUSH
71192: NOP4
71196: PPUSH
71197: NOP4
// AddComChangeProfession ( j , 15 ) ;
71201: NOP4
71205: PPUSH
71206: LD_INT 15
71208: PPUSH
71209: NOP4
// end ;
71213: GO 71160
71215: POP
71216: POP
// end ; end ; end ; end ; end ;
71217: GO 70610
71219: POP
71220: POP
// end ;
71221: LD_VAR 0 1
71225: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71226: LD_INT 0
71228: PPUSH
71229: PPUSH
71230: PPUSH
71231: PPUSH
// if not mc_bases then
71232: NOP4
71236: NOT
71237: IFFALSE 71241
// exit ;
71239: GO 71419
// for i = 1 to mc_bases do
71241: NOP4
71245: PUSH
71246: DOUBLE
71247: LD_INT 1
71249: DEC
71250: ST_TO_ADDR
71251: NOP4
71255: PUSH
71256: FOR_TO
71257: IFFALSE 71417
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71259: NOP4
71263: PUSH
71264: NOP4
71268: PUSH
71269: NOP4
71273: ARRAY
71274: PPUSH
71275: LD_INT 25
71277: PUSH
71278: LD_INT 9
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PPUSH
71285: NOP4
71289: ST_TO_ADDR
// if not tmp then
71290: NOP4
71294: NOT
71295: IFFALSE 71299
// continue ;
71297: GO 71256
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71299: NOP4
71303: PUSH
71304: NOP4
71308: ARRAY
71309: PPUSH
71310: LD_INT 29
71312: PPUSH
71313: NOP4
71317: NOT
71318: PUSH
71319: NOP4
71323: PUSH
71324: NOP4
71328: ARRAY
71329: PPUSH
71330: LD_INT 28
71332: PPUSH
71333: NOP4
71337: NOT
71338: AND
71339: IFFALSE 71343
// continue ;
71341: GO 71256
// for j in tmp do
71343: NOP4
71347: PUSH
71348: NOP4
71352: PUSH
71353: FOR_IN
71354: IFFALSE 71413
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71356: NOP4
71360: PUSH
71361: NOP4
71365: PUSH
71366: NOP4
71370: ARRAY
71371: PUSH
71372: LD_INT 1
71374: ARRAY
71375: IN
71376: NOT
71377: PUSH
71378: NOP4
71382: PUSH
71383: NOP4
71387: PUSH
71388: NOP4
71392: ARRAY
71393: PUSH
71394: LD_INT 2
71396: ARRAY
71397: IN
71398: NOT
71399: AND
71400: IFFALSE 71411
// ComSpaceTimeShoot ( j ) ;
71402: NOP4
71406: PPUSH
71407: NOP4
71411: GO 71353
71413: POP
71414: POP
// end ;
71415: GO 71256
71417: POP
71418: POP
// end ;
71419: LD_VAR 0 1
71423: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71424: LD_INT 0
71426: PPUSH
71427: PPUSH
71428: PPUSH
71429: PPUSH
71430: PPUSH
71431: PPUSH
71432: PPUSH
71433: PPUSH
71434: PPUSH
// if not mc_bases then
71435: NOP4
71439: NOT
71440: IFFALSE 71444
// exit ;
71442: GO 72066
// for i = 1 to mc_bases do
71444: NOP4
71448: PUSH
71449: DOUBLE
71450: LD_INT 1
71452: DEC
71453: ST_TO_ADDR
71454: NOP4
71458: PUSH
71459: FOR_TO
71460: IFFALSE 72064
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71462: NOP4
71466: PUSH
71467: NOP4
71471: ARRAY
71472: NOT
71473: PUSH
71474: LD_INT 38
71476: PPUSH
71477: NOP4
71481: PUSH
71482: NOP4
71486: ARRAY
71487: PPUSH
71488: NOP4
71492: PUSH
71493: LD_INT 2
71495: NONEQUAL
71496: OR
71497: IFFALSE 71501
// continue ;
71499: GO 71459
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71501: NOP4
71505: PUSH
71506: NOP4
71510: PUSH
71511: NOP4
71515: ARRAY
71516: PPUSH
71517: LD_INT 30
71519: PUSH
71520: LD_INT 34
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PPUSH
71527: NOP4
71531: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71532: NOP4
71536: PUSH
71537: NOP4
71541: PUSH
71542: NOP4
71546: ARRAY
71547: PPUSH
71548: LD_INT 25
71550: PUSH
71551: LD_INT 4
71553: PUSH
71554: EMPTY
71555: LIST
71556: LIST
71557: PPUSH
71558: NOP4
71562: PPUSH
71563: LD_INT 0
71565: PPUSH
71566: NOP4
71570: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71571: NOP4
71575: NOT
71576: PUSH
71577: NOP4
71581: NOT
71582: OR
71583: PUSH
71584: NOP4
71588: PUSH
71589: NOP4
71593: ARRAY
71594: PPUSH
71595: LD_INT 124
71597: PPUSH
71598: NOP4
71602: OR
71603: IFFALSE 71607
// continue ;
71605: GO 71459
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71607: NOP4
71611: PUSH
71612: NOP4
71616: ARRAY
71617: PUSH
71618: NOP4
71622: PUSH
71623: NOP4
71627: ARRAY
71628: LESS
71629: PUSH
71630: NOP4
71634: PUSH
71635: NOP4
71639: ARRAY
71640: PUSH
71641: NOP4
71645: LESS
71646: AND
71647: IFFALSE 72062
// begin tmp := sci [ 1 ] ;
71649: NOP4
71653: PUSH
71654: NOP4
71658: PUSH
71659: LD_INT 1
71661: ARRAY
71662: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71663: NOP4
71667: PPUSH
71668: LD_INT 124
71670: PPUSH
71671: NOP4
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71675: NOP4
71679: PUSH
71680: DOUBLE
71681: NOP4
71685: PUSH
71686: NOP4
71690: ARRAY
71691: INC
71692: ST_TO_ADDR
71693: NOP4
71697: PUSH
71698: NOP4
71702: ARRAY
71703: PUSH
71704: FOR_DOWNTO
71705: IFFALSE 72048
// begin if IsInUnit ( tmp ) then
71707: NOP4
71711: PPUSH
71712: NOP4
71716: IFFALSE 71727
// ComExitBuilding ( tmp ) ;
71718: NOP4
71722: PPUSH
71723: NOP4
// repeat wait ( 0 0$1 ) ;
71727: LD_INT 35
71729: PPUSH
71730: NOP4
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71734: NOP4
71738: PPUSH
71739: NOP4
71743: NOT
71744: PUSH
71745: NOP4
71749: PPUSH
71750: NOP4
71754: NOT
71755: AND
71756: IFFALSE 71727
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71758: NOP4
71762: PUSH
71763: NOP4
71767: PPUSH
71768: NOP4
71772: PUSH
71773: NOP4
71777: PPUSH
71778: NOP4
71782: PUSH
71783: EMPTY
71784: LIST
71785: LIST
71786: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71787: LD_INT 35
71789: PPUSH
71790: NOP4
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71794: NOP4
71798: PUSH
71799: NOP4
71803: PUSH
71804: NOP4
71808: ARRAY
71809: PUSH
71810: NOP4
71814: ARRAY
71815: PUSH
71816: LD_INT 1
71818: ARRAY
71819: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71820: NOP4
71824: PUSH
71825: NOP4
71829: PUSH
71830: NOP4
71834: ARRAY
71835: PUSH
71836: NOP4
71840: ARRAY
71841: PUSH
71842: LD_INT 2
71844: ARRAY
71845: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71846: NOP4
71850: PPUSH
71851: LD_INT 10
71853: PPUSH
71854: NOP4
71858: PUSH
71859: LD_INT 4
71861: ARRAY
71862: IFFALSE 71900
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71864: NOP4
71868: PPUSH
71869: NOP4
71873: PUSH
71874: LD_INT 1
71876: ARRAY
71877: PPUSH
71878: NOP4
71882: PUSH
71883: LD_INT 2
71885: ARRAY
71886: PPUSH
71887: NOP4
// wait ( 0 0$10 ) ;
71891: LD_INT 350
71893: PPUSH
71894: NOP4
// end else
71898: GO 71926
// begin ComMoveXY ( tmp , x , y ) ;
71900: NOP4
71904: PPUSH
71905: NOP4
71909: PPUSH
71910: NOP4
71914: PPUSH
71915: NOP4
// wait ( 0 0$3 ) ;
71919: LD_INT 105
71921: PPUSH
71922: NOP4
// end ; until IsAt ( tmp , x , y ) ;
71926: NOP4
71930: PPUSH
71931: NOP4
71935: PPUSH
71936: NOP4
71940: PPUSH
71941: NOP4
71945: IFFALSE 71787
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71947: NOP4
71951: PPUSH
71952: NOP4
71956: PPUSH
71957: NOP4
71961: PPUSH
71962: NOP4
71966: PUSH
71967: NOP4
71971: ARRAY
71972: PPUSH
71973: NOP4
// repeat wait ( 0 0$1 ) ;
71977: LD_INT 35
71979: PPUSH
71980: NOP4
// until not HasTask ( tmp ) ;
71984: NOP4
71988: PPUSH
71989: NOP4
71993: NOT
71994: IFFALSE 71977
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
71996: NOP4
72000: PUSH
72001: NOP4
72005: PPUSH
72006: NOP4
72010: PUSH
72011: NOP4
72015: PUSH
72016: NOP4
72020: ARRAY
72021: PUSH
72022: LD_INT 1
72024: PLUS
72025: PUSH
72026: EMPTY
72027: LIST
72028: LIST
72029: PPUSH
72030: NOP4
72034: PUSH
72035: NOP4
72039: ARRAY
72040: PPUSH
72041: NOP4
72045: ST_TO_ADDR
// end ;
72046: GO 71704
72048: POP
72049: POP
// MC_Reset ( i , 124 ) ;
72050: NOP4
72054: PPUSH
72055: LD_INT 124
72057: PPUSH
72058: NOP4
// end ; end ;
72062: GO 71459
72064: POP
72065: POP
// end ;
72066: LD_VAR 0 1
72070: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72071: LD_INT 0
72073: PPUSH
72074: PPUSH
72075: PPUSH
// if not mc_bases then
72076: NOP4
72080: NOT
72081: IFFALSE 72085
// exit ;
72083: GO 72691
// for i = 1 to mc_bases do
72085: NOP4
72089: PUSH
72090: DOUBLE
72091: LD_INT 1
72093: DEC
72094: ST_TO_ADDR
72095: NOP4
72099: PUSH
72100: FOR_TO
72101: IFFALSE 72689
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72103: NOP4
72107: PUSH
72108: NOP4
72112: PUSH
72113: NOP4
72117: ARRAY
72118: PPUSH
72119: LD_INT 25
72121: PUSH
72122: LD_INT 4
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PPUSH
72129: NOP4
72133: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72134: NOP4
72138: NOT
72139: PUSH
72140: NOP4
72144: PUSH
72145: NOP4
72149: ARRAY
72150: NOT
72151: OR
72152: PUSH
72153: NOP4
72157: PUSH
72158: NOP4
72162: ARRAY
72163: PPUSH
72164: LD_INT 2
72166: PUSH
72167: LD_INT 30
72169: PUSH
72170: LD_INT 0
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 30
72179: PUSH
72180: LD_INT 1
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: LIST
72191: PPUSH
72192: NOP4
72196: NOT
72197: OR
72198: IFFALSE 72248
// begin if mc_deposits_finder [ i ] then
72200: NOP4
72204: PUSH
72205: NOP4
72209: ARRAY
72210: IFFALSE 72246
// begin MC_Reset ( i , 125 ) ;
72212: NOP4
72216: PPUSH
72217: LD_INT 125
72219: PPUSH
72220: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72224: NOP4
72228: PUSH
72229: NOP4
72233: PPUSH
72234: NOP4
72238: PPUSH
72239: EMPTY
72240: PPUSH
72241: NOP4
72245: ST_TO_ADDR
// end ; continue ;
72246: GO 72100
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72248: NOP4
72252: PUSH
72253: NOP4
72257: ARRAY
72258: PUSH
72259: LD_INT 1
72261: ARRAY
72262: PUSH
72263: LD_INT 3
72265: ARRAY
72266: PUSH
72267: LD_INT 1
72269: EQUAL
72270: PUSH
72271: LD_INT 20
72273: PPUSH
72274: NOP4
72278: PUSH
72279: NOP4
72283: ARRAY
72284: PPUSH
72285: NOP4
72289: PUSH
72290: LD_INT 2
72292: NONEQUAL
72293: AND
72294: IFFALSE 72344
// begin if mc_deposits_finder [ i ] then
72296: NOP4
72300: PUSH
72301: NOP4
72305: ARRAY
72306: IFFALSE 72342
// begin MC_Reset ( i , 125 ) ;
72308: NOP4
72312: PPUSH
72313: LD_INT 125
72315: PPUSH
72316: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72320: NOP4
72324: PUSH
72325: NOP4
72329: PPUSH
72330: NOP4
72334: PPUSH
72335: EMPTY
72336: PPUSH
72337: NOP4
72341: ST_TO_ADDR
// end ; continue ;
72342: GO 72100
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72344: NOP4
72348: PUSH
72349: NOP4
72353: ARRAY
72354: PUSH
72355: LD_INT 1
72357: ARRAY
72358: PUSH
72359: LD_INT 1
72361: ARRAY
72362: PPUSH
72363: NOP4
72367: PUSH
72368: NOP4
72372: ARRAY
72373: PUSH
72374: LD_INT 1
72376: ARRAY
72377: PUSH
72378: LD_INT 2
72380: ARRAY
72381: PPUSH
72382: NOP4
72386: PUSH
72387: NOP4
72391: ARRAY
72392: PPUSH
72393: NOP4
72397: IFFALSE 72440
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72399: NOP4
72403: PUSH
72404: NOP4
72408: PPUSH
72409: NOP4
72413: PPUSH
72414: NOP4
72418: PUSH
72419: NOP4
72423: ARRAY
72424: PPUSH
72425: LD_INT 1
72427: PPUSH
72428: NOP4
72432: PPUSH
72433: NOP4
72437: ST_TO_ADDR
72438: GO 72687
// begin if not mc_deposits_finder [ i ] then
72440: NOP4
72444: PUSH
72445: NOP4
72449: ARRAY
72450: NOT
72451: IFFALSE 72503
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72453: NOP4
72457: PUSH
72458: NOP4
72462: PPUSH
72463: NOP4
72467: PPUSH
72468: NOP4
72472: PUSH
72473: LD_INT 1
72475: ARRAY
72476: PUSH
72477: EMPTY
72478: LIST
72479: PPUSH
72480: NOP4
72484: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72485: NOP4
72489: PUSH
72490: LD_INT 1
72492: ARRAY
72493: PPUSH
72494: LD_INT 125
72496: PPUSH
72497: NOP4
// end else
72501: GO 72687
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72503: NOP4
72507: PUSH
72508: NOP4
72512: ARRAY
72513: PUSH
72514: LD_INT 1
72516: ARRAY
72517: PPUSH
72518: NOP4
72522: IFFALSE 72545
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72524: NOP4
72528: PUSH
72529: NOP4
72533: ARRAY
72534: PUSH
72535: LD_INT 1
72537: ARRAY
72538: PPUSH
72539: NOP4
72543: GO 72687
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72545: NOP4
72549: PUSH
72550: NOP4
72554: ARRAY
72555: PUSH
72556: LD_INT 1
72558: ARRAY
72559: PPUSH
72560: NOP4
72564: NOT
72565: PUSH
72566: NOP4
72570: PUSH
72571: NOP4
72575: ARRAY
72576: PUSH
72577: LD_INT 1
72579: ARRAY
72580: PPUSH
72581: NOP4
72585: PUSH
72586: NOP4
72590: ARRAY
72591: PUSH
72592: LD_INT 1
72594: ARRAY
72595: PUSH
72596: LD_INT 1
72598: ARRAY
72599: PPUSH
72600: NOP4
72604: PUSH
72605: NOP4
72609: ARRAY
72610: PUSH
72611: LD_INT 1
72613: ARRAY
72614: PUSH
72615: LD_INT 2
72617: ARRAY
72618: PPUSH
72619: NOP4
72623: PUSH
72624: LD_INT 6
72626: GREATER
72627: AND
72628: IFFALSE 72687
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72630: NOP4
72634: PUSH
72635: NOP4
72639: ARRAY
72640: PUSH
72641: LD_INT 1
72643: ARRAY
72644: PPUSH
72645: NOP4
72649: PUSH
72650: NOP4
72654: ARRAY
72655: PUSH
72656: LD_INT 1
72658: ARRAY
72659: PUSH
72660: LD_INT 1
72662: ARRAY
72663: PPUSH
72664: NOP4
72668: PUSH
72669: NOP4
72673: ARRAY
72674: PUSH
72675: LD_INT 1
72677: ARRAY
72678: PUSH
72679: LD_INT 2
72681: ARRAY
72682: PPUSH
72683: NOP4
// end ; end ; end ;
72687: GO 72100
72689: POP
72690: POP
// end ;
72691: LD_VAR 0 1
72695: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72696: LD_INT 0
72698: PPUSH
72699: PPUSH
72700: PPUSH
72701: PPUSH
72702: PPUSH
72703: PPUSH
72704: PPUSH
72705: PPUSH
72706: PPUSH
72707: PPUSH
72708: PPUSH
// if not mc_bases then
72709: NOP4
72713: NOT
72714: IFFALSE 72718
// exit ;
72716: GO 73658
// for i = 1 to mc_bases do
72718: NOP4
72722: PUSH
72723: DOUBLE
72724: LD_INT 1
72726: DEC
72727: ST_TO_ADDR
72728: NOP4
72732: PUSH
72733: FOR_TO
72734: IFFALSE 73656
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72736: NOP4
72740: PUSH
72741: NOP4
72745: ARRAY
72746: NOT
72747: PUSH
72748: NOP4
72752: PUSH
72753: NOP4
72757: ARRAY
72758: OR
72759: IFFALSE 72763
// continue ;
72761: GO 72733
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72763: NOP4
72767: PUSH
72768: NOP4
72772: PUSH
72773: NOP4
72777: ARRAY
72778: PUSH
72779: LD_INT 1
72781: ARRAY
72782: PPUSH
72783: NOP4
72787: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72788: NOP4
72792: PUSH
72793: LD_INT 3
72795: EQUAL
72796: PUSH
72797: NOP4
72801: PUSH
72802: NOP4
72806: ARRAY
72807: PUSH
72808: NOP4
72812: PUSH
72813: NOP4
72817: ARRAY
72818: UNION
72819: PPUSH
72820: LD_INT 33
72822: PUSH
72823: LD_INT 2
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PPUSH
72830: NOP4
72834: NOT
72835: OR
72836: IFFALSE 72840
// continue ;
72838: GO 72733
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72840: NOP4
72844: PUSH
72845: NOP4
72849: PUSH
72850: NOP4
72854: ARRAY
72855: PPUSH
72856: LD_INT 30
72858: PUSH
72859: LD_INT 36
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PPUSH
72866: NOP4
72870: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72871: NOP4
72875: PUSH
72876: NOP4
72880: PUSH
72881: NOP4
72885: ARRAY
72886: PPUSH
72887: LD_INT 34
72889: PUSH
72890: LD_INT 31
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PPUSH
72897: NOP4
72901: ST_TO_ADDR
// if not cts and not mcts then
72902: NOP4
72906: NOT
72907: PUSH
72908: NOP4
72912: NOT
72913: AND
72914: IFFALSE 72918
// continue ;
72916: GO 72733
// x := cts ;
72918: NOP4
72922: PUSH
72923: NOP4
72927: ST_TO_ADDR
// if not x then
72928: NOP4
72932: NOT
72933: IFFALSE 72945
// x := mcts ;
72935: NOP4
72939: PUSH
72940: NOP4
72944: ST_TO_ADDR
// if not x then
72945: NOP4
72949: NOT
72950: IFFALSE 72954
// continue ;
72952: GO 72733
// if mc_remote_driver [ i ] then
72954: NOP4
72958: PUSH
72959: NOP4
72963: ARRAY
72964: IFFALSE 73351
// for j in mc_remote_driver [ i ] do
72966: NOP4
72970: PUSH
72971: NOP4
72975: PUSH
72976: NOP4
72980: ARRAY
72981: PUSH
72982: FOR_IN
72983: IFFALSE 73349
// begin if GetClass ( j ) <> 3 then
72985: NOP4
72989: PPUSH
72990: NOP4
72994: PUSH
72995: LD_INT 3
72997: NONEQUAL
72998: IFFALSE 73051
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73000: NOP4
73004: PUSH
73005: NOP4
73009: PPUSH
73010: NOP4
73014: PPUSH
73015: NOP4
73019: PUSH
73020: NOP4
73024: ARRAY
73025: PUSH
73026: NOP4
73030: DIFF
73031: PPUSH
73032: NOP4
73036: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73037: NOP4
73041: PPUSH
73042: LD_INT 0
73044: PPUSH
73045: NOP4
// continue ;
73049: GO 72982
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73051: NOP4
73055: PUSH
73056: NOP4
73060: ARRAY
73061: PPUSH
73062: LD_INT 34
73064: PUSH
73065: LD_INT 31
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: LD_INT 58
73074: PUSH
73075: EMPTY
73076: LIST
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PPUSH
73082: NOP4
73086: PUSH
73087: NOP4
73091: PPUSH
73092: NOP4
73096: NOT
73097: AND
73098: IFFALSE 73169
// begin if IsInUnit ( j ) then
73100: NOP4
73104: PPUSH
73105: NOP4
73109: IFFALSE 73120
// ComExitBuilding ( j ) ;
73111: NOP4
73115: PPUSH
73116: NOP4
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73120: NOP4
73124: PPUSH
73125: NOP4
73129: PUSH
73130: NOP4
73134: ARRAY
73135: PPUSH
73136: LD_INT 34
73138: PUSH
73139: LD_INT 31
73141: PUSH
73142: EMPTY
73143: LIST
73144: LIST
73145: PUSH
73146: LD_INT 58
73148: PUSH
73149: EMPTY
73150: LIST
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PPUSH
73156: NOP4
73160: PUSH
73161: LD_INT 1
73163: ARRAY
73164: PPUSH
73165: NOP4
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73169: NOP4
73173: PPUSH
73174: NOP4
73178: NOT
73179: PUSH
73180: NOP4
73184: PPUSH
73185: NOP4
73189: PPUSH
73190: NOP4
73194: PUSH
73195: LD_INT 36
73197: NONEQUAL
73198: PUSH
73199: NOP4
73203: PPUSH
73204: NOP4
73208: NOT
73209: AND
73210: OR
73211: IFFALSE 73347
// begin if IsInUnit ( j ) then
73213: NOP4
73217: PPUSH
73218: NOP4
73222: IFFALSE 73233
// ComExitBuilding ( j ) ;
73224: NOP4
73228: PPUSH
73229: NOP4
// ct := 0 ;
73233: NOP4
73237: PUSH
73238: LD_INT 0
73240: ST_TO_ADDR
// for k in x do
73241: NOP4
73245: PUSH
73246: NOP4
73250: PUSH
73251: FOR_IN
73252: IFFALSE 73325
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73254: NOP4
73258: PPUSH
73259: NOP4
73263: PUSH
73264: LD_INT 31
73266: EQUAL
73267: PUSH
73268: NOP4
73272: PPUSH
73273: NOP4
73277: NOT
73278: AND
73279: PUSH
73280: NOP4
73284: PPUSH
73285: NOP4
73289: PUSH
73290: LD_INT 36
73292: EQUAL
73293: PUSH
73294: NOP4
73298: PPUSH
73299: NOP4
73303: PUSH
73304: LD_INT 3
73306: LESS
73307: AND
73308: OR
73309: IFFALSE 73323
// begin ct := k ;
73311: NOP4
73315: PUSH
73316: NOP4
73320: ST_TO_ADDR
// break ;
73321: GO 73325
// end ;
73323: GO 73251
73325: POP
73326: POP
// if ct then
73327: NOP4
73331: IFFALSE 73347
// ComEnterUnit ( j , ct ) ;
73333: NOP4
73337: PPUSH
73338: NOP4
73342: PPUSH
73343: NOP4
// end ; end ;
73347: GO 72982
73349: POP
73350: POP
// places := 0 ;
73351: NOP4
73355: PUSH
73356: LD_INT 0
73358: ST_TO_ADDR
// for j = 1 to x do
73359: NOP4
73363: PUSH
73364: DOUBLE
73365: LD_INT 1
73367: DEC
73368: ST_TO_ADDR
73369: NOP4
73373: PUSH
73374: FOR_TO
73375: IFFALSE 73451
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73377: NOP4
73381: PUSH
73382: NOP4
73386: ARRAY
73387: PPUSH
73388: NOP4
73392: PUSH
73393: LD_INT 31
73395: EQUAL
73396: IFFALSE 73414
// places := places + 1 else
73398: NOP4
73402: PUSH
73403: NOP4
73407: PUSH
73408: LD_INT 1
73410: PLUS
73411: ST_TO_ADDR
73412: GO 73449
// if GetBType ( x [ j ] ) = b_control_tower then
73414: NOP4
73418: PUSH
73419: NOP4
73423: ARRAY
73424: PPUSH
73425: NOP4
73429: PUSH
73430: LD_INT 36
73432: EQUAL
73433: IFFALSE 73449
// places := places + 3 ;
73435: NOP4
73439: PUSH
73440: NOP4
73444: PUSH
73445: LD_INT 3
73447: PLUS
73448: ST_TO_ADDR
73449: GO 73374
73451: POP
73452: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73453: NOP4
73457: PUSH
73458: LD_INT 0
73460: EQUAL
73461: PUSH
73462: NOP4
73466: PUSH
73467: NOP4
73471: PUSH
73472: NOP4
73476: ARRAY
73477: LESSEQUAL
73478: OR
73479: IFFALSE 73483
// continue ;
73481: GO 72733
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73483: NOP4
73487: PUSH
73488: NOP4
73492: PUSH
73493: NOP4
73497: ARRAY
73498: PPUSH
73499: LD_INT 25
73501: PUSH
73502: LD_INT 3
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: PPUSH
73509: NOP4
73513: PUSH
73514: NOP4
73518: PUSH
73519: NOP4
73523: ARRAY
73524: DIFF
73525: PPUSH
73526: LD_INT 3
73528: PPUSH
73529: NOP4
73533: ST_TO_ADDR
// for j in tmp do
73534: NOP4
73538: PUSH
73539: NOP4
73543: PUSH
73544: FOR_IN
73545: IFFALSE 73580
// if GetTag ( j ) > 0 then
73547: NOP4
73551: PPUSH
73552: NOP4
73556: PUSH
73557: LD_INT 0
73559: GREATER
73560: IFFALSE 73578
// tmp := tmp diff j ;
73562: NOP4
73566: PUSH
73567: NOP4
73571: PUSH
73572: NOP4
73576: DIFF
73577: ST_TO_ADDR
73578: GO 73544
73580: POP
73581: POP
// if not tmp then
73582: NOP4
73586: NOT
73587: IFFALSE 73591
// continue ;
73589: GO 72733
// if places then
73591: NOP4
73595: IFFALSE 73654
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73597: NOP4
73601: PUSH
73602: NOP4
73606: PPUSH
73607: NOP4
73611: PPUSH
73612: NOP4
73616: PUSH
73617: NOP4
73621: ARRAY
73622: PUSH
73623: NOP4
73627: PUSH
73628: LD_INT 1
73630: ARRAY
73631: UNION
73632: PPUSH
73633: NOP4
73637: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73638: NOP4
73642: PUSH
73643: LD_INT 1
73645: ARRAY
73646: PPUSH
73647: LD_INT 126
73649: PPUSH
73650: NOP4
// end ; end ;
73654: GO 72733
73656: POP
73657: POP
// end ;
73658: LD_VAR 0 1
73662: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73663: LD_INT 0
73665: PPUSH
73666: PPUSH
73667: PPUSH
73668: PPUSH
73669: PPUSH
73670: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73671: NOP4
73675: NOT
73676: PUSH
73677: NOP4
73681: NOT
73682: OR
73683: PUSH
73684: NOP4
73688: NOT
73689: OR
73690: PUSH
73691: NOP4
73695: PUSH
73696: LD_INT 1
73698: PUSH
73699: LD_INT 2
73701: PUSH
73702: LD_INT 3
73704: PUSH
73705: LD_INT 4
73707: PUSH
73708: LD_INT 5
73710: PUSH
73711: LD_INT 8
73713: PUSH
73714: LD_INT 9
73716: PUSH
73717: LD_INT 15
73719: PUSH
73720: LD_INT 16
73722: PUSH
73723: EMPTY
73724: LIST
73725: LIST
73726: LIST
73727: LIST
73728: LIST
73729: LIST
73730: LIST
73731: LIST
73732: LIST
73733: IN
73734: NOT
73735: OR
73736: IFFALSE 73740
// exit ;
73738: GO 74640
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73740: NOP4
73744: PUSH
73745: NOP4
73749: PPUSH
73750: LD_INT 21
73752: PUSH
73753: LD_INT 3
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: LD_INT 24
73762: PUSH
73763: LD_INT 250
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PPUSH
73774: NOP4
73778: ST_TO_ADDR
// case class of 1 , 15 :
73779: NOP4
73783: PUSH
73784: LD_INT 1
73786: DOUBLE
73787: EQUAL
73788: IFTRUE 73798
73790: LD_INT 15
73792: DOUBLE
73793: EQUAL
73794: IFTRUE 73798
73796: GO 73883
73798: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73799: NOP4
73803: PUSH
73804: NOP4
73808: PPUSH
73809: LD_INT 2
73811: PUSH
73812: LD_INT 30
73814: PUSH
73815: LD_INT 32
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: PUSH
73822: LD_INT 30
73824: PUSH
73825: LD_INT 31
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: LIST
73836: PPUSH
73837: NOP4
73841: PUSH
73842: NOP4
73846: PPUSH
73847: LD_INT 2
73849: PUSH
73850: LD_INT 30
73852: PUSH
73853: LD_INT 4
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 30
73862: PUSH
73863: LD_INT 5
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: LIST
73874: PPUSH
73875: NOP4
73879: ADD
73880: ST_TO_ADDR
73881: GO 74129
73883: LD_INT 2
73885: DOUBLE
73886: EQUAL
73887: IFTRUE 73897
73889: LD_INT 16
73891: DOUBLE
73892: EQUAL
73893: IFTRUE 73897
73895: GO 73943
73897: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73898: NOP4
73902: PUSH
73903: NOP4
73907: PPUSH
73908: LD_INT 2
73910: PUSH
73911: LD_INT 30
73913: PUSH
73914: LD_INT 0
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 30
73923: PUSH
73924: LD_INT 1
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: LIST
73935: PPUSH
73936: NOP4
73940: ST_TO_ADDR
73941: GO 74129
73943: LD_INT 3
73945: DOUBLE
73946: EQUAL
73947: IFTRUE 73951
73949: GO 73997
73951: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73952: NOP4
73956: PUSH
73957: NOP4
73961: PPUSH
73962: LD_INT 2
73964: PUSH
73965: LD_INT 30
73967: PUSH
73968: LD_INT 2
73970: PUSH
73971: EMPTY
73972: LIST
73973: LIST
73974: PUSH
73975: LD_INT 30
73977: PUSH
73978: LD_INT 3
73980: PUSH
73981: EMPTY
73982: LIST
73983: LIST
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: LIST
73989: PPUSH
73990: NOP4
73994: ST_TO_ADDR
73995: GO 74129
73997: LD_INT 4
73999: DOUBLE
74000: EQUAL
74001: IFTRUE 74005
74003: GO 74062
74005: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74006: NOP4
74010: PUSH
74011: NOP4
74015: PPUSH
74016: LD_INT 2
74018: PUSH
74019: LD_INT 30
74021: PUSH
74022: LD_INT 6
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 30
74031: PUSH
74032: LD_INT 7
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 30
74041: PUSH
74042: LD_INT 8
74044: PUSH
74045: EMPTY
74046: LIST
74047: LIST
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: PPUSH
74055: NOP4
74059: ST_TO_ADDR
74060: GO 74129
74062: LD_INT 5
74064: DOUBLE
74065: EQUAL
74066: IFTRUE 74082
74068: LD_INT 8
74070: DOUBLE
74071: EQUAL
74072: IFTRUE 74082
74074: LD_INT 9
74076: DOUBLE
74077: EQUAL
74078: IFTRUE 74082
74080: GO 74128
74082: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74083: NOP4
74087: PUSH
74088: NOP4
74092: PPUSH
74093: LD_INT 2
74095: PUSH
74096: LD_INT 30
74098: PUSH
74099: LD_INT 4
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PUSH
74106: LD_INT 30
74108: PUSH
74109: LD_INT 5
74111: PUSH
74112: EMPTY
74113: LIST
74114: LIST
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: LIST
74120: PPUSH
74121: NOP4
74125: ST_TO_ADDR
74126: GO 74129
74128: POP
// if not tmp then
74129: NOP4
74133: NOT
74134: IFFALSE 74138
// exit ;
74136: GO 74640
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74138: NOP4
74142: PUSH
74143: LD_INT 1
74145: PUSH
74146: LD_INT 15
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: IN
74153: PUSH
74154: NOP4
74158: PUSH
74159: NOP4
74163: ARRAY
74164: AND
74165: IFFALSE 74321
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74167: NOP4
74171: PUSH
74172: NOP4
74176: PUSH
74177: NOP4
74181: ARRAY
74182: PUSH
74183: LD_INT 1
74185: ARRAY
74186: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74187: NOP4
74191: PUSH
74192: NOP4
74196: PUSH
74197: NOP4
74201: ARRAY
74202: IN
74203: NOT
74204: IFFALSE 74319
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74206: NOP4
74210: PUSH
74211: NOP4
74215: PPUSH
74216: NOP4
74220: PUSH
74221: NOP4
74225: PUSH
74226: NOP4
74230: ARRAY
74231: PUSH
74232: LD_INT 1
74234: PLUS
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PPUSH
74240: NOP4
74244: PPUSH
74245: NOP4
74249: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74250: NOP4
74254: PUSH
74255: NOP4
74259: PPUSH
74260: NOP4
74264: PPUSH
74265: NOP4
74269: PUSH
74270: NOP4
74274: ARRAY
74275: PUSH
74276: NOP4
74280: DIFF
74281: PPUSH
74282: NOP4
74286: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74287: NOP4
74291: PPUSH
74292: NOP4
74296: PUSH
74297: NOP4
74301: ARRAY
74302: PUSH
74303: NOP4
74307: PUSH
74308: NOP4
74312: ARRAY
74313: ARRAY
74314: PPUSH
74315: NOP4
// end ; exit ;
74319: GO 74640
// end ; if tmp > 1 then
74321: NOP4
74325: PUSH
74326: LD_INT 1
74328: GREATER
74329: IFFALSE 74433
// for i = 2 to tmp do
74331: NOP4
74335: PUSH
74336: DOUBLE
74337: LD_INT 2
74339: DEC
74340: ST_TO_ADDR
74341: NOP4
74345: PUSH
74346: FOR_TO
74347: IFFALSE 74431
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74349: NOP4
74353: PUSH
74354: NOP4
74358: ARRAY
74359: PPUSH
74360: NOP4
74364: PUSH
74365: LD_INT 6
74367: EQUAL
74368: IFFALSE 74429
// begin x := tmp [ i ] ;
74370: NOP4
74374: PUSH
74375: NOP4
74379: PUSH
74380: NOP4
74384: ARRAY
74385: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74386: NOP4
74390: PUSH
74391: NOP4
74395: PPUSH
74396: NOP4
74400: PPUSH
74401: NOP4
74405: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74406: NOP4
74410: PUSH
74411: NOP4
74415: PPUSH
74416: LD_INT 1
74418: PPUSH
74419: NOP4
74423: PPUSH
74424: NOP4
74428: ST_TO_ADDR
// end ;
74429: GO 74346
74431: POP
74432: POP
// for i in tmp do
74433: NOP4
74437: PUSH
74438: NOP4
74442: PUSH
74443: FOR_IN
74444: IFFALSE 74513
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74446: NOP4
74450: PPUSH
74451: NOP4
74455: PUSH
74456: LD_INT 6
74458: LESS
74459: PUSH
74460: NOP4
74464: PPUSH
74465: NOP4
74469: PUSH
74470: LD_INT 31
74472: PUSH
74473: LD_INT 32
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: IN
74480: NOT
74481: AND
74482: PUSH
74483: NOP4
74487: PPUSH
74488: NOP4
74492: PUSH
74493: LD_INT 0
74495: EQUAL
74496: OR
74497: IFFALSE 74511
// begin j := i ;
74499: NOP4
74503: PUSH
74504: NOP4
74508: ST_TO_ADDR
// break ;
74509: GO 74513
// end ; end ;
74511: GO 74443
74513: POP
74514: POP
// if j then
74515: NOP4
74519: IFFALSE 74537
// ComEnterUnit ( unit , j ) else
74521: NOP4
74525: PPUSH
74526: NOP4
74530: PPUSH
74531: NOP4
74535: GO 74640
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74537: NOP4
74541: PUSH
74542: NOP4
74546: PPUSH
74547: LD_INT 2
74549: PUSH
74550: LD_INT 30
74552: PUSH
74553: LD_INT 0
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: LD_INT 30
74562: PUSH
74563: LD_INT 1
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: LIST
74574: PPUSH
74575: NOP4
74579: ST_TO_ADDR
// if depot then
74580: NOP4
74584: IFFALSE 74640
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74586: NOP4
74590: PUSH
74591: NOP4
74595: PPUSH
74596: NOP4
74600: PPUSH
74601: NOP4
74605: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74606: NOP4
74610: PPUSH
74611: NOP4
74615: PPUSH
74616: NOP4
74620: PUSH
74621: LD_INT 10
74623: GREATER
74624: IFFALSE 74640
// ComStandNearbyBuilding ( unit , depot ) ;
74626: NOP4
74630: PPUSH
74631: NOP4
74635: PPUSH
74636: NOP4
// end ; end ; end ;
74640: LD_VAR 0 5
74644: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74645: LD_INT 0
74647: PPUSH
74648: PPUSH
74649: PPUSH
74650: PPUSH
// if not mc_bases then
74651: NOP4
74655: NOT
74656: IFFALSE 74660
// exit ;
74658: GO 74899
// for i = 1 to mc_bases do
74660: NOP4
74664: PUSH
74665: DOUBLE
74666: LD_INT 1
74668: DEC
74669: ST_TO_ADDR
74670: NOP4
74674: PUSH
74675: FOR_TO
74676: IFFALSE 74897
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74678: NOP4
74682: PUSH
74683: NOP4
74687: PUSH
74688: NOP4
74692: ARRAY
74693: PPUSH
74694: LD_INT 21
74696: PUSH
74697: LD_INT 1
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PPUSH
74704: NOP4
74708: PUSH
74709: NOP4
74713: PUSH
74714: NOP4
74718: ARRAY
74719: UNION
74720: ST_TO_ADDR
// if not tmp then
74721: NOP4
74725: NOT
74726: IFFALSE 74730
// continue ;
74728: GO 74675
// for j in tmp do
74730: NOP4
74734: PUSH
74735: NOP4
74739: PUSH
74740: FOR_IN
74741: IFFALSE 74893
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74743: NOP4
74747: PPUSH
74748: NOP4
74752: NOT
74753: PUSH
74754: NOP4
74758: PPUSH
74759: NOP4
74763: NOT
74764: AND
74765: PUSH
74766: NOP4
74770: PPUSH
74771: NOP4
74775: NOT
74776: AND
74777: PUSH
74778: NOP4
74782: PPUSH
74783: NOP4
74787: NOT
74788: AND
74789: PUSH
74790: NOP4
74794: PUSH
74795: NOP4
74799: PUSH
74800: NOP4
74804: ARRAY
74805: PUSH
74806: LD_INT 1
74808: ARRAY
74809: IN
74810: NOT
74811: AND
74812: PUSH
74813: NOP4
74817: PUSH
74818: NOP4
74822: PUSH
74823: NOP4
74827: ARRAY
74828: PUSH
74829: LD_INT 2
74831: ARRAY
74832: IN
74833: NOT
74834: AND
74835: PUSH
74836: NOP4
74840: PUSH
74841: NOP4
74845: PUSH
74846: NOP4
74850: ARRAY
74851: IN
74852: NOT
74853: AND
74854: IFFALSE 74891
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74856: NOP4
74860: PPUSH
74861: NOP4
74865: PUSH
74866: NOP4
74870: ARRAY
74871: PPUSH
74872: NOP4
74876: PPUSH
74877: NOP4
74881: PPUSH
74882: NOP4
74886: PPUSH
74887: NOP4
// end ;
74891: GO 74740
74893: POP
74894: POP
// end ;
74895: GO 74675
74897: POP
74898: POP
// end ;
74899: LD_VAR 0 1
74903: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74904: LD_INT 0
74906: PPUSH
74907: PPUSH
74908: PPUSH
74909: PPUSH
74910: PPUSH
74911: PPUSH
// if not mc_bases [ base ] then
74912: NOP4
74916: PUSH
74917: NOP4
74921: ARRAY
74922: NOT
74923: IFFALSE 74927
// exit ;
74925: GO 75109
// tmp := [ ] ;
74927: NOP4
74931: PUSH
74932: EMPTY
74933: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74934: NOP4
74938: PUSH
74939: NOP4
74943: PPUSH
74944: LD_INT 0
74946: PPUSH
74947: NOP4
74951: ST_TO_ADDR
// if not list then
74952: NOP4
74956: NOT
74957: IFFALSE 74961
// exit ;
74959: GO 75109
// for i = 1 to amount do
74961: NOP4
74965: PUSH
74966: DOUBLE
74967: LD_INT 1
74969: DEC
74970: ST_TO_ADDR
74971: NOP4
74975: PUSH
74976: FOR_TO
74977: IFFALSE 75057
// begin x := rand ( 1 , list [ 1 ] ) ;
74979: NOP4
74983: PUSH
74984: LD_INT 1
74986: PPUSH
74987: NOP4
74991: PUSH
74992: LD_INT 1
74994: ARRAY
74995: PPUSH
74996: NOP4
75000: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75001: NOP4
75005: PUSH
75006: NOP4
75010: PPUSH
75011: NOP4
75015: PPUSH
75016: NOP4
75020: PUSH
75021: LD_INT 1
75023: ARRAY
75024: PUSH
75025: NOP4
75029: ARRAY
75030: PUSH
75031: NOP4
75035: PUSH
75036: LD_INT 2
75038: ARRAY
75039: PUSH
75040: NOP4
75044: ARRAY
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PPUSH
75050: NOP4
75054: ST_TO_ADDR
// end ;
75055: GO 74976
75057: POP
75058: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75059: NOP4
75063: PUSH
75064: NOP4
75068: PPUSH
75069: NOP4
75073: PPUSH
75074: NOP4
75078: PPUSH
75079: NOP4
75083: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75084: NOP4
75088: PUSH
75089: NOP4
75093: PPUSH
75094: NOP4
75098: PPUSH
75099: NOP4
75103: PPUSH
75104: NOP4
75108: ST_TO_ADDR
// end ;
75109: LD_VAR 0 4
75113: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75114: LD_INT 0
75116: PPUSH
// if not mc_bases [ base ] then
75117: NOP4
75121: PUSH
75122: NOP4
75126: ARRAY
75127: NOT
75128: IFFALSE 75132
// exit ;
75130: GO 75157
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75132: NOP4
75136: PUSH
75137: NOP4
75141: PPUSH
75142: NOP4
75146: PPUSH
75147: NOP4
75151: PPUSH
75152: NOP4
75156: ST_TO_ADDR
// end ;
75157: LD_VAR 0 3
75161: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75162: LD_INT 0
75164: PPUSH
// if not mc_bases [ base ] then
75165: NOP4
75169: PUSH
75170: NOP4
75174: ARRAY
75175: NOT
75176: IFFALSE 75180
// exit ;
75178: GO 75217
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75180: NOP4
75184: PUSH
75185: NOP4
75189: PPUSH
75190: NOP4
75194: PPUSH
75195: NOP4
75199: PUSH
75200: NOP4
75204: ARRAY
75205: PUSH
75206: NOP4
75210: UNION
75211: PPUSH
75212: NOP4
75216: ST_TO_ADDR
// end ;
75217: LD_VAR 0 3
75221: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75222: LD_INT 0
75224: PPUSH
// if not mc_bases [ base ] then
75225: NOP4
75229: PUSH
75230: NOP4
75234: ARRAY
75235: NOT
75236: IFFALSE 75240
// exit ;
75238: GO 75265
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75240: NOP4
75244: PUSH
75245: NOP4
75249: PPUSH
75250: NOP4
75254: PPUSH
75255: NOP4
75259: PPUSH
75260: NOP4
75264: ST_TO_ADDR
// end ;
75265: LD_VAR 0 3
75269: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75270: LD_INT 0
75272: PPUSH
// if not mc_bases [ base ] then
75273: NOP4
75277: PUSH
75278: NOP4
75282: ARRAY
75283: NOT
75284: IFFALSE 75288
// exit ;
75286: GO 75325
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75288: NOP4
75292: PUSH
75293: NOP4
75297: PPUSH
75298: NOP4
75302: PPUSH
75303: NOP4
75307: PUSH
75308: NOP4
75312: ARRAY
75313: PUSH
75314: NOP4
75318: ADD
75319: PPUSH
75320: NOP4
75324: ST_TO_ADDR
// end ;
75325: LD_VAR 0 3
75329: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75330: LD_INT 0
75332: PPUSH
// if not mc_bases [ base ] then
75333: NOP4
75337: PUSH
75338: NOP4
75342: ARRAY
75343: NOT
75344: IFFALSE 75348
// exit ;
75346: GO 75402
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75348: NOP4
75352: PUSH
75353: NOP4
75357: PPUSH
75358: NOP4
75362: PPUSH
75363: NOP4
75367: PPUSH
75368: NOP4
75372: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75373: NOP4
75377: PUSH
75378: NOP4
75382: PPUSH
75383: NOP4
75387: PPUSH
75388: NOP4
75392: PUSH
75393: LD_INT 0
75395: PLUS
75396: PPUSH
75397: NOP4
75401: ST_TO_ADDR
// end ;
75402: LD_VAR 0 3
75406: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75407: LD_INT 0
75409: PPUSH
// if not mc_bases [ base ] then
75410: NOP4
75414: PUSH
75415: NOP4
75419: ARRAY
75420: NOT
75421: IFFALSE 75425
// exit ;
75423: GO 75450
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75425: NOP4
75429: PUSH
75430: NOP4
75434: PPUSH
75435: NOP4
75439: PPUSH
75440: NOP4
75444: PPUSH
75445: NOP4
75449: ST_TO_ADDR
// end ;
75450: LD_VAR 0 3
75454: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75455: LD_INT 0
75457: PPUSH
75458: PPUSH
75459: PPUSH
75460: PPUSH
// if not mc_bases [ base ] then
75461: NOP4
75465: PUSH
75466: NOP4
75470: ARRAY
75471: NOT
75472: IFFALSE 75476
// exit ;
75474: GO 75541
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75476: NOP4
75480: PUSH
75481: NOP4
75485: PPUSH
75486: NOP4
75490: PUSH
75491: NOP4
75495: PUSH
75496: NOP4
75500: ARRAY
75501: PUSH
75502: LD_INT 1
75504: PLUS
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PPUSH
75510: NOP4
75514: PUSH
75515: NOP4
75519: PUSH
75520: NOP4
75524: PUSH
75525: NOP4
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: PPUSH
75536: NOP4
75540: ST_TO_ADDR
// end ;
75541: LD_VAR 0 5
75545: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75546: LD_INT 0
75548: PPUSH
// if not mc_bases [ base ] then
75549: NOP4
75553: PUSH
75554: NOP4
75558: ARRAY
75559: NOT
75560: IFFALSE 75564
// exit ;
75562: GO 75589
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75564: NOP4
75568: PUSH
75569: NOP4
75573: PPUSH
75574: NOP4
75578: PPUSH
75579: NOP4
75583: PPUSH
75584: NOP4
75588: ST_TO_ADDR
// end ;
75589: LD_VAR 0 3
75593: RET
// export function MC_GetMinesField ( base ) ; begin
75594: LD_INT 0
75596: PPUSH
// result := mc_mines [ base ] ;
75597: NOP4
75601: PUSH
75602: NOP4
75606: PUSH
75607: NOP4
75611: ARRAY
75612: ST_TO_ADDR
// end ;
75613: LD_VAR 0 2
75617: RET
// export function MC_GetProduceList ( base ) ; begin
75618: LD_INT 0
75620: PPUSH
// result := mc_produce [ base ] ;
75621: NOP4
75625: PUSH
75626: NOP4
75630: PUSH
75631: NOP4
75635: ARRAY
75636: ST_TO_ADDR
// end ;
75637: LD_VAR 0 2
75641: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75642: LD_INT 0
75644: PPUSH
75645: PPUSH
// if not mc_bases then
75646: NOP4
75650: NOT
75651: IFFALSE 75655
// exit ;
75653: GO 75720
// if mc_bases [ base ] then
75655: NOP4
75659: PUSH
75660: NOP4
75664: ARRAY
75665: IFFALSE 75720
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75667: NOP4
75671: PUSH
75672: NOP4
75676: PUSH
75677: NOP4
75681: ARRAY
75682: PPUSH
75683: LD_INT 30
75685: PUSH
75686: NOP4
75690: PUSH
75691: EMPTY
75692: LIST
75693: LIST
75694: PPUSH
75695: NOP4
75699: ST_TO_ADDR
// if result then
75700: NOP4
75704: IFFALSE 75720
// result := result [ 1 ] ;
75706: NOP4
75710: PUSH
75711: NOP4
75715: PUSH
75716: LD_INT 1
75718: ARRAY
75719: ST_TO_ADDR
// end ; end ;
75720: LD_VAR 0 3
75724: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75725: LD_INT 0
75727: PPUSH
75728: PPUSH
// if not mc_bases then
75729: NOP4
75733: NOT
75734: IFFALSE 75738
// exit ;
75736: GO 75783
// if mc_bases [ base ] then
75738: NOP4
75742: PUSH
75743: NOP4
75747: ARRAY
75748: IFFALSE 75783
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75750: NOP4
75754: PUSH
75755: NOP4
75759: PUSH
75760: NOP4
75764: ARRAY
75765: PPUSH
75766: LD_INT 30
75768: PUSH
75769: NOP4
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PPUSH
75778: NOP4
75782: ST_TO_ADDR
// end ;
75783: LD_VAR 0 3
75787: RET
// export function MC_SetTame ( base , area ) ; begin
75788: LD_INT 0
75790: PPUSH
// if not mc_bases or not base then
75791: NOP4
75795: NOT
75796: PUSH
75797: NOP4
75801: NOT
75802: OR
75803: IFFALSE 75807
// exit ;
75805: GO 75832
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75807: NOP4
75811: PUSH
75812: NOP4
75816: PPUSH
75817: NOP4
75821: PPUSH
75822: NOP4
75826: PPUSH
75827: NOP4
75831: ST_TO_ADDR
// end ;
75832: LD_VAR 0 3
75836: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75837: LD_INT 0
75839: PPUSH
75840: PPUSH
// if not mc_bases or not base then
75841: NOP4
75845: NOT
75846: PUSH
75847: NOP4
75851: NOT
75852: OR
75853: IFFALSE 75857
// exit ;
75855: GO 75959
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75857: NOP4
75861: PUSH
75862: NOP4
75866: PUSH
75867: NOP4
75871: ARRAY
75872: PPUSH
75873: LD_INT 30
75875: PUSH
75876: NOP4
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PPUSH
75885: NOP4
75889: ST_TO_ADDR
// if not tmp then
75890: NOP4
75894: NOT
75895: IFFALSE 75899
// exit ;
75897: GO 75959
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75899: NOP4
75903: PUSH
75904: NOP4
75908: PPUSH
75909: NOP4
75913: PPUSH
75914: NOP4
75918: PUSH
75919: NOP4
75923: ARRAY
75924: PPUSH
75925: NOP4
75929: PUSH
75930: NOP4
75934: ARRAY
75935: PUSH
75936: LD_INT 1
75938: PLUS
75939: PPUSH
75940: NOP4
75944: PUSH
75945: LD_INT 1
75947: ARRAY
75948: PPUSH
75949: NOP4
75953: PPUSH
75954: NOP4
75958: ST_TO_ADDR
// end ;
75959: LD_VAR 0 3
75963: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75964: LD_INT 0
75966: PPUSH
75967: PPUSH
// if not mc_bases or not base or not kinds then
75968: NOP4
75972: NOT
75973: PUSH
75974: NOP4
75978: NOT
75979: OR
75980: PUSH
75981: NOP4
75985: NOT
75986: OR
75987: IFFALSE 75991
// exit ;
75989: GO 76052
// for i in kinds do
75991: NOP4
75995: PUSH
75996: NOP4
76000: PUSH
76001: FOR_IN
76002: IFFALSE 76050
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76004: NOP4
76008: PUSH
76009: NOP4
76013: PPUSH
76014: NOP4
76018: PUSH
76019: NOP4
76023: PUSH
76024: NOP4
76028: ARRAY
76029: PUSH
76030: LD_INT 1
76032: PLUS
76033: PUSH
76034: EMPTY
76035: LIST
76036: LIST
76037: PPUSH
76038: NOP4
76042: PPUSH
76043: NOP4
76047: ST_TO_ADDR
76048: GO 76001
76050: POP
76051: POP
// end ;
76052: LD_VAR 0 3
76056: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76057: LD_INT 0
76059: PPUSH
// if not mc_bases or not base or not areas then
76060: NOP4
76064: NOT
76065: PUSH
76066: NOP4
76070: NOT
76071: OR
76072: PUSH
76073: NOP4
76077: NOT
76078: OR
76079: IFFALSE 76083
// exit ;
76081: GO 76108
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76083: NOP4
76087: PUSH
76088: NOP4
76092: PPUSH
76093: NOP4
76097: PPUSH
76098: NOP4
76102: PPUSH
76103: NOP4
76107: ST_TO_ADDR
// end ;
76108: LD_VAR 0 3
76112: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76113: LD_INT 0
76115: PPUSH
// if not mc_bases or not base or not teleports_exit then
76116: NOP4
76120: NOT
76121: PUSH
76122: NOP4
76126: NOT
76127: OR
76128: PUSH
76129: NOP4
76133: NOT
76134: OR
76135: IFFALSE 76139
// exit ;
76137: GO 76164
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76139: NOP4
76143: PUSH
76144: NOP4
76148: PPUSH
76149: NOP4
76153: PPUSH
76154: NOP4
76158: PPUSH
76159: NOP4
76163: ST_TO_ADDR
// end ;
76164: LD_VAR 0 3
76168: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76169: LD_INT 0
76171: PPUSH
76172: PPUSH
76173: PPUSH
// if not mc_bases or not base or not ext_list then
76174: NOP4
76178: NOT
76179: PUSH
76180: NOP4
76184: NOT
76185: OR
76186: PUSH
76187: NOP4
76191: NOT
76192: OR
76193: IFFALSE 76197
// exit ;
76195: GO 76370
// tmp := GetFacExtXYD ( x , y , d ) ;
76197: NOP4
76201: PUSH
76202: NOP4
76206: PPUSH
76207: NOP4
76211: PPUSH
76212: NOP4
76216: PPUSH
76217: NOP4
76221: ST_TO_ADDR
// if not tmp then
76222: NOP4
76226: NOT
76227: IFFALSE 76231
// exit ;
76229: GO 76370
// for i in tmp do
76231: NOP4
76235: PUSH
76236: NOP4
76240: PUSH
76241: FOR_IN
76242: IFFALSE 76368
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76244: NOP4
76248: PUSH
76249: NOP4
76253: PPUSH
76254: NOP4
76258: PPUSH
76259: NOP4
76263: PUSH
76264: NOP4
76268: ARRAY
76269: PPUSH
76270: NOP4
76274: PUSH
76275: NOP4
76279: ARRAY
76280: PUSH
76281: LD_INT 1
76283: PLUS
76284: PPUSH
76285: NOP4
76289: PUSH
76290: LD_INT 1
76292: ARRAY
76293: PUSH
76294: NOP4
76298: PUSH
76299: LD_INT 1
76301: ARRAY
76302: PUSH
76303: NOP4
76307: PUSH
76308: LD_INT 2
76310: ARRAY
76311: PUSH
76312: NOP4
76316: PUSH
76317: LD_INT 3
76319: ARRAY
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: LIST
76325: LIST
76326: PPUSH
76327: NOP4
76331: PPUSH
76332: NOP4
76336: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76337: NOP4
76341: PUSH
76342: NOP4
76346: PPUSH
76347: LD_INT 1
76349: PPUSH
76350: NOP4
76354: ST_TO_ADDR
// if not ext_list then
76355: NOP4
76359: NOT
76360: IFFALSE 76366
// exit ;
76362: POP
76363: POP
76364: GO 76370
// end ;
76366: GO 76241
76368: POP
76369: POP
// end ;
76370: LD_VAR 0 6
76374: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76375: LD_INT 0
76377: PPUSH
// if not mc_bases or not base or not weapon_list then
76378: NOP4
76382: NOT
76383: PUSH
76384: NOP4
76388: NOT
76389: OR
76390: PUSH
76391: NOP4
76395: NOT
76396: OR
76397: IFFALSE 76401
// exit ;
76399: GO 76426
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76401: NOP4
76405: PUSH
76406: NOP4
76410: PPUSH
76411: NOP4
76415: PPUSH
76416: NOP4
76420: PPUSH
76421: NOP4
76425: ST_TO_ADDR
// end ;
76426: LD_VAR 0 3
76430: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76431: LD_INT 0
76433: PPUSH
// if not mc_bases or not base or not tech_list then
76434: NOP4
76438: NOT
76439: PUSH
76440: NOP4
76444: NOT
76445: OR
76446: PUSH
76447: NOP4
76451: NOT
76452: OR
76453: IFFALSE 76457
// exit ;
76455: GO 76482
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76457: NOP4
76461: PUSH
76462: NOP4
76466: PPUSH
76467: NOP4
76471: PPUSH
76472: NOP4
76476: PPUSH
76477: NOP4
76481: ST_TO_ADDR
// end ;
76482: LD_VAR 0 3
76486: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76487: LD_INT 0
76489: PPUSH
// if not mc_bases or not parking_area or not base then
76490: NOP4
76494: NOT
76495: PUSH
76496: NOP4
76500: NOT
76501: OR
76502: PUSH
76503: NOP4
76507: NOT
76508: OR
76509: IFFALSE 76513
// exit ;
76511: GO 76538
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76513: NOP4
76517: PUSH
76518: NOP4
76522: PPUSH
76523: NOP4
76527: PPUSH
76528: NOP4
76532: PPUSH
76533: NOP4
76537: ST_TO_ADDR
// end ;
76538: LD_VAR 0 3
76542: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76543: LD_INT 0
76545: PPUSH
// if not mc_bases or not base or not scan_area then
76546: NOP4
76550: NOT
76551: PUSH
76552: NOP4
76556: NOT
76557: OR
76558: PUSH
76559: NOP4
76563: NOT
76564: OR
76565: IFFALSE 76569
// exit ;
76567: GO 76594
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76569: NOP4
76573: PUSH
76574: NOP4
76578: PPUSH
76579: NOP4
76583: PPUSH
76584: NOP4
76588: PPUSH
76589: NOP4
76593: ST_TO_ADDR
// end ;
76594: LD_VAR 0 3
76598: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76599: LD_INT 0
76601: PPUSH
76602: PPUSH
// if not mc_bases or not base then
76603: NOP4
76607: NOT
76608: PUSH
76609: NOP4
76613: NOT
76614: OR
76615: IFFALSE 76619
// exit ;
76617: GO 76683
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76619: NOP4
76623: PUSH
76624: LD_INT 1
76626: PUSH
76627: LD_INT 2
76629: PUSH
76630: LD_INT 3
76632: PUSH
76633: LD_INT 4
76635: PUSH
76636: LD_INT 11
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: LIST
76643: LIST
76644: LIST
76645: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76646: NOP4
76650: PUSH
76651: NOP4
76655: PPUSH
76656: NOP4
76660: PPUSH
76661: NOP4
76665: PUSH
76666: NOP4
76670: ARRAY
76671: PUSH
76672: NOP4
76676: DIFF
76677: PPUSH
76678: NOP4
76682: ST_TO_ADDR
// end ;
76683: LD_VAR 0 2
76687: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76688: LD_INT 0
76690: PPUSH
// result := mc_vehicles [ base ] ;
76691: NOP4
76695: PUSH
76696: NOP4
76700: PUSH
76701: NOP4
76705: ARRAY
76706: ST_TO_ADDR
// if onlyCombat then
76707: NOP4
76711: IFFALSE 76889
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76713: NOP4
76717: PUSH
76718: NOP4
76722: PUSH
76723: NOP4
76727: PPUSH
76728: LD_INT 2
76730: PUSH
76731: LD_INT 34
76733: PUSH
76734: LD_INT 12
76736: PUSH
76737: EMPTY
76738: LIST
76739: LIST
76740: PUSH
76741: LD_INT 34
76743: PUSH
76744: LD_INT 51
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: LD_INT 34
76753: PUSH
76754: NOP4
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 34
76765: PUSH
76766: LD_INT 32
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PUSH
76773: LD_INT 34
76775: PUSH
76776: LD_INT 13
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: PUSH
76783: LD_INT 34
76785: PUSH
76786: LD_INT 52
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 34
76795: PUSH
76796: NOP4
76800: PUSH
76801: EMPTY
76802: LIST
76803: LIST
76804: PUSH
76805: LD_INT 34
76807: PUSH
76808: LD_INT 14
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 34
76817: PUSH
76818: LD_INT 53
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: LD_INT 34
76827: PUSH
76828: NOP4
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: LD_INT 34
76839: PUSH
76840: LD_INT 31
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: PUSH
76847: LD_INT 34
76849: PUSH
76850: LD_INT 48
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: LD_INT 34
76859: PUSH
76860: LD_INT 8
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: EMPTY
76868: LIST
76869: LIST
76870: LIST
76871: LIST
76872: LIST
76873: LIST
76874: LIST
76875: LIST
76876: LIST
76877: LIST
76878: LIST
76879: LIST
76880: LIST
76881: LIST
76882: PPUSH
76883: NOP4
76887: DIFF
76888: ST_TO_ADDR
// end ; end_of_file
76889: LD_VAR 0 3
76893: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76894: LD_INT 0
76896: PPUSH
76897: PPUSH
76898: PPUSH
// if not mc_bases or not skirmish then
76899: NOP4
76903: NOT
76904: PUSH
76905: NOP4
76909: NOT
76910: OR
76911: IFFALSE 76915
// exit ;
76913: GO 77080
// for i = 1 to mc_bases do
76915: NOP4
76919: PUSH
76920: DOUBLE
76921: LD_INT 1
76923: DEC
76924: ST_TO_ADDR
76925: NOP4
76929: PUSH
76930: FOR_TO
76931: IFFALSE 77078
// begin if sci in mc_bases [ i ] then
76933: NOP4
76937: PUSH
76938: NOP4
76942: PUSH
76943: NOP4
76947: ARRAY
76948: IN
76949: IFFALSE 77076
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76951: NOP4
76955: PUSH
76956: NOP4
76960: PPUSH
76961: NOP4
76965: PUSH
76966: NOP4
76970: PUSH
76971: NOP4
76975: ARRAY
76976: PUSH
76977: LD_INT 1
76979: PLUS
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: PPUSH
76985: NOP4
76989: PPUSH
76990: NOP4
76994: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
76995: NOP4
76999: PUSH
77000: NOP4
77004: PUSH
77005: NOP4
77009: ARRAY
77010: PPUSH
77011: LD_INT 2
77013: PUSH
77014: LD_INT 30
77016: PUSH
77017: LD_INT 0
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: LD_INT 30
77026: PUSH
77027: LD_INT 1
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: LIST
77038: PPUSH
77039: NOP4
77043: PPUSH
77044: NOP4
77048: PPUSH
77049: NOP4
77053: ST_TO_ADDR
// if tmp then
77054: NOP4
77058: IFFALSE 77074
// ComStandNearbyBuilding ( ape , tmp ) ;
77060: NOP4
77064: PPUSH
77065: NOP4
77069: PPUSH
77070: NOP4
// break ;
77074: GO 77078
// end ; end ;
77076: GO 76930
77078: POP
77079: POP
// end ;
77080: LD_VAR 0 3
77084: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77085: LD_INT 0
77087: PPUSH
77088: PPUSH
77089: PPUSH
// if not mc_bases or not skirmish then
77090: NOP4
77094: NOT
77095: PUSH
77096: NOP4
77100: NOT
77101: OR
77102: IFFALSE 77106
// exit ;
77104: GO 77195
// for i = 1 to mc_bases do
77106: NOP4
77110: PUSH
77111: DOUBLE
77112: LD_INT 1
77114: DEC
77115: ST_TO_ADDR
77116: NOP4
77120: PUSH
77121: FOR_TO
77122: IFFALSE 77193
// begin if building in mc_busy_turret_list [ i ] then
77124: NOP4
77128: PUSH
77129: NOP4
77133: PUSH
77134: NOP4
77138: ARRAY
77139: IN
77140: IFFALSE 77191
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77142: NOP4
77146: PUSH
77147: NOP4
77151: PUSH
77152: NOP4
77156: ARRAY
77157: PUSH
77158: NOP4
77162: DIFF
77163: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77164: NOP4
77168: PUSH
77169: NOP4
77173: PPUSH
77174: NOP4
77178: PPUSH
77179: NOP4
77183: PPUSH
77184: NOP4
77188: ST_TO_ADDR
// break ;
77189: GO 77193
// end ; end ;
77191: GO 77121
77193: POP
77194: POP
// end ;
77195: LD_VAR 0 3
77199: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77200: LD_INT 0
77202: PPUSH
77203: PPUSH
77204: PPUSH
// if not mc_bases or not skirmish then
77205: NOP4
77209: NOT
77210: PUSH
77211: NOP4
77215: NOT
77216: OR
77217: IFFALSE 77221
// exit ;
77219: GO 77420
// for i = 1 to mc_bases do
77221: NOP4
77225: PUSH
77226: DOUBLE
77227: LD_INT 1
77229: DEC
77230: ST_TO_ADDR
77231: NOP4
77235: PUSH
77236: FOR_TO
77237: IFFALSE 77418
// if building in mc_bases [ i ] then
77239: NOP4
77243: PUSH
77244: NOP4
77248: PUSH
77249: NOP4
77253: ARRAY
77254: IN
77255: IFFALSE 77416
// begin tmp := mc_bases [ i ] diff building ;
77257: NOP4
77261: PUSH
77262: NOP4
77266: PUSH
77267: NOP4
77271: ARRAY
77272: PUSH
77273: NOP4
77277: DIFF
77278: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77279: NOP4
77283: PUSH
77284: NOP4
77288: PPUSH
77289: NOP4
77293: PPUSH
77294: NOP4
77298: PPUSH
77299: NOP4
77303: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77304: NOP4
77308: PUSH
77309: NOP4
77313: PUSH
77314: NOP4
77318: ARRAY
77319: IN
77320: IFFALSE 77359
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77322: NOP4
77326: PUSH
77327: NOP4
77331: PPUSH
77332: NOP4
77336: PPUSH
77337: NOP4
77341: PUSH
77342: NOP4
77346: ARRAY
77347: PUSH
77348: NOP4
77352: DIFF
77353: PPUSH
77354: NOP4
77358: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77359: NOP4
77363: PUSH
77364: NOP4
77368: PUSH
77369: NOP4
77373: ARRAY
77374: IN
77375: IFFALSE 77414
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77377: NOP4
77381: PUSH
77382: NOP4
77386: PPUSH
77387: NOP4
77391: PPUSH
77392: NOP4
77396: PUSH
77397: NOP4
77401: ARRAY
77402: PUSH
77403: NOP4
77407: DIFF
77408: PPUSH
77409: NOP4
77413: ST_TO_ADDR
// break ;
77414: GO 77418
// end ;
77416: GO 77236
77418: POP
77419: POP
// end ;
77420: LD_VAR 0 4
77424: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77425: LD_INT 0
77427: PPUSH
77428: PPUSH
77429: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77430: NOP4
77434: NOT
77435: PUSH
77436: NOP4
77440: NOT
77441: OR
77442: PUSH
77443: NOP4
77447: PUSH
77448: NOP4
77452: IN
77453: NOT
77454: OR
77455: IFFALSE 77459
// exit ;
77457: GO 77582
// for i = 1 to mc_vehicles do
77459: NOP4
77463: PUSH
77464: DOUBLE
77465: LD_INT 1
77467: DEC
77468: ST_TO_ADDR
77469: NOP4
77473: PUSH
77474: FOR_TO
77475: IFFALSE 77580
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77477: NOP4
77481: PUSH
77482: NOP4
77486: PUSH
77487: NOP4
77491: ARRAY
77492: IN
77493: PUSH
77494: NOP4
77498: PUSH
77499: NOP4
77503: PUSH
77504: NOP4
77508: ARRAY
77509: IN
77510: OR
77511: IFFALSE 77578
// begin tmp := mc_vehicles [ i ] diff old ;
77513: NOP4
77517: PUSH
77518: NOP4
77522: PUSH
77523: NOP4
77527: ARRAY
77528: PUSH
77529: NOP4
77533: DIFF
77534: ST_TO_ADDR
// tmp := tmp diff new ;
77535: NOP4
77539: PUSH
77540: NOP4
77544: PUSH
77545: NOP4
77549: DIFF
77550: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77551: NOP4
77555: PUSH
77556: NOP4
77560: PPUSH
77561: NOP4
77565: PPUSH
77566: NOP4
77570: PPUSH
77571: NOP4
77575: ST_TO_ADDR
// break ;
77576: GO 77580
// end ;
77578: GO 77474
77580: POP
77581: POP
// end ;
77582: LD_VAR 0 5
77586: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77587: LD_INT 0
77589: PPUSH
77590: PPUSH
77591: PPUSH
77592: PPUSH
// if not mc_bases or not skirmish then
77593: NOP4
77597: NOT
77598: PUSH
77599: NOP4
77603: NOT
77604: OR
77605: IFFALSE 77609
// exit ;
77607: GO 78001
// side := GetSide ( vehicle ) ;
77609: NOP4
77613: PUSH
77614: NOP4
77618: PPUSH
77619: NOP4
77623: ST_TO_ADDR
// for i = 1 to mc_bases do
77624: NOP4
77628: PUSH
77629: DOUBLE
77630: LD_INT 1
77632: DEC
77633: ST_TO_ADDR
77634: NOP4
77638: PUSH
77639: FOR_TO
77640: IFFALSE 77999
// begin if factory in mc_bases [ i ] then
77642: NOP4
77646: PUSH
77647: NOP4
77651: PUSH
77652: NOP4
77656: ARRAY
77657: IN
77658: IFFALSE 77997
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77660: NOP4
77664: PUSH
77665: NOP4
77669: ARRAY
77670: PUSH
77671: NOP4
77675: PUSH
77676: NOP4
77680: ARRAY
77681: LESS
77682: PUSH
77683: NOP4
77687: PPUSH
77688: NOP4
77692: PUSH
77693: LD_INT 31
77695: PUSH
77696: LD_INT 32
77698: PUSH
77699: LD_INT 51
77701: PUSH
77702: NOP4
77706: PUSH
77707: LD_INT 12
77709: PUSH
77710: LD_INT 30
77712: PUSH
77713: NOP4
77717: PUSH
77718: LD_INT 11
77720: PUSH
77721: LD_INT 53
77723: PUSH
77724: LD_INT 14
77726: PUSH
77727: NOP4
77731: PUSH
77732: LD_INT 29
77734: PUSH
77735: NOP4
77739: PUSH
77740: LD_INT 13
77742: PUSH
77743: LD_INT 52
77745: PUSH
77746: NOP4
77750: PUSH
77751: LD_INT 48
77753: PUSH
77754: LD_INT 8
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: LIST
77763: LIST
77764: LIST
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: LIST
77776: IN
77777: NOT
77778: AND
77779: IFFALSE 77827
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77781: NOP4
77785: PUSH
77786: NOP4
77790: PPUSH
77791: NOP4
77795: PUSH
77796: NOP4
77800: PUSH
77801: NOP4
77805: ARRAY
77806: PUSH
77807: LD_INT 1
77809: PLUS
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PPUSH
77815: NOP4
77819: PPUSH
77820: NOP4
77824: ST_TO_ADDR
77825: GO 77871
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77827: NOP4
77831: PUSH
77832: NOP4
77836: PPUSH
77837: NOP4
77841: PUSH
77842: NOP4
77846: PUSH
77847: NOP4
77851: ARRAY
77852: PUSH
77853: LD_INT 1
77855: PLUS
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PPUSH
77861: NOP4
77865: PPUSH
77866: NOP4
77870: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77871: NOP4
77875: PPUSH
77876: NOP4
77880: PUSH
77881: LD_INT 2
77883: EQUAL
77884: IFFALSE 77913
// begin repeat wait ( 0 0$3 ) ;
77886: LD_INT 105
77888: PPUSH
77889: NOP4
// Connect ( vehicle ) ;
77893: NOP4
77897: PPUSH
77898: NOP4
// until IsControledBy ( vehicle ) ;
77902: NOP4
77906: PPUSH
77907: NOP4
77911: IFFALSE 77886
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77913: NOP4
77917: PPUSH
77918: NOP4
77922: PUSH
77923: NOP4
77927: ARRAY
77928: PPUSH
77929: NOP4
// if GetControl ( vehicle ) <> control_manual then
77933: NOP4
77937: PPUSH
77938: NOP4
77942: PUSH
77943: LD_INT 1
77945: NONEQUAL
77946: IFFALSE 77950
// break ;
77948: GO 77999
// repeat wait ( 0 0$1 ) ;
77950: LD_INT 35
77952: PPUSH
77953: NOP4
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77957: NOP4
77961: PPUSH
77962: NOP4
77966: PUSH
77967: NOP4
77971: ARRAY
77972: PPUSH
77973: NOP4
77977: IFFALSE 77950
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77979: NOP4
77983: PPUSH
77984: NOP4
77988: PPUSH
77989: NOP4
// exit ;
77993: POP
77994: POP
77995: GO 78001
// end ; end ;
77997: GO 77639
77999: POP
78000: POP
// end ;
78001: LD_VAR 0 3
78005: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78006: LD_INT 0
78008: PPUSH
78009: PPUSH
78010: PPUSH
78011: PPUSH
// if not mc_bases or not skirmish then
78012: NOP4
78016: NOT
78017: PUSH
78018: NOP4
78022: NOT
78023: OR
78024: IFFALSE 78028
// exit ;
78026: GO 78381
// repeat wait ( 0 0$1 ) ;
78028: LD_INT 35
78030: PPUSH
78031: NOP4
// until GetResourceAmountXY ( x , y ) ;
78035: NOP4
78039: PPUSH
78040: NOP4
78044: PPUSH
78045: NOP4
78049: IFFALSE 78028
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78051: NOP4
78055: PPUSH
78056: NOP4
78060: PPUSH
78061: NOP4
78065: PUSH
78066: LD_INT 4
78068: EQUAL
78069: IFFALSE 78073
// exit ;
78071: GO 78381
// for i = 1 to mc_bases do
78073: NOP4
78077: PUSH
78078: DOUBLE
78079: LD_INT 1
78081: DEC
78082: ST_TO_ADDR
78083: NOP4
78087: PUSH
78088: FOR_TO
78089: IFFALSE 78379
// begin if mc_crates_area [ i ] then
78091: NOP4
78095: PUSH
78096: NOP4
78100: ARRAY
78101: IFFALSE 78212
// for j in mc_crates_area [ i ] do
78103: NOP4
78107: PUSH
78108: NOP4
78112: PUSH
78113: NOP4
78117: ARRAY
78118: PUSH
78119: FOR_IN
78120: IFFALSE 78210
// if InArea ( x , y , j ) then
78122: NOP4
78126: PPUSH
78127: NOP4
78131: PPUSH
78132: NOP4
78136: PPUSH
78137: NOP4
78141: IFFALSE 78208
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78143: NOP4
78147: PUSH
78148: NOP4
78152: PPUSH
78153: NOP4
78157: PUSH
78158: NOP4
78162: PUSH
78163: NOP4
78167: ARRAY
78168: PUSH
78169: LD_INT 1
78171: PLUS
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PPUSH
78177: NOP4
78181: PUSH
78182: NOP4
78186: PUSH
78187: NOP4
78191: PUSH
78192: EMPTY
78193: LIST
78194: LIST
78195: LIST
78196: PPUSH
78197: NOP4
78201: ST_TO_ADDR
// exit ;
78202: POP
78203: POP
78204: POP
78205: POP
78206: GO 78381
// end ;
78208: GO 78119
78210: POP
78211: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78212: NOP4
78216: PUSH
78217: NOP4
78221: PUSH
78222: NOP4
78226: ARRAY
78227: PPUSH
78228: LD_INT 2
78230: PUSH
78231: LD_INT 30
78233: PUSH
78234: LD_INT 0
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: LD_INT 30
78243: PUSH
78244: LD_INT 1
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: LIST
78255: PPUSH
78256: NOP4
78260: ST_TO_ADDR
// if not depot then
78261: NOP4
78265: NOT
78266: IFFALSE 78270
// continue ;
78268: GO 78088
// for j in depot do
78270: NOP4
78274: PUSH
78275: NOP4
78279: PUSH
78280: FOR_IN
78281: IFFALSE 78375
// if GetDistUnitXY ( j , x , y ) < 30 then
78283: NOP4
78287: PPUSH
78288: NOP4
78292: PPUSH
78293: NOP4
78297: PPUSH
78298: NOP4
78302: PUSH
78303: LD_INT 30
78305: LESS
78306: IFFALSE 78373
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78308: NOP4
78312: PUSH
78313: NOP4
78317: PPUSH
78318: NOP4
78322: PUSH
78323: NOP4
78327: PUSH
78328: NOP4
78332: ARRAY
78333: PUSH
78334: LD_INT 1
78336: PLUS
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PPUSH
78342: NOP4
78346: PUSH
78347: NOP4
78351: PUSH
78352: NOP4
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: LIST
78361: PPUSH
78362: NOP4
78366: ST_TO_ADDR
// exit ;
78367: POP
78368: POP
78369: POP
78370: POP
78371: GO 78381
// end ;
78373: GO 78280
78375: POP
78376: POP
// end ;
78377: GO 78088
78379: POP
78380: POP
// end ;
78381: LD_VAR 0 6
78385: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78386: LD_INT 0
78388: PPUSH
78389: PPUSH
78390: PPUSH
78391: PPUSH
// if not mc_bases or not skirmish then
78392: NOP4
78396: NOT
78397: PUSH
78398: NOP4
78402: NOT
78403: OR
78404: IFFALSE 78408
// exit ;
78406: GO 78685
// side := GetSide ( lab ) ;
78408: NOP4
78412: PUSH
78413: NOP4
78417: PPUSH
78418: NOP4
78422: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78423: NOP4
78427: PUSH
78428: NOP4
78432: IN
78433: NOT
78434: PUSH
78435: NOP4
78439: NOT
78440: OR
78441: PUSH
78442: NOP4
78446: NOT
78447: OR
78448: IFFALSE 78452
// exit ;
78450: GO 78685
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78452: NOP4
78456: PUSH
78457: NOP4
78461: PPUSH
78462: NOP4
78466: PPUSH
78467: NOP4
78471: PUSH
78472: NOP4
78476: ARRAY
78477: PUSH
78478: NOP4
78482: DIFF
78483: PPUSH
78484: NOP4
78488: ST_TO_ADDR
// for i = 1 to mc_bases do
78489: NOP4
78493: PUSH
78494: DOUBLE
78495: LD_INT 1
78497: DEC
78498: ST_TO_ADDR
78499: NOP4
78503: PUSH
78504: FOR_TO
78505: IFFALSE 78683
// begin if lab in mc_bases [ i ] then
78507: NOP4
78511: PUSH
78512: NOP4
78516: PUSH
78517: NOP4
78521: ARRAY
78522: IN
78523: IFFALSE 78681
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78525: NOP4
78529: PUSH
78530: LD_INT 11
78532: PUSH
78533: LD_INT 4
78535: PUSH
78536: LD_INT 3
78538: PUSH
78539: LD_INT 2
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: IN
78548: PUSH
78549: NOP4
78553: PUSH
78554: NOP4
78558: ARRAY
78559: AND
78560: IFFALSE 78681
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78562: NOP4
78566: PUSH
78567: NOP4
78571: PUSH
78572: NOP4
78576: ARRAY
78577: PUSH
78578: LD_INT 1
78580: ARRAY
78581: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78582: NOP4
78586: PUSH
78587: NOP4
78591: PPUSH
78592: NOP4
78596: PPUSH
78597: EMPTY
78598: PPUSH
78599: NOP4
78603: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78604: NOP4
78608: PPUSH
78609: LD_INT 0
78611: PPUSH
78612: NOP4
// ComExitBuilding ( tmp ) ;
78616: NOP4
78620: PPUSH
78621: NOP4
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78625: NOP4
78629: PUSH
78630: NOP4
78634: PPUSH
78635: NOP4
78639: PPUSH
78640: NOP4
78644: PUSH
78645: NOP4
78649: ARRAY
78650: PPUSH
78651: LD_INT 1
78653: PPUSH
78654: NOP4
78658: PPUSH
78659: NOP4
78663: PPUSH
78664: NOP4
78668: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78669: NOP4
78673: PPUSH
78674: LD_INT 112
78676: PPUSH
78677: NOP4
// end ; end ; end ;
78681: GO 78504
78683: POP
78684: POP
// end ;
78685: LD_VAR 0 3
78689: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78690: LD_INT 0
78692: PPUSH
78693: PPUSH
78694: PPUSH
78695: PPUSH
78696: PPUSH
78697: PPUSH
78698: PPUSH
78699: PPUSH
// if not mc_bases or not skirmish then
78700: NOP4
78704: NOT
78705: PUSH
78706: NOP4
78710: NOT
78711: OR
78712: IFFALSE 78716
// exit ;
78714: GO 80087
// for i = 1 to mc_bases do
78716: NOP4
78720: PUSH
78721: DOUBLE
78722: LD_INT 1
78724: DEC
78725: ST_TO_ADDR
78726: NOP4
78730: PUSH
78731: FOR_TO
78732: IFFALSE 80085
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78734: NOP4
78738: PUSH
78739: NOP4
78743: PUSH
78744: NOP4
78748: ARRAY
78749: IN
78750: PUSH
78751: NOP4
78755: PUSH
78756: NOP4
78760: PUSH
78761: NOP4
78765: ARRAY
78766: IN
78767: OR
78768: PUSH
78769: NOP4
78773: PUSH
78774: NOP4
78778: PUSH
78779: NOP4
78783: ARRAY
78784: IN
78785: OR
78786: PUSH
78787: NOP4
78791: PUSH
78792: NOP4
78796: PUSH
78797: NOP4
78801: ARRAY
78802: IN
78803: OR
78804: PUSH
78805: NOP4
78809: PUSH
78810: NOP4
78814: PUSH
78815: NOP4
78819: ARRAY
78820: IN
78821: OR
78822: PUSH
78823: NOP4
78827: PUSH
78828: NOP4
78832: PUSH
78833: NOP4
78837: ARRAY
78838: IN
78839: OR
78840: IFFALSE 80083
// begin if un in mc_ape [ i ] then
78842: NOP4
78846: PUSH
78847: NOP4
78851: PUSH
78852: NOP4
78856: ARRAY
78857: IN
78858: IFFALSE 78897
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78860: NOP4
78864: PUSH
78865: NOP4
78869: PPUSH
78870: NOP4
78874: PPUSH
78875: NOP4
78879: PUSH
78880: NOP4
78884: ARRAY
78885: PUSH
78886: NOP4
78890: DIFF
78891: PPUSH
78892: NOP4
78896: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78897: NOP4
78901: PUSH
78902: NOP4
78906: PUSH
78907: NOP4
78911: ARRAY
78912: IN
78913: IFFALSE 78937
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78915: NOP4
78919: PUSH
78920: NOP4
78924: PPUSH
78925: NOP4
78929: PPUSH
78930: EMPTY
78931: PPUSH
78932: NOP4
78936: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78937: NOP4
78941: PPUSH
78942: NOP4
78946: PUSH
78947: LD_INT 2
78949: EQUAL
78950: PUSH
78951: NOP4
78955: PPUSH
78956: NOP4
78960: PUSH
78961: LD_INT 20
78963: EQUAL
78964: PUSH
78965: NOP4
78969: PUSH
78970: NOP4
78974: PUSH
78975: NOP4
78979: ARRAY
78980: IN
78981: OR
78982: PUSH
78983: NOP4
78987: PPUSH
78988: NOP4
78992: PUSH
78993: LD_INT 12
78995: PUSH
78996: LD_INT 51
78998: PUSH
78999: NOP4
79003: PUSH
79004: LD_INT 32
79006: PUSH
79007: LD_INT 13
79009: PUSH
79010: LD_INT 52
79012: PUSH
79013: LD_INT 31
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: IN
79025: OR
79026: AND
79027: IFFALSE 79335
// begin if un in mc_defender [ i ] then
79029: NOP4
79033: PUSH
79034: NOP4
79038: PUSH
79039: NOP4
79043: ARRAY
79044: IN
79045: IFFALSE 79084
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79047: NOP4
79051: PUSH
79052: NOP4
79056: PPUSH
79057: NOP4
79061: PPUSH
79062: NOP4
79066: PUSH
79067: NOP4
79071: ARRAY
79072: PUSH
79073: NOP4
79077: DIFF
79078: PPUSH
79079: NOP4
79083: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79084: NOP4
79088: PUSH
79089: NOP4
79093: PPUSH
79094: LD_INT 3
79096: PPUSH
79097: NOP4
79101: ST_TO_ADDR
// if fac then
79102: NOP4
79106: IFFALSE 79335
// begin for j in fac do
79108: NOP4
79112: PUSH
79113: NOP4
79117: PUSH
79118: FOR_IN
79119: IFFALSE 79333
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79121: NOP4
79125: PUSH
79126: NOP4
79130: PPUSH
79131: NOP4
79135: PPUSH
79136: NOP4
79140: PPUSH
79141: NOP4
79145: PPUSH
79146: NOP4
79150: PPUSH
79151: NOP4
79155: PPUSH
79156: NOP4
79160: PPUSH
79161: NOP4
79165: PPUSH
79166: NOP4
79170: PPUSH
79171: NOP4
79175: ST_TO_ADDR
// if components then
79176: NOP4
79180: IFFALSE 79331
// begin if GetWeapon ( un ) = ar_control_tower then
79182: NOP4
79186: PPUSH
79187: NOP4
79191: PUSH
79192: LD_INT 31
79194: EQUAL
79195: IFFALSE 79312
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79197: NOP4
79201: PPUSH
79202: NOP4
79206: PPUSH
79207: LD_INT 0
79209: PPUSH
79210: NOP4
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79214: NOP4
79218: PUSH
79219: NOP4
79223: PPUSH
79224: NOP4
79228: PPUSH
79229: NOP4
79233: PUSH
79234: NOP4
79238: ARRAY
79239: PUSH
79240: NOP4
79244: PPUSH
79245: NOP4
79249: DIFF
79250: PPUSH
79251: NOP4
79255: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79256: NOP4
79260: PUSH
79261: NOP4
79265: PUSH
79266: NOP4
79270: ARRAY
79271: PPUSH
79272: LD_INT 1
79274: PPUSH
79275: NOP4
79279: PPUSH
79280: NOP4
79284: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79285: NOP4
79289: PUSH
79290: NOP4
79294: PPUSH
79295: NOP4
79299: PPUSH
79300: NOP4
79304: PPUSH
79305: NOP4
79309: ST_TO_ADDR
// end else
79310: GO 79329
// MC_InsertProduceList ( i , [ components ] ) ;
79312: NOP4
79316: PPUSH
79317: NOP4
79321: PUSH
79322: EMPTY
79323: LIST
79324: PPUSH
79325: NOP4
// break ;
79329: GO 79333
// end ; end ;
79331: GO 79118
79333: POP
79334: POP
// end ; end ; if GetType ( un ) = unit_building then
79335: NOP4
79339: PPUSH
79340: NOP4
79344: PUSH
79345: LD_INT 3
79347: EQUAL
79348: IFFALSE 79751
// begin btype := GetBType ( un ) ;
79350: NOP4
79354: PUSH
79355: NOP4
79359: PPUSH
79360: NOP4
79364: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79365: NOP4
79369: PUSH
79370: LD_INT 29
79372: PUSH
79373: LD_INT 30
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: IN
79380: IFFALSE 79453
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79382: NOP4
79386: PPUSH
79387: NOP4
79391: PPUSH
79392: NOP4
79396: PPUSH
79397: NOP4
79401: PPUSH
79402: NOP4
79406: PPUSH
79407: NOP4
79411: PPUSH
79412: NOP4
79416: NOT
79417: IFFALSE 79453
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79419: NOP4
79423: PPUSH
79424: NOP4
79428: PPUSH
79429: NOP4
79433: PPUSH
79434: NOP4
79438: PPUSH
79439: NOP4
79443: PPUSH
79444: NOP4
79448: PPUSH
79449: NOP4
// end ; if btype = b_warehouse then
79453: NOP4
79457: PUSH
79458: LD_INT 1
79460: EQUAL
79461: IFFALSE 79479
// begin btype := b_depot ;
79463: NOP4
79467: PUSH
79468: LD_INT 0
79470: ST_TO_ADDR
// pos := 1 ;
79471: NOP4
79475: PUSH
79476: LD_INT 1
79478: ST_TO_ADDR
// end ; if btype = b_factory then
79479: NOP4
79483: PUSH
79484: LD_INT 3
79486: EQUAL
79487: IFFALSE 79505
// begin btype := b_workshop ;
79489: NOP4
79493: PUSH
79494: LD_INT 2
79496: ST_TO_ADDR
// pos := 1 ;
79497: NOP4
79501: PUSH
79502: LD_INT 1
79504: ST_TO_ADDR
// end ; if btype = b_barracks then
79505: NOP4
79509: PUSH
79510: LD_INT 5
79512: EQUAL
79513: IFFALSE 79523
// btype := b_armoury ;
79515: NOP4
79519: PUSH
79520: LD_INT 4
79522: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79523: NOP4
79527: PUSH
79528: LD_INT 7
79530: PUSH
79531: LD_INT 8
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: IN
79538: IFFALSE 79548
// btype := b_lab ;
79540: NOP4
79544: PUSH
79545: LD_INT 6
79547: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79548: NOP4
79552: PUSH
79553: NOP4
79557: PPUSH
79558: NOP4
79562: PUSH
79563: NOP4
79567: PUSH
79568: NOP4
79572: ARRAY
79573: PUSH
79574: LD_INT 1
79576: PLUS
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PPUSH
79582: NOP4
79586: PUSH
79587: NOP4
79591: PPUSH
79592: NOP4
79596: PUSH
79597: NOP4
79601: PPUSH
79602: NOP4
79606: PUSH
79607: NOP4
79611: PPUSH
79612: NOP4
79616: PUSH
79617: EMPTY
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: PPUSH
79623: NOP4
79627: ST_TO_ADDR
// if pos = 1 then
79628: NOP4
79632: PUSH
79633: LD_INT 1
79635: EQUAL
79636: IFFALSE 79751
// begin tmp := mc_build_list [ i ] ;
79638: NOP4
79642: PUSH
79643: NOP4
79647: PUSH
79648: NOP4
79652: ARRAY
79653: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79654: NOP4
79658: PPUSH
79659: LD_INT 2
79661: PUSH
79662: LD_INT 30
79664: PUSH
79665: LD_INT 0
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: LD_INT 30
79674: PUSH
79675: LD_INT 1
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: LIST
79686: PPUSH
79687: NOP4
79691: IFFALSE 79701
// pos := 2 ;
79693: NOP4
79697: PUSH
79698: LD_INT 2
79700: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79701: NOP4
79705: PUSH
79706: NOP4
79710: PPUSH
79711: NOP4
79715: PPUSH
79716: NOP4
79720: PPUSH
79721: NOP4
79725: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79726: NOP4
79730: PUSH
79731: NOP4
79735: PPUSH
79736: NOP4
79740: PPUSH
79741: NOP4
79745: PPUSH
79746: NOP4
79750: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79751: NOP4
79755: PUSH
79756: NOP4
79760: PUSH
79761: NOP4
79765: ARRAY
79766: IN
79767: IFFALSE 79806
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79769: NOP4
79773: PUSH
79774: NOP4
79778: PPUSH
79779: NOP4
79783: PPUSH
79784: NOP4
79788: PUSH
79789: NOP4
79793: ARRAY
79794: PUSH
79795: NOP4
79799: DIFF
79800: PPUSH
79801: NOP4
79805: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79806: NOP4
79810: PUSH
79811: NOP4
79815: PUSH
79816: NOP4
79820: ARRAY
79821: IN
79822: IFFALSE 79861
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79824: NOP4
79828: PUSH
79829: NOP4
79833: PPUSH
79834: NOP4
79838: PPUSH
79839: NOP4
79843: PUSH
79844: NOP4
79848: ARRAY
79849: PUSH
79850: NOP4
79854: DIFF
79855: PPUSH
79856: NOP4
79860: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79861: NOP4
79865: PUSH
79866: NOP4
79870: PUSH
79871: NOP4
79875: ARRAY
79876: IN
79877: IFFALSE 79916
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79879: NOP4
79883: PUSH
79884: NOP4
79888: PPUSH
79889: NOP4
79893: PPUSH
79894: NOP4
79898: PUSH
79899: NOP4
79903: ARRAY
79904: PUSH
79905: NOP4
79909: DIFF
79910: PPUSH
79911: NOP4
79915: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79916: NOP4
79920: PUSH
79921: NOP4
79925: PUSH
79926: NOP4
79930: ARRAY
79931: IN
79932: IFFALSE 79971
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79934: NOP4
79938: PUSH
79939: NOP4
79943: PPUSH
79944: NOP4
79948: PPUSH
79949: NOP4
79953: PUSH
79954: NOP4
79958: ARRAY
79959: PUSH
79960: NOP4
79964: DIFF
79965: PPUSH
79966: NOP4
79970: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79971: NOP4
79975: PUSH
79976: NOP4
79980: PUSH
79981: NOP4
79985: ARRAY
79986: IN
79987: IFFALSE 80026
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
79989: NOP4
79993: PUSH
79994: NOP4
79998: PPUSH
79999: NOP4
80003: PPUSH
80004: NOP4
80008: PUSH
80009: NOP4
80013: ARRAY
80014: PUSH
80015: NOP4
80019: DIFF
80020: PPUSH
80021: NOP4
80025: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80026: NOP4
80030: PUSH
80031: NOP4
80035: PUSH
80036: NOP4
80040: ARRAY
80041: IN
80042: IFFALSE 80081
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80044: NOP4
80048: PUSH
80049: NOP4
80053: PPUSH
80054: NOP4
80058: PPUSH
80059: NOP4
80063: PUSH
80064: NOP4
80068: ARRAY
80069: PUSH
80070: NOP4
80074: DIFF
80075: PPUSH
80076: NOP4
80080: ST_TO_ADDR
// end ; break ;
80081: GO 80085
// end ;
80083: GO 78731
80085: POP
80086: POP
// end ;
80087: LD_VAR 0 2
80091: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80092: LD_INT 0
80094: PPUSH
80095: PPUSH
80096: PPUSH
// if not mc_bases or not skirmish then
80097: NOP4
80101: NOT
80102: PUSH
80103: NOP4
80107: NOT
80108: OR
80109: IFFALSE 80113
// exit ;
80111: GO 80328
// for i = 1 to mc_bases do
80113: NOP4
80117: PUSH
80118: DOUBLE
80119: LD_INT 1
80121: DEC
80122: ST_TO_ADDR
80123: NOP4
80127: PUSH
80128: FOR_TO
80129: IFFALSE 80326
// begin if building in mc_construct_list [ i ] then
80131: NOP4
80135: PUSH
80136: NOP4
80140: PUSH
80141: NOP4
80145: ARRAY
80146: IN
80147: IFFALSE 80324
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80149: NOP4
80153: PUSH
80154: NOP4
80158: PPUSH
80159: NOP4
80163: PPUSH
80164: NOP4
80168: PUSH
80169: NOP4
80173: ARRAY
80174: PUSH
80175: NOP4
80179: DIFF
80180: PPUSH
80181: NOP4
80185: ST_TO_ADDR
// if building in mc_lab [ i ] then
80186: NOP4
80190: PUSH
80191: NOP4
80195: PUSH
80196: NOP4
80200: ARRAY
80201: IN
80202: IFFALSE 80257
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80204: NOP4
80208: PUSH
80209: NOP4
80213: PPUSH
80214: NOP4
80218: PPUSH
80219: NOP4
80223: PUSH
80224: NOP4
80228: ARRAY
80229: PPUSH
80230: LD_INT 1
80232: PPUSH
80233: NOP4
80237: PUSH
80238: NOP4
80242: ARRAY
80243: PPUSH
80244: LD_INT 0
80246: PPUSH
80247: NOP4
80251: PPUSH
80252: NOP4
80256: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80257: NOP4
80261: PUSH
80262: NOP4
80266: PUSH
80267: NOP4
80271: ARRAY
80272: IN
80273: NOT
80274: IFFALSE 80320
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80276: NOP4
80280: PUSH
80281: NOP4
80285: PPUSH
80286: NOP4
80290: PUSH
80291: NOP4
80295: PUSH
80296: NOP4
80300: ARRAY
80301: PUSH
80302: LD_INT 1
80304: PLUS
80305: PUSH
80306: EMPTY
80307: LIST
80308: LIST
80309: PPUSH
80310: NOP4
80314: PPUSH
80315: NOP4
80319: ST_TO_ADDR
// exit ;
80320: POP
80321: POP
80322: GO 80328
// end ; end ;
80324: GO 80128
80326: POP
80327: POP
// end ;
80328: LD_VAR 0 2
80332: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80333: LD_INT 0
80335: PPUSH
80336: PPUSH
80337: PPUSH
80338: PPUSH
80339: PPUSH
80340: PPUSH
80341: PPUSH
// if not mc_bases or not skirmish then
80342: NOP4
80346: NOT
80347: PUSH
80348: NOP4
80352: NOT
80353: OR
80354: IFFALSE 80358
// exit ;
80356: GO 81019
// for i = 1 to mc_bases do
80358: NOP4
80362: PUSH
80363: DOUBLE
80364: LD_INT 1
80366: DEC
80367: ST_TO_ADDR
80368: NOP4
80372: PUSH
80373: FOR_TO
80374: IFFALSE 81017
// begin if building in mc_construct_list [ i ] then
80376: NOP4
80380: PUSH
80381: NOP4
80385: PUSH
80386: NOP4
80390: ARRAY
80391: IN
80392: IFFALSE 81015
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80394: NOP4
80398: PUSH
80399: NOP4
80403: PPUSH
80404: NOP4
80408: PPUSH
80409: NOP4
80413: PUSH
80414: NOP4
80418: ARRAY
80419: PUSH
80420: NOP4
80424: DIFF
80425: PPUSH
80426: NOP4
80430: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80431: NOP4
80435: PUSH
80436: NOP4
80440: PPUSH
80441: NOP4
80445: PUSH
80446: NOP4
80450: PUSH
80451: NOP4
80455: ARRAY
80456: PUSH
80457: LD_INT 1
80459: PLUS
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PPUSH
80465: NOP4
80469: PPUSH
80470: NOP4
80474: ST_TO_ADDR
// btype := GetBType ( building ) ;
80475: NOP4
80479: PUSH
80480: NOP4
80484: PPUSH
80485: NOP4
80489: ST_TO_ADDR
// side := GetSide ( building ) ;
80490: NOP4
80494: PUSH
80495: NOP4
80499: PPUSH
80500: NOP4
80504: ST_TO_ADDR
// if btype = b_lab then
80505: NOP4
80509: PUSH
80510: LD_INT 6
80512: EQUAL
80513: IFFALSE 80563
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80515: NOP4
80519: PUSH
80520: NOP4
80524: PPUSH
80525: NOP4
80529: PUSH
80530: NOP4
80534: PUSH
80535: NOP4
80539: ARRAY
80540: PUSH
80541: LD_INT 1
80543: PLUS
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PPUSH
80549: NOP4
80553: PPUSH
80554: NOP4
80558: ST_TO_ADDR
// exit ;
80559: POP
80560: POP
80561: GO 81019
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80563: NOP4
80567: PUSH
80568: LD_INT 0
80570: PUSH
80571: LD_INT 2
80573: PUSH
80574: LD_INT 4
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: LIST
80581: IN
80582: IFFALSE 80706
// begin if btype = b_armoury then
80584: NOP4
80588: PUSH
80589: LD_INT 4
80591: EQUAL
80592: IFFALSE 80602
// btype := b_barracks ;
80594: NOP4
80598: PUSH
80599: LD_INT 5
80601: ST_TO_ADDR
// if btype = b_depot then
80602: NOP4
80606: PUSH
80607: LD_INT 0
80609: EQUAL
80610: IFFALSE 80620
// btype := b_warehouse ;
80612: NOP4
80616: PUSH
80617: LD_INT 1
80619: ST_TO_ADDR
// if btype = b_workshop then
80620: NOP4
80624: PUSH
80625: LD_INT 2
80627: EQUAL
80628: IFFALSE 80638
// btype := b_factory ;
80630: NOP4
80634: PUSH
80635: LD_INT 3
80637: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80638: NOP4
80642: PPUSH
80643: NOP4
80647: PPUSH
80648: NOP4
80652: PUSH
80653: LD_INT 1
80655: EQUAL
80656: IFFALSE 80702
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80658: NOP4
80662: PUSH
80663: NOP4
80667: PPUSH
80668: NOP4
80672: PUSH
80673: NOP4
80677: PUSH
80678: NOP4
80682: ARRAY
80683: PUSH
80684: LD_INT 1
80686: PLUS
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PPUSH
80692: NOP4
80696: PPUSH
80697: NOP4
80701: ST_TO_ADDR
// exit ;
80702: POP
80703: POP
80704: GO 81019
// end ; if btype in [ b_bunker , b_turret ] then
80706: NOP4
80710: PUSH
80711: LD_INT 32
80713: PUSH
80714: LD_INT 33
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: IN
80721: IFFALSE 81011
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80723: NOP4
80727: PUSH
80728: NOP4
80732: PPUSH
80733: NOP4
80737: PUSH
80738: NOP4
80742: PUSH
80743: NOP4
80747: ARRAY
80748: PUSH
80749: LD_INT 1
80751: PLUS
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PPUSH
80757: NOP4
80761: PPUSH
80762: NOP4
80766: ST_TO_ADDR
// if btype = b_bunker then
80767: NOP4
80771: PUSH
80772: LD_INT 32
80774: EQUAL
80775: IFFALSE 81011
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80777: NOP4
80781: PUSH
80782: NOP4
80786: PPUSH
80787: NOP4
80791: PUSH
80792: NOP4
80796: PUSH
80797: NOP4
80801: ARRAY
80802: PUSH
80803: LD_INT 1
80805: PLUS
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PPUSH
80811: NOP4
80815: PPUSH
80816: NOP4
80820: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80821: NOP4
80825: PUSH
80826: NOP4
80830: PUSH
80831: NOP4
80835: ARRAY
80836: PPUSH
80837: LD_INT 25
80839: PUSH
80840: LD_INT 1
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 3
80849: PUSH
80850: LD_INT 54
80852: PUSH
80853: EMPTY
80854: LIST
80855: PUSH
80856: EMPTY
80857: LIST
80858: LIST
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PPUSH
80864: NOP4
80868: ST_TO_ADDR
// if tmp then
80869: NOP4
80873: IFFALSE 80879
// exit ;
80875: POP
80876: POP
80877: GO 81019
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80879: NOP4
80883: PUSH
80884: NOP4
80888: PUSH
80889: NOP4
80893: ARRAY
80894: PPUSH
80895: LD_INT 2
80897: PUSH
80898: LD_INT 30
80900: PUSH
80901: LD_INT 4
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 30
80910: PUSH
80911: LD_INT 5
80913: PUSH
80914: EMPTY
80915: LIST
80916: LIST
80917: PUSH
80918: EMPTY
80919: LIST
80920: LIST
80921: LIST
80922: PPUSH
80923: NOP4
80927: ST_TO_ADDR
// if not tmp then
80928: NOP4
80932: NOT
80933: IFFALSE 80939
// exit ;
80935: POP
80936: POP
80937: GO 81019
// for j in tmp do
80939: NOP4
80943: PUSH
80944: NOP4
80948: PUSH
80949: FOR_IN
80950: IFFALSE 81009
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80952: NOP4
80956: PUSH
80957: NOP4
80961: PPUSH
80962: NOP4
80966: PPUSH
80967: LD_INT 25
80969: PUSH
80970: LD_INT 1
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PPUSH
80977: NOP4
80981: ST_TO_ADDR
// if units then
80982: NOP4
80986: IFFALSE 81007
// begin ComExitBuilding ( units [ 1 ] ) ;
80988: NOP4
80992: PUSH
80993: LD_INT 1
80995: ARRAY
80996: PPUSH
80997: NOP4
// exit ;
81001: POP
81002: POP
81003: POP
81004: POP
81005: GO 81019
// end ; end ;
81007: GO 80949
81009: POP
81010: POP
// end ; end ; exit ;
81011: POP
81012: POP
81013: GO 81019
// end ; end ;
81015: GO 80373
81017: POP
81018: POP
// end ;
81019: LD_VAR 0 2
81023: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81024: LD_INT 0
81026: PPUSH
81027: PPUSH
81028: PPUSH
81029: PPUSH
81030: PPUSH
81031: PPUSH
81032: PPUSH
// if not mc_bases or not skirmish then
81033: NOP4
81037: NOT
81038: PUSH
81039: NOP4
81043: NOT
81044: OR
81045: IFFALSE 81049
// exit ;
81047: GO 81314
// btype := GetBType ( building ) ;
81049: NOP4
81053: PUSH
81054: NOP4
81058: PPUSH
81059: NOP4
81063: ST_TO_ADDR
// x := GetX ( building ) ;
81064: NOP4
81068: PUSH
81069: NOP4
81073: PPUSH
81074: NOP4
81078: ST_TO_ADDR
// y := GetY ( building ) ;
81079: NOP4
81083: PUSH
81084: NOP4
81088: PPUSH
81089: NOP4
81093: ST_TO_ADDR
// d := GetDir ( building ) ;
81094: NOP4
81098: PUSH
81099: NOP4
81103: PPUSH
81104: NOP4
81108: ST_TO_ADDR
// for i = 1 to mc_bases do
81109: NOP4
81113: PUSH
81114: DOUBLE
81115: LD_INT 1
81117: DEC
81118: ST_TO_ADDR
81119: NOP4
81123: PUSH
81124: FOR_TO
81125: IFFALSE 81312
// begin if not mc_build_list [ i ] then
81127: NOP4
81131: PUSH
81132: NOP4
81136: ARRAY
81137: NOT
81138: IFFALSE 81142
// continue ;
81140: GO 81124
// for j := 1 to mc_build_list [ i ] do
81142: NOP4
81146: PUSH
81147: DOUBLE
81148: LD_INT 1
81150: DEC
81151: ST_TO_ADDR
81152: NOP4
81156: PUSH
81157: NOP4
81161: ARRAY
81162: PUSH
81163: FOR_TO
81164: IFFALSE 81308
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81166: NOP4
81170: PUSH
81171: NOP4
81175: PUSH
81176: NOP4
81180: PUSH
81181: NOP4
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: PPUSH
81192: NOP4
81196: PUSH
81197: NOP4
81201: ARRAY
81202: PUSH
81203: NOP4
81207: ARRAY
81208: PPUSH
81209: NOP4
81213: IFFALSE 81306
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81215: NOP4
81219: PUSH
81220: NOP4
81224: PPUSH
81225: NOP4
81229: PPUSH
81230: NOP4
81234: PUSH
81235: NOP4
81239: ARRAY
81240: PPUSH
81241: NOP4
81245: PPUSH
81246: NOP4
81250: PPUSH
81251: NOP4
81255: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81256: NOP4
81260: PUSH
81261: NOP4
81265: PPUSH
81266: NOP4
81270: PUSH
81271: NOP4
81275: PUSH
81276: NOP4
81280: ARRAY
81281: PUSH
81282: LD_INT 1
81284: PLUS
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PPUSH
81290: NOP4
81294: PPUSH
81295: NOP4
81299: ST_TO_ADDR
// exit ;
81300: POP
81301: POP
81302: POP
81303: POP
81304: GO 81314
// end ;
81306: GO 81163
81308: POP
81309: POP
// end ;
81310: GO 81124
81312: POP
81313: POP
// end ;
81314: LD_VAR 0 3
81318: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81319: LD_INT 0
81321: PPUSH
81322: PPUSH
81323: PPUSH
// if not mc_bases or not skirmish then
81324: NOP4
81328: NOT
81329: PUSH
81330: NOP4
81334: NOT
81335: OR
81336: IFFALSE 81340
// exit ;
81338: GO 81530
// for i = 1 to mc_bases do
81340: NOP4
81344: PUSH
81345: DOUBLE
81346: LD_INT 1
81348: DEC
81349: ST_TO_ADDR
81350: NOP4
81354: PUSH
81355: FOR_TO
81356: IFFALSE 81443
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81358: NOP4
81362: PUSH
81363: NOP4
81367: PUSH
81368: NOP4
81372: ARRAY
81373: IN
81374: PUSH
81375: NOP4
81379: PUSH
81380: NOP4
81384: PUSH
81385: NOP4
81389: ARRAY
81390: IN
81391: NOT
81392: AND
81393: IFFALSE 81441
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81395: NOP4
81399: PUSH
81400: NOP4
81404: PPUSH
81405: NOP4
81409: PUSH
81410: NOP4
81414: PUSH
81415: NOP4
81419: ARRAY
81420: PUSH
81421: LD_INT 1
81423: PLUS
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PPUSH
81429: NOP4
81433: PPUSH
81434: NOP4
81438: ST_TO_ADDR
// break ;
81439: GO 81443
// end ; end ;
81441: GO 81355
81443: POP
81444: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81445: NOP4
81449: PPUSH
81450: NOP4
81454: PUSH
81455: NOP4
81459: IN
81460: PUSH
81461: NOP4
81465: PPUSH
81466: NOP4
81470: PUSH
81471: LD_INT 5
81473: EQUAL
81474: AND
81475: PUSH
81476: NOP4
81480: PPUSH
81481: NOP4
81485: PUSH
81486: LD_INT 18
81488: NONEQUAL
81489: AND
81490: IFFALSE 81530
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81492: NOP4
81496: PPUSH
81497: NOP4
81501: PUSH
81502: LD_INT 5
81504: PUSH
81505: LD_INT 8
81507: PUSH
81508: LD_INT 9
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: LIST
81515: IN
81516: IFFALSE 81530
// SetClass ( unit , 1 ) ;
81518: NOP4
81522: PPUSH
81523: LD_INT 1
81525: PPUSH
81526: NOP4
// end ;
81530: LD_VAR 0 3
81534: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81535: LD_INT 0
81537: PPUSH
81538: PPUSH
// if not mc_bases or not skirmish then
81539: NOP4
81543: NOT
81544: PUSH
81545: NOP4
81549: NOT
81550: OR
81551: IFFALSE 81555
// exit ;
81553: GO 81671
// if GetLives ( abandoned_vehicle ) > 250 then
81555: NOP4
81559: PPUSH
81560: NOP4
81564: PUSH
81565: LD_INT 250
81567: GREATER
81568: IFFALSE 81572
// exit ;
81570: GO 81671
// for i = 1 to mc_bases do
81572: NOP4
81576: PUSH
81577: DOUBLE
81578: LD_INT 1
81580: DEC
81581: ST_TO_ADDR
81582: NOP4
81586: PUSH
81587: FOR_TO
81588: IFFALSE 81669
// begin if driver in mc_bases [ i ] then
81590: NOP4
81594: PUSH
81595: NOP4
81599: PUSH
81600: NOP4
81604: ARRAY
81605: IN
81606: IFFALSE 81667
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81608: NOP4
81612: PPUSH
81613: NOP4
81617: PUSH
81618: NOP4
81622: ARRAY
81623: PPUSH
81624: LD_INT 2
81626: PUSH
81627: LD_INT 30
81629: PUSH
81630: LD_INT 0
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 30
81639: PUSH
81640: LD_INT 1
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: LIST
81651: PPUSH
81652: NOP4
81656: PUSH
81657: LD_INT 1
81659: ARRAY
81660: PPUSH
81661: NOP4
// break ;
81665: GO 81669
// end ; end ;
81667: GO 81587
81669: POP
81670: POP
// end ; end_of_file
81671: LD_VAR 0 5
81675: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
81676: LD_INT 0
81678: PPUSH
// ar_miner := 81 ;
81679: NOP4
81683: PUSH
81684: LD_INT 81
81686: ST_TO_ADDR
// ar_crane := 88 ;
81687: NOP4
81691: PUSH
81692: LD_INT 88
81694: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
81695: NOP4
81699: PUSH
81700: LD_INT 89
81702: ST_TO_ADDR
// us_hack := 99 ;
81703: NOP4
81707: PUSH
81708: LD_INT 99
81710: ST_TO_ADDR
// us_artillery := 97 ;
81711: NOP4
81715: PUSH
81716: LD_INT 97
81718: ST_TO_ADDR
// ar_bio_bomb := 91 ;
81719: NOP4
81723: PUSH
81724: LD_INT 91
81726: ST_TO_ADDR
// ar_mortar := 92 ;
81727: NOP4
81731: PUSH
81732: LD_INT 92
81734: ST_TO_ADDR
// ru_flamethrower := 93 ;
81735: NOP4
81739: PUSH
81740: LD_INT 93
81742: ST_TO_ADDR
// ru_radar := 98 ;
81743: NOP4
81747: PUSH
81748: LD_INT 98
81750: ST_TO_ADDR
// tech_Artillery := 80 ;
81751: NOP4
81755: PUSH
81756: LD_INT 80
81758: ST_TO_ADDR
// tech_RadMat := 81 ;
81759: NOP4
81763: PUSH
81764: LD_INT 81
81766: ST_TO_ADDR
// tech_BasicTools := 82 ;
81767: NOP4
81771: PUSH
81772: LD_INT 82
81774: ST_TO_ADDR
// tech_Cargo := 83 ;
81775: NOP4
81779: PUSH
81780: LD_INT 83
81782: ST_TO_ADDR
// tech_Track := 84 ;
81783: NOP4
81787: PUSH
81788: LD_INT 84
81790: ST_TO_ADDR
// tech_Crane := 85 ;
81791: NOP4
81795: PUSH
81796: LD_INT 85
81798: ST_TO_ADDR
// tech_Bulldozer := 86 ;
81799: NOP4
81803: PUSH
81804: LD_INT 86
81806: ST_TO_ADDR
// tech_Hovercraft := 87 ;
81807: NOP4
81811: PUSH
81812: LD_INT 87
81814: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
81815: NOP4
81819: PUSH
81820: LD_INT 88
81822: ST_TO_ADDR
// end ;
81823: LD_VAR 0 1
81827: RET
// every 1 do
81828: GO 81830
81830: DISABLE
// InitGlobalVariables ; end_of_file
81831: NOP4
81835: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81836: LD_INT 0
81838: PPUSH
81839: PPUSH
81840: PPUSH
81841: PPUSH
81842: PPUSH
81843: PPUSH
81844: PPUSH
81845: PPUSH
81846: PPUSH
81847: PPUSH
81848: PPUSH
81849: PPUSH
81850: PPUSH
81851: PPUSH
81852: PPUSH
81853: PPUSH
81854: PPUSH
81855: PPUSH
81856: PPUSH
81857: PPUSH
81858: PPUSH
81859: PPUSH
81860: PPUSH
81861: PPUSH
81862: PPUSH
81863: PPUSH
81864: PPUSH
81865: PPUSH
81866: PPUSH
81867: PPUSH
81868: PPUSH
81869: PPUSH
81870: PPUSH
81871: PPUSH
// if not list then
81872: NOP4
81876: NOT
81877: IFFALSE 81881
// exit ;
81879: GO 86540
// base := list [ 1 ] ;
81881: NOP4
81885: PUSH
81886: NOP4
81890: PUSH
81891: LD_INT 1
81893: ARRAY
81894: ST_TO_ADDR
// group := list [ 2 ] ;
81895: NOP4
81899: PUSH
81900: NOP4
81904: PUSH
81905: LD_INT 2
81907: ARRAY
81908: ST_TO_ADDR
// path := list [ 3 ] ;
81909: NOP4
81913: PUSH
81914: NOP4
81918: PUSH
81919: LD_INT 3
81921: ARRAY
81922: ST_TO_ADDR
// flags := list [ 4 ] ;
81923: NOP4
81927: PUSH
81928: NOP4
81932: PUSH
81933: LD_INT 4
81935: ARRAY
81936: ST_TO_ADDR
// mined := [ ] ;
81937: NOP4
81941: PUSH
81942: EMPTY
81943: ST_TO_ADDR
// bombed := [ ] ;
81944: NOP4
81948: PUSH
81949: EMPTY
81950: ST_TO_ADDR
// healers := [ ] ;
81951: NOP4
81955: PUSH
81956: EMPTY
81957: ST_TO_ADDR
// to_heal := [ ] ;
81958: NOP4
81962: PUSH
81963: EMPTY
81964: ST_TO_ADDR
// repairs := [ ] ;
81965: NOP4
81969: PUSH
81970: EMPTY
81971: ST_TO_ADDR
// to_repair := [ ] ;
81972: NOP4
81976: PUSH
81977: EMPTY
81978: ST_TO_ADDR
// if not group or not path then
81979: NOP4
81983: NOT
81984: PUSH
81985: NOP4
81989: NOT
81990: OR
81991: IFFALSE 81995
// exit ;
81993: GO 86540
// side := GetSide ( group [ 1 ] ) ;
81995: NOP4
81999: PUSH
82000: NOP4
82004: PUSH
82005: LD_INT 1
82007: ARRAY
82008: PPUSH
82009: NOP4
82013: ST_TO_ADDR
// if flags then
82014: NOP4
82018: IFFALSE 82162
// begin f_ignore_area := flags [ 1 ] ;
82020: NOP4
82024: PUSH
82025: NOP4
82029: PUSH
82030: LD_INT 1
82032: ARRAY
82033: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82034: NOP4
82038: PUSH
82039: NOP4
82043: PUSH
82044: LD_INT 2
82046: ARRAY
82047: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82048: NOP4
82052: PUSH
82053: NOP4
82057: PUSH
82058: LD_INT 3
82060: ARRAY
82061: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82062: NOP4
82066: PUSH
82067: NOP4
82071: PUSH
82072: LD_INT 4
82074: ARRAY
82075: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82076: NOP4
82080: PUSH
82081: NOP4
82085: PUSH
82086: LD_INT 5
82088: ARRAY
82089: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82090: NOP4
82094: PUSH
82095: NOP4
82099: PUSH
82100: LD_INT 6
82102: ARRAY
82103: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82104: NOP4
82108: PUSH
82109: NOP4
82113: PUSH
82114: LD_INT 7
82116: ARRAY
82117: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82118: NOP4
82122: PUSH
82123: NOP4
82127: PUSH
82128: LD_INT 8
82130: ARRAY
82131: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82132: NOP4
82136: PUSH
82137: NOP4
82141: PUSH
82142: LD_INT 9
82144: ARRAY
82145: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82146: NOP4
82150: PUSH
82151: NOP4
82155: PUSH
82156: LD_INT 10
82158: ARRAY
82159: ST_TO_ADDR
// end else
82160: GO 82242
// begin f_ignore_area := false ;
82162: NOP4
82166: PUSH
82167: LD_INT 0
82169: ST_TO_ADDR
// f_capture := false ;
82170: NOP4
82174: PUSH
82175: LD_INT 0
82177: ST_TO_ADDR
// f_ignore_civ := false ;
82178: NOP4
82182: PUSH
82183: LD_INT 0
82185: ST_TO_ADDR
// f_murder := false ;
82186: NOP4
82190: PUSH
82191: LD_INT 0
82193: ST_TO_ADDR
// f_mines := false ;
82194: NOP4
82198: PUSH
82199: LD_INT 0
82201: ST_TO_ADDR
// f_repair := false ;
82202: NOP4
82206: PUSH
82207: LD_INT 0
82209: ST_TO_ADDR
// f_heal := false ;
82210: NOP4
82214: PUSH
82215: LD_INT 0
82217: ST_TO_ADDR
// f_spacetime := false ;
82218: NOP4
82222: PUSH
82223: LD_INT 0
82225: ST_TO_ADDR
// f_attack_depot := false ;
82226: NOP4
82230: PUSH
82231: LD_INT 0
82233: ST_TO_ADDR
// f_crawl := false ;
82234: NOP4
82238: PUSH
82239: LD_INT 0
82241: ST_TO_ADDR
// end ; if f_heal then
82242: NOP4
82246: IFFALSE 82273
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82248: NOP4
82252: PUSH
82253: NOP4
82257: PPUSH
82258: LD_INT 25
82260: PUSH
82261: LD_INT 4
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PPUSH
82268: NOP4
82272: ST_TO_ADDR
// if f_repair then
82273: NOP4
82277: IFFALSE 82304
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82279: NOP4
82283: PUSH
82284: NOP4
82288: PPUSH
82289: LD_INT 25
82291: PUSH
82292: LD_INT 3
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PPUSH
82299: NOP4
82303: ST_TO_ADDR
// units_path := [ ] ;
82304: NOP4
82308: PUSH
82309: EMPTY
82310: ST_TO_ADDR
// for i = 1 to group do
82311: NOP4
82315: PUSH
82316: DOUBLE
82317: LD_INT 1
82319: DEC
82320: ST_TO_ADDR
82321: NOP4
82325: PUSH
82326: FOR_TO
82327: IFFALSE 82356
// units_path := Replace ( units_path , i , path ) ;
82329: NOP4
82333: PUSH
82334: NOP4
82338: PPUSH
82339: NOP4
82343: PPUSH
82344: NOP4
82348: PPUSH
82349: NOP4
82353: ST_TO_ADDR
82354: GO 82326
82356: POP
82357: POP
// repeat for i = group downto 1 do
82358: NOP4
82362: PUSH
82363: DOUBLE
82364: NOP4
82368: INC
82369: ST_TO_ADDR
82370: LD_INT 1
82372: PUSH
82373: FOR_DOWNTO
82374: IFFALSE 86496
// begin wait ( 5 ) ;
82376: LD_INT 5
82378: PPUSH
82379: NOP4
// tmp := [ ] ;
82383: NOP4
82387: PUSH
82388: EMPTY
82389: ST_TO_ADDR
// attacking := false ;
82390: NOP4
82394: PUSH
82395: LD_INT 0
82397: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82398: NOP4
82402: PUSH
82403: NOP4
82407: ARRAY
82408: PPUSH
82409: NOP4
82413: PUSH
82414: NOP4
82418: PUSH
82419: NOP4
82423: ARRAY
82424: NOT
82425: OR
82426: IFFALSE 82535
// begin if GetType ( group [ i ] ) = unit_human then
82428: NOP4
82432: PUSH
82433: NOP4
82437: ARRAY
82438: PPUSH
82439: NOP4
82443: PUSH
82444: LD_INT 1
82446: EQUAL
82447: IFFALSE 82493
// begin to_heal := to_heal diff group [ i ] ;
82449: NOP4
82453: PUSH
82454: NOP4
82458: PUSH
82459: NOP4
82463: PUSH
82464: NOP4
82468: ARRAY
82469: DIFF
82470: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82471: NOP4
82475: PUSH
82476: NOP4
82480: PUSH
82481: NOP4
82485: PUSH
82486: NOP4
82490: ARRAY
82491: DIFF
82492: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82493: NOP4
82497: PUSH
82498: NOP4
82502: PPUSH
82503: NOP4
82507: PPUSH
82508: NOP4
82512: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82513: NOP4
82517: PUSH
82518: NOP4
82522: PPUSH
82523: NOP4
82527: PPUSH
82528: NOP4
82532: ST_TO_ADDR
// continue ;
82533: GO 82373
// end ; if f_repair then
82535: NOP4
82539: IFFALSE 83028
// begin if GetType ( group [ i ] ) = unit_vehicle then
82541: NOP4
82545: PUSH
82546: NOP4
82550: ARRAY
82551: PPUSH
82552: NOP4
82556: PUSH
82557: LD_INT 2
82559: EQUAL
82560: IFFALSE 82750
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82562: NOP4
82566: PUSH
82567: NOP4
82571: ARRAY
82572: PPUSH
82573: NOP4
82577: PUSH
82578: LD_INT 700
82580: LESS
82581: PUSH
82582: NOP4
82586: PUSH
82587: NOP4
82591: ARRAY
82592: PUSH
82593: NOP4
82597: IN
82598: NOT
82599: AND
82600: IFFALSE 82624
// to_repair := to_repair union group [ i ] ;
82602: NOP4
82606: PUSH
82607: NOP4
82611: PUSH
82612: NOP4
82616: PUSH
82617: NOP4
82621: ARRAY
82622: UNION
82623: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82624: NOP4
82628: PUSH
82629: NOP4
82633: ARRAY
82634: PPUSH
82635: NOP4
82639: PUSH
82640: LD_INT 1000
82642: EQUAL
82643: PUSH
82644: NOP4
82648: PUSH
82649: NOP4
82653: ARRAY
82654: PUSH
82655: NOP4
82659: IN
82660: AND
82661: IFFALSE 82685
// to_repair := to_repair diff group [ i ] ;
82663: NOP4
82667: PUSH
82668: NOP4
82672: PUSH
82673: NOP4
82677: PUSH
82678: NOP4
82682: ARRAY
82683: DIFF
82684: ST_TO_ADDR
// if group [ i ] in to_repair then
82685: NOP4
82689: PUSH
82690: NOP4
82694: ARRAY
82695: PUSH
82696: NOP4
82700: IN
82701: IFFALSE 82748
// begin if not IsInArea ( group [ i ] , f_repair ) then
82703: NOP4
82707: PUSH
82708: NOP4
82712: ARRAY
82713: PPUSH
82714: NOP4
82718: PPUSH
82719: NOP4
82723: NOT
82724: IFFALSE 82746
// ComMoveToArea ( group [ i ] , f_repair ) ;
82726: NOP4
82730: PUSH
82731: NOP4
82735: ARRAY
82736: PPUSH
82737: NOP4
82741: PPUSH
82742: NOP4
// continue ;
82746: GO 82373
// end ; end else
82748: GO 83028
// if group [ i ] in repairs then
82750: NOP4
82754: PUSH
82755: NOP4
82759: ARRAY
82760: PUSH
82761: NOP4
82765: IN
82766: IFFALSE 83028
// begin if IsInUnit ( group [ i ] ) then
82768: NOP4
82772: PUSH
82773: NOP4
82777: ARRAY
82778: PPUSH
82779: NOP4
82783: IFFALSE 82851
// begin z := IsInUnit ( group [ i ] ) ;
82785: NOP4
82789: PUSH
82790: NOP4
82794: PUSH
82795: NOP4
82799: ARRAY
82800: PPUSH
82801: NOP4
82805: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82806: NOP4
82810: PUSH
82811: NOP4
82815: IN
82816: PUSH
82817: NOP4
82821: PPUSH
82822: NOP4
82826: PPUSH
82827: NOP4
82831: AND
82832: IFFALSE 82849
// ComExitVehicle ( group [ i ] ) ;
82834: NOP4
82838: PUSH
82839: NOP4
82843: ARRAY
82844: PPUSH
82845: NOP4
// end else
82849: GO 83028
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82851: NOP4
82855: PUSH
82856: NOP4
82860: PPUSH
82861: LD_INT 95
82863: PUSH
82864: NOP4
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PUSH
82873: LD_INT 58
82875: PUSH
82876: EMPTY
82877: LIST
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: PPUSH
82883: NOP4
82887: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
82888: NOP4
82892: PUSH
82893: NOP4
82897: ARRAY
82898: PPUSH
82899: NOP4
82903: NOT
82904: IFFALSE 83026
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
82906: NOP4
82910: PUSH
82911: NOP4
82915: PPUSH
82916: NOP4
82920: PUSH
82921: NOP4
82925: ARRAY
82926: PPUSH
82927: NOP4
82931: ST_TO_ADDR
// if not x then
82932: NOP4
82936: NOT
82937: IFFALSE 82941
// continue ;
82939: GO 82373
// if GetLives ( x ) < 1000 then
82941: NOP4
82945: PPUSH
82946: NOP4
82950: PUSH
82951: LD_INT 1000
82953: LESS
82954: IFFALSE 82978
// ComRepairVehicle ( group [ i ] , x ) else
82956: NOP4
82960: PUSH
82961: NOP4
82965: ARRAY
82966: PPUSH
82967: NOP4
82971: PPUSH
82972: NOP4
82976: GO 83026
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
82978: NOP4
82982: PUSH
82983: NOP4
82987: PUSH
82988: NOP4
82992: ARRAY
82993: PPUSH
82994: NOP4
82998: PUSH
82999: LD_INT 1000
83001: LESS
83002: AND
83003: NOT
83004: IFFALSE 83026
// ComEnterUnit ( group [ i ] , x ) ;
83006: NOP4
83010: PUSH
83011: NOP4
83015: ARRAY
83016: PPUSH
83017: NOP4
83021: PPUSH
83022: NOP4
// end ; continue ;
83026: GO 82373
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83028: NOP4
83032: PUSH
83033: NOP4
83037: PUSH
83038: NOP4
83042: ARRAY
83043: PPUSH
83044: NOP4
83048: PUSH
83049: LD_INT 1
83051: EQUAL
83052: AND
83053: IFFALSE 83531
// begin if group [ i ] in healers then
83055: NOP4
83059: PUSH
83060: NOP4
83064: ARRAY
83065: PUSH
83066: NOP4
83070: IN
83071: IFFALSE 83344
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83073: NOP4
83077: PUSH
83078: NOP4
83082: ARRAY
83083: PPUSH
83084: NOP4
83088: PPUSH
83089: NOP4
83093: NOT
83094: PUSH
83095: NOP4
83099: PUSH
83100: NOP4
83104: ARRAY
83105: PPUSH
83106: NOP4
83110: NOT
83111: AND
83112: IFFALSE 83136
// ComMoveToArea ( group [ i ] , f_heal ) else
83114: NOP4
83118: PUSH
83119: NOP4
83123: ARRAY
83124: PPUSH
83125: NOP4
83129: PPUSH
83130: NOP4
83134: GO 83342
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83136: NOP4
83140: PUSH
83141: NOP4
83145: ARRAY
83146: PPUSH
83147: NOP4
83151: PPUSH
83152: NOP4
83156: PUSH
83157: LD_INT 1000
83159: EQUAL
83160: IFFALSE 83179
// ComStop ( group [ i ] ) else
83162: NOP4
83166: PUSH
83167: NOP4
83171: ARRAY
83172: PPUSH
83173: NOP4
83177: GO 83342
// if not HasTask ( group [ i ] ) and to_heal then
83179: NOP4
83183: PUSH
83184: NOP4
83188: ARRAY
83189: PPUSH
83190: NOP4
83194: NOT
83195: PUSH
83196: NOP4
83200: AND
83201: IFFALSE 83342
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83203: NOP4
83207: PUSH
83208: NOP4
83212: PPUSH
83213: LD_INT 3
83215: PUSH
83216: LD_INT 54
83218: PUSH
83219: EMPTY
83220: LIST
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PPUSH
83226: NOP4
83230: PPUSH
83231: NOP4
83235: PUSH
83236: NOP4
83240: ARRAY
83241: PPUSH
83242: NOP4
83246: ST_TO_ADDR
// if z then
83247: NOP4
83251: IFFALSE 83342
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83253: LD_INT 91
83255: PUSH
83256: NOP4
83260: PUSH
83261: LD_INT 10
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: LIST
83268: PUSH
83269: LD_INT 81
83271: PUSH
83272: NOP4
83276: PPUSH
83277: NOP4
83281: PUSH
83282: EMPTY
83283: LIST
83284: LIST
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PPUSH
83290: NOP4
83294: PUSH
83295: LD_INT 0
83297: EQUAL
83298: IFFALSE 83322
// ComHeal ( group [ i ] , z ) else
83300: NOP4
83304: PUSH
83305: NOP4
83309: ARRAY
83310: PPUSH
83311: NOP4
83315: PPUSH
83316: NOP4
83320: GO 83342
// ComMoveToArea ( group [ i ] , f_heal ) ;
83322: NOP4
83326: PUSH
83327: NOP4
83331: ARRAY
83332: PPUSH
83333: NOP4
83337: PPUSH
83338: NOP4
// end ; continue ;
83342: GO 82373
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83344: NOP4
83348: PUSH
83349: NOP4
83353: ARRAY
83354: PPUSH
83355: NOP4
83359: PUSH
83360: LD_INT 700
83362: LESS
83363: PUSH
83364: NOP4
83368: PUSH
83369: NOP4
83373: ARRAY
83374: PUSH
83375: NOP4
83379: IN
83380: NOT
83381: AND
83382: IFFALSE 83406
// to_heal := to_heal union group [ i ] ;
83384: NOP4
83388: PUSH
83389: NOP4
83393: PUSH
83394: NOP4
83398: PUSH
83399: NOP4
83403: ARRAY
83404: UNION
83405: ST_TO_ADDR
// if group [ i ] in to_heal then
83406: NOP4
83410: PUSH
83411: NOP4
83415: ARRAY
83416: PUSH
83417: NOP4
83421: IN
83422: IFFALSE 83531
// begin if GetLives ( group [ i ] ) = 1000 then
83424: NOP4
83428: PUSH
83429: NOP4
83433: ARRAY
83434: PPUSH
83435: NOP4
83439: PUSH
83440: LD_INT 1000
83442: EQUAL
83443: IFFALSE 83469
// to_heal := to_heal diff group [ i ] else
83445: NOP4
83449: PUSH
83450: NOP4
83454: PUSH
83455: NOP4
83459: PUSH
83460: NOP4
83464: ARRAY
83465: DIFF
83466: ST_TO_ADDR
83467: GO 83531
// begin if not IsInArea ( group [ i ] , to_heal ) then
83469: NOP4
83473: PUSH
83474: NOP4
83478: ARRAY
83479: PPUSH
83480: NOP4
83484: PPUSH
83485: NOP4
83489: NOT
83490: IFFALSE 83514
// ComMoveToArea ( group [ i ] , f_heal ) else
83492: NOP4
83496: PUSH
83497: NOP4
83501: ARRAY
83502: PPUSH
83503: NOP4
83507: PPUSH
83508: NOP4
83512: GO 83529
// ComHold ( group [ i ] ) ;
83514: NOP4
83518: PUSH
83519: NOP4
83523: ARRAY
83524: PPUSH
83525: NOP4
// continue ;
83529: GO 82373
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83531: NOP4
83535: PUSH
83536: NOP4
83540: ARRAY
83541: PPUSH
83542: LD_INT 10
83544: PPUSH
83545: NOP4
83549: NOT
83550: PUSH
83551: NOP4
83555: PUSH
83556: NOP4
83560: ARRAY
83561: PUSH
83562: EMPTY
83563: EQUAL
83564: NOT
83565: AND
83566: IFFALSE 83832
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83568: NOP4
83572: PUSH
83573: NOP4
83577: ARRAY
83578: PPUSH
83579: NOP4
83583: PUSH
83584: LD_INT 1
83586: PUSH
83587: LD_INT 2
83589: PUSH
83590: EMPTY
83591: LIST
83592: LIST
83593: IN
83594: IFFALSE 83635
// if GetFuel ( group [ i ] ) < 10 then
83596: NOP4
83600: PUSH
83601: NOP4
83605: ARRAY
83606: PPUSH
83607: NOP4
83611: PUSH
83612: LD_INT 10
83614: LESS
83615: IFFALSE 83635
// SetFuel ( group [ i ] , 12 ) ;
83617: NOP4
83621: PUSH
83622: NOP4
83626: ARRAY
83627: PPUSH
83628: LD_INT 12
83630: PPUSH
83631: NOP4
// if units_path [ i ] then
83635: NOP4
83639: PUSH
83640: NOP4
83644: ARRAY
83645: IFFALSE 83830
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83647: NOP4
83651: PUSH
83652: NOP4
83656: ARRAY
83657: PPUSH
83658: NOP4
83662: PUSH
83663: NOP4
83667: ARRAY
83668: PUSH
83669: LD_INT 1
83671: ARRAY
83672: PUSH
83673: LD_INT 1
83675: ARRAY
83676: PPUSH
83677: NOP4
83681: PUSH
83682: NOP4
83686: ARRAY
83687: PUSH
83688: LD_INT 1
83690: ARRAY
83691: PUSH
83692: LD_INT 2
83694: ARRAY
83695: PPUSH
83696: NOP4
83700: PUSH
83701: LD_INT 6
83703: GREATER
83704: IFFALSE 83779
// begin if not HasTask ( group [ i ] ) then
83706: NOP4
83710: PUSH
83711: NOP4
83715: ARRAY
83716: PPUSH
83717: NOP4
83721: NOT
83722: IFFALSE 83777
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83724: NOP4
83728: PUSH
83729: NOP4
83733: ARRAY
83734: PPUSH
83735: NOP4
83739: PUSH
83740: NOP4
83744: ARRAY
83745: PUSH
83746: LD_INT 1
83748: ARRAY
83749: PUSH
83750: LD_INT 1
83752: ARRAY
83753: PPUSH
83754: NOP4
83758: PUSH
83759: NOP4
83763: ARRAY
83764: PUSH
83765: LD_INT 1
83767: ARRAY
83768: PUSH
83769: LD_INT 2
83771: ARRAY
83772: PPUSH
83773: NOP4
// end else
83777: GO 83830
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83779: NOP4
83783: PUSH
83784: NOP4
83788: PUSH
83789: NOP4
83793: ARRAY
83794: PPUSH
83795: LD_INT 1
83797: PPUSH
83798: NOP4
83802: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83803: NOP4
83807: PUSH
83808: NOP4
83812: PPUSH
83813: NOP4
83817: PPUSH
83818: NOP4
83822: PPUSH
83823: NOP4
83827: ST_TO_ADDR
// continue ;
83828: GO 82373
// end ; end ; end else
83830: GO 86494
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83832: NOP4
83836: PUSH
83837: LD_INT 81
83839: PUSH
83840: NOP4
83844: PUSH
83845: NOP4
83849: ARRAY
83850: PPUSH
83851: NOP4
83855: PUSH
83856: EMPTY
83857: LIST
83858: LIST
83859: PPUSH
83860: NOP4
83864: ST_TO_ADDR
// if not tmp then
83865: NOP4
83869: NOT
83870: IFFALSE 83874
// continue ;
83872: GO 82373
// if f_ignore_area then
83874: NOP4
83878: IFFALSE 83966
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
83880: NOP4
83884: PUSH
83885: NOP4
83889: PPUSH
83890: LD_INT 3
83892: PUSH
83893: LD_INT 92
83895: PUSH
83896: NOP4
83900: PUSH
83901: LD_INT 1
83903: ARRAY
83904: PUSH
83905: NOP4
83909: PUSH
83910: LD_INT 2
83912: ARRAY
83913: PUSH
83914: NOP4
83918: PUSH
83919: LD_INT 3
83921: ARRAY
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PPUSH
83933: NOP4
83937: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83938: NOP4
83942: PUSH
83943: NOP4
83947: DIFF
83948: IFFALSE 83966
// tmp := tmp diff tmp2 ;
83950: NOP4
83954: PUSH
83955: NOP4
83959: PUSH
83960: NOP4
83964: DIFF
83965: ST_TO_ADDR
// end ; if not f_murder then
83966: NOP4
83970: NOT
83971: IFFALSE 84029
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
83973: NOP4
83977: PUSH
83978: NOP4
83982: PPUSH
83983: LD_INT 3
83985: PUSH
83986: LD_INT 50
83988: PUSH
83989: EMPTY
83990: LIST
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PPUSH
83996: NOP4
84000: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84001: NOP4
84005: PUSH
84006: NOP4
84010: DIFF
84011: IFFALSE 84029
// tmp := tmp diff tmp2 ;
84013: NOP4
84017: PUSH
84018: NOP4
84022: PUSH
84023: NOP4
84027: DIFF
84028: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84029: NOP4
84033: PUSH
84034: NOP4
84038: PUSH
84039: NOP4
84043: ARRAY
84044: PPUSH
84045: NOP4
84049: PPUSH
84050: LD_INT 1
84052: PPUSH
84053: LD_INT 1
84055: PPUSH
84056: NOP4
84060: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84061: NOP4
84065: PUSH
84066: NOP4
84070: ARRAY
84071: PPUSH
84072: NOP4
84076: PUSH
84077: LD_INT 1
84079: EQUAL
84080: IFFALSE 84528
// begin if WantPlant ( group [ i ] ) then
84082: NOP4
84086: PUSH
84087: NOP4
84091: ARRAY
84092: PPUSH
84093: NOP4
84097: IFFALSE 84101
// continue ;
84099: GO 82373
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84101: NOP4
84105: PUSH
84106: NOP4
84110: PUSH
84111: NOP4
84115: ARRAY
84116: PPUSH
84117: NOP4
84121: NOT
84122: AND
84123: PUSH
84124: NOP4
84128: PUSH
84129: LD_INT 1
84131: ARRAY
84132: PUSH
84133: NOP4
84137: PPUSH
84138: LD_INT 21
84140: PUSH
84141: LD_INT 2
84143: PUSH
84144: EMPTY
84145: LIST
84146: LIST
84147: PUSH
84148: LD_INT 58
84150: PUSH
84151: EMPTY
84152: LIST
84153: PUSH
84154: EMPTY
84155: LIST
84156: LIST
84157: PPUSH
84158: NOP4
84162: IN
84163: AND
84164: IFFALSE 84200
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84166: NOP4
84170: PUSH
84171: NOP4
84175: ARRAY
84176: PPUSH
84177: NOP4
84181: PUSH
84182: LD_INT 1
84184: ARRAY
84185: PPUSH
84186: NOP4
// attacking := true ;
84190: NOP4
84194: PUSH
84195: LD_INT 1
84197: ST_TO_ADDR
// continue ;
84198: GO 82373
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84200: NOP4
84204: PUSH
84205: NOP4
84209: PUSH
84210: NOP4
84214: ARRAY
84215: PPUSH
84216: NOP4
84220: PUSH
84221: LD_INT 1
84223: EQUAL
84224: AND
84225: PUSH
84226: NOP4
84230: PUSH
84231: NOP4
84235: ARRAY
84236: PPUSH
84237: NOP4
84241: PUSH
84242: LD_INT 800
84244: LESS
84245: AND
84246: PUSH
84247: NOP4
84251: PUSH
84252: NOP4
84256: ARRAY
84257: PPUSH
84258: NOP4
84262: NOT
84263: AND
84264: IFFALSE 84281
// ComCrawl ( group [ i ] ) ;
84266: NOP4
84270: PUSH
84271: NOP4
84275: ARRAY
84276: PPUSH
84277: NOP4
// if f_mines then
84281: NOP4
84285: IFFALSE 84528
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84287: NOP4
84291: PUSH
84292: LD_INT 1
84294: ARRAY
84295: PPUSH
84296: NOP4
84300: PUSH
84301: LD_INT 3
84303: EQUAL
84304: PUSH
84305: NOP4
84309: PUSH
84310: LD_INT 1
84312: ARRAY
84313: PUSH
84314: NOP4
84318: IN
84319: NOT
84320: AND
84321: IFFALSE 84528
// begin x := GetX ( tmp [ 1 ] ) ;
84323: NOP4
84327: PUSH
84328: NOP4
84332: PUSH
84333: LD_INT 1
84335: ARRAY
84336: PPUSH
84337: NOP4
84341: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84342: NOP4
84346: PUSH
84347: NOP4
84351: PUSH
84352: LD_INT 1
84354: ARRAY
84355: PPUSH
84356: NOP4
84360: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84361: NOP4
84365: PUSH
84366: NOP4
84370: PUSH
84371: NOP4
84375: ARRAY
84376: PPUSH
84377: NOP4
84381: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84382: NOP4
84386: PUSH
84387: NOP4
84391: ARRAY
84392: PPUSH
84393: NOP4
84397: PPUSH
84398: NOP4
84402: PPUSH
84403: NOP4
84407: PUSH
84408: LD_INT 1
84410: ARRAY
84411: PPUSH
84412: NOP4
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84416: NOP4
84420: PUSH
84421: NOP4
84425: ARRAY
84426: PPUSH
84427: NOP4
84431: PPUSH
84432: NOP4
84436: PPUSH
84437: LD_INT 7
84439: PPUSH
84440: NOP4
84444: PPUSH
84445: NOP4
84449: PPUSH
84450: NOP4
84454: PPUSH
84455: LD_INT 7
84457: PPUSH
84458: NOP4
84462: PPUSH
84463: NOP4
// SetTag ( group [ i ] , 71 ) ;
84467: NOP4
84471: PUSH
84472: NOP4
84476: ARRAY
84477: PPUSH
84478: LD_INT 71
84480: PPUSH
84481: NOP4
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84485: NOP4
84489: PUSH
84490: NOP4
84494: PPUSH
84495: NOP4
84499: PUSH
84500: LD_INT 1
84502: PLUS
84503: PPUSH
84504: NOP4
84508: PUSH
84509: LD_INT 1
84511: ARRAY
84512: PPUSH
84513: NOP4
84517: ST_TO_ADDR
// attacking := true ;
84518: NOP4
84522: PUSH
84523: LD_INT 1
84525: ST_TO_ADDR
// continue ;
84526: GO 82373
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84528: NOP4
84532: PUSH
84533: NOP4
84537: ARRAY
84538: PPUSH
84539: NOP4
84543: PUSH
84544: LD_INT 17
84546: EQUAL
84547: PUSH
84548: NOP4
84552: PUSH
84553: NOP4
84557: ARRAY
84558: PPUSH
84559: NOP4
84563: PUSH
84564: LD_INT 71
84566: EQUAL
84567: NOT
84568: AND
84569: IFFALSE 84715
// begin attacking := false ;
84571: NOP4
84575: PUSH
84576: LD_INT 0
84578: ST_TO_ADDR
// k := 5 ;
84579: NOP4
84583: PUSH
84584: LD_INT 5
84586: ST_TO_ADDR
// if tmp < k then
84587: NOP4
84591: PUSH
84592: NOP4
84596: LESS
84597: IFFALSE 84609
// k := tmp ;
84599: NOP4
84603: PUSH
84604: NOP4
84608: ST_TO_ADDR
// for j = 1 to k do
84609: NOP4
84613: PUSH
84614: DOUBLE
84615: LD_INT 1
84617: DEC
84618: ST_TO_ADDR
84619: NOP4
84623: PUSH
84624: FOR_TO
84625: IFFALSE 84713
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84627: NOP4
84631: PUSH
84632: NOP4
84636: ARRAY
84637: PUSH
84638: NOP4
84642: PPUSH
84643: LD_INT 58
84645: PUSH
84646: EMPTY
84647: LIST
84648: PPUSH
84649: NOP4
84653: IN
84654: NOT
84655: IFFALSE 84711
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84657: NOP4
84661: PUSH
84662: NOP4
84666: ARRAY
84667: PPUSH
84668: NOP4
84672: PUSH
84673: NOP4
84677: ARRAY
84678: PPUSH
84679: NOP4
// attacking := true ;
84683: NOP4
84687: PUSH
84688: LD_INT 1
84690: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84691: NOP4
84695: PUSH
84696: NOP4
84700: ARRAY
84701: PPUSH
84702: LD_INT 71
84704: PPUSH
84705: NOP4
// continue ;
84709: GO 84624
// end ; end ;
84711: GO 84624
84713: POP
84714: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84715: NOP4
84719: PUSH
84720: NOP4
84724: ARRAY
84725: PPUSH
84726: NOP4
84730: PUSH
84731: LD_INT 8
84733: EQUAL
84734: PUSH
84735: NOP4
84739: PUSH
84740: NOP4
84744: ARRAY
84745: PPUSH
84746: NOP4
84750: PUSH
84751: LD_INT 28
84753: PUSH
84754: LD_INT 45
84756: PUSH
84757: LD_INT 7
84759: PUSH
84760: LD_INT 47
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: IN
84769: OR
84770: IFFALSE 85026
// begin attacking := false ;
84772: NOP4
84776: PUSH
84777: LD_INT 0
84779: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84780: NOP4
84784: PUSH
84785: LD_INT 1
84787: ARRAY
84788: PPUSH
84789: NOP4
84793: PUSH
84794: LD_INT 32
84796: PUSH
84797: LD_INT 31
84799: PUSH
84800: LD_INT 33
84802: PUSH
84803: LD_INT 4
84805: PUSH
84806: LD_INT 5
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: LIST
84813: LIST
84814: LIST
84815: IN
84816: IFFALSE 85002
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84818: NOP4
84822: PUSH
84823: NOP4
84827: PUSH
84828: LD_INT 1
84830: ARRAY
84831: PPUSH
84832: NOP4
84836: PPUSH
84837: NOP4
84841: PUSH
84842: LD_INT 1
84844: ARRAY
84845: PPUSH
84846: NOP4
84850: PPUSH
84851: NOP4
84855: PUSH
84856: LD_INT 1
84858: ARRAY
84859: PPUSH
84860: NOP4
84864: PPUSH
84865: NOP4
84869: PUSH
84870: LD_INT 1
84872: ARRAY
84873: PPUSH
84874: NOP4
84878: PPUSH
84879: NOP4
84883: PUSH
84884: LD_INT 1
84886: ARRAY
84887: PPUSH
84888: NOP4
84892: PPUSH
84893: LD_INT 0
84895: PPUSH
84896: NOP4
84900: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
84901: NOP4
84905: PUSH
84906: NOP4
84910: PUSH
84911: NOP4
84915: ARRAY
84916: PPUSH
84917: NOP4
84921: PPUSH
84922: NOP4
84926: ST_TO_ADDR
// if j then
84927: NOP4
84931: IFFALSE 85000
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
84933: NOP4
84937: PUSH
84938: LD_INT 1
84940: ARRAY
84941: PPUSH
84942: NOP4
84946: PUSH
84947: LD_INT 2
84949: ARRAY
84950: PPUSH
84951: NOP4
84955: IFFALSE 85000
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
84957: NOP4
84961: PUSH
84962: NOP4
84966: ARRAY
84967: PPUSH
84968: NOP4
84972: PUSH
84973: LD_INT 1
84975: ARRAY
84976: PPUSH
84977: NOP4
84981: PUSH
84982: LD_INT 2
84984: ARRAY
84985: PPUSH
84986: NOP4
// attacking := true ;
84990: NOP4
84994: PUSH
84995: LD_INT 1
84997: ST_TO_ADDR
// continue ;
84998: GO 82373
// end ; end else
85000: GO 85026
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85002: NOP4
85006: PUSH
85007: NOP4
85011: ARRAY
85012: PPUSH
85013: NOP4
85017: PUSH
85018: LD_INT 1
85020: ARRAY
85021: PPUSH
85022: NOP4
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85026: NOP4
85030: PUSH
85031: NOP4
85035: ARRAY
85036: PPUSH
85037: NOP4
85041: PUSH
85042: LD_INT 11
85044: EQUAL
85045: IFFALSE 85323
// begin k := 10 ;
85047: NOP4
85051: PUSH
85052: LD_INT 10
85054: ST_TO_ADDR
// x := 0 ;
85055: NOP4
85059: PUSH
85060: LD_INT 0
85062: ST_TO_ADDR
// if tmp < k then
85063: NOP4
85067: PUSH
85068: NOP4
85072: LESS
85073: IFFALSE 85085
// k := tmp ;
85075: NOP4
85079: PUSH
85080: NOP4
85084: ST_TO_ADDR
// for j = k downto 1 do
85085: NOP4
85089: PUSH
85090: DOUBLE
85091: NOP4
85095: INC
85096: ST_TO_ADDR
85097: LD_INT 1
85099: PUSH
85100: FOR_DOWNTO
85101: IFFALSE 85176
// begin if GetType ( tmp [ j ] ) = unit_human then
85103: NOP4
85107: PUSH
85108: NOP4
85112: ARRAY
85113: PPUSH
85114: NOP4
85118: PUSH
85119: LD_INT 1
85121: EQUAL
85122: IFFALSE 85174
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85124: NOP4
85128: PUSH
85129: NOP4
85133: ARRAY
85134: PPUSH
85135: NOP4
85139: PUSH
85140: NOP4
85144: ARRAY
85145: PPUSH
85146: NOP4
// x := tmp [ j ] ;
85150: NOP4
85154: PUSH
85155: NOP4
85159: PUSH
85160: NOP4
85164: ARRAY
85165: ST_TO_ADDR
// attacking := true ;
85166: NOP4
85170: PUSH
85171: LD_INT 1
85173: ST_TO_ADDR
// end ; end ;
85174: GO 85100
85176: POP
85177: POP
// if not x then
85178: NOP4
85182: NOT
85183: IFFALSE 85323
// begin attacking := true ;
85185: NOP4
85189: PUSH
85190: LD_INT 1
85192: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85193: NOP4
85197: PUSH
85198: NOP4
85202: ARRAY
85203: PPUSH
85204: NOP4
85208: PPUSH
85209: NOP4
85213: PUSH
85214: NOP4
85218: ARRAY
85219: PPUSH
85220: NOP4
85224: PPUSH
85225: NOP4
85229: PUSH
85230: LD_INT 2
85232: ARRAY
85233: PUSH
85234: NOP4
85238: PUSH
85239: LD_INT 1
85241: ARRAY
85242: PPUSH
85243: NOP4
85247: PPUSH
85248: NOP4
85252: PUSH
85253: LD_INT 1
85255: ARRAY
85256: PPUSH
85257: NOP4
85261: PPUSH
85262: NOP4
85266: PUSH
85267: LD_INT 2
85269: ARRAY
85270: EQUAL
85271: IFFALSE 85299
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85273: NOP4
85277: PUSH
85278: NOP4
85282: ARRAY
85283: PPUSH
85284: NOP4
85288: PUSH
85289: LD_INT 1
85291: ARRAY
85292: PPUSH
85293: NOP4
85297: GO 85323
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85299: NOP4
85303: PUSH
85304: NOP4
85308: ARRAY
85309: PPUSH
85310: NOP4
85314: PUSH
85315: LD_INT 1
85317: ARRAY
85318: PPUSH
85319: NOP4
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85323: NOP4
85327: PUSH
85328: NOP4
85332: ARRAY
85333: PPUSH
85334: NOP4
85338: PUSH
85339: LD_INT 29
85341: EQUAL
85342: IFFALSE 85708
// begin if WantsToAttack ( group [ i ] ) in bombed then
85344: NOP4
85348: PUSH
85349: NOP4
85353: ARRAY
85354: PPUSH
85355: NOP4
85359: PUSH
85360: NOP4
85364: IN
85365: IFFALSE 85369
// continue ;
85367: GO 82373
// k := 8 ;
85369: NOP4
85373: PUSH
85374: LD_INT 8
85376: ST_TO_ADDR
// x := 0 ;
85377: NOP4
85381: PUSH
85382: LD_INT 0
85384: ST_TO_ADDR
// if tmp < k then
85385: NOP4
85389: PUSH
85390: NOP4
85394: LESS
85395: IFFALSE 85407
// k := tmp ;
85397: NOP4
85401: PUSH
85402: NOP4
85406: ST_TO_ADDR
// for j = 1 to k do
85407: NOP4
85411: PUSH
85412: DOUBLE
85413: LD_INT 1
85415: DEC
85416: ST_TO_ADDR
85417: NOP4
85421: PUSH
85422: FOR_TO
85423: IFFALSE 85555
// begin if GetType ( tmp [ j ] ) = unit_building then
85425: NOP4
85429: PUSH
85430: NOP4
85434: ARRAY
85435: PPUSH
85436: NOP4
85440: PUSH
85441: LD_INT 3
85443: EQUAL
85444: IFFALSE 85553
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85446: NOP4
85450: PUSH
85451: NOP4
85455: ARRAY
85456: PUSH
85457: NOP4
85461: IN
85462: NOT
85463: PUSH
85464: NOP4
85468: PUSH
85469: NOP4
85473: ARRAY
85474: PPUSH
85475: NOP4
85479: AND
85480: IFFALSE 85553
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85482: NOP4
85486: PUSH
85487: NOP4
85491: ARRAY
85492: PPUSH
85493: NOP4
85497: PUSH
85498: NOP4
85502: ARRAY
85503: PPUSH
85504: NOP4
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85508: NOP4
85512: PUSH
85513: NOP4
85517: PPUSH
85518: NOP4
85522: PUSH
85523: LD_INT 1
85525: PLUS
85526: PPUSH
85527: NOP4
85531: PUSH
85532: NOP4
85536: ARRAY
85537: PPUSH
85538: NOP4
85542: ST_TO_ADDR
// attacking := true ;
85543: NOP4
85547: PUSH
85548: LD_INT 1
85550: ST_TO_ADDR
// break ;
85551: GO 85555
// end ; end ;
85553: GO 85422
85555: POP
85556: POP
// if not attacking and f_attack_depot then
85557: NOP4
85561: NOT
85562: PUSH
85563: NOP4
85567: AND
85568: IFFALSE 85663
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85570: NOP4
85574: PUSH
85575: NOP4
85579: PPUSH
85580: LD_INT 2
85582: PUSH
85583: LD_INT 30
85585: PUSH
85586: LD_INT 0
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: PUSH
85593: LD_INT 30
85595: PUSH
85596: LD_INT 1
85598: PUSH
85599: EMPTY
85600: LIST
85601: LIST
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: LIST
85607: PPUSH
85608: NOP4
85612: ST_TO_ADDR
// if z then
85613: NOP4
85617: IFFALSE 85663
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85619: NOP4
85623: PUSH
85624: NOP4
85628: ARRAY
85629: PPUSH
85630: NOP4
85634: PPUSH
85635: NOP4
85639: PUSH
85640: NOP4
85644: ARRAY
85645: PPUSH
85646: NOP4
85650: PPUSH
85651: NOP4
// attacking := true ;
85655: NOP4
85659: PUSH
85660: LD_INT 1
85662: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85663: NOP4
85667: PUSH
85668: NOP4
85672: ARRAY
85673: PPUSH
85674: NOP4
85678: PUSH
85679: LD_INT 500
85681: LESS
85682: IFFALSE 85708
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85684: NOP4
85688: PUSH
85689: NOP4
85693: ARRAY
85694: PPUSH
85695: NOP4
85699: PUSH
85700: LD_INT 1
85702: ARRAY
85703: PPUSH
85704: NOP4
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85708: NOP4
85712: PUSH
85713: NOP4
85717: ARRAY
85718: PPUSH
85719: NOP4
85723: PUSH
85724: LD_INT 49
85726: EQUAL
85727: IFFALSE 85848
// begin if not HasTask ( group [ i ] ) then
85729: NOP4
85733: PUSH
85734: NOP4
85738: ARRAY
85739: PPUSH
85740: NOP4
85744: NOT
85745: IFFALSE 85848
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85747: NOP4
85751: PUSH
85752: LD_INT 81
85754: PUSH
85755: NOP4
85759: PUSH
85760: NOP4
85764: ARRAY
85765: PPUSH
85766: NOP4
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: PPUSH
85775: NOP4
85779: PPUSH
85780: NOP4
85784: PUSH
85785: NOP4
85789: ARRAY
85790: PPUSH
85791: NOP4
85795: ST_TO_ADDR
// if k then
85796: NOP4
85800: IFFALSE 85848
// if GetDistUnits ( group [ i ] , k ) > 10 then
85802: NOP4
85806: PUSH
85807: NOP4
85811: ARRAY
85812: PPUSH
85813: NOP4
85817: PPUSH
85818: NOP4
85822: PUSH
85823: LD_INT 10
85825: GREATER
85826: IFFALSE 85848
// ComMoveUnit ( group [ i ] , k ) ;
85828: NOP4
85832: PUSH
85833: NOP4
85837: ARRAY
85838: PPUSH
85839: NOP4
85843: PPUSH
85844: NOP4
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85848: NOP4
85852: PUSH
85853: NOP4
85857: ARRAY
85858: PPUSH
85859: NOP4
85863: PUSH
85864: LD_INT 250
85866: LESS
85867: PUSH
85868: NOP4
85872: PUSH
85873: NOP4
85877: ARRAY
85878: PUSH
85879: LD_INT 21
85881: PUSH
85882: LD_INT 2
85884: PUSH
85885: EMPTY
85886: LIST
85887: LIST
85888: PUSH
85889: LD_INT 23
85891: PUSH
85892: LD_INT 2
85894: PUSH
85895: EMPTY
85896: LIST
85897: LIST
85898: PUSH
85899: EMPTY
85900: LIST
85901: LIST
85902: PPUSH
85903: NOP4
85907: IN
85908: AND
85909: IFFALSE 86034
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
85911: NOP4
85915: PUSH
85916: NOP4
85920: PUSH
85921: NOP4
85925: PUSH
85926: NOP4
85930: ARRAY
85931: DIFF
85932: PPUSH
85933: NOP4
85937: PUSH
85938: NOP4
85942: ARRAY
85943: PPUSH
85944: NOP4
85948: ST_TO_ADDR
// if not k then
85949: NOP4
85953: NOT
85954: IFFALSE 85958
// continue ;
85956: GO 82373
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
85958: NOP4
85962: PUSH
85963: LD_INT 81
85965: PUSH
85966: NOP4
85970: PUSH
85971: NOP4
85975: ARRAY
85976: PPUSH
85977: NOP4
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PPUSH
85986: NOP4
85990: IN
85991: PUSH
85992: NOP4
85996: PPUSH
85997: NOP4
86001: PUSH
86002: NOP4
86006: ARRAY
86007: PPUSH
86008: NOP4
86012: PUSH
86013: LD_INT 5
86015: LESS
86016: AND
86017: IFFALSE 86034
// ComAutodestruct ( group [ i ] ) ;
86019: NOP4
86023: PUSH
86024: NOP4
86028: ARRAY
86029: PPUSH
86030: NOP4
// end ; if f_attack_depot then
86034: NOP4
86038: IFFALSE 86150
// begin k := 6 ;
86040: NOP4
86044: PUSH
86045: LD_INT 6
86047: ST_TO_ADDR
// if tmp < k then
86048: NOP4
86052: PUSH
86053: NOP4
86057: LESS
86058: IFFALSE 86070
// k := tmp ;
86060: NOP4
86064: PUSH
86065: NOP4
86069: ST_TO_ADDR
// for j = 1 to k do
86070: NOP4
86074: PUSH
86075: DOUBLE
86076: LD_INT 1
86078: DEC
86079: ST_TO_ADDR
86080: NOP4
86084: PUSH
86085: FOR_TO
86086: IFFALSE 86148
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86088: NOP4
86092: PPUSH
86093: NOP4
86097: PUSH
86098: LD_INT 0
86100: PUSH
86101: LD_INT 1
86103: PUSH
86104: EMPTY
86105: LIST
86106: LIST
86107: IN
86108: IFFALSE 86146
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86110: NOP4
86114: PUSH
86115: NOP4
86119: ARRAY
86120: PPUSH
86121: NOP4
86125: PUSH
86126: NOP4
86130: ARRAY
86131: PPUSH
86132: NOP4
// attacking := true ;
86136: NOP4
86140: PUSH
86141: LD_INT 1
86143: ST_TO_ADDR
// break ;
86144: GO 86148
// end ;
86146: GO 86085
86148: POP
86149: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86150: NOP4
86154: PUSH
86155: NOP4
86159: ARRAY
86160: PPUSH
86161: NOP4
86165: PUSH
86166: NOP4
86170: NOT
86171: AND
86172: IFFALSE 86494
// begin if GetTag ( group [ i ] ) = 71 then
86174: NOP4
86178: PUSH
86179: NOP4
86183: ARRAY
86184: PPUSH
86185: NOP4
86189: PUSH
86190: LD_INT 71
86192: EQUAL
86193: IFFALSE 86234
// begin if HasTask ( group [ i ] ) then
86195: NOP4
86199: PUSH
86200: NOP4
86204: ARRAY
86205: PPUSH
86206: NOP4
86210: IFFALSE 86216
// continue else
86212: GO 82373
86214: GO 86234
// SetTag ( group [ i ] , 0 ) ;
86216: NOP4
86220: PUSH
86221: NOP4
86225: ARRAY
86226: PPUSH
86227: LD_INT 0
86229: PPUSH
86230: NOP4
// end ; k := 8 ;
86234: NOP4
86238: PUSH
86239: LD_INT 8
86241: ST_TO_ADDR
// x := 0 ;
86242: NOP4
86246: PUSH
86247: LD_INT 0
86249: ST_TO_ADDR
// if tmp < k then
86250: NOP4
86254: PUSH
86255: NOP4
86259: LESS
86260: IFFALSE 86272
// k := tmp ;
86262: NOP4
86266: PUSH
86267: NOP4
86271: ST_TO_ADDR
// for j = 1 to k do
86272: NOP4
86276: PUSH
86277: DOUBLE
86278: LD_INT 1
86280: DEC
86281: ST_TO_ADDR
86282: NOP4
86286: PUSH
86287: FOR_TO
86288: IFFALSE 86386
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86290: NOP4
86294: PUSH
86295: NOP4
86299: ARRAY
86300: PPUSH
86301: NOP4
86305: PUSH
86306: LD_INT 1
86308: EQUAL
86309: PUSH
86310: NOP4
86314: PUSH
86315: NOP4
86319: ARRAY
86320: PPUSH
86321: NOP4
86325: PUSH
86326: LD_INT 250
86328: LESS
86329: PUSH
86330: NOP4
86334: AND
86335: PUSH
86336: NOP4
86340: NOT
86341: PUSH
86342: NOP4
86346: PUSH
86347: NOP4
86351: ARRAY
86352: PPUSH
86353: NOP4
86357: PUSH
86358: LD_INT 250
86360: GREATEREQUAL
86361: AND
86362: OR
86363: AND
86364: IFFALSE 86384
// begin x := tmp [ j ] ;
86366: NOP4
86370: PUSH
86371: NOP4
86375: PUSH
86376: NOP4
86380: ARRAY
86381: ST_TO_ADDR
// break ;
86382: GO 86386
// end ;
86384: GO 86287
86386: POP
86387: POP
// if x then
86388: NOP4
86392: IFFALSE 86416
// ComAttackUnit ( group [ i ] , x ) else
86394: NOP4
86398: PUSH
86399: NOP4
86403: ARRAY
86404: PPUSH
86405: NOP4
86409: PPUSH
86410: NOP4
86414: GO 86440
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86416: NOP4
86420: PUSH
86421: NOP4
86425: ARRAY
86426: PPUSH
86427: NOP4
86431: PUSH
86432: LD_INT 1
86434: ARRAY
86435: PPUSH
86436: NOP4
// if not HasTask ( group [ i ] ) then
86440: NOP4
86444: PUSH
86445: NOP4
86449: ARRAY
86450: PPUSH
86451: NOP4
86455: NOT
86456: IFFALSE 86494
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86458: NOP4
86462: PUSH
86463: NOP4
86467: ARRAY
86468: PPUSH
86469: NOP4
86473: PPUSH
86474: NOP4
86478: PUSH
86479: NOP4
86483: ARRAY
86484: PPUSH
86485: NOP4
86489: PPUSH
86490: NOP4
// end ; end ; end ;
86494: GO 82373
86496: POP
86497: POP
// wait ( 0 0$2 ) ;
86498: LD_INT 70
86500: PPUSH
86501: NOP4
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86505: NOP4
86509: NOT
86510: PUSH
86511: NOP4
86515: PUSH
86516: EMPTY
86517: EQUAL
86518: OR
86519: PUSH
86520: LD_INT 81
86522: PUSH
86523: NOP4
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: PPUSH
86532: NOP4
86536: NOT
86537: OR
86538: IFFALSE 82358
// end ;
86540: LD_VAR 0 2
86544: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86545: LD_INT 0
86547: PPUSH
86548: PPUSH
86549: PPUSH
86550: PPUSH
86551: PPUSH
86552: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86553: NOP4
86557: NOT
86558: PUSH
86559: NOP4
86563: PUSH
86564: NOP4
86568: ARRAY
86569: NOT
86570: OR
86571: PUSH
86572: NOP4
86576: NOT
86577: OR
86578: IFFALSE 86582
// exit ;
86580: GO 87136
// side := mc_sides [ base ] ;
86582: NOP4
86586: PUSH
86587: NOP4
86591: PUSH
86592: NOP4
86596: ARRAY
86597: ST_TO_ADDR
// if not side then
86598: NOP4
86602: NOT
86603: IFFALSE 86607
// exit ;
86605: GO 87136
// for i in solds do
86607: NOP4
86611: PUSH
86612: NOP4
86616: PUSH
86617: FOR_IN
86618: IFFALSE 86679
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86620: NOP4
86624: PPUSH
86625: NOP4
86629: PPUSH
86630: NOP4
86634: PUSH
86635: LD_INT 32
86637: PUSH
86638: LD_INT 31
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: IN
86645: IFFALSE 86665
// solds := solds diff i else
86647: NOP4
86651: PUSH
86652: NOP4
86656: PUSH
86657: NOP4
86661: DIFF
86662: ST_TO_ADDR
86663: GO 86677
// SetTag ( i , 18 ) ;
86665: NOP4
86669: PPUSH
86670: LD_INT 18
86672: PPUSH
86673: NOP4
86677: GO 86617
86679: POP
86680: POP
// if not solds then
86681: NOP4
86685: NOT
86686: IFFALSE 86690
// exit ;
86688: GO 87136
// repeat wait ( 0 0$2 ) ;
86690: LD_INT 70
86692: PPUSH
86693: NOP4
// enemy := mc_scan [ base ] ;
86697: NOP4
86701: PUSH
86702: NOP4
86706: PUSH
86707: NOP4
86711: ARRAY
86712: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86713: NOP4
86717: PUSH
86718: NOP4
86722: ARRAY
86723: NOT
86724: PUSH
86725: NOP4
86729: PUSH
86730: NOP4
86734: ARRAY
86735: PUSH
86736: EMPTY
86737: EQUAL
86738: OR
86739: IFFALSE 86776
// begin for i in solds do
86741: NOP4
86745: PUSH
86746: NOP4
86750: PUSH
86751: FOR_IN
86752: IFFALSE 86765
// ComStop ( i ) ;
86754: NOP4
86758: PPUSH
86759: NOP4
86763: GO 86751
86765: POP
86766: POP
// solds := [ ] ;
86767: NOP4
86771: PUSH
86772: EMPTY
86773: ST_TO_ADDR
// exit ;
86774: GO 87136
// end ; for i in solds do
86776: NOP4
86780: PUSH
86781: NOP4
86785: PUSH
86786: FOR_IN
86787: IFFALSE 87108
// begin if IsInUnit ( i ) then
86789: NOP4
86793: PPUSH
86794: NOP4
86798: IFFALSE 86809
// ComExitBuilding ( i ) ;
86800: NOP4
86804: PPUSH
86805: NOP4
// if GetLives ( i ) > 500 then
86809: NOP4
86813: PPUSH
86814: NOP4
86818: PUSH
86819: LD_INT 500
86821: GREATER
86822: IFFALSE 86875
// begin e := NearestUnitToUnit ( enemy , i ) ;
86824: NOP4
86828: PUSH
86829: NOP4
86833: PPUSH
86834: NOP4
86838: PPUSH
86839: NOP4
86843: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86844: NOP4
86848: PPUSH
86849: NOP4
86853: PPUSH
86854: NOP4
86858: PPUSH
86859: NOP4
86863: PPUSH
86864: NOP4
86868: PPUSH
86869: NOP4
// end else
86873: GO 87106
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86875: NOP4
86879: PPUSH
86880: NOP4
86884: PUSH
86885: NOP4
86889: ARRAY
86890: PPUSH
86891: LD_INT 2
86893: PUSH
86894: LD_INT 30
86896: PUSH
86897: LD_INT 0
86899: PUSH
86900: EMPTY
86901: LIST
86902: LIST
86903: PUSH
86904: LD_INT 30
86906: PUSH
86907: LD_INT 1
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 30
86916: PUSH
86917: LD_INT 6
86919: PUSH
86920: EMPTY
86921: LIST
86922: LIST
86923: PUSH
86924: EMPTY
86925: LIST
86926: LIST
86927: LIST
86928: LIST
86929: PPUSH
86930: NOP4
86934: PPUSH
86935: NOP4
86939: PPUSH
86940: NOP4
86944: PPUSH
86945: NOP4
86949: PUSH
86950: LD_INT 10
86952: GREATER
86953: IFFALSE 87106
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
86955: NOP4
86959: PUSH
86960: NOP4
86964: PUSH
86965: NOP4
86969: ARRAY
86970: PPUSH
86971: LD_INT 2
86973: PUSH
86974: LD_INT 30
86976: PUSH
86977: LD_INT 0
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 30
86986: PUSH
86987: LD_INT 1
86989: PUSH
86990: EMPTY
86991: LIST
86992: LIST
86993: PUSH
86994: LD_INT 30
86996: PUSH
86997: LD_INT 6
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: EMPTY
87005: LIST
87006: LIST
87007: LIST
87008: LIST
87009: PPUSH
87010: NOP4
87014: PPUSH
87015: NOP4
87019: PPUSH
87020: NOP4
87024: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87025: NOP4
87029: PPUSH
87030: NOP4
87034: PPUSH
87035: NOP4
87039: PPUSH
87040: LD_INT 3
87042: PPUSH
87043: LD_INT 5
87045: PPUSH
87046: NOP4
87050: PPUSH
87051: NOP4
87055: PPUSH
87056: NOP4
87060: PPUSH
87061: LD_INT 3
87063: PPUSH
87064: LD_INT 5
87066: PPUSH
87067: NOP4
87071: PPUSH
87072: NOP4
// SetTag ( i , 0 ) ;
87076: NOP4
87080: PPUSH
87081: LD_INT 0
87083: PPUSH
87084: NOP4
// solds := solds diff i ;
87088: NOP4
87092: PUSH
87093: NOP4
87097: PUSH
87098: NOP4
87102: DIFF
87103: ST_TO_ADDR
// continue ;
87104: GO 86786
// end ; end ;
87106: GO 86786
87108: POP
87109: POP
// until not solds or not enemy ;
87110: NOP4
87114: NOT
87115: PUSH
87116: NOP4
87120: NOT
87121: OR
87122: IFFALSE 86690
// MC_Reset ( base , 18 ) ;
87124: NOP4
87128: PPUSH
87129: LD_INT 18
87131: PPUSH
87132: NOP4
// end ;
87136: LD_VAR 0 3
87140: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87141: LD_INT 0
87143: PPUSH
87144: PPUSH
87145: PPUSH
87146: PPUSH
87147: PPUSH
87148: PPUSH
87149: PPUSH
87150: PPUSH
87151: PPUSH
87152: PPUSH
87153: PPUSH
87154: PPUSH
87155: PPUSH
87156: PPUSH
87157: PPUSH
87158: PPUSH
87159: PPUSH
87160: PPUSH
87161: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87162: NOP4
87166: PUSH
87167: NOP4
87171: PUSH
87172: NOP4
87176: ARRAY
87177: PPUSH
87178: LD_INT 25
87180: PUSH
87181: LD_INT 3
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: PPUSH
87188: NOP4
87192: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87193: NOP4
87197: PUSH
87198: NOP4
87202: ARRAY
87203: IFFALSE 87227
// mechs := mechs diff mc_remote_driver [ base ] ;
87205: NOP4
87209: PUSH
87210: NOP4
87214: PUSH
87215: NOP4
87219: PUSH
87220: NOP4
87224: ARRAY
87225: DIFF
87226: ST_TO_ADDR
// for i in mechs do
87227: NOP4
87231: PUSH
87232: NOP4
87236: PUSH
87237: FOR_IN
87238: IFFALSE 87273
// if GetTag ( i ) > 0 then
87240: NOP4
87244: PPUSH
87245: NOP4
87249: PUSH
87250: LD_INT 0
87252: GREATER
87253: IFFALSE 87271
// mechs := mechs diff i ;
87255: NOP4
87259: PUSH
87260: NOP4
87264: PUSH
87265: NOP4
87269: DIFF
87270: ST_TO_ADDR
87271: GO 87237
87273: POP
87274: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87275: NOP4
87279: PUSH
87280: NOP4
87284: PUSH
87285: NOP4
87289: ARRAY
87290: PPUSH
87291: LD_INT 2
87293: PUSH
87294: LD_INT 25
87296: PUSH
87297: LD_INT 1
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 25
87306: PUSH
87307: LD_INT 5
87309: PUSH
87310: EMPTY
87311: LIST
87312: LIST
87313: PUSH
87314: LD_INT 25
87316: PUSH
87317: LD_INT 8
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: LD_INT 25
87326: PUSH
87327: LD_INT 9
87329: PUSH
87330: EMPTY
87331: LIST
87332: LIST
87333: PUSH
87334: EMPTY
87335: LIST
87336: LIST
87337: LIST
87338: LIST
87339: LIST
87340: PPUSH
87341: NOP4
87345: ST_TO_ADDR
// if not defenders and not solds then
87346: NOP4
87350: NOT
87351: PUSH
87352: NOP4
87356: NOT
87357: AND
87358: IFFALSE 87362
// exit ;
87360: GO 89132
// depot_under_attack := false ;
87362: NOP4
87366: PUSH
87367: LD_INT 0
87369: ST_TO_ADDR
// sold_defenders := [ ] ;
87370: NOP4
87374: PUSH
87375: EMPTY
87376: ST_TO_ADDR
// if mechs then
87377: NOP4
87381: IFFALSE 87534
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87383: NOP4
87387: PUSH
87388: NOP4
87392: PPUSH
87393: LD_INT 21
87395: PUSH
87396: LD_INT 2
87398: PUSH
87399: EMPTY
87400: LIST
87401: LIST
87402: PPUSH
87403: NOP4
87407: PUSH
87408: FOR_IN
87409: IFFALSE 87532
// begin if GetTag ( i ) <> 20 then
87411: NOP4
87415: PPUSH
87416: NOP4
87420: PUSH
87421: LD_INT 20
87423: NONEQUAL
87424: IFFALSE 87438
// SetTag ( i , 20 ) ;
87426: NOP4
87430: PPUSH
87431: LD_INT 20
87433: PPUSH
87434: NOP4
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87438: NOP4
87442: PPUSH
87443: NOP4
87447: PUSH
87448: LD_INT 1
87450: EQUAL
87451: PUSH
87452: NOP4
87456: PPUSH
87457: NOP4
87461: NOT
87462: AND
87463: IFFALSE 87530
// begin un := mechs [ 1 ] ;
87465: NOP4
87469: PUSH
87470: NOP4
87474: PUSH
87475: LD_INT 1
87477: ARRAY
87478: ST_TO_ADDR
// ComExit ( un ) ;
87479: NOP4
87483: PPUSH
87484: NOP4
// AddComEnterUnit ( un , i ) ;
87488: NOP4
87492: PPUSH
87493: NOP4
87497: PPUSH
87498: NOP4
// SetTag ( un , 19 ) ;
87502: NOP4
87506: PPUSH
87507: LD_INT 19
87509: PPUSH
87510: NOP4
// mechs := mechs diff un ;
87514: NOP4
87518: PUSH
87519: NOP4
87523: PUSH
87524: NOP4
87528: DIFF
87529: ST_TO_ADDR
// end ; end ;
87530: GO 87408
87532: POP
87533: POP
// if solds then
87534: NOP4
87538: IFFALSE 87597
// for i in solds do
87540: NOP4
87544: PUSH
87545: NOP4
87549: PUSH
87550: FOR_IN
87551: IFFALSE 87595
// if not GetTag ( i ) then
87553: NOP4
87557: PPUSH
87558: NOP4
87562: NOT
87563: IFFALSE 87593
// begin defenders := defenders union i ;
87565: NOP4
87569: PUSH
87570: NOP4
87574: PUSH
87575: NOP4
87579: UNION
87580: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87581: NOP4
87585: PPUSH
87586: LD_INT 18
87588: PPUSH
87589: NOP4
// end ;
87593: GO 87550
87595: POP
87596: POP
// repeat wait ( 0 0$2 ) ;
87597: LD_INT 70
87599: PPUSH
87600: NOP4
// enemy := mc_scan [ base ] ;
87604: NOP4
87608: PUSH
87609: NOP4
87613: PUSH
87614: NOP4
87618: ARRAY
87619: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87620: NOP4
87624: PUSH
87625: NOP4
87629: ARRAY
87630: NOT
87631: PUSH
87632: NOP4
87636: PUSH
87637: NOP4
87641: ARRAY
87642: PUSH
87643: EMPTY
87644: EQUAL
87645: OR
87646: IFFALSE 87683
// begin for i in defenders do
87648: NOP4
87652: PUSH
87653: NOP4
87657: PUSH
87658: FOR_IN
87659: IFFALSE 87672
// ComStop ( i ) ;
87661: NOP4
87665: PPUSH
87666: NOP4
87670: GO 87658
87672: POP
87673: POP
// defenders := [ ] ;
87674: NOP4
87678: PUSH
87679: EMPTY
87680: ST_TO_ADDR
// exit ;
87681: GO 89132
// end ; for i in defenders do
87683: NOP4
87687: PUSH
87688: NOP4
87692: PUSH
87693: FOR_IN
87694: IFFALSE 88592
// begin e := NearestUnitToUnit ( enemy , i ) ;
87696: NOP4
87700: PUSH
87701: NOP4
87705: PPUSH
87706: NOP4
87710: PPUSH
87711: NOP4
87715: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87716: NOP4
87720: PUSH
87721: NOP4
87725: PUSH
87726: NOP4
87730: ARRAY
87731: PPUSH
87732: LD_INT 2
87734: PUSH
87735: LD_INT 30
87737: PUSH
87738: LD_INT 0
87740: PUSH
87741: EMPTY
87742: LIST
87743: LIST
87744: PUSH
87745: LD_INT 30
87747: PUSH
87748: LD_INT 1
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: LIST
87759: PPUSH
87760: NOP4
87764: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87765: NOP4
87769: PUSH
87770: NOP4
87774: NOT
87775: PUSH
87776: NOP4
87780: PPUSH
87781: LD_INT 3
87783: PUSH
87784: LD_INT 24
87786: PUSH
87787: LD_INT 600
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: EMPTY
87795: LIST
87796: LIST
87797: PPUSH
87798: NOP4
87802: OR
87803: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87804: NOP4
87808: PPUSH
87809: NOP4
87813: PUSH
87814: LD_INT 2
87816: DOUBLE
87817: EQUAL
87818: IFTRUE 87822
87820: GO 88218
87822: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87823: NOP4
87827: PPUSH
87828: NOP4
87832: PUSH
87833: LD_INT 1000
87835: EQUAL
87836: PUSH
87837: NOP4
87841: PPUSH
87842: NOP4
87846: PPUSH
87847: NOP4
87851: PUSH
87852: LD_INT 40
87854: LESS
87855: PUSH
87856: NOP4
87860: PPUSH
87861: NOP4
87865: PUSH
87866: NOP4
87870: ARRAY
87871: PPUSH
87872: NOP4
87876: OR
87877: AND
87878: IFFALSE 88000
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
87880: NOP4
87884: PPUSH
87885: NOP4
87889: PUSH
87890: LD_INT 1
87892: EQUAL
87893: PUSH
87894: NOP4
87898: PPUSH
87899: NOP4
87903: PUSH
87904: LD_INT 30
87906: LESS
87907: AND
87908: PUSH
87909: NOP4
87913: AND
87914: IFFALSE 87984
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
87916: NOP4
87920: PPUSH
87921: NOP4
87925: PPUSH
87926: NOP4
87930: PPUSH
87931: NOP4
87935: PPUSH
87936: NOP4
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
87940: NOP4
87944: PPUSH
87945: NOP4
87949: PPUSH
87950: NOP4
87954: PPUSH
87955: NOP4
87959: PPUSH
87960: NOP4
87964: PUSH
87965: LD_INT 6
87967: LESS
87968: IFFALSE 87982
// SetFuel ( i , 100 ) ;
87970: NOP4
87974: PPUSH
87975: LD_INT 100
87977: PPUSH
87978: NOP4
// end else
87982: GO 87998
// ComAttackUnit ( i , e ) ;
87984: NOP4
87988: PPUSH
87989: NOP4
87993: PPUSH
87994: NOP4
// end else
87998: GO 88101
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88000: NOP4
88004: PPUSH
88005: NOP4
88009: PUSH
88010: NOP4
88014: ARRAY
88015: PPUSH
88016: NOP4
88020: NOT
88021: PUSH
88022: NOP4
88026: PPUSH
88027: NOP4
88031: PPUSH
88032: NOP4
88036: PUSH
88037: LD_INT 40
88039: GREATEREQUAL
88040: AND
88041: PUSH
88042: NOP4
88046: PPUSH
88047: NOP4
88051: PUSH
88052: LD_INT 650
88054: LESSEQUAL
88055: OR
88056: PUSH
88057: NOP4
88061: PPUSH
88062: NOP4
88066: PUSH
88067: NOP4
88071: ARRAY
88072: PPUSH
88073: NOP4
88077: NOT
88078: AND
88079: IFFALSE 88101
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88081: NOP4
88085: PPUSH
88086: NOP4
88090: PUSH
88091: NOP4
88095: ARRAY
88096: PPUSH
88097: NOP4
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88101: NOP4
88105: PPUSH
88106: NOP4
88110: PUSH
88111: LD_INT 1000
88113: LESS
88114: PUSH
88115: NOP4
88119: PPUSH
88120: NOP4
88124: PUSH
88125: LD_INT 1
88127: EQUAL
88128: AND
88129: PUSH
88130: NOP4
88134: PPUSH
88135: NOP4
88139: AND
88140: PUSH
88141: NOP4
88145: PPUSH
88146: NOP4
88150: PUSH
88151: NOP4
88155: ARRAY
88156: PPUSH
88157: NOP4
88161: AND
88162: IFFALSE 88216
// begin mech := IsDrivenBy ( i ) ;
88164: NOP4
88168: PUSH
88169: NOP4
88173: PPUSH
88174: NOP4
88178: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88179: NOP4
88183: PPUSH
88184: NOP4
// AddComRepairVehicle ( mech , i ) ;
88188: NOP4
88192: PPUSH
88193: NOP4
88197: PPUSH
88198: NOP4
// AddComEnterUnit ( mech , i ) ;
88202: NOP4
88206: PPUSH
88207: NOP4
88211: PPUSH
88212: NOP4
// end ; end ; unit_human :
88216: GO 88563
88218: LD_INT 1
88220: DOUBLE
88221: EQUAL
88222: IFTRUE 88226
88224: GO 88562
88226: POP
// begin b := IsInUnit ( i ) ;
88227: NOP4
88231: PUSH
88232: NOP4
88236: PPUSH
88237: NOP4
88241: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88242: NOP4
88246: PUSH
88247: NOP4
88251: NOT
88252: PUSH
88253: NOP4
88257: PPUSH
88258: NOP4
88262: PUSH
88263: LD_INT 32
88265: PUSH
88266: LD_INT 31
88268: PUSH
88269: EMPTY
88270: LIST
88271: LIST
88272: IN
88273: OR
88274: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88275: NOP4
88279: PPUSH
88280: NOP4
88284: PUSH
88285: LD_INT 5
88287: EQUAL
88288: PUSH
88289: NOP4
88293: PPUSH
88294: NOP4
88298: PUSH
88299: LD_INT 1
88301: PUSH
88302: LD_INT 2
88304: PUSH
88305: LD_INT 3
88307: PUSH
88308: LD_INT 4
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: LIST
88315: LIST
88316: IN
88317: AND
88318: IFFALSE 88355
// begin class := AllowSpecClass ( i ) ;
88320: NOP4
88324: PUSH
88325: NOP4
88329: PPUSH
88330: NOP4
88334: ST_TO_ADDR
// if class then
88335: NOP4
88339: IFFALSE 88355
// ComChangeProfession ( i , class ) ;
88341: NOP4
88345: PPUSH
88346: NOP4
88350: PPUSH
88351: NOP4
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88355: NOP4
88359: PUSH
88360: NOP4
88364: PPUSH
88365: LD_INT 21
88367: PUSH
88368: LD_INT 2
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PPUSH
88375: NOP4
88379: PUSH
88380: LD_INT 1
88382: LESSEQUAL
88383: OR
88384: PUSH
88385: NOP4
88389: AND
88390: PUSH
88391: NOP4
88395: PUSH
88396: NOP4
88400: IN
88401: NOT
88402: AND
88403: IFFALSE 88496
// begin if b then
88405: NOP4
88409: IFFALSE 88458
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88411: NOP4
88415: PPUSH
88416: NOP4
88420: PPUSH
88421: NOP4
88425: PPUSH
88426: NOP4
88430: PPUSH
88431: NOP4
88435: PUSH
88436: LD_INT 10
88438: LESS
88439: PUSH
88440: NOP4
88444: PPUSH
88445: NOP4
88449: PUSH
88450: LD_INT 7
88452: NONEQUAL
88453: AND
88454: IFFALSE 88458
// continue ;
88456: GO 87693
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88458: NOP4
88462: PUSH
88463: NOP4
88467: PPUSH
88468: NOP4
88472: PUSH
88473: LD_INT 1
88475: PLUS
88476: PPUSH
88477: NOP4
88481: PPUSH
88482: NOP4
88486: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88487: NOP4
88491: PPUSH
88492: NOP4
// end ; if sold_defenders then
88496: NOP4
88500: IFFALSE 88560
// if i in sold_defenders then
88502: NOP4
88506: PUSH
88507: NOP4
88511: IN
88512: IFFALSE 88560
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88514: NOP4
88518: PPUSH
88519: NOP4
88523: NOT
88524: PUSH
88525: NOP4
88529: PPUSH
88530: NOP4
88534: PPUSH
88535: NOP4
88539: PUSH
88540: LD_INT 30
88542: LESS
88543: AND
88544: IFFALSE 88560
// ComAttackUnit ( i , e ) ;
88546: NOP4
88550: PPUSH
88551: NOP4
88555: PPUSH
88556: NOP4
// end ; end ; end ;
88560: GO 88563
88562: POP
// if IsDead ( i ) then
88563: NOP4
88567: PPUSH
88568: NOP4
88572: IFFALSE 88590
// defenders := defenders diff i ;
88574: NOP4
88578: PUSH
88579: NOP4
88583: PUSH
88584: NOP4
88588: DIFF
88589: ST_TO_ADDR
// end ;
88590: GO 87693
88592: POP
88593: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88594: NOP4
88598: NOT
88599: PUSH
88600: NOP4
88604: NOT
88605: OR
88606: PUSH
88607: NOP4
88611: PUSH
88612: NOP4
88616: ARRAY
88617: NOT
88618: OR
88619: IFFALSE 87597
// MC_Reset ( base , 18 ) ;
88621: NOP4
88625: PPUSH
88626: LD_INT 18
88628: PPUSH
88629: NOP4
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88633: NOP4
88637: PUSH
88638: NOP4
88642: PUSH
88643: NOP4
88647: PPUSH
88648: LD_INT 2
88650: PUSH
88651: LD_INT 25
88653: PUSH
88654: LD_INT 1
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 25
88663: PUSH
88664: LD_INT 5
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: PUSH
88671: LD_INT 25
88673: PUSH
88674: LD_INT 8
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 25
88683: PUSH
88684: LD_INT 9
88686: PUSH
88687: EMPTY
88688: LIST
88689: LIST
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: PPUSH
88698: NOP4
88702: DIFF
88703: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88704: NOP4
88708: NOT
88709: PUSH
88710: NOP4
88714: PPUSH
88715: LD_INT 21
88717: PUSH
88718: LD_INT 2
88720: PUSH
88721: EMPTY
88722: LIST
88723: LIST
88724: PPUSH
88725: NOP4
88729: AND
88730: IFFALSE 89068
// begin tmp := FilterByTag ( defenders , 19 ) ;
88732: NOP4
88736: PUSH
88737: NOP4
88741: PPUSH
88742: LD_INT 19
88744: PPUSH
88745: NOP4
88749: ST_TO_ADDR
// if tmp then
88750: NOP4
88754: IFFALSE 88824
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88756: NOP4
88760: PUSH
88761: NOP4
88765: PPUSH
88766: LD_INT 25
88768: PUSH
88769: LD_INT 3
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PPUSH
88776: NOP4
88780: ST_TO_ADDR
// if tmp then
88781: NOP4
88785: IFFALSE 88824
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88787: NOP4
88791: PUSH
88792: NOP4
88796: PPUSH
88797: NOP4
88801: PPUSH
88802: NOP4
88806: PUSH
88807: NOP4
88811: ARRAY
88812: PUSH
88813: NOP4
88817: UNION
88818: PPUSH
88819: NOP4
88823: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88824: NOP4
88828: PPUSH
88829: LD_INT 19
88831: PPUSH
88832: NOP4
// repeat wait ( 0 0$1 ) ;
88836: LD_INT 35
88838: PPUSH
88839: NOP4
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88843: NOP4
88847: PUSH
88848: NOP4
88852: ARRAY
88853: NOT
88854: PUSH
88855: NOP4
88859: PUSH
88860: NOP4
88864: ARRAY
88865: PUSH
88866: EMPTY
88867: EQUAL
88868: OR
88869: IFFALSE 88906
// begin for i in defenders do
88871: NOP4
88875: PUSH
88876: NOP4
88880: PUSH
88881: FOR_IN
88882: IFFALSE 88895
// ComStop ( i ) ;
88884: NOP4
88888: PPUSH
88889: NOP4
88893: GO 88881
88895: POP
88896: POP
// defenders := [ ] ;
88897: NOP4
88901: PUSH
88902: EMPTY
88903: ST_TO_ADDR
// exit ;
88904: GO 89132
// end ; for i in defenders do
88906: NOP4
88910: PUSH
88911: NOP4
88915: PUSH
88916: FOR_IN
88917: IFFALSE 89006
// begin if not IsInArea ( i , mc_parking [ base ] ) then
88919: NOP4
88923: PPUSH
88924: NOP4
88928: PUSH
88929: NOP4
88933: ARRAY
88934: PPUSH
88935: NOP4
88939: NOT
88940: IFFALSE 88964
// ComMoveToArea ( i , mc_parking [ base ] ) else
88942: NOP4
88946: PPUSH
88947: NOP4
88951: PUSH
88952: NOP4
88956: ARRAY
88957: PPUSH
88958: NOP4
88962: GO 89004
// if GetControl ( i ) = control_manual then
88964: NOP4
88968: PPUSH
88969: NOP4
88973: PUSH
88974: LD_INT 1
88976: EQUAL
88977: IFFALSE 89004
// if IsDrivenBy ( i ) then
88979: NOP4
88983: PPUSH
88984: NOP4
88988: IFFALSE 89004
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
88990: NOP4
88994: PPUSH
88995: NOP4
88999: PPUSH
89000: NOP4
// end ;
89004: GO 88916
89006: POP
89007: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89008: NOP4
89012: PPUSH
89013: LD_INT 95
89015: PUSH
89016: NOP4
89020: PUSH
89021: NOP4
89025: ARRAY
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: PPUSH
89031: NOP4
89035: PUSH
89036: NOP4
89040: EQUAL
89041: PUSH
89042: NOP4
89046: PUSH
89047: NOP4
89051: ARRAY
89052: OR
89053: PUSH
89054: NOP4
89058: PUSH
89059: NOP4
89063: ARRAY
89064: NOT
89065: OR
89066: IFFALSE 88836
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89068: NOP4
89072: PUSH
89073: NOP4
89077: PPUSH
89078: NOP4
89082: PPUSH
89083: NOP4
89087: PPUSH
89088: LD_INT 21
89090: PUSH
89091: LD_INT 2
89093: PUSH
89094: EMPTY
89095: LIST
89096: LIST
89097: PPUSH
89098: NOP4
89102: PPUSH
89103: NOP4
89107: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89108: NOP4
89112: PPUSH
89113: LD_INT 19
89115: PPUSH
89116: NOP4
// MC_Reset ( base , 20 ) ;
89120: NOP4
89124: PPUSH
89125: LD_INT 20
89127: PPUSH
89128: NOP4
// end ; end_of_file
89132: LD_VAR 0 3
89136: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89137: LD_INT 0
89139: PPUSH
89140: PPUSH
89141: PPUSH
89142: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89143: NOP4
89147: PPUSH
89148: NOP4
89152: PUSH
89153: NOP4
89157: EQUAL
89158: IFFALSE 89230
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89160: LD_INT 68
89162: PPUSH
89163: NOP4
89167: PPUSH
89168: NOP4
89172: PPUSH
89173: NOP4
89177: PUSH
89178: LD_INT 2
89180: EQUAL
89181: IFFALSE 89193
// eff := 70 else
89183: NOP4
89187: PUSH
89188: LD_INT 70
89190: ST_TO_ADDR
89191: GO 89201
// eff := 30 ;
89193: NOP4
89197: PUSH
89198: LD_INT 30
89200: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89201: NOP4
89205: PPUSH
89206: NOP4
89210: PPUSH
89211: NOP4
89215: PPUSH
89216: NOP4
89220: PPUSH
89221: NOP4
89225: PPUSH
89226: NOP4
// end ; end ;
89230: LD_VAR 0 2
89234: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89235: LD_INT 0
89237: PPUSH
// end ;
89238: LD_VAR 0 4
89242: RET
// export function SOS_Command ( cmd ) ; begin
89243: LD_INT 0
89245: PPUSH
// end ;
89246: LD_VAR 0 2
89250: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89251: LD_INT 0
89253: PPUSH
// end ;
89254: LD_VAR 0 6
89258: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
89259: LD_INT 0
89261: PPUSH
89262: PPUSH
// if not vehicle or not factory then
89263: NOP4
89267: NOT
89268: PUSH
89269: NOP4
89273: NOT
89274: OR
89275: IFFALSE 89279
// exit ;
89277: GO 89510
// if factoryWaypoints >= factory then
89279: NOP4
89283: PUSH
89284: NOP4
89288: GREATEREQUAL
89289: IFFALSE 89510
// if factoryWaypoints [ factory ] then
89291: NOP4
89295: PUSH
89296: NOP4
89300: ARRAY
89301: IFFALSE 89510
// begin if GetControl ( vehicle ) = control_manual then
89303: NOP4
89307: PPUSH
89308: NOP4
89312: PUSH
89313: LD_INT 1
89315: EQUAL
89316: IFFALSE 89397
// begin driver := IsDrivenBy ( vehicle ) ;
89318: NOP4
89322: PUSH
89323: NOP4
89327: PPUSH
89328: NOP4
89332: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89333: NOP4
89337: PPUSH
89338: NOP4
89342: PUSH
89343: NOP4
89347: ARRAY
89348: PUSH
89349: LD_INT 3
89351: ARRAY
89352: PPUSH
89353: NOP4
89357: PUSH
89358: NOP4
89362: ARRAY
89363: PUSH
89364: LD_INT 4
89366: ARRAY
89367: PPUSH
89368: NOP4
// AddComExitVehicle ( driver ) ;
89372: NOP4
89376: PPUSH
89377: NOP4
// AddComEnterUnit ( driver , factory ) ;
89381: NOP4
89385: PPUSH
89386: NOP4
89390: PPUSH
89391: NOP4
// end else
89395: GO 89510
// if GetControl ( vehicle ) = control_remote then
89397: NOP4
89401: PPUSH
89402: NOP4
89406: PUSH
89407: LD_INT 2
89409: EQUAL
89410: IFFALSE 89471
// begin wait ( 0 0$2 ) ;
89412: LD_INT 70
89414: PPUSH
89415: NOP4
// if Connect ( vehicle ) then
89419: NOP4
89423: PPUSH
89424: NOP4
89428: IFFALSE 89469
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89430: NOP4
89434: PPUSH
89435: NOP4
89439: PUSH
89440: NOP4
89444: ARRAY
89445: PUSH
89446: LD_INT 3
89448: ARRAY
89449: PPUSH
89450: NOP4
89454: PUSH
89455: NOP4
89459: ARRAY
89460: PUSH
89461: LD_INT 4
89463: ARRAY
89464: PPUSH
89465: NOP4
// end else
89469: GO 89510
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89471: NOP4
89475: PPUSH
89476: NOP4
89480: PUSH
89481: NOP4
89485: ARRAY
89486: PUSH
89487: LD_INT 3
89489: ARRAY
89490: PPUSH
89491: NOP4
89495: PUSH
89496: NOP4
89500: ARRAY
89501: PUSH
89502: LD_INT 4
89504: ARRAY
89505: PPUSH
89506: NOP4
// end ; end ;
89510: LD_VAR 0 3
89514: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89515: LD_INT 0
89517: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89518: NOP4
89522: PUSH
89523: LD_INT 250
89525: EQUAL
89526: PUSH
89527: NOP4
89531: PPUSH
89532: NOP4
89536: PUSH
89537: NOP4
89541: EQUAL
89542: AND
89543: IFFALSE 89564
// MinerPlaceMine ( unit , x , y ) ;
89545: NOP4
89549: PPUSH
89550: NOP4
89554: PPUSH
89555: NOP4
89559: PPUSH
89560: NOP4
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89564: NOP4
89568: PUSH
89569: LD_INT 251
89571: EQUAL
89572: PUSH
89573: NOP4
89577: PPUSH
89578: NOP4
89582: PUSH
89583: NOP4
89587: EQUAL
89588: AND
89589: IFFALSE 89610
// MinerDetonateMine ( unit , x , y ) ;
89591: NOP4
89595: PPUSH
89596: NOP4
89600: PPUSH
89601: NOP4
89605: PPUSH
89606: NOP4
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89610: NOP4
89614: PUSH
89615: LD_INT 252
89617: EQUAL
89618: PUSH
89619: NOP4
89623: PPUSH
89624: NOP4
89628: PUSH
89629: NOP4
89633: EQUAL
89634: AND
89635: IFFALSE 89656
// MinerCreateMinefield ( unit , x , y ) ;
89637: NOP4
89641: PPUSH
89642: NOP4
89646: PPUSH
89647: NOP4
89651: PPUSH
89652: NOP4
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89656: NOP4
89660: PUSH
89661: LD_INT 253
89663: EQUAL
89664: PUSH
89665: NOP4
89669: PPUSH
89670: NOP4
89674: PUSH
89675: LD_INT 5
89677: EQUAL
89678: AND
89679: IFFALSE 89700
// ComBinocular ( unit , x , y ) ;
89681: NOP4
89685: PPUSH
89686: NOP4
89690: PPUSH
89691: NOP4
89695: PPUSH
89696: NOP4
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89700: NOP4
89704: PUSH
89705: LD_INT 254
89707: EQUAL
89708: PUSH
89709: NOP4
89713: PPUSH
89714: NOP4
89718: PUSH
89719: NOP4
89723: EQUAL
89724: AND
89725: PUSH
89726: NOP4
89730: PPUSH
89731: NOP4
89735: PUSH
89736: LD_INT 3
89738: EQUAL
89739: AND
89740: IFFALSE 89756
// HackDestroyVehicle ( unit , selectedUnit ) ;
89742: NOP4
89746: PPUSH
89747: NOP4
89751: PPUSH
89752: NOP4
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89756: NOP4
89760: PUSH
89761: LD_INT 255
89763: EQUAL
89764: PUSH
89765: NOP4
89769: PPUSH
89770: NOP4
89774: PUSH
89775: LD_INT 14
89777: PUSH
89778: LD_INT 53
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: IN
89785: AND
89786: PUSH
89787: NOP4
89791: PPUSH
89792: NOP4
89796: PPUSH
89797: NOP4
89801: AND
89802: IFFALSE 89826
// CutTreeXYR ( unit , x , y , 12 ) ;
89804: NOP4
89808: PPUSH
89809: NOP4
89813: PPUSH
89814: NOP4
89818: PPUSH
89819: LD_INT 12
89821: PPUSH
89822: NOP4
// if cmd = 256 then
89826: NOP4
89830: PUSH
89831: LD_INT 256
89833: EQUAL
89834: IFFALSE 89855
// SetFactoryWaypoint ( unit , x , y ) ;
89836: NOP4
89840: PPUSH
89841: NOP4
89845: PPUSH
89846: NOP4
89850: PPUSH
89851: NOP4
// if cmd = 257 then
89855: NOP4
89859: PUSH
89860: LD_INT 257
89862: EQUAL
89863: IFFALSE 89884
// SetWarehouseGatheringPoint ( unit , x , y ) ;
89865: NOP4
89869: PPUSH
89870: NOP4
89874: PPUSH
89875: NOP4
89879: PPUSH
89880: NOP4
// end ;
89884: LD_VAR 0 6
89888: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
89889: LD_INT 0
89891: PPUSH
89892: PPUSH
89893: PPUSH
89894: PPUSH
89895: PPUSH
89896: PPUSH
89897: PPUSH
89898: PPUSH
89899: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
89900: NOP4
89904: NOT
89905: PUSH
89906: NOP4
89910: PPUSH
89911: NOP4
89915: PPUSH
89916: NOP4
89920: NOT
89921: OR
89922: PUSH
89923: NOP4
89927: NOT
89928: OR
89929: IFFALSE 89933
// exit ;
89931: GO 90273
// list := [ ] ;
89933: NOP4
89937: PUSH
89938: EMPTY
89939: ST_TO_ADDR
// if x - r < 0 then
89940: NOP4
89944: PUSH
89945: NOP4
89949: MINUS
89950: PUSH
89951: LD_INT 0
89953: LESS
89954: IFFALSE 89966
// min_x := 0 else
89956: NOP4
89960: PUSH
89961: LD_INT 0
89963: ST_TO_ADDR
89964: GO 89982
// min_x := x - r ;
89966: NOP4
89970: PUSH
89971: NOP4
89975: PUSH
89976: NOP4
89980: MINUS
89981: ST_TO_ADDR
// if y - r < 0 then
89982: NOP4
89986: PUSH
89987: NOP4
89991: MINUS
89992: PUSH
89993: LD_INT 0
89995: LESS
89996: IFFALSE 90008
// min_y := 0 else
89998: NOP4
90002: PUSH
90003: LD_INT 0
90005: ST_TO_ADDR
90006: GO 90024
// min_y := y - r ;
90008: NOP4
90012: PUSH
90013: NOP4
90017: PUSH
90018: NOP4
90022: MINUS
90023: ST_TO_ADDR
// max_x := x + r ;
90024: NOP4
90028: PUSH
90029: NOP4
90033: PUSH
90034: NOP4
90038: PLUS
90039: ST_TO_ADDR
// max_y := y + r ;
90040: NOP4
90044: PUSH
90045: NOP4
90049: PUSH
90050: NOP4
90054: PLUS
90055: ST_TO_ADDR
// for _x = min_x to max_x do
90056: NOP4
90060: PUSH
90061: DOUBLE
90062: NOP4
90066: DEC
90067: ST_TO_ADDR
90068: NOP4
90072: PUSH
90073: FOR_TO
90074: IFFALSE 90191
// for _y = min_y to max_y do
90076: NOP4
90080: PUSH
90081: DOUBLE
90082: NOP4
90086: DEC
90087: ST_TO_ADDR
90088: NOP4
90092: PUSH
90093: FOR_TO
90094: IFFALSE 90187
// begin if not ValidHex ( _x , _y ) then
90096: NOP4
90100: PPUSH
90101: NOP4
90105: PPUSH
90106: NOP4
90110: NOT
90111: IFFALSE 90115
// continue ;
90113: GO 90093
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90115: NOP4
90119: PPUSH
90120: NOP4
90124: PPUSH
90125: NOP4
90129: PUSH
90130: NOP4
90134: PPUSH
90135: NOP4
90139: PPUSH
90140: NOP4
90144: AND
90145: IFFALSE 90185
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90147: NOP4
90151: PUSH
90152: NOP4
90156: PPUSH
90157: NOP4
90161: PUSH
90162: LD_INT 1
90164: PLUS
90165: PPUSH
90166: NOP4
90170: PUSH
90171: NOP4
90175: PUSH
90176: EMPTY
90177: LIST
90178: LIST
90179: PPUSH
90180: NOP4
90184: ST_TO_ADDR
// end ;
90185: GO 90093
90187: POP
90188: POP
90189: GO 90073
90191: POP
90192: POP
// if not list then
90193: NOP4
90197: NOT
90198: IFFALSE 90202
// exit ;
90200: GO 90273
// for i in list do
90202: NOP4
90206: PUSH
90207: NOP4
90211: PUSH
90212: FOR_IN
90213: IFFALSE 90271
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90215: NOP4
90219: PPUSH
90220: LD_STRING M
90222: PUSH
90223: NOP4
90227: PUSH
90228: LD_INT 1
90230: ARRAY
90231: PUSH
90232: NOP4
90236: PUSH
90237: LD_INT 2
90239: ARRAY
90240: PUSH
90241: LD_INT 0
90243: PUSH
90244: LD_INT 0
90246: PUSH
90247: LD_INT 0
90249: PUSH
90250: LD_INT 0
90252: PUSH
90253: EMPTY
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: PUSH
90262: EMPTY
90263: LIST
90264: PPUSH
90265: NOP4
90269: GO 90212
90271: POP
90272: POP
// end ;
90273: LD_VAR 0 5
90277: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
90278: NOP4
90282: NOT
90283: IFFALSE 90333
90285: GO 90287
90287: DISABLE
// begin initHack := true ;
90288: NOP4
90292: PUSH
90293: LD_INT 1
90295: ST_TO_ADDR
// hackTanks := [ ] ;
90296: NOP4
90300: PUSH
90301: EMPTY
90302: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
90303: NOP4
90307: PUSH
90308: EMPTY
90309: ST_TO_ADDR
// hackLimit := 3 ;
90310: NOP4
90314: PUSH
90315: LD_INT 3
90317: ST_TO_ADDR
// hackDist := 12 ;
90318: NOP4
90322: PUSH
90323: LD_INT 12
90325: ST_TO_ADDR
// hackCounter := [ ] ;
90326: NOP4
90330: PUSH
90331: EMPTY
90332: ST_TO_ADDR
// end ;
90333: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
90334: NOP4
90338: PUSH
90339: LD_INT 34
90341: PUSH
90342: NOP4
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PPUSH
90351: NOP4
90355: AND
90356: IFFALSE 90611
90358: GO 90360
90360: DISABLE
90361: LD_INT 0
90363: PPUSH
90364: PPUSH
// begin enable ;
90365: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
90366: NOP4
90370: PUSH
90371: LD_INT 34
90373: PUSH
90374: NOP4
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: PPUSH
90383: NOP4
90387: PUSH
90388: FOR_IN
90389: IFFALSE 90609
// begin if not i in hackTanks then
90391: NOP4
90395: PUSH
90396: NOP4
90400: IN
90401: NOT
90402: IFFALSE 90485
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
90404: NOP4
90408: PUSH
90409: NOP4
90413: PPUSH
90414: NOP4
90418: PUSH
90419: LD_INT 1
90421: PLUS
90422: PPUSH
90423: NOP4
90427: PPUSH
90428: NOP4
90432: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
90433: NOP4
90437: PUSH
90438: NOP4
90442: PPUSH
90443: NOP4
90447: PUSH
90448: LD_INT 1
90450: PLUS
90451: PPUSH
90452: EMPTY
90453: PPUSH
90454: NOP4
90458: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
90459: NOP4
90463: PUSH
90464: NOP4
90468: PPUSH
90469: NOP4
90473: PUSH
90474: LD_INT 1
90476: PLUS
90477: PPUSH
90478: EMPTY
90479: PPUSH
90480: NOP4
90484: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90485: NOP4
90489: PPUSH
90490: NOP4
90494: NOT
90495: IFFALSE 90508
// begin HackUnlinkAll ( i ) ;
90497: NOP4
90501: PPUSH
90502: NOP4
// continue ;
90506: GO 90388
// end ; HackCheckCapturedStatus ( i ) ;
90508: NOP4
90512: PPUSH
90513: NOP4
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90517: NOP4
90521: PUSH
90522: LD_INT 81
90524: PUSH
90525: NOP4
90529: PPUSH
90530: NOP4
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 33
90541: PUSH
90542: LD_INT 3
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 91
90551: PUSH
90552: NOP4
90556: PUSH
90557: NOP4
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: LIST
90566: PUSH
90567: LD_INT 50
90569: PUSH
90570: EMPTY
90571: LIST
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: LIST
90577: LIST
90578: PPUSH
90579: NOP4
90583: ST_TO_ADDR
// if not tmp then
90584: NOP4
90588: NOT
90589: IFFALSE 90593
// continue ;
90591: GO 90388
// HackLink ( i , tmp ) ;
90593: NOP4
90597: PPUSH
90598: NOP4
90602: PPUSH
90603: NOP4
// end ;
90607: GO 90388
90609: POP
90610: POP
// end ;
90611: PPOPN 2
90613: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90614: LD_INT 0
90616: PPUSH
90617: PPUSH
90618: PPUSH
// if not hack in hackTanks then
90619: NOP4
90623: PUSH
90624: NOP4
90628: IN
90629: NOT
90630: IFFALSE 90634
// exit ;
90632: GO 90745
// index := GetElementIndex ( hackTanks , hack ) ;
90634: NOP4
90638: PUSH
90639: NOP4
90643: PPUSH
90644: NOP4
90648: PPUSH
90649: NOP4
90653: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
90654: NOP4
90658: PUSH
90659: NOP4
90663: ARRAY
90664: IFFALSE 90745
// begin for i in hackTanksCaptured [ index ] do
90666: NOP4
90670: PUSH
90671: NOP4
90675: PUSH
90676: NOP4
90680: ARRAY
90681: PUSH
90682: FOR_IN
90683: IFFALSE 90709
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
90685: NOP4
90689: PUSH
90690: LD_INT 1
90692: ARRAY
90693: PPUSH
90694: NOP4
90698: PUSH
90699: LD_INT 2
90701: ARRAY
90702: PPUSH
90703: NOP4
90707: GO 90682
90709: POP
90710: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
90711: NOP4
90715: PUSH
90716: NOP4
90720: PPUSH
90721: NOP4
90725: PPUSH
90726: EMPTY
90727: PPUSH
90728: NOP4
90732: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90733: NOP4
90737: PPUSH
90738: LD_INT 0
90740: PPUSH
90741: NOP4
// end ; end ;
90745: LD_VAR 0 2
90749: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90750: LD_INT 0
90752: PPUSH
90753: PPUSH
90754: PPUSH
// if not hack in hackTanks or not vehicles then
90755: NOP4
90759: PUSH
90760: NOP4
90764: IN
90765: NOT
90766: PUSH
90767: NOP4
90771: NOT
90772: OR
90773: IFFALSE 90777
// exit ;
90775: GO 91052
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90777: NOP4
90781: PUSH
90782: NOP4
90786: PPUSH
90787: NOP4
90791: PPUSH
90792: LD_INT 1
90794: PPUSH
90795: LD_INT 1
90797: PPUSH
90798: NOP4
90802: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90803: NOP4
90807: PUSH
90808: NOP4
90812: PPUSH
90813: NOP4
90817: PPUSH
90818: NOP4
90822: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90823: NOP4
90827: PUSH
90828: NOP4
90832: ARRAY
90833: PUSH
90834: NOP4
90838: LESS
90839: IFFALSE 91028
// begin for i := 1 to vehicles do
90841: NOP4
90845: PUSH
90846: DOUBLE
90847: LD_INT 1
90849: DEC
90850: ST_TO_ADDR
90851: NOP4
90855: PUSH
90856: FOR_TO
90857: IFFALSE 91026
// begin if hackTanksCaptured [ index ] = hackLimit then
90859: NOP4
90863: PUSH
90864: NOP4
90868: ARRAY
90869: PUSH
90870: NOP4
90874: EQUAL
90875: IFFALSE 90879
// break ;
90877: GO 91026
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
90879: NOP4
90883: PUSH
90884: NOP4
90888: PPUSH
90889: NOP4
90893: PPUSH
90894: NOP4
90898: PUSH
90899: NOP4
90903: ARRAY
90904: PUSH
90905: LD_INT 1
90907: PLUS
90908: PPUSH
90909: NOP4
90913: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
90914: NOP4
90918: PUSH
90919: NOP4
90923: PPUSH
90924: NOP4
90928: PUSH
90929: NOP4
90933: PUSH
90934: NOP4
90938: ARRAY
90939: PUSH
90940: LD_INT 1
90942: PLUS
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PPUSH
90948: NOP4
90952: PUSH
90953: NOP4
90957: ARRAY
90958: PUSH
90959: NOP4
90963: PUSH
90964: NOP4
90968: ARRAY
90969: PPUSH
90970: NOP4
90974: PUSH
90975: EMPTY
90976: LIST
90977: LIST
90978: PPUSH
90979: NOP4
90983: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
90984: NOP4
90988: PUSH
90989: NOP4
90993: ARRAY
90994: PPUSH
90995: NOP4
90999: PPUSH
91000: NOP4
91004: PPUSH
91005: NOP4
// ComStop ( vehicles [ i ] ) ;
91009: NOP4
91013: PUSH
91014: NOP4
91018: ARRAY
91019: PPUSH
91020: NOP4
// end ;
91024: GO 90856
91026: POP
91027: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91028: NOP4
91032: PPUSH
91033: NOP4
91037: PUSH
91038: NOP4
91042: ARRAY
91043: PUSH
91044: LD_INT 0
91046: PLUS
91047: PPUSH
91048: NOP4
// end ;
91052: LD_VAR 0 3
91056: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
91057: LD_INT 0
91059: PPUSH
91060: PPUSH
91061: PPUSH
91062: PPUSH
// if not hack in hackTanks then
91063: NOP4
91067: PUSH
91068: NOP4
91072: IN
91073: NOT
91074: IFFALSE 91078
// exit ;
91076: GO 91318
// index := GetElementIndex ( hackTanks , hack ) ;
91078: NOP4
91082: PUSH
91083: NOP4
91087: PPUSH
91088: NOP4
91092: PPUSH
91093: NOP4
91097: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
91098: NOP4
91102: PUSH
91103: DOUBLE
91104: NOP4
91108: PUSH
91109: NOP4
91113: ARRAY
91114: INC
91115: ST_TO_ADDR
91116: LD_INT 1
91118: PUSH
91119: FOR_DOWNTO
91120: IFFALSE 91292
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
91122: NOP4
91126: PUSH
91127: NOP4
91131: PUSH
91132: NOP4
91136: ARRAY
91137: PUSH
91138: NOP4
91142: ARRAY
91143: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
91144: NOP4
91148: PUSH
91149: LD_INT 1
91151: ARRAY
91152: PPUSH
91153: NOP4
91157: NOT
91158: PUSH
91159: NOP4
91163: PUSH
91164: LD_INT 1
91166: ARRAY
91167: PPUSH
91168: NOP4
91172: PUSH
91173: NOP4
91177: PPUSH
91178: NOP4
91182: NONEQUAL
91183: OR
91184: IFFALSE 91290
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
91186: NOP4
91190: PUSH
91191: LD_INT 1
91193: ARRAY
91194: PPUSH
91195: NOP4
91199: PUSH
91200: NOP4
91204: PUSH
91205: LD_INT 1
91207: ARRAY
91208: PPUSH
91209: NOP4
91213: PUSH
91214: NOP4
91218: PPUSH
91219: NOP4
91223: EQUAL
91224: AND
91225: IFFALSE 91249
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
91227: NOP4
91231: PUSH
91232: LD_INT 1
91234: ARRAY
91235: PPUSH
91236: NOP4
91240: PUSH
91241: LD_INT 2
91243: ARRAY
91244: PPUSH
91245: NOP4
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
91249: NOP4
91253: PUSH
91254: NOP4
91258: PPUSH
91259: NOP4
91263: PPUSH
91264: NOP4
91268: PUSH
91269: NOP4
91273: ARRAY
91274: PPUSH
91275: NOP4
91279: PPUSH
91280: NOP4
91284: PPUSH
91285: NOP4
91289: ST_TO_ADDR
// end ; end ;
91290: GO 91119
91292: POP
91293: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91294: NOP4
91298: PPUSH
91299: NOP4
91303: PUSH
91304: NOP4
91308: ARRAY
91309: PUSH
91310: LD_INT 0
91312: PLUS
91313: PPUSH
91314: NOP4
// end ;
91318: LD_VAR 0 2
91322: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
91323: LD_INT 0
91325: PPUSH
91326: PPUSH
91327: PPUSH
91328: PPUSH
// if not hack in hackTanks then
91329: NOP4
91333: PUSH
91334: NOP4
91338: IN
91339: NOT
91340: IFFALSE 91344
// exit ;
91342: GO 91429
// index := GetElementIndex ( hackTanks , hack ) ;
91344: NOP4
91348: PUSH
91349: NOP4
91353: PPUSH
91354: NOP4
91358: PPUSH
91359: NOP4
91363: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
91364: NOP4
91368: PUSH
91369: DOUBLE
91370: LD_INT 1
91372: DEC
91373: ST_TO_ADDR
91374: NOP4
91378: PUSH
91379: NOP4
91383: ARRAY
91384: PUSH
91385: FOR_TO
91386: IFFALSE 91427
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
91388: NOP4
91392: PUSH
91393: NOP4
91397: ARRAY
91398: PUSH
91399: NOP4
91403: ARRAY
91404: PUSH
91405: LD_INT 1
91407: ARRAY
91408: PUSH
91409: NOP4
91413: EQUAL
91414: IFFALSE 91425
// KillUnit ( vehicle ) ;
91416: NOP4
91420: PPUSH
91421: NOP4
91425: GO 91385
91427: POP
91428: POP
// end ;
91429: LD_VAR 0 3
91433: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
91434: NOP4
91438: NOT
91439: IFFALSE 91474
91441: GO 91443
91443: DISABLE
// begin initMiner := true ;
91444: NOP4
91448: PUSH
91449: LD_INT 1
91451: ST_TO_ADDR
// minersList := [ ] ;
91452: NOP4
91456: PUSH
91457: EMPTY
91458: ST_TO_ADDR
// minerMinesList := [ ] ;
91459: NOP4
91463: PUSH
91464: EMPTY
91465: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
91466: NOP4
91470: PUSH
91471: LD_INT 5
91473: ST_TO_ADDR
// end ;
91474: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
91475: NOP4
91479: PUSH
91480: LD_INT 34
91482: PUSH
91483: NOP4
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: PPUSH
91492: NOP4
91496: AND
91497: IFFALSE 91960
91499: GO 91501
91501: DISABLE
91502: LD_INT 0
91504: PPUSH
91505: PPUSH
91506: PPUSH
91507: PPUSH
// begin enable ;
91508: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91509: NOP4
91513: PUSH
91514: LD_INT 34
91516: PUSH
91517: NOP4
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: PPUSH
91526: NOP4
91530: PUSH
91531: FOR_IN
91532: IFFALSE 91604
// begin if not i in minersList then
91534: NOP4
91538: PUSH
91539: NOP4
91543: IN
91544: NOT
91545: IFFALSE 91602
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91547: NOP4
91551: PUSH
91552: NOP4
91556: PPUSH
91557: NOP4
91561: PUSH
91562: LD_INT 1
91564: PLUS
91565: PPUSH
91566: NOP4
91570: PPUSH
91571: NOP4
91575: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91576: NOP4
91580: PUSH
91581: NOP4
91585: PPUSH
91586: NOP4
91590: PUSH
91591: LD_INT 1
91593: PLUS
91594: PPUSH
91595: EMPTY
91596: PPUSH
91597: NOP4
91601: ST_TO_ADDR
// end end ;
91602: GO 91531
91604: POP
91605: POP
// for i := minerMinesList downto 1 do
91606: NOP4
91610: PUSH
91611: DOUBLE
91612: NOP4
91616: INC
91617: ST_TO_ADDR
91618: LD_INT 1
91620: PUSH
91621: FOR_DOWNTO
91622: IFFALSE 91958
// begin if IsLive ( minersList [ i ] ) then
91624: NOP4
91628: PUSH
91629: NOP4
91633: ARRAY
91634: PPUSH
91635: NOP4
91639: IFFALSE 91667
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91641: NOP4
91645: PUSH
91646: NOP4
91650: ARRAY
91651: PPUSH
91652: NOP4
91656: PUSH
91657: NOP4
91661: ARRAY
91662: PPUSH
91663: NOP4
// if not minerMinesList [ i ] then
91667: NOP4
91671: PUSH
91672: NOP4
91676: ARRAY
91677: NOT
91678: IFFALSE 91682
// continue ;
91680: GO 91621
// for j := minerMinesList [ i ] downto 1 do
91682: NOP4
91686: PUSH
91687: DOUBLE
91688: NOP4
91692: PUSH
91693: NOP4
91697: ARRAY
91698: INC
91699: ST_TO_ADDR
91700: LD_INT 1
91702: PUSH
91703: FOR_DOWNTO
91704: IFFALSE 91954
// begin side := GetSide ( minersList [ i ] ) ;
91706: NOP4
91710: PUSH
91711: NOP4
91715: PUSH
91716: NOP4
91720: ARRAY
91721: PPUSH
91722: NOP4
91726: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91727: NOP4
91731: PUSH
91732: NOP4
91736: PUSH
91737: NOP4
91741: ARRAY
91742: PUSH
91743: NOP4
91747: ARRAY
91748: PUSH
91749: LD_INT 1
91751: ARRAY
91752: PPUSH
91753: NOP4
91757: PUSH
91758: NOP4
91762: ARRAY
91763: PUSH
91764: NOP4
91768: ARRAY
91769: PUSH
91770: LD_INT 2
91772: ARRAY
91773: PPUSH
91774: NOP4
91778: ST_TO_ADDR
// if not tmp then
91779: NOP4
91783: NOT
91784: IFFALSE 91788
// continue ;
91786: GO 91703
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91788: NOP4
91792: PUSH
91793: LD_INT 81
91795: PUSH
91796: NOP4
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PPUSH
91805: NOP4
91809: IN
91810: PUSH
91811: NOP4
91815: PUSH
91816: NOP4
91820: ARRAY
91821: PUSH
91822: NOP4
91826: ARRAY
91827: PUSH
91828: LD_INT 1
91830: ARRAY
91831: PPUSH
91832: NOP4
91836: PUSH
91837: NOP4
91841: ARRAY
91842: PUSH
91843: NOP4
91847: ARRAY
91848: PUSH
91849: LD_INT 2
91851: ARRAY
91852: PPUSH
91853: NOP4
91857: AND
91858: IFFALSE 91952
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91860: NOP4
91864: PUSH
91865: NOP4
91869: ARRAY
91870: PUSH
91871: NOP4
91875: ARRAY
91876: PUSH
91877: LD_INT 1
91879: ARRAY
91880: PPUSH
91881: NOP4
91885: PUSH
91886: NOP4
91890: ARRAY
91891: PUSH
91892: NOP4
91896: ARRAY
91897: PUSH
91898: LD_INT 2
91900: ARRAY
91901: PPUSH
91902: NOP4
91906: PPUSH
91907: NOP4
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
91911: NOP4
91915: PUSH
91916: NOP4
91920: PPUSH
91921: NOP4
91925: PPUSH
91926: NOP4
91930: PUSH
91931: NOP4
91935: ARRAY
91936: PPUSH
91937: NOP4
91941: PPUSH
91942: NOP4
91946: PPUSH
91947: NOP4
91951: ST_TO_ADDR
// end ; end ;
91952: GO 91703
91954: POP
91955: POP
// end ;
91956: GO 91621
91958: POP
91959: POP
// end ;
91960: PPOPN 4
91962: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
91963: LD_INT 0
91965: PPUSH
91966: PPUSH
// result := false ;
91967: NOP4
91971: PUSH
91972: LD_INT 0
91974: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
91975: NOP4
91979: PPUSH
91980: NOP4
91984: PUSH
91985: NOP4
91989: EQUAL
91990: NOT
91991: IFFALSE 91995
// exit ;
91993: GO 92235
// index := GetElementIndex ( minersList , unit ) ;
91995: NOP4
91999: PUSH
92000: NOP4
92004: PPUSH
92005: NOP4
92009: PPUSH
92010: NOP4
92014: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
92015: NOP4
92019: PUSH
92020: NOP4
92024: ARRAY
92025: PUSH
92026: NOP4
92030: GREATEREQUAL
92031: IFFALSE 92035
// exit ;
92033: GO 92235
// ComMoveXY ( unit , x , y ) ;
92035: NOP4
92039: PPUSH
92040: NOP4
92044: PPUSH
92045: NOP4
92049: PPUSH
92050: NOP4
// repeat wait ( 0 0$1 ) ;
92054: LD_INT 35
92056: PPUSH
92057: NOP4
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
92061: NOP4
92065: PPUSH
92066: NOP4
92070: PPUSH
92071: NOP4
92075: PPUSH
92076: NOP4
92080: NOT
92081: PUSH
92082: NOP4
92086: PPUSH
92087: NOP4
92091: AND
92092: IFFALSE 92096
// exit ;
92094: GO 92235
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
92096: NOP4
92100: PPUSH
92101: NOP4
92105: PPUSH
92106: NOP4
92110: PUSH
92111: NOP4
92115: EQUAL
92116: PUSH
92117: NOP4
92121: PPUSH
92122: NOP4
92126: NOT
92127: AND
92128: IFFALSE 92054
// PlaySoundXY ( x , y , PlantMine ) ;
92130: NOP4
92134: PPUSH
92135: NOP4
92139: PPUSH
92140: LD_STRING PlantMine
92142: PPUSH
92143: NOP4
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
92147: NOP4
92151: PPUSH
92152: NOP4
92156: PPUSH
92157: NOP4
92161: PPUSH
92162: NOP4
92166: PPUSH
92167: LD_INT 0
92169: PPUSH
92170: NOP4
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
92174: NOP4
92178: PUSH
92179: NOP4
92183: PPUSH
92184: NOP4
92188: PUSH
92189: NOP4
92193: PUSH
92194: NOP4
92198: ARRAY
92199: PUSH
92200: LD_INT 1
92202: PLUS
92203: PUSH
92204: EMPTY
92205: LIST
92206: LIST
92207: PPUSH
92208: NOP4
92212: PUSH
92213: NOP4
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PPUSH
92222: NOP4
92226: ST_TO_ADDR
// result := true ;
92227: NOP4
92231: PUSH
92232: LD_INT 1
92234: ST_TO_ADDR
// end ;
92235: LD_VAR 0 4
92239: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
92240: LD_INT 0
92242: PPUSH
92243: PPUSH
92244: PPUSH
// if not unit in minersList then
92245: NOP4
92249: PUSH
92250: NOP4
92254: IN
92255: NOT
92256: IFFALSE 92260
// exit ;
92258: GO 92652
// index := GetElementIndex ( minersList , unit ) ;
92260: NOP4
92264: PUSH
92265: NOP4
92269: PPUSH
92270: NOP4
92274: PPUSH
92275: NOP4
92279: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
92280: NOP4
92284: PUSH
92285: DOUBLE
92286: NOP4
92290: PUSH
92291: NOP4
92295: ARRAY
92296: INC
92297: ST_TO_ADDR
92298: LD_INT 1
92300: PUSH
92301: FOR_DOWNTO
92302: IFFALSE 92463
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
92304: NOP4
92308: PUSH
92309: NOP4
92313: ARRAY
92314: PUSH
92315: NOP4
92319: ARRAY
92320: PUSH
92321: LD_INT 1
92323: ARRAY
92324: PUSH
92325: NOP4
92329: EQUAL
92330: PUSH
92331: NOP4
92335: PUSH
92336: NOP4
92340: ARRAY
92341: PUSH
92342: NOP4
92346: ARRAY
92347: PUSH
92348: LD_INT 2
92350: ARRAY
92351: PUSH
92352: NOP4
92356: EQUAL
92357: AND
92358: IFFALSE 92461
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92360: NOP4
92364: PUSH
92365: NOP4
92369: ARRAY
92370: PUSH
92371: NOP4
92375: ARRAY
92376: PUSH
92377: LD_INT 1
92379: ARRAY
92380: PPUSH
92381: NOP4
92385: PUSH
92386: NOP4
92390: ARRAY
92391: PUSH
92392: NOP4
92396: ARRAY
92397: PUSH
92398: LD_INT 2
92400: ARRAY
92401: PPUSH
92402: NOP4
92406: PPUSH
92407: NOP4
92411: PPUSH
92412: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92416: NOP4
92420: PUSH
92421: NOP4
92425: PPUSH
92426: NOP4
92430: PPUSH
92431: NOP4
92435: PUSH
92436: NOP4
92440: ARRAY
92441: PPUSH
92442: NOP4
92446: PPUSH
92447: NOP4
92451: PPUSH
92452: NOP4
92456: ST_TO_ADDR
// exit ;
92457: POP
92458: POP
92459: GO 92652
// end ; end ;
92461: GO 92301
92463: POP
92464: POP
// for i := minerMinesList [ index ] downto 1 do
92465: NOP4
92469: PUSH
92470: DOUBLE
92471: NOP4
92475: PUSH
92476: NOP4
92480: ARRAY
92481: INC
92482: ST_TO_ADDR
92483: LD_INT 1
92485: PUSH
92486: FOR_DOWNTO
92487: IFFALSE 92650
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92489: NOP4
92493: PUSH
92494: NOP4
92498: ARRAY
92499: PUSH
92500: NOP4
92504: ARRAY
92505: PUSH
92506: LD_INT 1
92508: ARRAY
92509: PPUSH
92510: NOP4
92514: PUSH
92515: NOP4
92519: ARRAY
92520: PUSH
92521: NOP4
92525: ARRAY
92526: PUSH
92527: LD_INT 2
92529: ARRAY
92530: PPUSH
92531: NOP4
92535: PPUSH
92536: NOP4
92540: PPUSH
92541: NOP4
92545: PUSH
92546: LD_INT 6
92548: LESS
92549: IFFALSE 92648
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92551: NOP4
92555: PUSH
92556: NOP4
92560: ARRAY
92561: PUSH
92562: NOP4
92566: ARRAY
92567: PUSH
92568: LD_INT 1
92570: ARRAY
92571: PPUSH
92572: NOP4
92576: PUSH
92577: NOP4
92581: ARRAY
92582: PUSH
92583: NOP4
92587: ARRAY
92588: PUSH
92589: LD_INT 2
92591: ARRAY
92592: PPUSH
92593: NOP4
92597: PPUSH
92598: NOP4
92602: PPUSH
92603: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92607: NOP4
92611: PUSH
92612: NOP4
92616: PPUSH
92617: NOP4
92621: PPUSH
92622: NOP4
92626: PUSH
92627: NOP4
92631: ARRAY
92632: PPUSH
92633: NOP4
92637: PPUSH
92638: NOP4
92642: PPUSH
92643: NOP4
92647: ST_TO_ADDR
// end ; end ;
92648: GO 92486
92650: POP
92651: POP
// end ;
92652: LD_VAR 0 4
92656: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
92657: LD_INT 0
92659: PPUSH
92660: PPUSH
92661: PPUSH
92662: PPUSH
92663: PPUSH
92664: PPUSH
92665: PPUSH
92666: PPUSH
92667: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
92668: NOP4
92672: PPUSH
92673: NOP4
92677: PUSH
92678: NOP4
92682: EQUAL
92683: NOT
92684: PUSH
92685: NOP4
92689: PUSH
92690: NOP4
92694: IN
92695: NOT
92696: OR
92697: IFFALSE 92701
// exit ;
92699: GO 93023
// index := GetElementIndex ( minersList , unit ) ;
92701: NOP4
92705: PUSH
92706: NOP4
92710: PPUSH
92711: NOP4
92715: PPUSH
92716: NOP4
92720: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92721: NOP4
92725: PUSH
92726: NOP4
92730: PUSH
92731: NOP4
92735: PUSH
92736: NOP4
92740: ARRAY
92741: MINUS
92742: ST_TO_ADDR
// if not minesFreeAmount then
92743: NOP4
92747: NOT
92748: IFFALSE 92752
// exit ;
92750: GO 93023
// tmp := [ ] ;
92752: NOP4
92756: PUSH
92757: EMPTY
92758: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92759: NOP4
92763: PUSH
92764: DOUBLE
92765: LD_INT 1
92767: DEC
92768: ST_TO_ADDR
92769: NOP4
92773: PUSH
92774: FOR_TO
92775: IFFALSE 92970
// begin _d := rand ( 0 , 5 ) ;
92777: NOP4
92781: PUSH
92782: LD_INT 0
92784: PPUSH
92785: LD_INT 5
92787: PPUSH
92788: NOP4
92792: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92793: NOP4
92797: PUSH
92798: LD_INT 2
92800: PPUSH
92801: LD_INT 6
92803: PPUSH
92804: NOP4
92808: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92809: NOP4
92813: PUSH
92814: NOP4
92818: PPUSH
92819: NOP4
92823: PPUSH
92824: NOP4
92828: PPUSH
92829: NOP4
92833: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92834: NOP4
92838: PUSH
92839: NOP4
92843: PPUSH
92844: NOP4
92848: PPUSH
92849: NOP4
92853: PPUSH
92854: NOP4
92858: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92859: NOP4
92863: PPUSH
92864: NOP4
92868: PPUSH
92869: NOP4
92873: PUSH
92874: NOP4
92878: PUSH
92879: NOP4
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PUSH
92888: NOP4
92892: IN
92893: NOT
92894: AND
92895: PUSH
92896: NOP4
92900: PPUSH
92901: NOP4
92905: PPUSH
92906: NOP4
92910: NOT
92911: AND
92912: IFFALSE 92954
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
92914: NOP4
92918: PUSH
92919: NOP4
92923: PPUSH
92924: NOP4
92928: PUSH
92929: LD_INT 1
92931: PLUS
92932: PPUSH
92933: NOP4
92937: PUSH
92938: NOP4
92942: PUSH
92943: EMPTY
92944: LIST
92945: LIST
92946: PPUSH
92947: NOP4
92951: ST_TO_ADDR
92952: GO 92968
// i := i - 1 ;
92954: NOP4
92958: PUSH
92959: NOP4
92963: PUSH
92964: LD_INT 1
92966: MINUS
92967: ST_TO_ADDR
// end ;
92968: GO 92774
92970: POP
92971: POP
// for i in tmp do
92972: NOP4
92976: PUSH
92977: NOP4
92981: PUSH
92982: FOR_IN
92983: IFFALSE 93021
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
92985: NOP4
92989: PPUSH
92990: NOP4
92994: PUSH
92995: LD_INT 1
92997: ARRAY
92998: PPUSH
92999: NOP4
93003: PUSH
93004: LD_INT 2
93006: ARRAY
93007: PPUSH
93008: NOP4
93012: NOT
93013: IFFALSE 93019
// exit ;
93015: POP
93016: POP
93017: GO 93023
93019: GO 92982
93021: POP
93022: POP
// end ;
93023: LD_VAR 0 4
93027: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
93028: LD_INT 0
93030: PPUSH
93031: PPUSH
93032: PPUSH
93033: PPUSH
93034: PPUSH
93035: PPUSH
93036: PPUSH
// if not GetClass ( unit ) = class_sniper then
93037: NOP4
93041: PPUSH
93042: NOP4
93046: PUSH
93047: LD_INT 5
93049: EQUAL
93050: NOT
93051: IFFALSE 93055
// exit ;
93053: GO 93443
// dist := 8 ;
93055: NOP4
93059: PUSH
93060: LD_INT 8
93062: ST_TO_ADDR
// viewRange := 12 ;
93063: NOP4
93067: PUSH
93068: LD_INT 12
93070: ST_TO_ADDR
// side := GetSide ( unit ) ;
93071: NOP4
93075: PUSH
93076: NOP4
93080: PPUSH
93081: NOP4
93085: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
93086: LD_INT 61
93088: PPUSH
93089: NOP4
93093: PPUSH
93094: NOP4
93098: PUSH
93099: LD_INT 2
93101: EQUAL
93102: IFFALSE 93112
// viewRange := 16 ;
93104: NOP4
93108: PUSH
93109: LD_INT 16
93111: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
93112: NOP4
93116: PPUSH
93117: NOP4
93121: PPUSH
93122: NOP4
93126: PPUSH
93127: NOP4
93131: PUSH
93132: NOP4
93136: GREATER
93137: IFFALSE 93216
// begin ComMoveXY ( unit , x , y ) ;
93139: NOP4
93143: PPUSH
93144: NOP4
93148: PPUSH
93149: NOP4
93153: PPUSH
93154: NOP4
// repeat wait ( 0 0$1 ) ;
93158: LD_INT 35
93160: PPUSH
93161: NOP4
// if not UnitGoingToXY ( unit , x , y ) then
93165: NOP4
93169: PPUSH
93170: NOP4
93174: PPUSH
93175: NOP4
93179: PPUSH
93180: NOP4
93184: NOT
93185: IFFALSE 93189
// exit ;
93187: GO 93443
// until GetDistUnitXY ( unit , x , y ) < dist ;
93189: NOP4
93193: PPUSH
93194: NOP4
93198: PPUSH
93199: NOP4
93203: PPUSH
93204: NOP4
93208: PUSH
93209: NOP4
93213: LESS
93214: IFFALSE 93158
// end ; ComTurnXY ( unit , x , y ) ;
93216: NOP4
93220: PPUSH
93221: NOP4
93225: PPUSH
93226: NOP4
93230: PPUSH
93231: NOP4
// wait ( 5 ) ;
93235: LD_INT 5
93237: PPUSH
93238: NOP4
// _d := GetDir ( unit ) ;
93242: NOP4
93246: PUSH
93247: NOP4
93251: PPUSH
93252: NOP4
93256: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
93257: NOP4
93261: PUSH
93262: NOP4
93266: PPUSH
93267: NOP4
93271: PPUSH
93272: NOP4
93276: PPUSH
93277: NOP4
93281: PPUSH
93282: NOP4
93286: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
93287: NOP4
93291: PUSH
93292: NOP4
93296: PPUSH
93297: NOP4
93301: PPUSH
93302: NOP4
93306: PPUSH
93307: NOP4
93311: PPUSH
93312: NOP4
93316: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93317: NOP4
93321: PPUSH
93322: NOP4
93326: PPUSH
93327: NOP4
93331: NOT
93332: IFFALSE 93336
// exit ;
93334: GO 93443
// ComAnimCustom ( unit , 1 ) ;
93336: NOP4
93340: PPUSH
93341: LD_INT 1
93343: PPUSH
93344: NOP4
// PlaceSeeing ( _x , _y , side , viewRange ) ;
93348: NOP4
93352: PPUSH
93353: NOP4
93357: PPUSH
93358: NOP4
93362: PPUSH
93363: NOP4
93367: PPUSH
93368: NOP4
// repeat wait ( 1 ) ;
93372: LD_INT 1
93374: PPUSH
93375: NOP4
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
93379: NOP4
93383: PPUSH
93384: NOP4
93388: PUSH
93389: NOP4
93393: PPUSH
93394: NOP4
93398: OR
93399: PUSH
93400: NOP4
93404: PPUSH
93405: NOP4
93409: NOT
93410: OR
93411: PUSH
93412: NOP4
93416: PPUSH
93417: NOP4
93421: OR
93422: IFFALSE 93372
// RemoveSeeing ( _x , _y , side ) ;
93424: NOP4
93428: PPUSH
93429: NOP4
93433: PPUSH
93434: NOP4
93438: PPUSH
93439: NOP4
// end ; end_of_file
93443: LD_VAR 0 4
93447: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
93448: NOP4
93452: PUSH
93453: LD_INT 200
93455: DOUBLE
93456: GREATEREQUAL
93457: IFFALSE 93465
93459: LD_INT 299
93461: DOUBLE
93462: LESSEQUAL
93463: IFTRUE 93467
93465: GO 93499
93467: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
93468: NOP4
93472: PPUSH
93473: NOP4
93477: PPUSH
93478: NOP4
93482: PPUSH
93483: NOP4
93487: PPUSH
93488: NOP4
93492: PPUSH
93493: NOP4
93497: GO 93576
93499: LD_INT 300
93501: DOUBLE
93502: GREATEREQUAL
93503: IFFALSE 93511
93505: LD_INT 399
93507: DOUBLE
93508: LESSEQUAL
93509: IFTRUE 93513
93511: GO 93575
93513: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93514: NOP4
93518: PPUSH
93519: NOP4
93523: PPUSH
93524: NOP4
93528: PPUSH
93529: NOP4
93533: PPUSH
93534: NOP4
93538: PPUSH
93539: NOP4
93543: PPUSH
93544: NOP4
93548: PPUSH
93549: NOP4
93553: PPUSH
93554: NOP4
93558: PPUSH
93559: NOP4
93563: PPUSH
93564: NOP4
93568: PPUSH
93569: NOP4
93573: GO 93576
93575: POP
// end ;
93576: PPOPN 11
93578: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93579: NOP4
93583: PPUSH
93584: NOP4
93588: PPUSH
93589: NOP4
93593: PPUSH
93594: NOP4
93598: PPUSH
93599: NOP4
93603: PPUSH
93604: NOP4
// end ;
93608: PPOPN 5
93610: END
