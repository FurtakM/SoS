// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 306 0 0
// InitMultiplayer ;
  20: CALL 567 0 0
// if debug then
  24: LD_EXP 1
  28: IFFALSE 37
// FogOff ( 1 ) ;
  30: LD_INT 1
  32: PPUSH
  33: CALL_OW 344
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  37: LD_INT 3
  39: PPUSH
  40: LD_INT 3
  42: PPUSH
  43: LD_INT 0
  45: PPUSH
  46: LD_INT 2
  48: PPUSH
  49: LD_INT 2
  51: PPUSH
  52: LD_INT 1
  54: PPUSH
  55: LD_INT 5
  57: PPUSH
  58: LD_INT 18
  60: PPUSH
  61: LD_INT 19
  63: PPUSH
  64: CALL 42001 0 9
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  68: LD_INT 2
  70: PPUSH
  71: CALL 1835 0 1
  75: PPUSH
  76: CALL 5790 0 1
// Multiplayer_Start ;
  80: CALL 3699 0 0
// Multiplayer_End ;
  84: CALL 3823 0 0
// end ;
  88: END
// export function CustomInitMacro ; var i ; begin
  89: LD_INT 0
  91: PPUSH
  92: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 8
  98: PUSH
  99: LD_INT 10
 101: PUSH
 102: LD_INT 12
 104: PUSH
 105: EMPTY
 106: LIST
 107: LIST
 108: LIST
 109: PUSH
 110: LD_OWVAR 67
 114: ARRAY
 115: PPUSH
 116: LD_INT 3
 118: PPUSH
 119: CALL 69951 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 123: LD_INT 2
 125: PPUSH
 126: LD_INT 6
 128: PUSH
 129: LD_INT 8
 131: PUSH
 132: LD_INT 9
 134: PUSH
 135: EMPTY
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 2
 148: PPUSH
 149: CALL 69951 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 153: LD_INT 3
 155: PPUSH
 156: LD_INT 6
 158: PUSH
 159: LD_INT 7
 161: PUSH
 162: LD_INT 9
 164: PUSH
 165: EMPTY
 166: LIST
 167: LIST
 168: LIST
 169: PUSH
 170: LD_OWVAR 67
 174: ARRAY
 175: PPUSH
 176: LD_INT 1
 178: PPUSH
 179: CALL 69951 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 183: LD_INT 4
 185: PPUSH
 186: LD_INT 6
 188: PUSH
 189: LD_INT 7
 191: PUSH
 192: LD_INT 9
 194: PUSH
 195: EMPTY
 196: LIST
 197: LIST
 198: LIST
 199: PUSH
 200: LD_OWVAR 67
 204: ARRAY
 205: PPUSH
 206: LD_INT 25
 208: PPUSH
 209: CALL 69951 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south ] ;
 213: LD_ADDR_EXP 66
 217: PUSH
 218: LD_INT 20
 220: PUSH
 221: LD_INT 21
 223: PUSH
 224: LD_INT 22
 226: PUSH
 227: LD_INT 24
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south ] ;
 236: LD_ADDR_EXP 67
 240: PUSH
 241: LD_INT 35
 243: PUSH
 244: LD_INT 34
 246: PUSH
 247: LD_INT 36
 249: PUSH
 250: LD_INT 33
 252: PUSH
 253: EMPTY
 254: LIST
 255: LIST
 256: LIST
 257: LIST
 258: ST_TO_ADDR
// for i = 1 to mc_bases do
 259: LD_ADDR_VAR 0 2
 263: PUSH
 264: DOUBLE
 265: LD_INT 1
 267: DEC
 268: ST_TO_ADDR
 269: LD_EXP 42
 273: PUSH
 274: FOR_TO
 275: IFFALSE 299
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 277: LD_VAR 0 2
 281: PPUSH
 282: LD_EXP 37
 286: PUSH
 287: LD_VAR 0 2
 291: ARRAY
 292: PPUSH
 293: CALL 70377 0 2
 297: GO 274
 299: POP
 300: POP
// end ;
 301: LD_VAR 0 1
 305: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 306: LD_INT 0
 308: PPUSH
// debug := false ;
 309: LD_ADDR_EXP 1
 313: PUSH
 314: LD_INT 0
 316: ST_TO_ADDR
// side_bot := 2 ;
 317: LD_ADDR_EXP 3
 321: PUSH
 322: LD_INT 2
 324: ST_TO_ADDR
// artifact_get := false ;
 325: LD_ADDR_EXP 4
 329: PUSH
 330: LD_INT 0
 332: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 333: LD_ADDR_EXP 5
 337: PUSH
 338: LD_STRING base_a
 340: PUSH
 341: LD_STRING base_b
 343: PUSH
 344: LD_STRING base_c
 346: PUSH
 347: LD_STRING base_d
 349: PUSH
 350: LD_STRING base_e
 352: PUSH
 353: LD_STRING base_f
 355: PUSH
 356: LD_STRING base_g
 358: PUSH
 359: LD_STRING base_h
 361: PUSH
 362: LD_STRING base_i
 364: PUSH
 365: LD_STRING base_j
 367: PUSH
 368: LD_STRING base_k
 370: PUSH
 371: LD_STRING base_l
 373: PUSH
 374: LD_STRING base_m
 376: PUSH
 377: LD_STRING base_n
 379: PUSH
 380: LD_STRING base_o
 382: PUSH
 383: LD_STRING base_p
 385: PUSH
 386: LD_STRING base_r
 388: PUSH
 389: LD_STRING base_s
 391: PUSH
 392: LD_STRING base_t
 394: PUSH
 395: LD_STRING base_u
 397: PUSH
 398: LD_STRING base_w
 400: PUSH
 401: LD_STRING base_x
 403: PUSH
 404: LD_STRING base_y
 406: PUSH
 407: LD_STRING base_z
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: LIST
 418: LIST
 419: LIST
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: LIST
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: ST_TO_ADDR
// end ;
 436: LD_VAR 0 1
 440: RET
// every 0 0$01 trigger game and not debug_strings do
 441: LD_EXP 2
 445: PUSH
 446: LD_OWVAR 48
 450: NOT
 451: AND
 452: IFFALSE 468
 454: GO 456
 456: DISABLE
// begin enable ;
 457: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 458: LD_ADDR_OWVAR 47
 462: PUSH
 463: CALL 4524 0 0
 467: ST_TO_ADDR
// end ;
 468: END
// function Debuger ; var i ; begin
 469: LD_INT 0
 471: PPUSH
 472: PPUSH
// if not debug then
 473: LD_EXP 1
 477: NOT
 478: IFFALSE 482
// exit ;
 480: GO 554
// game_speed := 5 ;
 482: LD_ADDR_OWVAR 65
 486: PUSH
 487: LD_INT 5
 489: ST_TO_ADDR
// uc_side := 1 ;
 490: LD_ADDR_OWVAR 20
 494: PUSH
 495: LD_INT 1
 497: ST_TO_ADDR
// uc_nation := 1 ;
 498: LD_ADDR_OWVAR 21
 502: PUSH
 503: LD_INT 1
 505: ST_TO_ADDR
// for i = 1 to 10 do
 506: LD_ADDR_VAR 0 2
 510: PUSH
 511: DOUBLE
 512: LD_INT 1
 514: DEC
 515: ST_TO_ADDR
 516: LD_INT 10
 518: PUSH
 519: FOR_TO
 520: IFFALSE 552
// begin PrepareHuman ( false , 1 , 10 ) ;
 522: LD_INT 0
 524: PPUSH
 525: LD_INT 1
 527: PPUSH
 528: LD_INT 10
 530: PPUSH
 531: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 535: CALL_OW 44
 539: PPUSH
 540: LD_INT 9
 542: PPUSH
 543: LD_INT 0
 545: PPUSH
 546: CALL_OW 49
// end ;
 550: GO 519
 552: POP
 553: POP
// end ;
 554: LD_VAR 0 1
 558: RET
// export function CustomEvent ( event ) ; begin
 559: LD_INT 0
 561: PPUSH
// end ; end_of_file
 562: LD_VAR 0 2
 566: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 567: LD_INT 0
 569: PPUSH
 570: PPUSH
 571: PPUSH
 572: PPUSH
 573: PPUSH
// multi_settings_counter := 6 ;
 574: LD_ADDR_EXP 18
 578: PUSH
 579: LD_INT 6
 581: ST_TO_ADDR
// if multiplayer then
 582: LD_OWVAR 4
 586: IFFALSE 757
// begin your_side := mp_player_side ;
 588: LD_ADDR_OWVAR 2
 592: PUSH
 593: LD_OWVAR 7
 597: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 598: LD_ADDR_EXP 6
 602: PUSH
 603: LD_OWVAR 6
 607: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 608: LD_ADDR_EXP 7
 612: PUSH
 613: LD_OWVAR 17
 617: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 618: LD_ADDR_EXP 8
 622: PUSH
 623: LD_OWVAR 15
 627: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 628: LD_ADDR_EXP 9
 632: PUSH
 633: LD_OWVAR 16
 637: ST_TO_ADDR
// multi_teams := [ ] ;
 638: LD_ADDR_EXP 10
 642: PUSH
 643: EMPTY
 644: ST_TO_ADDR
// for i in mp_teams do
 645: LD_ADDR_VAR 0 2
 649: PUSH
 650: LD_OWVAR 12
 654: PUSH
 655: FOR_IN
 656: IFFALSE 693
// multi_teams := Replace ( multi_teams , multi_teams + 1 , i [ 1 ] ) ;
 658: LD_ADDR_EXP 10
 662: PUSH
 663: LD_EXP 10
 667: PPUSH
 668: LD_EXP 10
 672: PUSH
 673: LD_INT 1
 675: PLUS
 676: PPUSH
 677: LD_VAR 0 2
 681: PUSH
 682: LD_INT 1
 684: ARRAY
 685: PPUSH
 686: CALL_OW 1
 690: ST_TO_ADDR
 691: GO 655
 693: POP
 694: POP
// for i = 1 to multi_settings_counter do
 695: LD_ADDR_VAR 0 2
 699: PUSH
 700: DOUBLE
 701: LD_INT 1
 703: DEC
 704: ST_TO_ADDR
 705: LD_EXP 18
 709: PUSH
 710: FOR_TO
 711: IFFALSE 753
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 713: LD_ADDR_EXP 17
 717: PUSH
 718: LD_EXP 17
 722: PPUSH
 723: LD_EXP 17
 727: PUSH
 728: LD_INT 1
 730: PLUS
 731: PPUSH
 732: LD_VAR 0 2
 736: PPUSH
 737: CALL_OW 426
 741: PUSH
 742: LD_INT 1
 744: PLUS
 745: PPUSH
 746: CALL_OW 2
 750: ST_TO_ADDR
 751: GO 710
 753: POP
 754: POP
// end else
 755: GO 940
// begin your_side := 1 ;
 757: LD_ADDR_OWVAR 2
 761: PUSH
 762: LD_INT 1
 764: ST_TO_ADDR
// multi_gametype := 1 ;
 765: LD_ADDR_EXP 6
 769: PUSH
 770: LD_INT 1
 772: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 773: LD_ADDR_EXP 7
 777: PUSH
 778: LD_INT 2
 780: PUSH
 781: LD_INT 0
 783: PUSH
 784: LD_INT 0
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 0
 792: PUSH
 793: LD_INT 0
 795: PUSH
 796: LD_INT 1
 798: PUSH
 799: LD_INT 0
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: LIST
 806: LIST
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 812: LD_ADDR_EXP 8
 816: PUSH
 817: LD_INT 1
 819: PUSH
 820: LD_INT 0
 822: PUSH
 823: LD_INT 0
 825: PUSH
 826: LD_INT 1
 828: PUSH
 829: LD_INT 0
 831: PUSH
 832: LD_INT 0
 834: PUSH
 835: LD_INT 1
 837: PUSH
 838: LD_INT 0
 840: PUSH
 841: EMPTY
 842: LIST
 843: LIST
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: LIST
 850: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 851: LD_ADDR_EXP 9
 855: PUSH
 856: LD_INT 1
 858: PUSH
 859: LD_INT 0
 861: PUSH
 862: LD_INT 0
 864: PUSH
 865: LD_INT 1
 867: PUSH
 868: LD_INT 0
 870: PUSH
 871: LD_INT 0
 873: PUSH
 874: LD_INT 1
 876: PUSH
 877: LD_INT 0
 879: PUSH
 880: EMPTY
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: ST_TO_ADDR
// multi_teams := [ 1 , 4 , 7 ] ;
 890: LD_ADDR_EXP 10
 894: PUSH
 895: LD_INT 1
 897: PUSH
 898: LD_INT 4
 900: PUSH
 901: LD_INT 7
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 909: LD_ADDR_EXP 17
 913: PUSH
 914: LD_INT 2
 916: PUSH
 917: LD_INT 2
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 3
 925: PUSH
 926: LD_INT 1
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: LIST
 939: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 940: LD_ADDR_EXP 11
 944: PUSH
 945: LD_INT 0
 947: PUSH
 948: LD_INT 0
 950: PUSH
 951: LD_INT 0
 953: PUSH
 954: LD_INT 0
 956: PUSH
 957: LD_INT 0
 959: PUSH
 960: LD_INT 0
 962: PUSH
 963: LD_INT 0
 965: PUSH
 966: LD_INT 0
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 979: LD_ADDR_EXP 14
 983: PUSH
 984: LD_INT 0
 986: PUSH
 987: LD_INT 0
 989: PUSH
 990: LD_INT 0
 992: PUSH
 993: LD_INT 0
 995: PUSH
 996: LD_INT 0
 998: PUSH
 999: LD_INT 0
1001: PUSH
1002: LD_INT 0
1004: PUSH
1005: LD_INT 0
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1018: LD_ADDR_EXP 25
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: LD_INT 0
1031: PUSH
1032: LD_INT 0
1034: PUSH
1035: LD_INT 0
1037: PUSH
1038: LD_INT 0
1040: PUSH
1041: LD_INT 0
1043: PUSH
1044: LD_INT 0
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: ST_TO_ADDR
// multi_teamgame := true ;
1057: LD_ADDR_EXP 15
1061: PUSH
1062: LD_INT 1
1064: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1065: LD_ADDR_EXP 13
1069: PUSH
1070: LD_INT 1
1072: PUSH
1073: EMPTY
1074: LIST
1075: ST_TO_ADDR
// multi_custom_commanders := true ;
1076: LD_ADDR_EXP 16
1080: PUSH
1081: LD_INT 1
1083: ST_TO_ADDR
// multi_commanders := [ ] ;
1084: LD_ADDR_EXP 24
1088: PUSH
1089: EMPTY
1090: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1091: LD_ADDR_EXP 27
1095: PUSH
1096: EMPTY
1097: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1098: LD_ADDR_EXP 28
1102: PUSH
1103: LD_INT 0
1105: ST_TO_ADDR
// multi_players_amount := 0 ;
1106: LD_ADDR_EXP 26
1110: PUSH
1111: LD_INT 0
1113: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1114: LD_ADDR_EXP 12
1118: PUSH
1119: LD_INT 9
1121: PUSH
1122: LD_INT 8
1124: PUSH
1125: EMPTY
1126: LIST
1127: LIST
1128: PUSH
1129: LD_INT 27
1131: PUSH
1132: LD_INT 26
1134: PUSH
1135: EMPTY
1136: LIST
1137: LIST
1138: PUSH
1139: LD_INT 29
1141: PUSH
1142: LD_INT 28
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: ST_TO_ADDR
// for i = 1 to 8 do
1154: LD_ADDR_VAR 0 2
1158: PUSH
1159: DOUBLE
1160: LD_INT 1
1162: DEC
1163: ST_TO_ADDR
1164: LD_INT 8
1166: PUSH
1167: FOR_TO
1168: IFFALSE 1497
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1170: LD_VAR 0 2
1174: PPUSH
1175: CALL_OW 530
1179: IFFALSE 1337
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1181: LD_ADDR_EXP 11
1185: PUSH
1186: LD_EXP 11
1190: PPUSH
1191: LD_VAR 0 2
1195: PPUSH
1196: LD_INT 1
1198: PPUSH
1199: CALL_OW 1
1203: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1204: LD_ADDR_EXP 9
1208: PUSH
1209: LD_EXP 9
1213: PPUSH
1214: LD_VAR 0 2
1218: PPUSH
1219: LD_INT 0
1221: PPUSH
1222: CALL_OW 1
1226: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1227: LD_ADDR_EXP 7
1231: PUSH
1232: LD_EXP 7
1236: PPUSH
1237: LD_VAR 0 2
1241: PPUSH
1242: LD_INT 0
1244: PPUSH
1245: CALL_OW 1
1249: ST_TO_ADDR
// for j = 1 to multi_teams do
1250: LD_ADDR_VAR 0 3
1254: PUSH
1255: DOUBLE
1256: LD_INT 1
1258: DEC
1259: ST_TO_ADDR
1260: LD_EXP 10
1264: PUSH
1265: FOR_TO
1266: IFFALSE 1335
// begin if i in multi_teams [ j ] then
1268: LD_VAR 0 2
1272: PUSH
1273: LD_EXP 10
1277: PUSH
1278: LD_VAR 0 3
1282: ARRAY
1283: IN
1284: IFFALSE 1333
// begin tmp := multi_teams [ j ] diff i ;
1286: LD_ADDR_VAR 0 5
1290: PUSH
1291: LD_EXP 10
1295: PUSH
1296: LD_VAR 0 3
1300: ARRAY
1301: PUSH
1302: LD_VAR 0 2
1306: DIFF
1307: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1308: LD_ADDR_EXP 10
1312: PUSH
1313: LD_EXP 10
1317: PPUSH
1318: LD_VAR 0 3
1322: PPUSH
1323: LD_VAR 0 5
1327: PPUSH
1328: CALL_OW 1
1332: ST_TO_ADDR
// end ; end ;
1333: GO 1265
1335: POP
1336: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1337: LD_EXP 9
1341: PUSH
1342: LD_VAR 0 2
1346: ARRAY
1347: PUSH
1348: LD_EXP 9
1352: PUSH
1353: LD_VAR 0 2
1357: ARRAY
1358: PUSH
1359: LD_EXP 13
1363: IN
1364: NOT
1365: AND
1366: IFFALSE 1407
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1368: LD_ADDR_EXP 9
1372: PUSH
1373: LD_EXP 9
1377: PPUSH
1378: LD_VAR 0 2
1382: PPUSH
1383: LD_EXP 13
1387: PUSH
1388: LD_INT 1
1390: PPUSH
1391: LD_EXP 13
1395: PPUSH
1396: CALL_OW 12
1400: ARRAY
1401: PPUSH
1402: CALL_OW 1
1406: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1407: LD_EXP 9
1411: PUSH
1412: LD_VAR 0 2
1416: ARRAY
1417: NOT
1418: PUSH
1419: LD_EXP 7
1423: PUSH
1424: LD_VAR 0 2
1428: ARRAY
1429: NOT
1430: AND
1431: PUSH
1432: LD_EXP 11
1436: PUSH
1437: LD_VAR 0 2
1441: ARRAY
1442: NOT
1443: AND
1444: IFFALSE 1469
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1446: LD_ADDR_EXP 14
1450: PUSH
1451: LD_EXP 14
1455: PPUSH
1456: LD_VAR 0 2
1460: PPUSH
1461: LD_INT 1
1463: PPUSH
1464: CALL_OW 1
1468: ST_TO_ADDR
// if multi_sides [ i ] then
1469: LD_EXP 7
1473: PUSH
1474: LD_VAR 0 2
1478: ARRAY
1479: IFFALSE 1495
// multi_players_amount := multi_players_amount + 1 ;
1481: LD_ADDR_EXP 26
1485: PUSH
1486: LD_EXP 26
1490: PUSH
1491: LD_INT 1
1493: PLUS
1494: ST_TO_ADDR
// end ;
1495: GO 1167
1497: POP
1498: POP
// for i in multi_teams do
1499: LD_ADDR_VAR 0 2
1503: PUSH
1504: LD_EXP 10
1508: PUSH
1509: FOR_IN
1510: IFFALSE 1618
// begin for j = 2 to i do
1512: LD_ADDR_VAR 0 3
1516: PUSH
1517: DOUBLE
1518: LD_INT 2
1520: DEC
1521: ST_TO_ADDR
1522: LD_VAR 0 2
1526: PUSH
1527: FOR_TO
1528: IFFALSE 1614
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1530: LD_VAR 0 2
1534: PUSH
1535: LD_VAR 0 3
1539: ARRAY
1540: PPUSH
1541: LD_VAR 0 2
1545: PUSH
1546: LD_INT 1
1548: ARRAY
1549: PPUSH
1550: CALL_OW 343
// for x = 1 to j - 1 do
1554: LD_ADDR_VAR 0 4
1558: PUSH
1559: DOUBLE
1560: LD_INT 1
1562: DEC
1563: ST_TO_ADDR
1564: LD_VAR 0 3
1568: PUSH
1569: LD_INT 1
1571: MINUS
1572: PUSH
1573: FOR_TO
1574: IFFALSE 1610
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1576: LD_VAR 0 2
1580: PUSH
1581: LD_VAR 0 3
1585: ARRAY
1586: PPUSH
1587: LD_VAR 0 2
1591: PUSH
1592: LD_VAR 0 4
1596: ARRAY
1597: PPUSH
1598: LD_INT 1
1600: PPUSH
1601: LD_INT 1
1603: PPUSH
1604: CALL_OW 80
1608: GO 1573
1610: POP
1611: POP
// end ;
1612: GO 1527
1614: POP
1615: POP
// end ;
1616: GO 1509
1618: POP
1619: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1620: LD_ADDR_OWVAR 67
1624: PUSH
1625: LD_INT 1
1627: PUSH
1628: LD_INT 2
1630: PUSH
1631: LD_INT 3
1633: PUSH
1634: EMPTY
1635: LIST
1636: LIST
1637: LIST
1638: PUSH
1639: LD_EXP 17
1643: PUSH
1644: LD_INT 1
1646: ARRAY
1647: ARRAY
1648: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1649: LD_ADDR_EXP 19
1653: PUSH
1654: LD_INT 9
1656: PUSH
1657: LD_INT 12
1659: PUSH
1660: LD_INT 15
1662: PUSH
1663: LD_INT 18
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: PUSH
1672: LD_EXP 17
1676: PUSH
1677: LD_INT 2
1679: ARRAY
1680: ARRAY
1681: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1682: LD_ADDR_EXP 20
1686: PUSH
1687: LD_INT 5
1689: PUSH
1690: LD_INT 7
1692: PUSH
1693: LD_INT 9
1695: PUSH
1696: EMPTY
1697: LIST
1698: LIST
1699: LIST
1700: PUSH
1701: LD_EXP 17
1705: PUSH
1706: LD_INT 3
1708: ARRAY
1709: ARRAY
1710: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1711: LD_ADDR_EXP 21
1715: PUSH
1716: LD_INT 6000
1718: PUSH
1719: LD_INT 1575
1721: PUSH
1722: EMPTY
1723: LIST
1724: LIST
1725: PUSH
1726: LD_INT 8000
1728: PUSH
1729: LD_INT 1260
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: PUSH
1736: LD_INT 10000
1738: PUSH
1739: LD_INT 770
1741: PUSH
1742: EMPTY
1743: LIST
1744: LIST
1745: PUSH
1746: LD_INT 15000
1748: PUSH
1749: LD_INT 770
1751: PUSH
1752: EMPTY
1753: LIST
1754: LIST
1755: PUSH
1756: EMPTY
1757: LIST
1758: LIST
1759: LIST
1760: LIST
1761: PUSH
1762: LD_EXP 17
1766: PUSH
1767: LD_INT 4
1769: ARRAY
1770: ARRAY
1771: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1772: LD_ADDR_EXP 22
1776: PUSH
1777: LD_INT 6
1779: PUSH
1780: LD_INT 8
1782: PUSH
1783: LD_INT 10
1785: PUSH
1786: EMPTY
1787: LIST
1788: LIST
1789: LIST
1790: PUSH
1791: LD_EXP 17
1795: PUSH
1796: LD_INT 5
1798: ARRAY
1799: ARRAY
1800: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1801: LD_ADDR_EXP 23
1805: PUSH
1806: LD_INT 0
1808: PUSH
1809: LD_INT 1
1811: PUSH
1812: LD_INT 2
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_EXP 17
1824: PUSH
1825: LD_INT 6
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// end ;
1830: LD_VAR 0 1
1834: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1835: LD_INT 0
1837: PPUSH
1838: PPUSH
// if not preferSide in multi_sides then
1839: LD_VAR 0 1
1843: PUSH
1844: LD_EXP 7
1848: IN
1849: NOT
1850: IFFALSE 1864
// begin result := preferSide ;
1852: LD_ADDR_VAR 0 2
1856: PUSH
1857: LD_VAR 0 1
1861: ST_TO_ADDR
// exit ;
1862: GO 1911
// end ; for i := 1 to 8 do
1864: LD_ADDR_VAR 0 3
1868: PUSH
1869: DOUBLE
1870: LD_INT 1
1872: DEC
1873: ST_TO_ADDR
1874: LD_INT 8
1876: PUSH
1877: FOR_TO
1878: IFFALSE 1909
// if not multi_sides [ i ] then
1880: LD_EXP 7
1884: PUSH
1885: LD_VAR 0 3
1889: ARRAY
1890: NOT
1891: IFFALSE 1907
// begin result := i ;
1893: LD_ADDR_VAR 0 2
1897: PUSH
1898: LD_VAR 0 3
1902: ST_TO_ADDR
// exit ;
1903: POP
1904: POP
1905: GO 1911
// end ;
1907: GO 1877
1909: POP
1910: POP
// end ;
1911: LD_VAR 0 2
1915: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1916: LD_INT 0
1918: PPUSH
// uc_side := side ;
1919: LD_ADDR_OWVAR 20
1923: PUSH
1924: LD_VAR 0 1
1928: ST_TO_ADDR
// uc_nation := 1 ;
1929: LD_ADDR_OWVAR 21
1933: PUSH
1934: LD_INT 1
1936: ST_TO_ADDR
// hc_importance := 100 ;
1937: LD_ADDR_OWVAR 32
1941: PUSH
1942: LD_INT 100
1944: ST_TO_ADDR
// hc_class := 1 ;
1945: LD_ADDR_OWVAR 28
1949: PUSH
1950: LD_INT 1
1952: ST_TO_ADDR
// if num = 1 then
1953: LD_VAR 0 2
1957: PUSH
1958: LD_INT 1
1960: EQUAL
1961: IFFALSE 2043
// begin hc_gallery := us ;
1963: LD_ADDR_OWVAR 33
1967: PUSH
1968: LD_STRING us
1970: ST_TO_ADDR
// hc_face_number := 5 ;
1971: LD_ADDR_OWVAR 34
1975: PUSH
1976: LD_INT 5
1978: ST_TO_ADDR
// hc_name := John Macmilan ;
1979: LD_ADDR_OWVAR 26
1983: PUSH
1984: LD_STRING John Macmilan
1986: ST_TO_ADDR
// hc_sex := sex_male ;
1987: LD_ADDR_OWVAR 27
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
1995: LD_ADDR_OWVAR 31
1999: PUSH
2000: LD_INT 7
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 4
2008: PUSH
2009: LD_INT 4
2011: PUSH
2012: EMPTY
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2018: LD_ADDR_OWVAR 29
2022: PUSH
2023: LD_INT 11
2025: PUSH
2026: LD_INT 10
2028: PUSH
2029: EMPTY
2030: LIST
2031: LIST
2032: ST_TO_ADDR
// result := CreateHuman ;
2033: LD_ADDR_VAR 0 3
2037: PUSH
2038: CALL_OW 44
2042: ST_TO_ADDR
// end ; if num = 2 then
2043: LD_VAR 0 2
2047: PUSH
2048: LD_INT 2
2050: EQUAL
2051: IFFALSE 2133
// begin hc_gallery := us ;
2053: LD_ADDR_OWVAR 33
2057: PUSH
2058: LD_STRING us
2060: ST_TO_ADDR
// hc_face_number := 2 ;
2061: LD_ADDR_OWVAR 34
2065: PUSH
2066: LD_INT 2
2068: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2069: LD_ADDR_OWVAR 26
2073: PUSH
2074: LD_STRING Lucy Donaldson
2076: ST_TO_ADDR
// hc_sex := sex_female ;
2077: LD_ADDR_OWVAR 27
2081: PUSH
2082: LD_INT 2
2084: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2085: LD_ADDR_OWVAR 31
2089: PUSH
2090: LD_INT 6
2092: PUSH
2093: LD_INT 3
2095: PUSH
2096: LD_INT 4
2098: PUSH
2099: LD_INT 3
2101: PUSH
2102: EMPTY
2103: LIST
2104: LIST
2105: LIST
2106: LIST
2107: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2108: LD_ADDR_OWVAR 29
2112: PUSH
2113: LD_INT 9
2115: PUSH
2116: LD_INT 12
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: ST_TO_ADDR
// result := CreateHuman ;
2123: LD_ADDR_VAR 0 3
2127: PUSH
2128: CALL_OW 44
2132: ST_TO_ADDR
// end ; if num = 3 then
2133: LD_VAR 0 2
2137: PUSH
2138: LD_INT 3
2140: EQUAL
2141: IFFALSE 2223
// begin hc_gallery := us ;
2143: LD_ADDR_OWVAR 33
2147: PUSH
2148: LD_STRING us
2150: ST_TO_ADDR
// hc_face_number := 7 ;
2151: LD_ADDR_OWVAR 34
2155: PUSH
2156: LD_INT 7
2158: ST_TO_ADDR
// hc_name := Arthur Powell ;
2159: LD_ADDR_OWVAR 26
2163: PUSH
2164: LD_STRING Arthur Powell
2166: ST_TO_ADDR
// hc_sex := sex_male ;
2167: LD_ADDR_OWVAR 27
2171: PUSH
2172: LD_INT 1
2174: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2175: LD_ADDR_OWVAR 31
2179: PUSH
2180: LD_INT 8
2182: PUSH
2183: LD_INT 2
2185: PUSH
2186: LD_INT 5
2188: PUSH
2189: LD_INT 2
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2198: LD_ADDR_OWVAR 29
2202: PUSH
2203: LD_INT 10
2205: PUSH
2206: LD_INT 11
2208: PUSH
2209: EMPTY
2210: LIST
2211: LIST
2212: ST_TO_ADDR
// result := CreateHuman ;
2213: LD_ADDR_VAR 0 3
2217: PUSH
2218: CALL_OW 44
2222: ST_TO_ADDR
// end ; end ;
2223: LD_VAR 0 3
2227: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2228: LD_INT 0
2230: PPUSH
2231: PPUSH
2232: PPUSH
2233: PPUSH
2234: PPUSH
2235: PPUSH
2236: PPUSH
2237: PPUSH
2238: PPUSH
// for i = 1 to 8 do
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: DOUBLE
2245: LD_INT 1
2247: DEC
2248: ST_TO_ADDR
2249: LD_INT 8
2251: PUSH
2252: FOR_TO
2253: IFFALSE 3143
// begin if not multi_sides [ i ] then
2255: LD_EXP 7
2259: PUSH
2260: LD_VAR 0 2
2264: ARRAY
2265: NOT
2266: IFFALSE 2270
// continue ;
2268: GO 2252
// if multi_custom_commanders then
2270: LD_EXP 16
2274: IFFALSE 2366
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2276: LD_ADDR_VAR 0 5
2280: PUSH
2281: LD_VAR 0 2
2285: PPUSH
2286: LD_EXP 7
2290: PUSH
2291: LD_VAR 0 2
2295: ARRAY
2296: PPUSH
2297: CALL 1916 0 2
2301: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2302: LD_ADDR_EXP 24
2306: PUSH
2307: LD_EXP 24
2311: PPUSH
2312: LD_EXP 24
2316: PUSH
2317: LD_INT 1
2319: PLUS
2320: PPUSH
2321: LD_VAR 0 5
2325: PPUSH
2326: CALL_OW 2
2330: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2331: LD_VAR 0 5
2335: PPUSH
2336: LD_EXP 12
2340: PUSH
2341: LD_EXP 7
2345: PUSH
2346: LD_VAR 0 2
2350: ARRAY
2351: ARRAY
2352: PUSH
2353: LD_INT 1
2355: ARRAY
2356: PPUSH
2357: LD_INT 0
2359: PPUSH
2360: CALL_OW 49
// end else
2364: GO 2577
// begin uc_side := i ;
2366: LD_ADDR_OWVAR 20
2370: PUSH
2371: LD_VAR 0 2
2375: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2376: LD_ADDR_OWVAR 21
2380: PUSH
2381: LD_EXP 9
2385: PUSH
2386: LD_VAR 0 2
2390: ARRAY
2391: ST_TO_ADDR
// hc_importance := 100 ;
2392: LD_ADDR_OWVAR 32
2396: PUSH
2397: LD_INT 100
2399: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2400: LD_INT 0
2402: PPUSH
2403: LD_INT 1
2405: PPUSH
2406: LD_EXP 20
2410: PPUSH
2411: CALL_OW 380
// if multiplayer then
2415: LD_OWVAR 4
2419: IFFALSE 2477
// begin hc_name := mp_sides_players_names [ i ] ;
2421: LD_ADDR_OWVAR 26
2425: PUSH
2426: LD_OWVAR 19
2430: PUSH
2431: LD_VAR 0 2
2435: ARRAY
2436: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2437: LD_ADDR_OWVAR 33
2441: PUSH
2442: LD_STRING MULTIAVATARS
2444: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2445: LD_ADDR_OWVAR 34
2449: PUSH
2450: LD_VAR 0 2
2454: PPUSH
2455: CALL_OW 525
2459: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2460: LD_ADDR_OWVAR 27
2464: PUSH
2465: LD_VAR 0 2
2469: PPUSH
2470: CALL_OW 526
2474: ST_TO_ADDR
// end else
2475: GO 2509
// begin hc_gallery :=  ;
2477: LD_ADDR_OWVAR 33
2481: PUSH
2482: LD_STRING 
2484: ST_TO_ADDR
// hc_name :=  ;
2485: LD_ADDR_OWVAR 26
2489: PUSH
2490: LD_STRING 
2492: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2493: LD_ADDR_OWVAR 27
2497: PUSH
2498: LD_INT 1
2500: PPUSH
2501: LD_INT 2
2503: PPUSH
2504: CALL_OW 12
2508: ST_TO_ADDR
// end ; un := CreateHuman ;
2509: LD_ADDR_VAR 0 5
2513: PUSH
2514: CALL_OW 44
2518: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2519: LD_VAR 0 5
2523: PPUSH
2524: LD_EXP 12
2528: PUSH
2529: LD_EXP 7
2533: PUSH
2534: LD_VAR 0 2
2538: ARRAY
2539: ARRAY
2540: PUSH
2541: LD_INT 1
2543: ARRAY
2544: PPUSH
2545: LD_INT 0
2547: PPUSH
2548: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2552: LD_ADDR_EXP 24
2556: PUSH
2557: LD_EXP 24
2561: PPUSH
2562: LD_VAR 0 2
2566: PPUSH
2567: LD_VAR 0 5
2571: PPUSH
2572: CALL_OW 1
2576: ST_TO_ADDR
// end ; InitHc ;
2577: CALL_OW 19
// InitUc ;
2581: CALL_OW 18
// uc_side := i ;
2585: LD_ADDR_OWVAR 20
2589: PUSH
2590: LD_VAR 0 2
2594: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2595: LD_ADDR_OWVAR 21
2599: PUSH
2600: LD_EXP 9
2604: PUSH
2605: LD_VAR 0 2
2609: ARRAY
2610: ST_TO_ADDR
// hc_gallery :=  ;
2611: LD_ADDR_OWVAR 33
2615: PUSH
2616: LD_STRING 
2618: ST_TO_ADDR
// hc_name :=  ;
2619: LD_ADDR_OWVAR 26
2623: PUSH
2624: LD_STRING 
2626: ST_TO_ADDR
// hc_importance := 0 ;
2627: LD_ADDR_OWVAR 32
2631: PUSH
2632: LD_INT 0
2634: ST_TO_ADDR
// cl := 1 ;
2635: LD_ADDR_VAR 0 4
2639: PUSH
2640: LD_INT 1
2642: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2643: LD_ADDR_VAR 0 3
2647: PUSH
2648: DOUBLE
2649: LD_INT 2
2651: DEC
2652: ST_TO_ADDR
2653: LD_EXP 19
2657: PUSH
2658: FOR_TO
2659: IFFALSE 3031
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2661: LD_VAR 0 3
2665: PUSH
2666: LD_INT 1
2668: MINUS
2669: PUSH
2670: LD_EXP 19
2674: PUSH
2675: LD_INT 1
2677: MINUS
2678: PUSH
2679: LD_INT 4
2681: DIVREAL
2682: MOD
2683: PUSH
2684: LD_INT 0
2686: EQUAL
2687: IFFALSE 2703
// cl := cl + 1 ;
2689: LD_ADDR_VAR 0 4
2693: PUSH
2694: LD_VAR 0 4
2698: PUSH
2699: LD_INT 1
2701: PLUS
2702: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2703: LD_INT 0
2705: PPUSH
2706: LD_VAR 0 4
2710: PPUSH
2711: LD_EXP 20
2715: PPUSH
2716: CALL_OW 380
// un := CreateHuman ;
2720: LD_ADDR_VAR 0 5
2724: PUSH
2725: CALL_OW 44
2729: ST_TO_ADDR
// if j > copy then
2730: LD_VAR 0 3
2734: PUSH
2735: LD_VAR 0 8
2739: GREATER
2740: IFFALSE 2769
// copy := Replace ( copy , j , un ) else
2742: LD_ADDR_VAR 0 8
2746: PUSH
2747: LD_VAR 0 8
2751: PPUSH
2752: LD_VAR 0 3
2756: PPUSH
2757: LD_VAR 0 5
2761: PPUSH
2762: CALL_OW 1
2766: ST_TO_ADDR
2767: GO 2851
// begin CopySkills ( copy [ j ] , un ) ;
2769: LD_VAR 0 8
2773: PUSH
2774: LD_VAR 0 3
2778: ARRAY
2779: PPUSH
2780: LD_VAR 0 5
2784: PPUSH
2785: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2789: LD_VAR 0 5
2793: PPUSH
2794: LD_INT 2
2796: PPUSH
2797: LD_VAR 0 8
2801: PUSH
2802: LD_VAR 0 3
2806: ARRAY
2807: PPUSH
2808: LD_INT 2
2810: PPUSH
2811: CALL_OW 260
2815: PPUSH
2816: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2820: LD_VAR 0 5
2824: PPUSH
2825: LD_INT 1
2827: PPUSH
2828: LD_VAR 0 8
2832: PUSH
2833: LD_VAR 0 3
2837: ARRAY
2838: PPUSH
2839: LD_INT 1
2841: PPUSH
2842: CALL_OW 260
2846: PPUSH
2847: CALL_OW 239
// end ; if multi_pos_area then
2851: LD_EXP 12
2855: IFFALSE 3029
// begin if GetClass ( un ) = 3 then
2857: LD_VAR 0 5
2861: PPUSH
2862: CALL_OW 257
2866: PUSH
2867: LD_INT 3
2869: EQUAL
2870: IFFALSE 2996
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2872: LD_INT 3
2874: PUSH
2875: LD_INT 2
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PUSH
2882: LD_VAR 0 3
2886: PUSH
2887: LD_INT 2
2889: MOD
2890: PUSH
2891: LD_INT 1
2893: PLUS
2894: ARRAY
2895: PPUSH
2896: LD_INT 2
2898: PPUSH
2899: LD_INT 1
2901: PPUSH
2902: LD_INT 5
2904: PUSH
2905: LD_INT 4
2907: PUSH
2908: LD_INT 3
2910: PUSH
2911: EMPTY
2912: LIST
2913: LIST
2914: LIST
2915: PUSH
2916: LD_VAR 0 3
2920: PUSH
2921: LD_INT 3
2923: MOD
2924: PUSH
2925: LD_INT 1
2927: PLUS
2928: ARRAY
2929: PPUSH
2930: LD_INT 100
2932: PPUSH
2933: CALL 14210 0 5
// veh := CreateVehicle ;
2937: LD_ADDR_VAR 0 6
2941: PUSH
2942: CALL_OW 45
2946: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
2947: LD_VAR 0 6
2951: PPUSH
2952: LD_EXP 12
2956: PUSH
2957: LD_EXP 7
2961: PUSH
2962: LD_VAR 0 2
2966: ARRAY
2967: ARRAY
2968: PUSH
2969: LD_INT 2
2971: ARRAY
2972: PPUSH
2973: LD_INT 0
2975: PPUSH
2976: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
2980: LD_VAR 0 5
2984: PPUSH
2985: LD_VAR 0 6
2989: PPUSH
2990: CALL_OW 52
// continue ;
2994: GO 2658
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2996: LD_VAR 0 5
3000: PPUSH
3001: LD_EXP 12
3005: PUSH
3006: LD_EXP 7
3010: PUSH
3011: LD_VAR 0 2
3015: ARRAY
3016: ARRAY
3017: PUSH
3018: LD_INT 1
3020: ARRAY
3021: PPUSH
3022: LD_INT 0
3024: PPUSH
3025: CALL_OW 49
// end ; end ;
3029: GO 2658
3031: POP
3032: POP
// for j = 1 to 3 do
3033: LD_ADDR_VAR 0 3
3037: PUSH
3038: DOUBLE
3039: LD_INT 1
3041: DEC
3042: ST_TO_ADDR
3043: LD_INT 3
3045: PUSH
3046: FOR_TO
3047: IFFALSE 3139
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3049: LD_INT 2
3051: PUSH
3052: LD_INT 3
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PUSH
3059: LD_INT 1
3061: PPUSH
3062: LD_INT 2
3064: PPUSH
3065: CALL_OW 12
3069: ARRAY
3070: PPUSH
3071: LD_INT 2
3073: PPUSH
3074: LD_INT 3
3076: PPUSH
3077: LD_INT 11
3079: PUSH
3080: LD_INT 7
3082: PUSH
3083: LD_INT 4
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: PUSH
3091: LD_VAR 0 3
3095: ARRAY
3096: PPUSH
3097: LD_INT 100
3099: PPUSH
3100: CALL 14210 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3104: CALL_OW 45
3108: PPUSH
3109: LD_EXP 12
3113: PUSH
3114: LD_EXP 7
3118: PUSH
3119: LD_VAR 0 2
3123: ARRAY
3124: ARRAY
3125: PUSH
3126: LD_INT 1
3128: ARRAY
3129: PPUSH
3130: LD_INT 0
3132: PPUSH
3133: CALL_OW 49
// end ;
3137: GO 3046
3139: POP
3140: POP
// end ;
3141: GO 2252
3143: POP
3144: POP
// end ;
3145: LD_VAR 0 1
3149: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3150: LD_INT 0
3152: PPUSH
3153: PPUSH
3154: PPUSH
3155: PPUSH
3156: PPUSH
// if not multi_support then
3157: LD_EXP 23
3161: NOT
3162: IFFALSE 3166
// exit ;
3164: GO 3694
// result := [ ] ;
3166: LD_ADDR_VAR 0 1
3170: PUSH
3171: EMPTY
3172: ST_TO_ADDR
// for i = 1 to 8 do
3173: LD_ADDR_VAR 0 2
3177: PUSH
3178: DOUBLE
3179: LD_INT 1
3181: DEC
3182: ST_TO_ADDR
3183: LD_INT 8
3185: PUSH
3186: FOR_TO
3187: IFFALSE 3692
// begin if multi_sides [ i ] then
3189: LD_EXP 7
3193: PUSH
3194: LD_VAR 0 2
3198: ARRAY
3199: IFFALSE 3690
// begin tmp := [ ] ;
3201: LD_ADDR_VAR 0 5
3205: PUSH
3206: EMPTY
3207: ST_TO_ADDR
// if multi_support = 1 then
3208: LD_EXP 23
3212: PUSH
3213: LD_INT 1
3215: EQUAL
3216: IFFALSE 3384
// begin uc_side := i ;
3218: LD_ADDR_OWVAR 20
3222: PUSH
3223: LD_VAR 0 2
3227: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3228: LD_ADDR_OWVAR 21
3232: PUSH
3233: LD_EXP 9
3237: PUSH
3238: LD_VAR 0 2
3242: ARRAY
3243: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3244: LD_INT 3
3246: PPUSH
3247: LD_INT 1
3249: PPUSH
3250: LD_INT 3
3252: PPUSH
3253: LD_INT 11
3255: PPUSH
3256: LD_INT 40
3258: PPUSH
3259: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3263: LD_ADDR_VAR 0 5
3267: PUSH
3268: LD_VAR 0 5
3272: PUSH
3273: CALL_OW 45
3277: ADD
3278: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3279: LD_INT 2
3281: PPUSH
3282: LD_INT 1
3284: PPUSH
3285: LD_INT 3
3287: PPUSH
3288: LD_INT 5
3290: PPUSH
3291: LD_INT 40
3293: PPUSH
3294: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3298: LD_ADDR_VAR 0 5
3302: PUSH
3303: LD_VAR 0 5
3307: PUSH
3308: CALL_OW 45
3312: ADD
3313: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3314: LD_INT 2
3316: PPUSH
3317: LD_INT 3
3319: PPUSH
3320: LD_INT 3
3322: PPUSH
3323: LD_INT 4
3325: PPUSH
3326: LD_INT 40
3328: PPUSH
3329: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3333: LD_ADDR_VAR 0 5
3337: PUSH
3338: LD_VAR 0 5
3342: PUSH
3343: CALL_OW 45
3347: ADD
3348: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3349: LD_INT 3
3351: PPUSH
3352: LD_INT 2
3354: PPUSH
3355: LD_INT 3
3357: PPUSH
3358: LD_INT 9
3360: PPUSH
3361: LD_INT 40
3363: PPUSH
3364: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3368: LD_ADDR_VAR 0 5
3372: PUSH
3373: LD_VAR 0 5
3377: PUSH
3378: CALL_OW 45
3382: ADD
3383: ST_TO_ADDR
// end ; if multi_support = 2 then
3384: LD_EXP 23
3388: PUSH
3389: LD_INT 2
3391: EQUAL
3392: IFFALSE 3665
// begin uc_side := i ;
3394: LD_ADDR_OWVAR 20
3398: PUSH
3399: LD_VAR 0 2
3403: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3404: LD_ADDR_OWVAR 21
3408: PUSH
3409: LD_EXP 9
3413: PUSH
3414: LD_VAR 0 2
3418: ARRAY
3419: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3420: LD_INT 3
3422: PPUSH
3423: LD_INT 1
3425: PPUSH
3426: LD_INT 3
3428: PPUSH
3429: LD_INT 11
3431: PPUSH
3432: LD_INT 40
3434: PPUSH
3435: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3439: LD_ADDR_VAR 0 5
3443: PUSH
3444: LD_VAR 0 5
3448: PUSH
3449: CALL_OW 45
3453: ADD
3454: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3455: LD_INT 3
3457: PPUSH
3458: LD_INT 3
3460: PPUSH
3461: LD_INT 3
3463: PPUSH
3464: LD_INT 12
3466: PPUSH
3467: LD_INT 40
3469: PPUSH
3470: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3474: LD_ADDR_VAR 0 5
3478: PUSH
3479: LD_VAR 0 5
3483: PUSH
3484: CALL_OW 45
3488: ADD
3489: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3490: LD_INT 2
3492: PPUSH
3493: LD_INT 3
3495: PPUSH
3496: LD_INT 3
3498: PPUSH
3499: LD_INT 5
3501: PPUSH
3502: LD_INT 40
3504: PPUSH
3505: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3509: LD_ADDR_VAR 0 5
3513: PUSH
3514: LD_VAR 0 5
3518: PUSH
3519: CALL_OW 45
3523: ADD
3524: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3525: LD_INT 4
3527: PPUSH
3528: LD_INT 1
3530: PPUSH
3531: LD_INT 3
3533: PPUSH
3534: LD_INT 6
3536: PPUSH
3537: LD_INT 40
3539: PPUSH
3540: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3544: LD_ADDR_VAR 0 5
3548: PUSH
3549: LD_VAR 0 5
3553: PUSH
3554: CALL_OW 45
3558: ADD
3559: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3560: LD_INT 2
3562: PPUSH
3563: LD_INT 3
3565: PPUSH
3566: LD_INT 3
3568: PPUSH
3569: LD_INT 9
3571: PPUSH
3572: LD_INT 40
3574: PPUSH
3575: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3579: LD_ADDR_VAR 0 5
3583: PUSH
3584: LD_VAR 0 5
3588: PUSH
3589: CALL_OW 45
3593: ADD
3594: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3595: LD_INT 2
3597: PPUSH
3598: LD_INT 3
3600: PPUSH
3601: LD_INT 3
3603: PPUSH
3604: LD_INT 9
3606: PPUSH
3607: LD_INT 40
3609: PPUSH
3610: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3614: LD_ADDR_VAR 0 5
3618: PUSH
3619: LD_VAR 0 5
3623: PUSH
3624: CALL_OW 45
3628: ADD
3629: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3630: LD_INT 4
3632: PPUSH
3633: LD_INT 1
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: LD_INT 6
3641: PPUSH
3642: LD_INT 40
3644: PPUSH
3645: CALL 14210 0 5
// tmp := tmp ^ CreateVehicle ;
3649: LD_ADDR_VAR 0 5
3653: PUSH
3654: LD_VAR 0 5
3658: PUSH
3659: CALL_OW 45
3663: ADD
3664: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3665: LD_ADDR_VAR 0 1
3669: PUSH
3670: LD_VAR 0 1
3674: PPUSH
3675: LD_VAR 0 2
3679: PPUSH
3680: LD_VAR 0 5
3684: PPUSH
3685: CALL_OW 2
3689: ST_TO_ADDR
// end ; end ;
3690: GO 3186
3692: POP
3693: POP
// end ;
3694: LD_VAR 0 1
3698: RET
// export function Multiplayer_Start ( ) ; begin
3699: LD_INT 0
3701: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3702: CALL 2228 0 0
// Multiplayer_InitPointSystem ( ) ;
3706: CALL 4623 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3710: LD_INT 20
3712: PPUSH
3713: CALL 4799 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3717: LD_INT 150
3719: PPUSH
3720: CALL 4799 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3724: LD_INT 5
3726: PPUSH
3727: CALL 4799 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3731: LD_INT 40
3733: NEG
3734: PPUSH
3735: CALL 4799 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3739: LD_INT 200
3741: PPUSH
3742: CALL 4799 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3746: LD_INT 2
3748: PPUSH
3749: CALL 4799 0 1
// Multiplayer_SpawnArtifact ;
3753: CALL 5239 0 0
// if multi_support then
3757: LD_EXP 23
3761: IFFALSE 3773
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3763: LD_ADDR_EXP 27
3767: PUSH
3768: CALL 3150 0 0
3772: ST_TO_ADDR
// game := true ;
3773: LD_ADDR_EXP 2
3777: PUSH
3778: LD_INT 1
3780: ST_TO_ADDR
// if multi_sides [ your_side ] then
3781: LD_EXP 7
3785: PUSH
3786: LD_OWVAR 2
3790: ARRAY
3791: IFFALSE 3818
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3793: LD_INT 22
3795: PUSH
3796: LD_OWVAR 2
3800: PUSH
3801: EMPTY
3802: LIST
3803: LIST
3804: PPUSH
3805: CALL_OW 69
3809: PUSH
3810: LD_INT 1
3812: ARRAY
3813: PPUSH
3814: CALL_OW 87
// end ;
3818: LD_VAR 0 1
3822: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3823: LD_INT 0
3825: PPUSH
3826: PPUSH
3827: PPUSH
3828: PPUSH
3829: PPUSH
// reinforcements_arrive := 0 ;
3830: LD_ADDR_VAR 0 5
3834: PUSH
3835: LD_INT 0
3837: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3838: LD_INT 35
3840: PPUSH
3841: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3845: LD_OWVAR 1
3849: PUSH
3850: LD_INT 21000
3852: GREATER
3853: PUSH
3854: LD_EXP 28
3858: NOT
3859: AND
3860: PUSH
3861: LD_EXP 23
3865: PUSH
3866: LD_INT 1
3868: EQUAL
3869: AND
3870: IFFALSE 4065
// begin multi_reinforcements_spawned := 1 ;
3872: LD_ADDR_EXP 28
3876: PUSH
3877: LD_INT 1
3879: ST_TO_ADDR
// for i = 1 to 8 do
3880: LD_ADDR_VAR 0 2
3884: PUSH
3885: DOUBLE
3886: LD_INT 1
3888: DEC
3889: ST_TO_ADDR
3890: LD_INT 8
3892: PUSH
3893: FOR_TO
3894: IFFALSE 4053
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3896: LD_EXP 7
3900: PUSH
3901: LD_VAR 0 2
3905: ARRAY
3906: PUSH
3907: LD_EXP 25
3911: PUSH
3912: LD_VAR 0 2
3916: ARRAY
3917: NOT
3918: AND
3919: PUSH
3920: LD_EXP 27
3924: PUSH
3925: LD_VAR 0 2
3929: ARRAY
3930: AND
3931: IFFALSE 4051
// begin tmp := multi_reinforcements [ i ] ;
3933: LD_ADDR_VAR 0 4
3937: PUSH
3938: LD_EXP 27
3942: PUSH
3943: LD_VAR 0 2
3947: ARRAY
3948: ST_TO_ADDR
// for j = 1 to 4 do
3949: LD_ADDR_VAR 0 3
3953: PUSH
3954: DOUBLE
3955: LD_INT 1
3957: DEC
3958: ST_TO_ADDR
3959: LD_INT 4
3961: PUSH
3962: FOR_TO
3963: IFFALSE 4024
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3965: LD_VAR 0 4
3969: PUSH
3970: LD_VAR 0 3
3974: ARRAY
3975: PPUSH
3976: LD_EXP 12
3980: PUSH
3981: LD_EXP 7
3985: PUSH
3986: LD_VAR 0 2
3990: ARRAY
3991: ARRAY
3992: PUSH
3993: LD_INT 2
3995: ARRAY
3996: PPUSH
3997: LD_INT 0
3999: PPUSH
4000: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4004: LD_ADDR_VAR 0 4
4008: PUSH
4009: LD_VAR 0 4
4013: PPUSH
4014: LD_INT 1
4016: PPUSH
4017: CALL_OW 3
4021: ST_TO_ADDR
// end ;
4022: GO 3962
4024: POP
4025: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4026: LD_ADDR_EXP 27
4030: PUSH
4031: LD_EXP 27
4035: PPUSH
4036: LD_VAR 0 2
4040: PPUSH
4041: LD_VAR 0 4
4045: PPUSH
4046: CALL_OW 1
4050: ST_TO_ADDR
// end ; end ;
4051: GO 3893
4053: POP
4054: POP
// reinforcements_arrive := tick ;
4055: LD_ADDR_VAR 0 5
4059: PUSH
4060: LD_OWVAR 1
4064: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4065: LD_VAR 0 5
4069: PUSH
4070: LD_INT 21000
4072: PLUS
4073: PUSH
4074: LD_OWVAR 1
4078: LESS
4079: PUSH
4080: LD_EXP 28
4084: PUSH
4085: LD_INT 1
4087: EQUAL
4088: AND
4089: PUSH
4090: LD_EXP 23
4094: PUSH
4095: LD_INT 2
4097: EQUAL
4098: AND
4099: IFFALSE 4284
// begin multi_reinforcements_spawned := 2 ;
4101: LD_ADDR_EXP 28
4105: PUSH
4106: LD_INT 2
4108: ST_TO_ADDR
// for i = 1 to 8 do
4109: LD_ADDR_VAR 0 2
4113: PUSH
4114: DOUBLE
4115: LD_INT 1
4117: DEC
4118: ST_TO_ADDR
4119: LD_INT 8
4121: PUSH
4122: FOR_TO
4123: IFFALSE 4282
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4125: LD_EXP 7
4129: PUSH
4130: LD_VAR 0 2
4134: ARRAY
4135: PUSH
4136: LD_EXP 25
4140: PUSH
4141: LD_VAR 0 2
4145: ARRAY
4146: NOT
4147: AND
4148: PUSH
4149: LD_EXP 27
4153: PUSH
4154: LD_VAR 0 2
4158: ARRAY
4159: AND
4160: IFFALSE 4280
// begin tmp := multi_reinforcements [ i ] ;
4162: LD_ADDR_VAR 0 4
4166: PUSH
4167: LD_EXP 27
4171: PUSH
4172: LD_VAR 0 2
4176: ARRAY
4177: ST_TO_ADDR
// for j = 1 to 3 do
4178: LD_ADDR_VAR 0 3
4182: PUSH
4183: DOUBLE
4184: LD_INT 1
4186: DEC
4187: ST_TO_ADDR
4188: LD_INT 3
4190: PUSH
4191: FOR_TO
4192: IFFALSE 4253
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4194: LD_VAR 0 4
4198: PUSH
4199: LD_VAR 0 3
4203: ARRAY
4204: PPUSH
4205: LD_EXP 12
4209: PUSH
4210: LD_EXP 7
4214: PUSH
4215: LD_VAR 0 2
4219: ARRAY
4220: ARRAY
4221: PUSH
4222: LD_INT 2
4224: ARRAY
4225: PPUSH
4226: LD_INT 0
4228: PPUSH
4229: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4233: LD_ADDR_VAR 0 4
4237: PUSH
4238: LD_VAR 0 4
4242: PPUSH
4243: LD_INT 1
4245: PPUSH
4246: CALL_OW 3
4250: ST_TO_ADDR
// end ;
4251: GO 4191
4253: POP
4254: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4255: LD_ADDR_EXP 27
4259: PUSH
4260: LD_EXP 27
4264: PPUSH
4265: LD_VAR 0 2
4269: PPUSH
4270: LD_VAR 0 4
4274: PPUSH
4275: CALL_OW 1
4279: ST_TO_ADDR
// end ; end ;
4280: GO 4122
4282: POP
4283: POP
// end ; if not multi_custom_commanders then
4284: LD_EXP 16
4288: NOT
4289: IFFALSE 4402
// begin for i = 1 to 8 do
4291: LD_ADDR_VAR 0 2
4295: PUSH
4296: DOUBLE
4297: LD_INT 1
4299: DEC
4300: ST_TO_ADDR
4301: LD_INT 8
4303: PUSH
4304: FOR_TO
4305: IFFALSE 4376
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4307: LD_INT 22
4309: PUSH
4310: LD_VAR 0 2
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PPUSH
4319: CALL_OW 69
4323: PUSH
4324: LD_INT 0
4326: EQUAL
4327: PUSH
4328: LD_EXP 25
4332: PUSH
4333: LD_VAR 0 2
4337: ARRAY
4338: NOT
4339: AND
4340: IFFALSE 4374
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4342: LD_ADDR_EXP 25
4346: PUSH
4347: LD_EXP 25
4351: PPUSH
4352: LD_VAR 0 2
4356: PPUSH
4357: LD_INT 1
4359: PPUSH
4360: CALL_OW 1
4364: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4365: LD_VAR 0 2
4369: PPUSH
4370: CALL 4869 0 1
// end ; end ;
4374: GO 4304
4376: POP
4377: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4378: LD_EXP 25
4382: PPUSH
4383: CALL 11484 0 1
4387: PUSH
4388: LD_EXP 7
4392: PPUSH
4393: CALL 11484 0 1
4397: EQUAL
4398: IFFALSE 4402
// break ;
4400: GO 4437
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4402: LD_INT 22
4404: PUSH
4405: LD_EXP 3
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: PPUSH
4414: CALL_OW 69
4418: PUSH
4419: LD_INT 0
4421: EQUAL
4422: PUSH
4423: LD_EXP 2
4427: AND
4428: PUSH
4429: LD_EXP 24
4433: NOT
4434: OR
4435: IFFALSE 3838
// game := false ;
4437: LD_ADDR_EXP 2
4441: PUSH
4442: LD_INT 0
4444: ST_TO_ADDR
// for i = 1 to 8 do
4445: LD_ADDR_VAR 0 2
4449: PUSH
4450: DOUBLE
4451: LD_INT 1
4453: DEC
4454: ST_TO_ADDR
4455: LD_INT 8
4457: PUSH
4458: FOR_TO
4459: IFFALSE 4495
// begin if multi_sides [ i ] then
4461: LD_EXP 7
4465: PUSH
4466: LD_VAR 0 2
4470: ARRAY
4471: IFFALSE 4493
// SetMultiScore ( i , multi_points [ i ] ) ;
4473: LD_VAR 0 2
4477: PPUSH
4478: LD_EXP 29
4482: PUSH
4483: LD_VAR 0 2
4487: ARRAY
4488: PPUSH
4489: CALL_OW 506
// end ;
4493: GO 4458
4495: POP
4496: POP
// if multi_loosers [ your_side ] then
4497: LD_EXP 25
4501: PUSH
4502: LD_OWVAR 2
4506: ARRAY
4507: IFFALSE 4515
// YouLostInMultiplayer else
4509: CALL_OW 107
4513: GO 4519
// YouWinInMultiplayer ;
4515: CALL_OW 106
// end ;
4519: LD_VAR 0 1
4523: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4524: LD_INT 0
4526: PPUSH
4527: PPUSH
// result := [ #tick , tick ] ;
4528: LD_ADDR_VAR 0 1
4532: PUSH
4533: LD_STRING #tick
4535: PUSH
4536: LD_OWVAR 1
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: ST_TO_ADDR
// for i = 1 to 8 do
4545: LD_ADDR_VAR 0 2
4549: PUSH
4550: DOUBLE
4551: LD_INT 1
4553: DEC
4554: ST_TO_ADDR
4555: LD_INT 8
4557: PUSH
4558: FOR_TO
4559: IFFALSE 4616
// begin if multi_sides [ i ] then
4561: LD_EXP 7
4565: PUSH
4566: LD_VAR 0 2
4570: ARRAY
4571: IFFALSE 4614
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4573: LD_ADDR_VAR 0 1
4577: PUSH
4578: LD_VAR 0 1
4582: PUSH
4583: LD_STRING #coop-points
4585: PUSH
4586: LD_VAR 0 2
4590: PUSH
4591: LD_VAR 0 2
4595: PUSH
4596: LD_EXP 29
4600: PUSH
4601: LD_VAR 0 2
4605: ARRAY
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: LIST
4611: LIST
4612: ADD
4613: ST_TO_ADDR
// end ; end ;
4614: GO 4558
4616: POP
4617: POP
// end ;
4618: LD_VAR 0 1
4622: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4623: LD_INT 0
4625: PPUSH
4626: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4627: LD_ADDR_EXP 29
4631: PUSH
4632: LD_INT 0
4634: PUSH
4635: LD_INT 0
4637: PUSH
4638: LD_INT 0
4640: PUSH
4641: LD_INT 0
4643: PUSH
4644: LD_INT 0
4646: PUSH
4647: LD_INT 0
4649: PUSH
4650: LD_INT 0
4652: PUSH
4653: LD_INT 0
4655: PUSH
4656: EMPTY
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4666: LD_ADDR_EXP 30
4670: PUSH
4671: EMPTY
4672: ST_TO_ADDR
// end ;
4673: LD_VAR 0 1
4677: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4678: LD_INT 0
4680: PPUSH
// if not multi_points or not side or side > 8 then
4681: LD_EXP 29
4685: NOT
4686: PUSH
4687: LD_VAR 0 1
4691: NOT
4692: OR
4693: PUSH
4694: LD_VAR 0 1
4698: PUSH
4699: LD_INT 8
4701: GREATER
4702: OR
4703: IFFALSE 4707
// exit ;
4705: GO 4744
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4707: LD_ADDR_EXP 29
4711: PUSH
4712: LD_EXP 29
4716: PPUSH
4717: LD_VAR 0 1
4721: PPUSH
4722: LD_EXP 29
4726: PUSH
4727: LD_VAR 0 1
4731: ARRAY
4732: PUSH
4733: LD_VAR 0 2
4737: PLUS
4738: PPUSH
4739: CALL_OW 1
4743: ST_TO_ADDR
// end ;
4744: LD_VAR 0 3
4748: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4749: LD_INT 0
4751: PPUSH
// if not multi_points or not side or side > 8 then
4752: LD_EXP 29
4756: NOT
4757: PUSH
4758: LD_VAR 0 1
4762: NOT
4763: OR
4764: PUSH
4765: LD_VAR 0 1
4769: PUSH
4770: LD_INT 8
4772: GREATER
4773: OR
4774: IFFALSE 4778
// exit ;
4776: GO 4794
// result := multi_points [ side ] ;
4778: LD_ADDR_VAR 0 2
4782: PUSH
4783: LD_EXP 29
4787: PUSH
4788: LD_VAR 0 1
4792: ARRAY
4793: ST_TO_ADDR
// end ;
4794: LD_VAR 0 2
4798: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4799: LD_INT 0
4801: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4802: LD_ADDR_EXP 30
4806: PUSH
4807: LD_EXP 30
4811: PPUSH
4812: LD_EXP 30
4816: PUSH
4817: LD_INT 1
4819: PLUS
4820: PPUSH
4821: LD_VAR 0 1
4825: PPUSH
4826: CALL_OW 2
4830: ST_TO_ADDR
// end ;
4831: LD_VAR 0 2
4835: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4836: LD_INT 0
4838: PPUSH
// if not id then
4839: LD_VAR 0 1
4843: NOT
4844: IFFALSE 4848
// exit ;
4846: GO 4864
// result := multi_points_conditions [ id ] ;
4848: LD_ADDR_VAR 0 2
4852: PUSH
4853: LD_EXP 30
4857: PUSH
4858: LD_VAR 0 1
4862: ARRAY
4863: ST_TO_ADDR
// end ;
4864: LD_VAR 0 2
4868: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4869: LD_INT 0
4871: PPUSH
4872: PPUSH
4873: PPUSH
4874: PPUSH
4875: PPUSH
// players := [ ] ;
4876: LD_ADDR_VAR 0 3
4880: PUSH
4881: EMPTY
4882: ST_TO_ADDR
// for i = 1 to 8 do
4883: LD_ADDR_VAR 0 4
4887: PUSH
4888: DOUBLE
4889: LD_INT 1
4891: DEC
4892: ST_TO_ADDR
4893: LD_INT 8
4895: PUSH
4896: FOR_TO
4897: IFFALSE 4956
// begin if i = side then
4899: LD_VAR 0 4
4903: PUSH
4904: LD_VAR 0 1
4908: EQUAL
4909: IFFALSE 4913
// continue ;
4911: GO 4896
// if multi_sides [ i ] and not multi_loosers [ i ] then
4913: LD_EXP 7
4917: PUSH
4918: LD_VAR 0 4
4922: ARRAY
4923: PUSH
4924: LD_EXP 25
4928: PUSH
4929: LD_VAR 0 4
4933: ARRAY
4934: NOT
4935: AND
4936: IFFALSE 4954
// players := players ^ i ;
4938: LD_ADDR_VAR 0 3
4942: PUSH
4943: LD_VAR 0 3
4947: PUSH
4948: LD_VAR 0 4
4952: ADD
4953: ST_TO_ADDR
// end ;
4954: GO 4896
4956: POP
4957: POP
// if not players then
4958: LD_VAR 0 3
4962: NOT
4963: IFFALSE 4967
// exit ;
4965: GO 5234
// if players = 1 then
4967: LD_VAR 0 3
4971: PUSH
4972: LD_INT 1
4974: EQUAL
4975: IFFALSE 5036
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
4977: LD_ADDR_VAR 0 4
4981: PUSH
4982: LD_INT 22
4984: PUSH
4985: LD_VAR 0 1
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: PUSH
4994: LD_INT 51
4996: PUSH
4997: EMPTY
4998: LIST
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PPUSH
5004: CALL_OW 69
5008: PUSH
5009: FOR_IN
5010: IFFALSE 5032
// SetSide ( i , players [ 1 ] ) ;
5012: LD_VAR 0 4
5016: PPUSH
5017: LD_VAR 0 3
5021: PUSH
5022: LD_INT 1
5024: ARRAY
5025: PPUSH
5026: CALL_OW 235
5030: GO 5009
5032: POP
5033: POP
// end else
5034: GO 5234
// begin j := 1 ;
5036: LD_ADDR_VAR 0 5
5040: PUSH
5041: LD_INT 1
5043: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5044: LD_ADDR_VAR 0 4
5048: PUSH
5049: LD_INT 22
5051: PUSH
5052: LD_VAR 0 1
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: PUSH
5061: LD_INT 2
5063: PUSH
5064: LD_INT 21
5066: PUSH
5067: LD_INT 1
5069: PUSH
5070: EMPTY
5071: LIST
5072: LIST
5073: PUSH
5074: LD_INT 51
5076: PUSH
5077: EMPTY
5078: LIST
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 21
5086: PUSH
5087: LD_INT 2
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: PUSH
5094: EMPTY
5095: LIST
5096: LIST
5097: LIST
5098: PUSH
5099: EMPTY
5100: LIST
5101: LIST
5102: PPUSH
5103: CALL_OW 69
5107: PUSH
5108: FOR_IN
5109: IFFALSE 5232
// begin SetSide ( i , players [ j ] ) ;
5111: LD_VAR 0 4
5115: PPUSH
5116: LD_VAR 0 3
5120: PUSH
5121: LD_VAR 0 5
5125: ARRAY
5126: PPUSH
5127: CALL_OW 235
// if IsDrivenBy ( i ) then
5131: LD_VAR 0 4
5135: PPUSH
5136: CALL_OW 311
5140: IFFALSE 5167
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5142: LD_VAR 0 4
5146: PPUSH
5147: CALL_OW 311
5151: PPUSH
5152: LD_VAR 0 3
5156: PUSH
5157: LD_VAR 0 5
5161: ARRAY
5162: PPUSH
5163: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5167: LD_VAR 0 4
5171: PPUSH
5172: CALL_OW 310
5176: PPUSH
5177: CALL_OW 247
5181: PUSH
5182: LD_INT 3
5184: EQUAL
5185: IFFALSE 5196
// ComExitBuilding ( i ) ;
5187: LD_VAR 0 4
5191: PPUSH
5192: CALL_OW 122
// j := j + 1 ;
5196: LD_ADDR_VAR 0 5
5200: PUSH
5201: LD_VAR 0 5
5205: PUSH
5206: LD_INT 1
5208: PLUS
5209: ST_TO_ADDR
// if j > players then
5210: LD_VAR 0 5
5214: PUSH
5215: LD_VAR 0 3
5219: GREATER
5220: IFFALSE 5230
// j := 1 ;
5222: LD_ADDR_VAR 0 5
5226: PUSH
5227: LD_INT 1
5229: ST_TO_ADDR
// end ;
5230: GO 5108
5232: POP
5233: POP
// end ; end ;
5234: LD_VAR 0 2
5238: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5239: LD_INT 0
5241: PPUSH
5242: PPUSH
5243: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5244: LD_ADDR_VAR 0 3
5248: PUSH
5249: LD_INT 5
5251: PUSH
5252: LD_INT 10
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: PUSH
5259: LD_INT 120
5261: PUSH
5262: LD_INT 2
5264: PUSH
5265: EMPTY
5266: LIST
5267: LIST
5268: PUSH
5269: LD_INT 101
5271: PUSH
5272: LD_INT 8
5274: PUSH
5275: EMPTY
5276: LIST
5277: LIST
5278: PUSH
5279: LD_INT 27
5281: PUSH
5282: LD_INT 4
5284: PUSH
5285: EMPTY
5286: LIST
5287: LIST
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: LIST
5293: LIST
5294: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5295: LD_ADDR_VAR 0 2
5299: PUSH
5300: LD_INT 1
5302: PPUSH
5303: LD_VAR 0 3
5307: PPUSH
5308: CALL_OW 12
5312: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5313: LD_INT 4
5315: PPUSH
5316: LD_INT 5
5318: PPUSH
5319: LD_VAR 0 3
5323: PUSH
5324: LD_VAR 0 2
5328: ARRAY
5329: PUSH
5330: LD_INT 1
5332: ARRAY
5333: PPUSH
5334: LD_VAR 0 3
5338: PUSH
5339: LD_VAR 0 2
5343: ARRAY
5344: PUSH
5345: LD_INT 2
5347: ARRAY
5348: PPUSH
5349: LD_INT 0
5351: PPUSH
5352: CALL_OW 58
// end ;
5356: LD_VAR 0 1
5360: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5361: LD_INT 0
5363: PPUSH
// if not side or side > 8 then
5364: LD_VAR 0 1
5368: NOT
5369: PUSH
5370: LD_VAR 0 1
5374: PUSH
5375: LD_INT 8
5377: GREATER
5378: OR
5379: IFFALSE 5383
// exit ;
5381: GO 5400
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5383: LD_VAR 0 1
5387: PPUSH
5388: LD_INT 6
5390: PPUSH
5391: CALL 4836 0 1
5395: PPUSH
5396: CALL 4678 0 2
// end ;
5400: LD_VAR 0 2
5404: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5405: LD_INT 0
5407: PPUSH
// if not side or side > 8 then
5408: LD_VAR 0 1
5412: NOT
5413: PUSH
5414: LD_VAR 0 1
5418: PUSH
5419: LD_INT 8
5421: GREATER
5422: OR
5423: IFFALSE 5427
// exit ;
5425: GO 5444
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5427: LD_VAR 0 1
5431: PPUSH
5432: LD_INT 4
5434: PPUSH
5435: CALL 4836 0 1
5439: PPUSH
5440: CALL 4678 0 2
// end ;
5444: LD_VAR 0 2
5448: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5449: LD_INT 0
5451: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5452: LD_VAR 0 1
5456: NOT
5457: PUSH
5458: LD_VAR 0 1
5462: PUSH
5463: LD_INT 8
5465: GREATER
5466: OR
5467: PUSH
5468: LD_VAR 0 2
5472: PUSH
5473: LD_INT 2
5475: PUSH
5476: LD_INT 6
5478: PUSH
5479: LD_INT 36
5481: PUSH
5482: LD_INT 0
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: LIST
5489: LIST
5490: IN
5491: NOT
5492: OR
5493: IFFALSE 5497
// exit ;
5495: GO 5514
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5497: LD_VAR 0 1
5501: PPUSH
5502: LD_INT 3
5504: PPUSH
5505: CALL 4836 0 1
5509: PPUSH
5510: CALL 4678 0 2
// end ;
5514: LD_VAR 0 3
5518: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5519: LD_INT 0
5521: PPUSH
5522: PPUSH
5523: PPUSH
5524: PPUSH
5525: PPUSH
5526: PPUSH
// if not un then
5527: LD_VAR 0 1
5531: NOT
5532: IFFALSE 5536
// exit ;
5534: GO 5760
// if not points then
5536: LD_VAR 0 2
5540: NOT
5541: IFFALSE 5558
// gained_points := Multiplayer_GetCondition ( 1 ) else
5543: LD_ADDR_VAR 0 8
5547: PUSH
5548: LD_INT 1
5550: PPUSH
5551: CALL 4836 0 1
5555: ST_TO_ADDR
5556: GO 5568
// gained_points := points ;
5558: LD_ADDR_VAR 0 8
5562: PUSH
5563: LD_VAR 0 2
5567: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5568: LD_ADDR_VAR 0 6
5572: PUSH
5573: LD_VAR 0 1
5577: PPUSH
5578: CALL_OW 503
5582: ST_TO_ADDR
// if last_shoot > - 1 then
5583: LD_VAR 0 6
5587: PUSH
5588: LD_INT 1
5590: NEG
5591: GREATER
5592: IFFALSE 5604
// begin side := last_shoot ;
5594: LD_ADDR_VAR 0 4
5598: PUSH
5599: LD_VAR 0 6
5603: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5604: LD_ADDR_VAR 0 7
5608: PUSH
5609: LD_OWVAR 3
5613: PUSH
5614: LD_INT 22
5616: PUSH
5617: LD_VAR 0 1
5621: PPUSH
5622: CALL_OW 255
5626: PUSH
5627: EMPTY
5628: LIST
5629: LIST
5630: PPUSH
5631: CALL_OW 69
5635: DIFF
5636: PPUSH
5637: LD_VAR 0 1
5641: PPUSH
5642: CALL_OW 74
5646: ST_TO_ADDR
// if nearest_unit then
5647: LD_VAR 0 7
5651: IFFALSE 5668
// side2 := GetSide ( nearest_unit ) ;
5653: LD_ADDR_VAR 0 5
5657: PUSH
5658: LD_VAR 0 7
5662: PPUSH
5663: CALL_OW 255
5667: ST_TO_ADDR
// if not side and not side2 then
5668: LD_VAR 0 4
5672: NOT
5673: PUSH
5674: LD_VAR 0 5
5678: NOT
5679: AND
5680: IFFALSE 5684
// exit ;
5682: GO 5760
// if side = side2 then
5684: LD_VAR 0 4
5688: PUSH
5689: LD_VAR 0 5
5693: EQUAL
5694: IFFALSE 5712
// Multiplayer_AddPoints ( side , gained_points ) else
5696: LD_VAR 0 4
5700: PPUSH
5701: LD_VAR 0 8
5705: PPUSH
5706: CALL 4678 0 2
5710: GO 5760
// begin if side then
5712: LD_VAR 0 4
5716: IFFALSE 5736
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5718: LD_VAR 0 4
5722: PPUSH
5723: LD_VAR 0 8
5727: PUSH
5728: LD_INT 2
5730: DIV
5731: PPUSH
5732: CALL 4678 0 2
// if side2 then
5736: LD_VAR 0 5
5740: IFFALSE 5760
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5742: LD_VAR 0 5
5746: PPUSH
5747: LD_VAR 0 8
5751: PUSH
5752: LD_INT 2
5754: DIV
5755: PPUSH
5756: CALL 4678 0 2
// end ; end ;
5760: LD_VAR 0 3
5764: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5765: LD_INT 0
5767: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5768: LD_VAR 0 1
5772: PPUSH
5773: LD_INT 2
5775: PPUSH
5776: CALL 4836 0 1
5780: PPUSH
5781: CALL 4678 0 2
// end ; end_of_file
5785: LD_VAR 0 2
5789: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5790: LD_INT 0
5792: PPUSH
5793: PPUSH
5794: PPUSH
5795: PPUSH
5796: PPUSH
5797: PPUSH
5798: PPUSH
5799: PPUSH
5800: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5801: LD_ADDR_VAR 0 9
5805: PUSH
5806: LD_INT 22
5808: PUSH
5809: LD_INT 2
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL_OW 69
5820: ST_TO_ADDR
// side_bot := side ;
5821: LD_ADDR_EXP 3
5825: PUSH
5826: LD_VAR 0 1
5830: ST_TO_ADDR
// if tmp and side <> 2 then
5831: LD_VAR 0 9
5835: PUSH
5836: LD_VAR 0 1
5840: PUSH
5841: LD_INT 2
5843: NONEQUAL
5844: AND
5845: IFFALSE 5882
// begin for i in tmp do
5847: LD_ADDR_VAR 0 3
5851: PUSH
5852: LD_VAR 0 9
5856: PUSH
5857: FOR_IN
5858: IFFALSE 5876
// SetSide ( i , side ) ;
5860: LD_VAR 0 3
5864: PPUSH
5865: LD_VAR 0 1
5869: PPUSH
5870: CALL_OW 235
5874: GO 5857
5876: POP
5877: POP
// ResetFog ;
5878: CALL_OW 335
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5882: LD_ADDR_VAR 0 10
5886: PUSH
5887: LD_INT 11
5889: PUSH
5890: LD_INT 4
5892: PUSH
5893: LD_INT 3
5895: PUSH
5896: LD_INT 5
5898: PUSH
5899: LD_INT 66
5901: PUSH
5902: LD_INT 67
5904: PUSH
5905: LD_INT 53
5907: PUSH
5908: LD_INT 18
5910: PUSH
5911: LD_INT 40
5913: PUSH
5914: LD_INT 22
5916: PUSH
5917: LD_INT 72
5919: PUSH
5920: LD_INT 55
5922: PUSH
5923: EMPTY
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: LIST
5936: ST_TO_ADDR
// for i in techs do
5937: LD_ADDR_VAR 0 3
5941: PUSH
5942: LD_VAR 0 10
5946: PUSH
5947: FOR_IN
5948: IFFALSE 5969
// SetTech ( i , side , state_researched ) ;
5950: LD_VAR 0 3
5954: PPUSH
5955: LD_VAR 0 1
5959: PPUSH
5960: LD_INT 2
5962: PPUSH
5963: CALL_OW 322
5967: GO 5947
5969: POP
5970: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
5971: LD_ADDR_VAR 0 8
5975: PUSH
5976: LD_INT 6
5978: PUSH
5979: LD_INT 7
5981: PUSH
5982: LD_INT 8
5984: PUSH
5985: EMPTY
5986: LIST
5987: LIST
5988: LIST
5989: PUSH
5990: LD_OWVAR 67
5994: ARRAY
5995: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
5996: LD_INT 69
5998: PUSH
5999: EMPTY
6000: LIST
6001: PPUSH
6002: LD_INT 141
6004: PPUSH
6005: CALL_OW 169
// Wait ( 1 ) ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 67
// uc_side := side ;
6016: LD_ADDR_OWVAR 20
6020: PUSH
6021: LD_VAR 0 1
6025: ST_TO_ADDR
// uc_nation := 2 ;
6026: LD_ADDR_OWVAR 21
6030: PUSH
6031: LD_INT 2
6033: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6034: LD_ADDR_EXP 33
6038: PUSH
6039: LD_INT 94
6041: PPUSH
6042: LD_INT 35
6044: PPUSH
6045: LD_STRING dammam
6047: PPUSH
6048: LD_VAR 0 8
6052: PPUSH
6053: LD_INT 10000
6055: PUSH
6056: LD_INT 1000
6058: PUSH
6059: LD_INT 300
6061: PUSH
6062: EMPTY
6063: LIST
6064: LIST
6065: LIST
6066: PPUSH
6067: LD_INT 12
6069: PUSH
6070: LD_INT 4
6072: PUSH
6073: LD_INT 1
6075: NEG
6076: PUSH
6077: LD_INT 4
6079: PUSH
6080: EMPTY
6081: LIST
6082: LIST
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL 17619 0 6
6090: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
6091: LD_ADDR_EXP 31
6095: PUSH
6096: LD_INT 45
6098: PPUSH
6099: LD_INT 34
6101: PPUSH
6102: LD_STRING jeddah
6104: PPUSH
6105: LD_VAR 0 8
6109: PPUSH
6110: LD_INT 700
6112: PUSH
6113: LD_INT 300
6115: PUSH
6116: LD_INT 10
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: LIST
6123: PPUSH
6124: LD_INT 10
6126: PUSH
6127: LD_INT 4
6129: PUSH
6130: LD_INT 3
6132: PUSH
6133: LD_INT 2
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL 17619 0 6
6146: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6147: LD_ADDR_EXP 32
6151: PUSH
6152: LD_INT 7
6154: PPUSH
6155: LD_INT 33
6157: PPUSH
6158: LD_STRING riyadh
6160: PPUSH
6161: LD_VAR 0 8
6165: PPUSH
6166: LD_INT 500
6168: PUSH
6169: LD_INT 60
6171: PUSH
6172: LD_INT 0
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: PPUSH
6180: LD_INT 4
6182: PUSH
6183: LD_INT 2
6185: PUSH
6186: LD_INT 3
6188: PUSH
6189: LD_INT 1
6191: PUSH
6192: EMPTY
6193: LIST
6194: LIST
6195: LIST
6196: LIST
6197: PPUSH
6198: CALL 17619 0 6
6202: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
6203: LD_ADDR_EXP 34
6207: PUSH
6208: LD_INT 69
6210: PPUSH
6211: LD_INT 36
6213: PPUSH
6214: LD_STRING 
6216: PPUSH
6217: LD_VAR 0 8
6221: PPUSH
6222: LD_INT 500
6224: PUSH
6225: LD_INT 50
6227: PUSH
6228: LD_INT 0
6230: PUSH
6231: EMPTY
6232: LIST
6233: LIST
6234: LIST
6235: PPUSH
6236: LD_INT 10
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: LD_INT 3
6244: PUSH
6245: LD_INT 1
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: LIST
6252: LIST
6253: PPUSH
6254: CALL 17619 0 6
6258: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south ] ;
6259: LD_ADDR_EXP 42
6263: PUSH
6264: LD_EXP 33
6268: PUSH
6269: LD_EXP 31
6273: PUSH
6274: LD_EXP 34
6278: PUSH
6279: LD_EXP 32
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6290: LD_ADDR_OWVAR 37
6294: PUSH
6295: LD_INT 14
6297: ST_TO_ADDR
// vc_engine := engine_siberite ;
6298: LD_ADDR_OWVAR 39
6302: PUSH
6303: LD_INT 3
6305: ST_TO_ADDR
// vc_control := control_manual ;
6306: LD_ADDR_OWVAR 38
6310: PUSH
6311: LD_INT 1
6313: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6314: LD_ADDR_OWVAR 40
6318: PUSH
6319: LD_INT 31
6321: ST_TO_ADDR
// for i = 1 to 5 do
6322: LD_ADDR_VAR 0 3
6326: PUSH
6327: DOUBLE
6328: LD_INT 1
6330: DEC
6331: ST_TO_ADDR
6332: LD_INT 5
6334: PUSH
6335: FOR_TO
6336: IFFALSE 6605
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6338: LD_ADDR_VAR 0 5
6342: PUSH
6343: LD_INT 156
6345: PUSH
6346: LD_INT 15
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: PUSH
6353: LD_INT 12
6355: PUSH
6356: LD_INT 7
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: PUSH
6367: LD_VAR 0 3
6371: PUSH
6372: LD_INT 2
6374: MOD
6375: PUSH
6376: LD_INT 1
6378: PLUS
6379: ARRAY
6380: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6381: LD_INT 0
6383: PPUSH
6384: LD_INT 3
6386: PPUSH
6387: LD_VAR 0 8
6391: PPUSH
6392: CALL_OW 380
// un := CreateVehicle ;
6396: LD_ADDR_VAR 0 6
6400: PUSH
6401: CALL_OW 45
6405: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6406: LD_VAR 0 6
6410: PPUSH
6411: LD_INT 0
6413: PPUSH
6414: LD_INT 5
6416: PPUSH
6417: CALL_OW 12
6421: PPUSH
6422: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6426: LD_VAR 0 6
6430: PPUSH
6431: LD_VAR 0 5
6435: PUSH
6436: LD_INT 1
6438: ARRAY
6439: PPUSH
6440: LD_VAR 0 5
6444: PUSH
6445: LD_INT 2
6447: ARRAY
6448: PPUSH
6449: LD_INT 6
6451: PPUSH
6452: LD_INT 0
6454: PPUSH
6455: CALL_OW 50
// un2 := CreateHuman ;
6459: LD_ADDR_VAR 0 7
6463: PUSH
6464: CALL_OW 44
6468: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6469: LD_VAR 0 7
6473: PPUSH
6474: LD_VAR 0 6
6478: PPUSH
6479: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6483: LD_ADDR_EXP 42
6487: PUSH
6488: LD_EXP 42
6492: PPUSH
6493: LD_VAR 0 3
6497: PUSH
6498: LD_INT 2
6500: MOD
6501: PUSH
6502: LD_INT 1
6504: PLUS
6505: PUSH
6506: LD_EXP 42
6510: PUSH
6511: LD_VAR 0 3
6515: PUSH
6516: LD_INT 2
6518: MOD
6519: PUSH
6520: LD_INT 1
6522: PLUS
6523: ARRAY
6524: PUSH
6525: LD_INT 1
6527: PLUS
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: PPUSH
6533: LD_VAR 0 6
6537: PPUSH
6538: CALL 14332 0 3
6542: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6543: LD_ADDR_EXP 42
6547: PUSH
6548: LD_EXP 42
6552: PPUSH
6553: LD_VAR 0 3
6557: PUSH
6558: LD_INT 2
6560: MOD
6561: PUSH
6562: LD_INT 1
6564: PLUS
6565: PUSH
6566: LD_EXP 42
6570: PUSH
6571: LD_VAR 0 3
6575: PUSH
6576: LD_INT 2
6578: MOD
6579: PUSH
6580: LD_INT 1
6582: PLUS
6583: ARRAY
6584: PUSH
6585: LD_INT 1
6587: PLUS
6588: PUSH
6589: EMPTY
6590: LIST
6591: LIST
6592: PPUSH
6593: LD_VAR 0 7
6597: PPUSH
6598: CALL 14332 0 3
6602: ST_TO_ADDR
// end ;
6603: GO 6335
6605: POP
6606: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6607: LD_ADDR_VAR 0 3
6611: PUSH
6612: LD_INT 22
6614: PUSH
6615: LD_EXP 3
6619: PUSH
6620: EMPTY
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 30
6626: PUSH
6627: LD_INT 31
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PUSH
6634: LD_INT 58
6636: PUSH
6637: EMPTY
6638: LIST
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: LIST
6644: PPUSH
6645: CALL_OW 69
6649: PUSH
6650: FOR_IN
6651: IFFALSE 6776
// begin if GetBase ( i ) then
6653: LD_VAR 0 3
6657: PPUSH
6658: CALL_OW 274
6662: IFFALSE 6666
// continue ;
6664: GO 6650
// d := GetDir ( i ) ;
6666: LD_ADDR_VAR 0 4
6670: PUSH
6671: LD_VAR 0 3
6675: PPUSH
6676: CALL_OW 254
6680: ST_TO_ADDR
// if d < 3 then
6681: LD_VAR 0 4
6685: PUSH
6686: LD_INT 3
6688: LESS
6689: IFFALSE 6707
// d := d + 3 else
6691: LD_ADDR_VAR 0 4
6695: PUSH
6696: LD_VAR 0 4
6700: PUSH
6701: LD_INT 3
6703: PLUS
6704: ST_TO_ADDR
6705: GO 6721
// d := d - 3 ;
6707: LD_ADDR_VAR 0 4
6711: PUSH
6712: LD_VAR 0 4
6716: PUSH
6717: LD_INT 3
6719: MINUS
6720: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6721: LD_INT 0
6723: PPUSH
6724: LD_INT 8
6726: PPUSH
6727: LD_VAR 0 8
6731: PPUSH
6732: CALL_OW 380
// un := CreateHuman ;
6736: LD_ADDR_VAR 0 6
6740: PUSH
6741: CALL_OW 44
6745: ST_TO_ADDR
// SetDir ( un , d ) ;
6746: LD_VAR 0 6
6750: PPUSH
6751: LD_VAR 0 4
6755: PPUSH
6756: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6760: LD_VAR 0 6
6764: PPUSH
6765: LD_VAR 0 3
6769: PPUSH
6770: CALL_OW 52
// end ;
6774: GO 6650
6776: POP
6777: POP
// ar_force_tmp := [ ] ;
6778: LD_ADDR_EXP 35
6782: PUSH
6783: EMPTY
6784: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6785: LD_INT 1
6787: PPUSH
6788: LD_INT 1
6790: PPUSH
6791: LD_VAR 0 8
6795: PPUSH
6796: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6800: LD_ADDR_OWVAR 33
6804: PUSH
6805: LD_STRING SecondCharsGal
6807: ST_TO_ADDR
// hc_face_number := 4 ;
6808: LD_ADDR_OWVAR 34
6812: PUSH
6813: LD_INT 4
6815: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6816: LD_ADDR_EXP 35
6820: PUSH
6821: LD_EXP 35
6825: PPUSH
6826: LD_INT 1
6828: PPUSH
6829: CALL_OW 44
6833: PPUSH
6834: CALL_OW 1
6838: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6839: LD_INT 2
6841: PPUSH
6842: LD_INT 4
6844: PPUSH
6845: LD_VAR 0 8
6849: PPUSH
6850: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6854: LD_ADDR_OWVAR 33
6858: PUSH
6859: LD_STRING SecondCharsGal
6861: ST_TO_ADDR
// hc_face_number := 15 ;
6862: LD_ADDR_OWVAR 34
6866: PUSH
6867: LD_INT 15
6869: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6870: LD_ADDR_EXP 35
6874: PUSH
6875: LD_EXP 35
6879: PPUSH
6880: LD_INT 2
6882: PPUSH
6883: CALL_OW 44
6887: PPUSH
6888: CALL_OW 1
6892: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6893: LD_INT 2
6895: PPUSH
6896: LD_INT 4
6898: PPUSH
6899: LD_VAR 0 8
6903: PPUSH
6904: CALL_OW 380
// hc_gallery :=  ;
6908: LD_ADDR_OWVAR 33
6912: PUSH
6913: LD_STRING 
6915: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
6916: LD_ADDR_EXP 35
6920: PUSH
6921: LD_EXP 35
6925: PPUSH
6926: LD_INT 3
6928: PPUSH
6929: CALL_OW 44
6933: PPUSH
6934: CALL_OW 1
6938: ST_TO_ADDR
// hc_sex := sex_male ;
6939: LD_ADDR_OWVAR 27
6943: PUSH
6944: LD_INT 1
6946: ST_TO_ADDR
// hc_class = 11 ;
6947: LD_ADDR_OWVAR 28
6951: PUSH
6952: LD_INT 11
6954: ST_TO_ADDR
// hc_gallery = sandar ;
6955: LD_ADDR_OWVAR 33
6959: PUSH
6960: LD_STRING sandar
6962: ST_TO_ADDR
// hc_face_number = 33 ;
6963: LD_ADDR_OWVAR 34
6967: PUSH
6968: LD_INT 33
6970: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
6971: LD_ADDR_OWVAR 26
6975: PUSH
6976: LD_STRING Thabit Muhair Saliba
6978: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
6979: LD_ADDR_OWVAR 31
6983: PUSH
6984: LD_INT 5
6986: PUSH
6987: LD_INT 5
6989: PUSH
6990: LD_INT 3
6992: PUSH
6993: LD_INT 3
6995: PUSH
6996: EMPTY
6997: LIST
6998: LIST
6999: LIST
7000: LIST
7001: ST_TO_ADDR
// Saliba = CreateHuman ;
7002: LD_ADDR_EXP 38
7006: PUSH
7007: CALL_OW 44
7011: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7012: LD_EXP 38
7016: PPUSH
7017: LD_INT 7
7019: PPUSH
7020: CALL_OW 52
// hc_name := Dietrich Gensher ;
7024: LD_ADDR_OWVAR 26
7028: PUSH
7029: LD_STRING Dietrich Gensher
7031: ST_TO_ADDR
// hc_class := 1 ;
7032: LD_ADDR_OWVAR 28
7036: PUSH
7037: LD_INT 1
7039: ST_TO_ADDR
// hc_gallery := sandar ;
7040: LD_ADDR_OWVAR 33
7044: PUSH
7045: LD_STRING sandar
7047: ST_TO_ADDR
// hc_face_number := 2 ;
7048: LD_ADDR_OWVAR 34
7052: PUSH
7053: LD_INT 2
7055: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7056: LD_ADDR_OWVAR 31
7060: PUSH
7061: LD_INT 10
7063: PUSH
7064: LD_INT 6
7066: PUSH
7067: LD_INT 5
7069: PUSH
7070: LD_INT 4
7072: PUSH
7073: EMPTY
7074: LIST
7075: LIST
7076: LIST
7077: LIST
7078: ST_TO_ADDR
// Gensher := CreateHuman ;
7079: LD_ADDR_EXP 39
7083: PUSH
7084: CALL_OW 44
7088: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7089: LD_EXP 39
7093: PPUSH
7094: LD_INT 94
7096: PPUSH
7097: CALL_OW 52
// InitHc ;
7101: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7105: LD_ADDR_EXP 37
7109: PUSH
7110: EMPTY
7111: PUSH
7112: EMPTY
7113: PUSH
7114: EMPTY
7115: PUSH
7116: EMPTY
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: LIST
7122: LIST
7123: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7124: LD_ADDR_VAR 0 4
7128: PUSH
7129: DOUBLE
7130: LD_INT 1
7132: DEC
7133: ST_TO_ADDR
7134: LD_INT 3
7136: PUSH
7137: LD_INT 3
7139: PUSH
7140: LD_INT 4
7142: PUSH
7143: EMPTY
7144: LIST
7145: LIST
7146: LIST
7147: PUSH
7148: LD_OWVAR 67
7152: ARRAY
7153: PUSH
7154: FOR_TO
7155: IFFALSE 7373
// for i = 1 to 4 do
7157: LD_ADDR_VAR 0 3
7161: PUSH
7162: DOUBLE
7163: LD_INT 1
7165: DEC
7166: ST_TO_ADDR
7167: LD_INT 4
7169: PUSH
7170: FOR_TO
7171: IFFALSE 7369
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7173: LD_INT 14
7175: PPUSH
7176: LD_INT 3
7178: PUSH
7179: LD_INT 2
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: PUSH
7186: LD_INT 1
7188: PPUSH
7189: LD_INT 2
7191: PPUSH
7192: CALL_OW 12
7196: ARRAY
7197: PPUSH
7198: LD_INT 1
7200: PUSH
7201: LD_INT 5
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PUSH
7208: LD_INT 1
7210: PPUSH
7211: LD_INT 2
7213: PPUSH
7214: CALL_OW 12
7218: ARRAY
7219: PPUSH
7220: LD_INT 25
7222: PUSH
7223: LD_INT 27
7225: PUSH
7226: LD_INT 26
7228: PUSH
7229: LD_INT 28
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: PUSH
7238: LD_INT 1
7240: PPUSH
7241: LD_INT 4
7243: PPUSH
7244: CALL_OW 12
7248: ARRAY
7249: PPUSH
7250: LD_INT 100
7252: PPUSH
7253: CALL 14210 0 5
// un := CreateVehicle ;
7257: LD_ADDR_VAR 0 6
7261: PUSH
7262: CALL_OW 45
7266: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7267: LD_ADDR_EXP 37
7271: PUSH
7272: LD_EXP 37
7276: PPUSH
7277: LD_VAR 0 3
7281: PUSH
7282: LD_EXP 37
7286: PUSH
7287: LD_VAR 0 3
7291: ARRAY
7292: PUSH
7293: LD_INT 1
7295: PLUS
7296: PUSH
7297: EMPTY
7298: LIST
7299: LIST
7300: PPUSH
7301: LD_VAR 0 6
7305: PPUSH
7306: CALL 14332 0 3
7310: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7311: LD_VAR 0 6
7315: PPUSH
7316: LD_INT 0
7318: PPUSH
7319: LD_INT 5
7321: PPUSH
7322: CALL_OW 12
7326: PPUSH
7327: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7331: LD_VAR 0 6
7335: PPUSH
7336: LD_INT 20
7338: PUSH
7339: LD_INT 21
7341: PUSH
7342: LD_INT 22
7344: PUSH
7345: LD_INT 24
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: LIST
7352: LIST
7353: PUSH
7354: LD_VAR 0 3
7358: ARRAY
7359: PPUSH
7360: LD_INT 0
7362: PPUSH
7363: CALL_OW 49
// end ;
7367: GO 7170
7369: POP
7370: POP
7371: GO 7154
7373: POP
7374: POP
// InitHc ;
7375: CALL_OW 19
// end ;
7379: LD_VAR 0 2
7383: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7384: LD_INT 94
7386: PPUSH
7387: CALL_OW 302
7391: PUSH
7392: LD_INT 94
7394: PPUSH
7395: CALL_OW 255
7399: PUSH
7400: LD_EXP 3
7404: EQUAL
7405: AND
7406: IFFALSE 8115
7408: GO 7410
7410: DISABLE
7411: LD_INT 0
7413: PPUSH
7414: PPUSH
7415: PPUSH
7416: PPUSH
7417: PPUSH
7418: PPUSH
7419: PPUSH
7420: PPUSH
7421: PPUSH
7422: PPUSH
// begin enable ;
7423: ENABLE
// base := 1 ;
7424: LD_ADDR_VAR 0 4
7428: PUSH
7429: LD_INT 1
7431: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7432: LD_ADDR_VAR 0 7
7436: PUSH
7437: LD_INT 0
7439: PUSH
7440: LD_INT 0
7442: PUSH
7443: LD_INT 0
7445: PUSH
7446: LD_INT 0
7448: PUSH
7449: LD_INT 1
7451: PUSH
7452: LD_INT 0
7454: PUSH
7455: LD_INT 0
7457: PUSH
7458: LD_INT 0
7460: PUSH
7461: LD_INT 1
7463: PUSH
7464: LD_INT 0
7466: PUSH
7467: EMPTY
7468: LIST
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: LIST
7474: LIST
7475: LIST
7476: LIST
7477: LIST
7478: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7479: LD_ADDR_VAR 0 6
7483: PUSH
7484: LD_INT 28
7486: PUSH
7487: LD_INT 14
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 107
7496: PUSH
7497: LD_INT 119
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: LD_INT 127
7506: PUSH
7507: LD_INT 97
7509: PUSH
7510: EMPTY
7511: LIST
7512: LIST
7513: PUSH
7514: LD_INT 185
7516: PUSH
7517: LD_INT 127
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: LIST
7528: LIST
7529: ST_TO_ADDR
// target := 0 ;
7530: LD_ADDR_VAR 0 9
7534: PUSH
7535: LD_INT 0
7537: ST_TO_ADDR
// x := 0 ;
7538: LD_ADDR_VAR 0 3
7542: PUSH
7543: LD_INT 0
7545: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7546: LD_ADDR_VAR 0 5
7550: PUSH
7551: LD_INT 14
7553: PUSH
7554: LD_INT 1
7556: PUSH
7557: LD_INT 2
7559: PUSH
7560: LD_INT 28
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 14
7571: PUSH
7572: LD_INT 1
7574: PUSH
7575: LD_INT 2
7577: PUSH
7578: LD_INT 25
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: LIST
7585: LIST
7586: PUSH
7587: LD_INT 14
7589: PUSH
7590: LD_INT 1
7592: PUSH
7593: LD_INT 2
7595: PUSH
7596: LD_INT 28
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: LIST
7604: PUSH
7605: LD_INT 14
7607: PUSH
7608: LD_INT 1
7610: PUSH
7611: LD_INT 2
7613: PUSH
7614: LD_INT 29
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: LIST
7621: LIST
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: LIST
7627: LIST
7628: ST_TO_ADDR
// if Difficulty > 1 then
7629: LD_OWVAR 67
7633: PUSH
7634: LD_INT 1
7636: GREATER
7637: IFFALSE 7734
// for i = 1 to Difficulty + 2 do
7639: LD_ADDR_VAR 0 1
7643: PUSH
7644: DOUBLE
7645: LD_INT 1
7647: DEC
7648: ST_TO_ADDR
7649: LD_OWVAR 67
7653: PUSH
7654: LD_INT 2
7656: PLUS
7657: PUSH
7658: FOR_TO
7659: IFFALSE 7732
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7661: LD_ADDR_VAR 0 5
7665: PUSH
7666: LD_VAR 0 5
7670: PPUSH
7671: LD_VAR 0 5
7675: PUSH
7676: LD_INT 1
7678: PLUS
7679: PPUSH
7680: LD_INT 14
7682: PUSH
7683: LD_INT 1
7685: PUSH
7686: LD_INT 2
7688: PUSH
7689: LD_INT 28
7691: PUSH
7692: LD_INT 27
7694: PUSH
7695: LD_INT 27
7697: PUSH
7698: LD_INT 29
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 1
7709: PPUSH
7710: LD_INT 4
7712: PPUSH
7713: CALL_OW 12
7717: ARRAY
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PPUSH
7725: CALL_OW 2
7729: ST_TO_ADDR
7730: GO 7658
7732: POP
7733: POP
// MC_SetProduceList ( base , tmp ) ;
7734: LD_VAR 0 4
7738: PPUSH
7739: LD_VAR 0 5
7743: PPUSH
7744: CALL 70269 0 2
// repeat wait ( 0 0$1 ) ;
7748: LD_INT 35
7750: PPUSH
7751: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7755: LD_VAR 0 4
7759: PPUSH
7760: CALL 70665 0 1
7764: PUSH
7765: LD_INT 0
7767: EQUAL
7768: IFFALSE 7748
// wait ( 0 0$10 ) ;
7770: LD_INT 350
7772: PPUSH
7773: CALL_OW 67
// for i = 1 to coords do
7777: LD_ADDR_VAR 0 1
7781: PUSH
7782: DOUBLE
7783: LD_INT 1
7785: DEC
7786: ST_TO_ADDR
7787: LD_VAR 0 6
7791: PUSH
7792: FOR_TO
7793: IFFALSE 7881
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7795: LD_ADDR_VAR 0 2
7799: PUSH
7800: LD_EXP 3
7804: PPUSH
7805: LD_VAR 0 6
7809: PUSH
7810: LD_VAR 0 1
7814: ARRAY
7815: PUSH
7816: LD_INT 1
7818: ARRAY
7819: PPUSH
7820: LD_VAR 0 6
7824: PUSH
7825: LD_VAR 0 1
7829: ARRAY
7830: PUSH
7831: LD_INT 2
7833: ARRAY
7834: PPUSH
7835: LD_INT 35
7837: PPUSH
7838: CALL 15228 0 4
7842: PUSH
7843: LD_INT 4
7845: ARRAY
7846: ST_TO_ADDR
// if t > x then
7847: LD_VAR 0 2
7851: PUSH
7852: LD_VAR 0 3
7856: GREATER
7857: IFFALSE 7879
// begin x := t ;
7859: LD_ADDR_VAR 0 3
7863: PUSH
7864: LD_VAR 0 2
7868: ST_TO_ADDR
// target := i ;
7869: LD_ADDR_VAR 0 9
7873: PUSH
7874: LD_VAR 0 1
7878: ST_TO_ADDR
// end ; end ;
7879: GO 7792
7881: POP
7882: POP
// case target of 1 :
7883: LD_VAR 0 9
7887: PUSH
7888: LD_INT 1
7890: DOUBLE
7891: EQUAL
7892: IFTRUE 7896
7894: GO 7928
7896: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
7897: LD_ADDR_VAR 0 10
7901: PUSH
7902: LD_INT 60
7904: PUSH
7905: LD_INT 8
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: LD_INT 28
7914: PUSH
7915: LD_INT 15
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PUSH
7922: EMPTY
7923: LIST
7924: LIST
7925: ST_TO_ADDR
7926: GO 8049
7928: LD_INT 2
7930: DOUBLE
7931: EQUAL
7932: IFTRUE 7936
7934: GO 7968
7936: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
7937: LD_ADDR_VAR 0 10
7941: PUSH
7942: LD_INT 52
7944: PUSH
7945: LD_INT 11
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 76
7954: PUSH
7955: LD_INT 90
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: ST_TO_ADDR
7966: GO 8049
7968: LD_INT 3
7970: DOUBLE
7971: EQUAL
7972: IFTRUE 7976
7974: GO 8008
7976: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
7977: LD_ADDR_VAR 0 10
7981: PUSH
7982: LD_INT 129
7984: PUSH
7985: LD_INT 66
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: PUSH
7992: LD_INT 130
7994: PUSH
7995: LD_INT 97
7997: PUSH
7998: EMPTY
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: ST_TO_ADDR
8006: GO 8049
8008: LD_INT 4
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8017: LD_ADDR_VAR 0 10
8021: PUSH
8022: LD_INT 156
8024: PUSH
8025: LD_INT 87
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 183
8034: PUSH
8035: LD_INT 127
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8049
8048: POP
// if not _target then
8049: LD_VAR 0 10
8053: NOT
8054: IFFALSE 8085
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8056: LD_ADDR_VAR 0 10
8060: PUSH
8061: LD_INT 52
8063: PUSH
8064: LD_INT 11
8066: PUSH
8067: EMPTY
8068: LIST
8069: LIST
8070: PUSH
8071: LD_INT 76
8073: PUSH
8074: LD_INT 90
8076: PUSH
8077: EMPTY
8078: LIST
8079: LIST
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8085: LD_VAR 0 4
8089: PPUSH
8090: LD_EXP 61
8094: PUSH
8095: LD_VAR 0 4
8099: ARRAY
8100: PPUSH
8101: LD_VAR 0 10
8105: PPUSH
8106: LD_VAR 0 7
8110: PPUSH
8111: CALL 70502 0 4
// end ;
8115: PPOPN 10
8117: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8118: LD_INT 45
8120: PPUSH
8121: CALL_OW 302
8125: PUSH
8126: LD_INT 45
8128: PPUSH
8129: CALL_OW 255
8133: PUSH
8134: LD_EXP 3
8138: EQUAL
8139: AND
8140: PUSH
8141: LD_EXP 26
8145: PUSH
8146: LD_INT 3
8148: EQUAL
8149: PUSH
8150: LD_INT 94
8152: PPUSH
8153: CALL_OW 301
8157: OR
8158: PUSH
8159: LD_INT 94
8161: PPUSH
8162: CALL_OW 255
8166: PUSH
8167: LD_EXP 3
8171: NONEQUAL
8172: OR
8173: AND
8174: IFFALSE 8760
8176: GO 8178
8178: DISABLE
8179: LD_INT 0
8181: PPUSH
8182: PPUSH
8183: PPUSH
8184: PPUSH
8185: PPUSH
8186: PPUSH
8187: PPUSH
8188: PPUSH
8189: PPUSH
8190: PPUSH
// begin enable ;
8191: ENABLE
// base := 2 ;
8192: LD_ADDR_VAR 0 4
8196: PUSH
8197: LD_INT 2
8199: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8200: LD_ADDR_VAR 0 7
8204: PUSH
8205: LD_INT 0
8207: PUSH
8208: LD_INT 0
8210: PUSH
8211: LD_INT 0
8213: PUSH
8214: LD_INT 0
8216: PUSH
8217: LD_INT 1
8219: PUSH
8220: LD_INT 0
8222: PUSH
8223: LD_INT 0
8225: PUSH
8226: LD_INT 0
8228: PUSH
8229: LD_INT 1
8231: PUSH
8232: LD_INT 0
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: LIST
8239: LIST
8240: LIST
8241: LIST
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8247: LD_ADDR_VAR 0 6
8251: PUSH
8252: LD_INT 101
8254: PUSH
8255: LD_INT 110
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: PUSH
8262: LD_INT 100
8264: PUSH
8265: LD_INT 21
8267: PUSH
8268: EMPTY
8269: LIST
8270: LIST
8271: PUSH
8272: EMPTY
8273: LIST
8274: LIST
8275: ST_TO_ADDR
// target := 0 ;
8276: LD_ADDR_VAR 0 9
8280: PUSH
8281: LD_INT 0
8283: ST_TO_ADDR
// x := 0 ;
8284: LD_ADDR_VAR 0 3
8288: PUSH
8289: LD_INT 0
8291: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8292: LD_ADDR_VAR 0 5
8296: PUSH
8297: LD_INT 14
8299: PUSH
8300: LD_INT 1
8302: PUSH
8303: LD_INT 2
8305: PUSH
8306: LD_INT 28
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: LIST
8314: PUSH
8315: LD_INT 14
8317: PUSH
8318: LD_INT 1
8320: PUSH
8321: LD_INT 2
8323: PUSH
8324: LD_INT 25
8326: PUSH
8327: EMPTY
8328: LIST
8329: LIST
8330: LIST
8331: LIST
8332: PUSH
8333: LD_INT 14
8335: PUSH
8336: LD_INT 1
8338: PUSH
8339: LD_INT 2
8341: PUSH
8342: LD_INT 28
8344: PUSH
8345: EMPTY
8346: LIST
8347: LIST
8348: LIST
8349: LIST
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: LIST
8355: ST_TO_ADDR
// if Difficulty > 1 then
8356: LD_OWVAR 67
8360: PUSH
8361: LD_INT 1
8363: GREATER
8364: IFFALSE 8459
// for i = 1 to Difficulty + 1 do
8366: LD_ADDR_VAR 0 1
8370: PUSH
8371: DOUBLE
8372: LD_INT 1
8374: DEC
8375: ST_TO_ADDR
8376: LD_OWVAR 67
8380: PUSH
8381: LD_INT 1
8383: PLUS
8384: PUSH
8385: FOR_TO
8386: IFFALSE 8457
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8388: LD_ADDR_VAR 0 5
8392: PUSH
8393: LD_VAR 0 5
8397: PPUSH
8398: LD_VAR 0 5
8402: PUSH
8403: LD_INT 1
8405: PLUS
8406: PPUSH
8407: LD_INT 14
8409: PUSH
8410: LD_INT 1
8412: PUSH
8413: LD_INT 2
8415: PUSH
8416: LD_INT 28
8418: PUSH
8419: LD_INT 27
8421: PUSH
8422: LD_INT 27
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: LIST
8429: PUSH
8430: LD_VAR 0 1
8434: PUSH
8435: LD_INT 2
8437: MOD
8438: PUSH
8439: LD_INT 1
8441: PLUS
8442: ARRAY
8443: PUSH
8444: EMPTY
8445: LIST
8446: LIST
8447: LIST
8448: LIST
8449: PPUSH
8450: CALL_OW 2
8454: ST_TO_ADDR
8455: GO 8385
8457: POP
8458: POP
// MC_SetProduceList ( base , tmp ) ;
8459: LD_VAR 0 4
8463: PPUSH
8464: LD_VAR 0 5
8468: PPUSH
8469: CALL 70269 0 2
// repeat wait ( 0 0$1 ) ;
8473: LD_INT 35
8475: PPUSH
8476: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8480: LD_VAR 0 4
8484: PPUSH
8485: CALL 70665 0 1
8489: PUSH
8490: LD_INT 0
8492: EQUAL
8493: IFFALSE 8473
// wait ( 0 0$10 ) ;
8495: LD_INT 350
8497: PPUSH
8498: CALL_OW 67
// for i = 1 to coords do
8502: LD_ADDR_VAR 0 1
8506: PUSH
8507: DOUBLE
8508: LD_INT 1
8510: DEC
8511: ST_TO_ADDR
8512: LD_VAR 0 6
8516: PUSH
8517: FOR_TO
8518: IFFALSE 8606
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8520: LD_ADDR_VAR 0 2
8524: PUSH
8525: LD_EXP 3
8529: PPUSH
8530: LD_VAR 0 6
8534: PUSH
8535: LD_VAR 0 1
8539: ARRAY
8540: PUSH
8541: LD_INT 1
8543: ARRAY
8544: PPUSH
8545: LD_VAR 0 6
8549: PUSH
8550: LD_VAR 0 1
8554: ARRAY
8555: PUSH
8556: LD_INT 2
8558: ARRAY
8559: PPUSH
8560: LD_INT 35
8562: PPUSH
8563: CALL 15228 0 4
8567: PUSH
8568: LD_INT 4
8570: ARRAY
8571: ST_TO_ADDR
// if t > x then
8572: LD_VAR 0 2
8576: PUSH
8577: LD_VAR 0 3
8581: GREATER
8582: IFFALSE 8604
// begin x := t ;
8584: LD_ADDR_VAR 0 3
8588: PUSH
8589: LD_VAR 0 2
8593: ST_TO_ADDR
// target := i ;
8594: LD_ADDR_VAR 0 9
8598: PUSH
8599: LD_VAR 0 1
8603: ST_TO_ADDR
// end ; end ;
8604: GO 8517
8606: POP
8607: POP
// case target of 1 :
8608: LD_VAR 0 9
8612: PUSH
8613: LD_INT 1
8615: DOUBLE
8616: EQUAL
8617: IFTRUE 8621
8619: GO 8653
8621: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8622: LD_ADDR_VAR 0 10
8626: PUSH
8627: LD_INT 49
8629: PUSH
8630: LD_INT 35
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: PUSH
8637: LD_INT 76
8639: PUSH
8640: LD_INT 90
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: ST_TO_ADDR
8651: GO 8694
8653: LD_INT 2
8655: DOUBLE
8656: EQUAL
8657: IFTRUE 8661
8659: GO 8693
8661: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8662: LD_ADDR_VAR 0 10
8666: PUSH
8667: LD_INT 79
8669: PUSH
8670: LD_INT 13
8672: PUSH
8673: EMPTY
8674: LIST
8675: LIST
8676: PUSH
8677: LD_INT 100
8679: PUSH
8680: LD_INT 22
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: ST_TO_ADDR
8691: GO 8694
8693: POP
// if not _target then
8694: LD_VAR 0 10
8698: NOT
8699: IFFALSE 8730
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8701: LD_ADDR_VAR 0 10
8705: PUSH
8706: LD_INT 49
8708: PUSH
8709: LD_INT 35
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: PUSH
8716: LD_INT 76
8718: PUSH
8719: LD_INT 90
8721: PUSH
8722: EMPTY
8723: LIST
8724: LIST
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8730: LD_VAR 0 4
8734: PPUSH
8735: LD_EXP 61
8739: PUSH
8740: LD_VAR 0 4
8744: ARRAY
8745: PPUSH
8746: LD_VAR 0 10
8750: PPUSH
8751: LD_VAR 0 7
8755: PPUSH
8756: CALL 70502 0 4
// end ; end_of_file
8760: PPOPN 10
8762: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8763: LD_INT 0
8765: PPUSH
8766: PPUSH
// begin if artifact_get then
8767: LD_EXP 4
8771: IFFALSE 8775
// exit ;
8773: GO 8797
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8775: LD_VAR 0 1
8779: PPUSH
8780: CALL_OW 255
8784: PPUSH
8785: CALL 5765 0 1
// artifact_get := true ;
8789: LD_ADDR_EXP 4
8793: PUSH
8794: LD_INT 1
8796: ST_TO_ADDR
// end ;
8797: PPOPN 4
8799: END
// on UnitDestroyed ( un ) do var i , side ;
8800: LD_INT 0
8802: PPUSH
8803: PPUSH
// begin side := GetSide ( un ) ;
8804: LD_ADDR_VAR 0 3
8808: PUSH
8809: LD_VAR 0 1
8813: PPUSH
8814: CALL_OW 255
8818: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8819: LD_VAR 0 3
8823: PUSH
8824: LD_EXP 68
8828: IN
8829: NOT
8830: PUSH
8831: LD_EXP 7
8835: PUSH
8836: LD_VAR 0 3
8840: ARRAY
8841: AND
8842: IFFALSE 8868
// if GetType ( un ) = unit_human then
8844: LD_VAR 0 1
8848: PPUSH
8849: CALL_OW 247
8853: PUSH
8854: LD_INT 1
8856: EQUAL
8857: IFFALSE 8868
// MultiplayerEvent_HumanLost ( side ) ;
8859: LD_VAR 0 3
8863: PPUSH
8864: CALL 5405 0 1
// if side in mc_sides then
8868: LD_VAR 0 3
8872: PUSH
8873: LD_EXP 68
8877: IN
8878: IFFALSE 8923
// if un <> Gensher then
8880: LD_VAR 0 1
8884: PUSH
8885: LD_EXP 39
8889: NONEQUAL
8890: IFFALSE 8906
// MultiplayerEvent_UnitKilled ( un , false ) else
8892: LD_VAR 0 1
8896: PPUSH
8897: LD_INT 0
8899: PPUSH
8900: CALL 5519 0 2
8904: GO 8923
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
8906: LD_VAR 0 1
8910: PPUSH
8911: LD_INT 5
8913: PPUSH
8914: CALL 4836 0 1
8918: PPUSH
8919: CALL 5519 0 2
// if multi_commanders and multi_custom_commanders then
8923: LD_EXP 24
8927: PUSH
8928: LD_EXP 16
8932: AND
8933: IFFALSE 8995
// if un in multi_commanders then
8935: LD_VAR 0 1
8939: PUSH
8940: LD_EXP 24
8944: IN
8945: IFFALSE 8995
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
8947: LD_ADDR_EXP 25
8951: PUSH
8952: LD_EXP 25
8956: PPUSH
8957: LD_VAR 0 3
8961: PPUSH
8962: LD_INT 1
8964: PPUSH
8965: CALL_OW 1
8969: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
8970: LD_ADDR_EXP 24
8974: PUSH
8975: LD_EXP 24
8979: PUSH
8980: LD_VAR 0 1
8984: DIFF
8985: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
8986: LD_VAR 0 3
8990: PPUSH
8991: CALL 4869 0 1
// end ; MCE_UnitDestroyed ( un ) ;
8995: LD_VAR 0 1
8999: PPUSH
9000: CALL 73728 0 1
// end ;
9004: PPOPN 3
9006: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9007: LD_VAR 0 1
9011: PPUSH
9012: LD_VAR 0 2
9016: PPUSH
9017: CALL 76062 0 2
// end ;
9021: PPOPN 2
9023: END
// on BuildingComplete ( building ) do var i , j ;
9024: LD_INT 0
9026: PPUSH
9027: PPUSH
// begin if GetSide ( building ) in mc_sides then
9028: LD_VAR 0 1
9032: PPUSH
9033: CALL_OW 255
9037: PUSH
9038: LD_EXP 68
9042: IN
9043: IFFALSE 9069
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9045: LD_VAR 0 1
9049: PPUSH
9050: CALL_OW 255
9054: PPUSH
9055: LD_VAR 0 1
9059: PPUSH
9060: CALL_OW 266
9064: PPUSH
9065: CALL 5449 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9069: LD_VAR 0 1
9073: PPUSH
9074: CALL_OW 266
9078: PUSH
9079: LD_INT 0
9081: EQUAL
9082: PUSH
9083: LD_VAR 0 1
9087: PPUSH
9088: CALL_OW 255
9092: PUSH
9093: LD_EXP 68
9097: IN
9098: NOT
9099: AND
9100: PUSH
9101: LD_EXP 5
9105: AND
9106: IFFALSE 9144
// begin SetBName ( building , base_names [ 1 ] ) ;
9108: LD_VAR 0 1
9112: PPUSH
9113: LD_EXP 5
9117: PUSH
9118: LD_INT 1
9120: ARRAY
9121: PPUSH
9122: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9126: LD_ADDR_EXP 5
9130: PUSH
9131: LD_EXP 5
9135: PPUSH
9136: LD_INT 1
9138: PPUSH
9139: CALL_OW 3
9143: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9144: LD_VAR 0 1
9148: PPUSH
9149: CALL 75371 0 1
// end ;
9153: PPOPN 3
9155: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9156: LD_VAR 0 1
9160: PPUSH
9161: LD_VAR 0 2
9165: PPUSH
9166: CALL 73424 0 2
// end ;
9170: PPOPN 2
9172: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9173: LD_VAR 0 1
9177: PPUSH
9178: LD_VAR 0 2
9182: PPUSH
9183: LD_VAR 0 3
9187: PPUSH
9188: LD_VAR 0 4
9192: PPUSH
9193: LD_VAR 0 5
9197: PPUSH
9198: CALL 73044 0 5
// end ;
9202: PPOPN 5
9204: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9205: LD_INT 0
9207: PPUSH
9208: PPUSH
9209: PPUSH
// begin side := GetSide ( vehicle ) ;
9210: LD_ADDR_VAR 0 4
9214: PUSH
9215: LD_VAR 0 1
9219: PPUSH
9220: CALL_OW 255
9224: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9225: LD_VAR 0 4
9229: PUSH
9230: LD_EXP 68
9234: IN
9235: NOT
9236: PUSH
9237: LD_EXP 7
9241: PUSH
9242: LD_VAR 0 4
9246: ARRAY
9247: AND
9248: IFFALSE 9259
// MultiplayerEvent_Produced ( side ) ;
9250: LD_VAR 0 4
9254: PPUSH
9255: CALL 5361 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9259: LD_VAR 0 1
9263: PPUSH
9264: LD_VAR 0 2
9268: PPUSH
9269: CALL 72634 0 2
// end ;
9273: PPOPN 5
9275: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9276: LD_VAR 0 1
9280: PPUSH
9281: LD_VAR 0 2
9285: PPUSH
9286: LD_VAR 0 3
9290: PPUSH
9291: LD_VAR 0 4
9295: PPUSH
9296: CALL 72472 0 4
// end ;
9300: PPOPN 4
9302: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9303: LD_VAR 0 1
9307: PPUSH
9308: LD_VAR 0 2
9312: PPUSH
9313: LD_VAR 0 3
9317: PPUSH
9318: CALL 72247 0 3
// end ;
9322: PPOPN 3
9324: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9325: LD_VAR 0 1
9329: PPUSH
9330: LD_VAR 0 2
9334: PPUSH
9335: CALL 72132 0 2
// end ;
9339: PPOPN 2
9341: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9342: LD_VAR 0 1
9346: PPUSH
9347: LD_VAR 0 2
9351: PPUSH
9352: CALL 76323 0 2
// end ;
9356: PPOPN 2
9358: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9359: LD_VAR 0 1
9363: PPUSH
9364: LD_VAR 0 2
9368: PPUSH
9369: LD_VAR 0 3
9373: PPUSH
9374: LD_VAR 0 4
9378: PPUSH
9379: CALL 76539 0 4
// end ; end_of_file end_of_file
9383: PPOPN 4
9385: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9386: LD_INT 0
9388: PPUSH
9389: PPUSH
// if exist_mode then
9390: LD_VAR 0 2
9394: IFFALSE 9419
// unit := CreateCharacter ( prefix & ident ) else
9396: LD_ADDR_VAR 0 5
9400: PUSH
9401: LD_VAR 0 3
9405: PUSH
9406: LD_VAR 0 1
9410: STR
9411: PPUSH
9412: CALL_OW 34
9416: ST_TO_ADDR
9417: GO 9434
// unit := NewCharacter ( ident ) ;
9419: LD_ADDR_VAR 0 5
9423: PUSH
9424: LD_VAR 0 1
9428: PPUSH
9429: CALL_OW 25
9433: ST_TO_ADDR
// result := unit ;
9434: LD_ADDR_VAR 0 4
9438: PUSH
9439: LD_VAR 0 5
9443: ST_TO_ADDR
// end ;
9444: LD_VAR 0 4
9448: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9449: LD_INT 0
9451: PPUSH
9452: PPUSH
// if not side or not nation then
9453: LD_VAR 0 1
9457: NOT
9458: PUSH
9459: LD_VAR 0 2
9463: NOT
9464: OR
9465: IFFALSE 9469
// exit ;
9467: GO 10233
// case nation of nation_american :
9469: LD_VAR 0 2
9473: PUSH
9474: LD_INT 1
9476: DOUBLE
9477: EQUAL
9478: IFTRUE 9482
9480: GO 9696
9482: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9483: LD_ADDR_VAR 0 4
9487: PUSH
9488: LD_INT 35
9490: PUSH
9491: LD_INT 45
9493: PUSH
9494: LD_INT 46
9496: PUSH
9497: LD_INT 47
9499: PUSH
9500: LD_INT 82
9502: PUSH
9503: LD_INT 83
9505: PUSH
9506: LD_INT 84
9508: PUSH
9509: LD_INT 85
9511: PUSH
9512: LD_INT 86
9514: PUSH
9515: LD_INT 1
9517: PUSH
9518: LD_INT 2
9520: PUSH
9521: LD_INT 6
9523: PUSH
9524: LD_INT 15
9526: PUSH
9527: LD_INT 16
9529: PUSH
9530: LD_INT 7
9532: PUSH
9533: LD_INT 12
9535: PUSH
9536: LD_INT 13
9538: PUSH
9539: LD_INT 10
9541: PUSH
9542: LD_INT 14
9544: PUSH
9545: LD_INT 20
9547: PUSH
9548: LD_INT 21
9550: PUSH
9551: LD_INT 22
9553: PUSH
9554: LD_INT 25
9556: PUSH
9557: LD_INT 32
9559: PUSH
9560: LD_INT 27
9562: PUSH
9563: LD_INT 36
9565: PUSH
9566: LD_INT 69
9568: PUSH
9569: LD_INT 39
9571: PUSH
9572: LD_INT 34
9574: PUSH
9575: LD_INT 40
9577: PUSH
9578: LD_INT 48
9580: PUSH
9581: LD_INT 49
9583: PUSH
9584: LD_INT 50
9586: PUSH
9587: LD_INT 51
9589: PUSH
9590: LD_INT 52
9592: PUSH
9593: LD_INT 53
9595: PUSH
9596: LD_INT 54
9598: PUSH
9599: LD_INT 55
9601: PUSH
9602: LD_INT 56
9604: PUSH
9605: LD_INT 57
9607: PUSH
9608: LD_INT 58
9610: PUSH
9611: LD_INT 59
9613: PUSH
9614: LD_INT 60
9616: PUSH
9617: LD_INT 61
9619: PUSH
9620: LD_INT 62
9622: PUSH
9623: LD_INT 80
9625: PUSH
9626: LD_INT 82
9628: PUSH
9629: LD_INT 83
9631: PUSH
9632: LD_INT 84
9634: PUSH
9635: LD_INT 85
9637: PUSH
9638: LD_INT 86
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: LIST
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: LIST
9659: LIST
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: LIST
9665: LIST
9666: LIST
9667: LIST
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: LIST
9677: LIST
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: LIST
9683: LIST
9684: LIST
9685: LIST
9686: LIST
9687: LIST
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: ST_TO_ADDR
9694: GO 10157
9696: LD_INT 2
9698: DOUBLE
9699: EQUAL
9700: IFTRUE 9704
9702: GO 9926
9704: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
9705: LD_ADDR_VAR 0 4
9709: PUSH
9710: LD_INT 35
9712: PUSH
9713: LD_INT 45
9715: PUSH
9716: LD_INT 46
9718: PUSH
9719: LD_INT 47
9721: PUSH
9722: LD_INT 82
9724: PUSH
9725: LD_INT 83
9727: PUSH
9728: LD_INT 84
9730: PUSH
9731: LD_INT 85
9733: PUSH
9734: LD_INT 87
9736: PUSH
9737: LD_INT 70
9739: PUSH
9740: LD_INT 1
9742: PUSH
9743: LD_INT 11
9745: PUSH
9746: LD_INT 3
9748: PUSH
9749: LD_INT 4
9751: PUSH
9752: LD_INT 5
9754: PUSH
9755: LD_INT 6
9757: PUSH
9758: LD_INT 15
9760: PUSH
9761: LD_INT 18
9763: PUSH
9764: LD_INT 7
9766: PUSH
9767: LD_INT 17
9769: PUSH
9770: LD_INT 8
9772: PUSH
9773: LD_INT 20
9775: PUSH
9776: LD_INT 21
9778: PUSH
9779: LD_INT 22
9781: PUSH
9782: LD_INT 72
9784: PUSH
9785: LD_INT 26
9787: PUSH
9788: LD_INT 69
9790: PUSH
9791: LD_INT 39
9793: PUSH
9794: LD_INT 40
9796: PUSH
9797: LD_INT 41
9799: PUSH
9800: LD_INT 42
9802: PUSH
9803: LD_INT 43
9805: PUSH
9806: LD_INT 48
9808: PUSH
9809: LD_INT 49
9811: PUSH
9812: LD_INT 50
9814: PUSH
9815: LD_INT 51
9817: PUSH
9818: LD_INT 52
9820: PUSH
9821: LD_INT 53
9823: PUSH
9824: LD_INT 54
9826: PUSH
9827: LD_INT 55
9829: PUSH
9830: LD_INT 56
9832: PUSH
9833: LD_INT 60
9835: PUSH
9836: LD_INT 61
9838: PUSH
9839: LD_INT 62
9841: PUSH
9842: LD_INT 66
9844: PUSH
9845: LD_INT 67
9847: PUSH
9848: LD_INT 68
9850: PUSH
9851: LD_INT 81
9853: PUSH
9854: LD_INT 82
9856: PUSH
9857: LD_INT 83
9859: PUSH
9860: LD_INT 84
9862: PUSH
9863: LD_INT 85
9865: PUSH
9866: LD_INT 87
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: LIST
9873: LIST
9874: LIST
9875: LIST
9876: LIST
9877: LIST
9878: LIST
9879: LIST
9880: LIST
9881: LIST
9882: LIST
9883: LIST
9884: LIST
9885: LIST
9886: LIST
9887: LIST
9888: LIST
9889: LIST
9890: LIST
9891: LIST
9892: LIST
9893: LIST
9894: LIST
9895: LIST
9896: LIST
9897: LIST
9898: LIST
9899: LIST
9900: LIST
9901: LIST
9902: LIST
9903: LIST
9904: LIST
9905: LIST
9906: LIST
9907: LIST
9908: LIST
9909: LIST
9910: LIST
9911: LIST
9912: LIST
9913: LIST
9914: LIST
9915: LIST
9916: LIST
9917: LIST
9918: LIST
9919: LIST
9920: LIST
9921: LIST
9922: LIST
9923: ST_TO_ADDR
9924: GO 10157
9926: LD_INT 3
9928: DOUBLE
9929: EQUAL
9930: IFTRUE 9934
9932: GO 10156
9934: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
9935: LD_ADDR_VAR 0 4
9939: PUSH
9940: LD_INT 46
9942: PUSH
9943: LD_INT 47
9945: PUSH
9946: LD_INT 1
9948: PUSH
9949: LD_INT 2
9951: PUSH
9952: LD_INT 82
9954: PUSH
9955: LD_INT 83
9957: PUSH
9958: LD_INT 84
9960: PUSH
9961: LD_INT 85
9963: PUSH
9964: LD_INT 86
9966: PUSH
9967: LD_INT 11
9969: PUSH
9970: LD_INT 9
9972: PUSH
9973: LD_INT 20
9975: PUSH
9976: LD_INT 19
9978: PUSH
9979: LD_INT 21
9981: PUSH
9982: LD_INT 24
9984: PUSH
9985: LD_INT 22
9987: PUSH
9988: LD_INT 25
9990: PUSH
9991: LD_INT 28
9993: PUSH
9994: LD_INT 29
9996: PUSH
9997: LD_INT 30
9999: PUSH
10000: LD_INT 31
10002: PUSH
10003: LD_INT 37
10005: PUSH
10006: LD_INT 38
10008: PUSH
10009: LD_INT 32
10011: PUSH
10012: LD_INT 27
10014: PUSH
10015: LD_INT 33
10017: PUSH
10018: LD_INT 69
10020: PUSH
10021: LD_INT 39
10023: PUSH
10024: LD_INT 34
10026: PUSH
10027: LD_INT 40
10029: PUSH
10030: LD_INT 71
10032: PUSH
10033: LD_INT 23
10035: PUSH
10036: LD_INT 44
10038: PUSH
10039: LD_INT 48
10041: PUSH
10042: LD_INT 49
10044: PUSH
10045: LD_INT 50
10047: PUSH
10048: LD_INT 51
10050: PUSH
10051: LD_INT 52
10053: PUSH
10054: LD_INT 53
10056: PUSH
10057: LD_INT 54
10059: PUSH
10060: LD_INT 55
10062: PUSH
10063: LD_INT 56
10065: PUSH
10066: LD_INT 57
10068: PUSH
10069: LD_INT 58
10071: PUSH
10072: LD_INT 59
10074: PUSH
10075: LD_INT 63
10077: PUSH
10078: LD_INT 64
10080: PUSH
10081: LD_INT 65
10083: PUSH
10084: LD_INT 82
10086: PUSH
10087: LD_INT 83
10089: PUSH
10090: LD_INT 84
10092: PUSH
10093: LD_INT 85
10095: PUSH
10096: LD_INT 86
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: ST_TO_ADDR
10154: GO 10157
10156: POP
// if state > - 1 and state < 3 then
10157: LD_VAR 0 3
10161: PUSH
10162: LD_INT 1
10164: NEG
10165: GREATER
10166: PUSH
10167: LD_VAR 0 3
10171: PUSH
10172: LD_INT 3
10174: LESS
10175: AND
10176: IFFALSE 10233
// for i in result do
10178: LD_ADDR_VAR 0 5
10182: PUSH
10183: LD_VAR 0 4
10187: PUSH
10188: FOR_IN
10189: IFFALSE 10231
// if GetTech ( i , side ) <> state then
10191: LD_VAR 0 5
10195: PPUSH
10196: LD_VAR 0 1
10200: PPUSH
10201: CALL_OW 321
10205: PUSH
10206: LD_VAR 0 3
10210: NONEQUAL
10211: IFFALSE 10229
// result := result diff i ;
10213: LD_ADDR_VAR 0 4
10217: PUSH
10218: LD_VAR 0 4
10222: PUSH
10223: LD_VAR 0 5
10227: DIFF
10228: ST_TO_ADDR
10229: GO 10188
10231: POP
10232: POP
// end ;
10233: LD_VAR 0 4
10237: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10238: LD_INT 0
10240: PPUSH
10241: PPUSH
10242: PPUSH
// result := true ;
10243: LD_ADDR_VAR 0 3
10247: PUSH
10248: LD_INT 1
10250: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10251: LD_ADDR_VAR 0 5
10255: PUSH
10256: LD_VAR 0 2
10260: PPUSH
10261: CALL_OW 480
10265: ST_TO_ADDR
// if not tmp then
10266: LD_VAR 0 5
10270: NOT
10271: IFFALSE 10275
// exit ;
10273: GO 10324
// for i in tmp do
10275: LD_ADDR_VAR 0 4
10279: PUSH
10280: LD_VAR 0 5
10284: PUSH
10285: FOR_IN
10286: IFFALSE 10322
// if GetTech ( i , side ) <> state_researched then
10288: LD_VAR 0 4
10292: PPUSH
10293: LD_VAR 0 1
10297: PPUSH
10298: CALL_OW 321
10302: PUSH
10303: LD_INT 2
10305: NONEQUAL
10306: IFFALSE 10320
// begin result := false ;
10308: LD_ADDR_VAR 0 3
10312: PUSH
10313: LD_INT 0
10315: ST_TO_ADDR
// exit ;
10316: POP
10317: POP
10318: GO 10324
// end ;
10320: GO 10285
10322: POP
10323: POP
// end ;
10324: LD_VAR 0 3
10328: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10329: LD_INT 0
10331: PPUSH
10332: PPUSH
10333: PPUSH
10334: PPUSH
10335: PPUSH
10336: PPUSH
10337: PPUSH
10338: PPUSH
10339: PPUSH
10340: PPUSH
10341: PPUSH
10342: PPUSH
10343: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10344: LD_VAR 0 1
10348: NOT
10349: PUSH
10350: LD_VAR 0 1
10354: PPUSH
10355: CALL_OW 257
10359: PUSH
10360: LD_INT 9
10362: NONEQUAL
10363: OR
10364: IFFALSE 10368
// exit ;
10366: GO 10941
// side := GetSide ( unit ) ;
10368: LD_ADDR_VAR 0 9
10372: PUSH
10373: LD_VAR 0 1
10377: PPUSH
10378: CALL_OW 255
10382: ST_TO_ADDR
// tech_space := tech_spacanom ;
10383: LD_ADDR_VAR 0 12
10387: PUSH
10388: LD_INT 29
10390: ST_TO_ADDR
// tech_time := tech_taurad ;
10391: LD_ADDR_VAR 0 13
10395: PUSH
10396: LD_INT 28
10398: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10399: LD_ADDR_VAR 0 11
10403: PUSH
10404: LD_VAR 0 1
10408: PPUSH
10409: CALL_OW 310
10413: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10414: LD_VAR 0 11
10418: PPUSH
10419: CALL_OW 247
10423: PUSH
10424: LD_INT 2
10426: EQUAL
10427: IFFALSE 10431
// exit ;
10429: GO 10941
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10431: LD_ADDR_VAR 0 8
10435: PUSH
10436: LD_INT 81
10438: PUSH
10439: LD_VAR 0 9
10443: PUSH
10444: EMPTY
10445: LIST
10446: LIST
10447: PUSH
10448: LD_INT 3
10450: PUSH
10451: LD_INT 21
10453: PUSH
10454: LD_INT 3
10456: PUSH
10457: EMPTY
10458: LIST
10459: LIST
10460: PUSH
10461: EMPTY
10462: LIST
10463: LIST
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PPUSH
10469: CALL_OW 69
10473: ST_TO_ADDR
// if not tmp then
10474: LD_VAR 0 8
10478: NOT
10479: IFFALSE 10483
// exit ;
10481: GO 10941
// if in_unit then
10483: LD_VAR 0 11
10487: IFFALSE 10511
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10489: LD_ADDR_VAR 0 10
10493: PUSH
10494: LD_VAR 0 8
10498: PPUSH
10499: LD_VAR 0 11
10503: PPUSH
10504: CALL_OW 74
10508: ST_TO_ADDR
10509: GO 10531
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10511: LD_ADDR_VAR 0 10
10515: PUSH
10516: LD_VAR 0 8
10520: PPUSH
10521: LD_VAR 0 1
10525: PPUSH
10526: CALL_OW 74
10530: ST_TO_ADDR
// if not enemy then
10531: LD_VAR 0 10
10535: NOT
10536: IFFALSE 10540
// exit ;
10538: GO 10941
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
10540: LD_VAR 0 11
10544: PUSH
10545: LD_VAR 0 11
10549: PPUSH
10550: LD_VAR 0 10
10554: PPUSH
10555: CALL_OW 296
10559: PUSH
10560: LD_INT 13
10562: GREATER
10563: AND
10564: PUSH
10565: LD_VAR 0 1
10569: PPUSH
10570: LD_VAR 0 10
10574: PPUSH
10575: CALL_OW 296
10579: PUSH
10580: LD_INT 12
10582: GREATER
10583: OR
10584: IFFALSE 10588
// exit ;
10586: GO 10941
// missile := [ 1 ] ;
10588: LD_ADDR_VAR 0 14
10592: PUSH
10593: LD_INT 1
10595: PUSH
10596: EMPTY
10597: LIST
10598: ST_TO_ADDR
// if Researched ( side , tech_space ) then
10599: LD_VAR 0 9
10603: PPUSH
10604: LD_VAR 0 12
10608: PPUSH
10609: CALL_OW 325
10613: IFFALSE 10642
// missile := Insert ( missile , missile + 1 , 2 ) ;
10615: LD_ADDR_VAR 0 14
10619: PUSH
10620: LD_VAR 0 14
10624: PPUSH
10625: LD_VAR 0 14
10629: PUSH
10630: LD_INT 1
10632: PLUS
10633: PPUSH
10634: LD_INT 2
10636: PPUSH
10637: CALL_OW 2
10641: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
10642: LD_VAR 0 9
10646: PPUSH
10647: LD_VAR 0 13
10651: PPUSH
10652: CALL_OW 325
10656: PUSH
10657: LD_VAR 0 10
10661: PPUSH
10662: CALL_OW 255
10666: PPUSH
10667: LD_VAR 0 13
10671: PPUSH
10672: CALL_OW 325
10676: NOT
10677: AND
10678: IFFALSE 10707
// missile := Insert ( missile , missile + 1 , 3 ) ;
10680: LD_ADDR_VAR 0 14
10684: PUSH
10685: LD_VAR 0 14
10689: PPUSH
10690: LD_VAR 0 14
10694: PUSH
10695: LD_INT 1
10697: PLUS
10698: PPUSH
10699: LD_INT 3
10701: PPUSH
10702: CALL_OW 2
10706: ST_TO_ADDR
// if missile < 2 then
10707: LD_VAR 0 14
10711: PUSH
10712: LD_INT 2
10714: LESS
10715: IFFALSE 10719
// exit ;
10717: GO 10941
// x := GetX ( enemy ) ;
10719: LD_ADDR_VAR 0 4
10723: PUSH
10724: LD_VAR 0 10
10728: PPUSH
10729: CALL_OW 250
10733: ST_TO_ADDR
// y := GetY ( enemy ) ;
10734: LD_ADDR_VAR 0 5
10738: PUSH
10739: LD_VAR 0 10
10743: PPUSH
10744: CALL_OW 251
10748: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
10749: LD_ADDR_VAR 0 6
10753: PUSH
10754: LD_VAR 0 4
10758: PUSH
10759: LD_INT 1
10761: NEG
10762: PPUSH
10763: LD_INT 1
10765: PPUSH
10766: CALL_OW 12
10770: PLUS
10771: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
10772: LD_ADDR_VAR 0 7
10776: PUSH
10777: LD_VAR 0 5
10781: PUSH
10782: LD_INT 1
10784: NEG
10785: PPUSH
10786: LD_INT 1
10788: PPUSH
10789: CALL_OW 12
10793: PLUS
10794: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
10795: LD_VAR 0 6
10799: PPUSH
10800: LD_VAR 0 7
10804: PPUSH
10805: CALL_OW 488
10809: NOT
10810: IFFALSE 10832
// begin _x := x ;
10812: LD_ADDR_VAR 0 6
10816: PUSH
10817: LD_VAR 0 4
10821: ST_TO_ADDR
// _y := y ;
10822: LD_ADDR_VAR 0 7
10826: PUSH
10827: LD_VAR 0 5
10831: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
10832: LD_ADDR_VAR 0 3
10836: PUSH
10837: LD_INT 1
10839: PPUSH
10840: LD_VAR 0 14
10844: PPUSH
10845: CALL_OW 12
10849: ST_TO_ADDR
// case i of 1 :
10850: LD_VAR 0 3
10854: PUSH
10855: LD_INT 1
10857: DOUBLE
10858: EQUAL
10859: IFTRUE 10863
10861: GO 10880
10863: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
10864: LD_VAR 0 1
10868: PPUSH
10869: LD_VAR 0 10
10873: PPUSH
10874: CALL_OW 115
10878: GO 10941
10880: LD_INT 2
10882: DOUBLE
10883: EQUAL
10884: IFTRUE 10888
10886: GO 10910
10888: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
10889: LD_VAR 0 1
10893: PPUSH
10894: LD_VAR 0 6
10898: PPUSH
10899: LD_VAR 0 7
10903: PPUSH
10904: CALL_OW 153
10908: GO 10941
10910: LD_INT 3
10912: DOUBLE
10913: EQUAL
10914: IFTRUE 10918
10916: GO 10940
10918: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
10919: LD_VAR 0 1
10923: PPUSH
10924: LD_VAR 0 6
10928: PPUSH
10929: LD_VAR 0 7
10933: PPUSH
10934: CALL_OW 154
10938: GO 10941
10940: POP
// end ;
10941: LD_VAR 0 2
10945: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
10946: LD_INT 0
10948: PPUSH
10949: PPUSH
10950: PPUSH
10951: PPUSH
10952: PPUSH
10953: PPUSH
// if not unit or not building then
10954: LD_VAR 0 1
10958: NOT
10959: PUSH
10960: LD_VAR 0 2
10964: NOT
10965: OR
10966: IFFALSE 10970
// exit ;
10968: GO 11128
// x := GetX ( building ) ;
10970: LD_ADDR_VAR 0 5
10974: PUSH
10975: LD_VAR 0 2
10979: PPUSH
10980: CALL_OW 250
10984: ST_TO_ADDR
// y := GetY ( building ) ;
10985: LD_ADDR_VAR 0 6
10989: PUSH
10990: LD_VAR 0 2
10994: PPUSH
10995: CALL_OW 251
10999: ST_TO_ADDR
// for i = 0 to 5 do
11000: LD_ADDR_VAR 0 4
11004: PUSH
11005: DOUBLE
11006: LD_INT 0
11008: DEC
11009: ST_TO_ADDR
11010: LD_INT 5
11012: PUSH
11013: FOR_TO
11014: IFFALSE 11126
// begin _x := ShiftX ( x , i , 3 ) ;
11016: LD_ADDR_VAR 0 7
11020: PUSH
11021: LD_VAR 0 5
11025: PPUSH
11026: LD_VAR 0 4
11030: PPUSH
11031: LD_INT 3
11033: PPUSH
11034: CALL_OW 272
11038: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11039: LD_ADDR_VAR 0 8
11043: PUSH
11044: LD_VAR 0 6
11048: PPUSH
11049: LD_VAR 0 4
11053: PPUSH
11054: LD_INT 3
11056: PPUSH
11057: CALL_OW 273
11061: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11062: LD_VAR 0 7
11066: PPUSH
11067: LD_VAR 0 8
11071: PPUSH
11072: CALL_OW 488
11076: NOT
11077: IFFALSE 11081
// continue ;
11079: GO 11013
// if HexInfo ( _x , _y ) = 0 then
11081: LD_VAR 0 7
11085: PPUSH
11086: LD_VAR 0 8
11090: PPUSH
11091: CALL_OW 428
11095: PUSH
11096: LD_INT 0
11098: EQUAL
11099: IFFALSE 11124
// begin ComMoveXY ( unit , _x , _y ) ;
11101: LD_VAR 0 1
11105: PPUSH
11106: LD_VAR 0 7
11110: PPUSH
11111: LD_VAR 0 8
11115: PPUSH
11116: CALL_OW 111
// exit ;
11120: POP
11121: POP
11122: GO 11128
// end ; end ;
11124: GO 11013
11126: POP
11127: POP
// end ;
11128: LD_VAR 0 3
11132: RET
// export function ScanBase ( side , base_area ) ; begin
11133: LD_INT 0
11135: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: LD_VAR 0 2
11145: PPUSH
11146: LD_INT 81
11148: PUSH
11149: LD_VAR 0 1
11153: PUSH
11154: EMPTY
11155: LIST
11156: LIST
11157: PPUSH
11158: CALL_OW 70
11162: ST_TO_ADDR
// end ;
11163: LD_VAR 0 3
11167: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11168: LD_INT 0
11170: PPUSH
11171: PPUSH
11172: PPUSH
11173: PPUSH
// result := false ;
11174: LD_ADDR_VAR 0 2
11178: PUSH
11179: LD_INT 0
11181: ST_TO_ADDR
// side := GetSide ( unit ) ;
11182: LD_ADDR_VAR 0 3
11186: PUSH
11187: LD_VAR 0 1
11191: PPUSH
11192: CALL_OW 255
11196: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11197: LD_ADDR_VAR 0 4
11201: PUSH
11202: LD_VAR 0 1
11206: PPUSH
11207: CALL_OW 248
11211: ST_TO_ADDR
// case nat of 1 :
11212: LD_VAR 0 4
11216: PUSH
11217: LD_INT 1
11219: DOUBLE
11220: EQUAL
11221: IFTRUE 11225
11223: GO 11236
11225: POP
// tech := tech_lassight ; 2 :
11226: LD_ADDR_VAR 0 5
11230: PUSH
11231: LD_INT 12
11233: ST_TO_ADDR
11234: GO 11275
11236: LD_INT 2
11238: DOUBLE
11239: EQUAL
11240: IFTRUE 11244
11242: GO 11255
11244: POP
// tech := tech_mortar ; 3 :
11245: LD_ADDR_VAR 0 5
11249: PUSH
11250: LD_INT 41
11252: ST_TO_ADDR
11253: GO 11275
11255: LD_INT 3
11257: DOUBLE
11258: EQUAL
11259: IFTRUE 11263
11261: GO 11274
11263: POP
// tech := tech_bazooka ; end ;
11264: LD_ADDR_VAR 0 5
11268: PUSH
11269: LD_INT 44
11271: ST_TO_ADDR
11272: GO 11275
11274: POP
// if Researched ( side , tech ) then
11275: LD_VAR 0 3
11279: PPUSH
11280: LD_VAR 0 5
11284: PPUSH
11285: CALL_OW 325
11289: IFFALSE 11316
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11291: LD_ADDR_VAR 0 2
11295: PUSH
11296: LD_INT 5
11298: PUSH
11299: LD_INT 8
11301: PUSH
11302: LD_INT 9
11304: PUSH
11305: EMPTY
11306: LIST
11307: LIST
11308: LIST
11309: PUSH
11310: LD_VAR 0 4
11314: ARRAY
11315: ST_TO_ADDR
// end ;
11316: LD_VAR 0 2
11320: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11321: LD_INT 0
11323: PPUSH
11324: PPUSH
11325: PPUSH
// if not mines then
11326: LD_VAR 0 2
11330: NOT
11331: IFFALSE 11335
// exit ;
11333: GO 11479
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11335: LD_ADDR_VAR 0 5
11339: PUSH
11340: LD_INT 81
11342: PUSH
11343: LD_VAR 0 1
11347: PUSH
11348: EMPTY
11349: LIST
11350: LIST
11351: PUSH
11352: LD_INT 3
11354: PUSH
11355: LD_INT 21
11357: PUSH
11358: LD_INT 3
11360: PUSH
11361: EMPTY
11362: LIST
11363: LIST
11364: PUSH
11365: EMPTY
11366: LIST
11367: LIST
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PPUSH
11373: CALL_OW 69
11377: ST_TO_ADDR
// for i in mines do
11378: LD_ADDR_VAR 0 4
11382: PUSH
11383: LD_VAR 0 2
11387: PUSH
11388: FOR_IN
11389: IFFALSE 11477
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11391: LD_VAR 0 4
11395: PUSH
11396: LD_INT 1
11398: ARRAY
11399: PPUSH
11400: LD_VAR 0 4
11404: PUSH
11405: LD_INT 2
11407: ARRAY
11408: PPUSH
11409: CALL_OW 458
11413: NOT
11414: IFFALSE 11418
// continue ;
11416: GO 11388
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11418: LD_VAR 0 4
11422: PUSH
11423: LD_INT 1
11425: ARRAY
11426: PPUSH
11427: LD_VAR 0 4
11431: PUSH
11432: LD_INT 2
11434: ARRAY
11435: PPUSH
11436: CALL_OW 428
11440: PUSH
11441: LD_VAR 0 5
11445: IN
11446: IFFALSE 11475
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11448: LD_VAR 0 4
11452: PUSH
11453: LD_INT 1
11455: ARRAY
11456: PPUSH
11457: LD_VAR 0 4
11461: PUSH
11462: LD_INT 2
11464: ARRAY
11465: PPUSH
11466: LD_VAR 0 1
11470: PPUSH
11471: CALL_OW 456
// end ;
11475: GO 11388
11477: POP
11478: POP
// end ;
11479: LD_VAR 0 3
11483: RET
// export function Count ( array ) ; var i ; begin
11484: LD_INT 0
11486: PPUSH
11487: PPUSH
// result := 0 ;
11488: LD_ADDR_VAR 0 2
11492: PUSH
11493: LD_INT 0
11495: ST_TO_ADDR
// for i in array do
11496: LD_ADDR_VAR 0 3
11500: PUSH
11501: LD_VAR 0 1
11505: PUSH
11506: FOR_IN
11507: IFFALSE 11531
// if i then
11509: LD_VAR 0 3
11513: IFFALSE 11529
// result := result + 1 ;
11515: LD_ADDR_VAR 0 2
11519: PUSH
11520: LD_VAR 0 2
11524: PUSH
11525: LD_INT 1
11527: PLUS
11528: ST_TO_ADDR
11529: GO 11506
11531: POP
11532: POP
// end ;
11533: LD_VAR 0 2
11537: RET
// export function IsEmpty ( building ) ; begin
11538: LD_INT 0
11540: PPUSH
// if not building then
11541: LD_VAR 0 1
11545: NOT
11546: IFFALSE 11550
// exit ;
11548: GO 11593
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
11550: LD_ADDR_VAR 0 2
11554: PUSH
11555: LD_VAR 0 1
11559: PUSH
11560: LD_INT 22
11562: PUSH
11563: LD_VAR 0 1
11567: PPUSH
11568: CALL_OW 255
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PUSH
11577: LD_INT 58
11579: PUSH
11580: EMPTY
11581: LIST
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PPUSH
11587: CALL_OW 69
11591: IN
11592: ST_TO_ADDR
// end ;
11593: LD_VAR 0 2
11597: RET
// export function IsNotFull ( building ) ; begin
11598: LD_INT 0
11600: PPUSH
// if not building then
11601: LD_VAR 0 1
11605: NOT
11606: IFFALSE 11610
// exit ;
11608: GO 11629
// result := UnitsInside ( building ) < 6 ;
11610: LD_ADDR_VAR 0 2
11614: PUSH
11615: LD_VAR 0 1
11619: PPUSH
11620: CALL_OW 313
11624: PUSH
11625: LD_INT 6
11627: LESS
11628: ST_TO_ADDR
// end ;
11629: LD_VAR 0 2
11633: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
11634: LD_INT 0
11636: PPUSH
11637: PPUSH
11638: PPUSH
11639: PPUSH
// tmp := [ ] ;
11640: LD_ADDR_VAR 0 3
11644: PUSH
11645: EMPTY
11646: ST_TO_ADDR
// list := [ ] ;
11647: LD_ADDR_VAR 0 5
11651: PUSH
11652: EMPTY
11653: ST_TO_ADDR
// for i = 16 to 25 do
11654: LD_ADDR_VAR 0 4
11658: PUSH
11659: DOUBLE
11660: LD_INT 16
11662: DEC
11663: ST_TO_ADDR
11664: LD_INT 25
11666: PUSH
11667: FOR_TO
11668: IFFALSE 11741
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
11670: LD_ADDR_VAR 0 3
11674: PUSH
11675: LD_VAR 0 3
11679: PUSH
11680: LD_INT 22
11682: PUSH
11683: LD_VAR 0 1
11687: PPUSH
11688: CALL_OW 255
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PUSH
11697: LD_INT 91
11699: PUSH
11700: LD_VAR 0 1
11704: PUSH
11705: LD_INT 6
11707: PUSH
11708: EMPTY
11709: LIST
11710: LIST
11711: LIST
11712: PUSH
11713: LD_INT 30
11715: PUSH
11716: LD_VAR 0 4
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: PUSH
11730: EMPTY
11731: LIST
11732: PPUSH
11733: CALL_OW 69
11737: ADD
11738: ST_TO_ADDR
11739: GO 11667
11741: POP
11742: POP
// for i = 1 to tmp do
11743: LD_ADDR_VAR 0 4
11747: PUSH
11748: DOUBLE
11749: LD_INT 1
11751: DEC
11752: ST_TO_ADDR
11753: LD_VAR 0 3
11757: PUSH
11758: FOR_TO
11759: IFFALSE 11847
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11761: LD_ADDR_VAR 0 5
11765: PUSH
11766: LD_VAR 0 5
11770: PUSH
11771: LD_VAR 0 3
11775: PUSH
11776: LD_VAR 0 4
11780: ARRAY
11781: PPUSH
11782: CALL_OW 266
11786: PUSH
11787: LD_VAR 0 3
11791: PUSH
11792: LD_VAR 0 4
11796: ARRAY
11797: PPUSH
11798: CALL_OW 250
11802: PUSH
11803: LD_VAR 0 3
11807: PUSH
11808: LD_VAR 0 4
11812: ARRAY
11813: PPUSH
11814: CALL_OW 251
11818: PUSH
11819: LD_VAR 0 3
11823: PUSH
11824: LD_VAR 0 4
11828: ARRAY
11829: PPUSH
11830: CALL_OW 254
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: PUSH
11841: EMPTY
11842: LIST
11843: ADD
11844: ST_TO_ADDR
11845: GO 11758
11847: POP
11848: POP
// result := list ;
11849: LD_ADDR_VAR 0 2
11853: PUSH
11854: LD_VAR 0 5
11858: ST_TO_ADDR
// end ;
11859: LD_VAR 0 2
11863: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
11864: LD_INT 0
11866: PPUSH
11867: PPUSH
11868: PPUSH
11869: PPUSH
11870: PPUSH
11871: PPUSH
11872: PPUSH
// if not factory then
11873: LD_VAR 0 1
11877: NOT
11878: IFFALSE 11882
// exit ;
11880: GO 12475
// if control = control_apeman then
11882: LD_VAR 0 4
11886: PUSH
11887: LD_INT 5
11889: EQUAL
11890: IFFALSE 11999
// begin tmp := UnitsInside ( factory ) ;
11892: LD_ADDR_VAR 0 8
11896: PUSH
11897: LD_VAR 0 1
11901: PPUSH
11902: CALL_OW 313
11906: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
11907: LD_VAR 0 8
11911: PPUSH
11912: LD_INT 25
11914: PUSH
11915: LD_INT 12
11917: PUSH
11918: EMPTY
11919: LIST
11920: LIST
11921: PPUSH
11922: CALL_OW 72
11926: NOT
11927: IFFALSE 11937
// control := control_manual ;
11929: LD_ADDR_VAR 0 4
11933: PUSH
11934: LD_INT 1
11936: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
11937: LD_ADDR_VAR 0 8
11941: PUSH
11942: LD_VAR 0 1
11946: PPUSH
11947: CALL 11634 0 1
11951: ST_TO_ADDR
// if tmp then
11952: LD_VAR 0 8
11956: IFFALSE 11999
// begin for i in tmp do
11958: LD_ADDR_VAR 0 7
11962: PUSH
11963: LD_VAR 0 8
11967: PUSH
11968: FOR_IN
11969: IFFALSE 11997
// if i [ 1 ] = b_ext_radio then
11971: LD_VAR 0 7
11975: PUSH
11976: LD_INT 1
11978: ARRAY
11979: PUSH
11980: LD_INT 22
11982: EQUAL
11983: IFFALSE 11995
// begin control := control_remote ;
11985: LD_ADDR_VAR 0 4
11989: PUSH
11990: LD_INT 2
11992: ST_TO_ADDR
// break ;
11993: GO 11997
// end ;
11995: GO 11968
11997: POP
11998: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
11999: LD_VAR 0 1
12003: PPUSH
12004: LD_VAR 0 2
12008: PPUSH
12009: LD_VAR 0 3
12013: PPUSH
12014: LD_VAR 0 4
12018: PPUSH
12019: LD_VAR 0 5
12023: PPUSH
12024: CALL_OW 448
12028: IFFALSE 12063
// begin result := [ chassis , engine , control , weapon ] ;
12030: LD_ADDR_VAR 0 6
12034: PUSH
12035: LD_VAR 0 2
12039: PUSH
12040: LD_VAR 0 3
12044: PUSH
12045: LD_VAR 0 4
12049: PUSH
12050: LD_VAR 0 5
12054: PUSH
12055: EMPTY
12056: LIST
12057: LIST
12058: LIST
12059: LIST
12060: ST_TO_ADDR
// exit ;
12061: GO 12475
// end ; _chassis := AvailableChassisList ( factory ) ;
12063: LD_ADDR_VAR 0 9
12067: PUSH
12068: LD_VAR 0 1
12072: PPUSH
12073: CALL_OW 475
12077: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12078: LD_ADDR_VAR 0 11
12082: PUSH
12083: LD_VAR 0 1
12087: PPUSH
12088: CALL_OW 476
12092: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12093: LD_ADDR_VAR 0 12
12097: PUSH
12098: LD_VAR 0 1
12102: PPUSH
12103: CALL_OW 477
12107: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12108: LD_ADDR_VAR 0 10
12112: PUSH
12113: LD_VAR 0 1
12117: PPUSH
12118: CALL_OW 478
12122: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12123: LD_VAR 0 9
12127: NOT
12128: PUSH
12129: LD_VAR 0 11
12133: NOT
12134: OR
12135: PUSH
12136: LD_VAR 0 12
12140: NOT
12141: OR
12142: PUSH
12143: LD_VAR 0 10
12147: NOT
12148: OR
12149: IFFALSE 12184
// begin result := [ chassis , engine , control , weapon ] ;
12151: LD_ADDR_VAR 0 6
12155: PUSH
12156: LD_VAR 0 2
12160: PUSH
12161: LD_VAR 0 3
12165: PUSH
12166: LD_VAR 0 4
12170: PUSH
12171: LD_VAR 0 5
12175: PUSH
12176: EMPTY
12177: LIST
12178: LIST
12179: LIST
12180: LIST
12181: ST_TO_ADDR
// exit ;
12182: GO 12475
// end ; if not chassis in _chassis then
12184: LD_VAR 0 2
12188: PUSH
12189: LD_VAR 0 9
12193: IN
12194: NOT
12195: IFFALSE 12221
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12197: LD_ADDR_VAR 0 2
12201: PUSH
12202: LD_VAR 0 9
12206: PUSH
12207: LD_INT 1
12209: PPUSH
12210: LD_VAR 0 9
12214: PPUSH
12215: CALL_OW 12
12219: ARRAY
12220: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12221: LD_VAR 0 2
12225: PPUSH
12226: LD_VAR 0 3
12230: PPUSH
12231: CALL 12480 0 2
12235: NOT
12236: IFFALSE 12295
// repeat engine := _engine [ 1 ] ;
12238: LD_ADDR_VAR 0 3
12242: PUSH
12243: LD_VAR 0 11
12247: PUSH
12248: LD_INT 1
12250: ARRAY
12251: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12252: LD_ADDR_VAR 0 11
12256: PUSH
12257: LD_VAR 0 11
12261: PPUSH
12262: LD_INT 1
12264: PPUSH
12265: CALL_OW 3
12269: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12270: LD_VAR 0 2
12274: PPUSH
12275: LD_VAR 0 3
12279: PPUSH
12280: CALL 12480 0 2
12284: PUSH
12285: LD_VAR 0 11
12289: PUSH
12290: EMPTY
12291: EQUAL
12292: OR
12293: IFFALSE 12238
// if not control in _control then
12295: LD_VAR 0 4
12299: PUSH
12300: LD_VAR 0 12
12304: IN
12305: NOT
12306: IFFALSE 12332
// control := _control [ rand ( 1 , _control ) ] ;
12308: LD_ADDR_VAR 0 4
12312: PUSH
12313: LD_VAR 0 12
12317: PUSH
12318: LD_INT 1
12320: PPUSH
12321: LD_VAR 0 12
12325: PPUSH
12326: CALL_OW 12
12330: ARRAY
12331: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12332: LD_VAR 0 2
12336: PPUSH
12337: LD_VAR 0 5
12341: PPUSH
12342: CALL 12700 0 2
12346: NOT
12347: IFFALSE 12406
// repeat weapon := _weapon [ 1 ] ;
12349: LD_ADDR_VAR 0 5
12353: PUSH
12354: LD_VAR 0 10
12358: PUSH
12359: LD_INT 1
12361: ARRAY
12362: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12363: LD_ADDR_VAR 0 10
12367: PUSH
12368: LD_VAR 0 10
12372: PPUSH
12373: LD_INT 1
12375: PPUSH
12376: CALL_OW 3
12380: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12381: LD_VAR 0 2
12385: PPUSH
12386: LD_VAR 0 5
12390: PPUSH
12391: CALL 12700 0 2
12395: PUSH
12396: LD_VAR 0 10
12400: PUSH
12401: EMPTY
12402: EQUAL
12403: OR
12404: IFFALSE 12349
// result := [ ] ;
12406: LD_ADDR_VAR 0 6
12410: PUSH
12411: EMPTY
12412: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12413: LD_VAR 0 1
12417: PPUSH
12418: LD_VAR 0 2
12422: PPUSH
12423: LD_VAR 0 3
12427: PPUSH
12428: LD_VAR 0 4
12432: PPUSH
12433: LD_VAR 0 5
12437: PPUSH
12438: CALL_OW 448
12442: IFFALSE 12475
// result := [ chassis , engine , control , weapon ] ;
12444: LD_ADDR_VAR 0 6
12448: PUSH
12449: LD_VAR 0 2
12453: PUSH
12454: LD_VAR 0 3
12458: PUSH
12459: LD_VAR 0 4
12463: PUSH
12464: LD_VAR 0 5
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: LIST
12473: LIST
12474: ST_TO_ADDR
// end ;
12475: LD_VAR 0 6
12479: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12480: LD_INT 0
12482: PPUSH
// if not chassis or not engine then
12483: LD_VAR 0 1
12487: NOT
12488: PUSH
12489: LD_VAR 0 2
12493: NOT
12494: OR
12495: IFFALSE 12499
// exit ;
12497: GO 12695
// case engine of engine_solar :
12499: LD_VAR 0 2
12503: PUSH
12504: LD_INT 2
12506: DOUBLE
12507: EQUAL
12508: IFTRUE 12512
12510: GO 12550
12512: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12513: LD_ADDR_VAR 0 3
12517: PUSH
12518: LD_INT 11
12520: PUSH
12521: LD_INT 12
12523: PUSH
12524: LD_INT 13
12526: PUSH
12527: LD_INT 14
12529: PUSH
12530: LD_INT 1
12532: PUSH
12533: LD_INT 2
12535: PUSH
12536: LD_INT 3
12538: PUSH
12539: EMPTY
12540: LIST
12541: LIST
12542: LIST
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: ST_TO_ADDR
12548: GO 12679
12550: LD_INT 1
12552: DOUBLE
12553: EQUAL
12554: IFTRUE 12558
12556: GO 12620
12558: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
12559: LD_ADDR_VAR 0 3
12563: PUSH
12564: LD_INT 11
12566: PUSH
12567: LD_INT 12
12569: PUSH
12570: LD_INT 13
12572: PUSH
12573: LD_INT 14
12575: PUSH
12576: LD_INT 1
12578: PUSH
12579: LD_INT 2
12581: PUSH
12582: LD_INT 3
12584: PUSH
12585: LD_INT 4
12587: PUSH
12588: LD_INT 5
12590: PUSH
12591: LD_INT 21
12593: PUSH
12594: LD_INT 23
12596: PUSH
12597: LD_INT 22
12599: PUSH
12600: LD_INT 24
12602: PUSH
12603: EMPTY
12604: LIST
12605: LIST
12606: LIST
12607: LIST
12608: LIST
12609: LIST
12610: LIST
12611: LIST
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: ST_TO_ADDR
12618: GO 12679
12620: LD_INT 3
12622: DOUBLE
12623: EQUAL
12624: IFTRUE 12628
12626: GO 12678
12628: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
12629: LD_ADDR_VAR 0 3
12633: PUSH
12634: LD_INT 13
12636: PUSH
12637: LD_INT 14
12639: PUSH
12640: LD_INT 2
12642: PUSH
12643: LD_INT 3
12645: PUSH
12646: LD_INT 4
12648: PUSH
12649: LD_INT 5
12651: PUSH
12652: LD_INT 21
12654: PUSH
12655: LD_INT 22
12657: PUSH
12658: LD_INT 23
12660: PUSH
12661: LD_INT 24
12663: PUSH
12664: EMPTY
12665: LIST
12666: LIST
12667: LIST
12668: LIST
12669: LIST
12670: LIST
12671: LIST
12672: LIST
12673: LIST
12674: LIST
12675: ST_TO_ADDR
12676: GO 12679
12678: POP
// result := ( chassis in result ) ;
12679: LD_ADDR_VAR 0 3
12683: PUSH
12684: LD_VAR 0 1
12688: PUSH
12689: LD_VAR 0 3
12693: IN
12694: ST_TO_ADDR
// end ;
12695: LD_VAR 0 3
12699: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
12700: LD_INT 0
12702: PPUSH
// if not chassis or not weapon then
12703: LD_VAR 0 1
12707: NOT
12708: PUSH
12709: LD_VAR 0 2
12713: NOT
12714: OR
12715: IFFALSE 12719
// exit ;
12717: GO 13745
// case weapon of us_machine_gun :
12719: LD_VAR 0 2
12723: PUSH
12724: LD_INT 2
12726: DOUBLE
12727: EQUAL
12728: IFTRUE 12732
12730: GO 12762
12732: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
12733: LD_ADDR_VAR 0 3
12737: PUSH
12738: LD_INT 1
12740: PUSH
12741: LD_INT 2
12743: PUSH
12744: LD_INT 3
12746: PUSH
12747: LD_INT 4
12749: PUSH
12750: LD_INT 5
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: LIST
12757: LIST
12758: LIST
12759: ST_TO_ADDR
12760: GO 13729
12762: LD_INT 3
12764: DOUBLE
12765: EQUAL
12766: IFTRUE 12770
12768: GO 12800
12770: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
12771: LD_ADDR_VAR 0 3
12775: PUSH
12776: LD_INT 1
12778: PUSH
12779: LD_INT 2
12781: PUSH
12782: LD_INT 3
12784: PUSH
12785: LD_INT 4
12787: PUSH
12788: LD_INT 5
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: LIST
12797: ST_TO_ADDR
12798: GO 13729
12800: LD_INT 11
12802: DOUBLE
12803: EQUAL
12804: IFTRUE 12808
12806: GO 12838
12808: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
12809: LD_ADDR_VAR 0 3
12813: PUSH
12814: LD_INT 1
12816: PUSH
12817: LD_INT 2
12819: PUSH
12820: LD_INT 3
12822: PUSH
12823: LD_INT 4
12825: PUSH
12826: LD_INT 5
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: LIST
12833: LIST
12834: LIST
12835: ST_TO_ADDR
12836: GO 13729
12838: LD_INT 4
12840: DOUBLE
12841: EQUAL
12842: IFTRUE 12846
12844: GO 12872
12846: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
12847: LD_ADDR_VAR 0 3
12851: PUSH
12852: LD_INT 2
12854: PUSH
12855: LD_INT 3
12857: PUSH
12858: LD_INT 4
12860: PUSH
12861: LD_INT 5
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: ST_TO_ADDR
12870: GO 13729
12872: LD_INT 5
12874: DOUBLE
12875: EQUAL
12876: IFTRUE 12880
12878: GO 12906
12880: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
12881: LD_ADDR_VAR 0 3
12885: PUSH
12886: LD_INT 2
12888: PUSH
12889: LD_INT 3
12891: PUSH
12892: LD_INT 4
12894: PUSH
12895: LD_INT 5
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: LIST
12902: LIST
12903: ST_TO_ADDR
12904: GO 13729
12906: LD_INT 9
12908: DOUBLE
12909: EQUAL
12910: IFTRUE 12914
12912: GO 12940
12914: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
12915: LD_ADDR_VAR 0 3
12919: PUSH
12920: LD_INT 2
12922: PUSH
12923: LD_INT 3
12925: PUSH
12926: LD_INT 4
12928: PUSH
12929: LD_INT 5
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: LIST
12936: LIST
12937: ST_TO_ADDR
12938: GO 13729
12940: LD_INT 7
12942: DOUBLE
12943: EQUAL
12944: IFTRUE 12948
12946: GO 12974
12948: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
12949: LD_ADDR_VAR 0 3
12953: PUSH
12954: LD_INT 2
12956: PUSH
12957: LD_INT 3
12959: PUSH
12960: LD_INT 4
12962: PUSH
12963: LD_INT 5
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: ST_TO_ADDR
12972: GO 13729
12974: LD_INT 12
12976: DOUBLE
12977: EQUAL
12978: IFTRUE 12982
12980: GO 13008
12982: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
12983: LD_ADDR_VAR 0 3
12987: PUSH
12988: LD_INT 2
12990: PUSH
12991: LD_INT 3
12993: PUSH
12994: LD_INT 4
12996: PUSH
12997: LD_INT 5
12999: PUSH
13000: EMPTY
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: ST_TO_ADDR
13006: GO 13729
13008: LD_INT 13
13010: DOUBLE
13011: EQUAL
13012: IFTRUE 13016
13014: GO 13042
13016: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13017: LD_ADDR_VAR 0 3
13021: PUSH
13022: LD_INT 2
13024: PUSH
13025: LD_INT 3
13027: PUSH
13028: LD_INT 4
13030: PUSH
13031: LD_INT 5
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: LIST
13038: LIST
13039: ST_TO_ADDR
13040: GO 13729
13042: LD_INT 14
13044: DOUBLE
13045: EQUAL
13046: IFTRUE 13050
13048: GO 13068
13050: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13051: LD_ADDR_VAR 0 3
13055: PUSH
13056: LD_INT 4
13058: PUSH
13059: LD_INT 5
13061: PUSH
13062: EMPTY
13063: LIST
13064: LIST
13065: ST_TO_ADDR
13066: GO 13729
13068: LD_INT 6
13070: DOUBLE
13071: EQUAL
13072: IFTRUE 13076
13074: GO 13094
13076: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13077: LD_ADDR_VAR 0 3
13081: PUSH
13082: LD_INT 4
13084: PUSH
13085: LD_INT 5
13087: PUSH
13088: EMPTY
13089: LIST
13090: LIST
13091: ST_TO_ADDR
13092: GO 13729
13094: LD_INT 10
13096: DOUBLE
13097: EQUAL
13098: IFTRUE 13102
13100: GO 13120
13102: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13103: LD_ADDR_VAR 0 3
13107: PUSH
13108: LD_INT 4
13110: PUSH
13111: LD_INT 5
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: ST_TO_ADDR
13118: GO 13729
13120: LD_INT 22
13122: DOUBLE
13123: EQUAL
13124: IFTRUE 13128
13126: GO 13154
13128: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13129: LD_ADDR_VAR 0 3
13133: PUSH
13134: LD_INT 11
13136: PUSH
13137: LD_INT 12
13139: PUSH
13140: LD_INT 13
13142: PUSH
13143: LD_INT 14
13145: PUSH
13146: EMPTY
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: ST_TO_ADDR
13152: GO 13729
13154: LD_INT 23
13156: DOUBLE
13157: EQUAL
13158: IFTRUE 13162
13160: GO 13188
13162: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13163: LD_ADDR_VAR 0 3
13167: PUSH
13168: LD_INT 11
13170: PUSH
13171: LD_INT 12
13173: PUSH
13174: LD_INT 13
13176: PUSH
13177: LD_INT 14
13179: PUSH
13180: EMPTY
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: ST_TO_ADDR
13186: GO 13729
13188: LD_INT 24
13190: DOUBLE
13191: EQUAL
13192: IFTRUE 13196
13194: GO 13222
13196: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13197: LD_ADDR_VAR 0 3
13201: PUSH
13202: LD_INT 11
13204: PUSH
13205: LD_INT 12
13207: PUSH
13208: LD_INT 13
13210: PUSH
13211: LD_INT 14
13213: PUSH
13214: EMPTY
13215: LIST
13216: LIST
13217: LIST
13218: LIST
13219: ST_TO_ADDR
13220: GO 13729
13222: LD_INT 30
13224: DOUBLE
13225: EQUAL
13226: IFTRUE 13230
13228: GO 13256
13230: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13231: LD_ADDR_VAR 0 3
13235: PUSH
13236: LD_INT 11
13238: PUSH
13239: LD_INT 12
13241: PUSH
13242: LD_INT 13
13244: PUSH
13245: LD_INT 14
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: ST_TO_ADDR
13254: GO 13729
13256: LD_INT 25
13258: DOUBLE
13259: EQUAL
13260: IFTRUE 13264
13262: GO 13282
13264: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13265: LD_ADDR_VAR 0 3
13269: PUSH
13270: LD_INT 13
13272: PUSH
13273: LD_INT 14
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: ST_TO_ADDR
13280: GO 13729
13282: LD_INT 27
13284: DOUBLE
13285: EQUAL
13286: IFTRUE 13290
13288: GO 13308
13290: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13291: LD_ADDR_VAR 0 3
13295: PUSH
13296: LD_INT 13
13298: PUSH
13299: LD_INT 14
13301: PUSH
13302: EMPTY
13303: LIST
13304: LIST
13305: ST_TO_ADDR
13306: GO 13729
13308: LD_INT 28
13310: DOUBLE
13311: EQUAL
13312: IFTRUE 13316
13314: GO 13334
13316: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13317: LD_ADDR_VAR 0 3
13321: PUSH
13322: LD_INT 13
13324: PUSH
13325: LD_INT 14
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: ST_TO_ADDR
13332: GO 13729
13334: LD_INT 29
13336: DOUBLE
13337: EQUAL
13338: IFTRUE 13342
13340: GO 13360
13342: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13343: LD_ADDR_VAR 0 3
13347: PUSH
13348: LD_INT 13
13350: PUSH
13351: LD_INT 14
13353: PUSH
13354: EMPTY
13355: LIST
13356: LIST
13357: ST_TO_ADDR
13358: GO 13729
13360: LD_INT 31
13362: DOUBLE
13363: EQUAL
13364: IFTRUE 13368
13366: GO 13386
13368: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13369: LD_ADDR_VAR 0 3
13373: PUSH
13374: LD_INT 13
13376: PUSH
13377: LD_INT 14
13379: PUSH
13380: EMPTY
13381: LIST
13382: LIST
13383: ST_TO_ADDR
13384: GO 13729
13386: LD_INT 26
13388: DOUBLE
13389: EQUAL
13390: IFTRUE 13394
13392: GO 13412
13394: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13395: LD_ADDR_VAR 0 3
13399: PUSH
13400: LD_INT 13
13402: PUSH
13403: LD_INT 14
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: ST_TO_ADDR
13410: GO 13729
13412: LD_INT 42
13414: DOUBLE
13415: EQUAL
13416: IFTRUE 13420
13418: GO 13446
13420: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13421: LD_ADDR_VAR 0 3
13425: PUSH
13426: LD_INT 21
13428: PUSH
13429: LD_INT 22
13431: PUSH
13432: LD_INT 23
13434: PUSH
13435: LD_INT 24
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: LIST
13442: LIST
13443: ST_TO_ADDR
13444: GO 13729
13446: LD_INT 43
13448: DOUBLE
13449: EQUAL
13450: IFTRUE 13454
13452: GO 13480
13454: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13455: LD_ADDR_VAR 0 3
13459: PUSH
13460: LD_INT 21
13462: PUSH
13463: LD_INT 22
13465: PUSH
13466: LD_INT 23
13468: PUSH
13469: LD_INT 24
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: LIST
13476: LIST
13477: ST_TO_ADDR
13478: GO 13729
13480: LD_INT 44
13482: DOUBLE
13483: EQUAL
13484: IFTRUE 13488
13486: GO 13514
13488: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13489: LD_ADDR_VAR 0 3
13493: PUSH
13494: LD_INT 21
13496: PUSH
13497: LD_INT 22
13499: PUSH
13500: LD_INT 23
13502: PUSH
13503: LD_INT 24
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: LIST
13510: LIST
13511: ST_TO_ADDR
13512: GO 13729
13514: LD_INT 45
13516: DOUBLE
13517: EQUAL
13518: IFTRUE 13522
13520: GO 13548
13522: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13523: LD_ADDR_VAR 0 3
13527: PUSH
13528: LD_INT 21
13530: PUSH
13531: LD_INT 22
13533: PUSH
13534: LD_INT 23
13536: PUSH
13537: LD_INT 24
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: LIST
13544: LIST
13545: ST_TO_ADDR
13546: GO 13729
13548: LD_INT 49
13550: DOUBLE
13551: EQUAL
13552: IFTRUE 13556
13554: GO 13582
13556: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
13557: LD_ADDR_VAR 0 3
13561: PUSH
13562: LD_INT 21
13564: PUSH
13565: LD_INT 22
13567: PUSH
13568: LD_INT 23
13570: PUSH
13571: LD_INT 24
13573: PUSH
13574: EMPTY
13575: LIST
13576: LIST
13577: LIST
13578: LIST
13579: ST_TO_ADDR
13580: GO 13729
13582: LD_INT 51
13584: DOUBLE
13585: EQUAL
13586: IFTRUE 13590
13588: GO 13616
13590: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
13591: LD_ADDR_VAR 0 3
13595: PUSH
13596: LD_INT 21
13598: PUSH
13599: LD_INT 22
13601: PUSH
13602: LD_INT 23
13604: PUSH
13605: LD_INT 24
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: ST_TO_ADDR
13614: GO 13729
13616: LD_INT 52
13618: DOUBLE
13619: EQUAL
13620: IFTRUE 13624
13622: GO 13650
13624: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
13625: LD_ADDR_VAR 0 3
13629: PUSH
13630: LD_INT 21
13632: PUSH
13633: LD_INT 22
13635: PUSH
13636: LD_INT 23
13638: PUSH
13639: LD_INT 24
13641: PUSH
13642: EMPTY
13643: LIST
13644: LIST
13645: LIST
13646: LIST
13647: ST_TO_ADDR
13648: GO 13729
13650: LD_INT 53
13652: DOUBLE
13653: EQUAL
13654: IFTRUE 13658
13656: GO 13676
13658: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
13659: LD_ADDR_VAR 0 3
13663: PUSH
13664: LD_INT 23
13666: PUSH
13667: LD_INT 24
13669: PUSH
13670: EMPTY
13671: LIST
13672: LIST
13673: ST_TO_ADDR
13674: GO 13729
13676: LD_INT 46
13678: DOUBLE
13679: EQUAL
13680: IFTRUE 13684
13682: GO 13702
13684: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
13685: LD_ADDR_VAR 0 3
13689: PUSH
13690: LD_INT 23
13692: PUSH
13693: LD_INT 24
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: ST_TO_ADDR
13700: GO 13729
13702: LD_INT 47
13704: DOUBLE
13705: EQUAL
13706: IFTRUE 13710
13708: GO 13728
13710: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13711: LD_ADDR_VAR 0 3
13715: PUSH
13716: LD_INT 23
13718: PUSH
13719: LD_INT 24
13721: PUSH
13722: EMPTY
13723: LIST
13724: LIST
13725: ST_TO_ADDR
13726: GO 13729
13728: POP
// result := ( chassis in result ) ;
13729: LD_ADDR_VAR 0 3
13733: PUSH
13734: LD_VAR 0 1
13738: PUSH
13739: LD_VAR 0 3
13743: IN
13744: ST_TO_ADDR
// end ;
13745: LD_VAR 0 3
13749: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
13750: LD_INT 0
13752: PPUSH
13753: PPUSH
13754: PPUSH
13755: PPUSH
13756: PPUSH
13757: PPUSH
13758: PPUSH
// result := array ;
13759: LD_ADDR_VAR 0 5
13763: PUSH
13764: LD_VAR 0 1
13768: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
13769: LD_VAR 0 1
13773: NOT
13774: PUSH
13775: LD_VAR 0 2
13779: NOT
13780: OR
13781: PUSH
13782: LD_VAR 0 3
13786: NOT
13787: OR
13788: PUSH
13789: LD_VAR 0 2
13793: PUSH
13794: LD_VAR 0 1
13798: GREATER
13799: OR
13800: PUSH
13801: LD_VAR 0 3
13805: PUSH
13806: LD_VAR 0 1
13810: GREATER
13811: OR
13812: IFFALSE 13816
// exit ;
13814: GO 14112
// if direction then
13816: LD_VAR 0 4
13820: IFFALSE 13884
// begin d := 1 ;
13822: LD_ADDR_VAR 0 9
13826: PUSH
13827: LD_INT 1
13829: ST_TO_ADDR
// if i_from > i_to then
13830: LD_VAR 0 2
13834: PUSH
13835: LD_VAR 0 3
13839: GREATER
13840: IFFALSE 13866
// length := ( array - i_from ) + i_to else
13842: LD_ADDR_VAR 0 11
13846: PUSH
13847: LD_VAR 0 1
13851: PUSH
13852: LD_VAR 0 2
13856: MINUS
13857: PUSH
13858: LD_VAR 0 3
13862: PLUS
13863: ST_TO_ADDR
13864: GO 13882
// length := i_to - i_from ;
13866: LD_ADDR_VAR 0 11
13870: PUSH
13871: LD_VAR 0 3
13875: PUSH
13876: LD_VAR 0 2
13880: MINUS
13881: ST_TO_ADDR
// end else
13882: GO 13945
// begin d := - 1 ;
13884: LD_ADDR_VAR 0 9
13888: PUSH
13889: LD_INT 1
13891: NEG
13892: ST_TO_ADDR
// if i_from > i_to then
13893: LD_VAR 0 2
13897: PUSH
13898: LD_VAR 0 3
13902: GREATER
13903: IFFALSE 13923
// length := i_from - i_to else
13905: LD_ADDR_VAR 0 11
13909: PUSH
13910: LD_VAR 0 2
13914: PUSH
13915: LD_VAR 0 3
13919: MINUS
13920: ST_TO_ADDR
13921: GO 13945
// length := ( array - i_to ) + i_from ;
13923: LD_ADDR_VAR 0 11
13927: PUSH
13928: LD_VAR 0 1
13932: PUSH
13933: LD_VAR 0 3
13937: MINUS
13938: PUSH
13939: LD_VAR 0 2
13943: PLUS
13944: ST_TO_ADDR
// end ; if not length then
13945: LD_VAR 0 11
13949: NOT
13950: IFFALSE 13954
// exit ;
13952: GO 14112
// tmp := array ;
13954: LD_ADDR_VAR 0 10
13958: PUSH
13959: LD_VAR 0 1
13963: ST_TO_ADDR
// for i = 1 to length do
13964: LD_ADDR_VAR 0 6
13968: PUSH
13969: DOUBLE
13970: LD_INT 1
13972: DEC
13973: ST_TO_ADDR
13974: LD_VAR 0 11
13978: PUSH
13979: FOR_TO
13980: IFFALSE 14100
// begin for j = 1 to array do
13982: LD_ADDR_VAR 0 7
13986: PUSH
13987: DOUBLE
13988: LD_INT 1
13990: DEC
13991: ST_TO_ADDR
13992: LD_VAR 0 1
13996: PUSH
13997: FOR_TO
13998: IFFALSE 14086
// begin k := j + d ;
14000: LD_ADDR_VAR 0 8
14004: PUSH
14005: LD_VAR 0 7
14009: PUSH
14010: LD_VAR 0 9
14014: PLUS
14015: ST_TO_ADDR
// if k > array then
14016: LD_VAR 0 8
14020: PUSH
14021: LD_VAR 0 1
14025: GREATER
14026: IFFALSE 14036
// k := 1 ;
14028: LD_ADDR_VAR 0 8
14032: PUSH
14033: LD_INT 1
14035: ST_TO_ADDR
// if not k then
14036: LD_VAR 0 8
14040: NOT
14041: IFFALSE 14053
// k := array ;
14043: LD_ADDR_VAR 0 8
14047: PUSH
14048: LD_VAR 0 1
14052: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14053: LD_ADDR_VAR 0 10
14057: PUSH
14058: LD_VAR 0 10
14062: PPUSH
14063: LD_VAR 0 8
14067: PPUSH
14068: LD_VAR 0 1
14072: PUSH
14073: LD_VAR 0 7
14077: ARRAY
14078: PPUSH
14079: CALL_OW 1
14083: ST_TO_ADDR
// end ;
14084: GO 13997
14086: POP
14087: POP
// array := tmp ;
14088: LD_ADDR_VAR 0 1
14092: PUSH
14093: LD_VAR 0 10
14097: ST_TO_ADDR
// end ;
14098: GO 13979
14100: POP
14101: POP
// result := array ;
14102: LD_ADDR_VAR 0 5
14106: PUSH
14107: LD_VAR 0 1
14111: ST_TO_ADDR
// end ;
14112: LD_VAR 0 5
14116: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14117: LD_INT 0
14119: PPUSH
14120: PPUSH
// result := 0 ;
14121: LD_ADDR_VAR 0 3
14125: PUSH
14126: LD_INT 0
14128: ST_TO_ADDR
// if not array or not value in array then
14129: LD_VAR 0 1
14133: NOT
14134: PUSH
14135: LD_VAR 0 2
14139: PUSH
14140: LD_VAR 0 1
14144: IN
14145: NOT
14146: OR
14147: IFFALSE 14151
// exit ;
14149: GO 14205
// for i = 1 to array do
14151: LD_ADDR_VAR 0 4
14155: PUSH
14156: DOUBLE
14157: LD_INT 1
14159: DEC
14160: ST_TO_ADDR
14161: LD_VAR 0 1
14165: PUSH
14166: FOR_TO
14167: IFFALSE 14203
// if value = array [ i ] then
14169: LD_VAR 0 2
14173: PUSH
14174: LD_VAR 0 1
14178: PUSH
14179: LD_VAR 0 4
14183: ARRAY
14184: EQUAL
14185: IFFALSE 14201
// begin result := i ;
14187: LD_ADDR_VAR 0 3
14191: PUSH
14192: LD_VAR 0 4
14196: ST_TO_ADDR
// exit ;
14197: POP
14198: POP
14199: GO 14205
// end ;
14201: GO 14166
14203: POP
14204: POP
// end ;
14205: LD_VAR 0 3
14209: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14210: LD_INT 0
14212: PPUSH
// vc_chassis := chassis ;
14213: LD_ADDR_OWVAR 37
14217: PUSH
14218: LD_VAR 0 1
14222: ST_TO_ADDR
// vc_engine := engine ;
14223: LD_ADDR_OWVAR 39
14227: PUSH
14228: LD_VAR 0 2
14232: ST_TO_ADDR
// vc_control := control ;
14233: LD_ADDR_OWVAR 38
14237: PUSH
14238: LD_VAR 0 3
14242: ST_TO_ADDR
// vc_weapon := weapon ;
14243: LD_ADDR_OWVAR 40
14247: PUSH
14248: LD_VAR 0 4
14252: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14253: LD_ADDR_OWVAR 41
14257: PUSH
14258: LD_VAR 0 5
14262: ST_TO_ADDR
// end ;
14263: LD_VAR 0 6
14267: RET
// export function WantPlant ( unit ) ; var task ; begin
14268: LD_INT 0
14270: PPUSH
14271: PPUSH
// result := false ;
14272: LD_ADDR_VAR 0 2
14276: PUSH
14277: LD_INT 0
14279: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14280: LD_ADDR_VAR 0 3
14284: PUSH
14285: LD_VAR 0 1
14289: PPUSH
14290: CALL_OW 437
14294: ST_TO_ADDR
// if task then
14295: LD_VAR 0 3
14299: IFFALSE 14327
// if task [ 1 ] [ 1 ] = p then
14301: LD_VAR 0 3
14305: PUSH
14306: LD_INT 1
14308: ARRAY
14309: PUSH
14310: LD_INT 1
14312: ARRAY
14313: PUSH
14314: LD_STRING p
14316: EQUAL
14317: IFFALSE 14327
// result := true ;
14319: LD_ADDR_VAR 0 2
14323: PUSH
14324: LD_INT 1
14326: ST_TO_ADDR
// end ;
14327: LD_VAR 0 2
14331: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14332: LD_INT 0
14334: PPUSH
14335: PPUSH
14336: PPUSH
14337: PPUSH
// if pos < 1 then
14338: LD_VAR 0 2
14342: PUSH
14343: LD_INT 1
14345: LESS
14346: IFFALSE 14350
// exit ;
14348: GO 14653
// if pos = 1 then
14350: LD_VAR 0 2
14354: PUSH
14355: LD_INT 1
14357: EQUAL
14358: IFFALSE 14391
// result := Replace ( arr , pos [ 1 ] , value ) else
14360: LD_ADDR_VAR 0 4
14364: PUSH
14365: LD_VAR 0 1
14369: PPUSH
14370: LD_VAR 0 2
14374: PUSH
14375: LD_INT 1
14377: ARRAY
14378: PPUSH
14379: LD_VAR 0 3
14383: PPUSH
14384: CALL_OW 1
14388: ST_TO_ADDR
14389: GO 14653
// begin tmp := arr ;
14391: LD_ADDR_VAR 0 6
14395: PUSH
14396: LD_VAR 0 1
14400: ST_TO_ADDR
// s_arr := [ tmp ] ;
14401: LD_ADDR_VAR 0 7
14405: PUSH
14406: LD_VAR 0 6
14410: PUSH
14411: EMPTY
14412: LIST
14413: ST_TO_ADDR
// for i = 1 to pos - 1 do
14414: LD_ADDR_VAR 0 5
14418: PUSH
14419: DOUBLE
14420: LD_INT 1
14422: DEC
14423: ST_TO_ADDR
14424: LD_VAR 0 2
14428: PUSH
14429: LD_INT 1
14431: MINUS
14432: PUSH
14433: FOR_TO
14434: IFFALSE 14479
// begin tmp := tmp [ pos [ i ] ] ;
14436: LD_ADDR_VAR 0 6
14440: PUSH
14441: LD_VAR 0 6
14445: PUSH
14446: LD_VAR 0 2
14450: PUSH
14451: LD_VAR 0 5
14455: ARRAY
14456: ARRAY
14457: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14458: LD_ADDR_VAR 0 7
14462: PUSH
14463: LD_VAR 0 7
14467: PUSH
14468: LD_VAR 0 6
14472: PUSH
14473: EMPTY
14474: LIST
14475: ADD
14476: ST_TO_ADDR
// end ;
14477: GO 14433
14479: POP
14480: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14481: LD_ADDR_VAR 0 6
14485: PUSH
14486: LD_VAR 0 6
14490: PPUSH
14491: LD_VAR 0 2
14495: PUSH
14496: LD_VAR 0 2
14500: ARRAY
14501: PPUSH
14502: LD_VAR 0 3
14506: PPUSH
14507: CALL_OW 1
14511: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14512: LD_ADDR_VAR 0 7
14516: PUSH
14517: LD_VAR 0 7
14521: PPUSH
14522: LD_VAR 0 7
14526: PPUSH
14527: LD_VAR 0 6
14531: PPUSH
14532: CALL_OW 1
14536: ST_TO_ADDR
// for i = s_arr downto 2 do
14537: LD_ADDR_VAR 0 5
14541: PUSH
14542: DOUBLE
14543: LD_VAR 0 7
14547: INC
14548: ST_TO_ADDR
14549: LD_INT 2
14551: PUSH
14552: FOR_DOWNTO
14553: IFFALSE 14637
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
14555: LD_ADDR_VAR 0 6
14559: PUSH
14560: LD_VAR 0 7
14564: PUSH
14565: LD_VAR 0 5
14569: PUSH
14570: LD_INT 1
14572: MINUS
14573: ARRAY
14574: PPUSH
14575: LD_VAR 0 2
14579: PUSH
14580: LD_VAR 0 5
14584: PUSH
14585: LD_INT 1
14587: MINUS
14588: ARRAY
14589: PPUSH
14590: LD_VAR 0 7
14594: PUSH
14595: LD_VAR 0 5
14599: ARRAY
14600: PPUSH
14601: CALL_OW 1
14605: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
14606: LD_ADDR_VAR 0 7
14610: PUSH
14611: LD_VAR 0 7
14615: PPUSH
14616: LD_VAR 0 5
14620: PUSH
14621: LD_INT 1
14623: MINUS
14624: PPUSH
14625: LD_VAR 0 6
14629: PPUSH
14630: CALL_OW 1
14634: ST_TO_ADDR
// end ;
14635: GO 14552
14637: POP
14638: POP
// result := s_arr [ 1 ] ;
14639: LD_ADDR_VAR 0 4
14643: PUSH
14644: LD_VAR 0 7
14648: PUSH
14649: LD_INT 1
14651: ARRAY
14652: ST_TO_ADDR
// end ; end ;
14653: LD_VAR 0 4
14657: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
14658: LD_INT 0
14660: PPUSH
14661: PPUSH
// if not list then
14662: LD_VAR 0 1
14666: NOT
14667: IFFALSE 14671
// exit ;
14669: GO 14762
// i := list [ pos1 ] ;
14671: LD_ADDR_VAR 0 5
14675: PUSH
14676: LD_VAR 0 1
14680: PUSH
14681: LD_VAR 0 2
14685: ARRAY
14686: ST_TO_ADDR
// if not i then
14687: LD_VAR 0 5
14691: NOT
14692: IFFALSE 14696
// exit ;
14694: GO 14762
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
14696: LD_ADDR_VAR 0 1
14700: PUSH
14701: LD_VAR 0 1
14705: PPUSH
14706: LD_VAR 0 2
14710: PPUSH
14711: LD_VAR 0 1
14715: PUSH
14716: LD_VAR 0 3
14720: ARRAY
14721: PPUSH
14722: CALL_OW 1
14726: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
14727: LD_ADDR_VAR 0 1
14731: PUSH
14732: LD_VAR 0 1
14736: PPUSH
14737: LD_VAR 0 3
14741: PPUSH
14742: LD_VAR 0 5
14746: PPUSH
14747: CALL_OW 1
14751: ST_TO_ADDR
// result := list ;
14752: LD_ADDR_VAR 0 4
14756: PUSH
14757: LD_VAR 0 1
14761: ST_TO_ADDR
// end ;
14762: LD_VAR 0 4
14766: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
14767: LD_INT 0
14769: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
14770: LD_ADDR_VAR 0 5
14774: PUSH
14775: LD_VAR 0 1
14779: PPUSH
14780: CALL_OW 250
14784: PPUSH
14785: LD_VAR 0 1
14789: PPUSH
14790: CALL_OW 251
14794: PPUSH
14795: LD_VAR 0 2
14799: PPUSH
14800: LD_VAR 0 3
14804: PPUSH
14805: LD_VAR 0 4
14809: PPUSH
14810: CALL 14820 0 5
14814: ST_TO_ADDR
// end ;
14815: LD_VAR 0 5
14819: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
14820: LD_INT 0
14822: PPUSH
14823: PPUSH
14824: PPUSH
14825: PPUSH
// if not list then
14826: LD_VAR 0 3
14830: NOT
14831: IFFALSE 14835
// exit ;
14833: GO 15223
// result := [ ] ;
14835: LD_ADDR_VAR 0 6
14839: PUSH
14840: EMPTY
14841: ST_TO_ADDR
// for i in list do
14842: LD_ADDR_VAR 0 7
14846: PUSH
14847: LD_VAR 0 3
14851: PUSH
14852: FOR_IN
14853: IFFALSE 15055
// begin tmp := GetDistUnitXY ( i , x , y ) ;
14855: LD_ADDR_VAR 0 9
14859: PUSH
14860: LD_VAR 0 7
14864: PPUSH
14865: LD_VAR 0 1
14869: PPUSH
14870: LD_VAR 0 2
14874: PPUSH
14875: CALL_OW 297
14879: ST_TO_ADDR
// if not result then
14880: LD_VAR 0 6
14884: NOT
14885: IFFALSE 14911
// result := [ [ i , tmp ] ] else
14887: LD_ADDR_VAR 0 6
14891: PUSH
14892: LD_VAR 0 7
14896: PUSH
14897: LD_VAR 0 9
14901: PUSH
14902: EMPTY
14903: LIST
14904: LIST
14905: PUSH
14906: EMPTY
14907: LIST
14908: ST_TO_ADDR
14909: GO 15053
// begin if result [ result ] [ 2 ] < tmp then
14911: LD_VAR 0 6
14915: PUSH
14916: LD_VAR 0 6
14920: ARRAY
14921: PUSH
14922: LD_INT 2
14924: ARRAY
14925: PUSH
14926: LD_VAR 0 9
14930: LESS
14931: IFFALSE 14973
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
14933: LD_ADDR_VAR 0 6
14937: PUSH
14938: LD_VAR 0 6
14942: PPUSH
14943: LD_VAR 0 6
14947: PUSH
14948: LD_INT 1
14950: PLUS
14951: PPUSH
14952: LD_VAR 0 7
14956: PUSH
14957: LD_VAR 0 9
14961: PUSH
14962: EMPTY
14963: LIST
14964: LIST
14965: PPUSH
14966: CALL_OW 2
14970: ST_TO_ADDR
14971: GO 15053
// for j = 1 to result do
14973: LD_ADDR_VAR 0 8
14977: PUSH
14978: DOUBLE
14979: LD_INT 1
14981: DEC
14982: ST_TO_ADDR
14983: LD_VAR 0 6
14987: PUSH
14988: FOR_TO
14989: IFFALSE 15051
// begin if tmp < result [ j ] [ 2 ] then
14991: LD_VAR 0 9
14995: PUSH
14996: LD_VAR 0 6
15000: PUSH
15001: LD_VAR 0 8
15005: ARRAY
15006: PUSH
15007: LD_INT 2
15009: ARRAY
15010: LESS
15011: IFFALSE 15049
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15013: LD_ADDR_VAR 0 6
15017: PUSH
15018: LD_VAR 0 6
15022: PPUSH
15023: LD_VAR 0 8
15027: PPUSH
15028: LD_VAR 0 7
15032: PUSH
15033: LD_VAR 0 9
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PPUSH
15042: CALL_OW 2
15046: ST_TO_ADDR
// break ;
15047: GO 15051
// end ; end ;
15049: GO 14988
15051: POP
15052: POP
// end ; end ;
15053: GO 14852
15055: POP
15056: POP
// if result and not asc then
15057: LD_VAR 0 6
15061: PUSH
15062: LD_VAR 0 4
15066: NOT
15067: AND
15068: IFFALSE 15143
// begin tmp := result ;
15070: LD_ADDR_VAR 0 9
15074: PUSH
15075: LD_VAR 0 6
15079: ST_TO_ADDR
// for i = tmp downto 1 do
15080: LD_ADDR_VAR 0 7
15084: PUSH
15085: DOUBLE
15086: LD_VAR 0 9
15090: INC
15091: ST_TO_ADDR
15092: LD_INT 1
15094: PUSH
15095: FOR_DOWNTO
15096: IFFALSE 15141
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15098: LD_ADDR_VAR 0 6
15102: PUSH
15103: LD_VAR 0 6
15107: PPUSH
15108: LD_VAR 0 9
15112: PUSH
15113: LD_VAR 0 7
15117: MINUS
15118: PUSH
15119: LD_INT 1
15121: PLUS
15122: PPUSH
15123: LD_VAR 0 9
15127: PUSH
15128: LD_VAR 0 7
15132: ARRAY
15133: PPUSH
15134: CALL_OW 1
15138: ST_TO_ADDR
15139: GO 15095
15141: POP
15142: POP
// end ; tmp := [ ] ;
15143: LD_ADDR_VAR 0 9
15147: PUSH
15148: EMPTY
15149: ST_TO_ADDR
// if mode then
15150: LD_VAR 0 5
15154: IFFALSE 15223
// begin for i = 1 to result do
15156: LD_ADDR_VAR 0 7
15160: PUSH
15161: DOUBLE
15162: LD_INT 1
15164: DEC
15165: ST_TO_ADDR
15166: LD_VAR 0 6
15170: PUSH
15171: FOR_TO
15172: IFFALSE 15211
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15174: LD_ADDR_VAR 0 9
15178: PUSH
15179: LD_VAR 0 9
15183: PPUSH
15184: LD_VAR 0 7
15188: PPUSH
15189: LD_VAR 0 6
15193: PUSH
15194: LD_VAR 0 7
15198: ARRAY
15199: PUSH
15200: LD_INT 1
15202: ARRAY
15203: PPUSH
15204: CALL_OW 1
15208: ST_TO_ADDR
15209: GO 15171
15211: POP
15212: POP
// result := tmp ;
15213: LD_ADDR_VAR 0 6
15217: PUSH
15218: LD_VAR 0 9
15222: ST_TO_ADDR
// end ; end ;
15223: LD_VAR 0 6
15227: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15228: LD_INT 0
15230: PPUSH
15231: PPUSH
15232: PPUSH
15233: PPUSH
15234: PPUSH
15235: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15236: LD_ADDR_VAR 0 5
15240: PUSH
15241: LD_INT 0
15243: PUSH
15244: LD_INT 0
15246: PUSH
15247: LD_INT 0
15249: PUSH
15250: EMPTY
15251: PUSH
15252: EMPTY
15253: LIST
15254: LIST
15255: LIST
15256: LIST
15257: ST_TO_ADDR
// if not x or not y then
15258: LD_VAR 0 2
15262: NOT
15263: PUSH
15264: LD_VAR 0 3
15268: NOT
15269: OR
15270: IFFALSE 15274
// exit ;
15272: GO 16920
// if not range then
15274: LD_VAR 0 4
15278: NOT
15279: IFFALSE 15289
// range := 10 ;
15281: LD_ADDR_VAR 0 4
15285: PUSH
15286: LD_INT 10
15288: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15289: LD_ADDR_VAR 0 8
15293: PUSH
15294: LD_INT 81
15296: PUSH
15297: LD_VAR 0 1
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PUSH
15306: LD_INT 92
15308: PUSH
15309: LD_VAR 0 2
15313: PUSH
15314: LD_VAR 0 3
15318: PUSH
15319: LD_VAR 0 4
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: LIST
15328: LIST
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: LD_INT 21
15335: PUSH
15336: LD_INT 3
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: EMPTY
15348: LIST
15349: LIST
15350: LIST
15351: PPUSH
15352: CALL_OW 69
15356: ST_TO_ADDR
// if not tmp then
15357: LD_VAR 0 8
15361: NOT
15362: IFFALSE 15366
// exit ;
15364: GO 16920
// for i in tmp do
15366: LD_ADDR_VAR 0 6
15370: PUSH
15371: LD_VAR 0 8
15375: PUSH
15376: FOR_IN
15377: IFFALSE 16895
// begin points := [ 0 , 0 , 0 ] ;
15379: LD_ADDR_VAR 0 9
15383: PUSH
15384: LD_INT 0
15386: PUSH
15387: LD_INT 0
15389: PUSH
15390: LD_INT 0
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: LIST
15397: ST_TO_ADDR
// bpoints := 1 ;
15398: LD_ADDR_VAR 0 10
15402: PUSH
15403: LD_INT 1
15405: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15406: LD_VAR 0 6
15410: PPUSH
15411: CALL_OW 247
15415: PUSH
15416: LD_INT 1
15418: DOUBLE
15419: EQUAL
15420: IFTRUE 15424
15422: GO 16002
15424: POP
// begin if GetClass ( i ) = 1 then
15425: LD_VAR 0 6
15429: PPUSH
15430: CALL_OW 257
15434: PUSH
15435: LD_INT 1
15437: EQUAL
15438: IFFALSE 15459
// points := [ 10 , 5 , 3 ] ;
15440: LD_ADDR_VAR 0 9
15444: PUSH
15445: LD_INT 10
15447: PUSH
15448: LD_INT 5
15450: PUSH
15451: LD_INT 3
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: LIST
15458: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15459: LD_VAR 0 6
15463: PPUSH
15464: CALL_OW 257
15468: PUSH
15469: LD_INT 2
15471: PUSH
15472: LD_INT 3
15474: PUSH
15475: LD_INT 4
15477: PUSH
15478: EMPTY
15479: LIST
15480: LIST
15481: LIST
15482: IN
15483: IFFALSE 15504
// points := [ 3 , 2 , 1 ] ;
15485: LD_ADDR_VAR 0 9
15489: PUSH
15490: LD_INT 3
15492: PUSH
15493: LD_INT 2
15495: PUSH
15496: LD_INT 1
15498: PUSH
15499: EMPTY
15500: LIST
15501: LIST
15502: LIST
15503: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15504: LD_VAR 0 6
15508: PPUSH
15509: CALL_OW 257
15513: PUSH
15514: LD_INT 5
15516: EQUAL
15517: IFFALSE 15538
// points := [ 130 , 5 , 2 ] ;
15519: LD_ADDR_VAR 0 9
15523: PUSH
15524: LD_INT 130
15526: PUSH
15527: LD_INT 5
15529: PUSH
15530: LD_INT 2
15532: PUSH
15533: EMPTY
15534: LIST
15535: LIST
15536: LIST
15537: ST_TO_ADDR
// if GetClass ( i ) = 8 then
15538: LD_VAR 0 6
15542: PPUSH
15543: CALL_OW 257
15547: PUSH
15548: LD_INT 8
15550: EQUAL
15551: IFFALSE 15572
// points := [ 35 , 35 , 30 ] ;
15553: LD_ADDR_VAR 0 9
15557: PUSH
15558: LD_INT 35
15560: PUSH
15561: LD_INT 35
15563: PUSH
15564: LD_INT 30
15566: PUSH
15567: EMPTY
15568: LIST
15569: LIST
15570: LIST
15571: ST_TO_ADDR
// if GetClass ( i ) = 9 then
15572: LD_VAR 0 6
15576: PPUSH
15577: CALL_OW 257
15581: PUSH
15582: LD_INT 9
15584: EQUAL
15585: IFFALSE 15606
// points := [ 20 , 55 , 40 ] ;
15587: LD_ADDR_VAR 0 9
15591: PUSH
15592: LD_INT 20
15594: PUSH
15595: LD_INT 55
15597: PUSH
15598: LD_INT 40
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: LIST
15605: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
15606: LD_VAR 0 6
15610: PPUSH
15611: CALL_OW 257
15615: PUSH
15616: LD_INT 12
15618: PUSH
15619: LD_INT 16
15621: PUSH
15622: EMPTY
15623: LIST
15624: LIST
15625: IN
15626: IFFALSE 15647
// points := [ 5 , 3 , 2 ] ;
15628: LD_ADDR_VAR 0 9
15632: PUSH
15633: LD_INT 5
15635: PUSH
15636: LD_INT 3
15638: PUSH
15639: LD_INT 2
15641: PUSH
15642: EMPTY
15643: LIST
15644: LIST
15645: LIST
15646: ST_TO_ADDR
// if GetClass ( i ) = 17 then
15647: LD_VAR 0 6
15651: PPUSH
15652: CALL_OW 257
15656: PUSH
15657: LD_INT 17
15659: EQUAL
15660: IFFALSE 15681
// points := [ 100 , 50 , 75 ] ;
15662: LD_ADDR_VAR 0 9
15666: PUSH
15667: LD_INT 100
15669: PUSH
15670: LD_INT 50
15672: PUSH
15673: LD_INT 75
15675: PUSH
15676: EMPTY
15677: LIST
15678: LIST
15679: LIST
15680: ST_TO_ADDR
// if GetClass ( i ) = 15 then
15681: LD_VAR 0 6
15685: PPUSH
15686: CALL_OW 257
15690: PUSH
15691: LD_INT 15
15693: EQUAL
15694: IFFALSE 15715
// points := [ 10 , 5 , 3 ] ;
15696: LD_ADDR_VAR 0 9
15700: PUSH
15701: LD_INT 10
15703: PUSH
15704: LD_INT 5
15706: PUSH
15707: LD_INT 3
15709: PUSH
15710: EMPTY
15711: LIST
15712: LIST
15713: LIST
15714: ST_TO_ADDR
// if GetClass ( i ) = 14 then
15715: LD_VAR 0 6
15719: PPUSH
15720: CALL_OW 257
15724: PUSH
15725: LD_INT 14
15727: EQUAL
15728: IFFALSE 15749
// points := [ 10 , 0 , 0 ] ;
15730: LD_ADDR_VAR 0 9
15734: PUSH
15735: LD_INT 10
15737: PUSH
15738: LD_INT 0
15740: PUSH
15741: LD_INT 0
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: LIST
15748: ST_TO_ADDR
// if GetClass ( i ) = 11 then
15749: LD_VAR 0 6
15753: PPUSH
15754: CALL_OW 257
15758: PUSH
15759: LD_INT 11
15761: EQUAL
15762: IFFALSE 15783
// points := [ 30 , 10 , 5 ] ;
15764: LD_ADDR_VAR 0 9
15768: PUSH
15769: LD_INT 30
15771: PUSH
15772: LD_INT 10
15774: PUSH
15775: LD_INT 5
15777: PUSH
15778: EMPTY
15779: LIST
15780: LIST
15781: LIST
15782: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
15783: LD_VAR 0 1
15787: PPUSH
15788: LD_INT 5
15790: PPUSH
15791: CALL_OW 321
15795: PUSH
15796: LD_INT 2
15798: EQUAL
15799: IFFALSE 15816
// bpoints := bpoints * 1.8 ;
15801: LD_ADDR_VAR 0 10
15805: PUSH
15806: LD_VAR 0 10
15810: PUSH
15811: LD_REAL  1.80000000000000E+0000
15814: MUL
15815: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
15816: LD_VAR 0 6
15820: PPUSH
15821: CALL_OW 257
15825: PUSH
15826: LD_INT 1
15828: PUSH
15829: LD_INT 2
15831: PUSH
15832: LD_INT 3
15834: PUSH
15835: LD_INT 4
15837: PUSH
15838: EMPTY
15839: LIST
15840: LIST
15841: LIST
15842: LIST
15843: IN
15844: PUSH
15845: LD_VAR 0 1
15849: PPUSH
15850: LD_INT 51
15852: PPUSH
15853: CALL_OW 321
15857: PUSH
15858: LD_INT 2
15860: EQUAL
15861: AND
15862: IFFALSE 15879
// bpoints := bpoints * 1.2 ;
15864: LD_ADDR_VAR 0 10
15868: PUSH
15869: LD_VAR 0 10
15873: PUSH
15874: LD_REAL  1.20000000000000E+0000
15877: MUL
15878: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
15879: LD_VAR 0 6
15883: PPUSH
15884: CALL_OW 257
15888: PUSH
15889: LD_INT 5
15891: PUSH
15892: LD_INT 7
15894: PUSH
15895: LD_INT 9
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: LIST
15902: IN
15903: PUSH
15904: LD_VAR 0 1
15908: PPUSH
15909: LD_INT 52
15911: PPUSH
15912: CALL_OW 321
15916: PUSH
15917: LD_INT 2
15919: EQUAL
15920: AND
15921: IFFALSE 15938
// bpoints := bpoints * 1.5 ;
15923: LD_ADDR_VAR 0 10
15927: PUSH
15928: LD_VAR 0 10
15932: PUSH
15933: LD_REAL  1.50000000000000E+0000
15936: MUL
15937: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
15938: LD_VAR 0 1
15942: PPUSH
15943: LD_INT 66
15945: PPUSH
15946: CALL_OW 321
15950: PUSH
15951: LD_INT 2
15953: EQUAL
15954: IFFALSE 15971
// bpoints := bpoints * 1.1 ;
15956: LD_ADDR_VAR 0 10
15960: PUSH
15961: LD_VAR 0 10
15965: PUSH
15966: LD_REAL  1.10000000000000E+0000
15969: MUL
15970: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
15971: LD_ADDR_VAR 0 10
15975: PUSH
15976: LD_VAR 0 10
15980: PUSH
15981: LD_VAR 0 6
15985: PPUSH
15986: LD_INT 1
15988: PPUSH
15989: CALL_OW 259
15993: PUSH
15994: LD_REAL  1.15000000000000E+0000
15997: MUL
15998: MUL
15999: ST_TO_ADDR
// end ; unit_vehicle :
16000: GO 16824
16002: LD_INT 2
16004: DOUBLE
16005: EQUAL
16006: IFTRUE 16010
16008: GO 16812
16010: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16011: LD_VAR 0 6
16015: PPUSH
16016: CALL_OW 264
16020: PUSH
16021: LD_INT 2
16023: PUSH
16024: LD_INT 42
16026: PUSH
16027: LD_INT 24
16029: PUSH
16030: EMPTY
16031: LIST
16032: LIST
16033: LIST
16034: IN
16035: IFFALSE 16056
// points := [ 25 , 5 , 3 ] ;
16037: LD_ADDR_VAR 0 9
16041: PUSH
16042: LD_INT 25
16044: PUSH
16045: LD_INT 5
16047: PUSH
16048: LD_INT 3
16050: PUSH
16051: EMPTY
16052: LIST
16053: LIST
16054: LIST
16055: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16056: LD_VAR 0 6
16060: PPUSH
16061: CALL_OW 264
16065: PUSH
16066: LD_INT 4
16068: PUSH
16069: LD_INT 43
16071: PUSH
16072: LD_INT 25
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: LIST
16079: IN
16080: IFFALSE 16101
// points := [ 40 , 15 , 5 ] ;
16082: LD_ADDR_VAR 0 9
16086: PUSH
16087: LD_INT 40
16089: PUSH
16090: LD_INT 15
16092: PUSH
16093: LD_INT 5
16095: PUSH
16096: EMPTY
16097: LIST
16098: LIST
16099: LIST
16100: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16101: LD_VAR 0 6
16105: PPUSH
16106: CALL_OW 264
16110: PUSH
16111: LD_INT 3
16113: PUSH
16114: LD_INT 23
16116: PUSH
16117: EMPTY
16118: LIST
16119: LIST
16120: IN
16121: IFFALSE 16142
// points := [ 7 , 25 , 8 ] ;
16123: LD_ADDR_VAR 0 9
16127: PUSH
16128: LD_INT 7
16130: PUSH
16131: LD_INT 25
16133: PUSH
16134: LD_INT 8
16136: PUSH
16137: EMPTY
16138: LIST
16139: LIST
16140: LIST
16141: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16142: LD_VAR 0 6
16146: PPUSH
16147: CALL_OW 264
16151: PUSH
16152: LD_INT 5
16154: PUSH
16155: LD_INT 27
16157: PUSH
16158: LD_INT 44
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: LIST
16165: IN
16166: IFFALSE 16187
// points := [ 14 , 50 , 16 ] ;
16168: LD_ADDR_VAR 0 9
16172: PUSH
16173: LD_INT 14
16175: PUSH
16176: LD_INT 50
16178: PUSH
16179: LD_INT 16
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: LIST
16186: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16187: LD_VAR 0 6
16191: PPUSH
16192: CALL_OW 264
16196: PUSH
16197: LD_INT 6
16199: PUSH
16200: LD_INT 46
16202: PUSH
16203: EMPTY
16204: LIST
16205: LIST
16206: IN
16207: IFFALSE 16228
// points := [ 32 , 120 , 70 ] ;
16209: LD_ADDR_VAR 0 9
16213: PUSH
16214: LD_INT 32
16216: PUSH
16217: LD_INT 120
16219: PUSH
16220: LD_INT 70
16222: PUSH
16223: EMPTY
16224: LIST
16225: LIST
16226: LIST
16227: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
16228: LD_VAR 0 6
16232: PPUSH
16233: CALL_OW 264
16237: PUSH
16238: LD_INT 7
16240: PUSH
16241: LD_INT 28
16243: PUSH
16244: LD_INT 45
16246: PUSH
16247: EMPTY
16248: LIST
16249: LIST
16250: LIST
16251: IN
16252: IFFALSE 16273
// points := [ 35 , 20 , 45 ] ;
16254: LD_ADDR_VAR 0 9
16258: PUSH
16259: LD_INT 35
16261: PUSH
16262: LD_INT 20
16264: PUSH
16265: LD_INT 45
16267: PUSH
16268: EMPTY
16269: LIST
16270: LIST
16271: LIST
16272: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16273: LD_VAR 0 6
16277: PPUSH
16278: CALL_OW 264
16282: PUSH
16283: LD_INT 47
16285: PUSH
16286: EMPTY
16287: LIST
16288: IN
16289: IFFALSE 16310
// points := [ 67 , 45 , 75 ] ;
16291: LD_ADDR_VAR 0 9
16295: PUSH
16296: LD_INT 67
16298: PUSH
16299: LD_INT 45
16301: PUSH
16302: LD_INT 75
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: LIST
16309: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16310: LD_VAR 0 6
16314: PPUSH
16315: CALL_OW 264
16319: PUSH
16320: LD_INT 26
16322: PUSH
16323: EMPTY
16324: LIST
16325: IN
16326: IFFALSE 16347
// points := [ 120 , 30 , 80 ] ;
16328: LD_ADDR_VAR 0 9
16332: PUSH
16333: LD_INT 120
16335: PUSH
16336: LD_INT 30
16338: PUSH
16339: LD_INT 80
16341: PUSH
16342: EMPTY
16343: LIST
16344: LIST
16345: LIST
16346: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16347: LD_VAR 0 6
16351: PPUSH
16352: CALL_OW 264
16356: PUSH
16357: LD_INT 22
16359: PUSH
16360: EMPTY
16361: LIST
16362: IN
16363: IFFALSE 16384
// points := [ 40 , 1 , 1 ] ;
16365: LD_ADDR_VAR 0 9
16369: PUSH
16370: LD_INT 40
16372: PUSH
16373: LD_INT 1
16375: PUSH
16376: LD_INT 1
16378: PUSH
16379: EMPTY
16380: LIST
16381: LIST
16382: LIST
16383: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16384: LD_VAR 0 6
16388: PPUSH
16389: CALL_OW 264
16393: PUSH
16394: LD_INT 29
16396: PUSH
16397: EMPTY
16398: LIST
16399: IN
16400: IFFALSE 16421
// points := [ 70 , 200 , 400 ] ;
16402: LD_ADDR_VAR 0 9
16406: PUSH
16407: LD_INT 70
16409: PUSH
16410: LD_INT 200
16412: PUSH
16413: LD_INT 400
16415: PUSH
16416: EMPTY
16417: LIST
16418: LIST
16419: LIST
16420: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16421: LD_VAR 0 6
16425: PPUSH
16426: CALL_OW 264
16430: PUSH
16431: LD_INT 14
16433: PUSH
16434: LD_INT 53
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: IN
16441: IFFALSE 16462
// points := [ 40 , 10 , 20 ] ;
16443: LD_ADDR_VAR 0 9
16447: PUSH
16448: LD_INT 40
16450: PUSH
16451: LD_INT 10
16453: PUSH
16454: LD_INT 20
16456: PUSH
16457: EMPTY
16458: LIST
16459: LIST
16460: LIST
16461: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16462: LD_VAR 0 6
16466: PPUSH
16467: CALL_OW 264
16471: PUSH
16472: LD_INT 9
16474: PUSH
16475: EMPTY
16476: LIST
16477: IN
16478: IFFALSE 16499
// points := [ 5 , 70 , 20 ] ;
16480: LD_ADDR_VAR 0 9
16484: PUSH
16485: LD_INT 5
16487: PUSH
16488: LD_INT 70
16490: PUSH
16491: LD_INT 20
16493: PUSH
16494: EMPTY
16495: LIST
16496: LIST
16497: LIST
16498: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16499: LD_VAR 0 6
16503: PPUSH
16504: CALL_OW 264
16508: PUSH
16509: LD_INT 10
16511: PUSH
16512: EMPTY
16513: LIST
16514: IN
16515: IFFALSE 16536
// points := [ 35 , 110 , 70 ] ;
16517: LD_ADDR_VAR 0 9
16521: PUSH
16522: LD_INT 35
16524: PUSH
16525: LD_INT 110
16527: PUSH
16528: LD_INT 70
16530: PUSH
16531: EMPTY
16532: LIST
16533: LIST
16534: LIST
16535: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
16536: LD_VAR 0 6
16540: PPUSH
16541: CALL_OW 265
16545: PUSH
16546: LD_INT 25
16548: EQUAL
16549: IFFALSE 16570
// points := [ 80 , 65 , 100 ] ;
16551: LD_ADDR_VAR 0 9
16555: PUSH
16556: LD_INT 80
16558: PUSH
16559: LD_INT 65
16561: PUSH
16562: LD_INT 100
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: LIST
16569: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
16570: LD_VAR 0 6
16574: PPUSH
16575: CALL_OW 263
16579: PUSH
16580: LD_INT 1
16582: EQUAL
16583: IFFALSE 16618
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
16585: LD_ADDR_VAR 0 10
16589: PUSH
16590: LD_VAR 0 10
16594: PUSH
16595: LD_VAR 0 6
16599: PPUSH
16600: CALL_OW 311
16604: PPUSH
16605: LD_INT 3
16607: PPUSH
16608: CALL_OW 259
16612: PUSH
16613: LD_INT 4
16615: MUL
16616: MUL
16617: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
16618: LD_VAR 0 6
16622: PPUSH
16623: CALL_OW 263
16627: PUSH
16628: LD_INT 2
16630: EQUAL
16631: IFFALSE 16682
// begin j := IsControledBy ( i ) ;
16633: LD_ADDR_VAR 0 7
16637: PUSH
16638: LD_VAR 0 6
16642: PPUSH
16643: CALL_OW 312
16647: ST_TO_ADDR
// if j then
16648: LD_VAR 0 7
16652: IFFALSE 16682
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
16654: LD_ADDR_VAR 0 10
16658: PUSH
16659: LD_VAR 0 10
16663: PUSH
16664: LD_VAR 0 7
16668: PPUSH
16669: LD_INT 3
16671: PPUSH
16672: CALL_OW 259
16676: PUSH
16677: LD_INT 3
16679: MUL
16680: MUL
16681: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
16682: LD_VAR 0 6
16686: PPUSH
16687: CALL_OW 264
16691: PUSH
16692: LD_INT 5
16694: PUSH
16695: LD_INT 6
16697: PUSH
16698: LD_INT 46
16700: PUSH
16701: LD_INT 44
16703: PUSH
16704: LD_INT 47
16706: PUSH
16707: LD_INT 45
16709: PUSH
16710: LD_INT 28
16712: PUSH
16713: LD_INT 7
16715: PUSH
16716: LD_INT 27
16718: PUSH
16719: LD_INT 29
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: LIST
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: LIST
16731: LIST
16732: LIST
16733: IN
16734: PUSH
16735: LD_VAR 0 1
16739: PPUSH
16740: LD_INT 52
16742: PPUSH
16743: CALL_OW 321
16747: PUSH
16748: LD_INT 2
16750: EQUAL
16751: AND
16752: IFFALSE 16769
// bpoints := bpoints * 1.2 ;
16754: LD_ADDR_VAR 0 10
16758: PUSH
16759: LD_VAR 0 10
16763: PUSH
16764: LD_REAL  1.20000000000000E+0000
16767: MUL
16768: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
16769: LD_VAR 0 6
16773: PPUSH
16774: CALL_OW 264
16778: PUSH
16779: LD_INT 6
16781: PUSH
16782: LD_INT 46
16784: PUSH
16785: LD_INT 47
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: LIST
16792: IN
16793: IFFALSE 16810
// bpoints := bpoints * 1.2 ;
16795: LD_ADDR_VAR 0 10
16799: PUSH
16800: LD_VAR 0 10
16804: PUSH
16805: LD_REAL  1.20000000000000E+0000
16808: MUL
16809: ST_TO_ADDR
// end ; unit_building :
16810: GO 16824
16812: LD_INT 3
16814: DOUBLE
16815: EQUAL
16816: IFTRUE 16820
16818: GO 16823
16820: POP
// ; end ;
16821: GO 16824
16823: POP
// for j = 1 to 3 do
16824: LD_ADDR_VAR 0 7
16828: PUSH
16829: DOUBLE
16830: LD_INT 1
16832: DEC
16833: ST_TO_ADDR
16834: LD_INT 3
16836: PUSH
16837: FOR_TO
16838: IFFALSE 16891
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
16840: LD_ADDR_VAR 0 5
16844: PUSH
16845: LD_VAR 0 5
16849: PPUSH
16850: LD_VAR 0 7
16854: PPUSH
16855: LD_VAR 0 5
16859: PUSH
16860: LD_VAR 0 7
16864: ARRAY
16865: PUSH
16866: LD_VAR 0 9
16870: PUSH
16871: LD_VAR 0 7
16875: ARRAY
16876: PUSH
16877: LD_VAR 0 10
16881: MUL
16882: PLUS
16883: PPUSH
16884: CALL_OW 1
16888: ST_TO_ADDR
16889: GO 16837
16891: POP
16892: POP
// end ;
16893: GO 15376
16895: POP
16896: POP
// result := Replace ( result , 4 , tmp ) ;
16897: LD_ADDR_VAR 0 5
16901: PUSH
16902: LD_VAR 0 5
16906: PPUSH
16907: LD_INT 4
16909: PPUSH
16910: LD_VAR 0 8
16914: PPUSH
16915: CALL_OW 1
16919: ST_TO_ADDR
// end ;
16920: LD_VAR 0 5
16924: RET
// export function DangerAtRange ( unit , range ) ; begin
16925: LD_INT 0
16927: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
16928: LD_ADDR_VAR 0 3
16932: PUSH
16933: LD_VAR 0 1
16937: PPUSH
16938: CALL_OW 255
16942: PPUSH
16943: LD_VAR 0 1
16947: PPUSH
16948: CALL_OW 250
16952: PPUSH
16953: LD_VAR 0 1
16957: PPUSH
16958: CALL_OW 251
16962: PPUSH
16963: LD_VAR 0 2
16967: PPUSH
16968: CALL 15228 0 4
16972: ST_TO_ADDR
// end ;
16973: LD_VAR 0 3
16977: RET
// export function DangerInArea ( side , area ) ; begin
16978: LD_INT 0
16980: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
16981: LD_ADDR_VAR 0 3
16985: PUSH
16986: LD_VAR 0 2
16990: PPUSH
16991: LD_INT 81
16993: PUSH
16994: LD_VAR 0 1
16998: PUSH
16999: EMPTY
17000: LIST
17001: LIST
17002: PPUSH
17003: CALL_OW 70
17007: ST_TO_ADDR
// end ;
17008: LD_VAR 0 3
17012: RET
// export function IsExtension ( b ) ; begin
17013: LD_INT 0
17015: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17016: LD_ADDR_VAR 0 2
17020: PUSH
17021: LD_VAR 0 1
17025: PUSH
17026: LD_INT 23
17028: PUSH
17029: LD_INT 20
17031: PUSH
17032: LD_INT 22
17034: PUSH
17035: LD_INT 17
17037: PUSH
17038: LD_INT 24
17040: PUSH
17041: LD_INT 21
17043: PUSH
17044: LD_INT 19
17046: PUSH
17047: LD_INT 16
17049: PUSH
17050: LD_INT 25
17052: PUSH
17053: LD_INT 18
17055: PUSH
17056: EMPTY
17057: LIST
17058: LIST
17059: LIST
17060: LIST
17061: LIST
17062: LIST
17063: LIST
17064: LIST
17065: LIST
17066: LIST
17067: IN
17068: ST_TO_ADDR
// end ;
17069: LD_VAR 0 2
17073: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
17074: LD_INT 0
17076: PPUSH
17077: PPUSH
17078: PPUSH
// result := [ ] ;
17079: LD_ADDR_VAR 0 3
17083: PUSH
17084: EMPTY
17085: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17086: LD_ADDR_VAR 0 4
17090: PUSH
17091: LD_VAR 0 2
17095: PPUSH
17096: LD_INT 21
17098: PUSH
17099: LD_INT 3
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PPUSH
17106: CALL_OW 70
17110: ST_TO_ADDR
// if not tmp then
17111: LD_VAR 0 4
17115: NOT
17116: IFFALSE 17120
// exit ;
17118: GO 17178
// for i in tmp do
17120: LD_ADDR_VAR 0 5
17124: PUSH
17125: LD_VAR 0 4
17129: PUSH
17130: FOR_IN
17131: IFFALSE 17166
// if GetBase ( i ) <> base then
17133: LD_VAR 0 5
17137: PPUSH
17138: CALL_OW 274
17142: PUSH
17143: LD_VAR 0 1
17147: NONEQUAL
17148: IFFALSE 17164
// ComLinkToBase ( base , i ) ;
17150: LD_VAR 0 1
17154: PPUSH
17155: LD_VAR 0 5
17159: PPUSH
17160: CALL_OW 169
17164: GO 17130
17166: POP
17167: POP
// result := tmp ;
17168: LD_ADDR_VAR 0 3
17172: PUSH
17173: LD_VAR 0 4
17177: ST_TO_ADDR
// end ;
17178: LD_VAR 0 3
17182: RET
// export function ComComplete ( unit , b ) ; var i ; begin
17183: LD_INT 0
17185: PPUSH
17186: PPUSH
// if BuildingStatus ( b ) = bs_build then
17187: LD_VAR 0 2
17191: PPUSH
17192: CALL_OW 461
17196: PUSH
17197: LD_INT 1
17199: EQUAL
17200: IFFALSE 17260
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17202: LD_VAR 0 1
17206: PPUSH
17207: LD_STRING h
17209: PUSH
17210: LD_VAR 0 2
17214: PPUSH
17215: CALL_OW 250
17219: PUSH
17220: LD_VAR 0 2
17224: PPUSH
17225: CALL_OW 251
17229: PUSH
17230: LD_VAR 0 2
17234: PUSH
17235: LD_INT 0
17237: PUSH
17238: LD_INT 0
17240: PUSH
17241: LD_INT 0
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: LIST
17248: LIST
17249: LIST
17250: LIST
17251: LIST
17252: PUSH
17253: EMPTY
17254: LIST
17255: PPUSH
17256: CALL_OW 446
// end ;
17260: LD_VAR 0 3
17264: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17265: LD_INT 0
17267: PPUSH
17268: PPUSH
17269: PPUSH
17270: PPUSH
17271: PPUSH
17272: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17273: LD_VAR 0 1
17277: NOT
17278: PUSH
17279: LD_VAR 0 1
17283: PPUSH
17284: CALL_OW 263
17288: PUSH
17289: LD_INT 2
17291: EQUAL
17292: NOT
17293: OR
17294: IFFALSE 17298
// exit ;
17296: GO 17614
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17298: LD_ADDR_VAR 0 6
17302: PUSH
17303: LD_INT 22
17305: PUSH
17306: LD_VAR 0 1
17310: PPUSH
17311: CALL_OW 255
17315: PUSH
17316: EMPTY
17317: LIST
17318: LIST
17319: PUSH
17320: LD_INT 2
17322: PUSH
17323: LD_INT 30
17325: PUSH
17326: LD_INT 36
17328: PUSH
17329: EMPTY
17330: LIST
17331: LIST
17332: PUSH
17333: LD_INT 34
17335: PUSH
17336: LD_INT 31
17338: PUSH
17339: EMPTY
17340: LIST
17341: LIST
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: LIST
17347: PUSH
17348: EMPTY
17349: LIST
17350: LIST
17351: PPUSH
17352: CALL_OW 69
17356: ST_TO_ADDR
// if not tmp then
17357: LD_VAR 0 6
17361: NOT
17362: IFFALSE 17366
// exit ;
17364: GO 17614
// result := [ ] ;
17366: LD_ADDR_VAR 0 2
17370: PUSH
17371: EMPTY
17372: ST_TO_ADDR
// for i in tmp do
17373: LD_ADDR_VAR 0 3
17377: PUSH
17378: LD_VAR 0 6
17382: PUSH
17383: FOR_IN
17384: IFFALSE 17455
// begin t := UnitsInside ( i ) ;
17386: LD_ADDR_VAR 0 4
17390: PUSH
17391: LD_VAR 0 3
17395: PPUSH
17396: CALL_OW 313
17400: ST_TO_ADDR
// if t then
17401: LD_VAR 0 4
17405: IFFALSE 17453
// for j in t do
17407: LD_ADDR_VAR 0 7
17411: PUSH
17412: LD_VAR 0 4
17416: PUSH
17417: FOR_IN
17418: IFFALSE 17451
// result := Insert ( result , result + 1 , j ) ;
17420: LD_ADDR_VAR 0 2
17424: PUSH
17425: LD_VAR 0 2
17429: PPUSH
17430: LD_VAR 0 2
17434: PUSH
17435: LD_INT 1
17437: PLUS
17438: PPUSH
17439: LD_VAR 0 7
17443: PPUSH
17444: CALL_OW 2
17448: ST_TO_ADDR
17449: GO 17417
17451: POP
17452: POP
// end ;
17453: GO 17383
17455: POP
17456: POP
// if not result then
17457: LD_VAR 0 2
17461: NOT
17462: IFFALSE 17466
// exit ;
17464: GO 17614
// mech := result [ 1 ] ;
17466: LD_ADDR_VAR 0 5
17470: PUSH
17471: LD_VAR 0 2
17475: PUSH
17476: LD_INT 1
17478: ARRAY
17479: ST_TO_ADDR
// if result > 1 then
17480: LD_VAR 0 2
17484: PUSH
17485: LD_INT 1
17487: GREATER
17488: IFFALSE 17600
// for i = 2 to result do
17490: LD_ADDR_VAR 0 3
17494: PUSH
17495: DOUBLE
17496: LD_INT 2
17498: DEC
17499: ST_TO_ADDR
17500: LD_VAR 0 2
17504: PUSH
17505: FOR_TO
17506: IFFALSE 17598
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
17508: LD_ADDR_VAR 0 4
17512: PUSH
17513: LD_VAR 0 2
17517: PUSH
17518: LD_VAR 0 3
17522: ARRAY
17523: PPUSH
17524: LD_INT 3
17526: PPUSH
17527: CALL_OW 259
17531: PUSH
17532: LD_VAR 0 2
17536: PUSH
17537: LD_VAR 0 3
17541: ARRAY
17542: PPUSH
17543: CALL_OW 432
17547: MINUS
17548: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
17549: LD_VAR 0 4
17553: PUSH
17554: LD_VAR 0 5
17558: PPUSH
17559: LD_INT 3
17561: PPUSH
17562: CALL_OW 259
17566: PUSH
17567: LD_VAR 0 5
17571: PPUSH
17572: CALL_OW 432
17576: MINUS
17577: GREATEREQUAL
17578: IFFALSE 17596
// mech := result [ i ] ;
17580: LD_ADDR_VAR 0 5
17584: PUSH
17585: LD_VAR 0 2
17589: PUSH
17590: LD_VAR 0 3
17594: ARRAY
17595: ST_TO_ADDR
// end ;
17596: GO 17505
17598: POP
17599: POP
// ComLinkTo ( vehicle , mech ) ;
17600: LD_VAR 0 1
17604: PPUSH
17605: LD_VAR 0 5
17609: PPUSH
17610: CALL_OW 135
// end ;
17614: LD_VAR 0 2
17618: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
17619: LD_INT 0
17621: PPUSH
17622: PPUSH
17623: PPUSH
17624: PPUSH
17625: PPUSH
17626: PPUSH
17627: PPUSH
17628: PPUSH
17629: PPUSH
17630: PPUSH
17631: PPUSH
17632: PPUSH
17633: PPUSH
// result := [ ] ;
17634: LD_ADDR_VAR 0 7
17638: PUSH
17639: EMPTY
17640: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
17641: LD_VAR 0 1
17645: PPUSH
17646: CALL_OW 266
17650: PUSH
17651: LD_INT 0
17653: PUSH
17654: LD_INT 1
17656: PUSH
17657: EMPTY
17658: LIST
17659: LIST
17660: IN
17661: NOT
17662: IFFALSE 17666
// exit ;
17664: GO 19297
// if name then
17666: LD_VAR 0 3
17670: IFFALSE 17686
// SetBName ( base_dep , name ) ;
17672: LD_VAR 0 1
17676: PPUSH
17677: LD_VAR 0 3
17681: PPUSH
17682: CALL_OW 500
// base := GetBase ( base_dep ) ;
17686: LD_ADDR_VAR 0 15
17690: PUSH
17691: LD_VAR 0 1
17695: PPUSH
17696: CALL_OW 274
17700: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
17701: LD_ADDR_VAR 0 16
17705: PUSH
17706: LD_VAR 0 1
17710: PPUSH
17711: CALL_OW 255
17715: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
17716: LD_ADDR_VAR 0 17
17720: PUSH
17721: LD_VAR 0 1
17725: PPUSH
17726: CALL_OW 248
17730: ST_TO_ADDR
// if sources then
17731: LD_VAR 0 5
17735: IFFALSE 17782
// for i = 1 to 3 do
17737: LD_ADDR_VAR 0 8
17741: PUSH
17742: DOUBLE
17743: LD_INT 1
17745: DEC
17746: ST_TO_ADDR
17747: LD_INT 3
17749: PUSH
17750: FOR_TO
17751: IFFALSE 17780
// AddResourceType ( base , i , sources [ i ] ) ;
17753: LD_VAR 0 15
17757: PPUSH
17758: LD_VAR 0 8
17762: PPUSH
17763: LD_VAR 0 5
17767: PUSH
17768: LD_VAR 0 8
17772: ARRAY
17773: PPUSH
17774: CALL_OW 276
17778: GO 17750
17780: POP
17781: POP
// buildings := GetBaseBuildings ( base , area ) ;
17782: LD_ADDR_VAR 0 18
17786: PUSH
17787: LD_VAR 0 15
17791: PPUSH
17792: LD_VAR 0 2
17796: PPUSH
17797: CALL 17074 0 2
17801: ST_TO_ADDR
// InitHc ;
17802: CALL_OW 19
// InitUc ;
17806: CALL_OW 18
// uc_side := side ;
17810: LD_ADDR_OWVAR 20
17814: PUSH
17815: LD_VAR 0 16
17819: ST_TO_ADDR
// uc_nation := nation ;
17820: LD_ADDR_OWVAR 21
17824: PUSH
17825: LD_VAR 0 17
17829: ST_TO_ADDR
// if buildings then
17830: LD_VAR 0 18
17834: IFFALSE 19156
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
17836: LD_ADDR_VAR 0 19
17840: PUSH
17841: LD_VAR 0 18
17845: PPUSH
17846: LD_INT 2
17848: PUSH
17849: LD_INT 30
17851: PUSH
17852: LD_INT 29
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: PUSH
17859: LD_INT 30
17861: PUSH
17862: LD_INT 30
17864: PUSH
17865: EMPTY
17866: LIST
17867: LIST
17868: PUSH
17869: EMPTY
17870: LIST
17871: LIST
17872: LIST
17873: PPUSH
17874: CALL_OW 72
17878: ST_TO_ADDR
// if tmp then
17879: LD_VAR 0 19
17883: IFFALSE 17931
// for i in tmp do
17885: LD_ADDR_VAR 0 8
17889: PUSH
17890: LD_VAR 0 19
17894: PUSH
17895: FOR_IN
17896: IFFALSE 17929
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
17898: LD_VAR 0 8
17902: PPUSH
17903: CALL_OW 250
17907: PPUSH
17908: LD_VAR 0 8
17912: PPUSH
17913: CALL_OW 251
17917: PPUSH
17918: LD_VAR 0 16
17922: PPUSH
17923: CALL_OW 441
17927: GO 17895
17929: POP
17930: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
17931: LD_VAR 0 18
17935: PPUSH
17936: LD_INT 2
17938: PUSH
17939: LD_INT 30
17941: PUSH
17942: LD_INT 32
17944: PUSH
17945: EMPTY
17946: LIST
17947: LIST
17948: PUSH
17949: LD_INT 30
17951: PUSH
17952: LD_INT 33
17954: PUSH
17955: EMPTY
17956: LIST
17957: LIST
17958: PUSH
17959: EMPTY
17960: LIST
17961: LIST
17962: LIST
17963: PPUSH
17964: CALL_OW 72
17968: IFFALSE 18056
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
17970: LD_ADDR_VAR 0 8
17974: PUSH
17975: LD_VAR 0 18
17979: PPUSH
17980: LD_INT 2
17982: PUSH
17983: LD_INT 30
17985: PUSH
17986: LD_INT 32
17988: PUSH
17989: EMPTY
17990: LIST
17991: LIST
17992: PUSH
17993: LD_INT 30
17995: PUSH
17996: LD_INT 33
17998: PUSH
17999: EMPTY
18000: LIST
18001: LIST
18002: PUSH
18003: EMPTY
18004: LIST
18005: LIST
18006: LIST
18007: PPUSH
18008: CALL_OW 72
18012: PUSH
18013: FOR_IN
18014: IFFALSE 18054
// begin if not GetBWeapon ( i ) then
18016: LD_VAR 0 8
18020: PPUSH
18021: CALL_OW 269
18025: NOT
18026: IFFALSE 18052
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18028: LD_VAR 0 8
18032: PPUSH
18033: LD_VAR 0 8
18037: PPUSH
18038: LD_VAR 0 2
18042: PPUSH
18043: CALL 19302 0 2
18047: PPUSH
18048: CALL_OW 431
// end ;
18052: GO 18013
18054: POP
18055: POP
// end ; for i = 1 to personel do
18056: LD_ADDR_VAR 0 8
18060: PUSH
18061: DOUBLE
18062: LD_INT 1
18064: DEC
18065: ST_TO_ADDR
18066: LD_VAR 0 6
18070: PUSH
18071: FOR_TO
18072: IFFALSE 19136
// begin if i > 4 then
18074: LD_VAR 0 8
18078: PUSH
18079: LD_INT 4
18081: GREATER
18082: IFFALSE 18086
// break ;
18084: GO 19136
// case i of 1 :
18086: LD_VAR 0 8
18090: PUSH
18091: LD_INT 1
18093: DOUBLE
18094: EQUAL
18095: IFTRUE 18099
18097: GO 18179
18099: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18100: LD_ADDR_VAR 0 12
18104: PUSH
18105: LD_VAR 0 18
18109: PPUSH
18110: LD_INT 22
18112: PUSH
18113: LD_VAR 0 16
18117: PUSH
18118: EMPTY
18119: LIST
18120: LIST
18121: PUSH
18122: LD_INT 58
18124: PUSH
18125: EMPTY
18126: LIST
18127: PUSH
18128: LD_INT 2
18130: PUSH
18131: LD_INT 30
18133: PUSH
18134: LD_INT 32
18136: PUSH
18137: EMPTY
18138: LIST
18139: LIST
18140: PUSH
18141: LD_INT 30
18143: PUSH
18144: LD_INT 4
18146: PUSH
18147: EMPTY
18148: LIST
18149: LIST
18150: PUSH
18151: LD_INT 30
18153: PUSH
18154: LD_INT 5
18156: PUSH
18157: EMPTY
18158: LIST
18159: LIST
18160: PUSH
18161: EMPTY
18162: LIST
18163: LIST
18164: LIST
18165: LIST
18166: PUSH
18167: EMPTY
18168: LIST
18169: LIST
18170: LIST
18171: PPUSH
18172: CALL_OW 72
18176: ST_TO_ADDR
18177: GO 18401
18179: LD_INT 2
18181: DOUBLE
18182: EQUAL
18183: IFTRUE 18187
18185: GO 18249
18187: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18188: LD_ADDR_VAR 0 12
18192: PUSH
18193: LD_VAR 0 18
18197: PPUSH
18198: LD_INT 22
18200: PUSH
18201: LD_VAR 0 16
18205: PUSH
18206: EMPTY
18207: LIST
18208: LIST
18209: PUSH
18210: LD_INT 2
18212: PUSH
18213: LD_INT 30
18215: PUSH
18216: LD_INT 0
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: PUSH
18223: LD_INT 30
18225: PUSH
18226: LD_INT 1
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: LIST
18237: PUSH
18238: EMPTY
18239: LIST
18240: LIST
18241: PPUSH
18242: CALL_OW 72
18246: ST_TO_ADDR
18247: GO 18401
18249: LD_INT 3
18251: DOUBLE
18252: EQUAL
18253: IFTRUE 18257
18255: GO 18319
18257: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18258: LD_ADDR_VAR 0 12
18262: PUSH
18263: LD_VAR 0 18
18267: PPUSH
18268: LD_INT 22
18270: PUSH
18271: LD_VAR 0 16
18275: PUSH
18276: EMPTY
18277: LIST
18278: LIST
18279: PUSH
18280: LD_INT 2
18282: PUSH
18283: LD_INT 30
18285: PUSH
18286: LD_INT 2
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PUSH
18293: LD_INT 30
18295: PUSH
18296: LD_INT 3
18298: PUSH
18299: EMPTY
18300: LIST
18301: LIST
18302: PUSH
18303: EMPTY
18304: LIST
18305: LIST
18306: LIST
18307: PUSH
18308: EMPTY
18309: LIST
18310: LIST
18311: PPUSH
18312: CALL_OW 72
18316: ST_TO_ADDR
18317: GO 18401
18319: LD_INT 4
18321: DOUBLE
18322: EQUAL
18323: IFTRUE 18327
18325: GO 18400
18327: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18328: LD_ADDR_VAR 0 12
18332: PUSH
18333: LD_VAR 0 18
18337: PPUSH
18338: LD_INT 22
18340: PUSH
18341: LD_VAR 0 16
18345: PUSH
18346: EMPTY
18347: LIST
18348: LIST
18349: PUSH
18350: LD_INT 2
18352: PUSH
18353: LD_INT 30
18355: PUSH
18356: LD_INT 6
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: PUSH
18363: LD_INT 30
18365: PUSH
18366: LD_INT 7
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PUSH
18373: LD_INT 30
18375: PUSH
18376: LD_INT 8
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: EMPTY
18384: LIST
18385: LIST
18386: LIST
18387: LIST
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: PPUSH
18393: CALL_OW 72
18397: ST_TO_ADDR
18398: GO 18401
18400: POP
// if i = 1 then
18401: LD_VAR 0 8
18405: PUSH
18406: LD_INT 1
18408: EQUAL
18409: IFFALSE 18520
// begin tmp := [ ] ;
18411: LD_ADDR_VAR 0 19
18415: PUSH
18416: EMPTY
18417: ST_TO_ADDR
// for j in f do
18418: LD_ADDR_VAR 0 9
18422: PUSH
18423: LD_VAR 0 12
18427: PUSH
18428: FOR_IN
18429: IFFALSE 18502
// if GetBType ( j ) = b_bunker then
18431: LD_VAR 0 9
18435: PPUSH
18436: CALL_OW 266
18440: PUSH
18441: LD_INT 32
18443: EQUAL
18444: IFFALSE 18471
// tmp := Insert ( tmp , 1 , j ) else
18446: LD_ADDR_VAR 0 19
18450: PUSH
18451: LD_VAR 0 19
18455: PPUSH
18456: LD_INT 1
18458: PPUSH
18459: LD_VAR 0 9
18463: PPUSH
18464: CALL_OW 2
18468: ST_TO_ADDR
18469: GO 18500
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18471: LD_ADDR_VAR 0 19
18475: PUSH
18476: LD_VAR 0 19
18480: PPUSH
18481: LD_VAR 0 19
18485: PUSH
18486: LD_INT 1
18488: PLUS
18489: PPUSH
18490: LD_VAR 0 9
18494: PPUSH
18495: CALL_OW 2
18499: ST_TO_ADDR
18500: GO 18428
18502: POP
18503: POP
// if tmp then
18504: LD_VAR 0 19
18508: IFFALSE 18520
// f := tmp ;
18510: LD_ADDR_VAR 0 12
18514: PUSH
18515: LD_VAR 0 19
18519: ST_TO_ADDR
// end ; x := personel [ i ] ;
18520: LD_ADDR_VAR 0 13
18524: PUSH
18525: LD_VAR 0 6
18529: PUSH
18530: LD_VAR 0 8
18534: ARRAY
18535: ST_TO_ADDR
// if x = - 1 then
18536: LD_VAR 0 13
18540: PUSH
18541: LD_INT 1
18543: NEG
18544: EQUAL
18545: IFFALSE 18754
// begin for j in f do
18547: LD_ADDR_VAR 0 9
18551: PUSH
18552: LD_VAR 0 12
18556: PUSH
18557: FOR_IN
18558: IFFALSE 18750
// repeat InitHc ;
18560: CALL_OW 19
// if GetBType ( j ) = b_barracks then
18564: LD_VAR 0 9
18568: PPUSH
18569: CALL_OW 266
18573: PUSH
18574: LD_INT 5
18576: EQUAL
18577: IFFALSE 18647
// begin if UnitsInside ( j ) < 3 then
18579: LD_VAR 0 9
18583: PPUSH
18584: CALL_OW 313
18588: PUSH
18589: LD_INT 3
18591: LESS
18592: IFFALSE 18628
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
18594: LD_INT 0
18596: PPUSH
18597: LD_INT 5
18599: PUSH
18600: LD_INT 8
18602: PUSH
18603: LD_INT 9
18605: PUSH
18606: EMPTY
18607: LIST
18608: LIST
18609: LIST
18610: PUSH
18611: LD_VAR 0 17
18615: ARRAY
18616: PPUSH
18617: LD_VAR 0 4
18621: PPUSH
18622: CALL_OW 380
18626: GO 18645
// PrepareHuman ( false , i , skill ) ;
18628: LD_INT 0
18630: PPUSH
18631: LD_VAR 0 8
18635: PPUSH
18636: LD_VAR 0 4
18640: PPUSH
18641: CALL_OW 380
// end else
18645: GO 18664
// PrepareHuman ( false , i , skill ) ;
18647: LD_INT 0
18649: PPUSH
18650: LD_VAR 0 8
18654: PPUSH
18655: LD_VAR 0 4
18659: PPUSH
18660: CALL_OW 380
// un := CreateHuman ;
18664: LD_ADDR_VAR 0 14
18668: PUSH
18669: CALL_OW 44
18673: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18674: LD_ADDR_VAR 0 7
18678: PUSH
18679: LD_VAR 0 7
18683: PPUSH
18684: LD_INT 1
18686: PPUSH
18687: LD_VAR 0 14
18691: PPUSH
18692: CALL_OW 2
18696: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
18697: LD_VAR 0 14
18701: PPUSH
18702: LD_VAR 0 9
18706: PPUSH
18707: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
18711: LD_VAR 0 9
18715: PPUSH
18716: CALL_OW 313
18720: PUSH
18721: LD_INT 6
18723: EQUAL
18724: PUSH
18725: LD_VAR 0 9
18729: PPUSH
18730: CALL_OW 266
18734: PUSH
18735: LD_INT 32
18737: PUSH
18738: LD_INT 31
18740: PUSH
18741: EMPTY
18742: LIST
18743: LIST
18744: IN
18745: OR
18746: IFFALSE 18560
18748: GO 18557
18750: POP
18751: POP
// end else
18752: GO 19134
// for j = 1 to x do
18754: LD_ADDR_VAR 0 9
18758: PUSH
18759: DOUBLE
18760: LD_INT 1
18762: DEC
18763: ST_TO_ADDR
18764: LD_VAR 0 13
18768: PUSH
18769: FOR_TO
18770: IFFALSE 19132
// begin InitHc ;
18772: CALL_OW 19
// if not f then
18776: LD_VAR 0 12
18780: NOT
18781: IFFALSE 18870
// begin PrepareHuman ( false , i , skill ) ;
18783: LD_INT 0
18785: PPUSH
18786: LD_VAR 0 8
18790: PPUSH
18791: LD_VAR 0 4
18795: PPUSH
18796: CALL_OW 380
// un := CreateHuman ;
18800: LD_ADDR_VAR 0 14
18804: PUSH
18805: CALL_OW 44
18809: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18810: LD_ADDR_VAR 0 7
18814: PUSH
18815: LD_VAR 0 7
18819: PPUSH
18820: LD_INT 1
18822: PPUSH
18823: LD_VAR 0 14
18827: PPUSH
18828: CALL_OW 2
18832: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
18833: LD_VAR 0 14
18837: PPUSH
18838: LD_VAR 0 1
18842: PPUSH
18843: CALL_OW 250
18847: PPUSH
18848: LD_VAR 0 1
18852: PPUSH
18853: CALL_OW 251
18857: PPUSH
18858: LD_INT 10
18860: PPUSH
18861: LD_INT 0
18863: PPUSH
18864: CALL_OW 50
// continue ;
18868: GO 18769
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
18870: LD_VAR 0 12
18874: PUSH
18875: LD_INT 1
18877: ARRAY
18878: PPUSH
18879: CALL_OW 313
18883: PUSH
18884: LD_VAR 0 12
18888: PUSH
18889: LD_INT 1
18891: ARRAY
18892: PPUSH
18893: CALL_OW 266
18897: PUSH
18898: LD_INT 32
18900: PUSH
18901: LD_INT 31
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: IN
18908: AND
18909: PUSH
18910: LD_VAR 0 12
18914: PUSH
18915: LD_INT 1
18917: ARRAY
18918: PPUSH
18919: CALL_OW 313
18923: PUSH
18924: LD_INT 6
18926: EQUAL
18927: OR
18928: IFFALSE 18948
// f := Delete ( f , 1 ) ;
18930: LD_ADDR_VAR 0 12
18934: PUSH
18935: LD_VAR 0 12
18939: PPUSH
18940: LD_INT 1
18942: PPUSH
18943: CALL_OW 3
18947: ST_TO_ADDR
// if not f then
18948: LD_VAR 0 12
18952: NOT
18953: IFFALSE 18971
// begin x := x + 2 ;
18955: LD_ADDR_VAR 0 13
18959: PUSH
18960: LD_VAR 0 13
18964: PUSH
18965: LD_INT 2
18967: PLUS
18968: ST_TO_ADDR
// continue ;
18969: GO 18769
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
18971: LD_VAR 0 12
18975: PUSH
18976: LD_INT 1
18978: ARRAY
18979: PPUSH
18980: CALL_OW 266
18984: PUSH
18985: LD_INT 5
18987: EQUAL
18988: IFFALSE 19062
// begin if UnitsInside ( f [ 1 ] ) < 3 then
18990: LD_VAR 0 12
18994: PUSH
18995: LD_INT 1
18997: ARRAY
18998: PPUSH
18999: CALL_OW 313
19003: PUSH
19004: LD_INT 3
19006: LESS
19007: IFFALSE 19043
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19009: LD_INT 0
19011: PPUSH
19012: LD_INT 5
19014: PUSH
19015: LD_INT 8
19017: PUSH
19018: LD_INT 9
19020: PUSH
19021: EMPTY
19022: LIST
19023: LIST
19024: LIST
19025: PUSH
19026: LD_VAR 0 17
19030: ARRAY
19031: PPUSH
19032: LD_VAR 0 4
19036: PPUSH
19037: CALL_OW 380
19041: GO 19060
// PrepareHuman ( false , i , skill ) ;
19043: LD_INT 0
19045: PPUSH
19046: LD_VAR 0 8
19050: PPUSH
19051: LD_VAR 0 4
19055: PPUSH
19056: CALL_OW 380
// end else
19060: GO 19079
// PrepareHuman ( false , i , skill ) ;
19062: LD_INT 0
19064: PPUSH
19065: LD_VAR 0 8
19069: PPUSH
19070: LD_VAR 0 4
19074: PPUSH
19075: CALL_OW 380
// un := CreateHuman ;
19079: LD_ADDR_VAR 0 14
19083: PUSH
19084: CALL_OW 44
19088: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19089: LD_ADDR_VAR 0 7
19093: PUSH
19094: LD_VAR 0 7
19098: PPUSH
19099: LD_INT 1
19101: PPUSH
19102: LD_VAR 0 14
19106: PPUSH
19107: CALL_OW 2
19111: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19112: LD_VAR 0 14
19116: PPUSH
19117: LD_VAR 0 12
19121: PUSH
19122: LD_INT 1
19124: ARRAY
19125: PPUSH
19126: CALL_OW 52
// end ;
19130: GO 18769
19132: POP
19133: POP
// end ;
19134: GO 18071
19136: POP
19137: POP
// result := result ^ buildings ;
19138: LD_ADDR_VAR 0 7
19142: PUSH
19143: LD_VAR 0 7
19147: PUSH
19148: LD_VAR 0 18
19152: ADD
19153: ST_TO_ADDR
// end else
19154: GO 19297
// begin for i = 1 to personel do
19156: LD_ADDR_VAR 0 8
19160: PUSH
19161: DOUBLE
19162: LD_INT 1
19164: DEC
19165: ST_TO_ADDR
19166: LD_VAR 0 6
19170: PUSH
19171: FOR_TO
19172: IFFALSE 19295
// begin if i > 4 then
19174: LD_VAR 0 8
19178: PUSH
19179: LD_INT 4
19181: GREATER
19182: IFFALSE 19186
// break ;
19184: GO 19295
// x := personel [ i ] ;
19186: LD_ADDR_VAR 0 13
19190: PUSH
19191: LD_VAR 0 6
19195: PUSH
19196: LD_VAR 0 8
19200: ARRAY
19201: ST_TO_ADDR
// if x = - 1 then
19202: LD_VAR 0 13
19206: PUSH
19207: LD_INT 1
19209: NEG
19210: EQUAL
19211: IFFALSE 19215
// continue ;
19213: GO 19171
// PrepareHuman ( false , i , skill ) ;
19215: LD_INT 0
19217: PPUSH
19218: LD_VAR 0 8
19222: PPUSH
19223: LD_VAR 0 4
19227: PPUSH
19228: CALL_OW 380
// un := CreateHuman ;
19232: LD_ADDR_VAR 0 14
19236: PUSH
19237: CALL_OW 44
19241: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19242: LD_VAR 0 14
19246: PPUSH
19247: LD_VAR 0 1
19251: PPUSH
19252: CALL_OW 250
19256: PPUSH
19257: LD_VAR 0 1
19261: PPUSH
19262: CALL_OW 251
19266: PPUSH
19267: LD_INT 10
19269: PPUSH
19270: LD_INT 0
19272: PPUSH
19273: CALL_OW 50
// result := result ^ un ;
19277: LD_ADDR_VAR 0 7
19281: PUSH
19282: LD_VAR 0 7
19286: PUSH
19287: LD_VAR 0 14
19291: ADD
19292: ST_TO_ADDR
// end ;
19293: GO 19171
19295: POP
19296: POP
// end ; end ;
19297: LD_VAR 0 7
19301: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19302: LD_INT 0
19304: PPUSH
19305: PPUSH
19306: PPUSH
19307: PPUSH
19308: PPUSH
19309: PPUSH
19310: PPUSH
19311: PPUSH
19312: PPUSH
19313: PPUSH
19314: PPUSH
19315: PPUSH
19316: PPUSH
19317: PPUSH
19318: PPUSH
19319: PPUSH
// result := false ;
19320: LD_ADDR_VAR 0 3
19324: PUSH
19325: LD_INT 0
19327: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19328: LD_VAR 0 1
19332: NOT
19333: PUSH
19334: LD_VAR 0 1
19338: PPUSH
19339: CALL_OW 266
19343: PUSH
19344: LD_INT 32
19346: PUSH
19347: LD_INT 33
19349: PUSH
19350: EMPTY
19351: LIST
19352: LIST
19353: IN
19354: NOT
19355: OR
19356: IFFALSE 19360
// exit ;
19358: GO 20496
// nat := GetNation ( tower ) ;
19360: LD_ADDR_VAR 0 12
19364: PUSH
19365: LD_VAR 0 1
19369: PPUSH
19370: CALL_OW 248
19374: ST_TO_ADDR
// side := GetSide ( tower ) ;
19375: LD_ADDR_VAR 0 16
19379: PUSH
19380: LD_VAR 0 1
19384: PPUSH
19385: CALL_OW 255
19389: ST_TO_ADDR
// x := GetX ( tower ) ;
19390: LD_ADDR_VAR 0 10
19394: PUSH
19395: LD_VAR 0 1
19399: PPUSH
19400: CALL_OW 250
19404: ST_TO_ADDR
// y := GetY ( tower ) ;
19405: LD_ADDR_VAR 0 11
19409: PUSH
19410: LD_VAR 0 1
19414: PPUSH
19415: CALL_OW 251
19419: ST_TO_ADDR
// if not x or not y then
19420: LD_VAR 0 10
19424: NOT
19425: PUSH
19426: LD_VAR 0 11
19430: NOT
19431: OR
19432: IFFALSE 19436
// exit ;
19434: GO 20496
// weapon := 0 ;
19436: LD_ADDR_VAR 0 18
19440: PUSH
19441: LD_INT 0
19443: ST_TO_ADDR
// fac_list := [ ] ;
19444: LD_ADDR_VAR 0 17
19448: PUSH
19449: EMPTY
19450: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
19451: LD_ADDR_VAR 0 6
19455: PUSH
19456: LD_VAR 0 1
19460: PPUSH
19461: CALL_OW 274
19465: PPUSH
19466: LD_VAR 0 2
19470: PPUSH
19471: CALL 17074 0 2
19475: PPUSH
19476: LD_INT 30
19478: PUSH
19479: LD_INT 3
19481: PUSH
19482: EMPTY
19483: LIST
19484: LIST
19485: PPUSH
19486: CALL_OW 72
19490: ST_TO_ADDR
// if not factories then
19491: LD_VAR 0 6
19495: NOT
19496: IFFALSE 19500
// exit ;
19498: GO 20496
// for i in factories do
19500: LD_ADDR_VAR 0 8
19504: PUSH
19505: LD_VAR 0 6
19509: PUSH
19510: FOR_IN
19511: IFFALSE 19536
// fac_list := fac_list union AvailableWeaponList ( i ) ;
19513: LD_ADDR_VAR 0 17
19517: PUSH
19518: LD_VAR 0 17
19522: PUSH
19523: LD_VAR 0 8
19527: PPUSH
19528: CALL_OW 478
19532: UNION
19533: ST_TO_ADDR
19534: GO 19510
19536: POP
19537: POP
// if not fac_list then
19538: LD_VAR 0 17
19542: NOT
19543: IFFALSE 19547
// exit ;
19545: GO 20496
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
19547: LD_ADDR_VAR 0 5
19551: PUSH
19552: LD_INT 4
19554: PUSH
19555: LD_INT 5
19557: PUSH
19558: LD_INT 9
19560: PUSH
19561: LD_INT 10
19563: PUSH
19564: LD_INT 6
19566: PUSH
19567: LD_INT 7
19569: PUSH
19570: LD_INT 11
19572: PUSH
19573: EMPTY
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: LIST
19579: LIST
19580: LIST
19581: PUSH
19582: LD_INT 27
19584: PUSH
19585: LD_INT 28
19587: PUSH
19588: LD_INT 26
19590: PUSH
19591: LD_INT 30
19593: PUSH
19594: EMPTY
19595: LIST
19596: LIST
19597: LIST
19598: LIST
19599: PUSH
19600: LD_INT 43
19602: PUSH
19603: LD_INT 44
19605: PUSH
19606: LD_INT 46
19608: PUSH
19609: LD_INT 45
19611: PUSH
19612: LD_INT 47
19614: PUSH
19615: LD_INT 49
19617: PUSH
19618: EMPTY
19619: LIST
19620: LIST
19621: LIST
19622: LIST
19623: LIST
19624: LIST
19625: PUSH
19626: EMPTY
19627: LIST
19628: LIST
19629: LIST
19630: PUSH
19631: LD_VAR 0 12
19635: ARRAY
19636: ST_TO_ADDR
// for i in list do
19637: LD_ADDR_VAR 0 8
19641: PUSH
19642: LD_VAR 0 5
19646: PUSH
19647: FOR_IN
19648: IFFALSE 19681
// if not i in fac_list then
19650: LD_VAR 0 8
19654: PUSH
19655: LD_VAR 0 17
19659: IN
19660: NOT
19661: IFFALSE 19679
// list := list diff i ;
19663: LD_ADDR_VAR 0 5
19667: PUSH
19668: LD_VAR 0 5
19672: PUSH
19673: LD_VAR 0 8
19677: DIFF
19678: ST_TO_ADDR
19679: GO 19647
19681: POP
19682: POP
// if not list then
19683: LD_VAR 0 5
19687: NOT
19688: IFFALSE 19692
// exit ;
19690: GO 20496
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
19692: LD_VAR 0 12
19696: PUSH
19697: LD_INT 3
19699: EQUAL
19700: PUSH
19701: LD_INT 49
19703: PUSH
19704: LD_VAR 0 5
19708: IN
19709: AND
19710: PUSH
19711: LD_INT 31
19713: PPUSH
19714: LD_VAR 0 16
19718: PPUSH
19719: CALL_OW 321
19723: PUSH
19724: LD_INT 2
19726: EQUAL
19727: AND
19728: IFFALSE 19788
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
19730: LD_INT 22
19732: PUSH
19733: LD_VAR 0 16
19737: PUSH
19738: EMPTY
19739: LIST
19740: LIST
19741: PUSH
19742: LD_INT 35
19744: PUSH
19745: LD_INT 49
19747: PUSH
19748: EMPTY
19749: LIST
19750: LIST
19751: PUSH
19752: LD_INT 91
19754: PUSH
19755: LD_VAR 0 1
19759: PUSH
19760: LD_INT 10
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: LIST
19767: PUSH
19768: EMPTY
19769: LIST
19770: LIST
19771: LIST
19772: PPUSH
19773: CALL_OW 69
19777: NOT
19778: IFFALSE 19788
// weapon := ru_time_lapser ;
19780: LD_ADDR_VAR 0 18
19784: PUSH
19785: LD_INT 49
19787: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
19788: LD_VAR 0 12
19792: PUSH
19793: LD_INT 1
19795: PUSH
19796: LD_INT 2
19798: PUSH
19799: EMPTY
19800: LIST
19801: LIST
19802: IN
19803: PUSH
19804: LD_INT 11
19806: PUSH
19807: LD_VAR 0 5
19811: IN
19812: PUSH
19813: LD_INT 30
19815: PUSH
19816: LD_VAR 0 5
19820: IN
19821: OR
19822: AND
19823: PUSH
19824: LD_INT 6
19826: PPUSH
19827: LD_VAR 0 16
19831: PPUSH
19832: CALL_OW 321
19836: PUSH
19837: LD_INT 2
19839: EQUAL
19840: AND
19841: IFFALSE 20006
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
19843: LD_INT 22
19845: PUSH
19846: LD_VAR 0 16
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: PUSH
19855: LD_INT 2
19857: PUSH
19858: LD_INT 35
19860: PUSH
19861: LD_INT 11
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: PUSH
19868: LD_INT 35
19870: PUSH
19871: LD_INT 30
19873: PUSH
19874: EMPTY
19875: LIST
19876: LIST
19877: PUSH
19878: EMPTY
19879: LIST
19880: LIST
19881: LIST
19882: PUSH
19883: LD_INT 91
19885: PUSH
19886: LD_VAR 0 1
19890: PUSH
19891: LD_INT 18
19893: PUSH
19894: EMPTY
19895: LIST
19896: LIST
19897: LIST
19898: PUSH
19899: EMPTY
19900: LIST
19901: LIST
19902: LIST
19903: PPUSH
19904: CALL_OW 69
19908: NOT
19909: PUSH
19910: LD_INT 22
19912: PUSH
19913: LD_VAR 0 16
19917: PUSH
19918: EMPTY
19919: LIST
19920: LIST
19921: PUSH
19922: LD_INT 2
19924: PUSH
19925: LD_INT 30
19927: PUSH
19928: LD_INT 32
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: PUSH
19935: LD_INT 30
19937: PUSH
19938: LD_INT 33
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: PUSH
19945: EMPTY
19946: LIST
19947: LIST
19948: LIST
19949: PUSH
19950: LD_INT 91
19952: PUSH
19953: LD_VAR 0 1
19957: PUSH
19958: LD_INT 12
19960: PUSH
19961: EMPTY
19962: LIST
19963: LIST
19964: LIST
19965: PUSH
19966: EMPTY
19967: LIST
19968: LIST
19969: LIST
19970: PUSH
19971: EMPTY
19972: LIST
19973: PPUSH
19974: CALL_OW 69
19978: PUSH
19979: LD_INT 2
19981: GREATER
19982: AND
19983: IFFALSE 20006
// weapon := [ us_radar , ar_radar ] [ nat ] ;
19985: LD_ADDR_VAR 0 18
19989: PUSH
19990: LD_INT 11
19992: PUSH
19993: LD_INT 30
19995: PUSH
19996: EMPTY
19997: LIST
19998: LIST
19999: PUSH
20000: LD_VAR 0 12
20004: ARRAY
20005: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20006: LD_VAR 0 18
20010: NOT
20011: PUSH
20012: LD_INT 40
20014: PPUSH
20015: LD_VAR 0 16
20019: PPUSH
20020: CALL_OW 321
20024: PUSH
20025: LD_INT 2
20027: EQUAL
20028: AND
20029: PUSH
20030: LD_INT 7
20032: PUSH
20033: LD_VAR 0 5
20037: IN
20038: PUSH
20039: LD_INT 28
20041: PUSH
20042: LD_VAR 0 5
20046: IN
20047: OR
20048: PUSH
20049: LD_INT 45
20051: PUSH
20052: LD_VAR 0 5
20056: IN
20057: OR
20058: AND
20059: IFFALSE 20313
// begin hex := GetHexInfo ( x , y ) ;
20061: LD_ADDR_VAR 0 4
20065: PUSH
20066: LD_VAR 0 10
20070: PPUSH
20071: LD_VAR 0 11
20075: PPUSH
20076: CALL_OW 546
20080: ST_TO_ADDR
// if hex [ 1 ] then
20081: LD_VAR 0 4
20085: PUSH
20086: LD_INT 1
20088: ARRAY
20089: IFFALSE 20093
// exit ;
20091: GO 20496
// height := hex [ 2 ] ;
20093: LD_ADDR_VAR 0 15
20097: PUSH
20098: LD_VAR 0 4
20102: PUSH
20103: LD_INT 2
20105: ARRAY
20106: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20107: LD_ADDR_VAR 0 14
20111: PUSH
20112: LD_INT 0
20114: PUSH
20115: LD_INT 2
20117: PUSH
20118: LD_INT 3
20120: PUSH
20121: LD_INT 5
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: LIST
20128: LIST
20129: ST_TO_ADDR
// for i in tmp do
20130: LD_ADDR_VAR 0 8
20134: PUSH
20135: LD_VAR 0 14
20139: PUSH
20140: FOR_IN
20141: IFFALSE 20311
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20143: LD_ADDR_VAR 0 9
20147: PUSH
20148: LD_VAR 0 10
20152: PPUSH
20153: LD_VAR 0 8
20157: PPUSH
20158: LD_INT 5
20160: PPUSH
20161: CALL_OW 272
20165: PUSH
20166: LD_VAR 0 11
20170: PPUSH
20171: LD_VAR 0 8
20175: PPUSH
20176: LD_INT 5
20178: PPUSH
20179: CALL_OW 273
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20188: LD_VAR 0 9
20192: PUSH
20193: LD_INT 1
20195: ARRAY
20196: PPUSH
20197: LD_VAR 0 9
20201: PUSH
20202: LD_INT 2
20204: ARRAY
20205: PPUSH
20206: CALL_OW 488
20210: IFFALSE 20309
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20212: LD_ADDR_VAR 0 4
20216: PUSH
20217: LD_VAR 0 9
20221: PUSH
20222: LD_INT 1
20224: ARRAY
20225: PPUSH
20226: LD_VAR 0 9
20230: PUSH
20231: LD_INT 2
20233: ARRAY
20234: PPUSH
20235: CALL_OW 546
20239: ST_TO_ADDR
// if hex [ 1 ] then
20240: LD_VAR 0 4
20244: PUSH
20245: LD_INT 1
20247: ARRAY
20248: IFFALSE 20252
// continue ;
20250: GO 20140
// h := hex [ 2 ] ;
20252: LD_ADDR_VAR 0 13
20256: PUSH
20257: LD_VAR 0 4
20261: PUSH
20262: LD_INT 2
20264: ARRAY
20265: ST_TO_ADDR
// if h + 7 < height then
20266: LD_VAR 0 13
20270: PUSH
20271: LD_INT 7
20273: PLUS
20274: PUSH
20275: LD_VAR 0 15
20279: LESS
20280: IFFALSE 20309
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20282: LD_ADDR_VAR 0 18
20286: PUSH
20287: LD_INT 7
20289: PUSH
20290: LD_INT 28
20292: PUSH
20293: LD_INT 45
20295: PUSH
20296: EMPTY
20297: LIST
20298: LIST
20299: LIST
20300: PUSH
20301: LD_VAR 0 12
20305: ARRAY
20306: ST_TO_ADDR
// break ;
20307: GO 20311
// end ; end ; end ;
20309: GO 20140
20311: POP
20312: POP
// end ; if not weapon then
20313: LD_VAR 0 18
20317: NOT
20318: IFFALSE 20378
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20320: LD_ADDR_VAR 0 5
20324: PUSH
20325: LD_VAR 0 5
20329: PUSH
20330: LD_INT 11
20332: PUSH
20333: LD_INT 30
20335: PUSH
20336: LD_INT 49
20338: PUSH
20339: EMPTY
20340: LIST
20341: LIST
20342: LIST
20343: DIFF
20344: ST_TO_ADDR
// if not list then
20345: LD_VAR 0 5
20349: NOT
20350: IFFALSE 20354
// exit ;
20352: GO 20496
// weapon := list [ rand ( 1 , list ) ] ;
20354: LD_ADDR_VAR 0 18
20358: PUSH
20359: LD_VAR 0 5
20363: PUSH
20364: LD_INT 1
20366: PPUSH
20367: LD_VAR 0 5
20371: PPUSH
20372: CALL_OW 12
20376: ARRAY
20377: ST_TO_ADDR
// end ; if weapon then
20378: LD_VAR 0 18
20382: IFFALSE 20496
// begin tmp := CostOfWeapon ( weapon ) ;
20384: LD_ADDR_VAR 0 14
20388: PUSH
20389: LD_VAR 0 18
20393: PPUSH
20394: CALL_OW 451
20398: ST_TO_ADDR
// j := GetBase ( tower ) ;
20399: LD_ADDR_VAR 0 9
20403: PUSH
20404: LD_VAR 0 1
20408: PPUSH
20409: CALL_OW 274
20413: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20414: LD_VAR 0 9
20418: PPUSH
20419: LD_INT 1
20421: PPUSH
20422: CALL_OW 275
20426: PUSH
20427: LD_VAR 0 14
20431: PUSH
20432: LD_INT 1
20434: ARRAY
20435: GREATEREQUAL
20436: PUSH
20437: LD_VAR 0 9
20441: PPUSH
20442: LD_INT 2
20444: PPUSH
20445: CALL_OW 275
20449: PUSH
20450: LD_VAR 0 14
20454: PUSH
20455: LD_INT 2
20457: ARRAY
20458: GREATEREQUAL
20459: AND
20460: PUSH
20461: LD_VAR 0 9
20465: PPUSH
20466: LD_INT 3
20468: PPUSH
20469: CALL_OW 275
20473: PUSH
20474: LD_VAR 0 14
20478: PUSH
20479: LD_INT 3
20481: ARRAY
20482: GREATEREQUAL
20483: AND
20484: IFFALSE 20496
// result := weapon ;
20486: LD_ADDR_VAR 0 3
20490: PUSH
20491: LD_VAR 0 18
20495: ST_TO_ADDR
// end ; end ;
20496: LD_VAR 0 3
20500: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
20501: LD_INT 0
20503: PPUSH
20504: PPUSH
// result := true ;
20505: LD_ADDR_VAR 0 3
20509: PUSH
20510: LD_INT 1
20512: ST_TO_ADDR
// if array1 = array2 then
20513: LD_VAR 0 1
20517: PUSH
20518: LD_VAR 0 2
20522: EQUAL
20523: IFFALSE 20583
// begin for i = 1 to array1 do
20525: LD_ADDR_VAR 0 4
20529: PUSH
20530: DOUBLE
20531: LD_INT 1
20533: DEC
20534: ST_TO_ADDR
20535: LD_VAR 0 1
20539: PUSH
20540: FOR_TO
20541: IFFALSE 20579
// if array1 [ i ] <> array2 [ i ] then
20543: LD_VAR 0 1
20547: PUSH
20548: LD_VAR 0 4
20552: ARRAY
20553: PUSH
20554: LD_VAR 0 2
20558: PUSH
20559: LD_VAR 0 4
20563: ARRAY
20564: NONEQUAL
20565: IFFALSE 20577
// begin result := false ;
20567: LD_ADDR_VAR 0 3
20571: PUSH
20572: LD_INT 0
20574: ST_TO_ADDR
// break ;
20575: GO 20579
// end ;
20577: GO 20540
20579: POP
20580: POP
// end else
20581: GO 20591
// result := false ;
20583: LD_ADDR_VAR 0 3
20587: PUSH
20588: LD_INT 0
20590: ST_TO_ADDR
// end ;
20591: LD_VAR 0 3
20595: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
20596: LD_INT 0
20598: PPUSH
20599: PPUSH
20600: PPUSH
// pom := GetBase ( fac ) ;
20601: LD_ADDR_VAR 0 5
20605: PUSH
20606: LD_VAR 0 1
20610: PPUSH
20611: CALL_OW 274
20615: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
20616: LD_ADDR_VAR 0 4
20620: PUSH
20621: LD_VAR 0 2
20625: PUSH
20626: LD_INT 1
20628: ARRAY
20629: PPUSH
20630: LD_VAR 0 2
20634: PUSH
20635: LD_INT 2
20637: ARRAY
20638: PPUSH
20639: LD_VAR 0 2
20643: PUSH
20644: LD_INT 3
20646: ARRAY
20647: PPUSH
20648: LD_VAR 0 2
20652: PUSH
20653: LD_INT 4
20655: ARRAY
20656: PPUSH
20657: CALL_OW 449
20661: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20662: LD_ADDR_VAR 0 3
20666: PUSH
20667: LD_VAR 0 5
20671: PPUSH
20672: LD_INT 1
20674: PPUSH
20675: CALL_OW 275
20679: PUSH
20680: LD_VAR 0 4
20684: PUSH
20685: LD_INT 1
20687: ARRAY
20688: GREATEREQUAL
20689: PUSH
20690: LD_VAR 0 5
20694: PPUSH
20695: LD_INT 2
20697: PPUSH
20698: CALL_OW 275
20702: PUSH
20703: LD_VAR 0 4
20707: PUSH
20708: LD_INT 2
20710: ARRAY
20711: GREATEREQUAL
20712: AND
20713: PUSH
20714: LD_VAR 0 5
20718: PPUSH
20719: LD_INT 3
20721: PPUSH
20722: CALL_OW 275
20726: PUSH
20727: LD_VAR 0 4
20731: PUSH
20732: LD_INT 3
20734: ARRAY
20735: GREATEREQUAL
20736: AND
20737: ST_TO_ADDR
// end ;
20738: LD_VAR 0 3
20742: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
20743: LD_INT 0
20745: PPUSH
20746: PPUSH
20747: PPUSH
20748: PPUSH
// pom := GetBase ( building ) ;
20749: LD_ADDR_VAR 0 3
20753: PUSH
20754: LD_VAR 0 1
20758: PPUSH
20759: CALL_OW 274
20763: ST_TO_ADDR
// if not pom then
20764: LD_VAR 0 3
20768: NOT
20769: IFFALSE 20773
// exit ;
20771: GO 20943
// btype := GetBType ( building ) ;
20773: LD_ADDR_VAR 0 5
20777: PUSH
20778: LD_VAR 0 1
20782: PPUSH
20783: CALL_OW 266
20787: ST_TO_ADDR
// if btype = b_armoury then
20788: LD_VAR 0 5
20792: PUSH
20793: LD_INT 4
20795: EQUAL
20796: IFFALSE 20806
// btype := b_barracks ;
20798: LD_ADDR_VAR 0 5
20802: PUSH
20803: LD_INT 5
20805: ST_TO_ADDR
// if btype = b_depot then
20806: LD_VAR 0 5
20810: PUSH
20811: LD_INT 0
20813: EQUAL
20814: IFFALSE 20824
// btype := b_warehouse ;
20816: LD_ADDR_VAR 0 5
20820: PUSH
20821: LD_INT 1
20823: ST_TO_ADDR
// if btype = b_workshop then
20824: LD_VAR 0 5
20828: PUSH
20829: LD_INT 2
20831: EQUAL
20832: IFFALSE 20842
// btype := b_factory ;
20834: LD_ADDR_VAR 0 5
20838: PUSH
20839: LD_INT 3
20841: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20842: LD_ADDR_VAR 0 4
20846: PUSH
20847: LD_VAR 0 5
20851: PPUSH
20852: LD_VAR 0 1
20856: PPUSH
20857: CALL_OW 248
20861: PPUSH
20862: CALL_OW 450
20866: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20867: LD_ADDR_VAR 0 2
20871: PUSH
20872: LD_VAR 0 3
20876: PPUSH
20877: LD_INT 1
20879: PPUSH
20880: CALL_OW 275
20884: PUSH
20885: LD_VAR 0 4
20889: PUSH
20890: LD_INT 1
20892: ARRAY
20893: GREATEREQUAL
20894: PUSH
20895: LD_VAR 0 3
20899: PPUSH
20900: LD_INT 2
20902: PPUSH
20903: CALL_OW 275
20907: PUSH
20908: LD_VAR 0 4
20912: PUSH
20913: LD_INT 2
20915: ARRAY
20916: GREATEREQUAL
20917: AND
20918: PUSH
20919: LD_VAR 0 3
20923: PPUSH
20924: LD_INT 3
20926: PPUSH
20927: CALL_OW 275
20931: PUSH
20932: LD_VAR 0 4
20936: PUSH
20937: LD_INT 3
20939: ARRAY
20940: GREATEREQUAL
20941: AND
20942: ST_TO_ADDR
// end ;
20943: LD_VAR 0 2
20947: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
20948: LD_INT 0
20950: PPUSH
20951: PPUSH
20952: PPUSH
// pom := GetBase ( building ) ;
20953: LD_ADDR_VAR 0 4
20957: PUSH
20958: LD_VAR 0 1
20962: PPUSH
20963: CALL_OW 274
20967: ST_TO_ADDR
// if not pom then
20968: LD_VAR 0 4
20972: NOT
20973: IFFALSE 20977
// exit ;
20975: GO 21078
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20977: LD_ADDR_VAR 0 5
20981: PUSH
20982: LD_VAR 0 2
20986: PPUSH
20987: LD_VAR 0 1
20991: PPUSH
20992: CALL_OW 248
20996: PPUSH
20997: CALL_OW 450
21001: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21002: LD_ADDR_VAR 0 3
21006: PUSH
21007: LD_VAR 0 4
21011: PPUSH
21012: LD_INT 1
21014: PPUSH
21015: CALL_OW 275
21019: PUSH
21020: LD_VAR 0 5
21024: PUSH
21025: LD_INT 1
21027: ARRAY
21028: GREATEREQUAL
21029: PUSH
21030: LD_VAR 0 4
21034: PPUSH
21035: LD_INT 2
21037: PPUSH
21038: CALL_OW 275
21042: PUSH
21043: LD_VAR 0 5
21047: PUSH
21048: LD_INT 2
21050: ARRAY
21051: GREATEREQUAL
21052: AND
21053: PUSH
21054: LD_VAR 0 4
21058: PPUSH
21059: LD_INT 3
21061: PPUSH
21062: CALL_OW 275
21066: PUSH
21067: LD_VAR 0 5
21071: PUSH
21072: LD_INT 3
21074: ARRAY
21075: GREATEREQUAL
21076: AND
21077: ST_TO_ADDR
// end ;
21078: LD_VAR 0 3
21082: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
21083: LD_INT 0
21085: PPUSH
21086: PPUSH
21087: PPUSH
21088: PPUSH
21089: PPUSH
21090: PPUSH
21091: PPUSH
21092: PPUSH
21093: PPUSH
21094: PPUSH
// result := false ;
21095: LD_ADDR_VAR 0 6
21099: PUSH
21100: LD_INT 0
21102: ST_TO_ADDR
// if not base or not btype or not x or not y then
21103: LD_VAR 0 1
21107: NOT
21108: PUSH
21109: LD_VAR 0 2
21113: NOT
21114: OR
21115: PUSH
21116: LD_VAR 0 3
21120: NOT
21121: OR
21122: PUSH
21123: LD_VAR 0 4
21127: NOT
21128: OR
21129: IFFALSE 21133
// exit ;
21131: GO 21742
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
21133: LD_ADDR_VAR 0 12
21137: PUSH
21138: LD_VAR 0 2
21142: PPUSH
21143: LD_VAR 0 3
21147: PPUSH
21148: LD_VAR 0 4
21152: PPUSH
21153: LD_VAR 0 5
21157: PPUSH
21158: LD_VAR 0 1
21162: PUSH
21163: LD_INT 1
21165: ARRAY
21166: PPUSH
21167: CALL_OW 248
21171: PPUSH
21172: LD_INT 0
21174: PPUSH
21175: CALL 22579 0 6
21179: ST_TO_ADDR
// if not hexes then
21180: LD_VAR 0 12
21184: NOT
21185: IFFALSE 21189
// exit ;
21187: GO 21742
// for i = 1 to hexes do
21189: LD_ADDR_VAR 0 7
21193: PUSH
21194: DOUBLE
21195: LD_INT 1
21197: DEC
21198: ST_TO_ADDR
21199: LD_VAR 0 12
21203: PUSH
21204: FOR_TO
21205: IFFALSE 21740
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21207: LD_ADDR_VAR 0 11
21211: PUSH
21212: LD_VAR 0 12
21216: PUSH
21217: LD_VAR 0 7
21221: ARRAY
21222: PUSH
21223: LD_INT 1
21225: ARRAY
21226: PPUSH
21227: LD_VAR 0 12
21231: PUSH
21232: LD_VAR 0 7
21236: ARRAY
21237: PUSH
21238: LD_INT 2
21240: ARRAY
21241: PPUSH
21242: CALL_OW 428
21246: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21247: LD_VAR 0 12
21251: PUSH
21252: LD_VAR 0 7
21256: ARRAY
21257: PUSH
21258: LD_INT 1
21260: ARRAY
21261: PPUSH
21262: LD_VAR 0 12
21266: PUSH
21267: LD_VAR 0 7
21271: ARRAY
21272: PUSH
21273: LD_INT 2
21275: ARRAY
21276: PPUSH
21277: CALL_OW 351
21281: PUSH
21282: LD_VAR 0 12
21286: PUSH
21287: LD_VAR 0 7
21291: ARRAY
21292: PUSH
21293: LD_INT 1
21295: ARRAY
21296: PPUSH
21297: LD_VAR 0 12
21301: PUSH
21302: LD_VAR 0 7
21306: ARRAY
21307: PUSH
21308: LD_INT 2
21310: ARRAY
21311: PPUSH
21312: CALL_OW 488
21316: NOT
21317: OR
21318: PUSH
21319: LD_VAR 0 11
21323: PPUSH
21324: CALL_OW 247
21328: PUSH
21329: LD_INT 3
21331: EQUAL
21332: OR
21333: IFFALSE 21339
// exit ;
21335: POP
21336: POP
21337: GO 21742
// if not tmp or not tmp in base then
21339: LD_VAR 0 11
21343: NOT
21344: PUSH
21345: LD_VAR 0 11
21349: PUSH
21350: LD_VAR 0 1
21354: IN
21355: NOT
21356: OR
21357: IFFALSE 21361
// continue ;
21359: GO 21204
// result := true ;
21361: LD_ADDR_VAR 0 6
21365: PUSH
21366: LD_INT 1
21368: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21369: LD_ADDR_VAR 0 15
21373: PUSH
21374: LD_VAR 0 1
21378: PPUSH
21379: LD_INT 22
21381: PUSH
21382: LD_VAR 0 11
21386: PPUSH
21387: CALL_OW 255
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: PUSH
21396: LD_INT 2
21398: PUSH
21399: LD_INT 30
21401: PUSH
21402: LD_INT 0
21404: PUSH
21405: EMPTY
21406: LIST
21407: LIST
21408: PUSH
21409: LD_INT 30
21411: PUSH
21412: LD_INT 1
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: EMPTY
21420: LIST
21421: LIST
21422: LIST
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PPUSH
21428: CALL_OW 72
21432: ST_TO_ADDR
// if dep then
21433: LD_VAR 0 15
21437: IFFALSE 21573
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
21439: LD_ADDR_VAR 0 14
21443: PUSH
21444: LD_VAR 0 15
21448: PUSH
21449: LD_INT 1
21451: ARRAY
21452: PPUSH
21453: CALL_OW 250
21457: PPUSH
21458: LD_VAR 0 15
21462: PUSH
21463: LD_INT 1
21465: ARRAY
21466: PPUSH
21467: CALL_OW 254
21471: PPUSH
21472: LD_INT 5
21474: PPUSH
21475: CALL_OW 272
21479: PUSH
21480: LD_VAR 0 15
21484: PUSH
21485: LD_INT 1
21487: ARRAY
21488: PPUSH
21489: CALL_OW 251
21493: PPUSH
21494: LD_VAR 0 15
21498: PUSH
21499: LD_INT 1
21501: ARRAY
21502: PPUSH
21503: CALL_OW 254
21507: PPUSH
21508: LD_INT 5
21510: PPUSH
21511: CALL_OW 273
21515: PUSH
21516: EMPTY
21517: LIST
21518: LIST
21519: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
21520: LD_VAR 0 14
21524: PUSH
21525: LD_INT 1
21527: ARRAY
21528: PPUSH
21529: LD_VAR 0 14
21533: PUSH
21534: LD_INT 2
21536: ARRAY
21537: PPUSH
21538: CALL_OW 488
21542: IFFALSE 21573
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
21544: LD_VAR 0 11
21548: PPUSH
21549: LD_VAR 0 14
21553: PUSH
21554: LD_INT 1
21556: ARRAY
21557: PPUSH
21558: LD_VAR 0 14
21562: PUSH
21563: LD_INT 2
21565: ARRAY
21566: PPUSH
21567: CALL_OW 111
// continue ;
21571: GO 21204
// end ; end ; r := GetDir ( tmp ) ;
21573: LD_ADDR_VAR 0 13
21577: PUSH
21578: LD_VAR 0 11
21582: PPUSH
21583: CALL_OW 254
21587: ST_TO_ADDR
// if r = 5 then
21588: LD_VAR 0 13
21592: PUSH
21593: LD_INT 5
21595: EQUAL
21596: IFFALSE 21606
// r := 0 ;
21598: LD_ADDR_VAR 0 13
21602: PUSH
21603: LD_INT 0
21605: ST_TO_ADDR
// for j = r to 5 do
21606: LD_ADDR_VAR 0 8
21610: PUSH
21611: DOUBLE
21612: LD_VAR 0 13
21616: DEC
21617: ST_TO_ADDR
21618: LD_INT 5
21620: PUSH
21621: FOR_TO
21622: IFFALSE 21736
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
21624: LD_ADDR_VAR 0 9
21628: PUSH
21629: LD_VAR 0 11
21633: PPUSH
21634: CALL_OW 250
21638: PPUSH
21639: LD_VAR 0 8
21643: PPUSH
21644: LD_INT 2
21646: PPUSH
21647: CALL_OW 272
21651: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
21652: LD_ADDR_VAR 0 10
21656: PUSH
21657: LD_VAR 0 11
21661: PPUSH
21662: CALL_OW 251
21666: PPUSH
21667: LD_VAR 0 8
21671: PPUSH
21672: LD_INT 2
21674: PPUSH
21675: CALL_OW 273
21679: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
21680: LD_VAR 0 9
21684: PPUSH
21685: LD_VAR 0 10
21689: PPUSH
21690: CALL_OW 488
21694: PUSH
21695: LD_VAR 0 9
21699: PPUSH
21700: LD_VAR 0 10
21704: PPUSH
21705: CALL_OW 428
21709: NOT
21710: AND
21711: IFFALSE 21734
// begin ComMoveXY ( tmp , _x , _y ) ;
21713: LD_VAR 0 11
21717: PPUSH
21718: LD_VAR 0 9
21722: PPUSH
21723: LD_VAR 0 10
21727: PPUSH
21728: CALL_OW 111
// break ;
21732: GO 21736
// end ; end ;
21734: GO 21621
21736: POP
21737: POP
// end ;
21738: GO 21204
21740: POP
21741: POP
// end ;
21742: LD_VAR 0 6
21746: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
21747: LD_INT 0
21749: PPUSH
21750: PPUSH
21751: PPUSH
21752: PPUSH
21753: PPUSH
21754: PPUSH
21755: PPUSH
21756: PPUSH
21757: PPUSH
21758: PPUSH
// result := false ;
21759: LD_ADDR_VAR 0 6
21763: PUSH
21764: LD_INT 0
21766: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
21767: LD_VAR 0 1
21771: NOT
21772: PUSH
21773: LD_VAR 0 1
21777: PPUSH
21778: CALL_OW 266
21782: PUSH
21783: LD_INT 0
21785: PUSH
21786: LD_INT 1
21788: PUSH
21789: EMPTY
21790: LIST
21791: LIST
21792: IN
21793: NOT
21794: OR
21795: PUSH
21796: LD_VAR 0 2
21800: NOT
21801: OR
21802: PUSH
21803: LD_VAR 0 5
21807: PUSH
21808: LD_INT 0
21810: PUSH
21811: LD_INT 1
21813: PUSH
21814: LD_INT 2
21816: PUSH
21817: LD_INT 3
21819: PUSH
21820: LD_INT 4
21822: PUSH
21823: LD_INT 5
21825: PUSH
21826: EMPTY
21827: LIST
21828: LIST
21829: LIST
21830: LIST
21831: LIST
21832: LIST
21833: IN
21834: NOT
21835: OR
21836: PUSH
21837: LD_VAR 0 3
21841: PPUSH
21842: LD_VAR 0 4
21846: PPUSH
21847: CALL_OW 488
21851: NOT
21852: OR
21853: IFFALSE 21857
// exit ;
21855: GO 22574
// pom := GetBase ( depot ) ;
21857: LD_ADDR_VAR 0 10
21861: PUSH
21862: LD_VAR 0 1
21866: PPUSH
21867: CALL_OW 274
21871: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
21872: LD_ADDR_VAR 0 11
21876: PUSH
21877: LD_VAR 0 2
21881: PPUSH
21882: LD_VAR 0 1
21886: PPUSH
21887: CALL_OW 248
21891: PPUSH
21892: CALL_OW 450
21896: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
21897: LD_VAR 0 10
21901: PPUSH
21902: LD_INT 1
21904: PPUSH
21905: CALL_OW 275
21909: PUSH
21910: LD_VAR 0 11
21914: PUSH
21915: LD_INT 1
21917: ARRAY
21918: GREATEREQUAL
21919: PUSH
21920: LD_VAR 0 10
21924: PPUSH
21925: LD_INT 2
21927: PPUSH
21928: CALL_OW 275
21932: PUSH
21933: LD_VAR 0 11
21937: PUSH
21938: LD_INT 2
21940: ARRAY
21941: GREATEREQUAL
21942: AND
21943: PUSH
21944: LD_VAR 0 10
21948: PPUSH
21949: LD_INT 3
21951: PPUSH
21952: CALL_OW 275
21956: PUSH
21957: LD_VAR 0 11
21961: PUSH
21962: LD_INT 3
21964: ARRAY
21965: GREATEREQUAL
21966: AND
21967: NOT
21968: IFFALSE 21972
// exit ;
21970: GO 22574
// if GetBType ( depot ) = b_depot then
21972: LD_VAR 0 1
21976: PPUSH
21977: CALL_OW 266
21981: PUSH
21982: LD_INT 0
21984: EQUAL
21985: IFFALSE 21997
// dist := 28 else
21987: LD_ADDR_VAR 0 14
21991: PUSH
21992: LD_INT 28
21994: ST_TO_ADDR
21995: GO 22005
// dist := 36 ;
21997: LD_ADDR_VAR 0 14
22001: PUSH
22002: LD_INT 36
22004: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
22005: LD_VAR 0 1
22009: PPUSH
22010: LD_VAR 0 3
22014: PPUSH
22015: LD_VAR 0 4
22019: PPUSH
22020: CALL_OW 297
22024: PUSH
22025: LD_VAR 0 14
22029: GREATER
22030: IFFALSE 22034
// exit ;
22032: GO 22574
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
22034: LD_ADDR_VAR 0 12
22038: PUSH
22039: LD_VAR 0 2
22043: PPUSH
22044: LD_VAR 0 3
22048: PPUSH
22049: LD_VAR 0 4
22053: PPUSH
22054: LD_VAR 0 5
22058: PPUSH
22059: LD_VAR 0 1
22063: PPUSH
22064: CALL_OW 248
22068: PPUSH
22069: LD_INT 0
22071: PPUSH
22072: CALL 22579 0 6
22076: ST_TO_ADDR
// if not hexes then
22077: LD_VAR 0 12
22081: NOT
22082: IFFALSE 22086
// exit ;
22084: GO 22574
// hex := GetHexInfo ( x , y ) ;
22086: LD_ADDR_VAR 0 15
22090: PUSH
22091: LD_VAR 0 3
22095: PPUSH
22096: LD_VAR 0 4
22100: PPUSH
22101: CALL_OW 546
22105: ST_TO_ADDR
// if hex [ 1 ] then
22106: LD_VAR 0 15
22110: PUSH
22111: LD_INT 1
22113: ARRAY
22114: IFFALSE 22118
// exit ;
22116: GO 22574
// height := hex [ 2 ] ;
22118: LD_ADDR_VAR 0 13
22122: PUSH
22123: LD_VAR 0 15
22127: PUSH
22128: LD_INT 2
22130: ARRAY
22131: ST_TO_ADDR
// for i = 1 to hexes do
22132: LD_ADDR_VAR 0 7
22136: PUSH
22137: DOUBLE
22138: LD_INT 1
22140: DEC
22141: ST_TO_ADDR
22142: LD_VAR 0 12
22146: PUSH
22147: FOR_TO
22148: IFFALSE 22478
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
22150: LD_VAR 0 12
22154: PUSH
22155: LD_VAR 0 7
22159: ARRAY
22160: PUSH
22161: LD_INT 1
22163: ARRAY
22164: PPUSH
22165: LD_VAR 0 12
22169: PUSH
22170: LD_VAR 0 7
22174: ARRAY
22175: PUSH
22176: LD_INT 2
22178: ARRAY
22179: PPUSH
22180: CALL_OW 488
22184: NOT
22185: PUSH
22186: LD_VAR 0 12
22190: PUSH
22191: LD_VAR 0 7
22195: ARRAY
22196: PUSH
22197: LD_INT 1
22199: ARRAY
22200: PPUSH
22201: LD_VAR 0 12
22205: PUSH
22206: LD_VAR 0 7
22210: ARRAY
22211: PUSH
22212: LD_INT 2
22214: ARRAY
22215: PPUSH
22216: CALL_OW 428
22220: PUSH
22221: LD_INT 0
22223: GREATER
22224: OR
22225: PUSH
22226: LD_VAR 0 12
22230: PUSH
22231: LD_VAR 0 7
22235: ARRAY
22236: PUSH
22237: LD_INT 1
22239: ARRAY
22240: PPUSH
22241: LD_VAR 0 12
22245: PUSH
22246: LD_VAR 0 7
22250: ARRAY
22251: PUSH
22252: LD_INT 2
22254: ARRAY
22255: PPUSH
22256: CALL_OW 351
22260: OR
22261: IFFALSE 22267
// exit ;
22263: POP
22264: POP
22265: GO 22574
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22267: LD_ADDR_VAR 0 8
22271: PUSH
22272: LD_VAR 0 12
22276: PUSH
22277: LD_VAR 0 7
22281: ARRAY
22282: PUSH
22283: LD_INT 1
22285: ARRAY
22286: PPUSH
22287: LD_VAR 0 12
22291: PUSH
22292: LD_VAR 0 7
22296: ARRAY
22297: PUSH
22298: LD_INT 2
22300: ARRAY
22301: PPUSH
22302: CALL_OW 546
22306: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
22307: LD_VAR 0 8
22311: PUSH
22312: LD_INT 1
22314: ARRAY
22315: PUSH
22316: LD_VAR 0 8
22320: PUSH
22321: LD_INT 2
22323: ARRAY
22324: PUSH
22325: LD_VAR 0 13
22329: PUSH
22330: LD_INT 2
22332: PLUS
22333: GREATER
22334: OR
22335: PUSH
22336: LD_VAR 0 8
22340: PUSH
22341: LD_INT 2
22343: ARRAY
22344: PUSH
22345: LD_VAR 0 13
22349: PUSH
22350: LD_INT 2
22352: MINUS
22353: LESS
22354: OR
22355: PUSH
22356: LD_VAR 0 8
22360: PUSH
22361: LD_INT 3
22363: ARRAY
22364: PUSH
22365: LD_INT 0
22367: PUSH
22368: LD_INT 8
22370: PUSH
22371: LD_INT 9
22373: PUSH
22374: LD_INT 10
22376: PUSH
22377: LD_INT 11
22379: PUSH
22380: LD_INT 12
22382: PUSH
22383: LD_INT 13
22385: PUSH
22386: LD_INT 16
22388: PUSH
22389: LD_INT 17
22391: PUSH
22392: LD_INT 18
22394: PUSH
22395: LD_INT 19
22397: PUSH
22398: LD_INT 20
22400: PUSH
22401: LD_INT 21
22403: PUSH
22404: EMPTY
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: LIST
22410: LIST
22411: LIST
22412: LIST
22413: LIST
22414: LIST
22415: LIST
22416: LIST
22417: LIST
22418: IN
22419: NOT
22420: OR
22421: PUSH
22422: LD_VAR 0 8
22426: PUSH
22427: LD_INT 5
22429: ARRAY
22430: NOT
22431: OR
22432: PUSH
22433: LD_VAR 0 8
22437: PUSH
22438: LD_INT 6
22440: ARRAY
22441: PUSH
22442: LD_INT 1
22444: PUSH
22445: LD_INT 2
22447: PUSH
22448: LD_INT 7
22450: PUSH
22451: LD_INT 9
22453: PUSH
22454: LD_INT 10
22456: PUSH
22457: LD_INT 11
22459: PUSH
22460: EMPTY
22461: LIST
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: LIST
22467: IN
22468: NOT
22469: OR
22470: IFFALSE 22476
// exit ;
22472: POP
22473: POP
22474: GO 22574
// end ;
22476: GO 22147
22478: POP
22479: POP
// side := GetSide ( depot ) ;
22480: LD_ADDR_VAR 0 9
22484: PUSH
22485: LD_VAR 0 1
22489: PPUSH
22490: CALL_OW 255
22494: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
22495: LD_VAR 0 9
22499: PPUSH
22500: LD_VAR 0 3
22504: PPUSH
22505: LD_VAR 0 4
22509: PPUSH
22510: LD_INT 20
22512: PPUSH
22513: CALL 15228 0 4
22517: PUSH
22518: LD_INT 4
22520: ARRAY
22521: IFFALSE 22525
// exit ;
22523: GO 22574
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
22525: LD_VAR 0 2
22529: PUSH
22530: LD_INT 29
22532: PUSH
22533: LD_INT 30
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: IN
22540: PUSH
22541: LD_VAR 0 3
22545: PPUSH
22546: LD_VAR 0 4
22550: PPUSH
22551: LD_VAR 0 9
22555: PPUSH
22556: CALL_OW 440
22560: NOT
22561: AND
22562: IFFALSE 22566
// exit ;
22564: GO 22574
// result := true ;
22566: LD_ADDR_VAR 0 6
22570: PUSH
22571: LD_INT 1
22573: ST_TO_ADDR
// end ;
22574: LD_VAR 0 6
22578: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
22579: LD_INT 0
22581: PPUSH
22582: PPUSH
22583: PPUSH
22584: PPUSH
22585: PPUSH
22586: PPUSH
22587: PPUSH
22588: PPUSH
22589: PPUSH
22590: PPUSH
22591: PPUSH
22592: PPUSH
22593: PPUSH
22594: PPUSH
22595: PPUSH
22596: PPUSH
22597: PPUSH
22598: PPUSH
22599: PPUSH
22600: PPUSH
22601: PPUSH
22602: PPUSH
22603: PPUSH
22604: PPUSH
22605: PPUSH
22606: PPUSH
22607: PPUSH
22608: PPUSH
22609: PPUSH
22610: PPUSH
22611: PPUSH
22612: PPUSH
22613: PPUSH
22614: PPUSH
22615: PPUSH
22616: PPUSH
22617: PPUSH
22618: PPUSH
22619: PPUSH
22620: PPUSH
22621: PPUSH
22622: PPUSH
22623: PPUSH
22624: PPUSH
22625: PPUSH
22626: PPUSH
22627: PPUSH
22628: PPUSH
22629: PPUSH
22630: PPUSH
22631: PPUSH
22632: PPUSH
22633: PPUSH
22634: PPUSH
22635: PPUSH
22636: PPUSH
22637: PPUSH
22638: PPUSH
// result = [ ] ;
22639: LD_ADDR_VAR 0 7
22643: PUSH
22644: EMPTY
22645: ST_TO_ADDR
// temp_list = [ ] ;
22646: LD_ADDR_VAR 0 9
22650: PUSH
22651: EMPTY
22652: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
22653: LD_VAR 0 4
22657: PUSH
22658: LD_INT 0
22660: PUSH
22661: LD_INT 1
22663: PUSH
22664: LD_INT 2
22666: PUSH
22667: LD_INT 3
22669: PUSH
22670: LD_INT 4
22672: PUSH
22673: LD_INT 5
22675: PUSH
22676: EMPTY
22677: LIST
22678: LIST
22679: LIST
22680: LIST
22681: LIST
22682: LIST
22683: IN
22684: NOT
22685: PUSH
22686: LD_VAR 0 1
22690: PUSH
22691: LD_INT 0
22693: PUSH
22694: LD_INT 1
22696: PUSH
22697: EMPTY
22698: LIST
22699: LIST
22700: IN
22701: PUSH
22702: LD_VAR 0 5
22706: PUSH
22707: LD_INT 1
22709: PUSH
22710: LD_INT 2
22712: PUSH
22713: LD_INT 3
22715: PUSH
22716: EMPTY
22717: LIST
22718: LIST
22719: LIST
22720: IN
22721: NOT
22722: AND
22723: OR
22724: IFFALSE 22728
// exit ;
22726: GO 41119
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
22728: LD_VAR 0 1
22732: PUSH
22733: LD_INT 6
22735: PUSH
22736: LD_INT 7
22738: PUSH
22739: LD_INT 8
22741: PUSH
22742: LD_INT 13
22744: PUSH
22745: LD_INT 12
22747: PUSH
22748: LD_INT 15
22750: PUSH
22751: LD_INT 11
22753: PUSH
22754: LD_INT 14
22756: PUSH
22757: LD_INT 10
22759: PUSH
22760: EMPTY
22761: LIST
22762: LIST
22763: LIST
22764: LIST
22765: LIST
22766: LIST
22767: LIST
22768: LIST
22769: LIST
22770: IN
22771: IFFALSE 22781
// btype = b_lab ;
22773: LD_ADDR_VAR 0 1
22777: PUSH
22778: LD_INT 6
22780: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
22781: LD_VAR 0 6
22785: PUSH
22786: LD_INT 0
22788: PUSH
22789: LD_INT 1
22791: PUSH
22792: LD_INT 2
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: LIST
22799: IN
22800: NOT
22801: PUSH
22802: LD_VAR 0 1
22806: PUSH
22807: LD_INT 0
22809: PUSH
22810: LD_INT 1
22812: PUSH
22813: LD_INT 2
22815: PUSH
22816: LD_INT 3
22818: PUSH
22819: LD_INT 6
22821: PUSH
22822: LD_INT 36
22824: PUSH
22825: LD_INT 4
22827: PUSH
22828: LD_INT 5
22830: PUSH
22831: LD_INT 31
22833: PUSH
22834: LD_INT 32
22836: PUSH
22837: LD_INT 33
22839: PUSH
22840: EMPTY
22841: LIST
22842: LIST
22843: LIST
22844: LIST
22845: LIST
22846: LIST
22847: LIST
22848: LIST
22849: LIST
22850: LIST
22851: LIST
22852: IN
22853: NOT
22854: PUSH
22855: LD_VAR 0 6
22859: PUSH
22860: LD_INT 1
22862: EQUAL
22863: AND
22864: OR
22865: PUSH
22866: LD_VAR 0 1
22870: PUSH
22871: LD_INT 2
22873: PUSH
22874: LD_INT 3
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: IN
22881: NOT
22882: PUSH
22883: LD_VAR 0 6
22887: PUSH
22888: LD_INT 2
22890: EQUAL
22891: AND
22892: OR
22893: IFFALSE 22903
// mode = 0 ;
22895: LD_ADDR_VAR 0 6
22899: PUSH
22900: LD_INT 0
22902: ST_TO_ADDR
// case mode of 0 :
22903: LD_VAR 0 6
22907: PUSH
22908: LD_INT 0
22910: DOUBLE
22911: EQUAL
22912: IFTRUE 22916
22914: GO 34369
22916: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
22917: LD_ADDR_VAR 0 11
22921: PUSH
22922: LD_INT 0
22924: PUSH
22925: LD_INT 0
22927: PUSH
22928: EMPTY
22929: LIST
22930: LIST
22931: PUSH
22932: LD_INT 0
22934: PUSH
22935: LD_INT 1
22937: NEG
22938: PUSH
22939: EMPTY
22940: LIST
22941: LIST
22942: PUSH
22943: LD_INT 1
22945: PUSH
22946: LD_INT 0
22948: PUSH
22949: EMPTY
22950: LIST
22951: LIST
22952: PUSH
22953: LD_INT 1
22955: PUSH
22956: LD_INT 1
22958: PUSH
22959: EMPTY
22960: LIST
22961: LIST
22962: PUSH
22963: LD_INT 0
22965: PUSH
22966: LD_INT 1
22968: PUSH
22969: EMPTY
22970: LIST
22971: LIST
22972: PUSH
22973: LD_INT 1
22975: NEG
22976: PUSH
22977: LD_INT 0
22979: PUSH
22980: EMPTY
22981: LIST
22982: LIST
22983: PUSH
22984: LD_INT 1
22986: NEG
22987: PUSH
22988: LD_INT 1
22990: NEG
22991: PUSH
22992: EMPTY
22993: LIST
22994: LIST
22995: PUSH
22996: LD_INT 1
22998: NEG
22999: PUSH
23000: LD_INT 2
23002: NEG
23003: PUSH
23004: EMPTY
23005: LIST
23006: LIST
23007: PUSH
23008: LD_INT 0
23010: PUSH
23011: LD_INT 2
23013: NEG
23014: PUSH
23015: EMPTY
23016: LIST
23017: LIST
23018: PUSH
23019: LD_INT 1
23021: PUSH
23022: LD_INT 1
23024: NEG
23025: PUSH
23026: EMPTY
23027: LIST
23028: LIST
23029: PUSH
23030: LD_INT 1
23032: PUSH
23033: LD_INT 2
23035: PUSH
23036: EMPTY
23037: LIST
23038: LIST
23039: PUSH
23040: LD_INT 0
23042: PUSH
23043: LD_INT 2
23045: PUSH
23046: EMPTY
23047: LIST
23048: LIST
23049: PUSH
23050: LD_INT 1
23052: NEG
23053: PUSH
23054: LD_INT 1
23056: PUSH
23057: EMPTY
23058: LIST
23059: LIST
23060: PUSH
23061: LD_INT 1
23063: PUSH
23064: LD_INT 3
23066: PUSH
23067: EMPTY
23068: LIST
23069: LIST
23070: PUSH
23071: LD_INT 0
23073: PUSH
23074: LD_INT 3
23076: PUSH
23077: EMPTY
23078: LIST
23079: LIST
23080: PUSH
23081: LD_INT 1
23083: NEG
23084: PUSH
23085: LD_INT 2
23087: PUSH
23088: EMPTY
23089: LIST
23090: LIST
23091: PUSH
23092: EMPTY
23093: LIST
23094: LIST
23095: LIST
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: LIST
23107: LIST
23108: LIST
23109: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
23110: LD_ADDR_VAR 0 12
23114: PUSH
23115: LD_INT 0
23117: PUSH
23118: LD_INT 0
23120: PUSH
23121: EMPTY
23122: LIST
23123: LIST
23124: PUSH
23125: LD_INT 0
23127: PUSH
23128: LD_INT 1
23130: NEG
23131: PUSH
23132: EMPTY
23133: LIST
23134: LIST
23135: PUSH
23136: LD_INT 1
23138: PUSH
23139: LD_INT 0
23141: PUSH
23142: EMPTY
23143: LIST
23144: LIST
23145: PUSH
23146: LD_INT 1
23148: PUSH
23149: LD_INT 1
23151: PUSH
23152: EMPTY
23153: LIST
23154: LIST
23155: PUSH
23156: LD_INT 0
23158: PUSH
23159: LD_INT 1
23161: PUSH
23162: EMPTY
23163: LIST
23164: LIST
23165: PUSH
23166: LD_INT 1
23168: NEG
23169: PUSH
23170: LD_INT 0
23172: PUSH
23173: EMPTY
23174: LIST
23175: LIST
23176: PUSH
23177: LD_INT 1
23179: NEG
23180: PUSH
23181: LD_INT 1
23183: NEG
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: PUSH
23189: LD_INT 1
23191: PUSH
23192: LD_INT 1
23194: NEG
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: PUSH
23200: LD_INT 2
23202: PUSH
23203: LD_INT 0
23205: PUSH
23206: EMPTY
23207: LIST
23208: LIST
23209: PUSH
23210: LD_INT 2
23212: PUSH
23213: LD_INT 1
23215: PUSH
23216: EMPTY
23217: LIST
23218: LIST
23219: PUSH
23220: LD_INT 1
23222: NEG
23223: PUSH
23224: LD_INT 1
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: PUSH
23231: LD_INT 2
23233: NEG
23234: PUSH
23235: LD_INT 0
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: PUSH
23242: LD_INT 2
23244: NEG
23245: PUSH
23246: LD_INT 1
23248: NEG
23249: PUSH
23250: EMPTY
23251: LIST
23252: LIST
23253: PUSH
23254: LD_INT 2
23256: NEG
23257: PUSH
23258: LD_INT 1
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PUSH
23265: LD_INT 3
23267: NEG
23268: PUSH
23269: LD_INT 0
23271: PUSH
23272: EMPTY
23273: LIST
23274: LIST
23275: PUSH
23276: LD_INT 3
23278: NEG
23279: PUSH
23280: LD_INT 1
23282: NEG
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: PUSH
23288: EMPTY
23289: LIST
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: LIST
23295: LIST
23296: LIST
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: LIST
23302: LIST
23303: LIST
23304: LIST
23305: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
23306: LD_ADDR_VAR 0 13
23310: PUSH
23311: LD_INT 0
23313: PUSH
23314: LD_INT 0
23316: PUSH
23317: EMPTY
23318: LIST
23319: LIST
23320: PUSH
23321: LD_INT 0
23323: PUSH
23324: LD_INT 1
23326: NEG
23327: PUSH
23328: EMPTY
23329: LIST
23330: LIST
23331: PUSH
23332: LD_INT 1
23334: PUSH
23335: LD_INT 0
23337: PUSH
23338: EMPTY
23339: LIST
23340: LIST
23341: PUSH
23342: LD_INT 1
23344: PUSH
23345: LD_INT 1
23347: PUSH
23348: EMPTY
23349: LIST
23350: LIST
23351: PUSH
23352: LD_INT 0
23354: PUSH
23355: LD_INT 1
23357: PUSH
23358: EMPTY
23359: LIST
23360: LIST
23361: PUSH
23362: LD_INT 1
23364: NEG
23365: PUSH
23366: LD_INT 0
23368: PUSH
23369: EMPTY
23370: LIST
23371: LIST
23372: PUSH
23373: LD_INT 1
23375: NEG
23376: PUSH
23377: LD_INT 1
23379: NEG
23380: PUSH
23381: EMPTY
23382: LIST
23383: LIST
23384: PUSH
23385: LD_INT 1
23387: NEG
23388: PUSH
23389: LD_INT 2
23391: NEG
23392: PUSH
23393: EMPTY
23394: LIST
23395: LIST
23396: PUSH
23397: LD_INT 2
23399: PUSH
23400: LD_INT 1
23402: PUSH
23403: EMPTY
23404: LIST
23405: LIST
23406: PUSH
23407: LD_INT 2
23409: PUSH
23410: LD_INT 2
23412: PUSH
23413: EMPTY
23414: LIST
23415: LIST
23416: PUSH
23417: LD_INT 1
23419: PUSH
23420: LD_INT 2
23422: PUSH
23423: EMPTY
23424: LIST
23425: LIST
23426: PUSH
23427: LD_INT 2
23429: NEG
23430: PUSH
23431: LD_INT 1
23433: NEG
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: PUSH
23439: LD_INT 2
23441: NEG
23442: PUSH
23443: LD_INT 2
23445: NEG
23446: PUSH
23447: EMPTY
23448: LIST
23449: LIST
23450: PUSH
23451: LD_INT 2
23453: NEG
23454: PUSH
23455: LD_INT 3
23457: NEG
23458: PUSH
23459: EMPTY
23460: LIST
23461: LIST
23462: PUSH
23463: LD_INT 3
23465: NEG
23466: PUSH
23467: LD_INT 2
23469: NEG
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: LD_INT 3
23477: NEG
23478: PUSH
23479: LD_INT 3
23481: NEG
23482: PUSH
23483: EMPTY
23484: LIST
23485: LIST
23486: PUSH
23487: EMPTY
23488: LIST
23489: LIST
23490: LIST
23491: LIST
23492: LIST
23493: LIST
23494: LIST
23495: LIST
23496: LIST
23497: LIST
23498: LIST
23499: LIST
23500: LIST
23501: LIST
23502: LIST
23503: LIST
23504: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
23505: LD_ADDR_VAR 0 14
23509: PUSH
23510: LD_INT 0
23512: PUSH
23513: LD_INT 0
23515: PUSH
23516: EMPTY
23517: LIST
23518: LIST
23519: PUSH
23520: LD_INT 0
23522: PUSH
23523: LD_INT 1
23525: NEG
23526: PUSH
23527: EMPTY
23528: LIST
23529: LIST
23530: PUSH
23531: LD_INT 1
23533: PUSH
23534: LD_INT 0
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: PUSH
23541: LD_INT 1
23543: PUSH
23544: LD_INT 1
23546: PUSH
23547: EMPTY
23548: LIST
23549: LIST
23550: PUSH
23551: LD_INT 0
23553: PUSH
23554: LD_INT 1
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: PUSH
23561: LD_INT 1
23563: NEG
23564: PUSH
23565: LD_INT 0
23567: PUSH
23568: EMPTY
23569: LIST
23570: LIST
23571: PUSH
23572: LD_INT 1
23574: NEG
23575: PUSH
23576: LD_INT 1
23578: NEG
23579: PUSH
23580: EMPTY
23581: LIST
23582: LIST
23583: PUSH
23584: LD_INT 1
23586: NEG
23587: PUSH
23588: LD_INT 2
23590: NEG
23591: PUSH
23592: EMPTY
23593: LIST
23594: LIST
23595: PUSH
23596: LD_INT 0
23598: PUSH
23599: LD_INT 2
23601: NEG
23602: PUSH
23603: EMPTY
23604: LIST
23605: LIST
23606: PUSH
23607: LD_INT 1
23609: PUSH
23610: LD_INT 1
23612: NEG
23613: PUSH
23614: EMPTY
23615: LIST
23616: LIST
23617: PUSH
23618: LD_INT 1
23620: PUSH
23621: LD_INT 2
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: PUSH
23628: LD_INT 0
23630: PUSH
23631: LD_INT 2
23633: PUSH
23634: EMPTY
23635: LIST
23636: LIST
23637: PUSH
23638: LD_INT 1
23640: NEG
23641: PUSH
23642: LD_INT 1
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PUSH
23649: LD_INT 1
23651: NEG
23652: PUSH
23653: LD_INT 3
23655: NEG
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: PUSH
23661: LD_INT 0
23663: PUSH
23664: LD_INT 3
23666: NEG
23667: PUSH
23668: EMPTY
23669: LIST
23670: LIST
23671: PUSH
23672: LD_INT 1
23674: PUSH
23675: LD_INT 2
23677: NEG
23678: PUSH
23679: EMPTY
23680: LIST
23681: LIST
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: LIST
23687: LIST
23688: LIST
23689: LIST
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: LIST
23695: LIST
23696: LIST
23697: LIST
23698: LIST
23699: LIST
23700: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
23701: LD_ADDR_VAR 0 15
23705: PUSH
23706: LD_INT 0
23708: PUSH
23709: LD_INT 0
23711: PUSH
23712: EMPTY
23713: LIST
23714: LIST
23715: PUSH
23716: LD_INT 0
23718: PUSH
23719: LD_INT 1
23721: NEG
23722: PUSH
23723: EMPTY
23724: LIST
23725: LIST
23726: PUSH
23727: LD_INT 1
23729: PUSH
23730: LD_INT 0
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: PUSH
23737: LD_INT 1
23739: PUSH
23740: LD_INT 1
23742: PUSH
23743: EMPTY
23744: LIST
23745: LIST
23746: PUSH
23747: LD_INT 0
23749: PUSH
23750: LD_INT 1
23752: PUSH
23753: EMPTY
23754: LIST
23755: LIST
23756: PUSH
23757: LD_INT 1
23759: NEG
23760: PUSH
23761: LD_INT 0
23763: PUSH
23764: EMPTY
23765: LIST
23766: LIST
23767: PUSH
23768: LD_INT 1
23770: NEG
23771: PUSH
23772: LD_INT 1
23774: NEG
23775: PUSH
23776: EMPTY
23777: LIST
23778: LIST
23779: PUSH
23780: LD_INT 1
23782: PUSH
23783: LD_INT 1
23785: NEG
23786: PUSH
23787: EMPTY
23788: LIST
23789: LIST
23790: PUSH
23791: LD_INT 2
23793: PUSH
23794: LD_INT 0
23796: PUSH
23797: EMPTY
23798: LIST
23799: LIST
23800: PUSH
23801: LD_INT 2
23803: PUSH
23804: LD_INT 1
23806: PUSH
23807: EMPTY
23808: LIST
23809: LIST
23810: PUSH
23811: LD_INT 1
23813: NEG
23814: PUSH
23815: LD_INT 1
23817: PUSH
23818: EMPTY
23819: LIST
23820: LIST
23821: PUSH
23822: LD_INT 2
23824: NEG
23825: PUSH
23826: LD_INT 0
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: PUSH
23833: LD_INT 2
23835: NEG
23836: PUSH
23837: LD_INT 1
23839: NEG
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: PUSH
23845: LD_INT 2
23847: PUSH
23848: LD_INT 1
23850: NEG
23851: PUSH
23852: EMPTY
23853: LIST
23854: LIST
23855: PUSH
23856: LD_INT 3
23858: PUSH
23859: LD_INT 0
23861: PUSH
23862: EMPTY
23863: LIST
23864: LIST
23865: PUSH
23866: LD_INT 3
23868: PUSH
23869: LD_INT 1
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: EMPTY
23877: LIST
23878: LIST
23879: LIST
23880: LIST
23881: LIST
23882: LIST
23883: LIST
23884: LIST
23885: LIST
23886: LIST
23887: LIST
23888: LIST
23889: LIST
23890: LIST
23891: LIST
23892: LIST
23893: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
23894: LD_ADDR_VAR 0 16
23898: PUSH
23899: LD_INT 0
23901: PUSH
23902: LD_INT 0
23904: PUSH
23905: EMPTY
23906: LIST
23907: LIST
23908: PUSH
23909: LD_INT 0
23911: PUSH
23912: LD_INT 1
23914: NEG
23915: PUSH
23916: EMPTY
23917: LIST
23918: LIST
23919: PUSH
23920: LD_INT 1
23922: PUSH
23923: LD_INT 0
23925: PUSH
23926: EMPTY
23927: LIST
23928: LIST
23929: PUSH
23930: LD_INT 1
23932: PUSH
23933: LD_INT 1
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: PUSH
23940: LD_INT 0
23942: PUSH
23943: LD_INT 1
23945: PUSH
23946: EMPTY
23947: LIST
23948: LIST
23949: PUSH
23950: LD_INT 1
23952: NEG
23953: PUSH
23954: LD_INT 0
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: PUSH
23961: LD_INT 1
23963: NEG
23964: PUSH
23965: LD_INT 1
23967: NEG
23968: PUSH
23969: EMPTY
23970: LIST
23971: LIST
23972: PUSH
23973: LD_INT 1
23975: NEG
23976: PUSH
23977: LD_INT 2
23979: NEG
23980: PUSH
23981: EMPTY
23982: LIST
23983: LIST
23984: PUSH
23985: LD_INT 2
23987: PUSH
23988: LD_INT 1
23990: PUSH
23991: EMPTY
23992: LIST
23993: LIST
23994: PUSH
23995: LD_INT 2
23997: PUSH
23998: LD_INT 2
24000: PUSH
24001: EMPTY
24002: LIST
24003: LIST
24004: PUSH
24005: LD_INT 1
24007: PUSH
24008: LD_INT 2
24010: PUSH
24011: EMPTY
24012: LIST
24013: LIST
24014: PUSH
24015: LD_INT 2
24017: NEG
24018: PUSH
24019: LD_INT 1
24021: NEG
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: PUSH
24027: LD_INT 2
24029: NEG
24030: PUSH
24031: LD_INT 2
24033: NEG
24034: PUSH
24035: EMPTY
24036: LIST
24037: LIST
24038: PUSH
24039: LD_INT 3
24041: PUSH
24042: LD_INT 2
24044: PUSH
24045: EMPTY
24046: LIST
24047: LIST
24048: PUSH
24049: LD_INT 3
24051: PUSH
24052: LD_INT 3
24054: PUSH
24055: EMPTY
24056: LIST
24057: LIST
24058: PUSH
24059: LD_INT 2
24061: PUSH
24062: LD_INT 3
24064: PUSH
24065: EMPTY
24066: LIST
24067: LIST
24068: PUSH
24069: EMPTY
24070: LIST
24071: LIST
24072: LIST
24073: LIST
24074: LIST
24075: LIST
24076: LIST
24077: LIST
24078: LIST
24079: LIST
24080: LIST
24081: LIST
24082: LIST
24083: LIST
24084: LIST
24085: LIST
24086: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24087: LD_ADDR_VAR 0 17
24091: PUSH
24092: LD_INT 0
24094: PUSH
24095: LD_INT 0
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PUSH
24102: LD_INT 0
24104: PUSH
24105: LD_INT 1
24107: NEG
24108: PUSH
24109: EMPTY
24110: LIST
24111: LIST
24112: PUSH
24113: LD_INT 1
24115: PUSH
24116: LD_INT 0
24118: PUSH
24119: EMPTY
24120: LIST
24121: LIST
24122: PUSH
24123: LD_INT 1
24125: PUSH
24126: LD_INT 1
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: PUSH
24133: LD_INT 0
24135: PUSH
24136: LD_INT 1
24138: PUSH
24139: EMPTY
24140: LIST
24141: LIST
24142: PUSH
24143: LD_INT 1
24145: NEG
24146: PUSH
24147: LD_INT 0
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: PUSH
24154: LD_INT 1
24156: NEG
24157: PUSH
24158: LD_INT 1
24160: NEG
24161: PUSH
24162: EMPTY
24163: LIST
24164: LIST
24165: PUSH
24166: LD_INT 1
24168: NEG
24169: PUSH
24170: LD_INT 2
24172: NEG
24173: PUSH
24174: EMPTY
24175: LIST
24176: LIST
24177: PUSH
24178: LD_INT 0
24180: PUSH
24181: LD_INT 2
24183: NEG
24184: PUSH
24185: EMPTY
24186: LIST
24187: LIST
24188: PUSH
24189: LD_INT 1
24191: PUSH
24192: LD_INT 1
24194: NEG
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: PUSH
24200: LD_INT 2
24202: PUSH
24203: LD_INT 0
24205: PUSH
24206: EMPTY
24207: LIST
24208: LIST
24209: PUSH
24210: LD_INT 2
24212: PUSH
24213: LD_INT 1
24215: PUSH
24216: EMPTY
24217: LIST
24218: LIST
24219: PUSH
24220: LD_INT 2
24222: PUSH
24223: LD_INT 2
24225: PUSH
24226: EMPTY
24227: LIST
24228: LIST
24229: PUSH
24230: LD_INT 1
24232: PUSH
24233: LD_INT 2
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: PUSH
24240: LD_INT 0
24242: PUSH
24243: LD_INT 2
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PUSH
24250: LD_INT 1
24252: NEG
24253: PUSH
24254: LD_INT 1
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: PUSH
24261: LD_INT 2
24263: NEG
24264: PUSH
24265: LD_INT 0
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: PUSH
24272: LD_INT 2
24274: NEG
24275: PUSH
24276: LD_INT 1
24278: NEG
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: LD_INT 2
24286: NEG
24287: PUSH
24288: LD_INT 2
24290: NEG
24291: PUSH
24292: EMPTY
24293: LIST
24294: LIST
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: LIST
24303: LIST
24304: LIST
24305: LIST
24306: LIST
24307: LIST
24308: LIST
24309: LIST
24310: LIST
24311: LIST
24312: LIST
24313: LIST
24314: LIST
24315: LIST
24316: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24317: LD_ADDR_VAR 0 18
24321: PUSH
24322: LD_INT 0
24324: PUSH
24325: LD_INT 0
24327: PUSH
24328: EMPTY
24329: LIST
24330: LIST
24331: PUSH
24332: LD_INT 0
24334: PUSH
24335: LD_INT 1
24337: NEG
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: PUSH
24343: LD_INT 1
24345: PUSH
24346: LD_INT 0
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: LD_INT 1
24355: PUSH
24356: LD_INT 1
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: PUSH
24363: LD_INT 0
24365: PUSH
24366: LD_INT 1
24368: PUSH
24369: EMPTY
24370: LIST
24371: LIST
24372: PUSH
24373: LD_INT 1
24375: NEG
24376: PUSH
24377: LD_INT 0
24379: PUSH
24380: EMPTY
24381: LIST
24382: LIST
24383: PUSH
24384: LD_INT 1
24386: NEG
24387: PUSH
24388: LD_INT 1
24390: NEG
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: PUSH
24396: LD_INT 1
24398: NEG
24399: PUSH
24400: LD_INT 2
24402: NEG
24403: PUSH
24404: EMPTY
24405: LIST
24406: LIST
24407: PUSH
24408: LD_INT 0
24410: PUSH
24411: LD_INT 2
24413: NEG
24414: PUSH
24415: EMPTY
24416: LIST
24417: LIST
24418: PUSH
24419: LD_INT 1
24421: PUSH
24422: LD_INT 1
24424: NEG
24425: PUSH
24426: EMPTY
24427: LIST
24428: LIST
24429: PUSH
24430: LD_INT 2
24432: PUSH
24433: LD_INT 0
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: PUSH
24440: LD_INT 2
24442: PUSH
24443: LD_INT 1
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: PUSH
24450: LD_INT 2
24452: PUSH
24453: LD_INT 2
24455: PUSH
24456: EMPTY
24457: LIST
24458: LIST
24459: PUSH
24460: LD_INT 1
24462: PUSH
24463: LD_INT 2
24465: PUSH
24466: EMPTY
24467: LIST
24468: LIST
24469: PUSH
24470: LD_INT 0
24472: PUSH
24473: LD_INT 2
24475: PUSH
24476: EMPTY
24477: LIST
24478: LIST
24479: PUSH
24480: LD_INT 1
24482: NEG
24483: PUSH
24484: LD_INT 1
24486: PUSH
24487: EMPTY
24488: LIST
24489: LIST
24490: PUSH
24491: LD_INT 2
24493: NEG
24494: PUSH
24495: LD_INT 0
24497: PUSH
24498: EMPTY
24499: LIST
24500: LIST
24501: PUSH
24502: LD_INT 2
24504: NEG
24505: PUSH
24506: LD_INT 1
24508: NEG
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 2
24516: NEG
24517: PUSH
24518: LD_INT 2
24520: NEG
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: EMPTY
24527: LIST
24528: LIST
24529: LIST
24530: LIST
24531: LIST
24532: LIST
24533: LIST
24534: LIST
24535: LIST
24536: LIST
24537: LIST
24538: LIST
24539: LIST
24540: LIST
24541: LIST
24542: LIST
24543: LIST
24544: LIST
24545: LIST
24546: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24547: LD_ADDR_VAR 0 19
24551: PUSH
24552: LD_INT 0
24554: PUSH
24555: LD_INT 0
24557: PUSH
24558: EMPTY
24559: LIST
24560: LIST
24561: PUSH
24562: LD_INT 0
24564: PUSH
24565: LD_INT 1
24567: NEG
24568: PUSH
24569: EMPTY
24570: LIST
24571: LIST
24572: PUSH
24573: LD_INT 1
24575: PUSH
24576: LD_INT 0
24578: PUSH
24579: EMPTY
24580: LIST
24581: LIST
24582: PUSH
24583: LD_INT 1
24585: PUSH
24586: LD_INT 1
24588: PUSH
24589: EMPTY
24590: LIST
24591: LIST
24592: PUSH
24593: LD_INT 0
24595: PUSH
24596: LD_INT 1
24598: PUSH
24599: EMPTY
24600: LIST
24601: LIST
24602: PUSH
24603: LD_INT 1
24605: NEG
24606: PUSH
24607: LD_INT 0
24609: PUSH
24610: EMPTY
24611: LIST
24612: LIST
24613: PUSH
24614: LD_INT 1
24616: NEG
24617: PUSH
24618: LD_INT 1
24620: NEG
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: PUSH
24626: LD_INT 1
24628: NEG
24629: PUSH
24630: LD_INT 2
24632: NEG
24633: PUSH
24634: EMPTY
24635: LIST
24636: LIST
24637: PUSH
24638: LD_INT 0
24640: PUSH
24641: LD_INT 2
24643: NEG
24644: PUSH
24645: EMPTY
24646: LIST
24647: LIST
24648: PUSH
24649: LD_INT 1
24651: PUSH
24652: LD_INT 1
24654: NEG
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: PUSH
24660: LD_INT 2
24662: PUSH
24663: LD_INT 0
24665: PUSH
24666: EMPTY
24667: LIST
24668: LIST
24669: PUSH
24670: LD_INT 2
24672: PUSH
24673: LD_INT 1
24675: PUSH
24676: EMPTY
24677: LIST
24678: LIST
24679: PUSH
24680: LD_INT 2
24682: PUSH
24683: LD_INT 2
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: PUSH
24690: LD_INT 1
24692: PUSH
24693: LD_INT 2
24695: PUSH
24696: EMPTY
24697: LIST
24698: LIST
24699: PUSH
24700: LD_INT 0
24702: PUSH
24703: LD_INT 2
24705: PUSH
24706: EMPTY
24707: LIST
24708: LIST
24709: PUSH
24710: LD_INT 1
24712: NEG
24713: PUSH
24714: LD_INT 1
24716: PUSH
24717: EMPTY
24718: LIST
24719: LIST
24720: PUSH
24721: LD_INT 2
24723: NEG
24724: PUSH
24725: LD_INT 0
24727: PUSH
24728: EMPTY
24729: LIST
24730: LIST
24731: PUSH
24732: LD_INT 2
24734: NEG
24735: PUSH
24736: LD_INT 1
24738: NEG
24739: PUSH
24740: EMPTY
24741: LIST
24742: LIST
24743: PUSH
24744: LD_INT 2
24746: NEG
24747: PUSH
24748: LD_INT 2
24750: NEG
24751: PUSH
24752: EMPTY
24753: LIST
24754: LIST
24755: PUSH
24756: EMPTY
24757: LIST
24758: LIST
24759: LIST
24760: LIST
24761: LIST
24762: LIST
24763: LIST
24764: LIST
24765: LIST
24766: LIST
24767: LIST
24768: LIST
24769: LIST
24770: LIST
24771: LIST
24772: LIST
24773: LIST
24774: LIST
24775: LIST
24776: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24777: LD_ADDR_VAR 0 20
24781: PUSH
24782: LD_INT 0
24784: PUSH
24785: LD_INT 0
24787: PUSH
24788: EMPTY
24789: LIST
24790: LIST
24791: PUSH
24792: LD_INT 0
24794: PUSH
24795: LD_INT 1
24797: NEG
24798: PUSH
24799: EMPTY
24800: LIST
24801: LIST
24802: PUSH
24803: LD_INT 1
24805: PUSH
24806: LD_INT 0
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: PUSH
24813: LD_INT 1
24815: PUSH
24816: LD_INT 1
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: PUSH
24823: LD_INT 0
24825: PUSH
24826: LD_INT 1
24828: PUSH
24829: EMPTY
24830: LIST
24831: LIST
24832: PUSH
24833: LD_INT 1
24835: NEG
24836: PUSH
24837: LD_INT 0
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PUSH
24844: LD_INT 1
24846: NEG
24847: PUSH
24848: LD_INT 1
24850: NEG
24851: PUSH
24852: EMPTY
24853: LIST
24854: LIST
24855: PUSH
24856: LD_INT 1
24858: NEG
24859: PUSH
24860: LD_INT 2
24862: NEG
24863: PUSH
24864: EMPTY
24865: LIST
24866: LIST
24867: PUSH
24868: LD_INT 0
24870: PUSH
24871: LD_INT 2
24873: NEG
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: PUSH
24879: LD_INT 1
24881: PUSH
24882: LD_INT 1
24884: NEG
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PUSH
24890: LD_INT 2
24892: PUSH
24893: LD_INT 0
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PUSH
24900: LD_INT 2
24902: PUSH
24903: LD_INT 1
24905: PUSH
24906: EMPTY
24907: LIST
24908: LIST
24909: PUSH
24910: LD_INT 2
24912: PUSH
24913: LD_INT 2
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 1
24922: PUSH
24923: LD_INT 2
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 0
24932: PUSH
24933: LD_INT 2
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: LD_INT 1
24942: NEG
24943: PUSH
24944: LD_INT 1
24946: PUSH
24947: EMPTY
24948: LIST
24949: LIST
24950: PUSH
24951: LD_INT 2
24953: NEG
24954: PUSH
24955: LD_INT 0
24957: PUSH
24958: EMPTY
24959: LIST
24960: LIST
24961: PUSH
24962: LD_INT 2
24964: NEG
24965: PUSH
24966: LD_INT 1
24968: NEG
24969: PUSH
24970: EMPTY
24971: LIST
24972: LIST
24973: PUSH
24974: LD_INT 2
24976: NEG
24977: PUSH
24978: LD_INT 2
24980: NEG
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: PUSH
24986: EMPTY
24987: LIST
24988: LIST
24989: LIST
24990: LIST
24991: LIST
24992: LIST
24993: LIST
24994: LIST
24995: LIST
24996: LIST
24997: LIST
24998: LIST
24999: LIST
25000: LIST
25001: LIST
25002: LIST
25003: LIST
25004: LIST
25005: LIST
25006: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25007: LD_ADDR_VAR 0 21
25011: PUSH
25012: LD_INT 0
25014: PUSH
25015: LD_INT 0
25017: PUSH
25018: EMPTY
25019: LIST
25020: LIST
25021: PUSH
25022: LD_INT 0
25024: PUSH
25025: LD_INT 1
25027: NEG
25028: PUSH
25029: EMPTY
25030: LIST
25031: LIST
25032: PUSH
25033: LD_INT 1
25035: PUSH
25036: LD_INT 0
25038: PUSH
25039: EMPTY
25040: LIST
25041: LIST
25042: PUSH
25043: LD_INT 1
25045: PUSH
25046: LD_INT 1
25048: PUSH
25049: EMPTY
25050: LIST
25051: LIST
25052: PUSH
25053: LD_INT 0
25055: PUSH
25056: LD_INT 1
25058: PUSH
25059: EMPTY
25060: LIST
25061: LIST
25062: PUSH
25063: LD_INT 1
25065: NEG
25066: PUSH
25067: LD_INT 0
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: LD_INT 1
25076: NEG
25077: PUSH
25078: LD_INT 1
25080: NEG
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: PUSH
25086: LD_INT 1
25088: NEG
25089: PUSH
25090: LD_INT 2
25092: NEG
25093: PUSH
25094: EMPTY
25095: LIST
25096: LIST
25097: PUSH
25098: LD_INT 0
25100: PUSH
25101: LD_INT 2
25103: NEG
25104: PUSH
25105: EMPTY
25106: LIST
25107: LIST
25108: PUSH
25109: LD_INT 1
25111: PUSH
25112: LD_INT 1
25114: NEG
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: PUSH
25120: LD_INT 2
25122: PUSH
25123: LD_INT 0
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: PUSH
25130: LD_INT 2
25132: PUSH
25133: LD_INT 1
25135: PUSH
25136: EMPTY
25137: LIST
25138: LIST
25139: PUSH
25140: LD_INT 2
25142: PUSH
25143: LD_INT 2
25145: PUSH
25146: EMPTY
25147: LIST
25148: LIST
25149: PUSH
25150: LD_INT 1
25152: PUSH
25153: LD_INT 2
25155: PUSH
25156: EMPTY
25157: LIST
25158: LIST
25159: PUSH
25160: LD_INT 0
25162: PUSH
25163: LD_INT 2
25165: PUSH
25166: EMPTY
25167: LIST
25168: LIST
25169: PUSH
25170: LD_INT 1
25172: NEG
25173: PUSH
25174: LD_INT 1
25176: PUSH
25177: EMPTY
25178: LIST
25179: LIST
25180: PUSH
25181: LD_INT 2
25183: NEG
25184: PUSH
25185: LD_INT 0
25187: PUSH
25188: EMPTY
25189: LIST
25190: LIST
25191: PUSH
25192: LD_INT 2
25194: NEG
25195: PUSH
25196: LD_INT 1
25198: NEG
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: PUSH
25204: LD_INT 2
25206: NEG
25207: PUSH
25208: LD_INT 2
25210: NEG
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: PUSH
25216: EMPTY
25217: LIST
25218: LIST
25219: LIST
25220: LIST
25221: LIST
25222: LIST
25223: LIST
25224: LIST
25225: LIST
25226: LIST
25227: LIST
25228: LIST
25229: LIST
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25237: LD_ADDR_VAR 0 22
25241: PUSH
25242: LD_INT 0
25244: PUSH
25245: LD_INT 0
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: LD_INT 0
25254: PUSH
25255: LD_INT 1
25257: NEG
25258: PUSH
25259: EMPTY
25260: LIST
25261: LIST
25262: PUSH
25263: LD_INT 1
25265: PUSH
25266: LD_INT 0
25268: PUSH
25269: EMPTY
25270: LIST
25271: LIST
25272: PUSH
25273: LD_INT 1
25275: PUSH
25276: LD_INT 1
25278: PUSH
25279: EMPTY
25280: LIST
25281: LIST
25282: PUSH
25283: LD_INT 0
25285: PUSH
25286: LD_INT 1
25288: PUSH
25289: EMPTY
25290: LIST
25291: LIST
25292: PUSH
25293: LD_INT 1
25295: NEG
25296: PUSH
25297: LD_INT 0
25299: PUSH
25300: EMPTY
25301: LIST
25302: LIST
25303: PUSH
25304: LD_INT 1
25306: NEG
25307: PUSH
25308: LD_INT 1
25310: NEG
25311: PUSH
25312: EMPTY
25313: LIST
25314: LIST
25315: PUSH
25316: LD_INT 1
25318: NEG
25319: PUSH
25320: LD_INT 2
25322: NEG
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: PUSH
25328: LD_INT 0
25330: PUSH
25331: LD_INT 2
25333: NEG
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 1
25341: PUSH
25342: LD_INT 1
25344: NEG
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 2
25352: PUSH
25353: LD_INT 0
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: LD_INT 2
25362: PUSH
25363: LD_INT 1
25365: PUSH
25366: EMPTY
25367: LIST
25368: LIST
25369: PUSH
25370: LD_INT 2
25372: PUSH
25373: LD_INT 2
25375: PUSH
25376: EMPTY
25377: LIST
25378: LIST
25379: PUSH
25380: LD_INT 1
25382: PUSH
25383: LD_INT 2
25385: PUSH
25386: EMPTY
25387: LIST
25388: LIST
25389: PUSH
25390: LD_INT 0
25392: PUSH
25393: LD_INT 2
25395: PUSH
25396: EMPTY
25397: LIST
25398: LIST
25399: PUSH
25400: LD_INT 1
25402: NEG
25403: PUSH
25404: LD_INT 1
25406: PUSH
25407: EMPTY
25408: LIST
25409: LIST
25410: PUSH
25411: LD_INT 2
25413: NEG
25414: PUSH
25415: LD_INT 0
25417: PUSH
25418: EMPTY
25419: LIST
25420: LIST
25421: PUSH
25422: LD_INT 2
25424: NEG
25425: PUSH
25426: LD_INT 1
25428: NEG
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: PUSH
25434: LD_INT 2
25436: NEG
25437: PUSH
25438: LD_INT 2
25440: NEG
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: PUSH
25446: EMPTY
25447: LIST
25448: LIST
25449: LIST
25450: LIST
25451: LIST
25452: LIST
25453: LIST
25454: LIST
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: LIST
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
25467: LD_ADDR_VAR 0 23
25471: PUSH
25472: LD_INT 0
25474: PUSH
25475: LD_INT 0
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: PUSH
25482: LD_INT 0
25484: PUSH
25485: LD_INT 1
25487: NEG
25488: PUSH
25489: EMPTY
25490: LIST
25491: LIST
25492: PUSH
25493: LD_INT 1
25495: PUSH
25496: LD_INT 0
25498: PUSH
25499: EMPTY
25500: LIST
25501: LIST
25502: PUSH
25503: LD_INT 1
25505: PUSH
25506: LD_INT 1
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: PUSH
25513: LD_INT 0
25515: PUSH
25516: LD_INT 1
25518: PUSH
25519: EMPTY
25520: LIST
25521: LIST
25522: PUSH
25523: LD_INT 1
25525: NEG
25526: PUSH
25527: LD_INT 0
25529: PUSH
25530: EMPTY
25531: LIST
25532: LIST
25533: PUSH
25534: LD_INT 1
25536: NEG
25537: PUSH
25538: LD_INT 1
25540: NEG
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 1
25548: NEG
25549: PUSH
25550: LD_INT 2
25552: NEG
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: PUSH
25558: LD_INT 0
25560: PUSH
25561: LD_INT 2
25563: NEG
25564: PUSH
25565: EMPTY
25566: LIST
25567: LIST
25568: PUSH
25569: LD_INT 1
25571: PUSH
25572: LD_INT 1
25574: NEG
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: PUSH
25580: LD_INT 2
25582: PUSH
25583: LD_INT 0
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 2
25592: PUSH
25593: LD_INT 1
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PUSH
25600: LD_INT 2
25602: PUSH
25603: LD_INT 2
25605: PUSH
25606: EMPTY
25607: LIST
25608: LIST
25609: PUSH
25610: LD_INT 1
25612: PUSH
25613: LD_INT 2
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PUSH
25620: LD_INT 0
25622: PUSH
25623: LD_INT 2
25625: PUSH
25626: EMPTY
25627: LIST
25628: LIST
25629: PUSH
25630: LD_INT 1
25632: NEG
25633: PUSH
25634: LD_INT 1
25636: PUSH
25637: EMPTY
25638: LIST
25639: LIST
25640: PUSH
25641: LD_INT 2
25643: NEG
25644: PUSH
25645: LD_INT 0
25647: PUSH
25648: EMPTY
25649: LIST
25650: LIST
25651: PUSH
25652: LD_INT 2
25654: NEG
25655: PUSH
25656: LD_INT 1
25658: NEG
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 2
25666: NEG
25667: PUSH
25668: LD_INT 2
25670: NEG
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: LD_INT 2
25678: NEG
25679: PUSH
25680: LD_INT 3
25682: NEG
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 1
25690: NEG
25691: PUSH
25692: LD_INT 3
25694: NEG
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: LD_INT 1
25702: PUSH
25703: LD_INT 2
25705: NEG
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: LD_INT 2
25713: PUSH
25714: LD_INT 1
25716: NEG
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: EMPTY
25723: LIST
25724: LIST
25725: LIST
25726: LIST
25727: LIST
25728: LIST
25729: LIST
25730: LIST
25731: LIST
25732: LIST
25733: LIST
25734: LIST
25735: LIST
25736: LIST
25737: LIST
25738: LIST
25739: LIST
25740: LIST
25741: LIST
25742: LIST
25743: LIST
25744: LIST
25745: LIST
25746: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
25747: LD_ADDR_VAR 0 24
25751: PUSH
25752: LD_INT 0
25754: PUSH
25755: LD_INT 0
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PUSH
25762: LD_INT 0
25764: PUSH
25765: LD_INT 1
25767: NEG
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: LD_INT 1
25775: PUSH
25776: LD_INT 0
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: LD_INT 1
25785: PUSH
25786: LD_INT 1
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 0
25795: PUSH
25796: LD_INT 1
25798: PUSH
25799: EMPTY
25800: LIST
25801: LIST
25802: PUSH
25803: LD_INT 1
25805: NEG
25806: PUSH
25807: LD_INT 0
25809: PUSH
25810: EMPTY
25811: LIST
25812: LIST
25813: PUSH
25814: LD_INT 1
25816: NEG
25817: PUSH
25818: LD_INT 1
25820: NEG
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PUSH
25826: LD_INT 1
25828: NEG
25829: PUSH
25830: LD_INT 2
25832: NEG
25833: PUSH
25834: EMPTY
25835: LIST
25836: LIST
25837: PUSH
25838: LD_INT 0
25840: PUSH
25841: LD_INT 2
25843: NEG
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: PUSH
25849: LD_INT 1
25851: PUSH
25852: LD_INT 1
25854: NEG
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 2
25862: PUSH
25863: LD_INT 0
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PUSH
25870: LD_INT 2
25872: PUSH
25873: LD_INT 1
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: LD_INT 2
25882: PUSH
25883: LD_INT 2
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 1
25892: PUSH
25893: LD_INT 2
25895: PUSH
25896: EMPTY
25897: LIST
25898: LIST
25899: PUSH
25900: LD_INT 0
25902: PUSH
25903: LD_INT 2
25905: PUSH
25906: EMPTY
25907: LIST
25908: LIST
25909: PUSH
25910: LD_INT 1
25912: NEG
25913: PUSH
25914: LD_INT 1
25916: PUSH
25917: EMPTY
25918: LIST
25919: LIST
25920: PUSH
25921: LD_INT 2
25923: NEG
25924: PUSH
25925: LD_INT 0
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: PUSH
25932: LD_INT 2
25934: NEG
25935: PUSH
25936: LD_INT 1
25938: NEG
25939: PUSH
25940: EMPTY
25941: LIST
25942: LIST
25943: PUSH
25944: LD_INT 2
25946: NEG
25947: PUSH
25948: LD_INT 2
25950: NEG
25951: PUSH
25952: EMPTY
25953: LIST
25954: LIST
25955: PUSH
25956: LD_INT 1
25958: PUSH
25959: LD_INT 2
25961: NEG
25962: PUSH
25963: EMPTY
25964: LIST
25965: LIST
25966: PUSH
25967: LD_INT 2
25969: PUSH
25970: LD_INT 1
25972: NEG
25973: PUSH
25974: EMPTY
25975: LIST
25976: LIST
25977: PUSH
25978: LD_INT 3
25980: PUSH
25981: LD_INT 1
25983: PUSH
25984: EMPTY
25985: LIST
25986: LIST
25987: PUSH
25988: LD_INT 3
25990: PUSH
25991: LD_INT 2
25993: PUSH
25994: EMPTY
25995: LIST
25996: LIST
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: LIST
26002: LIST
26003: LIST
26004: LIST
26005: LIST
26006: LIST
26007: LIST
26008: LIST
26009: LIST
26010: LIST
26011: LIST
26012: LIST
26013: LIST
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: LIST
26019: LIST
26020: LIST
26021: LIST
26022: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
26023: LD_ADDR_VAR 0 25
26027: PUSH
26028: LD_INT 0
26030: PUSH
26031: LD_INT 0
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 0
26040: PUSH
26041: LD_INT 1
26043: NEG
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PUSH
26049: LD_INT 1
26051: PUSH
26052: LD_INT 0
26054: PUSH
26055: EMPTY
26056: LIST
26057: LIST
26058: PUSH
26059: LD_INT 1
26061: PUSH
26062: LD_INT 1
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PUSH
26069: LD_INT 0
26071: PUSH
26072: LD_INT 1
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: PUSH
26079: LD_INT 1
26081: NEG
26082: PUSH
26083: LD_INT 0
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: PUSH
26090: LD_INT 1
26092: NEG
26093: PUSH
26094: LD_INT 1
26096: NEG
26097: PUSH
26098: EMPTY
26099: LIST
26100: LIST
26101: PUSH
26102: LD_INT 1
26104: NEG
26105: PUSH
26106: LD_INT 2
26108: NEG
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: LD_INT 0
26116: PUSH
26117: LD_INT 2
26119: NEG
26120: PUSH
26121: EMPTY
26122: LIST
26123: LIST
26124: PUSH
26125: LD_INT 1
26127: PUSH
26128: LD_INT 1
26130: NEG
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 2
26138: PUSH
26139: LD_INT 0
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: LD_INT 2
26148: PUSH
26149: LD_INT 1
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: PUSH
26156: LD_INT 2
26158: PUSH
26159: LD_INT 2
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: LD_INT 1
26168: PUSH
26169: LD_INT 2
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 0
26178: PUSH
26179: LD_INT 2
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: LD_INT 1
26188: NEG
26189: PUSH
26190: LD_INT 1
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: PUSH
26197: LD_INT 2
26199: NEG
26200: PUSH
26201: LD_INT 0
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: PUSH
26208: LD_INT 2
26210: NEG
26211: PUSH
26212: LD_INT 1
26214: NEG
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: PUSH
26220: LD_INT 2
26222: NEG
26223: PUSH
26224: LD_INT 2
26226: NEG
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 3
26234: PUSH
26235: LD_INT 1
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: PUSH
26242: LD_INT 3
26244: PUSH
26245: LD_INT 2
26247: PUSH
26248: EMPTY
26249: LIST
26250: LIST
26251: PUSH
26252: LD_INT 2
26254: PUSH
26255: LD_INT 3
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 1
26264: PUSH
26265: LD_INT 3
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: LIST
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: LIST
26281: LIST
26282: LIST
26283: LIST
26284: LIST
26285: LIST
26286: LIST
26287: LIST
26288: LIST
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: LIST
26294: LIST
26295: LIST
26296: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
26297: LD_ADDR_VAR 0 26
26301: PUSH
26302: LD_INT 0
26304: PUSH
26305: LD_INT 0
26307: PUSH
26308: EMPTY
26309: LIST
26310: LIST
26311: PUSH
26312: LD_INT 0
26314: PUSH
26315: LD_INT 1
26317: NEG
26318: PUSH
26319: EMPTY
26320: LIST
26321: LIST
26322: PUSH
26323: LD_INT 1
26325: PUSH
26326: LD_INT 0
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 1
26335: PUSH
26336: LD_INT 1
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 0
26345: PUSH
26346: LD_INT 1
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: PUSH
26353: LD_INT 1
26355: NEG
26356: PUSH
26357: LD_INT 0
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 1
26366: NEG
26367: PUSH
26368: LD_INT 1
26370: NEG
26371: PUSH
26372: EMPTY
26373: LIST
26374: LIST
26375: PUSH
26376: LD_INT 1
26378: NEG
26379: PUSH
26380: LD_INT 2
26382: NEG
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 0
26390: PUSH
26391: LD_INT 2
26393: NEG
26394: PUSH
26395: EMPTY
26396: LIST
26397: LIST
26398: PUSH
26399: LD_INT 1
26401: PUSH
26402: LD_INT 1
26404: NEG
26405: PUSH
26406: EMPTY
26407: LIST
26408: LIST
26409: PUSH
26410: LD_INT 2
26412: PUSH
26413: LD_INT 0
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: PUSH
26420: LD_INT 2
26422: PUSH
26423: LD_INT 1
26425: PUSH
26426: EMPTY
26427: LIST
26428: LIST
26429: PUSH
26430: LD_INT 2
26432: PUSH
26433: LD_INT 2
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: LD_INT 1
26442: PUSH
26443: LD_INT 2
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 0
26452: PUSH
26453: LD_INT 2
26455: PUSH
26456: EMPTY
26457: LIST
26458: LIST
26459: PUSH
26460: LD_INT 1
26462: NEG
26463: PUSH
26464: LD_INT 1
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: PUSH
26471: LD_INT 2
26473: NEG
26474: PUSH
26475: LD_INT 0
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PUSH
26482: LD_INT 2
26484: NEG
26485: PUSH
26486: LD_INT 1
26488: NEG
26489: PUSH
26490: EMPTY
26491: LIST
26492: LIST
26493: PUSH
26494: LD_INT 2
26496: NEG
26497: PUSH
26498: LD_INT 2
26500: NEG
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 2
26508: PUSH
26509: LD_INT 3
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 1
26518: PUSH
26519: LD_INT 3
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 1
26528: NEG
26529: PUSH
26530: LD_INT 2
26532: PUSH
26533: EMPTY
26534: LIST
26535: LIST
26536: PUSH
26537: LD_INT 2
26539: NEG
26540: PUSH
26541: LD_INT 1
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: LIST
26566: LIST
26567: LIST
26568: LIST
26569: LIST
26570: LIST
26571: LIST
26572: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
26573: LD_ADDR_VAR 0 27
26577: PUSH
26578: LD_INT 0
26580: PUSH
26581: LD_INT 0
26583: PUSH
26584: EMPTY
26585: LIST
26586: LIST
26587: PUSH
26588: LD_INT 0
26590: PUSH
26591: LD_INT 1
26593: NEG
26594: PUSH
26595: EMPTY
26596: LIST
26597: LIST
26598: PUSH
26599: LD_INT 1
26601: PUSH
26602: LD_INT 0
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PUSH
26609: LD_INT 1
26611: PUSH
26612: LD_INT 1
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: PUSH
26619: LD_INT 0
26621: PUSH
26622: LD_INT 1
26624: PUSH
26625: EMPTY
26626: LIST
26627: LIST
26628: PUSH
26629: LD_INT 1
26631: NEG
26632: PUSH
26633: LD_INT 0
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: PUSH
26640: LD_INT 1
26642: NEG
26643: PUSH
26644: LD_INT 1
26646: NEG
26647: PUSH
26648: EMPTY
26649: LIST
26650: LIST
26651: PUSH
26652: LD_INT 1
26654: NEG
26655: PUSH
26656: LD_INT 2
26658: NEG
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: PUSH
26664: LD_INT 0
26666: PUSH
26667: LD_INT 2
26669: NEG
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PUSH
26675: LD_INT 1
26677: PUSH
26678: LD_INT 1
26680: NEG
26681: PUSH
26682: EMPTY
26683: LIST
26684: LIST
26685: PUSH
26686: LD_INT 2
26688: PUSH
26689: LD_INT 0
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 2
26698: PUSH
26699: LD_INT 1
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: LD_INT 2
26708: PUSH
26709: LD_INT 2
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 1
26718: PUSH
26719: LD_INT 2
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 0
26728: PUSH
26729: LD_INT 2
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 1
26738: NEG
26739: PUSH
26740: LD_INT 1
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: PUSH
26747: LD_INT 2
26749: NEG
26750: PUSH
26751: LD_INT 0
26753: PUSH
26754: EMPTY
26755: LIST
26756: LIST
26757: PUSH
26758: LD_INT 2
26760: NEG
26761: PUSH
26762: LD_INT 1
26764: NEG
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PUSH
26770: LD_INT 2
26772: NEG
26773: PUSH
26774: LD_INT 2
26776: NEG
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 1
26784: NEG
26785: PUSH
26786: LD_INT 2
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PUSH
26793: LD_INT 2
26795: NEG
26796: PUSH
26797: LD_INT 1
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: PUSH
26804: LD_INT 3
26806: NEG
26807: PUSH
26808: LD_INT 1
26810: NEG
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: LD_INT 3
26818: NEG
26819: PUSH
26820: LD_INT 2
26822: NEG
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: PUSH
26828: EMPTY
26829: LIST
26830: LIST
26831: LIST
26832: LIST
26833: LIST
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: LIST
26839: LIST
26840: LIST
26841: LIST
26842: LIST
26843: LIST
26844: LIST
26845: LIST
26846: LIST
26847: LIST
26848: LIST
26849: LIST
26850: LIST
26851: LIST
26852: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
26853: LD_ADDR_VAR 0 28
26857: PUSH
26858: LD_INT 0
26860: PUSH
26861: LD_INT 0
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: PUSH
26868: LD_INT 0
26870: PUSH
26871: LD_INT 1
26873: NEG
26874: PUSH
26875: EMPTY
26876: LIST
26877: LIST
26878: PUSH
26879: LD_INT 1
26881: PUSH
26882: LD_INT 0
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 1
26891: PUSH
26892: LD_INT 1
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: LD_INT 0
26901: PUSH
26902: LD_INT 1
26904: PUSH
26905: EMPTY
26906: LIST
26907: LIST
26908: PUSH
26909: LD_INT 1
26911: NEG
26912: PUSH
26913: LD_INT 0
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: PUSH
26920: LD_INT 1
26922: NEG
26923: PUSH
26924: LD_INT 1
26926: NEG
26927: PUSH
26928: EMPTY
26929: LIST
26930: LIST
26931: PUSH
26932: LD_INT 1
26934: NEG
26935: PUSH
26936: LD_INT 2
26938: NEG
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: LD_INT 0
26946: PUSH
26947: LD_INT 2
26949: NEG
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: PUSH
26955: LD_INT 1
26957: PUSH
26958: LD_INT 1
26960: NEG
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: LD_INT 2
26968: PUSH
26969: LD_INT 0
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: PUSH
26976: LD_INT 2
26978: PUSH
26979: LD_INT 1
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: LD_INT 2
26988: PUSH
26989: LD_INT 2
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: LD_INT 1
26998: PUSH
26999: LD_INT 2
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 0
27008: PUSH
27009: LD_INT 2
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: PUSH
27016: LD_INT 1
27018: NEG
27019: PUSH
27020: LD_INT 1
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: PUSH
27027: LD_INT 2
27029: NEG
27030: PUSH
27031: LD_INT 0
27033: PUSH
27034: EMPTY
27035: LIST
27036: LIST
27037: PUSH
27038: LD_INT 2
27040: NEG
27041: PUSH
27042: LD_INT 1
27044: NEG
27045: PUSH
27046: EMPTY
27047: LIST
27048: LIST
27049: PUSH
27050: LD_INT 2
27052: NEG
27053: PUSH
27054: LD_INT 2
27056: NEG
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 2
27064: NEG
27065: PUSH
27066: LD_INT 3
27068: NEG
27069: PUSH
27070: EMPTY
27071: LIST
27072: LIST
27073: PUSH
27074: LD_INT 1
27076: NEG
27077: PUSH
27078: LD_INT 3
27080: NEG
27081: PUSH
27082: EMPTY
27083: LIST
27084: LIST
27085: PUSH
27086: LD_INT 3
27088: NEG
27089: PUSH
27090: LD_INT 1
27092: NEG
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: LD_INT 3
27100: NEG
27101: PUSH
27102: LD_INT 2
27104: NEG
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: LIST
27114: LIST
27115: LIST
27116: LIST
27117: LIST
27118: LIST
27119: LIST
27120: LIST
27121: LIST
27122: LIST
27123: LIST
27124: LIST
27125: LIST
27126: LIST
27127: LIST
27128: LIST
27129: LIST
27130: LIST
27131: LIST
27132: LIST
27133: LIST
27134: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27135: LD_ADDR_VAR 0 29
27139: PUSH
27140: LD_INT 0
27142: PUSH
27143: LD_INT 0
27145: PUSH
27146: EMPTY
27147: LIST
27148: LIST
27149: PUSH
27150: LD_INT 0
27152: PUSH
27153: LD_INT 1
27155: NEG
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: LD_INT 1
27163: PUSH
27164: LD_INT 0
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: LD_INT 1
27173: PUSH
27174: LD_INT 1
27176: PUSH
27177: EMPTY
27178: LIST
27179: LIST
27180: PUSH
27181: LD_INT 0
27183: PUSH
27184: LD_INT 1
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 1
27193: NEG
27194: PUSH
27195: LD_INT 0
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 1
27204: NEG
27205: PUSH
27206: LD_INT 1
27208: NEG
27209: PUSH
27210: EMPTY
27211: LIST
27212: LIST
27213: PUSH
27214: LD_INT 1
27216: NEG
27217: PUSH
27218: LD_INT 2
27220: NEG
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: LD_INT 0
27228: PUSH
27229: LD_INT 2
27231: NEG
27232: PUSH
27233: EMPTY
27234: LIST
27235: LIST
27236: PUSH
27237: LD_INT 1
27239: PUSH
27240: LD_INT 1
27242: NEG
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 2
27250: PUSH
27251: LD_INT 0
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 2
27260: PUSH
27261: LD_INT 1
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: PUSH
27268: LD_INT 1
27270: PUSH
27271: LD_INT 2
27273: PUSH
27274: EMPTY
27275: LIST
27276: LIST
27277: PUSH
27278: LD_INT 0
27280: PUSH
27281: LD_INT 2
27283: PUSH
27284: EMPTY
27285: LIST
27286: LIST
27287: PUSH
27288: LD_INT 1
27290: NEG
27291: PUSH
27292: LD_INT 1
27294: PUSH
27295: EMPTY
27296: LIST
27297: LIST
27298: PUSH
27299: LD_INT 2
27301: NEG
27302: PUSH
27303: LD_INT 1
27305: NEG
27306: PUSH
27307: EMPTY
27308: LIST
27309: LIST
27310: PUSH
27311: LD_INT 2
27313: NEG
27314: PUSH
27315: LD_INT 2
27317: NEG
27318: PUSH
27319: EMPTY
27320: LIST
27321: LIST
27322: PUSH
27323: LD_INT 2
27325: NEG
27326: PUSH
27327: LD_INT 3
27329: NEG
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 2
27337: PUSH
27338: LD_INT 1
27340: NEG
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: PUSH
27346: LD_INT 3
27348: PUSH
27349: LD_INT 1
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: PUSH
27356: LD_INT 1
27358: PUSH
27359: LD_INT 3
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 1
27368: NEG
27369: PUSH
27370: LD_INT 2
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: PUSH
27377: LD_INT 3
27379: NEG
27380: PUSH
27381: LD_INT 2
27383: NEG
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: LIST
27402: LIST
27403: LIST
27404: LIST
27405: LIST
27406: LIST
27407: LIST
27408: LIST
27409: LIST
27410: LIST
27411: LIST
27412: LIST
27413: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
27414: LD_ADDR_VAR 0 30
27418: PUSH
27419: LD_INT 0
27421: PUSH
27422: LD_INT 0
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 0
27431: PUSH
27432: LD_INT 1
27434: NEG
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 1
27442: PUSH
27443: LD_INT 0
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: PUSH
27450: LD_INT 1
27452: PUSH
27453: LD_INT 1
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: PUSH
27460: LD_INT 0
27462: PUSH
27463: LD_INT 1
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 1
27472: NEG
27473: PUSH
27474: LD_INT 0
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: LD_INT 1
27483: NEG
27484: PUSH
27485: LD_INT 1
27487: NEG
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: PUSH
27493: LD_INT 1
27495: NEG
27496: PUSH
27497: LD_INT 2
27499: NEG
27500: PUSH
27501: EMPTY
27502: LIST
27503: LIST
27504: PUSH
27505: LD_INT 0
27507: PUSH
27508: LD_INT 2
27510: NEG
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 1
27518: PUSH
27519: LD_INT 1
27521: NEG
27522: PUSH
27523: EMPTY
27524: LIST
27525: LIST
27526: PUSH
27527: LD_INT 2
27529: PUSH
27530: LD_INT 0
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: LD_INT 2
27539: PUSH
27540: LD_INT 1
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: LD_INT 2
27549: PUSH
27550: LD_INT 2
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: PUSH
27557: LD_INT 1
27559: PUSH
27560: LD_INT 2
27562: PUSH
27563: EMPTY
27564: LIST
27565: LIST
27566: PUSH
27567: LD_INT 1
27569: NEG
27570: PUSH
27571: LD_INT 1
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: LD_INT 2
27580: NEG
27581: PUSH
27582: LD_INT 0
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 2
27591: NEG
27592: PUSH
27593: LD_INT 1
27595: NEG
27596: PUSH
27597: EMPTY
27598: LIST
27599: LIST
27600: PUSH
27601: LD_INT 1
27603: NEG
27604: PUSH
27605: LD_INT 3
27607: NEG
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: LD_INT 2
27618: NEG
27619: PUSH
27620: EMPTY
27621: LIST
27622: LIST
27623: PUSH
27624: LD_INT 3
27626: PUSH
27627: LD_INT 2
27629: PUSH
27630: EMPTY
27631: LIST
27632: LIST
27633: PUSH
27634: LD_INT 2
27636: PUSH
27637: LD_INT 3
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: PUSH
27644: LD_INT 2
27646: NEG
27647: PUSH
27648: LD_INT 1
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PUSH
27655: LD_INT 3
27657: NEG
27658: PUSH
27659: LD_INT 1
27661: NEG
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: LIST
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: LIST
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: LIST
27682: LIST
27683: LIST
27684: LIST
27685: LIST
27686: LIST
27687: LIST
27688: LIST
27689: LIST
27690: LIST
27691: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27692: LD_ADDR_VAR 0 31
27696: PUSH
27697: LD_INT 0
27699: PUSH
27700: LD_INT 0
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 0
27709: PUSH
27710: LD_INT 1
27712: NEG
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: PUSH
27718: LD_INT 1
27720: PUSH
27721: LD_INT 0
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: PUSH
27728: LD_INT 1
27730: PUSH
27731: LD_INT 1
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: PUSH
27738: LD_INT 0
27740: PUSH
27741: LD_INT 1
27743: PUSH
27744: EMPTY
27745: LIST
27746: LIST
27747: PUSH
27748: LD_INT 1
27750: NEG
27751: PUSH
27752: LD_INT 0
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: PUSH
27759: LD_INT 1
27761: NEG
27762: PUSH
27763: LD_INT 1
27765: NEG
27766: PUSH
27767: EMPTY
27768: LIST
27769: LIST
27770: PUSH
27771: LD_INT 1
27773: NEG
27774: PUSH
27775: LD_INT 2
27777: NEG
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 1
27785: PUSH
27786: LD_INT 1
27788: NEG
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: LD_INT 2
27796: PUSH
27797: LD_INT 0
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 2
27806: PUSH
27807: LD_INT 1
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 2
27816: PUSH
27817: LD_INT 2
27819: PUSH
27820: EMPTY
27821: LIST
27822: LIST
27823: PUSH
27824: LD_INT 1
27826: PUSH
27827: LD_INT 2
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: PUSH
27834: LD_INT 0
27836: PUSH
27837: LD_INT 2
27839: PUSH
27840: EMPTY
27841: LIST
27842: LIST
27843: PUSH
27844: LD_INT 1
27846: NEG
27847: PUSH
27848: LD_INT 1
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: LD_INT 2
27857: NEG
27858: PUSH
27859: LD_INT 1
27861: NEG
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: LD_INT 2
27869: NEG
27870: PUSH
27871: LD_INT 2
27873: NEG
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 2
27881: NEG
27882: PUSH
27883: LD_INT 3
27885: NEG
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: LD_INT 2
27893: PUSH
27894: LD_INT 1
27896: NEG
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 3
27904: PUSH
27905: LD_INT 1
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 1
27914: PUSH
27915: LD_INT 3
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: LD_INT 1
27924: NEG
27925: PUSH
27926: LD_INT 2
27928: PUSH
27929: EMPTY
27930: LIST
27931: LIST
27932: PUSH
27933: LD_INT 3
27935: NEG
27936: PUSH
27937: LD_INT 2
27939: NEG
27940: PUSH
27941: EMPTY
27942: LIST
27943: LIST
27944: PUSH
27945: EMPTY
27946: LIST
27947: LIST
27948: LIST
27949: LIST
27950: LIST
27951: LIST
27952: LIST
27953: LIST
27954: LIST
27955: LIST
27956: LIST
27957: LIST
27958: LIST
27959: LIST
27960: LIST
27961: LIST
27962: LIST
27963: LIST
27964: LIST
27965: LIST
27966: LIST
27967: LIST
27968: LIST
27969: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
27970: LD_ADDR_VAR 0 32
27974: PUSH
27975: LD_INT 0
27977: PUSH
27978: LD_INT 0
27980: PUSH
27981: EMPTY
27982: LIST
27983: LIST
27984: PUSH
27985: LD_INT 0
27987: PUSH
27988: LD_INT 1
27990: NEG
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: LD_INT 1
27998: PUSH
27999: LD_INT 0
28001: PUSH
28002: EMPTY
28003: LIST
28004: LIST
28005: PUSH
28006: LD_INT 1
28008: PUSH
28009: LD_INT 1
28011: PUSH
28012: EMPTY
28013: LIST
28014: LIST
28015: PUSH
28016: LD_INT 0
28018: PUSH
28019: LD_INT 1
28021: PUSH
28022: EMPTY
28023: LIST
28024: LIST
28025: PUSH
28026: LD_INT 1
28028: NEG
28029: PUSH
28030: LD_INT 0
28032: PUSH
28033: EMPTY
28034: LIST
28035: LIST
28036: PUSH
28037: LD_INT 1
28039: NEG
28040: PUSH
28041: LD_INT 1
28043: NEG
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PUSH
28049: LD_INT 1
28051: NEG
28052: PUSH
28053: LD_INT 2
28055: NEG
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: LD_INT 0
28063: PUSH
28064: LD_INT 2
28066: NEG
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 1
28074: PUSH
28075: LD_INT 1
28077: NEG
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: PUSH
28083: LD_INT 2
28085: PUSH
28086: LD_INT 1
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: PUSH
28093: LD_INT 2
28095: PUSH
28096: LD_INT 2
28098: PUSH
28099: EMPTY
28100: LIST
28101: LIST
28102: PUSH
28103: LD_INT 1
28105: PUSH
28106: LD_INT 2
28108: PUSH
28109: EMPTY
28110: LIST
28111: LIST
28112: PUSH
28113: LD_INT 0
28115: PUSH
28116: LD_INT 2
28118: PUSH
28119: EMPTY
28120: LIST
28121: LIST
28122: PUSH
28123: LD_INT 1
28125: NEG
28126: PUSH
28127: LD_INT 1
28129: PUSH
28130: EMPTY
28131: LIST
28132: LIST
28133: PUSH
28134: LD_INT 2
28136: NEG
28137: PUSH
28138: LD_INT 0
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 2
28147: NEG
28148: PUSH
28149: LD_INT 1
28151: NEG
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: PUSH
28157: LD_INT 1
28159: NEG
28160: PUSH
28161: LD_INT 3
28163: NEG
28164: PUSH
28165: EMPTY
28166: LIST
28167: LIST
28168: PUSH
28169: LD_INT 1
28171: PUSH
28172: LD_INT 2
28174: NEG
28175: PUSH
28176: EMPTY
28177: LIST
28178: LIST
28179: PUSH
28180: LD_INT 3
28182: PUSH
28183: LD_INT 2
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: PUSH
28190: LD_INT 2
28192: PUSH
28193: LD_INT 3
28195: PUSH
28196: EMPTY
28197: LIST
28198: LIST
28199: PUSH
28200: LD_INT 2
28202: NEG
28203: PUSH
28204: LD_INT 1
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 3
28213: NEG
28214: PUSH
28215: LD_INT 1
28217: NEG
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: LIST
28234: LIST
28235: LIST
28236: LIST
28237: LIST
28238: LIST
28239: LIST
28240: LIST
28241: LIST
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28248: LD_ADDR_VAR 0 33
28252: PUSH
28253: LD_INT 0
28255: PUSH
28256: LD_INT 0
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 0
28265: PUSH
28266: LD_INT 1
28268: NEG
28269: PUSH
28270: EMPTY
28271: LIST
28272: LIST
28273: PUSH
28274: LD_INT 1
28276: PUSH
28277: LD_INT 0
28279: PUSH
28280: EMPTY
28281: LIST
28282: LIST
28283: PUSH
28284: LD_INT 1
28286: PUSH
28287: LD_INT 1
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: LD_INT 0
28296: PUSH
28297: LD_INT 1
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: LD_INT 1
28306: NEG
28307: PUSH
28308: LD_INT 0
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 1
28317: NEG
28318: PUSH
28319: LD_INT 1
28321: NEG
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PUSH
28327: LD_INT 1
28329: NEG
28330: PUSH
28331: LD_INT 2
28333: NEG
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: LD_INT 1
28341: PUSH
28342: LD_INT 1
28344: NEG
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: LD_INT 2
28352: PUSH
28353: LD_INT 0
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 2
28362: PUSH
28363: LD_INT 1
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 1
28372: PUSH
28373: LD_INT 2
28375: PUSH
28376: EMPTY
28377: LIST
28378: LIST
28379: PUSH
28380: LD_INT 0
28382: PUSH
28383: LD_INT 2
28385: PUSH
28386: EMPTY
28387: LIST
28388: LIST
28389: PUSH
28390: LD_INT 1
28392: NEG
28393: PUSH
28394: LD_INT 1
28396: PUSH
28397: EMPTY
28398: LIST
28399: LIST
28400: PUSH
28401: LD_INT 2
28403: NEG
28404: PUSH
28405: LD_INT 0
28407: PUSH
28408: EMPTY
28409: LIST
28410: LIST
28411: PUSH
28412: LD_INT 2
28414: NEG
28415: PUSH
28416: LD_INT 1
28418: NEG
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: LD_INT 2
28426: NEG
28427: PUSH
28428: LD_INT 2
28430: NEG
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 2
28438: NEG
28439: PUSH
28440: LD_INT 3
28442: NEG
28443: PUSH
28444: EMPTY
28445: LIST
28446: LIST
28447: PUSH
28448: LD_INT 2
28450: PUSH
28451: LD_INT 1
28453: NEG
28454: PUSH
28455: EMPTY
28456: LIST
28457: LIST
28458: PUSH
28459: LD_INT 3
28461: PUSH
28462: LD_INT 1
28464: PUSH
28465: EMPTY
28466: LIST
28467: LIST
28468: PUSH
28469: LD_INT 1
28471: PUSH
28472: LD_INT 3
28474: PUSH
28475: EMPTY
28476: LIST
28477: LIST
28478: PUSH
28479: LD_INT 1
28481: NEG
28482: PUSH
28483: LD_INT 2
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 3
28492: NEG
28493: PUSH
28494: LD_INT 2
28496: NEG
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: LIST
28506: LIST
28507: LIST
28508: LIST
28509: LIST
28510: LIST
28511: LIST
28512: LIST
28513: LIST
28514: LIST
28515: LIST
28516: LIST
28517: LIST
28518: LIST
28519: LIST
28520: LIST
28521: LIST
28522: LIST
28523: LIST
28524: LIST
28525: LIST
28526: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28527: LD_ADDR_VAR 0 34
28531: PUSH
28532: LD_INT 0
28534: PUSH
28535: LD_INT 0
28537: PUSH
28538: EMPTY
28539: LIST
28540: LIST
28541: PUSH
28542: LD_INT 0
28544: PUSH
28545: LD_INT 1
28547: NEG
28548: PUSH
28549: EMPTY
28550: LIST
28551: LIST
28552: PUSH
28553: LD_INT 1
28555: PUSH
28556: LD_INT 0
28558: PUSH
28559: EMPTY
28560: LIST
28561: LIST
28562: PUSH
28563: LD_INT 1
28565: PUSH
28566: LD_INT 1
28568: PUSH
28569: EMPTY
28570: LIST
28571: LIST
28572: PUSH
28573: LD_INT 0
28575: PUSH
28576: LD_INT 1
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PUSH
28583: LD_INT 1
28585: NEG
28586: PUSH
28587: LD_INT 0
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: PUSH
28594: LD_INT 1
28596: NEG
28597: PUSH
28598: LD_INT 1
28600: NEG
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 1
28608: NEG
28609: PUSH
28610: LD_INT 2
28612: NEG
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: LD_INT 0
28620: PUSH
28621: LD_INT 2
28623: NEG
28624: PUSH
28625: EMPTY
28626: LIST
28627: LIST
28628: PUSH
28629: LD_INT 1
28631: PUSH
28632: LD_INT 1
28634: NEG
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: PUSH
28640: LD_INT 2
28642: PUSH
28643: LD_INT 1
28645: PUSH
28646: EMPTY
28647: LIST
28648: LIST
28649: PUSH
28650: LD_INT 2
28652: PUSH
28653: LD_INT 2
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: LD_INT 1
28662: PUSH
28663: LD_INT 2
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 1
28672: NEG
28673: PUSH
28674: LD_INT 1
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 2
28683: NEG
28684: PUSH
28685: LD_INT 0
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: PUSH
28692: LD_INT 2
28694: NEG
28695: PUSH
28696: LD_INT 1
28698: NEG
28699: PUSH
28700: EMPTY
28701: LIST
28702: LIST
28703: PUSH
28704: LD_INT 2
28706: NEG
28707: PUSH
28708: LD_INT 2
28710: NEG
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: LD_INT 1
28718: NEG
28719: PUSH
28720: LD_INT 3
28722: NEG
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 1
28730: PUSH
28731: LD_INT 2
28733: NEG
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PUSH
28739: LD_INT 3
28741: PUSH
28742: LD_INT 2
28744: PUSH
28745: EMPTY
28746: LIST
28747: LIST
28748: PUSH
28749: LD_INT 2
28751: PUSH
28752: LD_INT 3
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 2
28761: NEG
28762: PUSH
28763: LD_INT 1
28765: PUSH
28766: EMPTY
28767: LIST
28768: LIST
28769: PUSH
28770: LD_INT 3
28772: NEG
28773: PUSH
28774: LD_INT 1
28776: NEG
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: LIST
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: LIST
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
28807: LD_ADDR_VAR 0 35
28811: PUSH
28812: LD_INT 0
28814: PUSH
28815: LD_INT 0
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: PUSH
28822: LD_INT 0
28824: PUSH
28825: LD_INT 1
28827: NEG
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: LD_INT 1
28835: PUSH
28836: LD_INT 0
28838: PUSH
28839: EMPTY
28840: LIST
28841: LIST
28842: PUSH
28843: LD_INT 1
28845: PUSH
28846: LD_INT 1
28848: PUSH
28849: EMPTY
28850: LIST
28851: LIST
28852: PUSH
28853: LD_INT 0
28855: PUSH
28856: LD_INT 1
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 1
28865: NEG
28866: PUSH
28867: LD_INT 0
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 1
28876: NEG
28877: PUSH
28878: LD_INT 1
28880: NEG
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 2
28888: PUSH
28889: LD_INT 1
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 2
28898: NEG
28899: PUSH
28900: LD_INT 1
28902: NEG
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: PUSH
28908: EMPTY
28909: LIST
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
28919: LD_ADDR_VAR 0 36
28923: PUSH
28924: LD_INT 0
28926: PUSH
28927: LD_INT 0
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PUSH
28934: LD_INT 0
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 1
28947: PUSH
28948: LD_INT 0
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 1
28957: PUSH
28958: LD_INT 1
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 0
28967: PUSH
28968: LD_INT 1
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: LD_INT 1
28977: NEG
28978: PUSH
28979: LD_INT 0
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: PUSH
28986: LD_INT 1
28988: NEG
28989: PUSH
28990: LD_INT 1
28992: NEG
28993: PUSH
28994: EMPTY
28995: LIST
28996: LIST
28997: PUSH
28998: LD_INT 1
29000: NEG
29001: PUSH
29002: LD_INT 2
29004: NEG
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: PUSH
29010: LD_INT 1
29012: PUSH
29013: LD_INT 2
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29031: LD_ADDR_VAR 0 37
29035: PUSH
29036: LD_INT 0
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 0
29048: PUSH
29049: LD_INT 1
29051: NEG
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 1
29059: PUSH
29060: LD_INT 0
29062: PUSH
29063: EMPTY
29064: LIST
29065: LIST
29066: PUSH
29067: LD_INT 1
29069: PUSH
29070: LD_INT 1
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 0
29079: PUSH
29080: LD_INT 1
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 1
29089: NEG
29090: PUSH
29091: LD_INT 0
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: LD_INT 1
29100: NEG
29101: PUSH
29102: LD_INT 1
29104: NEG
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 1
29112: PUSH
29113: LD_INT 1
29115: NEG
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: LD_INT 1
29123: NEG
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: LIST
29136: LIST
29137: LIST
29138: LIST
29139: LIST
29140: LIST
29141: LIST
29142: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29143: LD_ADDR_VAR 0 38
29147: PUSH
29148: LD_INT 0
29150: PUSH
29151: LD_INT 0
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: LD_INT 0
29160: PUSH
29161: LD_INT 1
29163: NEG
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: PUSH
29169: LD_INT 1
29171: PUSH
29172: LD_INT 0
29174: PUSH
29175: EMPTY
29176: LIST
29177: LIST
29178: PUSH
29179: LD_INT 1
29181: PUSH
29182: LD_INT 1
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PUSH
29189: LD_INT 0
29191: PUSH
29192: LD_INT 1
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PUSH
29199: LD_INT 1
29201: NEG
29202: PUSH
29203: LD_INT 0
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 1
29212: NEG
29213: PUSH
29214: LD_INT 1
29216: NEG
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 2
29224: PUSH
29225: LD_INT 1
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: PUSH
29232: LD_INT 2
29234: NEG
29235: PUSH
29236: LD_INT 1
29238: NEG
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: LIST
29251: LIST
29252: LIST
29253: LIST
29254: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29255: LD_ADDR_VAR 0 39
29259: PUSH
29260: LD_INT 0
29262: PUSH
29263: LD_INT 0
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PUSH
29270: LD_INT 0
29272: PUSH
29273: LD_INT 1
29275: NEG
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: LD_INT 1
29283: PUSH
29284: LD_INT 0
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: LD_INT 1
29293: PUSH
29294: LD_INT 1
29296: PUSH
29297: EMPTY
29298: LIST
29299: LIST
29300: PUSH
29301: LD_INT 0
29303: PUSH
29304: LD_INT 1
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 1
29313: NEG
29314: PUSH
29315: LD_INT 0
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 1
29324: NEG
29325: PUSH
29326: LD_INT 1
29328: NEG
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: LD_INT 1
29336: NEG
29337: PUSH
29338: LD_INT 2
29340: NEG
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 1
29348: PUSH
29349: LD_INT 2
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: LIST
29360: LIST
29361: LIST
29362: LIST
29363: LIST
29364: LIST
29365: LIST
29366: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29367: LD_ADDR_VAR 0 40
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 0
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 0
29384: PUSH
29385: LD_INT 1
29387: NEG
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 1
29395: PUSH
29396: LD_INT 0
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 1
29405: PUSH
29406: LD_INT 1
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: LD_INT 0
29415: PUSH
29416: LD_INT 1
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: PUSH
29423: LD_INT 1
29425: NEG
29426: PUSH
29427: LD_INT 0
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 1
29436: NEG
29437: PUSH
29438: LD_INT 1
29440: NEG
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: LD_INT 1
29448: PUSH
29449: LD_INT 1
29451: NEG
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: PUSH
29457: LD_INT 1
29459: NEG
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: EMPTY
29469: LIST
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29479: LD_ADDR_VAR 0 41
29483: PUSH
29484: LD_INT 0
29486: PUSH
29487: LD_INT 0
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: PUSH
29494: LD_INT 0
29496: PUSH
29497: LD_INT 1
29499: NEG
29500: PUSH
29501: EMPTY
29502: LIST
29503: LIST
29504: PUSH
29505: LD_INT 1
29507: PUSH
29508: LD_INT 0
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 1
29517: PUSH
29518: LD_INT 1
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PUSH
29525: LD_INT 0
29527: PUSH
29528: LD_INT 1
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 1
29537: NEG
29538: PUSH
29539: LD_INT 0
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 1
29548: NEG
29549: PUSH
29550: LD_INT 1
29552: NEG
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: LD_INT 2
29564: NEG
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PUSH
29570: LD_INT 1
29572: PUSH
29573: LD_INT 1
29575: NEG
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: LD_INT 2
29583: PUSH
29584: LD_INT 0
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 2
29593: PUSH
29594: LD_INT 1
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PUSH
29601: LD_INT 2
29603: PUSH
29604: LD_INT 2
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: PUSH
29611: LD_INT 1
29613: PUSH
29614: LD_INT 2
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 1
29623: NEG
29624: PUSH
29625: LD_INT 1
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: LD_INT 2
29634: NEG
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 2
29645: NEG
29646: PUSH
29647: LD_INT 1
29649: NEG
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 2
29657: NEG
29658: PUSH
29659: LD_INT 2
29661: NEG
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 2
29669: NEG
29670: PUSH
29671: LD_INT 3
29673: NEG
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PUSH
29679: LD_INT 2
29681: PUSH
29682: LD_INT 1
29684: NEG
29685: PUSH
29686: EMPTY
29687: LIST
29688: LIST
29689: PUSH
29690: LD_INT 3
29692: PUSH
29693: LD_INT 0
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 3
29702: PUSH
29703: LD_INT 1
29705: PUSH
29706: EMPTY
29707: LIST
29708: LIST
29709: PUSH
29710: LD_INT 3
29712: PUSH
29713: LD_INT 2
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: LD_INT 3
29722: PUSH
29723: LD_INT 3
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 2
29732: PUSH
29733: LD_INT 3
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: LD_INT 2
29742: NEG
29743: PUSH
29744: LD_INT 1
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PUSH
29751: LD_INT 3
29753: NEG
29754: PUSH
29755: LD_INT 0
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 3
29764: NEG
29765: PUSH
29766: LD_INT 1
29768: NEG
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 3
29776: NEG
29777: PUSH
29778: LD_INT 2
29780: NEG
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 3
29788: NEG
29789: PUSH
29790: LD_INT 3
29792: NEG
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: LIST
29828: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29829: LD_ADDR_VAR 0 42
29833: PUSH
29834: LD_INT 0
29836: PUSH
29837: LD_INT 0
29839: PUSH
29840: EMPTY
29841: LIST
29842: LIST
29843: PUSH
29844: LD_INT 0
29846: PUSH
29847: LD_INT 1
29849: NEG
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: PUSH
29855: LD_INT 1
29857: PUSH
29858: LD_INT 0
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 1
29867: PUSH
29868: LD_INT 1
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 0
29877: PUSH
29878: LD_INT 1
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: LD_INT 0
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: LD_INT 1
29898: NEG
29899: PUSH
29900: LD_INT 1
29902: NEG
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 1
29910: NEG
29911: PUSH
29912: LD_INT 2
29914: NEG
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: PUSH
29920: LD_INT 0
29922: PUSH
29923: LD_INT 2
29925: NEG
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: LD_INT 1
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: PUSH
29942: LD_INT 2
29944: PUSH
29945: LD_INT 1
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 2
29954: PUSH
29955: LD_INT 2
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: LD_INT 2
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 0
29974: PUSH
29975: LD_INT 2
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 1
29984: NEG
29985: PUSH
29986: LD_INT 1
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: PUSH
29993: LD_INT 2
29995: NEG
29996: PUSH
29997: LD_INT 1
29999: NEG
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: LD_INT 2
30007: NEG
30008: PUSH
30009: LD_INT 2
30011: NEG
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 2
30019: NEG
30020: PUSH
30021: LD_INT 3
30023: NEG
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 1
30031: NEG
30032: PUSH
30033: LD_INT 3
30035: NEG
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PUSH
30041: LD_INT 0
30043: PUSH
30044: LD_INT 3
30046: NEG
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 1
30054: PUSH
30055: LD_INT 2
30057: NEG
30058: PUSH
30059: EMPTY
30060: LIST
30061: LIST
30062: PUSH
30063: LD_INT 3
30065: PUSH
30066: LD_INT 2
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 3
30075: PUSH
30076: LD_INT 3
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 2
30085: PUSH
30086: LD_INT 3
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: LD_INT 3
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: PUSH
30103: LD_INT 0
30105: PUSH
30106: LD_INT 3
30108: PUSH
30109: EMPTY
30110: LIST
30111: LIST
30112: PUSH
30113: LD_INT 1
30115: NEG
30116: PUSH
30117: LD_INT 2
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PUSH
30124: LD_INT 3
30126: NEG
30127: PUSH
30128: LD_INT 2
30130: NEG
30131: PUSH
30132: EMPTY
30133: LIST
30134: LIST
30135: PUSH
30136: LD_INT 3
30138: NEG
30139: PUSH
30140: LD_INT 3
30142: NEG
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: LIST
30170: LIST
30171: LIST
30172: LIST
30173: LIST
30174: LIST
30175: LIST
30176: LIST
30177: LIST
30178: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30179: LD_ADDR_VAR 0 43
30183: PUSH
30184: LD_INT 0
30186: PUSH
30187: LD_INT 0
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 0
30196: PUSH
30197: LD_INT 1
30199: NEG
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 1
30207: PUSH
30208: LD_INT 0
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 1
30217: PUSH
30218: LD_INT 1
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 0
30227: PUSH
30228: LD_INT 1
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: NEG
30238: PUSH
30239: LD_INT 0
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 1
30248: NEG
30249: PUSH
30250: LD_INT 1
30252: NEG
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 1
30260: NEG
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 0
30272: PUSH
30273: LD_INT 2
30275: NEG
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 1
30283: PUSH
30284: LD_INT 1
30286: NEG
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 2
30294: PUSH
30295: LD_INT 0
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PUSH
30302: LD_INT 2
30304: PUSH
30305: LD_INT 1
30307: PUSH
30308: EMPTY
30309: LIST
30310: LIST
30311: PUSH
30312: LD_INT 1
30314: PUSH
30315: LD_INT 2
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 0
30324: PUSH
30325: LD_INT 2
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: LD_INT 1
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 2
30345: NEG
30346: PUSH
30347: LD_INT 0
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 2
30356: NEG
30357: PUSH
30358: LD_INT 1
30360: NEG
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: NEG
30369: PUSH
30370: LD_INT 3
30372: NEG
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: LD_INT 3
30383: NEG
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 1
30391: PUSH
30392: LD_INT 2
30394: NEG
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PUSH
30400: LD_INT 2
30402: PUSH
30403: LD_INT 1
30405: NEG
30406: PUSH
30407: EMPTY
30408: LIST
30409: LIST
30410: PUSH
30411: LD_INT 3
30413: PUSH
30414: LD_INT 0
30416: PUSH
30417: EMPTY
30418: LIST
30419: LIST
30420: PUSH
30421: LD_INT 3
30423: PUSH
30424: LD_INT 1
30426: PUSH
30427: EMPTY
30428: LIST
30429: LIST
30430: PUSH
30431: LD_INT 1
30433: PUSH
30434: LD_INT 3
30436: PUSH
30437: EMPTY
30438: LIST
30439: LIST
30440: PUSH
30441: LD_INT 0
30443: PUSH
30444: LD_INT 3
30446: PUSH
30447: EMPTY
30448: LIST
30449: LIST
30450: PUSH
30451: LD_INT 1
30453: NEG
30454: PUSH
30455: LD_INT 2
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: PUSH
30462: LD_INT 2
30464: NEG
30465: PUSH
30466: LD_INT 1
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: LD_INT 3
30475: NEG
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 3
30486: NEG
30487: PUSH
30488: LD_INT 1
30490: NEG
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: LIST
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30527: LD_ADDR_VAR 0 44
30531: PUSH
30532: LD_INT 0
30534: PUSH
30535: LD_INT 0
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: PUSH
30542: LD_INT 0
30544: PUSH
30545: LD_INT 1
30547: NEG
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: LD_INT 1
30555: PUSH
30556: LD_INT 0
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 1
30565: PUSH
30566: LD_INT 1
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: LD_INT 1
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 1
30585: NEG
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: NEG
30609: PUSH
30610: LD_INT 2
30612: NEG
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 1
30620: PUSH
30621: LD_INT 1
30623: NEG
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 2
30631: PUSH
30632: LD_INT 0
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: PUSH
30639: LD_INT 2
30641: PUSH
30642: LD_INT 1
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 2
30651: PUSH
30652: LD_INT 2
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 1
30661: PUSH
30662: LD_INT 2
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 1
30671: NEG
30672: PUSH
30673: LD_INT 1
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 2
30682: NEG
30683: PUSH
30684: LD_INT 0
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 2
30693: NEG
30694: PUSH
30695: LD_INT 1
30697: NEG
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: LD_INT 2
30705: NEG
30706: PUSH
30707: LD_INT 2
30709: NEG
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: PUSH
30715: LD_INT 2
30717: NEG
30718: PUSH
30719: LD_INT 3
30721: NEG
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: LD_INT 2
30729: PUSH
30730: LD_INT 1
30732: NEG
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: LD_INT 3
30740: PUSH
30741: LD_INT 0
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: PUSH
30748: LD_INT 3
30750: PUSH
30751: LD_INT 1
30753: PUSH
30754: EMPTY
30755: LIST
30756: LIST
30757: PUSH
30758: LD_INT 3
30760: PUSH
30761: LD_INT 2
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: PUSH
30768: LD_INT 3
30770: PUSH
30771: LD_INT 3
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 2
30780: PUSH
30781: LD_INT 3
30783: PUSH
30784: EMPTY
30785: LIST
30786: LIST
30787: PUSH
30788: LD_INT 2
30790: NEG
30791: PUSH
30792: LD_INT 1
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 3
30801: NEG
30802: PUSH
30803: LD_INT 0
30805: PUSH
30806: EMPTY
30807: LIST
30808: LIST
30809: PUSH
30810: LD_INT 3
30812: NEG
30813: PUSH
30814: LD_INT 1
30816: NEG
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: PUSH
30822: LD_INT 3
30824: NEG
30825: PUSH
30826: LD_INT 2
30828: NEG
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 3
30836: NEG
30837: PUSH
30838: LD_INT 3
30840: NEG
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: LIST
30874: LIST
30875: LIST
30876: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30877: LD_ADDR_VAR 0 45
30881: PUSH
30882: LD_INT 0
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 0
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 1
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 1
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 0
30925: PUSH
30926: LD_INT 1
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: LD_INT 1
30935: NEG
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 1
30946: NEG
30947: PUSH
30948: LD_INT 1
30950: NEG
30951: PUSH
30952: EMPTY
30953: LIST
30954: LIST
30955: PUSH
30956: LD_INT 1
30958: NEG
30959: PUSH
30960: LD_INT 2
30962: NEG
30963: PUSH
30964: EMPTY
30965: LIST
30966: LIST
30967: PUSH
30968: LD_INT 0
30970: PUSH
30971: LD_INT 2
30973: NEG
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 1
30981: PUSH
30982: LD_INT 1
30984: NEG
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 2
30992: PUSH
30993: LD_INT 1
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 2
31002: PUSH
31003: LD_INT 2
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 1
31012: PUSH
31013: LD_INT 2
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 0
31022: PUSH
31023: LD_INT 2
31025: PUSH
31026: EMPTY
31027: LIST
31028: LIST
31029: PUSH
31030: LD_INT 1
31032: NEG
31033: PUSH
31034: LD_INT 1
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 2
31043: NEG
31044: PUSH
31045: LD_INT 1
31047: NEG
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PUSH
31053: LD_INT 2
31055: NEG
31056: PUSH
31057: LD_INT 2
31059: NEG
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: LD_INT 2
31067: NEG
31068: PUSH
31069: LD_INT 3
31071: NEG
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 1
31079: NEG
31080: PUSH
31081: LD_INT 3
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 0
31091: PUSH
31092: LD_INT 3
31094: NEG
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 1
31102: PUSH
31103: LD_INT 2
31105: NEG
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 3
31113: PUSH
31114: LD_INT 2
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 3
31123: PUSH
31124: LD_INT 3
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: PUSH
31131: LD_INT 2
31133: PUSH
31134: LD_INT 3
31136: PUSH
31137: EMPTY
31138: LIST
31139: LIST
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: LD_INT 3
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 0
31153: PUSH
31154: LD_INT 3
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 1
31163: NEG
31164: PUSH
31165: LD_INT 2
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 3
31174: NEG
31175: PUSH
31176: LD_INT 2
31178: NEG
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 3
31186: NEG
31187: PUSH
31188: LD_INT 3
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: LIST
31203: LIST
31204: LIST
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: LIST
31210: LIST
31211: LIST
31212: LIST
31213: LIST
31214: LIST
31215: LIST
31216: LIST
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: LIST
31223: LIST
31224: LIST
31225: LIST
31226: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31227: LD_ADDR_VAR 0 46
31231: PUSH
31232: LD_INT 0
31234: PUSH
31235: LD_INT 0
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 0
31244: PUSH
31245: LD_INT 1
31247: NEG
31248: PUSH
31249: EMPTY
31250: LIST
31251: LIST
31252: PUSH
31253: LD_INT 1
31255: PUSH
31256: LD_INT 0
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 1
31265: PUSH
31266: LD_INT 1
31268: PUSH
31269: EMPTY
31270: LIST
31271: LIST
31272: PUSH
31273: LD_INT 0
31275: PUSH
31276: LD_INT 1
31278: PUSH
31279: EMPTY
31280: LIST
31281: LIST
31282: PUSH
31283: LD_INT 1
31285: NEG
31286: PUSH
31287: LD_INT 0
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: LD_INT 1
31296: NEG
31297: PUSH
31298: LD_INT 1
31300: NEG
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 1
31308: NEG
31309: PUSH
31310: LD_INT 2
31312: NEG
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: LD_INT 0
31320: PUSH
31321: LD_INT 2
31323: NEG
31324: PUSH
31325: EMPTY
31326: LIST
31327: LIST
31328: PUSH
31329: LD_INT 1
31331: PUSH
31332: LD_INT 1
31334: NEG
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 2
31342: PUSH
31343: LD_INT 0
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 2
31352: PUSH
31353: LD_INT 1
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 1
31362: PUSH
31363: LD_INT 2
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 0
31372: PUSH
31373: LD_INT 2
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 1
31382: NEG
31383: PUSH
31384: LD_INT 1
31386: PUSH
31387: EMPTY
31388: LIST
31389: LIST
31390: PUSH
31391: LD_INT 2
31393: NEG
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 2
31404: NEG
31405: PUSH
31406: LD_INT 1
31408: NEG
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 1
31416: NEG
31417: PUSH
31418: LD_INT 3
31420: NEG
31421: PUSH
31422: EMPTY
31423: LIST
31424: LIST
31425: PUSH
31426: LD_INT 0
31428: PUSH
31429: LD_INT 3
31431: NEG
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 1
31439: PUSH
31440: LD_INT 2
31442: NEG
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 2
31450: PUSH
31451: LD_INT 1
31453: NEG
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 3
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 3
31471: PUSH
31472: LD_INT 1
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: LD_INT 1
31481: PUSH
31482: LD_INT 3
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: LD_INT 0
31491: PUSH
31492: LD_INT 3
31494: PUSH
31495: EMPTY
31496: LIST
31497: LIST
31498: PUSH
31499: LD_INT 1
31501: NEG
31502: PUSH
31503: LD_INT 2
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 2
31512: NEG
31513: PUSH
31514: LD_INT 1
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: LD_INT 3
31523: NEG
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 3
31534: NEG
31535: PUSH
31536: LD_INT 1
31538: NEG
31539: PUSH
31540: EMPTY
31541: LIST
31542: LIST
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: LIST
31559: LIST
31560: LIST
31561: LIST
31562: LIST
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: LIST
31571: LIST
31572: LIST
31573: LIST
31574: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31575: LD_ADDR_VAR 0 47
31579: PUSH
31580: LD_INT 0
31582: PUSH
31583: LD_INT 0
31585: PUSH
31586: EMPTY
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 0
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 1
31603: PUSH
31604: LD_INT 0
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 1
31613: PUSH
31614: LD_INT 1
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 0
31623: PUSH
31624: LD_INT 1
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 1
31633: NEG
31634: PUSH
31635: LD_INT 0
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: LD_INT 1
31648: NEG
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 1
31656: NEG
31657: PUSH
31658: LD_INT 2
31660: NEG
31661: PUSH
31662: EMPTY
31663: LIST
31664: LIST
31665: PUSH
31666: LD_INT 0
31668: PUSH
31669: LD_INT 2
31671: NEG
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: PUSH
31680: LD_INT 1
31682: NEG
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 2
31690: NEG
31691: PUSH
31692: LD_INT 1
31694: NEG
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 2
31702: NEG
31703: PUSH
31704: LD_INT 2
31706: NEG
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
31726: LD_ADDR_VAR 0 48
31730: PUSH
31731: LD_INT 0
31733: PUSH
31734: LD_INT 0
31736: PUSH
31737: EMPTY
31738: LIST
31739: LIST
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: LD_INT 1
31746: NEG
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 1
31754: PUSH
31755: LD_INT 0
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 1
31764: PUSH
31765: LD_INT 1
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: LD_INT 0
31774: PUSH
31775: LD_INT 1
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 1
31784: NEG
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: EMPTY
31790: LIST
31791: LIST
31792: PUSH
31793: LD_INT 1
31795: NEG
31796: PUSH
31797: LD_INT 1
31799: NEG
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 1
31807: NEG
31808: PUSH
31809: LD_INT 2
31811: NEG
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 0
31819: PUSH
31820: LD_INT 2
31822: NEG
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 1
31830: PUSH
31831: LD_INT 1
31833: NEG
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 2
31841: PUSH
31842: LD_INT 0
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 2
31851: PUSH
31852: LD_INT 1
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
31873: LD_ADDR_VAR 0 49
31877: PUSH
31878: LD_INT 0
31880: PUSH
31881: LD_INT 0
31883: PUSH
31884: EMPTY
31885: LIST
31886: LIST
31887: PUSH
31888: LD_INT 0
31890: PUSH
31891: LD_INT 1
31893: NEG
31894: PUSH
31895: EMPTY
31896: LIST
31897: LIST
31898: PUSH
31899: LD_INT 1
31901: PUSH
31902: LD_INT 0
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PUSH
31909: LD_INT 1
31911: PUSH
31912: LD_INT 1
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 0
31921: PUSH
31922: LD_INT 1
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 1
31931: NEG
31932: PUSH
31933: LD_INT 0
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 1
31942: NEG
31943: PUSH
31944: LD_INT 1
31946: NEG
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PUSH
31952: LD_INT 1
31954: PUSH
31955: LD_INT 1
31957: NEG
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: LD_INT 0
31968: PUSH
31969: EMPTY
31970: LIST
31971: LIST
31972: PUSH
31973: LD_INT 2
31975: PUSH
31976: LD_INT 1
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 2
31985: PUSH
31986: LD_INT 2
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 1
31995: PUSH
31996: LD_INT 2
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: LIST
32007: LIST
32008: LIST
32009: LIST
32010: LIST
32011: LIST
32012: LIST
32013: LIST
32014: LIST
32015: LIST
32016: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32017: LD_ADDR_VAR 0 50
32021: PUSH
32022: LD_INT 0
32024: PUSH
32025: LD_INT 0
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: LD_INT 0
32034: PUSH
32035: LD_INT 1
32037: NEG
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PUSH
32043: LD_INT 1
32045: PUSH
32046: LD_INT 0
32048: PUSH
32049: EMPTY
32050: LIST
32051: LIST
32052: PUSH
32053: LD_INT 1
32055: PUSH
32056: LD_INT 1
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: PUSH
32063: LD_INT 0
32065: PUSH
32066: LD_INT 1
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 1
32075: NEG
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 1
32086: NEG
32087: PUSH
32088: LD_INT 1
32090: NEG
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 2
32098: PUSH
32099: LD_INT 1
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 2
32108: PUSH
32109: LD_INT 2
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 1
32118: PUSH
32119: LD_INT 2
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 0
32128: PUSH
32129: LD_INT 2
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 1
32138: NEG
32139: PUSH
32140: LD_INT 1
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: LIST
32155: LIST
32156: LIST
32157: LIST
32158: LIST
32159: LIST
32160: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32161: LD_ADDR_VAR 0 51
32165: PUSH
32166: LD_INT 0
32168: PUSH
32169: LD_INT 0
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 0
32178: PUSH
32179: LD_INT 1
32181: NEG
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: LD_INT 1
32189: PUSH
32190: LD_INT 0
32192: PUSH
32193: EMPTY
32194: LIST
32195: LIST
32196: PUSH
32197: LD_INT 1
32199: PUSH
32200: LD_INT 1
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: PUSH
32207: LD_INT 0
32209: PUSH
32210: LD_INT 1
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 1
32219: NEG
32220: PUSH
32221: LD_INT 0
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: LD_INT 1
32230: NEG
32231: PUSH
32232: LD_INT 1
32234: NEG
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 1
32242: PUSH
32243: LD_INT 2
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 0
32252: PUSH
32253: LD_INT 2
32255: PUSH
32256: EMPTY
32257: LIST
32258: LIST
32259: PUSH
32260: LD_INT 1
32262: NEG
32263: PUSH
32264: LD_INT 1
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 2
32273: NEG
32274: PUSH
32275: LD_INT 0
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 2
32284: NEG
32285: PUSH
32286: LD_INT 1
32288: NEG
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32308: LD_ADDR_VAR 0 52
32312: PUSH
32313: LD_INT 0
32315: PUSH
32316: LD_INT 0
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 0
32325: PUSH
32326: LD_INT 1
32328: NEG
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 1
32336: PUSH
32337: LD_INT 0
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 1
32346: PUSH
32347: LD_INT 1
32349: PUSH
32350: EMPTY
32351: LIST
32352: LIST
32353: PUSH
32354: LD_INT 0
32356: PUSH
32357: LD_INT 1
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 1
32366: NEG
32367: PUSH
32368: LD_INT 0
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: LD_INT 1
32377: NEG
32378: PUSH
32379: LD_INT 1
32381: NEG
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 1
32389: NEG
32390: PUSH
32391: LD_INT 2
32393: NEG
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 1
32401: NEG
32402: PUSH
32403: LD_INT 1
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 2
32412: NEG
32413: PUSH
32414: LD_INT 0
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: LD_INT 2
32423: NEG
32424: PUSH
32425: LD_INT 1
32427: NEG
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 2
32435: NEG
32436: PUSH
32437: LD_INT 2
32439: NEG
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32459: LD_ADDR_VAR 0 53
32463: PUSH
32464: LD_INT 0
32466: PUSH
32467: LD_INT 0
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: PUSH
32474: LD_INT 0
32476: PUSH
32477: LD_INT 1
32479: NEG
32480: PUSH
32481: EMPTY
32482: LIST
32483: LIST
32484: PUSH
32485: LD_INT 1
32487: PUSH
32488: LD_INT 0
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 1
32497: PUSH
32498: LD_INT 1
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: LD_INT 0
32507: PUSH
32508: LD_INT 1
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: LD_INT 1
32517: NEG
32518: PUSH
32519: LD_INT 0
32521: PUSH
32522: EMPTY
32523: LIST
32524: LIST
32525: PUSH
32526: LD_INT 1
32528: NEG
32529: PUSH
32530: LD_INT 1
32532: NEG
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: PUSH
32538: LD_INT 1
32540: NEG
32541: PUSH
32542: LD_INT 2
32544: NEG
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 0
32552: PUSH
32553: LD_INT 2
32555: NEG
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 1
32563: PUSH
32564: LD_INT 1
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 2
32574: PUSH
32575: LD_INT 0
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: LD_INT 2
32584: PUSH
32585: LD_INT 1
32587: PUSH
32588: EMPTY
32589: LIST
32590: LIST
32591: PUSH
32592: LD_INT 2
32594: PUSH
32595: LD_INT 2
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: PUSH
32602: LD_INT 1
32604: PUSH
32605: LD_INT 2
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 0
32614: PUSH
32615: LD_INT 2
32617: PUSH
32618: EMPTY
32619: LIST
32620: LIST
32621: PUSH
32622: LD_INT 1
32624: NEG
32625: PUSH
32626: LD_INT 1
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 2
32635: NEG
32636: PUSH
32637: LD_INT 0
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 2
32646: NEG
32647: PUSH
32648: LD_INT 1
32650: NEG
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PUSH
32656: LD_INT 2
32658: NEG
32659: PUSH
32660: LD_INT 2
32662: NEG
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: LIST
32672: LIST
32673: LIST
32674: LIST
32675: LIST
32676: LIST
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32689: LD_ADDR_VAR 0 54
32693: PUSH
32694: LD_INT 0
32696: PUSH
32697: LD_INT 0
32699: PUSH
32700: EMPTY
32701: LIST
32702: LIST
32703: PUSH
32704: LD_INT 0
32706: PUSH
32707: LD_INT 1
32709: NEG
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 1
32717: PUSH
32718: LD_INT 0
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 1
32727: PUSH
32728: LD_INT 1
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 0
32737: PUSH
32738: LD_INT 1
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 1
32747: NEG
32748: PUSH
32749: LD_INT 0
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PUSH
32756: LD_INT 1
32758: NEG
32759: PUSH
32760: LD_INT 1
32762: NEG
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 1
32770: NEG
32771: PUSH
32772: LD_INT 2
32774: NEG
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: LD_INT 2
32785: NEG
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 1
32793: PUSH
32794: LD_INT 1
32796: NEG
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 2
32804: PUSH
32805: LD_INT 0
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 2
32814: PUSH
32815: LD_INT 1
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 2
32824: PUSH
32825: LD_INT 2
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 1
32834: PUSH
32835: LD_INT 2
32837: PUSH
32838: EMPTY
32839: LIST
32840: LIST
32841: PUSH
32842: LD_INT 0
32844: PUSH
32845: LD_INT 2
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 1
32854: NEG
32855: PUSH
32856: LD_INT 1
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: LD_INT 2
32865: NEG
32866: PUSH
32867: LD_INT 0
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 2
32876: NEG
32877: PUSH
32878: LD_INT 1
32880: NEG
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 2
32888: NEG
32889: PUSH
32890: LD_INT 2
32892: NEG
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: LIST
32902: LIST
32903: LIST
32904: LIST
32905: LIST
32906: LIST
32907: LIST
32908: LIST
32909: LIST
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32919: LD_ADDR_VAR 0 55
32923: PUSH
32924: LD_INT 0
32926: PUSH
32927: LD_INT 0
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 0
32936: PUSH
32937: LD_INT 1
32939: NEG
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PUSH
32945: LD_INT 1
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: PUSH
32958: LD_INT 1
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: LD_INT 0
32967: PUSH
32968: LD_INT 1
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 1
32977: NEG
32978: PUSH
32979: LD_INT 0
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 1
32988: NEG
32989: PUSH
32990: LD_INT 1
32992: NEG
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 1
33000: NEG
33001: PUSH
33002: LD_INT 2
33004: NEG
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 0
33012: PUSH
33013: LD_INT 2
33015: NEG
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 1
33023: PUSH
33024: LD_INT 1
33026: NEG
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: LD_INT 2
33034: PUSH
33035: LD_INT 0
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: PUSH
33042: LD_INT 2
33044: PUSH
33045: LD_INT 1
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 2
33054: PUSH
33055: LD_INT 2
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: LD_INT 2
33067: PUSH
33068: EMPTY
33069: LIST
33070: LIST
33071: PUSH
33072: LD_INT 0
33074: PUSH
33075: LD_INT 2
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: PUSH
33082: LD_INT 1
33084: NEG
33085: PUSH
33086: LD_INT 1
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 2
33095: NEG
33096: PUSH
33097: LD_INT 0
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 2
33106: NEG
33107: PUSH
33108: LD_INT 1
33110: NEG
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 2
33118: NEG
33119: PUSH
33120: LD_INT 2
33122: NEG
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33149: LD_ADDR_VAR 0 56
33153: PUSH
33154: LD_INT 0
33156: PUSH
33157: LD_INT 0
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 0
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 1
33177: PUSH
33178: LD_INT 0
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 1
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 0
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 1
33207: NEG
33208: PUSH
33209: LD_INT 0
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: LD_INT 1
33218: NEG
33219: PUSH
33220: LD_INT 1
33222: NEG
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 1
33230: NEG
33231: PUSH
33232: LD_INT 2
33234: NEG
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: PUSH
33240: LD_INT 0
33242: PUSH
33243: LD_INT 2
33245: NEG
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 1
33253: PUSH
33254: LD_INT 1
33256: NEG
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 2
33264: PUSH
33265: LD_INT 0
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: PUSH
33272: LD_INT 2
33274: PUSH
33275: LD_INT 1
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 2
33284: PUSH
33285: LD_INT 2
33287: PUSH
33288: EMPTY
33289: LIST
33290: LIST
33291: PUSH
33292: LD_INT 1
33294: PUSH
33295: LD_INT 2
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 0
33304: PUSH
33305: LD_INT 2
33307: PUSH
33308: EMPTY
33309: LIST
33310: LIST
33311: PUSH
33312: LD_INT 1
33314: NEG
33315: PUSH
33316: LD_INT 1
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PUSH
33323: LD_INT 2
33325: NEG
33326: PUSH
33327: LD_INT 0
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 2
33336: NEG
33337: PUSH
33338: LD_INT 1
33340: NEG
33341: PUSH
33342: EMPTY
33343: LIST
33344: LIST
33345: PUSH
33346: LD_INT 2
33348: NEG
33349: PUSH
33350: LD_INT 2
33352: NEG
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: EMPTY
33359: LIST
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33379: LD_ADDR_VAR 0 57
33383: PUSH
33384: LD_INT 0
33386: PUSH
33387: LD_INT 0
33389: PUSH
33390: EMPTY
33391: LIST
33392: LIST
33393: PUSH
33394: LD_INT 0
33396: PUSH
33397: LD_INT 1
33399: NEG
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 1
33407: PUSH
33408: LD_INT 0
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: LD_INT 1
33417: PUSH
33418: LD_INT 1
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: LD_INT 1
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 1
33437: NEG
33438: PUSH
33439: LD_INT 0
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: LD_INT 1
33448: NEG
33449: PUSH
33450: LD_INT 1
33452: NEG
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: LD_INT 1
33460: NEG
33461: PUSH
33462: LD_INT 2
33464: NEG
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 0
33472: PUSH
33473: LD_INT 2
33475: NEG
33476: PUSH
33477: EMPTY
33478: LIST
33479: LIST
33480: PUSH
33481: LD_INT 1
33483: PUSH
33484: LD_INT 1
33486: NEG
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 2
33494: PUSH
33495: LD_INT 0
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 2
33504: PUSH
33505: LD_INT 1
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 2
33514: PUSH
33515: LD_INT 2
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 1
33524: PUSH
33525: LD_INT 2
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 0
33534: PUSH
33535: LD_INT 2
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 1
33544: NEG
33545: PUSH
33546: LD_INT 1
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 2
33555: NEG
33556: PUSH
33557: LD_INT 0
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 2
33566: NEG
33567: PUSH
33568: LD_INT 1
33570: NEG
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 2
33578: NEG
33579: PUSH
33580: LD_INT 2
33582: NEG
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33609: LD_ADDR_VAR 0 58
33613: PUSH
33614: LD_INT 0
33616: PUSH
33617: LD_INT 0
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: PUSH
33624: LD_INT 0
33626: PUSH
33627: LD_INT 1
33629: NEG
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: LD_INT 1
33637: PUSH
33638: LD_INT 0
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 1
33647: PUSH
33648: LD_INT 1
33650: PUSH
33651: EMPTY
33652: LIST
33653: LIST
33654: PUSH
33655: LD_INT 0
33657: PUSH
33658: LD_INT 1
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 1
33667: NEG
33668: PUSH
33669: LD_INT 0
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: LD_INT 1
33678: NEG
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 1
33690: NEG
33691: PUSH
33692: LD_INT 2
33694: NEG
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 0
33702: PUSH
33703: LD_INT 2
33705: NEG
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 1
33713: PUSH
33714: LD_INT 1
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 2
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 2
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: PUSH
33742: LD_INT 2
33744: PUSH
33745: LD_INT 2
33747: PUSH
33748: EMPTY
33749: LIST
33750: LIST
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: LD_INT 2
33757: PUSH
33758: EMPTY
33759: LIST
33760: LIST
33761: PUSH
33762: LD_INT 0
33764: PUSH
33765: LD_INT 2
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: PUSH
33772: LD_INT 1
33774: NEG
33775: PUSH
33776: LD_INT 1
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 2
33785: NEG
33786: PUSH
33787: LD_INT 0
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 2
33796: NEG
33797: PUSH
33798: LD_INT 1
33800: NEG
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: LD_INT 2
33812: NEG
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
33839: LD_ADDR_VAR 0 59
33843: PUSH
33844: LD_INT 0
33846: PUSH
33847: LD_INT 0
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: LD_INT 1
33859: NEG
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 1
33867: PUSH
33868: LD_INT 0
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: LD_INT 1
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: LD_INT 1
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: NEG
33898: PUSH
33899: LD_INT 0
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: EMPTY
33919: LIST
33920: LIST
33921: LIST
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
33927: LD_ADDR_VAR 0 60
33931: PUSH
33932: LD_INT 0
33934: PUSH
33935: LD_INT 0
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: LD_INT 1
33947: NEG
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 1
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: LD_INT 1
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 0
33975: PUSH
33976: LD_INT 1
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 1
33985: NEG
33986: PUSH
33987: LD_INT 0
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: PUSH
33994: LD_INT 1
33996: NEG
33997: PUSH
33998: LD_INT 1
34000: NEG
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: LIST
34010: LIST
34011: LIST
34012: LIST
34013: LIST
34014: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34015: LD_ADDR_VAR 0 61
34019: PUSH
34020: LD_INT 0
34022: PUSH
34023: LD_INT 0
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: PUSH
34030: LD_INT 0
34032: PUSH
34033: LD_INT 1
34035: NEG
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 1
34043: PUSH
34044: LD_INT 0
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: LD_INT 1
34053: PUSH
34054: LD_INT 1
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 0
34063: PUSH
34064: LD_INT 1
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: LD_INT 1
34073: NEG
34074: PUSH
34075: LD_INT 0
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: PUSH
34082: LD_INT 1
34084: NEG
34085: PUSH
34086: LD_INT 1
34088: NEG
34089: PUSH
34090: EMPTY
34091: LIST
34092: LIST
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: LIST
34102: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34103: LD_ADDR_VAR 0 62
34107: PUSH
34108: LD_INT 0
34110: PUSH
34111: LD_INT 0
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 0
34120: PUSH
34121: LD_INT 1
34123: NEG
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 1
34131: PUSH
34132: LD_INT 0
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 1
34141: PUSH
34142: LD_INT 1
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: LD_INT 0
34151: PUSH
34152: LD_INT 1
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 0
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: LD_INT 1
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: EMPTY
34183: LIST
34184: LIST
34185: LIST
34186: LIST
34187: LIST
34188: LIST
34189: LIST
34190: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34191: LD_ADDR_VAR 0 63
34195: PUSH
34196: LD_INT 0
34198: PUSH
34199: LD_INT 0
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 0
34208: PUSH
34209: LD_INT 1
34211: NEG
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: LD_INT 0
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: LD_INT 1
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 0
34239: PUSH
34240: LD_INT 1
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 1
34249: NEG
34250: PUSH
34251: LD_INT 0
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 1
34260: NEG
34261: PUSH
34262: LD_INT 1
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34279: LD_ADDR_VAR 0 64
34283: PUSH
34284: LD_INT 0
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 0
34296: PUSH
34297: LD_INT 1
34299: NEG
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: LD_INT 1
34307: PUSH
34308: LD_INT 0
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 1
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: EMPTY
34322: LIST
34323: LIST
34324: PUSH
34325: LD_INT 0
34327: PUSH
34328: LD_INT 1
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 1
34337: NEG
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 1
34348: NEG
34349: PUSH
34350: LD_INT 1
34352: NEG
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: LIST
34362: LIST
34363: LIST
34364: LIST
34365: LIST
34366: ST_TO_ADDR
// end ; 1 :
34367: GO 40264
34369: LD_INT 1
34371: DOUBLE
34372: EQUAL
34373: IFTRUE 34377
34375: GO 37000
34377: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34378: LD_ADDR_VAR 0 11
34382: PUSH
34383: LD_INT 1
34385: NEG
34386: PUSH
34387: LD_INT 3
34389: NEG
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 0
34397: PUSH
34398: LD_INT 3
34400: NEG
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 1
34408: PUSH
34409: LD_INT 2
34411: NEG
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: LIST
34421: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34422: LD_ADDR_VAR 0 12
34426: PUSH
34427: LD_INT 2
34429: PUSH
34430: LD_INT 1
34432: NEG
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 3
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 3
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: LIST
34462: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34463: LD_ADDR_VAR 0 13
34467: PUSH
34468: LD_INT 3
34470: PUSH
34471: LD_INT 2
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 3
34480: PUSH
34481: LD_INT 3
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 2
34490: PUSH
34491: LD_INT 3
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: LIST
34502: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34503: LD_ADDR_VAR 0 14
34507: PUSH
34508: LD_INT 1
34510: PUSH
34511: LD_INT 3
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 0
34520: PUSH
34521: LD_INT 3
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 1
34530: NEG
34531: PUSH
34532: LD_INT 2
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: LIST
34543: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34544: LD_ADDR_VAR 0 15
34548: PUSH
34549: LD_INT 2
34551: NEG
34552: PUSH
34553: LD_INT 1
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 3
34562: NEG
34563: PUSH
34564: LD_INT 0
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 3
34573: NEG
34574: PUSH
34575: LD_INT 1
34577: NEG
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: LIST
34587: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34588: LD_ADDR_VAR 0 16
34592: PUSH
34593: LD_INT 2
34595: NEG
34596: PUSH
34597: LD_INT 3
34599: NEG
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 3
34607: NEG
34608: PUSH
34609: LD_INT 2
34611: NEG
34612: PUSH
34613: EMPTY
34614: LIST
34615: LIST
34616: PUSH
34617: LD_INT 3
34619: NEG
34620: PUSH
34621: LD_INT 3
34623: NEG
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: LIST
34633: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34634: LD_ADDR_VAR 0 17
34638: PUSH
34639: LD_INT 1
34641: NEG
34642: PUSH
34643: LD_INT 3
34645: NEG
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 0
34653: PUSH
34654: LD_INT 3
34656: NEG
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 1
34664: PUSH
34665: LD_INT 2
34667: NEG
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: LIST
34677: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34678: LD_ADDR_VAR 0 18
34682: PUSH
34683: LD_INT 2
34685: PUSH
34686: LD_INT 1
34688: NEG
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 3
34696: PUSH
34697: LD_INT 0
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 3
34706: PUSH
34707: LD_INT 1
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: LIST
34718: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34719: LD_ADDR_VAR 0 19
34723: PUSH
34724: LD_INT 3
34726: PUSH
34727: LD_INT 2
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 3
34736: PUSH
34737: LD_INT 3
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 2
34746: PUSH
34747: LD_INT 3
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: LIST
34758: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34759: LD_ADDR_VAR 0 20
34763: PUSH
34764: LD_INT 1
34766: PUSH
34767: LD_INT 3
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 0
34776: PUSH
34777: LD_INT 3
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: NEG
34787: PUSH
34788: LD_INT 2
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: LIST
34799: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34800: LD_ADDR_VAR 0 21
34804: PUSH
34805: LD_INT 2
34807: NEG
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 3
34818: NEG
34819: PUSH
34820: LD_INT 0
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 3
34829: NEG
34830: PUSH
34831: LD_INT 1
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: LIST
34843: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34844: LD_ADDR_VAR 0 22
34848: PUSH
34849: LD_INT 2
34851: NEG
34852: PUSH
34853: LD_INT 3
34855: NEG
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 3
34863: NEG
34864: PUSH
34865: LD_INT 2
34867: NEG
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 3
34875: NEG
34876: PUSH
34877: LD_INT 3
34879: NEG
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: LIST
34889: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
34890: LD_ADDR_VAR 0 23
34894: PUSH
34895: LD_INT 0
34897: PUSH
34898: LD_INT 3
34900: NEG
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 1
34908: NEG
34909: PUSH
34910: LD_INT 4
34912: NEG
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 1
34920: PUSH
34921: LD_INT 3
34923: NEG
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: LIST
34933: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
34934: LD_ADDR_VAR 0 24
34938: PUSH
34939: LD_INT 3
34941: PUSH
34942: LD_INT 0
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 3
34951: PUSH
34952: LD_INT 1
34954: NEG
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 4
34962: PUSH
34963: LD_INT 1
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: EMPTY
34971: LIST
34972: LIST
34973: LIST
34974: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
34975: LD_ADDR_VAR 0 25
34979: PUSH
34980: LD_INT 3
34982: PUSH
34983: LD_INT 3
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 4
34992: PUSH
34993: LD_INT 3
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 3
35002: PUSH
35003: LD_INT 4
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: LIST
35014: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
35015: LD_ADDR_VAR 0 26
35019: PUSH
35020: LD_INT 0
35022: PUSH
35023: LD_INT 3
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: LD_INT 4
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 3
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: LIST
35055: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
35056: LD_ADDR_VAR 0 27
35060: PUSH
35061: LD_INT 3
35063: NEG
35064: PUSH
35065: LD_INT 0
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 3
35074: NEG
35075: PUSH
35076: LD_INT 1
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 4
35085: NEG
35086: PUSH
35087: LD_INT 1
35089: NEG
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: LIST
35099: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
35100: LD_ADDR_VAR 0 28
35104: PUSH
35105: LD_INT 3
35107: NEG
35108: PUSH
35109: LD_INT 3
35111: NEG
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 3
35119: NEG
35120: PUSH
35121: LD_INT 4
35123: NEG
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: LD_INT 4
35131: NEG
35132: PUSH
35133: LD_INT 3
35135: NEG
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: LIST
35145: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
35146: LD_ADDR_VAR 0 29
35150: PUSH
35151: LD_INT 1
35153: NEG
35154: PUSH
35155: LD_INT 3
35157: NEG
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: LD_INT 0
35165: PUSH
35166: LD_INT 3
35168: NEG
35169: PUSH
35170: EMPTY
35171: LIST
35172: LIST
35173: PUSH
35174: LD_INT 1
35176: PUSH
35177: LD_INT 2
35179: NEG
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 1
35187: NEG
35188: PUSH
35189: LD_INT 4
35191: NEG
35192: PUSH
35193: EMPTY
35194: LIST
35195: LIST
35196: PUSH
35197: LD_INT 0
35199: PUSH
35200: LD_INT 4
35202: NEG
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 1
35210: PUSH
35211: LD_INT 3
35213: NEG
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: NEG
35222: PUSH
35223: LD_INT 5
35225: NEG
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 0
35233: PUSH
35234: LD_INT 5
35236: NEG
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 1
35244: PUSH
35245: LD_INT 4
35247: NEG
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 1
35255: NEG
35256: PUSH
35257: LD_INT 6
35259: NEG
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 0
35267: PUSH
35268: LD_INT 6
35270: NEG
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: LD_INT 5
35281: NEG
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
35301: LD_ADDR_VAR 0 30
35305: PUSH
35306: LD_INT 2
35308: PUSH
35309: LD_INT 1
35311: NEG
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 3
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 3
35329: PUSH
35330: LD_INT 1
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 3
35339: PUSH
35340: LD_INT 1
35342: NEG
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: LD_INT 4
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 4
35360: PUSH
35361: LD_INT 1
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 4
35370: PUSH
35371: LD_INT 1
35373: NEG
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 5
35381: PUSH
35382: LD_INT 0
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 5
35391: PUSH
35392: LD_INT 1
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 5
35401: PUSH
35402: LD_INT 1
35404: NEG
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 6
35412: PUSH
35413: LD_INT 0
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 6
35422: PUSH
35423: LD_INT 1
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
35444: LD_ADDR_VAR 0 31
35448: PUSH
35449: LD_INT 3
35451: PUSH
35452: LD_INT 2
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 3
35461: PUSH
35462: LD_INT 3
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 2
35471: PUSH
35472: LD_INT 3
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 4
35481: PUSH
35482: LD_INT 3
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 4
35491: PUSH
35492: LD_INT 4
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 3
35501: PUSH
35502: LD_INT 4
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 5
35511: PUSH
35512: LD_INT 4
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 5
35521: PUSH
35522: LD_INT 5
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 4
35531: PUSH
35532: LD_INT 5
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 6
35541: PUSH
35542: LD_INT 5
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 6
35551: PUSH
35552: LD_INT 6
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 5
35561: PUSH
35562: LD_INT 6
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: EMPTY
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
35583: LD_ADDR_VAR 0 32
35587: PUSH
35588: LD_INT 1
35590: PUSH
35591: LD_INT 3
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: LD_INT 3
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 1
35610: NEG
35611: PUSH
35612: LD_INT 2
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 4
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 0
35631: PUSH
35632: LD_INT 4
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 1
35641: NEG
35642: PUSH
35643: LD_INT 3
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 1
35652: PUSH
35653: LD_INT 5
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: LD_INT 5
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 1
35672: NEG
35673: PUSH
35674: LD_INT 4
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: LD_INT 6
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: LD_INT 6
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 5
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: LIST
35716: LIST
35717: LIST
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
35726: LD_ADDR_VAR 0 33
35730: PUSH
35731: LD_INT 2
35733: NEG
35734: PUSH
35735: LD_INT 1
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 3
35744: NEG
35745: PUSH
35746: LD_INT 0
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 3
35755: NEG
35756: PUSH
35757: LD_INT 1
35759: NEG
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 3
35767: NEG
35768: PUSH
35769: LD_INT 1
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 4
35778: NEG
35779: PUSH
35780: LD_INT 0
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 4
35789: NEG
35790: PUSH
35791: LD_INT 1
35793: NEG
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 4
35801: NEG
35802: PUSH
35803: LD_INT 1
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: LD_INT 5
35812: NEG
35813: PUSH
35814: LD_INT 0
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 5
35823: NEG
35824: PUSH
35825: LD_INT 1
35827: NEG
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 5
35835: NEG
35836: PUSH
35837: LD_INT 1
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 6
35846: NEG
35847: PUSH
35848: LD_INT 0
35850: PUSH
35851: EMPTY
35852: LIST
35853: LIST
35854: PUSH
35855: LD_INT 6
35857: NEG
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: LIST
35871: LIST
35872: LIST
35873: LIST
35874: LIST
35875: LIST
35876: LIST
35877: LIST
35878: LIST
35879: LIST
35880: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
35881: LD_ADDR_VAR 0 34
35885: PUSH
35886: LD_INT 2
35888: NEG
35889: PUSH
35890: LD_INT 3
35892: NEG
35893: PUSH
35894: EMPTY
35895: LIST
35896: LIST
35897: PUSH
35898: LD_INT 3
35900: NEG
35901: PUSH
35902: LD_INT 2
35904: NEG
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: PUSH
35910: LD_INT 3
35912: NEG
35913: PUSH
35914: LD_INT 3
35916: NEG
35917: PUSH
35918: EMPTY
35919: LIST
35920: LIST
35921: PUSH
35922: LD_INT 3
35924: NEG
35925: PUSH
35926: LD_INT 4
35928: NEG
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 4
35936: NEG
35937: PUSH
35938: LD_INT 3
35940: NEG
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 4
35948: NEG
35949: PUSH
35950: LD_INT 4
35952: NEG
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 4
35960: NEG
35961: PUSH
35962: LD_INT 5
35964: NEG
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 5
35972: NEG
35973: PUSH
35974: LD_INT 4
35976: NEG
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 5
35984: NEG
35985: PUSH
35986: LD_INT 5
35988: NEG
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 5
35996: NEG
35997: PUSH
35998: LD_INT 6
36000: NEG
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 6
36008: NEG
36009: PUSH
36010: LD_INT 5
36012: NEG
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 6
36020: NEG
36021: PUSH
36022: LD_INT 6
36024: NEG
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: LIST
36040: LIST
36041: LIST
36042: LIST
36043: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
36044: LD_ADDR_VAR 0 41
36048: PUSH
36049: LD_INT 0
36051: PUSH
36052: LD_INT 2
36054: NEG
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 1
36062: NEG
36063: PUSH
36064: LD_INT 3
36066: NEG
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 1
36074: PUSH
36075: LD_INT 2
36077: NEG
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: LIST
36087: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
36088: LD_ADDR_VAR 0 42
36092: PUSH
36093: LD_INT 2
36095: PUSH
36096: LD_INT 0
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 2
36105: PUSH
36106: LD_INT 1
36108: NEG
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: LD_INT 3
36116: PUSH
36117: LD_INT 1
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: LIST
36128: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
36129: LD_ADDR_VAR 0 43
36133: PUSH
36134: LD_INT 2
36136: PUSH
36137: LD_INT 2
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 3
36146: PUSH
36147: LD_INT 2
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: LD_INT 2
36156: PUSH
36157: LD_INT 3
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: LIST
36168: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
36169: LD_ADDR_VAR 0 44
36173: PUSH
36174: LD_INT 0
36176: PUSH
36177: LD_INT 2
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: LD_INT 1
36186: PUSH
36187: LD_INT 3
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 1
36196: NEG
36197: PUSH
36198: LD_INT 2
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: LIST
36209: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36210: LD_ADDR_VAR 0 45
36214: PUSH
36215: LD_INT 2
36217: NEG
36218: PUSH
36219: LD_INT 0
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 2
36228: NEG
36229: PUSH
36230: LD_INT 1
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 3
36239: NEG
36240: PUSH
36241: LD_INT 1
36243: NEG
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: LIST
36253: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
36254: LD_ADDR_VAR 0 46
36258: PUSH
36259: LD_INT 2
36261: NEG
36262: PUSH
36263: LD_INT 2
36265: NEG
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: LD_INT 2
36273: NEG
36274: PUSH
36275: LD_INT 3
36277: NEG
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: PUSH
36283: LD_INT 3
36285: NEG
36286: PUSH
36287: LD_INT 2
36289: NEG
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: LIST
36299: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
36300: LD_ADDR_VAR 0 47
36304: PUSH
36305: LD_INT 2
36307: NEG
36308: PUSH
36309: LD_INT 3
36311: NEG
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PUSH
36317: LD_INT 1
36319: NEG
36320: PUSH
36321: LD_INT 3
36323: NEG
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36333: LD_ADDR_VAR 0 48
36337: PUSH
36338: LD_INT 1
36340: PUSH
36341: LD_INT 2
36343: NEG
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 2
36351: PUSH
36352: LD_INT 1
36354: NEG
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
36364: LD_ADDR_VAR 0 49
36368: PUSH
36369: LD_INT 3
36371: PUSH
36372: LD_INT 1
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 3
36381: PUSH
36382: LD_INT 2
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
36393: LD_ADDR_VAR 0 50
36397: PUSH
36398: LD_INT 2
36400: PUSH
36401: LD_INT 3
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: LD_INT 3
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36422: LD_ADDR_VAR 0 51
36426: PUSH
36427: LD_INT 1
36429: NEG
36430: PUSH
36431: LD_INT 2
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 2
36440: NEG
36441: PUSH
36442: LD_INT 1
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36453: LD_ADDR_VAR 0 52
36457: PUSH
36458: LD_INT 3
36460: NEG
36461: PUSH
36462: LD_INT 1
36464: NEG
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 3
36472: NEG
36473: PUSH
36474: LD_INT 2
36476: NEG
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36486: LD_ADDR_VAR 0 53
36490: PUSH
36491: LD_INT 1
36493: NEG
36494: PUSH
36495: LD_INT 3
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 0
36505: PUSH
36506: LD_INT 3
36508: NEG
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 1
36516: PUSH
36517: LD_INT 2
36519: NEG
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: LIST
36529: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36530: LD_ADDR_VAR 0 54
36534: PUSH
36535: LD_INT 2
36537: PUSH
36538: LD_INT 1
36540: NEG
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: PUSH
36546: LD_INT 3
36548: PUSH
36549: LD_INT 0
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 3
36558: PUSH
36559: LD_INT 1
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: LIST
36570: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36571: LD_ADDR_VAR 0 55
36575: PUSH
36576: LD_INT 3
36578: PUSH
36579: LD_INT 2
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 3
36588: PUSH
36589: LD_INT 3
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 2
36598: PUSH
36599: LD_INT 3
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: LIST
36610: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36611: LD_ADDR_VAR 0 56
36615: PUSH
36616: LD_INT 1
36618: PUSH
36619: LD_INT 3
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: PUSH
36626: LD_INT 0
36628: PUSH
36629: LD_INT 3
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 1
36638: NEG
36639: PUSH
36640: LD_INT 2
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: LIST
36651: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36652: LD_ADDR_VAR 0 57
36656: PUSH
36657: LD_INT 2
36659: NEG
36660: PUSH
36661: LD_INT 1
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 3
36670: NEG
36671: PUSH
36672: LD_INT 0
36674: PUSH
36675: EMPTY
36676: LIST
36677: LIST
36678: PUSH
36679: LD_INT 3
36681: NEG
36682: PUSH
36683: LD_INT 1
36685: NEG
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: LIST
36695: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36696: LD_ADDR_VAR 0 58
36700: PUSH
36701: LD_INT 2
36703: NEG
36704: PUSH
36705: LD_INT 3
36707: NEG
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: LD_INT 3
36715: NEG
36716: PUSH
36717: LD_INT 2
36719: NEG
36720: PUSH
36721: EMPTY
36722: LIST
36723: LIST
36724: PUSH
36725: LD_INT 3
36727: NEG
36728: PUSH
36729: LD_INT 3
36731: NEG
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: LIST
36741: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
36742: LD_ADDR_VAR 0 59
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: LD_INT 2
36753: NEG
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 0
36761: PUSH
36762: LD_INT 2
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 1
36772: PUSH
36773: LD_INT 1
36775: NEG
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: LIST
36785: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36786: LD_ADDR_VAR 0 60
36790: PUSH
36791: LD_INT 1
36793: PUSH
36794: LD_INT 1
36796: NEG
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 2
36804: PUSH
36805: LD_INT 0
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 2
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: LIST
36826: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36827: LD_ADDR_VAR 0 61
36831: PUSH
36832: LD_INT 2
36834: PUSH
36835: LD_INT 1
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 2
36844: PUSH
36845: LD_INT 2
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 1
36854: PUSH
36855: LD_INT 2
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: PUSH
36862: EMPTY
36863: LIST
36864: LIST
36865: LIST
36866: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36867: LD_ADDR_VAR 0 62
36871: PUSH
36872: LD_INT 1
36874: PUSH
36875: LD_INT 2
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: LD_INT 0
36884: PUSH
36885: LD_INT 2
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 1
36894: NEG
36895: PUSH
36896: LD_INT 1
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: LIST
36907: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
36908: LD_ADDR_VAR 0 63
36912: PUSH
36913: LD_INT 1
36915: NEG
36916: PUSH
36917: LD_INT 1
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 2
36926: NEG
36927: PUSH
36928: LD_INT 0
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 2
36937: NEG
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: LIST
36951: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36952: LD_ADDR_VAR 0 64
36956: PUSH
36957: LD_INT 1
36959: NEG
36960: PUSH
36961: LD_INT 2
36963: NEG
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 2
36971: NEG
36972: PUSH
36973: LD_INT 1
36975: NEG
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 2
36983: NEG
36984: PUSH
36985: LD_INT 2
36987: NEG
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: LIST
36997: ST_TO_ADDR
// end ; 2 :
36998: GO 40264
37000: LD_INT 2
37002: DOUBLE
37003: EQUAL
37004: IFTRUE 37008
37006: GO 40263
37008: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
37009: LD_ADDR_VAR 0 29
37013: PUSH
37014: LD_INT 4
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: LD_INT 4
37026: PUSH
37027: LD_INT 1
37029: NEG
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 5
37037: PUSH
37038: LD_INT 0
37040: PUSH
37041: EMPTY
37042: LIST
37043: LIST
37044: PUSH
37045: LD_INT 5
37047: PUSH
37048: LD_INT 1
37050: PUSH
37051: EMPTY
37052: LIST
37053: LIST
37054: PUSH
37055: LD_INT 4
37057: PUSH
37058: LD_INT 1
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: PUSH
37065: LD_INT 3
37067: PUSH
37068: LD_INT 0
37070: PUSH
37071: EMPTY
37072: LIST
37073: LIST
37074: PUSH
37075: LD_INT 3
37077: PUSH
37078: LD_INT 1
37080: NEG
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 3
37088: PUSH
37089: LD_INT 2
37091: NEG
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 5
37099: PUSH
37100: LD_INT 2
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: LD_INT 3
37109: PUSH
37110: LD_INT 3
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: PUSH
37117: LD_INT 3
37119: PUSH
37120: LD_INT 2
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 4
37129: PUSH
37130: LD_INT 3
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 4
37139: PUSH
37140: LD_INT 4
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 3
37149: PUSH
37150: LD_INT 4
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: PUSH
37157: LD_INT 2
37159: PUSH
37160: LD_INT 3
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: PUSH
37170: LD_INT 2
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 4
37179: PUSH
37180: LD_INT 2
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: LD_INT 2
37189: PUSH
37190: LD_INT 4
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: LD_INT 4
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: LD_INT 3
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: LD_INT 1
37219: PUSH
37220: LD_INT 4
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 1
37229: PUSH
37230: LD_INT 5
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 0
37239: PUSH
37240: LD_INT 5
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 1
37249: NEG
37250: PUSH
37251: LD_INT 4
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: LD_INT 1
37260: NEG
37261: PUSH
37262: LD_INT 3
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: PUSH
37269: LD_INT 2
37271: PUSH
37272: LD_INT 5
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 2
37281: NEG
37282: PUSH
37283: LD_INT 3
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 3
37292: NEG
37293: PUSH
37294: LD_INT 0
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 3
37303: NEG
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 2
37315: NEG
37316: PUSH
37317: LD_INT 0
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 2
37326: NEG
37327: PUSH
37328: LD_INT 1
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 3
37337: NEG
37338: PUSH
37339: LD_INT 1
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 4
37348: NEG
37349: PUSH
37350: LD_INT 0
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 4
37359: NEG
37360: PUSH
37361: LD_INT 1
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 4
37371: NEG
37372: PUSH
37373: LD_INT 2
37375: NEG
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 2
37383: NEG
37384: PUSH
37385: LD_INT 2
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: PUSH
37392: LD_INT 4
37394: NEG
37395: PUSH
37396: LD_INT 4
37398: NEG
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 4
37406: NEG
37407: PUSH
37408: LD_INT 5
37410: NEG
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: LD_INT 3
37418: NEG
37419: PUSH
37420: LD_INT 4
37422: NEG
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 3
37430: NEG
37431: PUSH
37432: LD_INT 3
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 4
37442: NEG
37443: PUSH
37444: LD_INT 3
37446: NEG
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: PUSH
37452: LD_INT 5
37454: NEG
37455: PUSH
37456: LD_INT 4
37458: NEG
37459: PUSH
37460: EMPTY
37461: LIST
37462: LIST
37463: PUSH
37464: LD_INT 5
37466: NEG
37467: PUSH
37468: LD_INT 5
37470: NEG
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 3
37478: NEG
37479: PUSH
37480: LD_INT 5
37482: NEG
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 5
37490: NEG
37491: PUSH
37492: LD_INT 3
37494: NEG
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: LIST
37504: LIST
37505: LIST
37506: LIST
37507: LIST
37508: LIST
37509: LIST
37510: LIST
37511: LIST
37512: LIST
37513: LIST
37514: LIST
37515: LIST
37516: LIST
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: LIST
37542: LIST
37543: LIST
37544: LIST
37545: LIST
37546: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
37547: LD_ADDR_VAR 0 30
37551: PUSH
37552: LD_INT 4
37554: PUSH
37555: LD_INT 4
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 4
37564: PUSH
37565: LD_INT 3
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 5
37574: PUSH
37575: LD_INT 4
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 5
37584: PUSH
37585: LD_INT 5
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 4
37594: PUSH
37595: LD_INT 5
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: LD_INT 3
37604: PUSH
37605: LD_INT 4
37607: PUSH
37608: EMPTY
37609: LIST
37610: LIST
37611: PUSH
37612: LD_INT 3
37614: PUSH
37615: LD_INT 3
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: PUSH
37622: LD_INT 5
37624: PUSH
37625: LD_INT 3
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: LD_INT 3
37634: PUSH
37635: LD_INT 5
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 0
37644: PUSH
37645: LD_INT 3
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 0
37654: PUSH
37655: LD_INT 2
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: PUSH
37665: LD_INT 3
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 1
37674: PUSH
37675: LD_INT 4
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: LD_INT 4
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 1
37694: NEG
37695: PUSH
37696: LD_INT 3
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 1
37705: NEG
37706: PUSH
37707: LD_INT 2
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 2
37716: PUSH
37717: LD_INT 4
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 2
37726: NEG
37727: PUSH
37728: LD_INT 2
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: LD_INT 4
37737: NEG
37738: PUSH
37739: LD_INT 0
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 4
37748: NEG
37749: PUSH
37750: LD_INT 1
37752: NEG
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 3
37760: NEG
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 3
37771: NEG
37772: PUSH
37773: LD_INT 1
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 4
37782: NEG
37783: PUSH
37784: LD_INT 1
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: LD_INT 5
37793: NEG
37794: PUSH
37795: LD_INT 0
37797: PUSH
37798: EMPTY
37799: LIST
37800: LIST
37801: PUSH
37802: LD_INT 5
37804: NEG
37805: PUSH
37806: LD_INT 1
37808: NEG
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: LD_INT 5
37816: NEG
37817: PUSH
37818: LD_INT 2
37820: NEG
37821: PUSH
37822: EMPTY
37823: LIST
37824: LIST
37825: PUSH
37826: LD_INT 3
37828: NEG
37829: PUSH
37830: LD_INT 2
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PUSH
37837: LD_INT 3
37839: NEG
37840: PUSH
37841: LD_INT 3
37843: NEG
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 3
37851: NEG
37852: PUSH
37853: LD_INT 4
37855: NEG
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 2
37863: NEG
37864: PUSH
37865: LD_INT 3
37867: NEG
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 2
37875: NEG
37876: PUSH
37877: LD_INT 2
37879: NEG
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 3
37887: NEG
37888: PUSH
37889: LD_INT 2
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: LD_INT 4
37899: NEG
37900: PUSH
37901: LD_INT 3
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 4
37911: NEG
37912: PUSH
37913: LD_INT 4
37915: NEG
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 2
37923: NEG
37924: PUSH
37925: LD_INT 4
37927: NEG
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: LD_INT 4
37935: NEG
37936: PUSH
37937: LD_INT 2
37939: NEG
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 0
37947: PUSH
37948: LD_INT 4
37950: NEG
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: PUSH
37956: LD_INT 0
37958: PUSH
37959: LD_INT 5
37961: NEG
37962: PUSH
37963: EMPTY
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 1
37969: PUSH
37970: LD_INT 4
37972: NEG
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 1
37980: PUSH
37981: LD_INT 3
37983: NEG
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 0
37991: PUSH
37992: LD_INT 3
37994: NEG
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 1
38002: NEG
38003: PUSH
38004: LD_INT 4
38006: NEG
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: LD_INT 1
38014: NEG
38015: PUSH
38016: LD_INT 5
38018: NEG
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: LD_INT 2
38026: PUSH
38027: LD_INT 3
38029: NEG
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 2
38037: NEG
38038: PUSH
38039: LD_INT 5
38041: NEG
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: LIST
38089: LIST
38090: LIST
38091: LIST
38092: LIST
38093: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
38094: LD_ADDR_VAR 0 31
38098: PUSH
38099: LD_INT 0
38101: PUSH
38102: LD_INT 4
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: LD_INT 0
38111: PUSH
38112: LD_INT 3
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 1
38121: PUSH
38122: LD_INT 4
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 1
38131: PUSH
38132: LD_INT 5
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 0
38141: PUSH
38142: LD_INT 5
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 1
38151: NEG
38152: PUSH
38153: LD_INT 4
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 1
38162: NEG
38163: PUSH
38164: LD_INT 3
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 2
38173: PUSH
38174: LD_INT 5
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 2
38183: NEG
38184: PUSH
38185: LD_INT 3
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 3
38194: NEG
38195: PUSH
38196: LD_INT 0
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 3
38205: NEG
38206: PUSH
38207: LD_INT 1
38209: NEG
38210: PUSH
38211: EMPTY
38212: LIST
38213: LIST
38214: PUSH
38215: LD_INT 2
38217: NEG
38218: PUSH
38219: LD_INT 0
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PUSH
38226: LD_INT 2
38228: NEG
38229: PUSH
38230: LD_INT 1
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 3
38239: NEG
38240: PUSH
38241: LD_INT 1
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 4
38250: NEG
38251: PUSH
38252: LD_INT 0
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 4
38261: NEG
38262: PUSH
38263: LD_INT 1
38265: NEG
38266: PUSH
38267: EMPTY
38268: LIST
38269: LIST
38270: PUSH
38271: LD_INT 4
38273: NEG
38274: PUSH
38275: LD_INT 2
38277: NEG
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PUSH
38283: LD_INT 2
38285: NEG
38286: PUSH
38287: LD_INT 2
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PUSH
38294: LD_INT 4
38296: NEG
38297: PUSH
38298: LD_INT 4
38300: NEG
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 4
38308: NEG
38309: PUSH
38310: LD_INT 5
38312: NEG
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: LD_INT 3
38320: NEG
38321: PUSH
38322: LD_INT 4
38324: NEG
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 3
38332: NEG
38333: PUSH
38334: LD_INT 3
38336: NEG
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 4
38344: NEG
38345: PUSH
38346: LD_INT 3
38348: NEG
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 5
38356: NEG
38357: PUSH
38358: LD_INT 4
38360: NEG
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 5
38368: NEG
38369: PUSH
38370: LD_INT 5
38372: NEG
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 3
38380: NEG
38381: PUSH
38382: LD_INT 5
38384: NEG
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 5
38392: NEG
38393: PUSH
38394: LD_INT 3
38396: NEG
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 0
38404: PUSH
38405: LD_INT 3
38407: NEG
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: LD_INT 0
38415: PUSH
38416: LD_INT 4
38418: NEG
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 1
38426: PUSH
38427: LD_INT 3
38429: NEG
38430: PUSH
38431: EMPTY
38432: LIST
38433: LIST
38434: PUSH
38435: LD_INT 1
38437: PUSH
38438: LD_INT 2
38440: NEG
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 0
38448: PUSH
38449: LD_INT 2
38451: NEG
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 1
38459: NEG
38460: PUSH
38461: LD_INT 3
38463: NEG
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 1
38471: NEG
38472: PUSH
38473: LD_INT 4
38475: NEG
38476: PUSH
38477: EMPTY
38478: LIST
38479: LIST
38480: PUSH
38481: LD_INT 2
38483: PUSH
38484: LD_INT 2
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: NEG
38495: PUSH
38496: LD_INT 4
38498: NEG
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 4
38506: PUSH
38507: LD_INT 0
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 4
38516: PUSH
38517: LD_INT 1
38519: NEG
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 5
38527: PUSH
38528: LD_INT 0
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 5
38537: PUSH
38538: LD_INT 1
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 4
38547: PUSH
38548: LD_INT 1
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 3
38557: PUSH
38558: LD_INT 0
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 3
38567: PUSH
38568: LD_INT 1
38570: NEG
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 3
38578: PUSH
38579: LD_INT 2
38581: NEG
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 5
38589: PUSH
38590: LD_INT 2
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: LIST
38606: LIST
38607: LIST
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: LIST
38630: LIST
38631: LIST
38632: LIST
38633: LIST
38634: LIST
38635: LIST
38636: LIST
38637: LIST
38638: LIST
38639: LIST
38640: LIST
38641: LIST
38642: LIST
38643: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
38644: LD_ADDR_VAR 0 32
38648: PUSH
38649: LD_INT 4
38651: NEG
38652: PUSH
38653: LD_INT 0
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 4
38662: NEG
38663: PUSH
38664: LD_INT 1
38666: NEG
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 3
38674: NEG
38675: PUSH
38676: LD_INT 0
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 3
38685: NEG
38686: PUSH
38687: LD_INT 1
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 4
38696: NEG
38697: PUSH
38698: LD_INT 1
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 5
38707: NEG
38708: PUSH
38709: LD_INT 0
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 5
38718: NEG
38719: PUSH
38720: LD_INT 1
38722: NEG
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 5
38730: NEG
38731: PUSH
38732: LD_INT 2
38734: NEG
38735: PUSH
38736: EMPTY
38737: LIST
38738: LIST
38739: PUSH
38740: LD_INT 3
38742: NEG
38743: PUSH
38744: LD_INT 2
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: LD_INT 3
38753: NEG
38754: PUSH
38755: LD_INT 3
38757: NEG
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 3
38765: NEG
38766: PUSH
38767: LD_INT 4
38769: NEG
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 2
38777: NEG
38778: PUSH
38779: LD_INT 3
38781: NEG
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: LD_INT 2
38789: NEG
38790: PUSH
38791: LD_INT 2
38793: NEG
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: LD_INT 3
38801: NEG
38802: PUSH
38803: LD_INT 2
38805: NEG
38806: PUSH
38807: EMPTY
38808: LIST
38809: LIST
38810: PUSH
38811: LD_INT 4
38813: NEG
38814: PUSH
38815: LD_INT 3
38817: NEG
38818: PUSH
38819: EMPTY
38820: LIST
38821: LIST
38822: PUSH
38823: LD_INT 4
38825: NEG
38826: PUSH
38827: LD_INT 4
38829: NEG
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 2
38837: NEG
38838: PUSH
38839: LD_INT 4
38841: NEG
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: PUSH
38847: LD_INT 4
38849: NEG
38850: PUSH
38851: LD_INT 2
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 0
38861: PUSH
38862: LD_INT 4
38864: NEG
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 0
38872: PUSH
38873: LD_INT 5
38875: NEG
38876: PUSH
38877: EMPTY
38878: LIST
38879: LIST
38880: PUSH
38881: LD_INT 1
38883: PUSH
38884: LD_INT 4
38886: NEG
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: LD_INT 1
38894: PUSH
38895: LD_INT 3
38897: NEG
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 0
38905: PUSH
38906: LD_INT 3
38908: NEG
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 1
38916: NEG
38917: PUSH
38918: LD_INT 4
38920: NEG
38921: PUSH
38922: EMPTY
38923: LIST
38924: LIST
38925: PUSH
38926: LD_INT 1
38928: NEG
38929: PUSH
38930: LD_INT 5
38932: NEG
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: LD_INT 3
38943: NEG
38944: PUSH
38945: EMPTY
38946: LIST
38947: LIST
38948: PUSH
38949: LD_INT 2
38951: NEG
38952: PUSH
38953: LD_INT 5
38955: NEG
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: LD_INT 3
38963: PUSH
38964: LD_INT 0
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 3
38973: PUSH
38974: LD_INT 1
38976: NEG
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 4
38984: PUSH
38985: LD_INT 0
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 4
38994: PUSH
38995: LD_INT 1
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 3
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 2
39014: PUSH
39015: LD_INT 0
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 2
39024: PUSH
39025: LD_INT 1
39027: NEG
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 2
39035: PUSH
39036: LD_INT 2
39038: NEG
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: PUSH
39044: LD_INT 4
39046: PUSH
39047: LD_INT 2
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 4
39056: PUSH
39057: LD_INT 4
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: PUSH
39064: LD_INT 4
39066: PUSH
39067: LD_INT 3
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 5
39076: PUSH
39077: LD_INT 4
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 5
39086: PUSH
39087: LD_INT 5
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: LD_INT 4
39096: PUSH
39097: LD_INT 5
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 3
39106: PUSH
39107: LD_INT 4
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: LD_INT 3
39116: PUSH
39117: LD_INT 3
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 5
39126: PUSH
39127: LD_INT 3
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 3
39136: PUSH
39137: LD_INT 5
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: LIST
39148: LIST
39149: LIST
39150: LIST
39151: LIST
39152: LIST
39153: LIST
39154: LIST
39155: LIST
39156: LIST
39157: LIST
39158: LIST
39159: LIST
39160: LIST
39161: LIST
39162: LIST
39163: LIST
39164: LIST
39165: LIST
39166: LIST
39167: LIST
39168: LIST
39169: LIST
39170: LIST
39171: LIST
39172: LIST
39173: LIST
39174: LIST
39175: LIST
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: LIST
39190: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
39191: LD_ADDR_VAR 0 33
39195: PUSH
39196: LD_INT 4
39198: NEG
39199: PUSH
39200: LD_INT 4
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 4
39210: NEG
39211: PUSH
39212: LD_INT 5
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 3
39222: NEG
39223: PUSH
39224: LD_INT 4
39226: NEG
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 3
39234: NEG
39235: PUSH
39236: LD_INT 3
39238: NEG
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 4
39246: NEG
39247: PUSH
39248: LD_INT 3
39250: NEG
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 5
39258: NEG
39259: PUSH
39260: LD_INT 4
39262: NEG
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: LD_INT 5
39270: NEG
39271: PUSH
39272: LD_INT 5
39274: NEG
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 3
39282: NEG
39283: PUSH
39284: LD_INT 5
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 5
39294: NEG
39295: PUSH
39296: LD_INT 3
39298: NEG
39299: PUSH
39300: EMPTY
39301: LIST
39302: LIST
39303: PUSH
39304: LD_INT 0
39306: PUSH
39307: LD_INT 3
39309: NEG
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: PUSH
39315: LD_INT 0
39317: PUSH
39318: LD_INT 4
39320: NEG
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: LD_INT 1
39328: PUSH
39329: LD_INT 3
39331: NEG
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: LD_INT 2
39342: NEG
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: LD_INT 0
39350: PUSH
39351: LD_INT 2
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 1
39361: NEG
39362: PUSH
39363: LD_INT 3
39365: NEG
39366: PUSH
39367: EMPTY
39368: LIST
39369: LIST
39370: PUSH
39371: LD_INT 1
39373: NEG
39374: PUSH
39375: LD_INT 4
39377: NEG
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: LD_INT 2
39385: PUSH
39386: LD_INT 2
39388: NEG
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 2
39396: NEG
39397: PUSH
39398: LD_INT 4
39400: NEG
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 4
39408: PUSH
39409: LD_INT 0
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: LD_INT 4
39418: PUSH
39419: LD_INT 1
39421: NEG
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 5
39429: PUSH
39430: LD_INT 0
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 5
39439: PUSH
39440: LD_INT 1
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 4
39449: PUSH
39450: LD_INT 1
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 3
39459: PUSH
39460: LD_INT 0
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 3
39469: PUSH
39470: LD_INT 1
39472: NEG
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 3
39480: PUSH
39481: LD_INT 2
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 5
39491: PUSH
39492: LD_INT 2
39494: PUSH
39495: EMPTY
39496: LIST
39497: LIST
39498: PUSH
39499: LD_INT 3
39501: PUSH
39502: LD_INT 3
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: PUSH
39509: LD_INT 3
39511: PUSH
39512: LD_INT 2
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 4
39521: PUSH
39522: LD_INT 3
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 4
39531: PUSH
39532: LD_INT 4
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 3
39541: PUSH
39542: LD_INT 4
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 2
39551: PUSH
39552: LD_INT 3
39554: PUSH
39555: EMPTY
39556: LIST
39557: LIST
39558: PUSH
39559: LD_INT 2
39561: PUSH
39562: LD_INT 2
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 4
39571: PUSH
39572: LD_INT 2
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 2
39581: PUSH
39582: LD_INT 4
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 0
39591: PUSH
39592: LD_INT 4
39594: PUSH
39595: EMPTY
39596: LIST
39597: LIST
39598: PUSH
39599: LD_INT 0
39601: PUSH
39602: LD_INT 3
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 1
39611: PUSH
39612: LD_INT 4
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 1
39621: PUSH
39622: LD_INT 5
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 0
39631: PUSH
39632: LD_INT 5
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: LD_INT 1
39641: NEG
39642: PUSH
39643: LD_INT 4
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PUSH
39650: LD_INT 1
39652: NEG
39653: PUSH
39654: LD_INT 3
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 2
39663: PUSH
39664: LD_INT 5
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 2
39673: NEG
39674: PUSH
39675: LD_INT 3
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: LIST
39691: LIST
39692: LIST
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: LIST
39699: LIST
39700: LIST
39701: LIST
39702: LIST
39703: LIST
39704: LIST
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: LIST
39714: LIST
39715: LIST
39716: LIST
39717: LIST
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: LIST
39725: LIST
39726: LIST
39727: LIST
39728: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
39729: LD_ADDR_VAR 0 34
39733: PUSH
39734: LD_INT 0
39736: PUSH
39737: LD_INT 4
39739: NEG
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 0
39747: PUSH
39748: LD_INT 5
39750: NEG
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 1
39758: PUSH
39759: LD_INT 4
39761: NEG
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 1
39769: PUSH
39770: LD_INT 3
39772: NEG
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PUSH
39778: LD_INT 0
39780: PUSH
39781: LD_INT 3
39783: NEG
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 1
39791: NEG
39792: PUSH
39793: LD_INT 4
39795: NEG
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 1
39803: NEG
39804: PUSH
39805: LD_INT 5
39807: NEG
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: LD_INT 2
39815: PUSH
39816: LD_INT 3
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 2
39826: NEG
39827: PUSH
39828: LD_INT 5
39830: NEG
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: LD_INT 3
39838: PUSH
39839: LD_INT 0
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 3
39848: PUSH
39849: LD_INT 1
39851: NEG
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 4
39859: PUSH
39860: LD_INT 0
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 4
39869: PUSH
39870: LD_INT 1
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 3
39879: PUSH
39880: LD_INT 1
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 2
39889: PUSH
39890: LD_INT 0
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 2
39899: PUSH
39900: LD_INT 1
39902: NEG
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 2
39910: PUSH
39911: LD_INT 2
39913: NEG
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 4
39921: PUSH
39922: LD_INT 2
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 4
39931: PUSH
39932: LD_INT 4
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 4
39941: PUSH
39942: LD_INT 3
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 5
39951: PUSH
39952: LD_INT 4
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: LD_INT 5
39961: PUSH
39962: LD_INT 5
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: PUSH
39969: LD_INT 4
39971: PUSH
39972: LD_INT 5
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 3
39981: PUSH
39982: LD_INT 4
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 3
39991: PUSH
39992: LD_INT 3
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 5
40001: PUSH
40002: LD_INT 3
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 3
40011: PUSH
40012: LD_INT 5
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: PUSH
40019: LD_INT 0
40021: PUSH
40022: LD_INT 3
40024: PUSH
40025: EMPTY
40026: LIST
40027: LIST
40028: PUSH
40029: LD_INT 0
40031: PUSH
40032: LD_INT 2
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: LD_INT 1
40041: PUSH
40042: LD_INT 3
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: PUSH
40052: LD_INT 4
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 0
40061: PUSH
40062: LD_INT 4
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 1
40071: NEG
40072: PUSH
40073: LD_INT 3
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 1
40082: NEG
40083: PUSH
40084: LD_INT 2
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 2
40093: PUSH
40094: LD_INT 4
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 2
40103: NEG
40104: PUSH
40105: LD_INT 2
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 4
40114: NEG
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 4
40125: NEG
40126: PUSH
40127: LD_INT 1
40129: NEG
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 3
40137: NEG
40138: PUSH
40139: LD_INT 0
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 3
40148: NEG
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 4
40159: NEG
40160: PUSH
40161: LD_INT 1
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 5
40170: NEG
40171: PUSH
40172: LD_INT 0
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 5
40181: NEG
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: LD_INT 5
40193: NEG
40194: PUSH
40195: LD_INT 2
40197: NEG
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 3
40205: NEG
40206: PUSH
40207: LD_INT 2
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: LIST
40218: LIST
40219: LIST
40220: LIST
40221: LIST
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: LIST
40232: LIST
40233: LIST
40234: LIST
40235: LIST
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: LIST
40241: LIST
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: LIST
40248: LIST
40249: LIST
40250: LIST
40251: LIST
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: LIST
40258: LIST
40259: LIST
40260: ST_TO_ADDR
// end ; end ;
40261: GO 40264
40263: POP
// case btype of b_depot , b_warehouse :
40264: LD_VAR 0 1
40268: PUSH
40269: LD_INT 0
40271: DOUBLE
40272: EQUAL
40273: IFTRUE 40283
40275: LD_INT 1
40277: DOUBLE
40278: EQUAL
40279: IFTRUE 40283
40281: GO 40484
40283: POP
// case nation of nation_american :
40284: LD_VAR 0 5
40288: PUSH
40289: LD_INT 1
40291: DOUBLE
40292: EQUAL
40293: IFTRUE 40297
40295: GO 40353
40297: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
40298: LD_ADDR_VAR 0 9
40302: PUSH
40303: LD_VAR 0 11
40307: PUSH
40308: LD_VAR 0 12
40312: PUSH
40313: LD_VAR 0 13
40317: PUSH
40318: LD_VAR 0 14
40322: PUSH
40323: LD_VAR 0 15
40327: PUSH
40328: LD_VAR 0 16
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: LIST
40337: LIST
40338: LIST
40339: LIST
40340: PUSH
40341: LD_VAR 0 4
40345: PUSH
40346: LD_INT 1
40348: PLUS
40349: ARRAY
40350: ST_TO_ADDR
40351: GO 40482
40353: LD_INT 2
40355: DOUBLE
40356: EQUAL
40357: IFTRUE 40361
40359: GO 40417
40361: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
40362: LD_ADDR_VAR 0 9
40366: PUSH
40367: LD_VAR 0 17
40371: PUSH
40372: LD_VAR 0 18
40376: PUSH
40377: LD_VAR 0 19
40381: PUSH
40382: LD_VAR 0 20
40386: PUSH
40387: LD_VAR 0 21
40391: PUSH
40392: LD_VAR 0 22
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: PUSH
40405: LD_VAR 0 4
40409: PUSH
40410: LD_INT 1
40412: PLUS
40413: ARRAY
40414: ST_TO_ADDR
40415: GO 40482
40417: LD_INT 3
40419: DOUBLE
40420: EQUAL
40421: IFTRUE 40425
40423: GO 40481
40425: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
40426: LD_ADDR_VAR 0 9
40430: PUSH
40431: LD_VAR 0 23
40435: PUSH
40436: LD_VAR 0 24
40440: PUSH
40441: LD_VAR 0 25
40445: PUSH
40446: LD_VAR 0 26
40450: PUSH
40451: LD_VAR 0 27
40455: PUSH
40456: LD_VAR 0 28
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: PUSH
40469: LD_VAR 0 4
40473: PUSH
40474: LD_INT 1
40476: PLUS
40477: ARRAY
40478: ST_TO_ADDR
40479: GO 40482
40481: POP
40482: GO 41037
40484: LD_INT 2
40486: DOUBLE
40487: EQUAL
40488: IFTRUE 40498
40490: LD_INT 3
40492: DOUBLE
40493: EQUAL
40494: IFTRUE 40498
40496: GO 40554
40498: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
40499: LD_ADDR_VAR 0 9
40503: PUSH
40504: LD_VAR 0 29
40508: PUSH
40509: LD_VAR 0 30
40513: PUSH
40514: LD_VAR 0 31
40518: PUSH
40519: LD_VAR 0 32
40523: PUSH
40524: LD_VAR 0 33
40528: PUSH
40529: LD_VAR 0 34
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: PUSH
40542: LD_VAR 0 4
40546: PUSH
40547: LD_INT 1
40549: PLUS
40550: ARRAY
40551: ST_TO_ADDR
40552: GO 41037
40554: LD_INT 16
40556: DOUBLE
40557: EQUAL
40558: IFTRUE 40616
40560: LD_INT 17
40562: DOUBLE
40563: EQUAL
40564: IFTRUE 40616
40566: LD_INT 18
40568: DOUBLE
40569: EQUAL
40570: IFTRUE 40616
40572: LD_INT 19
40574: DOUBLE
40575: EQUAL
40576: IFTRUE 40616
40578: LD_INT 22
40580: DOUBLE
40581: EQUAL
40582: IFTRUE 40616
40584: LD_INT 20
40586: DOUBLE
40587: EQUAL
40588: IFTRUE 40616
40590: LD_INT 21
40592: DOUBLE
40593: EQUAL
40594: IFTRUE 40616
40596: LD_INT 23
40598: DOUBLE
40599: EQUAL
40600: IFTRUE 40616
40602: LD_INT 24
40604: DOUBLE
40605: EQUAL
40606: IFTRUE 40616
40608: LD_INT 25
40610: DOUBLE
40611: EQUAL
40612: IFTRUE 40616
40614: GO 40672
40616: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
40617: LD_ADDR_VAR 0 9
40621: PUSH
40622: LD_VAR 0 35
40626: PUSH
40627: LD_VAR 0 36
40631: PUSH
40632: LD_VAR 0 37
40636: PUSH
40637: LD_VAR 0 38
40641: PUSH
40642: LD_VAR 0 39
40646: PUSH
40647: LD_VAR 0 40
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: LIST
40658: LIST
40659: PUSH
40660: LD_VAR 0 4
40664: PUSH
40665: LD_INT 1
40667: PLUS
40668: ARRAY
40669: ST_TO_ADDR
40670: GO 41037
40672: LD_INT 6
40674: DOUBLE
40675: EQUAL
40676: IFTRUE 40728
40678: LD_INT 7
40680: DOUBLE
40681: EQUAL
40682: IFTRUE 40728
40684: LD_INT 8
40686: DOUBLE
40687: EQUAL
40688: IFTRUE 40728
40690: LD_INT 13
40692: DOUBLE
40693: EQUAL
40694: IFTRUE 40728
40696: LD_INT 12
40698: DOUBLE
40699: EQUAL
40700: IFTRUE 40728
40702: LD_INT 15
40704: DOUBLE
40705: EQUAL
40706: IFTRUE 40728
40708: LD_INT 11
40710: DOUBLE
40711: EQUAL
40712: IFTRUE 40728
40714: LD_INT 14
40716: DOUBLE
40717: EQUAL
40718: IFTRUE 40728
40720: LD_INT 10
40722: DOUBLE
40723: EQUAL
40724: IFTRUE 40728
40726: GO 40784
40728: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
40729: LD_ADDR_VAR 0 9
40733: PUSH
40734: LD_VAR 0 41
40738: PUSH
40739: LD_VAR 0 42
40743: PUSH
40744: LD_VAR 0 43
40748: PUSH
40749: LD_VAR 0 44
40753: PUSH
40754: LD_VAR 0 45
40758: PUSH
40759: LD_VAR 0 46
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: LIST
40768: LIST
40769: LIST
40770: LIST
40771: PUSH
40772: LD_VAR 0 4
40776: PUSH
40777: LD_INT 1
40779: PLUS
40780: ARRAY
40781: ST_TO_ADDR
40782: GO 41037
40784: LD_INT 36
40786: DOUBLE
40787: EQUAL
40788: IFTRUE 40792
40790: GO 40848
40792: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
40793: LD_ADDR_VAR 0 9
40797: PUSH
40798: LD_VAR 0 47
40802: PUSH
40803: LD_VAR 0 48
40807: PUSH
40808: LD_VAR 0 49
40812: PUSH
40813: LD_VAR 0 50
40817: PUSH
40818: LD_VAR 0 51
40822: PUSH
40823: LD_VAR 0 52
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: LIST
40832: LIST
40833: LIST
40834: LIST
40835: PUSH
40836: LD_VAR 0 4
40840: PUSH
40841: LD_INT 1
40843: PLUS
40844: ARRAY
40845: ST_TO_ADDR
40846: GO 41037
40848: LD_INT 4
40850: DOUBLE
40851: EQUAL
40852: IFTRUE 40874
40854: LD_INT 5
40856: DOUBLE
40857: EQUAL
40858: IFTRUE 40874
40860: LD_INT 34
40862: DOUBLE
40863: EQUAL
40864: IFTRUE 40874
40866: LD_INT 37
40868: DOUBLE
40869: EQUAL
40870: IFTRUE 40874
40872: GO 40930
40874: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
40875: LD_ADDR_VAR 0 9
40879: PUSH
40880: LD_VAR 0 53
40884: PUSH
40885: LD_VAR 0 54
40889: PUSH
40890: LD_VAR 0 55
40894: PUSH
40895: LD_VAR 0 56
40899: PUSH
40900: LD_VAR 0 57
40904: PUSH
40905: LD_VAR 0 58
40909: PUSH
40910: EMPTY
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: PUSH
40918: LD_VAR 0 4
40922: PUSH
40923: LD_INT 1
40925: PLUS
40926: ARRAY
40927: ST_TO_ADDR
40928: GO 41037
40930: LD_INT 31
40932: DOUBLE
40933: EQUAL
40934: IFTRUE 40980
40936: LD_INT 32
40938: DOUBLE
40939: EQUAL
40940: IFTRUE 40980
40942: LD_INT 33
40944: DOUBLE
40945: EQUAL
40946: IFTRUE 40980
40948: LD_INT 27
40950: DOUBLE
40951: EQUAL
40952: IFTRUE 40980
40954: LD_INT 26
40956: DOUBLE
40957: EQUAL
40958: IFTRUE 40980
40960: LD_INT 28
40962: DOUBLE
40963: EQUAL
40964: IFTRUE 40980
40966: LD_INT 29
40968: DOUBLE
40969: EQUAL
40970: IFTRUE 40980
40972: LD_INT 30
40974: DOUBLE
40975: EQUAL
40976: IFTRUE 40980
40978: GO 41036
40980: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
40981: LD_ADDR_VAR 0 9
40985: PUSH
40986: LD_VAR 0 59
40990: PUSH
40991: LD_VAR 0 60
40995: PUSH
40996: LD_VAR 0 61
41000: PUSH
41001: LD_VAR 0 62
41005: PUSH
41006: LD_VAR 0 63
41010: PUSH
41011: LD_VAR 0 64
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: PUSH
41024: LD_VAR 0 4
41028: PUSH
41029: LD_INT 1
41031: PLUS
41032: ARRAY
41033: ST_TO_ADDR
41034: GO 41037
41036: POP
// temp_list2 = [ ] ;
41037: LD_ADDR_VAR 0 10
41041: PUSH
41042: EMPTY
41043: ST_TO_ADDR
// for i in temp_list do
41044: LD_ADDR_VAR 0 8
41048: PUSH
41049: LD_VAR 0 9
41053: PUSH
41054: FOR_IN
41055: IFFALSE 41107
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
41057: LD_ADDR_VAR 0 10
41061: PUSH
41062: LD_VAR 0 10
41066: PUSH
41067: LD_VAR 0 8
41071: PUSH
41072: LD_INT 1
41074: ARRAY
41075: PUSH
41076: LD_VAR 0 2
41080: PLUS
41081: PUSH
41082: LD_VAR 0 8
41086: PUSH
41087: LD_INT 2
41089: ARRAY
41090: PUSH
41091: LD_VAR 0 3
41095: PLUS
41096: PUSH
41097: EMPTY
41098: LIST
41099: LIST
41100: PUSH
41101: EMPTY
41102: LIST
41103: ADD
41104: ST_TO_ADDR
41105: GO 41054
41107: POP
41108: POP
// result = temp_list2 ;
41109: LD_ADDR_VAR 0 7
41113: PUSH
41114: LD_VAR 0 10
41118: ST_TO_ADDR
// end ;
41119: LD_VAR 0 7
41123: RET
// export function EnemyInRange ( unit , dist ) ; begin
41124: LD_INT 0
41126: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
41127: LD_ADDR_VAR 0 3
41131: PUSH
41132: LD_VAR 0 1
41136: PPUSH
41137: CALL_OW 255
41141: PPUSH
41142: LD_VAR 0 1
41146: PPUSH
41147: CALL_OW 250
41151: PPUSH
41152: LD_VAR 0 1
41156: PPUSH
41157: CALL_OW 251
41161: PPUSH
41162: LD_VAR 0 2
41166: PPUSH
41167: CALL 15228 0 4
41171: PUSH
41172: LD_INT 4
41174: ARRAY
41175: ST_TO_ADDR
// end ;
41176: LD_VAR 0 3
41180: RET
// export function PlayerSeeMe ( unit ) ; begin
41181: LD_INT 0
41183: PPUSH
// result := See ( your_side , unit ) ;
41184: LD_ADDR_VAR 0 2
41188: PUSH
41189: LD_OWVAR 2
41193: PPUSH
41194: LD_VAR 0 1
41198: PPUSH
41199: CALL_OW 292
41203: ST_TO_ADDR
// end ;
41204: LD_VAR 0 2
41208: RET
// export function ReverseDir ( unit ) ; begin
41209: LD_INT 0
41211: PPUSH
// if not unit then
41212: LD_VAR 0 1
41216: NOT
41217: IFFALSE 41221
// exit ;
41219: GO 41244
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
41221: LD_ADDR_VAR 0 2
41225: PUSH
41226: LD_VAR 0 1
41230: PPUSH
41231: CALL_OW 254
41235: PUSH
41236: LD_INT 3
41238: PLUS
41239: PUSH
41240: LD_INT 6
41242: MOD
41243: ST_TO_ADDR
// end ;
41244: LD_VAR 0 2
41248: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
41249: LD_INT 0
41251: PPUSH
41252: PPUSH
41253: PPUSH
41254: PPUSH
41255: PPUSH
// if not hexes then
41256: LD_VAR 0 2
41260: NOT
41261: IFFALSE 41265
// exit ;
41263: GO 41413
// dist := 9999 ;
41265: LD_ADDR_VAR 0 5
41269: PUSH
41270: LD_INT 9999
41272: ST_TO_ADDR
// for i = 1 to hexes do
41273: LD_ADDR_VAR 0 4
41277: PUSH
41278: DOUBLE
41279: LD_INT 1
41281: DEC
41282: ST_TO_ADDR
41283: LD_VAR 0 2
41287: PUSH
41288: FOR_TO
41289: IFFALSE 41401
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
41291: LD_VAR 0 1
41295: PPUSH
41296: LD_VAR 0 2
41300: PUSH
41301: LD_VAR 0 4
41305: ARRAY
41306: PUSH
41307: LD_INT 1
41309: ARRAY
41310: PPUSH
41311: LD_VAR 0 2
41315: PUSH
41316: LD_VAR 0 4
41320: ARRAY
41321: PUSH
41322: LD_INT 2
41324: ARRAY
41325: PPUSH
41326: CALL_OW 297
41330: PUSH
41331: LD_VAR 0 5
41335: LESS
41336: IFFALSE 41399
// begin hex := hexes [ i ] ;
41338: LD_ADDR_VAR 0 7
41342: PUSH
41343: LD_VAR 0 2
41347: PUSH
41348: LD_VAR 0 4
41352: ARRAY
41353: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
41354: LD_ADDR_VAR 0 5
41358: PUSH
41359: LD_VAR 0 1
41363: PPUSH
41364: LD_VAR 0 2
41368: PUSH
41369: LD_VAR 0 4
41373: ARRAY
41374: PUSH
41375: LD_INT 1
41377: ARRAY
41378: PPUSH
41379: LD_VAR 0 2
41383: PUSH
41384: LD_VAR 0 4
41388: ARRAY
41389: PUSH
41390: LD_INT 2
41392: ARRAY
41393: PPUSH
41394: CALL_OW 297
41398: ST_TO_ADDR
// end ; end ;
41399: GO 41288
41401: POP
41402: POP
// result := hex ;
41403: LD_ADDR_VAR 0 3
41407: PUSH
41408: LD_VAR 0 7
41412: ST_TO_ADDR
// end ;
41413: LD_VAR 0 3
41417: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
41418: LD_INT 0
41420: PPUSH
41421: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
41422: LD_VAR 0 1
41426: NOT
41427: PUSH
41428: LD_VAR 0 1
41432: PUSH
41433: LD_INT 21
41435: PUSH
41436: LD_INT 2
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 23
41445: PUSH
41446: LD_INT 2
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PPUSH
41457: CALL_OW 69
41461: IN
41462: NOT
41463: OR
41464: IFFALSE 41468
// exit ;
41466: GO 41515
// for i = 1 to 3 do
41468: LD_ADDR_VAR 0 3
41472: PUSH
41473: DOUBLE
41474: LD_INT 1
41476: DEC
41477: ST_TO_ADDR
41478: LD_INT 3
41480: PUSH
41481: FOR_TO
41482: IFFALSE 41513
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
41484: LD_VAR 0 1
41488: PPUSH
41489: CALL_OW 250
41493: PPUSH
41494: LD_VAR 0 1
41498: PPUSH
41499: CALL_OW 251
41503: PPUSH
41504: LD_INT 1
41506: PPUSH
41507: CALL_OW 453
41511: GO 41481
41513: POP
41514: POP
// end ;
41515: LD_VAR 0 2
41519: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
41520: LD_INT 0
41522: PPUSH
41523: PPUSH
41524: PPUSH
41525: PPUSH
41526: PPUSH
41527: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
41528: LD_VAR 0 1
41532: NOT
41533: PUSH
41534: LD_VAR 0 2
41538: NOT
41539: OR
41540: PUSH
41541: LD_VAR 0 1
41545: PPUSH
41546: CALL_OW 314
41550: OR
41551: IFFALSE 41555
// exit ;
41553: GO 41996
// x := GetX ( enemy_unit ) ;
41555: LD_ADDR_VAR 0 7
41559: PUSH
41560: LD_VAR 0 2
41564: PPUSH
41565: CALL_OW 250
41569: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
41570: LD_ADDR_VAR 0 8
41574: PUSH
41575: LD_VAR 0 2
41579: PPUSH
41580: CALL_OW 251
41584: ST_TO_ADDR
// if not x or not y then
41585: LD_VAR 0 7
41589: NOT
41590: PUSH
41591: LD_VAR 0 8
41595: NOT
41596: OR
41597: IFFALSE 41601
// exit ;
41599: GO 41996
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
41601: LD_ADDR_VAR 0 6
41605: PUSH
41606: LD_VAR 0 7
41610: PPUSH
41611: LD_INT 0
41613: PPUSH
41614: LD_INT 4
41616: PPUSH
41617: CALL_OW 272
41621: PUSH
41622: LD_VAR 0 8
41626: PPUSH
41627: LD_INT 0
41629: PPUSH
41630: LD_INT 4
41632: PPUSH
41633: CALL_OW 273
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_VAR 0 7
41646: PPUSH
41647: LD_INT 1
41649: PPUSH
41650: LD_INT 4
41652: PPUSH
41653: CALL_OW 272
41657: PUSH
41658: LD_VAR 0 8
41662: PPUSH
41663: LD_INT 1
41665: PPUSH
41666: LD_INT 4
41668: PPUSH
41669: CALL_OW 273
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: PUSH
41678: LD_VAR 0 7
41682: PPUSH
41683: LD_INT 2
41685: PPUSH
41686: LD_INT 4
41688: PPUSH
41689: CALL_OW 272
41693: PUSH
41694: LD_VAR 0 8
41698: PPUSH
41699: LD_INT 2
41701: PPUSH
41702: LD_INT 4
41704: PPUSH
41705: CALL_OW 273
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_VAR 0 7
41718: PPUSH
41719: LD_INT 3
41721: PPUSH
41722: LD_INT 4
41724: PPUSH
41725: CALL_OW 272
41729: PUSH
41730: LD_VAR 0 8
41734: PPUSH
41735: LD_INT 3
41737: PPUSH
41738: LD_INT 4
41740: PPUSH
41741: CALL_OW 273
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: PUSH
41750: LD_VAR 0 7
41754: PPUSH
41755: LD_INT 4
41757: PPUSH
41758: LD_INT 4
41760: PPUSH
41761: CALL_OW 272
41765: PUSH
41766: LD_VAR 0 8
41770: PPUSH
41771: LD_INT 4
41773: PPUSH
41774: LD_INT 4
41776: PPUSH
41777: CALL_OW 273
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: LD_VAR 0 7
41790: PPUSH
41791: LD_INT 5
41793: PPUSH
41794: LD_INT 4
41796: PPUSH
41797: CALL_OW 272
41801: PUSH
41802: LD_VAR 0 8
41806: PPUSH
41807: LD_INT 5
41809: PPUSH
41810: LD_INT 4
41812: PPUSH
41813: CALL_OW 273
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: LIST
41826: LIST
41827: LIST
41828: LIST
41829: ST_TO_ADDR
// for i = tmp downto 1 do
41830: LD_ADDR_VAR 0 4
41834: PUSH
41835: DOUBLE
41836: LD_VAR 0 6
41840: INC
41841: ST_TO_ADDR
41842: LD_INT 1
41844: PUSH
41845: FOR_DOWNTO
41846: IFFALSE 41947
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
41848: LD_VAR 0 6
41852: PUSH
41853: LD_VAR 0 4
41857: ARRAY
41858: PUSH
41859: LD_INT 1
41861: ARRAY
41862: PPUSH
41863: LD_VAR 0 6
41867: PUSH
41868: LD_VAR 0 4
41872: ARRAY
41873: PUSH
41874: LD_INT 2
41876: ARRAY
41877: PPUSH
41878: CALL_OW 488
41882: NOT
41883: PUSH
41884: LD_VAR 0 6
41888: PUSH
41889: LD_VAR 0 4
41893: ARRAY
41894: PUSH
41895: LD_INT 1
41897: ARRAY
41898: PPUSH
41899: LD_VAR 0 6
41903: PUSH
41904: LD_VAR 0 4
41908: ARRAY
41909: PUSH
41910: LD_INT 2
41912: ARRAY
41913: PPUSH
41914: CALL_OW 428
41918: PUSH
41919: LD_INT 0
41921: NONEQUAL
41922: OR
41923: IFFALSE 41945
// tmp := Delete ( tmp , i ) ;
41925: LD_ADDR_VAR 0 6
41929: PUSH
41930: LD_VAR 0 6
41934: PPUSH
41935: LD_VAR 0 4
41939: PPUSH
41940: CALL_OW 3
41944: ST_TO_ADDR
41945: GO 41845
41947: POP
41948: POP
// j := GetClosestHex ( unit , tmp ) ;
41949: LD_ADDR_VAR 0 5
41953: PUSH
41954: LD_VAR 0 1
41958: PPUSH
41959: LD_VAR 0 6
41963: PPUSH
41964: CALL 41249 0 2
41968: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
41969: LD_VAR 0 1
41973: PPUSH
41974: LD_VAR 0 5
41978: PUSH
41979: LD_INT 1
41981: ARRAY
41982: PPUSH
41983: LD_VAR 0 5
41987: PUSH
41988: LD_INT 2
41990: ARRAY
41991: PPUSH
41992: CALL_OW 111
// end ;
41996: LD_VAR 0 3
42000: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
42001: LD_INT 0
42003: PPUSH
42004: PPUSH
42005: PPUSH
// uc_side = 0 ;
42006: LD_ADDR_OWVAR 20
42010: PUSH
42011: LD_INT 0
42013: ST_TO_ADDR
// uc_nation = 0 ;
42014: LD_ADDR_OWVAR 21
42018: PUSH
42019: LD_INT 0
42021: ST_TO_ADDR
// InitHc_All ( ) ;
42022: CALL_OW 584
// InitVc ;
42026: CALL_OW 20
// if mastodonts then
42030: LD_VAR 0 6
42034: IFFALSE 42101
// for i = 1 to mastodonts do
42036: LD_ADDR_VAR 0 11
42040: PUSH
42041: DOUBLE
42042: LD_INT 1
42044: DEC
42045: ST_TO_ADDR
42046: LD_VAR 0 6
42050: PUSH
42051: FOR_TO
42052: IFFALSE 42099
// begin vc_chassis := 31 ;
42054: LD_ADDR_OWVAR 37
42058: PUSH
42059: LD_INT 31
42061: ST_TO_ADDR
// vc_control := control_rider ;
42062: LD_ADDR_OWVAR 38
42066: PUSH
42067: LD_INT 4
42069: ST_TO_ADDR
// animal := CreateVehicle ;
42070: LD_ADDR_VAR 0 12
42074: PUSH
42075: CALL_OW 45
42079: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42080: LD_VAR 0 12
42084: PPUSH
42085: LD_VAR 0 8
42089: PPUSH
42090: LD_INT 0
42092: PPUSH
42093: CALL 44289 0 3
// end ;
42097: GO 42051
42099: POP
42100: POP
// if horses then
42101: LD_VAR 0 5
42105: IFFALSE 42172
// for i = 1 to horses do
42107: LD_ADDR_VAR 0 11
42111: PUSH
42112: DOUBLE
42113: LD_INT 1
42115: DEC
42116: ST_TO_ADDR
42117: LD_VAR 0 5
42121: PUSH
42122: FOR_TO
42123: IFFALSE 42170
// begin hc_class := 21 ;
42125: LD_ADDR_OWVAR 28
42129: PUSH
42130: LD_INT 21
42132: ST_TO_ADDR
// hc_gallery :=  ;
42133: LD_ADDR_OWVAR 33
42137: PUSH
42138: LD_STRING 
42140: ST_TO_ADDR
// animal := CreateHuman ;
42141: LD_ADDR_VAR 0 12
42145: PUSH
42146: CALL_OW 44
42150: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42151: LD_VAR 0 12
42155: PPUSH
42156: LD_VAR 0 8
42160: PPUSH
42161: LD_INT 0
42163: PPUSH
42164: CALL 44289 0 3
// end ;
42168: GO 42122
42170: POP
42171: POP
// if birds then
42172: LD_VAR 0 1
42176: IFFALSE 42243
// for i = 1 to birds do
42178: LD_ADDR_VAR 0 11
42182: PUSH
42183: DOUBLE
42184: LD_INT 1
42186: DEC
42187: ST_TO_ADDR
42188: LD_VAR 0 1
42192: PUSH
42193: FOR_TO
42194: IFFALSE 42241
// begin hc_class = 18 ;
42196: LD_ADDR_OWVAR 28
42200: PUSH
42201: LD_INT 18
42203: ST_TO_ADDR
// hc_gallery =  ;
42204: LD_ADDR_OWVAR 33
42208: PUSH
42209: LD_STRING 
42211: ST_TO_ADDR
// animal := CreateHuman ;
42212: LD_ADDR_VAR 0 12
42216: PUSH
42217: CALL_OW 44
42221: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42222: LD_VAR 0 12
42226: PPUSH
42227: LD_VAR 0 8
42231: PPUSH
42232: LD_INT 0
42234: PPUSH
42235: CALL 44289 0 3
// end ;
42239: GO 42193
42241: POP
42242: POP
// if tigers then
42243: LD_VAR 0 2
42247: IFFALSE 42331
// for i = 1 to tigers do
42249: LD_ADDR_VAR 0 11
42253: PUSH
42254: DOUBLE
42255: LD_INT 1
42257: DEC
42258: ST_TO_ADDR
42259: LD_VAR 0 2
42263: PUSH
42264: FOR_TO
42265: IFFALSE 42329
// begin hc_class = class_tiger ;
42267: LD_ADDR_OWVAR 28
42271: PUSH
42272: LD_INT 14
42274: ST_TO_ADDR
// hc_gallery =  ;
42275: LD_ADDR_OWVAR 33
42279: PUSH
42280: LD_STRING 
42282: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
42283: LD_ADDR_OWVAR 35
42287: PUSH
42288: LD_INT 7
42290: NEG
42291: PPUSH
42292: LD_INT 7
42294: PPUSH
42295: CALL_OW 12
42299: ST_TO_ADDR
// animal := CreateHuman ;
42300: LD_ADDR_VAR 0 12
42304: PUSH
42305: CALL_OW 44
42309: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42310: LD_VAR 0 12
42314: PPUSH
42315: LD_VAR 0 8
42319: PPUSH
42320: LD_INT 0
42322: PPUSH
42323: CALL 44289 0 3
// end ;
42327: GO 42264
42329: POP
42330: POP
// if apemans then
42331: LD_VAR 0 3
42335: IFFALSE 42458
// for i = 1 to apemans do
42337: LD_ADDR_VAR 0 11
42341: PUSH
42342: DOUBLE
42343: LD_INT 1
42345: DEC
42346: ST_TO_ADDR
42347: LD_VAR 0 3
42351: PUSH
42352: FOR_TO
42353: IFFALSE 42456
// begin hc_class = class_apeman ;
42355: LD_ADDR_OWVAR 28
42359: PUSH
42360: LD_INT 12
42362: ST_TO_ADDR
// hc_gallery =  ;
42363: LD_ADDR_OWVAR 33
42367: PUSH
42368: LD_STRING 
42370: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
42371: LD_ADDR_OWVAR 35
42375: PUSH
42376: LD_INT 5
42378: NEG
42379: PPUSH
42380: LD_INT 5
42382: PPUSH
42383: CALL_OW 12
42387: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
42388: LD_ADDR_OWVAR 31
42392: PUSH
42393: LD_INT 1
42395: PPUSH
42396: LD_INT 3
42398: PPUSH
42399: CALL_OW 12
42403: PUSH
42404: LD_INT 1
42406: PPUSH
42407: LD_INT 3
42409: PPUSH
42410: CALL_OW 12
42414: PUSH
42415: LD_INT 0
42417: PUSH
42418: LD_INT 0
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: LIST
42425: LIST
42426: ST_TO_ADDR
// animal := CreateHuman ;
42427: LD_ADDR_VAR 0 12
42431: PUSH
42432: CALL_OW 44
42436: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42437: LD_VAR 0 12
42441: PPUSH
42442: LD_VAR 0 8
42446: PPUSH
42447: LD_INT 0
42449: PPUSH
42450: CALL 44289 0 3
// end ;
42454: GO 42352
42456: POP
42457: POP
// if enchidnas then
42458: LD_VAR 0 4
42462: IFFALSE 42529
// for i = 1 to enchidnas do
42464: LD_ADDR_VAR 0 11
42468: PUSH
42469: DOUBLE
42470: LD_INT 1
42472: DEC
42473: ST_TO_ADDR
42474: LD_VAR 0 4
42478: PUSH
42479: FOR_TO
42480: IFFALSE 42527
// begin hc_class = 13 ;
42482: LD_ADDR_OWVAR 28
42486: PUSH
42487: LD_INT 13
42489: ST_TO_ADDR
// hc_gallery =  ;
42490: LD_ADDR_OWVAR 33
42494: PUSH
42495: LD_STRING 
42497: ST_TO_ADDR
// animal := CreateHuman ;
42498: LD_ADDR_VAR 0 12
42502: PUSH
42503: CALL_OW 44
42507: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42508: LD_VAR 0 12
42512: PPUSH
42513: LD_VAR 0 8
42517: PPUSH
42518: LD_INT 0
42520: PPUSH
42521: CALL 44289 0 3
// end ;
42525: GO 42479
42527: POP
42528: POP
// if fishes then
42529: LD_VAR 0 7
42533: IFFALSE 42600
// for i = 1 to fishes do
42535: LD_ADDR_VAR 0 11
42539: PUSH
42540: DOUBLE
42541: LD_INT 1
42543: DEC
42544: ST_TO_ADDR
42545: LD_VAR 0 7
42549: PUSH
42550: FOR_TO
42551: IFFALSE 42598
// begin hc_class = 20 ;
42553: LD_ADDR_OWVAR 28
42557: PUSH
42558: LD_INT 20
42560: ST_TO_ADDR
// hc_gallery =  ;
42561: LD_ADDR_OWVAR 33
42565: PUSH
42566: LD_STRING 
42568: ST_TO_ADDR
// animal := CreateHuman ;
42569: LD_ADDR_VAR 0 12
42573: PUSH
42574: CALL_OW 44
42578: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
42579: LD_VAR 0 12
42583: PPUSH
42584: LD_VAR 0 9
42588: PPUSH
42589: LD_INT 0
42591: PPUSH
42592: CALL 44289 0 3
// end ;
42596: GO 42550
42598: POP
42599: POP
// end ;
42600: LD_VAR 0 10
42604: RET
// export function WantHeal ( sci , unit ) ; begin
42605: LD_INT 0
42607: PPUSH
// if GetTaskList ( sci ) > 0 then
42608: LD_VAR 0 1
42612: PPUSH
42613: CALL_OW 437
42617: PUSH
42618: LD_INT 0
42620: GREATER
42621: IFFALSE 42691
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
42623: LD_VAR 0 1
42627: PPUSH
42628: CALL_OW 437
42632: PUSH
42633: LD_INT 1
42635: ARRAY
42636: PUSH
42637: LD_INT 1
42639: ARRAY
42640: PUSH
42641: LD_STRING l
42643: EQUAL
42644: PUSH
42645: LD_VAR 0 1
42649: PPUSH
42650: CALL_OW 437
42654: PUSH
42655: LD_INT 1
42657: ARRAY
42658: PUSH
42659: LD_INT 4
42661: ARRAY
42662: PUSH
42663: LD_VAR 0 2
42667: EQUAL
42668: AND
42669: IFFALSE 42681
// result := true else
42671: LD_ADDR_VAR 0 3
42675: PUSH
42676: LD_INT 1
42678: ST_TO_ADDR
42679: GO 42689
// result := false ;
42681: LD_ADDR_VAR 0 3
42685: PUSH
42686: LD_INT 0
42688: ST_TO_ADDR
// end else
42689: GO 42699
// result := false ;
42691: LD_ADDR_VAR 0 3
42695: PUSH
42696: LD_INT 0
42698: ST_TO_ADDR
// end ;
42699: LD_VAR 0 3
42703: RET
// export function HealTarget ( sci ) ; begin
42704: LD_INT 0
42706: PPUSH
// if not sci then
42707: LD_VAR 0 1
42711: NOT
42712: IFFALSE 42716
// exit ;
42714: GO 42781
// result := 0 ;
42716: LD_ADDR_VAR 0 2
42720: PUSH
42721: LD_INT 0
42723: ST_TO_ADDR
// if GetTaskList ( sci ) then
42724: LD_VAR 0 1
42728: PPUSH
42729: CALL_OW 437
42733: IFFALSE 42781
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
42735: LD_VAR 0 1
42739: PPUSH
42740: CALL_OW 437
42744: PUSH
42745: LD_INT 1
42747: ARRAY
42748: PUSH
42749: LD_INT 1
42751: ARRAY
42752: PUSH
42753: LD_STRING l
42755: EQUAL
42756: IFFALSE 42781
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
42758: LD_ADDR_VAR 0 2
42762: PUSH
42763: LD_VAR 0 1
42767: PPUSH
42768: CALL_OW 437
42772: PUSH
42773: LD_INT 1
42775: ARRAY
42776: PUSH
42777: LD_INT 4
42779: ARRAY
42780: ST_TO_ADDR
// end ;
42781: LD_VAR 0 2
42785: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
42786: LD_INT 0
42788: PPUSH
42789: PPUSH
42790: PPUSH
42791: PPUSH
// if not base_units then
42792: LD_VAR 0 1
42796: NOT
42797: IFFALSE 42801
// exit ;
42799: GO 42888
// result := false ;
42801: LD_ADDR_VAR 0 2
42805: PUSH
42806: LD_INT 0
42808: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
42809: LD_ADDR_VAR 0 5
42813: PUSH
42814: LD_VAR 0 1
42818: PPUSH
42819: LD_INT 21
42821: PUSH
42822: LD_INT 3
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PPUSH
42829: CALL_OW 72
42833: ST_TO_ADDR
// if not tmp then
42834: LD_VAR 0 5
42838: NOT
42839: IFFALSE 42843
// exit ;
42841: GO 42888
// for i in tmp do
42843: LD_ADDR_VAR 0 3
42847: PUSH
42848: LD_VAR 0 5
42852: PUSH
42853: FOR_IN
42854: IFFALSE 42886
// begin result := EnemyInRange ( i , 22 ) ;
42856: LD_ADDR_VAR 0 2
42860: PUSH
42861: LD_VAR 0 3
42865: PPUSH
42866: LD_INT 22
42868: PPUSH
42869: CALL 41124 0 2
42873: ST_TO_ADDR
// if result then
42874: LD_VAR 0 2
42878: IFFALSE 42884
// exit ;
42880: POP
42881: POP
42882: GO 42888
// end ;
42884: GO 42853
42886: POP
42887: POP
// end ;
42888: LD_VAR 0 2
42892: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
42893: LD_INT 0
42895: PPUSH
42896: PPUSH
// if not units then
42897: LD_VAR 0 1
42901: NOT
42902: IFFALSE 42906
// exit ;
42904: GO 42976
// result := [ ] ;
42906: LD_ADDR_VAR 0 3
42910: PUSH
42911: EMPTY
42912: ST_TO_ADDR
// for i in units do
42913: LD_ADDR_VAR 0 4
42917: PUSH
42918: LD_VAR 0 1
42922: PUSH
42923: FOR_IN
42924: IFFALSE 42974
// if GetTag ( i ) = tag then
42926: LD_VAR 0 4
42930: PPUSH
42931: CALL_OW 110
42935: PUSH
42936: LD_VAR 0 2
42940: EQUAL
42941: IFFALSE 42972
// result := Insert ( result , result + 1 , i ) ;
42943: LD_ADDR_VAR 0 3
42947: PUSH
42948: LD_VAR 0 3
42952: PPUSH
42953: LD_VAR 0 3
42957: PUSH
42958: LD_INT 1
42960: PLUS
42961: PPUSH
42962: LD_VAR 0 4
42966: PPUSH
42967: CALL_OW 2
42971: ST_TO_ADDR
42972: GO 42923
42974: POP
42975: POP
// end ;
42976: LD_VAR 0 3
42980: RET
// export function IsDriver ( un ) ; begin
42981: LD_INT 0
42983: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
42984: LD_ADDR_VAR 0 2
42988: PUSH
42989: LD_VAR 0 1
42993: PUSH
42994: LD_INT 55
42996: PUSH
42997: EMPTY
42998: LIST
42999: PPUSH
43000: CALL_OW 69
43004: IN
43005: ST_TO_ADDR
// end ;
43006: LD_VAR 0 2
43010: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
43011: LD_INT 0
43013: PPUSH
43014: PPUSH
// list := [ ] ;
43015: LD_ADDR_VAR 0 5
43019: PUSH
43020: EMPTY
43021: ST_TO_ADDR
// case d of 0 :
43022: LD_VAR 0 3
43026: PUSH
43027: LD_INT 0
43029: DOUBLE
43030: EQUAL
43031: IFTRUE 43035
43033: GO 43168
43035: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
43036: LD_ADDR_VAR 0 5
43040: PUSH
43041: LD_VAR 0 1
43045: PUSH
43046: LD_INT 4
43048: MINUS
43049: PUSH
43050: LD_VAR 0 2
43054: PUSH
43055: LD_INT 4
43057: MINUS
43058: PUSH
43059: LD_INT 2
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: LIST
43066: PUSH
43067: LD_VAR 0 1
43071: PUSH
43072: LD_INT 3
43074: MINUS
43075: PUSH
43076: LD_VAR 0 2
43080: PUSH
43081: LD_INT 1
43083: PUSH
43084: EMPTY
43085: LIST
43086: LIST
43087: LIST
43088: PUSH
43089: LD_VAR 0 1
43093: PUSH
43094: LD_INT 4
43096: PLUS
43097: PUSH
43098: LD_VAR 0 2
43102: PUSH
43103: LD_INT 4
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: LIST
43110: PUSH
43111: LD_VAR 0 1
43115: PUSH
43116: LD_INT 3
43118: PLUS
43119: PUSH
43120: LD_VAR 0 2
43124: PUSH
43125: LD_INT 3
43127: PLUS
43128: PUSH
43129: LD_INT 5
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: LIST
43136: PUSH
43137: LD_VAR 0 1
43141: PUSH
43142: LD_VAR 0 2
43146: PUSH
43147: LD_INT 4
43149: PLUS
43150: PUSH
43151: LD_INT 0
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: LIST
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: LIST
43163: LIST
43164: LIST
43165: ST_TO_ADDR
// end ; 1 :
43166: GO 43866
43168: LD_INT 1
43170: DOUBLE
43171: EQUAL
43172: IFTRUE 43176
43174: GO 43309
43176: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
43177: LD_ADDR_VAR 0 5
43181: PUSH
43182: LD_VAR 0 1
43186: PUSH
43187: LD_VAR 0 2
43191: PUSH
43192: LD_INT 4
43194: MINUS
43195: PUSH
43196: LD_INT 3
43198: PUSH
43199: EMPTY
43200: LIST
43201: LIST
43202: LIST
43203: PUSH
43204: LD_VAR 0 1
43208: PUSH
43209: LD_INT 3
43211: MINUS
43212: PUSH
43213: LD_VAR 0 2
43217: PUSH
43218: LD_INT 3
43220: MINUS
43221: PUSH
43222: LD_INT 2
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: LIST
43229: PUSH
43230: LD_VAR 0 1
43234: PUSH
43235: LD_INT 4
43237: MINUS
43238: PUSH
43239: LD_VAR 0 2
43243: PUSH
43244: LD_INT 1
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: LIST
43251: PUSH
43252: LD_VAR 0 1
43256: PUSH
43257: LD_VAR 0 2
43261: PUSH
43262: LD_INT 3
43264: PLUS
43265: PUSH
43266: LD_INT 0
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: LIST
43273: PUSH
43274: LD_VAR 0 1
43278: PUSH
43279: LD_INT 4
43281: PLUS
43282: PUSH
43283: LD_VAR 0 2
43287: PUSH
43288: LD_INT 4
43290: PLUS
43291: PUSH
43292: LD_INT 5
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: LIST
43299: PUSH
43300: EMPTY
43301: LIST
43302: LIST
43303: LIST
43304: LIST
43305: LIST
43306: ST_TO_ADDR
// end ; 2 :
43307: GO 43866
43309: LD_INT 2
43311: DOUBLE
43312: EQUAL
43313: IFTRUE 43317
43315: GO 43446
43317: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
43318: LD_ADDR_VAR 0 5
43322: PUSH
43323: LD_VAR 0 1
43327: PUSH
43328: LD_VAR 0 2
43332: PUSH
43333: LD_INT 3
43335: MINUS
43336: PUSH
43337: LD_INT 3
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: LIST
43344: PUSH
43345: LD_VAR 0 1
43349: PUSH
43350: LD_INT 4
43352: PLUS
43353: PUSH
43354: LD_VAR 0 2
43358: PUSH
43359: LD_INT 4
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: LIST
43366: PUSH
43367: LD_VAR 0 1
43371: PUSH
43372: LD_VAR 0 2
43376: PUSH
43377: LD_INT 4
43379: PLUS
43380: PUSH
43381: LD_INT 0
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: LIST
43388: PUSH
43389: LD_VAR 0 1
43393: PUSH
43394: LD_INT 3
43396: MINUS
43397: PUSH
43398: LD_VAR 0 2
43402: PUSH
43403: LD_INT 1
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: LIST
43410: PUSH
43411: LD_VAR 0 1
43415: PUSH
43416: LD_INT 4
43418: MINUS
43419: PUSH
43420: LD_VAR 0 2
43424: PUSH
43425: LD_INT 4
43427: MINUS
43428: PUSH
43429: LD_INT 2
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: LIST
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: LIST
43441: LIST
43442: LIST
43443: ST_TO_ADDR
// end ; 3 :
43444: GO 43866
43446: LD_INT 3
43448: DOUBLE
43449: EQUAL
43450: IFTRUE 43454
43452: GO 43587
43454: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
43455: LD_ADDR_VAR 0 5
43459: PUSH
43460: LD_VAR 0 1
43464: PUSH
43465: LD_INT 3
43467: PLUS
43468: PUSH
43469: LD_VAR 0 2
43473: PUSH
43474: LD_INT 4
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: LIST
43481: PUSH
43482: LD_VAR 0 1
43486: PUSH
43487: LD_INT 4
43489: PLUS
43490: PUSH
43491: LD_VAR 0 2
43495: PUSH
43496: LD_INT 4
43498: PLUS
43499: PUSH
43500: LD_INT 5
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: LIST
43507: PUSH
43508: LD_VAR 0 1
43512: PUSH
43513: LD_INT 4
43515: MINUS
43516: PUSH
43517: LD_VAR 0 2
43521: PUSH
43522: LD_INT 1
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: LIST
43529: PUSH
43530: LD_VAR 0 1
43534: PUSH
43535: LD_VAR 0 2
43539: PUSH
43540: LD_INT 4
43542: MINUS
43543: PUSH
43544: LD_INT 3
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: LIST
43551: PUSH
43552: LD_VAR 0 1
43556: PUSH
43557: LD_INT 3
43559: MINUS
43560: PUSH
43561: LD_VAR 0 2
43565: PUSH
43566: LD_INT 3
43568: MINUS
43569: PUSH
43570: LD_INT 2
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: LIST
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: LIST
43584: ST_TO_ADDR
// end ; 4 :
43585: GO 43866
43587: LD_INT 4
43589: DOUBLE
43590: EQUAL
43591: IFTRUE 43595
43593: GO 43728
43595: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
43596: LD_ADDR_VAR 0 5
43600: PUSH
43601: LD_VAR 0 1
43605: PUSH
43606: LD_VAR 0 2
43610: PUSH
43611: LD_INT 4
43613: PLUS
43614: PUSH
43615: LD_INT 0
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: LIST
43622: PUSH
43623: LD_VAR 0 1
43627: PUSH
43628: LD_INT 3
43630: PLUS
43631: PUSH
43632: LD_VAR 0 2
43636: PUSH
43637: LD_INT 3
43639: PLUS
43640: PUSH
43641: LD_INT 5
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: LIST
43648: PUSH
43649: LD_VAR 0 1
43653: PUSH
43654: LD_INT 4
43656: PLUS
43657: PUSH
43658: LD_VAR 0 2
43662: PUSH
43663: LD_INT 4
43665: PUSH
43666: EMPTY
43667: LIST
43668: LIST
43669: LIST
43670: PUSH
43671: LD_VAR 0 1
43675: PUSH
43676: LD_VAR 0 2
43680: PUSH
43681: LD_INT 3
43683: MINUS
43684: PUSH
43685: LD_INT 3
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: LIST
43692: PUSH
43693: LD_VAR 0 1
43697: PUSH
43698: LD_INT 4
43700: MINUS
43701: PUSH
43702: LD_VAR 0 2
43706: PUSH
43707: LD_INT 4
43709: MINUS
43710: PUSH
43711: LD_INT 2
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: LIST
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: ST_TO_ADDR
// end ; 5 :
43726: GO 43866
43728: LD_INT 5
43730: DOUBLE
43731: EQUAL
43732: IFTRUE 43736
43734: GO 43865
43736: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
43737: LD_ADDR_VAR 0 5
43741: PUSH
43742: LD_VAR 0 1
43746: PUSH
43747: LD_INT 4
43749: MINUS
43750: PUSH
43751: LD_VAR 0 2
43755: PUSH
43756: LD_INT 1
43758: PUSH
43759: EMPTY
43760: LIST
43761: LIST
43762: LIST
43763: PUSH
43764: LD_VAR 0 1
43768: PUSH
43769: LD_VAR 0 2
43773: PUSH
43774: LD_INT 4
43776: MINUS
43777: PUSH
43778: LD_INT 3
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: LIST
43785: PUSH
43786: LD_VAR 0 1
43790: PUSH
43791: LD_INT 4
43793: PLUS
43794: PUSH
43795: LD_VAR 0 2
43799: PUSH
43800: LD_INT 4
43802: PLUS
43803: PUSH
43804: LD_INT 5
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: LIST
43811: PUSH
43812: LD_VAR 0 1
43816: PUSH
43817: LD_INT 3
43819: PLUS
43820: PUSH
43821: LD_VAR 0 2
43825: PUSH
43826: LD_INT 4
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: LIST
43833: PUSH
43834: LD_VAR 0 1
43838: PUSH
43839: LD_VAR 0 2
43843: PUSH
43844: LD_INT 3
43846: PLUS
43847: PUSH
43848: LD_INT 0
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: LIST
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: LIST
43862: ST_TO_ADDR
// end ; end ;
43863: GO 43866
43865: POP
// result := list ;
43866: LD_ADDR_VAR 0 4
43870: PUSH
43871: LD_VAR 0 5
43875: ST_TO_ADDR
// end ;
43876: LD_VAR 0 4
43880: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
43881: LD_INT 0
43883: PPUSH
43884: PPUSH
43885: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
43886: LD_VAR 0 1
43890: NOT
43891: PUSH
43892: LD_VAR 0 2
43896: PUSH
43897: LD_INT 1
43899: PUSH
43900: LD_INT 2
43902: PUSH
43903: LD_INT 3
43905: PUSH
43906: LD_INT 4
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: IN
43915: NOT
43916: OR
43917: IFFALSE 43921
// exit ;
43919: GO 44013
// tmp := [ ] ;
43921: LD_ADDR_VAR 0 5
43925: PUSH
43926: EMPTY
43927: ST_TO_ADDR
// for i in units do
43928: LD_ADDR_VAR 0 4
43932: PUSH
43933: LD_VAR 0 1
43937: PUSH
43938: FOR_IN
43939: IFFALSE 43982
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
43941: LD_ADDR_VAR 0 5
43945: PUSH
43946: LD_VAR 0 5
43950: PPUSH
43951: LD_VAR 0 5
43955: PUSH
43956: LD_INT 1
43958: PLUS
43959: PPUSH
43960: LD_VAR 0 4
43964: PPUSH
43965: LD_VAR 0 2
43969: PPUSH
43970: CALL_OW 259
43974: PPUSH
43975: CALL_OW 2
43979: ST_TO_ADDR
43980: GO 43938
43982: POP
43983: POP
// if not tmp then
43984: LD_VAR 0 5
43988: NOT
43989: IFFALSE 43993
// exit ;
43991: GO 44013
// result := SortListByListDesc ( units , tmp ) ;
43993: LD_ADDR_VAR 0 3
43997: PUSH
43998: LD_VAR 0 1
44002: PPUSH
44003: LD_VAR 0 5
44007: PPUSH
44008: CALL_OW 77
44012: ST_TO_ADDR
// end ;
44013: LD_VAR 0 3
44017: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
44018: LD_INT 0
44020: PPUSH
44021: PPUSH
44022: PPUSH
// result := false ;
44023: LD_ADDR_VAR 0 3
44027: PUSH
44028: LD_INT 0
44030: ST_TO_ADDR
// x := GetX ( building ) ;
44031: LD_ADDR_VAR 0 4
44035: PUSH
44036: LD_VAR 0 2
44040: PPUSH
44041: CALL_OW 250
44045: ST_TO_ADDR
// y := GetY ( building ) ;
44046: LD_ADDR_VAR 0 5
44050: PUSH
44051: LD_VAR 0 2
44055: PPUSH
44056: CALL_OW 251
44060: ST_TO_ADDR
// if not building or not x or not y then
44061: LD_VAR 0 2
44065: NOT
44066: PUSH
44067: LD_VAR 0 4
44071: NOT
44072: OR
44073: PUSH
44074: LD_VAR 0 5
44078: NOT
44079: OR
44080: IFFALSE 44084
// exit ;
44082: GO 44176
// if GetTaskList ( unit ) then
44084: LD_VAR 0 1
44088: PPUSH
44089: CALL_OW 437
44093: IFFALSE 44176
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44095: LD_STRING e
44097: PUSH
44098: LD_VAR 0 1
44102: PPUSH
44103: CALL_OW 437
44107: PUSH
44108: LD_INT 1
44110: ARRAY
44111: PUSH
44112: LD_INT 1
44114: ARRAY
44115: EQUAL
44116: PUSH
44117: LD_VAR 0 4
44121: PUSH
44122: LD_VAR 0 1
44126: PPUSH
44127: CALL_OW 437
44131: PUSH
44132: LD_INT 1
44134: ARRAY
44135: PUSH
44136: LD_INT 2
44138: ARRAY
44139: EQUAL
44140: AND
44141: PUSH
44142: LD_VAR 0 5
44146: PUSH
44147: LD_VAR 0 1
44151: PPUSH
44152: CALL_OW 437
44156: PUSH
44157: LD_INT 1
44159: ARRAY
44160: PUSH
44161: LD_INT 3
44163: ARRAY
44164: EQUAL
44165: AND
44166: IFFALSE 44176
// result := true end ;
44168: LD_ADDR_VAR 0 3
44172: PUSH
44173: LD_INT 1
44175: ST_TO_ADDR
// end ;
44176: LD_VAR 0 3
44180: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
44181: LD_INT 0
44183: PPUSH
// result := false ;
44184: LD_ADDR_VAR 0 4
44188: PUSH
44189: LD_INT 0
44191: ST_TO_ADDR
// if GetTaskList ( unit ) then
44192: LD_VAR 0 1
44196: PPUSH
44197: CALL_OW 437
44201: IFFALSE 44284
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44203: LD_STRING M
44205: PUSH
44206: LD_VAR 0 1
44210: PPUSH
44211: CALL_OW 437
44215: PUSH
44216: LD_INT 1
44218: ARRAY
44219: PUSH
44220: LD_INT 1
44222: ARRAY
44223: EQUAL
44224: PUSH
44225: LD_VAR 0 2
44229: PUSH
44230: LD_VAR 0 1
44234: PPUSH
44235: CALL_OW 437
44239: PUSH
44240: LD_INT 1
44242: ARRAY
44243: PUSH
44244: LD_INT 2
44246: ARRAY
44247: EQUAL
44248: AND
44249: PUSH
44250: LD_VAR 0 3
44254: PUSH
44255: LD_VAR 0 1
44259: PPUSH
44260: CALL_OW 437
44264: PUSH
44265: LD_INT 1
44267: ARRAY
44268: PUSH
44269: LD_INT 3
44271: ARRAY
44272: EQUAL
44273: AND
44274: IFFALSE 44284
// result := true ;
44276: LD_ADDR_VAR 0 4
44280: PUSH
44281: LD_INT 1
44283: ST_TO_ADDR
// end ; end ;
44284: LD_VAR 0 4
44288: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
44289: LD_INT 0
44291: PPUSH
44292: PPUSH
44293: PPUSH
44294: PPUSH
// if not unit or not area then
44295: LD_VAR 0 1
44299: NOT
44300: PUSH
44301: LD_VAR 0 2
44305: NOT
44306: OR
44307: IFFALSE 44311
// exit ;
44309: GO 44475
// tmp := AreaToList ( area , i ) ;
44311: LD_ADDR_VAR 0 6
44315: PUSH
44316: LD_VAR 0 2
44320: PPUSH
44321: LD_VAR 0 5
44325: PPUSH
44326: CALL_OW 517
44330: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
44331: LD_ADDR_VAR 0 5
44335: PUSH
44336: DOUBLE
44337: LD_INT 1
44339: DEC
44340: ST_TO_ADDR
44341: LD_VAR 0 6
44345: PUSH
44346: LD_INT 1
44348: ARRAY
44349: PUSH
44350: FOR_TO
44351: IFFALSE 44473
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
44353: LD_ADDR_VAR 0 7
44357: PUSH
44358: LD_VAR 0 6
44362: PUSH
44363: LD_INT 1
44365: ARRAY
44366: PUSH
44367: LD_VAR 0 5
44371: ARRAY
44372: PUSH
44373: LD_VAR 0 6
44377: PUSH
44378: LD_INT 2
44380: ARRAY
44381: PUSH
44382: LD_VAR 0 5
44386: ARRAY
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
44392: LD_VAR 0 7
44396: PUSH
44397: LD_INT 1
44399: ARRAY
44400: PPUSH
44401: LD_VAR 0 7
44405: PUSH
44406: LD_INT 2
44408: ARRAY
44409: PPUSH
44410: CALL_OW 428
44414: PUSH
44415: LD_INT 0
44417: EQUAL
44418: IFFALSE 44471
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
44420: LD_VAR 0 1
44424: PPUSH
44425: LD_VAR 0 7
44429: PUSH
44430: LD_INT 1
44432: ARRAY
44433: PPUSH
44434: LD_VAR 0 7
44438: PUSH
44439: LD_INT 2
44441: ARRAY
44442: PPUSH
44443: LD_VAR 0 3
44447: PPUSH
44448: CALL_OW 48
// result := IsPlaced ( unit ) ;
44452: LD_ADDR_VAR 0 4
44456: PUSH
44457: LD_VAR 0 1
44461: PPUSH
44462: CALL_OW 305
44466: ST_TO_ADDR
// exit ;
44467: POP
44468: POP
44469: GO 44475
// end ; end ;
44471: GO 44350
44473: POP
44474: POP
// end ;
44475: LD_VAR 0 4
44479: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
44480: LD_INT 0
44482: PPUSH
44483: PPUSH
44484: PPUSH
// if not side or side > 8 then
44485: LD_VAR 0 1
44489: NOT
44490: PUSH
44491: LD_VAR 0 1
44495: PUSH
44496: LD_INT 8
44498: GREATER
44499: OR
44500: IFFALSE 44504
// exit ;
44502: GO 44691
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
44504: LD_ADDR_VAR 0 4
44508: PUSH
44509: LD_INT 22
44511: PUSH
44512: LD_VAR 0 1
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PUSH
44521: LD_INT 21
44523: PUSH
44524: LD_INT 3
44526: PUSH
44527: EMPTY
44528: LIST
44529: LIST
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PPUSH
44535: CALL_OW 69
44539: ST_TO_ADDR
// if not tmp then
44540: LD_VAR 0 4
44544: NOT
44545: IFFALSE 44549
// exit ;
44547: GO 44691
// enable_addtolog := true ;
44549: LD_ADDR_OWVAR 81
44553: PUSH
44554: LD_INT 1
44556: ST_TO_ADDR
// AddToLog ( [ ) ;
44557: LD_STRING [
44559: PPUSH
44560: CALL_OW 561
// for i in tmp do
44564: LD_ADDR_VAR 0 3
44568: PUSH
44569: LD_VAR 0 4
44573: PUSH
44574: FOR_IN
44575: IFFALSE 44682
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
44577: LD_STRING [
44579: PUSH
44580: LD_VAR 0 3
44584: PPUSH
44585: CALL_OW 266
44589: STR
44590: PUSH
44591: LD_STRING , 
44593: STR
44594: PUSH
44595: LD_VAR 0 3
44599: PPUSH
44600: CALL_OW 250
44604: STR
44605: PUSH
44606: LD_STRING , 
44608: STR
44609: PUSH
44610: LD_VAR 0 3
44614: PPUSH
44615: CALL_OW 251
44619: STR
44620: PUSH
44621: LD_STRING , 
44623: STR
44624: PUSH
44625: LD_VAR 0 3
44629: PPUSH
44630: CALL_OW 254
44634: STR
44635: PUSH
44636: LD_STRING , 
44638: STR
44639: PUSH
44640: LD_VAR 0 3
44644: PPUSH
44645: LD_INT 1
44647: PPUSH
44648: CALL_OW 268
44652: STR
44653: PUSH
44654: LD_STRING , 
44656: STR
44657: PUSH
44658: LD_VAR 0 3
44662: PPUSH
44663: LD_INT 2
44665: PPUSH
44666: CALL_OW 268
44670: STR
44671: PUSH
44672: LD_STRING ],
44674: STR
44675: PPUSH
44676: CALL_OW 561
// end ;
44680: GO 44574
44682: POP
44683: POP
// AddToLog ( ]; ) ;
44684: LD_STRING ];
44686: PPUSH
44687: CALL_OW 561
// end ;
44691: LD_VAR 0 2
44695: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
44696: LD_INT 0
44698: PPUSH
44699: PPUSH
44700: PPUSH
44701: PPUSH
44702: PPUSH
// if not area or not rate or not max then
44703: LD_VAR 0 1
44707: NOT
44708: PUSH
44709: LD_VAR 0 2
44713: NOT
44714: OR
44715: PUSH
44716: LD_VAR 0 4
44720: NOT
44721: OR
44722: IFFALSE 44726
// exit ;
44724: GO 44918
// while 1 do
44726: LD_INT 1
44728: IFFALSE 44918
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
44730: LD_ADDR_VAR 0 9
44734: PUSH
44735: LD_VAR 0 1
44739: PPUSH
44740: LD_INT 1
44742: PPUSH
44743: CALL_OW 287
44747: PUSH
44748: LD_INT 10
44750: MUL
44751: ST_TO_ADDR
// r := rate / 10 ;
44752: LD_ADDR_VAR 0 7
44756: PUSH
44757: LD_VAR 0 2
44761: PUSH
44762: LD_INT 10
44764: DIVREAL
44765: ST_TO_ADDR
// time := 1 1$00 ;
44766: LD_ADDR_VAR 0 8
44770: PUSH
44771: LD_INT 2100
44773: ST_TO_ADDR
// if amount < min then
44774: LD_VAR 0 9
44778: PUSH
44779: LD_VAR 0 3
44783: LESS
44784: IFFALSE 44802
// r := r * 2 else
44786: LD_ADDR_VAR 0 7
44790: PUSH
44791: LD_VAR 0 7
44795: PUSH
44796: LD_INT 2
44798: MUL
44799: ST_TO_ADDR
44800: GO 44828
// if amount > max then
44802: LD_VAR 0 9
44806: PUSH
44807: LD_VAR 0 4
44811: GREATER
44812: IFFALSE 44828
// r := r / 2 ;
44814: LD_ADDR_VAR 0 7
44818: PUSH
44819: LD_VAR 0 7
44823: PUSH
44824: LD_INT 2
44826: DIVREAL
44827: ST_TO_ADDR
// time := time / r ;
44828: LD_ADDR_VAR 0 8
44832: PUSH
44833: LD_VAR 0 8
44837: PUSH
44838: LD_VAR 0 7
44842: DIVREAL
44843: ST_TO_ADDR
// if time < 0 then
44844: LD_VAR 0 8
44848: PUSH
44849: LD_INT 0
44851: LESS
44852: IFFALSE 44869
// time := time * - 1 ;
44854: LD_ADDR_VAR 0 8
44858: PUSH
44859: LD_VAR 0 8
44863: PUSH
44864: LD_INT 1
44866: NEG
44867: MUL
44868: ST_TO_ADDR
// wait ( time ) ;
44869: LD_VAR 0 8
44873: PPUSH
44874: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
44878: LD_INT 35
44880: PPUSH
44881: LD_INT 875
44883: PPUSH
44884: CALL_OW 12
44888: PPUSH
44889: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
44893: LD_INT 1
44895: PPUSH
44896: LD_INT 5
44898: PPUSH
44899: CALL_OW 12
44903: PPUSH
44904: LD_VAR 0 1
44908: PPUSH
44909: LD_INT 1
44911: PPUSH
44912: CALL_OW 55
// end ;
44916: GO 44726
// end ;
44918: LD_VAR 0 5
44922: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
44923: LD_INT 0
44925: PPUSH
44926: PPUSH
44927: PPUSH
44928: PPUSH
44929: PPUSH
44930: PPUSH
44931: PPUSH
44932: PPUSH
// if not turrets or not factories then
44933: LD_VAR 0 1
44937: NOT
44938: PUSH
44939: LD_VAR 0 2
44943: NOT
44944: OR
44945: IFFALSE 44949
// exit ;
44947: GO 45256
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
44949: LD_ADDR_VAR 0 10
44953: PUSH
44954: LD_INT 5
44956: PUSH
44957: LD_INT 6
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PUSH
44964: LD_INT 2
44966: PUSH
44967: LD_INT 4
44969: PUSH
44970: EMPTY
44971: LIST
44972: LIST
44973: PUSH
44974: LD_INT 3
44976: PUSH
44977: LD_INT 5
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: LIST
44988: PUSH
44989: LD_INT 24
44991: PUSH
44992: LD_INT 25
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 23
45001: PUSH
45002: LD_INT 27
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PUSH
45013: LD_INT 42
45015: PUSH
45016: LD_INT 43
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 44
45025: PUSH
45026: LD_INT 46
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 45
45035: PUSH
45036: LD_INT 47
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: EMPTY
45044: LIST
45045: LIST
45046: LIST
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: LIST
45052: ST_TO_ADDR
// result := [ ] ;
45053: LD_ADDR_VAR 0 3
45057: PUSH
45058: EMPTY
45059: ST_TO_ADDR
// for i in turrets do
45060: LD_ADDR_VAR 0 4
45064: PUSH
45065: LD_VAR 0 1
45069: PUSH
45070: FOR_IN
45071: IFFALSE 45254
// begin nat := GetNation ( i ) ;
45073: LD_ADDR_VAR 0 7
45077: PUSH
45078: LD_VAR 0 4
45082: PPUSH
45083: CALL_OW 248
45087: ST_TO_ADDR
// weapon := 0 ;
45088: LD_ADDR_VAR 0 8
45092: PUSH
45093: LD_INT 0
45095: ST_TO_ADDR
// if not nat then
45096: LD_VAR 0 7
45100: NOT
45101: IFFALSE 45105
// continue ;
45103: GO 45070
// for j in list [ nat ] do
45105: LD_ADDR_VAR 0 5
45109: PUSH
45110: LD_VAR 0 10
45114: PUSH
45115: LD_VAR 0 7
45119: ARRAY
45120: PUSH
45121: FOR_IN
45122: IFFALSE 45163
// if GetBWeapon ( i ) = j [ 1 ] then
45124: LD_VAR 0 4
45128: PPUSH
45129: CALL_OW 269
45133: PUSH
45134: LD_VAR 0 5
45138: PUSH
45139: LD_INT 1
45141: ARRAY
45142: EQUAL
45143: IFFALSE 45161
// begin weapon := j [ 2 ] ;
45145: LD_ADDR_VAR 0 8
45149: PUSH
45150: LD_VAR 0 5
45154: PUSH
45155: LD_INT 2
45157: ARRAY
45158: ST_TO_ADDR
// break ;
45159: GO 45163
// end ;
45161: GO 45121
45163: POP
45164: POP
// if not weapon then
45165: LD_VAR 0 8
45169: NOT
45170: IFFALSE 45174
// continue ;
45172: GO 45070
// for k in factories do
45174: LD_ADDR_VAR 0 6
45178: PUSH
45179: LD_VAR 0 2
45183: PUSH
45184: FOR_IN
45185: IFFALSE 45250
// begin weapons := AvailableWeaponList ( k ) ;
45187: LD_ADDR_VAR 0 9
45191: PUSH
45192: LD_VAR 0 6
45196: PPUSH
45197: CALL_OW 478
45201: ST_TO_ADDR
// if not weapons then
45202: LD_VAR 0 9
45206: NOT
45207: IFFALSE 45211
// continue ;
45209: GO 45184
// if weapon in weapons then
45211: LD_VAR 0 8
45215: PUSH
45216: LD_VAR 0 9
45220: IN
45221: IFFALSE 45248
// begin result := [ i , weapon ] ;
45223: LD_ADDR_VAR 0 3
45227: PUSH
45228: LD_VAR 0 4
45232: PUSH
45233: LD_VAR 0 8
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: ST_TO_ADDR
// exit ;
45242: POP
45243: POP
45244: POP
45245: POP
45246: GO 45256
// end ; end ;
45248: GO 45184
45250: POP
45251: POP
// end ;
45252: GO 45070
45254: POP
45255: POP
// end ;
45256: LD_VAR 0 3
45260: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
45261: LD_INT 0
45263: PPUSH
// if not side or side > 8 then
45264: LD_VAR 0 3
45268: NOT
45269: PUSH
45270: LD_VAR 0 3
45274: PUSH
45275: LD_INT 8
45277: GREATER
45278: OR
45279: IFFALSE 45283
// exit ;
45281: GO 45342
// if not range then
45283: LD_VAR 0 4
45287: NOT
45288: IFFALSE 45299
// range := - 12 ;
45290: LD_ADDR_VAR 0 4
45294: PUSH
45295: LD_INT 12
45297: NEG
45298: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
45299: LD_VAR 0 1
45303: PPUSH
45304: LD_VAR 0 2
45308: PPUSH
45309: LD_VAR 0 3
45313: PPUSH
45314: LD_VAR 0 4
45318: PPUSH
45319: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
45323: LD_VAR 0 1
45327: PPUSH
45328: LD_VAR 0 2
45332: PPUSH
45333: LD_VAR 0 3
45337: PPUSH
45338: CALL_OW 331
// end ;
45342: LD_VAR 0 5
45346: RET
// export function Video ( mode ) ; begin
45347: LD_INT 0
45349: PPUSH
// ingame_video = mode ;
45350: LD_ADDR_OWVAR 52
45354: PUSH
45355: LD_VAR 0 1
45359: ST_TO_ADDR
// interface_hidden = mode ;
45360: LD_ADDR_OWVAR 54
45364: PUSH
45365: LD_VAR 0 1
45369: ST_TO_ADDR
// end ;
45370: LD_VAR 0 2
45374: RET
// export function Join ( array , element ) ; begin
45375: LD_INT 0
45377: PPUSH
// result := Replace ( array , array + 1 , element ) ;
45378: LD_ADDR_VAR 0 3
45382: PUSH
45383: LD_VAR 0 1
45387: PPUSH
45388: LD_VAR 0 1
45392: PUSH
45393: LD_INT 1
45395: PLUS
45396: PPUSH
45397: LD_VAR 0 2
45401: PPUSH
45402: CALL_OW 1
45406: ST_TO_ADDR
// end ;
45407: LD_VAR 0 3
45411: RET
// export function JoinUnion ( array , element ) ; begin
45412: LD_INT 0
45414: PPUSH
// result := array union element ;
45415: LD_ADDR_VAR 0 3
45419: PUSH
45420: LD_VAR 0 1
45424: PUSH
45425: LD_VAR 0 2
45429: UNION
45430: ST_TO_ADDR
// end ;
45431: LD_VAR 0 3
45435: RET
// export function GetBehemoths ( side ) ; begin
45436: LD_INT 0
45438: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
45439: LD_ADDR_VAR 0 2
45443: PUSH
45444: LD_INT 22
45446: PUSH
45447: LD_VAR 0 1
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 31
45458: PUSH
45459: LD_INT 25
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PPUSH
45470: CALL_OW 69
45474: ST_TO_ADDR
// end ;
45475: LD_VAR 0 2
45479: RET
// export function Shuffle ( array ) ; var i , index ; begin
45480: LD_INT 0
45482: PPUSH
45483: PPUSH
45484: PPUSH
// result := [ ] ;
45485: LD_ADDR_VAR 0 2
45489: PUSH
45490: EMPTY
45491: ST_TO_ADDR
// if not array then
45492: LD_VAR 0 1
45496: NOT
45497: IFFALSE 45501
// exit ;
45499: GO 45600
// Randomize ;
45501: CALL_OW 10
// for i = array downto 1 do
45505: LD_ADDR_VAR 0 3
45509: PUSH
45510: DOUBLE
45511: LD_VAR 0 1
45515: INC
45516: ST_TO_ADDR
45517: LD_INT 1
45519: PUSH
45520: FOR_DOWNTO
45521: IFFALSE 45598
// begin index := rand ( 1 , array ) ;
45523: LD_ADDR_VAR 0 4
45527: PUSH
45528: LD_INT 1
45530: PPUSH
45531: LD_VAR 0 1
45535: PPUSH
45536: CALL_OW 12
45540: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
45541: LD_ADDR_VAR 0 2
45545: PUSH
45546: LD_VAR 0 2
45550: PPUSH
45551: LD_VAR 0 2
45555: PUSH
45556: LD_INT 1
45558: PLUS
45559: PPUSH
45560: LD_VAR 0 1
45564: PUSH
45565: LD_VAR 0 4
45569: ARRAY
45570: PPUSH
45571: CALL_OW 2
45575: ST_TO_ADDR
// array := Delete ( array , index ) ;
45576: LD_ADDR_VAR 0 1
45580: PUSH
45581: LD_VAR 0 1
45585: PPUSH
45586: LD_VAR 0 4
45590: PPUSH
45591: CALL_OW 3
45595: ST_TO_ADDR
// end ;
45596: GO 45520
45598: POP
45599: POP
// end ;
45600: LD_VAR 0 2
45604: RET
// export function GetBaseMaterials ( base ) ; begin
45605: LD_INT 0
45607: PPUSH
// result := [ 0 , 0 , 0 ] ;
45608: LD_ADDR_VAR 0 2
45612: PUSH
45613: LD_INT 0
45615: PUSH
45616: LD_INT 0
45618: PUSH
45619: LD_INT 0
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: LIST
45626: ST_TO_ADDR
// if not base then
45627: LD_VAR 0 1
45631: NOT
45632: IFFALSE 45636
// exit ;
45634: GO 45685
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
45636: LD_ADDR_VAR 0 2
45640: PUSH
45641: LD_VAR 0 1
45645: PPUSH
45646: LD_INT 1
45648: PPUSH
45649: CALL_OW 275
45653: PUSH
45654: LD_VAR 0 1
45658: PPUSH
45659: LD_INT 2
45661: PPUSH
45662: CALL_OW 275
45666: PUSH
45667: LD_VAR 0 1
45671: PPUSH
45672: LD_INT 3
45674: PPUSH
45675: CALL_OW 275
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: LIST
45684: ST_TO_ADDR
// end ;
45685: LD_VAR 0 2
45689: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
45690: LD_INT 0
45692: PPUSH
45693: PPUSH
// result := array ;
45694: LD_ADDR_VAR 0 3
45698: PUSH
45699: LD_VAR 0 1
45703: ST_TO_ADDR
// if size > 0 then
45704: LD_VAR 0 2
45708: PUSH
45709: LD_INT 0
45711: GREATER
45712: IFFALSE 45758
// for i := array downto size do
45714: LD_ADDR_VAR 0 4
45718: PUSH
45719: DOUBLE
45720: LD_VAR 0 1
45724: INC
45725: ST_TO_ADDR
45726: LD_VAR 0 2
45730: PUSH
45731: FOR_DOWNTO
45732: IFFALSE 45756
// result := Delete ( result , result ) ;
45734: LD_ADDR_VAR 0 3
45738: PUSH
45739: LD_VAR 0 3
45743: PPUSH
45744: LD_VAR 0 3
45748: PPUSH
45749: CALL_OW 3
45753: ST_TO_ADDR
45754: GO 45731
45756: POP
45757: POP
// end ;
45758: LD_VAR 0 3
45762: RET
// export function ComExit ( unit ) ; var tmp ; begin
45763: LD_INT 0
45765: PPUSH
45766: PPUSH
// if not IsInUnit ( unit ) then
45767: LD_VAR 0 1
45771: PPUSH
45772: CALL_OW 310
45776: NOT
45777: IFFALSE 45781
// exit ;
45779: GO 45841
// tmp := IsInUnit ( unit ) ;
45781: LD_ADDR_VAR 0 3
45785: PUSH
45786: LD_VAR 0 1
45790: PPUSH
45791: CALL_OW 310
45795: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
45796: LD_VAR 0 3
45800: PPUSH
45801: CALL_OW 247
45805: PUSH
45806: LD_INT 2
45808: EQUAL
45809: IFFALSE 45822
// ComExitVehicle ( unit ) else
45811: LD_VAR 0 1
45815: PPUSH
45816: CALL_OW 121
45820: GO 45831
// ComExitBuilding ( unit ) ;
45822: LD_VAR 0 1
45826: PPUSH
45827: CALL_OW 122
// result := tmp ;
45831: LD_ADDR_VAR 0 2
45835: PUSH
45836: LD_VAR 0 3
45840: ST_TO_ADDR
// end ;
45841: LD_VAR 0 2
45845: RET
// export function ResetHc ; begin
45846: LD_INT 0
45848: PPUSH
// InitHc ;
45849: CALL_OW 19
// hc_importance := 0 ;
45853: LD_ADDR_OWVAR 32
45857: PUSH
45858: LD_INT 0
45860: ST_TO_ADDR
// end ;
45861: LD_VAR 0 1
45865: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
45866: LD_INT 0
45868: PPUSH
45869: PPUSH
45870: PPUSH
// _x := ( x1 + x2 ) div 2 ;
45871: LD_ADDR_VAR 0 6
45875: PUSH
45876: LD_VAR 0 1
45880: PUSH
45881: LD_VAR 0 3
45885: PLUS
45886: PUSH
45887: LD_INT 2
45889: DIV
45890: ST_TO_ADDR
// if _x < 0 then
45891: LD_VAR 0 6
45895: PUSH
45896: LD_INT 0
45898: LESS
45899: IFFALSE 45916
// _x := _x * - 1 ;
45901: LD_ADDR_VAR 0 6
45905: PUSH
45906: LD_VAR 0 6
45910: PUSH
45911: LD_INT 1
45913: NEG
45914: MUL
45915: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
45916: LD_ADDR_VAR 0 7
45920: PUSH
45921: LD_VAR 0 2
45925: PUSH
45926: LD_VAR 0 4
45930: PLUS
45931: PUSH
45932: LD_INT 2
45934: DIV
45935: ST_TO_ADDR
// if _y < 0 then
45936: LD_VAR 0 7
45940: PUSH
45941: LD_INT 0
45943: LESS
45944: IFFALSE 45961
// _y := _y * - 1 ;
45946: LD_ADDR_VAR 0 7
45950: PUSH
45951: LD_VAR 0 7
45955: PUSH
45956: LD_INT 1
45958: NEG
45959: MUL
45960: ST_TO_ADDR
// result := [ _x , _y ] ;
45961: LD_ADDR_VAR 0 5
45965: PUSH
45966: LD_VAR 0 6
45970: PUSH
45971: LD_VAR 0 7
45975: PUSH
45976: EMPTY
45977: LIST
45978: LIST
45979: ST_TO_ADDR
// end ;
45980: LD_VAR 0 5
45984: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
45985: LD_INT 0
45987: PPUSH
45988: PPUSH
45989: PPUSH
45990: PPUSH
// task := GetTaskList ( unit ) ;
45991: LD_ADDR_VAR 0 7
45995: PUSH
45996: LD_VAR 0 1
46000: PPUSH
46001: CALL_OW 437
46005: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
46006: LD_VAR 0 7
46010: NOT
46011: PUSH
46012: LD_VAR 0 1
46016: PPUSH
46017: LD_VAR 0 2
46021: PPUSH
46022: CALL_OW 308
46026: NOT
46027: AND
46028: IFFALSE 46032
// exit ;
46030: GO 46150
// if IsInArea ( unit , area ) then
46032: LD_VAR 0 1
46036: PPUSH
46037: LD_VAR 0 2
46041: PPUSH
46042: CALL_OW 308
46046: IFFALSE 46064
// begin ComMoveToArea ( unit , goAway ) ;
46048: LD_VAR 0 1
46052: PPUSH
46053: LD_VAR 0 3
46057: PPUSH
46058: CALL_OW 113
// exit ;
46062: GO 46150
// end ; if task [ 1 ] [ 1 ] <> M then
46064: LD_VAR 0 7
46068: PUSH
46069: LD_INT 1
46071: ARRAY
46072: PUSH
46073: LD_INT 1
46075: ARRAY
46076: PUSH
46077: LD_STRING M
46079: NONEQUAL
46080: IFFALSE 46084
// exit ;
46082: GO 46150
// x := task [ 1 ] [ 2 ] ;
46084: LD_ADDR_VAR 0 5
46088: PUSH
46089: LD_VAR 0 7
46093: PUSH
46094: LD_INT 1
46096: ARRAY
46097: PUSH
46098: LD_INT 2
46100: ARRAY
46101: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
46102: LD_ADDR_VAR 0 6
46106: PUSH
46107: LD_VAR 0 7
46111: PUSH
46112: LD_INT 1
46114: ARRAY
46115: PUSH
46116: LD_INT 3
46118: ARRAY
46119: ST_TO_ADDR
// if InArea ( x , y , area ) then
46120: LD_VAR 0 5
46124: PPUSH
46125: LD_VAR 0 6
46129: PPUSH
46130: LD_VAR 0 2
46134: PPUSH
46135: CALL_OW 309
46139: IFFALSE 46150
// ComStop ( unit ) ;
46141: LD_VAR 0 1
46145: PPUSH
46146: CALL_OW 141
// end ;
46150: LD_VAR 0 4
46154: RET
// export function Abs ( value ) ; begin
46155: LD_INT 0
46157: PPUSH
// result := value ;
46158: LD_ADDR_VAR 0 2
46162: PUSH
46163: LD_VAR 0 1
46167: ST_TO_ADDR
// if value < 0 then
46168: LD_VAR 0 1
46172: PUSH
46173: LD_INT 0
46175: LESS
46176: IFFALSE 46193
// result := value * - 1 ;
46178: LD_ADDR_VAR 0 2
46182: PUSH
46183: LD_VAR 0 1
46187: PUSH
46188: LD_INT 1
46190: NEG
46191: MUL
46192: ST_TO_ADDR
// end ;
46193: LD_VAR 0 2
46197: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
46198: LD_INT 0
46200: PPUSH
46201: PPUSH
46202: PPUSH
46203: PPUSH
46204: PPUSH
46205: PPUSH
46206: PPUSH
46207: PPUSH
// if not unit or not building then
46208: LD_VAR 0 1
46212: NOT
46213: PUSH
46214: LD_VAR 0 2
46218: NOT
46219: OR
46220: IFFALSE 46224
// exit ;
46222: GO 46450
// x := GetX ( building ) ;
46224: LD_ADDR_VAR 0 4
46228: PUSH
46229: LD_VAR 0 2
46233: PPUSH
46234: CALL_OW 250
46238: ST_TO_ADDR
// y := GetY ( building ) ;
46239: LD_ADDR_VAR 0 6
46243: PUSH
46244: LD_VAR 0 2
46248: PPUSH
46249: CALL_OW 251
46253: ST_TO_ADDR
// d := GetDir ( building ) ;
46254: LD_ADDR_VAR 0 8
46258: PUSH
46259: LD_VAR 0 2
46263: PPUSH
46264: CALL_OW 254
46268: ST_TO_ADDR
// r := 4 ;
46269: LD_ADDR_VAR 0 9
46273: PUSH
46274: LD_INT 4
46276: ST_TO_ADDR
// for i := 1 to 5 do
46277: LD_ADDR_VAR 0 10
46281: PUSH
46282: DOUBLE
46283: LD_INT 1
46285: DEC
46286: ST_TO_ADDR
46287: LD_INT 5
46289: PUSH
46290: FOR_TO
46291: IFFALSE 46448
// begin _x := ShiftX ( x , d , r + i ) ;
46293: LD_ADDR_VAR 0 5
46297: PUSH
46298: LD_VAR 0 4
46302: PPUSH
46303: LD_VAR 0 8
46307: PPUSH
46308: LD_VAR 0 9
46312: PUSH
46313: LD_VAR 0 10
46317: PLUS
46318: PPUSH
46319: CALL_OW 272
46323: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
46324: LD_ADDR_VAR 0 7
46328: PUSH
46329: LD_VAR 0 6
46333: PPUSH
46334: LD_VAR 0 8
46338: PPUSH
46339: LD_VAR 0 9
46343: PUSH
46344: LD_VAR 0 10
46348: PLUS
46349: PPUSH
46350: CALL_OW 273
46354: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
46355: LD_VAR 0 5
46359: PPUSH
46360: LD_VAR 0 7
46364: PPUSH
46365: CALL_OW 488
46369: PUSH
46370: LD_VAR 0 5
46374: PPUSH
46375: LD_VAR 0 7
46379: PPUSH
46380: CALL_OW 428
46384: PPUSH
46385: CALL_OW 247
46389: PUSH
46390: LD_INT 3
46392: PUSH
46393: LD_INT 2
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: IN
46400: NOT
46401: AND
46402: IFFALSE 46446
// begin ComMoveXY ( unit , _x , _y ) ;
46404: LD_VAR 0 1
46408: PPUSH
46409: LD_VAR 0 5
46413: PPUSH
46414: LD_VAR 0 7
46418: PPUSH
46419: CALL_OW 111
// result := [ _x , _y ] ;
46423: LD_ADDR_VAR 0 3
46427: PUSH
46428: LD_VAR 0 5
46432: PUSH
46433: LD_VAR 0 7
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: ST_TO_ADDR
// exit ;
46442: POP
46443: POP
46444: GO 46450
// end ; end ;
46446: GO 46290
46448: POP
46449: POP
// end ;
46450: LD_VAR 0 3
46454: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
46455: LD_INT 0
46457: PPUSH
46458: PPUSH
46459: PPUSH
// result := 0 ;
46460: LD_ADDR_VAR 0 3
46464: PUSH
46465: LD_INT 0
46467: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
46468: LD_VAR 0 1
46472: PUSH
46473: LD_INT 0
46475: LESS
46476: PUSH
46477: LD_VAR 0 1
46481: PUSH
46482: LD_INT 8
46484: GREATER
46485: OR
46486: PUSH
46487: LD_VAR 0 2
46491: PUSH
46492: LD_INT 0
46494: LESS
46495: OR
46496: PUSH
46497: LD_VAR 0 2
46501: PUSH
46502: LD_INT 8
46504: GREATER
46505: OR
46506: IFFALSE 46510
// exit ;
46508: GO 46585
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
46510: LD_ADDR_VAR 0 4
46514: PUSH
46515: LD_INT 22
46517: PUSH
46518: LD_VAR 0 2
46522: PUSH
46523: EMPTY
46524: LIST
46525: LIST
46526: PPUSH
46527: CALL_OW 69
46531: PUSH
46532: FOR_IN
46533: IFFALSE 46583
// begin un := UnitShoot ( i ) ;
46535: LD_ADDR_VAR 0 5
46539: PUSH
46540: LD_VAR 0 4
46544: PPUSH
46545: CALL_OW 504
46549: ST_TO_ADDR
// if GetSide ( un ) = side1 then
46550: LD_VAR 0 5
46554: PPUSH
46555: CALL_OW 255
46559: PUSH
46560: LD_VAR 0 1
46564: EQUAL
46565: IFFALSE 46581
// begin result := un ;
46567: LD_ADDR_VAR 0 3
46571: PUSH
46572: LD_VAR 0 5
46576: ST_TO_ADDR
// exit ;
46577: POP
46578: POP
46579: GO 46585
// end ; end ;
46581: GO 46532
46583: POP
46584: POP
// end ; end_of_file
46585: LD_VAR 0 3
46589: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
46590: LD_INT 0
46592: PPUSH
46593: PPUSH
// skirmish := false ;
46594: LD_ADDR_EXP 40
46598: PUSH
46599: LD_INT 0
46601: ST_TO_ADDR
// debug_mc := false ;
46602: LD_ADDR_EXP 41
46606: PUSH
46607: LD_INT 0
46609: ST_TO_ADDR
// mc_bases := [ ] ;
46610: LD_ADDR_EXP 42
46614: PUSH
46615: EMPTY
46616: ST_TO_ADDR
// mc_sides := [ ] ;
46617: LD_ADDR_EXP 68
46621: PUSH
46622: EMPTY
46623: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
46624: LD_ADDR_EXP 43
46628: PUSH
46629: EMPTY
46630: ST_TO_ADDR
// mc_building_repairs := [ ] ;
46631: LD_ADDR_EXP 44
46635: PUSH
46636: EMPTY
46637: ST_TO_ADDR
// mc_need_heal := [ ] ;
46638: LD_ADDR_EXP 45
46642: PUSH
46643: EMPTY
46644: ST_TO_ADDR
// mc_healers := [ ] ;
46645: LD_ADDR_EXP 46
46649: PUSH
46650: EMPTY
46651: ST_TO_ADDR
// mc_build_list := [ ] ;
46652: LD_ADDR_EXP 47
46656: PUSH
46657: EMPTY
46658: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
46659: LD_ADDR_EXP 74
46663: PUSH
46664: EMPTY
46665: ST_TO_ADDR
// mc_builders := [ ] ;
46666: LD_ADDR_EXP 48
46670: PUSH
46671: EMPTY
46672: ST_TO_ADDR
// mc_construct_list := [ ] ;
46673: LD_ADDR_EXP 49
46677: PUSH
46678: EMPTY
46679: ST_TO_ADDR
// mc_turret_list := [ ] ;
46680: LD_ADDR_EXP 50
46684: PUSH
46685: EMPTY
46686: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
46687: LD_ADDR_EXP 51
46691: PUSH
46692: EMPTY
46693: ST_TO_ADDR
// mc_miners := [ ] ;
46694: LD_ADDR_EXP 56
46698: PUSH
46699: EMPTY
46700: ST_TO_ADDR
// mc_mines := [ ] ;
46701: LD_ADDR_EXP 55
46705: PUSH
46706: EMPTY
46707: ST_TO_ADDR
// mc_minefields := [ ] ;
46708: LD_ADDR_EXP 57
46712: PUSH
46713: EMPTY
46714: ST_TO_ADDR
// mc_crates := [ ] ;
46715: LD_ADDR_EXP 58
46719: PUSH
46720: EMPTY
46721: ST_TO_ADDR
// mc_crates_collector := [ ] ;
46722: LD_ADDR_EXP 59
46726: PUSH
46727: EMPTY
46728: ST_TO_ADDR
// mc_crates_area := [ ] ;
46729: LD_ADDR_EXP 60
46733: PUSH
46734: EMPTY
46735: ST_TO_ADDR
// mc_vehicles := [ ] ;
46736: LD_ADDR_EXP 61
46740: PUSH
46741: EMPTY
46742: ST_TO_ADDR
// mc_attack := [ ] ;
46743: LD_ADDR_EXP 62
46747: PUSH
46748: EMPTY
46749: ST_TO_ADDR
// mc_produce := [ ] ;
46750: LD_ADDR_EXP 63
46754: PUSH
46755: EMPTY
46756: ST_TO_ADDR
// mc_defender := [ ] ;
46757: LD_ADDR_EXP 64
46761: PUSH
46762: EMPTY
46763: ST_TO_ADDR
// mc_parking := [ ] ;
46764: LD_ADDR_EXP 66
46768: PUSH
46769: EMPTY
46770: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
46771: LD_ADDR_EXP 52
46775: PUSH
46776: EMPTY
46777: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
46778: LD_ADDR_EXP 54
46782: PUSH
46783: EMPTY
46784: ST_TO_ADDR
// mc_scan := [ ] ;
46785: LD_ADDR_EXP 65
46789: PUSH
46790: EMPTY
46791: ST_TO_ADDR
// mc_scan_area := [ ] ;
46792: LD_ADDR_EXP 67
46796: PUSH
46797: EMPTY
46798: ST_TO_ADDR
// mc_tech := [ ] ;
46799: LD_ADDR_EXP 69
46803: PUSH
46804: EMPTY
46805: ST_TO_ADDR
// mc_class := [ ] ;
46806: LD_ADDR_EXP 83
46810: PUSH
46811: EMPTY
46812: ST_TO_ADDR
// mc_class_case_use := [ ] ;
46813: LD_ADDR_EXP 84
46817: PUSH
46818: EMPTY
46819: ST_TO_ADDR
// end ;
46820: LD_VAR 0 1
46824: RET
// export function MC_Kill ( base ) ; begin
46825: LD_INT 0
46827: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
46828: LD_ADDR_EXP 42
46832: PUSH
46833: LD_EXP 42
46837: PPUSH
46838: LD_VAR 0 1
46842: PPUSH
46843: EMPTY
46844: PPUSH
46845: CALL_OW 1
46849: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
46850: LD_ADDR_EXP 43
46854: PUSH
46855: LD_EXP 43
46859: PPUSH
46860: LD_VAR 0 1
46864: PPUSH
46865: EMPTY
46866: PPUSH
46867: CALL_OW 1
46871: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
46872: LD_ADDR_EXP 44
46876: PUSH
46877: LD_EXP 44
46881: PPUSH
46882: LD_VAR 0 1
46886: PPUSH
46887: EMPTY
46888: PPUSH
46889: CALL_OW 1
46893: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
46894: LD_ADDR_EXP 45
46898: PUSH
46899: LD_EXP 45
46903: PPUSH
46904: LD_VAR 0 1
46908: PPUSH
46909: EMPTY
46910: PPUSH
46911: CALL_OW 1
46915: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
46916: LD_ADDR_EXP 46
46920: PUSH
46921: LD_EXP 46
46925: PPUSH
46926: LD_VAR 0 1
46930: PPUSH
46931: EMPTY
46932: PPUSH
46933: CALL_OW 1
46937: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
46938: LD_ADDR_EXP 47
46942: PUSH
46943: LD_EXP 47
46947: PPUSH
46948: LD_VAR 0 1
46952: PPUSH
46953: EMPTY
46954: PPUSH
46955: CALL_OW 1
46959: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
46960: LD_ADDR_EXP 48
46964: PUSH
46965: LD_EXP 48
46969: PPUSH
46970: LD_VAR 0 1
46974: PPUSH
46975: EMPTY
46976: PPUSH
46977: CALL_OW 1
46981: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
46982: LD_ADDR_EXP 49
46986: PUSH
46987: LD_EXP 49
46991: PPUSH
46992: LD_VAR 0 1
46996: PPUSH
46997: EMPTY
46998: PPUSH
46999: CALL_OW 1
47003: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
47004: LD_ADDR_EXP 50
47008: PUSH
47009: LD_EXP 50
47013: PPUSH
47014: LD_VAR 0 1
47018: PPUSH
47019: EMPTY
47020: PPUSH
47021: CALL_OW 1
47025: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
47026: LD_ADDR_EXP 51
47030: PUSH
47031: LD_EXP 51
47035: PPUSH
47036: LD_VAR 0 1
47040: PPUSH
47041: EMPTY
47042: PPUSH
47043: CALL_OW 1
47047: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
47048: LD_ADDR_EXP 52
47052: PUSH
47053: LD_EXP 52
47057: PPUSH
47058: LD_VAR 0 1
47062: PPUSH
47063: EMPTY
47064: PPUSH
47065: CALL_OW 1
47069: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
47070: LD_ADDR_EXP 53
47074: PUSH
47075: LD_EXP 53
47079: PPUSH
47080: LD_VAR 0 1
47084: PPUSH
47085: LD_INT 0
47087: PPUSH
47088: CALL_OW 1
47092: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
47093: LD_ADDR_EXP 54
47097: PUSH
47098: LD_EXP 54
47102: PPUSH
47103: LD_VAR 0 1
47107: PPUSH
47108: EMPTY
47109: PPUSH
47110: CALL_OW 1
47114: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
47115: LD_ADDR_EXP 55
47119: PUSH
47120: LD_EXP 55
47124: PPUSH
47125: LD_VAR 0 1
47129: PPUSH
47130: EMPTY
47131: PPUSH
47132: CALL_OW 1
47136: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
47137: LD_ADDR_EXP 56
47141: PUSH
47142: LD_EXP 56
47146: PPUSH
47147: LD_VAR 0 1
47151: PPUSH
47152: EMPTY
47153: PPUSH
47154: CALL_OW 1
47158: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
47159: LD_ADDR_EXP 57
47163: PUSH
47164: LD_EXP 57
47168: PPUSH
47169: LD_VAR 0 1
47173: PPUSH
47174: EMPTY
47175: PPUSH
47176: CALL_OW 1
47180: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
47181: LD_ADDR_EXP 58
47185: PUSH
47186: LD_EXP 58
47190: PPUSH
47191: LD_VAR 0 1
47195: PPUSH
47196: EMPTY
47197: PPUSH
47198: CALL_OW 1
47202: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
47203: LD_ADDR_EXP 59
47207: PUSH
47208: LD_EXP 59
47212: PPUSH
47213: LD_VAR 0 1
47217: PPUSH
47218: EMPTY
47219: PPUSH
47220: CALL_OW 1
47224: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
47225: LD_ADDR_EXP 60
47229: PUSH
47230: LD_EXP 60
47234: PPUSH
47235: LD_VAR 0 1
47239: PPUSH
47240: EMPTY
47241: PPUSH
47242: CALL_OW 1
47246: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
47247: LD_ADDR_EXP 61
47251: PUSH
47252: LD_EXP 61
47256: PPUSH
47257: LD_VAR 0 1
47261: PPUSH
47262: EMPTY
47263: PPUSH
47264: CALL_OW 1
47268: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
47269: LD_ADDR_EXP 62
47273: PUSH
47274: LD_EXP 62
47278: PPUSH
47279: LD_VAR 0 1
47283: PPUSH
47284: EMPTY
47285: PPUSH
47286: CALL_OW 1
47290: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
47291: LD_ADDR_EXP 63
47295: PUSH
47296: LD_EXP 63
47300: PPUSH
47301: LD_VAR 0 1
47305: PPUSH
47306: EMPTY
47307: PPUSH
47308: CALL_OW 1
47312: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
47313: LD_ADDR_EXP 64
47317: PUSH
47318: LD_EXP 64
47322: PPUSH
47323: LD_VAR 0 1
47327: PPUSH
47328: EMPTY
47329: PPUSH
47330: CALL_OW 1
47334: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
47335: LD_ADDR_EXP 65
47339: PUSH
47340: LD_EXP 65
47344: PPUSH
47345: LD_VAR 0 1
47349: PPUSH
47350: EMPTY
47351: PPUSH
47352: CALL_OW 1
47356: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
47357: LD_ADDR_EXP 66
47361: PUSH
47362: LD_EXP 66
47366: PPUSH
47367: LD_VAR 0 1
47371: PPUSH
47372: EMPTY
47373: PPUSH
47374: CALL_OW 1
47378: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
47379: LD_ADDR_EXP 67
47383: PUSH
47384: LD_EXP 67
47388: PPUSH
47389: LD_VAR 0 1
47393: PPUSH
47394: EMPTY
47395: PPUSH
47396: CALL_OW 1
47400: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
47401: LD_ADDR_EXP 69
47405: PUSH
47406: LD_EXP 69
47410: PPUSH
47411: LD_VAR 0 1
47415: PPUSH
47416: EMPTY
47417: PPUSH
47418: CALL_OW 1
47422: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
47423: LD_ADDR_EXP 71
47427: PUSH
47428: LD_EXP 71
47432: PPUSH
47433: LD_VAR 0 1
47437: PPUSH
47438: EMPTY
47439: PPUSH
47440: CALL_OW 1
47444: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
47445: LD_ADDR_EXP 72
47449: PUSH
47450: LD_EXP 72
47454: PPUSH
47455: LD_VAR 0 1
47459: PPUSH
47460: EMPTY
47461: PPUSH
47462: CALL_OW 1
47466: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
47467: LD_ADDR_EXP 73
47471: PUSH
47472: LD_EXP 73
47476: PPUSH
47477: LD_VAR 0 1
47481: PPUSH
47482: EMPTY
47483: PPUSH
47484: CALL_OW 1
47488: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
47489: LD_ADDR_EXP 74
47493: PUSH
47494: LD_EXP 74
47498: PPUSH
47499: LD_VAR 0 1
47503: PPUSH
47504: EMPTY
47505: PPUSH
47506: CALL_OW 1
47510: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
47511: LD_ADDR_EXP 75
47515: PUSH
47516: LD_EXP 75
47520: PPUSH
47521: LD_VAR 0 1
47525: PPUSH
47526: EMPTY
47527: PPUSH
47528: CALL_OW 1
47532: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
47533: LD_ADDR_EXP 76
47537: PUSH
47538: LD_EXP 76
47542: PPUSH
47543: LD_VAR 0 1
47547: PPUSH
47548: EMPTY
47549: PPUSH
47550: CALL_OW 1
47554: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
47555: LD_ADDR_EXP 77
47559: PUSH
47560: LD_EXP 77
47564: PPUSH
47565: LD_VAR 0 1
47569: PPUSH
47570: EMPTY
47571: PPUSH
47572: CALL_OW 1
47576: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
47577: LD_ADDR_EXP 78
47581: PUSH
47582: LD_EXP 78
47586: PPUSH
47587: LD_VAR 0 1
47591: PPUSH
47592: EMPTY
47593: PPUSH
47594: CALL_OW 1
47598: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
47599: LD_ADDR_EXP 79
47603: PUSH
47604: LD_EXP 79
47608: PPUSH
47609: LD_VAR 0 1
47613: PPUSH
47614: EMPTY
47615: PPUSH
47616: CALL_OW 1
47620: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
47621: LD_ADDR_EXP 80
47625: PUSH
47626: LD_EXP 80
47630: PPUSH
47631: LD_VAR 0 1
47635: PPUSH
47636: EMPTY
47637: PPUSH
47638: CALL_OW 1
47642: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
47643: LD_ADDR_EXP 81
47647: PUSH
47648: LD_EXP 81
47652: PPUSH
47653: LD_VAR 0 1
47657: PPUSH
47658: EMPTY
47659: PPUSH
47660: CALL_OW 1
47664: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
47665: LD_ADDR_EXP 82
47669: PUSH
47670: LD_EXP 82
47674: PPUSH
47675: LD_VAR 0 1
47679: PPUSH
47680: EMPTY
47681: PPUSH
47682: CALL_OW 1
47686: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
47687: LD_ADDR_EXP 83
47691: PUSH
47692: LD_EXP 83
47696: PPUSH
47697: LD_VAR 0 1
47701: PPUSH
47702: EMPTY
47703: PPUSH
47704: CALL_OW 1
47708: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
47709: LD_ADDR_EXP 84
47713: PUSH
47714: LD_EXP 84
47718: PPUSH
47719: LD_VAR 0 1
47723: PPUSH
47724: LD_INT 0
47726: PPUSH
47727: CALL_OW 1
47731: ST_TO_ADDR
// end ;
47732: LD_VAR 0 2
47736: RET
// export function MC_Add ( side , units ) ; var base ; begin
47737: LD_INT 0
47739: PPUSH
47740: PPUSH
// base := mc_bases + 1 ;
47741: LD_ADDR_VAR 0 4
47745: PUSH
47746: LD_EXP 42
47750: PUSH
47751: LD_INT 1
47753: PLUS
47754: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
47755: LD_ADDR_EXP 68
47759: PUSH
47760: LD_EXP 68
47764: PPUSH
47765: LD_VAR 0 4
47769: PPUSH
47770: LD_VAR 0 1
47774: PPUSH
47775: CALL_OW 1
47779: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
47780: LD_ADDR_EXP 42
47784: PUSH
47785: LD_EXP 42
47789: PPUSH
47790: LD_VAR 0 4
47794: PPUSH
47795: LD_VAR 0 2
47799: PPUSH
47800: CALL_OW 1
47804: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
47805: LD_ADDR_EXP 43
47809: PUSH
47810: LD_EXP 43
47814: PPUSH
47815: LD_VAR 0 4
47819: PPUSH
47820: EMPTY
47821: PPUSH
47822: CALL_OW 1
47826: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
47827: LD_ADDR_EXP 44
47831: PUSH
47832: LD_EXP 44
47836: PPUSH
47837: LD_VAR 0 4
47841: PPUSH
47842: EMPTY
47843: PPUSH
47844: CALL_OW 1
47848: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
47849: LD_ADDR_EXP 45
47853: PUSH
47854: LD_EXP 45
47858: PPUSH
47859: LD_VAR 0 4
47863: PPUSH
47864: EMPTY
47865: PPUSH
47866: CALL_OW 1
47870: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
47871: LD_ADDR_EXP 46
47875: PUSH
47876: LD_EXP 46
47880: PPUSH
47881: LD_VAR 0 4
47885: PPUSH
47886: EMPTY
47887: PPUSH
47888: CALL_OW 1
47892: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
47893: LD_ADDR_EXP 47
47897: PUSH
47898: LD_EXP 47
47902: PPUSH
47903: LD_VAR 0 4
47907: PPUSH
47908: EMPTY
47909: PPUSH
47910: CALL_OW 1
47914: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
47915: LD_ADDR_EXP 48
47919: PUSH
47920: LD_EXP 48
47924: PPUSH
47925: LD_VAR 0 4
47929: PPUSH
47930: EMPTY
47931: PPUSH
47932: CALL_OW 1
47936: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
47937: LD_ADDR_EXP 49
47941: PUSH
47942: LD_EXP 49
47946: PPUSH
47947: LD_VAR 0 4
47951: PPUSH
47952: EMPTY
47953: PPUSH
47954: CALL_OW 1
47958: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
47959: LD_ADDR_EXP 50
47963: PUSH
47964: LD_EXP 50
47968: PPUSH
47969: LD_VAR 0 4
47973: PPUSH
47974: EMPTY
47975: PPUSH
47976: CALL_OW 1
47980: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
47981: LD_ADDR_EXP 51
47985: PUSH
47986: LD_EXP 51
47990: PPUSH
47991: LD_VAR 0 4
47995: PPUSH
47996: EMPTY
47997: PPUSH
47998: CALL_OW 1
48002: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48003: LD_ADDR_EXP 52
48007: PUSH
48008: LD_EXP 52
48012: PPUSH
48013: LD_VAR 0 4
48017: PPUSH
48018: EMPTY
48019: PPUSH
48020: CALL_OW 1
48024: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
48025: LD_ADDR_EXP 53
48029: PUSH
48030: LD_EXP 53
48034: PPUSH
48035: LD_VAR 0 4
48039: PPUSH
48040: LD_INT 0
48042: PPUSH
48043: CALL_OW 1
48047: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48048: LD_ADDR_EXP 54
48052: PUSH
48053: LD_EXP 54
48057: PPUSH
48058: LD_VAR 0 4
48062: PPUSH
48063: EMPTY
48064: PPUSH
48065: CALL_OW 1
48069: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48070: LD_ADDR_EXP 55
48074: PUSH
48075: LD_EXP 55
48079: PPUSH
48080: LD_VAR 0 4
48084: PPUSH
48085: EMPTY
48086: PPUSH
48087: CALL_OW 1
48091: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
48092: LD_ADDR_EXP 56
48096: PUSH
48097: LD_EXP 56
48101: PPUSH
48102: LD_VAR 0 4
48106: PPUSH
48107: EMPTY
48108: PPUSH
48109: CALL_OW 1
48113: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
48114: LD_ADDR_EXP 57
48118: PUSH
48119: LD_EXP 57
48123: PPUSH
48124: LD_VAR 0 4
48128: PPUSH
48129: EMPTY
48130: PPUSH
48131: CALL_OW 1
48135: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
48136: LD_ADDR_EXP 58
48140: PUSH
48141: LD_EXP 58
48145: PPUSH
48146: LD_VAR 0 4
48150: PPUSH
48151: EMPTY
48152: PPUSH
48153: CALL_OW 1
48157: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
48158: LD_ADDR_EXP 59
48162: PUSH
48163: LD_EXP 59
48167: PPUSH
48168: LD_VAR 0 4
48172: PPUSH
48173: EMPTY
48174: PPUSH
48175: CALL_OW 1
48179: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
48180: LD_ADDR_EXP 60
48184: PUSH
48185: LD_EXP 60
48189: PPUSH
48190: LD_VAR 0 4
48194: PPUSH
48195: EMPTY
48196: PPUSH
48197: CALL_OW 1
48201: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
48202: LD_ADDR_EXP 61
48206: PUSH
48207: LD_EXP 61
48211: PPUSH
48212: LD_VAR 0 4
48216: PPUSH
48217: EMPTY
48218: PPUSH
48219: CALL_OW 1
48223: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
48224: LD_ADDR_EXP 62
48228: PUSH
48229: LD_EXP 62
48233: PPUSH
48234: LD_VAR 0 4
48238: PPUSH
48239: EMPTY
48240: PPUSH
48241: CALL_OW 1
48245: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
48246: LD_ADDR_EXP 63
48250: PUSH
48251: LD_EXP 63
48255: PPUSH
48256: LD_VAR 0 4
48260: PPUSH
48261: EMPTY
48262: PPUSH
48263: CALL_OW 1
48267: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
48268: LD_ADDR_EXP 64
48272: PUSH
48273: LD_EXP 64
48277: PPUSH
48278: LD_VAR 0 4
48282: PPUSH
48283: EMPTY
48284: PPUSH
48285: CALL_OW 1
48289: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
48290: LD_ADDR_EXP 65
48294: PUSH
48295: LD_EXP 65
48299: PPUSH
48300: LD_VAR 0 4
48304: PPUSH
48305: EMPTY
48306: PPUSH
48307: CALL_OW 1
48311: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
48312: LD_ADDR_EXP 66
48316: PUSH
48317: LD_EXP 66
48321: PPUSH
48322: LD_VAR 0 4
48326: PPUSH
48327: EMPTY
48328: PPUSH
48329: CALL_OW 1
48333: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
48334: LD_ADDR_EXP 67
48338: PUSH
48339: LD_EXP 67
48343: PPUSH
48344: LD_VAR 0 4
48348: PPUSH
48349: EMPTY
48350: PPUSH
48351: CALL_OW 1
48355: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
48356: LD_ADDR_EXP 69
48360: PUSH
48361: LD_EXP 69
48365: PPUSH
48366: LD_VAR 0 4
48370: PPUSH
48371: EMPTY
48372: PPUSH
48373: CALL_OW 1
48377: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
48378: LD_ADDR_EXP 71
48382: PUSH
48383: LD_EXP 71
48387: PPUSH
48388: LD_VAR 0 4
48392: PPUSH
48393: EMPTY
48394: PPUSH
48395: CALL_OW 1
48399: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
48400: LD_ADDR_EXP 72
48404: PUSH
48405: LD_EXP 72
48409: PPUSH
48410: LD_VAR 0 4
48414: PPUSH
48415: EMPTY
48416: PPUSH
48417: CALL_OW 1
48421: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48422: LD_ADDR_EXP 73
48426: PUSH
48427: LD_EXP 73
48431: PPUSH
48432: LD_VAR 0 4
48436: PPUSH
48437: EMPTY
48438: PPUSH
48439: CALL_OW 1
48443: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48444: LD_ADDR_EXP 74
48448: PUSH
48449: LD_EXP 74
48453: PPUSH
48454: LD_VAR 0 4
48458: PPUSH
48459: EMPTY
48460: PPUSH
48461: CALL_OW 1
48465: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
48466: LD_ADDR_EXP 75
48470: PUSH
48471: LD_EXP 75
48475: PPUSH
48476: LD_VAR 0 4
48480: PPUSH
48481: EMPTY
48482: PPUSH
48483: CALL_OW 1
48487: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48488: LD_ADDR_EXP 76
48492: PUSH
48493: LD_EXP 76
48497: PPUSH
48498: LD_VAR 0 4
48502: PPUSH
48503: EMPTY
48504: PPUSH
48505: CALL_OW 1
48509: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48510: LD_ADDR_EXP 77
48514: PUSH
48515: LD_EXP 77
48519: PPUSH
48520: LD_VAR 0 4
48524: PPUSH
48525: EMPTY
48526: PPUSH
48527: CALL_OW 1
48531: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48532: LD_ADDR_EXP 78
48536: PUSH
48537: LD_EXP 78
48541: PPUSH
48542: LD_VAR 0 4
48546: PPUSH
48547: EMPTY
48548: PPUSH
48549: CALL_OW 1
48553: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48554: LD_ADDR_EXP 79
48558: PUSH
48559: LD_EXP 79
48563: PPUSH
48564: LD_VAR 0 4
48568: PPUSH
48569: EMPTY
48570: PPUSH
48571: CALL_OW 1
48575: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48576: LD_ADDR_EXP 80
48580: PUSH
48581: LD_EXP 80
48585: PPUSH
48586: LD_VAR 0 4
48590: PPUSH
48591: EMPTY
48592: PPUSH
48593: CALL_OW 1
48597: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
48598: LD_ADDR_EXP 81
48602: PUSH
48603: LD_EXP 81
48607: PPUSH
48608: LD_VAR 0 4
48612: PPUSH
48613: EMPTY
48614: PPUSH
48615: CALL_OW 1
48619: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
48620: LD_ADDR_EXP 82
48624: PUSH
48625: LD_EXP 82
48629: PPUSH
48630: LD_VAR 0 4
48634: PPUSH
48635: EMPTY
48636: PPUSH
48637: CALL_OW 1
48641: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
48642: LD_ADDR_EXP 83
48646: PUSH
48647: LD_EXP 83
48651: PPUSH
48652: LD_VAR 0 4
48656: PPUSH
48657: EMPTY
48658: PPUSH
48659: CALL_OW 1
48663: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
48664: LD_ADDR_EXP 84
48668: PUSH
48669: LD_EXP 84
48673: PPUSH
48674: LD_VAR 0 4
48678: PPUSH
48679: LD_INT 0
48681: PPUSH
48682: CALL_OW 1
48686: ST_TO_ADDR
// result := base ;
48687: LD_ADDR_VAR 0 3
48691: PUSH
48692: LD_VAR 0 4
48696: ST_TO_ADDR
// end ;
48697: LD_VAR 0 3
48701: RET
// export function MC_Start ( ) ; var i ; begin
48702: LD_INT 0
48704: PPUSH
48705: PPUSH
// for i = 1 to mc_bases do
48706: LD_ADDR_VAR 0 2
48710: PUSH
48711: DOUBLE
48712: LD_INT 1
48714: DEC
48715: ST_TO_ADDR
48716: LD_EXP 42
48720: PUSH
48721: FOR_TO
48722: IFFALSE 49799
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
48724: LD_ADDR_EXP 42
48728: PUSH
48729: LD_EXP 42
48733: PPUSH
48734: LD_VAR 0 2
48738: PPUSH
48739: LD_EXP 42
48743: PUSH
48744: LD_VAR 0 2
48748: ARRAY
48749: PUSH
48750: LD_INT 0
48752: DIFF
48753: PPUSH
48754: CALL_OW 1
48758: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
48759: LD_ADDR_EXP 43
48763: PUSH
48764: LD_EXP 43
48768: PPUSH
48769: LD_VAR 0 2
48773: PPUSH
48774: EMPTY
48775: PPUSH
48776: CALL_OW 1
48780: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
48781: LD_ADDR_EXP 44
48785: PUSH
48786: LD_EXP 44
48790: PPUSH
48791: LD_VAR 0 2
48795: PPUSH
48796: EMPTY
48797: PPUSH
48798: CALL_OW 1
48802: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
48803: LD_ADDR_EXP 45
48807: PUSH
48808: LD_EXP 45
48812: PPUSH
48813: LD_VAR 0 2
48817: PPUSH
48818: EMPTY
48819: PPUSH
48820: CALL_OW 1
48824: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
48825: LD_ADDR_EXP 46
48829: PUSH
48830: LD_EXP 46
48834: PPUSH
48835: LD_VAR 0 2
48839: PPUSH
48840: EMPTY
48841: PUSH
48842: EMPTY
48843: PUSH
48844: EMPTY
48845: LIST
48846: LIST
48847: PPUSH
48848: CALL_OW 1
48852: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
48853: LD_ADDR_EXP 47
48857: PUSH
48858: LD_EXP 47
48862: PPUSH
48863: LD_VAR 0 2
48867: PPUSH
48868: EMPTY
48869: PPUSH
48870: CALL_OW 1
48874: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
48875: LD_ADDR_EXP 74
48879: PUSH
48880: LD_EXP 74
48884: PPUSH
48885: LD_VAR 0 2
48889: PPUSH
48890: EMPTY
48891: PPUSH
48892: CALL_OW 1
48896: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
48897: LD_ADDR_EXP 48
48901: PUSH
48902: LD_EXP 48
48906: PPUSH
48907: LD_VAR 0 2
48911: PPUSH
48912: EMPTY
48913: PPUSH
48914: CALL_OW 1
48918: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
48919: LD_ADDR_EXP 49
48923: PUSH
48924: LD_EXP 49
48928: PPUSH
48929: LD_VAR 0 2
48933: PPUSH
48934: EMPTY
48935: PPUSH
48936: CALL_OW 1
48940: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
48941: LD_ADDR_EXP 50
48945: PUSH
48946: LD_EXP 50
48950: PPUSH
48951: LD_VAR 0 2
48955: PPUSH
48956: LD_EXP 42
48960: PUSH
48961: LD_VAR 0 2
48965: ARRAY
48966: PPUSH
48967: LD_INT 2
48969: PUSH
48970: LD_INT 30
48972: PUSH
48973: LD_INT 32
48975: PUSH
48976: EMPTY
48977: LIST
48978: LIST
48979: PUSH
48980: LD_INT 30
48982: PUSH
48983: LD_INT 33
48985: PUSH
48986: EMPTY
48987: LIST
48988: LIST
48989: PUSH
48990: EMPTY
48991: LIST
48992: LIST
48993: LIST
48994: PPUSH
48995: CALL_OW 72
48999: PPUSH
49000: CALL_OW 1
49004: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
49005: LD_ADDR_EXP 51
49009: PUSH
49010: LD_EXP 51
49014: PPUSH
49015: LD_VAR 0 2
49019: PPUSH
49020: LD_EXP 42
49024: PUSH
49025: LD_VAR 0 2
49029: ARRAY
49030: PPUSH
49031: LD_INT 2
49033: PUSH
49034: LD_INT 30
49036: PUSH
49037: LD_INT 32
49039: PUSH
49040: EMPTY
49041: LIST
49042: LIST
49043: PUSH
49044: LD_INT 30
49046: PUSH
49047: LD_INT 31
49049: PUSH
49050: EMPTY
49051: LIST
49052: LIST
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: LIST
49058: PUSH
49059: LD_INT 58
49061: PUSH
49062: EMPTY
49063: LIST
49064: PUSH
49065: EMPTY
49066: LIST
49067: LIST
49068: PPUSH
49069: CALL_OW 72
49073: PPUSH
49074: CALL_OW 1
49078: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
49079: LD_ADDR_EXP 52
49083: PUSH
49084: LD_EXP 52
49088: PPUSH
49089: LD_VAR 0 2
49093: PPUSH
49094: EMPTY
49095: PPUSH
49096: CALL_OW 1
49100: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
49101: LD_ADDR_EXP 56
49105: PUSH
49106: LD_EXP 56
49110: PPUSH
49111: LD_VAR 0 2
49115: PPUSH
49116: EMPTY
49117: PPUSH
49118: CALL_OW 1
49122: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
49123: LD_ADDR_EXP 55
49127: PUSH
49128: LD_EXP 55
49132: PPUSH
49133: LD_VAR 0 2
49137: PPUSH
49138: EMPTY
49139: PPUSH
49140: CALL_OW 1
49144: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
49145: LD_ADDR_EXP 57
49149: PUSH
49150: LD_EXP 57
49154: PPUSH
49155: LD_VAR 0 2
49159: PPUSH
49160: EMPTY
49161: PPUSH
49162: CALL_OW 1
49166: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
49167: LD_ADDR_EXP 58
49171: PUSH
49172: LD_EXP 58
49176: PPUSH
49177: LD_VAR 0 2
49181: PPUSH
49182: EMPTY
49183: PPUSH
49184: CALL_OW 1
49188: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
49189: LD_ADDR_EXP 59
49193: PUSH
49194: LD_EXP 59
49198: PPUSH
49199: LD_VAR 0 2
49203: PPUSH
49204: EMPTY
49205: PPUSH
49206: CALL_OW 1
49210: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
49211: LD_ADDR_EXP 60
49215: PUSH
49216: LD_EXP 60
49220: PPUSH
49221: LD_VAR 0 2
49225: PPUSH
49226: EMPTY
49227: PPUSH
49228: CALL_OW 1
49232: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
49233: LD_ADDR_EXP 61
49237: PUSH
49238: LD_EXP 61
49242: PPUSH
49243: LD_VAR 0 2
49247: PPUSH
49248: EMPTY
49249: PPUSH
49250: CALL_OW 1
49254: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49255: LD_ADDR_EXP 62
49259: PUSH
49260: LD_EXP 62
49264: PPUSH
49265: LD_VAR 0 2
49269: PPUSH
49270: EMPTY
49271: PPUSH
49272: CALL_OW 1
49276: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
49277: LD_ADDR_EXP 63
49281: PUSH
49282: LD_EXP 63
49286: PPUSH
49287: LD_VAR 0 2
49291: PPUSH
49292: EMPTY
49293: PPUSH
49294: CALL_OW 1
49298: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
49299: LD_ADDR_EXP 64
49303: PUSH
49304: LD_EXP 64
49308: PPUSH
49309: LD_VAR 0 2
49313: PPUSH
49314: EMPTY
49315: PPUSH
49316: CALL_OW 1
49320: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
49321: LD_ADDR_EXP 53
49325: PUSH
49326: LD_EXP 53
49330: PPUSH
49331: LD_VAR 0 2
49335: PPUSH
49336: LD_INT 0
49338: PPUSH
49339: CALL_OW 1
49343: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
49344: LD_ADDR_EXP 66
49348: PUSH
49349: LD_EXP 66
49353: PPUSH
49354: LD_VAR 0 2
49358: PPUSH
49359: LD_INT 0
49361: PPUSH
49362: CALL_OW 1
49366: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49367: LD_ADDR_EXP 54
49371: PUSH
49372: LD_EXP 54
49376: PPUSH
49377: LD_VAR 0 2
49381: PPUSH
49382: EMPTY
49383: PPUSH
49384: CALL_OW 1
49388: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
49389: LD_ADDR_EXP 65
49393: PUSH
49394: LD_EXP 65
49398: PPUSH
49399: LD_VAR 0 2
49403: PPUSH
49404: LD_INT 0
49406: PPUSH
49407: CALL_OW 1
49411: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
49412: LD_ADDR_EXP 67
49416: PUSH
49417: LD_EXP 67
49421: PPUSH
49422: LD_VAR 0 2
49426: PPUSH
49427: EMPTY
49428: PPUSH
49429: CALL_OW 1
49433: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
49434: LD_ADDR_EXP 70
49438: PUSH
49439: LD_EXP 70
49443: PPUSH
49444: LD_VAR 0 2
49448: PPUSH
49449: LD_INT 0
49451: PPUSH
49452: CALL_OW 1
49456: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
49457: LD_ADDR_EXP 71
49461: PUSH
49462: LD_EXP 71
49466: PPUSH
49467: LD_VAR 0 2
49471: PPUSH
49472: EMPTY
49473: PPUSH
49474: CALL_OW 1
49478: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49479: LD_ADDR_EXP 72
49483: PUSH
49484: LD_EXP 72
49488: PPUSH
49489: LD_VAR 0 2
49493: PPUSH
49494: EMPTY
49495: PPUSH
49496: CALL_OW 1
49500: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
49501: LD_ADDR_EXP 73
49505: PUSH
49506: LD_EXP 73
49510: PPUSH
49511: LD_VAR 0 2
49515: PPUSH
49516: EMPTY
49517: PPUSH
49518: CALL_OW 1
49522: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
49523: LD_ADDR_EXP 75
49527: PUSH
49528: LD_EXP 75
49532: PPUSH
49533: LD_VAR 0 2
49537: PPUSH
49538: LD_EXP 42
49542: PUSH
49543: LD_VAR 0 2
49547: ARRAY
49548: PPUSH
49549: LD_INT 2
49551: PUSH
49552: LD_INT 30
49554: PUSH
49555: LD_INT 6
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: PUSH
49562: LD_INT 30
49564: PUSH
49565: LD_INT 7
49567: PUSH
49568: EMPTY
49569: LIST
49570: LIST
49571: PUSH
49572: LD_INT 30
49574: PUSH
49575: LD_INT 8
49577: PUSH
49578: EMPTY
49579: LIST
49580: LIST
49581: PUSH
49582: EMPTY
49583: LIST
49584: LIST
49585: LIST
49586: LIST
49587: PPUSH
49588: CALL_OW 72
49592: PPUSH
49593: CALL_OW 1
49597: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
49598: LD_ADDR_EXP 76
49602: PUSH
49603: LD_EXP 76
49607: PPUSH
49608: LD_VAR 0 2
49612: PPUSH
49613: EMPTY
49614: PPUSH
49615: CALL_OW 1
49619: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
49620: LD_ADDR_EXP 77
49624: PUSH
49625: LD_EXP 77
49629: PPUSH
49630: LD_VAR 0 2
49634: PPUSH
49635: EMPTY
49636: PPUSH
49637: CALL_OW 1
49641: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
49642: LD_ADDR_EXP 78
49646: PUSH
49647: LD_EXP 78
49651: PPUSH
49652: LD_VAR 0 2
49656: PPUSH
49657: EMPTY
49658: PPUSH
49659: CALL_OW 1
49663: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
49664: LD_ADDR_EXP 79
49668: PUSH
49669: LD_EXP 79
49673: PPUSH
49674: LD_VAR 0 2
49678: PPUSH
49679: EMPTY
49680: PPUSH
49681: CALL_OW 1
49685: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
49686: LD_ADDR_EXP 80
49690: PUSH
49691: LD_EXP 80
49695: PPUSH
49696: LD_VAR 0 2
49700: PPUSH
49701: EMPTY
49702: PPUSH
49703: CALL_OW 1
49707: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
49708: LD_ADDR_EXP 81
49712: PUSH
49713: LD_EXP 81
49717: PPUSH
49718: LD_VAR 0 2
49722: PPUSH
49723: EMPTY
49724: PPUSH
49725: CALL_OW 1
49729: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
49730: LD_ADDR_EXP 82
49734: PUSH
49735: LD_EXP 82
49739: PPUSH
49740: LD_VAR 0 2
49744: PPUSH
49745: EMPTY
49746: PPUSH
49747: CALL_OW 1
49751: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
49752: LD_ADDR_EXP 83
49756: PUSH
49757: LD_EXP 83
49761: PPUSH
49762: LD_VAR 0 2
49766: PPUSH
49767: EMPTY
49768: PPUSH
49769: CALL_OW 1
49773: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
49774: LD_ADDR_EXP 84
49778: PUSH
49779: LD_EXP 84
49783: PPUSH
49784: LD_VAR 0 2
49788: PPUSH
49789: LD_INT 0
49791: PPUSH
49792: CALL_OW 1
49796: ST_TO_ADDR
// end ;
49797: GO 48721
49799: POP
49800: POP
// MC_InitSides ( ) ;
49801: CALL 50087 0 0
// MC_InitResearch ( ) ;
49805: CALL 49826 0 0
// CustomInitMacro ( ) ;
49809: CALL 89 0 0
// skirmish := true ;
49813: LD_ADDR_EXP 40
49817: PUSH
49818: LD_INT 1
49820: ST_TO_ADDR
// end ;
49821: LD_VAR 0 1
49825: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
49826: LD_INT 0
49828: PPUSH
49829: PPUSH
49830: PPUSH
49831: PPUSH
49832: PPUSH
49833: PPUSH
// if not mc_bases then
49834: LD_EXP 42
49838: NOT
49839: IFFALSE 49843
// exit ;
49841: GO 50082
// for i = 1 to 8 do
49843: LD_ADDR_VAR 0 2
49847: PUSH
49848: DOUBLE
49849: LD_INT 1
49851: DEC
49852: ST_TO_ADDR
49853: LD_INT 8
49855: PUSH
49856: FOR_TO
49857: IFFALSE 49883
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
49859: LD_ADDR_EXP 69
49863: PUSH
49864: LD_EXP 69
49868: PPUSH
49869: LD_VAR 0 2
49873: PPUSH
49874: EMPTY
49875: PPUSH
49876: CALL_OW 1
49880: ST_TO_ADDR
49881: GO 49856
49883: POP
49884: POP
// tmp := [ ] ;
49885: LD_ADDR_VAR 0 5
49889: PUSH
49890: EMPTY
49891: ST_TO_ADDR
// for i = 1 to mc_sides do
49892: LD_ADDR_VAR 0 2
49896: PUSH
49897: DOUBLE
49898: LD_INT 1
49900: DEC
49901: ST_TO_ADDR
49902: LD_EXP 68
49906: PUSH
49907: FOR_TO
49908: IFFALSE 49966
// if not mc_sides [ i ] in tmp then
49910: LD_EXP 68
49914: PUSH
49915: LD_VAR 0 2
49919: ARRAY
49920: PUSH
49921: LD_VAR 0 5
49925: IN
49926: NOT
49927: IFFALSE 49964
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
49929: LD_ADDR_VAR 0 5
49933: PUSH
49934: LD_VAR 0 5
49938: PPUSH
49939: LD_VAR 0 5
49943: PUSH
49944: LD_INT 1
49946: PLUS
49947: PPUSH
49948: LD_EXP 68
49952: PUSH
49953: LD_VAR 0 2
49957: ARRAY
49958: PPUSH
49959: CALL_OW 2
49963: ST_TO_ADDR
49964: GO 49907
49966: POP
49967: POP
// if not tmp then
49968: LD_VAR 0 5
49972: NOT
49973: IFFALSE 49977
// exit ;
49975: GO 50082
// for j in tmp do
49977: LD_ADDR_VAR 0 3
49981: PUSH
49982: LD_VAR 0 5
49986: PUSH
49987: FOR_IN
49988: IFFALSE 50080
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
49990: LD_ADDR_VAR 0 6
49994: PUSH
49995: LD_INT 22
49997: PUSH
49998: LD_VAR 0 3
50002: PUSH
50003: EMPTY
50004: LIST
50005: LIST
50006: PPUSH
50007: CALL_OW 69
50011: ST_TO_ADDR
// if not un then
50012: LD_VAR 0 6
50016: NOT
50017: IFFALSE 50021
// continue ;
50019: GO 49987
// nation := GetNation ( un [ 1 ] ) ;
50021: LD_ADDR_VAR 0 4
50025: PUSH
50026: LD_VAR 0 6
50030: PUSH
50031: LD_INT 1
50033: ARRAY
50034: PPUSH
50035: CALL_OW 248
50039: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
50040: LD_ADDR_EXP 69
50044: PUSH
50045: LD_EXP 69
50049: PPUSH
50050: LD_VAR 0 3
50054: PPUSH
50055: LD_VAR 0 3
50059: PPUSH
50060: LD_VAR 0 4
50064: PPUSH
50065: LD_INT 1
50067: PPUSH
50068: CALL 9449 0 3
50072: PPUSH
50073: CALL_OW 1
50077: ST_TO_ADDR
// end ;
50078: GO 49987
50080: POP
50081: POP
// end ;
50082: LD_VAR 0 1
50086: RET
// export function MC_InitSides ( ) ; var i ; begin
50087: LD_INT 0
50089: PPUSH
50090: PPUSH
// if not mc_bases then
50091: LD_EXP 42
50095: NOT
50096: IFFALSE 50100
// exit ;
50098: GO 50174
// for i = 1 to mc_bases do
50100: LD_ADDR_VAR 0 2
50104: PUSH
50105: DOUBLE
50106: LD_INT 1
50108: DEC
50109: ST_TO_ADDR
50110: LD_EXP 42
50114: PUSH
50115: FOR_TO
50116: IFFALSE 50172
// if mc_bases [ i ] then
50118: LD_EXP 42
50122: PUSH
50123: LD_VAR 0 2
50127: ARRAY
50128: IFFALSE 50170
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
50130: LD_ADDR_EXP 68
50134: PUSH
50135: LD_EXP 68
50139: PPUSH
50140: LD_VAR 0 2
50144: PPUSH
50145: LD_EXP 42
50149: PUSH
50150: LD_VAR 0 2
50154: ARRAY
50155: PUSH
50156: LD_INT 1
50158: ARRAY
50159: PPUSH
50160: CALL_OW 255
50164: PPUSH
50165: CALL_OW 1
50169: ST_TO_ADDR
50170: GO 50115
50172: POP
50173: POP
// end ;
50174: LD_VAR 0 1
50178: RET
// every 0 0$01 trigger skirmish do
50179: LD_EXP 40
50183: IFFALSE 50337
50185: GO 50187
50187: DISABLE
// begin enable ;
50188: ENABLE
// MC_CheckBuildings ( ) ;
50189: CALL 54835 0 0
// MC_CheckPeopleLife ( ) ;
50193: CALL 54960 0 0
// RaiseSailEvent ( 100 ) ;
50197: LD_INT 100
50199: PPUSH
50200: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
50204: LD_INT 103
50206: PPUSH
50207: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
50211: LD_INT 104
50213: PPUSH
50214: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
50218: LD_INT 105
50220: PPUSH
50221: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
50225: LD_INT 106
50227: PPUSH
50228: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
50232: LD_INT 107
50234: PPUSH
50235: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
50239: LD_INT 108
50241: PPUSH
50242: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
50246: LD_INT 109
50248: PPUSH
50249: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
50253: LD_INT 110
50255: PPUSH
50256: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
50260: LD_INT 111
50262: PPUSH
50263: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
50267: LD_INT 112
50269: PPUSH
50270: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
50274: LD_INT 113
50276: PPUSH
50277: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
50281: LD_INT 120
50283: PPUSH
50284: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
50288: LD_INT 121
50290: PPUSH
50291: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
50295: LD_INT 122
50297: PPUSH
50298: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
50302: LD_INT 123
50304: PPUSH
50305: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
50309: LD_INT 124
50311: PPUSH
50312: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
50316: LD_INT 125
50318: PPUSH
50319: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
50323: LD_INT 126
50325: PPUSH
50326: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
50330: LD_INT 200
50332: PPUSH
50333: CALL_OW 427
// end ;
50337: END
// on SailEvent ( event ) do begin if event < 100 then
50338: LD_VAR 0 1
50342: PUSH
50343: LD_INT 100
50345: LESS
50346: IFFALSE 50357
// CustomEvent ( event ) ;
50348: LD_VAR 0 1
50352: PPUSH
50353: CALL 559 0 1
// if event = 100 then
50357: LD_VAR 0 1
50361: PUSH
50362: LD_INT 100
50364: EQUAL
50365: IFFALSE 50371
// MC_ClassManager ( ) ;
50367: CALL 50763 0 0
// if event = 101 then
50371: LD_VAR 0 1
50375: PUSH
50376: LD_INT 101
50378: EQUAL
50379: IFFALSE 50385
// MC_RepairBuildings ( ) ;
50381: CALL 55545 0 0
// if event = 102 then
50385: LD_VAR 0 1
50389: PUSH
50390: LD_INT 102
50392: EQUAL
50393: IFFALSE 50399
// MC_Heal ( ) ;
50395: CALL 56430 0 0
// if event = 103 then
50399: LD_VAR 0 1
50403: PUSH
50404: LD_INT 103
50406: EQUAL
50407: IFFALSE 50413
// MC_Build ( ) ;
50409: CALL 56852 0 0
// if event = 104 then
50413: LD_VAR 0 1
50417: PUSH
50418: LD_INT 104
50420: EQUAL
50421: IFFALSE 50427
// MC_TurretWeapon ( ) ;
50423: CALL 58465 0 0
// if event = 105 then
50427: LD_VAR 0 1
50431: PUSH
50432: LD_INT 105
50434: EQUAL
50435: IFFALSE 50441
// MC_BuildUpgrade ( ) ;
50437: CALL 58016 0 0
// if event = 106 then
50441: LD_VAR 0 1
50445: PUSH
50446: LD_INT 106
50448: EQUAL
50449: IFFALSE 50455
// MC_PlantMines ( ) ;
50451: CALL 58895 0 0
// if event = 107 then
50455: LD_VAR 0 1
50459: PUSH
50460: LD_INT 107
50462: EQUAL
50463: IFFALSE 50469
// MC_CollectCrates ( ) ;
50465: CALL 59693 0 0
// if event = 108 then
50469: LD_VAR 0 1
50473: PUSH
50474: LD_INT 108
50476: EQUAL
50477: IFFALSE 50483
// MC_LinkRemoteControl ( ) ;
50479: CALL 61469 0 0
// if event = 109 then
50483: LD_VAR 0 1
50487: PUSH
50488: LD_INT 109
50490: EQUAL
50491: IFFALSE 50497
// MC_ProduceVehicle ( ) ;
50493: CALL 61650 0 0
// if event = 110 then
50497: LD_VAR 0 1
50501: PUSH
50502: LD_INT 110
50504: EQUAL
50505: IFFALSE 50511
// MC_SendAttack ( ) ;
50507: CALL 62116 0 0
// if event = 111 then
50511: LD_VAR 0 1
50515: PUSH
50516: LD_INT 111
50518: EQUAL
50519: IFFALSE 50525
// MC_Defend ( ) ;
50521: CALL 62224 0 0
// if event = 112 then
50525: LD_VAR 0 1
50529: PUSH
50530: LD_INT 112
50532: EQUAL
50533: IFFALSE 50539
// MC_Research ( ) ;
50535: CALL 62851 0 0
// if event = 113 then
50539: LD_VAR 0 1
50543: PUSH
50544: LD_INT 113
50546: EQUAL
50547: IFFALSE 50553
// MC_MinesTrigger ( ) ;
50549: CALL 63965 0 0
// if event = 120 then
50553: LD_VAR 0 1
50557: PUSH
50558: LD_INT 120
50560: EQUAL
50561: IFFALSE 50567
// MC_RepairVehicle ( ) ;
50563: CALL 64064 0 0
// if event = 121 then
50567: LD_VAR 0 1
50571: PUSH
50572: LD_INT 121
50574: EQUAL
50575: IFFALSE 50581
// MC_TameApe ( ) ;
50577: CALL 64794 0 0
// if event = 122 then
50581: LD_VAR 0 1
50585: PUSH
50586: LD_INT 122
50588: EQUAL
50589: IFFALSE 50595
// MC_ChangeApeClass ( ) ;
50591: CALL 65623 0 0
// if event = 123 then
50595: LD_VAR 0 1
50599: PUSH
50600: LD_INT 123
50602: EQUAL
50603: IFFALSE 50609
// MC_Bazooka ( ) ;
50605: CALL 66273 0 0
// if event = 124 then
50609: LD_VAR 0 1
50613: PUSH
50614: LD_INT 124
50616: EQUAL
50617: IFFALSE 50623
// MC_TeleportExit ( ) ;
50619: CALL 66471 0 0
// if event = 125 then
50623: LD_VAR 0 1
50627: PUSH
50628: LD_INT 125
50630: EQUAL
50631: IFFALSE 50637
// MC_Deposits ( ) ;
50633: CALL 67118 0 0
// if event = 126 then
50637: LD_VAR 0 1
50641: PUSH
50642: LD_INT 126
50644: EQUAL
50645: IFFALSE 50651
// MC_RemoteDriver ( ) ;
50647: CALL 67743 0 0
// if event = 200 then
50651: LD_VAR 0 1
50655: PUSH
50656: LD_INT 200
50658: EQUAL
50659: IFFALSE 50665
// MC_Idle ( ) ;
50661: CALL 69692 0 0
// end ;
50665: PPOPN 1
50667: END
// export function MC_Reset ( base , tag ) ; var i ; begin
50668: LD_INT 0
50670: PPUSH
50671: PPUSH
// if not mc_bases [ base ] or not tag then
50672: LD_EXP 42
50676: PUSH
50677: LD_VAR 0 1
50681: ARRAY
50682: NOT
50683: PUSH
50684: LD_VAR 0 2
50688: NOT
50689: OR
50690: IFFALSE 50694
// exit ;
50692: GO 50758
// for i in mc_bases [ base ] union mc_ape [ base ] do
50694: LD_ADDR_VAR 0 4
50698: PUSH
50699: LD_EXP 42
50703: PUSH
50704: LD_VAR 0 1
50708: ARRAY
50709: PUSH
50710: LD_EXP 71
50714: PUSH
50715: LD_VAR 0 1
50719: ARRAY
50720: UNION
50721: PUSH
50722: FOR_IN
50723: IFFALSE 50756
// if GetTag ( i ) = tag then
50725: LD_VAR 0 4
50729: PPUSH
50730: CALL_OW 110
50734: PUSH
50735: LD_VAR 0 2
50739: EQUAL
50740: IFFALSE 50754
// SetTag ( i , 0 ) ;
50742: LD_VAR 0 4
50746: PPUSH
50747: LD_INT 0
50749: PPUSH
50750: CALL_OW 109
50754: GO 50722
50756: POP
50757: POP
// end ;
50758: LD_VAR 0 3
50762: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
50763: LD_INT 0
50765: PPUSH
50766: PPUSH
50767: PPUSH
50768: PPUSH
50769: PPUSH
50770: PPUSH
50771: PPUSH
50772: PPUSH
// if not mc_bases then
50773: LD_EXP 42
50777: NOT
50778: IFFALSE 50782
// exit ;
50780: GO 51240
// for i = 1 to mc_bases do
50782: LD_ADDR_VAR 0 2
50786: PUSH
50787: DOUBLE
50788: LD_INT 1
50790: DEC
50791: ST_TO_ADDR
50792: LD_EXP 42
50796: PUSH
50797: FOR_TO
50798: IFFALSE 51238
// begin tmp := MC_ClassCheckReq ( i ) ;
50800: LD_ADDR_VAR 0 4
50804: PUSH
50805: LD_VAR 0 2
50809: PPUSH
50810: CALL 51245 0 1
50814: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
50815: LD_ADDR_EXP 83
50819: PUSH
50820: LD_EXP 83
50824: PPUSH
50825: LD_VAR 0 2
50829: PPUSH
50830: LD_VAR 0 4
50834: PPUSH
50835: CALL_OW 1
50839: ST_TO_ADDR
// if not tmp then
50840: LD_VAR 0 4
50844: NOT
50845: IFFALSE 50849
// continue ;
50847: GO 50797
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
50849: LD_ADDR_VAR 0 6
50853: PUSH
50854: LD_EXP 42
50858: PUSH
50859: LD_VAR 0 2
50863: ARRAY
50864: PPUSH
50865: LD_INT 2
50867: PUSH
50868: LD_INT 30
50870: PUSH
50871: LD_INT 4
50873: PUSH
50874: EMPTY
50875: LIST
50876: LIST
50877: PUSH
50878: LD_INT 30
50880: PUSH
50881: LD_INT 5
50883: PUSH
50884: EMPTY
50885: LIST
50886: LIST
50887: PUSH
50888: EMPTY
50889: LIST
50890: LIST
50891: LIST
50892: PPUSH
50893: CALL_OW 72
50897: PUSH
50898: LD_EXP 42
50902: PUSH
50903: LD_VAR 0 2
50907: ARRAY
50908: PPUSH
50909: LD_INT 2
50911: PUSH
50912: LD_INT 30
50914: PUSH
50915: LD_INT 0
50917: PUSH
50918: EMPTY
50919: LIST
50920: LIST
50921: PUSH
50922: LD_INT 30
50924: PUSH
50925: LD_INT 1
50927: PUSH
50928: EMPTY
50929: LIST
50930: LIST
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: LIST
50936: PPUSH
50937: CALL_OW 72
50941: PUSH
50942: LD_EXP 42
50946: PUSH
50947: LD_VAR 0 2
50951: ARRAY
50952: PPUSH
50953: LD_INT 30
50955: PUSH
50956: LD_INT 3
50958: PUSH
50959: EMPTY
50960: LIST
50961: LIST
50962: PPUSH
50963: CALL_OW 72
50967: PUSH
50968: LD_EXP 42
50972: PUSH
50973: LD_VAR 0 2
50977: ARRAY
50978: PPUSH
50979: LD_INT 2
50981: PUSH
50982: LD_INT 30
50984: PUSH
50985: LD_INT 6
50987: PUSH
50988: EMPTY
50989: LIST
50990: LIST
50991: PUSH
50992: LD_INT 30
50994: PUSH
50995: LD_INT 7
50997: PUSH
50998: EMPTY
50999: LIST
51000: LIST
51001: PUSH
51002: LD_INT 30
51004: PUSH
51005: LD_INT 8
51007: PUSH
51008: EMPTY
51009: LIST
51010: LIST
51011: PUSH
51012: EMPTY
51013: LIST
51014: LIST
51015: LIST
51016: LIST
51017: PPUSH
51018: CALL_OW 72
51022: PUSH
51023: EMPTY
51024: LIST
51025: LIST
51026: LIST
51027: LIST
51028: ST_TO_ADDR
// for j = 1 to 4 do
51029: LD_ADDR_VAR 0 3
51033: PUSH
51034: DOUBLE
51035: LD_INT 1
51037: DEC
51038: ST_TO_ADDR
51039: LD_INT 4
51041: PUSH
51042: FOR_TO
51043: IFFALSE 51234
// begin if not tmp [ j ] then
51045: LD_VAR 0 4
51049: PUSH
51050: LD_VAR 0 3
51054: ARRAY
51055: NOT
51056: IFFALSE 51060
// continue ;
51058: GO 51042
// for p in tmp [ j ] do
51060: LD_ADDR_VAR 0 5
51064: PUSH
51065: LD_VAR 0 4
51069: PUSH
51070: LD_VAR 0 3
51074: ARRAY
51075: PUSH
51076: FOR_IN
51077: IFFALSE 51230
// begin if not b [ j ] then
51079: LD_VAR 0 6
51083: PUSH
51084: LD_VAR 0 3
51088: ARRAY
51089: NOT
51090: IFFALSE 51094
// break ;
51092: GO 51230
// e := 0 ;
51094: LD_ADDR_VAR 0 7
51098: PUSH
51099: LD_INT 0
51101: ST_TO_ADDR
// for k in b [ j ] do
51102: LD_ADDR_VAR 0 8
51106: PUSH
51107: LD_VAR 0 6
51111: PUSH
51112: LD_VAR 0 3
51116: ARRAY
51117: PUSH
51118: FOR_IN
51119: IFFALSE 51146
// if IsNotFull ( k ) then
51121: LD_VAR 0 8
51125: PPUSH
51126: CALL 11598 0 1
51130: IFFALSE 51144
// begin e := k ;
51132: LD_ADDR_VAR 0 7
51136: PUSH
51137: LD_VAR 0 8
51141: ST_TO_ADDR
// break ;
51142: GO 51146
// end ;
51144: GO 51118
51146: POP
51147: POP
// if e and not UnitGoingToBuilding ( p , e ) then
51148: LD_VAR 0 7
51152: PUSH
51153: LD_VAR 0 5
51157: PPUSH
51158: LD_VAR 0 7
51162: PPUSH
51163: CALL 44018 0 2
51167: NOT
51168: AND
51169: IFFALSE 51228
// begin if IsInUnit ( p ) then
51171: LD_VAR 0 5
51175: PPUSH
51176: CALL_OW 310
51180: IFFALSE 51191
// ComExitBuilding ( p ) ;
51182: LD_VAR 0 5
51186: PPUSH
51187: CALL_OW 122
// ComEnterUnit ( p , e ) ;
51191: LD_VAR 0 5
51195: PPUSH
51196: LD_VAR 0 7
51200: PPUSH
51201: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
51205: LD_VAR 0 5
51209: PPUSH
51210: LD_VAR 0 3
51214: PPUSH
51215: CALL_OW 183
// AddComExitBuilding ( p ) ;
51219: LD_VAR 0 5
51223: PPUSH
51224: CALL_OW 182
// end ; end ;
51228: GO 51076
51230: POP
51231: POP
// end ;
51232: GO 51042
51234: POP
51235: POP
// end ;
51236: GO 50797
51238: POP
51239: POP
// end ;
51240: LD_VAR 0 1
51244: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
51245: LD_INT 0
51247: PPUSH
51248: PPUSH
51249: PPUSH
51250: PPUSH
51251: PPUSH
51252: PPUSH
51253: PPUSH
51254: PPUSH
51255: PPUSH
51256: PPUSH
51257: PPUSH
51258: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51259: LD_VAR 0 1
51263: NOT
51264: PUSH
51265: LD_EXP 42
51269: PUSH
51270: LD_VAR 0 1
51274: ARRAY
51275: NOT
51276: OR
51277: PUSH
51278: LD_EXP 42
51282: PUSH
51283: LD_VAR 0 1
51287: ARRAY
51288: PPUSH
51289: LD_INT 2
51291: PUSH
51292: LD_INT 30
51294: PUSH
51295: LD_INT 0
51297: PUSH
51298: EMPTY
51299: LIST
51300: LIST
51301: PUSH
51302: LD_INT 30
51304: PUSH
51305: LD_INT 1
51307: PUSH
51308: EMPTY
51309: LIST
51310: LIST
51311: PUSH
51312: EMPTY
51313: LIST
51314: LIST
51315: LIST
51316: PPUSH
51317: CALL_OW 72
51321: NOT
51322: OR
51323: IFFALSE 51327
// exit ;
51325: GO 54830
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51327: LD_ADDR_VAR 0 4
51331: PUSH
51332: LD_EXP 42
51336: PUSH
51337: LD_VAR 0 1
51341: ARRAY
51342: PPUSH
51343: LD_INT 2
51345: PUSH
51346: LD_INT 25
51348: PUSH
51349: LD_INT 1
51351: PUSH
51352: EMPTY
51353: LIST
51354: LIST
51355: PUSH
51356: LD_INT 25
51358: PUSH
51359: LD_INT 2
51361: PUSH
51362: EMPTY
51363: LIST
51364: LIST
51365: PUSH
51366: LD_INT 25
51368: PUSH
51369: LD_INT 3
51371: PUSH
51372: EMPTY
51373: LIST
51374: LIST
51375: PUSH
51376: LD_INT 25
51378: PUSH
51379: LD_INT 4
51381: PUSH
51382: EMPTY
51383: LIST
51384: LIST
51385: PUSH
51386: LD_INT 25
51388: PUSH
51389: LD_INT 5
51391: PUSH
51392: EMPTY
51393: LIST
51394: LIST
51395: PUSH
51396: LD_INT 25
51398: PUSH
51399: LD_INT 8
51401: PUSH
51402: EMPTY
51403: LIST
51404: LIST
51405: PUSH
51406: LD_INT 25
51408: PUSH
51409: LD_INT 9
51411: PUSH
51412: EMPTY
51413: LIST
51414: LIST
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: LIST
51420: LIST
51421: LIST
51422: LIST
51423: LIST
51424: LIST
51425: PPUSH
51426: CALL_OW 72
51430: ST_TO_ADDR
// if not tmp then
51431: LD_VAR 0 4
51435: NOT
51436: IFFALSE 51440
// exit ;
51438: GO 54830
// for i in tmp do
51440: LD_ADDR_VAR 0 3
51444: PUSH
51445: LD_VAR 0 4
51449: PUSH
51450: FOR_IN
51451: IFFALSE 51482
// if GetTag ( i ) then
51453: LD_VAR 0 3
51457: PPUSH
51458: CALL_OW 110
51462: IFFALSE 51480
// tmp := tmp diff i ;
51464: LD_ADDR_VAR 0 4
51468: PUSH
51469: LD_VAR 0 4
51473: PUSH
51474: LD_VAR 0 3
51478: DIFF
51479: ST_TO_ADDR
51480: GO 51450
51482: POP
51483: POP
// if not tmp then
51484: LD_VAR 0 4
51488: NOT
51489: IFFALSE 51493
// exit ;
51491: GO 54830
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51493: LD_ADDR_VAR 0 5
51497: PUSH
51498: LD_EXP 42
51502: PUSH
51503: LD_VAR 0 1
51507: ARRAY
51508: PPUSH
51509: LD_INT 2
51511: PUSH
51512: LD_INT 25
51514: PUSH
51515: LD_INT 1
51517: PUSH
51518: EMPTY
51519: LIST
51520: LIST
51521: PUSH
51522: LD_INT 25
51524: PUSH
51525: LD_INT 5
51527: PUSH
51528: EMPTY
51529: LIST
51530: LIST
51531: PUSH
51532: LD_INT 25
51534: PUSH
51535: LD_INT 8
51537: PUSH
51538: EMPTY
51539: LIST
51540: LIST
51541: PUSH
51542: LD_INT 25
51544: PUSH
51545: LD_INT 9
51547: PUSH
51548: EMPTY
51549: LIST
51550: LIST
51551: PUSH
51552: EMPTY
51553: LIST
51554: LIST
51555: LIST
51556: LIST
51557: LIST
51558: PPUSH
51559: CALL_OW 72
51563: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
51564: LD_ADDR_VAR 0 6
51568: PUSH
51569: LD_EXP 42
51573: PUSH
51574: LD_VAR 0 1
51578: ARRAY
51579: PPUSH
51580: LD_INT 25
51582: PUSH
51583: LD_INT 2
51585: PUSH
51586: EMPTY
51587: LIST
51588: LIST
51589: PPUSH
51590: CALL_OW 72
51594: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
51595: LD_ADDR_VAR 0 7
51599: PUSH
51600: LD_EXP 42
51604: PUSH
51605: LD_VAR 0 1
51609: ARRAY
51610: PPUSH
51611: LD_INT 25
51613: PUSH
51614: LD_INT 3
51616: PUSH
51617: EMPTY
51618: LIST
51619: LIST
51620: PPUSH
51621: CALL_OW 72
51625: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
51626: LD_ADDR_VAR 0 8
51630: PUSH
51631: LD_EXP 42
51635: PUSH
51636: LD_VAR 0 1
51640: ARRAY
51641: PPUSH
51642: LD_INT 25
51644: PUSH
51645: LD_INT 4
51647: PUSH
51648: EMPTY
51649: LIST
51650: LIST
51651: PUSH
51652: LD_INT 24
51654: PUSH
51655: LD_INT 251
51657: PUSH
51658: EMPTY
51659: LIST
51660: LIST
51661: PUSH
51662: EMPTY
51663: LIST
51664: LIST
51665: PPUSH
51666: CALL_OW 72
51670: ST_TO_ADDR
// if mc_scan [ base ] then
51671: LD_EXP 65
51675: PUSH
51676: LD_VAR 0 1
51680: ARRAY
51681: IFFALSE 52142
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
51683: LD_ADDR_EXP 84
51687: PUSH
51688: LD_EXP 84
51692: PPUSH
51693: LD_VAR 0 1
51697: PPUSH
51698: LD_INT 4
51700: PPUSH
51701: CALL_OW 1
51705: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51706: LD_ADDR_VAR 0 12
51710: PUSH
51711: LD_EXP 42
51715: PUSH
51716: LD_VAR 0 1
51720: ARRAY
51721: PPUSH
51722: LD_INT 2
51724: PUSH
51725: LD_INT 30
51727: PUSH
51728: LD_INT 4
51730: PUSH
51731: EMPTY
51732: LIST
51733: LIST
51734: PUSH
51735: LD_INT 30
51737: PUSH
51738: LD_INT 5
51740: PUSH
51741: EMPTY
51742: LIST
51743: LIST
51744: PUSH
51745: EMPTY
51746: LIST
51747: LIST
51748: LIST
51749: PPUSH
51750: CALL_OW 72
51754: ST_TO_ADDR
// if not b then
51755: LD_VAR 0 12
51759: NOT
51760: IFFALSE 51764
// exit ;
51762: GO 54830
// p := [ ] ;
51764: LD_ADDR_VAR 0 11
51768: PUSH
51769: EMPTY
51770: ST_TO_ADDR
// if sci >= 2 then
51771: LD_VAR 0 8
51775: PUSH
51776: LD_INT 2
51778: GREATEREQUAL
51779: IFFALSE 51810
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
51781: LD_ADDR_VAR 0 8
51785: PUSH
51786: LD_VAR 0 8
51790: PUSH
51791: LD_INT 1
51793: ARRAY
51794: PUSH
51795: LD_VAR 0 8
51799: PUSH
51800: LD_INT 2
51802: ARRAY
51803: PUSH
51804: EMPTY
51805: LIST
51806: LIST
51807: ST_TO_ADDR
51808: GO 51871
// if sci = 1 then
51810: LD_VAR 0 8
51814: PUSH
51815: LD_INT 1
51817: EQUAL
51818: IFFALSE 51839
// sci := [ sci [ 1 ] ] else
51820: LD_ADDR_VAR 0 8
51824: PUSH
51825: LD_VAR 0 8
51829: PUSH
51830: LD_INT 1
51832: ARRAY
51833: PUSH
51834: EMPTY
51835: LIST
51836: ST_TO_ADDR
51837: GO 51871
// if sci = 0 then
51839: LD_VAR 0 8
51843: PUSH
51844: LD_INT 0
51846: EQUAL
51847: IFFALSE 51871
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
51849: LD_ADDR_VAR 0 11
51853: PUSH
51854: LD_VAR 0 4
51858: PPUSH
51859: LD_INT 4
51861: PPUSH
51862: CALL 43881 0 2
51866: PUSH
51867: LD_INT 1
51869: ARRAY
51870: ST_TO_ADDR
// if eng > 4 then
51871: LD_VAR 0 6
51875: PUSH
51876: LD_INT 4
51878: GREATER
51879: IFFALSE 51925
// for i = eng downto 4 do
51881: LD_ADDR_VAR 0 3
51885: PUSH
51886: DOUBLE
51887: LD_VAR 0 6
51891: INC
51892: ST_TO_ADDR
51893: LD_INT 4
51895: PUSH
51896: FOR_DOWNTO
51897: IFFALSE 51923
// eng := eng diff eng [ i ] ;
51899: LD_ADDR_VAR 0 6
51903: PUSH
51904: LD_VAR 0 6
51908: PUSH
51909: LD_VAR 0 6
51913: PUSH
51914: LD_VAR 0 3
51918: ARRAY
51919: DIFF
51920: ST_TO_ADDR
51921: GO 51896
51923: POP
51924: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
51925: LD_ADDR_VAR 0 4
51929: PUSH
51930: LD_VAR 0 4
51934: PUSH
51935: LD_VAR 0 5
51939: PUSH
51940: LD_VAR 0 6
51944: UNION
51945: PUSH
51946: LD_VAR 0 7
51950: UNION
51951: PUSH
51952: LD_VAR 0 8
51956: UNION
51957: DIFF
51958: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
51959: LD_ADDR_VAR 0 13
51963: PUSH
51964: LD_EXP 42
51968: PUSH
51969: LD_VAR 0 1
51973: ARRAY
51974: PPUSH
51975: LD_INT 2
51977: PUSH
51978: LD_INT 30
51980: PUSH
51981: LD_INT 32
51983: PUSH
51984: EMPTY
51985: LIST
51986: LIST
51987: PUSH
51988: LD_INT 30
51990: PUSH
51991: LD_INT 31
51993: PUSH
51994: EMPTY
51995: LIST
51996: LIST
51997: PUSH
51998: EMPTY
51999: LIST
52000: LIST
52001: LIST
52002: PPUSH
52003: CALL_OW 72
52007: PUSH
52008: LD_EXP 42
52012: PUSH
52013: LD_VAR 0 1
52017: ARRAY
52018: PPUSH
52019: LD_INT 2
52021: PUSH
52022: LD_INT 30
52024: PUSH
52025: LD_INT 4
52027: PUSH
52028: EMPTY
52029: LIST
52030: LIST
52031: PUSH
52032: LD_INT 30
52034: PUSH
52035: LD_INT 5
52037: PUSH
52038: EMPTY
52039: LIST
52040: LIST
52041: PUSH
52042: EMPTY
52043: LIST
52044: LIST
52045: LIST
52046: PPUSH
52047: CALL_OW 72
52051: PUSH
52052: LD_INT 6
52054: MUL
52055: PLUS
52056: ST_TO_ADDR
// if bcount < tmp then
52057: LD_VAR 0 13
52061: PUSH
52062: LD_VAR 0 4
52066: LESS
52067: IFFALSE 52113
// for i = tmp downto bcount do
52069: LD_ADDR_VAR 0 3
52073: PUSH
52074: DOUBLE
52075: LD_VAR 0 4
52079: INC
52080: ST_TO_ADDR
52081: LD_VAR 0 13
52085: PUSH
52086: FOR_DOWNTO
52087: IFFALSE 52111
// tmp := Delete ( tmp , tmp ) ;
52089: LD_ADDR_VAR 0 4
52093: PUSH
52094: LD_VAR 0 4
52098: PPUSH
52099: LD_VAR 0 4
52103: PPUSH
52104: CALL_OW 3
52108: ST_TO_ADDR
52109: GO 52086
52111: POP
52112: POP
// result := [ tmp , 0 , 0 , p ] ;
52113: LD_ADDR_VAR 0 2
52117: PUSH
52118: LD_VAR 0 4
52122: PUSH
52123: LD_INT 0
52125: PUSH
52126: LD_INT 0
52128: PUSH
52129: LD_VAR 0 11
52133: PUSH
52134: EMPTY
52135: LIST
52136: LIST
52137: LIST
52138: LIST
52139: ST_TO_ADDR
// exit ;
52140: GO 54830
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52142: LD_EXP 42
52146: PUSH
52147: LD_VAR 0 1
52151: ARRAY
52152: PPUSH
52153: LD_INT 2
52155: PUSH
52156: LD_INT 30
52158: PUSH
52159: LD_INT 6
52161: PUSH
52162: EMPTY
52163: LIST
52164: LIST
52165: PUSH
52166: LD_INT 30
52168: PUSH
52169: LD_INT 7
52171: PUSH
52172: EMPTY
52173: LIST
52174: LIST
52175: PUSH
52176: LD_INT 30
52178: PUSH
52179: LD_INT 8
52181: PUSH
52182: EMPTY
52183: LIST
52184: LIST
52185: PUSH
52186: EMPTY
52187: LIST
52188: LIST
52189: LIST
52190: LIST
52191: PPUSH
52192: CALL_OW 72
52196: NOT
52197: PUSH
52198: LD_EXP 42
52202: PUSH
52203: LD_VAR 0 1
52207: ARRAY
52208: PPUSH
52209: LD_INT 30
52211: PUSH
52212: LD_INT 3
52214: PUSH
52215: EMPTY
52216: LIST
52217: LIST
52218: PPUSH
52219: CALL_OW 72
52223: NOT
52224: AND
52225: IFFALSE 52297
// begin if eng = tmp then
52227: LD_VAR 0 6
52231: PUSH
52232: LD_VAR 0 4
52236: EQUAL
52237: IFFALSE 52241
// exit ;
52239: GO 54830
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
52241: LD_ADDR_EXP 84
52245: PUSH
52246: LD_EXP 84
52250: PPUSH
52251: LD_VAR 0 1
52255: PPUSH
52256: LD_INT 1
52258: PPUSH
52259: CALL_OW 1
52263: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
52264: LD_ADDR_VAR 0 2
52268: PUSH
52269: LD_INT 0
52271: PUSH
52272: LD_VAR 0 4
52276: PUSH
52277: LD_VAR 0 6
52281: DIFF
52282: PUSH
52283: LD_INT 0
52285: PUSH
52286: LD_INT 0
52288: PUSH
52289: EMPTY
52290: LIST
52291: LIST
52292: LIST
52293: LIST
52294: ST_TO_ADDR
// exit ;
52295: GO 54830
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52297: LD_EXP 69
52301: PUSH
52302: LD_EXP 68
52306: PUSH
52307: LD_VAR 0 1
52311: ARRAY
52312: ARRAY
52313: PUSH
52314: LD_EXP 42
52318: PUSH
52319: LD_VAR 0 1
52323: ARRAY
52324: PPUSH
52325: LD_INT 2
52327: PUSH
52328: LD_INT 30
52330: PUSH
52331: LD_INT 6
52333: PUSH
52334: EMPTY
52335: LIST
52336: LIST
52337: PUSH
52338: LD_INT 30
52340: PUSH
52341: LD_INT 7
52343: PUSH
52344: EMPTY
52345: LIST
52346: LIST
52347: PUSH
52348: LD_INT 30
52350: PUSH
52351: LD_INT 8
52353: PUSH
52354: EMPTY
52355: LIST
52356: LIST
52357: PUSH
52358: EMPTY
52359: LIST
52360: LIST
52361: LIST
52362: LIST
52363: PPUSH
52364: CALL_OW 72
52368: AND
52369: PUSH
52370: LD_EXP 42
52374: PUSH
52375: LD_VAR 0 1
52379: ARRAY
52380: PPUSH
52381: LD_INT 30
52383: PUSH
52384: LD_INT 3
52386: PUSH
52387: EMPTY
52388: LIST
52389: LIST
52390: PPUSH
52391: CALL_OW 72
52395: NOT
52396: AND
52397: IFFALSE 52611
// begin if sci >= 6 then
52399: LD_VAR 0 8
52403: PUSH
52404: LD_INT 6
52406: GREATEREQUAL
52407: IFFALSE 52411
// exit ;
52409: GO 54830
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
52411: LD_ADDR_EXP 84
52415: PUSH
52416: LD_EXP 84
52420: PPUSH
52421: LD_VAR 0 1
52425: PPUSH
52426: LD_INT 2
52428: PPUSH
52429: CALL_OW 1
52433: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
52434: LD_ADDR_VAR 0 9
52438: PUSH
52439: LD_VAR 0 4
52443: PUSH
52444: LD_VAR 0 8
52448: DIFF
52449: PPUSH
52450: LD_INT 4
52452: PPUSH
52453: CALL 43881 0 2
52457: ST_TO_ADDR
// p := [ ] ;
52458: LD_ADDR_VAR 0 11
52462: PUSH
52463: EMPTY
52464: ST_TO_ADDR
// if sci < 6 and sort > 6 then
52465: LD_VAR 0 8
52469: PUSH
52470: LD_INT 6
52472: LESS
52473: PUSH
52474: LD_VAR 0 9
52478: PUSH
52479: LD_INT 6
52481: GREATER
52482: AND
52483: IFFALSE 52564
// begin for i = 1 to 6 - sci do
52485: LD_ADDR_VAR 0 3
52489: PUSH
52490: DOUBLE
52491: LD_INT 1
52493: DEC
52494: ST_TO_ADDR
52495: LD_INT 6
52497: PUSH
52498: LD_VAR 0 8
52502: MINUS
52503: PUSH
52504: FOR_TO
52505: IFFALSE 52560
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
52507: LD_ADDR_VAR 0 11
52511: PUSH
52512: LD_VAR 0 11
52516: PPUSH
52517: LD_VAR 0 11
52521: PUSH
52522: LD_INT 1
52524: PLUS
52525: PPUSH
52526: LD_VAR 0 9
52530: PUSH
52531: LD_INT 1
52533: ARRAY
52534: PPUSH
52535: CALL_OW 2
52539: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
52540: LD_ADDR_VAR 0 9
52544: PUSH
52545: LD_VAR 0 9
52549: PPUSH
52550: LD_INT 1
52552: PPUSH
52553: CALL_OW 3
52557: ST_TO_ADDR
// end ;
52558: GO 52504
52560: POP
52561: POP
// end else
52562: GO 52584
// if sort then
52564: LD_VAR 0 9
52568: IFFALSE 52584
// p := sort [ 1 ] ;
52570: LD_ADDR_VAR 0 11
52574: PUSH
52575: LD_VAR 0 9
52579: PUSH
52580: LD_INT 1
52582: ARRAY
52583: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
52584: LD_ADDR_VAR 0 2
52588: PUSH
52589: LD_INT 0
52591: PUSH
52592: LD_INT 0
52594: PUSH
52595: LD_INT 0
52597: PUSH
52598: LD_VAR 0 11
52602: PUSH
52603: EMPTY
52604: LIST
52605: LIST
52606: LIST
52607: LIST
52608: ST_TO_ADDR
// exit ;
52609: GO 54830
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52611: LD_EXP 69
52615: PUSH
52616: LD_EXP 68
52620: PUSH
52621: LD_VAR 0 1
52625: ARRAY
52626: ARRAY
52627: PUSH
52628: LD_EXP 42
52632: PUSH
52633: LD_VAR 0 1
52637: ARRAY
52638: PPUSH
52639: LD_INT 2
52641: PUSH
52642: LD_INT 30
52644: PUSH
52645: LD_INT 6
52647: PUSH
52648: EMPTY
52649: LIST
52650: LIST
52651: PUSH
52652: LD_INT 30
52654: PUSH
52655: LD_INT 7
52657: PUSH
52658: EMPTY
52659: LIST
52660: LIST
52661: PUSH
52662: LD_INT 30
52664: PUSH
52665: LD_INT 8
52667: PUSH
52668: EMPTY
52669: LIST
52670: LIST
52671: PUSH
52672: EMPTY
52673: LIST
52674: LIST
52675: LIST
52676: LIST
52677: PPUSH
52678: CALL_OW 72
52682: AND
52683: PUSH
52684: LD_EXP 42
52688: PUSH
52689: LD_VAR 0 1
52693: ARRAY
52694: PPUSH
52695: LD_INT 30
52697: PUSH
52698: LD_INT 3
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: PPUSH
52705: CALL_OW 72
52709: AND
52710: IFFALSE 53444
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
52712: LD_ADDR_EXP 84
52716: PUSH
52717: LD_EXP 84
52721: PPUSH
52722: LD_VAR 0 1
52726: PPUSH
52727: LD_INT 3
52729: PPUSH
52730: CALL_OW 1
52734: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
52735: LD_ADDR_VAR 0 2
52739: PUSH
52740: LD_INT 0
52742: PUSH
52743: LD_INT 0
52745: PUSH
52746: LD_INT 0
52748: PUSH
52749: LD_INT 0
52751: PUSH
52752: EMPTY
52753: LIST
52754: LIST
52755: LIST
52756: LIST
52757: ST_TO_ADDR
// if not eng then
52758: LD_VAR 0 6
52762: NOT
52763: IFFALSE 52826
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
52765: LD_ADDR_VAR 0 11
52769: PUSH
52770: LD_VAR 0 4
52774: PPUSH
52775: LD_INT 2
52777: PPUSH
52778: CALL 43881 0 2
52782: PUSH
52783: LD_INT 1
52785: ARRAY
52786: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
52787: LD_ADDR_VAR 0 2
52791: PUSH
52792: LD_VAR 0 2
52796: PPUSH
52797: LD_INT 2
52799: PPUSH
52800: LD_VAR 0 11
52804: PPUSH
52805: CALL_OW 1
52809: ST_TO_ADDR
// tmp := tmp diff p ;
52810: LD_ADDR_VAR 0 4
52814: PUSH
52815: LD_VAR 0 4
52819: PUSH
52820: LD_VAR 0 11
52824: DIFF
52825: ST_TO_ADDR
// end ; if tmp and sci < 6 then
52826: LD_VAR 0 4
52830: PUSH
52831: LD_VAR 0 8
52835: PUSH
52836: LD_INT 6
52838: LESS
52839: AND
52840: IFFALSE 53028
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
52842: LD_ADDR_VAR 0 9
52846: PUSH
52847: LD_VAR 0 4
52851: PUSH
52852: LD_VAR 0 8
52856: PUSH
52857: LD_VAR 0 7
52861: UNION
52862: DIFF
52863: PPUSH
52864: LD_INT 4
52866: PPUSH
52867: CALL 43881 0 2
52871: ST_TO_ADDR
// p := [ ] ;
52872: LD_ADDR_VAR 0 11
52876: PUSH
52877: EMPTY
52878: ST_TO_ADDR
// if sort then
52879: LD_VAR 0 9
52883: IFFALSE 52999
// for i = 1 to 6 - sci do
52885: LD_ADDR_VAR 0 3
52889: PUSH
52890: DOUBLE
52891: LD_INT 1
52893: DEC
52894: ST_TO_ADDR
52895: LD_INT 6
52897: PUSH
52898: LD_VAR 0 8
52902: MINUS
52903: PUSH
52904: FOR_TO
52905: IFFALSE 52997
// begin if i = sort then
52907: LD_VAR 0 3
52911: PUSH
52912: LD_VAR 0 9
52916: EQUAL
52917: IFFALSE 52921
// break ;
52919: GO 52997
// if GetClass ( i ) = 4 then
52921: LD_VAR 0 3
52925: PPUSH
52926: CALL_OW 257
52930: PUSH
52931: LD_INT 4
52933: EQUAL
52934: IFFALSE 52938
// continue ;
52936: GO 52904
// p := Insert ( p , p + 1 , sort [ i ] ) ;
52938: LD_ADDR_VAR 0 11
52942: PUSH
52943: LD_VAR 0 11
52947: PPUSH
52948: LD_VAR 0 11
52952: PUSH
52953: LD_INT 1
52955: PLUS
52956: PPUSH
52957: LD_VAR 0 9
52961: PUSH
52962: LD_VAR 0 3
52966: ARRAY
52967: PPUSH
52968: CALL_OW 2
52972: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
52973: LD_ADDR_VAR 0 4
52977: PUSH
52978: LD_VAR 0 4
52982: PUSH
52983: LD_VAR 0 9
52987: PUSH
52988: LD_VAR 0 3
52992: ARRAY
52993: DIFF
52994: ST_TO_ADDR
// end ;
52995: GO 52904
52997: POP
52998: POP
// if p then
52999: LD_VAR 0 11
53003: IFFALSE 53028
// result := Replace ( result , 4 , p ) ;
53005: LD_ADDR_VAR 0 2
53009: PUSH
53010: LD_VAR 0 2
53014: PPUSH
53015: LD_INT 4
53017: PPUSH
53018: LD_VAR 0 11
53022: PPUSH
53023: CALL_OW 1
53027: ST_TO_ADDR
// end ; if tmp and mech < 6 then
53028: LD_VAR 0 4
53032: PUSH
53033: LD_VAR 0 7
53037: PUSH
53038: LD_INT 6
53040: LESS
53041: AND
53042: IFFALSE 53230
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
53044: LD_ADDR_VAR 0 9
53048: PUSH
53049: LD_VAR 0 4
53053: PUSH
53054: LD_VAR 0 8
53058: PUSH
53059: LD_VAR 0 7
53063: UNION
53064: DIFF
53065: PPUSH
53066: LD_INT 3
53068: PPUSH
53069: CALL 43881 0 2
53073: ST_TO_ADDR
// p := [ ] ;
53074: LD_ADDR_VAR 0 11
53078: PUSH
53079: EMPTY
53080: ST_TO_ADDR
// if sort then
53081: LD_VAR 0 9
53085: IFFALSE 53201
// for i = 1 to 6 - mech do
53087: LD_ADDR_VAR 0 3
53091: PUSH
53092: DOUBLE
53093: LD_INT 1
53095: DEC
53096: ST_TO_ADDR
53097: LD_INT 6
53099: PUSH
53100: LD_VAR 0 7
53104: MINUS
53105: PUSH
53106: FOR_TO
53107: IFFALSE 53199
// begin if i = sort then
53109: LD_VAR 0 3
53113: PUSH
53114: LD_VAR 0 9
53118: EQUAL
53119: IFFALSE 53123
// break ;
53121: GO 53199
// if GetClass ( i ) = 3 then
53123: LD_VAR 0 3
53127: PPUSH
53128: CALL_OW 257
53132: PUSH
53133: LD_INT 3
53135: EQUAL
53136: IFFALSE 53140
// continue ;
53138: GO 53106
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53140: LD_ADDR_VAR 0 11
53144: PUSH
53145: LD_VAR 0 11
53149: PPUSH
53150: LD_VAR 0 11
53154: PUSH
53155: LD_INT 1
53157: PLUS
53158: PPUSH
53159: LD_VAR 0 9
53163: PUSH
53164: LD_VAR 0 3
53168: ARRAY
53169: PPUSH
53170: CALL_OW 2
53174: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53175: LD_ADDR_VAR 0 4
53179: PUSH
53180: LD_VAR 0 4
53184: PUSH
53185: LD_VAR 0 9
53189: PUSH
53190: LD_VAR 0 3
53194: ARRAY
53195: DIFF
53196: ST_TO_ADDR
// end ;
53197: GO 53106
53199: POP
53200: POP
// if p then
53201: LD_VAR 0 11
53205: IFFALSE 53230
// result := Replace ( result , 3 , p ) ;
53207: LD_ADDR_VAR 0 2
53211: PUSH
53212: LD_VAR 0 2
53216: PPUSH
53217: LD_INT 3
53219: PPUSH
53220: LD_VAR 0 11
53224: PPUSH
53225: CALL_OW 1
53229: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
53230: LD_VAR 0 4
53234: PUSH
53235: LD_INT 6
53237: GREATER
53238: PUSH
53239: LD_VAR 0 6
53243: PUSH
53244: LD_INT 6
53246: LESS
53247: AND
53248: IFFALSE 53442
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
53250: LD_ADDR_VAR 0 9
53254: PUSH
53255: LD_VAR 0 4
53259: PUSH
53260: LD_VAR 0 8
53264: PUSH
53265: LD_VAR 0 7
53269: UNION
53270: PUSH
53271: LD_VAR 0 6
53275: UNION
53276: DIFF
53277: PPUSH
53278: LD_INT 2
53280: PPUSH
53281: CALL 43881 0 2
53285: ST_TO_ADDR
// p := [ ] ;
53286: LD_ADDR_VAR 0 11
53290: PUSH
53291: EMPTY
53292: ST_TO_ADDR
// if sort then
53293: LD_VAR 0 9
53297: IFFALSE 53413
// for i = 1 to 6 - eng do
53299: LD_ADDR_VAR 0 3
53303: PUSH
53304: DOUBLE
53305: LD_INT 1
53307: DEC
53308: ST_TO_ADDR
53309: LD_INT 6
53311: PUSH
53312: LD_VAR 0 6
53316: MINUS
53317: PUSH
53318: FOR_TO
53319: IFFALSE 53411
// begin if i = sort then
53321: LD_VAR 0 3
53325: PUSH
53326: LD_VAR 0 9
53330: EQUAL
53331: IFFALSE 53335
// break ;
53333: GO 53411
// if GetClass ( i ) = 2 then
53335: LD_VAR 0 3
53339: PPUSH
53340: CALL_OW 257
53344: PUSH
53345: LD_INT 2
53347: EQUAL
53348: IFFALSE 53352
// continue ;
53350: GO 53318
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53352: LD_ADDR_VAR 0 11
53356: PUSH
53357: LD_VAR 0 11
53361: PPUSH
53362: LD_VAR 0 11
53366: PUSH
53367: LD_INT 1
53369: PLUS
53370: PPUSH
53371: LD_VAR 0 9
53375: PUSH
53376: LD_VAR 0 3
53380: ARRAY
53381: PPUSH
53382: CALL_OW 2
53386: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53387: LD_ADDR_VAR 0 4
53391: PUSH
53392: LD_VAR 0 4
53396: PUSH
53397: LD_VAR 0 9
53401: PUSH
53402: LD_VAR 0 3
53406: ARRAY
53407: DIFF
53408: ST_TO_ADDR
// end ;
53409: GO 53318
53411: POP
53412: POP
// if p then
53413: LD_VAR 0 11
53417: IFFALSE 53442
// result := Replace ( result , 2 , p ) ;
53419: LD_ADDR_VAR 0 2
53423: PUSH
53424: LD_VAR 0 2
53428: PPUSH
53429: LD_INT 2
53431: PPUSH
53432: LD_VAR 0 11
53436: PPUSH
53437: CALL_OW 1
53441: ST_TO_ADDR
// end ; exit ;
53442: GO 54830
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
53444: LD_EXP 69
53448: PUSH
53449: LD_EXP 68
53453: PUSH
53454: LD_VAR 0 1
53458: ARRAY
53459: ARRAY
53460: NOT
53461: PUSH
53462: LD_EXP 42
53466: PUSH
53467: LD_VAR 0 1
53471: ARRAY
53472: PPUSH
53473: LD_INT 30
53475: PUSH
53476: LD_INT 3
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: PPUSH
53483: CALL_OW 72
53487: AND
53488: PUSH
53489: LD_EXP 47
53493: PUSH
53494: LD_VAR 0 1
53498: ARRAY
53499: AND
53500: IFFALSE 54108
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
53502: LD_ADDR_EXP 84
53506: PUSH
53507: LD_EXP 84
53511: PPUSH
53512: LD_VAR 0 1
53516: PPUSH
53517: LD_INT 5
53519: PPUSH
53520: CALL_OW 1
53524: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53525: LD_ADDR_VAR 0 2
53529: PUSH
53530: LD_INT 0
53532: PUSH
53533: LD_INT 0
53535: PUSH
53536: LD_INT 0
53538: PUSH
53539: LD_INT 0
53541: PUSH
53542: EMPTY
53543: LIST
53544: LIST
53545: LIST
53546: LIST
53547: ST_TO_ADDR
// if sci > 1 then
53548: LD_VAR 0 8
53552: PUSH
53553: LD_INT 1
53555: GREATER
53556: IFFALSE 53584
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
53558: LD_ADDR_VAR 0 4
53562: PUSH
53563: LD_VAR 0 4
53567: PUSH
53568: LD_VAR 0 8
53572: PUSH
53573: LD_VAR 0 8
53577: PUSH
53578: LD_INT 1
53580: ARRAY
53581: DIFF
53582: DIFF
53583: ST_TO_ADDR
// if tmp and not sci then
53584: LD_VAR 0 4
53588: PUSH
53589: LD_VAR 0 8
53593: NOT
53594: AND
53595: IFFALSE 53664
// begin sort := SortBySkill ( tmp , 4 ) ;
53597: LD_ADDR_VAR 0 9
53601: PUSH
53602: LD_VAR 0 4
53606: PPUSH
53607: LD_INT 4
53609: PPUSH
53610: CALL 43881 0 2
53614: ST_TO_ADDR
// if sort then
53615: LD_VAR 0 9
53619: IFFALSE 53635
// p := sort [ 1 ] ;
53621: LD_ADDR_VAR 0 11
53625: PUSH
53626: LD_VAR 0 9
53630: PUSH
53631: LD_INT 1
53633: ARRAY
53634: ST_TO_ADDR
// if p then
53635: LD_VAR 0 11
53639: IFFALSE 53664
// result := Replace ( result , 4 , p ) ;
53641: LD_ADDR_VAR 0 2
53645: PUSH
53646: LD_VAR 0 2
53650: PPUSH
53651: LD_INT 4
53653: PPUSH
53654: LD_VAR 0 11
53658: PPUSH
53659: CALL_OW 1
53663: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
53664: LD_ADDR_VAR 0 4
53668: PUSH
53669: LD_VAR 0 4
53673: PUSH
53674: LD_VAR 0 7
53678: DIFF
53679: ST_TO_ADDR
// if tmp and mech < 6 then
53680: LD_VAR 0 4
53684: PUSH
53685: LD_VAR 0 7
53689: PUSH
53690: LD_INT 6
53692: LESS
53693: AND
53694: IFFALSE 53882
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
53696: LD_ADDR_VAR 0 9
53700: PUSH
53701: LD_VAR 0 4
53705: PUSH
53706: LD_VAR 0 8
53710: PUSH
53711: LD_VAR 0 7
53715: UNION
53716: DIFF
53717: PPUSH
53718: LD_INT 3
53720: PPUSH
53721: CALL 43881 0 2
53725: ST_TO_ADDR
// p := [ ] ;
53726: LD_ADDR_VAR 0 11
53730: PUSH
53731: EMPTY
53732: ST_TO_ADDR
// if sort then
53733: LD_VAR 0 9
53737: IFFALSE 53853
// for i = 1 to 6 - mech do
53739: LD_ADDR_VAR 0 3
53743: PUSH
53744: DOUBLE
53745: LD_INT 1
53747: DEC
53748: ST_TO_ADDR
53749: LD_INT 6
53751: PUSH
53752: LD_VAR 0 7
53756: MINUS
53757: PUSH
53758: FOR_TO
53759: IFFALSE 53851
// begin if i = sort then
53761: LD_VAR 0 3
53765: PUSH
53766: LD_VAR 0 9
53770: EQUAL
53771: IFFALSE 53775
// break ;
53773: GO 53851
// if GetClass ( i ) = 3 then
53775: LD_VAR 0 3
53779: PPUSH
53780: CALL_OW 257
53784: PUSH
53785: LD_INT 3
53787: EQUAL
53788: IFFALSE 53792
// continue ;
53790: GO 53758
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53792: LD_ADDR_VAR 0 11
53796: PUSH
53797: LD_VAR 0 11
53801: PPUSH
53802: LD_VAR 0 11
53806: PUSH
53807: LD_INT 1
53809: PLUS
53810: PPUSH
53811: LD_VAR 0 9
53815: PUSH
53816: LD_VAR 0 3
53820: ARRAY
53821: PPUSH
53822: CALL_OW 2
53826: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53827: LD_ADDR_VAR 0 4
53831: PUSH
53832: LD_VAR 0 4
53836: PUSH
53837: LD_VAR 0 9
53841: PUSH
53842: LD_VAR 0 3
53846: ARRAY
53847: DIFF
53848: ST_TO_ADDR
// end ;
53849: GO 53758
53851: POP
53852: POP
// if p then
53853: LD_VAR 0 11
53857: IFFALSE 53882
// result := Replace ( result , 3 , p ) ;
53859: LD_ADDR_VAR 0 2
53863: PUSH
53864: LD_VAR 0 2
53868: PPUSH
53869: LD_INT 3
53871: PPUSH
53872: LD_VAR 0 11
53876: PPUSH
53877: CALL_OW 1
53881: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
53882: LD_ADDR_VAR 0 4
53886: PUSH
53887: LD_VAR 0 4
53891: PUSH
53892: LD_VAR 0 6
53896: DIFF
53897: ST_TO_ADDR
// if tmp and eng < 6 then
53898: LD_VAR 0 4
53902: PUSH
53903: LD_VAR 0 6
53907: PUSH
53908: LD_INT 6
53910: LESS
53911: AND
53912: IFFALSE 54106
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
53914: LD_ADDR_VAR 0 9
53918: PUSH
53919: LD_VAR 0 4
53923: PUSH
53924: LD_VAR 0 8
53928: PUSH
53929: LD_VAR 0 7
53933: UNION
53934: PUSH
53935: LD_VAR 0 6
53939: UNION
53940: DIFF
53941: PPUSH
53942: LD_INT 2
53944: PPUSH
53945: CALL 43881 0 2
53949: ST_TO_ADDR
// p := [ ] ;
53950: LD_ADDR_VAR 0 11
53954: PUSH
53955: EMPTY
53956: ST_TO_ADDR
// if sort then
53957: LD_VAR 0 9
53961: IFFALSE 54077
// for i = 1 to 6 - eng do
53963: LD_ADDR_VAR 0 3
53967: PUSH
53968: DOUBLE
53969: LD_INT 1
53971: DEC
53972: ST_TO_ADDR
53973: LD_INT 6
53975: PUSH
53976: LD_VAR 0 6
53980: MINUS
53981: PUSH
53982: FOR_TO
53983: IFFALSE 54075
// begin if i = sort then
53985: LD_VAR 0 3
53989: PUSH
53990: LD_VAR 0 9
53994: EQUAL
53995: IFFALSE 53999
// break ;
53997: GO 54075
// if GetClass ( i ) = 2 then
53999: LD_VAR 0 3
54003: PPUSH
54004: CALL_OW 257
54008: PUSH
54009: LD_INT 2
54011: EQUAL
54012: IFFALSE 54016
// continue ;
54014: GO 53982
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54016: LD_ADDR_VAR 0 11
54020: PUSH
54021: LD_VAR 0 11
54025: PPUSH
54026: LD_VAR 0 11
54030: PUSH
54031: LD_INT 1
54033: PLUS
54034: PPUSH
54035: LD_VAR 0 9
54039: PUSH
54040: LD_VAR 0 3
54044: ARRAY
54045: PPUSH
54046: CALL_OW 2
54050: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54051: LD_ADDR_VAR 0 4
54055: PUSH
54056: LD_VAR 0 4
54060: PUSH
54061: LD_VAR 0 9
54065: PUSH
54066: LD_VAR 0 3
54070: ARRAY
54071: DIFF
54072: ST_TO_ADDR
// end ;
54073: GO 53982
54075: POP
54076: POP
// if p then
54077: LD_VAR 0 11
54081: IFFALSE 54106
// result := Replace ( result , 2 , p ) ;
54083: LD_ADDR_VAR 0 2
54087: PUSH
54088: LD_VAR 0 2
54092: PPUSH
54093: LD_INT 2
54095: PPUSH
54096: LD_VAR 0 11
54100: PPUSH
54101: CALL_OW 1
54105: ST_TO_ADDR
// end ; exit ;
54106: GO 54830
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
54108: LD_EXP 69
54112: PUSH
54113: LD_EXP 68
54117: PUSH
54118: LD_VAR 0 1
54122: ARRAY
54123: ARRAY
54124: NOT
54125: PUSH
54126: LD_EXP 42
54130: PUSH
54131: LD_VAR 0 1
54135: ARRAY
54136: PPUSH
54137: LD_INT 30
54139: PUSH
54140: LD_INT 3
54142: PUSH
54143: EMPTY
54144: LIST
54145: LIST
54146: PPUSH
54147: CALL_OW 72
54151: AND
54152: PUSH
54153: LD_EXP 47
54157: PUSH
54158: LD_VAR 0 1
54162: ARRAY
54163: NOT
54164: AND
54165: IFFALSE 54830
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
54167: LD_ADDR_EXP 84
54171: PUSH
54172: LD_EXP 84
54176: PPUSH
54177: LD_VAR 0 1
54181: PPUSH
54182: LD_INT 6
54184: PPUSH
54185: CALL_OW 1
54189: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54190: LD_ADDR_VAR 0 2
54194: PUSH
54195: LD_INT 0
54197: PUSH
54198: LD_INT 0
54200: PUSH
54201: LD_INT 0
54203: PUSH
54204: LD_INT 0
54206: PUSH
54207: EMPTY
54208: LIST
54209: LIST
54210: LIST
54211: LIST
54212: ST_TO_ADDR
// if sci >= 1 then
54213: LD_VAR 0 8
54217: PUSH
54218: LD_INT 1
54220: GREATEREQUAL
54221: IFFALSE 54243
// tmp := tmp diff sci [ 1 ] ;
54223: LD_ADDR_VAR 0 4
54227: PUSH
54228: LD_VAR 0 4
54232: PUSH
54233: LD_VAR 0 8
54237: PUSH
54238: LD_INT 1
54240: ARRAY
54241: DIFF
54242: ST_TO_ADDR
// if tmp and not sci then
54243: LD_VAR 0 4
54247: PUSH
54248: LD_VAR 0 8
54252: NOT
54253: AND
54254: IFFALSE 54323
// begin sort := SortBySkill ( tmp , 4 ) ;
54256: LD_ADDR_VAR 0 9
54260: PUSH
54261: LD_VAR 0 4
54265: PPUSH
54266: LD_INT 4
54268: PPUSH
54269: CALL 43881 0 2
54273: ST_TO_ADDR
// if sort then
54274: LD_VAR 0 9
54278: IFFALSE 54294
// p := sort [ 1 ] ;
54280: LD_ADDR_VAR 0 11
54284: PUSH
54285: LD_VAR 0 9
54289: PUSH
54290: LD_INT 1
54292: ARRAY
54293: ST_TO_ADDR
// if p then
54294: LD_VAR 0 11
54298: IFFALSE 54323
// result := Replace ( result , 4 , p ) ;
54300: LD_ADDR_VAR 0 2
54304: PUSH
54305: LD_VAR 0 2
54309: PPUSH
54310: LD_INT 4
54312: PPUSH
54313: LD_VAR 0 11
54317: PPUSH
54318: CALL_OW 1
54322: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54323: LD_ADDR_VAR 0 4
54327: PUSH
54328: LD_VAR 0 4
54332: PUSH
54333: LD_VAR 0 7
54337: DIFF
54338: ST_TO_ADDR
// if tmp and mech < 6 then
54339: LD_VAR 0 4
54343: PUSH
54344: LD_VAR 0 7
54348: PUSH
54349: LD_INT 6
54351: LESS
54352: AND
54353: IFFALSE 54535
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
54355: LD_ADDR_VAR 0 9
54359: PUSH
54360: LD_VAR 0 4
54364: PUSH
54365: LD_VAR 0 7
54369: DIFF
54370: PPUSH
54371: LD_INT 3
54373: PPUSH
54374: CALL 43881 0 2
54378: ST_TO_ADDR
// p := [ ] ;
54379: LD_ADDR_VAR 0 11
54383: PUSH
54384: EMPTY
54385: ST_TO_ADDR
// if sort then
54386: LD_VAR 0 9
54390: IFFALSE 54506
// for i = 1 to 6 - mech do
54392: LD_ADDR_VAR 0 3
54396: PUSH
54397: DOUBLE
54398: LD_INT 1
54400: DEC
54401: ST_TO_ADDR
54402: LD_INT 6
54404: PUSH
54405: LD_VAR 0 7
54409: MINUS
54410: PUSH
54411: FOR_TO
54412: IFFALSE 54504
// begin if i = sort then
54414: LD_VAR 0 3
54418: PUSH
54419: LD_VAR 0 9
54423: EQUAL
54424: IFFALSE 54428
// break ;
54426: GO 54504
// if GetClass ( i ) = 3 then
54428: LD_VAR 0 3
54432: PPUSH
54433: CALL_OW 257
54437: PUSH
54438: LD_INT 3
54440: EQUAL
54441: IFFALSE 54445
// continue ;
54443: GO 54411
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54445: LD_ADDR_VAR 0 11
54449: PUSH
54450: LD_VAR 0 11
54454: PPUSH
54455: LD_VAR 0 11
54459: PUSH
54460: LD_INT 1
54462: PLUS
54463: PPUSH
54464: LD_VAR 0 9
54468: PUSH
54469: LD_VAR 0 3
54473: ARRAY
54474: PPUSH
54475: CALL_OW 2
54479: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54480: LD_ADDR_VAR 0 4
54484: PUSH
54485: LD_VAR 0 4
54489: PUSH
54490: LD_VAR 0 9
54494: PUSH
54495: LD_VAR 0 3
54499: ARRAY
54500: DIFF
54501: ST_TO_ADDR
// end ;
54502: GO 54411
54504: POP
54505: POP
// if p then
54506: LD_VAR 0 11
54510: IFFALSE 54535
// result := Replace ( result , 3 , p ) ;
54512: LD_ADDR_VAR 0 2
54516: PUSH
54517: LD_VAR 0 2
54521: PPUSH
54522: LD_INT 3
54524: PPUSH
54525: LD_VAR 0 11
54529: PPUSH
54530: CALL_OW 1
54534: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54535: LD_ADDR_VAR 0 4
54539: PUSH
54540: LD_VAR 0 4
54544: PUSH
54545: LD_VAR 0 6
54549: DIFF
54550: ST_TO_ADDR
// if tmp and eng < 4 then
54551: LD_VAR 0 4
54555: PUSH
54556: LD_VAR 0 6
54560: PUSH
54561: LD_INT 4
54563: LESS
54564: AND
54565: IFFALSE 54755
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
54567: LD_ADDR_VAR 0 9
54571: PUSH
54572: LD_VAR 0 4
54576: PUSH
54577: LD_VAR 0 7
54581: PUSH
54582: LD_VAR 0 6
54586: UNION
54587: DIFF
54588: PPUSH
54589: LD_INT 2
54591: PPUSH
54592: CALL 43881 0 2
54596: ST_TO_ADDR
// p := [ ] ;
54597: LD_ADDR_VAR 0 11
54601: PUSH
54602: EMPTY
54603: ST_TO_ADDR
// if sort then
54604: LD_VAR 0 9
54608: IFFALSE 54724
// for i = 1 to 4 - eng do
54610: LD_ADDR_VAR 0 3
54614: PUSH
54615: DOUBLE
54616: LD_INT 1
54618: DEC
54619: ST_TO_ADDR
54620: LD_INT 4
54622: PUSH
54623: LD_VAR 0 6
54627: MINUS
54628: PUSH
54629: FOR_TO
54630: IFFALSE 54722
// begin if i = sort then
54632: LD_VAR 0 3
54636: PUSH
54637: LD_VAR 0 9
54641: EQUAL
54642: IFFALSE 54646
// break ;
54644: GO 54722
// if GetClass ( i ) = 2 then
54646: LD_VAR 0 3
54650: PPUSH
54651: CALL_OW 257
54655: PUSH
54656: LD_INT 2
54658: EQUAL
54659: IFFALSE 54663
// continue ;
54661: GO 54629
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54663: LD_ADDR_VAR 0 11
54667: PUSH
54668: LD_VAR 0 11
54672: PPUSH
54673: LD_VAR 0 11
54677: PUSH
54678: LD_INT 1
54680: PLUS
54681: PPUSH
54682: LD_VAR 0 9
54686: PUSH
54687: LD_VAR 0 3
54691: ARRAY
54692: PPUSH
54693: CALL_OW 2
54697: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54698: LD_ADDR_VAR 0 4
54702: PUSH
54703: LD_VAR 0 4
54707: PUSH
54708: LD_VAR 0 9
54712: PUSH
54713: LD_VAR 0 3
54717: ARRAY
54718: DIFF
54719: ST_TO_ADDR
// end ;
54720: GO 54629
54722: POP
54723: POP
// if p then
54724: LD_VAR 0 11
54728: IFFALSE 54753
// result := Replace ( result , 2 , p ) ;
54730: LD_ADDR_VAR 0 2
54734: PUSH
54735: LD_VAR 0 2
54739: PPUSH
54740: LD_INT 2
54742: PPUSH
54743: LD_VAR 0 11
54747: PPUSH
54748: CALL_OW 1
54752: ST_TO_ADDR
// end else
54753: GO 54799
// for i = eng downto 5 do
54755: LD_ADDR_VAR 0 3
54759: PUSH
54760: DOUBLE
54761: LD_VAR 0 6
54765: INC
54766: ST_TO_ADDR
54767: LD_INT 5
54769: PUSH
54770: FOR_DOWNTO
54771: IFFALSE 54797
// tmp := tmp union eng [ i ] ;
54773: LD_ADDR_VAR 0 4
54777: PUSH
54778: LD_VAR 0 4
54782: PUSH
54783: LD_VAR 0 6
54787: PUSH
54788: LD_VAR 0 3
54792: ARRAY
54793: UNION
54794: ST_TO_ADDR
54795: GO 54770
54797: POP
54798: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
54799: LD_ADDR_VAR 0 2
54803: PUSH
54804: LD_VAR 0 2
54808: PPUSH
54809: LD_INT 1
54811: PPUSH
54812: LD_VAR 0 4
54816: PUSH
54817: LD_VAR 0 5
54821: DIFF
54822: PPUSH
54823: CALL_OW 1
54827: ST_TO_ADDR
// exit ;
54828: GO 54830
// end ; end ;
54830: LD_VAR 0 2
54834: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
54835: LD_INT 0
54837: PPUSH
54838: PPUSH
54839: PPUSH
// if not mc_bases then
54840: LD_EXP 42
54844: NOT
54845: IFFALSE 54849
// exit ;
54847: GO 54955
// for i = 1 to mc_bases do
54849: LD_ADDR_VAR 0 2
54853: PUSH
54854: DOUBLE
54855: LD_INT 1
54857: DEC
54858: ST_TO_ADDR
54859: LD_EXP 42
54863: PUSH
54864: FOR_TO
54865: IFFALSE 54946
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
54867: LD_ADDR_VAR 0 3
54871: PUSH
54872: LD_EXP 42
54876: PUSH
54877: LD_VAR 0 2
54881: ARRAY
54882: PPUSH
54883: LD_INT 21
54885: PUSH
54886: LD_INT 3
54888: PUSH
54889: EMPTY
54890: LIST
54891: LIST
54892: PUSH
54893: LD_INT 3
54895: PUSH
54896: LD_INT 24
54898: PUSH
54899: LD_INT 1000
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: PUSH
54906: EMPTY
54907: LIST
54908: LIST
54909: PUSH
54910: EMPTY
54911: LIST
54912: LIST
54913: PPUSH
54914: CALL_OW 72
54918: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
54919: LD_ADDR_EXP 43
54923: PUSH
54924: LD_EXP 43
54928: PPUSH
54929: LD_VAR 0 2
54933: PPUSH
54934: LD_VAR 0 3
54938: PPUSH
54939: CALL_OW 1
54943: ST_TO_ADDR
// end ;
54944: GO 54864
54946: POP
54947: POP
// RaiseSailEvent ( 101 ) ;
54948: LD_INT 101
54950: PPUSH
54951: CALL_OW 427
// end ;
54955: LD_VAR 0 1
54959: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
54960: LD_INT 0
54962: PPUSH
54963: PPUSH
54964: PPUSH
54965: PPUSH
54966: PPUSH
54967: PPUSH
54968: PPUSH
// if not mc_bases then
54969: LD_EXP 42
54973: NOT
54974: IFFALSE 54978
// exit ;
54976: GO 55540
// for i = 1 to mc_bases do
54978: LD_ADDR_VAR 0 2
54982: PUSH
54983: DOUBLE
54984: LD_INT 1
54986: DEC
54987: ST_TO_ADDR
54988: LD_EXP 42
54992: PUSH
54993: FOR_TO
54994: IFFALSE 55531
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
54996: LD_ADDR_VAR 0 5
55000: PUSH
55001: LD_EXP 42
55005: PUSH
55006: LD_VAR 0 2
55010: ARRAY
55011: PUSH
55012: LD_EXP 71
55016: PUSH
55017: LD_VAR 0 2
55021: ARRAY
55022: UNION
55023: PPUSH
55024: LD_INT 21
55026: PUSH
55027: LD_INT 1
55029: PUSH
55030: EMPTY
55031: LIST
55032: LIST
55033: PUSH
55034: LD_INT 1
55036: PUSH
55037: LD_INT 3
55039: PUSH
55040: LD_INT 54
55042: PUSH
55043: EMPTY
55044: LIST
55045: PUSH
55046: EMPTY
55047: LIST
55048: LIST
55049: PUSH
55050: LD_INT 3
55052: PUSH
55053: LD_INT 24
55055: PUSH
55056: LD_INT 800
55058: PUSH
55059: EMPTY
55060: LIST
55061: LIST
55062: PUSH
55063: EMPTY
55064: LIST
55065: LIST
55066: PUSH
55067: EMPTY
55068: LIST
55069: LIST
55070: LIST
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: PPUSH
55076: CALL_OW 72
55080: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
55081: LD_ADDR_VAR 0 6
55085: PUSH
55086: LD_EXP 42
55090: PUSH
55091: LD_VAR 0 2
55095: ARRAY
55096: PPUSH
55097: LD_INT 21
55099: PUSH
55100: LD_INT 1
55102: PUSH
55103: EMPTY
55104: LIST
55105: LIST
55106: PUSH
55107: LD_INT 1
55109: PUSH
55110: LD_INT 3
55112: PUSH
55113: LD_INT 54
55115: PUSH
55116: EMPTY
55117: LIST
55118: PUSH
55119: EMPTY
55120: LIST
55121: LIST
55122: PUSH
55123: LD_INT 3
55125: PUSH
55126: LD_INT 24
55128: PUSH
55129: LD_INT 250
55131: PUSH
55132: EMPTY
55133: LIST
55134: LIST
55135: PUSH
55136: EMPTY
55137: LIST
55138: LIST
55139: PUSH
55140: EMPTY
55141: LIST
55142: LIST
55143: LIST
55144: PUSH
55145: EMPTY
55146: LIST
55147: LIST
55148: PPUSH
55149: CALL_OW 72
55153: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
55154: LD_ADDR_VAR 0 7
55158: PUSH
55159: LD_VAR 0 5
55163: PUSH
55164: LD_VAR 0 6
55168: DIFF
55169: ST_TO_ADDR
// if not need_heal_1 then
55170: LD_VAR 0 6
55174: NOT
55175: IFFALSE 55208
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
55177: LD_ADDR_EXP 45
55181: PUSH
55182: LD_EXP 45
55186: PPUSH
55187: LD_VAR 0 2
55191: PUSH
55192: LD_INT 1
55194: PUSH
55195: EMPTY
55196: LIST
55197: LIST
55198: PPUSH
55199: EMPTY
55200: PPUSH
55201: CALL 14332 0 3
55205: ST_TO_ADDR
55206: GO 55278
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
55208: LD_ADDR_EXP 45
55212: PUSH
55213: LD_EXP 45
55217: PPUSH
55218: LD_VAR 0 2
55222: PUSH
55223: LD_INT 1
55225: PUSH
55226: EMPTY
55227: LIST
55228: LIST
55229: PPUSH
55230: LD_EXP 45
55234: PUSH
55235: LD_VAR 0 2
55239: ARRAY
55240: PUSH
55241: LD_INT 1
55243: ARRAY
55244: PPUSH
55245: LD_INT 3
55247: PUSH
55248: LD_INT 24
55250: PUSH
55251: LD_INT 1000
55253: PUSH
55254: EMPTY
55255: LIST
55256: LIST
55257: PUSH
55258: EMPTY
55259: LIST
55260: LIST
55261: PPUSH
55262: CALL_OW 72
55266: PUSH
55267: LD_VAR 0 6
55271: UNION
55272: PPUSH
55273: CALL 14332 0 3
55277: ST_TO_ADDR
// if not need_heal_2 then
55278: LD_VAR 0 7
55282: NOT
55283: IFFALSE 55316
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
55285: LD_ADDR_EXP 45
55289: PUSH
55290: LD_EXP 45
55294: PPUSH
55295: LD_VAR 0 2
55299: PUSH
55300: LD_INT 2
55302: PUSH
55303: EMPTY
55304: LIST
55305: LIST
55306: PPUSH
55307: EMPTY
55308: PPUSH
55309: CALL 14332 0 3
55313: ST_TO_ADDR
55314: GO 55348
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
55316: LD_ADDR_EXP 45
55320: PUSH
55321: LD_EXP 45
55325: PPUSH
55326: LD_VAR 0 2
55330: PUSH
55331: LD_INT 2
55333: PUSH
55334: EMPTY
55335: LIST
55336: LIST
55337: PPUSH
55338: LD_VAR 0 7
55342: PPUSH
55343: CALL 14332 0 3
55347: ST_TO_ADDR
// if need_heal_2 then
55348: LD_VAR 0 7
55352: IFFALSE 55513
// for j in need_heal_2 do
55354: LD_ADDR_VAR 0 3
55358: PUSH
55359: LD_VAR 0 7
55363: PUSH
55364: FOR_IN
55365: IFFALSE 55511
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55367: LD_ADDR_VAR 0 5
55371: PUSH
55372: LD_EXP 42
55376: PUSH
55377: LD_VAR 0 2
55381: ARRAY
55382: PPUSH
55383: LD_INT 2
55385: PUSH
55386: LD_INT 30
55388: PUSH
55389: LD_INT 6
55391: PUSH
55392: EMPTY
55393: LIST
55394: LIST
55395: PUSH
55396: LD_INT 30
55398: PUSH
55399: LD_INT 7
55401: PUSH
55402: EMPTY
55403: LIST
55404: LIST
55405: PUSH
55406: LD_INT 30
55408: PUSH
55409: LD_INT 8
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: PUSH
55416: LD_INT 30
55418: PUSH
55419: LD_INT 0
55421: PUSH
55422: EMPTY
55423: LIST
55424: LIST
55425: PUSH
55426: LD_INT 30
55428: PUSH
55429: LD_INT 1
55431: PUSH
55432: EMPTY
55433: LIST
55434: LIST
55435: PUSH
55436: EMPTY
55437: LIST
55438: LIST
55439: LIST
55440: LIST
55441: LIST
55442: LIST
55443: PPUSH
55444: CALL_OW 72
55448: ST_TO_ADDR
// if tmp then
55449: LD_VAR 0 5
55453: IFFALSE 55509
// begin k := NearestUnitToUnit ( tmp , j ) ;
55455: LD_ADDR_VAR 0 4
55459: PUSH
55460: LD_VAR 0 5
55464: PPUSH
55465: LD_VAR 0 3
55469: PPUSH
55470: CALL_OW 74
55474: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
55475: LD_VAR 0 3
55479: PPUSH
55480: LD_VAR 0 4
55484: PPUSH
55485: CALL_OW 296
55489: PUSH
55490: LD_INT 5
55492: GREATER
55493: IFFALSE 55509
// ComMoveToNearbyEntrance ( j , k ) ;
55495: LD_VAR 0 3
55499: PPUSH
55500: LD_VAR 0 4
55504: PPUSH
55505: CALL 46198 0 2
// end ; end ;
55509: GO 55364
55511: POP
55512: POP
// if not need_heal_1 and not need_heal_2 then
55513: LD_VAR 0 6
55517: NOT
55518: PUSH
55519: LD_VAR 0 7
55523: NOT
55524: AND
55525: IFFALSE 55529
// continue ;
55527: GO 54993
// end ;
55529: GO 54993
55531: POP
55532: POP
// RaiseSailEvent ( 102 ) ;
55533: LD_INT 102
55535: PPUSH
55536: CALL_OW 427
// end ;
55540: LD_VAR 0 1
55544: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
55545: LD_INT 0
55547: PPUSH
55548: PPUSH
55549: PPUSH
55550: PPUSH
55551: PPUSH
55552: PPUSH
55553: PPUSH
55554: PPUSH
// if not mc_bases then
55555: LD_EXP 42
55559: NOT
55560: IFFALSE 55564
// exit ;
55562: GO 56425
// for i = 1 to mc_bases do
55564: LD_ADDR_VAR 0 2
55568: PUSH
55569: DOUBLE
55570: LD_INT 1
55572: DEC
55573: ST_TO_ADDR
55574: LD_EXP 42
55578: PUSH
55579: FOR_TO
55580: IFFALSE 56423
// begin if not mc_building_need_repair [ i ] then
55582: LD_EXP 43
55586: PUSH
55587: LD_VAR 0 2
55591: ARRAY
55592: NOT
55593: IFFALSE 55780
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
55595: LD_ADDR_VAR 0 6
55599: PUSH
55600: LD_EXP 61
55604: PUSH
55605: LD_VAR 0 2
55609: ARRAY
55610: PPUSH
55611: LD_INT 3
55613: PUSH
55614: LD_INT 24
55616: PUSH
55617: LD_INT 1000
55619: PUSH
55620: EMPTY
55621: LIST
55622: LIST
55623: PUSH
55624: EMPTY
55625: LIST
55626: LIST
55627: PUSH
55628: LD_INT 2
55630: PUSH
55631: LD_INT 34
55633: PUSH
55634: LD_INT 13
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: PUSH
55641: LD_INT 34
55643: PUSH
55644: LD_INT 52
55646: PUSH
55647: EMPTY
55648: LIST
55649: LIST
55650: PUSH
55651: LD_INT 34
55653: PUSH
55654: LD_EXP 91
55658: PUSH
55659: EMPTY
55660: LIST
55661: LIST
55662: PUSH
55663: EMPTY
55664: LIST
55665: LIST
55666: LIST
55667: LIST
55668: PUSH
55669: EMPTY
55670: LIST
55671: LIST
55672: PPUSH
55673: CALL_OW 72
55677: ST_TO_ADDR
// if cranes then
55678: LD_VAR 0 6
55682: IFFALSE 55744
// for j in cranes do
55684: LD_ADDR_VAR 0 3
55688: PUSH
55689: LD_VAR 0 6
55693: PUSH
55694: FOR_IN
55695: IFFALSE 55742
// if not IsInArea ( j , mc_parking [ i ] ) then
55697: LD_VAR 0 3
55701: PPUSH
55702: LD_EXP 66
55706: PUSH
55707: LD_VAR 0 2
55711: ARRAY
55712: PPUSH
55713: CALL_OW 308
55717: NOT
55718: IFFALSE 55740
// ComMoveToArea ( j , mc_parking [ i ] ) ;
55720: LD_VAR 0 3
55724: PPUSH
55725: LD_EXP 66
55729: PUSH
55730: LD_VAR 0 2
55734: ARRAY
55735: PPUSH
55736: CALL_OW 113
55740: GO 55694
55742: POP
55743: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
55744: LD_ADDR_EXP 44
55748: PUSH
55749: LD_EXP 44
55753: PPUSH
55754: LD_VAR 0 2
55758: PPUSH
55759: EMPTY
55760: PPUSH
55761: CALL_OW 1
55765: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
55766: LD_VAR 0 2
55770: PPUSH
55771: LD_INT 101
55773: PPUSH
55774: CALL 50668 0 2
// continue ;
55778: GO 55579
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
55780: LD_ADDR_EXP 48
55784: PUSH
55785: LD_EXP 48
55789: PPUSH
55790: LD_VAR 0 2
55794: PPUSH
55795: EMPTY
55796: PPUSH
55797: CALL_OW 1
55801: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
55802: LD_VAR 0 2
55806: PPUSH
55807: LD_INT 103
55809: PPUSH
55810: CALL 50668 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
55814: LD_ADDR_VAR 0 5
55818: PUSH
55819: LD_EXP 42
55823: PUSH
55824: LD_VAR 0 2
55828: ARRAY
55829: PUSH
55830: LD_EXP 71
55834: PUSH
55835: LD_VAR 0 2
55839: ARRAY
55840: UNION
55841: PPUSH
55842: LD_INT 2
55844: PUSH
55845: LD_INT 25
55847: PUSH
55848: LD_INT 2
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: PUSH
55855: LD_INT 25
55857: PUSH
55858: LD_INT 16
55860: PUSH
55861: EMPTY
55862: LIST
55863: LIST
55864: PUSH
55865: EMPTY
55866: LIST
55867: LIST
55868: LIST
55869: PUSH
55870: EMPTY
55871: LIST
55872: PPUSH
55873: CALL_OW 72
55877: PUSH
55878: LD_EXP 45
55882: PUSH
55883: LD_VAR 0 2
55887: ARRAY
55888: PUSH
55889: LD_INT 1
55891: ARRAY
55892: PUSH
55893: LD_EXP 45
55897: PUSH
55898: LD_VAR 0 2
55902: ARRAY
55903: PUSH
55904: LD_INT 2
55906: ARRAY
55907: UNION
55908: DIFF
55909: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
55910: LD_ADDR_VAR 0 6
55914: PUSH
55915: LD_EXP 61
55919: PUSH
55920: LD_VAR 0 2
55924: ARRAY
55925: PPUSH
55926: LD_INT 2
55928: PUSH
55929: LD_INT 34
55931: PUSH
55932: LD_INT 13
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: PUSH
55939: LD_INT 34
55941: PUSH
55942: LD_INT 52
55944: PUSH
55945: EMPTY
55946: LIST
55947: LIST
55948: PUSH
55949: LD_INT 34
55951: PUSH
55952: LD_EXP 91
55956: PUSH
55957: EMPTY
55958: LIST
55959: LIST
55960: PUSH
55961: EMPTY
55962: LIST
55963: LIST
55964: LIST
55965: LIST
55966: PPUSH
55967: CALL_OW 72
55971: ST_TO_ADDR
// if cranes then
55972: LD_VAR 0 6
55976: IFFALSE 56112
// begin for j in cranes do
55978: LD_ADDR_VAR 0 3
55982: PUSH
55983: LD_VAR 0 6
55987: PUSH
55988: FOR_IN
55989: IFFALSE 56110
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
55991: LD_VAR 0 3
55995: PPUSH
55996: CALL_OW 256
56000: PUSH
56001: LD_INT 1000
56003: EQUAL
56004: PUSH
56005: LD_VAR 0 3
56009: PPUSH
56010: CALL_OW 314
56014: NOT
56015: AND
56016: IFFALSE 56050
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
56018: LD_VAR 0 3
56022: PPUSH
56023: LD_EXP 43
56027: PUSH
56028: LD_VAR 0 2
56032: ARRAY
56033: PPUSH
56034: LD_VAR 0 3
56038: PPUSH
56039: CALL_OW 74
56043: PPUSH
56044: CALL_OW 130
56048: GO 56108
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
56050: LD_VAR 0 3
56054: PPUSH
56055: CALL_OW 256
56059: PUSH
56060: LD_INT 500
56062: LESS
56063: PUSH
56064: LD_VAR 0 3
56068: PPUSH
56069: LD_EXP 66
56073: PUSH
56074: LD_VAR 0 2
56078: ARRAY
56079: PPUSH
56080: CALL_OW 308
56084: NOT
56085: AND
56086: IFFALSE 56108
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56088: LD_VAR 0 3
56092: PPUSH
56093: LD_EXP 66
56097: PUSH
56098: LD_VAR 0 2
56102: ARRAY
56103: PPUSH
56104: CALL_OW 113
// end ;
56108: GO 55988
56110: POP
56111: POP
// end ; if tmp > 3 then
56112: LD_VAR 0 5
56116: PUSH
56117: LD_INT 3
56119: GREATER
56120: IFFALSE 56140
// tmp := ShrinkArray ( tmp , 4 ) ;
56122: LD_ADDR_VAR 0 5
56126: PUSH
56127: LD_VAR 0 5
56131: PPUSH
56132: LD_INT 4
56134: PPUSH
56135: CALL 45690 0 2
56139: ST_TO_ADDR
// if not tmp then
56140: LD_VAR 0 5
56144: NOT
56145: IFFALSE 56149
// continue ;
56147: GO 55579
// for j in tmp do
56149: LD_ADDR_VAR 0 3
56153: PUSH
56154: LD_VAR 0 5
56158: PUSH
56159: FOR_IN
56160: IFFALSE 56419
// begin if IsInUnit ( j ) then
56162: LD_VAR 0 3
56166: PPUSH
56167: CALL_OW 310
56171: IFFALSE 56182
// ComExitBuilding ( j ) ;
56173: LD_VAR 0 3
56177: PPUSH
56178: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
56182: LD_VAR 0 3
56186: PUSH
56187: LD_EXP 44
56191: PUSH
56192: LD_VAR 0 2
56196: ARRAY
56197: IN
56198: NOT
56199: IFFALSE 56257
// begin SetTag ( j , 101 ) ;
56201: LD_VAR 0 3
56205: PPUSH
56206: LD_INT 101
56208: PPUSH
56209: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
56213: LD_ADDR_EXP 44
56217: PUSH
56218: LD_EXP 44
56222: PPUSH
56223: LD_VAR 0 2
56227: PUSH
56228: LD_EXP 44
56232: PUSH
56233: LD_VAR 0 2
56237: ARRAY
56238: PUSH
56239: LD_INT 1
56241: PLUS
56242: PUSH
56243: EMPTY
56244: LIST
56245: LIST
56246: PPUSH
56247: LD_VAR 0 3
56251: PPUSH
56252: CALL 14332 0 3
56256: ST_TO_ADDR
// end ; wait ( 1 ) ;
56257: LD_INT 1
56259: PPUSH
56260: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
56264: LD_ADDR_VAR 0 7
56268: PUSH
56269: LD_EXP 43
56273: PUSH
56274: LD_VAR 0 2
56278: ARRAY
56279: ST_TO_ADDR
// if mc_scan [ i ] then
56280: LD_EXP 65
56284: PUSH
56285: LD_VAR 0 2
56289: ARRAY
56290: IFFALSE 56352
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
56292: LD_ADDR_VAR 0 7
56296: PUSH
56297: LD_EXP 43
56301: PUSH
56302: LD_VAR 0 2
56306: ARRAY
56307: PPUSH
56308: LD_INT 3
56310: PUSH
56311: LD_INT 30
56313: PUSH
56314: LD_INT 32
56316: PUSH
56317: EMPTY
56318: LIST
56319: LIST
56320: PUSH
56321: LD_INT 30
56323: PUSH
56324: LD_INT 33
56326: PUSH
56327: EMPTY
56328: LIST
56329: LIST
56330: PUSH
56331: LD_INT 30
56333: PUSH
56334: LD_INT 31
56336: PUSH
56337: EMPTY
56338: LIST
56339: LIST
56340: PUSH
56341: EMPTY
56342: LIST
56343: LIST
56344: LIST
56345: LIST
56346: PPUSH
56347: CALL_OW 72
56351: ST_TO_ADDR
// if not to_repair_tmp then
56352: LD_VAR 0 7
56356: NOT
56357: IFFALSE 56361
// continue ;
56359: GO 56159
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
56361: LD_ADDR_VAR 0 8
56365: PUSH
56366: LD_VAR 0 7
56370: PPUSH
56371: LD_VAR 0 3
56375: PPUSH
56376: CALL_OW 74
56380: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
56381: LD_VAR 0 8
56385: PPUSH
56386: LD_INT 16
56388: PPUSH
56389: CALL 16925 0 2
56393: PUSH
56394: LD_INT 4
56396: ARRAY
56397: PUSH
56398: LD_INT 10
56400: LESS
56401: IFFALSE 56417
// ComRepairBuilding ( j , to_repair ) ;
56403: LD_VAR 0 3
56407: PPUSH
56408: LD_VAR 0 8
56412: PPUSH
56413: CALL_OW 130
// end ;
56417: GO 56159
56419: POP
56420: POP
// end ;
56421: GO 55579
56423: POP
56424: POP
// end ;
56425: LD_VAR 0 1
56429: RET
// export function MC_Heal ; var i , j , tmp ; begin
56430: LD_INT 0
56432: PPUSH
56433: PPUSH
56434: PPUSH
56435: PPUSH
// if not mc_bases then
56436: LD_EXP 42
56440: NOT
56441: IFFALSE 56445
// exit ;
56443: GO 56847
// for i = 1 to mc_bases do
56445: LD_ADDR_VAR 0 2
56449: PUSH
56450: DOUBLE
56451: LD_INT 1
56453: DEC
56454: ST_TO_ADDR
56455: LD_EXP 42
56459: PUSH
56460: FOR_TO
56461: IFFALSE 56845
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
56463: LD_EXP 45
56467: PUSH
56468: LD_VAR 0 2
56472: ARRAY
56473: PUSH
56474: LD_INT 1
56476: ARRAY
56477: NOT
56478: PUSH
56479: LD_EXP 45
56483: PUSH
56484: LD_VAR 0 2
56488: ARRAY
56489: PUSH
56490: LD_INT 2
56492: ARRAY
56493: NOT
56494: AND
56495: IFFALSE 56533
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
56497: LD_ADDR_EXP 46
56501: PUSH
56502: LD_EXP 46
56506: PPUSH
56507: LD_VAR 0 2
56511: PPUSH
56512: EMPTY
56513: PPUSH
56514: CALL_OW 1
56518: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
56519: LD_VAR 0 2
56523: PPUSH
56524: LD_INT 102
56526: PPUSH
56527: CALL 50668 0 2
// continue ;
56531: GO 56460
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56533: LD_ADDR_VAR 0 4
56537: PUSH
56538: LD_EXP 42
56542: PUSH
56543: LD_VAR 0 2
56547: ARRAY
56548: PPUSH
56549: LD_INT 25
56551: PUSH
56552: LD_INT 4
56554: PUSH
56555: EMPTY
56556: LIST
56557: LIST
56558: PPUSH
56559: CALL_OW 72
56563: ST_TO_ADDR
// if not tmp then
56564: LD_VAR 0 4
56568: NOT
56569: IFFALSE 56573
// continue ;
56571: GO 56460
// if mc_taming [ i ] then
56573: LD_EXP 73
56577: PUSH
56578: LD_VAR 0 2
56582: ARRAY
56583: IFFALSE 56607
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56585: LD_ADDR_EXP 73
56589: PUSH
56590: LD_EXP 73
56594: PPUSH
56595: LD_VAR 0 2
56599: PPUSH
56600: EMPTY
56601: PPUSH
56602: CALL_OW 1
56606: ST_TO_ADDR
// for j in tmp do
56607: LD_ADDR_VAR 0 3
56611: PUSH
56612: LD_VAR 0 4
56616: PUSH
56617: FOR_IN
56618: IFFALSE 56841
// begin if IsInUnit ( j ) then
56620: LD_VAR 0 3
56624: PPUSH
56625: CALL_OW 310
56629: IFFALSE 56640
// ComExitBuilding ( j ) ;
56631: LD_VAR 0 3
56635: PPUSH
56636: CALL_OW 122
// if not j in mc_healers [ i ] then
56640: LD_VAR 0 3
56644: PUSH
56645: LD_EXP 46
56649: PUSH
56650: LD_VAR 0 2
56654: ARRAY
56655: IN
56656: NOT
56657: IFFALSE 56703
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
56659: LD_ADDR_EXP 46
56663: PUSH
56664: LD_EXP 46
56668: PPUSH
56669: LD_VAR 0 2
56673: PUSH
56674: LD_EXP 46
56678: PUSH
56679: LD_VAR 0 2
56683: ARRAY
56684: PUSH
56685: LD_INT 1
56687: PLUS
56688: PUSH
56689: EMPTY
56690: LIST
56691: LIST
56692: PPUSH
56693: LD_VAR 0 3
56697: PPUSH
56698: CALL 14332 0 3
56702: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
56703: LD_VAR 0 3
56707: PPUSH
56708: CALL_OW 110
56712: PUSH
56713: LD_INT 102
56715: NONEQUAL
56716: IFFALSE 56730
// SetTag ( j , 102 ) ;
56718: LD_VAR 0 3
56722: PPUSH
56723: LD_INT 102
56725: PPUSH
56726: CALL_OW 109
// Wait ( 3 ) ;
56730: LD_INT 3
56732: PPUSH
56733: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
56737: LD_EXP 45
56741: PUSH
56742: LD_VAR 0 2
56746: ARRAY
56747: PUSH
56748: LD_INT 1
56750: ARRAY
56751: IFFALSE 56783
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
56753: LD_VAR 0 3
56757: PPUSH
56758: LD_EXP 45
56762: PUSH
56763: LD_VAR 0 2
56767: ARRAY
56768: PUSH
56769: LD_INT 1
56771: ARRAY
56772: PUSH
56773: LD_INT 1
56775: ARRAY
56776: PPUSH
56777: CALL_OW 128
56781: GO 56839
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
56783: LD_VAR 0 3
56787: PPUSH
56788: CALL_OW 314
56792: NOT
56793: PUSH
56794: LD_EXP 45
56798: PUSH
56799: LD_VAR 0 2
56803: ARRAY
56804: PUSH
56805: LD_INT 2
56807: ARRAY
56808: AND
56809: IFFALSE 56839
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
56811: LD_VAR 0 3
56815: PPUSH
56816: LD_EXP 45
56820: PUSH
56821: LD_VAR 0 2
56825: ARRAY
56826: PUSH
56827: LD_INT 2
56829: ARRAY
56830: PUSH
56831: LD_INT 1
56833: ARRAY
56834: PPUSH
56835: CALL_OW 128
// end ;
56839: GO 56617
56841: POP
56842: POP
// end ;
56843: GO 56460
56845: POP
56846: POP
// end ;
56847: LD_VAR 0 1
56851: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
56852: LD_INT 0
56854: PPUSH
56855: PPUSH
56856: PPUSH
56857: PPUSH
56858: PPUSH
// if not mc_bases then
56859: LD_EXP 42
56863: NOT
56864: IFFALSE 56868
// exit ;
56866: GO 58011
// for i = 1 to mc_bases do
56868: LD_ADDR_VAR 0 2
56872: PUSH
56873: DOUBLE
56874: LD_INT 1
56876: DEC
56877: ST_TO_ADDR
56878: LD_EXP 42
56882: PUSH
56883: FOR_TO
56884: IFFALSE 58009
// begin if mc_scan [ i ] then
56886: LD_EXP 65
56890: PUSH
56891: LD_VAR 0 2
56895: ARRAY
56896: IFFALSE 56900
// continue ;
56898: GO 56883
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
56900: LD_EXP 47
56904: PUSH
56905: LD_VAR 0 2
56909: ARRAY
56910: NOT
56911: PUSH
56912: LD_EXP 49
56916: PUSH
56917: LD_VAR 0 2
56921: ARRAY
56922: NOT
56923: AND
56924: PUSH
56925: LD_EXP 48
56929: PUSH
56930: LD_VAR 0 2
56934: ARRAY
56935: AND
56936: IFFALSE 56974
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
56938: LD_ADDR_EXP 48
56942: PUSH
56943: LD_EXP 48
56947: PPUSH
56948: LD_VAR 0 2
56952: PPUSH
56953: EMPTY
56954: PPUSH
56955: CALL_OW 1
56959: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
56960: LD_VAR 0 2
56964: PPUSH
56965: LD_INT 103
56967: PPUSH
56968: CALL 50668 0 2
// continue ;
56972: GO 56883
// end ; if mc_construct_list [ i ] then
56974: LD_EXP 49
56978: PUSH
56979: LD_VAR 0 2
56983: ARRAY
56984: IFFALSE 57204
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
56986: LD_ADDR_VAR 0 4
56990: PUSH
56991: LD_EXP 42
56995: PUSH
56996: LD_VAR 0 2
57000: ARRAY
57001: PPUSH
57002: LD_INT 25
57004: PUSH
57005: LD_INT 2
57007: PUSH
57008: EMPTY
57009: LIST
57010: LIST
57011: PPUSH
57012: CALL_OW 72
57016: PUSH
57017: LD_EXP 44
57021: PUSH
57022: LD_VAR 0 2
57026: ARRAY
57027: DIFF
57028: ST_TO_ADDR
// if not tmp then
57029: LD_VAR 0 4
57033: NOT
57034: IFFALSE 57038
// continue ;
57036: GO 56883
// for j in tmp do
57038: LD_ADDR_VAR 0 3
57042: PUSH
57043: LD_VAR 0 4
57047: PUSH
57048: FOR_IN
57049: IFFALSE 57200
// begin if not mc_builders [ i ] then
57051: LD_EXP 48
57055: PUSH
57056: LD_VAR 0 2
57060: ARRAY
57061: NOT
57062: IFFALSE 57120
// begin SetTag ( j , 103 ) ;
57064: LD_VAR 0 3
57068: PPUSH
57069: LD_INT 103
57071: PPUSH
57072: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
57076: LD_ADDR_EXP 48
57080: PUSH
57081: LD_EXP 48
57085: PPUSH
57086: LD_VAR 0 2
57090: PUSH
57091: LD_EXP 48
57095: PUSH
57096: LD_VAR 0 2
57100: ARRAY
57101: PUSH
57102: LD_INT 1
57104: PLUS
57105: PUSH
57106: EMPTY
57107: LIST
57108: LIST
57109: PPUSH
57110: LD_VAR 0 3
57114: PPUSH
57115: CALL 14332 0 3
57119: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
57120: LD_VAR 0 3
57124: PPUSH
57125: CALL_OW 310
57129: IFFALSE 57140
// ComExitBuilding ( j ) ;
57131: LD_VAR 0 3
57135: PPUSH
57136: CALL_OW 122
// wait ( 3 ) ;
57140: LD_INT 3
57142: PPUSH
57143: CALL_OW 67
// if not mc_construct_list [ i ] then
57147: LD_EXP 49
57151: PUSH
57152: LD_VAR 0 2
57156: ARRAY
57157: NOT
57158: IFFALSE 57162
// break ;
57160: GO 57200
// if not HasTask ( j ) then
57162: LD_VAR 0 3
57166: PPUSH
57167: CALL_OW 314
57171: NOT
57172: IFFALSE 57198
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
57174: LD_VAR 0 3
57178: PPUSH
57179: LD_EXP 49
57183: PUSH
57184: LD_VAR 0 2
57188: ARRAY
57189: PUSH
57190: LD_INT 1
57192: ARRAY
57193: PPUSH
57194: CALL 17183 0 2
// end ;
57198: GO 57048
57200: POP
57201: POP
// end else
57202: GO 58007
// if mc_build_list [ i ] then
57204: LD_EXP 47
57208: PUSH
57209: LD_VAR 0 2
57213: ARRAY
57214: IFFALSE 58007
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57216: LD_ADDR_VAR 0 5
57220: PUSH
57221: LD_EXP 42
57225: PUSH
57226: LD_VAR 0 2
57230: ARRAY
57231: PPUSH
57232: LD_INT 2
57234: PUSH
57235: LD_INT 30
57237: PUSH
57238: LD_INT 0
57240: PUSH
57241: EMPTY
57242: LIST
57243: LIST
57244: PUSH
57245: LD_INT 30
57247: PUSH
57248: LD_INT 1
57250: PUSH
57251: EMPTY
57252: LIST
57253: LIST
57254: PUSH
57255: EMPTY
57256: LIST
57257: LIST
57258: LIST
57259: PPUSH
57260: CALL_OW 72
57264: ST_TO_ADDR
// if depot then
57265: LD_VAR 0 5
57269: IFFALSE 57287
// depot := depot [ 1 ] else
57271: LD_ADDR_VAR 0 5
57275: PUSH
57276: LD_VAR 0 5
57280: PUSH
57281: LD_INT 1
57283: ARRAY
57284: ST_TO_ADDR
57285: GO 57295
// depot := 0 ;
57287: LD_ADDR_VAR 0 5
57291: PUSH
57292: LD_INT 0
57294: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
57295: LD_EXP 47
57299: PUSH
57300: LD_VAR 0 2
57304: ARRAY
57305: PUSH
57306: LD_INT 1
57308: ARRAY
57309: PUSH
57310: LD_INT 1
57312: ARRAY
57313: PPUSH
57314: CALL 17013 0 1
57318: PUSH
57319: LD_EXP 42
57323: PUSH
57324: LD_VAR 0 2
57328: ARRAY
57329: PPUSH
57330: LD_INT 2
57332: PUSH
57333: LD_INT 30
57335: PUSH
57336: LD_INT 2
57338: PUSH
57339: EMPTY
57340: LIST
57341: LIST
57342: PUSH
57343: LD_INT 30
57345: PUSH
57346: LD_INT 3
57348: PUSH
57349: EMPTY
57350: LIST
57351: LIST
57352: PUSH
57353: EMPTY
57354: LIST
57355: LIST
57356: LIST
57357: PPUSH
57358: CALL_OW 72
57362: NOT
57363: AND
57364: IFFALSE 57469
// begin for j = 1 to mc_build_list [ i ] do
57366: LD_ADDR_VAR 0 3
57370: PUSH
57371: DOUBLE
57372: LD_INT 1
57374: DEC
57375: ST_TO_ADDR
57376: LD_EXP 47
57380: PUSH
57381: LD_VAR 0 2
57385: ARRAY
57386: PUSH
57387: FOR_TO
57388: IFFALSE 57467
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
57390: LD_EXP 47
57394: PUSH
57395: LD_VAR 0 2
57399: ARRAY
57400: PUSH
57401: LD_VAR 0 3
57405: ARRAY
57406: PUSH
57407: LD_INT 1
57409: ARRAY
57410: PUSH
57411: LD_INT 2
57413: EQUAL
57414: IFFALSE 57465
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
57416: LD_ADDR_EXP 47
57420: PUSH
57421: LD_EXP 47
57425: PPUSH
57426: LD_VAR 0 2
57430: PPUSH
57431: LD_EXP 47
57435: PUSH
57436: LD_VAR 0 2
57440: ARRAY
57441: PPUSH
57442: LD_VAR 0 3
57446: PPUSH
57447: LD_INT 1
57449: PPUSH
57450: LD_INT 0
57452: PPUSH
57453: CALL 13750 0 4
57457: PPUSH
57458: CALL_OW 1
57462: ST_TO_ADDR
// break ;
57463: GO 57467
// end ;
57465: GO 57387
57467: POP
57468: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
57469: LD_EXP 47
57473: PUSH
57474: LD_VAR 0 2
57478: ARRAY
57479: PUSH
57480: LD_INT 1
57482: ARRAY
57483: PUSH
57484: LD_INT 1
57486: ARRAY
57487: PUSH
57488: LD_INT 0
57490: EQUAL
57491: PUSH
57492: LD_VAR 0 5
57496: PUSH
57497: LD_VAR 0 5
57501: PPUSH
57502: LD_EXP 47
57506: PUSH
57507: LD_VAR 0 2
57511: ARRAY
57512: PUSH
57513: LD_INT 1
57515: ARRAY
57516: PUSH
57517: LD_INT 1
57519: ARRAY
57520: PPUSH
57521: LD_EXP 47
57525: PUSH
57526: LD_VAR 0 2
57530: ARRAY
57531: PUSH
57532: LD_INT 1
57534: ARRAY
57535: PUSH
57536: LD_INT 2
57538: ARRAY
57539: PPUSH
57540: LD_EXP 47
57544: PUSH
57545: LD_VAR 0 2
57549: ARRAY
57550: PUSH
57551: LD_INT 1
57553: ARRAY
57554: PUSH
57555: LD_INT 3
57557: ARRAY
57558: PPUSH
57559: LD_EXP 47
57563: PUSH
57564: LD_VAR 0 2
57568: ARRAY
57569: PUSH
57570: LD_INT 1
57572: ARRAY
57573: PUSH
57574: LD_INT 4
57576: ARRAY
57577: PPUSH
57578: CALL 21747 0 5
57582: AND
57583: OR
57584: IFFALSE 57865
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
57586: LD_ADDR_VAR 0 4
57590: PUSH
57591: LD_EXP 42
57595: PUSH
57596: LD_VAR 0 2
57600: ARRAY
57601: PPUSH
57602: LD_INT 25
57604: PUSH
57605: LD_INT 2
57607: PUSH
57608: EMPTY
57609: LIST
57610: LIST
57611: PPUSH
57612: CALL_OW 72
57616: PUSH
57617: LD_EXP 44
57621: PUSH
57622: LD_VAR 0 2
57626: ARRAY
57627: DIFF
57628: ST_TO_ADDR
// if not tmp then
57629: LD_VAR 0 4
57633: NOT
57634: IFFALSE 57638
// continue ;
57636: GO 56883
// for j in tmp do
57638: LD_ADDR_VAR 0 3
57642: PUSH
57643: LD_VAR 0 4
57647: PUSH
57648: FOR_IN
57649: IFFALSE 57861
// begin if not mc_builders [ i ] then
57651: LD_EXP 48
57655: PUSH
57656: LD_VAR 0 2
57660: ARRAY
57661: NOT
57662: IFFALSE 57720
// begin SetTag ( j , 103 ) ;
57664: LD_VAR 0 3
57668: PPUSH
57669: LD_INT 103
57671: PPUSH
57672: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
57676: LD_ADDR_EXP 48
57680: PUSH
57681: LD_EXP 48
57685: PPUSH
57686: LD_VAR 0 2
57690: PUSH
57691: LD_EXP 48
57695: PUSH
57696: LD_VAR 0 2
57700: ARRAY
57701: PUSH
57702: LD_INT 1
57704: PLUS
57705: PUSH
57706: EMPTY
57707: LIST
57708: LIST
57709: PPUSH
57710: LD_VAR 0 3
57714: PPUSH
57715: CALL 14332 0 3
57719: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
57720: LD_VAR 0 3
57724: PPUSH
57725: CALL_OW 310
57729: IFFALSE 57740
// ComExitBuilding ( j ) ;
57731: LD_VAR 0 3
57735: PPUSH
57736: CALL_OW 122
// wait ( 3 ) ;
57740: LD_INT 3
57742: PPUSH
57743: CALL_OW 67
// if not mc_build_list [ i ] then
57747: LD_EXP 47
57751: PUSH
57752: LD_VAR 0 2
57756: ARRAY
57757: NOT
57758: IFFALSE 57762
// break ;
57760: GO 57861
// if not HasTask ( j ) then
57762: LD_VAR 0 3
57766: PPUSH
57767: CALL_OW 314
57771: NOT
57772: IFFALSE 57859
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
57774: LD_VAR 0 3
57778: PPUSH
57779: LD_EXP 47
57783: PUSH
57784: LD_VAR 0 2
57788: ARRAY
57789: PUSH
57790: LD_INT 1
57792: ARRAY
57793: PUSH
57794: LD_INT 1
57796: ARRAY
57797: PPUSH
57798: LD_EXP 47
57802: PUSH
57803: LD_VAR 0 2
57807: ARRAY
57808: PUSH
57809: LD_INT 1
57811: ARRAY
57812: PUSH
57813: LD_INT 2
57815: ARRAY
57816: PPUSH
57817: LD_EXP 47
57821: PUSH
57822: LD_VAR 0 2
57826: ARRAY
57827: PUSH
57828: LD_INT 1
57830: ARRAY
57831: PUSH
57832: LD_INT 3
57834: ARRAY
57835: PPUSH
57836: LD_EXP 47
57840: PUSH
57841: LD_VAR 0 2
57845: ARRAY
57846: PUSH
57847: LD_INT 1
57849: ARRAY
57850: PUSH
57851: LD_INT 4
57853: ARRAY
57854: PPUSH
57855: CALL_OW 145
// end ;
57859: GO 57648
57861: POP
57862: POP
// end else
57863: GO 58007
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
57865: LD_EXP 42
57869: PUSH
57870: LD_VAR 0 2
57874: ARRAY
57875: PPUSH
57876: LD_EXP 47
57880: PUSH
57881: LD_VAR 0 2
57885: ARRAY
57886: PUSH
57887: LD_INT 1
57889: ARRAY
57890: PUSH
57891: LD_INT 1
57893: ARRAY
57894: PPUSH
57895: LD_EXP 47
57899: PUSH
57900: LD_VAR 0 2
57904: ARRAY
57905: PUSH
57906: LD_INT 1
57908: ARRAY
57909: PUSH
57910: LD_INT 2
57912: ARRAY
57913: PPUSH
57914: LD_EXP 47
57918: PUSH
57919: LD_VAR 0 2
57923: ARRAY
57924: PUSH
57925: LD_INT 1
57927: ARRAY
57928: PUSH
57929: LD_INT 3
57931: ARRAY
57932: PPUSH
57933: LD_EXP 47
57937: PUSH
57938: LD_VAR 0 2
57942: ARRAY
57943: PUSH
57944: LD_INT 1
57946: ARRAY
57947: PUSH
57948: LD_INT 4
57950: ARRAY
57951: PPUSH
57952: CALL 21083 0 5
57956: NOT
57957: IFFALSE 58007
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
57959: LD_ADDR_EXP 47
57963: PUSH
57964: LD_EXP 47
57968: PPUSH
57969: LD_VAR 0 2
57973: PPUSH
57974: LD_EXP 47
57978: PUSH
57979: LD_VAR 0 2
57983: ARRAY
57984: PPUSH
57985: LD_INT 1
57987: PPUSH
57988: LD_INT 1
57990: NEG
57991: PPUSH
57992: LD_INT 0
57994: PPUSH
57995: CALL 13750 0 4
57999: PPUSH
58000: CALL_OW 1
58004: ST_TO_ADDR
// continue ;
58005: GO 56883
// end ; end ; end ;
58007: GO 56883
58009: POP
58010: POP
// end ;
58011: LD_VAR 0 1
58015: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
58016: LD_INT 0
58018: PPUSH
58019: PPUSH
58020: PPUSH
58021: PPUSH
58022: PPUSH
58023: PPUSH
// if not mc_bases then
58024: LD_EXP 42
58028: NOT
58029: IFFALSE 58033
// exit ;
58031: GO 58460
// for i = 1 to mc_bases do
58033: LD_ADDR_VAR 0 2
58037: PUSH
58038: DOUBLE
58039: LD_INT 1
58041: DEC
58042: ST_TO_ADDR
58043: LD_EXP 42
58047: PUSH
58048: FOR_TO
58049: IFFALSE 58458
// begin tmp := mc_build_upgrade [ i ] ;
58051: LD_ADDR_VAR 0 4
58055: PUSH
58056: LD_EXP 74
58060: PUSH
58061: LD_VAR 0 2
58065: ARRAY
58066: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
58067: LD_ADDR_VAR 0 6
58071: PUSH
58072: LD_EXP 75
58076: PUSH
58077: LD_VAR 0 2
58081: ARRAY
58082: PPUSH
58083: LD_INT 2
58085: PUSH
58086: LD_INT 30
58088: PUSH
58089: LD_INT 6
58091: PUSH
58092: EMPTY
58093: LIST
58094: LIST
58095: PUSH
58096: LD_INT 30
58098: PUSH
58099: LD_INT 7
58101: PUSH
58102: EMPTY
58103: LIST
58104: LIST
58105: PUSH
58106: EMPTY
58107: LIST
58108: LIST
58109: LIST
58110: PPUSH
58111: CALL_OW 72
58115: ST_TO_ADDR
// if not tmp and not lab then
58116: LD_VAR 0 4
58120: NOT
58121: PUSH
58122: LD_VAR 0 6
58126: NOT
58127: AND
58128: IFFALSE 58132
// continue ;
58130: GO 58048
// if tmp then
58132: LD_VAR 0 4
58136: IFFALSE 58256
// for j in tmp do
58138: LD_ADDR_VAR 0 3
58142: PUSH
58143: LD_VAR 0 4
58147: PUSH
58148: FOR_IN
58149: IFFALSE 58254
// begin if UpgradeCost ( j ) then
58151: LD_VAR 0 3
58155: PPUSH
58156: CALL 20743 0 1
58160: IFFALSE 58252
// begin ComUpgrade ( j ) ;
58162: LD_VAR 0 3
58166: PPUSH
58167: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
58171: LD_ADDR_EXP 74
58175: PUSH
58176: LD_EXP 74
58180: PPUSH
58181: LD_VAR 0 2
58185: PPUSH
58186: LD_EXP 74
58190: PUSH
58191: LD_VAR 0 2
58195: ARRAY
58196: PUSH
58197: LD_VAR 0 3
58201: DIFF
58202: PPUSH
58203: CALL_OW 1
58207: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58208: LD_ADDR_EXP 49
58212: PUSH
58213: LD_EXP 49
58217: PPUSH
58218: LD_VAR 0 2
58222: PUSH
58223: LD_EXP 49
58227: PUSH
58228: LD_VAR 0 2
58232: ARRAY
58233: PUSH
58234: LD_INT 1
58236: PLUS
58237: PUSH
58238: EMPTY
58239: LIST
58240: LIST
58241: PPUSH
58242: LD_VAR 0 3
58246: PPUSH
58247: CALL 14332 0 3
58251: ST_TO_ADDR
// end ; end ;
58252: GO 58148
58254: POP
58255: POP
// if not lab or not mc_lab_upgrade [ i ] then
58256: LD_VAR 0 6
58260: NOT
58261: PUSH
58262: LD_EXP 76
58266: PUSH
58267: LD_VAR 0 2
58271: ARRAY
58272: NOT
58273: OR
58274: IFFALSE 58278
// continue ;
58276: GO 58048
// for j in lab do
58278: LD_ADDR_VAR 0 3
58282: PUSH
58283: LD_VAR 0 6
58287: PUSH
58288: FOR_IN
58289: IFFALSE 58454
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
58291: LD_VAR 0 3
58295: PPUSH
58296: CALL_OW 266
58300: PUSH
58301: LD_INT 6
58303: PUSH
58304: LD_INT 7
58306: PUSH
58307: EMPTY
58308: LIST
58309: LIST
58310: IN
58311: PUSH
58312: LD_VAR 0 3
58316: PPUSH
58317: CALL_OW 461
58321: PUSH
58322: LD_INT 1
58324: NONEQUAL
58325: AND
58326: IFFALSE 58452
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
58328: LD_VAR 0 3
58332: PPUSH
58333: LD_EXP 76
58337: PUSH
58338: LD_VAR 0 2
58342: ARRAY
58343: PUSH
58344: LD_INT 1
58346: ARRAY
58347: PPUSH
58348: CALL 20948 0 2
58352: IFFALSE 58452
// begin ComCancel ( j ) ;
58354: LD_VAR 0 3
58358: PPUSH
58359: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
58363: LD_VAR 0 3
58367: PPUSH
58368: LD_EXP 76
58372: PUSH
58373: LD_VAR 0 2
58377: ARRAY
58378: PUSH
58379: LD_INT 1
58381: ARRAY
58382: PPUSH
58383: CALL_OW 207
// if not j in mc_construct_list [ i ] then
58387: LD_VAR 0 3
58391: PUSH
58392: LD_EXP 49
58396: PUSH
58397: LD_VAR 0 2
58401: ARRAY
58402: IN
58403: NOT
58404: IFFALSE 58450
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58406: LD_ADDR_EXP 49
58410: PUSH
58411: LD_EXP 49
58415: PPUSH
58416: LD_VAR 0 2
58420: PUSH
58421: LD_EXP 49
58425: PUSH
58426: LD_VAR 0 2
58430: ARRAY
58431: PUSH
58432: LD_INT 1
58434: PLUS
58435: PUSH
58436: EMPTY
58437: LIST
58438: LIST
58439: PPUSH
58440: LD_VAR 0 3
58444: PPUSH
58445: CALL 14332 0 3
58449: ST_TO_ADDR
// break ;
58450: GO 58454
// end ; end ; end ;
58452: GO 58288
58454: POP
58455: POP
// end ;
58456: GO 58048
58458: POP
58459: POP
// end ;
58460: LD_VAR 0 1
58464: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
58465: LD_INT 0
58467: PPUSH
58468: PPUSH
58469: PPUSH
58470: PPUSH
58471: PPUSH
58472: PPUSH
58473: PPUSH
58474: PPUSH
58475: PPUSH
// if not mc_bases then
58476: LD_EXP 42
58480: NOT
58481: IFFALSE 58485
// exit ;
58483: GO 58890
// for i = 1 to mc_bases do
58485: LD_ADDR_VAR 0 2
58489: PUSH
58490: DOUBLE
58491: LD_INT 1
58493: DEC
58494: ST_TO_ADDR
58495: LD_EXP 42
58499: PUSH
58500: FOR_TO
58501: IFFALSE 58888
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
58503: LD_EXP 50
58507: PUSH
58508: LD_VAR 0 2
58512: ARRAY
58513: NOT
58514: PUSH
58515: LD_EXP 42
58519: PUSH
58520: LD_VAR 0 2
58524: ARRAY
58525: PPUSH
58526: LD_INT 30
58528: PUSH
58529: LD_INT 3
58531: PUSH
58532: EMPTY
58533: LIST
58534: LIST
58535: PPUSH
58536: CALL_OW 72
58540: NOT
58541: OR
58542: IFFALSE 58546
// continue ;
58544: GO 58500
// busy := false ;
58546: LD_ADDR_VAR 0 8
58550: PUSH
58551: LD_INT 0
58553: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58554: LD_ADDR_VAR 0 4
58558: PUSH
58559: LD_EXP 42
58563: PUSH
58564: LD_VAR 0 2
58568: ARRAY
58569: PPUSH
58570: LD_INT 30
58572: PUSH
58573: LD_INT 3
58575: PUSH
58576: EMPTY
58577: LIST
58578: LIST
58579: PPUSH
58580: CALL_OW 72
58584: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
58585: LD_ADDR_VAR 0 6
58589: PUSH
58590: LD_EXP 50
58594: PUSH
58595: LD_VAR 0 2
58599: ARRAY
58600: PPUSH
58601: LD_INT 2
58603: PUSH
58604: LD_INT 30
58606: PUSH
58607: LD_INT 32
58609: PUSH
58610: EMPTY
58611: LIST
58612: LIST
58613: PUSH
58614: LD_INT 30
58616: PUSH
58617: LD_INT 33
58619: PUSH
58620: EMPTY
58621: LIST
58622: LIST
58623: PUSH
58624: EMPTY
58625: LIST
58626: LIST
58627: LIST
58628: PPUSH
58629: CALL_OW 72
58633: ST_TO_ADDR
// if not t then
58634: LD_VAR 0 6
58638: NOT
58639: IFFALSE 58643
// continue ;
58641: GO 58500
// for j in tmp do
58643: LD_ADDR_VAR 0 3
58647: PUSH
58648: LD_VAR 0 4
58652: PUSH
58653: FOR_IN
58654: IFFALSE 58684
// if not BuildingStatus ( j ) = bs_idle then
58656: LD_VAR 0 3
58660: PPUSH
58661: CALL_OW 461
58665: PUSH
58666: LD_INT 2
58668: EQUAL
58669: NOT
58670: IFFALSE 58682
// begin busy := true ;
58672: LD_ADDR_VAR 0 8
58676: PUSH
58677: LD_INT 1
58679: ST_TO_ADDR
// break ;
58680: GO 58684
// end ;
58682: GO 58653
58684: POP
58685: POP
// if busy then
58686: LD_VAR 0 8
58690: IFFALSE 58694
// continue ;
58692: GO 58500
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
58694: LD_ADDR_VAR 0 7
58698: PUSH
58699: LD_VAR 0 6
58703: PPUSH
58704: LD_INT 35
58706: PUSH
58707: LD_INT 0
58709: PUSH
58710: EMPTY
58711: LIST
58712: LIST
58713: PPUSH
58714: CALL_OW 72
58718: ST_TO_ADDR
// if tw then
58719: LD_VAR 0 7
58723: IFFALSE 58800
// begin tw := tw [ 1 ] ;
58725: LD_ADDR_VAR 0 7
58729: PUSH
58730: LD_VAR 0 7
58734: PUSH
58735: LD_INT 1
58737: ARRAY
58738: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
58739: LD_ADDR_VAR 0 9
58743: PUSH
58744: LD_VAR 0 7
58748: PPUSH
58749: LD_EXP 67
58753: PUSH
58754: LD_VAR 0 2
58758: ARRAY
58759: PPUSH
58760: CALL 19302 0 2
58764: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
58765: LD_EXP 81
58769: PUSH
58770: LD_VAR 0 2
58774: ARRAY
58775: IFFALSE 58798
// if not weapon in mc_allowed_tower_weapons [ i ] then
58777: LD_VAR 0 9
58781: PUSH
58782: LD_EXP 81
58786: PUSH
58787: LD_VAR 0 2
58791: ARRAY
58792: IN
58793: NOT
58794: IFFALSE 58798
// continue ;
58796: GO 58500
// end else
58798: GO 58863
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
58800: LD_ADDR_VAR 0 5
58804: PUSH
58805: LD_EXP 50
58809: PUSH
58810: LD_VAR 0 2
58814: ARRAY
58815: PPUSH
58816: LD_VAR 0 4
58820: PPUSH
58821: CALL 44923 0 2
58825: ST_TO_ADDR
// if not tmp2 then
58826: LD_VAR 0 5
58830: NOT
58831: IFFALSE 58835
// continue ;
58833: GO 58500
// tw := tmp2 [ 1 ] ;
58835: LD_ADDR_VAR 0 7
58839: PUSH
58840: LD_VAR 0 5
58844: PUSH
58845: LD_INT 1
58847: ARRAY
58848: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
58849: LD_ADDR_VAR 0 9
58853: PUSH
58854: LD_VAR 0 5
58858: PUSH
58859: LD_INT 2
58861: ARRAY
58862: ST_TO_ADDR
// end ; if not weapon then
58863: LD_VAR 0 9
58867: NOT
58868: IFFALSE 58872
// continue ;
58870: GO 58500
// ComPlaceWeapon ( tw , weapon ) ;
58872: LD_VAR 0 7
58876: PPUSH
58877: LD_VAR 0 9
58881: PPUSH
58882: CALL_OW 148
// end ;
58886: GO 58500
58888: POP
58889: POP
// end ;
58890: LD_VAR 0 1
58894: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
58895: LD_INT 0
58897: PPUSH
58898: PPUSH
58899: PPUSH
58900: PPUSH
58901: PPUSH
58902: PPUSH
// if not mc_bases then
58903: LD_EXP 42
58907: NOT
58908: IFFALSE 58912
// exit ;
58910: GO 59688
// for i = 1 to mc_bases do
58912: LD_ADDR_VAR 0 2
58916: PUSH
58917: DOUBLE
58918: LD_INT 1
58920: DEC
58921: ST_TO_ADDR
58922: LD_EXP 42
58926: PUSH
58927: FOR_TO
58928: IFFALSE 59686
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
58930: LD_EXP 55
58934: PUSH
58935: LD_VAR 0 2
58939: ARRAY
58940: NOT
58941: PUSH
58942: LD_EXP 55
58946: PUSH
58947: LD_VAR 0 2
58951: ARRAY
58952: PUSH
58953: LD_EXP 56
58957: PUSH
58958: LD_VAR 0 2
58962: ARRAY
58963: EQUAL
58964: OR
58965: PUSH
58966: LD_EXP 65
58970: PUSH
58971: LD_VAR 0 2
58975: ARRAY
58976: OR
58977: IFFALSE 58981
// continue ;
58979: GO 58927
// if mc_miners [ i ] then
58981: LD_EXP 56
58985: PUSH
58986: LD_VAR 0 2
58990: ARRAY
58991: IFFALSE 59373
// begin for j = mc_miners [ i ] downto 1 do
58993: LD_ADDR_VAR 0 3
58997: PUSH
58998: DOUBLE
58999: LD_EXP 56
59003: PUSH
59004: LD_VAR 0 2
59008: ARRAY
59009: INC
59010: ST_TO_ADDR
59011: LD_INT 1
59013: PUSH
59014: FOR_DOWNTO
59015: IFFALSE 59371
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
59017: LD_EXP 56
59021: PUSH
59022: LD_VAR 0 2
59026: ARRAY
59027: PUSH
59028: LD_VAR 0 3
59032: ARRAY
59033: PPUSH
59034: CALL_OW 301
59038: PUSH
59039: LD_EXP 56
59043: PUSH
59044: LD_VAR 0 2
59048: ARRAY
59049: PUSH
59050: LD_VAR 0 3
59054: ARRAY
59055: PPUSH
59056: CALL_OW 257
59060: PUSH
59061: LD_INT 1
59063: NONEQUAL
59064: OR
59065: IFFALSE 59128
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
59067: LD_ADDR_VAR 0 5
59071: PUSH
59072: LD_EXP 56
59076: PUSH
59077: LD_VAR 0 2
59081: ARRAY
59082: PUSH
59083: LD_EXP 56
59087: PUSH
59088: LD_VAR 0 2
59092: ARRAY
59093: PUSH
59094: LD_VAR 0 3
59098: ARRAY
59099: DIFF
59100: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
59101: LD_ADDR_EXP 56
59105: PUSH
59106: LD_EXP 56
59110: PPUSH
59111: LD_VAR 0 2
59115: PPUSH
59116: LD_VAR 0 5
59120: PPUSH
59121: CALL_OW 1
59125: ST_TO_ADDR
// continue ;
59126: GO 59014
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
59128: LD_EXP 56
59132: PUSH
59133: LD_VAR 0 2
59137: ARRAY
59138: PUSH
59139: LD_VAR 0 3
59143: ARRAY
59144: PPUSH
59145: CALL_OW 257
59149: PUSH
59150: LD_INT 1
59152: EQUAL
59153: PUSH
59154: LD_EXP 56
59158: PUSH
59159: LD_VAR 0 2
59163: ARRAY
59164: PUSH
59165: LD_VAR 0 3
59169: ARRAY
59170: PPUSH
59171: CALL_OW 459
59175: NOT
59176: AND
59177: PUSH
59178: LD_EXP 56
59182: PUSH
59183: LD_VAR 0 2
59187: ARRAY
59188: PUSH
59189: LD_VAR 0 3
59193: ARRAY
59194: PPUSH
59195: CALL_OW 314
59199: NOT
59200: AND
59201: IFFALSE 59369
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
59203: LD_EXP 56
59207: PUSH
59208: LD_VAR 0 2
59212: ARRAY
59213: PUSH
59214: LD_VAR 0 3
59218: ARRAY
59219: PPUSH
59220: CALL_OW 310
59224: IFFALSE 59247
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
59226: LD_EXP 56
59230: PUSH
59231: LD_VAR 0 2
59235: ARRAY
59236: PUSH
59237: LD_VAR 0 3
59241: ARRAY
59242: PPUSH
59243: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
59247: LD_EXP 56
59251: PUSH
59252: LD_VAR 0 2
59256: ARRAY
59257: PUSH
59258: LD_VAR 0 3
59262: ARRAY
59263: PPUSH
59264: CALL_OW 314
59268: NOT
59269: IFFALSE 59369
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
59271: LD_EXP 56
59275: PUSH
59276: LD_VAR 0 2
59280: ARRAY
59281: PUSH
59282: LD_VAR 0 3
59286: ARRAY
59287: PPUSH
59288: LD_EXP 55
59292: PUSH
59293: LD_VAR 0 2
59297: ARRAY
59298: PUSH
59299: LD_VAR 0 3
59303: PUSH
59304: LD_EXP 55
59308: PUSH
59309: LD_VAR 0 2
59313: ARRAY
59314: MOD
59315: PUSH
59316: LD_INT 1
59318: PLUS
59319: ARRAY
59320: PUSH
59321: LD_INT 1
59323: ARRAY
59324: PPUSH
59325: LD_EXP 55
59329: PUSH
59330: LD_VAR 0 2
59334: ARRAY
59335: PUSH
59336: LD_VAR 0 3
59340: PUSH
59341: LD_EXP 55
59345: PUSH
59346: LD_VAR 0 2
59350: ARRAY
59351: MOD
59352: PUSH
59353: LD_INT 1
59355: PLUS
59356: ARRAY
59357: PUSH
59358: LD_INT 2
59360: ARRAY
59361: PPUSH
59362: LD_INT 0
59364: PPUSH
59365: CALL_OW 193
// end ; end ;
59369: GO 59014
59371: POP
59372: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
59373: LD_ADDR_VAR 0 5
59377: PUSH
59378: LD_EXP 42
59382: PUSH
59383: LD_VAR 0 2
59387: ARRAY
59388: PPUSH
59389: LD_INT 2
59391: PUSH
59392: LD_INT 30
59394: PUSH
59395: LD_INT 4
59397: PUSH
59398: EMPTY
59399: LIST
59400: LIST
59401: PUSH
59402: LD_INT 30
59404: PUSH
59405: LD_INT 5
59407: PUSH
59408: EMPTY
59409: LIST
59410: LIST
59411: PUSH
59412: LD_INT 30
59414: PUSH
59415: LD_INT 32
59417: PUSH
59418: EMPTY
59419: LIST
59420: LIST
59421: PUSH
59422: EMPTY
59423: LIST
59424: LIST
59425: LIST
59426: LIST
59427: PPUSH
59428: CALL_OW 72
59432: ST_TO_ADDR
// if not tmp then
59433: LD_VAR 0 5
59437: NOT
59438: IFFALSE 59442
// continue ;
59440: GO 58927
// list := [ ] ;
59442: LD_ADDR_VAR 0 6
59446: PUSH
59447: EMPTY
59448: ST_TO_ADDR
// for j in tmp do
59449: LD_ADDR_VAR 0 3
59453: PUSH
59454: LD_VAR 0 5
59458: PUSH
59459: FOR_IN
59460: IFFALSE 59529
// begin for k in UnitsInside ( j ) do
59462: LD_ADDR_VAR 0 4
59466: PUSH
59467: LD_VAR 0 3
59471: PPUSH
59472: CALL_OW 313
59476: PUSH
59477: FOR_IN
59478: IFFALSE 59525
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
59480: LD_VAR 0 4
59484: PPUSH
59485: CALL_OW 257
59489: PUSH
59490: LD_INT 1
59492: EQUAL
59493: PUSH
59494: LD_VAR 0 4
59498: PPUSH
59499: CALL_OW 459
59503: NOT
59504: AND
59505: IFFALSE 59523
// list := list ^ k ;
59507: LD_ADDR_VAR 0 6
59511: PUSH
59512: LD_VAR 0 6
59516: PUSH
59517: LD_VAR 0 4
59521: ADD
59522: ST_TO_ADDR
59523: GO 59477
59525: POP
59526: POP
// end ;
59527: GO 59459
59529: POP
59530: POP
// list := list diff mc_miners [ i ] ;
59531: LD_ADDR_VAR 0 6
59535: PUSH
59536: LD_VAR 0 6
59540: PUSH
59541: LD_EXP 56
59545: PUSH
59546: LD_VAR 0 2
59550: ARRAY
59551: DIFF
59552: ST_TO_ADDR
// if not list then
59553: LD_VAR 0 6
59557: NOT
59558: IFFALSE 59562
// continue ;
59560: GO 58927
// k := mc_mines [ i ] - mc_miners [ i ] ;
59562: LD_ADDR_VAR 0 4
59566: PUSH
59567: LD_EXP 55
59571: PUSH
59572: LD_VAR 0 2
59576: ARRAY
59577: PUSH
59578: LD_EXP 56
59582: PUSH
59583: LD_VAR 0 2
59587: ARRAY
59588: MINUS
59589: ST_TO_ADDR
// if k > list then
59590: LD_VAR 0 4
59594: PUSH
59595: LD_VAR 0 6
59599: GREATER
59600: IFFALSE 59612
// k := list ;
59602: LD_ADDR_VAR 0 4
59606: PUSH
59607: LD_VAR 0 6
59611: ST_TO_ADDR
// for j = 1 to k do
59612: LD_ADDR_VAR 0 3
59616: PUSH
59617: DOUBLE
59618: LD_INT 1
59620: DEC
59621: ST_TO_ADDR
59622: LD_VAR 0 4
59626: PUSH
59627: FOR_TO
59628: IFFALSE 59682
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
59630: LD_ADDR_EXP 56
59634: PUSH
59635: LD_EXP 56
59639: PPUSH
59640: LD_VAR 0 2
59644: PUSH
59645: LD_EXP 56
59649: PUSH
59650: LD_VAR 0 2
59654: ARRAY
59655: PUSH
59656: LD_INT 1
59658: PLUS
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: PPUSH
59664: LD_VAR 0 6
59668: PUSH
59669: LD_VAR 0 3
59673: ARRAY
59674: PPUSH
59675: CALL 14332 0 3
59679: ST_TO_ADDR
59680: GO 59627
59682: POP
59683: POP
// end ;
59684: GO 58927
59686: POP
59687: POP
// end ;
59688: LD_VAR 0 1
59692: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
59693: LD_INT 0
59695: PPUSH
59696: PPUSH
59697: PPUSH
59698: PPUSH
59699: PPUSH
59700: PPUSH
59701: PPUSH
59702: PPUSH
59703: PPUSH
59704: PPUSH
// if not mc_bases then
59705: LD_EXP 42
59709: NOT
59710: IFFALSE 59714
// exit ;
59712: GO 61464
// for i = 1 to mc_bases do
59714: LD_ADDR_VAR 0 2
59718: PUSH
59719: DOUBLE
59720: LD_INT 1
59722: DEC
59723: ST_TO_ADDR
59724: LD_EXP 42
59728: PUSH
59729: FOR_TO
59730: IFFALSE 61462
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
59732: LD_EXP 42
59736: PUSH
59737: LD_VAR 0 2
59741: ARRAY
59742: NOT
59743: PUSH
59744: LD_EXP 49
59748: PUSH
59749: LD_VAR 0 2
59753: ARRAY
59754: OR
59755: IFFALSE 59759
// continue ;
59757: GO 59729
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
59759: LD_EXP 58
59763: PUSH
59764: LD_VAR 0 2
59768: ARRAY
59769: NOT
59770: PUSH
59771: LD_EXP 59
59775: PUSH
59776: LD_VAR 0 2
59780: ARRAY
59781: AND
59782: IFFALSE 59820
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59784: LD_ADDR_EXP 59
59788: PUSH
59789: LD_EXP 59
59793: PPUSH
59794: LD_VAR 0 2
59798: PPUSH
59799: EMPTY
59800: PPUSH
59801: CALL_OW 1
59805: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
59806: LD_VAR 0 2
59810: PPUSH
59811: LD_INT 107
59813: PPUSH
59814: CALL 50668 0 2
// continue ;
59818: GO 59729
// end ; target := [ ] ;
59820: LD_ADDR_VAR 0 6
59824: PUSH
59825: EMPTY
59826: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
59827: LD_ADDR_VAR 0 3
59831: PUSH
59832: DOUBLE
59833: LD_EXP 58
59837: PUSH
59838: LD_VAR 0 2
59842: ARRAY
59843: INC
59844: ST_TO_ADDR
59845: LD_INT 1
59847: PUSH
59848: FOR_DOWNTO
59849: IFFALSE 60109
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
59851: LD_EXP 58
59855: PUSH
59856: LD_VAR 0 2
59860: ARRAY
59861: PUSH
59862: LD_VAR 0 3
59866: ARRAY
59867: PUSH
59868: LD_INT 2
59870: ARRAY
59871: PPUSH
59872: LD_EXP 58
59876: PUSH
59877: LD_VAR 0 2
59881: ARRAY
59882: PUSH
59883: LD_VAR 0 3
59887: ARRAY
59888: PUSH
59889: LD_INT 3
59891: ARRAY
59892: PPUSH
59893: CALL_OW 488
59897: PUSH
59898: LD_EXP 58
59902: PUSH
59903: LD_VAR 0 2
59907: ARRAY
59908: PUSH
59909: LD_VAR 0 3
59913: ARRAY
59914: PUSH
59915: LD_INT 2
59917: ARRAY
59918: PPUSH
59919: LD_EXP 58
59923: PUSH
59924: LD_VAR 0 2
59928: ARRAY
59929: PUSH
59930: LD_VAR 0 3
59934: ARRAY
59935: PUSH
59936: LD_INT 3
59938: ARRAY
59939: PPUSH
59940: CALL_OW 284
59944: PUSH
59945: LD_INT 0
59947: EQUAL
59948: AND
59949: IFFALSE 60004
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
59951: LD_ADDR_VAR 0 5
59955: PUSH
59956: LD_EXP 58
59960: PUSH
59961: LD_VAR 0 2
59965: ARRAY
59966: PPUSH
59967: LD_VAR 0 3
59971: PPUSH
59972: CALL_OW 3
59976: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
59977: LD_ADDR_EXP 58
59981: PUSH
59982: LD_EXP 58
59986: PPUSH
59987: LD_VAR 0 2
59991: PPUSH
59992: LD_VAR 0 5
59996: PPUSH
59997: CALL_OW 1
60001: ST_TO_ADDR
// continue ;
60002: GO 59848
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
60004: LD_EXP 42
60008: PUSH
60009: LD_VAR 0 2
60013: ARRAY
60014: PUSH
60015: LD_INT 1
60017: ARRAY
60018: PPUSH
60019: CALL_OW 255
60023: PPUSH
60024: LD_EXP 58
60028: PUSH
60029: LD_VAR 0 2
60033: ARRAY
60034: PUSH
60035: LD_VAR 0 3
60039: ARRAY
60040: PUSH
60041: LD_INT 2
60043: ARRAY
60044: PPUSH
60045: LD_EXP 58
60049: PUSH
60050: LD_VAR 0 2
60054: ARRAY
60055: PUSH
60056: LD_VAR 0 3
60060: ARRAY
60061: PUSH
60062: LD_INT 3
60064: ARRAY
60065: PPUSH
60066: LD_INT 30
60068: PPUSH
60069: CALL 15228 0 4
60073: PUSH
60074: LD_INT 4
60076: ARRAY
60077: PUSH
60078: LD_INT 0
60080: EQUAL
60081: IFFALSE 60107
// begin target := mc_crates [ i ] [ j ] ;
60083: LD_ADDR_VAR 0 6
60087: PUSH
60088: LD_EXP 58
60092: PUSH
60093: LD_VAR 0 2
60097: ARRAY
60098: PUSH
60099: LD_VAR 0 3
60103: ARRAY
60104: ST_TO_ADDR
// break ;
60105: GO 60109
// end ; end ;
60107: GO 59848
60109: POP
60110: POP
// if not target then
60111: LD_VAR 0 6
60115: NOT
60116: IFFALSE 60120
// continue ;
60118: GO 59729
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
60120: LD_ADDR_VAR 0 7
60124: PUSH
60125: LD_EXP 61
60129: PUSH
60130: LD_VAR 0 2
60134: ARRAY
60135: PPUSH
60136: LD_INT 2
60138: PUSH
60139: LD_INT 3
60141: PUSH
60142: LD_INT 58
60144: PUSH
60145: EMPTY
60146: LIST
60147: PUSH
60148: EMPTY
60149: LIST
60150: LIST
60151: PUSH
60152: LD_INT 61
60154: PUSH
60155: EMPTY
60156: LIST
60157: PUSH
60158: LD_INT 33
60160: PUSH
60161: LD_INT 5
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: PUSH
60168: LD_INT 33
60170: PUSH
60171: LD_INT 3
60173: PUSH
60174: EMPTY
60175: LIST
60176: LIST
60177: PUSH
60178: EMPTY
60179: LIST
60180: LIST
60181: LIST
60182: LIST
60183: LIST
60184: PUSH
60185: LD_INT 2
60187: PUSH
60188: LD_INT 34
60190: PUSH
60191: LD_INT 32
60193: PUSH
60194: EMPTY
60195: LIST
60196: LIST
60197: PUSH
60198: LD_INT 34
60200: PUSH
60201: LD_INT 51
60203: PUSH
60204: EMPTY
60205: LIST
60206: LIST
60207: PUSH
60208: LD_INT 34
60210: PUSH
60211: LD_INT 12
60213: PUSH
60214: EMPTY
60215: LIST
60216: LIST
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: LIST
60222: LIST
60223: PUSH
60224: EMPTY
60225: LIST
60226: LIST
60227: PPUSH
60228: CALL_OW 72
60232: ST_TO_ADDR
// if not cargo then
60233: LD_VAR 0 7
60237: NOT
60238: IFFALSE 60881
// begin if mc_crates_collector [ i ] < 5 then
60240: LD_EXP 59
60244: PUSH
60245: LD_VAR 0 2
60249: ARRAY
60250: PUSH
60251: LD_INT 5
60253: LESS
60254: IFFALSE 60620
// begin if mc_ape [ i ] then
60256: LD_EXP 71
60260: PUSH
60261: LD_VAR 0 2
60265: ARRAY
60266: IFFALSE 60313
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
60268: LD_ADDR_VAR 0 5
60272: PUSH
60273: LD_EXP 71
60277: PUSH
60278: LD_VAR 0 2
60282: ARRAY
60283: PPUSH
60284: LD_INT 25
60286: PUSH
60287: LD_INT 16
60289: PUSH
60290: EMPTY
60291: LIST
60292: LIST
60293: PUSH
60294: LD_INT 24
60296: PUSH
60297: LD_INT 750
60299: PUSH
60300: EMPTY
60301: LIST
60302: LIST
60303: PUSH
60304: EMPTY
60305: LIST
60306: LIST
60307: PPUSH
60308: CALL_OW 72
60312: ST_TO_ADDR
// if not tmp then
60313: LD_VAR 0 5
60317: NOT
60318: IFFALSE 60365
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
60320: LD_ADDR_VAR 0 5
60324: PUSH
60325: LD_EXP 42
60329: PUSH
60330: LD_VAR 0 2
60334: ARRAY
60335: PPUSH
60336: LD_INT 25
60338: PUSH
60339: LD_INT 2
60341: PUSH
60342: EMPTY
60343: LIST
60344: LIST
60345: PUSH
60346: LD_INT 24
60348: PUSH
60349: LD_INT 750
60351: PUSH
60352: EMPTY
60353: LIST
60354: LIST
60355: PUSH
60356: EMPTY
60357: LIST
60358: LIST
60359: PPUSH
60360: CALL_OW 72
60364: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
60365: LD_EXP 71
60369: PUSH
60370: LD_VAR 0 2
60374: ARRAY
60375: PUSH
60376: LD_EXP 42
60380: PUSH
60381: LD_VAR 0 2
60385: ARRAY
60386: PPUSH
60387: LD_INT 25
60389: PUSH
60390: LD_INT 2
60392: PUSH
60393: EMPTY
60394: LIST
60395: LIST
60396: PUSH
60397: LD_INT 24
60399: PUSH
60400: LD_INT 750
60402: PUSH
60403: EMPTY
60404: LIST
60405: LIST
60406: PUSH
60407: EMPTY
60408: LIST
60409: LIST
60410: PPUSH
60411: CALL_OW 72
60415: AND
60416: PUSH
60417: LD_VAR 0 5
60421: PUSH
60422: LD_INT 5
60424: LESS
60425: AND
60426: IFFALSE 60508
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
60428: LD_ADDR_VAR 0 3
60432: PUSH
60433: LD_EXP 42
60437: PUSH
60438: LD_VAR 0 2
60442: ARRAY
60443: PPUSH
60444: LD_INT 25
60446: PUSH
60447: LD_INT 2
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: PUSH
60454: LD_INT 24
60456: PUSH
60457: LD_INT 750
60459: PUSH
60460: EMPTY
60461: LIST
60462: LIST
60463: PUSH
60464: EMPTY
60465: LIST
60466: LIST
60467: PPUSH
60468: CALL_OW 72
60472: PUSH
60473: FOR_IN
60474: IFFALSE 60506
// begin tmp := tmp union j ;
60476: LD_ADDR_VAR 0 5
60480: PUSH
60481: LD_VAR 0 5
60485: PUSH
60486: LD_VAR 0 3
60490: UNION
60491: ST_TO_ADDR
// if tmp >= 5 then
60492: LD_VAR 0 5
60496: PUSH
60497: LD_INT 5
60499: GREATEREQUAL
60500: IFFALSE 60504
// break ;
60502: GO 60506
// end ;
60504: GO 60473
60506: POP
60507: POP
// end ; if not tmp then
60508: LD_VAR 0 5
60512: NOT
60513: IFFALSE 60517
// continue ;
60515: GO 59729
// for j in tmp do
60517: LD_ADDR_VAR 0 3
60521: PUSH
60522: LD_VAR 0 5
60526: PUSH
60527: FOR_IN
60528: IFFALSE 60618
// if not GetTag ( j ) then
60530: LD_VAR 0 3
60534: PPUSH
60535: CALL_OW 110
60539: NOT
60540: IFFALSE 60616
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
60542: LD_ADDR_EXP 59
60546: PUSH
60547: LD_EXP 59
60551: PPUSH
60552: LD_VAR 0 2
60556: PUSH
60557: LD_EXP 59
60561: PUSH
60562: LD_VAR 0 2
60566: ARRAY
60567: PUSH
60568: LD_INT 1
60570: PLUS
60571: PUSH
60572: EMPTY
60573: LIST
60574: LIST
60575: PPUSH
60576: LD_VAR 0 3
60580: PPUSH
60581: CALL 14332 0 3
60585: ST_TO_ADDR
// SetTag ( j , 107 ) ;
60586: LD_VAR 0 3
60590: PPUSH
60591: LD_INT 107
60593: PPUSH
60594: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
60598: LD_EXP 59
60602: PUSH
60603: LD_VAR 0 2
60607: ARRAY
60608: PUSH
60609: LD_INT 5
60611: GREATEREQUAL
60612: IFFALSE 60616
// break ;
60614: GO 60618
// end ;
60616: GO 60527
60618: POP
60619: POP
// end ; if mc_crates_collector [ i ] and target then
60620: LD_EXP 59
60624: PUSH
60625: LD_VAR 0 2
60629: ARRAY
60630: PUSH
60631: LD_VAR 0 6
60635: AND
60636: IFFALSE 60879
// begin if mc_crates_collector [ i ] < target [ 1 ] then
60638: LD_EXP 59
60642: PUSH
60643: LD_VAR 0 2
60647: ARRAY
60648: PUSH
60649: LD_VAR 0 6
60653: PUSH
60654: LD_INT 1
60656: ARRAY
60657: LESS
60658: IFFALSE 60678
// tmp := mc_crates_collector [ i ] else
60660: LD_ADDR_VAR 0 5
60664: PUSH
60665: LD_EXP 59
60669: PUSH
60670: LD_VAR 0 2
60674: ARRAY
60675: ST_TO_ADDR
60676: GO 60692
// tmp := target [ 1 ] ;
60678: LD_ADDR_VAR 0 5
60682: PUSH
60683: LD_VAR 0 6
60687: PUSH
60688: LD_INT 1
60690: ARRAY
60691: ST_TO_ADDR
// k := 0 ;
60692: LD_ADDR_VAR 0 4
60696: PUSH
60697: LD_INT 0
60699: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
60700: LD_ADDR_VAR 0 3
60704: PUSH
60705: LD_EXP 59
60709: PUSH
60710: LD_VAR 0 2
60714: ARRAY
60715: PUSH
60716: FOR_IN
60717: IFFALSE 60877
// begin k := k + 1 ;
60719: LD_ADDR_VAR 0 4
60723: PUSH
60724: LD_VAR 0 4
60728: PUSH
60729: LD_INT 1
60731: PLUS
60732: ST_TO_ADDR
// if k > tmp then
60733: LD_VAR 0 4
60737: PUSH
60738: LD_VAR 0 5
60742: GREATER
60743: IFFALSE 60747
// break ;
60745: GO 60877
// if not GetClass ( j ) in [ 2 , 16 ] then
60747: LD_VAR 0 3
60751: PPUSH
60752: CALL_OW 257
60756: PUSH
60757: LD_INT 2
60759: PUSH
60760: LD_INT 16
60762: PUSH
60763: EMPTY
60764: LIST
60765: LIST
60766: IN
60767: NOT
60768: IFFALSE 60821
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
60770: LD_ADDR_EXP 59
60774: PUSH
60775: LD_EXP 59
60779: PPUSH
60780: LD_VAR 0 2
60784: PPUSH
60785: LD_EXP 59
60789: PUSH
60790: LD_VAR 0 2
60794: ARRAY
60795: PUSH
60796: LD_VAR 0 3
60800: DIFF
60801: PPUSH
60802: CALL_OW 1
60806: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60807: LD_VAR 0 3
60811: PPUSH
60812: LD_INT 0
60814: PPUSH
60815: CALL_OW 109
// continue ;
60819: GO 60716
// end ; if IsInUnit ( j ) then
60821: LD_VAR 0 3
60825: PPUSH
60826: CALL_OW 310
60830: IFFALSE 60841
// ComExitBuilding ( j ) ;
60832: LD_VAR 0 3
60836: PPUSH
60837: CALL_OW 122
// wait ( 3 ) ;
60841: LD_INT 3
60843: PPUSH
60844: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
60848: LD_VAR 0 3
60852: PPUSH
60853: LD_VAR 0 6
60857: PUSH
60858: LD_INT 2
60860: ARRAY
60861: PPUSH
60862: LD_VAR 0 6
60866: PUSH
60867: LD_INT 3
60869: ARRAY
60870: PPUSH
60871: CALL_OW 117
// end ;
60875: GO 60716
60877: POP
60878: POP
// end ; end else
60879: GO 61460
// begin for j in cargo do
60881: LD_ADDR_VAR 0 3
60885: PUSH
60886: LD_VAR 0 7
60890: PUSH
60891: FOR_IN
60892: IFFALSE 61458
// begin if GetTag ( j ) <> 0 then
60894: LD_VAR 0 3
60898: PPUSH
60899: CALL_OW 110
60903: PUSH
60904: LD_INT 0
60906: NONEQUAL
60907: IFFALSE 60911
// continue ;
60909: GO 60891
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
60911: LD_VAR 0 3
60915: PPUSH
60916: CALL_OW 256
60920: PUSH
60921: LD_INT 1000
60923: LESS
60924: PUSH
60925: LD_VAR 0 3
60929: PPUSH
60930: LD_EXP 66
60934: PUSH
60935: LD_VAR 0 2
60939: ARRAY
60940: PPUSH
60941: CALL_OW 308
60945: NOT
60946: AND
60947: IFFALSE 60969
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60949: LD_VAR 0 3
60953: PPUSH
60954: LD_EXP 66
60958: PUSH
60959: LD_VAR 0 2
60963: ARRAY
60964: PPUSH
60965: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
60969: LD_VAR 0 3
60973: PPUSH
60974: CALL_OW 256
60978: PUSH
60979: LD_INT 1000
60981: LESS
60982: PUSH
60983: LD_VAR 0 3
60987: PPUSH
60988: LD_EXP 66
60992: PUSH
60993: LD_VAR 0 2
60997: ARRAY
60998: PPUSH
60999: CALL_OW 308
61003: AND
61004: IFFALSE 61008
// continue ;
61006: GO 60891
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
61008: LD_VAR 0 3
61012: PPUSH
61013: CALL_OW 262
61017: PUSH
61018: LD_INT 2
61020: EQUAL
61021: PUSH
61022: LD_VAR 0 3
61026: PPUSH
61027: CALL_OW 261
61031: PUSH
61032: LD_INT 15
61034: LESS
61035: AND
61036: IFFALSE 61040
// continue ;
61038: GO 60891
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
61040: LD_VAR 0 3
61044: PPUSH
61045: CALL_OW 262
61049: PUSH
61050: LD_INT 1
61052: EQUAL
61053: PUSH
61054: LD_VAR 0 3
61058: PPUSH
61059: CALL_OW 261
61063: PUSH
61064: LD_INT 10
61066: LESS
61067: AND
61068: IFFALSE 61397
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61070: LD_ADDR_VAR 0 8
61074: PUSH
61075: LD_EXP 42
61079: PUSH
61080: LD_VAR 0 2
61084: ARRAY
61085: PPUSH
61086: LD_INT 2
61088: PUSH
61089: LD_INT 30
61091: PUSH
61092: LD_INT 0
61094: PUSH
61095: EMPTY
61096: LIST
61097: LIST
61098: PUSH
61099: LD_INT 30
61101: PUSH
61102: LD_INT 1
61104: PUSH
61105: EMPTY
61106: LIST
61107: LIST
61108: PUSH
61109: EMPTY
61110: LIST
61111: LIST
61112: LIST
61113: PPUSH
61114: CALL_OW 72
61118: ST_TO_ADDR
// if not depot then
61119: LD_VAR 0 8
61123: NOT
61124: IFFALSE 61128
// continue ;
61126: GO 60891
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
61128: LD_VAR 0 3
61132: PPUSH
61133: LD_VAR 0 8
61137: PPUSH
61138: LD_VAR 0 3
61142: PPUSH
61143: CALL_OW 74
61147: PPUSH
61148: CALL_OW 296
61152: PUSH
61153: LD_INT 6
61155: LESS
61156: IFFALSE 61172
// SetFuel ( j , 100 ) else
61158: LD_VAR 0 3
61162: PPUSH
61163: LD_INT 100
61165: PPUSH
61166: CALL_OW 240
61170: GO 61397
// if GetFuel ( j ) = 0 then
61172: LD_VAR 0 3
61176: PPUSH
61177: CALL_OW 261
61181: PUSH
61182: LD_INT 0
61184: EQUAL
61185: IFFALSE 61397
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
61187: LD_ADDR_EXP 61
61191: PUSH
61192: LD_EXP 61
61196: PPUSH
61197: LD_VAR 0 2
61201: PPUSH
61202: LD_EXP 61
61206: PUSH
61207: LD_VAR 0 2
61211: ARRAY
61212: PUSH
61213: LD_VAR 0 3
61217: DIFF
61218: PPUSH
61219: CALL_OW 1
61223: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
61224: LD_VAR 0 3
61228: PPUSH
61229: CALL_OW 263
61233: PUSH
61234: LD_INT 1
61236: EQUAL
61237: IFFALSE 61253
// ComExitVehicle ( IsInUnit ( j ) ) ;
61239: LD_VAR 0 3
61243: PPUSH
61244: CALL_OW 310
61248: PPUSH
61249: CALL_OW 121
// if GetControl ( j ) = control_remote then
61253: LD_VAR 0 3
61257: PPUSH
61258: CALL_OW 263
61262: PUSH
61263: LD_INT 2
61265: EQUAL
61266: IFFALSE 61277
// ComUnlink ( j ) ;
61268: LD_VAR 0 3
61272: PPUSH
61273: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
61277: LD_ADDR_VAR 0 9
61281: PUSH
61282: LD_VAR 0 2
61286: PPUSH
61287: LD_INT 3
61289: PPUSH
61290: CALL 70772 0 2
61294: ST_TO_ADDR
// if fac then
61295: LD_VAR 0 9
61299: IFFALSE 61395
// begin for k in fac do
61301: LD_ADDR_VAR 0 4
61305: PUSH
61306: LD_VAR 0 9
61310: PUSH
61311: FOR_IN
61312: IFFALSE 61393
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
61314: LD_ADDR_VAR 0 10
61318: PUSH
61319: LD_VAR 0 9
61323: PPUSH
61324: LD_VAR 0 3
61328: PPUSH
61329: CALL_OW 265
61333: PPUSH
61334: LD_VAR 0 3
61338: PPUSH
61339: CALL_OW 262
61343: PPUSH
61344: LD_VAR 0 3
61348: PPUSH
61349: CALL_OW 263
61353: PPUSH
61354: LD_VAR 0 3
61358: PPUSH
61359: CALL_OW 264
61363: PPUSH
61364: CALL 11864 0 5
61368: ST_TO_ADDR
// if components then
61369: LD_VAR 0 10
61373: IFFALSE 61391
// begin MC_InsertProduceList ( i , components ) ;
61375: LD_VAR 0 2
61379: PPUSH
61380: LD_VAR 0 10
61384: PPUSH
61385: CALL 70317 0 2
// break ;
61389: GO 61393
// end ; end ;
61391: GO 61311
61393: POP
61394: POP
// end ; continue ;
61395: GO 60891
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
61397: LD_VAR 0 3
61401: PPUSH
61402: LD_INT 1
61404: PPUSH
61405: CALL_OW 289
61409: PUSH
61410: LD_INT 100
61412: LESS
61413: PUSH
61414: LD_VAR 0 3
61418: PPUSH
61419: CALL_OW 314
61423: NOT
61424: AND
61425: IFFALSE 61454
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61427: LD_VAR 0 3
61431: PPUSH
61432: LD_VAR 0 6
61436: PUSH
61437: LD_INT 2
61439: ARRAY
61440: PPUSH
61441: LD_VAR 0 6
61445: PUSH
61446: LD_INT 3
61448: ARRAY
61449: PPUSH
61450: CALL_OW 117
// break ;
61454: GO 61458
// end ;
61456: GO 60891
61458: POP
61459: POP
// end ; end ;
61460: GO 59729
61462: POP
61463: POP
// end ;
61464: LD_VAR 0 1
61468: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
61469: LD_INT 0
61471: PPUSH
61472: PPUSH
61473: PPUSH
61474: PPUSH
// if not mc_bases then
61475: LD_EXP 42
61479: NOT
61480: IFFALSE 61484
// exit ;
61482: GO 61645
// for i = 1 to mc_bases do
61484: LD_ADDR_VAR 0 2
61488: PUSH
61489: DOUBLE
61490: LD_INT 1
61492: DEC
61493: ST_TO_ADDR
61494: LD_EXP 42
61498: PUSH
61499: FOR_TO
61500: IFFALSE 61643
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
61502: LD_ADDR_VAR 0 4
61506: PUSH
61507: LD_EXP 61
61511: PUSH
61512: LD_VAR 0 2
61516: ARRAY
61517: PUSH
61518: LD_EXP 64
61522: PUSH
61523: LD_VAR 0 2
61527: ARRAY
61528: UNION
61529: PPUSH
61530: LD_INT 33
61532: PUSH
61533: LD_INT 2
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: PPUSH
61540: CALL_OW 72
61544: ST_TO_ADDR
// if tmp then
61545: LD_VAR 0 4
61549: IFFALSE 61641
// for j in tmp do
61551: LD_ADDR_VAR 0 3
61555: PUSH
61556: LD_VAR 0 4
61560: PUSH
61561: FOR_IN
61562: IFFALSE 61639
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
61564: LD_VAR 0 3
61568: PPUSH
61569: CALL_OW 312
61573: NOT
61574: PUSH
61575: LD_VAR 0 3
61579: PPUSH
61580: CALL_OW 256
61584: PUSH
61585: LD_INT 250
61587: GREATEREQUAL
61588: AND
61589: IFFALSE 61602
// Connect ( j ) else
61591: LD_VAR 0 3
61595: PPUSH
61596: CALL 17265 0 1
61600: GO 61637
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
61602: LD_VAR 0 3
61606: PPUSH
61607: CALL_OW 256
61611: PUSH
61612: LD_INT 250
61614: LESS
61615: PUSH
61616: LD_VAR 0 3
61620: PPUSH
61621: CALL_OW 312
61625: AND
61626: IFFALSE 61637
// ComUnlink ( j ) ;
61628: LD_VAR 0 3
61632: PPUSH
61633: CALL_OW 136
61637: GO 61561
61639: POP
61640: POP
// end ;
61641: GO 61499
61643: POP
61644: POP
// end ;
61645: LD_VAR 0 1
61649: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
61650: LD_INT 0
61652: PPUSH
61653: PPUSH
61654: PPUSH
61655: PPUSH
61656: PPUSH
// if not mc_bases then
61657: LD_EXP 42
61661: NOT
61662: IFFALSE 61666
// exit ;
61664: GO 62111
// for i = 1 to mc_bases do
61666: LD_ADDR_VAR 0 2
61670: PUSH
61671: DOUBLE
61672: LD_INT 1
61674: DEC
61675: ST_TO_ADDR
61676: LD_EXP 42
61680: PUSH
61681: FOR_TO
61682: IFFALSE 62109
// begin if not mc_produce [ i ] then
61684: LD_EXP 63
61688: PUSH
61689: LD_VAR 0 2
61693: ARRAY
61694: NOT
61695: IFFALSE 61699
// continue ;
61697: GO 61681
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
61699: LD_ADDR_VAR 0 5
61703: PUSH
61704: LD_EXP 42
61708: PUSH
61709: LD_VAR 0 2
61713: ARRAY
61714: PPUSH
61715: LD_INT 30
61717: PUSH
61718: LD_INT 3
61720: PUSH
61721: EMPTY
61722: LIST
61723: LIST
61724: PPUSH
61725: CALL_OW 72
61729: ST_TO_ADDR
// if not fac then
61730: LD_VAR 0 5
61734: NOT
61735: IFFALSE 61739
// continue ;
61737: GO 61681
// for j in fac do
61739: LD_ADDR_VAR 0 3
61743: PUSH
61744: LD_VAR 0 5
61748: PUSH
61749: FOR_IN
61750: IFFALSE 62105
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
61752: LD_VAR 0 3
61756: PPUSH
61757: CALL_OW 461
61761: PUSH
61762: LD_INT 2
61764: NONEQUAL
61765: PUSH
61766: LD_VAR 0 3
61770: PPUSH
61771: LD_INT 15
61773: PPUSH
61774: CALL 16925 0 2
61778: PUSH
61779: LD_INT 4
61781: ARRAY
61782: OR
61783: IFFALSE 61787
// continue ;
61785: GO 61749
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
61787: LD_VAR 0 3
61791: PPUSH
61792: LD_EXP 63
61796: PUSH
61797: LD_VAR 0 2
61801: ARRAY
61802: PUSH
61803: LD_INT 1
61805: ARRAY
61806: PUSH
61807: LD_INT 1
61809: ARRAY
61810: PPUSH
61811: LD_EXP 63
61815: PUSH
61816: LD_VAR 0 2
61820: ARRAY
61821: PUSH
61822: LD_INT 1
61824: ARRAY
61825: PUSH
61826: LD_INT 2
61828: ARRAY
61829: PPUSH
61830: LD_EXP 63
61834: PUSH
61835: LD_VAR 0 2
61839: ARRAY
61840: PUSH
61841: LD_INT 1
61843: ARRAY
61844: PUSH
61845: LD_INT 3
61847: ARRAY
61848: PPUSH
61849: LD_EXP 63
61853: PUSH
61854: LD_VAR 0 2
61858: ARRAY
61859: PUSH
61860: LD_INT 1
61862: ARRAY
61863: PUSH
61864: LD_INT 4
61866: ARRAY
61867: PPUSH
61868: CALL_OW 448
61872: PUSH
61873: LD_VAR 0 3
61877: PPUSH
61878: LD_EXP 63
61882: PUSH
61883: LD_VAR 0 2
61887: ARRAY
61888: PUSH
61889: LD_INT 1
61891: ARRAY
61892: PUSH
61893: LD_INT 1
61895: ARRAY
61896: PUSH
61897: LD_EXP 63
61901: PUSH
61902: LD_VAR 0 2
61906: ARRAY
61907: PUSH
61908: LD_INT 1
61910: ARRAY
61911: PUSH
61912: LD_INT 2
61914: ARRAY
61915: PUSH
61916: LD_EXP 63
61920: PUSH
61921: LD_VAR 0 2
61925: ARRAY
61926: PUSH
61927: LD_INT 1
61929: ARRAY
61930: PUSH
61931: LD_INT 3
61933: ARRAY
61934: PUSH
61935: LD_EXP 63
61939: PUSH
61940: LD_VAR 0 2
61944: ARRAY
61945: PUSH
61946: LD_INT 1
61948: ARRAY
61949: PUSH
61950: LD_INT 4
61952: ARRAY
61953: PUSH
61954: EMPTY
61955: LIST
61956: LIST
61957: LIST
61958: LIST
61959: PPUSH
61960: CALL 20596 0 2
61964: AND
61965: IFFALSE 62103
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
61967: LD_VAR 0 3
61971: PPUSH
61972: LD_EXP 63
61976: PUSH
61977: LD_VAR 0 2
61981: ARRAY
61982: PUSH
61983: LD_INT 1
61985: ARRAY
61986: PUSH
61987: LD_INT 1
61989: ARRAY
61990: PPUSH
61991: LD_EXP 63
61995: PUSH
61996: LD_VAR 0 2
62000: ARRAY
62001: PUSH
62002: LD_INT 1
62004: ARRAY
62005: PUSH
62006: LD_INT 2
62008: ARRAY
62009: PPUSH
62010: LD_EXP 63
62014: PUSH
62015: LD_VAR 0 2
62019: ARRAY
62020: PUSH
62021: LD_INT 1
62023: ARRAY
62024: PUSH
62025: LD_INT 3
62027: ARRAY
62028: PPUSH
62029: LD_EXP 63
62033: PUSH
62034: LD_VAR 0 2
62038: ARRAY
62039: PUSH
62040: LD_INT 1
62042: ARRAY
62043: PUSH
62044: LD_INT 4
62046: ARRAY
62047: PPUSH
62048: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
62052: LD_ADDR_VAR 0 4
62056: PUSH
62057: LD_EXP 63
62061: PUSH
62062: LD_VAR 0 2
62066: ARRAY
62067: PPUSH
62068: LD_INT 1
62070: PPUSH
62071: CALL_OW 3
62075: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62076: LD_ADDR_EXP 63
62080: PUSH
62081: LD_EXP 63
62085: PPUSH
62086: LD_VAR 0 2
62090: PPUSH
62091: LD_VAR 0 4
62095: PPUSH
62096: CALL_OW 1
62100: ST_TO_ADDR
// break ;
62101: GO 62105
// end ; end ;
62103: GO 61749
62105: POP
62106: POP
// end ;
62107: GO 61681
62109: POP
62110: POP
// end ;
62111: LD_VAR 0 1
62115: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
62116: LD_INT 0
62118: PPUSH
62119: PPUSH
62120: PPUSH
// if not mc_bases then
62121: LD_EXP 42
62125: NOT
62126: IFFALSE 62130
// exit ;
62128: GO 62219
// for i = 1 to mc_bases do
62130: LD_ADDR_VAR 0 2
62134: PUSH
62135: DOUBLE
62136: LD_INT 1
62138: DEC
62139: ST_TO_ADDR
62140: LD_EXP 42
62144: PUSH
62145: FOR_TO
62146: IFFALSE 62217
// begin if mc_attack [ i ] then
62148: LD_EXP 62
62152: PUSH
62153: LD_VAR 0 2
62157: ARRAY
62158: IFFALSE 62215
// begin tmp := mc_attack [ i ] [ 1 ] ;
62160: LD_ADDR_VAR 0 3
62164: PUSH
62165: LD_EXP 62
62169: PUSH
62170: LD_VAR 0 2
62174: ARRAY
62175: PUSH
62176: LD_INT 1
62178: ARRAY
62179: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62180: LD_ADDR_EXP 62
62184: PUSH
62185: LD_EXP 62
62189: PPUSH
62190: LD_VAR 0 2
62194: PPUSH
62195: EMPTY
62196: PPUSH
62197: CALL_OW 1
62201: ST_TO_ADDR
// Attack ( tmp ) ;
62202: LD_VAR 0 3
62206: PPUSH
62207: CALL 76824 0 1
// exit ;
62211: POP
62212: POP
62213: GO 62219
// end ; end ;
62215: GO 62145
62217: POP
62218: POP
// end ;
62219: LD_VAR 0 1
62223: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
62224: LD_INT 0
62226: PPUSH
62227: PPUSH
62228: PPUSH
62229: PPUSH
62230: PPUSH
62231: PPUSH
62232: PPUSH
// if not mc_bases then
62233: LD_EXP 42
62237: NOT
62238: IFFALSE 62242
// exit ;
62240: GO 62846
// for i = 1 to mc_bases do
62242: LD_ADDR_VAR 0 2
62246: PUSH
62247: DOUBLE
62248: LD_INT 1
62250: DEC
62251: ST_TO_ADDR
62252: LD_EXP 42
62256: PUSH
62257: FOR_TO
62258: IFFALSE 62844
// begin if not mc_bases [ i ] then
62260: LD_EXP 42
62264: PUSH
62265: LD_VAR 0 2
62269: ARRAY
62270: NOT
62271: IFFALSE 62275
// continue ;
62273: GO 62257
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
62275: LD_ADDR_VAR 0 7
62279: PUSH
62280: LD_EXP 42
62284: PUSH
62285: LD_VAR 0 2
62289: ARRAY
62290: PUSH
62291: LD_INT 1
62293: ARRAY
62294: PPUSH
62295: CALL 11168 0 1
62299: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
62300: LD_ADDR_EXP 65
62304: PUSH
62305: LD_EXP 65
62309: PPUSH
62310: LD_VAR 0 2
62314: PPUSH
62315: LD_EXP 42
62319: PUSH
62320: LD_VAR 0 2
62324: ARRAY
62325: PUSH
62326: LD_INT 1
62328: ARRAY
62329: PPUSH
62330: CALL_OW 255
62334: PPUSH
62335: LD_EXP 67
62339: PUSH
62340: LD_VAR 0 2
62344: ARRAY
62345: PPUSH
62346: CALL 11133 0 2
62350: PPUSH
62351: CALL_OW 1
62355: ST_TO_ADDR
// if not mc_scan [ i ] then
62356: LD_EXP 65
62360: PUSH
62361: LD_VAR 0 2
62365: ARRAY
62366: NOT
62367: IFFALSE 62522
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62369: LD_ADDR_VAR 0 4
62373: PUSH
62374: LD_EXP 42
62378: PUSH
62379: LD_VAR 0 2
62383: ARRAY
62384: PPUSH
62385: LD_INT 2
62387: PUSH
62388: LD_INT 25
62390: PUSH
62391: LD_INT 5
62393: PUSH
62394: EMPTY
62395: LIST
62396: LIST
62397: PUSH
62398: LD_INT 25
62400: PUSH
62401: LD_INT 8
62403: PUSH
62404: EMPTY
62405: LIST
62406: LIST
62407: PUSH
62408: LD_INT 25
62410: PUSH
62411: LD_INT 9
62413: PUSH
62414: EMPTY
62415: LIST
62416: LIST
62417: PUSH
62418: EMPTY
62419: LIST
62420: LIST
62421: LIST
62422: LIST
62423: PPUSH
62424: CALL_OW 72
62428: ST_TO_ADDR
// if not tmp then
62429: LD_VAR 0 4
62433: NOT
62434: IFFALSE 62438
// continue ;
62436: GO 62257
// for j in tmp do
62438: LD_ADDR_VAR 0 3
62442: PUSH
62443: LD_VAR 0 4
62447: PUSH
62448: FOR_IN
62449: IFFALSE 62520
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
62451: LD_VAR 0 3
62455: PPUSH
62456: CALL_OW 310
62460: PPUSH
62461: CALL_OW 266
62465: PUSH
62466: LD_INT 5
62468: EQUAL
62469: PUSH
62470: LD_VAR 0 3
62474: PPUSH
62475: CALL_OW 257
62479: PUSH
62480: LD_INT 1
62482: EQUAL
62483: AND
62484: PUSH
62485: LD_VAR 0 3
62489: PPUSH
62490: CALL_OW 459
62494: NOT
62495: AND
62496: PUSH
62497: LD_VAR 0 7
62501: AND
62502: IFFALSE 62518
// ComChangeProfession ( j , class ) ;
62504: LD_VAR 0 3
62508: PPUSH
62509: LD_VAR 0 7
62513: PPUSH
62514: CALL_OW 123
62518: GO 62448
62520: POP
62521: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
62522: LD_EXP 65
62526: PUSH
62527: LD_VAR 0 2
62531: ARRAY
62532: PUSH
62533: LD_EXP 64
62537: PUSH
62538: LD_VAR 0 2
62542: ARRAY
62543: NOT
62544: AND
62545: PUSH
62546: LD_EXP 42
62550: PUSH
62551: LD_VAR 0 2
62555: ARRAY
62556: PPUSH
62557: LD_INT 30
62559: PUSH
62560: LD_INT 32
62562: PUSH
62563: EMPTY
62564: LIST
62565: LIST
62566: PPUSH
62567: CALL_OW 72
62571: NOT
62572: AND
62573: PUSH
62574: LD_EXP 42
62578: PUSH
62579: LD_VAR 0 2
62583: ARRAY
62584: PPUSH
62585: LD_INT 2
62587: PUSH
62588: LD_INT 30
62590: PUSH
62591: LD_INT 4
62593: PUSH
62594: EMPTY
62595: LIST
62596: LIST
62597: PUSH
62598: LD_INT 30
62600: PUSH
62601: LD_INT 5
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: LIST
62612: PPUSH
62613: CALL_OW 72
62617: NOT
62618: AND
62619: IFFALSE 62751
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62621: LD_ADDR_VAR 0 4
62625: PUSH
62626: LD_EXP 42
62630: PUSH
62631: LD_VAR 0 2
62635: ARRAY
62636: PPUSH
62637: LD_INT 2
62639: PUSH
62640: LD_INT 25
62642: PUSH
62643: LD_INT 1
62645: PUSH
62646: EMPTY
62647: LIST
62648: LIST
62649: PUSH
62650: LD_INT 25
62652: PUSH
62653: LD_INT 5
62655: PUSH
62656: EMPTY
62657: LIST
62658: LIST
62659: PUSH
62660: LD_INT 25
62662: PUSH
62663: LD_INT 8
62665: PUSH
62666: EMPTY
62667: LIST
62668: LIST
62669: PUSH
62670: LD_INT 25
62672: PUSH
62673: LD_INT 9
62675: PUSH
62676: EMPTY
62677: LIST
62678: LIST
62679: PUSH
62680: EMPTY
62681: LIST
62682: LIST
62683: LIST
62684: LIST
62685: LIST
62686: PPUSH
62687: CALL_OW 72
62691: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
62692: LD_ADDR_VAR 0 4
62696: PUSH
62697: LD_VAR 0 4
62701: PUSH
62702: LD_VAR 0 4
62706: PPUSH
62707: LD_INT 18
62709: PPUSH
62710: CALL 42893 0 2
62714: DIFF
62715: ST_TO_ADDR
// if tmp then
62716: LD_VAR 0 4
62720: IFFALSE 62751
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
62722: LD_VAR 0 2
62726: PPUSH
62727: LD_VAR 0 4
62731: PPUSH
62732: LD_EXP 67
62736: PUSH
62737: LD_VAR 0 2
62741: ARRAY
62742: PPUSH
62743: CALL 81533 0 3
// exit ;
62747: POP
62748: POP
62749: GO 62846
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
62751: LD_EXP 65
62755: PUSH
62756: LD_VAR 0 2
62760: ARRAY
62761: PUSH
62762: LD_EXP 64
62766: PUSH
62767: LD_VAR 0 2
62771: ARRAY
62772: AND
62773: IFFALSE 62842
// begin tmp := mc_defender [ i ] ;
62775: LD_ADDR_VAR 0 4
62779: PUSH
62780: LD_EXP 64
62784: PUSH
62785: LD_VAR 0 2
62789: ARRAY
62790: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
62791: LD_ADDR_EXP 64
62795: PUSH
62796: LD_EXP 64
62800: PPUSH
62801: LD_VAR 0 2
62805: PPUSH
62806: EMPTY
62807: PPUSH
62808: CALL_OW 1
62812: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
62813: LD_VAR 0 2
62817: PPUSH
62818: LD_VAR 0 4
62822: PPUSH
62823: LD_EXP 65
62827: PUSH
62828: LD_VAR 0 2
62832: ARRAY
62833: PPUSH
62834: CALL 82094 0 3
// exit ;
62838: POP
62839: POP
62840: GO 62846
// end ; end ;
62842: GO 62257
62844: POP
62845: POP
// end ;
62846: LD_VAR 0 1
62850: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
62851: LD_INT 0
62853: PPUSH
62854: PPUSH
62855: PPUSH
62856: PPUSH
62857: PPUSH
62858: PPUSH
62859: PPUSH
62860: PPUSH
62861: PPUSH
62862: PPUSH
62863: PPUSH
// if not mc_bases then
62864: LD_EXP 42
62868: NOT
62869: IFFALSE 62873
// exit ;
62871: GO 63960
// for i = 1 to mc_bases do
62873: LD_ADDR_VAR 0 2
62877: PUSH
62878: DOUBLE
62879: LD_INT 1
62881: DEC
62882: ST_TO_ADDR
62883: LD_EXP 42
62887: PUSH
62888: FOR_TO
62889: IFFALSE 63958
// begin tmp := mc_lab [ i ] ;
62891: LD_ADDR_VAR 0 6
62895: PUSH
62896: LD_EXP 75
62900: PUSH
62901: LD_VAR 0 2
62905: ARRAY
62906: ST_TO_ADDR
// if not tmp then
62907: LD_VAR 0 6
62911: NOT
62912: IFFALSE 62916
// continue ;
62914: GO 62888
// idle_lab := 0 ;
62916: LD_ADDR_VAR 0 11
62920: PUSH
62921: LD_INT 0
62923: ST_TO_ADDR
// for j in tmp do
62924: LD_ADDR_VAR 0 3
62928: PUSH
62929: LD_VAR 0 6
62933: PUSH
62934: FOR_IN
62935: IFFALSE 63954
// begin researching := false ;
62937: LD_ADDR_VAR 0 10
62941: PUSH
62942: LD_INT 0
62944: ST_TO_ADDR
// side := GetSide ( j ) ;
62945: LD_ADDR_VAR 0 4
62949: PUSH
62950: LD_VAR 0 3
62954: PPUSH
62955: CALL_OW 255
62959: ST_TO_ADDR
// if not mc_tech [ side ] then
62960: LD_EXP 69
62964: PUSH
62965: LD_VAR 0 4
62969: ARRAY
62970: NOT
62971: IFFALSE 62975
// continue ;
62973: GO 62934
// if BuildingStatus ( j ) = bs_idle then
62975: LD_VAR 0 3
62979: PPUSH
62980: CALL_OW 461
62984: PUSH
62985: LD_INT 2
62987: EQUAL
62988: IFFALSE 63176
// begin if idle_lab and UnitsInside ( j ) < 6 then
62990: LD_VAR 0 11
62994: PUSH
62995: LD_VAR 0 3
62999: PPUSH
63000: CALL_OW 313
63004: PUSH
63005: LD_INT 6
63007: LESS
63008: AND
63009: IFFALSE 63080
// begin tmp2 := UnitsInside ( idle_lab ) ;
63011: LD_ADDR_VAR 0 9
63015: PUSH
63016: LD_VAR 0 11
63020: PPUSH
63021: CALL_OW 313
63025: ST_TO_ADDR
// if tmp2 then
63026: LD_VAR 0 9
63030: IFFALSE 63072
// for x in tmp2 do
63032: LD_ADDR_VAR 0 7
63036: PUSH
63037: LD_VAR 0 9
63041: PUSH
63042: FOR_IN
63043: IFFALSE 63070
// begin ComExitBuilding ( x ) ;
63045: LD_VAR 0 7
63049: PPUSH
63050: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
63054: LD_VAR 0 7
63058: PPUSH
63059: LD_VAR 0 3
63063: PPUSH
63064: CALL_OW 180
// end ;
63068: GO 63042
63070: POP
63071: POP
// idle_lab := 0 ;
63072: LD_ADDR_VAR 0 11
63076: PUSH
63077: LD_INT 0
63079: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
63080: LD_ADDR_VAR 0 5
63084: PUSH
63085: LD_EXP 69
63089: PUSH
63090: LD_VAR 0 4
63094: ARRAY
63095: PUSH
63096: FOR_IN
63097: IFFALSE 63157
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
63099: LD_VAR 0 3
63103: PPUSH
63104: LD_VAR 0 5
63108: PPUSH
63109: CALL_OW 430
63113: PUSH
63114: LD_VAR 0 4
63118: PPUSH
63119: LD_VAR 0 5
63123: PPUSH
63124: CALL 10238 0 2
63128: AND
63129: IFFALSE 63155
// begin researching := true ;
63131: LD_ADDR_VAR 0 10
63135: PUSH
63136: LD_INT 1
63138: ST_TO_ADDR
// ComResearch ( j , t ) ;
63139: LD_VAR 0 3
63143: PPUSH
63144: LD_VAR 0 5
63148: PPUSH
63149: CALL_OW 124
// break ;
63153: GO 63157
// end ;
63155: GO 63096
63157: POP
63158: POP
// if not researching then
63159: LD_VAR 0 10
63163: NOT
63164: IFFALSE 63176
// idle_lab := j ;
63166: LD_ADDR_VAR 0 11
63170: PUSH
63171: LD_VAR 0 3
63175: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
63176: LD_VAR 0 3
63180: PPUSH
63181: CALL_OW 461
63185: PUSH
63186: LD_INT 10
63188: EQUAL
63189: IFFALSE 63777
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
63191: LD_EXP 71
63195: PUSH
63196: LD_VAR 0 2
63200: ARRAY
63201: NOT
63202: PUSH
63203: LD_EXP 72
63207: PUSH
63208: LD_VAR 0 2
63212: ARRAY
63213: NOT
63214: AND
63215: PUSH
63216: LD_EXP 69
63220: PUSH
63221: LD_VAR 0 4
63225: ARRAY
63226: PUSH
63227: LD_INT 1
63229: GREATER
63230: AND
63231: IFFALSE 63362
// begin ComCancel ( j ) ;
63233: LD_VAR 0 3
63237: PPUSH
63238: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
63242: LD_ADDR_EXP 69
63246: PUSH
63247: LD_EXP 69
63251: PPUSH
63252: LD_VAR 0 4
63256: PPUSH
63257: LD_EXP 69
63261: PUSH
63262: LD_VAR 0 4
63266: ARRAY
63267: PPUSH
63268: LD_EXP 69
63272: PUSH
63273: LD_VAR 0 4
63277: ARRAY
63278: PUSH
63279: LD_INT 1
63281: MINUS
63282: PPUSH
63283: LD_EXP 69
63287: PUSH
63288: LD_VAR 0 4
63292: ARRAY
63293: PPUSH
63294: LD_INT 0
63296: PPUSH
63297: CALL 13750 0 4
63301: PPUSH
63302: CALL_OW 1
63306: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
63307: LD_ADDR_EXP 69
63311: PUSH
63312: LD_EXP 69
63316: PPUSH
63317: LD_VAR 0 4
63321: PPUSH
63322: LD_EXP 69
63326: PUSH
63327: LD_VAR 0 4
63331: ARRAY
63332: PPUSH
63333: LD_EXP 69
63337: PUSH
63338: LD_VAR 0 4
63342: ARRAY
63343: PPUSH
63344: LD_INT 1
63346: PPUSH
63347: LD_INT 0
63349: PPUSH
63350: CALL 13750 0 4
63354: PPUSH
63355: CALL_OW 1
63359: ST_TO_ADDR
// continue ;
63360: GO 62934
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
63362: LD_EXP 71
63366: PUSH
63367: LD_VAR 0 2
63371: ARRAY
63372: PUSH
63373: LD_EXP 72
63377: PUSH
63378: LD_VAR 0 2
63382: ARRAY
63383: NOT
63384: AND
63385: IFFALSE 63512
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
63387: LD_ADDR_EXP 72
63391: PUSH
63392: LD_EXP 72
63396: PPUSH
63397: LD_VAR 0 2
63401: PUSH
63402: LD_EXP 72
63406: PUSH
63407: LD_VAR 0 2
63411: ARRAY
63412: PUSH
63413: LD_INT 1
63415: PLUS
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PPUSH
63421: LD_EXP 71
63425: PUSH
63426: LD_VAR 0 2
63430: ARRAY
63431: PUSH
63432: LD_INT 1
63434: ARRAY
63435: PPUSH
63436: CALL 14332 0 3
63440: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
63441: LD_EXP 71
63445: PUSH
63446: LD_VAR 0 2
63450: ARRAY
63451: PUSH
63452: LD_INT 1
63454: ARRAY
63455: PPUSH
63456: LD_INT 112
63458: PPUSH
63459: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
63463: LD_ADDR_VAR 0 9
63467: PUSH
63468: LD_EXP 71
63472: PUSH
63473: LD_VAR 0 2
63477: ARRAY
63478: PPUSH
63479: LD_INT 1
63481: PPUSH
63482: CALL_OW 3
63486: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
63487: LD_ADDR_EXP 71
63491: PUSH
63492: LD_EXP 71
63496: PPUSH
63497: LD_VAR 0 2
63501: PPUSH
63502: LD_VAR 0 9
63506: PPUSH
63507: CALL_OW 1
63511: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
63512: LD_EXP 71
63516: PUSH
63517: LD_VAR 0 2
63521: ARRAY
63522: PUSH
63523: LD_EXP 72
63527: PUSH
63528: LD_VAR 0 2
63532: ARRAY
63533: AND
63534: PUSH
63535: LD_EXP 72
63539: PUSH
63540: LD_VAR 0 2
63544: ARRAY
63545: PUSH
63546: LD_INT 1
63548: ARRAY
63549: PPUSH
63550: CALL_OW 310
63554: NOT
63555: AND
63556: PUSH
63557: LD_VAR 0 3
63561: PPUSH
63562: CALL_OW 313
63566: PUSH
63567: LD_INT 6
63569: EQUAL
63570: AND
63571: IFFALSE 63627
// begin tmp2 := UnitsInside ( j ) ;
63573: LD_ADDR_VAR 0 9
63577: PUSH
63578: LD_VAR 0 3
63582: PPUSH
63583: CALL_OW 313
63587: ST_TO_ADDR
// if tmp2 = 6 then
63588: LD_VAR 0 9
63592: PUSH
63593: LD_INT 6
63595: EQUAL
63596: IFFALSE 63627
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
63598: LD_VAR 0 9
63602: PUSH
63603: LD_INT 1
63605: ARRAY
63606: PPUSH
63607: LD_INT 112
63609: PPUSH
63610: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
63614: LD_VAR 0 9
63618: PUSH
63619: LD_INT 1
63621: ARRAY
63622: PPUSH
63623: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
63627: LD_EXP 72
63631: PUSH
63632: LD_VAR 0 2
63636: ARRAY
63637: PUSH
63638: LD_EXP 72
63642: PUSH
63643: LD_VAR 0 2
63647: ARRAY
63648: PUSH
63649: LD_INT 1
63651: ARRAY
63652: PPUSH
63653: CALL_OW 314
63657: NOT
63658: AND
63659: PUSH
63660: LD_EXP 72
63664: PUSH
63665: LD_VAR 0 2
63669: ARRAY
63670: PUSH
63671: LD_INT 1
63673: ARRAY
63674: PPUSH
63675: CALL_OW 310
63679: NOT
63680: AND
63681: IFFALSE 63707
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
63683: LD_EXP 72
63687: PUSH
63688: LD_VAR 0 2
63692: ARRAY
63693: PUSH
63694: LD_INT 1
63696: ARRAY
63697: PPUSH
63698: LD_VAR 0 3
63702: PPUSH
63703: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
63707: LD_EXP 72
63711: PUSH
63712: LD_VAR 0 2
63716: ARRAY
63717: PUSH
63718: LD_INT 1
63720: ARRAY
63721: PPUSH
63722: CALL_OW 310
63726: PUSH
63727: LD_EXP 72
63731: PUSH
63732: LD_VAR 0 2
63736: ARRAY
63737: PUSH
63738: LD_INT 1
63740: ARRAY
63741: PPUSH
63742: CALL_OW 310
63746: PPUSH
63747: CALL_OW 461
63751: PUSH
63752: LD_INT 3
63754: NONEQUAL
63755: AND
63756: IFFALSE 63777
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
63758: LD_EXP 72
63762: PUSH
63763: LD_VAR 0 2
63767: ARRAY
63768: PUSH
63769: LD_INT 1
63771: ARRAY
63772: PPUSH
63773: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
63777: LD_VAR 0 3
63781: PPUSH
63782: CALL_OW 461
63786: PUSH
63787: LD_INT 6
63789: EQUAL
63790: PUSH
63791: LD_VAR 0 6
63795: PUSH
63796: LD_INT 1
63798: GREATER
63799: AND
63800: IFFALSE 63952
// begin sci := [ ] ;
63802: LD_ADDR_VAR 0 8
63806: PUSH
63807: EMPTY
63808: ST_TO_ADDR
// for x in ( tmp diff j ) do
63809: LD_ADDR_VAR 0 7
63813: PUSH
63814: LD_VAR 0 6
63818: PUSH
63819: LD_VAR 0 3
63823: DIFF
63824: PUSH
63825: FOR_IN
63826: IFFALSE 63878
// begin if sci = 6 then
63828: LD_VAR 0 8
63832: PUSH
63833: LD_INT 6
63835: EQUAL
63836: IFFALSE 63840
// break ;
63838: GO 63878
// if BuildingStatus ( x ) = bs_idle then
63840: LD_VAR 0 7
63844: PPUSH
63845: CALL_OW 461
63849: PUSH
63850: LD_INT 2
63852: EQUAL
63853: IFFALSE 63876
// sci := sci ^ UnitsInside ( x ) ;
63855: LD_ADDR_VAR 0 8
63859: PUSH
63860: LD_VAR 0 8
63864: PUSH
63865: LD_VAR 0 7
63869: PPUSH
63870: CALL_OW 313
63874: ADD
63875: ST_TO_ADDR
// end ;
63876: GO 63825
63878: POP
63879: POP
// if not sci then
63880: LD_VAR 0 8
63884: NOT
63885: IFFALSE 63889
// continue ;
63887: GO 62934
// for x in sci do
63889: LD_ADDR_VAR 0 7
63893: PUSH
63894: LD_VAR 0 8
63898: PUSH
63899: FOR_IN
63900: IFFALSE 63950
// if IsInUnit ( x ) and not HasTask ( x ) then
63902: LD_VAR 0 7
63906: PPUSH
63907: CALL_OW 310
63911: PUSH
63912: LD_VAR 0 7
63916: PPUSH
63917: CALL_OW 314
63921: NOT
63922: AND
63923: IFFALSE 63948
// begin ComExitBuilding ( x ) ;
63925: LD_VAR 0 7
63929: PPUSH
63930: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
63934: LD_VAR 0 7
63938: PPUSH
63939: LD_VAR 0 3
63943: PPUSH
63944: CALL_OW 180
// end ;
63948: GO 63899
63950: POP
63951: POP
// end ; end ;
63952: GO 62934
63954: POP
63955: POP
// end ;
63956: GO 62888
63958: POP
63959: POP
// end ;
63960: LD_VAR 0 1
63964: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
63965: LD_INT 0
63967: PPUSH
63968: PPUSH
// if not mc_bases then
63969: LD_EXP 42
63973: NOT
63974: IFFALSE 63978
// exit ;
63976: GO 64059
// for i = 1 to mc_bases do
63978: LD_ADDR_VAR 0 2
63982: PUSH
63983: DOUBLE
63984: LD_INT 1
63986: DEC
63987: ST_TO_ADDR
63988: LD_EXP 42
63992: PUSH
63993: FOR_TO
63994: IFFALSE 64057
// if mc_mines [ i ] and mc_miners [ i ] then
63996: LD_EXP 55
64000: PUSH
64001: LD_VAR 0 2
64005: ARRAY
64006: PUSH
64007: LD_EXP 56
64011: PUSH
64012: LD_VAR 0 2
64016: ARRAY
64017: AND
64018: IFFALSE 64055
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
64020: LD_EXP 56
64024: PUSH
64025: LD_VAR 0 2
64029: ARRAY
64030: PUSH
64031: LD_INT 1
64033: ARRAY
64034: PPUSH
64035: CALL_OW 255
64039: PPUSH
64040: LD_EXP 55
64044: PUSH
64045: LD_VAR 0 2
64049: ARRAY
64050: PPUSH
64051: CALL 11321 0 2
64055: GO 63993
64057: POP
64058: POP
// end ;
64059: LD_VAR 0 1
64063: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
64064: LD_INT 0
64066: PPUSH
64067: PPUSH
64068: PPUSH
64069: PPUSH
64070: PPUSH
64071: PPUSH
64072: PPUSH
64073: PPUSH
// if not mc_bases or not mc_parking then
64074: LD_EXP 42
64078: NOT
64079: PUSH
64080: LD_EXP 66
64084: NOT
64085: OR
64086: IFFALSE 64090
// exit ;
64088: GO 64789
// for i = 1 to mc_bases do
64090: LD_ADDR_VAR 0 2
64094: PUSH
64095: DOUBLE
64096: LD_INT 1
64098: DEC
64099: ST_TO_ADDR
64100: LD_EXP 42
64104: PUSH
64105: FOR_TO
64106: IFFALSE 64787
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
64108: LD_EXP 42
64112: PUSH
64113: LD_VAR 0 2
64117: ARRAY
64118: NOT
64119: PUSH
64120: LD_EXP 66
64124: PUSH
64125: LD_VAR 0 2
64129: ARRAY
64130: NOT
64131: OR
64132: IFFALSE 64136
// continue ;
64134: GO 64105
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64136: LD_ADDR_VAR 0 5
64140: PUSH
64141: LD_EXP 42
64145: PUSH
64146: LD_VAR 0 2
64150: ARRAY
64151: PUSH
64152: LD_INT 1
64154: ARRAY
64155: PPUSH
64156: CALL_OW 255
64160: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64161: LD_ADDR_VAR 0 6
64165: PUSH
64166: LD_EXP 42
64170: PUSH
64171: LD_VAR 0 2
64175: ARRAY
64176: PPUSH
64177: LD_INT 30
64179: PUSH
64180: LD_INT 3
64182: PUSH
64183: EMPTY
64184: LIST
64185: LIST
64186: PPUSH
64187: CALL_OW 72
64191: ST_TO_ADDR
// if not fac then
64192: LD_VAR 0 6
64196: NOT
64197: IFFALSE 64248
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64199: LD_ADDR_VAR 0 6
64203: PUSH
64204: LD_EXP 42
64208: PUSH
64209: LD_VAR 0 2
64213: ARRAY
64214: PPUSH
64215: LD_INT 2
64217: PUSH
64218: LD_INT 30
64220: PUSH
64221: LD_INT 0
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: LD_INT 30
64230: PUSH
64231: LD_INT 1
64233: PUSH
64234: EMPTY
64235: LIST
64236: LIST
64237: PUSH
64238: EMPTY
64239: LIST
64240: LIST
64241: LIST
64242: PPUSH
64243: CALL_OW 72
64247: ST_TO_ADDR
// if not fac then
64248: LD_VAR 0 6
64252: NOT
64253: IFFALSE 64257
// continue ;
64255: GO 64105
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64257: LD_ADDR_VAR 0 7
64261: PUSH
64262: LD_EXP 66
64266: PUSH
64267: LD_VAR 0 2
64271: ARRAY
64272: PPUSH
64273: LD_INT 22
64275: PUSH
64276: LD_VAR 0 5
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 21
64287: PUSH
64288: LD_INT 2
64290: PUSH
64291: EMPTY
64292: LIST
64293: LIST
64294: PUSH
64295: LD_INT 3
64297: PUSH
64298: LD_INT 24
64300: PUSH
64301: LD_INT 1000
64303: PUSH
64304: EMPTY
64305: LIST
64306: LIST
64307: PUSH
64308: EMPTY
64309: LIST
64310: LIST
64311: PUSH
64312: EMPTY
64313: LIST
64314: LIST
64315: LIST
64316: PPUSH
64317: CALL_OW 70
64321: ST_TO_ADDR
// for j in fac do
64322: LD_ADDR_VAR 0 3
64326: PUSH
64327: LD_VAR 0 6
64331: PUSH
64332: FOR_IN
64333: IFFALSE 64414
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64335: LD_ADDR_VAR 0 7
64339: PUSH
64340: LD_VAR 0 7
64344: PUSH
64345: LD_INT 22
64347: PUSH
64348: LD_VAR 0 5
64352: PUSH
64353: EMPTY
64354: LIST
64355: LIST
64356: PUSH
64357: LD_INT 91
64359: PUSH
64360: LD_VAR 0 3
64364: PUSH
64365: LD_INT 15
64367: PUSH
64368: EMPTY
64369: LIST
64370: LIST
64371: LIST
64372: PUSH
64373: LD_INT 21
64375: PUSH
64376: LD_INT 2
64378: PUSH
64379: EMPTY
64380: LIST
64381: LIST
64382: PUSH
64383: LD_INT 3
64385: PUSH
64386: LD_INT 24
64388: PUSH
64389: LD_INT 1000
64391: PUSH
64392: EMPTY
64393: LIST
64394: LIST
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: PUSH
64400: EMPTY
64401: LIST
64402: LIST
64403: LIST
64404: LIST
64405: PPUSH
64406: CALL_OW 69
64410: UNION
64411: ST_TO_ADDR
64412: GO 64332
64414: POP
64415: POP
// if not vehs then
64416: LD_VAR 0 7
64420: NOT
64421: IFFALSE 64447
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64423: LD_ADDR_EXP 54
64427: PUSH
64428: LD_EXP 54
64432: PPUSH
64433: LD_VAR 0 2
64437: PPUSH
64438: EMPTY
64439: PPUSH
64440: CALL_OW 1
64444: ST_TO_ADDR
// continue ;
64445: GO 64105
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64447: LD_ADDR_VAR 0 8
64451: PUSH
64452: LD_EXP 42
64456: PUSH
64457: LD_VAR 0 2
64461: ARRAY
64462: PPUSH
64463: LD_INT 30
64465: PUSH
64466: LD_INT 3
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: PPUSH
64473: CALL_OW 72
64477: ST_TO_ADDR
// if tmp then
64478: LD_VAR 0 8
64482: IFFALSE 64585
// begin for j in tmp do
64484: LD_ADDR_VAR 0 3
64488: PUSH
64489: LD_VAR 0 8
64493: PUSH
64494: FOR_IN
64495: IFFALSE 64583
// for k in UnitsInside ( j ) do
64497: LD_ADDR_VAR 0 4
64501: PUSH
64502: LD_VAR 0 3
64506: PPUSH
64507: CALL_OW 313
64511: PUSH
64512: FOR_IN
64513: IFFALSE 64579
// if k then
64515: LD_VAR 0 4
64519: IFFALSE 64577
// if not k in mc_repair_vehicle [ i ] then
64521: LD_VAR 0 4
64525: PUSH
64526: LD_EXP 54
64530: PUSH
64531: LD_VAR 0 2
64535: ARRAY
64536: IN
64537: NOT
64538: IFFALSE 64577
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
64540: LD_ADDR_EXP 54
64544: PUSH
64545: LD_EXP 54
64549: PPUSH
64550: LD_VAR 0 2
64554: PPUSH
64555: LD_EXP 54
64559: PUSH
64560: LD_VAR 0 2
64564: ARRAY
64565: PUSH
64566: LD_VAR 0 4
64570: UNION
64571: PPUSH
64572: CALL_OW 1
64576: ST_TO_ADDR
64577: GO 64512
64579: POP
64580: POP
64581: GO 64494
64583: POP
64584: POP
// end ; if not mc_repair_vehicle [ i ] then
64585: LD_EXP 54
64589: PUSH
64590: LD_VAR 0 2
64594: ARRAY
64595: NOT
64596: IFFALSE 64600
// continue ;
64598: GO 64105
// for j in mc_repair_vehicle [ i ] do
64600: LD_ADDR_VAR 0 3
64604: PUSH
64605: LD_EXP 54
64609: PUSH
64610: LD_VAR 0 2
64614: ARRAY
64615: PUSH
64616: FOR_IN
64617: IFFALSE 64783
// begin if GetClass ( j ) <> 3 then
64619: LD_VAR 0 3
64623: PPUSH
64624: CALL_OW 257
64628: PUSH
64629: LD_INT 3
64631: NONEQUAL
64632: IFFALSE 64673
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
64634: LD_ADDR_EXP 54
64638: PUSH
64639: LD_EXP 54
64643: PPUSH
64644: LD_VAR 0 2
64648: PPUSH
64649: LD_EXP 54
64653: PUSH
64654: LD_VAR 0 2
64658: ARRAY
64659: PUSH
64660: LD_VAR 0 3
64664: DIFF
64665: PPUSH
64666: CALL_OW 1
64670: ST_TO_ADDR
// continue ;
64671: GO 64616
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
64673: LD_VAR 0 3
64677: PPUSH
64678: CALL_OW 311
64682: NOT
64683: PUSH
64684: LD_VAR 0 3
64688: PUSH
64689: LD_EXP 45
64693: PUSH
64694: LD_VAR 0 2
64698: ARRAY
64699: PUSH
64700: LD_INT 1
64702: ARRAY
64703: IN
64704: NOT
64705: AND
64706: PUSH
64707: LD_VAR 0 3
64711: PUSH
64712: LD_EXP 45
64716: PUSH
64717: LD_VAR 0 2
64721: ARRAY
64722: PUSH
64723: LD_INT 2
64725: ARRAY
64726: IN
64727: NOT
64728: AND
64729: IFFALSE 64781
// begin if IsInUnit ( j ) then
64731: LD_VAR 0 3
64735: PPUSH
64736: CALL_OW 310
64740: IFFALSE 64751
// ComExitBuilding ( j ) ;
64742: LD_VAR 0 3
64746: PPUSH
64747: CALL_OW 122
// if not HasTask ( j ) then
64751: LD_VAR 0 3
64755: PPUSH
64756: CALL_OW 314
64760: NOT
64761: IFFALSE 64781
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
64763: LD_VAR 0 3
64767: PPUSH
64768: LD_VAR 0 7
64772: PUSH
64773: LD_INT 1
64775: ARRAY
64776: PPUSH
64777: CALL_OW 189
// end ; end ;
64781: GO 64616
64783: POP
64784: POP
// end ;
64785: GO 64105
64787: POP
64788: POP
// end ;
64789: LD_VAR 0 1
64793: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
64794: LD_INT 0
64796: PPUSH
64797: PPUSH
64798: PPUSH
64799: PPUSH
64800: PPUSH
64801: PPUSH
64802: PPUSH
64803: PPUSH
64804: PPUSH
64805: PPUSH
64806: PPUSH
// if not mc_bases then
64807: LD_EXP 42
64811: NOT
64812: IFFALSE 64816
// exit ;
64814: GO 65618
// for i = 1 to mc_bases do
64816: LD_ADDR_VAR 0 2
64820: PUSH
64821: DOUBLE
64822: LD_INT 1
64824: DEC
64825: ST_TO_ADDR
64826: LD_EXP 42
64830: PUSH
64831: FOR_TO
64832: IFFALSE 65616
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
64834: LD_EXP 70
64838: PUSH
64839: LD_VAR 0 2
64843: ARRAY
64844: NOT
64845: PUSH
64846: LD_EXP 45
64850: PUSH
64851: LD_VAR 0 2
64855: ARRAY
64856: PUSH
64857: LD_INT 1
64859: ARRAY
64860: OR
64861: PUSH
64862: LD_EXP 45
64866: PUSH
64867: LD_VAR 0 2
64871: ARRAY
64872: PUSH
64873: LD_INT 2
64875: ARRAY
64876: OR
64877: PUSH
64878: LD_EXP 68
64882: PUSH
64883: LD_VAR 0 2
64887: ARRAY
64888: PPUSH
64889: LD_INT 1
64891: PPUSH
64892: CALL_OW 325
64896: NOT
64897: OR
64898: PUSH
64899: LD_EXP 65
64903: PUSH
64904: LD_VAR 0 2
64908: ARRAY
64909: OR
64910: IFFALSE 64914
// continue ;
64912: GO 64831
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
64914: LD_ADDR_VAR 0 8
64918: PUSH
64919: LD_EXP 42
64923: PUSH
64924: LD_VAR 0 2
64928: ARRAY
64929: PPUSH
64930: LD_INT 25
64932: PUSH
64933: LD_INT 4
64935: PUSH
64936: EMPTY
64937: LIST
64938: LIST
64939: PUSH
64940: LD_INT 50
64942: PUSH
64943: EMPTY
64944: LIST
64945: PUSH
64946: LD_INT 3
64948: PUSH
64949: LD_INT 60
64951: PUSH
64952: EMPTY
64953: LIST
64954: PUSH
64955: EMPTY
64956: LIST
64957: LIST
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: LIST
64963: PPUSH
64964: CALL_OW 72
64968: PUSH
64969: LD_EXP 46
64973: PUSH
64974: LD_VAR 0 2
64978: ARRAY
64979: DIFF
64980: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64981: LD_ADDR_VAR 0 9
64985: PUSH
64986: LD_EXP 42
64990: PUSH
64991: LD_VAR 0 2
64995: ARRAY
64996: PPUSH
64997: LD_INT 2
64999: PUSH
65000: LD_INT 30
65002: PUSH
65003: LD_INT 0
65005: PUSH
65006: EMPTY
65007: LIST
65008: LIST
65009: PUSH
65010: LD_INT 30
65012: PUSH
65013: LD_INT 1
65015: PUSH
65016: EMPTY
65017: LIST
65018: LIST
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: LIST
65024: PPUSH
65025: CALL_OW 72
65029: ST_TO_ADDR
// if not tmp or not dep then
65030: LD_VAR 0 8
65034: NOT
65035: PUSH
65036: LD_VAR 0 9
65040: NOT
65041: OR
65042: IFFALSE 65046
// continue ;
65044: GO 64831
// side := GetSide ( tmp [ 1 ] ) ;
65046: LD_ADDR_VAR 0 11
65050: PUSH
65051: LD_VAR 0 8
65055: PUSH
65056: LD_INT 1
65058: ARRAY
65059: PPUSH
65060: CALL_OW 255
65064: ST_TO_ADDR
// dep := dep [ 1 ] ;
65065: LD_ADDR_VAR 0 9
65069: PUSH
65070: LD_VAR 0 9
65074: PUSH
65075: LD_INT 1
65077: ARRAY
65078: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
65079: LD_ADDR_VAR 0 7
65083: PUSH
65084: LD_EXP 70
65088: PUSH
65089: LD_VAR 0 2
65093: ARRAY
65094: PPUSH
65095: LD_INT 22
65097: PUSH
65098: LD_INT 0
65100: PUSH
65101: EMPTY
65102: LIST
65103: LIST
65104: PUSH
65105: LD_INT 25
65107: PUSH
65108: LD_INT 12
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: PUSH
65115: EMPTY
65116: LIST
65117: LIST
65118: PPUSH
65119: CALL_OW 70
65123: PUSH
65124: LD_INT 22
65126: PUSH
65127: LD_INT 0
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: PUSH
65134: LD_INT 25
65136: PUSH
65137: LD_INT 12
65139: PUSH
65140: EMPTY
65141: LIST
65142: LIST
65143: PUSH
65144: LD_INT 91
65146: PUSH
65147: LD_VAR 0 9
65151: PUSH
65152: LD_INT 20
65154: PUSH
65155: EMPTY
65156: LIST
65157: LIST
65158: LIST
65159: PUSH
65160: EMPTY
65161: LIST
65162: LIST
65163: LIST
65164: PPUSH
65165: CALL_OW 69
65169: UNION
65170: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
65171: LD_ADDR_VAR 0 10
65175: PUSH
65176: LD_EXP 70
65180: PUSH
65181: LD_VAR 0 2
65185: ARRAY
65186: PPUSH
65187: LD_INT 81
65189: PUSH
65190: LD_VAR 0 11
65194: PUSH
65195: EMPTY
65196: LIST
65197: LIST
65198: PPUSH
65199: CALL_OW 70
65203: ST_TO_ADDR
// if not apes or danger_at_area then
65204: LD_VAR 0 7
65208: NOT
65209: PUSH
65210: LD_VAR 0 10
65214: OR
65215: IFFALSE 65265
// begin if mc_taming [ i ] then
65217: LD_EXP 73
65221: PUSH
65222: LD_VAR 0 2
65226: ARRAY
65227: IFFALSE 65263
// begin MC_Reset ( i , 121 ) ;
65229: LD_VAR 0 2
65233: PPUSH
65234: LD_INT 121
65236: PPUSH
65237: CALL 50668 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65241: LD_ADDR_EXP 73
65245: PUSH
65246: LD_EXP 73
65250: PPUSH
65251: LD_VAR 0 2
65255: PPUSH
65256: EMPTY
65257: PPUSH
65258: CALL_OW 1
65262: ST_TO_ADDR
// end ; continue ;
65263: GO 64831
// end ; for j in tmp do
65265: LD_ADDR_VAR 0 3
65269: PUSH
65270: LD_VAR 0 8
65274: PUSH
65275: FOR_IN
65276: IFFALSE 65612
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
65278: LD_VAR 0 3
65282: PUSH
65283: LD_EXP 73
65287: PUSH
65288: LD_VAR 0 2
65292: ARRAY
65293: IN
65294: NOT
65295: PUSH
65296: LD_EXP 73
65300: PUSH
65301: LD_VAR 0 2
65305: ARRAY
65306: PUSH
65307: LD_INT 3
65309: LESS
65310: AND
65311: IFFALSE 65369
// begin SetTag ( j , 121 ) ;
65313: LD_VAR 0 3
65317: PPUSH
65318: LD_INT 121
65320: PPUSH
65321: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
65325: LD_ADDR_EXP 73
65329: PUSH
65330: LD_EXP 73
65334: PPUSH
65335: LD_VAR 0 2
65339: PUSH
65340: LD_EXP 73
65344: PUSH
65345: LD_VAR 0 2
65349: ARRAY
65350: PUSH
65351: LD_INT 1
65353: PLUS
65354: PUSH
65355: EMPTY
65356: LIST
65357: LIST
65358: PPUSH
65359: LD_VAR 0 3
65363: PPUSH
65364: CALL 14332 0 3
65368: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
65369: LD_VAR 0 3
65373: PUSH
65374: LD_EXP 73
65378: PUSH
65379: LD_VAR 0 2
65383: ARRAY
65384: IN
65385: IFFALSE 65610
// begin if GetClass ( j ) <> 4 then
65387: LD_VAR 0 3
65391: PPUSH
65392: CALL_OW 257
65396: PUSH
65397: LD_INT 4
65399: NONEQUAL
65400: IFFALSE 65453
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
65402: LD_ADDR_EXP 73
65406: PUSH
65407: LD_EXP 73
65411: PPUSH
65412: LD_VAR 0 2
65416: PPUSH
65417: LD_EXP 73
65421: PUSH
65422: LD_VAR 0 2
65426: ARRAY
65427: PUSH
65428: LD_VAR 0 3
65432: DIFF
65433: PPUSH
65434: CALL_OW 1
65438: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65439: LD_VAR 0 3
65443: PPUSH
65444: LD_INT 0
65446: PPUSH
65447: CALL_OW 109
// continue ;
65451: GO 65275
// end ; if IsInUnit ( j ) then
65453: LD_VAR 0 3
65457: PPUSH
65458: CALL_OW 310
65462: IFFALSE 65473
// ComExitBuilding ( j ) ;
65464: LD_VAR 0 3
65468: PPUSH
65469: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
65473: LD_ADDR_VAR 0 6
65477: PUSH
65478: LD_VAR 0 7
65482: PPUSH
65483: LD_VAR 0 3
65487: PPUSH
65488: CALL_OW 74
65492: ST_TO_ADDR
// if not ape then
65493: LD_VAR 0 6
65497: NOT
65498: IFFALSE 65502
// break ;
65500: GO 65612
// x := GetX ( ape ) ;
65502: LD_ADDR_VAR 0 4
65506: PUSH
65507: LD_VAR 0 6
65511: PPUSH
65512: CALL_OW 250
65516: ST_TO_ADDR
// y := GetY ( ape ) ;
65517: LD_ADDR_VAR 0 5
65521: PUSH
65522: LD_VAR 0 6
65526: PPUSH
65527: CALL_OW 251
65531: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65532: LD_VAR 0 4
65536: PPUSH
65537: LD_VAR 0 5
65541: PPUSH
65542: CALL_OW 488
65546: NOT
65547: PUSH
65548: LD_VAR 0 11
65552: PPUSH
65553: LD_VAR 0 4
65557: PPUSH
65558: LD_VAR 0 5
65562: PPUSH
65563: LD_INT 20
65565: PPUSH
65566: CALL 15228 0 4
65570: PUSH
65571: LD_INT 4
65573: ARRAY
65574: OR
65575: IFFALSE 65579
// break ;
65577: GO 65612
// if not HasTask ( j ) then
65579: LD_VAR 0 3
65583: PPUSH
65584: CALL_OW 314
65588: NOT
65589: IFFALSE 65610
// ComTameXY ( j , x , y ) ;
65591: LD_VAR 0 3
65595: PPUSH
65596: LD_VAR 0 4
65600: PPUSH
65601: LD_VAR 0 5
65605: PPUSH
65606: CALL_OW 131
// end ; end ;
65610: GO 65275
65612: POP
65613: POP
// end ;
65614: GO 64831
65616: POP
65617: POP
// end ;
65618: LD_VAR 0 1
65622: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
65623: LD_INT 0
65625: PPUSH
65626: PPUSH
65627: PPUSH
65628: PPUSH
65629: PPUSH
65630: PPUSH
65631: PPUSH
65632: PPUSH
// if not mc_bases then
65633: LD_EXP 42
65637: NOT
65638: IFFALSE 65642
// exit ;
65640: GO 66268
// for i = 1 to mc_bases do
65642: LD_ADDR_VAR 0 2
65646: PUSH
65647: DOUBLE
65648: LD_INT 1
65650: DEC
65651: ST_TO_ADDR
65652: LD_EXP 42
65656: PUSH
65657: FOR_TO
65658: IFFALSE 66266
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
65660: LD_EXP 71
65664: PUSH
65665: LD_VAR 0 2
65669: ARRAY
65670: NOT
65671: PUSH
65672: LD_EXP 71
65676: PUSH
65677: LD_VAR 0 2
65681: ARRAY
65682: PPUSH
65683: LD_INT 25
65685: PUSH
65686: LD_INT 12
65688: PUSH
65689: EMPTY
65690: LIST
65691: LIST
65692: PPUSH
65693: CALL_OW 72
65697: NOT
65698: OR
65699: IFFALSE 65703
// continue ;
65701: GO 65657
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
65703: LD_ADDR_VAR 0 5
65707: PUSH
65708: LD_EXP 71
65712: PUSH
65713: LD_VAR 0 2
65717: ARRAY
65718: PUSH
65719: LD_INT 1
65721: ARRAY
65722: PPUSH
65723: CALL_OW 255
65727: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
65728: LD_VAR 0 5
65732: PPUSH
65733: LD_INT 2
65735: PPUSH
65736: CALL_OW 325
65740: IFFALSE 65993
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
65742: LD_ADDR_VAR 0 4
65746: PUSH
65747: LD_EXP 71
65751: PUSH
65752: LD_VAR 0 2
65756: ARRAY
65757: PPUSH
65758: LD_INT 25
65760: PUSH
65761: LD_INT 16
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: PPUSH
65768: CALL_OW 72
65772: ST_TO_ADDR
// if tmp < 6 then
65773: LD_VAR 0 4
65777: PUSH
65778: LD_INT 6
65780: LESS
65781: IFFALSE 65993
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65783: LD_ADDR_VAR 0 6
65787: PUSH
65788: LD_EXP 42
65792: PUSH
65793: LD_VAR 0 2
65797: ARRAY
65798: PPUSH
65799: LD_INT 2
65801: PUSH
65802: LD_INT 30
65804: PUSH
65805: LD_INT 0
65807: PUSH
65808: EMPTY
65809: LIST
65810: LIST
65811: PUSH
65812: LD_INT 30
65814: PUSH
65815: LD_INT 1
65817: PUSH
65818: EMPTY
65819: LIST
65820: LIST
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: LIST
65826: PPUSH
65827: CALL_OW 72
65831: ST_TO_ADDR
// if depot then
65832: LD_VAR 0 6
65836: IFFALSE 65993
// begin selected := 0 ;
65838: LD_ADDR_VAR 0 7
65842: PUSH
65843: LD_INT 0
65845: ST_TO_ADDR
// for j in depot do
65846: LD_ADDR_VAR 0 3
65850: PUSH
65851: LD_VAR 0 6
65855: PUSH
65856: FOR_IN
65857: IFFALSE 65888
// begin if UnitsInside ( j ) < 6 then
65859: LD_VAR 0 3
65863: PPUSH
65864: CALL_OW 313
65868: PUSH
65869: LD_INT 6
65871: LESS
65872: IFFALSE 65886
// begin selected := j ;
65874: LD_ADDR_VAR 0 7
65878: PUSH
65879: LD_VAR 0 3
65883: ST_TO_ADDR
// break ;
65884: GO 65888
// end ; end ;
65886: GO 65856
65888: POP
65889: POP
// if selected then
65890: LD_VAR 0 7
65894: IFFALSE 65993
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
65896: LD_ADDR_VAR 0 3
65900: PUSH
65901: LD_EXP 71
65905: PUSH
65906: LD_VAR 0 2
65910: ARRAY
65911: PPUSH
65912: LD_INT 25
65914: PUSH
65915: LD_INT 12
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PPUSH
65922: CALL_OW 72
65926: PUSH
65927: FOR_IN
65928: IFFALSE 65991
// if not HasTask ( j ) then
65930: LD_VAR 0 3
65934: PPUSH
65935: CALL_OW 314
65939: NOT
65940: IFFALSE 65989
// begin if not IsInUnit ( j ) then
65942: LD_VAR 0 3
65946: PPUSH
65947: CALL_OW 310
65951: NOT
65952: IFFALSE 65968
// ComEnterUnit ( j , selected ) ;
65954: LD_VAR 0 3
65958: PPUSH
65959: LD_VAR 0 7
65963: PPUSH
65964: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
65968: LD_VAR 0 3
65972: PPUSH
65973: LD_INT 16
65975: PPUSH
65976: CALL_OW 183
// AddComExitBuilding ( j ) ;
65980: LD_VAR 0 3
65984: PPUSH
65985: CALL_OW 182
// end ;
65989: GO 65927
65991: POP
65992: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
65993: LD_VAR 0 5
65997: PPUSH
65998: LD_INT 11
66000: PPUSH
66001: CALL_OW 325
66005: IFFALSE 66264
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66007: LD_ADDR_VAR 0 4
66011: PUSH
66012: LD_EXP 71
66016: PUSH
66017: LD_VAR 0 2
66021: ARRAY
66022: PPUSH
66023: LD_INT 25
66025: PUSH
66026: LD_INT 16
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: PPUSH
66033: CALL_OW 72
66037: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
66038: LD_VAR 0 4
66042: PUSH
66043: LD_INT 6
66045: GREATEREQUAL
66046: PUSH
66047: LD_VAR 0 5
66051: PPUSH
66052: LD_INT 2
66054: PPUSH
66055: CALL_OW 325
66059: NOT
66060: OR
66061: IFFALSE 66264
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66063: LD_ADDR_VAR 0 8
66067: PUSH
66068: LD_EXP 42
66072: PUSH
66073: LD_VAR 0 2
66077: ARRAY
66078: PPUSH
66079: LD_INT 2
66081: PUSH
66082: LD_INT 30
66084: PUSH
66085: LD_INT 4
66087: PUSH
66088: EMPTY
66089: LIST
66090: LIST
66091: PUSH
66092: LD_INT 30
66094: PUSH
66095: LD_INT 5
66097: PUSH
66098: EMPTY
66099: LIST
66100: LIST
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: LIST
66106: PPUSH
66107: CALL_OW 72
66111: ST_TO_ADDR
// if barracks then
66112: LD_VAR 0 8
66116: IFFALSE 66264
// begin selected := 0 ;
66118: LD_ADDR_VAR 0 7
66122: PUSH
66123: LD_INT 0
66125: ST_TO_ADDR
// for j in barracks do
66126: LD_ADDR_VAR 0 3
66130: PUSH
66131: LD_VAR 0 8
66135: PUSH
66136: FOR_IN
66137: IFFALSE 66168
// begin if UnitsInside ( j ) < 6 then
66139: LD_VAR 0 3
66143: PPUSH
66144: CALL_OW 313
66148: PUSH
66149: LD_INT 6
66151: LESS
66152: IFFALSE 66166
// begin selected := j ;
66154: LD_ADDR_VAR 0 7
66158: PUSH
66159: LD_VAR 0 3
66163: ST_TO_ADDR
// break ;
66164: GO 66168
// end ; end ;
66166: GO 66136
66168: POP
66169: POP
// if selected then
66170: LD_VAR 0 7
66174: IFFALSE 66264
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66176: LD_ADDR_VAR 0 3
66180: PUSH
66181: LD_EXP 71
66185: PUSH
66186: LD_VAR 0 2
66190: ARRAY
66191: PPUSH
66192: LD_INT 25
66194: PUSH
66195: LD_INT 12
66197: PUSH
66198: EMPTY
66199: LIST
66200: LIST
66201: PPUSH
66202: CALL_OW 72
66206: PUSH
66207: FOR_IN
66208: IFFALSE 66262
// if not IsInUnit ( j ) and not HasTask ( j ) then
66210: LD_VAR 0 3
66214: PPUSH
66215: CALL_OW 310
66219: NOT
66220: PUSH
66221: LD_VAR 0 3
66225: PPUSH
66226: CALL_OW 314
66230: NOT
66231: AND
66232: IFFALSE 66260
// begin ComEnterUnit ( j , selected ) ;
66234: LD_VAR 0 3
66238: PPUSH
66239: LD_VAR 0 7
66243: PPUSH
66244: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
66248: LD_VAR 0 3
66252: PPUSH
66253: LD_INT 15
66255: PPUSH
66256: CALL_OW 183
// end ;
66260: GO 66207
66262: POP
66263: POP
// end ; end ; end ; end ; end ;
66264: GO 65657
66266: POP
66267: POP
// end ;
66268: LD_VAR 0 1
66272: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
66273: LD_INT 0
66275: PPUSH
66276: PPUSH
66277: PPUSH
66278: PPUSH
// if not mc_bases then
66279: LD_EXP 42
66283: NOT
66284: IFFALSE 66288
// exit ;
66286: GO 66466
// for i = 1 to mc_bases do
66288: LD_ADDR_VAR 0 2
66292: PUSH
66293: DOUBLE
66294: LD_INT 1
66296: DEC
66297: ST_TO_ADDR
66298: LD_EXP 42
66302: PUSH
66303: FOR_TO
66304: IFFALSE 66464
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
66306: LD_ADDR_VAR 0 4
66310: PUSH
66311: LD_EXP 42
66315: PUSH
66316: LD_VAR 0 2
66320: ARRAY
66321: PPUSH
66322: LD_INT 25
66324: PUSH
66325: LD_INT 9
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PPUSH
66332: CALL_OW 72
66336: ST_TO_ADDR
// if not tmp then
66337: LD_VAR 0 4
66341: NOT
66342: IFFALSE 66346
// continue ;
66344: GO 66303
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
66346: LD_EXP 68
66350: PUSH
66351: LD_VAR 0 2
66355: ARRAY
66356: PPUSH
66357: LD_INT 29
66359: PPUSH
66360: CALL_OW 325
66364: NOT
66365: PUSH
66366: LD_EXP 68
66370: PUSH
66371: LD_VAR 0 2
66375: ARRAY
66376: PPUSH
66377: LD_INT 28
66379: PPUSH
66380: CALL_OW 325
66384: NOT
66385: AND
66386: IFFALSE 66390
// continue ;
66388: GO 66303
// for j in tmp do
66390: LD_ADDR_VAR 0 3
66394: PUSH
66395: LD_VAR 0 4
66399: PUSH
66400: FOR_IN
66401: IFFALSE 66460
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
66403: LD_VAR 0 3
66407: PUSH
66408: LD_EXP 45
66412: PUSH
66413: LD_VAR 0 2
66417: ARRAY
66418: PUSH
66419: LD_INT 1
66421: ARRAY
66422: IN
66423: NOT
66424: PUSH
66425: LD_VAR 0 3
66429: PUSH
66430: LD_EXP 45
66434: PUSH
66435: LD_VAR 0 2
66439: ARRAY
66440: PUSH
66441: LD_INT 2
66443: ARRAY
66444: IN
66445: NOT
66446: AND
66447: IFFALSE 66458
// ComSpaceTimeShoot ( j ) ;
66449: LD_VAR 0 3
66453: PPUSH
66454: CALL 10329 0 1
66458: GO 66400
66460: POP
66461: POP
// end ;
66462: GO 66303
66464: POP
66465: POP
// end ;
66466: LD_VAR 0 1
66470: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
66471: LD_INT 0
66473: PPUSH
66474: PPUSH
66475: PPUSH
66476: PPUSH
66477: PPUSH
66478: PPUSH
66479: PPUSH
66480: PPUSH
66481: PPUSH
// if not mc_bases then
66482: LD_EXP 42
66486: NOT
66487: IFFALSE 66491
// exit ;
66489: GO 67113
// for i = 1 to mc_bases do
66491: LD_ADDR_VAR 0 2
66495: PUSH
66496: DOUBLE
66497: LD_INT 1
66499: DEC
66500: ST_TO_ADDR
66501: LD_EXP 42
66505: PUSH
66506: FOR_TO
66507: IFFALSE 67111
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
66509: LD_EXP 77
66513: PUSH
66514: LD_VAR 0 2
66518: ARRAY
66519: NOT
66520: PUSH
66521: LD_INT 38
66523: PPUSH
66524: LD_EXP 68
66528: PUSH
66529: LD_VAR 0 2
66533: ARRAY
66534: PPUSH
66535: CALL_OW 321
66539: PUSH
66540: LD_INT 2
66542: NONEQUAL
66543: OR
66544: IFFALSE 66548
// continue ;
66546: GO 66506
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
66548: LD_ADDR_VAR 0 8
66552: PUSH
66553: LD_EXP 42
66557: PUSH
66558: LD_VAR 0 2
66562: ARRAY
66563: PPUSH
66564: LD_INT 30
66566: PUSH
66567: LD_INT 34
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PPUSH
66574: CALL_OW 72
66578: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
66579: LD_ADDR_VAR 0 9
66583: PUSH
66584: LD_EXP 42
66588: PUSH
66589: LD_VAR 0 2
66593: ARRAY
66594: PPUSH
66595: LD_INT 25
66597: PUSH
66598: LD_INT 4
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PPUSH
66605: CALL_OW 72
66609: PPUSH
66610: LD_INT 0
66612: PPUSH
66613: CALL 42893 0 2
66617: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
66618: LD_VAR 0 9
66622: NOT
66623: PUSH
66624: LD_VAR 0 8
66628: NOT
66629: OR
66630: PUSH
66631: LD_EXP 42
66635: PUSH
66636: LD_VAR 0 2
66640: ARRAY
66641: PPUSH
66642: LD_INT 124
66644: PPUSH
66645: CALL 42893 0 2
66649: OR
66650: IFFALSE 66654
// continue ;
66652: GO 66506
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
66654: LD_EXP 78
66658: PUSH
66659: LD_VAR 0 2
66663: ARRAY
66664: PUSH
66665: LD_EXP 77
66669: PUSH
66670: LD_VAR 0 2
66674: ARRAY
66675: LESS
66676: PUSH
66677: LD_EXP 78
66681: PUSH
66682: LD_VAR 0 2
66686: ARRAY
66687: PUSH
66688: LD_VAR 0 8
66692: LESS
66693: AND
66694: IFFALSE 67109
// begin tmp := sci [ 1 ] ;
66696: LD_ADDR_VAR 0 7
66700: PUSH
66701: LD_VAR 0 9
66705: PUSH
66706: LD_INT 1
66708: ARRAY
66709: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
66710: LD_VAR 0 7
66714: PPUSH
66715: LD_INT 124
66717: PPUSH
66718: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
66722: LD_ADDR_VAR 0 3
66726: PUSH
66727: DOUBLE
66728: LD_EXP 77
66732: PUSH
66733: LD_VAR 0 2
66737: ARRAY
66738: INC
66739: ST_TO_ADDR
66740: LD_EXP 77
66744: PUSH
66745: LD_VAR 0 2
66749: ARRAY
66750: PUSH
66751: FOR_DOWNTO
66752: IFFALSE 67095
// begin if IsInUnit ( tmp ) then
66754: LD_VAR 0 7
66758: PPUSH
66759: CALL_OW 310
66763: IFFALSE 66774
// ComExitBuilding ( tmp ) ;
66765: LD_VAR 0 7
66769: PPUSH
66770: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
66774: LD_INT 35
66776: PPUSH
66777: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
66781: LD_VAR 0 7
66785: PPUSH
66786: CALL_OW 310
66790: NOT
66791: PUSH
66792: LD_VAR 0 7
66796: PPUSH
66797: CALL_OW 314
66801: NOT
66802: AND
66803: IFFALSE 66774
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
66805: LD_ADDR_VAR 0 6
66809: PUSH
66810: LD_VAR 0 7
66814: PPUSH
66815: CALL_OW 250
66819: PUSH
66820: LD_VAR 0 7
66824: PPUSH
66825: CALL_OW 251
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
66834: LD_INT 35
66836: PPUSH
66837: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
66841: LD_ADDR_VAR 0 4
66845: PUSH
66846: LD_EXP 77
66850: PUSH
66851: LD_VAR 0 2
66855: ARRAY
66856: PUSH
66857: LD_VAR 0 3
66861: ARRAY
66862: PUSH
66863: LD_INT 1
66865: ARRAY
66866: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
66867: LD_ADDR_VAR 0 5
66871: PUSH
66872: LD_EXP 77
66876: PUSH
66877: LD_VAR 0 2
66881: ARRAY
66882: PUSH
66883: LD_VAR 0 3
66887: ARRAY
66888: PUSH
66889: LD_INT 2
66891: ARRAY
66892: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
66893: LD_VAR 0 7
66897: PPUSH
66898: LD_INT 10
66900: PPUSH
66901: CALL 16925 0 2
66905: PUSH
66906: LD_INT 4
66908: ARRAY
66909: IFFALSE 66947
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
66911: LD_VAR 0 7
66915: PPUSH
66916: LD_VAR 0 6
66920: PUSH
66921: LD_INT 1
66923: ARRAY
66924: PPUSH
66925: LD_VAR 0 6
66929: PUSH
66930: LD_INT 2
66932: ARRAY
66933: PPUSH
66934: CALL_OW 111
// wait ( 0 0$10 ) ;
66938: LD_INT 350
66940: PPUSH
66941: CALL_OW 67
// end else
66945: GO 66973
// begin ComMoveXY ( tmp , x , y ) ;
66947: LD_VAR 0 7
66951: PPUSH
66952: LD_VAR 0 4
66956: PPUSH
66957: LD_VAR 0 5
66961: PPUSH
66962: CALL_OW 111
// wait ( 0 0$3 ) ;
66966: LD_INT 105
66968: PPUSH
66969: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
66973: LD_VAR 0 7
66977: PPUSH
66978: LD_VAR 0 4
66982: PPUSH
66983: LD_VAR 0 5
66987: PPUSH
66988: CALL_OW 307
66992: IFFALSE 66834
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
66994: LD_VAR 0 7
66998: PPUSH
66999: LD_VAR 0 4
67003: PPUSH
67004: LD_VAR 0 5
67008: PPUSH
67009: LD_VAR 0 8
67013: PUSH
67014: LD_VAR 0 3
67018: ARRAY
67019: PPUSH
67020: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
67024: LD_INT 35
67026: PPUSH
67027: CALL_OW 67
// until not HasTask ( tmp ) ;
67031: LD_VAR 0 7
67035: PPUSH
67036: CALL_OW 314
67040: NOT
67041: IFFALSE 67024
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
67043: LD_ADDR_EXP 78
67047: PUSH
67048: LD_EXP 78
67052: PPUSH
67053: LD_VAR 0 2
67057: PUSH
67058: LD_EXP 78
67062: PUSH
67063: LD_VAR 0 2
67067: ARRAY
67068: PUSH
67069: LD_INT 1
67071: PLUS
67072: PUSH
67073: EMPTY
67074: LIST
67075: LIST
67076: PPUSH
67077: LD_VAR 0 8
67081: PUSH
67082: LD_VAR 0 3
67086: ARRAY
67087: PPUSH
67088: CALL 14332 0 3
67092: ST_TO_ADDR
// end ;
67093: GO 66751
67095: POP
67096: POP
// MC_Reset ( i , 124 ) ;
67097: LD_VAR 0 2
67101: PPUSH
67102: LD_INT 124
67104: PPUSH
67105: CALL 50668 0 2
// end ; end ;
67109: GO 66506
67111: POP
67112: POP
// end ;
67113: LD_VAR 0 1
67117: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
67118: LD_INT 0
67120: PPUSH
67121: PPUSH
67122: PPUSH
// if not mc_bases then
67123: LD_EXP 42
67127: NOT
67128: IFFALSE 67132
// exit ;
67130: GO 67738
// for i = 1 to mc_bases do
67132: LD_ADDR_VAR 0 2
67136: PUSH
67137: DOUBLE
67138: LD_INT 1
67140: DEC
67141: ST_TO_ADDR
67142: LD_EXP 42
67146: PUSH
67147: FOR_TO
67148: IFFALSE 67736
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67150: LD_ADDR_VAR 0 3
67154: PUSH
67155: LD_EXP 42
67159: PUSH
67160: LD_VAR 0 2
67164: ARRAY
67165: PPUSH
67166: LD_INT 25
67168: PUSH
67169: LD_INT 4
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PPUSH
67176: CALL_OW 72
67180: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67181: LD_VAR 0 3
67185: NOT
67186: PUSH
67187: LD_EXP 79
67191: PUSH
67192: LD_VAR 0 2
67196: ARRAY
67197: NOT
67198: OR
67199: PUSH
67200: LD_EXP 42
67204: PUSH
67205: LD_VAR 0 2
67209: ARRAY
67210: PPUSH
67211: LD_INT 2
67213: PUSH
67214: LD_INT 30
67216: PUSH
67217: LD_INT 0
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 30
67226: PUSH
67227: LD_INT 1
67229: PUSH
67230: EMPTY
67231: LIST
67232: LIST
67233: PUSH
67234: EMPTY
67235: LIST
67236: LIST
67237: LIST
67238: PPUSH
67239: CALL_OW 72
67243: NOT
67244: OR
67245: IFFALSE 67295
// begin if mc_deposits_finder [ i ] then
67247: LD_EXP 80
67251: PUSH
67252: LD_VAR 0 2
67256: ARRAY
67257: IFFALSE 67293
// begin MC_Reset ( i , 125 ) ;
67259: LD_VAR 0 2
67263: PPUSH
67264: LD_INT 125
67266: PPUSH
67267: CALL 50668 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67271: LD_ADDR_EXP 80
67275: PUSH
67276: LD_EXP 80
67280: PPUSH
67281: LD_VAR 0 2
67285: PPUSH
67286: EMPTY
67287: PPUSH
67288: CALL_OW 1
67292: ST_TO_ADDR
// end ; continue ;
67293: GO 67147
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
67295: LD_EXP 79
67299: PUSH
67300: LD_VAR 0 2
67304: ARRAY
67305: PUSH
67306: LD_INT 1
67308: ARRAY
67309: PUSH
67310: LD_INT 3
67312: ARRAY
67313: PUSH
67314: LD_INT 1
67316: EQUAL
67317: PUSH
67318: LD_INT 20
67320: PPUSH
67321: LD_EXP 68
67325: PUSH
67326: LD_VAR 0 2
67330: ARRAY
67331: PPUSH
67332: CALL_OW 321
67336: PUSH
67337: LD_INT 2
67339: NONEQUAL
67340: AND
67341: IFFALSE 67391
// begin if mc_deposits_finder [ i ] then
67343: LD_EXP 80
67347: PUSH
67348: LD_VAR 0 2
67352: ARRAY
67353: IFFALSE 67389
// begin MC_Reset ( i , 125 ) ;
67355: LD_VAR 0 2
67359: PPUSH
67360: LD_INT 125
67362: PPUSH
67363: CALL 50668 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67367: LD_ADDR_EXP 80
67371: PUSH
67372: LD_EXP 80
67376: PPUSH
67377: LD_VAR 0 2
67381: PPUSH
67382: EMPTY
67383: PPUSH
67384: CALL_OW 1
67388: ST_TO_ADDR
// end ; continue ;
67389: GO 67147
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
67391: LD_EXP 79
67395: PUSH
67396: LD_VAR 0 2
67400: ARRAY
67401: PUSH
67402: LD_INT 1
67404: ARRAY
67405: PUSH
67406: LD_INT 1
67408: ARRAY
67409: PPUSH
67410: LD_EXP 79
67414: PUSH
67415: LD_VAR 0 2
67419: ARRAY
67420: PUSH
67421: LD_INT 1
67423: ARRAY
67424: PUSH
67425: LD_INT 2
67427: ARRAY
67428: PPUSH
67429: LD_EXP 68
67433: PUSH
67434: LD_VAR 0 2
67438: ARRAY
67439: PPUSH
67440: CALL_OW 440
67444: IFFALSE 67487
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
67446: LD_ADDR_EXP 79
67450: PUSH
67451: LD_EXP 79
67455: PPUSH
67456: LD_VAR 0 2
67460: PPUSH
67461: LD_EXP 79
67465: PUSH
67466: LD_VAR 0 2
67470: ARRAY
67471: PPUSH
67472: LD_INT 1
67474: PPUSH
67475: CALL_OW 3
67479: PPUSH
67480: CALL_OW 1
67484: ST_TO_ADDR
67485: GO 67734
// begin if not mc_deposits_finder [ i ] then
67487: LD_EXP 80
67491: PUSH
67492: LD_VAR 0 2
67496: ARRAY
67497: NOT
67498: IFFALSE 67550
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
67500: LD_ADDR_EXP 80
67504: PUSH
67505: LD_EXP 80
67509: PPUSH
67510: LD_VAR 0 2
67514: PPUSH
67515: LD_VAR 0 3
67519: PUSH
67520: LD_INT 1
67522: ARRAY
67523: PUSH
67524: EMPTY
67525: LIST
67526: PPUSH
67527: CALL_OW 1
67531: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
67532: LD_VAR 0 3
67536: PUSH
67537: LD_INT 1
67539: ARRAY
67540: PPUSH
67541: LD_INT 125
67543: PPUSH
67544: CALL_OW 109
// end else
67548: GO 67734
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
67550: LD_EXP 80
67554: PUSH
67555: LD_VAR 0 2
67559: ARRAY
67560: PUSH
67561: LD_INT 1
67563: ARRAY
67564: PPUSH
67565: CALL_OW 310
67569: IFFALSE 67592
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
67571: LD_EXP 80
67575: PUSH
67576: LD_VAR 0 2
67580: ARRAY
67581: PUSH
67582: LD_INT 1
67584: ARRAY
67585: PPUSH
67586: CALL_OW 122
67590: GO 67734
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
67592: LD_EXP 80
67596: PUSH
67597: LD_VAR 0 2
67601: ARRAY
67602: PUSH
67603: LD_INT 1
67605: ARRAY
67606: PPUSH
67607: CALL_OW 314
67611: NOT
67612: PUSH
67613: LD_EXP 80
67617: PUSH
67618: LD_VAR 0 2
67622: ARRAY
67623: PUSH
67624: LD_INT 1
67626: ARRAY
67627: PPUSH
67628: LD_EXP 79
67632: PUSH
67633: LD_VAR 0 2
67637: ARRAY
67638: PUSH
67639: LD_INT 1
67641: ARRAY
67642: PUSH
67643: LD_INT 1
67645: ARRAY
67646: PPUSH
67647: LD_EXP 79
67651: PUSH
67652: LD_VAR 0 2
67656: ARRAY
67657: PUSH
67658: LD_INT 1
67660: ARRAY
67661: PUSH
67662: LD_INT 2
67664: ARRAY
67665: PPUSH
67666: CALL_OW 297
67670: PUSH
67671: LD_INT 6
67673: GREATER
67674: AND
67675: IFFALSE 67734
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
67677: LD_EXP 80
67681: PUSH
67682: LD_VAR 0 2
67686: ARRAY
67687: PUSH
67688: LD_INT 1
67690: ARRAY
67691: PPUSH
67692: LD_EXP 79
67696: PUSH
67697: LD_VAR 0 2
67701: ARRAY
67702: PUSH
67703: LD_INT 1
67705: ARRAY
67706: PUSH
67707: LD_INT 1
67709: ARRAY
67710: PPUSH
67711: LD_EXP 79
67715: PUSH
67716: LD_VAR 0 2
67720: ARRAY
67721: PUSH
67722: LD_INT 1
67724: ARRAY
67725: PUSH
67726: LD_INT 2
67728: ARRAY
67729: PPUSH
67730: CALL_OW 111
// end ; end ; end ;
67734: GO 67147
67736: POP
67737: POP
// end ;
67738: LD_VAR 0 1
67742: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
67743: LD_INT 0
67745: PPUSH
67746: PPUSH
67747: PPUSH
67748: PPUSH
67749: PPUSH
67750: PPUSH
67751: PPUSH
67752: PPUSH
67753: PPUSH
67754: PPUSH
67755: PPUSH
// if not mc_bases then
67756: LD_EXP 42
67760: NOT
67761: IFFALSE 67765
// exit ;
67763: GO 68705
// for i = 1 to mc_bases do
67765: LD_ADDR_VAR 0 2
67769: PUSH
67770: DOUBLE
67771: LD_INT 1
67773: DEC
67774: ST_TO_ADDR
67775: LD_EXP 42
67779: PUSH
67780: FOR_TO
67781: IFFALSE 68703
// begin if not mc_bases [ i ] or mc_scan [ i ] then
67783: LD_EXP 42
67787: PUSH
67788: LD_VAR 0 2
67792: ARRAY
67793: NOT
67794: PUSH
67795: LD_EXP 65
67799: PUSH
67800: LD_VAR 0 2
67804: ARRAY
67805: OR
67806: IFFALSE 67810
// continue ;
67808: GO 67780
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
67810: LD_ADDR_VAR 0 7
67814: PUSH
67815: LD_EXP 42
67819: PUSH
67820: LD_VAR 0 2
67824: ARRAY
67825: PUSH
67826: LD_INT 1
67828: ARRAY
67829: PPUSH
67830: CALL_OW 248
67834: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
67835: LD_VAR 0 7
67839: PUSH
67840: LD_INT 3
67842: EQUAL
67843: PUSH
67844: LD_EXP 61
67848: PUSH
67849: LD_VAR 0 2
67853: ARRAY
67854: PUSH
67855: LD_EXP 64
67859: PUSH
67860: LD_VAR 0 2
67864: ARRAY
67865: UNION
67866: PPUSH
67867: LD_INT 33
67869: PUSH
67870: LD_INT 2
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PPUSH
67877: CALL_OW 72
67881: NOT
67882: OR
67883: IFFALSE 67887
// continue ;
67885: GO 67780
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
67887: LD_ADDR_VAR 0 9
67891: PUSH
67892: LD_EXP 42
67896: PUSH
67897: LD_VAR 0 2
67901: ARRAY
67902: PPUSH
67903: LD_INT 30
67905: PUSH
67906: LD_INT 36
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: PPUSH
67913: CALL_OW 72
67917: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
67918: LD_ADDR_VAR 0 10
67922: PUSH
67923: LD_EXP 61
67927: PUSH
67928: LD_VAR 0 2
67932: ARRAY
67933: PPUSH
67934: LD_INT 34
67936: PUSH
67937: LD_INT 31
67939: PUSH
67940: EMPTY
67941: LIST
67942: LIST
67943: PPUSH
67944: CALL_OW 72
67948: ST_TO_ADDR
// if not cts and not mcts then
67949: LD_VAR 0 9
67953: NOT
67954: PUSH
67955: LD_VAR 0 10
67959: NOT
67960: AND
67961: IFFALSE 67965
// continue ;
67963: GO 67780
// x := cts ;
67965: LD_ADDR_VAR 0 11
67969: PUSH
67970: LD_VAR 0 9
67974: ST_TO_ADDR
// if not x then
67975: LD_VAR 0 11
67979: NOT
67980: IFFALSE 67992
// x := mcts ;
67982: LD_ADDR_VAR 0 11
67986: PUSH
67987: LD_VAR 0 10
67991: ST_TO_ADDR
// if not x then
67992: LD_VAR 0 11
67996: NOT
67997: IFFALSE 68001
// continue ;
67999: GO 67780
// if mc_remote_driver [ i ] then
68001: LD_EXP 82
68005: PUSH
68006: LD_VAR 0 2
68010: ARRAY
68011: IFFALSE 68398
// for j in mc_remote_driver [ i ] do
68013: LD_ADDR_VAR 0 3
68017: PUSH
68018: LD_EXP 82
68022: PUSH
68023: LD_VAR 0 2
68027: ARRAY
68028: PUSH
68029: FOR_IN
68030: IFFALSE 68396
// begin if GetClass ( j ) <> 3 then
68032: LD_VAR 0 3
68036: PPUSH
68037: CALL_OW 257
68041: PUSH
68042: LD_INT 3
68044: NONEQUAL
68045: IFFALSE 68098
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
68047: LD_ADDR_EXP 82
68051: PUSH
68052: LD_EXP 82
68056: PPUSH
68057: LD_VAR 0 2
68061: PPUSH
68062: LD_EXP 82
68066: PUSH
68067: LD_VAR 0 2
68071: ARRAY
68072: PUSH
68073: LD_VAR 0 3
68077: DIFF
68078: PPUSH
68079: CALL_OW 1
68083: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68084: LD_VAR 0 3
68088: PPUSH
68089: LD_INT 0
68091: PPUSH
68092: CALL_OW 109
// continue ;
68096: GO 68029
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
68098: LD_EXP 61
68102: PUSH
68103: LD_VAR 0 2
68107: ARRAY
68108: PPUSH
68109: LD_INT 34
68111: PUSH
68112: LD_INT 31
68114: PUSH
68115: EMPTY
68116: LIST
68117: LIST
68118: PUSH
68119: LD_INT 58
68121: PUSH
68122: EMPTY
68123: LIST
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PPUSH
68129: CALL_OW 72
68133: PUSH
68134: LD_VAR 0 3
68138: PPUSH
68139: CALL 42981 0 1
68143: NOT
68144: AND
68145: IFFALSE 68216
// begin if IsInUnit ( j ) then
68147: LD_VAR 0 3
68151: PPUSH
68152: CALL_OW 310
68156: IFFALSE 68167
// ComExitBuilding ( j ) ;
68158: LD_VAR 0 3
68162: PPUSH
68163: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
68167: LD_VAR 0 3
68171: PPUSH
68172: LD_EXP 61
68176: PUSH
68177: LD_VAR 0 2
68181: ARRAY
68182: PPUSH
68183: LD_INT 34
68185: PUSH
68186: LD_INT 31
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 58
68195: PUSH
68196: EMPTY
68197: LIST
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PPUSH
68203: CALL_OW 72
68207: PUSH
68208: LD_INT 1
68210: ARRAY
68211: PPUSH
68212: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
68216: LD_VAR 0 3
68220: PPUSH
68221: CALL_OW 310
68225: NOT
68226: PUSH
68227: LD_VAR 0 3
68231: PPUSH
68232: CALL_OW 310
68236: PPUSH
68237: CALL_OW 266
68241: PUSH
68242: LD_INT 36
68244: NONEQUAL
68245: PUSH
68246: LD_VAR 0 3
68250: PPUSH
68251: CALL 42981 0 1
68255: NOT
68256: AND
68257: OR
68258: IFFALSE 68394
// begin if IsInUnit ( j ) then
68260: LD_VAR 0 3
68264: PPUSH
68265: CALL_OW 310
68269: IFFALSE 68280
// ComExitBuilding ( j ) ;
68271: LD_VAR 0 3
68275: PPUSH
68276: CALL_OW 122
// ct := 0 ;
68280: LD_ADDR_VAR 0 8
68284: PUSH
68285: LD_INT 0
68287: ST_TO_ADDR
// for k in x do
68288: LD_ADDR_VAR 0 4
68292: PUSH
68293: LD_VAR 0 11
68297: PUSH
68298: FOR_IN
68299: IFFALSE 68372
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
68301: LD_VAR 0 4
68305: PPUSH
68306: CALL_OW 264
68310: PUSH
68311: LD_INT 31
68313: EQUAL
68314: PUSH
68315: LD_VAR 0 4
68319: PPUSH
68320: CALL_OW 311
68324: NOT
68325: AND
68326: PUSH
68327: LD_VAR 0 4
68331: PPUSH
68332: CALL_OW 266
68336: PUSH
68337: LD_INT 36
68339: EQUAL
68340: PUSH
68341: LD_VAR 0 4
68345: PPUSH
68346: CALL_OW 313
68350: PUSH
68351: LD_INT 3
68353: LESS
68354: AND
68355: OR
68356: IFFALSE 68370
// begin ct := k ;
68358: LD_ADDR_VAR 0 8
68362: PUSH
68363: LD_VAR 0 4
68367: ST_TO_ADDR
// break ;
68368: GO 68372
// end ;
68370: GO 68298
68372: POP
68373: POP
// if ct then
68374: LD_VAR 0 8
68378: IFFALSE 68394
// ComEnterUnit ( j , ct ) ;
68380: LD_VAR 0 3
68384: PPUSH
68385: LD_VAR 0 8
68389: PPUSH
68390: CALL_OW 120
// end ; end ;
68394: GO 68029
68396: POP
68397: POP
// places := 0 ;
68398: LD_ADDR_VAR 0 5
68402: PUSH
68403: LD_INT 0
68405: ST_TO_ADDR
// for j = 1 to x do
68406: LD_ADDR_VAR 0 3
68410: PUSH
68411: DOUBLE
68412: LD_INT 1
68414: DEC
68415: ST_TO_ADDR
68416: LD_VAR 0 11
68420: PUSH
68421: FOR_TO
68422: IFFALSE 68498
// if GetWeapon ( x [ j ] ) = ar_control_tower then
68424: LD_VAR 0 11
68428: PUSH
68429: LD_VAR 0 3
68433: ARRAY
68434: PPUSH
68435: CALL_OW 264
68439: PUSH
68440: LD_INT 31
68442: EQUAL
68443: IFFALSE 68461
// places := places + 1 else
68445: LD_ADDR_VAR 0 5
68449: PUSH
68450: LD_VAR 0 5
68454: PUSH
68455: LD_INT 1
68457: PLUS
68458: ST_TO_ADDR
68459: GO 68496
// if GetBType ( x [ j ] ) = b_control_tower then
68461: LD_VAR 0 11
68465: PUSH
68466: LD_VAR 0 3
68470: ARRAY
68471: PPUSH
68472: CALL_OW 266
68476: PUSH
68477: LD_INT 36
68479: EQUAL
68480: IFFALSE 68496
// places := places + 3 ;
68482: LD_ADDR_VAR 0 5
68486: PUSH
68487: LD_VAR 0 5
68491: PUSH
68492: LD_INT 3
68494: PLUS
68495: ST_TO_ADDR
68496: GO 68421
68498: POP
68499: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
68500: LD_VAR 0 5
68504: PUSH
68505: LD_INT 0
68507: EQUAL
68508: PUSH
68509: LD_VAR 0 5
68513: PUSH
68514: LD_EXP 82
68518: PUSH
68519: LD_VAR 0 2
68523: ARRAY
68524: LESSEQUAL
68525: OR
68526: IFFALSE 68530
// continue ;
68528: GO 67780
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
68530: LD_ADDR_VAR 0 6
68534: PUSH
68535: LD_EXP 42
68539: PUSH
68540: LD_VAR 0 2
68544: ARRAY
68545: PPUSH
68546: LD_INT 25
68548: PUSH
68549: LD_INT 3
68551: PUSH
68552: EMPTY
68553: LIST
68554: LIST
68555: PPUSH
68556: CALL_OW 72
68560: PUSH
68561: LD_EXP 82
68565: PUSH
68566: LD_VAR 0 2
68570: ARRAY
68571: DIFF
68572: PPUSH
68573: LD_INT 3
68575: PPUSH
68576: CALL 43881 0 2
68580: ST_TO_ADDR
// for j in tmp do
68581: LD_ADDR_VAR 0 3
68585: PUSH
68586: LD_VAR 0 6
68590: PUSH
68591: FOR_IN
68592: IFFALSE 68627
// if GetTag ( j ) > 0 then
68594: LD_VAR 0 3
68598: PPUSH
68599: CALL_OW 110
68603: PUSH
68604: LD_INT 0
68606: GREATER
68607: IFFALSE 68625
// tmp := tmp diff j ;
68609: LD_ADDR_VAR 0 6
68613: PUSH
68614: LD_VAR 0 6
68618: PUSH
68619: LD_VAR 0 3
68623: DIFF
68624: ST_TO_ADDR
68625: GO 68591
68627: POP
68628: POP
// if not tmp then
68629: LD_VAR 0 6
68633: NOT
68634: IFFALSE 68638
// continue ;
68636: GO 67780
// if places then
68638: LD_VAR 0 5
68642: IFFALSE 68701
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
68644: LD_ADDR_EXP 82
68648: PUSH
68649: LD_EXP 82
68653: PPUSH
68654: LD_VAR 0 2
68658: PPUSH
68659: LD_EXP 82
68663: PUSH
68664: LD_VAR 0 2
68668: ARRAY
68669: PUSH
68670: LD_VAR 0 6
68674: PUSH
68675: LD_INT 1
68677: ARRAY
68678: UNION
68679: PPUSH
68680: CALL_OW 1
68684: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
68685: LD_VAR 0 6
68689: PUSH
68690: LD_INT 1
68692: ARRAY
68693: PPUSH
68694: LD_INT 126
68696: PPUSH
68697: CALL_OW 109
// end ; end ;
68701: GO 67780
68703: POP
68704: POP
// end ;
68705: LD_VAR 0 1
68709: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
68710: LD_INT 0
68712: PPUSH
68713: PPUSH
68714: PPUSH
68715: PPUSH
68716: PPUSH
68717: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
68718: LD_VAR 0 1
68722: NOT
68723: PUSH
68724: LD_VAR 0 2
68728: NOT
68729: OR
68730: PUSH
68731: LD_VAR 0 3
68735: NOT
68736: OR
68737: PUSH
68738: LD_VAR 0 4
68742: PUSH
68743: LD_INT 1
68745: PUSH
68746: LD_INT 2
68748: PUSH
68749: LD_INT 3
68751: PUSH
68752: LD_INT 4
68754: PUSH
68755: LD_INT 5
68757: PUSH
68758: LD_INT 8
68760: PUSH
68761: LD_INT 9
68763: PUSH
68764: LD_INT 15
68766: PUSH
68767: LD_INT 16
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: LIST
68780: IN
68781: NOT
68782: OR
68783: IFFALSE 68787
// exit ;
68785: GO 69687
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
68787: LD_ADDR_VAR 0 2
68791: PUSH
68792: LD_VAR 0 2
68796: PPUSH
68797: LD_INT 21
68799: PUSH
68800: LD_INT 3
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 24
68809: PUSH
68810: LD_INT 250
68812: PUSH
68813: EMPTY
68814: LIST
68815: LIST
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PPUSH
68821: CALL_OW 72
68825: ST_TO_ADDR
// case class of 1 , 15 :
68826: LD_VAR 0 4
68830: PUSH
68831: LD_INT 1
68833: DOUBLE
68834: EQUAL
68835: IFTRUE 68845
68837: LD_INT 15
68839: DOUBLE
68840: EQUAL
68841: IFTRUE 68845
68843: GO 68930
68845: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
68846: LD_ADDR_VAR 0 8
68850: PUSH
68851: LD_VAR 0 2
68855: PPUSH
68856: LD_INT 2
68858: PUSH
68859: LD_INT 30
68861: PUSH
68862: LD_INT 32
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 30
68871: PUSH
68872: LD_INT 31
68874: PUSH
68875: EMPTY
68876: LIST
68877: LIST
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: LIST
68883: PPUSH
68884: CALL_OW 72
68888: PUSH
68889: LD_VAR 0 2
68893: PPUSH
68894: LD_INT 2
68896: PUSH
68897: LD_INT 30
68899: PUSH
68900: LD_INT 4
68902: PUSH
68903: EMPTY
68904: LIST
68905: LIST
68906: PUSH
68907: LD_INT 30
68909: PUSH
68910: LD_INT 5
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: PUSH
68917: EMPTY
68918: LIST
68919: LIST
68920: LIST
68921: PPUSH
68922: CALL_OW 72
68926: ADD
68927: ST_TO_ADDR
68928: GO 69176
68930: LD_INT 2
68932: DOUBLE
68933: EQUAL
68934: IFTRUE 68944
68936: LD_INT 16
68938: DOUBLE
68939: EQUAL
68940: IFTRUE 68944
68942: GO 68990
68944: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
68945: LD_ADDR_VAR 0 8
68949: PUSH
68950: LD_VAR 0 2
68954: PPUSH
68955: LD_INT 2
68957: PUSH
68958: LD_INT 30
68960: PUSH
68961: LD_INT 0
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 30
68970: PUSH
68971: LD_INT 1
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: LIST
68982: PPUSH
68983: CALL_OW 72
68987: ST_TO_ADDR
68988: GO 69176
68990: LD_INT 3
68992: DOUBLE
68993: EQUAL
68994: IFTRUE 68998
68996: GO 69044
68998: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
68999: LD_ADDR_VAR 0 8
69003: PUSH
69004: LD_VAR 0 2
69008: PPUSH
69009: LD_INT 2
69011: PUSH
69012: LD_INT 30
69014: PUSH
69015: LD_INT 2
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: PUSH
69022: LD_INT 30
69024: PUSH
69025: LD_INT 3
69027: PUSH
69028: EMPTY
69029: LIST
69030: LIST
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: LIST
69036: PPUSH
69037: CALL_OW 72
69041: ST_TO_ADDR
69042: GO 69176
69044: LD_INT 4
69046: DOUBLE
69047: EQUAL
69048: IFTRUE 69052
69050: GO 69109
69052: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
69053: LD_ADDR_VAR 0 8
69057: PUSH
69058: LD_VAR 0 2
69062: PPUSH
69063: LD_INT 2
69065: PUSH
69066: LD_INT 30
69068: PUSH
69069: LD_INT 6
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 30
69078: PUSH
69079: LD_INT 7
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: LD_INT 30
69088: PUSH
69089: LD_INT 8
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: LIST
69100: LIST
69101: PPUSH
69102: CALL_OW 72
69106: ST_TO_ADDR
69107: GO 69176
69109: LD_INT 5
69111: DOUBLE
69112: EQUAL
69113: IFTRUE 69129
69115: LD_INT 8
69117: DOUBLE
69118: EQUAL
69119: IFTRUE 69129
69121: LD_INT 9
69123: DOUBLE
69124: EQUAL
69125: IFTRUE 69129
69127: GO 69175
69129: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
69130: LD_ADDR_VAR 0 8
69134: PUSH
69135: LD_VAR 0 2
69139: PPUSH
69140: LD_INT 2
69142: PUSH
69143: LD_INT 30
69145: PUSH
69146: LD_INT 4
69148: PUSH
69149: EMPTY
69150: LIST
69151: LIST
69152: PUSH
69153: LD_INT 30
69155: PUSH
69156: LD_INT 5
69158: PUSH
69159: EMPTY
69160: LIST
69161: LIST
69162: PUSH
69163: EMPTY
69164: LIST
69165: LIST
69166: LIST
69167: PPUSH
69168: CALL_OW 72
69172: ST_TO_ADDR
69173: GO 69176
69175: POP
// if not tmp then
69176: LD_VAR 0 8
69180: NOT
69181: IFFALSE 69185
// exit ;
69183: GO 69687
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
69185: LD_VAR 0 4
69189: PUSH
69190: LD_INT 1
69192: PUSH
69193: LD_INT 15
69195: PUSH
69196: EMPTY
69197: LIST
69198: LIST
69199: IN
69200: PUSH
69201: LD_EXP 51
69205: PUSH
69206: LD_VAR 0 1
69210: ARRAY
69211: AND
69212: IFFALSE 69368
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
69214: LD_ADDR_VAR 0 9
69218: PUSH
69219: LD_EXP 51
69223: PUSH
69224: LD_VAR 0 1
69228: ARRAY
69229: PUSH
69230: LD_INT 1
69232: ARRAY
69233: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
69234: LD_VAR 0 9
69238: PUSH
69239: LD_EXP 52
69243: PUSH
69244: LD_VAR 0 1
69248: ARRAY
69249: IN
69250: NOT
69251: IFFALSE 69366
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
69253: LD_ADDR_EXP 52
69257: PUSH
69258: LD_EXP 52
69262: PPUSH
69263: LD_VAR 0 1
69267: PUSH
69268: LD_EXP 52
69272: PUSH
69273: LD_VAR 0 1
69277: ARRAY
69278: PUSH
69279: LD_INT 1
69281: PLUS
69282: PUSH
69283: EMPTY
69284: LIST
69285: LIST
69286: PPUSH
69287: LD_VAR 0 9
69291: PPUSH
69292: CALL 14332 0 3
69296: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
69297: LD_ADDR_EXP 51
69301: PUSH
69302: LD_EXP 51
69306: PPUSH
69307: LD_VAR 0 1
69311: PPUSH
69312: LD_EXP 51
69316: PUSH
69317: LD_VAR 0 1
69321: ARRAY
69322: PUSH
69323: LD_VAR 0 9
69327: DIFF
69328: PPUSH
69329: CALL_OW 1
69333: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
69334: LD_VAR 0 3
69338: PPUSH
69339: LD_EXP 52
69343: PUSH
69344: LD_VAR 0 1
69348: ARRAY
69349: PUSH
69350: LD_EXP 52
69354: PUSH
69355: LD_VAR 0 1
69359: ARRAY
69360: ARRAY
69361: PPUSH
69362: CALL_OW 120
// end ; exit ;
69366: GO 69687
// end ; if tmp > 1 then
69368: LD_VAR 0 8
69372: PUSH
69373: LD_INT 1
69375: GREATER
69376: IFFALSE 69480
// for i = 2 to tmp do
69378: LD_ADDR_VAR 0 6
69382: PUSH
69383: DOUBLE
69384: LD_INT 2
69386: DEC
69387: ST_TO_ADDR
69388: LD_VAR 0 8
69392: PUSH
69393: FOR_TO
69394: IFFALSE 69478
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
69396: LD_VAR 0 8
69400: PUSH
69401: LD_VAR 0 6
69405: ARRAY
69406: PPUSH
69407: CALL_OW 461
69411: PUSH
69412: LD_INT 6
69414: EQUAL
69415: IFFALSE 69476
// begin x := tmp [ i ] ;
69417: LD_ADDR_VAR 0 9
69421: PUSH
69422: LD_VAR 0 8
69426: PUSH
69427: LD_VAR 0 6
69431: ARRAY
69432: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
69433: LD_ADDR_VAR 0 8
69437: PUSH
69438: LD_VAR 0 8
69442: PPUSH
69443: LD_VAR 0 6
69447: PPUSH
69448: CALL_OW 3
69452: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
69453: LD_ADDR_VAR 0 8
69457: PUSH
69458: LD_VAR 0 8
69462: PPUSH
69463: LD_INT 1
69465: PPUSH
69466: LD_VAR 0 9
69470: PPUSH
69471: CALL_OW 2
69475: ST_TO_ADDR
// end ;
69476: GO 69393
69478: POP
69479: POP
// for i in tmp do
69480: LD_ADDR_VAR 0 6
69484: PUSH
69485: LD_VAR 0 8
69489: PUSH
69490: FOR_IN
69491: IFFALSE 69560
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
69493: LD_VAR 0 6
69497: PPUSH
69498: CALL_OW 313
69502: PUSH
69503: LD_INT 6
69505: LESS
69506: PUSH
69507: LD_VAR 0 6
69511: PPUSH
69512: CALL_OW 266
69516: PUSH
69517: LD_INT 31
69519: PUSH
69520: LD_INT 32
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: IN
69527: NOT
69528: AND
69529: PUSH
69530: LD_VAR 0 6
69534: PPUSH
69535: CALL_OW 313
69539: PUSH
69540: LD_INT 0
69542: EQUAL
69543: OR
69544: IFFALSE 69558
// begin j := i ;
69546: LD_ADDR_VAR 0 7
69550: PUSH
69551: LD_VAR 0 6
69555: ST_TO_ADDR
// break ;
69556: GO 69560
// end ; end ;
69558: GO 69490
69560: POP
69561: POP
// if j then
69562: LD_VAR 0 7
69566: IFFALSE 69584
// ComEnterUnit ( unit , j ) else
69568: LD_VAR 0 3
69572: PPUSH
69573: LD_VAR 0 7
69577: PPUSH
69578: CALL_OW 120
69582: GO 69687
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69584: LD_ADDR_VAR 0 10
69588: PUSH
69589: LD_VAR 0 2
69593: PPUSH
69594: LD_INT 2
69596: PUSH
69597: LD_INT 30
69599: PUSH
69600: LD_INT 0
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 30
69609: PUSH
69610: LD_INT 1
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: LIST
69621: PPUSH
69622: CALL_OW 72
69626: ST_TO_ADDR
// if depot then
69627: LD_VAR 0 10
69631: IFFALSE 69687
// begin depot := NearestUnitToUnit ( depot , unit ) ;
69633: LD_ADDR_VAR 0 10
69637: PUSH
69638: LD_VAR 0 10
69642: PPUSH
69643: LD_VAR 0 3
69647: PPUSH
69648: CALL_OW 74
69652: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
69653: LD_VAR 0 3
69657: PPUSH
69658: LD_VAR 0 10
69662: PPUSH
69663: CALL_OW 296
69667: PUSH
69668: LD_INT 10
69670: GREATER
69671: IFFALSE 69687
// ComStandNearbyBuilding ( unit , depot ) ;
69673: LD_VAR 0 3
69677: PPUSH
69678: LD_VAR 0 10
69682: PPUSH
69683: CALL 10946 0 2
// end ; end ; end ;
69687: LD_VAR 0 5
69691: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
69692: LD_INT 0
69694: PPUSH
69695: PPUSH
69696: PPUSH
69697: PPUSH
// if not mc_bases then
69698: LD_EXP 42
69702: NOT
69703: IFFALSE 69707
// exit ;
69705: GO 69946
// for i = 1 to mc_bases do
69707: LD_ADDR_VAR 0 2
69711: PUSH
69712: DOUBLE
69713: LD_INT 1
69715: DEC
69716: ST_TO_ADDR
69717: LD_EXP 42
69721: PUSH
69722: FOR_TO
69723: IFFALSE 69944
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
69725: LD_ADDR_VAR 0 4
69729: PUSH
69730: LD_EXP 42
69734: PUSH
69735: LD_VAR 0 2
69739: ARRAY
69740: PPUSH
69741: LD_INT 21
69743: PUSH
69744: LD_INT 1
69746: PUSH
69747: EMPTY
69748: LIST
69749: LIST
69750: PPUSH
69751: CALL_OW 72
69755: PUSH
69756: LD_EXP 71
69760: PUSH
69761: LD_VAR 0 2
69765: ARRAY
69766: UNION
69767: ST_TO_ADDR
// if not tmp then
69768: LD_VAR 0 4
69772: NOT
69773: IFFALSE 69777
// continue ;
69775: GO 69722
// for j in tmp do
69777: LD_ADDR_VAR 0 3
69781: PUSH
69782: LD_VAR 0 4
69786: PUSH
69787: FOR_IN
69788: IFFALSE 69940
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
69790: LD_VAR 0 3
69794: PPUSH
69795: CALL_OW 110
69799: NOT
69800: PUSH
69801: LD_VAR 0 3
69805: PPUSH
69806: CALL_OW 314
69810: NOT
69811: AND
69812: PUSH
69813: LD_VAR 0 3
69817: PPUSH
69818: CALL_OW 311
69822: NOT
69823: AND
69824: PUSH
69825: LD_VAR 0 3
69829: PPUSH
69830: CALL_OW 310
69834: NOT
69835: AND
69836: PUSH
69837: LD_VAR 0 3
69841: PUSH
69842: LD_EXP 45
69846: PUSH
69847: LD_VAR 0 2
69851: ARRAY
69852: PUSH
69853: LD_INT 1
69855: ARRAY
69856: IN
69857: NOT
69858: AND
69859: PUSH
69860: LD_VAR 0 3
69864: PUSH
69865: LD_EXP 45
69869: PUSH
69870: LD_VAR 0 2
69874: ARRAY
69875: PUSH
69876: LD_INT 2
69878: ARRAY
69879: IN
69880: NOT
69881: AND
69882: PUSH
69883: LD_VAR 0 3
69887: PUSH
69888: LD_EXP 54
69892: PUSH
69893: LD_VAR 0 2
69897: ARRAY
69898: IN
69899: NOT
69900: AND
69901: IFFALSE 69938
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
69903: LD_VAR 0 2
69907: PPUSH
69908: LD_EXP 42
69912: PUSH
69913: LD_VAR 0 2
69917: ARRAY
69918: PPUSH
69919: LD_VAR 0 3
69923: PPUSH
69924: LD_VAR 0 3
69928: PPUSH
69929: CALL_OW 257
69933: PPUSH
69934: CALL 68710 0 4
// end ;
69938: GO 69787
69940: POP
69941: POP
// end ;
69942: GO 69722
69944: POP
69945: POP
// end ;
69946: LD_VAR 0 1
69950: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
69951: LD_INT 0
69953: PPUSH
69954: PPUSH
69955: PPUSH
69956: PPUSH
69957: PPUSH
69958: PPUSH
// if not mc_bases [ base ] then
69959: LD_EXP 42
69963: PUSH
69964: LD_VAR 0 1
69968: ARRAY
69969: NOT
69970: IFFALSE 69974
// exit ;
69972: GO 70156
// tmp := [ ] ;
69974: LD_ADDR_VAR 0 6
69978: PUSH
69979: EMPTY
69980: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
69981: LD_ADDR_VAR 0 7
69985: PUSH
69986: LD_VAR 0 3
69990: PPUSH
69991: LD_INT 0
69993: PPUSH
69994: CALL_OW 517
69998: ST_TO_ADDR
// if not list then
69999: LD_VAR 0 7
70003: NOT
70004: IFFALSE 70008
// exit ;
70006: GO 70156
// for i = 1 to amount do
70008: LD_ADDR_VAR 0 5
70012: PUSH
70013: DOUBLE
70014: LD_INT 1
70016: DEC
70017: ST_TO_ADDR
70018: LD_VAR 0 2
70022: PUSH
70023: FOR_TO
70024: IFFALSE 70104
// begin x := rand ( 1 , list [ 1 ] ) ;
70026: LD_ADDR_VAR 0 8
70030: PUSH
70031: LD_INT 1
70033: PPUSH
70034: LD_VAR 0 7
70038: PUSH
70039: LD_INT 1
70041: ARRAY
70042: PPUSH
70043: CALL_OW 12
70047: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
70048: LD_ADDR_VAR 0 6
70052: PUSH
70053: LD_VAR 0 6
70057: PPUSH
70058: LD_VAR 0 5
70062: PPUSH
70063: LD_VAR 0 7
70067: PUSH
70068: LD_INT 1
70070: ARRAY
70071: PUSH
70072: LD_VAR 0 8
70076: ARRAY
70077: PUSH
70078: LD_VAR 0 7
70082: PUSH
70083: LD_INT 2
70085: ARRAY
70086: PUSH
70087: LD_VAR 0 8
70091: ARRAY
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PPUSH
70097: CALL_OW 1
70101: ST_TO_ADDR
// end ;
70102: GO 70023
70104: POP
70105: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
70106: LD_ADDR_EXP 55
70110: PUSH
70111: LD_EXP 55
70115: PPUSH
70116: LD_VAR 0 1
70120: PPUSH
70121: LD_VAR 0 6
70125: PPUSH
70126: CALL_OW 1
70130: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
70131: LD_ADDR_EXP 57
70135: PUSH
70136: LD_EXP 57
70140: PPUSH
70141: LD_VAR 0 1
70145: PPUSH
70146: LD_VAR 0 3
70150: PPUSH
70151: CALL_OW 1
70155: ST_TO_ADDR
// end ;
70156: LD_VAR 0 4
70160: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
70161: LD_INT 0
70163: PPUSH
// if not mc_bases [ base ] then
70164: LD_EXP 42
70168: PUSH
70169: LD_VAR 0 1
70173: ARRAY
70174: NOT
70175: IFFALSE 70179
// exit ;
70177: GO 70204
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
70179: LD_ADDR_EXP 47
70183: PUSH
70184: LD_EXP 47
70188: PPUSH
70189: LD_VAR 0 1
70193: PPUSH
70194: LD_VAR 0 2
70198: PPUSH
70199: CALL_OW 1
70203: ST_TO_ADDR
// end ;
70204: LD_VAR 0 3
70208: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
70209: LD_INT 0
70211: PPUSH
// if not mc_bases [ base ] then
70212: LD_EXP 42
70216: PUSH
70217: LD_VAR 0 1
70221: ARRAY
70222: NOT
70223: IFFALSE 70227
// exit ;
70225: GO 70264
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
70227: LD_ADDR_EXP 47
70231: PUSH
70232: LD_EXP 47
70236: PPUSH
70237: LD_VAR 0 1
70241: PPUSH
70242: LD_EXP 47
70246: PUSH
70247: LD_VAR 0 1
70251: ARRAY
70252: PUSH
70253: LD_VAR 0 2
70257: UNION
70258: PPUSH
70259: CALL_OW 1
70263: ST_TO_ADDR
// end ;
70264: LD_VAR 0 3
70268: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
70269: LD_INT 0
70271: PPUSH
// if not mc_bases [ base ] then
70272: LD_EXP 42
70276: PUSH
70277: LD_VAR 0 1
70281: ARRAY
70282: NOT
70283: IFFALSE 70287
// exit ;
70285: GO 70312
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
70287: LD_ADDR_EXP 63
70291: PUSH
70292: LD_EXP 63
70296: PPUSH
70297: LD_VAR 0 1
70301: PPUSH
70302: LD_VAR 0 2
70306: PPUSH
70307: CALL_OW 1
70311: ST_TO_ADDR
// end ;
70312: LD_VAR 0 3
70316: RET
// export function MC_InsertProduceList ( base , components ) ; begin
70317: LD_INT 0
70319: PPUSH
// if not mc_bases [ base ] then
70320: LD_EXP 42
70324: PUSH
70325: LD_VAR 0 1
70329: ARRAY
70330: NOT
70331: IFFALSE 70335
// exit ;
70333: GO 70372
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
70335: LD_ADDR_EXP 63
70339: PUSH
70340: LD_EXP 63
70344: PPUSH
70345: LD_VAR 0 1
70349: PPUSH
70350: LD_EXP 63
70354: PUSH
70355: LD_VAR 0 1
70359: ARRAY
70360: PUSH
70361: LD_VAR 0 2
70365: ADD
70366: PPUSH
70367: CALL_OW 1
70371: ST_TO_ADDR
// end ;
70372: LD_VAR 0 3
70376: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
70377: LD_INT 0
70379: PPUSH
// if not mc_bases [ base ] then
70380: LD_EXP 42
70384: PUSH
70385: LD_VAR 0 1
70389: ARRAY
70390: NOT
70391: IFFALSE 70395
// exit ;
70393: GO 70449
// mc_defender := Replace ( mc_defender , base , deflist ) ;
70395: LD_ADDR_EXP 64
70399: PUSH
70400: LD_EXP 64
70404: PPUSH
70405: LD_VAR 0 1
70409: PPUSH
70410: LD_VAR 0 2
70414: PPUSH
70415: CALL_OW 1
70419: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
70420: LD_ADDR_EXP 53
70424: PUSH
70425: LD_EXP 53
70429: PPUSH
70430: LD_VAR 0 1
70434: PPUSH
70435: LD_VAR 0 2
70439: PUSH
70440: LD_INT 0
70442: PLUS
70443: PPUSH
70444: CALL_OW 1
70448: ST_TO_ADDR
// end ;
70449: LD_VAR 0 3
70453: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
70454: LD_INT 0
70456: PPUSH
// if not mc_bases [ base ] then
70457: LD_EXP 42
70461: PUSH
70462: LD_VAR 0 1
70466: ARRAY
70467: NOT
70468: IFFALSE 70472
// exit ;
70470: GO 70497
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
70472: LD_ADDR_EXP 53
70476: PUSH
70477: LD_EXP 53
70481: PPUSH
70482: LD_VAR 0 1
70486: PPUSH
70487: LD_VAR 0 2
70491: PPUSH
70492: CALL_OW 1
70496: ST_TO_ADDR
// end ;
70497: LD_VAR 0 3
70501: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
70502: LD_INT 0
70504: PPUSH
70505: PPUSH
70506: PPUSH
70507: PPUSH
// if not mc_bases [ base ] then
70508: LD_EXP 42
70512: PUSH
70513: LD_VAR 0 1
70517: ARRAY
70518: NOT
70519: IFFALSE 70523
// exit ;
70521: GO 70588
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
70523: LD_ADDR_EXP 62
70527: PUSH
70528: LD_EXP 62
70532: PPUSH
70533: LD_VAR 0 1
70537: PUSH
70538: LD_EXP 62
70542: PUSH
70543: LD_VAR 0 1
70547: ARRAY
70548: PUSH
70549: LD_INT 1
70551: PLUS
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PPUSH
70557: LD_VAR 0 1
70561: PUSH
70562: LD_VAR 0 2
70566: PUSH
70567: LD_VAR 0 3
70571: PUSH
70572: LD_VAR 0 4
70576: PUSH
70577: EMPTY
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: PPUSH
70583: CALL 14332 0 3
70587: ST_TO_ADDR
// end ;
70588: LD_VAR 0 5
70592: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
70593: LD_INT 0
70595: PPUSH
// if not mc_bases [ base ] then
70596: LD_EXP 42
70600: PUSH
70601: LD_VAR 0 1
70605: ARRAY
70606: NOT
70607: IFFALSE 70611
// exit ;
70609: GO 70636
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
70611: LD_ADDR_EXP 79
70615: PUSH
70616: LD_EXP 79
70620: PPUSH
70621: LD_VAR 0 1
70625: PPUSH
70626: LD_VAR 0 2
70630: PPUSH
70631: CALL_OW 1
70635: ST_TO_ADDR
// end ;
70636: LD_VAR 0 3
70640: RET
// export function MC_GetMinesField ( base ) ; begin
70641: LD_INT 0
70643: PPUSH
// result := mc_mines [ base ] ;
70644: LD_ADDR_VAR 0 2
70648: PUSH
70649: LD_EXP 55
70653: PUSH
70654: LD_VAR 0 1
70658: ARRAY
70659: ST_TO_ADDR
// end ;
70660: LD_VAR 0 2
70664: RET
// export function MC_GetProduceList ( base ) ; begin
70665: LD_INT 0
70667: PPUSH
// result := mc_produce [ base ] ;
70668: LD_ADDR_VAR 0 2
70672: PUSH
70673: LD_EXP 63
70677: PUSH
70678: LD_VAR 0 1
70682: ARRAY
70683: ST_TO_ADDR
// end ;
70684: LD_VAR 0 2
70688: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
70689: LD_INT 0
70691: PPUSH
70692: PPUSH
// if not mc_bases then
70693: LD_EXP 42
70697: NOT
70698: IFFALSE 70702
// exit ;
70700: GO 70767
// if mc_bases [ base ] then
70702: LD_EXP 42
70706: PUSH
70707: LD_VAR 0 1
70711: ARRAY
70712: IFFALSE 70767
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
70714: LD_ADDR_VAR 0 3
70718: PUSH
70719: LD_EXP 42
70723: PUSH
70724: LD_VAR 0 1
70728: ARRAY
70729: PPUSH
70730: LD_INT 30
70732: PUSH
70733: LD_VAR 0 2
70737: PUSH
70738: EMPTY
70739: LIST
70740: LIST
70741: PPUSH
70742: CALL_OW 72
70746: ST_TO_ADDR
// if result then
70747: LD_VAR 0 3
70751: IFFALSE 70767
// result := result [ 1 ] ;
70753: LD_ADDR_VAR 0 3
70757: PUSH
70758: LD_VAR 0 3
70762: PUSH
70763: LD_INT 1
70765: ARRAY
70766: ST_TO_ADDR
// end ; end ;
70767: LD_VAR 0 3
70771: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
70772: LD_INT 0
70774: PPUSH
70775: PPUSH
// if not mc_bases then
70776: LD_EXP 42
70780: NOT
70781: IFFALSE 70785
// exit ;
70783: GO 70830
// if mc_bases [ base ] then
70785: LD_EXP 42
70789: PUSH
70790: LD_VAR 0 1
70794: ARRAY
70795: IFFALSE 70830
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
70797: LD_ADDR_VAR 0 3
70801: PUSH
70802: LD_EXP 42
70806: PUSH
70807: LD_VAR 0 1
70811: ARRAY
70812: PPUSH
70813: LD_INT 30
70815: PUSH
70816: LD_VAR 0 2
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: PPUSH
70825: CALL_OW 72
70829: ST_TO_ADDR
// end ;
70830: LD_VAR 0 3
70834: RET
// export function MC_SetTame ( base , area ) ; begin
70835: LD_INT 0
70837: PPUSH
// if not mc_bases or not base then
70838: LD_EXP 42
70842: NOT
70843: PUSH
70844: LD_VAR 0 1
70848: NOT
70849: OR
70850: IFFALSE 70854
// exit ;
70852: GO 70879
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
70854: LD_ADDR_EXP 70
70858: PUSH
70859: LD_EXP 70
70863: PPUSH
70864: LD_VAR 0 1
70868: PPUSH
70869: LD_VAR 0 2
70873: PPUSH
70874: CALL_OW 1
70878: ST_TO_ADDR
// end ;
70879: LD_VAR 0 3
70883: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
70884: LD_INT 0
70886: PPUSH
70887: PPUSH
// if not mc_bases or not base then
70888: LD_EXP 42
70892: NOT
70893: PUSH
70894: LD_VAR 0 1
70898: NOT
70899: OR
70900: IFFALSE 70904
// exit ;
70902: GO 71006
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
70904: LD_ADDR_VAR 0 4
70908: PUSH
70909: LD_EXP 42
70913: PUSH
70914: LD_VAR 0 1
70918: ARRAY
70919: PPUSH
70920: LD_INT 30
70922: PUSH
70923: LD_VAR 0 2
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: PPUSH
70932: CALL_OW 72
70936: ST_TO_ADDR
// if not tmp then
70937: LD_VAR 0 4
70941: NOT
70942: IFFALSE 70946
// exit ;
70944: GO 71006
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
70946: LD_ADDR_EXP 74
70950: PUSH
70951: LD_EXP 74
70955: PPUSH
70956: LD_VAR 0 1
70960: PPUSH
70961: LD_EXP 74
70965: PUSH
70966: LD_VAR 0 1
70970: ARRAY
70971: PPUSH
70972: LD_EXP 74
70976: PUSH
70977: LD_VAR 0 1
70981: ARRAY
70982: PUSH
70983: LD_INT 1
70985: PLUS
70986: PPUSH
70987: LD_VAR 0 4
70991: PUSH
70992: LD_INT 1
70994: ARRAY
70995: PPUSH
70996: CALL_OW 2
71000: PPUSH
71001: CALL_OW 1
71005: ST_TO_ADDR
// end ;
71006: LD_VAR 0 3
71010: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
71011: LD_INT 0
71013: PPUSH
71014: PPUSH
// if not mc_bases or not base or not kinds then
71015: LD_EXP 42
71019: NOT
71020: PUSH
71021: LD_VAR 0 1
71025: NOT
71026: OR
71027: PUSH
71028: LD_VAR 0 2
71032: NOT
71033: OR
71034: IFFALSE 71038
// exit ;
71036: GO 71099
// for i in kinds do
71038: LD_ADDR_VAR 0 4
71042: PUSH
71043: LD_VAR 0 2
71047: PUSH
71048: FOR_IN
71049: IFFALSE 71097
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
71051: LD_ADDR_EXP 76
71055: PUSH
71056: LD_EXP 76
71060: PPUSH
71061: LD_VAR 0 1
71065: PUSH
71066: LD_EXP 76
71070: PUSH
71071: LD_VAR 0 1
71075: ARRAY
71076: PUSH
71077: LD_INT 1
71079: PLUS
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PPUSH
71085: LD_VAR 0 4
71089: PPUSH
71090: CALL 14332 0 3
71094: ST_TO_ADDR
71095: GO 71048
71097: POP
71098: POP
// end ;
71099: LD_VAR 0 3
71103: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
71104: LD_INT 0
71106: PPUSH
// if not mc_bases or not base or not areas then
71107: LD_EXP 42
71111: NOT
71112: PUSH
71113: LD_VAR 0 1
71117: NOT
71118: OR
71119: PUSH
71120: LD_VAR 0 2
71124: NOT
71125: OR
71126: IFFALSE 71130
// exit ;
71128: GO 71155
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
71130: LD_ADDR_EXP 60
71134: PUSH
71135: LD_EXP 60
71139: PPUSH
71140: LD_VAR 0 1
71144: PPUSH
71145: LD_VAR 0 2
71149: PPUSH
71150: CALL_OW 1
71154: ST_TO_ADDR
// end ;
71155: LD_VAR 0 3
71159: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
71160: LD_INT 0
71162: PPUSH
// if not mc_bases or not base or not teleports_exit then
71163: LD_EXP 42
71167: NOT
71168: PUSH
71169: LD_VAR 0 1
71173: NOT
71174: OR
71175: PUSH
71176: LD_VAR 0 2
71180: NOT
71181: OR
71182: IFFALSE 71186
// exit ;
71184: GO 71211
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
71186: LD_ADDR_EXP 77
71190: PUSH
71191: LD_EXP 77
71195: PPUSH
71196: LD_VAR 0 1
71200: PPUSH
71201: LD_VAR 0 2
71205: PPUSH
71206: CALL_OW 1
71210: ST_TO_ADDR
// end ;
71211: LD_VAR 0 3
71215: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
71216: LD_INT 0
71218: PPUSH
71219: PPUSH
71220: PPUSH
// if not mc_bases or not base or not ext_list then
71221: LD_EXP 42
71225: NOT
71226: PUSH
71227: LD_VAR 0 1
71231: NOT
71232: OR
71233: PUSH
71234: LD_VAR 0 5
71238: NOT
71239: OR
71240: IFFALSE 71244
// exit ;
71242: GO 71417
// tmp := GetFacExtXYD ( x , y , d ) ;
71244: LD_ADDR_VAR 0 8
71248: PUSH
71249: LD_VAR 0 2
71253: PPUSH
71254: LD_VAR 0 3
71258: PPUSH
71259: LD_VAR 0 4
71263: PPUSH
71264: CALL 43011 0 3
71268: ST_TO_ADDR
// if not tmp then
71269: LD_VAR 0 8
71273: NOT
71274: IFFALSE 71278
// exit ;
71276: GO 71417
// for i in tmp do
71278: LD_ADDR_VAR 0 7
71282: PUSH
71283: LD_VAR 0 8
71287: PUSH
71288: FOR_IN
71289: IFFALSE 71415
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
71291: LD_ADDR_EXP 47
71295: PUSH
71296: LD_EXP 47
71300: PPUSH
71301: LD_VAR 0 1
71305: PPUSH
71306: LD_EXP 47
71310: PUSH
71311: LD_VAR 0 1
71315: ARRAY
71316: PPUSH
71317: LD_EXP 47
71321: PUSH
71322: LD_VAR 0 1
71326: ARRAY
71327: PUSH
71328: LD_INT 1
71330: PLUS
71331: PPUSH
71332: LD_VAR 0 5
71336: PUSH
71337: LD_INT 1
71339: ARRAY
71340: PUSH
71341: LD_VAR 0 7
71345: PUSH
71346: LD_INT 1
71348: ARRAY
71349: PUSH
71350: LD_VAR 0 7
71354: PUSH
71355: LD_INT 2
71357: ARRAY
71358: PUSH
71359: LD_VAR 0 7
71363: PUSH
71364: LD_INT 3
71366: ARRAY
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: PPUSH
71374: CALL_OW 2
71378: PPUSH
71379: CALL_OW 1
71383: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
71384: LD_ADDR_VAR 0 5
71388: PUSH
71389: LD_VAR 0 5
71393: PPUSH
71394: LD_INT 1
71396: PPUSH
71397: CALL_OW 3
71401: ST_TO_ADDR
// if not ext_list then
71402: LD_VAR 0 5
71406: NOT
71407: IFFALSE 71413
// exit ;
71409: POP
71410: POP
71411: GO 71417
// end ;
71413: GO 71288
71415: POP
71416: POP
// end ;
71417: LD_VAR 0 6
71421: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
71422: LD_INT 0
71424: PPUSH
// if not mc_bases or not base or not weapon_list then
71425: LD_EXP 42
71429: NOT
71430: PUSH
71431: LD_VAR 0 1
71435: NOT
71436: OR
71437: PUSH
71438: LD_VAR 0 2
71442: NOT
71443: OR
71444: IFFALSE 71448
// exit ;
71446: GO 71473
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
71448: LD_ADDR_EXP 81
71452: PUSH
71453: LD_EXP 81
71457: PPUSH
71458: LD_VAR 0 1
71462: PPUSH
71463: LD_VAR 0 2
71467: PPUSH
71468: CALL_OW 1
71472: ST_TO_ADDR
// end ;
71473: LD_VAR 0 3
71477: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
71478: LD_INT 0
71480: PPUSH
// if not mc_bases or not base or not tech_list then
71481: LD_EXP 42
71485: NOT
71486: PUSH
71487: LD_VAR 0 1
71491: NOT
71492: OR
71493: PUSH
71494: LD_VAR 0 2
71498: NOT
71499: OR
71500: IFFALSE 71504
// exit ;
71502: GO 71529
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
71504: LD_ADDR_EXP 69
71508: PUSH
71509: LD_EXP 69
71513: PPUSH
71514: LD_VAR 0 1
71518: PPUSH
71519: LD_VAR 0 2
71523: PPUSH
71524: CALL_OW 1
71528: ST_TO_ADDR
// end ;
71529: LD_VAR 0 3
71533: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
71534: LD_INT 0
71536: PPUSH
// if not mc_bases or not parking_area or not base then
71537: LD_EXP 42
71541: NOT
71542: PUSH
71543: LD_VAR 0 2
71547: NOT
71548: OR
71549: PUSH
71550: LD_VAR 0 1
71554: NOT
71555: OR
71556: IFFALSE 71560
// exit ;
71558: GO 71585
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
71560: LD_ADDR_EXP 66
71564: PUSH
71565: LD_EXP 66
71569: PPUSH
71570: LD_VAR 0 1
71574: PPUSH
71575: LD_VAR 0 2
71579: PPUSH
71580: CALL_OW 1
71584: ST_TO_ADDR
// end ;
71585: LD_VAR 0 3
71589: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
71590: LD_INT 0
71592: PPUSH
// if not mc_bases or not base or not scan_area then
71593: LD_EXP 42
71597: NOT
71598: PUSH
71599: LD_VAR 0 1
71603: NOT
71604: OR
71605: PUSH
71606: LD_VAR 0 2
71610: NOT
71611: OR
71612: IFFALSE 71616
// exit ;
71614: GO 71641
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
71616: LD_ADDR_EXP 67
71620: PUSH
71621: LD_EXP 67
71625: PPUSH
71626: LD_VAR 0 1
71630: PPUSH
71631: LD_VAR 0 2
71635: PPUSH
71636: CALL_OW 1
71640: ST_TO_ADDR
// end ;
71641: LD_VAR 0 3
71645: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
71646: LD_INT 0
71648: PPUSH
71649: PPUSH
// if not mc_bases or not base then
71650: LD_EXP 42
71654: NOT
71655: PUSH
71656: LD_VAR 0 1
71660: NOT
71661: OR
71662: IFFALSE 71666
// exit ;
71664: GO 71730
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
71666: LD_ADDR_VAR 0 3
71670: PUSH
71671: LD_INT 1
71673: PUSH
71674: LD_INT 2
71676: PUSH
71677: LD_INT 3
71679: PUSH
71680: LD_INT 4
71682: PUSH
71683: LD_INT 11
71685: PUSH
71686: EMPTY
71687: LIST
71688: LIST
71689: LIST
71690: LIST
71691: LIST
71692: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
71693: LD_ADDR_EXP 69
71697: PUSH
71698: LD_EXP 69
71702: PPUSH
71703: LD_VAR 0 1
71707: PPUSH
71708: LD_EXP 69
71712: PUSH
71713: LD_VAR 0 1
71717: ARRAY
71718: PUSH
71719: LD_VAR 0 3
71723: DIFF
71724: PPUSH
71725: CALL_OW 1
71729: ST_TO_ADDR
// end ;
71730: LD_VAR 0 2
71734: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
71735: LD_INT 0
71737: PPUSH
// result := mc_vehicles [ base ] ;
71738: LD_ADDR_VAR 0 3
71742: PUSH
71743: LD_EXP 61
71747: PUSH
71748: LD_VAR 0 1
71752: ARRAY
71753: ST_TO_ADDR
// if onlyCombat then
71754: LD_VAR 0 2
71758: IFFALSE 71936
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
71760: LD_ADDR_VAR 0 3
71764: PUSH
71765: LD_VAR 0 3
71769: PUSH
71770: LD_VAR 0 3
71774: PPUSH
71775: LD_INT 2
71777: PUSH
71778: LD_INT 34
71780: PUSH
71781: LD_INT 12
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 34
71790: PUSH
71791: LD_INT 51
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PUSH
71798: LD_INT 34
71800: PUSH
71801: LD_EXP 86
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: PUSH
71810: LD_INT 34
71812: PUSH
71813: LD_INT 32
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: PUSH
71820: LD_INT 34
71822: PUSH
71823: LD_INT 13
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: PUSH
71830: LD_INT 34
71832: PUSH
71833: LD_INT 52
71835: PUSH
71836: EMPTY
71837: LIST
71838: LIST
71839: PUSH
71840: LD_INT 34
71842: PUSH
71843: LD_EXP 91
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: PUSH
71852: LD_INT 34
71854: PUSH
71855: LD_INT 14
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PUSH
71862: LD_INT 34
71864: PUSH
71865: LD_INT 53
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 34
71874: PUSH
71875: LD_EXP 85
71879: PUSH
71880: EMPTY
71881: LIST
71882: LIST
71883: PUSH
71884: LD_INT 34
71886: PUSH
71887: LD_INT 31
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 34
71896: PUSH
71897: LD_INT 48
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 34
71906: PUSH
71907: LD_INT 8
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: LIST
71918: LIST
71919: LIST
71920: LIST
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: LIST
71926: LIST
71927: LIST
71928: LIST
71929: PPUSH
71930: CALL_OW 72
71934: DIFF
71935: ST_TO_ADDR
// end ; end_of_file
71936: LD_VAR 0 3
71940: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
71941: LD_INT 0
71943: PPUSH
71944: PPUSH
71945: PPUSH
// if not mc_bases or not skirmish then
71946: LD_EXP 42
71950: NOT
71951: PUSH
71952: LD_EXP 40
71956: NOT
71957: OR
71958: IFFALSE 71962
// exit ;
71960: GO 72127
// for i = 1 to mc_bases do
71962: LD_ADDR_VAR 0 4
71966: PUSH
71967: DOUBLE
71968: LD_INT 1
71970: DEC
71971: ST_TO_ADDR
71972: LD_EXP 42
71976: PUSH
71977: FOR_TO
71978: IFFALSE 72125
// begin if sci in mc_bases [ i ] then
71980: LD_VAR 0 2
71984: PUSH
71985: LD_EXP 42
71989: PUSH
71990: LD_VAR 0 4
71994: ARRAY
71995: IN
71996: IFFALSE 72123
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
71998: LD_ADDR_EXP 71
72002: PUSH
72003: LD_EXP 71
72007: PPUSH
72008: LD_VAR 0 4
72012: PUSH
72013: LD_EXP 71
72017: PUSH
72018: LD_VAR 0 4
72022: ARRAY
72023: PUSH
72024: LD_INT 1
72026: PLUS
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PPUSH
72032: LD_VAR 0 1
72036: PPUSH
72037: CALL 14332 0 3
72041: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
72042: LD_ADDR_VAR 0 5
72046: PUSH
72047: LD_EXP 42
72051: PUSH
72052: LD_VAR 0 4
72056: ARRAY
72057: PPUSH
72058: LD_INT 2
72060: PUSH
72061: LD_INT 30
72063: PUSH
72064: LD_INT 0
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 30
72073: PUSH
72074: LD_INT 1
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: LIST
72085: PPUSH
72086: CALL_OW 72
72090: PPUSH
72091: LD_VAR 0 1
72095: PPUSH
72096: CALL_OW 74
72100: ST_TO_ADDR
// if tmp then
72101: LD_VAR 0 5
72105: IFFALSE 72121
// ComStandNearbyBuilding ( ape , tmp ) ;
72107: LD_VAR 0 1
72111: PPUSH
72112: LD_VAR 0 5
72116: PPUSH
72117: CALL 10946 0 2
// break ;
72121: GO 72125
// end ; end ;
72123: GO 71977
72125: POP
72126: POP
// end ;
72127: LD_VAR 0 3
72131: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
72132: LD_INT 0
72134: PPUSH
72135: PPUSH
72136: PPUSH
// if not mc_bases or not skirmish then
72137: LD_EXP 42
72141: NOT
72142: PUSH
72143: LD_EXP 40
72147: NOT
72148: OR
72149: IFFALSE 72153
// exit ;
72151: GO 72242
// for i = 1 to mc_bases do
72153: LD_ADDR_VAR 0 4
72157: PUSH
72158: DOUBLE
72159: LD_INT 1
72161: DEC
72162: ST_TO_ADDR
72163: LD_EXP 42
72167: PUSH
72168: FOR_TO
72169: IFFALSE 72240
// begin if building in mc_busy_turret_list [ i ] then
72171: LD_VAR 0 1
72175: PUSH
72176: LD_EXP 52
72180: PUSH
72181: LD_VAR 0 4
72185: ARRAY
72186: IN
72187: IFFALSE 72238
// begin tmp := mc_busy_turret_list [ i ] diff building ;
72189: LD_ADDR_VAR 0 5
72193: PUSH
72194: LD_EXP 52
72198: PUSH
72199: LD_VAR 0 4
72203: ARRAY
72204: PUSH
72205: LD_VAR 0 1
72209: DIFF
72210: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
72211: LD_ADDR_EXP 52
72215: PUSH
72216: LD_EXP 52
72220: PPUSH
72221: LD_VAR 0 4
72225: PPUSH
72226: LD_VAR 0 5
72230: PPUSH
72231: CALL_OW 1
72235: ST_TO_ADDR
// break ;
72236: GO 72240
// end ; end ;
72238: GO 72168
72240: POP
72241: POP
// end ;
72242: LD_VAR 0 3
72246: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
72247: LD_INT 0
72249: PPUSH
72250: PPUSH
72251: PPUSH
// if not mc_bases or not skirmish then
72252: LD_EXP 42
72256: NOT
72257: PUSH
72258: LD_EXP 40
72262: NOT
72263: OR
72264: IFFALSE 72268
// exit ;
72266: GO 72467
// for i = 1 to mc_bases do
72268: LD_ADDR_VAR 0 5
72272: PUSH
72273: DOUBLE
72274: LD_INT 1
72276: DEC
72277: ST_TO_ADDR
72278: LD_EXP 42
72282: PUSH
72283: FOR_TO
72284: IFFALSE 72465
// if building in mc_bases [ i ] then
72286: LD_VAR 0 1
72290: PUSH
72291: LD_EXP 42
72295: PUSH
72296: LD_VAR 0 5
72300: ARRAY
72301: IN
72302: IFFALSE 72463
// begin tmp := mc_bases [ i ] diff building ;
72304: LD_ADDR_VAR 0 6
72308: PUSH
72309: LD_EXP 42
72313: PUSH
72314: LD_VAR 0 5
72318: ARRAY
72319: PUSH
72320: LD_VAR 0 1
72324: DIFF
72325: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
72326: LD_ADDR_EXP 42
72330: PUSH
72331: LD_EXP 42
72335: PPUSH
72336: LD_VAR 0 5
72340: PPUSH
72341: LD_VAR 0 6
72345: PPUSH
72346: CALL_OW 1
72350: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
72351: LD_VAR 0 1
72355: PUSH
72356: LD_EXP 50
72360: PUSH
72361: LD_VAR 0 5
72365: ARRAY
72366: IN
72367: IFFALSE 72406
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
72369: LD_ADDR_EXP 50
72373: PUSH
72374: LD_EXP 50
72378: PPUSH
72379: LD_VAR 0 5
72383: PPUSH
72384: LD_EXP 50
72388: PUSH
72389: LD_VAR 0 5
72393: ARRAY
72394: PUSH
72395: LD_VAR 0 1
72399: DIFF
72400: PPUSH
72401: CALL_OW 1
72405: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
72406: LD_VAR 0 1
72410: PUSH
72411: LD_EXP 51
72415: PUSH
72416: LD_VAR 0 5
72420: ARRAY
72421: IN
72422: IFFALSE 72461
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
72424: LD_ADDR_EXP 51
72428: PUSH
72429: LD_EXP 51
72433: PPUSH
72434: LD_VAR 0 5
72438: PPUSH
72439: LD_EXP 51
72443: PUSH
72444: LD_VAR 0 5
72448: ARRAY
72449: PUSH
72450: LD_VAR 0 1
72454: DIFF
72455: PPUSH
72456: CALL_OW 1
72460: ST_TO_ADDR
// break ;
72461: GO 72465
// end ;
72463: GO 72283
72465: POP
72466: POP
// end ;
72467: LD_VAR 0 4
72471: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
72472: LD_INT 0
72474: PPUSH
72475: PPUSH
72476: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
72477: LD_EXP 42
72481: NOT
72482: PUSH
72483: LD_EXP 40
72487: NOT
72488: OR
72489: PUSH
72490: LD_VAR 0 3
72494: PUSH
72495: LD_EXP 68
72499: IN
72500: NOT
72501: OR
72502: IFFALSE 72506
// exit ;
72504: GO 72629
// for i = 1 to mc_vehicles do
72506: LD_ADDR_VAR 0 6
72510: PUSH
72511: DOUBLE
72512: LD_INT 1
72514: DEC
72515: ST_TO_ADDR
72516: LD_EXP 61
72520: PUSH
72521: FOR_TO
72522: IFFALSE 72627
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
72524: LD_VAR 0 2
72528: PUSH
72529: LD_EXP 61
72533: PUSH
72534: LD_VAR 0 6
72538: ARRAY
72539: IN
72540: PUSH
72541: LD_VAR 0 1
72545: PUSH
72546: LD_EXP 61
72550: PUSH
72551: LD_VAR 0 6
72555: ARRAY
72556: IN
72557: OR
72558: IFFALSE 72625
// begin tmp := mc_vehicles [ i ] diff old ;
72560: LD_ADDR_VAR 0 7
72564: PUSH
72565: LD_EXP 61
72569: PUSH
72570: LD_VAR 0 6
72574: ARRAY
72575: PUSH
72576: LD_VAR 0 2
72580: DIFF
72581: ST_TO_ADDR
// tmp := tmp diff new ;
72582: LD_ADDR_VAR 0 7
72586: PUSH
72587: LD_VAR 0 7
72591: PUSH
72592: LD_VAR 0 1
72596: DIFF
72597: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
72598: LD_ADDR_EXP 61
72602: PUSH
72603: LD_EXP 61
72607: PPUSH
72608: LD_VAR 0 6
72612: PPUSH
72613: LD_VAR 0 7
72617: PPUSH
72618: CALL_OW 1
72622: ST_TO_ADDR
// break ;
72623: GO 72627
// end ;
72625: GO 72521
72627: POP
72628: POP
// end ;
72629: LD_VAR 0 5
72633: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
72634: LD_INT 0
72636: PPUSH
72637: PPUSH
72638: PPUSH
72639: PPUSH
// if not mc_bases or not skirmish then
72640: LD_EXP 42
72644: NOT
72645: PUSH
72646: LD_EXP 40
72650: NOT
72651: OR
72652: IFFALSE 72656
// exit ;
72654: GO 73039
// side := GetSide ( vehicle ) ;
72656: LD_ADDR_VAR 0 5
72660: PUSH
72661: LD_VAR 0 1
72665: PPUSH
72666: CALL_OW 255
72670: ST_TO_ADDR
// for i = 1 to mc_bases do
72671: LD_ADDR_VAR 0 4
72675: PUSH
72676: DOUBLE
72677: LD_INT 1
72679: DEC
72680: ST_TO_ADDR
72681: LD_EXP 42
72685: PUSH
72686: FOR_TO
72687: IFFALSE 73037
// begin if factory in mc_bases [ i ] then
72689: LD_VAR 0 2
72693: PUSH
72694: LD_EXP 42
72698: PUSH
72699: LD_VAR 0 4
72703: ARRAY
72704: IN
72705: IFFALSE 73035
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
72707: LD_EXP 64
72711: PUSH
72712: LD_VAR 0 4
72716: ARRAY
72717: PUSH
72718: LD_EXP 53
72722: PUSH
72723: LD_VAR 0 4
72727: ARRAY
72728: LESS
72729: PUSH
72730: LD_VAR 0 1
72734: PPUSH
72735: CALL_OW 264
72739: PUSH
72740: LD_INT 31
72742: PUSH
72743: LD_INT 32
72745: PUSH
72746: LD_INT 51
72748: PUSH
72749: LD_EXP 86
72753: PUSH
72754: LD_INT 12
72756: PUSH
72757: LD_INT 30
72759: PUSH
72760: LD_EXP 85
72764: PUSH
72765: LD_INT 11
72767: PUSH
72768: LD_INT 53
72770: PUSH
72771: LD_INT 14
72773: PUSH
72774: LD_EXP 89
72778: PUSH
72779: LD_INT 29
72781: PUSH
72782: LD_EXP 87
72786: PUSH
72787: LD_INT 13
72789: PUSH
72790: LD_INT 52
72792: PUSH
72793: LD_EXP 91
72797: PUSH
72798: LD_INT 48
72800: PUSH
72801: LD_INT 8
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: LIST
72808: LIST
72809: LIST
72810: LIST
72811: LIST
72812: LIST
72813: LIST
72814: LIST
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: IN
72824: NOT
72825: AND
72826: IFFALSE 72874
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
72828: LD_ADDR_EXP 64
72832: PUSH
72833: LD_EXP 64
72837: PPUSH
72838: LD_VAR 0 4
72842: PUSH
72843: LD_EXP 64
72847: PUSH
72848: LD_VAR 0 4
72852: ARRAY
72853: PUSH
72854: LD_INT 1
72856: PLUS
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PPUSH
72862: LD_VAR 0 1
72866: PPUSH
72867: CALL 14332 0 3
72871: ST_TO_ADDR
72872: GO 72918
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
72874: LD_ADDR_EXP 61
72878: PUSH
72879: LD_EXP 61
72883: PPUSH
72884: LD_VAR 0 4
72888: PUSH
72889: LD_EXP 61
72893: PUSH
72894: LD_VAR 0 4
72898: ARRAY
72899: PUSH
72900: LD_INT 1
72902: PLUS
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PPUSH
72908: LD_VAR 0 1
72912: PPUSH
72913: CALL 14332 0 3
72917: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
72918: LD_VAR 0 1
72922: PPUSH
72923: CALL_OW 263
72927: PUSH
72928: LD_INT 2
72930: EQUAL
72931: IFFALSE 72951
// begin repeat wait ( 0 0$1 ) ;
72933: LD_INT 35
72935: PPUSH
72936: CALL_OW 67
// until IsControledBy ( vehicle ) ;
72940: LD_VAR 0 1
72944: PPUSH
72945: CALL_OW 312
72949: IFFALSE 72933
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
72951: LD_VAR 0 1
72955: PPUSH
72956: LD_EXP 66
72960: PUSH
72961: LD_VAR 0 4
72965: ARRAY
72966: PPUSH
72967: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
72971: LD_VAR 0 1
72975: PPUSH
72976: CALL_OW 263
72980: PUSH
72981: LD_INT 1
72983: NONEQUAL
72984: IFFALSE 72988
// break ;
72986: GO 73037
// repeat wait ( 0 0$1 ) ;
72988: LD_INT 35
72990: PPUSH
72991: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
72995: LD_VAR 0 1
72999: PPUSH
73000: LD_EXP 66
73004: PUSH
73005: LD_VAR 0 4
73009: ARRAY
73010: PPUSH
73011: CALL_OW 308
73015: IFFALSE 72988
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
73017: LD_VAR 0 1
73021: PPUSH
73022: CALL_OW 311
73026: PPUSH
73027: CALL_OW 121
// exit ;
73031: POP
73032: POP
73033: GO 73039
// end ; end ;
73035: GO 72686
73037: POP
73038: POP
// end ;
73039: LD_VAR 0 3
73043: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
73044: LD_INT 0
73046: PPUSH
73047: PPUSH
73048: PPUSH
73049: PPUSH
// if not mc_bases or not skirmish then
73050: LD_EXP 42
73054: NOT
73055: PUSH
73056: LD_EXP 40
73060: NOT
73061: OR
73062: IFFALSE 73066
// exit ;
73064: GO 73419
// repeat wait ( 0 0$1 ) ;
73066: LD_INT 35
73068: PPUSH
73069: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
73073: LD_VAR 0 2
73077: PPUSH
73078: LD_VAR 0 3
73082: PPUSH
73083: CALL_OW 284
73087: IFFALSE 73066
// if GetResourceTypeXY ( x , y ) = mat_artefact then
73089: LD_VAR 0 2
73093: PPUSH
73094: LD_VAR 0 3
73098: PPUSH
73099: CALL_OW 283
73103: PUSH
73104: LD_INT 4
73106: EQUAL
73107: IFFALSE 73111
// exit ;
73109: GO 73419
// for i = 1 to mc_bases do
73111: LD_ADDR_VAR 0 7
73115: PUSH
73116: DOUBLE
73117: LD_INT 1
73119: DEC
73120: ST_TO_ADDR
73121: LD_EXP 42
73125: PUSH
73126: FOR_TO
73127: IFFALSE 73417
// begin if mc_crates_area [ i ] then
73129: LD_EXP 60
73133: PUSH
73134: LD_VAR 0 7
73138: ARRAY
73139: IFFALSE 73250
// for j in mc_crates_area [ i ] do
73141: LD_ADDR_VAR 0 8
73145: PUSH
73146: LD_EXP 60
73150: PUSH
73151: LD_VAR 0 7
73155: ARRAY
73156: PUSH
73157: FOR_IN
73158: IFFALSE 73248
// if InArea ( x , y , j ) then
73160: LD_VAR 0 2
73164: PPUSH
73165: LD_VAR 0 3
73169: PPUSH
73170: LD_VAR 0 8
73174: PPUSH
73175: CALL_OW 309
73179: IFFALSE 73246
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73181: LD_ADDR_EXP 58
73185: PUSH
73186: LD_EXP 58
73190: PPUSH
73191: LD_VAR 0 7
73195: PUSH
73196: LD_EXP 58
73200: PUSH
73201: LD_VAR 0 7
73205: ARRAY
73206: PUSH
73207: LD_INT 1
73209: PLUS
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PPUSH
73215: LD_VAR 0 4
73219: PUSH
73220: LD_VAR 0 2
73224: PUSH
73225: LD_VAR 0 3
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: LIST
73234: PPUSH
73235: CALL 14332 0 3
73239: ST_TO_ADDR
// exit ;
73240: POP
73241: POP
73242: POP
73243: POP
73244: GO 73419
// end ;
73246: GO 73157
73248: POP
73249: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73250: LD_ADDR_VAR 0 9
73254: PUSH
73255: LD_EXP 42
73259: PUSH
73260: LD_VAR 0 7
73264: ARRAY
73265: PPUSH
73266: LD_INT 2
73268: PUSH
73269: LD_INT 30
73271: PUSH
73272: LD_INT 0
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: LD_INT 30
73281: PUSH
73282: LD_INT 1
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: LIST
73293: PPUSH
73294: CALL_OW 72
73298: ST_TO_ADDR
// if not depot then
73299: LD_VAR 0 9
73303: NOT
73304: IFFALSE 73308
// continue ;
73306: GO 73126
// for j in depot do
73308: LD_ADDR_VAR 0 8
73312: PUSH
73313: LD_VAR 0 9
73317: PUSH
73318: FOR_IN
73319: IFFALSE 73413
// if GetDistUnitXY ( j , x , y ) < 30 then
73321: LD_VAR 0 8
73325: PPUSH
73326: LD_VAR 0 2
73330: PPUSH
73331: LD_VAR 0 3
73335: PPUSH
73336: CALL_OW 297
73340: PUSH
73341: LD_INT 30
73343: LESS
73344: IFFALSE 73411
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73346: LD_ADDR_EXP 58
73350: PUSH
73351: LD_EXP 58
73355: PPUSH
73356: LD_VAR 0 7
73360: PUSH
73361: LD_EXP 58
73365: PUSH
73366: LD_VAR 0 7
73370: ARRAY
73371: PUSH
73372: LD_INT 1
73374: PLUS
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PPUSH
73380: LD_VAR 0 4
73384: PUSH
73385: LD_VAR 0 2
73389: PUSH
73390: LD_VAR 0 3
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: LIST
73399: PPUSH
73400: CALL 14332 0 3
73404: ST_TO_ADDR
// exit ;
73405: POP
73406: POP
73407: POP
73408: POP
73409: GO 73419
// end ;
73411: GO 73318
73413: POP
73414: POP
// end ;
73415: GO 73126
73417: POP
73418: POP
// end ;
73419: LD_VAR 0 6
73423: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
73424: LD_INT 0
73426: PPUSH
73427: PPUSH
73428: PPUSH
73429: PPUSH
// if not mc_bases or not skirmish then
73430: LD_EXP 42
73434: NOT
73435: PUSH
73436: LD_EXP 40
73440: NOT
73441: OR
73442: IFFALSE 73446
// exit ;
73444: GO 73723
// side := GetSide ( lab ) ;
73446: LD_ADDR_VAR 0 4
73450: PUSH
73451: LD_VAR 0 2
73455: PPUSH
73456: CALL_OW 255
73460: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
73461: LD_VAR 0 4
73465: PUSH
73466: LD_EXP 68
73470: IN
73471: NOT
73472: PUSH
73473: LD_EXP 69
73477: NOT
73478: OR
73479: PUSH
73480: LD_EXP 42
73484: NOT
73485: OR
73486: IFFALSE 73490
// exit ;
73488: GO 73723
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
73490: LD_ADDR_EXP 69
73494: PUSH
73495: LD_EXP 69
73499: PPUSH
73500: LD_VAR 0 4
73504: PPUSH
73505: LD_EXP 69
73509: PUSH
73510: LD_VAR 0 4
73514: ARRAY
73515: PUSH
73516: LD_VAR 0 1
73520: DIFF
73521: PPUSH
73522: CALL_OW 1
73526: ST_TO_ADDR
// for i = 1 to mc_bases do
73527: LD_ADDR_VAR 0 5
73531: PUSH
73532: DOUBLE
73533: LD_INT 1
73535: DEC
73536: ST_TO_ADDR
73537: LD_EXP 42
73541: PUSH
73542: FOR_TO
73543: IFFALSE 73721
// begin if lab in mc_bases [ i ] then
73545: LD_VAR 0 2
73549: PUSH
73550: LD_EXP 42
73554: PUSH
73555: LD_VAR 0 5
73559: ARRAY
73560: IN
73561: IFFALSE 73719
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
73563: LD_VAR 0 1
73567: PUSH
73568: LD_INT 11
73570: PUSH
73571: LD_INT 4
73573: PUSH
73574: LD_INT 3
73576: PUSH
73577: LD_INT 2
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: IN
73586: PUSH
73587: LD_EXP 72
73591: PUSH
73592: LD_VAR 0 5
73596: ARRAY
73597: AND
73598: IFFALSE 73719
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
73600: LD_ADDR_VAR 0 6
73604: PUSH
73605: LD_EXP 72
73609: PUSH
73610: LD_VAR 0 5
73614: ARRAY
73615: PUSH
73616: LD_INT 1
73618: ARRAY
73619: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
73620: LD_ADDR_EXP 72
73624: PUSH
73625: LD_EXP 72
73629: PPUSH
73630: LD_VAR 0 5
73634: PPUSH
73635: EMPTY
73636: PPUSH
73637: CALL_OW 1
73641: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
73642: LD_VAR 0 6
73646: PPUSH
73647: LD_INT 0
73649: PPUSH
73650: CALL_OW 109
// ComExitBuilding ( tmp ) ;
73654: LD_VAR 0 6
73658: PPUSH
73659: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
73663: LD_ADDR_EXP 71
73667: PUSH
73668: LD_EXP 71
73672: PPUSH
73673: LD_VAR 0 5
73677: PPUSH
73678: LD_EXP 71
73682: PUSH
73683: LD_VAR 0 5
73687: ARRAY
73688: PPUSH
73689: LD_INT 1
73691: PPUSH
73692: LD_VAR 0 6
73696: PPUSH
73697: CALL_OW 2
73701: PPUSH
73702: CALL_OW 1
73706: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
73707: LD_VAR 0 5
73711: PPUSH
73712: LD_INT 112
73714: PPUSH
73715: CALL 50668 0 2
// end ; end ; end ;
73719: GO 73542
73721: POP
73722: POP
// end ;
73723: LD_VAR 0 3
73727: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
73728: LD_INT 0
73730: PPUSH
73731: PPUSH
73732: PPUSH
73733: PPUSH
73734: PPUSH
73735: PPUSH
73736: PPUSH
73737: PPUSH
// if not mc_bases or not skirmish then
73738: LD_EXP 42
73742: NOT
73743: PUSH
73744: LD_EXP 40
73748: NOT
73749: OR
73750: IFFALSE 73754
// exit ;
73752: GO 75125
// for i = 1 to mc_bases do
73754: LD_ADDR_VAR 0 3
73758: PUSH
73759: DOUBLE
73760: LD_INT 1
73762: DEC
73763: ST_TO_ADDR
73764: LD_EXP 42
73768: PUSH
73769: FOR_TO
73770: IFFALSE 75123
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
73772: LD_VAR 0 1
73776: PUSH
73777: LD_EXP 42
73781: PUSH
73782: LD_VAR 0 3
73786: ARRAY
73787: IN
73788: PUSH
73789: LD_VAR 0 1
73793: PUSH
73794: LD_EXP 49
73798: PUSH
73799: LD_VAR 0 3
73803: ARRAY
73804: IN
73805: OR
73806: PUSH
73807: LD_VAR 0 1
73811: PUSH
73812: LD_EXP 64
73816: PUSH
73817: LD_VAR 0 3
73821: ARRAY
73822: IN
73823: OR
73824: PUSH
73825: LD_VAR 0 1
73829: PUSH
73830: LD_EXP 61
73834: PUSH
73835: LD_VAR 0 3
73839: ARRAY
73840: IN
73841: OR
73842: PUSH
73843: LD_VAR 0 1
73847: PUSH
73848: LD_EXP 71
73852: PUSH
73853: LD_VAR 0 3
73857: ARRAY
73858: IN
73859: OR
73860: PUSH
73861: LD_VAR 0 1
73865: PUSH
73866: LD_EXP 72
73870: PUSH
73871: LD_VAR 0 3
73875: ARRAY
73876: IN
73877: OR
73878: IFFALSE 75121
// begin if un in mc_ape [ i ] then
73880: LD_VAR 0 1
73884: PUSH
73885: LD_EXP 71
73889: PUSH
73890: LD_VAR 0 3
73894: ARRAY
73895: IN
73896: IFFALSE 73935
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
73898: LD_ADDR_EXP 71
73902: PUSH
73903: LD_EXP 71
73907: PPUSH
73908: LD_VAR 0 3
73912: PPUSH
73913: LD_EXP 71
73917: PUSH
73918: LD_VAR 0 3
73922: ARRAY
73923: PUSH
73924: LD_VAR 0 1
73928: DIFF
73929: PPUSH
73930: CALL_OW 1
73934: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
73935: LD_VAR 0 1
73939: PUSH
73940: LD_EXP 72
73944: PUSH
73945: LD_VAR 0 3
73949: ARRAY
73950: IN
73951: IFFALSE 73975
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
73953: LD_ADDR_EXP 72
73957: PUSH
73958: LD_EXP 72
73962: PPUSH
73963: LD_VAR 0 3
73967: PPUSH
73968: EMPTY
73969: PPUSH
73970: CALL_OW 1
73974: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
73975: LD_VAR 0 1
73979: PPUSH
73980: CALL_OW 247
73984: PUSH
73985: LD_INT 2
73987: EQUAL
73988: PUSH
73989: LD_VAR 0 1
73993: PPUSH
73994: CALL_OW 110
73998: PUSH
73999: LD_INT 20
74001: EQUAL
74002: PUSH
74003: LD_VAR 0 1
74007: PUSH
74008: LD_EXP 64
74012: PUSH
74013: LD_VAR 0 3
74017: ARRAY
74018: IN
74019: OR
74020: PUSH
74021: LD_VAR 0 1
74025: PPUSH
74026: CALL_OW 264
74030: PUSH
74031: LD_INT 12
74033: PUSH
74034: LD_INT 51
74036: PUSH
74037: LD_EXP 86
74041: PUSH
74042: LD_INT 32
74044: PUSH
74045: LD_INT 13
74047: PUSH
74048: LD_INT 52
74050: PUSH
74051: LD_INT 31
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: IN
74063: OR
74064: AND
74065: IFFALSE 74373
// begin if un in mc_defender [ i ] then
74067: LD_VAR 0 1
74071: PUSH
74072: LD_EXP 64
74076: PUSH
74077: LD_VAR 0 3
74081: ARRAY
74082: IN
74083: IFFALSE 74122
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
74085: LD_ADDR_EXP 64
74089: PUSH
74090: LD_EXP 64
74094: PPUSH
74095: LD_VAR 0 3
74099: PPUSH
74100: LD_EXP 64
74104: PUSH
74105: LD_VAR 0 3
74109: ARRAY
74110: PUSH
74111: LD_VAR 0 1
74115: DIFF
74116: PPUSH
74117: CALL_OW 1
74121: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
74122: LD_ADDR_VAR 0 8
74126: PUSH
74127: LD_VAR 0 3
74131: PPUSH
74132: LD_INT 3
74134: PPUSH
74135: CALL 70772 0 2
74139: ST_TO_ADDR
// if fac then
74140: LD_VAR 0 8
74144: IFFALSE 74373
// begin for j in fac do
74146: LD_ADDR_VAR 0 4
74150: PUSH
74151: LD_VAR 0 8
74155: PUSH
74156: FOR_IN
74157: IFFALSE 74371
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
74159: LD_ADDR_VAR 0 9
74163: PUSH
74164: LD_VAR 0 8
74168: PPUSH
74169: LD_VAR 0 1
74173: PPUSH
74174: CALL_OW 265
74178: PPUSH
74179: LD_VAR 0 1
74183: PPUSH
74184: CALL_OW 262
74188: PPUSH
74189: LD_VAR 0 1
74193: PPUSH
74194: CALL_OW 263
74198: PPUSH
74199: LD_VAR 0 1
74203: PPUSH
74204: CALL_OW 264
74208: PPUSH
74209: CALL 11864 0 5
74213: ST_TO_ADDR
// if components then
74214: LD_VAR 0 9
74218: IFFALSE 74369
// begin if GetWeapon ( un ) = ar_control_tower then
74220: LD_VAR 0 1
74224: PPUSH
74225: CALL_OW 264
74229: PUSH
74230: LD_INT 31
74232: EQUAL
74233: IFFALSE 74350
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
74235: LD_VAR 0 1
74239: PPUSH
74240: CALL_OW 311
74244: PPUSH
74245: LD_INT 0
74247: PPUSH
74248: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
74252: LD_ADDR_EXP 82
74256: PUSH
74257: LD_EXP 82
74261: PPUSH
74262: LD_VAR 0 3
74266: PPUSH
74267: LD_EXP 82
74271: PUSH
74272: LD_VAR 0 3
74276: ARRAY
74277: PUSH
74278: LD_VAR 0 1
74282: PPUSH
74283: CALL_OW 311
74287: DIFF
74288: PPUSH
74289: CALL_OW 1
74293: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
74294: LD_ADDR_VAR 0 7
74298: PUSH
74299: LD_EXP 63
74303: PUSH
74304: LD_VAR 0 3
74308: ARRAY
74309: PPUSH
74310: LD_INT 1
74312: PPUSH
74313: LD_VAR 0 9
74317: PPUSH
74318: CALL_OW 2
74322: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
74323: LD_ADDR_EXP 63
74327: PUSH
74328: LD_EXP 63
74332: PPUSH
74333: LD_VAR 0 3
74337: PPUSH
74338: LD_VAR 0 7
74342: PPUSH
74343: CALL_OW 1
74347: ST_TO_ADDR
// end else
74348: GO 74367
// MC_InsertProduceList ( i , [ components ] ) ;
74350: LD_VAR 0 3
74354: PPUSH
74355: LD_VAR 0 9
74359: PUSH
74360: EMPTY
74361: LIST
74362: PPUSH
74363: CALL 70317 0 2
// break ;
74367: GO 74371
// end ; end ;
74369: GO 74156
74371: POP
74372: POP
// end ; end ; if GetType ( un ) = unit_building then
74373: LD_VAR 0 1
74377: PPUSH
74378: CALL_OW 247
74382: PUSH
74383: LD_INT 3
74385: EQUAL
74386: IFFALSE 74789
// begin btype := GetBType ( un ) ;
74388: LD_ADDR_VAR 0 5
74392: PUSH
74393: LD_VAR 0 1
74397: PPUSH
74398: CALL_OW 266
74402: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
74403: LD_VAR 0 5
74407: PUSH
74408: LD_INT 29
74410: PUSH
74411: LD_INT 30
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: IN
74418: IFFALSE 74491
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
74420: LD_VAR 0 1
74424: PPUSH
74425: CALL_OW 250
74429: PPUSH
74430: LD_VAR 0 1
74434: PPUSH
74435: CALL_OW 251
74439: PPUSH
74440: LD_VAR 0 1
74444: PPUSH
74445: CALL_OW 255
74449: PPUSH
74450: CALL_OW 440
74454: NOT
74455: IFFALSE 74491
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
74457: LD_VAR 0 1
74461: PPUSH
74462: CALL_OW 250
74466: PPUSH
74467: LD_VAR 0 1
74471: PPUSH
74472: CALL_OW 251
74476: PPUSH
74477: LD_VAR 0 1
74481: PPUSH
74482: CALL_OW 255
74486: PPUSH
74487: CALL_OW 441
// end ; if btype = b_warehouse then
74491: LD_VAR 0 5
74495: PUSH
74496: LD_INT 1
74498: EQUAL
74499: IFFALSE 74517
// begin btype := b_depot ;
74501: LD_ADDR_VAR 0 5
74505: PUSH
74506: LD_INT 0
74508: ST_TO_ADDR
// pos := 1 ;
74509: LD_ADDR_VAR 0 6
74513: PUSH
74514: LD_INT 1
74516: ST_TO_ADDR
// end ; if btype = b_factory then
74517: LD_VAR 0 5
74521: PUSH
74522: LD_INT 3
74524: EQUAL
74525: IFFALSE 74543
// begin btype := b_workshop ;
74527: LD_ADDR_VAR 0 5
74531: PUSH
74532: LD_INT 2
74534: ST_TO_ADDR
// pos := 1 ;
74535: LD_ADDR_VAR 0 6
74539: PUSH
74540: LD_INT 1
74542: ST_TO_ADDR
// end ; if btype = b_barracks then
74543: LD_VAR 0 5
74547: PUSH
74548: LD_INT 5
74550: EQUAL
74551: IFFALSE 74561
// btype := b_armoury ;
74553: LD_ADDR_VAR 0 5
74557: PUSH
74558: LD_INT 4
74560: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
74561: LD_VAR 0 5
74565: PUSH
74566: LD_INT 7
74568: PUSH
74569: LD_INT 8
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: IN
74576: IFFALSE 74586
// btype := b_lab ;
74578: LD_ADDR_VAR 0 5
74582: PUSH
74583: LD_INT 6
74585: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
74586: LD_ADDR_EXP 47
74590: PUSH
74591: LD_EXP 47
74595: PPUSH
74596: LD_VAR 0 3
74600: PUSH
74601: LD_EXP 47
74605: PUSH
74606: LD_VAR 0 3
74610: ARRAY
74611: PUSH
74612: LD_INT 1
74614: PLUS
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PPUSH
74620: LD_VAR 0 5
74624: PUSH
74625: LD_VAR 0 1
74629: PPUSH
74630: CALL_OW 250
74634: PUSH
74635: LD_VAR 0 1
74639: PPUSH
74640: CALL_OW 251
74644: PUSH
74645: LD_VAR 0 1
74649: PPUSH
74650: CALL_OW 254
74654: PUSH
74655: EMPTY
74656: LIST
74657: LIST
74658: LIST
74659: LIST
74660: PPUSH
74661: CALL 14332 0 3
74665: ST_TO_ADDR
// if pos = 1 then
74666: LD_VAR 0 6
74670: PUSH
74671: LD_INT 1
74673: EQUAL
74674: IFFALSE 74789
// begin tmp := mc_build_list [ i ] ;
74676: LD_ADDR_VAR 0 7
74680: PUSH
74681: LD_EXP 47
74685: PUSH
74686: LD_VAR 0 3
74690: ARRAY
74691: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74692: LD_VAR 0 7
74696: PPUSH
74697: LD_INT 2
74699: PUSH
74700: LD_INT 30
74702: PUSH
74703: LD_INT 0
74705: PUSH
74706: EMPTY
74707: LIST
74708: LIST
74709: PUSH
74710: LD_INT 30
74712: PUSH
74713: LD_INT 1
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: LIST
74724: PPUSH
74725: CALL_OW 72
74729: IFFALSE 74739
// pos := 2 ;
74731: LD_ADDR_VAR 0 6
74735: PUSH
74736: LD_INT 2
74738: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
74739: LD_ADDR_VAR 0 7
74743: PUSH
74744: LD_VAR 0 7
74748: PPUSH
74749: LD_VAR 0 6
74753: PPUSH
74754: LD_VAR 0 7
74758: PPUSH
74759: CALL 14658 0 3
74763: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
74764: LD_ADDR_EXP 47
74768: PUSH
74769: LD_EXP 47
74773: PPUSH
74774: LD_VAR 0 3
74778: PPUSH
74779: LD_VAR 0 7
74783: PPUSH
74784: CALL_OW 1
74788: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
74789: LD_VAR 0 1
74793: PUSH
74794: LD_EXP 42
74798: PUSH
74799: LD_VAR 0 3
74803: ARRAY
74804: IN
74805: IFFALSE 74844
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
74807: LD_ADDR_EXP 42
74811: PUSH
74812: LD_EXP 42
74816: PPUSH
74817: LD_VAR 0 3
74821: PPUSH
74822: LD_EXP 42
74826: PUSH
74827: LD_VAR 0 3
74831: ARRAY
74832: PUSH
74833: LD_VAR 0 1
74837: DIFF
74838: PPUSH
74839: CALL_OW 1
74843: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
74844: LD_VAR 0 1
74848: PUSH
74849: LD_EXP 49
74853: PUSH
74854: LD_VAR 0 3
74858: ARRAY
74859: IN
74860: IFFALSE 74899
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
74862: LD_ADDR_EXP 49
74866: PUSH
74867: LD_EXP 49
74871: PPUSH
74872: LD_VAR 0 3
74876: PPUSH
74877: LD_EXP 49
74881: PUSH
74882: LD_VAR 0 3
74886: ARRAY
74887: PUSH
74888: LD_VAR 0 1
74892: DIFF
74893: PPUSH
74894: CALL_OW 1
74898: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
74899: LD_VAR 0 1
74903: PUSH
74904: LD_EXP 61
74908: PUSH
74909: LD_VAR 0 3
74913: ARRAY
74914: IN
74915: IFFALSE 74954
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
74917: LD_ADDR_EXP 61
74921: PUSH
74922: LD_EXP 61
74926: PPUSH
74927: LD_VAR 0 3
74931: PPUSH
74932: LD_EXP 61
74936: PUSH
74937: LD_VAR 0 3
74941: ARRAY
74942: PUSH
74943: LD_VAR 0 1
74947: DIFF
74948: PPUSH
74949: CALL_OW 1
74953: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
74954: LD_VAR 0 1
74958: PUSH
74959: LD_EXP 64
74963: PUSH
74964: LD_VAR 0 3
74968: ARRAY
74969: IN
74970: IFFALSE 75009
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
74972: LD_ADDR_EXP 64
74976: PUSH
74977: LD_EXP 64
74981: PPUSH
74982: LD_VAR 0 3
74986: PPUSH
74987: LD_EXP 64
74991: PUSH
74992: LD_VAR 0 3
74996: ARRAY
74997: PUSH
74998: LD_VAR 0 1
75002: DIFF
75003: PPUSH
75004: CALL_OW 1
75008: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
75009: LD_VAR 0 1
75013: PUSH
75014: LD_EXP 51
75018: PUSH
75019: LD_VAR 0 3
75023: ARRAY
75024: IN
75025: IFFALSE 75064
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
75027: LD_ADDR_EXP 51
75031: PUSH
75032: LD_EXP 51
75036: PPUSH
75037: LD_VAR 0 3
75041: PPUSH
75042: LD_EXP 51
75046: PUSH
75047: LD_VAR 0 3
75051: ARRAY
75052: PUSH
75053: LD_VAR 0 1
75057: DIFF
75058: PPUSH
75059: CALL_OW 1
75063: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
75064: LD_VAR 0 1
75068: PUSH
75069: LD_EXP 50
75073: PUSH
75074: LD_VAR 0 3
75078: ARRAY
75079: IN
75080: IFFALSE 75119
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
75082: LD_ADDR_EXP 50
75086: PUSH
75087: LD_EXP 50
75091: PPUSH
75092: LD_VAR 0 3
75096: PPUSH
75097: LD_EXP 50
75101: PUSH
75102: LD_VAR 0 3
75106: ARRAY
75107: PUSH
75108: LD_VAR 0 1
75112: DIFF
75113: PPUSH
75114: CALL_OW 1
75118: ST_TO_ADDR
// end ; break ;
75119: GO 75123
// end ;
75121: GO 73769
75123: POP
75124: POP
// end ;
75125: LD_VAR 0 2
75129: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
75130: LD_INT 0
75132: PPUSH
75133: PPUSH
75134: PPUSH
// if not mc_bases or not skirmish then
75135: LD_EXP 42
75139: NOT
75140: PUSH
75141: LD_EXP 40
75145: NOT
75146: OR
75147: IFFALSE 75151
// exit ;
75149: GO 75366
// for i = 1 to mc_bases do
75151: LD_ADDR_VAR 0 3
75155: PUSH
75156: DOUBLE
75157: LD_INT 1
75159: DEC
75160: ST_TO_ADDR
75161: LD_EXP 42
75165: PUSH
75166: FOR_TO
75167: IFFALSE 75364
// begin if building in mc_construct_list [ i ] then
75169: LD_VAR 0 1
75173: PUSH
75174: LD_EXP 49
75178: PUSH
75179: LD_VAR 0 3
75183: ARRAY
75184: IN
75185: IFFALSE 75362
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75187: LD_ADDR_EXP 49
75191: PUSH
75192: LD_EXP 49
75196: PPUSH
75197: LD_VAR 0 3
75201: PPUSH
75202: LD_EXP 49
75206: PUSH
75207: LD_VAR 0 3
75211: ARRAY
75212: PUSH
75213: LD_VAR 0 1
75217: DIFF
75218: PPUSH
75219: CALL_OW 1
75223: ST_TO_ADDR
// if building in mc_lab [ i ] then
75224: LD_VAR 0 1
75228: PUSH
75229: LD_EXP 75
75233: PUSH
75234: LD_VAR 0 3
75238: ARRAY
75239: IN
75240: IFFALSE 75295
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
75242: LD_ADDR_EXP 76
75246: PUSH
75247: LD_EXP 76
75251: PPUSH
75252: LD_VAR 0 3
75256: PPUSH
75257: LD_EXP 76
75261: PUSH
75262: LD_VAR 0 3
75266: ARRAY
75267: PPUSH
75268: LD_INT 1
75270: PPUSH
75271: LD_EXP 76
75275: PUSH
75276: LD_VAR 0 3
75280: ARRAY
75281: PPUSH
75282: LD_INT 0
75284: PPUSH
75285: CALL 13750 0 4
75289: PPUSH
75290: CALL_OW 1
75294: ST_TO_ADDR
// if not building in mc_bases [ i ] then
75295: LD_VAR 0 1
75299: PUSH
75300: LD_EXP 42
75304: PUSH
75305: LD_VAR 0 3
75309: ARRAY
75310: IN
75311: NOT
75312: IFFALSE 75358
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
75314: LD_ADDR_EXP 42
75318: PUSH
75319: LD_EXP 42
75323: PPUSH
75324: LD_VAR 0 3
75328: PUSH
75329: LD_EXP 42
75333: PUSH
75334: LD_VAR 0 3
75338: ARRAY
75339: PUSH
75340: LD_INT 1
75342: PLUS
75343: PUSH
75344: EMPTY
75345: LIST
75346: LIST
75347: PPUSH
75348: LD_VAR 0 1
75352: PPUSH
75353: CALL 14332 0 3
75357: ST_TO_ADDR
// exit ;
75358: POP
75359: POP
75360: GO 75366
// end ; end ;
75362: GO 75166
75364: POP
75365: POP
// end ;
75366: LD_VAR 0 2
75370: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
75371: LD_INT 0
75373: PPUSH
75374: PPUSH
75375: PPUSH
75376: PPUSH
75377: PPUSH
75378: PPUSH
75379: PPUSH
// if not mc_bases or not skirmish then
75380: LD_EXP 42
75384: NOT
75385: PUSH
75386: LD_EXP 40
75390: NOT
75391: OR
75392: IFFALSE 75396
// exit ;
75394: GO 76057
// for i = 1 to mc_bases do
75396: LD_ADDR_VAR 0 3
75400: PUSH
75401: DOUBLE
75402: LD_INT 1
75404: DEC
75405: ST_TO_ADDR
75406: LD_EXP 42
75410: PUSH
75411: FOR_TO
75412: IFFALSE 76055
// begin if building in mc_construct_list [ i ] then
75414: LD_VAR 0 1
75418: PUSH
75419: LD_EXP 49
75423: PUSH
75424: LD_VAR 0 3
75428: ARRAY
75429: IN
75430: IFFALSE 76053
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75432: LD_ADDR_EXP 49
75436: PUSH
75437: LD_EXP 49
75441: PPUSH
75442: LD_VAR 0 3
75446: PPUSH
75447: LD_EXP 49
75451: PUSH
75452: LD_VAR 0 3
75456: ARRAY
75457: PUSH
75458: LD_VAR 0 1
75462: DIFF
75463: PPUSH
75464: CALL_OW 1
75468: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
75469: LD_ADDR_EXP 42
75473: PUSH
75474: LD_EXP 42
75478: PPUSH
75479: LD_VAR 0 3
75483: PUSH
75484: LD_EXP 42
75488: PUSH
75489: LD_VAR 0 3
75493: ARRAY
75494: PUSH
75495: LD_INT 1
75497: PLUS
75498: PUSH
75499: EMPTY
75500: LIST
75501: LIST
75502: PPUSH
75503: LD_VAR 0 1
75507: PPUSH
75508: CALL 14332 0 3
75512: ST_TO_ADDR
// btype := GetBType ( building ) ;
75513: LD_ADDR_VAR 0 5
75517: PUSH
75518: LD_VAR 0 1
75522: PPUSH
75523: CALL_OW 266
75527: ST_TO_ADDR
// side := GetSide ( building ) ;
75528: LD_ADDR_VAR 0 8
75532: PUSH
75533: LD_VAR 0 1
75537: PPUSH
75538: CALL_OW 255
75542: ST_TO_ADDR
// if btype = b_lab then
75543: LD_VAR 0 5
75547: PUSH
75548: LD_INT 6
75550: EQUAL
75551: IFFALSE 75601
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
75553: LD_ADDR_EXP 75
75557: PUSH
75558: LD_EXP 75
75562: PPUSH
75563: LD_VAR 0 3
75567: PUSH
75568: LD_EXP 75
75572: PUSH
75573: LD_VAR 0 3
75577: ARRAY
75578: PUSH
75579: LD_INT 1
75581: PLUS
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PPUSH
75587: LD_VAR 0 1
75591: PPUSH
75592: CALL 14332 0 3
75596: ST_TO_ADDR
// exit ;
75597: POP
75598: POP
75599: GO 76057
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
75601: LD_VAR 0 5
75605: PUSH
75606: LD_INT 0
75608: PUSH
75609: LD_INT 2
75611: PUSH
75612: LD_INT 4
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: LIST
75619: IN
75620: IFFALSE 75744
// begin if btype = b_armoury then
75622: LD_VAR 0 5
75626: PUSH
75627: LD_INT 4
75629: EQUAL
75630: IFFALSE 75640
// btype := b_barracks ;
75632: LD_ADDR_VAR 0 5
75636: PUSH
75637: LD_INT 5
75639: ST_TO_ADDR
// if btype = b_depot then
75640: LD_VAR 0 5
75644: PUSH
75645: LD_INT 0
75647: EQUAL
75648: IFFALSE 75658
// btype := b_warehouse ;
75650: LD_ADDR_VAR 0 5
75654: PUSH
75655: LD_INT 1
75657: ST_TO_ADDR
// if btype = b_workshop then
75658: LD_VAR 0 5
75662: PUSH
75663: LD_INT 2
75665: EQUAL
75666: IFFALSE 75676
// btype := b_factory ;
75668: LD_ADDR_VAR 0 5
75672: PUSH
75673: LD_INT 3
75675: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
75676: LD_VAR 0 5
75680: PPUSH
75681: LD_VAR 0 8
75685: PPUSH
75686: CALL_OW 323
75690: PUSH
75691: LD_INT 1
75693: EQUAL
75694: IFFALSE 75740
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
75696: LD_ADDR_EXP 74
75700: PUSH
75701: LD_EXP 74
75705: PPUSH
75706: LD_VAR 0 3
75710: PUSH
75711: LD_EXP 74
75715: PUSH
75716: LD_VAR 0 3
75720: ARRAY
75721: PUSH
75722: LD_INT 1
75724: PLUS
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PPUSH
75730: LD_VAR 0 1
75734: PPUSH
75735: CALL 14332 0 3
75739: ST_TO_ADDR
// exit ;
75740: POP
75741: POP
75742: GO 76057
// end ; if btype in [ b_bunker , b_turret ] then
75744: LD_VAR 0 5
75748: PUSH
75749: LD_INT 32
75751: PUSH
75752: LD_INT 33
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: IN
75759: IFFALSE 76049
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
75761: LD_ADDR_EXP 50
75765: PUSH
75766: LD_EXP 50
75770: PPUSH
75771: LD_VAR 0 3
75775: PUSH
75776: LD_EXP 50
75780: PUSH
75781: LD_VAR 0 3
75785: ARRAY
75786: PUSH
75787: LD_INT 1
75789: PLUS
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PPUSH
75795: LD_VAR 0 1
75799: PPUSH
75800: CALL 14332 0 3
75804: ST_TO_ADDR
// if btype = b_bunker then
75805: LD_VAR 0 5
75809: PUSH
75810: LD_INT 32
75812: EQUAL
75813: IFFALSE 76049
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
75815: LD_ADDR_EXP 51
75819: PUSH
75820: LD_EXP 51
75824: PPUSH
75825: LD_VAR 0 3
75829: PUSH
75830: LD_EXP 51
75834: PUSH
75835: LD_VAR 0 3
75839: ARRAY
75840: PUSH
75841: LD_INT 1
75843: PLUS
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PPUSH
75849: LD_VAR 0 1
75853: PPUSH
75854: CALL 14332 0 3
75858: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
75859: LD_ADDR_VAR 0 6
75863: PUSH
75864: LD_EXP 42
75868: PUSH
75869: LD_VAR 0 3
75873: ARRAY
75874: PPUSH
75875: LD_INT 25
75877: PUSH
75878: LD_INT 1
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: LD_INT 3
75887: PUSH
75888: LD_INT 54
75890: PUSH
75891: EMPTY
75892: LIST
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: PPUSH
75902: CALL_OW 72
75906: ST_TO_ADDR
// if tmp then
75907: LD_VAR 0 6
75911: IFFALSE 75917
// exit ;
75913: POP
75914: POP
75915: GO 76057
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
75917: LD_ADDR_VAR 0 6
75921: PUSH
75922: LD_EXP 42
75926: PUSH
75927: LD_VAR 0 3
75931: ARRAY
75932: PPUSH
75933: LD_INT 2
75935: PUSH
75936: LD_INT 30
75938: PUSH
75939: LD_INT 4
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: LD_INT 30
75948: PUSH
75949: LD_INT 5
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: LIST
75960: PPUSH
75961: CALL_OW 72
75965: ST_TO_ADDR
// if not tmp then
75966: LD_VAR 0 6
75970: NOT
75971: IFFALSE 75977
// exit ;
75973: POP
75974: POP
75975: GO 76057
// for j in tmp do
75977: LD_ADDR_VAR 0 4
75981: PUSH
75982: LD_VAR 0 6
75986: PUSH
75987: FOR_IN
75988: IFFALSE 76047
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
75990: LD_ADDR_VAR 0 7
75994: PUSH
75995: LD_VAR 0 4
75999: PPUSH
76000: CALL_OW 313
76004: PPUSH
76005: LD_INT 25
76007: PUSH
76008: LD_INT 1
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PPUSH
76015: CALL_OW 72
76019: ST_TO_ADDR
// if units then
76020: LD_VAR 0 7
76024: IFFALSE 76045
// begin ComExitBuilding ( units [ 1 ] ) ;
76026: LD_VAR 0 7
76030: PUSH
76031: LD_INT 1
76033: ARRAY
76034: PPUSH
76035: CALL_OW 122
// exit ;
76039: POP
76040: POP
76041: POP
76042: POP
76043: GO 76057
// end ; end ;
76045: GO 75987
76047: POP
76048: POP
// end ; end ; exit ;
76049: POP
76050: POP
76051: GO 76057
// end ; end ;
76053: GO 75411
76055: POP
76056: POP
// end ;
76057: LD_VAR 0 2
76061: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
76062: LD_INT 0
76064: PPUSH
76065: PPUSH
76066: PPUSH
76067: PPUSH
76068: PPUSH
76069: PPUSH
76070: PPUSH
// if not mc_bases or not skirmish then
76071: LD_EXP 42
76075: NOT
76076: PUSH
76077: LD_EXP 40
76081: NOT
76082: OR
76083: IFFALSE 76087
// exit ;
76085: GO 76318
// btype := GetBType ( building ) ;
76087: LD_ADDR_VAR 0 6
76091: PUSH
76092: LD_VAR 0 1
76096: PPUSH
76097: CALL_OW 266
76101: ST_TO_ADDR
// x := GetX ( building ) ;
76102: LD_ADDR_VAR 0 7
76106: PUSH
76107: LD_VAR 0 1
76111: PPUSH
76112: CALL_OW 250
76116: ST_TO_ADDR
// y := GetY ( building ) ;
76117: LD_ADDR_VAR 0 8
76121: PUSH
76122: LD_VAR 0 1
76126: PPUSH
76127: CALL_OW 251
76131: ST_TO_ADDR
// d := GetDir ( building ) ;
76132: LD_ADDR_VAR 0 9
76136: PUSH
76137: LD_VAR 0 1
76141: PPUSH
76142: CALL_OW 254
76146: ST_TO_ADDR
// for i = 1 to mc_bases do
76147: LD_ADDR_VAR 0 4
76151: PUSH
76152: DOUBLE
76153: LD_INT 1
76155: DEC
76156: ST_TO_ADDR
76157: LD_EXP 42
76161: PUSH
76162: FOR_TO
76163: IFFALSE 76316
// begin if not mc_build_list [ i ] then
76165: LD_EXP 47
76169: PUSH
76170: LD_VAR 0 4
76174: ARRAY
76175: NOT
76176: IFFALSE 76180
// continue ;
76178: GO 76162
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
76180: LD_VAR 0 6
76184: PUSH
76185: LD_VAR 0 7
76189: PUSH
76190: LD_VAR 0 8
76194: PUSH
76195: LD_VAR 0 9
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: PPUSH
76206: LD_EXP 47
76210: PUSH
76211: LD_VAR 0 4
76215: ARRAY
76216: PUSH
76217: LD_INT 1
76219: ARRAY
76220: PPUSH
76221: CALL 20501 0 2
76225: IFFALSE 76314
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
76227: LD_ADDR_EXP 47
76231: PUSH
76232: LD_EXP 47
76236: PPUSH
76237: LD_VAR 0 4
76241: PPUSH
76242: LD_EXP 47
76246: PUSH
76247: LD_VAR 0 4
76251: ARRAY
76252: PPUSH
76253: LD_INT 1
76255: PPUSH
76256: CALL_OW 3
76260: PPUSH
76261: CALL_OW 1
76265: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
76266: LD_ADDR_EXP 49
76270: PUSH
76271: LD_EXP 49
76275: PPUSH
76276: LD_VAR 0 4
76280: PUSH
76281: LD_EXP 49
76285: PUSH
76286: LD_VAR 0 4
76290: ARRAY
76291: PUSH
76292: LD_INT 1
76294: PLUS
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: PPUSH
76300: LD_VAR 0 1
76304: PPUSH
76305: CALL 14332 0 3
76309: ST_TO_ADDR
// exit ;
76310: POP
76311: POP
76312: GO 76318
// end ; end ;
76314: GO 76162
76316: POP
76317: POP
// end ;
76318: LD_VAR 0 3
76322: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
76323: LD_INT 0
76325: PPUSH
76326: PPUSH
76327: PPUSH
// if not mc_bases or not skirmish then
76328: LD_EXP 42
76332: NOT
76333: PUSH
76334: LD_EXP 40
76338: NOT
76339: OR
76340: IFFALSE 76344
// exit ;
76342: GO 76534
// for i = 1 to mc_bases do
76344: LD_ADDR_VAR 0 4
76348: PUSH
76349: DOUBLE
76350: LD_INT 1
76352: DEC
76353: ST_TO_ADDR
76354: LD_EXP 42
76358: PUSH
76359: FOR_TO
76360: IFFALSE 76447
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
76362: LD_VAR 0 1
76366: PUSH
76367: LD_EXP 50
76371: PUSH
76372: LD_VAR 0 4
76376: ARRAY
76377: IN
76378: PUSH
76379: LD_VAR 0 1
76383: PUSH
76384: LD_EXP 51
76388: PUSH
76389: LD_VAR 0 4
76393: ARRAY
76394: IN
76395: NOT
76396: AND
76397: IFFALSE 76445
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76399: LD_ADDR_EXP 51
76403: PUSH
76404: LD_EXP 51
76408: PPUSH
76409: LD_VAR 0 4
76413: PUSH
76414: LD_EXP 51
76418: PUSH
76419: LD_VAR 0 4
76423: ARRAY
76424: PUSH
76425: LD_INT 1
76427: PLUS
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PPUSH
76433: LD_VAR 0 1
76437: PPUSH
76438: CALL 14332 0 3
76442: ST_TO_ADDR
// break ;
76443: GO 76447
// end ; end ;
76445: GO 76359
76447: POP
76448: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
76449: LD_VAR 0 1
76453: PPUSH
76454: CALL_OW 257
76458: PUSH
76459: LD_EXP 68
76463: IN
76464: PUSH
76465: LD_VAR 0 1
76469: PPUSH
76470: CALL_OW 266
76474: PUSH
76475: LD_INT 5
76477: EQUAL
76478: AND
76479: PUSH
76480: LD_VAR 0 2
76484: PPUSH
76485: CALL_OW 110
76489: PUSH
76490: LD_INT 18
76492: NONEQUAL
76493: AND
76494: IFFALSE 76534
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
76496: LD_VAR 0 2
76500: PPUSH
76501: CALL_OW 257
76505: PUSH
76506: LD_INT 5
76508: PUSH
76509: LD_INT 8
76511: PUSH
76512: LD_INT 9
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: LIST
76519: IN
76520: IFFALSE 76534
// SetClass ( unit , 1 ) ;
76522: LD_VAR 0 2
76526: PPUSH
76527: LD_INT 1
76529: PPUSH
76530: CALL_OW 336
// end ;
76534: LD_VAR 0 3
76538: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
76539: LD_INT 0
76541: PPUSH
76542: PPUSH
// if not mc_bases or not skirmish then
76543: LD_EXP 42
76547: NOT
76548: PUSH
76549: LD_EXP 40
76553: NOT
76554: OR
76555: IFFALSE 76559
// exit ;
76557: GO 76675
// if GetLives ( abandoned_vehicle ) > 250 then
76559: LD_VAR 0 2
76563: PPUSH
76564: CALL_OW 256
76568: PUSH
76569: LD_INT 250
76571: GREATER
76572: IFFALSE 76576
// exit ;
76574: GO 76675
// for i = 1 to mc_bases do
76576: LD_ADDR_VAR 0 6
76580: PUSH
76581: DOUBLE
76582: LD_INT 1
76584: DEC
76585: ST_TO_ADDR
76586: LD_EXP 42
76590: PUSH
76591: FOR_TO
76592: IFFALSE 76673
// begin if driver in mc_bases [ i ] then
76594: LD_VAR 0 1
76598: PUSH
76599: LD_EXP 42
76603: PUSH
76604: LD_VAR 0 6
76608: ARRAY
76609: IN
76610: IFFALSE 76671
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
76612: LD_VAR 0 1
76616: PPUSH
76617: LD_EXP 42
76621: PUSH
76622: LD_VAR 0 6
76626: ARRAY
76627: PPUSH
76628: LD_INT 2
76630: PUSH
76631: LD_INT 30
76633: PUSH
76634: LD_INT 0
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: LD_INT 30
76643: PUSH
76644: LD_INT 1
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: LIST
76655: PPUSH
76656: CALL_OW 72
76660: PUSH
76661: LD_INT 1
76663: ARRAY
76664: PPUSH
76665: CALL 46198 0 2
// break ;
76669: GO 76673
// end ; end ;
76671: GO 76591
76673: POP
76674: POP
// end ; end_of_file
76675: LD_VAR 0 5
76679: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
76680: LD_INT 0
76682: PPUSH
// ar_miner := 81 ;
76683: LD_ADDR_EXP 92
76687: PUSH
76688: LD_INT 81
76690: ST_TO_ADDR
// ar_crane := 88 ;
76691: LD_ADDR_EXP 91
76695: PUSH
76696: LD_INT 88
76698: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
76699: LD_ADDR_EXP 86
76703: PUSH
76704: LD_INT 89
76706: ST_TO_ADDR
// us_hack := 99 ;
76707: LD_ADDR_EXP 87
76711: PUSH
76712: LD_INT 99
76714: ST_TO_ADDR
// us_artillery := 97 ;
76715: LD_ADDR_EXP 88
76719: PUSH
76720: LD_INT 97
76722: ST_TO_ADDR
// ar_bio_bomb := 91 ;
76723: LD_ADDR_EXP 89
76727: PUSH
76728: LD_INT 91
76730: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
76731: LD_ADDR_EXP 90
76735: PUSH
76736: LD_INT 92
76738: ST_TO_ADDR
// ru_radar := 98 ;
76739: LD_ADDR_EXP 85
76743: PUSH
76744: LD_INT 98
76746: ST_TO_ADDR
// tech_Artillery := 80 ;
76747: LD_ADDR_EXP 93
76751: PUSH
76752: LD_INT 80
76754: ST_TO_ADDR
// tech_RadMat := 81 ;
76755: LD_ADDR_EXP 94
76759: PUSH
76760: LD_INT 81
76762: ST_TO_ADDR
// tech_BasicTools := 82 ;
76763: LD_ADDR_EXP 95
76767: PUSH
76768: LD_INT 82
76770: ST_TO_ADDR
// tech_Cargo := 83 ;
76771: LD_ADDR_EXP 96
76775: PUSH
76776: LD_INT 83
76778: ST_TO_ADDR
// tech_Track := 84 ;
76779: LD_ADDR_EXP 97
76783: PUSH
76784: LD_INT 84
76786: ST_TO_ADDR
// tech_Crane := 85 ;
76787: LD_ADDR_EXP 98
76791: PUSH
76792: LD_INT 85
76794: ST_TO_ADDR
// tech_Bulldozer := 86 ;
76795: LD_ADDR_EXP 99
76799: PUSH
76800: LD_INT 86
76802: ST_TO_ADDR
// tech_Hovercraft := 87 ;
76803: LD_ADDR_EXP 100
76807: PUSH
76808: LD_INT 87
76810: ST_TO_ADDR
// end ;
76811: LD_VAR 0 1
76815: RET
// every 1 do
76816: GO 76818
76818: DISABLE
// InitGlobalVariables ; end_of_file
76819: CALL 76680 0 0
76823: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
76824: LD_INT 0
76826: PPUSH
76827: PPUSH
76828: PPUSH
76829: PPUSH
76830: PPUSH
76831: PPUSH
76832: PPUSH
76833: PPUSH
76834: PPUSH
76835: PPUSH
76836: PPUSH
76837: PPUSH
76838: PPUSH
76839: PPUSH
76840: PPUSH
76841: PPUSH
76842: PPUSH
76843: PPUSH
76844: PPUSH
76845: PPUSH
76846: PPUSH
76847: PPUSH
76848: PPUSH
76849: PPUSH
76850: PPUSH
76851: PPUSH
76852: PPUSH
76853: PPUSH
76854: PPUSH
76855: PPUSH
76856: PPUSH
76857: PPUSH
76858: PPUSH
76859: PPUSH
// if not list then
76860: LD_VAR 0 1
76864: NOT
76865: IFFALSE 76869
// exit ;
76867: GO 81528
// base := list [ 1 ] ;
76869: LD_ADDR_VAR 0 3
76873: PUSH
76874: LD_VAR 0 1
76878: PUSH
76879: LD_INT 1
76881: ARRAY
76882: ST_TO_ADDR
// group := list [ 2 ] ;
76883: LD_ADDR_VAR 0 4
76887: PUSH
76888: LD_VAR 0 1
76892: PUSH
76893: LD_INT 2
76895: ARRAY
76896: ST_TO_ADDR
// path := list [ 3 ] ;
76897: LD_ADDR_VAR 0 5
76901: PUSH
76902: LD_VAR 0 1
76906: PUSH
76907: LD_INT 3
76909: ARRAY
76910: ST_TO_ADDR
// flags := list [ 4 ] ;
76911: LD_ADDR_VAR 0 6
76915: PUSH
76916: LD_VAR 0 1
76920: PUSH
76921: LD_INT 4
76923: ARRAY
76924: ST_TO_ADDR
// mined := [ ] ;
76925: LD_ADDR_VAR 0 27
76929: PUSH
76930: EMPTY
76931: ST_TO_ADDR
// bombed := [ ] ;
76932: LD_ADDR_VAR 0 28
76936: PUSH
76937: EMPTY
76938: ST_TO_ADDR
// healers := [ ] ;
76939: LD_ADDR_VAR 0 31
76943: PUSH
76944: EMPTY
76945: ST_TO_ADDR
// to_heal := [ ] ;
76946: LD_ADDR_VAR 0 30
76950: PUSH
76951: EMPTY
76952: ST_TO_ADDR
// repairs := [ ] ;
76953: LD_ADDR_VAR 0 33
76957: PUSH
76958: EMPTY
76959: ST_TO_ADDR
// to_repair := [ ] ;
76960: LD_ADDR_VAR 0 32
76964: PUSH
76965: EMPTY
76966: ST_TO_ADDR
// if not group or not path then
76967: LD_VAR 0 4
76971: NOT
76972: PUSH
76973: LD_VAR 0 5
76977: NOT
76978: OR
76979: IFFALSE 76983
// exit ;
76981: GO 81528
// side := GetSide ( group [ 1 ] ) ;
76983: LD_ADDR_VAR 0 35
76987: PUSH
76988: LD_VAR 0 4
76992: PUSH
76993: LD_INT 1
76995: ARRAY
76996: PPUSH
76997: CALL_OW 255
77001: ST_TO_ADDR
// if flags then
77002: LD_VAR 0 6
77006: IFFALSE 77150
// begin f_ignore_area := flags [ 1 ] ;
77008: LD_ADDR_VAR 0 17
77012: PUSH
77013: LD_VAR 0 6
77017: PUSH
77018: LD_INT 1
77020: ARRAY
77021: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77022: LD_ADDR_VAR 0 18
77026: PUSH
77027: LD_VAR 0 6
77031: PUSH
77032: LD_INT 2
77034: ARRAY
77035: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77036: LD_ADDR_VAR 0 19
77040: PUSH
77041: LD_VAR 0 6
77045: PUSH
77046: LD_INT 3
77048: ARRAY
77049: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77050: LD_ADDR_VAR 0 20
77054: PUSH
77055: LD_VAR 0 6
77059: PUSH
77060: LD_INT 4
77062: ARRAY
77063: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
77064: LD_ADDR_VAR 0 21
77068: PUSH
77069: LD_VAR 0 6
77073: PUSH
77074: LD_INT 5
77076: ARRAY
77077: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
77078: LD_ADDR_VAR 0 22
77082: PUSH
77083: LD_VAR 0 6
77087: PUSH
77088: LD_INT 6
77090: ARRAY
77091: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
77092: LD_ADDR_VAR 0 23
77096: PUSH
77097: LD_VAR 0 6
77101: PUSH
77102: LD_INT 7
77104: ARRAY
77105: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
77106: LD_ADDR_VAR 0 24
77110: PUSH
77111: LD_VAR 0 6
77115: PUSH
77116: LD_INT 8
77118: ARRAY
77119: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
77120: LD_ADDR_VAR 0 25
77124: PUSH
77125: LD_VAR 0 6
77129: PUSH
77130: LD_INT 9
77132: ARRAY
77133: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
77134: LD_ADDR_VAR 0 26
77138: PUSH
77139: LD_VAR 0 6
77143: PUSH
77144: LD_INT 10
77146: ARRAY
77147: ST_TO_ADDR
// end else
77148: GO 77230
// begin f_ignore_area := false ;
77150: LD_ADDR_VAR 0 17
77154: PUSH
77155: LD_INT 0
77157: ST_TO_ADDR
// f_capture := false ;
77158: LD_ADDR_VAR 0 18
77162: PUSH
77163: LD_INT 0
77165: ST_TO_ADDR
// f_ignore_civ := false ;
77166: LD_ADDR_VAR 0 19
77170: PUSH
77171: LD_INT 0
77173: ST_TO_ADDR
// f_murder := false ;
77174: LD_ADDR_VAR 0 20
77178: PUSH
77179: LD_INT 0
77181: ST_TO_ADDR
// f_mines := false ;
77182: LD_ADDR_VAR 0 21
77186: PUSH
77187: LD_INT 0
77189: ST_TO_ADDR
// f_repair := false ;
77190: LD_ADDR_VAR 0 22
77194: PUSH
77195: LD_INT 0
77197: ST_TO_ADDR
// f_heal := false ;
77198: LD_ADDR_VAR 0 23
77202: PUSH
77203: LD_INT 0
77205: ST_TO_ADDR
// f_spacetime := false ;
77206: LD_ADDR_VAR 0 24
77210: PUSH
77211: LD_INT 0
77213: ST_TO_ADDR
// f_attack_depot := false ;
77214: LD_ADDR_VAR 0 25
77218: PUSH
77219: LD_INT 0
77221: ST_TO_ADDR
// f_crawl := false ;
77222: LD_ADDR_VAR 0 26
77226: PUSH
77227: LD_INT 0
77229: ST_TO_ADDR
// end ; if f_heal then
77230: LD_VAR 0 23
77234: IFFALSE 77261
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
77236: LD_ADDR_VAR 0 31
77240: PUSH
77241: LD_VAR 0 4
77245: PPUSH
77246: LD_INT 25
77248: PUSH
77249: LD_INT 4
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PPUSH
77256: CALL_OW 72
77260: ST_TO_ADDR
// if f_repair then
77261: LD_VAR 0 22
77265: IFFALSE 77292
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
77267: LD_ADDR_VAR 0 33
77271: PUSH
77272: LD_VAR 0 4
77276: PPUSH
77277: LD_INT 25
77279: PUSH
77280: LD_INT 3
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: PPUSH
77287: CALL_OW 72
77291: ST_TO_ADDR
// units_path := [ ] ;
77292: LD_ADDR_VAR 0 16
77296: PUSH
77297: EMPTY
77298: ST_TO_ADDR
// for i = 1 to group do
77299: LD_ADDR_VAR 0 7
77303: PUSH
77304: DOUBLE
77305: LD_INT 1
77307: DEC
77308: ST_TO_ADDR
77309: LD_VAR 0 4
77313: PUSH
77314: FOR_TO
77315: IFFALSE 77344
// units_path := Replace ( units_path , i , path ) ;
77317: LD_ADDR_VAR 0 16
77321: PUSH
77322: LD_VAR 0 16
77326: PPUSH
77327: LD_VAR 0 7
77331: PPUSH
77332: LD_VAR 0 5
77336: PPUSH
77337: CALL_OW 1
77341: ST_TO_ADDR
77342: GO 77314
77344: POP
77345: POP
// repeat for i = group downto 1 do
77346: LD_ADDR_VAR 0 7
77350: PUSH
77351: DOUBLE
77352: LD_VAR 0 4
77356: INC
77357: ST_TO_ADDR
77358: LD_INT 1
77360: PUSH
77361: FOR_DOWNTO
77362: IFFALSE 81484
// begin wait ( 5 ) ;
77364: LD_INT 5
77366: PPUSH
77367: CALL_OW 67
// tmp := [ ] ;
77371: LD_ADDR_VAR 0 14
77375: PUSH
77376: EMPTY
77377: ST_TO_ADDR
// attacking := false ;
77378: LD_ADDR_VAR 0 29
77382: PUSH
77383: LD_INT 0
77385: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
77386: LD_VAR 0 4
77390: PUSH
77391: LD_VAR 0 7
77395: ARRAY
77396: PPUSH
77397: CALL_OW 301
77401: PUSH
77402: LD_VAR 0 4
77406: PUSH
77407: LD_VAR 0 7
77411: ARRAY
77412: NOT
77413: OR
77414: IFFALSE 77523
// begin if GetType ( group [ i ] ) = unit_human then
77416: LD_VAR 0 4
77420: PUSH
77421: LD_VAR 0 7
77425: ARRAY
77426: PPUSH
77427: CALL_OW 247
77431: PUSH
77432: LD_INT 1
77434: EQUAL
77435: IFFALSE 77481
// begin to_heal := to_heal diff group [ i ] ;
77437: LD_ADDR_VAR 0 30
77441: PUSH
77442: LD_VAR 0 30
77446: PUSH
77447: LD_VAR 0 4
77451: PUSH
77452: LD_VAR 0 7
77456: ARRAY
77457: DIFF
77458: ST_TO_ADDR
// healers := healers diff group [ i ] ;
77459: LD_ADDR_VAR 0 31
77463: PUSH
77464: LD_VAR 0 31
77468: PUSH
77469: LD_VAR 0 4
77473: PUSH
77474: LD_VAR 0 7
77478: ARRAY
77479: DIFF
77480: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
77481: LD_ADDR_VAR 0 4
77485: PUSH
77486: LD_VAR 0 4
77490: PPUSH
77491: LD_VAR 0 7
77495: PPUSH
77496: CALL_OW 3
77500: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
77501: LD_ADDR_VAR 0 16
77505: PUSH
77506: LD_VAR 0 16
77510: PPUSH
77511: LD_VAR 0 7
77515: PPUSH
77516: CALL_OW 3
77520: ST_TO_ADDR
// continue ;
77521: GO 77361
// end ; if f_repair then
77523: LD_VAR 0 22
77527: IFFALSE 78016
// begin if GetType ( group [ i ] ) = unit_vehicle then
77529: LD_VAR 0 4
77533: PUSH
77534: LD_VAR 0 7
77538: ARRAY
77539: PPUSH
77540: CALL_OW 247
77544: PUSH
77545: LD_INT 2
77547: EQUAL
77548: IFFALSE 77738
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
77550: LD_VAR 0 4
77554: PUSH
77555: LD_VAR 0 7
77559: ARRAY
77560: PPUSH
77561: CALL_OW 256
77565: PUSH
77566: LD_INT 700
77568: LESS
77569: PUSH
77570: LD_VAR 0 4
77574: PUSH
77575: LD_VAR 0 7
77579: ARRAY
77580: PUSH
77581: LD_VAR 0 32
77585: IN
77586: NOT
77587: AND
77588: IFFALSE 77612
// to_repair := to_repair union group [ i ] ;
77590: LD_ADDR_VAR 0 32
77594: PUSH
77595: LD_VAR 0 32
77599: PUSH
77600: LD_VAR 0 4
77604: PUSH
77605: LD_VAR 0 7
77609: ARRAY
77610: UNION
77611: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
77612: LD_VAR 0 4
77616: PUSH
77617: LD_VAR 0 7
77621: ARRAY
77622: PPUSH
77623: CALL_OW 256
77627: PUSH
77628: LD_INT 1000
77630: EQUAL
77631: PUSH
77632: LD_VAR 0 4
77636: PUSH
77637: LD_VAR 0 7
77641: ARRAY
77642: PUSH
77643: LD_VAR 0 32
77647: IN
77648: AND
77649: IFFALSE 77673
// to_repair := to_repair diff group [ i ] ;
77651: LD_ADDR_VAR 0 32
77655: PUSH
77656: LD_VAR 0 32
77660: PUSH
77661: LD_VAR 0 4
77665: PUSH
77666: LD_VAR 0 7
77670: ARRAY
77671: DIFF
77672: ST_TO_ADDR
// if group [ i ] in to_repair then
77673: LD_VAR 0 4
77677: PUSH
77678: LD_VAR 0 7
77682: ARRAY
77683: PUSH
77684: LD_VAR 0 32
77688: IN
77689: IFFALSE 77736
// begin if not IsInArea ( group [ i ] , f_repair ) then
77691: LD_VAR 0 4
77695: PUSH
77696: LD_VAR 0 7
77700: ARRAY
77701: PPUSH
77702: LD_VAR 0 22
77706: PPUSH
77707: CALL_OW 308
77711: NOT
77712: IFFALSE 77734
// ComMoveToArea ( group [ i ] , f_repair ) ;
77714: LD_VAR 0 4
77718: PUSH
77719: LD_VAR 0 7
77723: ARRAY
77724: PPUSH
77725: LD_VAR 0 22
77729: PPUSH
77730: CALL_OW 113
// continue ;
77734: GO 77361
// end ; end else
77736: GO 78016
// if group [ i ] in repairs then
77738: LD_VAR 0 4
77742: PUSH
77743: LD_VAR 0 7
77747: ARRAY
77748: PUSH
77749: LD_VAR 0 33
77753: IN
77754: IFFALSE 78016
// begin if IsInUnit ( group [ i ] ) then
77756: LD_VAR 0 4
77760: PUSH
77761: LD_VAR 0 7
77765: ARRAY
77766: PPUSH
77767: CALL_OW 310
77771: IFFALSE 77839
// begin z := IsInUnit ( group [ i ] ) ;
77773: LD_ADDR_VAR 0 13
77777: PUSH
77778: LD_VAR 0 4
77782: PUSH
77783: LD_VAR 0 7
77787: ARRAY
77788: PPUSH
77789: CALL_OW 310
77793: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
77794: LD_VAR 0 13
77798: PUSH
77799: LD_VAR 0 32
77803: IN
77804: PUSH
77805: LD_VAR 0 13
77809: PPUSH
77810: LD_VAR 0 22
77814: PPUSH
77815: CALL_OW 308
77819: AND
77820: IFFALSE 77837
// ComExitVehicle ( group [ i ] ) ;
77822: LD_VAR 0 4
77826: PUSH
77827: LD_VAR 0 7
77831: ARRAY
77832: PPUSH
77833: CALL_OW 121
// end else
77837: GO 78016
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
77839: LD_ADDR_VAR 0 13
77843: PUSH
77844: LD_VAR 0 4
77848: PPUSH
77849: LD_INT 95
77851: PUSH
77852: LD_VAR 0 22
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: LD_INT 58
77863: PUSH
77864: EMPTY
77865: LIST
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PPUSH
77871: CALL_OW 72
77875: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
77876: LD_VAR 0 4
77880: PUSH
77881: LD_VAR 0 7
77885: ARRAY
77886: PPUSH
77887: CALL_OW 314
77891: NOT
77892: IFFALSE 78014
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
77894: LD_ADDR_VAR 0 10
77898: PUSH
77899: LD_VAR 0 13
77903: PPUSH
77904: LD_VAR 0 4
77908: PUSH
77909: LD_VAR 0 7
77913: ARRAY
77914: PPUSH
77915: CALL_OW 74
77919: ST_TO_ADDR
// if not x then
77920: LD_VAR 0 10
77924: NOT
77925: IFFALSE 77929
// continue ;
77927: GO 77361
// if GetLives ( x ) < 1000 then
77929: LD_VAR 0 10
77933: PPUSH
77934: CALL_OW 256
77938: PUSH
77939: LD_INT 1000
77941: LESS
77942: IFFALSE 77966
// ComRepairVehicle ( group [ i ] , x ) else
77944: LD_VAR 0 4
77948: PUSH
77949: LD_VAR 0 7
77953: ARRAY
77954: PPUSH
77955: LD_VAR 0 10
77959: PPUSH
77960: CALL_OW 129
77964: GO 78014
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
77966: LD_VAR 0 23
77970: PUSH
77971: LD_VAR 0 4
77975: PUSH
77976: LD_VAR 0 7
77980: ARRAY
77981: PPUSH
77982: CALL_OW 256
77986: PUSH
77987: LD_INT 1000
77989: LESS
77990: AND
77991: NOT
77992: IFFALSE 78014
// ComEnterUnit ( group [ i ] , x ) ;
77994: LD_VAR 0 4
77998: PUSH
77999: LD_VAR 0 7
78003: ARRAY
78004: PPUSH
78005: LD_VAR 0 10
78009: PPUSH
78010: CALL_OW 120
// end ; continue ;
78014: GO 77361
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78016: LD_VAR 0 23
78020: PUSH
78021: LD_VAR 0 4
78025: PUSH
78026: LD_VAR 0 7
78030: ARRAY
78031: PPUSH
78032: CALL_OW 247
78036: PUSH
78037: LD_INT 1
78039: EQUAL
78040: AND
78041: IFFALSE 78519
// begin if group [ i ] in healers then
78043: LD_VAR 0 4
78047: PUSH
78048: LD_VAR 0 7
78052: ARRAY
78053: PUSH
78054: LD_VAR 0 31
78058: IN
78059: IFFALSE 78332
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78061: LD_VAR 0 4
78065: PUSH
78066: LD_VAR 0 7
78070: ARRAY
78071: PPUSH
78072: LD_VAR 0 23
78076: PPUSH
78077: CALL_OW 308
78081: NOT
78082: PUSH
78083: LD_VAR 0 4
78087: PUSH
78088: LD_VAR 0 7
78092: ARRAY
78093: PPUSH
78094: CALL_OW 314
78098: NOT
78099: AND
78100: IFFALSE 78124
// ComMoveToArea ( group [ i ] , f_heal ) else
78102: LD_VAR 0 4
78106: PUSH
78107: LD_VAR 0 7
78111: ARRAY
78112: PPUSH
78113: LD_VAR 0 23
78117: PPUSH
78118: CALL_OW 113
78122: GO 78330
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
78124: LD_VAR 0 4
78128: PUSH
78129: LD_VAR 0 7
78133: ARRAY
78134: PPUSH
78135: CALL 42704 0 1
78139: PPUSH
78140: CALL_OW 256
78144: PUSH
78145: LD_INT 1000
78147: EQUAL
78148: IFFALSE 78167
// ComStop ( group [ i ] ) else
78150: LD_VAR 0 4
78154: PUSH
78155: LD_VAR 0 7
78159: ARRAY
78160: PPUSH
78161: CALL_OW 141
78165: GO 78330
// if not HasTask ( group [ i ] ) and to_heal then
78167: LD_VAR 0 4
78171: PUSH
78172: LD_VAR 0 7
78176: ARRAY
78177: PPUSH
78178: CALL_OW 314
78182: NOT
78183: PUSH
78184: LD_VAR 0 30
78188: AND
78189: IFFALSE 78330
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
78191: LD_ADDR_VAR 0 13
78195: PUSH
78196: LD_VAR 0 30
78200: PPUSH
78201: LD_INT 3
78203: PUSH
78204: LD_INT 54
78206: PUSH
78207: EMPTY
78208: LIST
78209: PUSH
78210: EMPTY
78211: LIST
78212: LIST
78213: PPUSH
78214: CALL_OW 72
78218: PPUSH
78219: LD_VAR 0 4
78223: PUSH
78224: LD_VAR 0 7
78228: ARRAY
78229: PPUSH
78230: CALL_OW 74
78234: ST_TO_ADDR
// if z then
78235: LD_VAR 0 13
78239: IFFALSE 78330
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
78241: LD_INT 91
78243: PUSH
78244: LD_VAR 0 13
78248: PUSH
78249: LD_INT 10
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: LIST
78256: PUSH
78257: LD_INT 81
78259: PUSH
78260: LD_VAR 0 13
78264: PPUSH
78265: CALL_OW 255
78269: PUSH
78270: EMPTY
78271: LIST
78272: LIST
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PPUSH
78278: CALL_OW 69
78282: PUSH
78283: LD_INT 0
78285: EQUAL
78286: IFFALSE 78310
// ComHeal ( group [ i ] , z ) else
78288: LD_VAR 0 4
78292: PUSH
78293: LD_VAR 0 7
78297: ARRAY
78298: PPUSH
78299: LD_VAR 0 13
78303: PPUSH
78304: CALL_OW 128
78308: GO 78330
// ComMoveToArea ( group [ i ] , f_heal ) ;
78310: LD_VAR 0 4
78314: PUSH
78315: LD_VAR 0 7
78319: ARRAY
78320: PPUSH
78321: LD_VAR 0 23
78325: PPUSH
78326: CALL_OW 113
// end ; continue ;
78330: GO 77361
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
78332: LD_VAR 0 4
78336: PUSH
78337: LD_VAR 0 7
78341: ARRAY
78342: PPUSH
78343: CALL_OW 256
78347: PUSH
78348: LD_INT 700
78350: LESS
78351: PUSH
78352: LD_VAR 0 4
78356: PUSH
78357: LD_VAR 0 7
78361: ARRAY
78362: PUSH
78363: LD_VAR 0 30
78367: IN
78368: NOT
78369: AND
78370: IFFALSE 78394
// to_heal := to_heal union group [ i ] ;
78372: LD_ADDR_VAR 0 30
78376: PUSH
78377: LD_VAR 0 30
78381: PUSH
78382: LD_VAR 0 4
78386: PUSH
78387: LD_VAR 0 7
78391: ARRAY
78392: UNION
78393: ST_TO_ADDR
// if group [ i ] in to_heal then
78394: LD_VAR 0 4
78398: PUSH
78399: LD_VAR 0 7
78403: ARRAY
78404: PUSH
78405: LD_VAR 0 30
78409: IN
78410: IFFALSE 78519
// begin if GetLives ( group [ i ] ) = 1000 then
78412: LD_VAR 0 4
78416: PUSH
78417: LD_VAR 0 7
78421: ARRAY
78422: PPUSH
78423: CALL_OW 256
78427: PUSH
78428: LD_INT 1000
78430: EQUAL
78431: IFFALSE 78457
// to_heal := to_heal diff group [ i ] else
78433: LD_ADDR_VAR 0 30
78437: PUSH
78438: LD_VAR 0 30
78442: PUSH
78443: LD_VAR 0 4
78447: PUSH
78448: LD_VAR 0 7
78452: ARRAY
78453: DIFF
78454: ST_TO_ADDR
78455: GO 78519
// begin if not IsInArea ( group [ i ] , to_heal ) then
78457: LD_VAR 0 4
78461: PUSH
78462: LD_VAR 0 7
78466: ARRAY
78467: PPUSH
78468: LD_VAR 0 30
78472: PPUSH
78473: CALL_OW 308
78477: NOT
78478: IFFALSE 78502
// ComMoveToArea ( group [ i ] , f_heal ) else
78480: LD_VAR 0 4
78484: PUSH
78485: LD_VAR 0 7
78489: ARRAY
78490: PPUSH
78491: LD_VAR 0 23
78495: PPUSH
78496: CALL_OW 113
78500: GO 78517
// ComHold ( group [ i ] ) ;
78502: LD_VAR 0 4
78506: PUSH
78507: LD_VAR 0 7
78511: ARRAY
78512: PPUSH
78513: CALL_OW 140
// continue ;
78517: GO 77361
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
78519: LD_VAR 0 4
78523: PUSH
78524: LD_VAR 0 7
78528: ARRAY
78529: PPUSH
78530: LD_INT 10
78532: PPUSH
78533: CALL 41124 0 2
78537: NOT
78538: PUSH
78539: LD_VAR 0 16
78543: PUSH
78544: LD_VAR 0 7
78548: ARRAY
78549: PUSH
78550: EMPTY
78551: EQUAL
78552: NOT
78553: AND
78554: IFFALSE 78820
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
78556: LD_VAR 0 4
78560: PUSH
78561: LD_VAR 0 7
78565: ARRAY
78566: PPUSH
78567: CALL_OW 262
78571: PUSH
78572: LD_INT 1
78574: PUSH
78575: LD_INT 2
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: IN
78582: IFFALSE 78623
// if GetFuel ( group [ i ] ) < 10 then
78584: LD_VAR 0 4
78588: PUSH
78589: LD_VAR 0 7
78593: ARRAY
78594: PPUSH
78595: CALL_OW 261
78599: PUSH
78600: LD_INT 10
78602: LESS
78603: IFFALSE 78623
// SetFuel ( group [ i ] , 12 ) ;
78605: LD_VAR 0 4
78609: PUSH
78610: LD_VAR 0 7
78614: ARRAY
78615: PPUSH
78616: LD_INT 12
78618: PPUSH
78619: CALL_OW 240
// if units_path [ i ] then
78623: LD_VAR 0 16
78627: PUSH
78628: LD_VAR 0 7
78632: ARRAY
78633: IFFALSE 78818
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
78635: LD_VAR 0 4
78639: PUSH
78640: LD_VAR 0 7
78644: ARRAY
78645: PPUSH
78646: LD_VAR 0 16
78650: PUSH
78651: LD_VAR 0 7
78655: ARRAY
78656: PUSH
78657: LD_INT 1
78659: ARRAY
78660: PUSH
78661: LD_INT 1
78663: ARRAY
78664: PPUSH
78665: LD_VAR 0 16
78669: PUSH
78670: LD_VAR 0 7
78674: ARRAY
78675: PUSH
78676: LD_INT 1
78678: ARRAY
78679: PUSH
78680: LD_INT 2
78682: ARRAY
78683: PPUSH
78684: CALL_OW 297
78688: PUSH
78689: LD_INT 6
78691: GREATER
78692: IFFALSE 78767
// begin if not HasTask ( group [ i ] ) then
78694: LD_VAR 0 4
78698: PUSH
78699: LD_VAR 0 7
78703: ARRAY
78704: PPUSH
78705: CALL_OW 314
78709: NOT
78710: IFFALSE 78765
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
78712: LD_VAR 0 4
78716: PUSH
78717: LD_VAR 0 7
78721: ARRAY
78722: PPUSH
78723: LD_VAR 0 16
78727: PUSH
78728: LD_VAR 0 7
78732: ARRAY
78733: PUSH
78734: LD_INT 1
78736: ARRAY
78737: PUSH
78738: LD_INT 1
78740: ARRAY
78741: PPUSH
78742: LD_VAR 0 16
78746: PUSH
78747: LD_VAR 0 7
78751: ARRAY
78752: PUSH
78753: LD_INT 1
78755: ARRAY
78756: PUSH
78757: LD_INT 2
78759: ARRAY
78760: PPUSH
78761: CALL_OW 114
// end else
78765: GO 78818
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
78767: LD_ADDR_VAR 0 15
78771: PUSH
78772: LD_VAR 0 16
78776: PUSH
78777: LD_VAR 0 7
78781: ARRAY
78782: PPUSH
78783: LD_INT 1
78785: PPUSH
78786: CALL_OW 3
78790: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
78791: LD_ADDR_VAR 0 16
78795: PUSH
78796: LD_VAR 0 16
78800: PPUSH
78801: LD_VAR 0 7
78805: PPUSH
78806: LD_VAR 0 15
78810: PPUSH
78811: CALL_OW 1
78815: ST_TO_ADDR
// continue ;
78816: GO 77361
// end ; end ; end else
78818: GO 81482
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
78820: LD_ADDR_VAR 0 14
78824: PUSH
78825: LD_INT 81
78827: PUSH
78828: LD_VAR 0 4
78832: PUSH
78833: LD_VAR 0 7
78837: ARRAY
78838: PPUSH
78839: CALL_OW 255
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PPUSH
78848: CALL_OW 69
78852: ST_TO_ADDR
// if not tmp then
78853: LD_VAR 0 14
78857: NOT
78858: IFFALSE 78862
// continue ;
78860: GO 77361
// if f_ignore_area then
78862: LD_VAR 0 17
78866: IFFALSE 78954
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
78868: LD_ADDR_VAR 0 15
78872: PUSH
78873: LD_VAR 0 14
78877: PPUSH
78878: LD_INT 3
78880: PUSH
78881: LD_INT 92
78883: PUSH
78884: LD_VAR 0 17
78888: PUSH
78889: LD_INT 1
78891: ARRAY
78892: PUSH
78893: LD_VAR 0 17
78897: PUSH
78898: LD_INT 2
78900: ARRAY
78901: PUSH
78902: LD_VAR 0 17
78906: PUSH
78907: LD_INT 3
78909: ARRAY
78910: PUSH
78911: EMPTY
78912: LIST
78913: LIST
78914: LIST
78915: LIST
78916: PUSH
78917: EMPTY
78918: LIST
78919: LIST
78920: PPUSH
78921: CALL_OW 72
78925: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
78926: LD_VAR 0 14
78930: PUSH
78931: LD_VAR 0 15
78935: DIFF
78936: IFFALSE 78954
// tmp := tmp diff tmp2 ;
78938: LD_ADDR_VAR 0 14
78942: PUSH
78943: LD_VAR 0 14
78947: PUSH
78948: LD_VAR 0 15
78952: DIFF
78953: ST_TO_ADDR
// end ; if not f_murder then
78954: LD_VAR 0 20
78958: NOT
78959: IFFALSE 79017
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
78961: LD_ADDR_VAR 0 15
78965: PUSH
78966: LD_VAR 0 14
78970: PPUSH
78971: LD_INT 3
78973: PUSH
78974: LD_INT 50
78976: PUSH
78977: EMPTY
78978: LIST
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: PPUSH
78984: CALL_OW 72
78988: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
78989: LD_VAR 0 14
78993: PUSH
78994: LD_VAR 0 15
78998: DIFF
78999: IFFALSE 79017
// tmp := tmp diff tmp2 ;
79001: LD_ADDR_VAR 0 14
79005: PUSH
79006: LD_VAR 0 14
79010: PUSH
79011: LD_VAR 0 15
79015: DIFF
79016: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79017: LD_ADDR_VAR 0 14
79021: PUSH
79022: LD_VAR 0 4
79026: PUSH
79027: LD_VAR 0 7
79031: ARRAY
79032: PPUSH
79033: LD_VAR 0 14
79037: PPUSH
79038: LD_INT 1
79040: PPUSH
79041: LD_INT 1
79043: PPUSH
79044: CALL 14767 0 4
79048: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79049: LD_VAR 0 4
79053: PUSH
79054: LD_VAR 0 7
79058: ARRAY
79059: PPUSH
79060: CALL_OW 257
79064: PUSH
79065: LD_INT 1
79067: EQUAL
79068: IFFALSE 79516
// begin if WantPlant ( group [ i ] ) then
79070: LD_VAR 0 4
79074: PUSH
79075: LD_VAR 0 7
79079: ARRAY
79080: PPUSH
79081: CALL 14268 0 1
79085: IFFALSE 79089
// continue ;
79087: GO 77361
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
79089: LD_VAR 0 18
79093: PUSH
79094: LD_VAR 0 4
79098: PUSH
79099: LD_VAR 0 7
79103: ARRAY
79104: PPUSH
79105: CALL_OW 310
79109: NOT
79110: AND
79111: PUSH
79112: LD_VAR 0 14
79116: PUSH
79117: LD_INT 1
79119: ARRAY
79120: PUSH
79121: LD_VAR 0 14
79125: PPUSH
79126: LD_INT 21
79128: PUSH
79129: LD_INT 2
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: PUSH
79136: LD_INT 58
79138: PUSH
79139: EMPTY
79140: LIST
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PPUSH
79146: CALL_OW 72
79150: IN
79151: AND
79152: IFFALSE 79188
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
79154: LD_VAR 0 4
79158: PUSH
79159: LD_VAR 0 7
79163: ARRAY
79164: PPUSH
79165: LD_VAR 0 14
79169: PUSH
79170: LD_INT 1
79172: ARRAY
79173: PPUSH
79174: CALL_OW 120
// attacking := true ;
79178: LD_ADDR_VAR 0 29
79182: PUSH
79183: LD_INT 1
79185: ST_TO_ADDR
// continue ;
79186: GO 77361
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
79188: LD_VAR 0 26
79192: PUSH
79193: LD_VAR 0 4
79197: PUSH
79198: LD_VAR 0 7
79202: ARRAY
79203: PPUSH
79204: CALL_OW 257
79208: PUSH
79209: LD_INT 1
79211: EQUAL
79212: AND
79213: PUSH
79214: LD_VAR 0 4
79218: PUSH
79219: LD_VAR 0 7
79223: ARRAY
79224: PPUSH
79225: CALL_OW 256
79229: PUSH
79230: LD_INT 800
79232: LESS
79233: AND
79234: PUSH
79235: LD_VAR 0 4
79239: PUSH
79240: LD_VAR 0 7
79244: ARRAY
79245: PPUSH
79246: CALL_OW 318
79250: NOT
79251: AND
79252: IFFALSE 79269
// ComCrawl ( group [ i ] ) ;
79254: LD_VAR 0 4
79258: PUSH
79259: LD_VAR 0 7
79263: ARRAY
79264: PPUSH
79265: CALL_OW 137
// if f_mines then
79269: LD_VAR 0 21
79273: IFFALSE 79516
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
79275: LD_VAR 0 14
79279: PUSH
79280: LD_INT 1
79282: ARRAY
79283: PPUSH
79284: CALL_OW 247
79288: PUSH
79289: LD_INT 3
79291: EQUAL
79292: PUSH
79293: LD_VAR 0 14
79297: PUSH
79298: LD_INT 1
79300: ARRAY
79301: PUSH
79302: LD_VAR 0 27
79306: IN
79307: NOT
79308: AND
79309: IFFALSE 79516
// begin x := GetX ( tmp [ 1 ] ) ;
79311: LD_ADDR_VAR 0 10
79315: PUSH
79316: LD_VAR 0 14
79320: PUSH
79321: LD_INT 1
79323: ARRAY
79324: PPUSH
79325: CALL_OW 250
79329: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
79330: LD_ADDR_VAR 0 11
79334: PUSH
79335: LD_VAR 0 14
79339: PUSH
79340: LD_INT 1
79342: ARRAY
79343: PPUSH
79344: CALL_OW 251
79348: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
79349: LD_ADDR_VAR 0 12
79353: PUSH
79354: LD_VAR 0 4
79358: PUSH
79359: LD_VAR 0 7
79363: ARRAY
79364: PPUSH
79365: CALL 41209 0 1
79369: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
79370: LD_VAR 0 4
79374: PUSH
79375: LD_VAR 0 7
79379: ARRAY
79380: PPUSH
79381: LD_VAR 0 10
79385: PPUSH
79386: LD_VAR 0 11
79390: PPUSH
79391: LD_VAR 0 14
79395: PUSH
79396: LD_INT 1
79398: ARRAY
79399: PPUSH
79400: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
79404: LD_VAR 0 4
79408: PUSH
79409: LD_VAR 0 7
79413: ARRAY
79414: PPUSH
79415: LD_VAR 0 10
79419: PPUSH
79420: LD_VAR 0 12
79424: PPUSH
79425: LD_INT 7
79427: PPUSH
79428: CALL_OW 272
79432: PPUSH
79433: LD_VAR 0 11
79437: PPUSH
79438: LD_VAR 0 12
79442: PPUSH
79443: LD_INT 7
79445: PPUSH
79446: CALL_OW 273
79450: PPUSH
79451: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
79455: LD_VAR 0 4
79459: PUSH
79460: LD_VAR 0 7
79464: ARRAY
79465: PPUSH
79466: LD_INT 71
79468: PPUSH
79469: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
79473: LD_ADDR_VAR 0 27
79477: PUSH
79478: LD_VAR 0 27
79482: PPUSH
79483: LD_VAR 0 27
79487: PUSH
79488: LD_INT 1
79490: PLUS
79491: PPUSH
79492: LD_VAR 0 14
79496: PUSH
79497: LD_INT 1
79499: ARRAY
79500: PPUSH
79501: CALL_OW 1
79505: ST_TO_ADDR
// attacking := true ;
79506: LD_ADDR_VAR 0 29
79510: PUSH
79511: LD_INT 1
79513: ST_TO_ADDR
// continue ;
79514: GO 77361
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
79516: LD_VAR 0 4
79520: PUSH
79521: LD_VAR 0 7
79525: ARRAY
79526: PPUSH
79527: CALL_OW 257
79531: PUSH
79532: LD_INT 17
79534: EQUAL
79535: PUSH
79536: LD_VAR 0 4
79540: PUSH
79541: LD_VAR 0 7
79545: ARRAY
79546: PPUSH
79547: CALL_OW 110
79551: PUSH
79552: LD_INT 71
79554: EQUAL
79555: NOT
79556: AND
79557: IFFALSE 79703
// begin attacking := false ;
79559: LD_ADDR_VAR 0 29
79563: PUSH
79564: LD_INT 0
79566: ST_TO_ADDR
// k := 5 ;
79567: LD_ADDR_VAR 0 9
79571: PUSH
79572: LD_INT 5
79574: ST_TO_ADDR
// if tmp < k then
79575: LD_VAR 0 14
79579: PUSH
79580: LD_VAR 0 9
79584: LESS
79585: IFFALSE 79597
// k := tmp ;
79587: LD_ADDR_VAR 0 9
79591: PUSH
79592: LD_VAR 0 14
79596: ST_TO_ADDR
// for j = 1 to k do
79597: LD_ADDR_VAR 0 8
79601: PUSH
79602: DOUBLE
79603: LD_INT 1
79605: DEC
79606: ST_TO_ADDR
79607: LD_VAR 0 9
79611: PUSH
79612: FOR_TO
79613: IFFALSE 79701
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
79615: LD_VAR 0 14
79619: PUSH
79620: LD_VAR 0 8
79624: ARRAY
79625: PUSH
79626: LD_VAR 0 14
79630: PPUSH
79631: LD_INT 58
79633: PUSH
79634: EMPTY
79635: LIST
79636: PPUSH
79637: CALL_OW 72
79641: IN
79642: NOT
79643: IFFALSE 79699
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
79645: LD_VAR 0 4
79649: PUSH
79650: LD_VAR 0 7
79654: ARRAY
79655: PPUSH
79656: LD_VAR 0 14
79660: PUSH
79661: LD_VAR 0 8
79665: ARRAY
79666: PPUSH
79667: CALL_OW 115
// attacking := true ;
79671: LD_ADDR_VAR 0 29
79675: PUSH
79676: LD_INT 1
79678: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
79679: LD_VAR 0 4
79683: PUSH
79684: LD_VAR 0 7
79688: ARRAY
79689: PPUSH
79690: LD_INT 71
79692: PPUSH
79693: CALL_OW 109
// continue ;
79697: GO 79612
// end ; end ;
79699: GO 79612
79701: POP
79702: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
79703: LD_VAR 0 4
79707: PUSH
79708: LD_VAR 0 7
79712: ARRAY
79713: PPUSH
79714: CALL_OW 257
79718: PUSH
79719: LD_INT 8
79721: EQUAL
79722: PUSH
79723: LD_VAR 0 4
79727: PUSH
79728: LD_VAR 0 7
79732: ARRAY
79733: PPUSH
79734: CALL_OW 264
79738: PUSH
79739: LD_INT 28
79741: PUSH
79742: LD_INT 45
79744: PUSH
79745: LD_INT 7
79747: PUSH
79748: LD_INT 47
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: LIST
79755: LIST
79756: IN
79757: OR
79758: IFFALSE 80014
// begin attacking := false ;
79760: LD_ADDR_VAR 0 29
79764: PUSH
79765: LD_INT 0
79767: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
79768: LD_VAR 0 14
79772: PUSH
79773: LD_INT 1
79775: ARRAY
79776: PPUSH
79777: CALL_OW 266
79781: PUSH
79782: LD_INT 32
79784: PUSH
79785: LD_INT 31
79787: PUSH
79788: LD_INT 33
79790: PUSH
79791: LD_INT 4
79793: PUSH
79794: LD_INT 5
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: LIST
79801: LIST
79802: LIST
79803: IN
79804: IFFALSE 79990
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
79806: LD_ADDR_VAR 0 9
79810: PUSH
79811: LD_VAR 0 14
79815: PUSH
79816: LD_INT 1
79818: ARRAY
79819: PPUSH
79820: CALL_OW 266
79824: PPUSH
79825: LD_VAR 0 14
79829: PUSH
79830: LD_INT 1
79832: ARRAY
79833: PPUSH
79834: CALL_OW 250
79838: PPUSH
79839: LD_VAR 0 14
79843: PUSH
79844: LD_INT 1
79846: ARRAY
79847: PPUSH
79848: CALL_OW 251
79852: PPUSH
79853: LD_VAR 0 14
79857: PUSH
79858: LD_INT 1
79860: ARRAY
79861: PPUSH
79862: CALL_OW 254
79866: PPUSH
79867: LD_VAR 0 14
79871: PUSH
79872: LD_INT 1
79874: ARRAY
79875: PPUSH
79876: CALL_OW 248
79880: PPUSH
79881: LD_INT 0
79883: PPUSH
79884: CALL 22579 0 6
79888: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
79889: LD_ADDR_VAR 0 8
79893: PUSH
79894: LD_VAR 0 4
79898: PUSH
79899: LD_VAR 0 7
79903: ARRAY
79904: PPUSH
79905: LD_VAR 0 9
79909: PPUSH
79910: CALL 41249 0 2
79914: ST_TO_ADDR
// if j then
79915: LD_VAR 0 8
79919: IFFALSE 79988
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
79921: LD_VAR 0 8
79925: PUSH
79926: LD_INT 1
79928: ARRAY
79929: PPUSH
79930: LD_VAR 0 8
79934: PUSH
79935: LD_INT 2
79937: ARRAY
79938: PPUSH
79939: CALL_OW 488
79943: IFFALSE 79988
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
79945: LD_VAR 0 4
79949: PUSH
79950: LD_VAR 0 7
79954: ARRAY
79955: PPUSH
79956: LD_VAR 0 8
79960: PUSH
79961: LD_INT 1
79963: ARRAY
79964: PPUSH
79965: LD_VAR 0 8
79969: PUSH
79970: LD_INT 2
79972: ARRAY
79973: PPUSH
79974: CALL_OW 116
// attacking := true ;
79978: LD_ADDR_VAR 0 29
79982: PUSH
79983: LD_INT 1
79985: ST_TO_ADDR
// continue ;
79986: GO 77361
// end ; end else
79988: GO 80014
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
79990: LD_VAR 0 4
79994: PUSH
79995: LD_VAR 0 7
79999: ARRAY
80000: PPUSH
80001: LD_VAR 0 14
80005: PUSH
80006: LD_INT 1
80008: ARRAY
80009: PPUSH
80010: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80014: LD_VAR 0 4
80018: PUSH
80019: LD_VAR 0 7
80023: ARRAY
80024: PPUSH
80025: CALL_OW 265
80029: PUSH
80030: LD_INT 11
80032: EQUAL
80033: IFFALSE 80311
// begin k := 10 ;
80035: LD_ADDR_VAR 0 9
80039: PUSH
80040: LD_INT 10
80042: ST_TO_ADDR
// x := 0 ;
80043: LD_ADDR_VAR 0 10
80047: PUSH
80048: LD_INT 0
80050: ST_TO_ADDR
// if tmp < k then
80051: LD_VAR 0 14
80055: PUSH
80056: LD_VAR 0 9
80060: LESS
80061: IFFALSE 80073
// k := tmp ;
80063: LD_ADDR_VAR 0 9
80067: PUSH
80068: LD_VAR 0 14
80072: ST_TO_ADDR
// for j = k downto 1 do
80073: LD_ADDR_VAR 0 8
80077: PUSH
80078: DOUBLE
80079: LD_VAR 0 9
80083: INC
80084: ST_TO_ADDR
80085: LD_INT 1
80087: PUSH
80088: FOR_DOWNTO
80089: IFFALSE 80164
// begin if GetType ( tmp [ j ] ) = unit_human then
80091: LD_VAR 0 14
80095: PUSH
80096: LD_VAR 0 8
80100: ARRAY
80101: PPUSH
80102: CALL_OW 247
80106: PUSH
80107: LD_INT 1
80109: EQUAL
80110: IFFALSE 80162
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
80112: LD_VAR 0 4
80116: PUSH
80117: LD_VAR 0 7
80121: ARRAY
80122: PPUSH
80123: LD_VAR 0 14
80127: PUSH
80128: LD_VAR 0 8
80132: ARRAY
80133: PPUSH
80134: CALL 41520 0 2
// x := tmp [ j ] ;
80138: LD_ADDR_VAR 0 10
80142: PUSH
80143: LD_VAR 0 14
80147: PUSH
80148: LD_VAR 0 8
80152: ARRAY
80153: ST_TO_ADDR
// attacking := true ;
80154: LD_ADDR_VAR 0 29
80158: PUSH
80159: LD_INT 1
80161: ST_TO_ADDR
// end ; end ;
80162: GO 80088
80164: POP
80165: POP
// if not x then
80166: LD_VAR 0 10
80170: NOT
80171: IFFALSE 80311
// begin attacking := true ;
80173: LD_ADDR_VAR 0 29
80177: PUSH
80178: LD_INT 1
80180: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
80181: LD_VAR 0 4
80185: PUSH
80186: LD_VAR 0 7
80190: ARRAY
80191: PPUSH
80192: CALL_OW 250
80196: PPUSH
80197: LD_VAR 0 4
80201: PUSH
80202: LD_VAR 0 7
80206: ARRAY
80207: PPUSH
80208: CALL_OW 251
80212: PPUSH
80213: CALL_OW 546
80217: PUSH
80218: LD_INT 2
80220: ARRAY
80221: PUSH
80222: LD_VAR 0 14
80226: PUSH
80227: LD_INT 1
80229: ARRAY
80230: PPUSH
80231: CALL_OW 250
80235: PPUSH
80236: LD_VAR 0 14
80240: PUSH
80241: LD_INT 1
80243: ARRAY
80244: PPUSH
80245: CALL_OW 251
80249: PPUSH
80250: CALL_OW 546
80254: PUSH
80255: LD_INT 2
80257: ARRAY
80258: EQUAL
80259: IFFALSE 80287
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
80261: LD_VAR 0 4
80265: PUSH
80266: LD_VAR 0 7
80270: ARRAY
80271: PPUSH
80272: LD_VAR 0 14
80276: PUSH
80277: LD_INT 1
80279: ARRAY
80280: PPUSH
80281: CALL 41520 0 2
80285: GO 80311
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80287: LD_VAR 0 4
80291: PUSH
80292: LD_VAR 0 7
80296: ARRAY
80297: PPUSH
80298: LD_VAR 0 14
80302: PUSH
80303: LD_INT 1
80305: ARRAY
80306: PPUSH
80307: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
80311: LD_VAR 0 4
80315: PUSH
80316: LD_VAR 0 7
80320: ARRAY
80321: PPUSH
80322: CALL_OW 264
80326: PUSH
80327: LD_INT 29
80329: EQUAL
80330: IFFALSE 80696
// begin if WantsToAttack ( group [ i ] ) in bombed then
80332: LD_VAR 0 4
80336: PUSH
80337: LD_VAR 0 7
80341: ARRAY
80342: PPUSH
80343: CALL_OW 319
80347: PUSH
80348: LD_VAR 0 28
80352: IN
80353: IFFALSE 80357
// continue ;
80355: GO 77361
// k := 8 ;
80357: LD_ADDR_VAR 0 9
80361: PUSH
80362: LD_INT 8
80364: ST_TO_ADDR
// x := 0 ;
80365: LD_ADDR_VAR 0 10
80369: PUSH
80370: LD_INT 0
80372: ST_TO_ADDR
// if tmp < k then
80373: LD_VAR 0 14
80377: PUSH
80378: LD_VAR 0 9
80382: LESS
80383: IFFALSE 80395
// k := tmp ;
80385: LD_ADDR_VAR 0 9
80389: PUSH
80390: LD_VAR 0 14
80394: ST_TO_ADDR
// for j = 1 to k do
80395: LD_ADDR_VAR 0 8
80399: PUSH
80400: DOUBLE
80401: LD_INT 1
80403: DEC
80404: ST_TO_ADDR
80405: LD_VAR 0 9
80409: PUSH
80410: FOR_TO
80411: IFFALSE 80543
// begin if GetType ( tmp [ j ] ) = unit_building then
80413: LD_VAR 0 14
80417: PUSH
80418: LD_VAR 0 8
80422: ARRAY
80423: PPUSH
80424: CALL_OW 247
80428: PUSH
80429: LD_INT 3
80431: EQUAL
80432: IFFALSE 80541
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
80434: LD_VAR 0 14
80438: PUSH
80439: LD_VAR 0 8
80443: ARRAY
80444: PUSH
80445: LD_VAR 0 28
80449: IN
80450: NOT
80451: PUSH
80452: LD_VAR 0 14
80456: PUSH
80457: LD_VAR 0 8
80461: ARRAY
80462: PPUSH
80463: CALL_OW 313
80467: AND
80468: IFFALSE 80541
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80470: LD_VAR 0 4
80474: PUSH
80475: LD_VAR 0 7
80479: ARRAY
80480: PPUSH
80481: LD_VAR 0 14
80485: PUSH
80486: LD_VAR 0 8
80490: ARRAY
80491: PPUSH
80492: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
80496: LD_ADDR_VAR 0 28
80500: PUSH
80501: LD_VAR 0 28
80505: PPUSH
80506: LD_VAR 0 28
80510: PUSH
80511: LD_INT 1
80513: PLUS
80514: PPUSH
80515: LD_VAR 0 14
80519: PUSH
80520: LD_VAR 0 8
80524: ARRAY
80525: PPUSH
80526: CALL_OW 1
80530: ST_TO_ADDR
// attacking := true ;
80531: LD_ADDR_VAR 0 29
80535: PUSH
80536: LD_INT 1
80538: ST_TO_ADDR
// break ;
80539: GO 80543
// end ; end ;
80541: GO 80410
80543: POP
80544: POP
// if not attacking and f_attack_depot then
80545: LD_VAR 0 29
80549: NOT
80550: PUSH
80551: LD_VAR 0 25
80555: AND
80556: IFFALSE 80651
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80558: LD_ADDR_VAR 0 13
80562: PUSH
80563: LD_VAR 0 14
80567: PPUSH
80568: LD_INT 2
80570: PUSH
80571: LD_INT 30
80573: PUSH
80574: LD_INT 0
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 30
80583: PUSH
80584: LD_INT 1
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: LIST
80595: PPUSH
80596: CALL_OW 72
80600: ST_TO_ADDR
// if z then
80601: LD_VAR 0 13
80605: IFFALSE 80651
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
80607: LD_VAR 0 4
80611: PUSH
80612: LD_VAR 0 7
80616: ARRAY
80617: PPUSH
80618: LD_VAR 0 13
80622: PPUSH
80623: LD_VAR 0 4
80627: PUSH
80628: LD_VAR 0 7
80632: ARRAY
80633: PPUSH
80634: CALL_OW 74
80638: PPUSH
80639: CALL_OW 115
// attacking := true ;
80643: LD_ADDR_VAR 0 29
80647: PUSH
80648: LD_INT 1
80650: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
80651: LD_VAR 0 4
80655: PUSH
80656: LD_VAR 0 7
80660: ARRAY
80661: PPUSH
80662: CALL_OW 256
80666: PUSH
80667: LD_INT 500
80669: LESS
80670: IFFALSE 80696
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80672: LD_VAR 0 4
80676: PUSH
80677: LD_VAR 0 7
80681: ARRAY
80682: PPUSH
80683: LD_VAR 0 14
80687: PUSH
80688: LD_INT 1
80690: ARRAY
80691: PPUSH
80692: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
80696: LD_VAR 0 4
80700: PUSH
80701: LD_VAR 0 7
80705: ARRAY
80706: PPUSH
80707: CALL_OW 264
80711: PUSH
80712: LD_INT 49
80714: EQUAL
80715: IFFALSE 80836
// begin if not HasTask ( group [ i ] ) then
80717: LD_VAR 0 4
80721: PUSH
80722: LD_VAR 0 7
80726: ARRAY
80727: PPUSH
80728: CALL_OW 314
80732: NOT
80733: IFFALSE 80836
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
80735: LD_ADDR_VAR 0 9
80739: PUSH
80740: LD_INT 81
80742: PUSH
80743: LD_VAR 0 4
80747: PUSH
80748: LD_VAR 0 7
80752: ARRAY
80753: PPUSH
80754: CALL_OW 255
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PPUSH
80763: CALL_OW 69
80767: PPUSH
80768: LD_VAR 0 4
80772: PUSH
80773: LD_VAR 0 7
80777: ARRAY
80778: PPUSH
80779: CALL_OW 74
80783: ST_TO_ADDR
// if k then
80784: LD_VAR 0 9
80788: IFFALSE 80836
// if GetDistUnits ( group [ i ] , k ) > 10 then
80790: LD_VAR 0 4
80794: PUSH
80795: LD_VAR 0 7
80799: ARRAY
80800: PPUSH
80801: LD_VAR 0 9
80805: PPUSH
80806: CALL_OW 296
80810: PUSH
80811: LD_INT 10
80813: GREATER
80814: IFFALSE 80836
// ComMoveUnit ( group [ i ] , k ) ;
80816: LD_VAR 0 4
80820: PUSH
80821: LD_VAR 0 7
80825: ARRAY
80826: PPUSH
80827: LD_VAR 0 9
80831: PPUSH
80832: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
80836: LD_VAR 0 4
80840: PUSH
80841: LD_VAR 0 7
80845: ARRAY
80846: PPUSH
80847: CALL_OW 256
80851: PUSH
80852: LD_INT 250
80854: LESS
80855: PUSH
80856: LD_VAR 0 4
80860: PUSH
80861: LD_VAR 0 7
80865: ARRAY
80866: PUSH
80867: LD_INT 21
80869: PUSH
80870: LD_INT 2
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 23
80879: PUSH
80880: LD_INT 2
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: EMPTY
80888: LIST
80889: LIST
80890: PPUSH
80891: CALL_OW 69
80895: IN
80896: AND
80897: IFFALSE 81022
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
80899: LD_ADDR_VAR 0 9
80903: PUSH
80904: LD_OWVAR 3
80908: PUSH
80909: LD_VAR 0 4
80913: PUSH
80914: LD_VAR 0 7
80918: ARRAY
80919: DIFF
80920: PPUSH
80921: LD_VAR 0 4
80925: PUSH
80926: LD_VAR 0 7
80930: ARRAY
80931: PPUSH
80932: CALL_OW 74
80936: ST_TO_ADDR
// if not k then
80937: LD_VAR 0 9
80941: NOT
80942: IFFALSE 80946
// continue ;
80944: GO 77361
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
80946: LD_VAR 0 9
80950: PUSH
80951: LD_INT 81
80953: PUSH
80954: LD_VAR 0 4
80958: PUSH
80959: LD_VAR 0 7
80963: ARRAY
80964: PPUSH
80965: CALL_OW 255
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PPUSH
80974: CALL_OW 69
80978: IN
80979: PUSH
80980: LD_VAR 0 9
80984: PPUSH
80985: LD_VAR 0 4
80989: PUSH
80990: LD_VAR 0 7
80994: ARRAY
80995: PPUSH
80996: CALL_OW 296
81000: PUSH
81001: LD_INT 5
81003: LESS
81004: AND
81005: IFFALSE 81022
// ComAutodestruct ( group [ i ] ) ;
81007: LD_VAR 0 4
81011: PUSH
81012: LD_VAR 0 7
81016: ARRAY
81017: PPUSH
81018: CALL 41418 0 1
// end ; if f_attack_depot then
81022: LD_VAR 0 25
81026: IFFALSE 81138
// begin k := 6 ;
81028: LD_ADDR_VAR 0 9
81032: PUSH
81033: LD_INT 6
81035: ST_TO_ADDR
// if tmp < k then
81036: LD_VAR 0 14
81040: PUSH
81041: LD_VAR 0 9
81045: LESS
81046: IFFALSE 81058
// k := tmp ;
81048: LD_ADDR_VAR 0 9
81052: PUSH
81053: LD_VAR 0 14
81057: ST_TO_ADDR
// for j = 1 to k do
81058: LD_ADDR_VAR 0 8
81062: PUSH
81063: DOUBLE
81064: LD_INT 1
81066: DEC
81067: ST_TO_ADDR
81068: LD_VAR 0 9
81072: PUSH
81073: FOR_TO
81074: IFFALSE 81136
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
81076: LD_VAR 0 8
81080: PPUSH
81081: CALL_OW 266
81085: PUSH
81086: LD_INT 0
81088: PUSH
81089: LD_INT 1
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: IN
81096: IFFALSE 81134
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81098: LD_VAR 0 4
81102: PUSH
81103: LD_VAR 0 7
81107: ARRAY
81108: PPUSH
81109: LD_VAR 0 14
81113: PUSH
81114: LD_VAR 0 8
81118: ARRAY
81119: PPUSH
81120: CALL_OW 115
// attacking := true ;
81124: LD_ADDR_VAR 0 29
81128: PUSH
81129: LD_INT 1
81131: ST_TO_ADDR
// break ;
81132: GO 81136
// end ;
81134: GO 81073
81136: POP
81137: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
81138: LD_VAR 0 4
81142: PUSH
81143: LD_VAR 0 7
81147: ARRAY
81148: PPUSH
81149: CALL_OW 302
81153: PUSH
81154: LD_VAR 0 29
81158: NOT
81159: AND
81160: IFFALSE 81482
// begin if GetTag ( group [ i ] ) = 71 then
81162: LD_VAR 0 4
81166: PUSH
81167: LD_VAR 0 7
81171: ARRAY
81172: PPUSH
81173: CALL_OW 110
81177: PUSH
81178: LD_INT 71
81180: EQUAL
81181: IFFALSE 81222
// begin if HasTask ( group [ i ] ) then
81183: LD_VAR 0 4
81187: PUSH
81188: LD_VAR 0 7
81192: ARRAY
81193: PPUSH
81194: CALL_OW 314
81198: IFFALSE 81204
// continue else
81200: GO 77361
81202: GO 81222
// SetTag ( group [ i ] , 0 ) ;
81204: LD_VAR 0 4
81208: PUSH
81209: LD_VAR 0 7
81213: ARRAY
81214: PPUSH
81215: LD_INT 0
81217: PPUSH
81218: CALL_OW 109
// end ; k := 8 ;
81222: LD_ADDR_VAR 0 9
81226: PUSH
81227: LD_INT 8
81229: ST_TO_ADDR
// x := 0 ;
81230: LD_ADDR_VAR 0 10
81234: PUSH
81235: LD_INT 0
81237: ST_TO_ADDR
// if tmp < k then
81238: LD_VAR 0 14
81242: PUSH
81243: LD_VAR 0 9
81247: LESS
81248: IFFALSE 81260
// k := tmp ;
81250: LD_ADDR_VAR 0 9
81254: PUSH
81255: LD_VAR 0 14
81259: ST_TO_ADDR
// for j = 1 to k do
81260: LD_ADDR_VAR 0 8
81264: PUSH
81265: DOUBLE
81266: LD_INT 1
81268: DEC
81269: ST_TO_ADDR
81270: LD_VAR 0 9
81274: PUSH
81275: FOR_TO
81276: IFFALSE 81374
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
81278: LD_VAR 0 14
81282: PUSH
81283: LD_VAR 0 8
81287: ARRAY
81288: PPUSH
81289: CALL_OW 247
81293: PUSH
81294: LD_INT 1
81296: EQUAL
81297: PUSH
81298: LD_VAR 0 14
81302: PUSH
81303: LD_VAR 0 8
81307: ARRAY
81308: PPUSH
81309: CALL_OW 256
81313: PUSH
81314: LD_INT 250
81316: LESS
81317: PUSH
81318: LD_VAR 0 20
81322: AND
81323: PUSH
81324: LD_VAR 0 20
81328: NOT
81329: PUSH
81330: LD_VAR 0 14
81334: PUSH
81335: LD_VAR 0 8
81339: ARRAY
81340: PPUSH
81341: CALL_OW 256
81345: PUSH
81346: LD_INT 250
81348: GREATEREQUAL
81349: AND
81350: OR
81351: AND
81352: IFFALSE 81372
// begin x := tmp [ j ] ;
81354: LD_ADDR_VAR 0 10
81358: PUSH
81359: LD_VAR 0 14
81363: PUSH
81364: LD_VAR 0 8
81368: ARRAY
81369: ST_TO_ADDR
// break ;
81370: GO 81374
// end ;
81372: GO 81275
81374: POP
81375: POP
// if x then
81376: LD_VAR 0 10
81380: IFFALSE 81404
// ComAttackUnit ( group [ i ] , x ) else
81382: LD_VAR 0 4
81386: PUSH
81387: LD_VAR 0 7
81391: ARRAY
81392: PPUSH
81393: LD_VAR 0 10
81397: PPUSH
81398: CALL_OW 115
81402: GO 81428
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81404: LD_VAR 0 4
81408: PUSH
81409: LD_VAR 0 7
81413: ARRAY
81414: PPUSH
81415: LD_VAR 0 14
81419: PUSH
81420: LD_INT 1
81422: ARRAY
81423: PPUSH
81424: CALL_OW 115
// if not HasTask ( group [ i ] ) then
81428: LD_VAR 0 4
81432: PUSH
81433: LD_VAR 0 7
81437: ARRAY
81438: PPUSH
81439: CALL_OW 314
81443: NOT
81444: IFFALSE 81482
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
81446: LD_VAR 0 4
81450: PUSH
81451: LD_VAR 0 7
81455: ARRAY
81456: PPUSH
81457: LD_VAR 0 14
81461: PPUSH
81462: LD_VAR 0 4
81466: PUSH
81467: LD_VAR 0 7
81471: ARRAY
81472: PPUSH
81473: CALL_OW 74
81477: PPUSH
81478: CALL_OW 115
// end ; end ; end ;
81482: GO 77361
81484: POP
81485: POP
// wait ( 0 0$2 ) ;
81486: LD_INT 70
81488: PPUSH
81489: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
81493: LD_VAR 0 4
81497: NOT
81498: PUSH
81499: LD_VAR 0 4
81503: PUSH
81504: EMPTY
81505: EQUAL
81506: OR
81507: PUSH
81508: LD_INT 81
81510: PUSH
81511: LD_VAR 0 35
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PPUSH
81520: CALL_OW 69
81524: NOT
81525: OR
81526: IFFALSE 77346
// end ;
81528: LD_VAR 0 2
81532: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
81533: LD_INT 0
81535: PPUSH
81536: PPUSH
81537: PPUSH
81538: PPUSH
81539: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
81540: LD_VAR 0 1
81544: NOT
81545: PUSH
81546: LD_EXP 42
81550: PUSH
81551: LD_VAR 0 1
81555: ARRAY
81556: NOT
81557: OR
81558: PUSH
81559: LD_VAR 0 2
81563: NOT
81564: OR
81565: PUSH
81566: LD_VAR 0 3
81570: NOT
81571: OR
81572: IFFALSE 81576
// exit ;
81574: GO 82089
// side := mc_sides [ base ] ;
81576: LD_ADDR_VAR 0 6
81580: PUSH
81581: LD_EXP 68
81585: PUSH
81586: LD_VAR 0 1
81590: ARRAY
81591: ST_TO_ADDR
// if not side then
81592: LD_VAR 0 6
81596: NOT
81597: IFFALSE 81601
// exit ;
81599: GO 82089
// for i in solds do
81601: LD_ADDR_VAR 0 7
81605: PUSH
81606: LD_VAR 0 2
81610: PUSH
81611: FOR_IN
81612: IFFALSE 81673
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
81614: LD_VAR 0 7
81618: PPUSH
81619: CALL_OW 310
81623: PPUSH
81624: CALL_OW 266
81628: PUSH
81629: LD_INT 32
81631: PUSH
81632: LD_INT 31
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: IN
81639: IFFALSE 81659
// solds := solds diff i else
81641: LD_ADDR_VAR 0 2
81645: PUSH
81646: LD_VAR 0 2
81650: PUSH
81651: LD_VAR 0 7
81655: DIFF
81656: ST_TO_ADDR
81657: GO 81671
// SetTag ( i , 18 ) ;
81659: LD_VAR 0 7
81663: PPUSH
81664: LD_INT 18
81666: PPUSH
81667: CALL_OW 109
81671: GO 81611
81673: POP
81674: POP
// if not solds then
81675: LD_VAR 0 2
81679: NOT
81680: IFFALSE 81684
// exit ;
81682: GO 82089
// repeat wait ( 0 0$2 ) ;
81684: LD_INT 70
81686: PPUSH
81687: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
81691: LD_ADDR_VAR 0 5
81695: PUSH
81696: LD_VAR 0 6
81700: PPUSH
81701: LD_VAR 0 3
81705: PPUSH
81706: CALL 11133 0 2
81710: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
81711: LD_EXP 42
81715: PUSH
81716: LD_VAR 0 1
81720: ARRAY
81721: NOT
81722: PUSH
81723: LD_EXP 42
81727: PUSH
81728: LD_VAR 0 1
81732: ARRAY
81733: PUSH
81734: EMPTY
81735: EQUAL
81736: OR
81737: IFFALSE 81774
// begin for i in solds do
81739: LD_ADDR_VAR 0 7
81743: PUSH
81744: LD_VAR 0 2
81748: PUSH
81749: FOR_IN
81750: IFFALSE 81763
// ComStop ( i ) ;
81752: LD_VAR 0 7
81756: PPUSH
81757: CALL_OW 141
81761: GO 81749
81763: POP
81764: POP
// solds := [ ] ;
81765: LD_ADDR_VAR 0 2
81769: PUSH
81770: EMPTY
81771: ST_TO_ADDR
// exit ;
81772: GO 82089
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
81774: LD_VAR 0 5
81778: NOT
81779: PUSH
81780: LD_VAR 0 5
81784: PUSH
81785: LD_INT 3
81787: GREATER
81788: OR
81789: PUSH
81790: LD_EXP 64
81794: PUSH
81795: LD_VAR 0 1
81799: ARRAY
81800: OR
81801: IFFALSE 81842
// begin for i in solds do
81803: LD_ADDR_VAR 0 7
81807: PUSH
81808: LD_VAR 0 2
81812: PUSH
81813: FOR_IN
81814: IFFALSE 81838
// if HasTask ( i ) then
81816: LD_VAR 0 7
81820: PPUSH
81821: CALL_OW 314
81825: IFFALSE 81836
// ComStop ( i ) ;
81827: LD_VAR 0 7
81831: PPUSH
81832: CALL_OW 141
81836: GO 81813
81838: POP
81839: POP
// break ;
81840: GO 82077
// end ; for i in solds do
81842: LD_ADDR_VAR 0 7
81846: PUSH
81847: LD_VAR 0 2
81851: PUSH
81852: FOR_IN
81853: IFFALSE 82069
// begin if IsInUnit ( i ) then
81855: LD_VAR 0 7
81859: PPUSH
81860: CALL_OW 310
81864: IFFALSE 81875
// ComExitBuilding ( i ) ;
81866: LD_VAR 0 7
81870: PPUSH
81871: CALL_OW 122
// if GetLives ( i ) > 333 then
81875: LD_VAR 0 7
81879: PPUSH
81880: CALL_OW 256
81884: PUSH
81885: LD_INT 333
81887: GREATER
81888: IFFALSE 81916
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
81890: LD_VAR 0 7
81894: PPUSH
81895: LD_VAR 0 5
81899: PPUSH
81900: LD_VAR 0 7
81904: PPUSH
81905: CALL_OW 74
81909: PPUSH
81910: CALL_OW 115
81914: GO 82067
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
81916: LD_ADDR_VAR 0 8
81920: PUSH
81921: LD_EXP 42
81925: PUSH
81926: LD_VAR 0 1
81930: ARRAY
81931: PPUSH
81932: LD_INT 2
81934: PUSH
81935: LD_INT 30
81937: PUSH
81938: LD_INT 0
81940: PUSH
81941: EMPTY
81942: LIST
81943: LIST
81944: PUSH
81945: LD_INT 30
81947: PUSH
81948: LD_INT 1
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 30
81957: PUSH
81958: LD_INT 6
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: LIST
81969: LIST
81970: PPUSH
81971: CALL_OW 72
81975: PPUSH
81976: LD_VAR 0 7
81980: PPUSH
81981: CALL_OW 74
81985: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
81986: LD_VAR 0 7
81990: PPUSH
81991: LD_VAR 0 8
81995: PPUSH
81996: CALL_OW 250
82000: PPUSH
82001: LD_INT 3
82003: PPUSH
82004: LD_INT 5
82006: PPUSH
82007: CALL_OW 272
82011: PPUSH
82012: LD_VAR 0 8
82016: PPUSH
82017: CALL_OW 251
82021: PPUSH
82022: LD_INT 3
82024: PPUSH
82025: LD_INT 5
82027: PPUSH
82028: CALL_OW 273
82032: PPUSH
82033: CALL_OW 111
// SetTag ( i , 0 ) ;
82037: LD_VAR 0 7
82041: PPUSH
82042: LD_INT 0
82044: PPUSH
82045: CALL_OW 109
// solds := solds diff i ;
82049: LD_ADDR_VAR 0 2
82053: PUSH
82054: LD_VAR 0 2
82058: PUSH
82059: LD_VAR 0 7
82063: DIFF
82064: ST_TO_ADDR
// continue ;
82065: GO 81852
// end ; end ;
82067: GO 81852
82069: POP
82070: POP
// until solds ;
82071: LD_VAR 0 2
82075: IFFALSE 81684
// MC_Reset ( base , 18 ) ;
82077: LD_VAR 0 1
82081: PPUSH
82082: LD_INT 18
82084: PPUSH
82085: CALL 50668 0 2
// end ;
82089: LD_VAR 0 4
82093: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
82094: LD_INT 0
82096: PPUSH
82097: PPUSH
82098: PPUSH
82099: PPUSH
82100: PPUSH
82101: PPUSH
82102: PPUSH
82103: PPUSH
82104: PPUSH
82105: PPUSH
82106: PPUSH
82107: PPUSH
82108: PPUSH
82109: PPUSH
82110: PPUSH
82111: PPUSH
82112: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
82113: LD_ADDR_VAR 0 13
82117: PUSH
82118: LD_EXP 42
82122: PUSH
82123: LD_VAR 0 1
82127: ARRAY
82128: PPUSH
82129: LD_INT 25
82131: PUSH
82132: LD_INT 3
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PPUSH
82139: CALL_OW 72
82143: ST_TO_ADDR
// if mc_remote_driver [ base ] then
82144: LD_EXP 82
82148: PUSH
82149: LD_VAR 0 1
82153: ARRAY
82154: IFFALSE 82178
// mechs := mechs diff mc_remote_driver [ base ] ;
82156: LD_ADDR_VAR 0 13
82160: PUSH
82161: LD_VAR 0 13
82165: PUSH
82166: LD_EXP 82
82170: PUSH
82171: LD_VAR 0 1
82175: ARRAY
82176: DIFF
82177: ST_TO_ADDR
// for i in mechs do
82178: LD_ADDR_VAR 0 5
82182: PUSH
82183: LD_VAR 0 13
82187: PUSH
82188: FOR_IN
82189: IFFALSE 82224
// if GetTag ( i ) > 0 then
82191: LD_VAR 0 5
82195: PPUSH
82196: CALL_OW 110
82200: PUSH
82201: LD_INT 0
82203: GREATER
82204: IFFALSE 82222
// mechs := mechs diff i ;
82206: LD_ADDR_VAR 0 13
82210: PUSH
82211: LD_VAR 0 13
82215: PUSH
82216: LD_VAR 0 5
82220: DIFF
82221: ST_TO_ADDR
82222: GO 82188
82224: POP
82225: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
82226: LD_ADDR_VAR 0 9
82230: PUSH
82231: LD_EXP 42
82235: PUSH
82236: LD_VAR 0 1
82240: ARRAY
82241: PPUSH
82242: LD_INT 2
82244: PUSH
82245: LD_INT 25
82247: PUSH
82248: LD_INT 1
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 25
82257: PUSH
82258: LD_INT 5
82260: PUSH
82261: EMPTY
82262: LIST
82263: LIST
82264: PUSH
82265: LD_INT 25
82267: PUSH
82268: LD_INT 8
82270: PUSH
82271: EMPTY
82272: LIST
82273: LIST
82274: PUSH
82275: LD_INT 25
82277: PUSH
82278: LD_INT 9
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: PPUSH
82292: CALL_OW 72
82296: ST_TO_ADDR
// if not defenders and not solds then
82297: LD_VAR 0 2
82301: NOT
82302: PUSH
82303: LD_VAR 0 9
82307: NOT
82308: AND
82309: IFFALSE 82313
// exit ;
82311: GO 84003
// depot_under_attack := false ;
82313: LD_ADDR_VAR 0 17
82317: PUSH
82318: LD_INT 0
82320: ST_TO_ADDR
// sold_defenders := [ ] ;
82321: LD_ADDR_VAR 0 18
82325: PUSH
82326: EMPTY
82327: ST_TO_ADDR
// if mechs then
82328: LD_VAR 0 13
82332: IFFALSE 82485
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
82334: LD_ADDR_VAR 0 5
82338: PUSH
82339: LD_VAR 0 2
82343: PPUSH
82344: LD_INT 21
82346: PUSH
82347: LD_INT 2
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PPUSH
82354: CALL_OW 72
82358: PUSH
82359: FOR_IN
82360: IFFALSE 82483
// begin if GetTag ( i ) <> 20 then
82362: LD_VAR 0 5
82366: PPUSH
82367: CALL_OW 110
82371: PUSH
82372: LD_INT 20
82374: NONEQUAL
82375: IFFALSE 82389
// SetTag ( i , 20 ) ;
82377: LD_VAR 0 5
82381: PPUSH
82382: LD_INT 20
82384: PPUSH
82385: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
82389: LD_VAR 0 5
82393: PPUSH
82394: CALL_OW 263
82398: PUSH
82399: LD_INT 1
82401: EQUAL
82402: PUSH
82403: LD_VAR 0 5
82407: PPUSH
82408: CALL_OW 311
82412: NOT
82413: AND
82414: IFFALSE 82481
// begin un := mechs [ 1 ] ;
82416: LD_ADDR_VAR 0 11
82420: PUSH
82421: LD_VAR 0 13
82425: PUSH
82426: LD_INT 1
82428: ARRAY
82429: ST_TO_ADDR
// ComExit ( un ) ;
82430: LD_VAR 0 11
82434: PPUSH
82435: CALL 45763 0 1
// AddComEnterUnit ( un , i ) ;
82439: LD_VAR 0 11
82443: PPUSH
82444: LD_VAR 0 5
82448: PPUSH
82449: CALL_OW 180
// SetTag ( un , 19 ) ;
82453: LD_VAR 0 11
82457: PPUSH
82458: LD_INT 19
82460: PPUSH
82461: CALL_OW 109
// mechs := mechs diff un ;
82465: LD_ADDR_VAR 0 13
82469: PUSH
82470: LD_VAR 0 13
82474: PUSH
82475: LD_VAR 0 11
82479: DIFF
82480: ST_TO_ADDR
// end ; end ;
82481: GO 82359
82483: POP
82484: POP
// if solds then
82485: LD_VAR 0 9
82489: IFFALSE 82548
// for i in solds do
82491: LD_ADDR_VAR 0 5
82495: PUSH
82496: LD_VAR 0 9
82500: PUSH
82501: FOR_IN
82502: IFFALSE 82546
// if not GetTag ( i ) then
82504: LD_VAR 0 5
82508: PPUSH
82509: CALL_OW 110
82513: NOT
82514: IFFALSE 82544
// begin defenders := defenders union i ;
82516: LD_ADDR_VAR 0 2
82520: PUSH
82521: LD_VAR 0 2
82525: PUSH
82526: LD_VAR 0 5
82530: UNION
82531: ST_TO_ADDR
// SetTag ( i , 18 ) ;
82532: LD_VAR 0 5
82536: PPUSH
82537: LD_INT 18
82539: PPUSH
82540: CALL_OW 109
// end ;
82544: GO 82501
82546: POP
82547: POP
// repeat wait ( 0 0$2 ) ;
82548: LD_INT 70
82550: PPUSH
82551: CALL_OW 67
// enemy := mc_scan [ base ] ;
82555: LD_ADDR_VAR 0 3
82559: PUSH
82560: LD_EXP 65
82564: PUSH
82565: LD_VAR 0 1
82569: ARRAY
82570: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82571: LD_EXP 42
82575: PUSH
82576: LD_VAR 0 1
82580: ARRAY
82581: NOT
82582: PUSH
82583: LD_EXP 42
82587: PUSH
82588: LD_VAR 0 1
82592: ARRAY
82593: PUSH
82594: EMPTY
82595: EQUAL
82596: OR
82597: IFFALSE 82634
// begin for i in defenders do
82599: LD_ADDR_VAR 0 5
82603: PUSH
82604: LD_VAR 0 2
82608: PUSH
82609: FOR_IN
82610: IFFALSE 82623
// ComStop ( i ) ;
82612: LD_VAR 0 5
82616: PPUSH
82617: CALL_OW 141
82621: GO 82609
82623: POP
82624: POP
// defenders := [ ] ;
82625: LD_ADDR_VAR 0 2
82629: PUSH
82630: EMPTY
82631: ST_TO_ADDR
// exit ;
82632: GO 84003
// end ; for i in defenders do
82634: LD_ADDR_VAR 0 5
82638: PUSH
82639: LD_VAR 0 2
82643: PUSH
82644: FOR_IN
82645: IFFALSE 83463
// begin e := NearestUnitToUnit ( enemy , i ) ;
82647: LD_ADDR_VAR 0 14
82651: PUSH
82652: LD_VAR 0 3
82656: PPUSH
82657: LD_VAR 0 5
82661: PPUSH
82662: CALL_OW 74
82666: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82667: LD_ADDR_VAR 0 8
82671: PUSH
82672: LD_EXP 42
82676: PUSH
82677: LD_VAR 0 1
82681: ARRAY
82682: PPUSH
82683: LD_INT 2
82685: PUSH
82686: LD_INT 30
82688: PUSH
82689: LD_INT 0
82691: PUSH
82692: EMPTY
82693: LIST
82694: LIST
82695: PUSH
82696: LD_INT 30
82698: PUSH
82699: LD_INT 1
82701: PUSH
82702: EMPTY
82703: LIST
82704: LIST
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: LIST
82710: PPUSH
82711: CALL_OW 72
82715: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
82716: LD_ADDR_VAR 0 17
82720: PUSH
82721: LD_VAR 0 8
82725: NOT
82726: PUSH
82727: LD_VAR 0 8
82731: PPUSH
82732: LD_INT 3
82734: PUSH
82735: LD_INT 24
82737: PUSH
82738: LD_INT 600
82740: PUSH
82741: EMPTY
82742: LIST
82743: LIST
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PPUSH
82749: CALL_OW 72
82753: OR
82754: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
82755: LD_VAR 0 5
82759: PPUSH
82760: CALL_OW 247
82764: PUSH
82765: LD_INT 2
82767: DOUBLE
82768: EQUAL
82769: IFTRUE 82773
82771: GO 83169
82773: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
82774: LD_VAR 0 5
82778: PPUSH
82779: CALL_OW 256
82783: PUSH
82784: LD_INT 650
82786: GREATER
82787: PUSH
82788: LD_VAR 0 5
82792: PPUSH
82793: LD_VAR 0 14
82797: PPUSH
82798: CALL_OW 296
82802: PUSH
82803: LD_INT 40
82805: LESS
82806: PUSH
82807: LD_VAR 0 14
82811: PPUSH
82812: LD_EXP 67
82816: PUSH
82817: LD_VAR 0 1
82821: ARRAY
82822: PPUSH
82823: CALL_OW 308
82827: OR
82828: AND
82829: IFFALSE 82951
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
82831: LD_VAR 0 5
82835: PPUSH
82836: CALL_OW 262
82840: PUSH
82841: LD_INT 1
82843: EQUAL
82844: PUSH
82845: LD_VAR 0 5
82849: PPUSH
82850: CALL_OW 261
82854: PUSH
82855: LD_INT 30
82857: LESS
82858: AND
82859: PUSH
82860: LD_VAR 0 8
82864: AND
82865: IFFALSE 82935
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
82867: LD_VAR 0 5
82871: PPUSH
82872: LD_VAR 0 8
82876: PPUSH
82877: LD_VAR 0 5
82881: PPUSH
82882: CALL_OW 74
82886: PPUSH
82887: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
82891: LD_VAR 0 5
82895: PPUSH
82896: LD_VAR 0 8
82900: PPUSH
82901: LD_VAR 0 5
82905: PPUSH
82906: CALL_OW 74
82910: PPUSH
82911: CALL_OW 296
82915: PUSH
82916: LD_INT 6
82918: LESS
82919: IFFALSE 82933
// SetFuel ( i , 100 ) ;
82921: LD_VAR 0 5
82925: PPUSH
82926: LD_INT 100
82928: PPUSH
82929: CALL_OW 240
// end else
82933: GO 82949
// ComAttackUnit ( i , e ) ;
82935: LD_VAR 0 5
82939: PPUSH
82940: LD_VAR 0 14
82944: PPUSH
82945: CALL_OW 115
// end else
82949: GO 83052
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
82951: LD_VAR 0 14
82955: PPUSH
82956: LD_EXP 67
82960: PUSH
82961: LD_VAR 0 1
82965: ARRAY
82966: PPUSH
82967: CALL_OW 308
82971: NOT
82972: PUSH
82973: LD_VAR 0 5
82977: PPUSH
82978: LD_VAR 0 14
82982: PPUSH
82983: CALL_OW 296
82987: PUSH
82988: LD_INT 40
82990: GREATEREQUAL
82991: AND
82992: PUSH
82993: LD_VAR 0 5
82997: PPUSH
82998: CALL_OW 256
83002: PUSH
83003: LD_INT 650
83005: LESSEQUAL
83006: OR
83007: PUSH
83008: LD_VAR 0 5
83012: PPUSH
83013: LD_EXP 66
83017: PUSH
83018: LD_VAR 0 1
83022: ARRAY
83023: PPUSH
83024: CALL_OW 308
83028: NOT
83029: AND
83030: IFFALSE 83052
// ComMoveToArea ( i , mc_parking [ base ] ) ;
83032: LD_VAR 0 5
83036: PPUSH
83037: LD_EXP 66
83041: PUSH
83042: LD_VAR 0 1
83046: ARRAY
83047: PPUSH
83048: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
83052: LD_VAR 0 5
83056: PPUSH
83057: CALL_OW 256
83061: PUSH
83062: LD_INT 998
83064: LESS
83065: PUSH
83066: LD_VAR 0 5
83070: PPUSH
83071: CALL_OW 263
83075: PUSH
83076: LD_INT 1
83078: EQUAL
83079: AND
83080: PUSH
83081: LD_VAR 0 5
83085: PPUSH
83086: CALL_OW 311
83090: AND
83091: PUSH
83092: LD_VAR 0 5
83096: PPUSH
83097: LD_EXP 66
83101: PUSH
83102: LD_VAR 0 1
83106: ARRAY
83107: PPUSH
83108: CALL_OW 308
83112: AND
83113: IFFALSE 83167
// begin mech := IsDrivenBy ( i ) ;
83115: LD_ADDR_VAR 0 10
83119: PUSH
83120: LD_VAR 0 5
83124: PPUSH
83125: CALL_OW 311
83129: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
83130: LD_VAR 0 10
83134: PPUSH
83135: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
83139: LD_VAR 0 10
83143: PPUSH
83144: LD_VAR 0 5
83148: PPUSH
83149: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
83153: LD_VAR 0 10
83157: PPUSH
83158: LD_VAR 0 5
83162: PPUSH
83163: CALL_OW 180
// end ; end ; unit_human :
83167: GO 83434
83169: LD_INT 1
83171: DOUBLE
83172: EQUAL
83173: IFTRUE 83177
83175: GO 83433
83177: POP
// begin b := IsInUnit ( i ) ;
83178: LD_ADDR_VAR 0 19
83182: PUSH
83183: LD_VAR 0 5
83187: PPUSH
83188: CALL_OW 310
83192: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
83193: LD_ADDR_VAR 0 20
83197: PUSH
83198: LD_VAR 0 19
83202: NOT
83203: PUSH
83204: LD_VAR 0 19
83208: PPUSH
83209: CALL_OW 266
83213: PUSH
83214: LD_INT 32
83216: PUSH
83217: LD_INT 31
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: IN
83224: OR
83225: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
83226: LD_VAR 0 17
83230: PUSH
83231: LD_VAR 0 2
83235: PPUSH
83236: LD_INT 21
83238: PUSH
83239: LD_INT 2
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: PPUSH
83246: CALL_OW 72
83250: PUSH
83251: LD_INT 1
83253: LESSEQUAL
83254: OR
83255: PUSH
83256: LD_VAR 0 20
83260: AND
83261: PUSH
83262: LD_VAR 0 5
83266: PUSH
83267: LD_VAR 0 18
83271: IN
83272: NOT
83273: AND
83274: IFFALSE 83367
// begin if b then
83276: LD_VAR 0 19
83280: IFFALSE 83329
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
83282: LD_VAR 0 19
83286: PPUSH
83287: LD_VAR 0 3
83291: PPUSH
83292: LD_VAR 0 19
83296: PPUSH
83297: CALL_OW 74
83301: PPUSH
83302: CALL_OW 296
83306: PUSH
83307: LD_INT 10
83309: LESS
83310: PUSH
83311: LD_VAR 0 19
83315: PPUSH
83316: CALL_OW 461
83320: PUSH
83321: LD_INT 7
83323: NONEQUAL
83324: AND
83325: IFFALSE 83329
// continue ;
83327: GO 82644
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
83329: LD_ADDR_VAR 0 18
83333: PUSH
83334: LD_VAR 0 18
83338: PPUSH
83339: LD_VAR 0 18
83343: PUSH
83344: LD_INT 1
83346: PLUS
83347: PPUSH
83348: LD_VAR 0 5
83352: PPUSH
83353: CALL_OW 1
83357: ST_TO_ADDR
// ComExitBuilding ( i ) ;
83358: LD_VAR 0 5
83362: PPUSH
83363: CALL_OW 122
// end ; if sold_defenders then
83367: LD_VAR 0 18
83371: IFFALSE 83431
// if i in sold_defenders then
83373: LD_VAR 0 5
83377: PUSH
83378: LD_VAR 0 18
83382: IN
83383: IFFALSE 83431
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
83385: LD_VAR 0 5
83389: PPUSH
83390: CALL_OW 314
83394: NOT
83395: PUSH
83396: LD_VAR 0 5
83400: PPUSH
83401: LD_VAR 0 14
83405: PPUSH
83406: CALL_OW 296
83410: PUSH
83411: LD_INT 30
83413: LESS
83414: AND
83415: IFFALSE 83431
// ComAttackUnit ( i , e ) ;
83417: LD_VAR 0 5
83421: PPUSH
83422: LD_VAR 0 14
83426: PPUSH
83427: CALL_OW 115
// end ; end ; end ;
83431: GO 83434
83433: POP
// if IsDead ( i ) then
83434: LD_VAR 0 5
83438: PPUSH
83439: CALL_OW 301
83443: IFFALSE 83461
// defenders := defenders diff i ;
83445: LD_ADDR_VAR 0 2
83449: PUSH
83450: LD_VAR 0 2
83454: PUSH
83455: LD_VAR 0 5
83459: DIFF
83460: ST_TO_ADDR
// end ;
83461: GO 82644
83463: POP
83464: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
83465: LD_VAR 0 3
83469: NOT
83470: PUSH
83471: LD_VAR 0 2
83475: NOT
83476: OR
83477: PUSH
83478: LD_EXP 42
83482: PUSH
83483: LD_VAR 0 1
83487: ARRAY
83488: NOT
83489: OR
83490: IFFALSE 82548
// MC_Reset ( base , 18 ) ;
83492: LD_VAR 0 1
83496: PPUSH
83497: LD_INT 18
83499: PPUSH
83500: CALL 50668 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
83504: LD_ADDR_VAR 0 2
83508: PUSH
83509: LD_VAR 0 2
83513: PUSH
83514: LD_VAR 0 2
83518: PPUSH
83519: LD_INT 2
83521: PUSH
83522: LD_INT 25
83524: PUSH
83525: LD_INT 1
83527: PUSH
83528: EMPTY
83529: LIST
83530: LIST
83531: PUSH
83532: LD_INT 25
83534: PUSH
83535: LD_INT 5
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 25
83544: PUSH
83545: LD_INT 8
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 25
83554: PUSH
83555: LD_INT 9
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: EMPTY
83563: LIST
83564: LIST
83565: LIST
83566: LIST
83567: LIST
83568: PPUSH
83569: CALL_OW 72
83573: DIFF
83574: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
83575: LD_VAR 0 3
83579: NOT
83580: PUSH
83581: LD_VAR 0 2
83585: PPUSH
83586: LD_INT 21
83588: PUSH
83589: LD_INT 2
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PPUSH
83596: CALL_OW 72
83600: AND
83601: IFFALSE 83939
// begin tmp := FilterByTag ( defenders , 19 ) ;
83603: LD_ADDR_VAR 0 12
83607: PUSH
83608: LD_VAR 0 2
83612: PPUSH
83613: LD_INT 19
83615: PPUSH
83616: CALL 42893 0 2
83620: ST_TO_ADDR
// if tmp then
83621: LD_VAR 0 12
83625: IFFALSE 83695
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
83627: LD_ADDR_VAR 0 12
83631: PUSH
83632: LD_VAR 0 12
83636: PPUSH
83637: LD_INT 25
83639: PUSH
83640: LD_INT 3
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PPUSH
83647: CALL_OW 72
83651: ST_TO_ADDR
// if tmp then
83652: LD_VAR 0 12
83656: IFFALSE 83695
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
83658: LD_ADDR_EXP 54
83662: PUSH
83663: LD_EXP 54
83667: PPUSH
83668: LD_VAR 0 1
83672: PPUSH
83673: LD_EXP 54
83677: PUSH
83678: LD_VAR 0 1
83682: ARRAY
83683: PUSH
83684: LD_VAR 0 12
83688: UNION
83689: PPUSH
83690: CALL_OW 1
83694: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
83695: LD_VAR 0 1
83699: PPUSH
83700: LD_INT 19
83702: PPUSH
83703: CALL 50668 0 2
// repeat wait ( 0 0$1 ) ;
83707: LD_INT 35
83709: PPUSH
83710: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83714: LD_EXP 42
83718: PUSH
83719: LD_VAR 0 1
83723: ARRAY
83724: NOT
83725: PUSH
83726: LD_EXP 42
83730: PUSH
83731: LD_VAR 0 1
83735: ARRAY
83736: PUSH
83737: EMPTY
83738: EQUAL
83739: OR
83740: IFFALSE 83777
// begin for i in defenders do
83742: LD_ADDR_VAR 0 5
83746: PUSH
83747: LD_VAR 0 2
83751: PUSH
83752: FOR_IN
83753: IFFALSE 83766
// ComStop ( i ) ;
83755: LD_VAR 0 5
83759: PPUSH
83760: CALL_OW 141
83764: GO 83752
83766: POP
83767: POP
// defenders := [ ] ;
83768: LD_ADDR_VAR 0 2
83772: PUSH
83773: EMPTY
83774: ST_TO_ADDR
// exit ;
83775: GO 84003
// end ; for i in defenders do
83777: LD_ADDR_VAR 0 5
83781: PUSH
83782: LD_VAR 0 2
83786: PUSH
83787: FOR_IN
83788: IFFALSE 83877
// begin if not IsInArea ( i , mc_parking [ base ] ) then
83790: LD_VAR 0 5
83794: PPUSH
83795: LD_EXP 66
83799: PUSH
83800: LD_VAR 0 1
83804: ARRAY
83805: PPUSH
83806: CALL_OW 308
83810: NOT
83811: IFFALSE 83835
// ComMoveToArea ( i , mc_parking [ base ] ) else
83813: LD_VAR 0 5
83817: PPUSH
83818: LD_EXP 66
83822: PUSH
83823: LD_VAR 0 1
83827: ARRAY
83828: PPUSH
83829: CALL_OW 113
83833: GO 83875
// if GetControl ( i ) = control_manual then
83835: LD_VAR 0 5
83839: PPUSH
83840: CALL_OW 263
83844: PUSH
83845: LD_INT 1
83847: EQUAL
83848: IFFALSE 83875
// if IsDrivenBy ( i ) then
83850: LD_VAR 0 5
83854: PPUSH
83855: CALL_OW 311
83859: IFFALSE 83875
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
83861: LD_VAR 0 5
83865: PPUSH
83866: CALL_OW 311
83870: PPUSH
83871: CALL_OW 121
// end ;
83875: GO 83787
83877: POP
83878: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
83879: LD_VAR 0 2
83883: PPUSH
83884: LD_INT 95
83886: PUSH
83887: LD_EXP 66
83891: PUSH
83892: LD_VAR 0 1
83896: ARRAY
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: PPUSH
83902: CALL_OW 72
83906: PUSH
83907: LD_VAR 0 2
83911: EQUAL
83912: PUSH
83913: LD_EXP 65
83917: PUSH
83918: LD_VAR 0 1
83922: ARRAY
83923: OR
83924: PUSH
83925: LD_EXP 42
83929: PUSH
83930: LD_VAR 0 1
83934: ARRAY
83935: NOT
83936: OR
83937: IFFALSE 83707
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
83939: LD_ADDR_EXP 64
83943: PUSH
83944: LD_EXP 64
83948: PPUSH
83949: LD_VAR 0 1
83953: PPUSH
83954: LD_VAR 0 2
83958: PPUSH
83959: LD_INT 21
83961: PUSH
83962: LD_INT 2
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PPUSH
83969: CALL_OW 72
83973: PPUSH
83974: CALL_OW 1
83978: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
83979: LD_VAR 0 1
83983: PPUSH
83984: LD_INT 19
83986: PPUSH
83987: CALL 50668 0 2
// MC_Reset ( base , 20 ) ;
83991: LD_VAR 0 1
83995: PPUSH
83996: LD_INT 20
83998: PPUSH
83999: CALL 50668 0 2
// end ; end_of_file
84003: LD_VAR 0 4
84007: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
84008: LD_INT 0
84010: PPUSH
84011: PPUSH
84012: PPUSH
84013: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
84014: LD_VAR 0 1
84018: PPUSH
84019: CALL_OW 264
84023: PUSH
84024: LD_EXP 89
84028: EQUAL
84029: IFFALSE 84101
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
84031: LD_INT 68
84033: PPUSH
84034: LD_VAR 0 1
84038: PPUSH
84039: CALL_OW 255
84043: PPUSH
84044: CALL_OW 321
84048: PUSH
84049: LD_INT 2
84051: EQUAL
84052: IFFALSE 84064
// eff := 70 else
84054: LD_ADDR_VAR 0 4
84058: PUSH
84059: LD_INT 70
84061: ST_TO_ADDR
84062: GO 84072
// eff := 30 ;
84064: LD_ADDR_VAR 0 4
84068: PUSH
84069: LD_INT 30
84071: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
84072: LD_VAR 0 1
84076: PPUSH
84077: CALL_OW 250
84081: PPUSH
84082: LD_VAR 0 1
84086: PPUSH
84087: CALL_OW 251
84091: PPUSH
84092: LD_VAR 0 4
84096: PPUSH
84097: CALL_OW 495
// end ; end ;
84101: LD_VAR 0 2
84105: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
84106: LD_INT 0
84108: PPUSH
// end ;
84109: LD_VAR 0 4
84113: RET
// export function SOS_Command ( cmd ) ; begin
84114: LD_INT 0
84116: PPUSH
// end ;
84117: LD_VAR 0 2
84121: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
84122: LD_INT 0
84124: PPUSH
// if cmd = 121 then
84125: LD_VAR 0 1
84129: PUSH
84130: LD_INT 121
84132: EQUAL
84133: IFFALSE 84135
// end ;
84135: LD_VAR 0 6
84139: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
84140: LD_INT 0
84142: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
84143: LD_VAR 0 1
84147: PUSH
84148: LD_INT 250
84150: EQUAL
84151: PUSH
84152: LD_VAR 0 2
84156: PPUSH
84157: CALL_OW 264
84161: PUSH
84162: LD_EXP 92
84166: EQUAL
84167: AND
84168: IFFALSE 84189
// MinerPlaceMine ( unit , x , y ) ;
84170: LD_VAR 0 2
84174: PPUSH
84175: LD_VAR 0 4
84179: PPUSH
84180: LD_VAR 0 5
84184: PPUSH
84185: CALL 86538 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
84189: LD_VAR 0 1
84193: PUSH
84194: LD_INT 251
84196: EQUAL
84197: PUSH
84198: LD_VAR 0 2
84202: PPUSH
84203: CALL_OW 264
84207: PUSH
84208: LD_EXP 92
84212: EQUAL
84213: AND
84214: IFFALSE 84235
// MinerDetonateMine ( unit , x , y ) ;
84216: LD_VAR 0 2
84220: PPUSH
84221: LD_VAR 0 4
84225: PPUSH
84226: LD_VAR 0 5
84230: PPUSH
84231: CALL 86815 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
84235: LD_VAR 0 1
84239: PUSH
84240: LD_INT 252
84242: EQUAL
84243: PUSH
84244: LD_VAR 0 2
84248: PPUSH
84249: CALL_OW 264
84253: PUSH
84254: LD_EXP 92
84258: EQUAL
84259: AND
84260: IFFALSE 84281
// MinerCreateMinefield ( unit , x , y ) ;
84262: LD_VAR 0 2
84266: PPUSH
84267: LD_VAR 0 4
84271: PPUSH
84272: LD_VAR 0 5
84276: PPUSH
84277: CALL 87232 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
84281: LD_VAR 0 1
84285: PUSH
84286: LD_INT 253
84288: EQUAL
84289: PUSH
84290: LD_VAR 0 2
84294: PPUSH
84295: CALL_OW 257
84299: PUSH
84300: LD_INT 5
84302: EQUAL
84303: AND
84304: IFFALSE 84325
// ComBinocular ( unit , x , y ) ;
84306: LD_VAR 0 2
84310: PPUSH
84311: LD_VAR 0 4
84315: PPUSH
84316: LD_VAR 0 5
84320: PPUSH
84321: CALL 87603 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
84325: LD_VAR 0 1
84329: PUSH
84330: LD_INT 254
84332: EQUAL
84333: PUSH
84334: LD_VAR 0 2
84338: PPUSH
84339: CALL_OW 264
84343: PUSH
84344: LD_EXP 87
84348: EQUAL
84349: AND
84350: PUSH
84351: LD_VAR 0 3
84355: PPUSH
84356: CALL_OW 263
84360: PUSH
84361: LD_INT 3
84363: EQUAL
84364: AND
84365: IFFALSE 84381
// HackDestroyVehicle ( unit , selectedUnit ) ;
84367: LD_VAR 0 2
84371: PPUSH
84372: LD_VAR 0 3
84376: PPUSH
84377: CALL 85898 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
84381: LD_VAR 0 1
84385: PUSH
84386: LD_INT 255
84388: EQUAL
84389: PUSH
84390: LD_VAR 0 2
84394: PPUSH
84395: CALL_OW 264
84399: PUSH
84400: LD_INT 14
84402: PUSH
84403: LD_INT 53
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: IN
84410: AND
84411: PUSH
84412: LD_VAR 0 4
84416: PPUSH
84417: LD_VAR 0 5
84421: PPUSH
84422: CALL_OW 488
84426: AND
84427: IFFALSE 84451
// CutTreeXYR ( unit , x , y , 12 ) ;
84429: LD_VAR 0 2
84433: PPUSH
84434: LD_VAR 0 4
84438: PPUSH
84439: LD_VAR 0 5
84443: PPUSH
84444: LD_INT 12
84446: PPUSH
84447: CALL 84464 0 4
// end ;
84451: LD_VAR 0 6
84455: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
84456: LD_INT 0
84458: PPUSH
// end ;
84459: LD_VAR 0 4
84463: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
84464: LD_INT 0
84466: PPUSH
84467: PPUSH
84468: PPUSH
84469: PPUSH
84470: PPUSH
84471: PPUSH
84472: PPUSH
84473: PPUSH
84474: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
84475: LD_VAR 0 1
84479: NOT
84480: PUSH
84481: LD_VAR 0 2
84485: PPUSH
84486: LD_VAR 0 3
84490: PPUSH
84491: CALL_OW 488
84495: NOT
84496: OR
84497: PUSH
84498: LD_VAR 0 4
84502: NOT
84503: OR
84504: IFFALSE 84508
// exit ;
84506: GO 84848
// list := [ ] ;
84508: LD_ADDR_VAR 0 13
84512: PUSH
84513: EMPTY
84514: ST_TO_ADDR
// if x - r < 0 then
84515: LD_VAR 0 2
84519: PUSH
84520: LD_VAR 0 4
84524: MINUS
84525: PUSH
84526: LD_INT 0
84528: LESS
84529: IFFALSE 84541
// min_x := 0 else
84531: LD_ADDR_VAR 0 7
84535: PUSH
84536: LD_INT 0
84538: ST_TO_ADDR
84539: GO 84557
// min_x := x - r ;
84541: LD_ADDR_VAR 0 7
84545: PUSH
84546: LD_VAR 0 2
84550: PUSH
84551: LD_VAR 0 4
84555: MINUS
84556: ST_TO_ADDR
// if y - r < 0 then
84557: LD_VAR 0 3
84561: PUSH
84562: LD_VAR 0 4
84566: MINUS
84567: PUSH
84568: LD_INT 0
84570: LESS
84571: IFFALSE 84583
// min_y := 0 else
84573: LD_ADDR_VAR 0 8
84577: PUSH
84578: LD_INT 0
84580: ST_TO_ADDR
84581: GO 84599
// min_y := y - r ;
84583: LD_ADDR_VAR 0 8
84587: PUSH
84588: LD_VAR 0 3
84592: PUSH
84593: LD_VAR 0 4
84597: MINUS
84598: ST_TO_ADDR
// max_x := x + r ;
84599: LD_ADDR_VAR 0 9
84603: PUSH
84604: LD_VAR 0 2
84608: PUSH
84609: LD_VAR 0 4
84613: PLUS
84614: ST_TO_ADDR
// max_y := y + r ;
84615: LD_ADDR_VAR 0 10
84619: PUSH
84620: LD_VAR 0 3
84624: PUSH
84625: LD_VAR 0 4
84629: PLUS
84630: ST_TO_ADDR
// for _x = min_x to max_x do
84631: LD_ADDR_VAR 0 11
84635: PUSH
84636: DOUBLE
84637: LD_VAR 0 7
84641: DEC
84642: ST_TO_ADDR
84643: LD_VAR 0 9
84647: PUSH
84648: FOR_TO
84649: IFFALSE 84766
// for _y = min_y to max_y do
84651: LD_ADDR_VAR 0 12
84655: PUSH
84656: DOUBLE
84657: LD_VAR 0 8
84661: DEC
84662: ST_TO_ADDR
84663: LD_VAR 0 10
84667: PUSH
84668: FOR_TO
84669: IFFALSE 84762
// begin if not ValidHex ( _x , _y ) then
84671: LD_VAR 0 11
84675: PPUSH
84676: LD_VAR 0 12
84680: PPUSH
84681: CALL_OW 488
84685: NOT
84686: IFFALSE 84690
// continue ;
84688: GO 84668
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
84690: LD_VAR 0 11
84694: PPUSH
84695: LD_VAR 0 12
84699: PPUSH
84700: CALL_OW 351
84704: PUSH
84705: LD_VAR 0 11
84709: PPUSH
84710: LD_VAR 0 12
84714: PPUSH
84715: CALL_OW 554
84719: AND
84720: IFFALSE 84760
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
84722: LD_ADDR_VAR 0 13
84726: PUSH
84727: LD_VAR 0 13
84731: PPUSH
84732: LD_VAR 0 13
84736: PUSH
84737: LD_INT 1
84739: PLUS
84740: PPUSH
84741: LD_VAR 0 11
84745: PUSH
84746: LD_VAR 0 12
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PPUSH
84755: CALL_OW 2
84759: ST_TO_ADDR
// end ;
84760: GO 84668
84762: POP
84763: POP
84764: GO 84648
84766: POP
84767: POP
// if not list then
84768: LD_VAR 0 13
84772: NOT
84773: IFFALSE 84777
// exit ;
84775: GO 84848
// for i in list do
84777: LD_ADDR_VAR 0 6
84781: PUSH
84782: LD_VAR 0 13
84786: PUSH
84787: FOR_IN
84788: IFFALSE 84846
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
84790: LD_VAR 0 1
84794: PPUSH
84795: LD_STRING M
84797: PUSH
84798: LD_VAR 0 6
84802: PUSH
84803: LD_INT 1
84805: ARRAY
84806: PUSH
84807: LD_VAR 0 6
84811: PUSH
84812: LD_INT 2
84814: ARRAY
84815: PUSH
84816: LD_INT 0
84818: PUSH
84819: LD_INT 0
84821: PUSH
84822: LD_INT 0
84824: PUSH
84825: LD_INT 0
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: LIST
84836: PUSH
84837: EMPTY
84838: LIST
84839: PPUSH
84840: CALL_OW 447
84844: GO 84787
84846: POP
84847: POP
// end ;
84848: LD_VAR 0 5
84852: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
84853: LD_EXP 103
84857: NOT
84858: IFFALSE 84908
84860: GO 84862
84862: DISABLE
// begin initHack := true ;
84863: LD_ADDR_EXP 103
84867: PUSH
84868: LD_INT 1
84870: ST_TO_ADDR
// hackTanks := [ ] ;
84871: LD_ADDR_EXP 104
84875: PUSH
84876: EMPTY
84877: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
84878: LD_ADDR_EXP 105
84882: PUSH
84883: EMPTY
84884: ST_TO_ADDR
// hackLimit := 3 ;
84885: LD_ADDR_EXP 106
84889: PUSH
84890: LD_INT 3
84892: ST_TO_ADDR
// hackDist := 12 ;
84893: LD_ADDR_EXP 107
84897: PUSH
84898: LD_INT 12
84900: ST_TO_ADDR
// hackCounter := [ ] ;
84901: LD_ADDR_EXP 108
84905: PUSH
84906: EMPTY
84907: ST_TO_ADDR
// end ;
84908: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
84909: LD_EXP 103
84913: PUSH
84914: LD_INT 34
84916: PUSH
84917: LD_EXP 87
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PPUSH
84926: CALL_OW 69
84930: AND
84931: IFFALSE 85186
84933: GO 84935
84935: DISABLE
84936: LD_INT 0
84938: PPUSH
84939: PPUSH
// begin enable ;
84940: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
84941: LD_ADDR_VAR 0 1
84945: PUSH
84946: LD_INT 34
84948: PUSH
84949: LD_EXP 87
84953: PUSH
84954: EMPTY
84955: LIST
84956: LIST
84957: PPUSH
84958: CALL_OW 69
84962: PUSH
84963: FOR_IN
84964: IFFALSE 85184
// begin if not i in hackTanks then
84966: LD_VAR 0 1
84970: PUSH
84971: LD_EXP 104
84975: IN
84976: NOT
84977: IFFALSE 85060
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
84979: LD_ADDR_EXP 104
84983: PUSH
84984: LD_EXP 104
84988: PPUSH
84989: LD_EXP 104
84993: PUSH
84994: LD_INT 1
84996: PLUS
84997: PPUSH
84998: LD_VAR 0 1
85002: PPUSH
85003: CALL_OW 1
85007: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
85008: LD_ADDR_EXP 105
85012: PUSH
85013: LD_EXP 105
85017: PPUSH
85018: LD_EXP 105
85022: PUSH
85023: LD_INT 1
85025: PLUS
85026: PPUSH
85027: EMPTY
85028: PPUSH
85029: CALL_OW 1
85033: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
85034: LD_ADDR_EXP 108
85038: PUSH
85039: LD_EXP 108
85043: PPUSH
85044: LD_EXP 108
85048: PUSH
85049: LD_INT 1
85051: PLUS
85052: PPUSH
85053: EMPTY
85054: PPUSH
85055: CALL_OW 1
85059: ST_TO_ADDR
// end ; if not IsOk ( i ) then
85060: LD_VAR 0 1
85064: PPUSH
85065: CALL_OW 302
85069: NOT
85070: IFFALSE 85083
// begin HackUnlinkAll ( i ) ;
85072: LD_VAR 0 1
85076: PPUSH
85077: CALL 85189 0 1
// continue ;
85081: GO 84963
// end ; HackCheckCapturedStatus ( i ) ;
85083: LD_VAR 0 1
85087: PPUSH
85088: CALL 85632 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
85092: LD_ADDR_VAR 0 2
85096: PUSH
85097: LD_INT 81
85099: PUSH
85100: LD_VAR 0 1
85104: PPUSH
85105: CALL_OW 255
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 33
85116: PUSH
85117: LD_INT 3
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: PUSH
85124: LD_INT 91
85126: PUSH
85127: LD_VAR 0 1
85131: PUSH
85132: LD_EXP 107
85136: PUSH
85137: EMPTY
85138: LIST
85139: LIST
85140: LIST
85141: PUSH
85142: LD_INT 50
85144: PUSH
85145: EMPTY
85146: LIST
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: PPUSH
85154: CALL_OW 69
85158: ST_TO_ADDR
// if not tmp then
85159: LD_VAR 0 2
85163: NOT
85164: IFFALSE 85168
// continue ;
85166: GO 84963
// HackLink ( i , tmp ) ;
85168: LD_VAR 0 1
85172: PPUSH
85173: LD_VAR 0 2
85177: PPUSH
85178: CALL 85325 0 2
// end ;
85182: GO 84963
85184: POP
85185: POP
// end ;
85186: PPOPN 2
85188: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
85189: LD_INT 0
85191: PPUSH
85192: PPUSH
85193: PPUSH
// if not hack in hackTanks then
85194: LD_VAR 0 1
85198: PUSH
85199: LD_EXP 104
85203: IN
85204: NOT
85205: IFFALSE 85209
// exit ;
85207: GO 85320
// index := GetElementIndex ( hackTanks , hack ) ;
85209: LD_ADDR_VAR 0 4
85213: PUSH
85214: LD_EXP 104
85218: PPUSH
85219: LD_VAR 0 1
85223: PPUSH
85224: CALL 14117 0 2
85228: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
85229: LD_EXP 105
85233: PUSH
85234: LD_VAR 0 4
85238: ARRAY
85239: IFFALSE 85320
// begin for i in hackTanksCaptured [ index ] do
85241: LD_ADDR_VAR 0 3
85245: PUSH
85246: LD_EXP 105
85250: PUSH
85251: LD_VAR 0 4
85255: ARRAY
85256: PUSH
85257: FOR_IN
85258: IFFALSE 85284
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
85260: LD_VAR 0 3
85264: PUSH
85265: LD_INT 1
85267: ARRAY
85268: PPUSH
85269: LD_VAR 0 3
85273: PUSH
85274: LD_INT 2
85276: ARRAY
85277: PPUSH
85278: CALL_OW 235
85282: GO 85257
85284: POP
85285: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
85286: LD_ADDR_EXP 105
85290: PUSH
85291: LD_EXP 105
85295: PPUSH
85296: LD_VAR 0 4
85300: PPUSH
85301: EMPTY
85302: PPUSH
85303: CALL_OW 1
85307: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
85308: LD_VAR 0 1
85312: PPUSH
85313: LD_INT 0
85315: PPUSH
85316: CALL_OW 505
// end ; end ;
85320: LD_VAR 0 2
85324: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
85325: LD_INT 0
85327: PPUSH
85328: PPUSH
85329: PPUSH
// if not hack in hackTanks or not vehicles then
85330: LD_VAR 0 1
85334: PUSH
85335: LD_EXP 104
85339: IN
85340: NOT
85341: PUSH
85342: LD_VAR 0 2
85346: NOT
85347: OR
85348: IFFALSE 85352
// exit ;
85350: GO 85627
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
85352: LD_ADDR_VAR 0 2
85356: PUSH
85357: LD_VAR 0 1
85361: PPUSH
85362: LD_VAR 0 2
85366: PPUSH
85367: LD_INT 1
85369: PPUSH
85370: LD_INT 1
85372: PPUSH
85373: CALL 14767 0 4
85377: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
85378: LD_ADDR_VAR 0 5
85382: PUSH
85383: LD_EXP 104
85387: PPUSH
85388: LD_VAR 0 1
85392: PPUSH
85393: CALL 14117 0 2
85397: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
85398: LD_EXP 105
85402: PUSH
85403: LD_VAR 0 5
85407: ARRAY
85408: PUSH
85409: LD_EXP 106
85413: LESS
85414: IFFALSE 85603
// begin for i := 1 to vehicles do
85416: LD_ADDR_VAR 0 4
85420: PUSH
85421: DOUBLE
85422: LD_INT 1
85424: DEC
85425: ST_TO_ADDR
85426: LD_VAR 0 2
85430: PUSH
85431: FOR_TO
85432: IFFALSE 85601
// begin if hackTanksCaptured [ index ] = hackLimit then
85434: LD_EXP 105
85438: PUSH
85439: LD_VAR 0 5
85443: ARRAY
85444: PUSH
85445: LD_EXP 106
85449: EQUAL
85450: IFFALSE 85454
// break ;
85452: GO 85601
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
85454: LD_ADDR_EXP 108
85458: PUSH
85459: LD_EXP 108
85463: PPUSH
85464: LD_VAR 0 5
85468: PPUSH
85469: LD_EXP 108
85473: PUSH
85474: LD_VAR 0 5
85478: ARRAY
85479: PUSH
85480: LD_INT 1
85482: PLUS
85483: PPUSH
85484: CALL_OW 1
85488: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
85489: LD_ADDR_EXP 105
85493: PUSH
85494: LD_EXP 105
85498: PPUSH
85499: LD_VAR 0 5
85503: PUSH
85504: LD_EXP 105
85508: PUSH
85509: LD_VAR 0 5
85513: ARRAY
85514: PUSH
85515: LD_INT 1
85517: PLUS
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PPUSH
85523: LD_VAR 0 2
85527: PUSH
85528: LD_VAR 0 4
85532: ARRAY
85533: PUSH
85534: LD_VAR 0 2
85538: PUSH
85539: LD_VAR 0 4
85543: ARRAY
85544: PPUSH
85545: CALL_OW 255
85549: PUSH
85550: EMPTY
85551: LIST
85552: LIST
85553: PPUSH
85554: CALL 14332 0 3
85558: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
85559: LD_VAR 0 2
85563: PUSH
85564: LD_VAR 0 4
85568: ARRAY
85569: PPUSH
85570: LD_VAR 0 1
85574: PPUSH
85575: CALL_OW 255
85579: PPUSH
85580: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
85584: LD_VAR 0 2
85588: PUSH
85589: LD_VAR 0 4
85593: ARRAY
85594: PPUSH
85595: CALL_OW 141
// end ;
85599: GO 85431
85601: POP
85602: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
85603: LD_VAR 0 1
85607: PPUSH
85608: LD_EXP 105
85612: PUSH
85613: LD_VAR 0 5
85617: ARRAY
85618: PUSH
85619: LD_INT 0
85621: PLUS
85622: PPUSH
85623: CALL_OW 505
// end ;
85627: LD_VAR 0 3
85631: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
85632: LD_INT 0
85634: PPUSH
85635: PPUSH
85636: PPUSH
85637: PPUSH
// if not hack in hackTanks then
85638: LD_VAR 0 1
85642: PUSH
85643: LD_EXP 104
85647: IN
85648: NOT
85649: IFFALSE 85653
// exit ;
85651: GO 85893
// index := GetElementIndex ( hackTanks , hack ) ;
85653: LD_ADDR_VAR 0 4
85657: PUSH
85658: LD_EXP 104
85662: PPUSH
85663: LD_VAR 0 1
85667: PPUSH
85668: CALL 14117 0 2
85672: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
85673: LD_ADDR_VAR 0 3
85677: PUSH
85678: DOUBLE
85679: LD_EXP 105
85683: PUSH
85684: LD_VAR 0 4
85688: ARRAY
85689: INC
85690: ST_TO_ADDR
85691: LD_INT 1
85693: PUSH
85694: FOR_DOWNTO
85695: IFFALSE 85867
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
85697: LD_ADDR_VAR 0 5
85701: PUSH
85702: LD_EXP 105
85706: PUSH
85707: LD_VAR 0 4
85711: ARRAY
85712: PUSH
85713: LD_VAR 0 3
85717: ARRAY
85718: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
85719: LD_VAR 0 5
85723: PUSH
85724: LD_INT 1
85726: ARRAY
85727: PPUSH
85728: CALL_OW 302
85732: NOT
85733: PUSH
85734: LD_VAR 0 5
85738: PUSH
85739: LD_INT 1
85741: ARRAY
85742: PPUSH
85743: CALL_OW 255
85747: PUSH
85748: LD_VAR 0 1
85752: PPUSH
85753: CALL_OW 255
85757: NONEQUAL
85758: OR
85759: IFFALSE 85865
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
85761: LD_VAR 0 5
85765: PUSH
85766: LD_INT 1
85768: ARRAY
85769: PPUSH
85770: CALL_OW 305
85774: PUSH
85775: LD_VAR 0 5
85779: PUSH
85780: LD_INT 1
85782: ARRAY
85783: PPUSH
85784: CALL_OW 255
85788: PUSH
85789: LD_VAR 0 1
85793: PPUSH
85794: CALL_OW 255
85798: EQUAL
85799: AND
85800: IFFALSE 85824
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
85802: LD_VAR 0 5
85806: PUSH
85807: LD_INT 1
85809: ARRAY
85810: PPUSH
85811: LD_VAR 0 5
85815: PUSH
85816: LD_INT 2
85818: ARRAY
85819: PPUSH
85820: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
85824: LD_ADDR_EXP 105
85828: PUSH
85829: LD_EXP 105
85833: PPUSH
85834: LD_VAR 0 4
85838: PPUSH
85839: LD_EXP 105
85843: PUSH
85844: LD_VAR 0 4
85848: ARRAY
85849: PPUSH
85850: LD_VAR 0 3
85854: PPUSH
85855: CALL_OW 3
85859: PPUSH
85860: CALL_OW 1
85864: ST_TO_ADDR
// end ; end ;
85865: GO 85694
85867: POP
85868: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
85869: LD_VAR 0 1
85873: PPUSH
85874: LD_EXP 105
85878: PUSH
85879: LD_VAR 0 4
85883: ARRAY
85884: PUSH
85885: LD_INT 0
85887: PLUS
85888: PPUSH
85889: CALL_OW 505
// end ;
85893: LD_VAR 0 2
85897: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
85898: LD_INT 0
85900: PPUSH
85901: PPUSH
85902: PPUSH
85903: PPUSH
// if not hack in hackTanks then
85904: LD_VAR 0 1
85908: PUSH
85909: LD_EXP 104
85913: IN
85914: NOT
85915: IFFALSE 85919
// exit ;
85917: GO 86004
// index := GetElementIndex ( hackTanks , hack ) ;
85919: LD_ADDR_VAR 0 5
85923: PUSH
85924: LD_EXP 104
85928: PPUSH
85929: LD_VAR 0 1
85933: PPUSH
85934: CALL 14117 0 2
85938: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
85939: LD_ADDR_VAR 0 4
85943: PUSH
85944: DOUBLE
85945: LD_INT 1
85947: DEC
85948: ST_TO_ADDR
85949: LD_EXP 105
85953: PUSH
85954: LD_VAR 0 5
85958: ARRAY
85959: PUSH
85960: FOR_TO
85961: IFFALSE 86002
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
85963: LD_EXP 105
85967: PUSH
85968: LD_VAR 0 5
85972: ARRAY
85973: PUSH
85974: LD_VAR 0 4
85978: ARRAY
85979: PUSH
85980: LD_INT 1
85982: ARRAY
85983: PUSH
85984: LD_VAR 0 2
85988: EQUAL
85989: IFFALSE 86000
// KillUnit ( vehicle ) ;
85991: LD_VAR 0 2
85995: PPUSH
85996: CALL_OW 66
86000: GO 85960
86002: POP
86003: POP
// end ;
86004: LD_VAR 0 3
86008: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
86009: LD_EXP 109
86013: NOT
86014: IFFALSE 86049
86016: GO 86018
86018: DISABLE
// begin initMiner := true ;
86019: LD_ADDR_EXP 109
86023: PUSH
86024: LD_INT 1
86026: ST_TO_ADDR
// minersList := [ ] ;
86027: LD_ADDR_EXP 110
86031: PUSH
86032: EMPTY
86033: ST_TO_ADDR
// minerMinesList := [ ] ;
86034: LD_ADDR_EXP 111
86038: PUSH
86039: EMPTY
86040: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
86041: LD_ADDR_EXP 112
86045: PUSH
86046: LD_INT 5
86048: ST_TO_ADDR
// end ;
86049: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
86050: LD_EXP 109
86054: PUSH
86055: LD_INT 34
86057: PUSH
86058: LD_EXP 92
86062: PUSH
86063: EMPTY
86064: LIST
86065: LIST
86066: PPUSH
86067: CALL_OW 69
86071: AND
86072: IFFALSE 86535
86074: GO 86076
86076: DISABLE
86077: LD_INT 0
86079: PPUSH
86080: PPUSH
86081: PPUSH
86082: PPUSH
// begin enable ;
86083: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
86084: LD_ADDR_VAR 0 1
86088: PUSH
86089: LD_INT 34
86091: PUSH
86092: LD_EXP 92
86096: PUSH
86097: EMPTY
86098: LIST
86099: LIST
86100: PPUSH
86101: CALL_OW 69
86105: PUSH
86106: FOR_IN
86107: IFFALSE 86179
// begin if not i in minersList then
86109: LD_VAR 0 1
86113: PUSH
86114: LD_EXP 110
86118: IN
86119: NOT
86120: IFFALSE 86177
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
86122: LD_ADDR_EXP 110
86126: PUSH
86127: LD_EXP 110
86131: PPUSH
86132: LD_EXP 110
86136: PUSH
86137: LD_INT 1
86139: PLUS
86140: PPUSH
86141: LD_VAR 0 1
86145: PPUSH
86146: CALL_OW 1
86150: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
86151: LD_ADDR_EXP 111
86155: PUSH
86156: LD_EXP 111
86160: PPUSH
86161: LD_EXP 111
86165: PUSH
86166: LD_INT 1
86168: PLUS
86169: PPUSH
86170: EMPTY
86171: PPUSH
86172: CALL_OW 1
86176: ST_TO_ADDR
// end end ;
86177: GO 86106
86179: POP
86180: POP
// for i := minerMinesList downto 1 do
86181: LD_ADDR_VAR 0 1
86185: PUSH
86186: DOUBLE
86187: LD_EXP 111
86191: INC
86192: ST_TO_ADDR
86193: LD_INT 1
86195: PUSH
86196: FOR_DOWNTO
86197: IFFALSE 86533
// begin if IsLive ( minersList [ i ] ) then
86199: LD_EXP 110
86203: PUSH
86204: LD_VAR 0 1
86208: ARRAY
86209: PPUSH
86210: CALL_OW 300
86214: IFFALSE 86242
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
86216: LD_EXP 110
86220: PUSH
86221: LD_VAR 0 1
86225: ARRAY
86226: PPUSH
86227: LD_EXP 111
86231: PUSH
86232: LD_VAR 0 1
86236: ARRAY
86237: PPUSH
86238: CALL_OW 505
// if not minerMinesList [ i ] then
86242: LD_EXP 111
86246: PUSH
86247: LD_VAR 0 1
86251: ARRAY
86252: NOT
86253: IFFALSE 86257
// continue ;
86255: GO 86196
// for j := minerMinesList [ i ] downto 1 do
86257: LD_ADDR_VAR 0 2
86261: PUSH
86262: DOUBLE
86263: LD_EXP 111
86267: PUSH
86268: LD_VAR 0 1
86272: ARRAY
86273: INC
86274: ST_TO_ADDR
86275: LD_INT 1
86277: PUSH
86278: FOR_DOWNTO
86279: IFFALSE 86529
// begin side := GetSide ( minersList [ i ] ) ;
86281: LD_ADDR_VAR 0 3
86285: PUSH
86286: LD_EXP 110
86290: PUSH
86291: LD_VAR 0 1
86295: ARRAY
86296: PPUSH
86297: CALL_OW 255
86301: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
86302: LD_ADDR_VAR 0 4
86306: PUSH
86307: LD_EXP 111
86311: PUSH
86312: LD_VAR 0 1
86316: ARRAY
86317: PUSH
86318: LD_VAR 0 2
86322: ARRAY
86323: PUSH
86324: LD_INT 1
86326: ARRAY
86327: PPUSH
86328: LD_EXP 111
86332: PUSH
86333: LD_VAR 0 1
86337: ARRAY
86338: PUSH
86339: LD_VAR 0 2
86343: ARRAY
86344: PUSH
86345: LD_INT 2
86347: ARRAY
86348: PPUSH
86349: CALL_OW 428
86353: ST_TO_ADDR
// if not tmp then
86354: LD_VAR 0 4
86358: NOT
86359: IFFALSE 86363
// continue ;
86361: GO 86278
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
86363: LD_VAR 0 4
86367: PUSH
86368: LD_INT 81
86370: PUSH
86371: LD_VAR 0 3
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: PPUSH
86380: CALL_OW 69
86384: IN
86385: PUSH
86386: LD_EXP 111
86390: PUSH
86391: LD_VAR 0 1
86395: ARRAY
86396: PUSH
86397: LD_VAR 0 2
86401: ARRAY
86402: PUSH
86403: LD_INT 1
86405: ARRAY
86406: PPUSH
86407: LD_EXP 111
86411: PUSH
86412: LD_VAR 0 1
86416: ARRAY
86417: PUSH
86418: LD_VAR 0 2
86422: ARRAY
86423: PUSH
86424: LD_INT 2
86426: ARRAY
86427: PPUSH
86428: CALL_OW 458
86432: AND
86433: IFFALSE 86527
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
86435: LD_EXP 111
86439: PUSH
86440: LD_VAR 0 1
86444: ARRAY
86445: PUSH
86446: LD_VAR 0 2
86450: ARRAY
86451: PUSH
86452: LD_INT 1
86454: ARRAY
86455: PPUSH
86456: LD_EXP 111
86460: PUSH
86461: LD_VAR 0 1
86465: ARRAY
86466: PUSH
86467: LD_VAR 0 2
86471: ARRAY
86472: PUSH
86473: LD_INT 2
86475: ARRAY
86476: PPUSH
86477: LD_VAR 0 3
86481: PPUSH
86482: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
86486: LD_ADDR_EXP 111
86490: PUSH
86491: LD_EXP 111
86495: PPUSH
86496: LD_VAR 0 1
86500: PPUSH
86501: LD_EXP 111
86505: PUSH
86506: LD_VAR 0 1
86510: ARRAY
86511: PPUSH
86512: LD_VAR 0 2
86516: PPUSH
86517: CALL_OW 3
86521: PPUSH
86522: CALL_OW 1
86526: ST_TO_ADDR
// end ; end ;
86527: GO 86278
86529: POP
86530: POP
// end ;
86531: GO 86196
86533: POP
86534: POP
// end ;
86535: PPOPN 4
86537: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
86538: LD_INT 0
86540: PPUSH
86541: PPUSH
// result := false ;
86542: LD_ADDR_VAR 0 4
86546: PUSH
86547: LD_INT 0
86549: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
86550: LD_VAR 0 1
86554: PPUSH
86555: CALL_OW 264
86559: PUSH
86560: LD_EXP 92
86564: EQUAL
86565: NOT
86566: IFFALSE 86570
// exit ;
86568: GO 86810
// index := GetElementIndex ( minersList , unit ) ;
86570: LD_ADDR_VAR 0 5
86574: PUSH
86575: LD_EXP 110
86579: PPUSH
86580: LD_VAR 0 1
86584: PPUSH
86585: CALL 14117 0 2
86589: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
86590: LD_EXP 111
86594: PUSH
86595: LD_VAR 0 5
86599: ARRAY
86600: PUSH
86601: LD_EXP 112
86605: GREATEREQUAL
86606: IFFALSE 86610
// exit ;
86608: GO 86810
// ComMoveXY ( unit , x , y ) ;
86610: LD_VAR 0 1
86614: PPUSH
86615: LD_VAR 0 2
86619: PPUSH
86620: LD_VAR 0 3
86624: PPUSH
86625: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
86629: LD_INT 35
86631: PPUSH
86632: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
86636: LD_VAR 0 1
86640: PPUSH
86641: LD_VAR 0 2
86645: PPUSH
86646: LD_VAR 0 3
86650: PPUSH
86651: CALL 44181 0 3
86655: NOT
86656: PUSH
86657: LD_VAR 0 1
86661: PPUSH
86662: CALL_OW 314
86666: AND
86667: IFFALSE 86671
// exit ;
86669: GO 86810
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
86671: LD_VAR 0 2
86675: PPUSH
86676: LD_VAR 0 3
86680: PPUSH
86681: CALL_OW 428
86685: PUSH
86686: LD_VAR 0 1
86690: EQUAL
86691: PUSH
86692: LD_VAR 0 1
86696: PPUSH
86697: CALL_OW 314
86701: NOT
86702: AND
86703: IFFALSE 86629
// PlaySoundXY ( x , y , PlantMine ) ;
86705: LD_VAR 0 2
86709: PPUSH
86710: LD_VAR 0 3
86714: PPUSH
86715: LD_STRING PlantMine
86717: PPUSH
86718: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
86722: LD_VAR 0 2
86726: PPUSH
86727: LD_VAR 0 3
86731: PPUSH
86732: LD_VAR 0 1
86736: PPUSH
86737: CALL_OW 255
86741: PPUSH
86742: LD_INT 0
86744: PPUSH
86745: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
86749: LD_ADDR_EXP 111
86753: PUSH
86754: LD_EXP 111
86758: PPUSH
86759: LD_VAR 0 5
86763: PUSH
86764: LD_EXP 111
86768: PUSH
86769: LD_VAR 0 5
86773: ARRAY
86774: PUSH
86775: LD_INT 1
86777: PLUS
86778: PUSH
86779: EMPTY
86780: LIST
86781: LIST
86782: PPUSH
86783: LD_VAR 0 2
86787: PUSH
86788: LD_VAR 0 3
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PPUSH
86797: CALL 14332 0 3
86801: ST_TO_ADDR
// result := true ;
86802: LD_ADDR_VAR 0 4
86806: PUSH
86807: LD_INT 1
86809: ST_TO_ADDR
// end ;
86810: LD_VAR 0 4
86814: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
86815: LD_INT 0
86817: PPUSH
86818: PPUSH
86819: PPUSH
// if not unit in minersList then
86820: LD_VAR 0 1
86824: PUSH
86825: LD_EXP 110
86829: IN
86830: NOT
86831: IFFALSE 86835
// exit ;
86833: GO 87227
// index := GetElementIndex ( minersList , unit ) ;
86835: LD_ADDR_VAR 0 6
86839: PUSH
86840: LD_EXP 110
86844: PPUSH
86845: LD_VAR 0 1
86849: PPUSH
86850: CALL 14117 0 2
86854: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
86855: LD_ADDR_VAR 0 5
86859: PUSH
86860: DOUBLE
86861: LD_EXP 111
86865: PUSH
86866: LD_VAR 0 6
86870: ARRAY
86871: INC
86872: ST_TO_ADDR
86873: LD_INT 1
86875: PUSH
86876: FOR_DOWNTO
86877: IFFALSE 87038
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
86879: LD_EXP 111
86883: PUSH
86884: LD_VAR 0 6
86888: ARRAY
86889: PUSH
86890: LD_VAR 0 5
86894: ARRAY
86895: PUSH
86896: LD_INT 1
86898: ARRAY
86899: PUSH
86900: LD_VAR 0 2
86904: EQUAL
86905: PUSH
86906: LD_EXP 111
86910: PUSH
86911: LD_VAR 0 6
86915: ARRAY
86916: PUSH
86917: LD_VAR 0 5
86921: ARRAY
86922: PUSH
86923: LD_INT 2
86925: ARRAY
86926: PUSH
86927: LD_VAR 0 3
86931: EQUAL
86932: AND
86933: IFFALSE 87036
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
86935: LD_EXP 111
86939: PUSH
86940: LD_VAR 0 6
86944: ARRAY
86945: PUSH
86946: LD_VAR 0 5
86950: ARRAY
86951: PUSH
86952: LD_INT 1
86954: ARRAY
86955: PPUSH
86956: LD_EXP 111
86960: PUSH
86961: LD_VAR 0 6
86965: ARRAY
86966: PUSH
86967: LD_VAR 0 5
86971: ARRAY
86972: PUSH
86973: LD_INT 2
86975: ARRAY
86976: PPUSH
86977: LD_VAR 0 1
86981: PPUSH
86982: CALL_OW 255
86986: PPUSH
86987: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
86991: LD_ADDR_EXP 111
86995: PUSH
86996: LD_EXP 111
87000: PPUSH
87001: LD_VAR 0 6
87005: PPUSH
87006: LD_EXP 111
87010: PUSH
87011: LD_VAR 0 6
87015: ARRAY
87016: PPUSH
87017: LD_VAR 0 5
87021: PPUSH
87022: CALL_OW 3
87026: PPUSH
87027: CALL_OW 1
87031: ST_TO_ADDR
// exit ;
87032: POP
87033: POP
87034: GO 87227
// end ; end ;
87036: GO 86876
87038: POP
87039: POP
// for i := minerMinesList [ index ] downto 1 do
87040: LD_ADDR_VAR 0 5
87044: PUSH
87045: DOUBLE
87046: LD_EXP 111
87050: PUSH
87051: LD_VAR 0 6
87055: ARRAY
87056: INC
87057: ST_TO_ADDR
87058: LD_INT 1
87060: PUSH
87061: FOR_DOWNTO
87062: IFFALSE 87225
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
87064: LD_EXP 111
87068: PUSH
87069: LD_VAR 0 6
87073: ARRAY
87074: PUSH
87075: LD_VAR 0 5
87079: ARRAY
87080: PUSH
87081: LD_INT 1
87083: ARRAY
87084: PPUSH
87085: LD_EXP 111
87089: PUSH
87090: LD_VAR 0 6
87094: ARRAY
87095: PUSH
87096: LD_VAR 0 5
87100: ARRAY
87101: PUSH
87102: LD_INT 2
87104: ARRAY
87105: PPUSH
87106: LD_VAR 0 2
87110: PPUSH
87111: LD_VAR 0 3
87115: PPUSH
87116: CALL_OW 298
87120: PUSH
87121: LD_INT 6
87123: LESS
87124: IFFALSE 87223
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87126: LD_EXP 111
87130: PUSH
87131: LD_VAR 0 6
87135: ARRAY
87136: PUSH
87137: LD_VAR 0 5
87141: ARRAY
87142: PUSH
87143: LD_INT 1
87145: ARRAY
87146: PPUSH
87147: LD_EXP 111
87151: PUSH
87152: LD_VAR 0 6
87156: ARRAY
87157: PUSH
87158: LD_VAR 0 5
87162: ARRAY
87163: PUSH
87164: LD_INT 2
87166: ARRAY
87167: PPUSH
87168: LD_VAR 0 1
87172: PPUSH
87173: CALL_OW 255
87177: PPUSH
87178: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87182: LD_ADDR_EXP 111
87186: PUSH
87187: LD_EXP 111
87191: PPUSH
87192: LD_VAR 0 6
87196: PPUSH
87197: LD_EXP 111
87201: PUSH
87202: LD_VAR 0 6
87206: ARRAY
87207: PPUSH
87208: LD_VAR 0 5
87212: PPUSH
87213: CALL_OW 3
87217: PPUSH
87218: CALL_OW 1
87222: ST_TO_ADDR
// end ; end ;
87223: GO 87061
87225: POP
87226: POP
// end ;
87227: LD_VAR 0 4
87231: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
87232: LD_INT 0
87234: PPUSH
87235: PPUSH
87236: PPUSH
87237: PPUSH
87238: PPUSH
87239: PPUSH
87240: PPUSH
87241: PPUSH
87242: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
87243: LD_VAR 0 1
87247: PPUSH
87248: CALL_OW 264
87252: PUSH
87253: LD_EXP 92
87257: EQUAL
87258: NOT
87259: PUSH
87260: LD_VAR 0 1
87264: PUSH
87265: LD_EXP 110
87269: IN
87270: NOT
87271: OR
87272: IFFALSE 87276
// exit ;
87274: GO 87598
// index := GetElementIndex ( minersList , unit ) ;
87276: LD_ADDR_VAR 0 6
87280: PUSH
87281: LD_EXP 110
87285: PPUSH
87286: LD_VAR 0 1
87290: PPUSH
87291: CALL 14117 0 2
87295: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
87296: LD_ADDR_VAR 0 8
87300: PUSH
87301: LD_EXP 112
87305: PUSH
87306: LD_EXP 111
87310: PUSH
87311: LD_VAR 0 6
87315: ARRAY
87316: MINUS
87317: ST_TO_ADDR
// if not minesFreeAmount then
87318: LD_VAR 0 8
87322: NOT
87323: IFFALSE 87327
// exit ;
87325: GO 87598
// tmp := [ ] ;
87327: LD_ADDR_VAR 0 7
87331: PUSH
87332: EMPTY
87333: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
87334: LD_ADDR_VAR 0 5
87338: PUSH
87339: DOUBLE
87340: LD_INT 1
87342: DEC
87343: ST_TO_ADDR
87344: LD_VAR 0 8
87348: PUSH
87349: FOR_TO
87350: IFFALSE 87545
// begin _d := rand ( 0 , 5 ) ;
87352: LD_ADDR_VAR 0 11
87356: PUSH
87357: LD_INT 0
87359: PPUSH
87360: LD_INT 5
87362: PPUSH
87363: CALL_OW 12
87367: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
87368: LD_ADDR_VAR 0 12
87372: PUSH
87373: LD_INT 2
87375: PPUSH
87376: LD_INT 6
87378: PPUSH
87379: CALL_OW 12
87383: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
87384: LD_ADDR_VAR 0 9
87388: PUSH
87389: LD_VAR 0 2
87393: PPUSH
87394: LD_VAR 0 11
87398: PPUSH
87399: LD_VAR 0 12
87403: PPUSH
87404: CALL_OW 272
87408: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
87409: LD_ADDR_VAR 0 10
87413: PUSH
87414: LD_VAR 0 3
87418: PPUSH
87419: LD_VAR 0 11
87423: PPUSH
87424: LD_VAR 0 12
87428: PPUSH
87429: CALL_OW 273
87433: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
87434: LD_VAR 0 9
87438: PPUSH
87439: LD_VAR 0 10
87443: PPUSH
87444: CALL_OW 488
87448: PUSH
87449: LD_VAR 0 9
87453: PUSH
87454: LD_VAR 0 10
87458: PUSH
87459: EMPTY
87460: LIST
87461: LIST
87462: PUSH
87463: LD_VAR 0 7
87467: IN
87468: NOT
87469: AND
87470: PUSH
87471: LD_VAR 0 9
87475: PPUSH
87476: LD_VAR 0 10
87480: PPUSH
87481: CALL_OW 458
87485: NOT
87486: AND
87487: IFFALSE 87529
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
87489: LD_ADDR_VAR 0 7
87493: PUSH
87494: LD_VAR 0 7
87498: PPUSH
87499: LD_VAR 0 7
87503: PUSH
87504: LD_INT 1
87506: PLUS
87507: PPUSH
87508: LD_VAR 0 9
87512: PUSH
87513: LD_VAR 0 10
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PPUSH
87522: CALL_OW 1
87526: ST_TO_ADDR
87527: GO 87543
// i := i - 1 ;
87529: LD_ADDR_VAR 0 5
87533: PUSH
87534: LD_VAR 0 5
87538: PUSH
87539: LD_INT 1
87541: MINUS
87542: ST_TO_ADDR
// end ;
87543: GO 87349
87545: POP
87546: POP
// for i in tmp do
87547: LD_ADDR_VAR 0 5
87551: PUSH
87552: LD_VAR 0 7
87556: PUSH
87557: FOR_IN
87558: IFFALSE 87596
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
87560: LD_VAR 0 1
87564: PPUSH
87565: LD_VAR 0 5
87569: PUSH
87570: LD_INT 1
87572: ARRAY
87573: PPUSH
87574: LD_VAR 0 5
87578: PUSH
87579: LD_INT 2
87581: ARRAY
87582: PPUSH
87583: CALL 86538 0 3
87587: NOT
87588: IFFALSE 87594
// exit ;
87590: POP
87591: POP
87592: GO 87598
87594: GO 87557
87596: POP
87597: POP
// end ;
87598: LD_VAR 0 4
87602: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
87603: LD_INT 0
87605: PPUSH
87606: PPUSH
87607: PPUSH
87608: PPUSH
87609: PPUSH
87610: PPUSH
87611: PPUSH
// if not GetClass ( unit ) = class_sniper then
87612: LD_VAR 0 1
87616: PPUSH
87617: CALL_OW 257
87621: PUSH
87622: LD_INT 5
87624: EQUAL
87625: NOT
87626: IFFALSE 87630
// exit ;
87628: GO 88018
// dist := 8 ;
87630: LD_ADDR_VAR 0 5
87634: PUSH
87635: LD_INT 8
87637: ST_TO_ADDR
// viewRange := 12 ;
87638: LD_ADDR_VAR 0 7
87642: PUSH
87643: LD_INT 12
87645: ST_TO_ADDR
// side := GetSide ( unit ) ;
87646: LD_ADDR_VAR 0 6
87650: PUSH
87651: LD_VAR 0 1
87655: PPUSH
87656: CALL_OW 255
87660: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
87661: LD_INT 61
87663: PPUSH
87664: LD_VAR 0 6
87668: PPUSH
87669: CALL_OW 321
87673: PUSH
87674: LD_INT 2
87676: EQUAL
87677: IFFALSE 87687
// viewRange := 16 ;
87679: LD_ADDR_VAR 0 7
87683: PUSH
87684: LD_INT 16
87686: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
87687: LD_VAR 0 1
87691: PPUSH
87692: LD_VAR 0 2
87696: PPUSH
87697: LD_VAR 0 3
87701: PPUSH
87702: CALL_OW 297
87706: PUSH
87707: LD_VAR 0 5
87711: GREATER
87712: IFFALSE 87791
// begin ComMoveXY ( unit , x , y ) ;
87714: LD_VAR 0 1
87718: PPUSH
87719: LD_VAR 0 2
87723: PPUSH
87724: LD_VAR 0 3
87728: PPUSH
87729: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
87733: LD_INT 35
87735: PPUSH
87736: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
87740: LD_VAR 0 1
87744: PPUSH
87745: LD_VAR 0 2
87749: PPUSH
87750: LD_VAR 0 3
87754: PPUSH
87755: CALL 44181 0 3
87759: NOT
87760: IFFALSE 87764
// exit ;
87762: GO 88018
// until GetDistUnitXY ( unit , x , y ) < dist ;
87764: LD_VAR 0 1
87768: PPUSH
87769: LD_VAR 0 2
87773: PPUSH
87774: LD_VAR 0 3
87778: PPUSH
87779: CALL_OW 297
87783: PUSH
87784: LD_VAR 0 5
87788: LESS
87789: IFFALSE 87733
// end ; ComTurnXY ( unit , x , y ) ;
87791: LD_VAR 0 1
87795: PPUSH
87796: LD_VAR 0 2
87800: PPUSH
87801: LD_VAR 0 3
87805: PPUSH
87806: CALL_OW 118
// wait ( 5 ) ;
87810: LD_INT 5
87812: PPUSH
87813: CALL_OW 67
// _d := GetDir ( unit ) ;
87817: LD_ADDR_VAR 0 10
87821: PUSH
87822: LD_VAR 0 1
87826: PPUSH
87827: CALL_OW 254
87831: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
87832: LD_ADDR_VAR 0 8
87836: PUSH
87837: LD_VAR 0 1
87841: PPUSH
87842: CALL_OW 250
87846: PPUSH
87847: LD_VAR 0 10
87851: PPUSH
87852: LD_VAR 0 5
87856: PPUSH
87857: CALL_OW 272
87861: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
87862: LD_ADDR_VAR 0 9
87866: PUSH
87867: LD_VAR 0 1
87871: PPUSH
87872: CALL_OW 251
87876: PPUSH
87877: LD_VAR 0 10
87881: PPUSH
87882: LD_VAR 0 5
87886: PPUSH
87887: CALL_OW 273
87891: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
87892: LD_VAR 0 8
87896: PPUSH
87897: LD_VAR 0 9
87901: PPUSH
87902: CALL_OW 488
87906: NOT
87907: IFFALSE 87911
// exit ;
87909: GO 88018
// ComAnimCustom ( unit , 1 ) ;
87911: LD_VAR 0 1
87915: PPUSH
87916: LD_INT 1
87918: PPUSH
87919: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
87923: LD_VAR 0 8
87927: PPUSH
87928: LD_VAR 0 9
87932: PPUSH
87933: LD_VAR 0 6
87937: PPUSH
87938: LD_VAR 0 7
87942: PPUSH
87943: CALL_OW 330
// repeat wait ( 1 ) ;
87947: LD_INT 1
87949: PPUSH
87950: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
87954: LD_VAR 0 1
87958: PPUSH
87959: CALL_OW 316
87963: PUSH
87964: LD_VAR 0 1
87968: PPUSH
87969: CALL_OW 314
87973: OR
87974: PUSH
87975: LD_VAR 0 1
87979: PPUSH
87980: CALL_OW 302
87984: NOT
87985: OR
87986: PUSH
87987: LD_VAR 0 1
87991: PPUSH
87992: CALL_OW 301
87996: OR
87997: IFFALSE 87947
// RemoveSeeing ( _x , _y , side ) ;
87999: LD_VAR 0 8
88003: PPUSH
88004: LD_VAR 0 9
88008: PPUSH
88009: LD_VAR 0 6
88013: PPUSH
88014: CALL_OW 331
// end ; end_of_file
88018: LD_VAR 0 4
88022: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
88023: LD_VAR 0 1
88027: PUSH
88028: LD_INT 200
88030: DOUBLE
88031: GREATEREQUAL
88032: IFFALSE 88040
88034: LD_INT 299
88036: DOUBLE
88037: LESSEQUAL
88038: IFTRUE 88042
88040: GO 88074
88042: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; end ;
88043: LD_VAR 0 1
88047: PPUSH
88048: LD_VAR 0 2
88052: PPUSH
88053: LD_VAR 0 3
88057: PPUSH
88058: LD_VAR 0 4
88062: PPUSH
88063: LD_VAR 0 5
88067: PPUSH
88068: CALL 84140 0 5
88072: GO 88075
88074: POP
// end ;
88075: PPOPN 11
88077: END
