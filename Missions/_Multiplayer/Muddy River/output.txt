// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 350 0 0
// InitMultiplayer ;
  20: CALL 611 0 0
// InitMacro ;
  24: CALL 51272 0 0
// if debug then
  28: LD_EXP 1
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: CALL_OW 344
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: CALL 44008 0 9
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: CALL 1893 0 1
  79: PPUSH
  80: CALL 5848 0 1
// Multiplayer_Start ;
  84: CALL 3757 0 0
// MC_Start ( ) ;
  88: CALL 53452 0 0
// Multiplayer_End ;
  92: CALL 3881 0 0
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: LD_OWVAR 67
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: CALL 75190 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: LD_OWVAR 67
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: CALL 75190 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: LD_OWVAR 67
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: CALL 75190 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: LD_OWVAR 67
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: CALL 75190 0 3
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: LD_OWVAR 67
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: CALL 75190 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: LD_ADDR_EXP 67
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: LD_ADDR_EXP 68
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: LD_VAR 0 2
 325: PPUSH
 326: LD_EXP 38
 330: PUSH
 331: LD_VAR 0 2
 335: ARRAY
 336: PPUSH
 337: CALL 75616 0 2
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := false ;
 353: LD_ADDR_EXP 1
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: LD_ADDR_EXP 3
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: LD_ADDR_EXP 4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: LD_ADDR_EXP 5
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: LD_EXP 2
 489: PUSH
 490: LD_OWVAR 48
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: CALL 4582 0 0
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: LD_EXP 1
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: LD_ADDR_VAR 0 2
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: CALL_OW 44
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: CALL_OW 49
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: LD_ADDR_EXP 18
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: LD_OWVAR 4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: LD_OWVAR 7
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: LD_ADDR_EXP 6
 646: PUSH
 647: LD_OWVAR 6
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: LD_ADDR_EXP 7
 656: PUSH
 657: LD_OWVAR 17
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: LD_ADDR_EXP 8
 666: PUSH
 667: LD_OWVAR 15
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: LD_ADDR_EXP 9
 676: PUSH
 677: LD_OWVAR 16
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: LD_ADDR_EXP 10
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: LD_OWVAR 12
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: LD_ADDR_EXP 10
 706: PUSH
 707: LD_EXP 10
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: LD_EXP 10
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: LD_VAR 0 2
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: CALL 14988 0 3
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: LD_ADDR_VAR 0 2
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: LD_EXP 18
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: LD_ADDR_EXP 17
 772: PUSH
 773: LD_EXP 17
 777: PPUSH
 778: LD_EXP 17
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: LD_VAR 0 2
 791: PPUSH
 792: CALL_OW 426
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: CALL_OW 2
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: LD_ADDR_EXP 6
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: LD_ADDR_EXP 7
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: LD_ADDR_EXP 8
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: LD_ADDR_EXP 9
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: LD_ADDR_EXP 10
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: LD_ADDR_EXP 17
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: LD_ADDR_EXP 11
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: LD_ADDR_EXP 14
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: LD_ADDR_EXP 25
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: LD_ADDR_EXP 15
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: LD_ADDR_EXP 13
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: LD_ADDR_EXP 16
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: LD_ADDR_EXP 24
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: LD_ADDR_EXP 27
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: LD_ADDR_EXP 26
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: LD_ADDR_EXP 12
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: LD_ADDR_VAR 0 2
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: LD_VAR 0 2
1232: PPUSH
1233: CALL_OW 530
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: LD_ADDR_EXP 11
1243: PUSH
1244: LD_EXP 11
1248: PPUSH
1249: LD_VAR 0 2
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: CALL_OW 1
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: LD_ADDR_EXP 9
1266: PUSH
1267: LD_EXP 9
1271: PPUSH
1272: LD_VAR 0 2
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: CALL_OW 1
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: LD_ADDR_EXP 7
1289: PUSH
1290: LD_EXP 7
1294: PPUSH
1295: LD_VAR 0 2
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: CALL_OW 1
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: LD_ADDR_VAR 0 3
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: LD_EXP 10
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: LD_VAR 0 2
1330: PUSH
1331: LD_EXP 10
1335: PUSH
1336: LD_VAR 0 3
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: LD_ADDR_VAR 0 5
1348: PUSH
1349: LD_EXP 10
1353: PUSH
1354: LD_VAR 0 3
1358: ARRAY
1359: PUSH
1360: LD_VAR 0 2
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: LD_ADDR_EXP 10
1370: PUSH
1371: LD_EXP 10
1375: PPUSH
1376: LD_VAR 0 3
1380: PPUSH
1381: LD_VAR 0 5
1385: PPUSH
1386: CALL_OW 1
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: LD_EXP 9
1399: PUSH
1400: LD_VAR 0 2
1404: ARRAY
1405: PUSH
1406: LD_EXP 9
1410: PUSH
1411: LD_VAR 0 2
1415: ARRAY
1416: PUSH
1417: LD_EXP 13
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: LD_ADDR_EXP 9
1430: PUSH
1431: LD_EXP 9
1435: PPUSH
1436: LD_VAR 0 2
1440: PPUSH
1441: LD_EXP 13
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: LD_EXP 13
1453: PPUSH
1454: CALL_OW 12
1458: ARRAY
1459: PPUSH
1460: CALL_OW 1
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: LD_EXP 9
1469: PUSH
1470: LD_VAR 0 2
1474: ARRAY
1475: NOT
1476: PUSH
1477: LD_EXP 7
1481: PUSH
1482: LD_VAR 0 2
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: LD_EXP 11
1494: PUSH
1495: LD_VAR 0 2
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: LD_ADDR_EXP 14
1508: PUSH
1509: LD_EXP 14
1513: PPUSH
1514: LD_VAR 0 2
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: CALL_OW 1
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: LD_EXP 7
1531: PUSH
1532: LD_VAR 0 2
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: LD_ADDR_EXP 26
1543: PUSH
1544: LD_EXP 26
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: LD_ADDR_VAR 0 2
1561: PUSH
1562: LD_EXP 10
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: LD_ADDR_VAR 0 3
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: LD_VAR 0 2
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: LD_VAR 0 2
1592: PUSH
1593: LD_VAR 0 3
1597: ARRAY
1598: PPUSH
1599: LD_VAR 0 2
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: CALL_OW 343
// for x = 1 to j - 1 do
1612: LD_ADDR_VAR 0 4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: LD_VAR 0 3
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: LD_VAR 0 2
1638: PUSH
1639: LD_VAR 0 3
1643: ARRAY
1644: PPUSH
1645: LD_VAR 0 2
1649: PUSH
1650: LD_VAR 0 4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: CALL_OW 80
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_EXP 17
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: LD_EXP 17
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: LD_ADDR_EXP 20
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_EXP 17
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: LD_ADDR_EXP 21
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: LD_EXP 17
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: LD_ADDR_EXP 22
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: LD_EXP 17
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: LD_ADDR_EXP 23
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: LD_EXP 17
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: LD_VAR 0 1
1901: PUSH
1902: LD_EXP 7
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: LD_ADDR_VAR 0 2
1914: PUSH
1915: LD_VAR 0 1
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: LD_ADDR_VAR 0 3
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: LD_EXP 7
1942: PUSH
1943: LD_VAR 0 3
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: LD_ADDR_VAR 0 2
1955: PUSH
1956: LD_VAR 0 3
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: LD_VAR 0 1
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: LD_VAR 0 2
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: LD_ADDR_VAR 0 3
2095: PUSH
2096: CALL_OW 44
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: LD_VAR 0 2
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: LD_ADDR_VAR 0 3
2185: PUSH
2186: CALL_OW 44
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: LD_VAR 0 2
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: LD_ADDR_VAR 0 3
2275: PUSH
2276: CALL_OW 44
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: LD_ADDR_VAR 0 2
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: LD_EXP 7
2317: PUSH
2318: LD_VAR 0 2
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: LD_EXP 16
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 2
2343: PPUSH
2344: LD_EXP 7
2348: PUSH
2349: LD_VAR 0 2
2353: ARRAY
2354: PPUSH
2355: CALL 1974 0 2
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: LD_ADDR_EXP 24
2364: PUSH
2365: LD_EXP 24
2369: PPUSH
2370: LD_EXP 24
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: LD_VAR 0 5
2383: PPUSH
2384: CALL_OW 2
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: LD_VAR 0 5
2393: PPUSH
2394: LD_EXP 12
2398: PUSH
2399: LD_EXP 7
2403: PUSH
2404: LD_VAR 0 2
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: CALL_OW 49
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: LD_VAR 0 2
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: LD_EXP 9
2443: PUSH
2444: LD_VAR 0 2
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: LD_EXP 20
2468: PPUSH
2469: CALL_OW 380
// if multiplayer then
2473: LD_OWVAR 4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: LD_OWVAR 19
2488: PUSH
2489: LD_VAR 0 2
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: LD_VAR 0 2
2512: PPUSH
2513: CALL_OW 525
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: LD_VAR 0 2
2527: PPUSH
2528: CALL_OW 526
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: CALL_OW 12
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: LD_ADDR_VAR 0 5
2571: PUSH
2572: CALL_OW 44
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: LD_VAR 0 5
2581: PPUSH
2582: LD_EXP 12
2586: PUSH
2587: LD_EXP 7
2591: PUSH
2592: LD_VAR 0 2
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: LD_ADDR_EXP 24
2614: PUSH
2615: LD_EXP 24
2619: PPUSH
2620: LD_VAR 0 2
2624: PPUSH
2625: LD_VAR 0 5
2629: PPUSH
2630: CALL_OW 1
2634: ST_TO_ADDR
// end ; InitHc ;
2635: CALL_OW 19
// InitUc ;
2639: CALL_OW 18
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: LD_VAR 0 2
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: LD_EXP 9
2662: PUSH
2663: LD_VAR 0 2
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: LD_ADDR_VAR 0 4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: LD_ADDR_VAR 0 3
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: LD_EXP 19
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: LD_VAR 0 3
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: LD_EXP 19
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: LD_ADDR_VAR 0 4
2751: PUSH
2752: LD_VAR 0 4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: LD_VAR 0 4
2768: PPUSH
2769: LD_EXP 20
2773: PPUSH
2774: CALL_OW 380
// un := CreateHuman ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: CALL_OW 44
2787: ST_TO_ADDR
// if j > copy then
2788: LD_VAR 0 3
2792: PUSH
2793: LD_VAR 0 8
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: LD_ADDR_VAR 0 8
2804: PUSH
2805: LD_VAR 0 8
2809: PPUSH
2810: LD_VAR 0 3
2814: PPUSH
2815: LD_VAR 0 5
2819: PPUSH
2820: CALL_OW 1
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: LD_VAR 0 8
2831: PUSH
2832: LD_VAR 0 3
2836: ARRAY
2837: PPUSH
2838: LD_VAR 0 5
2842: PPUSH
2843: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: LD_VAR 0 5
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: LD_VAR 0 8
2859: PUSH
2860: LD_VAR 0 3
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: CALL_OW 260
2873: PPUSH
2874: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: LD_VAR 0 5
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: LD_VAR 0 8
2890: PUSH
2891: LD_VAR 0 3
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: CALL_OW 260
2904: PPUSH
2905: CALL_OW 239
// end ; if multi_pos_area then
2909: LD_EXP 12
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: LD_VAR 0 5
2919: PPUSH
2920: CALL_OW 257
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: LD_VAR 0 3
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: LD_VAR 0 3
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: CALL 14866 0 5
// veh := CreateVehicle ;
2995: LD_ADDR_VAR 0 6
2999: PUSH
3000: CALL_OW 45
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: LD_VAR 0 6
3009: PPUSH
3010: LD_EXP 12
3014: PUSH
3015: LD_EXP 7
3019: PUSH
3020: LD_VAR 0 2
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3038: LD_VAR 0 5
3042: PPUSH
3043: LD_VAR 0 6
3047: PPUSH
3048: CALL_OW 52
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: LD_VAR 0 5
3058: PPUSH
3059: LD_EXP 12
3063: PUSH
3064: LD_EXP 7
3068: PUSH
3069: LD_VAR 0 2
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: CALL_OW 49
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: LD_ADDR_VAR 0 3
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: CALL_OW 12
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: LD_VAR 0 3
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: CALL 14866 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: CALL_OW 45
3166: PPUSH
3167: LD_EXP 12
3171: PUSH
3172: LD_EXP 7
3176: PUSH
3177: LD_VAR 0 2
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: CALL_OW 49
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: LD_EXP 23
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: LD_ADDR_VAR 0 1
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: LD_ADDR_VAR 0 2
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: LD_EXP 7
3251: PUSH
3252: LD_VAR 0 2
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: LD_ADDR_VAR 0 5
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: LD_EXP 23
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: LD_VAR 0 2
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: LD_EXP 9
3295: PUSH
3296: LD_VAR 0 2
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3321: LD_ADDR_VAR 0 5
3325: PUSH
3326: LD_VAR 0 5
3330: PUSH
3331: CALL_OW 45
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3356: LD_ADDR_VAR 0 5
3360: PUSH
3361: LD_VAR 0 5
3365: PUSH
3366: CALL_OW 45
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3391: LD_ADDR_VAR 0 5
3395: PUSH
3396: LD_VAR 0 5
3400: PUSH
3401: CALL_OW 45
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3426: LD_ADDR_VAR 0 5
3430: PUSH
3431: LD_VAR 0 5
3435: PUSH
3436: CALL_OW 45
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: LD_EXP 23
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: LD_VAR 0 2
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: LD_EXP 9
3471: PUSH
3472: LD_VAR 0 2
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3497: LD_ADDR_VAR 0 5
3501: PUSH
3502: LD_VAR 0 5
3506: PUSH
3507: CALL_OW 45
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3532: LD_ADDR_VAR 0 5
3536: PUSH
3537: LD_VAR 0 5
3541: PUSH
3542: CALL_OW 45
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3567: LD_ADDR_VAR 0 5
3571: PUSH
3572: LD_VAR 0 5
3576: PUSH
3577: CALL_OW 45
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3602: LD_ADDR_VAR 0 5
3606: PUSH
3607: LD_VAR 0 5
3611: PUSH
3612: CALL_OW 45
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3637: LD_ADDR_VAR 0 5
3641: PUSH
3642: LD_VAR 0 5
3646: PUSH
3647: CALL_OW 45
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3672: LD_ADDR_VAR 0 5
3676: PUSH
3677: LD_VAR 0 5
3681: PUSH
3682: CALL_OW 45
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: CALL 14866 0 5
// tmp := tmp ^ CreateVehicle ;
3707: LD_ADDR_VAR 0 5
3711: PUSH
3712: LD_VAR 0 5
3716: PUSH
3717: CALL_OW 45
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: LD_ADDR_VAR 0 1
3727: PUSH
3728: LD_VAR 0 1
3732: PPUSH
3733: LD_VAR 0 2
3737: PPUSH
3738: LD_VAR 0 5
3742: PPUSH
3743: CALL_OW 2
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: CALL 2286 0 0
// Multiplayer_InitPointSystem ( ) ;
3764: CALL 4681 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: CALL 4857 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: CALL 4857 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: CALL 4857 0 1
// Multiplayer_SpawnArtifact ;
3811: CALL 5297 0 0
// if multi_support then
3815: LD_EXP 23
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: LD_ADDR_EXP 27
3825: PUSH
3826: CALL 3208 0 0
3830: ST_TO_ADDR
// game := true ;
3831: LD_ADDR_EXP 2
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: LD_EXP 7
3843: PUSH
3844: LD_OWVAR 2
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: LD_OWVAR 2
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: CALL_OW 69
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: CALL_OW 87
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: LD_ADDR_VAR 0 5
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: LD_OWVAR 1
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: LD_EXP 28
3916: NOT
3917: AND
3918: PUSH
3919: LD_EXP 23
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: LD_ADDR_EXP 28
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: LD_ADDR_VAR 0 2
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: LD_EXP 7
3958: PUSH
3959: LD_VAR 0 2
3963: ARRAY
3964: PUSH
3965: LD_EXP 25
3969: PUSH
3970: LD_VAR 0 2
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: LD_EXP 27
3982: PUSH
3983: LD_VAR 0 2
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: LD_EXP 27
4000: PUSH
4001: LD_VAR 0 2
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: LD_ADDR_VAR 0 3
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: LD_VAR 0 4
4027: PUSH
4028: LD_VAR 0 3
4032: ARRAY
4033: PPUSH
4034: LD_EXP 12
4038: PUSH
4039: LD_EXP 7
4043: PUSH
4044: LD_VAR 0 2
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4062: LD_ADDR_VAR 0 4
4066: PUSH
4067: LD_VAR 0 4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: CALL_OW 3
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: LD_ADDR_EXP 27
4088: PUSH
4089: LD_EXP 27
4093: PPUSH
4094: LD_VAR 0 2
4098: PPUSH
4099: LD_VAR 0 4
4103: PPUSH
4104: CALL_OW 1
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: LD_ADDR_VAR 0 5
4117: PUSH
4118: LD_OWVAR 1
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: LD_VAR 0 5
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: LD_OWVAR 1
4136: LESS
4137: PUSH
4138: LD_EXP 28
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: LD_EXP 23
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: LD_ADDR_EXP 28
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: LD_ADDR_VAR 0 2
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: LD_EXP 7
4187: PUSH
4188: LD_VAR 0 2
4192: ARRAY
4193: PUSH
4194: LD_EXP 25
4198: PUSH
4199: LD_VAR 0 2
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: LD_EXP 27
4211: PUSH
4212: LD_VAR 0 2
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: LD_ADDR_VAR 0 4
4224: PUSH
4225: LD_EXP 27
4229: PUSH
4230: LD_VAR 0 2
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: LD_ADDR_VAR 0 3
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: LD_VAR 0 4
4256: PUSH
4257: LD_VAR 0 3
4261: ARRAY
4262: PPUSH
4263: LD_EXP 12
4267: PUSH
4268: LD_EXP 7
4272: PUSH
4273: LD_VAR 0 2
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4291: LD_ADDR_VAR 0 4
4295: PUSH
4296: LD_VAR 0 4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: CALL_OW 3
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: LD_ADDR_EXP 27
4317: PUSH
4318: LD_EXP 27
4322: PPUSH
4323: LD_VAR 0 2
4327: PPUSH
4328: LD_VAR 0 4
4332: PPUSH
4333: CALL_OW 1
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: LD_EXP 16
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: LD_ADDR_VAR 0 2
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: LD_VAR 0 2
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: CALL_OW 69
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: LD_EXP 25
4390: PUSH
4391: LD_VAR 0 2
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: LD_ADDR_EXP 25
4404: PUSH
4405: LD_EXP 25
4409: PPUSH
4410: LD_VAR 0 2
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: CALL_OW 1
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: LD_VAR 0 2
4427: PPUSH
4428: CALL 4927 0 1
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: LD_EXP 25
4440: PPUSH
4441: CALL 11953 0 1
4445: PUSH
4446: LD_EXP 7
4450: PPUSH
4451: CALL 11953 0 1
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: LD_EXP 3
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: CALL_OW 69
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: LD_EXP 2
4485: AND
4486: PUSH
4487: LD_EXP 24
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: LD_ADDR_EXP 2
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: LD_ADDR_VAR 0 2
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: LD_EXP 7
4523: PUSH
4524: LD_VAR 0 2
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: LD_VAR 0 2
4535: PPUSH
4536: LD_EXP 29
4540: PUSH
4541: LD_VAR 0 2
4545: ARRAY
4546: PPUSH
4547: CALL_OW 506
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: LD_EXP 25
4559: PUSH
4560: LD_OWVAR 2
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: CALL_OW 107
4571: GO 4577
// YouWinInMultiplayer ;
4573: CALL_OW 106
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: LD_ADDR_VAR 0 1
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: LD_OWVAR 1
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: LD_ADDR_VAR 0 2
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: LD_EXP 7
4623: PUSH
4624: LD_VAR 0 2
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: LD_ADDR_VAR 0 1
4635: PUSH
4636: LD_VAR 0 1
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: LD_VAR 0 2
4648: PUSH
4649: LD_VAR 0 2
4653: PUSH
4654: LD_EXP 29
4658: PUSH
4659: LD_VAR 0 2
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: LD_ADDR_EXP 29
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: LD_ADDR_EXP 30
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: LD_EXP 29
4743: NOT
4744: PUSH
4745: LD_VAR 0 1
4749: NOT
4750: OR
4751: PUSH
4752: LD_VAR 0 1
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: LD_ADDR_EXP 29
4769: PUSH
4770: LD_EXP 29
4774: PPUSH
4775: LD_VAR 0 1
4779: PPUSH
4780: LD_EXP 29
4784: PUSH
4785: LD_VAR 0 1
4789: ARRAY
4790: PUSH
4791: LD_VAR 0 2
4795: PLUS
4796: PPUSH
4797: CALL_OW 1
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: LD_EXP 29
4814: NOT
4815: PUSH
4816: LD_VAR 0 1
4820: NOT
4821: OR
4822: PUSH
4823: LD_VAR 0 1
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: LD_ADDR_VAR 0 2
4840: PUSH
4841: LD_EXP 29
4845: PUSH
4846: LD_VAR 0 1
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: LD_ADDR_EXP 30
4864: PUSH
4865: LD_EXP 30
4869: PPUSH
4870: LD_EXP 30
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: LD_VAR 0 1
4883: PPUSH
4884: CALL_OW 2
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: LD_VAR 0 1
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: LD_ADDR_VAR 0 2
4910: PUSH
4911: LD_EXP 30
4915: PUSH
4916: LD_VAR 0 1
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: LD_ADDR_VAR 0 3
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: LD_ADDR_VAR 0 4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: LD_VAR 0 4
4961: PUSH
4962: LD_VAR 0 1
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: LD_EXP 7
4975: PUSH
4976: LD_VAR 0 4
4980: ARRAY
4981: PUSH
4982: LD_EXP 25
4986: PUSH
4987: LD_VAR 0 4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: LD_ADDR_VAR 0 3
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_VAR 0 4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: LD_VAR 0 3
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: LD_VAR 0 3
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: LD_ADDR_VAR 0 4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: LD_VAR 0 1
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: CALL_OW 69
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: LD_VAR 0 4
5074: PPUSH
5075: LD_VAR 0 3
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: CALL_OW 235
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: LD_ADDR_VAR 0 5
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: LD_ADDR_VAR 0 4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: LD_VAR 0 1
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: CALL_OW 69
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: LD_VAR 0 4
5173: PPUSH
5174: LD_VAR 0 3
5178: PUSH
5179: LD_VAR 0 5
5183: ARRAY
5184: PPUSH
5185: CALL_OW 235
// if IsDrivenBy ( i ) then
5189: LD_VAR 0 4
5193: PPUSH
5194: CALL_OW 311
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: LD_VAR 0 4
5204: PPUSH
5205: CALL_OW 311
5209: PPUSH
5210: LD_VAR 0 3
5214: PUSH
5215: LD_VAR 0 5
5219: ARRAY
5220: PPUSH
5221: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: LD_VAR 0 4
5229: PPUSH
5230: CALL_OW 310
5234: PPUSH
5235: CALL_OW 247
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: LD_VAR 0 4
5249: PPUSH
5250: CALL_OW 122
// j := j + 1 ;
5254: LD_ADDR_VAR 0 5
5258: PUSH
5259: LD_VAR 0 5
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: LD_VAR 0 5
5272: PUSH
5273: LD_VAR 0 3
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: LD_ADDR_VAR 0 5
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: LD_ADDR_VAR 0 3
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: LD_ADDR_VAR 0 2
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: LD_VAR 0 3
5365: PPUSH
5366: CALL_OW 12
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: LD_VAR 0 3
5381: PUSH
5382: LD_VAR 0 2
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: LD_VAR 0 3
5396: PUSH
5397: LD_VAR 0 2
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: CALL_OW 58
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: LD_VAR 0 1
5426: NOT
5427: PUSH
5428: LD_VAR 0 1
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: LD_VAR 0 1
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: CALL 4894 0 1
5453: PPUSH
5454: CALL 4736 0 2
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: LD_VAR 0 1
5470: NOT
5471: PUSH
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: LD_VAR 0 1
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: CALL 4894 0 1
5497: PPUSH
5498: CALL 4736 0 2
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: LD_VAR 0 1
5514: NOT
5515: PUSH
5516: LD_VAR 0 1
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: LD_VAR 0 2
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: LD_VAR 0 1
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: CALL 4894 0 1
5567: PPUSH
5568: CALL 4736 0 2
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: LD_VAR 0 1
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: LD_VAR 0 2
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: LD_ADDR_VAR 0 8
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: CALL 4894 0 1
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: LD_ADDR_VAR 0 8
5620: PUSH
5621: LD_VAR 0 2
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: LD_ADDR_VAR 0 6
5630: PUSH
5631: LD_VAR 0 1
5635: PPUSH
5636: CALL_OW 503
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: LD_VAR 0 6
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: LD_ADDR_VAR 0 4
5656: PUSH
5657: LD_VAR 0 6
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: LD_ADDR_VAR 0 7
5666: PUSH
5667: LD_OWVAR 3
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: LD_VAR 0 1
5679: PPUSH
5680: CALL_OW 255
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: CALL_OW 69
5693: DIFF
5694: PPUSH
5695: LD_VAR 0 1
5699: PPUSH
5700: CALL_OW 74
5704: ST_TO_ADDR
// if nearest_unit then
5705: LD_VAR 0 7
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: LD_ADDR_VAR 0 5
5715: PUSH
5716: LD_VAR 0 7
5720: PPUSH
5721: CALL_OW 255
5725: ST_TO_ADDR
// if not side and not side2 then
5726: LD_VAR 0 4
5730: NOT
5731: PUSH
5732: LD_VAR 0 5
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: LD_VAR 0 4
5746: PUSH
5747: LD_VAR 0 5
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: LD_VAR 0 4
5758: PPUSH
5759: LD_VAR 0 8
5763: PPUSH
5764: CALL 4736 0 2
5768: GO 5818
// begin if side then
5770: LD_VAR 0 4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: LD_VAR 0 4
5780: PPUSH
5781: LD_VAR 0 8
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: CALL 4736 0 2
// if side2 then
5794: LD_VAR 0 5
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: LD_VAR 0 5
5804: PPUSH
5805: LD_VAR 0 8
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: CALL 4736 0 2
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: LD_VAR 0 1
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: CALL 4894 0 1
5838: PPUSH
5839: CALL 4736 0 2
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: LD_ADDR_VAR 0 9
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: CALL_OW 69
5878: ST_TO_ADDR
// side_bot := side ;
5879: LD_ADDR_EXP 3
5883: PUSH
5884: LD_VAR 0 1
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: LD_VAR 0 9
5893: PUSH
5894: LD_VAR 0 1
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: LD_ADDR_VAR 0 3
5909: PUSH
5910: LD_VAR 0 9
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: LD_VAR 0 3
5922: PPUSH
5923: LD_VAR 0 1
5927: PPUSH
5928: CALL_OW 235
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: CALL_OW 335
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: LD_ADDR_VAR 0 10
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_VAR 0 10
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: LD_VAR 0 3
6012: PPUSH
6013: LD_VAR 0 1
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: CALL_OW 322
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: LD_ADDR_VAR 0 8
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_OWVAR 67
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: CALL_OW 169
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: CALL_OW 67
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: LD_VAR 0 1
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: LD_ADDR_EXP 33
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: LD_VAR 0 8
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: CALL 18310 0 6
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: LD_ADDR_EXP 34
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: LD_VAR 0 8
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: CALL 18310 0 6
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: LD_ADDR_EXP 31
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: LD_VAR 0 8
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL 18310 0 6
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: LD_ADDR_EXP 32
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: LD_VAR 0 8
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: CALL 18310 0 6
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: LD_ADDR_EXP 35
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: LD_VAR 0 8
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: CALL 18310 0 6
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: LD_ADDR_EXP 43
6377: PUSH
6378: LD_EXP 33
6382: PUSH
6383: LD_EXP 31
6387: PUSH
6388: LD_EXP 35
6392: PUSH
6393: LD_EXP 32
6397: PUSH
6398: LD_EXP 34
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: LD_ADDR_VAR 0 3
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: LD_ADDR_VAR 0 5
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: LD_VAR 0 3
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: LD_VAR 0 8
6511: PPUSH
6512: CALL_OW 380
// un := CreateVehicle ;
6516: LD_ADDR_VAR 0 6
6520: PUSH
6521: CALL_OW 45
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: LD_VAR 0 6
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: CALL_OW 12
6541: PPUSH
6542: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: LD_VAR 0 6
6550: PPUSH
6551: LD_VAR 0 5
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: LD_VAR 0 5
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: CALL_OW 50
// un2 := CreateHuman ;
6579: LD_ADDR_VAR 0 7
6583: PUSH
6584: CALL_OW 44
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: LD_VAR 0 7
6593: PPUSH
6594: LD_VAR 0 6
6598: PPUSH
6599: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: LD_ADDR_EXP 43
6607: PUSH
6608: LD_EXP 43
6612: PPUSH
6613: LD_VAR 0 3
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: LD_EXP 43
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: LD_VAR 0 6
6657: PPUSH
6658: CALL 14988 0 3
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: LD_ADDR_EXP 43
6667: PUSH
6668: LD_EXP 43
6672: PPUSH
6673: LD_VAR 0 3
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: LD_EXP 43
6690: PUSH
6691: LD_VAR 0 3
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: LD_VAR 0 7
6717: PPUSH
6718: CALL 14988 0 3
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: LD_ADDR_VAR 0 3
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: LD_EXP 3
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: CALL_OW 69
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: LD_VAR 0 3
6777: PPUSH
6778: CALL_OW 274
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: LD_ADDR_VAR 0 4
6790: PUSH
6791: LD_VAR 0 3
6795: PPUSH
6796: CALL_OW 254
6800: ST_TO_ADDR
// if d < 3 then
6801: LD_VAR 0 4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: LD_ADDR_VAR 0 4
6815: PUSH
6816: LD_VAR 0 4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: LD_ADDR_VAR 0 4
6831: PUSH
6832: LD_VAR 0 4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: LD_VAR 0 8
6851: PPUSH
6852: CALL_OW 380
// un := CreateHuman ;
6856: LD_ADDR_VAR 0 6
6860: PUSH
6861: CALL_OW 44
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: LD_VAR 0 6
6870: PPUSH
6871: LD_VAR 0 4
6875: PPUSH
6876: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6880: LD_VAR 0 6
6884: PPUSH
6885: LD_VAR 0 3
6889: PPUSH
6890: CALL_OW 52
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: LD_ADDR_EXP 36
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: LD_VAR 0 8
6915: PPUSH
6916: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: LD_ADDR_EXP 36
6940: PUSH
6941: LD_EXP 36
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: CALL_OW 44
6953: PPUSH
6954: CALL_OW 1
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: LD_VAR 0 8
6969: PPUSH
6970: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: LD_ADDR_EXP 36
6994: PUSH
6995: LD_EXP 36
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: CALL_OW 44
7007: PPUSH
7008: CALL_OW 1
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: LD_VAR 0 8
7023: PPUSH
7024: CALL_OW 380
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: LD_ADDR_EXP 36
7040: PUSH
7041: LD_EXP 36
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: CALL_OW 44
7053: PPUSH
7054: CALL_OW 1
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: LD_ADDR_EXP 39
7126: PUSH
7127: CALL_OW 44
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: LD_EXP 39
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: CALL_OW 52
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: LD_ADDR_EXP 40
7203: PUSH
7204: CALL_OW 44
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: LD_EXP 40
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: CALL_OW 52
// InitHc ;
7221: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: LD_ADDR_EXP 38
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: LD_ADDR_VAR 0 4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: LD_OWVAR 67
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: LD_ADDR_VAR 0 3
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: CALL_OW 12
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: CALL_OW 12
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: CALL_OW 12
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: CALL 14866 0 5
// un := CreateVehicle ;
7377: LD_ADDR_VAR 0 6
7381: PUSH
7382: CALL_OW 45
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: LD_ADDR_EXP 38
7391: PUSH
7392: LD_EXP 38
7396: PPUSH
7397: LD_VAR 0 3
7401: PUSH
7402: LD_EXP 38
7406: PUSH
7407: LD_VAR 0 3
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: LD_VAR 0 6
7425: PPUSH
7426: CALL 14988 0 3
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: LD_VAR 0 6
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: CALL_OW 12
7446: PPUSH
7447: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: LD_VAR 0 6
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: LD_VAR 0 3
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: CALL_OW 49
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: CALL_OW 19
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: CALL_OW 302
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: CALL_OW 255
7519: PUSH
7520: LD_EXP 3
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: LD_ADDR_VAR 0 4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: LD_ADDR_VAR 0 7
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: LD_ADDR_VAR 0 6
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: LD_ADDR_VAR 0 9
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: LD_ADDR_VAR 0 3
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: LD_ADDR_VAR 0 5
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: LD_OWVAR 67
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: LD_ADDR_VAR 0 1
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: LD_OWVAR 67
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: LD_ADDR_VAR 0 5
7785: PUSH
7786: LD_VAR 0 5
7790: PPUSH
7791: LD_VAR 0 5
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: CALL_OW 12
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: CALL_OW 2
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: LD_VAR 0 4
7858: PPUSH
7859: LD_VAR 0 5
7863: PPUSH
7864: CALL 75508 0 2
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7875: LD_VAR 0 4
7879: PPUSH
7880: CALL 75904 0 1
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: CALL_OW 67
// for i = 1 to coords do
7897: LD_ADDR_VAR 0 1
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: LD_VAR 0 6
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: LD_ADDR_VAR 0 2
7919: PUSH
7920: LD_EXP 3
7924: PPUSH
7925: LD_VAR 0 6
7929: PUSH
7930: LD_VAR 0 1
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: LD_VAR 0 6
7944: PUSH
7945: LD_VAR 0 1
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: CALL 15884 0 4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: LD_VAR 0 2
7971: PUSH
7972: LD_VAR 0 3
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: LD_ADDR_VAR 0 3
7983: PUSH
7984: LD_VAR 0 2
7988: ST_TO_ADDR
// target := i ;
7989: LD_ADDR_VAR 0 9
7993: PUSH
7994: LD_VAR 0 1
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: LD_VAR 0 9
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: LD_ADDR_VAR 0 10
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: LD_ADDR_VAR 0 10
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: LD_ADDR_VAR 0 10
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: LD_VAR 0 10
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: LD_ADDR_VAR 0 10
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: LD_VAR 0 4
8209: PPUSH
8210: LD_EXP 62
8214: PUSH
8215: LD_VAR 0 4
8219: ARRAY
8220: PPUSH
8221: LD_VAR 0 10
8225: PPUSH
8226: LD_VAR 0 7
8230: PPUSH
8231: CALL 75741 0 4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: CALL_OW 302
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: CALL_OW 255
8253: PUSH
8254: LD_EXP 3
8258: EQUAL
8259: AND
8260: PUSH
8261: LD_EXP 26
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: CALL_OW 301
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: CALL_OW 255
8286: PUSH
8287: LD_EXP 3
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: LD_ADDR_VAR 0 7
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: LD_ADDR_VAR 0 6
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: LD_ADDR_VAR 0 9
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: LD_ADDR_VAR 0 3
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: LD_ADDR_VAR 0 5
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: LD_OWVAR 67
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: LD_ADDR_VAR 0 1
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: LD_OWVAR 67
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: LD_ADDR_VAR 0 5
8512: PUSH
8513: LD_VAR 0 5
8517: PPUSH
8518: LD_VAR 0 5
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: LD_VAR 0 1
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: CALL_OW 2
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: LD_VAR 0 4
8583: PPUSH
8584: LD_VAR 0 5
8588: PPUSH
8589: CALL 75508 0 2
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8600: LD_VAR 0 4
8604: PPUSH
8605: CALL 75904 0 1
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: CALL_OW 67
// for i = 1 to coords do
8622: LD_ADDR_VAR 0 1
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: LD_VAR 0 6
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: LD_ADDR_VAR 0 2
8644: PUSH
8645: LD_EXP 3
8649: PPUSH
8650: LD_VAR 0 6
8654: PUSH
8655: LD_VAR 0 1
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: LD_VAR 0 6
8669: PUSH
8670: LD_VAR 0 1
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: CALL 15884 0 4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: LD_VAR 0 2
8696: PUSH
8697: LD_VAR 0 3
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: LD_ADDR_VAR 0 3
8708: PUSH
8709: LD_VAR 0 2
8713: ST_TO_ADDR
// target := i ;
8714: LD_ADDR_VAR 0 9
8718: PUSH
8719: LD_VAR 0 1
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: LD_VAR 0 9
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: LD_ADDR_VAR 0 10
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: LD_ADDR_VAR 0 10
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: LD_VAR 0 10
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: LD_ADDR_VAR 0 10
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: LD_VAR 0 4
8854: PPUSH
8855: LD_EXP 62
8859: PUSH
8860: LD_VAR 0 4
8864: ARRAY
8865: PPUSH
8866: LD_VAR 0 10
8870: PPUSH
8871: LD_VAR 0 7
8875: PPUSH
8876: CALL 75741 0 4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: LD_EXP 4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: LD_VAR 0 1
8899: PPUSH
8900: CALL_OW 255
8904: PPUSH
8905: CALL 5823 0 1
// artifact_get := true ;
8909: LD_ADDR_EXP 4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: LD_ADDR_VAR 0 3
8928: PUSH
8929: LD_VAR 0 1
8933: PPUSH
8934: CALL_OW 255
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: LD_VAR 0 3
8943: PUSH
8944: LD_EXP 69
8948: IN
8949: NOT
8950: PUSH
8951: LD_EXP 7
8955: PUSH
8956: LD_VAR 0 3
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: LD_VAR 0 1
8968: PPUSH
8969: CALL_OW 247
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: LD_VAR 0 3
8983: PPUSH
8984: CALL 5463 0 1
// if side in mc_sides then
8988: LD_VAR 0 3
8992: PUSH
8993: LD_EXP 69
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: LD_VAR 0 1
9004: PUSH
9005: LD_EXP 40
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: LD_VAR 0 1
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: CALL 5577 0 2
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: LD_VAR 0 1
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: CALL 4894 0 1
9038: PPUSH
9039: CALL 5577 0 2
// if multi_commanders and multi_custom_commanders then
9043: LD_EXP 24
9047: PUSH
9048: LD_EXP 16
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: LD_VAR 0 1
9059: PUSH
9060: LD_EXP 24
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: LD_ADDR_EXP 25
9071: PUSH
9072: LD_EXP 25
9076: PPUSH
9077: LD_VAR 0 3
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: CALL_OW 1
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: LD_ADDR_EXP 24
9094: PUSH
9095: LD_EXP 24
9099: PUSH
9100: LD_VAR 0 1
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: LD_VAR 0 3
9110: PPUSH
9111: CALL 4927 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9115: LD_VAR 0 1
9119: PPUSH
9120: CALL 78998 0 1
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: LD_VAR 0 1
9131: PPUSH
9132: LD_VAR 0 2
9136: PPUSH
9137: CALL 81330 0 2
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: LD_VAR 0 1
9152: PPUSH
9153: CALL_OW 255
9157: PUSH
9158: LD_EXP 69
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: LD_VAR 0 1
9169: PPUSH
9170: CALL_OW 255
9174: PPUSH
9175: LD_VAR 0 1
9179: PPUSH
9180: CALL_OW 266
9184: PPUSH
9185: CALL 5507 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: LD_VAR 0 1
9193: PPUSH
9194: CALL_OW 266
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: LD_VAR 0 1
9207: PPUSH
9208: CALL_OW 255
9212: PUSH
9213: LD_EXP 69
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: LD_EXP 5
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: LD_VAR 0 1
9232: PPUSH
9233: LD_EXP 5
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9246: LD_ADDR_EXP 5
9250: PUSH
9251: LD_EXP 5
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: CALL_OW 3
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: LD_VAR 0 1
9268: PPUSH
9269: CALL 80639 0 1
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: LD_VAR 0 1
9280: PPUSH
9281: LD_VAR 0 2
9285: PPUSH
9286: CALL 78694 0 2
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: LD_VAR 0 1
9297: PPUSH
9298: LD_VAR 0 2
9302: PPUSH
9303: LD_VAR 0 3
9307: PPUSH
9308: LD_VAR 0 4
9312: PPUSH
9313: LD_VAR 0 5
9317: PPUSH
9318: CALL 78314 0 5
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: LD_ADDR_VAR 0 4
9334: PUSH
9335: LD_VAR 0 1
9339: PPUSH
9340: CALL_OW 255
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: LD_VAR 0 4
9349: PUSH
9350: LD_EXP 69
9354: IN
9355: NOT
9356: PUSH
9357: LD_EXP 7
9361: PUSH
9362: LD_VAR 0 4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: LD_VAR 0 4
9374: PPUSH
9375: CALL 5419 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: LD_VAR 0 1
9383: PPUSH
9384: LD_VAR 0 2
9388: PPUSH
9389: CALL 77867 0 2
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: LD_VAR 0 1
9400: PPUSH
9401: LD_VAR 0 2
9405: PPUSH
9406: LD_VAR 0 3
9410: PPUSH
9411: LD_VAR 0 4
9415: PPUSH
9416: CALL 77705 0 4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: LD_VAR 0 2
9432: PPUSH
9433: LD_VAR 0 3
9437: PPUSH
9438: CALL 77480 0 3
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: LD_VAR 0 1
9449: PPUSH
9450: LD_VAR 0 2
9454: PPUSH
9455: CALL 77365 0 2
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: LD_VAR 0 1
9466: PPUSH
9467: LD_VAR 0 2
9471: PPUSH
9472: CALL 81625 0 2
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: LD_VAR 0 1
9483: PPUSH
9484: LD_VAR 0 2
9488: PPUSH
9489: LD_VAR 0 3
9493: PPUSH
9494: LD_VAR 0 4
9498: PPUSH
9499: CALL 81841 0 4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: LD_EXP 2
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: LD_EXP 21
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: LD_EXP 21
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: CALL 9556 0 3
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: LD_VAR 0 1
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: LD_ADDR_VAR 0 7
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: LD_VAR 0 2
9594: PPUSH
9595: CALL_OW 67
// x := 5 ;
9599: LD_ADDR_VAR 0 6
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: LD_OWVAR 1
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: LD_OWVAR 67
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: LD_ADDR_VAR 0 5
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: LD_EXP 7
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: LD_EXP 7
9656: PUSH
9657: LD_VAR 0 5
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: LD_VAR 0 6
9668: PPUSH
9669: LD_VAR 0 7
9673: PUSH
9674: LD_EXP 7
9678: PUSH
9679: LD_VAR 0 5
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: CALL_OW 55
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: CALL_OW 67
// end ; for i in areas do
9704: LD_ADDR_VAR 0 5
9708: PUSH
9709: LD_VAR 0 1
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9724: LD_VAR 0 6
9728: PPUSH
9729: LD_VAR 0 5
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: CALL_OW 55
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: LD_ADDR_VAR 0 2
9749: PUSH
9750: LD_VAR 0 2
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: LD_ADDR_VAR 0 3
9763: PUSH
9764: LD_VAR 0 3
9768: PUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: LD_ADDR_VAR 0 6
9783: PUSH
9784: LD_VAR 0 6
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: LD_VAR 0 6
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: LD_ADDR_VAR 0 6
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: LD_VAR 0 2
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: LD_ADDR_VAR 0 2
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: LD_EXP 2
9833: NOT
9834: PUSH
9835: LD_VAR 0 3
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: LD_VAR 0 2
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: LD_ADDR_VAR 0 5
9865: PUSH
9866: LD_VAR 0 3
9870: PUSH
9871: LD_VAR 0 1
9875: STR
9876: PPUSH
9877: CALL_OW 34
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: LD_ADDR_VAR 0 5
9888: PUSH
9889: LD_VAR 0 1
9893: PPUSH
9894: CALL_OW 25
9898: ST_TO_ADDR
// result := unit ;
9899: LD_ADDR_VAR 0 4
9903: PUSH
9904: LD_VAR 0 5
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: LD_VAR 0 1
9922: NOT
9923: PUSH
9924: LD_VAR 0 2
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10702
// case nation of nation_american :
9934: LD_VAR 0 2
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: LD_ADDR_VAR 0 4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10626
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10395
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10170: LD_ADDR_VAR 0 4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: LD_INT 88
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: ST_TO_ADDR
10393: GO 10626
10395: LD_INT 3
10397: DOUBLE
10398: EQUAL
10399: IFTRUE 10403
10401: GO 10625
10403: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10404: LD_ADDR_VAR 0 4
10408: PUSH
10409: LD_INT 46
10411: PUSH
10412: LD_INT 47
10414: PUSH
10415: LD_INT 1
10417: PUSH
10418: LD_INT 2
10420: PUSH
10421: LD_INT 82
10423: PUSH
10424: LD_INT 83
10426: PUSH
10427: LD_INT 84
10429: PUSH
10430: LD_INT 85
10432: PUSH
10433: LD_INT 86
10435: PUSH
10436: LD_INT 11
10438: PUSH
10439: LD_INT 9
10441: PUSH
10442: LD_INT 20
10444: PUSH
10445: LD_INT 19
10447: PUSH
10448: LD_INT 21
10450: PUSH
10451: LD_INT 24
10453: PUSH
10454: LD_INT 22
10456: PUSH
10457: LD_INT 25
10459: PUSH
10460: LD_INT 28
10462: PUSH
10463: LD_INT 29
10465: PUSH
10466: LD_INT 30
10468: PUSH
10469: LD_INT 31
10471: PUSH
10472: LD_INT 37
10474: PUSH
10475: LD_INT 38
10477: PUSH
10478: LD_INT 32
10480: PUSH
10481: LD_INT 27
10483: PUSH
10484: LD_INT 33
10486: PUSH
10487: LD_INT 69
10489: PUSH
10490: LD_INT 39
10492: PUSH
10493: LD_INT 34
10495: PUSH
10496: LD_INT 40
10498: PUSH
10499: LD_INT 71
10501: PUSH
10502: LD_INT 23
10504: PUSH
10505: LD_INT 44
10507: PUSH
10508: LD_INT 48
10510: PUSH
10511: LD_INT 49
10513: PUSH
10514: LD_INT 50
10516: PUSH
10517: LD_INT 51
10519: PUSH
10520: LD_INT 52
10522: PUSH
10523: LD_INT 53
10525: PUSH
10526: LD_INT 54
10528: PUSH
10529: LD_INT 55
10531: PUSH
10532: LD_INT 56
10534: PUSH
10535: LD_INT 57
10537: PUSH
10538: LD_INT 58
10540: PUSH
10541: LD_INT 59
10543: PUSH
10544: LD_INT 63
10546: PUSH
10547: LD_INT 64
10549: PUSH
10550: LD_INT 65
10552: PUSH
10553: LD_INT 82
10555: PUSH
10556: LD_INT 83
10558: PUSH
10559: LD_INT 84
10561: PUSH
10562: LD_INT 85
10564: PUSH
10565: LD_INT 86
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: ST_TO_ADDR
10623: GO 10626
10625: POP
// if state > - 1 and state < 3 then
10626: LD_VAR 0 3
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: GREATER
10635: PUSH
10636: LD_VAR 0 3
10640: PUSH
10641: LD_INT 3
10643: LESS
10644: AND
10645: IFFALSE 10702
// for i in result do
10647: LD_ADDR_VAR 0 5
10651: PUSH
10652: LD_VAR 0 4
10656: PUSH
10657: FOR_IN
10658: IFFALSE 10700
// if GetTech ( i , side ) <> state then
10660: LD_VAR 0 5
10664: PPUSH
10665: LD_VAR 0 1
10669: PPUSH
10670: CALL_OW 321
10674: PUSH
10675: LD_VAR 0 3
10679: NONEQUAL
10680: IFFALSE 10698
// result := result diff i ;
10682: LD_ADDR_VAR 0 4
10686: PUSH
10687: LD_VAR 0 4
10691: PUSH
10692: LD_VAR 0 5
10696: DIFF
10697: ST_TO_ADDR
10698: GO 10657
10700: POP
10701: POP
// end ;
10702: LD_VAR 0 4
10706: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// result := true ;
10712: LD_ADDR_VAR 0 3
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10720: LD_ADDR_VAR 0 5
10724: PUSH
10725: LD_VAR 0 2
10729: PPUSH
10730: CALL_OW 480
10734: ST_TO_ADDR
// if not tmp then
10735: LD_VAR 0 5
10739: NOT
10740: IFFALSE 10744
// exit ;
10742: GO 10793
// for i in tmp do
10744: LD_ADDR_VAR 0 4
10748: PUSH
10749: LD_VAR 0 5
10753: PUSH
10754: FOR_IN
10755: IFFALSE 10791
// if GetTech ( i , side ) <> state_researched then
10757: LD_VAR 0 4
10761: PPUSH
10762: LD_VAR 0 1
10766: PPUSH
10767: CALL_OW 321
10771: PUSH
10772: LD_INT 2
10774: NONEQUAL
10775: IFFALSE 10789
// begin result := false ;
10777: LD_ADDR_VAR 0 3
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// exit ;
10785: POP
10786: POP
10787: GO 10793
// end ;
10789: GO 10754
10791: POP
10792: POP
// end ;
10793: LD_VAR 0 3
10797: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10798: LD_INT 0
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10813: LD_VAR 0 1
10817: NOT
10818: PUSH
10819: LD_VAR 0 1
10823: PPUSH
10824: CALL_OW 257
10828: PUSH
10829: LD_INT 9
10831: NONEQUAL
10832: OR
10833: IFFALSE 10837
// exit ;
10835: GO 11410
// side := GetSide ( unit ) ;
10837: LD_ADDR_VAR 0 9
10841: PUSH
10842: LD_VAR 0 1
10846: PPUSH
10847: CALL_OW 255
10851: ST_TO_ADDR
// tech_space := tech_spacanom ;
10852: LD_ADDR_VAR 0 12
10856: PUSH
10857: LD_INT 29
10859: ST_TO_ADDR
// tech_time := tech_taurad ;
10860: LD_ADDR_VAR 0 13
10864: PUSH
10865: LD_INT 28
10867: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10868: LD_ADDR_VAR 0 11
10872: PUSH
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL_OW 310
10882: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10883: LD_VAR 0 11
10887: PPUSH
10888: CALL_OW 247
10892: PUSH
10893: LD_INT 2
10895: EQUAL
10896: IFFALSE 10900
// exit ;
10898: GO 11410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10900: LD_ADDR_VAR 0 8
10904: PUSH
10905: LD_INT 81
10907: PUSH
10908: LD_VAR 0 9
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PUSH
10917: LD_INT 3
10919: PUSH
10920: LD_INT 21
10922: PUSH
10923: LD_INT 3
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PPUSH
10938: CALL_OW 69
10942: ST_TO_ADDR
// if not tmp then
10943: LD_VAR 0 8
10947: NOT
10948: IFFALSE 10952
// exit ;
10950: GO 11410
// if in_unit then
10952: LD_VAR 0 11
10956: IFFALSE 10980
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10958: LD_ADDR_VAR 0 10
10962: PUSH
10963: LD_VAR 0 8
10967: PPUSH
10968: LD_VAR 0 11
10972: PPUSH
10973: CALL_OW 74
10977: ST_TO_ADDR
10978: GO 11000
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10980: LD_ADDR_VAR 0 10
10984: PUSH
10985: LD_VAR 0 8
10989: PPUSH
10990: LD_VAR 0 1
10994: PPUSH
10995: CALL_OW 74
10999: ST_TO_ADDR
// if not enemy then
11000: LD_VAR 0 10
11004: NOT
11005: IFFALSE 11009
// exit ;
11007: GO 11410
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11009: LD_VAR 0 11
11013: PUSH
11014: LD_VAR 0 11
11018: PPUSH
11019: LD_VAR 0 10
11023: PPUSH
11024: CALL_OW 296
11028: PUSH
11029: LD_INT 13
11031: GREATER
11032: AND
11033: PUSH
11034: LD_VAR 0 1
11038: PPUSH
11039: LD_VAR 0 10
11043: PPUSH
11044: CALL_OW 296
11048: PUSH
11049: LD_INT 12
11051: GREATER
11052: OR
11053: IFFALSE 11057
// exit ;
11055: GO 11410
// missile := [ 1 ] ;
11057: LD_ADDR_VAR 0 14
11061: PUSH
11062: LD_INT 1
11064: PUSH
11065: EMPTY
11066: LIST
11067: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11068: LD_VAR 0 9
11072: PPUSH
11073: LD_VAR 0 12
11077: PPUSH
11078: CALL_OW 325
11082: IFFALSE 11111
// missile := Replace ( missile , missile + 1 , 2 ) ;
11084: LD_ADDR_VAR 0 14
11088: PUSH
11089: LD_VAR 0 14
11093: PPUSH
11094: LD_VAR 0 14
11098: PUSH
11099: LD_INT 1
11101: PLUS
11102: PPUSH
11103: LD_INT 2
11105: PPUSH
11106: CALL_OW 1
11110: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11111: LD_VAR 0 9
11115: PPUSH
11116: LD_VAR 0 13
11120: PPUSH
11121: CALL_OW 325
11125: PUSH
11126: LD_VAR 0 10
11130: PPUSH
11131: CALL_OW 255
11135: PPUSH
11136: LD_VAR 0 13
11140: PPUSH
11141: CALL_OW 325
11145: NOT
11146: AND
11147: IFFALSE 11176
// missile := Replace ( missile , missile + 1 , 3 ) ;
11149: LD_ADDR_VAR 0 14
11153: PUSH
11154: LD_VAR 0 14
11158: PPUSH
11159: LD_VAR 0 14
11163: PUSH
11164: LD_INT 1
11166: PLUS
11167: PPUSH
11168: LD_INT 3
11170: PPUSH
11171: CALL_OW 1
11175: ST_TO_ADDR
// if missile < 2 then
11176: LD_VAR 0 14
11180: PUSH
11181: LD_INT 2
11183: LESS
11184: IFFALSE 11188
// exit ;
11186: GO 11410
// x := GetX ( enemy ) ;
11188: LD_ADDR_VAR 0 4
11192: PUSH
11193: LD_VAR 0 10
11197: PPUSH
11198: CALL_OW 250
11202: ST_TO_ADDR
// y := GetY ( enemy ) ;
11203: LD_ADDR_VAR 0 5
11207: PUSH
11208: LD_VAR 0 10
11212: PPUSH
11213: CALL_OW 251
11217: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11218: LD_ADDR_VAR 0 6
11222: PUSH
11223: LD_VAR 0 4
11227: PUSH
11228: LD_INT 1
11230: NEG
11231: PPUSH
11232: LD_INT 1
11234: PPUSH
11235: CALL_OW 12
11239: PLUS
11240: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11241: LD_ADDR_VAR 0 7
11245: PUSH
11246: LD_VAR 0 5
11250: PUSH
11251: LD_INT 1
11253: NEG
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: CALL_OW 12
11262: PLUS
11263: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11264: LD_VAR 0 6
11268: PPUSH
11269: LD_VAR 0 7
11273: PPUSH
11274: CALL_OW 488
11278: NOT
11279: IFFALSE 11301
// begin _x := x ;
11281: LD_ADDR_VAR 0 6
11285: PUSH
11286: LD_VAR 0 4
11290: ST_TO_ADDR
// _y := y ;
11291: LD_ADDR_VAR 0 7
11295: PUSH
11296: LD_VAR 0 5
11300: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11301: LD_ADDR_VAR 0 3
11305: PUSH
11306: LD_INT 1
11308: PPUSH
11309: LD_VAR 0 14
11313: PPUSH
11314: CALL_OW 12
11318: ST_TO_ADDR
// case i of 1 :
11319: LD_VAR 0 3
11323: PUSH
11324: LD_INT 1
11326: DOUBLE
11327: EQUAL
11328: IFTRUE 11332
11330: GO 11349
11332: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11333: LD_VAR 0 1
11337: PPUSH
11338: LD_VAR 0 10
11342: PPUSH
11343: CALL_OW 115
11347: GO 11410
11349: LD_INT 2
11351: DOUBLE
11352: EQUAL
11353: IFTRUE 11357
11355: GO 11379
11357: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11358: LD_VAR 0 1
11362: PPUSH
11363: LD_VAR 0 6
11367: PPUSH
11368: LD_VAR 0 7
11372: PPUSH
11373: CALL_OW 153
11377: GO 11410
11379: LD_INT 3
11381: DOUBLE
11382: EQUAL
11383: IFTRUE 11387
11385: GO 11409
11387: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11388: LD_VAR 0 1
11392: PPUSH
11393: LD_VAR 0 6
11397: PPUSH
11398: LD_VAR 0 7
11402: PPUSH
11403: CALL_OW 154
11407: GO 11410
11409: POP
// end ;
11410: LD_VAR 0 2
11414: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11415: LD_INT 0
11417: PPUSH
11418: PPUSH
11419: PPUSH
11420: PPUSH
11421: PPUSH
11422: PPUSH
// if not unit or not building then
11423: LD_VAR 0 1
11427: NOT
11428: PUSH
11429: LD_VAR 0 2
11433: NOT
11434: OR
11435: IFFALSE 11439
// exit ;
11437: GO 11597
// x := GetX ( building ) ;
11439: LD_ADDR_VAR 0 5
11443: PUSH
11444: LD_VAR 0 2
11448: PPUSH
11449: CALL_OW 250
11453: ST_TO_ADDR
// y := GetY ( building ) ;
11454: LD_ADDR_VAR 0 6
11458: PUSH
11459: LD_VAR 0 2
11463: PPUSH
11464: CALL_OW 251
11468: ST_TO_ADDR
// for i = 0 to 5 do
11469: LD_ADDR_VAR 0 4
11473: PUSH
11474: DOUBLE
11475: LD_INT 0
11477: DEC
11478: ST_TO_ADDR
11479: LD_INT 5
11481: PUSH
11482: FOR_TO
11483: IFFALSE 11595
// begin _x := ShiftX ( x , i , 3 ) ;
11485: LD_ADDR_VAR 0 7
11489: PUSH
11490: LD_VAR 0 5
11494: PPUSH
11495: LD_VAR 0 4
11499: PPUSH
11500: LD_INT 3
11502: PPUSH
11503: CALL_OW 272
11507: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11508: LD_ADDR_VAR 0 8
11512: PUSH
11513: LD_VAR 0 6
11517: PPUSH
11518: LD_VAR 0 4
11522: PPUSH
11523: LD_INT 3
11525: PPUSH
11526: CALL_OW 273
11530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11531: LD_VAR 0 7
11535: PPUSH
11536: LD_VAR 0 8
11540: PPUSH
11541: CALL_OW 488
11545: NOT
11546: IFFALSE 11550
// continue ;
11548: GO 11482
// if HexInfo ( _x , _y ) = 0 then
11550: LD_VAR 0 7
11554: PPUSH
11555: LD_VAR 0 8
11559: PPUSH
11560: CALL_OW 428
11564: PUSH
11565: LD_INT 0
11567: EQUAL
11568: IFFALSE 11593
// begin ComMoveXY ( unit , _x , _y ) ;
11570: LD_VAR 0 1
11574: PPUSH
11575: LD_VAR 0 7
11579: PPUSH
11580: LD_VAR 0 8
11584: PPUSH
11585: CALL_OW 111
// exit ;
11589: POP
11590: POP
11591: GO 11597
// end ; end ;
11593: GO 11482
11595: POP
11596: POP
// end ;
11597: LD_VAR 0 3
11601: RET
// export function ScanBase ( side , base_area ) ; begin
11602: LD_INT 0
11604: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11605: LD_ADDR_VAR 0 3
11609: PUSH
11610: LD_VAR 0 2
11614: PPUSH
11615: LD_INT 81
11617: PUSH
11618: LD_VAR 0 1
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PPUSH
11627: CALL_OW 70
11631: ST_TO_ADDR
// end ;
11632: LD_VAR 0 3
11636: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11637: LD_INT 0
11639: PPUSH
11640: PPUSH
11641: PPUSH
11642: PPUSH
// result := false ;
11643: LD_ADDR_VAR 0 2
11647: PUSH
11648: LD_INT 0
11650: ST_TO_ADDR
// side := GetSide ( unit ) ;
11651: LD_ADDR_VAR 0 3
11655: PUSH
11656: LD_VAR 0 1
11660: PPUSH
11661: CALL_OW 255
11665: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11666: LD_ADDR_VAR 0 4
11670: PUSH
11671: LD_VAR 0 1
11675: PPUSH
11676: CALL_OW 248
11680: ST_TO_ADDR
// case nat of 1 :
11681: LD_VAR 0 4
11685: PUSH
11686: LD_INT 1
11688: DOUBLE
11689: EQUAL
11690: IFTRUE 11694
11692: GO 11705
11694: POP
// tech := tech_lassight ; 2 :
11695: LD_ADDR_VAR 0 5
11699: PUSH
11700: LD_INT 12
11702: ST_TO_ADDR
11703: GO 11744
11705: LD_INT 2
11707: DOUBLE
11708: EQUAL
11709: IFTRUE 11713
11711: GO 11724
11713: POP
// tech := tech_mortar ; 3 :
11714: LD_ADDR_VAR 0 5
11718: PUSH
11719: LD_INT 41
11721: ST_TO_ADDR
11722: GO 11744
11724: LD_INT 3
11726: DOUBLE
11727: EQUAL
11728: IFTRUE 11732
11730: GO 11743
11732: POP
// tech := tech_bazooka ; end ;
11733: LD_ADDR_VAR 0 5
11737: PUSH
11738: LD_INT 44
11740: ST_TO_ADDR
11741: GO 11744
11743: POP
// if Researched ( side , tech ) then
11744: LD_VAR 0 3
11748: PPUSH
11749: LD_VAR 0 5
11753: PPUSH
11754: CALL_OW 325
11758: IFFALSE 11785
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11760: LD_ADDR_VAR 0 2
11764: PUSH
11765: LD_INT 5
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: LD_INT 9
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: LIST
11778: PUSH
11779: LD_VAR 0 4
11783: ARRAY
11784: ST_TO_ADDR
// end ;
11785: LD_VAR 0 2
11789: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11790: LD_INT 0
11792: PPUSH
11793: PPUSH
11794: PPUSH
// if not mines then
11795: LD_VAR 0 2
11799: NOT
11800: IFFALSE 11804
// exit ;
11802: GO 11948
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11804: LD_ADDR_VAR 0 5
11808: PUSH
11809: LD_INT 81
11811: PUSH
11812: LD_VAR 0 1
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: LD_INT 3
11823: PUSH
11824: LD_INT 21
11826: PUSH
11827: LD_INT 3
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PPUSH
11842: CALL_OW 69
11846: ST_TO_ADDR
// for i in mines do
11847: LD_ADDR_VAR 0 4
11851: PUSH
11852: LD_VAR 0 2
11856: PUSH
11857: FOR_IN
11858: IFFALSE 11946
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11860: LD_VAR 0 4
11864: PUSH
11865: LD_INT 1
11867: ARRAY
11868: PPUSH
11869: LD_VAR 0 4
11873: PUSH
11874: LD_INT 2
11876: ARRAY
11877: PPUSH
11878: CALL_OW 458
11882: NOT
11883: IFFALSE 11887
// continue ;
11885: GO 11857
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11887: LD_VAR 0 4
11891: PUSH
11892: LD_INT 1
11894: ARRAY
11895: PPUSH
11896: LD_VAR 0 4
11900: PUSH
11901: LD_INT 2
11903: ARRAY
11904: PPUSH
11905: CALL_OW 428
11909: PUSH
11910: LD_VAR 0 5
11914: IN
11915: IFFALSE 11944
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11917: LD_VAR 0 4
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: LD_VAR 0 4
11930: PUSH
11931: LD_INT 2
11933: ARRAY
11934: PPUSH
11935: LD_VAR 0 1
11939: PPUSH
11940: CALL_OW 456
// end ;
11944: GO 11857
11946: POP
11947: POP
// end ;
11948: LD_VAR 0 3
11952: RET
// export function Count ( array ) ; var i ; begin
11953: LD_INT 0
11955: PPUSH
11956: PPUSH
// result := 0 ;
11957: LD_ADDR_VAR 0 2
11961: PUSH
11962: LD_INT 0
11964: ST_TO_ADDR
// for i in array do
11965: LD_ADDR_VAR 0 3
11969: PUSH
11970: LD_VAR 0 1
11974: PUSH
11975: FOR_IN
11976: IFFALSE 12000
// if i then
11978: LD_VAR 0 3
11982: IFFALSE 11998
// result := result + 1 ;
11984: LD_ADDR_VAR 0 2
11988: PUSH
11989: LD_VAR 0 2
11993: PUSH
11994: LD_INT 1
11996: PLUS
11997: ST_TO_ADDR
11998: GO 11975
12000: POP
12001: POP
// end ;
12002: LD_VAR 0 2
12006: RET
// export function IsEmpty ( building ) ; begin
12007: LD_INT 0
12009: PPUSH
// if not building then
12010: LD_VAR 0 1
12014: NOT
12015: IFFALSE 12019
// exit ;
12017: GO 12062
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12019: LD_ADDR_VAR 0 2
12023: PUSH
12024: LD_VAR 0 1
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: LD_VAR 0 1
12036: PPUSH
12037: CALL_OW 255
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 58
12048: PUSH
12049: EMPTY
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PPUSH
12056: CALL_OW 69
12060: IN
12061: ST_TO_ADDR
// end ;
12062: LD_VAR 0 2
12066: RET
// export function IsNotFull ( building ) ; var places ; begin
12067: LD_INT 0
12069: PPUSH
12070: PPUSH
// if not building then
12071: LD_VAR 0 1
12075: NOT
12076: IFFALSE 12080
// exit ;
12078: GO 12251
// result := false ;
12080: LD_ADDR_VAR 0 2
12084: PUSH
12085: LD_INT 0
12087: ST_TO_ADDR
// places := 0 ;
12088: LD_ADDR_VAR 0 3
12092: PUSH
12093: LD_INT 0
12095: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
12096: LD_VAR 0 1
12100: PPUSH
12101: CALL_OW 266
12105: PUSH
12106: LD_INT 0
12108: DOUBLE
12109: EQUAL
12110: IFTRUE 12168
12112: LD_INT 1
12114: DOUBLE
12115: EQUAL
12116: IFTRUE 12168
12118: LD_INT 6
12120: DOUBLE
12121: EQUAL
12122: IFTRUE 12168
12124: LD_INT 7
12126: DOUBLE
12127: EQUAL
12128: IFTRUE 12168
12130: LD_INT 8
12132: DOUBLE
12133: EQUAL
12134: IFTRUE 12168
12136: LD_INT 4
12138: DOUBLE
12139: EQUAL
12140: IFTRUE 12168
12142: LD_INT 5
12144: DOUBLE
12145: EQUAL
12146: IFTRUE 12168
12148: LD_INT 2
12150: DOUBLE
12151: EQUAL
12152: IFTRUE 12168
12154: LD_INT 3
12156: DOUBLE
12157: EQUAL
12158: IFTRUE 12168
12160: LD_INT 35
12162: DOUBLE
12163: EQUAL
12164: IFTRUE 12168
12166: GO 12179
12168: POP
// places := 6 ; b_bunker , b_breastwork :
12169: LD_ADDR_VAR 0 3
12173: PUSH
12174: LD_INT 6
12176: ST_TO_ADDR
12177: GO 12224
12179: LD_INT 32
12181: DOUBLE
12182: EQUAL
12183: IFTRUE 12193
12185: LD_INT 31
12187: DOUBLE
12188: EQUAL
12189: IFTRUE 12193
12191: GO 12204
12193: POP
// places := 1 ; b_control_tower :
12194: LD_ADDR_VAR 0 3
12198: PUSH
12199: LD_INT 1
12201: ST_TO_ADDR
12202: GO 12224
12204: LD_INT 36
12206: DOUBLE
12207: EQUAL
12208: IFTRUE 12212
12210: GO 12223
12212: POP
// places := 3 ; end ;
12213: LD_ADDR_VAR 0 3
12217: PUSH
12218: LD_INT 3
12220: ST_TO_ADDR
12221: GO 12224
12223: POP
// if places then
12224: LD_VAR 0 3
12228: IFFALSE 12251
// result := UnitsInside ( building ) < places ;
12230: LD_ADDR_VAR 0 2
12234: PUSH
12235: LD_VAR 0 1
12239: PPUSH
12240: CALL_OW 313
12244: PUSH
12245: LD_VAR 0 3
12249: LESS
12250: ST_TO_ADDR
// end ;
12251: LD_VAR 0 2
12255: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12256: LD_INT 0
12258: PPUSH
12259: PPUSH
12260: PPUSH
12261: PPUSH
// tmp := [ ] ;
12262: LD_ADDR_VAR 0 3
12266: PUSH
12267: EMPTY
12268: ST_TO_ADDR
// list := [ ] ;
12269: LD_ADDR_VAR 0 5
12273: PUSH
12274: EMPTY
12275: ST_TO_ADDR
// for i = 16 to 25 do
12276: LD_ADDR_VAR 0 4
12280: PUSH
12281: DOUBLE
12282: LD_INT 16
12284: DEC
12285: ST_TO_ADDR
12286: LD_INT 25
12288: PUSH
12289: FOR_TO
12290: IFFALSE 12363
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12292: LD_ADDR_VAR 0 3
12296: PUSH
12297: LD_VAR 0 3
12301: PUSH
12302: LD_INT 22
12304: PUSH
12305: LD_VAR 0 1
12309: PPUSH
12310: CALL_OW 255
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 91
12321: PUSH
12322: LD_VAR 0 1
12326: PUSH
12327: LD_INT 6
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: LIST
12334: PUSH
12335: LD_INT 30
12337: PUSH
12338: LD_VAR 0 4
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: LIST
12351: PUSH
12352: EMPTY
12353: LIST
12354: PPUSH
12355: CALL_OW 69
12359: ADD
12360: ST_TO_ADDR
12361: GO 12289
12363: POP
12364: POP
// for i = 1 to tmp do
12365: LD_ADDR_VAR 0 4
12369: PUSH
12370: DOUBLE
12371: LD_INT 1
12373: DEC
12374: ST_TO_ADDR
12375: LD_VAR 0 3
12379: PUSH
12380: FOR_TO
12381: IFFALSE 12469
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12383: LD_ADDR_VAR 0 5
12387: PUSH
12388: LD_VAR 0 5
12392: PUSH
12393: LD_VAR 0 3
12397: PUSH
12398: LD_VAR 0 4
12402: ARRAY
12403: PPUSH
12404: CALL_OW 266
12408: PUSH
12409: LD_VAR 0 3
12413: PUSH
12414: LD_VAR 0 4
12418: ARRAY
12419: PPUSH
12420: CALL_OW 250
12424: PUSH
12425: LD_VAR 0 3
12429: PUSH
12430: LD_VAR 0 4
12434: ARRAY
12435: PPUSH
12436: CALL_OW 251
12440: PUSH
12441: LD_VAR 0 3
12445: PUSH
12446: LD_VAR 0 4
12450: ARRAY
12451: PPUSH
12452: CALL_OW 254
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: PUSH
12463: EMPTY
12464: LIST
12465: ADD
12466: ST_TO_ADDR
12467: GO 12380
12469: POP
12470: POP
// result := list ;
12471: LD_ADDR_VAR 0 2
12475: PUSH
12476: LD_VAR 0 5
12480: ST_TO_ADDR
// end ;
12481: LD_VAR 0 2
12485: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12486: LD_INT 0
12488: PPUSH
12489: PPUSH
12490: PPUSH
12491: PPUSH
12492: PPUSH
12493: PPUSH
12494: PPUSH
// if not factory then
12495: LD_VAR 0 1
12499: NOT
12500: IFFALSE 12504
// exit ;
12502: GO 13097
// if control = control_apeman then
12504: LD_VAR 0 4
12508: PUSH
12509: LD_INT 5
12511: EQUAL
12512: IFFALSE 12621
// begin tmp := UnitsInside ( factory ) ;
12514: LD_ADDR_VAR 0 8
12518: PUSH
12519: LD_VAR 0 1
12523: PPUSH
12524: CALL_OW 313
12528: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12529: LD_VAR 0 8
12533: PPUSH
12534: LD_INT 25
12536: PUSH
12537: LD_INT 12
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: PPUSH
12544: CALL_OW 72
12548: NOT
12549: IFFALSE 12559
// control := control_manual ;
12551: LD_ADDR_VAR 0 4
12555: PUSH
12556: LD_INT 1
12558: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12559: LD_ADDR_VAR 0 8
12563: PUSH
12564: LD_VAR 0 1
12568: PPUSH
12569: CALL 12256 0 1
12573: ST_TO_ADDR
// if tmp then
12574: LD_VAR 0 8
12578: IFFALSE 12621
// begin for i in tmp do
12580: LD_ADDR_VAR 0 7
12584: PUSH
12585: LD_VAR 0 8
12589: PUSH
12590: FOR_IN
12591: IFFALSE 12619
// if i [ 1 ] = b_ext_radio then
12593: LD_VAR 0 7
12597: PUSH
12598: LD_INT 1
12600: ARRAY
12601: PUSH
12602: LD_INT 22
12604: EQUAL
12605: IFFALSE 12617
// begin control := control_remote ;
12607: LD_ADDR_VAR 0 4
12611: PUSH
12612: LD_INT 2
12614: ST_TO_ADDR
// break ;
12615: GO 12619
// end ;
12617: GO 12590
12619: POP
12620: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12621: LD_VAR 0 1
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: LD_VAR 0 3
12635: PPUSH
12636: LD_VAR 0 4
12640: PPUSH
12641: LD_VAR 0 5
12645: PPUSH
12646: CALL_OW 448
12650: IFFALSE 12685
// begin result := [ chassis , engine , control , weapon ] ;
12652: LD_ADDR_VAR 0 6
12656: PUSH
12657: LD_VAR 0 2
12661: PUSH
12662: LD_VAR 0 3
12666: PUSH
12667: LD_VAR 0 4
12671: PUSH
12672: LD_VAR 0 5
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: ST_TO_ADDR
// exit ;
12683: GO 13097
// end ; _chassis := AvailableChassisList ( factory ) ;
12685: LD_ADDR_VAR 0 9
12689: PUSH
12690: LD_VAR 0 1
12694: PPUSH
12695: CALL_OW 475
12699: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12700: LD_ADDR_VAR 0 11
12704: PUSH
12705: LD_VAR 0 1
12709: PPUSH
12710: CALL_OW 476
12714: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12715: LD_ADDR_VAR 0 12
12719: PUSH
12720: LD_VAR 0 1
12724: PPUSH
12725: CALL_OW 477
12729: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12730: LD_ADDR_VAR 0 10
12734: PUSH
12735: LD_VAR 0 1
12739: PPUSH
12740: CALL_OW 478
12744: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12745: LD_VAR 0 9
12749: NOT
12750: PUSH
12751: LD_VAR 0 11
12755: NOT
12756: OR
12757: PUSH
12758: LD_VAR 0 12
12762: NOT
12763: OR
12764: PUSH
12765: LD_VAR 0 10
12769: NOT
12770: OR
12771: IFFALSE 12806
// begin result := [ chassis , engine , control , weapon ] ;
12773: LD_ADDR_VAR 0 6
12777: PUSH
12778: LD_VAR 0 2
12782: PUSH
12783: LD_VAR 0 3
12787: PUSH
12788: LD_VAR 0 4
12792: PUSH
12793: LD_VAR 0 5
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: ST_TO_ADDR
// exit ;
12804: GO 13097
// end ; if not chassis in _chassis then
12806: LD_VAR 0 2
12810: PUSH
12811: LD_VAR 0 9
12815: IN
12816: NOT
12817: IFFALSE 12843
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12819: LD_ADDR_VAR 0 2
12823: PUSH
12824: LD_VAR 0 9
12828: PUSH
12829: LD_INT 1
12831: PPUSH
12832: LD_VAR 0 9
12836: PPUSH
12837: CALL_OW 12
12841: ARRAY
12842: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12843: LD_VAR 0 2
12847: PPUSH
12848: LD_VAR 0 3
12852: PPUSH
12853: CALL 13102 0 2
12857: NOT
12858: IFFALSE 12917
// repeat engine := _engine [ 1 ] ;
12860: LD_ADDR_VAR 0 3
12864: PUSH
12865: LD_VAR 0 11
12869: PUSH
12870: LD_INT 1
12872: ARRAY
12873: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12874: LD_ADDR_VAR 0 11
12878: PUSH
12879: LD_VAR 0 11
12883: PPUSH
12884: LD_INT 1
12886: PPUSH
12887: CALL_OW 3
12891: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12892: LD_VAR 0 2
12896: PPUSH
12897: LD_VAR 0 3
12901: PPUSH
12902: CALL 13102 0 2
12906: PUSH
12907: LD_VAR 0 11
12911: PUSH
12912: EMPTY
12913: EQUAL
12914: OR
12915: IFFALSE 12860
// if not control in _control then
12917: LD_VAR 0 4
12921: PUSH
12922: LD_VAR 0 12
12926: IN
12927: NOT
12928: IFFALSE 12954
// control := _control [ rand ( 1 , _control ) ] ;
12930: LD_ADDR_VAR 0 4
12934: PUSH
12935: LD_VAR 0 12
12939: PUSH
12940: LD_INT 1
12942: PPUSH
12943: LD_VAR 0 12
12947: PPUSH
12948: CALL_OW 12
12952: ARRAY
12953: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12954: LD_VAR 0 2
12958: PPUSH
12959: LD_VAR 0 5
12963: PPUSH
12964: CALL 13322 0 2
12968: NOT
12969: IFFALSE 13028
// repeat weapon := _weapon [ 1 ] ;
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_VAR 0 10
12980: PUSH
12981: LD_INT 1
12983: ARRAY
12984: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12985: LD_ADDR_VAR 0 10
12989: PUSH
12990: LD_VAR 0 10
12994: PPUSH
12995: LD_INT 1
12997: PPUSH
12998: CALL_OW 3
13002: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
13003: LD_VAR 0 2
13007: PPUSH
13008: LD_VAR 0 5
13012: PPUSH
13013: CALL 13322 0 2
13017: PUSH
13018: LD_VAR 0 10
13022: PUSH
13023: EMPTY
13024: EQUAL
13025: OR
13026: IFFALSE 12971
// result := [ ] ;
13028: LD_ADDR_VAR 0 6
13032: PUSH
13033: EMPTY
13034: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13035: LD_VAR 0 1
13039: PPUSH
13040: LD_VAR 0 2
13044: PPUSH
13045: LD_VAR 0 3
13049: PPUSH
13050: LD_VAR 0 4
13054: PPUSH
13055: LD_VAR 0 5
13059: PPUSH
13060: CALL_OW 448
13064: IFFALSE 13097
// result := [ chassis , engine , control , weapon ] ;
13066: LD_ADDR_VAR 0 6
13070: PUSH
13071: LD_VAR 0 2
13075: PUSH
13076: LD_VAR 0 3
13080: PUSH
13081: LD_VAR 0 4
13085: PUSH
13086: LD_VAR 0 5
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: ST_TO_ADDR
// end ;
13097: LD_VAR 0 6
13101: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
13102: LD_INT 0
13104: PPUSH
// if not chassis or not engine then
13105: LD_VAR 0 1
13109: NOT
13110: PUSH
13111: LD_VAR 0 2
13115: NOT
13116: OR
13117: IFFALSE 13121
// exit ;
13119: GO 13317
// case engine of engine_solar :
13121: LD_VAR 0 2
13125: PUSH
13126: LD_INT 2
13128: DOUBLE
13129: EQUAL
13130: IFTRUE 13134
13132: GO 13172
13134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 11
13142: PUSH
13143: LD_INT 12
13145: PUSH
13146: LD_INT 13
13148: PUSH
13149: LD_INT 14
13151: PUSH
13152: LD_INT 1
13154: PUSH
13155: LD_INT 2
13157: PUSH
13158: LD_INT 3
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: ST_TO_ADDR
13170: GO 13301
13172: LD_INT 1
13174: DOUBLE
13175: EQUAL
13176: IFTRUE 13180
13178: GO 13242
13180: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13181: LD_ADDR_VAR 0 3
13185: PUSH
13186: LD_INT 11
13188: PUSH
13189: LD_INT 12
13191: PUSH
13192: LD_INT 13
13194: PUSH
13195: LD_INT 14
13197: PUSH
13198: LD_INT 1
13200: PUSH
13201: LD_INT 2
13203: PUSH
13204: LD_INT 3
13206: PUSH
13207: LD_INT 4
13209: PUSH
13210: LD_INT 5
13212: PUSH
13213: LD_INT 21
13215: PUSH
13216: LD_INT 23
13218: PUSH
13219: LD_INT 22
13221: PUSH
13222: LD_INT 24
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: ST_TO_ADDR
13240: GO 13301
13242: LD_INT 3
13244: DOUBLE
13245: EQUAL
13246: IFTRUE 13250
13248: GO 13300
13250: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13251: LD_ADDR_VAR 0 3
13255: PUSH
13256: LD_INT 13
13258: PUSH
13259: LD_INT 14
13261: PUSH
13262: LD_INT 2
13264: PUSH
13265: LD_INT 3
13267: PUSH
13268: LD_INT 4
13270: PUSH
13271: LD_INT 5
13273: PUSH
13274: LD_INT 21
13276: PUSH
13277: LD_INT 22
13279: PUSH
13280: LD_INT 23
13282: PUSH
13283: LD_INT 24
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: LIST
13290: LIST
13291: LIST
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: LIST
13297: ST_TO_ADDR
13298: GO 13301
13300: POP
// result := ( chassis in result ) ;
13301: LD_ADDR_VAR 0 3
13305: PUSH
13306: LD_VAR 0 1
13310: PUSH
13311: LD_VAR 0 3
13315: IN
13316: ST_TO_ADDR
// end ;
13317: LD_VAR 0 3
13321: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13322: LD_INT 0
13324: PPUSH
// if not chassis or not weapon then
13325: LD_VAR 0 1
13329: NOT
13330: PUSH
13331: LD_VAR 0 2
13335: NOT
13336: OR
13337: IFFALSE 13341
// exit ;
13339: GO 14401
// case weapon of us_machine_gun :
13341: LD_VAR 0 2
13345: PUSH
13346: LD_INT 2
13348: DOUBLE
13349: EQUAL
13350: IFTRUE 13354
13352: GO 13384
13354: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13355: LD_ADDR_VAR 0 3
13359: PUSH
13360: LD_INT 1
13362: PUSH
13363: LD_INT 2
13365: PUSH
13366: LD_INT 3
13368: PUSH
13369: LD_INT 4
13371: PUSH
13372: LD_INT 5
13374: PUSH
13375: EMPTY
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: ST_TO_ADDR
13382: GO 14385
13384: LD_INT 3
13386: DOUBLE
13387: EQUAL
13388: IFTRUE 13392
13390: GO 13422
13392: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13393: LD_ADDR_VAR 0 3
13397: PUSH
13398: LD_INT 1
13400: PUSH
13401: LD_INT 2
13403: PUSH
13404: LD_INT 3
13406: PUSH
13407: LD_INT 4
13409: PUSH
13410: LD_INT 5
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: ST_TO_ADDR
13420: GO 14385
13422: LD_INT 11
13424: DOUBLE
13425: EQUAL
13426: IFTRUE 13430
13428: GO 13460
13430: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13431: LD_ADDR_VAR 0 3
13435: PUSH
13436: LD_INT 1
13438: PUSH
13439: LD_INT 2
13441: PUSH
13442: LD_INT 3
13444: PUSH
13445: LD_INT 4
13447: PUSH
13448: LD_INT 5
13450: PUSH
13451: EMPTY
13452: LIST
13453: LIST
13454: LIST
13455: LIST
13456: LIST
13457: ST_TO_ADDR
13458: GO 14385
13460: LD_INT 4
13462: DOUBLE
13463: EQUAL
13464: IFTRUE 13468
13466: GO 13494
13468: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13469: LD_ADDR_VAR 0 3
13473: PUSH
13474: LD_INT 2
13476: PUSH
13477: LD_INT 3
13479: PUSH
13480: LD_INT 4
13482: PUSH
13483: LD_INT 5
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: LIST
13490: LIST
13491: ST_TO_ADDR
13492: GO 14385
13494: LD_INT 5
13496: DOUBLE
13497: EQUAL
13498: IFTRUE 13502
13500: GO 13528
13502: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13503: LD_ADDR_VAR 0 3
13507: PUSH
13508: LD_INT 2
13510: PUSH
13511: LD_INT 3
13513: PUSH
13514: LD_INT 4
13516: PUSH
13517: LD_INT 5
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: LIST
13524: LIST
13525: ST_TO_ADDR
13526: GO 14385
13528: LD_INT 9
13530: DOUBLE
13531: EQUAL
13532: IFTRUE 13536
13534: GO 13562
13536: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13537: LD_ADDR_VAR 0 3
13541: PUSH
13542: LD_INT 2
13544: PUSH
13545: LD_INT 3
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: LD_INT 5
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: LIST
13558: LIST
13559: ST_TO_ADDR
13560: GO 14385
13562: LD_INT 7
13564: DOUBLE
13565: EQUAL
13566: IFTRUE 13570
13568: GO 13596
13570: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13571: LD_ADDR_VAR 0 3
13575: PUSH
13576: LD_INT 2
13578: PUSH
13579: LD_INT 3
13581: PUSH
13582: LD_INT 4
13584: PUSH
13585: LD_INT 5
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: ST_TO_ADDR
13594: GO 14385
13596: LD_INT 12
13598: DOUBLE
13599: EQUAL
13600: IFTRUE 13604
13602: GO 13630
13604: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13605: LD_ADDR_VAR 0 3
13609: PUSH
13610: LD_INT 2
13612: PUSH
13613: LD_INT 3
13615: PUSH
13616: LD_INT 4
13618: PUSH
13619: LD_INT 5
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: ST_TO_ADDR
13628: GO 14385
13630: LD_INT 13
13632: DOUBLE
13633: EQUAL
13634: IFTRUE 13638
13636: GO 13664
13638: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13639: LD_ADDR_VAR 0 3
13643: PUSH
13644: LD_INT 2
13646: PUSH
13647: LD_INT 3
13649: PUSH
13650: LD_INT 4
13652: PUSH
13653: LD_INT 5
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: ST_TO_ADDR
13662: GO 14385
13664: LD_INT 14
13666: DOUBLE
13667: EQUAL
13668: IFTRUE 13672
13670: GO 13690
13672: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13673: LD_ADDR_VAR 0 3
13677: PUSH
13678: LD_INT 4
13680: PUSH
13681: LD_INT 5
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: ST_TO_ADDR
13688: GO 14385
13690: LD_INT 6
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13716
13698: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13699: LD_ADDR_VAR 0 3
13703: PUSH
13704: LD_INT 4
13706: PUSH
13707: LD_INT 5
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: ST_TO_ADDR
13714: GO 14385
13716: LD_INT 10
13718: DOUBLE
13719: EQUAL
13720: IFTRUE 13724
13722: GO 13742
13724: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13725: LD_ADDR_VAR 0 3
13729: PUSH
13730: LD_INT 4
13732: PUSH
13733: LD_INT 5
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: ST_TO_ADDR
13740: GO 14385
13742: LD_INT 22
13744: DOUBLE
13745: EQUAL
13746: IFTRUE 13750
13748: GO 13776
13750: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13751: LD_ADDR_VAR 0 3
13755: PUSH
13756: LD_INT 11
13758: PUSH
13759: LD_INT 12
13761: PUSH
13762: LD_INT 13
13764: PUSH
13765: LD_INT 14
13767: PUSH
13768: EMPTY
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: ST_TO_ADDR
13774: GO 14385
13776: LD_INT 23
13778: DOUBLE
13779: EQUAL
13780: IFTRUE 13784
13782: GO 13810
13784: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13785: LD_ADDR_VAR 0 3
13789: PUSH
13790: LD_INT 11
13792: PUSH
13793: LD_INT 12
13795: PUSH
13796: LD_INT 13
13798: PUSH
13799: LD_INT 14
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: ST_TO_ADDR
13808: GO 14385
13810: LD_INT 24
13812: DOUBLE
13813: EQUAL
13814: IFTRUE 13818
13816: GO 13844
13818: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13819: LD_ADDR_VAR 0 3
13823: PUSH
13824: LD_INT 11
13826: PUSH
13827: LD_INT 12
13829: PUSH
13830: LD_INT 13
13832: PUSH
13833: LD_INT 14
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: ST_TO_ADDR
13842: GO 14385
13844: LD_INT 30
13846: DOUBLE
13847: EQUAL
13848: IFTRUE 13852
13850: GO 13878
13852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13853: LD_ADDR_VAR 0 3
13857: PUSH
13858: LD_INT 11
13860: PUSH
13861: LD_INT 12
13863: PUSH
13864: LD_INT 13
13866: PUSH
13867: LD_INT 14
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: ST_TO_ADDR
13876: GO 14385
13878: LD_INT 25
13880: DOUBLE
13881: EQUAL
13882: IFTRUE 13886
13884: GO 13904
13886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13887: LD_ADDR_VAR 0 3
13891: PUSH
13892: LD_INT 13
13894: PUSH
13895: LD_INT 14
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: ST_TO_ADDR
13902: GO 14385
13904: LD_INT 27
13906: DOUBLE
13907: EQUAL
13908: IFTRUE 13912
13910: GO 13930
13912: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13913: LD_ADDR_VAR 0 3
13917: PUSH
13918: LD_INT 13
13920: PUSH
13921: LD_INT 14
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: ST_TO_ADDR
13928: GO 14385
13930: LD_INT 92
13932: DOUBLE
13933: EQUAL
13934: IFTRUE 13938
13936: GO 13964
13938: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13939: LD_ADDR_VAR 0 3
13943: PUSH
13944: LD_INT 11
13946: PUSH
13947: LD_INT 12
13949: PUSH
13950: LD_INT 13
13952: PUSH
13953: LD_INT 14
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: ST_TO_ADDR
13962: GO 14385
13964: LD_INT 28
13966: DOUBLE
13967: EQUAL
13968: IFTRUE 13972
13970: GO 13990
13972: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13973: LD_ADDR_VAR 0 3
13977: PUSH
13978: LD_INT 13
13980: PUSH
13981: LD_INT 14
13983: PUSH
13984: EMPTY
13985: LIST
13986: LIST
13987: ST_TO_ADDR
13988: GO 14385
13990: LD_INT 29
13992: DOUBLE
13993: EQUAL
13994: IFTRUE 13998
13996: GO 14016
13998: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13999: LD_ADDR_VAR 0 3
14003: PUSH
14004: LD_INT 13
14006: PUSH
14007: LD_INT 14
14009: PUSH
14010: EMPTY
14011: LIST
14012: LIST
14013: ST_TO_ADDR
14014: GO 14385
14016: LD_INT 31
14018: DOUBLE
14019: EQUAL
14020: IFTRUE 14024
14022: GO 14042
14024: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
14025: LD_ADDR_VAR 0 3
14029: PUSH
14030: LD_INT 13
14032: PUSH
14033: LD_INT 14
14035: PUSH
14036: EMPTY
14037: LIST
14038: LIST
14039: ST_TO_ADDR
14040: GO 14385
14042: LD_INT 26
14044: DOUBLE
14045: EQUAL
14046: IFTRUE 14050
14048: GO 14068
14050: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
14051: LD_ADDR_VAR 0 3
14055: PUSH
14056: LD_INT 13
14058: PUSH
14059: LD_INT 14
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: ST_TO_ADDR
14066: GO 14385
14068: LD_INT 42
14070: DOUBLE
14071: EQUAL
14072: IFTRUE 14076
14074: GO 14102
14076: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
14077: LD_ADDR_VAR 0 3
14081: PUSH
14082: LD_INT 21
14084: PUSH
14085: LD_INT 22
14087: PUSH
14088: LD_INT 23
14090: PUSH
14091: LD_INT 24
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: ST_TO_ADDR
14100: GO 14385
14102: LD_INT 43
14104: DOUBLE
14105: EQUAL
14106: IFTRUE 14110
14108: GO 14136
14110: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
14111: LD_ADDR_VAR 0 3
14115: PUSH
14116: LD_INT 21
14118: PUSH
14119: LD_INT 22
14121: PUSH
14122: LD_INT 23
14124: PUSH
14125: LD_INT 24
14127: PUSH
14128: EMPTY
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: ST_TO_ADDR
14134: GO 14385
14136: LD_INT 44
14138: DOUBLE
14139: EQUAL
14140: IFTRUE 14144
14142: GO 14170
14144: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
14145: LD_ADDR_VAR 0 3
14149: PUSH
14150: LD_INT 21
14152: PUSH
14153: LD_INT 22
14155: PUSH
14156: LD_INT 23
14158: PUSH
14159: LD_INT 24
14161: PUSH
14162: EMPTY
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: ST_TO_ADDR
14168: GO 14385
14170: LD_INT 45
14172: DOUBLE
14173: EQUAL
14174: IFTRUE 14178
14176: GO 14204
14178: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14179: LD_ADDR_VAR 0 3
14183: PUSH
14184: LD_INT 21
14186: PUSH
14187: LD_INT 22
14189: PUSH
14190: LD_INT 23
14192: PUSH
14193: LD_INT 24
14195: PUSH
14196: EMPTY
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: ST_TO_ADDR
14202: GO 14385
14204: LD_INT 49
14206: DOUBLE
14207: EQUAL
14208: IFTRUE 14212
14210: GO 14238
14212: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14213: LD_ADDR_VAR 0 3
14217: PUSH
14218: LD_INT 21
14220: PUSH
14221: LD_INT 22
14223: PUSH
14224: LD_INT 23
14226: PUSH
14227: LD_INT 24
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: ST_TO_ADDR
14236: GO 14385
14238: LD_INT 51
14240: DOUBLE
14241: EQUAL
14242: IFTRUE 14246
14244: GO 14272
14246: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14247: LD_ADDR_VAR 0 3
14251: PUSH
14252: LD_INT 21
14254: PUSH
14255: LD_INT 22
14257: PUSH
14258: LD_INT 23
14260: PUSH
14261: LD_INT 24
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: LIST
14268: LIST
14269: ST_TO_ADDR
14270: GO 14385
14272: LD_INT 52
14274: DOUBLE
14275: EQUAL
14276: IFTRUE 14280
14278: GO 14306
14280: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14281: LD_ADDR_VAR 0 3
14285: PUSH
14286: LD_INT 21
14288: PUSH
14289: LD_INT 22
14291: PUSH
14292: LD_INT 23
14294: PUSH
14295: LD_INT 24
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: ST_TO_ADDR
14304: GO 14385
14306: LD_INT 53
14308: DOUBLE
14309: EQUAL
14310: IFTRUE 14314
14312: GO 14332
14314: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14315: LD_ADDR_VAR 0 3
14319: PUSH
14320: LD_INT 23
14322: PUSH
14323: LD_INT 24
14325: PUSH
14326: EMPTY
14327: LIST
14328: LIST
14329: ST_TO_ADDR
14330: GO 14385
14332: LD_INT 46
14334: DOUBLE
14335: EQUAL
14336: IFTRUE 14340
14338: GO 14358
14340: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14341: LD_ADDR_VAR 0 3
14345: PUSH
14346: LD_INT 23
14348: PUSH
14349: LD_INT 24
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: ST_TO_ADDR
14356: GO 14385
14358: LD_INT 47
14360: DOUBLE
14361: EQUAL
14362: IFTRUE 14366
14364: GO 14384
14366: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14367: LD_ADDR_VAR 0 3
14371: PUSH
14372: LD_INT 23
14374: PUSH
14375: LD_INT 24
14377: PUSH
14378: EMPTY
14379: LIST
14380: LIST
14381: ST_TO_ADDR
14382: GO 14385
14384: POP
// result := ( chassis in result ) ;
14385: LD_ADDR_VAR 0 3
14389: PUSH
14390: LD_VAR 0 1
14394: PUSH
14395: LD_VAR 0 3
14399: IN
14400: ST_TO_ADDR
// end ;
14401: LD_VAR 0 3
14405: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14406: LD_INT 0
14408: PPUSH
14409: PPUSH
14410: PPUSH
14411: PPUSH
14412: PPUSH
14413: PPUSH
14414: PPUSH
// result := array ;
14415: LD_ADDR_VAR 0 5
14419: PUSH
14420: LD_VAR 0 1
14424: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14425: LD_VAR 0 1
14429: NOT
14430: PUSH
14431: LD_VAR 0 2
14435: NOT
14436: OR
14437: PUSH
14438: LD_VAR 0 3
14442: NOT
14443: OR
14444: PUSH
14445: LD_VAR 0 2
14449: PUSH
14450: LD_VAR 0 1
14454: GREATER
14455: OR
14456: PUSH
14457: LD_VAR 0 3
14461: PUSH
14462: LD_VAR 0 1
14466: GREATER
14467: OR
14468: IFFALSE 14472
// exit ;
14470: GO 14768
// if direction then
14472: LD_VAR 0 4
14476: IFFALSE 14540
// begin d := 1 ;
14478: LD_ADDR_VAR 0 9
14482: PUSH
14483: LD_INT 1
14485: ST_TO_ADDR
// if i_from > i_to then
14486: LD_VAR 0 2
14490: PUSH
14491: LD_VAR 0 3
14495: GREATER
14496: IFFALSE 14522
// length := ( array - i_from ) + i_to else
14498: LD_ADDR_VAR 0 11
14502: PUSH
14503: LD_VAR 0 1
14507: PUSH
14508: LD_VAR 0 2
14512: MINUS
14513: PUSH
14514: LD_VAR 0 3
14518: PLUS
14519: ST_TO_ADDR
14520: GO 14538
// length := i_to - i_from ;
14522: LD_ADDR_VAR 0 11
14526: PUSH
14527: LD_VAR 0 3
14531: PUSH
14532: LD_VAR 0 2
14536: MINUS
14537: ST_TO_ADDR
// end else
14538: GO 14601
// begin d := - 1 ;
14540: LD_ADDR_VAR 0 9
14544: PUSH
14545: LD_INT 1
14547: NEG
14548: ST_TO_ADDR
// if i_from > i_to then
14549: LD_VAR 0 2
14553: PUSH
14554: LD_VAR 0 3
14558: GREATER
14559: IFFALSE 14579
// length := i_from - i_to else
14561: LD_ADDR_VAR 0 11
14565: PUSH
14566: LD_VAR 0 2
14570: PUSH
14571: LD_VAR 0 3
14575: MINUS
14576: ST_TO_ADDR
14577: GO 14601
// length := ( array - i_to ) + i_from ;
14579: LD_ADDR_VAR 0 11
14583: PUSH
14584: LD_VAR 0 1
14588: PUSH
14589: LD_VAR 0 3
14593: MINUS
14594: PUSH
14595: LD_VAR 0 2
14599: PLUS
14600: ST_TO_ADDR
// end ; if not length then
14601: LD_VAR 0 11
14605: NOT
14606: IFFALSE 14610
// exit ;
14608: GO 14768
// tmp := array ;
14610: LD_ADDR_VAR 0 10
14614: PUSH
14615: LD_VAR 0 1
14619: ST_TO_ADDR
// for i = 1 to length do
14620: LD_ADDR_VAR 0 6
14624: PUSH
14625: DOUBLE
14626: LD_INT 1
14628: DEC
14629: ST_TO_ADDR
14630: LD_VAR 0 11
14634: PUSH
14635: FOR_TO
14636: IFFALSE 14756
// begin for j = 1 to array do
14638: LD_ADDR_VAR 0 7
14642: PUSH
14643: DOUBLE
14644: LD_INT 1
14646: DEC
14647: ST_TO_ADDR
14648: LD_VAR 0 1
14652: PUSH
14653: FOR_TO
14654: IFFALSE 14742
// begin k := j + d ;
14656: LD_ADDR_VAR 0 8
14660: PUSH
14661: LD_VAR 0 7
14665: PUSH
14666: LD_VAR 0 9
14670: PLUS
14671: ST_TO_ADDR
// if k > array then
14672: LD_VAR 0 8
14676: PUSH
14677: LD_VAR 0 1
14681: GREATER
14682: IFFALSE 14692
// k := 1 ;
14684: LD_ADDR_VAR 0 8
14688: PUSH
14689: LD_INT 1
14691: ST_TO_ADDR
// if not k then
14692: LD_VAR 0 8
14696: NOT
14697: IFFALSE 14709
// k := array ;
14699: LD_ADDR_VAR 0 8
14703: PUSH
14704: LD_VAR 0 1
14708: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14709: LD_ADDR_VAR 0 10
14713: PUSH
14714: LD_VAR 0 10
14718: PPUSH
14719: LD_VAR 0 8
14723: PPUSH
14724: LD_VAR 0 1
14728: PUSH
14729: LD_VAR 0 7
14733: ARRAY
14734: PPUSH
14735: CALL_OW 1
14739: ST_TO_ADDR
// end ;
14740: GO 14653
14742: POP
14743: POP
// array := tmp ;
14744: LD_ADDR_VAR 0 1
14748: PUSH
14749: LD_VAR 0 10
14753: ST_TO_ADDR
// end ;
14754: GO 14635
14756: POP
14757: POP
// result := array ;
14758: LD_ADDR_VAR 0 5
14762: PUSH
14763: LD_VAR 0 1
14767: ST_TO_ADDR
// end ;
14768: LD_VAR 0 5
14772: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14773: LD_INT 0
14775: PPUSH
14776: PPUSH
// result := 0 ;
14777: LD_ADDR_VAR 0 3
14781: PUSH
14782: LD_INT 0
14784: ST_TO_ADDR
// if not array or not value in array then
14785: LD_VAR 0 1
14789: NOT
14790: PUSH
14791: LD_VAR 0 2
14795: PUSH
14796: LD_VAR 0 1
14800: IN
14801: NOT
14802: OR
14803: IFFALSE 14807
// exit ;
14805: GO 14861
// for i = 1 to array do
14807: LD_ADDR_VAR 0 4
14811: PUSH
14812: DOUBLE
14813: LD_INT 1
14815: DEC
14816: ST_TO_ADDR
14817: LD_VAR 0 1
14821: PUSH
14822: FOR_TO
14823: IFFALSE 14859
// if value = array [ i ] then
14825: LD_VAR 0 2
14829: PUSH
14830: LD_VAR 0 1
14834: PUSH
14835: LD_VAR 0 4
14839: ARRAY
14840: EQUAL
14841: IFFALSE 14857
// begin result := i ;
14843: LD_ADDR_VAR 0 3
14847: PUSH
14848: LD_VAR 0 4
14852: ST_TO_ADDR
// exit ;
14853: POP
14854: POP
14855: GO 14861
// end ;
14857: GO 14822
14859: POP
14860: POP
// end ;
14861: LD_VAR 0 3
14865: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14866: LD_INT 0
14868: PPUSH
// vc_chassis := chassis ;
14869: LD_ADDR_OWVAR 37
14873: PUSH
14874: LD_VAR 0 1
14878: ST_TO_ADDR
// vc_engine := engine ;
14879: LD_ADDR_OWVAR 39
14883: PUSH
14884: LD_VAR 0 2
14888: ST_TO_ADDR
// vc_control := control ;
14889: LD_ADDR_OWVAR 38
14893: PUSH
14894: LD_VAR 0 3
14898: ST_TO_ADDR
// vc_weapon := weapon ;
14899: LD_ADDR_OWVAR 40
14903: PUSH
14904: LD_VAR 0 4
14908: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14909: LD_ADDR_OWVAR 41
14913: PUSH
14914: LD_VAR 0 5
14918: ST_TO_ADDR
// end ;
14919: LD_VAR 0 6
14923: RET
// export function WantPlant ( unit ) ; var task ; begin
14924: LD_INT 0
14926: PPUSH
14927: PPUSH
// result := false ;
14928: LD_ADDR_VAR 0 2
14932: PUSH
14933: LD_INT 0
14935: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14936: LD_ADDR_VAR 0 3
14940: PUSH
14941: LD_VAR 0 1
14945: PPUSH
14946: CALL_OW 437
14950: ST_TO_ADDR
// if task then
14951: LD_VAR 0 3
14955: IFFALSE 14983
// if task [ 1 ] [ 1 ] = p then
14957: LD_VAR 0 3
14961: PUSH
14962: LD_INT 1
14964: ARRAY
14965: PUSH
14966: LD_INT 1
14968: ARRAY
14969: PUSH
14970: LD_STRING p
14972: EQUAL
14973: IFFALSE 14983
// result := true ;
14975: LD_ADDR_VAR 0 2
14979: PUSH
14980: LD_INT 1
14982: ST_TO_ADDR
// end ;
14983: LD_VAR 0 2
14987: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14988: LD_INT 0
14990: PPUSH
14991: PPUSH
14992: PPUSH
14993: PPUSH
// if pos < 1 then
14994: LD_VAR 0 2
14998: PUSH
14999: LD_INT 1
15001: LESS
15002: IFFALSE 15006
// exit ;
15004: GO 15309
// if pos = 1 then
15006: LD_VAR 0 2
15010: PUSH
15011: LD_INT 1
15013: EQUAL
15014: IFFALSE 15047
// result := Replace ( arr , pos [ 1 ] , value ) else
15016: LD_ADDR_VAR 0 4
15020: PUSH
15021: LD_VAR 0 1
15025: PPUSH
15026: LD_VAR 0 2
15030: PUSH
15031: LD_INT 1
15033: ARRAY
15034: PPUSH
15035: LD_VAR 0 3
15039: PPUSH
15040: CALL_OW 1
15044: ST_TO_ADDR
15045: GO 15309
// begin tmp := arr ;
15047: LD_ADDR_VAR 0 6
15051: PUSH
15052: LD_VAR 0 1
15056: ST_TO_ADDR
// s_arr := [ tmp ] ;
15057: LD_ADDR_VAR 0 7
15061: PUSH
15062: LD_VAR 0 6
15066: PUSH
15067: EMPTY
15068: LIST
15069: ST_TO_ADDR
// for i = 1 to pos - 1 do
15070: LD_ADDR_VAR 0 5
15074: PUSH
15075: DOUBLE
15076: LD_INT 1
15078: DEC
15079: ST_TO_ADDR
15080: LD_VAR 0 2
15084: PUSH
15085: LD_INT 1
15087: MINUS
15088: PUSH
15089: FOR_TO
15090: IFFALSE 15135
// begin tmp := tmp [ pos [ i ] ] ;
15092: LD_ADDR_VAR 0 6
15096: PUSH
15097: LD_VAR 0 6
15101: PUSH
15102: LD_VAR 0 2
15106: PUSH
15107: LD_VAR 0 5
15111: ARRAY
15112: ARRAY
15113: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
15114: LD_ADDR_VAR 0 7
15118: PUSH
15119: LD_VAR 0 7
15123: PUSH
15124: LD_VAR 0 6
15128: PUSH
15129: EMPTY
15130: LIST
15131: ADD
15132: ST_TO_ADDR
// end ;
15133: GO 15089
15135: POP
15136: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
15137: LD_ADDR_VAR 0 6
15141: PUSH
15142: LD_VAR 0 6
15146: PPUSH
15147: LD_VAR 0 2
15151: PUSH
15152: LD_VAR 0 2
15156: ARRAY
15157: PPUSH
15158: LD_VAR 0 3
15162: PPUSH
15163: CALL_OW 1
15167: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15168: LD_ADDR_VAR 0 7
15172: PUSH
15173: LD_VAR 0 7
15177: PPUSH
15178: LD_VAR 0 7
15182: PPUSH
15183: LD_VAR 0 6
15187: PPUSH
15188: CALL_OW 1
15192: ST_TO_ADDR
// for i = s_arr downto 2 do
15193: LD_ADDR_VAR 0 5
15197: PUSH
15198: DOUBLE
15199: LD_VAR 0 7
15203: INC
15204: ST_TO_ADDR
15205: LD_INT 2
15207: PUSH
15208: FOR_DOWNTO
15209: IFFALSE 15293
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15211: LD_ADDR_VAR 0 6
15215: PUSH
15216: LD_VAR 0 7
15220: PUSH
15221: LD_VAR 0 5
15225: PUSH
15226: LD_INT 1
15228: MINUS
15229: ARRAY
15230: PPUSH
15231: LD_VAR 0 2
15235: PUSH
15236: LD_VAR 0 5
15240: PUSH
15241: LD_INT 1
15243: MINUS
15244: ARRAY
15245: PPUSH
15246: LD_VAR 0 7
15250: PUSH
15251: LD_VAR 0 5
15255: ARRAY
15256: PPUSH
15257: CALL_OW 1
15261: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15262: LD_ADDR_VAR 0 7
15266: PUSH
15267: LD_VAR 0 7
15271: PPUSH
15272: LD_VAR 0 5
15276: PUSH
15277: LD_INT 1
15279: MINUS
15280: PPUSH
15281: LD_VAR 0 6
15285: PPUSH
15286: CALL_OW 1
15290: ST_TO_ADDR
// end ;
15291: GO 15208
15293: POP
15294: POP
// result := s_arr [ 1 ] ;
15295: LD_ADDR_VAR 0 4
15299: PUSH
15300: LD_VAR 0 7
15304: PUSH
15305: LD_INT 1
15307: ARRAY
15308: ST_TO_ADDR
// end ; end ;
15309: LD_VAR 0 4
15313: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15314: LD_INT 0
15316: PPUSH
15317: PPUSH
// if not list then
15318: LD_VAR 0 1
15322: NOT
15323: IFFALSE 15327
// exit ;
15325: GO 15418
// i := list [ pos1 ] ;
15327: LD_ADDR_VAR 0 5
15331: PUSH
15332: LD_VAR 0 1
15336: PUSH
15337: LD_VAR 0 2
15341: ARRAY
15342: ST_TO_ADDR
// if not i then
15343: LD_VAR 0 5
15347: NOT
15348: IFFALSE 15352
// exit ;
15350: GO 15418
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15352: LD_ADDR_VAR 0 1
15356: PUSH
15357: LD_VAR 0 1
15361: PPUSH
15362: LD_VAR 0 2
15366: PPUSH
15367: LD_VAR 0 1
15371: PUSH
15372: LD_VAR 0 3
15376: ARRAY
15377: PPUSH
15378: CALL_OW 1
15382: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15383: LD_ADDR_VAR 0 1
15387: PUSH
15388: LD_VAR 0 1
15392: PPUSH
15393: LD_VAR 0 3
15397: PPUSH
15398: LD_VAR 0 5
15402: PPUSH
15403: CALL_OW 1
15407: ST_TO_ADDR
// result := list ;
15408: LD_ADDR_VAR 0 4
15412: PUSH
15413: LD_VAR 0 1
15417: ST_TO_ADDR
// end ;
15418: LD_VAR 0 4
15422: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15423: LD_INT 0
15425: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15426: LD_ADDR_VAR 0 5
15430: PUSH
15431: LD_VAR 0 1
15435: PPUSH
15436: CALL_OW 250
15440: PPUSH
15441: LD_VAR 0 1
15445: PPUSH
15446: CALL_OW 251
15450: PPUSH
15451: LD_VAR 0 2
15455: PPUSH
15456: LD_VAR 0 3
15460: PPUSH
15461: LD_VAR 0 4
15465: PPUSH
15466: CALL 15476 0 5
15470: ST_TO_ADDR
// end ;
15471: LD_VAR 0 5
15475: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15476: LD_INT 0
15478: PPUSH
15479: PPUSH
15480: PPUSH
15481: PPUSH
// if not list then
15482: LD_VAR 0 3
15486: NOT
15487: IFFALSE 15491
// exit ;
15489: GO 15879
// result := [ ] ;
15491: LD_ADDR_VAR 0 6
15495: PUSH
15496: EMPTY
15497: ST_TO_ADDR
// for i in list do
15498: LD_ADDR_VAR 0 7
15502: PUSH
15503: LD_VAR 0 3
15507: PUSH
15508: FOR_IN
15509: IFFALSE 15711
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15511: LD_ADDR_VAR 0 9
15515: PUSH
15516: LD_VAR 0 7
15520: PPUSH
15521: LD_VAR 0 1
15525: PPUSH
15526: LD_VAR 0 2
15530: PPUSH
15531: CALL_OW 297
15535: ST_TO_ADDR
// if not result then
15536: LD_VAR 0 6
15540: NOT
15541: IFFALSE 15567
// result := [ [ i , tmp ] ] else
15543: LD_ADDR_VAR 0 6
15547: PUSH
15548: LD_VAR 0 7
15552: PUSH
15553: LD_VAR 0 9
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PUSH
15562: EMPTY
15563: LIST
15564: ST_TO_ADDR
15565: GO 15709
// begin if result [ result ] [ 2 ] < tmp then
15567: LD_VAR 0 6
15571: PUSH
15572: LD_VAR 0 6
15576: ARRAY
15577: PUSH
15578: LD_INT 2
15580: ARRAY
15581: PUSH
15582: LD_VAR 0 9
15586: LESS
15587: IFFALSE 15629
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15589: LD_ADDR_VAR 0 6
15593: PUSH
15594: LD_VAR 0 6
15598: PPUSH
15599: LD_VAR 0 6
15603: PUSH
15604: LD_INT 1
15606: PLUS
15607: PPUSH
15608: LD_VAR 0 7
15612: PUSH
15613: LD_VAR 0 9
15617: PUSH
15618: EMPTY
15619: LIST
15620: LIST
15621: PPUSH
15622: CALL_OW 2
15626: ST_TO_ADDR
15627: GO 15709
// for j = 1 to result do
15629: LD_ADDR_VAR 0 8
15633: PUSH
15634: DOUBLE
15635: LD_INT 1
15637: DEC
15638: ST_TO_ADDR
15639: LD_VAR 0 6
15643: PUSH
15644: FOR_TO
15645: IFFALSE 15707
// begin if tmp < result [ j ] [ 2 ] then
15647: LD_VAR 0 9
15651: PUSH
15652: LD_VAR 0 6
15656: PUSH
15657: LD_VAR 0 8
15661: ARRAY
15662: PUSH
15663: LD_INT 2
15665: ARRAY
15666: LESS
15667: IFFALSE 15705
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15669: LD_ADDR_VAR 0 6
15673: PUSH
15674: LD_VAR 0 6
15678: PPUSH
15679: LD_VAR 0 8
15683: PPUSH
15684: LD_VAR 0 7
15688: PUSH
15689: LD_VAR 0 9
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PPUSH
15698: CALL_OW 2
15702: ST_TO_ADDR
// break ;
15703: GO 15707
// end ; end ;
15705: GO 15644
15707: POP
15708: POP
// end ; end ;
15709: GO 15508
15711: POP
15712: POP
// if result and not asc then
15713: LD_VAR 0 6
15717: PUSH
15718: LD_VAR 0 4
15722: NOT
15723: AND
15724: IFFALSE 15799
// begin tmp := result ;
15726: LD_ADDR_VAR 0 9
15730: PUSH
15731: LD_VAR 0 6
15735: ST_TO_ADDR
// for i = tmp downto 1 do
15736: LD_ADDR_VAR 0 7
15740: PUSH
15741: DOUBLE
15742: LD_VAR 0 9
15746: INC
15747: ST_TO_ADDR
15748: LD_INT 1
15750: PUSH
15751: FOR_DOWNTO
15752: IFFALSE 15797
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15754: LD_ADDR_VAR 0 6
15758: PUSH
15759: LD_VAR 0 6
15763: PPUSH
15764: LD_VAR 0 9
15768: PUSH
15769: LD_VAR 0 7
15773: MINUS
15774: PUSH
15775: LD_INT 1
15777: PLUS
15778: PPUSH
15779: LD_VAR 0 9
15783: PUSH
15784: LD_VAR 0 7
15788: ARRAY
15789: PPUSH
15790: CALL_OW 1
15794: ST_TO_ADDR
15795: GO 15751
15797: POP
15798: POP
// end ; tmp := [ ] ;
15799: LD_ADDR_VAR 0 9
15803: PUSH
15804: EMPTY
15805: ST_TO_ADDR
// if mode then
15806: LD_VAR 0 5
15810: IFFALSE 15879
// begin for i = 1 to result do
15812: LD_ADDR_VAR 0 7
15816: PUSH
15817: DOUBLE
15818: LD_INT 1
15820: DEC
15821: ST_TO_ADDR
15822: LD_VAR 0 6
15826: PUSH
15827: FOR_TO
15828: IFFALSE 15867
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15830: LD_ADDR_VAR 0 9
15834: PUSH
15835: LD_VAR 0 9
15839: PPUSH
15840: LD_VAR 0 7
15844: PPUSH
15845: LD_VAR 0 6
15849: PUSH
15850: LD_VAR 0 7
15854: ARRAY
15855: PUSH
15856: LD_INT 1
15858: ARRAY
15859: PPUSH
15860: CALL_OW 1
15864: ST_TO_ADDR
15865: GO 15827
15867: POP
15868: POP
// result := tmp ;
15869: LD_ADDR_VAR 0 6
15873: PUSH
15874: LD_VAR 0 9
15878: ST_TO_ADDR
// end ; end ;
15879: LD_VAR 0 6
15883: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15884: LD_INT 0
15886: PPUSH
15887: PPUSH
15888: PPUSH
15889: PPUSH
15890: PPUSH
15891: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15892: LD_ADDR_VAR 0 5
15896: PUSH
15897: LD_INT 0
15899: PUSH
15900: LD_INT 0
15902: PUSH
15903: LD_INT 0
15905: PUSH
15906: EMPTY
15907: PUSH
15908: EMPTY
15909: LIST
15910: LIST
15911: LIST
15912: LIST
15913: ST_TO_ADDR
// if not x or not y then
15914: LD_VAR 0 2
15918: NOT
15919: PUSH
15920: LD_VAR 0 3
15924: NOT
15925: OR
15926: IFFALSE 15930
// exit ;
15928: GO 17580
// if not range then
15930: LD_VAR 0 4
15934: NOT
15935: IFFALSE 15945
// range := 10 ;
15937: LD_ADDR_VAR 0 4
15941: PUSH
15942: LD_INT 10
15944: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15945: LD_ADDR_VAR 0 8
15949: PUSH
15950: LD_INT 81
15952: PUSH
15953: LD_VAR 0 1
15957: PUSH
15958: EMPTY
15959: LIST
15960: LIST
15961: PUSH
15962: LD_INT 92
15964: PUSH
15965: LD_VAR 0 2
15969: PUSH
15970: LD_VAR 0 3
15974: PUSH
15975: LD_VAR 0 4
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: LIST
15984: LIST
15985: PUSH
15986: LD_INT 3
15988: PUSH
15989: LD_INT 21
15991: PUSH
15992: LD_INT 3
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PUSH
16003: EMPTY
16004: LIST
16005: LIST
16006: LIST
16007: PPUSH
16008: CALL_OW 69
16012: ST_TO_ADDR
// if not tmp then
16013: LD_VAR 0 8
16017: NOT
16018: IFFALSE 16022
// exit ;
16020: GO 17580
// for i in tmp do
16022: LD_ADDR_VAR 0 6
16026: PUSH
16027: LD_VAR 0 8
16031: PUSH
16032: FOR_IN
16033: IFFALSE 17555
// begin points := [ 0 , 0 , 0 ] ;
16035: LD_ADDR_VAR 0 9
16039: PUSH
16040: LD_INT 0
16042: PUSH
16043: LD_INT 0
16045: PUSH
16046: LD_INT 0
16048: PUSH
16049: EMPTY
16050: LIST
16051: LIST
16052: LIST
16053: ST_TO_ADDR
// bpoints := 1 ;
16054: LD_ADDR_VAR 0 10
16058: PUSH
16059: LD_INT 1
16061: ST_TO_ADDR
// case GetType ( i ) of unit_human :
16062: LD_VAR 0 6
16066: PPUSH
16067: CALL_OW 247
16071: PUSH
16072: LD_INT 1
16074: DOUBLE
16075: EQUAL
16076: IFTRUE 16080
16078: GO 16658
16080: POP
// begin if GetClass ( i ) = 1 then
16081: LD_VAR 0 6
16085: PPUSH
16086: CALL_OW 257
16090: PUSH
16091: LD_INT 1
16093: EQUAL
16094: IFFALSE 16115
// points := [ 10 , 5 , 3 ] ;
16096: LD_ADDR_VAR 0 9
16100: PUSH
16101: LD_INT 10
16103: PUSH
16104: LD_INT 5
16106: PUSH
16107: LD_INT 3
16109: PUSH
16110: EMPTY
16111: LIST
16112: LIST
16113: LIST
16114: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16115: LD_VAR 0 6
16119: PPUSH
16120: CALL_OW 257
16124: PUSH
16125: LD_INT 2
16127: PUSH
16128: LD_INT 3
16130: PUSH
16131: LD_INT 4
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: LIST
16138: IN
16139: IFFALSE 16160
// points := [ 3 , 2 , 1 ] ;
16141: LD_ADDR_VAR 0 9
16145: PUSH
16146: LD_INT 3
16148: PUSH
16149: LD_INT 2
16151: PUSH
16152: LD_INT 1
16154: PUSH
16155: EMPTY
16156: LIST
16157: LIST
16158: LIST
16159: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16160: LD_VAR 0 6
16164: PPUSH
16165: CALL_OW 257
16169: PUSH
16170: LD_INT 5
16172: EQUAL
16173: IFFALSE 16194
// points := [ 130 , 5 , 2 ] ;
16175: LD_ADDR_VAR 0 9
16179: PUSH
16180: LD_INT 130
16182: PUSH
16183: LD_INT 5
16185: PUSH
16186: LD_INT 2
16188: PUSH
16189: EMPTY
16190: LIST
16191: LIST
16192: LIST
16193: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16194: LD_VAR 0 6
16198: PPUSH
16199: CALL_OW 257
16203: PUSH
16204: LD_INT 8
16206: EQUAL
16207: IFFALSE 16228
// points := [ 35 , 35 , 30 ] ;
16209: LD_ADDR_VAR 0 9
16213: PUSH
16214: LD_INT 35
16216: PUSH
16217: LD_INT 35
16219: PUSH
16220: LD_INT 30
16222: PUSH
16223: EMPTY
16224: LIST
16225: LIST
16226: LIST
16227: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16228: LD_VAR 0 6
16232: PPUSH
16233: CALL_OW 257
16237: PUSH
16238: LD_INT 9
16240: EQUAL
16241: IFFALSE 16262
// points := [ 20 , 55 , 40 ] ;
16243: LD_ADDR_VAR 0 9
16247: PUSH
16248: LD_INT 20
16250: PUSH
16251: LD_INT 55
16253: PUSH
16254: LD_INT 40
16256: PUSH
16257: EMPTY
16258: LIST
16259: LIST
16260: LIST
16261: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16262: LD_VAR 0 6
16266: PPUSH
16267: CALL_OW 257
16271: PUSH
16272: LD_INT 12
16274: PUSH
16275: LD_INT 16
16277: PUSH
16278: EMPTY
16279: LIST
16280: LIST
16281: IN
16282: IFFALSE 16303
// points := [ 5 , 3 , 2 ] ;
16284: LD_ADDR_VAR 0 9
16288: PUSH
16289: LD_INT 5
16291: PUSH
16292: LD_INT 3
16294: PUSH
16295: LD_INT 2
16297: PUSH
16298: EMPTY
16299: LIST
16300: LIST
16301: LIST
16302: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16303: LD_VAR 0 6
16307: PPUSH
16308: CALL_OW 257
16312: PUSH
16313: LD_INT 17
16315: EQUAL
16316: IFFALSE 16337
// points := [ 100 , 50 , 75 ] ;
16318: LD_ADDR_VAR 0 9
16322: PUSH
16323: LD_INT 100
16325: PUSH
16326: LD_INT 50
16328: PUSH
16329: LD_INT 75
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: LIST
16336: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16337: LD_VAR 0 6
16341: PPUSH
16342: CALL_OW 257
16346: PUSH
16347: LD_INT 15
16349: EQUAL
16350: IFFALSE 16371
// points := [ 10 , 5 , 3 ] ;
16352: LD_ADDR_VAR 0 9
16356: PUSH
16357: LD_INT 10
16359: PUSH
16360: LD_INT 5
16362: PUSH
16363: LD_INT 3
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: LIST
16370: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16371: LD_VAR 0 6
16375: PPUSH
16376: CALL_OW 257
16380: PUSH
16381: LD_INT 14
16383: EQUAL
16384: IFFALSE 16405
// points := [ 10 , 0 , 0 ] ;
16386: LD_ADDR_VAR 0 9
16390: PUSH
16391: LD_INT 10
16393: PUSH
16394: LD_INT 0
16396: PUSH
16397: LD_INT 0
16399: PUSH
16400: EMPTY
16401: LIST
16402: LIST
16403: LIST
16404: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16405: LD_VAR 0 6
16409: PPUSH
16410: CALL_OW 257
16414: PUSH
16415: LD_INT 11
16417: EQUAL
16418: IFFALSE 16439
// points := [ 30 , 10 , 5 ] ;
16420: LD_ADDR_VAR 0 9
16424: PUSH
16425: LD_INT 30
16427: PUSH
16428: LD_INT 10
16430: PUSH
16431: LD_INT 5
16433: PUSH
16434: EMPTY
16435: LIST
16436: LIST
16437: LIST
16438: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16439: LD_VAR 0 1
16443: PPUSH
16444: LD_INT 5
16446: PPUSH
16447: CALL_OW 321
16451: PUSH
16452: LD_INT 2
16454: EQUAL
16455: IFFALSE 16472
// bpoints := bpoints * 1.8 ;
16457: LD_ADDR_VAR 0 10
16461: PUSH
16462: LD_VAR 0 10
16466: PUSH
16467: LD_REAL  1.80000000000000E+0000
16470: MUL
16471: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16472: LD_VAR 0 6
16476: PPUSH
16477: CALL_OW 257
16481: PUSH
16482: LD_INT 1
16484: PUSH
16485: LD_INT 2
16487: PUSH
16488: LD_INT 3
16490: PUSH
16491: LD_INT 4
16493: PUSH
16494: EMPTY
16495: LIST
16496: LIST
16497: LIST
16498: LIST
16499: IN
16500: PUSH
16501: LD_VAR 0 1
16505: PPUSH
16506: LD_INT 51
16508: PPUSH
16509: CALL_OW 321
16513: PUSH
16514: LD_INT 2
16516: EQUAL
16517: AND
16518: IFFALSE 16535
// bpoints := bpoints * 1.2 ;
16520: LD_ADDR_VAR 0 10
16524: PUSH
16525: LD_VAR 0 10
16529: PUSH
16530: LD_REAL  1.20000000000000E+0000
16533: MUL
16534: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16535: LD_VAR 0 6
16539: PPUSH
16540: CALL_OW 257
16544: PUSH
16545: LD_INT 5
16547: PUSH
16548: LD_INT 7
16550: PUSH
16551: LD_INT 9
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: LIST
16558: IN
16559: PUSH
16560: LD_VAR 0 1
16564: PPUSH
16565: LD_INT 52
16567: PPUSH
16568: CALL_OW 321
16572: PUSH
16573: LD_INT 2
16575: EQUAL
16576: AND
16577: IFFALSE 16594
// bpoints := bpoints * 1.5 ;
16579: LD_ADDR_VAR 0 10
16583: PUSH
16584: LD_VAR 0 10
16588: PUSH
16589: LD_REAL  1.50000000000000E+0000
16592: MUL
16593: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16594: LD_VAR 0 1
16598: PPUSH
16599: LD_INT 66
16601: PPUSH
16602: CALL_OW 321
16606: PUSH
16607: LD_INT 2
16609: EQUAL
16610: IFFALSE 16627
// bpoints := bpoints * 1.1 ;
16612: LD_ADDR_VAR 0 10
16616: PUSH
16617: LD_VAR 0 10
16621: PUSH
16622: LD_REAL  1.10000000000000E+0000
16625: MUL
16626: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16627: LD_ADDR_VAR 0 10
16631: PUSH
16632: LD_VAR 0 10
16636: PUSH
16637: LD_VAR 0 6
16641: PPUSH
16642: LD_INT 1
16644: PPUSH
16645: CALL_OW 259
16649: PUSH
16650: LD_REAL  1.15000000000000E+0000
16653: MUL
16654: MUL
16655: ST_TO_ADDR
// end ; unit_vehicle :
16656: GO 17484
16658: LD_INT 2
16660: DOUBLE
16661: EQUAL
16662: IFTRUE 16666
16664: GO 17472
16666: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16667: LD_VAR 0 6
16671: PPUSH
16672: CALL_OW 264
16676: PUSH
16677: LD_INT 2
16679: PUSH
16680: LD_INT 42
16682: PUSH
16683: LD_INT 24
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: LIST
16690: IN
16691: IFFALSE 16712
// points := [ 25 , 5 , 3 ] ;
16693: LD_ADDR_VAR 0 9
16697: PUSH
16698: LD_INT 25
16700: PUSH
16701: LD_INT 5
16703: PUSH
16704: LD_INT 3
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: LIST
16711: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16712: LD_VAR 0 6
16716: PPUSH
16717: CALL_OW 264
16721: PUSH
16722: LD_INT 4
16724: PUSH
16725: LD_INT 43
16727: PUSH
16728: LD_INT 25
16730: PUSH
16731: EMPTY
16732: LIST
16733: LIST
16734: LIST
16735: IN
16736: IFFALSE 16757
// points := [ 40 , 15 , 5 ] ;
16738: LD_ADDR_VAR 0 9
16742: PUSH
16743: LD_INT 40
16745: PUSH
16746: LD_INT 15
16748: PUSH
16749: LD_INT 5
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: LIST
16756: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16757: LD_VAR 0 6
16761: PPUSH
16762: CALL_OW 264
16766: PUSH
16767: LD_INT 3
16769: PUSH
16770: LD_INT 23
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: IN
16777: IFFALSE 16798
// points := [ 7 , 25 , 8 ] ;
16779: LD_ADDR_VAR 0 9
16783: PUSH
16784: LD_INT 7
16786: PUSH
16787: LD_INT 25
16789: PUSH
16790: LD_INT 8
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: LIST
16797: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16798: LD_VAR 0 6
16802: PPUSH
16803: CALL_OW 264
16807: PUSH
16808: LD_INT 5
16810: PUSH
16811: LD_INT 27
16813: PUSH
16814: LD_INT 44
16816: PUSH
16817: EMPTY
16818: LIST
16819: LIST
16820: LIST
16821: IN
16822: IFFALSE 16843
// points := [ 14 , 50 , 16 ] ;
16824: LD_ADDR_VAR 0 9
16828: PUSH
16829: LD_INT 14
16831: PUSH
16832: LD_INT 50
16834: PUSH
16835: LD_INT 16
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: LIST
16842: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16843: LD_VAR 0 6
16847: PPUSH
16848: CALL_OW 264
16852: PUSH
16853: LD_INT 6
16855: PUSH
16856: LD_INT 46
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: IN
16863: IFFALSE 16884
// points := [ 32 , 120 , 70 ] ;
16865: LD_ADDR_VAR 0 9
16869: PUSH
16870: LD_INT 32
16872: PUSH
16873: LD_INT 120
16875: PUSH
16876: LD_INT 70
16878: PUSH
16879: EMPTY
16880: LIST
16881: LIST
16882: LIST
16883: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16884: LD_VAR 0 6
16888: PPUSH
16889: CALL_OW 264
16893: PUSH
16894: LD_INT 7
16896: PUSH
16897: LD_INT 28
16899: PUSH
16900: LD_INT 45
16902: PUSH
16903: LD_INT 92
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: IN
16912: IFFALSE 16933
// points := [ 35 , 20 , 45 ] ;
16914: LD_ADDR_VAR 0 9
16918: PUSH
16919: LD_INT 35
16921: PUSH
16922: LD_INT 20
16924: PUSH
16925: LD_INT 45
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: LIST
16932: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16933: LD_VAR 0 6
16937: PPUSH
16938: CALL_OW 264
16942: PUSH
16943: LD_INT 47
16945: PUSH
16946: EMPTY
16947: LIST
16948: IN
16949: IFFALSE 16970
// points := [ 67 , 45 , 75 ] ;
16951: LD_ADDR_VAR 0 9
16955: PUSH
16956: LD_INT 67
16958: PUSH
16959: LD_INT 45
16961: PUSH
16962: LD_INT 75
16964: PUSH
16965: EMPTY
16966: LIST
16967: LIST
16968: LIST
16969: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16970: LD_VAR 0 6
16974: PPUSH
16975: CALL_OW 264
16979: PUSH
16980: LD_INT 26
16982: PUSH
16983: EMPTY
16984: LIST
16985: IN
16986: IFFALSE 17007
// points := [ 120 , 30 , 80 ] ;
16988: LD_ADDR_VAR 0 9
16992: PUSH
16993: LD_INT 120
16995: PUSH
16996: LD_INT 30
16998: PUSH
16999: LD_INT 80
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: LIST
17006: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
17007: LD_VAR 0 6
17011: PPUSH
17012: CALL_OW 264
17016: PUSH
17017: LD_INT 22
17019: PUSH
17020: EMPTY
17021: LIST
17022: IN
17023: IFFALSE 17044
// points := [ 40 , 1 , 1 ] ;
17025: LD_ADDR_VAR 0 9
17029: PUSH
17030: LD_INT 40
17032: PUSH
17033: LD_INT 1
17035: PUSH
17036: LD_INT 1
17038: PUSH
17039: EMPTY
17040: LIST
17041: LIST
17042: LIST
17043: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
17044: LD_VAR 0 6
17048: PPUSH
17049: CALL_OW 264
17053: PUSH
17054: LD_INT 29
17056: PUSH
17057: EMPTY
17058: LIST
17059: IN
17060: IFFALSE 17081
// points := [ 70 , 200 , 400 ] ;
17062: LD_ADDR_VAR 0 9
17066: PUSH
17067: LD_INT 70
17069: PUSH
17070: LD_INT 200
17072: PUSH
17073: LD_INT 400
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: LIST
17080: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17081: LD_VAR 0 6
17085: PPUSH
17086: CALL_OW 264
17090: PUSH
17091: LD_INT 14
17093: PUSH
17094: LD_INT 53
17096: PUSH
17097: EMPTY
17098: LIST
17099: LIST
17100: IN
17101: IFFALSE 17122
// points := [ 40 , 10 , 20 ] ;
17103: LD_ADDR_VAR 0 9
17107: PUSH
17108: LD_INT 40
17110: PUSH
17111: LD_INT 10
17113: PUSH
17114: LD_INT 20
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: LIST
17121: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17122: LD_VAR 0 6
17126: PPUSH
17127: CALL_OW 264
17131: PUSH
17132: LD_INT 9
17134: PUSH
17135: EMPTY
17136: LIST
17137: IN
17138: IFFALSE 17159
// points := [ 5 , 70 , 20 ] ;
17140: LD_ADDR_VAR 0 9
17144: PUSH
17145: LD_INT 5
17147: PUSH
17148: LD_INT 70
17150: PUSH
17151: LD_INT 20
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: LIST
17158: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17159: LD_VAR 0 6
17163: PPUSH
17164: CALL_OW 264
17168: PUSH
17169: LD_INT 10
17171: PUSH
17172: EMPTY
17173: LIST
17174: IN
17175: IFFALSE 17196
// points := [ 35 , 110 , 70 ] ;
17177: LD_ADDR_VAR 0 9
17181: PUSH
17182: LD_INT 35
17184: PUSH
17185: LD_INT 110
17187: PUSH
17188: LD_INT 70
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: LIST
17195: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17196: LD_VAR 0 6
17200: PPUSH
17201: CALL_OW 265
17205: PUSH
17206: LD_INT 25
17208: EQUAL
17209: IFFALSE 17230
// points := [ 80 , 65 , 100 ] ;
17211: LD_ADDR_VAR 0 9
17215: PUSH
17216: LD_INT 80
17218: PUSH
17219: LD_INT 65
17221: PUSH
17222: LD_INT 100
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17230: LD_VAR 0 6
17234: PPUSH
17235: CALL_OW 263
17239: PUSH
17240: LD_INT 1
17242: EQUAL
17243: IFFALSE 17278
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17245: LD_ADDR_VAR 0 10
17249: PUSH
17250: LD_VAR 0 10
17254: PUSH
17255: LD_VAR 0 6
17259: PPUSH
17260: CALL_OW 311
17264: PPUSH
17265: LD_INT 3
17267: PPUSH
17268: CALL_OW 259
17272: PUSH
17273: LD_INT 4
17275: MUL
17276: MUL
17277: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17278: LD_VAR 0 6
17282: PPUSH
17283: CALL_OW 263
17287: PUSH
17288: LD_INT 2
17290: EQUAL
17291: IFFALSE 17342
// begin j := IsControledBy ( i ) ;
17293: LD_ADDR_VAR 0 7
17297: PUSH
17298: LD_VAR 0 6
17302: PPUSH
17303: CALL_OW 312
17307: ST_TO_ADDR
// if j then
17308: LD_VAR 0 7
17312: IFFALSE 17342
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17314: LD_ADDR_VAR 0 10
17318: PUSH
17319: LD_VAR 0 10
17323: PUSH
17324: LD_VAR 0 7
17328: PPUSH
17329: LD_INT 3
17331: PPUSH
17332: CALL_OW 259
17336: PUSH
17337: LD_INT 3
17339: MUL
17340: MUL
17341: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17342: LD_VAR 0 6
17346: PPUSH
17347: CALL_OW 264
17351: PUSH
17352: LD_INT 5
17354: PUSH
17355: LD_INT 6
17357: PUSH
17358: LD_INT 46
17360: PUSH
17361: LD_INT 44
17363: PUSH
17364: LD_INT 47
17366: PUSH
17367: LD_INT 45
17369: PUSH
17370: LD_INT 28
17372: PUSH
17373: LD_INT 7
17375: PUSH
17376: LD_INT 27
17378: PUSH
17379: LD_INT 29
17381: PUSH
17382: EMPTY
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: LIST
17388: LIST
17389: LIST
17390: LIST
17391: LIST
17392: LIST
17393: IN
17394: PUSH
17395: LD_VAR 0 1
17399: PPUSH
17400: LD_INT 52
17402: PPUSH
17403: CALL_OW 321
17407: PUSH
17408: LD_INT 2
17410: EQUAL
17411: AND
17412: IFFALSE 17429
// bpoints := bpoints * 1.2 ;
17414: LD_ADDR_VAR 0 10
17418: PUSH
17419: LD_VAR 0 10
17423: PUSH
17424: LD_REAL  1.20000000000000E+0000
17427: MUL
17428: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17429: LD_VAR 0 6
17433: PPUSH
17434: CALL_OW 264
17438: PUSH
17439: LD_INT 6
17441: PUSH
17442: LD_INT 46
17444: PUSH
17445: LD_INT 47
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: LIST
17452: IN
17453: IFFALSE 17470
// bpoints := bpoints * 1.2 ;
17455: LD_ADDR_VAR 0 10
17459: PUSH
17460: LD_VAR 0 10
17464: PUSH
17465: LD_REAL  1.20000000000000E+0000
17468: MUL
17469: ST_TO_ADDR
// end ; unit_building :
17470: GO 17484
17472: LD_INT 3
17474: DOUBLE
17475: EQUAL
17476: IFTRUE 17480
17478: GO 17483
17480: POP
// ; end ;
17481: GO 17484
17483: POP
// for j = 1 to 3 do
17484: LD_ADDR_VAR 0 7
17488: PUSH
17489: DOUBLE
17490: LD_INT 1
17492: DEC
17493: ST_TO_ADDR
17494: LD_INT 3
17496: PUSH
17497: FOR_TO
17498: IFFALSE 17551
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17500: LD_ADDR_VAR 0 5
17504: PUSH
17505: LD_VAR 0 5
17509: PPUSH
17510: LD_VAR 0 7
17514: PPUSH
17515: LD_VAR 0 5
17519: PUSH
17520: LD_VAR 0 7
17524: ARRAY
17525: PUSH
17526: LD_VAR 0 9
17530: PUSH
17531: LD_VAR 0 7
17535: ARRAY
17536: PUSH
17537: LD_VAR 0 10
17541: MUL
17542: PLUS
17543: PPUSH
17544: CALL_OW 1
17548: ST_TO_ADDR
17549: GO 17497
17551: POP
17552: POP
// end ;
17553: GO 16032
17555: POP
17556: POP
// result := Replace ( result , 4 , tmp ) ;
17557: LD_ADDR_VAR 0 5
17561: PUSH
17562: LD_VAR 0 5
17566: PPUSH
17567: LD_INT 4
17569: PPUSH
17570: LD_VAR 0 8
17574: PPUSH
17575: CALL_OW 1
17579: ST_TO_ADDR
// end ;
17580: LD_VAR 0 5
17584: RET
// export function DangerAtRange ( unit , range ) ; begin
17585: LD_INT 0
17587: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17588: LD_ADDR_VAR 0 3
17592: PUSH
17593: LD_VAR 0 1
17597: PPUSH
17598: CALL_OW 255
17602: PPUSH
17603: LD_VAR 0 1
17607: PPUSH
17608: CALL_OW 250
17612: PPUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL_OW 251
17622: PPUSH
17623: LD_VAR 0 2
17627: PPUSH
17628: CALL 15884 0 4
17632: ST_TO_ADDR
// end ;
17633: LD_VAR 0 3
17637: RET
// export function DangerInArea ( side , area ) ; begin
17638: LD_INT 0
17640: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17641: LD_ADDR_VAR 0 3
17645: PUSH
17646: LD_VAR 0 2
17650: PPUSH
17651: LD_INT 81
17653: PUSH
17654: LD_VAR 0 1
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: PPUSH
17663: CALL_OW 70
17667: ST_TO_ADDR
// end ;
17668: LD_VAR 0 3
17672: RET
// export function IsExtension ( b ) ; begin
17673: LD_INT 0
17675: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17676: LD_ADDR_VAR 0 2
17680: PUSH
17681: LD_VAR 0 1
17685: PUSH
17686: LD_INT 23
17688: PUSH
17689: LD_INT 20
17691: PUSH
17692: LD_INT 22
17694: PUSH
17695: LD_INT 17
17697: PUSH
17698: LD_INT 24
17700: PUSH
17701: LD_INT 21
17703: PUSH
17704: LD_INT 19
17706: PUSH
17707: LD_INT 16
17709: PUSH
17710: LD_INT 25
17712: PUSH
17713: LD_INT 18
17715: PUSH
17716: EMPTY
17717: LIST
17718: LIST
17719: LIST
17720: LIST
17721: LIST
17722: LIST
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: IN
17728: ST_TO_ADDR
// end ;
17729: LD_VAR 0 2
17733: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17734: LD_INT 0
17736: PPUSH
17737: PPUSH
17738: PPUSH
// result := [ ] ;
17739: LD_ADDR_VAR 0 4
17743: PUSH
17744: EMPTY
17745: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17746: LD_ADDR_VAR 0 5
17750: PUSH
17751: LD_VAR 0 2
17755: PPUSH
17756: LD_INT 21
17758: PUSH
17759: LD_INT 3
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: PPUSH
17766: CALL_OW 70
17770: ST_TO_ADDR
// if not tmp then
17771: LD_VAR 0 5
17775: NOT
17776: IFFALSE 17780
// exit ;
17778: GO 17844
// if checkLink then
17780: LD_VAR 0 3
17784: IFFALSE 17834
// begin for i in tmp do
17786: LD_ADDR_VAR 0 6
17790: PUSH
17791: LD_VAR 0 5
17795: PUSH
17796: FOR_IN
17797: IFFALSE 17832
// if GetBase ( i ) <> base then
17799: LD_VAR 0 6
17803: PPUSH
17804: CALL_OW 274
17808: PUSH
17809: LD_VAR 0 1
17813: NONEQUAL
17814: IFFALSE 17830
// ComLinkToBase ( base , i ) ;
17816: LD_VAR 0 1
17820: PPUSH
17821: LD_VAR 0 6
17825: PPUSH
17826: CALL_OW 169
17830: GO 17796
17832: POP
17833: POP
// end ; result := tmp ;
17834: LD_ADDR_VAR 0 4
17838: PUSH
17839: LD_VAR 0 5
17843: ST_TO_ADDR
// end ;
17844: LD_VAR 0 4
17848: RET
// export function ComComplete ( units , b ) ; var i ; begin
17849: LD_INT 0
17851: PPUSH
17852: PPUSH
// if not units then
17853: LD_VAR 0 1
17857: NOT
17858: IFFALSE 17862
// exit ;
17860: GO 17952
// for i in units do
17862: LD_ADDR_VAR 0 4
17866: PUSH
17867: LD_VAR 0 1
17871: PUSH
17872: FOR_IN
17873: IFFALSE 17950
// if BuildingStatus ( b ) = bs_build then
17875: LD_VAR 0 2
17879: PPUSH
17880: CALL_OW 461
17884: PUSH
17885: LD_INT 1
17887: EQUAL
17888: IFFALSE 17948
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17890: LD_VAR 0 4
17894: PPUSH
17895: LD_STRING h
17897: PUSH
17898: LD_VAR 0 2
17902: PPUSH
17903: CALL_OW 250
17907: PUSH
17908: LD_VAR 0 2
17912: PPUSH
17913: CALL_OW 251
17917: PUSH
17918: LD_VAR 0 2
17922: PUSH
17923: LD_INT 0
17925: PUSH
17926: LD_INT 0
17928: PUSH
17929: LD_INT 0
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: LIST
17938: LIST
17939: LIST
17940: PUSH
17941: EMPTY
17942: LIST
17943: PPUSH
17944: CALL_OW 446
17948: GO 17872
17950: POP
17951: POP
// end ;
17952: LD_VAR 0 3
17956: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17957: LD_INT 0
17959: PPUSH
17960: PPUSH
17961: PPUSH
17962: PPUSH
17963: PPUSH
17964: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17965: LD_VAR 0 1
17969: NOT
17970: PUSH
17971: LD_VAR 0 1
17975: PPUSH
17976: CALL_OW 263
17980: PUSH
17981: LD_INT 2
17983: NONEQUAL
17984: OR
17985: IFFALSE 17989
// exit ;
17987: GO 18305
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17989: LD_ADDR_VAR 0 6
17993: PUSH
17994: LD_INT 22
17996: PUSH
17997: LD_VAR 0 1
18001: PPUSH
18002: CALL_OW 255
18006: PUSH
18007: EMPTY
18008: LIST
18009: LIST
18010: PUSH
18011: LD_INT 2
18013: PUSH
18014: LD_INT 30
18016: PUSH
18017: LD_INT 36
18019: PUSH
18020: EMPTY
18021: LIST
18022: LIST
18023: PUSH
18024: LD_INT 34
18026: PUSH
18027: LD_INT 31
18029: PUSH
18030: EMPTY
18031: LIST
18032: LIST
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: LIST
18038: PUSH
18039: EMPTY
18040: LIST
18041: LIST
18042: PPUSH
18043: CALL_OW 69
18047: ST_TO_ADDR
// if not tmp then
18048: LD_VAR 0 6
18052: NOT
18053: IFFALSE 18057
// exit ;
18055: GO 18305
// result := [ ] ;
18057: LD_ADDR_VAR 0 2
18061: PUSH
18062: EMPTY
18063: ST_TO_ADDR
// for i in tmp do
18064: LD_ADDR_VAR 0 3
18068: PUSH
18069: LD_VAR 0 6
18073: PUSH
18074: FOR_IN
18075: IFFALSE 18146
// begin t := UnitsInside ( i ) ;
18077: LD_ADDR_VAR 0 4
18081: PUSH
18082: LD_VAR 0 3
18086: PPUSH
18087: CALL_OW 313
18091: ST_TO_ADDR
// if t then
18092: LD_VAR 0 4
18096: IFFALSE 18144
// for j in t do
18098: LD_ADDR_VAR 0 7
18102: PUSH
18103: LD_VAR 0 4
18107: PUSH
18108: FOR_IN
18109: IFFALSE 18142
// result := Replace ( result , result + 1 , j ) ;
18111: LD_ADDR_VAR 0 2
18115: PUSH
18116: LD_VAR 0 2
18120: PPUSH
18121: LD_VAR 0 2
18125: PUSH
18126: LD_INT 1
18128: PLUS
18129: PPUSH
18130: LD_VAR 0 7
18134: PPUSH
18135: CALL_OW 1
18139: ST_TO_ADDR
18140: GO 18108
18142: POP
18143: POP
// end ;
18144: GO 18074
18146: POP
18147: POP
// if not result then
18148: LD_VAR 0 2
18152: NOT
18153: IFFALSE 18157
// exit ;
18155: GO 18305
// mech := result [ 1 ] ;
18157: LD_ADDR_VAR 0 5
18161: PUSH
18162: LD_VAR 0 2
18166: PUSH
18167: LD_INT 1
18169: ARRAY
18170: ST_TO_ADDR
// if result > 1 then
18171: LD_VAR 0 2
18175: PUSH
18176: LD_INT 1
18178: GREATER
18179: IFFALSE 18291
// begin for i = 2 to result do
18181: LD_ADDR_VAR 0 3
18185: PUSH
18186: DOUBLE
18187: LD_INT 2
18189: DEC
18190: ST_TO_ADDR
18191: LD_VAR 0 2
18195: PUSH
18196: FOR_TO
18197: IFFALSE 18289
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18199: LD_ADDR_VAR 0 4
18203: PUSH
18204: LD_VAR 0 2
18208: PUSH
18209: LD_VAR 0 3
18213: ARRAY
18214: PPUSH
18215: LD_INT 3
18217: PPUSH
18218: CALL_OW 259
18222: PUSH
18223: LD_VAR 0 2
18227: PUSH
18228: LD_VAR 0 3
18232: ARRAY
18233: PPUSH
18234: CALL_OW 432
18238: MINUS
18239: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18240: LD_VAR 0 4
18244: PUSH
18245: LD_VAR 0 5
18249: PPUSH
18250: LD_INT 3
18252: PPUSH
18253: CALL_OW 259
18257: PUSH
18258: LD_VAR 0 5
18262: PPUSH
18263: CALL_OW 432
18267: MINUS
18268: GREATEREQUAL
18269: IFFALSE 18287
// mech := result [ i ] ;
18271: LD_ADDR_VAR 0 5
18275: PUSH
18276: LD_VAR 0 2
18280: PUSH
18281: LD_VAR 0 3
18285: ARRAY
18286: ST_TO_ADDR
// end ;
18287: GO 18196
18289: POP
18290: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18291: LD_VAR 0 1
18295: PPUSH
18296: LD_VAR 0 5
18300: PPUSH
18301: CALL_OW 135
// end ;
18305: LD_VAR 0 2
18309: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18310: LD_INT 0
18312: PPUSH
18313: PPUSH
18314: PPUSH
18315: PPUSH
18316: PPUSH
18317: PPUSH
18318: PPUSH
18319: PPUSH
18320: PPUSH
18321: PPUSH
18322: PPUSH
18323: PPUSH
18324: PPUSH
// result := [ ] ;
18325: LD_ADDR_VAR 0 7
18329: PUSH
18330: EMPTY
18331: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18332: LD_VAR 0 1
18336: PPUSH
18337: CALL_OW 266
18341: PUSH
18342: LD_INT 0
18344: PUSH
18345: LD_INT 1
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: IN
18352: NOT
18353: IFFALSE 18357
// exit ;
18355: GO 19991
// if name then
18357: LD_VAR 0 3
18361: IFFALSE 18377
// SetBName ( base_dep , name ) ;
18363: LD_VAR 0 1
18367: PPUSH
18368: LD_VAR 0 3
18372: PPUSH
18373: CALL_OW 500
// base := GetBase ( base_dep ) ;
18377: LD_ADDR_VAR 0 15
18381: PUSH
18382: LD_VAR 0 1
18386: PPUSH
18387: CALL_OW 274
18391: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18392: LD_ADDR_VAR 0 16
18396: PUSH
18397: LD_VAR 0 1
18401: PPUSH
18402: CALL_OW 255
18406: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18407: LD_ADDR_VAR 0 17
18411: PUSH
18412: LD_VAR 0 1
18416: PPUSH
18417: CALL_OW 248
18421: ST_TO_ADDR
// if sources then
18422: LD_VAR 0 5
18426: IFFALSE 18473
// for i = 1 to 3 do
18428: LD_ADDR_VAR 0 8
18432: PUSH
18433: DOUBLE
18434: LD_INT 1
18436: DEC
18437: ST_TO_ADDR
18438: LD_INT 3
18440: PUSH
18441: FOR_TO
18442: IFFALSE 18471
// AddResourceType ( base , i , sources [ i ] ) ;
18444: LD_VAR 0 15
18448: PPUSH
18449: LD_VAR 0 8
18453: PPUSH
18454: LD_VAR 0 5
18458: PUSH
18459: LD_VAR 0 8
18463: ARRAY
18464: PPUSH
18465: CALL_OW 276
18469: GO 18441
18471: POP
18472: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18473: LD_ADDR_VAR 0 18
18477: PUSH
18478: LD_VAR 0 15
18482: PPUSH
18483: LD_VAR 0 2
18487: PPUSH
18488: LD_INT 1
18490: PPUSH
18491: CALL 17734 0 3
18495: ST_TO_ADDR
// InitHc ;
18496: CALL_OW 19
// InitUc ;
18500: CALL_OW 18
// uc_side := side ;
18504: LD_ADDR_OWVAR 20
18508: PUSH
18509: LD_VAR 0 16
18513: ST_TO_ADDR
// uc_nation := nation ;
18514: LD_ADDR_OWVAR 21
18518: PUSH
18519: LD_VAR 0 17
18523: ST_TO_ADDR
// if buildings then
18524: LD_VAR 0 18
18528: IFFALSE 19850
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18530: LD_ADDR_VAR 0 19
18534: PUSH
18535: LD_VAR 0 18
18539: PPUSH
18540: LD_INT 2
18542: PUSH
18543: LD_INT 30
18545: PUSH
18546: LD_INT 29
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: PUSH
18553: LD_INT 30
18555: PUSH
18556: LD_INT 30
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: PUSH
18563: EMPTY
18564: LIST
18565: LIST
18566: LIST
18567: PPUSH
18568: CALL_OW 72
18572: ST_TO_ADDR
// if tmp then
18573: LD_VAR 0 19
18577: IFFALSE 18625
// for i in tmp do
18579: LD_ADDR_VAR 0 8
18583: PUSH
18584: LD_VAR 0 19
18588: PUSH
18589: FOR_IN
18590: IFFALSE 18623
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18592: LD_VAR 0 8
18596: PPUSH
18597: CALL_OW 250
18601: PPUSH
18602: LD_VAR 0 8
18606: PPUSH
18607: CALL_OW 251
18611: PPUSH
18612: LD_VAR 0 16
18616: PPUSH
18617: CALL_OW 441
18621: GO 18589
18623: POP
18624: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18625: LD_VAR 0 18
18629: PPUSH
18630: LD_INT 2
18632: PUSH
18633: LD_INT 30
18635: PUSH
18636: LD_INT 32
18638: PUSH
18639: EMPTY
18640: LIST
18641: LIST
18642: PUSH
18643: LD_INT 30
18645: PUSH
18646: LD_INT 33
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: LIST
18657: PPUSH
18658: CALL_OW 72
18662: IFFALSE 18750
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18664: LD_ADDR_VAR 0 8
18668: PUSH
18669: LD_VAR 0 18
18673: PPUSH
18674: LD_INT 2
18676: PUSH
18677: LD_INT 30
18679: PUSH
18680: LD_INT 32
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: PUSH
18687: LD_INT 30
18689: PUSH
18690: LD_INT 33
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: LIST
18701: PPUSH
18702: CALL_OW 72
18706: PUSH
18707: FOR_IN
18708: IFFALSE 18748
// begin if not GetBWeapon ( i ) then
18710: LD_VAR 0 8
18714: PPUSH
18715: CALL_OW 269
18719: NOT
18720: IFFALSE 18746
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18722: LD_VAR 0 8
18726: PPUSH
18727: LD_VAR 0 8
18731: PPUSH
18732: LD_VAR 0 2
18736: PPUSH
18737: CALL 19996 0 2
18741: PPUSH
18742: CALL_OW 431
// end ;
18746: GO 18707
18748: POP
18749: POP
// end ; for i = 1 to personel do
18750: LD_ADDR_VAR 0 8
18754: PUSH
18755: DOUBLE
18756: LD_INT 1
18758: DEC
18759: ST_TO_ADDR
18760: LD_VAR 0 6
18764: PUSH
18765: FOR_TO
18766: IFFALSE 19830
// begin if i > 4 then
18768: LD_VAR 0 8
18772: PUSH
18773: LD_INT 4
18775: GREATER
18776: IFFALSE 18780
// break ;
18778: GO 19830
// case i of 1 :
18780: LD_VAR 0 8
18784: PUSH
18785: LD_INT 1
18787: DOUBLE
18788: EQUAL
18789: IFTRUE 18793
18791: GO 18873
18793: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18794: LD_ADDR_VAR 0 12
18798: PUSH
18799: LD_VAR 0 18
18803: PPUSH
18804: LD_INT 22
18806: PUSH
18807: LD_VAR 0 16
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: PUSH
18816: LD_INT 58
18818: PUSH
18819: EMPTY
18820: LIST
18821: PUSH
18822: LD_INT 2
18824: PUSH
18825: LD_INT 30
18827: PUSH
18828: LD_INT 32
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: PUSH
18835: LD_INT 30
18837: PUSH
18838: LD_INT 4
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 30
18847: PUSH
18848: LD_INT 5
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: LIST
18859: LIST
18860: PUSH
18861: EMPTY
18862: LIST
18863: LIST
18864: LIST
18865: PPUSH
18866: CALL_OW 72
18870: ST_TO_ADDR
18871: GO 19095
18873: LD_INT 2
18875: DOUBLE
18876: EQUAL
18877: IFTRUE 18881
18879: GO 18943
18881: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18882: LD_ADDR_VAR 0 12
18886: PUSH
18887: LD_VAR 0 18
18891: PPUSH
18892: LD_INT 22
18894: PUSH
18895: LD_VAR 0 16
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: PUSH
18904: LD_INT 2
18906: PUSH
18907: LD_INT 30
18909: PUSH
18910: LD_INT 0
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: LD_INT 30
18919: PUSH
18920: LD_INT 1
18922: PUSH
18923: EMPTY
18924: LIST
18925: LIST
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: LIST
18931: PUSH
18932: EMPTY
18933: LIST
18934: LIST
18935: PPUSH
18936: CALL_OW 72
18940: ST_TO_ADDR
18941: GO 19095
18943: LD_INT 3
18945: DOUBLE
18946: EQUAL
18947: IFTRUE 18951
18949: GO 19013
18951: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18952: LD_ADDR_VAR 0 12
18956: PUSH
18957: LD_VAR 0 18
18961: PPUSH
18962: LD_INT 22
18964: PUSH
18965: LD_VAR 0 16
18969: PUSH
18970: EMPTY
18971: LIST
18972: LIST
18973: PUSH
18974: LD_INT 2
18976: PUSH
18977: LD_INT 30
18979: PUSH
18980: LD_INT 2
18982: PUSH
18983: EMPTY
18984: LIST
18985: LIST
18986: PUSH
18987: LD_INT 30
18989: PUSH
18990: LD_INT 3
18992: PUSH
18993: EMPTY
18994: LIST
18995: LIST
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: LIST
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PPUSH
19006: CALL_OW 72
19010: ST_TO_ADDR
19011: GO 19095
19013: LD_INT 4
19015: DOUBLE
19016: EQUAL
19017: IFTRUE 19021
19019: GO 19094
19021: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
19022: LD_ADDR_VAR 0 12
19026: PUSH
19027: LD_VAR 0 18
19031: PPUSH
19032: LD_INT 22
19034: PUSH
19035: LD_VAR 0 16
19039: PUSH
19040: EMPTY
19041: LIST
19042: LIST
19043: PUSH
19044: LD_INT 2
19046: PUSH
19047: LD_INT 30
19049: PUSH
19050: LD_INT 6
19052: PUSH
19053: EMPTY
19054: LIST
19055: LIST
19056: PUSH
19057: LD_INT 30
19059: PUSH
19060: LD_INT 7
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: PUSH
19067: LD_INT 30
19069: PUSH
19070: LD_INT 8
19072: PUSH
19073: EMPTY
19074: LIST
19075: LIST
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: LIST
19081: LIST
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: PPUSH
19087: CALL_OW 72
19091: ST_TO_ADDR
19092: GO 19095
19094: POP
// if i = 1 then
19095: LD_VAR 0 8
19099: PUSH
19100: LD_INT 1
19102: EQUAL
19103: IFFALSE 19214
// begin tmp := [ ] ;
19105: LD_ADDR_VAR 0 19
19109: PUSH
19110: EMPTY
19111: ST_TO_ADDR
// for j in f do
19112: LD_ADDR_VAR 0 9
19116: PUSH
19117: LD_VAR 0 12
19121: PUSH
19122: FOR_IN
19123: IFFALSE 19196
// if GetBType ( j ) = b_bunker then
19125: LD_VAR 0 9
19129: PPUSH
19130: CALL_OW 266
19134: PUSH
19135: LD_INT 32
19137: EQUAL
19138: IFFALSE 19165
// tmp := Insert ( tmp , 1 , j ) else
19140: LD_ADDR_VAR 0 19
19144: PUSH
19145: LD_VAR 0 19
19149: PPUSH
19150: LD_INT 1
19152: PPUSH
19153: LD_VAR 0 9
19157: PPUSH
19158: CALL_OW 2
19162: ST_TO_ADDR
19163: GO 19194
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19165: LD_ADDR_VAR 0 19
19169: PUSH
19170: LD_VAR 0 19
19174: PPUSH
19175: LD_VAR 0 19
19179: PUSH
19180: LD_INT 1
19182: PLUS
19183: PPUSH
19184: LD_VAR 0 9
19188: PPUSH
19189: CALL_OW 2
19193: ST_TO_ADDR
19194: GO 19122
19196: POP
19197: POP
// if tmp then
19198: LD_VAR 0 19
19202: IFFALSE 19214
// f := tmp ;
19204: LD_ADDR_VAR 0 12
19208: PUSH
19209: LD_VAR 0 19
19213: ST_TO_ADDR
// end ; x := personel [ i ] ;
19214: LD_ADDR_VAR 0 13
19218: PUSH
19219: LD_VAR 0 6
19223: PUSH
19224: LD_VAR 0 8
19228: ARRAY
19229: ST_TO_ADDR
// if x = - 1 then
19230: LD_VAR 0 13
19234: PUSH
19235: LD_INT 1
19237: NEG
19238: EQUAL
19239: IFFALSE 19448
// begin for j in f do
19241: LD_ADDR_VAR 0 9
19245: PUSH
19246: LD_VAR 0 12
19250: PUSH
19251: FOR_IN
19252: IFFALSE 19444
// repeat InitHc ;
19254: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19258: LD_VAR 0 9
19262: PPUSH
19263: CALL_OW 266
19267: PUSH
19268: LD_INT 5
19270: EQUAL
19271: IFFALSE 19341
// begin if UnitsInside ( j ) < 3 then
19273: LD_VAR 0 9
19277: PPUSH
19278: CALL_OW 313
19282: PUSH
19283: LD_INT 3
19285: LESS
19286: IFFALSE 19322
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19288: LD_INT 0
19290: PPUSH
19291: LD_INT 5
19293: PUSH
19294: LD_INT 8
19296: PUSH
19297: LD_INT 9
19299: PUSH
19300: EMPTY
19301: LIST
19302: LIST
19303: LIST
19304: PUSH
19305: LD_VAR 0 17
19309: ARRAY
19310: PPUSH
19311: LD_VAR 0 4
19315: PPUSH
19316: CALL_OW 380
19320: GO 19339
// PrepareHuman ( false , i , skill ) ;
19322: LD_INT 0
19324: PPUSH
19325: LD_VAR 0 8
19329: PPUSH
19330: LD_VAR 0 4
19334: PPUSH
19335: CALL_OW 380
// end else
19339: GO 19358
// PrepareHuman ( false , i , skill ) ;
19341: LD_INT 0
19343: PPUSH
19344: LD_VAR 0 8
19348: PPUSH
19349: LD_VAR 0 4
19353: PPUSH
19354: CALL_OW 380
// un := CreateHuman ;
19358: LD_ADDR_VAR 0 14
19362: PUSH
19363: CALL_OW 44
19367: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19368: LD_ADDR_VAR 0 7
19372: PUSH
19373: LD_VAR 0 7
19377: PPUSH
19378: LD_INT 1
19380: PPUSH
19381: LD_VAR 0 14
19385: PPUSH
19386: CALL_OW 2
19390: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19391: LD_VAR 0 14
19395: PPUSH
19396: LD_VAR 0 9
19400: PPUSH
19401: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19405: LD_VAR 0 9
19409: PPUSH
19410: CALL_OW 313
19414: PUSH
19415: LD_INT 6
19417: EQUAL
19418: PUSH
19419: LD_VAR 0 9
19423: PPUSH
19424: CALL_OW 266
19428: PUSH
19429: LD_INT 32
19431: PUSH
19432: LD_INT 31
19434: PUSH
19435: EMPTY
19436: LIST
19437: LIST
19438: IN
19439: OR
19440: IFFALSE 19254
19442: GO 19251
19444: POP
19445: POP
// end else
19446: GO 19828
// for j = 1 to x do
19448: LD_ADDR_VAR 0 9
19452: PUSH
19453: DOUBLE
19454: LD_INT 1
19456: DEC
19457: ST_TO_ADDR
19458: LD_VAR 0 13
19462: PUSH
19463: FOR_TO
19464: IFFALSE 19826
// begin InitHc ;
19466: CALL_OW 19
// if not f then
19470: LD_VAR 0 12
19474: NOT
19475: IFFALSE 19564
// begin PrepareHuman ( false , i , skill ) ;
19477: LD_INT 0
19479: PPUSH
19480: LD_VAR 0 8
19484: PPUSH
19485: LD_VAR 0 4
19489: PPUSH
19490: CALL_OW 380
// un := CreateHuman ;
19494: LD_ADDR_VAR 0 14
19498: PUSH
19499: CALL_OW 44
19503: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19504: LD_ADDR_VAR 0 7
19508: PUSH
19509: LD_VAR 0 7
19513: PPUSH
19514: LD_INT 1
19516: PPUSH
19517: LD_VAR 0 14
19521: PPUSH
19522: CALL_OW 2
19526: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19527: LD_VAR 0 14
19531: PPUSH
19532: LD_VAR 0 1
19536: PPUSH
19537: CALL_OW 250
19541: PPUSH
19542: LD_VAR 0 1
19546: PPUSH
19547: CALL_OW 251
19551: PPUSH
19552: LD_INT 10
19554: PPUSH
19555: LD_INT 0
19557: PPUSH
19558: CALL_OW 50
// continue ;
19562: GO 19463
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19564: LD_VAR 0 12
19568: PUSH
19569: LD_INT 1
19571: ARRAY
19572: PPUSH
19573: CALL_OW 313
19577: PUSH
19578: LD_VAR 0 12
19582: PUSH
19583: LD_INT 1
19585: ARRAY
19586: PPUSH
19587: CALL_OW 266
19591: PUSH
19592: LD_INT 32
19594: PUSH
19595: LD_INT 31
19597: PUSH
19598: EMPTY
19599: LIST
19600: LIST
19601: IN
19602: AND
19603: PUSH
19604: LD_VAR 0 12
19608: PUSH
19609: LD_INT 1
19611: ARRAY
19612: PPUSH
19613: CALL_OW 313
19617: PUSH
19618: LD_INT 6
19620: EQUAL
19621: OR
19622: IFFALSE 19642
// f := Delete ( f , 1 ) ;
19624: LD_ADDR_VAR 0 12
19628: PUSH
19629: LD_VAR 0 12
19633: PPUSH
19634: LD_INT 1
19636: PPUSH
19637: CALL_OW 3
19641: ST_TO_ADDR
// if not f then
19642: LD_VAR 0 12
19646: NOT
19647: IFFALSE 19665
// begin x := x + 2 ;
19649: LD_ADDR_VAR 0 13
19653: PUSH
19654: LD_VAR 0 13
19658: PUSH
19659: LD_INT 2
19661: PLUS
19662: ST_TO_ADDR
// continue ;
19663: GO 19463
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19665: LD_VAR 0 12
19669: PUSH
19670: LD_INT 1
19672: ARRAY
19673: PPUSH
19674: CALL_OW 266
19678: PUSH
19679: LD_INT 5
19681: EQUAL
19682: IFFALSE 19756
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19684: LD_VAR 0 12
19688: PUSH
19689: LD_INT 1
19691: ARRAY
19692: PPUSH
19693: CALL_OW 313
19697: PUSH
19698: LD_INT 3
19700: LESS
19701: IFFALSE 19737
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19703: LD_INT 0
19705: PPUSH
19706: LD_INT 5
19708: PUSH
19709: LD_INT 8
19711: PUSH
19712: LD_INT 9
19714: PUSH
19715: EMPTY
19716: LIST
19717: LIST
19718: LIST
19719: PUSH
19720: LD_VAR 0 17
19724: ARRAY
19725: PPUSH
19726: LD_VAR 0 4
19730: PPUSH
19731: CALL_OW 380
19735: GO 19754
// PrepareHuman ( false , i , skill ) ;
19737: LD_INT 0
19739: PPUSH
19740: LD_VAR 0 8
19744: PPUSH
19745: LD_VAR 0 4
19749: PPUSH
19750: CALL_OW 380
// end else
19754: GO 19773
// PrepareHuman ( false , i , skill ) ;
19756: LD_INT 0
19758: PPUSH
19759: LD_VAR 0 8
19763: PPUSH
19764: LD_VAR 0 4
19768: PPUSH
19769: CALL_OW 380
// un := CreateHuman ;
19773: LD_ADDR_VAR 0 14
19777: PUSH
19778: CALL_OW 44
19782: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19783: LD_ADDR_VAR 0 7
19787: PUSH
19788: LD_VAR 0 7
19792: PPUSH
19793: LD_INT 1
19795: PPUSH
19796: LD_VAR 0 14
19800: PPUSH
19801: CALL_OW 2
19805: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19806: LD_VAR 0 14
19810: PPUSH
19811: LD_VAR 0 12
19815: PUSH
19816: LD_INT 1
19818: ARRAY
19819: PPUSH
19820: CALL_OW 52
// end ;
19824: GO 19463
19826: POP
19827: POP
// end ;
19828: GO 18765
19830: POP
19831: POP
// result := result ^ buildings ;
19832: LD_ADDR_VAR 0 7
19836: PUSH
19837: LD_VAR 0 7
19841: PUSH
19842: LD_VAR 0 18
19846: ADD
19847: ST_TO_ADDR
// end else
19848: GO 19991
// begin for i = 1 to personel do
19850: LD_ADDR_VAR 0 8
19854: PUSH
19855: DOUBLE
19856: LD_INT 1
19858: DEC
19859: ST_TO_ADDR
19860: LD_VAR 0 6
19864: PUSH
19865: FOR_TO
19866: IFFALSE 19989
// begin if i > 4 then
19868: LD_VAR 0 8
19872: PUSH
19873: LD_INT 4
19875: GREATER
19876: IFFALSE 19880
// break ;
19878: GO 19989
// x := personel [ i ] ;
19880: LD_ADDR_VAR 0 13
19884: PUSH
19885: LD_VAR 0 6
19889: PUSH
19890: LD_VAR 0 8
19894: ARRAY
19895: ST_TO_ADDR
// if x = - 1 then
19896: LD_VAR 0 13
19900: PUSH
19901: LD_INT 1
19903: NEG
19904: EQUAL
19905: IFFALSE 19909
// continue ;
19907: GO 19865
// PrepareHuman ( false , i , skill ) ;
19909: LD_INT 0
19911: PPUSH
19912: LD_VAR 0 8
19916: PPUSH
19917: LD_VAR 0 4
19921: PPUSH
19922: CALL_OW 380
// un := CreateHuman ;
19926: LD_ADDR_VAR 0 14
19930: PUSH
19931: CALL_OW 44
19935: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19936: LD_VAR 0 14
19940: PPUSH
19941: LD_VAR 0 1
19945: PPUSH
19946: CALL_OW 250
19950: PPUSH
19951: LD_VAR 0 1
19955: PPUSH
19956: CALL_OW 251
19960: PPUSH
19961: LD_INT 10
19963: PPUSH
19964: LD_INT 0
19966: PPUSH
19967: CALL_OW 50
// result := result ^ un ;
19971: LD_ADDR_VAR 0 7
19975: PUSH
19976: LD_VAR 0 7
19980: PUSH
19981: LD_VAR 0 14
19985: ADD
19986: ST_TO_ADDR
// end ;
19987: GO 19865
19989: POP
19990: POP
// end ; end ;
19991: LD_VAR 0 7
19995: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19996: LD_INT 0
19998: PPUSH
19999: PPUSH
20000: PPUSH
20001: PPUSH
20002: PPUSH
20003: PPUSH
20004: PPUSH
20005: PPUSH
20006: PPUSH
20007: PPUSH
20008: PPUSH
20009: PPUSH
20010: PPUSH
20011: PPUSH
20012: PPUSH
20013: PPUSH
// result := false ;
20014: LD_ADDR_VAR 0 3
20018: PUSH
20019: LD_INT 0
20021: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
20022: LD_VAR 0 1
20026: NOT
20027: PUSH
20028: LD_VAR 0 1
20032: PPUSH
20033: CALL_OW 266
20037: PUSH
20038: LD_INT 32
20040: PUSH
20041: LD_INT 33
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: IN
20048: NOT
20049: OR
20050: IFFALSE 20054
// exit ;
20052: GO 21163
// nat := GetNation ( tower ) ;
20054: LD_ADDR_VAR 0 12
20058: PUSH
20059: LD_VAR 0 1
20063: PPUSH
20064: CALL_OW 248
20068: ST_TO_ADDR
// side := GetSide ( tower ) ;
20069: LD_ADDR_VAR 0 16
20073: PUSH
20074: LD_VAR 0 1
20078: PPUSH
20079: CALL_OW 255
20083: ST_TO_ADDR
// x := GetX ( tower ) ;
20084: LD_ADDR_VAR 0 10
20088: PUSH
20089: LD_VAR 0 1
20093: PPUSH
20094: CALL_OW 250
20098: ST_TO_ADDR
// y := GetY ( tower ) ;
20099: LD_ADDR_VAR 0 11
20103: PUSH
20104: LD_VAR 0 1
20108: PPUSH
20109: CALL_OW 251
20113: ST_TO_ADDR
// if not x or not y then
20114: LD_VAR 0 10
20118: NOT
20119: PUSH
20120: LD_VAR 0 11
20124: NOT
20125: OR
20126: IFFALSE 20130
// exit ;
20128: GO 21163
// weapon := 0 ;
20130: LD_ADDR_VAR 0 18
20134: PUSH
20135: LD_INT 0
20137: ST_TO_ADDR
// fac_list := [ ] ;
20138: LD_ADDR_VAR 0 17
20142: PUSH
20143: EMPTY
20144: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20145: LD_ADDR_VAR 0 6
20149: PUSH
20150: LD_VAR 0 1
20154: PPUSH
20155: CALL_OW 274
20159: PPUSH
20160: LD_VAR 0 2
20164: PPUSH
20165: LD_INT 0
20167: PPUSH
20168: CALL 17734 0 3
20172: PPUSH
20173: LD_INT 30
20175: PUSH
20176: LD_INT 3
20178: PUSH
20179: EMPTY
20180: LIST
20181: LIST
20182: PPUSH
20183: CALL_OW 72
20187: ST_TO_ADDR
// if not factories then
20188: LD_VAR 0 6
20192: NOT
20193: IFFALSE 20197
// exit ;
20195: GO 21163
// for i in factories do
20197: LD_ADDR_VAR 0 8
20201: PUSH
20202: LD_VAR 0 6
20206: PUSH
20207: FOR_IN
20208: IFFALSE 20233
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20210: LD_ADDR_VAR 0 17
20214: PUSH
20215: LD_VAR 0 17
20219: PUSH
20220: LD_VAR 0 8
20224: PPUSH
20225: CALL_OW 478
20229: UNION
20230: ST_TO_ADDR
20231: GO 20207
20233: POP
20234: POP
// if not fac_list then
20235: LD_VAR 0 17
20239: NOT
20240: IFFALSE 20244
// exit ;
20242: GO 21163
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20244: LD_ADDR_VAR 0 5
20248: PUSH
20249: LD_INT 4
20251: PUSH
20252: LD_INT 5
20254: PUSH
20255: LD_INT 9
20257: PUSH
20258: LD_INT 10
20260: PUSH
20261: LD_INT 6
20263: PUSH
20264: LD_INT 7
20266: PUSH
20267: LD_INT 11
20269: PUSH
20270: EMPTY
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: LIST
20276: LIST
20277: LIST
20278: PUSH
20279: LD_INT 27
20281: PUSH
20282: LD_INT 28
20284: PUSH
20285: LD_INT 26
20287: PUSH
20288: LD_INT 30
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: LIST
20295: LIST
20296: PUSH
20297: LD_INT 43
20299: PUSH
20300: LD_INT 44
20302: PUSH
20303: LD_INT 46
20305: PUSH
20306: LD_INT 45
20308: PUSH
20309: LD_INT 47
20311: PUSH
20312: LD_INT 49
20314: PUSH
20315: EMPTY
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: PUSH
20323: EMPTY
20324: LIST
20325: LIST
20326: LIST
20327: PUSH
20328: LD_VAR 0 12
20332: ARRAY
20333: ST_TO_ADDR
// list := list isect fac_list ;
20334: LD_ADDR_VAR 0 5
20338: PUSH
20339: LD_VAR 0 5
20343: PUSH
20344: LD_VAR 0 17
20348: ISECT
20349: ST_TO_ADDR
// if not list then
20350: LD_VAR 0 5
20354: NOT
20355: IFFALSE 20359
// exit ;
20357: GO 21163
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20359: LD_VAR 0 12
20363: PUSH
20364: LD_INT 3
20366: EQUAL
20367: PUSH
20368: LD_INT 49
20370: PUSH
20371: LD_VAR 0 5
20375: IN
20376: AND
20377: PUSH
20378: LD_INT 31
20380: PPUSH
20381: LD_VAR 0 16
20385: PPUSH
20386: CALL_OW 321
20390: PUSH
20391: LD_INT 2
20393: EQUAL
20394: AND
20395: IFFALSE 20455
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20397: LD_INT 22
20399: PUSH
20400: LD_VAR 0 16
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: PUSH
20409: LD_INT 35
20411: PUSH
20412: LD_INT 49
20414: PUSH
20415: EMPTY
20416: LIST
20417: LIST
20418: PUSH
20419: LD_INT 91
20421: PUSH
20422: LD_VAR 0 1
20426: PUSH
20427: LD_INT 10
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: LIST
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: LIST
20439: PPUSH
20440: CALL_OW 69
20444: NOT
20445: IFFALSE 20455
// weapon := ru_time_lapser ;
20447: LD_ADDR_VAR 0 18
20451: PUSH
20452: LD_INT 49
20454: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20455: LD_VAR 0 12
20459: PUSH
20460: LD_INT 1
20462: PUSH
20463: LD_INT 2
20465: PUSH
20466: EMPTY
20467: LIST
20468: LIST
20469: IN
20470: PUSH
20471: LD_INT 11
20473: PUSH
20474: LD_VAR 0 5
20478: IN
20479: PUSH
20480: LD_INT 30
20482: PUSH
20483: LD_VAR 0 5
20487: IN
20488: OR
20489: AND
20490: PUSH
20491: LD_INT 6
20493: PPUSH
20494: LD_VAR 0 16
20498: PPUSH
20499: CALL_OW 321
20503: PUSH
20504: LD_INT 2
20506: EQUAL
20507: AND
20508: IFFALSE 20673
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20510: LD_INT 22
20512: PUSH
20513: LD_VAR 0 16
20517: PUSH
20518: EMPTY
20519: LIST
20520: LIST
20521: PUSH
20522: LD_INT 2
20524: PUSH
20525: LD_INT 35
20527: PUSH
20528: LD_INT 11
20530: PUSH
20531: EMPTY
20532: LIST
20533: LIST
20534: PUSH
20535: LD_INT 35
20537: PUSH
20538: LD_INT 30
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: LIST
20549: PUSH
20550: LD_INT 91
20552: PUSH
20553: LD_VAR 0 1
20557: PUSH
20558: LD_INT 18
20560: PUSH
20561: EMPTY
20562: LIST
20563: LIST
20564: LIST
20565: PUSH
20566: EMPTY
20567: LIST
20568: LIST
20569: LIST
20570: PPUSH
20571: CALL_OW 69
20575: NOT
20576: PUSH
20577: LD_INT 22
20579: PUSH
20580: LD_VAR 0 16
20584: PUSH
20585: EMPTY
20586: LIST
20587: LIST
20588: PUSH
20589: LD_INT 2
20591: PUSH
20592: LD_INT 30
20594: PUSH
20595: LD_INT 32
20597: PUSH
20598: EMPTY
20599: LIST
20600: LIST
20601: PUSH
20602: LD_INT 30
20604: PUSH
20605: LD_INT 33
20607: PUSH
20608: EMPTY
20609: LIST
20610: LIST
20611: PUSH
20612: EMPTY
20613: LIST
20614: LIST
20615: LIST
20616: PUSH
20617: LD_INT 91
20619: PUSH
20620: LD_VAR 0 1
20624: PUSH
20625: LD_INT 12
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: LIST
20632: PUSH
20633: EMPTY
20634: LIST
20635: LIST
20636: LIST
20637: PUSH
20638: EMPTY
20639: LIST
20640: PPUSH
20641: CALL_OW 69
20645: PUSH
20646: LD_INT 2
20648: GREATER
20649: AND
20650: IFFALSE 20673
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20652: LD_ADDR_VAR 0 18
20656: PUSH
20657: LD_INT 11
20659: PUSH
20660: LD_INT 30
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: PUSH
20667: LD_VAR 0 12
20671: ARRAY
20672: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20673: LD_VAR 0 18
20677: NOT
20678: PUSH
20679: LD_INT 40
20681: PPUSH
20682: LD_VAR 0 16
20686: PPUSH
20687: CALL_OW 321
20691: PUSH
20692: LD_INT 2
20694: EQUAL
20695: AND
20696: PUSH
20697: LD_INT 7
20699: PUSH
20700: LD_VAR 0 5
20704: IN
20705: PUSH
20706: LD_INT 28
20708: PUSH
20709: LD_VAR 0 5
20713: IN
20714: OR
20715: PUSH
20716: LD_INT 45
20718: PUSH
20719: LD_VAR 0 5
20723: IN
20724: OR
20725: AND
20726: IFFALSE 20980
// begin hex := GetHexInfo ( x , y ) ;
20728: LD_ADDR_VAR 0 4
20732: PUSH
20733: LD_VAR 0 10
20737: PPUSH
20738: LD_VAR 0 11
20742: PPUSH
20743: CALL_OW 546
20747: ST_TO_ADDR
// if hex [ 1 ] then
20748: LD_VAR 0 4
20752: PUSH
20753: LD_INT 1
20755: ARRAY
20756: IFFALSE 20760
// exit ;
20758: GO 21163
// height := hex [ 2 ] ;
20760: LD_ADDR_VAR 0 15
20764: PUSH
20765: LD_VAR 0 4
20769: PUSH
20770: LD_INT 2
20772: ARRAY
20773: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20774: LD_ADDR_VAR 0 14
20778: PUSH
20779: LD_INT 0
20781: PUSH
20782: LD_INT 2
20784: PUSH
20785: LD_INT 3
20787: PUSH
20788: LD_INT 5
20790: PUSH
20791: EMPTY
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: ST_TO_ADDR
// for i in tmp do
20797: LD_ADDR_VAR 0 8
20801: PUSH
20802: LD_VAR 0 14
20806: PUSH
20807: FOR_IN
20808: IFFALSE 20978
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20810: LD_ADDR_VAR 0 9
20814: PUSH
20815: LD_VAR 0 10
20819: PPUSH
20820: LD_VAR 0 8
20824: PPUSH
20825: LD_INT 5
20827: PPUSH
20828: CALL_OW 272
20832: PUSH
20833: LD_VAR 0 11
20837: PPUSH
20838: LD_VAR 0 8
20842: PPUSH
20843: LD_INT 5
20845: PPUSH
20846: CALL_OW 273
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20855: LD_VAR 0 9
20859: PUSH
20860: LD_INT 1
20862: ARRAY
20863: PPUSH
20864: LD_VAR 0 9
20868: PUSH
20869: LD_INT 2
20871: ARRAY
20872: PPUSH
20873: CALL_OW 488
20877: IFFALSE 20976
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20879: LD_ADDR_VAR 0 4
20883: PUSH
20884: LD_VAR 0 9
20888: PUSH
20889: LD_INT 1
20891: ARRAY
20892: PPUSH
20893: LD_VAR 0 9
20897: PUSH
20898: LD_INT 2
20900: ARRAY
20901: PPUSH
20902: CALL_OW 546
20906: ST_TO_ADDR
// if hex [ 1 ] then
20907: LD_VAR 0 4
20911: PUSH
20912: LD_INT 1
20914: ARRAY
20915: IFFALSE 20919
// continue ;
20917: GO 20807
// h := hex [ 2 ] ;
20919: LD_ADDR_VAR 0 13
20923: PUSH
20924: LD_VAR 0 4
20928: PUSH
20929: LD_INT 2
20931: ARRAY
20932: ST_TO_ADDR
// if h + 7 < height then
20933: LD_VAR 0 13
20937: PUSH
20938: LD_INT 7
20940: PLUS
20941: PUSH
20942: LD_VAR 0 15
20946: LESS
20947: IFFALSE 20976
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20949: LD_ADDR_VAR 0 18
20953: PUSH
20954: LD_INT 7
20956: PUSH
20957: LD_INT 28
20959: PUSH
20960: LD_INT 45
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: LIST
20967: PUSH
20968: LD_VAR 0 12
20972: ARRAY
20973: ST_TO_ADDR
// break ;
20974: GO 20978
// end ; end ; end ;
20976: GO 20807
20978: POP
20979: POP
// end ; if not weapon then
20980: LD_VAR 0 18
20984: NOT
20985: IFFALSE 21045
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20987: LD_ADDR_VAR 0 5
20991: PUSH
20992: LD_VAR 0 5
20996: PUSH
20997: LD_INT 11
20999: PUSH
21000: LD_INT 30
21002: PUSH
21003: LD_INT 49
21005: PUSH
21006: EMPTY
21007: LIST
21008: LIST
21009: LIST
21010: DIFF
21011: ST_TO_ADDR
// if not list then
21012: LD_VAR 0 5
21016: NOT
21017: IFFALSE 21021
// exit ;
21019: GO 21163
// weapon := list [ rand ( 1 , list ) ] ;
21021: LD_ADDR_VAR 0 18
21025: PUSH
21026: LD_VAR 0 5
21030: PUSH
21031: LD_INT 1
21033: PPUSH
21034: LD_VAR 0 5
21038: PPUSH
21039: CALL_OW 12
21043: ARRAY
21044: ST_TO_ADDR
// end ; if weapon then
21045: LD_VAR 0 18
21049: IFFALSE 21163
// begin tmp := CostOfWeapon ( weapon ) ;
21051: LD_ADDR_VAR 0 14
21055: PUSH
21056: LD_VAR 0 18
21060: PPUSH
21061: CALL_OW 451
21065: ST_TO_ADDR
// j := GetBase ( tower ) ;
21066: LD_ADDR_VAR 0 9
21070: PUSH
21071: LD_VAR 0 1
21075: PPUSH
21076: CALL_OW 274
21080: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21081: LD_VAR 0 9
21085: PPUSH
21086: LD_INT 1
21088: PPUSH
21089: CALL_OW 275
21093: PUSH
21094: LD_VAR 0 14
21098: PUSH
21099: LD_INT 1
21101: ARRAY
21102: GREATEREQUAL
21103: PUSH
21104: LD_VAR 0 9
21108: PPUSH
21109: LD_INT 2
21111: PPUSH
21112: CALL_OW 275
21116: PUSH
21117: LD_VAR 0 14
21121: PUSH
21122: LD_INT 2
21124: ARRAY
21125: GREATEREQUAL
21126: AND
21127: PUSH
21128: LD_VAR 0 9
21132: PPUSH
21133: LD_INT 3
21135: PPUSH
21136: CALL_OW 275
21140: PUSH
21141: LD_VAR 0 14
21145: PUSH
21146: LD_INT 3
21148: ARRAY
21149: GREATEREQUAL
21150: AND
21151: IFFALSE 21163
// result := weapon ;
21153: LD_ADDR_VAR 0 3
21157: PUSH
21158: LD_VAR 0 18
21162: ST_TO_ADDR
// end ; end ;
21163: LD_VAR 0 3
21167: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21168: LD_INT 0
21170: PPUSH
21171: PPUSH
// result := true ;
21172: LD_ADDR_VAR 0 3
21176: PUSH
21177: LD_INT 1
21179: ST_TO_ADDR
// if array1 = array2 then
21180: LD_VAR 0 1
21184: PUSH
21185: LD_VAR 0 2
21189: EQUAL
21190: IFFALSE 21250
// begin for i = 1 to array1 do
21192: LD_ADDR_VAR 0 4
21196: PUSH
21197: DOUBLE
21198: LD_INT 1
21200: DEC
21201: ST_TO_ADDR
21202: LD_VAR 0 1
21206: PUSH
21207: FOR_TO
21208: IFFALSE 21246
// if array1 [ i ] <> array2 [ i ] then
21210: LD_VAR 0 1
21214: PUSH
21215: LD_VAR 0 4
21219: ARRAY
21220: PUSH
21221: LD_VAR 0 2
21225: PUSH
21226: LD_VAR 0 4
21230: ARRAY
21231: NONEQUAL
21232: IFFALSE 21244
// begin result := false ;
21234: LD_ADDR_VAR 0 3
21238: PUSH
21239: LD_INT 0
21241: ST_TO_ADDR
// break ;
21242: GO 21246
// end ;
21244: GO 21207
21246: POP
21247: POP
// end else
21248: GO 21258
// result := false ;
21250: LD_ADDR_VAR 0 3
21254: PUSH
21255: LD_INT 0
21257: ST_TO_ADDR
// end ;
21258: LD_VAR 0 3
21262: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21263: LD_INT 0
21265: PPUSH
21266: PPUSH
// if not array1 or not array2 then
21267: LD_VAR 0 1
21271: NOT
21272: PUSH
21273: LD_VAR 0 2
21277: NOT
21278: OR
21279: IFFALSE 21283
// exit ;
21281: GO 21347
// result := true ;
21283: LD_ADDR_VAR 0 3
21287: PUSH
21288: LD_INT 1
21290: ST_TO_ADDR
// for i = 1 to array1 do
21291: LD_ADDR_VAR 0 4
21295: PUSH
21296: DOUBLE
21297: LD_INT 1
21299: DEC
21300: ST_TO_ADDR
21301: LD_VAR 0 1
21305: PUSH
21306: FOR_TO
21307: IFFALSE 21345
// if array1 [ i ] <> array2 [ i ] then
21309: LD_VAR 0 1
21313: PUSH
21314: LD_VAR 0 4
21318: ARRAY
21319: PUSH
21320: LD_VAR 0 2
21324: PUSH
21325: LD_VAR 0 4
21329: ARRAY
21330: NONEQUAL
21331: IFFALSE 21343
// begin result := false ;
21333: LD_ADDR_VAR 0 3
21337: PUSH
21338: LD_INT 0
21340: ST_TO_ADDR
// break ;
21341: GO 21345
// end ;
21343: GO 21306
21345: POP
21346: POP
// end ;
21347: LD_VAR 0 3
21351: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21352: LD_INT 0
21354: PPUSH
21355: PPUSH
21356: PPUSH
// pom := GetBase ( fac ) ;
21357: LD_ADDR_VAR 0 5
21361: PUSH
21362: LD_VAR 0 1
21366: PPUSH
21367: CALL_OW 274
21371: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21372: LD_ADDR_VAR 0 4
21376: PUSH
21377: LD_VAR 0 2
21381: PUSH
21382: LD_INT 1
21384: ARRAY
21385: PPUSH
21386: LD_VAR 0 2
21390: PUSH
21391: LD_INT 2
21393: ARRAY
21394: PPUSH
21395: LD_VAR 0 2
21399: PUSH
21400: LD_INT 3
21402: ARRAY
21403: PPUSH
21404: LD_VAR 0 2
21408: PUSH
21409: LD_INT 4
21411: ARRAY
21412: PPUSH
21413: CALL_OW 449
21417: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21418: LD_ADDR_VAR 0 3
21422: PUSH
21423: LD_VAR 0 5
21427: PPUSH
21428: LD_INT 1
21430: PPUSH
21431: CALL_OW 275
21435: PUSH
21436: LD_VAR 0 4
21440: PUSH
21441: LD_INT 1
21443: ARRAY
21444: GREATEREQUAL
21445: PUSH
21446: LD_VAR 0 5
21450: PPUSH
21451: LD_INT 2
21453: PPUSH
21454: CALL_OW 275
21458: PUSH
21459: LD_VAR 0 4
21463: PUSH
21464: LD_INT 2
21466: ARRAY
21467: GREATEREQUAL
21468: AND
21469: PUSH
21470: LD_VAR 0 5
21474: PPUSH
21475: LD_INT 3
21477: PPUSH
21478: CALL_OW 275
21482: PUSH
21483: LD_VAR 0 4
21487: PUSH
21488: LD_INT 3
21490: ARRAY
21491: GREATEREQUAL
21492: AND
21493: ST_TO_ADDR
// end ;
21494: LD_VAR 0 3
21498: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21499: LD_INT 0
21501: PPUSH
21502: PPUSH
21503: PPUSH
21504: PPUSH
// pom := GetBase ( building ) ;
21505: LD_ADDR_VAR 0 3
21509: PUSH
21510: LD_VAR 0 1
21514: PPUSH
21515: CALL_OW 274
21519: ST_TO_ADDR
// if not pom then
21520: LD_VAR 0 3
21524: NOT
21525: IFFALSE 21529
// exit ;
21527: GO 21699
// btype := GetBType ( building ) ;
21529: LD_ADDR_VAR 0 5
21533: PUSH
21534: LD_VAR 0 1
21538: PPUSH
21539: CALL_OW 266
21543: ST_TO_ADDR
// if btype = b_armoury then
21544: LD_VAR 0 5
21548: PUSH
21549: LD_INT 4
21551: EQUAL
21552: IFFALSE 21562
// btype := b_barracks ;
21554: LD_ADDR_VAR 0 5
21558: PUSH
21559: LD_INT 5
21561: ST_TO_ADDR
// if btype = b_depot then
21562: LD_VAR 0 5
21566: PUSH
21567: LD_INT 0
21569: EQUAL
21570: IFFALSE 21580
// btype := b_warehouse ;
21572: LD_ADDR_VAR 0 5
21576: PUSH
21577: LD_INT 1
21579: ST_TO_ADDR
// if btype = b_workshop then
21580: LD_VAR 0 5
21584: PUSH
21585: LD_INT 2
21587: EQUAL
21588: IFFALSE 21598
// btype := b_factory ;
21590: LD_ADDR_VAR 0 5
21594: PUSH
21595: LD_INT 3
21597: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21598: LD_ADDR_VAR 0 4
21602: PUSH
21603: LD_VAR 0 5
21607: PPUSH
21608: LD_VAR 0 1
21612: PPUSH
21613: CALL_OW 248
21617: PPUSH
21618: CALL_OW 450
21622: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21623: LD_ADDR_VAR 0 2
21627: PUSH
21628: LD_VAR 0 3
21632: PPUSH
21633: LD_INT 1
21635: PPUSH
21636: CALL_OW 275
21640: PUSH
21641: LD_VAR 0 4
21645: PUSH
21646: LD_INT 1
21648: ARRAY
21649: GREATEREQUAL
21650: PUSH
21651: LD_VAR 0 3
21655: PPUSH
21656: LD_INT 2
21658: PPUSH
21659: CALL_OW 275
21663: PUSH
21664: LD_VAR 0 4
21668: PUSH
21669: LD_INT 2
21671: ARRAY
21672: GREATEREQUAL
21673: AND
21674: PUSH
21675: LD_VAR 0 3
21679: PPUSH
21680: LD_INT 3
21682: PPUSH
21683: CALL_OW 275
21687: PUSH
21688: LD_VAR 0 4
21692: PUSH
21693: LD_INT 3
21695: ARRAY
21696: GREATEREQUAL
21697: AND
21698: ST_TO_ADDR
// end ;
21699: LD_VAR 0 2
21703: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21704: LD_INT 0
21706: PPUSH
21707: PPUSH
21708: PPUSH
// pom := GetBase ( building ) ;
21709: LD_ADDR_VAR 0 4
21713: PUSH
21714: LD_VAR 0 1
21718: PPUSH
21719: CALL_OW 274
21723: ST_TO_ADDR
// if not pom then
21724: LD_VAR 0 4
21728: NOT
21729: IFFALSE 21733
// exit ;
21731: GO 21834
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21733: LD_ADDR_VAR 0 5
21737: PUSH
21738: LD_VAR 0 2
21742: PPUSH
21743: LD_VAR 0 1
21747: PPUSH
21748: CALL_OW 248
21752: PPUSH
21753: CALL_OW 450
21757: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21758: LD_ADDR_VAR 0 3
21762: PUSH
21763: LD_VAR 0 4
21767: PPUSH
21768: LD_INT 1
21770: PPUSH
21771: CALL_OW 275
21775: PUSH
21776: LD_VAR 0 5
21780: PUSH
21781: LD_INT 1
21783: ARRAY
21784: GREATEREQUAL
21785: PUSH
21786: LD_VAR 0 4
21790: PPUSH
21791: LD_INT 2
21793: PPUSH
21794: CALL_OW 275
21798: PUSH
21799: LD_VAR 0 5
21803: PUSH
21804: LD_INT 2
21806: ARRAY
21807: GREATEREQUAL
21808: AND
21809: PUSH
21810: LD_VAR 0 4
21814: PPUSH
21815: LD_INT 3
21817: PPUSH
21818: CALL_OW 275
21822: PUSH
21823: LD_VAR 0 5
21827: PUSH
21828: LD_INT 3
21830: ARRAY
21831: GREATEREQUAL
21832: AND
21833: ST_TO_ADDR
// end ;
21834: LD_VAR 0 3
21838: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21839: LD_INT 0
21841: PPUSH
21842: PPUSH
21843: PPUSH
21844: PPUSH
21845: PPUSH
21846: PPUSH
21847: PPUSH
21848: PPUSH
21849: PPUSH
21850: PPUSH
21851: PPUSH
// result := false ;
21852: LD_ADDR_VAR 0 8
21856: PUSH
21857: LD_INT 0
21859: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21860: LD_VAR 0 5
21864: NOT
21865: PUSH
21866: LD_VAR 0 1
21870: NOT
21871: OR
21872: PUSH
21873: LD_VAR 0 2
21877: NOT
21878: OR
21879: PUSH
21880: LD_VAR 0 3
21884: NOT
21885: OR
21886: IFFALSE 21890
// exit ;
21888: GO 22704
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21890: LD_ADDR_VAR 0 14
21894: PUSH
21895: LD_VAR 0 1
21899: PPUSH
21900: LD_VAR 0 2
21904: PPUSH
21905: LD_VAR 0 3
21909: PPUSH
21910: LD_VAR 0 4
21914: PPUSH
21915: LD_VAR 0 5
21919: PUSH
21920: LD_INT 1
21922: ARRAY
21923: PPUSH
21924: CALL_OW 248
21928: PPUSH
21929: LD_INT 0
21931: PPUSH
21932: CALL 23937 0 6
21936: ST_TO_ADDR
// if not hexes then
21937: LD_VAR 0 14
21941: NOT
21942: IFFALSE 21946
// exit ;
21944: GO 22704
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21946: LD_ADDR_VAR 0 17
21950: PUSH
21951: LD_VAR 0 5
21955: PPUSH
21956: LD_INT 22
21958: PUSH
21959: LD_VAR 0 13
21963: PPUSH
21964: CALL_OW 255
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: PUSH
21973: LD_INT 2
21975: PUSH
21976: LD_INT 30
21978: PUSH
21979: LD_INT 0
21981: PUSH
21982: EMPTY
21983: LIST
21984: LIST
21985: PUSH
21986: LD_INT 30
21988: PUSH
21989: LD_INT 1
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: LIST
22000: PUSH
22001: EMPTY
22002: LIST
22003: LIST
22004: PPUSH
22005: CALL_OW 72
22009: ST_TO_ADDR
// for i = 1 to hexes do
22010: LD_ADDR_VAR 0 9
22014: PUSH
22015: DOUBLE
22016: LD_INT 1
22018: DEC
22019: ST_TO_ADDR
22020: LD_VAR 0 14
22024: PUSH
22025: FOR_TO
22026: IFFALSE 22702
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22028: LD_ADDR_VAR 0 13
22032: PUSH
22033: LD_VAR 0 14
22037: PUSH
22038: LD_VAR 0 9
22042: ARRAY
22043: PUSH
22044: LD_INT 1
22046: ARRAY
22047: PPUSH
22048: LD_VAR 0 14
22052: PUSH
22053: LD_VAR 0 9
22057: ARRAY
22058: PUSH
22059: LD_INT 2
22061: ARRAY
22062: PPUSH
22063: CALL_OW 428
22067: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
22068: LD_VAR 0 14
22072: PUSH
22073: LD_VAR 0 9
22077: ARRAY
22078: PUSH
22079: LD_INT 1
22081: ARRAY
22082: PPUSH
22083: LD_VAR 0 14
22087: PUSH
22088: LD_VAR 0 9
22092: ARRAY
22093: PUSH
22094: LD_INT 2
22096: ARRAY
22097: PPUSH
22098: CALL_OW 351
22102: PUSH
22103: LD_VAR 0 14
22107: PUSH
22108: LD_VAR 0 9
22112: ARRAY
22113: PUSH
22114: LD_INT 1
22116: ARRAY
22117: PPUSH
22118: LD_VAR 0 14
22122: PUSH
22123: LD_VAR 0 9
22127: ARRAY
22128: PUSH
22129: LD_INT 2
22131: ARRAY
22132: PPUSH
22133: CALL_OW 488
22137: NOT
22138: OR
22139: PUSH
22140: LD_VAR 0 13
22144: PPUSH
22145: CALL_OW 247
22149: PUSH
22150: LD_INT 3
22152: EQUAL
22153: OR
22154: IFFALSE 22160
// exit ;
22156: POP
22157: POP
22158: GO 22704
// if not tmp then
22160: LD_VAR 0 13
22164: NOT
22165: IFFALSE 22169
// continue ;
22167: GO 22025
// result := true ;
22169: LD_ADDR_VAR 0 8
22173: PUSH
22174: LD_INT 1
22176: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22177: LD_VAR 0 6
22181: PUSH
22182: LD_VAR 0 13
22186: PPUSH
22187: CALL_OW 247
22191: PUSH
22192: LD_INT 2
22194: EQUAL
22195: AND
22196: PUSH
22197: LD_VAR 0 13
22201: PPUSH
22202: CALL_OW 263
22206: PUSH
22207: LD_INT 1
22209: EQUAL
22210: AND
22211: IFFALSE 22375
// begin if IsDrivenBy ( tmp ) then
22213: LD_VAR 0 13
22217: PPUSH
22218: CALL_OW 311
22222: IFFALSE 22226
// continue ;
22224: GO 22025
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22226: LD_VAR 0 6
22230: PPUSH
22231: LD_INT 3
22233: PUSH
22234: LD_INT 60
22236: PUSH
22237: EMPTY
22238: LIST
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: PUSH
22244: LD_INT 3
22246: PUSH
22247: LD_INT 55
22249: PUSH
22250: EMPTY
22251: LIST
22252: PUSH
22253: EMPTY
22254: LIST
22255: LIST
22256: PUSH
22257: EMPTY
22258: LIST
22259: LIST
22260: PPUSH
22261: CALL_OW 72
22265: IFFALSE 22373
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22267: LD_ADDR_VAR 0 18
22271: PUSH
22272: LD_VAR 0 6
22276: PPUSH
22277: LD_INT 3
22279: PUSH
22280: LD_INT 60
22282: PUSH
22283: EMPTY
22284: LIST
22285: PUSH
22286: EMPTY
22287: LIST
22288: LIST
22289: PUSH
22290: LD_INT 3
22292: PUSH
22293: LD_INT 55
22295: PUSH
22296: EMPTY
22297: LIST
22298: PUSH
22299: EMPTY
22300: LIST
22301: LIST
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: PPUSH
22307: CALL_OW 72
22311: PUSH
22312: LD_INT 1
22314: ARRAY
22315: ST_TO_ADDR
// if IsInUnit ( driver ) then
22316: LD_VAR 0 18
22320: PPUSH
22321: CALL_OW 310
22325: IFFALSE 22336
// ComExit ( driver ) ;
22327: LD_VAR 0 18
22331: PPUSH
22332: CALL 47717 0 1
// AddComEnterUnit ( driver , tmp ) ;
22336: LD_VAR 0 18
22340: PPUSH
22341: LD_VAR 0 13
22345: PPUSH
22346: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
22350: LD_VAR 0 18
22354: PPUSH
22355: LD_VAR 0 7
22359: PPUSH
22360: CALL_OW 173
// AddComExitVehicle ( driver ) ;
22364: LD_VAR 0 18
22368: PPUSH
22369: CALL_OW 181
// end ; continue ;
22373: GO 22025
// end ; if not cleaners or not tmp in cleaners then
22375: LD_VAR 0 6
22379: NOT
22380: PUSH
22381: LD_VAR 0 13
22385: PUSH
22386: LD_VAR 0 6
22390: IN
22391: NOT
22392: OR
22393: IFFALSE 22700
// begin if dep then
22395: LD_VAR 0 17
22399: IFFALSE 22535
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22401: LD_ADDR_VAR 0 16
22405: PUSH
22406: LD_VAR 0 17
22410: PUSH
22411: LD_INT 1
22413: ARRAY
22414: PPUSH
22415: CALL_OW 250
22419: PPUSH
22420: LD_VAR 0 17
22424: PUSH
22425: LD_INT 1
22427: ARRAY
22428: PPUSH
22429: CALL_OW 254
22433: PPUSH
22434: LD_INT 5
22436: PPUSH
22437: CALL_OW 272
22441: PUSH
22442: LD_VAR 0 17
22446: PUSH
22447: LD_INT 1
22449: ARRAY
22450: PPUSH
22451: CALL_OW 251
22455: PPUSH
22456: LD_VAR 0 17
22460: PUSH
22461: LD_INT 1
22463: ARRAY
22464: PPUSH
22465: CALL_OW 254
22469: PPUSH
22470: LD_INT 5
22472: PPUSH
22473: CALL_OW 273
22477: PUSH
22478: EMPTY
22479: LIST
22480: LIST
22481: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22482: LD_VAR 0 16
22486: PUSH
22487: LD_INT 1
22489: ARRAY
22490: PPUSH
22491: LD_VAR 0 16
22495: PUSH
22496: LD_INT 2
22498: ARRAY
22499: PPUSH
22500: CALL_OW 488
22504: IFFALSE 22535
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22506: LD_VAR 0 13
22510: PPUSH
22511: LD_VAR 0 16
22515: PUSH
22516: LD_INT 1
22518: ARRAY
22519: PPUSH
22520: LD_VAR 0 16
22524: PUSH
22525: LD_INT 2
22527: ARRAY
22528: PPUSH
22529: CALL_OW 111
// continue ;
22533: GO 22025
// end ; end ; r := GetDir ( tmp ) ;
22535: LD_ADDR_VAR 0 15
22539: PUSH
22540: LD_VAR 0 13
22544: PPUSH
22545: CALL_OW 254
22549: ST_TO_ADDR
// if r = 5 then
22550: LD_VAR 0 15
22554: PUSH
22555: LD_INT 5
22557: EQUAL
22558: IFFALSE 22568
// r := 0 ;
22560: LD_ADDR_VAR 0 15
22564: PUSH
22565: LD_INT 0
22567: ST_TO_ADDR
// for j = r to 5 do
22568: LD_ADDR_VAR 0 10
22572: PUSH
22573: DOUBLE
22574: LD_VAR 0 15
22578: DEC
22579: ST_TO_ADDR
22580: LD_INT 5
22582: PUSH
22583: FOR_TO
22584: IFFALSE 22698
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22586: LD_ADDR_VAR 0 11
22590: PUSH
22591: LD_VAR 0 13
22595: PPUSH
22596: CALL_OW 250
22600: PPUSH
22601: LD_VAR 0 10
22605: PPUSH
22606: LD_INT 2
22608: PPUSH
22609: CALL_OW 272
22613: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22614: LD_ADDR_VAR 0 12
22618: PUSH
22619: LD_VAR 0 13
22623: PPUSH
22624: CALL_OW 251
22628: PPUSH
22629: LD_VAR 0 10
22633: PPUSH
22634: LD_INT 2
22636: PPUSH
22637: CALL_OW 273
22641: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22642: LD_VAR 0 11
22646: PPUSH
22647: LD_VAR 0 12
22651: PPUSH
22652: CALL_OW 488
22656: PUSH
22657: LD_VAR 0 11
22661: PPUSH
22662: LD_VAR 0 12
22666: PPUSH
22667: CALL_OW 428
22671: NOT
22672: AND
22673: IFFALSE 22696
// begin ComMoveXY ( tmp , _x , _y ) ;
22675: LD_VAR 0 13
22679: PPUSH
22680: LD_VAR 0 11
22684: PPUSH
22685: LD_VAR 0 12
22689: PPUSH
22690: CALL_OW 111
// break ;
22694: GO 22698
// end ; end ;
22696: GO 22583
22698: POP
22699: POP
// end ; end ;
22700: GO 22025
22702: POP
22703: POP
// end ;
22704: LD_VAR 0 8
22708: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22709: LD_INT 0
22711: PPUSH
// result := true ;
22712: LD_ADDR_VAR 0 3
22716: PUSH
22717: LD_INT 1
22719: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22720: LD_VAR 0 2
22724: PUSH
22725: LD_INT 24
22727: DOUBLE
22728: EQUAL
22729: IFTRUE 22739
22731: LD_INT 33
22733: DOUBLE
22734: EQUAL
22735: IFTRUE 22739
22737: GO 22764
22739: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22740: LD_ADDR_VAR 0 3
22744: PUSH
22745: LD_INT 32
22747: PPUSH
22748: LD_VAR 0 1
22752: PPUSH
22753: CALL_OW 321
22757: PUSH
22758: LD_INT 2
22760: EQUAL
22761: ST_TO_ADDR
22762: GO 23080
22764: LD_INT 20
22766: DOUBLE
22767: EQUAL
22768: IFTRUE 22772
22770: GO 22797
22772: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22773: LD_ADDR_VAR 0 3
22777: PUSH
22778: LD_INT 6
22780: PPUSH
22781: LD_VAR 0 1
22785: PPUSH
22786: CALL_OW 321
22790: PUSH
22791: LD_INT 2
22793: EQUAL
22794: ST_TO_ADDR
22795: GO 23080
22797: LD_INT 22
22799: DOUBLE
22800: EQUAL
22801: IFTRUE 22811
22803: LD_INT 36
22805: DOUBLE
22806: EQUAL
22807: IFTRUE 22811
22809: GO 22836
22811: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22812: LD_ADDR_VAR 0 3
22816: PUSH
22817: LD_INT 15
22819: PPUSH
22820: LD_VAR 0 1
22824: PPUSH
22825: CALL_OW 321
22829: PUSH
22830: LD_INT 2
22832: EQUAL
22833: ST_TO_ADDR
22834: GO 23080
22836: LD_INT 30
22838: DOUBLE
22839: EQUAL
22840: IFTRUE 22844
22842: GO 22869
22844: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22845: LD_ADDR_VAR 0 3
22849: PUSH
22850: LD_INT 20
22852: PPUSH
22853: LD_VAR 0 1
22857: PPUSH
22858: CALL_OW 321
22862: PUSH
22863: LD_INT 2
22865: EQUAL
22866: ST_TO_ADDR
22867: GO 23080
22869: LD_INT 28
22871: DOUBLE
22872: EQUAL
22873: IFTRUE 22883
22875: LD_INT 21
22877: DOUBLE
22878: EQUAL
22879: IFTRUE 22883
22881: GO 22908
22883: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22884: LD_ADDR_VAR 0 3
22888: PUSH
22889: LD_INT 21
22891: PPUSH
22892: LD_VAR 0 1
22896: PPUSH
22897: CALL_OW 321
22901: PUSH
22902: LD_INT 2
22904: EQUAL
22905: ST_TO_ADDR
22906: GO 23080
22908: LD_INT 16
22910: DOUBLE
22911: EQUAL
22912: IFTRUE 22916
22914: GO 22941
22916: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22917: LD_ADDR_VAR 0 3
22921: PUSH
22922: LD_INT 84
22924: PPUSH
22925: LD_VAR 0 1
22929: PPUSH
22930: CALL_OW 321
22934: PUSH
22935: LD_INT 2
22937: EQUAL
22938: ST_TO_ADDR
22939: GO 23080
22941: LD_INT 19
22943: DOUBLE
22944: EQUAL
22945: IFTRUE 22955
22947: LD_INT 23
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 22980
22955: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22956: LD_ADDR_VAR 0 3
22960: PUSH
22961: LD_INT 83
22963: PPUSH
22964: LD_VAR 0 1
22968: PPUSH
22969: CALL_OW 321
22973: PUSH
22974: LD_INT 2
22976: EQUAL
22977: ST_TO_ADDR
22978: GO 23080
22980: LD_INT 17
22982: DOUBLE
22983: EQUAL
22984: IFTRUE 22988
22986: GO 23013
22988: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22989: LD_ADDR_VAR 0 3
22993: PUSH
22994: LD_INT 39
22996: PPUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 321
23006: PUSH
23007: LD_INT 2
23009: EQUAL
23010: ST_TO_ADDR
23011: GO 23080
23013: LD_INT 18
23015: DOUBLE
23016: EQUAL
23017: IFTRUE 23021
23019: GO 23046
23021: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
23022: LD_ADDR_VAR 0 3
23026: PUSH
23027: LD_INT 40
23029: PPUSH
23030: LD_VAR 0 1
23034: PPUSH
23035: CALL_OW 321
23039: PUSH
23040: LD_INT 2
23042: EQUAL
23043: ST_TO_ADDR
23044: GO 23080
23046: LD_INT 27
23048: DOUBLE
23049: EQUAL
23050: IFTRUE 23054
23052: GO 23079
23054: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
23055: LD_ADDR_VAR 0 3
23059: PUSH
23060: LD_INT 35
23062: PPUSH
23063: LD_VAR 0 1
23067: PPUSH
23068: CALL_OW 321
23072: PUSH
23073: LD_INT 2
23075: EQUAL
23076: ST_TO_ADDR
23077: GO 23080
23079: POP
// end ;
23080: LD_VAR 0 3
23084: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23085: LD_INT 0
23087: PPUSH
23088: PPUSH
23089: PPUSH
23090: PPUSH
23091: PPUSH
23092: PPUSH
23093: PPUSH
23094: PPUSH
23095: PPUSH
23096: PPUSH
23097: PPUSH
// result := false ;
23098: LD_ADDR_VAR 0 6
23102: PUSH
23103: LD_INT 0
23105: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23106: LD_VAR 0 1
23110: NOT
23111: PUSH
23112: LD_VAR 0 1
23116: PPUSH
23117: CALL_OW 266
23121: PUSH
23122: LD_INT 0
23124: PUSH
23125: LD_INT 1
23127: PUSH
23128: EMPTY
23129: LIST
23130: LIST
23131: IN
23132: NOT
23133: OR
23134: PUSH
23135: LD_VAR 0 2
23139: NOT
23140: OR
23141: PUSH
23142: LD_VAR 0 5
23146: PUSH
23147: LD_INT 0
23149: PUSH
23150: LD_INT 1
23152: PUSH
23153: LD_INT 2
23155: PUSH
23156: LD_INT 3
23158: PUSH
23159: LD_INT 4
23161: PUSH
23162: LD_INT 5
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: LIST
23169: LIST
23170: LIST
23171: LIST
23172: IN
23173: NOT
23174: OR
23175: PUSH
23176: LD_VAR 0 3
23180: PPUSH
23181: LD_VAR 0 4
23185: PPUSH
23186: CALL_OW 488
23190: NOT
23191: OR
23192: IFFALSE 23196
// exit ;
23194: GO 23932
// side := GetSide ( depot ) ;
23196: LD_ADDR_VAR 0 9
23200: PUSH
23201: LD_VAR 0 1
23205: PPUSH
23206: CALL_OW 255
23210: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23211: LD_VAR 0 9
23215: PPUSH
23216: LD_VAR 0 2
23220: PPUSH
23221: CALL 22709 0 2
23225: NOT
23226: IFFALSE 23230
// exit ;
23228: GO 23932
// pom := GetBase ( depot ) ;
23230: LD_ADDR_VAR 0 10
23234: PUSH
23235: LD_VAR 0 1
23239: PPUSH
23240: CALL_OW 274
23244: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23245: LD_ADDR_VAR 0 11
23249: PUSH
23250: LD_VAR 0 2
23254: PPUSH
23255: LD_VAR 0 1
23259: PPUSH
23260: CALL_OW 248
23264: PPUSH
23265: CALL_OW 450
23269: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23270: LD_VAR 0 10
23274: PPUSH
23275: LD_INT 1
23277: PPUSH
23278: CALL_OW 275
23282: PUSH
23283: LD_VAR 0 11
23287: PUSH
23288: LD_INT 1
23290: ARRAY
23291: GREATEREQUAL
23292: PUSH
23293: LD_VAR 0 10
23297: PPUSH
23298: LD_INT 2
23300: PPUSH
23301: CALL_OW 275
23305: PUSH
23306: LD_VAR 0 11
23310: PUSH
23311: LD_INT 2
23313: ARRAY
23314: GREATEREQUAL
23315: AND
23316: PUSH
23317: LD_VAR 0 10
23321: PPUSH
23322: LD_INT 3
23324: PPUSH
23325: CALL_OW 275
23329: PUSH
23330: LD_VAR 0 11
23334: PUSH
23335: LD_INT 3
23337: ARRAY
23338: GREATEREQUAL
23339: AND
23340: NOT
23341: IFFALSE 23345
// exit ;
23343: GO 23932
// if GetBType ( depot ) = b_depot then
23345: LD_VAR 0 1
23349: PPUSH
23350: CALL_OW 266
23354: PUSH
23355: LD_INT 0
23357: EQUAL
23358: IFFALSE 23370
// dist := 28 else
23360: LD_ADDR_VAR 0 14
23364: PUSH
23365: LD_INT 28
23367: ST_TO_ADDR
23368: GO 23378
// dist := 36 ;
23370: LD_ADDR_VAR 0 14
23374: PUSH
23375: LD_INT 36
23377: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23378: LD_VAR 0 1
23382: PPUSH
23383: LD_VAR 0 3
23387: PPUSH
23388: LD_VAR 0 4
23392: PPUSH
23393: CALL_OW 297
23397: PUSH
23398: LD_VAR 0 14
23402: GREATER
23403: IFFALSE 23407
// exit ;
23405: GO 23932
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23407: LD_ADDR_VAR 0 12
23411: PUSH
23412: LD_VAR 0 2
23416: PPUSH
23417: LD_VAR 0 3
23421: PPUSH
23422: LD_VAR 0 4
23426: PPUSH
23427: LD_VAR 0 5
23431: PPUSH
23432: LD_VAR 0 1
23436: PPUSH
23437: CALL_OW 248
23441: PPUSH
23442: LD_INT 0
23444: PPUSH
23445: CALL 23937 0 6
23449: ST_TO_ADDR
// if not hexes then
23450: LD_VAR 0 12
23454: NOT
23455: IFFALSE 23459
// exit ;
23457: GO 23932
// hex := GetHexInfo ( x , y ) ;
23459: LD_ADDR_VAR 0 15
23463: PUSH
23464: LD_VAR 0 3
23468: PPUSH
23469: LD_VAR 0 4
23473: PPUSH
23474: CALL_OW 546
23478: ST_TO_ADDR
// if hex [ 1 ] then
23479: LD_VAR 0 15
23483: PUSH
23484: LD_INT 1
23486: ARRAY
23487: IFFALSE 23491
// exit ;
23489: GO 23932
// height := hex [ 2 ] ;
23491: LD_ADDR_VAR 0 13
23495: PUSH
23496: LD_VAR 0 15
23500: PUSH
23501: LD_INT 2
23503: ARRAY
23504: ST_TO_ADDR
// for i = 1 to hexes do
23505: LD_ADDR_VAR 0 7
23509: PUSH
23510: DOUBLE
23511: LD_INT 1
23513: DEC
23514: ST_TO_ADDR
23515: LD_VAR 0 12
23519: PUSH
23520: FOR_TO
23521: IFFALSE 23851
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23523: LD_VAR 0 12
23527: PUSH
23528: LD_VAR 0 7
23532: ARRAY
23533: PUSH
23534: LD_INT 1
23536: ARRAY
23537: PPUSH
23538: LD_VAR 0 12
23542: PUSH
23543: LD_VAR 0 7
23547: ARRAY
23548: PUSH
23549: LD_INT 2
23551: ARRAY
23552: PPUSH
23553: CALL_OW 488
23557: NOT
23558: PUSH
23559: LD_VAR 0 12
23563: PUSH
23564: LD_VAR 0 7
23568: ARRAY
23569: PUSH
23570: LD_INT 1
23572: ARRAY
23573: PPUSH
23574: LD_VAR 0 12
23578: PUSH
23579: LD_VAR 0 7
23583: ARRAY
23584: PUSH
23585: LD_INT 2
23587: ARRAY
23588: PPUSH
23589: CALL_OW 428
23593: PUSH
23594: LD_INT 0
23596: GREATER
23597: OR
23598: PUSH
23599: LD_VAR 0 12
23603: PUSH
23604: LD_VAR 0 7
23608: ARRAY
23609: PUSH
23610: LD_INT 1
23612: ARRAY
23613: PPUSH
23614: LD_VAR 0 12
23618: PUSH
23619: LD_VAR 0 7
23623: ARRAY
23624: PUSH
23625: LD_INT 2
23627: ARRAY
23628: PPUSH
23629: CALL_OW 351
23633: OR
23634: IFFALSE 23640
// exit ;
23636: POP
23637: POP
23638: GO 23932
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23640: LD_ADDR_VAR 0 8
23644: PUSH
23645: LD_VAR 0 12
23649: PUSH
23650: LD_VAR 0 7
23654: ARRAY
23655: PUSH
23656: LD_INT 1
23658: ARRAY
23659: PPUSH
23660: LD_VAR 0 12
23664: PUSH
23665: LD_VAR 0 7
23669: ARRAY
23670: PUSH
23671: LD_INT 2
23673: ARRAY
23674: PPUSH
23675: CALL_OW 546
23679: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23680: LD_VAR 0 8
23684: PUSH
23685: LD_INT 1
23687: ARRAY
23688: PUSH
23689: LD_VAR 0 8
23693: PUSH
23694: LD_INT 2
23696: ARRAY
23697: PUSH
23698: LD_VAR 0 13
23702: PUSH
23703: LD_INT 2
23705: PLUS
23706: GREATER
23707: OR
23708: PUSH
23709: LD_VAR 0 8
23713: PUSH
23714: LD_INT 2
23716: ARRAY
23717: PUSH
23718: LD_VAR 0 13
23722: PUSH
23723: LD_INT 2
23725: MINUS
23726: LESS
23727: OR
23728: PUSH
23729: LD_VAR 0 8
23733: PUSH
23734: LD_INT 3
23736: ARRAY
23737: PUSH
23738: LD_INT 0
23740: PUSH
23741: LD_INT 8
23743: PUSH
23744: LD_INT 9
23746: PUSH
23747: LD_INT 10
23749: PUSH
23750: LD_INT 11
23752: PUSH
23753: LD_INT 12
23755: PUSH
23756: LD_INT 13
23758: PUSH
23759: LD_INT 16
23761: PUSH
23762: LD_INT 17
23764: PUSH
23765: LD_INT 18
23767: PUSH
23768: LD_INT 19
23770: PUSH
23771: LD_INT 20
23773: PUSH
23774: LD_INT 21
23776: PUSH
23777: EMPTY
23778: LIST
23779: LIST
23780: LIST
23781: LIST
23782: LIST
23783: LIST
23784: LIST
23785: LIST
23786: LIST
23787: LIST
23788: LIST
23789: LIST
23790: LIST
23791: IN
23792: NOT
23793: OR
23794: PUSH
23795: LD_VAR 0 8
23799: PUSH
23800: LD_INT 5
23802: ARRAY
23803: NOT
23804: OR
23805: PUSH
23806: LD_VAR 0 8
23810: PUSH
23811: LD_INT 6
23813: ARRAY
23814: PUSH
23815: LD_INT 1
23817: PUSH
23818: LD_INT 2
23820: PUSH
23821: LD_INT 7
23823: PUSH
23824: LD_INT 9
23826: PUSH
23827: LD_INT 10
23829: PUSH
23830: LD_INT 11
23832: PUSH
23833: EMPTY
23834: LIST
23835: LIST
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: IN
23841: NOT
23842: OR
23843: IFFALSE 23849
// exit ;
23845: POP
23846: POP
23847: GO 23932
// end ;
23849: GO 23520
23851: POP
23852: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23853: LD_VAR 0 9
23857: PPUSH
23858: LD_VAR 0 3
23862: PPUSH
23863: LD_VAR 0 4
23867: PPUSH
23868: LD_INT 20
23870: PPUSH
23871: CALL 15884 0 4
23875: PUSH
23876: LD_INT 4
23878: ARRAY
23879: IFFALSE 23883
// exit ;
23881: GO 23932
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23883: LD_VAR 0 2
23887: PUSH
23888: LD_INT 29
23890: PUSH
23891: LD_INT 30
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: IN
23898: PUSH
23899: LD_VAR 0 3
23903: PPUSH
23904: LD_VAR 0 4
23908: PPUSH
23909: LD_VAR 0 9
23913: PPUSH
23914: CALL_OW 440
23918: NOT
23919: AND
23920: IFFALSE 23924
// exit ;
23922: GO 23932
// result := true ;
23924: LD_ADDR_VAR 0 6
23928: PUSH
23929: LD_INT 1
23931: ST_TO_ADDR
// end ;
23932: LD_VAR 0 6
23936: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23937: LD_INT 0
23939: PPUSH
23940: PPUSH
23941: PPUSH
23942: PPUSH
23943: PPUSH
23944: PPUSH
23945: PPUSH
23946: PPUSH
23947: PPUSH
23948: PPUSH
23949: PPUSH
23950: PPUSH
23951: PPUSH
23952: PPUSH
23953: PPUSH
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
23960: PPUSH
23961: PPUSH
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
23974: PPUSH
23975: PPUSH
23976: PPUSH
23977: PPUSH
23978: PPUSH
23979: PPUSH
23980: PPUSH
23981: PPUSH
23982: PPUSH
23983: PPUSH
23984: PPUSH
23985: PPUSH
23986: PPUSH
23987: PPUSH
23988: PPUSH
23989: PPUSH
23990: PPUSH
23991: PPUSH
23992: PPUSH
23993: PPUSH
23994: PPUSH
23995: PPUSH
23996: PPUSH
// result = [ ] ;
23997: LD_ADDR_VAR 0 7
24001: PUSH
24002: EMPTY
24003: ST_TO_ADDR
// temp_list = [ ] ;
24004: LD_ADDR_VAR 0 9
24008: PUSH
24009: EMPTY
24010: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
24011: LD_VAR 0 4
24015: PUSH
24016: LD_INT 0
24018: PUSH
24019: LD_INT 1
24021: PUSH
24022: LD_INT 2
24024: PUSH
24025: LD_INT 3
24027: PUSH
24028: LD_INT 4
24030: PUSH
24031: LD_INT 5
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: LIST
24038: LIST
24039: LIST
24040: LIST
24041: IN
24042: NOT
24043: PUSH
24044: LD_VAR 0 1
24048: PUSH
24049: LD_INT 0
24051: PUSH
24052: LD_INT 1
24054: PUSH
24055: EMPTY
24056: LIST
24057: LIST
24058: IN
24059: PUSH
24060: LD_VAR 0 5
24064: PUSH
24065: LD_INT 1
24067: PUSH
24068: LD_INT 2
24070: PUSH
24071: LD_INT 3
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: LIST
24078: IN
24079: NOT
24080: AND
24081: OR
24082: IFFALSE 24086
// exit ;
24084: GO 42477
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24086: LD_VAR 0 1
24090: PUSH
24091: LD_INT 6
24093: PUSH
24094: LD_INT 7
24096: PUSH
24097: LD_INT 8
24099: PUSH
24100: LD_INT 13
24102: PUSH
24103: LD_INT 12
24105: PUSH
24106: LD_INT 15
24108: PUSH
24109: LD_INT 11
24111: PUSH
24112: LD_INT 14
24114: PUSH
24115: LD_INT 10
24117: PUSH
24118: EMPTY
24119: LIST
24120: LIST
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: LIST
24128: IN
24129: IFFALSE 24139
// btype = b_lab ;
24131: LD_ADDR_VAR 0 1
24135: PUSH
24136: LD_INT 6
24138: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24139: LD_VAR 0 6
24143: PUSH
24144: LD_INT 0
24146: PUSH
24147: LD_INT 1
24149: PUSH
24150: LD_INT 2
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: LIST
24157: IN
24158: NOT
24159: PUSH
24160: LD_VAR 0 1
24164: PUSH
24165: LD_INT 0
24167: PUSH
24168: LD_INT 1
24170: PUSH
24171: LD_INT 2
24173: PUSH
24174: LD_INT 3
24176: PUSH
24177: LD_INT 6
24179: PUSH
24180: LD_INT 36
24182: PUSH
24183: LD_INT 4
24185: PUSH
24186: LD_INT 5
24188: PUSH
24189: LD_INT 31
24191: PUSH
24192: LD_INT 32
24194: PUSH
24195: LD_INT 33
24197: PUSH
24198: EMPTY
24199: LIST
24200: LIST
24201: LIST
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: LIST
24207: LIST
24208: LIST
24209: LIST
24210: IN
24211: NOT
24212: PUSH
24213: LD_VAR 0 6
24217: PUSH
24218: LD_INT 1
24220: EQUAL
24221: AND
24222: OR
24223: PUSH
24224: LD_VAR 0 1
24228: PUSH
24229: LD_INT 2
24231: PUSH
24232: LD_INT 3
24234: PUSH
24235: EMPTY
24236: LIST
24237: LIST
24238: IN
24239: NOT
24240: PUSH
24241: LD_VAR 0 6
24245: PUSH
24246: LD_INT 2
24248: EQUAL
24249: AND
24250: OR
24251: IFFALSE 24261
// mode = 0 ;
24253: LD_ADDR_VAR 0 6
24257: PUSH
24258: LD_INT 0
24260: ST_TO_ADDR
// case mode of 0 :
24261: LD_VAR 0 6
24265: PUSH
24266: LD_INT 0
24268: DOUBLE
24269: EQUAL
24270: IFTRUE 24274
24272: GO 35727
24274: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24275: LD_ADDR_VAR 0 11
24279: PUSH
24280: LD_INT 0
24282: PUSH
24283: LD_INT 0
24285: PUSH
24286: EMPTY
24287: LIST
24288: LIST
24289: PUSH
24290: LD_INT 0
24292: PUSH
24293: LD_INT 1
24295: NEG
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: PUSH
24301: LD_INT 1
24303: PUSH
24304: LD_INT 0
24306: PUSH
24307: EMPTY
24308: LIST
24309: LIST
24310: PUSH
24311: LD_INT 1
24313: PUSH
24314: LD_INT 1
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: PUSH
24321: LD_INT 0
24323: PUSH
24324: LD_INT 1
24326: PUSH
24327: EMPTY
24328: LIST
24329: LIST
24330: PUSH
24331: LD_INT 1
24333: NEG
24334: PUSH
24335: LD_INT 0
24337: PUSH
24338: EMPTY
24339: LIST
24340: LIST
24341: PUSH
24342: LD_INT 1
24344: NEG
24345: PUSH
24346: LD_INT 1
24348: NEG
24349: PUSH
24350: EMPTY
24351: LIST
24352: LIST
24353: PUSH
24354: LD_INT 1
24356: NEG
24357: PUSH
24358: LD_INT 2
24360: NEG
24361: PUSH
24362: EMPTY
24363: LIST
24364: LIST
24365: PUSH
24366: LD_INT 0
24368: PUSH
24369: LD_INT 2
24371: NEG
24372: PUSH
24373: EMPTY
24374: LIST
24375: LIST
24376: PUSH
24377: LD_INT 1
24379: PUSH
24380: LD_INT 1
24382: NEG
24383: PUSH
24384: EMPTY
24385: LIST
24386: LIST
24387: PUSH
24388: LD_INT 1
24390: PUSH
24391: LD_INT 2
24393: PUSH
24394: EMPTY
24395: LIST
24396: LIST
24397: PUSH
24398: LD_INT 0
24400: PUSH
24401: LD_INT 2
24403: PUSH
24404: EMPTY
24405: LIST
24406: LIST
24407: PUSH
24408: LD_INT 1
24410: NEG
24411: PUSH
24412: LD_INT 1
24414: PUSH
24415: EMPTY
24416: LIST
24417: LIST
24418: PUSH
24419: LD_INT 1
24421: PUSH
24422: LD_INT 3
24424: PUSH
24425: EMPTY
24426: LIST
24427: LIST
24428: PUSH
24429: LD_INT 0
24431: PUSH
24432: LD_INT 3
24434: PUSH
24435: EMPTY
24436: LIST
24437: LIST
24438: PUSH
24439: LD_INT 1
24441: NEG
24442: PUSH
24443: LD_INT 2
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: LIST
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: LIST
24459: LIST
24460: LIST
24461: LIST
24462: LIST
24463: LIST
24464: LIST
24465: LIST
24466: LIST
24467: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24468: LD_ADDR_VAR 0 12
24472: PUSH
24473: LD_INT 0
24475: PUSH
24476: LD_INT 0
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: PUSH
24483: LD_INT 0
24485: PUSH
24486: LD_INT 1
24488: NEG
24489: PUSH
24490: EMPTY
24491: LIST
24492: LIST
24493: PUSH
24494: LD_INT 1
24496: PUSH
24497: LD_INT 0
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: PUSH
24504: LD_INT 1
24506: PUSH
24507: LD_INT 1
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 0
24516: PUSH
24517: LD_INT 1
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PUSH
24524: LD_INT 1
24526: NEG
24527: PUSH
24528: LD_INT 0
24530: PUSH
24531: EMPTY
24532: LIST
24533: LIST
24534: PUSH
24535: LD_INT 1
24537: NEG
24538: PUSH
24539: LD_INT 1
24541: NEG
24542: PUSH
24543: EMPTY
24544: LIST
24545: LIST
24546: PUSH
24547: LD_INT 1
24549: PUSH
24550: LD_INT 1
24552: NEG
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: PUSH
24558: LD_INT 2
24560: PUSH
24561: LD_INT 0
24563: PUSH
24564: EMPTY
24565: LIST
24566: LIST
24567: PUSH
24568: LD_INT 2
24570: PUSH
24571: LD_INT 1
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: LD_INT 1
24580: NEG
24581: PUSH
24582: LD_INT 1
24584: PUSH
24585: EMPTY
24586: LIST
24587: LIST
24588: PUSH
24589: LD_INT 2
24591: NEG
24592: PUSH
24593: LD_INT 0
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: LD_INT 2
24602: NEG
24603: PUSH
24604: LD_INT 1
24606: NEG
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: PUSH
24612: LD_INT 2
24614: NEG
24615: PUSH
24616: LD_INT 1
24618: PUSH
24619: EMPTY
24620: LIST
24621: LIST
24622: PUSH
24623: LD_INT 3
24625: NEG
24626: PUSH
24627: LD_INT 0
24629: PUSH
24630: EMPTY
24631: LIST
24632: LIST
24633: PUSH
24634: LD_INT 3
24636: NEG
24637: PUSH
24638: LD_INT 1
24640: NEG
24641: PUSH
24642: EMPTY
24643: LIST
24644: LIST
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: LIST
24650: LIST
24651: LIST
24652: LIST
24653: LIST
24654: LIST
24655: LIST
24656: LIST
24657: LIST
24658: LIST
24659: LIST
24660: LIST
24661: LIST
24662: LIST
24663: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24664: LD_ADDR_VAR 0 13
24668: PUSH
24669: LD_INT 0
24671: PUSH
24672: LD_INT 0
24674: PUSH
24675: EMPTY
24676: LIST
24677: LIST
24678: PUSH
24679: LD_INT 0
24681: PUSH
24682: LD_INT 1
24684: NEG
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: PUSH
24690: LD_INT 1
24692: PUSH
24693: LD_INT 0
24695: PUSH
24696: EMPTY
24697: LIST
24698: LIST
24699: PUSH
24700: LD_INT 1
24702: PUSH
24703: LD_INT 1
24705: PUSH
24706: EMPTY
24707: LIST
24708: LIST
24709: PUSH
24710: LD_INT 0
24712: PUSH
24713: LD_INT 1
24715: PUSH
24716: EMPTY
24717: LIST
24718: LIST
24719: PUSH
24720: LD_INT 1
24722: NEG
24723: PUSH
24724: LD_INT 0
24726: PUSH
24727: EMPTY
24728: LIST
24729: LIST
24730: PUSH
24731: LD_INT 1
24733: NEG
24734: PUSH
24735: LD_INT 1
24737: NEG
24738: PUSH
24739: EMPTY
24740: LIST
24741: LIST
24742: PUSH
24743: LD_INT 1
24745: NEG
24746: PUSH
24747: LD_INT 2
24749: NEG
24750: PUSH
24751: EMPTY
24752: LIST
24753: LIST
24754: PUSH
24755: LD_INT 2
24757: PUSH
24758: LD_INT 1
24760: PUSH
24761: EMPTY
24762: LIST
24763: LIST
24764: PUSH
24765: LD_INT 2
24767: PUSH
24768: LD_INT 2
24770: PUSH
24771: EMPTY
24772: LIST
24773: LIST
24774: PUSH
24775: LD_INT 1
24777: PUSH
24778: LD_INT 2
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 2
24787: NEG
24788: PUSH
24789: LD_INT 1
24791: NEG
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 2
24799: NEG
24800: PUSH
24801: LD_INT 2
24803: NEG
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: LD_INT 2
24811: NEG
24812: PUSH
24813: LD_INT 3
24815: NEG
24816: PUSH
24817: EMPTY
24818: LIST
24819: LIST
24820: PUSH
24821: LD_INT 3
24823: NEG
24824: PUSH
24825: LD_INT 2
24827: NEG
24828: PUSH
24829: EMPTY
24830: LIST
24831: LIST
24832: PUSH
24833: LD_INT 3
24835: NEG
24836: PUSH
24837: LD_INT 3
24839: NEG
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: LIST
24849: LIST
24850: LIST
24851: LIST
24852: LIST
24853: LIST
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: LIST
24862: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24863: LD_ADDR_VAR 0 14
24867: PUSH
24868: LD_INT 0
24870: PUSH
24871: LD_INT 0
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: PUSH
24878: LD_INT 0
24880: PUSH
24881: LD_INT 1
24883: NEG
24884: PUSH
24885: EMPTY
24886: LIST
24887: LIST
24888: PUSH
24889: LD_INT 1
24891: PUSH
24892: LD_INT 0
24894: PUSH
24895: EMPTY
24896: LIST
24897: LIST
24898: PUSH
24899: LD_INT 1
24901: PUSH
24902: LD_INT 1
24904: PUSH
24905: EMPTY
24906: LIST
24907: LIST
24908: PUSH
24909: LD_INT 0
24911: PUSH
24912: LD_INT 1
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: PUSH
24919: LD_INT 1
24921: NEG
24922: PUSH
24923: LD_INT 0
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 1
24932: NEG
24933: PUSH
24934: LD_INT 1
24936: NEG
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PUSH
24942: LD_INT 1
24944: NEG
24945: PUSH
24946: LD_INT 2
24948: NEG
24949: PUSH
24950: EMPTY
24951: LIST
24952: LIST
24953: PUSH
24954: LD_INT 0
24956: PUSH
24957: LD_INT 2
24959: NEG
24960: PUSH
24961: EMPTY
24962: LIST
24963: LIST
24964: PUSH
24965: LD_INT 1
24967: PUSH
24968: LD_INT 1
24970: NEG
24971: PUSH
24972: EMPTY
24973: LIST
24974: LIST
24975: PUSH
24976: LD_INT 1
24978: PUSH
24979: LD_INT 2
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: PUSH
24986: LD_INT 0
24988: PUSH
24989: LD_INT 2
24991: PUSH
24992: EMPTY
24993: LIST
24994: LIST
24995: PUSH
24996: LD_INT 1
24998: NEG
24999: PUSH
25000: LD_INT 1
25002: PUSH
25003: EMPTY
25004: LIST
25005: LIST
25006: PUSH
25007: LD_INT 1
25009: NEG
25010: PUSH
25011: LD_INT 3
25013: NEG
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: PUSH
25019: LD_INT 0
25021: PUSH
25022: LD_INT 3
25024: NEG
25025: PUSH
25026: EMPTY
25027: LIST
25028: LIST
25029: PUSH
25030: LD_INT 1
25032: PUSH
25033: LD_INT 2
25035: NEG
25036: PUSH
25037: EMPTY
25038: LIST
25039: LIST
25040: PUSH
25041: EMPTY
25042: LIST
25043: LIST
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: LIST
25050: LIST
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: LIST
25056: LIST
25057: LIST
25058: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
25059: LD_ADDR_VAR 0 15
25063: PUSH
25064: LD_INT 0
25066: PUSH
25067: LD_INT 0
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: LD_INT 0
25076: PUSH
25077: LD_INT 1
25079: NEG
25080: PUSH
25081: EMPTY
25082: LIST
25083: LIST
25084: PUSH
25085: LD_INT 1
25087: PUSH
25088: LD_INT 0
25090: PUSH
25091: EMPTY
25092: LIST
25093: LIST
25094: PUSH
25095: LD_INT 1
25097: PUSH
25098: LD_INT 1
25100: PUSH
25101: EMPTY
25102: LIST
25103: LIST
25104: PUSH
25105: LD_INT 0
25107: PUSH
25108: LD_INT 1
25110: PUSH
25111: EMPTY
25112: LIST
25113: LIST
25114: PUSH
25115: LD_INT 1
25117: NEG
25118: PUSH
25119: LD_INT 0
25121: PUSH
25122: EMPTY
25123: LIST
25124: LIST
25125: PUSH
25126: LD_INT 1
25128: NEG
25129: PUSH
25130: LD_INT 1
25132: NEG
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PUSH
25138: LD_INT 1
25140: PUSH
25141: LD_INT 1
25143: NEG
25144: PUSH
25145: EMPTY
25146: LIST
25147: LIST
25148: PUSH
25149: LD_INT 2
25151: PUSH
25152: LD_INT 0
25154: PUSH
25155: EMPTY
25156: LIST
25157: LIST
25158: PUSH
25159: LD_INT 2
25161: PUSH
25162: LD_INT 1
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: PUSH
25169: LD_INT 1
25171: NEG
25172: PUSH
25173: LD_INT 1
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: PUSH
25180: LD_INT 2
25182: NEG
25183: PUSH
25184: LD_INT 0
25186: PUSH
25187: EMPTY
25188: LIST
25189: LIST
25190: PUSH
25191: LD_INT 2
25193: NEG
25194: PUSH
25195: LD_INT 1
25197: NEG
25198: PUSH
25199: EMPTY
25200: LIST
25201: LIST
25202: PUSH
25203: LD_INT 2
25205: PUSH
25206: LD_INT 1
25208: NEG
25209: PUSH
25210: EMPTY
25211: LIST
25212: LIST
25213: PUSH
25214: LD_INT 3
25216: PUSH
25217: LD_INT 0
25219: PUSH
25220: EMPTY
25221: LIST
25222: LIST
25223: PUSH
25224: LD_INT 3
25226: PUSH
25227: LD_INT 1
25229: PUSH
25230: EMPTY
25231: LIST
25232: LIST
25233: PUSH
25234: EMPTY
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25252: LD_ADDR_VAR 0 16
25256: PUSH
25257: LD_INT 0
25259: PUSH
25260: LD_INT 0
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: PUSH
25267: LD_INT 0
25269: PUSH
25270: LD_INT 1
25272: NEG
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 1
25280: PUSH
25281: LD_INT 0
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PUSH
25288: LD_INT 1
25290: PUSH
25291: LD_INT 1
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: PUSH
25298: LD_INT 0
25300: PUSH
25301: LD_INT 1
25303: PUSH
25304: EMPTY
25305: LIST
25306: LIST
25307: PUSH
25308: LD_INT 1
25310: NEG
25311: PUSH
25312: LD_INT 0
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: LD_INT 1
25321: NEG
25322: PUSH
25323: LD_INT 1
25325: NEG
25326: PUSH
25327: EMPTY
25328: LIST
25329: LIST
25330: PUSH
25331: LD_INT 1
25333: NEG
25334: PUSH
25335: LD_INT 2
25337: NEG
25338: PUSH
25339: EMPTY
25340: LIST
25341: LIST
25342: PUSH
25343: LD_INT 2
25345: PUSH
25346: LD_INT 1
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: PUSH
25353: LD_INT 2
25355: PUSH
25356: LD_INT 2
25358: PUSH
25359: EMPTY
25360: LIST
25361: LIST
25362: PUSH
25363: LD_INT 1
25365: PUSH
25366: LD_INT 2
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: PUSH
25373: LD_INT 2
25375: NEG
25376: PUSH
25377: LD_INT 1
25379: NEG
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: PUSH
25385: LD_INT 2
25387: NEG
25388: PUSH
25389: LD_INT 2
25391: NEG
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 3
25399: PUSH
25400: LD_INT 2
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 3
25409: PUSH
25410: LD_INT 3
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: LD_INT 2
25419: PUSH
25420: LD_INT 3
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: EMPTY
25428: LIST
25429: LIST
25430: LIST
25431: LIST
25432: LIST
25433: LIST
25434: LIST
25435: LIST
25436: LIST
25437: LIST
25438: LIST
25439: LIST
25440: LIST
25441: LIST
25442: LIST
25443: LIST
25444: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25445: LD_ADDR_VAR 0 17
25449: PUSH
25450: LD_INT 0
25452: PUSH
25453: LD_INT 0
25455: PUSH
25456: EMPTY
25457: LIST
25458: LIST
25459: PUSH
25460: LD_INT 0
25462: PUSH
25463: LD_INT 1
25465: NEG
25466: PUSH
25467: EMPTY
25468: LIST
25469: LIST
25470: PUSH
25471: LD_INT 1
25473: PUSH
25474: LD_INT 0
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: PUSH
25481: LD_INT 1
25483: PUSH
25484: LD_INT 1
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 0
25493: PUSH
25494: LD_INT 1
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PUSH
25501: LD_INT 1
25503: NEG
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: PUSH
25512: LD_INT 1
25514: NEG
25515: PUSH
25516: LD_INT 1
25518: NEG
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: PUSH
25524: LD_INT 1
25526: NEG
25527: PUSH
25528: LD_INT 2
25530: NEG
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: LD_INT 2
25541: NEG
25542: PUSH
25543: EMPTY
25544: LIST
25545: LIST
25546: PUSH
25547: LD_INT 1
25549: PUSH
25550: LD_INT 1
25552: NEG
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: PUSH
25558: LD_INT 2
25560: PUSH
25561: LD_INT 0
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: LD_INT 2
25570: PUSH
25571: LD_INT 1
25573: PUSH
25574: EMPTY
25575: LIST
25576: LIST
25577: PUSH
25578: LD_INT 2
25580: PUSH
25581: LD_INT 2
25583: PUSH
25584: EMPTY
25585: LIST
25586: LIST
25587: PUSH
25588: LD_INT 1
25590: PUSH
25591: LD_INT 2
25593: PUSH
25594: EMPTY
25595: LIST
25596: LIST
25597: PUSH
25598: LD_INT 0
25600: PUSH
25601: LD_INT 2
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 1
25610: NEG
25611: PUSH
25612: LD_INT 1
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: PUSH
25619: LD_INT 2
25621: NEG
25622: PUSH
25623: LD_INT 0
25625: PUSH
25626: EMPTY
25627: LIST
25628: LIST
25629: PUSH
25630: LD_INT 2
25632: NEG
25633: PUSH
25634: LD_INT 1
25636: NEG
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 2
25644: NEG
25645: PUSH
25646: LD_INT 2
25648: NEG
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: LIST
25672: LIST
25673: LIST
25674: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25675: LD_ADDR_VAR 0 18
25679: PUSH
25680: LD_INT 0
25682: PUSH
25683: LD_INT 0
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 0
25692: PUSH
25693: LD_INT 1
25695: NEG
25696: PUSH
25697: EMPTY
25698: LIST
25699: LIST
25700: PUSH
25701: LD_INT 1
25703: PUSH
25704: LD_INT 0
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: LD_INT 1
25713: PUSH
25714: LD_INT 1
25716: PUSH
25717: EMPTY
25718: LIST
25719: LIST
25720: PUSH
25721: LD_INT 0
25723: PUSH
25724: LD_INT 1
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 1
25733: NEG
25734: PUSH
25735: LD_INT 0
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: LD_INT 1
25744: NEG
25745: PUSH
25746: LD_INT 1
25748: NEG
25749: PUSH
25750: EMPTY
25751: LIST
25752: LIST
25753: PUSH
25754: LD_INT 1
25756: NEG
25757: PUSH
25758: LD_INT 2
25760: NEG
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: LD_INT 0
25768: PUSH
25769: LD_INT 2
25771: NEG
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: PUSH
25777: LD_INT 1
25779: PUSH
25780: LD_INT 1
25782: NEG
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: PUSH
25788: LD_INT 2
25790: PUSH
25791: LD_INT 0
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: PUSH
25798: LD_INT 2
25800: PUSH
25801: LD_INT 1
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: PUSH
25808: LD_INT 2
25810: PUSH
25811: LD_INT 2
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PUSH
25818: LD_INT 1
25820: PUSH
25821: LD_INT 2
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: LD_INT 0
25830: PUSH
25831: LD_INT 2
25833: PUSH
25834: EMPTY
25835: LIST
25836: LIST
25837: PUSH
25838: LD_INT 1
25840: NEG
25841: PUSH
25842: LD_INT 1
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: PUSH
25849: LD_INT 2
25851: NEG
25852: PUSH
25853: LD_INT 0
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 2
25862: NEG
25863: PUSH
25864: LD_INT 1
25866: NEG
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: PUSH
25872: LD_INT 2
25874: NEG
25875: PUSH
25876: LD_INT 2
25878: NEG
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: LIST
25888: LIST
25889: LIST
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: LIST
25898: LIST
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: LIST
25904: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25905: LD_ADDR_VAR 0 19
25909: PUSH
25910: LD_INT 0
25912: PUSH
25913: LD_INT 0
25915: PUSH
25916: EMPTY
25917: LIST
25918: LIST
25919: PUSH
25920: LD_INT 0
25922: PUSH
25923: LD_INT 1
25925: NEG
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PUSH
25931: LD_INT 1
25933: PUSH
25934: LD_INT 0
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: PUSH
25941: LD_INT 1
25943: PUSH
25944: LD_INT 1
25946: PUSH
25947: EMPTY
25948: LIST
25949: LIST
25950: PUSH
25951: LD_INT 0
25953: PUSH
25954: LD_INT 1
25956: PUSH
25957: EMPTY
25958: LIST
25959: LIST
25960: PUSH
25961: LD_INT 1
25963: NEG
25964: PUSH
25965: LD_INT 0
25967: PUSH
25968: EMPTY
25969: LIST
25970: LIST
25971: PUSH
25972: LD_INT 1
25974: NEG
25975: PUSH
25976: LD_INT 1
25978: NEG
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PUSH
25984: LD_INT 1
25986: NEG
25987: PUSH
25988: LD_INT 2
25990: NEG
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: PUSH
25996: LD_INT 0
25998: PUSH
25999: LD_INT 2
26001: NEG
26002: PUSH
26003: EMPTY
26004: LIST
26005: LIST
26006: PUSH
26007: LD_INT 1
26009: PUSH
26010: LD_INT 1
26012: NEG
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: PUSH
26018: LD_INT 2
26020: PUSH
26021: LD_INT 0
26023: PUSH
26024: EMPTY
26025: LIST
26026: LIST
26027: PUSH
26028: LD_INT 2
26030: PUSH
26031: LD_INT 1
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 2
26040: PUSH
26041: LD_INT 2
26043: PUSH
26044: EMPTY
26045: LIST
26046: LIST
26047: PUSH
26048: LD_INT 1
26050: PUSH
26051: LD_INT 2
26053: PUSH
26054: EMPTY
26055: LIST
26056: LIST
26057: PUSH
26058: LD_INT 0
26060: PUSH
26061: LD_INT 2
26063: PUSH
26064: EMPTY
26065: LIST
26066: LIST
26067: PUSH
26068: LD_INT 1
26070: NEG
26071: PUSH
26072: LD_INT 1
26074: PUSH
26075: EMPTY
26076: LIST
26077: LIST
26078: PUSH
26079: LD_INT 2
26081: NEG
26082: PUSH
26083: LD_INT 0
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: PUSH
26090: LD_INT 2
26092: NEG
26093: PUSH
26094: LD_INT 1
26096: NEG
26097: PUSH
26098: EMPTY
26099: LIST
26100: LIST
26101: PUSH
26102: LD_INT 2
26104: NEG
26105: PUSH
26106: LD_INT 2
26108: NEG
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: LIST
26118: LIST
26119: LIST
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: LIST
26125: LIST
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: LIST
26131: LIST
26132: LIST
26133: LIST
26134: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26135: LD_ADDR_VAR 0 20
26139: PUSH
26140: LD_INT 0
26142: PUSH
26143: LD_INT 0
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: PUSH
26150: LD_INT 0
26152: PUSH
26153: LD_INT 1
26155: NEG
26156: PUSH
26157: EMPTY
26158: LIST
26159: LIST
26160: PUSH
26161: LD_INT 1
26163: PUSH
26164: LD_INT 0
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: PUSH
26171: LD_INT 1
26173: PUSH
26174: LD_INT 1
26176: PUSH
26177: EMPTY
26178: LIST
26179: LIST
26180: PUSH
26181: LD_INT 0
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PUSH
26191: LD_INT 1
26193: NEG
26194: PUSH
26195: LD_INT 0
26197: PUSH
26198: EMPTY
26199: LIST
26200: LIST
26201: PUSH
26202: LD_INT 1
26204: NEG
26205: PUSH
26206: LD_INT 1
26208: NEG
26209: PUSH
26210: EMPTY
26211: LIST
26212: LIST
26213: PUSH
26214: LD_INT 1
26216: NEG
26217: PUSH
26218: LD_INT 2
26220: NEG
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: PUSH
26226: LD_INT 0
26228: PUSH
26229: LD_INT 2
26231: NEG
26232: PUSH
26233: EMPTY
26234: LIST
26235: LIST
26236: PUSH
26237: LD_INT 1
26239: PUSH
26240: LD_INT 1
26242: NEG
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PUSH
26248: LD_INT 2
26250: PUSH
26251: LD_INT 0
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: PUSH
26258: LD_INT 2
26260: PUSH
26261: LD_INT 1
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 2
26270: PUSH
26271: LD_INT 2
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: LD_INT 1
26280: PUSH
26281: LD_INT 2
26283: PUSH
26284: EMPTY
26285: LIST
26286: LIST
26287: PUSH
26288: LD_INT 0
26290: PUSH
26291: LD_INT 2
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: PUSH
26298: LD_INT 1
26300: NEG
26301: PUSH
26302: LD_INT 1
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: PUSH
26309: LD_INT 2
26311: NEG
26312: PUSH
26313: LD_INT 0
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 2
26322: NEG
26323: PUSH
26324: LD_INT 1
26326: NEG
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 2
26334: NEG
26335: PUSH
26336: LD_INT 2
26338: NEG
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: LIST
26348: LIST
26349: LIST
26350: LIST
26351: LIST
26352: LIST
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: LIST
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26365: LD_ADDR_VAR 0 21
26369: PUSH
26370: LD_INT 0
26372: PUSH
26373: LD_INT 0
26375: PUSH
26376: EMPTY
26377: LIST
26378: LIST
26379: PUSH
26380: LD_INT 0
26382: PUSH
26383: LD_INT 1
26385: NEG
26386: PUSH
26387: EMPTY
26388: LIST
26389: LIST
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: LD_INT 0
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PUSH
26401: LD_INT 1
26403: PUSH
26404: LD_INT 1
26406: PUSH
26407: EMPTY
26408: LIST
26409: LIST
26410: PUSH
26411: LD_INT 0
26413: PUSH
26414: LD_INT 1
26416: PUSH
26417: EMPTY
26418: LIST
26419: LIST
26420: PUSH
26421: LD_INT 1
26423: NEG
26424: PUSH
26425: LD_INT 0
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: PUSH
26432: LD_INT 1
26434: NEG
26435: PUSH
26436: LD_INT 1
26438: NEG
26439: PUSH
26440: EMPTY
26441: LIST
26442: LIST
26443: PUSH
26444: LD_INT 1
26446: NEG
26447: PUSH
26448: LD_INT 2
26450: NEG
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: PUSH
26456: LD_INT 0
26458: PUSH
26459: LD_INT 2
26461: NEG
26462: PUSH
26463: EMPTY
26464: LIST
26465: LIST
26466: PUSH
26467: LD_INT 1
26469: PUSH
26470: LD_INT 1
26472: NEG
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: PUSH
26478: LD_INT 2
26480: PUSH
26481: LD_INT 0
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: LD_INT 2
26490: PUSH
26491: LD_INT 1
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: LD_INT 2
26500: PUSH
26501: LD_INT 2
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: PUSH
26508: LD_INT 1
26510: PUSH
26511: LD_INT 2
26513: PUSH
26514: EMPTY
26515: LIST
26516: LIST
26517: PUSH
26518: LD_INT 0
26520: PUSH
26521: LD_INT 2
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: LD_INT 1
26530: NEG
26531: PUSH
26532: LD_INT 1
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 2
26541: NEG
26542: PUSH
26543: LD_INT 0
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: LD_INT 2
26552: NEG
26553: PUSH
26554: LD_INT 1
26556: NEG
26557: PUSH
26558: EMPTY
26559: LIST
26560: LIST
26561: PUSH
26562: LD_INT 2
26564: NEG
26565: PUSH
26566: LD_INT 2
26568: NEG
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: LIST
26578: LIST
26579: LIST
26580: LIST
26581: LIST
26582: LIST
26583: LIST
26584: LIST
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: LIST
26590: LIST
26591: LIST
26592: LIST
26593: LIST
26594: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26595: LD_ADDR_VAR 0 22
26599: PUSH
26600: LD_INT 0
26602: PUSH
26603: LD_INT 0
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: PUSH
26610: LD_INT 0
26612: PUSH
26613: LD_INT 1
26615: NEG
26616: PUSH
26617: EMPTY
26618: LIST
26619: LIST
26620: PUSH
26621: LD_INT 1
26623: PUSH
26624: LD_INT 0
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: LD_INT 1
26633: PUSH
26634: LD_INT 1
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: PUSH
26641: LD_INT 0
26643: PUSH
26644: LD_INT 1
26646: PUSH
26647: EMPTY
26648: LIST
26649: LIST
26650: PUSH
26651: LD_INT 1
26653: NEG
26654: PUSH
26655: LD_INT 0
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: LD_INT 1
26664: NEG
26665: PUSH
26666: LD_INT 1
26668: NEG
26669: PUSH
26670: EMPTY
26671: LIST
26672: LIST
26673: PUSH
26674: LD_INT 1
26676: NEG
26677: PUSH
26678: LD_INT 2
26680: NEG
26681: PUSH
26682: EMPTY
26683: LIST
26684: LIST
26685: PUSH
26686: LD_INT 0
26688: PUSH
26689: LD_INT 2
26691: NEG
26692: PUSH
26693: EMPTY
26694: LIST
26695: LIST
26696: PUSH
26697: LD_INT 1
26699: PUSH
26700: LD_INT 1
26702: NEG
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: PUSH
26708: LD_INT 2
26710: PUSH
26711: LD_INT 0
26713: PUSH
26714: EMPTY
26715: LIST
26716: LIST
26717: PUSH
26718: LD_INT 2
26720: PUSH
26721: LD_INT 1
26723: PUSH
26724: EMPTY
26725: LIST
26726: LIST
26727: PUSH
26728: LD_INT 2
26730: PUSH
26731: LD_INT 2
26733: PUSH
26734: EMPTY
26735: LIST
26736: LIST
26737: PUSH
26738: LD_INT 1
26740: PUSH
26741: LD_INT 2
26743: PUSH
26744: EMPTY
26745: LIST
26746: LIST
26747: PUSH
26748: LD_INT 0
26750: PUSH
26751: LD_INT 2
26753: PUSH
26754: EMPTY
26755: LIST
26756: LIST
26757: PUSH
26758: LD_INT 1
26760: NEG
26761: PUSH
26762: LD_INT 1
26764: PUSH
26765: EMPTY
26766: LIST
26767: LIST
26768: PUSH
26769: LD_INT 2
26771: NEG
26772: PUSH
26773: LD_INT 0
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: PUSH
26780: LD_INT 2
26782: NEG
26783: PUSH
26784: LD_INT 1
26786: NEG
26787: PUSH
26788: EMPTY
26789: LIST
26790: LIST
26791: PUSH
26792: LD_INT 2
26794: NEG
26795: PUSH
26796: LD_INT 2
26798: NEG
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: LIST
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: LIST
26821: LIST
26822: LIST
26823: LIST
26824: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26825: LD_ADDR_VAR 0 23
26829: PUSH
26830: LD_INT 0
26832: PUSH
26833: LD_INT 0
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 0
26842: PUSH
26843: LD_INT 1
26845: NEG
26846: PUSH
26847: EMPTY
26848: LIST
26849: LIST
26850: PUSH
26851: LD_INT 1
26853: PUSH
26854: LD_INT 0
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: PUSH
26861: LD_INT 1
26863: PUSH
26864: LD_INT 1
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 0
26873: PUSH
26874: LD_INT 1
26876: PUSH
26877: EMPTY
26878: LIST
26879: LIST
26880: PUSH
26881: LD_INT 1
26883: NEG
26884: PUSH
26885: LD_INT 0
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: PUSH
26892: LD_INT 1
26894: NEG
26895: PUSH
26896: LD_INT 1
26898: NEG
26899: PUSH
26900: EMPTY
26901: LIST
26902: LIST
26903: PUSH
26904: LD_INT 1
26906: NEG
26907: PUSH
26908: LD_INT 2
26910: NEG
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: PUSH
26916: LD_INT 0
26918: PUSH
26919: LD_INT 2
26921: NEG
26922: PUSH
26923: EMPTY
26924: LIST
26925: LIST
26926: PUSH
26927: LD_INT 1
26929: PUSH
26930: LD_INT 1
26932: NEG
26933: PUSH
26934: EMPTY
26935: LIST
26936: LIST
26937: PUSH
26938: LD_INT 2
26940: PUSH
26941: LD_INT 0
26943: PUSH
26944: EMPTY
26945: LIST
26946: LIST
26947: PUSH
26948: LD_INT 2
26950: PUSH
26951: LD_INT 1
26953: PUSH
26954: EMPTY
26955: LIST
26956: LIST
26957: PUSH
26958: LD_INT 2
26960: PUSH
26961: LD_INT 2
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: PUSH
26968: LD_INT 1
26970: PUSH
26971: LD_INT 2
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: PUSH
26978: LD_INT 0
26980: PUSH
26981: LD_INT 2
26983: PUSH
26984: EMPTY
26985: LIST
26986: LIST
26987: PUSH
26988: LD_INT 1
26990: NEG
26991: PUSH
26992: LD_INT 1
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: PUSH
26999: LD_INT 2
27001: NEG
27002: PUSH
27003: LD_INT 0
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 2
27012: NEG
27013: PUSH
27014: LD_INT 1
27016: NEG
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 2
27024: NEG
27025: PUSH
27026: LD_INT 2
27028: NEG
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PUSH
27034: LD_INT 2
27036: NEG
27037: PUSH
27038: LD_INT 3
27040: NEG
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PUSH
27046: LD_INT 1
27048: NEG
27049: PUSH
27050: LD_INT 3
27052: NEG
27053: PUSH
27054: EMPTY
27055: LIST
27056: LIST
27057: PUSH
27058: LD_INT 1
27060: PUSH
27061: LD_INT 2
27063: NEG
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: PUSH
27069: LD_INT 2
27071: PUSH
27072: LD_INT 1
27074: NEG
27075: PUSH
27076: EMPTY
27077: LIST
27078: LIST
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: LIST
27084: LIST
27085: LIST
27086: LIST
27087: LIST
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: LIST
27095: LIST
27096: LIST
27097: LIST
27098: LIST
27099: LIST
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27105: LD_ADDR_VAR 0 24
27109: PUSH
27110: LD_INT 0
27112: PUSH
27113: LD_INT 0
27115: PUSH
27116: EMPTY
27117: LIST
27118: LIST
27119: PUSH
27120: LD_INT 0
27122: PUSH
27123: LD_INT 1
27125: NEG
27126: PUSH
27127: EMPTY
27128: LIST
27129: LIST
27130: PUSH
27131: LD_INT 1
27133: PUSH
27134: LD_INT 0
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 1
27143: PUSH
27144: LD_INT 1
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 0
27153: PUSH
27154: LD_INT 1
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: LD_INT 1
27163: NEG
27164: PUSH
27165: LD_INT 0
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: PUSH
27172: LD_INT 1
27174: NEG
27175: PUSH
27176: LD_INT 1
27178: NEG
27179: PUSH
27180: EMPTY
27181: LIST
27182: LIST
27183: PUSH
27184: LD_INT 1
27186: NEG
27187: PUSH
27188: LD_INT 2
27190: NEG
27191: PUSH
27192: EMPTY
27193: LIST
27194: LIST
27195: PUSH
27196: LD_INT 0
27198: PUSH
27199: LD_INT 2
27201: NEG
27202: PUSH
27203: EMPTY
27204: LIST
27205: LIST
27206: PUSH
27207: LD_INT 1
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: EMPTY
27215: LIST
27216: LIST
27217: PUSH
27218: LD_INT 2
27220: PUSH
27221: LD_INT 0
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: PUSH
27228: LD_INT 2
27230: PUSH
27231: LD_INT 1
27233: PUSH
27234: EMPTY
27235: LIST
27236: LIST
27237: PUSH
27238: LD_INT 2
27240: PUSH
27241: LD_INT 2
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 1
27250: PUSH
27251: LD_INT 2
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 0
27260: PUSH
27261: LD_INT 2
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: PUSH
27268: LD_INT 1
27270: NEG
27271: PUSH
27272: LD_INT 1
27274: PUSH
27275: EMPTY
27276: LIST
27277: LIST
27278: PUSH
27279: LD_INT 2
27281: NEG
27282: PUSH
27283: LD_INT 0
27285: PUSH
27286: EMPTY
27287: LIST
27288: LIST
27289: PUSH
27290: LD_INT 2
27292: NEG
27293: PUSH
27294: LD_INT 1
27296: NEG
27297: PUSH
27298: EMPTY
27299: LIST
27300: LIST
27301: PUSH
27302: LD_INT 2
27304: NEG
27305: PUSH
27306: LD_INT 2
27308: NEG
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 1
27316: PUSH
27317: LD_INT 2
27319: NEG
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PUSH
27325: LD_INT 2
27327: PUSH
27328: LD_INT 1
27330: NEG
27331: PUSH
27332: EMPTY
27333: LIST
27334: LIST
27335: PUSH
27336: LD_INT 3
27338: PUSH
27339: LD_INT 1
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: PUSH
27346: LD_INT 3
27348: PUSH
27349: LD_INT 2
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: PUSH
27356: EMPTY
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: LIST
27374: LIST
27375: LIST
27376: LIST
27377: LIST
27378: LIST
27379: LIST
27380: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27381: LD_ADDR_VAR 0 25
27385: PUSH
27386: LD_INT 0
27388: PUSH
27389: LD_INT 0
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: PUSH
27396: LD_INT 0
27398: PUSH
27399: LD_INT 1
27401: NEG
27402: PUSH
27403: EMPTY
27404: LIST
27405: LIST
27406: PUSH
27407: LD_INT 1
27409: PUSH
27410: LD_INT 0
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 1
27419: PUSH
27420: LD_INT 1
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: PUSH
27427: LD_INT 0
27429: PUSH
27430: LD_INT 1
27432: PUSH
27433: EMPTY
27434: LIST
27435: LIST
27436: PUSH
27437: LD_INT 1
27439: NEG
27440: PUSH
27441: LD_INT 0
27443: PUSH
27444: EMPTY
27445: LIST
27446: LIST
27447: PUSH
27448: LD_INT 1
27450: NEG
27451: PUSH
27452: LD_INT 1
27454: NEG
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: PUSH
27460: LD_INT 1
27462: NEG
27463: PUSH
27464: LD_INT 2
27466: NEG
27467: PUSH
27468: EMPTY
27469: LIST
27470: LIST
27471: PUSH
27472: LD_INT 0
27474: PUSH
27475: LD_INT 2
27477: NEG
27478: PUSH
27479: EMPTY
27480: LIST
27481: LIST
27482: PUSH
27483: LD_INT 1
27485: PUSH
27486: LD_INT 1
27488: NEG
27489: PUSH
27490: EMPTY
27491: LIST
27492: LIST
27493: PUSH
27494: LD_INT 2
27496: PUSH
27497: LD_INT 0
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 2
27506: PUSH
27507: LD_INT 1
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 2
27516: PUSH
27517: LD_INT 2
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 1
27526: PUSH
27527: LD_INT 2
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 0
27536: PUSH
27537: LD_INT 2
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: PUSH
27544: LD_INT 1
27546: NEG
27547: PUSH
27548: LD_INT 1
27550: PUSH
27551: EMPTY
27552: LIST
27553: LIST
27554: PUSH
27555: LD_INT 2
27557: NEG
27558: PUSH
27559: LD_INT 0
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 2
27568: NEG
27569: PUSH
27570: LD_INT 1
27572: NEG
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: LD_INT 2
27580: NEG
27581: PUSH
27582: LD_INT 2
27584: NEG
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: PUSH
27590: LD_INT 3
27592: PUSH
27593: LD_INT 1
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: LD_INT 3
27602: PUSH
27603: LD_INT 2
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 2
27612: PUSH
27613: LD_INT 3
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 1
27622: PUSH
27623: LD_INT 3
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: EMPTY
27631: LIST
27632: LIST
27633: LIST
27634: LIST
27635: LIST
27636: LIST
27637: LIST
27638: LIST
27639: LIST
27640: LIST
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: LIST
27649: LIST
27650: LIST
27651: LIST
27652: LIST
27653: LIST
27654: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27655: LD_ADDR_VAR 0 26
27659: PUSH
27660: LD_INT 0
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: LD_INT 0
27672: PUSH
27673: LD_INT 1
27675: NEG
27676: PUSH
27677: EMPTY
27678: LIST
27679: LIST
27680: PUSH
27681: LD_INT 1
27683: PUSH
27684: LD_INT 0
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: LD_INT 1
27693: PUSH
27694: LD_INT 1
27696: PUSH
27697: EMPTY
27698: LIST
27699: LIST
27700: PUSH
27701: LD_INT 0
27703: PUSH
27704: LD_INT 1
27706: PUSH
27707: EMPTY
27708: LIST
27709: LIST
27710: PUSH
27711: LD_INT 1
27713: NEG
27714: PUSH
27715: LD_INT 0
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: PUSH
27722: LD_INT 1
27724: NEG
27725: PUSH
27726: LD_INT 1
27728: NEG
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: LD_INT 1
27736: NEG
27737: PUSH
27738: LD_INT 2
27740: NEG
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: LD_INT 0
27748: PUSH
27749: LD_INT 2
27751: NEG
27752: PUSH
27753: EMPTY
27754: LIST
27755: LIST
27756: PUSH
27757: LD_INT 1
27759: PUSH
27760: LD_INT 1
27762: NEG
27763: PUSH
27764: EMPTY
27765: LIST
27766: LIST
27767: PUSH
27768: LD_INT 2
27770: PUSH
27771: LD_INT 0
27773: PUSH
27774: EMPTY
27775: LIST
27776: LIST
27777: PUSH
27778: LD_INT 2
27780: PUSH
27781: LD_INT 1
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 2
27790: PUSH
27791: LD_INT 2
27793: PUSH
27794: EMPTY
27795: LIST
27796: LIST
27797: PUSH
27798: LD_INT 1
27800: PUSH
27801: LD_INT 2
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: PUSH
27808: LD_INT 0
27810: PUSH
27811: LD_INT 2
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: LD_INT 1
27820: NEG
27821: PUSH
27822: LD_INT 1
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: LD_INT 2
27831: NEG
27832: PUSH
27833: LD_INT 0
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: PUSH
27840: LD_INT 2
27842: NEG
27843: PUSH
27844: LD_INT 1
27846: NEG
27847: PUSH
27848: EMPTY
27849: LIST
27850: LIST
27851: PUSH
27852: LD_INT 2
27854: NEG
27855: PUSH
27856: LD_INT 2
27858: NEG
27859: PUSH
27860: EMPTY
27861: LIST
27862: LIST
27863: PUSH
27864: LD_INT 2
27866: PUSH
27867: LD_INT 3
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: PUSH
27874: LD_INT 1
27876: PUSH
27877: LD_INT 3
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 1
27886: NEG
27887: PUSH
27888: LD_INT 2
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PUSH
27895: LD_INT 2
27897: NEG
27898: PUSH
27899: LD_INT 1
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: LIST
27920: LIST
27921: LIST
27922: LIST
27923: LIST
27924: LIST
27925: LIST
27926: LIST
27927: LIST
27928: LIST
27929: LIST
27930: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27931: LD_ADDR_VAR 0 27
27935: PUSH
27936: LD_INT 0
27938: PUSH
27939: LD_INT 0
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: LD_INT 1
27951: NEG
27952: PUSH
27953: EMPTY
27954: LIST
27955: LIST
27956: PUSH
27957: LD_INT 1
27959: PUSH
27960: LD_INT 0
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: PUSH
27967: LD_INT 1
27969: PUSH
27970: LD_INT 1
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: LD_INT 1
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 1
27989: NEG
27990: PUSH
27991: LD_INT 0
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: PUSH
27998: LD_INT 1
28000: NEG
28001: PUSH
28002: LD_INT 1
28004: NEG
28005: PUSH
28006: EMPTY
28007: LIST
28008: LIST
28009: PUSH
28010: LD_INT 1
28012: NEG
28013: PUSH
28014: LD_INT 2
28016: NEG
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 0
28024: PUSH
28025: LD_INT 2
28027: NEG
28028: PUSH
28029: EMPTY
28030: LIST
28031: LIST
28032: PUSH
28033: LD_INT 1
28035: PUSH
28036: LD_INT 1
28038: NEG
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 2
28046: PUSH
28047: LD_INT 0
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 2
28056: PUSH
28057: LD_INT 1
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: LD_INT 2
28066: PUSH
28067: LD_INT 2
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PUSH
28074: LD_INT 1
28076: PUSH
28077: LD_INT 2
28079: PUSH
28080: EMPTY
28081: LIST
28082: LIST
28083: PUSH
28084: LD_INT 0
28086: PUSH
28087: LD_INT 2
28089: PUSH
28090: EMPTY
28091: LIST
28092: LIST
28093: PUSH
28094: LD_INT 1
28096: NEG
28097: PUSH
28098: LD_INT 1
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PUSH
28105: LD_INT 2
28107: NEG
28108: PUSH
28109: LD_INT 0
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 2
28118: NEG
28119: PUSH
28120: LD_INT 1
28122: NEG
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 2
28130: NEG
28131: PUSH
28132: LD_INT 2
28134: NEG
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PUSH
28140: LD_INT 1
28142: NEG
28143: PUSH
28144: LD_INT 2
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: LD_INT 2
28153: NEG
28154: PUSH
28155: LD_INT 1
28157: PUSH
28158: EMPTY
28159: LIST
28160: LIST
28161: PUSH
28162: LD_INT 3
28164: NEG
28165: PUSH
28166: LD_INT 1
28168: NEG
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 3
28176: NEG
28177: PUSH
28178: LD_INT 2
28180: NEG
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: LIST
28194: LIST
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28211: LD_ADDR_VAR 0 28
28215: PUSH
28216: LD_INT 0
28218: PUSH
28219: LD_INT 0
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 0
28228: PUSH
28229: LD_INT 1
28231: NEG
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: LD_INT 1
28239: PUSH
28240: LD_INT 0
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PUSH
28247: LD_INT 1
28249: PUSH
28250: LD_INT 1
28252: PUSH
28253: EMPTY
28254: LIST
28255: LIST
28256: PUSH
28257: LD_INT 0
28259: PUSH
28260: LD_INT 1
28262: PUSH
28263: EMPTY
28264: LIST
28265: LIST
28266: PUSH
28267: LD_INT 1
28269: NEG
28270: PUSH
28271: LD_INT 0
28273: PUSH
28274: EMPTY
28275: LIST
28276: LIST
28277: PUSH
28278: LD_INT 1
28280: NEG
28281: PUSH
28282: LD_INT 1
28284: NEG
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 1
28292: NEG
28293: PUSH
28294: LD_INT 2
28296: NEG
28297: PUSH
28298: EMPTY
28299: LIST
28300: LIST
28301: PUSH
28302: LD_INT 0
28304: PUSH
28305: LD_INT 2
28307: NEG
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PUSH
28313: LD_INT 1
28315: PUSH
28316: LD_INT 1
28318: NEG
28319: PUSH
28320: EMPTY
28321: LIST
28322: LIST
28323: PUSH
28324: LD_INT 2
28326: PUSH
28327: LD_INT 0
28329: PUSH
28330: EMPTY
28331: LIST
28332: LIST
28333: PUSH
28334: LD_INT 2
28336: PUSH
28337: LD_INT 1
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 2
28346: PUSH
28347: LD_INT 2
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 1
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: LD_INT 0
28366: PUSH
28367: LD_INT 2
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: LD_INT 1
28376: NEG
28377: PUSH
28378: LD_INT 1
28380: PUSH
28381: EMPTY
28382: LIST
28383: LIST
28384: PUSH
28385: LD_INT 2
28387: NEG
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: PUSH
28396: LD_INT 2
28398: NEG
28399: PUSH
28400: LD_INT 1
28402: NEG
28403: PUSH
28404: EMPTY
28405: LIST
28406: LIST
28407: PUSH
28408: LD_INT 2
28410: NEG
28411: PUSH
28412: LD_INT 2
28414: NEG
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PUSH
28420: LD_INT 2
28422: NEG
28423: PUSH
28424: LD_INT 3
28426: NEG
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: LD_INT 1
28434: NEG
28435: PUSH
28436: LD_INT 3
28438: NEG
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 3
28446: NEG
28447: PUSH
28448: LD_INT 1
28450: NEG
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 3
28458: NEG
28459: PUSH
28460: LD_INT 2
28462: NEG
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: EMPTY
28469: LIST
28470: LIST
28471: LIST
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: LIST
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28493: LD_ADDR_VAR 0 29
28497: PUSH
28498: LD_INT 0
28500: PUSH
28501: LD_INT 0
28503: PUSH
28504: EMPTY
28505: LIST
28506: LIST
28507: PUSH
28508: LD_INT 0
28510: PUSH
28511: LD_INT 1
28513: NEG
28514: PUSH
28515: EMPTY
28516: LIST
28517: LIST
28518: PUSH
28519: LD_INT 1
28521: PUSH
28522: LD_INT 0
28524: PUSH
28525: EMPTY
28526: LIST
28527: LIST
28528: PUSH
28529: LD_INT 1
28531: PUSH
28532: LD_INT 1
28534: PUSH
28535: EMPTY
28536: LIST
28537: LIST
28538: PUSH
28539: LD_INT 0
28541: PUSH
28542: LD_INT 1
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: LD_INT 1
28551: NEG
28552: PUSH
28553: LD_INT 0
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 1
28562: NEG
28563: PUSH
28564: LD_INT 1
28566: NEG
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: LD_INT 1
28574: NEG
28575: PUSH
28576: LD_INT 2
28578: NEG
28579: PUSH
28580: EMPTY
28581: LIST
28582: LIST
28583: PUSH
28584: LD_INT 0
28586: PUSH
28587: LD_INT 2
28589: NEG
28590: PUSH
28591: EMPTY
28592: LIST
28593: LIST
28594: PUSH
28595: LD_INT 1
28597: PUSH
28598: LD_INT 1
28600: NEG
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 2
28608: PUSH
28609: LD_INT 0
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: PUSH
28616: LD_INT 2
28618: PUSH
28619: LD_INT 1
28621: PUSH
28622: EMPTY
28623: LIST
28624: LIST
28625: PUSH
28626: LD_INT 1
28628: PUSH
28629: LD_INT 2
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: LD_INT 2
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 1
28648: NEG
28649: PUSH
28650: LD_INT 1
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: LD_INT 2
28659: NEG
28660: PUSH
28661: LD_INT 1
28663: NEG
28664: PUSH
28665: EMPTY
28666: LIST
28667: LIST
28668: PUSH
28669: LD_INT 2
28671: NEG
28672: PUSH
28673: LD_INT 2
28675: NEG
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 2
28683: NEG
28684: PUSH
28685: LD_INT 3
28687: NEG
28688: PUSH
28689: EMPTY
28690: LIST
28691: LIST
28692: PUSH
28693: LD_INT 2
28695: PUSH
28696: LD_INT 1
28698: NEG
28699: PUSH
28700: EMPTY
28701: LIST
28702: LIST
28703: PUSH
28704: LD_INT 3
28706: PUSH
28707: LD_INT 1
28709: PUSH
28710: EMPTY
28711: LIST
28712: LIST
28713: PUSH
28714: LD_INT 1
28716: PUSH
28717: LD_INT 3
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 1
28726: NEG
28727: PUSH
28728: LD_INT 2
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: LD_INT 3
28737: NEG
28738: PUSH
28739: LD_INT 2
28741: NEG
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: LIST
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28772: LD_ADDR_VAR 0 30
28776: PUSH
28777: LD_INT 0
28779: PUSH
28780: LD_INT 0
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: LD_INT 0
28789: PUSH
28790: LD_INT 1
28792: NEG
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 1
28800: PUSH
28801: LD_INT 0
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 1
28810: PUSH
28811: LD_INT 1
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: LD_INT 0
28820: PUSH
28821: LD_INT 1
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 1
28830: NEG
28831: PUSH
28832: LD_INT 0
28834: PUSH
28835: EMPTY
28836: LIST
28837: LIST
28838: PUSH
28839: LD_INT 1
28841: NEG
28842: PUSH
28843: LD_INT 1
28845: NEG
28846: PUSH
28847: EMPTY
28848: LIST
28849: LIST
28850: PUSH
28851: LD_INT 1
28853: NEG
28854: PUSH
28855: LD_INT 2
28857: NEG
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 0
28865: PUSH
28866: LD_INT 2
28868: NEG
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 1
28876: PUSH
28877: LD_INT 1
28879: NEG
28880: PUSH
28881: EMPTY
28882: LIST
28883: LIST
28884: PUSH
28885: LD_INT 2
28887: PUSH
28888: LD_INT 0
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PUSH
28895: LD_INT 2
28897: PUSH
28898: LD_INT 1
28900: PUSH
28901: EMPTY
28902: LIST
28903: LIST
28904: PUSH
28905: LD_INT 2
28907: PUSH
28908: LD_INT 2
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: PUSH
28915: LD_INT 1
28917: PUSH
28918: LD_INT 2
28920: PUSH
28921: EMPTY
28922: LIST
28923: LIST
28924: PUSH
28925: LD_INT 1
28927: NEG
28928: PUSH
28929: LD_INT 1
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: LD_INT 2
28938: NEG
28939: PUSH
28940: LD_INT 0
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PUSH
28947: LD_INT 2
28949: NEG
28950: PUSH
28951: LD_INT 1
28953: NEG
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PUSH
28959: LD_INT 1
28961: NEG
28962: PUSH
28963: LD_INT 3
28965: NEG
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 1
28973: PUSH
28974: LD_INT 2
28976: NEG
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 3
28984: PUSH
28985: LD_INT 2
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 2
28994: PUSH
28995: LD_INT 3
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: LD_INT 2
29004: NEG
29005: PUSH
29006: LD_INT 1
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: LD_INT 3
29015: NEG
29016: PUSH
29017: LD_INT 1
29019: NEG
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29050: LD_ADDR_VAR 0 31
29054: PUSH
29055: LD_INT 0
29057: PUSH
29058: LD_INT 0
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: PUSH
29065: LD_INT 0
29067: PUSH
29068: LD_INT 1
29070: NEG
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 1
29078: PUSH
29079: LD_INT 0
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 1
29088: PUSH
29089: LD_INT 1
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 0
29098: PUSH
29099: LD_INT 1
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 1
29108: NEG
29109: PUSH
29110: LD_INT 0
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: PUSH
29117: LD_INT 1
29119: NEG
29120: PUSH
29121: LD_INT 1
29123: NEG
29124: PUSH
29125: EMPTY
29126: LIST
29127: LIST
29128: PUSH
29129: LD_INT 1
29131: NEG
29132: PUSH
29133: LD_INT 2
29135: NEG
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 1
29143: PUSH
29144: LD_INT 1
29146: NEG
29147: PUSH
29148: EMPTY
29149: LIST
29150: LIST
29151: PUSH
29152: LD_INT 2
29154: PUSH
29155: LD_INT 0
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 2
29164: PUSH
29165: LD_INT 1
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PUSH
29172: LD_INT 2
29174: PUSH
29175: LD_INT 2
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 1
29184: PUSH
29185: LD_INT 2
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: LD_INT 0
29194: PUSH
29195: LD_INT 2
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: LD_INT 1
29204: NEG
29205: PUSH
29206: LD_INT 1
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PUSH
29213: LD_INT 2
29215: NEG
29216: PUSH
29217: LD_INT 1
29219: NEG
29220: PUSH
29221: EMPTY
29222: LIST
29223: LIST
29224: PUSH
29225: LD_INT 2
29227: NEG
29228: PUSH
29229: LD_INT 2
29231: NEG
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: PUSH
29237: LD_INT 2
29239: NEG
29240: PUSH
29241: LD_INT 3
29243: NEG
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 2
29251: PUSH
29252: LD_INT 1
29254: NEG
29255: PUSH
29256: EMPTY
29257: LIST
29258: LIST
29259: PUSH
29260: LD_INT 3
29262: PUSH
29263: LD_INT 1
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PUSH
29270: LD_INT 1
29272: PUSH
29273: LD_INT 3
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 1
29282: NEG
29283: PUSH
29284: LD_INT 2
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: LD_INT 3
29293: NEG
29294: PUSH
29295: LD_INT 2
29297: NEG
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29328: LD_ADDR_VAR 0 32
29332: PUSH
29333: LD_INT 0
29335: PUSH
29336: LD_INT 0
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 0
29345: PUSH
29346: LD_INT 1
29348: NEG
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: PUSH
29354: LD_INT 1
29356: PUSH
29357: LD_INT 0
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PUSH
29364: LD_INT 1
29366: PUSH
29367: LD_INT 1
29369: PUSH
29370: EMPTY
29371: LIST
29372: LIST
29373: PUSH
29374: LD_INT 0
29376: PUSH
29377: LD_INT 1
29379: PUSH
29380: EMPTY
29381: LIST
29382: LIST
29383: PUSH
29384: LD_INT 1
29386: NEG
29387: PUSH
29388: LD_INT 0
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 1
29397: NEG
29398: PUSH
29399: LD_INT 1
29401: NEG
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: LD_INT 1
29409: NEG
29410: PUSH
29411: LD_INT 2
29413: NEG
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 0
29421: PUSH
29422: LD_INT 2
29424: NEG
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 1
29432: PUSH
29433: LD_INT 1
29435: NEG
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: LD_INT 2
29443: PUSH
29444: LD_INT 1
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 2
29453: PUSH
29454: LD_INT 2
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 2
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 0
29473: PUSH
29474: LD_INT 2
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 1
29483: NEG
29484: PUSH
29485: LD_INT 1
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 2
29494: NEG
29495: PUSH
29496: LD_INT 0
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: PUSH
29503: LD_INT 2
29505: NEG
29506: PUSH
29507: LD_INT 1
29509: NEG
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 1
29517: NEG
29518: PUSH
29519: LD_INT 3
29521: NEG
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: LD_INT 2
29532: NEG
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 3
29540: PUSH
29541: LD_INT 2
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PUSH
29548: LD_INT 2
29550: PUSH
29551: LD_INT 3
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 2
29560: NEG
29561: PUSH
29562: LD_INT 1
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 3
29571: NEG
29572: PUSH
29573: LD_INT 1
29575: NEG
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29606: LD_ADDR_VAR 0 33
29610: PUSH
29611: LD_INT 0
29613: PUSH
29614: LD_INT 0
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 0
29623: PUSH
29624: LD_INT 1
29626: NEG
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: LD_INT 1
29634: PUSH
29635: LD_INT 0
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: LD_INT 1
29644: PUSH
29645: LD_INT 1
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 0
29654: PUSH
29655: LD_INT 1
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: LD_INT 1
29664: NEG
29665: PUSH
29666: LD_INT 0
29668: PUSH
29669: EMPTY
29670: LIST
29671: LIST
29672: PUSH
29673: LD_INT 1
29675: NEG
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: EMPTY
29682: LIST
29683: LIST
29684: PUSH
29685: LD_INT 1
29687: NEG
29688: PUSH
29689: LD_INT 2
29691: NEG
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 1
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 2
29710: PUSH
29711: LD_INT 0
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PUSH
29718: LD_INT 2
29720: PUSH
29721: LD_INT 1
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 1
29730: PUSH
29731: LD_INT 2
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 0
29740: PUSH
29741: LD_INT 2
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: LD_INT 1
29750: NEG
29751: PUSH
29752: LD_INT 1
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 2
29761: NEG
29762: PUSH
29763: LD_INT 0
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: PUSH
29770: LD_INT 2
29772: NEG
29773: PUSH
29774: LD_INT 1
29776: NEG
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 2
29784: NEG
29785: PUSH
29786: LD_INT 2
29788: NEG
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: LD_INT 2
29796: NEG
29797: PUSH
29798: LD_INT 3
29800: NEG
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 1
29811: NEG
29812: PUSH
29813: EMPTY
29814: LIST
29815: LIST
29816: PUSH
29817: LD_INT 3
29819: PUSH
29820: LD_INT 1
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: LD_INT 1
29829: PUSH
29830: LD_INT 3
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: PUSH
29837: LD_INT 1
29839: NEG
29840: PUSH
29841: LD_INT 2
29843: PUSH
29844: EMPTY
29845: LIST
29846: LIST
29847: PUSH
29848: LD_INT 3
29850: NEG
29851: PUSH
29852: LD_INT 2
29854: NEG
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: LIST
29864: LIST
29865: LIST
29866: LIST
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29885: LD_ADDR_VAR 0 34
29889: PUSH
29890: LD_INT 0
29892: PUSH
29893: LD_INT 0
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: PUSH
29900: LD_INT 0
29902: PUSH
29903: LD_INT 1
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 1
29913: PUSH
29914: LD_INT 0
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: PUSH
29921: LD_INT 1
29923: PUSH
29924: LD_INT 1
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: LD_INT 0
29933: PUSH
29934: LD_INT 1
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PUSH
29941: LD_INT 1
29943: NEG
29944: PUSH
29945: LD_INT 0
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 1
29954: NEG
29955: PUSH
29956: LD_INT 1
29958: NEG
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 1
29966: NEG
29967: PUSH
29968: LD_INT 2
29970: NEG
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 0
29978: PUSH
29979: LD_INT 2
29981: NEG
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 1
29989: PUSH
29990: LD_INT 1
29992: NEG
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 2
30000: PUSH
30001: LD_INT 1
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 2
30010: PUSH
30011: LD_INT 2
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 1
30020: PUSH
30021: LD_INT 2
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 1
30030: NEG
30031: PUSH
30032: LD_INT 1
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: PUSH
30039: LD_INT 2
30041: NEG
30042: PUSH
30043: LD_INT 0
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 2
30052: NEG
30053: PUSH
30054: LD_INT 1
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 2
30064: NEG
30065: PUSH
30066: LD_INT 2
30068: NEG
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: LD_INT 1
30076: NEG
30077: PUSH
30078: LD_INT 3
30080: NEG
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 1
30088: PUSH
30089: LD_INT 2
30091: NEG
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 3
30099: PUSH
30100: LD_INT 2
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 2
30109: PUSH
30110: LD_INT 3
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 2
30119: NEG
30120: PUSH
30121: LD_INT 1
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: LD_INT 3
30130: NEG
30131: PUSH
30132: LD_INT 1
30134: NEG
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: LIST
30144: LIST
30145: LIST
30146: LIST
30147: LIST
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30165: LD_ADDR_VAR 0 35
30169: PUSH
30170: LD_INT 0
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 0
30182: PUSH
30183: LD_INT 1
30185: NEG
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: LD_INT 1
30193: PUSH
30194: LD_INT 0
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 1
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 0
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 1
30223: NEG
30224: PUSH
30225: LD_INT 0
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: PUSH
30232: LD_INT 1
30234: NEG
30235: PUSH
30236: LD_INT 1
30238: NEG
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 2
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 2
30256: NEG
30257: PUSH
30258: LD_INT 1
30260: NEG
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: LIST
30270: LIST
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30277: LD_ADDR_VAR 0 36
30281: PUSH
30282: LD_INT 0
30284: PUSH
30285: LD_INT 0
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: LD_INT 0
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 1
30315: PUSH
30316: LD_INT 1
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: LD_INT 1
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 1
30335: NEG
30336: PUSH
30337: LD_INT 0
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: LD_INT 1
30350: NEG
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 1
30358: NEG
30359: PUSH
30360: LD_INT 2
30362: NEG
30363: PUSH
30364: EMPTY
30365: LIST
30366: LIST
30367: PUSH
30368: LD_INT 1
30370: PUSH
30371: LD_INT 2
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: LIST
30382: LIST
30383: LIST
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30389: LD_ADDR_VAR 0 37
30393: PUSH
30394: LD_INT 0
30396: PUSH
30397: LD_INT 0
30399: PUSH
30400: EMPTY
30401: LIST
30402: LIST
30403: PUSH
30404: LD_INT 0
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 1
30417: PUSH
30418: LD_INT 0
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: PUSH
30425: LD_INT 1
30427: PUSH
30428: LD_INT 1
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 0
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 1
30447: NEG
30448: PUSH
30449: LD_INT 0
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: PUSH
30456: LD_INT 1
30458: NEG
30459: PUSH
30460: LD_INT 1
30462: NEG
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 1
30470: PUSH
30471: LD_INT 1
30473: NEG
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 1
30481: NEG
30482: PUSH
30483: LD_INT 1
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30501: LD_ADDR_VAR 0 38
30505: PUSH
30506: LD_INT 0
30508: PUSH
30509: LD_INT 0
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 0
30518: PUSH
30519: LD_INT 1
30521: NEG
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 1
30529: PUSH
30530: LD_INT 0
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 1
30539: PUSH
30540: LD_INT 1
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 0
30549: PUSH
30550: LD_INT 1
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PUSH
30557: LD_INT 1
30559: NEG
30560: PUSH
30561: LD_INT 0
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 1
30570: NEG
30571: PUSH
30572: LD_INT 1
30574: NEG
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 2
30582: PUSH
30583: LD_INT 1
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 2
30592: NEG
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30613: LD_ADDR_VAR 0 39
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: LD_INT 0
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 0
30630: PUSH
30631: LD_INT 1
30633: NEG
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: PUSH
30639: LD_INT 1
30641: PUSH
30642: LD_INT 0
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 1
30651: PUSH
30652: LD_INT 1
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 0
30661: PUSH
30662: LD_INT 1
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 1
30671: NEG
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 1
30682: NEG
30683: PUSH
30684: LD_INT 1
30686: NEG
30687: PUSH
30688: EMPTY
30689: LIST
30690: LIST
30691: PUSH
30692: LD_INT 1
30694: NEG
30695: PUSH
30696: LD_INT 2
30698: NEG
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: LD_INT 1
30706: PUSH
30707: LD_INT 2
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30725: LD_ADDR_VAR 0 40
30729: PUSH
30730: LD_INT 0
30732: PUSH
30733: LD_INT 0
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 1
30745: NEG
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: PUSH
30751: LD_INT 1
30753: PUSH
30754: LD_INT 0
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 1
30763: PUSH
30764: LD_INT 1
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: LD_INT 1
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 1
30783: NEG
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 1
30794: NEG
30795: PUSH
30796: LD_INT 1
30798: NEG
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 1
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 1
30817: NEG
30818: PUSH
30819: LD_INT 1
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: LIST
30836: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30837: LD_ADDR_VAR 0 41
30841: PUSH
30842: LD_INT 0
30844: PUSH
30845: LD_INT 0
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 0
30854: PUSH
30855: LD_INT 1
30857: NEG
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 1
30865: PUSH
30866: LD_INT 0
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 1
30875: PUSH
30876: LD_INT 1
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 0
30885: PUSH
30886: LD_INT 1
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 1
30895: NEG
30896: PUSH
30897: LD_INT 0
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: LD_INT 1
30906: NEG
30907: PUSH
30908: LD_INT 1
30910: NEG
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 1
30918: NEG
30919: PUSH
30920: LD_INT 2
30922: NEG
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 1
30930: PUSH
30931: LD_INT 1
30933: NEG
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 2
30941: PUSH
30942: LD_INT 0
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 2
30951: PUSH
30952: LD_INT 1
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 2
30961: PUSH
30962: LD_INT 2
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 1
30971: PUSH
30972: LD_INT 2
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 1
30981: NEG
30982: PUSH
30983: LD_INT 1
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 2
30992: NEG
30993: PUSH
30994: LD_INT 0
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 2
31003: NEG
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 2
31015: NEG
31016: PUSH
31017: LD_INT 2
31019: NEG
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 2
31027: NEG
31028: PUSH
31029: LD_INT 3
31031: NEG
31032: PUSH
31033: EMPTY
31034: LIST
31035: LIST
31036: PUSH
31037: LD_INT 2
31039: PUSH
31040: LD_INT 1
31042: NEG
31043: PUSH
31044: EMPTY
31045: LIST
31046: LIST
31047: PUSH
31048: LD_INT 3
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 3
31060: PUSH
31061: LD_INT 1
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 3
31070: PUSH
31071: LD_INT 2
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 3
31080: PUSH
31081: LD_INT 3
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 2
31090: PUSH
31091: LD_INT 3
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 2
31100: NEG
31101: PUSH
31102: LD_INT 1
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 3
31111: NEG
31112: PUSH
31113: LD_INT 0
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 3
31122: NEG
31123: PUSH
31124: LD_INT 1
31126: NEG
31127: PUSH
31128: EMPTY
31129: LIST
31130: LIST
31131: PUSH
31132: LD_INT 3
31134: NEG
31135: PUSH
31136: LD_INT 2
31138: NEG
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 3
31146: NEG
31147: PUSH
31148: LD_INT 3
31150: NEG
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31187: LD_ADDR_VAR 0 42
31191: PUSH
31192: LD_INT 0
31194: PUSH
31195: LD_INT 0
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 0
31204: PUSH
31205: LD_INT 1
31207: NEG
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 1
31215: PUSH
31216: LD_INT 0
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 1
31225: PUSH
31226: LD_INT 1
31228: PUSH
31229: EMPTY
31230: LIST
31231: LIST
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: LD_INT 1
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 1
31245: NEG
31246: PUSH
31247: LD_INT 0
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 1
31256: NEG
31257: PUSH
31258: LD_INT 1
31260: NEG
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 1
31268: NEG
31269: PUSH
31270: LD_INT 2
31272: NEG
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: PUSH
31278: LD_INT 0
31280: PUSH
31281: LD_INT 2
31283: NEG
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 1
31291: PUSH
31292: LD_INT 1
31294: NEG
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 2
31302: PUSH
31303: LD_INT 1
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 2
31312: PUSH
31313: LD_INT 2
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: PUSH
31323: LD_INT 2
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: LD_INT 2
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: LD_INT 1
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 2
31353: NEG
31354: PUSH
31355: LD_INT 1
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 2
31365: NEG
31366: PUSH
31367: LD_INT 2
31369: NEG
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 2
31377: NEG
31378: PUSH
31379: LD_INT 3
31381: NEG
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 1
31389: NEG
31390: PUSH
31391: LD_INT 3
31393: NEG
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 0
31401: PUSH
31402: LD_INT 3
31404: NEG
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: LD_INT 2
31415: NEG
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 3
31423: PUSH
31424: LD_INT 2
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 3
31433: PUSH
31434: LD_INT 3
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: LD_INT 2
31443: PUSH
31444: LD_INT 3
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: LD_INT 3
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: LD_INT 0
31463: PUSH
31464: LD_INT 3
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: LD_INT 2
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 3
31484: NEG
31485: PUSH
31486: LD_INT 2
31488: NEG
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 3
31496: NEG
31497: PUSH
31498: LD_INT 3
31500: NEG
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: LIST
31527: LIST
31528: LIST
31529: LIST
31530: LIST
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31537: LD_ADDR_VAR 0 43
31541: PUSH
31542: LD_INT 0
31544: PUSH
31545: LD_INT 0
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: LD_INT 1
31557: NEG
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: LD_INT 0
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: LD_INT 1
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 0
31585: PUSH
31586: LD_INT 1
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: LD_INT 0
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: LD_INT 2
31622: NEG
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: LD_INT 0
31630: PUSH
31631: LD_INT 2
31633: NEG
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 1
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: LD_INT 0
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: LD_INT 1
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: LD_INT 2
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 0
31682: PUSH
31683: LD_INT 2
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 1
31692: NEG
31693: PUSH
31694: LD_INT 1
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 2
31703: NEG
31704: PUSH
31705: LD_INT 0
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 2
31714: NEG
31715: PUSH
31716: LD_INT 1
31718: NEG
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: LD_INT 1
31726: NEG
31727: PUSH
31728: LD_INT 3
31730: NEG
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 0
31738: PUSH
31739: LD_INT 3
31741: NEG
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 1
31749: PUSH
31750: LD_INT 2
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 2
31760: PUSH
31761: LD_INT 1
31763: NEG
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 3
31771: PUSH
31772: LD_INT 0
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 3
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: PUSH
31792: LD_INT 3
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 0
31801: PUSH
31802: LD_INT 3
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: PUSH
31809: LD_INT 1
31811: NEG
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 2
31822: NEG
31823: PUSH
31824: LD_INT 1
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 3
31833: NEG
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 3
31844: NEG
31845: PUSH
31846: LD_INT 1
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: LIST
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31885: LD_ADDR_VAR 0 44
31889: PUSH
31890: LD_INT 0
31892: PUSH
31893: LD_INT 0
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 0
31902: PUSH
31903: LD_INT 1
31905: NEG
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 1
31913: PUSH
31914: LD_INT 0
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 1
31923: PUSH
31924: LD_INT 1
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 0
31933: PUSH
31934: LD_INT 1
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 1
31943: NEG
31944: PUSH
31945: LD_INT 0
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PUSH
31952: LD_INT 1
31954: NEG
31955: PUSH
31956: LD_INT 1
31958: NEG
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: PUSH
31964: LD_INT 1
31966: NEG
31967: PUSH
31968: LD_INT 2
31970: NEG
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: LD_INT 1
31978: PUSH
31979: LD_INT 1
31981: NEG
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 2
31989: PUSH
31990: LD_INT 0
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 2
31999: PUSH
32000: LD_INT 1
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 2
32009: PUSH
32010: LD_INT 2
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: PUSH
32017: LD_INT 1
32019: PUSH
32020: LD_INT 2
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: LD_INT 1
32029: NEG
32030: PUSH
32031: LD_INT 1
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 2
32040: NEG
32041: PUSH
32042: LD_INT 0
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 2
32051: NEG
32052: PUSH
32053: LD_INT 1
32055: NEG
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 2
32063: NEG
32064: PUSH
32065: LD_INT 2
32067: NEG
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 2
32075: NEG
32076: PUSH
32077: LD_INT 3
32079: NEG
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: PUSH
32085: LD_INT 2
32087: PUSH
32088: LD_INT 1
32090: NEG
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 3
32098: PUSH
32099: LD_INT 0
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 3
32108: PUSH
32109: LD_INT 1
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 3
32118: PUSH
32119: LD_INT 2
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 3
32128: PUSH
32129: LD_INT 3
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 2
32138: PUSH
32139: LD_INT 3
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: PUSH
32146: LD_INT 2
32148: NEG
32149: PUSH
32150: LD_INT 1
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 3
32159: NEG
32160: PUSH
32161: LD_INT 0
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 3
32170: NEG
32171: PUSH
32172: LD_INT 1
32174: NEG
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 3
32182: NEG
32183: PUSH
32184: LD_INT 2
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 3
32194: NEG
32195: PUSH
32196: LD_INT 3
32198: NEG
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: LIST
32226: LIST
32227: LIST
32228: LIST
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32235: LD_ADDR_VAR 0 45
32239: PUSH
32240: LD_INT 0
32242: PUSH
32243: LD_INT 0
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 0
32252: PUSH
32253: LD_INT 1
32255: NEG
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PUSH
32261: LD_INT 1
32263: PUSH
32264: LD_INT 0
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: PUSH
32274: LD_INT 1
32276: PUSH
32277: EMPTY
32278: LIST
32279: LIST
32280: PUSH
32281: LD_INT 0
32283: PUSH
32284: LD_INT 1
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 1
32293: NEG
32294: PUSH
32295: LD_INT 0
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 1
32304: NEG
32305: PUSH
32306: LD_INT 1
32308: NEG
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: LD_INT 1
32316: NEG
32317: PUSH
32318: LD_INT 2
32320: NEG
32321: PUSH
32322: EMPTY
32323: LIST
32324: LIST
32325: PUSH
32326: LD_INT 0
32328: PUSH
32329: LD_INT 2
32331: NEG
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: LD_INT 1
32339: PUSH
32340: LD_INT 1
32342: NEG
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: LD_INT 2
32350: PUSH
32351: LD_INT 1
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PUSH
32358: LD_INT 2
32360: PUSH
32361: LD_INT 2
32363: PUSH
32364: EMPTY
32365: LIST
32366: LIST
32367: PUSH
32368: LD_INT 1
32370: PUSH
32371: LD_INT 2
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 0
32380: PUSH
32381: LD_INT 2
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 1
32390: NEG
32391: PUSH
32392: LD_INT 1
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 2
32401: NEG
32402: PUSH
32403: LD_INT 1
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 2
32413: NEG
32414: PUSH
32415: LD_INT 2
32417: NEG
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: LD_INT 2
32425: NEG
32426: PUSH
32427: LD_INT 3
32429: NEG
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 1
32437: NEG
32438: PUSH
32439: LD_INT 3
32441: NEG
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 0
32449: PUSH
32450: LD_INT 3
32452: NEG
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 1
32460: PUSH
32461: LD_INT 2
32463: NEG
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 3
32471: PUSH
32472: LD_INT 2
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 3
32481: PUSH
32482: LD_INT 3
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 2
32491: PUSH
32492: LD_INT 3
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 1
32501: PUSH
32502: LD_INT 3
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: LD_INT 3
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: LD_INT 2
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 3
32532: NEG
32533: PUSH
32534: LD_INT 2
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 3
32544: NEG
32545: PUSH
32546: LD_INT 3
32548: NEG
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: EMPTY
32555: LIST
32556: LIST
32557: LIST
32558: LIST
32559: LIST
32560: LIST
32561: LIST
32562: LIST
32563: LIST
32564: LIST
32565: LIST
32566: LIST
32567: LIST
32568: LIST
32569: LIST
32570: LIST
32571: LIST
32572: LIST
32573: LIST
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32585: LD_ADDR_VAR 0 46
32589: PUSH
32590: LD_INT 0
32592: PUSH
32593: LD_INT 0
32595: PUSH
32596: EMPTY
32597: LIST
32598: LIST
32599: PUSH
32600: LD_INT 0
32602: PUSH
32603: LD_INT 1
32605: NEG
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: PUSH
32611: LD_INT 1
32613: PUSH
32614: LD_INT 0
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 1
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 1
32643: NEG
32644: PUSH
32645: LD_INT 0
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 1
32654: NEG
32655: PUSH
32656: LD_INT 1
32658: NEG
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 1
32666: NEG
32667: PUSH
32668: LD_INT 2
32670: NEG
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 0
32678: PUSH
32679: LD_INT 2
32681: NEG
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: PUSH
32687: LD_INT 1
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 2
32700: PUSH
32701: LD_INT 0
32703: PUSH
32704: EMPTY
32705: LIST
32706: LIST
32707: PUSH
32708: LD_INT 2
32710: PUSH
32711: LD_INT 1
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 1
32720: PUSH
32721: LD_INT 2
32723: PUSH
32724: EMPTY
32725: LIST
32726: LIST
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: LD_INT 2
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 1
32740: NEG
32741: PUSH
32742: LD_INT 1
32744: PUSH
32745: EMPTY
32746: LIST
32747: LIST
32748: PUSH
32749: LD_INT 2
32751: NEG
32752: PUSH
32753: LD_INT 0
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 2
32762: NEG
32763: PUSH
32764: LD_INT 1
32766: NEG
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: LD_INT 3
32778: NEG
32779: PUSH
32780: EMPTY
32781: LIST
32782: LIST
32783: PUSH
32784: LD_INT 0
32786: PUSH
32787: LD_INT 3
32789: NEG
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 1
32797: PUSH
32798: LD_INT 2
32800: NEG
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 2
32808: PUSH
32809: LD_INT 1
32811: NEG
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 3
32819: PUSH
32820: LD_INT 0
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 3
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: LD_INT 3
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 0
32849: PUSH
32850: LD_INT 3
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 1
32859: NEG
32860: PUSH
32861: LD_INT 2
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 2
32870: NEG
32871: PUSH
32872: LD_INT 1
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PUSH
32879: LD_INT 3
32881: NEG
32882: PUSH
32883: LD_INT 0
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 3
32892: NEG
32893: PUSH
32894: LD_INT 1
32896: NEG
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: LIST
32906: LIST
32907: LIST
32908: LIST
32909: LIST
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: LIST
32916: LIST
32917: LIST
32918: LIST
32919: LIST
32920: LIST
32921: LIST
32922: LIST
32923: LIST
32924: LIST
32925: LIST
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32933: LD_ADDR_VAR 0 47
32937: PUSH
32938: LD_INT 0
32940: PUSH
32941: LD_INT 0
32943: PUSH
32944: EMPTY
32945: LIST
32946: LIST
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: LD_INT 1
32953: NEG
32954: PUSH
32955: EMPTY
32956: LIST
32957: LIST
32958: PUSH
32959: LD_INT 1
32961: PUSH
32962: LD_INT 0
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: PUSH
32969: LD_INT 1
32971: PUSH
32972: LD_INT 1
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: LD_INT 0
32981: PUSH
32982: LD_INT 1
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 1
32991: NEG
32992: PUSH
32993: LD_INT 0
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 1
33002: NEG
33003: PUSH
33004: LD_INT 1
33006: NEG
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: PUSH
33012: LD_INT 1
33014: NEG
33015: PUSH
33016: LD_INT 2
33018: NEG
33019: PUSH
33020: EMPTY
33021: LIST
33022: LIST
33023: PUSH
33024: LD_INT 0
33026: PUSH
33027: LD_INT 2
33029: NEG
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: PUSH
33038: LD_INT 1
33040: NEG
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: LD_INT 1
33052: NEG
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 2
33060: NEG
33061: PUSH
33062: LD_INT 2
33064: NEG
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33084: LD_ADDR_VAR 0 48
33088: PUSH
33089: LD_INT 0
33091: PUSH
33092: LD_INT 0
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 0
33101: PUSH
33102: LD_INT 1
33104: NEG
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 1
33112: PUSH
33113: LD_INT 0
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 1
33122: PUSH
33123: LD_INT 1
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: PUSH
33130: LD_INT 0
33132: PUSH
33133: LD_INT 1
33135: PUSH
33136: EMPTY
33137: LIST
33138: LIST
33139: PUSH
33140: LD_INT 1
33142: NEG
33143: PUSH
33144: LD_INT 0
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: LD_INT 1
33153: NEG
33154: PUSH
33155: LD_INT 1
33157: NEG
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: LD_INT 2
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 0
33177: PUSH
33178: LD_INT 2
33180: NEG
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 1
33188: PUSH
33189: LD_INT 1
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 2
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 2
33209: PUSH
33210: LD_INT 1
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33231: LD_ADDR_VAR 0 49
33235: PUSH
33236: LD_INT 0
33238: PUSH
33239: LD_INT 0
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 0
33248: PUSH
33249: LD_INT 1
33251: NEG
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: LD_INT 1
33259: PUSH
33260: LD_INT 0
33262: PUSH
33263: EMPTY
33264: LIST
33265: LIST
33266: PUSH
33267: LD_INT 1
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 0
33279: PUSH
33280: LD_INT 1
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 1
33289: NEG
33290: PUSH
33291: LD_INT 0
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 1
33300: NEG
33301: PUSH
33302: LD_INT 1
33304: NEG
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 1
33312: PUSH
33313: LD_INT 1
33315: NEG
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 2
33323: PUSH
33324: LD_INT 0
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: LD_INT 2
33333: PUSH
33334: LD_INT 1
33336: PUSH
33337: EMPTY
33338: LIST
33339: LIST
33340: PUSH
33341: LD_INT 2
33343: PUSH
33344: LD_INT 2
33346: PUSH
33347: EMPTY
33348: LIST
33349: LIST
33350: PUSH
33351: LD_INT 1
33353: PUSH
33354: LD_INT 2
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33375: LD_ADDR_VAR 0 50
33379: PUSH
33380: LD_INT 0
33382: PUSH
33383: LD_INT 0
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 0
33392: PUSH
33393: LD_INT 1
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 1
33403: PUSH
33404: LD_INT 0
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: PUSH
33411: LD_INT 1
33413: PUSH
33414: LD_INT 1
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 0
33423: PUSH
33424: LD_INT 1
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 1
33433: NEG
33434: PUSH
33435: LD_INT 0
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 1
33444: NEG
33445: PUSH
33446: LD_INT 1
33448: NEG
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 2
33456: PUSH
33457: LD_INT 1
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: PUSH
33464: LD_INT 2
33466: PUSH
33467: LD_INT 2
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PUSH
33474: LD_INT 1
33476: PUSH
33477: LD_INT 2
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 0
33486: PUSH
33487: LD_INT 2
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: NEG
33497: PUSH
33498: LD_INT 1
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33519: LD_ADDR_VAR 0 51
33523: PUSH
33524: LD_INT 0
33526: PUSH
33527: LD_INT 0
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 0
33536: PUSH
33537: LD_INT 1
33539: NEG
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 1
33547: PUSH
33548: LD_INT 0
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: LD_INT 1
33557: PUSH
33558: LD_INT 1
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 0
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 1
33577: NEG
33578: PUSH
33579: LD_INT 0
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 1
33588: NEG
33589: PUSH
33590: LD_INT 1
33592: NEG
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 1
33600: PUSH
33601: LD_INT 2
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 0
33610: PUSH
33611: LD_INT 2
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: LD_INT 1
33620: NEG
33621: PUSH
33622: LD_INT 1
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 2
33631: NEG
33632: PUSH
33633: LD_INT 0
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 2
33642: NEG
33643: PUSH
33644: LD_INT 1
33646: NEG
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: LIST
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33666: LD_ADDR_VAR 0 52
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: LD_INT 0
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 0
33683: PUSH
33684: LD_INT 1
33686: NEG
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 1
33694: PUSH
33695: LD_INT 0
33697: PUSH
33698: EMPTY
33699: LIST
33700: LIST
33701: PUSH
33702: LD_INT 1
33704: PUSH
33705: LD_INT 1
33707: PUSH
33708: EMPTY
33709: LIST
33710: LIST
33711: PUSH
33712: LD_INT 0
33714: PUSH
33715: LD_INT 1
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: NEG
33725: PUSH
33726: LD_INT 0
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 1
33735: NEG
33736: PUSH
33737: LD_INT 1
33739: NEG
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: LD_INT 1
33747: NEG
33748: PUSH
33749: LD_INT 2
33751: NEG
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 1
33759: NEG
33760: PUSH
33761: LD_INT 1
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 2
33770: NEG
33771: PUSH
33772: LD_INT 0
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 2
33781: NEG
33782: PUSH
33783: LD_INT 1
33785: NEG
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 2
33793: NEG
33794: PUSH
33795: LD_INT 2
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: LIST
33807: LIST
33808: LIST
33809: LIST
33810: LIST
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33817: LD_ADDR_VAR 0 53
33821: PUSH
33822: LD_INT 0
33824: PUSH
33825: LD_INT 0
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 0
33834: PUSH
33835: LD_INT 1
33837: NEG
33838: PUSH
33839: EMPTY
33840: LIST
33841: LIST
33842: PUSH
33843: LD_INT 1
33845: PUSH
33846: LD_INT 0
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 1
33855: PUSH
33856: LD_INT 1
33858: PUSH
33859: EMPTY
33860: LIST
33861: LIST
33862: PUSH
33863: LD_INT 0
33865: PUSH
33866: LD_INT 1
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 1
33875: NEG
33876: PUSH
33877: LD_INT 0
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 1
33886: NEG
33887: PUSH
33888: LD_INT 1
33890: NEG
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: LD_INT 1
33898: NEG
33899: PUSH
33900: LD_INT 2
33902: NEG
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 0
33910: PUSH
33911: LD_INT 2
33913: NEG
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PUSH
33919: LD_INT 1
33921: PUSH
33922: LD_INT 1
33924: NEG
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 2
33932: PUSH
33933: LD_INT 0
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 2
33942: PUSH
33943: LD_INT 1
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: PUSH
33950: LD_INT 2
33952: PUSH
33953: LD_INT 2
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: LD_INT 2
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: LD_INT 2
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: PUSH
33980: LD_INT 1
33982: NEG
33983: PUSH
33984: LD_INT 1
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: LD_INT 2
33993: NEG
33994: PUSH
33995: LD_INT 0
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 2
34004: NEG
34005: PUSH
34006: LD_INT 1
34008: NEG
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 2
34016: NEG
34017: PUSH
34018: LD_INT 2
34020: NEG
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34047: LD_ADDR_VAR 0 54
34051: PUSH
34052: LD_INT 0
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 0
34064: PUSH
34065: LD_INT 1
34067: NEG
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: LD_INT 1
34075: PUSH
34076: LD_INT 0
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: LD_INT 1
34085: PUSH
34086: LD_INT 1
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 0
34095: PUSH
34096: LD_INT 1
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: PUSH
34103: LD_INT 1
34105: NEG
34106: PUSH
34107: LD_INT 0
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 1
34116: NEG
34117: PUSH
34118: LD_INT 1
34120: NEG
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: LD_INT 1
34128: NEG
34129: PUSH
34130: LD_INT 2
34132: NEG
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 0
34140: PUSH
34141: LD_INT 2
34143: NEG
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: LD_INT 1
34151: PUSH
34152: LD_INT 1
34154: NEG
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: PUSH
34160: LD_INT 2
34162: PUSH
34163: LD_INT 0
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: PUSH
34173: LD_INT 1
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 2
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: EMPTY
34187: LIST
34188: LIST
34189: PUSH
34190: LD_INT 1
34192: PUSH
34193: LD_INT 2
34195: PUSH
34196: EMPTY
34197: LIST
34198: LIST
34199: PUSH
34200: LD_INT 0
34202: PUSH
34203: LD_INT 2
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: LD_INT 1
34212: NEG
34213: PUSH
34214: LD_INT 1
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: LD_INT 2
34223: NEG
34224: PUSH
34225: LD_INT 0
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 2
34234: NEG
34235: PUSH
34236: LD_INT 1
34238: NEG
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 2
34246: NEG
34247: PUSH
34248: LD_INT 2
34250: NEG
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34277: LD_ADDR_VAR 0 55
34281: PUSH
34282: LD_INT 0
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 0
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 1
34305: PUSH
34306: LD_INT 0
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 1
34315: PUSH
34316: LD_INT 1
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 0
34325: PUSH
34326: LD_INT 1
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 1
34335: NEG
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 1
34346: NEG
34347: PUSH
34348: LD_INT 1
34350: NEG
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 1
34358: NEG
34359: PUSH
34360: LD_INT 2
34362: NEG
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: LD_INT 2
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 1
34381: PUSH
34382: LD_INT 1
34384: NEG
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 2
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 2
34402: PUSH
34403: LD_INT 1
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 2
34412: PUSH
34413: LD_INT 2
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 1
34422: PUSH
34423: LD_INT 2
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 0
34432: PUSH
34433: LD_INT 2
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 1
34442: NEG
34443: PUSH
34444: LD_INT 1
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 2
34453: NEG
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: NEG
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 2
34476: NEG
34477: PUSH
34478: LD_INT 2
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: LIST
34497: LIST
34498: LIST
34499: LIST
34500: LIST
34501: LIST
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34507: LD_ADDR_VAR 0 56
34511: PUSH
34512: LD_INT 0
34514: PUSH
34515: LD_INT 0
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 0
34524: PUSH
34525: LD_INT 1
34527: NEG
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 1
34535: PUSH
34536: LD_INT 0
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 1
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 0
34555: PUSH
34556: LD_INT 1
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: NEG
34566: PUSH
34567: LD_INT 0
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 1
34576: NEG
34577: PUSH
34578: LD_INT 1
34580: NEG
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 1
34588: NEG
34589: PUSH
34590: LD_INT 2
34592: NEG
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: PUSH
34598: LD_INT 0
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: LD_INT 1
34614: NEG
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PUSH
34620: LD_INT 2
34622: PUSH
34623: LD_INT 0
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 2
34632: PUSH
34633: LD_INT 1
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: LD_INT 2
34642: PUSH
34643: LD_INT 2
34645: PUSH
34646: EMPTY
34647: LIST
34648: LIST
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: LD_INT 2
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: LD_INT 0
34662: PUSH
34663: LD_INT 2
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: PUSH
34670: LD_INT 1
34672: NEG
34673: PUSH
34674: LD_INT 1
34676: PUSH
34677: EMPTY
34678: LIST
34679: LIST
34680: PUSH
34681: LD_INT 2
34683: NEG
34684: PUSH
34685: LD_INT 0
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 2
34694: NEG
34695: PUSH
34696: LD_INT 1
34698: NEG
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 2
34706: NEG
34707: PUSH
34708: LD_INT 2
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34737: LD_ADDR_VAR 0 57
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 0
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 0
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 1
34795: NEG
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 1
34806: NEG
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 2
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: LD_INT 2
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: PUSH
34842: LD_INT 1
34844: NEG
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 2
34852: PUSH
34853: LD_INT 0
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 2
34862: PUSH
34863: LD_INT 1
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: PUSH
34873: LD_INT 2
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 1
34882: PUSH
34883: LD_INT 2
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: LD_INT 2
34895: PUSH
34896: EMPTY
34897: LIST
34898: LIST
34899: PUSH
34900: LD_INT 1
34902: NEG
34903: PUSH
34904: LD_INT 1
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: LD_INT 0
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 2
34924: NEG
34925: PUSH
34926: LD_INT 1
34928: NEG
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 2
34936: NEG
34937: PUSH
34938: LD_INT 2
34940: NEG
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: LIST
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34967: LD_ADDR_VAR 0 58
34971: PUSH
34972: LD_INT 0
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 0
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 1
34995: PUSH
34996: LD_INT 0
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 1
35005: PUSH
35006: LD_INT 1
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: LD_INT 1
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 1
35025: NEG
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 1
35036: NEG
35037: PUSH
35038: LD_INT 1
35040: NEG
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 1
35048: NEG
35049: PUSH
35050: LD_INT 2
35052: NEG
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: PUSH
35058: LD_INT 0
35060: PUSH
35061: LD_INT 2
35063: NEG
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 1
35071: PUSH
35072: LD_INT 1
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: LD_INT 0
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 2
35092: PUSH
35093: LD_INT 1
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 2
35102: PUSH
35103: LD_INT 2
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: LD_INT 1
35112: PUSH
35113: LD_INT 2
35115: PUSH
35116: EMPTY
35117: LIST
35118: LIST
35119: PUSH
35120: LD_INT 0
35122: PUSH
35123: LD_INT 2
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 2
35143: NEG
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 2
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 2
35166: NEG
35167: PUSH
35168: LD_INT 2
35170: NEG
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: LIST
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35197: LD_ADDR_VAR 0 59
35201: PUSH
35202: LD_INT 0
35204: PUSH
35205: LD_INT 0
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 0
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 1
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 1
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 0
35245: PUSH
35246: LD_INT 1
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 1
35255: NEG
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: LD_INT 1
35270: NEG
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35285: LD_ADDR_VAR 0 60
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: LIST
35368: LIST
35369: LIST
35370: LIST
35371: LIST
35372: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35373: LD_ADDR_VAR 0 61
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: LD_INT 0
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 0
35390: PUSH
35391: LD_INT 1
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: PUSH
35402: LD_INT 0
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 1
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: LD_INT 1
35424: PUSH
35425: EMPTY
35426: LIST
35427: LIST
35428: PUSH
35429: LD_INT 1
35431: NEG
35432: PUSH
35433: LD_INT 0
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 1
35442: NEG
35443: PUSH
35444: LD_INT 1
35446: NEG
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35461: LD_ADDR_VAR 0 62
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: LD_INT 0
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 0
35478: PUSH
35479: LD_INT 1
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 1
35489: PUSH
35490: LD_INT 0
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: LD_INT 1
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: LD_INT 1
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: NEG
35520: PUSH
35521: LD_INT 0
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: NEG
35531: PUSH
35532: LD_INT 1
35534: NEG
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: LIST
35544: LIST
35545: LIST
35546: LIST
35547: LIST
35548: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35549: LD_ADDR_VAR 0 63
35553: PUSH
35554: LD_INT 0
35556: PUSH
35557: LD_INT 0
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: LD_INT 0
35566: PUSH
35567: LD_INT 1
35569: NEG
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: PUSH
35578: LD_INT 0
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 1
35587: PUSH
35588: LD_INT 1
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 0
35597: PUSH
35598: LD_INT 1
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 1
35607: NEG
35608: PUSH
35609: LD_INT 0
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: LD_INT 1
35618: NEG
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: EMPTY
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35637: LD_ADDR_VAR 0 64
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: LD_INT 0
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 0
35654: PUSH
35655: LD_INT 1
35657: NEG
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 1
35665: PUSH
35666: LD_INT 0
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: PUSH
35673: LD_INT 1
35675: PUSH
35676: LD_INT 1
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 0
35685: PUSH
35686: LD_INT 1
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 1
35695: NEG
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: LD_INT 1
35710: NEG
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: ST_TO_ADDR
// end ; 1 :
35725: GO 41622
35727: LD_INT 1
35729: DOUBLE
35730: EQUAL
35731: IFTRUE 35735
35733: GO 38358
35735: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35736: LD_ADDR_VAR 0 11
35740: PUSH
35741: LD_INT 1
35743: NEG
35744: PUSH
35745: LD_INT 3
35747: NEG
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: LD_INT 3
35758: NEG
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: PUSH
35767: LD_INT 2
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: LIST
35779: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35780: LD_ADDR_VAR 0 12
35784: PUSH
35785: LD_INT 2
35787: PUSH
35788: LD_INT 1
35790: NEG
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: LD_INT 3
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 3
35808: PUSH
35809: LD_INT 1
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: LIST
35820: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35821: LD_ADDR_VAR 0 13
35825: PUSH
35826: LD_INT 3
35828: PUSH
35829: LD_INT 2
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 3
35838: PUSH
35839: LD_INT 3
35841: PUSH
35842: EMPTY
35843: LIST
35844: LIST
35845: PUSH
35846: LD_INT 2
35848: PUSH
35849: LD_INT 3
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: EMPTY
35857: LIST
35858: LIST
35859: LIST
35860: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35861: LD_ADDR_VAR 0 14
35865: PUSH
35866: LD_INT 1
35868: PUSH
35869: LD_INT 3
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 0
35878: PUSH
35879: LD_INT 3
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 1
35888: NEG
35889: PUSH
35890: LD_INT 2
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: LIST
35901: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35902: LD_ADDR_VAR 0 15
35906: PUSH
35907: LD_INT 2
35909: NEG
35910: PUSH
35911: LD_INT 1
35913: PUSH
35914: EMPTY
35915: LIST
35916: LIST
35917: PUSH
35918: LD_INT 3
35920: NEG
35921: PUSH
35922: LD_INT 0
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 3
35931: NEG
35932: PUSH
35933: LD_INT 1
35935: NEG
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: LIST
35945: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35946: LD_ADDR_VAR 0 16
35950: PUSH
35951: LD_INT 2
35953: NEG
35954: PUSH
35955: LD_INT 3
35957: NEG
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 3
35965: NEG
35966: PUSH
35967: LD_INT 2
35969: NEG
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 3
35977: NEG
35978: PUSH
35979: LD_INT 3
35981: NEG
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: LIST
35991: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35992: LD_ADDR_VAR 0 17
35996: PUSH
35997: LD_INT 1
35999: NEG
36000: PUSH
36001: LD_INT 3
36003: NEG
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 0
36011: PUSH
36012: LD_INT 3
36014: NEG
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 1
36022: PUSH
36023: LD_INT 2
36025: NEG
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: LIST
36035: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36036: LD_ADDR_VAR 0 18
36040: PUSH
36041: LD_INT 2
36043: PUSH
36044: LD_INT 1
36046: NEG
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 3
36054: PUSH
36055: LD_INT 0
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 3
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: LIST
36076: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36077: LD_ADDR_VAR 0 19
36081: PUSH
36082: LD_INT 3
36084: PUSH
36085: LD_INT 2
36087: PUSH
36088: EMPTY
36089: LIST
36090: LIST
36091: PUSH
36092: LD_INT 3
36094: PUSH
36095: LD_INT 3
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: LD_INT 2
36104: PUSH
36105: LD_INT 3
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: LIST
36116: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36117: LD_ADDR_VAR 0 20
36121: PUSH
36122: LD_INT 1
36124: PUSH
36125: LD_INT 3
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: LD_INT 3
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 1
36144: NEG
36145: PUSH
36146: LD_INT 2
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: LIST
36157: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36158: LD_ADDR_VAR 0 21
36162: PUSH
36163: LD_INT 2
36165: NEG
36166: PUSH
36167: LD_INT 1
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: PUSH
36174: LD_INT 3
36176: NEG
36177: PUSH
36178: LD_INT 0
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: LD_INT 3
36187: NEG
36188: PUSH
36189: LD_INT 1
36191: NEG
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: LIST
36201: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36202: LD_ADDR_VAR 0 22
36206: PUSH
36207: LD_INT 2
36209: NEG
36210: PUSH
36211: LD_INT 3
36213: NEG
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 3
36221: NEG
36222: PUSH
36223: LD_INT 2
36225: NEG
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 3
36233: NEG
36234: PUSH
36235: LD_INT 3
36237: NEG
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: LIST
36247: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36248: LD_ADDR_VAR 0 23
36252: PUSH
36253: LD_INT 0
36255: PUSH
36256: LD_INT 3
36258: NEG
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 1
36266: NEG
36267: PUSH
36268: LD_INT 4
36270: NEG
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 1
36278: PUSH
36279: LD_INT 3
36281: NEG
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: LIST
36291: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36292: LD_ADDR_VAR 0 24
36296: PUSH
36297: LD_INT 3
36299: PUSH
36300: LD_INT 0
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 3
36309: PUSH
36310: LD_INT 1
36312: NEG
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 4
36320: PUSH
36321: LD_INT 1
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: LIST
36332: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36333: LD_ADDR_VAR 0 25
36337: PUSH
36338: LD_INT 3
36340: PUSH
36341: LD_INT 3
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 4
36350: PUSH
36351: LD_INT 3
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 3
36360: PUSH
36361: LD_INT 4
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: LIST
36372: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36373: LD_ADDR_VAR 0 26
36377: PUSH
36378: LD_INT 0
36380: PUSH
36381: LD_INT 3
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 1
36390: PUSH
36391: LD_INT 4
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 1
36400: NEG
36401: PUSH
36402: LD_INT 3
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: LIST
36413: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36414: LD_ADDR_VAR 0 27
36418: PUSH
36419: LD_INT 3
36421: NEG
36422: PUSH
36423: LD_INT 0
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 3
36432: NEG
36433: PUSH
36434: LD_INT 1
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: LD_INT 4
36443: NEG
36444: PUSH
36445: LD_INT 1
36447: NEG
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: LIST
36457: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36458: LD_ADDR_VAR 0 28
36462: PUSH
36463: LD_INT 3
36465: NEG
36466: PUSH
36467: LD_INT 3
36469: NEG
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 3
36477: NEG
36478: PUSH
36479: LD_INT 4
36481: NEG
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PUSH
36487: LD_INT 4
36489: NEG
36490: PUSH
36491: LD_INT 3
36493: NEG
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: LIST
36503: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36504: LD_ADDR_VAR 0 29
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: LD_INT 3
36515: NEG
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: LD_INT 3
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: PUSH
36535: LD_INT 2
36537: NEG
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 1
36545: NEG
36546: PUSH
36547: LD_INT 4
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: LD_INT 4
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: PUSH
36569: LD_INT 3
36571: NEG
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 1
36579: NEG
36580: PUSH
36581: LD_INT 5
36583: NEG
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 0
36591: PUSH
36592: LD_INT 5
36594: NEG
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 1
36602: PUSH
36603: LD_INT 4
36605: NEG
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 1
36613: NEG
36614: PUSH
36615: LD_INT 6
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 0
36625: PUSH
36626: LD_INT 6
36628: NEG
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 1
36636: PUSH
36637: LD_INT 5
36639: NEG
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36659: LD_ADDR_VAR 0 30
36663: PUSH
36664: LD_INT 2
36666: PUSH
36667: LD_INT 1
36669: NEG
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 3
36677: PUSH
36678: LD_INT 0
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 3
36687: PUSH
36688: LD_INT 1
36690: PUSH
36691: EMPTY
36692: LIST
36693: LIST
36694: PUSH
36695: LD_INT 3
36697: PUSH
36698: LD_INT 1
36700: NEG
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 4
36708: PUSH
36709: LD_INT 0
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: LD_INT 4
36718: PUSH
36719: LD_INT 1
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 4
36728: PUSH
36729: LD_INT 1
36731: NEG
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 5
36739: PUSH
36740: LD_INT 0
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 5
36749: PUSH
36750: LD_INT 1
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 5
36759: PUSH
36760: LD_INT 1
36762: NEG
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 6
36770: PUSH
36771: LD_INT 0
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 6
36780: PUSH
36781: LD_INT 1
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36802: LD_ADDR_VAR 0 31
36806: PUSH
36807: LD_INT 3
36809: PUSH
36810: LD_INT 2
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 3
36819: PUSH
36820: LD_INT 3
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 2
36829: PUSH
36830: LD_INT 3
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: LD_INT 4
36839: PUSH
36840: LD_INT 3
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: LD_INT 4
36849: PUSH
36850: LD_INT 4
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 3
36859: PUSH
36860: LD_INT 4
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 5
36869: PUSH
36870: LD_INT 4
36872: PUSH
36873: EMPTY
36874: LIST
36875: LIST
36876: PUSH
36877: LD_INT 5
36879: PUSH
36880: LD_INT 5
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 4
36889: PUSH
36890: LD_INT 5
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 6
36899: PUSH
36900: LD_INT 5
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 6
36909: PUSH
36910: LD_INT 6
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 5
36919: PUSH
36920: LD_INT 6
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36941: LD_ADDR_VAR 0 32
36945: PUSH
36946: LD_INT 1
36948: PUSH
36949: LD_INT 3
36951: PUSH
36952: EMPTY
36953: LIST
36954: LIST
36955: PUSH
36956: LD_INT 0
36958: PUSH
36959: LD_INT 3
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 1
36968: NEG
36969: PUSH
36970: LD_INT 2
36972: PUSH
36973: EMPTY
36974: LIST
36975: LIST
36976: PUSH
36977: LD_INT 1
36979: PUSH
36980: LD_INT 4
36982: PUSH
36983: EMPTY
36984: LIST
36985: LIST
36986: PUSH
36987: LD_INT 0
36989: PUSH
36990: LD_INT 4
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: NEG
37000: PUSH
37001: LD_INT 3
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 1
37010: PUSH
37011: LD_INT 5
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 0
37020: PUSH
37021: LD_INT 5
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 1
37030: NEG
37031: PUSH
37032: LD_INT 4
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: LD_INT 1
37041: PUSH
37042: LD_INT 6
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 0
37051: PUSH
37052: LD_INT 6
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 1
37061: NEG
37062: PUSH
37063: LD_INT 5
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37084: LD_ADDR_VAR 0 33
37088: PUSH
37089: LD_INT 2
37091: NEG
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 3
37102: NEG
37103: PUSH
37104: LD_INT 0
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 3
37113: NEG
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 3
37125: NEG
37126: PUSH
37127: LD_INT 1
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 4
37136: NEG
37137: PUSH
37138: LD_INT 0
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 4
37147: NEG
37148: PUSH
37149: LD_INT 1
37151: NEG
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: PUSH
37157: LD_INT 4
37159: NEG
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: LD_INT 5
37170: NEG
37171: PUSH
37172: LD_INT 0
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 5
37181: NEG
37182: PUSH
37183: LD_INT 1
37185: NEG
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 5
37193: NEG
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 6
37204: NEG
37205: PUSH
37206: LD_INT 0
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 6
37215: NEG
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37239: LD_ADDR_VAR 0 34
37243: PUSH
37244: LD_INT 2
37246: NEG
37247: PUSH
37248: LD_INT 3
37250: NEG
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 3
37258: NEG
37259: PUSH
37260: LD_INT 2
37262: NEG
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 3
37270: NEG
37271: PUSH
37272: LD_INT 3
37274: NEG
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 3
37282: NEG
37283: PUSH
37284: LD_INT 4
37286: NEG
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 4
37294: NEG
37295: PUSH
37296: LD_INT 3
37298: NEG
37299: PUSH
37300: EMPTY
37301: LIST
37302: LIST
37303: PUSH
37304: LD_INT 4
37306: NEG
37307: PUSH
37308: LD_INT 4
37310: NEG
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 4
37318: NEG
37319: PUSH
37320: LD_INT 5
37322: NEG
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 5
37330: NEG
37331: PUSH
37332: LD_INT 4
37334: NEG
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 5
37342: NEG
37343: PUSH
37344: LD_INT 5
37346: NEG
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 5
37354: NEG
37355: PUSH
37356: LD_INT 6
37358: NEG
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: LD_INT 6
37366: NEG
37367: PUSH
37368: LD_INT 5
37370: NEG
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: LD_INT 6
37378: NEG
37379: PUSH
37380: LD_INT 6
37382: NEG
37383: PUSH
37384: EMPTY
37385: LIST
37386: LIST
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37402: LD_ADDR_VAR 0 41
37406: PUSH
37407: LD_INT 0
37409: PUSH
37410: LD_INT 2
37412: NEG
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: LD_INT 1
37420: NEG
37421: PUSH
37422: LD_INT 3
37424: NEG
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 1
37432: PUSH
37433: LD_INT 2
37435: NEG
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: LIST
37445: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37446: LD_ADDR_VAR 0 42
37450: PUSH
37451: LD_INT 2
37453: PUSH
37454: LD_INT 0
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: LD_INT 2
37463: PUSH
37464: LD_INT 1
37466: NEG
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 3
37474: PUSH
37475: LD_INT 1
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: LIST
37486: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37487: LD_ADDR_VAR 0 43
37491: PUSH
37492: LD_INT 2
37494: PUSH
37495: LD_INT 2
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 3
37504: PUSH
37505: LD_INT 2
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 2
37514: PUSH
37515: LD_INT 3
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: EMPTY
37523: LIST
37524: LIST
37525: LIST
37526: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37527: LD_ADDR_VAR 0 44
37531: PUSH
37532: LD_INT 0
37534: PUSH
37535: LD_INT 2
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: LD_INT 1
37544: PUSH
37545: LD_INT 3
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 1
37554: NEG
37555: PUSH
37556: LD_INT 2
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: LIST
37567: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37568: LD_ADDR_VAR 0 45
37572: PUSH
37573: LD_INT 2
37575: NEG
37576: PUSH
37577: LD_INT 0
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 2
37586: NEG
37587: PUSH
37588: LD_INT 1
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: LD_INT 3
37597: NEG
37598: PUSH
37599: LD_INT 1
37601: NEG
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: LIST
37611: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37612: LD_ADDR_VAR 0 46
37616: PUSH
37617: LD_INT 2
37619: NEG
37620: PUSH
37621: LD_INT 2
37623: NEG
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 2
37631: NEG
37632: PUSH
37633: LD_INT 3
37635: NEG
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 3
37643: NEG
37644: PUSH
37645: LD_INT 2
37647: NEG
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: LIST
37657: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37658: LD_ADDR_VAR 0 47
37662: PUSH
37663: LD_INT 2
37665: NEG
37666: PUSH
37667: LD_INT 3
37669: NEG
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: LD_INT 3
37681: NEG
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: EMPTY
37688: LIST
37689: LIST
37690: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37691: LD_ADDR_VAR 0 48
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: LD_INT 2
37701: NEG
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 2
37709: PUSH
37710: LD_INT 1
37712: NEG
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37722: LD_ADDR_VAR 0 49
37726: PUSH
37727: LD_INT 3
37729: PUSH
37730: LD_INT 1
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 3
37739: PUSH
37740: LD_INT 2
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37751: LD_ADDR_VAR 0 50
37755: PUSH
37756: LD_INT 2
37758: PUSH
37759: LD_INT 3
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 1
37768: PUSH
37769: LD_INT 3
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37780: LD_ADDR_VAR 0 51
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: LD_INT 2
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: LD_INT 1
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37811: LD_ADDR_VAR 0 52
37815: PUSH
37816: LD_INT 3
37818: NEG
37819: PUSH
37820: LD_INT 1
37822: NEG
37823: PUSH
37824: EMPTY
37825: LIST
37826: LIST
37827: PUSH
37828: LD_INT 3
37830: NEG
37831: PUSH
37832: LD_INT 2
37834: NEG
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37844: LD_ADDR_VAR 0 53
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: LD_INT 3
37855: NEG
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 0
37863: PUSH
37864: LD_INT 3
37866: NEG
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: LD_INT 2
37877: NEG
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: EMPTY
37884: LIST
37885: LIST
37886: LIST
37887: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37888: LD_ADDR_VAR 0 54
37892: PUSH
37893: LD_INT 2
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 3
37906: PUSH
37907: LD_INT 0
37909: PUSH
37910: EMPTY
37911: LIST
37912: LIST
37913: PUSH
37914: LD_INT 3
37916: PUSH
37917: LD_INT 1
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: LIST
37928: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37929: LD_ADDR_VAR 0 55
37933: PUSH
37934: LD_INT 3
37936: PUSH
37937: LD_INT 2
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: PUSH
37944: LD_INT 3
37946: PUSH
37947: LD_INT 3
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: PUSH
37954: LD_INT 2
37956: PUSH
37957: LD_INT 3
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: LIST
37968: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37969: LD_ADDR_VAR 0 56
37973: PUSH
37974: LD_INT 1
37976: PUSH
37977: LD_INT 3
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: LD_INT 0
37986: PUSH
37987: LD_INT 3
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 1
37996: NEG
37997: PUSH
37998: LD_INT 2
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: LIST
38009: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38010: LD_ADDR_VAR 0 57
38014: PUSH
38015: LD_INT 2
38017: NEG
38018: PUSH
38019: LD_INT 1
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 3
38028: NEG
38029: PUSH
38030: LD_INT 0
38032: PUSH
38033: EMPTY
38034: LIST
38035: LIST
38036: PUSH
38037: LD_INT 3
38039: NEG
38040: PUSH
38041: LD_INT 1
38043: NEG
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: LIST
38053: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38054: LD_ADDR_VAR 0 58
38058: PUSH
38059: LD_INT 2
38061: NEG
38062: PUSH
38063: LD_INT 3
38065: NEG
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 3
38073: NEG
38074: PUSH
38075: LD_INT 2
38077: NEG
38078: PUSH
38079: EMPTY
38080: LIST
38081: LIST
38082: PUSH
38083: LD_INT 3
38085: NEG
38086: PUSH
38087: LD_INT 3
38089: NEG
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: LIST
38099: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38100: LD_ADDR_VAR 0 59
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: LD_INT 2
38111: NEG
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: LD_INT 2
38122: NEG
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 1
38130: PUSH
38131: LD_INT 1
38133: NEG
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: LIST
38143: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38144: LD_ADDR_VAR 0 60
38148: PUSH
38149: LD_INT 1
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 2
38162: PUSH
38163: LD_INT 0
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 2
38172: PUSH
38173: LD_INT 1
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: LIST
38184: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38185: LD_ADDR_VAR 0 61
38189: PUSH
38190: LD_INT 2
38192: PUSH
38193: LD_INT 1
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 2
38202: PUSH
38203: LD_INT 2
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 1
38212: PUSH
38213: LD_INT 2
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: LIST
38224: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38225: LD_ADDR_VAR 0 62
38229: PUSH
38230: LD_INT 1
38232: PUSH
38233: LD_INT 2
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 0
38242: PUSH
38243: LD_INT 2
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: LD_INT 1
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: EMPTY
38262: LIST
38263: LIST
38264: LIST
38265: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38266: LD_ADDR_VAR 0 63
38270: PUSH
38271: LD_INT 1
38273: NEG
38274: PUSH
38275: LD_INT 1
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: PUSH
38282: LD_INT 2
38284: NEG
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 2
38295: NEG
38296: PUSH
38297: LD_INT 1
38299: NEG
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: LIST
38309: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38310: LD_ADDR_VAR 0 64
38314: PUSH
38315: LD_INT 1
38317: NEG
38318: PUSH
38319: LD_INT 2
38321: NEG
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 2
38329: NEG
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 2
38341: NEG
38342: PUSH
38343: LD_INT 2
38345: NEG
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: LIST
38355: ST_TO_ADDR
// end ; 2 :
38356: GO 41622
38358: LD_INT 2
38360: DOUBLE
38361: EQUAL
38362: IFTRUE 38366
38364: GO 41621
38366: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38367: LD_ADDR_VAR 0 29
38371: PUSH
38372: LD_INT 4
38374: PUSH
38375: LD_INT 0
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: LD_INT 4
38384: PUSH
38385: LD_INT 1
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 5
38395: PUSH
38396: LD_INT 0
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: LD_INT 5
38405: PUSH
38406: LD_INT 1
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: LD_INT 4
38415: PUSH
38416: LD_INT 1
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 3
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 3
38435: PUSH
38436: LD_INT 1
38438: NEG
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 3
38446: PUSH
38447: LD_INT 2
38449: NEG
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 5
38457: PUSH
38458: LD_INT 2
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 3
38467: PUSH
38468: LD_INT 3
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 3
38477: PUSH
38478: LD_INT 2
38480: PUSH
38481: EMPTY
38482: LIST
38483: LIST
38484: PUSH
38485: LD_INT 4
38487: PUSH
38488: LD_INT 3
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 4
38497: PUSH
38498: LD_INT 4
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 3
38507: PUSH
38508: LD_INT 4
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 2
38517: PUSH
38518: LD_INT 3
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 2
38527: PUSH
38528: LD_INT 2
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 4
38537: PUSH
38538: LD_INT 2
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 2
38547: PUSH
38548: LD_INT 4
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: LD_INT 4
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: LD_INT 3
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 1
38577: PUSH
38578: LD_INT 4
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: PUSH
38585: LD_INT 1
38587: PUSH
38588: LD_INT 5
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 0
38597: PUSH
38598: LD_INT 5
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 1
38607: NEG
38608: PUSH
38609: LD_INT 4
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 1
38618: NEG
38619: PUSH
38620: LD_INT 3
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 2
38629: PUSH
38630: LD_INT 5
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: LD_INT 3
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 3
38650: NEG
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 3
38661: NEG
38662: PUSH
38663: LD_INT 1
38665: NEG
38666: PUSH
38667: EMPTY
38668: LIST
38669: LIST
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: LD_INT 0
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 2
38684: NEG
38685: PUSH
38686: LD_INT 1
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 3
38695: NEG
38696: PUSH
38697: LD_INT 1
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 4
38706: NEG
38707: PUSH
38708: LD_INT 0
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 4
38717: NEG
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 4
38729: NEG
38730: PUSH
38731: LD_INT 2
38733: NEG
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 2
38741: NEG
38742: PUSH
38743: LD_INT 2
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 4
38752: NEG
38753: PUSH
38754: LD_INT 4
38756: NEG
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PUSH
38762: LD_INT 4
38764: NEG
38765: PUSH
38766: LD_INT 5
38768: NEG
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 3
38776: NEG
38777: PUSH
38778: LD_INT 4
38780: NEG
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 3
38788: NEG
38789: PUSH
38790: LD_INT 3
38792: NEG
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 4
38800: NEG
38801: PUSH
38802: LD_INT 3
38804: NEG
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 5
38812: NEG
38813: PUSH
38814: LD_INT 4
38816: NEG
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: LD_INT 5
38824: NEG
38825: PUSH
38826: LD_INT 5
38828: NEG
38829: PUSH
38830: EMPTY
38831: LIST
38832: LIST
38833: PUSH
38834: LD_INT 3
38836: NEG
38837: PUSH
38838: LD_INT 5
38840: NEG
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PUSH
38846: LD_INT 5
38848: NEG
38849: PUSH
38850: LD_INT 3
38852: NEG
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: LIST
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38905: LD_ADDR_VAR 0 30
38909: PUSH
38910: LD_INT 4
38912: PUSH
38913: LD_INT 4
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 4
38922: PUSH
38923: LD_INT 3
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 5
38932: PUSH
38933: LD_INT 4
38935: PUSH
38936: EMPTY
38937: LIST
38938: LIST
38939: PUSH
38940: LD_INT 5
38942: PUSH
38943: LD_INT 5
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 4
38952: PUSH
38953: LD_INT 5
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 3
38962: PUSH
38963: LD_INT 4
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: LD_INT 3
38972: PUSH
38973: LD_INT 3
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 5
38982: PUSH
38983: LD_INT 3
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 3
38992: PUSH
38993: LD_INT 5
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: LD_INT 0
39002: PUSH
39003: LD_INT 3
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 0
39012: PUSH
39013: LD_INT 2
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 1
39022: PUSH
39023: LD_INT 3
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 1
39032: PUSH
39033: LD_INT 4
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 0
39042: PUSH
39043: LD_INT 4
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: LD_INT 3
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 1
39063: NEG
39064: PUSH
39065: LD_INT 2
39067: PUSH
39068: EMPTY
39069: LIST
39070: LIST
39071: PUSH
39072: LD_INT 2
39074: PUSH
39075: LD_INT 4
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 2
39084: NEG
39085: PUSH
39086: LD_INT 2
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: LD_INT 4
39095: NEG
39096: PUSH
39097: LD_INT 0
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 4
39106: NEG
39107: PUSH
39108: LD_INT 1
39110: NEG
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: LD_INT 3
39118: NEG
39119: PUSH
39120: LD_INT 0
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 3
39129: NEG
39130: PUSH
39131: LD_INT 1
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: PUSH
39138: LD_INT 4
39140: NEG
39141: PUSH
39142: LD_INT 1
39144: PUSH
39145: EMPTY
39146: LIST
39147: LIST
39148: PUSH
39149: LD_INT 5
39151: NEG
39152: PUSH
39153: LD_INT 0
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 5
39162: NEG
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 5
39174: NEG
39175: PUSH
39176: LD_INT 2
39178: NEG
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 3
39186: NEG
39187: PUSH
39188: LD_INT 2
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 3
39197: NEG
39198: PUSH
39199: LD_INT 3
39201: NEG
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: LD_INT 3
39209: NEG
39210: PUSH
39211: LD_INT 4
39213: NEG
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 2
39221: NEG
39222: PUSH
39223: LD_INT 3
39225: NEG
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 2
39233: NEG
39234: PUSH
39235: LD_INT 2
39237: NEG
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 3
39245: NEG
39246: PUSH
39247: LD_INT 2
39249: NEG
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 4
39257: NEG
39258: PUSH
39259: LD_INT 3
39261: NEG
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 4
39269: NEG
39270: PUSH
39271: LD_INT 4
39273: NEG
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 2
39281: NEG
39282: PUSH
39283: LD_INT 4
39285: NEG
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: PUSH
39291: LD_INT 4
39293: NEG
39294: PUSH
39295: LD_INT 2
39297: NEG
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: LD_INT 4
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 0
39316: PUSH
39317: LD_INT 5
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: PUSH
39328: LD_INT 4
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 1
39338: PUSH
39339: LD_INT 3
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: LD_INT 3
39352: NEG
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 1
39360: NEG
39361: PUSH
39362: LD_INT 4
39364: NEG
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: LD_INT 5
39376: NEG
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 2
39384: PUSH
39385: LD_INT 3
39387: NEG
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: LD_INT 5
39399: NEG
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: LIST
39413: LIST
39414: LIST
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: LIST
39422: LIST
39423: LIST
39424: LIST
39425: LIST
39426: LIST
39427: LIST
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: LIST
39438: LIST
39439: LIST
39440: LIST
39441: LIST
39442: LIST
39443: LIST
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39452: LD_ADDR_VAR 0 31
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: LD_INT 4
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 0
39469: PUSH
39470: LD_INT 3
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 1
39479: PUSH
39480: LD_INT 4
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: PUSH
39487: LD_INT 1
39489: PUSH
39490: LD_INT 5
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: PUSH
39497: LD_INT 0
39499: PUSH
39500: LD_INT 5
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 1
39509: NEG
39510: PUSH
39511: LD_INT 4
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: LD_INT 1
39520: NEG
39521: PUSH
39522: LD_INT 3
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 2
39531: PUSH
39532: LD_INT 5
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 2
39541: NEG
39542: PUSH
39543: LD_INT 3
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 3
39552: NEG
39553: PUSH
39554: LD_INT 0
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 3
39563: NEG
39564: PUSH
39565: LD_INT 1
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 2
39575: NEG
39576: PUSH
39577: LD_INT 0
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 2
39586: NEG
39587: PUSH
39588: LD_INT 1
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 3
39597: NEG
39598: PUSH
39599: LD_INT 1
39601: PUSH
39602: EMPTY
39603: LIST
39604: LIST
39605: PUSH
39606: LD_INT 4
39608: NEG
39609: PUSH
39610: LD_INT 0
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 4
39619: NEG
39620: PUSH
39621: LD_INT 1
39623: NEG
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 4
39631: NEG
39632: PUSH
39633: LD_INT 2
39635: NEG
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 2
39643: NEG
39644: PUSH
39645: LD_INT 2
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 4
39654: NEG
39655: PUSH
39656: LD_INT 4
39658: NEG
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 4
39666: NEG
39667: PUSH
39668: LD_INT 5
39670: NEG
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: LD_INT 3
39678: NEG
39679: PUSH
39680: LD_INT 4
39682: NEG
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: LD_INT 3
39690: NEG
39691: PUSH
39692: LD_INT 3
39694: NEG
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: LD_INT 4
39702: NEG
39703: PUSH
39704: LD_INT 3
39706: NEG
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 5
39714: NEG
39715: PUSH
39716: LD_INT 4
39718: NEG
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 5
39726: NEG
39727: PUSH
39728: LD_INT 5
39730: NEG
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 3
39738: NEG
39739: PUSH
39740: LD_INT 5
39742: NEG
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 5
39750: NEG
39751: PUSH
39752: LD_INT 3
39754: NEG
39755: PUSH
39756: EMPTY
39757: LIST
39758: LIST
39759: PUSH
39760: LD_INT 0
39762: PUSH
39763: LD_INT 3
39765: NEG
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: LD_INT 4
39776: NEG
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: LD_INT 3
39787: NEG
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: LD_INT 1
39795: PUSH
39796: LD_INT 2
39798: NEG
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 0
39806: PUSH
39807: LD_INT 2
39809: NEG
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 1
39817: NEG
39818: PUSH
39819: LD_INT 3
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 1
39829: NEG
39830: PUSH
39831: LD_INT 4
39833: NEG
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 2
39841: PUSH
39842: LD_INT 2
39844: NEG
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: LD_INT 2
39852: NEG
39853: PUSH
39854: LD_INT 4
39856: NEG
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 4
39864: PUSH
39865: LD_INT 0
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 4
39874: PUSH
39875: LD_INT 1
39877: NEG
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 5
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 5
39895: PUSH
39896: LD_INT 1
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 4
39905: PUSH
39906: LD_INT 1
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 3
39915: PUSH
39916: LD_INT 0
39918: PUSH
39919: EMPTY
39920: LIST
39921: LIST
39922: PUSH
39923: LD_INT 3
39925: PUSH
39926: LD_INT 1
39928: NEG
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 3
39936: PUSH
39937: LD_INT 2
39939: NEG
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 5
39947: PUSH
39948: LD_INT 2
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
40002: LD_ADDR_VAR 0 32
40006: PUSH
40007: LD_INT 4
40009: NEG
40010: PUSH
40011: LD_INT 0
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 4
40020: NEG
40021: PUSH
40022: LD_INT 1
40024: NEG
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 3
40032: NEG
40033: PUSH
40034: LD_INT 0
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 3
40043: NEG
40044: PUSH
40045: LD_INT 1
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 4
40054: NEG
40055: PUSH
40056: LD_INT 1
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 5
40065: NEG
40066: PUSH
40067: LD_INT 0
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 5
40076: NEG
40077: PUSH
40078: LD_INT 1
40080: NEG
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 5
40088: NEG
40089: PUSH
40090: LD_INT 2
40092: NEG
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 3
40100: NEG
40101: PUSH
40102: LD_INT 2
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 3
40111: NEG
40112: PUSH
40113: LD_INT 3
40115: NEG
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 3
40123: NEG
40124: PUSH
40125: LD_INT 4
40127: NEG
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: LD_INT 2
40135: NEG
40136: PUSH
40137: LD_INT 3
40139: NEG
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 2
40147: NEG
40148: PUSH
40149: LD_INT 2
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 3
40159: NEG
40160: PUSH
40161: LD_INT 2
40163: NEG
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 4
40171: NEG
40172: PUSH
40173: LD_INT 3
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 4
40183: NEG
40184: PUSH
40185: LD_INT 4
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: LD_INT 2
40195: NEG
40196: PUSH
40197: LD_INT 4
40199: NEG
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 4
40207: NEG
40208: PUSH
40209: LD_INT 2
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 0
40219: PUSH
40220: LD_INT 4
40222: NEG
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: LD_INT 5
40233: NEG
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 1
40241: PUSH
40242: LD_INT 4
40244: NEG
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 1
40252: PUSH
40253: LD_INT 3
40255: NEG
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: LD_INT 3
40266: NEG
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 1
40274: NEG
40275: PUSH
40276: LD_INT 4
40278: NEG
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 1
40286: NEG
40287: PUSH
40288: LD_INT 5
40290: NEG
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 2
40298: PUSH
40299: LD_INT 3
40301: NEG
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 2
40309: NEG
40310: PUSH
40311: LD_INT 5
40313: NEG
40314: PUSH
40315: EMPTY
40316: LIST
40317: LIST
40318: PUSH
40319: LD_INT 3
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 3
40331: PUSH
40332: LD_INT 1
40334: NEG
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 4
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 4
40352: PUSH
40353: LD_INT 1
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 3
40362: PUSH
40363: LD_INT 1
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 2
40372: PUSH
40373: LD_INT 0
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: LD_INT 2
40382: PUSH
40383: LD_INT 1
40385: NEG
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 2
40393: PUSH
40394: LD_INT 2
40396: NEG
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 4
40404: PUSH
40405: LD_INT 2
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PUSH
40412: LD_INT 4
40414: PUSH
40415: LD_INT 4
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: LD_INT 4
40424: PUSH
40425: LD_INT 3
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 5
40434: PUSH
40435: LD_INT 4
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 5
40444: PUSH
40445: LD_INT 5
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 4
40454: PUSH
40455: LD_INT 5
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PUSH
40462: LD_INT 3
40464: PUSH
40465: LD_INT 4
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: LD_INT 3
40474: PUSH
40475: LD_INT 3
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 5
40484: PUSH
40485: LD_INT 3
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 3
40494: PUSH
40495: LD_INT 5
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: LIST
40513: LIST
40514: LIST
40515: LIST
40516: LIST
40517: LIST
40518: LIST
40519: LIST
40520: LIST
40521: LIST
40522: LIST
40523: LIST
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40549: LD_ADDR_VAR 0 33
40553: PUSH
40554: LD_INT 4
40556: NEG
40557: PUSH
40558: LD_INT 4
40560: NEG
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 4
40568: NEG
40569: PUSH
40570: LD_INT 5
40572: NEG
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 3
40580: NEG
40581: PUSH
40582: LD_INT 4
40584: NEG
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 3
40592: NEG
40593: PUSH
40594: LD_INT 3
40596: NEG
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 4
40604: NEG
40605: PUSH
40606: LD_INT 3
40608: NEG
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 5
40616: NEG
40617: PUSH
40618: LD_INT 4
40620: NEG
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 5
40628: NEG
40629: PUSH
40630: LD_INT 5
40632: NEG
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: PUSH
40638: LD_INT 3
40640: NEG
40641: PUSH
40642: LD_INT 5
40644: NEG
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 5
40652: NEG
40653: PUSH
40654: LD_INT 3
40656: NEG
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 0
40664: PUSH
40665: LD_INT 3
40667: NEG
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: LD_INT 4
40678: NEG
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: LD_INT 3
40689: NEG
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 1
40697: PUSH
40698: LD_INT 2
40700: NEG
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 0
40708: PUSH
40709: LD_INT 2
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 1
40719: NEG
40720: PUSH
40721: LD_INT 3
40723: NEG
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 1
40731: NEG
40732: PUSH
40733: LD_INT 4
40735: NEG
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 2
40743: PUSH
40744: LD_INT 2
40746: NEG
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 2
40754: NEG
40755: PUSH
40756: LD_INT 4
40758: NEG
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 4
40766: PUSH
40767: LD_INT 0
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 4
40776: PUSH
40777: LD_INT 1
40779: NEG
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 5
40787: PUSH
40788: LD_INT 0
40790: PUSH
40791: EMPTY
40792: LIST
40793: LIST
40794: PUSH
40795: LD_INT 5
40797: PUSH
40798: LD_INT 1
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 4
40807: PUSH
40808: LD_INT 1
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: LD_INT 0
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 3
40827: PUSH
40828: LD_INT 1
40830: NEG
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: PUSH
40836: LD_INT 3
40838: PUSH
40839: LD_INT 2
40841: NEG
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 5
40849: PUSH
40850: LD_INT 2
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 3
40859: PUSH
40860: LD_INT 3
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 3
40869: PUSH
40870: LD_INT 2
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 4
40879: PUSH
40880: LD_INT 3
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 4
40889: PUSH
40890: LD_INT 4
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 3
40899: PUSH
40900: LD_INT 4
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: LD_INT 2
40909: PUSH
40910: LD_INT 3
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: PUSH
40917: LD_INT 2
40919: PUSH
40920: LD_INT 2
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 4
40929: PUSH
40930: LD_INT 2
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 2
40939: PUSH
40940: LD_INT 4
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 0
40949: PUSH
40950: LD_INT 4
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 0
40959: PUSH
40960: LD_INT 3
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 1
40969: PUSH
40970: LD_INT 4
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: PUSH
40980: LD_INT 5
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: LD_INT 0
40989: PUSH
40990: LD_INT 5
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: LD_INT 4
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 1
41010: NEG
41011: PUSH
41012: LD_INT 3
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 2
41021: PUSH
41022: LD_INT 5
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: LD_INT 2
41031: NEG
41032: PUSH
41033: LD_INT 3
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: LIST
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: LIST
41059: LIST
41060: LIST
41061: LIST
41062: LIST
41063: LIST
41064: LIST
41065: LIST
41066: LIST
41067: LIST
41068: LIST
41069: LIST
41070: LIST
41071: LIST
41072: LIST
41073: LIST
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41087: LD_ADDR_VAR 0 34
41091: PUSH
41092: LD_INT 0
41094: PUSH
41095: LD_INT 4
41097: NEG
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 0
41105: PUSH
41106: LD_INT 5
41108: NEG
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: PUSH
41114: LD_INT 1
41116: PUSH
41117: LD_INT 4
41119: NEG
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PUSH
41125: LD_INT 1
41127: PUSH
41128: LD_INT 3
41130: NEG
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 0
41138: PUSH
41139: LD_INT 3
41141: NEG
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: LD_INT 1
41149: NEG
41150: PUSH
41151: LD_INT 4
41153: NEG
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 1
41161: NEG
41162: PUSH
41163: LD_INT 5
41165: NEG
41166: PUSH
41167: EMPTY
41168: LIST
41169: LIST
41170: PUSH
41171: LD_INT 2
41173: PUSH
41174: LD_INT 3
41176: NEG
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 2
41184: NEG
41185: PUSH
41186: LD_INT 5
41188: NEG
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 3
41196: PUSH
41197: LD_INT 0
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 3
41206: PUSH
41207: LD_INT 1
41209: NEG
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 4
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 4
41227: PUSH
41228: LD_INT 1
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: LD_INT 3
41237: PUSH
41238: LD_INT 1
41240: PUSH
41241: EMPTY
41242: LIST
41243: LIST
41244: PUSH
41245: LD_INT 2
41247: PUSH
41248: LD_INT 0
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 2
41257: PUSH
41258: LD_INT 1
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 2
41268: PUSH
41269: LD_INT 2
41271: NEG
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 4
41279: PUSH
41280: LD_INT 2
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 4
41289: PUSH
41290: LD_INT 4
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 4
41299: PUSH
41300: LD_INT 3
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: LD_INT 5
41309: PUSH
41310: LD_INT 4
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 5
41319: PUSH
41320: LD_INT 5
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 4
41329: PUSH
41330: LD_INT 5
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 3
41339: PUSH
41340: LD_INT 4
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PUSH
41347: LD_INT 3
41349: PUSH
41350: LD_INT 3
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 5
41359: PUSH
41360: LD_INT 3
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: PUSH
41367: LD_INT 3
41369: PUSH
41370: LD_INT 5
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: LD_INT 0
41379: PUSH
41380: LD_INT 3
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 0
41389: PUSH
41390: LD_INT 2
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 1
41399: PUSH
41400: LD_INT 3
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 1
41409: PUSH
41410: LD_INT 4
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: LD_INT 0
41419: PUSH
41420: LD_INT 4
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 1
41429: NEG
41430: PUSH
41431: LD_INT 3
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 1
41440: NEG
41441: PUSH
41442: LD_INT 2
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 2
41451: PUSH
41452: LD_INT 4
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 2
41461: NEG
41462: PUSH
41463: LD_INT 2
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 4
41472: NEG
41473: PUSH
41474: LD_INT 0
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PUSH
41481: LD_INT 4
41483: NEG
41484: PUSH
41485: LD_INT 1
41487: NEG
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: PUSH
41493: LD_INT 3
41495: NEG
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 3
41506: NEG
41507: PUSH
41508: LD_INT 1
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 4
41517: NEG
41518: PUSH
41519: LD_INT 1
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: PUSH
41526: LD_INT 5
41528: NEG
41529: PUSH
41530: LD_INT 0
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: LD_INT 5
41539: NEG
41540: PUSH
41541: LD_INT 1
41543: NEG
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 5
41551: NEG
41552: PUSH
41553: LD_INT 2
41555: NEG
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: LD_INT 3
41563: NEG
41564: PUSH
41565: LD_INT 2
41567: PUSH
41568: EMPTY
41569: LIST
41570: LIST
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: LIST
41576: LIST
41577: LIST
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: ST_TO_ADDR
// end ; end ;
41619: GO 41622
41621: POP
// case btype of b_depot , b_warehouse :
41622: LD_VAR 0 1
41626: PUSH
41627: LD_INT 0
41629: DOUBLE
41630: EQUAL
41631: IFTRUE 41641
41633: LD_INT 1
41635: DOUBLE
41636: EQUAL
41637: IFTRUE 41641
41639: GO 41842
41641: POP
// case nation of nation_american :
41642: LD_VAR 0 5
41646: PUSH
41647: LD_INT 1
41649: DOUBLE
41650: EQUAL
41651: IFTRUE 41655
41653: GO 41711
41655: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41656: LD_ADDR_VAR 0 9
41660: PUSH
41661: LD_VAR 0 11
41665: PUSH
41666: LD_VAR 0 12
41670: PUSH
41671: LD_VAR 0 13
41675: PUSH
41676: LD_VAR 0 14
41680: PUSH
41681: LD_VAR 0 15
41685: PUSH
41686: LD_VAR 0 16
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: PUSH
41699: LD_VAR 0 4
41703: PUSH
41704: LD_INT 1
41706: PLUS
41707: ARRAY
41708: ST_TO_ADDR
41709: GO 41840
41711: LD_INT 2
41713: DOUBLE
41714: EQUAL
41715: IFTRUE 41719
41717: GO 41775
41719: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41720: LD_ADDR_VAR 0 9
41724: PUSH
41725: LD_VAR 0 17
41729: PUSH
41730: LD_VAR 0 18
41734: PUSH
41735: LD_VAR 0 19
41739: PUSH
41740: LD_VAR 0 20
41744: PUSH
41745: LD_VAR 0 21
41749: PUSH
41750: LD_VAR 0 22
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: PUSH
41763: LD_VAR 0 4
41767: PUSH
41768: LD_INT 1
41770: PLUS
41771: ARRAY
41772: ST_TO_ADDR
41773: GO 41840
41775: LD_INT 3
41777: DOUBLE
41778: EQUAL
41779: IFTRUE 41783
41781: GO 41839
41783: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41784: LD_ADDR_VAR 0 9
41788: PUSH
41789: LD_VAR 0 23
41793: PUSH
41794: LD_VAR 0 24
41798: PUSH
41799: LD_VAR 0 25
41803: PUSH
41804: LD_VAR 0 26
41808: PUSH
41809: LD_VAR 0 27
41813: PUSH
41814: LD_VAR 0 28
41818: PUSH
41819: EMPTY
41820: LIST
41821: LIST
41822: LIST
41823: LIST
41824: LIST
41825: LIST
41826: PUSH
41827: LD_VAR 0 4
41831: PUSH
41832: LD_INT 1
41834: PLUS
41835: ARRAY
41836: ST_TO_ADDR
41837: GO 41840
41839: POP
41840: GO 42395
41842: LD_INT 2
41844: DOUBLE
41845: EQUAL
41846: IFTRUE 41856
41848: LD_INT 3
41850: DOUBLE
41851: EQUAL
41852: IFTRUE 41856
41854: GO 41912
41856: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41857: LD_ADDR_VAR 0 9
41861: PUSH
41862: LD_VAR 0 29
41866: PUSH
41867: LD_VAR 0 30
41871: PUSH
41872: LD_VAR 0 31
41876: PUSH
41877: LD_VAR 0 32
41881: PUSH
41882: LD_VAR 0 33
41886: PUSH
41887: LD_VAR 0 34
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: PUSH
41900: LD_VAR 0 4
41904: PUSH
41905: LD_INT 1
41907: PLUS
41908: ARRAY
41909: ST_TO_ADDR
41910: GO 42395
41912: LD_INT 16
41914: DOUBLE
41915: EQUAL
41916: IFTRUE 41974
41918: LD_INT 17
41920: DOUBLE
41921: EQUAL
41922: IFTRUE 41974
41924: LD_INT 18
41926: DOUBLE
41927: EQUAL
41928: IFTRUE 41974
41930: LD_INT 19
41932: DOUBLE
41933: EQUAL
41934: IFTRUE 41974
41936: LD_INT 22
41938: DOUBLE
41939: EQUAL
41940: IFTRUE 41974
41942: LD_INT 20
41944: DOUBLE
41945: EQUAL
41946: IFTRUE 41974
41948: LD_INT 21
41950: DOUBLE
41951: EQUAL
41952: IFTRUE 41974
41954: LD_INT 23
41956: DOUBLE
41957: EQUAL
41958: IFTRUE 41974
41960: LD_INT 24
41962: DOUBLE
41963: EQUAL
41964: IFTRUE 41974
41966: LD_INT 25
41968: DOUBLE
41969: EQUAL
41970: IFTRUE 41974
41972: GO 42030
41974: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41975: LD_ADDR_VAR 0 9
41979: PUSH
41980: LD_VAR 0 35
41984: PUSH
41985: LD_VAR 0 36
41989: PUSH
41990: LD_VAR 0 37
41994: PUSH
41995: LD_VAR 0 38
41999: PUSH
42000: LD_VAR 0 39
42004: PUSH
42005: LD_VAR 0 40
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: LIST
42014: LIST
42015: LIST
42016: LIST
42017: PUSH
42018: LD_VAR 0 4
42022: PUSH
42023: LD_INT 1
42025: PLUS
42026: ARRAY
42027: ST_TO_ADDR
42028: GO 42395
42030: LD_INT 6
42032: DOUBLE
42033: EQUAL
42034: IFTRUE 42086
42036: LD_INT 7
42038: DOUBLE
42039: EQUAL
42040: IFTRUE 42086
42042: LD_INT 8
42044: DOUBLE
42045: EQUAL
42046: IFTRUE 42086
42048: LD_INT 13
42050: DOUBLE
42051: EQUAL
42052: IFTRUE 42086
42054: LD_INT 12
42056: DOUBLE
42057: EQUAL
42058: IFTRUE 42086
42060: LD_INT 15
42062: DOUBLE
42063: EQUAL
42064: IFTRUE 42086
42066: LD_INT 11
42068: DOUBLE
42069: EQUAL
42070: IFTRUE 42086
42072: LD_INT 14
42074: DOUBLE
42075: EQUAL
42076: IFTRUE 42086
42078: LD_INT 10
42080: DOUBLE
42081: EQUAL
42082: IFTRUE 42086
42084: GO 42142
42086: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42087: LD_ADDR_VAR 0 9
42091: PUSH
42092: LD_VAR 0 41
42096: PUSH
42097: LD_VAR 0 42
42101: PUSH
42102: LD_VAR 0 43
42106: PUSH
42107: LD_VAR 0 44
42111: PUSH
42112: LD_VAR 0 45
42116: PUSH
42117: LD_VAR 0 46
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: LIST
42126: LIST
42127: LIST
42128: LIST
42129: PUSH
42130: LD_VAR 0 4
42134: PUSH
42135: LD_INT 1
42137: PLUS
42138: ARRAY
42139: ST_TO_ADDR
42140: GO 42395
42142: LD_INT 36
42144: DOUBLE
42145: EQUAL
42146: IFTRUE 42150
42148: GO 42206
42150: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42151: LD_ADDR_VAR 0 9
42155: PUSH
42156: LD_VAR 0 47
42160: PUSH
42161: LD_VAR 0 48
42165: PUSH
42166: LD_VAR 0 49
42170: PUSH
42171: LD_VAR 0 50
42175: PUSH
42176: LD_VAR 0 51
42180: PUSH
42181: LD_VAR 0 52
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: LIST
42190: LIST
42191: LIST
42192: LIST
42193: PUSH
42194: LD_VAR 0 4
42198: PUSH
42199: LD_INT 1
42201: PLUS
42202: ARRAY
42203: ST_TO_ADDR
42204: GO 42395
42206: LD_INT 4
42208: DOUBLE
42209: EQUAL
42210: IFTRUE 42232
42212: LD_INT 5
42214: DOUBLE
42215: EQUAL
42216: IFTRUE 42232
42218: LD_INT 34
42220: DOUBLE
42221: EQUAL
42222: IFTRUE 42232
42224: LD_INT 37
42226: DOUBLE
42227: EQUAL
42228: IFTRUE 42232
42230: GO 42288
42232: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42233: LD_ADDR_VAR 0 9
42237: PUSH
42238: LD_VAR 0 53
42242: PUSH
42243: LD_VAR 0 54
42247: PUSH
42248: LD_VAR 0 55
42252: PUSH
42253: LD_VAR 0 56
42257: PUSH
42258: LD_VAR 0 57
42262: PUSH
42263: LD_VAR 0 58
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: LIST
42272: LIST
42273: LIST
42274: LIST
42275: PUSH
42276: LD_VAR 0 4
42280: PUSH
42281: LD_INT 1
42283: PLUS
42284: ARRAY
42285: ST_TO_ADDR
42286: GO 42395
42288: LD_INT 31
42290: DOUBLE
42291: EQUAL
42292: IFTRUE 42338
42294: LD_INT 32
42296: DOUBLE
42297: EQUAL
42298: IFTRUE 42338
42300: LD_INT 33
42302: DOUBLE
42303: EQUAL
42304: IFTRUE 42338
42306: LD_INT 27
42308: DOUBLE
42309: EQUAL
42310: IFTRUE 42338
42312: LD_INT 26
42314: DOUBLE
42315: EQUAL
42316: IFTRUE 42338
42318: LD_INT 28
42320: DOUBLE
42321: EQUAL
42322: IFTRUE 42338
42324: LD_INT 29
42326: DOUBLE
42327: EQUAL
42328: IFTRUE 42338
42330: LD_INT 30
42332: DOUBLE
42333: EQUAL
42334: IFTRUE 42338
42336: GO 42394
42338: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42339: LD_ADDR_VAR 0 9
42343: PUSH
42344: LD_VAR 0 59
42348: PUSH
42349: LD_VAR 0 60
42353: PUSH
42354: LD_VAR 0 61
42358: PUSH
42359: LD_VAR 0 62
42363: PUSH
42364: LD_VAR 0 63
42368: PUSH
42369: LD_VAR 0 64
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: LIST
42378: LIST
42379: LIST
42380: LIST
42381: PUSH
42382: LD_VAR 0 4
42386: PUSH
42387: LD_INT 1
42389: PLUS
42390: ARRAY
42391: ST_TO_ADDR
42392: GO 42395
42394: POP
// temp_list2 = [ ] ;
42395: LD_ADDR_VAR 0 10
42399: PUSH
42400: EMPTY
42401: ST_TO_ADDR
// for i in temp_list do
42402: LD_ADDR_VAR 0 8
42406: PUSH
42407: LD_VAR 0 9
42411: PUSH
42412: FOR_IN
42413: IFFALSE 42465
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42415: LD_ADDR_VAR 0 10
42419: PUSH
42420: LD_VAR 0 10
42424: PUSH
42425: LD_VAR 0 8
42429: PUSH
42430: LD_INT 1
42432: ARRAY
42433: PUSH
42434: LD_VAR 0 2
42438: PLUS
42439: PUSH
42440: LD_VAR 0 8
42444: PUSH
42445: LD_INT 2
42447: ARRAY
42448: PUSH
42449: LD_VAR 0 3
42453: PLUS
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: EMPTY
42460: LIST
42461: ADD
42462: ST_TO_ADDR
42463: GO 42412
42465: POP
42466: POP
// result = temp_list2 ;
42467: LD_ADDR_VAR 0 7
42471: PUSH
42472: LD_VAR 0 10
42476: ST_TO_ADDR
// end ;
42477: LD_VAR 0 7
42481: RET
// export function EnemyInRange ( unit , dist ) ; begin
42482: LD_INT 0
42484: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42485: LD_ADDR_VAR 0 3
42489: PUSH
42490: LD_VAR 0 1
42494: PPUSH
42495: CALL_OW 255
42499: PPUSH
42500: LD_VAR 0 1
42504: PPUSH
42505: CALL_OW 250
42509: PPUSH
42510: LD_VAR 0 1
42514: PPUSH
42515: CALL_OW 251
42519: PPUSH
42520: LD_VAR 0 2
42524: PPUSH
42525: CALL 15884 0 4
42529: PUSH
42530: LD_INT 4
42532: ARRAY
42533: ST_TO_ADDR
// end ;
42534: LD_VAR 0 3
42538: RET
// export function PlayerSeeMe ( unit ) ; begin
42539: LD_INT 0
42541: PPUSH
// result := See ( your_side , unit ) ;
42542: LD_ADDR_VAR 0 2
42546: PUSH
42547: LD_OWVAR 2
42551: PPUSH
42552: LD_VAR 0 1
42556: PPUSH
42557: CALL_OW 292
42561: ST_TO_ADDR
// end ;
42562: LD_VAR 0 2
42566: RET
// export function ReverseDir ( unit ) ; begin
42567: LD_INT 0
42569: PPUSH
// if not unit then
42570: LD_VAR 0 1
42574: NOT
42575: IFFALSE 42579
// exit ;
42577: GO 42602
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42579: LD_ADDR_VAR 0 2
42583: PUSH
42584: LD_VAR 0 1
42588: PPUSH
42589: CALL_OW 254
42593: PUSH
42594: LD_INT 3
42596: PLUS
42597: PUSH
42598: LD_INT 6
42600: MOD
42601: ST_TO_ADDR
// end ;
42602: LD_VAR 0 2
42606: RET
// export function ReverseArray ( array ) ; var i ; begin
42607: LD_INT 0
42609: PPUSH
42610: PPUSH
// if not array then
42611: LD_VAR 0 1
42615: NOT
42616: IFFALSE 42620
// exit ;
42618: GO 42675
// result := [ ] ;
42620: LD_ADDR_VAR 0 2
42624: PUSH
42625: EMPTY
42626: ST_TO_ADDR
// for i := array downto 1 do
42627: LD_ADDR_VAR 0 3
42631: PUSH
42632: DOUBLE
42633: LD_VAR 0 1
42637: INC
42638: ST_TO_ADDR
42639: LD_INT 1
42641: PUSH
42642: FOR_DOWNTO
42643: IFFALSE 42673
// result := Join ( result , array [ i ] ) ;
42645: LD_ADDR_VAR 0 2
42649: PUSH
42650: LD_VAR 0 2
42654: PPUSH
42655: LD_VAR 0 1
42659: PUSH
42660: LD_VAR 0 3
42664: ARRAY
42665: PPUSH
42666: CALL 47319 0 2
42670: ST_TO_ADDR
42671: GO 42642
42673: POP
42674: POP
// end ;
42675: LD_VAR 0 2
42679: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
42680: LD_INT 0
42682: PPUSH
42683: PPUSH
42684: PPUSH
42685: PPUSH
42686: PPUSH
42687: PPUSH
// if not unit or not hexes then
42688: LD_VAR 0 1
42692: NOT
42693: PUSH
42694: LD_VAR 0 2
42698: NOT
42699: OR
42700: IFFALSE 42704
// exit ;
42702: GO 42827
// dist := 9999 ;
42704: LD_ADDR_VAR 0 5
42708: PUSH
42709: LD_INT 9999
42711: ST_TO_ADDR
// for i = 1 to hexes do
42712: LD_ADDR_VAR 0 4
42716: PUSH
42717: DOUBLE
42718: LD_INT 1
42720: DEC
42721: ST_TO_ADDR
42722: LD_VAR 0 2
42726: PUSH
42727: FOR_TO
42728: IFFALSE 42815
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42730: LD_ADDR_VAR 0 6
42734: PUSH
42735: LD_VAR 0 1
42739: PPUSH
42740: LD_VAR 0 2
42744: PUSH
42745: LD_VAR 0 4
42749: ARRAY
42750: PUSH
42751: LD_INT 1
42753: ARRAY
42754: PPUSH
42755: LD_VAR 0 2
42759: PUSH
42760: LD_VAR 0 4
42764: ARRAY
42765: PUSH
42766: LD_INT 2
42768: ARRAY
42769: PPUSH
42770: CALL_OW 297
42774: ST_TO_ADDR
// if tdist < dist then
42775: LD_VAR 0 6
42779: PUSH
42780: LD_VAR 0 5
42784: LESS
42785: IFFALSE 42813
// begin hex := hexes [ i ] ;
42787: LD_ADDR_VAR 0 8
42791: PUSH
42792: LD_VAR 0 2
42796: PUSH
42797: LD_VAR 0 4
42801: ARRAY
42802: ST_TO_ADDR
// dist := tdist ;
42803: LD_ADDR_VAR 0 5
42807: PUSH
42808: LD_VAR 0 6
42812: ST_TO_ADDR
// end ; end ;
42813: GO 42727
42815: POP
42816: POP
// result := hex ;
42817: LD_ADDR_VAR 0 3
42821: PUSH
42822: LD_VAR 0 8
42826: ST_TO_ADDR
// end ;
42827: LD_VAR 0 3
42831: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42832: LD_INT 0
42834: PPUSH
42835: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42836: LD_VAR 0 1
42840: NOT
42841: PUSH
42842: LD_VAR 0 1
42846: PUSH
42847: LD_INT 21
42849: PUSH
42850: LD_INT 2
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: LD_INT 23
42859: PUSH
42860: LD_INT 2
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: PPUSH
42871: CALL_OW 69
42875: IN
42876: NOT
42877: OR
42878: IFFALSE 42882
// exit ;
42880: GO 42929
// for i = 1 to 3 do
42882: LD_ADDR_VAR 0 3
42886: PUSH
42887: DOUBLE
42888: LD_INT 1
42890: DEC
42891: ST_TO_ADDR
42892: LD_INT 3
42894: PUSH
42895: FOR_TO
42896: IFFALSE 42927
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42898: LD_VAR 0 1
42902: PPUSH
42903: CALL_OW 250
42907: PPUSH
42908: LD_VAR 0 1
42912: PPUSH
42913: CALL_OW 251
42917: PPUSH
42918: LD_INT 1
42920: PPUSH
42921: CALL_OW 453
42925: GO 42895
42927: POP
42928: POP
// end ;
42929: LD_VAR 0 2
42933: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42934: LD_INT 0
42936: PPUSH
42937: PPUSH
42938: PPUSH
42939: PPUSH
42940: PPUSH
42941: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42942: LD_VAR 0 1
42946: NOT
42947: PUSH
42948: LD_VAR 0 2
42952: NOT
42953: OR
42954: PUSH
42955: LD_VAR 0 1
42959: PPUSH
42960: CALL_OW 314
42964: OR
42965: IFFALSE 42969
// exit ;
42967: GO 43436
// if GetLives ( i ) < 250 then
42969: LD_VAR 0 4
42973: PPUSH
42974: CALL_OW 256
42978: PUSH
42979: LD_INT 250
42981: LESS
42982: IFFALSE 42995
// begin ComAutodestruct ( i ) ;
42984: LD_VAR 0 4
42988: PPUSH
42989: CALL 42832 0 1
// exit ;
42993: GO 43436
// end ; x := GetX ( enemy_unit ) ;
42995: LD_ADDR_VAR 0 7
42999: PUSH
43000: LD_VAR 0 2
43004: PPUSH
43005: CALL_OW 250
43009: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
43010: LD_ADDR_VAR 0 8
43014: PUSH
43015: LD_VAR 0 2
43019: PPUSH
43020: CALL_OW 251
43024: ST_TO_ADDR
// if not x or not y then
43025: LD_VAR 0 7
43029: NOT
43030: PUSH
43031: LD_VAR 0 8
43035: NOT
43036: OR
43037: IFFALSE 43041
// exit ;
43039: GO 43436
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43041: LD_ADDR_VAR 0 6
43045: PUSH
43046: LD_VAR 0 7
43050: PPUSH
43051: LD_INT 0
43053: PPUSH
43054: LD_INT 4
43056: PPUSH
43057: CALL_OW 272
43061: PUSH
43062: LD_VAR 0 8
43066: PPUSH
43067: LD_INT 0
43069: PPUSH
43070: LD_INT 4
43072: PPUSH
43073: CALL_OW 273
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_VAR 0 7
43086: PPUSH
43087: LD_INT 1
43089: PPUSH
43090: LD_INT 4
43092: PPUSH
43093: CALL_OW 272
43097: PUSH
43098: LD_VAR 0 8
43102: PPUSH
43103: LD_INT 1
43105: PPUSH
43106: LD_INT 4
43108: PPUSH
43109: CALL_OW 273
43113: PUSH
43114: EMPTY
43115: LIST
43116: LIST
43117: PUSH
43118: LD_VAR 0 7
43122: PPUSH
43123: LD_INT 2
43125: PPUSH
43126: LD_INT 4
43128: PPUSH
43129: CALL_OW 272
43133: PUSH
43134: LD_VAR 0 8
43138: PPUSH
43139: LD_INT 2
43141: PPUSH
43142: LD_INT 4
43144: PPUSH
43145: CALL_OW 273
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_VAR 0 7
43158: PPUSH
43159: LD_INT 3
43161: PPUSH
43162: LD_INT 4
43164: PPUSH
43165: CALL_OW 272
43169: PUSH
43170: LD_VAR 0 8
43174: PPUSH
43175: LD_INT 3
43177: PPUSH
43178: LD_INT 4
43180: PPUSH
43181: CALL_OW 273
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_VAR 0 7
43194: PPUSH
43195: LD_INT 4
43197: PPUSH
43198: LD_INT 4
43200: PPUSH
43201: CALL_OW 272
43205: PUSH
43206: LD_VAR 0 8
43210: PPUSH
43211: LD_INT 4
43213: PPUSH
43214: LD_INT 4
43216: PPUSH
43217: CALL_OW 273
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: PUSH
43226: LD_VAR 0 7
43230: PPUSH
43231: LD_INT 5
43233: PPUSH
43234: LD_INT 4
43236: PPUSH
43237: CALL_OW 272
43241: PUSH
43242: LD_VAR 0 8
43246: PPUSH
43247: LD_INT 5
43249: PPUSH
43250: LD_INT 4
43252: PPUSH
43253: CALL_OW 273
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: ST_TO_ADDR
// for i = tmp downto 1 do
43270: LD_ADDR_VAR 0 4
43274: PUSH
43275: DOUBLE
43276: LD_VAR 0 6
43280: INC
43281: ST_TO_ADDR
43282: LD_INT 1
43284: PUSH
43285: FOR_DOWNTO
43286: IFFALSE 43387
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43288: LD_VAR 0 6
43292: PUSH
43293: LD_VAR 0 4
43297: ARRAY
43298: PUSH
43299: LD_INT 1
43301: ARRAY
43302: PPUSH
43303: LD_VAR 0 6
43307: PUSH
43308: LD_VAR 0 4
43312: ARRAY
43313: PUSH
43314: LD_INT 2
43316: ARRAY
43317: PPUSH
43318: CALL_OW 488
43322: NOT
43323: PUSH
43324: LD_VAR 0 6
43328: PUSH
43329: LD_VAR 0 4
43333: ARRAY
43334: PUSH
43335: LD_INT 1
43337: ARRAY
43338: PPUSH
43339: LD_VAR 0 6
43343: PUSH
43344: LD_VAR 0 4
43348: ARRAY
43349: PUSH
43350: LD_INT 2
43352: ARRAY
43353: PPUSH
43354: CALL_OW 428
43358: PUSH
43359: LD_INT 0
43361: NONEQUAL
43362: OR
43363: IFFALSE 43385
// tmp := Delete ( tmp , i ) ;
43365: LD_ADDR_VAR 0 6
43369: PUSH
43370: LD_VAR 0 6
43374: PPUSH
43375: LD_VAR 0 4
43379: PPUSH
43380: CALL_OW 3
43384: ST_TO_ADDR
43385: GO 43285
43387: POP
43388: POP
// j := GetClosestHex ( unit , tmp ) ;
43389: LD_ADDR_VAR 0 5
43393: PUSH
43394: LD_VAR 0 1
43398: PPUSH
43399: LD_VAR 0 6
43403: PPUSH
43404: CALL 42680 0 2
43408: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43409: LD_VAR 0 1
43413: PPUSH
43414: LD_VAR 0 5
43418: PUSH
43419: LD_INT 1
43421: ARRAY
43422: PPUSH
43423: LD_VAR 0 5
43427: PUSH
43428: LD_INT 2
43430: ARRAY
43431: PPUSH
43432: CALL_OW 111
// end ;
43436: LD_VAR 0 3
43440: RET
// export function PrepareApemanSoldier ( ) ; begin
43441: LD_INT 0
43443: PPUSH
// uc_nation := 0 ;
43444: LD_ADDR_OWVAR 21
43448: PUSH
43449: LD_INT 0
43451: ST_TO_ADDR
// hc_sex := sex_male ;
43452: LD_ADDR_OWVAR 27
43456: PUSH
43457: LD_INT 1
43459: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
43460: LD_ADDR_OWVAR 28
43464: PUSH
43465: LD_INT 15
43467: ST_TO_ADDR
// hc_gallery :=  ;
43468: LD_ADDR_OWVAR 33
43472: PUSH
43473: LD_STRING 
43475: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43476: LD_ADDR_OWVAR 31
43480: PUSH
43481: LD_INT 0
43483: PPUSH
43484: LD_INT 3
43486: PPUSH
43487: CALL_OW 12
43491: PUSH
43492: LD_INT 0
43494: PPUSH
43495: LD_INT 3
43497: PPUSH
43498: CALL_OW 12
43502: PUSH
43503: LD_INT 0
43505: PUSH
43506: LD_INT 0
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: LIST
43513: LIST
43514: ST_TO_ADDR
// end ;
43515: LD_VAR 0 1
43519: RET
// export function PrepareApemanEngineer ( ) ; begin
43520: LD_INT 0
43522: PPUSH
// uc_nation := 0 ;
43523: LD_ADDR_OWVAR 21
43527: PUSH
43528: LD_INT 0
43530: ST_TO_ADDR
// hc_sex := sex_male ;
43531: LD_ADDR_OWVAR 27
43535: PUSH
43536: LD_INT 1
43538: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
43539: LD_ADDR_OWVAR 28
43543: PUSH
43544: LD_INT 16
43546: ST_TO_ADDR
// hc_gallery :=  ;
43547: LD_ADDR_OWVAR 33
43551: PUSH
43552: LD_STRING 
43554: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43555: LD_ADDR_OWVAR 31
43559: PUSH
43560: LD_INT 0
43562: PPUSH
43563: LD_INT 3
43565: PPUSH
43566: CALL_OW 12
43570: PUSH
43571: LD_INT 0
43573: PPUSH
43574: LD_INT 3
43576: PPUSH
43577: CALL_OW 12
43581: PUSH
43582: LD_INT 0
43584: PUSH
43585: LD_INT 0
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: LIST
43592: LIST
43593: ST_TO_ADDR
// end ;
43594: LD_VAR 0 1
43598: RET
// export function PrepareApeman ( agressivity ) ; begin
43599: LD_INT 0
43601: PPUSH
// uc_side := 0 ;
43602: LD_ADDR_OWVAR 20
43606: PUSH
43607: LD_INT 0
43609: ST_TO_ADDR
// uc_nation := 0 ;
43610: LD_ADDR_OWVAR 21
43614: PUSH
43615: LD_INT 0
43617: ST_TO_ADDR
// hc_sex := sex_male ;
43618: LD_ADDR_OWVAR 27
43622: PUSH
43623: LD_INT 1
43625: ST_TO_ADDR
// hc_class := class_apeman ;
43626: LD_ADDR_OWVAR 28
43630: PUSH
43631: LD_INT 12
43633: ST_TO_ADDR
// hc_gallery :=  ;
43634: LD_ADDR_OWVAR 33
43638: PUSH
43639: LD_STRING 
43641: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43642: LD_ADDR_OWVAR 35
43646: PUSH
43647: LD_VAR 0 1
43651: NEG
43652: PPUSH
43653: LD_VAR 0 1
43657: PPUSH
43658: CALL_OW 12
43662: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43663: LD_ADDR_OWVAR 31
43667: PUSH
43668: LD_INT 0
43670: PPUSH
43671: LD_INT 3
43673: PPUSH
43674: CALL_OW 12
43678: PUSH
43679: LD_INT 0
43681: PPUSH
43682: LD_INT 3
43684: PPUSH
43685: CALL_OW 12
43689: PUSH
43690: LD_INT 0
43692: PUSH
43693: LD_INT 0
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: ST_TO_ADDR
// end ;
43702: LD_VAR 0 2
43706: RET
// export function PrepareTiger ( agressivity ) ; begin
43707: LD_INT 0
43709: PPUSH
// uc_side := 0 ;
43710: LD_ADDR_OWVAR 20
43714: PUSH
43715: LD_INT 0
43717: ST_TO_ADDR
// uc_nation := 0 ;
43718: LD_ADDR_OWVAR 21
43722: PUSH
43723: LD_INT 0
43725: ST_TO_ADDR
// hc_class := class_tiger ;
43726: LD_ADDR_OWVAR 28
43730: PUSH
43731: LD_INT 14
43733: ST_TO_ADDR
// hc_gallery :=  ;
43734: LD_ADDR_OWVAR 33
43738: PUSH
43739: LD_STRING 
43741: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43742: LD_ADDR_OWVAR 35
43746: PUSH
43747: LD_VAR 0 1
43751: NEG
43752: PPUSH
43753: LD_VAR 0 1
43757: PPUSH
43758: CALL_OW 12
43762: ST_TO_ADDR
// end ;
43763: LD_VAR 0 2
43767: RET
// export function PrepareEnchidna ( ) ; begin
43768: LD_INT 0
43770: PPUSH
// uc_side := 0 ;
43771: LD_ADDR_OWVAR 20
43775: PUSH
43776: LD_INT 0
43778: ST_TO_ADDR
// uc_nation := 0 ;
43779: LD_ADDR_OWVAR 21
43783: PUSH
43784: LD_INT 0
43786: ST_TO_ADDR
// hc_class := class_baggie ;
43787: LD_ADDR_OWVAR 28
43791: PUSH
43792: LD_INT 13
43794: ST_TO_ADDR
// hc_gallery :=  ;
43795: LD_ADDR_OWVAR 33
43799: PUSH
43800: LD_STRING 
43802: ST_TO_ADDR
// end ;
43803: LD_VAR 0 1
43807: RET
// export function PrepareFrog ( ) ; begin
43808: LD_INT 0
43810: PPUSH
// uc_side := 0 ;
43811: LD_ADDR_OWVAR 20
43815: PUSH
43816: LD_INT 0
43818: ST_TO_ADDR
// uc_nation := 0 ;
43819: LD_ADDR_OWVAR 21
43823: PUSH
43824: LD_INT 0
43826: ST_TO_ADDR
// hc_class := class_frog ;
43827: LD_ADDR_OWVAR 28
43831: PUSH
43832: LD_INT 19
43834: ST_TO_ADDR
// hc_gallery :=  ;
43835: LD_ADDR_OWVAR 33
43839: PUSH
43840: LD_STRING 
43842: ST_TO_ADDR
// end ;
43843: LD_VAR 0 1
43847: RET
// export function PrepareFish ( ) ; begin
43848: LD_INT 0
43850: PPUSH
// uc_side := 0 ;
43851: LD_ADDR_OWVAR 20
43855: PUSH
43856: LD_INT 0
43858: ST_TO_ADDR
// uc_nation := 0 ;
43859: LD_ADDR_OWVAR 21
43863: PUSH
43864: LD_INT 0
43866: ST_TO_ADDR
// hc_class := class_fish ;
43867: LD_ADDR_OWVAR 28
43871: PUSH
43872: LD_INT 20
43874: ST_TO_ADDR
// hc_gallery :=  ;
43875: LD_ADDR_OWVAR 33
43879: PUSH
43880: LD_STRING 
43882: ST_TO_ADDR
// end ;
43883: LD_VAR 0 1
43887: RET
// export function PrepareBird ( ) ; begin
43888: LD_INT 0
43890: PPUSH
// uc_side := 0 ;
43891: LD_ADDR_OWVAR 20
43895: PUSH
43896: LD_INT 0
43898: ST_TO_ADDR
// uc_nation := 0 ;
43899: LD_ADDR_OWVAR 21
43903: PUSH
43904: LD_INT 0
43906: ST_TO_ADDR
// hc_class := class_phororhacos ;
43907: LD_ADDR_OWVAR 28
43911: PUSH
43912: LD_INT 18
43914: ST_TO_ADDR
// hc_gallery :=  ;
43915: LD_ADDR_OWVAR 33
43919: PUSH
43920: LD_STRING 
43922: ST_TO_ADDR
// end ;
43923: LD_VAR 0 1
43927: RET
// export function PrepareHorse ( ) ; begin
43928: LD_INT 0
43930: PPUSH
// uc_side := 0 ;
43931: LD_ADDR_OWVAR 20
43935: PUSH
43936: LD_INT 0
43938: ST_TO_ADDR
// uc_nation := 0 ;
43939: LD_ADDR_OWVAR 21
43943: PUSH
43944: LD_INT 0
43946: ST_TO_ADDR
// hc_class := class_horse ;
43947: LD_ADDR_OWVAR 28
43951: PUSH
43952: LD_INT 21
43954: ST_TO_ADDR
// hc_gallery :=  ;
43955: LD_ADDR_OWVAR 33
43959: PUSH
43960: LD_STRING 
43962: ST_TO_ADDR
// end ;
43963: LD_VAR 0 1
43967: RET
// export function PrepareMastodont ( ) ; begin
43968: LD_INT 0
43970: PPUSH
// uc_side := 0 ;
43971: LD_ADDR_OWVAR 20
43975: PUSH
43976: LD_INT 0
43978: ST_TO_ADDR
// uc_nation := 0 ;
43979: LD_ADDR_OWVAR 21
43983: PUSH
43984: LD_INT 0
43986: ST_TO_ADDR
// vc_chassis := class_mastodont ;
43987: LD_ADDR_OWVAR 37
43991: PUSH
43992: LD_INT 31
43994: ST_TO_ADDR
// vc_control := control_rider ;
43995: LD_ADDR_OWVAR 38
43999: PUSH
44000: LD_INT 4
44002: ST_TO_ADDR
// end ;
44003: LD_VAR 0 1
44007: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
44008: LD_INT 0
44010: PPUSH
44011: PPUSH
44012: PPUSH
// uc_side = 0 ;
44013: LD_ADDR_OWVAR 20
44017: PUSH
44018: LD_INT 0
44020: ST_TO_ADDR
// uc_nation = 0 ;
44021: LD_ADDR_OWVAR 21
44025: PUSH
44026: LD_INT 0
44028: ST_TO_ADDR
// InitHc_All ( ) ;
44029: CALL_OW 584
// InitVc ;
44033: CALL_OW 20
// if mastodonts then
44037: LD_VAR 0 6
44041: IFFALSE 44108
// for i = 1 to mastodonts do
44043: LD_ADDR_VAR 0 11
44047: PUSH
44048: DOUBLE
44049: LD_INT 1
44051: DEC
44052: ST_TO_ADDR
44053: LD_VAR 0 6
44057: PUSH
44058: FOR_TO
44059: IFFALSE 44106
// begin vc_chassis := 31 ;
44061: LD_ADDR_OWVAR 37
44065: PUSH
44066: LD_INT 31
44068: ST_TO_ADDR
// vc_control := control_rider ;
44069: LD_ADDR_OWVAR 38
44073: PUSH
44074: LD_INT 4
44076: ST_TO_ADDR
// animal := CreateVehicle ;
44077: LD_ADDR_VAR 0 12
44081: PUSH
44082: CALL_OW 45
44086: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44087: LD_VAR 0 12
44091: PPUSH
44092: LD_VAR 0 8
44096: PPUSH
44097: LD_INT 0
44099: PPUSH
44100: CALL 46236 0 3
// end ;
44104: GO 44058
44106: POP
44107: POP
// if horses then
44108: LD_VAR 0 5
44112: IFFALSE 44179
// for i = 1 to horses do
44114: LD_ADDR_VAR 0 11
44118: PUSH
44119: DOUBLE
44120: LD_INT 1
44122: DEC
44123: ST_TO_ADDR
44124: LD_VAR 0 5
44128: PUSH
44129: FOR_TO
44130: IFFALSE 44177
// begin hc_class := 21 ;
44132: LD_ADDR_OWVAR 28
44136: PUSH
44137: LD_INT 21
44139: ST_TO_ADDR
// hc_gallery :=  ;
44140: LD_ADDR_OWVAR 33
44144: PUSH
44145: LD_STRING 
44147: ST_TO_ADDR
// animal := CreateHuman ;
44148: LD_ADDR_VAR 0 12
44152: PUSH
44153: CALL_OW 44
44157: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44158: LD_VAR 0 12
44162: PPUSH
44163: LD_VAR 0 8
44167: PPUSH
44168: LD_INT 0
44170: PPUSH
44171: CALL 46236 0 3
// end ;
44175: GO 44129
44177: POP
44178: POP
// if birds then
44179: LD_VAR 0 1
44183: IFFALSE 44250
// for i = 1 to birds do
44185: LD_ADDR_VAR 0 11
44189: PUSH
44190: DOUBLE
44191: LD_INT 1
44193: DEC
44194: ST_TO_ADDR
44195: LD_VAR 0 1
44199: PUSH
44200: FOR_TO
44201: IFFALSE 44248
// begin hc_class = 18 ;
44203: LD_ADDR_OWVAR 28
44207: PUSH
44208: LD_INT 18
44210: ST_TO_ADDR
// hc_gallery =  ;
44211: LD_ADDR_OWVAR 33
44215: PUSH
44216: LD_STRING 
44218: ST_TO_ADDR
// animal := CreateHuman ;
44219: LD_ADDR_VAR 0 12
44223: PUSH
44224: CALL_OW 44
44228: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44229: LD_VAR 0 12
44233: PPUSH
44234: LD_VAR 0 8
44238: PPUSH
44239: LD_INT 0
44241: PPUSH
44242: CALL 46236 0 3
// end ;
44246: GO 44200
44248: POP
44249: POP
// if tigers then
44250: LD_VAR 0 2
44254: IFFALSE 44338
// for i = 1 to tigers do
44256: LD_ADDR_VAR 0 11
44260: PUSH
44261: DOUBLE
44262: LD_INT 1
44264: DEC
44265: ST_TO_ADDR
44266: LD_VAR 0 2
44270: PUSH
44271: FOR_TO
44272: IFFALSE 44336
// begin hc_class = class_tiger ;
44274: LD_ADDR_OWVAR 28
44278: PUSH
44279: LD_INT 14
44281: ST_TO_ADDR
// hc_gallery =  ;
44282: LD_ADDR_OWVAR 33
44286: PUSH
44287: LD_STRING 
44289: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44290: LD_ADDR_OWVAR 35
44294: PUSH
44295: LD_INT 7
44297: NEG
44298: PPUSH
44299: LD_INT 7
44301: PPUSH
44302: CALL_OW 12
44306: ST_TO_ADDR
// animal := CreateHuman ;
44307: LD_ADDR_VAR 0 12
44311: PUSH
44312: CALL_OW 44
44316: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44317: LD_VAR 0 12
44321: PPUSH
44322: LD_VAR 0 8
44326: PPUSH
44327: LD_INT 0
44329: PPUSH
44330: CALL 46236 0 3
// end ;
44334: GO 44271
44336: POP
44337: POP
// if apemans then
44338: LD_VAR 0 3
44342: IFFALSE 44465
// for i = 1 to apemans do
44344: LD_ADDR_VAR 0 11
44348: PUSH
44349: DOUBLE
44350: LD_INT 1
44352: DEC
44353: ST_TO_ADDR
44354: LD_VAR 0 3
44358: PUSH
44359: FOR_TO
44360: IFFALSE 44463
// begin hc_class = class_apeman ;
44362: LD_ADDR_OWVAR 28
44366: PUSH
44367: LD_INT 12
44369: ST_TO_ADDR
// hc_gallery =  ;
44370: LD_ADDR_OWVAR 33
44374: PUSH
44375: LD_STRING 
44377: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44378: LD_ADDR_OWVAR 35
44382: PUSH
44383: LD_INT 2
44385: NEG
44386: PPUSH
44387: LD_INT 2
44389: PPUSH
44390: CALL_OW 12
44394: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44395: LD_ADDR_OWVAR 31
44399: PUSH
44400: LD_INT 1
44402: PPUSH
44403: LD_INT 3
44405: PPUSH
44406: CALL_OW 12
44410: PUSH
44411: LD_INT 1
44413: PPUSH
44414: LD_INT 3
44416: PPUSH
44417: CALL_OW 12
44421: PUSH
44422: LD_INT 0
44424: PUSH
44425: LD_INT 0
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: LIST
44432: LIST
44433: ST_TO_ADDR
// animal := CreateHuman ;
44434: LD_ADDR_VAR 0 12
44438: PUSH
44439: CALL_OW 44
44443: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44444: LD_VAR 0 12
44448: PPUSH
44449: LD_VAR 0 8
44453: PPUSH
44454: LD_INT 0
44456: PPUSH
44457: CALL 46236 0 3
// end ;
44461: GO 44359
44463: POP
44464: POP
// if enchidnas then
44465: LD_VAR 0 4
44469: IFFALSE 44536
// for i = 1 to enchidnas do
44471: LD_ADDR_VAR 0 11
44475: PUSH
44476: DOUBLE
44477: LD_INT 1
44479: DEC
44480: ST_TO_ADDR
44481: LD_VAR 0 4
44485: PUSH
44486: FOR_TO
44487: IFFALSE 44534
// begin hc_class = 13 ;
44489: LD_ADDR_OWVAR 28
44493: PUSH
44494: LD_INT 13
44496: ST_TO_ADDR
// hc_gallery =  ;
44497: LD_ADDR_OWVAR 33
44501: PUSH
44502: LD_STRING 
44504: ST_TO_ADDR
// animal := CreateHuman ;
44505: LD_ADDR_VAR 0 12
44509: PUSH
44510: CALL_OW 44
44514: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44515: LD_VAR 0 12
44519: PPUSH
44520: LD_VAR 0 8
44524: PPUSH
44525: LD_INT 0
44527: PPUSH
44528: CALL 46236 0 3
// end ;
44532: GO 44486
44534: POP
44535: POP
// if fishes then
44536: LD_VAR 0 7
44540: IFFALSE 44607
// for i = 1 to fishes do
44542: LD_ADDR_VAR 0 11
44546: PUSH
44547: DOUBLE
44548: LD_INT 1
44550: DEC
44551: ST_TO_ADDR
44552: LD_VAR 0 7
44556: PUSH
44557: FOR_TO
44558: IFFALSE 44605
// begin hc_class = 20 ;
44560: LD_ADDR_OWVAR 28
44564: PUSH
44565: LD_INT 20
44567: ST_TO_ADDR
// hc_gallery =  ;
44568: LD_ADDR_OWVAR 33
44572: PUSH
44573: LD_STRING 
44575: ST_TO_ADDR
// animal := CreateHuman ;
44576: LD_ADDR_VAR 0 12
44580: PUSH
44581: CALL_OW 44
44585: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44586: LD_VAR 0 12
44590: PPUSH
44591: LD_VAR 0 9
44595: PPUSH
44596: LD_INT 0
44598: PPUSH
44599: CALL 46236 0 3
// end ;
44603: GO 44557
44605: POP
44606: POP
// end ;
44607: LD_VAR 0 10
44611: RET
// export function WantHeal ( sci , unit ) ; begin
44612: LD_INT 0
44614: PPUSH
// if GetTaskList ( sci ) > 0 then
44615: LD_VAR 0 1
44619: PPUSH
44620: CALL_OW 437
44624: PUSH
44625: LD_INT 0
44627: GREATER
44628: IFFALSE 44698
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44630: LD_VAR 0 1
44634: PPUSH
44635: CALL_OW 437
44639: PUSH
44640: LD_INT 1
44642: ARRAY
44643: PUSH
44644: LD_INT 1
44646: ARRAY
44647: PUSH
44648: LD_STRING l
44650: EQUAL
44651: PUSH
44652: LD_VAR 0 1
44656: PPUSH
44657: CALL_OW 437
44661: PUSH
44662: LD_INT 1
44664: ARRAY
44665: PUSH
44666: LD_INT 4
44668: ARRAY
44669: PUSH
44670: LD_VAR 0 2
44674: EQUAL
44675: AND
44676: IFFALSE 44688
// result := true else
44678: LD_ADDR_VAR 0 3
44682: PUSH
44683: LD_INT 1
44685: ST_TO_ADDR
44686: GO 44696
// result := false ;
44688: LD_ADDR_VAR 0 3
44692: PUSH
44693: LD_INT 0
44695: ST_TO_ADDR
// end else
44696: GO 44706
// result := false ;
44698: LD_ADDR_VAR 0 3
44702: PUSH
44703: LD_INT 0
44705: ST_TO_ADDR
// end ;
44706: LD_VAR 0 3
44710: RET
// export function HealTarget ( sci ) ; begin
44711: LD_INT 0
44713: PPUSH
// if not sci then
44714: LD_VAR 0 1
44718: NOT
44719: IFFALSE 44723
// exit ;
44721: GO 44788
// result := 0 ;
44723: LD_ADDR_VAR 0 2
44727: PUSH
44728: LD_INT 0
44730: ST_TO_ADDR
// if GetTaskList ( sci ) then
44731: LD_VAR 0 1
44735: PPUSH
44736: CALL_OW 437
44740: IFFALSE 44788
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44742: LD_VAR 0 1
44746: PPUSH
44747: CALL_OW 437
44751: PUSH
44752: LD_INT 1
44754: ARRAY
44755: PUSH
44756: LD_INT 1
44758: ARRAY
44759: PUSH
44760: LD_STRING l
44762: EQUAL
44763: IFFALSE 44788
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44765: LD_ADDR_VAR 0 2
44769: PUSH
44770: LD_VAR 0 1
44774: PPUSH
44775: CALL_OW 437
44779: PUSH
44780: LD_INT 1
44782: ARRAY
44783: PUSH
44784: LD_INT 4
44786: ARRAY
44787: ST_TO_ADDR
// end ;
44788: LD_VAR 0 2
44792: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44793: LD_INT 0
44795: PPUSH
44796: PPUSH
44797: PPUSH
44798: PPUSH
// if not base_units then
44799: LD_VAR 0 1
44803: NOT
44804: IFFALSE 44808
// exit ;
44806: GO 44895
// result := false ;
44808: LD_ADDR_VAR 0 2
44812: PUSH
44813: LD_INT 0
44815: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44816: LD_ADDR_VAR 0 5
44820: PUSH
44821: LD_VAR 0 1
44825: PPUSH
44826: LD_INT 21
44828: PUSH
44829: LD_INT 3
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PPUSH
44836: CALL_OW 72
44840: ST_TO_ADDR
// if not tmp then
44841: LD_VAR 0 5
44845: NOT
44846: IFFALSE 44850
// exit ;
44848: GO 44895
// for i in tmp do
44850: LD_ADDR_VAR 0 3
44854: PUSH
44855: LD_VAR 0 5
44859: PUSH
44860: FOR_IN
44861: IFFALSE 44893
// begin result := EnemyInRange ( i , 22 ) ;
44863: LD_ADDR_VAR 0 2
44867: PUSH
44868: LD_VAR 0 3
44872: PPUSH
44873: LD_INT 22
44875: PPUSH
44876: CALL 42482 0 2
44880: ST_TO_ADDR
// if result then
44881: LD_VAR 0 2
44885: IFFALSE 44891
// exit ;
44887: POP
44888: POP
44889: GO 44895
// end ;
44891: GO 44860
44893: POP
44894: POP
// end ;
44895: LD_VAR 0 2
44899: RET
// export function FilterByTag ( units , tag ) ; begin
44900: LD_INT 0
44902: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
44903: LD_ADDR_VAR 0 3
44907: PUSH
44908: LD_VAR 0 1
44912: PPUSH
44913: LD_INT 120
44915: PUSH
44916: LD_VAR 0 2
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PPUSH
44925: CALL_OW 72
44929: ST_TO_ADDR
// end ;
44930: LD_VAR 0 3
44934: RET
// export function IsDriver ( un ) ; begin
44935: LD_INT 0
44937: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44938: LD_ADDR_VAR 0 2
44942: PUSH
44943: LD_VAR 0 1
44947: PUSH
44948: LD_INT 55
44950: PUSH
44951: EMPTY
44952: LIST
44953: PPUSH
44954: CALL_OW 69
44958: IN
44959: ST_TO_ADDR
// end ;
44960: LD_VAR 0 2
44964: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44965: LD_INT 0
44967: PPUSH
44968: PPUSH
// list := [ ] ;
44969: LD_ADDR_VAR 0 5
44973: PUSH
44974: EMPTY
44975: ST_TO_ADDR
// case d of 0 :
44976: LD_VAR 0 3
44980: PUSH
44981: LD_INT 0
44983: DOUBLE
44984: EQUAL
44985: IFTRUE 44989
44987: GO 45122
44989: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44990: LD_ADDR_VAR 0 5
44994: PUSH
44995: LD_VAR 0 1
44999: PUSH
45000: LD_INT 4
45002: MINUS
45003: PUSH
45004: LD_VAR 0 2
45008: PUSH
45009: LD_INT 4
45011: MINUS
45012: PUSH
45013: LD_INT 2
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: LIST
45020: PUSH
45021: LD_VAR 0 1
45025: PUSH
45026: LD_INT 3
45028: MINUS
45029: PUSH
45030: LD_VAR 0 2
45034: PUSH
45035: LD_INT 1
45037: PUSH
45038: EMPTY
45039: LIST
45040: LIST
45041: LIST
45042: PUSH
45043: LD_VAR 0 1
45047: PUSH
45048: LD_INT 4
45050: PLUS
45051: PUSH
45052: LD_VAR 0 2
45056: PUSH
45057: LD_INT 4
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: LIST
45064: PUSH
45065: LD_VAR 0 1
45069: PUSH
45070: LD_INT 3
45072: PLUS
45073: PUSH
45074: LD_VAR 0 2
45078: PUSH
45079: LD_INT 3
45081: PLUS
45082: PUSH
45083: LD_INT 5
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: LIST
45090: PUSH
45091: LD_VAR 0 1
45095: PUSH
45096: LD_VAR 0 2
45100: PUSH
45101: LD_INT 4
45103: PLUS
45104: PUSH
45105: LD_INT 0
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: LIST
45112: PUSH
45113: EMPTY
45114: LIST
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: ST_TO_ADDR
// end ; 1 :
45120: GO 45820
45122: LD_INT 1
45124: DOUBLE
45125: EQUAL
45126: IFTRUE 45130
45128: GO 45263
45130: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45131: LD_ADDR_VAR 0 5
45135: PUSH
45136: LD_VAR 0 1
45140: PUSH
45141: LD_VAR 0 2
45145: PUSH
45146: LD_INT 4
45148: MINUS
45149: PUSH
45150: LD_INT 3
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: LIST
45157: PUSH
45158: LD_VAR 0 1
45162: PUSH
45163: LD_INT 3
45165: MINUS
45166: PUSH
45167: LD_VAR 0 2
45171: PUSH
45172: LD_INT 3
45174: MINUS
45175: PUSH
45176: LD_INT 2
45178: PUSH
45179: EMPTY
45180: LIST
45181: LIST
45182: LIST
45183: PUSH
45184: LD_VAR 0 1
45188: PUSH
45189: LD_INT 4
45191: MINUS
45192: PUSH
45193: LD_VAR 0 2
45197: PUSH
45198: LD_INT 1
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: LIST
45205: PUSH
45206: LD_VAR 0 1
45210: PUSH
45211: LD_VAR 0 2
45215: PUSH
45216: LD_INT 3
45218: PLUS
45219: PUSH
45220: LD_INT 0
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: LIST
45227: PUSH
45228: LD_VAR 0 1
45232: PUSH
45233: LD_INT 4
45235: PLUS
45236: PUSH
45237: LD_VAR 0 2
45241: PUSH
45242: LD_INT 4
45244: PLUS
45245: PUSH
45246: LD_INT 5
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: LIST
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: ST_TO_ADDR
// end ; 2 :
45261: GO 45820
45263: LD_INT 2
45265: DOUBLE
45266: EQUAL
45267: IFTRUE 45271
45269: GO 45400
45271: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45272: LD_ADDR_VAR 0 5
45276: PUSH
45277: LD_VAR 0 1
45281: PUSH
45282: LD_VAR 0 2
45286: PUSH
45287: LD_INT 3
45289: MINUS
45290: PUSH
45291: LD_INT 3
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: LIST
45298: PUSH
45299: LD_VAR 0 1
45303: PUSH
45304: LD_INT 4
45306: PLUS
45307: PUSH
45308: LD_VAR 0 2
45312: PUSH
45313: LD_INT 4
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: LIST
45320: PUSH
45321: LD_VAR 0 1
45325: PUSH
45326: LD_VAR 0 2
45330: PUSH
45331: LD_INT 4
45333: PLUS
45334: PUSH
45335: LD_INT 0
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: LIST
45342: PUSH
45343: LD_VAR 0 1
45347: PUSH
45348: LD_INT 3
45350: MINUS
45351: PUSH
45352: LD_VAR 0 2
45356: PUSH
45357: LD_INT 1
45359: PUSH
45360: EMPTY
45361: LIST
45362: LIST
45363: LIST
45364: PUSH
45365: LD_VAR 0 1
45369: PUSH
45370: LD_INT 4
45372: MINUS
45373: PUSH
45374: LD_VAR 0 2
45378: PUSH
45379: LD_INT 4
45381: MINUS
45382: PUSH
45383: LD_INT 2
45385: PUSH
45386: EMPTY
45387: LIST
45388: LIST
45389: LIST
45390: PUSH
45391: EMPTY
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: ST_TO_ADDR
// end ; 3 :
45398: GO 45820
45400: LD_INT 3
45402: DOUBLE
45403: EQUAL
45404: IFTRUE 45408
45406: GO 45541
45408: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45409: LD_ADDR_VAR 0 5
45413: PUSH
45414: LD_VAR 0 1
45418: PUSH
45419: LD_INT 3
45421: PLUS
45422: PUSH
45423: LD_VAR 0 2
45427: PUSH
45428: LD_INT 4
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: LIST
45435: PUSH
45436: LD_VAR 0 1
45440: PUSH
45441: LD_INT 4
45443: PLUS
45444: PUSH
45445: LD_VAR 0 2
45449: PUSH
45450: LD_INT 4
45452: PLUS
45453: PUSH
45454: LD_INT 5
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: LIST
45461: PUSH
45462: LD_VAR 0 1
45466: PUSH
45467: LD_INT 4
45469: MINUS
45470: PUSH
45471: LD_VAR 0 2
45475: PUSH
45476: LD_INT 1
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: LIST
45483: PUSH
45484: LD_VAR 0 1
45488: PUSH
45489: LD_VAR 0 2
45493: PUSH
45494: LD_INT 4
45496: MINUS
45497: PUSH
45498: LD_INT 3
45500: PUSH
45501: EMPTY
45502: LIST
45503: LIST
45504: LIST
45505: PUSH
45506: LD_VAR 0 1
45510: PUSH
45511: LD_INT 3
45513: MINUS
45514: PUSH
45515: LD_VAR 0 2
45519: PUSH
45520: LD_INT 3
45522: MINUS
45523: PUSH
45524: LD_INT 2
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: LIST
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: ST_TO_ADDR
// end ; 4 :
45539: GO 45820
45541: LD_INT 4
45543: DOUBLE
45544: EQUAL
45545: IFTRUE 45549
45547: GO 45682
45549: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45550: LD_ADDR_VAR 0 5
45554: PUSH
45555: LD_VAR 0 1
45559: PUSH
45560: LD_VAR 0 2
45564: PUSH
45565: LD_INT 4
45567: PLUS
45568: PUSH
45569: LD_INT 0
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: LIST
45576: PUSH
45577: LD_VAR 0 1
45581: PUSH
45582: LD_INT 3
45584: PLUS
45585: PUSH
45586: LD_VAR 0 2
45590: PUSH
45591: LD_INT 3
45593: PLUS
45594: PUSH
45595: LD_INT 5
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: LIST
45602: PUSH
45603: LD_VAR 0 1
45607: PUSH
45608: LD_INT 4
45610: PLUS
45611: PUSH
45612: LD_VAR 0 2
45616: PUSH
45617: LD_INT 4
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: LIST
45624: PUSH
45625: LD_VAR 0 1
45629: PUSH
45630: LD_VAR 0 2
45634: PUSH
45635: LD_INT 3
45637: MINUS
45638: PUSH
45639: LD_INT 3
45641: PUSH
45642: EMPTY
45643: LIST
45644: LIST
45645: LIST
45646: PUSH
45647: LD_VAR 0 1
45651: PUSH
45652: LD_INT 4
45654: MINUS
45655: PUSH
45656: LD_VAR 0 2
45660: PUSH
45661: LD_INT 4
45663: MINUS
45664: PUSH
45665: LD_INT 2
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: LIST
45672: PUSH
45673: EMPTY
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: ST_TO_ADDR
// end ; 5 :
45680: GO 45820
45682: LD_INT 5
45684: DOUBLE
45685: EQUAL
45686: IFTRUE 45690
45688: GO 45819
45690: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45691: LD_ADDR_VAR 0 5
45695: PUSH
45696: LD_VAR 0 1
45700: PUSH
45701: LD_INT 4
45703: MINUS
45704: PUSH
45705: LD_VAR 0 2
45709: PUSH
45710: LD_INT 1
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: LIST
45717: PUSH
45718: LD_VAR 0 1
45722: PUSH
45723: LD_VAR 0 2
45727: PUSH
45728: LD_INT 4
45730: MINUS
45731: PUSH
45732: LD_INT 3
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: LIST
45739: PUSH
45740: LD_VAR 0 1
45744: PUSH
45745: LD_INT 4
45747: PLUS
45748: PUSH
45749: LD_VAR 0 2
45753: PUSH
45754: LD_INT 4
45756: PLUS
45757: PUSH
45758: LD_INT 5
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: LIST
45765: PUSH
45766: LD_VAR 0 1
45770: PUSH
45771: LD_INT 3
45773: PLUS
45774: PUSH
45775: LD_VAR 0 2
45779: PUSH
45780: LD_INT 4
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: LIST
45787: PUSH
45788: LD_VAR 0 1
45792: PUSH
45793: LD_VAR 0 2
45797: PUSH
45798: LD_INT 3
45800: PLUS
45801: PUSH
45802: LD_INT 0
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: LIST
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: LIST
45814: LIST
45815: LIST
45816: ST_TO_ADDR
// end ; end ;
45817: GO 45820
45819: POP
// result := list ;
45820: LD_ADDR_VAR 0 4
45824: PUSH
45825: LD_VAR 0 5
45829: ST_TO_ADDR
// end ;
45830: LD_VAR 0 4
45834: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45835: LD_INT 0
45837: PPUSH
45838: PPUSH
45839: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45840: LD_VAR 0 1
45844: NOT
45845: PUSH
45846: LD_VAR 0 2
45850: PUSH
45851: LD_INT 1
45853: PUSH
45854: LD_INT 2
45856: PUSH
45857: LD_INT 3
45859: PUSH
45860: LD_INT 4
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: IN
45869: NOT
45870: OR
45871: IFFALSE 45875
// exit ;
45873: GO 45958
// tmp := [ ] ;
45875: LD_ADDR_VAR 0 5
45879: PUSH
45880: EMPTY
45881: ST_TO_ADDR
// for i in units do
45882: LD_ADDR_VAR 0 4
45886: PUSH
45887: LD_VAR 0 1
45891: PUSH
45892: FOR_IN
45893: IFFALSE 45927
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
45895: LD_ADDR_VAR 0 5
45899: PUSH
45900: LD_VAR 0 5
45904: PPUSH
45905: LD_VAR 0 4
45909: PPUSH
45910: LD_VAR 0 2
45914: PPUSH
45915: CALL_OW 259
45919: PPUSH
45920: CALL 47319 0 2
45924: ST_TO_ADDR
45925: GO 45892
45927: POP
45928: POP
// if not tmp then
45929: LD_VAR 0 5
45933: NOT
45934: IFFALSE 45938
// exit ;
45936: GO 45958
// result := SortListByListDesc ( units , tmp ) ;
45938: LD_ADDR_VAR 0 3
45942: PUSH
45943: LD_VAR 0 1
45947: PPUSH
45948: LD_VAR 0 5
45952: PPUSH
45953: CALL_OW 77
45957: ST_TO_ADDR
// end ;
45958: LD_VAR 0 3
45962: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45963: LD_INT 0
45965: PPUSH
45966: PPUSH
45967: PPUSH
// result := false ;
45968: LD_ADDR_VAR 0 3
45972: PUSH
45973: LD_INT 0
45975: ST_TO_ADDR
// if not building then
45976: LD_VAR 0 2
45980: NOT
45981: IFFALSE 45985
// exit ;
45983: GO 46123
// x := GetX ( building ) ;
45985: LD_ADDR_VAR 0 4
45989: PUSH
45990: LD_VAR 0 2
45994: PPUSH
45995: CALL_OW 250
45999: ST_TO_ADDR
// y := GetY ( building ) ;
46000: LD_ADDR_VAR 0 5
46004: PUSH
46005: LD_VAR 0 2
46009: PPUSH
46010: CALL_OW 251
46014: ST_TO_ADDR
// if not x or not y then
46015: LD_VAR 0 4
46019: NOT
46020: PUSH
46021: LD_VAR 0 5
46025: NOT
46026: OR
46027: IFFALSE 46031
// exit ;
46029: GO 46123
// if GetTaskList ( unit ) then
46031: LD_VAR 0 1
46035: PPUSH
46036: CALL_OW 437
46040: IFFALSE 46123
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46042: LD_STRING e
46044: PUSH
46045: LD_VAR 0 1
46049: PPUSH
46050: CALL_OW 437
46054: PUSH
46055: LD_INT 1
46057: ARRAY
46058: PUSH
46059: LD_INT 1
46061: ARRAY
46062: EQUAL
46063: PUSH
46064: LD_VAR 0 4
46068: PUSH
46069: LD_VAR 0 1
46073: PPUSH
46074: CALL_OW 437
46078: PUSH
46079: LD_INT 1
46081: ARRAY
46082: PUSH
46083: LD_INT 2
46085: ARRAY
46086: EQUAL
46087: AND
46088: PUSH
46089: LD_VAR 0 5
46093: PUSH
46094: LD_VAR 0 1
46098: PPUSH
46099: CALL_OW 437
46103: PUSH
46104: LD_INT 1
46106: ARRAY
46107: PUSH
46108: LD_INT 3
46110: ARRAY
46111: EQUAL
46112: AND
46113: IFFALSE 46123
// result := true end ;
46115: LD_ADDR_VAR 0 3
46119: PUSH
46120: LD_INT 1
46122: ST_TO_ADDR
// end ;
46123: LD_VAR 0 3
46127: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46128: LD_INT 0
46130: PPUSH
// result := false ;
46131: LD_ADDR_VAR 0 4
46135: PUSH
46136: LD_INT 0
46138: ST_TO_ADDR
// if GetTaskList ( unit ) then
46139: LD_VAR 0 1
46143: PPUSH
46144: CALL_OW 437
46148: IFFALSE 46231
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46150: LD_STRING M
46152: PUSH
46153: LD_VAR 0 1
46157: PPUSH
46158: CALL_OW 437
46162: PUSH
46163: LD_INT 1
46165: ARRAY
46166: PUSH
46167: LD_INT 1
46169: ARRAY
46170: EQUAL
46171: PUSH
46172: LD_VAR 0 2
46176: PUSH
46177: LD_VAR 0 1
46181: PPUSH
46182: CALL_OW 437
46186: PUSH
46187: LD_INT 1
46189: ARRAY
46190: PUSH
46191: LD_INT 2
46193: ARRAY
46194: EQUAL
46195: AND
46196: PUSH
46197: LD_VAR 0 3
46201: PUSH
46202: LD_VAR 0 1
46206: PPUSH
46207: CALL_OW 437
46211: PUSH
46212: LD_INT 1
46214: ARRAY
46215: PUSH
46216: LD_INT 3
46218: ARRAY
46219: EQUAL
46220: AND
46221: IFFALSE 46231
// result := true ;
46223: LD_ADDR_VAR 0 4
46227: PUSH
46228: LD_INT 1
46230: ST_TO_ADDR
// end ; end ;
46231: LD_VAR 0 4
46235: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46236: LD_INT 0
46238: PPUSH
46239: PPUSH
46240: PPUSH
46241: PPUSH
// if not unit or not area then
46242: LD_VAR 0 1
46246: NOT
46247: PUSH
46248: LD_VAR 0 2
46252: NOT
46253: OR
46254: IFFALSE 46258
// exit ;
46256: GO 46422
// tmp := AreaToList ( area , i ) ;
46258: LD_ADDR_VAR 0 6
46262: PUSH
46263: LD_VAR 0 2
46267: PPUSH
46268: LD_VAR 0 5
46272: PPUSH
46273: CALL_OW 517
46277: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46278: LD_ADDR_VAR 0 5
46282: PUSH
46283: DOUBLE
46284: LD_INT 1
46286: DEC
46287: ST_TO_ADDR
46288: LD_VAR 0 6
46292: PUSH
46293: LD_INT 1
46295: ARRAY
46296: PUSH
46297: FOR_TO
46298: IFFALSE 46420
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46300: LD_ADDR_VAR 0 7
46304: PUSH
46305: LD_VAR 0 6
46309: PUSH
46310: LD_INT 1
46312: ARRAY
46313: PUSH
46314: LD_VAR 0 5
46318: ARRAY
46319: PUSH
46320: LD_VAR 0 6
46324: PUSH
46325: LD_INT 2
46327: ARRAY
46328: PUSH
46329: LD_VAR 0 5
46333: ARRAY
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46339: LD_VAR 0 7
46343: PUSH
46344: LD_INT 1
46346: ARRAY
46347: PPUSH
46348: LD_VAR 0 7
46352: PUSH
46353: LD_INT 2
46355: ARRAY
46356: PPUSH
46357: CALL_OW 428
46361: PUSH
46362: LD_INT 0
46364: EQUAL
46365: IFFALSE 46418
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46367: LD_VAR 0 1
46371: PPUSH
46372: LD_VAR 0 7
46376: PUSH
46377: LD_INT 1
46379: ARRAY
46380: PPUSH
46381: LD_VAR 0 7
46385: PUSH
46386: LD_INT 2
46388: ARRAY
46389: PPUSH
46390: LD_VAR 0 3
46394: PPUSH
46395: CALL_OW 48
// result := IsPlaced ( unit ) ;
46399: LD_ADDR_VAR 0 4
46403: PUSH
46404: LD_VAR 0 1
46408: PPUSH
46409: CALL_OW 305
46413: ST_TO_ADDR
// exit ;
46414: POP
46415: POP
46416: GO 46422
// end ; end ;
46418: GO 46297
46420: POP
46421: POP
// end ;
46422: LD_VAR 0 4
46426: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46427: LD_INT 0
46429: PPUSH
46430: PPUSH
46431: PPUSH
// if not side or side > 8 then
46432: LD_VAR 0 1
46436: NOT
46437: PUSH
46438: LD_VAR 0 1
46442: PUSH
46443: LD_INT 8
46445: GREATER
46446: OR
46447: IFFALSE 46451
// exit ;
46449: GO 46638
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46451: LD_ADDR_VAR 0 4
46455: PUSH
46456: LD_INT 22
46458: PUSH
46459: LD_VAR 0 1
46463: PUSH
46464: EMPTY
46465: LIST
46466: LIST
46467: PUSH
46468: LD_INT 21
46470: PUSH
46471: LD_INT 3
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: PPUSH
46482: CALL_OW 69
46486: ST_TO_ADDR
// if not tmp then
46487: LD_VAR 0 4
46491: NOT
46492: IFFALSE 46496
// exit ;
46494: GO 46638
// enable_addtolog := true ;
46496: LD_ADDR_OWVAR 81
46500: PUSH
46501: LD_INT 1
46503: ST_TO_ADDR
// AddToLog ( [ ) ;
46504: LD_STRING [
46506: PPUSH
46507: CALL_OW 561
// for i in tmp do
46511: LD_ADDR_VAR 0 3
46515: PUSH
46516: LD_VAR 0 4
46520: PUSH
46521: FOR_IN
46522: IFFALSE 46629
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46524: LD_STRING [
46526: PUSH
46527: LD_VAR 0 3
46531: PPUSH
46532: CALL_OW 266
46536: STR
46537: PUSH
46538: LD_STRING , 
46540: STR
46541: PUSH
46542: LD_VAR 0 3
46546: PPUSH
46547: CALL_OW 250
46551: STR
46552: PUSH
46553: LD_STRING , 
46555: STR
46556: PUSH
46557: LD_VAR 0 3
46561: PPUSH
46562: CALL_OW 251
46566: STR
46567: PUSH
46568: LD_STRING , 
46570: STR
46571: PUSH
46572: LD_VAR 0 3
46576: PPUSH
46577: CALL_OW 254
46581: STR
46582: PUSH
46583: LD_STRING , 
46585: STR
46586: PUSH
46587: LD_VAR 0 3
46591: PPUSH
46592: LD_INT 1
46594: PPUSH
46595: CALL_OW 268
46599: STR
46600: PUSH
46601: LD_STRING , 
46603: STR
46604: PUSH
46605: LD_VAR 0 3
46609: PPUSH
46610: LD_INT 2
46612: PPUSH
46613: CALL_OW 268
46617: STR
46618: PUSH
46619: LD_STRING ],
46621: STR
46622: PPUSH
46623: CALL_OW 561
// end ;
46627: GO 46521
46629: POP
46630: POP
// AddToLog ( ]; ) ;
46631: LD_STRING ];
46633: PPUSH
46634: CALL_OW 561
// end ;
46638: LD_VAR 0 2
46642: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46643: LD_INT 0
46645: PPUSH
46646: PPUSH
46647: PPUSH
46648: PPUSH
46649: PPUSH
// if not area or not rate or not max then
46650: LD_VAR 0 1
46654: NOT
46655: PUSH
46656: LD_VAR 0 2
46660: NOT
46661: OR
46662: PUSH
46663: LD_VAR 0 4
46667: NOT
46668: OR
46669: IFFALSE 46673
// exit ;
46671: GO 46862
// while 1 do
46673: LD_INT 1
46675: IFFALSE 46862
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46677: LD_ADDR_VAR 0 9
46681: PUSH
46682: LD_VAR 0 1
46686: PPUSH
46687: LD_INT 1
46689: PPUSH
46690: CALL_OW 287
46694: PUSH
46695: LD_INT 10
46697: MUL
46698: ST_TO_ADDR
// r := rate / 10 ;
46699: LD_ADDR_VAR 0 7
46703: PUSH
46704: LD_VAR 0 2
46708: PUSH
46709: LD_INT 10
46711: DIVREAL
46712: ST_TO_ADDR
// time := 1 1$00 ;
46713: LD_ADDR_VAR 0 8
46717: PUSH
46718: LD_INT 2100
46720: ST_TO_ADDR
// if amount < min then
46721: LD_VAR 0 9
46725: PUSH
46726: LD_VAR 0 3
46730: LESS
46731: IFFALSE 46749
// r := r * 2 else
46733: LD_ADDR_VAR 0 7
46737: PUSH
46738: LD_VAR 0 7
46742: PUSH
46743: LD_INT 2
46745: MUL
46746: ST_TO_ADDR
46747: GO 46775
// if amount > max then
46749: LD_VAR 0 9
46753: PUSH
46754: LD_VAR 0 4
46758: GREATER
46759: IFFALSE 46775
// r := r / 2 ;
46761: LD_ADDR_VAR 0 7
46765: PUSH
46766: LD_VAR 0 7
46770: PUSH
46771: LD_INT 2
46773: DIVREAL
46774: ST_TO_ADDR
// time := time / r ;
46775: LD_ADDR_VAR 0 8
46779: PUSH
46780: LD_VAR 0 8
46784: PUSH
46785: LD_VAR 0 7
46789: DIVREAL
46790: ST_TO_ADDR
// if time < 0 then
46791: LD_VAR 0 8
46795: PUSH
46796: LD_INT 0
46798: LESS
46799: IFFALSE 46816
// time := time * - 1 ;
46801: LD_ADDR_VAR 0 8
46805: PUSH
46806: LD_VAR 0 8
46810: PUSH
46811: LD_INT 1
46813: NEG
46814: MUL
46815: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
46816: LD_VAR 0 8
46820: PUSH
46821: LD_INT 35
46823: PPUSH
46824: LD_INT 875
46826: PPUSH
46827: CALL_OW 12
46831: PLUS
46832: PPUSH
46833: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46837: LD_INT 1
46839: PPUSH
46840: LD_INT 5
46842: PPUSH
46843: CALL_OW 12
46847: PPUSH
46848: LD_VAR 0 1
46852: PPUSH
46853: LD_INT 1
46855: PPUSH
46856: CALL_OW 55
// end ;
46860: GO 46673
// end ;
46862: LD_VAR 0 5
46866: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46867: LD_INT 0
46869: PPUSH
46870: PPUSH
46871: PPUSH
46872: PPUSH
46873: PPUSH
46874: PPUSH
46875: PPUSH
46876: PPUSH
// if not turrets or not factories then
46877: LD_VAR 0 1
46881: NOT
46882: PUSH
46883: LD_VAR 0 2
46887: NOT
46888: OR
46889: IFFALSE 46893
// exit ;
46891: GO 47200
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46893: LD_ADDR_VAR 0 10
46897: PUSH
46898: LD_INT 5
46900: PUSH
46901: LD_INT 6
46903: PUSH
46904: EMPTY
46905: LIST
46906: LIST
46907: PUSH
46908: LD_INT 2
46910: PUSH
46911: LD_INT 4
46913: PUSH
46914: EMPTY
46915: LIST
46916: LIST
46917: PUSH
46918: LD_INT 3
46920: PUSH
46921: LD_INT 5
46923: PUSH
46924: EMPTY
46925: LIST
46926: LIST
46927: PUSH
46928: EMPTY
46929: LIST
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 24
46935: PUSH
46936: LD_INT 25
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: PUSH
46943: LD_INT 23
46945: PUSH
46946: LD_INT 27
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PUSH
46957: LD_INT 42
46959: PUSH
46960: LD_INT 43
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: PUSH
46967: LD_INT 44
46969: PUSH
46970: LD_INT 46
46972: PUSH
46973: EMPTY
46974: LIST
46975: LIST
46976: PUSH
46977: LD_INT 45
46979: PUSH
46980: LD_INT 47
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: EMPTY
46988: LIST
46989: LIST
46990: LIST
46991: PUSH
46992: EMPTY
46993: LIST
46994: LIST
46995: LIST
46996: ST_TO_ADDR
// result := [ ] ;
46997: LD_ADDR_VAR 0 3
47001: PUSH
47002: EMPTY
47003: ST_TO_ADDR
// for i in turrets do
47004: LD_ADDR_VAR 0 4
47008: PUSH
47009: LD_VAR 0 1
47013: PUSH
47014: FOR_IN
47015: IFFALSE 47198
// begin nat := GetNation ( i ) ;
47017: LD_ADDR_VAR 0 7
47021: PUSH
47022: LD_VAR 0 4
47026: PPUSH
47027: CALL_OW 248
47031: ST_TO_ADDR
// weapon := 0 ;
47032: LD_ADDR_VAR 0 8
47036: PUSH
47037: LD_INT 0
47039: ST_TO_ADDR
// if not nat then
47040: LD_VAR 0 7
47044: NOT
47045: IFFALSE 47049
// continue ;
47047: GO 47014
// for j in list [ nat ] do
47049: LD_ADDR_VAR 0 5
47053: PUSH
47054: LD_VAR 0 10
47058: PUSH
47059: LD_VAR 0 7
47063: ARRAY
47064: PUSH
47065: FOR_IN
47066: IFFALSE 47107
// if GetBWeapon ( i ) = j [ 1 ] then
47068: LD_VAR 0 4
47072: PPUSH
47073: CALL_OW 269
47077: PUSH
47078: LD_VAR 0 5
47082: PUSH
47083: LD_INT 1
47085: ARRAY
47086: EQUAL
47087: IFFALSE 47105
// begin weapon := j [ 2 ] ;
47089: LD_ADDR_VAR 0 8
47093: PUSH
47094: LD_VAR 0 5
47098: PUSH
47099: LD_INT 2
47101: ARRAY
47102: ST_TO_ADDR
// break ;
47103: GO 47107
// end ;
47105: GO 47065
47107: POP
47108: POP
// if not weapon then
47109: LD_VAR 0 8
47113: NOT
47114: IFFALSE 47118
// continue ;
47116: GO 47014
// for k in factories do
47118: LD_ADDR_VAR 0 6
47122: PUSH
47123: LD_VAR 0 2
47127: PUSH
47128: FOR_IN
47129: IFFALSE 47194
// begin weapons := AvailableWeaponList ( k ) ;
47131: LD_ADDR_VAR 0 9
47135: PUSH
47136: LD_VAR 0 6
47140: PPUSH
47141: CALL_OW 478
47145: ST_TO_ADDR
// if not weapons then
47146: LD_VAR 0 9
47150: NOT
47151: IFFALSE 47155
// continue ;
47153: GO 47128
// if weapon in weapons then
47155: LD_VAR 0 8
47159: PUSH
47160: LD_VAR 0 9
47164: IN
47165: IFFALSE 47192
// begin result := [ i , weapon ] ;
47167: LD_ADDR_VAR 0 3
47171: PUSH
47172: LD_VAR 0 4
47176: PUSH
47177: LD_VAR 0 8
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: ST_TO_ADDR
// exit ;
47186: POP
47187: POP
47188: POP
47189: POP
47190: GO 47200
// end ; end ;
47192: GO 47128
47194: POP
47195: POP
// end ;
47196: GO 47014
47198: POP
47199: POP
// end ;
47200: LD_VAR 0 3
47204: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47205: LD_INT 0
47207: PPUSH
// if not side or side > 8 then
47208: LD_VAR 0 3
47212: NOT
47213: PUSH
47214: LD_VAR 0 3
47218: PUSH
47219: LD_INT 8
47221: GREATER
47222: OR
47223: IFFALSE 47227
// exit ;
47225: GO 47286
// if not range then
47227: LD_VAR 0 4
47231: NOT
47232: IFFALSE 47243
// range := - 12 ;
47234: LD_ADDR_VAR 0 4
47238: PUSH
47239: LD_INT 12
47241: NEG
47242: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47243: LD_VAR 0 1
47247: PPUSH
47248: LD_VAR 0 2
47252: PPUSH
47253: LD_VAR 0 3
47257: PPUSH
47258: LD_VAR 0 4
47262: PPUSH
47263: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47267: LD_VAR 0 1
47271: PPUSH
47272: LD_VAR 0 2
47276: PPUSH
47277: LD_VAR 0 3
47281: PPUSH
47282: CALL_OW 331
// end ;
47286: LD_VAR 0 5
47290: RET
// export function Video ( mode ) ; begin
47291: LD_INT 0
47293: PPUSH
// ingame_video = mode ;
47294: LD_ADDR_OWVAR 52
47298: PUSH
47299: LD_VAR 0 1
47303: ST_TO_ADDR
// interface_hidden = mode ;
47304: LD_ADDR_OWVAR 54
47308: PUSH
47309: LD_VAR 0 1
47313: ST_TO_ADDR
// end ;
47314: LD_VAR 0 2
47318: RET
// export function Join ( array , element ) ; begin
47319: LD_INT 0
47321: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47322: LD_ADDR_VAR 0 3
47326: PUSH
47327: LD_VAR 0 1
47331: PPUSH
47332: LD_VAR 0 1
47336: PUSH
47337: LD_INT 1
47339: PLUS
47340: PPUSH
47341: LD_VAR 0 2
47345: PPUSH
47346: CALL_OW 1
47350: ST_TO_ADDR
// end ;
47351: LD_VAR 0 3
47355: RET
// export function JoinUnion ( array , element ) ; begin
47356: LD_INT 0
47358: PPUSH
// result := array union element ;
47359: LD_ADDR_VAR 0 3
47363: PUSH
47364: LD_VAR 0 1
47368: PUSH
47369: LD_VAR 0 2
47373: UNION
47374: ST_TO_ADDR
// end ;
47375: LD_VAR 0 3
47379: RET
// export function GetBehemoths ( side ) ; begin
47380: LD_INT 0
47382: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
47383: LD_ADDR_VAR 0 2
47387: PUSH
47388: LD_INT 22
47390: PUSH
47391: LD_VAR 0 1
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: PUSH
47400: LD_INT 31
47402: PUSH
47403: LD_INT 25
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: EMPTY
47411: LIST
47412: LIST
47413: PPUSH
47414: CALL_OW 69
47418: ST_TO_ADDR
// end ;
47419: LD_VAR 0 2
47423: RET
// export function Shuffle ( array ) ; var i , index ; begin
47424: LD_INT 0
47426: PPUSH
47427: PPUSH
47428: PPUSH
// result := [ ] ;
47429: LD_ADDR_VAR 0 2
47433: PUSH
47434: EMPTY
47435: ST_TO_ADDR
// if not array then
47436: LD_VAR 0 1
47440: NOT
47441: IFFALSE 47445
// exit ;
47443: GO 47544
// Randomize ;
47445: CALL_OW 10
// for i = array downto 1 do
47449: LD_ADDR_VAR 0 3
47453: PUSH
47454: DOUBLE
47455: LD_VAR 0 1
47459: INC
47460: ST_TO_ADDR
47461: LD_INT 1
47463: PUSH
47464: FOR_DOWNTO
47465: IFFALSE 47542
// begin index := rand ( 1 , array ) ;
47467: LD_ADDR_VAR 0 4
47471: PUSH
47472: LD_INT 1
47474: PPUSH
47475: LD_VAR 0 1
47479: PPUSH
47480: CALL_OW 12
47484: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47485: LD_ADDR_VAR 0 2
47489: PUSH
47490: LD_VAR 0 2
47494: PPUSH
47495: LD_VAR 0 2
47499: PUSH
47500: LD_INT 1
47502: PLUS
47503: PPUSH
47504: LD_VAR 0 1
47508: PUSH
47509: LD_VAR 0 4
47513: ARRAY
47514: PPUSH
47515: CALL_OW 2
47519: ST_TO_ADDR
// array := Delete ( array , index ) ;
47520: LD_ADDR_VAR 0 1
47524: PUSH
47525: LD_VAR 0 1
47529: PPUSH
47530: LD_VAR 0 4
47534: PPUSH
47535: CALL_OW 3
47539: ST_TO_ADDR
// end ;
47540: GO 47464
47542: POP
47543: POP
// end ;
47544: LD_VAR 0 2
47548: RET
// export function GetBaseMaterials ( base ) ; begin
47549: LD_INT 0
47551: PPUSH
// result := [ 0 , 0 , 0 ] ;
47552: LD_ADDR_VAR 0 2
47556: PUSH
47557: LD_INT 0
47559: PUSH
47560: LD_INT 0
47562: PUSH
47563: LD_INT 0
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: LIST
47570: ST_TO_ADDR
// if not base then
47571: LD_VAR 0 1
47575: NOT
47576: IFFALSE 47580
// exit ;
47578: GO 47629
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47580: LD_ADDR_VAR 0 2
47584: PUSH
47585: LD_VAR 0 1
47589: PPUSH
47590: LD_INT 1
47592: PPUSH
47593: CALL_OW 275
47597: PUSH
47598: LD_VAR 0 1
47602: PPUSH
47603: LD_INT 2
47605: PPUSH
47606: CALL_OW 275
47610: PUSH
47611: LD_VAR 0 1
47615: PPUSH
47616: LD_INT 3
47618: PPUSH
47619: CALL_OW 275
47623: PUSH
47624: EMPTY
47625: LIST
47626: LIST
47627: LIST
47628: ST_TO_ADDR
// end ;
47629: LD_VAR 0 2
47633: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47634: LD_INT 0
47636: PPUSH
47637: PPUSH
// result := array ;
47638: LD_ADDR_VAR 0 3
47642: PUSH
47643: LD_VAR 0 1
47647: ST_TO_ADDR
// if size >= result then
47648: LD_VAR 0 2
47652: PUSH
47653: LD_VAR 0 3
47657: GREATEREQUAL
47658: IFFALSE 47662
// exit ;
47660: GO 47712
// if size then
47662: LD_VAR 0 2
47666: IFFALSE 47712
// for i := array downto size do
47668: LD_ADDR_VAR 0 4
47672: PUSH
47673: DOUBLE
47674: LD_VAR 0 1
47678: INC
47679: ST_TO_ADDR
47680: LD_VAR 0 2
47684: PUSH
47685: FOR_DOWNTO
47686: IFFALSE 47710
// result := Delete ( result , result ) ;
47688: LD_ADDR_VAR 0 3
47692: PUSH
47693: LD_VAR 0 3
47697: PPUSH
47698: LD_VAR 0 3
47702: PPUSH
47703: CALL_OW 3
47707: ST_TO_ADDR
47708: GO 47685
47710: POP
47711: POP
// end ;
47712: LD_VAR 0 3
47716: RET
// export function ComExit ( unit ) ; var tmp ; begin
47717: LD_INT 0
47719: PPUSH
47720: PPUSH
// if not IsInUnit ( unit ) then
47721: LD_VAR 0 1
47725: PPUSH
47726: CALL_OW 310
47730: NOT
47731: IFFALSE 47735
// exit ;
47733: GO 47795
// tmp := IsInUnit ( unit ) ;
47735: LD_ADDR_VAR 0 3
47739: PUSH
47740: LD_VAR 0 1
47744: PPUSH
47745: CALL_OW 310
47749: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47750: LD_VAR 0 3
47754: PPUSH
47755: CALL_OW 247
47759: PUSH
47760: LD_INT 2
47762: EQUAL
47763: IFFALSE 47776
// ComExitVehicle ( unit ) else
47765: LD_VAR 0 1
47769: PPUSH
47770: CALL_OW 121
47774: GO 47785
// ComExitBuilding ( unit ) ;
47776: LD_VAR 0 1
47780: PPUSH
47781: CALL_OW 122
// result := tmp ;
47785: LD_ADDR_VAR 0 2
47789: PUSH
47790: LD_VAR 0 3
47794: ST_TO_ADDR
// end ;
47795: LD_VAR 0 2
47799: RET
// export function ComExitAll ( units ) ; var i ; begin
47800: LD_INT 0
47802: PPUSH
47803: PPUSH
// if not units then
47804: LD_VAR 0 1
47808: NOT
47809: IFFALSE 47813
// exit ;
47811: GO 47839
// for i in units do
47813: LD_ADDR_VAR 0 3
47817: PUSH
47818: LD_VAR 0 1
47822: PUSH
47823: FOR_IN
47824: IFFALSE 47837
// ComExit ( i ) ;
47826: LD_VAR 0 3
47830: PPUSH
47831: CALL 47717 0 1
47835: GO 47823
47837: POP
47838: POP
// end ;
47839: LD_VAR 0 2
47843: RET
// export function ResetHc ; begin
47844: LD_INT 0
47846: PPUSH
// InitHc ;
47847: CALL_OW 19
// hc_importance := 0 ;
47851: LD_ADDR_OWVAR 32
47855: PUSH
47856: LD_INT 0
47858: ST_TO_ADDR
// end ;
47859: LD_VAR 0 1
47863: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47864: LD_INT 0
47866: PPUSH
47867: PPUSH
47868: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47869: LD_ADDR_VAR 0 6
47873: PUSH
47874: LD_VAR 0 1
47878: PUSH
47879: LD_VAR 0 3
47883: PLUS
47884: PUSH
47885: LD_INT 2
47887: DIV
47888: ST_TO_ADDR
// if _x < 0 then
47889: LD_VAR 0 6
47893: PUSH
47894: LD_INT 0
47896: LESS
47897: IFFALSE 47914
// _x := _x * - 1 ;
47899: LD_ADDR_VAR 0 6
47903: PUSH
47904: LD_VAR 0 6
47908: PUSH
47909: LD_INT 1
47911: NEG
47912: MUL
47913: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47914: LD_ADDR_VAR 0 7
47918: PUSH
47919: LD_VAR 0 2
47923: PUSH
47924: LD_VAR 0 4
47928: PLUS
47929: PUSH
47930: LD_INT 2
47932: DIV
47933: ST_TO_ADDR
// if _y < 0 then
47934: LD_VAR 0 7
47938: PUSH
47939: LD_INT 0
47941: LESS
47942: IFFALSE 47959
// _y := _y * - 1 ;
47944: LD_ADDR_VAR 0 7
47948: PUSH
47949: LD_VAR 0 7
47953: PUSH
47954: LD_INT 1
47956: NEG
47957: MUL
47958: ST_TO_ADDR
// result := [ _x , _y ] ;
47959: LD_ADDR_VAR 0 5
47963: PUSH
47964: LD_VAR 0 6
47968: PUSH
47969: LD_VAR 0 7
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: ST_TO_ADDR
// end ;
47978: LD_VAR 0 5
47982: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47983: LD_INT 0
47985: PPUSH
47986: PPUSH
47987: PPUSH
47988: PPUSH
// task := GetTaskList ( unit ) ;
47989: LD_ADDR_VAR 0 7
47993: PUSH
47994: LD_VAR 0 1
47998: PPUSH
47999: CALL_OW 437
48003: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
48004: LD_VAR 0 7
48008: NOT
48009: PUSH
48010: LD_VAR 0 1
48014: PPUSH
48015: LD_VAR 0 2
48019: PPUSH
48020: CALL_OW 308
48024: NOT
48025: AND
48026: IFFALSE 48030
// exit ;
48028: GO 48148
// if IsInArea ( unit , area ) then
48030: LD_VAR 0 1
48034: PPUSH
48035: LD_VAR 0 2
48039: PPUSH
48040: CALL_OW 308
48044: IFFALSE 48062
// begin ComMoveToArea ( unit , goAway ) ;
48046: LD_VAR 0 1
48050: PPUSH
48051: LD_VAR 0 3
48055: PPUSH
48056: CALL_OW 113
// exit ;
48060: GO 48148
// end ; if task [ 1 ] [ 1 ] <> M then
48062: LD_VAR 0 7
48066: PUSH
48067: LD_INT 1
48069: ARRAY
48070: PUSH
48071: LD_INT 1
48073: ARRAY
48074: PUSH
48075: LD_STRING M
48077: NONEQUAL
48078: IFFALSE 48082
// exit ;
48080: GO 48148
// x := task [ 1 ] [ 2 ] ;
48082: LD_ADDR_VAR 0 5
48086: PUSH
48087: LD_VAR 0 7
48091: PUSH
48092: LD_INT 1
48094: ARRAY
48095: PUSH
48096: LD_INT 2
48098: ARRAY
48099: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48100: LD_ADDR_VAR 0 6
48104: PUSH
48105: LD_VAR 0 7
48109: PUSH
48110: LD_INT 1
48112: ARRAY
48113: PUSH
48114: LD_INT 3
48116: ARRAY
48117: ST_TO_ADDR
// if InArea ( x , y , area ) then
48118: LD_VAR 0 5
48122: PPUSH
48123: LD_VAR 0 6
48127: PPUSH
48128: LD_VAR 0 2
48132: PPUSH
48133: CALL_OW 309
48137: IFFALSE 48148
// ComStop ( unit ) ;
48139: LD_VAR 0 1
48143: PPUSH
48144: CALL_OW 141
// end ;
48148: LD_VAR 0 4
48152: RET
// export function Abs ( value ) ; begin
48153: LD_INT 0
48155: PPUSH
// result := value ;
48156: LD_ADDR_VAR 0 2
48160: PUSH
48161: LD_VAR 0 1
48165: ST_TO_ADDR
// if value < 0 then
48166: LD_VAR 0 1
48170: PUSH
48171: LD_INT 0
48173: LESS
48174: IFFALSE 48191
// result := value * - 1 ;
48176: LD_ADDR_VAR 0 2
48180: PUSH
48181: LD_VAR 0 1
48185: PUSH
48186: LD_INT 1
48188: NEG
48189: MUL
48190: ST_TO_ADDR
// end ;
48191: LD_VAR 0 2
48195: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48196: LD_INT 0
48198: PPUSH
48199: PPUSH
48200: PPUSH
48201: PPUSH
48202: PPUSH
48203: PPUSH
48204: PPUSH
48205: PPUSH
// if not unit or not building then
48206: LD_VAR 0 1
48210: NOT
48211: PUSH
48212: LD_VAR 0 2
48216: NOT
48217: OR
48218: IFFALSE 48222
// exit ;
48220: GO 48448
// x := GetX ( building ) ;
48222: LD_ADDR_VAR 0 4
48226: PUSH
48227: LD_VAR 0 2
48231: PPUSH
48232: CALL_OW 250
48236: ST_TO_ADDR
// y := GetY ( building ) ;
48237: LD_ADDR_VAR 0 6
48241: PUSH
48242: LD_VAR 0 2
48246: PPUSH
48247: CALL_OW 251
48251: ST_TO_ADDR
// d := GetDir ( building ) ;
48252: LD_ADDR_VAR 0 8
48256: PUSH
48257: LD_VAR 0 2
48261: PPUSH
48262: CALL_OW 254
48266: ST_TO_ADDR
// r := 4 ;
48267: LD_ADDR_VAR 0 9
48271: PUSH
48272: LD_INT 4
48274: ST_TO_ADDR
// for i := 1 to 5 do
48275: LD_ADDR_VAR 0 10
48279: PUSH
48280: DOUBLE
48281: LD_INT 1
48283: DEC
48284: ST_TO_ADDR
48285: LD_INT 5
48287: PUSH
48288: FOR_TO
48289: IFFALSE 48446
// begin _x := ShiftX ( x , d , r + i ) ;
48291: LD_ADDR_VAR 0 5
48295: PUSH
48296: LD_VAR 0 4
48300: PPUSH
48301: LD_VAR 0 8
48305: PPUSH
48306: LD_VAR 0 9
48310: PUSH
48311: LD_VAR 0 10
48315: PLUS
48316: PPUSH
48317: CALL_OW 272
48321: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48322: LD_ADDR_VAR 0 7
48326: PUSH
48327: LD_VAR 0 6
48331: PPUSH
48332: LD_VAR 0 8
48336: PPUSH
48337: LD_VAR 0 9
48341: PUSH
48342: LD_VAR 0 10
48346: PLUS
48347: PPUSH
48348: CALL_OW 273
48352: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48353: LD_VAR 0 5
48357: PPUSH
48358: LD_VAR 0 7
48362: PPUSH
48363: CALL_OW 488
48367: PUSH
48368: LD_VAR 0 5
48372: PPUSH
48373: LD_VAR 0 7
48377: PPUSH
48378: CALL_OW 428
48382: PPUSH
48383: CALL_OW 247
48387: PUSH
48388: LD_INT 3
48390: PUSH
48391: LD_INT 2
48393: PUSH
48394: EMPTY
48395: LIST
48396: LIST
48397: IN
48398: NOT
48399: AND
48400: IFFALSE 48444
// begin ComMoveXY ( unit , _x , _y ) ;
48402: LD_VAR 0 1
48406: PPUSH
48407: LD_VAR 0 5
48411: PPUSH
48412: LD_VAR 0 7
48416: PPUSH
48417: CALL_OW 111
// result := [ _x , _y ] ;
48421: LD_ADDR_VAR 0 3
48425: PUSH
48426: LD_VAR 0 5
48430: PUSH
48431: LD_VAR 0 7
48435: PUSH
48436: EMPTY
48437: LIST
48438: LIST
48439: ST_TO_ADDR
// exit ;
48440: POP
48441: POP
48442: GO 48448
// end ; end ;
48444: GO 48288
48446: POP
48447: POP
// end ;
48448: LD_VAR 0 3
48452: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48453: LD_INT 0
48455: PPUSH
48456: PPUSH
48457: PPUSH
// result := 0 ;
48458: LD_ADDR_VAR 0 3
48462: PUSH
48463: LD_INT 0
48465: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48466: LD_VAR 0 1
48470: PUSH
48471: LD_INT 0
48473: LESS
48474: PUSH
48475: LD_VAR 0 1
48479: PUSH
48480: LD_INT 8
48482: GREATER
48483: OR
48484: PUSH
48485: LD_VAR 0 2
48489: PUSH
48490: LD_INT 0
48492: LESS
48493: OR
48494: PUSH
48495: LD_VAR 0 2
48499: PUSH
48500: LD_INT 8
48502: GREATER
48503: OR
48504: IFFALSE 48508
// exit ;
48506: GO 48583
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48508: LD_ADDR_VAR 0 4
48512: PUSH
48513: LD_INT 22
48515: PUSH
48516: LD_VAR 0 2
48520: PUSH
48521: EMPTY
48522: LIST
48523: LIST
48524: PPUSH
48525: CALL_OW 69
48529: PUSH
48530: FOR_IN
48531: IFFALSE 48581
// begin un := UnitShoot ( i ) ;
48533: LD_ADDR_VAR 0 5
48537: PUSH
48538: LD_VAR 0 4
48542: PPUSH
48543: CALL_OW 504
48547: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48548: LD_VAR 0 5
48552: PPUSH
48553: CALL_OW 255
48557: PUSH
48558: LD_VAR 0 1
48562: EQUAL
48563: IFFALSE 48579
// begin result := un ;
48565: LD_ADDR_VAR 0 3
48569: PUSH
48570: LD_VAR 0 5
48574: ST_TO_ADDR
// exit ;
48575: POP
48576: POP
48577: GO 48583
// end ; end ;
48579: GO 48530
48581: POP
48582: POP
// end ;
48583: LD_VAR 0 3
48587: RET
// export function GetCargoBay ( units ) ; begin
48588: LD_INT 0
48590: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48591: LD_ADDR_VAR 0 2
48595: PUSH
48596: LD_VAR 0 1
48600: PPUSH
48601: LD_INT 2
48603: PUSH
48604: LD_INT 34
48606: PUSH
48607: LD_INT 12
48609: PUSH
48610: EMPTY
48611: LIST
48612: LIST
48613: PUSH
48614: LD_INT 34
48616: PUSH
48617: LD_INT 51
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: PUSH
48624: LD_INT 34
48626: PUSH
48627: LD_INT 32
48629: PUSH
48630: EMPTY
48631: LIST
48632: LIST
48633: PUSH
48634: LD_INT 34
48636: PUSH
48637: LD_INT 89
48639: PUSH
48640: EMPTY
48641: LIST
48642: LIST
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: LIST
48650: PPUSH
48651: CALL_OW 72
48655: ST_TO_ADDR
// end ;
48656: LD_VAR 0 2
48660: RET
// export function Negate ( value ) ; begin
48661: LD_INT 0
48663: PPUSH
// result := not value ;
48664: LD_ADDR_VAR 0 2
48668: PUSH
48669: LD_VAR 0 1
48673: NOT
48674: ST_TO_ADDR
// end ;
48675: LD_VAR 0 2
48679: RET
// export function Inc ( value ) ; begin
48680: LD_INT 0
48682: PPUSH
// result := value + 1 ;
48683: LD_ADDR_VAR 0 2
48687: PUSH
48688: LD_VAR 0 1
48692: PUSH
48693: LD_INT 1
48695: PLUS
48696: ST_TO_ADDR
// end ;
48697: LD_VAR 0 2
48701: RET
// export function Dec ( value ) ; begin
48702: LD_INT 0
48704: PPUSH
// result := value - 1 ;
48705: LD_ADDR_VAR 0 2
48709: PUSH
48710: LD_VAR 0 1
48714: PUSH
48715: LD_INT 1
48717: MINUS
48718: ST_TO_ADDR
// end ;
48719: LD_VAR 0 2
48723: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
48724: LD_INT 0
48726: PPUSH
48727: PPUSH
48728: PPUSH
48729: PPUSH
48730: PPUSH
48731: PPUSH
48732: PPUSH
48733: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
48734: LD_VAR 0 1
48738: PPUSH
48739: LD_VAR 0 2
48743: PPUSH
48744: CALL_OW 488
48748: NOT
48749: PUSH
48750: LD_VAR 0 3
48754: PPUSH
48755: LD_VAR 0 4
48759: PPUSH
48760: CALL_OW 488
48764: NOT
48765: OR
48766: IFFALSE 48779
// begin result := - 1 ;
48768: LD_ADDR_VAR 0 5
48772: PUSH
48773: LD_INT 1
48775: NEG
48776: ST_TO_ADDR
// exit ;
48777: GO 49014
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
48779: LD_ADDR_VAR 0 12
48783: PUSH
48784: LD_VAR 0 1
48788: PPUSH
48789: LD_VAR 0 2
48793: PPUSH
48794: LD_VAR 0 3
48798: PPUSH
48799: LD_VAR 0 4
48803: PPUSH
48804: CALL 47864 0 4
48808: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
48809: LD_ADDR_VAR 0 11
48813: PUSH
48814: LD_VAR 0 1
48818: PPUSH
48819: LD_VAR 0 2
48823: PPUSH
48824: LD_VAR 0 12
48828: PUSH
48829: LD_INT 1
48831: ARRAY
48832: PPUSH
48833: LD_VAR 0 12
48837: PUSH
48838: LD_INT 2
48840: ARRAY
48841: PPUSH
48842: CALL_OW 298
48846: ST_TO_ADDR
// distance := 9999 ;
48847: LD_ADDR_VAR 0 10
48851: PUSH
48852: LD_INT 9999
48854: ST_TO_ADDR
// for i := 0 to 5 do
48855: LD_ADDR_VAR 0 6
48859: PUSH
48860: DOUBLE
48861: LD_INT 0
48863: DEC
48864: ST_TO_ADDR
48865: LD_INT 5
48867: PUSH
48868: FOR_TO
48869: IFFALSE 49012
// begin _x := ShiftX ( x1 , i , centerDist ) ;
48871: LD_ADDR_VAR 0 7
48875: PUSH
48876: LD_VAR 0 1
48880: PPUSH
48881: LD_VAR 0 6
48885: PPUSH
48886: LD_VAR 0 11
48890: PPUSH
48891: CALL_OW 272
48895: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
48896: LD_ADDR_VAR 0 8
48900: PUSH
48901: LD_VAR 0 2
48905: PPUSH
48906: LD_VAR 0 6
48910: PPUSH
48911: LD_VAR 0 11
48915: PPUSH
48916: CALL_OW 273
48920: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48921: LD_VAR 0 7
48925: PPUSH
48926: LD_VAR 0 8
48930: PPUSH
48931: CALL_OW 488
48935: NOT
48936: IFFALSE 48940
// continue ;
48938: GO 48868
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
48940: LD_ADDR_VAR 0 9
48944: PUSH
48945: LD_VAR 0 12
48949: PUSH
48950: LD_INT 1
48952: ARRAY
48953: PPUSH
48954: LD_VAR 0 12
48958: PUSH
48959: LD_INT 2
48961: ARRAY
48962: PPUSH
48963: LD_VAR 0 7
48967: PPUSH
48968: LD_VAR 0 8
48972: PPUSH
48973: CALL_OW 298
48977: ST_TO_ADDR
// if tmp < distance then
48978: LD_VAR 0 9
48982: PUSH
48983: LD_VAR 0 10
48987: LESS
48988: IFFALSE 49010
// begin result := i ;
48990: LD_ADDR_VAR 0 5
48994: PUSH
48995: LD_VAR 0 6
48999: ST_TO_ADDR
// distance := tmp ;
49000: LD_ADDR_VAR 0 10
49004: PUSH
49005: LD_VAR 0 9
49009: ST_TO_ADDR
// end ; end ;
49010: GO 48868
49012: POP
49013: POP
// end ;
49014: LD_VAR 0 5
49018: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49019: LD_INT 0
49021: PPUSH
49022: PPUSH
// if not driver or not IsInUnit ( driver ) then
49023: LD_VAR 0 1
49027: NOT
49028: PUSH
49029: LD_VAR 0 1
49033: PPUSH
49034: CALL_OW 310
49038: NOT
49039: OR
49040: IFFALSE 49044
// exit ;
49042: GO 49134
// vehicle := IsInUnit ( driver ) ;
49044: LD_ADDR_VAR 0 3
49048: PUSH
49049: LD_VAR 0 1
49053: PPUSH
49054: CALL_OW 310
49058: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49059: LD_VAR 0 1
49063: PPUSH
49064: LD_STRING \
49066: PUSH
49067: LD_INT 0
49069: PUSH
49070: LD_INT 0
49072: PUSH
49073: LD_INT 0
49075: PUSH
49076: LD_INT 0
49078: PUSH
49079: LD_INT 0
49081: PUSH
49082: LD_INT 0
49084: PUSH
49085: EMPTY
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: PUSH
49094: LD_STRING E
49096: PUSH
49097: LD_INT 0
49099: PUSH
49100: LD_INT 0
49102: PUSH
49103: LD_VAR 0 3
49107: PUSH
49108: LD_INT 0
49110: PUSH
49111: LD_INT 0
49113: PUSH
49114: LD_INT 0
49116: PUSH
49117: EMPTY
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: LIST
49124: LIST
49125: PUSH
49126: EMPTY
49127: LIST
49128: LIST
49129: PPUSH
49130: CALL_OW 446
// end ;
49134: LD_VAR 0 2
49138: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49139: LD_INT 0
49141: PPUSH
49142: PPUSH
// if not driver or not IsInUnit ( driver ) then
49143: LD_VAR 0 1
49147: NOT
49148: PUSH
49149: LD_VAR 0 1
49153: PPUSH
49154: CALL_OW 310
49158: NOT
49159: OR
49160: IFFALSE 49164
// exit ;
49162: GO 49254
// vehicle := IsInUnit ( driver ) ;
49164: LD_ADDR_VAR 0 3
49168: PUSH
49169: LD_VAR 0 1
49173: PPUSH
49174: CALL_OW 310
49178: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49179: LD_VAR 0 1
49183: PPUSH
49184: LD_STRING \
49186: PUSH
49187: LD_INT 0
49189: PUSH
49190: LD_INT 0
49192: PUSH
49193: LD_INT 0
49195: PUSH
49196: LD_INT 0
49198: PUSH
49199: LD_INT 0
49201: PUSH
49202: LD_INT 0
49204: PUSH
49205: EMPTY
49206: LIST
49207: LIST
49208: LIST
49209: LIST
49210: LIST
49211: LIST
49212: LIST
49213: PUSH
49214: LD_STRING E
49216: PUSH
49217: LD_INT 0
49219: PUSH
49220: LD_INT 0
49222: PUSH
49223: LD_VAR 0 3
49227: PUSH
49228: LD_INT 0
49230: PUSH
49231: LD_INT 0
49233: PUSH
49234: LD_INT 0
49236: PUSH
49237: EMPTY
49238: LIST
49239: LIST
49240: LIST
49241: LIST
49242: LIST
49243: LIST
49244: LIST
49245: PUSH
49246: EMPTY
49247: LIST
49248: LIST
49249: PPUSH
49250: CALL_OW 447
// end ;
49254: LD_VAR 0 2
49258: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49259: LD_INT 0
49261: PPUSH
49262: PPUSH
49263: PPUSH
// tmp := [ ] ;
49264: LD_ADDR_VAR 0 5
49268: PUSH
49269: EMPTY
49270: ST_TO_ADDR
// for i in units do
49271: LD_ADDR_VAR 0 4
49275: PUSH
49276: LD_VAR 0 1
49280: PUSH
49281: FOR_IN
49282: IFFALSE 49320
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49284: LD_ADDR_VAR 0 5
49288: PUSH
49289: LD_VAR 0 5
49293: PPUSH
49294: LD_VAR 0 5
49298: PUSH
49299: LD_INT 1
49301: PLUS
49302: PPUSH
49303: LD_VAR 0 4
49307: PPUSH
49308: CALL_OW 256
49312: PPUSH
49313: CALL_OW 2
49317: ST_TO_ADDR
49318: GO 49281
49320: POP
49321: POP
// if not tmp then
49322: LD_VAR 0 5
49326: NOT
49327: IFFALSE 49331
// exit ;
49329: GO 49379
// if asc then
49331: LD_VAR 0 2
49335: IFFALSE 49359
// result := SortListByListAsc ( units , tmp ) else
49337: LD_ADDR_VAR 0 3
49341: PUSH
49342: LD_VAR 0 1
49346: PPUSH
49347: LD_VAR 0 5
49351: PPUSH
49352: CALL_OW 76
49356: ST_TO_ADDR
49357: GO 49379
// result := SortListByListDesc ( units , tmp ) ;
49359: LD_ADDR_VAR 0 3
49363: PUSH
49364: LD_VAR 0 1
49368: PPUSH
49369: LD_VAR 0 5
49373: PPUSH
49374: CALL_OW 77
49378: ST_TO_ADDR
// end ;
49379: LD_VAR 0 3
49383: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49384: LD_INT 0
49386: PPUSH
49387: PPUSH
// task := GetTaskList ( mech ) ;
49388: LD_ADDR_VAR 0 4
49392: PUSH
49393: LD_VAR 0 1
49397: PPUSH
49398: CALL_OW 437
49402: ST_TO_ADDR
// if not task then
49403: LD_VAR 0 4
49407: NOT
49408: IFFALSE 49412
// exit ;
49410: GO 49454
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49412: LD_ADDR_VAR 0 3
49416: PUSH
49417: LD_VAR 0 4
49421: PUSH
49422: LD_INT 1
49424: ARRAY
49425: PUSH
49426: LD_INT 1
49428: ARRAY
49429: PUSH
49430: LD_STRING r
49432: EQUAL
49433: PUSH
49434: LD_VAR 0 4
49438: PUSH
49439: LD_INT 1
49441: ARRAY
49442: PUSH
49443: LD_INT 4
49445: ARRAY
49446: PUSH
49447: LD_VAR 0 2
49451: EQUAL
49452: AND
49453: ST_TO_ADDR
// end ;
49454: LD_VAR 0 3
49458: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49459: LD_INT 0
49461: PPUSH
// SetDir ( unit , d ) ;
49462: LD_VAR 0 1
49466: PPUSH
49467: LD_VAR 0 4
49471: PPUSH
49472: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49476: LD_VAR 0 1
49480: PPUSH
49481: LD_VAR 0 2
49485: PPUSH
49486: LD_VAR 0 3
49490: PPUSH
49491: LD_VAR 0 5
49495: PPUSH
49496: CALL_OW 48
// end ;
49500: LD_VAR 0 6
49504: RET
// export function ToNaturalNumber ( number ) ; begin
49505: LD_INT 0
49507: PPUSH
// result := number div 1 ;
49508: LD_ADDR_VAR 0 2
49512: PUSH
49513: LD_VAR 0 1
49517: PUSH
49518: LD_INT 1
49520: DIV
49521: ST_TO_ADDR
// if number < 0 then
49522: LD_VAR 0 1
49526: PUSH
49527: LD_INT 0
49529: LESS
49530: IFFALSE 49540
// result := 0 ;
49532: LD_ADDR_VAR 0 2
49536: PUSH
49537: LD_INT 0
49539: ST_TO_ADDR
// end ;
49540: LD_VAR 0 2
49544: RET
// export function SortByClass ( units , class ) ; var un ; begin
49545: LD_INT 0
49547: PPUSH
49548: PPUSH
// if not units or not class then
49549: LD_VAR 0 1
49553: NOT
49554: PUSH
49555: LD_VAR 0 2
49559: NOT
49560: OR
49561: IFFALSE 49565
// exit ;
49563: GO 49660
// result := [ ] ;
49565: LD_ADDR_VAR 0 3
49569: PUSH
49570: EMPTY
49571: ST_TO_ADDR
// for un in units do
49572: LD_ADDR_VAR 0 4
49576: PUSH
49577: LD_VAR 0 1
49581: PUSH
49582: FOR_IN
49583: IFFALSE 49658
// if GetClass ( un ) = class then
49585: LD_VAR 0 4
49589: PPUSH
49590: CALL_OW 257
49594: PUSH
49595: LD_VAR 0 2
49599: EQUAL
49600: IFFALSE 49627
// result := Insert ( result , 1 , un ) else
49602: LD_ADDR_VAR 0 3
49606: PUSH
49607: LD_VAR 0 3
49611: PPUSH
49612: LD_INT 1
49614: PPUSH
49615: LD_VAR 0 4
49619: PPUSH
49620: CALL_OW 2
49624: ST_TO_ADDR
49625: GO 49656
// result := Replace ( result , result + 1 , un ) ;
49627: LD_ADDR_VAR 0 3
49631: PUSH
49632: LD_VAR 0 3
49636: PPUSH
49637: LD_VAR 0 3
49641: PUSH
49642: LD_INT 1
49644: PLUS
49645: PPUSH
49646: LD_VAR 0 4
49650: PPUSH
49651: CALL_OW 1
49655: ST_TO_ADDR
49656: GO 49582
49658: POP
49659: POP
// end ;
49660: LD_VAR 0 3
49664: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
49665: LD_INT 0
49667: PPUSH
49668: PPUSH
49669: PPUSH
49670: PPUSH
49671: PPUSH
49672: PPUSH
49673: PPUSH
// result := [ ] ;
49674: LD_ADDR_VAR 0 4
49678: PUSH
49679: EMPTY
49680: ST_TO_ADDR
// if x - r < 0 then
49681: LD_VAR 0 1
49685: PUSH
49686: LD_VAR 0 3
49690: MINUS
49691: PUSH
49692: LD_INT 0
49694: LESS
49695: IFFALSE 49707
// min_x := 0 else
49697: LD_ADDR_VAR 0 8
49701: PUSH
49702: LD_INT 0
49704: ST_TO_ADDR
49705: GO 49723
// min_x := x - r ;
49707: LD_ADDR_VAR 0 8
49711: PUSH
49712: LD_VAR 0 1
49716: PUSH
49717: LD_VAR 0 3
49721: MINUS
49722: ST_TO_ADDR
// if y - r < 0 then
49723: LD_VAR 0 2
49727: PUSH
49728: LD_VAR 0 3
49732: MINUS
49733: PUSH
49734: LD_INT 0
49736: LESS
49737: IFFALSE 49749
// min_y := 0 else
49739: LD_ADDR_VAR 0 7
49743: PUSH
49744: LD_INT 0
49746: ST_TO_ADDR
49747: GO 49765
// min_y := y - r ;
49749: LD_ADDR_VAR 0 7
49753: PUSH
49754: LD_VAR 0 2
49758: PUSH
49759: LD_VAR 0 3
49763: MINUS
49764: ST_TO_ADDR
// max_x := x + r ;
49765: LD_ADDR_VAR 0 9
49769: PUSH
49770: LD_VAR 0 1
49774: PUSH
49775: LD_VAR 0 3
49779: PLUS
49780: ST_TO_ADDR
// max_y := y + r ;
49781: LD_ADDR_VAR 0 10
49785: PUSH
49786: LD_VAR 0 2
49790: PUSH
49791: LD_VAR 0 3
49795: PLUS
49796: ST_TO_ADDR
// for _x = min_x to max_x do
49797: LD_ADDR_VAR 0 5
49801: PUSH
49802: DOUBLE
49803: LD_VAR 0 8
49807: DEC
49808: ST_TO_ADDR
49809: LD_VAR 0 9
49813: PUSH
49814: FOR_TO
49815: IFFALSE 49916
// for _y = min_y to max_y do
49817: LD_ADDR_VAR 0 6
49821: PUSH
49822: DOUBLE
49823: LD_VAR 0 7
49827: DEC
49828: ST_TO_ADDR
49829: LD_VAR 0 10
49833: PUSH
49834: FOR_TO
49835: IFFALSE 49912
// begin if not ValidHex ( _x , _y ) then
49837: LD_VAR 0 5
49841: PPUSH
49842: LD_VAR 0 6
49846: PPUSH
49847: CALL_OW 488
49851: NOT
49852: IFFALSE 49856
// continue ;
49854: GO 49834
// if GetResourceTypeXY ( _x , _y ) then
49856: LD_VAR 0 5
49860: PPUSH
49861: LD_VAR 0 6
49865: PPUSH
49866: CALL_OW 283
49870: IFFALSE 49910
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
49872: LD_ADDR_VAR 0 4
49876: PUSH
49877: LD_VAR 0 4
49881: PPUSH
49882: LD_VAR 0 4
49886: PUSH
49887: LD_INT 1
49889: PLUS
49890: PPUSH
49891: LD_VAR 0 5
49895: PUSH
49896: LD_VAR 0 6
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PPUSH
49905: CALL_OW 1
49909: ST_TO_ADDR
// end ;
49910: GO 49834
49912: POP
49913: POP
49914: GO 49814
49916: POP
49917: POP
// end ;
49918: LD_VAR 0 4
49922: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
49923: LD_INT 0
49925: PPUSH
49926: PPUSH
49927: PPUSH
49928: PPUSH
49929: PPUSH
49930: PPUSH
49931: PPUSH
49932: PPUSH
// if not units then
49933: LD_VAR 0 1
49937: NOT
49938: IFFALSE 49942
// exit ;
49940: GO 50466
// result := UnitFilter ( units , [ f_ok ] ) ;
49942: LD_ADDR_VAR 0 3
49946: PUSH
49947: LD_VAR 0 1
49951: PPUSH
49952: LD_INT 50
49954: PUSH
49955: EMPTY
49956: LIST
49957: PPUSH
49958: CALL_OW 72
49962: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49963: LD_ADDR_VAR 0 8
49967: PUSH
49968: LD_VAR 0 1
49972: PUSH
49973: LD_INT 1
49975: ARRAY
49976: PPUSH
49977: CALL_OW 255
49981: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
49982: LD_ADDR_VAR 0 10
49986: PUSH
49987: LD_INT 29
49989: PUSH
49990: LD_INT 91
49992: PUSH
49993: LD_INT 49
49995: PUSH
49996: EMPTY
49997: LIST
49998: LIST
49999: LIST
50000: ST_TO_ADDR
// if not result then
50001: LD_VAR 0 3
50005: NOT
50006: IFFALSE 50010
// exit ;
50008: GO 50466
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
50010: LD_ADDR_VAR 0 5
50014: PUSH
50015: LD_INT 81
50017: PUSH
50018: LD_VAR 0 8
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: PPUSH
50027: CALL_OW 69
50031: ST_TO_ADDR
// for i in result do
50032: LD_ADDR_VAR 0 4
50036: PUSH
50037: LD_VAR 0 3
50041: PUSH
50042: FOR_IN
50043: IFFALSE 50464
// begin tag := GetTag ( i ) + 1 ;
50045: LD_ADDR_VAR 0 9
50049: PUSH
50050: LD_VAR 0 4
50054: PPUSH
50055: CALL_OW 110
50059: PUSH
50060: LD_INT 1
50062: PLUS
50063: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
50064: LD_ADDR_VAR 0 7
50068: PUSH
50069: LD_VAR 0 4
50073: PPUSH
50074: CALL_OW 250
50078: PPUSH
50079: LD_VAR 0 4
50083: PPUSH
50084: CALL_OW 251
50088: PPUSH
50089: LD_INT 6
50091: PPUSH
50092: CALL 49665 0 3
50096: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50097: LD_VAR 0 4
50101: PPUSH
50102: CALL_OW 247
50106: PUSH
50107: LD_INT 2
50109: EQUAL
50110: PUSH
50111: LD_VAR 0 7
50115: AND
50116: PUSH
50117: LD_VAR 0 4
50121: PPUSH
50122: CALL_OW 264
50126: PUSH
50127: LD_VAR 0 10
50131: IN
50132: NOT
50133: AND
50134: IFFALSE 50173
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50136: LD_VAR 0 4
50140: PPUSH
50141: LD_VAR 0 7
50145: PUSH
50146: LD_INT 1
50148: ARRAY
50149: PUSH
50150: LD_INT 1
50152: ARRAY
50153: PPUSH
50154: LD_VAR 0 7
50158: PUSH
50159: LD_INT 1
50161: ARRAY
50162: PUSH
50163: LD_INT 2
50165: ARRAY
50166: PPUSH
50167: CALL_OW 116
50171: GO 50462
// if path > tag then
50173: LD_VAR 0 2
50177: PUSH
50178: LD_VAR 0 9
50182: GREATER
50183: IFFALSE 50391
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
50185: LD_ADDR_VAR 0 6
50189: PUSH
50190: LD_VAR 0 5
50194: PPUSH
50195: LD_INT 91
50197: PUSH
50198: LD_VAR 0 4
50202: PUSH
50203: LD_INT 8
50205: PUSH
50206: EMPTY
50207: LIST
50208: LIST
50209: LIST
50210: PPUSH
50211: CALL_OW 72
50215: ST_TO_ADDR
// if nearEnemy then
50216: LD_VAR 0 6
50220: IFFALSE 50289
// begin if GetWeapon ( i ) = ru_time_lapser then
50222: LD_VAR 0 4
50226: PPUSH
50227: CALL_OW 264
50231: PUSH
50232: LD_INT 49
50234: EQUAL
50235: IFFALSE 50263
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50237: LD_VAR 0 4
50241: PPUSH
50242: LD_VAR 0 6
50246: PPUSH
50247: LD_VAR 0 4
50251: PPUSH
50252: CALL_OW 74
50256: PPUSH
50257: CALL_OW 112
50261: GO 50287
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
50263: LD_VAR 0 4
50267: PPUSH
50268: LD_VAR 0 6
50272: PPUSH
50273: LD_VAR 0 4
50277: PPUSH
50278: CALL_OW 74
50282: PPUSH
50283: CALL_OW 115
// end else
50287: GO 50389
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50289: LD_VAR 0 4
50293: PPUSH
50294: LD_VAR 0 2
50298: PUSH
50299: LD_VAR 0 9
50303: ARRAY
50304: PUSH
50305: LD_INT 1
50307: ARRAY
50308: PPUSH
50309: LD_VAR 0 2
50313: PUSH
50314: LD_VAR 0 9
50318: ARRAY
50319: PUSH
50320: LD_INT 2
50322: ARRAY
50323: PPUSH
50324: CALL_OW 297
50328: PUSH
50329: LD_INT 6
50331: GREATER
50332: IFFALSE 50375
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50334: LD_VAR 0 4
50338: PPUSH
50339: LD_VAR 0 2
50343: PUSH
50344: LD_VAR 0 9
50348: ARRAY
50349: PUSH
50350: LD_INT 1
50352: ARRAY
50353: PPUSH
50354: LD_VAR 0 2
50358: PUSH
50359: LD_VAR 0 9
50363: ARRAY
50364: PUSH
50365: LD_INT 2
50367: ARRAY
50368: PPUSH
50369: CALL_OW 114
50373: GO 50389
// SetTag ( i , tag ) ;
50375: LD_VAR 0 4
50379: PPUSH
50380: LD_VAR 0 9
50384: PPUSH
50385: CALL_OW 109
// end else
50389: GO 50462
// if enemy then
50391: LD_VAR 0 5
50395: IFFALSE 50462
// begin if GetWeapon ( i ) = ru_time_lapser then
50397: LD_VAR 0 4
50401: PPUSH
50402: CALL_OW 264
50406: PUSH
50407: LD_INT 49
50409: EQUAL
50410: IFFALSE 50438
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
50412: LD_VAR 0 4
50416: PPUSH
50417: LD_VAR 0 5
50421: PPUSH
50422: LD_VAR 0 4
50426: PPUSH
50427: CALL_OW 74
50431: PPUSH
50432: CALL_OW 112
50436: GO 50462
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50438: LD_VAR 0 4
50442: PPUSH
50443: LD_VAR 0 5
50447: PPUSH
50448: LD_VAR 0 4
50452: PPUSH
50453: CALL_OW 74
50457: PPUSH
50458: CALL_OW 115
// end ; end ;
50462: GO 50042
50464: POP
50465: POP
// end ;
50466: LD_VAR 0 3
50470: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50471: LD_INT 0
50473: PPUSH
50474: PPUSH
50475: PPUSH
// if not unit or IsInUnit ( unit ) then
50476: LD_VAR 0 1
50480: NOT
50481: PUSH
50482: LD_VAR 0 1
50486: PPUSH
50487: CALL_OW 310
50491: OR
50492: IFFALSE 50496
// exit ;
50494: GO 50587
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50496: LD_ADDR_VAR 0 4
50500: PUSH
50501: LD_VAR 0 1
50505: PPUSH
50506: CALL_OW 250
50510: PPUSH
50511: LD_VAR 0 2
50515: PPUSH
50516: LD_INT 1
50518: PPUSH
50519: CALL_OW 272
50523: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50524: LD_ADDR_VAR 0 5
50528: PUSH
50529: LD_VAR 0 1
50533: PPUSH
50534: CALL_OW 251
50538: PPUSH
50539: LD_VAR 0 2
50543: PPUSH
50544: LD_INT 1
50546: PPUSH
50547: CALL_OW 273
50551: ST_TO_ADDR
// if ValidHex ( x , y ) then
50552: LD_VAR 0 4
50556: PPUSH
50557: LD_VAR 0 5
50561: PPUSH
50562: CALL_OW 488
50566: IFFALSE 50587
// ComTurnXY ( unit , x , y ) ;
50568: LD_VAR 0 1
50572: PPUSH
50573: LD_VAR 0 4
50577: PPUSH
50578: LD_VAR 0 5
50582: PPUSH
50583: CALL_OW 118
// end ;
50587: LD_VAR 0 3
50591: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50592: LD_INT 0
50594: PPUSH
50595: PPUSH
// result := false ;
50596: LD_ADDR_VAR 0 3
50600: PUSH
50601: LD_INT 0
50603: ST_TO_ADDR
// if not units then
50604: LD_VAR 0 2
50608: NOT
50609: IFFALSE 50613
// exit ;
50611: GO 50658
// for i in units do
50613: LD_ADDR_VAR 0 4
50617: PUSH
50618: LD_VAR 0 2
50622: PUSH
50623: FOR_IN
50624: IFFALSE 50656
// if See ( side , i ) then
50626: LD_VAR 0 1
50630: PPUSH
50631: LD_VAR 0 4
50635: PPUSH
50636: CALL_OW 292
50640: IFFALSE 50654
// begin result := true ;
50642: LD_ADDR_VAR 0 3
50646: PUSH
50647: LD_INT 1
50649: ST_TO_ADDR
// exit ;
50650: POP
50651: POP
50652: GO 50658
// end ;
50654: GO 50623
50656: POP
50657: POP
// end ;
50658: LD_VAR 0 3
50662: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50663: LD_INT 0
50665: PPUSH
50666: PPUSH
50667: PPUSH
50668: PPUSH
// if not unit or not points then
50669: LD_VAR 0 1
50673: NOT
50674: PUSH
50675: LD_VAR 0 2
50679: NOT
50680: OR
50681: IFFALSE 50685
// exit ;
50683: GO 50775
// dist := 99999 ;
50685: LD_ADDR_VAR 0 5
50689: PUSH
50690: LD_INT 99999
50692: ST_TO_ADDR
// for i in points do
50693: LD_ADDR_VAR 0 4
50697: PUSH
50698: LD_VAR 0 2
50702: PUSH
50703: FOR_IN
50704: IFFALSE 50773
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
50706: LD_ADDR_VAR 0 6
50710: PUSH
50711: LD_VAR 0 1
50715: PPUSH
50716: LD_VAR 0 4
50720: PUSH
50721: LD_INT 1
50723: ARRAY
50724: PPUSH
50725: LD_VAR 0 4
50729: PUSH
50730: LD_INT 2
50732: ARRAY
50733: PPUSH
50734: CALL_OW 297
50738: ST_TO_ADDR
// if tmpDist < dist then
50739: LD_VAR 0 6
50743: PUSH
50744: LD_VAR 0 5
50748: LESS
50749: IFFALSE 50771
// begin result := i ;
50751: LD_ADDR_VAR 0 3
50755: PUSH
50756: LD_VAR 0 4
50760: ST_TO_ADDR
// dist := tmpDist ;
50761: LD_ADDR_VAR 0 5
50765: PUSH
50766: LD_VAR 0 6
50770: ST_TO_ADDR
// end ; end ;
50771: GO 50703
50773: POP
50774: POP
// end ;
50775: LD_VAR 0 3
50779: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
50780: LD_INT 0
50782: PPUSH
// uc_side := side ;
50783: LD_ADDR_OWVAR 20
50787: PUSH
50788: LD_VAR 0 1
50792: ST_TO_ADDR
// uc_nation := 3 ;
50793: LD_ADDR_OWVAR 21
50797: PUSH
50798: LD_INT 3
50800: ST_TO_ADDR
// vc_chassis := 25 ;
50801: LD_ADDR_OWVAR 37
50805: PUSH
50806: LD_INT 25
50808: ST_TO_ADDR
// vc_engine := engine_siberite ;
50809: LD_ADDR_OWVAR 39
50813: PUSH
50814: LD_INT 3
50816: ST_TO_ADDR
// vc_control := control_computer ;
50817: LD_ADDR_OWVAR 38
50821: PUSH
50822: LD_INT 3
50824: ST_TO_ADDR
// vc_weapon := 59 ;
50825: LD_ADDR_OWVAR 40
50829: PUSH
50830: LD_INT 59
50832: ST_TO_ADDR
// result := CreateVehicle ;
50833: LD_ADDR_VAR 0 5
50837: PUSH
50838: CALL_OW 45
50842: ST_TO_ADDR
// SetDir ( result , d ) ;
50843: LD_VAR 0 5
50847: PPUSH
50848: LD_VAR 0 4
50852: PPUSH
50853: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
50857: LD_VAR 0 5
50861: PPUSH
50862: LD_VAR 0 2
50866: PPUSH
50867: LD_VAR 0 3
50871: PPUSH
50872: LD_INT 0
50874: PPUSH
50875: CALL_OW 48
// end ;
50879: LD_VAR 0 5
50883: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
50884: LD_INT 0
50886: PPUSH
50887: PPUSH
50888: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
50889: LD_ADDR_VAR 0 2
50893: PUSH
50894: LD_INT 0
50896: PUSH
50897: LD_INT 0
50899: PUSH
50900: LD_INT 0
50902: PUSH
50903: LD_INT 0
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: LIST
50910: LIST
50911: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
50912: LD_VAR 0 1
50916: NOT
50917: PUSH
50918: LD_VAR 0 1
50922: PPUSH
50923: CALL_OW 264
50927: PUSH
50928: LD_INT 12
50930: PUSH
50931: LD_INT 51
50933: PUSH
50934: LD_INT 32
50936: PUSH
50937: LD_INT 89
50939: PUSH
50940: EMPTY
50941: LIST
50942: LIST
50943: LIST
50944: LIST
50945: IN
50946: NOT
50947: OR
50948: IFFALSE 50952
// exit ;
50950: GO 51050
// for i := 1 to 3 do
50952: LD_ADDR_VAR 0 3
50956: PUSH
50957: DOUBLE
50958: LD_INT 1
50960: DEC
50961: ST_TO_ADDR
50962: LD_INT 3
50964: PUSH
50965: FOR_TO
50966: IFFALSE 51048
// begin tmp := GetCargo ( cargo , i ) ;
50968: LD_ADDR_VAR 0 4
50972: PUSH
50973: LD_VAR 0 1
50977: PPUSH
50978: LD_VAR 0 3
50982: PPUSH
50983: CALL_OW 289
50987: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
50988: LD_ADDR_VAR 0 2
50992: PUSH
50993: LD_VAR 0 2
50997: PPUSH
50998: LD_VAR 0 3
51002: PPUSH
51003: LD_VAR 0 4
51007: PPUSH
51008: CALL_OW 1
51012: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
51013: LD_ADDR_VAR 0 2
51017: PUSH
51018: LD_VAR 0 2
51022: PPUSH
51023: LD_INT 4
51025: PPUSH
51026: LD_VAR 0 2
51030: PUSH
51031: LD_INT 4
51033: ARRAY
51034: PUSH
51035: LD_VAR 0 4
51039: PLUS
51040: PPUSH
51041: CALL_OW 1
51045: ST_TO_ADDR
// end ;
51046: GO 50965
51048: POP
51049: POP
// end ;
51050: LD_VAR 0 2
51054: RET
// export function Length ( array ) ; begin
51055: LD_INT 0
51057: PPUSH
// result := array + 0 ;
51058: LD_ADDR_VAR 0 2
51062: PUSH
51063: LD_VAR 0 1
51067: PUSH
51068: LD_INT 0
51070: PLUS
51071: ST_TO_ADDR
// end ;
51072: LD_VAR 0 2
51076: RET
// export function PrepareArray ( array ) ; begin
51077: LD_INT 0
51079: PPUSH
// result := array diff 0 ;
51080: LD_ADDR_VAR 0 2
51084: PUSH
51085: LD_VAR 0 1
51089: PUSH
51090: LD_INT 0
51092: DIFF
51093: ST_TO_ADDR
// if not result [ 1 ] then
51094: LD_VAR 0 2
51098: PUSH
51099: LD_INT 1
51101: ARRAY
51102: NOT
51103: IFFALSE 51123
// result := Delete ( result , 1 ) ;
51105: LD_ADDR_VAR 0 2
51109: PUSH
51110: LD_VAR 0 2
51114: PPUSH
51115: LD_INT 1
51117: PPUSH
51118: CALL_OW 3
51122: ST_TO_ADDR
// end ;
51123: LD_VAR 0 2
51127: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
51128: LD_INT 0
51130: PPUSH
51131: PPUSH
51132: PPUSH
51133: PPUSH
// sibRocketRange := 25 ;
51134: LD_ADDR_VAR 0 6
51138: PUSH
51139: LD_INT 25
51141: ST_TO_ADDR
// result := false ;
51142: LD_ADDR_VAR 0 4
51146: PUSH
51147: LD_INT 0
51149: ST_TO_ADDR
// for i := 0 to 5 do
51150: LD_ADDR_VAR 0 5
51154: PUSH
51155: DOUBLE
51156: LD_INT 0
51158: DEC
51159: ST_TO_ADDR
51160: LD_INT 5
51162: PUSH
51163: FOR_TO
51164: IFFALSE 51231
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
51166: LD_VAR 0 1
51170: PPUSH
51171: LD_VAR 0 5
51175: PPUSH
51176: LD_VAR 0 6
51180: PPUSH
51181: CALL_OW 272
51185: PPUSH
51186: LD_VAR 0 2
51190: PPUSH
51191: LD_VAR 0 5
51195: PPUSH
51196: LD_VAR 0 6
51200: PPUSH
51201: CALL_OW 273
51205: PPUSH
51206: LD_VAR 0 3
51210: PPUSH
51211: CALL_OW 309
51215: IFFALSE 51229
// begin result := true ;
51217: LD_ADDR_VAR 0 4
51221: PUSH
51222: LD_INT 1
51224: ST_TO_ADDR
// exit ;
51225: POP
51226: POP
51227: GO 51233
// end ;
51229: GO 51163
51231: POP
51232: POP
// end ;
51233: LD_VAR 0 4
51237: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
51238: LD_INT 0
51240: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
51241: LD_VAR 0 1
51245: PPUSH
51246: LD_VAR 0 2
51250: PPUSH
51251: LD_INT 0
51253: PPUSH
51254: LD_INT 0
51256: PPUSH
51257: LD_INT 1
51259: PPUSH
51260: LD_INT 0
51262: PPUSH
51263: CALL_OW 587
// end ; end_of_file
51267: LD_VAR 0 3
51271: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
51272: LD_INT 0
51274: PPUSH
51275: PPUSH
// skirmish := false ;
51276: LD_ADDR_EXP 41
51280: PUSH
51281: LD_INT 0
51283: ST_TO_ADDR
// debug_mc := false ;
51284: LD_ADDR_EXP 42
51288: PUSH
51289: LD_INT 0
51291: ST_TO_ADDR
// mc_bases := [ ] ;
51292: LD_ADDR_EXP 43
51296: PUSH
51297: EMPTY
51298: ST_TO_ADDR
// mc_sides := [ ] ;
51299: LD_ADDR_EXP 69
51303: PUSH
51304: EMPTY
51305: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51306: LD_ADDR_EXP 44
51310: PUSH
51311: EMPTY
51312: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51313: LD_ADDR_EXP 45
51317: PUSH
51318: EMPTY
51319: ST_TO_ADDR
// mc_need_heal := [ ] ;
51320: LD_ADDR_EXP 46
51324: PUSH
51325: EMPTY
51326: ST_TO_ADDR
// mc_healers := [ ] ;
51327: LD_ADDR_EXP 47
51331: PUSH
51332: EMPTY
51333: ST_TO_ADDR
// mc_build_list := [ ] ;
51334: LD_ADDR_EXP 48
51338: PUSH
51339: EMPTY
51340: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51341: LD_ADDR_EXP 75
51345: PUSH
51346: EMPTY
51347: ST_TO_ADDR
// mc_builders := [ ] ;
51348: LD_ADDR_EXP 49
51352: PUSH
51353: EMPTY
51354: ST_TO_ADDR
// mc_construct_list := [ ] ;
51355: LD_ADDR_EXP 50
51359: PUSH
51360: EMPTY
51361: ST_TO_ADDR
// mc_turret_list := [ ] ;
51362: LD_ADDR_EXP 51
51366: PUSH
51367: EMPTY
51368: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51369: LD_ADDR_EXP 52
51373: PUSH
51374: EMPTY
51375: ST_TO_ADDR
// mc_miners := [ ] ;
51376: LD_ADDR_EXP 57
51380: PUSH
51381: EMPTY
51382: ST_TO_ADDR
// mc_mines := [ ] ;
51383: LD_ADDR_EXP 56
51387: PUSH
51388: EMPTY
51389: ST_TO_ADDR
// mc_minefields := [ ] ;
51390: LD_ADDR_EXP 58
51394: PUSH
51395: EMPTY
51396: ST_TO_ADDR
// mc_crates := [ ] ;
51397: LD_ADDR_EXP 59
51401: PUSH
51402: EMPTY
51403: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51404: LD_ADDR_EXP 60
51408: PUSH
51409: EMPTY
51410: ST_TO_ADDR
// mc_crates_area := [ ] ;
51411: LD_ADDR_EXP 61
51415: PUSH
51416: EMPTY
51417: ST_TO_ADDR
// mc_vehicles := [ ] ;
51418: LD_ADDR_EXP 62
51422: PUSH
51423: EMPTY
51424: ST_TO_ADDR
// mc_attack := [ ] ;
51425: LD_ADDR_EXP 63
51429: PUSH
51430: EMPTY
51431: ST_TO_ADDR
// mc_produce := [ ] ;
51432: LD_ADDR_EXP 64
51436: PUSH
51437: EMPTY
51438: ST_TO_ADDR
// mc_defender := [ ] ;
51439: LD_ADDR_EXP 65
51443: PUSH
51444: EMPTY
51445: ST_TO_ADDR
// mc_parking := [ ] ;
51446: LD_ADDR_EXP 67
51450: PUSH
51451: EMPTY
51452: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51453: LD_ADDR_EXP 53
51457: PUSH
51458: EMPTY
51459: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51460: LD_ADDR_EXP 55
51464: PUSH
51465: EMPTY
51466: ST_TO_ADDR
// mc_scan := [ ] ;
51467: LD_ADDR_EXP 66
51471: PUSH
51472: EMPTY
51473: ST_TO_ADDR
// mc_scan_area := [ ] ;
51474: LD_ADDR_EXP 68
51478: PUSH
51479: EMPTY
51480: ST_TO_ADDR
// mc_tech := [ ] ;
51481: LD_ADDR_EXP 70
51485: PUSH
51486: EMPTY
51487: ST_TO_ADDR
// mc_class := [ ] ;
51488: LD_ADDR_EXP 84
51492: PUSH
51493: EMPTY
51494: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51495: LD_ADDR_EXP 85
51499: PUSH
51500: EMPTY
51501: ST_TO_ADDR
// mc_is_defending := [ ] ;
51502: LD_ADDR_EXP 86
51506: PUSH
51507: EMPTY
51508: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
51509: LD_ADDR_EXP 77
51513: PUSH
51514: EMPTY
51515: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
51516: LD_ADDR_EXP 87
51520: PUSH
51521: LD_INT 0
51523: ST_TO_ADDR
// end ;
51524: LD_VAR 0 1
51528: RET
// export function MC_Kill ( base ) ; begin
51529: LD_INT 0
51531: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51532: LD_ADDR_EXP 43
51536: PUSH
51537: LD_EXP 43
51541: PPUSH
51542: LD_VAR 0 1
51546: PPUSH
51547: EMPTY
51548: PPUSH
51549: CALL_OW 1
51553: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51554: LD_ADDR_EXP 44
51558: PUSH
51559: LD_EXP 44
51563: PPUSH
51564: LD_VAR 0 1
51568: PPUSH
51569: EMPTY
51570: PPUSH
51571: CALL_OW 1
51575: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51576: LD_ADDR_EXP 45
51580: PUSH
51581: LD_EXP 45
51585: PPUSH
51586: LD_VAR 0 1
51590: PPUSH
51591: EMPTY
51592: PPUSH
51593: CALL_OW 1
51597: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51598: LD_ADDR_EXP 46
51602: PUSH
51603: LD_EXP 46
51607: PPUSH
51608: LD_VAR 0 1
51612: PPUSH
51613: EMPTY
51614: PPUSH
51615: CALL_OW 1
51619: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51620: LD_ADDR_EXP 47
51624: PUSH
51625: LD_EXP 47
51629: PPUSH
51630: LD_VAR 0 1
51634: PPUSH
51635: EMPTY
51636: PPUSH
51637: CALL_OW 1
51641: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51642: LD_ADDR_EXP 48
51646: PUSH
51647: LD_EXP 48
51651: PPUSH
51652: LD_VAR 0 1
51656: PPUSH
51657: EMPTY
51658: PPUSH
51659: CALL_OW 1
51663: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51664: LD_ADDR_EXP 49
51668: PUSH
51669: LD_EXP 49
51673: PPUSH
51674: LD_VAR 0 1
51678: PPUSH
51679: EMPTY
51680: PPUSH
51681: CALL_OW 1
51685: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51686: LD_ADDR_EXP 50
51690: PUSH
51691: LD_EXP 50
51695: PPUSH
51696: LD_VAR 0 1
51700: PPUSH
51701: EMPTY
51702: PPUSH
51703: CALL_OW 1
51707: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51708: LD_ADDR_EXP 51
51712: PUSH
51713: LD_EXP 51
51717: PPUSH
51718: LD_VAR 0 1
51722: PPUSH
51723: EMPTY
51724: PPUSH
51725: CALL_OW 1
51729: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51730: LD_ADDR_EXP 52
51734: PUSH
51735: LD_EXP 52
51739: PPUSH
51740: LD_VAR 0 1
51744: PPUSH
51745: EMPTY
51746: PPUSH
51747: CALL_OW 1
51751: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51752: LD_ADDR_EXP 53
51756: PUSH
51757: LD_EXP 53
51761: PPUSH
51762: LD_VAR 0 1
51766: PPUSH
51767: EMPTY
51768: PPUSH
51769: CALL_OW 1
51773: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51774: LD_ADDR_EXP 54
51778: PUSH
51779: LD_EXP 54
51783: PPUSH
51784: LD_VAR 0 1
51788: PPUSH
51789: LD_INT 0
51791: PPUSH
51792: CALL_OW 1
51796: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51797: LD_ADDR_EXP 55
51801: PUSH
51802: LD_EXP 55
51806: PPUSH
51807: LD_VAR 0 1
51811: PPUSH
51812: EMPTY
51813: PPUSH
51814: CALL_OW 1
51818: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51819: LD_ADDR_EXP 56
51823: PUSH
51824: LD_EXP 56
51828: PPUSH
51829: LD_VAR 0 1
51833: PPUSH
51834: EMPTY
51835: PPUSH
51836: CALL_OW 1
51840: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51841: LD_ADDR_EXP 57
51845: PUSH
51846: LD_EXP 57
51850: PPUSH
51851: LD_VAR 0 1
51855: PPUSH
51856: EMPTY
51857: PPUSH
51858: CALL_OW 1
51862: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51863: LD_ADDR_EXP 58
51867: PUSH
51868: LD_EXP 58
51872: PPUSH
51873: LD_VAR 0 1
51877: PPUSH
51878: EMPTY
51879: PPUSH
51880: CALL_OW 1
51884: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51885: LD_ADDR_EXP 59
51889: PUSH
51890: LD_EXP 59
51894: PPUSH
51895: LD_VAR 0 1
51899: PPUSH
51900: EMPTY
51901: PPUSH
51902: CALL_OW 1
51906: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51907: LD_ADDR_EXP 60
51911: PUSH
51912: LD_EXP 60
51916: PPUSH
51917: LD_VAR 0 1
51921: PPUSH
51922: EMPTY
51923: PPUSH
51924: CALL_OW 1
51928: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51929: LD_ADDR_EXP 61
51933: PUSH
51934: LD_EXP 61
51938: PPUSH
51939: LD_VAR 0 1
51943: PPUSH
51944: EMPTY
51945: PPUSH
51946: CALL_OW 1
51950: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51951: LD_ADDR_EXP 62
51955: PUSH
51956: LD_EXP 62
51960: PPUSH
51961: LD_VAR 0 1
51965: PPUSH
51966: EMPTY
51967: PPUSH
51968: CALL_OW 1
51972: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51973: LD_ADDR_EXP 63
51977: PUSH
51978: LD_EXP 63
51982: PPUSH
51983: LD_VAR 0 1
51987: PPUSH
51988: EMPTY
51989: PPUSH
51990: CALL_OW 1
51994: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51995: LD_ADDR_EXP 64
51999: PUSH
52000: LD_EXP 64
52004: PPUSH
52005: LD_VAR 0 1
52009: PPUSH
52010: EMPTY
52011: PPUSH
52012: CALL_OW 1
52016: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52017: LD_ADDR_EXP 65
52021: PUSH
52022: LD_EXP 65
52026: PPUSH
52027: LD_VAR 0 1
52031: PPUSH
52032: EMPTY
52033: PPUSH
52034: CALL_OW 1
52038: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52039: LD_ADDR_EXP 66
52043: PUSH
52044: LD_EXP 66
52048: PPUSH
52049: LD_VAR 0 1
52053: PPUSH
52054: EMPTY
52055: PPUSH
52056: CALL_OW 1
52060: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52061: LD_ADDR_EXP 67
52065: PUSH
52066: LD_EXP 67
52070: PPUSH
52071: LD_VAR 0 1
52075: PPUSH
52076: EMPTY
52077: PPUSH
52078: CALL_OW 1
52082: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52083: LD_ADDR_EXP 68
52087: PUSH
52088: LD_EXP 68
52092: PPUSH
52093: LD_VAR 0 1
52097: PPUSH
52098: EMPTY
52099: PPUSH
52100: CALL_OW 1
52104: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52105: LD_ADDR_EXP 70
52109: PUSH
52110: LD_EXP 70
52114: PPUSH
52115: LD_VAR 0 1
52119: PPUSH
52120: EMPTY
52121: PPUSH
52122: CALL_OW 1
52126: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52127: LD_ADDR_EXP 72
52131: PUSH
52132: LD_EXP 72
52136: PPUSH
52137: LD_VAR 0 1
52141: PPUSH
52142: EMPTY
52143: PPUSH
52144: CALL_OW 1
52148: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52149: LD_ADDR_EXP 73
52153: PUSH
52154: LD_EXP 73
52158: PPUSH
52159: LD_VAR 0 1
52163: PPUSH
52164: EMPTY
52165: PPUSH
52166: CALL_OW 1
52170: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52171: LD_ADDR_EXP 74
52175: PUSH
52176: LD_EXP 74
52180: PPUSH
52181: LD_VAR 0 1
52185: PPUSH
52186: EMPTY
52187: PPUSH
52188: CALL_OW 1
52192: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52193: LD_ADDR_EXP 75
52197: PUSH
52198: LD_EXP 75
52202: PPUSH
52203: LD_VAR 0 1
52207: PPUSH
52208: EMPTY
52209: PPUSH
52210: CALL_OW 1
52214: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52215: LD_ADDR_EXP 76
52219: PUSH
52220: LD_EXP 76
52224: PPUSH
52225: LD_VAR 0 1
52229: PPUSH
52230: EMPTY
52231: PPUSH
52232: CALL_OW 1
52236: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52237: LD_ADDR_EXP 77
52241: PUSH
52242: LD_EXP 77
52246: PPUSH
52247: LD_VAR 0 1
52251: PPUSH
52252: EMPTY
52253: PPUSH
52254: CALL_OW 1
52258: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52259: LD_ADDR_EXP 78
52263: PUSH
52264: LD_EXP 78
52268: PPUSH
52269: LD_VAR 0 1
52273: PPUSH
52274: EMPTY
52275: PPUSH
52276: CALL_OW 1
52280: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52281: LD_ADDR_EXP 79
52285: PUSH
52286: LD_EXP 79
52290: PPUSH
52291: LD_VAR 0 1
52295: PPUSH
52296: EMPTY
52297: PPUSH
52298: CALL_OW 1
52302: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52303: LD_ADDR_EXP 80
52307: PUSH
52308: LD_EXP 80
52312: PPUSH
52313: LD_VAR 0 1
52317: PPUSH
52318: EMPTY
52319: PPUSH
52320: CALL_OW 1
52324: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52325: LD_ADDR_EXP 81
52329: PUSH
52330: LD_EXP 81
52334: PPUSH
52335: LD_VAR 0 1
52339: PPUSH
52340: EMPTY
52341: PPUSH
52342: CALL_OW 1
52346: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52347: LD_ADDR_EXP 82
52351: PUSH
52352: LD_EXP 82
52356: PPUSH
52357: LD_VAR 0 1
52361: PPUSH
52362: EMPTY
52363: PPUSH
52364: CALL_OW 1
52368: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52369: LD_ADDR_EXP 83
52373: PUSH
52374: LD_EXP 83
52378: PPUSH
52379: LD_VAR 0 1
52383: PPUSH
52384: EMPTY
52385: PPUSH
52386: CALL_OW 1
52390: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52391: LD_ADDR_EXP 84
52395: PUSH
52396: LD_EXP 84
52400: PPUSH
52401: LD_VAR 0 1
52405: PPUSH
52406: EMPTY
52407: PPUSH
52408: CALL_OW 1
52412: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52413: LD_ADDR_EXP 85
52417: PUSH
52418: LD_EXP 85
52422: PPUSH
52423: LD_VAR 0 1
52427: PPUSH
52428: LD_INT 0
52430: PPUSH
52431: CALL_OW 1
52435: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52436: LD_ADDR_EXP 86
52440: PUSH
52441: LD_EXP 86
52445: PPUSH
52446: LD_VAR 0 1
52450: PPUSH
52451: LD_INT 0
52453: PPUSH
52454: CALL_OW 1
52458: ST_TO_ADDR
// end ;
52459: LD_VAR 0 2
52463: RET
// export function MC_Add ( side , units ) ; var base ; begin
52464: LD_INT 0
52466: PPUSH
52467: PPUSH
// base := mc_bases + 1 ;
52468: LD_ADDR_VAR 0 4
52472: PUSH
52473: LD_EXP 43
52477: PUSH
52478: LD_INT 1
52480: PLUS
52481: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52482: LD_ADDR_EXP 69
52486: PUSH
52487: LD_EXP 69
52491: PPUSH
52492: LD_VAR 0 4
52496: PPUSH
52497: LD_VAR 0 1
52501: PPUSH
52502: CALL_OW 1
52506: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52507: LD_ADDR_EXP 43
52511: PUSH
52512: LD_EXP 43
52516: PPUSH
52517: LD_VAR 0 4
52521: PPUSH
52522: LD_VAR 0 2
52526: PPUSH
52527: CALL_OW 1
52531: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52532: LD_ADDR_EXP 44
52536: PUSH
52537: LD_EXP 44
52541: PPUSH
52542: LD_VAR 0 4
52546: PPUSH
52547: EMPTY
52548: PPUSH
52549: CALL_OW 1
52553: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52554: LD_ADDR_EXP 45
52558: PUSH
52559: LD_EXP 45
52563: PPUSH
52564: LD_VAR 0 4
52568: PPUSH
52569: EMPTY
52570: PPUSH
52571: CALL_OW 1
52575: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52576: LD_ADDR_EXP 46
52580: PUSH
52581: LD_EXP 46
52585: PPUSH
52586: LD_VAR 0 4
52590: PPUSH
52591: EMPTY
52592: PPUSH
52593: CALL_OW 1
52597: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52598: LD_ADDR_EXP 47
52602: PUSH
52603: LD_EXP 47
52607: PPUSH
52608: LD_VAR 0 4
52612: PPUSH
52613: EMPTY
52614: PPUSH
52615: CALL_OW 1
52619: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52620: LD_ADDR_EXP 48
52624: PUSH
52625: LD_EXP 48
52629: PPUSH
52630: LD_VAR 0 4
52634: PPUSH
52635: EMPTY
52636: PPUSH
52637: CALL_OW 1
52641: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52642: LD_ADDR_EXP 49
52646: PUSH
52647: LD_EXP 49
52651: PPUSH
52652: LD_VAR 0 4
52656: PPUSH
52657: EMPTY
52658: PPUSH
52659: CALL_OW 1
52663: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52664: LD_ADDR_EXP 50
52668: PUSH
52669: LD_EXP 50
52673: PPUSH
52674: LD_VAR 0 4
52678: PPUSH
52679: EMPTY
52680: PPUSH
52681: CALL_OW 1
52685: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52686: LD_ADDR_EXP 51
52690: PUSH
52691: LD_EXP 51
52695: PPUSH
52696: LD_VAR 0 4
52700: PPUSH
52701: EMPTY
52702: PPUSH
52703: CALL_OW 1
52707: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52708: LD_ADDR_EXP 52
52712: PUSH
52713: LD_EXP 52
52717: PPUSH
52718: LD_VAR 0 4
52722: PPUSH
52723: EMPTY
52724: PPUSH
52725: CALL_OW 1
52729: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52730: LD_ADDR_EXP 53
52734: PUSH
52735: LD_EXP 53
52739: PPUSH
52740: LD_VAR 0 4
52744: PPUSH
52745: EMPTY
52746: PPUSH
52747: CALL_OW 1
52751: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52752: LD_ADDR_EXP 54
52756: PUSH
52757: LD_EXP 54
52761: PPUSH
52762: LD_VAR 0 4
52766: PPUSH
52767: LD_INT 0
52769: PPUSH
52770: CALL_OW 1
52774: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52775: LD_ADDR_EXP 55
52779: PUSH
52780: LD_EXP 55
52784: PPUSH
52785: LD_VAR 0 4
52789: PPUSH
52790: EMPTY
52791: PPUSH
52792: CALL_OW 1
52796: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52797: LD_ADDR_EXP 56
52801: PUSH
52802: LD_EXP 56
52806: PPUSH
52807: LD_VAR 0 4
52811: PPUSH
52812: EMPTY
52813: PPUSH
52814: CALL_OW 1
52818: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52819: LD_ADDR_EXP 57
52823: PUSH
52824: LD_EXP 57
52828: PPUSH
52829: LD_VAR 0 4
52833: PPUSH
52834: EMPTY
52835: PPUSH
52836: CALL_OW 1
52840: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52841: LD_ADDR_EXP 58
52845: PUSH
52846: LD_EXP 58
52850: PPUSH
52851: LD_VAR 0 4
52855: PPUSH
52856: EMPTY
52857: PPUSH
52858: CALL_OW 1
52862: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52863: LD_ADDR_EXP 59
52867: PUSH
52868: LD_EXP 59
52872: PPUSH
52873: LD_VAR 0 4
52877: PPUSH
52878: EMPTY
52879: PPUSH
52880: CALL_OW 1
52884: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52885: LD_ADDR_EXP 60
52889: PUSH
52890: LD_EXP 60
52894: PPUSH
52895: LD_VAR 0 4
52899: PPUSH
52900: EMPTY
52901: PPUSH
52902: CALL_OW 1
52906: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52907: LD_ADDR_EXP 61
52911: PUSH
52912: LD_EXP 61
52916: PPUSH
52917: LD_VAR 0 4
52921: PPUSH
52922: EMPTY
52923: PPUSH
52924: CALL_OW 1
52928: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52929: LD_ADDR_EXP 62
52933: PUSH
52934: LD_EXP 62
52938: PPUSH
52939: LD_VAR 0 4
52943: PPUSH
52944: EMPTY
52945: PPUSH
52946: CALL_OW 1
52950: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52951: LD_ADDR_EXP 63
52955: PUSH
52956: LD_EXP 63
52960: PPUSH
52961: LD_VAR 0 4
52965: PPUSH
52966: EMPTY
52967: PPUSH
52968: CALL_OW 1
52972: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52973: LD_ADDR_EXP 64
52977: PUSH
52978: LD_EXP 64
52982: PPUSH
52983: LD_VAR 0 4
52987: PPUSH
52988: EMPTY
52989: PPUSH
52990: CALL_OW 1
52994: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52995: LD_ADDR_EXP 65
52999: PUSH
53000: LD_EXP 65
53004: PPUSH
53005: LD_VAR 0 4
53009: PPUSH
53010: EMPTY
53011: PPUSH
53012: CALL_OW 1
53016: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53017: LD_ADDR_EXP 66
53021: PUSH
53022: LD_EXP 66
53026: PPUSH
53027: LD_VAR 0 4
53031: PPUSH
53032: EMPTY
53033: PPUSH
53034: CALL_OW 1
53038: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53039: LD_ADDR_EXP 67
53043: PUSH
53044: LD_EXP 67
53048: PPUSH
53049: LD_VAR 0 4
53053: PPUSH
53054: EMPTY
53055: PPUSH
53056: CALL_OW 1
53060: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53061: LD_ADDR_EXP 68
53065: PUSH
53066: LD_EXP 68
53070: PPUSH
53071: LD_VAR 0 4
53075: PPUSH
53076: EMPTY
53077: PPUSH
53078: CALL_OW 1
53082: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53083: LD_ADDR_EXP 70
53087: PUSH
53088: LD_EXP 70
53092: PPUSH
53093: LD_VAR 0 4
53097: PPUSH
53098: EMPTY
53099: PPUSH
53100: CALL_OW 1
53104: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53105: LD_ADDR_EXP 72
53109: PUSH
53110: LD_EXP 72
53114: PPUSH
53115: LD_VAR 0 4
53119: PPUSH
53120: EMPTY
53121: PPUSH
53122: CALL_OW 1
53126: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53127: LD_ADDR_EXP 73
53131: PUSH
53132: LD_EXP 73
53136: PPUSH
53137: LD_VAR 0 4
53141: PPUSH
53142: EMPTY
53143: PPUSH
53144: CALL_OW 1
53148: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53149: LD_ADDR_EXP 74
53153: PUSH
53154: LD_EXP 74
53158: PPUSH
53159: LD_VAR 0 4
53163: PPUSH
53164: EMPTY
53165: PPUSH
53166: CALL_OW 1
53170: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53171: LD_ADDR_EXP 75
53175: PUSH
53176: LD_EXP 75
53180: PPUSH
53181: LD_VAR 0 4
53185: PPUSH
53186: EMPTY
53187: PPUSH
53188: CALL_OW 1
53192: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53193: LD_ADDR_EXP 76
53197: PUSH
53198: LD_EXP 76
53202: PPUSH
53203: LD_VAR 0 4
53207: PPUSH
53208: EMPTY
53209: PPUSH
53210: CALL_OW 1
53214: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53215: LD_ADDR_EXP 77
53219: PUSH
53220: LD_EXP 77
53224: PPUSH
53225: LD_VAR 0 4
53229: PPUSH
53230: EMPTY
53231: PPUSH
53232: CALL_OW 1
53236: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53237: LD_ADDR_EXP 78
53241: PUSH
53242: LD_EXP 78
53246: PPUSH
53247: LD_VAR 0 4
53251: PPUSH
53252: EMPTY
53253: PPUSH
53254: CALL_OW 1
53258: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53259: LD_ADDR_EXP 79
53263: PUSH
53264: LD_EXP 79
53268: PPUSH
53269: LD_VAR 0 4
53273: PPUSH
53274: EMPTY
53275: PPUSH
53276: CALL_OW 1
53280: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53281: LD_ADDR_EXP 80
53285: PUSH
53286: LD_EXP 80
53290: PPUSH
53291: LD_VAR 0 4
53295: PPUSH
53296: EMPTY
53297: PPUSH
53298: CALL_OW 1
53302: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53303: LD_ADDR_EXP 81
53307: PUSH
53308: LD_EXP 81
53312: PPUSH
53313: LD_VAR 0 4
53317: PPUSH
53318: EMPTY
53319: PPUSH
53320: CALL_OW 1
53324: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53325: LD_ADDR_EXP 82
53329: PUSH
53330: LD_EXP 82
53334: PPUSH
53335: LD_VAR 0 4
53339: PPUSH
53340: EMPTY
53341: PPUSH
53342: CALL_OW 1
53346: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53347: LD_ADDR_EXP 83
53351: PUSH
53352: LD_EXP 83
53356: PPUSH
53357: LD_VAR 0 4
53361: PPUSH
53362: EMPTY
53363: PPUSH
53364: CALL_OW 1
53368: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53369: LD_ADDR_EXP 84
53373: PUSH
53374: LD_EXP 84
53378: PPUSH
53379: LD_VAR 0 4
53383: PPUSH
53384: EMPTY
53385: PPUSH
53386: CALL_OW 1
53390: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53391: LD_ADDR_EXP 85
53395: PUSH
53396: LD_EXP 85
53400: PPUSH
53401: LD_VAR 0 4
53405: PPUSH
53406: LD_INT 0
53408: PPUSH
53409: CALL_OW 1
53413: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53414: LD_ADDR_EXP 86
53418: PUSH
53419: LD_EXP 86
53423: PPUSH
53424: LD_VAR 0 4
53428: PPUSH
53429: LD_INT 0
53431: PPUSH
53432: CALL_OW 1
53436: ST_TO_ADDR
// result := base ;
53437: LD_ADDR_VAR 0 3
53441: PUSH
53442: LD_VAR 0 4
53446: ST_TO_ADDR
// end ;
53447: LD_VAR 0 3
53451: RET
// export function MC_Start ( ) ; var i ; begin
53452: LD_INT 0
53454: PPUSH
53455: PPUSH
// for i = 1 to mc_bases do
53456: LD_ADDR_VAR 0 2
53460: PUSH
53461: DOUBLE
53462: LD_INT 1
53464: DEC
53465: ST_TO_ADDR
53466: LD_EXP 43
53470: PUSH
53471: FOR_TO
53472: IFFALSE 54572
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53474: LD_ADDR_EXP 43
53478: PUSH
53479: LD_EXP 43
53483: PPUSH
53484: LD_VAR 0 2
53488: PPUSH
53489: LD_EXP 43
53493: PUSH
53494: LD_VAR 0 2
53498: ARRAY
53499: PUSH
53500: LD_INT 0
53502: DIFF
53503: PPUSH
53504: CALL_OW 1
53508: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53509: LD_ADDR_EXP 44
53513: PUSH
53514: LD_EXP 44
53518: PPUSH
53519: LD_VAR 0 2
53523: PPUSH
53524: EMPTY
53525: PPUSH
53526: CALL_OW 1
53530: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53531: LD_ADDR_EXP 45
53535: PUSH
53536: LD_EXP 45
53540: PPUSH
53541: LD_VAR 0 2
53545: PPUSH
53546: EMPTY
53547: PPUSH
53548: CALL_OW 1
53552: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53553: LD_ADDR_EXP 46
53557: PUSH
53558: LD_EXP 46
53562: PPUSH
53563: LD_VAR 0 2
53567: PPUSH
53568: EMPTY
53569: PPUSH
53570: CALL_OW 1
53574: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53575: LD_ADDR_EXP 47
53579: PUSH
53580: LD_EXP 47
53584: PPUSH
53585: LD_VAR 0 2
53589: PPUSH
53590: EMPTY
53591: PUSH
53592: EMPTY
53593: PUSH
53594: EMPTY
53595: LIST
53596: LIST
53597: PPUSH
53598: CALL_OW 1
53602: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53603: LD_ADDR_EXP 48
53607: PUSH
53608: LD_EXP 48
53612: PPUSH
53613: LD_VAR 0 2
53617: PPUSH
53618: EMPTY
53619: PPUSH
53620: CALL_OW 1
53624: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53625: LD_ADDR_EXP 75
53629: PUSH
53630: LD_EXP 75
53634: PPUSH
53635: LD_VAR 0 2
53639: PPUSH
53640: EMPTY
53641: PPUSH
53642: CALL_OW 1
53646: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53647: LD_ADDR_EXP 49
53651: PUSH
53652: LD_EXP 49
53656: PPUSH
53657: LD_VAR 0 2
53661: PPUSH
53662: EMPTY
53663: PPUSH
53664: CALL_OW 1
53668: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53669: LD_ADDR_EXP 50
53673: PUSH
53674: LD_EXP 50
53678: PPUSH
53679: LD_VAR 0 2
53683: PPUSH
53684: EMPTY
53685: PPUSH
53686: CALL_OW 1
53690: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53691: LD_ADDR_EXP 51
53695: PUSH
53696: LD_EXP 51
53700: PPUSH
53701: LD_VAR 0 2
53705: PPUSH
53706: LD_EXP 43
53710: PUSH
53711: LD_VAR 0 2
53715: ARRAY
53716: PPUSH
53717: LD_INT 2
53719: PUSH
53720: LD_INT 30
53722: PUSH
53723: LD_INT 32
53725: PUSH
53726: EMPTY
53727: LIST
53728: LIST
53729: PUSH
53730: LD_INT 30
53732: PUSH
53733: LD_INT 33
53735: PUSH
53736: EMPTY
53737: LIST
53738: LIST
53739: PUSH
53740: EMPTY
53741: LIST
53742: LIST
53743: LIST
53744: PPUSH
53745: CALL_OW 72
53749: PPUSH
53750: CALL_OW 1
53754: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53755: LD_ADDR_EXP 52
53759: PUSH
53760: LD_EXP 52
53764: PPUSH
53765: LD_VAR 0 2
53769: PPUSH
53770: LD_EXP 43
53774: PUSH
53775: LD_VAR 0 2
53779: ARRAY
53780: PPUSH
53781: LD_INT 2
53783: PUSH
53784: LD_INT 30
53786: PUSH
53787: LD_INT 32
53789: PUSH
53790: EMPTY
53791: LIST
53792: LIST
53793: PUSH
53794: LD_INT 30
53796: PUSH
53797: LD_INT 31
53799: PUSH
53800: EMPTY
53801: LIST
53802: LIST
53803: PUSH
53804: EMPTY
53805: LIST
53806: LIST
53807: LIST
53808: PUSH
53809: LD_INT 58
53811: PUSH
53812: EMPTY
53813: LIST
53814: PUSH
53815: EMPTY
53816: LIST
53817: LIST
53818: PPUSH
53819: CALL_OW 72
53823: PPUSH
53824: CALL_OW 1
53828: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53829: LD_ADDR_EXP 53
53833: PUSH
53834: LD_EXP 53
53838: PPUSH
53839: LD_VAR 0 2
53843: PPUSH
53844: EMPTY
53845: PPUSH
53846: CALL_OW 1
53850: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53851: LD_ADDR_EXP 57
53855: PUSH
53856: LD_EXP 57
53860: PPUSH
53861: LD_VAR 0 2
53865: PPUSH
53866: EMPTY
53867: PPUSH
53868: CALL_OW 1
53872: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53873: LD_ADDR_EXP 56
53877: PUSH
53878: LD_EXP 56
53882: PPUSH
53883: LD_VAR 0 2
53887: PPUSH
53888: EMPTY
53889: PPUSH
53890: CALL_OW 1
53894: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53895: LD_ADDR_EXP 58
53899: PUSH
53900: LD_EXP 58
53904: PPUSH
53905: LD_VAR 0 2
53909: PPUSH
53910: EMPTY
53911: PPUSH
53912: CALL_OW 1
53916: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53917: LD_ADDR_EXP 59
53921: PUSH
53922: LD_EXP 59
53926: PPUSH
53927: LD_VAR 0 2
53931: PPUSH
53932: EMPTY
53933: PPUSH
53934: CALL_OW 1
53938: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53939: LD_ADDR_EXP 60
53943: PUSH
53944: LD_EXP 60
53948: PPUSH
53949: LD_VAR 0 2
53953: PPUSH
53954: EMPTY
53955: PPUSH
53956: CALL_OW 1
53960: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53961: LD_ADDR_EXP 61
53965: PUSH
53966: LD_EXP 61
53970: PPUSH
53971: LD_VAR 0 2
53975: PPUSH
53976: EMPTY
53977: PPUSH
53978: CALL_OW 1
53982: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53983: LD_ADDR_EXP 62
53987: PUSH
53988: LD_EXP 62
53992: PPUSH
53993: LD_VAR 0 2
53997: PPUSH
53998: EMPTY
53999: PPUSH
54000: CALL_OW 1
54004: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54005: LD_ADDR_EXP 63
54009: PUSH
54010: LD_EXP 63
54014: PPUSH
54015: LD_VAR 0 2
54019: PPUSH
54020: EMPTY
54021: PPUSH
54022: CALL_OW 1
54026: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54027: LD_ADDR_EXP 64
54031: PUSH
54032: LD_EXP 64
54036: PPUSH
54037: LD_VAR 0 2
54041: PPUSH
54042: EMPTY
54043: PPUSH
54044: CALL_OW 1
54048: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54049: LD_ADDR_EXP 65
54053: PUSH
54054: LD_EXP 65
54058: PPUSH
54059: LD_VAR 0 2
54063: PPUSH
54064: EMPTY
54065: PPUSH
54066: CALL_OW 1
54070: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54071: LD_ADDR_EXP 54
54075: PUSH
54076: LD_EXP 54
54080: PPUSH
54081: LD_VAR 0 2
54085: PPUSH
54086: LD_INT 0
54088: PPUSH
54089: CALL_OW 1
54093: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54094: LD_ADDR_EXP 67
54098: PUSH
54099: LD_EXP 67
54103: PPUSH
54104: LD_VAR 0 2
54108: PPUSH
54109: LD_INT 0
54111: PPUSH
54112: CALL_OW 1
54116: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54117: LD_ADDR_EXP 55
54121: PUSH
54122: LD_EXP 55
54126: PPUSH
54127: LD_VAR 0 2
54131: PPUSH
54132: EMPTY
54133: PPUSH
54134: CALL_OW 1
54138: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54139: LD_ADDR_EXP 66
54143: PUSH
54144: LD_EXP 66
54148: PPUSH
54149: LD_VAR 0 2
54153: PPUSH
54154: LD_INT 0
54156: PPUSH
54157: CALL_OW 1
54161: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54162: LD_ADDR_EXP 68
54166: PUSH
54167: LD_EXP 68
54171: PPUSH
54172: LD_VAR 0 2
54176: PPUSH
54177: EMPTY
54178: PPUSH
54179: CALL_OW 1
54183: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54184: LD_ADDR_EXP 71
54188: PUSH
54189: LD_EXP 71
54193: PPUSH
54194: LD_VAR 0 2
54198: PPUSH
54199: LD_INT 0
54201: PPUSH
54202: CALL_OW 1
54206: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54207: LD_ADDR_EXP 72
54211: PUSH
54212: LD_EXP 72
54216: PPUSH
54217: LD_VAR 0 2
54221: PPUSH
54222: EMPTY
54223: PPUSH
54224: CALL_OW 1
54228: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54229: LD_ADDR_EXP 73
54233: PUSH
54234: LD_EXP 73
54238: PPUSH
54239: LD_VAR 0 2
54243: PPUSH
54244: EMPTY
54245: PPUSH
54246: CALL_OW 1
54250: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54251: LD_ADDR_EXP 74
54255: PUSH
54256: LD_EXP 74
54260: PPUSH
54261: LD_VAR 0 2
54265: PPUSH
54266: EMPTY
54267: PPUSH
54268: CALL_OW 1
54272: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54273: LD_ADDR_EXP 76
54277: PUSH
54278: LD_EXP 76
54282: PPUSH
54283: LD_VAR 0 2
54287: PPUSH
54288: LD_EXP 43
54292: PUSH
54293: LD_VAR 0 2
54297: ARRAY
54298: PPUSH
54299: LD_INT 2
54301: PUSH
54302: LD_INT 30
54304: PUSH
54305: LD_INT 6
54307: PUSH
54308: EMPTY
54309: LIST
54310: LIST
54311: PUSH
54312: LD_INT 30
54314: PUSH
54315: LD_INT 7
54317: PUSH
54318: EMPTY
54319: LIST
54320: LIST
54321: PUSH
54322: LD_INT 30
54324: PUSH
54325: LD_INT 8
54327: PUSH
54328: EMPTY
54329: LIST
54330: LIST
54331: PUSH
54332: EMPTY
54333: LIST
54334: LIST
54335: LIST
54336: LIST
54337: PPUSH
54338: CALL_OW 72
54342: PPUSH
54343: CALL_OW 1
54347: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54348: LD_ADDR_EXP 77
54352: PUSH
54353: LD_EXP 77
54357: PPUSH
54358: LD_VAR 0 2
54362: PPUSH
54363: EMPTY
54364: PPUSH
54365: CALL_OW 1
54369: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54370: LD_ADDR_EXP 78
54374: PUSH
54375: LD_EXP 78
54379: PPUSH
54380: LD_VAR 0 2
54384: PPUSH
54385: EMPTY
54386: PPUSH
54387: CALL_OW 1
54391: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54392: LD_ADDR_EXP 79
54396: PUSH
54397: LD_EXP 79
54401: PPUSH
54402: LD_VAR 0 2
54406: PPUSH
54407: EMPTY
54408: PPUSH
54409: CALL_OW 1
54413: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54414: LD_ADDR_EXP 80
54418: PUSH
54419: LD_EXP 80
54423: PPUSH
54424: LD_VAR 0 2
54428: PPUSH
54429: EMPTY
54430: PPUSH
54431: CALL_OW 1
54435: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54436: LD_ADDR_EXP 81
54440: PUSH
54441: LD_EXP 81
54445: PPUSH
54446: LD_VAR 0 2
54450: PPUSH
54451: EMPTY
54452: PPUSH
54453: CALL_OW 1
54457: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54458: LD_ADDR_EXP 82
54462: PUSH
54463: LD_EXP 82
54467: PPUSH
54468: LD_VAR 0 2
54472: PPUSH
54473: EMPTY
54474: PPUSH
54475: CALL_OW 1
54479: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54480: LD_ADDR_EXP 83
54484: PUSH
54485: LD_EXP 83
54489: PPUSH
54490: LD_VAR 0 2
54494: PPUSH
54495: EMPTY
54496: PPUSH
54497: CALL_OW 1
54501: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54502: LD_ADDR_EXP 84
54506: PUSH
54507: LD_EXP 84
54511: PPUSH
54512: LD_VAR 0 2
54516: PPUSH
54517: EMPTY
54518: PPUSH
54519: CALL_OW 1
54523: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54524: LD_ADDR_EXP 85
54528: PUSH
54529: LD_EXP 85
54533: PPUSH
54534: LD_VAR 0 2
54538: PPUSH
54539: LD_INT 0
54541: PPUSH
54542: CALL_OW 1
54546: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54547: LD_ADDR_EXP 86
54551: PUSH
54552: LD_EXP 86
54556: PPUSH
54557: LD_VAR 0 2
54561: PPUSH
54562: LD_INT 0
54564: PPUSH
54565: CALL_OW 1
54569: ST_TO_ADDR
// end ;
54570: GO 53471
54572: POP
54573: POP
// MC_InitSides ( ) ;
54574: CALL 54860 0 0
// MC_InitResearch ( ) ;
54578: CALL 54599 0 0
// CustomInitMacro ( ) ;
54582: CALL 97 0 0
// skirmish := true ;
54586: LD_ADDR_EXP 41
54590: PUSH
54591: LD_INT 1
54593: ST_TO_ADDR
// end ;
54594: LD_VAR 0 1
54598: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54599: LD_INT 0
54601: PPUSH
54602: PPUSH
54603: PPUSH
54604: PPUSH
54605: PPUSH
54606: PPUSH
// if not mc_bases then
54607: LD_EXP 43
54611: NOT
54612: IFFALSE 54616
// exit ;
54614: GO 54855
// for i = 1 to 8 do
54616: LD_ADDR_VAR 0 2
54620: PUSH
54621: DOUBLE
54622: LD_INT 1
54624: DEC
54625: ST_TO_ADDR
54626: LD_INT 8
54628: PUSH
54629: FOR_TO
54630: IFFALSE 54656
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54632: LD_ADDR_EXP 70
54636: PUSH
54637: LD_EXP 70
54641: PPUSH
54642: LD_VAR 0 2
54646: PPUSH
54647: EMPTY
54648: PPUSH
54649: CALL_OW 1
54653: ST_TO_ADDR
54654: GO 54629
54656: POP
54657: POP
// tmp := [ ] ;
54658: LD_ADDR_VAR 0 5
54662: PUSH
54663: EMPTY
54664: ST_TO_ADDR
// for i = 1 to mc_sides do
54665: LD_ADDR_VAR 0 2
54669: PUSH
54670: DOUBLE
54671: LD_INT 1
54673: DEC
54674: ST_TO_ADDR
54675: LD_EXP 69
54679: PUSH
54680: FOR_TO
54681: IFFALSE 54739
// if not mc_sides [ i ] in tmp then
54683: LD_EXP 69
54687: PUSH
54688: LD_VAR 0 2
54692: ARRAY
54693: PUSH
54694: LD_VAR 0 5
54698: IN
54699: NOT
54700: IFFALSE 54737
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54702: LD_ADDR_VAR 0 5
54706: PUSH
54707: LD_VAR 0 5
54711: PPUSH
54712: LD_VAR 0 5
54716: PUSH
54717: LD_INT 1
54719: PLUS
54720: PPUSH
54721: LD_EXP 69
54725: PUSH
54726: LD_VAR 0 2
54730: ARRAY
54731: PPUSH
54732: CALL_OW 2
54736: ST_TO_ADDR
54737: GO 54680
54739: POP
54740: POP
// if not tmp then
54741: LD_VAR 0 5
54745: NOT
54746: IFFALSE 54750
// exit ;
54748: GO 54855
// for j in tmp do
54750: LD_ADDR_VAR 0 3
54754: PUSH
54755: LD_VAR 0 5
54759: PUSH
54760: FOR_IN
54761: IFFALSE 54853
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54763: LD_ADDR_VAR 0 6
54767: PUSH
54768: LD_INT 22
54770: PUSH
54771: LD_VAR 0 3
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: PPUSH
54780: CALL_OW 69
54784: ST_TO_ADDR
// if not un then
54785: LD_VAR 0 6
54789: NOT
54790: IFFALSE 54794
// continue ;
54792: GO 54760
// nation := GetNation ( un [ 1 ] ) ;
54794: LD_ADDR_VAR 0 4
54798: PUSH
54799: LD_VAR 0 6
54803: PUSH
54804: LD_INT 1
54806: ARRAY
54807: PPUSH
54808: CALL_OW 248
54812: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54813: LD_ADDR_EXP 70
54817: PUSH
54818: LD_EXP 70
54822: PPUSH
54823: LD_VAR 0 3
54827: PPUSH
54828: LD_VAR 0 3
54832: PPUSH
54833: LD_VAR 0 4
54837: PPUSH
54838: LD_INT 1
54840: PPUSH
54841: CALL 9914 0 3
54845: PPUSH
54846: CALL_OW 1
54850: ST_TO_ADDR
// end ;
54851: GO 54760
54853: POP
54854: POP
// end ;
54855: LD_VAR 0 1
54859: RET
// export function MC_InitSides ( ) ; var i ; begin
54860: LD_INT 0
54862: PPUSH
54863: PPUSH
// if not mc_bases then
54864: LD_EXP 43
54868: NOT
54869: IFFALSE 54873
// exit ;
54871: GO 54947
// for i = 1 to mc_bases do
54873: LD_ADDR_VAR 0 2
54877: PUSH
54878: DOUBLE
54879: LD_INT 1
54881: DEC
54882: ST_TO_ADDR
54883: LD_EXP 43
54887: PUSH
54888: FOR_TO
54889: IFFALSE 54945
// if mc_bases [ i ] then
54891: LD_EXP 43
54895: PUSH
54896: LD_VAR 0 2
54900: ARRAY
54901: IFFALSE 54943
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54903: LD_ADDR_EXP 69
54907: PUSH
54908: LD_EXP 69
54912: PPUSH
54913: LD_VAR 0 2
54917: PPUSH
54918: LD_EXP 43
54922: PUSH
54923: LD_VAR 0 2
54927: ARRAY
54928: PUSH
54929: LD_INT 1
54931: ARRAY
54932: PPUSH
54933: CALL_OW 255
54937: PPUSH
54938: CALL_OW 1
54942: ST_TO_ADDR
54943: GO 54888
54945: POP
54946: POP
// end ;
54947: LD_VAR 0 1
54951: RET
// every 0 0$03 trigger skirmish do
54952: LD_EXP 41
54956: IFFALSE 55110
54958: GO 54960
54960: DISABLE
// begin enable ;
54961: ENABLE
// MC_CheckBuildings ( ) ;
54962: CALL 59608 0 0
// MC_CheckPeopleLife ( ) ;
54966: CALL 59769 0 0
// RaiseSailEvent ( 100 ) ;
54970: LD_INT 100
54972: PPUSH
54973: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54977: LD_INT 103
54979: PPUSH
54980: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54984: LD_INT 104
54986: PPUSH
54987: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54991: LD_INT 105
54993: PPUSH
54994: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54998: LD_INT 106
55000: PPUSH
55001: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55005: LD_INT 107
55007: PPUSH
55008: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55012: LD_INT 108
55014: PPUSH
55015: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55019: LD_INT 109
55021: PPUSH
55022: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55026: LD_INT 110
55028: PPUSH
55029: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55033: LD_INT 111
55035: PPUSH
55036: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55040: LD_INT 112
55042: PPUSH
55043: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55047: LD_INT 113
55049: PPUSH
55050: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55054: LD_INT 120
55056: PPUSH
55057: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55061: LD_INT 121
55063: PPUSH
55064: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55068: LD_INT 122
55070: PPUSH
55071: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55075: LD_INT 123
55077: PPUSH
55078: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55082: LD_INT 124
55084: PPUSH
55085: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55089: LD_INT 125
55091: PPUSH
55092: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55096: LD_INT 126
55098: PPUSH
55099: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55103: LD_INT 200
55105: PPUSH
55106: CALL_OW 427
// end ;
55110: END
// on SailEvent ( event ) do begin if event < 100 then
55111: LD_VAR 0 1
55115: PUSH
55116: LD_INT 100
55118: LESS
55119: IFFALSE 55130
// CustomEvent ( event ) ;
55121: LD_VAR 0 1
55125: PPUSH
55126: CALL 603 0 1
// if event = 100 then
55130: LD_VAR 0 1
55134: PUSH
55135: LD_INT 100
55137: EQUAL
55138: IFFALSE 55144
// MC_ClassManager ( ) ;
55140: CALL 55536 0 0
// if event = 101 then
55144: LD_VAR 0 1
55148: PUSH
55149: LD_INT 101
55151: EQUAL
55152: IFFALSE 55158
// MC_RepairBuildings ( ) ;
55154: CALL 60354 0 0
// if event = 102 then
55158: LD_VAR 0 1
55162: PUSH
55163: LD_INT 102
55165: EQUAL
55166: IFFALSE 55172
// MC_Heal ( ) ;
55168: CALL 61289 0 0
// if event = 103 then
55172: LD_VAR 0 1
55176: PUSH
55177: LD_INT 103
55179: EQUAL
55180: IFFALSE 55186
// MC_Build ( ) ;
55182: CALL 61711 0 0
// if event = 104 then
55186: LD_VAR 0 1
55190: PUSH
55191: LD_INT 104
55193: EQUAL
55194: IFFALSE 55200
// MC_TurretWeapon ( ) ;
55196: CALL 63345 0 0
// if event = 105 then
55200: LD_VAR 0 1
55204: PUSH
55205: LD_INT 105
55207: EQUAL
55208: IFFALSE 55214
// MC_BuildUpgrade ( ) ;
55210: CALL 62896 0 0
// if event = 106 then
55214: LD_VAR 0 1
55218: PUSH
55219: LD_INT 106
55221: EQUAL
55222: IFFALSE 55228
// MC_PlantMines ( ) ;
55224: CALL 63775 0 0
// if event = 107 then
55228: LD_VAR 0 1
55232: PUSH
55233: LD_INT 107
55235: EQUAL
55236: IFFALSE 55242
// MC_CollectCrates ( ) ;
55238: CALL 64566 0 0
// if event = 108 then
55242: LD_VAR 0 1
55246: PUSH
55247: LD_INT 108
55249: EQUAL
55250: IFFALSE 55256
// MC_LinkRemoteControl ( ) ;
55252: CALL 66416 0 0
// if event = 109 then
55256: LD_VAR 0 1
55260: PUSH
55261: LD_INT 109
55263: EQUAL
55264: IFFALSE 55270
// MC_ProduceVehicle ( ) ;
55266: CALL 66597 0 0
// if event = 110 then
55270: LD_VAR 0 1
55274: PUSH
55275: LD_INT 110
55277: EQUAL
55278: IFFALSE 55284
// MC_SendAttack ( ) ;
55280: CALL 67063 0 0
// if event = 111 then
55284: LD_VAR 0 1
55288: PUSH
55289: LD_INT 111
55291: EQUAL
55292: IFFALSE 55298
// MC_Defend ( ) ;
55294: CALL 67171 0 0
// if event = 112 then
55298: LD_VAR 0 1
55302: PUSH
55303: LD_INT 112
55305: EQUAL
55306: IFFALSE 55312
// MC_Research ( ) ;
55308: CALL 68051 0 0
// if event = 113 then
55312: LD_VAR 0 1
55316: PUSH
55317: LD_INT 113
55319: EQUAL
55320: IFFALSE 55326
// MC_MinesTrigger ( ) ;
55322: CALL 69165 0 0
// if event = 120 then
55326: LD_VAR 0 1
55330: PUSH
55331: LD_INT 120
55333: EQUAL
55334: IFFALSE 55340
// MC_RepairVehicle ( ) ;
55336: CALL 69264 0 0
// if event = 121 then
55340: LD_VAR 0 1
55344: PUSH
55345: LD_INT 121
55347: EQUAL
55348: IFFALSE 55354
// MC_TameApe ( ) ;
55350: CALL 70033 0 0
// if event = 122 then
55354: LD_VAR 0 1
55358: PUSH
55359: LD_INT 122
55361: EQUAL
55362: IFFALSE 55368
// MC_ChangeApeClass ( ) ;
55364: CALL 70862 0 0
// if event = 123 then
55368: LD_VAR 0 1
55372: PUSH
55373: LD_INT 123
55375: EQUAL
55376: IFFALSE 55382
// MC_Bazooka ( ) ;
55378: CALL 71512 0 0
// if event = 124 then
55382: LD_VAR 0 1
55386: PUSH
55387: LD_INT 124
55389: EQUAL
55390: IFFALSE 55396
// MC_TeleportExit ( ) ;
55392: CALL 71710 0 0
// if event = 125 then
55396: LD_VAR 0 1
55400: PUSH
55401: LD_INT 125
55403: EQUAL
55404: IFFALSE 55410
// MC_Deposits ( ) ;
55406: CALL 72357 0 0
// if event = 126 then
55410: LD_VAR 0 1
55414: PUSH
55415: LD_INT 126
55417: EQUAL
55418: IFFALSE 55424
// MC_RemoteDriver ( ) ;
55420: CALL 72982 0 0
// if event = 200 then
55424: LD_VAR 0 1
55428: PUSH
55429: LD_INT 200
55431: EQUAL
55432: IFFALSE 55438
// MC_Idle ( ) ;
55434: CALL 74931 0 0
// end ;
55438: PPOPN 1
55440: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55441: LD_INT 0
55443: PPUSH
55444: PPUSH
// if not mc_bases [ base ] or not tag then
55445: LD_EXP 43
55449: PUSH
55450: LD_VAR 0 1
55454: ARRAY
55455: NOT
55456: PUSH
55457: LD_VAR 0 2
55461: NOT
55462: OR
55463: IFFALSE 55467
// exit ;
55465: GO 55531
// for i in mc_bases [ base ] union mc_ape [ base ] do
55467: LD_ADDR_VAR 0 4
55471: PUSH
55472: LD_EXP 43
55476: PUSH
55477: LD_VAR 0 1
55481: ARRAY
55482: PUSH
55483: LD_EXP 72
55487: PUSH
55488: LD_VAR 0 1
55492: ARRAY
55493: UNION
55494: PUSH
55495: FOR_IN
55496: IFFALSE 55529
// if GetTag ( i ) = tag then
55498: LD_VAR 0 4
55502: PPUSH
55503: CALL_OW 110
55507: PUSH
55508: LD_VAR 0 2
55512: EQUAL
55513: IFFALSE 55527
// SetTag ( i , 0 ) ;
55515: LD_VAR 0 4
55519: PPUSH
55520: LD_INT 0
55522: PPUSH
55523: CALL_OW 109
55527: GO 55495
55529: POP
55530: POP
// end ;
55531: LD_VAR 0 3
55535: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55536: LD_INT 0
55538: PPUSH
55539: PPUSH
55540: PPUSH
55541: PPUSH
55542: PPUSH
55543: PPUSH
55544: PPUSH
55545: PPUSH
// if not mc_bases then
55546: LD_EXP 43
55550: NOT
55551: IFFALSE 55555
// exit ;
55553: GO 56013
// for i = 1 to mc_bases do
55555: LD_ADDR_VAR 0 2
55559: PUSH
55560: DOUBLE
55561: LD_INT 1
55563: DEC
55564: ST_TO_ADDR
55565: LD_EXP 43
55569: PUSH
55570: FOR_TO
55571: IFFALSE 56011
// begin tmp := MC_ClassCheckReq ( i ) ;
55573: LD_ADDR_VAR 0 4
55577: PUSH
55578: LD_VAR 0 2
55582: PPUSH
55583: CALL 56018 0 1
55587: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55588: LD_ADDR_EXP 84
55592: PUSH
55593: LD_EXP 84
55597: PPUSH
55598: LD_VAR 0 2
55602: PPUSH
55603: LD_VAR 0 4
55607: PPUSH
55608: CALL_OW 1
55612: ST_TO_ADDR
// if not tmp then
55613: LD_VAR 0 4
55617: NOT
55618: IFFALSE 55622
// continue ;
55620: GO 55570
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55622: LD_ADDR_VAR 0 6
55626: PUSH
55627: LD_EXP 43
55631: PUSH
55632: LD_VAR 0 2
55636: ARRAY
55637: PPUSH
55638: LD_INT 2
55640: PUSH
55641: LD_INT 30
55643: PUSH
55644: LD_INT 4
55646: PUSH
55647: EMPTY
55648: LIST
55649: LIST
55650: PUSH
55651: LD_INT 30
55653: PUSH
55654: LD_INT 5
55656: PUSH
55657: EMPTY
55658: LIST
55659: LIST
55660: PUSH
55661: EMPTY
55662: LIST
55663: LIST
55664: LIST
55665: PPUSH
55666: CALL_OW 72
55670: PUSH
55671: LD_EXP 43
55675: PUSH
55676: LD_VAR 0 2
55680: ARRAY
55681: PPUSH
55682: LD_INT 2
55684: PUSH
55685: LD_INT 30
55687: PUSH
55688: LD_INT 0
55690: PUSH
55691: EMPTY
55692: LIST
55693: LIST
55694: PUSH
55695: LD_INT 30
55697: PUSH
55698: LD_INT 1
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: PUSH
55705: EMPTY
55706: LIST
55707: LIST
55708: LIST
55709: PPUSH
55710: CALL_OW 72
55714: PUSH
55715: LD_EXP 43
55719: PUSH
55720: LD_VAR 0 2
55724: ARRAY
55725: PPUSH
55726: LD_INT 30
55728: PUSH
55729: LD_INT 3
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: PPUSH
55736: CALL_OW 72
55740: PUSH
55741: LD_EXP 43
55745: PUSH
55746: LD_VAR 0 2
55750: ARRAY
55751: PPUSH
55752: LD_INT 2
55754: PUSH
55755: LD_INT 30
55757: PUSH
55758: LD_INT 6
55760: PUSH
55761: EMPTY
55762: LIST
55763: LIST
55764: PUSH
55765: LD_INT 30
55767: PUSH
55768: LD_INT 7
55770: PUSH
55771: EMPTY
55772: LIST
55773: LIST
55774: PUSH
55775: LD_INT 30
55777: PUSH
55778: LD_INT 8
55780: PUSH
55781: EMPTY
55782: LIST
55783: LIST
55784: PUSH
55785: EMPTY
55786: LIST
55787: LIST
55788: LIST
55789: LIST
55790: PPUSH
55791: CALL_OW 72
55795: PUSH
55796: EMPTY
55797: LIST
55798: LIST
55799: LIST
55800: LIST
55801: ST_TO_ADDR
// for j = 1 to 4 do
55802: LD_ADDR_VAR 0 3
55806: PUSH
55807: DOUBLE
55808: LD_INT 1
55810: DEC
55811: ST_TO_ADDR
55812: LD_INT 4
55814: PUSH
55815: FOR_TO
55816: IFFALSE 56007
// begin if not tmp [ j ] then
55818: LD_VAR 0 4
55822: PUSH
55823: LD_VAR 0 3
55827: ARRAY
55828: NOT
55829: IFFALSE 55833
// continue ;
55831: GO 55815
// for p in tmp [ j ] do
55833: LD_ADDR_VAR 0 5
55837: PUSH
55838: LD_VAR 0 4
55842: PUSH
55843: LD_VAR 0 3
55847: ARRAY
55848: PUSH
55849: FOR_IN
55850: IFFALSE 56003
// begin if not b [ j ] then
55852: LD_VAR 0 6
55856: PUSH
55857: LD_VAR 0 3
55861: ARRAY
55862: NOT
55863: IFFALSE 55867
// break ;
55865: GO 56003
// e := 0 ;
55867: LD_ADDR_VAR 0 7
55871: PUSH
55872: LD_INT 0
55874: ST_TO_ADDR
// for k in b [ j ] do
55875: LD_ADDR_VAR 0 8
55879: PUSH
55880: LD_VAR 0 6
55884: PUSH
55885: LD_VAR 0 3
55889: ARRAY
55890: PUSH
55891: FOR_IN
55892: IFFALSE 55919
// if IsNotFull ( k ) then
55894: LD_VAR 0 8
55898: PPUSH
55899: CALL 12067 0 1
55903: IFFALSE 55917
// begin e := k ;
55905: LD_ADDR_VAR 0 7
55909: PUSH
55910: LD_VAR 0 8
55914: ST_TO_ADDR
// break ;
55915: GO 55919
// end ;
55917: GO 55891
55919: POP
55920: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55921: LD_VAR 0 7
55925: PUSH
55926: LD_VAR 0 5
55930: PPUSH
55931: LD_VAR 0 7
55935: PPUSH
55936: CALL 45963 0 2
55940: NOT
55941: AND
55942: IFFALSE 56001
// begin if IsInUnit ( p ) then
55944: LD_VAR 0 5
55948: PPUSH
55949: CALL_OW 310
55953: IFFALSE 55964
// ComExitBuilding ( p ) ;
55955: LD_VAR 0 5
55959: PPUSH
55960: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55964: LD_VAR 0 5
55968: PPUSH
55969: LD_VAR 0 7
55973: PPUSH
55974: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55978: LD_VAR 0 5
55982: PPUSH
55983: LD_VAR 0 3
55987: PPUSH
55988: CALL_OW 183
// AddComExitBuilding ( p ) ;
55992: LD_VAR 0 5
55996: PPUSH
55997: CALL_OW 182
// end ; end ;
56001: GO 55849
56003: POP
56004: POP
// end ;
56005: GO 55815
56007: POP
56008: POP
// end ;
56009: GO 55570
56011: POP
56012: POP
// end ;
56013: LD_VAR 0 1
56017: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56018: LD_INT 0
56020: PPUSH
56021: PPUSH
56022: PPUSH
56023: PPUSH
56024: PPUSH
56025: PPUSH
56026: PPUSH
56027: PPUSH
56028: PPUSH
56029: PPUSH
56030: PPUSH
56031: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56032: LD_VAR 0 1
56036: NOT
56037: PUSH
56038: LD_EXP 43
56042: PUSH
56043: LD_VAR 0 1
56047: ARRAY
56048: NOT
56049: OR
56050: PUSH
56051: LD_EXP 43
56055: PUSH
56056: LD_VAR 0 1
56060: ARRAY
56061: PPUSH
56062: LD_INT 2
56064: PUSH
56065: LD_INT 30
56067: PUSH
56068: LD_INT 0
56070: PUSH
56071: EMPTY
56072: LIST
56073: LIST
56074: PUSH
56075: LD_INT 30
56077: PUSH
56078: LD_INT 1
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: PUSH
56085: EMPTY
56086: LIST
56087: LIST
56088: LIST
56089: PPUSH
56090: CALL_OW 72
56094: NOT
56095: OR
56096: IFFALSE 56100
// exit ;
56098: GO 59603
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56100: LD_ADDR_VAR 0 4
56104: PUSH
56105: LD_EXP 43
56109: PUSH
56110: LD_VAR 0 1
56114: ARRAY
56115: PPUSH
56116: LD_INT 2
56118: PUSH
56119: LD_INT 25
56121: PUSH
56122: LD_INT 1
56124: PUSH
56125: EMPTY
56126: LIST
56127: LIST
56128: PUSH
56129: LD_INT 25
56131: PUSH
56132: LD_INT 2
56134: PUSH
56135: EMPTY
56136: LIST
56137: LIST
56138: PUSH
56139: LD_INT 25
56141: PUSH
56142: LD_INT 3
56144: PUSH
56145: EMPTY
56146: LIST
56147: LIST
56148: PUSH
56149: LD_INT 25
56151: PUSH
56152: LD_INT 4
56154: PUSH
56155: EMPTY
56156: LIST
56157: LIST
56158: PUSH
56159: LD_INT 25
56161: PUSH
56162: LD_INT 5
56164: PUSH
56165: EMPTY
56166: LIST
56167: LIST
56168: PUSH
56169: LD_INT 25
56171: PUSH
56172: LD_INT 8
56174: PUSH
56175: EMPTY
56176: LIST
56177: LIST
56178: PUSH
56179: LD_INT 25
56181: PUSH
56182: LD_INT 9
56184: PUSH
56185: EMPTY
56186: LIST
56187: LIST
56188: PUSH
56189: EMPTY
56190: LIST
56191: LIST
56192: LIST
56193: LIST
56194: LIST
56195: LIST
56196: LIST
56197: LIST
56198: PPUSH
56199: CALL_OW 72
56203: ST_TO_ADDR
// if not tmp then
56204: LD_VAR 0 4
56208: NOT
56209: IFFALSE 56213
// exit ;
56211: GO 59603
// for i in tmp do
56213: LD_ADDR_VAR 0 3
56217: PUSH
56218: LD_VAR 0 4
56222: PUSH
56223: FOR_IN
56224: IFFALSE 56255
// if GetTag ( i ) then
56226: LD_VAR 0 3
56230: PPUSH
56231: CALL_OW 110
56235: IFFALSE 56253
// tmp := tmp diff i ;
56237: LD_ADDR_VAR 0 4
56241: PUSH
56242: LD_VAR 0 4
56246: PUSH
56247: LD_VAR 0 3
56251: DIFF
56252: ST_TO_ADDR
56253: GO 56223
56255: POP
56256: POP
// if not tmp then
56257: LD_VAR 0 4
56261: NOT
56262: IFFALSE 56266
// exit ;
56264: GO 59603
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56266: LD_ADDR_VAR 0 5
56270: PUSH
56271: LD_EXP 43
56275: PUSH
56276: LD_VAR 0 1
56280: ARRAY
56281: PPUSH
56282: LD_INT 2
56284: PUSH
56285: LD_INT 25
56287: PUSH
56288: LD_INT 1
56290: PUSH
56291: EMPTY
56292: LIST
56293: LIST
56294: PUSH
56295: LD_INT 25
56297: PUSH
56298: LD_INT 5
56300: PUSH
56301: EMPTY
56302: LIST
56303: LIST
56304: PUSH
56305: LD_INT 25
56307: PUSH
56308: LD_INT 8
56310: PUSH
56311: EMPTY
56312: LIST
56313: LIST
56314: PUSH
56315: LD_INT 25
56317: PUSH
56318: LD_INT 9
56320: PUSH
56321: EMPTY
56322: LIST
56323: LIST
56324: PUSH
56325: EMPTY
56326: LIST
56327: LIST
56328: LIST
56329: LIST
56330: LIST
56331: PPUSH
56332: CALL_OW 72
56336: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56337: LD_ADDR_VAR 0 6
56341: PUSH
56342: LD_EXP 43
56346: PUSH
56347: LD_VAR 0 1
56351: ARRAY
56352: PPUSH
56353: LD_INT 25
56355: PUSH
56356: LD_INT 2
56358: PUSH
56359: EMPTY
56360: LIST
56361: LIST
56362: PPUSH
56363: CALL_OW 72
56367: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56368: LD_ADDR_VAR 0 7
56372: PUSH
56373: LD_EXP 43
56377: PUSH
56378: LD_VAR 0 1
56382: ARRAY
56383: PPUSH
56384: LD_INT 25
56386: PUSH
56387: LD_INT 3
56389: PUSH
56390: EMPTY
56391: LIST
56392: LIST
56393: PPUSH
56394: CALL_OW 72
56398: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56399: LD_ADDR_VAR 0 8
56403: PUSH
56404: LD_EXP 43
56408: PUSH
56409: LD_VAR 0 1
56413: ARRAY
56414: PPUSH
56415: LD_INT 25
56417: PUSH
56418: LD_INT 4
56420: PUSH
56421: EMPTY
56422: LIST
56423: LIST
56424: PUSH
56425: LD_INT 24
56427: PUSH
56428: LD_INT 251
56430: PUSH
56431: EMPTY
56432: LIST
56433: LIST
56434: PUSH
56435: EMPTY
56436: LIST
56437: LIST
56438: PPUSH
56439: CALL_OW 72
56443: ST_TO_ADDR
// if mc_is_defending [ base ] then
56444: LD_EXP 86
56448: PUSH
56449: LD_VAR 0 1
56453: ARRAY
56454: IFFALSE 56915
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56456: LD_ADDR_EXP 85
56460: PUSH
56461: LD_EXP 85
56465: PPUSH
56466: LD_VAR 0 1
56470: PPUSH
56471: LD_INT 4
56473: PPUSH
56474: CALL_OW 1
56478: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56479: LD_ADDR_VAR 0 12
56483: PUSH
56484: LD_EXP 43
56488: PUSH
56489: LD_VAR 0 1
56493: ARRAY
56494: PPUSH
56495: LD_INT 2
56497: PUSH
56498: LD_INT 30
56500: PUSH
56501: LD_INT 4
56503: PUSH
56504: EMPTY
56505: LIST
56506: LIST
56507: PUSH
56508: LD_INT 30
56510: PUSH
56511: LD_INT 5
56513: PUSH
56514: EMPTY
56515: LIST
56516: LIST
56517: PUSH
56518: EMPTY
56519: LIST
56520: LIST
56521: LIST
56522: PPUSH
56523: CALL_OW 72
56527: ST_TO_ADDR
// if not b then
56528: LD_VAR 0 12
56532: NOT
56533: IFFALSE 56537
// exit ;
56535: GO 59603
// p := [ ] ;
56537: LD_ADDR_VAR 0 11
56541: PUSH
56542: EMPTY
56543: ST_TO_ADDR
// if sci >= 2 then
56544: LD_VAR 0 8
56548: PUSH
56549: LD_INT 2
56551: GREATEREQUAL
56552: IFFALSE 56583
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56554: LD_ADDR_VAR 0 8
56558: PUSH
56559: LD_VAR 0 8
56563: PUSH
56564: LD_INT 1
56566: ARRAY
56567: PUSH
56568: LD_VAR 0 8
56572: PUSH
56573: LD_INT 2
56575: ARRAY
56576: PUSH
56577: EMPTY
56578: LIST
56579: LIST
56580: ST_TO_ADDR
56581: GO 56644
// if sci = 1 then
56583: LD_VAR 0 8
56587: PUSH
56588: LD_INT 1
56590: EQUAL
56591: IFFALSE 56612
// sci := [ sci [ 1 ] ] else
56593: LD_ADDR_VAR 0 8
56597: PUSH
56598: LD_VAR 0 8
56602: PUSH
56603: LD_INT 1
56605: ARRAY
56606: PUSH
56607: EMPTY
56608: LIST
56609: ST_TO_ADDR
56610: GO 56644
// if sci = 0 then
56612: LD_VAR 0 8
56616: PUSH
56617: LD_INT 0
56619: EQUAL
56620: IFFALSE 56644
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56622: LD_ADDR_VAR 0 11
56626: PUSH
56627: LD_VAR 0 4
56631: PPUSH
56632: LD_INT 4
56634: PPUSH
56635: CALL 45835 0 2
56639: PUSH
56640: LD_INT 1
56642: ARRAY
56643: ST_TO_ADDR
// if eng > 4 then
56644: LD_VAR 0 6
56648: PUSH
56649: LD_INT 4
56651: GREATER
56652: IFFALSE 56698
// for i = eng downto 4 do
56654: LD_ADDR_VAR 0 3
56658: PUSH
56659: DOUBLE
56660: LD_VAR 0 6
56664: INC
56665: ST_TO_ADDR
56666: LD_INT 4
56668: PUSH
56669: FOR_DOWNTO
56670: IFFALSE 56696
// eng := eng diff eng [ i ] ;
56672: LD_ADDR_VAR 0 6
56676: PUSH
56677: LD_VAR 0 6
56681: PUSH
56682: LD_VAR 0 6
56686: PUSH
56687: LD_VAR 0 3
56691: ARRAY
56692: DIFF
56693: ST_TO_ADDR
56694: GO 56669
56696: POP
56697: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56698: LD_ADDR_VAR 0 4
56702: PUSH
56703: LD_VAR 0 4
56707: PUSH
56708: LD_VAR 0 5
56712: PUSH
56713: LD_VAR 0 6
56717: UNION
56718: PUSH
56719: LD_VAR 0 7
56723: UNION
56724: PUSH
56725: LD_VAR 0 8
56729: UNION
56730: DIFF
56731: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56732: LD_ADDR_VAR 0 13
56736: PUSH
56737: LD_EXP 43
56741: PUSH
56742: LD_VAR 0 1
56746: ARRAY
56747: PPUSH
56748: LD_INT 2
56750: PUSH
56751: LD_INT 30
56753: PUSH
56754: LD_INT 32
56756: PUSH
56757: EMPTY
56758: LIST
56759: LIST
56760: PUSH
56761: LD_INT 30
56763: PUSH
56764: LD_INT 31
56766: PUSH
56767: EMPTY
56768: LIST
56769: LIST
56770: PUSH
56771: EMPTY
56772: LIST
56773: LIST
56774: LIST
56775: PPUSH
56776: CALL_OW 72
56780: PUSH
56781: LD_EXP 43
56785: PUSH
56786: LD_VAR 0 1
56790: ARRAY
56791: PPUSH
56792: LD_INT 2
56794: PUSH
56795: LD_INT 30
56797: PUSH
56798: LD_INT 4
56800: PUSH
56801: EMPTY
56802: LIST
56803: LIST
56804: PUSH
56805: LD_INT 30
56807: PUSH
56808: LD_INT 5
56810: PUSH
56811: EMPTY
56812: LIST
56813: LIST
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: LIST
56819: PPUSH
56820: CALL_OW 72
56824: PUSH
56825: LD_INT 6
56827: MUL
56828: PLUS
56829: ST_TO_ADDR
// if bcount < tmp then
56830: LD_VAR 0 13
56834: PUSH
56835: LD_VAR 0 4
56839: LESS
56840: IFFALSE 56886
// for i = tmp downto bcount do
56842: LD_ADDR_VAR 0 3
56846: PUSH
56847: DOUBLE
56848: LD_VAR 0 4
56852: INC
56853: ST_TO_ADDR
56854: LD_VAR 0 13
56858: PUSH
56859: FOR_DOWNTO
56860: IFFALSE 56884
// tmp := Delete ( tmp , tmp ) ;
56862: LD_ADDR_VAR 0 4
56866: PUSH
56867: LD_VAR 0 4
56871: PPUSH
56872: LD_VAR 0 4
56876: PPUSH
56877: CALL_OW 3
56881: ST_TO_ADDR
56882: GO 56859
56884: POP
56885: POP
// result := [ tmp , 0 , 0 , p ] ;
56886: LD_ADDR_VAR 0 2
56890: PUSH
56891: LD_VAR 0 4
56895: PUSH
56896: LD_INT 0
56898: PUSH
56899: LD_INT 0
56901: PUSH
56902: LD_VAR 0 11
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: LIST
56911: LIST
56912: ST_TO_ADDR
// exit ;
56913: GO 59603
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56915: LD_EXP 43
56919: PUSH
56920: LD_VAR 0 1
56924: ARRAY
56925: PPUSH
56926: LD_INT 2
56928: PUSH
56929: LD_INT 30
56931: PUSH
56932: LD_INT 6
56934: PUSH
56935: EMPTY
56936: LIST
56937: LIST
56938: PUSH
56939: LD_INT 30
56941: PUSH
56942: LD_INT 7
56944: PUSH
56945: EMPTY
56946: LIST
56947: LIST
56948: PUSH
56949: LD_INT 30
56951: PUSH
56952: LD_INT 8
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: PUSH
56959: EMPTY
56960: LIST
56961: LIST
56962: LIST
56963: LIST
56964: PPUSH
56965: CALL_OW 72
56969: NOT
56970: PUSH
56971: LD_EXP 43
56975: PUSH
56976: LD_VAR 0 1
56980: ARRAY
56981: PPUSH
56982: LD_INT 30
56984: PUSH
56985: LD_INT 3
56987: PUSH
56988: EMPTY
56989: LIST
56990: LIST
56991: PPUSH
56992: CALL_OW 72
56996: NOT
56997: AND
56998: IFFALSE 57070
// begin if eng = tmp then
57000: LD_VAR 0 6
57004: PUSH
57005: LD_VAR 0 4
57009: EQUAL
57010: IFFALSE 57014
// exit ;
57012: GO 59603
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57014: LD_ADDR_EXP 85
57018: PUSH
57019: LD_EXP 85
57023: PPUSH
57024: LD_VAR 0 1
57028: PPUSH
57029: LD_INT 1
57031: PPUSH
57032: CALL_OW 1
57036: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57037: LD_ADDR_VAR 0 2
57041: PUSH
57042: LD_INT 0
57044: PUSH
57045: LD_VAR 0 4
57049: PUSH
57050: LD_VAR 0 6
57054: DIFF
57055: PUSH
57056: LD_INT 0
57058: PUSH
57059: LD_INT 0
57061: PUSH
57062: EMPTY
57063: LIST
57064: LIST
57065: LIST
57066: LIST
57067: ST_TO_ADDR
// exit ;
57068: GO 59603
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57070: LD_EXP 70
57074: PUSH
57075: LD_EXP 69
57079: PUSH
57080: LD_VAR 0 1
57084: ARRAY
57085: ARRAY
57086: PUSH
57087: LD_EXP 43
57091: PUSH
57092: LD_VAR 0 1
57096: ARRAY
57097: PPUSH
57098: LD_INT 2
57100: PUSH
57101: LD_INT 30
57103: PUSH
57104: LD_INT 6
57106: PUSH
57107: EMPTY
57108: LIST
57109: LIST
57110: PUSH
57111: LD_INT 30
57113: PUSH
57114: LD_INT 7
57116: PUSH
57117: EMPTY
57118: LIST
57119: LIST
57120: PUSH
57121: LD_INT 30
57123: PUSH
57124: LD_INT 8
57126: PUSH
57127: EMPTY
57128: LIST
57129: LIST
57130: PUSH
57131: EMPTY
57132: LIST
57133: LIST
57134: LIST
57135: LIST
57136: PPUSH
57137: CALL_OW 72
57141: AND
57142: PUSH
57143: LD_EXP 43
57147: PUSH
57148: LD_VAR 0 1
57152: ARRAY
57153: PPUSH
57154: LD_INT 30
57156: PUSH
57157: LD_INT 3
57159: PUSH
57160: EMPTY
57161: LIST
57162: LIST
57163: PPUSH
57164: CALL_OW 72
57168: NOT
57169: AND
57170: IFFALSE 57384
// begin if sci >= 6 then
57172: LD_VAR 0 8
57176: PUSH
57177: LD_INT 6
57179: GREATEREQUAL
57180: IFFALSE 57184
// exit ;
57182: GO 59603
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57184: LD_ADDR_EXP 85
57188: PUSH
57189: LD_EXP 85
57193: PPUSH
57194: LD_VAR 0 1
57198: PPUSH
57199: LD_INT 2
57201: PPUSH
57202: CALL_OW 1
57206: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57207: LD_ADDR_VAR 0 9
57211: PUSH
57212: LD_VAR 0 4
57216: PUSH
57217: LD_VAR 0 8
57221: DIFF
57222: PPUSH
57223: LD_INT 4
57225: PPUSH
57226: CALL 45835 0 2
57230: ST_TO_ADDR
// p := [ ] ;
57231: LD_ADDR_VAR 0 11
57235: PUSH
57236: EMPTY
57237: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57238: LD_VAR 0 8
57242: PUSH
57243: LD_INT 6
57245: LESS
57246: PUSH
57247: LD_VAR 0 9
57251: PUSH
57252: LD_INT 6
57254: GREATER
57255: AND
57256: IFFALSE 57337
// begin for i = 1 to 6 - sci do
57258: LD_ADDR_VAR 0 3
57262: PUSH
57263: DOUBLE
57264: LD_INT 1
57266: DEC
57267: ST_TO_ADDR
57268: LD_INT 6
57270: PUSH
57271: LD_VAR 0 8
57275: MINUS
57276: PUSH
57277: FOR_TO
57278: IFFALSE 57333
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57280: LD_ADDR_VAR 0 11
57284: PUSH
57285: LD_VAR 0 11
57289: PPUSH
57290: LD_VAR 0 11
57294: PUSH
57295: LD_INT 1
57297: PLUS
57298: PPUSH
57299: LD_VAR 0 9
57303: PUSH
57304: LD_INT 1
57306: ARRAY
57307: PPUSH
57308: CALL_OW 2
57312: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57313: LD_ADDR_VAR 0 9
57317: PUSH
57318: LD_VAR 0 9
57322: PPUSH
57323: LD_INT 1
57325: PPUSH
57326: CALL_OW 3
57330: ST_TO_ADDR
// end ;
57331: GO 57277
57333: POP
57334: POP
// end else
57335: GO 57357
// if sort then
57337: LD_VAR 0 9
57341: IFFALSE 57357
// p := sort [ 1 ] ;
57343: LD_ADDR_VAR 0 11
57347: PUSH
57348: LD_VAR 0 9
57352: PUSH
57353: LD_INT 1
57355: ARRAY
57356: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57357: LD_ADDR_VAR 0 2
57361: PUSH
57362: LD_INT 0
57364: PUSH
57365: LD_INT 0
57367: PUSH
57368: LD_INT 0
57370: PUSH
57371: LD_VAR 0 11
57375: PUSH
57376: EMPTY
57377: LIST
57378: LIST
57379: LIST
57380: LIST
57381: ST_TO_ADDR
// exit ;
57382: GO 59603
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57384: LD_EXP 70
57388: PUSH
57389: LD_EXP 69
57393: PUSH
57394: LD_VAR 0 1
57398: ARRAY
57399: ARRAY
57400: PUSH
57401: LD_EXP 43
57405: PUSH
57406: LD_VAR 0 1
57410: ARRAY
57411: PPUSH
57412: LD_INT 2
57414: PUSH
57415: LD_INT 30
57417: PUSH
57418: LD_INT 6
57420: PUSH
57421: EMPTY
57422: LIST
57423: LIST
57424: PUSH
57425: LD_INT 30
57427: PUSH
57428: LD_INT 7
57430: PUSH
57431: EMPTY
57432: LIST
57433: LIST
57434: PUSH
57435: LD_INT 30
57437: PUSH
57438: LD_INT 8
57440: PUSH
57441: EMPTY
57442: LIST
57443: LIST
57444: PUSH
57445: EMPTY
57446: LIST
57447: LIST
57448: LIST
57449: LIST
57450: PPUSH
57451: CALL_OW 72
57455: AND
57456: PUSH
57457: LD_EXP 43
57461: PUSH
57462: LD_VAR 0 1
57466: ARRAY
57467: PPUSH
57468: LD_INT 30
57470: PUSH
57471: LD_INT 3
57473: PUSH
57474: EMPTY
57475: LIST
57476: LIST
57477: PPUSH
57478: CALL_OW 72
57482: AND
57483: IFFALSE 58217
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57485: LD_ADDR_EXP 85
57489: PUSH
57490: LD_EXP 85
57494: PPUSH
57495: LD_VAR 0 1
57499: PPUSH
57500: LD_INT 3
57502: PPUSH
57503: CALL_OW 1
57507: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57508: LD_ADDR_VAR 0 2
57512: PUSH
57513: LD_INT 0
57515: PUSH
57516: LD_INT 0
57518: PUSH
57519: LD_INT 0
57521: PUSH
57522: LD_INT 0
57524: PUSH
57525: EMPTY
57526: LIST
57527: LIST
57528: LIST
57529: LIST
57530: ST_TO_ADDR
// if not eng then
57531: LD_VAR 0 6
57535: NOT
57536: IFFALSE 57599
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57538: LD_ADDR_VAR 0 11
57542: PUSH
57543: LD_VAR 0 4
57547: PPUSH
57548: LD_INT 2
57550: PPUSH
57551: CALL 45835 0 2
57555: PUSH
57556: LD_INT 1
57558: ARRAY
57559: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57560: LD_ADDR_VAR 0 2
57564: PUSH
57565: LD_VAR 0 2
57569: PPUSH
57570: LD_INT 2
57572: PPUSH
57573: LD_VAR 0 11
57577: PPUSH
57578: CALL_OW 1
57582: ST_TO_ADDR
// tmp := tmp diff p ;
57583: LD_ADDR_VAR 0 4
57587: PUSH
57588: LD_VAR 0 4
57592: PUSH
57593: LD_VAR 0 11
57597: DIFF
57598: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57599: LD_VAR 0 4
57603: PUSH
57604: LD_VAR 0 8
57608: PUSH
57609: LD_INT 6
57611: LESS
57612: AND
57613: IFFALSE 57801
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57615: LD_ADDR_VAR 0 9
57619: PUSH
57620: LD_VAR 0 4
57624: PUSH
57625: LD_VAR 0 8
57629: PUSH
57630: LD_VAR 0 7
57634: UNION
57635: DIFF
57636: PPUSH
57637: LD_INT 4
57639: PPUSH
57640: CALL 45835 0 2
57644: ST_TO_ADDR
// p := [ ] ;
57645: LD_ADDR_VAR 0 11
57649: PUSH
57650: EMPTY
57651: ST_TO_ADDR
// if sort then
57652: LD_VAR 0 9
57656: IFFALSE 57772
// for i = 1 to 6 - sci do
57658: LD_ADDR_VAR 0 3
57662: PUSH
57663: DOUBLE
57664: LD_INT 1
57666: DEC
57667: ST_TO_ADDR
57668: LD_INT 6
57670: PUSH
57671: LD_VAR 0 8
57675: MINUS
57676: PUSH
57677: FOR_TO
57678: IFFALSE 57770
// begin if i = sort then
57680: LD_VAR 0 3
57684: PUSH
57685: LD_VAR 0 9
57689: EQUAL
57690: IFFALSE 57694
// break ;
57692: GO 57770
// if GetClass ( i ) = 4 then
57694: LD_VAR 0 3
57698: PPUSH
57699: CALL_OW 257
57703: PUSH
57704: LD_INT 4
57706: EQUAL
57707: IFFALSE 57711
// continue ;
57709: GO 57677
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57711: LD_ADDR_VAR 0 11
57715: PUSH
57716: LD_VAR 0 11
57720: PPUSH
57721: LD_VAR 0 11
57725: PUSH
57726: LD_INT 1
57728: PLUS
57729: PPUSH
57730: LD_VAR 0 9
57734: PUSH
57735: LD_VAR 0 3
57739: ARRAY
57740: PPUSH
57741: CALL_OW 2
57745: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57746: LD_ADDR_VAR 0 4
57750: PUSH
57751: LD_VAR 0 4
57755: PUSH
57756: LD_VAR 0 9
57760: PUSH
57761: LD_VAR 0 3
57765: ARRAY
57766: DIFF
57767: ST_TO_ADDR
// end ;
57768: GO 57677
57770: POP
57771: POP
// if p then
57772: LD_VAR 0 11
57776: IFFALSE 57801
// result := Replace ( result , 4 , p ) ;
57778: LD_ADDR_VAR 0 2
57782: PUSH
57783: LD_VAR 0 2
57787: PPUSH
57788: LD_INT 4
57790: PPUSH
57791: LD_VAR 0 11
57795: PPUSH
57796: CALL_OW 1
57800: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57801: LD_VAR 0 4
57805: PUSH
57806: LD_VAR 0 7
57810: PUSH
57811: LD_INT 6
57813: LESS
57814: AND
57815: IFFALSE 58003
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57817: LD_ADDR_VAR 0 9
57821: PUSH
57822: LD_VAR 0 4
57826: PUSH
57827: LD_VAR 0 8
57831: PUSH
57832: LD_VAR 0 7
57836: UNION
57837: DIFF
57838: PPUSH
57839: LD_INT 3
57841: PPUSH
57842: CALL 45835 0 2
57846: ST_TO_ADDR
// p := [ ] ;
57847: LD_ADDR_VAR 0 11
57851: PUSH
57852: EMPTY
57853: ST_TO_ADDR
// if sort then
57854: LD_VAR 0 9
57858: IFFALSE 57974
// for i = 1 to 6 - mech do
57860: LD_ADDR_VAR 0 3
57864: PUSH
57865: DOUBLE
57866: LD_INT 1
57868: DEC
57869: ST_TO_ADDR
57870: LD_INT 6
57872: PUSH
57873: LD_VAR 0 7
57877: MINUS
57878: PUSH
57879: FOR_TO
57880: IFFALSE 57972
// begin if i = sort then
57882: LD_VAR 0 3
57886: PUSH
57887: LD_VAR 0 9
57891: EQUAL
57892: IFFALSE 57896
// break ;
57894: GO 57972
// if GetClass ( i ) = 3 then
57896: LD_VAR 0 3
57900: PPUSH
57901: CALL_OW 257
57905: PUSH
57906: LD_INT 3
57908: EQUAL
57909: IFFALSE 57913
// continue ;
57911: GO 57879
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57913: LD_ADDR_VAR 0 11
57917: PUSH
57918: LD_VAR 0 11
57922: PPUSH
57923: LD_VAR 0 11
57927: PUSH
57928: LD_INT 1
57930: PLUS
57931: PPUSH
57932: LD_VAR 0 9
57936: PUSH
57937: LD_VAR 0 3
57941: ARRAY
57942: PPUSH
57943: CALL_OW 2
57947: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57948: LD_ADDR_VAR 0 4
57952: PUSH
57953: LD_VAR 0 4
57957: PUSH
57958: LD_VAR 0 9
57962: PUSH
57963: LD_VAR 0 3
57967: ARRAY
57968: DIFF
57969: ST_TO_ADDR
// end ;
57970: GO 57879
57972: POP
57973: POP
// if p then
57974: LD_VAR 0 11
57978: IFFALSE 58003
// result := Replace ( result , 3 , p ) ;
57980: LD_ADDR_VAR 0 2
57984: PUSH
57985: LD_VAR 0 2
57989: PPUSH
57990: LD_INT 3
57992: PPUSH
57993: LD_VAR 0 11
57997: PPUSH
57998: CALL_OW 1
58002: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58003: LD_VAR 0 4
58007: PUSH
58008: LD_INT 6
58010: GREATER
58011: PUSH
58012: LD_VAR 0 6
58016: PUSH
58017: LD_INT 6
58019: LESS
58020: AND
58021: IFFALSE 58215
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58023: LD_ADDR_VAR 0 9
58027: PUSH
58028: LD_VAR 0 4
58032: PUSH
58033: LD_VAR 0 8
58037: PUSH
58038: LD_VAR 0 7
58042: UNION
58043: PUSH
58044: LD_VAR 0 6
58048: UNION
58049: DIFF
58050: PPUSH
58051: LD_INT 2
58053: PPUSH
58054: CALL 45835 0 2
58058: ST_TO_ADDR
// p := [ ] ;
58059: LD_ADDR_VAR 0 11
58063: PUSH
58064: EMPTY
58065: ST_TO_ADDR
// if sort then
58066: LD_VAR 0 9
58070: IFFALSE 58186
// for i = 1 to 6 - eng do
58072: LD_ADDR_VAR 0 3
58076: PUSH
58077: DOUBLE
58078: LD_INT 1
58080: DEC
58081: ST_TO_ADDR
58082: LD_INT 6
58084: PUSH
58085: LD_VAR 0 6
58089: MINUS
58090: PUSH
58091: FOR_TO
58092: IFFALSE 58184
// begin if i = sort then
58094: LD_VAR 0 3
58098: PUSH
58099: LD_VAR 0 9
58103: EQUAL
58104: IFFALSE 58108
// break ;
58106: GO 58184
// if GetClass ( i ) = 2 then
58108: LD_VAR 0 3
58112: PPUSH
58113: CALL_OW 257
58117: PUSH
58118: LD_INT 2
58120: EQUAL
58121: IFFALSE 58125
// continue ;
58123: GO 58091
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58125: LD_ADDR_VAR 0 11
58129: PUSH
58130: LD_VAR 0 11
58134: PPUSH
58135: LD_VAR 0 11
58139: PUSH
58140: LD_INT 1
58142: PLUS
58143: PPUSH
58144: LD_VAR 0 9
58148: PUSH
58149: LD_VAR 0 3
58153: ARRAY
58154: PPUSH
58155: CALL_OW 2
58159: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58160: LD_ADDR_VAR 0 4
58164: PUSH
58165: LD_VAR 0 4
58169: PUSH
58170: LD_VAR 0 9
58174: PUSH
58175: LD_VAR 0 3
58179: ARRAY
58180: DIFF
58181: ST_TO_ADDR
// end ;
58182: GO 58091
58184: POP
58185: POP
// if p then
58186: LD_VAR 0 11
58190: IFFALSE 58215
// result := Replace ( result , 2 , p ) ;
58192: LD_ADDR_VAR 0 2
58196: PUSH
58197: LD_VAR 0 2
58201: PPUSH
58202: LD_INT 2
58204: PPUSH
58205: LD_VAR 0 11
58209: PPUSH
58210: CALL_OW 1
58214: ST_TO_ADDR
// end ; exit ;
58215: GO 59603
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58217: LD_EXP 70
58221: PUSH
58222: LD_EXP 69
58226: PUSH
58227: LD_VAR 0 1
58231: ARRAY
58232: ARRAY
58233: NOT
58234: PUSH
58235: LD_EXP 43
58239: PUSH
58240: LD_VAR 0 1
58244: ARRAY
58245: PPUSH
58246: LD_INT 30
58248: PUSH
58249: LD_INT 3
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: PPUSH
58256: CALL_OW 72
58260: AND
58261: PUSH
58262: LD_EXP 48
58266: PUSH
58267: LD_VAR 0 1
58271: ARRAY
58272: AND
58273: IFFALSE 58881
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58275: LD_ADDR_EXP 85
58279: PUSH
58280: LD_EXP 85
58284: PPUSH
58285: LD_VAR 0 1
58289: PPUSH
58290: LD_INT 5
58292: PPUSH
58293: CALL_OW 1
58297: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58298: LD_ADDR_VAR 0 2
58302: PUSH
58303: LD_INT 0
58305: PUSH
58306: LD_INT 0
58308: PUSH
58309: LD_INT 0
58311: PUSH
58312: LD_INT 0
58314: PUSH
58315: EMPTY
58316: LIST
58317: LIST
58318: LIST
58319: LIST
58320: ST_TO_ADDR
// if sci > 1 then
58321: LD_VAR 0 8
58325: PUSH
58326: LD_INT 1
58328: GREATER
58329: IFFALSE 58357
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58331: LD_ADDR_VAR 0 4
58335: PUSH
58336: LD_VAR 0 4
58340: PUSH
58341: LD_VAR 0 8
58345: PUSH
58346: LD_VAR 0 8
58350: PUSH
58351: LD_INT 1
58353: ARRAY
58354: DIFF
58355: DIFF
58356: ST_TO_ADDR
// if tmp and not sci then
58357: LD_VAR 0 4
58361: PUSH
58362: LD_VAR 0 8
58366: NOT
58367: AND
58368: IFFALSE 58437
// begin sort := SortBySkill ( tmp , 4 ) ;
58370: LD_ADDR_VAR 0 9
58374: PUSH
58375: LD_VAR 0 4
58379: PPUSH
58380: LD_INT 4
58382: PPUSH
58383: CALL 45835 0 2
58387: ST_TO_ADDR
// if sort then
58388: LD_VAR 0 9
58392: IFFALSE 58408
// p := sort [ 1 ] ;
58394: LD_ADDR_VAR 0 11
58398: PUSH
58399: LD_VAR 0 9
58403: PUSH
58404: LD_INT 1
58406: ARRAY
58407: ST_TO_ADDR
// if p then
58408: LD_VAR 0 11
58412: IFFALSE 58437
// result := Replace ( result , 4 , p ) ;
58414: LD_ADDR_VAR 0 2
58418: PUSH
58419: LD_VAR 0 2
58423: PPUSH
58424: LD_INT 4
58426: PPUSH
58427: LD_VAR 0 11
58431: PPUSH
58432: CALL_OW 1
58436: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58437: LD_ADDR_VAR 0 4
58441: PUSH
58442: LD_VAR 0 4
58446: PUSH
58447: LD_VAR 0 7
58451: DIFF
58452: ST_TO_ADDR
// if tmp and mech < 6 then
58453: LD_VAR 0 4
58457: PUSH
58458: LD_VAR 0 7
58462: PUSH
58463: LD_INT 6
58465: LESS
58466: AND
58467: IFFALSE 58655
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58469: LD_ADDR_VAR 0 9
58473: PUSH
58474: LD_VAR 0 4
58478: PUSH
58479: LD_VAR 0 8
58483: PUSH
58484: LD_VAR 0 7
58488: UNION
58489: DIFF
58490: PPUSH
58491: LD_INT 3
58493: PPUSH
58494: CALL 45835 0 2
58498: ST_TO_ADDR
// p := [ ] ;
58499: LD_ADDR_VAR 0 11
58503: PUSH
58504: EMPTY
58505: ST_TO_ADDR
// if sort then
58506: LD_VAR 0 9
58510: IFFALSE 58626
// for i = 1 to 6 - mech do
58512: LD_ADDR_VAR 0 3
58516: PUSH
58517: DOUBLE
58518: LD_INT 1
58520: DEC
58521: ST_TO_ADDR
58522: LD_INT 6
58524: PUSH
58525: LD_VAR 0 7
58529: MINUS
58530: PUSH
58531: FOR_TO
58532: IFFALSE 58624
// begin if i = sort then
58534: LD_VAR 0 3
58538: PUSH
58539: LD_VAR 0 9
58543: EQUAL
58544: IFFALSE 58548
// break ;
58546: GO 58624
// if GetClass ( i ) = 3 then
58548: LD_VAR 0 3
58552: PPUSH
58553: CALL_OW 257
58557: PUSH
58558: LD_INT 3
58560: EQUAL
58561: IFFALSE 58565
// continue ;
58563: GO 58531
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58565: LD_ADDR_VAR 0 11
58569: PUSH
58570: LD_VAR 0 11
58574: PPUSH
58575: LD_VAR 0 11
58579: PUSH
58580: LD_INT 1
58582: PLUS
58583: PPUSH
58584: LD_VAR 0 9
58588: PUSH
58589: LD_VAR 0 3
58593: ARRAY
58594: PPUSH
58595: CALL_OW 2
58599: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58600: LD_ADDR_VAR 0 4
58604: PUSH
58605: LD_VAR 0 4
58609: PUSH
58610: LD_VAR 0 9
58614: PUSH
58615: LD_VAR 0 3
58619: ARRAY
58620: DIFF
58621: ST_TO_ADDR
// end ;
58622: GO 58531
58624: POP
58625: POP
// if p then
58626: LD_VAR 0 11
58630: IFFALSE 58655
// result := Replace ( result , 3 , p ) ;
58632: LD_ADDR_VAR 0 2
58636: PUSH
58637: LD_VAR 0 2
58641: PPUSH
58642: LD_INT 3
58644: PPUSH
58645: LD_VAR 0 11
58649: PPUSH
58650: CALL_OW 1
58654: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58655: LD_ADDR_VAR 0 4
58659: PUSH
58660: LD_VAR 0 4
58664: PUSH
58665: LD_VAR 0 6
58669: DIFF
58670: ST_TO_ADDR
// if tmp and eng < 6 then
58671: LD_VAR 0 4
58675: PUSH
58676: LD_VAR 0 6
58680: PUSH
58681: LD_INT 6
58683: LESS
58684: AND
58685: IFFALSE 58879
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58687: LD_ADDR_VAR 0 9
58691: PUSH
58692: LD_VAR 0 4
58696: PUSH
58697: LD_VAR 0 8
58701: PUSH
58702: LD_VAR 0 7
58706: UNION
58707: PUSH
58708: LD_VAR 0 6
58712: UNION
58713: DIFF
58714: PPUSH
58715: LD_INT 2
58717: PPUSH
58718: CALL 45835 0 2
58722: ST_TO_ADDR
// p := [ ] ;
58723: LD_ADDR_VAR 0 11
58727: PUSH
58728: EMPTY
58729: ST_TO_ADDR
// if sort then
58730: LD_VAR 0 9
58734: IFFALSE 58850
// for i = 1 to 6 - eng do
58736: LD_ADDR_VAR 0 3
58740: PUSH
58741: DOUBLE
58742: LD_INT 1
58744: DEC
58745: ST_TO_ADDR
58746: LD_INT 6
58748: PUSH
58749: LD_VAR 0 6
58753: MINUS
58754: PUSH
58755: FOR_TO
58756: IFFALSE 58848
// begin if i = sort then
58758: LD_VAR 0 3
58762: PUSH
58763: LD_VAR 0 9
58767: EQUAL
58768: IFFALSE 58772
// break ;
58770: GO 58848
// if GetClass ( i ) = 2 then
58772: LD_VAR 0 3
58776: PPUSH
58777: CALL_OW 257
58781: PUSH
58782: LD_INT 2
58784: EQUAL
58785: IFFALSE 58789
// continue ;
58787: GO 58755
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58789: LD_ADDR_VAR 0 11
58793: PUSH
58794: LD_VAR 0 11
58798: PPUSH
58799: LD_VAR 0 11
58803: PUSH
58804: LD_INT 1
58806: PLUS
58807: PPUSH
58808: LD_VAR 0 9
58812: PUSH
58813: LD_VAR 0 3
58817: ARRAY
58818: PPUSH
58819: CALL_OW 2
58823: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58824: LD_ADDR_VAR 0 4
58828: PUSH
58829: LD_VAR 0 4
58833: PUSH
58834: LD_VAR 0 9
58838: PUSH
58839: LD_VAR 0 3
58843: ARRAY
58844: DIFF
58845: ST_TO_ADDR
// end ;
58846: GO 58755
58848: POP
58849: POP
// if p then
58850: LD_VAR 0 11
58854: IFFALSE 58879
// result := Replace ( result , 2 , p ) ;
58856: LD_ADDR_VAR 0 2
58860: PUSH
58861: LD_VAR 0 2
58865: PPUSH
58866: LD_INT 2
58868: PPUSH
58869: LD_VAR 0 11
58873: PPUSH
58874: CALL_OW 1
58878: ST_TO_ADDR
// end ; exit ;
58879: GO 59603
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58881: LD_EXP 70
58885: PUSH
58886: LD_EXP 69
58890: PUSH
58891: LD_VAR 0 1
58895: ARRAY
58896: ARRAY
58897: NOT
58898: PUSH
58899: LD_EXP 43
58903: PUSH
58904: LD_VAR 0 1
58908: ARRAY
58909: PPUSH
58910: LD_INT 30
58912: PUSH
58913: LD_INT 3
58915: PUSH
58916: EMPTY
58917: LIST
58918: LIST
58919: PPUSH
58920: CALL_OW 72
58924: AND
58925: PUSH
58926: LD_EXP 48
58930: PUSH
58931: LD_VAR 0 1
58935: ARRAY
58936: NOT
58937: AND
58938: IFFALSE 59603
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58940: LD_ADDR_EXP 85
58944: PUSH
58945: LD_EXP 85
58949: PPUSH
58950: LD_VAR 0 1
58954: PPUSH
58955: LD_INT 6
58957: PPUSH
58958: CALL_OW 1
58962: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58963: LD_ADDR_VAR 0 2
58967: PUSH
58968: LD_INT 0
58970: PUSH
58971: LD_INT 0
58973: PUSH
58974: LD_INT 0
58976: PUSH
58977: LD_INT 0
58979: PUSH
58980: EMPTY
58981: LIST
58982: LIST
58983: LIST
58984: LIST
58985: ST_TO_ADDR
// if sci >= 1 then
58986: LD_VAR 0 8
58990: PUSH
58991: LD_INT 1
58993: GREATEREQUAL
58994: IFFALSE 59016
// tmp := tmp diff sci [ 1 ] ;
58996: LD_ADDR_VAR 0 4
59000: PUSH
59001: LD_VAR 0 4
59005: PUSH
59006: LD_VAR 0 8
59010: PUSH
59011: LD_INT 1
59013: ARRAY
59014: DIFF
59015: ST_TO_ADDR
// if tmp and not sci then
59016: LD_VAR 0 4
59020: PUSH
59021: LD_VAR 0 8
59025: NOT
59026: AND
59027: IFFALSE 59096
// begin sort := SortBySkill ( tmp , 4 ) ;
59029: LD_ADDR_VAR 0 9
59033: PUSH
59034: LD_VAR 0 4
59038: PPUSH
59039: LD_INT 4
59041: PPUSH
59042: CALL 45835 0 2
59046: ST_TO_ADDR
// if sort then
59047: LD_VAR 0 9
59051: IFFALSE 59067
// p := sort [ 1 ] ;
59053: LD_ADDR_VAR 0 11
59057: PUSH
59058: LD_VAR 0 9
59062: PUSH
59063: LD_INT 1
59065: ARRAY
59066: ST_TO_ADDR
// if p then
59067: LD_VAR 0 11
59071: IFFALSE 59096
// result := Replace ( result , 4 , p ) ;
59073: LD_ADDR_VAR 0 2
59077: PUSH
59078: LD_VAR 0 2
59082: PPUSH
59083: LD_INT 4
59085: PPUSH
59086: LD_VAR 0 11
59090: PPUSH
59091: CALL_OW 1
59095: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59096: LD_ADDR_VAR 0 4
59100: PUSH
59101: LD_VAR 0 4
59105: PUSH
59106: LD_VAR 0 7
59110: DIFF
59111: ST_TO_ADDR
// if tmp and mech < 6 then
59112: LD_VAR 0 4
59116: PUSH
59117: LD_VAR 0 7
59121: PUSH
59122: LD_INT 6
59124: LESS
59125: AND
59126: IFFALSE 59308
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59128: LD_ADDR_VAR 0 9
59132: PUSH
59133: LD_VAR 0 4
59137: PUSH
59138: LD_VAR 0 7
59142: DIFF
59143: PPUSH
59144: LD_INT 3
59146: PPUSH
59147: CALL 45835 0 2
59151: ST_TO_ADDR
// p := [ ] ;
59152: LD_ADDR_VAR 0 11
59156: PUSH
59157: EMPTY
59158: ST_TO_ADDR
// if sort then
59159: LD_VAR 0 9
59163: IFFALSE 59279
// for i = 1 to 6 - mech do
59165: LD_ADDR_VAR 0 3
59169: PUSH
59170: DOUBLE
59171: LD_INT 1
59173: DEC
59174: ST_TO_ADDR
59175: LD_INT 6
59177: PUSH
59178: LD_VAR 0 7
59182: MINUS
59183: PUSH
59184: FOR_TO
59185: IFFALSE 59277
// begin if i = sort then
59187: LD_VAR 0 3
59191: PUSH
59192: LD_VAR 0 9
59196: EQUAL
59197: IFFALSE 59201
// break ;
59199: GO 59277
// if GetClass ( i ) = 3 then
59201: LD_VAR 0 3
59205: PPUSH
59206: CALL_OW 257
59210: PUSH
59211: LD_INT 3
59213: EQUAL
59214: IFFALSE 59218
// continue ;
59216: GO 59184
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59218: LD_ADDR_VAR 0 11
59222: PUSH
59223: LD_VAR 0 11
59227: PPUSH
59228: LD_VAR 0 11
59232: PUSH
59233: LD_INT 1
59235: PLUS
59236: PPUSH
59237: LD_VAR 0 9
59241: PUSH
59242: LD_VAR 0 3
59246: ARRAY
59247: PPUSH
59248: CALL_OW 2
59252: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59253: LD_ADDR_VAR 0 4
59257: PUSH
59258: LD_VAR 0 4
59262: PUSH
59263: LD_VAR 0 9
59267: PUSH
59268: LD_VAR 0 3
59272: ARRAY
59273: DIFF
59274: ST_TO_ADDR
// end ;
59275: GO 59184
59277: POP
59278: POP
// if p then
59279: LD_VAR 0 11
59283: IFFALSE 59308
// result := Replace ( result , 3 , p ) ;
59285: LD_ADDR_VAR 0 2
59289: PUSH
59290: LD_VAR 0 2
59294: PPUSH
59295: LD_INT 3
59297: PPUSH
59298: LD_VAR 0 11
59302: PPUSH
59303: CALL_OW 1
59307: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59308: LD_ADDR_VAR 0 4
59312: PUSH
59313: LD_VAR 0 4
59317: PUSH
59318: LD_VAR 0 6
59322: DIFF
59323: ST_TO_ADDR
// if tmp and eng < 4 then
59324: LD_VAR 0 4
59328: PUSH
59329: LD_VAR 0 6
59333: PUSH
59334: LD_INT 4
59336: LESS
59337: AND
59338: IFFALSE 59528
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59340: LD_ADDR_VAR 0 9
59344: PUSH
59345: LD_VAR 0 4
59349: PUSH
59350: LD_VAR 0 7
59354: PUSH
59355: LD_VAR 0 6
59359: UNION
59360: DIFF
59361: PPUSH
59362: LD_INT 2
59364: PPUSH
59365: CALL 45835 0 2
59369: ST_TO_ADDR
// p := [ ] ;
59370: LD_ADDR_VAR 0 11
59374: PUSH
59375: EMPTY
59376: ST_TO_ADDR
// if sort then
59377: LD_VAR 0 9
59381: IFFALSE 59497
// for i = 1 to 4 - eng do
59383: LD_ADDR_VAR 0 3
59387: PUSH
59388: DOUBLE
59389: LD_INT 1
59391: DEC
59392: ST_TO_ADDR
59393: LD_INT 4
59395: PUSH
59396: LD_VAR 0 6
59400: MINUS
59401: PUSH
59402: FOR_TO
59403: IFFALSE 59495
// begin if i = sort then
59405: LD_VAR 0 3
59409: PUSH
59410: LD_VAR 0 9
59414: EQUAL
59415: IFFALSE 59419
// break ;
59417: GO 59495
// if GetClass ( i ) = 2 then
59419: LD_VAR 0 3
59423: PPUSH
59424: CALL_OW 257
59428: PUSH
59429: LD_INT 2
59431: EQUAL
59432: IFFALSE 59436
// continue ;
59434: GO 59402
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59436: LD_ADDR_VAR 0 11
59440: PUSH
59441: LD_VAR 0 11
59445: PPUSH
59446: LD_VAR 0 11
59450: PUSH
59451: LD_INT 1
59453: PLUS
59454: PPUSH
59455: LD_VAR 0 9
59459: PUSH
59460: LD_VAR 0 3
59464: ARRAY
59465: PPUSH
59466: CALL_OW 2
59470: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59471: LD_ADDR_VAR 0 4
59475: PUSH
59476: LD_VAR 0 4
59480: PUSH
59481: LD_VAR 0 9
59485: PUSH
59486: LD_VAR 0 3
59490: ARRAY
59491: DIFF
59492: ST_TO_ADDR
// end ;
59493: GO 59402
59495: POP
59496: POP
// if p then
59497: LD_VAR 0 11
59501: IFFALSE 59526
// result := Replace ( result , 2 , p ) ;
59503: LD_ADDR_VAR 0 2
59507: PUSH
59508: LD_VAR 0 2
59512: PPUSH
59513: LD_INT 2
59515: PPUSH
59516: LD_VAR 0 11
59520: PPUSH
59521: CALL_OW 1
59525: ST_TO_ADDR
// end else
59526: GO 59572
// for i = eng downto 5 do
59528: LD_ADDR_VAR 0 3
59532: PUSH
59533: DOUBLE
59534: LD_VAR 0 6
59538: INC
59539: ST_TO_ADDR
59540: LD_INT 5
59542: PUSH
59543: FOR_DOWNTO
59544: IFFALSE 59570
// tmp := tmp union eng [ i ] ;
59546: LD_ADDR_VAR 0 4
59550: PUSH
59551: LD_VAR 0 4
59555: PUSH
59556: LD_VAR 0 6
59560: PUSH
59561: LD_VAR 0 3
59565: ARRAY
59566: UNION
59567: ST_TO_ADDR
59568: GO 59543
59570: POP
59571: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59572: LD_ADDR_VAR 0 2
59576: PUSH
59577: LD_VAR 0 2
59581: PPUSH
59582: LD_INT 1
59584: PPUSH
59585: LD_VAR 0 4
59589: PUSH
59590: LD_VAR 0 5
59594: DIFF
59595: PPUSH
59596: CALL_OW 1
59600: ST_TO_ADDR
// exit ;
59601: GO 59603
// end ; end ;
59603: LD_VAR 0 2
59607: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59608: LD_INT 0
59610: PPUSH
59611: PPUSH
59612: PPUSH
// if not mc_bases then
59613: LD_EXP 43
59617: NOT
59618: IFFALSE 59622
// exit ;
59620: GO 59764
// for i = 1 to mc_bases do
59622: LD_ADDR_VAR 0 2
59626: PUSH
59627: DOUBLE
59628: LD_INT 1
59630: DEC
59631: ST_TO_ADDR
59632: LD_EXP 43
59636: PUSH
59637: FOR_TO
59638: IFFALSE 59755
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59640: LD_ADDR_VAR 0 3
59644: PUSH
59645: LD_EXP 43
59649: PUSH
59650: LD_VAR 0 2
59654: ARRAY
59655: PPUSH
59656: LD_INT 21
59658: PUSH
59659: LD_INT 3
59661: PUSH
59662: EMPTY
59663: LIST
59664: LIST
59665: PUSH
59666: LD_INT 3
59668: PUSH
59669: LD_INT 2
59671: PUSH
59672: LD_INT 30
59674: PUSH
59675: LD_INT 29
59677: PUSH
59678: EMPTY
59679: LIST
59680: LIST
59681: PUSH
59682: LD_INT 30
59684: PUSH
59685: LD_INT 30
59687: PUSH
59688: EMPTY
59689: LIST
59690: LIST
59691: PUSH
59692: EMPTY
59693: LIST
59694: LIST
59695: LIST
59696: PUSH
59697: EMPTY
59698: LIST
59699: LIST
59700: PUSH
59701: LD_INT 3
59703: PUSH
59704: LD_INT 24
59706: PUSH
59707: LD_INT 1000
59709: PUSH
59710: EMPTY
59711: LIST
59712: LIST
59713: PUSH
59714: EMPTY
59715: LIST
59716: LIST
59717: PUSH
59718: EMPTY
59719: LIST
59720: LIST
59721: LIST
59722: PPUSH
59723: CALL_OW 72
59727: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59728: LD_ADDR_EXP 44
59732: PUSH
59733: LD_EXP 44
59737: PPUSH
59738: LD_VAR 0 2
59742: PPUSH
59743: LD_VAR 0 3
59747: PPUSH
59748: CALL_OW 1
59752: ST_TO_ADDR
// end ;
59753: GO 59637
59755: POP
59756: POP
// RaiseSailEvent ( 101 ) ;
59757: LD_INT 101
59759: PPUSH
59760: CALL_OW 427
// end ;
59764: LD_VAR 0 1
59768: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59769: LD_INT 0
59771: PPUSH
59772: PPUSH
59773: PPUSH
59774: PPUSH
59775: PPUSH
59776: PPUSH
59777: PPUSH
// if not mc_bases then
59778: LD_EXP 43
59782: NOT
59783: IFFALSE 59787
// exit ;
59785: GO 60349
// for i = 1 to mc_bases do
59787: LD_ADDR_VAR 0 2
59791: PUSH
59792: DOUBLE
59793: LD_INT 1
59795: DEC
59796: ST_TO_ADDR
59797: LD_EXP 43
59801: PUSH
59802: FOR_TO
59803: IFFALSE 60340
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59805: LD_ADDR_VAR 0 5
59809: PUSH
59810: LD_EXP 43
59814: PUSH
59815: LD_VAR 0 2
59819: ARRAY
59820: PUSH
59821: LD_EXP 72
59825: PUSH
59826: LD_VAR 0 2
59830: ARRAY
59831: UNION
59832: PPUSH
59833: LD_INT 21
59835: PUSH
59836: LD_INT 1
59838: PUSH
59839: EMPTY
59840: LIST
59841: LIST
59842: PUSH
59843: LD_INT 1
59845: PUSH
59846: LD_INT 3
59848: PUSH
59849: LD_INT 54
59851: PUSH
59852: EMPTY
59853: LIST
59854: PUSH
59855: EMPTY
59856: LIST
59857: LIST
59858: PUSH
59859: LD_INT 3
59861: PUSH
59862: LD_INT 24
59864: PUSH
59865: LD_INT 1000
59867: PUSH
59868: EMPTY
59869: LIST
59870: LIST
59871: PUSH
59872: EMPTY
59873: LIST
59874: LIST
59875: PUSH
59876: EMPTY
59877: LIST
59878: LIST
59879: LIST
59880: PUSH
59881: EMPTY
59882: LIST
59883: LIST
59884: PPUSH
59885: CALL_OW 72
59889: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59890: LD_ADDR_VAR 0 6
59894: PUSH
59895: LD_EXP 43
59899: PUSH
59900: LD_VAR 0 2
59904: ARRAY
59905: PPUSH
59906: LD_INT 21
59908: PUSH
59909: LD_INT 1
59911: PUSH
59912: EMPTY
59913: LIST
59914: LIST
59915: PUSH
59916: LD_INT 1
59918: PUSH
59919: LD_INT 3
59921: PUSH
59922: LD_INT 54
59924: PUSH
59925: EMPTY
59926: LIST
59927: PUSH
59928: EMPTY
59929: LIST
59930: LIST
59931: PUSH
59932: LD_INT 3
59934: PUSH
59935: LD_INT 24
59937: PUSH
59938: LD_INT 250
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: PUSH
59945: EMPTY
59946: LIST
59947: LIST
59948: PUSH
59949: EMPTY
59950: LIST
59951: LIST
59952: LIST
59953: PUSH
59954: EMPTY
59955: LIST
59956: LIST
59957: PPUSH
59958: CALL_OW 72
59962: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59963: LD_ADDR_VAR 0 7
59967: PUSH
59968: LD_VAR 0 5
59972: PUSH
59973: LD_VAR 0 6
59977: DIFF
59978: ST_TO_ADDR
// if not need_heal_1 then
59979: LD_VAR 0 6
59983: NOT
59984: IFFALSE 60017
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59986: LD_ADDR_EXP 46
59990: PUSH
59991: LD_EXP 46
59995: PPUSH
59996: LD_VAR 0 2
60000: PUSH
60001: LD_INT 1
60003: PUSH
60004: EMPTY
60005: LIST
60006: LIST
60007: PPUSH
60008: EMPTY
60009: PPUSH
60010: CALL 14988 0 3
60014: ST_TO_ADDR
60015: GO 60087
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60017: LD_ADDR_EXP 46
60021: PUSH
60022: LD_EXP 46
60026: PPUSH
60027: LD_VAR 0 2
60031: PUSH
60032: LD_INT 1
60034: PUSH
60035: EMPTY
60036: LIST
60037: LIST
60038: PPUSH
60039: LD_EXP 46
60043: PUSH
60044: LD_VAR 0 2
60048: ARRAY
60049: PUSH
60050: LD_INT 1
60052: ARRAY
60053: PPUSH
60054: LD_INT 3
60056: PUSH
60057: LD_INT 24
60059: PUSH
60060: LD_INT 1000
60062: PUSH
60063: EMPTY
60064: LIST
60065: LIST
60066: PUSH
60067: EMPTY
60068: LIST
60069: LIST
60070: PPUSH
60071: CALL_OW 72
60075: PUSH
60076: LD_VAR 0 6
60080: UNION
60081: PPUSH
60082: CALL 14988 0 3
60086: ST_TO_ADDR
// if not need_heal_2 then
60087: LD_VAR 0 7
60091: NOT
60092: IFFALSE 60125
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60094: LD_ADDR_EXP 46
60098: PUSH
60099: LD_EXP 46
60103: PPUSH
60104: LD_VAR 0 2
60108: PUSH
60109: LD_INT 2
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PPUSH
60116: EMPTY
60117: PPUSH
60118: CALL 14988 0 3
60122: ST_TO_ADDR
60123: GO 60157
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60125: LD_ADDR_EXP 46
60129: PUSH
60130: LD_EXP 46
60134: PPUSH
60135: LD_VAR 0 2
60139: PUSH
60140: LD_INT 2
60142: PUSH
60143: EMPTY
60144: LIST
60145: LIST
60146: PPUSH
60147: LD_VAR 0 7
60151: PPUSH
60152: CALL 14988 0 3
60156: ST_TO_ADDR
// if need_heal_2 then
60157: LD_VAR 0 7
60161: IFFALSE 60322
// for j in need_heal_2 do
60163: LD_ADDR_VAR 0 3
60167: PUSH
60168: LD_VAR 0 7
60172: PUSH
60173: FOR_IN
60174: IFFALSE 60320
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60176: LD_ADDR_VAR 0 5
60180: PUSH
60181: LD_EXP 43
60185: PUSH
60186: LD_VAR 0 2
60190: ARRAY
60191: PPUSH
60192: LD_INT 2
60194: PUSH
60195: LD_INT 30
60197: PUSH
60198: LD_INT 6
60200: PUSH
60201: EMPTY
60202: LIST
60203: LIST
60204: PUSH
60205: LD_INT 30
60207: PUSH
60208: LD_INT 7
60210: PUSH
60211: EMPTY
60212: LIST
60213: LIST
60214: PUSH
60215: LD_INT 30
60217: PUSH
60218: LD_INT 8
60220: PUSH
60221: EMPTY
60222: LIST
60223: LIST
60224: PUSH
60225: LD_INT 30
60227: PUSH
60228: LD_INT 0
60230: PUSH
60231: EMPTY
60232: LIST
60233: LIST
60234: PUSH
60235: LD_INT 30
60237: PUSH
60238: LD_INT 1
60240: PUSH
60241: EMPTY
60242: LIST
60243: LIST
60244: PUSH
60245: EMPTY
60246: LIST
60247: LIST
60248: LIST
60249: LIST
60250: LIST
60251: LIST
60252: PPUSH
60253: CALL_OW 72
60257: ST_TO_ADDR
// if tmp then
60258: LD_VAR 0 5
60262: IFFALSE 60318
// begin k := NearestUnitToUnit ( tmp , j ) ;
60264: LD_ADDR_VAR 0 4
60268: PUSH
60269: LD_VAR 0 5
60273: PPUSH
60274: LD_VAR 0 3
60278: PPUSH
60279: CALL_OW 74
60283: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60284: LD_VAR 0 3
60288: PPUSH
60289: LD_VAR 0 4
60293: PPUSH
60294: CALL_OW 296
60298: PUSH
60299: LD_INT 5
60301: GREATER
60302: IFFALSE 60318
// ComMoveToNearbyEntrance ( j , k ) ;
60304: LD_VAR 0 3
60308: PPUSH
60309: LD_VAR 0 4
60313: PPUSH
60314: CALL 48196 0 2
// end ; end ;
60318: GO 60173
60320: POP
60321: POP
// if not need_heal_1 and not need_heal_2 then
60322: LD_VAR 0 6
60326: NOT
60327: PUSH
60328: LD_VAR 0 7
60332: NOT
60333: AND
60334: IFFALSE 60338
// continue ;
60336: GO 59802
// end ;
60338: GO 59802
60340: POP
60341: POP
// RaiseSailEvent ( 102 ) ;
60342: LD_INT 102
60344: PPUSH
60345: CALL_OW 427
// end ;
60349: LD_VAR 0 1
60353: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60354: LD_INT 0
60356: PPUSH
60357: PPUSH
60358: PPUSH
60359: PPUSH
60360: PPUSH
60361: PPUSH
60362: PPUSH
60363: PPUSH
// if not mc_bases then
60364: LD_EXP 43
60368: NOT
60369: IFFALSE 60373
// exit ;
60371: GO 61284
// for i = 1 to mc_bases do
60373: LD_ADDR_VAR 0 2
60377: PUSH
60378: DOUBLE
60379: LD_INT 1
60381: DEC
60382: ST_TO_ADDR
60383: LD_EXP 43
60387: PUSH
60388: FOR_TO
60389: IFFALSE 61282
// begin if not mc_building_need_repair [ i ] then
60391: LD_EXP 44
60395: PUSH
60396: LD_VAR 0 2
60400: ARRAY
60401: NOT
60402: IFFALSE 60587
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60404: LD_ADDR_VAR 0 6
60408: PUSH
60409: LD_EXP 62
60413: PUSH
60414: LD_VAR 0 2
60418: ARRAY
60419: PPUSH
60420: LD_INT 3
60422: PUSH
60423: LD_INT 24
60425: PUSH
60426: LD_INT 1000
60428: PUSH
60429: EMPTY
60430: LIST
60431: LIST
60432: PUSH
60433: EMPTY
60434: LIST
60435: LIST
60436: PUSH
60437: LD_INT 2
60439: PUSH
60440: LD_INT 34
60442: PUSH
60443: LD_INT 13
60445: PUSH
60446: EMPTY
60447: LIST
60448: LIST
60449: PUSH
60450: LD_INT 34
60452: PUSH
60453: LD_INT 52
60455: PUSH
60456: EMPTY
60457: LIST
60458: LIST
60459: PUSH
60460: LD_INT 34
60462: PUSH
60463: LD_INT 88
60465: PUSH
60466: EMPTY
60467: LIST
60468: LIST
60469: PUSH
60470: EMPTY
60471: LIST
60472: LIST
60473: LIST
60474: LIST
60475: PUSH
60476: EMPTY
60477: LIST
60478: LIST
60479: PPUSH
60480: CALL_OW 72
60484: ST_TO_ADDR
// if cranes then
60485: LD_VAR 0 6
60489: IFFALSE 60551
// for j in cranes do
60491: LD_ADDR_VAR 0 3
60495: PUSH
60496: LD_VAR 0 6
60500: PUSH
60501: FOR_IN
60502: IFFALSE 60549
// if not IsInArea ( j , mc_parking [ i ] ) then
60504: LD_VAR 0 3
60508: PPUSH
60509: LD_EXP 67
60513: PUSH
60514: LD_VAR 0 2
60518: ARRAY
60519: PPUSH
60520: CALL_OW 308
60524: NOT
60525: IFFALSE 60547
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60527: LD_VAR 0 3
60531: PPUSH
60532: LD_EXP 67
60536: PUSH
60537: LD_VAR 0 2
60541: ARRAY
60542: PPUSH
60543: CALL_OW 113
60547: GO 60501
60549: POP
60550: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60551: LD_ADDR_EXP 45
60555: PUSH
60556: LD_EXP 45
60560: PPUSH
60561: LD_VAR 0 2
60565: PPUSH
60566: EMPTY
60567: PPUSH
60568: CALL_OW 1
60572: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60573: LD_VAR 0 2
60577: PPUSH
60578: LD_INT 101
60580: PPUSH
60581: CALL 55441 0 2
// continue ;
60585: GO 60388
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60587: LD_ADDR_EXP 49
60591: PUSH
60592: LD_EXP 49
60596: PPUSH
60597: LD_VAR 0 2
60601: PPUSH
60602: EMPTY
60603: PPUSH
60604: CALL_OW 1
60608: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60609: LD_VAR 0 2
60613: PPUSH
60614: LD_INT 103
60616: PPUSH
60617: CALL 55441 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60621: LD_ADDR_VAR 0 5
60625: PUSH
60626: LD_EXP 43
60630: PUSH
60631: LD_VAR 0 2
60635: ARRAY
60636: PUSH
60637: LD_EXP 72
60641: PUSH
60642: LD_VAR 0 2
60646: ARRAY
60647: UNION
60648: PPUSH
60649: LD_INT 2
60651: PUSH
60652: LD_INT 25
60654: PUSH
60655: LD_INT 2
60657: PUSH
60658: EMPTY
60659: LIST
60660: LIST
60661: PUSH
60662: LD_INT 25
60664: PUSH
60665: LD_INT 16
60667: PUSH
60668: EMPTY
60669: LIST
60670: LIST
60671: PUSH
60672: EMPTY
60673: LIST
60674: LIST
60675: LIST
60676: PUSH
60677: EMPTY
60678: LIST
60679: PPUSH
60680: CALL_OW 72
60684: ST_TO_ADDR
// if mc_need_heal [ i ] then
60685: LD_EXP 46
60689: PUSH
60690: LD_VAR 0 2
60694: ARRAY
60695: IFFALSE 60739
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60697: LD_ADDR_VAR 0 5
60701: PUSH
60702: LD_VAR 0 5
60706: PUSH
60707: LD_EXP 46
60711: PUSH
60712: LD_VAR 0 2
60716: ARRAY
60717: PUSH
60718: LD_INT 1
60720: ARRAY
60721: PUSH
60722: LD_EXP 46
60726: PUSH
60727: LD_VAR 0 2
60731: ARRAY
60732: PUSH
60733: LD_INT 2
60735: ARRAY
60736: UNION
60737: DIFF
60738: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60739: LD_ADDR_VAR 0 6
60743: PUSH
60744: LD_EXP 62
60748: PUSH
60749: LD_VAR 0 2
60753: ARRAY
60754: PPUSH
60755: LD_INT 2
60757: PUSH
60758: LD_INT 34
60760: PUSH
60761: LD_INT 13
60763: PUSH
60764: EMPTY
60765: LIST
60766: LIST
60767: PUSH
60768: LD_INT 34
60770: PUSH
60771: LD_INT 52
60773: PUSH
60774: EMPTY
60775: LIST
60776: LIST
60777: PUSH
60778: LD_INT 34
60780: PUSH
60781: LD_INT 88
60783: PUSH
60784: EMPTY
60785: LIST
60786: LIST
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: LIST
60792: LIST
60793: PPUSH
60794: CALL_OW 72
60798: ST_TO_ADDR
// if cranes then
60799: LD_VAR 0 6
60803: IFFALSE 60971
// begin for j in cranes do
60805: LD_ADDR_VAR 0 3
60809: PUSH
60810: LD_VAR 0 6
60814: PUSH
60815: FOR_IN
60816: IFFALSE 60969
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60818: LD_VAR 0 3
60822: PPUSH
60823: CALL_OW 256
60827: PUSH
60828: LD_INT 1000
60830: EQUAL
60831: PUSH
60832: LD_VAR 0 3
60836: PPUSH
60837: CALL_OW 314
60841: NOT
60842: AND
60843: IFFALSE 60909
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
60845: LD_ADDR_VAR 0 8
60849: PUSH
60850: LD_EXP 44
60854: PUSH
60855: LD_VAR 0 2
60859: ARRAY
60860: PPUSH
60861: LD_VAR 0 3
60865: PPUSH
60866: CALL_OW 74
60870: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60871: LD_VAR 0 8
60875: PPUSH
60876: LD_INT 16
60878: PPUSH
60879: CALL 17585 0 2
60883: PUSH
60884: LD_INT 4
60886: ARRAY
60887: PUSH
60888: LD_INT 10
60890: LESS
60891: IFFALSE 60907
// ComRepairBuilding ( j , to_repair ) ;
60893: LD_VAR 0 3
60897: PPUSH
60898: LD_VAR 0 8
60902: PPUSH
60903: CALL_OW 130
// end else
60907: GO 60967
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60909: LD_VAR 0 3
60913: PPUSH
60914: CALL_OW 256
60918: PUSH
60919: LD_INT 500
60921: LESS
60922: PUSH
60923: LD_VAR 0 3
60927: PPUSH
60928: LD_EXP 67
60932: PUSH
60933: LD_VAR 0 2
60937: ARRAY
60938: PPUSH
60939: CALL_OW 308
60943: NOT
60944: AND
60945: IFFALSE 60967
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60947: LD_VAR 0 3
60951: PPUSH
60952: LD_EXP 67
60956: PUSH
60957: LD_VAR 0 2
60961: ARRAY
60962: PPUSH
60963: CALL_OW 113
// end ;
60967: GO 60815
60969: POP
60970: POP
// end ; if tmp > 3 then
60971: LD_VAR 0 5
60975: PUSH
60976: LD_INT 3
60978: GREATER
60979: IFFALSE 60999
// tmp := ShrinkArray ( tmp , 4 ) ;
60981: LD_ADDR_VAR 0 5
60985: PUSH
60986: LD_VAR 0 5
60990: PPUSH
60991: LD_INT 4
60993: PPUSH
60994: CALL 47634 0 2
60998: ST_TO_ADDR
// if not tmp then
60999: LD_VAR 0 5
61003: NOT
61004: IFFALSE 61008
// continue ;
61006: GO 60388
// for j in tmp do
61008: LD_ADDR_VAR 0 3
61012: PUSH
61013: LD_VAR 0 5
61017: PUSH
61018: FOR_IN
61019: IFFALSE 61278
// begin if IsInUnit ( j ) then
61021: LD_VAR 0 3
61025: PPUSH
61026: CALL_OW 310
61030: IFFALSE 61041
// ComExitBuilding ( j ) ;
61032: LD_VAR 0 3
61036: PPUSH
61037: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61041: LD_VAR 0 3
61045: PUSH
61046: LD_EXP 45
61050: PUSH
61051: LD_VAR 0 2
61055: ARRAY
61056: IN
61057: NOT
61058: IFFALSE 61116
// begin SetTag ( j , 101 ) ;
61060: LD_VAR 0 3
61064: PPUSH
61065: LD_INT 101
61067: PPUSH
61068: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61072: LD_ADDR_EXP 45
61076: PUSH
61077: LD_EXP 45
61081: PPUSH
61082: LD_VAR 0 2
61086: PUSH
61087: LD_EXP 45
61091: PUSH
61092: LD_VAR 0 2
61096: ARRAY
61097: PUSH
61098: LD_INT 1
61100: PLUS
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PPUSH
61106: LD_VAR 0 3
61110: PPUSH
61111: CALL 14988 0 3
61115: ST_TO_ADDR
// end ; wait ( 1 ) ;
61116: LD_INT 1
61118: PPUSH
61119: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61123: LD_ADDR_VAR 0 7
61127: PUSH
61128: LD_EXP 44
61132: PUSH
61133: LD_VAR 0 2
61137: ARRAY
61138: ST_TO_ADDR
// if mc_scan [ i ] then
61139: LD_EXP 66
61143: PUSH
61144: LD_VAR 0 2
61148: ARRAY
61149: IFFALSE 61211
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61151: LD_ADDR_VAR 0 7
61155: PUSH
61156: LD_EXP 44
61160: PUSH
61161: LD_VAR 0 2
61165: ARRAY
61166: PPUSH
61167: LD_INT 3
61169: PUSH
61170: LD_INT 30
61172: PUSH
61173: LD_INT 32
61175: PUSH
61176: EMPTY
61177: LIST
61178: LIST
61179: PUSH
61180: LD_INT 30
61182: PUSH
61183: LD_INT 33
61185: PUSH
61186: EMPTY
61187: LIST
61188: LIST
61189: PUSH
61190: LD_INT 30
61192: PUSH
61193: LD_INT 31
61195: PUSH
61196: EMPTY
61197: LIST
61198: LIST
61199: PUSH
61200: EMPTY
61201: LIST
61202: LIST
61203: LIST
61204: LIST
61205: PPUSH
61206: CALL_OW 72
61210: ST_TO_ADDR
// if not to_repair_tmp then
61211: LD_VAR 0 7
61215: NOT
61216: IFFALSE 61220
// continue ;
61218: GO 61018
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61220: LD_ADDR_VAR 0 8
61224: PUSH
61225: LD_VAR 0 7
61229: PPUSH
61230: LD_VAR 0 3
61234: PPUSH
61235: CALL_OW 74
61239: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
61240: LD_VAR 0 8
61244: PPUSH
61245: LD_INT 16
61247: PPUSH
61248: CALL 17585 0 2
61252: PUSH
61253: LD_INT 4
61255: ARRAY
61256: PUSH
61257: LD_INT 14
61259: LESS
61260: IFFALSE 61276
// ComRepairBuilding ( j , to_repair ) ;
61262: LD_VAR 0 3
61266: PPUSH
61267: LD_VAR 0 8
61271: PPUSH
61272: CALL_OW 130
// end ;
61276: GO 61018
61278: POP
61279: POP
// end ;
61280: GO 60388
61282: POP
61283: POP
// end ;
61284: LD_VAR 0 1
61288: RET
// export function MC_Heal ; var i , j , tmp ; begin
61289: LD_INT 0
61291: PPUSH
61292: PPUSH
61293: PPUSH
61294: PPUSH
// if not mc_bases then
61295: LD_EXP 43
61299: NOT
61300: IFFALSE 61304
// exit ;
61302: GO 61706
// for i = 1 to mc_bases do
61304: LD_ADDR_VAR 0 2
61308: PUSH
61309: DOUBLE
61310: LD_INT 1
61312: DEC
61313: ST_TO_ADDR
61314: LD_EXP 43
61318: PUSH
61319: FOR_TO
61320: IFFALSE 61704
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61322: LD_EXP 46
61326: PUSH
61327: LD_VAR 0 2
61331: ARRAY
61332: PUSH
61333: LD_INT 1
61335: ARRAY
61336: NOT
61337: PUSH
61338: LD_EXP 46
61342: PUSH
61343: LD_VAR 0 2
61347: ARRAY
61348: PUSH
61349: LD_INT 2
61351: ARRAY
61352: NOT
61353: AND
61354: IFFALSE 61392
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61356: LD_ADDR_EXP 47
61360: PUSH
61361: LD_EXP 47
61365: PPUSH
61366: LD_VAR 0 2
61370: PPUSH
61371: EMPTY
61372: PPUSH
61373: CALL_OW 1
61377: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61378: LD_VAR 0 2
61382: PPUSH
61383: LD_INT 102
61385: PPUSH
61386: CALL 55441 0 2
// continue ;
61390: GO 61319
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61392: LD_ADDR_VAR 0 4
61396: PUSH
61397: LD_EXP 43
61401: PUSH
61402: LD_VAR 0 2
61406: ARRAY
61407: PPUSH
61408: LD_INT 25
61410: PUSH
61411: LD_INT 4
61413: PUSH
61414: EMPTY
61415: LIST
61416: LIST
61417: PPUSH
61418: CALL_OW 72
61422: ST_TO_ADDR
// if not tmp then
61423: LD_VAR 0 4
61427: NOT
61428: IFFALSE 61432
// continue ;
61430: GO 61319
// if mc_taming [ i ] then
61432: LD_EXP 74
61436: PUSH
61437: LD_VAR 0 2
61441: ARRAY
61442: IFFALSE 61466
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61444: LD_ADDR_EXP 74
61448: PUSH
61449: LD_EXP 74
61453: PPUSH
61454: LD_VAR 0 2
61458: PPUSH
61459: EMPTY
61460: PPUSH
61461: CALL_OW 1
61465: ST_TO_ADDR
// for j in tmp do
61466: LD_ADDR_VAR 0 3
61470: PUSH
61471: LD_VAR 0 4
61475: PUSH
61476: FOR_IN
61477: IFFALSE 61700
// begin if IsInUnit ( j ) then
61479: LD_VAR 0 3
61483: PPUSH
61484: CALL_OW 310
61488: IFFALSE 61499
// ComExitBuilding ( j ) ;
61490: LD_VAR 0 3
61494: PPUSH
61495: CALL_OW 122
// if not j in mc_healers [ i ] then
61499: LD_VAR 0 3
61503: PUSH
61504: LD_EXP 47
61508: PUSH
61509: LD_VAR 0 2
61513: ARRAY
61514: IN
61515: NOT
61516: IFFALSE 61562
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61518: LD_ADDR_EXP 47
61522: PUSH
61523: LD_EXP 47
61527: PPUSH
61528: LD_VAR 0 2
61532: PUSH
61533: LD_EXP 47
61537: PUSH
61538: LD_VAR 0 2
61542: ARRAY
61543: PUSH
61544: LD_INT 1
61546: PLUS
61547: PUSH
61548: EMPTY
61549: LIST
61550: LIST
61551: PPUSH
61552: LD_VAR 0 3
61556: PPUSH
61557: CALL 14988 0 3
61561: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61562: LD_VAR 0 3
61566: PPUSH
61567: CALL_OW 110
61571: PUSH
61572: LD_INT 102
61574: NONEQUAL
61575: IFFALSE 61589
// SetTag ( j , 102 ) ;
61577: LD_VAR 0 3
61581: PPUSH
61582: LD_INT 102
61584: PPUSH
61585: CALL_OW 109
// Wait ( 3 ) ;
61589: LD_INT 3
61591: PPUSH
61592: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61596: LD_EXP 46
61600: PUSH
61601: LD_VAR 0 2
61605: ARRAY
61606: PUSH
61607: LD_INT 1
61609: ARRAY
61610: IFFALSE 61642
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61612: LD_VAR 0 3
61616: PPUSH
61617: LD_EXP 46
61621: PUSH
61622: LD_VAR 0 2
61626: ARRAY
61627: PUSH
61628: LD_INT 1
61630: ARRAY
61631: PUSH
61632: LD_INT 1
61634: ARRAY
61635: PPUSH
61636: CALL_OW 128
61640: GO 61698
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61642: LD_VAR 0 3
61646: PPUSH
61647: CALL_OW 314
61651: NOT
61652: PUSH
61653: LD_EXP 46
61657: PUSH
61658: LD_VAR 0 2
61662: ARRAY
61663: PUSH
61664: LD_INT 2
61666: ARRAY
61667: AND
61668: IFFALSE 61698
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61670: LD_VAR 0 3
61674: PPUSH
61675: LD_EXP 46
61679: PUSH
61680: LD_VAR 0 2
61684: ARRAY
61685: PUSH
61686: LD_INT 2
61688: ARRAY
61689: PUSH
61690: LD_INT 1
61692: ARRAY
61693: PPUSH
61694: CALL_OW 128
// end ;
61698: GO 61476
61700: POP
61701: POP
// end ;
61702: GO 61319
61704: POP
61705: POP
// end ;
61706: LD_VAR 0 1
61710: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
61711: LD_INT 0
61713: PPUSH
61714: PPUSH
61715: PPUSH
61716: PPUSH
61717: PPUSH
61718: PPUSH
// if not mc_bases then
61719: LD_EXP 43
61723: NOT
61724: IFFALSE 61728
// exit ;
61726: GO 62891
// for i = 1 to mc_bases do
61728: LD_ADDR_VAR 0 2
61732: PUSH
61733: DOUBLE
61734: LD_INT 1
61736: DEC
61737: ST_TO_ADDR
61738: LD_EXP 43
61742: PUSH
61743: FOR_TO
61744: IFFALSE 62889
// begin if mc_scan [ i ] then
61746: LD_EXP 66
61750: PUSH
61751: LD_VAR 0 2
61755: ARRAY
61756: IFFALSE 61760
// continue ;
61758: GO 61743
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61760: LD_EXP 48
61764: PUSH
61765: LD_VAR 0 2
61769: ARRAY
61770: NOT
61771: PUSH
61772: LD_EXP 50
61776: PUSH
61777: LD_VAR 0 2
61781: ARRAY
61782: NOT
61783: AND
61784: PUSH
61785: LD_EXP 49
61789: PUSH
61790: LD_VAR 0 2
61794: ARRAY
61795: AND
61796: IFFALSE 61834
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61798: LD_ADDR_EXP 49
61802: PUSH
61803: LD_EXP 49
61807: PPUSH
61808: LD_VAR 0 2
61812: PPUSH
61813: EMPTY
61814: PPUSH
61815: CALL_OW 1
61819: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61820: LD_VAR 0 2
61824: PPUSH
61825: LD_INT 103
61827: PPUSH
61828: CALL 55441 0 2
// continue ;
61832: GO 61743
// end ; if mc_construct_list [ i ] then
61834: LD_EXP 50
61838: PUSH
61839: LD_VAR 0 2
61843: ARRAY
61844: IFFALSE 62064
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61846: LD_ADDR_VAR 0 5
61850: PUSH
61851: LD_EXP 43
61855: PUSH
61856: LD_VAR 0 2
61860: ARRAY
61861: PPUSH
61862: LD_INT 25
61864: PUSH
61865: LD_INT 2
61867: PUSH
61868: EMPTY
61869: LIST
61870: LIST
61871: PPUSH
61872: CALL_OW 72
61876: PUSH
61877: LD_EXP 45
61881: PUSH
61882: LD_VAR 0 2
61886: ARRAY
61887: DIFF
61888: ST_TO_ADDR
// if not tmp then
61889: LD_VAR 0 5
61893: NOT
61894: IFFALSE 61898
// continue ;
61896: GO 61743
// for j in tmp do
61898: LD_ADDR_VAR 0 3
61902: PUSH
61903: LD_VAR 0 5
61907: PUSH
61908: FOR_IN
61909: IFFALSE 62060
// begin if not mc_builders [ i ] then
61911: LD_EXP 49
61915: PUSH
61916: LD_VAR 0 2
61920: ARRAY
61921: NOT
61922: IFFALSE 61980
// begin SetTag ( j , 103 ) ;
61924: LD_VAR 0 3
61928: PPUSH
61929: LD_INT 103
61931: PPUSH
61932: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61936: LD_ADDR_EXP 49
61940: PUSH
61941: LD_EXP 49
61945: PPUSH
61946: LD_VAR 0 2
61950: PUSH
61951: LD_EXP 49
61955: PUSH
61956: LD_VAR 0 2
61960: ARRAY
61961: PUSH
61962: LD_INT 1
61964: PLUS
61965: PUSH
61966: EMPTY
61967: LIST
61968: LIST
61969: PPUSH
61970: LD_VAR 0 3
61974: PPUSH
61975: CALL 14988 0 3
61979: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61980: LD_VAR 0 3
61984: PPUSH
61985: CALL_OW 310
61989: IFFALSE 62000
// ComExitBuilding ( j ) ;
61991: LD_VAR 0 3
61995: PPUSH
61996: CALL_OW 122
// wait ( 3 ) ;
62000: LD_INT 3
62002: PPUSH
62003: CALL_OW 67
// if not mc_construct_list [ i ] then
62007: LD_EXP 50
62011: PUSH
62012: LD_VAR 0 2
62016: ARRAY
62017: NOT
62018: IFFALSE 62022
// break ;
62020: GO 62060
// if not HasTask ( j ) then
62022: LD_VAR 0 3
62026: PPUSH
62027: CALL_OW 314
62031: NOT
62032: IFFALSE 62058
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62034: LD_VAR 0 3
62038: PPUSH
62039: LD_EXP 50
62043: PUSH
62044: LD_VAR 0 2
62048: ARRAY
62049: PUSH
62050: LD_INT 1
62052: ARRAY
62053: PPUSH
62054: CALL 17849 0 2
// end ;
62058: GO 61908
62060: POP
62061: POP
// end else
62062: GO 62887
// if mc_build_list [ i ] then
62064: LD_EXP 48
62068: PUSH
62069: LD_VAR 0 2
62073: ARRAY
62074: IFFALSE 62887
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62076: LD_EXP 48
62080: PUSH
62081: LD_VAR 0 2
62085: ARRAY
62086: PUSH
62087: LD_INT 1
62089: ARRAY
62090: PUSH
62091: LD_INT 1
62093: ARRAY
62094: PPUSH
62095: CALL 17673 0 1
62099: PUSH
62100: LD_EXP 43
62104: PUSH
62105: LD_VAR 0 2
62109: ARRAY
62110: PPUSH
62111: LD_INT 2
62113: PUSH
62114: LD_INT 30
62116: PUSH
62117: LD_INT 2
62119: PUSH
62120: EMPTY
62121: LIST
62122: LIST
62123: PUSH
62124: LD_INT 30
62126: PUSH
62127: LD_INT 3
62129: PUSH
62130: EMPTY
62131: LIST
62132: LIST
62133: PUSH
62134: EMPTY
62135: LIST
62136: LIST
62137: LIST
62138: PPUSH
62139: CALL_OW 72
62143: NOT
62144: AND
62145: IFFALSE 62250
// begin for j = 1 to mc_build_list [ i ] do
62147: LD_ADDR_VAR 0 3
62151: PUSH
62152: DOUBLE
62153: LD_INT 1
62155: DEC
62156: ST_TO_ADDR
62157: LD_EXP 48
62161: PUSH
62162: LD_VAR 0 2
62166: ARRAY
62167: PUSH
62168: FOR_TO
62169: IFFALSE 62248
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62171: LD_EXP 48
62175: PUSH
62176: LD_VAR 0 2
62180: ARRAY
62181: PUSH
62182: LD_VAR 0 3
62186: ARRAY
62187: PUSH
62188: LD_INT 1
62190: ARRAY
62191: PUSH
62192: LD_INT 2
62194: EQUAL
62195: IFFALSE 62246
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62197: LD_ADDR_EXP 48
62201: PUSH
62202: LD_EXP 48
62206: PPUSH
62207: LD_VAR 0 2
62211: PPUSH
62212: LD_EXP 48
62216: PUSH
62217: LD_VAR 0 2
62221: ARRAY
62222: PPUSH
62223: LD_VAR 0 3
62227: PPUSH
62228: LD_INT 1
62230: PPUSH
62231: LD_INT 0
62233: PPUSH
62234: CALL 14406 0 4
62238: PPUSH
62239: CALL_OW 1
62243: ST_TO_ADDR
// break ;
62244: GO 62248
// end ;
62246: GO 62168
62248: POP
62249: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62250: LD_ADDR_VAR 0 6
62254: PUSH
62255: LD_EXP 43
62259: PUSH
62260: LD_VAR 0 2
62264: ARRAY
62265: PPUSH
62266: LD_INT 2
62268: PUSH
62269: LD_INT 30
62271: PUSH
62272: LD_INT 0
62274: PUSH
62275: EMPTY
62276: LIST
62277: LIST
62278: PUSH
62279: LD_INT 30
62281: PUSH
62282: LD_INT 1
62284: PUSH
62285: EMPTY
62286: LIST
62287: LIST
62288: PUSH
62289: EMPTY
62290: LIST
62291: LIST
62292: LIST
62293: PPUSH
62294: CALL_OW 72
62298: ST_TO_ADDR
// for k := 1 to depot do
62299: LD_ADDR_VAR 0 4
62303: PUSH
62304: DOUBLE
62305: LD_INT 1
62307: DEC
62308: ST_TO_ADDR
62309: LD_VAR 0 6
62313: PUSH
62314: FOR_TO
62315: IFFALSE 62885
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62317: LD_EXP 48
62321: PUSH
62322: LD_VAR 0 2
62326: ARRAY
62327: PUSH
62328: LD_INT 1
62330: ARRAY
62331: PUSH
62332: LD_INT 1
62334: ARRAY
62335: PUSH
62336: LD_INT 0
62338: EQUAL
62339: PUSH
62340: LD_VAR 0 6
62344: PUSH
62345: LD_VAR 0 4
62349: ARRAY
62350: PPUSH
62351: LD_EXP 48
62355: PUSH
62356: LD_VAR 0 2
62360: ARRAY
62361: PUSH
62362: LD_INT 1
62364: ARRAY
62365: PUSH
62366: LD_INT 1
62368: ARRAY
62369: PPUSH
62370: LD_EXP 48
62374: PUSH
62375: LD_VAR 0 2
62379: ARRAY
62380: PUSH
62381: LD_INT 1
62383: ARRAY
62384: PUSH
62385: LD_INT 2
62387: ARRAY
62388: PPUSH
62389: LD_EXP 48
62393: PUSH
62394: LD_VAR 0 2
62398: ARRAY
62399: PUSH
62400: LD_INT 1
62402: ARRAY
62403: PUSH
62404: LD_INT 3
62406: ARRAY
62407: PPUSH
62408: LD_EXP 48
62412: PUSH
62413: LD_VAR 0 2
62417: ARRAY
62418: PUSH
62419: LD_INT 1
62421: ARRAY
62422: PUSH
62423: LD_INT 4
62425: ARRAY
62426: PPUSH
62427: CALL 23085 0 5
62431: OR
62432: IFFALSE 62713
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62434: LD_ADDR_VAR 0 5
62438: PUSH
62439: LD_EXP 43
62443: PUSH
62444: LD_VAR 0 2
62448: ARRAY
62449: PPUSH
62450: LD_INT 25
62452: PUSH
62453: LD_INT 2
62455: PUSH
62456: EMPTY
62457: LIST
62458: LIST
62459: PPUSH
62460: CALL_OW 72
62464: PUSH
62465: LD_EXP 45
62469: PUSH
62470: LD_VAR 0 2
62474: ARRAY
62475: DIFF
62476: ST_TO_ADDR
// if not tmp then
62477: LD_VAR 0 5
62481: NOT
62482: IFFALSE 62486
// continue ;
62484: GO 62314
// for j in tmp do
62486: LD_ADDR_VAR 0 3
62490: PUSH
62491: LD_VAR 0 5
62495: PUSH
62496: FOR_IN
62497: IFFALSE 62709
// begin if not mc_builders [ i ] then
62499: LD_EXP 49
62503: PUSH
62504: LD_VAR 0 2
62508: ARRAY
62509: NOT
62510: IFFALSE 62568
// begin SetTag ( j , 103 ) ;
62512: LD_VAR 0 3
62516: PPUSH
62517: LD_INT 103
62519: PPUSH
62520: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62524: LD_ADDR_EXP 49
62528: PUSH
62529: LD_EXP 49
62533: PPUSH
62534: LD_VAR 0 2
62538: PUSH
62539: LD_EXP 49
62543: PUSH
62544: LD_VAR 0 2
62548: ARRAY
62549: PUSH
62550: LD_INT 1
62552: PLUS
62553: PUSH
62554: EMPTY
62555: LIST
62556: LIST
62557: PPUSH
62558: LD_VAR 0 3
62562: PPUSH
62563: CALL 14988 0 3
62567: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62568: LD_VAR 0 3
62572: PPUSH
62573: CALL_OW 310
62577: IFFALSE 62588
// ComExitBuilding ( j ) ;
62579: LD_VAR 0 3
62583: PPUSH
62584: CALL_OW 122
// wait ( 3 ) ;
62588: LD_INT 3
62590: PPUSH
62591: CALL_OW 67
// if not mc_build_list [ i ] then
62595: LD_EXP 48
62599: PUSH
62600: LD_VAR 0 2
62604: ARRAY
62605: NOT
62606: IFFALSE 62610
// break ;
62608: GO 62709
// if not HasTask ( j ) then
62610: LD_VAR 0 3
62614: PPUSH
62615: CALL_OW 314
62619: NOT
62620: IFFALSE 62707
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62622: LD_VAR 0 3
62626: PPUSH
62627: LD_EXP 48
62631: PUSH
62632: LD_VAR 0 2
62636: ARRAY
62637: PUSH
62638: LD_INT 1
62640: ARRAY
62641: PUSH
62642: LD_INT 1
62644: ARRAY
62645: PPUSH
62646: LD_EXP 48
62650: PUSH
62651: LD_VAR 0 2
62655: ARRAY
62656: PUSH
62657: LD_INT 1
62659: ARRAY
62660: PUSH
62661: LD_INT 2
62663: ARRAY
62664: PPUSH
62665: LD_EXP 48
62669: PUSH
62670: LD_VAR 0 2
62674: ARRAY
62675: PUSH
62676: LD_INT 1
62678: ARRAY
62679: PUSH
62680: LD_INT 3
62682: ARRAY
62683: PPUSH
62684: LD_EXP 48
62688: PUSH
62689: LD_VAR 0 2
62693: ARRAY
62694: PUSH
62695: LD_INT 1
62697: ARRAY
62698: PUSH
62699: LD_INT 4
62701: ARRAY
62702: PPUSH
62703: CALL_OW 145
// end ;
62707: GO 62496
62709: POP
62710: POP
// end else
62711: GO 62883
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62713: LD_EXP 43
62717: PUSH
62718: LD_VAR 0 2
62722: ARRAY
62723: PPUSH
62724: LD_EXP 48
62728: PUSH
62729: LD_VAR 0 2
62733: ARRAY
62734: PUSH
62735: LD_INT 1
62737: ARRAY
62738: PUSH
62739: LD_INT 1
62741: ARRAY
62742: PPUSH
62743: LD_EXP 48
62747: PUSH
62748: LD_VAR 0 2
62752: ARRAY
62753: PUSH
62754: LD_INT 1
62756: ARRAY
62757: PUSH
62758: LD_INT 2
62760: ARRAY
62761: PPUSH
62762: LD_EXP 48
62766: PUSH
62767: LD_VAR 0 2
62771: ARRAY
62772: PUSH
62773: LD_INT 1
62775: ARRAY
62776: PUSH
62777: LD_INT 3
62779: ARRAY
62780: PPUSH
62781: LD_EXP 48
62785: PUSH
62786: LD_VAR 0 2
62790: ARRAY
62791: PUSH
62792: LD_INT 1
62794: ARRAY
62795: PUSH
62796: LD_INT 4
62798: ARRAY
62799: PPUSH
62800: LD_EXP 43
62804: PUSH
62805: LD_VAR 0 2
62809: ARRAY
62810: PPUSH
62811: LD_INT 21
62813: PUSH
62814: LD_INT 3
62816: PUSH
62817: EMPTY
62818: LIST
62819: LIST
62820: PPUSH
62821: CALL_OW 72
62825: PPUSH
62826: EMPTY
62827: PPUSH
62828: CALL 21839 0 7
62832: NOT
62833: IFFALSE 62883
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62835: LD_ADDR_EXP 48
62839: PUSH
62840: LD_EXP 48
62844: PPUSH
62845: LD_VAR 0 2
62849: PPUSH
62850: LD_EXP 48
62854: PUSH
62855: LD_VAR 0 2
62859: ARRAY
62860: PPUSH
62861: LD_INT 1
62863: PPUSH
62864: LD_INT 1
62866: NEG
62867: PPUSH
62868: LD_INT 0
62870: PPUSH
62871: CALL 14406 0 4
62875: PPUSH
62876: CALL_OW 1
62880: ST_TO_ADDR
// continue ;
62881: GO 62314
// end ; end ;
62883: GO 62314
62885: POP
62886: POP
// end ; end ;
62887: GO 61743
62889: POP
62890: POP
// end ;
62891: LD_VAR 0 1
62895: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62896: LD_INT 0
62898: PPUSH
62899: PPUSH
62900: PPUSH
62901: PPUSH
62902: PPUSH
62903: PPUSH
// if not mc_bases then
62904: LD_EXP 43
62908: NOT
62909: IFFALSE 62913
// exit ;
62911: GO 63340
// for i = 1 to mc_bases do
62913: LD_ADDR_VAR 0 2
62917: PUSH
62918: DOUBLE
62919: LD_INT 1
62921: DEC
62922: ST_TO_ADDR
62923: LD_EXP 43
62927: PUSH
62928: FOR_TO
62929: IFFALSE 63338
// begin tmp := mc_build_upgrade [ i ] ;
62931: LD_ADDR_VAR 0 4
62935: PUSH
62936: LD_EXP 75
62940: PUSH
62941: LD_VAR 0 2
62945: ARRAY
62946: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62947: LD_ADDR_VAR 0 6
62951: PUSH
62952: LD_EXP 76
62956: PUSH
62957: LD_VAR 0 2
62961: ARRAY
62962: PPUSH
62963: LD_INT 2
62965: PUSH
62966: LD_INT 30
62968: PUSH
62969: LD_INT 6
62971: PUSH
62972: EMPTY
62973: LIST
62974: LIST
62975: PUSH
62976: LD_INT 30
62978: PUSH
62979: LD_INT 7
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: PUSH
62986: EMPTY
62987: LIST
62988: LIST
62989: LIST
62990: PPUSH
62991: CALL_OW 72
62995: ST_TO_ADDR
// if not tmp and not lab then
62996: LD_VAR 0 4
63000: NOT
63001: PUSH
63002: LD_VAR 0 6
63006: NOT
63007: AND
63008: IFFALSE 63012
// continue ;
63010: GO 62928
// if tmp then
63012: LD_VAR 0 4
63016: IFFALSE 63136
// for j in tmp do
63018: LD_ADDR_VAR 0 3
63022: PUSH
63023: LD_VAR 0 4
63027: PUSH
63028: FOR_IN
63029: IFFALSE 63134
// begin if UpgradeCost ( j ) then
63031: LD_VAR 0 3
63035: PPUSH
63036: CALL 21499 0 1
63040: IFFALSE 63132
// begin ComUpgrade ( j ) ;
63042: LD_VAR 0 3
63046: PPUSH
63047: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63051: LD_ADDR_EXP 75
63055: PUSH
63056: LD_EXP 75
63060: PPUSH
63061: LD_VAR 0 2
63065: PPUSH
63066: LD_EXP 75
63070: PUSH
63071: LD_VAR 0 2
63075: ARRAY
63076: PUSH
63077: LD_VAR 0 3
63081: DIFF
63082: PPUSH
63083: CALL_OW 1
63087: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63088: LD_ADDR_EXP 50
63092: PUSH
63093: LD_EXP 50
63097: PPUSH
63098: LD_VAR 0 2
63102: PUSH
63103: LD_EXP 50
63107: PUSH
63108: LD_VAR 0 2
63112: ARRAY
63113: PUSH
63114: LD_INT 1
63116: PLUS
63117: PUSH
63118: EMPTY
63119: LIST
63120: LIST
63121: PPUSH
63122: LD_VAR 0 3
63126: PPUSH
63127: CALL 14988 0 3
63131: ST_TO_ADDR
// end ; end ;
63132: GO 63028
63134: POP
63135: POP
// if not lab or not mc_lab_upgrade [ i ] then
63136: LD_VAR 0 6
63140: NOT
63141: PUSH
63142: LD_EXP 77
63146: PUSH
63147: LD_VAR 0 2
63151: ARRAY
63152: NOT
63153: OR
63154: IFFALSE 63158
// continue ;
63156: GO 62928
// for j in lab do
63158: LD_ADDR_VAR 0 3
63162: PUSH
63163: LD_VAR 0 6
63167: PUSH
63168: FOR_IN
63169: IFFALSE 63334
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63171: LD_VAR 0 3
63175: PPUSH
63176: CALL_OW 266
63180: PUSH
63181: LD_INT 6
63183: PUSH
63184: LD_INT 7
63186: PUSH
63187: EMPTY
63188: LIST
63189: LIST
63190: IN
63191: PUSH
63192: LD_VAR 0 3
63196: PPUSH
63197: CALL_OW 461
63201: PUSH
63202: LD_INT 1
63204: NONEQUAL
63205: AND
63206: IFFALSE 63332
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63208: LD_VAR 0 3
63212: PPUSH
63213: LD_EXP 77
63217: PUSH
63218: LD_VAR 0 2
63222: ARRAY
63223: PUSH
63224: LD_INT 1
63226: ARRAY
63227: PPUSH
63228: CALL 21704 0 2
63232: IFFALSE 63332
// begin ComCancel ( j ) ;
63234: LD_VAR 0 3
63238: PPUSH
63239: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63243: LD_VAR 0 3
63247: PPUSH
63248: LD_EXP 77
63252: PUSH
63253: LD_VAR 0 2
63257: ARRAY
63258: PUSH
63259: LD_INT 1
63261: ARRAY
63262: PPUSH
63263: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63267: LD_VAR 0 3
63271: PUSH
63272: LD_EXP 50
63276: PUSH
63277: LD_VAR 0 2
63281: ARRAY
63282: IN
63283: NOT
63284: IFFALSE 63330
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63286: LD_ADDR_EXP 50
63290: PUSH
63291: LD_EXP 50
63295: PPUSH
63296: LD_VAR 0 2
63300: PUSH
63301: LD_EXP 50
63305: PUSH
63306: LD_VAR 0 2
63310: ARRAY
63311: PUSH
63312: LD_INT 1
63314: PLUS
63315: PUSH
63316: EMPTY
63317: LIST
63318: LIST
63319: PPUSH
63320: LD_VAR 0 3
63324: PPUSH
63325: CALL 14988 0 3
63329: ST_TO_ADDR
// break ;
63330: GO 63334
// end ; end ; end ;
63332: GO 63168
63334: POP
63335: POP
// end ;
63336: GO 62928
63338: POP
63339: POP
// end ;
63340: LD_VAR 0 1
63344: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63345: LD_INT 0
63347: PPUSH
63348: PPUSH
63349: PPUSH
63350: PPUSH
63351: PPUSH
63352: PPUSH
63353: PPUSH
63354: PPUSH
63355: PPUSH
// if not mc_bases then
63356: LD_EXP 43
63360: NOT
63361: IFFALSE 63365
// exit ;
63363: GO 63770
// for i = 1 to mc_bases do
63365: LD_ADDR_VAR 0 2
63369: PUSH
63370: DOUBLE
63371: LD_INT 1
63373: DEC
63374: ST_TO_ADDR
63375: LD_EXP 43
63379: PUSH
63380: FOR_TO
63381: IFFALSE 63768
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63383: LD_EXP 51
63387: PUSH
63388: LD_VAR 0 2
63392: ARRAY
63393: NOT
63394: PUSH
63395: LD_EXP 43
63399: PUSH
63400: LD_VAR 0 2
63404: ARRAY
63405: PPUSH
63406: LD_INT 30
63408: PUSH
63409: LD_INT 3
63411: PUSH
63412: EMPTY
63413: LIST
63414: LIST
63415: PPUSH
63416: CALL_OW 72
63420: NOT
63421: OR
63422: IFFALSE 63426
// continue ;
63424: GO 63380
// busy := false ;
63426: LD_ADDR_VAR 0 8
63430: PUSH
63431: LD_INT 0
63433: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63434: LD_ADDR_VAR 0 4
63438: PUSH
63439: LD_EXP 43
63443: PUSH
63444: LD_VAR 0 2
63448: ARRAY
63449: PPUSH
63450: LD_INT 30
63452: PUSH
63453: LD_INT 3
63455: PUSH
63456: EMPTY
63457: LIST
63458: LIST
63459: PPUSH
63460: CALL_OW 72
63464: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63465: LD_ADDR_VAR 0 6
63469: PUSH
63470: LD_EXP 51
63474: PUSH
63475: LD_VAR 0 2
63479: ARRAY
63480: PPUSH
63481: LD_INT 2
63483: PUSH
63484: LD_INT 30
63486: PUSH
63487: LD_INT 32
63489: PUSH
63490: EMPTY
63491: LIST
63492: LIST
63493: PUSH
63494: LD_INT 30
63496: PUSH
63497: LD_INT 33
63499: PUSH
63500: EMPTY
63501: LIST
63502: LIST
63503: PUSH
63504: EMPTY
63505: LIST
63506: LIST
63507: LIST
63508: PPUSH
63509: CALL_OW 72
63513: ST_TO_ADDR
// if not t then
63514: LD_VAR 0 6
63518: NOT
63519: IFFALSE 63523
// continue ;
63521: GO 63380
// for j in tmp do
63523: LD_ADDR_VAR 0 3
63527: PUSH
63528: LD_VAR 0 4
63532: PUSH
63533: FOR_IN
63534: IFFALSE 63564
// if not BuildingStatus ( j ) = bs_idle then
63536: LD_VAR 0 3
63540: PPUSH
63541: CALL_OW 461
63545: PUSH
63546: LD_INT 2
63548: EQUAL
63549: NOT
63550: IFFALSE 63562
// begin busy := true ;
63552: LD_ADDR_VAR 0 8
63556: PUSH
63557: LD_INT 1
63559: ST_TO_ADDR
// break ;
63560: GO 63564
// end ;
63562: GO 63533
63564: POP
63565: POP
// if busy then
63566: LD_VAR 0 8
63570: IFFALSE 63574
// continue ;
63572: GO 63380
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63574: LD_ADDR_VAR 0 7
63578: PUSH
63579: LD_VAR 0 6
63583: PPUSH
63584: LD_INT 35
63586: PUSH
63587: LD_INT 0
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: PPUSH
63594: CALL_OW 72
63598: ST_TO_ADDR
// if tw then
63599: LD_VAR 0 7
63603: IFFALSE 63680
// begin tw := tw [ 1 ] ;
63605: LD_ADDR_VAR 0 7
63609: PUSH
63610: LD_VAR 0 7
63614: PUSH
63615: LD_INT 1
63617: ARRAY
63618: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63619: LD_ADDR_VAR 0 9
63623: PUSH
63624: LD_VAR 0 7
63628: PPUSH
63629: LD_EXP 68
63633: PUSH
63634: LD_VAR 0 2
63638: ARRAY
63639: PPUSH
63640: CALL 19996 0 2
63644: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63645: LD_EXP 82
63649: PUSH
63650: LD_VAR 0 2
63654: ARRAY
63655: IFFALSE 63678
// if not weapon in mc_allowed_tower_weapons [ i ] then
63657: LD_VAR 0 9
63661: PUSH
63662: LD_EXP 82
63666: PUSH
63667: LD_VAR 0 2
63671: ARRAY
63672: IN
63673: NOT
63674: IFFALSE 63678
// continue ;
63676: GO 63380
// end else
63678: GO 63743
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63680: LD_ADDR_VAR 0 5
63684: PUSH
63685: LD_EXP 51
63689: PUSH
63690: LD_VAR 0 2
63694: ARRAY
63695: PPUSH
63696: LD_VAR 0 4
63700: PPUSH
63701: CALL 46867 0 2
63705: ST_TO_ADDR
// if not tmp2 then
63706: LD_VAR 0 5
63710: NOT
63711: IFFALSE 63715
// continue ;
63713: GO 63380
// tw := tmp2 [ 1 ] ;
63715: LD_ADDR_VAR 0 7
63719: PUSH
63720: LD_VAR 0 5
63724: PUSH
63725: LD_INT 1
63727: ARRAY
63728: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63729: LD_ADDR_VAR 0 9
63733: PUSH
63734: LD_VAR 0 5
63738: PUSH
63739: LD_INT 2
63741: ARRAY
63742: ST_TO_ADDR
// end ; if not weapon then
63743: LD_VAR 0 9
63747: NOT
63748: IFFALSE 63752
// continue ;
63750: GO 63380
// ComPlaceWeapon ( tw , weapon ) ;
63752: LD_VAR 0 7
63756: PPUSH
63757: LD_VAR 0 9
63761: PPUSH
63762: CALL_OW 148
// end ;
63766: GO 63380
63768: POP
63769: POP
// end ;
63770: LD_VAR 0 1
63774: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63775: LD_INT 0
63777: PPUSH
63778: PPUSH
63779: PPUSH
63780: PPUSH
63781: PPUSH
63782: PPUSH
63783: PPUSH
// if not mc_bases then
63784: LD_EXP 43
63788: NOT
63789: IFFALSE 63793
// exit ;
63791: GO 64561
// for i = 1 to mc_bases do
63793: LD_ADDR_VAR 0 2
63797: PUSH
63798: DOUBLE
63799: LD_INT 1
63801: DEC
63802: ST_TO_ADDR
63803: LD_EXP 43
63807: PUSH
63808: FOR_TO
63809: IFFALSE 64559
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63811: LD_EXP 56
63815: PUSH
63816: LD_VAR 0 2
63820: ARRAY
63821: NOT
63822: PUSH
63823: LD_EXP 56
63827: PUSH
63828: LD_VAR 0 2
63832: ARRAY
63833: PUSH
63834: LD_EXP 57
63838: PUSH
63839: LD_VAR 0 2
63843: ARRAY
63844: EQUAL
63845: OR
63846: PUSH
63847: LD_EXP 66
63851: PUSH
63852: LD_VAR 0 2
63856: ARRAY
63857: OR
63858: IFFALSE 63862
// continue ;
63860: GO 63808
// if mc_miners [ i ] then
63862: LD_EXP 57
63866: PUSH
63867: LD_VAR 0 2
63871: ARRAY
63872: IFFALSE 64246
// begin for j = mc_miners [ i ] downto 1 do
63874: LD_ADDR_VAR 0 3
63878: PUSH
63879: DOUBLE
63880: LD_EXP 57
63884: PUSH
63885: LD_VAR 0 2
63889: ARRAY
63890: INC
63891: ST_TO_ADDR
63892: LD_INT 1
63894: PUSH
63895: FOR_DOWNTO
63896: IFFALSE 64244
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63898: LD_EXP 57
63902: PUSH
63903: LD_VAR 0 2
63907: ARRAY
63908: PUSH
63909: LD_VAR 0 3
63913: ARRAY
63914: PPUSH
63915: CALL_OW 301
63919: PUSH
63920: LD_EXP 57
63924: PUSH
63925: LD_VAR 0 2
63929: ARRAY
63930: PUSH
63931: LD_VAR 0 3
63935: ARRAY
63936: PPUSH
63937: CALL_OW 257
63941: PUSH
63942: LD_INT 1
63944: NONEQUAL
63945: OR
63946: IFFALSE 64009
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63948: LD_ADDR_VAR 0 5
63952: PUSH
63953: LD_EXP 57
63957: PUSH
63958: LD_VAR 0 2
63962: ARRAY
63963: PUSH
63964: LD_EXP 57
63968: PUSH
63969: LD_VAR 0 2
63973: ARRAY
63974: PUSH
63975: LD_VAR 0 3
63979: ARRAY
63980: DIFF
63981: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63982: LD_ADDR_EXP 57
63986: PUSH
63987: LD_EXP 57
63991: PPUSH
63992: LD_VAR 0 2
63996: PPUSH
63997: LD_VAR 0 5
64001: PPUSH
64002: CALL_OW 1
64006: ST_TO_ADDR
// continue ;
64007: GO 63895
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64009: LD_EXP 57
64013: PUSH
64014: LD_VAR 0 2
64018: ARRAY
64019: PUSH
64020: LD_VAR 0 3
64024: ARRAY
64025: PPUSH
64026: CALL_OW 257
64030: PUSH
64031: LD_INT 1
64033: EQUAL
64034: PUSH
64035: LD_EXP 57
64039: PUSH
64040: LD_VAR 0 2
64044: ARRAY
64045: PUSH
64046: LD_VAR 0 3
64050: ARRAY
64051: PPUSH
64052: CALL_OW 459
64056: NOT
64057: AND
64058: PUSH
64059: LD_EXP 57
64063: PUSH
64064: LD_VAR 0 2
64068: ARRAY
64069: PUSH
64070: LD_VAR 0 3
64074: ARRAY
64075: PPUSH
64076: CALL_OW 314
64080: NOT
64081: AND
64082: IFFALSE 64242
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64084: LD_EXP 57
64088: PUSH
64089: LD_VAR 0 2
64093: ARRAY
64094: PUSH
64095: LD_VAR 0 3
64099: ARRAY
64100: PPUSH
64101: CALL_OW 310
64105: IFFALSE 64128
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64107: LD_EXP 57
64111: PUSH
64112: LD_VAR 0 2
64116: ARRAY
64117: PUSH
64118: LD_VAR 0 3
64122: ARRAY
64123: PPUSH
64124: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64128: LD_EXP 57
64132: PUSH
64133: LD_VAR 0 2
64137: ARRAY
64138: PUSH
64139: LD_VAR 0 3
64143: ARRAY
64144: PPUSH
64145: CALL_OW 314
64149: NOT
64150: IFFALSE 64242
// begin r := rand ( 1 , mc_mines [ i ] ) ;
64152: LD_ADDR_VAR 0 7
64156: PUSH
64157: LD_INT 1
64159: PPUSH
64160: LD_EXP 56
64164: PUSH
64165: LD_VAR 0 2
64169: ARRAY
64170: PPUSH
64171: CALL_OW 12
64175: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64176: LD_EXP 57
64180: PUSH
64181: LD_VAR 0 2
64185: ARRAY
64186: PUSH
64187: LD_VAR 0 3
64191: ARRAY
64192: PPUSH
64193: LD_EXP 56
64197: PUSH
64198: LD_VAR 0 2
64202: ARRAY
64203: PUSH
64204: LD_VAR 0 7
64208: ARRAY
64209: PUSH
64210: LD_INT 1
64212: ARRAY
64213: PPUSH
64214: LD_EXP 56
64218: PUSH
64219: LD_VAR 0 2
64223: ARRAY
64224: PUSH
64225: LD_VAR 0 7
64229: ARRAY
64230: PUSH
64231: LD_INT 2
64233: ARRAY
64234: PPUSH
64235: LD_INT 0
64237: PPUSH
64238: CALL_OW 193
// end ; end ; end ;
64242: GO 63895
64244: POP
64245: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64246: LD_ADDR_VAR 0 5
64250: PUSH
64251: LD_EXP 43
64255: PUSH
64256: LD_VAR 0 2
64260: ARRAY
64261: PPUSH
64262: LD_INT 2
64264: PUSH
64265: LD_INT 30
64267: PUSH
64268: LD_INT 4
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: PUSH
64275: LD_INT 30
64277: PUSH
64278: LD_INT 5
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 30
64287: PUSH
64288: LD_INT 32
64290: PUSH
64291: EMPTY
64292: LIST
64293: LIST
64294: PUSH
64295: EMPTY
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: PPUSH
64301: CALL_OW 72
64305: ST_TO_ADDR
// if not tmp then
64306: LD_VAR 0 5
64310: NOT
64311: IFFALSE 64315
// continue ;
64313: GO 63808
// list := [ ] ;
64315: LD_ADDR_VAR 0 6
64319: PUSH
64320: EMPTY
64321: ST_TO_ADDR
// for j in tmp do
64322: LD_ADDR_VAR 0 3
64326: PUSH
64327: LD_VAR 0 5
64331: PUSH
64332: FOR_IN
64333: IFFALSE 64402
// begin for k in UnitsInside ( j ) do
64335: LD_ADDR_VAR 0 4
64339: PUSH
64340: LD_VAR 0 3
64344: PPUSH
64345: CALL_OW 313
64349: PUSH
64350: FOR_IN
64351: IFFALSE 64398
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64353: LD_VAR 0 4
64357: PPUSH
64358: CALL_OW 257
64362: PUSH
64363: LD_INT 1
64365: EQUAL
64366: PUSH
64367: LD_VAR 0 4
64371: PPUSH
64372: CALL_OW 459
64376: NOT
64377: AND
64378: IFFALSE 64396
// list := list ^ k ;
64380: LD_ADDR_VAR 0 6
64384: PUSH
64385: LD_VAR 0 6
64389: PUSH
64390: LD_VAR 0 4
64394: ADD
64395: ST_TO_ADDR
64396: GO 64350
64398: POP
64399: POP
// end ;
64400: GO 64332
64402: POP
64403: POP
// list := list diff mc_miners [ i ] ;
64404: LD_ADDR_VAR 0 6
64408: PUSH
64409: LD_VAR 0 6
64413: PUSH
64414: LD_EXP 57
64418: PUSH
64419: LD_VAR 0 2
64423: ARRAY
64424: DIFF
64425: ST_TO_ADDR
// if not list then
64426: LD_VAR 0 6
64430: NOT
64431: IFFALSE 64435
// continue ;
64433: GO 63808
// k := mc_mines [ i ] - mc_miners [ i ] ;
64435: LD_ADDR_VAR 0 4
64439: PUSH
64440: LD_EXP 56
64444: PUSH
64445: LD_VAR 0 2
64449: ARRAY
64450: PUSH
64451: LD_EXP 57
64455: PUSH
64456: LD_VAR 0 2
64460: ARRAY
64461: MINUS
64462: ST_TO_ADDR
// if k > list then
64463: LD_VAR 0 4
64467: PUSH
64468: LD_VAR 0 6
64472: GREATER
64473: IFFALSE 64485
// k := list ;
64475: LD_ADDR_VAR 0 4
64479: PUSH
64480: LD_VAR 0 6
64484: ST_TO_ADDR
// for j = 1 to k do
64485: LD_ADDR_VAR 0 3
64489: PUSH
64490: DOUBLE
64491: LD_INT 1
64493: DEC
64494: ST_TO_ADDR
64495: LD_VAR 0 4
64499: PUSH
64500: FOR_TO
64501: IFFALSE 64555
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64503: LD_ADDR_EXP 57
64507: PUSH
64508: LD_EXP 57
64512: PPUSH
64513: LD_VAR 0 2
64517: PUSH
64518: LD_EXP 57
64522: PUSH
64523: LD_VAR 0 2
64527: ARRAY
64528: PUSH
64529: LD_INT 1
64531: PLUS
64532: PUSH
64533: EMPTY
64534: LIST
64535: LIST
64536: PPUSH
64537: LD_VAR 0 6
64541: PUSH
64542: LD_VAR 0 3
64546: ARRAY
64547: PPUSH
64548: CALL 14988 0 3
64552: ST_TO_ADDR
64553: GO 64500
64555: POP
64556: POP
// end ;
64557: GO 63808
64559: POP
64560: POP
// end ;
64561: LD_VAR 0 1
64565: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64566: LD_INT 0
64568: PPUSH
64569: PPUSH
64570: PPUSH
64571: PPUSH
64572: PPUSH
64573: PPUSH
64574: PPUSH
64575: PPUSH
64576: PPUSH
64577: PPUSH
64578: PPUSH
// if not mc_bases then
64579: LD_EXP 43
64583: NOT
64584: IFFALSE 64588
// exit ;
64586: GO 66411
// for i = 1 to mc_bases do
64588: LD_ADDR_VAR 0 2
64592: PUSH
64593: DOUBLE
64594: LD_INT 1
64596: DEC
64597: ST_TO_ADDR
64598: LD_EXP 43
64602: PUSH
64603: FOR_TO
64604: IFFALSE 66409
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64606: LD_EXP 43
64610: PUSH
64611: LD_VAR 0 2
64615: ARRAY
64616: NOT
64617: PUSH
64618: LD_EXP 50
64622: PUSH
64623: LD_VAR 0 2
64627: ARRAY
64628: OR
64629: IFFALSE 64633
// continue ;
64631: GO 64603
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64633: LD_EXP 59
64637: PUSH
64638: LD_VAR 0 2
64642: ARRAY
64643: NOT
64644: PUSH
64645: LD_EXP 60
64649: PUSH
64650: LD_VAR 0 2
64654: ARRAY
64655: AND
64656: IFFALSE 64694
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64658: LD_ADDR_EXP 60
64662: PUSH
64663: LD_EXP 60
64667: PPUSH
64668: LD_VAR 0 2
64672: PPUSH
64673: EMPTY
64674: PPUSH
64675: CALL_OW 1
64679: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64680: LD_VAR 0 2
64684: PPUSH
64685: LD_INT 107
64687: PPUSH
64688: CALL 55441 0 2
// continue ;
64692: GO 64603
// end ; target := [ ] ;
64694: LD_ADDR_VAR 0 7
64698: PUSH
64699: EMPTY
64700: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64701: LD_ADDR_VAR 0 6
64705: PUSH
64706: LD_EXP 43
64710: PUSH
64711: LD_VAR 0 2
64715: ARRAY
64716: PUSH
64717: LD_INT 1
64719: ARRAY
64720: PPUSH
64721: CALL_OW 255
64725: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64726: LD_ADDR_VAR 0 9
64730: PUSH
64731: LD_EXP 43
64735: PUSH
64736: LD_VAR 0 2
64740: ARRAY
64741: PPUSH
64742: LD_INT 2
64744: PUSH
64745: LD_INT 30
64747: PUSH
64748: LD_INT 0
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PUSH
64755: LD_INT 30
64757: PUSH
64758: LD_INT 1
64760: PUSH
64761: EMPTY
64762: LIST
64763: LIST
64764: PUSH
64765: EMPTY
64766: LIST
64767: LIST
64768: LIST
64769: PPUSH
64770: CALL_OW 72
64774: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64775: LD_ADDR_VAR 0 3
64779: PUSH
64780: DOUBLE
64781: LD_EXP 59
64785: PUSH
64786: LD_VAR 0 2
64790: ARRAY
64791: INC
64792: ST_TO_ADDR
64793: LD_INT 1
64795: PUSH
64796: FOR_DOWNTO
64797: IFFALSE 65042
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64799: LD_EXP 59
64803: PUSH
64804: LD_VAR 0 2
64808: ARRAY
64809: PUSH
64810: LD_VAR 0 3
64814: ARRAY
64815: PUSH
64816: LD_INT 2
64818: ARRAY
64819: PPUSH
64820: LD_EXP 59
64824: PUSH
64825: LD_VAR 0 2
64829: ARRAY
64830: PUSH
64831: LD_VAR 0 3
64835: ARRAY
64836: PUSH
64837: LD_INT 3
64839: ARRAY
64840: PPUSH
64841: CALL_OW 488
64845: PUSH
64846: LD_EXP 59
64850: PUSH
64851: LD_VAR 0 2
64855: ARRAY
64856: PUSH
64857: LD_VAR 0 3
64861: ARRAY
64862: PUSH
64863: LD_INT 2
64865: ARRAY
64866: PPUSH
64867: LD_EXP 59
64871: PUSH
64872: LD_VAR 0 2
64876: ARRAY
64877: PUSH
64878: LD_VAR 0 3
64882: ARRAY
64883: PUSH
64884: LD_INT 3
64886: ARRAY
64887: PPUSH
64888: CALL_OW 284
64892: PUSH
64893: LD_INT 0
64895: EQUAL
64896: AND
64897: IFFALSE 64952
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64899: LD_ADDR_VAR 0 5
64903: PUSH
64904: LD_EXP 59
64908: PUSH
64909: LD_VAR 0 2
64913: ARRAY
64914: PPUSH
64915: LD_VAR 0 3
64919: PPUSH
64920: CALL_OW 3
64924: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64925: LD_ADDR_EXP 59
64929: PUSH
64930: LD_EXP 59
64934: PPUSH
64935: LD_VAR 0 2
64939: PPUSH
64940: LD_VAR 0 5
64944: PPUSH
64945: CALL_OW 1
64949: ST_TO_ADDR
// continue ;
64950: GO 64796
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64952: LD_VAR 0 6
64956: PPUSH
64957: LD_EXP 59
64961: PUSH
64962: LD_VAR 0 2
64966: ARRAY
64967: PUSH
64968: LD_VAR 0 3
64972: ARRAY
64973: PUSH
64974: LD_INT 2
64976: ARRAY
64977: PPUSH
64978: LD_EXP 59
64982: PUSH
64983: LD_VAR 0 2
64987: ARRAY
64988: PUSH
64989: LD_VAR 0 3
64993: ARRAY
64994: PUSH
64995: LD_INT 3
64997: ARRAY
64998: PPUSH
64999: LD_INT 30
65001: PPUSH
65002: CALL 15884 0 4
65006: PUSH
65007: LD_INT 4
65009: ARRAY
65010: PUSH
65011: LD_INT 0
65013: EQUAL
65014: IFFALSE 65040
// begin target := mc_crates [ i ] [ j ] ;
65016: LD_ADDR_VAR 0 7
65020: PUSH
65021: LD_EXP 59
65025: PUSH
65026: LD_VAR 0 2
65030: ARRAY
65031: PUSH
65032: LD_VAR 0 3
65036: ARRAY
65037: ST_TO_ADDR
// break ;
65038: GO 65042
// end ; end ;
65040: GO 64796
65042: POP
65043: POP
// if not target then
65044: LD_VAR 0 7
65048: NOT
65049: IFFALSE 65053
// continue ;
65051: GO 64603
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65053: LD_ADDR_VAR 0 8
65057: PUSH
65058: LD_EXP 62
65062: PUSH
65063: LD_VAR 0 2
65067: ARRAY
65068: PPUSH
65069: LD_INT 2
65071: PUSH
65072: LD_INT 3
65074: PUSH
65075: LD_INT 58
65077: PUSH
65078: EMPTY
65079: LIST
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: PUSH
65085: LD_INT 61
65087: PUSH
65088: EMPTY
65089: LIST
65090: PUSH
65091: LD_INT 33
65093: PUSH
65094: LD_INT 5
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PUSH
65101: LD_INT 33
65103: PUSH
65104: LD_INT 3
65106: PUSH
65107: EMPTY
65108: LIST
65109: LIST
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: LIST
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 2
65120: PUSH
65121: LD_INT 34
65123: PUSH
65124: LD_INT 32
65126: PUSH
65127: EMPTY
65128: LIST
65129: LIST
65130: PUSH
65131: LD_INT 34
65133: PUSH
65134: LD_INT 51
65136: PUSH
65137: EMPTY
65138: LIST
65139: LIST
65140: PUSH
65141: LD_INT 34
65143: PUSH
65144: LD_INT 12
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PUSH
65151: EMPTY
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: PUSH
65157: EMPTY
65158: LIST
65159: LIST
65160: PPUSH
65161: CALL_OW 72
65165: ST_TO_ADDR
// if not cargo then
65166: LD_VAR 0 8
65170: NOT
65171: IFFALSE 65877
// begin if mc_crates_collector [ i ] < 5 then
65173: LD_EXP 60
65177: PUSH
65178: LD_VAR 0 2
65182: ARRAY
65183: PUSH
65184: LD_INT 5
65186: LESS
65187: IFFALSE 65553
// begin if mc_ape [ i ] then
65189: LD_EXP 72
65193: PUSH
65194: LD_VAR 0 2
65198: ARRAY
65199: IFFALSE 65246
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65201: LD_ADDR_VAR 0 5
65205: PUSH
65206: LD_EXP 72
65210: PUSH
65211: LD_VAR 0 2
65215: ARRAY
65216: PPUSH
65217: LD_INT 25
65219: PUSH
65220: LD_INT 16
65222: PUSH
65223: EMPTY
65224: LIST
65225: LIST
65226: PUSH
65227: LD_INT 24
65229: PUSH
65230: LD_INT 750
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: PPUSH
65241: CALL_OW 72
65245: ST_TO_ADDR
// if not tmp then
65246: LD_VAR 0 5
65250: NOT
65251: IFFALSE 65298
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65253: LD_ADDR_VAR 0 5
65257: PUSH
65258: LD_EXP 43
65262: PUSH
65263: LD_VAR 0 2
65267: ARRAY
65268: PPUSH
65269: LD_INT 25
65271: PUSH
65272: LD_INT 2
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 24
65281: PUSH
65282: LD_INT 750
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: EMPTY
65290: LIST
65291: LIST
65292: PPUSH
65293: CALL_OW 72
65297: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65298: LD_EXP 72
65302: PUSH
65303: LD_VAR 0 2
65307: ARRAY
65308: PUSH
65309: LD_EXP 43
65313: PUSH
65314: LD_VAR 0 2
65318: ARRAY
65319: PPUSH
65320: LD_INT 25
65322: PUSH
65323: LD_INT 2
65325: PUSH
65326: EMPTY
65327: LIST
65328: LIST
65329: PUSH
65330: LD_INT 24
65332: PUSH
65333: LD_INT 750
65335: PUSH
65336: EMPTY
65337: LIST
65338: LIST
65339: PUSH
65340: EMPTY
65341: LIST
65342: LIST
65343: PPUSH
65344: CALL_OW 72
65348: AND
65349: PUSH
65350: LD_VAR 0 5
65354: PUSH
65355: LD_INT 5
65357: LESS
65358: AND
65359: IFFALSE 65441
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65361: LD_ADDR_VAR 0 3
65365: PUSH
65366: LD_EXP 43
65370: PUSH
65371: LD_VAR 0 2
65375: ARRAY
65376: PPUSH
65377: LD_INT 25
65379: PUSH
65380: LD_INT 2
65382: PUSH
65383: EMPTY
65384: LIST
65385: LIST
65386: PUSH
65387: LD_INT 24
65389: PUSH
65390: LD_INT 750
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: PUSH
65397: EMPTY
65398: LIST
65399: LIST
65400: PPUSH
65401: CALL_OW 72
65405: PUSH
65406: FOR_IN
65407: IFFALSE 65439
// begin tmp := tmp union j ;
65409: LD_ADDR_VAR 0 5
65413: PUSH
65414: LD_VAR 0 5
65418: PUSH
65419: LD_VAR 0 3
65423: UNION
65424: ST_TO_ADDR
// if tmp >= 5 then
65425: LD_VAR 0 5
65429: PUSH
65430: LD_INT 5
65432: GREATEREQUAL
65433: IFFALSE 65437
// break ;
65435: GO 65439
// end ;
65437: GO 65406
65439: POP
65440: POP
// end ; if not tmp then
65441: LD_VAR 0 5
65445: NOT
65446: IFFALSE 65450
// continue ;
65448: GO 64603
// for j in tmp do
65450: LD_ADDR_VAR 0 3
65454: PUSH
65455: LD_VAR 0 5
65459: PUSH
65460: FOR_IN
65461: IFFALSE 65551
// if not GetTag ( j ) then
65463: LD_VAR 0 3
65467: PPUSH
65468: CALL_OW 110
65472: NOT
65473: IFFALSE 65549
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65475: LD_ADDR_EXP 60
65479: PUSH
65480: LD_EXP 60
65484: PPUSH
65485: LD_VAR 0 2
65489: PUSH
65490: LD_EXP 60
65494: PUSH
65495: LD_VAR 0 2
65499: ARRAY
65500: PUSH
65501: LD_INT 1
65503: PLUS
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PPUSH
65509: LD_VAR 0 3
65513: PPUSH
65514: CALL 14988 0 3
65518: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65519: LD_VAR 0 3
65523: PPUSH
65524: LD_INT 107
65526: PPUSH
65527: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65531: LD_EXP 60
65535: PUSH
65536: LD_VAR 0 2
65540: ARRAY
65541: PUSH
65542: LD_INT 5
65544: GREATEREQUAL
65545: IFFALSE 65549
// break ;
65547: GO 65551
// end ;
65549: GO 65460
65551: POP
65552: POP
// end ; if mc_crates_collector [ i ] and target then
65553: LD_EXP 60
65557: PUSH
65558: LD_VAR 0 2
65562: ARRAY
65563: PUSH
65564: LD_VAR 0 7
65568: AND
65569: IFFALSE 65875
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65571: LD_EXP 60
65575: PUSH
65576: LD_VAR 0 2
65580: ARRAY
65581: PUSH
65582: LD_VAR 0 7
65586: PUSH
65587: LD_INT 1
65589: ARRAY
65590: LESS
65591: IFFALSE 65611
// tmp := mc_crates_collector [ i ] else
65593: LD_ADDR_VAR 0 5
65597: PUSH
65598: LD_EXP 60
65602: PUSH
65603: LD_VAR 0 2
65607: ARRAY
65608: ST_TO_ADDR
65609: GO 65625
// tmp := target [ 1 ] ;
65611: LD_ADDR_VAR 0 5
65615: PUSH
65616: LD_VAR 0 7
65620: PUSH
65621: LD_INT 1
65623: ARRAY
65624: ST_TO_ADDR
// k := 0 ;
65625: LD_ADDR_VAR 0 4
65629: PUSH
65630: LD_INT 0
65632: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65633: LD_ADDR_VAR 0 3
65637: PUSH
65638: LD_EXP 60
65642: PUSH
65643: LD_VAR 0 2
65647: ARRAY
65648: PUSH
65649: FOR_IN
65650: IFFALSE 65873
// begin k := k + 1 ;
65652: LD_ADDR_VAR 0 4
65656: PUSH
65657: LD_VAR 0 4
65661: PUSH
65662: LD_INT 1
65664: PLUS
65665: ST_TO_ADDR
// if k > tmp then
65666: LD_VAR 0 4
65670: PUSH
65671: LD_VAR 0 5
65675: GREATER
65676: IFFALSE 65680
// break ;
65678: GO 65873
// if not GetClass ( j ) in [ 2 , 16 ] then
65680: LD_VAR 0 3
65684: PPUSH
65685: CALL_OW 257
65689: PUSH
65690: LD_INT 2
65692: PUSH
65693: LD_INT 16
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: IN
65700: NOT
65701: IFFALSE 65754
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65703: LD_ADDR_EXP 60
65707: PUSH
65708: LD_EXP 60
65712: PPUSH
65713: LD_VAR 0 2
65717: PPUSH
65718: LD_EXP 60
65722: PUSH
65723: LD_VAR 0 2
65727: ARRAY
65728: PUSH
65729: LD_VAR 0 3
65733: DIFF
65734: PPUSH
65735: CALL_OW 1
65739: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65740: LD_VAR 0 3
65744: PPUSH
65745: LD_INT 0
65747: PPUSH
65748: CALL_OW 109
// continue ;
65752: GO 65649
// end ; if IsInUnit ( j ) then
65754: LD_VAR 0 3
65758: PPUSH
65759: CALL_OW 310
65763: IFFALSE 65774
// ComExitBuilding ( j ) ;
65765: LD_VAR 0 3
65769: PPUSH
65770: CALL_OW 122
// wait ( 3 ) ;
65774: LD_INT 3
65776: PPUSH
65777: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65781: LD_VAR 0 3
65785: PPUSH
65786: CALL_OW 314
65790: PUSH
65791: LD_VAR 0 6
65795: PPUSH
65796: LD_VAR 0 7
65800: PUSH
65801: LD_INT 2
65803: ARRAY
65804: PPUSH
65805: LD_VAR 0 7
65809: PUSH
65810: LD_INT 3
65812: ARRAY
65813: PPUSH
65814: LD_INT 30
65816: PPUSH
65817: CALL 15884 0 4
65821: PUSH
65822: LD_INT 4
65824: ARRAY
65825: AND
65826: IFFALSE 65844
// ComStandNearbyBuilding ( j , depot ) else
65828: LD_VAR 0 3
65832: PPUSH
65833: LD_VAR 0 9
65837: PPUSH
65838: CALL 11415 0 2
65842: GO 65871
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65844: LD_VAR 0 3
65848: PPUSH
65849: LD_VAR 0 7
65853: PUSH
65854: LD_INT 2
65856: ARRAY
65857: PPUSH
65858: LD_VAR 0 7
65862: PUSH
65863: LD_INT 3
65865: ARRAY
65866: PPUSH
65867: CALL_OW 117
// end ;
65871: GO 65649
65873: POP
65874: POP
// end ; end else
65875: GO 66407
// begin for j in cargo do
65877: LD_ADDR_VAR 0 3
65881: PUSH
65882: LD_VAR 0 8
65886: PUSH
65887: FOR_IN
65888: IFFALSE 66405
// begin if GetTag ( j ) <> 0 then
65890: LD_VAR 0 3
65894: PPUSH
65895: CALL_OW 110
65899: PUSH
65900: LD_INT 0
65902: NONEQUAL
65903: IFFALSE 65907
// continue ;
65905: GO 65887
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65907: LD_VAR 0 3
65911: PPUSH
65912: CALL_OW 256
65916: PUSH
65917: LD_INT 1000
65919: LESS
65920: PUSH
65921: LD_VAR 0 3
65925: PPUSH
65926: LD_EXP 67
65930: PUSH
65931: LD_VAR 0 2
65935: ARRAY
65936: PPUSH
65937: CALL_OW 308
65941: NOT
65942: AND
65943: IFFALSE 65965
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65945: LD_VAR 0 3
65949: PPUSH
65950: LD_EXP 67
65954: PUSH
65955: LD_VAR 0 2
65959: ARRAY
65960: PPUSH
65961: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65965: LD_VAR 0 3
65969: PPUSH
65970: CALL_OW 256
65974: PUSH
65975: LD_INT 1000
65977: LESS
65978: PUSH
65979: LD_VAR 0 3
65983: PPUSH
65984: LD_EXP 67
65988: PUSH
65989: LD_VAR 0 2
65993: ARRAY
65994: PPUSH
65995: CALL_OW 308
65999: AND
66000: IFFALSE 66004
// continue ;
66002: GO 65887
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66004: LD_VAR 0 3
66008: PPUSH
66009: CALL_OW 262
66013: PUSH
66014: LD_INT 2
66016: EQUAL
66017: PUSH
66018: LD_VAR 0 3
66022: PPUSH
66023: CALL_OW 261
66027: PUSH
66028: LD_INT 15
66030: LESS
66031: AND
66032: IFFALSE 66036
// continue ;
66034: GO 65887
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66036: LD_VAR 0 3
66040: PPUSH
66041: CALL_OW 262
66045: PUSH
66046: LD_INT 1
66048: EQUAL
66049: PUSH
66050: LD_VAR 0 3
66054: PPUSH
66055: CALL_OW 261
66059: PUSH
66060: LD_INT 10
66062: LESS
66063: AND
66064: IFFALSE 66344
// begin if not depot then
66066: LD_VAR 0 9
66070: NOT
66071: IFFALSE 66075
// continue ;
66073: GO 65887
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66075: LD_VAR 0 3
66079: PPUSH
66080: LD_VAR 0 9
66084: PPUSH
66085: LD_VAR 0 3
66089: PPUSH
66090: CALL_OW 74
66094: PPUSH
66095: CALL_OW 296
66099: PUSH
66100: LD_INT 6
66102: LESS
66103: IFFALSE 66119
// SetFuel ( j , 100 ) else
66105: LD_VAR 0 3
66109: PPUSH
66110: LD_INT 100
66112: PPUSH
66113: CALL_OW 240
66117: GO 66344
// if GetFuel ( j ) = 0 then
66119: LD_VAR 0 3
66123: PPUSH
66124: CALL_OW 261
66128: PUSH
66129: LD_INT 0
66131: EQUAL
66132: IFFALSE 66344
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66134: LD_ADDR_EXP 62
66138: PUSH
66139: LD_EXP 62
66143: PPUSH
66144: LD_VAR 0 2
66148: PPUSH
66149: LD_EXP 62
66153: PUSH
66154: LD_VAR 0 2
66158: ARRAY
66159: PUSH
66160: LD_VAR 0 3
66164: DIFF
66165: PPUSH
66166: CALL_OW 1
66170: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66171: LD_VAR 0 3
66175: PPUSH
66176: CALL_OW 263
66180: PUSH
66181: LD_INT 1
66183: EQUAL
66184: IFFALSE 66200
// ComExitVehicle ( IsInUnit ( j ) ) ;
66186: LD_VAR 0 3
66190: PPUSH
66191: CALL_OW 310
66195: PPUSH
66196: CALL_OW 121
// if GetControl ( j ) = control_remote then
66200: LD_VAR 0 3
66204: PPUSH
66205: CALL_OW 263
66209: PUSH
66210: LD_INT 2
66212: EQUAL
66213: IFFALSE 66224
// ComUnlink ( j ) ;
66215: LD_VAR 0 3
66219: PPUSH
66220: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66224: LD_ADDR_VAR 0 10
66228: PUSH
66229: LD_VAR 0 2
66233: PPUSH
66234: LD_INT 3
66236: PPUSH
66237: CALL 76011 0 2
66241: ST_TO_ADDR
// if fac then
66242: LD_VAR 0 10
66246: IFFALSE 66342
// begin for k in fac do
66248: LD_ADDR_VAR 0 4
66252: PUSH
66253: LD_VAR 0 10
66257: PUSH
66258: FOR_IN
66259: IFFALSE 66340
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66261: LD_ADDR_VAR 0 11
66265: PUSH
66266: LD_VAR 0 10
66270: PPUSH
66271: LD_VAR 0 3
66275: PPUSH
66276: CALL_OW 265
66280: PPUSH
66281: LD_VAR 0 3
66285: PPUSH
66286: CALL_OW 262
66290: PPUSH
66291: LD_VAR 0 3
66295: PPUSH
66296: CALL_OW 263
66300: PPUSH
66301: LD_VAR 0 3
66305: PPUSH
66306: CALL_OW 264
66310: PPUSH
66311: CALL 12486 0 5
66315: ST_TO_ADDR
// if components then
66316: LD_VAR 0 11
66320: IFFALSE 66338
// begin MC_InsertProduceList ( i , components ) ;
66322: LD_VAR 0 2
66326: PPUSH
66327: LD_VAR 0 11
66331: PPUSH
66332: CALL 75556 0 2
// break ;
66336: GO 66340
// end ; end ;
66338: GO 66258
66340: POP
66341: POP
// end ; continue ;
66342: GO 65887
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66344: LD_VAR 0 3
66348: PPUSH
66349: LD_INT 1
66351: PPUSH
66352: CALL_OW 289
66356: PUSH
66357: LD_INT 100
66359: LESS
66360: PUSH
66361: LD_VAR 0 3
66365: PPUSH
66366: CALL_OW 314
66370: NOT
66371: AND
66372: IFFALSE 66401
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66374: LD_VAR 0 3
66378: PPUSH
66379: LD_VAR 0 7
66383: PUSH
66384: LD_INT 2
66386: ARRAY
66387: PPUSH
66388: LD_VAR 0 7
66392: PUSH
66393: LD_INT 3
66395: ARRAY
66396: PPUSH
66397: CALL_OW 117
// break ;
66401: GO 66405
// end ;
66403: GO 65887
66405: POP
66406: POP
// end ; end ;
66407: GO 64603
66409: POP
66410: POP
// end ;
66411: LD_VAR 0 1
66415: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66416: LD_INT 0
66418: PPUSH
66419: PPUSH
66420: PPUSH
66421: PPUSH
// if not mc_bases then
66422: LD_EXP 43
66426: NOT
66427: IFFALSE 66431
// exit ;
66429: GO 66592
// for i = 1 to mc_bases do
66431: LD_ADDR_VAR 0 2
66435: PUSH
66436: DOUBLE
66437: LD_INT 1
66439: DEC
66440: ST_TO_ADDR
66441: LD_EXP 43
66445: PUSH
66446: FOR_TO
66447: IFFALSE 66590
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66449: LD_ADDR_VAR 0 4
66453: PUSH
66454: LD_EXP 62
66458: PUSH
66459: LD_VAR 0 2
66463: ARRAY
66464: PUSH
66465: LD_EXP 65
66469: PUSH
66470: LD_VAR 0 2
66474: ARRAY
66475: UNION
66476: PPUSH
66477: LD_INT 33
66479: PUSH
66480: LD_INT 2
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: PPUSH
66487: CALL_OW 72
66491: ST_TO_ADDR
// if tmp then
66492: LD_VAR 0 4
66496: IFFALSE 66588
// for j in tmp do
66498: LD_ADDR_VAR 0 3
66502: PUSH
66503: LD_VAR 0 4
66507: PUSH
66508: FOR_IN
66509: IFFALSE 66586
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66511: LD_VAR 0 3
66515: PPUSH
66516: CALL_OW 312
66520: NOT
66521: PUSH
66522: LD_VAR 0 3
66526: PPUSH
66527: CALL_OW 256
66531: PUSH
66532: LD_INT 250
66534: GREATEREQUAL
66535: AND
66536: IFFALSE 66549
// Connect ( j ) else
66538: LD_VAR 0 3
66542: PPUSH
66543: CALL 17957 0 1
66547: GO 66584
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66549: LD_VAR 0 3
66553: PPUSH
66554: CALL_OW 256
66558: PUSH
66559: LD_INT 250
66561: LESS
66562: PUSH
66563: LD_VAR 0 3
66567: PPUSH
66568: CALL_OW 312
66572: AND
66573: IFFALSE 66584
// ComUnlink ( j ) ;
66575: LD_VAR 0 3
66579: PPUSH
66580: CALL_OW 136
66584: GO 66508
66586: POP
66587: POP
// end ;
66588: GO 66446
66590: POP
66591: POP
// end ;
66592: LD_VAR 0 1
66596: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66597: LD_INT 0
66599: PPUSH
66600: PPUSH
66601: PPUSH
66602: PPUSH
66603: PPUSH
// if not mc_bases then
66604: LD_EXP 43
66608: NOT
66609: IFFALSE 66613
// exit ;
66611: GO 67058
// for i = 1 to mc_bases do
66613: LD_ADDR_VAR 0 2
66617: PUSH
66618: DOUBLE
66619: LD_INT 1
66621: DEC
66622: ST_TO_ADDR
66623: LD_EXP 43
66627: PUSH
66628: FOR_TO
66629: IFFALSE 67056
// begin if not mc_produce [ i ] then
66631: LD_EXP 64
66635: PUSH
66636: LD_VAR 0 2
66640: ARRAY
66641: NOT
66642: IFFALSE 66646
// continue ;
66644: GO 66628
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66646: LD_ADDR_VAR 0 5
66650: PUSH
66651: LD_EXP 43
66655: PUSH
66656: LD_VAR 0 2
66660: ARRAY
66661: PPUSH
66662: LD_INT 30
66664: PUSH
66665: LD_INT 3
66667: PUSH
66668: EMPTY
66669: LIST
66670: LIST
66671: PPUSH
66672: CALL_OW 72
66676: ST_TO_ADDR
// if not fac then
66677: LD_VAR 0 5
66681: NOT
66682: IFFALSE 66686
// continue ;
66684: GO 66628
// for j in fac do
66686: LD_ADDR_VAR 0 3
66690: PUSH
66691: LD_VAR 0 5
66695: PUSH
66696: FOR_IN
66697: IFFALSE 67052
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66699: LD_VAR 0 3
66703: PPUSH
66704: CALL_OW 461
66708: PUSH
66709: LD_INT 2
66711: NONEQUAL
66712: PUSH
66713: LD_VAR 0 3
66717: PPUSH
66718: LD_INT 15
66720: PPUSH
66721: CALL 17585 0 2
66725: PUSH
66726: LD_INT 4
66728: ARRAY
66729: OR
66730: IFFALSE 66734
// continue ;
66732: GO 66696
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66734: LD_VAR 0 3
66738: PPUSH
66739: LD_EXP 64
66743: PUSH
66744: LD_VAR 0 2
66748: ARRAY
66749: PUSH
66750: LD_INT 1
66752: ARRAY
66753: PUSH
66754: LD_INT 1
66756: ARRAY
66757: PPUSH
66758: LD_EXP 64
66762: PUSH
66763: LD_VAR 0 2
66767: ARRAY
66768: PUSH
66769: LD_INT 1
66771: ARRAY
66772: PUSH
66773: LD_INT 2
66775: ARRAY
66776: PPUSH
66777: LD_EXP 64
66781: PUSH
66782: LD_VAR 0 2
66786: ARRAY
66787: PUSH
66788: LD_INT 1
66790: ARRAY
66791: PUSH
66792: LD_INT 3
66794: ARRAY
66795: PPUSH
66796: LD_EXP 64
66800: PUSH
66801: LD_VAR 0 2
66805: ARRAY
66806: PUSH
66807: LD_INT 1
66809: ARRAY
66810: PUSH
66811: LD_INT 4
66813: ARRAY
66814: PPUSH
66815: CALL_OW 448
66819: PUSH
66820: LD_VAR 0 3
66824: PPUSH
66825: LD_EXP 64
66829: PUSH
66830: LD_VAR 0 2
66834: ARRAY
66835: PUSH
66836: LD_INT 1
66838: ARRAY
66839: PUSH
66840: LD_INT 1
66842: ARRAY
66843: PUSH
66844: LD_EXP 64
66848: PUSH
66849: LD_VAR 0 2
66853: ARRAY
66854: PUSH
66855: LD_INT 1
66857: ARRAY
66858: PUSH
66859: LD_INT 2
66861: ARRAY
66862: PUSH
66863: LD_EXP 64
66867: PUSH
66868: LD_VAR 0 2
66872: ARRAY
66873: PUSH
66874: LD_INT 1
66876: ARRAY
66877: PUSH
66878: LD_INT 3
66880: ARRAY
66881: PUSH
66882: LD_EXP 64
66886: PUSH
66887: LD_VAR 0 2
66891: ARRAY
66892: PUSH
66893: LD_INT 1
66895: ARRAY
66896: PUSH
66897: LD_INT 4
66899: ARRAY
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: LIST
66905: LIST
66906: PPUSH
66907: CALL 21352 0 2
66911: AND
66912: IFFALSE 67050
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66914: LD_VAR 0 3
66918: PPUSH
66919: LD_EXP 64
66923: PUSH
66924: LD_VAR 0 2
66928: ARRAY
66929: PUSH
66930: LD_INT 1
66932: ARRAY
66933: PUSH
66934: LD_INT 1
66936: ARRAY
66937: PPUSH
66938: LD_EXP 64
66942: PUSH
66943: LD_VAR 0 2
66947: ARRAY
66948: PUSH
66949: LD_INT 1
66951: ARRAY
66952: PUSH
66953: LD_INT 2
66955: ARRAY
66956: PPUSH
66957: LD_EXP 64
66961: PUSH
66962: LD_VAR 0 2
66966: ARRAY
66967: PUSH
66968: LD_INT 1
66970: ARRAY
66971: PUSH
66972: LD_INT 3
66974: ARRAY
66975: PPUSH
66976: LD_EXP 64
66980: PUSH
66981: LD_VAR 0 2
66985: ARRAY
66986: PUSH
66987: LD_INT 1
66989: ARRAY
66990: PUSH
66991: LD_INT 4
66993: ARRAY
66994: PPUSH
66995: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66999: LD_ADDR_VAR 0 4
67003: PUSH
67004: LD_EXP 64
67008: PUSH
67009: LD_VAR 0 2
67013: ARRAY
67014: PPUSH
67015: LD_INT 1
67017: PPUSH
67018: CALL_OW 3
67022: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67023: LD_ADDR_EXP 64
67027: PUSH
67028: LD_EXP 64
67032: PPUSH
67033: LD_VAR 0 2
67037: PPUSH
67038: LD_VAR 0 4
67042: PPUSH
67043: CALL_OW 1
67047: ST_TO_ADDR
// break ;
67048: GO 67052
// end ; end ;
67050: GO 66696
67052: POP
67053: POP
// end ;
67054: GO 66628
67056: POP
67057: POP
// end ;
67058: LD_VAR 0 1
67062: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67063: LD_INT 0
67065: PPUSH
67066: PPUSH
67067: PPUSH
// if not mc_bases then
67068: LD_EXP 43
67072: NOT
67073: IFFALSE 67077
// exit ;
67075: GO 67166
// for i = 1 to mc_bases do
67077: LD_ADDR_VAR 0 2
67081: PUSH
67082: DOUBLE
67083: LD_INT 1
67085: DEC
67086: ST_TO_ADDR
67087: LD_EXP 43
67091: PUSH
67092: FOR_TO
67093: IFFALSE 67164
// begin if mc_attack [ i ] then
67095: LD_EXP 63
67099: PUSH
67100: LD_VAR 0 2
67104: ARRAY
67105: IFFALSE 67162
// begin tmp := mc_attack [ i ] [ 1 ] ;
67107: LD_ADDR_VAR 0 3
67111: PUSH
67112: LD_EXP 63
67116: PUSH
67117: LD_VAR 0 2
67121: ARRAY
67122: PUSH
67123: LD_INT 1
67125: ARRAY
67126: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67127: LD_ADDR_EXP 63
67131: PUSH
67132: LD_EXP 63
67136: PPUSH
67137: LD_VAR 0 2
67141: PPUSH
67142: EMPTY
67143: PPUSH
67144: CALL_OW 1
67148: ST_TO_ADDR
// Attack ( tmp ) ;
67149: LD_VAR 0 3
67153: PPUSH
67154: CALL 81982 0 1
// exit ;
67158: POP
67159: POP
67160: GO 67166
// end ; end ;
67162: GO 67092
67164: POP
67165: POP
// end ;
67166: LD_VAR 0 1
67170: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67171: LD_INT 0
67173: PPUSH
67174: PPUSH
67175: PPUSH
67176: PPUSH
67177: PPUSH
67178: PPUSH
67179: PPUSH
// if not mc_bases then
67180: LD_EXP 43
67184: NOT
67185: IFFALSE 67189
// exit ;
67187: GO 68046
// for i = 1 to mc_bases do
67189: LD_ADDR_VAR 0 2
67193: PUSH
67194: DOUBLE
67195: LD_INT 1
67197: DEC
67198: ST_TO_ADDR
67199: LD_EXP 43
67203: PUSH
67204: FOR_TO
67205: IFFALSE 68044
// begin if not mc_bases [ i ] then
67207: LD_EXP 43
67211: PUSH
67212: LD_VAR 0 2
67216: ARRAY
67217: NOT
67218: IFFALSE 67222
// continue ;
67220: GO 67204
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67222: LD_ADDR_VAR 0 7
67226: PUSH
67227: LD_EXP 43
67231: PUSH
67232: LD_VAR 0 2
67236: ARRAY
67237: PUSH
67238: LD_INT 1
67240: ARRAY
67241: PPUSH
67242: CALL 11637 0 1
67246: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67247: LD_ADDR_EXP 66
67251: PUSH
67252: LD_EXP 66
67256: PPUSH
67257: LD_VAR 0 2
67261: PPUSH
67262: LD_EXP 43
67266: PUSH
67267: LD_VAR 0 2
67271: ARRAY
67272: PUSH
67273: LD_INT 1
67275: ARRAY
67276: PPUSH
67277: CALL_OW 255
67281: PPUSH
67282: LD_EXP 68
67286: PUSH
67287: LD_VAR 0 2
67291: ARRAY
67292: PPUSH
67293: CALL 11602 0 2
67297: PPUSH
67298: CALL_OW 1
67302: ST_TO_ADDR
// if not mc_scan [ i ] then
67303: LD_EXP 66
67307: PUSH
67308: LD_VAR 0 2
67312: ARRAY
67313: NOT
67314: IFFALSE 67492
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67316: LD_ADDR_EXP 86
67320: PUSH
67321: LD_EXP 86
67325: PPUSH
67326: LD_VAR 0 2
67330: PPUSH
67331: LD_INT 0
67333: PPUSH
67334: CALL_OW 1
67338: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67339: LD_ADDR_VAR 0 4
67343: PUSH
67344: LD_EXP 43
67348: PUSH
67349: LD_VAR 0 2
67353: ARRAY
67354: PPUSH
67355: LD_INT 2
67357: PUSH
67358: LD_INT 25
67360: PUSH
67361: LD_INT 5
67363: PUSH
67364: EMPTY
67365: LIST
67366: LIST
67367: PUSH
67368: LD_INT 25
67370: PUSH
67371: LD_INT 8
67373: PUSH
67374: EMPTY
67375: LIST
67376: LIST
67377: PUSH
67378: LD_INT 25
67380: PUSH
67381: LD_INT 9
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: LIST
67392: LIST
67393: PPUSH
67394: CALL_OW 72
67398: ST_TO_ADDR
// if not tmp then
67399: LD_VAR 0 4
67403: NOT
67404: IFFALSE 67408
// continue ;
67406: GO 67204
// for j in tmp do
67408: LD_ADDR_VAR 0 3
67412: PUSH
67413: LD_VAR 0 4
67417: PUSH
67418: FOR_IN
67419: IFFALSE 67490
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67421: LD_VAR 0 3
67425: PPUSH
67426: CALL_OW 310
67430: PPUSH
67431: CALL_OW 266
67435: PUSH
67436: LD_INT 5
67438: EQUAL
67439: PUSH
67440: LD_VAR 0 3
67444: PPUSH
67445: CALL_OW 257
67449: PUSH
67450: LD_INT 1
67452: EQUAL
67453: AND
67454: PUSH
67455: LD_VAR 0 3
67459: PPUSH
67460: CALL_OW 459
67464: NOT
67465: AND
67466: PUSH
67467: LD_VAR 0 7
67471: AND
67472: IFFALSE 67488
// ComChangeProfession ( j , class ) ;
67474: LD_VAR 0 3
67478: PPUSH
67479: LD_VAR 0 7
67483: PPUSH
67484: CALL_OW 123
67488: GO 67418
67490: POP
67491: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67492: LD_EXP 66
67496: PUSH
67497: LD_VAR 0 2
67501: ARRAY
67502: PUSH
67503: LD_EXP 86
67507: PUSH
67508: LD_VAR 0 2
67512: ARRAY
67513: NOT
67514: AND
67515: PUSH
67516: LD_EXP 65
67520: PUSH
67521: LD_VAR 0 2
67525: ARRAY
67526: NOT
67527: AND
67528: PUSH
67529: LD_EXP 43
67533: PUSH
67534: LD_VAR 0 2
67538: ARRAY
67539: PPUSH
67540: LD_INT 50
67542: PUSH
67543: EMPTY
67544: LIST
67545: PUSH
67546: LD_INT 2
67548: PUSH
67549: LD_INT 30
67551: PUSH
67552: LD_INT 32
67554: PUSH
67555: EMPTY
67556: LIST
67557: LIST
67558: PUSH
67559: LD_INT 30
67561: PUSH
67562: LD_INT 33
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 30
67571: PUSH
67572: LD_INT 4
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: PUSH
67579: LD_INT 30
67581: PUSH
67582: LD_INT 5
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PPUSH
67600: CALL_OW 72
67604: PUSH
67605: LD_INT 4
67607: LESS
67608: PUSH
67609: LD_EXP 43
67613: PUSH
67614: LD_VAR 0 2
67618: ARRAY
67619: PPUSH
67620: LD_INT 3
67622: PUSH
67623: LD_INT 24
67625: PUSH
67626: LD_INT 1000
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: PUSH
67637: LD_INT 2
67639: PUSH
67640: LD_INT 30
67642: PUSH
67643: LD_INT 0
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 30
67652: PUSH
67653: LD_INT 1
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: LIST
67664: PUSH
67665: EMPTY
67666: LIST
67667: LIST
67668: PPUSH
67669: CALL_OW 72
67673: OR
67674: AND
67675: IFFALSE 67926
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67677: LD_ADDR_EXP 86
67681: PUSH
67682: LD_EXP 86
67686: PPUSH
67687: LD_VAR 0 2
67691: PPUSH
67692: LD_INT 1
67694: PPUSH
67695: CALL_OW 1
67699: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67700: LD_ADDR_VAR 0 4
67704: PUSH
67705: LD_EXP 43
67709: PUSH
67710: LD_VAR 0 2
67714: ARRAY
67715: PPUSH
67716: LD_INT 2
67718: PUSH
67719: LD_INT 25
67721: PUSH
67722: LD_INT 1
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PUSH
67729: LD_INT 25
67731: PUSH
67732: LD_INT 5
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 25
67741: PUSH
67742: LD_INT 8
67744: PUSH
67745: EMPTY
67746: LIST
67747: LIST
67748: PUSH
67749: LD_INT 25
67751: PUSH
67752: LD_INT 9
67754: PUSH
67755: EMPTY
67756: LIST
67757: LIST
67758: PUSH
67759: EMPTY
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: PPUSH
67766: CALL_OW 72
67770: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67771: LD_ADDR_VAR 0 4
67775: PUSH
67776: LD_VAR 0 4
67780: PUSH
67781: LD_VAR 0 4
67785: PPUSH
67786: LD_INT 18
67788: PPUSH
67789: CALL 44900 0 2
67793: DIFF
67794: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67795: LD_VAR 0 4
67799: NOT
67800: PUSH
67801: LD_EXP 43
67805: PUSH
67806: LD_VAR 0 2
67810: ARRAY
67811: PPUSH
67812: LD_INT 2
67814: PUSH
67815: LD_INT 30
67817: PUSH
67818: LD_INT 4
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 30
67827: PUSH
67828: LD_INT 5
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: EMPTY
67836: LIST
67837: LIST
67838: LIST
67839: PPUSH
67840: CALL_OW 72
67844: NOT
67845: AND
67846: IFFALSE 67908
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67848: LD_ADDR_VAR 0 4
67852: PUSH
67853: LD_EXP 43
67857: PUSH
67858: LD_VAR 0 2
67862: ARRAY
67863: PPUSH
67864: LD_INT 2
67866: PUSH
67867: LD_INT 25
67869: PUSH
67870: LD_INT 2
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: LD_INT 25
67879: PUSH
67880: LD_INT 3
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: PUSH
67887: LD_INT 25
67889: PUSH
67890: LD_INT 4
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: LIST
67901: LIST
67902: PPUSH
67903: CALL_OW 72
67907: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67908: LD_VAR 0 2
67912: PPUSH
67913: LD_VAR 0 4
67917: PPUSH
67918: CALL 86691 0 2
// exit ;
67922: POP
67923: POP
67924: GO 68046
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67926: LD_EXP 66
67930: PUSH
67931: LD_VAR 0 2
67935: ARRAY
67936: PUSH
67937: LD_EXP 86
67941: PUSH
67942: LD_VAR 0 2
67946: ARRAY
67947: NOT
67948: AND
67949: PUSH
67950: LD_EXP 65
67954: PUSH
67955: LD_VAR 0 2
67959: ARRAY
67960: AND
67961: IFFALSE 68042
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67963: LD_ADDR_EXP 86
67967: PUSH
67968: LD_EXP 86
67972: PPUSH
67973: LD_VAR 0 2
67977: PPUSH
67978: LD_INT 1
67980: PPUSH
67981: CALL_OW 1
67985: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67986: LD_ADDR_VAR 0 4
67990: PUSH
67991: LD_EXP 65
67995: PUSH
67996: LD_VAR 0 2
68000: ARRAY
68001: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68002: LD_ADDR_EXP 65
68006: PUSH
68007: LD_EXP 65
68011: PPUSH
68012: LD_VAR 0 2
68016: PPUSH
68017: EMPTY
68018: PPUSH
68019: CALL_OW 1
68023: ST_TO_ADDR
// Defend ( i , tmp ) ;
68024: LD_VAR 0 2
68028: PPUSH
68029: LD_VAR 0 4
68033: PPUSH
68034: CALL 87287 0 2
// exit ;
68038: POP
68039: POP
68040: GO 68046
// end ; end ;
68042: GO 67204
68044: POP
68045: POP
// end ;
68046: LD_VAR 0 1
68050: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68051: LD_INT 0
68053: PPUSH
68054: PPUSH
68055: PPUSH
68056: PPUSH
68057: PPUSH
68058: PPUSH
68059: PPUSH
68060: PPUSH
68061: PPUSH
68062: PPUSH
68063: PPUSH
// if not mc_bases then
68064: LD_EXP 43
68068: NOT
68069: IFFALSE 68073
// exit ;
68071: GO 69160
// for i = 1 to mc_bases do
68073: LD_ADDR_VAR 0 2
68077: PUSH
68078: DOUBLE
68079: LD_INT 1
68081: DEC
68082: ST_TO_ADDR
68083: LD_EXP 43
68087: PUSH
68088: FOR_TO
68089: IFFALSE 69158
// begin tmp := mc_lab [ i ] ;
68091: LD_ADDR_VAR 0 6
68095: PUSH
68096: LD_EXP 76
68100: PUSH
68101: LD_VAR 0 2
68105: ARRAY
68106: ST_TO_ADDR
// if not tmp then
68107: LD_VAR 0 6
68111: NOT
68112: IFFALSE 68116
// continue ;
68114: GO 68088
// idle_lab := 0 ;
68116: LD_ADDR_VAR 0 11
68120: PUSH
68121: LD_INT 0
68123: ST_TO_ADDR
// for j in tmp do
68124: LD_ADDR_VAR 0 3
68128: PUSH
68129: LD_VAR 0 6
68133: PUSH
68134: FOR_IN
68135: IFFALSE 69154
// begin researching := false ;
68137: LD_ADDR_VAR 0 10
68141: PUSH
68142: LD_INT 0
68144: ST_TO_ADDR
// side := GetSide ( j ) ;
68145: LD_ADDR_VAR 0 4
68149: PUSH
68150: LD_VAR 0 3
68154: PPUSH
68155: CALL_OW 255
68159: ST_TO_ADDR
// if not mc_tech [ side ] then
68160: LD_EXP 70
68164: PUSH
68165: LD_VAR 0 4
68169: ARRAY
68170: NOT
68171: IFFALSE 68175
// continue ;
68173: GO 68134
// if BuildingStatus ( j ) = bs_idle then
68175: LD_VAR 0 3
68179: PPUSH
68180: CALL_OW 461
68184: PUSH
68185: LD_INT 2
68187: EQUAL
68188: IFFALSE 68376
// begin if idle_lab and UnitsInside ( j ) < 6 then
68190: LD_VAR 0 11
68194: PUSH
68195: LD_VAR 0 3
68199: PPUSH
68200: CALL_OW 313
68204: PUSH
68205: LD_INT 6
68207: LESS
68208: AND
68209: IFFALSE 68280
// begin tmp2 := UnitsInside ( idle_lab ) ;
68211: LD_ADDR_VAR 0 9
68215: PUSH
68216: LD_VAR 0 11
68220: PPUSH
68221: CALL_OW 313
68225: ST_TO_ADDR
// if tmp2 then
68226: LD_VAR 0 9
68230: IFFALSE 68272
// for x in tmp2 do
68232: LD_ADDR_VAR 0 7
68236: PUSH
68237: LD_VAR 0 9
68241: PUSH
68242: FOR_IN
68243: IFFALSE 68270
// begin ComExitBuilding ( x ) ;
68245: LD_VAR 0 7
68249: PPUSH
68250: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68254: LD_VAR 0 7
68258: PPUSH
68259: LD_VAR 0 3
68263: PPUSH
68264: CALL_OW 180
// end ;
68268: GO 68242
68270: POP
68271: POP
// idle_lab := 0 ;
68272: LD_ADDR_VAR 0 11
68276: PUSH
68277: LD_INT 0
68279: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68280: LD_ADDR_VAR 0 5
68284: PUSH
68285: LD_EXP 70
68289: PUSH
68290: LD_VAR 0 4
68294: ARRAY
68295: PUSH
68296: FOR_IN
68297: IFFALSE 68357
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68299: LD_VAR 0 3
68303: PPUSH
68304: LD_VAR 0 5
68308: PPUSH
68309: CALL_OW 430
68313: PUSH
68314: LD_VAR 0 4
68318: PPUSH
68319: LD_VAR 0 5
68323: PPUSH
68324: CALL 10707 0 2
68328: AND
68329: IFFALSE 68355
// begin researching := true ;
68331: LD_ADDR_VAR 0 10
68335: PUSH
68336: LD_INT 1
68338: ST_TO_ADDR
// ComResearch ( j , t ) ;
68339: LD_VAR 0 3
68343: PPUSH
68344: LD_VAR 0 5
68348: PPUSH
68349: CALL_OW 124
// break ;
68353: GO 68357
// end ;
68355: GO 68296
68357: POP
68358: POP
// if not researching then
68359: LD_VAR 0 10
68363: NOT
68364: IFFALSE 68376
// idle_lab := j ;
68366: LD_ADDR_VAR 0 11
68370: PUSH
68371: LD_VAR 0 3
68375: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68376: LD_VAR 0 3
68380: PPUSH
68381: CALL_OW 461
68385: PUSH
68386: LD_INT 10
68388: EQUAL
68389: IFFALSE 68977
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68391: LD_EXP 72
68395: PUSH
68396: LD_VAR 0 2
68400: ARRAY
68401: NOT
68402: PUSH
68403: LD_EXP 73
68407: PUSH
68408: LD_VAR 0 2
68412: ARRAY
68413: NOT
68414: AND
68415: PUSH
68416: LD_EXP 70
68420: PUSH
68421: LD_VAR 0 4
68425: ARRAY
68426: PUSH
68427: LD_INT 1
68429: GREATER
68430: AND
68431: IFFALSE 68562
// begin ComCancel ( j ) ;
68433: LD_VAR 0 3
68437: PPUSH
68438: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68442: LD_ADDR_EXP 70
68446: PUSH
68447: LD_EXP 70
68451: PPUSH
68452: LD_VAR 0 4
68456: PPUSH
68457: LD_EXP 70
68461: PUSH
68462: LD_VAR 0 4
68466: ARRAY
68467: PPUSH
68468: LD_EXP 70
68472: PUSH
68473: LD_VAR 0 4
68477: ARRAY
68478: PUSH
68479: LD_INT 1
68481: MINUS
68482: PPUSH
68483: LD_EXP 70
68487: PUSH
68488: LD_VAR 0 4
68492: ARRAY
68493: PPUSH
68494: LD_INT 0
68496: PPUSH
68497: CALL 14406 0 4
68501: PPUSH
68502: CALL_OW 1
68506: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68507: LD_ADDR_EXP 70
68511: PUSH
68512: LD_EXP 70
68516: PPUSH
68517: LD_VAR 0 4
68521: PPUSH
68522: LD_EXP 70
68526: PUSH
68527: LD_VAR 0 4
68531: ARRAY
68532: PPUSH
68533: LD_EXP 70
68537: PUSH
68538: LD_VAR 0 4
68542: ARRAY
68543: PPUSH
68544: LD_INT 1
68546: PPUSH
68547: LD_INT 0
68549: PPUSH
68550: CALL 14406 0 4
68554: PPUSH
68555: CALL_OW 1
68559: ST_TO_ADDR
// continue ;
68560: GO 68134
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68562: LD_EXP 72
68566: PUSH
68567: LD_VAR 0 2
68571: ARRAY
68572: PUSH
68573: LD_EXP 73
68577: PUSH
68578: LD_VAR 0 2
68582: ARRAY
68583: NOT
68584: AND
68585: IFFALSE 68712
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68587: LD_ADDR_EXP 73
68591: PUSH
68592: LD_EXP 73
68596: PPUSH
68597: LD_VAR 0 2
68601: PUSH
68602: LD_EXP 73
68606: PUSH
68607: LD_VAR 0 2
68611: ARRAY
68612: PUSH
68613: LD_INT 1
68615: PLUS
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PPUSH
68621: LD_EXP 72
68625: PUSH
68626: LD_VAR 0 2
68630: ARRAY
68631: PUSH
68632: LD_INT 1
68634: ARRAY
68635: PPUSH
68636: CALL 14988 0 3
68640: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68641: LD_EXP 72
68645: PUSH
68646: LD_VAR 0 2
68650: ARRAY
68651: PUSH
68652: LD_INT 1
68654: ARRAY
68655: PPUSH
68656: LD_INT 112
68658: PPUSH
68659: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68663: LD_ADDR_VAR 0 9
68667: PUSH
68668: LD_EXP 72
68672: PUSH
68673: LD_VAR 0 2
68677: ARRAY
68678: PPUSH
68679: LD_INT 1
68681: PPUSH
68682: CALL_OW 3
68686: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68687: LD_ADDR_EXP 72
68691: PUSH
68692: LD_EXP 72
68696: PPUSH
68697: LD_VAR 0 2
68701: PPUSH
68702: LD_VAR 0 9
68706: PPUSH
68707: CALL_OW 1
68711: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68712: LD_EXP 72
68716: PUSH
68717: LD_VAR 0 2
68721: ARRAY
68722: PUSH
68723: LD_EXP 73
68727: PUSH
68728: LD_VAR 0 2
68732: ARRAY
68733: AND
68734: PUSH
68735: LD_EXP 73
68739: PUSH
68740: LD_VAR 0 2
68744: ARRAY
68745: PUSH
68746: LD_INT 1
68748: ARRAY
68749: PPUSH
68750: CALL_OW 310
68754: NOT
68755: AND
68756: PUSH
68757: LD_VAR 0 3
68761: PPUSH
68762: CALL_OW 313
68766: PUSH
68767: LD_INT 6
68769: EQUAL
68770: AND
68771: IFFALSE 68827
// begin tmp2 := UnitsInside ( j ) ;
68773: LD_ADDR_VAR 0 9
68777: PUSH
68778: LD_VAR 0 3
68782: PPUSH
68783: CALL_OW 313
68787: ST_TO_ADDR
// if tmp2 = 6 then
68788: LD_VAR 0 9
68792: PUSH
68793: LD_INT 6
68795: EQUAL
68796: IFFALSE 68827
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68798: LD_VAR 0 9
68802: PUSH
68803: LD_INT 1
68805: ARRAY
68806: PPUSH
68807: LD_INT 112
68809: PPUSH
68810: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68814: LD_VAR 0 9
68818: PUSH
68819: LD_INT 1
68821: ARRAY
68822: PPUSH
68823: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68827: LD_EXP 73
68831: PUSH
68832: LD_VAR 0 2
68836: ARRAY
68837: PUSH
68838: LD_EXP 73
68842: PUSH
68843: LD_VAR 0 2
68847: ARRAY
68848: PUSH
68849: LD_INT 1
68851: ARRAY
68852: PPUSH
68853: CALL_OW 314
68857: NOT
68858: AND
68859: PUSH
68860: LD_EXP 73
68864: PUSH
68865: LD_VAR 0 2
68869: ARRAY
68870: PUSH
68871: LD_INT 1
68873: ARRAY
68874: PPUSH
68875: CALL_OW 310
68879: NOT
68880: AND
68881: IFFALSE 68907
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68883: LD_EXP 73
68887: PUSH
68888: LD_VAR 0 2
68892: ARRAY
68893: PUSH
68894: LD_INT 1
68896: ARRAY
68897: PPUSH
68898: LD_VAR 0 3
68902: PPUSH
68903: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68907: LD_EXP 73
68911: PUSH
68912: LD_VAR 0 2
68916: ARRAY
68917: PUSH
68918: LD_INT 1
68920: ARRAY
68921: PPUSH
68922: CALL_OW 310
68926: PUSH
68927: LD_EXP 73
68931: PUSH
68932: LD_VAR 0 2
68936: ARRAY
68937: PUSH
68938: LD_INT 1
68940: ARRAY
68941: PPUSH
68942: CALL_OW 310
68946: PPUSH
68947: CALL_OW 461
68951: PUSH
68952: LD_INT 3
68954: NONEQUAL
68955: AND
68956: IFFALSE 68977
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68958: LD_EXP 73
68962: PUSH
68963: LD_VAR 0 2
68967: ARRAY
68968: PUSH
68969: LD_INT 1
68971: ARRAY
68972: PPUSH
68973: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68977: LD_VAR 0 3
68981: PPUSH
68982: CALL_OW 461
68986: PUSH
68987: LD_INT 6
68989: EQUAL
68990: PUSH
68991: LD_VAR 0 6
68995: PUSH
68996: LD_INT 1
68998: GREATER
68999: AND
69000: IFFALSE 69152
// begin sci := [ ] ;
69002: LD_ADDR_VAR 0 8
69006: PUSH
69007: EMPTY
69008: ST_TO_ADDR
// for x in ( tmp diff j ) do
69009: LD_ADDR_VAR 0 7
69013: PUSH
69014: LD_VAR 0 6
69018: PUSH
69019: LD_VAR 0 3
69023: DIFF
69024: PUSH
69025: FOR_IN
69026: IFFALSE 69078
// begin if sci = 6 then
69028: LD_VAR 0 8
69032: PUSH
69033: LD_INT 6
69035: EQUAL
69036: IFFALSE 69040
// break ;
69038: GO 69078
// if BuildingStatus ( x ) = bs_idle then
69040: LD_VAR 0 7
69044: PPUSH
69045: CALL_OW 461
69049: PUSH
69050: LD_INT 2
69052: EQUAL
69053: IFFALSE 69076
// sci := sci ^ UnitsInside ( x ) ;
69055: LD_ADDR_VAR 0 8
69059: PUSH
69060: LD_VAR 0 8
69064: PUSH
69065: LD_VAR 0 7
69069: PPUSH
69070: CALL_OW 313
69074: ADD
69075: ST_TO_ADDR
// end ;
69076: GO 69025
69078: POP
69079: POP
// if not sci then
69080: LD_VAR 0 8
69084: NOT
69085: IFFALSE 69089
// continue ;
69087: GO 68134
// for x in sci do
69089: LD_ADDR_VAR 0 7
69093: PUSH
69094: LD_VAR 0 8
69098: PUSH
69099: FOR_IN
69100: IFFALSE 69150
// if IsInUnit ( x ) and not HasTask ( x ) then
69102: LD_VAR 0 7
69106: PPUSH
69107: CALL_OW 310
69111: PUSH
69112: LD_VAR 0 7
69116: PPUSH
69117: CALL_OW 314
69121: NOT
69122: AND
69123: IFFALSE 69148
// begin ComExitBuilding ( x ) ;
69125: LD_VAR 0 7
69129: PPUSH
69130: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69134: LD_VAR 0 7
69138: PPUSH
69139: LD_VAR 0 3
69143: PPUSH
69144: CALL_OW 180
// end ;
69148: GO 69099
69150: POP
69151: POP
// end ; end ;
69152: GO 68134
69154: POP
69155: POP
// end ;
69156: GO 68088
69158: POP
69159: POP
// end ;
69160: LD_VAR 0 1
69164: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69165: LD_INT 0
69167: PPUSH
69168: PPUSH
// if not mc_bases then
69169: LD_EXP 43
69173: NOT
69174: IFFALSE 69178
// exit ;
69176: GO 69259
// for i = 1 to mc_bases do
69178: LD_ADDR_VAR 0 2
69182: PUSH
69183: DOUBLE
69184: LD_INT 1
69186: DEC
69187: ST_TO_ADDR
69188: LD_EXP 43
69192: PUSH
69193: FOR_TO
69194: IFFALSE 69257
// if mc_mines [ i ] and mc_miners [ i ] then
69196: LD_EXP 56
69200: PUSH
69201: LD_VAR 0 2
69205: ARRAY
69206: PUSH
69207: LD_EXP 57
69211: PUSH
69212: LD_VAR 0 2
69216: ARRAY
69217: AND
69218: IFFALSE 69255
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69220: LD_EXP 57
69224: PUSH
69225: LD_VAR 0 2
69229: ARRAY
69230: PUSH
69231: LD_INT 1
69233: ARRAY
69234: PPUSH
69235: CALL_OW 255
69239: PPUSH
69240: LD_EXP 56
69244: PUSH
69245: LD_VAR 0 2
69249: ARRAY
69250: PPUSH
69251: CALL 11790 0 2
69255: GO 69193
69257: POP
69258: POP
// end ;
69259: LD_VAR 0 1
69263: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69264: LD_INT 0
69266: PPUSH
69267: PPUSH
69268: PPUSH
69269: PPUSH
69270: PPUSH
69271: PPUSH
69272: PPUSH
69273: PPUSH
// if not mc_bases or not mc_parking then
69274: LD_EXP 43
69278: NOT
69279: PUSH
69280: LD_EXP 67
69284: NOT
69285: OR
69286: IFFALSE 69290
// exit ;
69288: GO 70028
// for i = 1 to mc_bases do
69290: LD_ADDR_VAR 0 2
69294: PUSH
69295: DOUBLE
69296: LD_INT 1
69298: DEC
69299: ST_TO_ADDR
69300: LD_EXP 43
69304: PUSH
69305: FOR_TO
69306: IFFALSE 70026
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69308: LD_EXP 43
69312: PUSH
69313: LD_VAR 0 2
69317: ARRAY
69318: NOT
69319: PUSH
69320: LD_EXP 67
69324: PUSH
69325: LD_VAR 0 2
69329: ARRAY
69330: NOT
69331: OR
69332: IFFALSE 69336
// continue ;
69334: GO 69305
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69336: LD_ADDR_VAR 0 5
69340: PUSH
69341: LD_EXP 43
69345: PUSH
69346: LD_VAR 0 2
69350: ARRAY
69351: PUSH
69352: LD_INT 1
69354: ARRAY
69355: PPUSH
69356: CALL_OW 255
69360: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69361: LD_ADDR_VAR 0 6
69365: PUSH
69366: LD_EXP 43
69370: PUSH
69371: LD_VAR 0 2
69375: ARRAY
69376: PPUSH
69377: LD_INT 30
69379: PUSH
69380: LD_INT 3
69382: PUSH
69383: EMPTY
69384: LIST
69385: LIST
69386: PPUSH
69387: CALL_OW 72
69391: ST_TO_ADDR
// if not fac then
69392: LD_VAR 0 6
69396: NOT
69397: IFFALSE 69448
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69399: LD_ADDR_VAR 0 6
69403: PUSH
69404: LD_EXP 43
69408: PUSH
69409: LD_VAR 0 2
69413: ARRAY
69414: PPUSH
69415: LD_INT 2
69417: PUSH
69418: LD_INT 30
69420: PUSH
69421: LD_INT 0
69423: PUSH
69424: EMPTY
69425: LIST
69426: LIST
69427: PUSH
69428: LD_INT 30
69430: PUSH
69431: LD_INT 1
69433: PUSH
69434: EMPTY
69435: LIST
69436: LIST
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: LIST
69442: PPUSH
69443: CALL_OW 72
69447: ST_TO_ADDR
// if not fac then
69448: LD_VAR 0 6
69452: NOT
69453: IFFALSE 69457
// continue ;
69455: GO 69305
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69457: LD_ADDR_VAR 0 7
69461: PUSH
69462: LD_EXP 67
69466: PUSH
69467: LD_VAR 0 2
69471: ARRAY
69472: PPUSH
69473: LD_INT 22
69475: PUSH
69476: LD_VAR 0 5
69480: PUSH
69481: EMPTY
69482: LIST
69483: LIST
69484: PUSH
69485: LD_INT 21
69487: PUSH
69488: LD_INT 2
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: LD_INT 3
69497: PUSH
69498: LD_INT 60
69500: PUSH
69501: EMPTY
69502: LIST
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 3
69510: PUSH
69511: LD_INT 24
69513: PUSH
69514: LD_INT 1000
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: EMPTY
69526: LIST
69527: LIST
69528: LIST
69529: LIST
69530: PPUSH
69531: CALL_OW 70
69535: ST_TO_ADDR
// for j in fac do
69536: LD_ADDR_VAR 0 3
69540: PUSH
69541: LD_VAR 0 6
69545: PUSH
69546: FOR_IN
69547: IFFALSE 69642
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69549: LD_ADDR_VAR 0 7
69553: PUSH
69554: LD_VAR 0 7
69558: PUSH
69559: LD_INT 22
69561: PUSH
69562: LD_VAR 0 5
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 91
69573: PUSH
69574: LD_VAR 0 3
69578: PUSH
69579: LD_INT 15
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 21
69589: PUSH
69590: LD_INT 2
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 3
69599: PUSH
69600: LD_INT 60
69602: PUSH
69603: EMPTY
69604: LIST
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: LD_INT 3
69612: PUSH
69613: LD_INT 24
69615: PUSH
69616: LD_INT 1000
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: PPUSH
69634: CALL_OW 69
69638: UNION
69639: ST_TO_ADDR
69640: GO 69546
69642: POP
69643: POP
// if not vehs then
69644: LD_VAR 0 7
69648: NOT
69649: IFFALSE 69675
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69651: LD_ADDR_EXP 55
69655: PUSH
69656: LD_EXP 55
69660: PPUSH
69661: LD_VAR 0 2
69665: PPUSH
69666: EMPTY
69667: PPUSH
69668: CALL_OW 1
69672: ST_TO_ADDR
// continue ;
69673: GO 69305
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69675: LD_ADDR_VAR 0 8
69679: PUSH
69680: LD_EXP 43
69684: PUSH
69685: LD_VAR 0 2
69689: ARRAY
69690: PPUSH
69691: LD_INT 30
69693: PUSH
69694: LD_INT 3
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PPUSH
69701: CALL_OW 72
69705: ST_TO_ADDR
// if tmp then
69706: LD_VAR 0 8
69710: IFFALSE 69813
// begin for j in tmp do
69712: LD_ADDR_VAR 0 3
69716: PUSH
69717: LD_VAR 0 8
69721: PUSH
69722: FOR_IN
69723: IFFALSE 69811
// for k in UnitsInside ( j ) do
69725: LD_ADDR_VAR 0 4
69729: PUSH
69730: LD_VAR 0 3
69734: PPUSH
69735: CALL_OW 313
69739: PUSH
69740: FOR_IN
69741: IFFALSE 69807
// if k then
69743: LD_VAR 0 4
69747: IFFALSE 69805
// if not k in mc_repair_vehicle [ i ] then
69749: LD_VAR 0 4
69753: PUSH
69754: LD_EXP 55
69758: PUSH
69759: LD_VAR 0 2
69763: ARRAY
69764: IN
69765: NOT
69766: IFFALSE 69805
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69768: LD_ADDR_EXP 55
69772: PUSH
69773: LD_EXP 55
69777: PPUSH
69778: LD_VAR 0 2
69782: PPUSH
69783: LD_EXP 55
69787: PUSH
69788: LD_VAR 0 2
69792: ARRAY
69793: PUSH
69794: LD_VAR 0 4
69798: UNION
69799: PPUSH
69800: CALL_OW 1
69804: ST_TO_ADDR
69805: GO 69740
69807: POP
69808: POP
69809: GO 69722
69811: POP
69812: POP
// end ; if not mc_repair_vehicle [ i ] then
69813: LD_EXP 55
69817: PUSH
69818: LD_VAR 0 2
69822: ARRAY
69823: NOT
69824: IFFALSE 69828
// continue ;
69826: GO 69305
// for j in mc_repair_vehicle [ i ] do
69828: LD_ADDR_VAR 0 3
69832: PUSH
69833: LD_EXP 55
69837: PUSH
69838: LD_VAR 0 2
69842: ARRAY
69843: PUSH
69844: FOR_IN
69845: IFFALSE 70022
// begin if GetClass ( j ) <> 3 then
69847: LD_VAR 0 3
69851: PPUSH
69852: CALL_OW 257
69856: PUSH
69857: LD_INT 3
69859: NONEQUAL
69860: IFFALSE 69901
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69862: LD_ADDR_EXP 55
69866: PUSH
69867: LD_EXP 55
69871: PPUSH
69872: LD_VAR 0 2
69876: PPUSH
69877: LD_EXP 55
69881: PUSH
69882: LD_VAR 0 2
69886: ARRAY
69887: PUSH
69888: LD_VAR 0 3
69892: DIFF
69893: PPUSH
69894: CALL_OW 1
69898: ST_TO_ADDR
// continue ;
69899: GO 69844
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69901: LD_VAR 0 3
69905: PPUSH
69906: CALL_OW 311
69910: NOT
69911: PUSH
69912: LD_VAR 0 3
69916: PUSH
69917: LD_EXP 46
69921: PUSH
69922: LD_VAR 0 2
69926: ARRAY
69927: PUSH
69928: LD_INT 1
69930: ARRAY
69931: IN
69932: NOT
69933: AND
69934: PUSH
69935: LD_VAR 0 3
69939: PUSH
69940: LD_EXP 46
69944: PUSH
69945: LD_VAR 0 2
69949: ARRAY
69950: PUSH
69951: LD_INT 2
69953: ARRAY
69954: IN
69955: NOT
69956: AND
69957: IFFALSE 70020
// begin if IsInUnit ( j ) then
69959: LD_VAR 0 3
69963: PPUSH
69964: CALL_OW 310
69968: IFFALSE 69981
// ComExitBuilding ( j ) else
69970: LD_VAR 0 3
69974: PPUSH
69975: CALL_OW 122
69979: GO 70020
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69981: LD_VAR 0 3
69985: PPUSH
69986: LD_VAR 0 7
69990: PUSH
69991: LD_INT 1
69993: ARRAY
69994: PPUSH
69995: CALL 49384 0 2
69999: NOT
70000: IFFALSE 70020
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
70002: LD_VAR 0 3
70006: PPUSH
70007: LD_VAR 0 7
70011: PUSH
70012: LD_INT 1
70014: ARRAY
70015: PPUSH
70016: CALL_OW 129
// end ; end ;
70020: GO 69844
70022: POP
70023: POP
// end ;
70024: GO 69305
70026: POP
70027: POP
// end ;
70028: LD_VAR 0 1
70032: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70033: LD_INT 0
70035: PPUSH
70036: PPUSH
70037: PPUSH
70038: PPUSH
70039: PPUSH
70040: PPUSH
70041: PPUSH
70042: PPUSH
70043: PPUSH
70044: PPUSH
70045: PPUSH
// if not mc_bases then
70046: LD_EXP 43
70050: NOT
70051: IFFALSE 70055
// exit ;
70053: GO 70857
// for i = 1 to mc_bases do
70055: LD_ADDR_VAR 0 2
70059: PUSH
70060: DOUBLE
70061: LD_INT 1
70063: DEC
70064: ST_TO_ADDR
70065: LD_EXP 43
70069: PUSH
70070: FOR_TO
70071: IFFALSE 70855
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70073: LD_EXP 71
70077: PUSH
70078: LD_VAR 0 2
70082: ARRAY
70083: NOT
70084: PUSH
70085: LD_EXP 46
70089: PUSH
70090: LD_VAR 0 2
70094: ARRAY
70095: PUSH
70096: LD_INT 1
70098: ARRAY
70099: OR
70100: PUSH
70101: LD_EXP 46
70105: PUSH
70106: LD_VAR 0 2
70110: ARRAY
70111: PUSH
70112: LD_INT 2
70114: ARRAY
70115: OR
70116: PUSH
70117: LD_EXP 69
70121: PUSH
70122: LD_VAR 0 2
70126: ARRAY
70127: PPUSH
70128: LD_INT 1
70130: PPUSH
70131: CALL_OW 325
70135: NOT
70136: OR
70137: PUSH
70138: LD_EXP 66
70142: PUSH
70143: LD_VAR 0 2
70147: ARRAY
70148: OR
70149: IFFALSE 70153
// continue ;
70151: GO 70070
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70153: LD_ADDR_VAR 0 8
70157: PUSH
70158: LD_EXP 43
70162: PUSH
70163: LD_VAR 0 2
70167: ARRAY
70168: PPUSH
70169: LD_INT 25
70171: PUSH
70172: LD_INT 4
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: PUSH
70179: LD_INT 50
70181: PUSH
70182: EMPTY
70183: LIST
70184: PUSH
70185: LD_INT 3
70187: PUSH
70188: LD_INT 60
70190: PUSH
70191: EMPTY
70192: LIST
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: EMPTY
70199: LIST
70200: LIST
70201: LIST
70202: PPUSH
70203: CALL_OW 72
70207: PUSH
70208: LD_EXP 47
70212: PUSH
70213: LD_VAR 0 2
70217: ARRAY
70218: DIFF
70219: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70220: LD_ADDR_VAR 0 9
70224: PUSH
70225: LD_EXP 43
70229: PUSH
70230: LD_VAR 0 2
70234: ARRAY
70235: PPUSH
70236: LD_INT 2
70238: PUSH
70239: LD_INT 30
70241: PUSH
70242: LD_INT 0
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: LD_INT 30
70251: PUSH
70252: LD_INT 1
70254: PUSH
70255: EMPTY
70256: LIST
70257: LIST
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: LIST
70263: PPUSH
70264: CALL_OW 72
70268: ST_TO_ADDR
// if not tmp or not dep then
70269: LD_VAR 0 8
70273: NOT
70274: PUSH
70275: LD_VAR 0 9
70279: NOT
70280: OR
70281: IFFALSE 70285
// continue ;
70283: GO 70070
// side := GetSide ( tmp [ 1 ] ) ;
70285: LD_ADDR_VAR 0 11
70289: PUSH
70290: LD_VAR 0 8
70294: PUSH
70295: LD_INT 1
70297: ARRAY
70298: PPUSH
70299: CALL_OW 255
70303: ST_TO_ADDR
// dep := dep [ 1 ] ;
70304: LD_ADDR_VAR 0 9
70308: PUSH
70309: LD_VAR 0 9
70313: PUSH
70314: LD_INT 1
70316: ARRAY
70317: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70318: LD_ADDR_VAR 0 7
70322: PUSH
70323: LD_EXP 71
70327: PUSH
70328: LD_VAR 0 2
70332: ARRAY
70333: PPUSH
70334: LD_INT 22
70336: PUSH
70337: LD_INT 0
70339: PUSH
70340: EMPTY
70341: LIST
70342: LIST
70343: PUSH
70344: LD_INT 25
70346: PUSH
70347: LD_INT 12
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: PUSH
70354: EMPTY
70355: LIST
70356: LIST
70357: PPUSH
70358: CALL_OW 70
70362: PUSH
70363: LD_INT 22
70365: PUSH
70366: LD_INT 0
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: LD_INT 25
70375: PUSH
70376: LD_INT 12
70378: PUSH
70379: EMPTY
70380: LIST
70381: LIST
70382: PUSH
70383: LD_INT 91
70385: PUSH
70386: LD_VAR 0 9
70390: PUSH
70391: LD_INT 20
70393: PUSH
70394: EMPTY
70395: LIST
70396: LIST
70397: LIST
70398: PUSH
70399: EMPTY
70400: LIST
70401: LIST
70402: LIST
70403: PPUSH
70404: CALL_OW 69
70408: UNION
70409: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70410: LD_ADDR_VAR 0 10
70414: PUSH
70415: LD_EXP 71
70419: PUSH
70420: LD_VAR 0 2
70424: ARRAY
70425: PPUSH
70426: LD_INT 81
70428: PUSH
70429: LD_VAR 0 11
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PPUSH
70438: CALL_OW 70
70442: ST_TO_ADDR
// if not apes or danger_at_area then
70443: LD_VAR 0 7
70447: NOT
70448: PUSH
70449: LD_VAR 0 10
70453: OR
70454: IFFALSE 70504
// begin if mc_taming [ i ] then
70456: LD_EXP 74
70460: PUSH
70461: LD_VAR 0 2
70465: ARRAY
70466: IFFALSE 70502
// begin MC_Reset ( i , 121 ) ;
70468: LD_VAR 0 2
70472: PPUSH
70473: LD_INT 121
70475: PPUSH
70476: CALL 55441 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70480: LD_ADDR_EXP 74
70484: PUSH
70485: LD_EXP 74
70489: PPUSH
70490: LD_VAR 0 2
70494: PPUSH
70495: EMPTY
70496: PPUSH
70497: CALL_OW 1
70501: ST_TO_ADDR
// end ; continue ;
70502: GO 70070
// end ; for j in tmp do
70504: LD_ADDR_VAR 0 3
70508: PUSH
70509: LD_VAR 0 8
70513: PUSH
70514: FOR_IN
70515: IFFALSE 70851
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70517: LD_VAR 0 3
70521: PUSH
70522: LD_EXP 74
70526: PUSH
70527: LD_VAR 0 2
70531: ARRAY
70532: IN
70533: NOT
70534: PUSH
70535: LD_EXP 74
70539: PUSH
70540: LD_VAR 0 2
70544: ARRAY
70545: PUSH
70546: LD_INT 3
70548: LESS
70549: AND
70550: IFFALSE 70608
// begin SetTag ( j , 121 ) ;
70552: LD_VAR 0 3
70556: PPUSH
70557: LD_INT 121
70559: PPUSH
70560: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70564: LD_ADDR_EXP 74
70568: PUSH
70569: LD_EXP 74
70573: PPUSH
70574: LD_VAR 0 2
70578: PUSH
70579: LD_EXP 74
70583: PUSH
70584: LD_VAR 0 2
70588: ARRAY
70589: PUSH
70590: LD_INT 1
70592: PLUS
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PPUSH
70598: LD_VAR 0 3
70602: PPUSH
70603: CALL 14988 0 3
70607: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70608: LD_VAR 0 3
70612: PUSH
70613: LD_EXP 74
70617: PUSH
70618: LD_VAR 0 2
70622: ARRAY
70623: IN
70624: IFFALSE 70849
// begin if GetClass ( j ) <> 4 then
70626: LD_VAR 0 3
70630: PPUSH
70631: CALL_OW 257
70635: PUSH
70636: LD_INT 4
70638: NONEQUAL
70639: IFFALSE 70692
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70641: LD_ADDR_EXP 74
70645: PUSH
70646: LD_EXP 74
70650: PPUSH
70651: LD_VAR 0 2
70655: PPUSH
70656: LD_EXP 74
70660: PUSH
70661: LD_VAR 0 2
70665: ARRAY
70666: PUSH
70667: LD_VAR 0 3
70671: DIFF
70672: PPUSH
70673: CALL_OW 1
70677: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70678: LD_VAR 0 3
70682: PPUSH
70683: LD_INT 0
70685: PPUSH
70686: CALL_OW 109
// continue ;
70690: GO 70514
// end ; if IsInUnit ( j ) then
70692: LD_VAR 0 3
70696: PPUSH
70697: CALL_OW 310
70701: IFFALSE 70712
// ComExitBuilding ( j ) ;
70703: LD_VAR 0 3
70707: PPUSH
70708: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70712: LD_ADDR_VAR 0 6
70716: PUSH
70717: LD_VAR 0 7
70721: PPUSH
70722: LD_VAR 0 3
70726: PPUSH
70727: CALL_OW 74
70731: ST_TO_ADDR
// if not ape then
70732: LD_VAR 0 6
70736: NOT
70737: IFFALSE 70741
// break ;
70739: GO 70851
// x := GetX ( ape ) ;
70741: LD_ADDR_VAR 0 4
70745: PUSH
70746: LD_VAR 0 6
70750: PPUSH
70751: CALL_OW 250
70755: ST_TO_ADDR
// y := GetY ( ape ) ;
70756: LD_ADDR_VAR 0 5
70760: PUSH
70761: LD_VAR 0 6
70765: PPUSH
70766: CALL_OW 251
70770: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70771: LD_VAR 0 4
70775: PPUSH
70776: LD_VAR 0 5
70780: PPUSH
70781: CALL_OW 488
70785: NOT
70786: PUSH
70787: LD_VAR 0 11
70791: PPUSH
70792: LD_VAR 0 4
70796: PPUSH
70797: LD_VAR 0 5
70801: PPUSH
70802: LD_INT 20
70804: PPUSH
70805: CALL 15884 0 4
70809: PUSH
70810: LD_INT 4
70812: ARRAY
70813: OR
70814: IFFALSE 70818
// break ;
70816: GO 70851
// if not HasTask ( j ) then
70818: LD_VAR 0 3
70822: PPUSH
70823: CALL_OW 314
70827: NOT
70828: IFFALSE 70849
// ComTameXY ( j , x , y ) ;
70830: LD_VAR 0 3
70834: PPUSH
70835: LD_VAR 0 4
70839: PPUSH
70840: LD_VAR 0 5
70844: PPUSH
70845: CALL_OW 131
// end ; end ;
70849: GO 70514
70851: POP
70852: POP
// end ;
70853: GO 70070
70855: POP
70856: POP
// end ;
70857: LD_VAR 0 1
70861: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70862: LD_INT 0
70864: PPUSH
70865: PPUSH
70866: PPUSH
70867: PPUSH
70868: PPUSH
70869: PPUSH
70870: PPUSH
70871: PPUSH
// if not mc_bases then
70872: LD_EXP 43
70876: NOT
70877: IFFALSE 70881
// exit ;
70879: GO 71507
// for i = 1 to mc_bases do
70881: LD_ADDR_VAR 0 2
70885: PUSH
70886: DOUBLE
70887: LD_INT 1
70889: DEC
70890: ST_TO_ADDR
70891: LD_EXP 43
70895: PUSH
70896: FOR_TO
70897: IFFALSE 71505
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70899: LD_EXP 72
70903: PUSH
70904: LD_VAR 0 2
70908: ARRAY
70909: NOT
70910: PUSH
70911: LD_EXP 72
70915: PUSH
70916: LD_VAR 0 2
70920: ARRAY
70921: PPUSH
70922: LD_INT 25
70924: PUSH
70925: LD_INT 12
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: PPUSH
70932: CALL_OW 72
70936: NOT
70937: OR
70938: IFFALSE 70942
// continue ;
70940: GO 70896
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70942: LD_ADDR_VAR 0 5
70946: PUSH
70947: LD_EXP 72
70951: PUSH
70952: LD_VAR 0 2
70956: ARRAY
70957: PUSH
70958: LD_INT 1
70960: ARRAY
70961: PPUSH
70962: CALL_OW 255
70966: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70967: LD_VAR 0 5
70971: PPUSH
70972: LD_INT 2
70974: PPUSH
70975: CALL_OW 325
70979: IFFALSE 71232
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70981: LD_ADDR_VAR 0 4
70985: PUSH
70986: LD_EXP 72
70990: PUSH
70991: LD_VAR 0 2
70995: ARRAY
70996: PPUSH
70997: LD_INT 25
70999: PUSH
71000: LD_INT 16
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PPUSH
71007: CALL_OW 72
71011: ST_TO_ADDR
// if tmp < 6 then
71012: LD_VAR 0 4
71016: PUSH
71017: LD_INT 6
71019: LESS
71020: IFFALSE 71232
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71022: LD_ADDR_VAR 0 6
71026: PUSH
71027: LD_EXP 43
71031: PUSH
71032: LD_VAR 0 2
71036: ARRAY
71037: PPUSH
71038: LD_INT 2
71040: PUSH
71041: LD_INT 30
71043: PUSH
71044: LD_INT 0
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 30
71053: PUSH
71054: LD_INT 1
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: LIST
71065: PPUSH
71066: CALL_OW 72
71070: ST_TO_ADDR
// if depot then
71071: LD_VAR 0 6
71075: IFFALSE 71232
// begin selected := 0 ;
71077: LD_ADDR_VAR 0 7
71081: PUSH
71082: LD_INT 0
71084: ST_TO_ADDR
// for j in depot do
71085: LD_ADDR_VAR 0 3
71089: PUSH
71090: LD_VAR 0 6
71094: PUSH
71095: FOR_IN
71096: IFFALSE 71127
// begin if UnitsInside ( j ) < 6 then
71098: LD_VAR 0 3
71102: PPUSH
71103: CALL_OW 313
71107: PUSH
71108: LD_INT 6
71110: LESS
71111: IFFALSE 71125
// begin selected := j ;
71113: LD_ADDR_VAR 0 7
71117: PUSH
71118: LD_VAR 0 3
71122: ST_TO_ADDR
// break ;
71123: GO 71127
// end ; end ;
71125: GO 71095
71127: POP
71128: POP
// if selected then
71129: LD_VAR 0 7
71133: IFFALSE 71232
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71135: LD_ADDR_VAR 0 3
71139: PUSH
71140: LD_EXP 72
71144: PUSH
71145: LD_VAR 0 2
71149: ARRAY
71150: PPUSH
71151: LD_INT 25
71153: PUSH
71154: LD_INT 12
71156: PUSH
71157: EMPTY
71158: LIST
71159: LIST
71160: PPUSH
71161: CALL_OW 72
71165: PUSH
71166: FOR_IN
71167: IFFALSE 71230
// if not HasTask ( j ) then
71169: LD_VAR 0 3
71173: PPUSH
71174: CALL_OW 314
71178: NOT
71179: IFFALSE 71228
// begin if not IsInUnit ( j ) then
71181: LD_VAR 0 3
71185: PPUSH
71186: CALL_OW 310
71190: NOT
71191: IFFALSE 71207
// ComEnterUnit ( j , selected ) ;
71193: LD_VAR 0 3
71197: PPUSH
71198: LD_VAR 0 7
71202: PPUSH
71203: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71207: LD_VAR 0 3
71211: PPUSH
71212: LD_INT 16
71214: PPUSH
71215: CALL_OW 183
// AddComExitBuilding ( j ) ;
71219: LD_VAR 0 3
71223: PPUSH
71224: CALL_OW 182
// end ;
71228: GO 71166
71230: POP
71231: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71232: LD_VAR 0 5
71236: PPUSH
71237: LD_INT 11
71239: PPUSH
71240: CALL_OW 325
71244: IFFALSE 71503
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71246: LD_ADDR_VAR 0 4
71250: PUSH
71251: LD_EXP 72
71255: PUSH
71256: LD_VAR 0 2
71260: ARRAY
71261: PPUSH
71262: LD_INT 25
71264: PUSH
71265: LD_INT 16
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PPUSH
71272: CALL_OW 72
71276: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71277: LD_VAR 0 4
71281: PUSH
71282: LD_INT 6
71284: GREATEREQUAL
71285: PUSH
71286: LD_VAR 0 5
71290: PPUSH
71291: LD_INT 2
71293: PPUSH
71294: CALL_OW 325
71298: NOT
71299: OR
71300: IFFALSE 71503
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71302: LD_ADDR_VAR 0 8
71306: PUSH
71307: LD_EXP 43
71311: PUSH
71312: LD_VAR 0 2
71316: ARRAY
71317: PPUSH
71318: LD_INT 2
71320: PUSH
71321: LD_INT 30
71323: PUSH
71324: LD_INT 4
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 30
71333: PUSH
71334: LD_INT 5
71336: PUSH
71337: EMPTY
71338: LIST
71339: LIST
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: LIST
71345: PPUSH
71346: CALL_OW 72
71350: ST_TO_ADDR
// if barracks then
71351: LD_VAR 0 8
71355: IFFALSE 71503
// begin selected := 0 ;
71357: LD_ADDR_VAR 0 7
71361: PUSH
71362: LD_INT 0
71364: ST_TO_ADDR
// for j in barracks do
71365: LD_ADDR_VAR 0 3
71369: PUSH
71370: LD_VAR 0 8
71374: PUSH
71375: FOR_IN
71376: IFFALSE 71407
// begin if UnitsInside ( j ) < 6 then
71378: LD_VAR 0 3
71382: PPUSH
71383: CALL_OW 313
71387: PUSH
71388: LD_INT 6
71390: LESS
71391: IFFALSE 71405
// begin selected := j ;
71393: LD_ADDR_VAR 0 7
71397: PUSH
71398: LD_VAR 0 3
71402: ST_TO_ADDR
// break ;
71403: GO 71407
// end ; end ;
71405: GO 71375
71407: POP
71408: POP
// if selected then
71409: LD_VAR 0 7
71413: IFFALSE 71503
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71415: LD_ADDR_VAR 0 3
71419: PUSH
71420: LD_EXP 72
71424: PUSH
71425: LD_VAR 0 2
71429: ARRAY
71430: PPUSH
71431: LD_INT 25
71433: PUSH
71434: LD_INT 12
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PPUSH
71441: CALL_OW 72
71445: PUSH
71446: FOR_IN
71447: IFFALSE 71501
// if not IsInUnit ( j ) and not HasTask ( j ) then
71449: LD_VAR 0 3
71453: PPUSH
71454: CALL_OW 310
71458: NOT
71459: PUSH
71460: LD_VAR 0 3
71464: PPUSH
71465: CALL_OW 314
71469: NOT
71470: AND
71471: IFFALSE 71499
// begin ComEnterUnit ( j , selected ) ;
71473: LD_VAR 0 3
71477: PPUSH
71478: LD_VAR 0 7
71482: PPUSH
71483: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71487: LD_VAR 0 3
71491: PPUSH
71492: LD_INT 15
71494: PPUSH
71495: CALL_OW 183
// end ;
71499: GO 71446
71501: POP
71502: POP
// end ; end ; end ; end ; end ;
71503: GO 70896
71505: POP
71506: POP
// end ;
71507: LD_VAR 0 1
71511: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71512: LD_INT 0
71514: PPUSH
71515: PPUSH
71516: PPUSH
71517: PPUSH
// if not mc_bases then
71518: LD_EXP 43
71522: NOT
71523: IFFALSE 71527
// exit ;
71525: GO 71705
// for i = 1 to mc_bases do
71527: LD_ADDR_VAR 0 2
71531: PUSH
71532: DOUBLE
71533: LD_INT 1
71535: DEC
71536: ST_TO_ADDR
71537: LD_EXP 43
71541: PUSH
71542: FOR_TO
71543: IFFALSE 71703
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71545: LD_ADDR_VAR 0 4
71549: PUSH
71550: LD_EXP 43
71554: PUSH
71555: LD_VAR 0 2
71559: ARRAY
71560: PPUSH
71561: LD_INT 25
71563: PUSH
71564: LD_INT 9
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PPUSH
71571: CALL_OW 72
71575: ST_TO_ADDR
// if not tmp then
71576: LD_VAR 0 4
71580: NOT
71581: IFFALSE 71585
// continue ;
71583: GO 71542
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71585: LD_EXP 69
71589: PUSH
71590: LD_VAR 0 2
71594: ARRAY
71595: PPUSH
71596: LD_INT 29
71598: PPUSH
71599: CALL_OW 325
71603: NOT
71604: PUSH
71605: LD_EXP 69
71609: PUSH
71610: LD_VAR 0 2
71614: ARRAY
71615: PPUSH
71616: LD_INT 28
71618: PPUSH
71619: CALL_OW 325
71623: NOT
71624: AND
71625: IFFALSE 71629
// continue ;
71627: GO 71542
// for j in tmp do
71629: LD_ADDR_VAR 0 3
71633: PUSH
71634: LD_VAR 0 4
71638: PUSH
71639: FOR_IN
71640: IFFALSE 71699
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71642: LD_VAR 0 3
71646: PUSH
71647: LD_EXP 46
71651: PUSH
71652: LD_VAR 0 2
71656: ARRAY
71657: PUSH
71658: LD_INT 1
71660: ARRAY
71661: IN
71662: NOT
71663: PUSH
71664: LD_VAR 0 3
71668: PUSH
71669: LD_EXP 46
71673: PUSH
71674: LD_VAR 0 2
71678: ARRAY
71679: PUSH
71680: LD_INT 2
71682: ARRAY
71683: IN
71684: NOT
71685: AND
71686: IFFALSE 71697
// ComSpaceTimeShoot ( j ) ;
71688: LD_VAR 0 3
71692: PPUSH
71693: CALL 10798 0 1
71697: GO 71639
71699: POP
71700: POP
// end ;
71701: GO 71542
71703: POP
71704: POP
// end ;
71705: LD_VAR 0 1
71709: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71710: LD_INT 0
71712: PPUSH
71713: PPUSH
71714: PPUSH
71715: PPUSH
71716: PPUSH
71717: PPUSH
71718: PPUSH
71719: PPUSH
71720: PPUSH
// if not mc_bases then
71721: LD_EXP 43
71725: NOT
71726: IFFALSE 71730
// exit ;
71728: GO 72352
// for i = 1 to mc_bases do
71730: LD_ADDR_VAR 0 2
71734: PUSH
71735: DOUBLE
71736: LD_INT 1
71738: DEC
71739: ST_TO_ADDR
71740: LD_EXP 43
71744: PUSH
71745: FOR_TO
71746: IFFALSE 72350
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71748: LD_EXP 78
71752: PUSH
71753: LD_VAR 0 2
71757: ARRAY
71758: NOT
71759: PUSH
71760: LD_INT 38
71762: PPUSH
71763: LD_EXP 69
71767: PUSH
71768: LD_VAR 0 2
71772: ARRAY
71773: PPUSH
71774: CALL_OW 321
71778: PUSH
71779: LD_INT 2
71781: NONEQUAL
71782: OR
71783: IFFALSE 71787
// continue ;
71785: GO 71745
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71787: LD_ADDR_VAR 0 8
71791: PUSH
71792: LD_EXP 43
71796: PUSH
71797: LD_VAR 0 2
71801: ARRAY
71802: PPUSH
71803: LD_INT 30
71805: PUSH
71806: LD_INT 34
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PPUSH
71813: CALL_OW 72
71817: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71818: LD_ADDR_VAR 0 9
71822: PUSH
71823: LD_EXP 43
71827: PUSH
71828: LD_VAR 0 2
71832: ARRAY
71833: PPUSH
71834: LD_INT 25
71836: PUSH
71837: LD_INT 4
71839: PUSH
71840: EMPTY
71841: LIST
71842: LIST
71843: PPUSH
71844: CALL_OW 72
71848: PPUSH
71849: LD_INT 0
71851: PPUSH
71852: CALL 44900 0 2
71856: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71857: LD_VAR 0 9
71861: NOT
71862: PUSH
71863: LD_VAR 0 8
71867: NOT
71868: OR
71869: PUSH
71870: LD_EXP 43
71874: PUSH
71875: LD_VAR 0 2
71879: ARRAY
71880: PPUSH
71881: LD_INT 124
71883: PPUSH
71884: CALL 44900 0 2
71888: OR
71889: IFFALSE 71893
// continue ;
71891: GO 71745
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71893: LD_EXP 79
71897: PUSH
71898: LD_VAR 0 2
71902: ARRAY
71903: PUSH
71904: LD_EXP 78
71908: PUSH
71909: LD_VAR 0 2
71913: ARRAY
71914: LESS
71915: PUSH
71916: LD_EXP 79
71920: PUSH
71921: LD_VAR 0 2
71925: ARRAY
71926: PUSH
71927: LD_VAR 0 8
71931: LESS
71932: AND
71933: IFFALSE 72348
// begin tmp := sci [ 1 ] ;
71935: LD_ADDR_VAR 0 7
71939: PUSH
71940: LD_VAR 0 9
71944: PUSH
71945: LD_INT 1
71947: ARRAY
71948: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71949: LD_VAR 0 7
71953: PPUSH
71954: LD_INT 124
71956: PPUSH
71957: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71961: LD_ADDR_VAR 0 3
71965: PUSH
71966: DOUBLE
71967: LD_EXP 78
71971: PUSH
71972: LD_VAR 0 2
71976: ARRAY
71977: INC
71978: ST_TO_ADDR
71979: LD_EXP 78
71983: PUSH
71984: LD_VAR 0 2
71988: ARRAY
71989: PUSH
71990: FOR_DOWNTO
71991: IFFALSE 72334
// begin if IsInUnit ( tmp ) then
71993: LD_VAR 0 7
71997: PPUSH
71998: CALL_OW 310
72002: IFFALSE 72013
// ComExitBuilding ( tmp ) ;
72004: LD_VAR 0 7
72008: PPUSH
72009: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72013: LD_INT 35
72015: PPUSH
72016: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72020: LD_VAR 0 7
72024: PPUSH
72025: CALL_OW 310
72029: NOT
72030: PUSH
72031: LD_VAR 0 7
72035: PPUSH
72036: CALL_OW 314
72040: NOT
72041: AND
72042: IFFALSE 72013
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72044: LD_ADDR_VAR 0 6
72048: PUSH
72049: LD_VAR 0 7
72053: PPUSH
72054: CALL_OW 250
72058: PUSH
72059: LD_VAR 0 7
72063: PPUSH
72064: CALL_OW 251
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72073: LD_INT 35
72075: PPUSH
72076: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72080: LD_ADDR_VAR 0 4
72084: PUSH
72085: LD_EXP 78
72089: PUSH
72090: LD_VAR 0 2
72094: ARRAY
72095: PUSH
72096: LD_VAR 0 3
72100: ARRAY
72101: PUSH
72102: LD_INT 1
72104: ARRAY
72105: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72106: LD_ADDR_VAR 0 5
72110: PUSH
72111: LD_EXP 78
72115: PUSH
72116: LD_VAR 0 2
72120: ARRAY
72121: PUSH
72122: LD_VAR 0 3
72126: ARRAY
72127: PUSH
72128: LD_INT 2
72130: ARRAY
72131: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72132: LD_VAR 0 7
72136: PPUSH
72137: LD_INT 10
72139: PPUSH
72140: CALL 17585 0 2
72144: PUSH
72145: LD_INT 4
72147: ARRAY
72148: IFFALSE 72186
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72150: LD_VAR 0 7
72154: PPUSH
72155: LD_VAR 0 6
72159: PUSH
72160: LD_INT 1
72162: ARRAY
72163: PPUSH
72164: LD_VAR 0 6
72168: PUSH
72169: LD_INT 2
72171: ARRAY
72172: PPUSH
72173: CALL_OW 111
// wait ( 0 0$10 ) ;
72177: LD_INT 350
72179: PPUSH
72180: CALL_OW 67
// end else
72184: GO 72212
// begin ComMoveXY ( tmp , x , y ) ;
72186: LD_VAR 0 7
72190: PPUSH
72191: LD_VAR 0 4
72195: PPUSH
72196: LD_VAR 0 5
72200: PPUSH
72201: CALL_OW 111
// wait ( 0 0$3 ) ;
72205: LD_INT 105
72207: PPUSH
72208: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72212: LD_VAR 0 7
72216: PPUSH
72217: LD_VAR 0 4
72221: PPUSH
72222: LD_VAR 0 5
72226: PPUSH
72227: CALL_OW 307
72231: IFFALSE 72073
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72233: LD_VAR 0 7
72237: PPUSH
72238: LD_VAR 0 4
72242: PPUSH
72243: LD_VAR 0 5
72247: PPUSH
72248: LD_VAR 0 8
72252: PUSH
72253: LD_VAR 0 3
72257: ARRAY
72258: PPUSH
72259: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72263: LD_INT 35
72265: PPUSH
72266: CALL_OW 67
// until not HasTask ( tmp ) ;
72270: LD_VAR 0 7
72274: PPUSH
72275: CALL_OW 314
72279: NOT
72280: IFFALSE 72263
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72282: LD_ADDR_EXP 79
72286: PUSH
72287: LD_EXP 79
72291: PPUSH
72292: LD_VAR 0 2
72296: PUSH
72297: LD_EXP 79
72301: PUSH
72302: LD_VAR 0 2
72306: ARRAY
72307: PUSH
72308: LD_INT 1
72310: PLUS
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PPUSH
72316: LD_VAR 0 8
72320: PUSH
72321: LD_VAR 0 3
72325: ARRAY
72326: PPUSH
72327: CALL 14988 0 3
72331: ST_TO_ADDR
// end ;
72332: GO 71990
72334: POP
72335: POP
// MC_Reset ( i , 124 ) ;
72336: LD_VAR 0 2
72340: PPUSH
72341: LD_INT 124
72343: PPUSH
72344: CALL 55441 0 2
// end ; end ;
72348: GO 71745
72350: POP
72351: POP
// end ;
72352: LD_VAR 0 1
72356: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72357: LD_INT 0
72359: PPUSH
72360: PPUSH
72361: PPUSH
// if not mc_bases then
72362: LD_EXP 43
72366: NOT
72367: IFFALSE 72371
// exit ;
72369: GO 72977
// for i = 1 to mc_bases do
72371: LD_ADDR_VAR 0 2
72375: PUSH
72376: DOUBLE
72377: LD_INT 1
72379: DEC
72380: ST_TO_ADDR
72381: LD_EXP 43
72385: PUSH
72386: FOR_TO
72387: IFFALSE 72975
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72389: LD_ADDR_VAR 0 3
72393: PUSH
72394: LD_EXP 43
72398: PUSH
72399: LD_VAR 0 2
72403: ARRAY
72404: PPUSH
72405: LD_INT 25
72407: PUSH
72408: LD_INT 4
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PPUSH
72415: CALL_OW 72
72419: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72420: LD_VAR 0 3
72424: NOT
72425: PUSH
72426: LD_EXP 80
72430: PUSH
72431: LD_VAR 0 2
72435: ARRAY
72436: NOT
72437: OR
72438: PUSH
72439: LD_EXP 43
72443: PUSH
72444: LD_VAR 0 2
72448: ARRAY
72449: PPUSH
72450: LD_INT 2
72452: PUSH
72453: LD_INT 30
72455: PUSH
72456: LD_INT 0
72458: PUSH
72459: EMPTY
72460: LIST
72461: LIST
72462: PUSH
72463: LD_INT 30
72465: PUSH
72466: LD_INT 1
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: LIST
72477: PPUSH
72478: CALL_OW 72
72482: NOT
72483: OR
72484: IFFALSE 72534
// begin if mc_deposits_finder [ i ] then
72486: LD_EXP 81
72490: PUSH
72491: LD_VAR 0 2
72495: ARRAY
72496: IFFALSE 72532
// begin MC_Reset ( i , 125 ) ;
72498: LD_VAR 0 2
72502: PPUSH
72503: LD_INT 125
72505: PPUSH
72506: CALL 55441 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72510: LD_ADDR_EXP 81
72514: PUSH
72515: LD_EXP 81
72519: PPUSH
72520: LD_VAR 0 2
72524: PPUSH
72525: EMPTY
72526: PPUSH
72527: CALL_OW 1
72531: ST_TO_ADDR
// end ; continue ;
72532: GO 72386
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72534: LD_EXP 80
72538: PUSH
72539: LD_VAR 0 2
72543: ARRAY
72544: PUSH
72545: LD_INT 1
72547: ARRAY
72548: PUSH
72549: LD_INT 3
72551: ARRAY
72552: PUSH
72553: LD_INT 1
72555: EQUAL
72556: PUSH
72557: LD_INT 20
72559: PPUSH
72560: LD_EXP 69
72564: PUSH
72565: LD_VAR 0 2
72569: ARRAY
72570: PPUSH
72571: CALL_OW 321
72575: PUSH
72576: LD_INT 2
72578: NONEQUAL
72579: AND
72580: IFFALSE 72630
// begin if mc_deposits_finder [ i ] then
72582: LD_EXP 81
72586: PUSH
72587: LD_VAR 0 2
72591: ARRAY
72592: IFFALSE 72628
// begin MC_Reset ( i , 125 ) ;
72594: LD_VAR 0 2
72598: PPUSH
72599: LD_INT 125
72601: PPUSH
72602: CALL 55441 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72606: LD_ADDR_EXP 81
72610: PUSH
72611: LD_EXP 81
72615: PPUSH
72616: LD_VAR 0 2
72620: PPUSH
72621: EMPTY
72622: PPUSH
72623: CALL_OW 1
72627: ST_TO_ADDR
// end ; continue ;
72628: GO 72386
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72630: LD_EXP 80
72634: PUSH
72635: LD_VAR 0 2
72639: ARRAY
72640: PUSH
72641: LD_INT 1
72643: ARRAY
72644: PUSH
72645: LD_INT 1
72647: ARRAY
72648: PPUSH
72649: LD_EXP 80
72653: PUSH
72654: LD_VAR 0 2
72658: ARRAY
72659: PUSH
72660: LD_INT 1
72662: ARRAY
72663: PUSH
72664: LD_INT 2
72666: ARRAY
72667: PPUSH
72668: LD_EXP 69
72672: PUSH
72673: LD_VAR 0 2
72677: ARRAY
72678: PPUSH
72679: CALL_OW 440
72683: IFFALSE 72726
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72685: LD_ADDR_EXP 80
72689: PUSH
72690: LD_EXP 80
72694: PPUSH
72695: LD_VAR 0 2
72699: PPUSH
72700: LD_EXP 80
72704: PUSH
72705: LD_VAR 0 2
72709: ARRAY
72710: PPUSH
72711: LD_INT 1
72713: PPUSH
72714: CALL_OW 3
72718: PPUSH
72719: CALL_OW 1
72723: ST_TO_ADDR
72724: GO 72973
// begin if not mc_deposits_finder [ i ] then
72726: LD_EXP 81
72730: PUSH
72731: LD_VAR 0 2
72735: ARRAY
72736: NOT
72737: IFFALSE 72789
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72739: LD_ADDR_EXP 81
72743: PUSH
72744: LD_EXP 81
72748: PPUSH
72749: LD_VAR 0 2
72753: PPUSH
72754: LD_VAR 0 3
72758: PUSH
72759: LD_INT 1
72761: ARRAY
72762: PUSH
72763: EMPTY
72764: LIST
72765: PPUSH
72766: CALL_OW 1
72770: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72771: LD_VAR 0 3
72775: PUSH
72776: LD_INT 1
72778: ARRAY
72779: PPUSH
72780: LD_INT 125
72782: PPUSH
72783: CALL_OW 109
// end else
72787: GO 72973
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72789: LD_EXP 81
72793: PUSH
72794: LD_VAR 0 2
72798: ARRAY
72799: PUSH
72800: LD_INT 1
72802: ARRAY
72803: PPUSH
72804: CALL_OW 310
72808: IFFALSE 72831
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72810: LD_EXP 81
72814: PUSH
72815: LD_VAR 0 2
72819: ARRAY
72820: PUSH
72821: LD_INT 1
72823: ARRAY
72824: PPUSH
72825: CALL_OW 122
72829: GO 72973
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72831: LD_EXP 81
72835: PUSH
72836: LD_VAR 0 2
72840: ARRAY
72841: PUSH
72842: LD_INT 1
72844: ARRAY
72845: PPUSH
72846: CALL_OW 314
72850: NOT
72851: PUSH
72852: LD_EXP 81
72856: PUSH
72857: LD_VAR 0 2
72861: ARRAY
72862: PUSH
72863: LD_INT 1
72865: ARRAY
72866: PPUSH
72867: LD_EXP 80
72871: PUSH
72872: LD_VAR 0 2
72876: ARRAY
72877: PUSH
72878: LD_INT 1
72880: ARRAY
72881: PUSH
72882: LD_INT 1
72884: ARRAY
72885: PPUSH
72886: LD_EXP 80
72890: PUSH
72891: LD_VAR 0 2
72895: ARRAY
72896: PUSH
72897: LD_INT 1
72899: ARRAY
72900: PUSH
72901: LD_INT 2
72903: ARRAY
72904: PPUSH
72905: CALL_OW 297
72909: PUSH
72910: LD_INT 6
72912: GREATER
72913: AND
72914: IFFALSE 72973
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72916: LD_EXP 81
72920: PUSH
72921: LD_VAR 0 2
72925: ARRAY
72926: PUSH
72927: LD_INT 1
72929: ARRAY
72930: PPUSH
72931: LD_EXP 80
72935: PUSH
72936: LD_VAR 0 2
72940: ARRAY
72941: PUSH
72942: LD_INT 1
72944: ARRAY
72945: PUSH
72946: LD_INT 1
72948: ARRAY
72949: PPUSH
72950: LD_EXP 80
72954: PUSH
72955: LD_VAR 0 2
72959: ARRAY
72960: PUSH
72961: LD_INT 1
72963: ARRAY
72964: PUSH
72965: LD_INT 2
72967: ARRAY
72968: PPUSH
72969: CALL_OW 111
// end ; end ; end ;
72973: GO 72386
72975: POP
72976: POP
// end ;
72977: LD_VAR 0 1
72981: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72982: LD_INT 0
72984: PPUSH
72985: PPUSH
72986: PPUSH
72987: PPUSH
72988: PPUSH
72989: PPUSH
72990: PPUSH
72991: PPUSH
72992: PPUSH
72993: PPUSH
72994: PPUSH
// if not mc_bases then
72995: LD_EXP 43
72999: NOT
73000: IFFALSE 73004
// exit ;
73002: GO 73944
// for i = 1 to mc_bases do
73004: LD_ADDR_VAR 0 2
73008: PUSH
73009: DOUBLE
73010: LD_INT 1
73012: DEC
73013: ST_TO_ADDR
73014: LD_EXP 43
73018: PUSH
73019: FOR_TO
73020: IFFALSE 73942
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73022: LD_EXP 43
73026: PUSH
73027: LD_VAR 0 2
73031: ARRAY
73032: NOT
73033: PUSH
73034: LD_EXP 66
73038: PUSH
73039: LD_VAR 0 2
73043: ARRAY
73044: OR
73045: IFFALSE 73049
// continue ;
73047: GO 73019
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73049: LD_ADDR_VAR 0 7
73053: PUSH
73054: LD_EXP 43
73058: PUSH
73059: LD_VAR 0 2
73063: ARRAY
73064: PUSH
73065: LD_INT 1
73067: ARRAY
73068: PPUSH
73069: CALL_OW 248
73073: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73074: LD_VAR 0 7
73078: PUSH
73079: LD_INT 3
73081: EQUAL
73082: PUSH
73083: LD_EXP 62
73087: PUSH
73088: LD_VAR 0 2
73092: ARRAY
73093: PUSH
73094: LD_EXP 65
73098: PUSH
73099: LD_VAR 0 2
73103: ARRAY
73104: UNION
73105: PPUSH
73106: LD_INT 33
73108: PUSH
73109: LD_INT 2
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PPUSH
73116: CALL_OW 72
73120: NOT
73121: OR
73122: IFFALSE 73126
// continue ;
73124: GO 73019
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73126: LD_ADDR_VAR 0 9
73130: PUSH
73131: LD_EXP 43
73135: PUSH
73136: LD_VAR 0 2
73140: ARRAY
73141: PPUSH
73142: LD_INT 30
73144: PUSH
73145: LD_INT 36
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PPUSH
73152: CALL_OW 72
73156: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73157: LD_ADDR_VAR 0 10
73161: PUSH
73162: LD_EXP 62
73166: PUSH
73167: LD_VAR 0 2
73171: ARRAY
73172: PPUSH
73173: LD_INT 34
73175: PUSH
73176: LD_INT 31
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: PPUSH
73183: CALL_OW 72
73187: ST_TO_ADDR
// if not cts and not mcts then
73188: LD_VAR 0 9
73192: NOT
73193: PUSH
73194: LD_VAR 0 10
73198: NOT
73199: AND
73200: IFFALSE 73204
// continue ;
73202: GO 73019
// x := cts ;
73204: LD_ADDR_VAR 0 11
73208: PUSH
73209: LD_VAR 0 9
73213: ST_TO_ADDR
// if not x then
73214: LD_VAR 0 11
73218: NOT
73219: IFFALSE 73231
// x := mcts ;
73221: LD_ADDR_VAR 0 11
73225: PUSH
73226: LD_VAR 0 10
73230: ST_TO_ADDR
// if not x then
73231: LD_VAR 0 11
73235: NOT
73236: IFFALSE 73240
// continue ;
73238: GO 73019
// if mc_remote_driver [ i ] then
73240: LD_EXP 83
73244: PUSH
73245: LD_VAR 0 2
73249: ARRAY
73250: IFFALSE 73637
// for j in mc_remote_driver [ i ] do
73252: LD_ADDR_VAR 0 3
73256: PUSH
73257: LD_EXP 83
73261: PUSH
73262: LD_VAR 0 2
73266: ARRAY
73267: PUSH
73268: FOR_IN
73269: IFFALSE 73635
// begin if GetClass ( j ) <> 3 then
73271: LD_VAR 0 3
73275: PPUSH
73276: CALL_OW 257
73280: PUSH
73281: LD_INT 3
73283: NONEQUAL
73284: IFFALSE 73337
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73286: LD_ADDR_EXP 83
73290: PUSH
73291: LD_EXP 83
73295: PPUSH
73296: LD_VAR 0 2
73300: PPUSH
73301: LD_EXP 83
73305: PUSH
73306: LD_VAR 0 2
73310: ARRAY
73311: PUSH
73312: LD_VAR 0 3
73316: DIFF
73317: PPUSH
73318: CALL_OW 1
73322: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73323: LD_VAR 0 3
73327: PPUSH
73328: LD_INT 0
73330: PPUSH
73331: CALL_OW 109
// continue ;
73335: GO 73268
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73337: LD_EXP 62
73341: PUSH
73342: LD_VAR 0 2
73346: ARRAY
73347: PPUSH
73348: LD_INT 34
73350: PUSH
73351: LD_INT 31
73353: PUSH
73354: EMPTY
73355: LIST
73356: LIST
73357: PUSH
73358: LD_INT 58
73360: PUSH
73361: EMPTY
73362: LIST
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: PPUSH
73368: CALL_OW 72
73372: PUSH
73373: LD_VAR 0 3
73377: PPUSH
73378: CALL 44935 0 1
73382: NOT
73383: AND
73384: IFFALSE 73455
// begin if IsInUnit ( j ) then
73386: LD_VAR 0 3
73390: PPUSH
73391: CALL_OW 310
73395: IFFALSE 73406
// ComExitBuilding ( j ) ;
73397: LD_VAR 0 3
73401: PPUSH
73402: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73406: LD_VAR 0 3
73410: PPUSH
73411: LD_EXP 62
73415: PUSH
73416: LD_VAR 0 2
73420: ARRAY
73421: PPUSH
73422: LD_INT 34
73424: PUSH
73425: LD_INT 31
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PUSH
73432: LD_INT 58
73434: PUSH
73435: EMPTY
73436: LIST
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: PPUSH
73442: CALL_OW 72
73446: PUSH
73447: LD_INT 1
73449: ARRAY
73450: PPUSH
73451: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73455: LD_VAR 0 3
73459: PPUSH
73460: CALL_OW 310
73464: NOT
73465: PUSH
73466: LD_VAR 0 3
73470: PPUSH
73471: CALL_OW 310
73475: PPUSH
73476: CALL_OW 266
73480: PUSH
73481: LD_INT 36
73483: NONEQUAL
73484: PUSH
73485: LD_VAR 0 3
73489: PPUSH
73490: CALL 44935 0 1
73494: NOT
73495: AND
73496: OR
73497: IFFALSE 73633
// begin if IsInUnit ( j ) then
73499: LD_VAR 0 3
73503: PPUSH
73504: CALL_OW 310
73508: IFFALSE 73519
// ComExitBuilding ( j ) ;
73510: LD_VAR 0 3
73514: PPUSH
73515: CALL_OW 122
// ct := 0 ;
73519: LD_ADDR_VAR 0 8
73523: PUSH
73524: LD_INT 0
73526: ST_TO_ADDR
// for k in x do
73527: LD_ADDR_VAR 0 4
73531: PUSH
73532: LD_VAR 0 11
73536: PUSH
73537: FOR_IN
73538: IFFALSE 73611
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73540: LD_VAR 0 4
73544: PPUSH
73545: CALL_OW 264
73549: PUSH
73550: LD_INT 31
73552: EQUAL
73553: PUSH
73554: LD_VAR 0 4
73558: PPUSH
73559: CALL_OW 311
73563: NOT
73564: AND
73565: PUSH
73566: LD_VAR 0 4
73570: PPUSH
73571: CALL_OW 266
73575: PUSH
73576: LD_INT 36
73578: EQUAL
73579: PUSH
73580: LD_VAR 0 4
73584: PPUSH
73585: CALL_OW 313
73589: PUSH
73590: LD_INT 3
73592: LESS
73593: AND
73594: OR
73595: IFFALSE 73609
// begin ct := k ;
73597: LD_ADDR_VAR 0 8
73601: PUSH
73602: LD_VAR 0 4
73606: ST_TO_ADDR
// break ;
73607: GO 73611
// end ;
73609: GO 73537
73611: POP
73612: POP
// if ct then
73613: LD_VAR 0 8
73617: IFFALSE 73633
// ComEnterUnit ( j , ct ) ;
73619: LD_VAR 0 3
73623: PPUSH
73624: LD_VAR 0 8
73628: PPUSH
73629: CALL_OW 120
// end ; end ;
73633: GO 73268
73635: POP
73636: POP
// places := 0 ;
73637: LD_ADDR_VAR 0 5
73641: PUSH
73642: LD_INT 0
73644: ST_TO_ADDR
// for j = 1 to x do
73645: LD_ADDR_VAR 0 3
73649: PUSH
73650: DOUBLE
73651: LD_INT 1
73653: DEC
73654: ST_TO_ADDR
73655: LD_VAR 0 11
73659: PUSH
73660: FOR_TO
73661: IFFALSE 73737
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73663: LD_VAR 0 11
73667: PUSH
73668: LD_VAR 0 3
73672: ARRAY
73673: PPUSH
73674: CALL_OW 264
73678: PUSH
73679: LD_INT 31
73681: EQUAL
73682: IFFALSE 73700
// places := places + 1 else
73684: LD_ADDR_VAR 0 5
73688: PUSH
73689: LD_VAR 0 5
73693: PUSH
73694: LD_INT 1
73696: PLUS
73697: ST_TO_ADDR
73698: GO 73735
// if GetBType ( x [ j ] ) = b_control_tower then
73700: LD_VAR 0 11
73704: PUSH
73705: LD_VAR 0 3
73709: ARRAY
73710: PPUSH
73711: CALL_OW 266
73715: PUSH
73716: LD_INT 36
73718: EQUAL
73719: IFFALSE 73735
// places := places + 3 ;
73721: LD_ADDR_VAR 0 5
73725: PUSH
73726: LD_VAR 0 5
73730: PUSH
73731: LD_INT 3
73733: PLUS
73734: ST_TO_ADDR
73735: GO 73660
73737: POP
73738: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73739: LD_VAR 0 5
73743: PUSH
73744: LD_INT 0
73746: EQUAL
73747: PUSH
73748: LD_VAR 0 5
73752: PUSH
73753: LD_EXP 83
73757: PUSH
73758: LD_VAR 0 2
73762: ARRAY
73763: LESSEQUAL
73764: OR
73765: IFFALSE 73769
// continue ;
73767: GO 73019
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73769: LD_ADDR_VAR 0 6
73773: PUSH
73774: LD_EXP 43
73778: PUSH
73779: LD_VAR 0 2
73783: ARRAY
73784: PPUSH
73785: LD_INT 25
73787: PUSH
73788: LD_INT 3
73790: PUSH
73791: EMPTY
73792: LIST
73793: LIST
73794: PPUSH
73795: CALL_OW 72
73799: PUSH
73800: LD_EXP 83
73804: PUSH
73805: LD_VAR 0 2
73809: ARRAY
73810: DIFF
73811: PPUSH
73812: LD_INT 3
73814: PPUSH
73815: CALL 45835 0 2
73819: ST_TO_ADDR
// for j in tmp do
73820: LD_ADDR_VAR 0 3
73824: PUSH
73825: LD_VAR 0 6
73829: PUSH
73830: FOR_IN
73831: IFFALSE 73866
// if GetTag ( j ) > 0 then
73833: LD_VAR 0 3
73837: PPUSH
73838: CALL_OW 110
73842: PUSH
73843: LD_INT 0
73845: GREATER
73846: IFFALSE 73864
// tmp := tmp diff j ;
73848: LD_ADDR_VAR 0 6
73852: PUSH
73853: LD_VAR 0 6
73857: PUSH
73858: LD_VAR 0 3
73862: DIFF
73863: ST_TO_ADDR
73864: GO 73830
73866: POP
73867: POP
// if not tmp then
73868: LD_VAR 0 6
73872: NOT
73873: IFFALSE 73877
// continue ;
73875: GO 73019
// if places then
73877: LD_VAR 0 5
73881: IFFALSE 73940
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73883: LD_ADDR_EXP 83
73887: PUSH
73888: LD_EXP 83
73892: PPUSH
73893: LD_VAR 0 2
73897: PPUSH
73898: LD_EXP 83
73902: PUSH
73903: LD_VAR 0 2
73907: ARRAY
73908: PUSH
73909: LD_VAR 0 6
73913: PUSH
73914: LD_INT 1
73916: ARRAY
73917: UNION
73918: PPUSH
73919: CALL_OW 1
73923: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73924: LD_VAR 0 6
73928: PUSH
73929: LD_INT 1
73931: ARRAY
73932: PPUSH
73933: LD_INT 126
73935: PPUSH
73936: CALL_OW 109
// end ; end ;
73940: GO 73019
73942: POP
73943: POP
// end ;
73944: LD_VAR 0 1
73948: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73949: LD_INT 0
73951: PPUSH
73952: PPUSH
73953: PPUSH
73954: PPUSH
73955: PPUSH
73956: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73957: LD_VAR 0 1
73961: NOT
73962: PUSH
73963: LD_VAR 0 2
73967: NOT
73968: OR
73969: PUSH
73970: LD_VAR 0 3
73974: NOT
73975: OR
73976: PUSH
73977: LD_VAR 0 4
73981: PUSH
73982: LD_INT 1
73984: PUSH
73985: LD_INT 2
73987: PUSH
73988: LD_INT 3
73990: PUSH
73991: LD_INT 4
73993: PUSH
73994: LD_INT 5
73996: PUSH
73997: LD_INT 8
73999: PUSH
74000: LD_INT 9
74002: PUSH
74003: LD_INT 15
74005: PUSH
74006: LD_INT 16
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: LIST
74013: LIST
74014: LIST
74015: LIST
74016: LIST
74017: LIST
74018: LIST
74019: IN
74020: NOT
74021: OR
74022: IFFALSE 74026
// exit ;
74024: GO 74926
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74026: LD_ADDR_VAR 0 2
74030: PUSH
74031: LD_VAR 0 2
74035: PPUSH
74036: LD_INT 21
74038: PUSH
74039: LD_INT 3
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 24
74048: PUSH
74049: LD_INT 250
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PPUSH
74060: CALL_OW 72
74064: ST_TO_ADDR
// case class of 1 , 15 :
74065: LD_VAR 0 4
74069: PUSH
74070: LD_INT 1
74072: DOUBLE
74073: EQUAL
74074: IFTRUE 74084
74076: LD_INT 15
74078: DOUBLE
74079: EQUAL
74080: IFTRUE 74084
74082: GO 74169
74084: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74085: LD_ADDR_VAR 0 8
74089: PUSH
74090: LD_VAR 0 2
74094: PPUSH
74095: LD_INT 2
74097: PUSH
74098: LD_INT 30
74100: PUSH
74101: LD_INT 32
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 30
74110: PUSH
74111: LD_INT 31
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: LIST
74122: PPUSH
74123: CALL_OW 72
74127: PUSH
74128: LD_VAR 0 2
74132: PPUSH
74133: LD_INT 2
74135: PUSH
74136: LD_INT 30
74138: PUSH
74139: LD_INT 4
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 30
74148: PUSH
74149: LD_INT 5
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: LIST
74160: PPUSH
74161: CALL_OW 72
74165: ADD
74166: ST_TO_ADDR
74167: GO 74415
74169: LD_INT 2
74171: DOUBLE
74172: EQUAL
74173: IFTRUE 74183
74175: LD_INT 16
74177: DOUBLE
74178: EQUAL
74179: IFTRUE 74183
74181: GO 74229
74183: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74184: LD_ADDR_VAR 0 8
74188: PUSH
74189: LD_VAR 0 2
74193: PPUSH
74194: LD_INT 2
74196: PUSH
74197: LD_INT 30
74199: PUSH
74200: LD_INT 0
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 30
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: EMPTY
74218: LIST
74219: LIST
74220: LIST
74221: PPUSH
74222: CALL_OW 72
74226: ST_TO_ADDR
74227: GO 74415
74229: LD_INT 3
74231: DOUBLE
74232: EQUAL
74233: IFTRUE 74237
74235: GO 74283
74237: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74238: LD_ADDR_VAR 0 8
74242: PUSH
74243: LD_VAR 0 2
74247: PPUSH
74248: LD_INT 2
74250: PUSH
74251: LD_INT 30
74253: PUSH
74254: LD_INT 2
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: LD_INT 30
74263: PUSH
74264: LD_INT 3
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: LIST
74275: PPUSH
74276: CALL_OW 72
74280: ST_TO_ADDR
74281: GO 74415
74283: LD_INT 4
74285: DOUBLE
74286: EQUAL
74287: IFTRUE 74291
74289: GO 74348
74291: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74292: LD_ADDR_VAR 0 8
74296: PUSH
74297: LD_VAR 0 2
74301: PPUSH
74302: LD_INT 2
74304: PUSH
74305: LD_INT 30
74307: PUSH
74308: LD_INT 6
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: LD_INT 30
74317: PUSH
74318: LD_INT 7
74320: PUSH
74321: EMPTY
74322: LIST
74323: LIST
74324: PUSH
74325: LD_INT 30
74327: PUSH
74328: LD_INT 8
74330: PUSH
74331: EMPTY
74332: LIST
74333: LIST
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: LIST
74339: LIST
74340: PPUSH
74341: CALL_OW 72
74345: ST_TO_ADDR
74346: GO 74415
74348: LD_INT 5
74350: DOUBLE
74351: EQUAL
74352: IFTRUE 74368
74354: LD_INT 8
74356: DOUBLE
74357: EQUAL
74358: IFTRUE 74368
74360: LD_INT 9
74362: DOUBLE
74363: EQUAL
74364: IFTRUE 74368
74366: GO 74414
74368: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74369: LD_ADDR_VAR 0 8
74373: PUSH
74374: LD_VAR 0 2
74378: PPUSH
74379: LD_INT 2
74381: PUSH
74382: LD_INT 30
74384: PUSH
74385: LD_INT 4
74387: PUSH
74388: EMPTY
74389: LIST
74390: LIST
74391: PUSH
74392: LD_INT 30
74394: PUSH
74395: LD_INT 5
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: LIST
74406: PPUSH
74407: CALL_OW 72
74411: ST_TO_ADDR
74412: GO 74415
74414: POP
// if not tmp then
74415: LD_VAR 0 8
74419: NOT
74420: IFFALSE 74424
// exit ;
74422: GO 74926
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74424: LD_VAR 0 4
74428: PUSH
74429: LD_INT 1
74431: PUSH
74432: LD_INT 15
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: IN
74439: PUSH
74440: LD_EXP 52
74444: PUSH
74445: LD_VAR 0 1
74449: ARRAY
74450: AND
74451: IFFALSE 74607
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74453: LD_ADDR_VAR 0 9
74457: PUSH
74458: LD_EXP 52
74462: PUSH
74463: LD_VAR 0 1
74467: ARRAY
74468: PUSH
74469: LD_INT 1
74471: ARRAY
74472: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74473: LD_VAR 0 9
74477: PUSH
74478: LD_EXP 53
74482: PUSH
74483: LD_VAR 0 1
74487: ARRAY
74488: IN
74489: NOT
74490: IFFALSE 74605
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74492: LD_ADDR_EXP 53
74496: PUSH
74497: LD_EXP 53
74501: PPUSH
74502: LD_VAR 0 1
74506: PUSH
74507: LD_EXP 53
74511: PUSH
74512: LD_VAR 0 1
74516: ARRAY
74517: PUSH
74518: LD_INT 1
74520: PLUS
74521: PUSH
74522: EMPTY
74523: LIST
74524: LIST
74525: PPUSH
74526: LD_VAR 0 9
74530: PPUSH
74531: CALL 14988 0 3
74535: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74536: LD_ADDR_EXP 52
74540: PUSH
74541: LD_EXP 52
74545: PPUSH
74546: LD_VAR 0 1
74550: PPUSH
74551: LD_EXP 52
74555: PUSH
74556: LD_VAR 0 1
74560: ARRAY
74561: PUSH
74562: LD_VAR 0 9
74566: DIFF
74567: PPUSH
74568: CALL_OW 1
74572: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74573: LD_VAR 0 3
74577: PPUSH
74578: LD_EXP 53
74582: PUSH
74583: LD_VAR 0 1
74587: ARRAY
74588: PUSH
74589: LD_EXP 53
74593: PUSH
74594: LD_VAR 0 1
74598: ARRAY
74599: ARRAY
74600: PPUSH
74601: CALL_OW 120
// end ; exit ;
74605: GO 74926
// end ; if tmp > 1 then
74607: LD_VAR 0 8
74611: PUSH
74612: LD_INT 1
74614: GREATER
74615: IFFALSE 74719
// for i = 2 to tmp do
74617: LD_ADDR_VAR 0 6
74621: PUSH
74622: DOUBLE
74623: LD_INT 2
74625: DEC
74626: ST_TO_ADDR
74627: LD_VAR 0 8
74631: PUSH
74632: FOR_TO
74633: IFFALSE 74717
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74635: LD_VAR 0 8
74639: PUSH
74640: LD_VAR 0 6
74644: ARRAY
74645: PPUSH
74646: CALL_OW 461
74650: PUSH
74651: LD_INT 6
74653: EQUAL
74654: IFFALSE 74715
// begin x := tmp [ i ] ;
74656: LD_ADDR_VAR 0 9
74660: PUSH
74661: LD_VAR 0 8
74665: PUSH
74666: LD_VAR 0 6
74670: ARRAY
74671: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74672: LD_ADDR_VAR 0 8
74676: PUSH
74677: LD_VAR 0 8
74681: PPUSH
74682: LD_VAR 0 6
74686: PPUSH
74687: CALL_OW 3
74691: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74692: LD_ADDR_VAR 0 8
74696: PUSH
74697: LD_VAR 0 8
74701: PPUSH
74702: LD_INT 1
74704: PPUSH
74705: LD_VAR 0 9
74709: PPUSH
74710: CALL_OW 2
74714: ST_TO_ADDR
// end ;
74715: GO 74632
74717: POP
74718: POP
// for i in tmp do
74719: LD_ADDR_VAR 0 6
74723: PUSH
74724: LD_VAR 0 8
74728: PUSH
74729: FOR_IN
74730: IFFALSE 74799
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74732: LD_VAR 0 6
74736: PPUSH
74737: CALL_OW 313
74741: PUSH
74742: LD_INT 6
74744: LESS
74745: PUSH
74746: LD_VAR 0 6
74750: PPUSH
74751: CALL_OW 266
74755: PUSH
74756: LD_INT 31
74758: PUSH
74759: LD_INT 32
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: IN
74766: NOT
74767: AND
74768: PUSH
74769: LD_VAR 0 6
74773: PPUSH
74774: CALL_OW 313
74778: PUSH
74779: LD_INT 0
74781: EQUAL
74782: OR
74783: IFFALSE 74797
// begin j := i ;
74785: LD_ADDR_VAR 0 7
74789: PUSH
74790: LD_VAR 0 6
74794: ST_TO_ADDR
// break ;
74795: GO 74799
// end ; end ;
74797: GO 74729
74799: POP
74800: POP
// if j then
74801: LD_VAR 0 7
74805: IFFALSE 74823
// ComEnterUnit ( unit , j ) else
74807: LD_VAR 0 3
74811: PPUSH
74812: LD_VAR 0 7
74816: PPUSH
74817: CALL_OW 120
74821: GO 74926
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74823: LD_ADDR_VAR 0 10
74827: PUSH
74828: LD_VAR 0 2
74832: PPUSH
74833: LD_INT 2
74835: PUSH
74836: LD_INT 30
74838: PUSH
74839: LD_INT 0
74841: PUSH
74842: EMPTY
74843: LIST
74844: LIST
74845: PUSH
74846: LD_INT 30
74848: PUSH
74849: LD_INT 1
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: LIST
74860: PPUSH
74861: CALL_OW 72
74865: ST_TO_ADDR
// if depot then
74866: LD_VAR 0 10
74870: IFFALSE 74926
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74872: LD_ADDR_VAR 0 10
74876: PUSH
74877: LD_VAR 0 10
74881: PPUSH
74882: LD_VAR 0 3
74886: PPUSH
74887: CALL_OW 74
74891: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74892: LD_VAR 0 3
74896: PPUSH
74897: LD_VAR 0 10
74901: PPUSH
74902: CALL_OW 296
74906: PUSH
74907: LD_INT 10
74909: GREATER
74910: IFFALSE 74926
// ComStandNearbyBuilding ( unit , depot ) ;
74912: LD_VAR 0 3
74916: PPUSH
74917: LD_VAR 0 10
74921: PPUSH
74922: CALL 11415 0 2
// end ; end ; end ;
74926: LD_VAR 0 5
74930: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74931: LD_INT 0
74933: PPUSH
74934: PPUSH
74935: PPUSH
74936: PPUSH
// if not mc_bases then
74937: LD_EXP 43
74941: NOT
74942: IFFALSE 74946
// exit ;
74944: GO 75185
// for i = 1 to mc_bases do
74946: LD_ADDR_VAR 0 2
74950: PUSH
74951: DOUBLE
74952: LD_INT 1
74954: DEC
74955: ST_TO_ADDR
74956: LD_EXP 43
74960: PUSH
74961: FOR_TO
74962: IFFALSE 75183
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74964: LD_ADDR_VAR 0 4
74968: PUSH
74969: LD_EXP 43
74973: PUSH
74974: LD_VAR 0 2
74978: ARRAY
74979: PPUSH
74980: LD_INT 21
74982: PUSH
74983: LD_INT 1
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PPUSH
74990: CALL_OW 72
74994: PUSH
74995: LD_EXP 72
74999: PUSH
75000: LD_VAR 0 2
75004: ARRAY
75005: UNION
75006: ST_TO_ADDR
// if not tmp then
75007: LD_VAR 0 4
75011: NOT
75012: IFFALSE 75016
// continue ;
75014: GO 74961
// for j in tmp do
75016: LD_ADDR_VAR 0 3
75020: PUSH
75021: LD_VAR 0 4
75025: PUSH
75026: FOR_IN
75027: IFFALSE 75179
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75029: LD_VAR 0 3
75033: PPUSH
75034: CALL_OW 110
75038: NOT
75039: PUSH
75040: LD_VAR 0 3
75044: PPUSH
75045: CALL_OW 314
75049: NOT
75050: AND
75051: PUSH
75052: LD_VAR 0 3
75056: PPUSH
75057: CALL_OW 311
75061: NOT
75062: AND
75063: PUSH
75064: LD_VAR 0 3
75068: PPUSH
75069: CALL_OW 310
75073: NOT
75074: AND
75075: PUSH
75076: LD_VAR 0 3
75080: PUSH
75081: LD_EXP 46
75085: PUSH
75086: LD_VAR 0 2
75090: ARRAY
75091: PUSH
75092: LD_INT 1
75094: ARRAY
75095: IN
75096: NOT
75097: AND
75098: PUSH
75099: LD_VAR 0 3
75103: PUSH
75104: LD_EXP 46
75108: PUSH
75109: LD_VAR 0 2
75113: ARRAY
75114: PUSH
75115: LD_INT 2
75117: ARRAY
75118: IN
75119: NOT
75120: AND
75121: PUSH
75122: LD_VAR 0 3
75126: PUSH
75127: LD_EXP 55
75131: PUSH
75132: LD_VAR 0 2
75136: ARRAY
75137: IN
75138: NOT
75139: AND
75140: IFFALSE 75177
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75142: LD_VAR 0 2
75146: PPUSH
75147: LD_EXP 43
75151: PUSH
75152: LD_VAR 0 2
75156: ARRAY
75157: PPUSH
75158: LD_VAR 0 3
75162: PPUSH
75163: LD_VAR 0 3
75167: PPUSH
75168: CALL_OW 257
75172: PPUSH
75173: CALL 73949 0 4
// end ;
75177: GO 75026
75179: POP
75180: POP
// end ;
75181: GO 74961
75183: POP
75184: POP
// end ;
75185: LD_VAR 0 1
75189: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
75190: LD_INT 0
75192: PPUSH
75193: PPUSH
75194: PPUSH
75195: PPUSH
75196: PPUSH
75197: PPUSH
// if not mc_bases [ base ] then
75198: LD_EXP 43
75202: PUSH
75203: LD_VAR 0 1
75207: ARRAY
75208: NOT
75209: IFFALSE 75213
// exit ;
75211: GO 75395
// tmp := [ ] ;
75213: LD_ADDR_VAR 0 6
75217: PUSH
75218: EMPTY
75219: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75220: LD_ADDR_VAR 0 7
75224: PUSH
75225: LD_VAR 0 3
75229: PPUSH
75230: LD_INT 0
75232: PPUSH
75233: CALL_OW 517
75237: ST_TO_ADDR
// if not list then
75238: LD_VAR 0 7
75242: NOT
75243: IFFALSE 75247
// exit ;
75245: GO 75395
// for i = 1 to amount do
75247: LD_ADDR_VAR 0 5
75251: PUSH
75252: DOUBLE
75253: LD_INT 1
75255: DEC
75256: ST_TO_ADDR
75257: LD_VAR 0 2
75261: PUSH
75262: FOR_TO
75263: IFFALSE 75343
// begin x := rand ( 1 , list [ 1 ] ) ;
75265: LD_ADDR_VAR 0 8
75269: PUSH
75270: LD_INT 1
75272: PPUSH
75273: LD_VAR 0 7
75277: PUSH
75278: LD_INT 1
75280: ARRAY
75281: PPUSH
75282: CALL_OW 12
75286: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75287: LD_ADDR_VAR 0 6
75291: PUSH
75292: LD_VAR 0 6
75296: PPUSH
75297: LD_VAR 0 5
75301: PPUSH
75302: LD_VAR 0 7
75306: PUSH
75307: LD_INT 1
75309: ARRAY
75310: PUSH
75311: LD_VAR 0 8
75315: ARRAY
75316: PUSH
75317: LD_VAR 0 7
75321: PUSH
75322: LD_INT 2
75324: ARRAY
75325: PUSH
75326: LD_VAR 0 8
75330: ARRAY
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PPUSH
75336: CALL_OW 1
75340: ST_TO_ADDR
// end ;
75341: GO 75262
75343: POP
75344: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75345: LD_ADDR_EXP 56
75349: PUSH
75350: LD_EXP 56
75354: PPUSH
75355: LD_VAR 0 1
75359: PPUSH
75360: LD_VAR 0 6
75364: PPUSH
75365: CALL_OW 1
75369: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75370: LD_ADDR_EXP 58
75374: PUSH
75375: LD_EXP 58
75379: PPUSH
75380: LD_VAR 0 1
75384: PPUSH
75385: LD_VAR 0 3
75389: PPUSH
75390: CALL_OW 1
75394: ST_TO_ADDR
// end ;
75395: LD_VAR 0 4
75399: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75400: LD_INT 0
75402: PPUSH
// if not mc_bases [ base ] then
75403: LD_EXP 43
75407: PUSH
75408: LD_VAR 0 1
75412: ARRAY
75413: NOT
75414: IFFALSE 75418
// exit ;
75416: GO 75443
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75418: LD_ADDR_EXP 48
75422: PUSH
75423: LD_EXP 48
75427: PPUSH
75428: LD_VAR 0 1
75432: PPUSH
75433: LD_VAR 0 2
75437: PPUSH
75438: CALL_OW 1
75442: ST_TO_ADDR
// end ;
75443: LD_VAR 0 3
75447: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75448: LD_INT 0
75450: PPUSH
// if not mc_bases [ base ] then
75451: LD_EXP 43
75455: PUSH
75456: LD_VAR 0 1
75460: ARRAY
75461: NOT
75462: IFFALSE 75466
// exit ;
75464: GO 75503
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75466: LD_ADDR_EXP 48
75470: PUSH
75471: LD_EXP 48
75475: PPUSH
75476: LD_VAR 0 1
75480: PPUSH
75481: LD_EXP 48
75485: PUSH
75486: LD_VAR 0 1
75490: ARRAY
75491: PUSH
75492: LD_VAR 0 2
75496: UNION
75497: PPUSH
75498: CALL_OW 1
75502: ST_TO_ADDR
// end ;
75503: LD_VAR 0 3
75507: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75508: LD_INT 0
75510: PPUSH
// if not mc_bases [ base ] then
75511: LD_EXP 43
75515: PUSH
75516: LD_VAR 0 1
75520: ARRAY
75521: NOT
75522: IFFALSE 75526
// exit ;
75524: GO 75551
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75526: LD_ADDR_EXP 64
75530: PUSH
75531: LD_EXP 64
75535: PPUSH
75536: LD_VAR 0 1
75540: PPUSH
75541: LD_VAR 0 2
75545: PPUSH
75546: CALL_OW 1
75550: ST_TO_ADDR
// end ;
75551: LD_VAR 0 3
75555: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75556: LD_INT 0
75558: PPUSH
// if not mc_bases [ base ] then
75559: LD_EXP 43
75563: PUSH
75564: LD_VAR 0 1
75568: ARRAY
75569: NOT
75570: IFFALSE 75574
// exit ;
75572: GO 75611
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75574: LD_ADDR_EXP 64
75578: PUSH
75579: LD_EXP 64
75583: PPUSH
75584: LD_VAR 0 1
75588: PPUSH
75589: LD_EXP 64
75593: PUSH
75594: LD_VAR 0 1
75598: ARRAY
75599: PUSH
75600: LD_VAR 0 2
75604: ADD
75605: PPUSH
75606: CALL_OW 1
75610: ST_TO_ADDR
// end ;
75611: LD_VAR 0 3
75615: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75616: LD_INT 0
75618: PPUSH
// if not mc_bases [ base ] then
75619: LD_EXP 43
75623: PUSH
75624: LD_VAR 0 1
75628: ARRAY
75629: NOT
75630: IFFALSE 75634
// exit ;
75632: GO 75688
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75634: LD_ADDR_EXP 65
75638: PUSH
75639: LD_EXP 65
75643: PPUSH
75644: LD_VAR 0 1
75648: PPUSH
75649: LD_VAR 0 2
75653: PPUSH
75654: CALL_OW 1
75658: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75659: LD_ADDR_EXP 54
75663: PUSH
75664: LD_EXP 54
75668: PPUSH
75669: LD_VAR 0 1
75673: PPUSH
75674: LD_VAR 0 2
75678: PUSH
75679: LD_INT 0
75681: PLUS
75682: PPUSH
75683: CALL_OW 1
75687: ST_TO_ADDR
// end ;
75688: LD_VAR 0 3
75692: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75693: LD_INT 0
75695: PPUSH
// if not mc_bases [ base ] then
75696: LD_EXP 43
75700: PUSH
75701: LD_VAR 0 1
75705: ARRAY
75706: NOT
75707: IFFALSE 75711
// exit ;
75709: GO 75736
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75711: LD_ADDR_EXP 54
75715: PUSH
75716: LD_EXP 54
75720: PPUSH
75721: LD_VAR 0 1
75725: PPUSH
75726: LD_VAR 0 2
75730: PPUSH
75731: CALL_OW 1
75735: ST_TO_ADDR
// end ;
75736: LD_VAR 0 3
75740: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75741: LD_INT 0
75743: PPUSH
75744: PPUSH
75745: PPUSH
75746: PPUSH
// if not mc_bases [ base ] then
75747: LD_EXP 43
75751: PUSH
75752: LD_VAR 0 1
75756: ARRAY
75757: NOT
75758: IFFALSE 75762
// exit ;
75760: GO 75827
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75762: LD_ADDR_EXP 63
75766: PUSH
75767: LD_EXP 63
75771: PPUSH
75772: LD_VAR 0 1
75776: PUSH
75777: LD_EXP 63
75781: PUSH
75782: LD_VAR 0 1
75786: ARRAY
75787: PUSH
75788: LD_INT 1
75790: PLUS
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PPUSH
75796: LD_VAR 0 1
75800: PUSH
75801: LD_VAR 0 2
75805: PUSH
75806: LD_VAR 0 3
75810: PUSH
75811: LD_VAR 0 4
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: LIST
75820: LIST
75821: PPUSH
75822: CALL 14988 0 3
75826: ST_TO_ADDR
// end ;
75827: LD_VAR 0 5
75831: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75832: LD_INT 0
75834: PPUSH
// if not mc_bases [ base ] then
75835: LD_EXP 43
75839: PUSH
75840: LD_VAR 0 1
75844: ARRAY
75845: NOT
75846: IFFALSE 75850
// exit ;
75848: GO 75875
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75850: LD_ADDR_EXP 80
75854: PUSH
75855: LD_EXP 80
75859: PPUSH
75860: LD_VAR 0 1
75864: PPUSH
75865: LD_VAR 0 2
75869: PPUSH
75870: CALL_OW 1
75874: ST_TO_ADDR
// end ;
75875: LD_VAR 0 3
75879: RET
// export function MC_GetMinesField ( base ) ; begin
75880: LD_INT 0
75882: PPUSH
// result := mc_mines [ base ] ;
75883: LD_ADDR_VAR 0 2
75887: PUSH
75888: LD_EXP 56
75892: PUSH
75893: LD_VAR 0 1
75897: ARRAY
75898: ST_TO_ADDR
// end ;
75899: LD_VAR 0 2
75903: RET
// export function MC_GetProduceList ( base ) ; begin
75904: LD_INT 0
75906: PPUSH
// result := mc_produce [ base ] ;
75907: LD_ADDR_VAR 0 2
75911: PUSH
75912: LD_EXP 64
75916: PUSH
75917: LD_VAR 0 1
75921: ARRAY
75922: ST_TO_ADDR
// end ;
75923: LD_VAR 0 2
75927: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75928: LD_INT 0
75930: PPUSH
75931: PPUSH
// if not mc_bases then
75932: LD_EXP 43
75936: NOT
75937: IFFALSE 75941
// exit ;
75939: GO 76006
// if mc_bases [ base ] then
75941: LD_EXP 43
75945: PUSH
75946: LD_VAR 0 1
75950: ARRAY
75951: IFFALSE 76006
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75953: LD_ADDR_VAR 0 3
75957: PUSH
75958: LD_EXP 43
75962: PUSH
75963: LD_VAR 0 1
75967: ARRAY
75968: PPUSH
75969: LD_INT 30
75971: PUSH
75972: LD_VAR 0 2
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PPUSH
75981: CALL_OW 72
75985: ST_TO_ADDR
// if result then
75986: LD_VAR 0 3
75990: IFFALSE 76006
// result := result [ 1 ] ;
75992: LD_ADDR_VAR 0 3
75996: PUSH
75997: LD_VAR 0 3
76001: PUSH
76002: LD_INT 1
76004: ARRAY
76005: ST_TO_ADDR
// end ; end ;
76006: LD_VAR 0 3
76010: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76011: LD_INT 0
76013: PPUSH
76014: PPUSH
// if not mc_bases then
76015: LD_EXP 43
76019: NOT
76020: IFFALSE 76024
// exit ;
76022: GO 76069
// if mc_bases [ base ] then
76024: LD_EXP 43
76028: PUSH
76029: LD_VAR 0 1
76033: ARRAY
76034: IFFALSE 76069
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76036: LD_ADDR_VAR 0 3
76040: PUSH
76041: LD_EXP 43
76045: PUSH
76046: LD_VAR 0 1
76050: ARRAY
76051: PPUSH
76052: LD_INT 30
76054: PUSH
76055: LD_VAR 0 2
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PPUSH
76064: CALL_OW 72
76068: ST_TO_ADDR
// end ;
76069: LD_VAR 0 3
76073: RET
// export function MC_SetTame ( base , area ) ; begin
76074: LD_INT 0
76076: PPUSH
// if not mc_bases or not base then
76077: LD_EXP 43
76081: NOT
76082: PUSH
76083: LD_VAR 0 1
76087: NOT
76088: OR
76089: IFFALSE 76093
// exit ;
76091: GO 76118
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76093: LD_ADDR_EXP 71
76097: PUSH
76098: LD_EXP 71
76102: PPUSH
76103: LD_VAR 0 1
76107: PPUSH
76108: LD_VAR 0 2
76112: PPUSH
76113: CALL_OW 1
76117: ST_TO_ADDR
// end ;
76118: LD_VAR 0 3
76122: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76123: LD_INT 0
76125: PPUSH
76126: PPUSH
// if not mc_bases or not base then
76127: LD_EXP 43
76131: NOT
76132: PUSH
76133: LD_VAR 0 1
76137: NOT
76138: OR
76139: IFFALSE 76143
// exit ;
76141: GO 76245
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76143: LD_ADDR_VAR 0 4
76147: PUSH
76148: LD_EXP 43
76152: PUSH
76153: LD_VAR 0 1
76157: ARRAY
76158: PPUSH
76159: LD_INT 30
76161: PUSH
76162: LD_VAR 0 2
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PPUSH
76171: CALL_OW 72
76175: ST_TO_ADDR
// if not tmp then
76176: LD_VAR 0 4
76180: NOT
76181: IFFALSE 76185
// exit ;
76183: GO 76245
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76185: LD_ADDR_EXP 75
76189: PUSH
76190: LD_EXP 75
76194: PPUSH
76195: LD_VAR 0 1
76199: PPUSH
76200: LD_EXP 75
76204: PUSH
76205: LD_VAR 0 1
76209: ARRAY
76210: PPUSH
76211: LD_EXP 75
76215: PUSH
76216: LD_VAR 0 1
76220: ARRAY
76221: PUSH
76222: LD_INT 1
76224: PLUS
76225: PPUSH
76226: LD_VAR 0 4
76230: PUSH
76231: LD_INT 1
76233: ARRAY
76234: PPUSH
76235: CALL_OW 2
76239: PPUSH
76240: CALL_OW 1
76244: ST_TO_ADDR
// end ;
76245: LD_VAR 0 3
76249: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76250: LD_INT 0
76252: PPUSH
76253: PPUSH
// if not mc_bases or not base or not kinds then
76254: LD_EXP 43
76258: NOT
76259: PUSH
76260: LD_VAR 0 1
76264: NOT
76265: OR
76266: PUSH
76267: LD_VAR 0 2
76271: NOT
76272: OR
76273: IFFALSE 76277
// exit ;
76275: GO 76338
// for i in kinds do
76277: LD_ADDR_VAR 0 4
76281: PUSH
76282: LD_VAR 0 2
76286: PUSH
76287: FOR_IN
76288: IFFALSE 76336
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76290: LD_ADDR_EXP 77
76294: PUSH
76295: LD_EXP 77
76299: PPUSH
76300: LD_VAR 0 1
76304: PUSH
76305: LD_EXP 77
76309: PUSH
76310: LD_VAR 0 1
76314: ARRAY
76315: PUSH
76316: LD_INT 1
76318: PLUS
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PPUSH
76324: LD_VAR 0 4
76328: PPUSH
76329: CALL 14988 0 3
76333: ST_TO_ADDR
76334: GO 76287
76336: POP
76337: POP
// end ;
76338: LD_VAR 0 3
76342: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76343: LD_INT 0
76345: PPUSH
// if not mc_bases or not base or not areas then
76346: LD_EXP 43
76350: NOT
76351: PUSH
76352: LD_VAR 0 1
76356: NOT
76357: OR
76358: PUSH
76359: LD_VAR 0 2
76363: NOT
76364: OR
76365: IFFALSE 76369
// exit ;
76367: GO 76394
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76369: LD_ADDR_EXP 61
76373: PUSH
76374: LD_EXP 61
76378: PPUSH
76379: LD_VAR 0 1
76383: PPUSH
76384: LD_VAR 0 2
76388: PPUSH
76389: CALL_OW 1
76393: ST_TO_ADDR
// end ;
76394: LD_VAR 0 3
76398: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76399: LD_INT 0
76401: PPUSH
// if not mc_bases or not base or not teleports_exit then
76402: LD_EXP 43
76406: NOT
76407: PUSH
76408: LD_VAR 0 1
76412: NOT
76413: OR
76414: PUSH
76415: LD_VAR 0 2
76419: NOT
76420: OR
76421: IFFALSE 76425
// exit ;
76423: GO 76450
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76425: LD_ADDR_EXP 78
76429: PUSH
76430: LD_EXP 78
76434: PPUSH
76435: LD_VAR 0 1
76439: PPUSH
76440: LD_VAR 0 2
76444: PPUSH
76445: CALL_OW 1
76449: ST_TO_ADDR
// end ;
76450: LD_VAR 0 3
76454: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76455: LD_INT 0
76457: PPUSH
76458: PPUSH
76459: PPUSH
// if not mc_bases or not base or not ext_list then
76460: LD_EXP 43
76464: NOT
76465: PUSH
76466: LD_VAR 0 1
76470: NOT
76471: OR
76472: PUSH
76473: LD_VAR 0 5
76477: NOT
76478: OR
76479: IFFALSE 76483
// exit ;
76481: GO 76656
// tmp := GetFacExtXYD ( x , y , d ) ;
76483: LD_ADDR_VAR 0 8
76487: PUSH
76488: LD_VAR 0 2
76492: PPUSH
76493: LD_VAR 0 3
76497: PPUSH
76498: LD_VAR 0 4
76502: PPUSH
76503: CALL 44965 0 3
76507: ST_TO_ADDR
// if not tmp then
76508: LD_VAR 0 8
76512: NOT
76513: IFFALSE 76517
// exit ;
76515: GO 76656
// for i in tmp do
76517: LD_ADDR_VAR 0 7
76521: PUSH
76522: LD_VAR 0 8
76526: PUSH
76527: FOR_IN
76528: IFFALSE 76654
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76530: LD_ADDR_EXP 48
76534: PUSH
76535: LD_EXP 48
76539: PPUSH
76540: LD_VAR 0 1
76544: PPUSH
76545: LD_EXP 48
76549: PUSH
76550: LD_VAR 0 1
76554: ARRAY
76555: PPUSH
76556: LD_EXP 48
76560: PUSH
76561: LD_VAR 0 1
76565: ARRAY
76566: PUSH
76567: LD_INT 1
76569: PLUS
76570: PPUSH
76571: LD_VAR 0 5
76575: PUSH
76576: LD_INT 1
76578: ARRAY
76579: PUSH
76580: LD_VAR 0 7
76584: PUSH
76585: LD_INT 1
76587: ARRAY
76588: PUSH
76589: LD_VAR 0 7
76593: PUSH
76594: LD_INT 2
76596: ARRAY
76597: PUSH
76598: LD_VAR 0 7
76602: PUSH
76603: LD_INT 3
76605: ARRAY
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: LIST
76611: LIST
76612: PPUSH
76613: CALL_OW 2
76617: PPUSH
76618: CALL_OW 1
76622: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76623: LD_ADDR_VAR 0 5
76627: PUSH
76628: LD_VAR 0 5
76632: PPUSH
76633: LD_INT 1
76635: PPUSH
76636: CALL_OW 3
76640: ST_TO_ADDR
// if not ext_list then
76641: LD_VAR 0 5
76645: NOT
76646: IFFALSE 76652
// exit ;
76648: POP
76649: POP
76650: GO 76656
// end ;
76652: GO 76527
76654: POP
76655: POP
// end ;
76656: LD_VAR 0 6
76660: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76661: LD_INT 0
76663: PPUSH
// if not mc_bases or not base or not weapon_list then
76664: LD_EXP 43
76668: NOT
76669: PUSH
76670: LD_VAR 0 1
76674: NOT
76675: OR
76676: PUSH
76677: LD_VAR 0 2
76681: NOT
76682: OR
76683: IFFALSE 76687
// exit ;
76685: GO 76712
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76687: LD_ADDR_EXP 82
76691: PUSH
76692: LD_EXP 82
76696: PPUSH
76697: LD_VAR 0 1
76701: PPUSH
76702: LD_VAR 0 2
76706: PPUSH
76707: CALL_OW 1
76711: ST_TO_ADDR
// end ;
76712: LD_VAR 0 3
76716: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76717: LD_INT 0
76719: PPUSH
// if not mc_bases or not base or not tech_list then
76720: LD_EXP 43
76724: NOT
76725: PUSH
76726: LD_VAR 0 1
76730: NOT
76731: OR
76732: PUSH
76733: LD_VAR 0 2
76737: NOT
76738: OR
76739: IFFALSE 76743
// exit ;
76741: GO 76768
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76743: LD_ADDR_EXP 70
76747: PUSH
76748: LD_EXP 70
76752: PPUSH
76753: LD_VAR 0 1
76757: PPUSH
76758: LD_VAR 0 2
76762: PPUSH
76763: CALL_OW 1
76767: ST_TO_ADDR
// end ;
76768: LD_VAR 0 3
76772: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76773: LD_INT 0
76775: PPUSH
// if not mc_bases or not parking_area or not base then
76776: LD_EXP 43
76780: NOT
76781: PUSH
76782: LD_VAR 0 2
76786: NOT
76787: OR
76788: PUSH
76789: LD_VAR 0 1
76793: NOT
76794: OR
76795: IFFALSE 76799
// exit ;
76797: GO 76824
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76799: LD_ADDR_EXP 67
76803: PUSH
76804: LD_EXP 67
76808: PPUSH
76809: LD_VAR 0 1
76813: PPUSH
76814: LD_VAR 0 2
76818: PPUSH
76819: CALL_OW 1
76823: ST_TO_ADDR
// end ;
76824: LD_VAR 0 3
76828: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76829: LD_INT 0
76831: PPUSH
// if not mc_bases or not base or not scan_area then
76832: LD_EXP 43
76836: NOT
76837: PUSH
76838: LD_VAR 0 1
76842: NOT
76843: OR
76844: PUSH
76845: LD_VAR 0 2
76849: NOT
76850: OR
76851: IFFALSE 76855
// exit ;
76853: GO 76880
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76855: LD_ADDR_EXP 68
76859: PUSH
76860: LD_EXP 68
76864: PPUSH
76865: LD_VAR 0 1
76869: PPUSH
76870: LD_VAR 0 2
76874: PPUSH
76875: CALL_OW 1
76879: ST_TO_ADDR
// end ;
76880: LD_VAR 0 3
76884: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76885: LD_INT 0
76887: PPUSH
76888: PPUSH
// if not mc_bases or not base then
76889: LD_EXP 43
76893: NOT
76894: PUSH
76895: LD_VAR 0 1
76899: NOT
76900: OR
76901: IFFALSE 76905
// exit ;
76903: GO 76969
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76905: LD_ADDR_VAR 0 3
76909: PUSH
76910: LD_INT 1
76912: PUSH
76913: LD_INT 2
76915: PUSH
76916: LD_INT 3
76918: PUSH
76919: LD_INT 4
76921: PUSH
76922: LD_INT 11
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: LIST
76929: LIST
76930: LIST
76931: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76932: LD_ADDR_EXP 70
76936: PUSH
76937: LD_EXP 70
76941: PPUSH
76942: LD_VAR 0 1
76946: PPUSH
76947: LD_EXP 70
76951: PUSH
76952: LD_VAR 0 1
76956: ARRAY
76957: PUSH
76958: LD_VAR 0 3
76962: DIFF
76963: PPUSH
76964: CALL_OW 1
76968: ST_TO_ADDR
// end ;
76969: LD_VAR 0 2
76973: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76974: LD_INT 0
76976: PPUSH
// result := mc_vehicles [ base ] ;
76977: LD_ADDR_VAR 0 3
76981: PUSH
76982: LD_EXP 62
76986: PUSH
76987: LD_VAR 0 1
76991: ARRAY
76992: ST_TO_ADDR
// if onlyCombat then
76993: LD_VAR 0 2
76997: IFFALSE 77169
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76999: LD_ADDR_VAR 0 3
77003: PUSH
77004: LD_VAR 0 3
77008: PUSH
77009: LD_VAR 0 3
77013: PPUSH
77014: LD_INT 2
77016: PUSH
77017: LD_INT 34
77019: PUSH
77020: LD_INT 12
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 34
77029: PUSH
77030: LD_INT 51
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PUSH
77037: LD_INT 34
77039: PUSH
77040: LD_INT 89
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: LD_INT 34
77049: PUSH
77050: LD_INT 32
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: PUSH
77057: LD_INT 34
77059: PUSH
77060: LD_INT 13
77062: PUSH
77063: EMPTY
77064: LIST
77065: LIST
77066: PUSH
77067: LD_INT 34
77069: PUSH
77070: LD_INT 52
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: LD_INT 34
77079: PUSH
77080: LD_INT 88
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: LD_INT 34
77089: PUSH
77090: LD_INT 14
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 34
77099: PUSH
77100: LD_INT 53
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PUSH
77107: LD_INT 34
77109: PUSH
77110: LD_INT 98
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PUSH
77117: LD_INT 34
77119: PUSH
77120: LD_INT 31
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 34
77129: PUSH
77130: LD_INT 48
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 34
77139: PUSH
77140: LD_INT 8
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: LIST
77151: LIST
77152: LIST
77153: LIST
77154: LIST
77155: LIST
77156: LIST
77157: LIST
77158: LIST
77159: LIST
77160: LIST
77161: LIST
77162: PPUSH
77163: CALL_OW 72
77167: DIFF
77168: ST_TO_ADDR
// end ; end_of_file
77169: LD_VAR 0 3
77173: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77174: LD_INT 0
77176: PPUSH
77177: PPUSH
77178: PPUSH
// if not mc_bases or not skirmish then
77179: LD_EXP 43
77183: NOT
77184: PUSH
77185: LD_EXP 41
77189: NOT
77190: OR
77191: IFFALSE 77195
// exit ;
77193: GO 77360
// for i = 1 to mc_bases do
77195: LD_ADDR_VAR 0 4
77199: PUSH
77200: DOUBLE
77201: LD_INT 1
77203: DEC
77204: ST_TO_ADDR
77205: LD_EXP 43
77209: PUSH
77210: FOR_TO
77211: IFFALSE 77358
// begin if sci in mc_bases [ i ] then
77213: LD_VAR 0 2
77217: PUSH
77218: LD_EXP 43
77222: PUSH
77223: LD_VAR 0 4
77227: ARRAY
77228: IN
77229: IFFALSE 77356
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77231: LD_ADDR_EXP 72
77235: PUSH
77236: LD_EXP 72
77240: PPUSH
77241: LD_VAR 0 4
77245: PUSH
77246: LD_EXP 72
77250: PUSH
77251: LD_VAR 0 4
77255: ARRAY
77256: PUSH
77257: LD_INT 1
77259: PLUS
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PPUSH
77265: LD_VAR 0 1
77269: PPUSH
77270: CALL 14988 0 3
77274: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77275: LD_ADDR_VAR 0 5
77279: PUSH
77280: LD_EXP 43
77284: PUSH
77285: LD_VAR 0 4
77289: ARRAY
77290: PPUSH
77291: LD_INT 2
77293: PUSH
77294: LD_INT 30
77296: PUSH
77297: LD_INT 0
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: LD_INT 30
77306: PUSH
77307: LD_INT 1
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: LIST
77318: PPUSH
77319: CALL_OW 72
77323: PPUSH
77324: LD_VAR 0 1
77328: PPUSH
77329: CALL_OW 74
77333: ST_TO_ADDR
// if tmp then
77334: LD_VAR 0 5
77338: IFFALSE 77354
// ComStandNearbyBuilding ( ape , tmp ) ;
77340: LD_VAR 0 1
77344: PPUSH
77345: LD_VAR 0 5
77349: PPUSH
77350: CALL 11415 0 2
// break ;
77354: GO 77358
// end ; end ;
77356: GO 77210
77358: POP
77359: POP
// end ;
77360: LD_VAR 0 3
77364: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77365: LD_INT 0
77367: PPUSH
77368: PPUSH
77369: PPUSH
// if not mc_bases or not skirmish then
77370: LD_EXP 43
77374: NOT
77375: PUSH
77376: LD_EXP 41
77380: NOT
77381: OR
77382: IFFALSE 77386
// exit ;
77384: GO 77475
// for i = 1 to mc_bases do
77386: LD_ADDR_VAR 0 4
77390: PUSH
77391: DOUBLE
77392: LD_INT 1
77394: DEC
77395: ST_TO_ADDR
77396: LD_EXP 43
77400: PUSH
77401: FOR_TO
77402: IFFALSE 77473
// begin if building in mc_busy_turret_list [ i ] then
77404: LD_VAR 0 1
77408: PUSH
77409: LD_EXP 53
77413: PUSH
77414: LD_VAR 0 4
77418: ARRAY
77419: IN
77420: IFFALSE 77471
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77422: LD_ADDR_VAR 0 5
77426: PUSH
77427: LD_EXP 53
77431: PUSH
77432: LD_VAR 0 4
77436: ARRAY
77437: PUSH
77438: LD_VAR 0 1
77442: DIFF
77443: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77444: LD_ADDR_EXP 53
77448: PUSH
77449: LD_EXP 53
77453: PPUSH
77454: LD_VAR 0 4
77458: PPUSH
77459: LD_VAR 0 5
77463: PPUSH
77464: CALL_OW 1
77468: ST_TO_ADDR
// break ;
77469: GO 77473
// end ; end ;
77471: GO 77401
77473: POP
77474: POP
// end ;
77475: LD_VAR 0 3
77479: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77480: LD_INT 0
77482: PPUSH
77483: PPUSH
77484: PPUSH
// if not mc_bases or not skirmish then
77485: LD_EXP 43
77489: NOT
77490: PUSH
77491: LD_EXP 41
77495: NOT
77496: OR
77497: IFFALSE 77501
// exit ;
77499: GO 77700
// for i = 1 to mc_bases do
77501: LD_ADDR_VAR 0 5
77505: PUSH
77506: DOUBLE
77507: LD_INT 1
77509: DEC
77510: ST_TO_ADDR
77511: LD_EXP 43
77515: PUSH
77516: FOR_TO
77517: IFFALSE 77698
// if building in mc_bases [ i ] then
77519: LD_VAR 0 1
77523: PUSH
77524: LD_EXP 43
77528: PUSH
77529: LD_VAR 0 5
77533: ARRAY
77534: IN
77535: IFFALSE 77696
// begin tmp := mc_bases [ i ] diff building ;
77537: LD_ADDR_VAR 0 6
77541: PUSH
77542: LD_EXP 43
77546: PUSH
77547: LD_VAR 0 5
77551: ARRAY
77552: PUSH
77553: LD_VAR 0 1
77557: DIFF
77558: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77559: LD_ADDR_EXP 43
77563: PUSH
77564: LD_EXP 43
77568: PPUSH
77569: LD_VAR 0 5
77573: PPUSH
77574: LD_VAR 0 6
77578: PPUSH
77579: CALL_OW 1
77583: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77584: LD_VAR 0 1
77588: PUSH
77589: LD_EXP 51
77593: PUSH
77594: LD_VAR 0 5
77598: ARRAY
77599: IN
77600: IFFALSE 77639
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77602: LD_ADDR_EXP 51
77606: PUSH
77607: LD_EXP 51
77611: PPUSH
77612: LD_VAR 0 5
77616: PPUSH
77617: LD_EXP 51
77621: PUSH
77622: LD_VAR 0 5
77626: ARRAY
77627: PUSH
77628: LD_VAR 0 1
77632: DIFF
77633: PPUSH
77634: CALL_OW 1
77638: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77639: LD_VAR 0 1
77643: PUSH
77644: LD_EXP 52
77648: PUSH
77649: LD_VAR 0 5
77653: ARRAY
77654: IN
77655: IFFALSE 77694
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77657: LD_ADDR_EXP 52
77661: PUSH
77662: LD_EXP 52
77666: PPUSH
77667: LD_VAR 0 5
77671: PPUSH
77672: LD_EXP 52
77676: PUSH
77677: LD_VAR 0 5
77681: ARRAY
77682: PUSH
77683: LD_VAR 0 1
77687: DIFF
77688: PPUSH
77689: CALL_OW 1
77693: ST_TO_ADDR
// break ;
77694: GO 77698
// end ;
77696: GO 77516
77698: POP
77699: POP
// end ;
77700: LD_VAR 0 4
77704: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77705: LD_INT 0
77707: PPUSH
77708: PPUSH
77709: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77710: LD_EXP 43
77714: NOT
77715: PUSH
77716: LD_EXP 41
77720: NOT
77721: OR
77722: PUSH
77723: LD_VAR 0 3
77727: PUSH
77728: LD_EXP 69
77732: IN
77733: NOT
77734: OR
77735: IFFALSE 77739
// exit ;
77737: GO 77862
// for i = 1 to mc_vehicles do
77739: LD_ADDR_VAR 0 6
77743: PUSH
77744: DOUBLE
77745: LD_INT 1
77747: DEC
77748: ST_TO_ADDR
77749: LD_EXP 62
77753: PUSH
77754: FOR_TO
77755: IFFALSE 77860
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77757: LD_VAR 0 2
77761: PUSH
77762: LD_EXP 62
77766: PUSH
77767: LD_VAR 0 6
77771: ARRAY
77772: IN
77773: PUSH
77774: LD_VAR 0 1
77778: PUSH
77779: LD_EXP 62
77783: PUSH
77784: LD_VAR 0 6
77788: ARRAY
77789: IN
77790: OR
77791: IFFALSE 77858
// begin tmp := mc_vehicles [ i ] diff old ;
77793: LD_ADDR_VAR 0 7
77797: PUSH
77798: LD_EXP 62
77802: PUSH
77803: LD_VAR 0 6
77807: ARRAY
77808: PUSH
77809: LD_VAR 0 2
77813: DIFF
77814: ST_TO_ADDR
// tmp := tmp diff new ;
77815: LD_ADDR_VAR 0 7
77819: PUSH
77820: LD_VAR 0 7
77824: PUSH
77825: LD_VAR 0 1
77829: DIFF
77830: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77831: LD_ADDR_EXP 62
77835: PUSH
77836: LD_EXP 62
77840: PPUSH
77841: LD_VAR 0 6
77845: PPUSH
77846: LD_VAR 0 7
77850: PPUSH
77851: CALL_OW 1
77855: ST_TO_ADDR
// break ;
77856: GO 77860
// end ;
77858: GO 77754
77860: POP
77861: POP
// end ;
77862: LD_VAR 0 5
77866: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77867: LD_INT 0
77869: PPUSH
77870: PPUSH
77871: PPUSH
77872: PPUSH
// if not mc_bases or not skirmish then
77873: LD_EXP 43
77877: NOT
77878: PUSH
77879: LD_EXP 41
77883: NOT
77884: OR
77885: IFFALSE 77889
// exit ;
77887: GO 78309
// repeat wait ( 0 0$1 ) ;
77889: LD_INT 35
77891: PPUSH
77892: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
77896: LD_EXP 87
77900: NOT
77901: IFFALSE 77889
// mc_block_vehicle_constructed_thread := true ;
77903: LD_ADDR_EXP 87
77907: PUSH
77908: LD_INT 1
77910: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
77911: LD_ADDR_VAR 0 5
77915: PUSH
77916: LD_VAR 0 1
77920: PPUSH
77921: CALL_OW 255
77925: ST_TO_ADDR
// for i = 1 to mc_bases do
77926: LD_ADDR_VAR 0 4
77930: PUSH
77931: DOUBLE
77932: LD_INT 1
77934: DEC
77935: ST_TO_ADDR
77936: LD_EXP 43
77940: PUSH
77941: FOR_TO
77942: IFFALSE 78299
// begin if factory in mc_bases [ i ] then
77944: LD_VAR 0 2
77948: PUSH
77949: LD_EXP 43
77953: PUSH
77954: LD_VAR 0 4
77958: ARRAY
77959: IN
77960: IFFALSE 78297
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77962: LD_EXP 65
77966: PUSH
77967: LD_VAR 0 4
77971: ARRAY
77972: PUSH
77973: LD_EXP 54
77977: PUSH
77978: LD_VAR 0 4
77982: ARRAY
77983: LESS
77984: PUSH
77985: LD_VAR 0 1
77989: PPUSH
77990: CALL_OW 264
77994: PUSH
77995: LD_INT 31
77997: PUSH
77998: LD_INT 32
78000: PUSH
78001: LD_INT 51
78003: PUSH
78004: LD_INT 89
78006: PUSH
78007: LD_INT 12
78009: PUSH
78010: LD_INT 30
78012: PUSH
78013: LD_INT 98
78015: PUSH
78016: LD_INT 11
78018: PUSH
78019: LD_INT 53
78021: PUSH
78022: LD_INT 14
78024: PUSH
78025: LD_INT 91
78027: PUSH
78028: LD_INT 29
78030: PUSH
78031: LD_INT 99
78033: PUSH
78034: LD_INT 13
78036: PUSH
78037: LD_INT 52
78039: PUSH
78040: LD_INT 88
78042: PUSH
78043: LD_INT 48
78045: PUSH
78046: LD_INT 8
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: LIST
78053: LIST
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: LIST
78060: LIST
78061: LIST
78062: LIST
78063: LIST
78064: LIST
78065: LIST
78066: LIST
78067: LIST
78068: IN
78069: NOT
78070: AND
78071: IFFALSE 78119
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78073: LD_ADDR_EXP 65
78077: PUSH
78078: LD_EXP 65
78082: PPUSH
78083: LD_VAR 0 4
78087: PUSH
78088: LD_EXP 65
78092: PUSH
78093: LD_VAR 0 4
78097: ARRAY
78098: PUSH
78099: LD_INT 1
78101: PLUS
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PPUSH
78107: LD_VAR 0 1
78111: PPUSH
78112: CALL 14988 0 3
78116: ST_TO_ADDR
78117: GO 78163
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78119: LD_ADDR_EXP 62
78123: PUSH
78124: LD_EXP 62
78128: PPUSH
78129: LD_VAR 0 4
78133: PUSH
78134: LD_EXP 62
78138: PUSH
78139: LD_VAR 0 4
78143: ARRAY
78144: PUSH
78145: LD_INT 1
78147: PLUS
78148: PUSH
78149: EMPTY
78150: LIST
78151: LIST
78152: PPUSH
78153: LD_VAR 0 1
78157: PPUSH
78158: CALL 14988 0 3
78162: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
78163: LD_ADDR_EXP 87
78167: PUSH
78168: LD_INT 0
78170: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78171: LD_VAR 0 1
78175: PPUSH
78176: CALL_OW 263
78180: PUSH
78181: LD_INT 2
78183: EQUAL
78184: IFFALSE 78213
// begin repeat wait ( 0 0$3 ) ;
78186: LD_INT 105
78188: PPUSH
78189: CALL_OW 67
// Connect ( vehicle ) ;
78193: LD_VAR 0 1
78197: PPUSH
78198: CALL 17957 0 1
// until IsControledBy ( vehicle ) ;
78202: LD_VAR 0 1
78206: PPUSH
78207: CALL_OW 312
78211: IFFALSE 78186
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78213: LD_VAR 0 1
78217: PPUSH
78218: LD_EXP 67
78222: PUSH
78223: LD_VAR 0 4
78227: ARRAY
78228: PPUSH
78229: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78233: LD_VAR 0 1
78237: PPUSH
78238: CALL_OW 263
78242: PUSH
78243: LD_INT 1
78245: NONEQUAL
78246: IFFALSE 78250
// break ;
78248: GO 78299
// repeat wait ( 0 0$1 ) ;
78250: LD_INT 35
78252: PPUSH
78253: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78257: LD_VAR 0 1
78261: PPUSH
78262: LD_EXP 67
78266: PUSH
78267: LD_VAR 0 4
78271: ARRAY
78272: PPUSH
78273: CALL_OW 308
78277: IFFALSE 78250
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78279: LD_VAR 0 1
78283: PPUSH
78284: CALL_OW 311
78288: PPUSH
78289: CALL_OW 121
// exit ;
78293: POP
78294: POP
78295: GO 78309
// end ; end ;
78297: GO 77941
78299: POP
78300: POP
// mc_block_vehicle_constructed_thread := false ;
78301: LD_ADDR_EXP 87
78305: PUSH
78306: LD_INT 0
78308: ST_TO_ADDR
// end ;
78309: LD_VAR 0 3
78313: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78314: LD_INT 0
78316: PPUSH
78317: PPUSH
78318: PPUSH
78319: PPUSH
// if not mc_bases or not skirmish then
78320: LD_EXP 43
78324: NOT
78325: PUSH
78326: LD_EXP 41
78330: NOT
78331: OR
78332: IFFALSE 78336
// exit ;
78334: GO 78689
// repeat wait ( 0 0$1 ) ;
78336: LD_INT 35
78338: PPUSH
78339: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78343: LD_VAR 0 2
78347: PPUSH
78348: LD_VAR 0 3
78352: PPUSH
78353: CALL_OW 284
78357: IFFALSE 78336
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78359: LD_VAR 0 2
78363: PPUSH
78364: LD_VAR 0 3
78368: PPUSH
78369: CALL_OW 283
78373: PUSH
78374: LD_INT 4
78376: EQUAL
78377: IFFALSE 78381
// exit ;
78379: GO 78689
// for i = 1 to mc_bases do
78381: LD_ADDR_VAR 0 7
78385: PUSH
78386: DOUBLE
78387: LD_INT 1
78389: DEC
78390: ST_TO_ADDR
78391: LD_EXP 43
78395: PUSH
78396: FOR_TO
78397: IFFALSE 78687
// begin if mc_crates_area [ i ] then
78399: LD_EXP 61
78403: PUSH
78404: LD_VAR 0 7
78408: ARRAY
78409: IFFALSE 78520
// for j in mc_crates_area [ i ] do
78411: LD_ADDR_VAR 0 8
78415: PUSH
78416: LD_EXP 61
78420: PUSH
78421: LD_VAR 0 7
78425: ARRAY
78426: PUSH
78427: FOR_IN
78428: IFFALSE 78518
// if InArea ( x , y , j ) then
78430: LD_VAR 0 2
78434: PPUSH
78435: LD_VAR 0 3
78439: PPUSH
78440: LD_VAR 0 8
78444: PPUSH
78445: CALL_OW 309
78449: IFFALSE 78516
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78451: LD_ADDR_EXP 59
78455: PUSH
78456: LD_EXP 59
78460: PPUSH
78461: LD_VAR 0 7
78465: PUSH
78466: LD_EXP 59
78470: PUSH
78471: LD_VAR 0 7
78475: ARRAY
78476: PUSH
78477: LD_INT 1
78479: PLUS
78480: PUSH
78481: EMPTY
78482: LIST
78483: LIST
78484: PPUSH
78485: LD_VAR 0 4
78489: PUSH
78490: LD_VAR 0 2
78494: PUSH
78495: LD_VAR 0 3
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: LIST
78504: PPUSH
78505: CALL 14988 0 3
78509: ST_TO_ADDR
// exit ;
78510: POP
78511: POP
78512: POP
78513: POP
78514: GO 78689
// end ;
78516: GO 78427
78518: POP
78519: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78520: LD_ADDR_VAR 0 9
78524: PUSH
78525: LD_EXP 43
78529: PUSH
78530: LD_VAR 0 7
78534: ARRAY
78535: PPUSH
78536: LD_INT 2
78538: PUSH
78539: LD_INT 30
78541: PUSH
78542: LD_INT 0
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: LD_INT 30
78551: PUSH
78552: LD_INT 1
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: LIST
78563: PPUSH
78564: CALL_OW 72
78568: ST_TO_ADDR
// if not depot then
78569: LD_VAR 0 9
78573: NOT
78574: IFFALSE 78578
// continue ;
78576: GO 78396
// for j in depot do
78578: LD_ADDR_VAR 0 8
78582: PUSH
78583: LD_VAR 0 9
78587: PUSH
78588: FOR_IN
78589: IFFALSE 78683
// if GetDistUnitXY ( j , x , y ) < 30 then
78591: LD_VAR 0 8
78595: PPUSH
78596: LD_VAR 0 2
78600: PPUSH
78601: LD_VAR 0 3
78605: PPUSH
78606: CALL_OW 297
78610: PUSH
78611: LD_INT 30
78613: LESS
78614: IFFALSE 78681
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78616: LD_ADDR_EXP 59
78620: PUSH
78621: LD_EXP 59
78625: PPUSH
78626: LD_VAR 0 7
78630: PUSH
78631: LD_EXP 59
78635: PUSH
78636: LD_VAR 0 7
78640: ARRAY
78641: PUSH
78642: LD_INT 1
78644: PLUS
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PPUSH
78650: LD_VAR 0 4
78654: PUSH
78655: LD_VAR 0 2
78659: PUSH
78660: LD_VAR 0 3
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: LIST
78669: PPUSH
78670: CALL 14988 0 3
78674: ST_TO_ADDR
// exit ;
78675: POP
78676: POP
78677: POP
78678: POP
78679: GO 78689
// end ;
78681: GO 78588
78683: POP
78684: POP
// end ;
78685: GO 78396
78687: POP
78688: POP
// end ;
78689: LD_VAR 0 6
78693: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78694: LD_INT 0
78696: PPUSH
78697: PPUSH
78698: PPUSH
78699: PPUSH
// if not mc_bases or not skirmish then
78700: LD_EXP 43
78704: NOT
78705: PUSH
78706: LD_EXP 41
78710: NOT
78711: OR
78712: IFFALSE 78716
// exit ;
78714: GO 78993
// side := GetSide ( lab ) ;
78716: LD_ADDR_VAR 0 4
78720: PUSH
78721: LD_VAR 0 2
78725: PPUSH
78726: CALL_OW 255
78730: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78731: LD_VAR 0 4
78735: PUSH
78736: LD_EXP 69
78740: IN
78741: NOT
78742: PUSH
78743: LD_EXP 70
78747: NOT
78748: OR
78749: PUSH
78750: LD_EXP 43
78754: NOT
78755: OR
78756: IFFALSE 78760
// exit ;
78758: GO 78993
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78760: LD_ADDR_EXP 70
78764: PUSH
78765: LD_EXP 70
78769: PPUSH
78770: LD_VAR 0 4
78774: PPUSH
78775: LD_EXP 70
78779: PUSH
78780: LD_VAR 0 4
78784: ARRAY
78785: PUSH
78786: LD_VAR 0 1
78790: DIFF
78791: PPUSH
78792: CALL_OW 1
78796: ST_TO_ADDR
// for i = 1 to mc_bases do
78797: LD_ADDR_VAR 0 5
78801: PUSH
78802: DOUBLE
78803: LD_INT 1
78805: DEC
78806: ST_TO_ADDR
78807: LD_EXP 43
78811: PUSH
78812: FOR_TO
78813: IFFALSE 78991
// begin if lab in mc_bases [ i ] then
78815: LD_VAR 0 2
78819: PUSH
78820: LD_EXP 43
78824: PUSH
78825: LD_VAR 0 5
78829: ARRAY
78830: IN
78831: IFFALSE 78989
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78833: LD_VAR 0 1
78837: PUSH
78838: LD_INT 11
78840: PUSH
78841: LD_INT 4
78843: PUSH
78844: LD_INT 3
78846: PUSH
78847: LD_INT 2
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: LIST
78854: LIST
78855: IN
78856: PUSH
78857: LD_EXP 73
78861: PUSH
78862: LD_VAR 0 5
78866: ARRAY
78867: AND
78868: IFFALSE 78989
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78870: LD_ADDR_VAR 0 6
78874: PUSH
78875: LD_EXP 73
78879: PUSH
78880: LD_VAR 0 5
78884: ARRAY
78885: PUSH
78886: LD_INT 1
78888: ARRAY
78889: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78890: LD_ADDR_EXP 73
78894: PUSH
78895: LD_EXP 73
78899: PPUSH
78900: LD_VAR 0 5
78904: PPUSH
78905: EMPTY
78906: PPUSH
78907: CALL_OW 1
78911: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78912: LD_VAR 0 6
78916: PPUSH
78917: LD_INT 0
78919: PPUSH
78920: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78924: LD_VAR 0 6
78928: PPUSH
78929: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78933: LD_ADDR_EXP 72
78937: PUSH
78938: LD_EXP 72
78942: PPUSH
78943: LD_VAR 0 5
78947: PPUSH
78948: LD_EXP 72
78952: PUSH
78953: LD_VAR 0 5
78957: ARRAY
78958: PPUSH
78959: LD_INT 1
78961: PPUSH
78962: LD_VAR 0 6
78966: PPUSH
78967: CALL_OW 2
78971: PPUSH
78972: CALL_OW 1
78976: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78977: LD_VAR 0 5
78981: PPUSH
78982: LD_INT 112
78984: PPUSH
78985: CALL 55441 0 2
// end ; end ; end ;
78989: GO 78812
78991: POP
78992: POP
// end ;
78993: LD_VAR 0 3
78997: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78998: LD_INT 0
79000: PPUSH
79001: PPUSH
79002: PPUSH
79003: PPUSH
79004: PPUSH
79005: PPUSH
79006: PPUSH
79007: PPUSH
// if not mc_bases or not skirmish then
79008: LD_EXP 43
79012: NOT
79013: PUSH
79014: LD_EXP 41
79018: NOT
79019: OR
79020: IFFALSE 79024
// exit ;
79022: GO 80393
// for i = 1 to mc_bases do
79024: LD_ADDR_VAR 0 3
79028: PUSH
79029: DOUBLE
79030: LD_INT 1
79032: DEC
79033: ST_TO_ADDR
79034: LD_EXP 43
79038: PUSH
79039: FOR_TO
79040: IFFALSE 80391
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79042: LD_VAR 0 1
79046: PUSH
79047: LD_EXP 43
79051: PUSH
79052: LD_VAR 0 3
79056: ARRAY
79057: IN
79058: PUSH
79059: LD_VAR 0 1
79063: PUSH
79064: LD_EXP 50
79068: PUSH
79069: LD_VAR 0 3
79073: ARRAY
79074: IN
79075: OR
79076: PUSH
79077: LD_VAR 0 1
79081: PUSH
79082: LD_EXP 65
79086: PUSH
79087: LD_VAR 0 3
79091: ARRAY
79092: IN
79093: OR
79094: PUSH
79095: LD_VAR 0 1
79099: PUSH
79100: LD_EXP 62
79104: PUSH
79105: LD_VAR 0 3
79109: ARRAY
79110: IN
79111: OR
79112: PUSH
79113: LD_VAR 0 1
79117: PUSH
79118: LD_EXP 72
79122: PUSH
79123: LD_VAR 0 3
79127: ARRAY
79128: IN
79129: OR
79130: PUSH
79131: LD_VAR 0 1
79135: PUSH
79136: LD_EXP 73
79140: PUSH
79141: LD_VAR 0 3
79145: ARRAY
79146: IN
79147: OR
79148: IFFALSE 80389
// begin if un in mc_ape [ i ] then
79150: LD_VAR 0 1
79154: PUSH
79155: LD_EXP 72
79159: PUSH
79160: LD_VAR 0 3
79164: ARRAY
79165: IN
79166: IFFALSE 79205
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79168: LD_ADDR_EXP 72
79172: PUSH
79173: LD_EXP 72
79177: PPUSH
79178: LD_VAR 0 3
79182: PPUSH
79183: LD_EXP 72
79187: PUSH
79188: LD_VAR 0 3
79192: ARRAY
79193: PUSH
79194: LD_VAR 0 1
79198: DIFF
79199: PPUSH
79200: CALL_OW 1
79204: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79205: LD_VAR 0 1
79209: PUSH
79210: LD_EXP 73
79214: PUSH
79215: LD_VAR 0 3
79219: ARRAY
79220: IN
79221: IFFALSE 79245
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79223: LD_ADDR_EXP 73
79227: PUSH
79228: LD_EXP 73
79232: PPUSH
79233: LD_VAR 0 3
79237: PPUSH
79238: EMPTY
79239: PPUSH
79240: CALL_OW 1
79244: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79245: LD_VAR 0 1
79249: PPUSH
79250: CALL_OW 247
79254: PUSH
79255: LD_INT 2
79257: EQUAL
79258: PUSH
79259: LD_VAR 0 1
79263: PPUSH
79264: CALL_OW 110
79268: PUSH
79269: LD_INT 20
79271: EQUAL
79272: PUSH
79273: LD_VAR 0 1
79277: PUSH
79278: LD_EXP 65
79282: PUSH
79283: LD_VAR 0 3
79287: ARRAY
79288: IN
79289: OR
79290: PUSH
79291: LD_VAR 0 1
79295: PPUSH
79296: CALL_OW 264
79300: PUSH
79301: LD_INT 12
79303: PUSH
79304: LD_INT 51
79306: PUSH
79307: LD_INT 89
79309: PUSH
79310: LD_INT 32
79312: PUSH
79313: LD_INT 13
79315: PUSH
79316: LD_INT 52
79318: PUSH
79319: LD_INT 31
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: IN
79331: OR
79332: AND
79333: IFFALSE 79641
// begin if un in mc_defender [ i ] then
79335: LD_VAR 0 1
79339: PUSH
79340: LD_EXP 65
79344: PUSH
79345: LD_VAR 0 3
79349: ARRAY
79350: IN
79351: IFFALSE 79390
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79353: LD_ADDR_EXP 65
79357: PUSH
79358: LD_EXP 65
79362: PPUSH
79363: LD_VAR 0 3
79367: PPUSH
79368: LD_EXP 65
79372: PUSH
79373: LD_VAR 0 3
79377: ARRAY
79378: PUSH
79379: LD_VAR 0 1
79383: DIFF
79384: PPUSH
79385: CALL_OW 1
79389: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79390: LD_ADDR_VAR 0 8
79394: PUSH
79395: LD_VAR 0 3
79399: PPUSH
79400: LD_INT 3
79402: PPUSH
79403: CALL 76011 0 2
79407: ST_TO_ADDR
// if fac then
79408: LD_VAR 0 8
79412: IFFALSE 79641
// begin for j in fac do
79414: LD_ADDR_VAR 0 4
79418: PUSH
79419: LD_VAR 0 8
79423: PUSH
79424: FOR_IN
79425: IFFALSE 79639
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79427: LD_ADDR_VAR 0 9
79431: PUSH
79432: LD_VAR 0 8
79436: PPUSH
79437: LD_VAR 0 1
79441: PPUSH
79442: CALL_OW 265
79446: PPUSH
79447: LD_VAR 0 1
79451: PPUSH
79452: CALL_OW 262
79456: PPUSH
79457: LD_VAR 0 1
79461: PPUSH
79462: CALL_OW 263
79466: PPUSH
79467: LD_VAR 0 1
79471: PPUSH
79472: CALL_OW 264
79476: PPUSH
79477: CALL 12486 0 5
79481: ST_TO_ADDR
// if components then
79482: LD_VAR 0 9
79486: IFFALSE 79637
// begin if GetWeapon ( un ) = ar_control_tower then
79488: LD_VAR 0 1
79492: PPUSH
79493: CALL_OW 264
79497: PUSH
79498: LD_INT 31
79500: EQUAL
79501: IFFALSE 79618
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79503: LD_VAR 0 1
79507: PPUSH
79508: CALL_OW 311
79512: PPUSH
79513: LD_INT 0
79515: PPUSH
79516: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79520: LD_ADDR_EXP 83
79524: PUSH
79525: LD_EXP 83
79529: PPUSH
79530: LD_VAR 0 3
79534: PPUSH
79535: LD_EXP 83
79539: PUSH
79540: LD_VAR 0 3
79544: ARRAY
79545: PUSH
79546: LD_VAR 0 1
79550: PPUSH
79551: CALL_OW 311
79555: DIFF
79556: PPUSH
79557: CALL_OW 1
79561: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79562: LD_ADDR_VAR 0 7
79566: PUSH
79567: LD_EXP 64
79571: PUSH
79572: LD_VAR 0 3
79576: ARRAY
79577: PPUSH
79578: LD_INT 1
79580: PPUSH
79581: LD_VAR 0 9
79585: PPUSH
79586: CALL_OW 2
79590: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79591: LD_ADDR_EXP 64
79595: PUSH
79596: LD_EXP 64
79600: PPUSH
79601: LD_VAR 0 3
79605: PPUSH
79606: LD_VAR 0 7
79610: PPUSH
79611: CALL_OW 1
79615: ST_TO_ADDR
// end else
79616: GO 79635
// MC_InsertProduceList ( i , [ components ] ) ;
79618: LD_VAR 0 3
79622: PPUSH
79623: LD_VAR 0 9
79627: PUSH
79628: EMPTY
79629: LIST
79630: PPUSH
79631: CALL 75556 0 2
// break ;
79635: GO 79639
// end ; end ;
79637: GO 79424
79639: POP
79640: POP
// end ; end ; if GetType ( un ) = unit_building then
79641: LD_VAR 0 1
79645: PPUSH
79646: CALL_OW 247
79650: PUSH
79651: LD_INT 3
79653: EQUAL
79654: IFFALSE 80057
// begin btype := GetBType ( un ) ;
79656: LD_ADDR_VAR 0 5
79660: PUSH
79661: LD_VAR 0 1
79665: PPUSH
79666: CALL_OW 266
79670: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79671: LD_VAR 0 5
79675: PUSH
79676: LD_INT 29
79678: PUSH
79679: LD_INT 30
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: IN
79686: IFFALSE 79759
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79688: LD_VAR 0 1
79692: PPUSH
79693: CALL_OW 250
79697: PPUSH
79698: LD_VAR 0 1
79702: PPUSH
79703: CALL_OW 251
79707: PPUSH
79708: LD_VAR 0 1
79712: PPUSH
79713: CALL_OW 255
79717: PPUSH
79718: CALL_OW 440
79722: NOT
79723: IFFALSE 79759
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79725: LD_VAR 0 1
79729: PPUSH
79730: CALL_OW 250
79734: PPUSH
79735: LD_VAR 0 1
79739: PPUSH
79740: CALL_OW 251
79744: PPUSH
79745: LD_VAR 0 1
79749: PPUSH
79750: CALL_OW 255
79754: PPUSH
79755: CALL_OW 441
// end ; if btype = b_warehouse then
79759: LD_VAR 0 5
79763: PUSH
79764: LD_INT 1
79766: EQUAL
79767: IFFALSE 79785
// begin btype := b_depot ;
79769: LD_ADDR_VAR 0 5
79773: PUSH
79774: LD_INT 0
79776: ST_TO_ADDR
// pos := 1 ;
79777: LD_ADDR_VAR 0 6
79781: PUSH
79782: LD_INT 1
79784: ST_TO_ADDR
// end ; if btype = b_factory then
79785: LD_VAR 0 5
79789: PUSH
79790: LD_INT 3
79792: EQUAL
79793: IFFALSE 79811
// begin btype := b_workshop ;
79795: LD_ADDR_VAR 0 5
79799: PUSH
79800: LD_INT 2
79802: ST_TO_ADDR
// pos := 1 ;
79803: LD_ADDR_VAR 0 6
79807: PUSH
79808: LD_INT 1
79810: ST_TO_ADDR
// end ; if btype = b_barracks then
79811: LD_VAR 0 5
79815: PUSH
79816: LD_INT 5
79818: EQUAL
79819: IFFALSE 79829
// btype := b_armoury ;
79821: LD_ADDR_VAR 0 5
79825: PUSH
79826: LD_INT 4
79828: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79829: LD_VAR 0 5
79833: PUSH
79834: LD_INT 7
79836: PUSH
79837: LD_INT 8
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: IN
79844: IFFALSE 79854
// btype := b_lab ;
79846: LD_ADDR_VAR 0 5
79850: PUSH
79851: LD_INT 6
79853: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79854: LD_ADDR_EXP 48
79858: PUSH
79859: LD_EXP 48
79863: PPUSH
79864: LD_VAR 0 3
79868: PUSH
79869: LD_EXP 48
79873: PUSH
79874: LD_VAR 0 3
79878: ARRAY
79879: PUSH
79880: LD_INT 1
79882: PLUS
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: PPUSH
79888: LD_VAR 0 5
79892: PUSH
79893: LD_VAR 0 1
79897: PPUSH
79898: CALL_OW 250
79902: PUSH
79903: LD_VAR 0 1
79907: PPUSH
79908: CALL_OW 251
79912: PUSH
79913: LD_VAR 0 1
79917: PPUSH
79918: CALL_OW 254
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: PPUSH
79929: CALL 14988 0 3
79933: ST_TO_ADDR
// if pos = 1 then
79934: LD_VAR 0 6
79938: PUSH
79939: LD_INT 1
79941: EQUAL
79942: IFFALSE 80057
// begin tmp := mc_build_list [ i ] ;
79944: LD_ADDR_VAR 0 7
79948: PUSH
79949: LD_EXP 48
79953: PUSH
79954: LD_VAR 0 3
79958: ARRAY
79959: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79960: LD_VAR 0 7
79964: PPUSH
79965: LD_INT 2
79967: PUSH
79968: LD_INT 30
79970: PUSH
79971: LD_INT 0
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 30
79980: PUSH
79981: LD_INT 1
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: EMPTY
79989: LIST
79990: LIST
79991: LIST
79992: PPUSH
79993: CALL_OW 72
79997: IFFALSE 80007
// pos := 2 ;
79999: LD_ADDR_VAR 0 6
80003: PUSH
80004: LD_INT 2
80006: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80007: LD_ADDR_VAR 0 7
80011: PUSH
80012: LD_VAR 0 7
80016: PPUSH
80017: LD_VAR 0 6
80021: PPUSH
80022: LD_VAR 0 7
80026: PPUSH
80027: CALL 15314 0 3
80031: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80032: LD_ADDR_EXP 48
80036: PUSH
80037: LD_EXP 48
80041: PPUSH
80042: LD_VAR 0 3
80046: PPUSH
80047: LD_VAR 0 7
80051: PPUSH
80052: CALL_OW 1
80056: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80057: LD_VAR 0 1
80061: PUSH
80062: LD_EXP 43
80066: PUSH
80067: LD_VAR 0 3
80071: ARRAY
80072: IN
80073: IFFALSE 80112
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80075: LD_ADDR_EXP 43
80079: PUSH
80080: LD_EXP 43
80084: PPUSH
80085: LD_VAR 0 3
80089: PPUSH
80090: LD_EXP 43
80094: PUSH
80095: LD_VAR 0 3
80099: ARRAY
80100: PUSH
80101: LD_VAR 0 1
80105: DIFF
80106: PPUSH
80107: CALL_OW 1
80111: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80112: LD_VAR 0 1
80116: PUSH
80117: LD_EXP 50
80121: PUSH
80122: LD_VAR 0 3
80126: ARRAY
80127: IN
80128: IFFALSE 80167
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80130: LD_ADDR_EXP 50
80134: PUSH
80135: LD_EXP 50
80139: PPUSH
80140: LD_VAR 0 3
80144: PPUSH
80145: LD_EXP 50
80149: PUSH
80150: LD_VAR 0 3
80154: ARRAY
80155: PUSH
80156: LD_VAR 0 1
80160: DIFF
80161: PPUSH
80162: CALL_OW 1
80166: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80167: LD_VAR 0 1
80171: PUSH
80172: LD_EXP 62
80176: PUSH
80177: LD_VAR 0 3
80181: ARRAY
80182: IN
80183: IFFALSE 80222
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80185: LD_ADDR_EXP 62
80189: PUSH
80190: LD_EXP 62
80194: PPUSH
80195: LD_VAR 0 3
80199: PPUSH
80200: LD_EXP 62
80204: PUSH
80205: LD_VAR 0 3
80209: ARRAY
80210: PUSH
80211: LD_VAR 0 1
80215: DIFF
80216: PPUSH
80217: CALL_OW 1
80221: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80222: LD_VAR 0 1
80226: PUSH
80227: LD_EXP 65
80231: PUSH
80232: LD_VAR 0 3
80236: ARRAY
80237: IN
80238: IFFALSE 80277
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80240: LD_ADDR_EXP 65
80244: PUSH
80245: LD_EXP 65
80249: PPUSH
80250: LD_VAR 0 3
80254: PPUSH
80255: LD_EXP 65
80259: PUSH
80260: LD_VAR 0 3
80264: ARRAY
80265: PUSH
80266: LD_VAR 0 1
80270: DIFF
80271: PPUSH
80272: CALL_OW 1
80276: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80277: LD_VAR 0 1
80281: PUSH
80282: LD_EXP 52
80286: PUSH
80287: LD_VAR 0 3
80291: ARRAY
80292: IN
80293: IFFALSE 80332
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80295: LD_ADDR_EXP 52
80299: PUSH
80300: LD_EXP 52
80304: PPUSH
80305: LD_VAR 0 3
80309: PPUSH
80310: LD_EXP 52
80314: PUSH
80315: LD_VAR 0 3
80319: ARRAY
80320: PUSH
80321: LD_VAR 0 1
80325: DIFF
80326: PPUSH
80327: CALL_OW 1
80331: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80332: LD_VAR 0 1
80336: PUSH
80337: LD_EXP 51
80341: PUSH
80342: LD_VAR 0 3
80346: ARRAY
80347: IN
80348: IFFALSE 80387
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80350: LD_ADDR_EXP 51
80354: PUSH
80355: LD_EXP 51
80359: PPUSH
80360: LD_VAR 0 3
80364: PPUSH
80365: LD_EXP 51
80369: PUSH
80370: LD_VAR 0 3
80374: ARRAY
80375: PUSH
80376: LD_VAR 0 1
80380: DIFF
80381: PPUSH
80382: CALL_OW 1
80386: ST_TO_ADDR
// end ; break ;
80387: GO 80391
// end ;
80389: GO 79039
80391: POP
80392: POP
// end ;
80393: LD_VAR 0 2
80397: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80398: LD_INT 0
80400: PPUSH
80401: PPUSH
80402: PPUSH
// if not mc_bases or not skirmish then
80403: LD_EXP 43
80407: NOT
80408: PUSH
80409: LD_EXP 41
80413: NOT
80414: OR
80415: IFFALSE 80419
// exit ;
80417: GO 80634
// for i = 1 to mc_bases do
80419: LD_ADDR_VAR 0 3
80423: PUSH
80424: DOUBLE
80425: LD_INT 1
80427: DEC
80428: ST_TO_ADDR
80429: LD_EXP 43
80433: PUSH
80434: FOR_TO
80435: IFFALSE 80632
// begin if building in mc_construct_list [ i ] then
80437: LD_VAR 0 1
80441: PUSH
80442: LD_EXP 50
80446: PUSH
80447: LD_VAR 0 3
80451: ARRAY
80452: IN
80453: IFFALSE 80630
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80455: LD_ADDR_EXP 50
80459: PUSH
80460: LD_EXP 50
80464: PPUSH
80465: LD_VAR 0 3
80469: PPUSH
80470: LD_EXP 50
80474: PUSH
80475: LD_VAR 0 3
80479: ARRAY
80480: PUSH
80481: LD_VAR 0 1
80485: DIFF
80486: PPUSH
80487: CALL_OW 1
80491: ST_TO_ADDR
// if building in mc_lab [ i ] then
80492: LD_VAR 0 1
80496: PUSH
80497: LD_EXP 76
80501: PUSH
80502: LD_VAR 0 3
80506: ARRAY
80507: IN
80508: IFFALSE 80563
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80510: LD_ADDR_EXP 77
80514: PUSH
80515: LD_EXP 77
80519: PPUSH
80520: LD_VAR 0 3
80524: PPUSH
80525: LD_EXP 77
80529: PUSH
80530: LD_VAR 0 3
80534: ARRAY
80535: PPUSH
80536: LD_INT 1
80538: PPUSH
80539: LD_EXP 77
80543: PUSH
80544: LD_VAR 0 3
80548: ARRAY
80549: PPUSH
80550: LD_INT 0
80552: PPUSH
80553: CALL 14406 0 4
80557: PPUSH
80558: CALL_OW 1
80562: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80563: LD_VAR 0 1
80567: PUSH
80568: LD_EXP 43
80572: PUSH
80573: LD_VAR 0 3
80577: ARRAY
80578: IN
80579: NOT
80580: IFFALSE 80626
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80582: LD_ADDR_EXP 43
80586: PUSH
80587: LD_EXP 43
80591: PPUSH
80592: LD_VAR 0 3
80596: PUSH
80597: LD_EXP 43
80601: PUSH
80602: LD_VAR 0 3
80606: ARRAY
80607: PUSH
80608: LD_INT 1
80610: PLUS
80611: PUSH
80612: EMPTY
80613: LIST
80614: LIST
80615: PPUSH
80616: LD_VAR 0 1
80620: PPUSH
80621: CALL 14988 0 3
80625: ST_TO_ADDR
// exit ;
80626: POP
80627: POP
80628: GO 80634
// end ; end ;
80630: GO 80434
80632: POP
80633: POP
// end ;
80634: LD_VAR 0 2
80638: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80639: LD_INT 0
80641: PPUSH
80642: PPUSH
80643: PPUSH
80644: PPUSH
80645: PPUSH
80646: PPUSH
80647: PPUSH
// if not mc_bases or not skirmish then
80648: LD_EXP 43
80652: NOT
80653: PUSH
80654: LD_EXP 41
80658: NOT
80659: OR
80660: IFFALSE 80664
// exit ;
80662: GO 81325
// for i = 1 to mc_bases do
80664: LD_ADDR_VAR 0 3
80668: PUSH
80669: DOUBLE
80670: LD_INT 1
80672: DEC
80673: ST_TO_ADDR
80674: LD_EXP 43
80678: PUSH
80679: FOR_TO
80680: IFFALSE 81323
// begin if building in mc_construct_list [ i ] then
80682: LD_VAR 0 1
80686: PUSH
80687: LD_EXP 50
80691: PUSH
80692: LD_VAR 0 3
80696: ARRAY
80697: IN
80698: IFFALSE 81321
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80700: LD_ADDR_EXP 50
80704: PUSH
80705: LD_EXP 50
80709: PPUSH
80710: LD_VAR 0 3
80714: PPUSH
80715: LD_EXP 50
80719: PUSH
80720: LD_VAR 0 3
80724: ARRAY
80725: PUSH
80726: LD_VAR 0 1
80730: DIFF
80731: PPUSH
80732: CALL_OW 1
80736: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80737: LD_ADDR_EXP 43
80741: PUSH
80742: LD_EXP 43
80746: PPUSH
80747: LD_VAR 0 3
80751: PUSH
80752: LD_EXP 43
80756: PUSH
80757: LD_VAR 0 3
80761: ARRAY
80762: PUSH
80763: LD_INT 1
80765: PLUS
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PPUSH
80771: LD_VAR 0 1
80775: PPUSH
80776: CALL 14988 0 3
80780: ST_TO_ADDR
// btype := GetBType ( building ) ;
80781: LD_ADDR_VAR 0 5
80785: PUSH
80786: LD_VAR 0 1
80790: PPUSH
80791: CALL_OW 266
80795: ST_TO_ADDR
// side := GetSide ( building ) ;
80796: LD_ADDR_VAR 0 8
80800: PUSH
80801: LD_VAR 0 1
80805: PPUSH
80806: CALL_OW 255
80810: ST_TO_ADDR
// if btype = b_lab then
80811: LD_VAR 0 5
80815: PUSH
80816: LD_INT 6
80818: EQUAL
80819: IFFALSE 80869
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80821: LD_ADDR_EXP 76
80825: PUSH
80826: LD_EXP 76
80830: PPUSH
80831: LD_VAR 0 3
80835: PUSH
80836: LD_EXP 76
80840: PUSH
80841: LD_VAR 0 3
80845: ARRAY
80846: PUSH
80847: LD_INT 1
80849: PLUS
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PPUSH
80855: LD_VAR 0 1
80859: PPUSH
80860: CALL 14988 0 3
80864: ST_TO_ADDR
// exit ;
80865: POP
80866: POP
80867: GO 81325
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80869: LD_VAR 0 5
80873: PUSH
80874: LD_INT 0
80876: PUSH
80877: LD_INT 2
80879: PUSH
80880: LD_INT 4
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: LIST
80887: IN
80888: IFFALSE 81012
// begin if btype = b_armoury then
80890: LD_VAR 0 5
80894: PUSH
80895: LD_INT 4
80897: EQUAL
80898: IFFALSE 80908
// btype := b_barracks ;
80900: LD_ADDR_VAR 0 5
80904: PUSH
80905: LD_INT 5
80907: ST_TO_ADDR
// if btype = b_depot then
80908: LD_VAR 0 5
80912: PUSH
80913: LD_INT 0
80915: EQUAL
80916: IFFALSE 80926
// btype := b_warehouse ;
80918: LD_ADDR_VAR 0 5
80922: PUSH
80923: LD_INT 1
80925: ST_TO_ADDR
// if btype = b_workshop then
80926: LD_VAR 0 5
80930: PUSH
80931: LD_INT 2
80933: EQUAL
80934: IFFALSE 80944
// btype := b_factory ;
80936: LD_ADDR_VAR 0 5
80940: PUSH
80941: LD_INT 3
80943: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80944: LD_VAR 0 5
80948: PPUSH
80949: LD_VAR 0 8
80953: PPUSH
80954: CALL_OW 323
80958: PUSH
80959: LD_INT 1
80961: EQUAL
80962: IFFALSE 81008
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80964: LD_ADDR_EXP 75
80968: PUSH
80969: LD_EXP 75
80973: PPUSH
80974: LD_VAR 0 3
80978: PUSH
80979: LD_EXP 75
80983: PUSH
80984: LD_VAR 0 3
80988: ARRAY
80989: PUSH
80990: LD_INT 1
80992: PLUS
80993: PUSH
80994: EMPTY
80995: LIST
80996: LIST
80997: PPUSH
80998: LD_VAR 0 1
81002: PPUSH
81003: CALL 14988 0 3
81007: ST_TO_ADDR
// exit ;
81008: POP
81009: POP
81010: GO 81325
// end ; if btype in [ b_bunker , b_turret ] then
81012: LD_VAR 0 5
81016: PUSH
81017: LD_INT 32
81019: PUSH
81020: LD_INT 33
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: IN
81027: IFFALSE 81317
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81029: LD_ADDR_EXP 51
81033: PUSH
81034: LD_EXP 51
81038: PPUSH
81039: LD_VAR 0 3
81043: PUSH
81044: LD_EXP 51
81048: PUSH
81049: LD_VAR 0 3
81053: ARRAY
81054: PUSH
81055: LD_INT 1
81057: PLUS
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PPUSH
81063: LD_VAR 0 1
81067: PPUSH
81068: CALL 14988 0 3
81072: ST_TO_ADDR
// if btype = b_bunker then
81073: LD_VAR 0 5
81077: PUSH
81078: LD_INT 32
81080: EQUAL
81081: IFFALSE 81317
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81083: LD_ADDR_EXP 52
81087: PUSH
81088: LD_EXP 52
81092: PPUSH
81093: LD_VAR 0 3
81097: PUSH
81098: LD_EXP 52
81102: PUSH
81103: LD_VAR 0 3
81107: ARRAY
81108: PUSH
81109: LD_INT 1
81111: PLUS
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PPUSH
81117: LD_VAR 0 1
81121: PPUSH
81122: CALL 14988 0 3
81126: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81127: LD_ADDR_VAR 0 6
81131: PUSH
81132: LD_EXP 43
81136: PUSH
81137: LD_VAR 0 3
81141: ARRAY
81142: PPUSH
81143: LD_INT 25
81145: PUSH
81146: LD_INT 1
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 3
81155: PUSH
81156: LD_INT 54
81158: PUSH
81159: EMPTY
81160: LIST
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: PPUSH
81170: CALL_OW 72
81174: ST_TO_ADDR
// if tmp then
81175: LD_VAR 0 6
81179: IFFALSE 81185
// exit ;
81181: POP
81182: POP
81183: GO 81325
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81185: LD_ADDR_VAR 0 6
81189: PUSH
81190: LD_EXP 43
81194: PUSH
81195: LD_VAR 0 3
81199: ARRAY
81200: PPUSH
81201: LD_INT 2
81203: PUSH
81204: LD_INT 30
81206: PUSH
81207: LD_INT 4
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 30
81216: PUSH
81217: LD_INT 5
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: LIST
81228: PPUSH
81229: CALL_OW 72
81233: ST_TO_ADDR
// if not tmp then
81234: LD_VAR 0 6
81238: NOT
81239: IFFALSE 81245
// exit ;
81241: POP
81242: POP
81243: GO 81325
// for j in tmp do
81245: LD_ADDR_VAR 0 4
81249: PUSH
81250: LD_VAR 0 6
81254: PUSH
81255: FOR_IN
81256: IFFALSE 81315
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81258: LD_ADDR_VAR 0 7
81262: PUSH
81263: LD_VAR 0 4
81267: PPUSH
81268: CALL_OW 313
81272: PPUSH
81273: LD_INT 25
81275: PUSH
81276: LD_INT 1
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PPUSH
81283: CALL_OW 72
81287: ST_TO_ADDR
// if units then
81288: LD_VAR 0 7
81292: IFFALSE 81313
// begin ComExitBuilding ( units [ 1 ] ) ;
81294: LD_VAR 0 7
81298: PUSH
81299: LD_INT 1
81301: ARRAY
81302: PPUSH
81303: CALL_OW 122
// exit ;
81307: POP
81308: POP
81309: POP
81310: POP
81311: GO 81325
// end ; end ;
81313: GO 81255
81315: POP
81316: POP
// end ; end ; exit ;
81317: POP
81318: POP
81319: GO 81325
// end ; end ;
81321: GO 80679
81323: POP
81324: POP
// end ;
81325: LD_VAR 0 2
81329: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81330: LD_INT 0
81332: PPUSH
81333: PPUSH
81334: PPUSH
81335: PPUSH
81336: PPUSH
81337: PPUSH
81338: PPUSH
// if not mc_bases or not skirmish then
81339: LD_EXP 43
81343: NOT
81344: PUSH
81345: LD_EXP 41
81349: NOT
81350: OR
81351: IFFALSE 81355
// exit ;
81353: GO 81620
// btype := GetBType ( building ) ;
81355: LD_ADDR_VAR 0 6
81359: PUSH
81360: LD_VAR 0 1
81364: PPUSH
81365: CALL_OW 266
81369: ST_TO_ADDR
// x := GetX ( building ) ;
81370: LD_ADDR_VAR 0 7
81374: PUSH
81375: LD_VAR 0 1
81379: PPUSH
81380: CALL_OW 250
81384: ST_TO_ADDR
// y := GetY ( building ) ;
81385: LD_ADDR_VAR 0 8
81389: PUSH
81390: LD_VAR 0 1
81394: PPUSH
81395: CALL_OW 251
81399: ST_TO_ADDR
// d := GetDir ( building ) ;
81400: LD_ADDR_VAR 0 9
81404: PUSH
81405: LD_VAR 0 1
81409: PPUSH
81410: CALL_OW 254
81414: ST_TO_ADDR
// for i = 1 to mc_bases do
81415: LD_ADDR_VAR 0 4
81419: PUSH
81420: DOUBLE
81421: LD_INT 1
81423: DEC
81424: ST_TO_ADDR
81425: LD_EXP 43
81429: PUSH
81430: FOR_TO
81431: IFFALSE 81618
// begin if not mc_build_list [ i ] then
81433: LD_EXP 48
81437: PUSH
81438: LD_VAR 0 4
81442: ARRAY
81443: NOT
81444: IFFALSE 81448
// continue ;
81446: GO 81430
// for j := 1 to mc_build_list [ i ] do
81448: LD_ADDR_VAR 0 5
81452: PUSH
81453: DOUBLE
81454: LD_INT 1
81456: DEC
81457: ST_TO_ADDR
81458: LD_EXP 48
81462: PUSH
81463: LD_VAR 0 4
81467: ARRAY
81468: PUSH
81469: FOR_TO
81470: IFFALSE 81614
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81472: LD_VAR 0 6
81476: PUSH
81477: LD_VAR 0 7
81481: PUSH
81482: LD_VAR 0 8
81486: PUSH
81487: LD_VAR 0 9
81491: PUSH
81492: EMPTY
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: PPUSH
81498: LD_EXP 48
81502: PUSH
81503: LD_VAR 0 4
81507: ARRAY
81508: PUSH
81509: LD_VAR 0 5
81513: ARRAY
81514: PPUSH
81515: CALL 21168 0 2
81519: IFFALSE 81612
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81521: LD_ADDR_EXP 48
81525: PUSH
81526: LD_EXP 48
81530: PPUSH
81531: LD_VAR 0 4
81535: PPUSH
81536: LD_EXP 48
81540: PUSH
81541: LD_VAR 0 4
81545: ARRAY
81546: PPUSH
81547: LD_VAR 0 5
81551: PPUSH
81552: CALL_OW 3
81556: PPUSH
81557: CALL_OW 1
81561: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81562: LD_ADDR_EXP 50
81566: PUSH
81567: LD_EXP 50
81571: PPUSH
81572: LD_VAR 0 4
81576: PUSH
81577: LD_EXP 50
81581: PUSH
81582: LD_VAR 0 4
81586: ARRAY
81587: PUSH
81588: LD_INT 1
81590: PLUS
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PPUSH
81596: LD_VAR 0 1
81600: PPUSH
81601: CALL 14988 0 3
81605: ST_TO_ADDR
// exit ;
81606: POP
81607: POP
81608: POP
81609: POP
81610: GO 81620
// end ;
81612: GO 81469
81614: POP
81615: POP
// end ;
81616: GO 81430
81618: POP
81619: POP
// end ;
81620: LD_VAR 0 3
81624: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81625: LD_INT 0
81627: PPUSH
81628: PPUSH
81629: PPUSH
// if not mc_bases or not skirmish then
81630: LD_EXP 43
81634: NOT
81635: PUSH
81636: LD_EXP 41
81640: NOT
81641: OR
81642: IFFALSE 81646
// exit ;
81644: GO 81836
// for i = 1 to mc_bases do
81646: LD_ADDR_VAR 0 4
81650: PUSH
81651: DOUBLE
81652: LD_INT 1
81654: DEC
81655: ST_TO_ADDR
81656: LD_EXP 43
81660: PUSH
81661: FOR_TO
81662: IFFALSE 81749
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81664: LD_VAR 0 1
81668: PUSH
81669: LD_EXP 51
81673: PUSH
81674: LD_VAR 0 4
81678: ARRAY
81679: IN
81680: PUSH
81681: LD_VAR 0 1
81685: PUSH
81686: LD_EXP 52
81690: PUSH
81691: LD_VAR 0 4
81695: ARRAY
81696: IN
81697: NOT
81698: AND
81699: IFFALSE 81747
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81701: LD_ADDR_EXP 52
81705: PUSH
81706: LD_EXP 52
81710: PPUSH
81711: LD_VAR 0 4
81715: PUSH
81716: LD_EXP 52
81720: PUSH
81721: LD_VAR 0 4
81725: ARRAY
81726: PUSH
81727: LD_INT 1
81729: PLUS
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PPUSH
81735: LD_VAR 0 1
81739: PPUSH
81740: CALL 14988 0 3
81744: ST_TO_ADDR
// break ;
81745: GO 81749
// end ; end ;
81747: GO 81661
81749: POP
81750: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81751: LD_VAR 0 1
81755: PPUSH
81756: CALL_OW 257
81760: PUSH
81761: LD_EXP 69
81765: IN
81766: PUSH
81767: LD_VAR 0 1
81771: PPUSH
81772: CALL_OW 266
81776: PUSH
81777: LD_INT 5
81779: EQUAL
81780: AND
81781: PUSH
81782: LD_VAR 0 2
81786: PPUSH
81787: CALL_OW 110
81791: PUSH
81792: LD_INT 18
81794: NONEQUAL
81795: AND
81796: IFFALSE 81836
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81798: LD_VAR 0 2
81802: PPUSH
81803: CALL_OW 257
81807: PUSH
81808: LD_INT 5
81810: PUSH
81811: LD_INT 8
81813: PUSH
81814: LD_INT 9
81816: PUSH
81817: EMPTY
81818: LIST
81819: LIST
81820: LIST
81821: IN
81822: IFFALSE 81836
// SetClass ( unit , 1 ) ;
81824: LD_VAR 0 2
81828: PPUSH
81829: LD_INT 1
81831: PPUSH
81832: CALL_OW 336
// end ;
81836: LD_VAR 0 3
81840: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81841: LD_INT 0
81843: PPUSH
81844: PPUSH
// if not mc_bases or not skirmish then
81845: LD_EXP 43
81849: NOT
81850: PUSH
81851: LD_EXP 41
81855: NOT
81856: OR
81857: IFFALSE 81861
// exit ;
81859: GO 81977
// if GetLives ( abandoned_vehicle ) > 250 then
81861: LD_VAR 0 2
81865: PPUSH
81866: CALL_OW 256
81870: PUSH
81871: LD_INT 250
81873: GREATER
81874: IFFALSE 81878
// exit ;
81876: GO 81977
// for i = 1 to mc_bases do
81878: LD_ADDR_VAR 0 6
81882: PUSH
81883: DOUBLE
81884: LD_INT 1
81886: DEC
81887: ST_TO_ADDR
81888: LD_EXP 43
81892: PUSH
81893: FOR_TO
81894: IFFALSE 81975
// begin if driver in mc_bases [ i ] then
81896: LD_VAR 0 1
81900: PUSH
81901: LD_EXP 43
81905: PUSH
81906: LD_VAR 0 6
81910: ARRAY
81911: IN
81912: IFFALSE 81973
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81914: LD_VAR 0 1
81918: PPUSH
81919: LD_EXP 43
81923: PUSH
81924: LD_VAR 0 6
81928: ARRAY
81929: PPUSH
81930: LD_INT 2
81932: PUSH
81933: LD_INT 30
81935: PUSH
81936: LD_INT 0
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 30
81945: PUSH
81946: LD_INT 1
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: LIST
81957: PPUSH
81958: CALL_OW 72
81962: PUSH
81963: LD_INT 1
81965: ARRAY
81966: PPUSH
81967: CALL 48196 0 2
// break ;
81971: GO 81975
// end ; end ;
81973: GO 81893
81975: POP
81976: POP
// end ; end_of_file
81977: LD_VAR 0 5
81981: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81982: LD_INT 0
81984: PPUSH
81985: PPUSH
81986: PPUSH
81987: PPUSH
81988: PPUSH
81989: PPUSH
81990: PPUSH
81991: PPUSH
81992: PPUSH
81993: PPUSH
81994: PPUSH
81995: PPUSH
81996: PPUSH
81997: PPUSH
81998: PPUSH
81999: PPUSH
82000: PPUSH
82001: PPUSH
82002: PPUSH
82003: PPUSH
82004: PPUSH
82005: PPUSH
82006: PPUSH
82007: PPUSH
82008: PPUSH
82009: PPUSH
82010: PPUSH
82011: PPUSH
82012: PPUSH
82013: PPUSH
82014: PPUSH
82015: PPUSH
82016: PPUSH
82017: PPUSH
// if not list then
82018: LD_VAR 0 1
82022: NOT
82023: IFFALSE 82027
// exit ;
82025: GO 86686
// base := list [ 1 ] ;
82027: LD_ADDR_VAR 0 3
82031: PUSH
82032: LD_VAR 0 1
82036: PUSH
82037: LD_INT 1
82039: ARRAY
82040: ST_TO_ADDR
// group := list [ 2 ] ;
82041: LD_ADDR_VAR 0 4
82045: PUSH
82046: LD_VAR 0 1
82050: PUSH
82051: LD_INT 2
82053: ARRAY
82054: ST_TO_ADDR
// path := list [ 3 ] ;
82055: LD_ADDR_VAR 0 5
82059: PUSH
82060: LD_VAR 0 1
82064: PUSH
82065: LD_INT 3
82067: ARRAY
82068: ST_TO_ADDR
// flags := list [ 4 ] ;
82069: LD_ADDR_VAR 0 6
82073: PUSH
82074: LD_VAR 0 1
82078: PUSH
82079: LD_INT 4
82081: ARRAY
82082: ST_TO_ADDR
// mined := [ ] ;
82083: LD_ADDR_VAR 0 27
82087: PUSH
82088: EMPTY
82089: ST_TO_ADDR
// bombed := [ ] ;
82090: LD_ADDR_VAR 0 28
82094: PUSH
82095: EMPTY
82096: ST_TO_ADDR
// healers := [ ] ;
82097: LD_ADDR_VAR 0 31
82101: PUSH
82102: EMPTY
82103: ST_TO_ADDR
// to_heal := [ ] ;
82104: LD_ADDR_VAR 0 30
82108: PUSH
82109: EMPTY
82110: ST_TO_ADDR
// repairs := [ ] ;
82111: LD_ADDR_VAR 0 33
82115: PUSH
82116: EMPTY
82117: ST_TO_ADDR
// to_repair := [ ] ;
82118: LD_ADDR_VAR 0 32
82122: PUSH
82123: EMPTY
82124: ST_TO_ADDR
// if not group or not path then
82125: LD_VAR 0 4
82129: NOT
82130: PUSH
82131: LD_VAR 0 5
82135: NOT
82136: OR
82137: IFFALSE 82141
// exit ;
82139: GO 86686
// side := GetSide ( group [ 1 ] ) ;
82141: LD_ADDR_VAR 0 35
82145: PUSH
82146: LD_VAR 0 4
82150: PUSH
82151: LD_INT 1
82153: ARRAY
82154: PPUSH
82155: CALL_OW 255
82159: ST_TO_ADDR
// if flags then
82160: LD_VAR 0 6
82164: IFFALSE 82308
// begin f_ignore_area := flags [ 1 ] ;
82166: LD_ADDR_VAR 0 17
82170: PUSH
82171: LD_VAR 0 6
82175: PUSH
82176: LD_INT 1
82178: ARRAY
82179: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82180: LD_ADDR_VAR 0 18
82184: PUSH
82185: LD_VAR 0 6
82189: PUSH
82190: LD_INT 2
82192: ARRAY
82193: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82194: LD_ADDR_VAR 0 19
82198: PUSH
82199: LD_VAR 0 6
82203: PUSH
82204: LD_INT 3
82206: ARRAY
82207: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82208: LD_ADDR_VAR 0 20
82212: PUSH
82213: LD_VAR 0 6
82217: PUSH
82218: LD_INT 4
82220: ARRAY
82221: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82222: LD_ADDR_VAR 0 21
82226: PUSH
82227: LD_VAR 0 6
82231: PUSH
82232: LD_INT 5
82234: ARRAY
82235: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82236: LD_ADDR_VAR 0 22
82240: PUSH
82241: LD_VAR 0 6
82245: PUSH
82246: LD_INT 6
82248: ARRAY
82249: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82250: LD_ADDR_VAR 0 23
82254: PUSH
82255: LD_VAR 0 6
82259: PUSH
82260: LD_INT 7
82262: ARRAY
82263: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82264: LD_ADDR_VAR 0 24
82268: PUSH
82269: LD_VAR 0 6
82273: PUSH
82274: LD_INT 8
82276: ARRAY
82277: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82278: LD_ADDR_VAR 0 25
82282: PUSH
82283: LD_VAR 0 6
82287: PUSH
82288: LD_INT 9
82290: ARRAY
82291: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82292: LD_ADDR_VAR 0 26
82296: PUSH
82297: LD_VAR 0 6
82301: PUSH
82302: LD_INT 10
82304: ARRAY
82305: ST_TO_ADDR
// end else
82306: GO 82388
// begin f_ignore_area := false ;
82308: LD_ADDR_VAR 0 17
82312: PUSH
82313: LD_INT 0
82315: ST_TO_ADDR
// f_capture := false ;
82316: LD_ADDR_VAR 0 18
82320: PUSH
82321: LD_INT 0
82323: ST_TO_ADDR
// f_ignore_civ := false ;
82324: LD_ADDR_VAR 0 19
82328: PUSH
82329: LD_INT 0
82331: ST_TO_ADDR
// f_murder := false ;
82332: LD_ADDR_VAR 0 20
82336: PUSH
82337: LD_INT 0
82339: ST_TO_ADDR
// f_mines := false ;
82340: LD_ADDR_VAR 0 21
82344: PUSH
82345: LD_INT 0
82347: ST_TO_ADDR
// f_repair := false ;
82348: LD_ADDR_VAR 0 22
82352: PUSH
82353: LD_INT 0
82355: ST_TO_ADDR
// f_heal := false ;
82356: LD_ADDR_VAR 0 23
82360: PUSH
82361: LD_INT 0
82363: ST_TO_ADDR
// f_spacetime := false ;
82364: LD_ADDR_VAR 0 24
82368: PUSH
82369: LD_INT 0
82371: ST_TO_ADDR
// f_attack_depot := false ;
82372: LD_ADDR_VAR 0 25
82376: PUSH
82377: LD_INT 0
82379: ST_TO_ADDR
// f_crawl := false ;
82380: LD_ADDR_VAR 0 26
82384: PUSH
82385: LD_INT 0
82387: ST_TO_ADDR
// end ; if f_heal then
82388: LD_VAR 0 23
82392: IFFALSE 82419
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82394: LD_ADDR_VAR 0 31
82398: PUSH
82399: LD_VAR 0 4
82403: PPUSH
82404: LD_INT 25
82406: PUSH
82407: LD_INT 4
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PPUSH
82414: CALL_OW 72
82418: ST_TO_ADDR
// if f_repair then
82419: LD_VAR 0 22
82423: IFFALSE 82450
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82425: LD_ADDR_VAR 0 33
82429: PUSH
82430: LD_VAR 0 4
82434: PPUSH
82435: LD_INT 25
82437: PUSH
82438: LD_INT 3
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PPUSH
82445: CALL_OW 72
82449: ST_TO_ADDR
// units_path := [ ] ;
82450: LD_ADDR_VAR 0 16
82454: PUSH
82455: EMPTY
82456: ST_TO_ADDR
// for i = 1 to group do
82457: LD_ADDR_VAR 0 7
82461: PUSH
82462: DOUBLE
82463: LD_INT 1
82465: DEC
82466: ST_TO_ADDR
82467: LD_VAR 0 4
82471: PUSH
82472: FOR_TO
82473: IFFALSE 82502
// units_path := Replace ( units_path , i , path ) ;
82475: LD_ADDR_VAR 0 16
82479: PUSH
82480: LD_VAR 0 16
82484: PPUSH
82485: LD_VAR 0 7
82489: PPUSH
82490: LD_VAR 0 5
82494: PPUSH
82495: CALL_OW 1
82499: ST_TO_ADDR
82500: GO 82472
82502: POP
82503: POP
// repeat for i = group downto 1 do
82504: LD_ADDR_VAR 0 7
82508: PUSH
82509: DOUBLE
82510: LD_VAR 0 4
82514: INC
82515: ST_TO_ADDR
82516: LD_INT 1
82518: PUSH
82519: FOR_DOWNTO
82520: IFFALSE 86642
// begin wait ( 5 ) ;
82522: LD_INT 5
82524: PPUSH
82525: CALL_OW 67
// tmp := [ ] ;
82529: LD_ADDR_VAR 0 14
82533: PUSH
82534: EMPTY
82535: ST_TO_ADDR
// attacking := false ;
82536: LD_ADDR_VAR 0 29
82540: PUSH
82541: LD_INT 0
82543: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82544: LD_VAR 0 4
82548: PUSH
82549: LD_VAR 0 7
82553: ARRAY
82554: PPUSH
82555: CALL_OW 301
82559: PUSH
82560: LD_VAR 0 4
82564: PUSH
82565: LD_VAR 0 7
82569: ARRAY
82570: NOT
82571: OR
82572: IFFALSE 82681
// begin if GetType ( group [ i ] ) = unit_human then
82574: LD_VAR 0 4
82578: PUSH
82579: LD_VAR 0 7
82583: ARRAY
82584: PPUSH
82585: CALL_OW 247
82589: PUSH
82590: LD_INT 1
82592: EQUAL
82593: IFFALSE 82639
// begin to_heal := to_heal diff group [ i ] ;
82595: LD_ADDR_VAR 0 30
82599: PUSH
82600: LD_VAR 0 30
82604: PUSH
82605: LD_VAR 0 4
82609: PUSH
82610: LD_VAR 0 7
82614: ARRAY
82615: DIFF
82616: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82617: LD_ADDR_VAR 0 31
82621: PUSH
82622: LD_VAR 0 31
82626: PUSH
82627: LD_VAR 0 4
82631: PUSH
82632: LD_VAR 0 7
82636: ARRAY
82637: DIFF
82638: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82639: LD_ADDR_VAR 0 4
82643: PUSH
82644: LD_VAR 0 4
82648: PPUSH
82649: LD_VAR 0 7
82653: PPUSH
82654: CALL_OW 3
82658: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82659: LD_ADDR_VAR 0 16
82663: PUSH
82664: LD_VAR 0 16
82668: PPUSH
82669: LD_VAR 0 7
82673: PPUSH
82674: CALL_OW 3
82678: ST_TO_ADDR
// continue ;
82679: GO 82519
// end ; if f_repair then
82681: LD_VAR 0 22
82685: IFFALSE 83174
// begin if GetType ( group [ i ] ) = unit_vehicle then
82687: LD_VAR 0 4
82691: PUSH
82692: LD_VAR 0 7
82696: ARRAY
82697: PPUSH
82698: CALL_OW 247
82702: PUSH
82703: LD_INT 2
82705: EQUAL
82706: IFFALSE 82896
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82708: LD_VAR 0 4
82712: PUSH
82713: LD_VAR 0 7
82717: ARRAY
82718: PPUSH
82719: CALL_OW 256
82723: PUSH
82724: LD_INT 700
82726: LESS
82727: PUSH
82728: LD_VAR 0 4
82732: PUSH
82733: LD_VAR 0 7
82737: ARRAY
82738: PUSH
82739: LD_VAR 0 32
82743: IN
82744: NOT
82745: AND
82746: IFFALSE 82770
// to_repair := to_repair union group [ i ] ;
82748: LD_ADDR_VAR 0 32
82752: PUSH
82753: LD_VAR 0 32
82757: PUSH
82758: LD_VAR 0 4
82762: PUSH
82763: LD_VAR 0 7
82767: ARRAY
82768: UNION
82769: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82770: LD_VAR 0 4
82774: PUSH
82775: LD_VAR 0 7
82779: ARRAY
82780: PPUSH
82781: CALL_OW 256
82785: PUSH
82786: LD_INT 1000
82788: EQUAL
82789: PUSH
82790: LD_VAR 0 4
82794: PUSH
82795: LD_VAR 0 7
82799: ARRAY
82800: PUSH
82801: LD_VAR 0 32
82805: IN
82806: AND
82807: IFFALSE 82831
// to_repair := to_repair diff group [ i ] ;
82809: LD_ADDR_VAR 0 32
82813: PUSH
82814: LD_VAR 0 32
82818: PUSH
82819: LD_VAR 0 4
82823: PUSH
82824: LD_VAR 0 7
82828: ARRAY
82829: DIFF
82830: ST_TO_ADDR
// if group [ i ] in to_repair then
82831: LD_VAR 0 4
82835: PUSH
82836: LD_VAR 0 7
82840: ARRAY
82841: PUSH
82842: LD_VAR 0 32
82846: IN
82847: IFFALSE 82894
// begin if not IsInArea ( group [ i ] , f_repair ) then
82849: LD_VAR 0 4
82853: PUSH
82854: LD_VAR 0 7
82858: ARRAY
82859: PPUSH
82860: LD_VAR 0 22
82864: PPUSH
82865: CALL_OW 308
82869: NOT
82870: IFFALSE 82892
// ComMoveToArea ( group [ i ] , f_repair ) ;
82872: LD_VAR 0 4
82876: PUSH
82877: LD_VAR 0 7
82881: ARRAY
82882: PPUSH
82883: LD_VAR 0 22
82887: PPUSH
82888: CALL_OW 113
// continue ;
82892: GO 82519
// end ; end else
82894: GO 83174
// if group [ i ] in repairs then
82896: LD_VAR 0 4
82900: PUSH
82901: LD_VAR 0 7
82905: ARRAY
82906: PUSH
82907: LD_VAR 0 33
82911: IN
82912: IFFALSE 83174
// begin if IsInUnit ( group [ i ] ) then
82914: LD_VAR 0 4
82918: PUSH
82919: LD_VAR 0 7
82923: ARRAY
82924: PPUSH
82925: CALL_OW 310
82929: IFFALSE 82997
// begin z := IsInUnit ( group [ i ] ) ;
82931: LD_ADDR_VAR 0 13
82935: PUSH
82936: LD_VAR 0 4
82940: PUSH
82941: LD_VAR 0 7
82945: ARRAY
82946: PPUSH
82947: CALL_OW 310
82951: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82952: LD_VAR 0 13
82956: PUSH
82957: LD_VAR 0 32
82961: IN
82962: PUSH
82963: LD_VAR 0 13
82967: PPUSH
82968: LD_VAR 0 22
82972: PPUSH
82973: CALL_OW 308
82977: AND
82978: IFFALSE 82995
// ComExitVehicle ( group [ i ] ) ;
82980: LD_VAR 0 4
82984: PUSH
82985: LD_VAR 0 7
82989: ARRAY
82990: PPUSH
82991: CALL_OW 121
// end else
82995: GO 83174
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82997: LD_ADDR_VAR 0 13
83001: PUSH
83002: LD_VAR 0 4
83006: PPUSH
83007: LD_INT 95
83009: PUSH
83010: LD_VAR 0 22
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 58
83021: PUSH
83022: EMPTY
83023: LIST
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PPUSH
83029: CALL_OW 72
83033: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
83034: LD_VAR 0 4
83038: PUSH
83039: LD_VAR 0 7
83043: ARRAY
83044: PPUSH
83045: CALL_OW 314
83049: NOT
83050: IFFALSE 83172
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83052: LD_ADDR_VAR 0 10
83056: PUSH
83057: LD_VAR 0 13
83061: PPUSH
83062: LD_VAR 0 4
83066: PUSH
83067: LD_VAR 0 7
83071: ARRAY
83072: PPUSH
83073: CALL_OW 74
83077: ST_TO_ADDR
// if not x then
83078: LD_VAR 0 10
83082: NOT
83083: IFFALSE 83087
// continue ;
83085: GO 82519
// if GetLives ( x ) < 1000 then
83087: LD_VAR 0 10
83091: PPUSH
83092: CALL_OW 256
83096: PUSH
83097: LD_INT 1000
83099: LESS
83100: IFFALSE 83124
// ComRepairVehicle ( group [ i ] , x ) else
83102: LD_VAR 0 4
83106: PUSH
83107: LD_VAR 0 7
83111: ARRAY
83112: PPUSH
83113: LD_VAR 0 10
83117: PPUSH
83118: CALL_OW 129
83122: GO 83172
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83124: LD_VAR 0 23
83128: PUSH
83129: LD_VAR 0 4
83133: PUSH
83134: LD_VAR 0 7
83138: ARRAY
83139: PPUSH
83140: CALL_OW 256
83144: PUSH
83145: LD_INT 1000
83147: LESS
83148: AND
83149: NOT
83150: IFFALSE 83172
// ComEnterUnit ( group [ i ] , x ) ;
83152: LD_VAR 0 4
83156: PUSH
83157: LD_VAR 0 7
83161: ARRAY
83162: PPUSH
83163: LD_VAR 0 10
83167: PPUSH
83168: CALL_OW 120
// end ; continue ;
83172: GO 82519
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83174: LD_VAR 0 23
83178: PUSH
83179: LD_VAR 0 4
83183: PUSH
83184: LD_VAR 0 7
83188: ARRAY
83189: PPUSH
83190: CALL_OW 247
83194: PUSH
83195: LD_INT 1
83197: EQUAL
83198: AND
83199: IFFALSE 83677
// begin if group [ i ] in healers then
83201: LD_VAR 0 4
83205: PUSH
83206: LD_VAR 0 7
83210: ARRAY
83211: PUSH
83212: LD_VAR 0 31
83216: IN
83217: IFFALSE 83490
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83219: LD_VAR 0 4
83223: PUSH
83224: LD_VAR 0 7
83228: ARRAY
83229: PPUSH
83230: LD_VAR 0 23
83234: PPUSH
83235: CALL_OW 308
83239: NOT
83240: PUSH
83241: LD_VAR 0 4
83245: PUSH
83246: LD_VAR 0 7
83250: ARRAY
83251: PPUSH
83252: CALL_OW 314
83256: NOT
83257: AND
83258: IFFALSE 83282
// ComMoveToArea ( group [ i ] , f_heal ) else
83260: LD_VAR 0 4
83264: PUSH
83265: LD_VAR 0 7
83269: ARRAY
83270: PPUSH
83271: LD_VAR 0 23
83275: PPUSH
83276: CALL_OW 113
83280: GO 83488
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83282: LD_VAR 0 4
83286: PUSH
83287: LD_VAR 0 7
83291: ARRAY
83292: PPUSH
83293: CALL 44711 0 1
83297: PPUSH
83298: CALL_OW 256
83302: PUSH
83303: LD_INT 1000
83305: EQUAL
83306: IFFALSE 83325
// ComStop ( group [ i ] ) else
83308: LD_VAR 0 4
83312: PUSH
83313: LD_VAR 0 7
83317: ARRAY
83318: PPUSH
83319: CALL_OW 141
83323: GO 83488
// if not HasTask ( group [ i ] ) and to_heal then
83325: LD_VAR 0 4
83329: PUSH
83330: LD_VAR 0 7
83334: ARRAY
83335: PPUSH
83336: CALL_OW 314
83340: NOT
83341: PUSH
83342: LD_VAR 0 30
83346: AND
83347: IFFALSE 83488
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83349: LD_ADDR_VAR 0 13
83353: PUSH
83354: LD_VAR 0 30
83358: PPUSH
83359: LD_INT 3
83361: PUSH
83362: LD_INT 54
83364: PUSH
83365: EMPTY
83366: LIST
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PPUSH
83372: CALL_OW 72
83376: PPUSH
83377: LD_VAR 0 4
83381: PUSH
83382: LD_VAR 0 7
83386: ARRAY
83387: PPUSH
83388: CALL_OW 74
83392: ST_TO_ADDR
// if z then
83393: LD_VAR 0 13
83397: IFFALSE 83488
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83399: LD_INT 91
83401: PUSH
83402: LD_VAR 0 13
83406: PUSH
83407: LD_INT 10
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: LIST
83414: PUSH
83415: LD_INT 81
83417: PUSH
83418: LD_VAR 0 13
83422: PPUSH
83423: CALL_OW 255
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PPUSH
83436: CALL_OW 69
83440: PUSH
83441: LD_INT 0
83443: EQUAL
83444: IFFALSE 83468
// ComHeal ( group [ i ] , z ) else
83446: LD_VAR 0 4
83450: PUSH
83451: LD_VAR 0 7
83455: ARRAY
83456: PPUSH
83457: LD_VAR 0 13
83461: PPUSH
83462: CALL_OW 128
83466: GO 83488
// ComMoveToArea ( group [ i ] , f_heal ) ;
83468: LD_VAR 0 4
83472: PUSH
83473: LD_VAR 0 7
83477: ARRAY
83478: PPUSH
83479: LD_VAR 0 23
83483: PPUSH
83484: CALL_OW 113
// end ; continue ;
83488: GO 82519
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83490: LD_VAR 0 4
83494: PUSH
83495: LD_VAR 0 7
83499: ARRAY
83500: PPUSH
83501: CALL_OW 256
83505: PUSH
83506: LD_INT 700
83508: LESS
83509: PUSH
83510: LD_VAR 0 4
83514: PUSH
83515: LD_VAR 0 7
83519: ARRAY
83520: PUSH
83521: LD_VAR 0 30
83525: IN
83526: NOT
83527: AND
83528: IFFALSE 83552
// to_heal := to_heal union group [ i ] ;
83530: LD_ADDR_VAR 0 30
83534: PUSH
83535: LD_VAR 0 30
83539: PUSH
83540: LD_VAR 0 4
83544: PUSH
83545: LD_VAR 0 7
83549: ARRAY
83550: UNION
83551: ST_TO_ADDR
// if group [ i ] in to_heal then
83552: LD_VAR 0 4
83556: PUSH
83557: LD_VAR 0 7
83561: ARRAY
83562: PUSH
83563: LD_VAR 0 30
83567: IN
83568: IFFALSE 83677
// begin if GetLives ( group [ i ] ) = 1000 then
83570: LD_VAR 0 4
83574: PUSH
83575: LD_VAR 0 7
83579: ARRAY
83580: PPUSH
83581: CALL_OW 256
83585: PUSH
83586: LD_INT 1000
83588: EQUAL
83589: IFFALSE 83615
// to_heal := to_heal diff group [ i ] else
83591: LD_ADDR_VAR 0 30
83595: PUSH
83596: LD_VAR 0 30
83600: PUSH
83601: LD_VAR 0 4
83605: PUSH
83606: LD_VAR 0 7
83610: ARRAY
83611: DIFF
83612: ST_TO_ADDR
83613: GO 83677
// begin if not IsInArea ( group [ i ] , to_heal ) then
83615: LD_VAR 0 4
83619: PUSH
83620: LD_VAR 0 7
83624: ARRAY
83625: PPUSH
83626: LD_VAR 0 30
83630: PPUSH
83631: CALL_OW 308
83635: NOT
83636: IFFALSE 83660
// ComMoveToArea ( group [ i ] , f_heal ) else
83638: LD_VAR 0 4
83642: PUSH
83643: LD_VAR 0 7
83647: ARRAY
83648: PPUSH
83649: LD_VAR 0 23
83653: PPUSH
83654: CALL_OW 113
83658: GO 83675
// ComHold ( group [ i ] ) ;
83660: LD_VAR 0 4
83664: PUSH
83665: LD_VAR 0 7
83669: ARRAY
83670: PPUSH
83671: CALL_OW 140
// continue ;
83675: GO 82519
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83677: LD_VAR 0 4
83681: PUSH
83682: LD_VAR 0 7
83686: ARRAY
83687: PPUSH
83688: LD_INT 10
83690: PPUSH
83691: CALL 42482 0 2
83695: NOT
83696: PUSH
83697: LD_VAR 0 16
83701: PUSH
83702: LD_VAR 0 7
83706: ARRAY
83707: PUSH
83708: EMPTY
83709: EQUAL
83710: NOT
83711: AND
83712: IFFALSE 83978
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83714: LD_VAR 0 4
83718: PUSH
83719: LD_VAR 0 7
83723: ARRAY
83724: PPUSH
83725: CALL_OW 262
83729: PUSH
83730: LD_INT 1
83732: PUSH
83733: LD_INT 2
83735: PUSH
83736: EMPTY
83737: LIST
83738: LIST
83739: IN
83740: IFFALSE 83781
// if GetFuel ( group [ i ] ) < 10 then
83742: LD_VAR 0 4
83746: PUSH
83747: LD_VAR 0 7
83751: ARRAY
83752: PPUSH
83753: CALL_OW 261
83757: PUSH
83758: LD_INT 10
83760: LESS
83761: IFFALSE 83781
// SetFuel ( group [ i ] , 12 ) ;
83763: LD_VAR 0 4
83767: PUSH
83768: LD_VAR 0 7
83772: ARRAY
83773: PPUSH
83774: LD_INT 12
83776: PPUSH
83777: CALL_OW 240
// if units_path [ i ] then
83781: LD_VAR 0 16
83785: PUSH
83786: LD_VAR 0 7
83790: ARRAY
83791: IFFALSE 83976
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83793: LD_VAR 0 4
83797: PUSH
83798: LD_VAR 0 7
83802: ARRAY
83803: PPUSH
83804: LD_VAR 0 16
83808: PUSH
83809: LD_VAR 0 7
83813: ARRAY
83814: PUSH
83815: LD_INT 1
83817: ARRAY
83818: PUSH
83819: LD_INT 1
83821: ARRAY
83822: PPUSH
83823: LD_VAR 0 16
83827: PUSH
83828: LD_VAR 0 7
83832: ARRAY
83833: PUSH
83834: LD_INT 1
83836: ARRAY
83837: PUSH
83838: LD_INT 2
83840: ARRAY
83841: PPUSH
83842: CALL_OW 297
83846: PUSH
83847: LD_INT 6
83849: GREATER
83850: IFFALSE 83925
// begin if not HasTask ( group [ i ] ) then
83852: LD_VAR 0 4
83856: PUSH
83857: LD_VAR 0 7
83861: ARRAY
83862: PPUSH
83863: CALL_OW 314
83867: NOT
83868: IFFALSE 83923
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83870: LD_VAR 0 4
83874: PUSH
83875: LD_VAR 0 7
83879: ARRAY
83880: PPUSH
83881: LD_VAR 0 16
83885: PUSH
83886: LD_VAR 0 7
83890: ARRAY
83891: PUSH
83892: LD_INT 1
83894: ARRAY
83895: PUSH
83896: LD_INT 1
83898: ARRAY
83899: PPUSH
83900: LD_VAR 0 16
83904: PUSH
83905: LD_VAR 0 7
83909: ARRAY
83910: PUSH
83911: LD_INT 1
83913: ARRAY
83914: PUSH
83915: LD_INT 2
83917: ARRAY
83918: PPUSH
83919: CALL_OW 114
// end else
83923: GO 83976
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83925: LD_ADDR_VAR 0 15
83929: PUSH
83930: LD_VAR 0 16
83934: PUSH
83935: LD_VAR 0 7
83939: ARRAY
83940: PPUSH
83941: LD_INT 1
83943: PPUSH
83944: CALL_OW 3
83948: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83949: LD_ADDR_VAR 0 16
83953: PUSH
83954: LD_VAR 0 16
83958: PPUSH
83959: LD_VAR 0 7
83963: PPUSH
83964: LD_VAR 0 15
83968: PPUSH
83969: CALL_OW 1
83973: ST_TO_ADDR
// continue ;
83974: GO 82519
// end ; end ; end else
83976: GO 86640
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83978: LD_ADDR_VAR 0 14
83982: PUSH
83983: LD_INT 81
83985: PUSH
83986: LD_VAR 0 4
83990: PUSH
83991: LD_VAR 0 7
83995: ARRAY
83996: PPUSH
83997: CALL_OW 255
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PPUSH
84006: CALL_OW 69
84010: ST_TO_ADDR
// if not tmp then
84011: LD_VAR 0 14
84015: NOT
84016: IFFALSE 84020
// continue ;
84018: GO 82519
// if f_ignore_area then
84020: LD_VAR 0 17
84024: IFFALSE 84112
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84026: LD_ADDR_VAR 0 15
84030: PUSH
84031: LD_VAR 0 14
84035: PPUSH
84036: LD_INT 3
84038: PUSH
84039: LD_INT 92
84041: PUSH
84042: LD_VAR 0 17
84046: PUSH
84047: LD_INT 1
84049: ARRAY
84050: PUSH
84051: LD_VAR 0 17
84055: PUSH
84056: LD_INT 2
84058: ARRAY
84059: PUSH
84060: LD_VAR 0 17
84064: PUSH
84065: LD_INT 3
84067: ARRAY
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: PPUSH
84079: CALL_OW 72
84083: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84084: LD_VAR 0 14
84088: PUSH
84089: LD_VAR 0 15
84093: DIFF
84094: IFFALSE 84112
// tmp := tmp diff tmp2 ;
84096: LD_ADDR_VAR 0 14
84100: PUSH
84101: LD_VAR 0 14
84105: PUSH
84106: LD_VAR 0 15
84110: DIFF
84111: ST_TO_ADDR
// end ; if not f_murder then
84112: LD_VAR 0 20
84116: NOT
84117: IFFALSE 84175
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84119: LD_ADDR_VAR 0 15
84123: PUSH
84124: LD_VAR 0 14
84128: PPUSH
84129: LD_INT 3
84131: PUSH
84132: LD_INT 50
84134: PUSH
84135: EMPTY
84136: LIST
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PPUSH
84142: CALL_OW 72
84146: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84147: LD_VAR 0 14
84151: PUSH
84152: LD_VAR 0 15
84156: DIFF
84157: IFFALSE 84175
// tmp := tmp diff tmp2 ;
84159: LD_ADDR_VAR 0 14
84163: PUSH
84164: LD_VAR 0 14
84168: PUSH
84169: LD_VAR 0 15
84173: DIFF
84174: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84175: LD_ADDR_VAR 0 14
84179: PUSH
84180: LD_VAR 0 4
84184: PUSH
84185: LD_VAR 0 7
84189: ARRAY
84190: PPUSH
84191: LD_VAR 0 14
84195: PPUSH
84196: LD_INT 1
84198: PPUSH
84199: LD_INT 1
84201: PPUSH
84202: CALL 15423 0 4
84206: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84207: LD_VAR 0 4
84211: PUSH
84212: LD_VAR 0 7
84216: ARRAY
84217: PPUSH
84218: CALL_OW 257
84222: PUSH
84223: LD_INT 1
84225: EQUAL
84226: IFFALSE 84674
// begin if WantPlant ( group [ i ] ) then
84228: LD_VAR 0 4
84232: PUSH
84233: LD_VAR 0 7
84237: ARRAY
84238: PPUSH
84239: CALL 14924 0 1
84243: IFFALSE 84247
// continue ;
84245: GO 82519
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84247: LD_VAR 0 18
84251: PUSH
84252: LD_VAR 0 4
84256: PUSH
84257: LD_VAR 0 7
84261: ARRAY
84262: PPUSH
84263: CALL_OW 310
84267: NOT
84268: AND
84269: PUSH
84270: LD_VAR 0 14
84274: PUSH
84275: LD_INT 1
84277: ARRAY
84278: PUSH
84279: LD_VAR 0 14
84283: PPUSH
84284: LD_INT 21
84286: PUSH
84287: LD_INT 2
84289: PUSH
84290: EMPTY
84291: LIST
84292: LIST
84293: PUSH
84294: LD_INT 58
84296: PUSH
84297: EMPTY
84298: LIST
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: PPUSH
84304: CALL_OW 72
84308: IN
84309: AND
84310: IFFALSE 84346
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84312: LD_VAR 0 4
84316: PUSH
84317: LD_VAR 0 7
84321: ARRAY
84322: PPUSH
84323: LD_VAR 0 14
84327: PUSH
84328: LD_INT 1
84330: ARRAY
84331: PPUSH
84332: CALL_OW 120
// attacking := true ;
84336: LD_ADDR_VAR 0 29
84340: PUSH
84341: LD_INT 1
84343: ST_TO_ADDR
// continue ;
84344: GO 82519
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84346: LD_VAR 0 26
84350: PUSH
84351: LD_VAR 0 4
84355: PUSH
84356: LD_VAR 0 7
84360: ARRAY
84361: PPUSH
84362: CALL_OW 257
84366: PUSH
84367: LD_INT 1
84369: EQUAL
84370: AND
84371: PUSH
84372: LD_VAR 0 4
84376: PUSH
84377: LD_VAR 0 7
84381: ARRAY
84382: PPUSH
84383: CALL_OW 256
84387: PUSH
84388: LD_INT 800
84390: LESS
84391: AND
84392: PUSH
84393: LD_VAR 0 4
84397: PUSH
84398: LD_VAR 0 7
84402: ARRAY
84403: PPUSH
84404: CALL_OW 318
84408: NOT
84409: AND
84410: IFFALSE 84427
// ComCrawl ( group [ i ] ) ;
84412: LD_VAR 0 4
84416: PUSH
84417: LD_VAR 0 7
84421: ARRAY
84422: PPUSH
84423: CALL_OW 137
// if f_mines then
84427: LD_VAR 0 21
84431: IFFALSE 84674
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84433: LD_VAR 0 14
84437: PUSH
84438: LD_INT 1
84440: ARRAY
84441: PPUSH
84442: CALL_OW 247
84446: PUSH
84447: LD_INT 3
84449: EQUAL
84450: PUSH
84451: LD_VAR 0 14
84455: PUSH
84456: LD_INT 1
84458: ARRAY
84459: PUSH
84460: LD_VAR 0 27
84464: IN
84465: NOT
84466: AND
84467: IFFALSE 84674
// begin x := GetX ( tmp [ 1 ] ) ;
84469: LD_ADDR_VAR 0 10
84473: PUSH
84474: LD_VAR 0 14
84478: PUSH
84479: LD_INT 1
84481: ARRAY
84482: PPUSH
84483: CALL_OW 250
84487: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84488: LD_ADDR_VAR 0 11
84492: PUSH
84493: LD_VAR 0 14
84497: PUSH
84498: LD_INT 1
84500: ARRAY
84501: PPUSH
84502: CALL_OW 251
84506: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84507: LD_ADDR_VAR 0 12
84511: PUSH
84512: LD_VAR 0 4
84516: PUSH
84517: LD_VAR 0 7
84521: ARRAY
84522: PPUSH
84523: CALL 42567 0 1
84527: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84528: LD_VAR 0 4
84532: PUSH
84533: LD_VAR 0 7
84537: ARRAY
84538: PPUSH
84539: LD_VAR 0 10
84543: PPUSH
84544: LD_VAR 0 11
84548: PPUSH
84549: LD_VAR 0 14
84553: PUSH
84554: LD_INT 1
84556: ARRAY
84557: PPUSH
84558: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84562: LD_VAR 0 4
84566: PUSH
84567: LD_VAR 0 7
84571: ARRAY
84572: PPUSH
84573: LD_VAR 0 10
84577: PPUSH
84578: LD_VAR 0 12
84582: PPUSH
84583: LD_INT 7
84585: PPUSH
84586: CALL_OW 272
84590: PPUSH
84591: LD_VAR 0 11
84595: PPUSH
84596: LD_VAR 0 12
84600: PPUSH
84601: LD_INT 7
84603: PPUSH
84604: CALL_OW 273
84608: PPUSH
84609: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
84613: LD_VAR 0 4
84617: PUSH
84618: LD_VAR 0 7
84622: ARRAY
84623: PPUSH
84624: LD_INT 71
84626: PPUSH
84627: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84631: LD_ADDR_VAR 0 27
84635: PUSH
84636: LD_VAR 0 27
84640: PPUSH
84641: LD_VAR 0 27
84645: PUSH
84646: LD_INT 1
84648: PLUS
84649: PPUSH
84650: LD_VAR 0 14
84654: PUSH
84655: LD_INT 1
84657: ARRAY
84658: PPUSH
84659: CALL_OW 1
84663: ST_TO_ADDR
// attacking := true ;
84664: LD_ADDR_VAR 0 29
84668: PUSH
84669: LD_INT 1
84671: ST_TO_ADDR
// continue ;
84672: GO 82519
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84674: LD_VAR 0 4
84678: PUSH
84679: LD_VAR 0 7
84683: ARRAY
84684: PPUSH
84685: CALL_OW 257
84689: PUSH
84690: LD_INT 17
84692: EQUAL
84693: PUSH
84694: LD_VAR 0 4
84698: PUSH
84699: LD_VAR 0 7
84703: ARRAY
84704: PPUSH
84705: CALL_OW 110
84709: PUSH
84710: LD_INT 71
84712: EQUAL
84713: NOT
84714: AND
84715: IFFALSE 84861
// begin attacking := false ;
84717: LD_ADDR_VAR 0 29
84721: PUSH
84722: LD_INT 0
84724: ST_TO_ADDR
// k := 5 ;
84725: LD_ADDR_VAR 0 9
84729: PUSH
84730: LD_INT 5
84732: ST_TO_ADDR
// if tmp < k then
84733: LD_VAR 0 14
84737: PUSH
84738: LD_VAR 0 9
84742: LESS
84743: IFFALSE 84755
// k := tmp ;
84745: LD_ADDR_VAR 0 9
84749: PUSH
84750: LD_VAR 0 14
84754: ST_TO_ADDR
// for j = 1 to k do
84755: LD_ADDR_VAR 0 8
84759: PUSH
84760: DOUBLE
84761: LD_INT 1
84763: DEC
84764: ST_TO_ADDR
84765: LD_VAR 0 9
84769: PUSH
84770: FOR_TO
84771: IFFALSE 84859
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84773: LD_VAR 0 14
84777: PUSH
84778: LD_VAR 0 8
84782: ARRAY
84783: PUSH
84784: LD_VAR 0 14
84788: PPUSH
84789: LD_INT 58
84791: PUSH
84792: EMPTY
84793: LIST
84794: PPUSH
84795: CALL_OW 72
84799: IN
84800: NOT
84801: IFFALSE 84857
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84803: LD_VAR 0 4
84807: PUSH
84808: LD_VAR 0 7
84812: ARRAY
84813: PPUSH
84814: LD_VAR 0 14
84818: PUSH
84819: LD_VAR 0 8
84823: ARRAY
84824: PPUSH
84825: CALL_OW 115
// attacking := true ;
84829: LD_ADDR_VAR 0 29
84833: PUSH
84834: LD_INT 1
84836: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84837: LD_VAR 0 4
84841: PUSH
84842: LD_VAR 0 7
84846: ARRAY
84847: PPUSH
84848: LD_INT 71
84850: PPUSH
84851: CALL_OW 109
// continue ;
84855: GO 84770
// end ; end ;
84857: GO 84770
84859: POP
84860: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84861: LD_VAR 0 4
84865: PUSH
84866: LD_VAR 0 7
84870: ARRAY
84871: PPUSH
84872: CALL_OW 257
84876: PUSH
84877: LD_INT 8
84879: EQUAL
84880: PUSH
84881: LD_VAR 0 4
84885: PUSH
84886: LD_VAR 0 7
84890: ARRAY
84891: PPUSH
84892: CALL_OW 264
84896: PUSH
84897: LD_INT 28
84899: PUSH
84900: LD_INT 45
84902: PUSH
84903: LD_INT 7
84905: PUSH
84906: LD_INT 47
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: IN
84915: OR
84916: IFFALSE 85172
// begin attacking := false ;
84918: LD_ADDR_VAR 0 29
84922: PUSH
84923: LD_INT 0
84925: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84926: LD_VAR 0 14
84930: PUSH
84931: LD_INT 1
84933: ARRAY
84934: PPUSH
84935: CALL_OW 266
84939: PUSH
84940: LD_INT 32
84942: PUSH
84943: LD_INT 31
84945: PUSH
84946: LD_INT 33
84948: PUSH
84949: LD_INT 4
84951: PUSH
84952: LD_INT 5
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: IN
84962: IFFALSE 85148
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84964: LD_ADDR_VAR 0 9
84968: PUSH
84969: LD_VAR 0 14
84973: PUSH
84974: LD_INT 1
84976: ARRAY
84977: PPUSH
84978: CALL_OW 266
84982: PPUSH
84983: LD_VAR 0 14
84987: PUSH
84988: LD_INT 1
84990: ARRAY
84991: PPUSH
84992: CALL_OW 250
84996: PPUSH
84997: LD_VAR 0 14
85001: PUSH
85002: LD_INT 1
85004: ARRAY
85005: PPUSH
85006: CALL_OW 251
85010: PPUSH
85011: LD_VAR 0 14
85015: PUSH
85016: LD_INT 1
85018: ARRAY
85019: PPUSH
85020: CALL_OW 254
85024: PPUSH
85025: LD_VAR 0 14
85029: PUSH
85030: LD_INT 1
85032: ARRAY
85033: PPUSH
85034: CALL_OW 248
85038: PPUSH
85039: LD_INT 0
85041: PPUSH
85042: CALL 23937 0 6
85046: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85047: LD_ADDR_VAR 0 8
85051: PUSH
85052: LD_VAR 0 4
85056: PUSH
85057: LD_VAR 0 7
85061: ARRAY
85062: PPUSH
85063: LD_VAR 0 9
85067: PPUSH
85068: CALL 42680 0 2
85072: ST_TO_ADDR
// if j then
85073: LD_VAR 0 8
85077: IFFALSE 85146
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85079: LD_VAR 0 8
85083: PUSH
85084: LD_INT 1
85086: ARRAY
85087: PPUSH
85088: LD_VAR 0 8
85092: PUSH
85093: LD_INT 2
85095: ARRAY
85096: PPUSH
85097: CALL_OW 488
85101: IFFALSE 85146
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85103: LD_VAR 0 4
85107: PUSH
85108: LD_VAR 0 7
85112: ARRAY
85113: PPUSH
85114: LD_VAR 0 8
85118: PUSH
85119: LD_INT 1
85121: ARRAY
85122: PPUSH
85123: LD_VAR 0 8
85127: PUSH
85128: LD_INT 2
85130: ARRAY
85131: PPUSH
85132: CALL_OW 116
// attacking := true ;
85136: LD_ADDR_VAR 0 29
85140: PUSH
85141: LD_INT 1
85143: ST_TO_ADDR
// continue ;
85144: GO 82519
// end ; end else
85146: GO 85172
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85148: LD_VAR 0 4
85152: PUSH
85153: LD_VAR 0 7
85157: ARRAY
85158: PPUSH
85159: LD_VAR 0 14
85163: PUSH
85164: LD_INT 1
85166: ARRAY
85167: PPUSH
85168: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85172: LD_VAR 0 4
85176: PUSH
85177: LD_VAR 0 7
85181: ARRAY
85182: PPUSH
85183: CALL_OW 265
85187: PUSH
85188: LD_INT 11
85190: EQUAL
85191: IFFALSE 85469
// begin k := 10 ;
85193: LD_ADDR_VAR 0 9
85197: PUSH
85198: LD_INT 10
85200: ST_TO_ADDR
// x := 0 ;
85201: LD_ADDR_VAR 0 10
85205: PUSH
85206: LD_INT 0
85208: ST_TO_ADDR
// if tmp < k then
85209: LD_VAR 0 14
85213: PUSH
85214: LD_VAR 0 9
85218: LESS
85219: IFFALSE 85231
// k := tmp ;
85221: LD_ADDR_VAR 0 9
85225: PUSH
85226: LD_VAR 0 14
85230: ST_TO_ADDR
// for j = k downto 1 do
85231: LD_ADDR_VAR 0 8
85235: PUSH
85236: DOUBLE
85237: LD_VAR 0 9
85241: INC
85242: ST_TO_ADDR
85243: LD_INT 1
85245: PUSH
85246: FOR_DOWNTO
85247: IFFALSE 85322
// begin if GetType ( tmp [ j ] ) = unit_human then
85249: LD_VAR 0 14
85253: PUSH
85254: LD_VAR 0 8
85258: ARRAY
85259: PPUSH
85260: CALL_OW 247
85264: PUSH
85265: LD_INT 1
85267: EQUAL
85268: IFFALSE 85320
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85270: LD_VAR 0 4
85274: PUSH
85275: LD_VAR 0 7
85279: ARRAY
85280: PPUSH
85281: LD_VAR 0 14
85285: PUSH
85286: LD_VAR 0 8
85290: ARRAY
85291: PPUSH
85292: CALL 42934 0 2
// x := tmp [ j ] ;
85296: LD_ADDR_VAR 0 10
85300: PUSH
85301: LD_VAR 0 14
85305: PUSH
85306: LD_VAR 0 8
85310: ARRAY
85311: ST_TO_ADDR
// attacking := true ;
85312: LD_ADDR_VAR 0 29
85316: PUSH
85317: LD_INT 1
85319: ST_TO_ADDR
// end ; end ;
85320: GO 85246
85322: POP
85323: POP
// if not x then
85324: LD_VAR 0 10
85328: NOT
85329: IFFALSE 85469
// begin attacking := true ;
85331: LD_ADDR_VAR 0 29
85335: PUSH
85336: LD_INT 1
85338: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85339: LD_VAR 0 4
85343: PUSH
85344: LD_VAR 0 7
85348: ARRAY
85349: PPUSH
85350: CALL_OW 250
85354: PPUSH
85355: LD_VAR 0 4
85359: PUSH
85360: LD_VAR 0 7
85364: ARRAY
85365: PPUSH
85366: CALL_OW 251
85370: PPUSH
85371: CALL_OW 546
85375: PUSH
85376: LD_INT 2
85378: ARRAY
85379: PUSH
85380: LD_VAR 0 14
85384: PUSH
85385: LD_INT 1
85387: ARRAY
85388: PPUSH
85389: CALL_OW 250
85393: PPUSH
85394: LD_VAR 0 14
85398: PUSH
85399: LD_INT 1
85401: ARRAY
85402: PPUSH
85403: CALL_OW 251
85407: PPUSH
85408: CALL_OW 546
85412: PUSH
85413: LD_INT 2
85415: ARRAY
85416: EQUAL
85417: IFFALSE 85445
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85419: LD_VAR 0 4
85423: PUSH
85424: LD_VAR 0 7
85428: ARRAY
85429: PPUSH
85430: LD_VAR 0 14
85434: PUSH
85435: LD_INT 1
85437: ARRAY
85438: PPUSH
85439: CALL 42934 0 2
85443: GO 85469
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85445: LD_VAR 0 4
85449: PUSH
85450: LD_VAR 0 7
85454: ARRAY
85455: PPUSH
85456: LD_VAR 0 14
85460: PUSH
85461: LD_INT 1
85463: ARRAY
85464: PPUSH
85465: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85469: LD_VAR 0 4
85473: PUSH
85474: LD_VAR 0 7
85478: ARRAY
85479: PPUSH
85480: CALL_OW 264
85484: PUSH
85485: LD_INT 29
85487: EQUAL
85488: IFFALSE 85854
// begin if WantsToAttack ( group [ i ] ) in bombed then
85490: LD_VAR 0 4
85494: PUSH
85495: LD_VAR 0 7
85499: ARRAY
85500: PPUSH
85501: CALL_OW 319
85505: PUSH
85506: LD_VAR 0 28
85510: IN
85511: IFFALSE 85515
// continue ;
85513: GO 82519
// k := 8 ;
85515: LD_ADDR_VAR 0 9
85519: PUSH
85520: LD_INT 8
85522: ST_TO_ADDR
// x := 0 ;
85523: LD_ADDR_VAR 0 10
85527: PUSH
85528: LD_INT 0
85530: ST_TO_ADDR
// if tmp < k then
85531: LD_VAR 0 14
85535: PUSH
85536: LD_VAR 0 9
85540: LESS
85541: IFFALSE 85553
// k := tmp ;
85543: LD_ADDR_VAR 0 9
85547: PUSH
85548: LD_VAR 0 14
85552: ST_TO_ADDR
// for j = 1 to k do
85553: LD_ADDR_VAR 0 8
85557: PUSH
85558: DOUBLE
85559: LD_INT 1
85561: DEC
85562: ST_TO_ADDR
85563: LD_VAR 0 9
85567: PUSH
85568: FOR_TO
85569: IFFALSE 85701
// begin if GetType ( tmp [ j ] ) = unit_building then
85571: LD_VAR 0 14
85575: PUSH
85576: LD_VAR 0 8
85580: ARRAY
85581: PPUSH
85582: CALL_OW 247
85586: PUSH
85587: LD_INT 3
85589: EQUAL
85590: IFFALSE 85699
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85592: LD_VAR 0 14
85596: PUSH
85597: LD_VAR 0 8
85601: ARRAY
85602: PUSH
85603: LD_VAR 0 28
85607: IN
85608: NOT
85609: PUSH
85610: LD_VAR 0 14
85614: PUSH
85615: LD_VAR 0 8
85619: ARRAY
85620: PPUSH
85621: CALL_OW 313
85625: AND
85626: IFFALSE 85699
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85628: LD_VAR 0 4
85632: PUSH
85633: LD_VAR 0 7
85637: ARRAY
85638: PPUSH
85639: LD_VAR 0 14
85643: PUSH
85644: LD_VAR 0 8
85648: ARRAY
85649: PPUSH
85650: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85654: LD_ADDR_VAR 0 28
85658: PUSH
85659: LD_VAR 0 28
85663: PPUSH
85664: LD_VAR 0 28
85668: PUSH
85669: LD_INT 1
85671: PLUS
85672: PPUSH
85673: LD_VAR 0 14
85677: PUSH
85678: LD_VAR 0 8
85682: ARRAY
85683: PPUSH
85684: CALL_OW 1
85688: ST_TO_ADDR
// attacking := true ;
85689: LD_ADDR_VAR 0 29
85693: PUSH
85694: LD_INT 1
85696: ST_TO_ADDR
// break ;
85697: GO 85701
// end ; end ;
85699: GO 85568
85701: POP
85702: POP
// if not attacking and f_attack_depot then
85703: LD_VAR 0 29
85707: NOT
85708: PUSH
85709: LD_VAR 0 25
85713: AND
85714: IFFALSE 85809
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85716: LD_ADDR_VAR 0 13
85720: PUSH
85721: LD_VAR 0 14
85725: PPUSH
85726: LD_INT 2
85728: PUSH
85729: LD_INT 30
85731: PUSH
85732: LD_INT 0
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 30
85741: PUSH
85742: LD_INT 1
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: LIST
85753: PPUSH
85754: CALL_OW 72
85758: ST_TO_ADDR
// if z then
85759: LD_VAR 0 13
85763: IFFALSE 85809
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85765: LD_VAR 0 4
85769: PUSH
85770: LD_VAR 0 7
85774: ARRAY
85775: PPUSH
85776: LD_VAR 0 13
85780: PPUSH
85781: LD_VAR 0 4
85785: PUSH
85786: LD_VAR 0 7
85790: ARRAY
85791: PPUSH
85792: CALL_OW 74
85796: PPUSH
85797: CALL_OW 115
// attacking := true ;
85801: LD_ADDR_VAR 0 29
85805: PUSH
85806: LD_INT 1
85808: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85809: LD_VAR 0 4
85813: PUSH
85814: LD_VAR 0 7
85818: ARRAY
85819: PPUSH
85820: CALL_OW 256
85824: PUSH
85825: LD_INT 500
85827: LESS
85828: IFFALSE 85854
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85830: LD_VAR 0 4
85834: PUSH
85835: LD_VAR 0 7
85839: ARRAY
85840: PPUSH
85841: LD_VAR 0 14
85845: PUSH
85846: LD_INT 1
85848: ARRAY
85849: PPUSH
85850: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85854: LD_VAR 0 4
85858: PUSH
85859: LD_VAR 0 7
85863: ARRAY
85864: PPUSH
85865: CALL_OW 264
85869: PUSH
85870: LD_INT 49
85872: EQUAL
85873: IFFALSE 85994
// begin if not HasTask ( group [ i ] ) then
85875: LD_VAR 0 4
85879: PUSH
85880: LD_VAR 0 7
85884: ARRAY
85885: PPUSH
85886: CALL_OW 314
85890: NOT
85891: IFFALSE 85994
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85893: LD_ADDR_VAR 0 9
85897: PUSH
85898: LD_INT 81
85900: PUSH
85901: LD_VAR 0 4
85905: PUSH
85906: LD_VAR 0 7
85910: ARRAY
85911: PPUSH
85912: CALL_OW 255
85916: PUSH
85917: EMPTY
85918: LIST
85919: LIST
85920: PPUSH
85921: CALL_OW 69
85925: PPUSH
85926: LD_VAR 0 4
85930: PUSH
85931: LD_VAR 0 7
85935: ARRAY
85936: PPUSH
85937: CALL_OW 74
85941: ST_TO_ADDR
// if k then
85942: LD_VAR 0 9
85946: IFFALSE 85994
// if GetDistUnits ( group [ i ] , k ) > 10 then
85948: LD_VAR 0 4
85952: PUSH
85953: LD_VAR 0 7
85957: ARRAY
85958: PPUSH
85959: LD_VAR 0 9
85963: PPUSH
85964: CALL_OW 296
85968: PUSH
85969: LD_INT 10
85971: GREATER
85972: IFFALSE 85994
// ComMoveUnit ( group [ i ] , k ) ;
85974: LD_VAR 0 4
85978: PUSH
85979: LD_VAR 0 7
85983: ARRAY
85984: PPUSH
85985: LD_VAR 0 9
85989: PPUSH
85990: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85994: LD_VAR 0 4
85998: PUSH
85999: LD_VAR 0 7
86003: ARRAY
86004: PPUSH
86005: CALL_OW 256
86009: PUSH
86010: LD_INT 250
86012: LESS
86013: PUSH
86014: LD_VAR 0 4
86018: PUSH
86019: LD_VAR 0 7
86023: ARRAY
86024: PUSH
86025: LD_INT 21
86027: PUSH
86028: LD_INT 2
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: LD_INT 23
86037: PUSH
86038: LD_INT 2
86040: PUSH
86041: EMPTY
86042: LIST
86043: LIST
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PPUSH
86049: CALL_OW 69
86053: IN
86054: AND
86055: IFFALSE 86180
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86057: LD_ADDR_VAR 0 9
86061: PUSH
86062: LD_OWVAR 3
86066: PUSH
86067: LD_VAR 0 4
86071: PUSH
86072: LD_VAR 0 7
86076: ARRAY
86077: DIFF
86078: PPUSH
86079: LD_VAR 0 4
86083: PUSH
86084: LD_VAR 0 7
86088: ARRAY
86089: PPUSH
86090: CALL_OW 74
86094: ST_TO_ADDR
// if not k then
86095: LD_VAR 0 9
86099: NOT
86100: IFFALSE 86104
// continue ;
86102: GO 82519
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86104: LD_VAR 0 9
86108: PUSH
86109: LD_INT 81
86111: PUSH
86112: LD_VAR 0 4
86116: PUSH
86117: LD_VAR 0 7
86121: ARRAY
86122: PPUSH
86123: CALL_OW 255
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: PPUSH
86132: CALL_OW 69
86136: IN
86137: PUSH
86138: LD_VAR 0 9
86142: PPUSH
86143: LD_VAR 0 4
86147: PUSH
86148: LD_VAR 0 7
86152: ARRAY
86153: PPUSH
86154: CALL_OW 296
86158: PUSH
86159: LD_INT 5
86161: LESS
86162: AND
86163: IFFALSE 86180
// ComAutodestruct ( group [ i ] ) ;
86165: LD_VAR 0 4
86169: PUSH
86170: LD_VAR 0 7
86174: ARRAY
86175: PPUSH
86176: CALL 42832 0 1
// end ; if f_attack_depot then
86180: LD_VAR 0 25
86184: IFFALSE 86296
// begin k := 6 ;
86186: LD_ADDR_VAR 0 9
86190: PUSH
86191: LD_INT 6
86193: ST_TO_ADDR
// if tmp < k then
86194: LD_VAR 0 14
86198: PUSH
86199: LD_VAR 0 9
86203: LESS
86204: IFFALSE 86216
// k := tmp ;
86206: LD_ADDR_VAR 0 9
86210: PUSH
86211: LD_VAR 0 14
86215: ST_TO_ADDR
// for j = 1 to k do
86216: LD_ADDR_VAR 0 8
86220: PUSH
86221: DOUBLE
86222: LD_INT 1
86224: DEC
86225: ST_TO_ADDR
86226: LD_VAR 0 9
86230: PUSH
86231: FOR_TO
86232: IFFALSE 86294
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86234: LD_VAR 0 8
86238: PPUSH
86239: CALL_OW 266
86243: PUSH
86244: LD_INT 0
86246: PUSH
86247: LD_INT 1
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: IN
86254: IFFALSE 86292
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86256: LD_VAR 0 4
86260: PUSH
86261: LD_VAR 0 7
86265: ARRAY
86266: PPUSH
86267: LD_VAR 0 14
86271: PUSH
86272: LD_VAR 0 8
86276: ARRAY
86277: PPUSH
86278: CALL_OW 115
// attacking := true ;
86282: LD_ADDR_VAR 0 29
86286: PUSH
86287: LD_INT 1
86289: ST_TO_ADDR
// break ;
86290: GO 86294
// end ;
86292: GO 86231
86294: POP
86295: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86296: LD_VAR 0 4
86300: PUSH
86301: LD_VAR 0 7
86305: ARRAY
86306: PPUSH
86307: CALL_OW 302
86311: PUSH
86312: LD_VAR 0 29
86316: NOT
86317: AND
86318: IFFALSE 86640
// begin if GetTag ( group [ i ] ) = 71 then
86320: LD_VAR 0 4
86324: PUSH
86325: LD_VAR 0 7
86329: ARRAY
86330: PPUSH
86331: CALL_OW 110
86335: PUSH
86336: LD_INT 71
86338: EQUAL
86339: IFFALSE 86380
// begin if HasTask ( group [ i ] ) then
86341: LD_VAR 0 4
86345: PUSH
86346: LD_VAR 0 7
86350: ARRAY
86351: PPUSH
86352: CALL_OW 314
86356: IFFALSE 86362
// continue else
86358: GO 82519
86360: GO 86380
// SetTag ( group [ i ] , 0 ) ;
86362: LD_VAR 0 4
86366: PUSH
86367: LD_VAR 0 7
86371: ARRAY
86372: PPUSH
86373: LD_INT 0
86375: PPUSH
86376: CALL_OW 109
// end ; k := 8 ;
86380: LD_ADDR_VAR 0 9
86384: PUSH
86385: LD_INT 8
86387: ST_TO_ADDR
// x := 0 ;
86388: LD_ADDR_VAR 0 10
86392: PUSH
86393: LD_INT 0
86395: ST_TO_ADDR
// if tmp < k then
86396: LD_VAR 0 14
86400: PUSH
86401: LD_VAR 0 9
86405: LESS
86406: IFFALSE 86418
// k := tmp ;
86408: LD_ADDR_VAR 0 9
86412: PUSH
86413: LD_VAR 0 14
86417: ST_TO_ADDR
// for j = 1 to k do
86418: LD_ADDR_VAR 0 8
86422: PUSH
86423: DOUBLE
86424: LD_INT 1
86426: DEC
86427: ST_TO_ADDR
86428: LD_VAR 0 9
86432: PUSH
86433: FOR_TO
86434: IFFALSE 86532
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86436: LD_VAR 0 14
86440: PUSH
86441: LD_VAR 0 8
86445: ARRAY
86446: PPUSH
86447: CALL_OW 247
86451: PUSH
86452: LD_INT 1
86454: EQUAL
86455: PUSH
86456: LD_VAR 0 14
86460: PUSH
86461: LD_VAR 0 8
86465: ARRAY
86466: PPUSH
86467: CALL_OW 256
86471: PUSH
86472: LD_INT 250
86474: LESS
86475: PUSH
86476: LD_VAR 0 20
86480: AND
86481: PUSH
86482: LD_VAR 0 20
86486: NOT
86487: PUSH
86488: LD_VAR 0 14
86492: PUSH
86493: LD_VAR 0 8
86497: ARRAY
86498: PPUSH
86499: CALL_OW 256
86503: PUSH
86504: LD_INT 250
86506: GREATEREQUAL
86507: AND
86508: OR
86509: AND
86510: IFFALSE 86530
// begin x := tmp [ j ] ;
86512: LD_ADDR_VAR 0 10
86516: PUSH
86517: LD_VAR 0 14
86521: PUSH
86522: LD_VAR 0 8
86526: ARRAY
86527: ST_TO_ADDR
// break ;
86528: GO 86532
// end ;
86530: GO 86433
86532: POP
86533: POP
// if x then
86534: LD_VAR 0 10
86538: IFFALSE 86562
// ComAttackUnit ( group [ i ] , x ) else
86540: LD_VAR 0 4
86544: PUSH
86545: LD_VAR 0 7
86549: ARRAY
86550: PPUSH
86551: LD_VAR 0 10
86555: PPUSH
86556: CALL_OW 115
86560: GO 86586
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86562: LD_VAR 0 4
86566: PUSH
86567: LD_VAR 0 7
86571: ARRAY
86572: PPUSH
86573: LD_VAR 0 14
86577: PUSH
86578: LD_INT 1
86580: ARRAY
86581: PPUSH
86582: CALL_OW 115
// if not HasTask ( group [ i ] ) then
86586: LD_VAR 0 4
86590: PUSH
86591: LD_VAR 0 7
86595: ARRAY
86596: PPUSH
86597: CALL_OW 314
86601: NOT
86602: IFFALSE 86640
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86604: LD_VAR 0 4
86608: PUSH
86609: LD_VAR 0 7
86613: ARRAY
86614: PPUSH
86615: LD_VAR 0 14
86619: PPUSH
86620: LD_VAR 0 4
86624: PUSH
86625: LD_VAR 0 7
86629: ARRAY
86630: PPUSH
86631: CALL_OW 74
86635: PPUSH
86636: CALL_OW 115
// end ; end ; end ;
86640: GO 82519
86642: POP
86643: POP
// wait ( 0 0$2 ) ;
86644: LD_INT 70
86646: PPUSH
86647: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86651: LD_VAR 0 4
86655: NOT
86656: PUSH
86657: LD_VAR 0 4
86661: PUSH
86662: EMPTY
86663: EQUAL
86664: OR
86665: PUSH
86666: LD_INT 81
86668: PUSH
86669: LD_VAR 0 35
86673: PUSH
86674: EMPTY
86675: LIST
86676: LIST
86677: PPUSH
86678: CALL_OW 69
86682: NOT
86683: OR
86684: IFFALSE 82504
// end ;
86686: LD_VAR 0 2
86690: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86691: LD_INT 0
86693: PPUSH
86694: PPUSH
86695: PPUSH
86696: PPUSH
86697: PPUSH
86698: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86699: LD_VAR 0 1
86703: NOT
86704: PUSH
86705: LD_EXP 43
86709: PUSH
86710: LD_VAR 0 1
86714: ARRAY
86715: NOT
86716: OR
86717: PUSH
86718: LD_VAR 0 2
86722: NOT
86723: OR
86724: IFFALSE 86728
// exit ;
86726: GO 87282
// side := mc_sides [ base ] ;
86728: LD_ADDR_VAR 0 6
86732: PUSH
86733: LD_EXP 69
86737: PUSH
86738: LD_VAR 0 1
86742: ARRAY
86743: ST_TO_ADDR
// if not side then
86744: LD_VAR 0 6
86748: NOT
86749: IFFALSE 86753
// exit ;
86751: GO 87282
// for i in solds do
86753: LD_ADDR_VAR 0 7
86757: PUSH
86758: LD_VAR 0 2
86762: PUSH
86763: FOR_IN
86764: IFFALSE 86825
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86766: LD_VAR 0 7
86770: PPUSH
86771: CALL_OW 310
86775: PPUSH
86776: CALL_OW 266
86780: PUSH
86781: LD_INT 32
86783: PUSH
86784: LD_INT 31
86786: PUSH
86787: EMPTY
86788: LIST
86789: LIST
86790: IN
86791: IFFALSE 86811
// solds := solds diff i else
86793: LD_ADDR_VAR 0 2
86797: PUSH
86798: LD_VAR 0 2
86802: PUSH
86803: LD_VAR 0 7
86807: DIFF
86808: ST_TO_ADDR
86809: GO 86823
// SetTag ( i , 18 ) ;
86811: LD_VAR 0 7
86815: PPUSH
86816: LD_INT 18
86818: PPUSH
86819: CALL_OW 109
86823: GO 86763
86825: POP
86826: POP
// if not solds then
86827: LD_VAR 0 2
86831: NOT
86832: IFFALSE 86836
// exit ;
86834: GO 87282
// repeat wait ( 0 0$2 ) ;
86836: LD_INT 70
86838: PPUSH
86839: CALL_OW 67
// enemy := mc_scan [ base ] ;
86843: LD_ADDR_VAR 0 4
86847: PUSH
86848: LD_EXP 66
86852: PUSH
86853: LD_VAR 0 1
86857: ARRAY
86858: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86859: LD_EXP 43
86863: PUSH
86864: LD_VAR 0 1
86868: ARRAY
86869: NOT
86870: PUSH
86871: LD_EXP 43
86875: PUSH
86876: LD_VAR 0 1
86880: ARRAY
86881: PUSH
86882: EMPTY
86883: EQUAL
86884: OR
86885: IFFALSE 86922
// begin for i in solds do
86887: LD_ADDR_VAR 0 7
86891: PUSH
86892: LD_VAR 0 2
86896: PUSH
86897: FOR_IN
86898: IFFALSE 86911
// ComStop ( i ) ;
86900: LD_VAR 0 7
86904: PPUSH
86905: CALL_OW 141
86909: GO 86897
86911: POP
86912: POP
// solds := [ ] ;
86913: LD_ADDR_VAR 0 2
86917: PUSH
86918: EMPTY
86919: ST_TO_ADDR
// exit ;
86920: GO 87282
// end ; for i in solds do
86922: LD_ADDR_VAR 0 7
86926: PUSH
86927: LD_VAR 0 2
86931: PUSH
86932: FOR_IN
86933: IFFALSE 87254
// begin if IsInUnit ( i ) then
86935: LD_VAR 0 7
86939: PPUSH
86940: CALL_OW 310
86944: IFFALSE 86955
// ComExitBuilding ( i ) ;
86946: LD_VAR 0 7
86950: PPUSH
86951: CALL_OW 122
// if GetLives ( i ) > 500 then
86955: LD_VAR 0 7
86959: PPUSH
86960: CALL_OW 256
86964: PUSH
86965: LD_INT 500
86967: GREATER
86968: IFFALSE 87021
// begin e := NearestUnitToUnit ( enemy , i ) ;
86970: LD_ADDR_VAR 0 5
86974: PUSH
86975: LD_VAR 0 4
86979: PPUSH
86980: LD_VAR 0 7
86984: PPUSH
86985: CALL_OW 74
86989: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86990: LD_VAR 0 7
86994: PPUSH
86995: LD_VAR 0 5
86999: PPUSH
87000: CALL_OW 250
87004: PPUSH
87005: LD_VAR 0 5
87009: PPUSH
87010: CALL_OW 251
87014: PPUSH
87015: CALL_OW 114
// end else
87019: GO 87252
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
87021: LD_VAR 0 7
87025: PPUSH
87026: LD_EXP 43
87030: PUSH
87031: LD_VAR 0 1
87035: ARRAY
87036: PPUSH
87037: LD_INT 2
87039: PUSH
87040: LD_INT 30
87042: PUSH
87043: LD_INT 0
87045: PUSH
87046: EMPTY
87047: LIST
87048: LIST
87049: PUSH
87050: LD_INT 30
87052: PUSH
87053: LD_INT 1
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 30
87062: PUSH
87063: LD_INT 6
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: PPUSH
87076: CALL_OW 72
87080: PPUSH
87081: LD_VAR 0 7
87085: PPUSH
87086: CALL_OW 74
87090: PPUSH
87091: CALL_OW 296
87095: PUSH
87096: LD_INT 10
87098: GREATER
87099: IFFALSE 87252
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
87101: LD_ADDR_VAR 0 8
87105: PUSH
87106: LD_EXP 43
87110: PUSH
87111: LD_VAR 0 1
87115: ARRAY
87116: PPUSH
87117: LD_INT 2
87119: PUSH
87120: LD_INT 30
87122: PUSH
87123: LD_INT 0
87125: PUSH
87126: EMPTY
87127: LIST
87128: LIST
87129: PUSH
87130: LD_INT 30
87132: PUSH
87133: LD_INT 1
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 30
87142: PUSH
87143: LD_INT 6
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: LIST
87154: LIST
87155: PPUSH
87156: CALL_OW 72
87160: PPUSH
87161: LD_VAR 0 7
87165: PPUSH
87166: CALL_OW 74
87170: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87171: LD_VAR 0 7
87175: PPUSH
87176: LD_VAR 0 8
87180: PPUSH
87181: CALL_OW 250
87185: PPUSH
87186: LD_INT 3
87188: PPUSH
87189: LD_INT 5
87191: PPUSH
87192: CALL_OW 272
87196: PPUSH
87197: LD_VAR 0 8
87201: PPUSH
87202: CALL_OW 251
87206: PPUSH
87207: LD_INT 3
87209: PPUSH
87210: LD_INT 5
87212: PPUSH
87213: CALL_OW 273
87217: PPUSH
87218: CALL_OW 111
// SetTag ( i , 0 ) ;
87222: LD_VAR 0 7
87226: PPUSH
87227: LD_INT 0
87229: PPUSH
87230: CALL_OW 109
// solds := solds diff i ;
87234: LD_ADDR_VAR 0 2
87238: PUSH
87239: LD_VAR 0 2
87243: PUSH
87244: LD_VAR 0 7
87248: DIFF
87249: ST_TO_ADDR
// continue ;
87250: GO 86932
// end ; end ;
87252: GO 86932
87254: POP
87255: POP
// until not solds or not enemy ;
87256: LD_VAR 0 2
87260: NOT
87261: PUSH
87262: LD_VAR 0 4
87266: NOT
87267: OR
87268: IFFALSE 86836
// MC_Reset ( base , 18 ) ;
87270: LD_VAR 0 1
87274: PPUSH
87275: LD_INT 18
87277: PPUSH
87278: CALL 55441 0 2
// end ;
87282: LD_VAR 0 3
87286: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87287: LD_INT 0
87289: PPUSH
87290: PPUSH
87291: PPUSH
87292: PPUSH
87293: PPUSH
87294: PPUSH
87295: PPUSH
87296: PPUSH
87297: PPUSH
87298: PPUSH
87299: PPUSH
87300: PPUSH
87301: PPUSH
87302: PPUSH
87303: PPUSH
87304: PPUSH
87305: PPUSH
87306: PPUSH
87307: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87308: LD_ADDR_VAR 0 12
87312: PUSH
87313: LD_EXP 43
87317: PUSH
87318: LD_VAR 0 1
87322: ARRAY
87323: PPUSH
87324: LD_INT 25
87326: PUSH
87327: LD_INT 3
87329: PUSH
87330: EMPTY
87331: LIST
87332: LIST
87333: PPUSH
87334: CALL_OW 72
87338: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87339: LD_EXP 83
87343: PUSH
87344: LD_VAR 0 1
87348: ARRAY
87349: IFFALSE 87373
// mechs := mechs diff mc_remote_driver [ base ] ;
87351: LD_ADDR_VAR 0 12
87355: PUSH
87356: LD_VAR 0 12
87360: PUSH
87361: LD_EXP 83
87365: PUSH
87366: LD_VAR 0 1
87370: ARRAY
87371: DIFF
87372: ST_TO_ADDR
// for i in mechs do
87373: LD_ADDR_VAR 0 4
87377: PUSH
87378: LD_VAR 0 12
87382: PUSH
87383: FOR_IN
87384: IFFALSE 87419
// if GetTag ( i ) > 0 then
87386: LD_VAR 0 4
87390: PPUSH
87391: CALL_OW 110
87395: PUSH
87396: LD_INT 0
87398: GREATER
87399: IFFALSE 87417
// mechs := mechs diff i ;
87401: LD_ADDR_VAR 0 12
87405: PUSH
87406: LD_VAR 0 12
87410: PUSH
87411: LD_VAR 0 4
87415: DIFF
87416: ST_TO_ADDR
87417: GO 87383
87419: POP
87420: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87421: LD_ADDR_VAR 0 8
87425: PUSH
87426: LD_EXP 43
87430: PUSH
87431: LD_VAR 0 1
87435: ARRAY
87436: PPUSH
87437: LD_INT 2
87439: PUSH
87440: LD_INT 25
87442: PUSH
87443: LD_INT 1
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 25
87452: PUSH
87453: LD_INT 5
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 25
87462: PUSH
87463: LD_INT 8
87465: PUSH
87466: EMPTY
87467: LIST
87468: LIST
87469: PUSH
87470: LD_INT 25
87472: PUSH
87473: LD_INT 9
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: LIST
87484: LIST
87485: LIST
87486: PPUSH
87487: CALL_OW 72
87491: ST_TO_ADDR
// if not defenders and not solds then
87492: LD_VAR 0 2
87496: NOT
87497: PUSH
87498: LD_VAR 0 8
87502: NOT
87503: AND
87504: IFFALSE 87508
// exit ;
87506: GO 89278
// depot_under_attack := false ;
87508: LD_ADDR_VAR 0 16
87512: PUSH
87513: LD_INT 0
87515: ST_TO_ADDR
// sold_defenders := [ ] ;
87516: LD_ADDR_VAR 0 17
87520: PUSH
87521: EMPTY
87522: ST_TO_ADDR
// if mechs then
87523: LD_VAR 0 12
87527: IFFALSE 87680
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87529: LD_ADDR_VAR 0 4
87533: PUSH
87534: LD_VAR 0 2
87538: PPUSH
87539: LD_INT 21
87541: PUSH
87542: LD_INT 2
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PPUSH
87549: CALL_OW 72
87553: PUSH
87554: FOR_IN
87555: IFFALSE 87678
// begin if GetTag ( i ) <> 20 then
87557: LD_VAR 0 4
87561: PPUSH
87562: CALL_OW 110
87566: PUSH
87567: LD_INT 20
87569: NONEQUAL
87570: IFFALSE 87584
// SetTag ( i , 20 ) ;
87572: LD_VAR 0 4
87576: PPUSH
87577: LD_INT 20
87579: PPUSH
87580: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87584: LD_VAR 0 4
87588: PPUSH
87589: CALL_OW 263
87593: PUSH
87594: LD_INT 1
87596: EQUAL
87597: PUSH
87598: LD_VAR 0 4
87602: PPUSH
87603: CALL_OW 311
87607: NOT
87608: AND
87609: IFFALSE 87676
// begin un := mechs [ 1 ] ;
87611: LD_ADDR_VAR 0 10
87615: PUSH
87616: LD_VAR 0 12
87620: PUSH
87621: LD_INT 1
87623: ARRAY
87624: ST_TO_ADDR
// ComExit ( un ) ;
87625: LD_VAR 0 10
87629: PPUSH
87630: CALL 47717 0 1
// AddComEnterUnit ( un , i ) ;
87634: LD_VAR 0 10
87638: PPUSH
87639: LD_VAR 0 4
87643: PPUSH
87644: CALL_OW 180
// SetTag ( un , 19 ) ;
87648: LD_VAR 0 10
87652: PPUSH
87653: LD_INT 19
87655: PPUSH
87656: CALL_OW 109
// mechs := mechs diff un ;
87660: LD_ADDR_VAR 0 12
87664: PUSH
87665: LD_VAR 0 12
87669: PUSH
87670: LD_VAR 0 10
87674: DIFF
87675: ST_TO_ADDR
// end ; end ;
87676: GO 87554
87678: POP
87679: POP
// if solds then
87680: LD_VAR 0 8
87684: IFFALSE 87743
// for i in solds do
87686: LD_ADDR_VAR 0 4
87690: PUSH
87691: LD_VAR 0 8
87695: PUSH
87696: FOR_IN
87697: IFFALSE 87741
// if not GetTag ( i ) then
87699: LD_VAR 0 4
87703: PPUSH
87704: CALL_OW 110
87708: NOT
87709: IFFALSE 87739
// begin defenders := defenders union i ;
87711: LD_ADDR_VAR 0 2
87715: PUSH
87716: LD_VAR 0 2
87720: PUSH
87721: LD_VAR 0 4
87725: UNION
87726: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87727: LD_VAR 0 4
87731: PPUSH
87732: LD_INT 18
87734: PPUSH
87735: CALL_OW 109
// end ;
87739: GO 87696
87741: POP
87742: POP
// repeat wait ( 0 0$2 ) ;
87743: LD_INT 70
87745: PPUSH
87746: CALL_OW 67
// enemy := mc_scan [ base ] ;
87750: LD_ADDR_VAR 0 21
87754: PUSH
87755: LD_EXP 66
87759: PUSH
87760: LD_VAR 0 1
87764: ARRAY
87765: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87766: LD_EXP 43
87770: PUSH
87771: LD_VAR 0 1
87775: ARRAY
87776: NOT
87777: PUSH
87778: LD_EXP 43
87782: PUSH
87783: LD_VAR 0 1
87787: ARRAY
87788: PUSH
87789: EMPTY
87790: EQUAL
87791: OR
87792: IFFALSE 87829
// begin for i in defenders do
87794: LD_ADDR_VAR 0 4
87798: PUSH
87799: LD_VAR 0 2
87803: PUSH
87804: FOR_IN
87805: IFFALSE 87818
// ComStop ( i ) ;
87807: LD_VAR 0 4
87811: PPUSH
87812: CALL_OW 141
87816: GO 87804
87818: POP
87819: POP
// defenders := [ ] ;
87820: LD_ADDR_VAR 0 2
87824: PUSH
87825: EMPTY
87826: ST_TO_ADDR
// exit ;
87827: GO 89278
// end ; for i in defenders do
87829: LD_ADDR_VAR 0 4
87833: PUSH
87834: LD_VAR 0 2
87838: PUSH
87839: FOR_IN
87840: IFFALSE 88738
// begin e := NearestUnitToUnit ( enemy , i ) ;
87842: LD_ADDR_VAR 0 13
87846: PUSH
87847: LD_VAR 0 21
87851: PPUSH
87852: LD_VAR 0 4
87856: PPUSH
87857: CALL_OW 74
87861: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87862: LD_ADDR_VAR 0 7
87866: PUSH
87867: LD_EXP 43
87871: PUSH
87872: LD_VAR 0 1
87876: ARRAY
87877: PPUSH
87878: LD_INT 2
87880: PUSH
87881: LD_INT 30
87883: PUSH
87884: LD_INT 0
87886: PUSH
87887: EMPTY
87888: LIST
87889: LIST
87890: PUSH
87891: LD_INT 30
87893: PUSH
87894: LD_INT 1
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: LIST
87905: PPUSH
87906: CALL_OW 72
87910: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87911: LD_ADDR_VAR 0 16
87915: PUSH
87916: LD_VAR 0 7
87920: NOT
87921: PUSH
87922: LD_VAR 0 7
87926: PPUSH
87927: LD_INT 3
87929: PUSH
87930: LD_INT 24
87932: PUSH
87933: LD_INT 600
87935: PUSH
87936: EMPTY
87937: LIST
87938: LIST
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PPUSH
87944: CALL_OW 72
87948: OR
87949: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87950: LD_VAR 0 4
87954: PPUSH
87955: CALL_OW 247
87959: PUSH
87960: LD_INT 2
87962: DOUBLE
87963: EQUAL
87964: IFTRUE 87968
87966: GO 88364
87968: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87969: LD_VAR 0 4
87973: PPUSH
87974: CALL_OW 256
87978: PUSH
87979: LD_INT 1000
87981: EQUAL
87982: PUSH
87983: LD_VAR 0 4
87987: PPUSH
87988: LD_VAR 0 13
87992: PPUSH
87993: CALL_OW 296
87997: PUSH
87998: LD_INT 40
88000: LESS
88001: PUSH
88002: LD_VAR 0 13
88006: PPUSH
88007: LD_EXP 68
88011: PUSH
88012: LD_VAR 0 1
88016: ARRAY
88017: PPUSH
88018: CALL_OW 308
88022: OR
88023: AND
88024: IFFALSE 88146
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
88026: LD_VAR 0 4
88030: PPUSH
88031: CALL_OW 262
88035: PUSH
88036: LD_INT 1
88038: EQUAL
88039: PUSH
88040: LD_VAR 0 4
88044: PPUSH
88045: CALL_OW 261
88049: PUSH
88050: LD_INT 30
88052: LESS
88053: AND
88054: PUSH
88055: LD_VAR 0 7
88059: AND
88060: IFFALSE 88130
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
88062: LD_VAR 0 4
88066: PPUSH
88067: LD_VAR 0 7
88071: PPUSH
88072: LD_VAR 0 4
88076: PPUSH
88077: CALL_OW 74
88081: PPUSH
88082: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
88086: LD_VAR 0 4
88090: PPUSH
88091: LD_VAR 0 7
88095: PPUSH
88096: LD_VAR 0 4
88100: PPUSH
88101: CALL_OW 74
88105: PPUSH
88106: CALL_OW 296
88110: PUSH
88111: LD_INT 6
88113: LESS
88114: IFFALSE 88128
// SetFuel ( i , 100 ) ;
88116: LD_VAR 0 4
88120: PPUSH
88121: LD_INT 100
88123: PPUSH
88124: CALL_OW 240
// end else
88128: GO 88144
// ComAttackUnit ( i , e ) ;
88130: LD_VAR 0 4
88134: PPUSH
88135: LD_VAR 0 13
88139: PPUSH
88140: CALL_OW 115
// end else
88144: GO 88247
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88146: LD_VAR 0 13
88150: PPUSH
88151: LD_EXP 68
88155: PUSH
88156: LD_VAR 0 1
88160: ARRAY
88161: PPUSH
88162: CALL_OW 308
88166: NOT
88167: PUSH
88168: LD_VAR 0 4
88172: PPUSH
88173: LD_VAR 0 13
88177: PPUSH
88178: CALL_OW 296
88182: PUSH
88183: LD_INT 40
88185: GREATEREQUAL
88186: AND
88187: PUSH
88188: LD_VAR 0 4
88192: PPUSH
88193: CALL_OW 256
88197: PUSH
88198: LD_INT 650
88200: LESSEQUAL
88201: OR
88202: PUSH
88203: LD_VAR 0 4
88207: PPUSH
88208: LD_EXP 67
88212: PUSH
88213: LD_VAR 0 1
88217: ARRAY
88218: PPUSH
88219: CALL_OW 308
88223: NOT
88224: AND
88225: IFFALSE 88247
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88227: LD_VAR 0 4
88231: PPUSH
88232: LD_EXP 67
88236: PUSH
88237: LD_VAR 0 1
88241: ARRAY
88242: PPUSH
88243: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88247: LD_VAR 0 4
88251: PPUSH
88252: CALL_OW 256
88256: PUSH
88257: LD_INT 1000
88259: LESS
88260: PUSH
88261: LD_VAR 0 4
88265: PPUSH
88266: CALL_OW 263
88270: PUSH
88271: LD_INT 1
88273: EQUAL
88274: AND
88275: PUSH
88276: LD_VAR 0 4
88280: PPUSH
88281: CALL_OW 311
88285: AND
88286: PUSH
88287: LD_VAR 0 4
88291: PPUSH
88292: LD_EXP 67
88296: PUSH
88297: LD_VAR 0 1
88301: ARRAY
88302: PPUSH
88303: CALL_OW 308
88307: AND
88308: IFFALSE 88362
// begin mech := IsDrivenBy ( i ) ;
88310: LD_ADDR_VAR 0 9
88314: PUSH
88315: LD_VAR 0 4
88319: PPUSH
88320: CALL_OW 311
88324: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88325: LD_VAR 0 9
88329: PPUSH
88330: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
88334: LD_VAR 0 9
88338: PPUSH
88339: LD_VAR 0 4
88343: PPUSH
88344: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
88348: LD_VAR 0 9
88352: PPUSH
88353: LD_VAR 0 4
88357: PPUSH
88358: CALL_OW 180
// end ; end ; unit_human :
88362: GO 88709
88364: LD_INT 1
88366: DOUBLE
88367: EQUAL
88368: IFTRUE 88372
88370: GO 88708
88372: POP
// begin b := IsInUnit ( i ) ;
88373: LD_ADDR_VAR 0 18
88377: PUSH
88378: LD_VAR 0 4
88382: PPUSH
88383: CALL_OW 310
88387: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88388: LD_ADDR_VAR 0 19
88392: PUSH
88393: LD_VAR 0 18
88397: NOT
88398: PUSH
88399: LD_VAR 0 18
88403: PPUSH
88404: CALL_OW 266
88408: PUSH
88409: LD_INT 32
88411: PUSH
88412: LD_INT 31
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: IN
88419: OR
88420: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88421: LD_VAR 0 18
88425: PPUSH
88426: CALL_OW 266
88430: PUSH
88431: LD_INT 5
88433: EQUAL
88434: PUSH
88435: LD_VAR 0 4
88439: PPUSH
88440: CALL_OW 257
88444: PUSH
88445: LD_INT 1
88447: PUSH
88448: LD_INT 2
88450: PUSH
88451: LD_INT 3
88453: PUSH
88454: LD_INT 4
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: IN
88463: AND
88464: IFFALSE 88501
// begin class := AllowSpecClass ( i ) ;
88466: LD_ADDR_VAR 0 20
88470: PUSH
88471: LD_VAR 0 4
88475: PPUSH
88476: CALL 11637 0 1
88480: ST_TO_ADDR
// if class then
88481: LD_VAR 0 20
88485: IFFALSE 88501
// ComChangeProfession ( i , class ) ;
88487: LD_VAR 0 4
88491: PPUSH
88492: LD_VAR 0 20
88496: PPUSH
88497: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88501: LD_VAR 0 16
88505: PUSH
88506: LD_VAR 0 2
88510: PPUSH
88511: LD_INT 21
88513: PUSH
88514: LD_INT 2
88516: PUSH
88517: EMPTY
88518: LIST
88519: LIST
88520: PPUSH
88521: CALL_OW 72
88525: PUSH
88526: LD_INT 1
88528: LESSEQUAL
88529: OR
88530: PUSH
88531: LD_VAR 0 19
88535: AND
88536: PUSH
88537: LD_VAR 0 4
88541: PUSH
88542: LD_VAR 0 17
88546: IN
88547: NOT
88548: AND
88549: IFFALSE 88642
// begin if b then
88551: LD_VAR 0 18
88555: IFFALSE 88604
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88557: LD_VAR 0 18
88561: PPUSH
88562: LD_VAR 0 21
88566: PPUSH
88567: LD_VAR 0 18
88571: PPUSH
88572: CALL_OW 74
88576: PPUSH
88577: CALL_OW 296
88581: PUSH
88582: LD_INT 10
88584: LESS
88585: PUSH
88586: LD_VAR 0 18
88590: PPUSH
88591: CALL_OW 461
88595: PUSH
88596: LD_INT 7
88598: NONEQUAL
88599: AND
88600: IFFALSE 88604
// continue ;
88602: GO 87839
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88604: LD_ADDR_VAR 0 17
88608: PUSH
88609: LD_VAR 0 17
88613: PPUSH
88614: LD_VAR 0 17
88618: PUSH
88619: LD_INT 1
88621: PLUS
88622: PPUSH
88623: LD_VAR 0 4
88627: PPUSH
88628: CALL_OW 1
88632: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88633: LD_VAR 0 4
88637: PPUSH
88638: CALL_OW 122
// end ; if sold_defenders then
88642: LD_VAR 0 17
88646: IFFALSE 88706
// if i in sold_defenders then
88648: LD_VAR 0 4
88652: PUSH
88653: LD_VAR 0 17
88657: IN
88658: IFFALSE 88706
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88660: LD_VAR 0 4
88664: PPUSH
88665: CALL_OW 314
88669: NOT
88670: PUSH
88671: LD_VAR 0 4
88675: PPUSH
88676: LD_VAR 0 13
88680: PPUSH
88681: CALL_OW 296
88685: PUSH
88686: LD_INT 30
88688: LESS
88689: AND
88690: IFFALSE 88706
// ComAttackUnit ( i , e ) ;
88692: LD_VAR 0 4
88696: PPUSH
88697: LD_VAR 0 13
88701: PPUSH
88702: CALL_OW 115
// end ; end ; end ;
88706: GO 88709
88708: POP
// if IsDead ( i ) then
88709: LD_VAR 0 4
88713: PPUSH
88714: CALL_OW 301
88718: IFFALSE 88736
// defenders := defenders diff i ;
88720: LD_ADDR_VAR 0 2
88724: PUSH
88725: LD_VAR 0 2
88729: PUSH
88730: LD_VAR 0 4
88734: DIFF
88735: ST_TO_ADDR
// end ;
88736: GO 87839
88738: POP
88739: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88740: LD_VAR 0 21
88744: NOT
88745: PUSH
88746: LD_VAR 0 2
88750: NOT
88751: OR
88752: PUSH
88753: LD_EXP 43
88757: PUSH
88758: LD_VAR 0 1
88762: ARRAY
88763: NOT
88764: OR
88765: IFFALSE 87743
// MC_Reset ( base , 18 ) ;
88767: LD_VAR 0 1
88771: PPUSH
88772: LD_INT 18
88774: PPUSH
88775: CALL 55441 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88779: LD_ADDR_VAR 0 2
88783: PUSH
88784: LD_VAR 0 2
88788: PUSH
88789: LD_VAR 0 2
88793: PPUSH
88794: LD_INT 2
88796: PUSH
88797: LD_INT 25
88799: PUSH
88800: LD_INT 1
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PUSH
88807: LD_INT 25
88809: PUSH
88810: LD_INT 5
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 25
88819: PUSH
88820: LD_INT 8
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 25
88829: PUSH
88830: LD_INT 9
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: PPUSH
88844: CALL_OW 72
88848: DIFF
88849: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88850: LD_VAR 0 21
88854: NOT
88855: PUSH
88856: LD_VAR 0 2
88860: PPUSH
88861: LD_INT 21
88863: PUSH
88864: LD_INT 2
88866: PUSH
88867: EMPTY
88868: LIST
88869: LIST
88870: PPUSH
88871: CALL_OW 72
88875: AND
88876: IFFALSE 89214
// begin tmp := FilterByTag ( defenders , 19 ) ;
88878: LD_ADDR_VAR 0 11
88882: PUSH
88883: LD_VAR 0 2
88887: PPUSH
88888: LD_INT 19
88890: PPUSH
88891: CALL 44900 0 2
88895: ST_TO_ADDR
// if tmp then
88896: LD_VAR 0 11
88900: IFFALSE 88970
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88902: LD_ADDR_VAR 0 11
88906: PUSH
88907: LD_VAR 0 11
88911: PPUSH
88912: LD_INT 25
88914: PUSH
88915: LD_INT 3
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: PPUSH
88922: CALL_OW 72
88926: ST_TO_ADDR
// if tmp then
88927: LD_VAR 0 11
88931: IFFALSE 88970
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88933: LD_ADDR_EXP 55
88937: PUSH
88938: LD_EXP 55
88942: PPUSH
88943: LD_VAR 0 1
88947: PPUSH
88948: LD_EXP 55
88952: PUSH
88953: LD_VAR 0 1
88957: ARRAY
88958: PUSH
88959: LD_VAR 0 11
88963: UNION
88964: PPUSH
88965: CALL_OW 1
88969: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88970: LD_VAR 0 1
88974: PPUSH
88975: LD_INT 19
88977: PPUSH
88978: CALL 55441 0 2
// repeat wait ( 0 0$1 ) ;
88982: LD_INT 35
88984: PPUSH
88985: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88989: LD_EXP 43
88993: PUSH
88994: LD_VAR 0 1
88998: ARRAY
88999: NOT
89000: PUSH
89001: LD_EXP 43
89005: PUSH
89006: LD_VAR 0 1
89010: ARRAY
89011: PUSH
89012: EMPTY
89013: EQUAL
89014: OR
89015: IFFALSE 89052
// begin for i in defenders do
89017: LD_ADDR_VAR 0 4
89021: PUSH
89022: LD_VAR 0 2
89026: PUSH
89027: FOR_IN
89028: IFFALSE 89041
// ComStop ( i ) ;
89030: LD_VAR 0 4
89034: PPUSH
89035: CALL_OW 141
89039: GO 89027
89041: POP
89042: POP
// defenders := [ ] ;
89043: LD_ADDR_VAR 0 2
89047: PUSH
89048: EMPTY
89049: ST_TO_ADDR
// exit ;
89050: GO 89278
// end ; for i in defenders do
89052: LD_ADDR_VAR 0 4
89056: PUSH
89057: LD_VAR 0 2
89061: PUSH
89062: FOR_IN
89063: IFFALSE 89152
// begin if not IsInArea ( i , mc_parking [ base ] ) then
89065: LD_VAR 0 4
89069: PPUSH
89070: LD_EXP 67
89074: PUSH
89075: LD_VAR 0 1
89079: ARRAY
89080: PPUSH
89081: CALL_OW 308
89085: NOT
89086: IFFALSE 89110
// ComMoveToArea ( i , mc_parking [ base ] ) else
89088: LD_VAR 0 4
89092: PPUSH
89093: LD_EXP 67
89097: PUSH
89098: LD_VAR 0 1
89102: ARRAY
89103: PPUSH
89104: CALL_OW 113
89108: GO 89150
// if GetControl ( i ) = control_manual then
89110: LD_VAR 0 4
89114: PPUSH
89115: CALL_OW 263
89119: PUSH
89120: LD_INT 1
89122: EQUAL
89123: IFFALSE 89150
// if IsDrivenBy ( i ) then
89125: LD_VAR 0 4
89129: PPUSH
89130: CALL_OW 311
89134: IFFALSE 89150
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89136: LD_VAR 0 4
89140: PPUSH
89141: CALL_OW 311
89145: PPUSH
89146: CALL_OW 121
// end ;
89150: GO 89062
89152: POP
89153: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89154: LD_VAR 0 2
89158: PPUSH
89159: LD_INT 95
89161: PUSH
89162: LD_EXP 67
89166: PUSH
89167: LD_VAR 0 1
89171: ARRAY
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: PPUSH
89177: CALL_OW 72
89181: PUSH
89182: LD_VAR 0 2
89186: EQUAL
89187: PUSH
89188: LD_EXP 66
89192: PUSH
89193: LD_VAR 0 1
89197: ARRAY
89198: OR
89199: PUSH
89200: LD_EXP 43
89204: PUSH
89205: LD_VAR 0 1
89209: ARRAY
89210: NOT
89211: OR
89212: IFFALSE 88982
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89214: LD_ADDR_EXP 65
89218: PUSH
89219: LD_EXP 65
89223: PPUSH
89224: LD_VAR 0 1
89228: PPUSH
89229: LD_VAR 0 2
89233: PPUSH
89234: LD_INT 21
89236: PUSH
89237: LD_INT 2
89239: PUSH
89240: EMPTY
89241: LIST
89242: LIST
89243: PPUSH
89244: CALL_OW 72
89248: PPUSH
89249: CALL_OW 1
89253: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89254: LD_VAR 0 1
89258: PPUSH
89259: LD_INT 19
89261: PPUSH
89262: CALL 55441 0 2
// MC_Reset ( base , 20 ) ;
89266: LD_VAR 0 1
89270: PPUSH
89271: LD_INT 20
89273: PPUSH
89274: CALL 55441 0 2
// end ; end_of_file
89278: LD_VAR 0 3
89282: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89283: LD_INT 0
89285: PPUSH
89286: PPUSH
89287: PPUSH
89288: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89289: LD_VAR 0 1
89293: PPUSH
89294: CALL_OW 264
89298: PUSH
89299: LD_INT 91
89301: EQUAL
89302: IFFALSE 89374
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89304: LD_INT 68
89306: PPUSH
89307: LD_VAR 0 1
89311: PPUSH
89312: CALL_OW 255
89316: PPUSH
89317: CALL_OW 321
89321: PUSH
89322: LD_INT 2
89324: EQUAL
89325: IFFALSE 89337
// eff := 70 else
89327: LD_ADDR_VAR 0 4
89331: PUSH
89332: LD_INT 70
89334: ST_TO_ADDR
89335: GO 89345
// eff := 30 ;
89337: LD_ADDR_VAR 0 4
89341: PUSH
89342: LD_INT 30
89344: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89345: LD_VAR 0 1
89349: PPUSH
89350: CALL_OW 250
89354: PPUSH
89355: LD_VAR 0 1
89359: PPUSH
89360: CALL_OW 251
89364: PPUSH
89365: LD_VAR 0 4
89369: PPUSH
89370: CALL_OW 495
// end ; end ;
89374: LD_VAR 0 2
89378: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89379: LD_INT 0
89381: PPUSH
// end ;
89382: LD_VAR 0 4
89386: RET
// export function SOS_Command ( cmd ) ; begin
89387: LD_INT 0
89389: PPUSH
// end ;
89390: LD_VAR 0 2
89394: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89395: LD_INT 0
89397: PPUSH
// end ;
89398: LD_VAR 0 6
89402: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
89403: LD_INT 0
89405: PPUSH
89406: PPUSH
// if not vehicle or not factory then
89407: LD_VAR 0 1
89411: NOT
89412: PUSH
89413: LD_VAR 0 2
89417: NOT
89418: OR
89419: IFFALSE 89423
// exit ;
89421: GO 89654
// if factoryWaypoints >= factory then
89423: LD_EXP 157
89427: PUSH
89428: LD_VAR 0 2
89432: GREATEREQUAL
89433: IFFALSE 89654
// if factoryWaypoints [ factory ] then
89435: LD_EXP 157
89439: PUSH
89440: LD_VAR 0 2
89444: ARRAY
89445: IFFALSE 89654
// begin if GetControl ( vehicle ) = control_manual then
89447: LD_VAR 0 1
89451: PPUSH
89452: CALL_OW 263
89456: PUSH
89457: LD_INT 1
89459: EQUAL
89460: IFFALSE 89541
// begin driver := IsDrivenBy ( vehicle ) ;
89462: LD_ADDR_VAR 0 4
89466: PUSH
89467: LD_VAR 0 1
89471: PPUSH
89472: CALL_OW 311
89476: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89477: LD_VAR 0 4
89481: PPUSH
89482: LD_EXP 157
89486: PUSH
89487: LD_VAR 0 2
89491: ARRAY
89492: PUSH
89493: LD_INT 3
89495: ARRAY
89496: PPUSH
89497: LD_EXP 157
89501: PUSH
89502: LD_VAR 0 2
89506: ARRAY
89507: PUSH
89508: LD_INT 4
89510: ARRAY
89511: PPUSH
89512: CALL_OW 171
// AddComExitVehicle ( driver ) ;
89516: LD_VAR 0 4
89520: PPUSH
89521: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
89525: LD_VAR 0 4
89529: PPUSH
89530: LD_VAR 0 2
89534: PPUSH
89535: CALL_OW 180
// end else
89539: GO 89654
// if GetControl ( vehicle ) = control_remote then
89541: LD_VAR 0 1
89545: PPUSH
89546: CALL_OW 263
89550: PUSH
89551: LD_INT 2
89553: EQUAL
89554: IFFALSE 89615
// begin wait ( 0 0$2 ) ;
89556: LD_INT 70
89558: PPUSH
89559: CALL_OW 67
// if Connect ( vehicle ) then
89563: LD_VAR 0 1
89567: PPUSH
89568: CALL 17957 0 1
89572: IFFALSE 89613
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89574: LD_VAR 0 1
89578: PPUSH
89579: LD_EXP 157
89583: PUSH
89584: LD_VAR 0 2
89588: ARRAY
89589: PUSH
89590: LD_INT 3
89592: ARRAY
89593: PPUSH
89594: LD_EXP 157
89598: PUSH
89599: LD_VAR 0 2
89603: ARRAY
89604: PUSH
89605: LD_INT 4
89607: ARRAY
89608: PPUSH
89609: CALL_OW 171
// end else
89613: GO 89654
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89615: LD_VAR 0 1
89619: PPUSH
89620: LD_EXP 157
89624: PUSH
89625: LD_VAR 0 2
89629: ARRAY
89630: PUSH
89631: LD_INT 3
89633: ARRAY
89634: PPUSH
89635: LD_EXP 157
89639: PUSH
89640: LD_VAR 0 2
89644: ARRAY
89645: PUSH
89646: LD_INT 4
89648: ARRAY
89649: PPUSH
89650: CALL_OW 171
// end ; end ;
89654: LD_VAR 0 3
89658: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89659: LD_INT 0
89661: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89662: LD_VAR 0 1
89666: PUSH
89667: LD_INT 250
89669: EQUAL
89670: PUSH
89671: LD_VAR 0 2
89675: PPUSH
89676: CALL_OW 264
89680: PUSH
89681: LD_INT 81
89683: EQUAL
89684: AND
89685: IFFALSE 89706
// MinerPlaceMine ( unit , x , y ) ;
89687: LD_VAR 0 2
89691: PPUSH
89692: LD_VAR 0 4
89696: PPUSH
89697: LD_VAR 0 5
89701: PPUSH
89702: CALL 92091 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89706: LD_VAR 0 1
89710: PUSH
89711: LD_INT 251
89713: EQUAL
89714: PUSH
89715: LD_VAR 0 2
89719: PPUSH
89720: CALL_OW 264
89724: PUSH
89725: LD_INT 81
89727: EQUAL
89728: AND
89729: IFFALSE 89750
// MinerDetonateMine ( unit , x , y ) ;
89731: LD_VAR 0 2
89735: PPUSH
89736: LD_VAR 0 4
89740: PPUSH
89741: LD_VAR 0 5
89745: PPUSH
89746: CALL 92366 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89750: LD_VAR 0 1
89754: PUSH
89755: LD_INT 252
89757: EQUAL
89758: PUSH
89759: LD_VAR 0 2
89763: PPUSH
89764: CALL_OW 264
89768: PUSH
89769: LD_INT 81
89771: EQUAL
89772: AND
89773: IFFALSE 89794
// MinerCreateMinefield ( unit , x , y ) ;
89775: LD_VAR 0 2
89779: PPUSH
89780: LD_VAR 0 4
89784: PPUSH
89785: LD_VAR 0 5
89789: PPUSH
89790: CALL 92783 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89794: LD_VAR 0 1
89798: PUSH
89799: LD_INT 253
89801: EQUAL
89802: PUSH
89803: LD_VAR 0 2
89807: PPUSH
89808: CALL_OW 257
89812: PUSH
89813: LD_INT 5
89815: EQUAL
89816: AND
89817: IFFALSE 89838
// ComBinocular ( unit , x , y ) ;
89819: LD_VAR 0 2
89823: PPUSH
89824: LD_VAR 0 4
89828: PPUSH
89829: LD_VAR 0 5
89833: PPUSH
89834: CALL 93152 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89838: LD_VAR 0 1
89842: PUSH
89843: LD_INT 254
89845: EQUAL
89846: PUSH
89847: LD_VAR 0 2
89851: PPUSH
89852: CALL_OW 264
89856: PUSH
89857: LD_INT 99
89859: EQUAL
89860: AND
89861: PUSH
89862: LD_VAR 0 3
89866: PPUSH
89867: CALL_OW 263
89871: PUSH
89872: LD_INT 3
89874: EQUAL
89875: AND
89876: IFFALSE 89892
// HackDestroyVehicle ( unit , selectedUnit ) ;
89878: LD_VAR 0 2
89882: PPUSH
89883: LD_VAR 0 3
89887: PPUSH
89888: CALL 91455 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89892: LD_VAR 0 1
89896: PUSH
89897: LD_INT 255
89899: EQUAL
89900: PUSH
89901: LD_VAR 0 2
89905: PPUSH
89906: CALL_OW 264
89910: PUSH
89911: LD_INT 14
89913: PUSH
89914: LD_INT 53
89916: PUSH
89917: EMPTY
89918: LIST
89919: LIST
89920: IN
89921: AND
89922: PUSH
89923: LD_VAR 0 4
89927: PPUSH
89928: LD_VAR 0 5
89932: PPUSH
89933: CALL_OW 488
89937: AND
89938: IFFALSE 89962
// CutTreeXYR ( unit , x , y , 12 ) ;
89940: LD_VAR 0 2
89944: PPUSH
89945: LD_VAR 0 4
89949: PPUSH
89950: LD_VAR 0 5
89954: PPUSH
89955: LD_INT 12
89957: PPUSH
89958: CALL 90025 0 4
// if cmd = 256 then
89962: LD_VAR 0 1
89966: PUSH
89967: LD_INT 256
89969: EQUAL
89970: IFFALSE 89991
// SetFactoryWaypoint ( unit , x , y ) ;
89972: LD_VAR 0 2
89976: PPUSH
89977: LD_VAR 0 4
89981: PPUSH
89982: LD_VAR 0 5
89986: PPUSH
89987: CALL 108218 0 3
// if cmd = 257 then
89991: LD_VAR 0 1
89995: PUSH
89996: LD_INT 257
89998: EQUAL
89999: IFFALSE 90020
// SetWarehouseGatheringPoint ( unit , x , y ) ;
90001: LD_VAR 0 2
90005: PPUSH
90006: LD_VAR 0 4
90010: PPUSH
90011: LD_VAR 0 5
90015: PPUSH
90016: CALL 108580 0 3
// end ;
90020: LD_VAR 0 6
90024: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90025: LD_INT 0
90027: PPUSH
90028: PPUSH
90029: PPUSH
90030: PPUSH
90031: PPUSH
90032: PPUSH
90033: PPUSH
90034: PPUSH
90035: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90036: LD_VAR 0 1
90040: NOT
90041: PUSH
90042: LD_VAR 0 2
90046: PPUSH
90047: LD_VAR 0 3
90051: PPUSH
90052: CALL_OW 488
90056: NOT
90057: OR
90058: PUSH
90059: LD_VAR 0 4
90063: NOT
90064: OR
90065: IFFALSE 90069
// exit ;
90067: GO 90409
// list := [ ] ;
90069: LD_ADDR_VAR 0 13
90073: PUSH
90074: EMPTY
90075: ST_TO_ADDR
// if x - r < 0 then
90076: LD_VAR 0 2
90080: PUSH
90081: LD_VAR 0 4
90085: MINUS
90086: PUSH
90087: LD_INT 0
90089: LESS
90090: IFFALSE 90102
// min_x := 0 else
90092: LD_ADDR_VAR 0 7
90096: PUSH
90097: LD_INT 0
90099: ST_TO_ADDR
90100: GO 90118
// min_x := x - r ;
90102: LD_ADDR_VAR 0 7
90106: PUSH
90107: LD_VAR 0 2
90111: PUSH
90112: LD_VAR 0 4
90116: MINUS
90117: ST_TO_ADDR
// if y - r < 0 then
90118: LD_VAR 0 3
90122: PUSH
90123: LD_VAR 0 4
90127: MINUS
90128: PUSH
90129: LD_INT 0
90131: LESS
90132: IFFALSE 90144
// min_y := 0 else
90134: LD_ADDR_VAR 0 8
90138: PUSH
90139: LD_INT 0
90141: ST_TO_ADDR
90142: GO 90160
// min_y := y - r ;
90144: LD_ADDR_VAR 0 8
90148: PUSH
90149: LD_VAR 0 3
90153: PUSH
90154: LD_VAR 0 4
90158: MINUS
90159: ST_TO_ADDR
// max_x := x + r ;
90160: LD_ADDR_VAR 0 9
90164: PUSH
90165: LD_VAR 0 2
90169: PUSH
90170: LD_VAR 0 4
90174: PLUS
90175: ST_TO_ADDR
// max_y := y + r ;
90176: LD_ADDR_VAR 0 10
90180: PUSH
90181: LD_VAR 0 3
90185: PUSH
90186: LD_VAR 0 4
90190: PLUS
90191: ST_TO_ADDR
// for _x = min_x to max_x do
90192: LD_ADDR_VAR 0 11
90196: PUSH
90197: DOUBLE
90198: LD_VAR 0 7
90202: DEC
90203: ST_TO_ADDR
90204: LD_VAR 0 9
90208: PUSH
90209: FOR_TO
90210: IFFALSE 90327
// for _y = min_y to max_y do
90212: LD_ADDR_VAR 0 12
90216: PUSH
90217: DOUBLE
90218: LD_VAR 0 8
90222: DEC
90223: ST_TO_ADDR
90224: LD_VAR 0 10
90228: PUSH
90229: FOR_TO
90230: IFFALSE 90323
// begin if not ValidHex ( _x , _y ) then
90232: LD_VAR 0 11
90236: PPUSH
90237: LD_VAR 0 12
90241: PPUSH
90242: CALL_OW 488
90246: NOT
90247: IFFALSE 90251
// continue ;
90249: GO 90229
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90251: LD_VAR 0 11
90255: PPUSH
90256: LD_VAR 0 12
90260: PPUSH
90261: CALL_OW 351
90265: PUSH
90266: LD_VAR 0 11
90270: PPUSH
90271: LD_VAR 0 12
90275: PPUSH
90276: CALL_OW 554
90280: AND
90281: IFFALSE 90321
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90283: LD_ADDR_VAR 0 13
90287: PUSH
90288: LD_VAR 0 13
90292: PPUSH
90293: LD_VAR 0 13
90297: PUSH
90298: LD_INT 1
90300: PLUS
90301: PPUSH
90302: LD_VAR 0 11
90306: PUSH
90307: LD_VAR 0 12
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PPUSH
90316: CALL_OW 2
90320: ST_TO_ADDR
// end ;
90321: GO 90229
90323: POP
90324: POP
90325: GO 90209
90327: POP
90328: POP
// if not list then
90329: LD_VAR 0 13
90333: NOT
90334: IFFALSE 90338
// exit ;
90336: GO 90409
// for i in list do
90338: LD_ADDR_VAR 0 6
90342: PUSH
90343: LD_VAR 0 13
90347: PUSH
90348: FOR_IN
90349: IFFALSE 90407
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90351: LD_VAR 0 1
90355: PPUSH
90356: LD_STRING M
90358: PUSH
90359: LD_VAR 0 6
90363: PUSH
90364: LD_INT 1
90366: ARRAY
90367: PUSH
90368: LD_VAR 0 6
90372: PUSH
90373: LD_INT 2
90375: ARRAY
90376: PUSH
90377: LD_INT 0
90379: PUSH
90380: LD_INT 0
90382: PUSH
90383: LD_INT 0
90385: PUSH
90386: LD_INT 0
90388: PUSH
90389: EMPTY
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: PUSH
90398: EMPTY
90399: LIST
90400: PPUSH
90401: CALL_OW 447
90405: GO 90348
90407: POP
90408: POP
// end ;
90409: LD_VAR 0 5
90413: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
90414: LD_EXP 88
90418: NOT
90419: IFFALSE 90469
90421: GO 90423
90423: DISABLE
// begin initHack := true ;
90424: LD_ADDR_EXP 88
90428: PUSH
90429: LD_INT 1
90431: ST_TO_ADDR
// hackTanks := [ ] ;
90432: LD_ADDR_EXP 89
90436: PUSH
90437: EMPTY
90438: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
90439: LD_ADDR_EXP 90
90443: PUSH
90444: EMPTY
90445: ST_TO_ADDR
// hackLimit := 3 ;
90446: LD_ADDR_EXP 91
90450: PUSH
90451: LD_INT 3
90453: ST_TO_ADDR
// hackDist := 12 ;
90454: LD_ADDR_EXP 92
90458: PUSH
90459: LD_INT 12
90461: ST_TO_ADDR
// hackCounter := [ ] ;
90462: LD_ADDR_EXP 93
90466: PUSH
90467: EMPTY
90468: ST_TO_ADDR
// end ;
90469: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
90470: LD_EXP 88
90474: PUSH
90475: LD_INT 34
90477: PUSH
90478: LD_INT 99
90480: PUSH
90481: EMPTY
90482: LIST
90483: LIST
90484: PPUSH
90485: CALL_OW 69
90489: AND
90490: IFFALSE 90743
90492: GO 90494
90494: DISABLE
90495: LD_INT 0
90497: PPUSH
90498: PPUSH
// begin enable ;
90499: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
90500: LD_ADDR_VAR 0 1
90504: PUSH
90505: LD_INT 34
90507: PUSH
90508: LD_INT 99
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PPUSH
90515: CALL_OW 69
90519: PUSH
90520: FOR_IN
90521: IFFALSE 90741
// begin if not i in hackTanks then
90523: LD_VAR 0 1
90527: PUSH
90528: LD_EXP 89
90532: IN
90533: NOT
90534: IFFALSE 90617
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
90536: LD_ADDR_EXP 89
90540: PUSH
90541: LD_EXP 89
90545: PPUSH
90546: LD_EXP 89
90550: PUSH
90551: LD_INT 1
90553: PLUS
90554: PPUSH
90555: LD_VAR 0 1
90559: PPUSH
90560: CALL_OW 1
90564: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
90565: LD_ADDR_EXP 90
90569: PUSH
90570: LD_EXP 90
90574: PPUSH
90575: LD_EXP 90
90579: PUSH
90580: LD_INT 1
90582: PLUS
90583: PPUSH
90584: EMPTY
90585: PPUSH
90586: CALL_OW 1
90590: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
90591: LD_ADDR_EXP 93
90595: PUSH
90596: LD_EXP 93
90600: PPUSH
90601: LD_EXP 93
90605: PUSH
90606: LD_INT 1
90608: PLUS
90609: PPUSH
90610: EMPTY
90611: PPUSH
90612: CALL_OW 1
90616: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90617: LD_VAR 0 1
90621: PPUSH
90622: CALL_OW 302
90626: NOT
90627: IFFALSE 90640
// begin HackUnlinkAll ( i ) ;
90629: LD_VAR 0 1
90633: PPUSH
90634: CALL 90746 0 1
// continue ;
90638: GO 90520
// end ; HackCheckCapturedStatus ( i ) ;
90640: LD_VAR 0 1
90644: PPUSH
90645: CALL 91189 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90649: LD_ADDR_VAR 0 2
90653: PUSH
90654: LD_INT 81
90656: PUSH
90657: LD_VAR 0 1
90661: PPUSH
90662: CALL_OW 255
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 33
90673: PUSH
90674: LD_INT 3
90676: PUSH
90677: EMPTY
90678: LIST
90679: LIST
90680: PUSH
90681: LD_INT 91
90683: PUSH
90684: LD_VAR 0 1
90688: PUSH
90689: LD_EXP 92
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: LIST
90698: PUSH
90699: LD_INT 50
90701: PUSH
90702: EMPTY
90703: LIST
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: PPUSH
90711: CALL_OW 69
90715: ST_TO_ADDR
// if not tmp then
90716: LD_VAR 0 2
90720: NOT
90721: IFFALSE 90725
// continue ;
90723: GO 90520
// HackLink ( i , tmp ) ;
90725: LD_VAR 0 1
90729: PPUSH
90730: LD_VAR 0 2
90734: PPUSH
90735: CALL 90882 0 2
// end ;
90739: GO 90520
90741: POP
90742: POP
// end ;
90743: PPOPN 2
90745: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90746: LD_INT 0
90748: PPUSH
90749: PPUSH
90750: PPUSH
// if not hack in hackTanks then
90751: LD_VAR 0 1
90755: PUSH
90756: LD_EXP 89
90760: IN
90761: NOT
90762: IFFALSE 90766
// exit ;
90764: GO 90877
// index := GetElementIndex ( hackTanks , hack ) ;
90766: LD_ADDR_VAR 0 4
90770: PUSH
90771: LD_EXP 89
90775: PPUSH
90776: LD_VAR 0 1
90780: PPUSH
90781: CALL 14773 0 2
90785: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
90786: LD_EXP 90
90790: PUSH
90791: LD_VAR 0 4
90795: ARRAY
90796: IFFALSE 90877
// begin for i in hackTanksCaptured [ index ] do
90798: LD_ADDR_VAR 0 3
90802: PUSH
90803: LD_EXP 90
90807: PUSH
90808: LD_VAR 0 4
90812: ARRAY
90813: PUSH
90814: FOR_IN
90815: IFFALSE 90841
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
90817: LD_VAR 0 3
90821: PUSH
90822: LD_INT 1
90824: ARRAY
90825: PPUSH
90826: LD_VAR 0 3
90830: PUSH
90831: LD_INT 2
90833: ARRAY
90834: PPUSH
90835: CALL_OW 235
90839: GO 90814
90841: POP
90842: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
90843: LD_ADDR_EXP 90
90847: PUSH
90848: LD_EXP 90
90852: PPUSH
90853: LD_VAR 0 4
90857: PPUSH
90858: EMPTY
90859: PPUSH
90860: CALL_OW 1
90864: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90865: LD_VAR 0 1
90869: PPUSH
90870: LD_INT 0
90872: PPUSH
90873: CALL_OW 505
// end ; end ;
90877: LD_VAR 0 2
90881: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90882: LD_INT 0
90884: PPUSH
90885: PPUSH
90886: PPUSH
// if not hack in hackTanks or not vehicles then
90887: LD_VAR 0 1
90891: PUSH
90892: LD_EXP 89
90896: IN
90897: NOT
90898: PUSH
90899: LD_VAR 0 2
90903: NOT
90904: OR
90905: IFFALSE 90909
// exit ;
90907: GO 91184
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90909: LD_ADDR_VAR 0 2
90913: PUSH
90914: LD_VAR 0 1
90918: PPUSH
90919: LD_VAR 0 2
90923: PPUSH
90924: LD_INT 1
90926: PPUSH
90927: LD_INT 1
90929: PPUSH
90930: CALL 15423 0 4
90934: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90935: LD_ADDR_VAR 0 5
90939: PUSH
90940: LD_EXP 89
90944: PPUSH
90945: LD_VAR 0 1
90949: PPUSH
90950: CALL 14773 0 2
90954: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90955: LD_EXP 90
90959: PUSH
90960: LD_VAR 0 5
90964: ARRAY
90965: PUSH
90966: LD_EXP 91
90970: LESS
90971: IFFALSE 91160
// begin for i := 1 to vehicles do
90973: LD_ADDR_VAR 0 4
90977: PUSH
90978: DOUBLE
90979: LD_INT 1
90981: DEC
90982: ST_TO_ADDR
90983: LD_VAR 0 2
90987: PUSH
90988: FOR_TO
90989: IFFALSE 91158
// begin if hackTanksCaptured [ index ] = hackLimit then
90991: LD_EXP 90
90995: PUSH
90996: LD_VAR 0 5
91000: ARRAY
91001: PUSH
91002: LD_EXP 91
91006: EQUAL
91007: IFFALSE 91011
// break ;
91009: GO 91158
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
91011: LD_ADDR_EXP 93
91015: PUSH
91016: LD_EXP 93
91020: PPUSH
91021: LD_VAR 0 5
91025: PPUSH
91026: LD_EXP 93
91030: PUSH
91031: LD_VAR 0 5
91035: ARRAY
91036: PUSH
91037: LD_INT 1
91039: PLUS
91040: PPUSH
91041: CALL_OW 1
91045: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
91046: LD_ADDR_EXP 90
91050: PUSH
91051: LD_EXP 90
91055: PPUSH
91056: LD_VAR 0 5
91060: PUSH
91061: LD_EXP 90
91065: PUSH
91066: LD_VAR 0 5
91070: ARRAY
91071: PUSH
91072: LD_INT 1
91074: PLUS
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: PPUSH
91080: LD_VAR 0 2
91084: PUSH
91085: LD_VAR 0 4
91089: ARRAY
91090: PUSH
91091: LD_VAR 0 2
91095: PUSH
91096: LD_VAR 0 4
91100: ARRAY
91101: PPUSH
91102: CALL_OW 255
91106: PUSH
91107: EMPTY
91108: LIST
91109: LIST
91110: PPUSH
91111: CALL 14988 0 3
91115: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
91116: LD_VAR 0 2
91120: PUSH
91121: LD_VAR 0 4
91125: ARRAY
91126: PPUSH
91127: LD_VAR 0 1
91131: PPUSH
91132: CALL_OW 255
91136: PPUSH
91137: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
91141: LD_VAR 0 2
91145: PUSH
91146: LD_VAR 0 4
91150: ARRAY
91151: PPUSH
91152: CALL_OW 141
// end ;
91156: GO 90988
91158: POP
91159: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91160: LD_VAR 0 1
91164: PPUSH
91165: LD_EXP 90
91169: PUSH
91170: LD_VAR 0 5
91174: ARRAY
91175: PUSH
91176: LD_INT 0
91178: PLUS
91179: PPUSH
91180: CALL_OW 505
// end ;
91184: LD_VAR 0 3
91188: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
91189: LD_INT 0
91191: PPUSH
91192: PPUSH
91193: PPUSH
91194: PPUSH
// if not hack in hackTanks then
91195: LD_VAR 0 1
91199: PUSH
91200: LD_EXP 89
91204: IN
91205: NOT
91206: IFFALSE 91210
// exit ;
91208: GO 91450
// index := GetElementIndex ( hackTanks , hack ) ;
91210: LD_ADDR_VAR 0 4
91214: PUSH
91215: LD_EXP 89
91219: PPUSH
91220: LD_VAR 0 1
91224: PPUSH
91225: CALL 14773 0 2
91229: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
91230: LD_ADDR_VAR 0 3
91234: PUSH
91235: DOUBLE
91236: LD_EXP 90
91240: PUSH
91241: LD_VAR 0 4
91245: ARRAY
91246: INC
91247: ST_TO_ADDR
91248: LD_INT 1
91250: PUSH
91251: FOR_DOWNTO
91252: IFFALSE 91424
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
91254: LD_ADDR_VAR 0 5
91258: PUSH
91259: LD_EXP 90
91263: PUSH
91264: LD_VAR 0 4
91268: ARRAY
91269: PUSH
91270: LD_VAR 0 3
91274: ARRAY
91275: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
91276: LD_VAR 0 5
91280: PUSH
91281: LD_INT 1
91283: ARRAY
91284: PPUSH
91285: CALL_OW 302
91289: NOT
91290: PUSH
91291: LD_VAR 0 5
91295: PUSH
91296: LD_INT 1
91298: ARRAY
91299: PPUSH
91300: CALL_OW 255
91304: PUSH
91305: LD_VAR 0 1
91309: PPUSH
91310: CALL_OW 255
91314: NONEQUAL
91315: OR
91316: IFFALSE 91422
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
91318: LD_VAR 0 5
91322: PUSH
91323: LD_INT 1
91325: ARRAY
91326: PPUSH
91327: CALL_OW 305
91331: PUSH
91332: LD_VAR 0 5
91336: PUSH
91337: LD_INT 1
91339: ARRAY
91340: PPUSH
91341: CALL_OW 255
91345: PUSH
91346: LD_VAR 0 1
91350: PPUSH
91351: CALL_OW 255
91355: EQUAL
91356: AND
91357: IFFALSE 91381
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
91359: LD_VAR 0 5
91363: PUSH
91364: LD_INT 1
91366: ARRAY
91367: PPUSH
91368: LD_VAR 0 5
91372: PUSH
91373: LD_INT 2
91375: ARRAY
91376: PPUSH
91377: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
91381: LD_ADDR_EXP 90
91385: PUSH
91386: LD_EXP 90
91390: PPUSH
91391: LD_VAR 0 4
91395: PPUSH
91396: LD_EXP 90
91400: PUSH
91401: LD_VAR 0 4
91405: ARRAY
91406: PPUSH
91407: LD_VAR 0 3
91411: PPUSH
91412: CALL_OW 3
91416: PPUSH
91417: CALL_OW 1
91421: ST_TO_ADDR
// end ; end ;
91422: GO 91251
91424: POP
91425: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91426: LD_VAR 0 1
91430: PPUSH
91431: LD_EXP 90
91435: PUSH
91436: LD_VAR 0 4
91440: ARRAY
91441: PUSH
91442: LD_INT 0
91444: PLUS
91445: PPUSH
91446: CALL_OW 505
// end ;
91450: LD_VAR 0 2
91454: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
91455: LD_INT 0
91457: PPUSH
91458: PPUSH
91459: PPUSH
91460: PPUSH
// if not hack in hackTanks then
91461: LD_VAR 0 1
91465: PUSH
91466: LD_EXP 89
91470: IN
91471: NOT
91472: IFFALSE 91476
// exit ;
91474: GO 91561
// index := GetElementIndex ( hackTanks , hack ) ;
91476: LD_ADDR_VAR 0 5
91480: PUSH
91481: LD_EXP 89
91485: PPUSH
91486: LD_VAR 0 1
91490: PPUSH
91491: CALL 14773 0 2
91495: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
91496: LD_ADDR_VAR 0 4
91500: PUSH
91501: DOUBLE
91502: LD_INT 1
91504: DEC
91505: ST_TO_ADDR
91506: LD_EXP 90
91510: PUSH
91511: LD_VAR 0 5
91515: ARRAY
91516: PUSH
91517: FOR_TO
91518: IFFALSE 91559
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
91520: LD_EXP 90
91524: PUSH
91525: LD_VAR 0 5
91529: ARRAY
91530: PUSH
91531: LD_VAR 0 4
91535: ARRAY
91536: PUSH
91537: LD_INT 1
91539: ARRAY
91540: PUSH
91541: LD_VAR 0 2
91545: EQUAL
91546: IFFALSE 91557
// KillUnit ( vehicle ) ;
91548: LD_VAR 0 2
91552: PPUSH
91553: CALL_OW 66
91557: GO 91517
91559: POP
91560: POP
// end ;
91561: LD_VAR 0 3
91565: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
91566: LD_EXP 94
91570: NOT
91571: IFFALSE 91606
91573: GO 91575
91575: DISABLE
// begin initMiner := true ;
91576: LD_ADDR_EXP 94
91580: PUSH
91581: LD_INT 1
91583: ST_TO_ADDR
// minersList := [ ] ;
91584: LD_ADDR_EXP 95
91588: PUSH
91589: EMPTY
91590: ST_TO_ADDR
// minerMinesList := [ ] ;
91591: LD_ADDR_EXP 96
91595: PUSH
91596: EMPTY
91597: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
91598: LD_ADDR_EXP 97
91602: PUSH
91603: LD_INT 5
91605: ST_TO_ADDR
// end ;
91606: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
91607: LD_EXP 94
91611: PUSH
91612: LD_INT 34
91614: PUSH
91615: LD_INT 81
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: PPUSH
91622: CALL_OW 69
91626: AND
91627: IFFALSE 92088
91629: GO 91631
91631: DISABLE
91632: LD_INT 0
91634: PPUSH
91635: PPUSH
91636: PPUSH
91637: PPUSH
// begin enable ;
91638: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91639: LD_ADDR_VAR 0 1
91643: PUSH
91644: LD_INT 34
91646: PUSH
91647: LD_INT 81
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PPUSH
91654: CALL_OW 69
91658: PUSH
91659: FOR_IN
91660: IFFALSE 91732
// begin if not i in minersList then
91662: LD_VAR 0 1
91666: PUSH
91667: LD_EXP 95
91671: IN
91672: NOT
91673: IFFALSE 91730
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91675: LD_ADDR_EXP 95
91679: PUSH
91680: LD_EXP 95
91684: PPUSH
91685: LD_EXP 95
91689: PUSH
91690: LD_INT 1
91692: PLUS
91693: PPUSH
91694: LD_VAR 0 1
91698: PPUSH
91699: CALL_OW 1
91703: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91704: LD_ADDR_EXP 96
91708: PUSH
91709: LD_EXP 96
91713: PPUSH
91714: LD_EXP 96
91718: PUSH
91719: LD_INT 1
91721: PLUS
91722: PPUSH
91723: EMPTY
91724: PPUSH
91725: CALL_OW 1
91729: ST_TO_ADDR
// end end ;
91730: GO 91659
91732: POP
91733: POP
// for i := minerMinesList downto 1 do
91734: LD_ADDR_VAR 0 1
91738: PUSH
91739: DOUBLE
91740: LD_EXP 96
91744: INC
91745: ST_TO_ADDR
91746: LD_INT 1
91748: PUSH
91749: FOR_DOWNTO
91750: IFFALSE 92086
// begin if IsLive ( minersList [ i ] ) then
91752: LD_EXP 95
91756: PUSH
91757: LD_VAR 0 1
91761: ARRAY
91762: PPUSH
91763: CALL_OW 300
91767: IFFALSE 91795
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91769: LD_EXP 95
91773: PUSH
91774: LD_VAR 0 1
91778: ARRAY
91779: PPUSH
91780: LD_EXP 96
91784: PUSH
91785: LD_VAR 0 1
91789: ARRAY
91790: PPUSH
91791: CALL_OW 505
// if not minerMinesList [ i ] then
91795: LD_EXP 96
91799: PUSH
91800: LD_VAR 0 1
91804: ARRAY
91805: NOT
91806: IFFALSE 91810
// continue ;
91808: GO 91749
// for j := minerMinesList [ i ] downto 1 do
91810: LD_ADDR_VAR 0 2
91814: PUSH
91815: DOUBLE
91816: LD_EXP 96
91820: PUSH
91821: LD_VAR 0 1
91825: ARRAY
91826: INC
91827: ST_TO_ADDR
91828: LD_INT 1
91830: PUSH
91831: FOR_DOWNTO
91832: IFFALSE 92082
// begin side := GetSide ( minersList [ i ] ) ;
91834: LD_ADDR_VAR 0 3
91838: PUSH
91839: LD_EXP 95
91843: PUSH
91844: LD_VAR 0 1
91848: ARRAY
91849: PPUSH
91850: CALL_OW 255
91854: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91855: LD_ADDR_VAR 0 4
91859: PUSH
91860: LD_EXP 96
91864: PUSH
91865: LD_VAR 0 1
91869: ARRAY
91870: PUSH
91871: LD_VAR 0 2
91875: ARRAY
91876: PUSH
91877: LD_INT 1
91879: ARRAY
91880: PPUSH
91881: LD_EXP 96
91885: PUSH
91886: LD_VAR 0 1
91890: ARRAY
91891: PUSH
91892: LD_VAR 0 2
91896: ARRAY
91897: PUSH
91898: LD_INT 2
91900: ARRAY
91901: PPUSH
91902: CALL_OW 428
91906: ST_TO_ADDR
// if not tmp then
91907: LD_VAR 0 4
91911: NOT
91912: IFFALSE 91916
// continue ;
91914: GO 91831
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91916: LD_VAR 0 4
91920: PUSH
91921: LD_INT 81
91923: PUSH
91924: LD_VAR 0 3
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: PPUSH
91933: CALL_OW 69
91937: IN
91938: PUSH
91939: LD_EXP 96
91943: PUSH
91944: LD_VAR 0 1
91948: ARRAY
91949: PUSH
91950: LD_VAR 0 2
91954: ARRAY
91955: PUSH
91956: LD_INT 1
91958: ARRAY
91959: PPUSH
91960: LD_EXP 96
91964: PUSH
91965: LD_VAR 0 1
91969: ARRAY
91970: PUSH
91971: LD_VAR 0 2
91975: ARRAY
91976: PUSH
91977: LD_INT 2
91979: ARRAY
91980: PPUSH
91981: CALL_OW 458
91985: AND
91986: IFFALSE 92080
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91988: LD_EXP 96
91992: PUSH
91993: LD_VAR 0 1
91997: ARRAY
91998: PUSH
91999: LD_VAR 0 2
92003: ARRAY
92004: PUSH
92005: LD_INT 1
92007: ARRAY
92008: PPUSH
92009: LD_EXP 96
92013: PUSH
92014: LD_VAR 0 1
92018: ARRAY
92019: PUSH
92020: LD_VAR 0 2
92024: ARRAY
92025: PUSH
92026: LD_INT 2
92028: ARRAY
92029: PPUSH
92030: LD_VAR 0 3
92034: PPUSH
92035: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
92039: LD_ADDR_EXP 96
92043: PUSH
92044: LD_EXP 96
92048: PPUSH
92049: LD_VAR 0 1
92053: PPUSH
92054: LD_EXP 96
92058: PUSH
92059: LD_VAR 0 1
92063: ARRAY
92064: PPUSH
92065: LD_VAR 0 2
92069: PPUSH
92070: CALL_OW 3
92074: PPUSH
92075: CALL_OW 1
92079: ST_TO_ADDR
// end ; end ;
92080: GO 91831
92082: POP
92083: POP
// end ;
92084: GO 91749
92086: POP
92087: POP
// end ;
92088: PPOPN 4
92090: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
92091: LD_INT 0
92093: PPUSH
92094: PPUSH
// result := false ;
92095: LD_ADDR_VAR 0 4
92099: PUSH
92100: LD_INT 0
92102: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
92103: LD_VAR 0 1
92107: PPUSH
92108: CALL_OW 264
92112: PUSH
92113: LD_INT 81
92115: EQUAL
92116: NOT
92117: IFFALSE 92121
// exit ;
92119: GO 92361
// index := GetElementIndex ( minersList , unit ) ;
92121: LD_ADDR_VAR 0 5
92125: PUSH
92126: LD_EXP 95
92130: PPUSH
92131: LD_VAR 0 1
92135: PPUSH
92136: CALL 14773 0 2
92140: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
92141: LD_EXP 96
92145: PUSH
92146: LD_VAR 0 5
92150: ARRAY
92151: PUSH
92152: LD_EXP 97
92156: GREATEREQUAL
92157: IFFALSE 92161
// exit ;
92159: GO 92361
// ComMoveXY ( unit , x , y ) ;
92161: LD_VAR 0 1
92165: PPUSH
92166: LD_VAR 0 2
92170: PPUSH
92171: LD_VAR 0 3
92175: PPUSH
92176: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
92180: LD_INT 35
92182: PPUSH
92183: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
92187: LD_VAR 0 1
92191: PPUSH
92192: LD_VAR 0 2
92196: PPUSH
92197: LD_VAR 0 3
92201: PPUSH
92202: CALL 46128 0 3
92206: NOT
92207: PUSH
92208: LD_VAR 0 1
92212: PPUSH
92213: CALL_OW 314
92217: AND
92218: IFFALSE 92222
// exit ;
92220: GO 92361
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
92222: LD_VAR 0 2
92226: PPUSH
92227: LD_VAR 0 3
92231: PPUSH
92232: CALL_OW 428
92236: PUSH
92237: LD_VAR 0 1
92241: EQUAL
92242: PUSH
92243: LD_VAR 0 1
92247: PPUSH
92248: CALL_OW 314
92252: NOT
92253: AND
92254: IFFALSE 92180
// PlaySoundXY ( x , y , PlantMine ) ;
92256: LD_VAR 0 2
92260: PPUSH
92261: LD_VAR 0 3
92265: PPUSH
92266: LD_STRING PlantMine
92268: PPUSH
92269: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
92273: LD_VAR 0 2
92277: PPUSH
92278: LD_VAR 0 3
92282: PPUSH
92283: LD_VAR 0 1
92287: PPUSH
92288: CALL_OW 255
92292: PPUSH
92293: LD_INT 0
92295: PPUSH
92296: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
92300: LD_ADDR_EXP 96
92304: PUSH
92305: LD_EXP 96
92309: PPUSH
92310: LD_VAR 0 5
92314: PUSH
92315: LD_EXP 96
92319: PUSH
92320: LD_VAR 0 5
92324: ARRAY
92325: PUSH
92326: LD_INT 1
92328: PLUS
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PPUSH
92334: LD_VAR 0 2
92338: PUSH
92339: LD_VAR 0 3
92343: PUSH
92344: EMPTY
92345: LIST
92346: LIST
92347: PPUSH
92348: CALL 14988 0 3
92352: ST_TO_ADDR
// result := true ;
92353: LD_ADDR_VAR 0 4
92357: PUSH
92358: LD_INT 1
92360: ST_TO_ADDR
// end ;
92361: LD_VAR 0 4
92365: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
92366: LD_INT 0
92368: PPUSH
92369: PPUSH
92370: PPUSH
// if not unit in minersList then
92371: LD_VAR 0 1
92375: PUSH
92376: LD_EXP 95
92380: IN
92381: NOT
92382: IFFALSE 92386
// exit ;
92384: GO 92778
// index := GetElementIndex ( minersList , unit ) ;
92386: LD_ADDR_VAR 0 6
92390: PUSH
92391: LD_EXP 95
92395: PPUSH
92396: LD_VAR 0 1
92400: PPUSH
92401: CALL 14773 0 2
92405: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
92406: LD_ADDR_VAR 0 5
92410: PUSH
92411: DOUBLE
92412: LD_EXP 96
92416: PUSH
92417: LD_VAR 0 6
92421: ARRAY
92422: INC
92423: ST_TO_ADDR
92424: LD_INT 1
92426: PUSH
92427: FOR_DOWNTO
92428: IFFALSE 92589
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
92430: LD_EXP 96
92434: PUSH
92435: LD_VAR 0 6
92439: ARRAY
92440: PUSH
92441: LD_VAR 0 5
92445: ARRAY
92446: PUSH
92447: LD_INT 1
92449: ARRAY
92450: PUSH
92451: LD_VAR 0 2
92455: EQUAL
92456: PUSH
92457: LD_EXP 96
92461: PUSH
92462: LD_VAR 0 6
92466: ARRAY
92467: PUSH
92468: LD_VAR 0 5
92472: ARRAY
92473: PUSH
92474: LD_INT 2
92476: ARRAY
92477: PUSH
92478: LD_VAR 0 3
92482: EQUAL
92483: AND
92484: IFFALSE 92587
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92486: LD_EXP 96
92490: PUSH
92491: LD_VAR 0 6
92495: ARRAY
92496: PUSH
92497: LD_VAR 0 5
92501: ARRAY
92502: PUSH
92503: LD_INT 1
92505: ARRAY
92506: PPUSH
92507: LD_EXP 96
92511: PUSH
92512: LD_VAR 0 6
92516: ARRAY
92517: PUSH
92518: LD_VAR 0 5
92522: ARRAY
92523: PUSH
92524: LD_INT 2
92526: ARRAY
92527: PPUSH
92528: LD_VAR 0 1
92532: PPUSH
92533: CALL_OW 255
92537: PPUSH
92538: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92542: LD_ADDR_EXP 96
92546: PUSH
92547: LD_EXP 96
92551: PPUSH
92552: LD_VAR 0 6
92556: PPUSH
92557: LD_EXP 96
92561: PUSH
92562: LD_VAR 0 6
92566: ARRAY
92567: PPUSH
92568: LD_VAR 0 5
92572: PPUSH
92573: CALL_OW 3
92577: PPUSH
92578: CALL_OW 1
92582: ST_TO_ADDR
// exit ;
92583: POP
92584: POP
92585: GO 92778
// end ; end ;
92587: GO 92427
92589: POP
92590: POP
// for i := minerMinesList [ index ] downto 1 do
92591: LD_ADDR_VAR 0 5
92595: PUSH
92596: DOUBLE
92597: LD_EXP 96
92601: PUSH
92602: LD_VAR 0 6
92606: ARRAY
92607: INC
92608: ST_TO_ADDR
92609: LD_INT 1
92611: PUSH
92612: FOR_DOWNTO
92613: IFFALSE 92776
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92615: LD_EXP 96
92619: PUSH
92620: LD_VAR 0 6
92624: ARRAY
92625: PUSH
92626: LD_VAR 0 5
92630: ARRAY
92631: PUSH
92632: LD_INT 1
92634: ARRAY
92635: PPUSH
92636: LD_EXP 96
92640: PUSH
92641: LD_VAR 0 6
92645: ARRAY
92646: PUSH
92647: LD_VAR 0 5
92651: ARRAY
92652: PUSH
92653: LD_INT 2
92655: ARRAY
92656: PPUSH
92657: LD_VAR 0 2
92661: PPUSH
92662: LD_VAR 0 3
92666: PPUSH
92667: CALL_OW 298
92671: PUSH
92672: LD_INT 6
92674: LESS
92675: IFFALSE 92774
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92677: LD_EXP 96
92681: PUSH
92682: LD_VAR 0 6
92686: ARRAY
92687: PUSH
92688: LD_VAR 0 5
92692: ARRAY
92693: PUSH
92694: LD_INT 1
92696: ARRAY
92697: PPUSH
92698: LD_EXP 96
92702: PUSH
92703: LD_VAR 0 6
92707: ARRAY
92708: PUSH
92709: LD_VAR 0 5
92713: ARRAY
92714: PUSH
92715: LD_INT 2
92717: ARRAY
92718: PPUSH
92719: LD_VAR 0 1
92723: PPUSH
92724: CALL_OW 255
92728: PPUSH
92729: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92733: LD_ADDR_EXP 96
92737: PUSH
92738: LD_EXP 96
92742: PPUSH
92743: LD_VAR 0 6
92747: PPUSH
92748: LD_EXP 96
92752: PUSH
92753: LD_VAR 0 6
92757: ARRAY
92758: PPUSH
92759: LD_VAR 0 5
92763: PPUSH
92764: CALL_OW 3
92768: PPUSH
92769: CALL_OW 1
92773: ST_TO_ADDR
// end ; end ;
92774: GO 92612
92776: POP
92777: POP
// end ;
92778: LD_VAR 0 4
92782: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
92783: LD_INT 0
92785: PPUSH
92786: PPUSH
92787: PPUSH
92788: PPUSH
92789: PPUSH
92790: PPUSH
92791: PPUSH
92792: PPUSH
92793: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
92794: LD_VAR 0 1
92798: PPUSH
92799: CALL_OW 264
92803: PUSH
92804: LD_INT 81
92806: EQUAL
92807: NOT
92808: PUSH
92809: LD_VAR 0 1
92813: PUSH
92814: LD_EXP 95
92818: IN
92819: NOT
92820: OR
92821: IFFALSE 92825
// exit ;
92823: GO 93147
// index := GetElementIndex ( minersList , unit ) ;
92825: LD_ADDR_VAR 0 6
92829: PUSH
92830: LD_EXP 95
92834: PPUSH
92835: LD_VAR 0 1
92839: PPUSH
92840: CALL 14773 0 2
92844: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92845: LD_ADDR_VAR 0 8
92849: PUSH
92850: LD_EXP 97
92854: PUSH
92855: LD_EXP 96
92859: PUSH
92860: LD_VAR 0 6
92864: ARRAY
92865: MINUS
92866: ST_TO_ADDR
// if not minesFreeAmount then
92867: LD_VAR 0 8
92871: NOT
92872: IFFALSE 92876
// exit ;
92874: GO 93147
// tmp := [ ] ;
92876: LD_ADDR_VAR 0 7
92880: PUSH
92881: EMPTY
92882: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92883: LD_ADDR_VAR 0 5
92887: PUSH
92888: DOUBLE
92889: LD_INT 1
92891: DEC
92892: ST_TO_ADDR
92893: LD_VAR 0 8
92897: PUSH
92898: FOR_TO
92899: IFFALSE 93094
// begin _d := rand ( 0 , 5 ) ;
92901: LD_ADDR_VAR 0 11
92905: PUSH
92906: LD_INT 0
92908: PPUSH
92909: LD_INT 5
92911: PPUSH
92912: CALL_OW 12
92916: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92917: LD_ADDR_VAR 0 12
92921: PUSH
92922: LD_INT 2
92924: PPUSH
92925: LD_INT 6
92927: PPUSH
92928: CALL_OW 12
92932: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92933: LD_ADDR_VAR 0 9
92937: PUSH
92938: LD_VAR 0 2
92942: PPUSH
92943: LD_VAR 0 11
92947: PPUSH
92948: LD_VAR 0 12
92952: PPUSH
92953: CALL_OW 272
92957: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92958: LD_ADDR_VAR 0 10
92962: PUSH
92963: LD_VAR 0 3
92967: PPUSH
92968: LD_VAR 0 11
92972: PPUSH
92973: LD_VAR 0 12
92977: PPUSH
92978: CALL_OW 273
92982: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92983: LD_VAR 0 9
92987: PPUSH
92988: LD_VAR 0 10
92992: PPUSH
92993: CALL_OW 488
92997: PUSH
92998: LD_VAR 0 9
93002: PUSH
93003: LD_VAR 0 10
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_VAR 0 7
93016: IN
93017: NOT
93018: AND
93019: PUSH
93020: LD_VAR 0 9
93024: PPUSH
93025: LD_VAR 0 10
93029: PPUSH
93030: CALL_OW 458
93034: NOT
93035: AND
93036: IFFALSE 93078
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
93038: LD_ADDR_VAR 0 7
93042: PUSH
93043: LD_VAR 0 7
93047: PPUSH
93048: LD_VAR 0 7
93052: PUSH
93053: LD_INT 1
93055: PLUS
93056: PPUSH
93057: LD_VAR 0 9
93061: PUSH
93062: LD_VAR 0 10
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: PPUSH
93071: CALL_OW 1
93075: ST_TO_ADDR
93076: GO 93092
// i := i - 1 ;
93078: LD_ADDR_VAR 0 5
93082: PUSH
93083: LD_VAR 0 5
93087: PUSH
93088: LD_INT 1
93090: MINUS
93091: ST_TO_ADDR
// end ;
93092: GO 92898
93094: POP
93095: POP
// for i in tmp do
93096: LD_ADDR_VAR 0 5
93100: PUSH
93101: LD_VAR 0 7
93105: PUSH
93106: FOR_IN
93107: IFFALSE 93145
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
93109: LD_VAR 0 1
93113: PPUSH
93114: LD_VAR 0 5
93118: PUSH
93119: LD_INT 1
93121: ARRAY
93122: PPUSH
93123: LD_VAR 0 5
93127: PUSH
93128: LD_INT 2
93130: ARRAY
93131: PPUSH
93132: CALL 92091 0 3
93136: NOT
93137: IFFALSE 93143
// exit ;
93139: POP
93140: POP
93141: GO 93147
93143: GO 93106
93145: POP
93146: POP
// end ;
93147: LD_VAR 0 4
93151: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
93152: LD_INT 0
93154: PPUSH
93155: PPUSH
93156: PPUSH
93157: PPUSH
93158: PPUSH
93159: PPUSH
93160: PPUSH
// if not GetClass ( unit ) = class_sniper then
93161: LD_VAR 0 1
93165: PPUSH
93166: CALL_OW 257
93170: PUSH
93171: LD_INT 5
93173: EQUAL
93174: NOT
93175: IFFALSE 93179
// exit ;
93177: GO 93567
// dist := 8 ;
93179: LD_ADDR_VAR 0 5
93183: PUSH
93184: LD_INT 8
93186: ST_TO_ADDR
// viewRange := 12 ;
93187: LD_ADDR_VAR 0 7
93191: PUSH
93192: LD_INT 12
93194: ST_TO_ADDR
// side := GetSide ( unit ) ;
93195: LD_ADDR_VAR 0 6
93199: PUSH
93200: LD_VAR 0 1
93204: PPUSH
93205: CALL_OW 255
93209: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
93210: LD_INT 61
93212: PPUSH
93213: LD_VAR 0 6
93217: PPUSH
93218: CALL_OW 321
93222: PUSH
93223: LD_INT 2
93225: EQUAL
93226: IFFALSE 93236
// viewRange := 16 ;
93228: LD_ADDR_VAR 0 7
93232: PUSH
93233: LD_INT 16
93235: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
93236: LD_VAR 0 1
93240: PPUSH
93241: LD_VAR 0 2
93245: PPUSH
93246: LD_VAR 0 3
93250: PPUSH
93251: CALL_OW 297
93255: PUSH
93256: LD_VAR 0 5
93260: GREATER
93261: IFFALSE 93340
// begin ComMoveXY ( unit , x , y ) ;
93263: LD_VAR 0 1
93267: PPUSH
93268: LD_VAR 0 2
93272: PPUSH
93273: LD_VAR 0 3
93277: PPUSH
93278: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93282: LD_INT 35
93284: PPUSH
93285: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
93289: LD_VAR 0 1
93293: PPUSH
93294: LD_VAR 0 2
93298: PPUSH
93299: LD_VAR 0 3
93303: PPUSH
93304: CALL 46128 0 3
93308: NOT
93309: IFFALSE 93313
// exit ;
93311: GO 93567
// until GetDistUnitXY ( unit , x , y ) < dist ;
93313: LD_VAR 0 1
93317: PPUSH
93318: LD_VAR 0 2
93322: PPUSH
93323: LD_VAR 0 3
93327: PPUSH
93328: CALL_OW 297
93332: PUSH
93333: LD_VAR 0 5
93337: LESS
93338: IFFALSE 93282
// end ; ComTurnXY ( unit , x , y ) ;
93340: LD_VAR 0 1
93344: PPUSH
93345: LD_VAR 0 2
93349: PPUSH
93350: LD_VAR 0 3
93354: PPUSH
93355: CALL_OW 118
// wait ( 5 ) ;
93359: LD_INT 5
93361: PPUSH
93362: CALL_OW 67
// _d := GetDir ( unit ) ;
93366: LD_ADDR_VAR 0 10
93370: PUSH
93371: LD_VAR 0 1
93375: PPUSH
93376: CALL_OW 254
93380: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
93381: LD_ADDR_VAR 0 8
93385: PUSH
93386: LD_VAR 0 1
93390: PPUSH
93391: CALL_OW 250
93395: PPUSH
93396: LD_VAR 0 10
93400: PPUSH
93401: LD_VAR 0 5
93405: PPUSH
93406: CALL_OW 272
93410: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
93411: LD_ADDR_VAR 0 9
93415: PUSH
93416: LD_VAR 0 1
93420: PPUSH
93421: CALL_OW 251
93425: PPUSH
93426: LD_VAR 0 10
93430: PPUSH
93431: LD_VAR 0 5
93435: PPUSH
93436: CALL_OW 273
93440: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93441: LD_VAR 0 8
93445: PPUSH
93446: LD_VAR 0 9
93450: PPUSH
93451: CALL_OW 488
93455: NOT
93456: IFFALSE 93460
// exit ;
93458: GO 93567
// ComAnimCustom ( unit , 1 ) ;
93460: LD_VAR 0 1
93464: PPUSH
93465: LD_INT 1
93467: PPUSH
93468: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
93472: LD_VAR 0 8
93476: PPUSH
93477: LD_VAR 0 9
93481: PPUSH
93482: LD_VAR 0 6
93486: PPUSH
93487: LD_VAR 0 7
93491: PPUSH
93492: CALL_OW 330
// repeat wait ( 1 ) ;
93496: LD_INT 1
93498: PPUSH
93499: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
93503: LD_VAR 0 1
93507: PPUSH
93508: CALL_OW 316
93512: PUSH
93513: LD_VAR 0 1
93517: PPUSH
93518: CALL_OW 314
93522: OR
93523: PUSH
93524: LD_VAR 0 1
93528: PPUSH
93529: CALL_OW 302
93533: NOT
93534: OR
93535: PUSH
93536: LD_VAR 0 1
93540: PPUSH
93541: CALL_OW 301
93545: OR
93546: IFFALSE 93496
// RemoveSeeing ( _x , _y , side ) ;
93548: LD_VAR 0 8
93552: PPUSH
93553: LD_VAR 0 9
93557: PPUSH
93558: LD_VAR 0 6
93562: PPUSH
93563: CALL_OW 331
// end ; end_of_file
93567: LD_VAR 0 4
93571: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
93572: LD_VAR 0 1
93576: PUSH
93577: LD_INT 200
93579: DOUBLE
93580: GREATEREQUAL
93581: IFFALSE 93589
93583: LD_INT 299
93585: DOUBLE
93586: LESSEQUAL
93587: IFTRUE 93591
93589: GO 93623
93591: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
93592: LD_VAR 0 1
93596: PPUSH
93597: LD_VAR 0 2
93601: PPUSH
93602: LD_VAR 0 3
93606: PPUSH
93607: LD_VAR 0 4
93611: PPUSH
93612: LD_VAR 0 5
93616: PPUSH
93617: CALL 89659 0 5
93621: GO 93700
93623: LD_INT 300
93625: DOUBLE
93626: GREATEREQUAL
93627: IFFALSE 93635
93629: LD_INT 399
93631: DOUBLE
93632: LESSEQUAL
93633: IFTRUE 93637
93635: GO 93699
93637: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93638: LD_VAR 0 1
93642: PPUSH
93643: LD_VAR 0 2
93647: PPUSH
93648: LD_VAR 0 3
93652: PPUSH
93653: LD_VAR 0 4
93657: PPUSH
93658: LD_VAR 0 5
93662: PPUSH
93663: LD_VAR 0 6
93667: PPUSH
93668: LD_VAR 0 7
93672: PPUSH
93673: LD_VAR 0 8
93677: PPUSH
93678: LD_VAR 0 9
93682: PPUSH
93683: LD_VAR 0 10
93687: PPUSH
93688: LD_VAR 0 11
93692: PPUSH
93693: CALL 106238 0 11
93697: GO 93700
93699: POP
// end ;
93700: PPOPN 11
93702: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93703: LD_VAR 0 1
93707: PPUSH
93708: LD_VAR 0 2
93712: PPUSH
93713: LD_VAR 0 3
93717: PPUSH
93718: LD_VAR 0 4
93722: PPUSH
93723: LD_VAR 0 5
93727: PPUSH
93728: CALL 89395 0 5
// end ; end_of_file
93732: PPOPN 5
93734: END
// export globalGameSaveCounter ; every 0 0$1 do
93735: GO 93737
93737: DISABLE
// begin enable ;
93738: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93739: LD_STRING updateTimer(
93741: PUSH
93742: LD_OWVAR 1
93746: STR
93747: PUSH
93748: LD_STRING );
93750: STR
93751: PPUSH
93752: CALL_OW 559
// end ;
93756: END
// every 0 0$1 do
93757: GO 93759
93759: DISABLE
// begin globalGameSaveCounter := 0 ;
93760: LD_ADDR_EXP 98
93764: PUSH
93765: LD_INT 0
93767: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
93768: LD_STRING setGameSaveCounter(0)
93770: PPUSH
93771: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
93775: LD_STRING initStreamRollete();
93777: PPUSH
93778: CALL_OW 559
// InitStreamMode ;
93782: CALL 95108 0 0
// DefineStreamItems ( false ) ;
93786: LD_INT 0
93788: PPUSH
93789: CALL 95572 0 1
// end ;
93793: END
// export function SOS_MapStart ( ) ; begin
93794: LD_INT 0
93796: PPUSH
// if streamModeActive then
93797: LD_EXP 99
93801: IFFALSE 93810
// DefineStreamItems ( true ) ;
93803: LD_INT 1
93805: PPUSH
93806: CALL 95572 0 1
// UpdateLuaVariables ( ) ;
93810: CALL 93827 0 0
// UpdateFactoryWaypoints ( ) ;
93814: CALL 108433 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93818: CALL 108690 0 0
// end ;
93822: LD_VAR 0 1
93826: RET
// function UpdateLuaVariables ( ) ; begin
93827: LD_INT 0
93829: PPUSH
// if globalGameSaveCounter then
93830: LD_EXP 98
93834: IFFALSE 93868
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
93836: LD_ADDR_EXP 98
93840: PUSH
93841: LD_EXP 98
93845: PPUSH
93846: CALL 48680 0 1
93850: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93851: LD_STRING setGameSaveCounter(
93853: PUSH
93854: LD_EXP 98
93858: STR
93859: PUSH
93860: LD_STRING )
93862: STR
93863: PPUSH
93864: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
93868: LD_STRING setGameDifficulty(
93870: PUSH
93871: LD_OWVAR 67
93875: STR
93876: PUSH
93877: LD_STRING )
93879: STR
93880: PPUSH
93881: CALL_OW 559
// end ;
93885: LD_VAR 0 1
93889: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93890: LD_INT 0
93892: PPUSH
// if p2 = stream_mode then
93893: LD_VAR 0 2
93897: PUSH
93898: LD_INT 100
93900: EQUAL
93901: IFFALSE 94904
// begin if not StreamModeActive then
93903: LD_EXP 99
93907: NOT
93908: IFFALSE 93918
// StreamModeActive := true ;
93910: LD_ADDR_EXP 99
93914: PUSH
93915: LD_INT 1
93917: ST_TO_ADDR
// if p3 = 0 then
93918: LD_VAR 0 3
93922: PUSH
93923: LD_INT 0
93925: EQUAL
93926: IFFALSE 93932
// InitStreamMode ;
93928: CALL 95108 0 0
// if p3 = 1 then
93932: LD_VAR 0 3
93936: PUSH
93937: LD_INT 1
93939: EQUAL
93940: IFFALSE 93950
// sRocket := true ;
93942: LD_ADDR_EXP 104
93946: PUSH
93947: LD_INT 1
93949: ST_TO_ADDR
// if p3 = 2 then
93950: LD_VAR 0 3
93954: PUSH
93955: LD_INT 2
93957: EQUAL
93958: IFFALSE 93968
// sSpeed := true ;
93960: LD_ADDR_EXP 103
93964: PUSH
93965: LD_INT 1
93967: ST_TO_ADDR
// if p3 = 3 then
93968: LD_VAR 0 3
93972: PUSH
93973: LD_INT 3
93975: EQUAL
93976: IFFALSE 93986
// sEngine := true ;
93978: LD_ADDR_EXP 105
93982: PUSH
93983: LD_INT 1
93985: ST_TO_ADDR
// if p3 = 4 then
93986: LD_VAR 0 3
93990: PUSH
93991: LD_INT 4
93993: EQUAL
93994: IFFALSE 94004
// sSpec := true ;
93996: LD_ADDR_EXP 102
94000: PUSH
94001: LD_INT 1
94003: ST_TO_ADDR
// if p3 = 5 then
94004: LD_VAR 0 3
94008: PUSH
94009: LD_INT 5
94011: EQUAL
94012: IFFALSE 94022
// sLevel := true ;
94014: LD_ADDR_EXP 106
94018: PUSH
94019: LD_INT 1
94021: ST_TO_ADDR
// if p3 = 6 then
94022: LD_VAR 0 3
94026: PUSH
94027: LD_INT 6
94029: EQUAL
94030: IFFALSE 94040
// sArmoury := true ;
94032: LD_ADDR_EXP 107
94036: PUSH
94037: LD_INT 1
94039: ST_TO_ADDR
// if p3 = 7 then
94040: LD_VAR 0 3
94044: PUSH
94045: LD_INT 7
94047: EQUAL
94048: IFFALSE 94058
// sRadar := true ;
94050: LD_ADDR_EXP 108
94054: PUSH
94055: LD_INT 1
94057: ST_TO_ADDR
// if p3 = 8 then
94058: LD_VAR 0 3
94062: PUSH
94063: LD_INT 8
94065: EQUAL
94066: IFFALSE 94076
// sBunker := true ;
94068: LD_ADDR_EXP 109
94072: PUSH
94073: LD_INT 1
94075: ST_TO_ADDR
// if p3 = 9 then
94076: LD_VAR 0 3
94080: PUSH
94081: LD_INT 9
94083: EQUAL
94084: IFFALSE 94094
// sHack := true ;
94086: LD_ADDR_EXP 110
94090: PUSH
94091: LD_INT 1
94093: ST_TO_ADDR
// if p3 = 10 then
94094: LD_VAR 0 3
94098: PUSH
94099: LD_INT 10
94101: EQUAL
94102: IFFALSE 94112
// sFire := true ;
94104: LD_ADDR_EXP 111
94108: PUSH
94109: LD_INT 1
94111: ST_TO_ADDR
// if p3 = 11 then
94112: LD_VAR 0 3
94116: PUSH
94117: LD_INT 11
94119: EQUAL
94120: IFFALSE 94130
// sRefresh := true ;
94122: LD_ADDR_EXP 112
94126: PUSH
94127: LD_INT 1
94129: ST_TO_ADDR
// if p3 = 12 then
94130: LD_VAR 0 3
94134: PUSH
94135: LD_INT 12
94137: EQUAL
94138: IFFALSE 94148
// sExp := true ;
94140: LD_ADDR_EXP 113
94144: PUSH
94145: LD_INT 1
94147: ST_TO_ADDR
// if p3 = 13 then
94148: LD_VAR 0 3
94152: PUSH
94153: LD_INT 13
94155: EQUAL
94156: IFFALSE 94166
// sDepot := true ;
94158: LD_ADDR_EXP 114
94162: PUSH
94163: LD_INT 1
94165: ST_TO_ADDR
// if p3 = 14 then
94166: LD_VAR 0 3
94170: PUSH
94171: LD_INT 14
94173: EQUAL
94174: IFFALSE 94184
// sFlag := true ;
94176: LD_ADDR_EXP 115
94180: PUSH
94181: LD_INT 1
94183: ST_TO_ADDR
// if p3 = 15 then
94184: LD_VAR 0 3
94188: PUSH
94189: LD_INT 15
94191: EQUAL
94192: IFFALSE 94202
// sKamikadze := true ;
94194: LD_ADDR_EXP 123
94198: PUSH
94199: LD_INT 1
94201: ST_TO_ADDR
// if p3 = 16 then
94202: LD_VAR 0 3
94206: PUSH
94207: LD_INT 16
94209: EQUAL
94210: IFFALSE 94220
// sTroll := true ;
94212: LD_ADDR_EXP 124
94216: PUSH
94217: LD_INT 1
94219: ST_TO_ADDR
// if p3 = 17 then
94220: LD_VAR 0 3
94224: PUSH
94225: LD_INT 17
94227: EQUAL
94228: IFFALSE 94238
// sSlow := true ;
94230: LD_ADDR_EXP 125
94234: PUSH
94235: LD_INT 1
94237: ST_TO_ADDR
// if p3 = 18 then
94238: LD_VAR 0 3
94242: PUSH
94243: LD_INT 18
94245: EQUAL
94246: IFFALSE 94256
// sLack := true ;
94248: LD_ADDR_EXP 126
94252: PUSH
94253: LD_INT 1
94255: ST_TO_ADDR
// if p3 = 19 then
94256: LD_VAR 0 3
94260: PUSH
94261: LD_INT 19
94263: EQUAL
94264: IFFALSE 94274
// sTank := true ;
94266: LD_ADDR_EXP 128
94270: PUSH
94271: LD_INT 1
94273: ST_TO_ADDR
// if p3 = 20 then
94274: LD_VAR 0 3
94278: PUSH
94279: LD_INT 20
94281: EQUAL
94282: IFFALSE 94292
// sRemote := true ;
94284: LD_ADDR_EXP 129
94288: PUSH
94289: LD_INT 1
94291: ST_TO_ADDR
// if p3 = 21 then
94292: LD_VAR 0 3
94296: PUSH
94297: LD_INT 21
94299: EQUAL
94300: IFFALSE 94310
// sPowell := true ;
94302: LD_ADDR_EXP 130
94306: PUSH
94307: LD_INT 1
94309: ST_TO_ADDR
// if p3 = 22 then
94310: LD_VAR 0 3
94314: PUSH
94315: LD_INT 22
94317: EQUAL
94318: IFFALSE 94328
// sTeleport := true ;
94320: LD_ADDR_EXP 133
94324: PUSH
94325: LD_INT 1
94327: ST_TO_ADDR
// if p3 = 23 then
94328: LD_VAR 0 3
94332: PUSH
94333: LD_INT 23
94335: EQUAL
94336: IFFALSE 94346
// sOilTower := true ;
94338: LD_ADDR_EXP 135
94342: PUSH
94343: LD_INT 1
94345: ST_TO_ADDR
// if p3 = 24 then
94346: LD_VAR 0 3
94350: PUSH
94351: LD_INT 24
94353: EQUAL
94354: IFFALSE 94364
// sShovel := true ;
94356: LD_ADDR_EXP 136
94360: PUSH
94361: LD_INT 1
94363: ST_TO_ADDR
// if p3 = 25 then
94364: LD_VAR 0 3
94368: PUSH
94369: LD_INT 25
94371: EQUAL
94372: IFFALSE 94382
// sSheik := true ;
94374: LD_ADDR_EXP 137
94378: PUSH
94379: LD_INT 1
94381: ST_TO_ADDR
// if p3 = 26 then
94382: LD_VAR 0 3
94386: PUSH
94387: LD_INT 26
94389: EQUAL
94390: IFFALSE 94400
// sEarthquake := true ;
94392: LD_ADDR_EXP 139
94396: PUSH
94397: LD_INT 1
94399: ST_TO_ADDR
// if p3 = 27 then
94400: LD_VAR 0 3
94404: PUSH
94405: LD_INT 27
94407: EQUAL
94408: IFFALSE 94418
// sAI := true ;
94410: LD_ADDR_EXP 140
94414: PUSH
94415: LD_INT 1
94417: ST_TO_ADDR
// if p3 = 28 then
94418: LD_VAR 0 3
94422: PUSH
94423: LD_INT 28
94425: EQUAL
94426: IFFALSE 94436
// sCargo := true ;
94428: LD_ADDR_EXP 143
94432: PUSH
94433: LD_INT 1
94435: ST_TO_ADDR
// if p3 = 29 then
94436: LD_VAR 0 3
94440: PUSH
94441: LD_INT 29
94443: EQUAL
94444: IFFALSE 94454
// sDLaser := true ;
94446: LD_ADDR_EXP 144
94450: PUSH
94451: LD_INT 1
94453: ST_TO_ADDR
// if p3 = 30 then
94454: LD_VAR 0 3
94458: PUSH
94459: LD_INT 30
94461: EQUAL
94462: IFFALSE 94472
// sExchange := true ;
94464: LD_ADDR_EXP 145
94468: PUSH
94469: LD_INT 1
94471: ST_TO_ADDR
// if p3 = 31 then
94472: LD_VAR 0 3
94476: PUSH
94477: LD_INT 31
94479: EQUAL
94480: IFFALSE 94490
// sFac := true ;
94482: LD_ADDR_EXP 146
94486: PUSH
94487: LD_INT 1
94489: ST_TO_ADDR
// if p3 = 32 then
94490: LD_VAR 0 3
94494: PUSH
94495: LD_INT 32
94497: EQUAL
94498: IFFALSE 94508
// sPower := true ;
94500: LD_ADDR_EXP 147
94504: PUSH
94505: LD_INT 1
94507: ST_TO_ADDR
// if p3 = 33 then
94508: LD_VAR 0 3
94512: PUSH
94513: LD_INT 33
94515: EQUAL
94516: IFFALSE 94526
// sRandom := true ;
94518: LD_ADDR_EXP 148
94522: PUSH
94523: LD_INT 1
94525: ST_TO_ADDR
// if p3 = 34 then
94526: LD_VAR 0 3
94530: PUSH
94531: LD_INT 34
94533: EQUAL
94534: IFFALSE 94544
// sShield := true ;
94536: LD_ADDR_EXP 149
94540: PUSH
94541: LD_INT 1
94543: ST_TO_ADDR
// if p3 = 35 then
94544: LD_VAR 0 3
94548: PUSH
94549: LD_INT 35
94551: EQUAL
94552: IFFALSE 94562
// sTime := true ;
94554: LD_ADDR_EXP 150
94558: PUSH
94559: LD_INT 1
94561: ST_TO_ADDR
// if p3 = 36 then
94562: LD_VAR 0 3
94566: PUSH
94567: LD_INT 36
94569: EQUAL
94570: IFFALSE 94580
// sTools := true ;
94572: LD_ADDR_EXP 151
94576: PUSH
94577: LD_INT 1
94579: ST_TO_ADDR
// if p3 = 101 then
94580: LD_VAR 0 3
94584: PUSH
94585: LD_INT 101
94587: EQUAL
94588: IFFALSE 94598
// sSold := true ;
94590: LD_ADDR_EXP 116
94594: PUSH
94595: LD_INT 1
94597: ST_TO_ADDR
// if p3 = 102 then
94598: LD_VAR 0 3
94602: PUSH
94603: LD_INT 102
94605: EQUAL
94606: IFFALSE 94616
// sDiff := true ;
94608: LD_ADDR_EXP 117
94612: PUSH
94613: LD_INT 1
94615: ST_TO_ADDR
// if p3 = 103 then
94616: LD_VAR 0 3
94620: PUSH
94621: LD_INT 103
94623: EQUAL
94624: IFFALSE 94634
// sFog := true ;
94626: LD_ADDR_EXP 120
94630: PUSH
94631: LD_INT 1
94633: ST_TO_ADDR
// if p3 = 104 then
94634: LD_VAR 0 3
94638: PUSH
94639: LD_INT 104
94641: EQUAL
94642: IFFALSE 94652
// sReset := true ;
94644: LD_ADDR_EXP 121
94648: PUSH
94649: LD_INT 1
94651: ST_TO_ADDR
// if p3 = 105 then
94652: LD_VAR 0 3
94656: PUSH
94657: LD_INT 105
94659: EQUAL
94660: IFFALSE 94670
// sSun := true ;
94662: LD_ADDR_EXP 122
94666: PUSH
94667: LD_INT 1
94669: ST_TO_ADDR
// if p3 = 106 then
94670: LD_VAR 0 3
94674: PUSH
94675: LD_INT 106
94677: EQUAL
94678: IFFALSE 94688
// sTiger := true ;
94680: LD_ADDR_EXP 118
94684: PUSH
94685: LD_INT 1
94687: ST_TO_ADDR
// if p3 = 107 then
94688: LD_VAR 0 3
94692: PUSH
94693: LD_INT 107
94695: EQUAL
94696: IFFALSE 94706
// sBomb := true ;
94698: LD_ADDR_EXP 119
94702: PUSH
94703: LD_INT 1
94705: ST_TO_ADDR
// if p3 = 108 then
94706: LD_VAR 0 3
94710: PUSH
94711: LD_INT 108
94713: EQUAL
94714: IFFALSE 94724
// sWound := true ;
94716: LD_ADDR_EXP 127
94720: PUSH
94721: LD_INT 1
94723: ST_TO_ADDR
// if p3 = 109 then
94724: LD_VAR 0 3
94728: PUSH
94729: LD_INT 109
94731: EQUAL
94732: IFFALSE 94742
// sBetray := true ;
94734: LD_ADDR_EXP 131
94738: PUSH
94739: LD_INT 1
94741: ST_TO_ADDR
// if p3 = 110 then
94742: LD_VAR 0 3
94746: PUSH
94747: LD_INT 110
94749: EQUAL
94750: IFFALSE 94760
// sContamin := true ;
94752: LD_ADDR_EXP 132
94756: PUSH
94757: LD_INT 1
94759: ST_TO_ADDR
// if p3 = 111 then
94760: LD_VAR 0 3
94764: PUSH
94765: LD_INT 111
94767: EQUAL
94768: IFFALSE 94778
// sOil := true ;
94770: LD_ADDR_EXP 134
94774: PUSH
94775: LD_INT 1
94777: ST_TO_ADDR
// if p3 = 112 then
94778: LD_VAR 0 3
94782: PUSH
94783: LD_INT 112
94785: EQUAL
94786: IFFALSE 94796
// sStu := true ;
94788: LD_ADDR_EXP 138
94792: PUSH
94793: LD_INT 1
94795: ST_TO_ADDR
// if p3 = 113 then
94796: LD_VAR 0 3
94800: PUSH
94801: LD_INT 113
94803: EQUAL
94804: IFFALSE 94814
// sBazooka := true ;
94806: LD_ADDR_EXP 141
94810: PUSH
94811: LD_INT 1
94813: ST_TO_ADDR
// if p3 = 114 then
94814: LD_VAR 0 3
94818: PUSH
94819: LD_INT 114
94821: EQUAL
94822: IFFALSE 94832
// sMortar := true ;
94824: LD_ADDR_EXP 142
94828: PUSH
94829: LD_INT 1
94831: ST_TO_ADDR
// if p3 = 115 then
94832: LD_VAR 0 3
94836: PUSH
94837: LD_INT 115
94839: EQUAL
94840: IFFALSE 94850
// sRanger := true ;
94842: LD_ADDR_EXP 152
94846: PUSH
94847: LD_INT 1
94849: ST_TO_ADDR
// if p3 = 116 then
94850: LD_VAR 0 3
94854: PUSH
94855: LD_INT 116
94857: EQUAL
94858: IFFALSE 94868
// sComputer := true ;
94860: LD_ADDR_EXP 153
94864: PUSH
94865: LD_INT 1
94867: ST_TO_ADDR
// if p3 = 117 then
94868: LD_VAR 0 3
94872: PUSH
94873: LD_INT 117
94875: EQUAL
94876: IFFALSE 94886
// s30 := true ;
94878: LD_ADDR_EXP 154
94882: PUSH
94883: LD_INT 1
94885: ST_TO_ADDR
// if p3 = 118 then
94886: LD_VAR 0 3
94890: PUSH
94891: LD_INT 118
94893: EQUAL
94894: IFFALSE 94904
// s60 := true ;
94896: LD_ADDR_EXP 155
94900: PUSH
94901: LD_INT 1
94903: ST_TO_ADDR
// end ; if p2 = hack_mode then
94904: LD_VAR 0 2
94908: PUSH
94909: LD_INT 101
94911: EQUAL
94912: IFFALSE 95040
// begin case p3 of 1 :
94914: LD_VAR 0 3
94918: PUSH
94919: LD_INT 1
94921: DOUBLE
94922: EQUAL
94923: IFTRUE 94927
94925: GO 94934
94927: POP
// hHackUnlimitedResources ; 2 :
94928: CALL 107179 0 0
94932: GO 95040
94934: LD_INT 2
94936: DOUBLE
94937: EQUAL
94938: IFTRUE 94942
94940: GO 94949
94942: POP
// hHackSetLevel10 ; 3 :
94943: CALL 107312 0 0
94947: GO 95040
94949: LD_INT 3
94951: DOUBLE
94952: EQUAL
94953: IFTRUE 94957
94955: GO 94964
94957: POP
// hHackSetLevel10YourUnits ; 4 :
94958: CALL 107397 0 0
94962: GO 95040
94964: LD_INT 4
94966: DOUBLE
94967: EQUAL
94968: IFTRUE 94972
94970: GO 94979
94972: POP
// hHackInvincible ; 5 :
94973: CALL 107845 0 0
94977: GO 95040
94979: LD_INT 5
94981: DOUBLE
94982: EQUAL
94983: IFTRUE 94987
94985: GO 94994
94987: POP
// hHackInvisible ; 6 :
94988: CALL 107956 0 0
94992: GO 95040
94994: LD_INT 6
94996: DOUBLE
94997: EQUAL
94998: IFTRUE 95002
95000: GO 95009
95002: POP
// hHackChangeYourSide ; 7 :
95003: CALL 108013 0 0
95007: GO 95040
95009: LD_INT 7
95011: DOUBLE
95012: EQUAL
95013: IFTRUE 95017
95015: GO 95024
95017: POP
// hHackChangeUnitSide ; 8 :
95018: CALL 108055 0 0
95022: GO 95040
95024: LD_INT 8
95026: DOUBLE
95027: EQUAL
95028: IFTRUE 95032
95030: GO 95039
95032: POP
// hHackFog ; end ;
95033: CALL 108156 0 0
95037: GO 95040
95039: POP
// end ; if p2 = game_save_mode then
95040: LD_VAR 0 2
95044: PUSH
95045: LD_INT 102
95047: EQUAL
95048: IFFALSE 95103
// begin if p3 = 1 then
95050: LD_VAR 0 3
95054: PUSH
95055: LD_INT 1
95057: EQUAL
95058: IFFALSE 95070
// globalGameSaveCounter := p4 ;
95060: LD_ADDR_EXP 98
95064: PUSH
95065: LD_VAR 0 4
95069: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95070: LD_VAR 0 3
95074: PUSH
95075: LD_INT 2
95077: EQUAL
95078: PUSH
95079: LD_EXP 98
95083: AND
95084: IFFALSE 95103
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95086: LD_STRING setGameSaveCounter(
95088: PUSH
95089: LD_EXP 98
95093: STR
95094: PUSH
95095: LD_STRING )
95097: STR
95098: PPUSH
95099: CALL_OW 559
// end ; end ;
95103: LD_VAR 0 7
95107: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
95108: LD_INT 0
95110: PPUSH
// streamModeActive := false ;
95111: LD_ADDR_EXP 99
95115: PUSH
95116: LD_INT 0
95118: ST_TO_ADDR
// normalCounter := 36 ;
95119: LD_ADDR_EXP 100
95123: PUSH
95124: LD_INT 36
95126: ST_TO_ADDR
// hardcoreCounter := 18 ;
95127: LD_ADDR_EXP 101
95131: PUSH
95132: LD_INT 18
95134: ST_TO_ADDR
// sRocket := false ;
95135: LD_ADDR_EXP 104
95139: PUSH
95140: LD_INT 0
95142: ST_TO_ADDR
// sSpeed := false ;
95143: LD_ADDR_EXP 103
95147: PUSH
95148: LD_INT 0
95150: ST_TO_ADDR
// sEngine := false ;
95151: LD_ADDR_EXP 105
95155: PUSH
95156: LD_INT 0
95158: ST_TO_ADDR
// sSpec := false ;
95159: LD_ADDR_EXP 102
95163: PUSH
95164: LD_INT 0
95166: ST_TO_ADDR
// sLevel := false ;
95167: LD_ADDR_EXP 106
95171: PUSH
95172: LD_INT 0
95174: ST_TO_ADDR
// sArmoury := false ;
95175: LD_ADDR_EXP 107
95179: PUSH
95180: LD_INT 0
95182: ST_TO_ADDR
// sRadar := false ;
95183: LD_ADDR_EXP 108
95187: PUSH
95188: LD_INT 0
95190: ST_TO_ADDR
// sBunker := false ;
95191: LD_ADDR_EXP 109
95195: PUSH
95196: LD_INT 0
95198: ST_TO_ADDR
// sHack := false ;
95199: LD_ADDR_EXP 110
95203: PUSH
95204: LD_INT 0
95206: ST_TO_ADDR
// sFire := false ;
95207: LD_ADDR_EXP 111
95211: PUSH
95212: LD_INT 0
95214: ST_TO_ADDR
// sRefresh := false ;
95215: LD_ADDR_EXP 112
95219: PUSH
95220: LD_INT 0
95222: ST_TO_ADDR
// sExp := false ;
95223: LD_ADDR_EXP 113
95227: PUSH
95228: LD_INT 0
95230: ST_TO_ADDR
// sDepot := false ;
95231: LD_ADDR_EXP 114
95235: PUSH
95236: LD_INT 0
95238: ST_TO_ADDR
// sFlag := false ;
95239: LD_ADDR_EXP 115
95243: PUSH
95244: LD_INT 0
95246: ST_TO_ADDR
// sKamikadze := false ;
95247: LD_ADDR_EXP 123
95251: PUSH
95252: LD_INT 0
95254: ST_TO_ADDR
// sTroll := false ;
95255: LD_ADDR_EXP 124
95259: PUSH
95260: LD_INT 0
95262: ST_TO_ADDR
// sSlow := false ;
95263: LD_ADDR_EXP 125
95267: PUSH
95268: LD_INT 0
95270: ST_TO_ADDR
// sLack := false ;
95271: LD_ADDR_EXP 126
95275: PUSH
95276: LD_INT 0
95278: ST_TO_ADDR
// sTank := false ;
95279: LD_ADDR_EXP 128
95283: PUSH
95284: LD_INT 0
95286: ST_TO_ADDR
// sRemote := false ;
95287: LD_ADDR_EXP 129
95291: PUSH
95292: LD_INT 0
95294: ST_TO_ADDR
// sPowell := false ;
95295: LD_ADDR_EXP 130
95299: PUSH
95300: LD_INT 0
95302: ST_TO_ADDR
// sTeleport := false ;
95303: LD_ADDR_EXP 133
95307: PUSH
95308: LD_INT 0
95310: ST_TO_ADDR
// sOilTower := false ;
95311: LD_ADDR_EXP 135
95315: PUSH
95316: LD_INT 0
95318: ST_TO_ADDR
// sShovel := false ;
95319: LD_ADDR_EXP 136
95323: PUSH
95324: LD_INT 0
95326: ST_TO_ADDR
// sSheik := false ;
95327: LD_ADDR_EXP 137
95331: PUSH
95332: LD_INT 0
95334: ST_TO_ADDR
// sEarthquake := false ;
95335: LD_ADDR_EXP 139
95339: PUSH
95340: LD_INT 0
95342: ST_TO_ADDR
// sAI := false ;
95343: LD_ADDR_EXP 140
95347: PUSH
95348: LD_INT 0
95350: ST_TO_ADDR
// sCargo := false ;
95351: LD_ADDR_EXP 143
95355: PUSH
95356: LD_INT 0
95358: ST_TO_ADDR
// sDLaser := false ;
95359: LD_ADDR_EXP 144
95363: PUSH
95364: LD_INT 0
95366: ST_TO_ADDR
// sExchange := false ;
95367: LD_ADDR_EXP 145
95371: PUSH
95372: LD_INT 0
95374: ST_TO_ADDR
// sFac := false ;
95375: LD_ADDR_EXP 146
95379: PUSH
95380: LD_INT 0
95382: ST_TO_ADDR
// sPower := false ;
95383: LD_ADDR_EXP 147
95387: PUSH
95388: LD_INT 0
95390: ST_TO_ADDR
// sRandom := false ;
95391: LD_ADDR_EXP 148
95395: PUSH
95396: LD_INT 0
95398: ST_TO_ADDR
// sShield := false ;
95399: LD_ADDR_EXP 149
95403: PUSH
95404: LD_INT 0
95406: ST_TO_ADDR
// sTime := false ;
95407: LD_ADDR_EXP 150
95411: PUSH
95412: LD_INT 0
95414: ST_TO_ADDR
// sTools := false ;
95415: LD_ADDR_EXP 151
95419: PUSH
95420: LD_INT 0
95422: ST_TO_ADDR
// sSold := false ;
95423: LD_ADDR_EXP 116
95427: PUSH
95428: LD_INT 0
95430: ST_TO_ADDR
// sDiff := false ;
95431: LD_ADDR_EXP 117
95435: PUSH
95436: LD_INT 0
95438: ST_TO_ADDR
// sFog := false ;
95439: LD_ADDR_EXP 120
95443: PUSH
95444: LD_INT 0
95446: ST_TO_ADDR
// sReset := false ;
95447: LD_ADDR_EXP 121
95451: PUSH
95452: LD_INT 0
95454: ST_TO_ADDR
// sSun := false ;
95455: LD_ADDR_EXP 122
95459: PUSH
95460: LD_INT 0
95462: ST_TO_ADDR
// sTiger := false ;
95463: LD_ADDR_EXP 118
95467: PUSH
95468: LD_INT 0
95470: ST_TO_ADDR
// sBomb := false ;
95471: LD_ADDR_EXP 119
95475: PUSH
95476: LD_INT 0
95478: ST_TO_ADDR
// sWound := false ;
95479: LD_ADDR_EXP 127
95483: PUSH
95484: LD_INT 0
95486: ST_TO_ADDR
// sBetray := false ;
95487: LD_ADDR_EXP 131
95491: PUSH
95492: LD_INT 0
95494: ST_TO_ADDR
// sContamin := false ;
95495: LD_ADDR_EXP 132
95499: PUSH
95500: LD_INT 0
95502: ST_TO_ADDR
// sOil := false ;
95503: LD_ADDR_EXP 134
95507: PUSH
95508: LD_INT 0
95510: ST_TO_ADDR
// sStu := false ;
95511: LD_ADDR_EXP 138
95515: PUSH
95516: LD_INT 0
95518: ST_TO_ADDR
// sBazooka := false ;
95519: LD_ADDR_EXP 141
95523: PUSH
95524: LD_INT 0
95526: ST_TO_ADDR
// sMortar := false ;
95527: LD_ADDR_EXP 142
95531: PUSH
95532: LD_INT 0
95534: ST_TO_ADDR
// sRanger := false ;
95535: LD_ADDR_EXP 152
95539: PUSH
95540: LD_INT 0
95542: ST_TO_ADDR
// sComputer := false ;
95543: LD_ADDR_EXP 153
95547: PUSH
95548: LD_INT 0
95550: ST_TO_ADDR
// s30 := false ;
95551: LD_ADDR_EXP 154
95555: PUSH
95556: LD_INT 0
95558: ST_TO_ADDR
// s60 := false ;
95559: LD_ADDR_EXP 155
95563: PUSH
95564: LD_INT 0
95566: ST_TO_ADDR
// end ;
95567: LD_VAR 0 1
95571: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95572: LD_INT 0
95574: PPUSH
95575: PPUSH
95576: PPUSH
95577: PPUSH
95578: PPUSH
95579: PPUSH
95580: PPUSH
// result := [ ] ;
95581: LD_ADDR_VAR 0 2
95585: PUSH
95586: EMPTY
95587: ST_TO_ADDR
// if campaign_id = 1 then
95588: LD_OWVAR 69
95592: PUSH
95593: LD_INT 1
95595: EQUAL
95596: IFFALSE 98762
// begin case mission_number of 1 :
95598: LD_OWVAR 70
95602: PUSH
95603: LD_INT 1
95605: DOUBLE
95606: EQUAL
95607: IFTRUE 95611
95609: GO 95687
95611: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95612: LD_ADDR_VAR 0 2
95616: PUSH
95617: LD_INT 2
95619: PUSH
95620: LD_INT 4
95622: PUSH
95623: LD_INT 11
95625: PUSH
95626: LD_INT 12
95628: PUSH
95629: LD_INT 15
95631: PUSH
95632: LD_INT 16
95634: PUSH
95635: LD_INT 22
95637: PUSH
95638: LD_INT 23
95640: PUSH
95641: LD_INT 26
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: PUSH
95655: LD_INT 101
95657: PUSH
95658: LD_INT 102
95660: PUSH
95661: LD_INT 106
95663: PUSH
95664: LD_INT 116
95666: PUSH
95667: LD_INT 117
95669: PUSH
95670: LD_INT 118
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: ST_TO_ADDR
95685: GO 98760
95687: LD_INT 2
95689: DOUBLE
95690: EQUAL
95691: IFTRUE 95695
95693: GO 95779
95695: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95696: LD_ADDR_VAR 0 2
95700: PUSH
95701: LD_INT 2
95703: PUSH
95704: LD_INT 4
95706: PUSH
95707: LD_INT 11
95709: PUSH
95710: LD_INT 12
95712: PUSH
95713: LD_INT 15
95715: PUSH
95716: LD_INT 16
95718: PUSH
95719: LD_INT 22
95721: PUSH
95722: LD_INT 23
95724: PUSH
95725: LD_INT 26
95727: PUSH
95728: EMPTY
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: PUSH
95739: LD_INT 101
95741: PUSH
95742: LD_INT 102
95744: PUSH
95745: LD_INT 105
95747: PUSH
95748: LD_INT 106
95750: PUSH
95751: LD_INT 108
95753: PUSH
95754: LD_INT 116
95756: PUSH
95757: LD_INT 117
95759: PUSH
95760: LD_INT 118
95762: PUSH
95763: EMPTY
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: PUSH
95773: EMPTY
95774: LIST
95775: LIST
95776: ST_TO_ADDR
95777: GO 98760
95779: LD_INT 3
95781: DOUBLE
95782: EQUAL
95783: IFTRUE 95787
95785: GO 95875
95787: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95788: LD_ADDR_VAR 0 2
95792: PUSH
95793: LD_INT 2
95795: PUSH
95796: LD_INT 4
95798: PUSH
95799: LD_INT 5
95801: PUSH
95802: LD_INT 11
95804: PUSH
95805: LD_INT 12
95807: PUSH
95808: LD_INT 15
95810: PUSH
95811: LD_INT 16
95813: PUSH
95814: LD_INT 22
95816: PUSH
95817: LD_INT 26
95819: PUSH
95820: LD_INT 36
95822: PUSH
95823: EMPTY
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: PUSH
95835: LD_INT 101
95837: PUSH
95838: LD_INT 102
95840: PUSH
95841: LD_INT 105
95843: PUSH
95844: LD_INT 106
95846: PUSH
95847: LD_INT 108
95849: PUSH
95850: LD_INT 116
95852: PUSH
95853: LD_INT 117
95855: PUSH
95856: LD_INT 118
95858: PUSH
95859: EMPTY
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: PUSH
95869: EMPTY
95870: LIST
95871: LIST
95872: ST_TO_ADDR
95873: GO 98760
95875: LD_INT 4
95877: DOUBLE
95878: EQUAL
95879: IFTRUE 95883
95881: GO 95979
95883: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95884: LD_ADDR_VAR 0 2
95888: PUSH
95889: LD_INT 2
95891: PUSH
95892: LD_INT 4
95894: PUSH
95895: LD_INT 5
95897: PUSH
95898: LD_INT 8
95900: PUSH
95901: LD_INT 11
95903: PUSH
95904: LD_INT 12
95906: PUSH
95907: LD_INT 15
95909: PUSH
95910: LD_INT 16
95912: PUSH
95913: LD_INT 22
95915: PUSH
95916: LD_INT 23
95918: PUSH
95919: LD_INT 26
95921: PUSH
95922: LD_INT 36
95924: PUSH
95925: EMPTY
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: PUSH
95939: LD_INT 101
95941: PUSH
95942: LD_INT 102
95944: PUSH
95945: LD_INT 105
95947: PUSH
95948: LD_INT 106
95950: PUSH
95951: LD_INT 108
95953: PUSH
95954: LD_INT 116
95956: PUSH
95957: LD_INT 117
95959: PUSH
95960: LD_INT 118
95962: PUSH
95963: EMPTY
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: PUSH
95973: EMPTY
95974: LIST
95975: LIST
95976: ST_TO_ADDR
95977: GO 98760
95979: LD_INT 5
95981: DOUBLE
95982: EQUAL
95983: IFTRUE 95987
95985: GO 96099
95987: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95988: LD_ADDR_VAR 0 2
95992: PUSH
95993: LD_INT 2
95995: PUSH
95996: LD_INT 4
95998: PUSH
95999: LD_INT 5
96001: PUSH
96002: LD_INT 6
96004: PUSH
96005: LD_INT 8
96007: PUSH
96008: LD_INT 11
96010: PUSH
96011: LD_INT 12
96013: PUSH
96014: LD_INT 15
96016: PUSH
96017: LD_INT 16
96019: PUSH
96020: LD_INT 22
96022: PUSH
96023: LD_INT 23
96025: PUSH
96026: LD_INT 25
96028: PUSH
96029: LD_INT 26
96031: PUSH
96032: LD_INT 36
96034: PUSH
96035: EMPTY
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: PUSH
96051: LD_INT 101
96053: PUSH
96054: LD_INT 102
96056: PUSH
96057: LD_INT 105
96059: PUSH
96060: LD_INT 106
96062: PUSH
96063: LD_INT 108
96065: PUSH
96066: LD_INT 109
96068: PUSH
96069: LD_INT 112
96071: PUSH
96072: LD_INT 116
96074: PUSH
96075: LD_INT 117
96077: PUSH
96078: LD_INT 118
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: ST_TO_ADDR
96097: GO 98760
96099: LD_INT 6
96101: DOUBLE
96102: EQUAL
96103: IFTRUE 96107
96105: GO 96239
96107: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96108: LD_ADDR_VAR 0 2
96112: PUSH
96113: LD_INT 2
96115: PUSH
96116: LD_INT 4
96118: PUSH
96119: LD_INT 5
96121: PUSH
96122: LD_INT 6
96124: PUSH
96125: LD_INT 8
96127: PUSH
96128: LD_INT 11
96130: PUSH
96131: LD_INT 12
96133: PUSH
96134: LD_INT 15
96136: PUSH
96137: LD_INT 16
96139: PUSH
96140: LD_INT 20
96142: PUSH
96143: LD_INT 21
96145: PUSH
96146: LD_INT 22
96148: PUSH
96149: LD_INT 23
96151: PUSH
96152: LD_INT 25
96154: PUSH
96155: LD_INT 26
96157: PUSH
96158: LD_INT 30
96160: PUSH
96161: LD_INT 31
96163: PUSH
96164: LD_INT 32
96166: PUSH
96167: LD_INT 36
96169: PUSH
96170: EMPTY
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: PUSH
96191: LD_INT 101
96193: PUSH
96194: LD_INT 102
96196: PUSH
96197: LD_INT 105
96199: PUSH
96200: LD_INT 106
96202: PUSH
96203: LD_INT 108
96205: PUSH
96206: LD_INT 109
96208: PUSH
96209: LD_INT 112
96211: PUSH
96212: LD_INT 116
96214: PUSH
96215: LD_INT 117
96217: PUSH
96218: LD_INT 118
96220: PUSH
96221: EMPTY
96222: LIST
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: LIST
96230: LIST
96231: LIST
96232: PUSH
96233: EMPTY
96234: LIST
96235: LIST
96236: ST_TO_ADDR
96237: GO 98760
96239: LD_INT 7
96241: DOUBLE
96242: EQUAL
96243: IFTRUE 96247
96245: GO 96359
96247: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96248: LD_ADDR_VAR 0 2
96252: PUSH
96253: LD_INT 2
96255: PUSH
96256: LD_INT 4
96258: PUSH
96259: LD_INT 5
96261: PUSH
96262: LD_INT 7
96264: PUSH
96265: LD_INT 11
96267: PUSH
96268: LD_INT 12
96270: PUSH
96271: LD_INT 15
96273: PUSH
96274: LD_INT 16
96276: PUSH
96277: LD_INT 20
96279: PUSH
96280: LD_INT 21
96282: PUSH
96283: LD_INT 22
96285: PUSH
96286: LD_INT 23
96288: PUSH
96289: LD_INT 25
96291: PUSH
96292: LD_INT 26
96294: PUSH
96295: EMPTY
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: PUSH
96311: LD_INT 101
96313: PUSH
96314: LD_INT 102
96316: PUSH
96317: LD_INT 103
96319: PUSH
96320: LD_INT 105
96322: PUSH
96323: LD_INT 106
96325: PUSH
96326: LD_INT 108
96328: PUSH
96329: LD_INT 112
96331: PUSH
96332: LD_INT 116
96334: PUSH
96335: LD_INT 117
96337: PUSH
96338: LD_INT 118
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: PUSH
96353: EMPTY
96354: LIST
96355: LIST
96356: ST_TO_ADDR
96357: GO 98760
96359: LD_INT 8
96361: DOUBLE
96362: EQUAL
96363: IFTRUE 96367
96365: GO 96507
96367: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
96368: LD_ADDR_VAR 0 2
96372: PUSH
96373: LD_INT 2
96375: PUSH
96376: LD_INT 4
96378: PUSH
96379: LD_INT 5
96381: PUSH
96382: LD_INT 6
96384: PUSH
96385: LD_INT 7
96387: PUSH
96388: LD_INT 8
96390: PUSH
96391: LD_INT 11
96393: PUSH
96394: LD_INT 12
96396: PUSH
96397: LD_INT 15
96399: PUSH
96400: LD_INT 16
96402: PUSH
96403: LD_INT 20
96405: PUSH
96406: LD_INT 21
96408: PUSH
96409: LD_INT 22
96411: PUSH
96412: LD_INT 23
96414: PUSH
96415: LD_INT 25
96417: PUSH
96418: LD_INT 26
96420: PUSH
96421: LD_INT 30
96423: PUSH
96424: LD_INT 31
96426: PUSH
96427: LD_INT 32
96429: PUSH
96430: LD_INT 36
96432: PUSH
96433: EMPTY
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: PUSH
96455: LD_INT 101
96457: PUSH
96458: LD_INT 102
96460: PUSH
96461: LD_INT 103
96463: PUSH
96464: LD_INT 105
96466: PUSH
96467: LD_INT 106
96469: PUSH
96470: LD_INT 108
96472: PUSH
96473: LD_INT 109
96475: PUSH
96476: LD_INT 112
96478: PUSH
96479: LD_INT 116
96481: PUSH
96482: LD_INT 117
96484: PUSH
96485: LD_INT 118
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: ST_TO_ADDR
96505: GO 98760
96507: LD_INT 9
96509: DOUBLE
96510: EQUAL
96511: IFTRUE 96515
96513: GO 96663
96515: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96516: LD_ADDR_VAR 0 2
96520: PUSH
96521: LD_INT 2
96523: PUSH
96524: LD_INT 4
96526: PUSH
96527: LD_INT 5
96529: PUSH
96530: LD_INT 6
96532: PUSH
96533: LD_INT 7
96535: PUSH
96536: LD_INT 8
96538: PUSH
96539: LD_INT 11
96541: PUSH
96542: LD_INT 12
96544: PUSH
96545: LD_INT 15
96547: PUSH
96548: LD_INT 16
96550: PUSH
96551: LD_INT 20
96553: PUSH
96554: LD_INT 21
96556: PUSH
96557: LD_INT 22
96559: PUSH
96560: LD_INT 23
96562: PUSH
96563: LD_INT 25
96565: PUSH
96566: LD_INT 26
96568: PUSH
96569: LD_INT 28
96571: PUSH
96572: LD_INT 30
96574: PUSH
96575: LD_INT 31
96577: PUSH
96578: LD_INT 32
96580: PUSH
96581: LD_INT 36
96583: PUSH
96584: EMPTY
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: PUSH
96607: LD_INT 101
96609: PUSH
96610: LD_INT 102
96612: PUSH
96613: LD_INT 103
96615: PUSH
96616: LD_INT 105
96618: PUSH
96619: LD_INT 106
96621: PUSH
96622: LD_INT 108
96624: PUSH
96625: LD_INT 109
96627: PUSH
96628: LD_INT 112
96630: PUSH
96631: LD_INT 114
96633: PUSH
96634: LD_INT 116
96636: PUSH
96637: LD_INT 117
96639: PUSH
96640: LD_INT 118
96642: PUSH
96643: EMPTY
96644: LIST
96645: LIST
96646: LIST
96647: LIST
96648: LIST
96649: LIST
96650: LIST
96651: LIST
96652: LIST
96653: LIST
96654: LIST
96655: LIST
96656: PUSH
96657: EMPTY
96658: LIST
96659: LIST
96660: ST_TO_ADDR
96661: GO 98760
96663: LD_INT 10
96665: DOUBLE
96666: EQUAL
96667: IFTRUE 96671
96669: GO 96867
96671: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96672: LD_ADDR_VAR 0 2
96676: PUSH
96677: LD_INT 2
96679: PUSH
96680: LD_INT 4
96682: PUSH
96683: LD_INT 5
96685: PUSH
96686: LD_INT 6
96688: PUSH
96689: LD_INT 7
96691: PUSH
96692: LD_INT 8
96694: PUSH
96695: LD_INT 9
96697: PUSH
96698: LD_INT 10
96700: PUSH
96701: LD_INT 11
96703: PUSH
96704: LD_INT 12
96706: PUSH
96707: LD_INT 13
96709: PUSH
96710: LD_INT 14
96712: PUSH
96713: LD_INT 15
96715: PUSH
96716: LD_INT 16
96718: PUSH
96719: LD_INT 17
96721: PUSH
96722: LD_INT 18
96724: PUSH
96725: LD_INT 19
96727: PUSH
96728: LD_INT 20
96730: PUSH
96731: LD_INT 21
96733: PUSH
96734: LD_INT 22
96736: PUSH
96737: LD_INT 23
96739: PUSH
96740: LD_INT 24
96742: PUSH
96743: LD_INT 25
96745: PUSH
96746: LD_INT 26
96748: PUSH
96749: LD_INT 28
96751: PUSH
96752: LD_INT 30
96754: PUSH
96755: LD_INT 31
96757: PUSH
96758: LD_INT 32
96760: PUSH
96761: LD_INT 36
96763: PUSH
96764: EMPTY
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: LIST
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: PUSH
96795: LD_INT 101
96797: PUSH
96798: LD_INT 102
96800: PUSH
96801: LD_INT 103
96803: PUSH
96804: LD_INT 104
96806: PUSH
96807: LD_INT 105
96809: PUSH
96810: LD_INT 106
96812: PUSH
96813: LD_INT 107
96815: PUSH
96816: LD_INT 108
96818: PUSH
96819: LD_INT 109
96821: PUSH
96822: LD_INT 110
96824: PUSH
96825: LD_INT 111
96827: PUSH
96828: LD_INT 112
96830: PUSH
96831: LD_INT 114
96833: PUSH
96834: LD_INT 116
96836: PUSH
96837: LD_INT 117
96839: PUSH
96840: LD_INT 118
96842: PUSH
96843: EMPTY
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: PUSH
96861: EMPTY
96862: LIST
96863: LIST
96864: ST_TO_ADDR
96865: GO 98760
96867: LD_INT 11
96869: DOUBLE
96870: EQUAL
96871: IFTRUE 96875
96873: GO 97079
96875: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96876: LD_ADDR_VAR 0 2
96880: PUSH
96881: LD_INT 2
96883: PUSH
96884: LD_INT 3
96886: PUSH
96887: LD_INT 4
96889: PUSH
96890: LD_INT 5
96892: PUSH
96893: LD_INT 6
96895: PUSH
96896: LD_INT 7
96898: PUSH
96899: LD_INT 8
96901: PUSH
96902: LD_INT 9
96904: PUSH
96905: LD_INT 10
96907: PUSH
96908: LD_INT 11
96910: PUSH
96911: LD_INT 12
96913: PUSH
96914: LD_INT 13
96916: PUSH
96917: LD_INT 14
96919: PUSH
96920: LD_INT 15
96922: PUSH
96923: LD_INT 16
96925: PUSH
96926: LD_INT 17
96928: PUSH
96929: LD_INT 18
96931: PUSH
96932: LD_INT 19
96934: PUSH
96935: LD_INT 20
96937: PUSH
96938: LD_INT 21
96940: PUSH
96941: LD_INT 22
96943: PUSH
96944: LD_INT 23
96946: PUSH
96947: LD_INT 24
96949: PUSH
96950: LD_INT 25
96952: PUSH
96953: LD_INT 26
96955: PUSH
96956: LD_INT 28
96958: PUSH
96959: LD_INT 30
96961: PUSH
96962: LD_INT 31
96964: PUSH
96965: LD_INT 32
96967: PUSH
96968: LD_INT 34
96970: PUSH
96971: LD_INT 36
96973: PUSH
96974: EMPTY
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: LIST
96999: LIST
97000: LIST
97001: LIST
97002: LIST
97003: LIST
97004: LIST
97005: LIST
97006: PUSH
97007: LD_INT 101
97009: PUSH
97010: LD_INT 102
97012: PUSH
97013: LD_INT 103
97015: PUSH
97016: LD_INT 104
97018: PUSH
97019: LD_INT 105
97021: PUSH
97022: LD_INT 106
97024: PUSH
97025: LD_INT 107
97027: PUSH
97028: LD_INT 108
97030: PUSH
97031: LD_INT 109
97033: PUSH
97034: LD_INT 110
97036: PUSH
97037: LD_INT 111
97039: PUSH
97040: LD_INT 112
97042: PUSH
97043: LD_INT 114
97045: PUSH
97046: LD_INT 116
97048: PUSH
97049: LD_INT 117
97051: PUSH
97052: LD_INT 118
97054: PUSH
97055: EMPTY
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: PUSH
97073: EMPTY
97074: LIST
97075: LIST
97076: ST_TO_ADDR
97077: GO 98760
97079: LD_INT 12
97081: DOUBLE
97082: EQUAL
97083: IFTRUE 97087
97085: GO 97307
97087: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97088: LD_ADDR_VAR 0 2
97092: PUSH
97093: LD_INT 1
97095: PUSH
97096: LD_INT 2
97098: PUSH
97099: LD_INT 3
97101: PUSH
97102: LD_INT 4
97104: PUSH
97105: LD_INT 5
97107: PUSH
97108: LD_INT 6
97110: PUSH
97111: LD_INT 7
97113: PUSH
97114: LD_INT 8
97116: PUSH
97117: LD_INT 9
97119: PUSH
97120: LD_INT 10
97122: PUSH
97123: LD_INT 11
97125: PUSH
97126: LD_INT 12
97128: PUSH
97129: LD_INT 13
97131: PUSH
97132: LD_INT 14
97134: PUSH
97135: LD_INT 15
97137: PUSH
97138: LD_INT 16
97140: PUSH
97141: LD_INT 17
97143: PUSH
97144: LD_INT 18
97146: PUSH
97147: LD_INT 19
97149: PUSH
97150: LD_INT 20
97152: PUSH
97153: LD_INT 21
97155: PUSH
97156: LD_INT 22
97158: PUSH
97159: LD_INT 23
97161: PUSH
97162: LD_INT 24
97164: PUSH
97165: LD_INT 25
97167: PUSH
97168: LD_INT 26
97170: PUSH
97171: LD_INT 27
97173: PUSH
97174: LD_INT 28
97176: PUSH
97177: LD_INT 30
97179: PUSH
97180: LD_INT 31
97182: PUSH
97183: LD_INT 32
97185: PUSH
97186: LD_INT 33
97188: PUSH
97189: LD_INT 34
97191: PUSH
97192: LD_INT 36
97194: PUSH
97195: EMPTY
97196: LIST
97197: LIST
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: PUSH
97231: LD_INT 101
97233: PUSH
97234: LD_INT 102
97236: PUSH
97237: LD_INT 103
97239: PUSH
97240: LD_INT 104
97242: PUSH
97243: LD_INT 105
97245: PUSH
97246: LD_INT 106
97248: PUSH
97249: LD_INT 107
97251: PUSH
97252: LD_INT 108
97254: PUSH
97255: LD_INT 109
97257: PUSH
97258: LD_INT 110
97260: PUSH
97261: LD_INT 111
97263: PUSH
97264: LD_INT 112
97266: PUSH
97267: LD_INT 113
97269: PUSH
97270: LD_INT 114
97272: PUSH
97273: LD_INT 116
97275: PUSH
97276: LD_INT 117
97278: PUSH
97279: LD_INT 118
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: LIST
97286: LIST
97287: LIST
97288: LIST
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: LIST
97294: LIST
97295: LIST
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: PUSH
97301: EMPTY
97302: LIST
97303: LIST
97304: ST_TO_ADDR
97305: GO 98760
97307: LD_INT 13
97309: DOUBLE
97310: EQUAL
97311: IFTRUE 97315
97313: GO 97523
97315: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97316: LD_ADDR_VAR 0 2
97320: PUSH
97321: LD_INT 1
97323: PUSH
97324: LD_INT 2
97326: PUSH
97327: LD_INT 3
97329: PUSH
97330: LD_INT 4
97332: PUSH
97333: LD_INT 5
97335: PUSH
97336: LD_INT 8
97338: PUSH
97339: LD_INT 9
97341: PUSH
97342: LD_INT 10
97344: PUSH
97345: LD_INT 11
97347: PUSH
97348: LD_INT 12
97350: PUSH
97351: LD_INT 14
97353: PUSH
97354: LD_INT 15
97356: PUSH
97357: LD_INT 16
97359: PUSH
97360: LD_INT 17
97362: PUSH
97363: LD_INT 18
97365: PUSH
97366: LD_INT 19
97368: PUSH
97369: LD_INT 20
97371: PUSH
97372: LD_INT 21
97374: PUSH
97375: LD_INT 22
97377: PUSH
97378: LD_INT 23
97380: PUSH
97381: LD_INT 24
97383: PUSH
97384: LD_INT 25
97386: PUSH
97387: LD_INT 26
97389: PUSH
97390: LD_INT 27
97392: PUSH
97393: LD_INT 28
97395: PUSH
97396: LD_INT 30
97398: PUSH
97399: LD_INT 31
97401: PUSH
97402: LD_INT 32
97404: PUSH
97405: LD_INT 33
97407: PUSH
97408: LD_INT 34
97410: PUSH
97411: LD_INT 36
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: LIST
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: PUSH
97447: LD_INT 101
97449: PUSH
97450: LD_INT 102
97452: PUSH
97453: LD_INT 103
97455: PUSH
97456: LD_INT 104
97458: PUSH
97459: LD_INT 105
97461: PUSH
97462: LD_INT 106
97464: PUSH
97465: LD_INT 107
97467: PUSH
97468: LD_INT 108
97470: PUSH
97471: LD_INT 109
97473: PUSH
97474: LD_INT 110
97476: PUSH
97477: LD_INT 111
97479: PUSH
97480: LD_INT 112
97482: PUSH
97483: LD_INT 113
97485: PUSH
97486: LD_INT 114
97488: PUSH
97489: LD_INT 116
97491: PUSH
97492: LD_INT 117
97494: PUSH
97495: LD_INT 118
97497: PUSH
97498: EMPTY
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: PUSH
97517: EMPTY
97518: LIST
97519: LIST
97520: ST_TO_ADDR
97521: GO 98760
97523: LD_INT 14
97525: DOUBLE
97526: EQUAL
97527: IFTRUE 97531
97529: GO 97755
97531: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97532: LD_ADDR_VAR 0 2
97536: PUSH
97537: LD_INT 1
97539: PUSH
97540: LD_INT 2
97542: PUSH
97543: LD_INT 3
97545: PUSH
97546: LD_INT 4
97548: PUSH
97549: LD_INT 5
97551: PUSH
97552: LD_INT 6
97554: PUSH
97555: LD_INT 7
97557: PUSH
97558: LD_INT 8
97560: PUSH
97561: LD_INT 9
97563: PUSH
97564: LD_INT 10
97566: PUSH
97567: LD_INT 11
97569: PUSH
97570: LD_INT 12
97572: PUSH
97573: LD_INT 13
97575: PUSH
97576: LD_INT 14
97578: PUSH
97579: LD_INT 15
97581: PUSH
97582: LD_INT 16
97584: PUSH
97585: LD_INT 17
97587: PUSH
97588: LD_INT 18
97590: PUSH
97591: LD_INT 19
97593: PUSH
97594: LD_INT 20
97596: PUSH
97597: LD_INT 21
97599: PUSH
97600: LD_INT 22
97602: PUSH
97603: LD_INT 23
97605: PUSH
97606: LD_INT 24
97608: PUSH
97609: LD_INT 25
97611: PUSH
97612: LD_INT 26
97614: PUSH
97615: LD_INT 27
97617: PUSH
97618: LD_INT 28
97620: PUSH
97621: LD_INT 29
97623: PUSH
97624: LD_INT 30
97626: PUSH
97627: LD_INT 31
97629: PUSH
97630: LD_INT 32
97632: PUSH
97633: LD_INT 33
97635: PUSH
97636: LD_INT 34
97638: PUSH
97639: LD_INT 36
97641: PUSH
97642: EMPTY
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: LIST
97653: LIST
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: PUSH
97679: LD_INT 101
97681: PUSH
97682: LD_INT 102
97684: PUSH
97685: LD_INT 103
97687: PUSH
97688: LD_INT 104
97690: PUSH
97691: LD_INT 105
97693: PUSH
97694: LD_INT 106
97696: PUSH
97697: LD_INT 107
97699: PUSH
97700: LD_INT 108
97702: PUSH
97703: LD_INT 109
97705: PUSH
97706: LD_INT 110
97708: PUSH
97709: LD_INT 111
97711: PUSH
97712: LD_INT 112
97714: PUSH
97715: LD_INT 113
97717: PUSH
97718: LD_INT 114
97720: PUSH
97721: LD_INT 116
97723: PUSH
97724: LD_INT 117
97726: PUSH
97727: LD_INT 118
97729: PUSH
97730: EMPTY
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: PUSH
97749: EMPTY
97750: LIST
97751: LIST
97752: ST_TO_ADDR
97753: GO 98760
97755: LD_INT 15
97757: DOUBLE
97758: EQUAL
97759: IFTRUE 97763
97761: GO 97987
97763: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97764: LD_ADDR_VAR 0 2
97768: PUSH
97769: LD_INT 1
97771: PUSH
97772: LD_INT 2
97774: PUSH
97775: LD_INT 3
97777: PUSH
97778: LD_INT 4
97780: PUSH
97781: LD_INT 5
97783: PUSH
97784: LD_INT 6
97786: PUSH
97787: LD_INT 7
97789: PUSH
97790: LD_INT 8
97792: PUSH
97793: LD_INT 9
97795: PUSH
97796: LD_INT 10
97798: PUSH
97799: LD_INT 11
97801: PUSH
97802: LD_INT 12
97804: PUSH
97805: LD_INT 13
97807: PUSH
97808: LD_INT 14
97810: PUSH
97811: LD_INT 15
97813: PUSH
97814: LD_INT 16
97816: PUSH
97817: LD_INT 17
97819: PUSH
97820: LD_INT 18
97822: PUSH
97823: LD_INT 19
97825: PUSH
97826: LD_INT 20
97828: PUSH
97829: LD_INT 21
97831: PUSH
97832: LD_INT 22
97834: PUSH
97835: LD_INT 23
97837: PUSH
97838: LD_INT 24
97840: PUSH
97841: LD_INT 25
97843: PUSH
97844: LD_INT 26
97846: PUSH
97847: LD_INT 27
97849: PUSH
97850: LD_INT 28
97852: PUSH
97853: LD_INT 29
97855: PUSH
97856: LD_INT 30
97858: PUSH
97859: LD_INT 31
97861: PUSH
97862: LD_INT 32
97864: PUSH
97865: LD_INT 33
97867: PUSH
97868: LD_INT 34
97870: PUSH
97871: LD_INT 36
97873: PUSH
97874: EMPTY
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: PUSH
97911: LD_INT 101
97913: PUSH
97914: LD_INT 102
97916: PUSH
97917: LD_INT 103
97919: PUSH
97920: LD_INT 104
97922: PUSH
97923: LD_INT 105
97925: PUSH
97926: LD_INT 106
97928: PUSH
97929: LD_INT 107
97931: PUSH
97932: LD_INT 108
97934: PUSH
97935: LD_INT 109
97937: PUSH
97938: LD_INT 110
97940: PUSH
97941: LD_INT 111
97943: PUSH
97944: LD_INT 112
97946: PUSH
97947: LD_INT 113
97949: PUSH
97950: LD_INT 114
97952: PUSH
97953: LD_INT 116
97955: PUSH
97956: LD_INT 117
97958: PUSH
97959: LD_INT 118
97961: PUSH
97962: EMPTY
97963: LIST
97964: LIST
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: PUSH
97981: EMPTY
97982: LIST
97983: LIST
97984: ST_TO_ADDR
97985: GO 98760
97987: LD_INT 16
97989: DOUBLE
97990: EQUAL
97991: IFTRUE 97995
97993: GO 98131
97995: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97996: LD_ADDR_VAR 0 2
98000: PUSH
98001: LD_INT 2
98003: PUSH
98004: LD_INT 4
98006: PUSH
98007: LD_INT 5
98009: PUSH
98010: LD_INT 7
98012: PUSH
98013: LD_INT 11
98015: PUSH
98016: LD_INT 12
98018: PUSH
98019: LD_INT 15
98021: PUSH
98022: LD_INT 16
98024: PUSH
98025: LD_INT 20
98027: PUSH
98028: LD_INT 21
98030: PUSH
98031: LD_INT 22
98033: PUSH
98034: LD_INT 23
98036: PUSH
98037: LD_INT 25
98039: PUSH
98040: LD_INT 26
98042: PUSH
98043: LD_INT 30
98045: PUSH
98046: LD_INT 31
98048: PUSH
98049: LD_INT 32
98051: PUSH
98052: LD_INT 33
98054: PUSH
98055: LD_INT 34
98057: PUSH
98058: EMPTY
98059: LIST
98060: LIST
98061: LIST
98062: LIST
98063: LIST
98064: LIST
98065: LIST
98066: LIST
98067: LIST
98068: LIST
98069: LIST
98070: LIST
98071: LIST
98072: LIST
98073: LIST
98074: LIST
98075: LIST
98076: LIST
98077: LIST
98078: PUSH
98079: LD_INT 101
98081: PUSH
98082: LD_INT 102
98084: PUSH
98085: LD_INT 103
98087: PUSH
98088: LD_INT 106
98090: PUSH
98091: LD_INT 108
98093: PUSH
98094: LD_INT 112
98096: PUSH
98097: LD_INT 113
98099: PUSH
98100: LD_INT 114
98102: PUSH
98103: LD_INT 116
98105: PUSH
98106: LD_INT 117
98108: PUSH
98109: LD_INT 118
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: ST_TO_ADDR
98129: GO 98760
98131: LD_INT 17
98133: DOUBLE
98134: EQUAL
98135: IFTRUE 98139
98137: GO 98363
98139: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98140: LD_ADDR_VAR 0 2
98144: PUSH
98145: LD_INT 1
98147: PUSH
98148: LD_INT 2
98150: PUSH
98151: LD_INT 3
98153: PUSH
98154: LD_INT 4
98156: PUSH
98157: LD_INT 5
98159: PUSH
98160: LD_INT 6
98162: PUSH
98163: LD_INT 7
98165: PUSH
98166: LD_INT 8
98168: PUSH
98169: LD_INT 9
98171: PUSH
98172: LD_INT 10
98174: PUSH
98175: LD_INT 11
98177: PUSH
98178: LD_INT 12
98180: PUSH
98181: LD_INT 13
98183: PUSH
98184: LD_INT 14
98186: PUSH
98187: LD_INT 15
98189: PUSH
98190: LD_INT 16
98192: PUSH
98193: LD_INT 17
98195: PUSH
98196: LD_INT 18
98198: PUSH
98199: LD_INT 19
98201: PUSH
98202: LD_INT 20
98204: PUSH
98205: LD_INT 21
98207: PUSH
98208: LD_INT 22
98210: PUSH
98211: LD_INT 23
98213: PUSH
98214: LD_INT 24
98216: PUSH
98217: LD_INT 25
98219: PUSH
98220: LD_INT 26
98222: PUSH
98223: LD_INT 27
98225: PUSH
98226: LD_INT 28
98228: PUSH
98229: LD_INT 29
98231: PUSH
98232: LD_INT 30
98234: PUSH
98235: LD_INT 31
98237: PUSH
98238: LD_INT 32
98240: PUSH
98241: LD_INT 33
98243: PUSH
98244: LD_INT 34
98246: PUSH
98247: LD_INT 36
98249: PUSH
98250: EMPTY
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: LIST
98271: LIST
98272: LIST
98273: LIST
98274: LIST
98275: LIST
98276: LIST
98277: LIST
98278: LIST
98279: LIST
98280: LIST
98281: LIST
98282: LIST
98283: LIST
98284: LIST
98285: LIST
98286: PUSH
98287: LD_INT 101
98289: PUSH
98290: LD_INT 102
98292: PUSH
98293: LD_INT 103
98295: PUSH
98296: LD_INT 104
98298: PUSH
98299: LD_INT 105
98301: PUSH
98302: LD_INT 106
98304: PUSH
98305: LD_INT 107
98307: PUSH
98308: LD_INT 108
98310: PUSH
98311: LD_INT 109
98313: PUSH
98314: LD_INT 110
98316: PUSH
98317: LD_INT 111
98319: PUSH
98320: LD_INT 112
98322: PUSH
98323: LD_INT 113
98325: PUSH
98326: LD_INT 114
98328: PUSH
98329: LD_INT 116
98331: PUSH
98332: LD_INT 117
98334: PUSH
98335: LD_INT 118
98337: PUSH
98338: EMPTY
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: PUSH
98357: EMPTY
98358: LIST
98359: LIST
98360: ST_TO_ADDR
98361: GO 98760
98363: LD_INT 18
98365: DOUBLE
98366: EQUAL
98367: IFTRUE 98371
98369: GO 98519
98371: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
98372: LD_ADDR_VAR 0 2
98376: PUSH
98377: LD_INT 2
98379: PUSH
98380: LD_INT 4
98382: PUSH
98383: LD_INT 5
98385: PUSH
98386: LD_INT 7
98388: PUSH
98389: LD_INT 11
98391: PUSH
98392: LD_INT 12
98394: PUSH
98395: LD_INT 15
98397: PUSH
98398: LD_INT 16
98400: PUSH
98401: LD_INT 20
98403: PUSH
98404: LD_INT 21
98406: PUSH
98407: LD_INT 22
98409: PUSH
98410: LD_INT 23
98412: PUSH
98413: LD_INT 25
98415: PUSH
98416: LD_INT 26
98418: PUSH
98419: LD_INT 30
98421: PUSH
98422: LD_INT 31
98424: PUSH
98425: LD_INT 32
98427: PUSH
98428: LD_INT 33
98430: PUSH
98431: LD_INT 34
98433: PUSH
98434: LD_INT 35
98436: PUSH
98437: LD_INT 36
98439: PUSH
98440: EMPTY
98441: LIST
98442: LIST
98443: LIST
98444: LIST
98445: LIST
98446: LIST
98447: LIST
98448: LIST
98449: LIST
98450: LIST
98451: LIST
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: LIST
98459: LIST
98460: LIST
98461: LIST
98462: PUSH
98463: LD_INT 101
98465: PUSH
98466: LD_INT 102
98468: PUSH
98469: LD_INT 103
98471: PUSH
98472: LD_INT 106
98474: PUSH
98475: LD_INT 108
98477: PUSH
98478: LD_INT 112
98480: PUSH
98481: LD_INT 113
98483: PUSH
98484: LD_INT 114
98486: PUSH
98487: LD_INT 115
98489: PUSH
98490: LD_INT 116
98492: PUSH
98493: LD_INT 117
98495: PUSH
98496: LD_INT 118
98498: PUSH
98499: EMPTY
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: LIST
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: ST_TO_ADDR
98517: GO 98760
98519: LD_INT 19
98521: DOUBLE
98522: EQUAL
98523: IFTRUE 98527
98525: GO 98759
98527: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98528: LD_ADDR_VAR 0 2
98532: PUSH
98533: LD_INT 1
98535: PUSH
98536: LD_INT 2
98538: PUSH
98539: LD_INT 3
98541: PUSH
98542: LD_INT 4
98544: PUSH
98545: LD_INT 5
98547: PUSH
98548: LD_INT 6
98550: PUSH
98551: LD_INT 7
98553: PUSH
98554: LD_INT 8
98556: PUSH
98557: LD_INT 9
98559: PUSH
98560: LD_INT 10
98562: PUSH
98563: LD_INT 11
98565: PUSH
98566: LD_INT 12
98568: PUSH
98569: LD_INT 13
98571: PUSH
98572: LD_INT 14
98574: PUSH
98575: LD_INT 15
98577: PUSH
98578: LD_INT 16
98580: PUSH
98581: LD_INT 17
98583: PUSH
98584: LD_INT 18
98586: PUSH
98587: LD_INT 19
98589: PUSH
98590: LD_INT 20
98592: PUSH
98593: LD_INT 21
98595: PUSH
98596: LD_INT 22
98598: PUSH
98599: LD_INT 23
98601: PUSH
98602: LD_INT 24
98604: PUSH
98605: LD_INT 25
98607: PUSH
98608: LD_INT 26
98610: PUSH
98611: LD_INT 27
98613: PUSH
98614: LD_INT 28
98616: PUSH
98617: LD_INT 29
98619: PUSH
98620: LD_INT 30
98622: PUSH
98623: LD_INT 31
98625: PUSH
98626: LD_INT 32
98628: PUSH
98629: LD_INT 33
98631: PUSH
98632: LD_INT 34
98634: PUSH
98635: LD_INT 35
98637: PUSH
98638: LD_INT 36
98640: PUSH
98641: EMPTY
98642: LIST
98643: LIST
98644: LIST
98645: LIST
98646: LIST
98647: LIST
98648: LIST
98649: LIST
98650: LIST
98651: LIST
98652: LIST
98653: LIST
98654: LIST
98655: LIST
98656: LIST
98657: LIST
98658: LIST
98659: LIST
98660: LIST
98661: LIST
98662: LIST
98663: LIST
98664: LIST
98665: LIST
98666: LIST
98667: LIST
98668: LIST
98669: LIST
98670: LIST
98671: LIST
98672: LIST
98673: LIST
98674: LIST
98675: LIST
98676: LIST
98677: LIST
98678: PUSH
98679: LD_INT 101
98681: PUSH
98682: LD_INT 102
98684: PUSH
98685: LD_INT 103
98687: PUSH
98688: LD_INT 104
98690: PUSH
98691: LD_INT 105
98693: PUSH
98694: LD_INT 106
98696: PUSH
98697: LD_INT 107
98699: PUSH
98700: LD_INT 108
98702: PUSH
98703: LD_INT 109
98705: PUSH
98706: LD_INT 110
98708: PUSH
98709: LD_INT 111
98711: PUSH
98712: LD_INT 112
98714: PUSH
98715: LD_INT 113
98717: PUSH
98718: LD_INT 114
98720: PUSH
98721: LD_INT 115
98723: PUSH
98724: LD_INT 116
98726: PUSH
98727: LD_INT 117
98729: PUSH
98730: LD_INT 118
98732: PUSH
98733: EMPTY
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: ST_TO_ADDR
98757: GO 98760
98759: POP
// end else
98760: GO 98991
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98762: LD_ADDR_VAR 0 2
98766: PUSH
98767: LD_INT 1
98769: PUSH
98770: LD_INT 2
98772: PUSH
98773: LD_INT 3
98775: PUSH
98776: LD_INT 4
98778: PUSH
98779: LD_INT 5
98781: PUSH
98782: LD_INT 6
98784: PUSH
98785: LD_INT 7
98787: PUSH
98788: LD_INT 8
98790: PUSH
98791: LD_INT 9
98793: PUSH
98794: LD_INT 10
98796: PUSH
98797: LD_INT 11
98799: PUSH
98800: LD_INT 12
98802: PUSH
98803: LD_INT 13
98805: PUSH
98806: LD_INT 14
98808: PUSH
98809: LD_INT 15
98811: PUSH
98812: LD_INT 16
98814: PUSH
98815: LD_INT 17
98817: PUSH
98818: LD_INT 18
98820: PUSH
98821: LD_INT 19
98823: PUSH
98824: LD_INT 20
98826: PUSH
98827: LD_INT 21
98829: PUSH
98830: LD_INT 22
98832: PUSH
98833: LD_INT 23
98835: PUSH
98836: LD_INT 24
98838: PUSH
98839: LD_INT 25
98841: PUSH
98842: LD_INT 26
98844: PUSH
98845: LD_INT 27
98847: PUSH
98848: LD_INT 28
98850: PUSH
98851: LD_INT 29
98853: PUSH
98854: LD_INT 30
98856: PUSH
98857: LD_INT 31
98859: PUSH
98860: LD_INT 32
98862: PUSH
98863: LD_INT 33
98865: PUSH
98866: LD_INT 34
98868: PUSH
98869: LD_INT 35
98871: PUSH
98872: LD_INT 36
98874: PUSH
98875: EMPTY
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: LIST
98883: LIST
98884: LIST
98885: LIST
98886: LIST
98887: LIST
98888: LIST
98889: LIST
98890: LIST
98891: LIST
98892: LIST
98893: LIST
98894: LIST
98895: LIST
98896: LIST
98897: LIST
98898: LIST
98899: LIST
98900: LIST
98901: LIST
98902: LIST
98903: LIST
98904: LIST
98905: LIST
98906: LIST
98907: LIST
98908: LIST
98909: LIST
98910: LIST
98911: LIST
98912: PUSH
98913: LD_INT 101
98915: PUSH
98916: LD_INT 102
98918: PUSH
98919: LD_INT 103
98921: PUSH
98922: LD_INT 104
98924: PUSH
98925: LD_INT 105
98927: PUSH
98928: LD_INT 106
98930: PUSH
98931: LD_INT 107
98933: PUSH
98934: LD_INT 108
98936: PUSH
98937: LD_INT 109
98939: PUSH
98940: LD_INT 110
98942: PUSH
98943: LD_INT 111
98945: PUSH
98946: LD_INT 112
98948: PUSH
98949: LD_INT 113
98951: PUSH
98952: LD_INT 114
98954: PUSH
98955: LD_INT 115
98957: PUSH
98958: LD_INT 116
98960: PUSH
98961: LD_INT 117
98963: PUSH
98964: LD_INT 118
98966: PUSH
98967: EMPTY
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: PUSH
98987: EMPTY
98988: LIST
98989: LIST
98990: ST_TO_ADDR
// if result then
98991: LD_VAR 0 2
98995: IFFALSE 99781
// begin normal :=  ;
98997: LD_ADDR_VAR 0 5
99001: PUSH
99002: LD_STRING 
99004: ST_TO_ADDR
// hardcore :=  ;
99005: LD_ADDR_VAR 0 6
99009: PUSH
99010: LD_STRING 
99012: ST_TO_ADDR
// active :=  ;
99013: LD_ADDR_VAR 0 7
99017: PUSH
99018: LD_STRING 
99020: ST_TO_ADDR
// for i = 1 to normalCounter do
99021: LD_ADDR_VAR 0 8
99025: PUSH
99026: DOUBLE
99027: LD_INT 1
99029: DEC
99030: ST_TO_ADDR
99031: LD_EXP 100
99035: PUSH
99036: FOR_TO
99037: IFFALSE 99138
// begin tmp := 0 ;
99039: LD_ADDR_VAR 0 3
99043: PUSH
99044: LD_STRING 0
99046: ST_TO_ADDR
// if result [ 1 ] then
99047: LD_VAR 0 2
99051: PUSH
99052: LD_INT 1
99054: ARRAY
99055: IFFALSE 99120
// if result [ 1 ] [ 1 ] = i then
99057: LD_VAR 0 2
99061: PUSH
99062: LD_INT 1
99064: ARRAY
99065: PUSH
99066: LD_INT 1
99068: ARRAY
99069: PUSH
99070: LD_VAR 0 8
99074: EQUAL
99075: IFFALSE 99120
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99077: LD_ADDR_VAR 0 2
99081: PUSH
99082: LD_VAR 0 2
99086: PPUSH
99087: LD_INT 1
99089: PPUSH
99090: LD_VAR 0 2
99094: PUSH
99095: LD_INT 1
99097: ARRAY
99098: PPUSH
99099: LD_INT 1
99101: PPUSH
99102: CALL_OW 3
99106: PPUSH
99107: CALL_OW 1
99111: ST_TO_ADDR
// tmp := 1 ;
99112: LD_ADDR_VAR 0 3
99116: PUSH
99117: LD_STRING 1
99119: ST_TO_ADDR
// end ; normal := normal & tmp ;
99120: LD_ADDR_VAR 0 5
99124: PUSH
99125: LD_VAR 0 5
99129: PUSH
99130: LD_VAR 0 3
99134: STR
99135: ST_TO_ADDR
// end ;
99136: GO 99036
99138: POP
99139: POP
// for i = 1 to hardcoreCounter do
99140: LD_ADDR_VAR 0 8
99144: PUSH
99145: DOUBLE
99146: LD_INT 1
99148: DEC
99149: ST_TO_ADDR
99150: LD_EXP 101
99154: PUSH
99155: FOR_TO
99156: IFFALSE 99261
// begin tmp := 0 ;
99158: LD_ADDR_VAR 0 3
99162: PUSH
99163: LD_STRING 0
99165: ST_TO_ADDR
// if result [ 2 ] then
99166: LD_VAR 0 2
99170: PUSH
99171: LD_INT 2
99173: ARRAY
99174: IFFALSE 99243
// if result [ 2 ] [ 1 ] = 100 + i then
99176: LD_VAR 0 2
99180: PUSH
99181: LD_INT 2
99183: ARRAY
99184: PUSH
99185: LD_INT 1
99187: ARRAY
99188: PUSH
99189: LD_INT 100
99191: PUSH
99192: LD_VAR 0 8
99196: PLUS
99197: EQUAL
99198: IFFALSE 99243
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99200: LD_ADDR_VAR 0 2
99204: PUSH
99205: LD_VAR 0 2
99209: PPUSH
99210: LD_INT 2
99212: PPUSH
99213: LD_VAR 0 2
99217: PUSH
99218: LD_INT 2
99220: ARRAY
99221: PPUSH
99222: LD_INT 1
99224: PPUSH
99225: CALL_OW 3
99229: PPUSH
99230: CALL_OW 1
99234: ST_TO_ADDR
// tmp := 1 ;
99235: LD_ADDR_VAR 0 3
99239: PUSH
99240: LD_STRING 1
99242: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99243: LD_ADDR_VAR 0 6
99247: PUSH
99248: LD_VAR 0 6
99252: PUSH
99253: LD_VAR 0 3
99257: STR
99258: ST_TO_ADDR
// end ;
99259: GO 99155
99261: POP
99262: POP
// if isGameLoad then
99263: LD_VAR 0 1
99267: IFFALSE 99742
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99269: LD_ADDR_VAR 0 4
99273: PUSH
99274: LD_EXP 104
99278: PUSH
99279: LD_EXP 103
99283: PUSH
99284: LD_EXP 105
99288: PUSH
99289: LD_EXP 102
99293: PUSH
99294: LD_EXP 106
99298: PUSH
99299: LD_EXP 107
99303: PUSH
99304: LD_EXP 108
99308: PUSH
99309: LD_EXP 109
99313: PUSH
99314: LD_EXP 110
99318: PUSH
99319: LD_EXP 111
99323: PUSH
99324: LD_EXP 112
99328: PUSH
99329: LD_EXP 113
99333: PUSH
99334: LD_EXP 114
99338: PUSH
99339: LD_EXP 115
99343: PUSH
99344: LD_EXP 123
99348: PUSH
99349: LD_EXP 124
99353: PUSH
99354: LD_EXP 125
99358: PUSH
99359: LD_EXP 126
99363: PUSH
99364: LD_EXP 128
99368: PUSH
99369: LD_EXP 129
99373: PUSH
99374: LD_EXP 130
99378: PUSH
99379: LD_EXP 133
99383: PUSH
99384: LD_EXP 135
99388: PUSH
99389: LD_EXP 136
99393: PUSH
99394: LD_EXP 137
99398: PUSH
99399: LD_EXP 139
99403: PUSH
99404: LD_EXP 140
99408: PUSH
99409: LD_EXP 143
99413: PUSH
99414: LD_EXP 144
99418: PUSH
99419: LD_EXP 145
99423: PUSH
99424: LD_EXP 146
99428: PUSH
99429: LD_EXP 147
99433: PUSH
99434: LD_EXP 148
99438: PUSH
99439: LD_EXP 149
99443: PUSH
99444: LD_EXP 150
99448: PUSH
99449: LD_EXP 151
99453: PUSH
99454: LD_EXP 116
99458: PUSH
99459: LD_EXP 117
99463: PUSH
99464: LD_EXP 120
99468: PUSH
99469: LD_EXP 121
99473: PUSH
99474: LD_EXP 122
99478: PUSH
99479: LD_EXP 118
99483: PUSH
99484: LD_EXP 119
99488: PUSH
99489: LD_EXP 127
99493: PUSH
99494: LD_EXP 131
99498: PUSH
99499: LD_EXP 132
99503: PUSH
99504: LD_EXP 134
99508: PUSH
99509: LD_EXP 138
99513: PUSH
99514: LD_EXP 141
99518: PUSH
99519: LD_EXP 142
99523: PUSH
99524: LD_EXP 152
99528: PUSH
99529: LD_EXP 153
99533: PUSH
99534: LD_EXP 154
99538: PUSH
99539: LD_EXP 155
99543: PUSH
99544: EMPTY
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: LIST
99564: LIST
99565: LIST
99566: LIST
99567: LIST
99568: LIST
99569: LIST
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: LIST
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: LIST
99594: LIST
99595: LIST
99596: LIST
99597: LIST
99598: LIST
99599: ST_TO_ADDR
// tmp :=  ;
99600: LD_ADDR_VAR 0 3
99604: PUSH
99605: LD_STRING 
99607: ST_TO_ADDR
// for i = 1 to normalCounter do
99608: LD_ADDR_VAR 0 8
99612: PUSH
99613: DOUBLE
99614: LD_INT 1
99616: DEC
99617: ST_TO_ADDR
99618: LD_EXP 100
99622: PUSH
99623: FOR_TO
99624: IFFALSE 99660
// begin if flags [ i ] then
99626: LD_VAR 0 4
99630: PUSH
99631: LD_VAR 0 8
99635: ARRAY
99636: IFFALSE 99658
// tmp := tmp & i & ; ;
99638: LD_ADDR_VAR 0 3
99642: PUSH
99643: LD_VAR 0 3
99647: PUSH
99648: LD_VAR 0 8
99652: STR
99653: PUSH
99654: LD_STRING ;
99656: STR
99657: ST_TO_ADDR
// end ;
99658: GO 99623
99660: POP
99661: POP
// for i = 1 to hardcoreCounter do
99662: LD_ADDR_VAR 0 8
99666: PUSH
99667: DOUBLE
99668: LD_INT 1
99670: DEC
99671: ST_TO_ADDR
99672: LD_EXP 101
99676: PUSH
99677: FOR_TO
99678: IFFALSE 99724
// begin if flags [ normalCounter + i ] then
99680: LD_VAR 0 4
99684: PUSH
99685: LD_EXP 100
99689: PUSH
99690: LD_VAR 0 8
99694: PLUS
99695: ARRAY
99696: IFFALSE 99722
// tmp := tmp & ( 100 + i ) & ; ;
99698: LD_ADDR_VAR 0 3
99702: PUSH
99703: LD_VAR 0 3
99707: PUSH
99708: LD_INT 100
99710: PUSH
99711: LD_VAR 0 8
99715: PLUS
99716: STR
99717: PUSH
99718: LD_STRING ;
99720: STR
99721: ST_TO_ADDR
// end ;
99722: GO 99677
99724: POP
99725: POP
// if tmp then
99726: LD_VAR 0 3
99730: IFFALSE 99742
// active := tmp ;
99732: LD_ADDR_VAR 0 7
99736: PUSH
99737: LD_VAR 0 3
99741: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99742: LD_STRING getStreamItemsFromMission("
99744: PUSH
99745: LD_VAR 0 5
99749: STR
99750: PUSH
99751: LD_STRING ","
99753: STR
99754: PUSH
99755: LD_VAR 0 6
99759: STR
99760: PUSH
99761: LD_STRING ","
99763: STR
99764: PUSH
99765: LD_VAR 0 7
99769: STR
99770: PUSH
99771: LD_STRING ")
99773: STR
99774: PPUSH
99775: CALL_OW 559
// end else
99779: GO 99788
// ToLua ( getStreamItemsFromMission("","","") ) ;
99781: LD_STRING getStreamItemsFromMission("","","")
99783: PPUSH
99784: CALL_OW 559
// end ;
99788: LD_VAR 0 2
99792: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99793: LD_EXP 99
99797: PUSH
99798: LD_EXP 104
99802: AND
99803: IFFALSE 99927
99805: GO 99807
99807: DISABLE
99808: LD_INT 0
99810: PPUSH
99811: PPUSH
// begin enable ;
99812: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99813: LD_ADDR_VAR 0 2
99817: PUSH
99818: LD_INT 22
99820: PUSH
99821: LD_OWVAR 2
99825: PUSH
99826: EMPTY
99827: LIST
99828: LIST
99829: PUSH
99830: LD_INT 2
99832: PUSH
99833: LD_INT 34
99835: PUSH
99836: LD_INT 7
99838: PUSH
99839: EMPTY
99840: LIST
99841: LIST
99842: PUSH
99843: LD_INT 34
99845: PUSH
99846: LD_INT 45
99848: PUSH
99849: EMPTY
99850: LIST
99851: LIST
99852: PUSH
99853: LD_INT 34
99855: PUSH
99856: LD_INT 28
99858: PUSH
99859: EMPTY
99860: LIST
99861: LIST
99862: PUSH
99863: LD_INT 34
99865: PUSH
99866: LD_INT 47
99868: PUSH
99869: EMPTY
99870: LIST
99871: LIST
99872: PUSH
99873: EMPTY
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: PUSH
99880: EMPTY
99881: LIST
99882: LIST
99883: PPUSH
99884: CALL_OW 69
99888: ST_TO_ADDR
// if not tmp then
99889: LD_VAR 0 2
99893: NOT
99894: IFFALSE 99898
// exit ;
99896: GO 99927
// for i in tmp do
99898: LD_ADDR_VAR 0 1
99902: PUSH
99903: LD_VAR 0 2
99907: PUSH
99908: FOR_IN
99909: IFFALSE 99925
// begin SetLives ( i , 0 ) ;
99911: LD_VAR 0 1
99915: PPUSH
99916: LD_INT 0
99918: PPUSH
99919: CALL_OW 234
// end ;
99923: GO 99908
99925: POP
99926: POP
// end ;
99927: PPOPN 2
99929: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
99930: LD_EXP 99
99934: PUSH
99935: LD_EXP 105
99939: AND
99940: IFFALSE 100024
99942: GO 99944
99944: DISABLE
99945: LD_INT 0
99947: PPUSH
99948: PPUSH
// begin enable ;
99949: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
99950: LD_ADDR_VAR 0 2
99954: PUSH
99955: LD_INT 22
99957: PUSH
99958: LD_OWVAR 2
99962: PUSH
99963: EMPTY
99964: LIST
99965: LIST
99966: PUSH
99967: LD_INT 32
99969: PUSH
99970: LD_INT 3
99972: PUSH
99973: EMPTY
99974: LIST
99975: LIST
99976: PUSH
99977: EMPTY
99978: LIST
99979: LIST
99980: PPUSH
99981: CALL_OW 69
99985: ST_TO_ADDR
// if not tmp then
99986: LD_VAR 0 2
99990: NOT
99991: IFFALSE 99995
// exit ;
99993: GO 100024
// for i in tmp do
99995: LD_ADDR_VAR 0 1
99999: PUSH
100000: LD_VAR 0 2
100004: PUSH
100005: FOR_IN
100006: IFFALSE 100022
// begin SetLives ( i , 0 ) ;
100008: LD_VAR 0 1
100012: PPUSH
100013: LD_INT 0
100015: PPUSH
100016: CALL_OW 234
// end ;
100020: GO 100005
100022: POP
100023: POP
// end ;
100024: PPOPN 2
100026: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100027: LD_EXP 99
100031: PUSH
100032: LD_EXP 102
100036: AND
100037: IFFALSE 100130
100039: GO 100041
100041: DISABLE
100042: LD_INT 0
100044: PPUSH
// begin enable ;
100045: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100046: LD_ADDR_VAR 0 1
100050: PUSH
100051: LD_INT 22
100053: PUSH
100054: LD_OWVAR 2
100058: PUSH
100059: EMPTY
100060: LIST
100061: LIST
100062: PUSH
100063: LD_INT 2
100065: PUSH
100066: LD_INT 25
100068: PUSH
100069: LD_INT 5
100071: PUSH
100072: EMPTY
100073: LIST
100074: LIST
100075: PUSH
100076: LD_INT 25
100078: PUSH
100079: LD_INT 9
100081: PUSH
100082: EMPTY
100083: LIST
100084: LIST
100085: PUSH
100086: LD_INT 25
100088: PUSH
100089: LD_INT 8
100091: PUSH
100092: EMPTY
100093: LIST
100094: LIST
100095: PUSH
100096: EMPTY
100097: LIST
100098: LIST
100099: LIST
100100: LIST
100101: PUSH
100102: EMPTY
100103: LIST
100104: LIST
100105: PPUSH
100106: CALL_OW 69
100110: PUSH
100111: FOR_IN
100112: IFFALSE 100128
// begin SetClass ( i , 1 ) ;
100114: LD_VAR 0 1
100118: PPUSH
100119: LD_INT 1
100121: PPUSH
100122: CALL_OW 336
// end ;
100126: GO 100111
100128: POP
100129: POP
// end ;
100130: PPOPN 1
100132: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100133: LD_EXP 99
100137: PUSH
100138: LD_EXP 103
100142: AND
100143: PUSH
100144: LD_OWVAR 65
100148: PUSH
100149: LD_INT 7
100151: LESS
100152: AND
100153: IFFALSE 100167
100155: GO 100157
100157: DISABLE
// begin enable ;
100158: ENABLE
// game_speed := 7 ;
100159: LD_ADDR_OWVAR 65
100163: PUSH
100164: LD_INT 7
100166: ST_TO_ADDR
// end ;
100167: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100168: LD_EXP 99
100172: PUSH
100173: LD_EXP 106
100177: AND
100178: IFFALSE 100380
100180: GO 100182
100182: DISABLE
100183: LD_INT 0
100185: PPUSH
100186: PPUSH
100187: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100188: LD_ADDR_VAR 0 3
100192: PUSH
100193: LD_INT 81
100195: PUSH
100196: LD_OWVAR 2
100200: PUSH
100201: EMPTY
100202: LIST
100203: LIST
100204: PUSH
100205: LD_INT 21
100207: PUSH
100208: LD_INT 1
100210: PUSH
100211: EMPTY
100212: LIST
100213: LIST
100214: PUSH
100215: EMPTY
100216: LIST
100217: LIST
100218: PPUSH
100219: CALL_OW 69
100223: ST_TO_ADDR
// if not tmp then
100224: LD_VAR 0 3
100228: NOT
100229: IFFALSE 100233
// exit ;
100231: GO 100380
// if tmp > 5 then
100233: LD_VAR 0 3
100237: PUSH
100238: LD_INT 5
100240: GREATER
100241: IFFALSE 100253
// k := 5 else
100243: LD_ADDR_VAR 0 2
100247: PUSH
100248: LD_INT 5
100250: ST_TO_ADDR
100251: GO 100263
// k := tmp ;
100253: LD_ADDR_VAR 0 2
100257: PUSH
100258: LD_VAR 0 3
100262: ST_TO_ADDR
// for i := 1 to k do
100263: LD_ADDR_VAR 0 1
100267: PUSH
100268: DOUBLE
100269: LD_INT 1
100271: DEC
100272: ST_TO_ADDR
100273: LD_VAR 0 2
100277: PUSH
100278: FOR_TO
100279: IFFALSE 100378
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100281: LD_VAR 0 3
100285: PUSH
100286: LD_VAR 0 1
100290: ARRAY
100291: PPUSH
100292: LD_VAR 0 1
100296: PUSH
100297: LD_INT 4
100299: MOD
100300: PUSH
100301: LD_INT 1
100303: PLUS
100304: PPUSH
100305: CALL_OW 259
100309: PUSH
100310: LD_INT 10
100312: LESS
100313: IFFALSE 100376
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100315: LD_VAR 0 3
100319: PUSH
100320: LD_VAR 0 1
100324: ARRAY
100325: PPUSH
100326: LD_VAR 0 1
100330: PUSH
100331: LD_INT 4
100333: MOD
100334: PUSH
100335: LD_INT 1
100337: PLUS
100338: PPUSH
100339: LD_VAR 0 3
100343: PUSH
100344: LD_VAR 0 1
100348: ARRAY
100349: PPUSH
100350: LD_VAR 0 1
100354: PUSH
100355: LD_INT 4
100357: MOD
100358: PUSH
100359: LD_INT 1
100361: PLUS
100362: PPUSH
100363: CALL_OW 259
100367: PUSH
100368: LD_INT 1
100370: PLUS
100371: PPUSH
100372: CALL_OW 237
100376: GO 100278
100378: POP
100379: POP
// end ;
100380: PPOPN 3
100382: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
100383: LD_EXP 99
100387: PUSH
100388: LD_EXP 107
100392: AND
100393: IFFALSE 100413
100395: GO 100397
100397: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100398: LD_INT 4
100400: PPUSH
100401: LD_OWVAR 2
100405: PPUSH
100406: LD_INT 0
100408: PPUSH
100409: CALL_OW 324
100413: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100414: LD_EXP 99
100418: PUSH
100419: LD_EXP 136
100423: AND
100424: IFFALSE 100444
100426: GO 100428
100428: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100429: LD_INT 19
100431: PPUSH
100432: LD_OWVAR 2
100436: PPUSH
100437: LD_INT 0
100439: PPUSH
100440: CALL_OW 324
100444: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100445: LD_EXP 99
100449: PUSH
100450: LD_EXP 108
100454: AND
100455: IFFALSE 100557
100457: GO 100459
100459: DISABLE
100460: LD_INT 0
100462: PPUSH
100463: PPUSH
// begin enable ;
100464: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100465: LD_ADDR_VAR 0 2
100469: PUSH
100470: LD_INT 22
100472: PUSH
100473: LD_OWVAR 2
100477: PUSH
100478: EMPTY
100479: LIST
100480: LIST
100481: PUSH
100482: LD_INT 2
100484: PUSH
100485: LD_INT 34
100487: PUSH
100488: LD_INT 11
100490: PUSH
100491: EMPTY
100492: LIST
100493: LIST
100494: PUSH
100495: LD_INT 34
100497: PUSH
100498: LD_INT 30
100500: PUSH
100501: EMPTY
100502: LIST
100503: LIST
100504: PUSH
100505: EMPTY
100506: LIST
100507: LIST
100508: LIST
100509: PUSH
100510: EMPTY
100511: LIST
100512: LIST
100513: PPUSH
100514: CALL_OW 69
100518: ST_TO_ADDR
// if not tmp then
100519: LD_VAR 0 2
100523: NOT
100524: IFFALSE 100528
// exit ;
100526: GO 100557
// for i in tmp do
100528: LD_ADDR_VAR 0 1
100532: PUSH
100533: LD_VAR 0 2
100537: PUSH
100538: FOR_IN
100539: IFFALSE 100555
// begin SetLives ( i , 0 ) ;
100541: LD_VAR 0 1
100545: PPUSH
100546: LD_INT 0
100548: PPUSH
100549: CALL_OW 234
// end ;
100553: GO 100538
100555: POP
100556: POP
// end ;
100557: PPOPN 2
100559: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100560: LD_EXP 99
100564: PUSH
100565: LD_EXP 109
100569: AND
100570: IFFALSE 100590
100572: GO 100574
100574: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100575: LD_INT 32
100577: PPUSH
100578: LD_OWVAR 2
100582: PPUSH
100583: LD_INT 0
100585: PPUSH
100586: CALL_OW 324
100590: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100591: LD_EXP 99
100595: PUSH
100596: LD_EXP 110
100600: AND
100601: IFFALSE 100782
100603: GO 100605
100605: DISABLE
100606: LD_INT 0
100608: PPUSH
100609: PPUSH
100610: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100611: LD_ADDR_VAR 0 2
100615: PUSH
100616: LD_INT 22
100618: PUSH
100619: LD_OWVAR 2
100623: PUSH
100624: EMPTY
100625: LIST
100626: LIST
100627: PUSH
100628: LD_INT 33
100630: PUSH
100631: LD_INT 3
100633: PUSH
100634: EMPTY
100635: LIST
100636: LIST
100637: PUSH
100638: EMPTY
100639: LIST
100640: LIST
100641: PPUSH
100642: CALL_OW 69
100646: ST_TO_ADDR
// if not tmp then
100647: LD_VAR 0 2
100651: NOT
100652: IFFALSE 100656
// exit ;
100654: GO 100782
// side := 0 ;
100656: LD_ADDR_VAR 0 3
100660: PUSH
100661: LD_INT 0
100663: ST_TO_ADDR
// for i := 1 to 8 do
100664: LD_ADDR_VAR 0 1
100668: PUSH
100669: DOUBLE
100670: LD_INT 1
100672: DEC
100673: ST_TO_ADDR
100674: LD_INT 8
100676: PUSH
100677: FOR_TO
100678: IFFALSE 100726
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100680: LD_OWVAR 2
100684: PUSH
100685: LD_VAR 0 1
100689: NONEQUAL
100690: PUSH
100691: LD_OWVAR 2
100695: PPUSH
100696: LD_VAR 0 1
100700: PPUSH
100701: CALL_OW 81
100705: PUSH
100706: LD_INT 2
100708: EQUAL
100709: AND
100710: IFFALSE 100724
// begin side := i ;
100712: LD_ADDR_VAR 0 3
100716: PUSH
100717: LD_VAR 0 1
100721: ST_TO_ADDR
// break ;
100722: GO 100726
// end ;
100724: GO 100677
100726: POP
100727: POP
// if not side then
100728: LD_VAR 0 3
100732: NOT
100733: IFFALSE 100737
// exit ;
100735: GO 100782
// for i := 1 to tmp do
100737: LD_ADDR_VAR 0 1
100741: PUSH
100742: DOUBLE
100743: LD_INT 1
100745: DEC
100746: ST_TO_ADDR
100747: LD_VAR 0 2
100751: PUSH
100752: FOR_TO
100753: IFFALSE 100780
// if Prob ( 60 ) then
100755: LD_INT 60
100757: PPUSH
100758: CALL_OW 13
100762: IFFALSE 100778
// SetSide ( i , side ) ;
100764: LD_VAR 0 1
100768: PPUSH
100769: LD_VAR 0 3
100773: PPUSH
100774: CALL_OW 235
100778: GO 100752
100780: POP
100781: POP
// end ;
100782: PPOPN 3
100784: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100785: LD_EXP 99
100789: PUSH
100790: LD_EXP 112
100794: AND
100795: IFFALSE 100914
100797: GO 100799
100799: DISABLE
100800: LD_INT 0
100802: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100803: LD_ADDR_VAR 0 1
100807: PUSH
100808: LD_INT 22
100810: PUSH
100811: LD_OWVAR 2
100815: PUSH
100816: EMPTY
100817: LIST
100818: LIST
100819: PUSH
100820: LD_INT 21
100822: PUSH
100823: LD_INT 1
100825: PUSH
100826: EMPTY
100827: LIST
100828: LIST
100829: PUSH
100830: LD_INT 3
100832: PUSH
100833: LD_INT 23
100835: PUSH
100836: LD_INT 0
100838: PUSH
100839: EMPTY
100840: LIST
100841: LIST
100842: PUSH
100843: EMPTY
100844: LIST
100845: LIST
100846: PUSH
100847: EMPTY
100848: LIST
100849: LIST
100850: LIST
100851: PPUSH
100852: CALL_OW 69
100856: PUSH
100857: FOR_IN
100858: IFFALSE 100912
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100860: LD_VAR 0 1
100864: PPUSH
100865: CALL_OW 257
100869: PUSH
100870: LD_INT 1
100872: PUSH
100873: LD_INT 2
100875: PUSH
100876: LD_INT 3
100878: PUSH
100879: LD_INT 4
100881: PUSH
100882: EMPTY
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: IN
100888: IFFALSE 100910
// SetClass ( un , rand ( 1 , 4 ) ) ;
100890: LD_VAR 0 1
100894: PPUSH
100895: LD_INT 1
100897: PPUSH
100898: LD_INT 4
100900: PPUSH
100901: CALL_OW 12
100905: PPUSH
100906: CALL_OW 336
100910: GO 100857
100912: POP
100913: POP
// end ;
100914: PPOPN 1
100916: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100917: LD_EXP 99
100921: PUSH
100922: LD_EXP 111
100926: AND
100927: IFFALSE 101006
100929: GO 100931
100931: DISABLE
100932: LD_INT 0
100934: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
100935: LD_ADDR_VAR 0 1
100939: PUSH
100940: LD_INT 22
100942: PUSH
100943: LD_OWVAR 2
100947: PUSH
100948: EMPTY
100949: LIST
100950: LIST
100951: PUSH
100952: LD_INT 21
100954: PUSH
100955: LD_INT 3
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: PUSH
100962: EMPTY
100963: LIST
100964: LIST
100965: PPUSH
100966: CALL_OW 69
100970: ST_TO_ADDR
// if not tmp then
100971: LD_VAR 0 1
100975: NOT
100976: IFFALSE 100980
// exit ;
100978: GO 101006
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
100980: LD_VAR 0 1
100984: PUSH
100985: LD_INT 1
100987: PPUSH
100988: LD_VAR 0 1
100992: PPUSH
100993: CALL_OW 12
100997: ARRAY
100998: PPUSH
100999: LD_INT 100
101001: PPUSH
101002: CALL_OW 234
// end ;
101006: PPOPN 1
101008: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101009: LD_EXP 99
101013: PUSH
101014: LD_EXP 113
101018: AND
101019: IFFALSE 101117
101021: GO 101023
101023: DISABLE
101024: LD_INT 0
101026: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101027: LD_ADDR_VAR 0 1
101031: PUSH
101032: LD_INT 22
101034: PUSH
101035: LD_OWVAR 2
101039: PUSH
101040: EMPTY
101041: LIST
101042: LIST
101043: PUSH
101044: LD_INT 21
101046: PUSH
101047: LD_INT 1
101049: PUSH
101050: EMPTY
101051: LIST
101052: LIST
101053: PUSH
101054: EMPTY
101055: LIST
101056: LIST
101057: PPUSH
101058: CALL_OW 69
101062: ST_TO_ADDR
// if not tmp then
101063: LD_VAR 0 1
101067: NOT
101068: IFFALSE 101072
// exit ;
101070: GO 101117
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101072: LD_VAR 0 1
101076: PUSH
101077: LD_INT 1
101079: PPUSH
101080: LD_VAR 0 1
101084: PPUSH
101085: CALL_OW 12
101089: ARRAY
101090: PPUSH
101091: LD_INT 1
101093: PPUSH
101094: LD_INT 4
101096: PPUSH
101097: CALL_OW 12
101101: PPUSH
101102: LD_INT 3000
101104: PPUSH
101105: LD_INT 9000
101107: PPUSH
101108: CALL_OW 12
101112: PPUSH
101113: CALL_OW 492
// end ;
101117: PPOPN 1
101119: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101120: LD_EXP 99
101124: PUSH
101125: LD_EXP 114
101129: AND
101130: IFFALSE 101150
101132: GO 101134
101134: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101135: LD_INT 1
101137: PPUSH
101138: LD_OWVAR 2
101142: PPUSH
101143: LD_INT 0
101145: PPUSH
101146: CALL_OW 324
101150: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101151: LD_EXP 99
101155: PUSH
101156: LD_EXP 115
101160: AND
101161: IFFALSE 101244
101163: GO 101165
101165: DISABLE
101166: LD_INT 0
101168: PPUSH
101169: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101170: LD_ADDR_VAR 0 2
101174: PUSH
101175: LD_INT 22
101177: PUSH
101178: LD_OWVAR 2
101182: PUSH
101183: EMPTY
101184: LIST
101185: LIST
101186: PUSH
101187: LD_INT 21
101189: PUSH
101190: LD_INT 3
101192: PUSH
101193: EMPTY
101194: LIST
101195: LIST
101196: PUSH
101197: EMPTY
101198: LIST
101199: LIST
101200: PPUSH
101201: CALL_OW 69
101205: ST_TO_ADDR
// if not tmp then
101206: LD_VAR 0 2
101210: NOT
101211: IFFALSE 101215
// exit ;
101213: GO 101244
// for i in tmp do
101215: LD_ADDR_VAR 0 1
101219: PUSH
101220: LD_VAR 0 2
101224: PUSH
101225: FOR_IN
101226: IFFALSE 101242
// SetBLevel ( i , 10 ) ;
101228: LD_VAR 0 1
101232: PPUSH
101233: LD_INT 10
101235: PPUSH
101236: CALL_OW 241
101240: GO 101225
101242: POP
101243: POP
// end ;
101244: PPOPN 2
101246: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101247: LD_EXP 99
101251: PUSH
101252: LD_EXP 116
101256: AND
101257: IFFALSE 101368
101259: GO 101261
101261: DISABLE
101262: LD_INT 0
101264: PPUSH
101265: PPUSH
101266: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101267: LD_ADDR_VAR 0 3
101271: PUSH
101272: LD_INT 22
101274: PUSH
101275: LD_OWVAR 2
101279: PUSH
101280: EMPTY
101281: LIST
101282: LIST
101283: PUSH
101284: LD_INT 25
101286: PUSH
101287: LD_INT 1
101289: PUSH
101290: EMPTY
101291: LIST
101292: LIST
101293: PUSH
101294: EMPTY
101295: LIST
101296: LIST
101297: PPUSH
101298: CALL_OW 69
101302: ST_TO_ADDR
// if not tmp then
101303: LD_VAR 0 3
101307: NOT
101308: IFFALSE 101312
// exit ;
101310: GO 101368
// un := tmp [ rand ( 1 , tmp ) ] ;
101312: LD_ADDR_VAR 0 2
101316: PUSH
101317: LD_VAR 0 3
101321: PUSH
101322: LD_INT 1
101324: PPUSH
101325: LD_VAR 0 3
101329: PPUSH
101330: CALL_OW 12
101334: ARRAY
101335: ST_TO_ADDR
// if Crawls ( un ) then
101336: LD_VAR 0 2
101340: PPUSH
101341: CALL_OW 318
101345: IFFALSE 101356
// ComWalk ( un ) ;
101347: LD_VAR 0 2
101351: PPUSH
101352: CALL_OW 138
// SetClass ( un , class_sniper ) ;
101356: LD_VAR 0 2
101360: PPUSH
101361: LD_INT 5
101363: PPUSH
101364: CALL_OW 336
// end ;
101368: PPOPN 3
101370: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101371: LD_EXP 99
101375: PUSH
101376: LD_EXP 117
101380: AND
101381: PUSH
101382: LD_OWVAR 67
101386: PUSH
101387: LD_INT 4
101389: LESS
101390: AND
101391: IFFALSE 101410
101393: GO 101395
101395: DISABLE
// begin Difficulty := Difficulty + 1 ;
101396: LD_ADDR_OWVAR 67
101400: PUSH
101401: LD_OWVAR 67
101405: PUSH
101406: LD_INT 1
101408: PLUS
101409: ST_TO_ADDR
// end ;
101410: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101411: LD_EXP 99
101415: PUSH
101416: LD_EXP 118
101420: AND
101421: IFFALSE 101524
101423: GO 101425
101425: DISABLE
101426: LD_INT 0
101428: PPUSH
// begin for i := 1 to 5 do
101429: LD_ADDR_VAR 0 1
101433: PUSH
101434: DOUBLE
101435: LD_INT 1
101437: DEC
101438: ST_TO_ADDR
101439: LD_INT 5
101441: PUSH
101442: FOR_TO
101443: IFFALSE 101522
// begin uc_nation := nation_nature ;
101445: LD_ADDR_OWVAR 21
101449: PUSH
101450: LD_INT 0
101452: ST_TO_ADDR
// uc_side := 0 ;
101453: LD_ADDR_OWVAR 20
101457: PUSH
101458: LD_INT 0
101460: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101461: LD_ADDR_OWVAR 29
101465: PUSH
101466: LD_INT 12
101468: PUSH
101469: LD_INT 12
101471: PUSH
101472: EMPTY
101473: LIST
101474: LIST
101475: ST_TO_ADDR
// hc_agressivity := 20 ;
101476: LD_ADDR_OWVAR 35
101480: PUSH
101481: LD_INT 20
101483: ST_TO_ADDR
// hc_class := class_tiger ;
101484: LD_ADDR_OWVAR 28
101488: PUSH
101489: LD_INT 14
101491: ST_TO_ADDR
// hc_gallery :=  ;
101492: LD_ADDR_OWVAR 33
101496: PUSH
101497: LD_STRING 
101499: ST_TO_ADDR
// hc_name :=  ;
101500: LD_ADDR_OWVAR 26
101504: PUSH
101505: LD_STRING 
101507: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101508: CALL_OW 44
101512: PPUSH
101513: LD_INT 0
101515: PPUSH
101516: CALL_OW 51
// end ;
101520: GO 101442
101522: POP
101523: POP
// end ;
101524: PPOPN 1
101526: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101527: LD_EXP 99
101531: PUSH
101532: LD_EXP 119
101536: AND
101537: IFFALSE 101546
101539: GO 101541
101541: DISABLE
// StreamSibBomb ;
101542: CALL 101547 0 0
101546: END
// export function StreamSibBomb ; var i , x , y ; begin
101547: LD_INT 0
101549: PPUSH
101550: PPUSH
101551: PPUSH
101552: PPUSH
// result := false ;
101553: LD_ADDR_VAR 0 1
101557: PUSH
101558: LD_INT 0
101560: ST_TO_ADDR
// for i := 1 to 16 do
101561: LD_ADDR_VAR 0 2
101565: PUSH
101566: DOUBLE
101567: LD_INT 1
101569: DEC
101570: ST_TO_ADDR
101571: LD_INT 16
101573: PUSH
101574: FOR_TO
101575: IFFALSE 101774
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101577: LD_ADDR_VAR 0 3
101581: PUSH
101582: LD_INT 10
101584: PUSH
101585: LD_INT 20
101587: PUSH
101588: LD_INT 30
101590: PUSH
101591: LD_INT 40
101593: PUSH
101594: LD_INT 50
101596: PUSH
101597: LD_INT 60
101599: PUSH
101600: LD_INT 70
101602: PUSH
101603: LD_INT 80
101605: PUSH
101606: LD_INT 90
101608: PUSH
101609: LD_INT 100
101611: PUSH
101612: LD_INT 110
101614: PUSH
101615: LD_INT 120
101617: PUSH
101618: LD_INT 130
101620: PUSH
101621: LD_INT 140
101623: PUSH
101624: LD_INT 150
101626: PUSH
101627: EMPTY
101628: LIST
101629: LIST
101630: LIST
101631: LIST
101632: LIST
101633: LIST
101634: LIST
101635: LIST
101636: LIST
101637: LIST
101638: LIST
101639: LIST
101640: LIST
101641: LIST
101642: LIST
101643: PUSH
101644: LD_INT 1
101646: PPUSH
101647: LD_INT 15
101649: PPUSH
101650: CALL_OW 12
101654: ARRAY
101655: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101656: LD_ADDR_VAR 0 4
101660: PUSH
101661: LD_INT 10
101663: PUSH
101664: LD_INT 20
101666: PUSH
101667: LD_INT 30
101669: PUSH
101670: LD_INT 40
101672: PUSH
101673: LD_INT 50
101675: PUSH
101676: LD_INT 60
101678: PUSH
101679: LD_INT 70
101681: PUSH
101682: LD_INT 80
101684: PUSH
101685: LD_INT 90
101687: PUSH
101688: LD_INT 100
101690: PUSH
101691: LD_INT 110
101693: PUSH
101694: LD_INT 120
101696: PUSH
101697: LD_INT 130
101699: PUSH
101700: LD_INT 140
101702: PUSH
101703: LD_INT 150
101705: PUSH
101706: EMPTY
101707: LIST
101708: LIST
101709: LIST
101710: LIST
101711: LIST
101712: LIST
101713: LIST
101714: LIST
101715: LIST
101716: LIST
101717: LIST
101718: LIST
101719: LIST
101720: LIST
101721: LIST
101722: PUSH
101723: LD_INT 1
101725: PPUSH
101726: LD_INT 15
101728: PPUSH
101729: CALL_OW 12
101733: ARRAY
101734: ST_TO_ADDR
// if ValidHex ( x , y ) then
101735: LD_VAR 0 3
101739: PPUSH
101740: LD_VAR 0 4
101744: PPUSH
101745: CALL_OW 488
101749: IFFALSE 101772
// begin result := [ x , y ] ;
101751: LD_ADDR_VAR 0 1
101755: PUSH
101756: LD_VAR 0 3
101760: PUSH
101761: LD_VAR 0 4
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: ST_TO_ADDR
// break ;
101770: GO 101774
// end ; end ;
101772: GO 101574
101774: POP
101775: POP
// if result then
101776: LD_VAR 0 1
101780: IFFALSE 101840
// begin ToLua ( playSibBomb() ) ;
101782: LD_STRING playSibBomb()
101784: PPUSH
101785: CALL_OW 559
// wait ( 0 0$14 ) ;
101789: LD_INT 490
101791: PPUSH
101792: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101796: LD_VAR 0 1
101800: PUSH
101801: LD_INT 1
101803: ARRAY
101804: PPUSH
101805: LD_VAR 0 1
101809: PUSH
101810: LD_INT 2
101812: ARRAY
101813: PPUSH
101814: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101818: LD_VAR 0 1
101822: PUSH
101823: LD_INT 1
101825: ARRAY
101826: PPUSH
101827: LD_VAR 0 1
101831: PUSH
101832: LD_INT 2
101834: ARRAY
101835: PPUSH
101836: CALL_OW 429
// end ; end ;
101840: LD_VAR 0 1
101844: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101845: LD_EXP 99
101849: PUSH
101850: LD_EXP 121
101854: AND
101855: IFFALSE 101867
101857: GO 101859
101859: DISABLE
// YouLost (  ) ;
101860: LD_STRING 
101862: PPUSH
101863: CALL_OW 104
101867: END
// every 0 0$1 trigger StreamModeActive and sFog do
101868: LD_EXP 99
101872: PUSH
101873: LD_EXP 120
101877: AND
101878: IFFALSE 101892
101880: GO 101882
101882: DISABLE
// FogOff ( your_side ) ;
101883: LD_OWVAR 2
101887: PPUSH
101888: CALL_OW 344
101892: END
// every 0 0$1 trigger StreamModeActive and sSun do
101893: LD_EXP 99
101897: PUSH
101898: LD_EXP 122
101902: AND
101903: IFFALSE 101931
101905: GO 101907
101907: DISABLE
// begin solar_recharge_percent := 0 ;
101908: LD_ADDR_OWVAR 79
101912: PUSH
101913: LD_INT 0
101915: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101916: LD_INT 10500
101918: PPUSH
101919: CALL_OW 67
// solar_recharge_percent := 100 ;
101923: LD_ADDR_OWVAR 79
101927: PUSH
101928: LD_INT 100
101930: ST_TO_ADDR
// end ;
101931: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
101932: LD_EXP 99
101936: PUSH
101937: LD_EXP 123
101941: AND
101942: IFFALSE 102181
101944: GO 101946
101946: DISABLE
101947: LD_INT 0
101949: PPUSH
101950: PPUSH
101951: PPUSH
// begin tmp := [ ] ;
101952: LD_ADDR_VAR 0 3
101956: PUSH
101957: EMPTY
101958: ST_TO_ADDR
// for i := 1 to 6 do
101959: LD_ADDR_VAR 0 1
101963: PUSH
101964: DOUBLE
101965: LD_INT 1
101967: DEC
101968: ST_TO_ADDR
101969: LD_INT 6
101971: PUSH
101972: FOR_TO
101973: IFFALSE 102078
// begin uc_nation := nation_nature ;
101975: LD_ADDR_OWVAR 21
101979: PUSH
101980: LD_INT 0
101982: ST_TO_ADDR
// uc_side := 0 ;
101983: LD_ADDR_OWVAR 20
101987: PUSH
101988: LD_INT 0
101990: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101991: LD_ADDR_OWVAR 29
101995: PUSH
101996: LD_INT 12
101998: PUSH
101999: LD_INT 12
102001: PUSH
102002: EMPTY
102003: LIST
102004: LIST
102005: ST_TO_ADDR
// hc_agressivity := 20 ;
102006: LD_ADDR_OWVAR 35
102010: PUSH
102011: LD_INT 20
102013: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102014: LD_ADDR_OWVAR 28
102018: PUSH
102019: LD_INT 17
102021: ST_TO_ADDR
// hc_gallery :=  ;
102022: LD_ADDR_OWVAR 33
102026: PUSH
102027: LD_STRING 
102029: ST_TO_ADDR
// hc_name :=  ;
102030: LD_ADDR_OWVAR 26
102034: PUSH
102035: LD_STRING 
102037: ST_TO_ADDR
// un := CreateHuman ;
102038: LD_ADDR_VAR 0 2
102042: PUSH
102043: CALL_OW 44
102047: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102048: LD_VAR 0 2
102052: PPUSH
102053: LD_INT 1
102055: PPUSH
102056: CALL_OW 51
// tmp := tmp ^ un ;
102060: LD_ADDR_VAR 0 3
102064: PUSH
102065: LD_VAR 0 3
102069: PUSH
102070: LD_VAR 0 2
102074: ADD
102075: ST_TO_ADDR
// end ;
102076: GO 101972
102078: POP
102079: POP
// repeat wait ( 0 0$1 ) ;
102080: LD_INT 35
102082: PPUSH
102083: CALL_OW 67
// for un in tmp do
102087: LD_ADDR_VAR 0 2
102091: PUSH
102092: LD_VAR 0 3
102096: PUSH
102097: FOR_IN
102098: IFFALSE 102172
// begin if IsDead ( un ) then
102100: LD_VAR 0 2
102104: PPUSH
102105: CALL_OW 301
102109: IFFALSE 102129
// begin tmp := tmp diff un ;
102111: LD_ADDR_VAR 0 3
102115: PUSH
102116: LD_VAR 0 3
102120: PUSH
102121: LD_VAR 0 2
102125: DIFF
102126: ST_TO_ADDR
// continue ;
102127: GO 102097
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102129: LD_VAR 0 2
102133: PPUSH
102134: LD_INT 3
102136: PUSH
102137: LD_INT 22
102139: PUSH
102140: LD_INT 0
102142: PUSH
102143: EMPTY
102144: LIST
102145: LIST
102146: PUSH
102147: EMPTY
102148: LIST
102149: LIST
102150: PPUSH
102151: CALL_OW 69
102155: PPUSH
102156: LD_VAR 0 2
102160: PPUSH
102161: CALL_OW 74
102165: PPUSH
102166: CALL_OW 115
// end ;
102170: GO 102097
102172: POP
102173: POP
// until not tmp ;
102174: LD_VAR 0 3
102178: NOT
102179: IFFALSE 102080
// end ;
102181: PPOPN 3
102183: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102184: LD_EXP 99
102188: PUSH
102189: LD_EXP 124
102193: AND
102194: IFFALSE 102248
102196: GO 102198
102198: DISABLE
// begin ToLua ( displayTroll(); ) ;
102199: LD_STRING displayTroll();
102201: PPUSH
102202: CALL_OW 559
// wait ( 3 3$00 ) ;
102206: LD_INT 6300
102208: PPUSH
102209: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102213: LD_STRING hideTroll();
102215: PPUSH
102216: CALL_OW 559
// wait ( 1 1$00 ) ;
102220: LD_INT 2100
102222: PPUSH
102223: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102227: LD_STRING displayTroll();
102229: PPUSH
102230: CALL_OW 559
// wait ( 1 1$00 ) ;
102234: LD_INT 2100
102236: PPUSH
102237: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102241: LD_STRING hideTroll();
102243: PPUSH
102244: CALL_OW 559
// end ;
102248: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102249: LD_EXP 99
102253: PUSH
102254: LD_EXP 125
102258: AND
102259: IFFALSE 102322
102261: GO 102263
102263: DISABLE
102264: LD_INT 0
102266: PPUSH
// begin p := 0 ;
102267: LD_ADDR_VAR 0 1
102271: PUSH
102272: LD_INT 0
102274: ST_TO_ADDR
// repeat game_speed := 1 ;
102275: LD_ADDR_OWVAR 65
102279: PUSH
102280: LD_INT 1
102282: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102283: LD_INT 35
102285: PPUSH
102286: CALL_OW 67
// p := p + 1 ;
102290: LD_ADDR_VAR 0 1
102294: PUSH
102295: LD_VAR 0 1
102299: PUSH
102300: LD_INT 1
102302: PLUS
102303: ST_TO_ADDR
// until p >= 60 ;
102304: LD_VAR 0 1
102308: PUSH
102309: LD_INT 60
102311: GREATEREQUAL
102312: IFFALSE 102275
// game_speed := 4 ;
102314: LD_ADDR_OWVAR 65
102318: PUSH
102319: LD_INT 4
102321: ST_TO_ADDR
// end ;
102322: PPOPN 1
102324: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102325: LD_EXP 99
102329: PUSH
102330: LD_EXP 126
102334: AND
102335: IFFALSE 102481
102337: GO 102339
102339: DISABLE
102340: LD_INT 0
102342: PPUSH
102343: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102344: LD_ADDR_VAR 0 1
102348: PUSH
102349: LD_INT 22
102351: PUSH
102352: LD_OWVAR 2
102356: PUSH
102357: EMPTY
102358: LIST
102359: LIST
102360: PUSH
102361: LD_INT 2
102363: PUSH
102364: LD_INT 30
102366: PUSH
102367: LD_INT 0
102369: PUSH
102370: EMPTY
102371: LIST
102372: LIST
102373: PUSH
102374: LD_INT 30
102376: PUSH
102377: LD_INT 1
102379: PUSH
102380: EMPTY
102381: LIST
102382: LIST
102383: PUSH
102384: EMPTY
102385: LIST
102386: LIST
102387: LIST
102388: PUSH
102389: EMPTY
102390: LIST
102391: LIST
102392: PPUSH
102393: CALL_OW 69
102397: ST_TO_ADDR
// if not depot then
102398: LD_VAR 0 1
102402: NOT
102403: IFFALSE 102407
// exit ;
102405: GO 102481
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102407: LD_ADDR_VAR 0 2
102411: PUSH
102412: LD_VAR 0 1
102416: PUSH
102417: LD_INT 1
102419: PPUSH
102420: LD_VAR 0 1
102424: PPUSH
102425: CALL_OW 12
102429: ARRAY
102430: PPUSH
102431: CALL_OW 274
102435: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102436: LD_VAR 0 2
102440: PPUSH
102441: LD_INT 1
102443: PPUSH
102444: LD_INT 0
102446: PPUSH
102447: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102451: LD_VAR 0 2
102455: PPUSH
102456: LD_INT 2
102458: PPUSH
102459: LD_INT 0
102461: PPUSH
102462: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102466: LD_VAR 0 2
102470: PPUSH
102471: LD_INT 3
102473: PPUSH
102474: LD_INT 0
102476: PPUSH
102477: CALL_OW 277
// end ;
102481: PPOPN 2
102483: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102484: LD_EXP 99
102488: PUSH
102489: LD_EXP 127
102493: AND
102494: IFFALSE 102591
102496: GO 102498
102498: DISABLE
102499: LD_INT 0
102501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102502: LD_ADDR_VAR 0 1
102506: PUSH
102507: LD_INT 22
102509: PUSH
102510: LD_OWVAR 2
102514: PUSH
102515: EMPTY
102516: LIST
102517: LIST
102518: PUSH
102519: LD_INT 21
102521: PUSH
102522: LD_INT 1
102524: PUSH
102525: EMPTY
102526: LIST
102527: LIST
102528: PUSH
102529: LD_INT 3
102531: PUSH
102532: LD_INT 23
102534: PUSH
102535: LD_INT 0
102537: PUSH
102538: EMPTY
102539: LIST
102540: LIST
102541: PUSH
102542: EMPTY
102543: LIST
102544: LIST
102545: PUSH
102546: EMPTY
102547: LIST
102548: LIST
102549: LIST
102550: PPUSH
102551: CALL_OW 69
102555: ST_TO_ADDR
// if not tmp then
102556: LD_VAR 0 1
102560: NOT
102561: IFFALSE 102565
// exit ;
102563: GO 102591
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102565: LD_VAR 0 1
102569: PUSH
102570: LD_INT 1
102572: PPUSH
102573: LD_VAR 0 1
102577: PPUSH
102578: CALL_OW 12
102582: ARRAY
102583: PPUSH
102584: LD_INT 200
102586: PPUSH
102587: CALL_OW 234
// end ;
102591: PPOPN 1
102593: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102594: LD_EXP 99
102598: PUSH
102599: LD_EXP 128
102603: AND
102604: IFFALSE 102683
102606: GO 102608
102608: DISABLE
102609: LD_INT 0
102611: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102612: LD_ADDR_VAR 0 1
102616: PUSH
102617: LD_INT 22
102619: PUSH
102620: LD_OWVAR 2
102624: PUSH
102625: EMPTY
102626: LIST
102627: LIST
102628: PUSH
102629: LD_INT 21
102631: PUSH
102632: LD_INT 2
102634: PUSH
102635: EMPTY
102636: LIST
102637: LIST
102638: PUSH
102639: EMPTY
102640: LIST
102641: LIST
102642: PPUSH
102643: CALL_OW 69
102647: ST_TO_ADDR
// if not tmp then
102648: LD_VAR 0 1
102652: NOT
102653: IFFALSE 102657
// exit ;
102655: GO 102683
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102657: LD_VAR 0 1
102661: PUSH
102662: LD_INT 1
102664: PPUSH
102665: LD_VAR 0 1
102669: PPUSH
102670: CALL_OW 12
102674: ARRAY
102675: PPUSH
102676: LD_INT 60
102678: PPUSH
102679: CALL_OW 234
// end ;
102683: PPOPN 1
102685: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102686: LD_EXP 99
102690: PUSH
102691: LD_EXP 129
102695: AND
102696: IFFALSE 102795
102698: GO 102700
102700: DISABLE
102701: LD_INT 0
102703: PPUSH
102704: PPUSH
// begin enable ;
102705: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102706: LD_ADDR_VAR 0 1
102710: PUSH
102711: LD_INT 22
102713: PUSH
102714: LD_OWVAR 2
102718: PUSH
102719: EMPTY
102720: LIST
102721: LIST
102722: PUSH
102723: LD_INT 61
102725: PUSH
102726: EMPTY
102727: LIST
102728: PUSH
102729: LD_INT 33
102731: PUSH
102732: LD_INT 2
102734: PUSH
102735: EMPTY
102736: LIST
102737: LIST
102738: PUSH
102739: EMPTY
102740: LIST
102741: LIST
102742: LIST
102743: PPUSH
102744: CALL_OW 69
102748: ST_TO_ADDR
// if not tmp then
102749: LD_VAR 0 1
102753: NOT
102754: IFFALSE 102758
// exit ;
102756: GO 102795
// for i in tmp do
102758: LD_ADDR_VAR 0 2
102762: PUSH
102763: LD_VAR 0 1
102767: PUSH
102768: FOR_IN
102769: IFFALSE 102793
// if IsControledBy ( i ) then
102771: LD_VAR 0 2
102775: PPUSH
102776: CALL_OW 312
102780: IFFALSE 102791
// ComUnlink ( i ) ;
102782: LD_VAR 0 2
102786: PPUSH
102787: CALL_OW 136
102791: GO 102768
102793: POP
102794: POP
// end ;
102795: PPOPN 2
102797: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102798: LD_EXP 99
102802: PUSH
102803: LD_EXP 130
102807: AND
102808: IFFALSE 102948
102810: GO 102812
102812: DISABLE
102813: LD_INT 0
102815: PPUSH
102816: PPUSH
// begin ToLua ( displayPowell(); ) ;
102817: LD_STRING displayPowell();
102819: PPUSH
102820: CALL_OW 559
// uc_side := 0 ;
102824: LD_ADDR_OWVAR 20
102828: PUSH
102829: LD_INT 0
102831: ST_TO_ADDR
// uc_nation := 2 ;
102832: LD_ADDR_OWVAR 21
102836: PUSH
102837: LD_INT 2
102839: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102840: LD_ADDR_OWVAR 37
102844: PUSH
102845: LD_INT 14
102847: ST_TO_ADDR
// vc_engine := engine_siberite ;
102848: LD_ADDR_OWVAR 39
102852: PUSH
102853: LD_INT 3
102855: ST_TO_ADDR
// vc_control := control_apeman ;
102856: LD_ADDR_OWVAR 38
102860: PUSH
102861: LD_INT 5
102863: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102864: LD_ADDR_OWVAR 40
102868: PUSH
102869: LD_INT 29
102871: ST_TO_ADDR
// un := CreateVehicle ;
102872: LD_ADDR_VAR 0 2
102876: PUSH
102877: CALL_OW 45
102881: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102882: LD_VAR 0 2
102886: PPUSH
102887: LD_INT 1
102889: PPUSH
102890: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102894: LD_INT 35
102896: PPUSH
102897: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102901: LD_VAR 0 2
102905: PPUSH
102906: LD_INT 22
102908: PUSH
102909: LD_OWVAR 2
102913: PUSH
102914: EMPTY
102915: LIST
102916: LIST
102917: PPUSH
102918: CALL_OW 69
102922: PPUSH
102923: LD_VAR 0 2
102927: PPUSH
102928: CALL_OW 74
102932: PPUSH
102933: CALL_OW 115
// until IsDead ( un ) ;
102937: LD_VAR 0 2
102941: PPUSH
102942: CALL_OW 301
102946: IFFALSE 102894
// end ;
102948: PPOPN 2
102950: END
// every 0 0$1 trigger StreamModeActive and sStu do
102951: LD_EXP 99
102955: PUSH
102956: LD_EXP 138
102960: AND
102961: IFFALSE 102977
102963: GO 102965
102965: DISABLE
// begin ToLua ( displayStucuk(); ) ;
102966: LD_STRING displayStucuk();
102968: PPUSH
102969: CALL_OW 559
// ResetFog ;
102973: CALL_OW 335
// end ;
102977: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
102978: LD_EXP 99
102982: PUSH
102983: LD_EXP 131
102987: AND
102988: IFFALSE 103129
102990: GO 102992
102992: DISABLE
102993: LD_INT 0
102995: PPUSH
102996: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102997: LD_ADDR_VAR 0 2
103001: PUSH
103002: LD_INT 22
103004: PUSH
103005: LD_OWVAR 2
103009: PUSH
103010: EMPTY
103011: LIST
103012: LIST
103013: PUSH
103014: LD_INT 21
103016: PUSH
103017: LD_INT 1
103019: PUSH
103020: EMPTY
103021: LIST
103022: LIST
103023: PUSH
103024: EMPTY
103025: LIST
103026: LIST
103027: PPUSH
103028: CALL_OW 69
103032: ST_TO_ADDR
// if not tmp then
103033: LD_VAR 0 2
103037: NOT
103038: IFFALSE 103042
// exit ;
103040: GO 103129
// un := tmp [ rand ( 1 , tmp ) ] ;
103042: LD_ADDR_VAR 0 1
103046: PUSH
103047: LD_VAR 0 2
103051: PUSH
103052: LD_INT 1
103054: PPUSH
103055: LD_VAR 0 2
103059: PPUSH
103060: CALL_OW 12
103064: ARRAY
103065: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103066: LD_VAR 0 1
103070: PPUSH
103071: LD_INT 0
103073: PPUSH
103074: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103078: LD_VAR 0 1
103082: PPUSH
103083: LD_OWVAR 3
103087: PUSH
103088: LD_VAR 0 1
103092: DIFF
103093: PPUSH
103094: LD_VAR 0 1
103098: PPUSH
103099: CALL_OW 74
103103: PPUSH
103104: CALL_OW 115
// wait ( 0 0$20 ) ;
103108: LD_INT 700
103110: PPUSH
103111: CALL_OW 67
// SetSide ( un , your_side ) ;
103115: LD_VAR 0 1
103119: PPUSH
103120: LD_OWVAR 2
103124: PPUSH
103125: CALL_OW 235
// end ;
103129: PPOPN 2
103131: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103132: LD_EXP 99
103136: PUSH
103137: LD_EXP 132
103141: AND
103142: IFFALSE 103248
103144: GO 103146
103146: DISABLE
103147: LD_INT 0
103149: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103150: LD_ADDR_VAR 0 1
103154: PUSH
103155: LD_INT 22
103157: PUSH
103158: LD_OWVAR 2
103162: PUSH
103163: EMPTY
103164: LIST
103165: LIST
103166: PUSH
103167: LD_INT 2
103169: PUSH
103170: LD_INT 30
103172: PUSH
103173: LD_INT 0
103175: PUSH
103176: EMPTY
103177: LIST
103178: LIST
103179: PUSH
103180: LD_INT 30
103182: PUSH
103183: LD_INT 1
103185: PUSH
103186: EMPTY
103187: LIST
103188: LIST
103189: PUSH
103190: EMPTY
103191: LIST
103192: LIST
103193: LIST
103194: PUSH
103195: EMPTY
103196: LIST
103197: LIST
103198: PPUSH
103199: CALL_OW 69
103203: ST_TO_ADDR
// if not depot then
103204: LD_VAR 0 1
103208: NOT
103209: IFFALSE 103213
// exit ;
103211: GO 103248
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103213: LD_VAR 0 1
103217: PUSH
103218: LD_INT 1
103220: ARRAY
103221: PPUSH
103222: CALL_OW 250
103226: PPUSH
103227: LD_VAR 0 1
103231: PUSH
103232: LD_INT 1
103234: ARRAY
103235: PPUSH
103236: CALL_OW 251
103240: PPUSH
103241: LD_INT 70
103243: PPUSH
103244: CALL_OW 495
// end ;
103248: PPOPN 1
103250: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103251: LD_EXP 99
103255: PUSH
103256: LD_EXP 133
103260: AND
103261: IFFALSE 103472
103263: GO 103265
103265: DISABLE
103266: LD_INT 0
103268: PPUSH
103269: PPUSH
103270: PPUSH
103271: PPUSH
103272: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103273: LD_ADDR_VAR 0 5
103277: PUSH
103278: LD_INT 22
103280: PUSH
103281: LD_OWVAR 2
103285: PUSH
103286: EMPTY
103287: LIST
103288: LIST
103289: PUSH
103290: LD_INT 21
103292: PUSH
103293: LD_INT 1
103295: PUSH
103296: EMPTY
103297: LIST
103298: LIST
103299: PUSH
103300: EMPTY
103301: LIST
103302: LIST
103303: PPUSH
103304: CALL_OW 69
103308: ST_TO_ADDR
// if not tmp then
103309: LD_VAR 0 5
103313: NOT
103314: IFFALSE 103318
// exit ;
103316: GO 103472
// for i in tmp do
103318: LD_ADDR_VAR 0 1
103322: PUSH
103323: LD_VAR 0 5
103327: PUSH
103328: FOR_IN
103329: IFFALSE 103470
// begin d := rand ( 0 , 5 ) ;
103331: LD_ADDR_VAR 0 4
103335: PUSH
103336: LD_INT 0
103338: PPUSH
103339: LD_INT 5
103341: PPUSH
103342: CALL_OW 12
103346: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103347: LD_ADDR_VAR 0 2
103351: PUSH
103352: LD_VAR 0 1
103356: PPUSH
103357: CALL_OW 250
103361: PPUSH
103362: LD_VAR 0 4
103366: PPUSH
103367: LD_INT 3
103369: PPUSH
103370: LD_INT 12
103372: PPUSH
103373: CALL_OW 12
103377: PPUSH
103378: CALL_OW 272
103382: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103383: LD_ADDR_VAR 0 3
103387: PUSH
103388: LD_VAR 0 1
103392: PPUSH
103393: CALL_OW 251
103397: PPUSH
103398: LD_VAR 0 4
103402: PPUSH
103403: LD_INT 3
103405: PPUSH
103406: LD_INT 12
103408: PPUSH
103409: CALL_OW 12
103413: PPUSH
103414: CALL_OW 273
103418: ST_TO_ADDR
// if ValidHex ( x , y ) then
103419: LD_VAR 0 2
103423: PPUSH
103424: LD_VAR 0 3
103428: PPUSH
103429: CALL_OW 488
103433: IFFALSE 103468
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103435: LD_VAR 0 1
103439: PPUSH
103440: LD_VAR 0 2
103444: PPUSH
103445: LD_VAR 0 3
103449: PPUSH
103450: LD_INT 3
103452: PPUSH
103453: LD_INT 6
103455: PPUSH
103456: CALL_OW 12
103460: PPUSH
103461: LD_INT 1
103463: PPUSH
103464: CALL_OW 483
// end ;
103468: GO 103328
103470: POP
103471: POP
// end ;
103472: PPOPN 5
103474: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103475: LD_EXP 99
103479: PUSH
103480: LD_EXP 134
103484: AND
103485: IFFALSE 103579
103487: GO 103489
103489: DISABLE
103490: LD_INT 0
103492: PPUSH
103493: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103494: LD_ADDR_VAR 0 2
103498: PUSH
103499: LD_INT 22
103501: PUSH
103502: LD_OWVAR 2
103506: PUSH
103507: EMPTY
103508: LIST
103509: LIST
103510: PUSH
103511: LD_INT 32
103513: PUSH
103514: LD_INT 1
103516: PUSH
103517: EMPTY
103518: LIST
103519: LIST
103520: PUSH
103521: LD_INT 21
103523: PUSH
103524: LD_INT 2
103526: PUSH
103527: EMPTY
103528: LIST
103529: LIST
103530: PUSH
103531: EMPTY
103532: LIST
103533: LIST
103534: LIST
103535: PPUSH
103536: CALL_OW 69
103540: ST_TO_ADDR
// if not tmp then
103541: LD_VAR 0 2
103545: NOT
103546: IFFALSE 103550
// exit ;
103548: GO 103579
// for i in tmp do
103550: LD_ADDR_VAR 0 1
103554: PUSH
103555: LD_VAR 0 2
103559: PUSH
103560: FOR_IN
103561: IFFALSE 103577
// SetFuel ( i , 0 ) ;
103563: LD_VAR 0 1
103567: PPUSH
103568: LD_INT 0
103570: PPUSH
103571: CALL_OW 240
103575: GO 103560
103577: POP
103578: POP
// end ;
103579: PPOPN 2
103581: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103582: LD_EXP 99
103586: PUSH
103587: LD_EXP 135
103591: AND
103592: IFFALSE 103658
103594: GO 103596
103596: DISABLE
103597: LD_INT 0
103599: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103600: LD_ADDR_VAR 0 1
103604: PUSH
103605: LD_INT 22
103607: PUSH
103608: LD_OWVAR 2
103612: PUSH
103613: EMPTY
103614: LIST
103615: LIST
103616: PUSH
103617: LD_INT 30
103619: PUSH
103620: LD_INT 29
103622: PUSH
103623: EMPTY
103624: LIST
103625: LIST
103626: PUSH
103627: EMPTY
103628: LIST
103629: LIST
103630: PPUSH
103631: CALL_OW 69
103635: ST_TO_ADDR
// if not tmp then
103636: LD_VAR 0 1
103640: NOT
103641: IFFALSE 103645
// exit ;
103643: GO 103658
// DestroyUnit ( tmp [ 1 ] ) ;
103645: LD_VAR 0 1
103649: PUSH
103650: LD_INT 1
103652: ARRAY
103653: PPUSH
103654: CALL_OW 65
// end ;
103658: PPOPN 1
103660: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103661: LD_EXP 99
103665: PUSH
103666: LD_EXP 137
103670: AND
103671: IFFALSE 103800
103673: GO 103675
103675: DISABLE
103676: LD_INT 0
103678: PPUSH
// begin uc_side := 0 ;
103679: LD_ADDR_OWVAR 20
103683: PUSH
103684: LD_INT 0
103686: ST_TO_ADDR
// uc_nation := nation_arabian ;
103687: LD_ADDR_OWVAR 21
103691: PUSH
103692: LD_INT 2
103694: ST_TO_ADDR
// hc_gallery :=  ;
103695: LD_ADDR_OWVAR 33
103699: PUSH
103700: LD_STRING 
103702: ST_TO_ADDR
// hc_name :=  ;
103703: LD_ADDR_OWVAR 26
103707: PUSH
103708: LD_STRING 
103710: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103711: LD_INT 1
103713: PPUSH
103714: LD_INT 11
103716: PPUSH
103717: LD_INT 10
103719: PPUSH
103720: CALL_OW 380
// un := CreateHuman ;
103724: LD_ADDR_VAR 0 1
103728: PUSH
103729: CALL_OW 44
103733: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103734: LD_VAR 0 1
103738: PPUSH
103739: LD_INT 1
103741: PPUSH
103742: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103746: LD_INT 35
103748: PPUSH
103749: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103753: LD_VAR 0 1
103757: PPUSH
103758: LD_INT 22
103760: PUSH
103761: LD_OWVAR 2
103765: PUSH
103766: EMPTY
103767: LIST
103768: LIST
103769: PPUSH
103770: CALL_OW 69
103774: PPUSH
103775: LD_VAR 0 1
103779: PPUSH
103780: CALL_OW 74
103784: PPUSH
103785: CALL_OW 115
// until IsDead ( un ) ;
103789: LD_VAR 0 1
103793: PPUSH
103794: CALL_OW 301
103798: IFFALSE 103746
// end ;
103800: PPOPN 1
103802: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103803: LD_EXP 99
103807: PUSH
103808: LD_EXP 139
103812: AND
103813: IFFALSE 103825
103815: GO 103817
103817: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103818: LD_STRING earthquake(getX(game), 0, 32)
103820: PPUSH
103821: CALL_OW 559
103825: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103826: LD_EXP 99
103830: PUSH
103831: LD_EXP 140
103835: AND
103836: IFFALSE 103927
103838: GO 103840
103840: DISABLE
103841: LD_INT 0
103843: PPUSH
// begin enable ;
103844: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103845: LD_ADDR_VAR 0 1
103849: PUSH
103850: LD_INT 22
103852: PUSH
103853: LD_OWVAR 2
103857: PUSH
103858: EMPTY
103859: LIST
103860: LIST
103861: PUSH
103862: LD_INT 21
103864: PUSH
103865: LD_INT 2
103867: PUSH
103868: EMPTY
103869: LIST
103870: LIST
103871: PUSH
103872: LD_INT 33
103874: PUSH
103875: LD_INT 3
103877: PUSH
103878: EMPTY
103879: LIST
103880: LIST
103881: PUSH
103882: EMPTY
103883: LIST
103884: LIST
103885: LIST
103886: PPUSH
103887: CALL_OW 69
103891: ST_TO_ADDR
// if not tmp then
103892: LD_VAR 0 1
103896: NOT
103897: IFFALSE 103901
// exit ;
103899: GO 103927
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103901: LD_VAR 0 1
103905: PUSH
103906: LD_INT 1
103908: PPUSH
103909: LD_VAR 0 1
103913: PPUSH
103914: CALL_OW 12
103918: ARRAY
103919: PPUSH
103920: LD_INT 1
103922: PPUSH
103923: CALL_OW 234
// end ;
103927: PPOPN 1
103929: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
103930: LD_EXP 99
103934: PUSH
103935: LD_EXP 141
103939: AND
103940: IFFALSE 104081
103942: GO 103944
103944: DISABLE
103945: LD_INT 0
103947: PPUSH
103948: PPUSH
103949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103950: LD_ADDR_VAR 0 3
103954: PUSH
103955: LD_INT 22
103957: PUSH
103958: LD_OWVAR 2
103962: PUSH
103963: EMPTY
103964: LIST
103965: LIST
103966: PUSH
103967: LD_INT 25
103969: PUSH
103970: LD_INT 1
103972: PUSH
103973: EMPTY
103974: LIST
103975: LIST
103976: PUSH
103977: EMPTY
103978: LIST
103979: LIST
103980: PPUSH
103981: CALL_OW 69
103985: ST_TO_ADDR
// if not tmp then
103986: LD_VAR 0 3
103990: NOT
103991: IFFALSE 103995
// exit ;
103993: GO 104081
// un := tmp [ rand ( 1 , tmp ) ] ;
103995: LD_ADDR_VAR 0 2
103999: PUSH
104000: LD_VAR 0 3
104004: PUSH
104005: LD_INT 1
104007: PPUSH
104008: LD_VAR 0 3
104012: PPUSH
104013: CALL_OW 12
104017: ARRAY
104018: ST_TO_ADDR
// if Crawls ( un ) then
104019: LD_VAR 0 2
104023: PPUSH
104024: CALL_OW 318
104028: IFFALSE 104039
// ComWalk ( un ) ;
104030: LD_VAR 0 2
104034: PPUSH
104035: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104039: LD_VAR 0 2
104043: PPUSH
104044: LD_INT 9
104046: PPUSH
104047: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104051: LD_INT 28
104053: PPUSH
104054: LD_OWVAR 2
104058: PPUSH
104059: LD_INT 2
104061: PPUSH
104062: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104066: LD_INT 29
104068: PPUSH
104069: LD_OWVAR 2
104073: PPUSH
104074: LD_INT 2
104076: PPUSH
104077: CALL_OW 322
// end ;
104081: PPOPN 3
104083: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104084: LD_EXP 99
104088: PUSH
104089: LD_EXP 142
104093: AND
104094: IFFALSE 104205
104096: GO 104098
104098: DISABLE
104099: LD_INT 0
104101: PPUSH
104102: PPUSH
104103: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104104: LD_ADDR_VAR 0 3
104108: PUSH
104109: LD_INT 22
104111: PUSH
104112: LD_OWVAR 2
104116: PUSH
104117: EMPTY
104118: LIST
104119: LIST
104120: PUSH
104121: LD_INT 25
104123: PUSH
104124: LD_INT 1
104126: PUSH
104127: EMPTY
104128: LIST
104129: LIST
104130: PUSH
104131: EMPTY
104132: LIST
104133: LIST
104134: PPUSH
104135: CALL_OW 69
104139: ST_TO_ADDR
// if not tmp then
104140: LD_VAR 0 3
104144: NOT
104145: IFFALSE 104149
// exit ;
104147: GO 104205
// un := tmp [ rand ( 1 , tmp ) ] ;
104149: LD_ADDR_VAR 0 2
104153: PUSH
104154: LD_VAR 0 3
104158: PUSH
104159: LD_INT 1
104161: PPUSH
104162: LD_VAR 0 3
104166: PPUSH
104167: CALL_OW 12
104171: ARRAY
104172: ST_TO_ADDR
// if Crawls ( un ) then
104173: LD_VAR 0 2
104177: PPUSH
104178: CALL_OW 318
104182: IFFALSE 104193
// ComWalk ( un ) ;
104184: LD_VAR 0 2
104188: PPUSH
104189: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104193: LD_VAR 0 2
104197: PPUSH
104198: LD_INT 8
104200: PPUSH
104201: CALL_OW 336
// end ;
104205: PPOPN 3
104207: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104208: LD_EXP 99
104212: PUSH
104213: LD_EXP 143
104217: AND
104218: IFFALSE 104362
104220: GO 104222
104222: DISABLE
104223: LD_INT 0
104225: PPUSH
104226: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104227: LD_ADDR_VAR 0 2
104231: PUSH
104232: LD_INT 22
104234: PUSH
104235: LD_OWVAR 2
104239: PUSH
104240: EMPTY
104241: LIST
104242: LIST
104243: PUSH
104244: LD_INT 21
104246: PUSH
104247: LD_INT 2
104249: PUSH
104250: EMPTY
104251: LIST
104252: LIST
104253: PUSH
104254: LD_INT 2
104256: PUSH
104257: LD_INT 34
104259: PUSH
104260: LD_INT 12
104262: PUSH
104263: EMPTY
104264: LIST
104265: LIST
104266: PUSH
104267: LD_INT 34
104269: PUSH
104270: LD_INT 51
104272: PUSH
104273: EMPTY
104274: LIST
104275: LIST
104276: PUSH
104277: LD_INT 34
104279: PUSH
104280: LD_INT 32
104282: PUSH
104283: EMPTY
104284: LIST
104285: LIST
104286: PUSH
104287: EMPTY
104288: LIST
104289: LIST
104290: LIST
104291: LIST
104292: PUSH
104293: EMPTY
104294: LIST
104295: LIST
104296: LIST
104297: PPUSH
104298: CALL_OW 69
104302: ST_TO_ADDR
// if not tmp then
104303: LD_VAR 0 2
104307: NOT
104308: IFFALSE 104312
// exit ;
104310: GO 104362
// for i in tmp do
104312: LD_ADDR_VAR 0 1
104316: PUSH
104317: LD_VAR 0 2
104321: PUSH
104322: FOR_IN
104323: IFFALSE 104360
// if GetCargo ( i , mat_artifact ) = 0 then
104325: LD_VAR 0 1
104329: PPUSH
104330: LD_INT 4
104332: PPUSH
104333: CALL_OW 289
104337: PUSH
104338: LD_INT 0
104340: EQUAL
104341: IFFALSE 104358
// SetCargo ( i , mat_siberit , 100 ) ;
104343: LD_VAR 0 1
104347: PPUSH
104348: LD_INT 3
104350: PPUSH
104351: LD_INT 100
104353: PPUSH
104354: CALL_OW 290
104358: GO 104322
104360: POP
104361: POP
// end ;
104362: PPOPN 2
104364: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104365: LD_EXP 99
104369: PUSH
104370: LD_EXP 144
104374: AND
104375: IFFALSE 104558
104377: GO 104379
104379: DISABLE
104380: LD_INT 0
104382: PPUSH
104383: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104384: LD_ADDR_VAR 0 2
104388: PUSH
104389: LD_INT 22
104391: PUSH
104392: LD_OWVAR 2
104396: PUSH
104397: EMPTY
104398: LIST
104399: LIST
104400: PPUSH
104401: CALL_OW 69
104405: ST_TO_ADDR
// if not tmp then
104406: LD_VAR 0 2
104410: NOT
104411: IFFALSE 104415
// exit ;
104413: GO 104558
// for i := 1 to 2 do
104415: LD_ADDR_VAR 0 1
104419: PUSH
104420: DOUBLE
104421: LD_INT 1
104423: DEC
104424: ST_TO_ADDR
104425: LD_INT 2
104427: PUSH
104428: FOR_TO
104429: IFFALSE 104556
// begin uc_side := your_side ;
104431: LD_ADDR_OWVAR 20
104435: PUSH
104436: LD_OWVAR 2
104440: ST_TO_ADDR
// uc_nation := nation_american ;
104441: LD_ADDR_OWVAR 21
104445: PUSH
104446: LD_INT 1
104448: ST_TO_ADDR
// vc_chassis := us_morphling ;
104449: LD_ADDR_OWVAR 37
104453: PUSH
104454: LD_INT 5
104456: ST_TO_ADDR
// vc_engine := engine_siberite ;
104457: LD_ADDR_OWVAR 39
104461: PUSH
104462: LD_INT 3
104464: ST_TO_ADDR
// vc_control := control_computer ;
104465: LD_ADDR_OWVAR 38
104469: PUSH
104470: LD_INT 3
104472: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104473: LD_ADDR_OWVAR 40
104477: PUSH
104478: LD_INT 10
104480: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104481: LD_VAR 0 2
104485: PUSH
104486: LD_INT 1
104488: ARRAY
104489: PPUSH
104490: CALL_OW 310
104494: NOT
104495: IFFALSE 104542
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104497: CALL_OW 45
104501: PPUSH
104502: LD_VAR 0 2
104506: PUSH
104507: LD_INT 1
104509: ARRAY
104510: PPUSH
104511: CALL_OW 250
104515: PPUSH
104516: LD_VAR 0 2
104520: PUSH
104521: LD_INT 1
104523: ARRAY
104524: PPUSH
104525: CALL_OW 251
104529: PPUSH
104530: LD_INT 12
104532: PPUSH
104533: LD_INT 1
104535: PPUSH
104536: CALL_OW 50
104540: GO 104554
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104542: CALL_OW 45
104546: PPUSH
104547: LD_INT 1
104549: PPUSH
104550: CALL_OW 51
// end ;
104554: GO 104428
104556: POP
104557: POP
// end ;
104558: PPOPN 2
104560: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104561: LD_EXP 99
104565: PUSH
104566: LD_EXP 145
104570: AND
104571: IFFALSE 104793
104573: GO 104575
104575: DISABLE
104576: LD_INT 0
104578: PPUSH
104579: PPUSH
104580: PPUSH
104581: PPUSH
104582: PPUSH
104583: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104584: LD_ADDR_VAR 0 6
104588: PUSH
104589: LD_INT 22
104591: PUSH
104592: LD_OWVAR 2
104596: PUSH
104597: EMPTY
104598: LIST
104599: LIST
104600: PUSH
104601: LD_INT 21
104603: PUSH
104604: LD_INT 1
104606: PUSH
104607: EMPTY
104608: LIST
104609: LIST
104610: PUSH
104611: LD_INT 3
104613: PUSH
104614: LD_INT 23
104616: PUSH
104617: LD_INT 0
104619: PUSH
104620: EMPTY
104621: LIST
104622: LIST
104623: PUSH
104624: EMPTY
104625: LIST
104626: LIST
104627: PUSH
104628: EMPTY
104629: LIST
104630: LIST
104631: LIST
104632: PPUSH
104633: CALL_OW 69
104637: ST_TO_ADDR
// if not tmp then
104638: LD_VAR 0 6
104642: NOT
104643: IFFALSE 104647
// exit ;
104645: GO 104793
// s1 := rand ( 1 , 4 ) ;
104647: LD_ADDR_VAR 0 2
104651: PUSH
104652: LD_INT 1
104654: PPUSH
104655: LD_INT 4
104657: PPUSH
104658: CALL_OW 12
104662: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104663: LD_ADDR_VAR 0 4
104667: PUSH
104668: LD_VAR 0 6
104672: PUSH
104673: LD_INT 1
104675: ARRAY
104676: PPUSH
104677: LD_VAR 0 2
104681: PPUSH
104682: CALL_OW 259
104686: ST_TO_ADDR
// if s1 = 1 then
104687: LD_VAR 0 2
104691: PUSH
104692: LD_INT 1
104694: EQUAL
104695: IFFALSE 104715
// s2 := rand ( 2 , 4 ) else
104697: LD_ADDR_VAR 0 3
104701: PUSH
104702: LD_INT 2
104704: PPUSH
104705: LD_INT 4
104707: PPUSH
104708: CALL_OW 12
104712: ST_TO_ADDR
104713: GO 104723
// s2 := 1 ;
104715: LD_ADDR_VAR 0 3
104719: PUSH
104720: LD_INT 1
104722: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104723: LD_ADDR_VAR 0 5
104727: PUSH
104728: LD_VAR 0 6
104732: PUSH
104733: LD_INT 1
104735: ARRAY
104736: PPUSH
104737: LD_VAR 0 3
104741: PPUSH
104742: CALL_OW 259
104746: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104747: LD_VAR 0 6
104751: PUSH
104752: LD_INT 1
104754: ARRAY
104755: PPUSH
104756: LD_VAR 0 2
104760: PPUSH
104761: LD_VAR 0 5
104765: PPUSH
104766: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104770: LD_VAR 0 6
104774: PUSH
104775: LD_INT 1
104777: ARRAY
104778: PPUSH
104779: LD_VAR 0 3
104783: PPUSH
104784: LD_VAR 0 4
104788: PPUSH
104789: CALL_OW 237
// end ;
104793: PPOPN 6
104795: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104796: LD_EXP 99
104800: PUSH
104801: LD_EXP 146
104805: AND
104806: IFFALSE 104885
104808: GO 104810
104810: DISABLE
104811: LD_INT 0
104813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104814: LD_ADDR_VAR 0 1
104818: PUSH
104819: LD_INT 22
104821: PUSH
104822: LD_OWVAR 2
104826: PUSH
104827: EMPTY
104828: LIST
104829: LIST
104830: PUSH
104831: LD_INT 30
104833: PUSH
104834: LD_INT 3
104836: PUSH
104837: EMPTY
104838: LIST
104839: LIST
104840: PUSH
104841: EMPTY
104842: LIST
104843: LIST
104844: PPUSH
104845: CALL_OW 69
104849: ST_TO_ADDR
// if not tmp then
104850: LD_VAR 0 1
104854: NOT
104855: IFFALSE 104859
// exit ;
104857: GO 104885
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104859: LD_VAR 0 1
104863: PUSH
104864: LD_INT 1
104866: PPUSH
104867: LD_VAR 0 1
104871: PPUSH
104872: CALL_OW 12
104876: ARRAY
104877: PPUSH
104878: LD_INT 1
104880: PPUSH
104881: CALL_OW 234
// end ;
104885: PPOPN 1
104887: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104888: LD_EXP 99
104892: PUSH
104893: LD_EXP 147
104897: AND
104898: IFFALSE 105010
104900: GO 104902
104902: DISABLE
104903: LD_INT 0
104905: PPUSH
104906: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104907: LD_ADDR_VAR 0 2
104911: PUSH
104912: LD_INT 22
104914: PUSH
104915: LD_OWVAR 2
104919: PUSH
104920: EMPTY
104921: LIST
104922: LIST
104923: PUSH
104924: LD_INT 2
104926: PUSH
104927: LD_INT 30
104929: PUSH
104930: LD_INT 27
104932: PUSH
104933: EMPTY
104934: LIST
104935: LIST
104936: PUSH
104937: LD_INT 30
104939: PUSH
104940: LD_INT 26
104942: PUSH
104943: EMPTY
104944: LIST
104945: LIST
104946: PUSH
104947: LD_INT 30
104949: PUSH
104950: LD_INT 28
104952: PUSH
104953: EMPTY
104954: LIST
104955: LIST
104956: PUSH
104957: EMPTY
104958: LIST
104959: LIST
104960: LIST
104961: LIST
104962: PUSH
104963: EMPTY
104964: LIST
104965: LIST
104966: PPUSH
104967: CALL_OW 69
104971: ST_TO_ADDR
// if not tmp then
104972: LD_VAR 0 2
104976: NOT
104977: IFFALSE 104981
// exit ;
104979: GO 105010
// for i in tmp do
104981: LD_ADDR_VAR 0 1
104985: PUSH
104986: LD_VAR 0 2
104990: PUSH
104991: FOR_IN
104992: IFFALSE 105008
// SetLives ( i , 1 ) ;
104994: LD_VAR 0 1
104998: PPUSH
104999: LD_INT 1
105001: PPUSH
105002: CALL_OW 234
105006: GO 104991
105008: POP
105009: POP
// end ;
105010: PPOPN 2
105012: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105013: LD_EXP 99
105017: PUSH
105018: LD_EXP 148
105022: AND
105023: IFFALSE 105310
105025: GO 105027
105027: DISABLE
105028: LD_INT 0
105030: PPUSH
105031: PPUSH
105032: PPUSH
// begin i := rand ( 1 , 7 ) ;
105033: LD_ADDR_VAR 0 1
105037: PUSH
105038: LD_INT 1
105040: PPUSH
105041: LD_INT 7
105043: PPUSH
105044: CALL_OW 12
105048: ST_TO_ADDR
// case i of 1 :
105049: LD_VAR 0 1
105053: PUSH
105054: LD_INT 1
105056: DOUBLE
105057: EQUAL
105058: IFTRUE 105062
105060: GO 105072
105062: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105063: LD_STRING earthquake(getX(game), 0, 32)
105065: PPUSH
105066: CALL_OW 559
105070: GO 105310
105072: LD_INT 2
105074: DOUBLE
105075: EQUAL
105076: IFTRUE 105080
105078: GO 105094
105080: POP
// begin ToLua ( displayStucuk(); ) ;
105081: LD_STRING displayStucuk();
105083: PPUSH
105084: CALL_OW 559
// ResetFog ;
105088: CALL_OW 335
// end ; 3 :
105092: GO 105310
105094: LD_INT 3
105096: DOUBLE
105097: EQUAL
105098: IFTRUE 105102
105100: GO 105206
105102: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105103: LD_ADDR_VAR 0 2
105107: PUSH
105108: LD_INT 22
105110: PUSH
105111: LD_OWVAR 2
105115: PUSH
105116: EMPTY
105117: LIST
105118: LIST
105119: PUSH
105120: LD_INT 25
105122: PUSH
105123: LD_INT 1
105125: PUSH
105126: EMPTY
105127: LIST
105128: LIST
105129: PUSH
105130: EMPTY
105131: LIST
105132: LIST
105133: PPUSH
105134: CALL_OW 69
105138: ST_TO_ADDR
// if not tmp then
105139: LD_VAR 0 2
105143: NOT
105144: IFFALSE 105148
// exit ;
105146: GO 105310
// un := tmp [ rand ( 1 , tmp ) ] ;
105148: LD_ADDR_VAR 0 3
105152: PUSH
105153: LD_VAR 0 2
105157: PUSH
105158: LD_INT 1
105160: PPUSH
105161: LD_VAR 0 2
105165: PPUSH
105166: CALL_OW 12
105170: ARRAY
105171: ST_TO_ADDR
// if Crawls ( un ) then
105172: LD_VAR 0 3
105176: PPUSH
105177: CALL_OW 318
105181: IFFALSE 105192
// ComWalk ( un ) ;
105183: LD_VAR 0 3
105187: PPUSH
105188: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105192: LD_VAR 0 3
105196: PPUSH
105197: LD_INT 8
105199: PPUSH
105200: CALL_OW 336
// end ; 4 :
105204: GO 105310
105206: LD_INT 4
105208: DOUBLE
105209: EQUAL
105210: IFTRUE 105214
105212: GO 105288
105214: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105215: LD_ADDR_VAR 0 2
105219: PUSH
105220: LD_INT 22
105222: PUSH
105223: LD_OWVAR 2
105227: PUSH
105228: EMPTY
105229: LIST
105230: LIST
105231: PUSH
105232: LD_INT 30
105234: PUSH
105235: LD_INT 29
105237: PUSH
105238: EMPTY
105239: LIST
105240: LIST
105241: PUSH
105242: EMPTY
105243: LIST
105244: LIST
105245: PPUSH
105246: CALL_OW 69
105250: ST_TO_ADDR
// if not tmp then
105251: LD_VAR 0 2
105255: NOT
105256: IFFALSE 105260
// exit ;
105258: GO 105310
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105260: LD_VAR 0 2
105264: PUSH
105265: LD_INT 1
105267: ARRAY
105268: PPUSH
105269: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105273: LD_VAR 0 2
105277: PUSH
105278: LD_INT 1
105280: ARRAY
105281: PPUSH
105282: CALL_OW 65
// end ; 5 .. 7 :
105286: GO 105310
105288: LD_INT 5
105290: DOUBLE
105291: GREATEREQUAL
105292: IFFALSE 105300
105294: LD_INT 7
105296: DOUBLE
105297: LESSEQUAL
105298: IFTRUE 105302
105300: GO 105309
105302: POP
// StreamSibBomb ; end ;
105303: CALL 101547 0 0
105307: GO 105310
105309: POP
// end ;
105310: PPOPN 3
105312: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105313: LD_EXP 99
105317: PUSH
105318: LD_EXP 149
105322: AND
105323: IFFALSE 105479
105325: GO 105327
105327: DISABLE
105328: LD_INT 0
105330: PPUSH
105331: PPUSH
105332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105333: LD_ADDR_VAR 0 2
105337: PUSH
105338: LD_INT 81
105340: PUSH
105341: LD_OWVAR 2
105345: PUSH
105346: EMPTY
105347: LIST
105348: LIST
105349: PUSH
105350: LD_INT 2
105352: PUSH
105353: LD_INT 21
105355: PUSH
105356: LD_INT 1
105358: PUSH
105359: EMPTY
105360: LIST
105361: LIST
105362: PUSH
105363: LD_INT 21
105365: PUSH
105366: LD_INT 2
105368: PUSH
105369: EMPTY
105370: LIST
105371: LIST
105372: PUSH
105373: EMPTY
105374: LIST
105375: LIST
105376: LIST
105377: PUSH
105378: EMPTY
105379: LIST
105380: LIST
105381: PPUSH
105382: CALL_OW 69
105386: ST_TO_ADDR
// if not tmp then
105387: LD_VAR 0 2
105391: NOT
105392: IFFALSE 105396
// exit ;
105394: GO 105479
// p := 0 ;
105396: LD_ADDR_VAR 0 3
105400: PUSH
105401: LD_INT 0
105403: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105404: LD_INT 35
105406: PPUSH
105407: CALL_OW 67
// p := p + 1 ;
105411: LD_ADDR_VAR 0 3
105415: PUSH
105416: LD_VAR 0 3
105420: PUSH
105421: LD_INT 1
105423: PLUS
105424: ST_TO_ADDR
// for i in tmp do
105425: LD_ADDR_VAR 0 1
105429: PUSH
105430: LD_VAR 0 2
105434: PUSH
105435: FOR_IN
105436: IFFALSE 105467
// if GetLives ( i ) < 1000 then
105438: LD_VAR 0 1
105442: PPUSH
105443: CALL_OW 256
105447: PUSH
105448: LD_INT 1000
105450: LESS
105451: IFFALSE 105465
// SetLives ( i , 1000 ) ;
105453: LD_VAR 0 1
105457: PPUSH
105458: LD_INT 1000
105460: PPUSH
105461: CALL_OW 234
105465: GO 105435
105467: POP
105468: POP
// until p > 20 ;
105469: LD_VAR 0 3
105473: PUSH
105474: LD_INT 20
105476: GREATER
105477: IFFALSE 105404
// end ;
105479: PPOPN 3
105481: END
// every 0 0$1 trigger StreamModeActive and sTime do
105482: LD_EXP 99
105486: PUSH
105487: LD_EXP 150
105491: AND
105492: IFFALSE 105527
105494: GO 105496
105496: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105497: LD_INT 28
105499: PPUSH
105500: LD_OWVAR 2
105504: PPUSH
105505: LD_INT 2
105507: PPUSH
105508: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105512: LD_INT 30
105514: PPUSH
105515: LD_OWVAR 2
105519: PPUSH
105520: LD_INT 2
105522: PPUSH
105523: CALL_OW 322
// end ;
105527: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105528: LD_EXP 99
105532: PUSH
105533: LD_EXP 151
105537: AND
105538: IFFALSE 105659
105540: GO 105542
105542: DISABLE
105543: LD_INT 0
105545: PPUSH
105546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105547: LD_ADDR_VAR 0 2
105551: PUSH
105552: LD_INT 22
105554: PUSH
105555: LD_OWVAR 2
105559: PUSH
105560: EMPTY
105561: LIST
105562: LIST
105563: PUSH
105564: LD_INT 21
105566: PUSH
105567: LD_INT 1
105569: PUSH
105570: EMPTY
105571: LIST
105572: LIST
105573: PUSH
105574: LD_INT 3
105576: PUSH
105577: LD_INT 23
105579: PUSH
105580: LD_INT 0
105582: PUSH
105583: EMPTY
105584: LIST
105585: LIST
105586: PUSH
105587: EMPTY
105588: LIST
105589: LIST
105590: PUSH
105591: EMPTY
105592: LIST
105593: LIST
105594: LIST
105595: PPUSH
105596: CALL_OW 69
105600: ST_TO_ADDR
// if not tmp then
105601: LD_VAR 0 2
105605: NOT
105606: IFFALSE 105610
// exit ;
105608: GO 105659
// for i in tmp do
105610: LD_ADDR_VAR 0 1
105614: PUSH
105615: LD_VAR 0 2
105619: PUSH
105620: FOR_IN
105621: IFFALSE 105657
// begin if Crawls ( i ) then
105623: LD_VAR 0 1
105627: PPUSH
105628: CALL_OW 318
105632: IFFALSE 105643
// ComWalk ( i ) ;
105634: LD_VAR 0 1
105638: PPUSH
105639: CALL_OW 138
// SetClass ( i , 2 ) ;
105643: LD_VAR 0 1
105647: PPUSH
105648: LD_INT 2
105650: PPUSH
105651: CALL_OW 336
// end ;
105655: GO 105620
105657: POP
105658: POP
// end ;
105659: PPOPN 2
105661: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105662: LD_EXP 99
105666: PUSH
105667: LD_EXP 152
105671: AND
105672: IFFALSE 105960
105674: GO 105676
105676: DISABLE
105677: LD_INT 0
105679: PPUSH
105680: PPUSH
105681: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105682: LD_OWVAR 2
105686: PPUSH
105687: LD_INT 9
105689: PPUSH
105690: LD_INT 1
105692: PPUSH
105693: LD_INT 1
105695: PPUSH
105696: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105700: LD_INT 9
105702: PPUSH
105703: LD_OWVAR 2
105707: PPUSH
105708: CALL_OW 343
// uc_side := 9 ;
105712: LD_ADDR_OWVAR 20
105716: PUSH
105717: LD_INT 9
105719: ST_TO_ADDR
// uc_nation := 2 ;
105720: LD_ADDR_OWVAR 21
105724: PUSH
105725: LD_INT 2
105727: ST_TO_ADDR
// hc_name := Dark Warrior ;
105728: LD_ADDR_OWVAR 26
105732: PUSH
105733: LD_STRING Dark Warrior
105735: ST_TO_ADDR
// hc_gallery :=  ;
105736: LD_ADDR_OWVAR 33
105740: PUSH
105741: LD_STRING 
105743: ST_TO_ADDR
// hc_noskilllimit := true ;
105744: LD_ADDR_OWVAR 76
105748: PUSH
105749: LD_INT 1
105751: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105752: LD_ADDR_OWVAR 31
105756: PUSH
105757: LD_INT 30
105759: PUSH
105760: LD_INT 30
105762: PUSH
105763: LD_INT 30
105765: PUSH
105766: LD_INT 30
105768: PUSH
105769: EMPTY
105770: LIST
105771: LIST
105772: LIST
105773: LIST
105774: ST_TO_ADDR
// un := CreateHuman ;
105775: LD_ADDR_VAR 0 3
105779: PUSH
105780: CALL_OW 44
105784: ST_TO_ADDR
// hc_noskilllimit := false ;
105785: LD_ADDR_OWVAR 76
105789: PUSH
105790: LD_INT 0
105792: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105793: LD_VAR 0 3
105797: PPUSH
105798: LD_INT 1
105800: PPUSH
105801: CALL_OW 51
// ToLua ( playRanger() ) ;
105805: LD_STRING playRanger()
105807: PPUSH
105808: CALL_OW 559
// p := 0 ;
105812: LD_ADDR_VAR 0 2
105816: PUSH
105817: LD_INT 0
105819: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105820: LD_INT 35
105822: PPUSH
105823: CALL_OW 67
// p := p + 1 ;
105827: LD_ADDR_VAR 0 2
105831: PUSH
105832: LD_VAR 0 2
105836: PUSH
105837: LD_INT 1
105839: PLUS
105840: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105841: LD_VAR 0 3
105845: PPUSH
105846: CALL_OW 256
105850: PUSH
105851: LD_INT 1000
105853: LESS
105854: IFFALSE 105868
// SetLives ( un , 1000 ) ;
105856: LD_VAR 0 3
105860: PPUSH
105861: LD_INT 1000
105863: PPUSH
105864: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105868: LD_VAR 0 3
105872: PPUSH
105873: LD_INT 81
105875: PUSH
105876: LD_OWVAR 2
105880: PUSH
105881: EMPTY
105882: LIST
105883: LIST
105884: PUSH
105885: LD_INT 91
105887: PUSH
105888: LD_VAR 0 3
105892: PUSH
105893: LD_INT 30
105895: PUSH
105896: EMPTY
105897: LIST
105898: LIST
105899: LIST
105900: PUSH
105901: EMPTY
105902: LIST
105903: LIST
105904: PPUSH
105905: CALL_OW 69
105909: PPUSH
105910: LD_VAR 0 3
105914: PPUSH
105915: CALL_OW 74
105919: PPUSH
105920: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
105924: LD_VAR 0 2
105928: PUSH
105929: LD_INT 80
105931: GREATER
105932: PUSH
105933: LD_VAR 0 3
105937: PPUSH
105938: CALL_OW 301
105942: OR
105943: IFFALSE 105820
// if un then
105945: LD_VAR 0 3
105949: IFFALSE 105960
// RemoveUnit ( un ) ;
105951: LD_VAR 0 3
105955: PPUSH
105956: CALL_OW 64
// end ;
105960: PPOPN 3
105962: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
105963: LD_EXP 153
105967: IFFALSE 106083
105969: GO 105971
105971: DISABLE
105972: LD_INT 0
105974: PPUSH
105975: PPUSH
105976: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105977: LD_ADDR_VAR 0 2
105981: PUSH
105982: LD_INT 81
105984: PUSH
105985: LD_OWVAR 2
105989: PUSH
105990: EMPTY
105991: LIST
105992: LIST
105993: PUSH
105994: LD_INT 21
105996: PUSH
105997: LD_INT 1
105999: PUSH
106000: EMPTY
106001: LIST
106002: LIST
106003: PUSH
106004: EMPTY
106005: LIST
106006: LIST
106007: PPUSH
106008: CALL_OW 69
106012: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106013: LD_STRING playComputer()
106015: PPUSH
106016: CALL_OW 559
// if not tmp then
106020: LD_VAR 0 2
106024: NOT
106025: IFFALSE 106029
// exit ;
106027: GO 106083
// for i in tmp do
106029: LD_ADDR_VAR 0 1
106033: PUSH
106034: LD_VAR 0 2
106038: PUSH
106039: FOR_IN
106040: IFFALSE 106081
// for j := 1 to 4 do
106042: LD_ADDR_VAR 0 3
106046: PUSH
106047: DOUBLE
106048: LD_INT 1
106050: DEC
106051: ST_TO_ADDR
106052: LD_INT 4
106054: PUSH
106055: FOR_TO
106056: IFFALSE 106077
// SetSkill ( i , j , 10 ) ;
106058: LD_VAR 0 1
106062: PPUSH
106063: LD_VAR 0 3
106067: PPUSH
106068: LD_INT 10
106070: PPUSH
106071: CALL_OW 237
106075: GO 106055
106077: POP
106078: POP
106079: GO 106039
106081: POP
106082: POP
// end ;
106083: PPOPN 3
106085: END
// every 0 0$1 trigger s30 do var i , tmp ;
106086: LD_EXP 154
106090: IFFALSE 106159
106092: GO 106094
106094: DISABLE
106095: LD_INT 0
106097: PPUSH
106098: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106099: LD_ADDR_VAR 0 2
106103: PUSH
106104: LD_INT 22
106106: PUSH
106107: LD_OWVAR 2
106111: PUSH
106112: EMPTY
106113: LIST
106114: LIST
106115: PPUSH
106116: CALL_OW 69
106120: ST_TO_ADDR
// if not tmp then
106121: LD_VAR 0 2
106125: NOT
106126: IFFALSE 106130
// exit ;
106128: GO 106159
// for i in tmp do
106130: LD_ADDR_VAR 0 1
106134: PUSH
106135: LD_VAR 0 2
106139: PUSH
106140: FOR_IN
106141: IFFALSE 106157
// SetLives ( i , 300 ) ;
106143: LD_VAR 0 1
106147: PPUSH
106148: LD_INT 300
106150: PPUSH
106151: CALL_OW 234
106155: GO 106140
106157: POP
106158: POP
// end ;
106159: PPOPN 2
106161: END
// every 0 0$1 trigger s60 do var i , tmp ;
106162: LD_EXP 155
106166: IFFALSE 106235
106168: GO 106170
106170: DISABLE
106171: LD_INT 0
106173: PPUSH
106174: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106175: LD_ADDR_VAR 0 2
106179: PUSH
106180: LD_INT 22
106182: PUSH
106183: LD_OWVAR 2
106187: PUSH
106188: EMPTY
106189: LIST
106190: LIST
106191: PPUSH
106192: CALL_OW 69
106196: ST_TO_ADDR
// if not tmp then
106197: LD_VAR 0 2
106201: NOT
106202: IFFALSE 106206
// exit ;
106204: GO 106235
// for i in tmp do
106206: LD_ADDR_VAR 0 1
106210: PUSH
106211: LD_VAR 0 2
106215: PUSH
106216: FOR_IN
106217: IFFALSE 106233
// SetLives ( i , 600 ) ;
106219: LD_VAR 0 1
106223: PPUSH
106224: LD_INT 600
106226: PPUSH
106227: CALL_OW 234
106231: GO 106216
106233: POP
106234: POP
// end ;
106235: PPOPN 2
106237: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106238: LD_INT 0
106240: PPUSH
// case cmd of 301 :
106241: LD_VAR 0 1
106245: PUSH
106246: LD_INT 301
106248: DOUBLE
106249: EQUAL
106250: IFTRUE 106254
106252: GO 106286
106254: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106255: LD_VAR 0 6
106259: PPUSH
106260: LD_VAR 0 7
106264: PPUSH
106265: LD_VAR 0 8
106269: PPUSH
106270: LD_VAR 0 4
106274: PPUSH
106275: LD_VAR 0 5
106279: PPUSH
106280: CALL 107487 0 5
106284: GO 106407
106286: LD_INT 302
106288: DOUBLE
106289: EQUAL
106290: IFTRUE 106294
106292: GO 106331
106294: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106295: LD_VAR 0 6
106299: PPUSH
106300: LD_VAR 0 7
106304: PPUSH
106305: LD_VAR 0 8
106309: PPUSH
106310: LD_VAR 0 9
106314: PPUSH
106315: LD_VAR 0 4
106319: PPUSH
106320: LD_VAR 0 5
106324: PPUSH
106325: CALL 107578 0 6
106329: GO 106407
106331: LD_INT 303
106333: DOUBLE
106334: EQUAL
106335: IFTRUE 106339
106337: GO 106376
106339: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106340: LD_VAR 0 6
106344: PPUSH
106345: LD_VAR 0 7
106349: PPUSH
106350: LD_VAR 0 8
106354: PPUSH
106355: LD_VAR 0 9
106359: PPUSH
106360: LD_VAR 0 4
106364: PPUSH
106365: LD_VAR 0 5
106369: PPUSH
106370: CALL 106412 0 6
106374: GO 106407
106376: LD_INT 304
106378: DOUBLE
106379: EQUAL
106380: IFTRUE 106384
106382: GO 106406
106384: POP
// hHackTeleport ( unit , x , y ) ; end ;
106385: LD_VAR 0 2
106389: PPUSH
106390: LD_VAR 0 4
106394: PPUSH
106395: LD_VAR 0 5
106399: PPUSH
106400: CALL 108171 0 3
106404: GO 106407
106406: POP
// end ;
106407: LD_VAR 0 12
106411: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106412: LD_INT 0
106414: PPUSH
106415: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106416: LD_VAR 0 1
106420: PUSH
106421: LD_INT 1
106423: LESS
106424: PUSH
106425: LD_VAR 0 1
106429: PUSH
106430: LD_INT 3
106432: GREATER
106433: OR
106434: PUSH
106435: LD_VAR 0 5
106439: PPUSH
106440: LD_VAR 0 6
106444: PPUSH
106445: CALL_OW 428
106449: OR
106450: IFFALSE 106454
// exit ;
106452: GO 107174
// uc_side := your_side ;
106454: LD_ADDR_OWVAR 20
106458: PUSH
106459: LD_OWVAR 2
106463: ST_TO_ADDR
// uc_nation := nation ;
106464: LD_ADDR_OWVAR 21
106468: PUSH
106469: LD_VAR 0 1
106473: ST_TO_ADDR
// bc_level = 1 ;
106474: LD_ADDR_OWVAR 43
106478: PUSH
106479: LD_INT 1
106481: ST_TO_ADDR
// case btype of 1 :
106482: LD_VAR 0 2
106486: PUSH
106487: LD_INT 1
106489: DOUBLE
106490: EQUAL
106491: IFTRUE 106495
106493: GO 106506
106495: POP
// bc_type := b_depot ; 2 :
106496: LD_ADDR_OWVAR 42
106500: PUSH
106501: LD_INT 0
106503: ST_TO_ADDR
106504: GO 107118
106506: LD_INT 2
106508: DOUBLE
106509: EQUAL
106510: IFTRUE 106514
106512: GO 106525
106514: POP
// bc_type := b_warehouse ; 3 :
106515: LD_ADDR_OWVAR 42
106519: PUSH
106520: LD_INT 1
106522: ST_TO_ADDR
106523: GO 107118
106525: LD_INT 3
106527: DOUBLE
106528: EQUAL
106529: IFTRUE 106533
106531: GO 106544
106533: POP
// bc_type := b_lab ; 4 .. 9 :
106534: LD_ADDR_OWVAR 42
106538: PUSH
106539: LD_INT 6
106541: ST_TO_ADDR
106542: GO 107118
106544: LD_INT 4
106546: DOUBLE
106547: GREATEREQUAL
106548: IFFALSE 106556
106550: LD_INT 9
106552: DOUBLE
106553: LESSEQUAL
106554: IFTRUE 106558
106556: GO 106610
106558: POP
// begin bc_type := b_lab_half ;
106559: LD_ADDR_OWVAR 42
106563: PUSH
106564: LD_INT 7
106566: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106567: LD_ADDR_OWVAR 44
106571: PUSH
106572: LD_INT 10
106574: PUSH
106575: LD_INT 11
106577: PUSH
106578: LD_INT 12
106580: PUSH
106581: LD_INT 15
106583: PUSH
106584: LD_INT 14
106586: PUSH
106587: LD_INT 13
106589: PUSH
106590: EMPTY
106591: LIST
106592: LIST
106593: LIST
106594: LIST
106595: LIST
106596: LIST
106597: PUSH
106598: LD_VAR 0 2
106602: PUSH
106603: LD_INT 3
106605: MINUS
106606: ARRAY
106607: ST_TO_ADDR
// end ; 10 .. 13 :
106608: GO 107118
106610: LD_INT 10
106612: DOUBLE
106613: GREATEREQUAL
106614: IFFALSE 106622
106616: LD_INT 13
106618: DOUBLE
106619: LESSEQUAL
106620: IFTRUE 106624
106622: GO 106701
106624: POP
// begin bc_type := b_lab_full ;
106625: LD_ADDR_OWVAR 42
106629: PUSH
106630: LD_INT 8
106632: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106633: LD_ADDR_OWVAR 44
106637: PUSH
106638: LD_INT 10
106640: PUSH
106641: LD_INT 12
106643: PUSH
106644: LD_INT 14
106646: PUSH
106647: LD_INT 13
106649: PUSH
106650: EMPTY
106651: LIST
106652: LIST
106653: LIST
106654: LIST
106655: PUSH
106656: LD_VAR 0 2
106660: PUSH
106661: LD_INT 9
106663: MINUS
106664: ARRAY
106665: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106666: LD_ADDR_OWVAR 45
106670: PUSH
106671: LD_INT 11
106673: PUSH
106674: LD_INT 15
106676: PUSH
106677: LD_INT 12
106679: PUSH
106680: LD_INT 15
106682: PUSH
106683: EMPTY
106684: LIST
106685: LIST
106686: LIST
106687: LIST
106688: PUSH
106689: LD_VAR 0 2
106693: PUSH
106694: LD_INT 9
106696: MINUS
106697: ARRAY
106698: ST_TO_ADDR
// end ; 14 :
106699: GO 107118
106701: LD_INT 14
106703: DOUBLE
106704: EQUAL
106705: IFTRUE 106709
106707: GO 106720
106709: POP
// bc_type := b_workshop ; 15 :
106710: LD_ADDR_OWVAR 42
106714: PUSH
106715: LD_INT 2
106717: ST_TO_ADDR
106718: GO 107118
106720: LD_INT 15
106722: DOUBLE
106723: EQUAL
106724: IFTRUE 106728
106726: GO 106739
106728: POP
// bc_type := b_factory ; 16 :
106729: LD_ADDR_OWVAR 42
106733: PUSH
106734: LD_INT 3
106736: ST_TO_ADDR
106737: GO 107118
106739: LD_INT 16
106741: DOUBLE
106742: EQUAL
106743: IFTRUE 106747
106745: GO 106758
106747: POP
// bc_type := b_ext_gun ; 17 :
106748: LD_ADDR_OWVAR 42
106752: PUSH
106753: LD_INT 17
106755: ST_TO_ADDR
106756: GO 107118
106758: LD_INT 17
106760: DOUBLE
106761: EQUAL
106762: IFTRUE 106766
106764: GO 106794
106766: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106767: LD_ADDR_OWVAR 42
106771: PUSH
106772: LD_INT 19
106774: PUSH
106775: LD_INT 23
106777: PUSH
106778: LD_INT 19
106780: PUSH
106781: EMPTY
106782: LIST
106783: LIST
106784: LIST
106785: PUSH
106786: LD_VAR 0 1
106790: ARRAY
106791: ST_TO_ADDR
106792: GO 107118
106794: LD_INT 18
106796: DOUBLE
106797: EQUAL
106798: IFTRUE 106802
106800: GO 106813
106802: POP
// bc_type := b_ext_radar ; 19 :
106803: LD_ADDR_OWVAR 42
106807: PUSH
106808: LD_INT 20
106810: ST_TO_ADDR
106811: GO 107118
106813: LD_INT 19
106815: DOUBLE
106816: EQUAL
106817: IFTRUE 106821
106819: GO 106832
106821: POP
// bc_type := b_ext_radio ; 20 :
106822: LD_ADDR_OWVAR 42
106826: PUSH
106827: LD_INT 22
106829: ST_TO_ADDR
106830: GO 107118
106832: LD_INT 20
106834: DOUBLE
106835: EQUAL
106836: IFTRUE 106840
106838: GO 106851
106840: POP
// bc_type := b_ext_siberium ; 21 :
106841: LD_ADDR_OWVAR 42
106845: PUSH
106846: LD_INT 21
106848: ST_TO_ADDR
106849: GO 107118
106851: LD_INT 21
106853: DOUBLE
106854: EQUAL
106855: IFTRUE 106859
106857: GO 106870
106859: POP
// bc_type := b_ext_computer ; 22 :
106860: LD_ADDR_OWVAR 42
106864: PUSH
106865: LD_INT 24
106867: ST_TO_ADDR
106868: GO 107118
106870: LD_INT 22
106872: DOUBLE
106873: EQUAL
106874: IFTRUE 106878
106876: GO 106889
106878: POP
// bc_type := b_ext_track ; 23 :
106879: LD_ADDR_OWVAR 42
106883: PUSH
106884: LD_INT 16
106886: ST_TO_ADDR
106887: GO 107118
106889: LD_INT 23
106891: DOUBLE
106892: EQUAL
106893: IFTRUE 106897
106895: GO 106908
106897: POP
// bc_type := b_ext_laser ; 24 :
106898: LD_ADDR_OWVAR 42
106902: PUSH
106903: LD_INT 25
106905: ST_TO_ADDR
106906: GO 107118
106908: LD_INT 24
106910: DOUBLE
106911: EQUAL
106912: IFTRUE 106916
106914: GO 106927
106916: POP
// bc_type := b_control_tower ; 25 :
106917: LD_ADDR_OWVAR 42
106921: PUSH
106922: LD_INT 36
106924: ST_TO_ADDR
106925: GO 107118
106927: LD_INT 25
106929: DOUBLE
106930: EQUAL
106931: IFTRUE 106935
106933: GO 106946
106935: POP
// bc_type := b_breastwork ; 26 :
106936: LD_ADDR_OWVAR 42
106940: PUSH
106941: LD_INT 31
106943: ST_TO_ADDR
106944: GO 107118
106946: LD_INT 26
106948: DOUBLE
106949: EQUAL
106950: IFTRUE 106954
106952: GO 106965
106954: POP
// bc_type := b_bunker ; 27 :
106955: LD_ADDR_OWVAR 42
106959: PUSH
106960: LD_INT 32
106962: ST_TO_ADDR
106963: GO 107118
106965: LD_INT 27
106967: DOUBLE
106968: EQUAL
106969: IFTRUE 106973
106971: GO 106984
106973: POP
// bc_type := b_turret ; 28 :
106974: LD_ADDR_OWVAR 42
106978: PUSH
106979: LD_INT 33
106981: ST_TO_ADDR
106982: GO 107118
106984: LD_INT 28
106986: DOUBLE
106987: EQUAL
106988: IFTRUE 106992
106990: GO 107003
106992: POP
// bc_type := b_armoury ; 29 :
106993: LD_ADDR_OWVAR 42
106997: PUSH
106998: LD_INT 4
107000: ST_TO_ADDR
107001: GO 107118
107003: LD_INT 29
107005: DOUBLE
107006: EQUAL
107007: IFTRUE 107011
107009: GO 107022
107011: POP
// bc_type := b_barracks ; 30 :
107012: LD_ADDR_OWVAR 42
107016: PUSH
107017: LD_INT 5
107019: ST_TO_ADDR
107020: GO 107118
107022: LD_INT 30
107024: DOUBLE
107025: EQUAL
107026: IFTRUE 107030
107028: GO 107041
107030: POP
// bc_type := b_solar_power ; 31 :
107031: LD_ADDR_OWVAR 42
107035: PUSH
107036: LD_INT 27
107038: ST_TO_ADDR
107039: GO 107118
107041: LD_INT 31
107043: DOUBLE
107044: EQUAL
107045: IFTRUE 107049
107047: GO 107060
107049: POP
// bc_type := b_oil_power ; 32 :
107050: LD_ADDR_OWVAR 42
107054: PUSH
107055: LD_INT 26
107057: ST_TO_ADDR
107058: GO 107118
107060: LD_INT 32
107062: DOUBLE
107063: EQUAL
107064: IFTRUE 107068
107066: GO 107079
107068: POP
// bc_type := b_siberite_power ; 33 :
107069: LD_ADDR_OWVAR 42
107073: PUSH
107074: LD_INT 28
107076: ST_TO_ADDR
107077: GO 107118
107079: LD_INT 33
107081: DOUBLE
107082: EQUAL
107083: IFTRUE 107087
107085: GO 107098
107087: POP
// bc_type := b_oil_mine ; 34 :
107088: LD_ADDR_OWVAR 42
107092: PUSH
107093: LD_INT 29
107095: ST_TO_ADDR
107096: GO 107118
107098: LD_INT 34
107100: DOUBLE
107101: EQUAL
107102: IFTRUE 107106
107104: GO 107117
107106: POP
// bc_type := b_siberite_mine ; end ;
107107: LD_ADDR_OWVAR 42
107111: PUSH
107112: LD_INT 30
107114: ST_TO_ADDR
107115: GO 107118
107117: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107118: LD_ADDR_VAR 0 8
107122: PUSH
107123: LD_VAR 0 5
107127: PPUSH
107128: LD_VAR 0 6
107132: PPUSH
107133: LD_VAR 0 3
107137: PPUSH
107138: CALL_OW 47
107142: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107143: LD_OWVAR 42
107147: PUSH
107148: LD_INT 32
107150: PUSH
107151: LD_INT 33
107153: PUSH
107154: EMPTY
107155: LIST
107156: LIST
107157: IN
107158: IFFALSE 107174
// PlaceWeaponTurret ( b , weapon ) ;
107160: LD_VAR 0 8
107164: PPUSH
107165: LD_VAR 0 4
107169: PPUSH
107170: CALL_OW 431
// end ;
107174: LD_VAR 0 7
107178: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107179: LD_INT 0
107181: PPUSH
107182: PPUSH
107183: PPUSH
107184: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107185: LD_ADDR_VAR 0 4
107189: PUSH
107190: LD_INT 22
107192: PUSH
107193: LD_OWVAR 2
107197: PUSH
107198: EMPTY
107199: LIST
107200: LIST
107201: PUSH
107202: LD_INT 2
107204: PUSH
107205: LD_INT 30
107207: PUSH
107208: LD_INT 0
107210: PUSH
107211: EMPTY
107212: LIST
107213: LIST
107214: PUSH
107215: LD_INT 30
107217: PUSH
107218: LD_INT 1
107220: PUSH
107221: EMPTY
107222: LIST
107223: LIST
107224: PUSH
107225: EMPTY
107226: LIST
107227: LIST
107228: LIST
107229: PUSH
107230: EMPTY
107231: LIST
107232: LIST
107233: PPUSH
107234: CALL_OW 69
107238: ST_TO_ADDR
// if not tmp then
107239: LD_VAR 0 4
107243: NOT
107244: IFFALSE 107248
// exit ;
107246: GO 107307
// for i in tmp do
107248: LD_ADDR_VAR 0 2
107252: PUSH
107253: LD_VAR 0 4
107257: PUSH
107258: FOR_IN
107259: IFFALSE 107305
// for j = 1 to 3 do
107261: LD_ADDR_VAR 0 3
107265: PUSH
107266: DOUBLE
107267: LD_INT 1
107269: DEC
107270: ST_TO_ADDR
107271: LD_INT 3
107273: PUSH
107274: FOR_TO
107275: IFFALSE 107301
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107277: LD_VAR 0 2
107281: PPUSH
107282: CALL_OW 274
107286: PPUSH
107287: LD_VAR 0 3
107291: PPUSH
107292: LD_INT 99999
107294: PPUSH
107295: CALL_OW 277
107299: GO 107274
107301: POP
107302: POP
107303: GO 107258
107305: POP
107306: POP
// end ;
107307: LD_VAR 0 1
107311: RET
// export function hHackSetLevel10 ; var i , j ; begin
107312: LD_INT 0
107314: PPUSH
107315: PPUSH
107316: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107317: LD_ADDR_VAR 0 2
107321: PUSH
107322: LD_INT 21
107324: PUSH
107325: LD_INT 1
107327: PUSH
107328: EMPTY
107329: LIST
107330: LIST
107331: PPUSH
107332: CALL_OW 69
107336: PUSH
107337: FOR_IN
107338: IFFALSE 107390
// if IsSelected ( i ) then
107340: LD_VAR 0 2
107344: PPUSH
107345: CALL_OW 306
107349: IFFALSE 107388
// begin for j := 1 to 4 do
107351: LD_ADDR_VAR 0 3
107355: PUSH
107356: DOUBLE
107357: LD_INT 1
107359: DEC
107360: ST_TO_ADDR
107361: LD_INT 4
107363: PUSH
107364: FOR_TO
107365: IFFALSE 107386
// SetSkill ( i , j , 10 ) ;
107367: LD_VAR 0 2
107371: PPUSH
107372: LD_VAR 0 3
107376: PPUSH
107377: LD_INT 10
107379: PPUSH
107380: CALL_OW 237
107384: GO 107364
107386: POP
107387: POP
// end ;
107388: GO 107337
107390: POP
107391: POP
// end ;
107392: LD_VAR 0 1
107396: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107397: LD_INT 0
107399: PPUSH
107400: PPUSH
107401: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107402: LD_ADDR_VAR 0 2
107406: PUSH
107407: LD_INT 22
107409: PUSH
107410: LD_OWVAR 2
107414: PUSH
107415: EMPTY
107416: LIST
107417: LIST
107418: PUSH
107419: LD_INT 21
107421: PUSH
107422: LD_INT 1
107424: PUSH
107425: EMPTY
107426: LIST
107427: LIST
107428: PUSH
107429: EMPTY
107430: LIST
107431: LIST
107432: PPUSH
107433: CALL_OW 69
107437: PUSH
107438: FOR_IN
107439: IFFALSE 107480
// begin for j := 1 to 4 do
107441: LD_ADDR_VAR 0 3
107445: PUSH
107446: DOUBLE
107447: LD_INT 1
107449: DEC
107450: ST_TO_ADDR
107451: LD_INT 4
107453: PUSH
107454: FOR_TO
107455: IFFALSE 107476
// SetSkill ( i , j , 10 ) ;
107457: LD_VAR 0 2
107461: PPUSH
107462: LD_VAR 0 3
107466: PPUSH
107467: LD_INT 10
107469: PPUSH
107470: CALL_OW 237
107474: GO 107454
107476: POP
107477: POP
// end ;
107478: GO 107438
107480: POP
107481: POP
// end ;
107482: LD_VAR 0 1
107486: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107487: LD_INT 0
107489: PPUSH
// uc_side := your_side ;
107490: LD_ADDR_OWVAR 20
107494: PUSH
107495: LD_OWVAR 2
107499: ST_TO_ADDR
// uc_nation := nation ;
107500: LD_ADDR_OWVAR 21
107504: PUSH
107505: LD_VAR 0 1
107509: ST_TO_ADDR
// InitHc ;
107510: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107514: LD_INT 0
107516: PPUSH
107517: LD_VAR 0 2
107521: PPUSH
107522: LD_VAR 0 3
107526: PPUSH
107527: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107531: LD_VAR 0 4
107535: PPUSH
107536: LD_VAR 0 5
107540: PPUSH
107541: CALL_OW 428
107545: PUSH
107546: LD_INT 0
107548: EQUAL
107549: IFFALSE 107573
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107551: CALL_OW 44
107555: PPUSH
107556: LD_VAR 0 4
107560: PPUSH
107561: LD_VAR 0 5
107565: PPUSH
107566: LD_INT 1
107568: PPUSH
107569: CALL_OW 48
// end ;
107573: LD_VAR 0 6
107577: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107578: LD_INT 0
107580: PPUSH
107581: PPUSH
// uc_side := your_side ;
107582: LD_ADDR_OWVAR 20
107586: PUSH
107587: LD_OWVAR 2
107591: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107592: LD_VAR 0 1
107596: PUSH
107597: LD_INT 1
107599: PUSH
107600: LD_INT 2
107602: PUSH
107603: LD_INT 3
107605: PUSH
107606: LD_INT 4
107608: PUSH
107609: LD_INT 5
107611: PUSH
107612: EMPTY
107613: LIST
107614: LIST
107615: LIST
107616: LIST
107617: LIST
107618: IN
107619: IFFALSE 107631
// uc_nation := nation_american else
107621: LD_ADDR_OWVAR 21
107625: PUSH
107626: LD_INT 1
107628: ST_TO_ADDR
107629: GO 107674
// if chassis in [ 11 , 12 , 13 , 14 ] then
107631: LD_VAR 0 1
107635: PUSH
107636: LD_INT 11
107638: PUSH
107639: LD_INT 12
107641: PUSH
107642: LD_INT 13
107644: PUSH
107645: LD_INT 14
107647: PUSH
107648: EMPTY
107649: LIST
107650: LIST
107651: LIST
107652: LIST
107653: IN
107654: IFFALSE 107666
// uc_nation := nation_arabian else
107656: LD_ADDR_OWVAR 21
107660: PUSH
107661: LD_INT 2
107663: ST_TO_ADDR
107664: GO 107674
// uc_nation := nation_russian ;
107666: LD_ADDR_OWVAR 21
107670: PUSH
107671: LD_INT 3
107673: ST_TO_ADDR
// vc_chassis := chassis ;
107674: LD_ADDR_OWVAR 37
107678: PUSH
107679: LD_VAR 0 1
107683: ST_TO_ADDR
// vc_engine := engine ;
107684: LD_ADDR_OWVAR 39
107688: PUSH
107689: LD_VAR 0 2
107693: ST_TO_ADDR
// vc_control := control ;
107694: LD_ADDR_OWVAR 38
107698: PUSH
107699: LD_VAR 0 3
107703: ST_TO_ADDR
// vc_weapon := weapon ;
107704: LD_ADDR_OWVAR 40
107708: PUSH
107709: LD_VAR 0 4
107713: ST_TO_ADDR
// un := CreateVehicle ;
107714: LD_ADDR_VAR 0 8
107718: PUSH
107719: CALL_OW 45
107723: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107724: LD_VAR 0 8
107728: PPUSH
107729: LD_INT 0
107731: PPUSH
107732: LD_INT 5
107734: PPUSH
107735: CALL_OW 12
107739: PPUSH
107740: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107744: LD_VAR 0 8
107748: PPUSH
107749: LD_VAR 0 5
107753: PPUSH
107754: LD_VAR 0 6
107758: PPUSH
107759: LD_INT 1
107761: PPUSH
107762: CALL_OW 48
// end ;
107766: LD_VAR 0 7
107770: RET
// export hInvincible ; every 1 do
107771: GO 107773
107773: DISABLE
// hInvincible := [ ] ;
107774: LD_ADDR_EXP 156
107778: PUSH
107779: EMPTY
107780: ST_TO_ADDR
107781: END
// every 10 do var i ;
107782: GO 107784
107784: DISABLE
107785: LD_INT 0
107787: PPUSH
// begin enable ;
107788: ENABLE
// if not hInvincible then
107789: LD_EXP 156
107793: NOT
107794: IFFALSE 107798
// exit ;
107796: GO 107842
// for i in hInvincible do
107798: LD_ADDR_VAR 0 1
107802: PUSH
107803: LD_EXP 156
107807: PUSH
107808: FOR_IN
107809: IFFALSE 107840
// if GetLives ( i ) < 1000 then
107811: LD_VAR 0 1
107815: PPUSH
107816: CALL_OW 256
107820: PUSH
107821: LD_INT 1000
107823: LESS
107824: IFFALSE 107838
// SetLives ( i , 1000 ) ;
107826: LD_VAR 0 1
107830: PPUSH
107831: LD_INT 1000
107833: PPUSH
107834: CALL_OW 234
107838: GO 107808
107840: POP
107841: POP
// end ;
107842: PPOPN 1
107844: END
// export function hHackInvincible ; var i ; begin
107845: LD_INT 0
107847: PPUSH
107848: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107849: LD_ADDR_VAR 0 2
107853: PUSH
107854: LD_INT 2
107856: PUSH
107857: LD_INT 21
107859: PUSH
107860: LD_INT 1
107862: PUSH
107863: EMPTY
107864: LIST
107865: LIST
107866: PUSH
107867: LD_INT 21
107869: PUSH
107870: LD_INT 2
107872: PUSH
107873: EMPTY
107874: LIST
107875: LIST
107876: PUSH
107877: EMPTY
107878: LIST
107879: LIST
107880: LIST
107881: PPUSH
107882: CALL_OW 69
107886: PUSH
107887: FOR_IN
107888: IFFALSE 107949
// if IsSelected ( i ) then
107890: LD_VAR 0 2
107894: PPUSH
107895: CALL_OW 306
107899: IFFALSE 107947
// begin if i in hInvincible then
107901: LD_VAR 0 2
107905: PUSH
107906: LD_EXP 156
107910: IN
107911: IFFALSE 107931
// hInvincible := hInvincible diff i else
107913: LD_ADDR_EXP 156
107917: PUSH
107918: LD_EXP 156
107922: PUSH
107923: LD_VAR 0 2
107927: DIFF
107928: ST_TO_ADDR
107929: GO 107947
// hInvincible := hInvincible union i ;
107931: LD_ADDR_EXP 156
107935: PUSH
107936: LD_EXP 156
107940: PUSH
107941: LD_VAR 0 2
107945: UNION
107946: ST_TO_ADDR
// end ;
107947: GO 107887
107949: POP
107950: POP
// end ;
107951: LD_VAR 0 1
107955: RET
// export function hHackInvisible ; var i , j ; begin
107956: LD_INT 0
107958: PPUSH
107959: PPUSH
107960: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107961: LD_ADDR_VAR 0 2
107965: PUSH
107966: LD_INT 21
107968: PUSH
107969: LD_INT 1
107971: PUSH
107972: EMPTY
107973: LIST
107974: LIST
107975: PPUSH
107976: CALL_OW 69
107980: PUSH
107981: FOR_IN
107982: IFFALSE 108006
// if IsSelected ( i ) then
107984: LD_VAR 0 2
107988: PPUSH
107989: CALL_OW 306
107993: IFFALSE 108004
// ComForceInvisible ( i ) ;
107995: LD_VAR 0 2
107999: PPUSH
108000: CALL_OW 496
108004: GO 107981
108006: POP
108007: POP
// end ;
108008: LD_VAR 0 1
108012: RET
// export function hHackChangeYourSide ; begin
108013: LD_INT 0
108015: PPUSH
// if your_side = 8 then
108016: LD_OWVAR 2
108020: PUSH
108021: LD_INT 8
108023: EQUAL
108024: IFFALSE 108036
// your_side := 0 else
108026: LD_ADDR_OWVAR 2
108030: PUSH
108031: LD_INT 0
108033: ST_TO_ADDR
108034: GO 108050
// your_side := your_side + 1 ;
108036: LD_ADDR_OWVAR 2
108040: PUSH
108041: LD_OWVAR 2
108045: PUSH
108046: LD_INT 1
108048: PLUS
108049: ST_TO_ADDR
// end ;
108050: LD_VAR 0 1
108054: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108055: LD_INT 0
108057: PPUSH
108058: PPUSH
108059: PPUSH
// for i in all_units do
108060: LD_ADDR_VAR 0 2
108064: PUSH
108065: LD_OWVAR 3
108069: PUSH
108070: FOR_IN
108071: IFFALSE 108149
// if IsSelected ( i ) then
108073: LD_VAR 0 2
108077: PPUSH
108078: CALL_OW 306
108082: IFFALSE 108147
// begin j := GetSide ( i ) ;
108084: LD_ADDR_VAR 0 3
108088: PUSH
108089: LD_VAR 0 2
108093: PPUSH
108094: CALL_OW 255
108098: ST_TO_ADDR
// if j = 8 then
108099: LD_VAR 0 3
108103: PUSH
108104: LD_INT 8
108106: EQUAL
108107: IFFALSE 108119
// j := 0 else
108109: LD_ADDR_VAR 0 3
108113: PUSH
108114: LD_INT 0
108116: ST_TO_ADDR
108117: GO 108133
// j := j + 1 ;
108119: LD_ADDR_VAR 0 3
108123: PUSH
108124: LD_VAR 0 3
108128: PUSH
108129: LD_INT 1
108131: PLUS
108132: ST_TO_ADDR
// SetSide ( i , j ) ;
108133: LD_VAR 0 2
108137: PPUSH
108138: LD_VAR 0 3
108142: PPUSH
108143: CALL_OW 235
// end ;
108147: GO 108070
108149: POP
108150: POP
// end ;
108151: LD_VAR 0 1
108155: RET
// export function hHackFog ; begin
108156: LD_INT 0
108158: PPUSH
// FogOff ( true ) ;
108159: LD_INT 1
108161: PPUSH
108162: CALL_OW 344
// end ;
108166: LD_VAR 0 1
108170: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108171: LD_INT 0
108173: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108174: LD_VAR 0 1
108178: PPUSH
108179: LD_VAR 0 2
108183: PPUSH
108184: LD_VAR 0 3
108188: PPUSH
108189: LD_INT 1
108191: PPUSH
108192: LD_INT 1
108194: PPUSH
108195: CALL_OW 483
// CenterOnXY ( x , y ) ;
108199: LD_VAR 0 2
108203: PPUSH
108204: LD_VAR 0 3
108208: PPUSH
108209: CALL_OW 84
// end ;
108213: LD_VAR 0 4
108217: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
108218: LD_INT 0
108220: PPUSH
108221: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
108222: LD_VAR 0 1
108226: NOT
108227: PUSH
108228: LD_VAR 0 2
108232: PPUSH
108233: LD_VAR 0 3
108237: PPUSH
108238: CALL_OW 488
108242: NOT
108243: OR
108244: PUSH
108245: LD_VAR 0 1
108249: PPUSH
108250: CALL_OW 266
108254: PUSH
108255: LD_INT 3
108257: NONEQUAL
108258: PUSH
108259: LD_VAR 0 1
108263: PPUSH
108264: CALL_OW 247
108268: PUSH
108269: LD_INT 1
108271: EQUAL
108272: NOT
108273: AND
108274: OR
108275: IFFALSE 108279
// exit ;
108277: GO 108428
// if GetType ( factory ) = unit_human then
108279: LD_VAR 0 1
108283: PPUSH
108284: CALL_OW 247
108288: PUSH
108289: LD_INT 1
108291: EQUAL
108292: IFFALSE 108309
// factory := IsInUnit ( factory ) ;
108294: LD_ADDR_VAR 0 1
108298: PUSH
108299: LD_VAR 0 1
108303: PPUSH
108304: CALL_OW 310
108308: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108309: LD_VAR 0 1
108313: PPUSH
108314: CALL_OW 266
108318: PUSH
108319: LD_INT 3
108321: NONEQUAL
108322: IFFALSE 108326
// exit ;
108324: GO 108428
// if HexInfo ( x , y ) = factory then
108326: LD_VAR 0 2
108330: PPUSH
108331: LD_VAR 0 3
108335: PPUSH
108336: CALL_OW 428
108340: PUSH
108341: LD_VAR 0 1
108345: EQUAL
108346: IFFALSE 108373
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
108348: LD_ADDR_EXP 157
108352: PUSH
108353: LD_EXP 157
108357: PPUSH
108358: LD_VAR 0 1
108362: PPUSH
108363: LD_INT 0
108365: PPUSH
108366: CALL_OW 1
108370: ST_TO_ADDR
108371: GO 108424
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
108373: LD_ADDR_EXP 157
108377: PUSH
108378: LD_EXP 157
108382: PPUSH
108383: LD_VAR 0 1
108387: PPUSH
108388: LD_VAR 0 1
108392: PPUSH
108393: CALL_OW 255
108397: PUSH
108398: LD_VAR 0 1
108402: PUSH
108403: LD_VAR 0 2
108407: PUSH
108408: LD_VAR 0 3
108412: PUSH
108413: EMPTY
108414: LIST
108415: LIST
108416: LIST
108417: LIST
108418: PPUSH
108419: CALL_OW 1
108423: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108424: CALL 108433 0 0
// end ;
108428: LD_VAR 0 4
108432: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108433: LD_INT 0
108435: PPUSH
108436: PPUSH
108437: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108438: LD_STRING resetFactoryWaypoint();
108440: PPUSH
108441: CALL_OW 559
// if factoryWaypoints then
108445: LD_EXP 157
108449: IFFALSE 108575
// begin list := PrepareArray ( factoryWaypoints ) ;
108451: LD_ADDR_VAR 0 3
108455: PUSH
108456: LD_EXP 157
108460: PPUSH
108461: CALL 51077 0 1
108465: ST_TO_ADDR
// for i := 1 to list do
108466: LD_ADDR_VAR 0 2
108470: PUSH
108471: DOUBLE
108472: LD_INT 1
108474: DEC
108475: ST_TO_ADDR
108476: LD_VAR 0 3
108480: PUSH
108481: FOR_TO
108482: IFFALSE 108573
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108484: LD_STRING setFactoryWaypointXY(
108486: PUSH
108487: LD_VAR 0 3
108491: PUSH
108492: LD_VAR 0 2
108496: ARRAY
108497: PUSH
108498: LD_INT 1
108500: ARRAY
108501: STR
108502: PUSH
108503: LD_STRING ,
108505: STR
108506: PUSH
108507: LD_VAR 0 3
108511: PUSH
108512: LD_VAR 0 2
108516: ARRAY
108517: PUSH
108518: LD_INT 2
108520: ARRAY
108521: STR
108522: PUSH
108523: LD_STRING ,
108525: STR
108526: PUSH
108527: LD_VAR 0 3
108531: PUSH
108532: LD_VAR 0 2
108536: ARRAY
108537: PUSH
108538: LD_INT 3
108540: ARRAY
108541: STR
108542: PUSH
108543: LD_STRING ,
108545: STR
108546: PUSH
108547: LD_VAR 0 3
108551: PUSH
108552: LD_VAR 0 2
108556: ARRAY
108557: PUSH
108558: LD_INT 4
108560: ARRAY
108561: STR
108562: PUSH
108563: LD_STRING )
108565: STR
108566: PPUSH
108567: CALL_OW 559
108571: GO 108481
108573: POP
108574: POP
// end ; end ;
108575: LD_VAR 0 1
108579: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
108580: LD_INT 0
108582: PPUSH
// if HexInfo ( x , y ) = warehouse then
108583: LD_VAR 0 2
108587: PPUSH
108588: LD_VAR 0 3
108592: PPUSH
108593: CALL_OW 428
108597: PUSH
108598: LD_VAR 0 1
108602: EQUAL
108603: IFFALSE 108630
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
108605: LD_ADDR_EXP 158
108609: PUSH
108610: LD_EXP 158
108614: PPUSH
108615: LD_VAR 0 1
108619: PPUSH
108620: LD_INT 0
108622: PPUSH
108623: CALL_OW 1
108627: ST_TO_ADDR
108628: GO 108681
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108630: LD_ADDR_EXP 158
108634: PUSH
108635: LD_EXP 158
108639: PPUSH
108640: LD_VAR 0 1
108644: PPUSH
108645: LD_VAR 0 1
108649: PPUSH
108650: CALL_OW 255
108654: PUSH
108655: LD_VAR 0 1
108659: PUSH
108660: LD_VAR 0 2
108664: PUSH
108665: LD_VAR 0 3
108669: PUSH
108670: EMPTY
108671: LIST
108672: LIST
108673: LIST
108674: LIST
108675: PPUSH
108676: CALL_OW 1
108680: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108681: CALL 108690 0 0
// end ;
108685: LD_VAR 0 4
108689: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108690: LD_INT 0
108692: PPUSH
108693: PPUSH
108694: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108695: LD_STRING resetWarehouseGatheringPoints();
108697: PPUSH
108698: CALL_OW 559
// if warehouseGatheringPoints then
108702: LD_EXP 158
108706: IFFALSE 108832
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108708: LD_ADDR_VAR 0 3
108712: PUSH
108713: LD_EXP 158
108717: PPUSH
108718: CALL 51077 0 1
108722: ST_TO_ADDR
// for i := 1 to list do
108723: LD_ADDR_VAR 0 2
108727: PUSH
108728: DOUBLE
108729: LD_INT 1
108731: DEC
108732: ST_TO_ADDR
108733: LD_VAR 0 3
108737: PUSH
108738: FOR_TO
108739: IFFALSE 108830
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108741: LD_STRING setWarehouseGatheringPointXY(
108743: PUSH
108744: LD_VAR 0 3
108748: PUSH
108749: LD_VAR 0 2
108753: ARRAY
108754: PUSH
108755: LD_INT 1
108757: ARRAY
108758: STR
108759: PUSH
108760: LD_STRING ,
108762: STR
108763: PUSH
108764: LD_VAR 0 3
108768: PUSH
108769: LD_VAR 0 2
108773: ARRAY
108774: PUSH
108775: LD_INT 2
108777: ARRAY
108778: STR
108779: PUSH
108780: LD_STRING ,
108782: STR
108783: PUSH
108784: LD_VAR 0 3
108788: PUSH
108789: LD_VAR 0 2
108793: ARRAY
108794: PUSH
108795: LD_INT 3
108797: ARRAY
108798: STR
108799: PUSH
108800: LD_STRING ,
108802: STR
108803: PUSH
108804: LD_VAR 0 3
108808: PUSH
108809: LD_VAR 0 2
108813: ARRAY
108814: PUSH
108815: LD_INT 4
108817: ARRAY
108818: STR
108819: PUSH
108820: LD_STRING )
108822: STR
108823: PPUSH
108824: CALL_OW 559
108828: GO 108738
108830: POP
108831: POP
// end ; end ;
108832: LD_VAR 0 1
108836: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108837: LD_EXP 158
108841: IFFALSE 109526
108843: GO 108845
108845: DISABLE
108846: LD_INT 0
108848: PPUSH
108849: PPUSH
108850: PPUSH
108851: PPUSH
108852: PPUSH
108853: PPUSH
108854: PPUSH
108855: PPUSH
108856: PPUSH
// begin enable ;
108857: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108858: LD_ADDR_VAR 0 3
108862: PUSH
108863: LD_EXP 158
108867: PPUSH
108868: CALL 51077 0 1
108872: ST_TO_ADDR
// if not list then
108873: LD_VAR 0 3
108877: NOT
108878: IFFALSE 108882
// exit ;
108880: GO 109526
// for i := 1 to list do
108882: LD_ADDR_VAR 0 1
108886: PUSH
108887: DOUBLE
108888: LD_INT 1
108890: DEC
108891: ST_TO_ADDR
108892: LD_VAR 0 3
108896: PUSH
108897: FOR_TO
108898: IFFALSE 109524
// begin depot := list [ i ] [ 2 ] ;
108900: LD_ADDR_VAR 0 8
108904: PUSH
108905: LD_VAR 0 3
108909: PUSH
108910: LD_VAR 0 1
108914: ARRAY
108915: PUSH
108916: LD_INT 2
108918: ARRAY
108919: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
108920: LD_ADDR_VAR 0 5
108924: PUSH
108925: LD_VAR 0 3
108929: PUSH
108930: LD_VAR 0 1
108934: ARRAY
108935: PUSH
108936: LD_INT 1
108938: ARRAY
108939: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
108940: LD_VAR 0 8
108944: PPUSH
108945: CALL_OW 301
108949: PUSH
108950: LD_VAR 0 5
108954: PUSH
108955: LD_VAR 0 8
108959: PPUSH
108960: CALL_OW 255
108964: NONEQUAL
108965: OR
108966: IFFALSE 108995
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
108968: LD_ADDR_EXP 158
108972: PUSH
108973: LD_EXP 158
108977: PPUSH
108978: LD_VAR 0 8
108982: PPUSH
108983: LD_INT 0
108985: PPUSH
108986: CALL_OW 1
108990: ST_TO_ADDR
// exit ;
108991: POP
108992: POP
108993: GO 109526
// end ; x := list [ i ] [ 3 ] ;
108995: LD_ADDR_VAR 0 6
108999: PUSH
109000: LD_VAR 0 3
109004: PUSH
109005: LD_VAR 0 1
109009: ARRAY
109010: PUSH
109011: LD_INT 3
109013: ARRAY
109014: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109015: LD_ADDR_VAR 0 7
109019: PUSH
109020: LD_VAR 0 3
109024: PUSH
109025: LD_VAR 0 1
109029: ARRAY
109030: PUSH
109031: LD_INT 4
109033: ARRAY
109034: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109035: LD_ADDR_VAR 0 9
109039: PUSH
109040: LD_VAR 0 6
109044: PPUSH
109045: LD_VAR 0 7
109049: PPUSH
109050: LD_INT 16
109052: PPUSH
109053: CALL 49665 0 3
109057: ST_TO_ADDR
// if not cratesNearbyPoint then
109058: LD_VAR 0 9
109062: NOT
109063: IFFALSE 109069
// exit ;
109065: POP
109066: POP
109067: GO 109526
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109069: LD_ADDR_VAR 0 4
109073: PUSH
109074: LD_INT 22
109076: PUSH
109077: LD_VAR 0 5
109081: PUSH
109082: EMPTY
109083: LIST
109084: LIST
109085: PUSH
109086: LD_INT 3
109088: PUSH
109089: LD_INT 60
109091: PUSH
109092: EMPTY
109093: LIST
109094: PUSH
109095: EMPTY
109096: LIST
109097: LIST
109098: PUSH
109099: LD_INT 91
109101: PUSH
109102: LD_VAR 0 8
109106: PUSH
109107: LD_INT 6
109109: PUSH
109110: EMPTY
109111: LIST
109112: LIST
109113: LIST
109114: PUSH
109115: LD_INT 2
109117: PUSH
109118: LD_INT 25
109120: PUSH
109121: LD_INT 2
109123: PUSH
109124: EMPTY
109125: LIST
109126: LIST
109127: PUSH
109128: LD_INT 25
109130: PUSH
109131: LD_INT 16
109133: PUSH
109134: EMPTY
109135: LIST
109136: LIST
109137: PUSH
109138: EMPTY
109139: LIST
109140: LIST
109141: LIST
109142: PUSH
109143: EMPTY
109144: LIST
109145: LIST
109146: LIST
109147: LIST
109148: PPUSH
109149: CALL_OW 69
109153: PUSH
109154: LD_VAR 0 8
109158: PPUSH
109159: CALL_OW 313
109163: PPUSH
109164: LD_INT 3
109166: PUSH
109167: LD_INT 60
109169: PUSH
109170: EMPTY
109171: LIST
109172: PUSH
109173: EMPTY
109174: LIST
109175: LIST
109176: PUSH
109177: LD_INT 2
109179: PUSH
109180: LD_INT 25
109182: PUSH
109183: LD_INT 2
109185: PUSH
109186: EMPTY
109187: LIST
109188: LIST
109189: PUSH
109190: LD_INT 25
109192: PUSH
109193: LD_INT 16
109195: PUSH
109196: EMPTY
109197: LIST
109198: LIST
109199: PUSH
109200: EMPTY
109201: LIST
109202: LIST
109203: LIST
109204: PUSH
109205: EMPTY
109206: LIST
109207: LIST
109208: PPUSH
109209: CALL_OW 72
109213: UNION
109214: ST_TO_ADDR
// if tmp then
109215: LD_VAR 0 4
109219: IFFALSE 109299
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109221: LD_ADDR_VAR 0 4
109225: PUSH
109226: LD_VAR 0 4
109230: PPUSH
109231: LD_INT 3
109233: PPUSH
109234: CALL 47634 0 2
109238: ST_TO_ADDR
// for j in tmp do
109239: LD_ADDR_VAR 0 2
109243: PUSH
109244: LD_VAR 0 4
109248: PUSH
109249: FOR_IN
109250: IFFALSE 109293
// begin if IsInUnit ( j ) then
109252: LD_VAR 0 2
109256: PPUSH
109257: CALL_OW 310
109261: IFFALSE 109272
// ComExit ( j ) ;
109263: LD_VAR 0 2
109267: PPUSH
109268: CALL 47717 0 1
// AddComCollect ( j , x , y ) ;
109272: LD_VAR 0 2
109276: PPUSH
109277: LD_VAR 0 6
109281: PPUSH
109282: LD_VAR 0 7
109286: PPUSH
109287: CALL_OW 177
// end ;
109291: GO 109249
109293: POP
109294: POP
// exit ;
109295: POP
109296: POP
109297: GO 109526
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109299: LD_ADDR_VAR 0 4
109303: PUSH
109304: LD_INT 22
109306: PUSH
109307: LD_VAR 0 5
109311: PUSH
109312: EMPTY
109313: LIST
109314: LIST
109315: PUSH
109316: LD_INT 91
109318: PUSH
109319: LD_VAR 0 8
109323: PUSH
109324: LD_INT 8
109326: PUSH
109327: EMPTY
109328: LIST
109329: LIST
109330: LIST
109331: PUSH
109332: LD_INT 2
109334: PUSH
109335: LD_INT 34
109337: PUSH
109338: LD_INT 12
109340: PUSH
109341: EMPTY
109342: LIST
109343: LIST
109344: PUSH
109345: LD_INT 34
109347: PUSH
109348: LD_INT 51
109350: PUSH
109351: EMPTY
109352: LIST
109353: LIST
109354: PUSH
109355: LD_INT 34
109357: PUSH
109358: LD_INT 32
109360: PUSH
109361: EMPTY
109362: LIST
109363: LIST
109364: PUSH
109365: LD_INT 34
109367: PUSH
109368: LD_INT 89
109370: PUSH
109371: EMPTY
109372: LIST
109373: LIST
109374: PUSH
109375: EMPTY
109376: LIST
109377: LIST
109378: LIST
109379: LIST
109380: LIST
109381: PUSH
109382: EMPTY
109383: LIST
109384: LIST
109385: LIST
109386: PPUSH
109387: CALL_OW 69
109391: ST_TO_ADDR
// if tmp then
109392: LD_VAR 0 4
109396: IFFALSE 109522
// begin for j in tmp do
109398: LD_ADDR_VAR 0 2
109402: PUSH
109403: LD_VAR 0 4
109407: PUSH
109408: FOR_IN
109409: IFFALSE 109520
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109411: LD_VAR 0 2
109415: PPUSH
109416: CALL_OW 262
109420: PUSH
109421: LD_INT 3
109423: EQUAL
109424: PUSH
109425: LD_VAR 0 2
109429: PPUSH
109430: CALL_OW 261
109434: PUSH
109435: LD_INT 20
109437: GREATER
109438: OR
109439: PUSH
109440: LD_VAR 0 2
109444: PPUSH
109445: CALL_OW 314
109449: NOT
109450: AND
109451: PUSH
109452: LD_VAR 0 2
109456: PPUSH
109457: CALL_OW 263
109461: PUSH
109462: LD_INT 1
109464: NONEQUAL
109465: PUSH
109466: LD_VAR 0 2
109470: PPUSH
109471: CALL_OW 311
109475: OR
109476: AND
109477: IFFALSE 109518
// begin ComCollect ( j , x , y ) ;
109479: LD_VAR 0 2
109483: PPUSH
109484: LD_VAR 0 6
109488: PPUSH
109489: LD_VAR 0 7
109493: PPUSH
109494: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109498: LD_VAR 0 2
109502: PPUSH
109503: LD_VAR 0 8
109507: PPUSH
109508: CALL_OW 172
// exit ;
109512: POP
109513: POP
109514: POP
109515: POP
109516: GO 109526
// end ;
109518: GO 109408
109520: POP
109521: POP
// end ; end ;
109522: GO 108897
109524: POP
109525: POP
// end ;
109526: PPOPN 9
109528: END
