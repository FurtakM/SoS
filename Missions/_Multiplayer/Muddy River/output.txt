// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 331 0 0
// InitMultiplayer ;
  20: CALL 592 0 0
// if debug then
  24: LD_EXP 1
  28: IFFALSE 37
// FogOff ( 1 ) ;
  30: LD_INT 1
  32: PPUSH
  33: CALL_OW 344
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  37: LD_INT 2
  39: PPUSH
  40: CALL 1868 0 1
  44: PPUSH
  45: CALL 5813 0 1
// Multiplayer_Start ;
  49: CALL 3730 0 0
// ResetFog ;
  53: CALL_OW 335
// InitMacro ;
  57: CALL 51736 0 0
// MC_Start ( ) ;
  61: CALL 53916 0 0
// game := true ;
  65: LD_ADDR_EXP 2
  69: PUSH
  70: LD_INT 1
  72: ST_TO_ADDR
// Multiplayer_End ;
  73: CALL 3846 0 0
// end ;
  77: END
// export function CustomInitMacro ; var i ; begin
  78: LD_INT 0
  80: PPUSH
  81: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
  82: LD_INT 1
  84: PPUSH
  85: LD_INT 8
  87: PUSH
  88: LD_INT 10
  90: PUSH
  91: LD_INT 12
  93: PUSH
  94: EMPTY
  95: LIST
  96: LIST
  97: LIST
  98: PUSH
  99: LD_OWVAR 67
 103: ARRAY
 104: PPUSH
 105: LD_INT 3
 107: PPUSH
 108: CALL 75633 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 112: LD_INT 2
 114: PPUSH
 115: LD_INT 6
 117: PUSH
 118: LD_INT 8
 120: PUSH
 121: LD_INT 9
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 75633 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 6
 147: PUSH
 148: LD_INT 7
 150: PUSH
 151: LD_INT 9
 153: PUSH
 154: EMPTY
 155: LIST
 156: LIST
 157: LIST
 158: PUSH
 159: LD_OWVAR 67
 163: ARRAY
 164: PPUSH
 165: LD_INT 1
 167: PPUSH
 168: CALL 75633 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 172: LD_INT 4
 174: PPUSH
 175: LD_INT 6
 177: PUSH
 178: LD_INT 7
 180: PUSH
 181: LD_INT 9
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: LIST
 188: PUSH
 189: LD_OWVAR 67
 193: ARRAY
 194: PPUSH
 195: LD_INT 25
 197: PPUSH
 198: CALL 75633 0 3
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 202: LD_INT 5
 204: PPUSH
 205: LD_INT 4
 207: PUSH
 208: LD_INT 5
 210: PUSH
 211: LD_INT 6
 213: PUSH
 214: EMPTY
 215: LIST
 216: LIST
 217: LIST
 218: PUSH
 219: LD_OWVAR 67
 223: ARRAY
 224: PPUSH
 225: LD_INT 39
 227: PPUSH
 228: CALL 75633 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 232: LD_ADDR_EXP 67
 236: PUSH
 237: LD_INT 20
 239: PUSH
 240: LD_INT 21
 242: PUSH
 243: LD_INT 22
 245: PUSH
 246: LD_INT 24
 248: PUSH
 249: LD_INT 20
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: LIST
 258: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 259: LD_ADDR_EXP 68
 263: PUSH
 264: LD_INT 35
 266: PUSH
 267: LD_INT 34
 269: PUSH
 270: LD_INT 36
 272: PUSH
 273: LD_INT 33
 275: PUSH
 276: LD_INT 38
 278: PUSH
 279: EMPTY
 280: LIST
 281: LIST
 282: LIST
 283: LIST
 284: LIST
 285: ST_TO_ADDR
// for i = 1 to 4 do
 286: LD_ADDR_VAR 0 2
 290: PUSH
 291: DOUBLE
 292: LD_INT 1
 294: DEC
 295: ST_TO_ADDR
 296: LD_INT 4
 298: PUSH
 299: FOR_TO
 300: IFFALSE 324
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 302: LD_VAR 0 2
 306: PPUSH
 307: LD_EXP 38
 311: PUSH
 312: LD_VAR 0 2
 316: ARRAY
 317: PPUSH
 318: CALL 76078 0 2
 322: GO 299
 324: POP
 325: POP
// end ;
 326: LD_VAR 0 1
 330: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 331: LD_INT 0
 333: PPUSH
// debug := 1 ;
 334: LD_ADDR_EXP 1
 338: PUSH
 339: LD_INT 1
 341: ST_TO_ADDR
// side_bot := 2 ;
 342: LD_ADDR_EXP 3
 346: PUSH
 347: LD_INT 2
 349: ST_TO_ADDR
// artifact_get := false ;
 350: LD_ADDR_EXP 4
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 358: LD_ADDR_EXP 5
 362: PUSH
 363: LD_STRING base_a
 365: PUSH
 366: LD_STRING base_b
 368: PUSH
 369: LD_STRING base_c
 371: PUSH
 372: LD_STRING base_d
 374: PUSH
 375: LD_STRING base_e
 377: PUSH
 378: LD_STRING base_f
 380: PUSH
 381: LD_STRING base_g
 383: PUSH
 384: LD_STRING base_h
 386: PUSH
 387: LD_STRING base_i
 389: PUSH
 390: LD_STRING base_j
 392: PUSH
 393: LD_STRING base_k
 395: PUSH
 396: LD_STRING base_l
 398: PUSH
 399: LD_STRING base_m
 401: PUSH
 402: LD_STRING base_n
 404: PUSH
 405: LD_STRING base_o
 407: PUSH
 408: LD_STRING base_p
 410: PUSH
 411: LD_STRING base_r
 413: PUSH
 414: LD_STRING base_s
 416: PUSH
 417: LD_STRING base_t
 419: PUSH
 420: LD_STRING base_u
 422: PUSH
 423: LD_STRING base_w
 425: PUSH
 426: LD_STRING base_x
 428: PUSH
 429: LD_STRING base_y
 431: PUSH
 432: LD_STRING base_z
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: ST_TO_ADDR
// end ;
 461: LD_VAR 0 1
 465: RET
// every 0 0$01 trigger game and not debug_strings do
 466: LD_EXP 2
 470: PUSH
 471: LD_OWVAR 48
 475: NOT
 476: AND
 477: IFFALSE 493
 479: GO 481
 481: DISABLE
// begin enable ;
 482: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 483: LD_ADDR_OWVAR 47
 487: PUSH
 488: CALL 4547 0 0
 492: ST_TO_ADDR
// end ;
 493: END
// function Debuger ; var i ; begin
 494: LD_INT 0
 496: PPUSH
 497: PPUSH
// if not debug then
 498: LD_EXP 1
 502: NOT
 503: IFFALSE 507
// exit ;
 505: GO 579
// game_speed := 5 ;
 507: LD_ADDR_OWVAR 65
 511: PUSH
 512: LD_INT 5
 514: ST_TO_ADDR
// uc_side := 1 ;
 515: LD_ADDR_OWVAR 20
 519: PUSH
 520: LD_INT 1
 522: ST_TO_ADDR
// uc_nation := 1 ;
 523: LD_ADDR_OWVAR 21
 527: PUSH
 528: LD_INT 1
 530: ST_TO_ADDR
// for i = 1 to 10 do
 531: LD_ADDR_VAR 0 2
 535: PUSH
 536: DOUBLE
 537: LD_INT 1
 539: DEC
 540: ST_TO_ADDR
 541: LD_INT 10
 543: PUSH
 544: FOR_TO
 545: IFFALSE 577
// begin PrepareHuman ( false , 1 , 10 ) ;
 547: LD_INT 0
 549: PPUSH
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 10
 555: PPUSH
 556: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 560: CALL_OW 44
 564: PPUSH
 565: LD_INT 9
 567: PPUSH
 568: LD_INT 0
 570: PPUSH
 571: CALL_OW 49
// end ;
 575: GO 544
 577: POP
 578: POP
// end ;
 579: LD_VAR 0 1
 583: RET
// export function CustomEvent ( event ) ; begin
 584: LD_INT 0
 586: PPUSH
// end ; end_of_file
 587: LD_VAR 0 2
 591: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 592: LD_INT 0
 594: PPUSH
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
// multi_settings_counter := 6 ;
 599: LD_ADDR_EXP 18
 603: PUSH
 604: LD_INT 6
 606: ST_TO_ADDR
// if multiplayer then
 607: LD_OWVAR 4
 611: IFFALSE 791
// begin your_side := mp_player_side ;
 613: LD_ADDR_OWVAR 2
 617: PUSH
 618: LD_OWVAR 7
 622: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 623: LD_ADDR_EXP 6
 627: PUSH
 628: LD_OWVAR 6
 632: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 633: LD_ADDR_EXP 7
 637: PUSH
 638: LD_OWVAR 17
 642: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 643: LD_ADDR_EXP 8
 647: PUSH
 648: LD_OWVAR 15
 652: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 653: LD_ADDR_EXP 9
 657: PUSH
 658: LD_OWVAR 16
 662: ST_TO_ADDR
// multi_teams := [ [ ] ] ;
 663: LD_ADDR_EXP 10
 667: PUSH
 668: EMPTY
 669: PUSH
 670: EMPTY
 671: LIST
 672: ST_TO_ADDR
// for i in mp_teams do
 673: LD_ADDR_VAR 0 2
 677: PUSH
 678: LD_OWVAR 12
 682: PUSH
 683: FOR_IN
 684: IFFALSE 727
// if i then
 686: LD_VAR 0 2
 690: IFFALSE 725
// multi_teams := Replace ( multi_teams , 1 , multi_teams [ 1 ] union i ) ;
 692: LD_ADDR_EXP 10
 696: PUSH
 697: LD_EXP 10
 701: PPUSH
 702: LD_INT 1
 704: PPUSH
 705: LD_EXP 10
 709: PUSH
 710: LD_INT 1
 712: ARRAY
 713: PUSH
 714: LD_VAR 0 2
 718: UNION
 719: PPUSH
 720: CALL_OW 1
 724: ST_TO_ADDR
 725: GO 683
 727: POP
 728: POP
// for i = 1 to multi_settings_counter do
 729: LD_ADDR_VAR 0 2
 733: PUSH
 734: DOUBLE
 735: LD_INT 1
 737: DEC
 738: ST_TO_ADDR
 739: LD_EXP 18
 743: PUSH
 744: FOR_TO
 745: IFFALSE 787
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 747: LD_ADDR_EXP 17
 751: PUSH
 752: LD_EXP 17
 756: PPUSH
 757: LD_EXP 17
 761: PUSH
 762: LD_INT 1
 764: PLUS
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: CALL_OW 426
 775: PUSH
 776: LD_INT 1
 778: PLUS
 779: PPUSH
 780: CALL_OW 2
 784: ST_TO_ADDR
 785: GO 744
 787: POP
 788: POP
// end else
 789: GO 973
// begin your_side := 1 ;
 791: LD_ADDR_OWVAR 2
 795: PUSH
 796: LD_INT 1
 798: ST_TO_ADDR
// multi_gametype := 1 ;
 799: LD_ADDR_EXP 6
 803: PUSH
 804: LD_INT 1
 806: ST_TO_ADDR
// multi_sides := [ 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 807: LD_ADDR_EXP 7
 811: PUSH
 812: LD_INT 2
 814: PUSH
 815: LD_INT 1
 817: PUSH
 818: LD_INT 0
 820: PUSH
 821: LD_INT 0
 823: PUSH
 824: LD_INT 0
 826: PUSH
 827: LD_INT 0
 829: PUSH
 830: LD_INT 0
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: ST_TO_ADDR
// multi_side_teams := [ 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 846: LD_ADDR_EXP 8
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 0
 859: PUSH
 860: LD_INT 0
 862: PUSH
 863: LD_INT 0
 865: PUSH
 866: LD_INT 0
 868: PUSH
 869: LD_INT 0
 871: PUSH
 872: LD_INT 0
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: ST_TO_ADDR
// multi_nations := [ 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 885: LD_ADDR_EXP 9
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 1
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: LD_INT 0
 907: PUSH
 908: LD_INT 0
 910: PUSH
 911: LD_INT 0
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: LIST
 922: LIST
 923: ST_TO_ADDR
// multi_teams := [ [ 1 , 2 ] ] ;
 924: LD_ADDR_EXP 10
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 2
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: PUSH
 939: EMPTY
 940: LIST
 941: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 942: LD_ADDR_EXP 17
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 2
 952: PUSH
 953: LD_INT 1
 955: PUSH
 956: LD_INT 3
 958: PUSH
 959: LD_INT 1
 961: PUSH
 962: LD_INT 1
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 973: LD_ADDR_EXP 11
 977: PUSH
 978: LD_INT 0
 980: PUSH
 981: LD_INT 0
 983: PUSH
 984: LD_INT 0
 986: PUSH
 987: LD_INT 0
 989: PUSH
 990: LD_INT 0
 992: PUSH
 993: LD_INT 0
 995: PUSH
 996: LD_INT 0
 998: PUSH
 999: LD_INT 0
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1012: LD_ADDR_EXP 14
1016: PUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 0
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: LD_INT 0
1031: PUSH
1032: LD_INT 0
1034: PUSH
1035: LD_INT 0
1037: PUSH
1038: LD_INT 0
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1051: LD_ADDR_EXP 25
1055: PUSH
1056: LD_INT 0
1058: PUSH
1059: LD_INT 0
1061: PUSH
1062: LD_INT 0
1064: PUSH
1065: LD_INT 0
1067: PUSH
1068: LD_INT 0
1070: PUSH
1071: LD_INT 0
1073: PUSH
1074: LD_INT 0
1076: PUSH
1077: LD_INT 0
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: ST_TO_ADDR
// multi_teamgame := true ;
1090: LD_ADDR_EXP 15
1094: PUSH
1095: LD_INT 1
1097: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1098: LD_ADDR_EXP 13
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: EMPTY
1107: LIST
1108: ST_TO_ADDR
// multi_custom_commanders := true ;
1109: LD_ADDR_EXP 16
1113: PUSH
1114: LD_INT 1
1116: ST_TO_ADDR
// multi_commanders := [ ] ;
1117: LD_ADDR_EXP 24
1121: PUSH
1122: EMPTY
1123: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1124: LD_ADDR_EXP 27
1128: PUSH
1129: EMPTY
1130: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1131: LD_ADDR_EXP 28
1135: PUSH
1136: LD_INT 0
1138: ST_TO_ADDR
// multi_players_amount := 0 ;
1139: LD_ADDR_EXP 26
1143: PUSH
1144: LD_INT 0
1146: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1147: LD_ADDR_EXP 12
1151: PUSH
1152: LD_INT 9
1154: PUSH
1155: LD_INT 8
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 26
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PUSH
1172: LD_INT 29
1174: PUSH
1175: LD_INT 28
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: LIST
1186: ST_TO_ADDR
// for i = 1 to 8 do
1187: LD_ADDR_VAR 0 2
1191: PUSH
1192: DOUBLE
1193: LD_INT 1
1195: DEC
1196: ST_TO_ADDR
1197: LD_INT 8
1199: PUSH
1200: FOR_TO
1201: IFFALSE 1530
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1203: LD_VAR 0 2
1207: PPUSH
1208: CALL_OW 530
1212: IFFALSE 1370
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1214: LD_ADDR_EXP 11
1218: PUSH
1219: LD_EXP 11
1223: PPUSH
1224: LD_VAR 0 2
1228: PPUSH
1229: LD_INT 1
1231: PPUSH
1232: CALL_OW 1
1236: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1237: LD_ADDR_EXP 9
1241: PUSH
1242: LD_EXP 9
1246: PPUSH
1247: LD_VAR 0 2
1251: PPUSH
1252: LD_INT 0
1254: PPUSH
1255: CALL_OW 1
1259: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1260: LD_ADDR_EXP 7
1264: PUSH
1265: LD_EXP 7
1269: PPUSH
1270: LD_VAR 0 2
1274: PPUSH
1275: LD_INT 0
1277: PPUSH
1278: CALL_OW 1
1282: ST_TO_ADDR
// for j = 1 to multi_teams do
1283: LD_ADDR_VAR 0 3
1287: PUSH
1288: DOUBLE
1289: LD_INT 1
1291: DEC
1292: ST_TO_ADDR
1293: LD_EXP 10
1297: PUSH
1298: FOR_TO
1299: IFFALSE 1368
// begin if i in multi_teams [ j ] then
1301: LD_VAR 0 2
1305: PUSH
1306: LD_EXP 10
1310: PUSH
1311: LD_VAR 0 3
1315: ARRAY
1316: IN
1317: IFFALSE 1366
// begin tmp := multi_teams [ j ] diff i ;
1319: LD_ADDR_VAR 0 5
1323: PUSH
1324: LD_EXP 10
1328: PUSH
1329: LD_VAR 0 3
1333: ARRAY
1334: PUSH
1335: LD_VAR 0 2
1339: DIFF
1340: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1341: LD_ADDR_EXP 10
1345: PUSH
1346: LD_EXP 10
1350: PPUSH
1351: LD_VAR 0 3
1355: PPUSH
1356: LD_VAR 0 5
1360: PPUSH
1361: CALL_OW 1
1365: ST_TO_ADDR
// end ; end ;
1366: GO 1298
1368: POP
1369: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1370: LD_EXP 9
1374: PUSH
1375: LD_VAR 0 2
1379: ARRAY
1380: PUSH
1381: LD_EXP 9
1385: PUSH
1386: LD_VAR 0 2
1390: ARRAY
1391: PUSH
1392: LD_EXP 13
1396: IN
1397: NOT
1398: AND
1399: IFFALSE 1440
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1401: LD_ADDR_EXP 9
1405: PUSH
1406: LD_EXP 9
1410: PPUSH
1411: LD_VAR 0 2
1415: PPUSH
1416: LD_EXP 13
1420: PUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_EXP 13
1428: PPUSH
1429: CALL_OW 12
1433: ARRAY
1434: PPUSH
1435: CALL_OW 1
1439: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1440: LD_EXP 9
1444: PUSH
1445: LD_VAR 0 2
1449: ARRAY
1450: NOT
1451: PUSH
1452: LD_EXP 7
1456: PUSH
1457: LD_VAR 0 2
1461: ARRAY
1462: NOT
1463: AND
1464: PUSH
1465: LD_EXP 11
1469: PUSH
1470: LD_VAR 0 2
1474: ARRAY
1475: NOT
1476: AND
1477: IFFALSE 1502
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1479: LD_ADDR_EXP 14
1483: PUSH
1484: LD_EXP 14
1488: PPUSH
1489: LD_VAR 0 2
1493: PPUSH
1494: LD_INT 1
1496: PPUSH
1497: CALL_OW 1
1501: ST_TO_ADDR
// if multi_sides [ i ] then
1502: LD_EXP 7
1506: PUSH
1507: LD_VAR 0 2
1511: ARRAY
1512: IFFALSE 1528
// multi_players_amount := multi_players_amount + 1 ;
1514: LD_ADDR_EXP 26
1518: PUSH
1519: LD_EXP 26
1523: PUSH
1524: LD_INT 1
1526: PLUS
1527: ST_TO_ADDR
// end ;
1528: GO 1200
1530: POP
1531: POP
// for i in multi_teams do
1532: LD_ADDR_VAR 0 2
1536: PUSH
1537: LD_EXP 10
1541: PUSH
1542: FOR_IN
1543: IFFALSE 1651
// begin for j = 2 to i do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: DOUBLE
1551: LD_INT 2
1553: DEC
1554: ST_TO_ADDR
1555: LD_VAR 0 2
1559: PUSH
1560: FOR_TO
1561: IFFALSE 1647
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1563: LD_VAR 0 2
1567: PUSH
1568: LD_VAR 0 3
1572: ARRAY
1573: PPUSH
1574: LD_VAR 0 2
1578: PUSH
1579: LD_INT 1
1581: ARRAY
1582: PPUSH
1583: CALL_OW 343
// for x = 1 to j - 1 do
1587: LD_ADDR_VAR 0 4
1591: PUSH
1592: DOUBLE
1593: LD_INT 1
1595: DEC
1596: ST_TO_ADDR
1597: LD_VAR 0 3
1601: PUSH
1602: LD_INT 1
1604: MINUS
1605: PUSH
1606: FOR_TO
1607: IFFALSE 1643
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1609: LD_VAR 0 2
1613: PUSH
1614: LD_VAR 0 3
1618: ARRAY
1619: PPUSH
1620: LD_VAR 0 2
1624: PUSH
1625: LD_VAR 0 4
1629: ARRAY
1630: PPUSH
1631: LD_INT 1
1633: PPUSH
1634: LD_INT 1
1636: PPUSH
1637: CALL_OW 80
1641: GO 1606
1643: POP
1644: POP
// end ;
1645: GO 1560
1647: POP
1648: POP
// end ;
1649: GO 1542
1651: POP
1652: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1653: LD_ADDR_OWVAR 67
1657: PUSH
1658: LD_INT 1
1660: PUSH
1661: LD_INT 2
1663: PUSH
1664: LD_INT 3
1666: PUSH
1667: EMPTY
1668: LIST
1669: LIST
1670: LIST
1671: PUSH
1672: LD_EXP 17
1676: PUSH
1677: LD_INT 1
1679: ARRAY
1680: ARRAY
1681: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1682: LD_ADDR_EXP 19
1686: PUSH
1687: LD_INT 9
1689: PUSH
1690: LD_INT 12
1692: PUSH
1693: LD_INT 15
1695: PUSH
1696: LD_INT 18
1698: PUSH
1699: EMPTY
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: PUSH
1705: LD_EXP 17
1709: PUSH
1710: LD_INT 2
1712: ARRAY
1713: ARRAY
1714: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1715: LD_ADDR_EXP 20
1719: PUSH
1720: LD_INT 5
1722: PUSH
1723: LD_INT 7
1725: PUSH
1726: LD_INT 9
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: PUSH
1734: LD_EXP 17
1738: PUSH
1739: LD_INT 3
1741: ARRAY
1742: ARRAY
1743: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1744: LD_ADDR_EXP 21
1748: PUSH
1749: LD_INT 6000
1751: PUSH
1752: LD_INT 1575
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: PUSH
1759: LD_INT 8000
1761: PUSH
1762: LD_INT 1260
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: PUSH
1769: LD_INT 10000
1771: PUSH
1772: LD_INT 770
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PUSH
1779: LD_INT 15000
1781: PUSH
1782: LD_INT 770
1784: PUSH
1785: EMPTY
1786: LIST
1787: LIST
1788: PUSH
1789: EMPTY
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: PUSH
1795: LD_EXP 17
1799: PUSH
1800: LD_INT 4
1802: ARRAY
1803: ARRAY
1804: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1805: LD_ADDR_EXP 22
1809: PUSH
1810: LD_INT 6
1812: PUSH
1813: LD_INT 8
1815: PUSH
1816: LD_INT 10
1818: PUSH
1819: EMPTY
1820: LIST
1821: LIST
1822: LIST
1823: PUSH
1824: LD_EXP 17
1828: PUSH
1829: LD_INT 5
1831: ARRAY
1832: ARRAY
1833: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1834: LD_ADDR_EXP 23
1838: PUSH
1839: LD_INT 0
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: LIST
1852: PUSH
1853: LD_EXP 17
1857: PUSH
1858: LD_INT 6
1860: ARRAY
1861: ARRAY
1862: ST_TO_ADDR
// end ;
1863: LD_VAR 0 1
1867: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1868: LD_INT 0
1870: PPUSH
1871: PPUSH
// if not multi_sides [ 2 ] then
1872: LD_EXP 7
1876: PUSH
1877: LD_INT 2
1879: ARRAY
1880: NOT
1881: IFFALSE 1895
// begin result := preferSide ;
1883: LD_ADDR_VAR 0 2
1887: PUSH
1888: LD_VAR 0 1
1892: ST_TO_ADDR
// exit ;
1893: GO 1942
// end ; for i := 1 to 8 do
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_INT 8
1907: PUSH
1908: FOR_TO
1909: IFFALSE 1940
// if not multi_sides [ i ] then
1911: LD_EXP 7
1915: PUSH
1916: LD_VAR 0 3
1920: ARRAY
1921: NOT
1922: IFFALSE 1938
// begin result := i ;
1924: LD_ADDR_VAR 0 2
1928: PUSH
1929: LD_VAR 0 3
1933: ST_TO_ADDR
// exit ;
1934: POP
1935: POP
1936: GO 1942
// end ;
1938: GO 1908
1940: POP
1941: POP
// end ;
1942: LD_VAR 0 2
1946: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1947: LD_INT 0
1949: PPUSH
// uc_side := side ;
1950: LD_ADDR_OWVAR 20
1954: PUSH
1955: LD_VAR 0 1
1959: ST_TO_ADDR
// uc_nation := 1 ;
1960: LD_ADDR_OWVAR 21
1964: PUSH
1965: LD_INT 1
1967: ST_TO_ADDR
// hc_importance := 100 ;
1968: LD_ADDR_OWVAR 32
1972: PUSH
1973: LD_INT 100
1975: ST_TO_ADDR
// hc_class := 1 ;
1976: LD_ADDR_OWVAR 28
1980: PUSH
1981: LD_INT 1
1983: ST_TO_ADDR
// if num = 1 then
1984: LD_VAR 0 2
1988: PUSH
1989: LD_INT 1
1991: EQUAL
1992: IFFALSE 2074
// begin hc_gallery := us ;
1994: LD_ADDR_OWVAR 33
1998: PUSH
1999: LD_STRING us
2001: ST_TO_ADDR
// hc_face_number := 5 ;
2002: LD_ADDR_OWVAR 34
2006: PUSH
2007: LD_INT 5
2009: ST_TO_ADDR
// hc_name := John Macmilan ;
2010: LD_ADDR_OWVAR 26
2014: PUSH
2015: LD_STRING John Macmilan
2017: ST_TO_ADDR
// hc_sex := sex_male ;
2018: LD_ADDR_OWVAR 27
2022: PUSH
2023: LD_INT 1
2025: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2026: LD_ADDR_OWVAR 31
2030: PUSH
2031: LD_INT 7
2033: PUSH
2034: LD_INT 2
2036: PUSH
2037: LD_INT 4
2039: PUSH
2040: LD_INT 4
2042: PUSH
2043: EMPTY
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2049: LD_ADDR_OWVAR 29
2053: PUSH
2054: LD_INT 11
2056: PUSH
2057: LD_INT 10
2059: PUSH
2060: EMPTY
2061: LIST
2062: LIST
2063: ST_TO_ADDR
// result := CreateHuman ;
2064: LD_ADDR_VAR 0 3
2068: PUSH
2069: CALL_OW 44
2073: ST_TO_ADDR
// end ; if num = 2 then
2074: LD_VAR 0 2
2078: PUSH
2079: LD_INT 2
2081: EQUAL
2082: IFFALSE 2164
// begin hc_gallery := us ;
2084: LD_ADDR_OWVAR 33
2088: PUSH
2089: LD_STRING us
2091: ST_TO_ADDR
// hc_face_number := 2 ;
2092: LD_ADDR_OWVAR 34
2096: PUSH
2097: LD_INT 2
2099: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2100: LD_ADDR_OWVAR 26
2104: PUSH
2105: LD_STRING Lucy Donaldson
2107: ST_TO_ADDR
// hc_sex := sex_female ;
2108: LD_ADDR_OWVAR 27
2112: PUSH
2113: LD_INT 2
2115: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2116: LD_ADDR_OWVAR 31
2120: PUSH
2121: LD_INT 6
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: LD_INT 4
2129: PUSH
2130: LD_INT 3
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2139: LD_ADDR_OWVAR 29
2143: PUSH
2144: LD_INT 9
2146: PUSH
2147: LD_INT 12
2149: PUSH
2150: EMPTY
2151: LIST
2152: LIST
2153: ST_TO_ADDR
// result := CreateHuman ;
2154: LD_ADDR_VAR 0 3
2158: PUSH
2159: CALL_OW 44
2163: ST_TO_ADDR
// end ; if num = 3 then
2164: LD_VAR 0 2
2168: PUSH
2169: LD_INT 3
2171: EQUAL
2172: IFFALSE 2254
// begin hc_gallery := us ;
2174: LD_ADDR_OWVAR 33
2178: PUSH
2179: LD_STRING us
2181: ST_TO_ADDR
// hc_face_number := 7 ;
2182: LD_ADDR_OWVAR 34
2186: PUSH
2187: LD_INT 7
2189: ST_TO_ADDR
// hc_name := Arthur Powell ;
2190: LD_ADDR_OWVAR 26
2194: PUSH
2195: LD_STRING Arthur Powell
2197: ST_TO_ADDR
// hc_sex := sex_male ;
2198: LD_ADDR_OWVAR 27
2202: PUSH
2203: LD_INT 1
2205: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2206: LD_ADDR_OWVAR 31
2210: PUSH
2211: LD_INT 8
2213: PUSH
2214: LD_INT 2
2216: PUSH
2217: LD_INT 5
2219: PUSH
2220: LD_INT 2
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: LIST
2227: LIST
2228: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2229: LD_ADDR_OWVAR 29
2233: PUSH
2234: LD_INT 10
2236: PUSH
2237: LD_INT 11
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: ST_TO_ADDR
// result := CreateHuman ;
2244: LD_ADDR_VAR 0 3
2248: PUSH
2249: CALL_OW 44
2253: ST_TO_ADDR
// end ; end ;
2254: LD_VAR 0 3
2258: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2259: LD_INT 0
2261: PPUSH
2262: PPUSH
2263: PPUSH
2264: PPUSH
2265: PPUSH
2266: PPUSH
2267: PPUSH
2268: PPUSH
2269: PPUSH
// for i = 1 to 8 do
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: DOUBLE
2276: LD_INT 1
2278: DEC
2279: ST_TO_ADDR
2280: LD_INT 8
2282: PUSH
2283: FOR_TO
2284: IFFALSE 3174
// begin if not multi_sides [ i ] then
2286: LD_EXP 7
2290: PUSH
2291: LD_VAR 0 2
2295: ARRAY
2296: NOT
2297: IFFALSE 2301
// continue ;
2299: GO 2283
// if multi_custom_commanders then
2301: LD_EXP 16
2305: IFFALSE 2397
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 2
2316: PPUSH
2317: LD_EXP 7
2321: PUSH
2322: LD_VAR 0 2
2326: ARRAY
2327: PPUSH
2328: CALL 1947 0 2
2332: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2333: LD_ADDR_EXP 24
2337: PUSH
2338: LD_EXP 24
2342: PPUSH
2343: LD_EXP 24
2347: PUSH
2348: LD_INT 1
2350: PLUS
2351: PPUSH
2352: LD_VAR 0 5
2356: PPUSH
2357: CALL_OW 2
2361: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2362: LD_VAR 0 5
2366: PPUSH
2367: LD_EXP 12
2371: PUSH
2372: LD_EXP 7
2376: PUSH
2377: LD_VAR 0 2
2381: ARRAY
2382: ARRAY
2383: PUSH
2384: LD_INT 1
2386: ARRAY
2387: PPUSH
2388: LD_INT 0
2390: PPUSH
2391: CALL_OW 49
// end else
2395: GO 2608
// begin uc_side := i ;
2397: LD_ADDR_OWVAR 20
2401: PUSH
2402: LD_VAR 0 2
2406: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2407: LD_ADDR_OWVAR 21
2411: PUSH
2412: LD_EXP 9
2416: PUSH
2417: LD_VAR 0 2
2421: ARRAY
2422: ST_TO_ADDR
// hc_importance := 100 ;
2423: LD_ADDR_OWVAR 32
2427: PUSH
2428: LD_INT 100
2430: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2431: LD_INT 0
2433: PPUSH
2434: LD_INT 1
2436: PPUSH
2437: LD_EXP 20
2441: PPUSH
2442: CALL_OW 380
// if multiplayer then
2446: LD_OWVAR 4
2450: IFFALSE 2508
// begin hc_name := mp_sides_players_names [ i ] ;
2452: LD_ADDR_OWVAR 26
2456: PUSH
2457: LD_OWVAR 19
2461: PUSH
2462: LD_VAR 0 2
2466: ARRAY
2467: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2468: LD_ADDR_OWVAR 33
2472: PUSH
2473: LD_STRING MULTIAVATARS
2475: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2476: LD_ADDR_OWVAR 34
2480: PUSH
2481: LD_VAR 0 2
2485: PPUSH
2486: CALL_OW 525
2490: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2491: LD_ADDR_OWVAR 27
2495: PUSH
2496: LD_VAR 0 2
2500: PPUSH
2501: CALL_OW 526
2505: ST_TO_ADDR
// end else
2506: GO 2540
// begin hc_gallery :=  ;
2508: LD_ADDR_OWVAR 33
2512: PUSH
2513: LD_STRING 
2515: ST_TO_ADDR
// hc_name :=  ;
2516: LD_ADDR_OWVAR 26
2520: PUSH
2521: LD_STRING 
2523: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2524: LD_ADDR_OWVAR 27
2528: PUSH
2529: LD_INT 1
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 12
2539: ST_TO_ADDR
// end ; un := CreateHuman ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: CALL_OW 44
2549: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2550: LD_VAR 0 5
2554: PPUSH
2555: LD_EXP 12
2559: PUSH
2560: LD_EXP 7
2564: PUSH
2565: LD_VAR 0 2
2569: ARRAY
2570: ARRAY
2571: PUSH
2572: LD_INT 1
2574: ARRAY
2575: PPUSH
2576: LD_INT 0
2578: PPUSH
2579: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2583: LD_ADDR_EXP 24
2587: PUSH
2588: LD_EXP 24
2592: PPUSH
2593: LD_VAR 0 2
2597: PPUSH
2598: LD_VAR 0 5
2602: PPUSH
2603: CALL_OW 1
2607: ST_TO_ADDR
// end ; InitHc ;
2608: CALL_OW 19
// InitUc ;
2612: CALL_OW 18
// uc_side := i ;
2616: LD_ADDR_OWVAR 20
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_EXP 9
2635: PUSH
2636: LD_VAR 0 2
2640: ARRAY
2641: ST_TO_ADDR
// hc_gallery :=  ;
2642: LD_ADDR_OWVAR 33
2646: PUSH
2647: LD_STRING 
2649: ST_TO_ADDR
// hc_name :=  ;
2650: LD_ADDR_OWVAR 26
2654: PUSH
2655: LD_STRING 
2657: ST_TO_ADDR
// hc_importance := 0 ;
2658: LD_ADDR_OWVAR 32
2662: PUSH
2663: LD_INT 0
2665: ST_TO_ADDR
// cl := 1 ;
2666: LD_ADDR_VAR 0 4
2670: PUSH
2671: LD_INT 1
2673: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2674: LD_ADDR_VAR 0 3
2678: PUSH
2679: DOUBLE
2680: LD_INT 2
2682: DEC
2683: ST_TO_ADDR
2684: LD_EXP 19
2688: PUSH
2689: FOR_TO
2690: IFFALSE 3062
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2692: LD_VAR 0 3
2696: PUSH
2697: LD_INT 1
2699: MINUS
2700: PUSH
2701: LD_EXP 19
2705: PUSH
2706: LD_INT 1
2708: MINUS
2709: PUSH
2710: LD_INT 4
2712: DIVREAL
2713: MOD
2714: PUSH
2715: LD_INT 0
2717: EQUAL
2718: IFFALSE 2734
// cl := cl + 1 ;
2720: LD_ADDR_VAR 0 4
2724: PUSH
2725: LD_VAR 0 4
2729: PUSH
2730: LD_INT 1
2732: PLUS
2733: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2734: LD_INT 0
2736: PPUSH
2737: LD_VAR 0 4
2741: PPUSH
2742: LD_EXP 20
2746: PPUSH
2747: CALL_OW 380
// un := CreateHuman ;
2751: LD_ADDR_VAR 0 5
2755: PUSH
2756: CALL_OW 44
2760: ST_TO_ADDR
// if j > copy then
2761: LD_VAR 0 3
2765: PUSH
2766: LD_VAR 0 8
2770: GREATER
2771: IFFALSE 2800
// copy := Replace ( copy , j , un ) else
2773: LD_ADDR_VAR 0 8
2777: PUSH
2778: LD_VAR 0 8
2782: PPUSH
2783: LD_VAR 0 3
2787: PPUSH
2788: LD_VAR 0 5
2792: PPUSH
2793: CALL_OW 1
2797: ST_TO_ADDR
2798: GO 2882
// begin CopySkills ( copy [ j ] , un ) ;
2800: LD_VAR 0 8
2804: PUSH
2805: LD_VAR 0 3
2809: ARRAY
2810: PPUSH
2811: LD_VAR 0 5
2815: PPUSH
2816: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2820: LD_VAR 0 5
2824: PPUSH
2825: LD_INT 2
2827: PPUSH
2828: LD_VAR 0 8
2832: PUSH
2833: LD_VAR 0 3
2837: ARRAY
2838: PPUSH
2839: LD_INT 2
2841: PPUSH
2842: CALL_OW 260
2846: PPUSH
2847: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2851: LD_VAR 0 5
2855: PPUSH
2856: LD_INT 1
2858: PPUSH
2859: LD_VAR 0 8
2863: PUSH
2864: LD_VAR 0 3
2868: ARRAY
2869: PPUSH
2870: LD_INT 1
2872: PPUSH
2873: CALL_OW 260
2877: PPUSH
2878: CALL_OW 239
// end ; if multi_pos_area then
2882: LD_EXP 12
2886: IFFALSE 3060
// begin if GetClass ( un ) = 3 then
2888: LD_VAR 0 5
2892: PPUSH
2893: CALL_OW 257
2897: PUSH
2898: LD_INT 3
2900: EQUAL
2901: IFFALSE 3027
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2903: LD_INT 3
2905: PUSH
2906: LD_INT 2
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: PUSH
2913: LD_VAR 0 3
2917: PUSH
2918: LD_INT 2
2920: MOD
2921: PUSH
2922: LD_INT 1
2924: PLUS
2925: ARRAY
2926: PPUSH
2927: LD_INT 2
2929: PPUSH
2930: LD_INT 1
2932: PPUSH
2933: LD_INT 5
2935: PUSH
2936: LD_INT 4
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: LD_VAR 0 3
2951: PUSH
2952: LD_INT 3
2954: MOD
2955: PUSH
2956: LD_INT 1
2958: PLUS
2959: ARRAY
2960: PPUSH
2961: LD_INT 100
2963: PPUSH
2964: CALL 14652 0 5
// veh := CreateVehicle ;
2968: LD_ADDR_VAR 0 6
2972: PUSH
2973: CALL_OW 45
2977: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
2978: LD_VAR 0 6
2982: PPUSH
2983: LD_EXP 12
2987: PUSH
2988: LD_EXP 7
2992: PUSH
2993: LD_VAR 0 2
2997: ARRAY
2998: ARRAY
2999: PUSH
3000: LD_INT 2
3002: ARRAY
3003: PPUSH
3004: LD_INT 0
3006: PPUSH
3007: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3011: LD_VAR 0 5
3015: PPUSH
3016: LD_VAR 0 6
3020: PPUSH
3021: CALL_OW 52
// continue ;
3025: GO 2689
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3027: LD_VAR 0 5
3031: PPUSH
3032: LD_EXP 12
3036: PUSH
3037: LD_EXP 7
3041: PUSH
3042: LD_VAR 0 2
3046: ARRAY
3047: ARRAY
3048: PUSH
3049: LD_INT 1
3051: ARRAY
3052: PPUSH
3053: LD_INT 0
3055: PPUSH
3056: CALL_OW 49
// end ; end ;
3060: GO 2689
3062: POP
3063: POP
// for j = 1 to 3 do
3064: LD_ADDR_VAR 0 3
3068: PUSH
3069: DOUBLE
3070: LD_INT 1
3072: DEC
3073: ST_TO_ADDR
3074: LD_INT 3
3076: PUSH
3077: FOR_TO
3078: IFFALSE 3170
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3080: LD_INT 2
3082: PUSH
3083: LD_INT 3
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: PUSH
3090: LD_INT 1
3092: PPUSH
3093: LD_INT 2
3095: PPUSH
3096: CALL_OW 12
3100: ARRAY
3101: PPUSH
3102: LD_INT 2
3104: PPUSH
3105: LD_INT 3
3107: PPUSH
3108: LD_INT 11
3110: PUSH
3111: LD_INT 7
3113: PUSH
3114: LD_INT 4
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: PUSH
3122: LD_VAR 0 3
3126: ARRAY
3127: PPUSH
3128: LD_INT 100
3130: PPUSH
3131: CALL 14652 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3135: CALL_OW 45
3139: PPUSH
3140: LD_EXP 12
3144: PUSH
3145: LD_EXP 7
3149: PUSH
3150: LD_VAR 0 2
3154: ARRAY
3155: ARRAY
3156: PUSH
3157: LD_INT 1
3159: ARRAY
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 49
// end ;
3168: GO 3077
3170: POP
3171: POP
// end ;
3172: GO 2283
3174: POP
3175: POP
// end ;
3176: LD_VAR 0 1
3180: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3181: LD_INT 0
3183: PPUSH
3184: PPUSH
3185: PPUSH
3186: PPUSH
3187: PPUSH
// if not multi_support then
3188: LD_EXP 23
3192: NOT
3193: IFFALSE 3197
// exit ;
3195: GO 3725
// result := [ ] ;
3197: LD_ADDR_VAR 0 1
3201: PUSH
3202: EMPTY
3203: ST_TO_ADDR
// for i = 1 to 8 do
3204: LD_ADDR_VAR 0 2
3208: PUSH
3209: DOUBLE
3210: LD_INT 1
3212: DEC
3213: ST_TO_ADDR
3214: LD_INT 8
3216: PUSH
3217: FOR_TO
3218: IFFALSE 3723
// begin if multi_sides [ i ] then
3220: LD_EXP 7
3224: PUSH
3225: LD_VAR 0 2
3229: ARRAY
3230: IFFALSE 3721
// begin tmp := [ ] ;
3232: LD_ADDR_VAR 0 5
3236: PUSH
3237: EMPTY
3238: ST_TO_ADDR
// if multi_support = 1 then
3239: LD_EXP 23
3243: PUSH
3244: LD_INT 1
3246: EQUAL
3247: IFFALSE 3415
// begin uc_side := i ;
3249: LD_ADDR_OWVAR 20
3253: PUSH
3254: LD_VAR 0 2
3258: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3259: LD_ADDR_OWVAR 21
3263: PUSH
3264: LD_EXP 9
3268: PUSH
3269: LD_VAR 0 2
3273: ARRAY
3274: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3275: LD_INT 3
3277: PPUSH
3278: LD_INT 1
3280: PPUSH
3281: LD_INT 3
3283: PPUSH
3284: LD_INT 11
3286: PPUSH
3287: LD_INT 40
3289: PPUSH
3290: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3294: LD_ADDR_VAR 0 5
3298: PUSH
3299: LD_VAR 0 5
3303: PUSH
3304: CALL_OW 45
3308: ADD
3309: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3310: LD_INT 2
3312: PPUSH
3313: LD_INT 1
3315: PPUSH
3316: LD_INT 3
3318: PPUSH
3319: LD_INT 5
3321: PPUSH
3322: LD_INT 40
3324: PPUSH
3325: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3329: LD_ADDR_VAR 0 5
3333: PUSH
3334: LD_VAR 0 5
3338: PUSH
3339: CALL_OW 45
3343: ADD
3344: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3345: LD_INT 2
3347: PPUSH
3348: LD_INT 3
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 4
3356: PPUSH
3357: LD_INT 40
3359: PPUSH
3360: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3364: LD_ADDR_VAR 0 5
3368: PUSH
3369: LD_VAR 0 5
3373: PUSH
3374: CALL_OW 45
3378: ADD
3379: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3380: LD_INT 3
3382: PPUSH
3383: LD_INT 2
3385: PPUSH
3386: LD_INT 3
3388: PPUSH
3389: LD_INT 9
3391: PPUSH
3392: LD_INT 40
3394: PPUSH
3395: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3399: LD_ADDR_VAR 0 5
3403: PUSH
3404: LD_VAR 0 5
3408: PUSH
3409: CALL_OW 45
3413: ADD
3414: ST_TO_ADDR
// end ; if multi_support = 2 then
3415: LD_EXP 23
3419: PUSH
3420: LD_INT 2
3422: EQUAL
3423: IFFALSE 3696
// begin uc_side := i ;
3425: LD_ADDR_OWVAR 20
3429: PUSH
3430: LD_VAR 0 2
3434: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3435: LD_ADDR_OWVAR 21
3439: PUSH
3440: LD_EXP 9
3444: PUSH
3445: LD_VAR 0 2
3449: ARRAY
3450: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 3
3459: PPUSH
3460: LD_INT 11
3462: PPUSH
3463: LD_INT 40
3465: PPUSH
3466: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3470: LD_ADDR_VAR 0 5
3474: PUSH
3475: LD_VAR 0 5
3479: PUSH
3480: CALL_OW 45
3484: ADD
3485: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3486: LD_INT 3
3488: PPUSH
3489: LD_INT 3
3491: PPUSH
3492: LD_INT 3
3494: PPUSH
3495: LD_INT 12
3497: PPUSH
3498: LD_INT 40
3500: PPUSH
3501: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3505: LD_ADDR_VAR 0 5
3509: PUSH
3510: LD_VAR 0 5
3514: PUSH
3515: CALL_OW 45
3519: ADD
3520: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3521: LD_INT 2
3523: PPUSH
3524: LD_INT 3
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 5
3532: PPUSH
3533: LD_INT 40
3535: PPUSH
3536: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3540: LD_ADDR_VAR 0 5
3544: PUSH
3545: LD_VAR 0 5
3549: PUSH
3550: CALL_OW 45
3554: ADD
3555: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3556: LD_INT 4
3558: PPUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_INT 3
3564: PPUSH
3565: LD_INT 6
3567: PPUSH
3568: LD_INT 40
3570: PPUSH
3571: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3575: LD_ADDR_VAR 0 5
3579: PUSH
3580: LD_VAR 0 5
3584: PUSH
3585: CALL_OW 45
3589: ADD
3590: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3591: LD_INT 2
3593: PPUSH
3594: LD_INT 3
3596: PPUSH
3597: LD_INT 3
3599: PPUSH
3600: LD_INT 9
3602: PPUSH
3603: LD_INT 40
3605: PPUSH
3606: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3610: LD_ADDR_VAR 0 5
3614: PUSH
3615: LD_VAR 0 5
3619: PUSH
3620: CALL_OW 45
3624: ADD
3625: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 3
3631: PPUSH
3632: LD_INT 3
3634: PPUSH
3635: LD_INT 9
3637: PPUSH
3638: LD_INT 40
3640: PPUSH
3641: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3645: LD_ADDR_VAR 0 5
3649: PUSH
3650: LD_VAR 0 5
3654: PUSH
3655: CALL_OW 45
3659: ADD
3660: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3661: LD_INT 4
3663: PPUSH
3664: LD_INT 1
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 6
3672: PPUSH
3673: LD_INT 40
3675: PPUSH
3676: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3680: LD_ADDR_VAR 0 5
3684: PUSH
3685: LD_VAR 0 5
3689: PUSH
3690: CALL_OW 45
3694: ADD
3695: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3696: LD_ADDR_VAR 0 1
3700: PUSH
3701: LD_VAR 0 1
3705: PPUSH
3706: LD_VAR 0 2
3710: PPUSH
3711: LD_VAR 0 5
3715: PPUSH
3716: CALL_OW 2
3720: ST_TO_ADDR
// end ; end ;
3721: GO 3217
3723: POP
3724: POP
// end ;
3725: LD_VAR 0 1
3729: RET
// export function Multiplayer_Start ( ) ; begin
3730: LD_INT 0
3732: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3733: CALL 2259 0 0
// Multiplayer_InitPointSystem ( ) ;
3737: CALL 4646 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3741: LD_INT 20
3743: PPUSH
3744: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3748: LD_INT 150
3750: PPUSH
3751: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3755: LD_INT 5
3757: PPUSH
3758: CALL 4822 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3762: LD_INT 40
3764: NEG
3765: PPUSH
3766: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3770: LD_INT 200
3772: PPUSH
3773: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3777: LD_INT 2
3779: PPUSH
3780: CALL 4822 0 1
// Multiplayer_SpawnArtifact ;
3784: CALL 5262 0 0
// if multi_support then
3788: LD_EXP 23
3792: IFFALSE 3804
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3794: LD_ADDR_EXP 27
3798: PUSH
3799: CALL 3181 0 0
3803: ST_TO_ADDR
// if multi_sides [ your_side ] then
3804: LD_EXP 7
3808: PUSH
3809: LD_OWVAR 2
3813: ARRAY
3814: IFFALSE 3841
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3816: LD_INT 22
3818: PUSH
3819: LD_OWVAR 2
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 69
3832: PUSH
3833: LD_INT 1
3835: ARRAY
3836: PPUSH
3837: CALL_OW 87
// end ;
3841: LD_VAR 0 1
3845: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3846: LD_INT 0
3848: PPUSH
3849: PPUSH
3850: PPUSH
3851: PPUSH
3852: PPUSH
// reinforcements_arrive := 0 ;
3853: LD_ADDR_VAR 0 5
3857: PUSH
3858: LD_INT 0
3860: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3861: LD_INT 35
3863: PPUSH
3864: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3868: LD_OWVAR 1
3872: PUSH
3873: LD_INT 21000
3875: GREATER
3876: PUSH
3877: LD_EXP 28
3881: NOT
3882: AND
3883: PUSH
3884: LD_EXP 23
3888: PUSH
3889: LD_INT 1
3891: EQUAL
3892: AND
3893: IFFALSE 4088
// begin multi_reinforcements_spawned := 1 ;
3895: LD_ADDR_EXP 28
3899: PUSH
3900: LD_INT 1
3902: ST_TO_ADDR
// for i = 1 to 8 do
3903: LD_ADDR_VAR 0 2
3907: PUSH
3908: DOUBLE
3909: LD_INT 1
3911: DEC
3912: ST_TO_ADDR
3913: LD_INT 8
3915: PUSH
3916: FOR_TO
3917: IFFALSE 4076
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3919: LD_EXP 7
3923: PUSH
3924: LD_VAR 0 2
3928: ARRAY
3929: PUSH
3930: LD_EXP 25
3934: PUSH
3935: LD_VAR 0 2
3939: ARRAY
3940: NOT
3941: AND
3942: PUSH
3943: LD_EXP 27
3947: PUSH
3948: LD_VAR 0 2
3952: ARRAY
3953: AND
3954: IFFALSE 4074
// begin tmp := multi_reinforcements [ i ] ;
3956: LD_ADDR_VAR 0 4
3960: PUSH
3961: LD_EXP 27
3965: PUSH
3966: LD_VAR 0 2
3970: ARRAY
3971: ST_TO_ADDR
// for j = 1 to 4 do
3972: LD_ADDR_VAR 0 3
3976: PUSH
3977: DOUBLE
3978: LD_INT 1
3980: DEC
3981: ST_TO_ADDR
3982: LD_INT 4
3984: PUSH
3985: FOR_TO
3986: IFFALSE 4047
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3988: LD_VAR 0 4
3992: PUSH
3993: LD_VAR 0 3
3997: ARRAY
3998: PPUSH
3999: LD_EXP 12
4003: PUSH
4004: LD_EXP 7
4008: PUSH
4009: LD_VAR 0 2
4013: ARRAY
4014: ARRAY
4015: PUSH
4016: LD_INT 2
4018: ARRAY
4019: PPUSH
4020: LD_INT 0
4022: PPUSH
4023: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4027: LD_ADDR_VAR 0 4
4031: PUSH
4032: LD_VAR 0 4
4036: PPUSH
4037: LD_INT 1
4039: PPUSH
4040: CALL_OW 3
4044: ST_TO_ADDR
// end ;
4045: GO 3985
4047: POP
4048: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4049: LD_ADDR_EXP 27
4053: PUSH
4054: LD_EXP 27
4058: PPUSH
4059: LD_VAR 0 2
4063: PPUSH
4064: LD_VAR 0 4
4068: PPUSH
4069: CALL_OW 1
4073: ST_TO_ADDR
// end ; end ;
4074: GO 3916
4076: POP
4077: POP
// reinforcements_arrive := tick ;
4078: LD_ADDR_VAR 0 5
4082: PUSH
4083: LD_OWVAR 1
4087: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4088: LD_VAR 0 5
4092: PUSH
4093: LD_INT 21000
4095: PLUS
4096: PUSH
4097: LD_OWVAR 1
4101: LESS
4102: PUSH
4103: LD_EXP 28
4107: PUSH
4108: LD_INT 1
4110: EQUAL
4111: AND
4112: PUSH
4113: LD_EXP 23
4117: PUSH
4118: LD_INT 2
4120: EQUAL
4121: AND
4122: IFFALSE 4307
// begin multi_reinforcements_spawned := 2 ;
4124: LD_ADDR_EXP 28
4128: PUSH
4129: LD_INT 2
4131: ST_TO_ADDR
// for i = 1 to 8 do
4132: LD_ADDR_VAR 0 2
4136: PUSH
4137: DOUBLE
4138: LD_INT 1
4140: DEC
4141: ST_TO_ADDR
4142: LD_INT 8
4144: PUSH
4145: FOR_TO
4146: IFFALSE 4305
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4148: LD_EXP 7
4152: PUSH
4153: LD_VAR 0 2
4157: ARRAY
4158: PUSH
4159: LD_EXP 25
4163: PUSH
4164: LD_VAR 0 2
4168: ARRAY
4169: NOT
4170: AND
4171: PUSH
4172: LD_EXP 27
4176: PUSH
4177: LD_VAR 0 2
4181: ARRAY
4182: AND
4183: IFFALSE 4303
// begin tmp := multi_reinforcements [ i ] ;
4185: LD_ADDR_VAR 0 4
4189: PUSH
4190: LD_EXP 27
4194: PUSH
4195: LD_VAR 0 2
4199: ARRAY
4200: ST_TO_ADDR
// for j = 1 to 3 do
4201: LD_ADDR_VAR 0 3
4205: PUSH
4206: DOUBLE
4207: LD_INT 1
4209: DEC
4210: ST_TO_ADDR
4211: LD_INT 3
4213: PUSH
4214: FOR_TO
4215: IFFALSE 4276
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4217: LD_VAR 0 4
4221: PUSH
4222: LD_VAR 0 3
4226: ARRAY
4227: PPUSH
4228: LD_EXP 12
4232: PUSH
4233: LD_EXP 7
4237: PUSH
4238: LD_VAR 0 2
4242: ARRAY
4243: ARRAY
4244: PUSH
4245: LD_INT 2
4247: ARRAY
4248: PPUSH
4249: LD_INT 0
4251: PPUSH
4252: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4256: LD_ADDR_VAR 0 4
4260: PUSH
4261: LD_VAR 0 4
4265: PPUSH
4266: LD_INT 1
4268: PPUSH
4269: CALL_OW 3
4273: ST_TO_ADDR
// end ;
4274: GO 4214
4276: POP
4277: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4278: LD_ADDR_EXP 27
4282: PUSH
4283: LD_EXP 27
4287: PPUSH
4288: LD_VAR 0 2
4292: PPUSH
4293: LD_VAR 0 4
4297: PPUSH
4298: CALL_OW 1
4302: ST_TO_ADDR
// end ; end ;
4303: GO 4145
4305: POP
4306: POP
// end ; if not multi_custom_commanders then
4307: LD_EXP 16
4311: NOT
4312: IFFALSE 4425
// begin for i = 1 to 8 do
4314: LD_ADDR_VAR 0 2
4318: PUSH
4319: DOUBLE
4320: LD_INT 1
4322: DEC
4323: ST_TO_ADDR
4324: LD_INT 8
4326: PUSH
4327: FOR_TO
4328: IFFALSE 4399
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4330: LD_INT 22
4332: PUSH
4333: LD_VAR 0 2
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PPUSH
4342: CALL_OW 69
4346: PUSH
4347: LD_INT 0
4349: EQUAL
4350: PUSH
4351: LD_EXP 25
4355: PUSH
4356: LD_VAR 0 2
4360: ARRAY
4361: NOT
4362: AND
4363: IFFALSE 4397
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4365: LD_ADDR_EXP 25
4369: PUSH
4370: LD_EXP 25
4374: PPUSH
4375: LD_VAR 0 2
4379: PPUSH
4380: LD_INT 1
4382: PPUSH
4383: CALL_OW 1
4387: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4388: LD_VAR 0 2
4392: PPUSH
4393: CALL 4892 0 1
// end ; end ;
4397: GO 4327
4399: POP
4400: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4401: LD_EXP 25
4405: PPUSH
4406: CALL 11914 0 1
4410: PUSH
4411: LD_EXP 7
4415: PPUSH
4416: CALL 11914 0 1
4420: EQUAL
4421: IFFALSE 4425
// break ;
4423: GO 4460
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4425: LD_INT 22
4427: PUSH
4428: LD_EXP 3
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: PPUSH
4437: CALL_OW 69
4441: PUSH
4442: LD_INT 0
4444: EQUAL
4445: PUSH
4446: LD_EXP 2
4450: AND
4451: PUSH
4452: LD_EXP 24
4456: NOT
4457: OR
4458: IFFALSE 3861
// game := false ;
4460: LD_ADDR_EXP 2
4464: PUSH
4465: LD_INT 0
4467: ST_TO_ADDR
// for i = 1 to 8 do
4468: LD_ADDR_VAR 0 2
4472: PUSH
4473: DOUBLE
4474: LD_INT 1
4476: DEC
4477: ST_TO_ADDR
4478: LD_INT 8
4480: PUSH
4481: FOR_TO
4482: IFFALSE 4518
// begin if multi_sides [ i ] then
4484: LD_EXP 7
4488: PUSH
4489: LD_VAR 0 2
4493: ARRAY
4494: IFFALSE 4516
// SetMultiScore ( i , multi_points [ i ] ) ;
4496: LD_VAR 0 2
4500: PPUSH
4501: LD_EXP 29
4505: PUSH
4506: LD_VAR 0 2
4510: ARRAY
4511: PPUSH
4512: CALL_OW 506
// end ;
4516: GO 4481
4518: POP
4519: POP
// if multi_loosers [ your_side ] then
4520: LD_EXP 25
4524: PUSH
4525: LD_OWVAR 2
4529: ARRAY
4530: IFFALSE 4538
// YouLostInMultiplayer else
4532: CALL_OW 107
4536: GO 4542
// YouWinInMultiplayer ;
4538: CALL_OW 106
// end ;
4542: LD_VAR 0 1
4546: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4547: LD_INT 0
4549: PPUSH
4550: PPUSH
// result := [ #tick , tick ] ;
4551: LD_ADDR_VAR 0 1
4555: PUSH
4556: LD_STRING #tick
4558: PUSH
4559: LD_OWVAR 1
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: ST_TO_ADDR
// for i = 1 to 8 do
4568: LD_ADDR_VAR 0 2
4572: PUSH
4573: DOUBLE
4574: LD_INT 1
4576: DEC
4577: ST_TO_ADDR
4578: LD_INT 8
4580: PUSH
4581: FOR_TO
4582: IFFALSE 4639
// begin if multi_sides [ i ] then
4584: LD_EXP 7
4588: PUSH
4589: LD_VAR 0 2
4593: ARRAY
4594: IFFALSE 4637
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4596: LD_ADDR_VAR 0 1
4600: PUSH
4601: LD_VAR 0 1
4605: PUSH
4606: LD_STRING #coop-points
4608: PUSH
4609: LD_VAR 0 2
4613: PUSH
4614: LD_VAR 0 2
4618: PUSH
4619: LD_EXP 29
4623: PUSH
4624: LD_VAR 0 2
4628: ARRAY
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: ADD
4636: ST_TO_ADDR
// end ; end ;
4637: GO 4581
4639: POP
4640: POP
// end ;
4641: LD_VAR 0 1
4645: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4646: LD_INT 0
4648: PPUSH
4649: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4650: LD_ADDR_EXP 29
4654: PUSH
4655: LD_INT 0
4657: PUSH
4658: LD_INT 0
4660: PUSH
4661: LD_INT 0
4663: PUSH
4664: LD_INT 0
4666: PUSH
4667: LD_INT 0
4669: PUSH
4670: LD_INT 0
4672: PUSH
4673: LD_INT 0
4675: PUSH
4676: LD_INT 0
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: LIST
4683: LIST
4684: LIST
4685: LIST
4686: LIST
4687: LIST
4688: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4689: LD_ADDR_EXP 30
4693: PUSH
4694: EMPTY
4695: ST_TO_ADDR
// end ;
4696: LD_VAR 0 1
4700: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4701: LD_INT 0
4703: PPUSH
// if not multi_points or not side or side > 8 then
4704: LD_EXP 29
4708: NOT
4709: PUSH
4710: LD_VAR 0 1
4714: NOT
4715: OR
4716: PUSH
4717: LD_VAR 0 1
4721: PUSH
4722: LD_INT 8
4724: GREATER
4725: OR
4726: IFFALSE 4730
// exit ;
4728: GO 4767
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4730: LD_ADDR_EXP 29
4734: PUSH
4735: LD_EXP 29
4739: PPUSH
4740: LD_VAR 0 1
4744: PPUSH
4745: LD_EXP 29
4749: PUSH
4750: LD_VAR 0 1
4754: ARRAY
4755: PUSH
4756: LD_VAR 0 2
4760: PLUS
4761: PPUSH
4762: CALL_OW 1
4766: ST_TO_ADDR
// end ;
4767: LD_VAR 0 3
4771: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4772: LD_INT 0
4774: PPUSH
// if not multi_points or not side or side > 8 then
4775: LD_EXP 29
4779: NOT
4780: PUSH
4781: LD_VAR 0 1
4785: NOT
4786: OR
4787: PUSH
4788: LD_VAR 0 1
4792: PUSH
4793: LD_INT 8
4795: GREATER
4796: OR
4797: IFFALSE 4801
// exit ;
4799: GO 4817
// result := multi_points [ side ] ;
4801: LD_ADDR_VAR 0 2
4805: PUSH
4806: LD_EXP 29
4810: PUSH
4811: LD_VAR 0 1
4815: ARRAY
4816: ST_TO_ADDR
// end ;
4817: LD_VAR 0 2
4821: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4822: LD_INT 0
4824: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4825: LD_ADDR_EXP 30
4829: PUSH
4830: LD_EXP 30
4834: PPUSH
4835: LD_EXP 30
4839: PUSH
4840: LD_INT 1
4842: PLUS
4843: PPUSH
4844: LD_VAR 0 1
4848: PPUSH
4849: CALL_OW 2
4853: ST_TO_ADDR
// end ;
4854: LD_VAR 0 2
4858: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4859: LD_INT 0
4861: PPUSH
// if not id then
4862: LD_VAR 0 1
4866: NOT
4867: IFFALSE 4871
// exit ;
4869: GO 4887
// result := multi_points_conditions [ id ] ;
4871: LD_ADDR_VAR 0 2
4875: PUSH
4876: LD_EXP 30
4880: PUSH
4881: LD_VAR 0 1
4885: ARRAY
4886: ST_TO_ADDR
// end ;
4887: LD_VAR 0 2
4891: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
4897: PPUSH
4898: PPUSH
// players := [ ] ;
4899: LD_ADDR_VAR 0 3
4903: PUSH
4904: EMPTY
4905: ST_TO_ADDR
// for i = 1 to 8 do
4906: LD_ADDR_VAR 0 4
4910: PUSH
4911: DOUBLE
4912: LD_INT 1
4914: DEC
4915: ST_TO_ADDR
4916: LD_INT 8
4918: PUSH
4919: FOR_TO
4920: IFFALSE 4979
// begin if i = side then
4922: LD_VAR 0 4
4926: PUSH
4927: LD_VAR 0 1
4931: EQUAL
4932: IFFALSE 4936
// continue ;
4934: GO 4919
// if multi_sides [ i ] and not multi_loosers [ i ] then
4936: LD_EXP 7
4940: PUSH
4941: LD_VAR 0 4
4945: ARRAY
4946: PUSH
4947: LD_EXP 25
4951: PUSH
4952: LD_VAR 0 4
4956: ARRAY
4957: NOT
4958: AND
4959: IFFALSE 4977
// players := players ^ i ;
4961: LD_ADDR_VAR 0 3
4965: PUSH
4966: LD_VAR 0 3
4970: PUSH
4971: LD_VAR 0 4
4975: ADD
4976: ST_TO_ADDR
// end ;
4977: GO 4919
4979: POP
4980: POP
// if not players then
4981: LD_VAR 0 3
4985: NOT
4986: IFFALSE 4990
// exit ;
4988: GO 5257
// if players = 1 then
4990: LD_VAR 0 3
4994: PUSH
4995: LD_INT 1
4997: EQUAL
4998: IFFALSE 5059
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5000: LD_ADDR_VAR 0 4
5004: PUSH
5005: LD_INT 22
5007: PUSH
5008: LD_VAR 0 1
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 51
5019: PUSH
5020: EMPTY
5021: LIST
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PPUSH
5027: CALL_OW 69
5031: PUSH
5032: FOR_IN
5033: IFFALSE 5055
// SetSide ( i , players [ 1 ] ) ;
5035: LD_VAR 0 4
5039: PPUSH
5040: LD_VAR 0 3
5044: PUSH
5045: LD_INT 1
5047: ARRAY
5048: PPUSH
5049: CALL_OW 235
5053: GO 5032
5055: POP
5056: POP
// end else
5057: GO 5257
// begin j := 1 ;
5059: LD_ADDR_VAR 0 5
5063: PUSH
5064: LD_INT 1
5066: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5067: LD_ADDR_VAR 0 4
5071: PUSH
5072: LD_INT 22
5074: PUSH
5075: LD_VAR 0 1
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 2
5086: PUSH
5087: LD_INT 21
5089: PUSH
5090: LD_INT 1
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: LD_INT 51
5099: PUSH
5100: EMPTY
5101: LIST
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 21
5109: PUSH
5110: LD_INT 2
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PPUSH
5126: CALL_OW 69
5130: PUSH
5131: FOR_IN
5132: IFFALSE 5255
// begin SetSide ( i , players [ j ] ) ;
5134: LD_VAR 0 4
5138: PPUSH
5139: LD_VAR 0 3
5143: PUSH
5144: LD_VAR 0 5
5148: ARRAY
5149: PPUSH
5150: CALL_OW 235
// if IsDrivenBy ( i ) then
5154: LD_VAR 0 4
5158: PPUSH
5159: CALL_OW 311
5163: IFFALSE 5190
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5165: LD_VAR 0 4
5169: PPUSH
5170: CALL_OW 311
5174: PPUSH
5175: LD_VAR 0 3
5179: PUSH
5180: LD_VAR 0 5
5184: ARRAY
5185: PPUSH
5186: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5190: LD_VAR 0 4
5194: PPUSH
5195: CALL_OW 310
5199: PPUSH
5200: CALL_OW 247
5204: PUSH
5205: LD_INT 3
5207: EQUAL
5208: IFFALSE 5219
// ComExitBuilding ( i ) ;
5210: LD_VAR 0 4
5214: PPUSH
5215: CALL_OW 122
// j := j + 1 ;
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_VAR 0 5
5228: PUSH
5229: LD_INT 1
5231: PLUS
5232: ST_TO_ADDR
// if j > players then
5233: LD_VAR 0 5
5237: PUSH
5238: LD_VAR 0 3
5242: GREATER
5243: IFFALSE 5253
// j := 1 ;
5245: LD_ADDR_VAR 0 5
5249: PUSH
5250: LD_INT 1
5252: ST_TO_ADDR
// end ;
5253: GO 5131
5255: POP
5256: POP
// end ; end ;
5257: LD_VAR 0 2
5261: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5262: LD_INT 0
5264: PPUSH
5265: PPUSH
5266: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5267: LD_ADDR_VAR 0 3
5271: PUSH
5272: LD_INT 5
5274: PUSH
5275: LD_INT 10
5277: PUSH
5278: EMPTY
5279: LIST
5280: LIST
5281: PUSH
5282: LD_INT 120
5284: PUSH
5285: LD_INT 2
5287: PUSH
5288: EMPTY
5289: LIST
5290: LIST
5291: PUSH
5292: LD_INT 101
5294: PUSH
5295: LD_INT 8
5297: PUSH
5298: EMPTY
5299: LIST
5300: LIST
5301: PUSH
5302: LD_INT 27
5304: PUSH
5305: LD_INT 4
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: LIST
5316: LIST
5317: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5318: LD_ADDR_VAR 0 2
5322: PUSH
5323: LD_INT 1
5325: PPUSH
5326: LD_VAR 0 3
5330: PPUSH
5331: CALL_OW 12
5335: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5336: LD_INT 4
5338: PPUSH
5339: LD_INT 5
5341: PPUSH
5342: LD_VAR 0 3
5346: PUSH
5347: LD_VAR 0 2
5351: ARRAY
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_VAR 0 3
5361: PUSH
5362: LD_VAR 0 2
5366: ARRAY
5367: PUSH
5368: LD_INT 2
5370: ARRAY
5371: PPUSH
5372: LD_INT 0
5374: PPUSH
5375: CALL_OW 58
// end ;
5379: LD_VAR 0 1
5383: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5384: LD_INT 0
5386: PPUSH
// if not side or side > 8 then
5387: LD_VAR 0 1
5391: NOT
5392: PUSH
5393: LD_VAR 0 1
5397: PUSH
5398: LD_INT 8
5400: GREATER
5401: OR
5402: IFFALSE 5406
// exit ;
5404: GO 5423
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5406: LD_VAR 0 1
5410: PPUSH
5411: LD_INT 6
5413: PPUSH
5414: CALL 4859 0 1
5418: PPUSH
5419: CALL 4701 0 2
// end ;
5423: LD_VAR 0 2
5427: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5428: LD_INT 0
5430: PPUSH
// if not side or side > 8 then
5431: LD_VAR 0 1
5435: NOT
5436: PUSH
5437: LD_VAR 0 1
5441: PUSH
5442: LD_INT 8
5444: GREATER
5445: OR
5446: IFFALSE 5450
// exit ;
5448: GO 5467
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5450: LD_VAR 0 1
5454: PPUSH
5455: LD_INT 4
5457: PPUSH
5458: CALL 4859 0 1
5462: PPUSH
5463: CALL 4701 0 2
// end ;
5467: LD_VAR 0 2
5471: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5472: LD_INT 0
5474: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5475: LD_VAR 0 1
5479: NOT
5480: PUSH
5481: LD_VAR 0 1
5485: PUSH
5486: LD_INT 8
5488: GREATER
5489: OR
5490: PUSH
5491: LD_VAR 0 2
5495: PUSH
5496: LD_INT 2
5498: PUSH
5499: LD_INT 6
5501: PUSH
5502: LD_INT 36
5504: PUSH
5505: LD_INT 0
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: IN
5514: NOT
5515: OR
5516: IFFALSE 5520
// exit ;
5518: GO 5537
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5520: LD_VAR 0 1
5524: PPUSH
5525: LD_INT 3
5527: PPUSH
5528: CALL 4859 0 1
5532: PPUSH
5533: CALL 4701 0 2
// end ;
5537: LD_VAR 0 3
5541: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5542: LD_INT 0
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
// if not un then
5550: LD_VAR 0 1
5554: NOT
5555: IFFALSE 5559
// exit ;
5557: GO 5783
// if not points then
5559: LD_VAR 0 2
5563: NOT
5564: IFFALSE 5581
// gained_points := Multiplayer_GetCondition ( 1 ) else
5566: LD_ADDR_VAR 0 8
5570: PUSH
5571: LD_INT 1
5573: PPUSH
5574: CALL 4859 0 1
5578: ST_TO_ADDR
5579: GO 5591
// gained_points := points ;
5581: LD_ADDR_VAR 0 8
5585: PUSH
5586: LD_VAR 0 2
5590: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5591: LD_ADDR_VAR 0 6
5595: PUSH
5596: LD_VAR 0 1
5600: PPUSH
5601: CALL_OW 503
5605: ST_TO_ADDR
// if last_shoot > - 1 then
5606: LD_VAR 0 6
5610: PUSH
5611: LD_INT 1
5613: NEG
5614: GREATER
5615: IFFALSE 5627
// begin side := last_shoot ;
5617: LD_ADDR_VAR 0 4
5621: PUSH
5622: LD_VAR 0 6
5626: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5627: LD_ADDR_VAR 0 7
5631: PUSH
5632: LD_OWVAR 3
5636: PUSH
5637: LD_INT 22
5639: PUSH
5640: LD_VAR 0 1
5644: PPUSH
5645: CALL_OW 255
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PPUSH
5654: CALL_OW 69
5658: DIFF
5659: PPUSH
5660: LD_VAR 0 1
5664: PPUSH
5665: CALL_OW 74
5669: ST_TO_ADDR
// if nearest_unit then
5670: LD_VAR 0 7
5674: IFFALSE 5691
// side2 := GetSide ( nearest_unit ) ;
5676: LD_ADDR_VAR 0 5
5680: PUSH
5681: LD_VAR 0 7
5685: PPUSH
5686: CALL_OW 255
5690: ST_TO_ADDR
// if not side and not side2 then
5691: LD_VAR 0 4
5695: NOT
5696: PUSH
5697: LD_VAR 0 5
5701: NOT
5702: AND
5703: IFFALSE 5707
// exit ;
5705: GO 5783
// if side = side2 then
5707: LD_VAR 0 4
5711: PUSH
5712: LD_VAR 0 5
5716: EQUAL
5717: IFFALSE 5735
// Multiplayer_AddPoints ( side , gained_points ) else
5719: LD_VAR 0 4
5723: PPUSH
5724: LD_VAR 0 8
5728: PPUSH
5729: CALL 4701 0 2
5733: GO 5783
// begin if side then
5735: LD_VAR 0 4
5739: IFFALSE 5759
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5741: LD_VAR 0 4
5745: PPUSH
5746: LD_VAR 0 8
5750: PUSH
5751: LD_INT 2
5753: DIV
5754: PPUSH
5755: CALL 4701 0 2
// if side2 then
5759: LD_VAR 0 5
5763: IFFALSE 5783
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5765: LD_VAR 0 5
5769: PPUSH
5770: LD_VAR 0 8
5774: PUSH
5775: LD_INT 2
5777: DIV
5778: PPUSH
5779: CALL 4701 0 2
// end ; end ;
5783: LD_VAR 0 3
5787: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5788: LD_INT 0
5790: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5791: LD_VAR 0 1
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: CALL 4859 0 1
5803: PPUSH
5804: CALL 4701 0 2
// end ; end_of_file
5808: LD_VAR 0 2
5812: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5813: LD_INT 0
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
5821: PPUSH
5822: PPUSH
5823: PPUSH
// side_bot := side ;
5824: LD_ADDR_EXP 3
5828: PUSH
5829: LD_VAR 0 1
5833: ST_TO_ADDR
// techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5834: LD_ADDR_VAR 0 10
5838: PUSH
5839: LD_INT 11
5841: PUSH
5842: LD_INT 4
5844: PUSH
5845: LD_INT 3
5847: PUSH
5848: LD_INT 5
5850: PUSH
5851: LD_INT 66
5853: PUSH
5854: LD_INT 67
5856: PUSH
5857: LD_INT 53
5859: PUSH
5860: LD_INT 18
5862: PUSH
5863: LD_INT 40
5865: PUSH
5866: LD_INT 22
5868: PUSH
5869: LD_INT 72
5871: PUSH
5872: LD_INT 55
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: LIST
5888: ST_TO_ADDR
// for i in techs do
5889: LD_ADDR_VAR 0 3
5893: PUSH
5894: LD_VAR 0 10
5898: PUSH
5899: FOR_IN
5900: IFFALSE 5921
// SetTech ( i , side , state_researched ) ;
5902: LD_VAR 0 3
5906: PPUSH
5907: LD_VAR 0 1
5911: PPUSH
5912: LD_INT 2
5914: PPUSH
5915: CALL_OW 322
5919: GO 5899
5921: POP
5922: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
5923: LD_ADDR_VAR 0 8
5927: PUSH
5928: LD_INT 6
5930: PUSH
5931: LD_INT 7
5933: PUSH
5934: LD_INT 8
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: PUSH
5942: LD_OWVAR 67
5946: ARRAY
5947: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
5948: LD_INT 69
5950: PUSH
5951: EMPTY
5952: LIST
5953: PPUSH
5954: LD_INT 141
5956: PPUSH
5957: CALL_OW 169
// wait ( 1 ) ;
5961: LD_INT 1
5963: PPUSH
5964: CALL_OW 67
// uc_side := side ;
5968: LD_ADDR_OWVAR 20
5972: PUSH
5973: LD_VAR 0 1
5977: ST_TO_ADDR
// uc_nation := 2 ;
5978: LD_ADDR_OWVAR 21
5982: PUSH
5983: LD_INT 2
5985: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
5986: LD_ADDR_EXP 33
5990: PUSH
5991: LD_INT 94
5993: PPUSH
5994: LD_INT 35
5996: PPUSH
5997: LD_STRING dammam
5999: PPUSH
6000: LD_VAR 0 8
6004: PPUSH
6005: LD_INT 10000
6007: PUSH
6008: LD_INT 1000
6010: PUSH
6011: LD_INT 300
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: LIST
6018: PPUSH
6019: LD_INT 12
6021: PUSH
6022: LD_INT 4
6024: PUSH
6025: LD_INT 1
6027: NEG
6028: PUSH
6029: LD_INT 4
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: LIST
6036: LIST
6037: PPUSH
6038: CALL 18473 0 6
6042: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6043: LD_ADDR_EXP 34
6047: PUSH
6048: LD_INT 122
6050: PPUSH
6051: LD_INT 38
6053: PPUSH
6054: LD_STRING 
6056: PPUSH
6057: LD_VAR 0 8
6061: PPUSH
6062: LD_INT 1000
6064: PUSH
6065: LD_INT 100
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: PPUSH
6076: LD_INT 12
6078: PUSH
6079: LD_INT 4
6081: PUSH
6082: LD_INT 2
6084: PUSH
6085: LD_INT 0
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL 18473 0 6
6098: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6099: LD_ADDR_EXP 31
6103: PUSH
6104: LD_INT 45
6106: PPUSH
6107: LD_INT 34
6109: PPUSH
6110: LD_STRING jeddah
6112: PPUSH
6113: LD_VAR 0 8
6117: PPUSH
6118: LD_INT 700
6120: PUSH
6121: LD_INT 300
6123: PUSH
6124: LD_INT 10
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: PPUSH
6132: LD_INT 12
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: LD_INT 3
6140: PUSH
6141: LD_INT 2
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: PPUSH
6150: CALL 18473 0 6
6154: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6155: LD_ADDR_EXP 32
6159: PUSH
6160: LD_INT 7
6162: PPUSH
6163: LD_INT 33
6165: PPUSH
6166: LD_STRING riyadh
6168: PPUSH
6169: LD_VAR 0 8
6173: PPUSH
6174: LD_INT 500
6176: PUSH
6177: LD_INT 60
6179: PUSH
6180: LD_INT 0
6182: PUSH
6183: EMPTY
6184: LIST
6185: LIST
6186: LIST
6187: PPUSH
6188: LD_INT 4
6190: PUSH
6191: LD_INT 2
6193: PUSH
6194: LD_INT 3
6196: PUSH
6197: LD_INT 1
6199: PUSH
6200: EMPTY
6201: LIST
6202: LIST
6203: LIST
6204: LIST
6205: PPUSH
6206: CALL 18473 0 6
6210: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6211: LD_ADDR_EXP 35
6215: PUSH
6216: LD_INT 69
6218: PPUSH
6219: LD_INT 36
6221: PPUSH
6222: LD_STRING 
6224: PPUSH
6225: LD_VAR 0 8
6229: PPUSH
6230: LD_INT 500
6232: PUSH
6233: LD_INT 50
6235: PUSH
6236: LD_INT 0
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: PPUSH
6244: LD_INT 11
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 3
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: PPUSH
6262: CALL 18473 0 6
6266: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6267: LD_ADDR_EXP 43
6271: PUSH
6272: LD_EXP 33
6276: PUSH
6277: LD_EXP 31
6281: PUSH
6282: LD_EXP 35
6286: PUSH
6287: LD_EXP 32
6291: PUSH
6292: LD_EXP 34
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6304: LD_ADDR_OWVAR 37
6308: PUSH
6309: LD_INT 14
6311: ST_TO_ADDR
// vc_engine := engine_siberite ;
6312: LD_ADDR_OWVAR 39
6316: PUSH
6317: LD_INT 3
6319: ST_TO_ADDR
// vc_control := control_manual ;
6320: LD_ADDR_OWVAR 38
6324: PUSH
6325: LD_INT 1
6327: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6328: LD_ADDR_OWVAR 40
6332: PUSH
6333: LD_INT 31
6335: ST_TO_ADDR
// for i = 1 to 4 do
6336: LD_ADDR_VAR 0 3
6340: PUSH
6341: DOUBLE
6342: LD_INT 1
6344: DEC
6345: ST_TO_ADDR
6346: LD_INT 4
6348: PUSH
6349: FOR_TO
6350: IFFALSE 6619
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6352: LD_ADDR_VAR 0 5
6356: PUSH
6357: LD_INT 156
6359: PUSH
6360: LD_INT 15
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: PUSH
6367: LD_INT 12
6369: PUSH
6370: LD_INT 7
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PUSH
6381: LD_VAR 0 3
6385: PUSH
6386: LD_INT 2
6388: MOD
6389: PUSH
6390: LD_INT 1
6392: PLUS
6393: ARRAY
6394: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6395: LD_INT 0
6397: PPUSH
6398: LD_INT 3
6400: PPUSH
6401: LD_VAR 0 8
6405: PPUSH
6406: CALL_OW 380
// un := CreateVehicle ;
6410: LD_ADDR_VAR 0 6
6414: PUSH
6415: CALL_OW 45
6419: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6420: LD_VAR 0 6
6424: PPUSH
6425: LD_INT 0
6427: PPUSH
6428: LD_INT 5
6430: PPUSH
6431: CALL_OW 12
6435: PPUSH
6436: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6440: LD_VAR 0 6
6444: PPUSH
6445: LD_VAR 0 5
6449: PUSH
6450: LD_INT 1
6452: ARRAY
6453: PPUSH
6454: LD_VAR 0 5
6458: PUSH
6459: LD_INT 2
6461: ARRAY
6462: PPUSH
6463: LD_INT 6
6465: PPUSH
6466: LD_INT 0
6468: PPUSH
6469: CALL_OW 50
// un2 := CreateHuman ;
6473: LD_ADDR_VAR 0 7
6477: PUSH
6478: CALL_OW 44
6482: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6483: LD_VAR 0 7
6487: PPUSH
6488: LD_VAR 0 6
6492: PPUSH
6493: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6497: LD_ADDR_EXP 43
6501: PUSH
6502: LD_EXP 43
6506: PPUSH
6507: LD_VAR 0 3
6511: PUSH
6512: LD_INT 2
6514: MOD
6515: PUSH
6516: LD_INT 1
6518: PLUS
6519: PUSH
6520: LD_EXP 43
6524: PUSH
6525: LD_VAR 0 3
6529: PUSH
6530: LD_INT 2
6532: MOD
6533: PUSH
6534: LD_INT 1
6536: PLUS
6537: ARRAY
6538: PUSH
6539: LD_INT 1
6541: PLUS
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PPUSH
6547: LD_VAR 0 6
6551: PPUSH
6552: CALL 14774 0 3
6556: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6557: LD_ADDR_EXP 43
6561: PUSH
6562: LD_EXP 43
6566: PPUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 2
6574: MOD
6575: PUSH
6576: LD_INT 1
6578: PLUS
6579: PUSH
6580: LD_EXP 43
6584: PUSH
6585: LD_VAR 0 3
6589: PUSH
6590: LD_INT 2
6592: MOD
6593: PUSH
6594: LD_INT 1
6596: PLUS
6597: ARRAY
6598: PUSH
6599: LD_INT 1
6601: PLUS
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: PPUSH
6607: LD_VAR 0 7
6611: PPUSH
6612: CALL 14774 0 3
6616: ST_TO_ADDR
// end ;
6617: GO 6349
6619: POP
6620: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6621: LD_ADDR_VAR 0 3
6625: PUSH
6626: LD_INT 22
6628: PUSH
6629: LD_EXP 3
6633: PUSH
6634: EMPTY
6635: LIST
6636: LIST
6637: PUSH
6638: LD_INT 30
6640: PUSH
6641: LD_INT 31
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: PUSH
6648: LD_INT 58
6650: PUSH
6651: EMPTY
6652: LIST
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: PPUSH
6659: CALL_OW 69
6663: PUSH
6664: FOR_IN
6665: IFFALSE 6790
// begin if GetBase ( i ) then
6667: LD_VAR 0 3
6671: PPUSH
6672: CALL_OW 274
6676: IFFALSE 6680
// continue ;
6678: GO 6664
// d := GetDir ( i ) ;
6680: LD_ADDR_VAR 0 4
6684: PUSH
6685: LD_VAR 0 3
6689: PPUSH
6690: CALL_OW 254
6694: ST_TO_ADDR
// if d < 3 then
6695: LD_VAR 0 4
6699: PUSH
6700: LD_INT 3
6702: LESS
6703: IFFALSE 6721
// d := d + 3 else
6705: LD_ADDR_VAR 0 4
6709: PUSH
6710: LD_VAR 0 4
6714: PUSH
6715: LD_INT 3
6717: PLUS
6718: ST_TO_ADDR
6719: GO 6735
// d := d - 3 ;
6721: LD_ADDR_VAR 0 4
6725: PUSH
6726: LD_VAR 0 4
6730: PUSH
6731: LD_INT 3
6733: MINUS
6734: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6735: LD_INT 0
6737: PPUSH
6738: LD_INT 8
6740: PPUSH
6741: LD_VAR 0 8
6745: PPUSH
6746: CALL_OW 380
// un := CreateHuman ;
6750: LD_ADDR_VAR 0 6
6754: PUSH
6755: CALL_OW 44
6759: ST_TO_ADDR
// SetDir ( un , d ) ;
6760: LD_VAR 0 6
6764: PPUSH
6765: LD_VAR 0 4
6769: PPUSH
6770: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6774: LD_VAR 0 6
6778: PPUSH
6779: LD_VAR 0 3
6783: PPUSH
6784: CALL_OW 52
// end ;
6788: GO 6664
6790: POP
6791: POP
// ar_force_tmp := [ ] ;
6792: LD_ADDR_EXP 36
6796: PUSH
6797: EMPTY
6798: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6799: LD_INT 1
6801: PPUSH
6802: LD_INT 1
6804: PPUSH
6805: LD_VAR 0 8
6809: PPUSH
6810: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6814: LD_ADDR_OWVAR 33
6818: PUSH
6819: LD_STRING SecondCharsGal
6821: ST_TO_ADDR
// hc_face_number := 4 ;
6822: LD_ADDR_OWVAR 34
6826: PUSH
6827: LD_INT 4
6829: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6830: LD_ADDR_EXP 36
6834: PUSH
6835: LD_EXP 36
6839: PPUSH
6840: LD_INT 1
6842: PPUSH
6843: CALL_OW 44
6847: PPUSH
6848: CALL_OW 1
6852: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6853: LD_INT 2
6855: PPUSH
6856: LD_INT 4
6858: PPUSH
6859: LD_VAR 0 8
6863: PPUSH
6864: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6868: LD_ADDR_OWVAR 33
6872: PUSH
6873: LD_STRING SecondCharsGal
6875: ST_TO_ADDR
// hc_face_number := 15 ;
6876: LD_ADDR_OWVAR 34
6880: PUSH
6881: LD_INT 15
6883: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6884: LD_ADDR_EXP 36
6888: PUSH
6889: LD_EXP 36
6893: PPUSH
6894: LD_INT 2
6896: PPUSH
6897: CALL_OW 44
6901: PPUSH
6902: CALL_OW 1
6906: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6907: LD_INT 2
6909: PPUSH
6910: LD_INT 4
6912: PPUSH
6913: LD_VAR 0 8
6917: PPUSH
6918: CALL_OW 380
// hc_gallery :=  ;
6922: LD_ADDR_OWVAR 33
6926: PUSH
6927: LD_STRING 
6929: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
6930: LD_ADDR_EXP 36
6934: PUSH
6935: LD_EXP 36
6939: PPUSH
6940: LD_INT 3
6942: PPUSH
6943: CALL_OW 44
6947: PPUSH
6948: CALL_OW 1
6952: ST_TO_ADDR
// hc_sex := sex_male ;
6953: LD_ADDR_OWVAR 27
6957: PUSH
6958: LD_INT 1
6960: ST_TO_ADDR
// hc_class = 11 ;
6961: LD_ADDR_OWVAR 28
6965: PUSH
6966: LD_INT 11
6968: ST_TO_ADDR
// hc_gallery = sandar ;
6969: LD_ADDR_OWVAR 33
6973: PUSH
6974: LD_STRING sandar
6976: ST_TO_ADDR
// hc_face_number = 33 ;
6977: LD_ADDR_OWVAR 34
6981: PUSH
6982: LD_INT 33
6984: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
6985: LD_ADDR_OWVAR 26
6989: PUSH
6990: LD_STRING Thabit Muhair Saliba
6992: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
6993: LD_ADDR_OWVAR 31
6997: PUSH
6998: LD_INT 5
7000: PUSH
7001: LD_INT 5
7003: PUSH
7004: LD_INT 3
7006: PUSH
7007: LD_INT 3
7009: PUSH
7010: EMPTY
7011: LIST
7012: LIST
7013: LIST
7014: LIST
7015: ST_TO_ADDR
// Saliba = CreateHuman ;
7016: LD_ADDR_EXP 39
7020: PUSH
7021: CALL_OW 44
7025: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7026: LD_EXP 39
7030: PPUSH
7031: LD_INT 7
7033: PPUSH
7034: CALL_OW 52
// hc_name := Dietrich Gensher ;
7038: LD_ADDR_OWVAR 26
7042: PUSH
7043: LD_STRING Dietrich Gensher
7045: ST_TO_ADDR
// hc_class := 1 ;
7046: LD_ADDR_OWVAR 28
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// hc_gallery := sandar ;
7054: LD_ADDR_OWVAR 33
7058: PUSH
7059: LD_STRING sandar
7061: ST_TO_ADDR
// hc_face_number := 2 ;
7062: LD_ADDR_OWVAR 34
7066: PUSH
7067: LD_INT 2
7069: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7070: LD_ADDR_OWVAR 31
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 6
7080: PUSH
7081: LD_INT 5
7083: PUSH
7084: LD_INT 4
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: LIST
7092: ST_TO_ADDR
// Gensher := CreateHuman ;
7093: LD_ADDR_EXP 40
7097: PUSH
7098: CALL_OW 44
7102: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7103: LD_EXP 40
7107: PPUSH
7108: LD_INT 94
7110: PPUSH
7111: CALL_OW 52
// InitHc ;
7115: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7119: LD_ADDR_EXP 38
7123: PUSH
7124: EMPTY
7125: PUSH
7126: EMPTY
7127: PUSH
7128: EMPTY
7129: PUSH
7130: EMPTY
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: LIST
7136: LIST
7137: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7138: LD_ADDR_VAR 0 4
7142: PUSH
7143: DOUBLE
7144: LD_INT 1
7146: DEC
7147: ST_TO_ADDR
7148: LD_INT 3
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 4
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: LIST
7161: PUSH
7162: LD_OWVAR 67
7166: ARRAY
7167: PUSH
7168: FOR_TO
7169: IFFALSE 7387
// for i = 1 to 3 do
7171: LD_ADDR_VAR 0 3
7175: PUSH
7176: DOUBLE
7177: LD_INT 1
7179: DEC
7180: ST_TO_ADDR
7181: LD_INT 3
7183: PUSH
7184: FOR_TO
7185: IFFALSE 7383
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7187: LD_INT 14
7189: PPUSH
7190: LD_INT 3
7192: PUSH
7193: LD_INT 2
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: PUSH
7200: LD_INT 1
7202: PPUSH
7203: LD_INT 2
7205: PPUSH
7206: CALL_OW 12
7210: ARRAY
7211: PPUSH
7212: LD_INT 1
7214: PUSH
7215: LD_INT 5
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PUSH
7222: LD_INT 1
7224: PPUSH
7225: LD_INT 2
7227: PPUSH
7228: CALL_OW 12
7232: ARRAY
7233: PPUSH
7234: LD_INT 25
7236: PUSH
7237: LD_INT 27
7239: PUSH
7240: LD_INT 26
7242: PUSH
7243: LD_INT 28
7245: PUSH
7246: EMPTY
7247: LIST
7248: LIST
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 1
7254: PPUSH
7255: LD_INT 4
7257: PPUSH
7258: CALL_OW 12
7262: ARRAY
7263: PPUSH
7264: LD_INT 100
7266: PPUSH
7267: CALL 14652 0 5
// un := CreateVehicle ;
7271: LD_ADDR_VAR 0 6
7275: PUSH
7276: CALL_OW 45
7280: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7281: LD_ADDR_EXP 38
7285: PUSH
7286: LD_EXP 38
7290: PPUSH
7291: LD_VAR 0 3
7295: PUSH
7296: LD_EXP 38
7300: PUSH
7301: LD_VAR 0 3
7305: ARRAY
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: PPUSH
7315: LD_VAR 0 6
7319: PPUSH
7320: CALL 14774 0 3
7324: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7325: LD_VAR 0 6
7329: PPUSH
7330: LD_INT 0
7332: PPUSH
7333: LD_INT 5
7335: PPUSH
7336: CALL_OW 12
7340: PPUSH
7341: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7345: LD_VAR 0 6
7349: PPUSH
7350: LD_INT 20
7352: PUSH
7353: LD_INT 21
7355: PUSH
7356: LD_INT 22
7358: PUSH
7359: LD_INT 24
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: LIST
7367: PUSH
7368: LD_VAR 0 3
7372: ARRAY
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 49
// end ;
7381: GO 7184
7383: POP
7384: POP
7385: GO 7168
7387: POP
7388: POP
// InitHc ;
7389: CALL_OW 19
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
7393: LD_ADDR_VAR 0 9
7397: PUSH
7398: LD_INT 22
7400: PUSH
7401: LD_INT 2
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: ST_TO_ADDR
// if tmp and side <> 2 then
7413: LD_VAR 0 9
7417: PUSH
7418: LD_VAR 0 1
7422: PUSH
7423: LD_INT 2
7425: NONEQUAL
7426: AND
7427: IFFALSE 7460
// begin for i in tmp do
7429: LD_ADDR_VAR 0 3
7433: PUSH
7434: LD_VAR 0 9
7438: PUSH
7439: FOR_IN
7440: IFFALSE 7458
// SetSide ( i , side ) ;
7442: LD_VAR 0 3
7446: PPUSH
7447: LD_VAR 0 1
7451: PPUSH
7452: CALL_OW 235
7456: GO 7439
7458: POP
7459: POP
// end ; end ;
7460: LD_VAR 0 2
7464: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7465: LD_INT 94
7467: PPUSH
7468: CALL_OW 302
7472: PUSH
7473: LD_INT 94
7475: PPUSH
7476: CALL_OW 255
7480: PUSH
7481: LD_EXP 3
7485: EQUAL
7486: AND
7487: IFFALSE 8196
7489: GO 7491
7491: DISABLE
7492: LD_INT 0
7494: PPUSH
7495: PPUSH
7496: PPUSH
7497: PPUSH
7498: PPUSH
7499: PPUSH
7500: PPUSH
7501: PPUSH
7502: PPUSH
7503: PPUSH
// begin enable ;
7504: ENABLE
// base := 1 ;
7505: LD_ADDR_VAR 0 4
7509: PUSH
7510: LD_INT 1
7512: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7513: LD_ADDR_VAR 0 7
7517: PUSH
7518: LD_INT 0
7520: PUSH
7521: LD_INT 0
7523: PUSH
7524: LD_INT 0
7526: PUSH
7527: LD_INT 0
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: LD_INT 0
7535: PUSH
7536: LD_INT 0
7538: PUSH
7539: LD_INT 0
7541: PUSH
7542: LD_INT 1
7544: PUSH
7545: LD_INT 0
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: LIST
7557: LIST
7558: LIST
7559: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7560: LD_ADDR_VAR 0 6
7564: PUSH
7565: LD_INT 28
7567: PUSH
7568: LD_INT 14
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 107
7577: PUSH
7578: LD_INT 119
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 127
7587: PUSH
7588: LD_INT 97
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: LD_INT 185
7597: PUSH
7598: LD_INT 127
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: LIST
7609: LIST
7610: ST_TO_ADDR
// target := 0 ;
7611: LD_ADDR_VAR 0 9
7615: PUSH
7616: LD_INT 0
7618: ST_TO_ADDR
// x := 0 ;
7619: LD_ADDR_VAR 0 3
7623: PUSH
7624: LD_INT 0
7626: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7627: LD_ADDR_VAR 0 5
7631: PUSH
7632: LD_INT 14
7634: PUSH
7635: LD_INT 1
7637: PUSH
7638: LD_INT 2
7640: PUSH
7641: LD_INT 28
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: PUSH
7650: LD_INT 14
7652: PUSH
7653: LD_INT 1
7655: PUSH
7656: LD_INT 2
7658: PUSH
7659: LD_INT 25
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 14
7670: PUSH
7671: LD_INT 1
7673: PUSH
7674: LD_INT 2
7676: PUSH
7677: LD_INT 28
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 14
7688: PUSH
7689: LD_INT 1
7691: PUSH
7692: LD_INT 2
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: ST_TO_ADDR
// if Difficulty > 1 then
7710: LD_OWVAR 67
7714: PUSH
7715: LD_INT 1
7717: GREATER
7718: IFFALSE 7815
// for i = 1 to Difficulty + 2 do
7720: LD_ADDR_VAR 0 1
7724: PUSH
7725: DOUBLE
7726: LD_INT 1
7728: DEC
7729: ST_TO_ADDR
7730: LD_OWVAR 67
7734: PUSH
7735: LD_INT 2
7737: PLUS
7738: PUSH
7739: FOR_TO
7740: IFFALSE 7813
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7742: LD_ADDR_VAR 0 5
7746: PUSH
7747: LD_VAR 0 5
7751: PPUSH
7752: LD_VAR 0 5
7756: PUSH
7757: LD_INT 1
7759: PLUS
7760: PPUSH
7761: LD_INT 14
7763: PUSH
7764: LD_INT 1
7766: PUSH
7767: LD_INT 2
7769: PUSH
7770: LD_INT 28
7772: PUSH
7773: LD_INT 27
7775: PUSH
7776: LD_INT 27
7778: PUSH
7779: LD_INT 29
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 1
7790: PPUSH
7791: LD_INT 4
7793: PPUSH
7794: CALL_OW 12
7798: ARRAY
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: PPUSH
7806: CALL_OW 2
7810: ST_TO_ADDR
7811: GO 7739
7813: POP
7814: POP
// MC_SetProduceList ( base , tmp ) ;
7815: LD_VAR 0 4
7819: PPUSH
7820: LD_VAR 0 5
7824: PPUSH
7825: CALL 75970 0 2
// repeat wait ( 0 0$1 ) ;
7829: LD_INT 35
7831: PPUSH
7832: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7836: LD_VAR 0 4
7840: PPUSH
7841: CALL 76366 0 1
7845: PUSH
7846: LD_INT 0
7848: EQUAL
7849: IFFALSE 7829
// wait ( 0 0$10 ) ;
7851: LD_INT 350
7853: PPUSH
7854: CALL_OW 67
// for i = 1 to coords do
7858: LD_ADDR_VAR 0 1
7862: PUSH
7863: DOUBLE
7864: LD_INT 1
7866: DEC
7867: ST_TO_ADDR
7868: LD_VAR 0 6
7872: PUSH
7873: FOR_TO
7874: IFFALSE 7962
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7876: LD_ADDR_VAR 0 2
7880: PUSH
7881: LD_EXP 3
7885: PPUSH
7886: LD_VAR 0 6
7890: PUSH
7891: LD_VAR 0 1
7895: ARRAY
7896: PUSH
7897: LD_INT 1
7899: ARRAY
7900: PPUSH
7901: LD_VAR 0 6
7905: PUSH
7906: LD_VAR 0 1
7910: ARRAY
7911: PUSH
7912: LD_INT 2
7914: ARRAY
7915: PPUSH
7916: LD_INT 35
7918: PPUSH
7919: CALL 16038 0 4
7923: PUSH
7924: LD_INT 4
7926: ARRAY
7927: ST_TO_ADDR
// if t > x then
7928: LD_VAR 0 2
7932: PUSH
7933: LD_VAR 0 3
7937: GREATER
7938: IFFALSE 7960
// begin x := t ;
7940: LD_ADDR_VAR 0 3
7944: PUSH
7945: LD_VAR 0 2
7949: ST_TO_ADDR
// target := i ;
7950: LD_ADDR_VAR 0 9
7954: PUSH
7955: LD_VAR 0 1
7959: ST_TO_ADDR
// end ; end ;
7960: GO 7873
7962: POP
7963: POP
// case target of 1 :
7964: LD_VAR 0 9
7968: PUSH
7969: LD_INT 1
7971: DOUBLE
7972: EQUAL
7973: IFTRUE 7977
7975: GO 8009
7977: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
7978: LD_ADDR_VAR 0 10
7982: PUSH
7983: LD_INT 60
7985: PUSH
7986: LD_INT 8
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 28
7995: PUSH
7996: LD_INT 15
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: ST_TO_ADDR
8007: GO 8130
8009: LD_INT 2
8011: DOUBLE
8012: EQUAL
8013: IFTRUE 8017
8015: GO 8049
8017: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8018: LD_ADDR_VAR 0 10
8022: PUSH
8023: LD_INT 52
8025: PUSH
8026: LD_INT 11
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 76
8035: PUSH
8036: LD_INT 90
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: ST_TO_ADDR
8047: GO 8130
8049: LD_INT 3
8051: DOUBLE
8052: EQUAL
8053: IFTRUE 8057
8055: GO 8089
8057: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8058: LD_ADDR_VAR 0 10
8062: PUSH
8063: LD_INT 129
8065: PUSH
8066: LD_INT 66
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: PUSH
8073: LD_INT 130
8075: PUSH
8076: LD_INT 97
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: ST_TO_ADDR
8087: GO 8130
8089: LD_INT 4
8091: DOUBLE
8092: EQUAL
8093: IFTRUE 8097
8095: GO 8129
8097: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8098: LD_ADDR_VAR 0 10
8102: PUSH
8103: LD_INT 156
8105: PUSH
8106: LD_INT 87
8108: PUSH
8109: EMPTY
8110: LIST
8111: LIST
8112: PUSH
8113: LD_INT 183
8115: PUSH
8116: LD_INT 127
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: ST_TO_ADDR
8127: GO 8130
8129: POP
// if not _target then
8130: LD_VAR 0 10
8134: NOT
8135: IFFALSE 8166
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 52
8144: PUSH
8145: LD_INT 11
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 76
8154: PUSH
8155: LD_INT 90
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8166: LD_VAR 0 4
8170: PPUSH
8171: LD_EXP 62
8175: PUSH
8176: LD_VAR 0 4
8180: ARRAY
8181: PPUSH
8182: LD_VAR 0 10
8186: PPUSH
8187: LD_VAR 0 7
8191: PPUSH
8192: CALL 76203 0 4
// end ;
8196: PPOPN 10
8198: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8199: LD_INT 45
8201: PPUSH
8202: CALL_OW 302
8206: PUSH
8207: LD_INT 45
8209: PPUSH
8210: CALL_OW 255
8214: PUSH
8215: LD_EXP 3
8219: EQUAL
8220: AND
8221: PUSH
8222: LD_EXP 26
8226: PUSH
8227: LD_INT 3
8229: EQUAL
8230: PUSH
8231: LD_INT 94
8233: PPUSH
8234: CALL_OW 301
8238: OR
8239: PUSH
8240: LD_INT 94
8242: PPUSH
8243: CALL_OW 255
8247: PUSH
8248: LD_EXP 3
8252: NONEQUAL
8253: OR
8254: AND
8255: IFFALSE 8841
8257: GO 8259
8259: DISABLE
8260: LD_INT 0
8262: PPUSH
8263: PPUSH
8264: PPUSH
8265: PPUSH
8266: PPUSH
8267: PPUSH
8268: PPUSH
8269: PPUSH
8270: PPUSH
8271: PPUSH
// begin enable ;
8272: ENABLE
// base := 2 ;
8273: LD_ADDR_VAR 0 4
8277: PUSH
8278: LD_INT 2
8280: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8281: LD_ADDR_VAR 0 7
8285: PUSH
8286: LD_INT 0
8288: PUSH
8289: LD_INT 0
8291: PUSH
8292: LD_INT 0
8294: PUSH
8295: LD_INT 0
8297: PUSH
8298: LD_INT 1
8300: PUSH
8301: LD_INT 0
8303: PUSH
8304: LD_INT 0
8306: PUSH
8307: LD_INT 0
8309: PUSH
8310: LD_INT 1
8312: PUSH
8313: LD_INT 0
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: LIST
8322: LIST
8323: LIST
8324: LIST
8325: LIST
8326: LIST
8327: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8328: LD_ADDR_VAR 0 6
8332: PUSH
8333: LD_INT 101
8335: PUSH
8336: LD_INT 110
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PUSH
8343: LD_INT 100
8345: PUSH
8346: LD_INT 21
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: ST_TO_ADDR
// target := 0 ;
8357: LD_ADDR_VAR 0 9
8361: PUSH
8362: LD_INT 0
8364: ST_TO_ADDR
// x := 0 ;
8365: LD_ADDR_VAR 0 3
8369: PUSH
8370: LD_INT 0
8372: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8373: LD_ADDR_VAR 0 5
8377: PUSH
8378: LD_INT 14
8380: PUSH
8381: LD_INT 1
8383: PUSH
8384: LD_INT 2
8386: PUSH
8387: LD_INT 28
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: PUSH
8396: LD_INT 14
8398: PUSH
8399: LD_INT 1
8401: PUSH
8402: LD_INT 2
8404: PUSH
8405: LD_INT 25
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 14
8416: PUSH
8417: LD_INT 1
8419: PUSH
8420: LD_INT 2
8422: PUSH
8423: LD_INT 28
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: LIST
8436: ST_TO_ADDR
// if Difficulty > 1 then
8437: LD_OWVAR 67
8441: PUSH
8442: LD_INT 1
8444: GREATER
8445: IFFALSE 8540
// for i = 1 to Difficulty + 1 do
8447: LD_ADDR_VAR 0 1
8451: PUSH
8452: DOUBLE
8453: LD_INT 1
8455: DEC
8456: ST_TO_ADDR
8457: LD_OWVAR 67
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: PUSH
8466: FOR_TO
8467: IFFALSE 8538
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8469: LD_ADDR_VAR 0 5
8473: PUSH
8474: LD_VAR 0 5
8478: PPUSH
8479: LD_VAR 0 5
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: PPUSH
8488: LD_INT 14
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 2
8496: PUSH
8497: LD_INT 28
8499: PUSH
8500: LD_INT 27
8502: PUSH
8503: LD_INT 27
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: LIST
8510: PUSH
8511: LD_VAR 0 1
8515: PUSH
8516: LD_INT 2
8518: MOD
8519: PUSH
8520: LD_INT 1
8522: PLUS
8523: ARRAY
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: PPUSH
8531: CALL_OW 2
8535: ST_TO_ADDR
8536: GO 8466
8538: POP
8539: POP
// MC_SetProduceList ( base , tmp ) ;
8540: LD_VAR 0 4
8544: PPUSH
8545: LD_VAR 0 5
8549: PPUSH
8550: CALL 75970 0 2
// repeat wait ( 0 0$1 ) ;
8554: LD_INT 35
8556: PPUSH
8557: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8561: LD_VAR 0 4
8565: PPUSH
8566: CALL 76366 0 1
8570: PUSH
8571: LD_INT 0
8573: EQUAL
8574: IFFALSE 8554
// wait ( 0 0$10 ) ;
8576: LD_INT 350
8578: PPUSH
8579: CALL_OW 67
// for i = 1 to coords do
8583: LD_ADDR_VAR 0 1
8587: PUSH
8588: DOUBLE
8589: LD_INT 1
8591: DEC
8592: ST_TO_ADDR
8593: LD_VAR 0 6
8597: PUSH
8598: FOR_TO
8599: IFFALSE 8687
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8601: LD_ADDR_VAR 0 2
8605: PUSH
8606: LD_EXP 3
8610: PPUSH
8611: LD_VAR 0 6
8615: PUSH
8616: LD_VAR 0 1
8620: ARRAY
8621: PUSH
8622: LD_INT 1
8624: ARRAY
8625: PPUSH
8626: LD_VAR 0 6
8630: PUSH
8631: LD_VAR 0 1
8635: ARRAY
8636: PUSH
8637: LD_INT 2
8639: ARRAY
8640: PPUSH
8641: LD_INT 35
8643: PPUSH
8644: CALL 16038 0 4
8648: PUSH
8649: LD_INT 4
8651: ARRAY
8652: ST_TO_ADDR
// if t > x then
8653: LD_VAR 0 2
8657: PUSH
8658: LD_VAR 0 3
8662: GREATER
8663: IFFALSE 8685
// begin x := t ;
8665: LD_ADDR_VAR 0 3
8669: PUSH
8670: LD_VAR 0 2
8674: ST_TO_ADDR
// target := i ;
8675: LD_ADDR_VAR 0 9
8679: PUSH
8680: LD_VAR 0 1
8684: ST_TO_ADDR
// end ; end ;
8685: GO 8598
8687: POP
8688: POP
// case target of 1 :
8689: LD_VAR 0 9
8693: PUSH
8694: LD_INT 1
8696: DOUBLE
8697: EQUAL
8698: IFTRUE 8702
8700: GO 8734
8702: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8703: LD_ADDR_VAR 0 10
8707: PUSH
8708: LD_INT 49
8710: PUSH
8711: LD_INT 35
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: PUSH
8718: LD_INT 76
8720: PUSH
8721: LD_INT 90
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: EMPTY
8729: LIST
8730: LIST
8731: ST_TO_ADDR
8732: GO 8775
8734: LD_INT 2
8736: DOUBLE
8737: EQUAL
8738: IFTRUE 8742
8740: GO 8774
8742: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8743: LD_ADDR_VAR 0 10
8747: PUSH
8748: LD_INT 79
8750: PUSH
8751: LD_INT 13
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: PUSH
8758: LD_INT 100
8760: PUSH
8761: LD_INT 22
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: ST_TO_ADDR
8772: GO 8775
8774: POP
// if not _target then
8775: LD_VAR 0 10
8779: NOT
8780: IFFALSE 8811
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8782: LD_ADDR_VAR 0 10
8786: PUSH
8787: LD_INT 49
8789: PUSH
8790: LD_INT 35
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 76
8799: PUSH
8800: LD_INT 90
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8811: LD_VAR 0 4
8815: PPUSH
8816: LD_EXP 62
8820: PUSH
8821: LD_VAR 0 4
8825: ARRAY
8826: PPUSH
8827: LD_VAR 0 10
8831: PPUSH
8832: LD_VAR 0 7
8836: PPUSH
8837: CALL 76203 0 4
// end ; end_of_file
8841: PPOPN 10
8843: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8844: LD_INT 0
8846: PPUSH
8847: PPUSH
// begin if artifact_get then
8848: LD_EXP 4
8852: IFFALSE 8856
// exit ;
8854: GO 8878
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8856: LD_VAR 0 1
8860: PPUSH
8861: CALL_OW 255
8865: PPUSH
8866: CALL 5788 0 1
// artifact_get := true ;
8870: LD_ADDR_EXP 4
8874: PUSH
8875: LD_INT 1
8877: ST_TO_ADDR
// end ;
8878: PPOPN 4
8880: END
// on UnitDestroyed ( un ) do var i , side ;
8881: LD_INT 0
8883: PPUSH
8884: PPUSH
// begin side := GetSide ( un ) ;
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: LD_VAR 0 1
8894: PPUSH
8895: CALL_OW 255
8899: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8900: LD_VAR 0 3
8904: PUSH
8905: LD_EXP 69
8909: IN
8910: NOT
8911: PUSH
8912: LD_EXP 7
8916: PUSH
8917: LD_VAR 0 3
8921: ARRAY
8922: AND
8923: IFFALSE 8949
// if GetType ( un ) = unit_human then
8925: LD_VAR 0 1
8929: PPUSH
8930: CALL_OW 247
8934: PUSH
8935: LD_INT 1
8937: EQUAL
8938: IFFALSE 8949
// MultiplayerEvent_HumanLost ( side ) ;
8940: LD_VAR 0 3
8944: PPUSH
8945: CALL 5428 0 1
// if side in mc_sides then
8949: LD_VAR 0 3
8953: PUSH
8954: LD_EXP 69
8958: IN
8959: IFFALSE 9004
// if un <> Gensher then
8961: LD_VAR 0 1
8965: PUSH
8966: LD_EXP 40
8970: NONEQUAL
8971: IFFALSE 8987
// MultiplayerEvent_UnitKilled ( un , false ) else
8973: LD_VAR 0 1
8977: PPUSH
8978: LD_INT 0
8980: PPUSH
8981: CALL 5542 0 2
8985: GO 9004
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
8987: LD_VAR 0 1
8991: PPUSH
8992: LD_INT 5
8994: PPUSH
8995: CALL 4859 0 1
8999: PPUSH
9000: CALL 5542 0 2
// if multi_commanders and multi_custom_commanders then
9004: LD_EXP 24
9008: PUSH
9009: LD_EXP 16
9013: AND
9014: IFFALSE 9076
// if un in multi_commanders then
9016: LD_VAR 0 1
9020: PUSH
9021: LD_EXP 24
9025: IN
9026: IFFALSE 9076
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9028: LD_ADDR_EXP 25
9032: PUSH
9033: LD_EXP 25
9037: PPUSH
9038: LD_VAR 0 3
9042: PPUSH
9043: LD_INT 1
9045: PPUSH
9046: CALL_OW 1
9050: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9051: LD_ADDR_EXP 24
9055: PUSH
9056: LD_EXP 24
9060: PUSH
9061: LD_VAR 0 1
9065: DIFF
9066: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9067: LD_VAR 0 3
9071: PPUSH
9072: CALL 4892 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9076: LD_VAR 0 1
9080: PPUSH
9081: CALL 79460 0 1
// end ;
9085: PPOPN 3
9087: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9088: LD_VAR 0 1
9092: PPUSH
9093: LD_VAR 0 2
9097: PPUSH
9098: CALL 81792 0 2
// end ;
9102: PPOPN 2
9104: END
// on BuildingComplete ( building ) do var i , j ;
9105: LD_INT 0
9107: PPUSH
9108: PPUSH
// begin if GetSide ( building ) in mc_sides then
9109: LD_VAR 0 1
9113: PPUSH
9114: CALL_OW 255
9118: PUSH
9119: LD_EXP 69
9123: IN
9124: IFFALSE 9150
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9126: LD_VAR 0 1
9130: PPUSH
9131: CALL_OW 255
9135: PPUSH
9136: LD_VAR 0 1
9140: PPUSH
9141: CALL_OW 266
9145: PPUSH
9146: CALL 5472 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9150: LD_VAR 0 1
9154: PPUSH
9155: CALL_OW 266
9159: PUSH
9160: LD_INT 0
9162: EQUAL
9163: PUSH
9164: LD_VAR 0 1
9168: PPUSH
9169: CALL_OW 255
9173: PUSH
9174: LD_EXP 69
9178: IN
9179: NOT
9180: AND
9181: PUSH
9182: LD_EXP 5
9186: AND
9187: IFFALSE 9225
// begin SetBName ( building , base_names [ 1 ] ) ;
9189: LD_VAR 0 1
9193: PPUSH
9194: LD_EXP 5
9198: PUSH
9199: LD_INT 1
9201: ARRAY
9202: PPUSH
9203: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9207: LD_ADDR_EXP 5
9211: PUSH
9212: LD_EXP 5
9216: PPUSH
9217: LD_INT 1
9219: PPUSH
9220: CALL_OW 3
9224: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9225: LD_VAR 0 1
9229: PPUSH
9230: CALL 81101 0 1
// end ;
9234: PPOPN 3
9236: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9237: LD_VAR 0 1
9241: PPUSH
9242: LD_VAR 0 2
9246: PPUSH
9247: CALL 79156 0 2
// end ;
9251: PPOPN 2
9253: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9254: LD_VAR 0 1
9258: PPUSH
9259: LD_VAR 0 2
9263: PPUSH
9264: LD_VAR 0 3
9268: PPUSH
9269: LD_VAR 0 4
9273: PPUSH
9274: LD_VAR 0 5
9278: PPUSH
9279: CALL 78776 0 5
// end ;
9283: PPOPN 5
9285: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
9290: PPUSH
// begin side := GetSide ( vehicle ) ;
9291: LD_ADDR_VAR 0 4
9295: PUSH
9296: LD_VAR 0 1
9300: PPUSH
9301: CALL_OW 255
9305: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9306: LD_VAR 0 4
9310: PUSH
9311: LD_EXP 69
9315: IN
9316: NOT
9317: PUSH
9318: LD_EXP 7
9322: PUSH
9323: LD_VAR 0 4
9327: ARRAY
9328: AND
9329: IFFALSE 9340
// MultiplayerEvent_Produced ( side ) ;
9331: LD_VAR 0 4
9335: PPUSH
9336: CALL 5384 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9340: LD_VAR 0 1
9344: PPUSH
9345: LD_VAR 0 2
9349: PPUSH
9350: CALL 78329 0 2
// end ;
9354: PPOPN 5
9356: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9357: LD_VAR 0 1
9361: PPUSH
9362: LD_VAR 0 2
9366: PPUSH
9367: LD_VAR 0 3
9371: PPUSH
9372: LD_VAR 0 4
9376: PPUSH
9377: CALL 78167 0 4
// end ;
9381: PPOPN 4
9383: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9384: LD_VAR 0 1
9388: PPUSH
9389: LD_VAR 0 2
9393: PPUSH
9394: LD_VAR 0 3
9398: PPUSH
9399: CALL 77942 0 3
// end ;
9403: PPOPN 3
9405: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9406: LD_VAR 0 1
9410: PPUSH
9411: LD_VAR 0 2
9415: PPUSH
9416: CALL 77827 0 2
// end ;
9420: PPOPN 2
9422: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: LD_VAR 0 2
9432: PPUSH
9433: CALL 82087 0 2
// end ;
9437: PPOPN 2
9439: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9440: LD_VAR 0 1
9444: PPUSH
9445: LD_VAR 0 2
9449: PPUSH
9450: LD_VAR 0 3
9454: PPUSH
9455: LD_VAR 0 4
9459: PPUSH
9460: CALL 82303 0 4
// end ; end_of_file
9464: PPOPN 4
9466: END
// every 0 0$20 trigger game do
9467: LD_EXP 2
9471: IFFALSE 9516
9473: GO 9475
9475: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9476: LD_INT 7
9478: PUSH
9479: LD_INT 6
9481: PUSH
9482: LD_INT 4
9484: PUSH
9485: LD_INT 6
9487: PUSH
9488: EMPTY
9489: LIST
9490: LIST
9491: LIST
9492: LIST
9493: PPUSH
9494: LD_EXP 21
9498: PUSH
9499: LD_INT 2
9501: ARRAY
9502: PPUSH
9503: LD_EXP 21
9507: PUSH
9508: LD_INT 1
9510: ARRAY
9511: PPUSH
9512: CALL 9517 0 3
9516: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9517: LD_INT 0
9519: PPUSH
9520: PPUSH
9521: PPUSH
9522: PPUSH
// if not areas then
9523: LD_VAR 0 1
9527: NOT
9528: IFFALSE 9532
// exit ;
9530: GO 9807
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9532: LD_ADDR_VAR 0 7
9536: PUSH
9537: LD_INT 31
9539: PUSH
9540: LD_INT 32
9542: PUSH
9543: LD_INT 30
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: ST_TO_ADDR
// repeat wait ( time ) ;
9551: LD_VAR 0 2
9555: PPUSH
9556: CALL_OW 67
// x := 5 ;
9560: LD_ADDR_VAR 0 6
9564: PUSH
9565: LD_INT 5
9567: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9568: LD_OWVAR 1
9572: PUSH
9573: LD_INT 42000
9575: PUSH
9576: LD_INT 37800
9578: PUSH
9579: LD_INT 29400
9581: PUSH
9582: EMPTY
9583: LIST
9584: LIST
9585: LIST
9586: PUSH
9587: LD_OWVAR 67
9591: ARRAY
9592: LESS
9593: IFFALSE 9665
// begin for i = 1 to multi_sides do
9595: LD_ADDR_VAR 0 5
9599: PUSH
9600: DOUBLE
9601: LD_INT 1
9603: DEC
9604: ST_TO_ADDR
9605: LD_EXP 7
9609: PUSH
9610: FOR_TO
9611: IFFALSE 9656
// if multi_sides [ i ] then
9613: LD_EXP 7
9617: PUSH
9618: LD_VAR 0 5
9622: ARRAY
9623: IFFALSE 9654
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9625: LD_VAR 0 6
9629: PPUSH
9630: LD_VAR 0 7
9634: PUSH
9635: LD_EXP 7
9639: PUSH
9640: LD_VAR 0 5
9644: ARRAY
9645: ARRAY
9646: PPUSH
9647: LD_INT 1
9649: PPUSH
9650: CALL_OW 55
9654: GO 9610
9656: POP
9657: POP
// wait ( 0 0$6 ) ;
9658: LD_INT 210
9660: PPUSH
9661: CALL_OW 67
// end ; for i in areas do
9665: LD_ADDR_VAR 0 5
9669: PUSH
9670: LD_VAR 0 1
9674: PUSH
9675: FOR_IN
9676: IFFALSE 9704
// begin wait ( 0 0$6 ) ;
9678: LD_INT 210
9680: PPUSH
9681: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9685: LD_VAR 0 6
9689: PPUSH
9690: LD_VAR 0 5
9694: PPUSH
9695: LD_INT 1
9697: PPUSH
9698: CALL_OW 55
// end ;
9702: GO 9675
9704: POP
9705: POP
// time := time + 0 0$2 ;
9706: LD_ADDR_VAR 0 2
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 70
9718: PLUS
9719: ST_TO_ADDR
// amount := amount - x * 10 ;
9720: LD_ADDR_VAR 0 3
9724: PUSH
9725: LD_VAR 0 3
9729: PUSH
9730: LD_VAR 0 6
9734: PUSH
9735: LD_INT 10
9737: MUL
9738: MINUS
9739: ST_TO_ADDR
// x := x - 1 ;
9740: LD_ADDR_VAR 0 6
9744: PUSH
9745: LD_VAR 0 6
9749: PUSH
9750: LD_INT 1
9752: MINUS
9753: ST_TO_ADDR
// if x = 0 then
9754: LD_VAR 0 6
9758: PUSH
9759: LD_INT 0
9761: EQUAL
9762: IFFALSE 9772
// x := 5 ;
9764: LD_ADDR_VAR 0 6
9768: PUSH
9769: LD_INT 5
9771: ST_TO_ADDR
// if time > 4 4$00 then
9772: LD_VAR 0 2
9776: PUSH
9777: LD_INT 8400
9779: GREATER
9780: IFFALSE 9790
// time := 0 0$40 ;
9782: LD_ADDR_VAR 0 2
9786: PUSH
9787: LD_INT 1400
9789: ST_TO_ADDR
// until not game or amount <= 0 ;
9790: LD_EXP 2
9794: NOT
9795: PUSH
9796: LD_VAR 0 3
9800: PUSH
9801: LD_INT 0
9803: LESSEQUAL
9804: OR
9805: IFFALSE 9551
// end ; end_of_file
9807: LD_VAR 0 4
9811: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9812: LD_INT 0
9814: PPUSH
9815: PPUSH
// if exist_mode then
9816: LD_VAR 0 2
9820: IFFALSE 9845
// unit := CreateCharacter ( prefix & ident ) else
9822: LD_ADDR_VAR 0 5
9826: PUSH
9827: LD_VAR 0 3
9831: PUSH
9832: LD_VAR 0 1
9836: STR
9837: PPUSH
9838: CALL_OW 34
9842: ST_TO_ADDR
9843: GO 9860
// unit := NewCharacter ( ident ) ;
9845: LD_ADDR_VAR 0 5
9849: PUSH
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 25
9859: ST_TO_ADDR
// result := unit ;
9860: LD_ADDR_VAR 0 4
9864: PUSH
9865: LD_VAR 0 5
9869: ST_TO_ADDR
// end ;
9870: LD_VAR 0 4
9874: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9875: LD_INT 0
9877: PPUSH
9878: PPUSH
// if not side or not nation then
9879: LD_VAR 0 1
9883: NOT
9884: PUSH
9885: LD_VAR 0 2
9889: NOT
9890: OR
9891: IFFALSE 9895
// exit ;
9893: GO 10663
// case nation of nation_american :
9895: LD_VAR 0 2
9899: PUSH
9900: LD_INT 1
9902: DOUBLE
9903: EQUAL
9904: IFTRUE 9908
9906: GO 10122
9908: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9909: LD_ADDR_VAR 0 4
9913: PUSH
9914: LD_INT 35
9916: PUSH
9917: LD_INT 45
9919: PUSH
9920: LD_INT 46
9922: PUSH
9923: LD_INT 47
9925: PUSH
9926: LD_INT 82
9928: PUSH
9929: LD_INT 83
9931: PUSH
9932: LD_INT 84
9934: PUSH
9935: LD_INT 85
9937: PUSH
9938: LD_INT 86
9940: PUSH
9941: LD_INT 1
9943: PUSH
9944: LD_INT 2
9946: PUSH
9947: LD_INT 6
9949: PUSH
9950: LD_INT 15
9952: PUSH
9953: LD_INT 16
9955: PUSH
9956: LD_INT 7
9958: PUSH
9959: LD_INT 12
9961: PUSH
9962: LD_INT 13
9964: PUSH
9965: LD_INT 10
9967: PUSH
9968: LD_INT 14
9970: PUSH
9971: LD_INT 20
9973: PUSH
9974: LD_INT 21
9976: PUSH
9977: LD_INT 22
9979: PUSH
9980: LD_INT 25
9982: PUSH
9983: LD_INT 32
9985: PUSH
9986: LD_INT 27
9988: PUSH
9989: LD_INT 36
9991: PUSH
9992: LD_INT 69
9994: PUSH
9995: LD_INT 39
9997: PUSH
9998: LD_INT 34
10000: PUSH
10001: LD_INT 40
10003: PUSH
10004: LD_INT 48
10006: PUSH
10007: LD_INT 49
10009: PUSH
10010: LD_INT 50
10012: PUSH
10013: LD_INT 51
10015: PUSH
10016: LD_INT 52
10018: PUSH
10019: LD_INT 53
10021: PUSH
10022: LD_INT 54
10024: PUSH
10025: LD_INT 55
10027: PUSH
10028: LD_INT 56
10030: PUSH
10031: LD_INT 57
10033: PUSH
10034: LD_INT 58
10036: PUSH
10037: LD_INT 59
10039: PUSH
10040: LD_INT 60
10042: PUSH
10043: LD_INT 61
10045: PUSH
10046: LD_INT 62
10048: PUSH
10049: LD_INT 80
10051: PUSH
10052: LD_INT 82
10054: PUSH
10055: LD_INT 83
10057: PUSH
10058: LD_INT 84
10060: PUSH
10061: LD_INT 85
10063: PUSH
10064: LD_INT 86
10066: PUSH
10067: EMPTY
10068: LIST
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: ST_TO_ADDR
10120: GO 10587
10122: LD_INT 2
10124: DOUBLE
10125: EQUAL
10126: IFTRUE 10130
10128: GO 10356
10130: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10131: LD_ADDR_VAR 0 4
10135: PUSH
10136: LD_INT 35
10138: PUSH
10139: LD_INT 45
10141: PUSH
10142: LD_INT 46
10144: PUSH
10145: LD_INT 47
10147: PUSH
10148: LD_INT 82
10150: PUSH
10151: LD_INT 83
10153: PUSH
10154: LD_INT 84
10156: PUSH
10157: LD_INT 85
10159: PUSH
10160: LD_INT 87
10162: PUSH
10163: LD_INT 70
10165: PUSH
10166: LD_INT 1
10168: PUSH
10169: LD_INT 11
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 4
10177: PUSH
10178: LD_INT 5
10180: PUSH
10181: LD_INT 6
10183: PUSH
10184: LD_INT 15
10186: PUSH
10187: LD_INT 18
10189: PUSH
10190: LD_INT 7
10192: PUSH
10193: LD_INT 17
10195: PUSH
10196: LD_INT 8
10198: PUSH
10199: LD_INT 20
10201: PUSH
10202: LD_INT 21
10204: PUSH
10205: LD_INT 22
10207: PUSH
10208: LD_INT 72
10210: PUSH
10211: LD_INT 26
10213: PUSH
10214: LD_INT 69
10216: PUSH
10217: LD_INT 39
10219: PUSH
10220: LD_INT 40
10222: PUSH
10223: LD_INT 41
10225: PUSH
10226: LD_INT 42
10228: PUSH
10229: LD_INT 43
10231: PUSH
10232: LD_INT 48
10234: PUSH
10235: LD_INT 49
10237: PUSH
10238: LD_INT 50
10240: PUSH
10241: LD_INT 51
10243: PUSH
10244: LD_INT 52
10246: PUSH
10247: LD_INT 53
10249: PUSH
10250: LD_INT 54
10252: PUSH
10253: LD_INT 55
10255: PUSH
10256: LD_INT 56
10258: PUSH
10259: LD_INT 60
10261: PUSH
10262: LD_INT 61
10264: PUSH
10265: LD_INT 62
10267: PUSH
10268: LD_INT 66
10270: PUSH
10271: LD_INT 67
10273: PUSH
10274: LD_INT 68
10276: PUSH
10277: LD_INT 81
10279: PUSH
10280: LD_INT 82
10282: PUSH
10283: LD_INT 83
10285: PUSH
10286: LD_INT 84
10288: PUSH
10289: LD_INT 85
10291: PUSH
10292: LD_INT 87
10294: PUSH
10295: LD_INT 88
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: LIST
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: ST_TO_ADDR
10354: GO 10587
10356: LD_INT 3
10358: DOUBLE
10359: EQUAL
10360: IFTRUE 10364
10362: GO 10586
10364: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10365: LD_ADDR_VAR 0 4
10369: PUSH
10370: LD_INT 46
10372: PUSH
10373: LD_INT 47
10375: PUSH
10376: LD_INT 1
10378: PUSH
10379: LD_INT 2
10381: PUSH
10382: LD_INT 82
10384: PUSH
10385: LD_INT 83
10387: PUSH
10388: LD_INT 84
10390: PUSH
10391: LD_INT 85
10393: PUSH
10394: LD_INT 86
10396: PUSH
10397: LD_INT 11
10399: PUSH
10400: LD_INT 9
10402: PUSH
10403: LD_INT 20
10405: PUSH
10406: LD_INT 19
10408: PUSH
10409: LD_INT 21
10411: PUSH
10412: LD_INT 24
10414: PUSH
10415: LD_INT 22
10417: PUSH
10418: LD_INT 25
10420: PUSH
10421: LD_INT 28
10423: PUSH
10424: LD_INT 29
10426: PUSH
10427: LD_INT 30
10429: PUSH
10430: LD_INT 31
10432: PUSH
10433: LD_INT 37
10435: PUSH
10436: LD_INT 38
10438: PUSH
10439: LD_INT 32
10441: PUSH
10442: LD_INT 27
10444: PUSH
10445: LD_INT 33
10447: PUSH
10448: LD_INT 69
10450: PUSH
10451: LD_INT 39
10453: PUSH
10454: LD_INT 34
10456: PUSH
10457: LD_INT 40
10459: PUSH
10460: LD_INT 71
10462: PUSH
10463: LD_INT 23
10465: PUSH
10466: LD_INT 44
10468: PUSH
10469: LD_INT 48
10471: PUSH
10472: LD_INT 49
10474: PUSH
10475: LD_INT 50
10477: PUSH
10478: LD_INT 51
10480: PUSH
10481: LD_INT 52
10483: PUSH
10484: LD_INT 53
10486: PUSH
10487: LD_INT 54
10489: PUSH
10490: LD_INT 55
10492: PUSH
10493: LD_INT 56
10495: PUSH
10496: LD_INT 57
10498: PUSH
10499: LD_INT 58
10501: PUSH
10502: LD_INT 59
10504: PUSH
10505: LD_INT 63
10507: PUSH
10508: LD_INT 64
10510: PUSH
10511: LD_INT 65
10513: PUSH
10514: LD_INT 82
10516: PUSH
10517: LD_INT 83
10519: PUSH
10520: LD_INT 84
10522: PUSH
10523: LD_INT 85
10525: PUSH
10526: LD_INT 86
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: LIST
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: ST_TO_ADDR
10584: GO 10587
10586: POP
// if state > - 1 and state < 3 then
10587: LD_VAR 0 3
10591: PUSH
10592: LD_INT 1
10594: NEG
10595: GREATER
10596: PUSH
10597: LD_VAR 0 3
10601: PUSH
10602: LD_INT 3
10604: LESS
10605: AND
10606: IFFALSE 10663
// for i in result do
10608: LD_ADDR_VAR 0 5
10612: PUSH
10613: LD_VAR 0 4
10617: PUSH
10618: FOR_IN
10619: IFFALSE 10661
// if GetTech ( i , side ) <> state then
10621: LD_VAR 0 5
10625: PPUSH
10626: LD_VAR 0 1
10630: PPUSH
10631: CALL_OW 321
10635: PUSH
10636: LD_VAR 0 3
10640: NONEQUAL
10641: IFFALSE 10659
// result := result diff i ;
10643: LD_ADDR_VAR 0 4
10647: PUSH
10648: LD_VAR 0 4
10652: PUSH
10653: LD_VAR 0 5
10657: DIFF
10658: ST_TO_ADDR
10659: GO 10618
10661: POP
10662: POP
// end ;
10663: LD_VAR 0 4
10667: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10668: LD_INT 0
10670: PPUSH
10671: PPUSH
10672: PPUSH
// result := true ;
10673: LD_ADDR_VAR 0 3
10677: PUSH
10678: LD_INT 1
10680: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10681: LD_ADDR_VAR 0 5
10685: PUSH
10686: LD_VAR 0 2
10690: PPUSH
10691: CALL_OW 480
10695: ST_TO_ADDR
// if not tmp then
10696: LD_VAR 0 5
10700: NOT
10701: IFFALSE 10705
// exit ;
10703: GO 10754
// for i in tmp do
10705: LD_ADDR_VAR 0 4
10709: PUSH
10710: LD_VAR 0 5
10714: PUSH
10715: FOR_IN
10716: IFFALSE 10752
// if GetTech ( i , side ) <> state_researched then
10718: LD_VAR 0 4
10722: PPUSH
10723: LD_VAR 0 1
10727: PPUSH
10728: CALL_OW 321
10732: PUSH
10733: LD_INT 2
10735: NONEQUAL
10736: IFFALSE 10750
// begin result := false ;
10738: LD_ADDR_VAR 0 3
10742: PUSH
10743: LD_INT 0
10745: ST_TO_ADDR
// exit ;
10746: POP
10747: POP
10748: GO 10754
// end ;
10750: GO 10715
10752: POP
10753: POP
// end ;
10754: LD_VAR 0 3
10758: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10759: LD_INT 0
10761: PPUSH
10762: PPUSH
10763: PPUSH
10764: PPUSH
10765: PPUSH
10766: PPUSH
10767: PPUSH
10768: PPUSH
10769: PPUSH
10770: PPUSH
10771: PPUSH
10772: PPUSH
10773: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10774: LD_VAR 0 1
10778: NOT
10779: PUSH
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 257
10789: PUSH
10790: LD_INT 9
10792: NONEQUAL
10793: OR
10794: IFFALSE 10798
// exit ;
10796: GO 11371
// side := GetSide ( unit ) ;
10798: LD_ADDR_VAR 0 9
10802: PUSH
10803: LD_VAR 0 1
10807: PPUSH
10808: CALL_OW 255
10812: ST_TO_ADDR
// tech_space := tech_spacanom ;
10813: LD_ADDR_VAR 0 12
10817: PUSH
10818: LD_INT 29
10820: ST_TO_ADDR
// tech_time := tech_taurad ;
10821: LD_ADDR_VAR 0 13
10825: PUSH
10826: LD_INT 28
10828: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10829: LD_ADDR_VAR 0 11
10833: PUSH
10834: LD_VAR 0 1
10838: PPUSH
10839: CALL_OW 310
10843: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10844: LD_VAR 0 11
10848: PPUSH
10849: CALL_OW 247
10853: PUSH
10854: LD_INT 2
10856: EQUAL
10857: IFFALSE 10861
// exit ;
10859: GO 11371
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10861: LD_ADDR_VAR 0 8
10865: PUSH
10866: LD_INT 81
10868: PUSH
10869: LD_VAR 0 9
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PUSH
10878: LD_INT 3
10880: PUSH
10881: LD_INT 21
10883: PUSH
10884: LD_INT 3
10886: PUSH
10887: EMPTY
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: PPUSH
10899: CALL_OW 69
10903: ST_TO_ADDR
// if not tmp then
10904: LD_VAR 0 8
10908: NOT
10909: IFFALSE 10913
// exit ;
10911: GO 11371
// if in_unit then
10913: LD_VAR 0 11
10917: IFFALSE 10941
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10919: LD_ADDR_VAR 0 10
10923: PUSH
10924: LD_VAR 0 8
10928: PPUSH
10929: LD_VAR 0 11
10933: PPUSH
10934: CALL_OW 74
10938: ST_TO_ADDR
10939: GO 10961
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10941: LD_ADDR_VAR 0 10
10945: PUSH
10946: LD_VAR 0 8
10950: PPUSH
10951: LD_VAR 0 1
10955: PPUSH
10956: CALL_OW 74
10960: ST_TO_ADDR
// if not enemy then
10961: LD_VAR 0 10
10965: NOT
10966: IFFALSE 10970
// exit ;
10968: GO 11371
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
10970: LD_VAR 0 11
10974: PUSH
10975: LD_VAR 0 11
10979: PPUSH
10980: LD_VAR 0 10
10984: PPUSH
10985: CALL_OW 296
10989: PUSH
10990: LD_INT 13
10992: GREATER
10993: AND
10994: PUSH
10995: LD_VAR 0 1
10999: PPUSH
11000: LD_VAR 0 10
11004: PPUSH
11005: CALL_OW 296
11009: PUSH
11010: LD_INT 12
11012: GREATER
11013: OR
11014: IFFALSE 11018
// exit ;
11016: GO 11371
// missile := [ 1 ] ;
11018: LD_ADDR_VAR 0 14
11022: PUSH
11023: LD_INT 1
11025: PUSH
11026: EMPTY
11027: LIST
11028: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11029: LD_VAR 0 9
11033: PPUSH
11034: LD_VAR 0 12
11038: PPUSH
11039: CALL_OW 325
11043: IFFALSE 11072
// missile := Replace ( missile , missile + 1 , 2 ) ;
11045: LD_ADDR_VAR 0 14
11049: PUSH
11050: LD_VAR 0 14
11054: PPUSH
11055: LD_VAR 0 14
11059: PUSH
11060: LD_INT 1
11062: PLUS
11063: PPUSH
11064: LD_INT 2
11066: PPUSH
11067: CALL_OW 1
11071: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11072: LD_VAR 0 9
11076: PPUSH
11077: LD_VAR 0 13
11081: PPUSH
11082: CALL_OW 325
11086: PUSH
11087: LD_VAR 0 10
11091: PPUSH
11092: CALL_OW 255
11096: PPUSH
11097: LD_VAR 0 13
11101: PPUSH
11102: CALL_OW 325
11106: NOT
11107: AND
11108: IFFALSE 11137
// missile := Replace ( missile , missile + 1 , 3 ) ;
11110: LD_ADDR_VAR 0 14
11114: PUSH
11115: LD_VAR 0 14
11119: PPUSH
11120: LD_VAR 0 14
11124: PUSH
11125: LD_INT 1
11127: PLUS
11128: PPUSH
11129: LD_INT 3
11131: PPUSH
11132: CALL_OW 1
11136: ST_TO_ADDR
// if missile < 2 then
11137: LD_VAR 0 14
11141: PUSH
11142: LD_INT 2
11144: LESS
11145: IFFALSE 11149
// exit ;
11147: GO 11371
// x := GetX ( enemy ) ;
11149: LD_ADDR_VAR 0 4
11153: PUSH
11154: LD_VAR 0 10
11158: PPUSH
11159: CALL_OW 250
11163: ST_TO_ADDR
// y := GetY ( enemy ) ;
11164: LD_ADDR_VAR 0 5
11168: PUSH
11169: LD_VAR 0 10
11173: PPUSH
11174: CALL_OW 251
11178: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11179: LD_ADDR_VAR 0 6
11183: PUSH
11184: LD_VAR 0 4
11188: PUSH
11189: LD_INT 1
11191: NEG
11192: PPUSH
11193: LD_INT 1
11195: PPUSH
11196: CALL_OW 12
11200: PLUS
11201: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11202: LD_ADDR_VAR 0 7
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: LD_INT 1
11214: NEG
11215: PPUSH
11216: LD_INT 1
11218: PPUSH
11219: CALL_OW 12
11223: PLUS
11224: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11225: LD_VAR 0 6
11229: PPUSH
11230: LD_VAR 0 7
11234: PPUSH
11235: CALL_OW 488
11239: NOT
11240: IFFALSE 11262
// begin _x := x ;
11242: LD_ADDR_VAR 0 6
11246: PUSH
11247: LD_VAR 0 4
11251: ST_TO_ADDR
// _y := y ;
11252: LD_ADDR_VAR 0 7
11256: PUSH
11257: LD_VAR 0 5
11261: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11262: LD_ADDR_VAR 0 3
11266: PUSH
11267: LD_INT 1
11269: PPUSH
11270: LD_VAR 0 14
11274: PPUSH
11275: CALL_OW 12
11279: ST_TO_ADDR
// case i of 1 :
11280: LD_VAR 0 3
11284: PUSH
11285: LD_INT 1
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11310
11293: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11294: LD_VAR 0 1
11298: PPUSH
11299: LD_VAR 0 10
11303: PPUSH
11304: CALL_OW 115
11308: GO 11371
11310: LD_INT 2
11312: DOUBLE
11313: EQUAL
11314: IFTRUE 11318
11316: GO 11340
11318: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11319: LD_VAR 0 1
11323: PPUSH
11324: LD_VAR 0 6
11328: PPUSH
11329: LD_VAR 0 7
11333: PPUSH
11334: CALL_OW 153
11338: GO 11371
11340: LD_INT 3
11342: DOUBLE
11343: EQUAL
11344: IFTRUE 11348
11346: GO 11370
11348: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11349: LD_VAR 0 1
11353: PPUSH
11354: LD_VAR 0 6
11358: PPUSH
11359: LD_VAR 0 7
11363: PPUSH
11364: CALL_OW 154
11368: GO 11371
11370: POP
// end ;
11371: LD_VAR 0 2
11375: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11376: LD_INT 0
11378: PPUSH
11379: PPUSH
11380: PPUSH
11381: PPUSH
11382: PPUSH
11383: PPUSH
// if not unit or not building then
11384: LD_VAR 0 1
11388: NOT
11389: PUSH
11390: LD_VAR 0 2
11394: NOT
11395: OR
11396: IFFALSE 11400
// exit ;
11398: GO 11558
// x := GetX ( building ) ;
11400: LD_ADDR_VAR 0 5
11404: PUSH
11405: LD_VAR 0 2
11409: PPUSH
11410: CALL_OW 250
11414: ST_TO_ADDR
// y := GetY ( building ) ;
11415: LD_ADDR_VAR 0 6
11419: PUSH
11420: LD_VAR 0 2
11424: PPUSH
11425: CALL_OW 251
11429: ST_TO_ADDR
// for i = 0 to 5 do
11430: LD_ADDR_VAR 0 4
11434: PUSH
11435: DOUBLE
11436: LD_INT 0
11438: DEC
11439: ST_TO_ADDR
11440: LD_INT 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11556
// begin _x := ShiftX ( x , i , 3 ) ;
11446: LD_ADDR_VAR 0 7
11450: PUSH
11451: LD_VAR 0 5
11455: PPUSH
11456: LD_VAR 0 4
11460: PPUSH
11461: LD_INT 3
11463: PPUSH
11464: CALL_OW 272
11468: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11469: LD_ADDR_VAR 0 8
11473: PUSH
11474: LD_VAR 0 6
11478: PPUSH
11479: LD_VAR 0 4
11483: PPUSH
11484: LD_INT 3
11486: PPUSH
11487: CALL_OW 273
11491: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11492: LD_VAR 0 7
11496: PPUSH
11497: LD_VAR 0 8
11501: PPUSH
11502: CALL_OW 488
11506: NOT
11507: IFFALSE 11511
// continue ;
11509: GO 11443
// if HexInfo ( _x , _y ) = 0 then
11511: LD_VAR 0 7
11515: PPUSH
11516: LD_VAR 0 8
11520: PPUSH
11521: CALL_OW 428
11525: PUSH
11526: LD_INT 0
11528: EQUAL
11529: IFFALSE 11554
// begin ComMoveXY ( unit , _x , _y ) ;
11531: LD_VAR 0 1
11535: PPUSH
11536: LD_VAR 0 7
11540: PPUSH
11541: LD_VAR 0 8
11545: PPUSH
11546: CALL_OW 111
// exit ;
11550: POP
11551: POP
11552: GO 11558
// end ; end ;
11554: GO 11443
11556: POP
11557: POP
// end ;
11558: LD_VAR 0 3
11562: RET
// export function ScanBase ( side , base_area ) ; begin
11563: LD_INT 0
11565: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11566: LD_ADDR_VAR 0 3
11570: PUSH
11571: LD_VAR 0 2
11575: PPUSH
11576: LD_INT 81
11578: PUSH
11579: LD_VAR 0 1
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PPUSH
11588: CALL_OW 70
11592: ST_TO_ADDR
// end ;
11593: LD_VAR 0 3
11597: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11598: LD_INT 0
11600: PPUSH
11601: PPUSH
11602: PPUSH
11603: PPUSH
// result := false ;
11604: LD_ADDR_VAR 0 2
11608: PUSH
11609: LD_INT 0
11611: ST_TO_ADDR
// side := GetSide ( unit ) ;
11612: LD_ADDR_VAR 0 3
11616: PUSH
11617: LD_VAR 0 1
11621: PPUSH
11622: CALL_OW 255
11626: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11627: LD_ADDR_VAR 0 4
11631: PUSH
11632: LD_VAR 0 1
11636: PPUSH
11637: CALL_OW 248
11641: ST_TO_ADDR
// case nat of 1 :
11642: LD_VAR 0 4
11646: PUSH
11647: LD_INT 1
11649: DOUBLE
11650: EQUAL
11651: IFTRUE 11655
11653: GO 11666
11655: POP
// tech := tech_lassight ; 2 :
11656: LD_ADDR_VAR 0 5
11660: PUSH
11661: LD_INT 12
11663: ST_TO_ADDR
11664: GO 11705
11666: LD_INT 2
11668: DOUBLE
11669: EQUAL
11670: IFTRUE 11674
11672: GO 11685
11674: POP
// tech := tech_mortar ; 3 :
11675: LD_ADDR_VAR 0 5
11679: PUSH
11680: LD_INT 41
11682: ST_TO_ADDR
11683: GO 11705
11685: LD_INT 3
11687: DOUBLE
11688: EQUAL
11689: IFTRUE 11693
11691: GO 11704
11693: POP
// tech := tech_bazooka ; end ;
11694: LD_ADDR_VAR 0 5
11698: PUSH
11699: LD_INT 44
11701: ST_TO_ADDR
11702: GO 11705
11704: POP
// if Researched ( side , tech ) then
11705: LD_VAR 0 3
11709: PPUSH
11710: LD_VAR 0 5
11714: PPUSH
11715: CALL_OW 325
11719: IFFALSE 11746
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11721: LD_ADDR_VAR 0 2
11725: PUSH
11726: LD_INT 5
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: LD_INT 9
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: LIST
11739: PUSH
11740: LD_VAR 0 4
11744: ARRAY
11745: ST_TO_ADDR
// end ;
11746: LD_VAR 0 2
11750: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11751: LD_INT 0
11753: PPUSH
11754: PPUSH
11755: PPUSH
// if not mines then
11756: LD_VAR 0 2
11760: NOT
11761: IFFALSE 11765
// exit ;
11763: GO 11909
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11765: LD_ADDR_VAR 0 5
11769: PUSH
11770: LD_INT 81
11772: PUSH
11773: LD_VAR 0 1
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_INT 3
11784: PUSH
11785: LD_INT 21
11787: PUSH
11788: LD_INT 3
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: PPUSH
11803: CALL_OW 69
11807: ST_TO_ADDR
// for i in mines do
11808: LD_ADDR_VAR 0 4
11812: PUSH
11813: LD_VAR 0 2
11817: PUSH
11818: FOR_IN
11819: IFFALSE 11907
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11821: LD_VAR 0 4
11825: PUSH
11826: LD_INT 1
11828: ARRAY
11829: PPUSH
11830: LD_VAR 0 4
11834: PUSH
11835: LD_INT 2
11837: ARRAY
11838: PPUSH
11839: CALL_OW 458
11843: NOT
11844: IFFALSE 11848
// continue ;
11846: GO 11818
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11848: LD_VAR 0 4
11852: PUSH
11853: LD_INT 1
11855: ARRAY
11856: PPUSH
11857: LD_VAR 0 4
11861: PUSH
11862: LD_INT 2
11864: ARRAY
11865: PPUSH
11866: CALL_OW 428
11870: PUSH
11871: LD_VAR 0 5
11875: IN
11876: IFFALSE 11905
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11878: LD_VAR 0 4
11882: PUSH
11883: LD_INT 1
11885: ARRAY
11886: PPUSH
11887: LD_VAR 0 4
11891: PUSH
11892: LD_INT 2
11894: ARRAY
11895: PPUSH
11896: LD_VAR 0 1
11900: PPUSH
11901: CALL_OW 456
// end ;
11905: GO 11818
11907: POP
11908: POP
// end ;
11909: LD_VAR 0 3
11913: RET
// export function Count ( array ) ; begin
11914: LD_INT 0
11916: PPUSH
// result := array + 0 ;
11917: LD_ADDR_VAR 0 2
11921: PUSH
11922: LD_VAR 0 1
11926: PUSH
11927: LD_INT 0
11929: PLUS
11930: ST_TO_ADDR
// end ;
11931: LD_VAR 0 2
11935: RET
// export function IsEmpty ( building ) ; begin
11936: LD_INT 0
11938: PPUSH
// if not building then
11939: LD_VAR 0 1
11943: NOT
11944: IFFALSE 11948
// exit ;
11946: GO 11991
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 1
11957: PUSH
11958: LD_INT 22
11960: PUSH
11961: LD_VAR 0 1
11965: PPUSH
11966: CALL_OW 255
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PUSH
11975: LD_INT 58
11977: PUSH
11978: EMPTY
11979: LIST
11980: PUSH
11981: EMPTY
11982: LIST
11983: LIST
11984: PPUSH
11985: CALL_OW 69
11989: IN
11990: ST_TO_ADDR
// end ;
11991: LD_VAR 0 2
11995: RET
// export function IsNotFull ( building ) ; var places ; begin
11996: LD_INT 0
11998: PPUSH
11999: PPUSH
// if not building then
12000: LD_VAR 0 1
12004: NOT
12005: IFFALSE 12009
// exit ;
12007: GO 12037
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
12009: LD_ADDR_VAR 0 2
12013: PUSH
12014: LD_VAR 0 1
12018: PPUSH
12019: LD_INT 3
12021: PUSH
12022: LD_INT 62
12024: PUSH
12025: EMPTY
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 72
12036: ST_TO_ADDR
// end ;
12037: LD_VAR 0 2
12041: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12042: LD_INT 0
12044: PPUSH
12045: PPUSH
12046: PPUSH
12047: PPUSH
// tmp := [ ] ;
12048: LD_ADDR_VAR 0 3
12052: PUSH
12053: EMPTY
12054: ST_TO_ADDR
// list := [ ] ;
12055: LD_ADDR_VAR 0 5
12059: PUSH
12060: EMPTY
12061: ST_TO_ADDR
// for i = 16 to 25 do
12062: LD_ADDR_VAR 0 4
12066: PUSH
12067: DOUBLE
12068: LD_INT 16
12070: DEC
12071: ST_TO_ADDR
12072: LD_INT 25
12074: PUSH
12075: FOR_TO
12076: IFFALSE 12149
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12078: LD_ADDR_VAR 0 3
12082: PUSH
12083: LD_VAR 0 3
12087: PUSH
12088: LD_INT 22
12090: PUSH
12091: LD_VAR 0 1
12095: PPUSH
12096: CALL_OW 255
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: LD_INT 91
12107: PUSH
12108: LD_VAR 0 1
12112: PUSH
12113: LD_INT 6
12115: PUSH
12116: EMPTY
12117: LIST
12118: LIST
12119: LIST
12120: PUSH
12121: LD_INT 30
12123: PUSH
12124: LD_VAR 0 4
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: PUSH
12138: EMPTY
12139: LIST
12140: PPUSH
12141: CALL_OW 69
12145: ADD
12146: ST_TO_ADDR
12147: GO 12075
12149: POP
12150: POP
// for i = 1 to tmp do
12151: LD_ADDR_VAR 0 4
12155: PUSH
12156: DOUBLE
12157: LD_INT 1
12159: DEC
12160: ST_TO_ADDR
12161: LD_VAR 0 3
12165: PUSH
12166: FOR_TO
12167: IFFALSE 12255
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12169: LD_ADDR_VAR 0 5
12173: PUSH
12174: LD_VAR 0 5
12178: PUSH
12179: LD_VAR 0 3
12183: PUSH
12184: LD_VAR 0 4
12188: ARRAY
12189: PPUSH
12190: CALL_OW 266
12194: PUSH
12195: LD_VAR 0 3
12199: PUSH
12200: LD_VAR 0 4
12204: ARRAY
12205: PPUSH
12206: CALL_OW 250
12210: PUSH
12211: LD_VAR 0 3
12215: PUSH
12216: LD_VAR 0 4
12220: ARRAY
12221: PPUSH
12222: CALL_OW 251
12226: PUSH
12227: LD_VAR 0 3
12231: PUSH
12232: LD_VAR 0 4
12236: ARRAY
12237: PPUSH
12238: CALL_OW 254
12242: PUSH
12243: EMPTY
12244: LIST
12245: LIST
12246: LIST
12247: LIST
12248: PUSH
12249: EMPTY
12250: LIST
12251: ADD
12252: ST_TO_ADDR
12253: GO 12166
12255: POP
12256: POP
// result := list ;
12257: LD_ADDR_VAR 0 2
12261: PUSH
12262: LD_VAR 0 5
12266: ST_TO_ADDR
// end ;
12267: LD_VAR 0 2
12271: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12272: LD_INT 0
12274: PPUSH
12275: PPUSH
12276: PPUSH
12277: PPUSH
12278: PPUSH
12279: PPUSH
12280: PPUSH
// if not factory then
12281: LD_VAR 0 1
12285: NOT
12286: IFFALSE 12290
// exit ;
12288: GO 12883
// if control = control_apeman then
12290: LD_VAR 0 4
12294: PUSH
12295: LD_INT 5
12297: EQUAL
12298: IFFALSE 12407
// begin tmp := UnitsInside ( factory ) ;
12300: LD_ADDR_VAR 0 8
12304: PUSH
12305: LD_VAR 0 1
12309: PPUSH
12310: CALL_OW 313
12314: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12315: LD_VAR 0 8
12319: PPUSH
12320: LD_INT 25
12322: PUSH
12323: LD_INT 12
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PPUSH
12330: CALL_OW 72
12334: NOT
12335: IFFALSE 12345
// control := control_manual ;
12337: LD_ADDR_VAR 0 4
12341: PUSH
12342: LD_INT 1
12344: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12345: LD_ADDR_VAR 0 8
12349: PUSH
12350: LD_VAR 0 1
12354: PPUSH
12355: CALL 12042 0 1
12359: ST_TO_ADDR
// if tmp then
12360: LD_VAR 0 8
12364: IFFALSE 12407
// begin for i in tmp do
12366: LD_ADDR_VAR 0 7
12370: PUSH
12371: LD_VAR 0 8
12375: PUSH
12376: FOR_IN
12377: IFFALSE 12405
// if i [ 1 ] = b_ext_radio then
12379: LD_VAR 0 7
12383: PUSH
12384: LD_INT 1
12386: ARRAY
12387: PUSH
12388: LD_INT 22
12390: EQUAL
12391: IFFALSE 12403
// begin control := control_remote ;
12393: LD_ADDR_VAR 0 4
12397: PUSH
12398: LD_INT 2
12400: ST_TO_ADDR
// break ;
12401: GO 12405
// end ;
12403: GO 12376
12405: POP
12406: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12407: LD_VAR 0 1
12411: PPUSH
12412: LD_VAR 0 2
12416: PPUSH
12417: LD_VAR 0 3
12421: PPUSH
12422: LD_VAR 0 4
12426: PPUSH
12427: LD_VAR 0 5
12431: PPUSH
12432: CALL_OW 448
12436: IFFALSE 12471
// begin result := [ chassis , engine , control , weapon ] ;
12438: LD_ADDR_VAR 0 6
12442: PUSH
12443: LD_VAR 0 2
12447: PUSH
12448: LD_VAR 0 3
12452: PUSH
12453: LD_VAR 0 4
12457: PUSH
12458: LD_VAR 0 5
12462: PUSH
12463: EMPTY
12464: LIST
12465: LIST
12466: LIST
12467: LIST
12468: ST_TO_ADDR
// exit ;
12469: GO 12883
// end ; _chassis := AvailableChassisList ( factory ) ;
12471: LD_ADDR_VAR 0 9
12475: PUSH
12476: LD_VAR 0 1
12480: PPUSH
12481: CALL_OW 475
12485: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12486: LD_ADDR_VAR 0 11
12490: PUSH
12491: LD_VAR 0 1
12495: PPUSH
12496: CALL_OW 476
12500: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12501: LD_ADDR_VAR 0 12
12505: PUSH
12506: LD_VAR 0 1
12510: PPUSH
12511: CALL_OW 477
12515: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12516: LD_ADDR_VAR 0 10
12520: PUSH
12521: LD_VAR 0 1
12525: PPUSH
12526: CALL_OW 478
12530: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12531: LD_VAR 0 9
12535: NOT
12536: PUSH
12537: LD_VAR 0 11
12541: NOT
12542: OR
12543: PUSH
12544: LD_VAR 0 12
12548: NOT
12549: OR
12550: PUSH
12551: LD_VAR 0 10
12555: NOT
12556: OR
12557: IFFALSE 12592
// begin result := [ chassis , engine , control , weapon ] ;
12559: LD_ADDR_VAR 0 6
12563: PUSH
12564: LD_VAR 0 2
12568: PUSH
12569: LD_VAR 0 3
12573: PUSH
12574: LD_VAR 0 4
12578: PUSH
12579: LD_VAR 0 5
12583: PUSH
12584: EMPTY
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: ST_TO_ADDR
// exit ;
12590: GO 12883
// end ; if not chassis in _chassis then
12592: LD_VAR 0 2
12596: PUSH
12597: LD_VAR 0 9
12601: IN
12602: NOT
12603: IFFALSE 12629
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12605: LD_ADDR_VAR 0 2
12609: PUSH
12610: LD_VAR 0 9
12614: PUSH
12615: LD_INT 1
12617: PPUSH
12618: LD_VAR 0 9
12622: PPUSH
12623: CALL_OW 12
12627: ARRAY
12628: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12629: LD_VAR 0 2
12633: PPUSH
12634: LD_VAR 0 3
12638: PPUSH
12639: CALL 12888 0 2
12643: NOT
12644: IFFALSE 12703
// repeat engine := _engine [ 1 ] ;
12646: LD_ADDR_VAR 0 3
12650: PUSH
12651: LD_VAR 0 11
12655: PUSH
12656: LD_INT 1
12658: ARRAY
12659: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12660: LD_ADDR_VAR 0 11
12664: PUSH
12665: LD_VAR 0 11
12669: PPUSH
12670: LD_INT 1
12672: PPUSH
12673: CALL_OW 3
12677: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12678: LD_VAR 0 2
12682: PPUSH
12683: LD_VAR 0 3
12687: PPUSH
12688: CALL 12888 0 2
12692: PUSH
12693: LD_VAR 0 11
12697: PUSH
12698: EMPTY
12699: EQUAL
12700: OR
12701: IFFALSE 12646
// if not control in _control then
12703: LD_VAR 0 4
12707: PUSH
12708: LD_VAR 0 12
12712: IN
12713: NOT
12714: IFFALSE 12740
// control := _control [ rand ( 1 , _control ) ] ;
12716: LD_ADDR_VAR 0 4
12720: PUSH
12721: LD_VAR 0 12
12725: PUSH
12726: LD_INT 1
12728: PPUSH
12729: LD_VAR 0 12
12733: PPUSH
12734: CALL_OW 12
12738: ARRAY
12739: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12740: LD_VAR 0 2
12744: PPUSH
12745: LD_VAR 0 5
12749: PPUSH
12750: CALL 13108 0 2
12754: NOT
12755: IFFALSE 12814
// repeat weapon := _weapon [ 1 ] ;
12757: LD_ADDR_VAR 0 5
12761: PUSH
12762: LD_VAR 0 10
12766: PUSH
12767: LD_INT 1
12769: ARRAY
12770: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12771: LD_ADDR_VAR 0 10
12775: PUSH
12776: LD_VAR 0 10
12780: PPUSH
12781: LD_INT 1
12783: PPUSH
12784: CALL_OW 3
12788: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12789: LD_VAR 0 2
12793: PPUSH
12794: LD_VAR 0 5
12798: PPUSH
12799: CALL 13108 0 2
12803: PUSH
12804: LD_VAR 0 10
12808: PUSH
12809: EMPTY
12810: EQUAL
12811: OR
12812: IFFALSE 12757
// result := [ ] ;
12814: LD_ADDR_VAR 0 6
12818: PUSH
12819: EMPTY
12820: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12821: LD_VAR 0 1
12825: PPUSH
12826: LD_VAR 0 2
12830: PPUSH
12831: LD_VAR 0 3
12835: PPUSH
12836: LD_VAR 0 4
12840: PPUSH
12841: LD_VAR 0 5
12845: PPUSH
12846: CALL_OW 448
12850: IFFALSE 12883
// result := [ chassis , engine , control , weapon ] ;
12852: LD_ADDR_VAR 0 6
12856: PUSH
12857: LD_VAR 0 2
12861: PUSH
12862: LD_VAR 0 3
12866: PUSH
12867: LD_VAR 0 4
12871: PUSH
12872: LD_VAR 0 5
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: ST_TO_ADDR
// end ;
12883: LD_VAR 0 6
12887: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12888: LD_INT 0
12890: PPUSH
// if not chassis or not engine then
12891: LD_VAR 0 1
12895: NOT
12896: PUSH
12897: LD_VAR 0 2
12901: NOT
12902: OR
12903: IFFALSE 12907
// exit ;
12905: GO 13103
// case engine of engine_solar :
12907: LD_VAR 0 2
12911: PUSH
12912: LD_INT 2
12914: DOUBLE
12915: EQUAL
12916: IFTRUE 12920
12918: GO 12958
12920: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12921: LD_ADDR_VAR 0 3
12925: PUSH
12926: LD_INT 11
12928: PUSH
12929: LD_INT 12
12931: PUSH
12932: LD_INT 13
12934: PUSH
12935: LD_INT 14
12937: PUSH
12938: LD_INT 1
12940: PUSH
12941: LD_INT 2
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: LIST
12953: LIST
12954: LIST
12955: ST_TO_ADDR
12956: GO 13087
12958: LD_INT 1
12960: DOUBLE
12961: EQUAL
12962: IFTRUE 12966
12964: GO 13028
12966: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
12967: LD_ADDR_VAR 0 3
12971: PUSH
12972: LD_INT 11
12974: PUSH
12975: LD_INT 12
12977: PUSH
12978: LD_INT 13
12980: PUSH
12981: LD_INT 14
12983: PUSH
12984: LD_INT 1
12986: PUSH
12987: LD_INT 2
12989: PUSH
12990: LD_INT 3
12992: PUSH
12993: LD_INT 4
12995: PUSH
12996: LD_INT 5
12998: PUSH
12999: LD_INT 21
13001: PUSH
13002: LD_INT 23
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 24
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: LIST
13024: LIST
13025: ST_TO_ADDR
13026: GO 13087
13028: LD_INT 3
13030: DOUBLE
13031: EQUAL
13032: IFTRUE 13036
13034: GO 13086
13036: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13037: LD_ADDR_VAR 0 3
13041: PUSH
13042: LD_INT 13
13044: PUSH
13045: LD_INT 14
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 3
13053: PUSH
13054: LD_INT 4
13056: PUSH
13057: LD_INT 5
13059: PUSH
13060: LD_INT 21
13062: PUSH
13063: LD_INT 22
13065: PUSH
13066: LD_INT 23
13068: PUSH
13069: LD_INT 24
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: ST_TO_ADDR
13084: GO 13087
13086: POP
// result := ( chassis in result ) ;
13087: LD_ADDR_VAR 0 3
13091: PUSH
13092: LD_VAR 0 1
13096: PUSH
13097: LD_VAR 0 3
13101: IN
13102: ST_TO_ADDR
// end ;
13103: LD_VAR 0 3
13107: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13108: LD_INT 0
13110: PPUSH
// if not chassis or not weapon then
13111: LD_VAR 0 1
13115: NOT
13116: PUSH
13117: LD_VAR 0 2
13121: NOT
13122: OR
13123: IFFALSE 13127
// exit ;
13125: GO 14187
// case weapon of us_machine_gun :
13127: LD_VAR 0 2
13131: PUSH
13132: LD_INT 2
13134: DOUBLE
13135: EQUAL
13136: IFTRUE 13140
13138: GO 13170
13140: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13141: LD_ADDR_VAR 0 3
13145: PUSH
13146: LD_INT 1
13148: PUSH
13149: LD_INT 2
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 4
13157: PUSH
13158: LD_INT 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: ST_TO_ADDR
13168: GO 14171
13170: LD_INT 3
13172: DOUBLE
13173: EQUAL
13174: IFTRUE 13178
13176: GO 13208
13178: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13179: LD_ADDR_VAR 0 3
13183: PUSH
13184: LD_INT 1
13186: PUSH
13187: LD_INT 2
13189: PUSH
13190: LD_INT 3
13192: PUSH
13193: LD_INT 4
13195: PUSH
13196: LD_INT 5
13198: PUSH
13199: EMPTY
13200: LIST
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: ST_TO_ADDR
13206: GO 14171
13208: LD_INT 11
13210: DOUBLE
13211: EQUAL
13212: IFTRUE 13216
13214: GO 13246
13216: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13217: LD_ADDR_VAR 0 3
13221: PUSH
13222: LD_INT 1
13224: PUSH
13225: LD_INT 2
13227: PUSH
13228: LD_INT 3
13230: PUSH
13231: LD_INT 4
13233: PUSH
13234: LD_INT 5
13236: PUSH
13237: EMPTY
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: ST_TO_ADDR
13244: GO 14171
13246: LD_INT 4
13248: DOUBLE
13249: EQUAL
13250: IFTRUE 13254
13252: GO 13280
13254: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13255: LD_ADDR_VAR 0 3
13259: PUSH
13260: LD_INT 2
13262: PUSH
13263: LD_INT 3
13265: PUSH
13266: LD_INT 4
13268: PUSH
13269: LD_INT 5
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: ST_TO_ADDR
13278: GO 14171
13280: LD_INT 5
13282: DOUBLE
13283: EQUAL
13284: IFTRUE 13288
13286: GO 13314
13288: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13289: LD_ADDR_VAR 0 3
13293: PUSH
13294: LD_INT 2
13296: PUSH
13297: LD_INT 3
13299: PUSH
13300: LD_INT 4
13302: PUSH
13303: LD_INT 5
13305: PUSH
13306: EMPTY
13307: LIST
13308: LIST
13309: LIST
13310: LIST
13311: ST_TO_ADDR
13312: GO 14171
13314: LD_INT 9
13316: DOUBLE
13317: EQUAL
13318: IFTRUE 13322
13320: GO 13348
13322: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13323: LD_ADDR_VAR 0 3
13327: PUSH
13328: LD_INT 2
13330: PUSH
13331: LD_INT 3
13333: PUSH
13334: LD_INT 4
13336: PUSH
13337: LD_INT 5
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: LIST
13344: LIST
13345: ST_TO_ADDR
13346: GO 14171
13348: LD_INT 7
13350: DOUBLE
13351: EQUAL
13352: IFTRUE 13356
13354: GO 13382
13356: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13357: LD_ADDR_VAR 0 3
13361: PUSH
13362: LD_INT 2
13364: PUSH
13365: LD_INT 3
13367: PUSH
13368: LD_INT 4
13370: PUSH
13371: LD_INT 5
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: ST_TO_ADDR
13380: GO 14171
13382: LD_INT 12
13384: DOUBLE
13385: EQUAL
13386: IFTRUE 13390
13388: GO 13416
13390: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13391: LD_ADDR_VAR 0 3
13395: PUSH
13396: LD_INT 2
13398: PUSH
13399: LD_INT 3
13401: PUSH
13402: LD_INT 4
13404: PUSH
13405: LD_INT 5
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: LIST
13412: LIST
13413: ST_TO_ADDR
13414: GO 14171
13416: LD_INT 13
13418: DOUBLE
13419: EQUAL
13420: IFTRUE 13424
13422: GO 13450
13424: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13425: LD_ADDR_VAR 0 3
13429: PUSH
13430: LD_INT 2
13432: PUSH
13433: LD_INT 3
13435: PUSH
13436: LD_INT 4
13438: PUSH
13439: LD_INT 5
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: ST_TO_ADDR
13448: GO 14171
13450: LD_INT 14
13452: DOUBLE
13453: EQUAL
13454: IFTRUE 13458
13456: GO 13476
13458: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13459: LD_ADDR_VAR 0 3
13463: PUSH
13464: LD_INT 4
13466: PUSH
13467: LD_INT 5
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: ST_TO_ADDR
13474: GO 14171
13476: LD_INT 6
13478: DOUBLE
13479: EQUAL
13480: IFTRUE 13484
13482: GO 13502
13484: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13485: LD_ADDR_VAR 0 3
13489: PUSH
13490: LD_INT 4
13492: PUSH
13493: LD_INT 5
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: ST_TO_ADDR
13500: GO 14171
13502: LD_INT 10
13504: DOUBLE
13505: EQUAL
13506: IFTRUE 13510
13508: GO 13528
13510: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13511: LD_ADDR_VAR 0 3
13515: PUSH
13516: LD_INT 4
13518: PUSH
13519: LD_INT 5
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: ST_TO_ADDR
13526: GO 14171
13528: LD_INT 22
13530: DOUBLE
13531: EQUAL
13532: IFTRUE 13536
13534: GO 13562
13536: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13537: LD_ADDR_VAR 0 3
13541: PUSH
13542: LD_INT 11
13544: PUSH
13545: LD_INT 12
13547: PUSH
13548: LD_INT 13
13550: PUSH
13551: LD_INT 14
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: LIST
13558: LIST
13559: ST_TO_ADDR
13560: GO 14171
13562: LD_INT 23
13564: DOUBLE
13565: EQUAL
13566: IFTRUE 13570
13568: GO 13596
13570: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13571: LD_ADDR_VAR 0 3
13575: PUSH
13576: LD_INT 11
13578: PUSH
13579: LD_INT 12
13581: PUSH
13582: LD_INT 13
13584: PUSH
13585: LD_INT 14
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: ST_TO_ADDR
13594: GO 14171
13596: LD_INT 24
13598: DOUBLE
13599: EQUAL
13600: IFTRUE 13604
13602: GO 13630
13604: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13605: LD_ADDR_VAR 0 3
13609: PUSH
13610: LD_INT 11
13612: PUSH
13613: LD_INT 12
13615: PUSH
13616: LD_INT 13
13618: PUSH
13619: LD_INT 14
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: ST_TO_ADDR
13628: GO 14171
13630: LD_INT 30
13632: DOUBLE
13633: EQUAL
13634: IFTRUE 13638
13636: GO 13664
13638: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13639: LD_ADDR_VAR 0 3
13643: PUSH
13644: LD_INT 11
13646: PUSH
13647: LD_INT 12
13649: PUSH
13650: LD_INT 13
13652: PUSH
13653: LD_INT 14
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: ST_TO_ADDR
13662: GO 14171
13664: LD_INT 25
13666: DOUBLE
13667: EQUAL
13668: IFTRUE 13672
13670: GO 13690
13672: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13673: LD_ADDR_VAR 0 3
13677: PUSH
13678: LD_INT 13
13680: PUSH
13681: LD_INT 14
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: ST_TO_ADDR
13688: GO 14171
13690: LD_INT 27
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13716
13698: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13699: LD_ADDR_VAR 0 3
13703: PUSH
13704: LD_INT 13
13706: PUSH
13707: LD_INT 14
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: ST_TO_ADDR
13714: GO 14171
13716: LD_INT 92
13718: DOUBLE
13719: EQUAL
13720: IFTRUE 13724
13722: GO 13750
13724: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13725: LD_ADDR_VAR 0 3
13729: PUSH
13730: LD_INT 11
13732: PUSH
13733: LD_INT 12
13735: PUSH
13736: LD_INT 13
13738: PUSH
13739: LD_INT 14
13741: PUSH
13742: EMPTY
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: ST_TO_ADDR
13748: GO 14171
13750: LD_INT 28
13752: DOUBLE
13753: EQUAL
13754: IFTRUE 13758
13756: GO 13776
13758: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13759: LD_ADDR_VAR 0 3
13763: PUSH
13764: LD_INT 13
13766: PUSH
13767: LD_INT 14
13769: PUSH
13770: EMPTY
13771: LIST
13772: LIST
13773: ST_TO_ADDR
13774: GO 14171
13776: LD_INT 29
13778: DOUBLE
13779: EQUAL
13780: IFTRUE 13784
13782: GO 13802
13784: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13785: LD_ADDR_VAR 0 3
13789: PUSH
13790: LD_INT 13
13792: PUSH
13793: LD_INT 14
13795: PUSH
13796: EMPTY
13797: LIST
13798: LIST
13799: ST_TO_ADDR
13800: GO 14171
13802: LD_INT 31
13804: DOUBLE
13805: EQUAL
13806: IFTRUE 13810
13808: GO 13828
13810: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13811: LD_ADDR_VAR 0 3
13815: PUSH
13816: LD_INT 13
13818: PUSH
13819: LD_INT 14
13821: PUSH
13822: EMPTY
13823: LIST
13824: LIST
13825: ST_TO_ADDR
13826: GO 14171
13828: LD_INT 26
13830: DOUBLE
13831: EQUAL
13832: IFTRUE 13836
13834: GO 13854
13836: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13837: LD_ADDR_VAR 0 3
13841: PUSH
13842: LD_INT 13
13844: PUSH
13845: LD_INT 14
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: ST_TO_ADDR
13852: GO 14171
13854: LD_INT 42
13856: DOUBLE
13857: EQUAL
13858: IFTRUE 13862
13860: GO 13888
13862: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13863: LD_ADDR_VAR 0 3
13867: PUSH
13868: LD_INT 21
13870: PUSH
13871: LD_INT 22
13873: PUSH
13874: LD_INT 23
13876: PUSH
13877: LD_INT 24
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: ST_TO_ADDR
13886: GO 14171
13888: LD_INT 43
13890: DOUBLE
13891: EQUAL
13892: IFTRUE 13896
13894: GO 13922
13896: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13897: LD_ADDR_VAR 0 3
13901: PUSH
13902: LD_INT 21
13904: PUSH
13905: LD_INT 22
13907: PUSH
13908: LD_INT 23
13910: PUSH
13911: LD_INT 24
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: ST_TO_ADDR
13920: GO 14171
13922: LD_INT 44
13924: DOUBLE
13925: EQUAL
13926: IFTRUE 13930
13928: GO 13956
13930: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13931: LD_ADDR_VAR 0 3
13935: PUSH
13936: LD_INT 21
13938: PUSH
13939: LD_INT 22
13941: PUSH
13942: LD_INT 23
13944: PUSH
13945: LD_INT 24
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: ST_TO_ADDR
13954: GO 14171
13956: LD_INT 45
13958: DOUBLE
13959: EQUAL
13960: IFTRUE 13964
13962: GO 13990
13964: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13965: LD_ADDR_VAR 0 3
13969: PUSH
13970: LD_INT 21
13972: PUSH
13973: LD_INT 22
13975: PUSH
13976: LD_INT 23
13978: PUSH
13979: LD_INT 24
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: LIST
13986: LIST
13987: ST_TO_ADDR
13988: GO 14171
13990: LD_INT 49
13992: DOUBLE
13993: EQUAL
13994: IFTRUE 13998
13996: GO 14024
13998: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
13999: LD_ADDR_VAR 0 3
14003: PUSH
14004: LD_INT 21
14006: PUSH
14007: LD_INT 22
14009: PUSH
14010: LD_INT 23
14012: PUSH
14013: LD_INT 24
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: ST_TO_ADDR
14022: GO 14171
14024: LD_INT 51
14026: DOUBLE
14027: EQUAL
14028: IFTRUE 14032
14030: GO 14058
14032: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14033: LD_ADDR_VAR 0 3
14037: PUSH
14038: LD_INT 21
14040: PUSH
14041: LD_INT 22
14043: PUSH
14044: LD_INT 23
14046: PUSH
14047: LD_INT 24
14049: PUSH
14050: EMPTY
14051: LIST
14052: LIST
14053: LIST
14054: LIST
14055: ST_TO_ADDR
14056: GO 14171
14058: LD_INT 52
14060: DOUBLE
14061: EQUAL
14062: IFTRUE 14066
14064: GO 14092
14066: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14067: LD_ADDR_VAR 0 3
14071: PUSH
14072: LD_INT 21
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 23
14080: PUSH
14081: LD_INT 24
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: ST_TO_ADDR
14090: GO 14171
14092: LD_INT 53
14094: DOUBLE
14095: EQUAL
14096: IFTRUE 14100
14098: GO 14118
14100: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14101: LD_ADDR_VAR 0 3
14105: PUSH
14106: LD_INT 23
14108: PUSH
14109: LD_INT 24
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: ST_TO_ADDR
14116: GO 14171
14118: LD_INT 46
14120: DOUBLE
14121: EQUAL
14122: IFTRUE 14126
14124: GO 14144
14126: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14127: LD_ADDR_VAR 0 3
14131: PUSH
14132: LD_INT 23
14134: PUSH
14135: LD_INT 24
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: ST_TO_ADDR
14142: GO 14171
14144: LD_INT 47
14146: DOUBLE
14147: EQUAL
14148: IFTRUE 14152
14150: GO 14170
14152: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14153: LD_ADDR_VAR 0 3
14157: PUSH
14158: LD_INT 23
14160: PUSH
14161: LD_INT 24
14163: PUSH
14164: EMPTY
14165: LIST
14166: LIST
14167: ST_TO_ADDR
14168: GO 14171
14170: POP
// result := ( chassis in result ) ;
14171: LD_ADDR_VAR 0 3
14175: PUSH
14176: LD_VAR 0 1
14180: PUSH
14181: LD_VAR 0 3
14185: IN
14186: ST_TO_ADDR
// end ;
14187: LD_VAR 0 3
14191: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14192: LD_INT 0
14194: PPUSH
14195: PPUSH
14196: PPUSH
14197: PPUSH
14198: PPUSH
14199: PPUSH
14200: PPUSH
// result := array ;
14201: LD_ADDR_VAR 0 5
14205: PUSH
14206: LD_VAR 0 1
14210: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14211: LD_VAR 0 1
14215: NOT
14216: PUSH
14217: LD_VAR 0 2
14221: NOT
14222: OR
14223: PUSH
14224: LD_VAR 0 3
14228: NOT
14229: OR
14230: PUSH
14231: LD_VAR 0 2
14235: PUSH
14236: LD_VAR 0 1
14240: GREATER
14241: OR
14242: PUSH
14243: LD_VAR 0 3
14247: PUSH
14248: LD_VAR 0 1
14252: GREATER
14253: OR
14254: IFFALSE 14258
// exit ;
14256: GO 14554
// if direction then
14258: LD_VAR 0 4
14262: IFFALSE 14326
// begin d := 1 ;
14264: LD_ADDR_VAR 0 9
14268: PUSH
14269: LD_INT 1
14271: ST_TO_ADDR
// if i_from > i_to then
14272: LD_VAR 0 2
14276: PUSH
14277: LD_VAR 0 3
14281: GREATER
14282: IFFALSE 14308
// length := ( array - i_from ) + i_to else
14284: LD_ADDR_VAR 0 11
14288: PUSH
14289: LD_VAR 0 1
14293: PUSH
14294: LD_VAR 0 2
14298: MINUS
14299: PUSH
14300: LD_VAR 0 3
14304: PLUS
14305: ST_TO_ADDR
14306: GO 14324
// length := i_to - i_from ;
14308: LD_ADDR_VAR 0 11
14312: PUSH
14313: LD_VAR 0 3
14317: PUSH
14318: LD_VAR 0 2
14322: MINUS
14323: ST_TO_ADDR
// end else
14324: GO 14387
// begin d := - 1 ;
14326: LD_ADDR_VAR 0 9
14330: PUSH
14331: LD_INT 1
14333: NEG
14334: ST_TO_ADDR
// if i_from > i_to then
14335: LD_VAR 0 2
14339: PUSH
14340: LD_VAR 0 3
14344: GREATER
14345: IFFALSE 14365
// length := i_from - i_to else
14347: LD_ADDR_VAR 0 11
14351: PUSH
14352: LD_VAR 0 2
14356: PUSH
14357: LD_VAR 0 3
14361: MINUS
14362: ST_TO_ADDR
14363: GO 14387
// length := ( array - i_to ) + i_from ;
14365: LD_ADDR_VAR 0 11
14369: PUSH
14370: LD_VAR 0 1
14374: PUSH
14375: LD_VAR 0 3
14379: MINUS
14380: PUSH
14381: LD_VAR 0 2
14385: PLUS
14386: ST_TO_ADDR
// end ; if not length then
14387: LD_VAR 0 11
14391: NOT
14392: IFFALSE 14396
// exit ;
14394: GO 14554
// tmp := array ;
14396: LD_ADDR_VAR 0 10
14400: PUSH
14401: LD_VAR 0 1
14405: ST_TO_ADDR
// for i = 1 to length do
14406: LD_ADDR_VAR 0 6
14410: PUSH
14411: DOUBLE
14412: LD_INT 1
14414: DEC
14415: ST_TO_ADDR
14416: LD_VAR 0 11
14420: PUSH
14421: FOR_TO
14422: IFFALSE 14542
// begin for j = 1 to array do
14424: LD_ADDR_VAR 0 7
14428: PUSH
14429: DOUBLE
14430: LD_INT 1
14432: DEC
14433: ST_TO_ADDR
14434: LD_VAR 0 1
14438: PUSH
14439: FOR_TO
14440: IFFALSE 14528
// begin k := j + d ;
14442: LD_ADDR_VAR 0 8
14446: PUSH
14447: LD_VAR 0 7
14451: PUSH
14452: LD_VAR 0 9
14456: PLUS
14457: ST_TO_ADDR
// if k > array then
14458: LD_VAR 0 8
14462: PUSH
14463: LD_VAR 0 1
14467: GREATER
14468: IFFALSE 14478
// k := 1 ;
14470: LD_ADDR_VAR 0 8
14474: PUSH
14475: LD_INT 1
14477: ST_TO_ADDR
// if not k then
14478: LD_VAR 0 8
14482: NOT
14483: IFFALSE 14495
// k := array ;
14485: LD_ADDR_VAR 0 8
14489: PUSH
14490: LD_VAR 0 1
14494: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14495: LD_ADDR_VAR 0 10
14499: PUSH
14500: LD_VAR 0 10
14504: PPUSH
14505: LD_VAR 0 8
14509: PPUSH
14510: LD_VAR 0 1
14514: PUSH
14515: LD_VAR 0 7
14519: ARRAY
14520: PPUSH
14521: CALL_OW 1
14525: ST_TO_ADDR
// end ;
14526: GO 14439
14528: POP
14529: POP
// array := tmp ;
14530: LD_ADDR_VAR 0 1
14534: PUSH
14535: LD_VAR 0 10
14539: ST_TO_ADDR
// end ;
14540: GO 14421
14542: POP
14543: POP
// result := array ;
14544: LD_ADDR_VAR 0 5
14548: PUSH
14549: LD_VAR 0 1
14553: ST_TO_ADDR
// end ;
14554: LD_VAR 0 5
14558: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14559: LD_INT 0
14561: PPUSH
14562: PPUSH
// result := 0 ;
14563: LD_ADDR_VAR 0 3
14567: PUSH
14568: LD_INT 0
14570: ST_TO_ADDR
// if not array or not value in array then
14571: LD_VAR 0 1
14575: NOT
14576: PUSH
14577: LD_VAR 0 2
14581: PUSH
14582: LD_VAR 0 1
14586: IN
14587: NOT
14588: OR
14589: IFFALSE 14593
// exit ;
14591: GO 14647
// for i = 1 to array do
14593: LD_ADDR_VAR 0 4
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_VAR 0 1
14607: PUSH
14608: FOR_TO
14609: IFFALSE 14645
// if value = array [ i ] then
14611: LD_VAR 0 2
14615: PUSH
14616: LD_VAR 0 1
14620: PUSH
14621: LD_VAR 0 4
14625: ARRAY
14626: EQUAL
14627: IFFALSE 14643
// begin result := i ;
14629: LD_ADDR_VAR 0 3
14633: PUSH
14634: LD_VAR 0 4
14638: ST_TO_ADDR
// exit ;
14639: POP
14640: POP
14641: GO 14647
// end ;
14643: GO 14608
14645: POP
14646: POP
// end ;
14647: LD_VAR 0 3
14651: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14652: LD_INT 0
14654: PPUSH
// vc_chassis := chassis ;
14655: LD_ADDR_OWVAR 37
14659: PUSH
14660: LD_VAR 0 1
14664: ST_TO_ADDR
// vc_engine := engine ;
14665: LD_ADDR_OWVAR 39
14669: PUSH
14670: LD_VAR 0 2
14674: ST_TO_ADDR
// vc_control := control ;
14675: LD_ADDR_OWVAR 38
14679: PUSH
14680: LD_VAR 0 3
14684: ST_TO_ADDR
// vc_weapon := weapon ;
14685: LD_ADDR_OWVAR 40
14689: PUSH
14690: LD_VAR 0 4
14694: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14695: LD_ADDR_OWVAR 41
14699: PUSH
14700: LD_VAR 0 5
14704: ST_TO_ADDR
// end ;
14705: LD_VAR 0 6
14709: RET
// export function WantPlant ( unit ) ; var task ; begin
14710: LD_INT 0
14712: PPUSH
14713: PPUSH
// result := false ;
14714: LD_ADDR_VAR 0 2
14718: PUSH
14719: LD_INT 0
14721: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14722: LD_ADDR_VAR 0 3
14726: PUSH
14727: LD_VAR 0 1
14731: PPUSH
14732: CALL_OW 437
14736: ST_TO_ADDR
// if task then
14737: LD_VAR 0 3
14741: IFFALSE 14769
// if task [ 1 ] [ 1 ] = p then
14743: LD_VAR 0 3
14747: PUSH
14748: LD_INT 1
14750: ARRAY
14751: PUSH
14752: LD_INT 1
14754: ARRAY
14755: PUSH
14756: LD_STRING p
14758: EQUAL
14759: IFFALSE 14769
// result := true ;
14761: LD_ADDR_VAR 0 2
14765: PUSH
14766: LD_INT 1
14768: ST_TO_ADDR
// end ;
14769: LD_VAR 0 2
14773: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14774: LD_INT 0
14776: PPUSH
14777: PPUSH
14778: PPUSH
14779: PPUSH
// if pos < 1 then
14780: LD_VAR 0 2
14784: PUSH
14785: LD_INT 1
14787: LESS
14788: IFFALSE 14792
// exit ;
14790: GO 15095
// if pos = 1 then
14792: LD_VAR 0 2
14796: PUSH
14797: LD_INT 1
14799: EQUAL
14800: IFFALSE 14833
// result := Replace ( arr , pos [ 1 ] , value ) else
14802: LD_ADDR_VAR 0 4
14806: PUSH
14807: LD_VAR 0 1
14811: PPUSH
14812: LD_VAR 0 2
14816: PUSH
14817: LD_INT 1
14819: ARRAY
14820: PPUSH
14821: LD_VAR 0 3
14825: PPUSH
14826: CALL_OW 1
14830: ST_TO_ADDR
14831: GO 15095
// begin tmp := arr ;
14833: LD_ADDR_VAR 0 6
14837: PUSH
14838: LD_VAR 0 1
14842: ST_TO_ADDR
// s_arr := [ tmp ] ;
14843: LD_ADDR_VAR 0 7
14847: PUSH
14848: LD_VAR 0 6
14852: PUSH
14853: EMPTY
14854: LIST
14855: ST_TO_ADDR
// for i = 1 to pos - 1 do
14856: LD_ADDR_VAR 0 5
14860: PUSH
14861: DOUBLE
14862: LD_INT 1
14864: DEC
14865: ST_TO_ADDR
14866: LD_VAR 0 2
14870: PUSH
14871: LD_INT 1
14873: MINUS
14874: PUSH
14875: FOR_TO
14876: IFFALSE 14921
// begin tmp := tmp [ pos [ i ] ] ;
14878: LD_ADDR_VAR 0 6
14882: PUSH
14883: LD_VAR 0 6
14887: PUSH
14888: LD_VAR 0 2
14892: PUSH
14893: LD_VAR 0 5
14897: ARRAY
14898: ARRAY
14899: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14900: LD_ADDR_VAR 0 7
14904: PUSH
14905: LD_VAR 0 7
14909: PUSH
14910: LD_VAR 0 6
14914: PUSH
14915: EMPTY
14916: LIST
14917: ADD
14918: ST_TO_ADDR
// end ;
14919: GO 14875
14921: POP
14922: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14923: LD_ADDR_VAR 0 6
14927: PUSH
14928: LD_VAR 0 6
14932: PPUSH
14933: LD_VAR 0 2
14937: PUSH
14938: LD_VAR 0 2
14942: ARRAY
14943: PPUSH
14944: LD_VAR 0 3
14948: PPUSH
14949: CALL_OW 1
14953: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14954: LD_ADDR_VAR 0 7
14958: PUSH
14959: LD_VAR 0 7
14963: PPUSH
14964: LD_VAR 0 7
14968: PPUSH
14969: LD_VAR 0 6
14973: PPUSH
14974: CALL_OW 1
14978: ST_TO_ADDR
// for i = s_arr downto 2 do
14979: LD_ADDR_VAR 0 5
14983: PUSH
14984: DOUBLE
14985: LD_VAR 0 7
14989: INC
14990: ST_TO_ADDR
14991: LD_INT 2
14993: PUSH
14994: FOR_DOWNTO
14995: IFFALSE 15079
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
14997: LD_ADDR_VAR 0 6
15001: PUSH
15002: LD_VAR 0 7
15006: PUSH
15007: LD_VAR 0 5
15011: PUSH
15012: LD_INT 1
15014: MINUS
15015: ARRAY
15016: PPUSH
15017: LD_VAR 0 2
15021: PUSH
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 1
15029: MINUS
15030: ARRAY
15031: PPUSH
15032: LD_VAR 0 7
15036: PUSH
15037: LD_VAR 0 5
15041: ARRAY
15042: PPUSH
15043: CALL_OW 1
15047: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15048: LD_ADDR_VAR 0 7
15052: PUSH
15053: LD_VAR 0 7
15057: PPUSH
15058: LD_VAR 0 5
15062: PUSH
15063: LD_INT 1
15065: MINUS
15066: PPUSH
15067: LD_VAR 0 6
15071: PPUSH
15072: CALL_OW 1
15076: ST_TO_ADDR
// end ;
15077: GO 14994
15079: POP
15080: POP
// result := s_arr [ 1 ] ;
15081: LD_ADDR_VAR 0 4
15085: PUSH
15086: LD_VAR 0 7
15090: PUSH
15091: LD_INT 1
15093: ARRAY
15094: ST_TO_ADDR
// end ; end ;
15095: LD_VAR 0 4
15099: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15100: LD_INT 0
15102: PPUSH
15103: PPUSH
// if not list then
15104: LD_VAR 0 1
15108: NOT
15109: IFFALSE 15113
// exit ;
15111: GO 15204
// i := list [ pos1 ] ;
15113: LD_ADDR_VAR 0 5
15117: PUSH
15118: LD_VAR 0 1
15122: PUSH
15123: LD_VAR 0 2
15127: ARRAY
15128: ST_TO_ADDR
// if not i then
15129: LD_VAR 0 5
15133: NOT
15134: IFFALSE 15138
// exit ;
15136: GO 15204
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15138: LD_ADDR_VAR 0 1
15142: PUSH
15143: LD_VAR 0 1
15147: PPUSH
15148: LD_VAR 0 2
15152: PPUSH
15153: LD_VAR 0 1
15157: PUSH
15158: LD_VAR 0 3
15162: ARRAY
15163: PPUSH
15164: CALL_OW 1
15168: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15169: LD_ADDR_VAR 0 1
15173: PUSH
15174: LD_VAR 0 1
15178: PPUSH
15179: LD_VAR 0 3
15183: PPUSH
15184: LD_VAR 0 5
15188: PPUSH
15189: CALL_OW 1
15193: ST_TO_ADDR
// result := list ;
15194: LD_ADDR_VAR 0 4
15198: PUSH
15199: LD_VAR 0 1
15203: ST_TO_ADDR
// end ;
15204: LD_VAR 0 4
15208: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15209: LD_INT 0
15211: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15212: LD_ADDR_VAR 0 5
15216: PUSH
15217: LD_VAR 0 1
15221: PPUSH
15222: CALL_OW 250
15226: PPUSH
15227: LD_VAR 0 1
15231: PPUSH
15232: CALL_OW 251
15236: PPUSH
15237: LD_VAR 0 2
15241: PPUSH
15242: LD_VAR 0 3
15246: PPUSH
15247: LD_VAR 0 4
15251: PPUSH
15252: CALL 15630 0 5
15256: ST_TO_ADDR
// end ;
15257: LD_VAR 0 5
15261: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
15262: LD_INT 0
15264: PPUSH
15265: PPUSH
15266: PPUSH
15267: PPUSH
// if not list or not unit then
15268: LD_VAR 0 2
15272: NOT
15273: PUSH
15274: LD_VAR 0 1
15278: NOT
15279: OR
15280: IFFALSE 15284
// exit ;
15282: GO 15625
// result := [ ] ;
15284: LD_ADDR_VAR 0 5
15288: PUSH
15289: EMPTY
15290: ST_TO_ADDR
// for i in list do
15291: LD_ADDR_VAR 0 6
15295: PUSH
15296: LD_VAR 0 2
15300: PUSH
15301: FOR_IN
15302: IFFALSE 15520
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
15304: LD_ADDR_VAR 0 8
15308: PUSH
15309: LD_VAR 0 1
15313: PPUSH
15314: LD_VAR 0 6
15318: PUSH
15319: LD_INT 1
15321: ARRAY
15322: PPUSH
15323: LD_VAR 0 6
15327: PUSH
15328: LD_INT 2
15330: ARRAY
15331: PPUSH
15332: CALL_OW 297
15336: ST_TO_ADDR
// if not Count ( result ) then
15337: LD_VAR 0 5
15341: PPUSH
15342: CALL 11914 0 1
15346: NOT
15347: IFFALSE 15380
// begin result := Join ( result , [ i , tmp ] ) ;
15349: LD_ADDR_VAR 0 5
15353: PUSH
15354: LD_VAR 0 5
15358: PPUSH
15359: LD_VAR 0 6
15363: PUSH
15364: LD_VAR 0 8
15368: PUSH
15369: EMPTY
15370: LIST
15371: LIST
15372: PPUSH
15373: CALL 47514 0 2
15377: ST_TO_ADDR
// continue ;
15378: GO 15301
// end ; if result [ result ] [ 2 ] <= tmp then
15380: LD_VAR 0 5
15384: PUSH
15385: LD_VAR 0 5
15389: ARRAY
15390: PUSH
15391: LD_INT 2
15393: ARRAY
15394: PUSH
15395: LD_VAR 0 8
15399: LESSEQUAL
15400: IFFALSE 15433
// result := Join ( result , [ i , tmp ] ) else
15402: LD_ADDR_VAR 0 5
15406: PUSH
15407: LD_VAR 0 5
15411: PPUSH
15412: LD_VAR 0 6
15416: PUSH
15417: LD_VAR 0 8
15421: PUSH
15422: EMPTY
15423: LIST
15424: LIST
15425: PPUSH
15426: CALL 47514 0 2
15430: ST_TO_ADDR
15431: GO 15518
// begin for j := 1 to Count ( result ) do
15433: LD_ADDR_VAR 0 7
15437: PUSH
15438: DOUBLE
15439: LD_INT 1
15441: DEC
15442: ST_TO_ADDR
15443: LD_VAR 0 5
15447: PPUSH
15448: CALL 11914 0 1
15452: PUSH
15453: FOR_TO
15454: IFFALSE 15516
// begin if tmp < result [ j ] [ 2 ] then
15456: LD_VAR 0 8
15460: PUSH
15461: LD_VAR 0 5
15465: PUSH
15466: LD_VAR 0 7
15470: ARRAY
15471: PUSH
15472: LD_INT 2
15474: ARRAY
15475: LESS
15476: IFFALSE 15514
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15478: LD_ADDR_VAR 0 5
15482: PUSH
15483: LD_VAR 0 5
15487: PPUSH
15488: LD_VAR 0 7
15492: PPUSH
15493: LD_VAR 0 6
15497: PUSH
15498: LD_VAR 0 8
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: PPUSH
15507: CALL_OW 2
15511: ST_TO_ADDR
// break ;
15512: GO 15516
// end ; end ;
15514: GO 15453
15516: POP
15517: POP
// end ; end ;
15518: GO 15301
15520: POP
15521: POP
// if result and not asc then
15522: LD_VAR 0 5
15526: PUSH
15527: LD_VAR 0 3
15531: NOT
15532: AND
15533: IFFALSE 15550
// result := ReverseArray ( result ) ;
15535: LD_ADDR_VAR 0 5
15539: PUSH
15540: LD_VAR 0 5
15544: PPUSH
15545: CALL 42790 0 1
15549: ST_TO_ADDR
// tmp := [ ] ;
15550: LD_ADDR_VAR 0 8
15554: PUSH
15555: EMPTY
15556: ST_TO_ADDR
// if mode then
15557: LD_VAR 0 4
15561: IFFALSE 15625
// begin for i := 1 to result do
15563: LD_ADDR_VAR 0 6
15567: PUSH
15568: DOUBLE
15569: LD_INT 1
15571: DEC
15572: ST_TO_ADDR
15573: LD_VAR 0 5
15577: PUSH
15578: FOR_TO
15579: IFFALSE 15613
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
15581: LD_ADDR_VAR 0 8
15585: PUSH
15586: LD_VAR 0 8
15590: PPUSH
15591: LD_VAR 0 5
15595: PUSH
15596: LD_VAR 0 6
15600: ARRAY
15601: PUSH
15602: LD_INT 1
15604: ARRAY
15605: PPUSH
15606: CALL 47514 0 2
15610: ST_TO_ADDR
15611: GO 15578
15613: POP
15614: POP
// result := tmp ;
15615: LD_ADDR_VAR 0 5
15619: PUSH
15620: LD_VAR 0 8
15624: ST_TO_ADDR
// end ; end ;
15625: LD_VAR 0 5
15629: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15630: LD_INT 0
15632: PPUSH
15633: PPUSH
15634: PPUSH
15635: PPUSH
// if not list then
15636: LD_VAR 0 3
15640: NOT
15641: IFFALSE 15645
// exit ;
15643: GO 16033
// result := [ ] ;
15645: LD_ADDR_VAR 0 6
15649: PUSH
15650: EMPTY
15651: ST_TO_ADDR
// for i in list do
15652: LD_ADDR_VAR 0 7
15656: PUSH
15657: LD_VAR 0 3
15661: PUSH
15662: FOR_IN
15663: IFFALSE 15865
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15665: LD_ADDR_VAR 0 9
15669: PUSH
15670: LD_VAR 0 7
15674: PPUSH
15675: LD_VAR 0 1
15679: PPUSH
15680: LD_VAR 0 2
15684: PPUSH
15685: CALL_OW 297
15689: ST_TO_ADDR
// if not result then
15690: LD_VAR 0 6
15694: NOT
15695: IFFALSE 15721
// result := [ [ i , tmp ] ] else
15697: LD_ADDR_VAR 0 6
15701: PUSH
15702: LD_VAR 0 7
15706: PUSH
15707: LD_VAR 0 9
15711: PUSH
15712: EMPTY
15713: LIST
15714: LIST
15715: PUSH
15716: EMPTY
15717: LIST
15718: ST_TO_ADDR
15719: GO 15863
// begin if result [ result ] [ 2 ] < tmp then
15721: LD_VAR 0 6
15725: PUSH
15726: LD_VAR 0 6
15730: ARRAY
15731: PUSH
15732: LD_INT 2
15734: ARRAY
15735: PUSH
15736: LD_VAR 0 9
15740: LESS
15741: IFFALSE 15783
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15743: LD_ADDR_VAR 0 6
15747: PUSH
15748: LD_VAR 0 6
15752: PPUSH
15753: LD_VAR 0 6
15757: PUSH
15758: LD_INT 1
15760: PLUS
15761: PPUSH
15762: LD_VAR 0 7
15766: PUSH
15767: LD_VAR 0 9
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 2
15780: ST_TO_ADDR
15781: GO 15863
// for j = 1 to result do
15783: LD_ADDR_VAR 0 8
15787: PUSH
15788: DOUBLE
15789: LD_INT 1
15791: DEC
15792: ST_TO_ADDR
15793: LD_VAR 0 6
15797: PUSH
15798: FOR_TO
15799: IFFALSE 15861
// begin if tmp < result [ j ] [ 2 ] then
15801: LD_VAR 0 9
15805: PUSH
15806: LD_VAR 0 6
15810: PUSH
15811: LD_VAR 0 8
15815: ARRAY
15816: PUSH
15817: LD_INT 2
15819: ARRAY
15820: LESS
15821: IFFALSE 15859
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15823: LD_ADDR_VAR 0 6
15827: PUSH
15828: LD_VAR 0 6
15832: PPUSH
15833: LD_VAR 0 8
15837: PPUSH
15838: LD_VAR 0 7
15842: PUSH
15843: LD_VAR 0 9
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PPUSH
15852: CALL_OW 2
15856: ST_TO_ADDR
// break ;
15857: GO 15861
// end ; end ;
15859: GO 15798
15861: POP
15862: POP
// end ; end ;
15863: GO 15662
15865: POP
15866: POP
// if result and not asc then
15867: LD_VAR 0 6
15871: PUSH
15872: LD_VAR 0 4
15876: NOT
15877: AND
15878: IFFALSE 15953
// begin tmp := result ;
15880: LD_ADDR_VAR 0 9
15884: PUSH
15885: LD_VAR 0 6
15889: ST_TO_ADDR
// for i = tmp downto 1 do
15890: LD_ADDR_VAR 0 7
15894: PUSH
15895: DOUBLE
15896: LD_VAR 0 9
15900: INC
15901: ST_TO_ADDR
15902: LD_INT 1
15904: PUSH
15905: FOR_DOWNTO
15906: IFFALSE 15951
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15908: LD_ADDR_VAR 0 6
15912: PUSH
15913: LD_VAR 0 6
15917: PPUSH
15918: LD_VAR 0 9
15922: PUSH
15923: LD_VAR 0 7
15927: MINUS
15928: PUSH
15929: LD_INT 1
15931: PLUS
15932: PPUSH
15933: LD_VAR 0 9
15937: PUSH
15938: LD_VAR 0 7
15942: ARRAY
15943: PPUSH
15944: CALL_OW 1
15948: ST_TO_ADDR
15949: GO 15905
15951: POP
15952: POP
// end ; tmp := [ ] ;
15953: LD_ADDR_VAR 0 9
15957: PUSH
15958: EMPTY
15959: ST_TO_ADDR
// if mode then
15960: LD_VAR 0 5
15964: IFFALSE 16033
// begin for i = 1 to result do
15966: LD_ADDR_VAR 0 7
15970: PUSH
15971: DOUBLE
15972: LD_INT 1
15974: DEC
15975: ST_TO_ADDR
15976: LD_VAR 0 6
15980: PUSH
15981: FOR_TO
15982: IFFALSE 16021
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15984: LD_ADDR_VAR 0 9
15988: PUSH
15989: LD_VAR 0 9
15993: PPUSH
15994: LD_VAR 0 7
15998: PPUSH
15999: LD_VAR 0 6
16003: PUSH
16004: LD_VAR 0 7
16008: ARRAY
16009: PUSH
16010: LD_INT 1
16012: ARRAY
16013: PPUSH
16014: CALL_OW 1
16018: ST_TO_ADDR
16019: GO 15981
16021: POP
16022: POP
// result := tmp ;
16023: LD_ADDR_VAR 0 6
16027: PUSH
16028: LD_VAR 0 9
16032: ST_TO_ADDR
// end ; end ;
16033: LD_VAR 0 6
16037: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
16038: LD_INT 0
16040: PPUSH
16041: PPUSH
16042: PPUSH
16043: PPUSH
16044: PPUSH
16045: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
16046: LD_ADDR_VAR 0 5
16050: PUSH
16051: LD_INT 0
16053: PUSH
16054: LD_INT 0
16056: PUSH
16057: LD_INT 0
16059: PUSH
16060: EMPTY
16061: PUSH
16062: EMPTY
16063: LIST
16064: LIST
16065: LIST
16066: LIST
16067: ST_TO_ADDR
// if not x or not y then
16068: LD_VAR 0 2
16072: NOT
16073: PUSH
16074: LD_VAR 0 3
16078: NOT
16079: OR
16080: IFFALSE 16084
// exit ;
16082: GO 17734
// if not range then
16084: LD_VAR 0 4
16088: NOT
16089: IFFALSE 16099
// range := 10 ;
16091: LD_ADDR_VAR 0 4
16095: PUSH
16096: LD_INT 10
16098: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16099: LD_ADDR_VAR 0 8
16103: PUSH
16104: LD_INT 81
16106: PUSH
16107: LD_VAR 0 1
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: PUSH
16116: LD_INT 92
16118: PUSH
16119: LD_VAR 0 2
16123: PUSH
16124: LD_VAR 0 3
16128: PUSH
16129: LD_VAR 0 4
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: LIST
16138: LIST
16139: PUSH
16140: LD_INT 3
16142: PUSH
16143: LD_INT 21
16145: PUSH
16146: LD_INT 3
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: LIST
16161: PPUSH
16162: CALL_OW 69
16166: ST_TO_ADDR
// if not tmp then
16167: LD_VAR 0 8
16171: NOT
16172: IFFALSE 16176
// exit ;
16174: GO 17734
// for i in tmp do
16176: LD_ADDR_VAR 0 6
16180: PUSH
16181: LD_VAR 0 8
16185: PUSH
16186: FOR_IN
16187: IFFALSE 17709
// begin points := [ 0 , 0 , 0 ] ;
16189: LD_ADDR_VAR 0 9
16193: PUSH
16194: LD_INT 0
16196: PUSH
16197: LD_INT 0
16199: PUSH
16200: LD_INT 0
16202: PUSH
16203: EMPTY
16204: LIST
16205: LIST
16206: LIST
16207: ST_TO_ADDR
// bpoints := 1 ;
16208: LD_ADDR_VAR 0 10
16212: PUSH
16213: LD_INT 1
16215: ST_TO_ADDR
// case GetType ( i ) of unit_human :
16216: LD_VAR 0 6
16220: PPUSH
16221: CALL_OW 247
16225: PUSH
16226: LD_INT 1
16228: DOUBLE
16229: EQUAL
16230: IFTRUE 16234
16232: GO 16812
16234: POP
// begin if GetClass ( i ) = 1 then
16235: LD_VAR 0 6
16239: PPUSH
16240: CALL_OW 257
16244: PUSH
16245: LD_INT 1
16247: EQUAL
16248: IFFALSE 16269
// points := [ 10 , 5 , 3 ] ;
16250: LD_ADDR_VAR 0 9
16254: PUSH
16255: LD_INT 10
16257: PUSH
16258: LD_INT 5
16260: PUSH
16261: LD_INT 3
16263: PUSH
16264: EMPTY
16265: LIST
16266: LIST
16267: LIST
16268: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16269: LD_VAR 0 6
16273: PPUSH
16274: CALL_OW 257
16278: PUSH
16279: LD_INT 2
16281: PUSH
16282: LD_INT 3
16284: PUSH
16285: LD_INT 4
16287: PUSH
16288: EMPTY
16289: LIST
16290: LIST
16291: LIST
16292: IN
16293: IFFALSE 16314
// points := [ 3 , 2 , 1 ] ;
16295: LD_ADDR_VAR 0 9
16299: PUSH
16300: LD_INT 3
16302: PUSH
16303: LD_INT 2
16305: PUSH
16306: LD_INT 1
16308: PUSH
16309: EMPTY
16310: LIST
16311: LIST
16312: LIST
16313: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16314: LD_VAR 0 6
16318: PPUSH
16319: CALL_OW 257
16323: PUSH
16324: LD_INT 5
16326: EQUAL
16327: IFFALSE 16348
// points := [ 130 , 5 , 2 ] ;
16329: LD_ADDR_VAR 0 9
16333: PUSH
16334: LD_INT 130
16336: PUSH
16337: LD_INT 5
16339: PUSH
16340: LD_INT 2
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: LIST
16347: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16348: LD_VAR 0 6
16352: PPUSH
16353: CALL_OW 257
16357: PUSH
16358: LD_INT 8
16360: EQUAL
16361: IFFALSE 16382
// points := [ 35 , 35 , 30 ] ;
16363: LD_ADDR_VAR 0 9
16367: PUSH
16368: LD_INT 35
16370: PUSH
16371: LD_INT 35
16373: PUSH
16374: LD_INT 30
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: LIST
16381: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16382: LD_VAR 0 6
16386: PPUSH
16387: CALL_OW 257
16391: PUSH
16392: LD_INT 9
16394: EQUAL
16395: IFFALSE 16416
// points := [ 20 , 55 , 40 ] ;
16397: LD_ADDR_VAR 0 9
16401: PUSH
16402: LD_INT 20
16404: PUSH
16405: LD_INT 55
16407: PUSH
16408: LD_INT 40
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: LIST
16415: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16416: LD_VAR 0 6
16420: PPUSH
16421: CALL_OW 257
16425: PUSH
16426: LD_INT 12
16428: PUSH
16429: LD_INT 16
16431: PUSH
16432: EMPTY
16433: LIST
16434: LIST
16435: IN
16436: IFFALSE 16457
// points := [ 5 , 3 , 2 ] ;
16438: LD_ADDR_VAR 0 9
16442: PUSH
16443: LD_INT 5
16445: PUSH
16446: LD_INT 3
16448: PUSH
16449: LD_INT 2
16451: PUSH
16452: EMPTY
16453: LIST
16454: LIST
16455: LIST
16456: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16457: LD_VAR 0 6
16461: PPUSH
16462: CALL_OW 257
16466: PUSH
16467: LD_INT 17
16469: EQUAL
16470: IFFALSE 16491
// points := [ 100 , 50 , 75 ] ;
16472: LD_ADDR_VAR 0 9
16476: PUSH
16477: LD_INT 100
16479: PUSH
16480: LD_INT 50
16482: PUSH
16483: LD_INT 75
16485: PUSH
16486: EMPTY
16487: LIST
16488: LIST
16489: LIST
16490: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16491: LD_VAR 0 6
16495: PPUSH
16496: CALL_OW 257
16500: PUSH
16501: LD_INT 15
16503: EQUAL
16504: IFFALSE 16525
// points := [ 10 , 5 , 3 ] ;
16506: LD_ADDR_VAR 0 9
16510: PUSH
16511: LD_INT 10
16513: PUSH
16514: LD_INT 5
16516: PUSH
16517: LD_INT 3
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: LIST
16524: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16525: LD_VAR 0 6
16529: PPUSH
16530: CALL_OW 257
16534: PUSH
16535: LD_INT 14
16537: EQUAL
16538: IFFALSE 16559
// points := [ 10 , 0 , 0 ] ;
16540: LD_ADDR_VAR 0 9
16544: PUSH
16545: LD_INT 10
16547: PUSH
16548: LD_INT 0
16550: PUSH
16551: LD_INT 0
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: LIST
16558: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16559: LD_VAR 0 6
16563: PPUSH
16564: CALL_OW 257
16568: PUSH
16569: LD_INT 11
16571: EQUAL
16572: IFFALSE 16593
// points := [ 30 , 10 , 5 ] ;
16574: LD_ADDR_VAR 0 9
16578: PUSH
16579: LD_INT 30
16581: PUSH
16582: LD_INT 10
16584: PUSH
16585: LD_INT 5
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: LIST
16592: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16593: LD_VAR 0 1
16597: PPUSH
16598: LD_INT 5
16600: PPUSH
16601: CALL_OW 321
16605: PUSH
16606: LD_INT 2
16608: EQUAL
16609: IFFALSE 16626
// bpoints := bpoints * 1.8 ;
16611: LD_ADDR_VAR 0 10
16615: PUSH
16616: LD_VAR 0 10
16620: PUSH
16621: LD_REAL  1.80000000000000E+0000
16624: MUL
16625: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16626: LD_VAR 0 6
16630: PPUSH
16631: CALL_OW 257
16635: PUSH
16636: LD_INT 1
16638: PUSH
16639: LD_INT 2
16641: PUSH
16642: LD_INT 3
16644: PUSH
16645: LD_INT 4
16647: PUSH
16648: EMPTY
16649: LIST
16650: LIST
16651: LIST
16652: LIST
16653: IN
16654: PUSH
16655: LD_VAR 0 1
16659: PPUSH
16660: LD_INT 51
16662: PPUSH
16663: CALL_OW 321
16667: PUSH
16668: LD_INT 2
16670: EQUAL
16671: AND
16672: IFFALSE 16689
// bpoints := bpoints * 1.2 ;
16674: LD_ADDR_VAR 0 10
16678: PUSH
16679: LD_VAR 0 10
16683: PUSH
16684: LD_REAL  1.20000000000000E+0000
16687: MUL
16688: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16689: LD_VAR 0 6
16693: PPUSH
16694: CALL_OW 257
16698: PUSH
16699: LD_INT 5
16701: PUSH
16702: LD_INT 7
16704: PUSH
16705: LD_INT 9
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: LIST
16712: IN
16713: PUSH
16714: LD_VAR 0 1
16718: PPUSH
16719: LD_INT 52
16721: PPUSH
16722: CALL_OW 321
16726: PUSH
16727: LD_INT 2
16729: EQUAL
16730: AND
16731: IFFALSE 16748
// bpoints := bpoints * 1.5 ;
16733: LD_ADDR_VAR 0 10
16737: PUSH
16738: LD_VAR 0 10
16742: PUSH
16743: LD_REAL  1.50000000000000E+0000
16746: MUL
16747: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16748: LD_VAR 0 1
16752: PPUSH
16753: LD_INT 66
16755: PPUSH
16756: CALL_OW 321
16760: PUSH
16761: LD_INT 2
16763: EQUAL
16764: IFFALSE 16781
// bpoints := bpoints * 1.1 ;
16766: LD_ADDR_VAR 0 10
16770: PUSH
16771: LD_VAR 0 10
16775: PUSH
16776: LD_REAL  1.10000000000000E+0000
16779: MUL
16780: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16781: LD_ADDR_VAR 0 10
16785: PUSH
16786: LD_VAR 0 10
16790: PUSH
16791: LD_VAR 0 6
16795: PPUSH
16796: LD_INT 1
16798: PPUSH
16799: CALL_OW 259
16803: PUSH
16804: LD_REAL  1.15000000000000E+0000
16807: MUL
16808: MUL
16809: ST_TO_ADDR
// end ; unit_vehicle :
16810: GO 17638
16812: LD_INT 2
16814: DOUBLE
16815: EQUAL
16816: IFTRUE 16820
16818: GO 17626
16820: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16821: LD_VAR 0 6
16825: PPUSH
16826: CALL_OW 264
16830: PUSH
16831: LD_INT 2
16833: PUSH
16834: LD_INT 42
16836: PUSH
16837: LD_INT 24
16839: PUSH
16840: EMPTY
16841: LIST
16842: LIST
16843: LIST
16844: IN
16845: IFFALSE 16866
// points := [ 25 , 5 , 3 ] ;
16847: LD_ADDR_VAR 0 9
16851: PUSH
16852: LD_INT 25
16854: PUSH
16855: LD_INT 5
16857: PUSH
16858: LD_INT 3
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: LIST
16865: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16866: LD_VAR 0 6
16870: PPUSH
16871: CALL_OW 264
16875: PUSH
16876: LD_INT 4
16878: PUSH
16879: LD_INT 43
16881: PUSH
16882: LD_INT 25
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: LIST
16889: IN
16890: IFFALSE 16911
// points := [ 40 , 15 , 5 ] ;
16892: LD_ADDR_VAR 0 9
16896: PUSH
16897: LD_INT 40
16899: PUSH
16900: LD_INT 15
16902: PUSH
16903: LD_INT 5
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16911: LD_VAR 0 6
16915: PPUSH
16916: CALL_OW 264
16920: PUSH
16921: LD_INT 3
16923: PUSH
16924: LD_INT 23
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: IN
16931: IFFALSE 16952
// points := [ 7 , 25 , 8 ] ;
16933: LD_ADDR_VAR 0 9
16937: PUSH
16938: LD_INT 7
16940: PUSH
16941: LD_INT 25
16943: PUSH
16944: LD_INT 8
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: LIST
16951: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16952: LD_VAR 0 6
16956: PPUSH
16957: CALL_OW 264
16961: PUSH
16962: LD_INT 5
16964: PUSH
16965: LD_INT 27
16967: PUSH
16968: LD_INT 44
16970: PUSH
16971: EMPTY
16972: LIST
16973: LIST
16974: LIST
16975: IN
16976: IFFALSE 16997
// points := [ 14 , 50 , 16 ] ;
16978: LD_ADDR_VAR 0 9
16982: PUSH
16983: LD_INT 14
16985: PUSH
16986: LD_INT 50
16988: PUSH
16989: LD_INT 16
16991: PUSH
16992: EMPTY
16993: LIST
16994: LIST
16995: LIST
16996: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16997: LD_VAR 0 6
17001: PPUSH
17002: CALL_OW 264
17006: PUSH
17007: LD_INT 6
17009: PUSH
17010: LD_INT 46
17012: PUSH
17013: EMPTY
17014: LIST
17015: LIST
17016: IN
17017: IFFALSE 17038
// points := [ 32 , 120 , 70 ] ;
17019: LD_ADDR_VAR 0 9
17023: PUSH
17024: LD_INT 32
17026: PUSH
17027: LD_INT 120
17029: PUSH
17030: LD_INT 70
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: LIST
17037: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
17038: LD_VAR 0 6
17042: PPUSH
17043: CALL_OW 264
17047: PUSH
17048: LD_INT 7
17050: PUSH
17051: LD_INT 28
17053: PUSH
17054: LD_INT 45
17056: PUSH
17057: LD_INT 92
17059: PUSH
17060: EMPTY
17061: LIST
17062: LIST
17063: LIST
17064: LIST
17065: IN
17066: IFFALSE 17087
// points := [ 35 , 20 , 45 ] ;
17068: LD_ADDR_VAR 0 9
17072: PUSH
17073: LD_INT 35
17075: PUSH
17076: LD_INT 20
17078: PUSH
17079: LD_INT 45
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: LIST
17086: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
17087: LD_VAR 0 6
17091: PPUSH
17092: CALL_OW 264
17096: PUSH
17097: LD_INT 47
17099: PUSH
17100: EMPTY
17101: LIST
17102: IN
17103: IFFALSE 17124
// points := [ 67 , 45 , 75 ] ;
17105: LD_ADDR_VAR 0 9
17109: PUSH
17110: LD_INT 67
17112: PUSH
17113: LD_INT 45
17115: PUSH
17116: LD_INT 75
17118: PUSH
17119: EMPTY
17120: LIST
17121: LIST
17122: LIST
17123: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
17124: LD_VAR 0 6
17128: PPUSH
17129: CALL_OW 264
17133: PUSH
17134: LD_INT 26
17136: PUSH
17137: EMPTY
17138: LIST
17139: IN
17140: IFFALSE 17161
// points := [ 120 , 30 , 80 ] ;
17142: LD_ADDR_VAR 0 9
17146: PUSH
17147: LD_INT 120
17149: PUSH
17150: LD_INT 30
17152: PUSH
17153: LD_INT 80
17155: PUSH
17156: EMPTY
17157: LIST
17158: LIST
17159: LIST
17160: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
17161: LD_VAR 0 6
17165: PPUSH
17166: CALL_OW 264
17170: PUSH
17171: LD_INT 22
17173: PUSH
17174: EMPTY
17175: LIST
17176: IN
17177: IFFALSE 17198
// points := [ 40 , 1 , 1 ] ;
17179: LD_ADDR_VAR 0 9
17183: PUSH
17184: LD_INT 40
17186: PUSH
17187: LD_INT 1
17189: PUSH
17190: LD_INT 1
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: LIST
17197: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
17198: LD_VAR 0 6
17202: PPUSH
17203: CALL_OW 264
17207: PUSH
17208: LD_INT 29
17210: PUSH
17211: EMPTY
17212: LIST
17213: IN
17214: IFFALSE 17235
// points := [ 70 , 200 , 400 ] ;
17216: LD_ADDR_VAR 0 9
17220: PUSH
17221: LD_INT 70
17223: PUSH
17224: LD_INT 200
17226: PUSH
17227: LD_INT 400
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: LIST
17234: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17235: LD_VAR 0 6
17239: PPUSH
17240: CALL_OW 264
17244: PUSH
17245: LD_INT 14
17247: PUSH
17248: LD_INT 53
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: IN
17255: IFFALSE 17276
// points := [ 40 , 10 , 20 ] ;
17257: LD_ADDR_VAR 0 9
17261: PUSH
17262: LD_INT 40
17264: PUSH
17265: LD_INT 10
17267: PUSH
17268: LD_INT 20
17270: PUSH
17271: EMPTY
17272: LIST
17273: LIST
17274: LIST
17275: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17276: LD_VAR 0 6
17280: PPUSH
17281: CALL_OW 264
17285: PUSH
17286: LD_INT 9
17288: PUSH
17289: EMPTY
17290: LIST
17291: IN
17292: IFFALSE 17313
// points := [ 5 , 70 , 20 ] ;
17294: LD_ADDR_VAR 0 9
17298: PUSH
17299: LD_INT 5
17301: PUSH
17302: LD_INT 70
17304: PUSH
17305: LD_INT 20
17307: PUSH
17308: EMPTY
17309: LIST
17310: LIST
17311: LIST
17312: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17313: LD_VAR 0 6
17317: PPUSH
17318: CALL_OW 264
17322: PUSH
17323: LD_INT 10
17325: PUSH
17326: EMPTY
17327: LIST
17328: IN
17329: IFFALSE 17350
// points := [ 35 , 110 , 70 ] ;
17331: LD_ADDR_VAR 0 9
17335: PUSH
17336: LD_INT 35
17338: PUSH
17339: LD_INT 110
17341: PUSH
17342: LD_INT 70
17344: PUSH
17345: EMPTY
17346: LIST
17347: LIST
17348: LIST
17349: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17350: LD_VAR 0 6
17354: PPUSH
17355: CALL_OW 265
17359: PUSH
17360: LD_INT 25
17362: EQUAL
17363: IFFALSE 17384
// points := [ 80 , 65 , 100 ] ;
17365: LD_ADDR_VAR 0 9
17369: PUSH
17370: LD_INT 80
17372: PUSH
17373: LD_INT 65
17375: PUSH
17376: LD_INT 100
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17384: LD_VAR 0 6
17388: PPUSH
17389: CALL_OW 263
17393: PUSH
17394: LD_INT 1
17396: EQUAL
17397: IFFALSE 17432
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17399: LD_ADDR_VAR 0 10
17403: PUSH
17404: LD_VAR 0 10
17408: PUSH
17409: LD_VAR 0 6
17413: PPUSH
17414: CALL_OW 311
17418: PPUSH
17419: LD_INT 3
17421: PPUSH
17422: CALL_OW 259
17426: PUSH
17427: LD_INT 4
17429: MUL
17430: MUL
17431: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17432: LD_VAR 0 6
17436: PPUSH
17437: CALL_OW 263
17441: PUSH
17442: LD_INT 2
17444: EQUAL
17445: IFFALSE 17496
// begin j := IsControledBy ( i ) ;
17447: LD_ADDR_VAR 0 7
17451: PUSH
17452: LD_VAR 0 6
17456: PPUSH
17457: CALL_OW 312
17461: ST_TO_ADDR
// if j then
17462: LD_VAR 0 7
17466: IFFALSE 17496
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17468: LD_ADDR_VAR 0 10
17472: PUSH
17473: LD_VAR 0 10
17477: PUSH
17478: LD_VAR 0 7
17482: PPUSH
17483: LD_INT 3
17485: PPUSH
17486: CALL_OW 259
17490: PUSH
17491: LD_INT 3
17493: MUL
17494: MUL
17495: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17496: LD_VAR 0 6
17500: PPUSH
17501: CALL_OW 264
17505: PUSH
17506: LD_INT 5
17508: PUSH
17509: LD_INT 6
17511: PUSH
17512: LD_INT 46
17514: PUSH
17515: LD_INT 44
17517: PUSH
17518: LD_INT 47
17520: PUSH
17521: LD_INT 45
17523: PUSH
17524: LD_INT 28
17526: PUSH
17527: LD_INT 7
17529: PUSH
17530: LD_INT 27
17532: PUSH
17533: LD_INT 29
17535: PUSH
17536: EMPTY
17537: LIST
17538: LIST
17539: LIST
17540: LIST
17541: LIST
17542: LIST
17543: LIST
17544: LIST
17545: LIST
17546: LIST
17547: IN
17548: PUSH
17549: LD_VAR 0 1
17553: PPUSH
17554: LD_INT 52
17556: PPUSH
17557: CALL_OW 321
17561: PUSH
17562: LD_INT 2
17564: EQUAL
17565: AND
17566: IFFALSE 17583
// bpoints := bpoints * 1.2 ;
17568: LD_ADDR_VAR 0 10
17572: PUSH
17573: LD_VAR 0 10
17577: PUSH
17578: LD_REAL  1.20000000000000E+0000
17581: MUL
17582: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17583: LD_VAR 0 6
17587: PPUSH
17588: CALL_OW 264
17592: PUSH
17593: LD_INT 6
17595: PUSH
17596: LD_INT 46
17598: PUSH
17599: LD_INT 47
17601: PUSH
17602: EMPTY
17603: LIST
17604: LIST
17605: LIST
17606: IN
17607: IFFALSE 17624
// bpoints := bpoints * 1.2 ;
17609: LD_ADDR_VAR 0 10
17613: PUSH
17614: LD_VAR 0 10
17618: PUSH
17619: LD_REAL  1.20000000000000E+0000
17622: MUL
17623: ST_TO_ADDR
// end ; unit_building :
17624: GO 17638
17626: LD_INT 3
17628: DOUBLE
17629: EQUAL
17630: IFTRUE 17634
17632: GO 17637
17634: POP
// ; end ;
17635: GO 17638
17637: POP
// for j = 1 to 3 do
17638: LD_ADDR_VAR 0 7
17642: PUSH
17643: DOUBLE
17644: LD_INT 1
17646: DEC
17647: ST_TO_ADDR
17648: LD_INT 3
17650: PUSH
17651: FOR_TO
17652: IFFALSE 17705
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17654: LD_ADDR_VAR 0 5
17658: PUSH
17659: LD_VAR 0 5
17663: PPUSH
17664: LD_VAR 0 7
17668: PPUSH
17669: LD_VAR 0 5
17673: PUSH
17674: LD_VAR 0 7
17678: ARRAY
17679: PUSH
17680: LD_VAR 0 9
17684: PUSH
17685: LD_VAR 0 7
17689: ARRAY
17690: PUSH
17691: LD_VAR 0 10
17695: MUL
17696: PLUS
17697: PPUSH
17698: CALL_OW 1
17702: ST_TO_ADDR
17703: GO 17651
17705: POP
17706: POP
// end ;
17707: GO 16186
17709: POP
17710: POP
// result := Replace ( result , 4 , tmp ) ;
17711: LD_ADDR_VAR 0 5
17715: PUSH
17716: LD_VAR 0 5
17720: PPUSH
17721: LD_INT 4
17723: PPUSH
17724: LD_VAR 0 8
17728: PPUSH
17729: CALL_OW 1
17733: ST_TO_ADDR
// end ;
17734: LD_VAR 0 5
17738: RET
// export function DangerAtRange ( unit , range ) ; begin
17739: LD_INT 0
17741: PPUSH
// if not unit then
17742: LD_VAR 0 1
17746: NOT
17747: IFFALSE 17751
// exit ;
17749: GO 17796
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17751: LD_ADDR_VAR 0 3
17755: PUSH
17756: LD_VAR 0 1
17760: PPUSH
17761: CALL_OW 255
17765: PPUSH
17766: LD_VAR 0 1
17770: PPUSH
17771: CALL_OW 250
17775: PPUSH
17776: LD_VAR 0 1
17780: PPUSH
17781: CALL_OW 251
17785: PPUSH
17786: LD_VAR 0 2
17790: PPUSH
17791: CALL 16038 0 4
17795: ST_TO_ADDR
// end ;
17796: LD_VAR 0 3
17800: RET
// export function DangerInArea ( side , area ) ; begin
17801: LD_INT 0
17803: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17804: LD_ADDR_VAR 0 3
17808: PUSH
17809: LD_VAR 0 2
17813: PPUSH
17814: LD_INT 81
17816: PUSH
17817: LD_VAR 0 1
17821: PUSH
17822: EMPTY
17823: LIST
17824: LIST
17825: PPUSH
17826: CALL_OW 70
17830: ST_TO_ADDR
// end ;
17831: LD_VAR 0 3
17835: RET
// export function IsExtension ( b ) ; begin
17836: LD_INT 0
17838: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17839: LD_ADDR_VAR 0 2
17843: PUSH
17844: LD_VAR 0 1
17848: PUSH
17849: LD_INT 23
17851: PUSH
17852: LD_INT 20
17854: PUSH
17855: LD_INT 22
17857: PUSH
17858: LD_INT 17
17860: PUSH
17861: LD_INT 24
17863: PUSH
17864: LD_INT 21
17866: PUSH
17867: LD_INT 19
17869: PUSH
17870: LD_INT 16
17872: PUSH
17873: LD_INT 25
17875: PUSH
17876: LD_INT 18
17878: PUSH
17879: EMPTY
17880: LIST
17881: LIST
17882: LIST
17883: LIST
17884: LIST
17885: LIST
17886: LIST
17887: LIST
17888: LIST
17889: LIST
17890: IN
17891: ST_TO_ADDR
// end ;
17892: LD_VAR 0 2
17896: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17897: LD_INT 0
17899: PPUSH
17900: PPUSH
17901: PPUSH
// result := [ ] ;
17902: LD_ADDR_VAR 0 4
17906: PUSH
17907: EMPTY
17908: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17909: LD_ADDR_VAR 0 5
17913: PUSH
17914: LD_VAR 0 2
17918: PPUSH
17919: LD_INT 21
17921: PUSH
17922: LD_INT 3
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: PPUSH
17929: CALL_OW 70
17933: ST_TO_ADDR
// if not tmp then
17934: LD_VAR 0 5
17938: NOT
17939: IFFALSE 17943
// exit ;
17941: GO 18007
// if checkLink then
17943: LD_VAR 0 3
17947: IFFALSE 17997
// begin for i in tmp do
17949: LD_ADDR_VAR 0 6
17953: PUSH
17954: LD_VAR 0 5
17958: PUSH
17959: FOR_IN
17960: IFFALSE 17995
// if GetBase ( i ) <> base then
17962: LD_VAR 0 6
17966: PPUSH
17967: CALL_OW 274
17971: PUSH
17972: LD_VAR 0 1
17976: NONEQUAL
17977: IFFALSE 17993
// ComLinkToBase ( base , i ) ;
17979: LD_VAR 0 1
17983: PPUSH
17984: LD_VAR 0 6
17988: PPUSH
17989: CALL_OW 169
17993: GO 17959
17995: POP
17996: POP
// end ; result := tmp ;
17997: LD_ADDR_VAR 0 4
18001: PUSH
18002: LD_VAR 0 5
18006: ST_TO_ADDR
// end ;
18007: LD_VAR 0 4
18011: RET
// export function ComComplete ( units , b ) ; var i ; begin
18012: LD_INT 0
18014: PPUSH
18015: PPUSH
// if not units then
18016: LD_VAR 0 1
18020: NOT
18021: IFFALSE 18025
// exit ;
18023: GO 18115
// for i in units do
18025: LD_ADDR_VAR 0 4
18029: PUSH
18030: LD_VAR 0 1
18034: PUSH
18035: FOR_IN
18036: IFFALSE 18113
// if BuildingStatus ( b ) = bs_build then
18038: LD_VAR 0 2
18042: PPUSH
18043: CALL_OW 461
18047: PUSH
18048: LD_INT 1
18050: EQUAL
18051: IFFALSE 18111
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
18053: LD_VAR 0 4
18057: PPUSH
18058: LD_STRING h
18060: PUSH
18061: LD_VAR 0 2
18065: PPUSH
18066: CALL_OW 250
18070: PUSH
18071: LD_VAR 0 2
18075: PPUSH
18076: CALL_OW 251
18080: PUSH
18081: LD_VAR 0 2
18085: PUSH
18086: LD_INT 0
18088: PUSH
18089: LD_INT 0
18091: PUSH
18092: LD_INT 0
18094: PUSH
18095: EMPTY
18096: LIST
18097: LIST
18098: LIST
18099: LIST
18100: LIST
18101: LIST
18102: LIST
18103: PUSH
18104: EMPTY
18105: LIST
18106: PPUSH
18107: CALL_OW 446
18111: GO 18035
18113: POP
18114: POP
// end ;
18115: LD_VAR 0 3
18119: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
18120: LD_INT 0
18122: PPUSH
18123: PPUSH
18124: PPUSH
18125: PPUSH
18126: PPUSH
18127: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
18128: LD_VAR 0 1
18132: NOT
18133: PUSH
18134: LD_VAR 0 1
18138: PPUSH
18139: CALL_OW 263
18143: PUSH
18144: LD_INT 2
18146: NONEQUAL
18147: OR
18148: IFFALSE 18152
// exit ;
18150: GO 18468
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
18152: LD_ADDR_VAR 0 6
18156: PUSH
18157: LD_INT 22
18159: PUSH
18160: LD_VAR 0 1
18164: PPUSH
18165: CALL_OW 255
18169: PUSH
18170: EMPTY
18171: LIST
18172: LIST
18173: PUSH
18174: LD_INT 2
18176: PUSH
18177: LD_INT 30
18179: PUSH
18180: LD_INT 36
18182: PUSH
18183: EMPTY
18184: LIST
18185: LIST
18186: PUSH
18187: LD_INT 34
18189: PUSH
18190: LD_INT 31
18192: PUSH
18193: EMPTY
18194: LIST
18195: LIST
18196: PUSH
18197: EMPTY
18198: LIST
18199: LIST
18200: LIST
18201: PUSH
18202: EMPTY
18203: LIST
18204: LIST
18205: PPUSH
18206: CALL_OW 69
18210: ST_TO_ADDR
// if not tmp then
18211: LD_VAR 0 6
18215: NOT
18216: IFFALSE 18220
// exit ;
18218: GO 18468
// result := [ ] ;
18220: LD_ADDR_VAR 0 2
18224: PUSH
18225: EMPTY
18226: ST_TO_ADDR
// for i in tmp do
18227: LD_ADDR_VAR 0 3
18231: PUSH
18232: LD_VAR 0 6
18236: PUSH
18237: FOR_IN
18238: IFFALSE 18309
// begin t := UnitsInside ( i ) ;
18240: LD_ADDR_VAR 0 4
18244: PUSH
18245: LD_VAR 0 3
18249: PPUSH
18250: CALL_OW 313
18254: ST_TO_ADDR
// if t then
18255: LD_VAR 0 4
18259: IFFALSE 18307
// for j in t do
18261: LD_ADDR_VAR 0 7
18265: PUSH
18266: LD_VAR 0 4
18270: PUSH
18271: FOR_IN
18272: IFFALSE 18305
// result := Replace ( result , result + 1 , j ) ;
18274: LD_ADDR_VAR 0 2
18278: PUSH
18279: LD_VAR 0 2
18283: PPUSH
18284: LD_VAR 0 2
18288: PUSH
18289: LD_INT 1
18291: PLUS
18292: PPUSH
18293: LD_VAR 0 7
18297: PPUSH
18298: CALL_OW 1
18302: ST_TO_ADDR
18303: GO 18271
18305: POP
18306: POP
// end ;
18307: GO 18237
18309: POP
18310: POP
// if not result then
18311: LD_VAR 0 2
18315: NOT
18316: IFFALSE 18320
// exit ;
18318: GO 18468
// mech := result [ 1 ] ;
18320: LD_ADDR_VAR 0 5
18324: PUSH
18325: LD_VAR 0 2
18329: PUSH
18330: LD_INT 1
18332: ARRAY
18333: ST_TO_ADDR
// if result > 1 then
18334: LD_VAR 0 2
18338: PUSH
18339: LD_INT 1
18341: GREATER
18342: IFFALSE 18454
// begin for i = 2 to result do
18344: LD_ADDR_VAR 0 3
18348: PUSH
18349: DOUBLE
18350: LD_INT 2
18352: DEC
18353: ST_TO_ADDR
18354: LD_VAR 0 2
18358: PUSH
18359: FOR_TO
18360: IFFALSE 18452
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18362: LD_ADDR_VAR 0 4
18366: PUSH
18367: LD_VAR 0 2
18371: PUSH
18372: LD_VAR 0 3
18376: ARRAY
18377: PPUSH
18378: LD_INT 3
18380: PPUSH
18381: CALL_OW 259
18385: PUSH
18386: LD_VAR 0 2
18390: PUSH
18391: LD_VAR 0 3
18395: ARRAY
18396: PPUSH
18397: CALL_OW 432
18401: MINUS
18402: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18403: LD_VAR 0 4
18407: PUSH
18408: LD_VAR 0 5
18412: PPUSH
18413: LD_INT 3
18415: PPUSH
18416: CALL_OW 259
18420: PUSH
18421: LD_VAR 0 5
18425: PPUSH
18426: CALL_OW 432
18430: MINUS
18431: GREATEREQUAL
18432: IFFALSE 18450
// mech := result [ i ] ;
18434: LD_ADDR_VAR 0 5
18438: PUSH
18439: LD_VAR 0 2
18443: PUSH
18444: LD_VAR 0 3
18448: ARRAY
18449: ST_TO_ADDR
// end ;
18450: GO 18359
18452: POP
18453: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18454: LD_VAR 0 1
18458: PPUSH
18459: LD_VAR 0 5
18463: PPUSH
18464: CALL_OW 135
// end ;
18468: LD_VAR 0 2
18472: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18473: LD_INT 0
18475: PPUSH
18476: PPUSH
18477: PPUSH
18478: PPUSH
18479: PPUSH
18480: PPUSH
18481: PPUSH
18482: PPUSH
18483: PPUSH
18484: PPUSH
18485: PPUSH
18486: PPUSH
18487: PPUSH
// result := [ ] ;
18488: LD_ADDR_VAR 0 7
18492: PUSH
18493: EMPTY
18494: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18495: LD_VAR 0 1
18499: PPUSH
18500: CALL_OW 266
18504: PUSH
18505: LD_INT 0
18507: PUSH
18508: LD_INT 1
18510: PUSH
18511: EMPTY
18512: LIST
18513: LIST
18514: IN
18515: NOT
18516: IFFALSE 18520
// exit ;
18518: GO 20154
// if name then
18520: LD_VAR 0 3
18524: IFFALSE 18540
// SetBName ( base_dep , name ) ;
18526: LD_VAR 0 1
18530: PPUSH
18531: LD_VAR 0 3
18535: PPUSH
18536: CALL_OW 500
// base := GetBase ( base_dep ) ;
18540: LD_ADDR_VAR 0 15
18544: PUSH
18545: LD_VAR 0 1
18549: PPUSH
18550: CALL_OW 274
18554: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18555: LD_ADDR_VAR 0 16
18559: PUSH
18560: LD_VAR 0 1
18564: PPUSH
18565: CALL_OW 255
18569: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18570: LD_ADDR_VAR 0 17
18574: PUSH
18575: LD_VAR 0 1
18579: PPUSH
18580: CALL_OW 248
18584: ST_TO_ADDR
// if sources then
18585: LD_VAR 0 5
18589: IFFALSE 18636
// for i = 1 to 3 do
18591: LD_ADDR_VAR 0 8
18595: PUSH
18596: DOUBLE
18597: LD_INT 1
18599: DEC
18600: ST_TO_ADDR
18601: LD_INT 3
18603: PUSH
18604: FOR_TO
18605: IFFALSE 18634
// AddResourceType ( base , i , sources [ i ] ) ;
18607: LD_VAR 0 15
18611: PPUSH
18612: LD_VAR 0 8
18616: PPUSH
18617: LD_VAR 0 5
18621: PUSH
18622: LD_VAR 0 8
18626: ARRAY
18627: PPUSH
18628: CALL_OW 276
18632: GO 18604
18634: POP
18635: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18636: LD_ADDR_VAR 0 18
18640: PUSH
18641: LD_VAR 0 15
18645: PPUSH
18646: LD_VAR 0 2
18650: PPUSH
18651: LD_INT 1
18653: PPUSH
18654: CALL 17897 0 3
18658: ST_TO_ADDR
// InitHc ;
18659: CALL_OW 19
// InitUc ;
18663: CALL_OW 18
// uc_side := side ;
18667: LD_ADDR_OWVAR 20
18671: PUSH
18672: LD_VAR 0 16
18676: ST_TO_ADDR
// uc_nation := nation ;
18677: LD_ADDR_OWVAR 21
18681: PUSH
18682: LD_VAR 0 17
18686: ST_TO_ADDR
// if buildings then
18687: LD_VAR 0 18
18691: IFFALSE 20013
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18693: LD_ADDR_VAR 0 19
18697: PUSH
18698: LD_VAR 0 18
18702: PPUSH
18703: LD_INT 2
18705: PUSH
18706: LD_INT 30
18708: PUSH
18709: LD_INT 29
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: PUSH
18716: LD_INT 30
18718: PUSH
18719: LD_INT 30
18721: PUSH
18722: EMPTY
18723: LIST
18724: LIST
18725: PUSH
18726: EMPTY
18727: LIST
18728: LIST
18729: LIST
18730: PPUSH
18731: CALL_OW 72
18735: ST_TO_ADDR
// if tmp then
18736: LD_VAR 0 19
18740: IFFALSE 18788
// for i in tmp do
18742: LD_ADDR_VAR 0 8
18746: PUSH
18747: LD_VAR 0 19
18751: PUSH
18752: FOR_IN
18753: IFFALSE 18786
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18755: LD_VAR 0 8
18759: PPUSH
18760: CALL_OW 250
18764: PPUSH
18765: LD_VAR 0 8
18769: PPUSH
18770: CALL_OW 251
18774: PPUSH
18775: LD_VAR 0 16
18779: PPUSH
18780: CALL_OW 441
18784: GO 18752
18786: POP
18787: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18788: LD_VAR 0 18
18792: PPUSH
18793: LD_INT 2
18795: PUSH
18796: LD_INT 30
18798: PUSH
18799: LD_INT 32
18801: PUSH
18802: EMPTY
18803: LIST
18804: LIST
18805: PUSH
18806: LD_INT 30
18808: PUSH
18809: LD_INT 33
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: PUSH
18816: EMPTY
18817: LIST
18818: LIST
18819: LIST
18820: PPUSH
18821: CALL_OW 72
18825: IFFALSE 18913
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18827: LD_ADDR_VAR 0 8
18831: PUSH
18832: LD_VAR 0 18
18836: PPUSH
18837: LD_INT 2
18839: PUSH
18840: LD_INT 30
18842: PUSH
18843: LD_INT 32
18845: PUSH
18846: EMPTY
18847: LIST
18848: LIST
18849: PUSH
18850: LD_INT 30
18852: PUSH
18853: LD_INT 33
18855: PUSH
18856: EMPTY
18857: LIST
18858: LIST
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: LIST
18864: PPUSH
18865: CALL_OW 72
18869: PUSH
18870: FOR_IN
18871: IFFALSE 18911
// begin if not GetBWeapon ( i ) then
18873: LD_VAR 0 8
18877: PPUSH
18878: CALL_OW 269
18882: NOT
18883: IFFALSE 18909
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18885: LD_VAR 0 8
18889: PPUSH
18890: LD_VAR 0 8
18894: PPUSH
18895: LD_VAR 0 2
18899: PPUSH
18900: CALL 20159 0 2
18904: PPUSH
18905: CALL_OW 431
// end ;
18909: GO 18870
18911: POP
18912: POP
// end ; for i = 1 to personel do
18913: LD_ADDR_VAR 0 8
18917: PUSH
18918: DOUBLE
18919: LD_INT 1
18921: DEC
18922: ST_TO_ADDR
18923: LD_VAR 0 6
18927: PUSH
18928: FOR_TO
18929: IFFALSE 19993
// begin if i > 4 then
18931: LD_VAR 0 8
18935: PUSH
18936: LD_INT 4
18938: GREATER
18939: IFFALSE 18943
// break ;
18941: GO 19993
// case i of 1 :
18943: LD_VAR 0 8
18947: PUSH
18948: LD_INT 1
18950: DOUBLE
18951: EQUAL
18952: IFTRUE 18956
18954: GO 19036
18956: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18957: LD_ADDR_VAR 0 12
18961: PUSH
18962: LD_VAR 0 18
18966: PPUSH
18967: LD_INT 22
18969: PUSH
18970: LD_VAR 0 16
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: PUSH
18979: LD_INT 58
18981: PUSH
18982: EMPTY
18983: LIST
18984: PUSH
18985: LD_INT 2
18987: PUSH
18988: LD_INT 30
18990: PUSH
18991: LD_INT 32
18993: PUSH
18994: EMPTY
18995: LIST
18996: LIST
18997: PUSH
18998: LD_INT 30
19000: PUSH
19001: LD_INT 4
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: PUSH
19008: LD_INT 30
19010: PUSH
19011: LD_INT 5
19013: PUSH
19014: EMPTY
19015: LIST
19016: LIST
19017: PUSH
19018: EMPTY
19019: LIST
19020: LIST
19021: LIST
19022: LIST
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: LIST
19028: PPUSH
19029: CALL_OW 72
19033: ST_TO_ADDR
19034: GO 19258
19036: LD_INT 2
19038: DOUBLE
19039: EQUAL
19040: IFTRUE 19044
19042: GO 19106
19044: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
19045: LD_ADDR_VAR 0 12
19049: PUSH
19050: LD_VAR 0 18
19054: PPUSH
19055: LD_INT 22
19057: PUSH
19058: LD_VAR 0 16
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: PUSH
19067: LD_INT 2
19069: PUSH
19070: LD_INT 30
19072: PUSH
19073: LD_INT 0
19075: PUSH
19076: EMPTY
19077: LIST
19078: LIST
19079: PUSH
19080: LD_INT 30
19082: PUSH
19083: LD_INT 1
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: PUSH
19090: EMPTY
19091: LIST
19092: LIST
19093: LIST
19094: PUSH
19095: EMPTY
19096: LIST
19097: LIST
19098: PPUSH
19099: CALL_OW 72
19103: ST_TO_ADDR
19104: GO 19258
19106: LD_INT 3
19108: DOUBLE
19109: EQUAL
19110: IFTRUE 19114
19112: GO 19176
19114: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
19115: LD_ADDR_VAR 0 12
19119: PUSH
19120: LD_VAR 0 18
19124: PPUSH
19125: LD_INT 22
19127: PUSH
19128: LD_VAR 0 16
19132: PUSH
19133: EMPTY
19134: LIST
19135: LIST
19136: PUSH
19137: LD_INT 2
19139: PUSH
19140: LD_INT 30
19142: PUSH
19143: LD_INT 2
19145: PUSH
19146: EMPTY
19147: LIST
19148: LIST
19149: PUSH
19150: LD_INT 30
19152: PUSH
19153: LD_INT 3
19155: PUSH
19156: EMPTY
19157: LIST
19158: LIST
19159: PUSH
19160: EMPTY
19161: LIST
19162: LIST
19163: LIST
19164: PUSH
19165: EMPTY
19166: LIST
19167: LIST
19168: PPUSH
19169: CALL_OW 72
19173: ST_TO_ADDR
19174: GO 19258
19176: LD_INT 4
19178: DOUBLE
19179: EQUAL
19180: IFTRUE 19184
19182: GO 19257
19184: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
19185: LD_ADDR_VAR 0 12
19189: PUSH
19190: LD_VAR 0 18
19194: PPUSH
19195: LD_INT 22
19197: PUSH
19198: LD_VAR 0 16
19202: PUSH
19203: EMPTY
19204: LIST
19205: LIST
19206: PUSH
19207: LD_INT 2
19209: PUSH
19210: LD_INT 30
19212: PUSH
19213: LD_INT 6
19215: PUSH
19216: EMPTY
19217: LIST
19218: LIST
19219: PUSH
19220: LD_INT 30
19222: PUSH
19223: LD_INT 7
19225: PUSH
19226: EMPTY
19227: LIST
19228: LIST
19229: PUSH
19230: LD_INT 30
19232: PUSH
19233: LD_INT 8
19235: PUSH
19236: EMPTY
19237: LIST
19238: LIST
19239: PUSH
19240: EMPTY
19241: LIST
19242: LIST
19243: LIST
19244: LIST
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: PPUSH
19250: CALL_OW 72
19254: ST_TO_ADDR
19255: GO 19258
19257: POP
// if i = 1 then
19258: LD_VAR 0 8
19262: PUSH
19263: LD_INT 1
19265: EQUAL
19266: IFFALSE 19377
// begin tmp := [ ] ;
19268: LD_ADDR_VAR 0 19
19272: PUSH
19273: EMPTY
19274: ST_TO_ADDR
// for j in f do
19275: LD_ADDR_VAR 0 9
19279: PUSH
19280: LD_VAR 0 12
19284: PUSH
19285: FOR_IN
19286: IFFALSE 19359
// if GetBType ( j ) = b_bunker then
19288: LD_VAR 0 9
19292: PPUSH
19293: CALL_OW 266
19297: PUSH
19298: LD_INT 32
19300: EQUAL
19301: IFFALSE 19328
// tmp := Insert ( tmp , 1 , j ) else
19303: LD_ADDR_VAR 0 19
19307: PUSH
19308: LD_VAR 0 19
19312: PPUSH
19313: LD_INT 1
19315: PPUSH
19316: LD_VAR 0 9
19320: PPUSH
19321: CALL_OW 2
19325: ST_TO_ADDR
19326: GO 19357
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19328: LD_ADDR_VAR 0 19
19332: PUSH
19333: LD_VAR 0 19
19337: PPUSH
19338: LD_VAR 0 19
19342: PUSH
19343: LD_INT 1
19345: PLUS
19346: PPUSH
19347: LD_VAR 0 9
19351: PPUSH
19352: CALL_OW 2
19356: ST_TO_ADDR
19357: GO 19285
19359: POP
19360: POP
// if tmp then
19361: LD_VAR 0 19
19365: IFFALSE 19377
// f := tmp ;
19367: LD_ADDR_VAR 0 12
19371: PUSH
19372: LD_VAR 0 19
19376: ST_TO_ADDR
// end ; x := personel [ i ] ;
19377: LD_ADDR_VAR 0 13
19381: PUSH
19382: LD_VAR 0 6
19386: PUSH
19387: LD_VAR 0 8
19391: ARRAY
19392: ST_TO_ADDR
// if x = - 1 then
19393: LD_VAR 0 13
19397: PUSH
19398: LD_INT 1
19400: NEG
19401: EQUAL
19402: IFFALSE 19611
// begin for j in f do
19404: LD_ADDR_VAR 0 9
19408: PUSH
19409: LD_VAR 0 12
19413: PUSH
19414: FOR_IN
19415: IFFALSE 19607
// repeat InitHc ;
19417: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19421: LD_VAR 0 9
19425: PPUSH
19426: CALL_OW 266
19430: PUSH
19431: LD_INT 5
19433: EQUAL
19434: IFFALSE 19504
// begin if UnitsInside ( j ) < 3 then
19436: LD_VAR 0 9
19440: PPUSH
19441: CALL_OW 313
19445: PUSH
19446: LD_INT 3
19448: LESS
19449: IFFALSE 19485
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19451: LD_INT 0
19453: PPUSH
19454: LD_INT 5
19456: PUSH
19457: LD_INT 8
19459: PUSH
19460: LD_INT 9
19462: PUSH
19463: EMPTY
19464: LIST
19465: LIST
19466: LIST
19467: PUSH
19468: LD_VAR 0 17
19472: ARRAY
19473: PPUSH
19474: LD_VAR 0 4
19478: PPUSH
19479: CALL_OW 380
19483: GO 19502
// PrepareHuman ( false , i , skill ) ;
19485: LD_INT 0
19487: PPUSH
19488: LD_VAR 0 8
19492: PPUSH
19493: LD_VAR 0 4
19497: PPUSH
19498: CALL_OW 380
// end else
19502: GO 19521
// PrepareHuman ( false , i , skill ) ;
19504: LD_INT 0
19506: PPUSH
19507: LD_VAR 0 8
19511: PPUSH
19512: LD_VAR 0 4
19516: PPUSH
19517: CALL_OW 380
// un := CreateHuman ;
19521: LD_ADDR_VAR 0 14
19525: PUSH
19526: CALL_OW 44
19530: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19531: LD_ADDR_VAR 0 7
19535: PUSH
19536: LD_VAR 0 7
19540: PPUSH
19541: LD_INT 1
19543: PPUSH
19544: LD_VAR 0 14
19548: PPUSH
19549: CALL_OW 2
19553: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19554: LD_VAR 0 14
19558: PPUSH
19559: LD_VAR 0 9
19563: PPUSH
19564: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19568: LD_VAR 0 9
19572: PPUSH
19573: CALL_OW 313
19577: PUSH
19578: LD_INT 6
19580: EQUAL
19581: PUSH
19582: LD_VAR 0 9
19586: PPUSH
19587: CALL_OW 266
19591: PUSH
19592: LD_INT 32
19594: PUSH
19595: LD_INT 31
19597: PUSH
19598: EMPTY
19599: LIST
19600: LIST
19601: IN
19602: OR
19603: IFFALSE 19417
19605: GO 19414
19607: POP
19608: POP
// end else
19609: GO 19991
// for j = 1 to x do
19611: LD_ADDR_VAR 0 9
19615: PUSH
19616: DOUBLE
19617: LD_INT 1
19619: DEC
19620: ST_TO_ADDR
19621: LD_VAR 0 13
19625: PUSH
19626: FOR_TO
19627: IFFALSE 19989
// begin InitHc ;
19629: CALL_OW 19
// if not f then
19633: LD_VAR 0 12
19637: NOT
19638: IFFALSE 19727
// begin PrepareHuman ( false , i , skill ) ;
19640: LD_INT 0
19642: PPUSH
19643: LD_VAR 0 8
19647: PPUSH
19648: LD_VAR 0 4
19652: PPUSH
19653: CALL_OW 380
// un := CreateHuman ;
19657: LD_ADDR_VAR 0 14
19661: PUSH
19662: CALL_OW 44
19666: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19667: LD_ADDR_VAR 0 7
19671: PUSH
19672: LD_VAR 0 7
19676: PPUSH
19677: LD_INT 1
19679: PPUSH
19680: LD_VAR 0 14
19684: PPUSH
19685: CALL_OW 2
19689: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19690: LD_VAR 0 14
19694: PPUSH
19695: LD_VAR 0 1
19699: PPUSH
19700: CALL_OW 250
19704: PPUSH
19705: LD_VAR 0 1
19709: PPUSH
19710: CALL_OW 251
19714: PPUSH
19715: LD_INT 10
19717: PPUSH
19718: LD_INT 0
19720: PPUSH
19721: CALL_OW 50
// continue ;
19725: GO 19626
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19727: LD_VAR 0 12
19731: PUSH
19732: LD_INT 1
19734: ARRAY
19735: PPUSH
19736: CALL_OW 313
19740: PUSH
19741: LD_VAR 0 12
19745: PUSH
19746: LD_INT 1
19748: ARRAY
19749: PPUSH
19750: CALL_OW 266
19754: PUSH
19755: LD_INT 32
19757: PUSH
19758: LD_INT 31
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: IN
19765: AND
19766: PUSH
19767: LD_VAR 0 12
19771: PUSH
19772: LD_INT 1
19774: ARRAY
19775: PPUSH
19776: CALL_OW 313
19780: PUSH
19781: LD_INT 6
19783: EQUAL
19784: OR
19785: IFFALSE 19805
// f := Delete ( f , 1 ) ;
19787: LD_ADDR_VAR 0 12
19791: PUSH
19792: LD_VAR 0 12
19796: PPUSH
19797: LD_INT 1
19799: PPUSH
19800: CALL_OW 3
19804: ST_TO_ADDR
// if not f then
19805: LD_VAR 0 12
19809: NOT
19810: IFFALSE 19828
// begin x := x + 2 ;
19812: LD_ADDR_VAR 0 13
19816: PUSH
19817: LD_VAR 0 13
19821: PUSH
19822: LD_INT 2
19824: PLUS
19825: ST_TO_ADDR
// continue ;
19826: GO 19626
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19828: LD_VAR 0 12
19832: PUSH
19833: LD_INT 1
19835: ARRAY
19836: PPUSH
19837: CALL_OW 266
19841: PUSH
19842: LD_INT 5
19844: EQUAL
19845: IFFALSE 19919
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19847: LD_VAR 0 12
19851: PUSH
19852: LD_INT 1
19854: ARRAY
19855: PPUSH
19856: CALL_OW 313
19860: PUSH
19861: LD_INT 3
19863: LESS
19864: IFFALSE 19900
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19866: LD_INT 0
19868: PPUSH
19869: LD_INT 5
19871: PUSH
19872: LD_INT 8
19874: PUSH
19875: LD_INT 9
19877: PUSH
19878: EMPTY
19879: LIST
19880: LIST
19881: LIST
19882: PUSH
19883: LD_VAR 0 17
19887: ARRAY
19888: PPUSH
19889: LD_VAR 0 4
19893: PPUSH
19894: CALL_OW 380
19898: GO 19917
// PrepareHuman ( false , i , skill ) ;
19900: LD_INT 0
19902: PPUSH
19903: LD_VAR 0 8
19907: PPUSH
19908: LD_VAR 0 4
19912: PPUSH
19913: CALL_OW 380
// end else
19917: GO 19936
// PrepareHuman ( false , i , skill ) ;
19919: LD_INT 0
19921: PPUSH
19922: LD_VAR 0 8
19926: PPUSH
19927: LD_VAR 0 4
19931: PPUSH
19932: CALL_OW 380
// un := CreateHuman ;
19936: LD_ADDR_VAR 0 14
19940: PUSH
19941: CALL_OW 44
19945: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19946: LD_ADDR_VAR 0 7
19950: PUSH
19951: LD_VAR 0 7
19955: PPUSH
19956: LD_INT 1
19958: PPUSH
19959: LD_VAR 0 14
19963: PPUSH
19964: CALL_OW 2
19968: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19969: LD_VAR 0 14
19973: PPUSH
19974: LD_VAR 0 12
19978: PUSH
19979: LD_INT 1
19981: ARRAY
19982: PPUSH
19983: CALL_OW 52
// end ;
19987: GO 19626
19989: POP
19990: POP
// end ;
19991: GO 18928
19993: POP
19994: POP
// result := result ^ buildings ;
19995: LD_ADDR_VAR 0 7
19999: PUSH
20000: LD_VAR 0 7
20004: PUSH
20005: LD_VAR 0 18
20009: ADD
20010: ST_TO_ADDR
// end else
20011: GO 20154
// begin for i = 1 to personel do
20013: LD_ADDR_VAR 0 8
20017: PUSH
20018: DOUBLE
20019: LD_INT 1
20021: DEC
20022: ST_TO_ADDR
20023: LD_VAR 0 6
20027: PUSH
20028: FOR_TO
20029: IFFALSE 20152
// begin if i > 4 then
20031: LD_VAR 0 8
20035: PUSH
20036: LD_INT 4
20038: GREATER
20039: IFFALSE 20043
// break ;
20041: GO 20152
// x := personel [ i ] ;
20043: LD_ADDR_VAR 0 13
20047: PUSH
20048: LD_VAR 0 6
20052: PUSH
20053: LD_VAR 0 8
20057: ARRAY
20058: ST_TO_ADDR
// if x = - 1 then
20059: LD_VAR 0 13
20063: PUSH
20064: LD_INT 1
20066: NEG
20067: EQUAL
20068: IFFALSE 20072
// continue ;
20070: GO 20028
// PrepareHuman ( false , i , skill ) ;
20072: LD_INT 0
20074: PPUSH
20075: LD_VAR 0 8
20079: PPUSH
20080: LD_VAR 0 4
20084: PPUSH
20085: CALL_OW 380
// un := CreateHuman ;
20089: LD_ADDR_VAR 0 14
20093: PUSH
20094: CALL_OW 44
20098: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20099: LD_VAR 0 14
20103: PPUSH
20104: LD_VAR 0 1
20108: PPUSH
20109: CALL_OW 250
20113: PPUSH
20114: LD_VAR 0 1
20118: PPUSH
20119: CALL_OW 251
20123: PPUSH
20124: LD_INT 10
20126: PPUSH
20127: LD_INT 0
20129: PPUSH
20130: CALL_OW 50
// result := result ^ un ;
20134: LD_ADDR_VAR 0 7
20138: PUSH
20139: LD_VAR 0 7
20143: PUSH
20144: LD_VAR 0 14
20148: ADD
20149: ST_TO_ADDR
// end ;
20150: GO 20028
20152: POP
20153: POP
// end ; end ;
20154: LD_VAR 0 7
20158: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
20159: LD_INT 0
20161: PPUSH
20162: PPUSH
20163: PPUSH
20164: PPUSH
20165: PPUSH
20166: PPUSH
20167: PPUSH
20168: PPUSH
20169: PPUSH
20170: PPUSH
20171: PPUSH
20172: PPUSH
20173: PPUSH
20174: PPUSH
20175: PPUSH
20176: PPUSH
// result := false ;
20177: LD_ADDR_VAR 0 3
20181: PUSH
20182: LD_INT 0
20184: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
20185: LD_VAR 0 1
20189: NOT
20190: PUSH
20191: LD_VAR 0 1
20195: PPUSH
20196: CALL_OW 266
20200: PUSH
20201: LD_INT 32
20203: PUSH
20204: LD_INT 33
20206: PUSH
20207: EMPTY
20208: LIST
20209: LIST
20210: IN
20211: NOT
20212: OR
20213: IFFALSE 20217
// exit ;
20215: GO 21326
// nat := GetNation ( tower ) ;
20217: LD_ADDR_VAR 0 12
20221: PUSH
20222: LD_VAR 0 1
20226: PPUSH
20227: CALL_OW 248
20231: ST_TO_ADDR
// side := GetSide ( tower ) ;
20232: LD_ADDR_VAR 0 16
20236: PUSH
20237: LD_VAR 0 1
20241: PPUSH
20242: CALL_OW 255
20246: ST_TO_ADDR
// x := GetX ( tower ) ;
20247: LD_ADDR_VAR 0 10
20251: PUSH
20252: LD_VAR 0 1
20256: PPUSH
20257: CALL_OW 250
20261: ST_TO_ADDR
// y := GetY ( tower ) ;
20262: LD_ADDR_VAR 0 11
20266: PUSH
20267: LD_VAR 0 1
20271: PPUSH
20272: CALL_OW 251
20276: ST_TO_ADDR
// if not x or not y then
20277: LD_VAR 0 10
20281: NOT
20282: PUSH
20283: LD_VAR 0 11
20287: NOT
20288: OR
20289: IFFALSE 20293
// exit ;
20291: GO 21326
// weapon := 0 ;
20293: LD_ADDR_VAR 0 18
20297: PUSH
20298: LD_INT 0
20300: ST_TO_ADDR
// fac_list := [ ] ;
20301: LD_ADDR_VAR 0 17
20305: PUSH
20306: EMPTY
20307: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20308: LD_ADDR_VAR 0 6
20312: PUSH
20313: LD_VAR 0 1
20317: PPUSH
20318: CALL_OW 274
20322: PPUSH
20323: LD_VAR 0 2
20327: PPUSH
20328: LD_INT 0
20330: PPUSH
20331: CALL 17897 0 3
20335: PPUSH
20336: LD_INT 30
20338: PUSH
20339: LD_INT 3
20341: PUSH
20342: EMPTY
20343: LIST
20344: LIST
20345: PPUSH
20346: CALL_OW 72
20350: ST_TO_ADDR
// if not factories then
20351: LD_VAR 0 6
20355: NOT
20356: IFFALSE 20360
// exit ;
20358: GO 21326
// for i in factories do
20360: LD_ADDR_VAR 0 8
20364: PUSH
20365: LD_VAR 0 6
20369: PUSH
20370: FOR_IN
20371: IFFALSE 20396
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20373: LD_ADDR_VAR 0 17
20377: PUSH
20378: LD_VAR 0 17
20382: PUSH
20383: LD_VAR 0 8
20387: PPUSH
20388: CALL_OW 478
20392: UNION
20393: ST_TO_ADDR
20394: GO 20370
20396: POP
20397: POP
// if not fac_list then
20398: LD_VAR 0 17
20402: NOT
20403: IFFALSE 20407
// exit ;
20405: GO 21326
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20407: LD_ADDR_VAR 0 5
20411: PUSH
20412: LD_INT 4
20414: PUSH
20415: LD_INT 5
20417: PUSH
20418: LD_INT 9
20420: PUSH
20421: LD_INT 10
20423: PUSH
20424: LD_INT 6
20426: PUSH
20427: LD_INT 7
20429: PUSH
20430: LD_INT 11
20432: PUSH
20433: EMPTY
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: LIST
20441: PUSH
20442: LD_INT 27
20444: PUSH
20445: LD_INT 28
20447: PUSH
20448: LD_INT 26
20450: PUSH
20451: LD_INT 30
20453: PUSH
20454: EMPTY
20455: LIST
20456: LIST
20457: LIST
20458: LIST
20459: PUSH
20460: LD_INT 43
20462: PUSH
20463: LD_INT 44
20465: PUSH
20466: LD_INT 46
20468: PUSH
20469: LD_INT 45
20471: PUSH
20472: LD_INT 47
20474: PUSH
20475: LD_INT 49
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: LIST
20482: LIST
20483: LIST
20484: LIST
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: LIST
20490: PUSH
20491: LD_VAR 0 12
20495: ARRAY
20496: ST_TO_ADDR
// list := list isect fac_list ;
20497: LD_ADDR_VAR 0 5
20501: PUSH
20502: LD_VAR 0 5
20506: PUSH
20507: LD_VAR 0 17
20511: ISECT
20512: ST_TO_ADDR
// if not list then
20513: LD_VAR 0 5
20517: NOT
20518: IFFALSE 20522
// exit ;
20520: GO 21326
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20522: LD_VAR 0 12
20526: PUSH
20527: LD_INT 3
20529: EQUAL
20530: PUSH
20531: LD_INT 49
20533: PUSH
20534: LD_VAR 0 5
20538: IN
20539: AND
20540: PUSH
20541: LD_INT 31
20543: PPUSH
20544: LD_VAR 0 16
20548: PPUSH
20549: CALL_OW 321
20553: PUSH
20554: LD_INT 2
20556: EQUAL
20557: AND
20558: IFFALSE 20618
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20560: LD_INT 22
20562: PUSH
20563: LD_VAR 0 16
20567: PUSH
20568: EMPTY
20569: LIST
20570: LIST
20571: PUSH
20572: LD_INT 35
20574: PUSH
20575: LD_INT 49
20577: PUSH
20578: EMPTY
20579: LIST
20580: LIST
20581: PUSH
20582: LD_INT 91
20584: PUSH
20585: LD_VAR 0 1
20589: PUSH
20590: LD_INT 10
20592: PUSH
20593: EMPTY
20594: LIST
20595: LIST
20596: LIST
20597: PUSH
20598: EMPTY
20599: LIST
20600: LIST
20601: LIST
20602: PPUSH
20603: CALL_OW 69
20607: NOT
20608: IFFALSE 20618
// weapon := ru_time_lapser ;
20610: LD_ADDR_VAR 0 18
20614: PUSH
20615: LD_INT 49
20617: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20618: LD_VAR 0 12
20622: PUSH
20623: LD_INT 1
20625: PUSH
20626: LD_INT 2
20628: PUSH
20629: EMPTY
20630: LIST
20631: LIST
20632: IN
20633: PUSH
20634: LD_INT 11
20636: PUSH
20637: LD_VAR 0 5
20641: IN
20642: PUSH
20643: LD_INT 30
20645: PUSH
20646: LD_VAR 0 5
20650: IN
20651: OR
20652: AND
20653: PUSH
20654: LD_INT 6
20656: PPUSH
20657: LD_VAR 0 16
20661: PPUSH
20662: CALL_OW 321
20666: PUSH
20667: LD_INT 2
20669: EQUAL
20670: AND
20671: IFFALSE 20836
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20673: LD_INT 22
20675: PUSH
20676: LD_VAR 0 16
20680: PUSH
20681: EMPTY
20682: LIST
20683: LIST
20684: PUSH
20685: LD_INT 2
20687: PUSH
20688: LD_INT 35
20690: PUSH
20691: LD_INT 11
20693: PUSH
20694: EMPTY
20695: LIST
20696: LIST
20697: PUSH
20698: LD_INT 35
20700: PUSH
20701: LD_INT 30
20703: PUSH
20704: EMPTY
20705: LIST
20706: LIST
20707: PUSH
20708: EMPTY
20709: LIST
20710: LIST
20711: LIST
20712: PUSH
20713: LD_INT 91
20715: PUSH
20716: LD_VAR 0 1
20720: PUSH
20721: LD_INT 18
20723: PUSH
20724: EMPTY
20725: LIST
20726: LIST
20727: LIST
20728: PUSH
20729: EMPTY
20730: LIST
20731: LIST
20732: LIST
20733: PPUSH
20734: CALL_OW 69
20738: NOT
20739: PUSH
20740: LD_INT 22
20742: PUSH
20743: LD_VAR 0 16
20747: PUSH
20748: EMPTY
20749: LIST
20750: LIST
20751: PUSH
20752: LD_INT 2
20754: PUSH
20755: LD_INT 30
20757: PUSH
20758: LD_INT 32
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: PUSH
20765: LD_INT 30
20767: PUSH
20768: LD_INT 33
20770: PUSH
20771: EMPTY
20772: LIST
20773: LIST
20774: PUSH
20775: EMPTY
20776: LIST
20777: LIST
20778: LIST
20779: PUSH
20780: LD_INT 91
20782: PUSH
20783: LD_VAR 0 1
20787: PUSH
20788: LD_INT 12
20790: PUSH
20791: EMPTY
20792: LIST
20793: LIST
20794: LIST
20795: PUSH
20796: EMPTY
20797: LIST
20798: LIST
20799: LIST
20800: PUSH
20801: EMPTY
20802: LIST
20803: PPUSH
20804: CALL_OW 69
20808: PUSH
20809: LD_INT 2
20811: GREATER
20812: AND
20813: IFFALSE 20836
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20815: LD_ADDR_VAR 0 18
20819: PUSH
20820: LD_INT 11
20822: PUSH
20823: LD_INT 30
20825: PUSH
20826: EMPTY
20827: LIST
20828: LIST
20829: PUSH
20830: LD_VAR 0 12
20834: ARRAY
20835: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20836: LD_VAR 0 18
20840: NOT
20841: PUSH
20842: LD_INT 40
20844: PPUSH
20845: LD_VAR 0 16
20849: PPUSH
20850: CALL_OW 321
20854: PUSH
20855: LD_INT 2
20857: EQUAL
20858: AND
20859: PUSH
20860: LD_INT 7
20862: PUSH
20863: LD_VAR 0 5
20867: IN
20868: PUSH
20869: LD_INT 28
20871: PUSH
20872: LD_VAR 0 5
20876: IN
20877: OR
20878: PUSH
20879: LD_INT 45
20881: PUSH
20882: LD_VAR 0 5
20886: IN
20887: OR
20888: AND
20889: IFFALSE 21143
// begin hex := GetHexInfo ( x , y ) ;
20891: LD_ADDR_VAR 0 4
20895: PUSH
20896: LD_VAR 0 10
20900: PPUSH
20901: LD_VAR 0 11
20905: PPUSH
20906: CALL_OW 546
20910: ST_TO_ADDR
// if hex [ 1 ] then
20911: LD_VAR 0 4
20915: PUSH
20916: LD_INT 1
20918: ARRAY
20919: IFFALSE 20923
// exit ;
20921: GO 21326
// height := hex [ 2 ] ;
20923: LD_ADDR_VAR 0 15
20927: PUSH
20928: LD_VAR 0 4
20932: PUSH
20933: LD_INT 2
20935: ARRAY
20936: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20937: LD_ADDR_VAR 0 14
20941: PUSH
20942: LD_INT 0
20944: PUSH
20945: LD_INT 2
20947: PUSH
20948: LD_INT 3
20950: PUSH
20951: LD_INT 5
20953: PUSH
20954: EMPTY
20955: LIST
20956: LIST
20957: LIST
20958: LIST
20959: ST_TO_ADDR
// for i in tmp do
20960: LD_ADDR_VAR 0 8
20964: PUSH
20965: LD_VAR 0 14
20969: PUSH
20970: FOR_IN
20971: IFFALSE 21141
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20973: LD_ADDR_VAR 0 9
20977: PUSH
20978: LD_VAR 0 10
20982: PPUSH
20983: LD_VAR 0 8
20987: PPUSH
20988: LD_INT 5
20990: PPUSH
20991: CALL_OW 272
20995: PUSH
20996: LD_VAR 0 11
21000: PPUSH
21001: LD_VAR 0 8
21005: PPUSH
21006: LD_INT 5
21008: PPUSH
21009: CALL_OW 273
21013: PUSH
21014: EMPTY
21015: LIST
21016: LIST
21017: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21018: LD_VAR 0 9
21022: PUSH
21023: LD_INT 1
21025: ARRAY
21026: PPUSH
21027: LD_VAR 0 9
21031: PUSH
21032: LD_INT 2
21034: ARRAY
21035: PPUSH
21036: CALL_OW 488
21040: IFFALSE 21139
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
21042: LD_ADDR_VAR 0 4
21046: PUSH
21047: LD_VAR 0 9
21051: PUSH
21052: LD_INT 1
21054: ARRAY
21055: PPUSH
21056: LD_VAR 0 9
21060: PUSH
21061: LD_INT 2
21063: ARRAY
21064: PPUSH
21065: CALL_OW 546
21069: ST_TO_ADDR
// if hex [ 1 ] then
21070: LD_VAR 0 4
21074: PUSH
21075: LD_INT 1
21077: ARRAY
21078: IFFALSE 21082
// continue ;
21080: GO 20970
// h := hex [ 2 ] ;
21082: LD_ADDR_VAR 0 13
21086: PUSH
21087: LD_VAR 0 4
21091: PUSH
21092: LD_INT 2
21094: ARRAY
21095: ST_TO_ADDR
// if h + 7 < height then
21096: LD_VAR 0 13
21100: PUSH
21101: LD_INT 7
21103: PLUS
21104: PUSH
21105: LD_VAR 0 15
21109: LESS
21110: IFFALSE 21139
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
21112: LD_ADDR_VAR 0 18
21116: PUSH
21117: LD_INT 7
21119: PUSH
21120: LD_INT 28
21122: PUSH
21123: LD_INT 45
21125: PUSH
21126: EMPTY
21127: LIST
21128: LIST
21129: LIST
21130: PUSH
21131: LD_VAR 0 12
21135: ARRAY
21136: ST_TO_ADDR
// break ;
21137: GO 21141
// end ; end ; end ;
21139: GO 20970
21141: POP
21142: POP
// end ; if not weapon then
21143: LD_VAR 0 18
21147: NOT
21148: IFFALSE 21208
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
21150: LD_ADDR_VAR 0 5
21154: PUSH
21155: LD_VAR 0 5
21159: PUSH
21160: LD_INT 11
21162: PUSH
21163: LD_INT 30
21165: PUSH
21166: LD_INT 49
21168: PUSH
21169: EMPTY
21170: LIST
21171: LIST
21172: LIST
21173: DIFF
21174: ST_TO_ADDR
// if not list then
21175: LD_VAR 0 5
21179: NOT
21180: IFFALSE 21184
// exit ;
21182: GO 21326
// weapon := list [ rand ( 1 , list ) ] ;
21184: LD_ADDR_VAR 0 18
21188: PUSH
21189: LD_VAR 0 5
21193: PUSH
21194: LD_INT 1
21196: PPUSH
21197: LD_VAR 0 5
21201: PPUSH
21202: CALL_OW 12
21206: ARRAY
21207: ST_TO_ADDR
// end ; if weapon then
21208: LD_VAR 0 18
21212: IFFALSE 21326
// begin tmp := CostOfWeapon ( weapon ) ;
21214: LD_ADDR_VAR 0 14
21218: PUSH
21219: LD_VAR 0 18
21223: PPUSH
21224: CALL_OW 451
21228: ST_TO_ADDR
// j := GetBase ( tower ) ;
21229: LD_ADDR_VAR 0 9
21233: PUSH
21234: LD_VAR 0 1
21238: PPUSH
21239: CALL_OW 274
21243: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21244: LD_VAR 0 9
21248: PPUSH
21249: LD_INT 1
21251: PPUSH
21252: CALL_OW 275
21256: PUSH
21257: LD_VAR 0 14
21261: PUSH
21262: LD_INT 1
21264: ARRAY
21265: GREATEREQUAL
21266: PUSH
21267: LD_VAR 0 9
21271: PPUSH
21272: LD_INT 2
21274: PPUSH
21275: CALL_OW 275
21279: PUSH
21280: LD_VAR 0 14
21284: PUSH
21285: LD_INT 2
21287: ARRAY
21288: GREATEREQUAL
21289: AND
21290: PUSH
21291: LD_VAR 0 9
21295: PPUSH
21296: LD_INT 3
21298: PPUSH
21299: CALL_OW 275
21303: PUSH
21304: LD_VAR 0 14
21308: PUSH
21309: LD_INT 3
21311: ARRAY
21312: GREATEREQUAL
21313: AND
21314: IFFALSE 21326
// result := weapon ;
21316: LD_ADDR_VAR 0 3
21320: PUSH
21321: LD_VAR 0 18
21325: ST_TO_ADDR
// end ; end ;
21326: LD_VAR 0 3
21330: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21331: LD_INT 0
21333: PPUSH
21334: PPUSH
// result := true ;
21335: LD_ADDR_VAR 0 3
21339: PUSH
21340: LD_INT 1
21342: ST_TO_ADDR
// if array1 = array2 then
21343: LD_VAR 0 1
21347: PUSH
21348: LD_VAR 0 2
21352: EQUAL
21353: IFFALSE 21413
// begin for i = 1 to array1 do
21355: LD_ADDR_VAR 0 4
21359: PUSH
21360: DOUBLE
21361: LD_INT 1
21363: DEC
21364: ST_TO_ADDR
21365: LD_VAR 0 1
21369: PUSH
21370: FOR_TO
21371: IFFALSE 21409
// if array1 [ i ] <> array2 [ i ] then
21373: LD_VAR 0 1
21377: PUSH
21378: LD_VAR 0 4
21382: ARRAY
21383: PUSH
21384: LD_VAR 0 2
21388: PUSH
21389: LD_VAR 0 4
21393: ARRAY
21394: NONEQUAL
21395: IFFALSE 21407
// begin result := false ;
21397: LD_ADDR_VAR 0 3
21401: PUSH
21402: LD_INT 0
21404: ST_TO_ADDR
// break ;
21405: GO 21409
// end ;
21407: GO 21370
21409: POP
21410: POP
// end else
21411: GO 21421
// result := false ;
21413: LD_ADDR_VAR 0 3
21417: PUSH
21418: LD_INT 0
21420: ST_TO_ADDR
// end ;
21421: LD_VAR 0 3
21425: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21426: LD_INT 0
21428: PPUSH
21429: PPUSH
// if not array1 or not array2 then
21430: LD_VAR 0 1
21434: NOT
21435: PUSH
21436: LD_VAR 0 2
21440: NOT
21441: OR
21442: IFFALSE 21446
// exit ;
21444: GO 21510
// result := true ;
21446: LD_ADDR_VAR 0 3
21450: PUSH
21451: LD_INT 1
21453: ST_TO_ADDR
// for i = 1 to array1 do
21454: LD_ADDR_VAR 0 4
21458: PUSH
21459: DOUBLE
21460: LD_INT 1
21462: DEC
21463: ST_TO_ADDR
21464: LD_VAR 0 1
21468: PUSH
21469: FOR_TO
21470: IFFALSE 21508
// if array1 [ i ] <> array2 [ i ] then
21472: LD_VAR 0 1
21476: PUSH
21477: LD_VAR 0 4
21481: ARRAY
21482: PUSH
21483: LD_VAR 0 2
21487: PUSH
21488: LD_VAR 0 4
21492: ARRAY
21493: NONEQUAL
21494: IFFALSE 21506
// begin result := false ;
21496: LD_ADDR_VAR 0 3
21500: PUSH
21501: LD_INT 0
21503: ST_TO_ADDR
// break ;
21504: GO 21508
// end ;
21506: GO 21469
21508: POP
21509: POP
// end ;
21510: LD_VAR 0 3
21514: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21515: LD_INT 0
21517: PPUSH
21518: PPUSH
21519: PPUSH
// pom := GetBase ( fac ) ;
21520: LD_ADDR_VAR 0 5
21524: PUSH
21525: LD_VAR 0 1
21529: PPUSH
21530: CALL_OW 274
21534: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21535: LD_ADDR_VAR 0 4
21539: PUSH
21540: LD_VAR 0 2
21544: PUSH
21545: LD_INT 1
21547: ARRAY
21548: PPUSH
21549: LD_VAR 0 2
21553: PUSH
21554: LD_INT 2
21556: ARRAY
21557: PPUSH
21558: LD_VAR 0 2
21562: PUSH
21563: LD_INT 3
21565: ARRAY
21566: PPUSH
21567: LD_VAR 0 2
21571: PUSH
21572: LD_INT 4
21574: ARRAY
21575: PPUSH
21576: CALL_OW 449
21580: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21581: LD_ADDR_VAR 0 3
21585: PUSH
21586: LD_VAR 0 5
21590: PPUSH
21591: LD_INT 1
21593: PPUSH
21594: CALL_OW 275
21598: PUSH
21599: LD_VAR 0 4
21603: PUSH
21604: LD_INT 1
21606: ARRAY
21607: GREATEREQUAL
21608: PUSH
21609: LD_VAR 0 5
21613: PPUSH
21614: LD_INT 2
21616: PPUSH
21617: CALL_OW 275
21621: PUSH
21622: LD_VAR 0 4
21626: PUSH
21627: LD_INT 2
21629: ARRAY
21630: GREATEREQUAL
21631: AND
21632: PUSH
21633: LD_VAR 0 5
21637: PPUSH
21638: LD_INT 3
21640: PPUSH
21641: CALL_OW 275
21645: PUSH
21646: LD_VAR 0 4
21650: PUSH
21651: LD_INT 3
21653: ARRAY
21654: GREATEREQUAL
21655: AND
21656: ST_TO_ADDR
// end ;
21657: LD_VAR 0 3
21661: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21662: LD_INT 0
21664: PPUSH
21665: PPUSH
21666: PPUSH
21667: PPUSH
// pom := GetBase ( building ) ;
21668: LD_ADDR_VAR 0 3
21672: PUSH
21673: LD_VAR 0 1
21677: PPUSH
21678: CALL_OW 274
21682: ST_TO_ADDR
// if not pom then
21683: LD_VAR 0 3
21687: NOT
21688: IFFALSE 21692
// exit ;
21690: GO 21862
// btype := GetBType ( building ) ;
21692: LD_ADDR_VAR 0 5
21696: PUSH
21697: LD_VAR 0 1
21701: PPUSH
21702: CALL_OW 266
21706: ST_TO_ADDR
// if btype = b_armoury then
21707: LD_VAR 0 5
21711: PUSH
21712: LD_INT 4
21714: EQUAL
21715: IFFALSE 21725
// btype := b_barracks ;
21717: LD_ADDR_VAR 0 5
21721: PUSH
21722: LD_INT 5
21724: ST_TO_ADDR
// if btype = b_depot then
21725: LD_VAR 0 5
21729: PUSH
21730: LD_INT 0
21732: EQUAL
21733: IFFALSE 21743
// btype := b_warehouse ;
21735: LD_ADDR_VAR 0 5
21739: PUSH
21740: LD_INT 1
21742: ST_TO_ADDR
// if btype = b_workshop then
21743: LD_VAR 0 5
21747: PUSH
21748: LD_INT 2
21750: EQUAL
21751: IFFALSE 21761
// btype := b_factory ;
21753: LD_ADDR_VAR 0 5
21757: PUSH
21758: LD_INT 3
21760: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21761: LD_ADDR_VAR 0 4
21765: PUSH
21766: LD_VAR 0 5
21770: PPUSH
21771: LD_VAR 0 1
21775: PPUSH
21776: CALL_OW 248
21780: PPUSH
21781: CALL_OW 450
21785: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21786: LD_ADDR_VAR 0 2
21790: PUSH
21791: LD_VAR 0 3
21795: PPUSH
21796: LD_INT 1
21798: PPUSH
21799: CALL_OW 275
21803: PUSH
21804: LD_VAR 0 4
21808: PUSH
21809: LD_INT 1
21811: ARRAY
21812: GREATEREQUAL
21813: PUSH
21814: LD_VAR 0 3
21818: PPUSH
21819: LD_INT 2
21821: PPUSH
21822: CALL_OW 275
21826: PUSH
21827: LD_VAR 0 4
21831: PUSH
21832: LD_INT 2
21834: ARRAY
21835: GREATEREQUAL
21836: AND
21837: PUSH
21838: LD_VAR 0 3
21842: PPUSH
21843: LD_INT 3
21845: PPUSH
21846: CALL_OW 275
21850: PUSH
21851: LD_VAR 0 4
21855: PUSH
21856: LD_INT 3
21858: ARRAY
21859: GREATEREQUAL
21860: AND
21861: ST_TO_ADDR
// end ;
21862: LD_VAR 0 2
21866: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21867: LD_INT 0
21869: PPUSH
21870: PPUSH
21871: PPUSH
// pom := GetBase ( building ) ;
21872: LD_ADDR_VAR 0 4
21876: PUSH
21877: LD_VAR 0 1
21881: PPUSH
21882: CALL_OW 274
21886: ST_TO_ADDR
// if not pom then
21887: LD_VAR 0 4
21891: NOT
21892: IFFALSE 21896
// exit ;
21894: GO 21997
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21896: LD_ADDR_VAR 0 5
21900: PUSH
21901: LD_VAR 0 2
21905: PPUSH
21906: LD_VAR 0 1
21910: PPUSH
21911: CALL_OW 248
21915: PPUSH
21916: CALL_OW 450
21920: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21921: LD_ADDR_VAR 0 3
21925: PUSH
21926: LD_VAR 0 4
21930: PPUSH
21931: LD_INT 1
21933: PPUSH
21934: CALL_OW 275
21938: PUSH
21939: LD_VAR 0 5
21943: PUSH
21944: LD_INT 1
21946: ARRAY
21947: GREATEREQUAL
21948: PUSH
21949: LD_VAR 0 4
21953: PPUSH
21954: LD_INT 2
21956: PPUSH
21957: CALL_OW 275
21961: PUSH
21962: LD_VAR 0 5
21966: PUSH
21967: LD_INT 2
21969: ARRAY
21970: GREATEREQUAL
21971: AND
21972: PUSH
21973: LD_VAR 0 4
21977: PPUSH
21978: LD_INT 3
21980: PPUSH
21981: CALL_OW 275
21985: PUSH
21986: LD_VAR 0 5
21990: PUSH
21991: LD_INT 3
21993: ARRAY
21994: GREATEREQUAL
21995: AND
21996: ST_TO_ADDR
// end ;
21997: LD_VAR 0 3
22001: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22002: LD_INT 0
22004: PPUSH
22005: PPUSH
22006: PPUSH
22007: PPUSH
22008: PPUSH
22009: PPUSH
22010: PPUSH
22011: PPUSH
22012: PPUSH
22013: PPUSH
22014: PPUSH
// result := false ;
22015: LD_ADDR_VAR 0 8
22019: PUSH
22020: LD_INT 0
22022: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22023: LD_VAR 0 5
22027: NOT
22028: PUSH
22029: LD_VAR 0 1
22033: NOT
22034: OR
22035: PUSH
22036: LD_VAR 0 2
22040: NOT
22041: OR
22042: PUSH
22043: LD_VAR 0 3
22047: NOT
22048: OR
22049: IFFALSE 22053
// exit ;
22051: GO 22867
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
22053: LD_ADDR_VAR 0 14
22057: PUSH
22058: LD_VAR 0 1
22062: PPUSH
22063: LD_VAR 0 2
22067: PPUSH
22068: LD_VAR 0 3
22072: PPUSH
22073: LD_VAR 0 4
22077: PPUSH
22078: LD_VAR 0 5
22082: PUSH
22083: LD_INT 1
22085: ARRAY
22086: PPUSH
22087: CALL_OW 248
22091: PPUSH
22092: LD_INT 0
22094: PPUSH
22095: CALL 24120 0 6
22099: ST_TO_ADDR
// if not hexes then
22100: LD_VAR 0 14
22104: NOT
22105: IFFALSE 22109
// exit ;
22107: GO 22867
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22109: LD_ADDR_VAR 0 17
22113: PUSH
22114: LD_VAR 0 5
22118: PPUSH
22119: LD_INT 22
22121: PUSH
22122: LD_VAR 0 13
22126: PPUSH
22127: CALL_OW 255
22131: PUSH
22132: EMPTY
22133: LIST
22134: LIST
22135: PUSH
22136: LD_INT 2
22138: PUSH
22139: LD_INT 30
22141: PUSH
22142: LD_INT 0
22144: PUSH
22145: EMPTY
22146: LIST
22147: LIST
22148: PUSH
22149: LD_INT 30
22151: PUSH
22152: LD_INT 1
22154: PUSH
22155: EMPTY
22156: LIST
22157: LIST
22158: PUSH
22159: EMPTY
22160: LIST
22161: LIST
22162: LIST
22163: PUSH
22164: EMPTY
22165: LIST
22166: LIST
22167: PPUSH
22168: CALL_OW 72
22172: ST_TO_ADDR
// for i = 1 to hexes do
22173: LD_ADDR_VAR 0 9
22177: PUSH
22178: DOUBLE
22179: LD_INT 1
22181: DEC
22182: ST_TO_ADDR
22183: LD_VAR 0 14
22187: PUSH
22188: FOR_TO
22189: IFFALSE 22865
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22191: LD_ADDR_VAR 0 13
22195: PUSH
22196: LD_VAR 0 14
22200: PUSH
22201: LD_VAR 0 9
22205: ARRAY
22206: PUSH
22207: LD_INT 1
22209: ARRAY
22210: PPUSH
22211: LD_VAR 0 14
22215: PUSH
22216: LD_VAR 0 9
22220: ARRAY
22221: PUSH
22222: LD_INT 2
22224: ARRAY
22225: PPUSH
22226: CALL_OW 428
22230: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
22231: LD_VAR 0 14
22235: PUSH
22236: LD_VAR 0 9
22240: ARRAY
22241: PUSH
22242: LD_INT 1
22244: ARRAY
22245: PPUSH
22246: LD_VAR 0 14
22250: PUSH
22251: LD_VAR 0 9
22255: ARRAY
22256: PUSH
22257: LD_INT 2
22259: ARRAY
22260: PPUSH
22261: CALL_OW 351
22265: PUSH
22266: LD_VAR 0 14
22270: PUSH
22271: LD_VAR 0 9
22275: ARRAY
22276: PUSH
22277: LD_INT 1
22279: ARRAY
22280: PPUSH
22281: LD_VAR 0 14
22285: PUSH
22286: LD_VAR 0 9
22290: ARRAY
22291: PUSH
22292: LD_INT 2
22294: ARRAY
22295: PPUSH
22296: CALL_OW 488
22300: NOT
22301: OR
22302: PUSH
22303: LD_VAR 0 13
22307: PPUSH
22308: CALL_OW 247
22312: PUSH
22313: LD_INT 3
22315: EQUAL
22316: OR
22317: IFFALSE 22323
// exit ;
22319: POP
22320: POP
22321: GO 22867
// if not tmp then
22323: LD_VAR 0 13
22327: NOT
22328: IFFALSE 22332
// continue ;
22330: GO 22188
// result := true ;
22332: LD_ADDR_VAR 0 8
22336: PUSH
22337: LD_INT 1
22339: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22340: LD_VAR 0 6
22344: PUSH
22345: LD_VAR 0 13
22349: PPUSH
22350: CALL_OW 247
22354: PUSH
22355: LD_INT 2
22357: EQUAL
22358: AND
22359: PUSH
22360: LD_VAR 0 13
22364: PPUSH
22365: CALL_OW 263
22369: PUSH
22370: LD_INT 1
22372: EQUAL
22373: AND
22374: IFFALSE 22538
// begin if IsDrivenBy ( tmp ) then
22376: LD_VAR 0 13
22380: PPUSH
22381: CALL_OW 311
22385: IFFALSE 22389
// continue ;
22387: GO 22188
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22389: LD_VAR 0 6
22393: PPUSH
22394: LD_INT 3
22396: PUSH
22397: LD_INT 60
22399: PUSH
22400: EMPTY
22401: LIST
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: PUSH
22407: LD_INT 3
22409: PUSH
22410: LD_INT 55
22412: PUSH
22413: EMPTY
22414: LIST
22415: PUSH
22416: EMPTY
22417: LIST
22418: LIST
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: PPUSH
22424: CALL_OW 72
22428: IFFALSE 22536
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22430: LD_ADDR_VAR 0 18
22434: PUSH
22435: LD_VAR 0 6
22439: PPUSH
22440: LD_INT 3
22442: PUSH
22443: LD_INT 60
22445: PUSH
22446: EMPTY
22447: LIST
22448: PUSH
22449: EMPTY
22450: LIST
22451: LIST
22452: PUSH
22453: LD_INT 3
22455: PUSH
22456: LD_INT 55
22458: PUSH
22459: EMPTY
22460: LIST
22461: PUSH
22462: EMPTY
22463: LIST
22464: LIST
22465: PUSH
22466: EMPTY
22467: LIST
22468: LIST
22469: PPUSH
22470: CALL_OW 72
22474: PUSH
22475: LD_INT 1
22477: ARRAY
22478: ST_TO_ADDR
// if IsInUnit ( driver ) then
22479: LD_VAR 0 18
22483: PPUSH
22484: CALL_OW 310
22488: IFFALSE 22499
// ComExit ( driver ) ;
22490: LD_VAR 0 18
22494: PPUSH
22495: CALL 47912 0 1
// AddComEnterUnit ( driver , tmp ) ;
22499: LD_VAR 0 18
22503: PPUSH
22504: LD_VAR 0 13
22508: PPUSH
22509: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
22513: LD_VAR 0 18
22517: PPUSH
22518: LD_VAR 0 7
22522: PPUSH
22523: CALL_OW 173
// AddComExitVehicle ( driver ) ;
22527: LD_VAR 0 18
22531: PPUSH
22532: CALL_OW 181
// end ; continue ;
22536: GO 22188
// end ; if not cleaners or not tmp in cleaners then
22538: LD_VAR 0 6
22542: NOT
22543: PUSH
22544: LD_VAR 0 13
22548: PUSH
22549: LD_VAR 0 6
22553: IN
22554: NOT
22555: OR
22556: IFFALSE 22863
// begin if dep then
22558: LD_VAR 0 17
22562: IFFALSE 22698
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22564: LD_ADDR_VAR 0 16
22568: PUSH
22569: LD_VAR 0 17
22573: PUSH
22574: LD_INT 1
22576: ARRAY
22577: PPUSH
22578: CALL_OW 250
22582: PPUSH
22583: LD_VAR 0 17
22587: PUSH
22588: LD_INT 1
22590: ARRAY
22591: PPUSH
22592: CALL_OW 254
22596: PPUSH
22597: LD_INT 5
22599: PPUSH
22600: CALL_OW 272
22604: PUSH
22605: LD_VAR 0 17
22609: PUSH
22610: LD_INT 1
22612: ARRAY
22613: PPUSH
22614: CALL_OW 251
22618: PPUSH
22619: LD_VAR 0 17
22623: PUSH
22624: LD_INT 1
22626: ARRAY
22627: PPUSH
22628: CALL_OW 254
22632: PPUSH
22633: LD_INT 5
22635: PPUSH
22636: CALL_OW 273
22640: PUSH
22641: EMPTY
22642: LIST
22643: LIST
22644: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22645: LD_VAR 0 16
22649: PUSH
22650: LD_INT 1
22652: ARRAY
22653: PPUSH
22654: LD_VAR 0 16
22658: PUSH
22659: LD_INT 2
22661: ARRAY
22662: PPUSH
22663: CALL_OW 488
22667: IFFALSE 22698
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22669: LD_VAR 0 13
22673: PPUSH
22674: LD_VAR 0 16
22678: PUSH
22679: LD_INT 1
22681: ARRAY
22682: PPUSH
22683: LD_VAR 0 16
22687: PUSH
22688: LD_INT 2
22690: ARRAY
22691: PPUSH
22692: CALL_OW 111
// continue ;
22696: GO 22188
// end ; end ; r := GetDir ( tmp ) ;
22698: LD_ADDR_VAR 0 15
22702: PUSH
22703: LD_VAR 0 13
22707: PPUSH
22708: CALL_OW 254
22712: ST_TO_ADDR
// if r = 5 then
22713: LD_VAR 0 15
22717: PUSH
22718: LD_INT 5
22720: EQUAL
22721: IFFALSE 22731
// r := 0 ;
22723: LD_ADDR_VAR 0 15
22727: PUSH
22728: LD_INT 0
22730: ST_TO_ADDR
// for j = r to 5 do
22731: LD_ADDR_VAR 0 10
22735: PUSH
22736: DOUBLE
22737: LD_VAR 0 15
22741: DEC
22742: ST_TO_ADDR
22743: LD_INT 5
22745: PUSH
22746: FOR_TO
22747: IFFALSE 22861
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22749: LD_ADDR_VAR 0 11
22753: PUSH
22754: LD_VAR 0 13
22758: PPUSH
22759: CALL_OW 250
22763: PPUSH
22764: LD_VAR 0 10
22768: PPUSH
22769: LD_INT 2
22771: PPUSH
22772: CALL_OW 272
22776: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22777: LD_ADDR_VAR 0 12
22781: PUSH
22782: LD_VAR 0 13
22786: PPUSH
22787: CALL_OW 251
22791: PPUSH
22792: LD_VAR 0 10
22796: PPUSH
22797: LD_INT 2
22799: PPUSH
22800: CALL_OW 273
22804: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22805: LD_VAR 0 11
22809: PPUSH
22810: LD_VAR 0 12
22814: PPUSH
22815: CALL_OW 488
22819: PUSH
22820: LD_VAR 0 11
22824: PPUSH
22825: LD_VAR 0 12
22829: PPUSH
22830: CALL_OW 428
22834: NOT
22835: AND
22836: IFFALSE 22859
// begin ComMoveXY ( tmp , _x , _y ) ;
22838: LD_VAR 0 13
22842: PPUSH
22843: LD_VAR 0 11
22847: PPUSH
22848: LD_VAR 0 12
22852: PPUSH
22853: CALL_OW 111
// break ;
22857: GO 22861
// end ; end ;
22859: GO 22746
22861: POP
22862: POP
// end ; end ;
22863: GO 22188
22865: POP
22866: POP
// end ;
22867: LD_VAR 0 8
22871: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22872: LD_INT 0
22874: PPUSH
// result := true ;
22875: LD_ADDR_VAR 0 3
22879: PUSH
22880: LD_INT 1
22882: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22883: LD_VAR 0 2
22887: PUSH
22888: LD_INT 24
22890: DOUBLE
22891: EQUAL
22892: IFTRUE 22902
22894: LD_INT 33
22896: DOUBLE
22897: EQUAL
22898: IFTRUE 22902
22900: GO 22927
22902: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22903: LD_ADDR_VAR 0 3
22907: PUSH
22908: LD_INT 32
22910: PPUSH
22911: LD_VAR 0 1
22915: PPUSH
22916: CALL_OW 321
22920: PUSH
22921: LD_INT 2
22923: EQUAL
22924: ST_TO_ADDR
22925: GO 23243
22927: LD_INT 20
22929: DOUBLE
22930: EQUAL
22931: IFTRUE 22935
22933: GO 22960
22935: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22936: LD_ADDR_VAR 0 3
22940: PUSH
22941: LD_INT 6
22943: PPUSH
22944: LD_VAR 0 1
22948: PPUSH
22949: CALL_OW 321
22953: PUSH
22954: LD_INT 2
22956: EQUAL
22957: ST_TO_ADDR
22958: GO 23243
22960: LD_INT 22
22962: DOUBLE
22963: EQUAL
22964: IFTRUE 22974
22966: LD_INT 36
22968: DOUBLE
22969: EQUAL
22970: IFTRUE 22974
22972: GO 22999
22974: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22975: LD_ADDR_VAR 0 3
22979: PUSH
22980: LD_INT 15
22982: PPUSH
22983: LD_VAR 0 1
22987: PPUSH
22988: CALL_OW 321
22992: PUSH
22993: LD_INT 2
22995: EQUAL
22996: ST_TO_ADDR
22997: GO 23243
22999: LD_INT 30
23001: DOUBLE
23002: EQUAL
23003: IFTRUE 23007
23005: GO 23032
23007: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23008: LD_ADDR_VAR 0 3
23012: PUSH
23013: LD_INT 20
23015: PPUSH
23016: LD_VAR 0 1
23020: PPUSH
23021: CALL_OW 321
23025: PUSH
23026: LD_INT 2
23028: EQUAL
23029: ST_TO_ADDR
23030: GO 23243
23032: LD_INT 28
23034: DOUBLE
23035: EQUAL
23036: IFTRUE 23046
23038: LD_INT 21
23040: DOUBLE
23041: EQUAL
23042: IFTRUE 23046
23044: GO 23071
23046: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
23047: LD_ADDR_VAR 0 3
23051: PUSH
23052: LD_INT 21
23054: PPUSH
23055: LD_VAR 0 1
23059: PPUSH
23060: CALL_OW 321
23064: PUSH
23065: LD_INT 2
23067: EQUAL
23068: ST_TO_ADDR
23069: GO 23243
23071: LD_INT 16
23073: DOUBLE
23074: EQUAL
23075: IFTRUE 23079
23077: GO 23104
23079: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
23080: LD_ADDR_VAR 0 3
23084: PUSH
23085: LD_INT 84
23087: PPUSH
23088: LD_VAR 0 1
23092: PPUSH
23093: CALL_OW 321
23097: PUSH
23098: LD_INT 2
23100: EQUAL
23101: ST_TO_ADDR
23102: GO 23243
23104: LD_INT 19
23106: DOUBLE
23107: EQUAL
23108: IFTRUE 23118
23110: LD_INT 23
23112: DOUBLE
23113: EQUAL
23114: IFTRUE 23118
23116: GO 23143
23118: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
23119: LD_ADDR_VAR 0 3
23123: PUSH
23124: LD_INT 83
23126: PPUSH
23127: LD_VAR 0 1
23131: PPUSH
23132: CALL_OW 321
23136: PUSH
23137: LD_INT 2
23139: EQUAL
23140: ST_TO_ADDR
23141: GO 23243
23143: LD_INT 17
23145: DOUBLE
23146: EQUAL
23147: IFTRUE 23151
23149: GO 23176
23151: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
23152: LD_ADDR_VAR 0 3
23156: PUSH
23157: LD_INT 39
23159: PPUSH
23160: LD_VAR 0 1
23164: PPUSH
23165: CALL_OW 321
23169: PUSH
23170: LD_INT 2
23172: EQUAL
23173: ST_TO_ADDR
23174: GO 23243
23176: LD_INT 18
23178: DOUBLE
23179: EQUAL
23180: IFTRUE 23184
23182: GO 23209
23184: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
23185: LD_ADDR_VAR 0 3
23189: PUSH
23190: LD_INT 40
23192: PPUSH
23193: LD_VAR 0 1
23197: PPUSH
23198: CALL_OW 321
23202: PUSH
23203: LD_INT 2
23205: EQUAL
23206: ST_TO_ADDR
23207: GO 23243
23209: LD_INT 27
23211: DOUBLE
23212: EQUAL
23213: IFTRUE 23217
23215: GO 23242
23217: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
23218: LD_ADDR_VAR 0 3
23222: PUSH
23223: LD_INT 35
23225: PPUSH
23226: LD_VAR 0 1
23230: PPUSH
23231: CALL_OW 321
23235: PUSH
23236: LD_INT 2
23238: EQUAL
23239: ST_TO_ADDR
23240: GO 23243
23242: POP
// end ;
23243: LD_VAR 0 3
23247: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23248: LD_INT 0
23250: PPUSH
23251: PPUSH
23252: PPUSH
23253: PPUSH
23254: PPUSH
23255: PPUSH
23256: PPUSH
23257: PPUSH
23258: PPUSH
23259: PPUSH
23260: PPUSH
// result := false ;
23261: LD_ADDR_VAR 0 6
23265: PUSH
23266: LD_INT 0
23268: ST_TO_ADDR
// if btype = b_depot then
23269: LD_VAR 0 2
23273: PUSH
23274: LD_INT 0
23276: EQUAL
23277: IFFALSE 23289
// begin result := true ;
23279: LD_ADDR_VAR 0 6
23283: PUSH
23284: LD_INT 1
23286: ST_TO_ADDR
// exit ;
23287: GO 24115
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23289: LD_VAR 0 1
23293: NOT
23294: PUSH
23295: LD_VAR 0 1
23299: PPUSH
23300: CALL_OW 266
23304: PUSH
23305: LD_INT 0
23307: PUSH
23308: LD_INT 1
23310: PUSH
23311: EMPTY
23312: LIST
23313: LIST
23314: IN
23315: NOT
23316: OR
23317: PUSH
23318: LD_VAR 0 2
23322: NOT
23323: OR
23324: PUSH
23325: LD_VAR 0 5
23329: PUSH
23330: LD_INT 0
23332: PUSH
23333: LD_INT 1
23335: PUSH
23336: LD_INT 2
23338: PUSH
23339: LD_INT 3
23341: PUSH
23342: LD_INT 4
23344: PUSH
23345: LD_INT 5
23347: PUSH
23348: EMPTY
23349: LIST
23350: LIST
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: IN
23356: NOT
23357: OR
23358: PUSH
23359: LD_VAR 0 3
23363: PPUSH
23364: LD_VAR 0 4
23368: PPUSH
23369: CALL_OW 488
23373: NOT
23374: OR
23375: IFFALSE 23379
// exit ;
23377: GO 24115
// side := GetSide ( depot ) ;
23379: LD_ADDR_VAR 0 9
23383: PUSH
23384: LD_VAR 0 1
23388: PPUSH
23389: CALL_OW 255
23393: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23394: LD_VAR 0 9
23398: PPUSH
23399: LD_VAR 0 2
23403: PPUSH
23404: CALL 22872 0 2
23408: NOT
23409: IFFALSE 23413
// exit ;
23411: GO 24115
// pom := GetBase ( depot ) ;
23413: LD_ADDR_VAR 0 10
23417: PUSH
23418: LD_VAR 0 1
23422: PPUSH
23423: CALL_OW 274
23427: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23428: LD_ADDR_VAR 0 11
23432: PUSH
23433: LD_VAR 0 2
23437: PPUSH
23438: LD_VAR 0 1
23442: PPUSH
23443: CALL_OW 248
23447: PPUSH
23448: CALL_OW 450
23452: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23453: LD_VAR 0 10
23457: PPUSH
23458: LD_INT 1
23460: PPUSH
23461: CALL_OW 275
23465: PUSH
23466: LD_VAR 0 11
23470: PUSH
23471: LD_INT 1
23473: ARRAY
23474: GREATEREQUAL
23475: PUSH
23476: LD_VAR 0 10
23480: PPUSH
23481: LD_INT 2
23483: PPUSH
23484: CALL_OW 275
23488: PUSH
23489: LD_VAR 0 11
23493: PUSH
23494: LD_INT 2
23496: ARRAY
23497: GREATEREQUAL
23498: AND
23499: PUSH
23500: LD_VAR 0 10
23504: PPUSH
23505: LD_INT 3
23507: PPUSH
23508: CALL_OW 275
23512: PUSH
23513: LD_VAR 0 11
23517: PUSH
23518: LD_INT 3
23520: ARRAY
23521: GREATEREQUAL
23522: AND
23523: NOT
23524: IFFALSE 23528
// exit ;
23526: GO 24115
// if GetBType ( depot ) = b_depot then
23528: LD_VAR 0 1
23532: PPUSH
23533: CALL_OW 266
23537: PUSH
23538: LD_INT 0
23540: EQUAL
23541: IFFALSE 23553
// dist := 28 else
23543: LD_ADDR_VAR 0 14
23547: PUSH
23548: LD_INT 28
23550: ST_TO_ADDR
23551: GO 23561
// dist := 36 ;
23553: LD_ADDR_VAR 0 14
23557: PUSH
23558: LD_INT 36
23560: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23561: LD_VAR 0 1
23565: PPUSH
23566: LD_VAR 0 3
23570: PPUSH
23571: LD_VAR 0 4
23575: PPUSH
23576: CALL_OW 297
23580: PUSH
23581: LD_VAR 0 14
23585: GREATER
23586: IFFALSE 23590
// exit ;
23588: GO 24115
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23590: LD_ADDR_VAR 0 12
23594: PUSH
23595: LD_VAR 0 2
23599: PPUSH
23600: LD_VAR 0 3
23604: PPUSH
23605: LD_VAR 0 4
23609: PPUSH
23610: LD_VAR 0 5
23614: PPUSH
23615: LD_VAR 0 1
23619: PPUSH
23620: CALL_OW 248
23624: PPUSH
23625: LD_INT 0
23627: PPUSH
23628: CALL 24120 0 6
23632: ST_TO_ADDR
// if not hexes then
23633: LD_VAR 0 12
23637: NOT
23638: IFFALSE 23642
// exit ;
23640: GO 24115
// hex := GetHexInfo ( x , y ) ;
23642: LD_ADDR_VAR 0 15
23646: PUSH
23647: LD_VAR 0 3
23651: PPUSH
23652: LD_VAR 0 4
23656: PPUSH
23657: CALL_OW 546
23661: ST_TO_ADDR
// if hex [ 1 ] then
23662: LD_VAR 0 15
23666: PUSH
23667: LD_INT 1
23669: ARRAY
23670: IFFALSE 23674
// exit ;
23672: GO 24115
// height := hex [ 2 ] ;
23674: LD_ADDR_VAR 0 13
23678: PUSH
23679: LD_VAR 0 15
23683: PUSH
23684: LD_INT 2
23686: ARRAY
23687: ST_TO_ADDR
// for i = 1 to hexes do
23688: LD_ADDR_VAR 0 7
23692: PUSH
23693: DOUBLE
23694: LD_INT 1
23696: DEC
23697: ST_TO_ADDR
23698: LD_VAR 0 12
23702: PUSH
23703: FOR_TO
23704: IFFALSE 24034
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23706: LD_VAR 0 12
23710: PUSH
23711: LD_VAR 0 7
23715: ARRAY
23716: PUSH
23717: LD_INT 1
23719: ARRAY
23720: PPUSH
23721: LD_VAR 0 12
23725: PUSH
23726: LD_VAR 0 7
23730: ARRAY
23731: PUSH
23732: LD_INT 2
23734: ARRAY
23735: PPUSH
23736: CALL_OW 488
23740: NOT
23741: PUSH
23742: LD_VAR 0 12
23746: PUSH
23747: LD_VAR 0 7
23751: ARRAY
23752: PUSH
23753: LD_INT 1
23755: ARRAY
23756: PPUSH
23757: LD_VAR 0 12
23761: PUSH
23762: LD_VAR 0 7
23766: ARRAY
23767: PUSH
23768: LD_INT 2
23770: ARRAY
23771: PPUSH
23772: CALL_OW 428
23776: PUSH
23777: LD_INT 0
23779: GREATER
23780: OR
23781: PUSH
23782: LD_VAR 0 12
23786: PUSH
23787: LD_VAR 0 7
23791: ARRAY
23792: PUSH
23793: LD_INT 1
23795: ARRAY
23796: PPUSH
23797: LD_VAR 0 12
23801: PUSH
23802: LD_VAR 0 7
23806: ARRAY
23807: PUSH
23808: LD_INT 2
23810: ARRAY
23811: PPUSH
23812: CALL_OW 351
23816: OR
23817: IFFALSE 23823
// exit ;
23819: POP
23820: POP
23821: GO 24115
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23823: LD_ADDR_VAR 0 8
23827: PUSH
23828: LD_VAR 0 12
23832: PUSH
23833: LD_VAR 0 7
23837: ARRAY
23838: PUSH
23839: LD_INT 1
23841: ARRAY
23842: PPUSH
23843: LD_VAR 0 12
23847: PUSH
23848: LD_VAR 0 7
23852: ARRAY
23853: PUSH
23854: LD_INT 2
23856: ARRAY
23857: PPUSH
23858: CALL_OW 546
23862: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23863: LD_VAR 0 8
23867: PUSH
23868: LD_INT 1
23870: ARRAY
23871: PUSH
23872: LD_VAR 0 8
23876: PUSH
23877: LD_INT 2
23879: ARRAY
23880: PUSH
23881: LD_VAR 0 13
23885: PUSH
23886: LD_INT 2
23888: PLUS
23889: GREATER
23890: OR
23891: PUSH
23892: LD_VAR 0 8
23896: PUSH
23897: LD_INT 2
23899: ARRAY
23900: PUSH
23901: LD_VAR 0 13
23905: PUSH
23906: LD_INT 2
23908: MINUS
23909: LESS
23910: OR
23911: PUSH
23912: LD_VAR 0 8
23916: PUSH
23917: LD_INT 3
23919: ARRAY
23920: PUSH
23921: LD_INT 0
23923: PUSH
23924: LD_INT 8
23926: PUSH
23927: LD_INT 9
23929: PUSH
23930: LD_INT 10
23932: PUSH
23933: LD_INT 11
23935: PUSH
23936: LD_INT 12
23938: PUSH
23939: LD_INT 13
23941: PUSH
23942: LD_INT 16
23944: PUSH
23945: LD_INT 17
23947: PUSH
23948: LD_INT 18
23950: PUSH
23951: LD_INT 19
23953: PUSH
23954: LD_INT 20
23956: PUSH
23957: LD_INT 21
23959: PUSH
23960: EMPTY
23961: LIST
23962: LIST
23963: LIST
23964: LIST
23965: LIST
23966: LIST
23967: LIST
23968: LIST
23969: LIST
23970: LIST
23971: LIST
23972: LIST
23973: LIST
23974: IN
23975: NOT
23976: OR
23977: PUSH
23978: LD_VAR 0 8
23982: PUSH
23983: LD_INT 5
23985: ARRAY
23986: NOT
23987: OR
23988: PUSH
23989: LD_VAR 0 8
23993: PUSH
23994: LD_INT 6
23996: ARRAY
23997: PUSH
23998: LD_INT 1
24000: PUSH
24001: LD_INT 2
24003: PUSH
24004: LD_INT 7
24006: PUSH
24007: LD_INT 9
24009: PUSH
24010: LD_INT 10
24012: PUSH
24013: LD_INT 11
24015: PUSH
24016: EMPTY
24017: LIST
24018: LIST
24019: LIST
24020: LIST
24021: LIST
24022: LIST
24023: IN
24024: NOT
24025: OR
24026: IFFALSE 24032
// exit ;
24028: POP
24029: POP
24030: GO 24115
// end ;
24032: GO 23703
24034: POP
24035: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24036: LD_VAR 0 9
24040: PPUSH
24041: LD_VAR 0 3
24045: PPUSH
24046: LD_VAR 0 4
24050: PPUSH
24051: LD_INT 20
24053: PPUSH
24054: CALL 16038 0 4
24058: PUSH
24059: LD_INT 4
24061: ARRAY
24062: IFFALSE 24066
// exit ;
24064: GO 24115
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
24066: LD_VAR 0 2
24070: PUSH
24071: LD_INT 29
24073: PUSH
24074: LD_INT 30
24076: PUSH
24077: EMPTY
24078: LIST
24079: LIST
24080: IN
24081: PUSH
24082: LD_VAR 0 3
24086: PPUSH
24087: LD_VAR 0 4
24091: PPUSH
24092: LD_VAR 0 9
24096: PPUSH
24097: CALL_OW 440
24101: NOT
24102: AND
24103: IFFALSE 24107
// exit ;
24105: GO 24115
// result := true ;
24107: LD_ADDR_VAR 0 6
24111: PUSH
24112: LD_INT 1
24114: ST_TO_ADDR
// end ;
24115: LD_VAR 0 6
24119: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
24120: LD_INT 0
24122: PPUSH
24123: PPUSH
24124: PPUSH
24125: PPUSH
24126: PPUSH
24127: PPUSH
24128: PPUSH
24129: PPUSH
24130: PPUSH
24131: PPUSH
24132: PPUSH
24133: PPUSH
24134: PPUSH
24135: PPUSH
24136: PPUSH
24137: PPUSH
24138: PPUSH
24139: PPUSH
24140: PPUSH
24141: PPUSH
24142: PPUSH
24143: PPUSH
24144: PPUSH
24145: PPUSH
24146: PPUSH
24147: PPUSH
24148: PPUSH
24149: PPUSH
24150: PPUSH
24151: PPUSH
24152: PPUSH
24153: PPUSH
24154: PPUSH
24155: PPUSH
24156: PPUSH
24157: PPUSH
24158: PPUSH
24159: PPUSH
24160: PPUSH
24161: PPUSH
24162: PPUSH
24163: PPUSH
24164: PPUSH
24165: PPUSH
24166: PPUSH
24167: PPUSH
24168: PPUSH
24169: PPUSH
24170: PPUSH
24171: PPUSH
24172: PPUSH
24173: PPUSH
24174: PPUSH
24175: PPUSH
24176: PPUSH
24177: PPUSH
24178: PPUSH
24179: PPUSH
// result = [ ] ;
24180: LD_ADDR_VAR 0 7
24184: PUSH
24185: EMPTY
24186: ST_TO_ADDR
// temp_list = [ ] ;
24187: LD_ADDR_VAR 0 9
24191: PUSH
24192: EMPTY
24193: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
24194: LD_VAR 0 4
24198: PUSH
24199: LD_INT 0
24201: PUSH
24202: LD_INT 1
24204: PUSH
24205: LD_INT 2
24207: PUSH
24208: LD_INT 3
24210: PUSH
24211: LD_INT 4
24213: PUSH
24214: LD_INT 5
24216: PUSH
24217: EMPTY
24218: LIST
24219: LIST
24220: LIST
24221: LIST
24222: LIST
24223: LIST
24224: IN
24225: NOT
24226: PUSH
24227: LD_VAR 0 1
24231: PUSH
24232: LD_INT 0
24234: PUSH
24235: LD_INT 1
24237: PUSH
24238: EMPTY
24239: LIST
24240: LIST
24241: IN
24242: PUSH
24243: LD_VAR 0 5
24247: PUSH
24248: LD_INT 1
24250: PUSH
24251: LD_INT 2
24253: PUSH
24254: LD_INT 3
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: LIST
24261: IN
24262: NOT
24263: AND
24264: OR
24265: IFFALSE 24269
// exit ;
24267: GO 42660
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24269: LD_VAR 0 1
24273: PUSH
24274: LD_INT 6
24276: PUSH
24277: LD_INT 7
24279: PUSH
24280: LD_INT 8
24282: PUSH
24283: LD_INT 13
24285: PUSH
24286: LD_INT 12
24288: PUSH
24289: LD_INT 15
24291: PUSH
24292: LD_INT 11
24294: PUSH
24295: LD_INT 14
24297: PUSH
24298: LD_INT 10
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: LIST
24305: LIST
24306: LIST
24307: LIST
24308: LIST
24309: LIST
24310: LIST
24311: IN
24312: IFFALSE 24322
// btype = b_lab ;
24314: LD_ADDR_VAR 0 1
24318: PUSH
24319: LD_INT 6
24321: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24322: LD_VAR 0 6
24326: PUSH
24327: LD_INT 0
24329: PUSH
24330: LD_INT 1
24332: PUSH
24333: LD_INT 2
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: IN
24341: NOT
24342: PUSH
24343: LD_VAR 0 1
24347: PUSH
24348: LD_INT 0
24350: PUSH
24351: LD_INT 1
24353: PUSH
24354: LD_INT 2
24356: PUSH
24357: LD_INT 3
24359: PUSH
24360: LD_INT 6
24362: PUSH
24363: LD_INT 36
24365: PUSH
24366: LD_INT 4
24368: PUSH
24369: LD_INT 5
24371: PUSH
24372: LD_INT 31
24374: PUSH
24375: LD_INT 32
24377: PUSH
24378: LD_INT 33
24380: PUSH
24381: EMPTY
24382: LIST
24383: LIST
24384: LIST
24385: LIST
24386: LIST
24387: LIST
24388: LIST
24389: LIST
24390: LIST
24391: LIST
24392: LIST
24393: IN
24394: NOT
24395: PUSH
24396: LD_VAR 0 6
24400: PUSH
24401: LD_INT 1
24403: EQUAL
24404: AND
24405: OR
24406: PUSH
24407: LD_VAR 0 1
24411: PUSH
24412: LD_INT 2
24414: PUSH
24415: LD_INT 3
24417: PUSH
24418: EMPTY
24419: LIST
24420: LIST
24421: IN
24422: NOT
24423: PUSH
24424: LD_VAR 0 6
24428: PUSH
24429: LD_INT 2
24431: EQUAL
24432: AND
24433: OR
24434: IFFALSE 24444
// mode = 0 ;
24436: LD_ADDR_VAR 0 6
24440: PUSH
24441: LD_INT 0
24443: ST_TO_ADDR
// case mode of 0 :
24444: LD_VAR 0 6
24448: PUSH
24449: LD_INT 0
24451: DOUBLE
24452: EQUAL
24453: IFTRUE 24457
24455: GO 35910
24457: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24458: LD_ADDR_VAR 0 11
24462: PUSH
24463: LD_INT 0
24465: PUSH
24466: LD_INT 0
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PUSH
24473: LD_INT 0
24475: PUSH
24476: LD_INT 1
24478: NEG
24479: PUSH
24480: EMPTY
24481: LIST
24482: LIST
24483: PUSH
24484: LD_INT 1
24486: PUSH
24487: LD_INT 0
24489: PUSH
24490: EMPTY
24491: LIST
24492: LIST
24493: PUSH
24494: LD_INT 1
24496: PUSH
24497: LD_INT 1
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: PUSH
24504: LD_INT 0
24506: PUSH
24507: LD_INT 1
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 1
24516: NEG
24517: PUSH
24518: LD_INT 0
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PUSH
24525: LD_INT 1
24527: NEG
24528: PUSH
24529: LD_INT 1
24531: NEG
24532: PUSH
24533: EMPTY
24534: LIST
24535: LIST
24536: PUSH
24537: LD_INT 1
24539: NEG
24540: PUSH
24541: LD_INT 2
24543: NEG
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: PUSH
24549: LD_INT 0
24551: PUSH
24552: LD_INT 2
24554: NEG
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: PUSH
24560: LD_INT 1
24562: PUSH
24563: LD_INT 1
24565: NEG
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PUSH
24571: LD_INT 1
24573: PUSH
24574: LD_INT 2
24576: PUSH
24577: EMPTY
24578: LIST
24579: LIST
24580: PUSH
24581: LD_INT 0
24583: PUSH
24584: LD_INT 2
24586: PUSH
24587: EMPTY
24588: LIST
24589: LIST
24590: PUSH
24591: LD_INT 1
24593: NEG
24594: PUSH
24595: LD_INT 1
24597: PUSH
24598: EMPTY
24599: LIST
24600: LIST
24601: PUSH
24602: LD_INT 1
24604: PUSH
24605: LD_INT 3
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: PUSH
24612: LD_INT 0
24614: PUSH
24615: LD_INT 3
24617: PUSH
24618: EMPTY
24619: LIST
24620: LIST
24621: PUSH
24622: LD_INT 1
24624: NEG
24625: PUSH
24626: LD_INT 2
24628: PUSH
24629: EMPTY
24630: LIST
24631: LIST
24632: PUSH
24633: EMPTY
24634: LIST
24635: LIST
24636: LIST
24637: LIST
24638: LIST
24639: LIST
24640: LIST
24641: LIST
24642: LIST
24643: LIST
24644: LIST
24645: LIST
24646: LIST
24647: LIST
24648: LIST
24649: LIST
24650: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24651: LD_ADDR_VAR 0 12
24655: PUSH
24656: LD_INT 0
24658: PUSH
24659: LD_INT 0
24661: PUSH
24662: EMPTY
24663: LIST
24664: LIST
24665: PUSH
24666: LD_INT 0
24668: PUSH
24669: LD_INT 1
24671: NEG
24672: PUSH
24673: EMPTY
24674: LIST
24675: LIST
24676: PUSH
24677: LD_INT 1
24679: PUSH
24680: LD_INT 0
24682: PUSH
24683: EMPTY
24684: LIST
24685: LIST
24686: PUSH
24687: LD_INT 1
24689: PUSH
24690: LD_INT 1
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PUSH
24697: LD_INT 0
24699: PUSH
24700: LD_INT 1
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: LD_INT 1
24709: NEG
24710: PUSH
24711: LD_INT 0
24713: PUSH
24714: EMPTY
24715: LIST
24716: LIST
24717: PUSH
24718: LD_INT 1
24720: NEG
24721: PUSH
24722: LD_INT 1
24724: NEG
24725: PUSH
24726: EMPTY
24727: LIST
24728: LIST
24729: PUSH
24730: LD_INT 1
24732: PUSH
24733: LD_INT 1
24735: NEG
24736: PUSH
24737: EMPTY
24738: LIST
24739: LIST
24740: PUSH
24741: LD_INT 2
24743: PUSH
24744: LD_INT 0
24746: PUSH
24747: EMPTY
24748: LIST
24749: LIST
24750: PUSH
24751: LD_INT 2
24753: PUSH
24754: LD_INT 1
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: PUSH
24761: LD_INT 1
24763: NEG
24764: PUSH
24765: LD_INT 1
24767: PUSH
24768: EMPTY
24769: LIST
24770: LIST
24771: PUSH
24772: LD_INT 2
24774: NEG
24775: PUSH
24776: LD_INT 0
24778: PUSH
24779: EMPTY
24780: LIST
24781: LIST
24782: PUSH
24783: LD_INT 2
24785: NEG
24786: PUSH
24787: LD_INT 1
24789: NEG
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 2
24797: NEG
24798: PUSH
24799: LD_INT 1
24801: PUSH
24802: EMPTY
24803: LIST
24804: LIST
24805: PUSH
24806: LD_INT 3
24808: NEG
24809: PUSH
24810: LD_INT 0
24812: PUSH
24813: EMPTY
24814: LIST
24815: LIST
24816: PUSH
24817: LD_INT 3
24819: NEG
24820: PUSH
24821: LD_INT 1
24823: NEG
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PUSH
24829: EMPTY
24830: LIST
24831: LIST
24832: LIST
24833: LIST
24834: LIST
24835: LIST
24836: LIST
24837: LIST
24838: LIST
24839: LIST
24840: LIST
24841: LIST
24842: LIST
24843: LIST
24844: LIST
24845: LIST
24846: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24847: LD_ADDR_VAR 0 13
24851: PUSH
24852: LD_INT 0
24854: PUSH
24855: LD_INT 0
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PUSH
24862: LD_INT 0
24864: PUSH
24865: LD_INT 1
24867: NEG
24868: PUSH
24869: EMPTY
24870: LIST
24871: LIST
24872: PUSH
24873: LD_INT 1
24875: PUSH
24876: LD_INT 0
24878: PUSH
24879: EMPTY
24880: LIST
24881: LIST
24882: PUSH
24883: LD_INT 1
24885: PUSH
24886: LD_INT 1
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PUSH
24893: LD_INT 0
24895: PUSH
24896: LD_INT 1
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: PUSH
24903: LD_INT 1
24905: NEG
24906: PUSH
24907: LD_INT 0
24909: PUSH
24910: EMPTY
24911: LIST
24912: LIST
24913: PUSH
24914: LD_INT 1
24916: NEG
24917: PUSH
24918: LD_INT 1
24920: NEG
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PUSH
24926: LD_INT 1
24928: NEG
24929: PUSH
24930: LD_INT 2
24932: NEG
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: PUSH
24938: LD_INT 2
24940: PUSH
24941: LD_INT 1
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: PUSH
24948: LD_INT 2
24950: PUSH
24951: LD_INT 2
24953: PUSH
24954: EMPTY
24955: LIST
24956: LIST
24957: PUSH
24958: LD_INT 1
24960: PUSH
24961: LD_INT 2
24963: PUSH
24964: EMPTY
24965: LIST
24966: LIST
24967: PUSH
24968: LD_INT 2
24970: NEG
24971: PUSH
24972: LD_INT 1
24974: NEG
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: LD_INT 2
24982: NEG
24983: PUSH
24984: LD_INT 2
24986: NEG
24987: PUSH
24988: EMPTY
24989: LIST
24990: LIST
24991: PUSH
24992: LD_INT 2
24994: NEG
24995: PUSH
24996: LD_INT 3
24998: NEG
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: PUSH
25004: LD_INT 3
25006: NEG
25007: PUSH
25008: LD_INT 2
25010: NEG
25011: PUSH
25012: EMPTY
25013: LIST
25014: LIST
25015: PUSH
25016: LD_INT 3
25018: NEG
25019: PUSH
25020: LD_INT 3
25022: NEG
25023: PUSH
25024: EMPTY
25025: LIST
25026: LIST
25027: PUSH
25028: EMPTY
25029: LIST
25030: LIST
25031: LIST
25032: LIST
25033: LIST
25034: LIST
25035: LIST
25036: LIST
25037: LIST
25038: LIST
25039: LIST
25040: LIST
25041: LIST
25042: LIST
25043: LIST
25044: LIST
25045: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25046: LD_ADDR_VAR 0 14
25050: PUSH
25051: LD_INT 0
25053: PUSH
25054: LD_INT 0
25056: PUSH
25057: EMPTY
25058: LIST
25059: LIST
25060: PUSH
25061: LD_INT 0
25063: PUSH
25064: LD_INT 1
25066: NEG
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PUSH
25072: LD_INT 1
25074: PUSH
25075: LD_INT 0
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 1
25084: PUSH
25085: LD_INT 1
25087: PUSH
25088: EMPTY
25089: LIST
25090: LIST
25091: PUSH
25092: LD_INT 0
25094: PUSH
25095: LD_INT 1
25097: PUSH
25098: EMPTY
25099: LIST
25100: LIST
25101: PUSH
25102: LD_INT 1
25104: NEG
25105: PUSH
25106: LD_INT 0
25108: PUSH
25109: EMPTY
25110: LIST
25111: LIST
25112: PUSH
25113: LD_INT 1
25115: NEG
25116: PUSH
25117: LD_INT 1
25119: NEG
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: PUSH
25125: LD_INT 1
25127: NEG
25128: PUSH
25129: LD_INT 2
25131: NEG
25132: PUSH
25133: EMPTY
25134: LIST
25135: LIST
25136: PUSH
25137: LD_INT 0
25139: PUSH
25140: LD_INT 2
25142: NEG
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PUSH
25148: LD_INT 1
25150: PUSH
25151: LD_INT 1
25153: NEG
25154: PUSH
25155: EMPTY
25156: LIST
25157: LIST
25158: PUSH
25159: LD_INT 1
25161: PUSH
25162: LD_INT 2
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: PUSH
25169: LD_INT 0
25171: PUSH
25172: LD_INT 2
25174: PUSH
25175: EMPTY
25176: LIST
25177: LIST
25178: PUSH
25179: LD_INT 1
25181: NEG
25182: PUSH
25183: LD_INT 1
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PUSH
25190: LD_INT 1
25192: NEG
25193: PUSH
25194: LD_INT 3
25196: NEG
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: PUSH
25202: LD_INT 0
25204: PUSH
25205: LD_INT 3
25207: NEG
25208: PUSH
25209: EMPTY
25210: LIST
25211: LIST
25212: PUSH
25213: LD_INT 1
25215: PUSH
25216: LD_INT 2
25218: NEG
25219: PUSH
25220: EMPTY
25221: LIST
25222: LIST
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: LIST
25228: LIST
25229: LIST
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
25242: LD_ADDR_VAR 0 15
25246: PUSH
25247: LD_INT 0
25249: PUSH
25250: LD_INT 0
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PUSH
25257: LD_INT 0
25259: PUSH
25260: LD_INT 1
25262: NEG
25263: PUSH
25264: EMPTY
25265: LIST
25266: LIST
25267: PUSH
25268: LD_INT 1
25270: PUSH
25271: LD_INT 0
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 1
25280: PUSH
25281: LD_INT 1
25283: PUSH
25284: EMPTY
25285: LIST
25286: LIST
25287: PUSH
25288: LD_INT 0
25290: PUSH
25291: LD_INT 1
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: PUSH
25298: LD_INT 1
25300: NEG
25301: PUSH
25302: LD_INT 0
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: PUSH
25309: LD_INT 1
25311: NEG
25312: PUSH
25313: LD_INT 1
25315: NEG
25316: PUSH
25317: EMPTY
25318: LIST
25319: LIST
25320: PUSH
25321: LD_INT 1
25323: PUSH
25324: LD_INT 1
25326: NEG
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: PUSH
25332: LD_INT 2
25334: PUSH
25335: LD_INT 0
25337: PUSH
25338: EMPTY
25339: LIST
25340: LIST
25341: PUSH
25342: LD_INT 2
25344: PUSH
25345: LD_INT 1
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: PUSH
25352: LD_INT 1
25354: NEG
25355: PUSH
25356: LD_INT 1
25358: PUSH
25359: EMPTY
25360: LIST
25361: LIST
25362: PUSH
25363: LD_INT 2
25365: NEG
25366: PUSH
25367: LD_INT 0
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PUSH
25374: LD_INT 2
25376: NEG
25377: PUSH
25378: LD_INT 1
25380: NEG
25381: PUSH
25382: EMPTY
25383: LIST
25384: LIST
25385: PUSH
25386: LD_INT 2
25388: PUSH
25389: LD_INT 1
25391: NEG
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 3
25399: PUSH
25400: LD_INT 0
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 3
25409: PUSH
25410: LD_INT 1
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: LIST
25421: LIST
25422: LIST
25423: LIST
25424: LIST
25425: LIST
25426: LIST
25427: LIST
25428: LIST
25429: LIST
25430: LIST
25431: LIST
25432: LIST
25433: LIST
25434: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25435: LD_ADDR_VAR 0 16
25439: PUSH
25440: LD_INT 0
25442: PUSH
25443: LD_INT 0
25445: PUSH
25446: EMPTY
25447: LIST
25448: LIST
25449: PUSH
25450: LD_INT 0
25452: PUSH
25453: LD_INT 1
25455: NEG
25456: PUSH
25457: EMPTY
25458: LIST
25459: LIST
25460: PUSH
25461: LD_INT 1
25463: PUSH
25464: LD_INT 0
25466: PUSH
25467: EMPTY
25468: LIST
25469: LIST
25470: PUSH
25471: LD_INT 1
25473: PUSH
25474: LD_INT 1
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: PUSH
25481: LD_INT 0
25483: PUSH
25484: LD_INT 1
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 1
25493: NEG
25494: PUSH
25495: LD_INT 0
25497: PUSH
25498: EMPTY
25499: LIST
25500: LIST
25501: PUSH
25502: LD_INT 1
25504: NEG
25505: PUSH
25506: LD_INT 1
25508: NEG
25509: PUSH
25510: EMPTY
25511: LIST
25512: LIST
25513: PUSH
25514: LD_INT 1
25516: NEG
25517: PUSH
25518: LD_INT 2
25520: NEG
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PUSH
25526: LD_INT 2
25528: PUSH
25529: LD_INT 1
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 2
25538: PUSH
25539: LD_INT 2
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 1
25548: PUSH
25549: LD_INT 2
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PUSH
25556: LD_INT 2
25558: NEG
25559: PUSH
25560: LD_INT 1
25562: NEG
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: LD_INT 2
25570: NEG
25571: PUSH
25572: LD_INT 2
25574: NEG
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: PUSH
25580: LD_INT 3
25582: PUSH
25583: LD_INT 2
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 3
25592: PUSH
25593: LD_INT 3
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PUSH
25600: LD_INT 2
25602: PUSH
25603: LD_INT 3
25605: PUSH
25606: EMPTY
25607: LIST
25608: LIST
25609: PUSH
25610: EMPTY
25611: LIST
25612: LIST
25613: LIST
25614: LIST
25615: LIST
25616: LIST
25617: LIST
25618: LIST
25619: LIST
25620: LIST
25621: LIST
25622: LIST
25623: LIST
25624: LIST
25625: LIST
25626: LIST
25627: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25628: LD_ADDR_VAR 0 17
25632: PUSH
25633: LD_INT 0
25635: PUSH
25636: LD_INT 0
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 0
25645: PUSH
25646: LD_INT 1
25648: NEG
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 1
25656: PUSH
25657: LD_INT 0
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 1
25666: PUSH
25667: LD_INT 1
25669: PUSH
25670: EMPTY
25671: LIST
25672: LIST
25673: PUSH
25674: LD_INT 0
25676: PUSH
25677: LD_INT 1
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_INT 1
25686: NEG
25687: PUSH
25688: LD_INT 0
25690: PUSH
25691: EMPTY
25692: LIST
25693: LIST
25694: PUSH
25695: LD_INT 1
25697: NEG
25698: PUSH
25699: LD_INT 1
25701: NEG
25702: PUSH
25703: EMPTY
25704: LIST
25705: LIST
25706: PUSH
25707: LD_INT 1
25709: NEG
25710: PUSH
25711: LD_INT 2
25713: NEG
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: PUSH
25719: LD_INT 0
25721: PUSH
25722: LD_INT 2
25724: NEG
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PUSH
25730: LD_INT 1
25732: PUSH
25733: LD_INT 1
25735: NEG
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: LD_INT 2
25743: PUSH
25744: LD_INT 0
25746: PUSH
25747: EMPTY
25748: LIST
25749: LIST
25750: PUSH
25751: LD_INT 2
25753: PUSH
25754: LD_INT 1
25756: PUSH
25757: EMPTY
25758: LIST
25759: LIST
25760: PUSH
25761: LD_INT 2
25763: PUSH
25764: LD_INT 2
25766: PUSH
25767: EMPTY
25768: LIST
25769: LIST
25770: PUSH
25771: LD_INT 1
25773: PUSH
25774: LD_INT 2
25776: PUSH
25777: EMPTY
25778: LIST
25779: LIST
25780: PUSH
25781: LD_INT 0
25783: PUSH
25784: LD_INT 2
25786: PUSH
25787: EMPTY
25788: LIST
25789: LIST
25790: PUSH
25791: LD_INT 1
25793: NEG
25794: PUSH
25795: LD_INT 1
25797: PUSH
25798: EMPTY
25799: LIST
25800: LIST
25801: PUSH
25802: LD_INT 2
25804: NEG
25805: PUSH
25806: LD_INT 0
25808: PUSH
25809: EMPTY
25810: LIST
25811: LIST
25812: PUSH
25813: LD_INT 2
25815: NEG
25816: PUSH
25817: LD_INT 1
25819: NEG
25820: PUSH
25821: EMPTY
25822: LIST
25823: LIST
25824: PUSH
25825: LD_INT 2
25827: NEG
25828: PUSH
25829: LD_INT 2
25831: NEG
25832: PUSH
25833: EMPTY
25834: LIST
25835: LIST
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: LIST
25841: LIST
25842: LIST
25843: LIST
25844: LIST
25845: LIST
25846: LIST
25847: LIST
25848: LIST
25849: LIST
25850: LIST
25851: LIST
25852: LIST
25853: LIST
25854: LIST
25855: LIST
25856: LIST
25857: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25858: LD_ADDR_VAR 0 18
25862: PUSH
25863: LD_INT 0
25865: PUSH
25866: LD_INT 0
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 0
25875: PUSH
25876: LD_INT 1
25878: NEG
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 1
25886: PUSH
25887: LD_INT 0
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: LD_INT 1
25896: PUSH
25897: LD_INT 1
25899: PUSH
25900: EMPTY
25901: LIST
25902: LIST
25903: PUSH
25904: LD_INT 0
25906: PUSH
25907: LD_INT 1
25909: PUSH
25910: EMPTY
25911: LIST
25912: LIST
25913: PUSH
25914: LD_INT 1
25916: NEG
25917: PUSH
25918: LD_INT 0
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: PUSH
25925: LD_INT 1
25927: NEG
25928: PUSH
25929: LD_INT 1
25931: NEG
25932: PUSH
25933: EMPTY
25934: LIST
25935: LIST
25936: PUSH
25937: LD_INT 1
25939: NEG
25940: PUSH
25941: LD_INT 2
25943: NEG
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: PUSH
25949: LD_INT 0
25951: PUSH
25952: LD_INT 2
25954: NEG
25955: PUSH
25956: EMPTY
25957: LIST
25958: LIST
25959: PUSH
25960: LD_INT 1
25962: PUSH
25963: LD_INT 1
25965: NEG
25966: PUSH
25967: EMPTY
25968: LIST
25969: LIST
25970: PUSH
25971: LD_INT 2
25973: PUSH
25974: LD_INT 0
25976: PUSH
25977: EMPTY
25978: LIST
25979: LIST
25980: PUSH
25981: LD_INT 2
25983: PUSH
25984: LD_INT 1
25986: PUSH
25987: EMPTY
25988: LIST
25989: LIST
25990: PUSH
25991: LD_INT 2
25993: PUSH
25994: LD_INT 2
25996: PUSH
25997: EMPTY
25998: LIST
25999: LIST
26000: PUSH
26001: LD_INT 1
26003: PUSH
26004: LD_INT 2
26006: PUSH
26007: EMPTY
26008: LIST
26009: LIST
26010: PUSH
26011: LD_INT 0
26013: PUSH
26014: LD_INT 2
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PUSH
26021: LD_INT 1
26023: NEG
26024: PUSH
26025: LD_INT 1
26027: PUSH
26028: EMPTY
26029: LIST
26030: LIST
26031: PUSH
26032: LD_INT 2
26034: NEG
26035: PUSH
26036: LD_INT 0
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: PUSH
26043: LD_INT 2
26045: NEG
26046: PUSH
26047: LD_INT 1
26049: NEG
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: PUSH
26055: LD_INT 2
26057: NEG
26058: PUSH
26059: LD_INT 2
26061: NEG
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: EMPTY
26068: LIST
26069: LIST
26070: LIST
26071: LIST
26072: LIST
26073: LIST
26074: LIST
26075: LIST
26076: LIST
26077: LIST
26078: LIST
26079: LIST
26080: LIST
26081: LIST
26082: LIST
26083: LIST
26084: LIST
26085: LIST
26086: LIST
26087: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26088: LD_ADDR_VAR 0 19
26092: PUSH
26093: LD_INT 0
26095: PUSH
26096: LD_INT 0
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 0
26105: PUSH
26106: LD_INT 1
26108: NEG
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: LD_INT 1
26116: PUSH
26117: LD_INT 0
26119: PUSH
26120: EMPTY
26121: LIST
26122: LIST
26123: PUSH
26124: LD_INT 1
26126: PUSH
26127: LD_INT 1
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: PUSH
26134: LD_INT 0
26136: PUSH
26137: LD_INT 1
26139: PUSH
26140: EMPTY
26141: LIST
26142: LIST
26143: PUSH
26144: LD_INT 1
26146: NEG
26147: PUSH
26148: LD_INT 0
26150: PUSH
26151: EMPTY
26152: LIST
26153: LIST
26154: PUSH
26155: LD_INT 1
26157: NEG
26158: PUSH
26159: LD_INT 1
26161: NEG
26162: PUSH
26163: EMPTY
26164: LIST
26165: LIST
26166: PUSH
26167: LD_INT 1
26169: NEG
26170: PUSH
26171: LD_INT 2
26173: NEG
26174: PUSH
26175: EMPTY
26176: LIST
26177: LIST
26178: PUSH
26179: LD_INT 0
26181: PUSH
26182: LD_INT 2
26184: NEG
26185: PUSH
26186: EMPTY
26187: LIST
26188: LIST
26189: PUSH
26190: LD_INT 1
26192: PUSH
26193: LD_INT 1
26195: NEG
26196: PUSH
26197: EMPTY
26198: LIST
26199: LIST
26200: PUSH
26201: LD_INT 2
26203: PUSH
26204: LD_INT 0
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: LD_INT 2
26213: PUSH
26214: LD_INT 1
26216: PUSH
26217: EMPTY
26218: LIST
26219: LIST
26220: PUSH
26221: LD_INT 2
26223: PUSH
26224: LD_INT 2
26226: PUSH
26227: EMPTY
26228: LIST
26229: LIST
26230: PUSH
26231: LD_INT 1
26233: PUSH
26234: LD_INT 2
26236: PUSH
26237: EMPTY
26238: LIST
26239: LIST
26240: PUSH
26241: LD_INT 0
26243: PUSH
26244: LD_INT 2
26246: PUSH
26247: EMPTY
26248: LIST
26249: LIST
26250: PUSH
26251: LD_INT 1
26253: NEG
26254: PUSH
26255: LD_INT 1
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 2
26264: NEG
26265: PUSH
26266: LD_INT 0
26268: PUSH
26269: EMPTY
26270: LIST
26271: LIST
26272: PUSH
26273: LD_INT 2
26275: NEG
26276: PUSH
26277: LD_INT 1
26279: NEG
26280: PUSH
26281: EMPTY
26282: LIST
26283: LIST
26284: PUSH
26285: LD_INT 2
26287: NEG
26288: PUSH
26289: LD_INT 2
26291: NEG
26292: PUSH
26293: EMPTY
26294: LIST
26295: LIST
26296: PUSH
26297: EMPTY
26298: LIST
26299: LIST
26300: LIST
26301: LIST
26302: LIST
26303: LIST
26304: LIST
26305: LIST
26306: LIST
26307: LIST
26308: LIST
26309: LIST
26310: LIST
26311: LIST
26312: LIST
26313: LIST
26314: LIST
26315: LIST
26316: LIST
26317: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26318: LD_ADDR_VAR 0 20
26322: PUSH
26323: LD_INT 0
26325: PUSH
26326: LD_INT 0
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 0
26335: PUSH
26336: LD_INT 1
26338: NEG
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 1
26346: PUSH
26347: LD_INT 0
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 1
26356: PUSH
26357: LD_INT 1
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 0
26366: PUSH
26367: LD_INT 1
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: LD_INT 1
26376: NEG
26377: PUSH
26378: LD_INT 0
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 1
26387: NEG
26388: PUSH
26389: LD_INT 1
26391: NEG
26392: PUSH
26393: EMPTY
26394: LIST
26395: LIST
26396: PUSH
26397: LD_INT 1
26399: NEG
26400: PUSH
26401: LD_INT 2
26403: NEG
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 0
26411: PUSH
26412: LD_INT 2
26414: NEG
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: PUSH
26420: LD_INT 1
26422: PUSH
26423: LD_INT 1
26425: NEG
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PUSH
26431: LD_INT 2
26433: PUSH
26434: LD_INT 0
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: PUSH
26441: LD_INT 2
26443: PUSH
26444: LD_INT 1
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 2
26453: PUSH
26454: LD_INT 2
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PUSH
26461: LD_INT 1
26463: PUSH
26464: LD_INT 2
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: PUSH
26471: LD_INT 0
26473: PUSH
26474: LD_INT 2
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: PUSH
26481: LD_INT 1
26483: NEG
26484: PUSH
26485: LD_INT 1
26487: PUSH
26488: EMPTY
26489: LIST
26490: LIST
26491: PUSH
26492: LD_INT 2
26494: NEG
26495: PUSH
26496: LD_INT 0
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: PUSH
26503: LD_INT 2
26505: NEG
26506: PUSH
26507: LD_INT 1
26509: NEG
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 2
26517: NEG
26518: PUSH
26519: LD_INT 2
26521: NEG
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: LIST
26531: LIST
26532: LIST
26533: LIST
26534: LIST
26535: LIST
26536: LIST
26537: LIST
26538: LIST
26539: LIST
26540: LIST
26541: LIST
26542: LIST
26543: LIST
26544: LIST
26545: LIST
26546: LIST
26547: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26548: LD_ADDR_VAR 0 21
26552: PUSH
26553: LD_INT 0
26555: PUSH
26556: LD_INT 0
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 0
26565: PUSH
26566: LD_INT 1
26568: NEG
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: LD_INT 1
26576: PUSH
26577: LD_INT 0
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: LD_INT 1
26586: PUSH
26587: LD_INT 1
26589: PUSH
26590: EMPTY
26591: LIST
26592: LIST
26593: PUSH
26594: LD_INT 0
26596: PUSH
26597: LD_INT 1
26599: PUSH
26600: EMPTY
26601: LIST
26602: LIST
26603: PUSH
26604: LD_INT 1
26606: NEG
26607: PUSH
26608: LD_INT 0
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: LD_INT 1
26617: NEG
26618: PUSH
26619: LD_INT 1
26621: NEG
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: PUSH
26627: LD_INT 1
26629: NEG
26630: PUSH
26631: LD_INT 2
26633: NEG
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: PUSH
26639: LD_INT 0
26641: PUSH
26642: LD_INT 2
26644: NEG
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: LD_INT 1
26652: PUSH
26653: LD_INT 1
26655: NEG
26656: PUSH
26657: EMPTY
26658: LIST
26659: LIST
26660: PUSH
26661: LD_INT 2
26663: PUSH
26664: LD_INT 0
26666: PUSH
26667: EMPTY
26668: LIST
26669: LIST
26670: PUSH
26671: LD_INT 2
26673: PUSH
26674: LD_INT 1
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PUSH
26681: LD_INT 2
26683: PUSH
26684: LD_INT 2
26686: PUSH
26687: EMPTY
26688: LIST
26689: LIST
26690: PUSH
26691: LD_INT 1
26693: PUSH
26694: LD_INT 2
26696: PUSH
26697: EMPTY
26698: LIST
26699: LIST
26700: PUSH
26701: LD_INT 0
26703: PUSH
26704: LD_INT 2
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: PUSH
26711: LD_INT 1
26713: NEG
26714: PUSH
26715: LD_INT 1
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: PUSH
26722: LD_INT 2
26724: NEG
26725: PUSH
26726: LD_INT 0
26728: PUSH
26729: EMPTY
26730: LIST
26731: LIST
26732: PUSH
26733: LD_INT 2
26735: NEG
26736: PUSH
26737: LD_INT 1
26739: NEG
26740: PUSH
26741: EMPTY
26742: LIST
26743: LIST
26744: PUSH
26745: LD_INT 2
26747: NEG
26748: PUSH
26749: LD_INT 2
26751: NEG
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: PUSH
26757: EMPTY
26758: LIST
26759: LIST
26760: LIST
26761: LIST
26762: LIST
26763: LIST
26764: LIST
26765: LIST
26766: LIST
26767: LIST
26768: LIST
26769: LIST
26770: LIST
26771: LIST
26772: LIST
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26778: LD_ADDR_VAR 0 22
26782: PUSH
26783: LD_INT 0
26785: PUSH
26786: LD_INT 0
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PUSH
26793: LD_INT 0
26795: PUSH
26796: LD_INT 1
26798: NEG
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: PUSH
26804: LD_INT 1
26806: PUSH
26807: LD_INT 0
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: PUSH
26814: LD_INT 1
26816: PUSH
26817: LD_INT 1
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PUSH
26824: LD_INT 0
26826: PUSH
26827: LD_INT 1
26829: PUSH
26830: EMPTY
26831: LIST
26832: LIST
26833: PUSH
26834: LD_INT 1
26836: NEG
26837: PUSH
26838: LD_INT 0
26840: PUSH
26841: EMPTY
26842: LIST
26843: LIST
26844: PUSH
26845: LD_INT 1
26847: NEG
26848: PUSH
26849: LD_INT 1
26851: NEG
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 1
26859: NEG
26860: PUSH
26861: LD_INT 2
26863: NEG
26864: PUSH
26865: EMPTY
26866: LIST
26867: LIST
26868: PUSH
26869: LD_INT 0
26871: PUSH
26872: LD_INT 2
26874: NEG
26875: PUSH
26876: EMPTY
26877: LIST
26878: LIST
26879: PUSH
26880: LD_INT 1
26882: PUSH
26883: LD_INT 1
26885: NEG
26886: PUSH
26887: EMPTY
26888: LIST
26889: LIST
26890: PUSH
26891: LD_INT 2
26893: PUSH
26894: LD_INT 0
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 2
26903: PUSH
26904: LD_INT 1
26906: PUSH
26907: EMPTY
26908: LIST
26909: LIST
26910: PUSH
26911: LD_INT 2
26913: PUSH
26914: LD_INT 2
26916: PUSH
26917: EMPTY
26918: LIST
26919: LIST
26920: PUSH
26921: LD_INT 1
26923: PUSH
26924: LD_INT 2
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: PUSH
26931: LD_INT 0
26933: PUSH
26934: LD_INT 2
26936: PUSH
26937: EMPTY
26938: LIST
26939: LIST
26940: PUSH
26941: LD_INT 1
26943: NEG
26944: PUSH
26945: LD_INT 1
26947: PUSH
26948: EMPTY
26949: LIST
26950: LIST
26951: PUSH
26952: LD_INT 2
26954: NEG
26955: PUSH
26956: LD_INT 0
26958: PUSH
26959: EMPTY
26960: LIST
26961: LIST
26962: PUSH
26963: LD_INT 2
26965: NEG
26966: PUSH
26967: LD_INT 1
26969: NEG
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 2
26977: NEG
26978: PUSH
26979: LD_INT 2
26981: NEG
26982: PUSH
26983: EMPTY
26984: LIST
26985: LIST
26986: PUSH
26987: EMPTY
26988: LIST
26989: LIST
26990: LIST
26991: LIST
26992: LIST
26993: LIST
26994: LIST
26995: LIST
26996: LIST
26997: LIST
26998: LIST
26999: LIST
27000: LIST
27001: LIST
27002: LIST
27003: LIST
27004: LIST
27005: LIST
27006: LIST
27007: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27008: LD_ADDR_VAR 0 23
27012: PUSH
27013: LD_INT 0
27015: PUSH
27016: LD_INT 0
27018: PUSH
27019: EMPTY
27020: LIST
27021: LIST
27022: PUSH
27023: LD_INT 0
27025: PUSH
27026: LD_INT 1
27028: NEG
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PUSH
27034: LD_INT 1
27036: PUSH
27037: LD_INT 0
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PUSH
27044: LD_INT 1
27046: PUSH
27047: LD_INT 1
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: LD_INT 0
27056: PUSH
27057: LD_INT 1
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PUSH
27064: LD_INT 1
27066: NEG
27067: PUSH
27068: LD_INT 0
27070: PUSH
27071: EMPTY
27072: LIST
27073: LIST
27074: PUSH
27075: LD_INT 1
27077: NEG
27078: PUSH
27079: LD_INT 1
27081: NEG
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 1
27089: NEG
27090: PUSH
27091: LD_INT 2
27093: NEG
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: PUSH
27099: LD_INT 0
27101: PUSH
27102: LD_INT 2
27104: NEG
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 1
27112: PUSH
27113: LD_INT 1
27115: NEG
27116: PUSH
27117: EMPTY
27118: LIST
27119: LIST
27120: PUSH
27121: LD_INT 2
27123: PUSH
27124: LD_INT 0
27126: PUSH
27127: EMPTY
27128: LIST
27129: LIST
27130: PUSH
27131: LD_INT 2
27133: PUSH
27134: LD_INT 1
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 2
27143: PUSH
27144: LD_INT 2
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 1
27153: PUSH
27154: LD_INT 2
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: LD_INT 0
27163: PUSH
27164: LD_INT 2
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: LD_INT 1
27173: NEG
27174: PUSH
27175: LD_INT 1
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: PUSH
27182: LD_INT 2
27184: NEG
27185: PUSH
27186: LD_INT 0
27188: PUSH
27189: EMPTY
27190: LIST
27191: LIST
27192: PUSH
27193: LD_INT 2
27195: NEG
27196: PUSH
27197: LD_INT 1
27199: NEG
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 2
27207: NEG
27208: PUSH
27209: LD_INT 2
27211: NEG
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: PUSH
27217: LD_INT 2
27219: NEG
27220: PUSH
27221: LD_INT 3
27223: NEG
27224: PUSH
27225: EMPTY
27226: LIST
27227: LIST
27228: PUSH
27229: LD_INT 1
27231: NEG
27232: PUSH
27233: LD_INT 3
27235: NEG
27236: PUSH
27237: EMPTY
27238: LIST
27239: LIST
27240: PUSH
27241: LD_INT 1
27243: PUSH
27244: LD_INT 2
27246: NEG
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 2
27254: PUSH
27255: LD_INT 1
27257: NEG
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: LIST
27267: LIST
27268: LIST
27269: LIST
27270: LIST
27271: LIST
27272: LIST
27273: LIST
27274: LIST
27275: LIST
27276: LIST
27277: LIST
27278: LIST
27279: LIST
27280: LIST
27281: LIST
27282: LIST
27283: LIST
27284: LIST
27285: LIST
27286: LIST
27287: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27288: LD_ADDR_VAR 0 24
27292: PUSH
27293: LD_INT 0
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: EMPTY
27300: LIST
27301: LIST
27302: PUSH
27303: LD_INT 0
27305: PUSH
27306: LD_INT 1
27308: NEG
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 1
27316: PUSH
27317: LD_INT 0
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PUSH
27324: LD_INT 1
27326: PUSH
27327: LD_INT 1
27329: PUSH
27330: EMPTY
27331: LIST
27332: LIST
27333: PUSH
27334: LD_INT 0
27336: PUSH
27337: LD_INT 1
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 1
27346: NEG
27347: PUSH
27348: LD_INT 0
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: LD_INT 1
27357: NEG
27358: PUSH
27359: LD_INT 1
27361: NEG
27362: PUSH
27363: EMPTY
27364: LIST
27365: LIST
27366: PUSH
27367: LD_INT 1
27369: NEG
27370: PUSH
27371: LD_INT 2
27373: NEG
27374: PUSH
27375: EMPTY
27376: LIST
27377: LIST
27378: PUSH
27379: LD_INT 0
27381: PUSH
27382: LD_INT 2
27384: NEG
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 1
27392: PUSH
27393: LD_INT 1
27395: NEG
27396: PUSH
27397: EMPTY
27398: LIST
27399: LIST
27400: PUSH
27401: LD_INT 2
27403: PUSH
27404: LD_INT 0
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: PUSH
27411: LD_INT 2
27413: PUSH
27414: LD_INT 1
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 2
27423: PUSH
27424: LD_INT 2
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: LD_INT 1
27433: PUSH
27434: LD_INT 2
27436: PUSH
27437: EMPTY
27438: LIST
27439: LIST
27440: PUSH
27441: LD_INT 0
27443: PUSH
27444: LD_INT 2
27446: PUSH
27447: EMPTY
27448: LIST
27449: LIST
27450: PUSH
27451: LD_INT 1
27453: NEG
27454: PUSH
27455: LD_INT 1
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: LD_INT 2
27464: NEG
27465: PUSH
27466: LD_INT 0
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: PUSH
27473: LD_INT 2
27475: NEG
27476: PUSH
27477: LD_INT 1
27479: NEG
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PUSH
27485: LD_INT 2
27487: NEG
27488: PUSH
27489: LD_INT 2
27491: NEG
27492: PUSH
27493: EMPTY
27494: LIST
27495: LIST
27496: PUSH
27497: LD_INT 1
27499: PUSH
27500: LD_INT 2
27502: NEG
27503: PUSH
27504: EMPTY
27505: LIST
27506: LIST
27507: PUSH
27508: LD_INT 2
27510: PUSH
27511: LD_INT 1
27513: NEG
27514: PUSH
27515: EMPTY
27516: LIST
27517: LIST
27518: PUSH
27519: LD_INT 3
27521: PUSH
27522: LD_INT 1
27524: PUSH
27525: EMPTY
27526: LIST
27527: LIST
27528: PUSH
27529: LD_INT 3
27531: PUSH
27532: LD_INT 2
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: LIST
27559: LIST
27560: LIST
27561: LIST
27562: LIST
27563: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27564: LD_ADDR_VAR 0 25
27568: PUSH
27569: LD_INT 0
27571: PUSH
27572: LD_INT 0
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: PUSH
27579: LD_INT 0
27581: PUSH
27582: LD_INT 1
27584: NEG
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: PUSH
27590: LD_INT 1
27592: PUSH
27593: LD_INT 0
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: LD_INT 1
27602: PUSH
27603: LD_INT 1
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 0
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 1
27622: NEG
27623: PUSH
27624: LD_INT 0
27626: PUSH
27627: EMPTY
27628: LIST
27629: LIST
27630: PUSH
27631: LD_INT 1
27633: NEG
27634: PUSH
27635: LD_INT 1
27637: NEG
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: LD_INT 1
27645: NEG
27646: PUSH
27647: LD_INT 2
27649: NEG
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PUSH
27655: LD_INT 0
27657: PUSH
27658: LD_INT 2
27660: NEG
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PUSH
27666: LD_INT 1
27668: PUSH
27669: LD_INT 1
27671: NEG
27672: PUSH
27673: EMPTY
27674: LIST
27675: LIST
27676: PUSH
27677: LD_INT 2
27679: PUSH
27680: LD_INT 0
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: PUSH
27687: LD_INT 2
27689: PUSH
27690: LD_INT 1
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PUSH
27697: LD_INT 2
27699: PUSH
27700: LD_INT 2
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 1
27709: PUSH
27710: LD_INT 2
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: LD_INT 2
27722: PUSH
27723: EMPTY
27724: LIST
27725: LIST
27726: PUSH
27727: LD_INT 1
27729: NEG
27730: PUSH
27731: LD_INT 1
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: PUSH
27738: LD_INT 2
27740: NEG
27741: PUSH
27742: LD_INT 0
27744: PUSH
27745: EMPTY
27746: LIST
27747: LIST
27748: PUSH
27749: LD_INT 2
27751: NEG
27752: PUSH
27753: LD_INT 1
27755: NEG
27756: PUSH
27757: EMPTY
27758: LIST
27759: LIST
27760: PUSH
27761: LD_INT 2
27763: NEG
27764: PUSH
27765: LD_INT 2
27767: NEG
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 3
27775: PUSH
27776: LD_INT 1
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 3
27785: PUSH
27786: LD_INT 2
27788: PUSH
27789: EMPTY
27790: LIST
27791: LIST
27792: PUSH
27793: LD_INT 2
27795: PUSH
27796: LD_INT 3
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 1
27805: PUSH
27806: LD_INT 3
27808: PUSH
27809: EMPTY
27810: LIST
27811: LIST
27812: PUSH
27813: EMPTY
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: LIST
27824: LIST
27825: LIST
27826: LIST
27827: LIST
27828: LIST
27829: LIST
27830: LIST
27831: LIST
27832: LIST
27833: LIST
27834: LIST
27835: LIST
27836: LIST
27837: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27838: LD_ADDR_VAR 0 26
27842: PUSH
27843: LD_INT 0
27845: PUSH
27846: LD_INT 0
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: PUSH
27853: LD_INT 0
27855: PUSH
27856: LD_INT 1
27858: NEG
27859: PUSH
27860: EMPTY
27861: LIST
27862: LIST
27863: PUSH
27864: LD_INT 1
27866: PUSH
27867: LD_INT 0
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: PUSH
27874: LD_INT 1
27876: PUSH
27877: LD_INT 1
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 0
27886: PUSH
27887: LD_INT 1
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PUSH
27894: LD_INT 1
27896: NEG
27897: PUSH
27898: LD_INT 0
27900: PUSH
27901: EMPTY
27902: LIST
27903: LIST
27904: PUSH
27905: LD_INT 1
27907: NEG
27908: PUSH
27909: LD_INT 1
27911: NEG
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 1
27919: NEG
27920: PUSH
27921: LD_INT 2
27923: NEG
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: PUSH
27929: LD_INT 0
27931: PUSH
27932: LD_INT 2
27934: NEG
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: PUSH
27940: LD_INT 1
27942: PUSH
27943: LD_INT 1
27945: NEG
27946: PUSH
27947: EMPTY
27948: LIST
27949: LIST
27950: PUSH
27951: LD_INT 2
27953: PUSH
27954: LD_INT 0
27956: PUSH
27957: EMPTY
27958: LIST
27959: LIST
27960: PUSH
27961: LD_INT 2
27963: PUSH
27964: LD_INT 1
27966: PUSH
27967: EMPTY
27968: LIST
27969: LIST
27970: PUSH
27971: LD_INT 2
27973: PUSH
27974: LD_INT 2
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 1
27983: PUSH
27984: LD_INT 2
27986: PUSH
27987: EMPTY
27988: LIST
27989: LIST
27990: PUSH
27991: LD_INT 0
27993: PUSH
27994: LD_INT 2
27996: PUSH
27997: EMPTY
27998: LIST
27999: LIST
28000: PUSH
28001: LD_INT 1
28003: NEG
28004: PUSH
28005: LD_INT 1
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 2
28014: NEG
28015: PUSH
28016: LD_INT 0
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: LD_INT 2
28025: NEG
28026: PUSH
28027: LD_INT 1
28029: NEG
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 2
28037: NEG
28038: PUSH
28039: LD_INT 2
28041: NEG
28042: PUSH
28043: EMPTY
28044: LIST
28045: LIST
28046: PUSH
28047: LD_INT 2
28049: PUSH
28050: LD_INT 3
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 1
28059: PUSH
28060: LD_INT 3
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: LD_INT 1
28069: NEG
28070: PUSH
28071: LD_INT 2
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: PUSH
28078: LD_INT 2
28080: NEG
28081: PUSH
28082: LD_INT 1
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: LIST
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: LIST
28110: LIST
28111: LIST
28112: LIST
28113: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28114: LD_ADDR_VAR 0 27
28118: PUSH
28119: LD_INT 0
28121: PUSH
28122: LD_INT 0
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PUSH
28129: LD_INT 0
28131: PUSH
28132: LD_INT 1
28134: NEG
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PUSH
28140: LD_INT 1
28142: PUSH
28143: LD_INT 0
28145: PUSH
28146: EMPTY
28147: LIST
28148: LIST
28149: PUSH
28150: LD_INT 1
28152: PUSH
28153: LD_INT 1
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PUSH
28160: LD_INT 0
28162: PUSH
28163: LD_INT 1
28165: PUSH
28166: EMPTY
28167: LIST
28168: LIST
28169: PUSH
28170: LD_INT 1
28172: NEG
28173: PUSH
28174: LD_INT 0
28176: PUSH
28177: EMPTY
28178: LIST
28179: LIST
28180: PUSH
28181: LD_INT 1
28183: NEG
28184: PUSH
28185: LD_INT 1
28187: NEG
28188: PUSH
28189: EMPTY
28190: LIST
28191: LIST
28192: PUSH
28193: LD_INT 1
28195: NEG
28196: PUSH
28197: LD_INT 2
28199: NEG
28200: PUSH
28201: EMPTY
28202: LIST
28203: LIST
28204: PUSH
28205: LD_INT 0
28207: PUSH
28208: LD_INT 2
28210: NEG
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: PUSH
28216: LD_INT 1
28218: PUSH
28219: LD_INT 1
28221: NEG
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 2
28229: PUSH
28230: LD_INT 0
28232: PUSH
28233: EMPTY
28234: LIST
28235: LIST
28236: PUSH
28237: LD_INT 2
28239: PUSH
28240: LD_INT 1
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PUSH
28247: LD_INT 2
28249: PUSH
28250: LD_INT 2
28252: PUSH
28253: EMPTY
28254: LIST
28255: LIST
28256: PUSH
28257: LD_INT 1
28259: PUSH
28260: LD_INT 2
28262: PUSH
28263: EMPTY
28264: LIST
28265: LIST
28266: PUSH
28267: LD_INT 0
28269: PUSH
28270: LD_INT 2
28272: PUSH
28273: EMPTY
28274: LIST
28275: LIST
28276: PUSH
28277: LD_INT 1
28279: NEG
28280: PUSH
28281: LD_INT 1
28283: PUSH
28284: EMPTY
28285: LIST
28286: LIST
28287: PUSH
28288: LD_INT 2
28290: NEG
28291: PUSH
28292: LD_INT 0
28294: PUSH
28295: EMPTY
28296: LIST
28297: LIST
28298: PUSH
28299: LD_INT 2
28301: NEG
28302: PUSH
28303: LD_INT 1
28305: NEG
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: LD_INT 2
28313: NEG
28314: PUSH
28315: LD_INT 2
28317: NEG
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 1
28325: NEG
28326: PUSH
28327: LD_INT 2
28329: PUSH
28330: EMPTY
28331: LIST
28332: LIST
28333: PUSH
28334: LD_INT 2
28336: NEG
28337: PUSH
28338: LD_INT 1
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 3
28347: NEG
28348: PUSH
28349: LD_INT 1
28351: NEG
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 3
28359: NEG
28360: PUSH
28361: LD_INT 2
28363: NEG
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PUSH
28369: EMPTY
28370: LIST
28371: LIST
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: LIST
28377: LIST
28378: LIST
28379: LIST
28380: LIST
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: LIST
28388: LIST
28389: LIST
28390: LIST
28391: LIST
28392: LIST
28393: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28394: LD_ADDR_VAR 0 28
28398: PUSH
28399: LD_INT 0
28401: PUSH
28402: LD_INT 0
28404: PUSH
28405: EMPTY
28406: LIST
28407: LIST
28408: PUSH
28409: LD_INT 0
28411: PUSH
28412: LD_INT 1
28414: NEG
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PUSH
28420: LD_INT 1
28422: PUSH
28423: LD_INT 0
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: PUSH
28430: LD_INT 1
28432: PUSH
28433: LD_INT 1
28435: PUSH
28436: EMPTY
28437: LIST
28438: LIST
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: LD_INT 1
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: LD_INT 1
28452: NEG
28453: PUSH
28454: LD_INT 0
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PUSH
28461: LD_INT 1
28463: NEG
28464: PUSH
28465: LD_INT 1
28467: NEG
28468: PUSH
28469: EMPTY
28470: LIST
28471: LIST
28472: PUSH
28473: LD_INT 1
28475: NEG
28476: PUSH
28477: LD_INT 2
28479: NEG
28480: PUSH
28481: EMPTY
28482: LIST
28483: LIST
28484: PUSH
28485: LD_INT 0
28487: PUSH
28488: LD_INT 2
28490: NEG
28491: PUSH
28492: EMPTY
28493: LIST
28494: LIST
28495: PUSH
28496: LD_INT 1
28498: PUSH
28499: LD_INT 1
28501: NEG
28502: PUSH
28503: EMPTY
28504: LIST
28505: LIST
28506: PUSH
28507: LD_INT 2
28509: PUSH
28510: LD_INT 0
28512: PUSH
28513: EMPTY
28514: LIST
28515: LIST
28516: PUSH
28517: LD_INT 2
28519: PUSH
28520: LD_INT 1
28522: PUSH
28523: EMPTY
28524: LIST
28525: LIST
28526: PUSH
28527: LD_INT 2
28529: PUSH
28530: LD_INT 2
28532: PUSH
28533: EMPTY
28534: LIST
28535: LIST
28536: PUSH
28537: LD_INT 1
28539: PUSH
28540: LD_INT 2
28542: PUSH
28543: EMPTY
28544: LIST
28545: LIST
28546: PUSH
28547: LD_INT 0
28549: PUSH
28550: LD_INT 2
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PUSH
28557: LD_INT 1
28559: NEG
28560: PUSH
28561: LD_INT 1
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: PUSH
28568: LD_INT 2
28570: NEG
28571: PUSH
28572: LD_INT 0
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 2
28581: NEG
28582: PUSH
28583: LD_INT 1
28585: NEG
28586: PUSH
28587: EMPTY
28588: LIST
28589: LIST
28590: PUSH
28591: LD_INT 2
28593: NEG
28594: PUSH
28595: LD_INT 2
28597: NEG
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 2
28605: NEG
28606: PUSH
28607: LD_INT 3
28609: NEG
28610: PUSH
28611: EMPTY
28612: LIST
28613: LIST
28614: PUSH
28615: LD_INT 1
28617: NEG
28618: PUSH
28619: LD_INT 3
28621: NEG
28622: PUSH
28623: EMPTY
28624: LIST
28625: LIST
28626: PUSH
28627: LD_INT 3
28629: NEG
28630: PUSH
28631: LD_INT 1
28633: NEG
28634: PUSH
28635: EMPTY
28636: LIST
28637: LIST
28638: PUSH
28639: LD_INT 3
28641: NEG
28642: PUSH
28643: LD_INT 2
28645: NEG
28646: PUSH
28647: EMPTY
28648: LIST
28649: LIST
28650: PUSH
28651: EMPTY
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: LIST
28663: LIST
28664: LIST
28665: LIST
28666: LIST
28667: LIST
28668: LIST
28669: LIST
28670: LIST
28671: LIST
28672: LIST
28673: LIST
28674: LIST
28675: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28676: LD_ADDR_VAR 0 29
28680: PUSH
28681: LD_INT 0
28683: PUSH
28684: LD_INT 0
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PUSH
28691: LD_INT 0
28693: PUSH
28694: LD_INT 1
28696: NEG
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 1
28704: PUSH
28705: LD_INT 0
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: LD_INT 1
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 0
28724: PUSH
28725: LD_INT 1
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: LD_INT 0
28738: PUSH
28739: EMPTY
28740: LIST
28741: LIST
28742: PUSH
28743: LD_INT 1
28745: NEG
28746: PUSH
28747: LD_INT 1
28749: NEG
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: LD_INT 1
28757: NEG
28758: PUSH
28759: LD_INT 2
28761: NEG
28762: PUSH
28763: EMPTY
28764: LIST
28765: LIST
28766: PUSH
28767: LD_INT 0
28769: PUSH
28770: LD_INT 2
28772: NEG
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: PUSH
28778: LD_INT 1
28780: PUSH
28781: LD_INT 1
28783: NEG
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 2
28791: PUSH
28792: LD_INT 0
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: LD_INT 2
28801: PUSH
28802: LD_INT 1
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 1
28811: PUSH
28812: LD_INT 2
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 0
28821: PUSH
28822: LD_INT 2
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PUSH
28829: LD_INT 1
28831: NEG
28832: PUSH
28833: LD_INT 1
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: LD_INT 2
28842: NEG
28843: PUSH
28844: LD_INT 1
28846: NEG
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: PUSH
28852: LD_INT 2
28854: NEG
28855: PUSH
28856: LD_INT 2
28858: NEG
28859: PUSH
28860: EMPTY
28861: LIST
28862: LIST
28863: PUSH
28864: LD_INT 2
28866: NEG
28867: PUSH
28868: LD_INT 3
28870: NEG
28871: PUSH
28872: EMPTY
28873: LIST
28874: LIST
28875: PUSH
28876: LD_INT 2
28878: PUSH
28879: LD_INT 1
28881: NEG
28882: PUSH
28883: EMPTY
28884: LIST
28885: LIST
28886: PUSH
28887: LD_INT 3
28889: PUSH
28890: LD_INT 1
28892: PUSH
28893: EMPTY
28894: LIST
28895: LIST
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: LD_INT 3
28902: PUSH
28903: EMPTY
28904: LIST
28905: LIST
28906: PUSH
28907: LD_INT 1
28909: NEG
28910: PUSH
28911: LD_INT 2
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 3
28920: NEG
28921: PUSH
28922: LD_INT 2
28924: NEG
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: LIST
28950: LIST
28951: LIST
28952: LIST
28953: LIST
28954: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28955: LD_ADDR_VAR 0 30
28959: PUSH
28960: LD_INT 0
28962: PUSH
28963: LD_INT 0
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 0
28972: PUSH
28973: LD_INT 1
28975: NEG
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: LD_INT 1
28983: PUSH
28984: LD_INT 0
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 1
28993: PUSH
28994: LD_INT 1
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: LD_INT 1
29006: PUSH
29007: EMPTY
29008: LIST
29009: LIST
29010: PUSH
29011: LD_INT 1
29013: NEG
29014: PUSH
29015: LD_INT 0
29017: PUSH
29018: EMPTY
29019: LIST
29020: LIST
29021: PUSH
29022: LD_INT 1
29024: NEG
29025: PUSH
29026: LD_INT 1
29028: NEG
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 1
29036: NEG
29037: PUSH
29038: LD_INT 2
29040: NEG
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 0
29048: PUSH
29049: LD_INT 2
29051: NEG
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 1
29059: PUSH
29060: LD_INT 1
29062: NEG
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 2
29070: PUSH
29071: LD_INT 0
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 2
29080: PUSH
29081: LD_INT 1
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 2
29090: PUSH
29091: LD_INT 2
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: LD_INT 1
29100: PUSH
29101: LD_INT 2
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: PUSH
29108: LD_INT 1
29110: NEG
29111: PUSH
29112: LD_INT 1
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PUSH
29119: LD_INT 2
29121: NEG
29122: PUSH
29123: LD_INT 0
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 2
29132: NEG
29133: PUSH
29134: LD_INT 1
29136: NEG
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 1
29144: NEG
29145: PUSH
29146: LD_INT 3
29148: NEG
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: LD_INT 1
29156: PUSH
29157: LD_INT 2
29159: NEG
29160: PUSH
29161: EMPTY
29162: LIST
29163: LIST
29164: PUSH
29165: LD_INT 3
29167: PUSH
29168: LD_INT 2
29170: PUSH
29171: EMPTY
29172: LIST
29173: LIST
29174: PUSH
29175: LD_INT 2
29177: PUSH
29178: LD_INT 3
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 2
29187: NEG
29188: PUSH
29189: LD_INT 1
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 3
29198: NEG
29199: PUSH
29200: LD_INT 1
29202: NEG
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: LIST
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29233: LD_ADDR_VAR 0 31
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: LD_INT 0
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: LD_INT 1
29253: NEG
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: PUSH
29262: LD_INT 0
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 1
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 0
29281: PUSH
29282: LD_INT 1
29284: PUSH
29285: EMPTY
29286: LIST
29287: LIST
29288: PUSH
29289: LD_INT 1
29291: NEG
29292: PUSH
29293: LD_INT 0
29295: PUSH
29296: EMPTY
29297: LIST
29298: LIST
29299: PUSH
29300: LD_INT 1
29302: NEG
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: LD_INT 1
29314: NEG
29315: PUSH
29316: LD_INT 2
29318: NEG
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: LD_INT 1
29326: PUSH
29327: LD_INT 1
29329: NEG
29330: PUSH
29331: EMPTY
29332: LIST
29333: LIST
29334: PUSH
29335: LD_INT 2
29337: PUSH
29338: LD_INT 0
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 2
29347: PUSH
29348: LD_INT 1
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: LD_INT 2
29357: PUSH
29358: LD_INT 2
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: LD_INT 1
29367: PUSH
29368: LD_INT 2
29370: PUSH
29371: EMPTY
29372: LIST
29373: LIST
29374: PUSH
29375: LD_INT 0
29377: PUSH
29378: LD_INT 2
29380: PUSH
29381: EMPTY
29382: LIST
29383: LIST
29384: PUSH
29385: LD_INT 1
29387: NEG
29388: PUSH
29389: LD_INT 1
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 2
29398: NEG
29399: PUSH
29400: LD_INT 1
29402: NEG
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 2
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: LD_INT 3
29426: NEG
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 2
29434: PUSH
29435: LD_INT 1
29437: NEG
29438: PUSH
29439: EMPTY
29440: LIST
29441: LIST
29442: PUSH
29443: LD_INT 3
29445: PUSH
29446: LD_INT 1
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 1
29455: PUSH
29456: LD_INT 3
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 1
29465: NEG
29466: PUSH
29467: LD_INT 2
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: PUSH
29474: LD_INT 3
29476: NEG
29477: PUSH
29478: LD_INT 2
29480: NEG
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: LIST
29507: LIST
29508: LIST
29509: LIST
29510: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29511: LD_ADDR_VAR 0 32
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 0
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 0
29528: PUSH
29529: LD_INT 1
29531: NEG
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 0
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 1
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 0
29559: PUSH
29560: LD_INT 1
29562: PUSH
29563: EMPTY
29564: LIST
29565: LIST
29566: PUSH
29567: LD_INT 1
29569: NEG
29570: PUSH
29571: LD_INT 0
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: LD_INT 1
29580: NEG
29581: PUSH
29582: LD_INT 1
29584: NEG
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: PUSH
29590: LD_INT 1
29592: NEG
29593: PUSH
29594: LD_INT 2
29596: NEG
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: LD_INT 0
29604: PUSH
29605: LD_INT 2
29607: NEG
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 1
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 2
29636: PUSH
29637: LD_INT 2
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 1
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 0
29656: PUSH
29657: LD_INT 2
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 1
29666: NEG
29667: PUSH
29668: LD_INT 1
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 2
29677: NEG
29678: PUSH
29679: LD_INT 0
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: LD_INT 2
29688: NEG
29689: PUSH
29690: LD_INT 1
29692: NEG
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 1
29700: NEG
29701: PUSH
29702: LD_INT 3
29704: NEG
29705: PUSH
29706: EMPTY
29707: LIST
29708: LIST
29709: PUSH
29710: LD_INT 1
29712: PUSH
29713: LD_INT 2
29715: NEG
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: LD_INT 3
29723: PUSH
29724: LD_INT 2
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 2
29733: PUSH
29734: LD_INT 3
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 2
29743: NEG
29744: PUSH
29745: LD_INT 1
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 3
29754: NEG
29755: PUSH
29756: LD_INT 1
29758: NEG
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: LIST
29768: LIST
29769: LIST
29770: LIST
29771: LIST
29772: LIST
29773: LIST
29774: LIST
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: LIST
29780: LIST
29781: LIST
29782: LIST
29783: LIST
29784: LIST
29785: LIST
29786: LIST
29787: LIST
29788: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29789: LD_ADDR_VAR 0 33
29793: PUSH
29794: LD_INT 0
29796: PUSH
29797: LD_INT 0
29799: PUSH
29800: EMPTY
29801: LIST
29802: LIST
29803: PUSH
29804: LD_INT 0
29806: PUSH
29807: LD_INT 1
29809: NEG
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 1
29817: PUSH
29818: LD_INT 0
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: PUSH
29825: LD_INT 1
29827: PUSH
29828: LD_INT 1
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: PUSH
29835: LD_INT 0
29837: PUSH
29838: LD_INT 1
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: LD_INT 1
29847: NEG
29848: PUSH
29849: LD_INT 0
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: PUSH
29856: LD_INT 1
29858: NEG
29859: PUSH
29860: LD_INT 1
29862: NEG
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 1
29870: NEG
29871: PUSH
29872: LD_INT 2
29874: NEG
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 1
29882: PUSH
29883: LD_INT 1
29885: NEG
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_INT 2
29893: PUSH
29894: LD_INT 0
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: PUSH
29901: LD_INT 2
29903: PUSH
29904: LD_INT 1
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 1
29913: PUSH
29914: LD_INT 2
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: PUSH
29921: LD_INT 0
29923: PUSH
29924: LD_INT 2
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: LD_INT 1
29933: NEG
29934: PUSH
29935: LD_INT 1
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: PUSH
29942: LD_INT 2
29944: NEG
29945: PUSH
29946: LD_INT 0
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 2
29955: NEG
29956: PUSH
29957: LD_INT 1
29959: NEG
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: LD_INT 2
29967: NEG
29968: PUSH
29969: LD_INT 2
29971: NEG
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 2
29979: NEG
29980: PUSH
29981: LD_INT 3
29983: NEG
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: LD_INT 2
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 3
30002: PUSH
30003: LD_INT 1
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 1
30012: PUSH
30013: LD_INT 3
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: LD_INT 1
30022: NEG
30023: PUSH
30024: LD_INT 2
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 3
30033: NEG
30034: PUSH
30035: LD_INT 2
30037: NEG
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: LIST
30055: LIST
30056: LIST
30057: LIST
30058: LIST
30059: LIST
30060: LIST
30061: LIST
30062: LIST
30063: LIST
30064: LIST
30065: LIST
30066: LIST
30067: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30068: LD_ADDR_VAR 0 34
30072: PUSH
30073: LD_INT 0
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 0
30085: PUSH
30086: LD_INT 1
30088: NEG
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 1
30096: PUSH
30097: LD_INT 0
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 1
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 0
30116: PUSH
30117: LD_INT 1
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PUSH
30124: LD_INT 1
30126: NEG
30127: PUSH
30128: LD_INT 0
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 1
30137: NEG
30138: PUSH
30139: LD_INT 1
30141: NEG
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 1
30149: NEG
30150: PUSH
30151: LD_INT 2
30153: NEG
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 0
30161: PUSH
30162: LD_INT 2
30164: NEG
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 1
30172: PUSH
30173: LD_INT 1
30175: NEG
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 2
30183: PUSH
30184: LD_INT 1
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: LD_INT 2
30193: PUSH
30194: LD_INT 2
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 1
30203: PUSH
30204: LD_INT 2
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 1
30213: NEG
30214: PUSH
30215: LD_INT 1
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: PUSH
30222: LD_INT 2
30224: NEG
30225: PUSH
30226: LD_INT 0
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 2
30235: NEG
30236: PUSH
30237: LD_INT 1
30239: NEG
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 2
30247: NEG
30248: PUSH
30249: LD_INT 2
30251: NEG
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 1
30259: NEG
30260: PUSH
30261: LD_INT 3
30263: NEG
30264: PUSH
30265: EMPTY
30266: LIST
30267: LIST
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: LD_INT 2
30274: NEG
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 3
30282: PUSH
30283: LD_INT 2
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 2
30292: PUSH
30293: LD_INT 3
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 2
30302: NEG
30303: PUSH
30304: LD_INT 1
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 3
30313: NEG
30314: PUSH
30315: LD_INT 1
30317: NEG
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: LIST
30343: LIST
30344: LIST
30345: LIST
30346: LIST
30347: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30348: LD_ADDR_VAR 0 35
30352: PUSH
30353: LD_INT 0
30355: PUSH
30356: LD_INT 0
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 0
30365: PUSH
30366: LD_INT 1
30368: NEG
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 1
30376: PUSH
30377: LD_INT 0
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: LD_INT 1
30386: PUSH
30387: LD_INT 1
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: PUSH
30394: LD_INT 0
30396: PUSH
30397: LD_INT 1
30399: PUSH
30400: EMPTY
30401: LIST
30402: LIST
30403: PUSH
30404: LD_INT 1
30406: NEG
30407: PUSH
30408: LD_INT 0
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: LD_INT 1
30421: NEG
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 2
30429: PUSH
30430: LD_INT 1
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PUSH
30437: LD_INT 2
30439: NEG
30440: PUSH
30441: LD_INT 1
30443: NEG
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30460: LD_ADDR_VAR 0 36
30464: PUSH
30465: LD_INT 0
30467: PUSH
30468: LD_INT 0
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 0
30477: PUSH
30478: LD_INT 1
30480: NEG
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 1
30488: PUSH
30489: LD_INT 0
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 1
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 0
30508: PUSH
30509: LD_INT 1
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 1
30518: NEG
30519: PUSH
30520: LD_INT 0
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 1
30529: NEG
30530: PUSH
30531: LD_INT 1
30533: NEG
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 1
30541: NEG
30542: PUSH
30543: LD_INT 2
30545: NEG
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 1
30553: PUSH
30554: LD_INT 2
30556: PUSH
30557: EMPTY
30558: LIST
30559: LIST
30560: PUSH
30561: EMPTY
30562: LIST
30563: LIST
30564: LIST
30565: LIST
30566: LIST
30567: LIST
30568: LIST
30569: LIST
30570: LIST
30571: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30572: LD_ADDR_VAR 0 37
30576: PUSH
30577: LD_INT 0
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: LD_INT 1
30592: NEG
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: LD_INT 1
30600: PUSH
30601: LD_INT 0
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: LD_INT 1
30610: PUSH
30611: LD_INT 1
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: LD_INT 1
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 1
30630: NEG
30631: PUSH
30632: LD_INT 0
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: PUSH
30639: LD_INT 1
30641: NEG
30642: PUSH
30643: LD_INT 1
30645: NEG
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: LD_INT 1
30653: PUSH
30654: LD_INT 1
30656: NEG
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PUSH
30662: LD_INT 1
30664: NEG
30665: PUSH
30666: LD_INT 1
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: LIST
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30684: LD_ADDR_VAR 0 38
30688: PUSH
30689: LD_INT 0
30691: PUSH
30692: LD_INT 0
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: LD_INT 1
30704: NEG
30705: PUSH
30706: EMPTY
30707: LIST
30708: LIST
30709: PUSH
30710: LD_INT 1
30712: PUSH
30713: LD_INT 0
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: LD_INT 1
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 0
30732: PUSH
30733: LD_INT 1
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 1
30742: NEG
30743: PUSH
30744: LD_INT 0
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: PUSH
30751: LD_INT 1
30753: NEG
30754: PUSH
30755: LD_INT 1
30757: NEG
30758: PUSH
30759: EMPTY
30760: LIST
30761: LIST
30762: PUSH
30763: LD_INT 2
30765: PUSH
30766: LD_INT 1
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 2
30775: NEG
30776: PUSH
30777: LD_INT 1
30779: NEG
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: LIST
30789: LIST
30790: LIST
30791: LIST
30792: LIST
30793: LIST
30794: LIST
30795: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30796: LD_ADDR_VAR 0 39
30800: PUSH
30801: LD_INT 0
30803: PUSH
30804: LD_INT 0
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 0
30813: PUSH
30814: LD_INT 1
30816: NEG
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: PUSH
30822: LD_INT 1
30824: PUSH
30825: LD_INT 0
30827: PUSH
30828: EMPTY
30829: LIST
30830: LIST
30831: PUSH
30832: LD_INT 1
30834: PUSH
30835: LD_INT 1
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: PUSH
30842: LD_INT 0
30844: PUSH
30845: LD_INT 1
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 1
30854: NEG
30855: PUSH
30856: LD_INT 0
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 1
30865: NEG
30866: PUSH
30867: LD_INT 1
30869: NEG
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PUSH
30875: LD_INT 1
30877: NEG
30878: PUSH
30879: LD_INT 2
30881: NEG
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: LD_INT 2
30892: PUSH
30893: EMPTY
30894: LIST
30895: LIST
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: LIST
30901: LIST
30902: LIST
30903: LIST
30904: LIST
30905: LIST
30906: LIST
30907: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30908: LD_ADDR_VAR 0 40
30912: PUSH
30913: LD_INT 0
30915: PUSH
30916: LD_INT 0
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 0
30925: PUSH
30926: LD_INT 1
30928: NEG
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 1
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 1
30946: PUSH
30947: LD_INT 1
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 0
30956: PUSH
30957: LD_INT 1
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: LD_INT 0
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 1
30977: NEG
30978: PUSH
30979: LD_INT 1
30981: NEG
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 1
30989: PUSH
30990: LD_INT 1
30992: NEG
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: LD_INT 1
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: LIST
31017: LIST
31018: LIST
31019: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31020: LD_ADDR_VAR 0 41
31024: PUSH
31025: LD_INT 0
31027: PUSH
31028: LD_INT 0
31030: PUSH
31031: EMPTY
31032: LIST
31033: LIST
31034: PUSH
31035: LD_INT 0
31037: PUSH
31038: LD_INT 1
31040: NEG
31041: PUSH
31042: EMPTY
31043: LIST
31044: LIST
31045: PUSH
31046: LD_INT 1
31048: PUSH
31049: LD_INT 0
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 1
31058: PUSH
31059: LD_INT 1
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 0
31068: PUSH
31069: LD_INT 1
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: LD_INT 1
31078: NEG
31079: PUSH
31080: LD_INT 0
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 1
31089: NEG
31090: PUSH
31091: LD_INT 1
31093: NEG
31094: PUSH
31095: EMPTY
31096: LIST
31097: LIST
31098: PUSH
31099: LD_INT 1
31101: NEG
31102: PUSH
31103: LD_INT 2
31105: NEG
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 1
31113: PUSH
31114: LD_INT 1
31116: NEG
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: PUSH
31122: LD_INT 2
31124: PUSH
31125: LD_INT 0
31127: PUSH
31128: EMPTY
31129: LIST
31130: LIST
31131: PUSH
31132: LD_INT 2
31134: PUSH
31135: LD_INT 1
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: PUSH
31142: LD_INT 2
31144: PUSH
31145: LD_INT 2
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 1
31154: PUSH
31155: LD_INT 2
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 1
31164: NEG
31165: PUSH
31166: LD_INT 1
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PUSH
31173: LD_INT 2
31175: NEG
31176: PUSH
31177: LD_INT 0
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: LD_INT 1
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 2
31198: NEG
31199: PUSH
31200: LD_INT 2
31202: NEG
31203: PUSH
31204: EMPTY
31205: LIST
31206: LIST
31207: PUSH
31208: LD_INT 2
31210: NEG
31211: PUSH
31212: LD_INT 3
31214: NEG
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: LD_INT 2
31222: PUSH
31223: LD_INT 1
31225: NEG
31226: PUSH
31227: EMPTY
31228: LIST
31229: LIST
31230: PUSH
31231: LD_INT 3
31233: PUSH
31234: LD_INT 0
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: PUSH
31241: LD_INT 3
31243: PUSH
31244: LD_INT 1
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 3
31253: PUSH
31254: LD_INT 2
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 3
31263: PUSH
31264: LD_INT 3
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 2
31273: PUSH
31274: LD_INT 3
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 2
31283: NEG
31284: PUSH
31285: LD_INT 1
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 3
31294: NEG
31295: PUSH
31296: LD_INT 0
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: PUSH
31303: LD_INT 3
31305: NEG
31306: PUSH
31307: LD_INT 1
31309: NEG
31310: PUSH
31311: EMPTY
31312: LIST
31313: LIST
31314: PUSH
31315: LD_INT 3
31317: NEG
31318: PUSH
31319: LD_INT 2
31321: NEG
31322: PUSH
31323: EMPTY
31324: LIST
31325: LIST
31326: PUSH
31327: LD_INT 3
31329: NEG
31330: PUSH
31331: LD_INT 3
31333: NEG
31334: PUSH
31335: EMPTY
31336: LIST
31337: LIST
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: LIST
31345: LIST
31346: LIST
31347: LIST
31348: LIST
31349: LIST
31350: LIST
31351: LIST
31352: LIST
31353: LIST
31354: LIST
31355: LIST
31356: LIST
31357: LIST
31358: LIST
31359: LIST
31360: LIST
31361: LIST
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31370: LD_ADDR_VAR 0 42
31374: PUSH
31375: LD_INT 0
31377: PUSH
31378: LD_INT 0
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 0
31387: PUSH
31388: LD_INT 1
31390: NEG
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 1
31398: PUSH
31399: LD_INT 0
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: PUSH
31406: LD_INT 1
31408: PUSH
31409: LD_INT 1
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: PUSH
31416: LD_INT 0
31418: PUSH
31419: LD_INT 1
31421: PUSH
31422: EMPTY
31423: LIST
31424: LIST
31425: PUSH
31426: LD_INT 1
31428: NEG
31429: PUSH
31430: LD_INT 0
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 1
31439: NEG
31440: PUSH
31441: LD_INT 1
31443: NEG
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: PUSH
31449: LD_INT 1
31451: NEG
31452: PUSH
31453: LD_INT 2
31455: NEG
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: LD_INT 0
31463: PUSH
31464: LD_INT 2
31466: NEG
31467: PUSH
31468: EMPTY
31469: LIST
31470: LIST
31471: PUSH
31472: LD_INT 1
31474: PUSH
31475: LD_INT 1
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 2
31485: PUSH
31486: LD_INT 1
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 2
31495: PUSH
31496: LD_INT 2
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: LD_INT 1
31505: PUSH
31506: LD_INT 2
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: LD_INT 0
31515: PUSH
31516: LD_INT 2
31518: PUSH
31519: EMPTY
31520: LIST
31521: LIST
31522: PUSH
31523: LD_INT 1
31525: NEG
31526: PUSH
31527: LD_INT 1
31529: PUSH
31530: EMPTY
31531: LIST
31532: LIST
31533: PUSH
31534: LD_INT 2
31536: NEG
31537: PUSH
31538: LD_INT 1
31540: NEG
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 2
31548: NEG
31549: PUSH
31550: LD_INT 2
31552: NEG
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 2
31560: NEG
31561: PUSH
31562: LD_INT 3
31564: NEG
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 1
31572: NEG
31573: PUSH
31574: LD_INT 3
31576: NEG
31577: PUSH
31578: EMPTY
31579: LIST
31580: LIST
31581: PUSH
31582: LD_INT 0
31584: PUSH
31585: LD_INT 3
31587: NEG
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: PUSH
31596: LD_INT 2
31598: NEG
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 3
31606: PUSH
31607: LD_INT 2
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 3
31616: PUSH
31617: LD_INT 3
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 2
31626: PUSH
31627: LD_INT 3
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 1
31636: PUSH
31637: LD_INT 3
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 0
31646: PUSH
31647: LD_INT 3
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 1
31656: NEG
31657: PUSH
31658: LD_INT 2
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 3
31667: NEG
31668: PUSH
31669: LD_INT 2
31671: NEG
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 3
31679: NEG
31680: PUSH
31681: LD_INT 3
31683: NEG
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: LIST
31693: LIST
31694: LIST
31695: LIST
31696: LIST
31697: LIST
31698: LIST
31699: LIST
31700: LIST
31701: LIST
31702: LIST
31703: LIST
31704: LIST
31705: LIST
31706: LIST
31707: LIST
31708: LIST
31709: LIST
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31720: LD_ADDR_VAR 0 43
31724: PUSH
31725: LD_INT 0
31727: PUSH
31728: LD_INT 0
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 0
31737: PUSH
31738: LD_INT 1
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: PUSH
31749: LD_INT 0
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 1
31758: PUSH
31759: LD_INT 1
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 0
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 1
31778: NEG
31779: PUSH
31780: LD_INT 0
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 1
31789: NEG
31790: PUSH
31791: LD_INT 1
31793: NEG
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 1
31801: NEG
31802: PUSH
31803: LD_INT 2
31805: NEG
31806: PUSH
31807: EMPTY
31808: LIST
31809: LIST
31810: PUSH
31811: LD_INT 0
31813: PUSH
31814: LD_INT 2
31816: NEG
31817: PUSH
31818: EMPTY
31819: LIST
31820: LIST
31821: PUSH
31822: LD_INT 1
31824: PUSH
31825: LD_INT 1
31827: NEG
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 2
31835: PUSH
31836: LD_INT 0
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: LD_INT 2
31845: PUSH
31846: LD_INT 1
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 1
31855: PUSH
31856: LD_INT 2
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 0
31865: PUSH
31866: LD_INT 2
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 1
31875: NEG
31876: PUSH
31877: LD_INT 1
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 2
31886: NEG
31887: PUSH
31888: LD_INT 0
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 2
31897: NEG
31898: PUSH
31899: LD_INT 1
31901: NEG
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 1
31909: NEG
31910: PUSH
31911: LD_INT 3
31913: NEG
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 0
31921: PUSH
31922: LD_INT 3
31924: NEG
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 1
31932: PUSH
31933: LD_INT 2
31935: NEG
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 2
31943: PUSH
31944: LD_INT 1
31946: NEG
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PUSH
31952: LD_INT 3
31954: PUSH
31955: LD_INT 0
31957: PUSH
31958: EMPTY
31959: LIST
31960: LIST
31961: PUSH
31962: LD_INT 3
31964: PUSH
31965: LD_INT 1
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 1
31974: PUSH
31975: LD_INT 3
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: LD_INT 0
31984: PUSH
31985: LD_INT 3
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 1
31994: NEG
31995: PUSH
31996: LD_INT 2
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 2
32005: NEG
32006: PUSH
32007: LD_INT 1
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: PUSH
32014: LD_INT 3
32016: NEG
32017: PUSH
32018: LD_INT 0
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 3
32027: NEG
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32068: LD_ADDR_VAR 0 44
32072: PUSH
32073: LD_INT 0
32075: PUSH
32076: LD_INT 0
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 0
32085: PUSH
32086: LD_INT 1
32088: NEG
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 1
32096: PUSH
32097: LD_INT 0
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 1
32106: PUSH
32107: LD_INT 1
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 0
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 1
32126: NEG
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: NEG
32138: PUSH
32139: LD_INT 1
32141: NEG
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 1
32149: NEG
32150: PUSH
32151: LD_INT 2
32153: NEG
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 1
32161: PUSH
32162: LD_INT 1
32164: NEG
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 2
32172: PUSH
32173: LD_INT 0
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 2
32182: PUSH
32183: LD_INT 1
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 2
32192: PUSH
32193: LD_INT 2
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 1
32202: PUSH
32203: LD_INT 2
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 1
32212: NEG
32213: PUSH
32214: LD_INT 1
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 2
32223: NEG
32224: PUSH
32225: LD_INT 0
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 2
32234: NEG
32235: PUSH
32236: LD_INT 1
32238: NEG
32239: PUSH
32240: EMPTY
32241: LIST
32242: LIST
32243: PUSH
32244: LD_INT 2
32246: NEG
32247: PUSH
32248: LD_INT 2
32250: NEG
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 2
32258: NEG
32259: PUSH
32260: LD_INT 3
32262: NEG
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 2
32270: PUSH
32271: LD_INT 1
32273: NEG
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 3
32281: PUSH
32282: LD_INT 0
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 3
32291: PUSH
32292: LD_INT 1
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 3
32301: PUSH
32302: LD_INT 2
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 3
32311: PUSH
32312: LD_INT 3
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 2
32321: PUSH
32322: LD_INT 3
32324: PUSH
32325: EMPTY
32326: LIST
32327: LIST
32328: PUSH
32329: LD_INT 2
32331: NEG
32332: PUSH
32333: LD_INT 1
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 3
32342: NEG
32343: PUSH
32344: LD_INT 0
32346: PUSH
32347: EMPTY
32348: LIST
32349: LIST
32350: PUSH
32351: LD_INT 3
32353: NEG
32354: PUSH
32355: LD_INT 1
32357: NEG
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 3
32365: NEG
32366: PUSH
32367: LD_INT 2
32369: NEG
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: LD_INT 3
32377: NEG
32378: PUSH
32379: LD_INT 3
32381: NEG
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: LIST
32403: LIST
32404: LIST
32405: LIST
32406: LIST
32407: LIST
32408: LIST
32409: LIST
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32418: LD_ADDR_VAR 0 45
32422: PUSH
32423: LD_INT 0
32425: PUSH
32426: LD_INT 0
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 0
32435: PUSH
32436: LD_INT 1
32438: NEG
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: LD_INT 1
32446: PUSH
32447: LD_INT 0
32449: PUSH
32450: EMPTY
32451: LIST
32452: LIST
32453: PUSH
32454: LD_INT 1
32456: PUSH
32457: LD_INT 1
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 0
32466: PUSH
32467: LD_INT 1
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: PUSH
32474: LD_INT 1
32476: NEG
32477: PUSH
32478: LD_INT 0
32480: PUSH
32481: EMPTY
32482: LIST
32483: LIST
32484: PUSH
32485: LD_INT 1
32487: NEG
32488: PUSH
32489: LD_INT 1
32491: NEG
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: LD_INT 1
32499: NEG
32500: PUSH
32501: LD_INT 2
32503: NEG
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: LD_INT 2
32514: NEG
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 1
32522: PUSH
32523: LD_INT 1
32525: NEG
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 2
32533: PUSH
32534: LD_INT 1
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: LD_INT 2
32543: PUSH
32544: LD_INT 2
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PUSH
32551: LD_INT 1
32553: PUSH
32554: LD_INT 2
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 0
32563: PUSH
32564: LD_INT 2
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 1
32573: NEG
32574: PUSH
32575: LD_INT 1
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: LD_INT 2
32584: NEG
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 2
32596: NEG
32597: PUSH
32598: LD_INT 2
32600: NEG
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 2
32608: NEG
32609: PUSH
32610: LD_INT 3
32612: NEG
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: PUSH
32618: LD_INT 1
32620: NEG
32621: PUSH
32622: LD_INT 3
32624: NEG
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: LD_INT 0
32632: PUSH
32633: LD_INT 3
32635: NEG
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 1
32643: PUSH
32644: LD_INT 2
32646: NEG
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 3
32654: PUSH
32655: LD_INT 2
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 3
32664: PUSH
32665: LD_INT 3
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 2
32674: PUSH
32675: LD_INT 3
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: LD_INT 3
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 0
32694: PUSH
32695: LD_INT 3
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: NEG
32705: PUSH
32706: LD_INT 2
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 3
32715: NEG
32716: PUSH
32717: LD_INT 2
32719: NEG
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 3
32727: NEG
32728: PUSH
32729: LD_INT 3
32731: NEG
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: EMPTY
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: LIST
32745: LIST
32746: LIST
32747: LIST
32748: LIST
32749: LIST
32750: LIST
32751: LIST
32752: LIST
32753: LIST
32754: LIST
32755: LIST
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32768: LD_ADDR_VAR 0 46
32772: PUSH
32773: LD_INT 0
32775: PUSH
32776: LD_INT 0
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 0
32785: PUSH
32786: LD_INT 1
32788: NEG
32789: PUSH
32790: EMPTY
32791: LIST
32792: LIST
32793: PUSH
32794: LD_INT 1
32796: PUSH
32797: LD_INT 0
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PUSH
32804: LD_INT 1
32806: PUSH
32807: LD_INT 1
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PUSH
32814: LD_INT 0
32816: PUSH
32817: LD_INT 1
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 1
32826: NEG
32827: PUSH
32828: LD_INT 0
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: PUSH
32835: LD_INT 1
32837: NEG
32838: PUSH
32839: LD_INT 1
32841: NEG
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 1
32849: NEG
32850: PUSH
32851: LD_INT 2
32853: NEG
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 0
32861: PUSH
32862: LD_INT 2
32864: NEG
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 1
32872: PUSH
32873: LD_INT 1
32875: NEG
32876: PUSH
32877: EMPTY
32878: LIST
32879: LIST
32880: PUSH
32881: LD_INT 2
32883: PUSH
32884: LD_INT 0
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 2
32893: PUSH
32894: LD_INT 1
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 1
32903: PUSH
32904: LD_INT 2
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 0
32913: PUSH
32914: LD_INT 2
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 1
32923: NEG
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 2
32934: NEG
32935: PUSH
32936: LD_INT 0
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 2
32945: NEG
32946: PUSH
32947: LD_INT 1
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 3
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: LD_INT 3
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: LD_INT 2
32983: NEG
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 2
32991: PUSH
32992: LD_INT 1
32994: NEG
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 3
33002: PUSH
33003: LD_INT 0
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 3
33012: PUSH
33013: LD_INT 1
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 1
33022: PUSH
33023: LD_INT 3
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 0
33032: PUSH
33033: LD_INT 3
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 1
33042: NEG
33043: PUSH
33044: LD_INT 2
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 2
33053: NEG
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 3
33064: NEG
33065: PUSH
33066: LD_INT 0
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 3
33075: NEG
33076: PUSH
33077: LD_INT 1
33079: NEG
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: LIST
33089: LIST
33090: LIST
33091: LIST
33092: LIST
33093: LIST
33094: LIST
33095: LIST
33096: LIST
33097: LIST
33098: LIST
33099: LIST
33100: LIST
33101: LIST
33102: LIST
33103: LIST
33104: LIST
33105: LIST
33106: LIST
33107: LIST
33108: LIST
33109: LIST
33110: LIST
33111: LIST
33112: LIST
33113: LIST
33114: LIST
33115: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33116: LD_ADDR_VAR 0 47
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: LD_INT 0
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 0
33133: PUSH
33134: LD_INT 1
33136: NEG
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: PUSH
33145: LD_INT 0
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 1
33154: PUSH
33155: LD_INT 1
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 0
33164: PUSH
33165: LD_INT 1
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 1
33174: NEG
33175: PUSH
33176: LD_INT 0
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 1
33185: NEG
33186: PUSH
33187: LD_INT 1
33189: NEG
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 1
33197: NEG
33198: PUSH
33199: LD_INT 2
33201: NEG
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 0
33209: PUSH
33210: LD_INT 2
33212: NEG
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 1
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: EMPTY
33226: LIST
33227: LIST
33228: PUSH
33229: LD_INT 2
33231: NEG
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 2
33243: NEG
33244: PUSH
33245: LD_INT 2
33247: NEG
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: LIST
33257: LIST
33258: LIST
33259: LIST
33260: LIST
33261: LIST
33262: LIST
33263: LIST
33264: LIST
33265: LIST
33266: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33267: LD_ADDR_VAR 0 48
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: LD_INT 0
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 0
33284: PUSH
33285: LD_INT 1
33287: NEG
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: LD_INT 0
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 1
33305: PUSH
33306: LD_INT 1
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PUSH
33313: LD_INT 0
33315: PUSH
33316: LD_INT 1
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PUSH
33323: LD_INT 1
33325: NEG
33326: PUSH
33327: LD_INT 0
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: NEG
33337: PUSH
33338: LD_INT 1
33340: NEG
33341: PUSH
33342: EMPTY
33343: LIST
33344: LIST
33345: PUSH
33346: LD_INT 1
33348: NEG
33349: PUSH
33350: LD_INT 2
33352: NEG
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 0
33360: PUSH
33361: LD_INT 2
33363: NEG
33364: PUSH
33365: EMPTY
33366: LIST
33367: LIST
33368: PUSH
33369: LD_INT 1
33371: PUSH
33372: LD_INT 1
33374: NEG
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 2
33382: PUSH
33383: LD_INT 0
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 2
33392: PUSH
33393: LD_INT 1
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: EMPTY
33401: LIST
33402: LIST
33403: LIST
33404: LIST
33405: LIST
33406: LIST
33407: LIST
33408: LIST
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33414: LD_ADDR_VAR 0 49
33418: PUSH
33419: LD_INT 0
33421: PUSH
33422: LD_INT 0
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 0
33431: PUSH
33432: LD_INT 1
33434: NEG
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 1
33442: PUSH
33443: LD_INT 0
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: LD_INT 1
33452: PUSH
33453: LD_INT 1
33455: PUSH
33456: EMPTY
33457: LIST
33458: LIST
33459: PUSH
33460: LD_INT 0
33462: PUSH
33463: LD_INT 1
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 1
33472: NEG
33473: PUSH
33474: LD_INT 0
33476: PUSH
33477: EMPTY
33478: LIST
33479: LIST
33480: PUSH
33481: LD_INT 1
33483: NEG
33484: PUSH
33485: LD_INT 1
33487: NEG
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: LD_INT 1
33495: PUSH
33496: LD_INT 1
33498: NEG
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 2
33506: PUSH
33507: LD_INT 0
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 2
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: PUSH
33527: LD_INT 2
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 1
33536: PUSH
33537: LD_INT 2
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: LIST
33548: LIST
33549: LIST
33550: LIST
33551: LIST
33552: LIST
33553: LIST
33554: LIST
33555: LIST
33556: LIST
33557: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33558: LD_ADDR_VAR 0 50
33562: PUSH
33563: LD_INT 0
33565: PUSH
33566: LD_INT 0
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 0
33575: PUSH
33576: LD_INT 1
33578: NEG
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: LD_INT 1
33586: PUSH
33587: LD_INT 0
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 1
33596: PUSH
33597: LD_INT 1
33599: PUSH
33600: EMPTY
33601: LIST
33602: LIST
33603: PUSH
33604: LD_INT 0
33606: PUSH
33607: LD_INT 1
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 1
33616: NEG
33617: PUSH
33618: LD_INT 0
33620: PUSH
33621: EMPTY
33622: LIST
33623: LIST
33624: PUSH
33625: LD_INT 1
33627: NEG
33628: PUSH
33629: LD_INT 1
33631: NEG
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 2
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 2
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 1
33659: PUSH
33660: LD_INT 2
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 0
33669: PUSH
33670: LD_INT 2
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 1
33679: NEG
33680: PUSH
33681: LD_INT 1
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33702: LD_ADDR_VAR 0 51
33706: PUSH
33707: LD_INT 0
33709: PUSH
33710: LD_INT 0
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: PUSH
33717: LD_INT 0
33719: PUSH
33720: LD_INT 1
33722: NEG
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: PUSH
33731: LD_INT 0
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 1
33740: PUSH
33741: LD_INT 1
33743: PUSH
33744: EMPTY
33745: LIST
33746: LIST
33747: PUSH
33748: LD_INT 0
33750: PUSH
33751: LD_INT 1
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 1
33760: NEG
33761: PUSH
33762: LD_INT 0
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: NEG
33772: PUSH
33773: LD_INT 1
33775: NEG
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 1
33783: PUSH
33784: LD_INT 2
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 0
33793: PUSH
33794: LD_INT 2
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 1
33803: NEG
33804: PUSH
33805: LD_INT 1
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: LD_INT 2
33814: NEG
33815: PUSH
33816: LD_INT 0
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 2
33825: NEG
33826: PUSH
33827: LD_INT 1
33829: NEG
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33849: LD_ADDR_VAR 0 52
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: LD_INT 0
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: LD_INT 1
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: LD_INT 0
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: PUSH
33888: LD_INT 1
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: LD_INT 1
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: NEG
33908: PUSH
33909: LD_INT 0
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: NEG
33919: PUSH
33920: LD_INT 1
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: NEG
33931: PUSH
33932: LD_INT 2
33934: NEG
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 1
33942: NEG
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 2
33953: NEG
33954: PUSH
33955: LD_INT 0
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 2
33964: NEG
33965: PUSH
33966: LD_INT 1
33968: NEG
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 2
33976: NEG
33977: PUSH
33978: LD_INT 2
33980: NEG
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34000: LD_ADDR_VAR 0 53
34004: PUSH
34005: LD_INT 0
34007: PUSH
34008: LD_INT 0
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 0
34017: PUSH
34018: LD_INT 1
34020: NEG
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: LD_INT 1
34028: PUSH
34029: LD_INT 0
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 1
34038: PUSH
34039: LD_INT 1
34041: PUSH
34042: EMPTY
34043: LIST
34044: LIST
34045: PUSH
34046: LD_INT 0
34048: PUSH
34049: LD_INT 1
34051: PUSH
34052: EMPTY
34053: LIST
34054: LIST
34055: PUSH
34056: LD_INT 1
34058: NEG
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 1
34069: NEG
34070: PUSH
34071: LD_INT 1
34073: NEG
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 1
34081: NEG
34082: PUSH
34083: LD_INT 2
34085: NEG
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 0
34093: PUSH
34094: LD_INT 2
34096: NEG
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 1
34104: PUSH
34105: LD_INT 1
34107: NEG
34108: PUSH
34109: EMPTY
34110: LIST
34111: LIST
34112: PUSH
34113: LD_INT 2
34115: PUSH
34116: LD_INT 0
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 2
34125: PUSH
34126: LD_INT 1
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 2
34135: PUSH
34136: LD_INT 2
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: LD_INT 2
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 0
34155: PUSH
34156: LD_INT 2
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: LD_INT 1
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 2
34176: NEG
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 2
34187: NEG
34188: PUSH
34189: LD_INT 1
34191: NEG
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 2
34199: NEG
34200: PUSH
34201: LD_INT 2
34203: NEG
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: LIST
34217: LIST
34218: LIST
34219: LIST
34220: LIST
34221: LIST
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: LIST
34227: LIST
34228: LIST
34229: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34230: LD_ADDR_VAR 0 54
34234: PUSH
34235: LD_INT 0
34237: PUSH
34238: LD_INT 0
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 0
34247: PUSH
34248: LD_INT 1
34250: NEG
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 1
34258: PUSH
34259: LD_INT 0
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 1
34268: PUSH
34269: LD_INT 1
34271: PUSH
34272: EMPTY
34273: LIST
34274: LIST
34275: PUSH
34276: LD_INT 0
34278: PUSH
34279: LD_INT 1
34281: PUSH
34282: EMPTY
34283: LIST
34284: LIST
34285: PUSH
34286: LD_INT 1
34288: NEG
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 1
34299: NEG
34300: PUSH
34301: LD_INT 1
34303: NEG
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: NEG
34312: PUSH
34313: LD_INT 2
34315: NEG
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 0
34323: PUSH
34324: LD_INT 2
34326: NEG
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PUSH
34332: LD_INT 1
34334: PUSH
34335: LD_INT 1
34337: NEG
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 2
34345: PUSH
34346: LD_INT 0
34348: PUSH
34349: EMPTY
34350: LIST
34351: LIST
34352: PUSH
34353: LD_INT 2
34355: PUSH
34356: LD_INT 1
34358: PUSH
34359: EMPTY
34360: LIST
34361: LIST
34362: PUSH
34363: LD_INT 2
34365: PUSH
34366: LD_INT 2
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: PUSH
34373: LD_INT 1
34375: PUSH
34376: LD_INT 2
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: PUSH
34383: LD_INT 0
34385: PUSH
34386: LD_INT 2
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 1
34395: NEG
34396: PUSH
34397: LD_INT 1
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: PUSH
34404: LD_INT 2
34406: NEG
34407: PUSH
34408: LD_INT 0
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 2
34417: NEG
34418: PUSH
34419: LD_INT 1
34421: NEG
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 2
34429: NEG
34430: PUSH
34431: LD_INT 2
34433: NEG
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: LIST
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34460: LD_ADDR_VAR 0 55
34464: PUSH
34465: LD_INT 0
34467: PUSH
34468: LD_INT 0
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 0
34477: PUSH
34478: LD_INT 1
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 1
34488: PUSH
34489: LD_INT 0
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 1
34498: PUSH
34499: LD_INT 1
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 0
34508: PUSH
34509: LD_INT 1
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 1
34518: NEG
34519: PUSH
34520: LD_INT 0
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: LD_INT 1
34533: NEG
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 1
34541: NEG
34542: PUSH
34543: LD_INT 2
34545: NEG
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: PUSH
34551: LD_INT 0
34553: PUSH
34554: LD_INT 2
34556: NEG
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 1
34564: PUSH
34565: LD_INT 1
34567: NEG
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 2
34575: PUSH
34576: LD_INT 0
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 2
34585: PUSH
34586: LD_INT 1
34588: PUSH
34589: EMPTY
34590: LIST
34591: LIST
34592: PUSH
34593: LD_INT 2
34595: PUSH
34596: LD_INT 2
34598: PUSH
34599: EMPTY
34600: LIST
34601: LIST
34602: PUSH
34603: LD_INT 1
34605: PUSH
34606: LD_INT 2
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 0
34615: PUSH
34616: LD_INT 2
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 1
34625: NEG
34626: PUSH
34627: LD_INT 1
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 2
34636: NEG
34637: PUSH
34638: LD_INT 0
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 2
34647: NEG
34648: PUSH
34649: LD_INT 1
34651: NEG
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 2
34659: NEG
34660: PUSH
34661: LD_INT 2
34663: NEG
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34690: LD_ADDR_VAR 0 56
34694: PUSH
34695: LD_INT 0
34697: PUSH
34698: LD_INT 0
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 0
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 1
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 1
34728: PUSH
34729: LD_INT 1
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 0
34738: PUSH
34739: LD_INT 1
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 1
34748: NEG
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: EMPTY
34754: LIST
34755: LIST
34756: PUSH
34757: LD_INT 1
34759: NEG
34760: PUSH
34761: LD_INT 1
34763: NEG
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 1
34771: NEG
34772: PUSH
34773: LD_INT 2
34775: NEG
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 0
34783: PUSH
34784: LD_INT 2
34786: NEG
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: PUSH
34792: LD_INT 1
34794: PUSH
34795: LD_INT 1
34797: NEG
34798: PUSH
34799: EMPTY
34800: LIST
34801: LIST
34802: PUSH
34803: LD_INT 2
34805: PUSH
34806: LD_INT 0
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: LD_INT 2
34815: PUSH
34816: LD_INT 1
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 2
34825: PUSH
34826: LD_INT 2
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 1
34835: PUSH
34836: LD_INT 2
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: LD_INT 0
34845: PUSH
34846: LD_INT 2
34848: PUSH
34849: EMPTY
34850: LIST
34851: LIST
34852: PUSH
34853: LD_INT 1
34855: NEG
34856: PUSH
34857: LD_INT 1
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 2
34866: NEG
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 2
34877: NEG
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: EMPTY
34884: LIST
34885: LIST
34886: PUSH
34887: LD_INT 2
34889: NEG
34890: PUSH
34891: LD_INT 2
34893: NEG
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: LIST
34912: LIST
34913: LIST
34914: LIST
34915: LIST
34916: LIST
34917: LIST
34918: LIST
34919: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34920: LD_ADDR_VAR 0 57
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: LD_INT 0
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 0
34937: PUSH
34938: LD_INT 1
34940: NEG
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: PUSH
34949: LD_INT 0
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 1
34958: PUSH
34959: LD_INT 1
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 0
34968: PUSH
34969: LD_INT 1
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 1
34978: NEG
34979: PUSH
34980: LD_INT 0
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 1
34989: NEG
34990: PUSH
34991: LD_INT 1
34993: NEG
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 1
35001: NEG
35002: PUSH
35003: LD_INT 2
35005: NEG
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 0
35013: PUSH
35014: LD_INT 2
35016: NEG
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 1
35024: PUSH
35025: LD_INT 1
35027: NEG
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 2
35035: PUSH
35036: LD_INT 0
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 2
35045: PUSH
35046: LD_INT 1
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 2
35055: PUSH
35056: LD_INT 2
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 1
35065: PUSH
35066: LD_INT 2
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 0
35075: PUSH
35076: LD_INT 2
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: LD_INT 1
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 2
35096: NEG
35097: PUSH
35098: LD_INT 0
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 2
35107: NEG
35108: PUSH
35109: LD_INT 1
35111: NEG
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 2
35119: NEG
35120: PUSH
35121: LD_INT 2
35123: NEG
35124: PUSH
35125: EMPTY
35126: LIST
35127: LIST
35128: PUSH
35129: EMPTY
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35150: LD_ADDR_VAR 0 58
35154: PUSH
35155: LD_INT 0
35157: PUSH
35158: LD_INT 0
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PUSH
35165: LD_INT 0
35167: PUSH
35168: LD_INT 1
35170: NEG
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 1
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 1
35188: PUSH
35189: LD_INT 1
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 0
35198: PUSH
35199: LD_INT 1
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 1
35208: NEG
35209: PUSH
35210: LD_INT 0
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 1
35219: NEG
35220: PUSH
35221: LD_INT 1
35223: NEG
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 1
35231: NEG
35232: PUSH
35233: LD_INT 2
35235: NEG
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 0
35243: PUSH
35244: LD_INT 2
35246: NEG
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 1
35254: PUSH
35255: LD_INT 1
35257: NEG
35258: PUSH
35259: EMPTY
35260: LIST
35261: LIST
35262: PUSH
35263: LD_INT 2
35265: PUSH
35266: LD_INT 0
35268: PUSH
35269: EMPTY
35270: LIST
35271: LIST
35272: PUSH
35273: LD_INT 2
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: LD_INT 2
35285: PUSH
35286: LD_INT 2
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 1
35295: PUSH
35296: LD_INT 2
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: LD_INT 0
35305: PUSH
35306: LD_INT 2
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: LD_INT 1
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 2
35326: NEG
35327: PUSH
35328: LD_INT 0
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 2
35337: NEG
35338: PUSH
35339: LD_INT 1
35341: NEG
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 2
35349: NEG
35350: PUSH
35351: LD_INT 2
35353: NEG
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: EMPTY
35360: LIST
35361: LIST
35362: LIST
35363: LIST
35364: LIST
35365: LIST
35366: LIST
35367: LIST
35368: LIST
35369: LIST
35370: LIST
35371: LIST
35372: LIST
35373: LIST
35374: LIST
35375: LIST
35376: LIST
35377: LIST
35378: LIST
35379: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35380: LD_ADDR_VAR 0 59
35384: PUSH
35385: LD_INT 0
35387: PUSH
35388: LD_INT 0
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 0
35397: PUSH
35398: LD_INT 1
35400: NEG
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: PUSH
35406: LD_INT 1
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 1
35418: PUSH
35419: LD_INT 1
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 0
35428: PUSH
35429: LD_INT 1
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: NEG
35439: PUSH
35440: LD_INT 0
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 1
35449: NEG
35450: PUSH
35451: LD_INT 1
35453: NEG
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: EMPTY
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35468: LD_ADDR_VAR 0 60
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: LD_INT 0
35478: PUSH
35479: EMPTY
35480: LIST
35481: LIST
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: LD_INT 1
35488: NEG
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: LD_INT 0
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 0
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: NEG
35527: PUSH
35528: LD_INT 0
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 1
35537: NEG
35538: PUSH
35539: LD_INT 1
35541: NEG
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: LIST
35551: LIST
35552: LIST
35553: LIST
35554: LIST
35555: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35556: LD_ADDR_VAR 0 61
35560: PUSH
35561: LD_INT 0
35563: PUSH
35564: LD_INT 0
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 0
35573: PUSH
35574: LD_INT 1
35576: NEG
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: LD_INT 0
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 1
35594: PUSH
35595: LD_INT 1
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 0
35604: PUSH
35605: LD_INT 1
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 1
35614: NEG
35615: PUSH
35616: LD_INT 0
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: NEG
35626: PUSH
35627: LD_INT 1
35629: NEG
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35644: LD_ADDR_VAR 0 62
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: LD_INT 0
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 0
35661: PUSH
35662: LD_INT 1
35664: NEG
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 1
35672: PUSH
35673: LD_INT 0
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: LD_INT 1
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 0
35692: PUSH
35693: LD_INT 1
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 1
35702: NEG
35703: PUSH
35704: LD_INT 0
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 1
35713: NEG
35714: PUSH
35715: LD_INT 1
35717: NEG
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35732: LD_ADDR_VAR 0 63
35736: PUSH
35737: LD_INT 0
35739: PUSH
35740: LD_INT 0
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 0
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 1
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 1
35770: PUSH
35771: LD_INT 1
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: LD_INT 1
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 1
35790: NEG
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 1
35801: NEG
35802: PUSH
35803: LD_INT 1
35805: NEG
35806: PUSH
35807: EMPTY
35808: LIST
35809: LIST
35810: PUSH
35811: EMPTY
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35820: LD_ADDR_VAR 0 64
35824: PUSH
35825: LD_INT 0
35827: PUSH
35828: LD_INT 0
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: PUSH
35835: LD_INT 0
35837: PUSH
35838: LD_INT 1
35840: NEG
35841: PUSH
35842: EMPTY
35843: LIST
35844: LIST
35845: PUSH
35846: LD_INT 1
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 1
35858: PUSH
35859: LD_INT 1
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: PUSH
35866: LD_INT 0
35868: PUSH
35869: LD_INT 1
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 1
35878: NEG
35879: PUSH
35880: LD_INT 0
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 1
35889: NEG
35890: PUSH
35891: LD_INT 1
35893: NEG
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: LIST
35903: LIST
35904: LIST
35905: LIST
35906: LIST
35907: ST_TO_ADDR
// end ; 1 :
35908: GO 41805
35910: LD_INT 1
35912: DOUBLE
35913: EQUAL
35914: IFTRUE 35918
35916: GO 38541
35918: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35919: LD_ADDR_VAR 0 11
35923: PUSH
35924: LD_INT 1
35926: NEG
35927: PUSH
35928: LD_INT 3
35930: NEG
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 0
35938: PUSH
35939: LD_INT 3
35941: NEG
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: LD_INT 2
35952: NEG
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: EMPTY
35959: LIST
35960: LIST
35961: LIST
35962: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35963: LD_ADDR_VAR 0 12
35967: PUSH
35968: LD_INT 2
35970: PUSH
35971: LD_INT 1
35973: NEG
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: LD_INT 3
35981: PUSH
35982: LD_INT 0
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 3
35991: PUSH
35992: LD_INT 1
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: LIST
36003: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36004: LD_ADDR_VAR 0 13
36008: PUSH
36009: LD_INT 3
36011: PUSH
36012: LD_INT 2
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 3
36021: PUSH
36022: LD_INT 3
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 2
36031: PUSH
36032: LD_INT 3
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: LIST
36043: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36044: LD_ADDR_VAR 0 14
36048: PUSH
36049: LD_INT 1
36051: PUSH
36052: LD_INT 3
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 0
36061: PUSH
36062: LD_INT 3
36064: PUSH
36065: EMPTY
36066: LIST
36067: LIST
36068: PUSH
36069: LD_INT 1
36071: NEG
36072: PUSH
36073: LD_INT 2
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: LIST
36084: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36085: LD_ADDR_VAR 0 15
36089: PUSH
36090: LD_INT 2
36092: NEG
36093: PUSH
36094: LD_INT 1
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 3
36103: NEG
36104: PUSH
36105: LD_INT 0
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 3
36114: NEG
36115: PUSH
36116: LD_INT 1
36118: NEG
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: LIST
36128: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36129: LD_ADDR_VAR 0 16
36133: PUSH
36134: LD_INT 2
36136: NEG
36137: PUSH
36138: LD_INT 3
36140: NEG
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 3
36148: NEG
36149: PUSH
36150: LD_INT 2
36152: NEG
36153: PUSH
36154: EMPTY
36155: LIST
36156: LIST
36157: PUSH
36158: LD_INT 3
36160: NEG
36161: PUSH
36162: LD_INT 3
36164: NEG
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: LIST
36174: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36175: LD_ADDR_VAR 0 17
36179: PUSH
36180: LD_INT 1
36182: NEG
36183: PUSH
36184: LD_INT 3
36186: NEG
36187: PUSH
36188: EMPTY
36189: LIST
36190: LIST
36191: PUSH
36192: LD_INT 0
36194: PUSH
36195: LD_INT 3
36197: NEG
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: PUSH
36206: LD_INT 2
36208: NEG
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: LIST
36218: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36219: LD_ADDR_VAR 0 18
36223: PUSH
36224: LD_INT 2
36226: PUSH
36227: LD_INT 1
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 3
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: LD_INT 3
36247: PUSH
36248: LD_INT 1
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: LIST
36259: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36260: LD_ADDR_VAR 0 19
36264: PUSH
36265: LD_INT 3
36267: PUSH
36268: LD_INT 2
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 3
36277: PUSH
36278: LD_INT 3
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: LD_INT 2
36287: PUSH
36288: LD_INT 3
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: LIST
36299: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36300: LD_ADDR_VAR 0 20
36304: PUSH
36305: LD_INT 1
36307: PUSH
36308: LD_INT 3
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 0
36317: PUSH
36318: LD_INT 3
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 1
36327: NEG
36328: PUSH
36329: LD_INT 2
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: LIST
36340: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36341: LD_ADDR_VAR 0 21
36345: PUSH
36346: LD_INT 2
36348: NEG
36349: PUSH
36350: LD_INT 1
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 3
36359: NEG
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 3
36370: NEG
36371: PUSH
36372: LD_INT 1
36374: NEG
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: LIST
36384: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36385: LD_ADDR_VAR 0 22
36389: PUSH
36390: LD_INT 2
36392: NEG
36393: PUSH
36394: LD_INT 3
36396: NEG
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 3
36404: NEG
36405: PUSH
36406: LD_INT 2
36408: NEG
36409: PUSH
36410: EMPTY
36411: LIST
36412: LIST
36413: PUSH
36414: LD_INT 3
36416: NEG
36417: PUSH
36418: LD_INT 3
36420: NEG
36421: PUSH
36422: EMPTY
36423: LIST
36424: LIST
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: LIST
36430: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36431: LD_ADDR_VAR 0 23
36435: PUSH
36436: LD_INT 0
36438: PUSH
36439: LD_INT 3
36441: NEG
36442: PUSH
36443: EMPTY
36444: LIST
36445: LIST
36446: PUSH
36447: LD_INT 1
36449: NEG
36450: PUSH
36451: LD_INT 4
36453: NEG
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 1
36461: PUSH
36462: LD_INT 3
36464: NEG
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: LIST
36474: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36475: LD_ADDR_VAR 0 24
36479: PUSH
36480: LD_INT 3
36482: PUSH
36483: LD_INT 0
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 3
36492: PUSH
36493: LD_INT 1
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 4
36503: PUSH
36504: LD_INT 1
36506: PUSH
36507: EMPTY
36508: LIST
36509: LIST
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: LIST
36515: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36516: LD_ADDR_VAR 0 25
36520: PUSH
36521: LD_INT 3
36523: PUSH
36524: LD_INT 3
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 4
36533: PUSH
36534: LD_INT 3
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 3
36543: PUSH
36544: LD_INT 4
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: LIST
36555: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36556: LD_ADDR_VAR 0 26
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: LD_INT 3
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: LD_INT 1
36573: PUSH
36574: LD_INT 4
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 1
36583: NEG
36584: PUSH
36585: LD_INT 3
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: LIST
36596: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36597: LD_ADDR_VAR 0 27
36601: PUSH
36602: LD_INT 3
36604: NEG
36605: PUSH
36606: LD_INT 0
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 3
36615: NEG
36616: PUSH
36617: LD_INT 1
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 4
36626: NEG
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: LIST
36640: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36641: LD_ADDR_VAR 0 28
36645: PUSH
36646: LD_INT 3
36648: NEG
36649: PUSH
36650: LD_INT 3
36652: NEG
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 3
36660: NEG
36661: PUSH
36662: LD_INT 4
36664: NEG
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: LD_INT 4
36672: NEG
36673: PUSH
36674: LD_INT 3
36676: NEG
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: LIST
36686: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36687: LD_ADDR_VAR 0 29
36691: PUSH
36692: LD_INT 1
36694: NEG
36695: PUSH
36696: LD_INT 3
36698: NEG
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 0
36706: PUSH
36707: LD_INT 3
36709: NEG
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: PUSH
36715: LD_INT 1
36717: PUSH
36718: LD_INT 2
36720: NEG
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 1
36728: NEG
36729: PUSH
36730: LD_INT 4
36732: NEG
36733: PUSH
36734: EMPTY
36735: LIST
36736: LIST
36737: PUSH
36738: LD_INT 0
36740: PUSH
36741: LD_INT 4
36743: NEG
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 1
36751: PUSH
36752: LD_INT 3
36754: NEG
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: LD_INT 1
36762: NEG
36763: PUSH
36764: LD_INT 5
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 0
36774: PUSH
36775: LD_INT 5
36777: NEG
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 1
36785: PUSH
36786: LD_INT 4
36788: NEG
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 1
36796: NEG
36797: PUSH
36798: LD_INT 6
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: LD_INT 6
36811: NEG
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 1
36819: PUSH
36820: LD_INT 5
36822: NEG
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36842: LD_ADDR_VAR 0 30
36846: PUSH
36847: LD_INT 2
36849: PUSH
36850: LD_INT 1
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 3
36860: PUSH
36861: LD_INT 0
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 3
36870: PUSH
36871: LD_INT 1
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 3
36880: PUSH
36881: LD_INT 1
36883: NEG
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 4
36891: PUSH
36892: LD_INT 0
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 4
36901: PUSH
36902: LD_INT 1
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 4
36911: PUSH
36912: LD_INT 1
36914: NEG
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 5
36922: PUSH
36923: LD_INT 0
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 5
36932: PUSH
36933: LD_INT 1
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 5
36942: PUSH
36943: LD_INT 1
36945: NEG
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 6
36953: PUSH
36954: LD_INT 0
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 6
36963: PUSH
36964: LD_INT 1
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36985: LD_ADDR_VAR 0 31
36989: PUSH
36990: LD_INT 3
36992: PUSH
36993: LD_INT 2
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 3
37002: PUSH
37003: LD_INT 3
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 2
37012: PUSH
37013: LD_INT 3
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 4
37022: PUSH
37023: LD_INT 3
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 4
37032: PUSH
37033: LD_INT 4
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 3
37042: PUSH
37043: LD_INT 4
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 5
37052: PUSH
37053: LD_INT 4
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 5
37062: PUSH
37063: LD_INT 5
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 4
37072: PUSH
37073: LD_INT 5
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 6
37082: PUSH
37083: LD_INT 5
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 6
37092: PUSH
37093: LD_INT 6
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 5
37102: PUSH
37103: LD_INT 6
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: LIST
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
37124: LD_ADDR_VAR 0 32
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: LD_INT 3
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 0
37141: PUSH
37142: LD_INT 3
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 1
37151: NEG
37152: PUSH
37153: LD_INT 2
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 1
37162: PUSH
37163: LD_INT 4
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: PUSH
37170: LD_INT 0
37172: PUSH
37173: LD_INT 4
37175: PUSH
37176: EMPTY
37177: LIST
37178: LIST
37179: PUSH
37180: LD_INT 1
37182: NEG
37183: PUSH
37184: LD_INT 3
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: PUSH
37194: LD_INT 5
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: LD_INT 0
37203: PUSH
37204: LD_INT 5
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: PUSH
37211: LD_INT 1
37213: NEG
37214: PUSH
37215: LD_INT 4
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 1
37224: PUSH
37225: LD_INT 6
37227: PUSH
37228: EMPTY
37229: LIST
37230: LIST
37231: PUSH
37232: LD_INT 0
37234: PUSH
37235: LD_INT 6
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 1
37244: NEG
37245: PUSH
37246: LD_INT 5
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: LIST
37257: LIST
37258: LIST
37259: LIST
37260: LIST
37261: LIST
37262: LIST
37263: LIST
37264: LIST
37265: LIST
37266: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37267: LD_ADDR_VAR 0 33
37271: PUSH
37272: LD_INT 2
37274: NEG
37275: PUSH
37276: LD_INT 1
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 3
37285: NEG
37286: PUSH
37287: LD_INT 0
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 3
37296: NEG
37297: PUSH
37298: LD_INT 1
37300: NEG
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 3
37308: NEG
37309: PUSH
37310: LD_INT 1
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 4
37319: NEG
37320: PUSH
37321: LD_INT 0
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 4
37330: NEG
37331: PUSH
37332: LD_INT 1
37334: NEG
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 4
37342: NEG
37343: PUSH
37344: LD_INT 1
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 5
37353: NEG
37354: PUSH
37355: LD_INT 0
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: PUSH
37362: LD_INT 5
37364: NEG
37365: PUSH
37366: LD_INT 1
37368: NEG
37369: PUSH
37370: EMPTY
37371: LIST
37372: LIST
37373: PUSH
37374: LD_INT 5
37376: NEG
37377: PUSH
37378: LD_INT 1
37380: PUSH
37381: EMPTY
37382: LIST
37383: LIST
37384: PUSH
37385: LD_INT 6
37387: NEG
37388: PUSH
37389: LD_INT 0
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 6
37398: NEG
37399: PUSH
37400: LD_INT 1
37402: NEG
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37422: LD_ADDR_VAR 0 34
37426: PUSH
37427: LD_INT 2
37429: NEG
37430: PUSH
37431: LD_INT 3
37433: NEG
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 3
37441: NEG
37442: PUSH
37443: LD_INT 2
37445: NEG
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: LD_INT 3
37453: NEG
37454: PUSH
37455: LD_INT 3
37457: NEG
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 3
37465: NEG
37466: PUSH
37467: LD_INT 4
37469: NEG
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 4
37477: NEG
37478: PUSH
37479: LD_INT 3
37481: NEG
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 4
37489: NEG
37490: PUSH
37491: LD_INT 4
37493: NEG
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 4
37501: NEG
37502: PUSH
37503: LD_INT 5
37505: NEG
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 5
37513: NEG
37514: PUSH
37515: LD_INT 4
37517: NEG
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 5
37525: NEG
37526: PUSH
37527: LD_INT 5
37529: NEG
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 5
37537: NEG
37538: PUSH
37539: LD_INT 6
37541: NEG
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 6
37549: NEG
37550: PUSH
37551: LD_INT 5
37553: NEG
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 6
37561: NEG
37562: PUSH
37563: LD_INT 6
37565: NEG
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37585: LD_ADDR_VAR 0 41
37589: PUSH
37590: LD_INT 0
37592: PUSH
37593: LD_INT 2
37595: NEG
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 1
37603: NEG
37604: PUSH
37605: LD_INT 3
37607: NEG
37608: PUSH
37609: EMPTY
37610: LIST
37611: LIST
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: LD_INT 2
37618: NEG
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: LIST
37628: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37629: LD_ADDR_VAR 0 42
37633: PUSH
37634: LD_INT 2
37636: PUSH
37637: LD_INT 0
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: LD_INT 1
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 3
37657: PUSH
37658: LD_INT 1
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: LIST
37669: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37670: LD_ADDR_VAR 0 43
37674: PUSH
37675: LD_INT 2
37677: PUSH
37678: LD_INT 2
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 3
37687: PUSH
37688: LD_INT 2
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 2
37697: PUSH
37698: LD_INT 3
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: LIST
37709: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37710: LD_ADDR_VAR 0 44
37714: PUSH
37715: LD_INT 0
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 1
37727: PUSH
37728: LD_INT 3
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: LD_INT 1
37737: NEG
37738: PUSH
37739: LD_INT 2
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: LIST
37750: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37751: LD_ADDR_VAR 0 45
37755: PUSH
37756: LD_INT 2
37758: NEG
37759: PUSH
37760: LD_INT 0
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 2
37769: NEG
37770: PUSH
37771: LD_INT 1
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: LD_INT 3
37780: NEG
37781: PUSH
37782: LD_INT 1
37784: NEG
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: LIST
37794: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37795: LD_ADDR_VAR 0 46
37799: PUSH
37800: LD_INT 2
37802: NEG
37803: PUSH
37804: LD_INT 2
37806: NEG
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: PUSH
37812: LD_INT 2
37814: NEG
37815: PUSH
37816: LD_INT 3
37818: NEG
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PUSH
37824: LD_INT 3
37826: NEG
37827: PUSH
37828: LD_INT 2
37830: NEG
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: LIST
37840: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37841: LD_ADDR_VAR 0 47
37845: PUSH
37846: LD_INT 2
37848: NEG
37849: PUSH
37850: LD_INT 3
37852: NEG
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 1
37860: NEG
37861: PUSH
37862: LD_INT 3
37864: NEG
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37874: LD_ADDR_VAR 0 48
37878: PUSH
37879: LD_INT 1
37881: PUSH
37882: LD_INT 2
37884: NEG
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 2
37892: PUSH
37893: LD_INT 1
37895: NEG
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37905: LD_ADDR_VAR 0 49
37909: PUSH
37910: LD_INT 3
37912: PUSH
37913: LD_INT 1
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 3
37922: PUSH
37923: LD_INT 2
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37934: LD_ADDR_VAR 0 50
37938: PUSH
37939: LD_INT 2
37941: PUSH
37942: LD_INT 3
37944: PUSH
37945: EMPTY
37946: LIST
37947: LIST
37948: PUSH
37949: LD_INT 1
37951: PUSH
37952: LD_INT 3
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37963: LD_ADDR_VAR 0 51
37967: PUSH
37968: LD_INT 1
37970: NEG
37971: PUSH
37972: LD_INT 2
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 2
37981: NEG
37982: PUSH
37983: LD_INT 1
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37994: LD_ADDR_VAR 0 52
37998: PUSH
37999: LD_INT 3
38001: NEG
38002: PUSH
38003: LD_INT 1
38005: NEG
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 3
38013: NEG
38014: PUSH
38015: LD_INT 2
38017: NEG
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38027: LD_ADDR_VAR 0 53
38031: PUSH
38032: LD_INT 1
38034: NEG
38035: PUSH
38036: LD_INT 3
38038: NEG
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 0
38046: PUSH
38047: LD_INT 3
38049: NEG
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 1
38057: PUSH
38058: LD_INT 2
38060: NEG
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: LIST
38070: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38071: LD_ADDR_VAR 0 54
38075: PUSH
38076: LD_INT 2
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 3
38089: PUSH
38090: LD_INT 0
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 3
38099: PUSH
38100: LD_INT 1
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: LIST
38111: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38112: LD_ADDR_VAR 0 55
38116: PUSH
38117: LD_INT 3
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 3
38129: PUSH
38130: LD_INT 3
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 2
38139: PUSH
38140: LD_INT 3
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: LIST
38151: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38152: LD_ADDR_VAR 0 56
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: LD_INT 3
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PUSH
38167: LD_INT 0
38169: PUSH
38170: LD_INT 3
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: LD_INT 1
38179: NEG
38180: PUSH
38181: LD_INT 2
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: LIST
38192: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38193: LD_ADDR_VAR 0 57
38197: PUSH
38198: LD_INT 2
38200: NEG
38201: PUSH
38202: LD_INT 1
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 3
38211: NEG
38212: PUSH
38213: LD_INT 0
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 3
38222: NEG
38223: PUSH
38224: LD_INT 1
38226: NEG
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: EMPTY
38233: LIST
38234: LIST
38235: LIST
38236: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38237: LD_ADDR_VAR 0 58
38241: PUSH
38242: LD_INT 2
38244: NEG
38245: PUSH
38246: LD_INT 3
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 3
38256: NEG
38257: PUSH
38258: LD_INT 2
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 3
38268: NEG
38269: PUSH
38270: LD_INT 3
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: LIST
38282: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38283: LD_ADDR_VAR 0 59
38287: PUSH
38288: LD_INT 1
38290: NEG
38291: PUSH
38292: LD_INT 2
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 0
38302: PUSH
38303: LD_INT 2
38305: NEG
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: LD_INT 1
38316: NEG
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: LIST
38326: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38327: LD_ADDR_VAR 0 60
38331: PUSH
38332: LD_INT 1
38334: PUSH
38335: LD_INT 1
38337: NEG
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 2
38345: PUSH
38346: LD_INT 0
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 2
38355: PUSH
38356: LD_INT 1
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: EMPTY
38364: LIST
38365: LIST
38366: LIST
38367: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38368: LD_ADDR_VAR 0 61
38372: PUSH
38373: LD_INT 2
38375: PUSH
38376: LD_INT 1
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 2
38385: PUSH
38386: LD_INT 2
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 1
38395: PUSH
38396: LD_INT 2
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: LIST
38407: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38408: LD_ADDR_VAR 0 62
38412: PUSH
38413: LD_INT 1
38415: PUSH
38416: LD_INT 2
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 0
38425: PUSH
38426: LD_INT 2
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 1
38435: NEG
38436: PUSH
38437: LD_INT 1
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: LIST
38448: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38449: LD_ADDR_VAR 0 63
38453: PUSH
38454: LD_INT 1
38456: NEG
38457: PUSH
38458: LD_INT 1
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 2
38467: NEG
38468: PUSH
38469: LD_INT 0
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 2
38478: NEG
38479: PUSH
38480: LD_INT 1
38482: NEG
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: LIST
38492: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38493: LD_ADDR_VAR 0 64
38497: PUSH
38498: LD_INT 1
38500: NEG
38501: PUSH
38502: LD_INT 2
38504: NEG
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 2
38512: NEG
38513: PUSH
38514: LD_INT 1
38516: NEG
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 2
38524: NEG
38525: PUSH
38526: LD_INT 2
38528: NEG
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: LIST
38538: ST_TO_ADDR
// end ; 2 :
38539: GO 41805
38541: LD_INT 2
38543: DOUBLE
38544: EQUAL
38545: IFTRUE 38549
38547: GO 41804
38549: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38550: LD_ADDR_VAR 0 29
38554: PUSH
38555: LD_INT 4
38557: PUSH
38558: LD_INT 0
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 4
38567: PUSH
38568: LD_INT 1
38570: NEG
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 5
38578: PUSH
38579: LD_INT 0
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 5
38588: PUSH
38589: LD_INT 1
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 4
38598: PUSH
38599: LD_INT 1
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 3
38608: PUSH
38609: LD_INT 0
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 3
38618: PUSH
38619: LD_INT 1
38621: NEG
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 3
38629: PUSH
38630: LD_INT 2
38632: NEG
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 5
38640: PUSH
38641: LD_INT 2
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 3
38650: PUSH
38651: LD_INT 3
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 3
38660: PUSH
38661: LD_INT 2
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 4
38670: PUSH
38671: LD_INT 3
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 4
38680: PUSH
38681: LD_INT 4
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 3
38690: PUSH
38691: LD_INT 4
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 2
38700: PUSH
38701: LD_INT 3
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 2
38710: PUSH
38711: LD_INT 2
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: LD_INT 4
38720: PUSH
38721: LD_INT 2
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 2
38730: PUSH
38731: LD_INT 4
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 0
38740: PUSH
38741: LD_INT 4
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 0
38750: PUSH
38751: LD_INT 3
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 1
38760: PUSH
38761: LD_INT 4
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 1
38770: PUSH
38771: LD_INT 5
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 0
38780: PUSH
38781: LD_INT 5
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PUSH
38788: LD_INT 1
38790: NEG
38791: PUSH
38792: LD_INT 4
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: LD_INT 1
38801: NEG
38802: PUSH
38803: LD_INT 3
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 2
38812: PUSH
38813: LD_INT 5
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 2
38822: NEG
38823: PUSH
38824: LD_INT 3
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 3
38833: NEG
38834: PUSH
38835: LD_INT 0
38837: PUSH
38838: EMPTY
38839: LIST
38840: LIST
38841: PUSH
38842: LD_INT 3
38844: NEG
38845: PUSH
38846: LD_INT 1
38848: NEG
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 2
38856: NEG
38857: PUSH
38858: LD_INT 0
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 2
38867: NEG
38868: PUSH
38869: LD_INT 1
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 3
38878: NEG
38879: PUSH
38880: LD_INT 1
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: LD_INT 4
38889: NEG
38890: PUSH
38891: LD_INT 0
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PUSH
38898: LD_INT 4
38900: NEG
38901: PUSH
38902: LD_INT 1
38904: NEG
38905: PUSH
38906: EMPTY
38907: LIST
38908: LIST
38909: PUSH
38910: LD_INT 4
38912: NEG
38913: PUSH
38914: LD_INT 2
38916: NEG
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 2
38924: NEG
38925: PUSH
38926: LD_INT 2
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PUSH
38933: LD_INT 4
38935: NEG
38936: PUSH
38937: LD_INT 4
38939: NEG
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 4
38947: NEG
38948: PUSH
38949: LD_INT 5
38951: NEG
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 3
38959: NEG
38960: PUSH
38961: LD_INT 4
38963: NEG
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 3
38971: NEG
38972: PUSH
38973: LD_INT 3
38975: NEG
38976: PUSH
38977: EMPTY
38978: LIST
38979: LIST
38980: PUSH
38981: LD_INT 4
38983: NEG
38984: PUSH
38985: LD_INT 3
38987: NEG
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 5
38995: NEG
38996: PUSH
38997: LD_INT 4
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 5
39007: NEG
39008: PUSH
39009: LD_INT 5
39011: NEG
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 3
39019: NEG
39020: PUSH
39021: LD_INT 5
39023: NEG
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 5
39031: NEG
39032: PUSH
39033: LD_INT 3
39035: NEG
39036: PUSH
39037: EMPTY
39038: LIST
39039: LIST
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: LIST
39045: LIST
39046: LIST
39047: LIST
39048: LIST
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: LIST
39087: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
39088: LD_ADDR_VAR 0 30
39092: PUSH
39093: LD_INT 4
39095: PUSH
39096: LD_INT 4
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: LD_INT 4
39105: PUSH
39106: LD_INT 3
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 5
39115: PUSH
39116: LD_INT 4
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 5
39125: PUSH
39126: LD_INT 5
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 4
39135: PUSH
39136: LD_INT 5
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 3
39145: PUSH
39146: LD_INT 4
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 3
39155: PUSH
39156: LD_INT 3
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 5
39165: PUSH
39166: LD_INT 3
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 3
39175: PUSH
39176: LD_INT 5
39178: PUSH
39179: EMPTY
39180: LIST
39181: LIST
39182: PUSH
39183: LD_INT 0
39185: PUSH
39186: LD_INT 3
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: LD_INT 2
39198: PUSH
39199: EMPTY
39200: LIST
39201: LIST
39202: PUSH
39203: LD_INT 1
39205: PUSH
39206: LD_INT 3
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 1
39215: PUSH
39216: LD_INT 4
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: LD_INT 0
39225: PUSH
39226: LD_INT 4
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: LD_INT 1
39235: NEG
39236: PUSH
39237: LD_INT 3
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 1
39246: NEG
39247: PUSH
39248: LD_INT 2
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 2
39257: PUSH
39258: LD_INT 4
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 2
39267: NEG
39268: PUSH
39269: LD_INT 2
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: LD_INT 4
39278: NEG
39279: PUSH
39280: LD_INT 0
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 4
39289: NEG
39290: PUSH
39291: LD_INT 1
39293: NEG
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 3
39301: NEG
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: PUSH
39310: LD_INT 3
39312: NEG
39313: PUSH
39314: LD_INT 1
39316: PUSH
39317: EMPTY
39318: LIST
39319: LIST
39320: PUSH
39321: LD_INT 4
39323: NEG
39324: PUSH
39325: LD_INT 1
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 5
39334: NEG
39335: PUSH
39336: LD_INT 0
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 5
39345: NEG
39346: PUSH
39347: LD_INT 1
39349: NEG
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 5
39357: NEG
39358: PUSH
39359: LD_INT 2
39361: NEG
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 3
39369: NEG
39370: PUSH
39371: LD_INT 2
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 3
39380: NEG
39381: PUSH
39382: LD_INT 3
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 3
39392: NEG
39393: PUSH
39394: LD_INT 4
39396: NEG
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 2
39404: NEG
39405: PUSH
39406: LD_INT 3
39408: NEG
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 2
39416: NEG
39417: PUSH
39418: LD_INT 2
39420: NEG
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 3
39428: NEG
39429: PUSH
39430: LD_INT 2
39432: NEG
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 4
39440: NEG
39441: PUSH
39442: LD_INT 3
39444: NEG
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 4
39452: NEG
39453: PUSH
39454: LD_INT 4
39456: NEG
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 2
39464: NEG
39465: PUSH
39466: LD_INT 4
39468: NEG
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 4
39476: NEG
39477: PUSH
39478: LD_INT 2
39480: NEG
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: PUSH
39486: LD_INT 0
39488: PUSH
39489: LD_INT 4
39491: NEG
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: PUSH
39497: LD_INT 0
39499: PUSH
39500: LD_INT 5
39502: NEG
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 1
39510: PUSH
39511: LD_INT 4
39513: NEG
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 1
39521: PUSH
39522: LD_INT 3
39524: NEG
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: LD_INT 0
39532: PUSH
39533: LD_INT 3
39535: NEG
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 1
39543: NEG
39544: PUSH
39545: LD_INT 4
39547: NEG
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 1
39555: NEG
39556: PUSH
39557: LD_INT 5
39559: NEG
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 2
39567: PUSH
39568: LD_INT 3
39570: NEG
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: LD_INT 2
39578: NEG
39579: PUSH
39580: LD_INT 5
39582: NEG
39583: PUSH
39584: EMPTY
39585: LIST
39586: LIST
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: LIST
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: LIST
39597: LIST
39598: LIST
39599: LIST
39600: LIST
39601: LIST
39602: LIST
39603: LIST
39604: LIST
39605: LIST
39606: LIST
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39635: LD_ADDR_VAR 0 31
39639: PUSH
39640: LD_INT 0
39642: PUSH
39643: LD_INT 4
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PUSH
39650: LD_INT 0
39652: PUSH
39653: LD_INT 3
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: LD_INT 1
39662: PUSH
39663: LD_INT 4
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: LD_INT 5
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: LD_INT 5
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 1
39692: NEG
39693: PUSH
39694: LD_INT 4
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 1
39703: NEG
39704: PUSH
39705: LD_INT 3
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 2
39714: PUSH
39715: LD_INT 5
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 2
39724: NEG
39725: PUSH
39726: LD_INT 3
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 3
39735: NEG
39736: PUSH
39737: LD_INT 0
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: LD_INT 3
39746: NEG
39747: PUSH
39748: LD_INT 1
39750: NEG
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 2
39758: NEG
39759: PUSH
39760: LD_INT 0
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 2
39769: NEG
39770: PUSH
39771: LD_INT 1
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PUSH
39778: LD_INT 3
39780: NEG
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 4
39791: NEG
39792: PUSH
39793: LD_INT 0
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 4
39802: NEG
39803: PUSH
39804: LD_INT 1
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 4
39814: NEG
39815: PUSH
39816: LD_INT 2
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 2
39826: NEG
39827: PUSH
39828: LD_INT 2
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 4
39837: NEG
39838: PUSH
39839: LD_INT 4
39841: NEG
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 4
39849: NEG
39850: PUSH
39851: LD_INT 5
39853: NEG
39854: PUSH
39855: EMPTY
39856: LIST
39857: LIST
39858: PUSH
39859: LD_INT 3
39861: NEG
39862: PUSH
39863: LD_INT 4
39865: NEG
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: LD_INT 3
39873: NEG
39874: PUSH
39875: LD_INT 3
39877: NEG
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 4
39885: NEG
39886: PUSH
39887: LD_INT 3
39889: NEG
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: PUSH
39895: LD_INT 5
39897: NEG
39898: PUSH
39899: LD_INT 4
39901: NEG
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 5
39909: NEG
39910: PUSH
39911: LD_INT 5
39913: NEG
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 3
39921: NEG
39922: PUSH
39923: LD_INT 5
39925: NEG
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 5
39933: NEG
39934: PUSH
39935: LD_INT 3
39937: NEG
39938: PUSH
39939: EMPTY
39940: LIST
39941: LIST
39942: PUSH
39943: LD_INT 0
39945: PUSH
39946: LD_INT 3
39948: NEG
39949: PUSH
39950: EMPTY
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 0
39956: PUSH
39957: LD_INT 4
39959: NEG
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 1
39967: PUSH
39968: LD_INT 3
39970: NEG
39971: PUSH
39972: EMPTY
39973: LIST
39974: LIST
39975: PUSH
39976: LD_INT 1
39978: PUSH
39979: LD_INT 2
39981: NEG
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 0
39989: PUSH
39990: LD_INT 2
39992: NEG
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 1
40000: NEG
40001: PUSH
40002: LD_INT 3
40004: NEG
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 1
40012: NEG
40013: PUSH
40014: LD_INT 4
40016: NEG
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 2
40024: PUSH
40025: LD_INT 2
40027: NEG
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: LD_INT 2
40035: NEG
40036: PUSH
40037: LD_INT 4
40039: NEG
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 4
40047: PUSH
40048: LD_INT 0
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 4
40057: PUSH
40058: LD_INT 1
40060: NEG
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 5
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 5
40078: PUSH
40079: LD_INT 1
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 4
40088: PUSH
40089: LD_INT 1
40091: PUSH
40092: EMPTY
40093: LIST
40094: LIST
40095: PUSH
40096: LD_INT 3
40098: PUSH
40099: LD_INT 0
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 3
40108: PUSH
40109: LD_INT 1
40111: NEG
40112: PUSH
40113: EMPTY
40114: LIST
40115: LIST
40116: PUSH
40117: LD_INT 3
40119: PUSH
40120: LD_INT 2
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 5
40130: PUSH
40131: LD_INT 2
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: LIST
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: LIST
40162: LIST
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: LIST
40181: LIST
40182: LIST
40183: LIST
40184: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
40185: LD_ADDR_VAR 0 32
40189: PUSH
40190: LD_INT 4
40192: NEG
40193: PUSH
40194: LD_INT 0
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: LD_INT 4
40203: NEG
40204: PUSH
40205: LD_INT 1
40207: NEG
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 3
40215: NEG
40216: PUSH
40217: LD_INT 0
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 3
40226: NEG
40227: PUSH
40228: LD_INT 1
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 4
40237: NEG
40238: PUSH
40239: LD_INT 1
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 5
40248: NEG
40249: PUSH
40250: LD_INT 0
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 5
40259: NEG
40260: PUSH
40261: LD_INT 1
40263: NEG
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 5
40271: NEG
40272: PUSH
40273: LD_INT 2
40275: NEG
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 3
40283: NEG
40284: PUSH
40285: LD_INT 2
40287: PUSH
40288: EMPTY
40289: LIST
40290: LIST
40291: PUSH
40292: LD_INT 3
40294: NEG
40295: PUSH
40296: LD_INT 3
40298: NEG
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: LD_INT 3
40306: NEG
40307: PUSH
40308: LD_INT 4
40310: NEG
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 2
40318: NEG
40319: PUSH
40320: LD_INT 3
40322: NEG
40323: PUSH
40324: EMPTY
40325: LIST
40326: LIST
40327: PUSH
40328: LD_INT 2
40330: NEG
40331: PUSH
40332: LD_INT 2
40334: NEG
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 3
40342: NEG
40343: PUSH
40344: LD_INT 2
40346: NEG
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 4
40354: NEG
40355: PUSH
40356: LD_INT 3
40358: NEG
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 4
40366: NEG
40367: PUSH
40368: LD_INT 4
40370: NEG
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 2
40378: NEG
40379: PUSH
40380: LD_INT 4
40382: NEG
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: PUSH
40388: LD_INT 4
40390: NEG
40391: PUSH
40392: LD_INT 2
40394: NEG
40395: PUSH
40396: EMPTY
40397: LIST
40398: LIST
40399: PUSH
40400: LD_INT 0
40402: PUSH
40403: LD_INT 4
40405: NEG
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 0
40413: PUSH
40414: LD_INT 5
40416: NEG
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: LD_INT 1
40424: PUSH
40425: LD_INT 4
40427: NEG
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 1
40435: PUSH
40436: LD_INT 3
40438: NEG
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 0
40446: PUSH
40447: LD_INT 3
40449: NEG
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 1
40457: NEG
40458: PUSH
40459: LD_INT 4
40461: NEG
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: LD_INT 1
40469: NEG
40470: PUSH
40471: LD_INT 5
40473: NEG
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 2
40481: PUSH
40482: LD_INT 3
40484: NEG
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 2
40492: NEG
40493: PUSH
40494: LD_INT 5
40496: NEG
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 3
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 3
40514: PUSH
40515: LD_INT 1
40517: NEG
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 4
40525: PUSH
40526: LD_INT 0
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: LD_INT 4
40535: PUSH
40536: LD_INT 1
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 3
40545: PUSH
40546: LD_INT 1
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: PUSH
40553: LD_INT 2
40555: PUSH
40556: LD_INT 0
40558: PUSH
40559: EMPTY
40560: LIST
40561: LIST
40562: PUSH
40563: LD_INT 2
40565: PUSH
40566: LD_INT 1
40568: NEG
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 2
40576: PUSH
40577: LD_INT 2
40579: NEG
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 4
40587: PUSH
40588: LD_INT 2
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 4
40597: PUSH
40598: LD_INT 4
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: LD_INT 4
40607: PUSH
40608: LD_INT 3
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 5
40617: PUSH
40618: LD_INT 4
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 5
40627: PUSH
40628: LD_INT 5
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 4
40637: PUSH
40638: LD_INT 5
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 3
40647: PUSH
40648: LD_INT 4
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 3
40657: PUSH
40658: LD_INT 3
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 5
40667: PUSH
40668: LD_INT 3
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 3
40677: PUSH
40678: LD_INT 5
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: LIST
40728: LIST
40729: LIST
40730: LIST
40731: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40732: LD_ADDR_VAR 0 33
40736: PUSH
40737: LD_INT 4
40739: NEG
40740: PUSH
40741: LD_INT 4
40743: NEG
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: LD_INT 4
40751: NEG
40752: PUSH
40753: LD_INT 5
40755: NEG
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 3
40763: NEG
40764: PUSH
40765: LD_INT 4
40767: NEG
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 3
40775: NEG
40776: PUSH
40777: LD_INT 3
40779: NEG
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 4
40787: NEG
40788: PUSH
40789: LD_INT 3
40791: NEG
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 5
40799: NEG
40800: PUSH
40801: LD_INT 4
40803: NEG
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: PUSH
40809: LD_INT 5
40811: NEG
40812: PUSH
40813: LD_INT 5
40815: NEG
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 3
40823: NEG
40824: PUSH
40825: LD_INT 5
40827: NEG
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 5
40835: NEG
40836: PUSH
40837: LD_INT 3
40839: NEG
40840: PUSH
40841: EMPTY
40842: LIST
40843: LIST
40844: PUSH
40845: LD_INT 0
40847: PUSH
40848: LD_INT 3
40850: NEG
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 0
40858: PUSH
40859: LD_INT 4
40861: NEG
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 1
40869: PUSH
40870: LD_INT 3
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 1
40880: PUSH
40881: LD_INT 2
40883: NEG
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 0
40891: PUSH
40892: LD_INT 2
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 1
40902: NEG
40903: PUSH
40904: LD_INT 3
40906: NEG
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 1
40914: NEG
40915: PUSH
40916: LD_INT 4
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 2
40926: PUSH
40927: LD_INT 2
40929: NEG
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 2
40937: NEG
40938: PUSH
40939: LD_INT 4
40941: NEG
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 4
40949: PUSH
40950: LD_INT 0
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 4
40959: PUSH
40960: LD_INT 1
40962: NEG
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 5
40970: PUSH
40971: LD_INT 0
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 5
40980: PUSH
40981: LD_INT 1
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: LD_INT 4
40990: PUSH
40991: LD_INT 1
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: PUSH
40998: LD_INT 3
41000: PUSH
41001: LD_INT 0
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 3
41010: PUSH
41011: LD_INT 1
41013: NEG
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 3
41021: PUSH
41022: LD_INT 2
41024: NEG
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: LD_INT 5
41032: PUSH
41033: LD_INT 2
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: LD_INT 3
41042: PUSH
41043: LD_INT 3
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 3
41052: PUSH
41053: LD_INT 2
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 4
41062: PUSH
41063: LD_INT 3
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 4
41072: PUSH
41073: LD_INT 4
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: LD_INT 3
41082: PUSH
41083: LD_INT 4
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 2
41092: PUSH
41093: LD_INT 3
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 2
41102: PUSH
41103: LD_INT 2
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: LD_INT 4
41112: PUSH
41113: LD_INT 2
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 2
41122: PUSH
41123: LD_INT 4
41125: PUSH
41126: EMPTY
41127: LIST
41128: LIST
41129: PUSH
41130: LD_INT 0
41132: PUSH
41133: LD_INT 4
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: PUSH
41140: LD_INT 0
41142: PUSH
41143: LD_INT 3
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 1
41152: PUSH
41153: LD_INT 4
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 1
41162: PUSH
41163: LD_INT 5
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: LD_INT 0
41172: PUSH
41173: LD_INT 5
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: LD_INT 1
41182: NEG
41183: PUSH
41184: LD_INT 4
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: PUSH
41191: LD_INT 1
41193: NEG
41194: PUSH
41195: LD_INT 3
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 2
41204: PUSH
41205: LD_INT 5
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 2
41214: NEG
41215: PUSH
41216: LD_INT 3
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: LIST
41227: LIST
41228: LIST
41229: LIST
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: LIST
41252: LIST
41253: LIST
41254: LIST
41255: LIST
41256: LIST
41257: LIST
41258: LIST
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: LIST
41266: LIST
41267: LIST
41268: LIST
41269: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41270: LD_ADDR_VAR 0 34
41274: PUSH
41275: LD_INT 0
41277: PUSH
41278: LD_INT 4
41280: NEG
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 0
41288: PUSH
41289: LD_INT 5
41291: NEG
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 1
41299: PUSH
41300: LD_INT 4
41302: NEG
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 1
41310: PUSH
41311: LD_INT 3
41313: NEG
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 0
41321: PUSH
41322: LD_INT 3
41324: NEG
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 1
41332: NEG
41333: PUSH
41334: LD_INT 4
41336: NEG
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: PUSH
41342: LD_INT 1
41344: NEG
41345: PUSH
41346: LD_INT 5
41348: NEG
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: PUSH
41354: LD_INT 2
41356: PUSH
41357: LD_INT 3
41359: NEG
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 2
41367: NEG
41368: PUSH
41369: LD_INT 5
41371: NEG
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: LD_INT 3
41379: PUSH
41380: LD_INT 0
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 3
41389: PUSH
41390: LD_INT 1
41392: NEG
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: LD_INT 4
41400: PUSH
41401: LD_INT 0
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 4
41410: PUSH
41411: LD_INT 1
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: LD_INT 3
41420: PUSH
41421: LD_INT 1
41423: PUSH
41424: EMPTY
41425: LIST
41426: LIST
41427: PUSH
41428: LD_INT 2
41430: PUSH
41431: LD_INT 0
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 2
41440: PUSH
41441: LD_INT 1
41443: NEG
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 2
41451: PUSH
41452: LD_INT 2
41454: NEG
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 4
41462: PUSH
41463: LD_INT 2
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 4
41472: PUSH
41473: LD_INT 4
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 4
41482: PUSH
41483: LD_INT 3
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 5
41492: PUSH
41493: LD_INT 4
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 5
41502: PUSH
41503: LD_INT 5
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 4
41512: PUSH
41513: LD_INT 5
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 3
41522: PUSH
41523: LD_INT 4
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 3
41532: PUSH
41533: LD_INT 3
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: LD_INT 5
41542: PUSH
41543: LD_INT 3
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 3
41552: PUSH
41553: LD_INT 5
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 0
41562: PUSH
41563: LD_INT 3
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: LD_INT 0
41572: PUSH
41573: LD_INT 2
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 1
41582: PUSH
41583: LD_INT 3
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 1
41592: PUSH
41593: LD_INT 4
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PUSH
41600: LD_INT 0
41602: PUSH
41603: LD_INT 4
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 1
41612: NEG
41613: PUSH
41614: LD_INT 3
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 1
41623: NEG
41624: PUSH
41625: LD_INT 2
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 2
41634: PUSH
41635: LD_INT 4
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 2
41644: NEG
41645: PUSH
41646: LD_INT 2
41648: PUSH
41649: EMPTY
41650: LIST
41651: LIST
41652: PUSH
41653: LD_INT 4
41655: NEG
41656: PUSH
41657: LD_INT 0
41659: PUSH
41660: EMPTY
41661: LIST
41662: LIST
41663: PUSH
41664: LD_INT 4
41666: NEG
41667: PUSH
41668: LD_INT 1
41670: NEG
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 3
41678: NEG
41679: PUSH
41680: LD_INT 0
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: LD_INT 3
41689: NEG
41690: PUSH
41691: LD_INT 1
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: PUSH
41698: LD_INT 4
41700: NEG
41701: PUSH
41702: LD_INT 1
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 5
41711: NEG
41712: PUSH
41713: LD_INT 0
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: PUSH
41720: LD_INT 5
41722: NEG
41723: PUSH
41724: LD_INT 1
41726: NEG
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: LD_INT 5
41734: NEG
41735: PUSH
41736: LD_INT 2
41738: NEG
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: PUSH
41744: LD_INT 3
41746: NEG
41747: PUSH
41748: LD_INT 2
41750: PUSH
41751: EMPTY
41752: LIST
41753: LIST
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: ST_TO_ADDR
// end ; end ;
41802: GO 41805
41804: POP
// case btype of b_depot , b_warehouse :
41805: LD_VAR 0 1
41809: PUSH
41810: LD_INT 0
41812: DOUBLE
41813: EQUAL
41814: IFTRUE 41824
41816: LD_INT 1
41818: DOUBLE
41819: EQUAL
41820: IFTRUE 41824
41822: GO 42025
41824: POP
// case nation of nation_american :
41825: LD_VAR 0 5
41829: PUSH
41830: LD_INT 1
41832: DOUBLE
41833: EQUAL
41834: IFTRUE 41838
41836: GO 41894
41838: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41839: LD_ADDR_VAR 0 9
41843: PUSH
41844: LD_VAR 0 11
41848: PUSH
41849: LD_VAR 0 12
41853: PUSH
41854: LD_VAR 0 13
41858: PUSH
41859: LD_VAR 0 14
41863: PUSH
41864: LD_VAR 0 15
41868: PUSH
41869: LD_VAR 0 16
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: LIST
41878: LIST
41879: LIST
41880: LIST
41881: PUSH
41882: LD_VAR 0 4
41886: PUSH
41887: LD_INT 1
41889: PLUS
41890: ARRAY
41891: ST_TO_ADDR
41892: GO 42023
41894: LD_INT 2
41896: DOUBLE
41897: EQUAL
41898: IFTRUE 41902
41900: GO 41958
41902: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41903: LD_ADDR_VAR 0 9
41907: PUSH
41908: LD_VAR 0 17
41912: PUSH
41913: LD_VAR 0 18
41917: PUSH
41918: LD_VAR 0 19
41922: PUSH
41923: LD_VAR 0 20
41927: PUSH
41928: LD_VAR 0 21
41932: PUSH
41933: LD_VAR 0 22
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: LIST
41942: LIST
41943: LIST
41944: LIST
41945: PUSH
41946: LD_VAR 0 4
41950: PUSH
41951: LD_INT 1
41953: PLUS
41954: ARRAY
41955: ST_TO_ADDR
41956: GO 42023
41958: LD_INT 3
41960: DOUBLE
41961: EQUAL
41962: IFTRUE 41966
41964: GO 42022
41966: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41967: LD_ADDR_VAR 0 9
41971: PUSH
41972: LD_VAR 0 23
41976: PUSH
41977: LD_VAR 0 24
41981: PUSH
41982: LD_VAR 0 25
41986: PUSH
41987: LD_VAR 0 26
41991: PUSH
41992: LD_VAR 0 27
41996: PUSH
41997: LD_VAR 0 28
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: LIST
42006: LIST
42007: LIST
42008: LIST
42009: PUSH
42010: LD_VAR 0 4
42014: PUSH
42015: LD_INT 1
42017: PLUS
42018: ARRAY
42019: ST_TO_ADDR
42020: GO 42023
42022: POP
42023: GO 42578
42025: LD_INT 2
42027: DOUBLE
42028: EQUAL
42029: IFTRUE 42039
42031: LD_INT 3
42033: DOUBLE
42034: EQUAL
42035: IFTRUE 42039
42037: GO 42095
42039: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42040: LD_ADDR_VAR 0 9
42044: PUSH
42045: LD_VAR 0 29
42049: PUSH
42050: LD_VAR 0 30
42054: PUSH
42055: LD_VAR 0 31
42059: PUSH
42060: LD_VAR 0 32
42064: PUSH
42065: LD_VAR 0 33
42069: PUSH
42070: LD_VAR 0 34
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: PUSH
42083: LD_VAR 0 4
42087: PUSH
42088: LD_INT 1
42090: PLUS
42091: ARRAY
42092: ST_TO_ADDR
42093: GO 42578
42095: LD_INT 16
42097: DOUBLE
42098: EQUAL
42099: IFTRUE 42157
42101: LD_INT 17
42103: DOUBLE
42104: EQUAL
42105: IFTRUE 42157
42107: LD_INT 18
42109: DOUBLE
42110: EQUAL
42111: IFTRUE 42157
42113: LD_INT 19
42115: DOUBLE
42116: EQUAL
42117: IFTRUE 42157
42119: LD_INT 22
42121: DOUBLE
42122: EQUAL
42123: IFTRUE 42157
42125: LD_INT 20
42127: DOUBLE
42128: EQUAL
42129: IFTRUE 42157
42131: LD_INT 21
42133: DOUBLE
42134: EQUAL
42135: IFTRUE 42157
42137: LD_INT 23
42139: DOUBLE
42140: EQUAL
42141: IFTRUE 42157
42143: LD_INT 24
42145: DOUBLE
42146: EQUAL
42147: IFTRUE 42157
42149: LD_INT 25
42151: DOUBLE
42152: EQUAL
42153: IFTRUE 42157
42155: GO 42213
42157: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
42158: LD_ADDR_VAR 0 9
42162: PUSH
42163: LD_VAR 0 35
42167: PUSH
42168: LD_VAR 0 36
42172: PUSH
42173: LD_VAR 0 37
42177: PUSH
42178: LD_VAR 0 38
42182: PUSH
42183: LD_VAR 0 39
42187: PUSH
42188: LD_VAR 0 40
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: LIST
42197: LIST
42198: LIST
42199: LIST
42200: PUSH
42201: LD_VAR 0 4
42205: PUSH
42206: LD_INT 1
42208: PLUS
42209: ARRAY
42210: ST_TO_ADDR
42211: GO 42578
42213: LD_INT 6
42215: DOUBLE
42216: EQUAL
42217: IFTRUE 42269
42219: LD_INT 7
42221: DOUBLE
42222: EQUAL
42223: IFTRUE 42269
42225: LD_INT 8
42227: DOUBLE
42228: EQUAL
42229: IFTRUE 42269
42231: LD_INT 13
42233: DOUBLE
42234: EQUAL
42235: IFTRUE 42269
42237: LD_INT 12
42239: DOUBLE
42240: EQUAL
42241: IFTRUE 42269
42243: LD_INT 15
42245: DOUBLE
42246: EQUAL
42247: IFTRUE 42269
42249: LD_INT 11
42251: DOUBLE
42252: EQUAL
42253: IFTRUE 42269
42255: LD_INT 14
42257: DOUBLE
42258: EQUAL
42259: IFTRUE 42269
42261: LD_INT 10
42263: DOUBLE
42264: EQUAL
42265: IFTRUE 42269
42267: GO 42325
42269: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42270: LD_ADDR_VAR 0 9
42274: PUSH
42275: LD_VAR 0 41
42279: PUSH
42280: LD_VAR 0 42
42284: PUSH
42285: LD_VAR 0 43
42289: PUSH
42290: LD_VAR 0 44
42294: PUSH
42295: LD_VAR 0 45
42299: PUSH
42300: LD_VAR 0 46
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: PUSH
42313: LD_VAR 0 4
42317: PUSH
42318: LD_INT 1
42320: PLUS
42321: ARRAY
42322: ST_TO_ADDR
42323: GO 42578
42325: LD_INT 36
42327: DOUBLE
42328: EQUAL
42329: IFTRUE 42333
42331: GO 42389
42333: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42334: LD_ADDR_VAR 0 9
42338: PUSH
42339: LD_VAR 0 47
42343: PUSH
42344: LD_VAR 0 48
42348: PUSH
42349: LD_VAR 0 49
42353: PUSH
42354: LD_VAR 0 50
42358: PUSH
42359: LD_VAR 0 51
42363: PUSH
42364: LD_VAR 0 52
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: LIST
42373: LIST
42374: LIST
42375: LIST
42376: PUSH
42377: LD_VAR 0 4
42381: PUSH
42382: LD_INT 1
42384: PLUS
42385: ARRAY
42386: ST_TO_ADDR
42387: GO 42578
42389: LD_INT 4
42391: DOUBLE
42392: EQUAL
42393: IFTRUE 42415
42395: LD_INT 5
42397: DOUBLE
42398: EQUAL
42399: IFTRUE 42415
42401: LD_INT 34
42403: DOUBLE
42404: EQUAL
42405: IFTRUE 42415
42407: LD_INT 37
42409: DOUBLE
42410: EQUAL
42411: IFTRUE 42415
42413: GO 42471
42415: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42416: LD_ADDR_VAR 0 9
42420: PUSH
42421: LD_VAR 0 53
42425: PUSH
42426: LD_VAR 0 54
42430: PUSH
42431: LD_VAR 0 55
42435: PUSH
42436: LD_VAR 0 56
42440: PUSH
42441: LD_VAR 0 57
42445: PUSH
42446: LD_VAR 0 58
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: PUSH
42459: LD_VAR 0 4
42463: PUSH
42464: LD_INT 1
42466: PLUS
42467: ARRAY
42468: ST_TO_ADDR
42469: GO 42578
42471: LD_INT 31
42473: DOUBLE
42474: EQUAL
42475: IFTRUE 42521
42477: LD_INT 32
42479: DOUBLE
42480: EQUAL
42481: IFTRUE 42521
42483: LD_INT 33
42485: DOUBLE
42486: EQUAL
42487: IFTRUE 42521
42489: LD_INT 27
42491: DOUBLE
42492: EQUAL
42493: IFTRUE 42521
42495: LD_INT 26
42497: DOUBLE
42498: EQUAL
42499: IFTRUE 42521
42501: LD_INT 28
42503: DOUBLE
42504: EQUAL
42505: IFTRUE 42521
42507: LD_INT 29
42509: DOUBLE
42510: EQUAL
42511: IFTRUE 42521
42513: LD_INT 30
42515: DOUBLE
42516: EQUAL
42517: IFTRUE 42521
42519: GO 42577
42521: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42522: LD_ADDR_VAR 0 9
42526: PUSH
42527: LD_VAR 0 59
42531: PUSH
42532: LD_VAR 0 60
42536: PUSH
42537: LD_VAR 0 61
42541: PUSH
42542: LD_VAR 0 62
42546: PUSH
42547: LD_VAR 0 63
42551: PUSH
42552: LD_VAR 0 64
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: LIST
42561: LIST
42562: LIST
42563: LIST
42564: PUSH
42565: LD_VAR 0 4
42569: PUSH
42570: LD_INT 1
42572: PLUS
42573: ARRAY
42574: ST_TO_ADDR
42575: GO 42578
42577: POP
// temp_list2 = [ ] ;
42578: LD_ADDR_VAR 0 10
42582: PUSH
42583: EMPTY
42584: ST_TO_ADDR
// for i in temp_list do
42585: LD_ADDR_VAR 0 8
42589: PUSH
42590: LD_VAR 0 9
42594: PUSH
42595: FOR_IN
42596: IFFALSE 42648
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42598: LD_ADDR_VAR 0 10
42602: PUSH
42603: LD_VAR 0 10
42607: PUSH
42608: LD_VAR 0 8
42612: PUSH
42613: LD_INT 1
42615: ARRAY
42616: PUSH
42617: LD_VAR 0 2
42621: PLUS
42622: PUSH
42623: LD_VAR 0 8
42627: PUSH
42628: LD_INT 2
42630: ARRAY
42631: PUSH
42632: LD_VAR 0 3
42636: PLUS
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: EMPTY
42643: LIST
42644: ADD
42645: ST_TO_ADDR
42646: GO 42595
42648: POP
42649: POP
// result = temp_list2 ;
42650: LD_ADDR_VAR 0 7
42654: PUSH
42655: LD_VAR 0 10
42659: ST_TO_ADDR
// end ;
42660: LD_VAR 0 7
42664: RET
// export function EnemyInRange ( unit , dist ) ; begin
42665: LD_INT 0
42667: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42668: LD_ADDR_VAR 0 3
42672: PUSH
42673: LD_VAR 0 1
42677: PPUSH
42678: CALL_OW 255
42682: PPUSH
42683: LD_VAR 0 1
42687: PPUSH
42688: CALL_OW 250
42692: PPUSH
42693: LD_VAR 0 1
42697: PPUSH
42698: CALL_OW 251
42702: PPUSH
42703: LD_VAR 0 2
42707: PPUSH
42708: CALL 16038 0 4
42712: PUSH
42713: LD_INT 4
42715: ARRAY
42716: ST_TO_ADDR
// end ;
42717: LD_VAR 0 3
42721: RET
// export function PlayerSeeMe ( unit ) ; begin
42722: LD_INT 0
42724: PPUSH
// result := See ( your_side , unit ) ;
42725: LD_ADDR_VAR 0 2
42729: PUSH
42730: LD_OWVAR 2
42734: PPUSH
42735: LD_VAR 0 1
42739: PPUSH
42740: CALL_OW 292
42744: ST_TO_ADDR
// end ;
42745: LD_VAR 0 2
42749: RET
// export function ReverseDir ( unit ) ; begin
42750: LD_INT 0
42752: PPUSH
// if not unit then
42753: LD_VAR 0 1
42757: NOT
42758: IFFALSE 42762
// exit ;
42760: GO 42785
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42762: LD_ADDR_VAR 0 2
42766: PUSH
42767: LD_VAR 0 1
42771: PPUSH
42772: CALL_OW 254
42776: PUSH
42777: LD_INT 3
42779: PLUS
42780: PUSH
42781: LD_INT 6
42783: MOD
42784: ST_TO_ADDR
// end ;
42785: LD_VAR 0 2
42789: RET
// export function ReverseArray ( array ) ; var i ; begin
42790: LD_INT 0
42792: PPUSH
42793: PPUSH
// if not array then
42794: LD_VAR 0 1
42798: NOT
42799: IFFALSE 42803
// exit ;
42801: GO 42858
// result := [ ] ;
42803: LD_ADDR_VAR 0 2
42807: PUSH
42808: EMPTY
42809: ST_TO_ADDR
// for i := array downto 1 do
42810: LD_ADDR_VAR 0 3
42814: PUSH
42815: DOUBLE
42816: LD_VAR 0 1
42820: INC
42821: ST_TO_ADDR
42822: LD_INT 1
42824: PUSH
42825: FOR_DOWNTO
42826: IFFALSE 42856
// result := Join ( result , array [ i ] ) ;
42828: LD_ADDR_VAR 0 2
42832: PUSH
42833: LD_VAR 0 2
42837: PPUSH
42838: LD_VAR 0 1
42842: PUSH
42843: LD_VAR 0 3
42847: ARRAY
42848: PPUSH
42849: CALL 47514 0 2
42853: ST_TO_ADDR
42854: GO 42825
42856: POP
42857: POP
// end ;
42858: LD_VAR 0 2
42862: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
42863: LD_INT 0
42865: PPUSH
42866: PPUSH
42867: PPUSH
42868: PPUSH
42869: PPUSH
42870: PPUSH
// if not unit or not hexes then
42871: LD_VAR 0 1
42875: NOT
42876: PUSH
42877: LD_VAR 0 2
42881: NOT
42882: OR
42883: IFFALSE 42887
// exit ;
42885: GO 43010
// dist := 9999 ;
42887: LD_ADDR_VAR 0 5
42891: PUSH
42892: LD_INT 9999
42894: ST_TO_ADDR
// for i = 1 to hexes do
42895: LD_ADDR_VAR 0 4
42899: PUSH
42900: DOUBLE
42901: LD_INT 1
42903: DEC
42904: ST_TO_ADDR
42905: LD_VAR 0 2
42909: PUSH
42910: FOR_TO
42911: IFFALSE 42998
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42913: LD_ADDR_VAR 0 6
42917: PUSH
42918: LD_VAR 0 1
42922: PPUSH
42923: LD_VAR 0 2
42927: PUSH
42928: LD_VAR 0 4
42932: ARRAY
42933: PUSH
42934: LD_INT 1
42936: ARRAY
42937: PPUSH
42938: LD_VAR 0 2
42942: PUSH
42943: LD_VAR 0 4
42947: ARRAY
42948: PUSH
42949: LD_INT 2
42951: ARRAY
42952: PPUSH
42953: CALL_OW 297
42957: ST_TO_ADDR
// if tdist < dist then
42958: LD_VAR 0 6
42962: PUSH
42963: LD_VAR 0 5
42967: LESS
42968: IFFALSE 42996
// begin hex := hexes [ i ] ;
42970: LD_ADDR_VAR 0 8
42974: PUSH
42975: LD_VAR 0 2
42979: PUSH
42980: LD_VAR 0 4
42984: ARRAY
42985: ST_TO_ADDR
// dist := tdist ;
42986: LD_ADDR_VAR 0 5
42990: PUSH
42991: LD_VAR 0 6
42995: ST_TO_ADDR
// end ; end ;
42996: GO 42910
42998: POP
42999: POP
// result := hex ;
43000: LD_ADDR_VAR 0 3
43004: PUSH
43005: LD_VAR 0 8
43009: ST_TO_ADDR
// end ;
43010: LD_VAR 0 3
43014: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43015: LD_INT 0
43017: PPUSH
43018: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43019: LD_VAR 0 1
43023: NOT
43024: PUSH
43025: LD_VAR 0 1
43029: PUSH
43030: LD_INT 21
43032: PUSH
43033: LD_INT 2
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 23
43042: PUSH
43043: LD_INT 2
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: PUSH
43050: EMPTY
43051: LIST
43052: LIST
43053: PPUSH
43054: CALL_OW 69
43058: IN
43059: NOT
43060: OR
43061: IFFALSE 43065
// exit ;
43063: GO 43112
// for i = 1 to 3 do
43065: LD_ADDR_VAR 0 3
43069: PUSH
43070: DOUBLE
43071: LD_INT 1
43073: DEC
43074: ST_TO_ADDR
43075: LD_INT 3
43077: PUSH
43078: FOR_TO
43079: IFFALSE 43110
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
43081: LD_VAR 0 1
43085: PPUSH
43086: CALL_OW 250
43090: PPUSH
43091: LD_VAR 0 1
43095: PPUSH
43096: CALL_OW 251
43100: PPUSH
43101: LD_INT 1
43103: PPUSH
43104: CALL_OW 453
43108: GO 43078
43110: POP
43111: POP
// end ;
43112: LD_VAR 0 2
43116: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
43117: LD_INT 0
43119: PPUSH
43120: PPUSH
43121: PPUSH
43122: PPUSH
43123: PPUSH
43124: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
43125: LD_VAR 0 1
43129: NOT
43130: PUSH
43131: LD_VAR 0 2
43135: NOT
43136: OR
43137: PUSH
43138: LD_VAR 0 1
43142: PPUSH
43143: CALL_OW 314
43147: OR
43148: IFFALSE 43152
// exit ;
43150: GO 43619
// if GetLives ( i ) < 250 then
43152: LD_VAR 0 4
43156: PPUSH
43157: CALL_OW 256
43161: PUSH
43162: LD_INT 250
43164: LESS
43165: IFFALSE 43178
// begin ComAutodestruct ( i ) ;
43167: LD_VAR 0 4
43171: PPUSH
43172: CALL 43015 0 1
// exit ;
43176: GO 43619
// end ; x := GetX ( enemy_unit ) ;
43178: LD_ADDR_VAR 0 7
43182: PUSH
43183: LD_VAR 0 2
43187: PPUSH
43188: CALL_OW 250
43192: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
43193: LD_ADDR_VAR 0 8
43197: PUSH
43198: LD_VAR 0 2
43202: PPUSH
43203: CALL_OW 251
43207: ST_TO_ADDR
// if not x or not y then
43208: LD_VAR 0 7
43212: NOT
43213: PUSH
43214: LD_VAR 0 8
43218: NOT
43219: OR
43220: IFFALSE 43224
// exit ;
43222: GO 43619
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43224: LD_ADDR_VAR 0 6
43228: PUSH
43229: LD_VAR 0 7
43233: PPUSH
43234: LD_INT 0
43236: PPUSH
43237: LD_INT 4
43239: PPUSH
43240: CALL_OW 272
43244: PUSH
43245: LD_VAR 0 8
43249: PPUSH
43250: LD_INT 0
43252: PPUSH
43253: LD_INT 4
43255: PPUSH
43256: CALL_OW 273
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_VAR 0 7
43269: PPUSH
43270: LD_INT 1
43272: PPUSH
43273: LD_INT 4
43275: PPUSH
43276: CALL_OW 272
43280: PUSH
43281: LD_VAR 0 8
43285: PPUSH
43286: LD_INT 1
43288: PPUSH
43289: LD_INT 4
43291: PPUSH
43292: CALL_OW 273
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_VAR 0 7
43305: PPUSH
43306: LD_INT 2
43308: PPUSH
43309: LD_INT 4
43311: PPUSH
43312: CALL_OW 272
43316: PUSH
43317: LD_VAR 0 8
43321: PPUSH
43322: LD_INT 2
43324: PPUSH
43325: LD_INT 4
43327: PPUSH
43328: CALL_OW 273
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: LD_VAR 0 7
43341: PPUSH
43342: LD_INT 3
43344: PPUSH
43345: LD_INT 4
43347: PPUSH
43348: CALL_OW 272
43352: PUSH
43353: LD_VAR 0 8
43357: PPUSH
43358: LD_INT 3
43360: PPUSH
43361: LD_INT 4
43363: PPUSH
43364: CALL_OW 273
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: PUSH
43373: LD_VAR 0 7
43377: PPUSH
43378: LD_INT 4
43380: PPUSH
43381: LD_INT 4
43383: PPUSH
43384: CALL_OW 272
43388: PUSH
43389: LD_VAR 0 8
43393: PPUSH
43394: LD_INT 4
43396: PPUSH
43397: LD_INT 4
43399: PPUSH
43400: CALL_OW 273
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: LD_VAR 0 7
43413: PPUSH
43414: LD_INT 5
43416: PPUSH
43417: LD_INT 4
43419: PPUSH
43420: CALL_OW 272
43424: PUSH
43425: LD_VAR 0 8
43429: PPUSH
43430: LD_INT 5
43432: PPUSH
43433: LD_INT 4
43435: PPUSH
43436: CALL_OW 273
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: LIST
43449: LIST
43450: LIST
43451: LIST
43452: ST_TO_ADDR
// for i = tmp downto 1 do
43453: LD_ADDR_VAR 0 4
43457: PUSH
43458: DOUBLE
43459: LD_VAR 0 6
43463: INC
43464: ST_TO_ADDR
43465: LD_INT 1
43467: PUSH
43468: FOR_DOWNTO
43469: IFFALSE 43570
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43471: LD_VAR 0 6
43475: PUSH
43476: LD_VAR 0 4
43480: ARRAY
43481: PUSH
43482: LD_INT 1
43484: ARRAY
43485: PPUSH
43486: LD_VAR 0 6
43490: PUSH
43491: LD_VAR 0 4
43495: ARRAY
43496: PUSH
43497: LD_INT 2
43499: ARRAY
43500: PPUSH
43501: CALL_OW 488
43505: NOT
43506: PUSH
43507: LD_VAR 0 6
43511: PUSH
43512: LD_VAR 0 4
43516: ARRAY
43517: PUSH
43518: LD_INT 1
43520: ARRAY
43521: PPUSH
43522: LD_VAR 0 6
43526: PUSH
43527: LD_VAR 0 4
43531: ARRAY
43532: PUSH
43533: LD_INT 2
43535: ARRAY
43536: PPUSH
43537: CALL_OW 428
43541: PUSH
43542: LD_INT 0
43544: NONEQUAL
43545: OR
43546: IFFALSE 43568
// tmp := Delete ( tmp , i ) ;
43548: LD_ADDR_VAR 0 6
43552: PUSH
43553: LD_VAR 0 6
43557: PPUSH
43558: LD_VAR 0 4
43562: PPUSH
43563: CALL_OW 3
43567: ST_TO_ADDR
43568: GO 43468
43570: POP
43571: POP
// j := GetClosestHex ( unit , tmp ) ;
43572: LD_ADDR_VAR 0 5
43576: PUSH
43577: LD_VAR 0 1
43581: PPUSH
43582: LD_VAR 0 6
43586: PPUSH
43587: CALL 42863 0 2
43591: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43592: LD_VAR 0 1
43596: PPUSH
43597: LD_VAR 0 5
43601: PUSH
43602: LD_INT 1
43604: ARRAY
43605: PPUSH
43606: LD_VAR 0 5
43610: PUSH
43611: LD_INT 2
43613: ARRAY
43614: PPUSH
43615: CALL_OW 111
// end ;
43619: LD_VAR 0 3
43623: RET
// export function PrepareApemanSoldier ( ) ; begin
43624: LD_INT 0
43626: PPUSH
// uc_nation := 0 ;
43627: LD_ADDR_OWVAR 21
43631: PUSH
43632: LD_INT 0
43634: ST_TO_ADDR
// hc_sex := sex_male ;
43635: LD_ADDR_OWVAR 27
43639: PUSH
43640: LD_INT 1
43642: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
43643: LD_ADDR_OWVAR 28
43647: PUSH
43648: LD_INT 15
43650: ST_TO_ADDR
// hc_gallery :=  ;
43651: LD_ADDR_OWVAR 33
43655: PUSH
43656: LD_STRING 
43658: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43659: LD_ADDR_OWVAR 31
43663: PUSH
43664: LD_INT 0
43666: PPUSH
43667: LD_INT 3
43669: PPUSH
43670: CALL_OW 12
43674: PUSH
43675: LD_INT 0
43677: PPUSH
43678: LD_INT 3
43680: PPUSH
43681: CALL_OW 12
43685: PUSH
43686: LD_INT 0
43688: PUSH
43689: LD_INT 0
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: ST_TO_ADDR
// end ;
43698: LD_VAR 0 1
43702: RET
// export function PrepareApemanEngineer ( ) ; begin
43703: LD_INT 0
43705: PPUSH
// uc_nation := 0 ;
43706: LD_ADDR_OWVAR 21
43710: PUSH
43711: LD_INT 0
43713: ST_TO_ADDR
// hc_sex := sex_male ;
43714: LD_ADDR_OWVAR 27
43718: PUSH
43719: LD_INT 1
43721: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
43722: LD_ADDR_OWVAR 28
43726: PUSH
43727: LD_INT 16
43729: ST_TO_ADDR
// hc_gallery :=  ;
43730: LD_ADDR_OWVAR 33
43734: PUSH
43735: LD_STRING 
43737: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43738: LD_ADDR_OWVAR 31
43742: PUSH
43743: LD_INT 0
43745: PPUSH
43746: LD_INT 3
43748: PPUSH
43749: CALL_OW 12
43753: PUSH
43754: LD_INT 0
43756: PPUSH
43757: LD_INT 3
43759: PPUSH
43760: CALL_OW 12
43764: PUSH
43765: LD_INT 0
43767: PUSH
43768: LD_INT 0
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: LIST
43775: LIST
43776: ST_TO_ADDR
// end ;
43777: LD_VAR 0 1
43781: RET
// export function PrepareApeman ( agressivity ) ; begin
43782: LD_INT 0
43784: PPUSH
// uc_side := 0 ;
43785: LD_ADDR_OWVAR 20
43789: PUSH
43790: LD_INT 0
43792: ST_TO_ADDR
// uc_nation := 0 ;
43793: LD_ADDR_OWVAR 21
43797: PUSH
43798: LD_INT 0
43800: ST_TO_ADDR
// hc_sex := sex_male ;
43801: LD_ADDR_OWVAR 27
43805: PUSH
43806: LD_INT 1
43808: ST_TO_ADDR
// hc_class := class_apeman ;
43809: LD_ADDR_OWVAR 28
43813: PUSH
43814: LD_INT 12
43816: ST_TO_ADDR
// hc_gallery :=  ;
43817: LD_ADDR_OWVAR 33
43821: PUSH
43822: LD_STRING 
43824: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43825: LD_ADDR_OWVAR 35
43829: PUSH
43830: LD_VAR 0 1
43834: NEG
43835: PPUSH
43836: LD_VAR 0 1
43840: PPUSH
43841: CALL_OW 12
43845: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43846: LD_ADDR_OWVAR 31
43850: PUSH
43851: LD_INT 0
43853: PPUSH
43854: LD_INT 3
43856: PPUSH
43857: CALL_OW 12
43861: PUSH
43862: LD_INT 0
43864: PPUSH
43865: LD_INT 3
43867: PPUSH
43868: CALL_OW 12
43872: PUSH
43873: LD_INT 0
43875: PUSH
43876: LD_INT 0
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: ST_TO_ADDR
// end ;
43885: LD_VAR 0 2
43889: RET
// export function PrepareTiger ( agressivity ) ; begin
43890: LD_INT 0
43892: PPUSH
// uc_side := 0 ;
43893: LD_ADDR_OWVAR 20
43897: PUSH
43898: LD_INT 0
43900: ST_TO_ADDR
// uc_nation := 0 ;
43901: LD_ADDR_OWVAR 21
43905: PUSH
43906: LD_INT 0
43908: ST_TO_ADDR
// hc_class := class_tiger ;
43909: LD_ADDR_OWVAR 28
43913: PUSH
43914: LD_INT 14
43916: ST_TO_ADDR
// hc_gallery :=  ;
43917: LD_ADDR_OWVAR 33
43921: PUSH
43922: LD_STRING 
43924: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43925: LD_ADDR_OWVAR 35
43929: PUSH
43930: LD_VAR 0 1
43934: NEG
43935: PPUSH
43936: LD_VAR 0 1
43940: PPUSH
43941: CALL_OW 12
43945: ST_TO_ADDR
// end ;
43946: LD_VAR 0 2
43950: RET
// export function PrepareEnchidna ( ) ; begin
43951: LD_INT 0
43953: PPUSH
// uc_side := 0 ;
43954: LD_ADDR_OWVAR 20
43958: PUSH
43959: LD_INT 0
43961: ST_TO_ADDR
// uc_nation := 0 ;
43962: LD_ADDR_OWVAR 21
43966: PUSH
43967: LD_INT 0
43969: ST_TO_ADDR
// hc_class := class_baggie ;
43970: LD_ADDR_OWVAR 28
43974: PUSH
43975: LD_INT 13
43977: ST_TO_ADDR
// hc_gallery :=  ;
43978: LD_ADDR_OWVAR 33
43982: PUSH
43983: LD_STRING 
43985: ST_TO_ADDR
// end ;
43986: LD_VAR 0 1
43990: RET
// export function PrepareFrog ( ) ; begin
43991: LD_INT 0
43993: PPUSH
// uc_side := 0 ;
43994: LD_ADDR_OWVAR 20
43998: PUSH
43999: LD_INT 0
44001: ST_TO_ADDR
// uc_nation := 0 ;
44002: LD_ADDR_OWVAR 21
44006: PUSH
44007: LD_INT 0
44009: ST_TO_ADDR
// hc_class := class_frog ;
44010: LD_ADDR_OWVAR 28
44014: PUSH
44015: LD_INT 19
44017: ST_TO_ADDR
// hc_gallery :=  ;
44018: LD_ADDR_OWVAR 33
44022: PUSH
44023: LD_STRING 
44025: ST_TO_ADDR
// end ;
44026: LD_VAR 0 1
44030: RET
// export function PrepareFish ( ) ; begin
44031: LD_INT 0
44033: PPUSH
// uc_side := 0 ;
44034: LD_ADDR_OWVAR 20
44038: PUSH
44039: LD_INT 0
44041: ST_TO_ADDR
// uc_nation := 0 ;
44042: LD_ADDR_OWVAR 21
44046: PUSH
44047: LD_INT 0
44049: ST_TO_ADDR
// hc_class := class_fish ;
44050: LD_ADDR_OWVAR 28
44054: PUSH
44055: LD_INT 20
44057: ST_TO_ADDR
// hc_gallery :=  ;
44058: LD_ADDR_OWVAR 33
44062: PUSH
44063: LD_STRING 
44065: ST_TO_ADDR
// end ;
44066: LD_VAR 0 1
44070: RET
// export function PrepareBird ( ) ; begin
44071: LD_INT 0
44073: PPUSH
// uc_side := 0 ;
44074: LD_ADDR_OWVAR 20
44078: PUSH
44079: LD_INT 0
44081: ST_TO_ADDR
// uc_nation := 0 ;
44082: LD_ADDR_OWVAR 21
44086: PUSH
44087: LD_INT 0
44089: ST_TO_ADDR
// hc_class := class_phororhacos ;
44090: LD_ADDR_OWVAR 28
44094: PUSH
44095: LD_INT 18
44097: ST_TO_ADDR
// hc_gallery :=  ;
44098: LD_ADDR_OWVAR 33
44102: PUSH
44103: LD_STRING 
44105: ST_TO_ADDR
// end ;
44106: LD_VAR 0 1
44110: RET
// export function PrepareHorse ( ) ; begin
44111: LD_INT 0
44113: PPUSH
// uc_side := 0 ;
44114: LD_ADDR_OWVAR 20
44118: PUSH
44119: LD_INT 0
44121: ST_TO_ADDR
// uc_nation := 0 ;
44122: LD_ADDR_OWVAR 21
44126: PUSH
44127: LD_INT 0
44129: ST_TO_ADDR
// hc_class := class_horse ;
44130: LD_ADDR_OWVAR 28
44134: PUSH
44135: LD_INT 21
44137: ST_TO_ADDR
// hc_gallery :=  ;
44138: LD_ADDR_OWVAR 33
44142: PUSH
44143: LD_STRING 
44145: ST_TO_ADDR
// end ;
44146: LD_VAR 0 1
44150: RET
// export function PrepareMastodont ( ) ; begin
44151: LD_INT 0
44153: PPUSH
// uc_side := 0 ;
44154: LD_ADDR_OWVAR 20
44158: PUSH
44159: LD_INT 0
44161: ST_TO_ADDR
// uc_nation := 0 ;
44162: LD_ADDR_OWVAR 21
44166: PUSH
44167: LD_INT 0
44169: ST_TO_ADDR
// vc_chassis := class_mastodont ;
44170: LD_ADDR_OWVAR 37
44174: PUSH
44175: LD_INT 31
44177: ST_TO_ADDR
// vc_control := control_rider ;
44178: LD_ADDR_OWVAR 38
44182: PUSH
44183: LD_INT 4
44185: ST_TO_ADDR
// end ;
44186: LD_VAR 0 1
44190: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
44191: LD_INT 0
44193: PPUSH
44194: PPUSH
44195: PPUSH
// uc_side = 0 ;
44196: LD_ADDR_OWVAR 20
44200: PUSH
44201: LD_INT 0
44203: ST_TO_ADDR
// uc_nation = 0 ;
44204: LD_ADDR_OWVAR 21
44208: PUSH
44209: LD_INT 0
44211: ST_TO_ADDR
// InitHc_All ( ) ;
44212: CALL_OW 584
// InitVc ;
44216: CALL_OW 20
// if mastodonts then
44220: LD_VAR 0 6
44224: IFFALSE 44291
// for i = 1 to mastodonts do
44226: LD_ADDR_VAR 0 11
44230: PUSH
44231: DOUBLE
44232: LD_INT 1
44234: DEC
44235: ST_TO_ADDR
44236: LD_VAR 0 6
44240: PUSH
44241: FOR_TO
44242: IFFALSE 44289
// begin vc_chassis := 31 ;
44244: LD_ADDR_OWVAR 37
44248: PUSH
44249: LD_INT 31
44251: ST_TO_ADDR
// vc_control := control_rider ;
44252: LD_ADDR_OWVAR 38
44256: PUSH
44257: LD_INT 4
44259: ST_TO_ADDR
// animal := CreateVehicle ;
44260: LD_ADDR_VAR 0 12
44264: PUSH
44265: CALL_OW 45
44269: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44270: LD_VAR 0 12
44274: PPUSH
44275: LD_VAR 0 8
44279: PPUSH
44280: LD_INT 0
44282: PPUSH
44283: CALL 46419 0 3
// end ;
44287: GO 44241
44289: POP
44290: POP
// if horses then
44291: LD_VAR 0 5
44295: IFFALSE 44362
// for i = 1 to horses do
44297: LD_ADDR_VAR 0 11
44301: PUSH
44302: DOUBLE
44303: LD_INT 1
44305: DEC
44306: ST_TO_ADDR
44307: LD_VAR 0 5
44311: PUSH
44312: FOR_TO
44313: IFFALSE 44360
// begin hc_class := 21 ;
44315: LD_ADDR_OWVAR 28
44319: PUSH
44320: LD_INT 21
44322: ST_TO_ADDR
// hc_gallery :=  ;
44323: LD_ADDR_OWVAR 33
44327: PUSH
44328: LD_STRING 
44330: ST_TO_ADDR
// animal := CreateHuman ;
44331: LD_ADDR_VAR 0 12
44335: PUSH
44336: CALL_OW 44
44340: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44341: LD_VAR 0 12
44345: PPUSH
44346: LD_VAR 0 8
44350: PPUSH
44351: LD_INT 0
44353: PPUSH
44354: CALL 46419 0 3
// end ;
44358: GO 44312
44360: POP
44361: POP
// if birds then
44362: LD_VAR 0 1
44366: IFFALSE 44433
// for i = 1 to birds do
44368: LD_ADDR_VAR 0 11
44372: PUSH
44373: DOUBLE
44374: LD_INT 1
44376: DEC
44377: ST_TO_ADDR
44378: LD_VAR 0 1
44382: PUSH
44383: FOR_TO
44384: IFFALSE 44431
// begin hc_class := 18 ;
44386: LD_ADDR_OWVAR 28
44390: PUSH
44391: LD_INT 18
44393: ST_TO_ADDR
// hc_gallery =  ;
44394: LD_ADDR_OWVAR 33
44398: PUSH
44399: LD_STRING 
44401: ST_TO_ADDR
// animal := CreateHuman ;
44402: LD_ADDR_VAR 0 12
44406: PUSH
44407: CALL_OW 44
44411: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44412: LD_VAR 0 12
44416: PPUSH
44417: LD_VAR 0 8
44421: PPUSH
44422: LD_INT 0
44424: PPUSH
44425: CALL 46419 0 3
// end ;
44429: GO 44383
44431: POP
44432: POP
// if tigers then
44433: LD_VAR 0 2
44437: IFFALSE 44521
// for i = 1 to tigers do
44439: LD_ADDR_VAR 0 11
44443: PUSH
44444: DOUBLE
44445: LD_INT 1
44447: DEC
44448: ST_TO_ADDR
44449: LD_VAR 0 2
44453: PUSH
44454: FOR_TO
44455: IFFALSE 44519
// begin hc_class = class_tiger ;
44457: LD_ADDR_OWVAR 28
44461: PUSH
44462: LD_INT 14
44464: ST_TO_ADDR
// hc_gallery =  ;
44465: LD_ADDR_OWVAR 33
44469: PUSH
44470: LD_STRING 
44472: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44473: LD_ADDR_OWVAR 35
44477: PUSH
44478: LD_INT 7
44480: NEG
44481: PPUSH
44482: LD_INT 7
44484: PPUSH
44485: CALL_OW 12
44489: ST_TO_ADDR
// animal := CreateHuman ;
44490: LD_ADDR_VAR 0 12
44494: PUSH
44495: CALL_OW 44
44499: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44500: LD_VAR 0 12
44504: PPUSH
44505: LD_VAR 0 8
44509: PPUSH
44510: LD_INT 0
44512: PPUSH
44513: CALL 46419 0 3
// end ;
44517: GO 44454
44519: POP
44520: POP
// if apemans then
44521: LD_VAR 0 3
44525: IFFALSE 44648
// for i = 1 to apemans do
44527: LD_ADDR_VAR 0 11
44531: PUSH
44532: DOUBLE
44533: LD_INT 1
44535: DEC
44536: ST_TO_ADDR
44537: LD_VAR 0 3
44541: PUSH
44542: FOR_TO
44543: IFFALSE 44646
// begin hc_class = class_apeman ;
44545: LD_ADDR_OWVAR 28
44549: PUSH
44550: LD_INT 12
44552: ST_TO_ADDR
// hc_gallery =  ;
44553: LD_ADDR_OWVAR 33
44557: PUSH
44558: LD_STRING 
44560: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44561: LD_ADDR_OWVAR 35
44565: PUSH
44566: LD_INT 2
44568: NEG
44569: PPUSH
44570: LD_INT 2
44572: PPUSH
44573: CALL_OW 12
44577: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44578: LD_ADDR_OWVAR 31
44582: PUSH
44583: LD_INT 1
44585: PPUSH
44586: LD_INT 3
44588: PPUSH
44589: CALL_OW 12
44593: PUSH
44594: LD_INT 1
44596: PPUSH
44597: LD_INT 3
44599: PPUSH
44600: CALL_OW 12
44604: PUSH
44605: LD_INT 0
44607: PUSH
44608: LD_INT 0
44610: PUSH
44611: EMPTY
44612: LIST
44613: LIST
44614: LIST
44615: LIST
44616: ST_TO_ADDR
// animal := CreateHuman ;
44617: LD_ADDR_VAR 0 12
44621: PUSH
44622: CALL_OW 44
44626: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44627: LD_VAR 0 12
44631: PPUSH
44632: LD_VAR 0 8
44636: PPUSH
44637: LD_INT 0
44639: PPUSH
44640: CALL 46419 0 3
// end ;
44644: GO 44542
44646: POP
44647: POP
// if enchidnas then
44648: LD_VAR 0 4
44652: IFFALSE 44719
// for i = 1 to enchidnas do
44654: LD_ADDR_VAR 0 11
44658: PUSH
44659: DOUBLE
44660: LD_INT 1
44662: DEC
44663: ST_TO_ADDR
44664: LD_VAR 0 4
44668: PUSH
44669: FOR_TO
44670: IFFALSE 44717
// begin hc_class = 13 ;
44672: LD_ADDR_OWVAR 28
44676: PUSH
44677: LD_INT 13
44679: ST_TO_ADDR
// hc_gallery =  ;
44680: LD_ADDR_OWVAR 33
44684: PUSH
44685: LD_STRING 
44687: ST_TO_ADDR
// animal := CreateHuman ;
44688: LD_ADDR_VAR 0 12
44692: PUSH
44693: CALL_OW 44
44697: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44698: LD_VAR 0 12
44702: PPUSH
44703: LD_VAR 0 8
44707: PPUSH
44708: LD_INT 0
44710: PPUSH
44711: CALL 46419 0 3
// end ;
44715: GO 44669
44717: POP
44718: POP
// if fishes then
44719: LD_VAR 0 7
44723: IFFALSE 44790
// for i = 1 to fishes do
44725: LD_ADDR_VAR 0 11
44729: PUSH
44730: DOUBLE
44731: LD_INT 1
44733: DEC
44734: ST_TO_ADDR
44735: LD_VAR 0 7
44739: PUSH
44740: FOR_TO
44741: IFFALSE 44788
// begin hc_class = 20 ;
44743: LD_ADDR_OWVAR 28
44747: PUSH
44748: LD_INT 20
44750: ST_TO_ADDR
// hc_gallery =  ;
44751: LD_ADDR_OWVAR 33
44755: PUSH
44756: LD_STRING 
44758: ST_TO_ADDR
// animal := CreateHuman ;
44759: LD_ADDR_VAR 0 12
44763: PUSH
44764: CALL_OW 44
44768: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44769: LD_VAR 0 12
44773: PPUSH
44774: LD_VAR 0 9
44778: PPUSH
44779: LD_INT 0
44781: PPUSH
44782: CALL 46419 0 3
// end ;
44786: GO 44740
44788: POP
44789: POP
// end ;
44790: LD_VAR 0 10
44794: RET
// export function WantHeal ( sci , unit ) ; begin
44795: LD_INT 0
44797: PPUSH
// if GetTaskList ( sci ) > 0 then
44798: LD_VAR 0 1
44802: PPUSH
44803: CALL_OW 437
44807: PUSH
44808: LD_INT 0
44810: GREATER
44811: IFFALSE 44881
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44813: LD_VAR 0 1
44817: PPUSH
44818: CALL_OW 437
44822: PUSH
44823: LD_INT 1
44825: ARRAY
44826: PUSH
44827: LD_INT 1
44829: ARRAY
44830: PUSH
44831: LD_STRING l
44833: EQUAL
44834: PUSH
44835: LD_VAR 0 1
44839: PPUSH
44840: CALL_OW 437
44844: PUSH
44845: LD_INT 1
44847: ARRAY
44848: PUSH
44849: LD_INT 4
44851: ARRAY
44852: PUSH
44853: LD_VAR 0 2
44857: EQUAL
44858: AND
44859: IFFALSE 44871
// result := true else
44861: LD_ADDR_VAR 0 3
44865: PUSH
44866: LD_INT 1
44868: ST_TO_ADDR
44869: GO 44879
// result := false ;
44871: LD_ADDR_VAR 0 3
44875: PUSH
44876: LD_INT 0
44878: ST_TO_ADDR
// end else
44879: GO 44889
// result := false ;
44881: LD_ADDR_VAR 0 3
44885: PUSH
44886: LD_INT 0
44888: ST_TO_ADDR
// end ;
44889: LD_VAR 0 3
44893: RET
// export function HealTarget ( sci ) ; begin
44894: LD_INT 0
44896: PPUSH
// if not sci then
44897: LD_VAR 0 1
44901: NOT
44902: IFFALSE 44906
// exit ;
44904: GO 44971
// result := 0 ;
44906: LD_ADDR_VAR 0 2
44910: PUSH
44911: LD_INT 0
44913: ST_TO_ADDR
// if GetTaskList ( sci ) then
44914: LD_VAR 0 1
44918: PPUSH
44919: CALL_OW 437
44923: IFFALSE 44971
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44925: LD_VAR 0 1
44929: PPUSH
44930: CALL_OW 437
44934: PUSH
44935: LD_INT 1
44937: ARRAY
44938: PUSH
44939: LD_INT 1
44941: ARRAY
44942: PUSH
44943: LD_STRING l
44945: EQUAL
44946: IFFALSE 44971
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44948: LD_ADDR_VAR 0 2
44952: PUSH
44953: LD_VAR 0 1
44957: PPUSH
44958: CALL_OW 437
44962: PUSH
44963: LD_INT 1
44965: ARRAY
44966: PUSH
44967: LD_INT 4
44969: ARRAY
44970: ST_TO_ADDR
// end ;
44971: LD_VAR 0 2
44975: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44976: LD_INT 0
44978: PPUSH
44979: PPUSH
44980: PPUSH
44981: PPUSH
// if not base_units then
44982: LD_VAR 0 1
44986: NOT
44987: IFFALSE 44991
// exit ;
44989: GO 45078
// result := false ;
44991: LD_ADDR_VAR 0 2
44995: PUSH
44996: LD_INT 0
44998: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44999: LD_ADDR_VAR 0 5
45003: PUSH
45004: LD_VAR 0 1
45008: PPUSH
45009: LD_INT 21
45011: PUSH
45012: LD_INT 3
45014: PUSH
45015: EMPTY
45016: LIST
45017: LIST
45018: PPUSH
45019: CALL_OW 72
45023: ST_TO_ADDR
// if not tmp then
45024: LD_VAR 0 5
45028: NOT
45029: IFFALSE 45033
// exit ;
45031: GO 45078
// for i in tmp do
45033: LD_ADDR_VAR 0 3
45037: PUSH
45038: LD_VAR 0 5
45042: PUSH
45043: FOR_IN
45044: IFFALSE 45076
// begin result := EnemyInRange ( i , 22 ) ;
45046: LD_ADDR_VAR 0 2
45050: PUSH
45051: LD_VAR 0 3
45055: PPUSH
45056: LD_INT 22
45058: PPUSH
45059: CALL 42665 0 2
45063: ST_TO_ADDR
// if result then
45064: LD_VAR 0 2
45068: IFFALSE 45074
// exit ;
45070: POP
45071: POP
45072: GO 45078
// end ;
45074: GO 45043
45076: POP
45077: POP
// end ;
45078: LD_VAR 0 2
45082: RET
// export function FilterByTag ( units , tag ) ; begin
45083: LD_INT 0
45085: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
45086: LD_ADDR_VAR 0 3
45090: PUSH
45091: LD_VAR 0 1
45095: PPUSH
45096: LD_INT 120
45098: PUSH
45099: LD_VAR 0 2
45103: PUSH
45104: EMPTY
45105: LIST
45106: LIST
45107: PPUSH
45108: CALL_OW 72
45112: ST_TO_ADDR
// end ;
45113: LD_VAR 0 3
45117: RET
// export function IsDriver ( un ) ; begin
45118: LD_INT 0
45120: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
45121: LD_ADDR_VAR 0 2
45125: PUSH
45126: LD_VAR 0 1
45130: PUSH
45131: LD_INT 55
45133: PUSH
45134: EMPTY
45135: LIST
45136: PPUSH
45137: CALL_OW 69
45141: IN
45142: ST_TO_ADDR
// end ;
45143: LD_VAR 0 2
45147: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
45148: LD_INT 0
45150: PPUSH
45151: PPUSH
// list := [ ] ;
45152: LD_ADDR_VAR 0 5
45156: PUSH
45157: EMPTY
45158: ST_TO_ADDR
// case d of 0 :
45159: LD_VAR 0 3
45163: PUSH
45164: LD_INT 0
45166: DOUBLE
45167: EQUAL
45168: IFTRUE 45172
45170: GO 45305
45172: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
45173: LD_ADDR_VAR 0 5
45177: PUSH
45178: LD_VAR 0 1
45182: PUSH
45183: LD_INT 4
45185: MINUS
45186: PUSH
45187: LD_VAR 0 2
45191: PUSH
45192: LD_INT 4
45194: MINUS
45195: PUSH
45196: LD_INT 2
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: LIST
45203: PUSH
45204: LD_VAR 0 1
45208: PUSH
45209: LD_INT 3
45211: MINUS
45212: PUSH
45213: LD_VAR 0 2
45217: PUSH
45218: LD_INT 1
45220: PUSH
45221: EMPTY
45222: LIST
45223: LIST
45224: LIST
45225: PUSH
45226: LD_VAR 0 1
45230: PUSH
45231: LD_INT 4
45233: PLUS
45234: PUSH
45235: LD_VAR 0 2
45239: PUSH
45240: LD_INT 4
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: LIST
45247: PUSH
45248: LD_VAR 0 1
45252: PUSH
45253: LD_INT 3
45255: PLUS
45256: PUSH
45257: LD_VAR 0 2
45261: PUSH
45262: LD_INT 3
45264: PLUS
45265: PUSH
45266: LD_INT 5
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: LIST
45273: PUSH
45274: LD_VAR 0 1
45278: PUSH
45279: LD_VAR 0 2
45283: PUSH
45284: LD_INT 4
45286: PLUS
45287: PUSH
45288: LD_INT 0
45290: PUSH
45291: EMPTY
45292: LIST
45293: LIST
45294: LIST
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: ST_TO_ADDR
// end ; 1 :
45303: GO 46003
45305: LD_INT 1
45307: DOUBLE
45308: EQUAL
45309: IFTRUE 45313
45311: GO 45446
45313: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45314: LD_ADDR_VAR 0 5
45318: PUSH
45319: LD_VAR 0 1
45323: PUSH
45324: LD_VAR 0 2
45328: PUSH
45329: LD_INT 4
45331: MINUS
45332: PUSH
45333: LD_INT 3
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: LIST
45340: PUSH
45341: LD_VAR 0 1
45345: PUSH
45346: LD_INT 3
45348: MINUS
45349: PUSH
45350: LD_VAR 0 2
45354: PUSH
45355: LD_INT 3
45357: MINUS
45358: PUSH
45359: LD_INT 2
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: LIST
45366: PUSH
45367: LD_VAR 0 1
45371: PUSH
45372: LD_INT 4
45374: MINUS
45375: PUSH
45376: LD_VAR 0 2
45380: PUSH
45381: LD_INT 1
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: LIST
45388: PUSH
45389: LD_VAR 0 1
45393: PUSH
45394: LD_VAR 0 2
45398: PUSH
45399: LD_INT 3
45401: PLUS
45402: PUSH
45403: LD_INT 0
45405: PUSH
45406: EMPTY
45407: LIST
45408: LIST
45409: LIST
45410: PUSH
45411: LD_VAR 0 1
45415: PUSH
45416: LD_INT 4
45418: PLUS
45419: PUSH
45420: LD_VAR 0 2
45424: PUSH
45425: LD_INT 4
45427: PLUS
45428: PUSH
45429: LD_INT 5
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: LIST
45436: PUSH
45437: EMPTY
45438: LIST
45439: LIST
45440: LIST
45441: LIST
45442: LIST
45443: ST_TO_ADDR
// end ; 2 :
45444: GO 46003
45446: LD_INT 2
45448: DOUBLE
45449: EQUAL
45450: IFTRUE 45454
45452: GO 45583
45454: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45455: LD_ADDR_VAR 0 5
45459: PUSH
45460: LD_VAR 0 1
45464: PUSH
45465: LD_VAR 0 2
45469: PUSH
45470: LD_INT 3
45472: MINUS
45473: PUSH
45474: LD_INT 3
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: LIST
45481: PUSH
45482: LD_VAR 0 1
45486: PUSH
45487: LD_INT 4
45489: PLUS
45490: PUSH
45491: LD_VAR 0 2
45495: PUSH
45496: LD_INT 4
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: LIST
45503: PUSH
45504: LD_VAR 0 1
45508: PUSH
45509: LD_VAR 0 2
45513: PUSH
45514: LD_INT 4
45516: PLUS
45517: PUSH
45518: LD_INT 0
45520: PUSH
45521: EMPTY
45522: LIST
45523: LIST
45524: LIST
45525: PUSH
45526: LD_VAR 0 1
45530: PUSH
45531: LD_INT 3
45533: MINUS
45534: PUSH
45535: LD_VAR 0 2
45539: PUSH
45540: LD_INT 1
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: LIST
45547: PUSH
45548: LD_VAR 0 1
45552: PUSH
45553: LD_INT 4
45555: MINUS
45556: PUSH
45557: LD_VAR 0 2
45561: PUSH
45562: LD_INT 4
45564: MINUS
45565: PUSH
45566: LD_INT 2
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: LIST
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: ST_TO_ADDR
// end ; 3 :
45581: GO 46003
45583: LD_INT 3
45585: DOUBLE
45586: EQUAL
45587: IFTRUE 45591
45589: GO 45724
45591: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45592: LD_ADDR_VAR 0 5
45596: PUSH
45597: LD_VAR 0 1
45601: PUSH
45602: LD_INT 3
45604: PLUS
45605: PUSH
45606: LD_VAR 0 2
45610: PUSH
45611: LD_INT 4
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: LIST
45618: PUSH
45619: LD_VAR 0 1
45623: PUSH
45624: LD_INT 4
45626: PLUS
45627: PUSH
45628: LD_VAR 0 2
45632: PUSH
45633: LD_INT 4
45635: PLUS
45636: PUSH
45637: LD_INT 5
45639: PUSH
45640: EMPTY
45641: LIST
45642: LIST
45643: LIST
45644: PUSH
45645: LD_VAR 0 1
45649: PUSH
45650: LD_INT 4
45652: MINUS
45653: PUSH
45654: LD_VAR 0 2
45658: PUSH
45659: LD_INT 1
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: LIST
45666: PUSH
45667: LD_VAR 0 1
45671: PUSH
45672: LD_VAR 0 2
45676: PUSH
45677: LD_INT 4
45679: MINUS
45680: PUSH
45681: LD_INT 3
45683: PUSH
45684: EMPTY
45685: LIST
45686: LIST
45687: LIST
45688: PUSH
45689: LD_VAR 0 1
45693: PUSH
45694: LD_INT 3
45696: MINUS
45697: PUSH
45698: LD_VAR 0 2
45702: PUSH
45703: LD_INT 3
45705: MINUS
45706: PUSH
45707: LD_INT 2
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: LIST
45714: PUSH
45715: EMPTY
45716: LIST
45717: LIST
45718: LIST
45719: LIST
45720: LIST
45721: ST_TO_ADDR
// end ; 4 :
45722: GO 46003
45724: LD_INT 4
45726: DOUBLE
45727: EQUAL
45728: IFTRUE 45732
45730: GO 45865
45732: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45733: LD_ADDR_VAR 0 5
45737: PUSH
45738: LD_VAR 0 1
45742: PUSH
45743: LD_VAR 0 2
45747: PUSH
45748: LD_INT 4
45750: PLUS
45751: PUSH
45752: LD_INT 0
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: LIST
45759: PUSH
45760: LD_VAR 0 1
45764: PUSH
45765: LD_INT 3
45767: PLUS
45768: PUSH
45769: LD_VAR 0 2
45773: PUSH
45774: LD_INT 3
45776: PLUS
45777: PUSH
45778: LD_INT 5
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: LIST
45785: PUSH
45786: LD_VAR 0 1
45790: PUSH
45791: LD_INT 4
45793: PLUS
45794: PUSH
45795: LD_VAR 0 2
45799: PUSH
45800: LD_INT 4
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: LIST
45807: PUSH
45808: LD_VAR 0 1
45812: PUSH
45813: LD_VAR 0 2
45817: PUSH
45818: LD_INT 3
45820: MINUS
45821: PUSH
45822: LD_INT 3
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: LIST
45829: PUSH
45830: LD_VAR 0 1
45834: PUSH
45835: LD_INT 4
45837: MINUS
45838: PUSH
45839: LD_VAR 0 2
45843: PUSH
45844: LD_INT 4
45846: MINUS
45847: PUSH
45848: LD_INT 2
45850: PUSH
45851: EMPTY
45852: LIST
45853: LIST
45854: LIST
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: ST_TO_ADDR
// end ; 5 :
45863: GO 46003
45865: LD_INT 5
45867: DOUBLE
45868: EQUAL
45869: IFTRUE 45873
45871: GO 46002
45873: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45874: LD_ADDR_VAR 0 5
45878: PUSH
45879: LD_VAR 0 1
45883: PUSH
45884: LD_INT 4
45886: MINUS
45887: PUSH
45888: LD_VAR 0 2
45892: PUSH
45893: LD_INT 1
45895: PUSH
45896: EMPTY
45897: LIST
45898: LIST
45899: LIST
45900: PUSH
45901: LD_VAR 0 1
45905: PUSH
45906: LD_VAR 0 2
45910: PUSH
45911: LD_INT 4
45913: MINUS
45914: PUSH
45915: LD_INT 3
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: LIST
45922: PUSH
45923: LD_VAR 0 1
45927: PUSH
45928: LD_INT 4
45930: PLUS
45931: PUSH
45932: LD_VAR 0 2
45936: PUSH
45937: LD_INT 4
45939: PLUS
45940: PUSH
45941: LD_INT 5
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: LIST
45948: PUSH
45949: LD_VAR 0 1
45953: PUSH
45954: LD_INT 3
45956: PLUS
45957: PUSH
45958: LD_VAR 0 2
45962: PUSH
45963: LD_INT 4
45965: PUSH
45966: EMPTY
45967: LIST
45968: LIST
45969: LIST
45970: PUSH
45971: LD_VAR 0 1
45975: PUSH
45976: LD_VAR 0 2
45980: PUSH
45981: LD_INT 3
45983: PLUS
45984: PUSH
45985: LD_INT 0
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: LIST
45992: PUSH
45993: EMPTY
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: ST_TO_ADDR
// end ; end ;
46000: GO 46003
46002: POP
// result := list ;
46003: LD_ADDR_VAR 0 4
46007: PUSH
46008: LD_VAR 0 5
46012: ST_TO_ADDR
// end ;
46013: LD_VAR 0 4
46017: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46018: LD_INT 0
46020: PPUSH
46021: PPUSH
46022: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46023: LD_VAR 0 1
46027: NOT
46028: PUSH
46029: LD_VAR 0 2
46033: PUSH
46034: LD_INT 1
46036: PUSH
46037: LD_INT 2
46039: PUSH
46040: LD_INT 3
46042: PUSH
46043: LD_INT 4
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: IN
46052: NOT
46053: OR
46054: IFFALSE 46058
// exit ;
46056: GO 46141
// tmp := [ ] ;
46058: LD_ADDR_VAR 0 5
46062: PUSH
46063: EMPTY
46064: ST_TO_ADDR
// for i in units do
46065: LD_ADDR_VAR 0 4
46069: PUSH
46070: LD_VAR 0 1
46074: PUSH
46075: FOR_IN
46076: IFFALSE 46110
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
46078: LD_ADDR_VAR 0 5
46082: PUSH
46083: LD_VAR 0 5
46087: PPUSH
46088: LD_VAR 0 4
46092: PPUSH
46093: LD_VAR 0 2
46097: PPUSH
46098: CALL_OW 259
46102: PPUSH
46103: CALL 47514 0 2
46107: ST_TO_ADDR
46108: GO 46075
46110: POP
46111: POP
// if not tmp then
46112: LD_VAR 0 5
46116: NOT
46117: IFFALSE 46121
// exit ;
46119: GO 46141
// result := SortListByListDesc ( units , tmp ) ;
46121: LD_ADDR_VAR 0 3
46125: PUSH
46126: LD_VAR 0 1
46130: PPUSH
46131: LD_VAR 0 5
46135: PPUSH
46136: CALL_OW 77
46140: ST_TO_ADDR
// end ;
46141: LD_VAR 0 3
46145: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
46146: LD_INT 0
46148: PPUSH
46149: PPUSH
46150: PPUSH
// result := false ;
46151: LD_ADDR_VAR 0 3
46155: PUSH
46156: LD_INT 0
46158: ST_TO_ADDR
// if not building then
46159: LD_VAR 0 2
46163: NOT
46164: IFFALSE 46168
// exit ;
46166: GO 46306
// x := GetX ( building ) ;
46168: LD_ADDR_VAR 0 4
46172: PUSH
46173: LD_VAR 0 2
46177: PPUSH
46178: CALL_OW 250
46182: ST_TO_ADDR
// y := GetY ( building ) ;
46183: LD_ADDR_VAR 0 5
46187: PUSH
46188: LD_VAR 0 2
46192: PPUSH
46193: CALL_OW 251
46197: ST_TO_ADDR
// if not x or not y then
46198: LD_VAR 0 4
46202: NOT
46203: PUSH
46204: LD_VAR 0 5
46208: NOT
46209: OR
46210: IFFALSE 46214
// exit ;
46212: GO 46306
// if GetTaskList ( unit ) then
46214: LD_VAR 0 1
46218: PPUSH
46219: CALL_OW 437
46223: IFFALSE 46306
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46225: LD_STRING e
46227: PUSH
46228: LD_VAR 0 1
46232: PPUSH
46233: CALL_OW 437
46237: PUSH
46238: LD_INT 1
46240: ARRAY
46241: PUSH
46242: LD_INT 1
46244: ARRAY
46245: EQUAL
46246: PUSH
46247: LD_VAR 0 4
46251: PUSH
46252: LD_VAR 0 1
46256: PPUSH
46257: CALL_OW 437
46261: PUSH
46262: LD_INT 1
46264: ARRAY
46265: PUSH
46266: LD_INT 2
46268: ARRAY
46269: EQUAL
46270: AND
46271: PUSH
46272: LD_VAR 0 5
46276: PUSH
46277: LD_VAR 0 1
46281: PPUSH
46282: CALL_OW 437
46286: PUSH
46287: LD_INT 1
46289: ARRAY
46290: PUSH
46291: LD_INT 3
46293: ARRAY
46294: EQUAL
46295: AND
46296: IFFALSE 46306
// result := true end ;
46298: LD_ADDR_VAR 0 3
46302: PUSH
46303: LD_INT 1
46305: ST_TO_ADDR
// end ;
46306: LD_VAR 0 3
46310: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46311: LD_INT 0
46313: PPUSH
// result := false ;
46314: LD_ADDR_VAR 0 4
46318: PUSH
46319: LD_INT 0
46321: ST_TO_ADDR
// if GetTaskList ( unit ) then
46322: LD_VAR 0 1
46326: PPUSH
46327: CALL_OW 437
46331: IFFALSE 46414
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46333: LD_STRING M
46335: PUSH
46336: LD_VAR 0 1
46340: PPUSH
46341: CALL_OW 437
46345: PUSH
46346: LD_INT 1
46348: ARRAY
46349: PUSH
46350: LD_INT 1
46352: ARRAY
46353: EQUAL
46354: PUSH
46355: LD_VAR 0 2
46359: PUSH
46360: LD_VAR 0 1
46364: PPUSH
46365: CALL_OW 437
46369: PUSH
46370: LD_INT 1
46372: ARRAY
46373: PUSH
46374: LD_INT 2
46376: ARRAY
46377: EQUAL
46378: AND
46379: PUSH
46380: LD_VAR 0 3
46384: PUSH
46385: LD_VAR 0 1
46389: PPUSH
46390: CALL_OW 437
46394: PUSH
46395: LD_INT 1
46397: ARRAY
46398: PUSH
46399: LD_INT 3
46401: ARRAY
46402: EQUAL
46403: AND
46404: IFFALSE 46414
// result := true ;
46406: LD_ADDR_VAR 0 4
46410: PUSH
46411: LD_INT 1
46413: ST_TO_ADDR
// end ; end ;
46414: LD_VAR 0 4
46418: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46419: LD_INT 0
46421: PPUSH
46422: PPUSH
46423: PPUSH
46424: PPUSH
// if not unit or not area then
46425: LD_VAR 0 1
46429: NOT
46430: PUSH
46431: LD_VAR 0 2
46435: NOT
46436: OR
46437: IFFALSE 46441
// exit ;
46439: GO 46617
// tmp := AreaToList ( area , i ) ;
46441: LD_ADDR_VAR 0 6
46445: PUSH
46446: LD_VAR 0 2
46450: PPUSH
46451: LD_VAR 0 5
46455: PPUSH
46456: CALL_OW 517
46460: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46461: LD_ADDR_VAR 0 5
46465: PUSH
46466: DOUBLE
46467: LD_INT 1
46469: DEC
46470: ST_TO_ADDR
46471: LD_VAR 0 6
46475: PUSH
46476: LD_INT 1
46478: ARRAY
46479: PUSH
46480: FOR_TO
46481: IFFALSE 46615
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46483: LD_ADDR_VAR 0 7
46487: PUSH
46488: LD_VAR 0 6
46492: PUSH
46493: LD_INT 1
46495: ARRAY
46496: PUSH
46497: LD_VAR 0 5
46501: ARRAY
46502: PUSH
46503: LD_VAR 0 6
46507: PUSH
46508: LD_INT 2
46510: ARRAY
46511: PUSH
46512: LD_VAR 0 5
46516: ARRAY
46517: PUSH
46518: EMPTY
46519: LIST
46520: LIST
46521: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
46522: LD_INT 92
46524: PUSH
46525: LD_VAR 0 7
46529: PUSH
46530: LD_INT 1
46532: ARRAY
46533: PUSH
46534: LD_VAR 0 7
46538: PUSH
46539: LD_INT 2
46541: ARRAY
46542: PUSH
46543: LD_INT 2
46545: PUSH
46546: EMPTY
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: PPUSH
46552: CALL_OW 69
46556: PUSH
46557: LD_INT 0
46559: EQUAL
46560: IFFALSE 46613
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46562: LD_VAR 0 1
46566: PPUSH
46567: LD_VAR 0 7
46571: PUSH
46572: LD_INT 1
46574: ARRAY
46575: PPUSH
46576: LD_VAR 0 7
46580: PUSH
46581: LD_INT 2
46583: ARRAY
46584: PPUSH
46585: LD_VAR 0 3
46589: PPUSH
46590: CALL_OW 48
// result := IsPlaced ( unit ) ;
46594: LD_ADDR_VAR 0 4
46598: PUSH
46599: LD_VAR 0 1
46603: PPUSH
46604: CALL_OW 305
46608: ST_TO_ADDR
// exit ;
46609: POP
46610: POP
46611: GO 46617
// end ; end ;
46613: GO 46480
46615: POP
46616: POP
// end ;
46617: LD_VAR 0 4
46621: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46622: LD_INT 0
46624: PPUSH
46625: PPUSH
46626: PPUSH
// if not side or side > 8 then
46627: LD_VAR 0 1
46631: NOT
46632: PUSH
46633: LD_VAR 0 1
46637: PUSH
46638: LD_INT 8
46640: GREATER
46641: OR
46642: IFFALSE 46646
// exit ;
46644: GO 46833
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46646: LD_ADDR_VAR 0 4
46650: PUSH
46651: LD_INT 22
46653: PUSH
46654: LD_VAR 0 1
46658: PUSH
46659: EMPTY
46660: LIST
46661: LIST
46662: PUSH
46663: LD_INT 21
46665: PUSH
46666: LD_INT 3
46668: PUSH
46669: EMPTY
46670: LIST
46671: LIST
46672: PUSH
46673: EMPTY
46674: LIST
46675: LIST
46676: PPUSH
46677: CALL_OW 69
46681: ST_TO_ADDR
// if not tmp then
46682: LD_VAR 0 4
46686: NOT
46687: IFFALSE 46691
// exit ;
46689: GO 46833
// enable_addtolog := true ;
46691: LD_ADDR_OWVAR 81
46695: PUSH
46696: LD_INT 1
46698: ST_TO_ADDR
// AddToLog ( [ ) ;
46699: LD_STRING [
46701: PPUSH
46702: CALL_OW 561
// for i in tmp do
46706: LD_ADDR_VAR 0 3
46710: PUSH
46711: LD_VAR 0 4
46715: PUSH
46716: FOR_IN
46717: IFFALSE 46824
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46719: LD_STRING [
46721: PUSH
46722: LD_VAR 0 3
46726: PPUSH
46727: CALL_OW 266
46731: STR
46732: PUSH
46733: LD_STRING , 
46735: STR
46736: PUSH
46737: LD_VAR 0 3
46741: PPUSH
46742: CALL_OW 250
46746: STR
46747: PUSH
46748: LD_STRING , 
46750: STR
46751: PUSH
46752: LD_VAR 0 3
46756: PPUSH
46757: CALL_OW 251
46761: STR
46762: PUSH
46763: LD_STRING , 
46765: STR
46766: PUSH
46767: LD_VAR 0 3
46771: PPUSH
46772: CALL_OW 254
46776: STR
46777: PUSH
46778: LD_STRING , 
46780: STR
46781: PUSH
46782: LD_VAR 0 3
46786: PPUSH
46787: LD_INT 1
46789: PPUSH
46790: CALL_OW 268
46794: STR
46795: PUSH
46796: LD_STRING , 
46798: STR
46799: PUSH
46800: LD_VAR 0 3
46804: PPUSH
46805: LD_INT 2
46807: PPUSH
46808: CALL_OW 268
46812: STR
46813: PUSH
46814: LD_STRING ],
46816: STR
46817: PPUSH
46818: CALL_OW 561
// end ;
46822: GO 46716
46824: POP
46825: POP
// AddToLog ( ]; ) ;
46826: LD_STRING ];
46828: PPUSH
46829: CALL_OW 561
// end ;
46833: LD_VAR 0 2
46837: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46838: LD_INT 0
46840: PPUSH
46841: PPUSH
46842: PPUSH
46843: PPUSH
46844: PPUSH
// if not area or not rate or not max then
46845: LD_VAR 0 1
46849: NOT
46850: PUSH
46851: LD_VAR 0 2
46855: NOT
46856: OR
46857: PUSH
46858: LD_VAR 0 4
46862: NOT
46863: OR
46864: IFFALSE 46868
// exit ;
46866: GO 47057
// while 1 do
46868: LD_INT 1
46870: IFFALSE 47057
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46872: LD_ADDR_VAR 0 9
46876: PUSH
46877: LD_VAR 0 1
46881: PPUSH
46882: LD_INT 1
46884: PPUSH
46885: CALL_OW 287
46889: PUSH
46890: LD_INT 10
46892: MUL
46893: ST_TO_ADDR
// r := rate / 10 ;
46894: LD_ADDR_VAR 0 7
46898: PUSH
46899: LD_VAR 0 2
46903: PUSH
46904: LD_INT 10
46906: DIVREAL
46907: ST_TO_ADDR
// time := 1 1$00 ;
46908: LD_ADDR_VAR 0 8
46912: PUSH
46913: LD_INT 2100
46915: ST_TO_ADDR
// if amount < min then
46916: LD_VAR 0 9
46920: PUSH
46921: LD_VAR 0 3
46925: LESS
46926: IFFALSE 46944
// r := r * 2 else
46928: LD_ADDR_VAR 0 7
46932: PUSH
46933: LD_VAR 0 7
46937: PUSH
46938: LD_INT 2
46940: MUL
46941: ST_TO_ADDR
46942: GO 46970
// if amount > max then
46944: LD_VAR 0 9
46948: PUSH
46949: LD_VAR 0 4
46953: GREATER
46954: IFFALSE 46970
// r := r / 2 ;
46956: LD_ADDR_VAR 0 7
46960: PUSH
46961: LD_VAR 0 7
46965: PUSH
46966: LD_INT 2
46968: DIVREAL
46969: ST_TO_ADDR
// time := time / r ;
46970: LD_ADDR_VAR 0 8
46974: PUSH
46975: LD_VAR 0 8
46979: PUSH
46980: LD_VAR 0 7
46984: DIVREAL
46985: ST_TO_ADDR
// if time < 0 then
46986: LD_VAR 0 8
46990: PUSH
46991: LD_INT 0
46993: LESS
46994: IFFALSE 47011
// time := time * - 1 ;
46996: LD_ADDR_VAR 0 8
47000: PUSH
47001: LD_VAR 0 8
47005: PUSH
47006: LD_INT 1
47008: NEG
47009: MUL
47010: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
47011: LD_VAR 0 8
47015: PUSH
47016: LD_INT 35
47018: PPUSH
47019: LD_INT 875
47021: PPUSH
47022: CALL_OW 12
47026: PLUS
47027: PPUSH
47028: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47032: LD_INT 1
47034: PPUSH
47035: LD_INT 5
47037: PPUSH
47038: CALL_OW 12
47042: PPUSH
47043: LD_VAR 0 1
47047: PPUSH
47048: LD_INT 1
47050: PPUSH
47051: CALL_OW 55
// end ;
47055: GO 46868
// end ;
47057: LD_VAR 0 5
47061: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47062: LD_INT 0
47064: PPUSH
47065: PPUSH
47066: PPUSH
47067: PPUSH
47068: PPUSH
47069: PPUSH
47070: PPUSH
47071: PPUSH
// if not turrets or not factories then
47072: LD_VAR 0 1
47076: NOT
47077: PUSH
47078: LD_VAR 0 2
47082: NOT
47083: OR
47084: IFFALSE 47088
// exit ;
47086: GO 47395
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
47088: LD_ADDR_VAR 0 10
47092: PUSH
47093: LD_INT 5
47095: PUSH
47096: LD_INT 6
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: LD_INT 2
47105: PUSH
47106: LD_INT 4
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 3
47115: PUSH
47116: LD_INT 5
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: LIST
47127: PUSH
47128: LD_INT 24
47130: PUSH
47131: LD_INT 25
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PUSH
47138: LD_INT 23
47140: PUSH
47141: LD_INT 27
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: LD_INT 42
47154: PUSH
47155: LD_INT 43
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: PUSH
47162: LD_INT 44
47164: PUSH
47165: LD_INT 46
47167: PUSH
47168: EMPTY
47169: LIST
47170: LIST
47171: PUSH
47172: LD_INT 45
47174: PUSH
47175: LD_INT 47
47177: PUSH
47178: EMPTY
47179: LIST
47180: LIST
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: LIST
47186: PUSH
47187: EMPTY
47188: LIST
47189: LIST
47190: LIST
47191: ST_TO_ADDR
// result := [ ] ;
47192: LD_ADDR_VAR 0 3
47196: PUSH
47197: EMPTY
47198: ST_TO_ADDR
// for i in turrets do
47199: LD_ADDR_VAR 0 4
47203: PUSH
47204: LD_VAR 0 1
47208: PUSH
47209: FOR_IN
47210: IFFALSE 47393
// begin nat := GetNation ( i ) ;
47212: LD_ADDR_VAR 0 7
47216: PUSH
47217: LD_VAR 0 4
47221: PPUSH
47222: CALL_OW 248
47226: ST_TO_ADDR
// weapon := 0 ;
47227: LD_ADDR_VAR 0 8
47231: PUSH
47232: LD_INT 0
47234: ST_TO_ADDR
// if not nat then
47235: LD_VAR 0 7
47239: NOT
47240: IFFALSE 47244
// continue ;
47242: GO 47209
// for j in list [ nat ] do
47244: LD_ADDR_VAR 0 5
47248: PUSH
47249: LD_VAR 0 10
47253: PUSH
47254: LD_VAR 0 7
47258: ARRAY
47259: PUSH
47260: FOR_IN
47261: IFFALSE 47302
// if GetBWeapon ( i ) = j [ 1 ] then
47263: LD_VAR 0 4
47267: PPUSH
47268: CALL_OW 269
47272: PUSH
47273: LD_VAR 0 5
47277: PUSH
47278: LD_INT 1
47280: ARRAY
47281: EQUAL
47282: IFFALSE 47300
// begin weapon := j [ 2 ] ;
47284: LD_ADDR_VAR 0 8
47288: PUSH
47289: LD_VAR 0 5
47293: PUSH
47294: LD_INT 2
47296: ARRAY
47297: ST_TO_ADDR
// break ;
47298: GO 47302
// end ;
47300: GO 47260
47302: POP
47303: POP
// if not weapon then
47304: LD_VAR 0 8
47308: NOT
47309: IFFALSE 47313
// continue ;
47311: GO 47209
// for k in factories do
47313: LD_ADDR_VAR 0 6
47317: PUSH
47318: LD_VAR 0 2
47322: PUSH
47323: FOR_IN
47324: IFFALSE 47389
// begin weapons := AvailableWeaponList ( k ) ;
47326: LD_ADDR_VAR 0 9
47330: PUSH
47331: LD_VAR 0 6
47335: PPUSH
47336: CALL_OW 478
47340: ST_TO_ADDR
// if not weapons then
47341: LD_VAR 0 9
47345: NOT
47346: IFFALSE 47350
// continue ;
47348: GO 47323
// if weapon in weapons then
47350: LD_VAR 0 8
47354: PUSH
47355: LD_VAR 0 9
47359: IN
47360: IFFALSE 47387
// begin result := [ i , weapon ] ;
47362: LD_ADDR_VAR 0 3
47366: PUSH
47367: LD_VAR 0 4
47371: PUSH
47372: LD_VAR 0 8
47376: PUSH
47377: EMPTY
47378: LIST
47379: LIST
47380: ST_TO_ADDR
// exit ;
47381: POP
47382: POP
47383: POP
47384: POP
47385: GO 47395
// end ; end ;
47387: GO 47323
47389: POP
47390: POP
// end ;
47391: GO 47209
47393: POP
47394: POP
// end ;
47395: LD_VAR 0 3
47399: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47400: LD_INT 0
47402: PPUSH
// if not side or side > 8 then
47403: LD_VAR 0 3
47407: NOT
47408: PUSH
47409: LD_VAR 0 3
47413: PUSH
47414: LD_INT 8
47416: GREATER
47417: OR
47418: IFFALSE 47422
// exit ;
47420: GO 47481
// if not range then
47422: LD_VAR 0 4
47426: NOT
47427: IFFALSE 47438
// range := - 12 ;
47429: LD_ADDR_VAR 0 4
47433: PUSH
47434: LD_INT 12
47436: NEG
47437: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47438: LD_VAR 0 1
47442: PPUSH
47443: LD_VAR 0 2
47447: PPUSH
47448: LD_VAR 0 3
47452: PPUSH
47453: LD_VAR 0 4
47457: PPUSH
47458: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47462: LD_VAR 0 1
47466: PPUSH
47467: LD_VAR 0 2
47471: PPUSH
47472: LD_VAR 0 3
47476: PPUSH
47477: CALL_OW 331
// end ;
47481: LD_VAR 0 5
47485: RET
// export function Video ( mode ) ; begin
47486: LD_INT 0
47488: PPUSH
// ingame_video = mode ;
47489: LD_ADDR_OWVAR 52
47493: PUSH
47494: LD_VAR 0 1
47498: ST_TO_ADDR
// interface_hidden = mode ;
47499: LD_ADDR_OWVAR 54
47503: PUSH
47504: LD_VAR 0 1
47508: ST_TO_ADDR
// end ;
47509: LD_VAR 0 2
47513: RET
// export function Join ( array , element ) ; begin
47514: LD_INT 0
47516: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47517: LD_ADDR_VAR 0 3
47521: PUSH
47522: LD_VAR 0 1
47526: PPUSH
47527: LD_VAR 0 1
47531: PUSH
47532: LD_INT 1
47534: PLUS
47535: PPUSH
47536: LD_VAR 0 2
47540: PPUSH
47541: CALL_OW 1
47545: ST_TO_ADDR
// end ;
47546: LD_VAR 0 3
47550: RET
// export function JoinUnion ( array , element ) ; begin
47551: LD_INT 0
47553: PPUSH
// result := array union element ;
47554: LD_ADDR_VAR 0 3
47558: PUSH
47559: LD_VAR 0 1
47563: PUSH
47564: LD_VAR 0 2
47568: UNION
47569: ST_TO_ADDR
// end ;
47570: LD_VAR 0 3
47574: RET
// export function GetBehemoths ( side ) ; begin
47575: LD_INT 0
47577: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
47578: LD_ADDR_VAR 0 2
47582: PUSH
47583: LD_INT 22
47585: PUSH
47586: LD_VAR 0 1
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PUSH
47595: LD_INT 31
47597: PUSH
47598: LD_INT 25
47600: PUSH
47601: EMPTY
47602: LIST
47603: LIST
47604: PUSH
47605: EMPTY
47606: LIST
47607: LIST
47608: PPUSH
47609: CALL_OW 69
47613: ST_TO_ADDR
// end ;
47614: LD_VAR 0 2
47618: RET
// export function Shuffle ( array ) ; var i , index ; begin
47619: LD_INT 0
47621: PPUSH
47622: PPUSH
47623: PPUSH
// result := [ ] ;
47624: LD_ADDR_VAR 0 2
47628: PUSH
47629: EMPTY
47630: ST_TO_ADDR
// if not array then
47631: LD_VAR 0 1
47635: NOT
47636: IFFALSE 47640
// exit ;
47638: GO 47739
// Randomize ;
47640: CALL_OW 10
// for i = array downto 1 do
47644: LD_ADDR_VAR 0 3
47648: PUSH
47649: DOUBLE
47650: LD_VAR 0 1
47654: INC
47655: ST_TO_ADDR
47656: LD_INT 1
47658: PUSH
47659: FOR_DOWNTO
47660: IFFALSE 47737
// begin index := rand ( 1 , array ) ;
47662: LD_ADDR_VAR 0 4
47666: PUSH
47667: LD_INT 1
47669: PPUSH
47670: LD_VAR 0 1
47674: PPUSH
47675: CALL_OW 12
47679: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47680: LD_ADDR_VAR 0 2
47684: PUSH
47685: LD_VAR 0 2
47689: PPUSH
47690: LD_VAR 0 2
47694: PUSH
47695: LD_INT 1
47697: PLUS
47698: PPUSH
47699: LD_VAR 0 1
47703: PUSH
47704: LD_VAR 0 4
47708: ARRAY
47709: PPUSH
47710: CALL_OW 2
47714: ST_TO_ADDR
// array := Delete ( array , index ) ;
47715: LD_ADDR_VAR 0 1
47719: PUSH
47720: LD_VAR 0 1
47724: PPUSH
47725: LD_VAR 0 4
47729: PPUSH
47730: CALL_OW 3
47734: ST_TO_ADDR
// end ;
47735: GO 47659
47737: POP
47738: POP
// end ;
47739: LD_VAR 0 2
47743: RET
// export function GetBaseMaterials ( base ) ; begin
47744: LD_INT 0
47746: PPUSH
// result := [ 0 , 0 , 0 ] ;
47747: LD_ADDR_VAR 0 2
47751: PUSH
47752: LD_INT 0
47754: PUSH
47755: LD_INT 0
47757: PUSH
47758: LD_INT 0
47760: PUSH
47761: EMPTY
47762: LIST
47763: LIST
47764: LIST
47765: ST_TO_ADDR
// if not base then
47766: LD_VAR 0 1
47770: NOT
47771: IFFALSE 47775
// exit ;
47773: GO 47824
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47775: LD_ADDR_VAR 0 2
47779: PUSH
47780: LD_VAR 0 1
47784: PPUSH
47785: LD_INT 1
47787: PPUSH
47788: CALL_OW 275
47792: PUSH
47793: LD_VAR 0 1
47797: PPUSH
47798: LD_INT 2
47800: PPUSH
47801: CALL_OW 275
47805: PUSH
47806: LD_VAR 0 1
47810: PPUSH
47811: LD_INT 3
47813: PPUSH
47814: CALL_OW 275
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: LIST
47823: ST_TO_ADDR
// end ;
47824: LD_VAR 0 2
47828: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47829: LD_INT 0
47831: PPUSH
47832: PPUSH
// result := array ;
47833: LD_ADDR_VAR 0 3
47837: PUSH
47838: LD_VAR 0 1
47842: ST_TO_ADDR
// if size >= result then
47843: LD_VAR 0 2
47847: PUSH
47848: LD_VAR 0 3
47852: GREATEREQUAL
47853: IFFALSE 47857
// exit ;
47855: GO 47907
// if size then
47857: LD_VAR 0 2
47861: IFFALSE 47907
// for i := array downto size do
47863: LD_ADDR_VAR 0 4
47867: PUSH
47868: DOUBLE
47869: LD_VAR 0 1
47873: INC
47874: ST_TO_ADDR
47875: LD_VAR 0 2
47879: PUSH
47880: FOR_DOWNTO
47881: IFFALSE 47905
// result := Delete ( result , result ) ;
47883: LD_ADDR_VAR 0 3
47887: PUSH
47888: LD_VAR 0 3
47892: PPUSH
47893: LD_VAR 0 3
47897: PPUSH
47898: CALL_OW 3
47902: ST_TO_ADDR
47903: GO 47880
47905: POP
47906: POP
// end ;
47907: LD_VAR 0 3
47911: RET
// export function ComExit ( unit ) ; var tmp ; begin
47912: LD_INT 0
47914: PPUSH
47915: PPUSH
// if not IsInUnit ( unit ) then
47916: LD_VAR 0 1
47920: PPUSH
47921: CALL_OW 310
47925: NOT
47926: IFFALSE 47930
// exit ;
47928: GO 47990
// tmp := IsInUnit ( unit ) ;
47930: LD_ADDR_VAR 0 3
47934: PUSH
47935: LD_VAR 0 1
47939: PPUSH
47940: CALL_OW 310
47944: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47945: LD_VAR 0 3
47949: PPUSH
47950: CALL_OW 247
47954: PUSH
47955: LD_INT 2
47957: EQUAL
47958: IFFALSE 47971
// ComExitVehicle ( unit ) else
47960: LD_VAR 0 1
47964: PPUSH
47965: CALL_OW 121
47969: GO 47980
// ComExitBuilding ( unit ) ;
47971: LD_VAR 0 1
47975: PPUSH
47976: CALL_OW 122
// result := tmp ;
47980: LD_ADDR_VAR 0 2
47984: PUSH
47985: LD_VAR 0 3
47989: ST_TO_ADDR
// end ;
47990: LD_VAR 0 2
47994: RET
// export function ComExitAll ( units ) ; var i ; begin
47995: LD_INT 0
47997: PPUSH
47998: PPUSH
// if not units then
47999: LD_VAR 0 1
48003: NOT
48004: IFFALSE 48008
// exit ;
48006: GO 48034
// for i in units do
48008: LD_ADDR_VAR 0 3
48012: PUSH
48013: LD_VAR 0 1
48017: PUSH
48018: FOR_IN
48019: IFFALSE 48032
// ComExit ( i ) ;
48021: LD_VAR 0 3
48025: PPUSH
48026: CALL 47912 0 1
48030: GO 48018
48032: POP
48033: POP
// end ;
48034: LD_VAR 0 2
48038: RET
// export function ResetHc ; begin
48039: LD_INT 0
48041: PPUSH
// InitHc ;
48042: CALL_OW 19
// hc_importance := 0 ;
48046: LD_ADDR_OWVAR 32
48050: PUSH
48051: LD_INT 0
48053: ST_TO_ADDR
// end ;
48054: LD_VAR 0 1
48058: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48059: LD_INT 0
48061: PPUSH
48062: PPUSH
48063: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48064: LD_ADDR_VAR 0 6
48068: PUSH
48069: LD_VAR 0 1
48073: PUSH
48074: LD_VAR 0 3
48078: PLUS
48079: PUSH
48080: LD_INT 2
48082: DIV
48083: ST_TO_ADDR
// if _x < 0 then
48084: LD_VAR 0 6
48088: PUSH
48089: LD_INT 0
48091: LESS
48092: IFFALSE 48109
// _x := _x * - 1 ;
48094: LD_ADDR_VAR 0 6
48098: PUSH
48099: LD_VAR 0 6
48103: PUSH
48104: LD_INT 1
48106: NEG
48107: MUL
48108: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
48109: LD_ADDR_VAR 0 7
48113: PUSH
48114: LD_VAR 0 2
48118: PUSH
48119: LD_VAR 0 4
48123: PLUS
48124: PUSH
48125: LD_INT 2
48127: DIV
48128: ST_TO_ADDR
// if _y < 0 then
48129: LD_VAR 0 7
48133: PUSH
48134: LD_INT 0
48136: LESS
48137: IFFALSE 48154
// _y := _y * - 1 ;
48139: LD_ADDR_VAR 0 7
48143: PUSH
48144: LD_VAR 0 7
48148: PUSH
48149: LD_INT 1
48151: NEG
48152: MUL
48153: ST_TO_ADDR
// result := [ _x , _y ] ;
48154: LD_ADDR_VAR 0 5
48158: PUSH
48159: LD_VAR 0 6
48163: PUSH
48164: LD_VAR 0 7
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: ST_TO_ADDR
// end ;
48173: LD_VAR 0 5
48177: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
48178: LD_INT 0
48180: PPUSH
48181: PPUSH
48182: PPUSH
48183: PPUSH
// task := GetTaskList ( unit ) ;
48184: LD_ADDR_VAR 0 7
48188: PUSH
48189: LD_VAR 0 1
48193: PPUSH
48194: CALL_OW 437
48198: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
48199: LD_VAR 0 7
48203: NOT
48204: PUSH
48205: LD_VAR 0 1
48209: PPUSH
48210: LD_VAR 0 2
48214: PPUSH
48215: CALL_OW 308
48219: NOT
48220: AND
48221: IFFALSE 48225
// exit ;
48223: GO 48343
// if IsInArea ( unit , area ) then
48225: LD_VAR 0 1
48229: PPUSH
48230: LD_VAR 0 2
48234: PPUSH
48235: CALL_OW 308
48239: IFFALSE 48257
// begin ComMoveToArea ( unit , goAway ) ;
48241: LD_VAR 0 1
48245: PPUSH
48246: LD_VAR 0 3
48250: PPUSH
48251: CALL_OW 113
// exit ;
48255: GO 48343
// end ; if task [ 1 ] [ 1 ] <> M then
48257: LD_VAR 0 7
48261: PUSH
48262: LD_INT 1
48264: ARRAY
48265: PUSH
48266: LD_INT 1
48268: ARRAY
48269: PUSH
48270: LD_STRING M
48272: NONEQUAL
48273: IFFALSE 48277
// exit ;
48275: GO 48343
// x := task [ 1 ] [ 2 ] ;
48277: LD_ADDR_VAR 0 5
48281: PUSH
48282: LD_VAR 0 7
48286: PUSH
48287: LD_INT 1
48289: ARRAY
48290: PUSH
48291: LD_INT 2
48293: ARRAY
48294: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48295: LD_ADDR_VAR 0 6
48299: PUSH
48300: LD_VAR 0 7
48304: PUSH
48305: LD_INT 1
48307: ARRAY
48308: PUSH
48309: LD_INT 3
48311: ARRAY
48312: ST_TO_ADDR
// if InArea ( x , y , area ) then
48313: LD_VAR 0 5
48317: PPUSH
48318: LD_VAR 0 6
48322: PPUSH
48323: LD_VAR 0 2
48327: PPUSH
48328: CALL_OW 309
48332: IFFALSE 48343
// ComStop ( unit ) ;
48334: LD_VAR 0 1
48338: PPUSH
48339: CALL_OW 141
// end ;
48343: LD_VAR 0 4
48347: RET
// export function Abs ( value ) ; begin
48348: LD_INT 0
48350: PPUSH
// result := value ;
48351: LD_ADDR_VAR 0 2
48355: PUSH
48356: LD_VAR 0 1
48360: ST_TO_ADDR
// if value < 0 then
48361: LD_VAR 0 1
48365: PUSH
48366: LD_INT 0
48368: LESS
48369: IFFALSE 48386
// result := value * - 1 ;
48371: LD_ADDR_VAR 0 2
48375: PUSH
48376: LD_VAR 0 1
48380: PUSH
48381: LD_INT 1
48383: NEG
48384: MUL
48385: ST_TO_ADDR
// end ;
48386: LD_VAR 0 2
48390: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48391: LD_INT 0
48393: PPUSH
48394: PPUSH
48395: PPUSH
48396: PPUSH
48397: PPUSH
48398: PPUSH
48399: PPUSH
48400: PPUSH
// if not unit or not building then
48401: LD_VAR 0 1
48405: NOT
48406: PUSH
48407: LD_VAR 0 2
48411: NOT
48412: OR
48413: IFFALSE 48417
// exit ;
48415: GO 48643
// x := GetX ( building ) ;
48417: LD_ADDR_VAR 0 4
48421: PUSH
48422: LD_VAR 0 2
48426: PPUSH
48427: CALL_OW 250
48431: ST_TO_ADDR
// y := GetY ( building ) ;
48432: LD_ADDR_VAR 0 6
48436: PUSH
48437: LD_VAR 0 2
48441: PPUSH
48442: CALL_OW 251
48446: ST_TO_ADDR
// d := GetDir ( building ) ;
48447: LD_ADDR_VAR 0 8
48451: PUSH
48452: LD_VAR 0 2
48456: PPUSH
48457: CALL_OW 254
48461: ST_TO_ADDR
// r := 4 ;
48462: LD_ADDR_VAR 0 9
48466: PUSH
48467: LD_INT 4
48469: ST_TO_ADDR
// for i := 1 to 5 do
48470: LD_ADDR_VAR 0 10
48474: PUSH
48475: DOUBLE
48476: LD_INT 1
48478: DEC
48479: ST_TO_ADDR
48480: LD_INT 5
48482: PUSH
48483: FOR_TO
48484: IFFALSE 48641
// begin _x := ShiftX ( x , d , r + i ) ;
48486: LD_ADDR_VAR 0 5
48490: PUSH
48491: LD_VAR 0 4
48495: PPUSH
48496: LD_VAR 0 8
48500: PPUSH
48501: LD_VAR 0 9
48505: PUSH
48506: LD_VAR 0 10
48510: PLUS
48511: PPUSH
48512: CALL_OW 272
48516: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48517: LD_ADDR_VAR 0 7
48521: PUSH
48522: LD_VAR 0 6
48526: PPUSH
48527: LD_VAR 0 8
48531: PPUSH
48532: LD_VAR 0 9
48536: PUSH
48537: LD_VAR 0 10
48541: PLUS
48542: PPUSH
48543: CALL_OW 273
48547: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48548: LD_VAR 0 5
48552: PPUSH
48553: LD_VAR 0 7
48557: PPUSH
48558: CALL_OW 488
48562: PUSH
48563: LD_VAR 0 5
48567: PPUSH
48568: LD_VAR 0 7
48572: PPUSH
48573: CALL_OW 428
48577: PPUSH
48578: CALL_OW 247
48582: PUSH
48583: LD_INT 3
48585: PUSH
48586: LD_INT 2
48588: PUSH
48589: EMPTY
48590: LIST
48591: LIST
48592: IN
48593: NOT
48594: AND
48595: IFFALSE 48639
// begin ComMoveXY ( unit , _x , _y ) ;
48597: LD_VAR 0 1
48601: PPUSH
48602: LD_VAR 0 5
48606: PPUSH
48607: LD_VAR 0 7
48611: PPUSH
48612: CALL_OW 111
// result := [ _x , _y ] ;
48616: LD_ADDR_VAR 0 3
48620: PUSH
48621: LD_VAR 0 5
48625: PUSH
48626: LD_VAR 0 7
48630: PUSH
48631: EMPTY
48632: LIST
48633: LIST
48634: ST_TO_ADDR
// exit ;
48635: POP
48636: POP
48637: GO 48643
// end ; end ;
48639: GO 48483
48641: POP
48642: POP
// end ;
48643: LD_VAR 0 3
48647: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48648: LD_INT 0
48650: PPUSH
48651: PPUSH
48652: PPUSH
// result := 0 ;
48653: LD_ADDR_VAR 0 3
48657: PUSH
48658: LD_INT 0
48660: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48661: LD_VAR 0 1
48665: PUSH
48666: LD_INT 0
48668: LESS
48669: PUSH
48670: LD_VAR 0 1
48674: PUSH
48675: LD_INT 8
48677: GREATER
48678: OR
48679: PUSH
48680: LD_VAR 0 2
48684: PUSH
48685: LD_INT 0
48687: LESS
48688: OR
48689: PUSH
48690: LD_VAR 0 2
48694: PUSH
48695: LD_INT 8
48697: GREATER
48698: OR
48699: IFFALSE 48703
// exit ;
48701: GO 48778
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48703: LD_ADDR_VAR 0 4
48707: PUSH
48708: LD_INT 22
48710: PUSH
48711: LD_VAR 0 2
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: PPUSH
48720: CALL_OW 69
48724: PUSH
48725: FOR_IN
48726: IFFALSE 48776
// begin un := UnitShoot ( i ) ;
48728: LD_ADDR_VAR 0 5
48732: PUSH
48733: LD_VAR 0 4
48737: PPUSH
48738: CALL_OW 504
48742: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48743: LD_VAR 0 5
48747: PPUSH
48748: CALL_OW 255
48752: PUSH
48753: LD_VAR 0 1
48757: EQUAL
48758: IFFALSE 48774
// begin result := un ;
48760: LD_ADDR_VAR 0 3
48764: PUSH
48765: LD_VAR 0 5
48769: ST_TO_ADDR
// exit ;
48770: POP
48771: POP
48772: GO 48778
// end ; end ;
48774: GO 48725
48776: POP
48777: POP
// end ;
48778: LD_VAR 0 3
48782: RET
// export function GetCargoBay ( units ) ; begin
48783: LD_INT 0
48785: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48786: LD_ADDR_VAR 0 2
48790: PUSH
48791: LD_VAR 0 1
48795: PPUSH
48796: LD_INT 2
48798: PUSH
48799: LD_INT 34
48801: PUSH
48802: LD_INT 12
48804: PUSH
48805: EMPTY
48806: LIST
48807: LIST
48808: PUSH
48809: LD_INT 34
48811: PUSH
48812: LD_INT 51
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: PUSH
48819: LD_INT 34
48821: PUSH
48822: LD_INT 32
48824: PUSH
48825: EMPTY
48826: LIST
48827: LIST
48828: PUSH
48829: LD_INT 34
48831: PUSH
48832: LD_INT 89
48834: PUSH
48835: EMPTY
48836: LIST
48837: LIST
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: PPUSH
48846: CALL_OW 72
48850: ST_TO_ADDR
// end ;
48851: LD_VAR 0 2
48855: RET
// export function Negate ( value ) ; begin
48856: LD_INT 0
48858: PPUSH
// result := not value ;
48859: LD_ADDR_VAR 0 2
48863: PUSH
48864: LD_VAR 0 1
48868: NOT
48869: ST_TO_ADDR
// end ;
48870: LD_VAR 0 2
48874: RET
// export function Inc ( value ) ; begin
48875: LD_INT 0
48877: PPUSH
// result := value + 1 ;
48878: LD_ADDR_VAR 0 2
48882: PUSH
48883: LD_VAR 0 1
48887: PUSH
48888: LD_INT 1
48890: PLUS
48891: ST_TO_ADDR
// end ;
48892: LD_VAR 0 2
48896: RET
// export function Dec ( value ) ; begin
48897: LD_INT 0
48899: PPUSH
// result := value - 1 ;
48900: LD_ADDR_VAR 0 2
48904: PUSH
48905: LD_VAR 0 1
48909: PUSH
48910: LD_INT 1
48912: MINUS
48913: ST_TO_ADDR
// end ;
48914: LD_VAR 0 2
48918: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
48919: LD_INT 0
48921: PPUSH
48922: PPUSH
48923: PPUSH
48924: PPUSH
48925: PPUSH
48926: PPUSH
48927: PPUSH
48928: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
48929: LD_VAR 0 1
48933: PPUSH
48934: LD_VAR 0 2
48938: PPUSH
48939: CALL_OW 488
48943: NOT
48944: PUSH
48945: LD_VAR 0 3
48949: PPUSH
48950: LD_VAR 0 4
48954: PPUSH
48955: CALL_OW 488
48959: NOT
48960: OR
48961: IFFALSE 48974
// begin result := - 1 ;
48963: LD_ADDR_VAR 0 5
48967: PUSH
48968: LD_INT 1
48970: NEG
48971: ST_TO_ADDR
// exit ;
48972: GO 49209
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
48974: LD_ADDR_VAR 0 12
48978: PUSH
48979: LD_VAR 0 1
48983: PPUSH
48984: LD_VAR 0 2
48988: PPUSH
48989: LD_VAR 0 3
48993: PPUSH
48994: LD_VAR 0 4
48998: PPUSH
48999: CALL 48059 0 4
49003: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49004: LD_ADDR_VAR 0 11
49008: PUSH
49009: LD_VAR 0 1
49013: PPUSH
49014: LD_VAR 0 2
49018: PPUSH
49019: LD_VAR 0 12
49023: PUSH
49024: LD_INT 1
49026: ARRAY
49027: PPUSH
49028: LD_VAR 0 12
49032: PUSH
49033: LD_INT 2
49035: ARRAY
49036: PPUSH
49037: CALL_OW 298
49041: ST_TO_ADDR
// distance := 9999 ;
49042: LD_ADDR_VAR 0 10
49046: PUSH
49047: LD_INT 9999
49049: ST_TO_ADDR
// for i := 0 to 5 do
49050: LD_ADDR_VAR 0 6
49054: PUSH
49055: DOUBLE
49056: LD_INT 0
49058: DEC
49059: ST_TO_ADDR
49060: LD_INT 5
49062: PUSH
49063: FOR_TO
49064: IFFALSE 49207
// begin _x := ShiftX ( x1 , i , centerDist ) ;
49066: LD_ADDR_VAR 0 7
49070: PUSH
49071: LD_VAR 0 1
49075: PPUSH
49076: LD_VAR 0 6
49080: PPUSH
49081: LD_VAR 0 11
49085: PPUSH
49086: CALL_OW 272
49090: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
49091: LD_ADDR_VAR 0 8
49095: PUSH
49096: LD_VAR 0 2
49100: PPUSH
49101: LD_VAR 0 6
49105: PPUSH
49106: LD_VAR 0 11
49110: PPUSH
49111: CALL_OW 273
49115: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49116: LD_VAR 0 7
49120: PPUSH
49121: LD_VAR 0 8
49125: PPUSH
49126: CALL_OW 488
49130: NOT
49131: IFFALSE 49135
// continue ;
49133: GO 49063
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
49135: LD_ADDR_VAR 0 9
49139: PUSH
49140: LD_VAR 0 12
49144: PUSH
49145: LD_INT 1
49147: ARRAY
49148: PPUSH
49149: LD_VAR 0 12
49153: PUSH
49154: LD_INT 2
49156: ARRAY
49157: PPUSH
49158: LD_VAR 0 7
49162: PPUSH
49163: LD_VAR 0 8
49167: PPUSH
49168: CALL_OW 298
49172: ST_TO_ADDR
// if tmp < distance then
49173: LD_VAR 0 9
49177: PUSH
49178: LD_VAR 0 10
49182: LESS
49183: IFFALSE 49205
// begin result := i ;
49185: LD_ADDR_VAR 0 5
49189: PUSH
49190: LD_VAR 0 6
49194: ST_TO_ADDR
// distance := tmp ;
49195: LD_ADDR_VAR 0 10
49199: PUSH
49200: LD_VAR 0 9
49204: ST_TO_ADDR
// end ; end ;
49205: GO 49063
49207: POP
49208: POP
// end ;
49209: LD_VAR 0 5
49213: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49214: LD_INT 0
49216: PPUSH
49217: PPUSH
// if not driver or not IsInUnit ( driver ) then
49218: LD_VAR 0 1
49222: NOT
49223: PUSH
49224: LD_VAR 0 1
49228: PPUSH
49229: CALL_OW 310
49233: NOT
49234: OR
49235: IFFALSE 49239
// exit ;
49237: GO 49329
// vehicle := IsInUnit ( driver ) ;
49239: LD_ADDR_VAR 0 3
49243: PUSH
49244: LD_VAR 0 1
49248: PPUSH
49249: CALL_OW 310
49253: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49254: LD_VAR 0 1
49258: PPUSH
49259: LD_STRING \
49261: PUSH
49262: LD_INT 0
49264: PUSH
49265: LD_INT 0
49267: PUSH
49268: LD_INT 0
49270: PUSH
49271: LD_INT 0
49273: PUSH
49274: LD_INT 0
49276: PUSH
49277: LD_INT 0
49279: PUSH
49280: EMPTY
49281: LIST
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: LIST
49288: PUSH
49289: LD_STRING E
49291: PUSH
49292: LD_INT 0
49294: PUSH
49295: LD_INT 0
49297: PUSH
49298: LD_VAR 0 3
49302: PUSH
49303: LD_INT 0
49305: PUSH
49306: LD_INT 0
49308: PUSH
49309: LD_INT 0
49311: PUSH
49312: EMPTY
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: PUSH
49321: EMPTY
49322: LIST
49323: LIST
49324: PPUSH
49325: CALL_OW 446
// end ;
49329: LD_VAR 0 2
49333: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49334: LD_INT 0
49336: PPUSH
49337: PPUSH
// if not driver or not IsInUnit ( driver ) then
49338: LD_VAR 0 1
49342: NOT
49343: PUSH
49344: LD_VAR 0 1
49348: PPUSH
49349: CALL_OW 310
49353: NOT
49354: OR
49355: IFFALSE 49359
// exit ;
49357: GO 49449
// vehicle := IsInUnit ( driver ) ;
49359: LD_ADDR_VAR 0 3
49363: PUSH
49364: LD_VAR 0 1
49368: PPUSH
49369: CALL_OW 310
49373: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49374: LD_VAR 0 1
49378: PPUSH
49379: LD_STRING \
49381: PUSH
49382: LD_INT 0
49384: PUSH
49385: LD_INT 0
49387: PUSH
49388: LD_INT 0
49390: PUSH
49391: LD_INT 0
49393: PUSH
49394: LD_INT 0
49396: PUSH
49397: LD_INT 0
49399: PUSH
49400: EMPTY
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: PUSH
49409: LD_STRING E
49411: PUSH
49412: LD_INT 0
49414: PUSH
49415: LD_INT 0
49417: PUSH
49418: LD_VAR 0 3
49422: PUSH
49423: LD_INT 0
49425: PUSH
49426: LD_INT 0
49428: PUSH
49429: LD_INT 0
49431: PUSH
49432: EMPTY
49433: LIST
49434: LIST
49435: LIST
49436: LIST
49437: LIST
49438: LIST
49439: LIST
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PPUSH
49445: CALL_OW 447
// end ;
49449: LD_VAR 0 2
49453: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49454: LD_INT 0
49456: PPUSH
49457: PPUSH
49458: PPUSH
// tmp := [ ] ;
49459: LD_ADDR_VAR 0 5
49463: PUSH
49464: EMPTY
49465: ST_TO_ADDR
// for i in units do
49466: LD_ADDR_VAR 0 4
49470: PUSH
49471: LD_VAR 0 1
49475: PUSH
49476: FOR_IN
49477: IFFALSE 49515
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49479: LD_ADDR_VAR 0 5
49483: PUSH
49484: LD_VAR 0 5
49488: PPUSH
49489: LD_VAR 0 5
49493: PUSH
49494: LD_INT 1
49496: PLUS
49497: PPUSH
49498: LD_VAR 0 4
49502: PPUSH
49503: CALL_OW 256
49507: PPUSH
49508: CALL_OW 2
49512: ST_TO_ADDR
49513: GO 49476
49515: POP
49516: POP
// if not tmp then
49517: LD_VAR 0 5
49521: NOT
49522: IFFALSE 49526
// exit ;
49524: GO 49574
// if asc then
49526: LD_VAR 0 2
49530: IFFALSE 49554
// result := SortListByListAsc ( units , tmp ) else
49532: LD_ADDR_VAR 0 3
49536: PUSH
49537: LD_VAR 0 1
49541: PPUSH
49542: LD_VAR 0 5
49546: PPUSH
49547: CALL_OW 76
49551: ST_TO_ADDR
49552: GO 49574
// result := SortListByListDesc ( units , tmp ) ;
49554: LD_ADDR_VAR 0 3
49558: PUSH
49559: LD_VAR 0 1
49563: PPUSH
49564: LD_VAR 0 5
49568: PPUSH
49569: CALL_OW 77
49573: ST_TO_ADDR
// end ;
49574: LD_VAR 0 3
49578: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49579: LD_INT 0
49581: PPUSH
49582: PPUSH
// task := GetTaskList ( mech ) ;
49583: LD_ADDR_VAR 0 4
49587: PUSH
49588: LD_VAR 0 1
49592: PPUSH
49593: CALL_OW 437
49597: ST_TO_ADDR
// if not task then
49598: LD_VAR 0 4
49602: NOT
49603: IFFALSE 49607
// exit ;
49605: GO 49649
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49607: LD_ADDR_VAR 0 3
49611: PUSH
49612: LD_VAR 0 4
49616: PUSH
49617: LD_INT 1
49619: ARRAY
49620: PUSH
49621: LD_INT 1
49623: ARRAY
49624: PUSH
49625: LD_STRING r
49627: EQUAL
49628: PUSH
49629: LD_VAR 0 4
49633: PUSH
49634: LD_INT 1
49636: ARRAY
49637: PUSH
49638: LD_INT 4
49640: ARRAY
49641: PUSH
49642: LD_VAR 0 2
49646: EQUAL
49647: AND
49648: ST_TO_ADDR
// end ;
49649: LD_VAR 0 3
49653: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49654: LD_INT 0
49656: PPUSH
// SetDir ( unit , d ) ;
49657: LD_VAR 0 1
49661: PPUSH
49662: LD_VAR 0 4
49666: PPUSH
49667: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49671: LD_VAR 0 1
49675: PPUSH
49676: LD_VAR 0 2
49680: PPUSH
49681: LD_VAR 0 3
49685: PPUSH
49686: LD_VAR 0 5
49690: PPUSH
49691: CALL_OW 48
// end ;
49695: LD_VAR 0 6
49699: RET
// export function ToNaturalNumber ( number ) ; begin
49700: LD_INT 0
49702: PPUSH
// result := number div 1 ;
49703: LD_ADDR_VAR 0 2
49707: PUSH
49708: LD_VAR 0 1
49712: PUSH
49713: LD_INT 1
49715: DIV
49716: ST_TO_ADDR
// if number < 0 then
49717: LD_VAR 0 1
49721: PUSH
49722: LD_INT 0
49724: LESS
49725: IFFALSE 49735
// result := 0 ;
49727: LD_ADDR_VAR 0 2
49731: PUSH
49732: LD_INT 0
49734: ST_TO_ADDR
// end ;
49735: LD_VAR 0 2
49739: RET
// export function SortByClass ( units , class ) ; var un ; begin
49740: LD_INT 0
49742: PPUSH
49743: PPUSH
// if not units or not class then
49744: LD_VAR 0 1
49748: NOT
49749: PUSH
49750: LD_VAR 0 2
49754: NOT
49755: OR
49756: IFFALSE 49760
// exit ;
49758: GO 49855
// result := [ ] ;
49760: LD_ADDR_VAR 0 3
49764: PUSH
49765: EMPTY
49766: ST_TO_ADDR
// for un in units do
49767: LD_ADDR_VAR 0 4
49771: PUSH
49772: LD_VAR 0 1
49776: PUSH
49777: FOR_IN
49778: IFFALSE 49853
// if GetClass ( un ) = class then
49780: LD_VAR 0 4
49784: PPUSH
49785: CALL_OW 257
49789: PUSH
49790: LD_VAR 0 2
49794: EQUAL
49795: IFFALSE 49822
// result := Insert ( result , 1 , un ) else
49797: LD_ADDR_VAR 0 3
49801: PUSH
49802: LD_VAR 0 3
49806: PPUSH
49807: LD_INT 1
49809: PPUSH
49810: LD_VAR 0 4
49814: PPUSH
49815: CALL_OW 2
49819: ST_TO_ADDR
49820: GO 49851
// result := Replace ( result , result + 1 , un ) ;
49822: LD_ADDR_VAR 0 3
49826: PUSH
49827: LD_VAR 0 3
49831: PPUSH
49832: LD_VAR 0 3
49836: PUSH
49837: LD_INT 1
49839: PLUS
49840: PPUSH
49841: LD_VAR 0 4
49845: PPUSH
49846: CALL_OW 1
49850: ST_TO_ADDR
49851: GO 49777
49853: POP
49854: POP
// end ;
49855: LD_VAR 0 3
49859: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
49860: LD_INT 0
49862: PPUSH
49863: PPUSH
49864: PPUSH
49865: PPUSH
49866: PPUSH
49867: PPUSH
49868: PPUSH
// result := [ ] ;
49869: LD_ADDR_VAR 0 4
49873: PUSH
49874: EMPTY
49875: ST_TO_ADDR
// if x - r < 0 then
49876: LD_VAR 0 1
49880: PUSH
49881: LD_VAR 0 3
49885: MINUS
49886: PUSH
49887: LD_INT 0
49889: LESS
49890: IFFALSE 49902
// min_x := 0 else
49892: LD_ADDR_VAR 0 8
49896: PUSH
49897: LD_INT 0
49899: ST_TO_ADDR
49900: GO 49918
// min_x := x - r ;
49902: LD_ADDR_VAR 0 8
49906: PUSH
49907: LD_VAR 0 1
49911: PUSH
49912: LD_VAR 0 3
49916: MINUS
49917: ST_TO_ADDR
// if y - r < 0 then
49918: LD_VAR 0 2
49922: PUSH
49923: LD_VAR 0 3
49927: MINUS
49928: PUSH
49929: LD_INT 0
49931: LESS
49932: IFFALSE 49944
// min_y := 0 else
49934: LD_ADDR_VAR 0 7
49938: PUSH
49939: LD_INT 0
49941: ST_TO_ADDR
49942: GO 49960
// min_y := y - r ;
49944: LD_ADDR_VAR 0 7
49948: PUSH
49949: LD_VAR 0 2
49953: PUSH
49954: LD_VAR 0 3
49958: MINUS
49959: ST_TO_ADDR
// max_x := x + r ;
49960: LD_ADDR_VAR 0 9
49964: PUSH
49965: LD_VAR 0 1
49969: PUSH
49970: LD_VAR 0 3
49974: PLUS
49975: ST_TO_ADDR
// max_y := y + r ;
49976: LD_ADDR_VAR 0 10
49980: PUSH
49981: LD_VAR 0 2
49985: PUSH
49986: LD_VAR 0 3
49990: PLUS
49991: ST_TO_ADDR
// for _x = min_x to max_x do
49992: LD_ADDR_VAR 0 5
49996: PUSH
49997: DOUBLE
49998: LD_VAR 0 8
50002: DEC
50003: ST_TO_ADDR
50004: LD_VAR 0 9
50008: PUSH
50009: FOR_TO
50010: IFFALSE 50111
// for _y = min_y to max_y do
50012: LD_ADDR_VAR 0 6
50016: PUSH
50017: DOUBLE
50018: LD_VAR 0 7
50022: DEC
50023: ST_TO_ADDR
50024: LD_VAR 0 10
50028: PUSH
50029: FOR_TO
50030: IFFALSE 50107
// begin if not ValidHex ( _x , _y ) then
50032: LD_VAR 0 5
50036: PPUSH
50037: LD_VAR 0 6
50041: PPUSH
50042: CALL_OW 488
50046: NOT
50047: IFFALSE 50051
// continue ;
50049: GO 50029
// if GetResourceTypeXY ( _x , _y ) then
50051: LD_VAR 0 5
50055: PPUSH
50056: LD_VAR 0 6
50060: PPUSH
50061: CALL_OW 283
50065: IFFALSE 50105
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50067: LD_ADDR_VAR 0 4
50071: PUSH
50072: LD_VAR 0 4
50076: PPUSH
50077: LD_VAR 0 4
50081: PUSH
50082: LD_INT 1
50084: PLUS
50085: PPUSH
50086: LD_VAR 0 5
50090: PUSH
50091: LD_VAR 0 6
50095: PUSH
50096: EMPTY
50097: LIST
50098: LIST
50099: PPUSH
50100: CALL_OW 1
50104: ST_TO_ADDR
// end ;
50105: GO 50029
50107: POP
50108: POP
50109: GO 50009
50111: POP
50112: POP
// end ;
50113: LD_VAR 0 4
50117: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
50118: LD_INT 0
50120: PPUSH
50121: PPUSH
50122: PPUSH
50123: PPUSH
50124: PPUSH
50125: PPUSH
50126: PPUSH
50127: PPUSH
// if not units then
50128: LD_VAR 0 1
50132: NOT
50133: IFFALSE 50137
// exit ;
50135: GO 50661
// result := UnitFilter ( units , [ f_ok ] ) ;
50137: LD_ADDR_VAR 0 3
50141: PUSH
50142: LD_VAR 0 1
50146: PPUSH
50147: LD_INT 50
50149: PUSH
50150: EMPTY
50151: LIST
50152: PPUSH
50153: CALL_OW 72
50157: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
50158: LD_ADDR_VAR 0 8
50162: PUSH
50163: LD_VAR 0 1
50167: PUSH
50168: LD_INT 1
50170: ARRAY
50171: PPUSH
50172: CALL_OW 255
50176: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
50177: LD_ADDR_VAR 0 10
50181: PUSH
50182: LD_INT 29
50184: PUSH
50185: LD_INT 91
50187: PUSH
50188: LD_INT 49
50190: PUSH
50191: EMPTY
50192: LIST
50193: LIST
50194: LIST
50195: ST_TO_ADDR
// if not result then
50196: LD_VAR 0 3
50200: NOT
50201: IFFALSE 50205
// exit ;
50203: GO 50661
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
50205: LD_ADDR_VAR 0 5
50209: PUSH
50210: LD_INT 81
50212: PUSH
50213: LD_VAR 0 8
50217: PUSH
50218: EMPTY
50219: LIST
50220: LIST
50221: PPUSH
50222: CALL_OW 69
50226: ST_TO_ADDR
// for i in result do
50227: LD_ADDR_VAR 0 4
50231: PUSH
50232: LD_VAR 0 3
50236: PUSH
50237: FOR_IN
50238: IFFALSE 50659
// begin tag := GetTag ( i ) + 1 ;
50240: LD_ADDR_VAR 0 9
50244: PUSH
50245: LD_VAR 0 4
50249: PPUSH
50250: CALL_OW 110
50254: PUSH
50255: LD_INT 1
50257: PLUS
50258: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
50259: LD_ADDR_VAR 0 7
50263: PUSH
50264: LD_VAR 0 4
50268: PPUSH
50269: CALL_OW 250
50273: PPUSH
50274: LD_VAR 0 4
50278: PPUSH
50279: CALL_OW 251
50283: PPUSH
50284: LD_INT 6
50286: PPUSH
50287: CALL 49860 0 3
50291: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50292: LD_VAR 0 4
50296: PPUSH
50297: CALL_OW 247
50301: PUSH
50302: LD_INT 2
50304: EQUAL
50305: PUSH
50306: LD_VAR 0 7
50310: AND
50311: PUSH
50312: LD_VAR 0 4
50316: PPUSH
50317: CALL_OW 264
50321: PUSH
50322: LD_VAR 0 10
50326: IN
50327: NOT
50328: AND
50329: IFFALSE 50368
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50331: LD_VAR 0 4
50335: PPUSH
50336: LD_VAR 0 7
50340: PUSH
50341: LD_INT 1
50343: ARRAY
50344: PUSH
50345: LD_INT 1
50347: ARRAY
50348: PPUSH
50349: LD_VAR 0 7
50353: PUSH
50354: LD_INT 1
50356: ARRAY
50357: PUSH
50358: LD_INT 2
50360: ARRAY
50361: PPUSH
50362: CALL_OW 116
50366: GO 50657
// if path > tag then
50368: LD_VAR 0 2
50372: PUSH
50373: LD_VAR 0 9
50377: GREATER
50378: IFFALSE 50586
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
50380: LD_ADDR_VAR 0 6
50384: PUSH
50385: LD_VAR 0 5
50389: PPUSH
50390: LD_INT 91
50392: PUSH
50393: LD_VAR 0 4
50397: PUSH
50398: LD_INT 8
50400: PUSH
50401: EMPTY
50402: LIST
50403: LIST
50404: LIST
50405: PPUSH
50406: CALL_OW 72
50410: ST_TO_ADDR
// if nearEnemy then
50411: LD_VAR 0 6
50415: IFFALSE 50484
// begin if GetWeapon ( i ) = ru_time_lapser then
50417: LD_VAR 0 4
50421: PPUSH
50422: CALL_OW 264
50426: PUSH
50427: LD_INT 49
50429: EQUAL
50430: IFFALSE 50458
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50432: LD_VAR 0 4
50436: PPUSH
50437: LD_VAR 0 6
50441: PPUSH
50442: LD_VAR 0 4
50446: PPUSH
50447: CALL_OW 74
50451: PPUSH
50452: CALL_OW 112
50456: GO 50482
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
50458: LD_VAR 0 4
50462: PPUSH
50463: LD_VAR 0 6
50467: PPUSH
50468: LD_VAR 0 4
50472: PPUSH
50473: CALL_OW 74
50477: PPUSH
50478: CALL 51586 0 2
// end else
50482: GO 50584
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50484: LD_VAR 0 4
50488: PPUSH
50489: LD_VAR 0 2
50493: PUSH
50494: LD_VAR 0 9
50498: ARRAY
50499: PUSH
50500: LD_INT 1
50502: ARRAY
50503: PPUSH
50504: LD_VAR 0 2
50508: PUSH
50509: LD_VAR 0 9
50513: ARRAY
50514: PUSH
50515: LD_INT 2
50517: ARRAY
50518: PPUSH
50519: CALL_OW 297
50523: PUSH
50524: LD_INT 6
50526: GREATER
50527: IFFALSE 50570
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50529: LD_VAR 0 4
50533: PPUSH
50534: LD_VAR 0 2
50538: PUSH
50539: LD_VAR 0 9
50543: ARRAY
50544: PUSH
50545: LD_INT 1
50547: ARRAY
50548: PPUSH
50549: LD_VAR 0 2
50553: PUSH
50554: LD_VAR 0 9
50558: ARRAY
50559: PUSH
50560: LD_INT 2
50562: ARRAY
50563: PPUSH
50564: CALL_OW 114
50568: GO 50584
// SetTag ( i , tag ) ;
50570: LD_VAR 0 4
50574: PPUSH
50575: LD_VAR 0 9
50579: PPUSH
50580: CALL_OW 109
// end else
50584: GO 50657
// if enemy then
50586: LD_VAR 0 5
50590: IFFALSE 50657
// begin if GetWeapon ( i ) = ru_time_lapser then
50592: LD_VAR 0 4
50596: PPUSH
50597: CALL_OW 264
50601: PUSH
50602: LD_INT 49
50604: EQUAL
50605: IFFALSE 50633
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
50607: LD_VAR 0 4
50611: PPUSH
50612: LD_VAR 0 5
50616: PPUSH
50617: LD_VAR 0 4
50621: PPUSH
50622: CALL_OW 74
50626: PPUSH
50627: CALL_OW 112
50631: GO 50657
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50633: LD_VAR 0 4
50637: PPUSH
50638: LD_VAR 0 5
50642: PPUSH
50643: LD_VAR 0 4
50647: PPUSH
50648: CALL_OW 74
50652: PPUSH
50653: CALL 51586 0 2
// end ; end ;
50657: GO 50237
50659: POP
50660: POP
// end ;
50661: LD_VAR 0 3
50665: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50666: LD_INT 0
50668: PPUSH
50669: PPUSH
50670: PPUSH
// if not unit or IsInUnit ( unit ) then
50671: LD_VAR 0 1
50675: NOT
50676: PUSH
50677: LD_VAR 0 1
50681: PPUSH
50682: CALL_OW 310
50686: OR
50687: IFFALSE 50691
// exit ;
50689: GO 50782
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50691: LD_ADDR_VAR 0 4
50695: PUSH
50696: LD_VAR 0 1
50700: PPUSH
50701: CALL_OW 250
50705: PPUSH
50706: LD_VAR 0 2
50710: PPUSH
50711: LD_INT 1
50713: PPUSH
50714: CALL_OW 272
50718: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50719: LD_ADDR_VAR 0 5
50723: PUSH
50724: LD_VAR 0 1
50728: PPUSH
50729: CALL_OW 251
50733: PPUSH
50734: LD_VAR 0 2
50738: PPUSH
50739: LD_INT 1
50741: PPUSH
50742: CALL_OW 273
50746: ST_TO_ADDR
// if ValidHex ( x , y ) then
50747: LD_VAR 0 4
50751: PPUSH
50752: LD_VAR 0 5
50756: PPUSH
50757: CALL_OW 488
50761: IFFALSE 50782
// ComTurnXY ( unit , x , y ) ;
50763: LD_VAR 0 1
50767: PPUSH
50768: LD_VAR 0 4
50772: PPUSH
50773: LD_VAR 0 5
50777: PPUSH
50778: CALL_OW 118
// end ;
50782: LD_VAR 0 3
50786: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50787: LD_INT 0
50789: PPUSH
50790: PPUSH
// result := false ;
50791: LD_ADDR_VAR 0 3
50795: PUSH
50796: LD_INT 0
50798: ST_TO_ADDR
// if not units then
50799: LD_VAR 0 2
50803: NOT
50804: IFFALSE 50808
// exit ;
50806: GO 50853
// for i in units do
50808: LD_ADDR_VAR 0 4
50812: PUSH
50813: LD_VAR 0 2
50817: PUSH
50818: FOR_IN
50819: IFFALSE 50851
// if See ( side , i ) then
50821: LD_VAR 0 1
50825: PPUSH
50826: LD_VAR 0 4
50830: PPUSH
50831: CALL_OW 292
50835: IFFALSE 50849
// begin result := true ;
50837: LD_ADDR_VAR 0 3
50841: PUSH
50842: LD_INT 1
50844: ST_TO_ADDR
// exit ;
50845: POP
50846: POP
50847: GO 50853
// end ;
50849: GO 50818
50851: POP
50852: POP
// end ;
50853: LD_VAR 0 3
50857: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50858: LD_INT 0
50860: PPUSH
50861: PPUSH
50862: PPUSH
50863: PPUSH
// if not unit or not points then
50864: LD_VAR 0 1
50868: NOT
50869: PUSH
50870: LD_VAR 0 2
50874: NOT
50875: OR
50876: IFFALSE 50880
// exit ;
50878: GO 50970
// dist := 99999 ;
50880: LD_ADDR_VAR 0 5
50884: PUSH
50885: LD_INT 99999
50887: ST_TO_ADDR
// for i in points do
50888: LD_ADDR_VAR 0 4
50892: PUSH
50893: LD_VAR 0 2
50897: PUSH
50898: FOR_IN
50899: IFFALSE 50968
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
50901: LD_ADDR_VAR 0 6
50905: PUSH
50906: LD_VAR 0 1
50910: PPUSH
50911: LD_VAR 0 4
50915: PUSH
50916: LD_INT 1
50918: ARRAY
50919: PPUSH
50920: LD_VAR 0 4
50924: PUSH
50925: LD_INT 2
50927: ARRAY
50928: PPUSH
50929: CALL_OW 297
50933: ST_TO_ADDR
// if tmpDist < dist then
50934: LD_VAR 0 6
50938: PUSH
50939: LD_VAR 0 5
50943: LESS
50944: IFFALSE 50966
// begin result := i ;
50946: LD_ADDR_VAR 0 3
50950: PUSH
50951: LD_VAR 0 4
50955: ST_TO_ADDR
// dist := tmpDist ;
50956: LD_ADDR_VAR 0 5
50960: PUSH
50961: LD_VAR 0 6
50965: ST_TO_ADDR
// end ; end ;
50966: GO 50898
50968: POP
50969: POP
// end ;
50970: LD_VAR 0 3
50974: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
50975: LD_INT 0
50977: PPUSH
// uc_side := side ;
50978: LD_ADDR_OWVAR 20
50982: PUSH
50983: LD_VAR 0 1
50987: ST_TO_ADDR
// uc_nation := 3 ;
50988: LD_ADDR_OWVAR 21
50992: PUSH
50993: LD_INT 3
50995: ST_TO_ADDR
// vc_chassis := 25 ;
50996: LD_ADDR_OWVAR 37
51000: PUSH
51001: LD_INT 25
51003: ST_TO_ADDR
// vc_engine := engine_siberite ;
51004: LD_ADDR_OWVAR 39
51008: PUSH
51009: LD_INT 3
51011: ST_TO_ADDR
// vc_control := control_computer ;
51012: LD_ADDR_OWVAR 38
51016: PUSH
51017: LD_INT 3
51019: ST_TO_ADDR
// vc_weapon := 59 ;
51020: LD_ADDR_OWVAR 40
51024: PUSH
51025: LD_INT 59
51027: ST_TO_ADDR
// result := CreateVehicle ;
51028: LD_ADDR_VAR 0 5
51032: PUSH
51033: CALL_OW 45
51037: ST_TO_ADDR
// SetDir ( result , d ) ;
51038: LD_VAR 0 5
51042: PPUSH
51043: LD_VAR 0 4
51047: PPUSH
51048: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
51052: LD_VAR 0 5
51056: PPUSH
51057: LD_VAR 0 2
51061: PPUSH
51062: LD_VAR 0 3
51066: PPUSH
51067: LD_INT 0
51069: PPUSH
51070: CALL_OW 48
// end ;
51074: LD_VAR 0 5
51078: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
51079: LD_INT 0
51081: PPUSH
51082: PPUSH
51083: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
51084: LD_ADDR_VAR 0 2
51088: PUSH
51089: LD_INT 0
51091: PUSH
51092: LD_INT 0
51094: PUSH
51095: LD_INT 0
51097: PUSH
51098: LD_INT 0
51100: PUSH
51101: EMPTY
51102: LIST
51103: LIST
51104: LIST
51105: LIST
51106: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
51107: LD_VAR 0 1
51111: NOT
51112: PUSH
51113: LD_VAR 0 1
51117: PPUSH
51118: CALL_OW 264
51122: PUSH
51123: LD_INT 12
51125: PUSH
51126: LD_INT 51
51128: PUSH
51129: LD_INT 32
51131: PUSH
51132: LD_INT 89
51134: PUSH
51135: EMPTY
51136: LIST
51137: LIST
51138: LIST
51139: LIST
51140: IN
51141: NOT
51142: OR
51143: IFFALSE 51147
// exit ;
51145: GO 51245
// for i := 1 to 3 do
51147: LD_ADDR_VAR 0 3
51151: PUSH
51152: DOUBLE
51153: LD_INT 1
51155: DEC
51156: ST_TO_ADDR
51157: LD_INT 3
51159: PUSH
51160: FOR_TO
51161: IFFALSE 51243
// begin tmp := GetCargo ( cargo , i ) ;
51163: LD_ADDR_VAR 0 4
51167: PUSH
51168: LD_VAR 0 1
51172: PPUSH
51173: LD_VAR 0 3
51177: PPUSH
51178: CALL_OW 289
51182: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
51183: LD_ADDR_VAR 0 2
51187: PUSH
51188: LD_VAR 0 2
51192: PPUSH
51193: LD_VAR 0 3
51197: PPUSH
51198: LD_VAR 0 4
51202: PPUSH
51203: CALL_OW 1
51207: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
51208: LD_ADDR_VAR 0 2
51212: PUSH
51213: LD_VAR 0 2
51217: PPUSH
51218: LD_INT 4
51220: PPUSH
51221: LD_VAR 0 2
51225: PUSH
51226: LD_INT 4
51228: ARRAY
51229: PUSH
51230: LD_VAR 0 4
51234: PLUS
51235: PPUSH
51236: CALL_OW 1
51240: ST_TO_ADDR
// end ;
51241: GO 51160
51243: POP
51244: POP
// end ;
51245: LD_VAR 0 2
51249: RET
// export function Length ( array ) ; begin
51250: LD_INT 0
51252: PPUSH
// result := array + 0 ;
51253: LD_ADDR_VAR 0 2
51257: PUSH
51258: LD_VAR 0 1
51262: PUSH
51263: LD_INT 0
51265: PLUS
51266: ST_TO_ADDR
// end ;
51267: LD_VAR 0 2
51271: RET
// export function PrepareArray ( array ) ; begin
51272: LD_INT 0
51274: PPUSH
// result := array diff 0 ;
51275: LD_ADDR_VAR 0 2
51279: PUSH
51280: LD_VAR 0 1
51284: PUSH
51285: LD_INT 0
51287: DIFF
51288: ST_TO_ADDR
// if not result [ 1 ] then
51289: LD_VAR 0 2
51293: PUSH
51294: LD_INT 1
51296: ARRAY
51297: NOT
51298: IFFALSE 51318
// result := Delete ( result , 1 ) ;
51300: LD_ADDR_VAR 0 2
51304: PUSH
51305: LD_VAR 0 2
51309: PPUSH
51310: LD_INT 1
51312: PPUSH
51313: CALL_OW 3
51317: ST_TO_ADDR
// end ;
51318: LD_VAR 0 2
51322: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
51323: LD_INT 0
51325: PPUSH
51326: PPUSH
51327: PPUSH
51328: PPUSH
// sibRocketRange := 25 ;
51329: LD_ADDR_VAR 0 6
51333: PUSH
51334: LD_INT 25
51336: ST_TO_ADDR
// result := false ;
51337: LD_ADDR_VAR 0 4
51341: PUSH
51342: LD_INT 0
51344: ST_TO_ADDR
// for i := 0 to 5 do
51345: LD_ADDR_VAR 0 5
51349: PUSH
51350: DOUBLE
51351: LD_INT 0
51353: DEC
51354: ST_TO_ADDR
51355: LD_INT 5
51357: PUSH
51358: FOR_TO
51359: IFFALSE 51426
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
51361: LD_VAR 0 1
51365: PPUSH
51366: LD_VAR 0 5
51370: PPUSH
51371: LD_VAR 0 6
51375: PPUSH
51376: CALL_OW 272
51380: PPUSH
51381: LD_VAR 0 2
51385: PPUSH
51386: LD_VAR 0 5
51390: PPUSH
51391: LD_VAR 0 6
51395: PPUSH
51396: CALL_OW 273
51400: PPUSH
51401: LD_VAR 0 3
51405: PPUSH
51406: CALL_OW 309
51410: IFFALSE 51424
// begin result := true ;
51412: LD_ADDR_VAR 0 4
51416: PUSH
51417: LD_INT 1
51419: ST_TO_ADDR
// exit ;
51420: POP
51421: POP
51422: GO 51428
// end ;
51424: GO 51358
51426: POP
51427: POP
// end ;
51428: LD_VAR 0 4
51432: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
51433: LD_INT 0
51435: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
51436: LD_VAR 0 1
51440: PPUSH
51441: LD_VAR 0 2
51445: PPUSH
51446: LD_INT 0
51448: PPUSH
51449: LD_INT 0
51451: PPUSH
51452: LD_INT 1
51454: PPUSH
51455: LD_INT 0
51457: PPUSH
51458: CALL_OW 587
// end ;
51462: LD_VAR 0 3
51466: RET
// export function CenterOnNow ( unit ) ; begin
51467: LD_INT 0
51469: PPUSH
// result := IsInUnit ( unit ) ;
51470: LD_ADDR_VAR 0 2
51474: PUSH
51475: LD_VAR 0 1
51479: PPUSH
51480: CALL_OW 310
51484: ST_TO_ADDR
// if not result then
51485: LD_VAR 0 2
51489: NOT
51490: IFFALSE 51502
// result := unit ;
51492: LD_ADDR_VAR 0 2
51496: PUSH
51497: LD_VAR 0 1
51501: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
51502: LD_VAR 0 1
51506: PPUSH
51507: CALL_OW 87
// end ;
51511: LD_VAR 0 2
51515: RET
// export function ComMoveHex ( unit , hex ) ; begin
51516: LD_INT 0
51518: PPUSH
// if not hex then
51519: LD_VAR 0 2
51523: NOT
51524: IFFALSE 51528
// exit ;
51526: GO 51581
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
51528: LD_VAR 0 2
51532: PUSH
51533: LD_INT 1
51535: ARRAY
51536: PPUSH
51537: LD_VAR 0 2
51541: PUSH
51542: LD_INT 2
51544: ARRAY
51545: PPUSH
51546: CALL_OW 428
51550: IFFALSE 51554
// exit ;
51552: GO 51581
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
51554: LD_VAR 0 1
51558: PPUSH
51559: LD_VAR 0 2
51563: PUSH
51564: LD_INT 1
51566: ARRAY
51567: PPUSH
51568: LD_VAR 0 2
51572: PUSH
51573: LD_INT 2
51575: ARRAY
51576: PPUSH
51577: CALL_OW 111
// end ;
51581: LD_VAR 0 3
51585: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
51586: LD_INT 0
51588: PPUSH
51589: PPUSH
51590: PPUSH
// if not unit or not enemy then
51591: LD_VAR 0 1
51595: NOT
51596: PUSH
51597: LD_VAR 0 2
51601: NOT
51602: OR
51603: IFFALSE 51607
// exit ;
51605: GO 51731
// x := GetX ( enemy ) ;
51607: LD_ADDR_VAR 0 4
51611: PUSH
51612: LD_VAR 0 2
51616: PPUSH
51617: CALL_OW 250
51621: ST_TO_ADDR
// y := GetY ( enemy ) ;
51622: LD_ADDR_VAR 0 5
51626: PUSH
51627: LD_VAR 0 2
51631: PPUSH
51632: CALL_OW 251
51636: ST_TO_ADDR
// if ValidHex ( x , y ) then
51637: LD_VAR 0 4
51641: PPUSH
51642: LD_VAR 0 5
51646: PPUSH
51647: CALL_OW 488
51651: IFFALSE 51731
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
51653: LD_VAR 0 2
51657: PPUSH
51658: CALL_OW 247
51662: PUSH
51663: LD_INT 3
51665: PUSH
51666: LD_INT 2
51668: PUSH
51669: EMPTY
51670: LIST
51671: LIST
51672: IN
51673: PUSH
51674: LD_VAR 0 1
51678: PPUSH
51679: CALL_OW 255
51683: PPUSH
51684: LD_VAR 0 2
51688: PPUSH
51689: CALL_OW 292
51693: AND
51694: IFFALSE 51712
// ComAttackUnit ( unit , enemy ) else
51696: LD_VAR 0 1
51700: PPUSH
51701: LD_VAR 0 2
51705: PPUSH
51706: CALL_OW 115
51710: GO 51731
// ComAgressiveMove ( unit , x , y ) ;
51712: LD_VAR 0 1
51716: PPUSH
51717: LD_VAR 0 4
51721: PPUSH
51722: LD_VAR 0 5
51726: PPUSH
51727: CALL_OW 114
// end ; end_of_file
51731: LD_VAR 0 3
51735: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
51736: LD_INT 0
51738: PPUSH
51739: PPUSH
// skirmish := false ;
51740: LD_ADDR_EXP 41
51744: PUSH
51745: LD_INT 0
51747: ST_TO_ADDR
// debug_mc := false ;
51748: LD_ADDR_EXP 42
51752: PUSH
51753: LD_INT 0
51755: ST_TO_ADDR
// mc_bases := [ ] ;
51756: LD_ADDR_EXP 43
51760: PUSH
51761: EMPTY
51762: ST_TO_ADDR
// mc_sides := [ ] ;
51763: LD_ADDR_EXP 69
51767: PUSH
51768: EMPTY
51769: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51770: LD_ADDR_EXP 44
51774: PUSH
51775: EMPTY
51776: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51777: LD_ADDR_EXP 45
51781: PUSH
51782: EMPTY
51783: ST_TO_ADDR
// mc_need_heal := [ ] ;
51784: LD_ADDR_EXP 46
51788: PUSH
51789: EMPTY
51790: ST_TO_ADDR
// mc_healers := [ ] ;
51791: LD_ADDR_EXP 47
51795: PUSH
51796: EMPTY
51797: ST_TO_ADDR
// mc_build_list := [ ] ;
51798: LD_ADDR_EXP 48
51802: PUSH
51803: EMPTY
51804: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51805: LD_ADDR_EXP 75
51809: PUSH
51810: EMPTY
51811: ST_TO_ADDR
// mc_builders := [ ] ;
51812: LD_ADDR_EXP 49
51816: PUSH
51817: EMPTY
51818: ST_TO_ADDR
// mc_construct_list := [ ] ;
51819: LD_ADDR_EXP 50
51823: PUSH
51824: EMPTY
51825: ST_TO_ADDR
// mc_turret_list := [ ] ;
51826: LD_ADDR_EXP 51
51830: PUSH
51831: EMPTY
51832: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51833: LD_ADDR_EXP 52
51837: PUSH
51838: EMPTY
51839: ST_TO_ADDR
// mc_miners := [ ] ;
51840: LD_ADDR_EXP 57
51844: PUSH
51845: EMPTY
51846: ST_TO_ADDR
// mc_mines := [ ] ;
51847: LD_ADDR_EXP 56
51851: PUSH
51852: EMPTY
51853: ST_TO_ADDR
// mc_minefields := [ ] ;
51854: LD_ADDR_EXP 58
51858: PUSH
51859: EMPTY
51860: ST_TO_ADDR
// mc_crates := [ ] ;
51861: LD_ADDR_EXP 59
51865: PUSH
51866: EMPTY
51867: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51868: LD_ADDR_EXP 60
51872: PUSH
51873: EMPTY
51874: ST_TO_ADDR
// mc_crates_area := [ ] ;
51875: LD_ADDR_EXP 61
51879: PUSH
51880: EMPTY
51881: ST_TO_ADDR
// mc_vehicles := [ ] ;
51882: LD_ADDR_EXP 62
51886: PUSH
51887: EMPTY
51888: ST_TO_ADDR
// mc_attack := [ ] ;
51889: LD_ADDR_EXP 63
51893: PUSH
51894: EMPTY
51895: ST_TO_ADDR
// mc_produce := [ ] ;
51896: LD_ADDR_EXP 64
51900: PUSH
51901: EMPTY
51902: ST_TO_ADDR
// mc_defender := [ ] ;
51903: LD_ADDR_EXP 65
51907: PUSH
51908: EMPTY
51909: ST_TO_ADDR
// mc_parking := [ ] ;
51910: LD_ADDR_EXP 67
51914: PUSH
51915: EMPTY
51916: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51917: LD_ADDR_EXP 53
51921: PUSH
51922: EMPTY
51923: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51924: LD_ADDR_EXP 55
51928: PUSH
51929: EMPTY
51930: ST_TO_ADDR
// mc_scan := [ ] ;
51931: LD_ADDR_EXP 66
51935: PUSH
51936: EMPTY
51937: ST_TO_ADDR
// mc_scan_area := [ ] ;
51938: LD_ADDR_EXP 68
51942: PUSH
51943: EMPTY
51944: ST_TO_ADDR
// mc_tech := [ ] ;
51945: LD_ADDR_EXP 70
51949: PUSH
51950: EMPTY
51951: ST_TO_ADDR
// mc_class := [ ] ;
51952: LD_ADDR_EXP 84
51956: PUSH
51957: EMPTY
51958: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51959: LD_ADDR_EXP 85
51963: PUSH
51964: EMPTY
51965: ST_TO_ADDR
// mc_is_defending := [ ] ;
51966: LD_ADDR_EXP 86
51970: PUSH
51971: EMPTY
51972: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
51973: LD_ADDR_EXP 77
51977: PUSH
51978: EMPTY
51979: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
51980: LD_ADDR_EXP 87
51984: PUSH
51985: LD_INT 0
51987: ST_TO_ADDR
// end ;
51988: LD_VAR 0 1
51992: RET
// export function MC_Kill ( base ) ; begin
51993: LD_INT 0
51995: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51996: LD_ADDR_EXP 43
52000: PUSH
52001: LD_EXP 43
52005: PPUSH
52006: LD_VAR 0 1
52010: PPUSH
52011: EMPTY
52012: PPUSH
52013: CALL_OW 1
52017: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52018: LD_ADDR_EXP 44
52022: PUSH
52023: LD_EXP 44
52027: PPUSH
52028: LD_VAR 0 1
52032: PPUSH
52033: EMPTY
52034: PPUSH
52035: CALL_OW 1
52039: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52040: LD_ADDR_EXP 45
52044: PUSH
52045: LD_EXP 45
52049: PPUSH
52050: LD_VAR 0 1
52054: PPUSH
52055: EMPTY
52056: PPUSH
52057: CALL_OW 1
52061: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52062: LD_ADDR_EXP 46
52066: PUSH
52067: LD_EXP 46
52071: PPUSH
52072: LD_VAR 0 1
52076: PPUSH
52077: EMPTY
52078: PPUSH
52079: CALL_OW 1
52083: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52084: LD_ADDR_EXP 47
52088: PUSH
52089: LD_EXP 47
52093: PPUSH
52094: LD_VAR 0 1
52098: PPUSH
52099: EMPTY
52100: PPUSH
52101: CALL_OW 1
52105: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52106: LD_ADDR_EXP 48
52110: PUSH
52111: LD_EXP 48
52115: PPUSH
52116: LD_VAR 0 1
52120: PPUSH
52121: EMPTY
52122: PPUSH
52123: CALL_OW 1
52127: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52128: LD_ADDR_EXP 49
52132: PUSH
52133: LD_EXP 49
52137: PPUSH
52138: LD_VAR 0 1
52142: PPUSH
52143: EMPTY
52144: PPUSH
52145: CALL_OW 1
52149: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52150: LD_ADDR_EXP 50
52154: PUSH
52155: LD_EXP 50
52159: PPUSH
52160: LD_VAR 0 1
52164: PPUSH
52165: EMPTY
52166: PPUSH
52167: CALL_OW 1
52171: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52172: LD_ADDR_EXP 51
52176: PUSH
52177: LD_EXP 51
52181: PPUSH
52182: LD_VAR 0 1
52186: PPUSH
52187: EMPTY
52188: PPUSH
52189: CALL_OW 1
52193: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52194: LD_ADDR_EXP 52
52198: PUSH
52199: LD_EXP 52
52203: PPUSH
52204: LD_VAR 0 1
52208: PPUSH
52209: EMPTY
52210: PPUSH
52211: CALL_OW 1
52215: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52216: LD_ADDR_EXP 53
52220: PUSH
52221: LD_EXP 53
52225: PPUSH
52226: LD_VAR 0 1
52230: PPUSH
52231: EMPTY
52232: PPUSH
52233: CALL_OW 1
52237: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52238: LD_ADDR_EXP 54
52242: PUSH
52243: LD_EXP 54
52247: PPUSH
52248: LD_VAR 0 1
52252: PPUSH
52253: LD_INT 0
52255: PPUSH
52256: CALL_OW 1
52260: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52261: LD_ADDR_EXP 55
52265: PUSH
52266: LD_EXP 55
52270: PPUSH
52271: LD_VAR 0 1
52275: PPUSH
52276: EMPTY
52277: PPUSH
52278: CALL_OW 1
52282: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52283: LD_ADDR_EXP 56
52287: PUSH
52288: LD_EXP 56
52292: PPUSH
52293: LD_VAR 0 1
52297: PPUSH
52298: EMPTY
52299: PPUSH
52300: CALL_OW 1
52304: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52305: LD_ADDR_EXP 57
52309: PUSH
52310: LD_EXP 57
52314: PPUSH
52315: LD_VAR 0 1
52319: PPUSH
52320: EMPTY
52321: PPUSH
52322: CALL_OW 1
52326: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52327: LD_ADDR_EXP 58
52331: PUSH
52332: LD_EXP 58
52336: PPUSH
52337: LD_VAR 0 1
52341: PPUSH
52342: EMPTY
52343: PPUSH
52344: CALL_OW 1
52348: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52349: LD_ADDR_EXP 59
52353: PUSH
52354: LD_EXP 59
52358: PPUSH
52359: LD_VAR 0 1
52363: PPUSH
52364: EMPTY
52365: PPUSH
52366: CALL_OW 1
52370: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52371: LD_ADDR_EXP 60
52375: PUSH
52376: LD_EXP 60
52380: PPUSH
52381: LD_VAR 0 1
52385: PPUSH
52386: EMPTY
52387: PPUSH
52388: CALL_OW 1
52392: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52393: LD_ADDR_EXP 61
52397: PUSH
52398: LD_EXP 61
52402: PPUSH
52403: LD_VAR 0 1
52407: PPUSH
52408: EMPTY
52409: PPUSH
52410: CALL_OW 1
52414: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52415: LD_ADDR_EXP 62
52419: PUSH
52420: LD_EXP 62
52424: PPUSH
52425: LD_VAR 0 1
52429: PPUSH
52430: EMPTY
52431: PPUSH
52432: CALL_OW 1
52436: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52437: LD_ADDR_EXP 63
52441: PUSH
52442: LD_EXP 63
52446: PPUSH
52447: LD_VAR 0 1
52451: PPUSH
52452: EMPTY
52453: PPUSH
52454: CALL_OW 1
52458: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52459: LD_ADDR_EXP 64
52463: PUSH
52464: LD_EXP 64
52468: PPUSH
52469: LD_VAR 0 1
52473: PPUSH
52474: EMPTY
52475: PPUSH
52476: CALL_OW 1
52480: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52481: LD_ADDR_EXP 65
52485: PUSH
52486: LD_EXP 65
52490: PPUSH
52491: LD_VAR 0 1
52495: PPUSH
52496: EMPTY
52497: PPUSH
52498: CALL_OW 1
52502: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52503: LD_ADDR_EXP 66
52507: PUSH
52508: LD_EXP 66
52512: PPUSH
52513: LD_VAR 0 1
52517: PPUSH
52518: EMPTY
52519: PPUSH
52520: CALL_OW 1
52524: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52525: LD_ADDR_EXP 67
52529: PUSH
52530: LD_EXP 67
52534: PPUSH
52535: LD_VAR 0 1
52539: PPUSH
52540: EMPTY
52541: PPUSH
52542: CALL_OW 1
52546: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52547: LD_ADDR_EXP 68
52551: PUSH
52552: LD_EXP 68
52556: PPUSH
52557: LD_VAR 0 1
52561: PPUSH
52562: EMPTY
52563: PPUSH
52564: CALL_OW 1
52568: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52569: LD_ADDR_EXP 70
52573: PUSH
52574: LD_EXP 70
52578: PPUSH
52579: LD_VAR 0 1
52583: PPUSH
52584: EMPTY
52585: PPUSH
52586: CALL_OW 1
52590: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52591: LD_ADDR_EXP 72
52595: PUSH
52596: LD_EXP 72
52600: PPUSH
52601: LD_VAR 0 1
52605: PPUSH
52606: EMPTY
52607: PPUSH
52608: CALL_OW 1
52612: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52613: LD_ADDR_EXP 73
52617: PUSH
52618: LD_EXP 73
52622: PPUSH
52623: LD_VAR 0 1
52627: PPUSH
52628: EMPTY
52629: PPUSH
52630: CALL_OW 1
52634: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52635: LD_ADDR_EXP 74
52639: PUSH
52640: LD_EXP 74
52644: PPUSH
52645: LD_VAR 0 1
52649: PPUSH
52650: EMPTY
52651: PPUSH
52652: CALL_OW 1
52656: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52657: LD_ADDR_EXP 75
52661: PUSH
52662: LD_EXP 75
52666: PPUSH
52667: LD_VAR 0 1
52671: PPUSH
52672: EMPTY
52673: PPUSH
52674: CALL_OW 1
52678: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52679: LD_ADDR_EXP 76
52683: PUSH
52684: LD_EXP 76
52688: PPUSH
52689: LD_VAR 0 1
52693: PPUSH
52694: EMPTY
52695: PPUSH
52696: CALL_OW 1
52700: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52701: LD_ADDR_EXP 77
52705: PUSH
52706: LD_EXP 77
52710: PPUSH
52711: LD_VAR 0 1
52715: PPUSH
52716: EMPTY
52717: PPUSH
52718: CALL_OW 1
52722: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52723: LD_ADDR_EXP 78
52727: PUSH
52728: LD_EXP 78
52732: PPUSH
52733: LD_VAR 0 1
52737: PPUSH
52738: EMPTY
52739: PPUSH
52740: CALL_OW 1
52744: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52745: LD_ADDR_EXP 79
52749: PUSH
52750: LD_EXP 79
52754: PPUSH
52755: LD_VAR 0 1
52759: PPUSH
52760: EMPTY
52761: PPUSH
52762: CALL_OW 1
52766: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52767: LD_ADDR_EXP 80
52771: PUSH
52772: LD_EXP 80
52776: PPUSH
52777: LD_VAR 0 1
52781: PPUSH
52782: EMPTY
52783: PPUSH
52784: CALL_OW 1
52788: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52789: LD_ADDR_EXP 81
52793: PUSH
52794: LD_EXP 81
52798: PPUSH
52799: LD_VAR 0 1
52803: PPUSH
52804: EMPTY
52805: PPUSH
52806: CALL_OW 1
52810: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52811: LD_ADDR_EXP 82
52815: PUSH
52816: LD_EXP 82
52820: PPUSH
52821: LD_VAR 0 1
52825: PPUSH
52826: EMPTY
52827: PPUSH
52828: CALL_OW 1
52832: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52833: LD_ADDR_EXP 83
52837: PUSH
52838: LD_EXP 83
52842: PPUSH
52843: LD_VAR 0 1
52847: PPUSH
52848: EMPTY
52849: PPUSH
52850: CALL_OW 1
52854: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52855: LD_ADDR_EXP 84
52859: PUSH
52860: LD_EXP 84
52864: PPUSH
52865: LD_VAR 0 1
52869: PPUSH
52870: EMPTY
52871: PPUSH
52872: CALL_OW 1
52876: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52877: LD_ADDR_EXP 85
52881: PUSH
52882: LD_EXP 85
52886: PPUSH
52887: LD_VAR 0 1
52891: PPUSH
52892: LD_INT 0
52894: PPUSH
52895: CALL_OW 1
52899: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52900: LD_ADDR_EXP 86
52904: PUSH
52905: LD_EXP 86
52909: PPUSH
52910: LD_VAR 0 1
52914: PPUSH
52915: LD_INT 0
52917: PPUSH
52918: CALL_OW 1
52922: ST_TO_ADDR
// end ;
52923: LD_VAR 0 2
52927: RET
// export function MC_Add ( side , units ) ; var base ; begin
52928: LD_INT 0
52930: PPUSH
52931: PPUSH
// base := mc_bases + 1 ;
52932: LD_ADDR_VAR 0 4
52936: PUSH
52937: LD_EXP 43
52941: PUSH
52942: LD_INT 1
52944: PLUS
52945: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52946: LD_ADDR_EXP 69
52950: PUSH
52951: LD_EXP 69
52955: PPUSH
52956: LD_VAR 0 4
52960: PPUSH
52961: LD_VAR 0 1
52965: PPUSH
52966: CALL_OW 1
52970: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52971: LD_ADDR_EXP 43
52975: PUSH
52976: LD_EXP 43
52980: PPUSH
52981: LD_VAR 0 4
52985: PPUSH
52986: LD_VAR 0 2
52990: PPUSH
52991: CALL_OW 1
52995: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52996: LD_ADDR_EXP 44
53000: PUSH
53001: LD_EXP 44
53005: PPUSH
53006: LD_VAR 0 4
53010: PPUSH
53011: EMPTY
53012: PPUSH
53013: CALL_OW 1
53017: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53018: LD_ADDR_EXP 45
53022: PUSH
53023: LD_EXP 45
53027: PPUSH
53028: LD_VAR 0 4
53032: PPUSH
53033: EMPTY
53034: PPUSH
53035: CALL_OW 1
53039: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53040: LD_ADDR_EXP 46
53044: PUSH
53045: LD_EXP 46
53049: PPUSH
53050: LD_VAR 0 4
53054: PPUSH
53055: EMPTY
53056: PPUSH
53057: CALL_OW 1
53061: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53062: LD_ADDR_EXP 47
53066: PUSH
53067: LD_EXP 47
53071: PPUSH
53072: LD_VAR 0 4
53076: PPUSH
53077: EMPTY
53078: PPUSH
53079: CALL_OW 1
53083: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53084: LD_ADDR_EXP 48
53088: PUSH
53089: LD_EXP 48
53093: PPUSH
53094: LD_VAR 0 4
53098: PPUSH
53099: EMPTY
53100: PPUSH
53101: CALL_OW 1
53105: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53106: LD_ADDR_EXP 49
53110: PUSH
53111: LD_EXP 49
53115: PPUSH
53116: LD_VAR 0 4
53120: PPUSH
53121: EMPTY
53122: PPUSH
53123: CALL_OW 1
53127: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53128: LD_ADDR_EXP 50
53132: PUSH
53133: LD_EXP 50
53137: PPUSH
53138: LD_VAR 0 4
53142: PPUSH
53143: EMPTY
53144: PPUSH
53145: CALL_OW 1
53149: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53150: LD_ADDR_EXP 51
53154: PUSH
53155: LD_EXP 51
53159: PPUSH
53160: LD_VAR 0 4
53164: PPUSH
53165: EMPTY
53166: PPUSH
53167: CALL_OW 1
53171: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53172: LD_ADDR_EXP 52
53176: PUSH
53177: LD_EXP 52
53181: PPUSH
53182: LD_VAR 0 4
53186: PPUSH
53187: EMPTY
53188: PPUSH
53189: CALL_OW 1
53193: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53194: LD_ADDR_EXP 53
53198: PUSH
53199: LD_EXP 53
53203: PPUSH
53204: LD_VAR 0 4
53208: PPUSH
53209: EMPTY
53210: PPUSH
53211: CALL_OW 1
53215: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53216: LD_ADDR_EXP 54
53220: PUSH
53221: LD_EXP 54
53225: PPUSH
53226: LD_VAR 0 4
53230: PPUSH
53231: LD_INT 0
53233: PPUSH
53234: CALL_OW 1
53238: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53239: LD_ADDR_EXP 55
53243: PUSH
53244: LD_EXP 55
53248: PPUSH
53249: LD_VAR 0 4
53253: PPUSH
53254: EMPTY
53255: PPUSH
53256: CALL_OW 1
53260: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53261: LD_ADDR_EXP 56
53265: PUSH
53266: LD_EXP 56
53270: PPUSH
53271: LD_VAR 0 4
53275: PPUSH
53276: EMPTY
53277: PPUSH
53278: CALL_OW 1
53282: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53283: LD_ADDR_EXP 57
53287: PUSH
53288: LD_EXP 57
53292: PPUSH
53293: LD_VAR 0 4
53297: PPUSH
53298: EMPTY
53299: PPUSH
53300: CALL_OW 1
53304: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53305: LD_ADDR_EXP 58
53309: PUSH
53310: LD_EXP 58
53314: PPUSH
53315: LD_VAR 0 4
53319: PPUSH
53320: EMPTY
53321: PPUSH
53322: CALL_OW 1
53326: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53327: LD_ADDR_EXP 59
53331: PUSH
53332: LD_EXP 59
53336: PPUSH
53337: LD_VAR 0 4
53341: PPUSH
53342: EMPTY
53343: PPUSH
53344: CALL_OW 1
53348: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53349: LD_ADDR_EXP 60
53353: PUSH
53354: LD_EXP 60
53358: PPUSH
53359: LD_VAR 0 4
53363: PPUSH
53364: EMPTY
53365: PPUSH
53366: CALL_OW 1
53370: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53371: LD_ADDR_EXP 61
53375: PUSH
53376: LD_EXP 61
53380: PPUSH
53381: LD_VAR 0 4
53385: PPUSH
53386: EMPTY
53387: PPUSH
53388: CALL_OW 1
53392: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53393: LD_ADDR_EXP 62
53397: PUSH
53398: LD_EXP 62
53402: PPUSH
53403: LD_VAR 0 4
53407: PPUSH
53408: EMPTY
53409: PPUSH
53410: CALL_OW 1
53414: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53415: LD_ADDR_EXP 63
53419: PUSH
53420: LD_EXP 63
53424: PPUSH
53425: LD_VAR 0 4
53429: PPUSH
53430: EMPTY
53431: PPUSH
53432: CALL_OW 1
53436: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53437: LD_ADDR_EXP 64
53441: PUSH
53442: LD_EXP 64
53446: PPUSH
53447: LD_VAR 0 4
53451: PPUSH
53452: EMPTY
53453: PPUSH
53454: CALL_OW 1
53458: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53459: LD_ADDR_EXP 65
53463: PUSH
53464: LD_EXP 65
53468: PPUSH
53469: LD_VAR 0 4
53473: PPUSH
53474: EMPTY
53475: PPUSH
53476: CALL_OW 1
53480: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53481: LD_ADDR_EXP 66
53485: PUSH
53486: LD_EXP 66
53490: PPUSH
53491: LD_VAR 0 4
53495: PPUSH
53496: EMPTY
53497: PPUSH
53498: CALL_OW 1
53502: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53503: LD_ADDR_EXP 67
53507: PUSH
53508: LD_EXP 67
53512: PPUSH
53513: LD_VAR 0 4
53517: PPUSH
53518: EMPTY
53519: PPUSH
53520: CALL_OW 1
53524: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53525: LD_ADDR_EXP 68
53529: PUSH
53530: LD_EXP 68
53534: PPUSH
53535: LD_VAR 0 4
53539: PPUSH
53540: EMPTY
53541: PPUSH
53542: CALL_OW 1
53546: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53547: LD_ADDR_EXP 70
53551: PUSH
53552: LD_EXP 70
53556: PPUSH
53557: LD_VAR 0 4
53561: PPUSH
53562: EMPTY
53563: PPUSH
53564: CALL_OW 1
53568: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53569: LD_ADDR_EXP 72
53573: PUSH
53574: LD_EXP 72
53578: PPUSH
53579: LD_VAR 0 4
53583: PPUSH
53584: EMPTY
53585: PPUSH
53586: CALL_OW 1
53590: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53591: LD_ADDR_EXP 73
53595: PUSH
53596: LD_EXP 73
53600: PPUSH
53601: LD_VAR 0 4
53605: PPUSH
53606: EMPTY
53607: PPUSH
53608: CALL_OW 1
53612: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53613: LD_ADDR_EXP 74
53617: PUSH
53618: LD_EXP 74
53622: PPUSH
53623: LD_VAR 0 4
53627: PPUSH
53628: EMPTY
53629: PPUSH
53630: CALL_OW 1
53634: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53635: LD_ADDR_EXP 75
53639: PUSH
53640: LD_EXP 75
53644: PPUSH
53645: LD_VAR 0 4
53649: PPUSH
53650: EMPTY
53651: PPUSH
53652: CALL_OW 1
53656: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53657: LD_ADDR_EXP 76
53661: PUSH
53662: LD_EXP 76
53666: PPUSH
53667: LD_VAR 0 4
53671: PPUSH
53672: EMPTY
53673: PPUSH
53674: CALL_OW 1
53678: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53679: LD_ADDR_EXP 77
53683: PUSH
53684: LD_EXP 77
53688: PPUSH
53689: LD_VAR 0 4
53693: PPUSH
53694: EMPTY
53695: PPUSH
53696: CALL_OW 1
53700: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53701: LD_ADDR_EXP 78
53705: PUSH
53706: LD_EXP 78
53710: PPUSH
53711: LD_VAR 0 4
53715: PPUSH
53716: EMPTY
53717: PPUSH
53718: CALL_OW 1
53722: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53723: LD_ADDR_EXP 79
53727: PUSH
53728: LD_EXP 79
53732: PPUSH
53733: LD_VAR 0 4
53737: PPUSH
53738: EMPTY
53739: PPUSH
53740: CALL_OW 1
53744: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53745: LD_ADDR_EXP 80
53749: PUSH
53750: LD_EXP 80
53754: PPUSH
53755: LD_VAR 0 4
53759: PPUSH
53760: EMPTY
53761: PPUSH
53762: CALL_OW 1
53766: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53767: LD_ADDR_EXP 81
53771: PUSH
53772: LD_EXP 81
53776: PPUSH
53777: LD_VAR 0 4
53781: PPUSH
53782: EMPTY
53783: PPUSH
53784: CALL_OW 1
53788: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53789: LD_ADDR_EXP 82
53793: PUSH
53794: LD_EXP 82
53798: PPUSH
53799: LD_VAR 0 4
53803: PPUSH
53804: EMPTY
53805: PPUSH
53806: CALL_OW 1
53810: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53811: LD_ADDR_EXP 83
53815: PUSH
53816: LD_EXP 83
53820: PPUSH
53821: LD_VAR 0 4
53825: PPUSH
53826: EMPTY
53827: PPUSH
53828: CALL_OW 1
53832: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53833: LD_ADDR_EXP 84
53837: PUSH
53838: LD_EXP 84
53842: PPUSH
53843: LD_VAR 0 4
53847: PPUSH
53848: EMPTY
53849: PPUSH
53850: CALL_OW 1
53854: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53855: LD_ADDR_EXP 85
53859: PUSH
53860: LD_EXP 85
53864: PPUSH
53865: LD_VAR 0 4
53869: PPUSH
53870: LD_INT 0
53872: PPUSH
53873: CALL_OW 1
53877: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53878: LD_ADDR_EXP 86
53882: PUSH
53883: LD_EXP 86
53887: PPUSH
53888: LD_VAR 0 4
53892: PPUSH
53893: LD_INT 0
53895: PPUSH
53896: CALL_OW 1
53900: ST_TO_ADDR
// result := base ;
53901: LD_ADDR_VAR 0 3
53905: PUSH
53906: LD_VAR 0 4
53910: ST_TO_ADDR
// end ;
53911: LD_VAR 0 3
53915: RET
// export function MC_Start ( ) ; var i ; begin
53916: LD_INT 0
53918: PPUSH
53919: PPUSH
// for i = 1 to mc_bases do
53920: LD_ADDR_VAR 0 2
53924: PUSH
53925: DOUBLE
53926: LD_INT 1
53928: DEC
53929: ST_TO_ADDR
53930: LD_EXP 43
53934: PUSH
53935: FOR_TO
53936: IFFALSE 55036
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53938: LD_ADDR_EXP 43
53942: PUSH
53943: LD_EXP 43
53947: PPUSH
53948: LD_VAR 0 2
53952: PPUSH
53953: LD_EXP 43
53957: PUSH
53958: LD_VAR 0 2
53962: ARRAY
53963: PUSH
53964: LD_INT 0
53966: DIFF
53967: PPUSH
53968: CALL_OW 1
53972: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53973: LD_ADDR_EXP 44
53977: PUSH
53978: LD_EXP 44
53982: PPUSH
53983: LD_VAR 0 2
53987: PPUSH
53988: EMPTY
53989: PPUSH
53990: CALL_OW 1
53994: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53995: LD_ADDR_EXP 45
53999: PUSH
54000: LD_EXP 45
54004: PPUSH
54005: LD_VAR 0 2
54009: PPUSH
54010: EMPTY
54011: PPUSH
54012: CALL_OW 1
54016: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54017: LD_ADDR_EXP 46
54021: PUSH
54022: LD_EXP 46
54026: PPUSH
54027: LD_VAR 0 2
54031: PPUSH
54032: EMPTY
54033: PPUSH
54034: CALL_OW 1
54038: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54039: LD_ADDR_EXP 47
54043: PUSH
54044: LD_EXP 47
54048: PPUSH
54049: LD_VAR 0 2
54053: PPUSH
54054: EMPTY
54055: PUSH
54056: EMPTY
54057: PUSH
54058: EMPTY
54059: LIST
54060: LIST
54061: PPUSH
54062: CALL_OW 1
54066: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54067: LD_ADDR_EXP 48
54071: PUSH
54072: LD_EXP 48
54076: PPUSH
54077: LD_VAR 0 2
54081: PPUSH
54082: EMPTY
54083: PPUSH
54084: CALL_OW 1
54088: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54089: LD_ADDR_EXP 75
54093: PUSH
54094: LD_EXP 75
54098: PPUSH
54099: LD_VAR 0 2
54103: PPUSH
54104: EMPTY
54105: PPUSH
54106: CALL_OW 1
54110: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54111: LD_ADDR_EXP 49
54115: PUSH
54116: LD_EXP 49
54120: PPUSH
54121: LD_VAR 0 2
54125: PPUSH
54126: EMPTY
54127: PPUSH
54128: CALL_OW 1
54132: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54133: LD_ADDR_EXP 50
54137: PUSH
54138: LD_EXP 50
54142: PPUSH
54143: LD_VAR 0 2
54147: PPUSH
54148: EMPTY
54149: PPUSH
54150: CALL_OW 1
54154: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54155: LD_ADDR_EXP 51
54159: PUSH
54160: LD_EXP 51
54164: PPUSH
54165: LD_VAR 0 2
54169: PPUSH
54170: LD_EXP 43
54174: PUSH
54175: LD_VAR 0 2
54179: ARRAY
54180: PPUSH
54181: LD_INT 2
54183: PUSH
54184: LD_INT 30
54186: PUSH
54187: LD_INT 32
54189: PUSH
54190: EMPTY
54191: LIST
54192: LIST
54193: PUSH
54194: LD_INT 30
54196: PUSH
54197: LD_INT 33
54199: PUSH
54200: EMPTY
54201: LIST
54202: LIST
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: LIST
54208: PPUSH
54209: CALL_OW 72
54213: PPUSH
54214: CALL_OW 1
54218: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54219: LD_ADDR_EXP 52
54223: PUSH
54224: LD_EXP 52
54228: PPUSH
54229: LD_VAR 0 2
54233: PPUSH
54234: LD_EXP 43
54238: PUSH
54239: LD_VAR 0 2
54243: ARRAY
54244: PPUSH
54245: LD_INT 2
54247: PUSH
54248: LD_INT 30
54250: PUSH
54251: LD_INT 32
54253: PUSH
54254: EMPTY
54255: LIST
54256: LIST
54257: PUSH
54258: LD_INT 30
54260: PUSH
54261: LD_INT 31
54263: PUSH
54264: EMPTY
54265: LIST
54266: LIST
54267: PUSH
54268: EMPTY
54269: LIST
54270: LIST
54271: LIST
54272: PUSH
54273: LD_INT 58
54275: PUSH
54276: EMPTY
54277: LIST
54278: PUSH
54279: EMPTY
54280: LIST
54281: LIST
54282: PPUSH
54283: CALL_OW 72
54287: PPUSH
54288: CALL_OW 1
54292: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54293: LD_ADDR_EXP 53
54297: PUSH
54298: LD_EXP 53
54302: PPUSH
54303: LD_VAR 0 2
54307: PPUSH
54308: EMPTY
54309: PPUSH
54310: CALL_OW 1
54314: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54315: LD_ADDR_EXP 57
54319: PUSH
54320: LD_EXP 57
54324: PPUSH
54325: LD_VAR 0 2
54329: PPUSH
54330: EMPTY
54331: PPUSH
54332: CALL_OW 1
54336: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54337: LD_ADDR_EXP 56
54341: PUSH
54342: LD_EXP 56
54346: PPUSH
54347: LD_VAR 0 2
54351: PPUSH
54352: EMPTY
54353: PPUSH
54354: CALL_OW 1
54358: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54359: LD_ADDR_EXP 58
54363: PUSH
54364: LD_EXP 58
54368: PPUSH
54369: LD_VAR 0 2
54373: PPUSH
54374: EMPTY
54375: PPUSH
54376: CALL_OW 1
54380: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54381: LD_ADDR_EXP 59
54385: PUSH
54386: LD_EXP 59
54390: PPUSH
54391: LD_VAR 0 2
54395: PPUSH
54396: EMPTY
54397: PPUSH
54398: CALL_OW 1
54402: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54403: LD_ADDR_EXP 60
54407: PUSH
54408: LD_EXP 60
54412: PPUSH
54413: LD_VAR 0 2
54417: PPUSH
54418: EMPTY
54419: PPUSH
54420: CALL_OW 1
54424: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54425: LD_ADDR_EXP 61
54429: PUSH
54430: LD_EXP 61
54434: PPUSH
54435: LD_VAR 0 2
54439: PPUSH
54440: EMPTY
54441: PPUSH
54442: CALL_OW 1
54446: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54447: LD_ADDR_EXP 62
54451: PUSH
54452: LD_EXP 62
54456: PPUSH
54457: LD_VAR 0 2
54461: PPUSH
54462: EMPTY
54463: PPUSH
54464: CALL_OW 1
54468: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54469: LD_ADDR_EXP 63
54473: PUSH
54474: LD_EXP 63
54478: PPUSH
54479: LD_VAR 0 2
54483: PPUSH
54484: EMPTY
54485: PPUSH
54486: CALL_OW 1
54490: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54491: LD_ADDR_EXP 64
54495: PUSH
54496: LD_EXP 64
54500: PPUSH
54501: LD_VAR 0 2
54505: PPUSH
54506: EMPTY
54507: PPUSH
54508: CALL_OW 1
54512: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54513: LD_ADDR_EXP 65
54517: PUSH
54518: LD_EXP 65
54522: PPUSH
54523: LD_VAR 0 2
54527: PPUSH
54528: EMPTY
54529: PPUSH
54530: CALL_OW 1
54534: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54535: LD_ADDR_EXP 54
54539: PUSH
54540: LD_EXP 54
54544: PPUSH
54545: LD_VAR 0 2
54549: PPUSH
54550: LD_INT 0
54552: PPUSH
54553: CALL_OW 1
54557: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54558: LD_ADDR_EXP 67
54562: PUSH
54563: LD_EXP 67
54567: PPUSH
54568: LD_VAR 0 2
54572: PPUSH
54573: LD_INT 0
54575: PPUSH
54576: CALL_OW 1
54580: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54581: LD_ADDR_EXP 55
54585: PUSH
54586: LD_EXP 55
54590: PPUSH
54591: LD_VAR 0 2
54595: PPUSH
54596: EMPTY
54597: PPUSH
54598: CALL_OW 1
54602: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54603: LD_ADDR_EXP 66
54607: PUSH
54608: LD_EXP 66
54612: PPUSH
54613: LD_VAR 0 2
54617: PPUSH
54618: LD_INT 0
54620: PPUSH
54621: CALL_OW 1
54625: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54626: LD_ADDR_EXP 68
54630: PUSH
54631: LD_EXP 68
54635: PPUSH
54636: LD_VAR 0 2
54640: PPUSH
54641: EMPTY
54642: PPUSH
54643: CALL_OW 1
54647: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54648: LD_ADDR_EXP 71
54652: PUSH
54653: LD_EXP 71
54657: PPUSH
54658: LD_VAR 0 2
54662: PPUSH
54663: LD_INT 0
54665: PPUSH
54666: CALL_OW 1
54670: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54671: LD_ADDR_EXP 72
54675: PUSH
54676: LD_EXP 72
54680: PPUSH
54681: LD_VAR 0 2
54685: PPUSH
54686: EMPTY
54687: PPUSH
54688: CALL_OW 1
54692: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54693: LD_ADDR_EXP 73
54697: PUSH
54698: LD_EXP 73
54702: PPUSH
54703: LD_VAR 0 2
54707: PPUSH
54708: EMPTY
54709: PPUSH
54710: CALL_OW 1
54714: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54715: LD_ADDR_EXP 74
54719: PUSH
54720: LD_EXP 74
54724: PPUSH
54725: LD_VAR 0 2
54729: PPUSH
54730: EMPTY
54731: PPUSH
54732: CALL_OW 1
54736: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54737: LD_ADDR_EXP 76
54741: PUSH
54742: LD_EXP 76
54746: PPUSH
54747: LD_VAR 0 2
54751: PPUSH
54752: LD_EXP 43
54756: PUSH
54757: LD_VAR 0 2
54761: ARRAY
54762: PPUSH
54763: LD_INT 2
54765: PUSH
54766: LD_INT 30
54768: PUSH
54769: LD_INT 6
54771: PUSH
54772: EMPTY
54773: LIST
54774: LIST
54775: PUSH
54776: LD_INT 30
54778: PUSH
54779: LD_INT 7
54781: PUSH
54782: EMPTY
54783: LIST
54784: LIST
54785: PUSH
54786: LD_INT 30
54788: PUSH
54789: LD_INT 8
54791: PUSH
54792: EMPTY
54793: LIST
54794: LIST
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: LIST
54800: LIST
54801: PPUSH
54802: CALL_OW 72
54806: PPUSH
54807: CALL_OW 1
54811: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54812: LD_ADDR_EXP 77
54816: PUSH
54817: LD_EXP 77
54821: PPUSH
54822: LD_VAR 0 2
54826: PPUSH
54827: EMPTY
54828: PPUSH
54829: CALL_OW 1
54833: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54834: LD_ADDR_EXP 78
54838: PUSH
54839: LD_EXP 78
54843: PPUSH
54844: LD_VAR 0 2
54848: PPUSH
54849: EMPTY
54850: PPUSH
54851: CALL_OW 1
54855: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54856: LD_ADDR_EXP 79
54860: PUSH
54861: LD_EXP 79
54865: PPUSH
54866: LD_VAR 0 2
54870: PPUSH
54871: EMPTY
54872: PPUSH
54873: CALL_OW 1
54877: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54878: LD_ADDR_EXP 80
54882: PUSH
54883: LD_EXP 80
54887: PPUSH
54888: LD_VAR 0 2
54892: PPUSH
54893: EMPTY
54894: PPUSH
54895: CALL_OW 1
54899: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54900: LD_ADDR_EXP 81
54904: PUSH
54905: LD_EXP 81
54909: PPUSH
54910: LD_VAR 0 2
54914: PPUSH
54915: EMPTY
54916: PPUSH
54917: CALL_OW 1
54921: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54922: LD_ADDR_EXP 82
54926: PUSH
54927: LD_EXP 82
54931: PPUSH
54932: LD_VAR 0 2
54936: PPUSH
54937: EMPTY
54938: PPUSH
54939: CALL_OW 1
54943: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54944: LD_ADDR_EXP 83
54948: PUSH
54949: LD_EXP 83
54953: PPUSH
54954: LD_VAR 0 2
54958: PPUSH
54959: EMPTY
54960: PPUSH
54961: CALL_OW 1
54965: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54966: LD_ADDR_EXP 84
54970: PUSH
54971: LD_EXP 84
54975: PPUSH
54976: LD_VAR 0 2
54980: PPUSH
54981: EMPTY
54982: PPUSH
54983: CALL_OW 1
54987: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54988: LD_ADDR_EXP 85
54992: PUSH
54993: LD_EXP 85
54997: PPUSH
54998: LD_VAR 0 2
55002: PPUSH
55003: LD_INT 0
55005: PPUSH
55006: CALL_OW 1
55010: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55011: LD_ADDR_EXP 86
55015: PUSH
55016: LD_EXP 86
55020: PPUSH
55021: LD_VAR 0 2
55025: PPUSH
55026: LD_INT 0
55028: PPUSH
55029: CALL_OW 1
55033: ST_TO_ADDR
// end ;
55034: GO 53935
55036: POP
55037: POP
// MC_InitSides ( ) ;
55038: CALL 55324 0 0
// MC_InitResearch ( ) ;
55042: CALL 55063 0 0
// CustomInitMacro ( ) ;
55046: CALL 78 0 0
// skirmish := true ;
55050: LD_ADDR_EXP 41
55054: PUSH
55055: LD_INT 1
55057: ST_TO_ADDR
// end ;
55058: LD_VAR 0 1
55062: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55063: LD_INT 0
55065: PPUSH
55066: PPUSH
55067: PPUSH
55068: PPUSH
55069: PPUSH
55070: PPUSH
// if not mc_bases then
55071: LD_EXP 43
55075: NOT
55076: IFFALSE 55080
// exit ;
55078: GO 55319
// for i = 1 to 8 do
55080: LD_ADDR_VAR 0 2
55084: PUSH
55085: DOUBLE
55086: LD_INT 1
55088: DEC
55089: ST_TO_ADDR
55090: LD_INT 8
55092: PUSH
55093: FOR_TO
55094: IFFALSE 55120
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55096: LD_ADDR_EXP 70
55100: PUSH
55101: LD_EXP 70
55105: PPUSH
55106: LD_VAR 0 2
55110: PPUSH
55111: EMPTY
55112: PPUSH
55113: CALL_OW 1
55117: ST_TO_ADDR
55118: GO 55093
55120: POP
55121: POP
// tmp := [ ] ;
55122: LD_ADDR_VAR 0 5
55126: PUSH
55127: EMPTY
55128: ST_TO_ADDR
// for i = 1 to mc_sides do
55129: LD_ADDR_VAR 0 2
55133: PUSH
55134: DOUBLE
55135: LD_INT 1
55137: DEC
55138: ST_TO_ADDR
55139: LD_EXP 69
55143: PUSH
55144: FOR_TO
55145: IFFALSE 55203
// if not mc_sides [ i ] in tmp then
55147: LD_EXP 69
55151: PUSH
55152: LD_VAR 0 2
55156: ARRAY
55157: PUSH
55158: LD_VAR 0 5
55162: IN
55163: NOT
55164: IFFALSE 55201
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55166: LD_ADDR_VAR 0 5
55170: PUSH
55171: LD_VAR 0 5
55175: PPUSH
55176: LD_VAR 0 5
55180: PUSH
55181: LD_INT 1
55183: PLUS
55184: PPUSH
55185: LD_EXP 69
55189: PUSH
55190: LD_VAR 0 2
55194: ARRAY
55195: PPUSH
55196: CALL_OW 2
55200: ST_TO_ADDR
55201: GO 55144
55203: POP
55204: POP
// if not tmp then
55205: LD_VAR 0 5
55209: NOT
55210: IFFALSE 55214
// exit ;
55212: GO 55319
// for j in tmp do
55214: LD_ADDR_VAR 0 3
55218: PUSH
55219: LD_VAR 0 5
55223: PUSH
55224: FOR_IN
55225: IFFALSE 55317
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55227: LD_ADDR_VAR 0 6
55231: PUSH
55232: LD_INT 22
55234: PUSH
55235: LD_VAR 0 3
55239: PUSH
55240: EMPTY
55241: LIST
55242: LIST
55243: PPUSH
55244: CALL_OW 69
55248: ST_TO_ADDR
// if not un then
55249: LD_VAR 0 6
55253: NOT
55254: IFFALSE 55258
// continue ;
55256: GO 55224
// nation := GetNation ( un [ 1 ] ) ;
55258: LD_ADDR_VAR 0 4
55262: PUSH
55263: LD_VAR 0 6
55267: PUSH
55268: LD_INT 1
55270: ARRAY
55271: PPUSH
55272: CALL_OW 248
55276: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55277: LD_ADDR_EXP 70
55281: PUSH
55282: LD_EXP 70
55286: PPUSH
55287: LD_VAR 0 3
55291: PPUSH
55292: LD_VAR 0 3
55296: PPUSH
55297: LD_VAR 0 4
55301: PPUSH
55302: LD_INT 1
55304: PPUSH
55305: CALL 9875 0 3
55309: PPUSH
55310: CALL_OW 1
55314: ST_TO_ADDR
// end ;
55315: GO 55224
55317: POP
55318: POP
// end ;
55319: LD_VAR 0 1
55323: RET
// export function MC_InitSides ( ) ; var i ; begin
55324: LD_INT 0
55326: PPUSH
55327: PPUSH
// if not mc_bases then
55328: LD_EXP 43
55332: NOT
55333: IFFALSE 55337
// exit ;
55335: GO 55411
// for i = 1 to mc_bases do
55337: LD_ADDR_VAR 0 2
55341: PUSH
55342: DOUBLE
55343: LD_INT 1
55345: DEC
55346: ST_TO_ADDR
55347: LD_EXP 43
55351: PUSH
55352: FOR_TO
55353: IFFALSE 55409
// if mc_bases [ i ] then
55355: LD_EXP 43
55359: PUSH
55360: LD_VAR 0 2
55364: ARRAY
55365: IFFALSE 55407
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55367: LD_ADDR_EXP 69
55371: PUSH
55372: LD_EXP 69
55376: PPUSH
55377: LD_VAR 0 2
55381: PPUSH
55382: LD_EXP 43
55386: PUSH
55387: LD_VAR 0 2
55391: ARRAY
55392: PUSH
55393: LD_INT 1
55395: ARRAY
55396: PPUSH
55397: CALL_OW 255
55401: PPUSH
55402: CALL_OW 1
55406: ST_TO_ADDR
55407: GO 55352
55409: POP
55410: POP
// end ;
55411: LD_VAR 0 1
55415: RET
// every 0 0$03 trigger skirmish do
55416: LD_EXP 41
55420: IFFALSE 55574
55422: GO 55424
55424: DISABLE
// begin enable ;
55425: ENABLE
// MC_CheckBuildings ( ) ;
55426: CALL 60086 0 0
// MC_CheckPeopleLife ( ) ;
55430: CALL 60247 0 0
// RaiseSailEvent ( 100 ) ;
55434: LD_INT 100
55436: PPUSH
55437: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55441: LD_INT 103
55443: PPUSH
55444: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55448: LD_INT 104
55450: PPUSH
55451: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55455: LD_INT 105
55457: PPUSH
55458: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55462: LD_INT 106
55464: PPUSH
55465: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55469: LD_INT 107
55471: PPUSH
55472: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55476: LD_INT 108
55478: PPUSH
55479: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55483: LD_INT 109
55485: PPUSH
55486: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55490: LD_INT 110
55492: PPUSH
55493: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55497: LD_INT 111
55499: PPUSH
55500: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55504: LD_INT 112
55506: PPUSH
55507: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55511: LD_INT 113
55513: PPUSH
55514: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55518: LD_INT 120
55520: PPUSH
55521: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55525: LD_INT 121
55527: PPUSH
55528: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55532: LD_INT 122
55534: PPUSH
55535: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55539: LD_INT 123
55541: PPUSH
55542: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55546: LD_INT 124
55548: PPUSH
55549: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55553: LD_INT 125
55555: PPUSH
55556: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55560: LD_INT 126
55562: PPUSH
55563: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55567: LD_INT 200
55569: PPUSH
55570: CALL_OW 427
// end ;
55574: END
// on SailEvent ( event ) do begin if event < 100 then
55575: LD_VAR 0 1
55579: PUSH
55580: LD_INT 100
55582: LESS
55583: IFFALSE 55594
// CustomEvent ( event ) ;
55585: LD_VAR 0 1
55589: PPUSH
55590: CALL 584 0 1
// if event = 100 then
55594: LD_VAR 0 1
55598: PUSH
55599: LD_INT 100
55601: EQUAL
55602: IFFALSE 55608
// MC_ClassManager ( ) ;
55604: CALL 56000 0 0
// if event = 101 then
55608: LD_VAR 0 1
55612: PUSH
55613: LD_INT 101
55615: EQUAL
55616: IFFALSE 55622
// MC_RepairBuildings ( ) ;
55618: CALL 60832 0 0
// if event = 102 then
55622: LD_VAR 0 1
55626: PUSH
55627: LD_INT 102
55629: EQUAL
55630: IFFALSE 55636
// MC_Heal ( ) ;
55632: CALL 61767 0 0
// if event = 103 then
55636: LD_VAR 0 1
55640: PUSH
55641: LD_INT 103
55643: EQUAL
55644: IFFALSE 55650
// MC_Build ( ) ;
55646: CALL 62189 0 0
// if event = 104 then
55650: LD_VAR 0 1
55654: PUSH
55655: LD_INT 104
55657: EQUAL
55658: IFFALSE 55664
// MC_TurretWeapon ( ) ;
55660: CALL 63823 0 0
// if event = 105 then
55664: LD_VAR 0 1
55668: PUSH
55669: LD_INT 105
55671: EQUAL
55672: IFFALSE 55678
// MC_BuildUpgrade ( ) ;
55674: CALL 63374 0 0
// if event = 106 then
55678: LD_VAR 0 1
55682: PUSH
55683: LD_INT 106
55685: EQUAL
55686: IFFALSE 55692
// MC_PlantMines ( ) ;
55688: CALL 64253 0 0
// if event = 107 then
55692: LD_VAR 0 1
55696: PUSH
55697: LD_INT 107
55699: EQUAL
55700: IFFALSE 55706
// MC_CollectCrates ( ) ;
55702: CALL 65051 0 0
// if event = 108 then
55706: LD_VAR 0 1
55710: PUSH
55711: LD_INT 108
55713: EQUAL
55714: IFFALSE 55720
// MC_LinkRemoteControl ( ) ;
55716: CALL 66901 0 0
// if event = 109 then
55720: LD_VAR 0 1
55724: PUSH
55725: LD_INT 109
55727: EQUAL
55728: IFFALSE 55734
// MC_ProduceVehicle ( ) ;
55730: CALL 67082 0 0
// if event = 110 then
55734: LD_VAR 0 1
55738: PUSH
55739: LD_INT 110
55741: EQUAL
55742: IFFALSE 55748
// MC_SendAttack ( ) ;
55744: CALL 67548 0 0
// if event = 111 then
55748: LD_VAR 0 1
55752: PUSH
55753: LD_INT 111
55755: EQUAL
55756: IFFALSE 55762
// MC_Defend ( ) ;
55758: CALL 67656 0 0
// if event = 112 then
55762: LD_VAR 0 1
55766: PUSH
55767: LD_INT 112
55769: EQUAL
55770: IFFALSE 55776
// MC_Research ( ) ;
55772: CALL 68536 0 0
// if event = 113 then
55776: LD_VAR 0 1
55780: PUSH
55781: LD_INT 113
55783: EQUAL
55784: IFFALSE 55790
// MC_MinesTrigger ( ) ;
55786: CALL 69650 0 0
// if event = 120 then
55790: LD_VAR 0 1
55794: PUSH
55795: LD_INT 120
55797: EQUAL
55798: IFFALSE 55804
// MC_RepairVehicle ( ) ;
55800: CALL 69749 0 0
// if event = 121 then
55804: LD_VAR 0 1
55808: PUSH
55809: LD_INT 121
55811: EQUAL
55812: IFFALSE 55818
// MC_TameApe ( ) ;
55814: CALL 70518 0 0
// if event = 122 then
55818: LD_VAR 0 1
55822: PUSH
55823: LD_INT 122
55825: EQUAL
55826: IFFALSE 55832
// MC_ChangeApeClass ( ) ;
55828: CALL 71347 0 0
// if event = 123 then
55832: LD_VAR 0 1
55836: PUSH
55837: LD_INT 123
55839: EQUAL
55840: IFFALSE 55846
// MC_Bazooka ( ) ;
55842: CALL 71997 0 0
// if event = 124 then
55846: LD_VAR 0 1
55850: PUSH
55851: LD_INT 124
55853: EQUAL
55854: IFFALSE 55860
// MC_TeleportExit ( ) ;
55856: CALL 72195 0 0
// if event = 125 then
55860: LD_VAR 0 1
55864: PUSH
55865: LD_INT 125
55867: EQUAL
55868: IFFALSE 55874
// MC_Deposits ( ) ;
55870: CALL 72842 0 0
// if event = 126 then
55874: LD_VAR 0 1
55878: PUSH
55879: LD_INT 126
55881: EQUAL
55882: IFFALSE 55888
// MC_RemoteDriver ( ) ;
55884: CALL 73467 0 0
// if event = 200 then
55888: LD_VAR 0 1
55892: PUSH
55893: LD_INT 200
55895: EQUAL
55896: IFFALSE 55902
// MC_Idle ( ) ;
55898: CALL 75374 0 0
// end ;
55902: PPOPN 1
55904: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55905: LD_INT 0
55907: PPUSH
55908: PPUSH
// if not mc_bases [ base ] or not tag then
55909: LD_EXP 43
55913: PUSH
55914: LD_VAR 0 1
55918: ARRAY
55919: NOT
55920: PUSH
55921: LD_VAR 0 2
55925: NOT
55926: OR
55927: IFFALSE 55931
// exit ;
55929: GO 55995
// for i in mc_bases [ base ] union mc_ape [ base ] do
55931: LD_ADDR_VAR 0 4
55935: PUSH
55936: LD_EXP 43
55940: PUSH
55941: LD_VAR 0 1
55945: ARRAY
55946: PUSH
55947: LD_EXP 72
55951: PUSH
55952: LD_VAR 0 1
55956: ARRAY
55957: UNION
55958: PUSH
55959: FOR_IN
55960: IFFALSE 55993
// if GetTag ( i ) = tag then
55962: LD_VAR 0 4
55966: PPUSH
55967: CALL_OW 110
55971: PUSH
55972: LD_VAR 0 2
55976: EQUAL
55977: IFFALSE 55991
// SetTag ( i , 0 ) ;
55979: LD_VAR 0 4
55983: PPUSH
55984: LD_INT 0
55986: PPUSH
55987: CALL_OW 109
55991: GO 55959
55993: POP
55994: POP
// end ;
55995: LD_VAR 0 3
55999: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56000: LD_INT 0
56002: PPUSH
56003: PPUSH
56004: PPUSH
56005: PPUSH
56006: PPUSH
56007: PPUSH
56008: PPUSH
56009: PPUSH
// if not mc_bases then
56010: LD_EXP 43
56014: NOT
56015: IFFALSE 56019
// exit ;
56017: GO 56468
// for i = 1 to mc_bases do
56019: LD_ADDR_VAR 0 2
56023: PUSH
56024: DOUBLE
56025: LD_INT 1
56027: DEC
56028: ST_TO_ADDR
56029: LD_EXP 43
56033: PUSH
56034: FOR_TO
56035: IFFALSE 56466
// begin tmp := MC_ClassCheckReq ( i ) ;
56037: LD_ADDR_VAR 0 4
56041: PUSH
56042: LD_VAR 0 2
56046: PPUSH
56047: CALL 56473 0 1
56051: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56052: LD_ADDR_EXP 84
56056: PUSH
56057: LD_EXP 84
56061: PPUSH
56062: LD_VAR 0 2
56066: PPUSH
56067: LD_VAR 0 4
56071: PPUSH
56072: CALL_OW 1
56076: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56077: LD_ADDR_VAR 0 6
56081: PUSH
56082: LD_EXP 43
56086: PUSH
56087: LD_VAR 0 2
56091: ARRAY
56092: PPUSH
56093: LD_INT 2
56095: PUSH
56096: LD_INT 30
56098: PUSH
56099: LD_INT 4
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: PUSH
56106: LD_INT 30
56108: PUSH
56109: LD_INT 5
56111: PUSH
56112: EMPTY
56113: LIST
56114: LIST
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: LIST
56120: PPUSH
56121: CALL_OW 72
56125: PUSH
56126: LD_EXP 43
56130: PUSH
56131: LD_VAR 0 2
56135: ARRAY
56136: PPUSH
56137: LD_INT 2
56139: PUSH
56140: LD_INT 30
56142: PUSH
56143: LD_INT 0
56145: PUSH
56146: EMPTY
56147: LIST
56148: LIST
56149: PUSH
56150: LD_INT 30
56152: PUSH
56153: LD_INT 1
56155: PUSH
56156: EMPTY
56157: LIST
56158: LIST
56159: PUSH
56160: EMPTY
56161: LIST
56162: LIST
56163: LIST
56164: PPUSH
56165: CALL_OW 72
56169: PUSH
56170: LD_EXP 43
56174: PUSH
56175: LD_VAR 0 2
56179: ARRAY
56180: PPUSH
56181: LD_INT 30
56183: PUSH
56184: LD_INT 3
56186: PUSH
56187: EMPTY
56188: LIST
56189: LIST
56190: PPUSH
56191: CALL_OW 72
56195: PUSH
56196: LD_EXP 43
56200: PUSH
56201: LD_VAR 0 2
56205: ARRAY
56206: PPUSH
56207: LD_INT 2
56209: PUSH
56210: LD_INT 30
56212: PUSH
56213: LD_INT 6
56215: PUSH
56216: EMPTY
56217: LIST
56218: LIST
56219: PUSH
56220: LD_INT 30
56222: PUSH
56223: LD_INT 7
56225: PUSH
56226: EMPTY
56227: LIST
56228: LIST
56229: PUSH
56230: LD_INT 30
56232: PUSH
56233: LD_INT 8
56235: PUSH
56236: EMPTY
56237: LIST
56238: LIST
56239: PUSH
56240: EMPTY
56241: LIST
56242: LIST
56243: LIST
56244: LIST
56245: PPUSH
56246: CALL_OW 72
56250: PUSH
56251: EMPTY
56252: LIST
56253: LIST
56254: LIST
56255: LIST
56256: ST_TO_ADDR
// for j := 1 to 4 do
56257: LD_ADDR_VAR 0 3
56261: PUSH
56262: DOUBLE
56263: LD_INT 1
56265: DEC
56266: ST_TO_ADDR
56267: LD_INT 4
56269: PUSH
56270: FOR_TO
56271: IFFALSE 56462
// begin if not tmp [ j ] then
56273: LD_VAR 0 4
56277: PUSH
56278: LD_VAR 0 3
56282: ARRAY
56283: NOT
56284: IFFALSE 56288
// continue ;
56286: GO 56270
// for p in tmp [ j ] do
56288: LD_ADDR_VAR 0 5
56292: PUSH
56293: LD_VAR 0 4
56297: PUSH
56298: LD_VAR 0 3
56302: ARRAY
56303: PUSH
56304: FOR_IN
56305: IFFALSE 56458
// begin if not b [ j ] then
56307: LD_VAR 0 6
56311: PUSH
56312: LD_VAR 0 3
56316: ARRAY
56317: NOT
56318: IFFALSE 56322
// break ;
56320: GO 56458
// e := 0 ;
56322: LD_ADDR_VAR 0 7
56326: PUSH
56327: LD_INT 0
56329: ST_TO_ADDR
// for k in b [ j ] do
56330: LD_ADDR_VAR 0 8
56334: PUSH
56335: LD_VAR 0 6
56339: PUSH
56340: LD_VAR 0 3
56344: ARRAY
56345: PUSH
56346: FOR_IN
56347: IFFALSE 56374
// if IsNotFull ( k ) then
56349: LD_VAR 0 8
56353: PPUSH
56354: CALL 11996 0 1
56358: IFFALSE 56372
// begin e := k ;
56360: LD_ADDR_VAR 0 7
56364: PUSH
56365: LD_VAR 0 8
56369: ST_TO_ADDR
// break ;
56370: GO 56374
// end ;
56372: GO 56346
56374: POP
56375: POP
// if e and not UnitGoingToBuilding ( p , e ) then
56376: LD_VAR 0 7
56380: PUSH
56381: LD_VAR 0 5
56385: PPUSH
56386: LD_VAR 0 7
56390: PPUSH
56391: CALL 46146 0 2
56395: NOT
56396: AND
56397: IFFALSE 56456
// begin if IsInUnit ( p ) then
56399: LD_VAR 0 5
56403: PPUSH
56404: CALL_OW 310
56408: IFFALSE 56419
// ComExitBuilding ( p ) ;
56410: LD_VAR 0 5
56414: PPUSH
56415: CALL_OW 122
// ComEnterUnit ( p , e ) ;
56419: LD_VAR 0 5
56423: PPUSH
56424: LD_VAR 0 7
56428: PPUSH
56429: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56433: LD_VAR 0 5
56437: PPUSH
56438: LD_VAR 0 3
56442: PPUSH
56443: CALL_OW 183
// AddComExitBuilding ( p ) ;
56447: LD_VAR 0 5
56451: PPUSH
56452: CALL_OW 182
// end ; end ;
56456: GO 56304
56458: POP
56459: POP
// end ;
56460: GO 56270
56462: POP
56463: POP
// end ;
56464: GO 56034
56466: POP
56467: POP
// end ;
56468: LD_VAR 0 1
56472: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56473: LD_INT 0
56475: PPUSH
56476: PPUSH
56477: PPUSH
56478: PPUSH
56479: PPUSH
56480: PPUSH
56481: PPUSH
56482: PPUSH
56483: PPUSH
56484: PPUSH
56485: PPUSH
56486: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
56487: LD_ADDR_VAR 0 2
56491: PUSH
56492: LD_INT 0
56494: PUSH
56495: LD_INT 0
56497: PUSH
56498: LD_INT 0
56500: PUSH
56501: LD_INT 0
56503: PUSH
56504: EMPTY
56505: LIST
56506: LIST
56507: LIST
56508: LIST
56509: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56510: LD_VAR 0 1
56514: NOT
56515: PUSH
56516: LD_EXP 43
56520: PUSH
56521: LD_VAR 0 1
56525: ARRAY
56526: NOT
56527: OR
56528: PUSH
56529: LD_EXP 43
56533: PUSH
56534: LD_VAR 0 1
56538: ARRAY
56539: PPUSH
56540: LD_INT 2
56542: PUSH
56543: LD_INT 30
56545: PUSH
56546: LD_INT 0
56548: PUSH
56549: EMPTY
56550: LIST
56551: LIST
56552: PUSH
56553: LD_INT 30
56555: PUSH
56556: LD_INT 1
56558: PUSH
56559: EMPTY
56560: LIST
56561: LIST
56562: PUSH
56563: EMPTY
56564: LIST
56565: LIST
56566: LIST
56567: PPUSH
56568: CALL_OW 72
56572: NOT
56573: OR
56574: IFFALSE 56578
// exit ;
56576: GO 60081
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56578: LD_ADDR_VAR 0 4
56582: PUSH
56583: LD_EXP 43
56587: PUSH
56588: LD_VAR 0 1
56592: ARRAY
56593: PPUSH
56594: LD_INT 2
56596: PUSH
56597: LD_INT 25
56599: PUSH
56600: LD_INT 1
56602: PUSH
56603: EMPTY
56604: LIST
56605: LIST
56606: PUSH
56607: LD_INT 25
56609: PUSH
56610: LD_INT 2
56612: PUSH
56613: EMPTY
56614: LIST
56615: LIST
56616: PUSH
56617: LD_INT 25
56619: PUSH
56620: LD_INT 3
56622: PUSH
56623: EMPTY
56624: LIST
56625: LIST
56626: PUSH
56627: LD_INT 25
56629: PUSH
56630: LD_INT 4
56632: PUSH
56633: EMPTY
56634: LIST
56635: LIST
56636: PUSH
56637: LD_INT 25
56639: PUSH
56640: LD_INT 5
56642: PUSH
56643: EMPTY
56644: LIST
56645: LIST
56646: PUSH
56647: LD_INT 25
56649: PUSH
56650: LD_INT 8
56652: PUSH
56653: EMPTY
56654: LIST
56655: LIST
56656: PUSH
56657: LD_INT 25
56659: PUSH
56660: LD_INT 9
56662: PUSH
56663: EMPTY
56664: LIST
56665: LIST
56666: PUSH
56667: EMPTY
56668: LIST
56669: LIST
56670: LIST
56671: LIST
56672: LIST
56673: LIST
56674: LIST
56675: LIST
56676: PPUSH
56677: CALL_OW 72
56681: ST_TO_ADDR
// if not tmp then
56682: LD_VAR 0 4
56686: NOT
56687: IFFALSE 56691
// exit ;
56689: GO 60081
// for i in tmp do
56691: LD_ADDR_VAR 0 3
56695: PUSH
56696: LD_VAR 0 4
56700: PUSH
56701: FOR_IN
56702: IFFALSE 56733
// if GetTag ( i ) then
56704: LD_VAR 0 3
56708: PPUSH
56709: CALL_OW 110
56713: IFFALSE 56731
// tmp := tmp diff i ;
56715: LD_ADDR_VAR 0 4
56719: PUSH
56720: LD_VAR 0 4
56724: PUSH
56725: LD_VAR 0 3
56729: DIFF
56730: ST_TO_ADDR
56731: GO 56701
56733: POP
56734: POP
// if not tmp then
56735: LD_VAR 0 4
56739: NOT
56740: IFFALSE 56744
// exit ;
56742: GO 60081
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56744: LD_ADDR_VAR 0 5
56748: PUSH
56749: LD_EXP 43
56753: PUSH
56754: LD_VAR 0 1
56758: ARRAY
56759: PPUSH
56760: LD_INT 2
56762: PUSH
56763: LD_INT 25
56765: PUSH
56766: LD_INT 1
56768: PUSH
56769: EMPTY
56770: LIST
56771: LIST
56772: PUSH
56773: LD_INT 25
56775: PUSH
56776: LD_INT 5
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: PUSH
56783: LD_INT 25
56785: PUSH
56786: LD_INT 8
56788: PUSH
56789: EMPTY
56790: LIST
56791: LIST
56792: PUSH
56793: LD_INT 25
56795: PUSH
56796: LD_INT 9
56798: PUSH
56799: EMPTY
56800: LIST
56801: LIST
56802: PUSH
56803: EMPTY
56804: LIST
56805: LIST
56806: LIST
56807: LIST
56808: LIST
56809: PPUSH
56810: CALL_OW 72
56814: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56815: LD_ADDR_VAR 0 6
56819: PUSH
56820: LD_EXP 43
56824: PUSH
56825: LD_VAR 0 1
56829: ARRAY
56830: PPUSH
56831: LD_INT 25
56833: PUSH
56834: LD_INT 2
56836: PUSH
56837: EMPTY
56838: LIST
56839: LIST
56840: PPUSH
56841: CALL_OW 72
56845: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56846: LD_ADDR_VAR 0 7
56850: PUSH
56851: LD_EXP 43
56855: PUSH
56856: LD_VAR 0 1
56860: ARRAY
56861: PPUSH
56862: LD_INT 25
56864: PUSH
56865: LD_INT 3
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: PPUSH
56872: CALL_OW 72
56876: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56877: LD_ADDR_VAR 0 8
56881: PUSH
56882: LD_EXP 43
56886: PUSH
56887: LD_VAR 0 1
56891: ARRAY
56892: PPUSH
56893: LD_INT 25
56895: PUSH
56896: LD_INT 4
56898: PUSH
56899: EMPTY
56900: LIST
56901: LIST
56902: PUSH
56903: LD_INT 24
56905: PUSH
56906: LD_INT 251
56908: PUSH
56909: EMPTY
56910: LIST
56911: LIST
56912: PUSH
56913: EMPTY
56914: LIST
56915: LIST
56916: PPUSH
56917: CALL_OW 72
56921: ST_TO_ADDR
// if mc_is_defending [ base ] then
56922: LD_EXP 86
56926: PUSH
56927: LD_VAR 0 1
56931: ARRAY
56932: IFFALSE 57393
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56934: LD_ADDR_EXP 85
56938: PUSH
56939: LD_EXP 85
56943: PPUSH
56944: LD_VAR 0 1
56948: PPUSH
56949: LD_INT 4
56951: PPUSH
56952: CALL_OW 1
56956: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56957: LD_ADDR_VAR 0 12
56961: PUSH
56962: LD_EXP 43
56966: PUSH
56967: LD_VAR 0 1
56971: ARRAY
56972: PPUSH
56973: LD_INT 2
56975: PUSH
56976: LD_INT 30
56978: PUSH
56979: LD_INT 4
56981: PUSH
56982: EMPTY
56983: LIST
56984: LIST
56985: PUSH
56986: LD_INT 30
56988: PUSH
56989: LD_INT 5
56991: PUSH
56992: EMPTY
56993: LIST
56994: LIST
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: LIST
57000: PPUSH
57001: CALL_OW 72
57005: ST_TO_ADDR
// if not b then
57006: LD_VAR 0 12
57010: NOT
57011: IFFALSE 57015
// exit ;
57013: GO 60081
// p := [ ] ;
57015: LD_ADDR_VAR 0 11
57019: PUSH
57020: EMPTY
57021: ST_TO_ADDR
// if sci >= 2 then
57022: LD_VAR 0 8
57026: PUSH
57027: LD_INT 2
57029: GREATEREQUAL
57030: IFFALSE 57061
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57032: LD_ADDR_VAR 0 8
57036: PUSH
57037: LD_VAR 0 8
57041: PUSH
57042: LD_INT 1
57044: ARRAY
57045: PUSH
57046: LD_VAR 0 8
57050: PUSH
57051: LD_INT 2
57053: ARRAY
57054: PUSH
57055: EMPTY
57056: LIST
57057: LIST
57058: ST_TO_ADDR
57059: GO 57122
// if sci = 1 then
57061: LD_VAR 0 8
57065: PUSH
57066: LD_INT 1
57068: EQUAL
57069: IFFALSE 57090
// sci := [ sci [ 1 ] ] else
57071: LD_ADDR_VAR 0 8
57075: PUSH
57076: LD_VAR 0 8
57080: PUSH
57081: LD_INT 1
57083: ARRAY
57084: PUSH
57085: EMPTY
57086: LIST
57087: ST_TO_ADDR
57088: GO 57122
// if sci = 0 then
57090: LD_VAR 0 8
57094: PUSH
57095: LD_INT 0
57097: EQUAL
57098: IFFALSE 57122
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57100: LD_ADDR_VAR 0 11
57104: PUSH
57105: LD_VAR 0 4
57109: PPUSH
57110: LD_INT 4
57112: PPUSH
57113: CALL 46018 0 2
57117: PUSH
57118: LD_INT 1
57120: ARRAY
57121: ST_TO_ADDR
// if eng > 4 then
57122: LD_VAR 0 6
57126: PUSH
57127: LD_INT 4
57129: GREATER
57130: IFFALSE 57176
// for i = eng downto 4 do
57132: LD_ADDR_VAR 0 3
57136: PUSH
57137: DOUBLE
57138: LD_VAR 0 6
57142: INC
57143: ST_TO_ADDR
57144: LD_INT 4
57146: PUSH
57147: FOR_DOWNTO
57148: IFFALSE 57174
// eng := eng diff eng [ i ] ;
57150: LD_ADDR_VAR 0 6
57154: PUSH
57155: LD_VAR 0 6
57159: PUSH
57160: LD_VAR 0 6
57164: PUSH
57165: LD_VAR 0 3
57169: ARRAY
57170: DIFF
57171: ST_TO_ADDR
57172: GO 57147
57174: POP
57175: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57176: LD_ADDR_VAR 0 4
57180: PUSH
57181: LD_VAR 0 4
57185: PUSH
57186: LD_VAR 0 5
57190: PUSH
57191: LD_VAR 0 6
57195: UNION
57196: PUSH
57197: LD_VAR 0 7
57201: UNION
57202: PUSH
57203: LD_VAR 0 8
57207: UNION
57208: DIFF
57209: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57210: LD_ADDR_VAR 0 13
57214: PUSH
57215: LD_EXP 43
57219: PUSH
57220: LD_VAR 0 1
57224: ARRAY
57225: PPUSH
57226: LD_INT 2
57228: PUSH
57229: LD_INT 30
57231: PUSH
57232: LD_INT 32
57234: PUSH
57235: EMPTY
57236: LIST
57237: LIST
57238: PUSH
57239: LD_INT 30
57241: PUSH
57242: LD_INT 31
57244: PUSH
57245: EMPTY
57246: LIST
57247: LIST
57248: PUSH
57249: EMPTY
57250: LIST
57251: LIST
57252: LIST
57253: PPUSH
57254: CALL_OW 72
57258: PUSH
57259: LD_EXP 43
57263: PUSH
57264: LD_VAR 0 1
57268: ARRAY
57269: PPUSH
57270: LD_INT 2
57272: PUSH
57273: LD_INT 30
57275: PUSH
57276: LD_INT 4
57278: PUSH
57279: EMPTY
57280: LIST
57281: LIST
57282: PUSH
57283: LD_INT 30
57285: PUSH
57286: LD_INT 5
57288: PUSH
57289: EMPTY
57290: LIST
57291: LIST
57292: PUSH
57293: EMPTY
57294: LIST
57295: LIST
57296: LIST
57297: PPUSH
57298: CALL_OW 72
57302: PUSH
57303: LD_INT 6
57305: MUL
57306: PLUS
57307: ST_TO_ADDR
// if bcount < tmp then
57308: LD_VAR 0 13
57312: PUSH
57313: LD_VAR 0 4
57317: LESS
57318: IFFALSE 57364
// for i = tmp downto bcount do
57320: LD_ADDR_VAR 0 3
57324: PUSH
57325: DOUBLE
57326: LD_VAR 0 4
57330: INC
57331: ST_TO_ADDR
57332: LD_VAR 0 13
57336: PUSH
57337: FOR_DOWNTO
57338: IFFALSE 57362
// tmp := Delete ( tmp , tmp ) ;
57340: LD_ADDR_VAR 0 4
57344: PUSH
57345: LD_VAR 0 4
57349: PPUSH
57350: LD_VAR 0 4
57354: PPUSH
57355: CALL_OW 3
57359: ST_TO_ADDR
57360: GO 57337
57362: POP
57363: POP
// result := [ tmp , 0 , 0 , p ] ;
57364: LD_ADDR_VAR 0 2
57368: PUSH
57369: LD_VAR 0 4
57373: PUSH
57374: LD_INT 0
57376: PUSH
57377: LD_INT 0
57379: PUSH
57380: LD_VAR 0 11
57384: PUSH
57385: EMPTY
57386: LIST
57387: LIST
57388: LIST
57389: LIST
57390: ST_TO_ADDR
// exit ;
57391: GO 60081
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57393: LD_EXP 43
57397: PUSH
57398: LD_VAR 0 1
57402: ARRAY
57403: PPUSH
57404: LD_INT 2
57406: PUSH
57407: LD_INT 30
57409: PUSH
57410: LD_INT 6
57412: PUSH
57413: EMPTY
57414: LIST
57415: LIST
57416: PUSH
57417: LD_INT 30
57419: PUSH
57420: LD_INT 7
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: PUSH
57427: LD_INT 30
57429: PUSH
57430: LD_INT 8
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: PUSH
57437: EMPTY
57438: LIST
57439: LIST
57440: LIST
57441: LIST
57442: PPUSH
57443: CALL_OW 72
57447: NOT
57448: PUSH
57449: LD_EXP 43
57453: PUSH
57454: LD_VAR 0 1
57458: ARRAY
57459: PPUSH
57460: LD_INT 30
57462: PUSH
57463: LD_INT 3
57465: PUSH
57466: EMPTY
57467: LIST
57468: LIST
57469: PPUSH
57470: CALL_OW 72
57474: NOT
57475: AND
57476: IFFALSE 57548
// begin if eng = tmp then
57478: LD_VAR 0 6
57482: PUSH
57483: LD_VAR 0 4
57487: EQUAL
57488: IFFALSE 57492
// exit ;
57490: GO 60081
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57492: LD_ADDR_EXP 85
57496: PUSH
57497: LD_EXP 85
57501: PPUSH
57502: LD_VAR 0 1
57506: PPUSH
57507: LD_INT 1
57509: PPUSH
57510: CALL_OW 1
57514: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57515: LD_ADDR_VAR 0 2
57519: PUSH
57520: LD_INT 0
57522: PUSH
57523: LD_VAR 0 4
57527: PUSH
57528: LD_VAR 0 6
57532: DIFF
57533: PUSH
57534: LD_INT 0
57536: PUSH
57537: LD_INT 0
57539: PUSH
57540: EMPTY
57541: LIST
57542: LIST
57543: LIST
57544: LIST
57545: ST_TO_ADDR
// exit ;
57546: GO 60081
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57548: LD_EXP 70
57552: PUSH
57553: LD_EXP 69
57557: PUSH
57558: LD_VAR 0 1
57562: ARRAY
57563: ARRAY
57564: PUSH
57565: LD_EXP 43
57569: PUSH
57570: LD_VAR 0 1
57574: ARRAY
57575: PPUSH
57576: LD_INT 2
57578: PUSH
57579: LD_INT 30
57581: PUSH
57582: LD_INT 6
57584: PUSH
57585: EMPTY
57586: LIST
57587: LIST
57588: PUSH
57589: LD_INT 30
57591: PUSH
57592: LD_INT 7
57594: PUSH
57595: EMPTY
57596: LIST
57597: LIST
57598: PUSH
57599: LD_INT 30
57601: PUSH
57602: LD_INT 8
57604: PUSH
57605: EMPTY
57606: LIST
57607: LIST
57608: PUSH
57609: EMPTY
57610: LIST
57611: LIST
57612: LIST
57613: LIST
57614: PPUSH
57615: CALL_OW 72
57619: AND
57620: PUSH
57621: LD_EXP 43
57625: PUSH
57626: LD_VAR 0 1
57630: ARRAY
57631: PPUSH
57632: LD_INT 30
57634: PUSH
57635: LD_INT 3
57637: PUSH
57638: EMPTY
57639: LIST
57640: LIST
57641: PPUSH
57642: CALL_OW 72
57646: NOT
57647: AND
57648: IFFALSE 57862
// begin if sci >= 6 then
57650: LD_VAR 0 8
57654: PUSH
57655: LD_INT 6
57657: GREATEREQUAL
57658: IFFALSE 57662
// exit ;
57660: GO 60081
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57662: LD_ADDR_EXP 85
57666: PUSH
57667: LD_EXP 85
57671: PPUSH
57672: LD_VAR 0 1
57676: PPUSH
57677: LD_INT 2
57679: PPUSH
57680: CALL_OW 1
57684: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57685: LD_ADDR_VAR 0 9
57689: PUSH
57690: LD_VAR 0 4
57694: PUSH
57695: LD_VAR 0 8
57699: DIFF
57700: PPUSH
57701: LD_INT 4
57703: PPUSH
57704: CALL 46018 0 2
57708: ST_TO_ADDR
// p := [ ] ;
57709: LD_ADDR_VAR 0 11
57713: PUSH
57714: EMPTY
57715: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57716: LD_VAR 0 8
57720: PUSH
57721: LD_INT 6
57723: LESS
57724: PUSH
57725: LD_VAR 0 9
57729: PUSH
57730: LD_INT 6
57732: GREATER
57733: AND
57734: IFFALSE 57815
// begin for i = 1 to 6 - sci do
57736: LD_ADDR_VAR 0 3
57740: PUSH
57741: DOUBLE
57742: LD_INT 1
57744: DEC
57745: ST_TO_ADDR
57746: LD_INT 6
57748: PUSH
57749: LD_VAR 0 8
57753: MINUS
57754: PUSH
57755: FOR_TO
57756: IFFALSE 57811
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57758: LD_ADDR_VAR 0 11
57762: PUSH
57763: LD_VAR 0 11
57767: PPUSH
57768: LD_VAR 0 11
57772: PUSH
57773: LD_INT 1
57775: PLUS
57776: PPUSH
57777: LD_VAR 0 9
57781: PUSH
57782: LD_INT 1
57784: ARRAY
57785: PPUSH
57786: CALL_OW 2
57790: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57791: LD_ADDR_VAR 0 9
57795: PUSH
57796: LD_VAR 0 9
57800: PPUSH
57801: LD_INT 1
57803: PPUSH
57804: CALL_OW 3
57808: ST_TO_ADDR
// end ;
57809: GO 57755
57811: POP
57812: POP
// end else
57813: GO 57835
// if sort then
57815: LD_VAR 0 9
57819: IFFALSE 57835
// p := sort [ 1 ] ;
57821: LD_ADDR_VAR 0 11
57825: PUSH
57826: LD_VAR 0 9
57830: PUSH
57831: LD_INT 1
57833: ARRAY
57834: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57835: LD_ADDR_VAR 0 2
57839: PUSH
57840: LD_INT 0
57842: PUSH
57843: LD_INT 0
57845: PUSH
57846: LD_INT 0
57848: PUSH
57849: LD_VAR 0 11
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: LIST
57858: LIST
57859: ST_TO_ADDR
// exit ;
57860: GO 60081
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57862: LD_EXP 70
57866: PUSH
57867: LD_EXP 69
57871: PUSH
57872: LD_VAR 0 1
57876: ARRAY
57877: ARRAY
57878: PUSH
57879: LD_EXP 43
57883: PUSH
57884: LD_VAR 0 1
57888: ARRAY
57889: PPUSH
57890: LD_INT 2
57892: PUSH
57893: LD_INT 30
57895: PUSH
57896: LD_INT 6
57898: PUSH
57899: EMPTY
57900: LIST
57901: LIST
57902: PUSH
57903: LD_INT 30
57905: PUSH
57906: LD_INT 7
57908: PUSH
57909: EMPTY
57910: LIST
57911: LIST
57912: PUSH
57913: LD_INT 30
57915: PUSH
57916: LD_INT 8
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: PUSH
57923: EMPTY
57924: LIST
57925: LIST
57926: LIST
57927: LIST
57928: PPUSH
57929: CALL_OW 72
57933: AND
57934: PUSH
57935: LD_EXP 43
57939: PUSH
57940: LD_VAR 0 1
57944: ARRAY
57945: PPUSH
57946: LD_INT 30
57948: PUSH
57949: LD_INT 3
57951: PUSH
57952: EMPTY
57953: LIST
57954: LIST
57955: PPUSH
57956: CALL_OW 72
57960: AND
57961: IFFALSE 58695
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57963: LD_ADDR_EXP 85
57967: PUSH
57968: LD_EXP 85
57972: PPUSH
57973: LD_VAR 0 1
57977: PPUSH
57978: LD_INT 3
57980: PPUSH
57981: CALL_OW 1
57985: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57986: LD_ADDR_VAR 0 2
57990: PUSH
57991: LD_INT 0
57993: PUSH
57994: LD_INT 0
57996: PUSH
57997: LD_INT 0
57999: PUSH
58000: LD_INT 0
58002: PUSH
58003: EMPTY
58004: LIST
58005: LIST
58006: LIST
58007: LIST
58008: ST_TO_ADDR
// if not eng then
58009: LD_VAR 0 6
58013: NOT
58014: IFFALSE 58077
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58016: LD_ADDR_VAR 0 11
58020: PUSH
58021: LD_VAR 0 4
58025: PPUSH
58026: LD_INT 2
58028: PPUSH
58029: CALL 46018 0 2
58033: PUSH
58034: LD_INT 1
58036: ARRAY
58037: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58038: LD_ADDR_VAR 0 2
58042: PUSH
58043: LD_VAR 0 2
58047: PPUSH
58048: LD_INT 2
58050: PPUSH
58051: LD_VAR 0 11
58055: PPUSH
58056: CALL_OW 1
58060: ST_TO_ADDR
// tmp := tmp diff p ;
58061: LD_ADDR_VAR 0 4
58065: PUSH
58066: LD_VAR 0 4
58070: PUSH
58071: LD_VAR 0 11
58075: DIFF
58076: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58077: LD_VAR 0 4
58081: PUSH
58082: LD_VAR 0 8
58086: PUSH
58087: LD_INT 6
58089: LESS
58090: AND
58091: IFFALSE 58279
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58093: LD_ADDR_VAR 0 9
58097: PUSH
58098: LD_VAR 0 4
58102: PUSH
58103: LD_VAR 0 8
58107: PUSH
58108: LD_VAR 0 7
58112: UNION
58113: DIFF
58114: PPUSH
58115: LD_INT 4
58117: PPUSH
58118: CALL 46018 0 2
58122: ST_TO_ADDR
// p := [ ] ;
58123: LD_ADDR_VAR 0 11
58127: PUSH
58128: EMPTY
58129: ST_TO_ADDR
// if sort then
58130: LD_VAR 0 9
58134: IFFALSE 58250
// for i = 1 to 6 - sci do
58136: LD_ADDR_VAR 0 3
58140: PUSH
58141: DOUBLE
58142: LD_INT 1
58144: DEC
58145: ST_TO_ADDR
58146: LD_INT 6
58148: PUSH
58149: LD_VAR 0 8
58153: MINUS
58154: PUSH
58155: FOR_TO
58156: IFFALSE 58248
// begin if i = sort then
58158: LD_VAR 0 3
58162: PUSH
58163: LD_VAR 0 9
58167: EQUAL
58168: IFFALSE 58172
// break ;
58170: GO 58248
// if GetClass ( i ) = 4 then
58172: LD_VAR 0 3
58176: PPUSH
58177: CALL_OW 257
58181: PUSH
58182: LD_INT 4
58184: EQUAL
58185: IFFALSE 58189
// continue ;
58187: GO 58155
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58189: LD_ADDR_VAR 0 11
58193: PUSH
58194: LD_VAR 0 11
58198: PPUSH
58199: LD_VAR 0 11
58203: PUSH
58204: LD_INT 1
58206: PLUS
58207: PPUSH
58208: LD_VAR 0 9
58212: PUSH
58213: LD_VAR 0 3
58217: ARRAY
58218: PPUSH
58219: CALL_OW 2
58223: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58224: LD_ADDR_VAR 0 4
58228: PUSH
58229: LD_VAR 0 4
58233: PUSH
58234: LD_VAR 0 9
58238: PUSH
58239: LD_VAR 0 3
58243: ARRAY
58244: DIFF
58245: ST_TO_ADDR
// end ;
58246: GO 58155
58248: POP
58249: POP
// if p then
58250: LD_VAR 0 11
58254: IFFALSE 58279
// result := Replace ( result , 4 , p ) ;
58256: LD_ADDR_VAR 0 2
58260: PUSH
58261: LD_VAR 0 2
58265: PPUSH
58266: LD_INT 4
58268: PPUSH
58269: LD_VAR 0 11
58273: PPUSH
58274: CALL_OW 1
58278: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58279: LD_VAR 0 4
58283: PUSH
58284: LD_VAR 0 7
58288: PUSH
58289: LD_INT 6
58291: LESS
58292: AND
58293: IFFALSE 58481
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58295: LD_ADDR_VAR 0 9
58299: PUSH
58300: LD_VAR 0 4
58304: PUSH
58305: LD_VAR 0 8
58309: PUSH
58310: LD_VAR 0 7
58314: UNION
58315: DIFF
58316: PPUSH
58317: LD_INT 3
58319: PPUSH
58320: CALL 46018 0 2
58324: ST_TO_ADDR
// p := [ ] ;
58325: LD_ADDR_VAR 0 11
58329: PUSH
58330: EMPTY
58331: ST_TO_ADDR
// if sort then
58332: LD_VAR 0 9
58336: IFFALSE 58452
// for i = 1 to 6 - mech do
58338: LD_ADDR_VAR 0 3
58342: PUSH
58343: DOUBLE
58344: LD_INT 1
58346: DEC
58347: ST_TO_ADDR
58348: LD_INT 6
58350: PUSH
58351: LD_VAR 0 7
58355: MINUS
58356: PUSH
58357: FOR_TO
58358: IFFALSE 58450
// begin if i = sort then
58360: LD_VAR 0 3
58364: PUSH
58365: LD_VAR 0 9
58369: EQUAL
58370: IFFALSE 58374
// break ;
58372: GO 58450
// if GetClass ( i ) = 3 then
58374: LD_VAR 0 3
58378: PPUSH
58379: CALL_OW 257
58383: PUSH
58384: LD_INT 3
58386: EQUAL
58387: IFFALSE 58391
// continue ;
58389: GO 58357
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58391: LD_ADDR_VAR 0 11
58395: PUSH
58396: LD_VAR 0 11
58400: PPUSH
58401: LD_VAR 0 11
58405: PUSH
58406: LD_INT 1
58408: PLUS
58409: PPUSH
58410: LD_VAR 0 9
58414: PUSH
58415: LD_VAR 0 3
58419: ARRAY
58420: PPUSH
58421: CALL_OW 2
58425: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58426: LD_ADDR_VAR 0 4
58430: PUSH
58431: LD_VAR 0 4
58435: PUSH
58436: LD_VAR 0 9
58440: PUSH
58441: LD_VAR 0 3
58445: ARRAY
58446: DIFF
58447: ST_TO_ADDR
// end ;
58448: GO 58357
58450: POP
58451: POP
// if p then
58452: LD_VAR 0 11
58456: IFFALSE 58481
// result := Replace ( result , 3 , p ) ;
58458: LD_ADDR_VAR 0 2
58462: PUSH
58463: LD_VAR 0 2
58467: PPUSH
58468: LD_INT 3
58470: PPUSH
58471: LD_VAR 0 11
58475: PPUSH
58476: CALL_OW 1
58480: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58481: LD_VAR 0 4
58485: PUSH
58486: LD_INT 6
58488: GREATER
58489: PUSH
58490: LD_VAR 0 6
58494: PUSH
58495: LD_INT 6
58497: LESS
58498: AND
58499: IFFALSE 58693
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58501: LD_ADDR_VAR 0 9
58505: PUSH
58506: LD_VAR 0 4
58510: PUSH
58511: LD_VAR 0 8
58515: PUSH
58516: LD_VAR 0 7
58520: UNION
58521: PUSH
58522: LD_VAR 0 6
58526: UNION
58527: DIFF
58528: PPUSH
58529: LD_INT 2
58531: PPUSH
58532: CALL 46018 0 2
58536: ST_TO_ADDR
// p := [ ] ;
58537: LD_ADDR_VAR 0 11
58541: PUSH
58542: EMPTY
58543: ST_TO_ADDR
// if sort then
58544: LD_VAR 0 9
58548: IFFALSE 58664
// for i = 1 to 6 - eng do
58550: LD_ADDR_VAR 0 3
58554: PUSH
58555: DOUBLE
58556: LD_INT 1
58558: DEC
58559: ST_TO_ADDR
58560: LD_INT 6
58562: PUSH
58563: LD_VAR 0 6
58567: MINUS
58568: PUSH
58569: FOR_TO
58570: IFFALSE 58662
// begin if i = sort then
58572: LD_VAR 0 3
58576: PUSH
58577: LD_VAR 0 9
58581: EQUAL
58582: IFFALSE 58586
// break ;
58584: GO 58662
// if GetClass ( i ) = 2 then
58586: LD_VAR 0 3
58590: PPUSH
58591: CALL_OW 257
58595: PUSH
58596: LD_INT 2
58598: EQUAL
58599: IFFALSE 58603
// continue ;
58601: GO 58569
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58603: LD_ADDR_VAR 0 11
58607: PUSH
58608: LD_VAR 0 11
58612: PPUSH
58613: LD_VAR 0 11
58617: PUSH
58618: LD_INT 1
58620: PLUS
58621: PPUSH
58622: LD_VAR 0 9
58626: PUSH
58627: LD_VAR 0 3
58631: ARRAY
58632: PPUSH
58633: CALL_OW 2
58637: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58638: LD_ADDR_VAR 0 4
58642: PUSH
58643: LD_VAR 0 4
58647: PUSH
58648: LD_VAR 0 9
58652: PUSH
58653: LD_VAR 0 3
58657: ARRAY
58658: DIFF
58659: ST_TO_ADDR
// end ;
58660: GO 58569
58662: POP
58663: POP
// if p then
58664: LD_VAR 0 11
58668: IFFALSE 58693
// result := Replace ( result , 2 , p ) ;
58670: LD_ADDR_VAR 0 2
58674: PUSH
58675: LD_VAR 0 2
58679: PPUSH
58680: LD_INT 2
58682: PPUSH
58683: LD_VAR 0 11
58687: PPUSH
58688: CALL_OW 1
58692: ST_TO_ADDR
// end ; exit ;
58693: GO 60081
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58695: LD_EXP 70
58699: PUSH
58700: LD_EXP 69
58704: PUSH
58705: LD_VAR 0 1
58709: ARRAY
58710: ARRAY
58711: NOT
58712: PUSH
58713: LD_EXP 43
58717: PUSH
58718: LD_VAR 0 1
58722: ARRAY
58723: PPUSH
58724: LD_INT 30
58726: PUSH
58727: LD_INT 3
58729: PUSH
58730: EMPTY
58731: LIST
58732: LIST
58733: PPUSH
58734: CALL_OW 72
58738: AND
58739: PUSH
58740: LD_EXP 48
58744: PUSH
58745: LD_VAR 0 1
58749: ARRAY
58750: AND
58751: IFFALSE 59359
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58753: LD_ADDR_EXP 85
58757: PUSH
58758: LD_EXP 85
58762: PPUSH
58763: LD_VAR 0 1
58767: PPUSH
58768: LD_INT 5
58770: PPUSH
58771: CALL_OW 1
58775: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58776: LD_ADDR_VAR 0 2
58780: PUSH
58781: LD_INT 0
58783: PUSH
58784: LD_INT 0
58786: PUSH
58787: LD_INT 0
58789: PUSH
58790: LD_INT 0
58792: PUSH
58793: EMPTY
58794: LIST
58795: LIST
58796: LIST
58797: LIST
58798: ST_TO_ADDR
// if sci > 1 then
58799: LD_VAR 0 8
58803: PUSH
58804: LD_INT 1
58806: GREATER
58807: IFFALSE 58835
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58809: LD_ADDR_VAR 0 4
58813: PUSH
58814: LD_VAR 0 4
58818: PUSH
58819: LD_VAR 0 8
58823: PUSH
58824: LD_VAR 0 8
58828: PUSH
58829: LD_INT 1
58831: ARRAY
58832: DIFF
58833: DIFF
58834: ST_TO_ADDR
// if tmp and not sci then
58835: LD_VAR 0 4
58839: PUSH
58840: LD_VAR 0 8
58844: NOT
58845: AND
58846: IFFALSE 58915
// begin sort := SortBySkill ( tmp , 4 ) ;
58848: LD_ADDR_VAR 0 9
58852: PUSH
58853: LD_VAR 0 4
58857: PPUSH
58858: LD_INT 4
58860: PPUSH
58861: CALL 46018 0 2
58865: ST_TO_ADDR
// if sort then
58866: LD_VAR 0 9
58870: IFFALSE 58886
// p := sort [ 1 ] ;
58872: LD_ADDR_VAR 0 11
58876: PUSH
58877: LD_VAR 0 9
58881: PUSH
58882: LD_INT 1
58884: ARRAY
58885: ST_TO_ADDR
// if p then
58886: LD_VAR 0 11
58890: IFFALSE 58915
// result := Replace ( result , 4 , p ) ;
58892: LD_ADDR_VAR 0 2
58896: PUSH
58897: LD_VAR 0 2
58901: PPUSH
58902: LD_INT 4
58904: PPUSH
58905: LD_VAR 0 11
58909: PPUSH
58910: CALL_OW 1
58914: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58915: LD_ADDR_VAR 0 4
58919: PUSH
58920: LD_VAR 0 4
58924: PUSH
58925: LD_VAR 0 7
58929: DIFF
58930: ST_TO_ADDR
// if tmp and mech < 6 then
58931: LD_VAR 0 4
58935: PUSH
58936: LD_VAR 0 7
58940: PUSH
58941: LD_INT 6
58943: LESS
58944: AND
58945: IFFALSE 59133
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58947: LD_ADDR_VAR 0 9
58951: PUSH
58952: LD_VAR 0 4
58956: PUSH
58957: LD_VAR 0 8
58961: PUSH
58962: LD_VAR 0 7
58966: UNION
58967: DIFF
58968: PPUSH
58969: LD_INT 3
58971: PPUSH
58972: CALL 46018 0 2
58976: ST_TO_ADDR
// p := [ ] ;
58977: LD_ADDR_VAR 0 11
58981: PUSH
58982: EMPTY
58983: ST_TO_ADDR
// if sort then
58984: LD_VAR 0 9
58988: IFFALSE 59104
// for i = 1 to 6 - mech do
58990: LD_ADDR_VAR 0 3
58994: PUSH
58995: DOUBLE
58996: LD_INT 1
58998: DEC
58999: ST_TO_ADDR
59000: LD_INT 6
59002: PUSH
59003: LD_VAR 0 7
59007: MINUS
59008: PUSH
59009: FOR_TO
59010: IFFALSE 59102
// begin if i = sort then
59012: LD_VAR 0 3
59016: PUSH
59017: LD_VAR 0 9
59021: EQUAL
59022: IFFALSE 59026
// break ;
59024: GO 59102
// if GetClass ( i ) = 3 then
59026: LD_VAR 0 3
59030: PPUSH
59031: CALL_OW 257
59035: PUSH
59036: LD_INT 3
59038: EQUAL
59039: IFFALSE 59043
// continue ;
59041: GO 59009
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59043: LD_ADDR_VAR 0 11
59047: PUSH
59048: LD_VAR 0 11
59052: PPUSH
59053: LD_VAR 0 11
59057: PUSH
59058: LD_INT 1
59060: PLUS
59061: PPUSH
59062: LD_VAR 0 9
59066: PUSH
59067: LD_VAR 0 3
59071: ARRAY
59072: PPUSH
59073: CALL_OW 2
59077: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59078: LD_ADDR_VAR 0 4
59082: PUSH
59083: LD_VAR 0 4
59087: PUSH
59088: LD_VAR 0 9
59092: PUSH
59093: LD_VAR 0 3
59097: ARRAY
59098: DIFF
59099: ST_TO_ADDR
// end ;
59100: GO 59009
59102: POP
59103: POP
// if p then
59104: LD_VAR 0 11
59108: IFFALSE 59133
// result := Replace ( result , 3 , p ) ;
59110: LD_ADDR_VAR 0 2
59114: PUSH
59115: LD_VAR 0 2
59119: PPUSH
59120: LD_INT 3
59122: PPUSH
59123: LD_VAR 0 11
59127: PPUSH
59128: CALL_OW 1
59132: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59133: LD_ADDR_VAR 0 4
59137: PUSH
59138: LD_VAR 0 4
59142: PUSH
59143: LD_VAR 0 6
59147: DIFF
59148: ST_TO_ADDR
// if tmp and eng < 6 then
59149: LD_VAR 0 4
59153: PUSH
59154: LD_VAR 0 6
59158: PUSH
59159: LD_INT 6
59161: LESS
59162: AND
59163: IFFALSE 59357
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59165: LD_ADDR_VAR 0 9
59169: PUSH
59170: LD_VAR 0 4
59174: PUSH
59175: LD_VAR 0 8
59179: PUSH
59180: LD_VAR 0 7
59184: UNION
59185: PUSH
59186: LD_VAR 0 6
59190: UNION
59191: DIFF
59192: PPUSH
59193: LD_INT 2
59195: PPUSH
59196: CALL 46018 0 2
59200: ST_TO_ADDR
// p := [ ] ;
59201: LD_ADDR_VAR 0 11
59205: PUSH
59206: EMPTY
59207: ST_TO_ADDR
// if sort then
59208: LD_VAR 0 9
59212: IFFALSE 59328
// for i = 1 to 6 - eng do
59214: LD_ADDR_VAR 0 3
59218: PUSH
59219: DOUBLE
59220: LD_INT 1
59222: DEC
59223: ST_TO_ADDR
59224: LD_INT 6
59226: PUSH
59227: LD_VAR 0 6
59231: MINUS
59232: PUSH
59233: FOR_TO
59234: IFFALSE 59326
// begin if i = sort then
59236: LD_VAR 0 3
59240: PUSH
59241: LD_VAR 0 9
59245: EQUAL
59246: IFFALSE 59250
// break ;
59248: GO 59326
// if GetClass ( i ) = 2 then
59250: LD_VAR 0 3
59254: PPUSH
59255: CALL_OW 257
59259: PUSH
59260: LD_INT 2
59262: EQUAL
59263: IFFALSE 59267
// continue ;
59265: GO 59233
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59267: LD_ADDR_VAR 0 11
59271: PUSH
59272: LD_VAR 0 11
59276: PPUSH
59277: LD_VAR 0 11
59281: PUSH
59282: LD_INT 1
59284: PLUS
59285: PPUSH
59286: LD_VAR 0 9
59290: PUSH
59291: LD_VAR 0 3
59295: ARRAY
59296: PPUSH
59297: CALL_OW 2
59301: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59302: LD_ADDR_VAR 0 4
59306: PUSH
59307: LD_VAR 0 4
59311: PUSH
59312: LD_VAR 0 9
59316: PUSH
59317: LD_VAR 0 3
59321: ARRAY
59322: DIFF
59323: ST_TO_ADDR
// end ;
59324: GO 59233
59326: POP
59327: POP
// if p then
59328: LD_VAR 0 11
59332: IFFALSE 59357
// result := Replace ( result , 2 , p ) ;
59334: LD_ADDR_VAR 0 2
59338: PUSH
59339: LD_VAR 0 2
59343: PPUSH
59344: LD_INT 2
59346: PPUSH
59347: LD_VAR 0 11
59351: PPUSH
59352: CALL_OW 1
59356: ST_TO_ADDR
// end ; exit ;
59357: GO 60081
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59359: LD_EXP 70
59363: PUSH
59364: LD_EXP 69
59368: PUSH
59369: LD_VAR 0 1
59373: ARRAY
59374: ARRAY
59375: NOT
59376: PUSH
59377: LD_EXP 43
59381: PUSH
59382: LD_VAR 0 1
59386: ARRAY
59387: PPUSH
59388: LD_INT 30
59390: PUSH
59391: LD_INT 3
59393: PUSH
59394: EMPTY
59395: LIST
59396: LIST
59397: PPUSH
59398: CALL_OW 72
59402: AND
59403: PUSH
59404: LD_EXP 48
59408: PUSH
59409: LD_VAR 0 1
59413: ARRAY
59414: NOT
59415: AND
59416: IFFALSE 60081
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59418: LD_ADDR_EXP 85
59422: PUSH
59423: LD_EXP 85
59427: PPUSH
59428: LD_VAR 0 1
59432: PPUSH
59433: LD_INT 6
59435: PPUSH
59436: CALL_OW 1
59440: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59441: LD_ADDR_VAR 0 2
59445: PUSH
59446: LD_INT 0
59448: PUSH
59449: LD_INT 0
59451: PUSH
59452: LD_INT 0
59454: PUSH
59455: LD_INT 0
59457: PUSH
59458: EMPTY
59459: LIST
59460: LIST
59461: LIST
59462: LIST
59463: ST_TO_ADDR
// if sci >= 1 then
59464: LD_VAR 0 8
59468: PUSH
59469: LD_INT 1
59471: GREATEREQUAL
59472: IFFALSE 59494
// tmp := tmp diff sci [ 1 ] ;
59474: LD_ADDR_VAR 0 4
59478: PUSH
59479: LD_VAR 0 4
59483: PUSH
59484: LD_VAR 0 8
59488: PUSH
59489: LD_INT 1
59491: ARRAY
59492: DIFF
59493: ST_TO_ADDR
// if tmp and not sci then
59494: LD_VAR 0 4
59498: PUSH
59499: LD_VAR 0 8
59503: NOT
59504: AND
59505: IFFALSE 59574
// begin sort := SortBySkill ( tmp , 4 ) ;
59507: LD_ADDR_VAR 0 9
59511: PUSH
59512: LD_VAR 0 4
59516: PPUSH
59517: LD_INT 4
59519: PPUSH
59520: CALL 46018 0 2
59524: ST_TO_ADDR
// if sort then
59525: LD_VAR 0 9
59529: IFFALSE 59545
// p := sort [ 1 ] ;
59531: LD_ADDR_VAR 0 11
59535: PUSH
59536: LD_VAR 0 9
59540: PUSH
59541: LD_INT 1
59543: ARRAY
59544: ST_TO_ADDR
// if p then
59545: LD_VAR 0 11
59549: IFFALSE 59574
// result := Replace ( result , 4 , p ) ;
59551: LD_ADDR_VAR 0 2
59555: PUSH
59556: LD_VAR 0 2
59560: PPUSH
59561: LD_INT 4
59563: PPUSH
59564: LD_VAR 0 11
59568: PPUSH
59569: CALL_OW 1
59573: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59574: LD_ADDR_VAR 0 4
59578: PUSH
59579: LD_VAR 0 4
59583: PUSH
59584: LD_VAR 0 7
59588: DIFF
59589: ST_TO_ADDR
// if tmp and mech < 6 then
59590: LD_VAR 0 4
59594: PUSH
59595: LD_VAR 0 7
59599: PUSH
59600: LD_INT 6
59602: LESS
59603: AND
59604: IFFALSE 59786
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59606: LD_ADDR_VAR 0 9
59610: PUSH
59611: LD_VAR 0 4
59615: PUSH
59616: LD_VAR 0 7
59620: DIFF
59621: PPUSH
59622: LD_INT 3
59624: PPUSH
59625: CALL 46018 0 2
59629: ST_TO_ADDR
// p := [ ] ;
59630: LD_ADDR_VAR 0 11
59634: PUSH
59635: EMPTY
59636: ST_TO_ADDR
// if sort then
59637: LD_VAR 0 9
59641: IFFALSE 59757
// for i = 1 to 6 - mech do
59643: LD_ADDR_VAR 0 3
59647: PUSH
59648: DOUBLE
59649: LD_INT 1
59651: DEC
59652: ST_TO_ADDR
59653: LD_INT 6
59655: PUSH
59656: LD_VAR 0 7
59660: MINUS
59661: PUSH
59662: FOR_TO
59663: IFFALSE 59755
// begin if i = sort then
59665: LD_VAR 0 3
59669: PUSH
59670: LD_VAR 0 9
59674: EQUAL
59675: IFFALSE 59679
// break ;
59677: GO 59755
// if GetClass ( i ) = 3 then
59679: LD_VAR 0 3
59683: PPUSH
59684: CALL_OW 257
59688: PUSH
59689: LD_INT 3
59691: EQUAL
59692: IFFALSE 59696
// continue ;
59694: GO 59662
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59696: LD_ADDR_VAR 0 11
59700: PUSH
59701: LD_VAR 0 11
59705: PPUSH
59706: LD_VAR 0 11
59710: PUSH
59711: LD_INT 1
59713: PLUS
59714: PPUSH
59715: LD_VAR 0 9
59719: PUSH
59720: LD_VAR 0 3
59724: ARRAY
59725: PPUSH
59726: CALL_OW 2
59730: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59731: LD_ADDR_VAR 0 4
59735: PUSH
59736: LD_VAR 0 4
59740: PUSH
59741: LD_VAR 0 9
59745: PUSH
59746: LD_VAR 0 3
59750: ARRAY
59751: DIFF
59752: ST_TO_ADDR
// end ;
59753: GO 59662
59755: POP
59756: POP
// if p then
59757: LD_VAR 0 11
59761: IFFALSE 59786
// result := Replace ( result , 3 , p ) ;
59763: LD_ADDR_VAR 0 2
59767: PUSH
59768: LD_VAR 0 2
59772: PPUSH
59773: LD_INT 3
59775: PPUSH
59776: LD_VAR 0 11
59780: PPUSH
59781: CALL_OW 1
59785: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59786: LD_ADDR_VAR 0 4
59790: PUSH
59791: LD_VAR 0 4
59795: PUSH
59796: LD_VAR 0 6
59800: DIFF
59801: ST_TO_ADDR
// if tmp and eng < 4 then
59802: LD_VAR 0 4
59806: PUSH
59807: LD_VAR 0 6
59811: PUSH
59812: LD_INT 4
59814: LESS
59815: AND
59816: IFFALSE 60006
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59818: LD_ADDR_VAR 0 9
59822: PUSH
59823: LD_VAR 0 4
59827: PUSH
59828: LD_VAR 0 7
59832: PUSH
59833: LD_VAR 0 6
59837: UNION
59838: DIFF
59839: PPUSH
59840: LD_INT 2
59842: PPUSH
59843: CALL 46018 0 2
59847: ST_TO_ADDR
// p := [ ] ;
59848: LD_ADDR_VAR 0 11
59852: PUSH
59853: EMPTY
59854: ST_TO_ADDR
// if sort then
59855: LD_VAR 0 9
59859: IFFALSE 59975
// for i = 1 to 4 - eng do
59861: LD_ADDR_VAR 0 3
59865: PUSH
59866: DOUBLE
59867: LD_INT 1
59869: DEC
59870: ST_TO_ADDR
59871: LD_INT 4
59873: PUSH
59874: LD_VAR 0 6
59878: MINUS
59879: PUSH
59880: FOR_TO
59881: IFFALSE 59973
// begin if i = sort then
59883: LD_VAR 0 3
59887: PUSH
59888: LD_VAR 0 9
59892: EQUAL
59893: IFFALSE 59897
// break ;
59895: GO 59973
// if GetClass ( i ) = 2 then
59897: LD_VAR 0 3
59901: PPUSH
59902: CALL_OW 257
59906: PUSH
59907: LD_INT 2
59909: EQUAL
59910: IFFALSE 59914
// continue ;
59912: GO 59880
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59914: LD_ADDR_VAR 0 11
59918: PUSH
59919: LD_VAR 0 11
59923: PPUSH
59924: LD_VAR 0 11
59928: PUSH
59929: LD_INT 1
59931: PLUS
59932: PPUSH
59933: LD_VAR 0 9
59937: PUSH
59938: LD_VAR 0 3
59942: ARRAY
59943: PPUSH
59944: CALL_OW 2
59948: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59949: LD_ADDR_VAR 0 4
59953: PUSH
59954: LD_VAR 0 4
59958: PUSH
59959: LD_VAR 0 9
59963: PUSH
59964: LD_VAR 0 3
59968: ARRAY
59969: DIFF
59970: ST_TO_ADDR
// end ;
59971: GO 59880
59973: POP
59974: POP
// if p then
59975: LD_VAR 0 11
59979: IFFALSE 60004
// result := Replace ( result , 2 , p ) ;
59981: LD_ADDR_VAR 0 2
59985: PUSH
59986: LD_VAR 0 2
59990: PPUSH
59991: LD_INT 2
59993: PPUSH
59994: LD_VAR 0 11
59998: PPUSH
59999: CALL_OW 1
60003: ST_TO_ADDR
// end else
60004: GO 60050
// for i = eng downto 5 do
60006: LD_ADDR_VAR 0 3
60010: PUSH
60011: DOUBLE
60012: LD_VAR 0 6
60016: INC
60017: ST_TO_ADDR
60018: LD_INT 5
60020: PUSH
60021: FOR_DOWNTO
60022: IFFALSE 60048
// tmp := tmp union eng [ i ] ;
60024: LD_ADDR_VAR 0 4
60028: PUSH
60029: LD_VAR 0 4
60033: PUSH
60034: LD_VAR 0 6
60038: PUSH
60039: LD_VAR 0 3
60043: ARRAY
60044: UNION
60045: ST_TO_ADDR
60046: GO 60021
60048: POP
60049: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60050: LD_ADDR_VAR 0 2
60054: PUSH
60055: LD_VAR 0 2
60059: PPUSH
60060: LD_INT 1
60062: PPUSH
60063: LD_VAR 0 4
60067: PUSH
60068: LD_VAR 0 5
60072: DIFF
60073: PPUSH
60074: CALL_OW 1
60078: ST_TO_ADDR
// exit ;
60079: GO 60081
// end ; end ;
60081: LD_VAR 0 2
60085: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60086: LD_INT 0
60088: PPUSH
60089: PPUSH
60090: PPUSH
// if not mc_bases then
60091: LD_EXP 43
60095: NOT
60096: IFFALSE 60100
// exit ;
60098: GO 60242
// for i = 1 to mc_bases do
60100: LD_ADDR_VAR 0 2
60104: PUSH
60105: DOUBLE
60106: LD_INT 1
60108: DEC
60109: ST_TO_ADDR
60110: LD_EXP 43
60114: PUSH
60115: FOR_TO
60116: IFFALSE 60233
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60118: LD_ADDR_VAR 0 3
60122: PUSH
60123: LD_EXP 43
60127: PUSH
60128: LD_VAR 0 2
60132: ARRAY
60133: PPUSH
60134: LD_INT 21
60136: PUSH
60137: LD_INT 3
60139: PUSH
60140: EMPTY
60141: LIST
60142: LIST
60143: PUSH
60144: LD_INT 3
60146: PUSH
60147: LD_INT 2
60149: PUSH
60150: LD_INT 30
60152: PUSH
60153: LD_INT 29
60155: PUSH
60156: EMPTY
60157: LIST
60158: LIST
60159: PUSH
60160: LD_INT 30
60162: PUSH
60163: LD_INT 30
60165: PUSH
60166: EMPTY
60167: LIST
60168: LIST
60169: PUSH
60170: EMPTY
60171: LIST
60172: LIST
60173: LIST
60174: PUSH
60175: EMPTY
60176: LIST
60177: LIST
60178: PUSH
60179: LD_INT 3
60181: PUSH
60182: LD_INT 24
60184: PUSH
60185: LD_INT 1000
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: PUSH
60192: EMPTY
60193: LIST
60194: LIST
60195: PUSH
60196: EMPTY
60197: LIST
60198: LIST
60199: LIST
60200: PPUSH
60201: CALL_OW 72
60205: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60206: LD_ADDR_EXP 44
60210: PUSH
60211: LD_EXP 44
60215: PPUSH
60216: LD_VAR 0 2
60220: PPUSH
60221: LD_VAR 0 3
60225: PPUSH
60226: CALL_OW 1
60230: ST_TO_ADDR
// end ;
60231: GO 60115
60233: POP
60234: POP
// RaiseSailEvent ( 101 ) ;
60235: LD_INT 101
60237: PPUSH
60238: CALL_OW 427
// end ;
60242: LD_VAR 0 1
60246: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60247: LD_INT 0
60249: PPUSH
60250: PPUSH
60251: PPUSH
60252: PPUSH
60253: PPUSH
60254: PPUSH
60255: PPUSH
// if not mc_bases then
60256: LD_EXP 43
60260: NOT
60261: IFFALSE 60265
// exit ;
60263: GO 60827
// for i = 1 to mc_bases do
60265: LD_ADDR_VAR 0 2
60269: PUSH
60270: DOUBLE
60271: LD_INT 1
60273: DEC
60274: ST_TO_ADDR
60275: LD_EXP 43
60279: PUSH
60280: FOR_TO
60281: IFFALSE 60818
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60283: LD_ADDR_VAR 0 5
60287: PUSH
60288: LD_EXP 43
60292: PUSH
60293: LD_VAR 0 2
60297: ARRAY
60298: PUSH
60299: LD_EXP 72
60303: PUSH
60304: LD_VAR 0 2
60308: ARRAY
60309: UNION
60310: PPUSH
60311: LD_INT 21
60313: PUSH
60314: LD_INT 1
60316: PUSH
60317: EMPTY
60318: LIST
60319: LIST
60320: PUSH
60321: LD_INT 1
60323: PUSH
60324: LD_INT 3
60326: PUSH
60327: LD_INT 54
60329: PUSH
60330: EMPTY
60331: LIST
60332: PUSH
60333: EMPTY
60334: LIST
60335: LIST
60336: PUSH
60337: LD_INT 3
60339: PUSH
60340: LD_INT 24
60342: PUSH
60343: LD_INT 1000
60345: PUSH
60346: EMPTY
60347: LIST
60348: LIST
60349: PUSH
60350: EMPTY
60351: LIST
60352: LIST
60353: PUSH
60354: EMPTY
60355: LIST
60356: LIST
60357: LIST
60358: PUSH
60359: EMPTY
60360: LIST
60361: LIST
60362: PPUSH
60363: CALL_OW 72
60367: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60368: LD_ADDR_VAR 0 6
60372: PUSH
60373: LD_EXP 43
60377: PUSH
60378: LD_VAR 0 2
60382: ARRAY
60383: PPUSH
60384: LD_INT 21
60386: PUSH
60387: LD_INT 1
60389: PUSH
60390: EMPTY
60391: LIST
60392: LIST
60393: PUSH
60394: LD_INT 1
60396: PUSH
60397: LD_INT 3
60399: PUSH
60400: LD_INT 54
60402: PUSH
60403: EMPTY
60404: LIST
60405: PUSH
60406: EMPTY
60407: LIST
60408: LIST
60409: PUSH
60410: LD_INT 3
60412: PUSH
60413: LD_INT 24
60415: PUSH
60416: LD_INT 250
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: PUSH
60423: EMPTY
60424: LIST
60425: LIST
60426: PUSH
60427: EMPTY
60428: LIST
60429: LIST
60430: LIST
60431: PUSH
60432: EMPTY
60433: LIST
60434: LIST
60435: PPUSH
60436: CALL_OW 72
60440: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60441: LD_ADDR_VAR 0 7
60445: PUSH
60446: LD_VAR 0 5
60450: PUSH
60451: LD_VAR 0 6
60455: DIFF
60456: ST_TO_ADDR
// if not need_heal_1 then
60457: LD_VAR 0 6
60461: NOT
60462: IFFALSE 60495
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
60464: LD_ADDR_EXP 46
60468: PUSH
60469: LD_EXP 46
60473: PPUSH
60474: LD_VAR 0 2
60478: PUSH
60479: LD_INT 1
60481: PUSH
60482: EMPTY
60483: LIST
60484: LIST
60485: PPUSH
60486: EMPTY
60487: PPUSH
60488: CALL 14774 0 3
60492: ST_TO_ADDR
60493: GO 60565
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60495: LD_ADDR_EXP 46
60499: PUSH
60500: LD_EXP 46
60504: PPUSH
60505: LD_VAR 0 2
60509: PUSH
60510: LD_INT 1
60512: PUSH
60513: EMPTY
60514: LIST
60515: LIST
60516: PPUSH
60517: LD_EXP 46
60521: PUSH
60522: LD_VAR 0 2
60526: ARRAY
60527: PUSH
60528: LD_INT 1
60530: ARRAY
60531: PPUSH
60532: LD_INT 3
60534: PUSH
60535: LD_INT 24
60537: PUSH
60538: LD_INT 1000
60540: PUSH
60541: EMPTY
60542: LIST
60543: LIST
60544: PUSH
60545: EMPTY
60546: LIST
60547: LIST
60548: PPUSH
60549: CALL_OW 72
60553: PUSH
60554: LD_VAR 0 6
60558: UNION
60559: PPUSH
60560: CALL 14774 0 3
60564: ST_TO_ADDR
// if not need_heal_2 then
60565: LD_VAR 0 7
60569: NOT
60570: IFFALSE 60603
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60572: LD_ADDR_EXP 46
60576: PUSH
60577: LD_EXP 46
60581: PPUSH
60582: LD_VAR 0 2
60586: PUSH
60587: LD_INT 2
60589: PUSH
60590: EMPTY
60591: LIST
60592: LIST
60593: PPUSH
60594: EMPTY
60595: PPUSH
60596: CALL 14774 0 3
60600: ST_TO_ADDR
60601: GO 60635
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60603: LD_ADDR_EXP 46
60607: PUSH
60608: LD_EXP 46
60612: PPUSH
60613: LD_VAR 0 2
60617: PUSH
60618: LD_INT 2
60620: PUSH
60621: EMPTY
60622: LIST
60623: LIST
60624: PPUSH
60625: LD_VAR 0 7
60629: PPUSH
60630: CALL 14774 0 3
60634: ST_TO_ADDR
// if need_heal_2 then
60635: LD_VAR 0 7
60639: IFFALSE 60800
// for j in need_heal_2 do
60641: LD_ADDR_VAR 0 3
60645: PUSH
60646: LD_VAR 0 7
60650: PUSH
60651: FOR_IN
60652: IFFALSE 60798
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60654: LD_ADDR_VAR 0 5
60658: PUSH
60659: LD_EXP 43
60663: PUSH
60664: LD_VAR 0 2
60668: ARRAY
60669: PPUSH
60670: LD_INT 2
60672: PUSH
60673: LD_INT 30
60675: PUSH
60676: LD_INT 6
60678: PUSH
60679: EMPTY
60680: LIST
60681: LIST
60682: PUSH
60683: LD_INT 30
60685: PUSH
60686: LD_INT 7
60688: PUSH
60689: EMPTY
60690: LIST
60691: LIST
60692: PUSH
60693: LD_INT 30
60695: PUSH
60696: LD_INT 8
60698: PUSH
60699: EMPTY
60700: LIST
60701: LIST
60702: PUSH
60703: LD_INT 30
60705: PUSH
60706: LD_INT 0
60708: PUSH
60709: EMPTY
60710: LIST
60711: LIST
60712: PUSH
60713: LD_INT 30
60715: PUSH
60716: LD_INT 1
60718: PUSH
60719: EMPTY
60720: LIST
60721: LIST
60722: PUSH
60723: EMPTY
60724: LIST
60725: LIST
60726: LIST
60727: LIST
60728: LIST
60729: LIST
60730: PPUSH
60731: CALL_OW 72
60735: ST_TO_ADDR
// if tmp then
60736: LD_VAR 0 5
60740: IFFALSE 60796
// begin k := NearestUnitToUnit ( tmp , j ) ;
60742: LD_ADDR_VAR 0 4
60746: PUSH
60747: LD_VAR 0 5
60751: PPUSH
60752: LD_VAR 0 3
60756: PPUSH
60757: CALL_OW 74
60761: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60762: LD_VAR 0 3
60766: PPUSH
60767: LD_VAR 0 4
60771: PPUSH
60772: CALL_OW 296
60776: PUSH
60777: LD_INT 5
60779: GREATER
60780: IFFALSE 60796
// ComMoveToNearbyEntrance ( j , k ) ;
60782: LD_VAR 0 3
60786: PPUSH
60787: LD_VAR 0 4
60791: PPUSH
60792: CALL 48391 0 2
// end ; end ;
60796: GO 60651
60798: POP
60799: POP
// if not need_heal_1 and not need_heal_2 then
60800: LD_VAR 0 6
60804: NOT
60805: PUSH
60806: LD_VAR 0 7
60810: NOT
60811: AND
60812: IFFALSE 60816
// continue ;
60814: GO 60280
// end ;
60816: GO 60280
60818: POP
60819: POP
// RaiseSailEvent ( 102 ) ;
60820: LD_INT 102
60822: PPUSH
60823: CALL_OW 427
// end ;
60827: LD_VAR 0 1
60831: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60832: LD_INT 0
60834: PPUSH
60835: PPUSH
60836: PPUSH
60837: PPUSH
60838: PPUSH
60839: PPUSH
60840: PPUSH
60841: PPUSH
// if not mc_bases then
60842: LD_EXP 43
60846: NOT
60847: IFFALSE 60851
// exit ;
60849: GO 61762
// for i = 1 to mc_bases do
60851: LD_ADDR_VAR 0 2
60855: PUSH
60856: DOUBLE
60857: LD_INT 1
60859: DEC
60860: ST_TO_ADDR
60861: LD_EXP 43
60865: PUSH
60866: FOR_TO
60867: IFFALSE 61760
// begin if not mc_building_need_repair [ i ] then
60869: LD_EXP 44
60873: PUSH
60874: LD_VAR 0 2
60878: ARRAY
60879: NOT
60880: IFFALSE 61065
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60882: LD_ADDR_VAR 0 6
60886: PUSH
60887: LD_EXP 62
60891: PUSH
60892: LD_VAR 0 2
60896: ARRAY
60897: PPUSH
60898: LD_INT 3
60900: PUSH
60901: LD_INT 24
60903: PUSH
60904: LD_INT 1000
60906: PUSH
60907: EMPTY
60908: LIST
60909: LIST
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: PUSH
60915: LD_INT 2
60917: PUSH
60918: LD_INT 34
60920: PUSH
60921: LD_INT 13
60923: PUSH
60924: EMPTY
60925: LIST
60926: LIST
60927: PUSH
60928: LD_INT 34
60930: PUSH
60931: LD_INT 52
60933: PUSH
60934: EMPTY
60935: LIST
60936: LIST
60937: PUSH
60938: LD_INT 34
60940: PUSH
60941: LD_INT 88
60943: PUSH
60944: EMPTY
60945: LIST
60946: LIST
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: LIST
60952: LIST
60953: PUSH
60954: EMPTY
60955: LIST
60956: LIST
60957: PPUSH
60958: CALL_OW 72
60962: ST_TO_ADDR
// if cranes then
60963: LD_VAR 0 6
60967: IFFALSE 61029
// for j in cranes do
60969: LD_ADDR_VAR 0 3
60973: PUSH
60974: LD_VAR 0 6
60978: PUSH
60979: FOR_IN
60980: IFFALSE 61027
// if not IsInArea ( j , mc_parking [ i ] ) then
60982: LD_VAR 0 3
60986: PPUSH
60987: LD_EXP 67
60991: PUSH
60992: LD_VAR 0 2
60996: ARRAY
60997: PPUSH
60998: CALL_OW 308
61002: NOT
61003: IFFALSE 61025
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61005: LD_VAR 0 3
61009: PPUSH
61010: LD_EXP 67
61014: PUSH
61015: LD_VAR 0 2
61019: ARRAY
61020: PPUSH
61021: CALL_OW 113
61025: GO 60979
61027: POP
61028: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61029: LD_ADDR_EXP 45
61033: PUSH
61034: LD_EXP 45
61038: PPUSH
61039: LD_VAR 0 2
61043: PPUSH
61044: EMPTY
61045: PPUSH
61046: CALL_OW 1
61050: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61051: LD_VAR 0 2
61055: PPUSH
61056: LD_INT 101
61058: PPUSH
61059: CALL 55905 0 2
// continue ;
61063: GO 60866
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61065: LD_ADDR_EXP 49
61069: PUSH
61070: LD_EXP 49
61074: PPUSH
61075: LD_VAR 0 2
61079: PPUSH
61080: EMPTY
61081: PPUSH
61082: CALL_OW 1
61086: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61087: LD_VAR 0 2
61091: PPUSH
61092: LD_INT 103
61094: PPUSH
61095: CALL 55905 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
61099: LD_ADDR_VAR 0 5
61103: PUSH
61104: LD_EXP 43
61108: PUSH
61109: LD_VAR 0 2
61113: ARRAY
61114: PUSH
61115: LD_EXP 72
61119: PUSH
61120: LD_VAR 0 2
61124: ARRAY
61125: UNION
61126: PPUSH
61127: LD_INT 2
61129: PUSH
61130: LD_INT 25
61132: PUSH
61133: LD_INT 2
61135: PUSH
61136: EMPTY
61137: LIST
61138: LIST
61139: PUSH
61140: LD_INT 25
61142: PUSH
61143: LD_INT 16
61145: PUSH
61146: EMPTY
61147: LIST
61148: LIST
61149: PUSH
61150: EMPTY
61151: LIST
61152: LIST
61153: LIST
61154: PUSH
61155: EMPTY
61156: LIST
61157: PPUSH
61158: CALL_OW 72
61162: ST_TO_ADDR
// if mc_need_heal [ i ] then
61163: LD_EXP 46
61167: PUSH
61168: LD_VAR 0 2
61172: ARRAY
61173: IFFALSE 61217
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61175: LD_ADDR_VAR 0 5
61179: PUSH
61180: LD_VAR 0 5
61184: PUSH
61185: LD_EXP 46
61189: PUSH
61190: LD_VAR 0 2
61194: ARRAY
61195: PUSH
61196: LD_INT 1
61198: ARRAY
61199: PUSH
61200: LD_EXP 46
61204: PUSH
61205: LD_VAR 0 2
61209: ARRAY
61210: PUSH
61211: LD_INT 2
61213: ARRAY
61214: UNION
61215: DIFF
61216: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61217: LD_ADDR_VAR 0 6
61221: PUSH
61222: LD_EXP 62
61226: PUSH
61227: LD_VAR 0 2
61231: ARRAY
61232: PPUSH
61233: LD_INT 2
61235: PUSH
61236: LD_INT 34
61238: PUSH
61239: LD_INT 13
61241: PUSH
61242: EMPTY
61243: LIST
61244: LIST
61245: PUSH
61246: LD_INT 34
61248: PUSH
61249: LD_INT 52
61251: PUSH
61252: EMPTY
61253: LIST
61254: LIST
61255: PUSH
61256: LD_INT 34
61258: PUSH
61259: LD_INT 88
61261: PUSH
61262: EMPTY
61263: LIST
61264: LIST
61265: PUSH
61266: EMPTY
61267: LIST
61268: LIST
61269: LIST
61270: LIST
61271: PPUSH
61272: CALL_OW 72
61276: ST_TO_ADDR
// if cranes then
61277: LD_VAR 0 6
61281: IFFALSE 61449
// begin for j in cranes do
61283: LD_ADDR_VAR 0 3
61287: PUSH
61288: LD_VAR 0 6
61292: PUSH
61293: FOR_IN
61294: IFFALSE 61447
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61296: LD_VAR 0 3
61300: PPUSH
61301: CALL_OW 256
61305: PUSH
61306: LD_INT 1000
61308: EQUAL
61309: PUSH
61310: LD_VAR 0 3
61314: PPUSH
61315: CALL_OW 314
61319: NOT
61320: AND
61321: IFFALSE 61387
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
61323: LD_ADDR_VAR 0 8
61327: PUSH
61328: LD_EXP 44
61332: PUSH
61333: LD_VAR 0 2
61337: ARRAY
61338: PPUSH
61339: LD_VAR 0 3
61343: PPUSH
61344: CALL_OW 74
61348: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61349: LD_VAR 0 8
61353: PPUSH
61354: LD_INT 16
61356: PPUSH
61357: CALL 17739 0 2
61361: PUSH
61362: LD_INT 4
61364: ARRAY
61365: PUSH
61366: LD_INT 10
61368: LESS
61369: IFFALSE 61385
// ComRepairBuilding ( j , to_repair ) ;
61371: LD_VAR 0 3
61375: PPUSH
61376: LD_VAR 0 8
61380: PPUSH
61381: CALL_OW 130
// end else
61385: GO 61445
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61387: LD_VAR 0 3
61391: PPUSH
61392: CALL_OW 256
61396: PUSH
61397: LD_INT 500
61399: LESS
61400: PUSH
61401: LD_VAR 0 3
61405: PPUSH
61406: LD_EXP 67
61410: PUSH
61411: LD_VAR 0 2
61415: ARRAY
61416: PPUSH
61417: CALL_OW 308
61421: NOT
61422: AND
61423: IFFALSE 61445
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61425: LD_VAR 0 3
61429: PPUSH
61430: LD_EXP 67
61434: PUSH
61435: LD_VAR 0 2
61439: ARRAY
61440: PPUSH
61441: CALL_OW 113
// end ;
61445: GO 61293
61447: POP
61448: POP
// end ; if tmp > 3 then
61449: LD_VAR 0 5
61453: PUSH
61454: LD_INT 3
61456: GREATER
61457: IFFALSE 61477
// tmp := ShrinkArray ( tmp , 4 ) ;
61459: LD_ADDR_VAR 0 5
61463: PUSH
61464: LD_VAR 0 5
61468: PPUSH
61469: LD_INT 4
61471: PPUSH
61472: CALL 47829 0 2
61476: ST_TO_ADDR
// if not tmp then
61477: LD_VAR 0 5
61481: NOT
61482: IFFALSE 61486
// continue ;
61484: GO 60866
// for j in tmp do
61486: LD_ADDR_VAR 0 3
61490: PUSH
61491: LD_VAR 0 5
61495: PUSH
61496: FOR_IN
61497: IFFALSE 61756
// begin if IsInUnit ( j ) then
61499: LD_VAR 0 3
61503: PPUSH
61504: CALL_OW 310
61508: IFFALSE 61519
// ComExitBuilding ( j ) ;
61510: LD_VAR 0 3
61514: PPUSH
61515: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61519: LD_VAR 0 3
61523: PUSH
61524: LD_EXP 45
61528: PUSH
61529: LD_VAR 0 2
61533: ARRAY
61534: IN
61535: NOT
61536: IFFALSE 61594
// begin SetTag ( j , 101 ) ;
61538: LD_VAR 0 3
61542: PPUSH
61543: LD_INT 101
61545: PPUSH
61546: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61550: LD_ADDR_EXP 45
61554: PUSH
61555: LD_EXP 45
61559: PPUSH
61560: LD_VAR 0 2
61564: PUSH
61565: LD_EXP 45
61569: PUSH
61570: LD_VAR 0 2
61574: ARRAY
61575: PUSH
61576: LD_INT 1
61578: PLUS
61579: PUSH
61580: EMPTY
61581: LIST
61582: LIST
61583: PPUSH
61584: LD_VAR 0 3
61588: PPUSH
61589: CALL 14774 0 3
61593: ST_TO_ADDR
// end ; wait ( 1 ) ;
61594: LD_INT 1
61596: PPUSH
61597: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61601: LD_ADDR_VAR 0 7
61605: PUSH
61606: LD_EXP 44
61610: PUSH
61611: LD_VAR 0 2
61615: ARRAY
61616: ST_TO_ADDR
// if mc_scan [ i ] then
61617: LD_EXP 66
61621: PUSH
61622: LD_VAR 0 2
61626: ARRAY
61627: IFFALSE 61689
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61629: LD_ADDR_VAR 0 7
61633: PUSH
61634: LD_EXP 44
61638: PUSH
61639: LD_VAR 0 2
61643: ARRAY
61644: PPUSH
61645: LD_INT 3
61647: PUSH
61648: LD_INT 30
61650: PUSH
61651: LD_INT 32
61653: PUSH
61654: EMPTY
61655: LIST
61656: LIST
61657: PUSH
61658: LD_INT 30
61660: PUSH
61661: LD_INT 33
61663: PUSH
61664: EMPTY
61665: LIST
61666: LIST
61667: PUSH
61668: LD_INT 30
61670: PUSH
61671: LD_INT 31
61673: PUSH
61674: EMPTY
61675: LIST
61676: LIST
61677: PUSH
61678: EMPTY
61679: LIST
61680: LIST
61681: LIST
61682: LIST
61683: PPUSH
61684: CALL_OW 72
61688: ST_TO_ADDR
// if not to_repair_tmp then
61689: LD_VAR 0 7
61693: NOT
61694: IFFALSE 61698
// continue ;
61696: GO 61496
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61698: LD_ADDR_VAR 0 8
61702: PUSH
61703: LD_VAR 0 7
61707: PPUSH
61708: LD_VAR 0 3
61712: PPUSH
61713: CALL_OW 74
61717: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
61718: LD_VAR 0 8
61722: PPUSH
61723: LD_INT 16
61725: PPUSH
61726: CALL 17739 0 2
61730: PUSH
61731: LD_INT 4
61733: ARRAY
61734: PUSH
61735: LD_INT 14
61737: LESS
61738: IFFALSE 61754
// ComRepairBuilding ( j , to_repair ) ;
61740: LD_VAR 0 3
61744: PPUSH
61745: LD_VAR 0 8
61749: PPUSH
61750: CALL_OW 130
// end ;
61754: GO 61496
61756: POP
61757: POP
// end ;
61758: GO 60866
61760: POP
61761: POP
// end ;
61762: LD_VAR 0 1
61766: RET
// export function MC_Heal ; var i , j , tmp ; begin
61767: LD_INT 0
61769: PPUSH
61770: PPUSH
61771: PPUSH
61772: PPUSH
// if not mc_bases then
61773: LD_EXP 43
61777: NOT
61778: IFFALSE 61782
// exit ;
61780: GO 62184
// for i = 1 to mc_bases do
61782: LD_ADDR_VAR 0 2
61786: PUSH
61787: DOUBLE
61788: LD_INT 1
61790: DEC
61791: ST_TO_ADDR
61792: LD_EXP 43
61796: PUSH
61797: FOR_TO
61798: IFFALSE 62182
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61800: LD_EXP 46
61804: PUSH
61805: LD_VAR 0 2
61809: ARRAY
61810: PUSH
61811: LD_INT 1
61813: ARRAY
61814: NOT
61815: PUSH
61816: LD_EXP 46
61820: PUSH
61821: LD_VAR 0 2
61825: ARRAY
61826: PUSH
61827: LD_INT 2
61829: ARRAY
61830: NOT
61831: AND
61832: IFFALSE 61870
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61834: LD_ADDR_EXP 47
61838: PUSH
61839: LD_EXP 47
61843: PPUSH
61844: LD_VAR 0 2
61848: PPUSH
61849: EMPTY
61850: PPUSH
61851: CALL_OW 1
61855: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61856: LD_VAR 0 2
61860: PPUSH
61861: LD_INT 102
61863: PPUSH
61864: CALL 55905 0 2
// continue ;
61868: GO 61797
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61870: LD_ADDR_VAR 0 4
61874: PUSH
61875: LD_EXP 43
61879: PUSH
61880: LD_VAR 0 2
61884: ARRAY
61885: PPUSH
61886: LD_INT 25
61888: PUSH
61889: LD_INT 4
61891: PUSH
61892: EMPTY
61893: LIST
61894: LIST
61895: PPUSH
61896: CALL_OW 72
61900: ST_TO_ADDR
// if not tmp then
61901: LD_VAR 0 4
61905: NOT
61906: IFFALSE 61910
// continue ;
61908: GO 61797
// if mc_taming [ i ] then
61910: LD_EXP 74
61914: PUSH
61915: LD_VAR 0 2
61919: ARRAY
61920: IFFALSE 61944
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61922: LD_ADDR_EXP 74
61926: PUSH
61927: LD_EXP 74
61931: PPUSH
61932: LD_VAR 0 2
61936: PPUSH
61937: EMPTY
61938: PPUSH
61939: CALL_OW 1
61943: ST_TO_ADDR
// for j in tmp do
61944: LD_ADDR_VAR 0 3
61948: PUSH
61949: LD_VAR 0 4
61953: PUSH
61954: FOR_IN
61955: IFFALSE 62178
// begin if IsInUnit ( j ) then
61957: LD_VAR 0 3
61961: PPUSH
61962: CALL_OW 310
61966: IFFALSE 61977
// ComExitBuilding ( j ) ;
61968: LD_VAR 0 3
61972: PPUSH
61973: CALL_OW 122
// if not j in mc_healers [ i ] then
61977: LD_VAR 0 3
61981: PUSH
61982: LD_EXP 47
61986: PUSH
61987: LD_VAR 0 2
61991: ARRAY
61992: IN
61993: NOT
61994: IFFALSE 62040
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61996: LD_ADDR_EXP 47
62000: PUSH
62001: LD_EXP 47
62005: PPUSH
62006: LD_VAR 0 2
62010: PUSH
62011: LD_EXP 47
62015: PUSH
62016: LD_VAR 0 2
62020: ARRAY
62021: PUSH
62022: LD_INT 1
62024: PLUS
62025: PUSH
62026: EMPTY
62027: LIST
62028: LIST
62029: PPUSH
62030: LD_VAR 0 3
62034: PPUSH
62035: CALL 14774 0 3
62039: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62040: LD_VAR 0 3
62044: PPUSH
62045: CALL_OW 110
62049: PUSH
62050: LD_INT 102
62052: NONEQUAL
62053: IFFALSE 62067
// SetTag ( j , 102 ) ;
62055: LD_VAR 0 3
62059: PPUSH
62060: LD_INT 102
62062: PPUSH
62063: CALL_OW 109
// Wait ( 3 ) ;
62067: LD_INT 3
62069: PPUSH
62070: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62074: LD_EXP 46
62078: PUSH
62079: LD_VAR 0 2
62083: ARRAY
62084: PUSH
62085: LD_INT 1
62087: ARRAY
62088: IFFALSE 62120
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62090: LD_VAR 0 3
62094: PPUSH
62095: LD_EXP 46
62099: PUSH
62100: LD_VAR 0 2
62104: ARRAY
62105: PUSH
62106: LD_INT 1
62108: ARRAY
62109: PUSH
62110: LD_INT 1
62112: ARRAY
62113: PPUSH
62114: CALL_OW 128
62118: GO 62176
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62120: LD_VAR 0 3
62124: PPUSH
62125: CALL_OW 314
62129: NOT
62130: PUSH
62131: LD_EXP 46
62135: PUSH
62136: LD_VAR 0 2
62140: ARRAY
62141: PUSH
62142: LD_INT 2
62144: ARRAY
62145: AND
62146: IFFALSE 62176
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62148: LD_VAR 0 3
62152: PPUSH
62153: LD_EXP 46
62157: PUSH
62158: LD_VAR 0 2
62162: ARRAY
62163: PUSH
62164: LD_INT 2
62166: ARRAY
62167: PUSH
62168: LD_INT 1
62170: ARRAY
62171: PPUSH
62172: CALL_OW 128
// end ;
62176: GO 61954
62178: POP
62179: POP
// end ;
62180: GO 61797
62182: POP
62183: POP
// end ;
62184: LD_VAR 0 1
62188: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
62189: LD_INT 0
62191: PPUSH
62192: PPUSH
62193: PPUSH
62194: PPUSH
62195: PPUSH
62196: PPUSH
// if not mc_bases then
62197: LD_EXP 43
62201: NOT
62202: IFFALSE 62206
// exit ;
62204: GO 63369
// for i = 1 to mc_bases do
62206: LD_ADDR_VAR 0 2
62210: PUSH
62211: DOUBLE
62212: LD_INT 1
62214: DEC
62215: ST_TO_ADDR
62216: LD_EXP 43
62220: PUSH
62221: FOR_TO
62222: IFFALSE 63367
// begin if mc_scan [ i ] then
62224: LD_EXP 66
62228: PUSH
62229: LD_VAR 0 2
62233: ARRAY
62234: IFFALSE 62238
// continue ;
62236: GO 62221
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62238: LD_EXP 48
62242: PUSH
62243: LD_VAR 0 2
62247: ARRAY
62248: NOT
62249: PUSH
62250: LD_EXP 50
62254: PUSH
62255: LD_VAR 0 2
62259: ARRAY
62260: NOT
62261: AND
62262: PUSH
62263: LD_EXP 49
62267: PUSH
62268: LD_VAR 0 2
62272: ARRAY
62273: AND
62274: IFFALSE 62312
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62276: LD_ADDR_EXP 49
62280: PUSH
62281: LD_EXP 49
62285: PPUSH
62286: LD_VAR 0 2
62290: PPUSH
62291: EMPTY
62292: PPUSH
62293: CALL_OW 1
62297: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62298: LD_VAR 0 2
62302: PPUSH
62303: LD_INT 103
62305: PPUSH
62306: CALL 55905 0 2
// continue ;
62310: GO 62221
// end ; if mc_construct_list [ i ] then
62312: LD_EXP 50
62316: PUSH
62317: LD_VAR 0 2
62321: ARRAY
62322: IFFALSE 62542
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62324: LD_ADDR_VAR 0 5
62328: PUSH
62329: LD_EXP 43
62333: PUSH
62334: LD_VAR 0 2
62338: ARRAY
62339: PPUSH
62340: LD_INT 25
62342: PUSH
62343: LD_INT 2
62345: PUSH
62346: EMPTY
62347: LIST
62348: LIST
62349: PPUSH
62350: CALL_OW 72
62354: PUSH
62355: LD_EXP 45
62359: PUSH
62360: LD_VAR 0 2
62364: ARRAY
62365: DIFF
62366: ST_TO_ADDR
// if not tmp then
62367: LD_VAR 0 5
62371: NOT
62372: IFFALSE 62376
// continue ;
62374: GO 62221
// for j in tmp do
62376: LD_ADDR_VAR 0 3
62380: PUSH
62381: LD_VAR 0 5
62385: PUSH
62386: FOR_IN
62387: IFFALSE 62538
// begin if not mc_builders [ i ] then
62389: LD_EXP 49
62393: PUSH
62394: LD_VAR 0 2
62398: ARRAY
62399: NOT
62400: IFFALSE 62458
// begin SetTag ( j , 103 ) ;
62402: LD_VAR 0 3
62406: PPUSH
62407: LD_INT 103
62409: PPUSH
62410: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62414: LD_ADDR_EXP 49
62418: PUSH
62419: LD_EXP 49
62423: PPUSH
62424: LD_VAR 0 2
62428: PUSH
62429: LD_EXP 49
62433: PUSH
62434: LD_VAR 0 2
62438: ARRAY
62439: PUSH
62440: LD_INT 1
62442: PLUS
62443: PUSH
62444: EMPTY
62445: LIST
62446: LIST
62447: PPUSH
62448: LD_VAR 0 3
62452: PPUSH
62453: CALL 14774 0 3
62457: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62458: LD_VAR 0 3
62462: PPUSH
62463: CALL_OW 310
62467: IFFALSE 62478
// ComExitBuilding ( j ) ;
62469: LD_VAR 0 3
62473: PPUSH
62474: CALL_OW 122
// wait ( 3 ) ;
62478: LD_INT 3
62480: PPUSH
62481: CALL_OW 67
// if not mc_construct_list [ i ] then
62485: LD_EXP 50
62489: PUSH
62490: LD_VAR 0 2
62494: ARRAY
62495: NOT
62496: IFFALSE 62500
// break ;
62498: GO 62538
// if not HasTask ( j ) then
62500: LD_VAR 0 3
62504: PPUSH
62505: CALL_OW 314
62509: NOT
62510: IFFALSE 62536
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62512: LD_VAR 0 3
62516: PPUSH
62517: LD_EXP 50
62521: PUSH
62522: LD_VAR 0 2
62526: ARRAY
62527: PUSH
62528: LD_INT 1
62530: ARRAY
62531: PPUSH
62532: CALL 18012 0 2
// end ;
62536: GO 62386
62538: POP
62539: POP
// end else
62540: GO 63365
// if mc_build_list [ i ] then
62542: LD_EXP 48
62546: PUSH
62547: LD_VAR 0 2
62551: ARRAY
62552: IFFALSE 63365
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62554: LD_EXP 48
62558: PUSH
62559: LD_VAR 0 2
62563: ARRAY
62564: PUSH
62565: LD_INT 1
62567: ARRAY
62568: PUSH
62569: LD_INT 1
62571: ARRAY
62572: PPUSH
62573: CALL 17836 0 1
62577: PUSH
62578: LD_EXP 43
62582: PUSH
62583: LD_VAR 0 2
62587: ARRAY
62588: PPUSH
62589: LD_INT 2
62591: PUSH
62592: LD_INT 30
62594: PUSH
62595: LD_INT 2
62597: PUSH
62598: EMPTY
62599: LIST
62600: LIST
62601: PUSH
62602: LD_INT 30
62604: PUSH
62605: LD_INT 3
62607: PUSH
62608: EMPTY
62609: LIST
62610: LIST
62611: PUSH
62612: EMPTY
62613: LIST
62614: LIST
62615: LIST
62616: PPUSH
62617: CALL_OW 72
62621: NOT
62622: AND
62623: IFFALSE 62728
// begin for j = 1 to mc_build_list [ i ] do
62625: LD_ADDR_VAR 0 3
62629: PUSH
62630: DOUBLE
62631: LD_INT 1
62633: DEC
62634: ST_TO_ADDR
62635: LD_EXP 48
62639: PUSH
62640: LD_VAR 0 2
62644: ARRAY
62645: PUSH
62646: FOR_TO
62647: IFFALSE 62726
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62649: LD_EXP 48
62653: PUSH
62654: LD_VAR 0 2
62658: ARRAY
62659: PUSH
62660: LD_VAR 0 3
62664: ARRAY
62665: PUSH
62666: LD_INT 1
62668: ARRAY
62669: PUSH
62670: LD_INT 2
62672: EQUAL
62673: IFFALSE 62724
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62675: LD_ADDR_EXP 48
62679: PUSH
62680: LD_EXP 48
62684: PPUSH
62685: LD_VAR 0 2
62689: PPUSH
62690: LD_EXP 48
62694: PUSH
62695: LD_VAR 0 2
62699: ARRAY
62700: PPUSH
62701: LD_VAR 0 3
62705: PPUSH
62706: LD_INT 1
62708: PPUSH
62709: LD_INT 0
62711: PPUSH
62712: CALL 14192 0 4
62716: PPUSH
62717: CALL_OW 1
62721: ST_TO_ADDR
// break ;
62722: GO 62726
// end ;
62724: GO 62646
62726: POP
62727: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62728: LD_ADDR_VAR 0 6
62732: PUSH
62733: LD_EXP 43
62737: PUSH
62738: LD_VAR 0 2
62742: ARRAY
62743: PPUSH
62744: LD_INT 2
62746: PUSH
62747: LD_INT 30
62749: PUSH
62750: LD_INT 0
62752: PUSH
62753: EMPTY
62754: LIST
62755: LIST
62756: PUSH
62757: LD_INT 30
62759: PUSH
62760: LD_INT 1
62762: PUSH
62763: EMPTY
62764: LIST
62765: LIST
62766: PUSH
62767: EMPTY
62768: LIST
62769: LIST
62770: LIST
62771: PPUSH
62772: CALL_OW 72
62776: ST_TO_ADDR
// for k := 1 to depot do
62777: LD_ADDR_VAR 0 4
62781: PUSH
62782: DOUBLE
62783: LD_INT 1
62785: DEC
62786: ST_TO_ADDR
62787: LD_VAR 0 6
62791: PUSH
62792: FOR_TO
62793: IFFALSE 63363
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62795: LD_EXP 48
62799: PUSH
62800: LD_VAR 0 2
62804: ARRAY
62805: PUSH
62806: LD_INT 1
62808: ARRAY
62809: PUSH
62810: LD_INT 1
62812: ARRAY
62813: PUSH
62814: LD_INT 0
62816: EQUAL
62817: PUSH
62818: LD_VAR 0 6
62822: PUSH
62823: LD_VAR 0 4
62827: ARRAY
62828: PPUSH
62829: LD_EXP 48
62833: PUSH
62834: LD_VAR 0 2
62838: ARRAY
62839: PUSH
62840: LD_INT 1
62842: ARRAY
62843: PUSH
62844: LD_INT 1
62846: ARRAY
62847: PPUSH
62848: LD_EXP 48
62852: PUSH
62853: LD_VAR 0 2
62857: ARRAY
62858: PUSH
62859: LD_INT 1
62861: ARRAY
62862: PUSH
62863: LD_INT 2
62865: ARRAY
62866: PPUSH
62867: LD_EXP 48
62871: PUSH
62872: LD_VAR 0 2
62876: ARRAY
62877: PUSH
62878: LD_INT 1
62880: ARRAY
62881: PUSH
62882: LD_INT 3
62884: ARRAY
62885: PPUSH
62886: LD_EXP 48
62890: PUSH
62891: LD_VAR 0 2
62895: ARRAY
62896: PUSH
62897: LD_INT 1
62899: ARRAY
62900: PUSH
62901: LD_INT 4
62903: ARRAY
62904: PPUSH
62905: CALL 23248 0 5
62909: OR
62910: IFFALSE 63191
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62912: LD_ADDR_VAR 0 5
62916: PUSH
62917: LD_EXP 43
62921: PUSH
62922: LD_VAR 0 2
62926: ARRAY
62927: PPUSH
62928: LD_INT 25
62930: PUSH
62931: LD_INT 2
62933: PUSH
62934: EMPTY
62935: LIST
62936: LIST
62937: PPUSH
62938: CALL_OW 72
62942: PUSH
62943: LD_EXP 45
62947: PUSH
62948: LD_VAR 0 2
62952: ARRAY
62953: DIFF
62954: ST_TO_ADDR
// if not tmp then
62955: LD_VAR 0 5
62959: NOT
62960: IFFALSE 62964
// continue ;
62962: GO 62792
// for j in tmp do
62964: LD_ADDR_VAR 0 3
62968: PUSH
62969: LD_VAR 0 5
62973: PUSH
62974: FOR_IN
62975: IFFALSE 63187
// begin if not mc_builders [ i ] then
62977: LD_EXP 49
62981: PUSH
62982: LD_VAR 0 2
62986: ARRAY
62987: NOT
62988: IFFALSE 63046
// begin SetTag ( j , 103 ) ;
62990: LD_VAR 0 3
62994: PPUSH
62995: LD_INT 103
62997: PPUSH
62998: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63002: LD_ADDR_EXP 49
63006: PUSH
63007: LD_EXP 49
63011: PPUSH
63012: LD_VAR 0 2
63016: PUSH
63017: LD_EXP 49
63021: PUSH
63022: LD_VAR 0 2
63026: ARRAY
63027: PUSH
63028: LD_INT 1
63030: PLUS
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: PPUSH
63036: LD_VAR 0 3
63040: PPUSH
63041: CALL 14774 0 3
63045: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63046: LD_VAR 0 3
63050: PPUSH
63051: CALL_OW 310
63055: IFFALSE 63066
// ComExitBuilding ( j ) ;
63057: LD_VAR 0 3
63061: PPUSH
63062: CALL_OW 122
// wait ( 3 ) ;
63066: LD_INT 3
63068: PPUSH
63069: CALL_OW 67
// if not mc_build_list [ i ] then
63073: LD_EXP 48
63077: PUSH
63078: LD_VAR 0 2
63082: ARRAY
63083: NOT
63084: IFFALSE 63088
// break ;
63086: GO 63187
// if not HasTask ( j ) then
63088: LD_VAR 0 3
63092: PPUSH
63093: CALL_OW 314
63097: NOT
63098: IFFALSE 63185
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63100: LD_VAR 0 3
63104: PPUSH
63105: LD_EXP 48
63109: PUSH
63110: LD_VAR 0 2
63114: ARRAY
63115: PUSH
63116: LD_INT 1
63118: ARRAY
63119: PUSH
63120: LD_INT 1
63122: ARRAY
63123: PPUSH
63124: LD_EXP 48
63128: PUSH
63129: LD_VAR 0 2
63133: ARRAY
63134: PUSH
63135: LD_INT 1
63137: ARRAY
63138: PUSH
63139: LD_INT 2
63141: ARRAY
63142: PPUSH
63143: LD_EXP 48
63147: PUSH
63148: LD_VAR 0 2
63152: ARRAY
63153: PUSH
63154: LD_INT 1
63156: ARRAY
63157: PUSH
63158: LD_INT 3
63160: ARRAY
63161: PPUSH
63162: LD_EXP 48
63166: PUSH
63167: LD_VAR 0 2
63171: ARRAY
63172: PUSH
63173: LD_INT 1
63175: ARRAY
63176: PUSH
63177: LD_INT 4
63179: ARRAY
63180: PPUSH
63181: CALL_OW 145
// end ;
63185: GO 62974
63187: POP
63188: POP
// end else
63189: GO 63361
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63191: LD_EXP 43
63195: PUSH
63196: LD_VAR 0 2
63200: ARRAY
63201: PPUSH
63202: LD_EXP 48
63206: PUSH
63207: LD_VAR 0 2
63211: ARRAY
63212: PUSH
63213: LD_INT 1
63215: ARRAY
63216: PUSH
63217: LD_INT 1
63219: ARRAY
63220: PPUSH
63221: LD_EXP 48
63225: PUSH
63226: LD_VAR 0 2
63230: ARRAY
63231: PUSH
63232: LD_INT 1
63234: ARRAY
63235: PUSH
63236: LD_INT 2
63238: ARRAY
63239: PPUSH
63240: LD_EXP 48
63244: PUSH
63245: LD_VAR 0 2
63249: ARRAY
63250: PUSH
63251: LD_INT 1
63253: ARRAY
63254: PUSH
63255: LD_INT 3
63257: ARRAY
63258: PPUSH
63259: LD_EXP 48
63263: PUSH
63264: LD_VAR 0 2
63268: ARRAY
63269: PUSH
63270: LD_INT 1
63272: ARRAY
63273: PUSH
63274: LD_INT 4
63276: ARRAY
63277: PPUSH
63278: LD_EXP 43
63282: PUSH
63283: LD_VAR 0 2
63287: ARRAY
63288: PPUSH
63289: LD_INT 21
63291: PUSH
63292: LD_INT 3
63294: PUSH
63295: EMPTY
63296: LIST
63297: LIST
63298: PPUSH
63299: CALL_OW 72
63303: PPUSH
63304: EMPTY
63305: PPUSH
63306: CALL 22002 0 7
63310: NOT
63311: IFFALSE 63361
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63313: LD_ADDR_EXP 48
63317: PUSH
63318: LD_EXP 48
63322: PPUSH
63323: LD_VAR 0 2
63327: PPUSH
63328: LD_EXP 48
63332: PUSH
63333: LD_VAR 0 2
63337: ARRAY
63338: PPUSH
63339: LD_INT 1
63341: PPUSH
63342: LD_INT 1
63344: NEG
63345: PPUSH
63346: LD_INT 0
63348: PPUSH
63349: CALL 14192 0 4
63353: PPUSH
63354: CALL_OW 1
63358: ST_TO_ADDR
// continue ;
63359: GO 62792
// end ; end ;
63361: GO 62792
63363: POP
63364: POP
// end ; end ;
63365: GO 62221
63367: POP
63368: POP
// end ;
63369: LD_VAR 0 1
63373: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63374: LD_INT 0
63376: PPUSH
63377: PPUSH
63378: PPUSH
63379: PPUSH
63380: PPUSH
63381: PPUSH
// if not mc_bases then
63382: LD_EXP 43
63386: NOT
63387: IFFALSE 63391
// exit ;
63389: GO 63818
// for i = 1 to mc_bases do
63391: LD_ADDR_VAR 0 2
63395: PUSH
63396: DOUBLE
63397: LD_INT 1
63399: DEC
63400: ST_TO_ADDR
63401: LD_EXP 43
63405: PUSH
63406: FOR_TO
63407: IFFALSE 63816
// begin tmp := mc_build_upgrade [ i ] ;
63409: LD_ADDR_VAR 0 4
63413: PUSH
63414: LD_EXP 75
63418: PUSH
63419: LD_VAR 0 2
63423: ARRAY
63424: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
63425: LD_ADDR_VAR 0 6
63429: PUSH
63430: LD_EXP 76
63434: PUSH
63435: LD_VAR 0 2
63439: ARRAY
63440: PPUSH
63441: LD_INT 2
63443: PUSH
63444: LD_INT 30
63446: PUSH
63447: LD_INT 6
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: PUSH
63454: LD_INT 30
63456: PUSH
63457: LD_INT 7
63459: PUSH
63460: EMPTY
63461: LIST
63462: LIST
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: LIST
63468: PPUSH
63469: CALL_OW 72
63473: ST_TO_ADDR
// if not tmp and not lab then
63474: LD_VAR 0 4
63478: NOT
63479: PUSH
63480: LD_VAR 0 6
63484: NOT
63485: AND
63486: IFFALSE 63490
// continue ;
63488: GO 63406
// if tmp then
63490: LD_VAR 0 4
63494: IFFALSE 63614
// for j in tmp do
63496: LD_ADDR_VAR 0 3
63500: PUSH
63501: LD_VAR 0 4
63505: PUSH
63506: FOR_IN
63507: IFFALSE 63612
// begin if UpgradeCost ( j ) then
63509: LD_VAR 0 3
63513: PPUSH
63514: CALL 21662 0 1
63518: IFFALSE 63610
// begin ComUpgrade ( j ) ;
63520: LD_VAR 0 3
63524: PPUSH
63525: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63529: LD_ADDR_EXP 75
63533: PUSH
63534: LD_EXP 75
63538: PPUSH
63539: LD_VAR 0 2
63543: PPUSH
63544: LD_EXP 75
63548: PUSH
63549: LD_VAR 0 2
63553: ARRAY
63554: PUSH
63555: LD_VAR 0 3
63559: DIFF
63560: PPUSH
63561: CALL_OW 1
63565: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63566: LD_ADDR_EXP 50
63570: PUSH
63571: LD_EXP 50
63575: PPUSH
63576: LD_VAR 0 2
63580: PUSH
63581: LD_EXP 50
63585: PUSH
63586: LD_VAR 0 2
63590: ARRAY
63591: PUSH
63592: LD_INT 1
63594: PLUS
63595: PUSH
63596: EMPTY
63597: LIST
63598: LIST
63599: PPUSH
63600: LD_VAR 0 3
63604: PPUSH
63605: CALL 14774 0 3
63609: ST_TO_ADDR
// end ; end ;
63610: GO 63506
63612: POP
63613: POP
// if not lab or not mc_lab_upgrade [ i ] then
63614: LD_VAR 0 6
63618: NOT
63619: PUSH
63620: LD_EXP 77
63624: PUSH
63625: LD_VAR 0 2
63629: ARRAY
63630: NOT
63631: OR
63632: IFFALSE 63636
// continue ;
63634: GO 63406
// for j in lab do
63636: LD_ADDR_VAR 0 3
63640: PUSH
63641: LD_VAR 0 6
63645: PUSH
63646: FOR_IN
63647: IFFALSE 63812
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63649: LD_VAR 0 3
63653: PPUSH
63654: CALL_OW 266
63658: PUSH
63659: LD_INT 6
63661: PUSH
63662: LD_INT 7
63664: PUSH
63665: EMPTY
63666: LIST
63667: LIST
63668: IN
63669: PUSH
63670: LD_VAR 0 3
63674: PPUSH
63675: CALL_OW 461
63679: PUSH
63680: LD_INT 1
63682: NONEQUAL
63683: AND
63684: IFFALSE 63810
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63686: LD_VAR 0 3
63690: PPUSH
63691: LD_EXP 77
63695: PUSH
63696: LD_VAR 0 2
63700: ARRAY
63701: PUSH
63702: LD_INT 1
63704: ARRAY
63705: PPUSH
63706: CALL 21867 0 2
63710: IFFALSE 63810
// begin ComCancel ( j ) ;
63712: LD_VAR 0 3
63716: PPUSH
63717: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63721: LD_VAR 0 3
63725: PPUSH
63726: LD_EXP 77
63730: PUSH
63731: LD_VAR 0 2
63735: ARRAY
63736: PUSH
63737: LD_INT 1
63739: ARRAY
63740: PPUSH
63741: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63745: LD_VAR 0 3
63749: PUSH
63750: LD_EXP 50
63754: PUSH
63755: LD_VAR 0 2
63759: ARRAY
63760: IN
63761: NOT
63762: IFFALSE 63808
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63764: LD_ADDR_EXP 50
63768: PUSH
63769: LD_EXP 50
63773: PPUSH
63774: LD_VAR 0 2
63778: PUSH
63779: LD_EXP 50
63783: PUSH
63784: LD_VAR 0 2
63788: ARRAY
63789: PUSH
63790: LD_INT 1
63792: PLUS
63793: PUSH
63794: EMPTY
63795: LIST
63796: LIST
63797: PPUSH
63798: LD_VAR 0 3
63802: PPUSH
63803: CALL 14774 0 3
63807: ST_TO_ADDR
// break ;
63808: GO 63812
// end ; end ; end ;
63810: GO 63646
63812: POP
63813: POP
// end ;
63814: GO 63406
63816: POP
63817: POP
// end ;
63818: LD_VAR 0 1
63822: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63823: LD_INT 0
63825: PPUSH
63826: PPUSH
63827: PPUSH
63828: PPUSH
63829: PPUSH
63830: PPUSH
63831: PPUSH
63832: PPUSH
63833: PPUSH
// if not mc_bases then
63834: LD_EXP 43
63838: NOT
63839: IFFALSE 63843
// exit ;
63841: GO 64248
// for i = 1 to mc_bases do
63843: LD_ADDR_VAR 0 2
63847: PUSH
63848: DOUBLE
63849: LD_INT 1
63851: DEC
63852: ST_TO_ADDR
63853: LD_EXP 43
63857: PUSH
63858: FOR_TO
63859: IFFALSE 64246
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63861: LD_EXP 51
63865: PUSH
63866: LD_VAR 0 2
63870: ARRAY
63871: NOT
63872: PUSH
63873: LD_EXP 43
63877: PUSH
63878: LD_VAR 0 2
63882: ARRAY
63883: PPUSH
63884: LD_INT 30
63886: PUSH
63887: LD_INT 3
63889: PUSH
63890: EMPTY
63891: LIST
63892: LIST
63893: PPUSH
63894: CALL_OW 72
63898: NOT
63899: OR
63900: IFFALSE 63904
// continue ;
63902: GO 63858
// busy := false ;
63904: LD_ADDR_VAR 0 8
63908: PUSH
63909: LD_INT 0
63911: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63912: LD_ADDR_VAR 0 4
63916: PUSH
63917: LD_EXP 43
63921: PUSH
63922: LD_VAR 0 2
63926: ARRAY
63927: PPUSH
63928: LD_INT 30
63930: PUSH
63931: LD_INT 3
63933: PUSH
63934: EMPTY
63935: LIST
63936: LIST
63937: PPUSH
63938: CALL_OW 72
63942: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63943: LD_ADDR_VAR 0 6
63947: PUSH
63948: LD_EXP 51
63952: PUSH
63953: LD_VAR 0 2
63957: ARRAY
63958: PPUSH
63959: LD_INT 2
63961: PUSH
63962: LD_INT 30
63964: PUSH
63965: LD_INT 32
63967: PUSH
63968: EMPTY
63969: LIST
63970: LIST
63971: PUSH
63972: LD_INT 30
63974: PUSH
63975: LD_INT 33
63977: PUSH
63978: EMPTY
63979: LIST
63980: LIST
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: LIST
63986: PPUSH
63987: CALL_OW 72
63991: ST_TO_ADDR
// if not t then
63992: LD_VAR 0 6
63996: NOT
63997: IFFALSE 64001
// continue ;
63999: GO 63858
// for j in tmp do
64001: LD_ADDR_VAR 0 3
64005: PUSH
64006: LD_VAR 0 4
64010: PUSH
64011: FOR_IN
64012: IFFALSE 64042
// if not BuildingStatus ( j ) = bs_idle then
64014: LD_VAR 0 3
64018: PPUSH
64019: CALL_OW 461
64023: PUSH
64024: LD_INT 2
64026: EQUAL
64027: NOT
64028: IFFALSE 64040
// begin busy := true ;
64030: LD_ADDR_VAR 0 8
64034: PUSH
64035: LD_INT 1
64037: ST_TO_ADDR
// break ;
64038: GO 64042
// end ;
64040: GO 64011
64042: POP
64043: POP
// if busy then
64044: LD_VAR 0 8
64048: IFFALSE 64052
// continue ;
64050: GO 63858
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64052: LD_ADDR_VAR 0 7
64056: PUSH
64057: LD_VAR 0 6
64061: PPUSH
64062: LD_INT 35
64064: PUSH
64065: LD_INT 0
64067: PUSH
64068: EMPTY
64069: LIST
64070: LIST
64071: PPUSH
64072: CALL_OW 72
64076: ST_TO_ADDR
// if tw then
64077: LD_VAR 0 7
64081: IFFALSE 64158
// begin tw := tw [ 1 ] ;
64083: LD_ADDR_VAR 0 7
64087: PUSH
64088: LD_VAR 0 7
64092: PUSH
64093: LD_INT 1
64095: ARRAY
64096: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64097: LD_ADDR_VAR 0 9
64101: PUSH
64102: LD_VAR 0 7
64106: PPUSH
64107: LD_EXP 68
64111: PUSH
64112: LD_VAR 0 2
64116: ARRAY
64117: PPUSH
64118: CALL 20159 0 2
64122: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64123: LD_EXP 82
64127: PUSH
64128: LD_VAR 0 2
64132: ARRAY
64133: IFFALSE 64156
// if not weapon in mc_allowed_tower_weapons [ i ] then
64135: LD_VAR 0 9
64139: PUSH
64140: LD_EXP 82
64144: PUSH
64145: LD_VAR 0 2
64149: ARRAY
64150: IN
64151: NOT
64152: IFFALSE 64156
// continue ;
64154: GO 63858
// end else
64156: GO 64221
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64158: LD_ADDR_VAR 0 5
64162: PUSH
64163: LD_EXP 51
64167: PUSH
64168: LD_VAR 0 2
64172: ARRAY
64173: PPUSH
64174: LD_VAR 0 4
64178: PPUSH
64179: CALL 47062 0 2
64183: ST_TO_ADDR
// if not tmp2 then
64184: LD_VAR 0 5
64188: NOT
64189: IFFALSE 64193
// continue ;
64191: GO 63858
// tw := tmp2 [ 1 ] ;
64193: LD_ADDR_VAR 0 7
64197: PUSH
64198: LD_VAR 0 5
64202: PUSH
64203: LD_INT 1
64205: ARRAY
64206: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64207: LD_ADDR_VAR 0 9
64211: PUSH
64212: LD_VAR 0 5
64216: PUSH
64217: LD_INT 2
64219: ARRAY
64220: ST_TO_ADDR
// end ; if not weapon then
64221: LD_VAR 0 9
64225: NOT
64226: IFFALSE 64230
// continue ;
64228: GO 63858
// ComPlaceWeapon ( tw , weapon ) ;
64230: LD_VAR 0 7
64234: PPUSH
64235: LD_VAR 0 9
64239: PPUSH
64240: CALL_OW 148
// end ;
64244: GO 63858
64246: POP
64247: POP
// end ;
64248: LD_VAR 0 1
64252: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64253: LD_INT 0
64255: PPUSH
64256: PPUSH
64257: PPUSH
64258: PPUSH
64259: PPUSH
64260: PPUSH
64261: PPUSH
// if not mc_bases then
64262: LD_EXP 43
64266: NOT
64267: IFFALSE 64271
// exit ;
64269: GO 65046
// for i = 1 to mc_bases do
64271: LD_ADDR_VAR 0 2
64275: PUSH
64276: DOUBLE
64277: LD_INT 1
64279: DEC
64280: ST_TO_ADDR
64281: LD_EXP 43
64285: PUSH
64286: FOR_TO
64287: IFFALSE 65044
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64289: LD_EXP 56
64293: PUSH
64294: LD_VAR 0 2
64298: ARRAY
64299: NOT
64300: PUSH
64301: LD_EXP 56
64305: PUSH
64306: LD_VAR 0 2
64310: ARRAY
64311: PUSH
64312: LD_EXP 57
64316: PUSH
64317: LD_VAR 0 2
64321: ARRAY
64322: EQUAL
64323: OR
64324: PUSH
64325: LD_EXP 66
64329: PUSH
64330: LD_VAR 0 2
64334: ARRAY
64335: OR
64336: IFFALSE 64340
// continue ;
64338: GO 64286
// if mc_miners [ i ] then
64340: LD_EXP 57
64344: PUSH
64345: LD_VAR 0 2
64349: ARRAY
64350: IFFALSE 64731
// begin for j = mc_miners [ i ] downto 1 do
64352: LD_ADDR_VAR 0 3
64356: PUSH
64357: DOUBLE
64358: LD_EXP 57
64362: PUSH
64363: LD_VAR 0 2
64367: ARRAY
64368: INC
64369: ST_TO_ADDR
64370: LD_INT 1
64372: PUSH
64373: FOR_DOWNTO
64374: IFFALSE 64729
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
64376: LD_EXP 57
64380: PUSH
64381: LD_VAR 0 2
64385: ARRAY
64386: PUSH
64387: LD_VAR 0 3
64391: ARRAY
64392: PPUSH
64393: CALL_OW 301
64397: PUSH
64398: LD_EXP 57
64402: PUSH
64403: LD_VAR 0 2
64407: ARRAY
64408: PUSH
64409: LD_VAR 0 3
64413: ARRAY
64414: PPUSH
64415: CALL_OW 257
64419: PUSH
64420: LD_INT 1
64422: NONEQUAL
64423: OR
64424: IFFALSE 64487
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
64426: LD_ADDR_VAR 0 5
64430: PUSH
64431: LD_EXP 57
64435: PUSH
64436: LD_VAR 0 2
64440: ARRAY
64441: PUSH
64442: LD_EXP 57
64446: PUSH
64447: LD_VAR 0 2
64451: ARRAY
64452: PUSH
64453: LD_VAR 0 3
64457: ARRAY
64458: DIFF
64459: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64460: LD_ADDR_EXP 57
64464: PUSH
64465: LD_EXP 57
64469: PPUSH
64470: LD_VAR 0 2
64474: PPUSH
64475: LD_VAR 0 5
64479: PPUSH
64480: CALL_OW 1
64484: ST_TO_ADDR
// continue ;
64485: GO 64373
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64487: LD_EXP 57
64491: PUSH
64492: LD_VAR 0 2
64496: ARRAY
64497: PUSH
64498: LD_VAR 0 3
64502: ARRAY
64503: PPUSH
64504: CALL_OW 257
64508: PUSH
64509: LD_INT 1
64511: EQUAL
64512: PUSH
64513: LD_EXP 57
64517: PUSH
64518: LD_VAR 0 2
64522: ARRAY
64523: PUSH
64524: LD_VAR 0 3
64528: ARRAY
64529: PPUSH
64530: CALL_OW 459
64534: NOT
64535: AND
64536: PUSH
64537: LD_EXP 57
64541: PUSH
64542: LD_VAR 0 2
64546: ARRAY
64547: PUSH
64548: LD_VAR 0 3
64552: ARRAY
64553: PPUSH
64554: CALL_OW 314
64558: NOT
64559: AND
64560: IFFALSE 64727
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64562: LD_EXP 57
64566: PUSH
64567: LD_VAR 0 2
64571: ARRAY
64572: PUSH
64573: LD_VAR 0 3
64577: ARRAY
64578: PPUSH
64579: CALL_OW 310
64583: IFFALSE 64606
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64585: LD_EXP 57
64589: PUSH
64590: LD_VAR 0 2
64594: ARRAY
64595: PUSH
64596: LD_VAR 0 3
64600: ARRAY
64601: PPUSH
64602: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64606: LD_EXP 57
64610: PUSH
64611: LD_VAR 0 2
64615: ARRAY
64616: PUSH
64617: LD_VAR 0 3
64621: ARRAY
64622: PPUSH
64623: CALL_OW 314
64627: NOT
64628: IFFALSE 64727
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
64630: LD_ADDR_VAR 0 7
64634: PUSH
64635: LD_VAR 0 3
64639: PUSH
64640: LD_EXP 56
64644: PUSH
64645: LD_VAR 0 2
64649: ARRAY
64650: PPUSH
64651: CALL 11914 0 1
64655: MOD
64656: PUSH
64657: LD_INT 1
64659: PLUS
64660: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64661: LD_EXP 57
64665: PUSH
64666: LD_VAR 0 2
64670: ARRAY
64671: PUSH
64672: LD_VAR 0 3
64676: ARRAY
64677: PPUSH
64678: LD_EXP 56
64682: PUSH
64683: LD_VAR 0 2
64687: ARRAY
64688: PUSH
64689: LD_VAR 0 7
64693: ARRAY
64694: PUSH
64695: LD_INT 1
64697: ARRAY
64698: PPUSH
64699: LD_EXP 56
64703: PUSH
64704: LD_VAR 0 2
64708: ARRAY
64709: PUSH
64710: LD_VAR 0 7
64714: ARRAY
64715: PUSH
64716: LD_INT 2
64718: ARRAY
64719: PPUSH
64720: LD_INT 0
64722: PPUSH
64723: CALL_OW 193
// end ; end ; end ;
64727: GO 64373
64729: POP
64730: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64731: LD_ADDR_VAR 0 5
64735: PUSH
64736: LD_EXP 43
64740: PUSH
64741: LD_VAR 0 2
64745: ARRAY
64746: PPUSH
64747: LD_INT 2
64749: PUSH
64750: LD_INT 30
64752: PUSH
64753: LD_INT 4
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: PUSH
64760: LD_INT 30
64762: PUSH
64763: LD_INT 5
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PUSH
64770: LD_INT 30
64772: PUSH
64773: LD_INT 32
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: PUSH
64780: EMPTY
64781: LIST
64782: LIST
64783: LIST
64784: LIST
64785: PPUSH
64786: CALL_OW 72
64790: ST_TO_ADDR
// if not tmp then
64791: LD_VAR 0 5
64795: NOT
64796: IFFALSE 64800
// continue ;
64798: GO 64286
// list := [ ] ;
64800: LD_ADDR_VAR 0 6
64804: PUSH
64805: EMPTY
64806: ST_TO_ADDR
// for j in tmp do
64807: LD_ADDR_VAR 0 3
64811: PUSH
64812: LD_VAR 0 5
64816: PUSH
64817: FOR_IN
64818: IFFALSE 64887
// begin for k in UnitsInside ( j ) do
64820: LD_ADDR_VAR 0 4
64824: PUSH
64825: LD_VAR 0 3
64829: PPUSH
64830: CALL_OW 313
64834: PUSH
64835: FOR_IN
64836: IFFALSE 64883
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64838: LD_VAR 0 4
64842: PPUSH
64843: CALL_OW 257
64847: PUSH
64848: LD_INT 1
64850: EQUAL
64851: PUSH
64852: LD_VAR 0 4
64856: PPUSH
64857: CALL_OW 459
64861: NOT
64862: AND
64863: IFFALSE 64881
// list := list ^ k ;
64865: LD_ADDR_VAR 0 6
64869: PUSH
64870: LD_VAR 0 6
64874: PUSH
64875: LD_VAR 0 4
64879: ADD
64880: ST_TO_ADDR
64881: GO 64835
64883: POP
64884: POP
// end ;
64885: GO 64817
64887: POP
64888: POP
// list := list diff mc_miners [ i ] ;
64889: LD_ADDR_VAR 0 6
64893: PUSH
64894: LD_VAR 0 6
64898: PUSH
64899: LD_EXP 57
64903: PUSH
64904: LD_VAR 0 2
64908: ARRAY
64909: DIFF
64910: ST_TO_ADDR
// if not list then
64911: LD_VAR 0 6
64915: NOT
64916: IFFALSE 64920
// continue ;
64918: GO 64286
// k := mc_mines [ i ] - mc_miners [ i ] ;
64920: LD_ADDR_VAR 0 4
64924: PUSH
64925: LD_EXP 56
64929: PUSH
64930: LD_VAR 0 2
64934: ARRAY
64935: PUSH
64936: LD_EXP 57
64940: PUSH
64941: LD_VAR 0 2
64945: ARRAY
64946: MINUS
64947: ST_TO_ADDR
// if k > list then
64948: LD_VAR 0 4
64952: PUSH
64953: LD_VAR 0 6
64957: GREATER
64958: IFFALSE 64970
// k := list ;
64960: LD_ADDR_VAR 0 4
64964: PUSH
64965: LD_VAR 0 6
64969: ST_TO_ADDR
// for j = 1 to k do
64970: LD_ADDR_VAR 0 3
64974: PUSH
64975: DOUBLE
64976: LD_INT 1
64978: DEC
64979: ST_TO_ADDR
64980: LD_VAR 0 4
64984: PUSH
64985: FOR_TO
64986: IFFALSE 65040
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64988: LD_ADDR_EXP 57
64992: PUSH
64993: LD_EXP 57
64997: PPUSH
64998: LD_VAR 0 2
65002: PUSH
65003: LD_EXP 57
65007: PUSH
65008: LD_VAR 0 2
65012: ARRAY
65013: PUSH
65014: LD_INT 1
65016: PLUS
65017: PUSH
65018: EMPTY
65019: LIST
65020: LIST
65021: PPUSH
65022: LD_VAR 0 6
65026: PUSH
65027: LD_VAR 0 3
65031: ARRAY
65032: PPUSH
65033: CALL 14774 0 3
65037: ST_TO_ADDR
65038: GO 64985
65040: POP
65041: POP
// end ;
65042: GO 64286
65044: POP
65045: POP
// end ;
65046: LD_VAR 0 1
65050: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
65051: LD_INT 0
65053: PPUSH
65054: PPUSH
65055: PPUSH
65056: PPUSH
65057: PPUSH
65058: PPUSH
65059: PPUSH
65060: PPUSH
65061: PPUSH
65062: PPUSH
65063: PPUSH
// if not mc_bases then
65064: LD_EXP 43
65068: NOT
65069: IFFALSE 65073
// exit ;
65071: GO 66896
// for i = 1 to mc_bases do
65073: LD_ADDR_VAR 0 2
65077: PUSH
65078: DOUBLE
65079: LD_INT 1
65081: DEC
65082: ST_TO_ADDR
65083: LD_EXP 43
65087: PUSH
65088: FOR_TO
65089: IFFALSE 66894
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65091: LD_EXP 43
65095: PUSH
65096: LD_VAR 0 2
65100: ARRAY
65101: NOT
65102: PUSH
65103: LD_EXP 50
65107: PUSH
65108: LD_VAR 0 2
65112: ARRAY
65113: OR
65114: IFFALSE 65118
// continue ;
65116: GO 65088
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65118: LD_EXP 59
65122: PUSH
65123: LD_VAR 0 2
65127: ARRAY
65128: NOT
65129: PUSH
65130: LD_EXP 60
65134: PUSH
65135: LD_VAR 0 2
65139: ARRAY
65140: AND
65141: IFFALSE 65179
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65143: LD_ADDR_EXP 60
65147: PUSH
65148: LD_EXP 60
65152: PPUSH
65153: LD_VAR 0 2
65157: PPUSH
65158: EMPTY
65159: PPUSH
65160: CALL_OW 1
65164: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65165: LD_VAR 0 2
65169: PPUSH
65170: LD_INT 107
65172: PPUSH
65173: CALL 55905 0 2
// continue ;
65177: GO 65088
// end ; target := [ ] ;
65179: LD_ADDR_VAR 0 7
65183: PUSH
65184: EMPTY
65185: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65186: LD_ADDR_VAR 0 6
65190: PUSH
65191: LD_EXP 43
65195: PUSH
65196: LD_VAR 0 2
65200: ARRAY
65201: PUSH
65202: LD_INT 1
65204: ARRAY
65205: PPUSH
65206: CALL_OW 255
65210: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65211: LD_ADDR_VAR 0 9
65215: PUSH
65216: LD_EXP 43
65220: PUSH
65221: LD_VAR 0 2
65225: ARRAY
65226: PPUSH
65227: LD_INT 2
65229: PUSH
65230: LD_INT 30
65232: PUSH
65233: LD_INT 0
65235: PUSH
65236: EMPTY
65237: LIST
65238: LIST
65239: PUSH
65240: LD_INT 30
65242: PUSH
65243: LD_INT 1
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: LIST
65254: PPUSH
65255: CALL_OW 72
65259: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65260: LD_ADDR_VAR 0 3
65264: PUSH
65265: DOUBLE
65266: LD_EXP 59
65270: PUSH
65271: LD_VAR 0 2
65275: ARRAY
65276: INC
65277: ST_TO_ADDR
65278: LD_INT 1
65280: PUSH
65281: FOR_DOWNTO
65282: IFFALSE 65527
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65284: LD_EXP 59
65288: PUSH
65289: LD_VAR 0 2
65293: ARRAY
65294: PUSH
65295: LD_VAR 0 3
65299: ARRAY
65300: PUSH
65301: LD_INT 2
65303: ARRAY
65304: PPUSH
65305: LD_EXP 59
65309: PUSH
65310: LD_VAR 0 2
65314: ARRAY
65315: PUSH
65316: LD_VAR 0 3
65320: ARRAY
65321: PUSH
65322: LD_INT 3
65324: ARRAY
65325: PPUSH
65326: CALL_OW 488
65330: PUSH
65331: LD_EXP 59
65335: PUSH
65336: LD_VAR 0 2
65340: ARRAY
65341: PUSH
65342: LD_VAR 0 3
65346: ARRAY
65347: PUSH
65348: LD_INT 2
65350: ARRAY
65351: PPUSH
65352: LD_EXP 59
65356: PUSH
65357: LD_VAR 0 2
65361: ARRAY
65362: PUSH
65363: LD_VAR 0 3
65367: ARRAY
65368: PUSH
65369: LD_INT 3
65371: ARRAY
65372: PPUSH
65373: CALL_OW 284
65377: PUSH
65378: LD_INT 0
65380: EQUAL
65381: AND
65382: IFFALSE 65437
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65384: LD_ADDR_VAR 0 5
65388: PUSH
65389: LD_EXP 59
65393: PUSH
65394: LD_VAR 0 2
65398: ARRAY
65399: PPUSH
65400: LD_VAR 0 3
65404: PPUSH
65405: CALL_OW 3
65409: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
65410: LD_ADDR_EXP 59
65414: PUSH
65415: LD_EXP 59
65419: PPUSH
65420: LD_VAR 0 2
65424: PPUSH
65425: LD_VAR 0 5
65429: PPUSH
65430: CALL_OW 1
65434: ST_TO_ADDR
// continue ;
65435: GO 65281
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
65437: LD_VAR 0 6
65441: PPUSH
65442: LD_EXP 59
65446: PUSH
65447: LD_VAR 0 2
65451: ARRAY
65452: PUSH
65453: LD_VAR 0 3
65457: ARRAY
65458: PUSH
65459: LD_INT 2
65461: ARRAY
65462: PPUSH
65463: LD_EXP 59
65467: PUSH
65468: LD_VAR 0 2
65472: ARRAY
65473: PUSH
65474: LD_VAR 0 3
65478: ARRAY
65479: PUSH
65480: LD_INT 3
65482: ARRAY
65483: PPUSH
65484: LD_INT 30
65486: PPUSH
65487: CALL 16038 0 4
65491: PUSH
65492: LD_INT 4
65494: ARRAY
65495: PUSH
65496: LD_INT 0
65498: EQUAL
65499: IFFALSE 65525
// begin target := mc_crates [ i ] [ j ] ;
65501: LD_ADDR_VAR 0 7
65505: PUSH
65506: LD_EXP 59
65510: PUSH
65511: LD_VAR 0 2
65515: ARRAY
65516: PUSH
65517: LD_VAR 0 3
65521: ARRAY
65522: ST_TO_ADDR
// break ;
65523: GO 65527
// end ; end ;
65525: GO 65281
65527: POP
65528: POP
// if not target then
65529: LD_VAR 0 7
65533: NOT
65534: IFFALSE 65538
// continue ;
65536: GO 65088
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65538: LD_ADDR_VAR 0 8
65542: PUSH
65543: LD_EXP 62
65547: PUSH
65548: LD_VAR 0 2
65552: ARRAY
65553: PPUSH
65554: LD_INT 2
65556: PUSH
65557: LD_INT 3
65559: PUSH
65560: LD_INT 58
65562: PUSH
65563: EMPTY
65564: LIST
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: PUSH
65570: LD_INT 61
65572: PUSH
65573: EMPTY
65574: LIST
65575: PUSH
65576: LD_INT 33
65578: PUSH
65579: LD_INT 5
65581: PUSH
65582: EMPTY
65583: LIST
65584: LIST
65585: PUSH
65586: LD_INT 33
65588: PUSH
65589: LD_INT 3
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: EMPTY
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: PUSH
65603: LD_INT 2
65605: PUSH
65606: LD_INT 34
65608: PUSH
65609: LD_INT 32
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: PUSH
65616: LD_INT 34
65618: PUSH
65619: LD_INT 51
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: PUSH
65626: LD_INT 34
65628: PUSH
65629: LD_INT 12
65631: PUSH
65632: EMPTY
65633: LIST
65634: LIST
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: LIST
65640: LIST
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: PPUSH
65646: CALL_OW 72
65650: ST_TO_ADDR
// if not cargo then
65651: LD_VAR 0 8
65655: NOT
65656: IFFALSE 66362
// begin if mc_crates_collector [ i ] < 5 then
65658: LD_EXP 60
65662: PUSH
65663: LD_VAR 0 2
65667: ARRAY
65668: PUSH
65669: LD_INT 5
65671: LESS
65672: IFFALSE 66038
// begin if mc_ape [ i ] then
65674: LD_EXP 72
65678: PUSH
65679: LD_VAR 0 2
65683: ARRAY
65684: IFFALSE 65731
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65686: LD_ADDR_VAR 0 5
65690: PUSH
65691: LD_EXP 72
65695: PUSH
65696: LD_VAR 0 2
65700: ARRAY
65701: PPUSH
65702: LD_INT 25
65704: PUSH
65705: LD_INT 16
65707: PUSH
65708: EMPTY
65709: LIST
65710: LIST
65711: PUSH
65712: LD_INT 24
65714: PUSH
65715: LD_INT 750
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: PUSH
65722: EMPTY
65723: LIST
65724: LIST
65725: PPUSH
65726: CALL_OW 72
65730: ST_TO_ADDR
// if not tmp then
65731: LD_VAR 0 5
65735: NOT
65736: IFFALSE 65783
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65738: LD_ADDR_VAR 0 5
65742: PUSH
65743: LD_EXP 43
65747: PUSH
65748: LD_VAR 0 2
65752: ARRAY
65753: PPUSH
65754: LD_INT 25
65756: PUSH
65757: LD_INT 2
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: LD_INT 24
65766: PUSH
65767: LD_INT 750
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: PUSH
65774: EMPTY
65775: LIST
65776: LIST
65777: PPUSH
65778: CALL_OW 72
65782: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65783: LD_EXP 72
65787: PUSH
65788: LD_VAR 0 2
65792: ARRAY
65793: PUSH
65794: LD_EXP 43
65798: PUSH
65799: LD_VAR 0 2
65803: ARRAY
65804: PPUSH
65805: LD_INT 25
65807: PUSH
65808: LD_INT 2
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: LD_INT 24
65817: PUSH
65818: LD_INT 750
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: PPUSH
65829: CALL_OW 72
65833: AND
65834: PUSH
65835: LD_VAR 0 5
65839: PUSH
65840: LD_INT 5
65842: LESS
65843: AND
65844: IFFALSE 65926
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65846: LD_ADDR_VAR 0 3
65850: PUSH
65851: LD_EXP 43
65855: PUSH
65856: LD_VAR 0 2
65860: ARRAY
65861: PPUSH
65862: LD_INT 25
65864: PUSH
65865: LD_INT 2
65867: PUSH
65868: EMPTY
65869: LIST
65870: LIST
65871: PUSH
65872: LD_INT 24
65874: PUSH
65875: LD_INT 750
65877: PUSH
65878: EMPTY
65879: LIST
65880: LIST
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PPUSH
65886: CALL_OW 72
65890: PUSH
65891: FOR_IN
65892: IFFALSE 65924
// begin tmp := tmp union j ;
65894: LD_ADDR_VAR 0 5
65898: PUSH
65899: LD_VAR 0 5
65903: PUSH
65904: LD_VAR 0 3
65908: UNION
65909: ST_TO_ADDR
// if tmp >= 5 then
65910: LD_VAR 0 5
65914: PUSH
65915: LD_INT 5
65917: GREATEREQUAL
65918: IFFALSE 65922
// break ;
65920: GO 65924
// end ;
65922: GO 65891
65924: POP
65925: POP
// end ; if not tmp then
65926: LD_VAR 0 5
65930: NOT
65931: IFFALSE 65935
// continue ;
65933: GO 65088
// for j in tmp do
65935: LD_ADDR_VAR 0 3
65939: PUSH
65940: LD_VAR 0 5
65944: PUSH
65945: FOR_IN
65946: IFFALSE 66036
// if not GetTag ( j ) then
65948: LD_VAR 0 3
65952: PPUSH
65953: CALL_OW 110
65957: NOT
65958: IFFALSE 66034
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65960: LD_ADDR_EXP 60
65964: PUSH
65965: LD_EXP 60
65969: PPUSH
65970: LD_VAR 0 2
65974: PUSH
65975: LD_EXP 60
65979: PUSH
65980: LD_VAR 0 2
65984: ARRAY
65985: PUSH
65986: LD_INT 1
65988: PLUS
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PPUSH
65994: LD_VAR 0 3
65998: PPUSH
65999: CALL 14774 0 3
66003: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66004: LD_VAR 0 3
66008: PPUSH
66009: LD_INT 107
66011: PPUSH
66012: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66016: LD_EXP 60
66020: PUSH
66021: LD_VAR 0 2
66025: ARRAY
66026: PUSH
66027: LD_INT 5
66029: GREATEREQUAL
66030: IFFALSE 66034
// break ;
66032: GO 66036
// end ;
66034: GO 65945
66036: POP
66037: POP
// end ; if mc_crates_collector [ i ] and target then
66038: LD_EXP 60
66042: PUSH
66043: LD_VAR 0 2
66047: ARRAY
66048: PUSH
66049: LD_VAR 0 7
66053: AND
66054: IFFALSE 66360
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66056: LD_EXP 60
66060: PUSH
66061: LD_VAR 0 2
66065: ARRAY
66066: PUSH
66067: LD_VAR 0 7
66071: PUSH
66072: LD_INT 1
66074: ARRAY
66075: LESS
66076: IFFALSE 66096
// tmp := mc_crates_collector [ i ] else
66078: LD_ADDR_VAR 0 5
66082: PUSH
66083: LD_EXP 60
66087: PUSH
66088: LD_VAR 0 2
66092: ARRAY
66093: ST_TO_ADDR
66094: GO 66110
// tmp := target [ 1 ] ;
66096: LD_ADDR_VAR 0 5
66100: PUSH
66101: LD_VAR 0 7
66105: PUSH
66106: LD_INT 1
66108: ARRAY
66109: ST_TO_ADDR
// k := 0 ;
66110: LD_ADDR_VAR 0 4
66114: PUSH
66115: LD_INT 0
66117: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66118: LD_ADDR_VAR 0 3
66122: PUSH
66123: LD_EXP 60
66127: PUSH
66128: LD_VAR 0 2
66132: ARRAY
66133: PUSH
66134: FOR_IN
66135: IFFALSE 66358
// begin k := k + 1 ;
66137: LD_ADDR_VAR 0 4
66141: PUSH
66142: LD_VAR 0 4
66146: PUSH
66147: LD_INT 1
66149: PLUS
66150: ST_TO_ADDR
// if k > tmp then
66151: LD_VAR 0 4
66155: PUSH
66156: LD_VAR 0 5
66160: GREATER
66161: IFFALSE 66165
// break ;
66163: GO 66358
// if not GetClass ( j ) in [ 2 , 16 ] then
66165: LD_VAR 0 3
66169: PPUSH
66170: CALL_OW 257
66174: PUSH
66175: LD_INT 2
66177: PUSH
66178: LD_INT 16
66180: PUSH
66181: EMPTY
66182: LIST
66183: LIST
66184: IN
66185: NOT
66186: IFFALSE 66239
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66188: LD_ADDR_EXP 60
66192: PUSH
66193: LD_EXP 60
66197: PPUSH
66198: LD_VAR 0 2
66202: PPUSH
66203: LD_EXP 60
66207: PUSH
66208: LD_VAR 0 2
66212: ARRAY
66213: PUSH
66214: LD_VAR 0 3
66218: DIFF
66219: PPUSH
66220: CALL_OW 1
66224: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66225: LD_VAR 0 3
66229: PPUSH
66230: LD_INT 0
66232: PPUSH
66233: CALL_OW 109
// continue ;
66237: GO 66134
// end ; if IsInUnit ( j ) then
66239: LD_VAR 0 3
66243: PPUSH
66244: CALL_OW 310
66248: IFFALSE 66259
// ComExitBuilding ( j ) ;
66250: LD_VAR 0 3
66254: PPUSH
66255: CALL_OW 122
// wait ( 3 ) ;
66259: LD_INT 3
66261: PPUSH
66262: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
66266: LD_VAR 0 3
66270: PPUSH
66271: CALL_OW 314
66275: PUSH
66276: LD_VAR 0 6
66280: PPUSH
66281: LD_VAR 0 7
66285: PUSH
66286: LD_INT 2
66288: ARRAY
66289: PPUSH
66290: LD_VAR 0 7
66294: PUSH
66295: LD_INT 3
66297: ARRAY
66298: PPUSH
66299: LD_INT 30
66301: PPUSH
66302: CALL 16038 0 4
66306: PUSH
66307: LD_INT 4
66309: ARRAY
66310: AND
66311: IFFALSE 66329
// ComStandNearbyBuilding ( j , depot ) else
66313: LD_VAR 0 3
66317: PPUSH
66318: LD_VAR 0 9
66322: PPUSH
66323: CALL 11376 0 2
66327: GO 66356
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66329: LD_VAR 0 3
66333: PPUSH
66334: LD_VAR 0 7
66338: PUSH
66339: LD_INT 2
66341: ARRAY
66342: PPUSH
66343: LD_VAR 0 7
66347: PUSH
66348: LD_INT 3
66350: ARRAY
66351: PPUSH
66352: CALL_OW 117
// end ;
66356: GO 66134
66358: POP
66359: POP
// end ; end else
66360: GO 66892
// begin for j in cargo do
66362: LD_ADDR_VAR 0 3
66366: PUSH
66367: LD_VAR 0 8
66371: PUSH
66372: FOR_IN
66373: IFFALSE 66890
// begin if GetTag ( j ) <> 0 then
66375: LD_VAR 0 3
66379: PPUSH
66380: CALL_OW 110
66384: PUSH
66385: LD_INT 0
66387: NONEQUAL
66388: IFFALSE 66392
// continue ;
66390: GO 66372
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66392: LD_VAR 0 3
66396: PPUSH
66397: CALL_OW 256
66401: PUSH
66402: LD_INT 1000
66404: LESS
66405: PUSH
66406: LD_VAR 0 3
66410: PPUSH
66411: LD_EXP 67
66415: PUSH
66416: LD_VAR 0 2
66420: ARRAY
66421: PPUSH
66422: CALL_OW 308
66426: NOT
66427: AND
66428: IFFALSE 66450
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66430: LD_VAR 0 3
66434: PPUSH
66435: LD_EXP 67
66439: PUSH
66440: LD_VAR 0 2
66444: ARRAY
66445: PPUSH
66446: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
66450: LD_VAR 0 3
66454: PPUSH
66455: CALL_OW 256
66459: PUSH
66460: LD_INT 1000
66462: LESS
66463: PUSH
66464: LD_VAR 0 3
66468: PPUSH
66469: LD_EXP 67
66473: PUSH
66474: LD_VAR 0 2
66478: ARRAY
66479: PPUSH
66480: CALL_OW 308
66484: AND
66485: IFFALSE 66489
// continue ;
66487: GO 66372
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66489: LD_VAR 0 3
66493: PPUSH
66494: CALL_OW 262
66498: PUSH
66499: LD_INT 2
66501: EQUAL
66502: PUSH
66503: LD_VAR 0 3
66507: PPUSH
66508: CALL_OW 261
66512: PUSH
66513: LD_INT 15
66515: LESS
66516: AND
66517: IFFALSE 66521
// continue ;
66519: GO 66372
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66521: LD_VAR 0 3
66525: PPUSH
66526: CALL_OW 262
66530: PUSH
66531: LD_INT 1
66533: EQUAL
66534: PUSH
66535: LD_VAR 0 3
66539: PPUSH
66540: CALL_OW 261
66544: PUSH
66545: LD_INT 10
66547: LESS
66548: AND
66549: IFFALSE 66829
// begin if not depot then
66551: LD_VAR 0 9
66555: NOT
66556: IFFALSE 66560
// continue ;
66558: GO 66372
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66560: LD_VAR 0 3
66564: PPUSH
66565: LD_VAR 0 9
66569: PPUSH
66570: LD_VAR 0 3
66574: PPUSH
66575: CALL_OW 74
66579: PPUSH
66580: CALL_OW 296
66584: PUSH
66585: LD_INT 6
66587: LESS
66588: IFFALSE 66604
// SetFuel ( j , 100 ) else
66590: LD_VAR 0 3
66594: PPUSH
66595: LD_INT 100
66597: PPUSH
66598: CALL_OW 240
66602: GO 66829
// if GetFuel ( j ) = 0 then
66604: LD_VAR 0 3
66608: PPUSH
66609: CALL_OW 261
66613: PUSH
66614: LD_INT 0
66616: EQUAL
66617: IFFALSE 66829
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66619: LD_ADDR_EXP 62
66623: PUSH
66624: LD_EXP 62
66628: PPUSH
66629: LD_VAR 0 2
66633: PPUSH
66634: LD_EXP 62
66638: PUSH
66639: LD_VAR 0 2
66643: ARRAY
66644: PUSH
66645: LD_VAR 0 3
66649: DIFF
66650: PPUSH
66651: CALL_OW 1
66655: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66656: LD_VAR 0 3
66660: PPUSH
66661: CALL_OW 263
66665: PUSH
66666: LD_INT 1
66668: EQUAL
66669: IFFALSE 66685
// ComExitVehicle ( IsInUnit ( j ) ) ;
66671: LD_VAR 0 3
66675: PPUSH
66676: CALL_OW 310
66680: PPUSH
66681: CALL_OW 121
// if GetControl ( j ) = control_remote then
66685: LD_VAR 0 3
66689: PPUSH
66690: CALL_OW 263
66694: PUSH
66695: LD_INT 2
66697: EQUAL
66698: IFFALSE 66709
// ComUnlink ( j ) ;
66700: LD_VAR 0 3
66704: PPUSH
66705: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66709: LD_ADDR_VAR 0 10
66713: PUSH
66714: LD_VAR 0 2
66718: PPUSH
66719: LD_INT 3
66721: PPUSH
66722: CALL 76473 0 2
66726: ST_TO_ADDR
// if fac then
66727: LD_VAR 0 10
66731: IFFALSE 66827
// begin for k in fac do
66733: LD_ADDR_VAR 0 4
66737: PUSH
66738: LD_VAR 0 10
66742: PUSH
66743: FOR_IN
66744: IFFALSE 66825
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66746: LD_ADDR_VAR 0 11
66750: PUSH
66751: LD_VAR 0 10
66755: PPUSH
66756: LD_VAR 0 3
66760: PPUSH
66761: CALL_OW 265
66765: PPUSH
66766: LD_VAR 0 3
66770: PPUSH
66771: CALL_OW 262
66775: PPUSH
66776: LD_VAR 0 3
66780: PPUSH
66781: CALL_OW 263
66785: PPUSH
66786: LD_VAR 0 3
66790: PPUSH
66791: CALL_OW 264
66795: PPUSH
66796: CALL 12272 0 5
66800: ST_TO_ADDR
// if components then
66801: LD_VAR 0 11
66805: IFFALSE 66823
// begin MC_InsertProduceList ( i , components ) ;
66807: LD_VAR 0 2
66811: PPUSH
66812: LD_VAR 0 11
66816: PPUSH
66817: CALL 76018 0 2
// break ;
66821: GO 66825
// end ; end ;
66823: GO 66743
66825: POP
66826: POP
// end ; continue ;
66827: GO 66372
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66829: LD_VAR 0 3
66833: PPUSH
66834: LD_INT 1
66836: PPUSH
66837: CALL_OW 289
66841: PUSH
66842: LD_INT 100
66844: LESS
66845: PUSH
66846: LD_VAR 0 3
66850: PPUSH
66851: CALL_OW 314
66855: NOT
66856: AND
66857: IFFALSE 66886
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66859: LD_VAR 0 3
66863: PPUSH
66864: LD_VAR 0 7
66868: PUSH
66869: LD_INT 2
66871: ARRAY
66872: PPUSH
66873: LD_VAR 0 7
66877: PUSH
66878: LD_INT 3
66880: ARRAY
66881: PPUSH
66882: CALL_OW 117
// break ;
66886: GO 66890
// end ;
66888: GO 66372
66890: POP
66891: POP
// end ; end ;
66892: GO 65088
66894: POP
66895: POP
// end ;
66896: LD_VAR 0 1
66900: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66901: LD_INT 0
66903: PPUSH
66904: PPUSH
66905: PPUSH
66906: PPUSH
// if not mc_bases then
66907: LD_EXP 43
66911: NOT
66912: IFFALSE 66916
// exit ;
66914: GO 67077
// for i = 1 to mc_bases do
66916: LD_ADDR_VAR 0 2
66920: PUSH
66921: DOUBLE
66922: LD_INT 1
66924: DEC
66925: ST_TO_ADDR
66926: LD_EXP 43
66930: PUSH
66931: FOR_TO
66932: IFFALSE 67075
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66934: LD_ADDR_VAR 0 4
66938: PUSH
66939: LD_EXP 62
66943: PUSH
66944: LD_VAR 0 2
66948: ARRAY
66949: PUSH
66950: LD_EXP 65
66954: PUSH
66955: LD_VAR 0 2
66959: ARRAY
66960: UNION
66961: PPUSH
66962: LD_INT 33
66964: PUSH
66965: LD_INT 2
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PPUSH
66972: CALL_OW 72
66976: ST_TO_ADDR
// if tmp then
66977: LD_VAR 0 4
66981: IFFALSE 67073
// for j in tmp do
66983: LD_ADDR_VAR 0 3
66987: PUSH
66988: LD_VAR 0 4
66992: PUSH
66993: FOR_IN
66994: IFFALSE 67071
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66996: LD_VAR 0 3
67000: PPUSH
67001: CALL_OW 312
67005: NOT
67006: PUSH
67007: LD_VAR 0 3
67011: PPUSH
67012: CALL_OW 256
67016: PUSH
67017: LD_INT 250
67019: GREATEREQUAL
67020: AND
67021: IFFALSE 67034
// Connect ( j ) else
67023: LD_VAR 0 3
67027: PPUSH
67028: CALL 18120 0 1
67032: GO 67069
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67034: LD_VAR 0 3
67038: PPUSH
67039: CALL_OW 256
67043: PUSH
67044: LD_INT 250
67046: LESS
67047: PUSH
67048: LD_VAR 0 3
67052: PPUSH
67053: CALL_OW 312
67057: AND
67058: IFFALSE 67069
// ComUnlink ( j ) ;
67060: LD_VAR 0 3
67064: PPUSH
67065: CALL_OW 136
67069: GO 66993
67071: POP
67072: POP
// end ;
67073: GO 66931
67075: POP
67076: POP
// end ;
67077: LD_VAR 0 1
67081: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67082: LD_INT 0
67084: PPUSH
67085: PPUSH
67086: PPUSH
67087: PPUSH
67088: PPUSH
// if not mc_bases then
67089: LD_EXP 43
67093: NOT
67094: IFFALSE 67098
// exit ;
67096: GO 67543
// for i = 1 to mc_bases do
67098: LD_ADDR_VAR 0 2
67102: PUSH
67103: DOUBLE
67104: LD_INT 1
67106: DEC
67107: ST_TO_ADDR
67108: LD_EXP 43
67112: PUSH
67113: FOR_TO
67114: IFFALSE 67541
// begin if not mc_produce [ i ] then
67116: LD_EXP 64
67120: PUSH
67121: LD_VAR 0 2
67125: ARRAY
67126: NOT
67127: IFFALSE 67131
// continue ;
67129: GO 67113
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67131: LD_ADDR_VAR 0 5
67135: PUSH
67136: LD_EXP 43
67140: PUSH
67141: LD_VAR 0 2
67145: ARRAY
67146: PPUSH
67147: LD_INT 30
67149: PUSH
67150: LD_INT 3
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: PPUSH
67157: CALL_OW 72
67161: ST_TO_ADDR
// if not fac then
67162: LD_VAR 0 5
67166: NOT
67167: IFFALSE 67171
// continue ;
67169: GO 67113
// for j in fac do
67171: LD_ADDR_VAR 0 3
67175: PUSH
67176: LD_VAR 0 5
67180: PUSH
67181: FOR_IN
67182: IFFALSE 67537
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67184: LD_VAR 0 3
67188: PPUSH
67189: CALL_OW 461
67193: PUSH
67194: LD_INT 2
67196: NONEQUAL
67197: PUSH
67198: LD_VAR 0 3
67202: PPUSH
67203: LD_INT 15
67205: PPUSH
67206: CALL 17739 0 2
67210: PUSH
67211: LD_INT 4
67213: ARRAY
67214: OR
67215: IFFALSE 67219
// continue ;
67217: GO 67181
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67219: LD_VAR 0 3
67223: PPUSH
67224: LD_EXP 64
67228: PUSH
67229: LD_VAR 0 2
67233: ARRAY
67234: PUSH
67235: LD_INT 1
67237: ARRAY
67238: PUSH
67239: LD_INT 1
67241: ARRAY
67242: PPUSH
67243: LD_EXP 64
67247: PUSH
67248: LD_VAR 0 2
67252: ARRAY
67253: PUSH
67254: LD_INT 1
67256: ARRAY
67257: PUSH
67258: LD_INT 2
67260: ARRAY
67261: PPUSH
67262: LD_EXP 64
67266: PUSH
67267: LD_VAR 0 2
67271: ARRAY
67272: PUSH
67273: LD_INT 1
67275: ARRAY
67276: PUSH
67277: LD_INT 3
67279: ARRAY
67280: PPUSH
67281: LD_EXP 64
67285: PUSH
67286: LD_VAR 0 2
67290: ARRAY
67291: PUSH
67292: LD_INT 1
67294: ARRAY
67295: PUSH
67296: LD_INT 4
67298: ARRAY
67299: PPUSH
67300: CALL_OW 448
67304: PUSH
67305: LD_VAR 0 3
67309: PPUSH
67310: LD_EXP 64
67314: PUSH
67315: LD_VAR 0 2
67319: ARRAY
67320: PUSH
67321: LD_INT 1
67323: ARRAY
67324: PUSH
67325: LD_INT 1
67327: ARRAY
67328: PUSH
67329: LD_EXP 64
67333: PUSH
67334: LD_VAR 0 2
67338: ARRAY
67339: PUSH
67340: LD_INT 1
67342: ARRAY
67343: PUSH
67344: LD_INT 2
67346: ARRAY
67347: PUSH
67348: LD_EXP 64
67352: PUSH
67353: LD_VAR 0 2
67357: ARRAY
67358: PUSH
67359: LD_INT 1
67361: ARRAY
67362: PUSH
67363: LD_INT 3
67365: ARRAY
67366: PUSH
67367: LD_EXP 64
67371: PUSH
67372: LD_VAR 0 2
67376: ARRAY
67377: PUSH
67378: LD_INT 1
67380: ARRAY
67381: PUSH
67382: LD_INT 4
67384: ARRAY
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: LIST
67390: LIST
67391: PPUSH
67392: CALL 21515 0 2
67396: AND
67397: IFFALSE 67535
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
67399: LD_VAR 0 3
67403: PPUSH
67404: LD_EXP 64
67408: PUSH
67409: LD_VAR 0 2
67413: ARRAY
67414: PUSH
67415: LD_INT 1
67417: ARRAY
67418: PUSH
67419: LD_INT 1
67421: ARRAY
67422: PPUSH
67423: LD_EXP 64
67427: PUSH
67428: LD_VAR 0 2
67432: ARRAY
67433: PUSH
67434: LD_INT 1
67436: ARRAY
67437: PUSH
67438: LD_INT 2
67440: ARRAY
67441: PPUSH
67442: LD_EXP 64
67446: PUSH
67447: LD_VAR 0 2
67451: ARRAY
67452: PUSH
67453: LD_INT 1
67455: ARRAY
67456: PUSH
67457: LD_INT 3
67459: ARRAY
67460: PPUSH
67461: LD_EXP 64
67465: PUSH
67466: LD_VAR 0 2
67470: ARRAY
67471: PUSH
67472: LD_INT 1
67474: ARRAY
67475: PUSH
67476: LD_INT 4
67478: ARRAY
67479: PPUSH
67480: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
67484: LD_ADDR_VAR 0 4
67488: PUSH
67489: LD_EXP 64
67493: PUSH
67494: LD_VAR 0 2
67498: ARRAY
67499: PPUSH
67500: LD_INT 1
67502: PPUSH
67503: CALL_OW 3
67507: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67508: LD_ADDR_EXP 64
67512: PUSH
67513: LD_EXP 64
67517: PPUSH
67518: LD_VAR 0 2
67522: PPUSH
67523: LD_VAR 0 4
67527: PPUSH
67528: CALL_OW 1
67532: ST_TO_ADDR
// break ;
67533: GO 67537
// end ; end ;
67535: GO 67181
67537: POP
67538: POP
// end ;
67539: GO 67113
67541: POP
67542: POP
// end ;
67543: LD_VAR 0 1
67547: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67548: LD_INT 0
67550: PPUSH
67551: PPUSH
67552: PPUSH
// if not mc_bases then
67553: LD_EXP 43
67557: NOT
67558: IFFALSE 67562
// exit ;
67560: GO 67651
// for i = 1 to mc_bases do
67562: LD_ADDR_VAR 0 2
67566: PUSH
67567: DOUBLE
67568: LD_INT 1
67570: DEC
67571: ST_TO_ADDR
67572: LD_EXP 43
67576: PUSH
67577: FOR_TO
67578: IFFALSE 67649
// begin if mc_attack [ i ] then
67580: LD_EXP 63
67584: PUSH
67585: LD_VAR 0 2
67589: ARRAY
67590: IFFALSE 67647
// begin tmp := mc_attack [ i ] [ 1 ] ;
67592: LD_ADDR_VAR 0 3
67596: PUSH
67597: LD_EXP 63
67601: PUSH
67602: LD_VAR 0 2
67606: ARRAY
67607: PUSH
67608: LD_INT 1
67610: ARRAY
67611: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67612: LD_ADDR_EXP 63
67616: PUSH
67617: LD_EXP 63
67621: PPUSH
67622: LD_VAR 0 2
67626: PPUSH
67627: EMPTY
67628: PPUSH
67629: CALL_OW 1
67633: ST_TO_ADDR
// Attack ( tmp ) ;
67634: LD_VAR 0 3
67638: PPUSH
67639: CALL 82444 0 1
// exit ;
67643: POP
67644: POP
67645: GO 67651
// end ; end ;
67647: GO 67577
67649: POP
67650: POP
// end ;
67651: LD_VAR 0 1
67655: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67656: LD_INT 0
67658: PPUSH
67659: PPUSH
67660: PPUSH
67661: PPUSH
67662: PPUSH
67663: PPUSH
67664: PPUSH
// if not mc_bases then
67665: LD_EXP 43
67669: NOT
67670: IFFALSE 67674
// exit ;
67672: GO 68531
// for i = 1 to mc_bases do
67674: LD_ADDR_VAR 0 2
67678: PUSH
67679: DOUBLE
67680: LD_INT 1
67682: DEC
67683: ST_TO_ADDR
67684: LD_EXP 43
67688: PUSH
67689: FOR_TO
67690: IFFALSE 68529
// begin if not mc_bases [ i ] then
67692: LD_EXP 43
67696: PUSH
67697: LD_VAR 0 2
67701: ARRAY
67702: NOT
67703: IFFALSE 67707
// continue ;
67705: GO 67689
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67707: LD_ADDR_VAR 0 7
67711: PUSH
67712: LD_EXP 43
67716: PUSH
67717: LD_VAR 0 2
67721: ARRAY
67722: PUSH
67723: LD_INT 1
67725: ARRAY
67726: PPUSH
67727: CALL 11598 0 1
67731: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67732: LD_ADDR_EXP 66
67736: PUSH
67737: LD_EXP 66
67741: PPUSH
67742: LD_VAR 0 2
67746: PPUSH
67747: LD_EXP 43
67751: PUSH
67752: LD_VAR 0 2
67756: ARRAY
67757: PUSH
67758: LD_INT 1
67760: ARRAY
67761: PPUSH
67762: CALL_OW 255
67766: PPUSH
67767: LD_EXP 68
67771: PUSH
67772: LD_VAR 0 2
67776: ARRAY
67777: PPUSH
67778: CALL 11563 0 2
67782: PPUSH
67783: CALL_OW 1
67787: ST_TO_ADDR
// if not mc_scan [ i ] then
67788: LD_EXP 66
67792: PUSH
67793: LD_VAR 0 2
67797: ARRAY
67798: NOT
67799: IFFALSE 67977
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67801: LD_ADDR_EXP 86
67805: PUSH
67806: LD_EXP 86
67810: PPUSH
67811: LD_VAR 0 2
67815: PPUSH
67816: LD_INT 0
67818: PPUSH
67819: CALL_OW 1
67823: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67824: LD_ADDR_VAR 0 4
67828: PUSH
67829: LD_EXP 43
67833: PUSH
67834: LD_VAR 0 2
67838: ARRAY
67839: PPUSH
67840: LD_INT 2
67842: PUSH
67843: LD_INT 25
67845: PUSH
67846: LD_INT 5
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 25
67855: PUSH
67856: LD_INT 8
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 25
67865: PUSH
67866: LD_INT 9
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: PPUSH
67879: CALL_OW 72
67883: ST_TO_ADDR
// if not tmp then
67884: LD_VAR 0 4
67888: NOT
67889: IFFALSE 67893
// continue ;
67891: GO 67689
// for j in tmp do
67893: LD_ADDR_VAR 0 3
67897: PUSH
67898: LD_VAR 0 4
67902: PUSH
67903: FOR_IN
67904: IFFALSE 67975
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67906: LD_VAR 0 3
67910: PPUSH
67911: CALL_OW 310
67915: PPUSH
67916: CALL_OW 266
67920: PUSH
67921: LD_INT 5
67923: EQUAL
67924: PUSH
67925: LD_VAR 0 3
67929: PPUSH
67930: CALL_OW 257
67934: PUSH
67935: LD_INT 1
67937: EQUAL
67938: AND
67939: PUSH
67940: LD_VAR 0 3
67944: PPUSH
67945: CALL_OW 459
67949: NOT
67950: AND
67951: PUSH
67952: LD_VAR 0 7
67956: AND
67957: IFFALSE 67973
// ComChangeProfession ( j , class ) ;
67959: LD_VAR 0 3
67963: PPUSH
67964: LD_VAR 0 7
67968: PPUSH
67969: CALL_OW 123
67973: GO 67903
67975: POP
67976: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67977: LD_EXP 66
67981: PUSH
67982: LD_VAR 0 2
67986: ARRAY
67987: PUSH
67988: LD_EXP 86
67992: PUSH
67993: LD_VAR 0 2
67997: ARRAY
67998: NOT
67999: AND
68000: PUSH
68001: LD_EXP 65
68005: PUSH
68006: LD_VAR 0 2
68010: ARRAY
68011: NOT
68012: AND
68013: PUSH
68014: LD_EXP 43
68018: PUSH
68019: LD_VAR 0 2
68023: ARRAY
68024: PPUSH
68025: LD_INT 50
68027: PUSH
68028: EMPTY
68029: LIST
68030: PUSH
68031: LD_INT 2
68033: PUSH
68034: LD_INT 30
68036: PUSH
68037: LD_INT 32
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 30
68046: PUSH
68047: LD_INT 33
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 30
68056: PUSH
68057: LD_INT 4
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 30
68066: PUSH
68067: LD_INT 5
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PPUSH
68085: CALL_OW 72
68089: PUSH
68090: LD_INT 4
68092: LESS
68093: PUSH
68094: LD_EXP 43
68098: PUSH
68099: LD_VAR 0 2
68103: ARRAY
68104: PPUSH
68105: LD_INT 3
68107: PUSH
68108: LD_INT 24
68110: PUSH
68111: LD_INT 1000
68113: PUSH
68114: EMPTY
68115: LIST
68116: LIST
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 2
68124: PUSH
68125: LD_INT 30
68127: PUSH
68128: LD_INT 0
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PUSH
68135: LD_INT 30
68137: PUSH
68138: LD_INT 1
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: LIST
68149: PUSH
68150: EMPTY
68151: LIST
68152: LIST
68153: PPUSH
68154: CALL_OW 72
68158: OR
68159: AND
68160: IFFALSE 68411
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68162: LD_ADDR_EXP 86
68166: PUSH
68167: LD_EXP 86
68171: PPUSH
68172: LD_VAR 0 2
68176: PPUSH
68177: LD_INT 1
68179: PPUSH
68180: CALL_OW 1
68184: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68185: LD_ADDR_VAR 0 4
68189: PUSH
68190: LD_EXP 43
68194: PUSH
68195: LD_VAR 0 2
68199: ARRAY
68200: PPUSH
68201: LD_INT 2
68203: PUSH
68204: LD_INT 25
68206: PUSH
68207: LD_INT 1
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 25
68216: PUSH
68217: LD_INT 5
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 25
68226: PUSH
68227: LD_INT 8
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 25
68236: PUSH
68237: LD_INT 9
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: EMPTY
68245: LIST
68246: LIST
68247: LIST
68248: LIST
68249: LIST
68250: PPUSH
68251: CALL_OW 72
68255: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68256: LD_ADDR_VAR 0 4
68260: PUSH
68261: LD_VAR 0 4
68265: PUSH
68266: LD_VAR 0 4
68270: PPUSH
68271: LD_INT 18
68273: PPUSH
68274: CALL 45083 0 2
68278: DIFF
68279: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68280: LD_VAR 0 4
68284: NOT
68285: PUSH
68286: LD_EXP 43
68290: PUSH
68291: LD_VAR 0 2
68295: ARRAY
68296: PPUSH
68297: LD_INT 2
68299: PUSH
68300: LD_INT 30
68302: PUSH
68303: LD_INT 4
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: LD_INT 30
68312: PUSH
68313: LD_INT 5
68315: PUSH
68316: EMPTY
68317: LIST
68318: LIST
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: LIST
68324: PPUSH
68325: CALL_OW 72
68329: NOT
68330: AND
68331: IFFALSE 68393
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
68333: LD_ADDR_VAR 0 4
68337: PUSH
68338: LD_EXP 43
68342: PUSH
68343: LD_VAR 0 2
68347: ARRAY
68348: PPUSH
68349: LD_INT 2
68351: PUSH
68352: LD_INT 25
68354: PUSH
68355: LD_INT 2
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PUSH
68362: LD_INT 25
68364: PUSH
68365: LD_INT 3
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PUSH
68372: LD_INT 25
68374: PUSH
68375: LD_INT 4
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: PPUSH
68388: CALL_OW 72
68392: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
68393: LD_VAR 0 2
68397: PPUSH
68398: LD_VAR 0 4
68402: PPUSH
68403: CALL 87153 0 2
// exit ;
68407: POP
68408: POP
68409: GO 68531
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
68411: LD_EXP 66
68415: PUSH
68416: LD_VAR 0 2
68420: ARRAY
68421: PUSH
68422: LD_EXP 86
68426: PUSH
68427: LD_VAR 0 2
68431: ARRAY
68432: NOT
68433: AND
68434: PUSH
68435: LD_EXP 65
68439: PUSH
68440: LD_VAR 0 2
68444: ARRAY
68445: AND
68446: IFFALSE 68527
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68448: LD_ADDR_EXP 86
68452: PUSH
68453: LD_EXP 86
68457: PPUSH
68458: LD_VAR 0 2
68462: PPUSH
68463: LD_INT 1
68465: PPUSH
68466: CALL_OW 1
68470: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
68471: LD_ADDR_VAR 0 4
68475: PUSH
68476: LD_EXP 65
68480: PUSH
68481: LD_VAR 0 2
68485: ARRAY
68486: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68487: LD_ADDR_EXP 65
68491: PUSH
68492: LD_EXP 65
68496: PPUSH
68497: LD_VAR 0 2
68501: PPUSH
68502: EMPTY
68503: PPUSH
68504: CALL_OW 1
68508: ST_TO_ADDR
// Defend ( i , tmp ) ;
68509: LD_VAR 0 2
68513: PPUSH
68514: LD_VAR 0 4
68518: PPUSH
68519: CALL 87749 0 2
// exit ;
68523: POP
68524: POP
68525: GO 68531
// end ; end ;
68527: GO 67689
68529: POP
68530: POP
// end ;
68531: LD_VAR 0 1
68535: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68536: LD_INT 0
68538: PPUSH
68539: PPUSH
68540: PPUSH
68541: PPUSH
68542: PPUSH
68543: PPUSH
68544: PPUSH
68545: PPUSH
68546: PPUSH
68547: PPUSH
68548: PPUSH
// if not mc_bases then
68549: LD_EXP 43
68553: NOT
68554: IFFALSE 68558
// exit ;
68556: GO 69645
// for i = 1 to mc_bases do
68558: LD_ADDR_VAR 0 2
68562: PUSH
68563: DOUBLE
68564: LD_INT 1
68566: DEC
68567: ST_TO_ADDR
68568: LD_EXP 43
68572: PUSH
68573: FOR_TO
68574: IFFALSE 69643
// begin tmp := mc_lab [ i ] ;
68576: LD_ADDR_VAR 0 6
68580: PUSH
68581: LD_EXP 76
68585: PUSH
68586: LD_VAR 0 2
68590: ARRAY
68591: ST_TO_ADDR
// if not tmp then
68592: LD_VAR 0 6
68596: NOT
68597: IFFALSE 68601
// continue ;
68599: GO 68573
// idle_lab := 0 ;
68601: LD_ADDR_VAR 0 11
68605: PUSH
68606: LD_INT 0
68608: ST_TO_ADDR
// for j in tmp do
68609: LD_ADDR_VAR 0 3
68613: PUSH
68614: LD_VAR 0 6
68618: PUSH
68619: FOR_IN
68620: IFFALSE 69639
// begin researching := false ;
68622: LD_ADDR_VAR 0 10
68626: PUSH
68627: LD_INT 0
68629: ST_TO_ADDR
// side := GetSide ( j ) ;
68630: LD_ADDR_VAR 0 4
68634: PUSH
68635: LD_VAR 0 3
68639: PPUSH
68640: CALL_OW 255
68644: ST_TO_ADDR
// if not mc_tech [ side ] then
68645: LD_EXP 70
68649: PUSH
68650: LD_VAR 0 4
68654: ARRAY
68655: NOT
68656: IFFALSE 68660
// continue ;
68658: GO 68619
// if BuildingStatus ( j ) = bs_idle then
68660: LD_VAR 0 3
68664: PPUSH
68665: CALL_OW 461
68669: PUSH
68670: LD_INT 2
68672: EQUAL
68673: IFFALSE 68861
// begin if idle_lab and UnitsInside ( j ) < 6 then
68675: LD_VAR 0 11
68679: PUSH
68680: LD_VAR 0 3
68684: PPUSH
68685: CALL_OW 313
68689: PUSH
68690: LD_INT 6
68692: LESS
68693: AND
68694: IFFALSE 68765
// begin tmp2 := UnitsInside ( idle_lab ) ;
68696: LD_ADDR_VAR 0 9
68700: PUSH
68701: LD_VAR 0 11
68705: PPUSH
68706: CALL_OW 313
68710: ST_TO_ADDR
// if tmp2 then
68711: LD_VAR 0 9
68715: IFFALSE 68757
// for x in tmp2 do
68717: LD_ADDR_VAR 0 7
68721: PUSH
68722: LD_VAR 0 9
68726: PUSH
68727: FOR_IN
68728: IFFALSE 68755
// begin ComExitBuilding ( x ) ;
68730: LD_VAR 0 7
68734: PPUSH
68735: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68739: LD_VAR 0 7
68743: PPUSH
68744: LD_VAR 0 3
68748: PPUSH
68749: CALL_OW 180
// end ;
68753: GO 68727
68755: POP
68756: POP
// idle_lab := 0 ;
68757: LD_ADDR_VAR 0 11
68761: PUSH
68762: LD_INT 0
68764: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68765: LD_ADDR_VAR 0 5
68769: PUSH
68770: LD_EXP 70
68774: PUSH
68775: LD_VAR 0 4
68779: ARRAY
68780: PUSH
68781: FOR_IN
68782: IFFALSE 68842
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68784: LD_VAR 0 3
68788: PPUSH
68789: LD_VAR 0 5
68793: PPUSH
68794: CALL_OW 430
68798: PUSH
68799: LD_VAR 0 4
68803: PPUSH
68804: LD_VAR 0 5
68808: PPUSH
68809: CALL 10668 0 2
68813: AND
68814: IFFALSE 68840
// begin researching := true ;
68816: LD_ADDR_VAR 0 10
68820: PUSH
68821: LD_INT 1
68823: ST_TO_ADDR
// ComResearch ( j , t ) ;
68824: LD_VAR 0 3
68828: PPUSH
68829: LD_VAR 0 5
68833: PPUSH
68834: CALL_OW 124
// break ;
68838: GO 68842
// end ;
68840: GO 68781
68842: POP
68843: POP
// if not researching then
68844: LD_VAR 0 10
68848: NOT
68849: IFFALSE 68861
// idle_lab := j ;
68851: LD_ADDR_VAR 0 11
68855: PUSH
68856: LD_VAR 0 3
68860: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68861: LD_VAR 0 3
68865: PPUSH
68866: CALL_OW 461
68870: PUSH
68871: LD_INT 10
68873: EQUAL
68874: IFFALSE 69462
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68876: LD_EXP 72
68880: PUSH
68881: LD_VAR 0 2
68885: ARRAY
68886: NOT
68887: PUSH
68888: LD_EXP 73
68892: PUSH
68893: LD_VAR 0 2
68897: ARRAY
68898: NOT
68899: AND
68900: PUSH
68901: LD_EXP 70
68905: PUSH
68906: LD_VAR 0 4
68910: ARRAY
68911: PUSH
68912: LD_INT 1
68914: GREATER
68915: AND
68916: IFFALSE 69047
// begin ComCancel ( j ) ;
68918: LD_VAR 0 3
68922: PPUSH
68923: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68927: LD_ADDR_EXP 70
68931: PUSH
68932: LD_EXP 70
68936: PPUSH
68937: LD_VAR 0 4
68941: PPUSH
68942: LD_EXP 70
68946: PUSH
68947: LD_VAR 0 4
68951: ARRAY
68952: PPUSH
68953: LD_EXP 70
68957: PUSH
68958: LD_VAR 0 4
68962: ARRAY
68963: PUSH
68964: LD_INT 1
68966: MINUS
68967: PPUSH
68968: LD_EXP 70
68972: PUSH
68973: LD_VAR 0 4
68977: ARRAY
68978: PPUSH
68979: LD_INT 0
68981: PPUSH
68982: CALL 14192 0 4
68986: PPUSH
68987: CALL_OW 1
68991: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68992: LD_ADDR_EXP 70
68996: PUSH
68997: LD_EXP 70
69001: PPUSH
69002: LD_VAR 0 4
69006: PPUSH
69007: LD_EXP 70
69011: PUSH
69012: LD_VAR 0 4
69016: ARRAY
69017: PPUSH
69018: LD_EXP 70
69022: PUSH
69023: LD_VAR 0 4
69027: ARRAY
69028: PPUSH
69029: LD_INT 1
69031: PPUSH
69032: LD_INT 0
69034: PPUSH
69035: CALL 14192 0 4
69039: PPUSH
69040: CALL_OW 1
69044: ST_TO_ADDR
// continue ;
69045: GO 68619
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69047: LD_EXP 72
69051: PUSH
69052: LD_VAR 0 2
69056: ARRAY
69057: PUSH
69058: LD_EXP 73
69062: PUSH
69063: LD_VAR 0 2
69067: ARRAY
69068: NOT
69069: AND
69070: IFFALSE 69197
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69072: LD_ADDR_EXP 73
69076: PUSH
69077: LD_EXP 73
69081: PPUSH
69082: LD_VAR 0 2
69086: PUSH
69087: LD_EXP 73
69091: PUSH
69092: LD_VAR 0 2
69096: ARRAY
69097: PUSH
69098: LD_INT 1
69100: PLUS
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PPUSH
69106: LD_EXP 72
69110: PUSH
69111: LD_VAR 0 2
69115: ARRAY
69116: PUSH
69117: LD_INT 1
69119: ARRAY
69120: PPUSH
69121: CALL 14774 0 3
69125: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69126: LD_EXP 72
69130: PUSH
69131: LD_VAR 0 2
69135: ARRAY
69136: PUSH
69137: LD_INT 1
69139: ARRAY
69140: PPUSH
69141: LD_INT 112
69143: PPUSH
69144: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69148: LD_ADDR_VAR 0 9
69152: PUSH
69153: LD_EXP 72
69157: PUSH
69158: LD_VAR 0 2
69162: ARRAY
69163: PPUSH
69164: LD_INT 1
69166: PPUSH
69167: CALL_OW 3
69171: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69172: LD_ADDR_EXP 72
69176: PUSH
69177: LD_EXP 72
69181: PPUSH
69182: LD_VAR 0 2
69186: PPUSH
69187: LD_VAR 0 9
69191: PPUSH
69192: CALL_OW 1
69196: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69197: LD_EXP 72
69201: PUSH
69202: LD_VAR 0 2
69206: ARRAY
69207: PUSH
69208: LD_EXP 73
69212: PUSH
69213: LD_VAR 0 2
69217: ARRAY
69218: AND
69219: PUSH
69220: LD_EXP 73
69224: PUSH
69225: LD_VAR 0 2
69229: ARRAY
69230: PUSH
69231: LD_INT 1
69233: ARRAY
69234: PPUSH
69235: CALL_OW 310
69239: NOT
69240: AND
69241: PUSH
69242: LD_VAR 0 3
69246: PPUSH
69247: CALL_OW 313
69251: PUSH
69252: LD_INT 6
69254: EQUAL
69255: AND
69256: IFFALSE 69312
// begin tmp2 := UnitsInside ( j ) ;
69258: LD_ADDR_VAR 0 9
69262: PUSH
69263: LD_VAR 0 3
69267: PPUSH
69268: CALL_OW 313
69272: ST_TO_ADDR
// if tmp2 = 6 then
69273: LD_VAR 0 9
69277: PUSH
69278: LD_INT 6
69280: EQUAL
69281: IFFALSE 69312
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69283: LD_VAR 0 9
69287: PUSH
69288: LD_INT 1
69290: ARRAY
69291: PPUSH
69292: LD_INT 112
69294: PPUSH
69295: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69299: LD_VAR 0 9
69303: PUSH
69304: LD_INT 1
69306: ARRAY
69307: PPUSH
69308: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69312: LD_EXP 73
69316: PUSH
69317: LD_VAR 0 2
69321: ARRAY
69322: PUSH
69323: LD_EXP 73
69327: PUSH
69328: LD_VAR 0 2
69332: ARRAY
69333: PUSH
69334: LD_INT 1
69336: ARRAY
69337: PPUSH
69338: CALL_OW 314
69342: NOT
69343: AND
69344: PUSH
69345: LD_EXP 73
69349: PUSH
69350: LD_VAR 0 2
69354: ARRAY
69355: PUSH
69356: LD_INT 1
69358: ARRAY
69359: PPUSH
69360: CALL_OW 310
69364: NOT
69365: AND
69366: IFFALSE 69392
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69368: LD_EXP 73
69372: PUSH
69373: LD_VAR 0 2
69377: ARRAY
69378: PUSH
69379: LD_INT 1
69381: ARRAY
69382: PPUSH
69383: LD_VAR 0 3
69387: PPUSH
69388: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69392: LD_EXP 73
69396: PUSH
69397: LD_VAR 0 2
69401: ARRAY
69402: PUSH
69403: LD_INT 1
69405: ARRAY
69406: PPUSH
69407: CALL_OW 310
69411: PUSH
69412: LD_EXP 73
69416: PUSH
69417: LD_VAR 0 2
69421: ARRAY
69422: PUSH
69423: LD_INT 1
69425: ARRAY
69426: PPUSH
69427: CALL_OW 310
69431: PPUSH
69432: CALL_OW 461
69436: PUSH
69437: LD_INT 3
69439: NONEQUAL
69440: AND
69441: IFFALSE 69462
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
69443: LD_EXP 73
69447: PUSH
69448: LD_VAR 0 2
69452: ARRAY
69453: PUSH
69454: LD_INT 1
69456: ARRAY
69457: PPUSH
69458: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
69462: LD_VAR 0 3
69466: PPUSH
69467: CALL_OW 461
69471: PUSH
69472: LD_INT 6
69474: EQUAL
69475: PUSH
69476: LD_VAR 0 6
69480: PUSH
69481: LD_INT 1
69483: GREATER
69484: AND
69485: IFFALSE 69637
// begin sci := [ ] ;
69487: LD_ADDR_VAR 0 8
69491: PUSH
69492: EMPTY
69493: ST_TO_ADDR
// for x in ( tmp diff j ) do
69494: LD_ADDR_VAR 0 7
69498: PUSH
69499: LD_VAR 0 6
69503: PUSH
69504: LD_VAR 0 3
69508: DIFF
69509: PUSH
69510: FOR_IN
69511: IFFALSE 69563
// begin if sci = 6 then
69513: LD_VAR 0 8
69517: PUSH
69518: LD_INT 6
69520: EQUAL
69521: IFFALSE 69525
// break ;
69523: GO 69563
// if BuildingStatus ( x ) = bs_idle then
69525: LD_VAR 0 7
69529: PPUSH
69530: CALL_OW 461
69534: PUSH
69535: LD_INT 2
69537: EQUAL
69538: IFFALSE 69561
// sci := sci ^ UnitsInside ( x ) ;
69540: LD_ADDR_VAR 0 8
69544: PUSH
69545: LD_VAR 0 8
69549: PUSH
69550: LD_VAR 0 7
69554: PPUSH
69555: CALL_OW 313
69559: ADD
69560: ST_TO_ADDR
// end ;
69561: GO 69510
69563: POP
69564: POP
// if not sci then
69565: LD_VAR 0 8
69569: NOT
69570: IFFALSE 69574
// continue ;
69572: GO 68619
// for x in sci do
69574: LD_ADDR_VAR 0 7
69578: PUSH
69579: LD_VAR 0 8
69583: PUSH
69584: FOR_IN
69585: IFFALSE 69635
// if IsInUnit ( x ) and not HasTask ( x ) then
69587: LD_VAR 0 7
69591: PPUSH
69592: CALL_OW 310
69596: PUSH
69597: LD_VAR 0 7
69601: PPUSH
69602: CALL_OW 314
69606: NOT
69607: AND
69608: IFFALSE 69633
// begin ComExitBuilding ( x ) ;
69610: LD_VAR 0 7
69614: PPUSH
69615: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69619: LD_VAR 0 7
69623: PPUSH
69624: LD_VAR 0 3
69628: PPUSH
69629: CALL_OW 180
// end ;
69633: GO 69584
69635: POP
69636: POP
// end ; end ;
69637: GO 68619
69639: POP
69640: POP
// end ;
69641: GO 68573
69643: POP
69644: POP
// end ;
69645: LD_VAR 0 1
69649: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69650: LD_INT 0
69652: PPUSH
69653: PPUSH
// if not mc_bases then
69654: LD_EXP 43
69658: NOT
69659: IFFALSE 69663
// exit ;
69661: GO 69744
// for i = 1 to mc_bases do
69663: LD_ADDR_VAR 0 2
69667: PUSH
69668: DOUBLE
69669: LD_INT 1
69671: DEC
69672: ST_TO_ADDR
69673: LD_EXP 43
69677: PUSH
69678: FOR_TO
69679: IFFALSE 69742
// if mc_mines [ i ] and mc_miners [ i ] then
69681: LD_EXP 56
69685: PUSH
69686: LD_VAR 0 2
69690: ARRAY
69691: PUSH
69692: LD_EXP 57
69696: PUSH
69697: LD_VAR 0 2
69701: ARRAY
69702: AND
69703: IFFALSE 69740
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69705: LD_EXP 57
69709: PUSH
69710: LD_VAR 0 2
69714: ARRAY
69715: PUSH
69716: LD_INT 1
69718: ARRAY
69719: PPUSH
69720: CALL_OW 255
69724: PPUSH
69725: LD_EXP 56
69729: PUSH
69730: LD_VAR 0 2
69734: ARRAY
69735: PPUSH
69736: CALL 11751 0 2
69740: GO 69678
69742: POP
69743: POP
// end ;
69744: LD_VAR 0 1
69748: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69749: LD_INT 0
69751: PPUSH
69752: PPUSH
69753: PPUSH
69754: PPUSH
69755: PPUSH
69756: PPUSH
69757: PPUSH
69758: PPUSH
// if not mc_bases or not mc_parking then
69759: LD_EXP 43
69763: NOT
69764: PUSH
69765: LD_EXP 67
69769: NOT
69770: OR
69771: IFFALSE 69775
// exit ;
69773: GO 70513
// for i = 1 to mc_bases do
69775: LD_ADDR_VAR 0 2
69779: PUSH
69780: DOUBLE
69781: LD_INT 1
69783: DEC
69784: ST_TO_ADDR
69785: LD_EXP 43
69789: PUSH
69790: FOR_TO
69791: IFFALSE 70511
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69793: LD_EXP 43
69797: PUSH
69798: LD_VAR 0 2
69802: ARRAY
69803: NOT
69804: PUSH
69805: LD_EXP 67
69809: PUSH
69810: LD_VAR 0 2
69814: ARRAY
69815: NOT
69816: OR
69817: IFFALSE 69821
// continue ;
69819: GO 69790
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69821: LD_ADDR_VAR 0 5
69825: PUSH
69826: LD_EXP 43
69830: PUSH
69831: LD_VAR 0 2
69835: ARRAY
69836: PUSH
69837: LD_INT 1
69839: ARRAY
69840: PPUSH
69841: CALL_OW 255
69845: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69846: LD_ADDR_VAR 0 6
69850: PUSH
69851: LD_EXP 43
69855: PUSH
69856: LD_VAR 0 2
69860: ARRAY
69861: PPUSH
69862: LD_INT 30
69864: PUSH
69865: LD_INT 3
69867: PUSH
69868: EMPTY
69869: LIST
69870: LIST
69871: PPUSH
69872: CALL_OW 72
69876: ST_TO_ADDR
// if not fac then
69877: LD_VAR 0 6
69881: NOT
69882: IFFALSE 69933
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69884: LD_ADDR_VAR 0 6
69888: PUSH
69889: LD_EXP 43
69893: PUSH
69894: LD_VAR 0 2
69898: ARRAY
69899: PPUSH
69900: LD_INT 2
69902: PUSH
69903: LD_INT 30
69905: PUSH
69906: LD_INT 0
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 30
69915: PUSH
69916: LD_INT 1
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: LIST
69927: PPUSH
69928: CALL_OW 72
69932: ST_TO_ADDR
// if not fac then
69933: LD_VAR 0 6
69937: NOT
69938: IFFALSE 69942
// continue ;
69940: GO 69790
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69942: LD_ADDR_VAR 0 7
69946: PUSH
69947: LD_EXP 67
69951: PUSH
69952: LD_VAR 0 2
69956: ARRAY
69957: PPUSH
69958: LD_INT 22
69960: PUSH
69961: LD_VAR 0 5
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: LD_INT 21
69972: PUSH
69973: LD_INT 2
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: PUSH
69980: LD_INT 3
69982: PUSH
69983: LD_INT 60
69985: PUSH
69986: EMPTY
69987: LIST
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 3
69995: PUSH
69996: LD_INT 24
69998: PUSH
69999: LD_INT 1000
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: PPUSH
70016: CALL_OW 70
70020: ST_TO_ADDR
// for j in fac do
70021: LD_ADDR_VAR 0 3
70025: PUSH
70026: LD_VAR 0 6
70030: PUSH
70031: FOR_IN
70032: IFFALSE 70127
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70034: LD_ADDR_VAR 0 7
70038: PUSH
70039: LD_VAR 0 7
70043: PUSH
70044: LD_INT 22
70046: PUSH
70047: LD_VAR 0 5
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 91
70058: PUSH
70059: LD_VAR 0 3
70063: PUSH
70064: LD_INT 15
70066: PUSH
70067: EMPTY
70068: LIST
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 21
70074: PUSH
70075: LD_INT 2
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 3
70084: PUSH
70085: LD_INT 60
70087: PUSH
70088: EMPTY
70089: LIST
70090: PUSH
70091: EMPTY
70092: LIST
70093: LIST
70094: PUSH
70095: LD_INT 3
70097: PUSH
70098: LD_INT 24
70100: PUSH
70101: LD_INT 1000
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: PUSH
70112: EMPTY
70113: LIST
70114: LIST
70115: LIST
70116: LIST
70117: LIST
70118: PPUSH
70119: CALL_OW 69
70123: UNION
70124: ST_TO_ADDR
70125: GO 70031
70127: POP
70128: POP
// if not vehs then
70129: LD_VAR 0 7
70133: NOT
70134: IFFALSE 70160
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70136: LD_ADDR_EXP 55
70140: PUSH
70141: LD_EXP 55
70145: PPUSH
70146: LD_VAR 0 2
70150: PPUSH
70151: EMPTY
70152: PPUSH
70153: CALL_OW 1
70157: ST_TO_ADDR
// continue ;
70158: GO 69790
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70160: LD_ADDR_VAR 0 8
70164: PUSH
70165: LD_EXP 43
70169: PUSH
70170: LD_VAR 0 2
70174: ARRAY
70175: PPUSH
70176: LD_INT 30
70178: PUSH
70179: LD_INT 3
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PPUSH
70186: CALL_OW 72
70190: ST_TO_ADDR
// if tmp then
70191: LD_VAR 0 8
70195: IFFALSE 70298
// begin for j in tmp do
70197: LD_ADDR_VAR 0 3
70201: PUSH
70202: LD_VAR 0 8
70206: PUSH
70207: FOR_IN
70208: IFFALSE 70296
// for k in UnitsInside ( j ) do
70210: LD_ADDR_VAR 0 4
70214: PUSH
70215: LD_VAR 0 3
70219: PPUSH
70220: CALL_OW 313
70224: PUSH
70225: FOR_IN
70226: IFFALSE 70292
// if k then
70228: LD_VAR 0 4
70232: IFFALSE 70290
// if not k in mc_repair_vehicle [ i ] then
70234: LD_VAR 0 4
70238: PUSH
70239: LD_EXP 55
70243: PUSH
70244: LD_VAR 0 2
70248: ARRAY
70249: IN
70250: NOT
70251: IFFALSE 70290
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70253: LD_ADDR_EXP 55
70257: PUSH
70258: LD_EXP 55
70262: PPUSH
70263: LD_VAR 0 2
70267: PPUSH
70268: LD_EXP 55
70272: PUSH
70273: LD_VAR 0 2
70277: ARRAY
70278: PUSH
70279: LD_VAR 0 4
70283: UNION
70284: PPUSH
70285: CALL_OW 1
70289: ST_TO_ADDR
70290: GO 70225
70292: POP
70293: POP
70294: GO 70207
70296: POP
70297: POP
// end ; if not mc_repair_vehicle [ i ] then
70298: LD_EXP 55
70302: PUSH
70303: LD_VAR 0 2
70307: ARRAY
70308: NOT
70309: IFFALSE 70313
// continue ;
70311: GO 69790
// for j in mc_repair_vehicle [ i ] do
70313: LD_ADDR_VAR 0 3
70317: PUSH
70318: LD_EXP 55
70322: PUSH
70323: LD_VAR 0 2
70327: ARRAY
70328: PUSH
70329: FOR_IN
70330: IFFALSE 70507
// begin if GetClass ( j ) <> 3 then
70332: LD_VAR 0 3
70336: PPUSH
70337: CALL_OW 257
70341: PUSH
70342: LD_INT 3
70344: NONEQUAL
70345: IFFALSE 70386
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70347: LD_ADDR_EXP 55
70351: PUSH
70352: LD_EXP 55
70356: PPUSH
70357: LD_VAR 0 2
70361: PPUSH
70362: LD_EXP 55
70366: PUSH
70367: LD_VAR 0 2
70371: ARRAY
70372: PUSH
70373: LD_VAR 0 3
70377: DIFF
70378: PPUSH
70379: CALL_OW 1
70383: ST_TO_ADDR
// continue ;
70384: GO 70329
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70386: LD_VAR 0 3
70390: PPUSH
70391: CALL_OW 311
70395: NOT
70396: PUSH
70397: LD_VAR 0 3
70401: PUSH
70402: LD_EXP 46
70406: PUSH
70407: LD_VAR 0 2
70411: ARRAY
70412: PUSH
70413: LD_INT 1
70415: ARRAY
70416: IN
70417: NOT
70418: AND
70419: PUSH
70420: LD_VAR 0 3
70424: PUSH
70425: LD_EXP 46
70429: PUSH
70430: LD_VAR 0 2
70434: ARRAY
70435: PUSH
70436: LD_INT 2
70438: ARRAY
70439: IN
70440: NOT
70441: AND
70442: IFFALSE 70505
// begin if IsInUnit ( j ) then
70444: LD_VAR 0 3
70448: PPUSH
70449: CALL_OW 310
70453: IFFALSE 70466
// ComExitBuilding ( j ) else
70455: LD_VAR 0 3
70459: PPUSH
70460: CALL_OW 122
70464: GO 70505
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
70466: LD_VAR 0 3
70470: PPUSH
70471: LD_VAR 0 7
70475: PUSH
70476: LD_INT 1
70478: ARRAY
70479: PPUSH
70480: CALL 49579 0 2
70484: NOT
70485: IFFALSE 70505
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
70487: LD_VAR 0 3
70491: PPUSH
70492: LD_VAR 0 7
70496: PUSH
70497: LD_INT 1
70499: ARRAY
70500: PPUSH
70501: CALL_OW 129
// end ; end ;
70505: GO 70329
70507: POP
70508: POP
// end ;
70509: GO 69790
70511: POP
70512: POP
// end ;
70513: LD_VAR 0 1
70517: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70518: LD_INT 0
70520: PPUSH
70521: PPUSH
70522: PPUSH
70523: PPUSH
70524: PPUSH
70525: PPUSH
70526: PPUSH
70527: PPUSH
70528: PPUSH
70529: PPUSH
70530: PPUSH
// if not mc_bases then
70531: LD_EXP 43
70535: NOT
70536: IFFALSE 70540
// exit ;
70538: GO 71342
// for i = 1 to mc_bases do
70540: LD_ADDR_VAR 0 2
70544: PUSH
70545: DOUBLE
70546: LD_INT 1
70548: DEC
70549: ST_TO_ADDR
70550: LD_EXP 43
70554: PUSH
70555: FOR_TO
70556: IFFALSE 71340
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70558: LD_EXP 71
70562: PUSH
70563: LD_VAR 0 2
70567: ARRAY
70568: NOT
70569: PUSH
70570: LD_EXP 46
70574: PUSH
70575: LD_VAR 0 2
70579: ARRAY
70580: PUSH
70581: LD_INT 1
70583: ARRAY
70584: OR
70585: PUSH
70586: LD_EXP 46
70590: PUSH
70591: LD_VAR 0 2
70595: ARRAY
70596: PUSH
70597: LD_INT 2
70599: ARRAY
70600: OR
70601: PUSH
70602: LD_EXP 69
70606: PUSH
70607: LD_VAR 0 2
70611: ARRAY
70612: PPUSH
70613: LD_INT 1
70615: PPUSH
70616: CALL_OW 325
70620: NOT
70621: OR
70622: PUSH
70623: LD_EXP 66
70627: PUSH
70628: LD_VAR 0 2
70632: ARRAY
70633: OR
70634: IFFALSE 70638
// continue ;
70636: GO 70555
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70638: LD_ADDR_VAR 0 8
70642: PUSH
70643: LD_EXP 43
70647: PUSH
70648: LD_VAR 0 2
70652: ARRAY
70653: PPUSH
70654: LD_INT 25
70656: PUSH
70657: LD_INT 4
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PUSH
70664: LD_INT 50
70666: PUSH
70667: EMPTY
70668: LIST
70669: PUSH
70670: LD_INT 3
70672: PUSH
70673: LD_INT 60
70675: PUSH
70676: EMPTY
70677: LIST
70678: PUSH
70679: EMPTY
70680: LIST
70681: LIST
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: LIST
70687: PPUSH
70688: CALL_OW 72
70692: PUSH
70693: LD_EXP 47
70697: PUSH
70698: LD_VAR 0 2
70702: ARRAY
70703: DIFF
70704: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70705: LD_ADDR_VAR 0 9
70709: PUSH
70710: LD_EXP 43
70714: PUSH
70715: LD_VAR 0 2
70719: ARRAY
70720: PPUSH
70721: LD_INT 2
70723: PUSH
70724: LD_INT 30
70726: PUSH
70727: LD_INT 0
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 30
70736: PUSH
70737: LD_INT 1
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: EMPTY
70745: LIST
70746: LIST
70747: LIST
70748: PPUSH
70749: CALL_OW 72
70753: ST_TO_ADDR
// if not tmp or not dep then
70754: LD_VAR 0 8
70758: NOT
70759: PUSH
70760: LD_VAR 0 9
70764: NOT
70765: OR
70766: IFFALSE 70770
// continue ;
70768: GO 70555
// side := GetSide ( tmp [ 1 ] ) ;
70770: LD_ADDR_VAR 0 11
70774: PUSH
70775: LD_VAR 0 8
70779: PUSH
70780: LD_INT 1
70782: ARRAY
70783: PPUSH
70784: CALL_OW 255
70788: ST_TO_ADDR
// dep := dep [ 1 ] ;
70789: LD_ADDR_VAR 0 9
70793: PUSH
70794: LD_VAR 0 9
70798: PUSH
70799: LD_INT 1
70801: ARRAY
70802: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70803: LD_ADDR_VAR 0 7
70807: PUSH
70808: LD_EXP 71
70812: PUSH
70813: LD_VAR 0 2
70817: ARRAY
70818: PPUSH
70819: LD_INT 22
70821: PUSH
70822: LD_INT 0
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: PUSH
70829: LD_INT 25
70831: PUSH
70832: LD_INT 12
70834: PUSH
70835: EMPTY
70836: LIST
70837: LIST
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PPUSH
70843: CALL_OW 70
70847: PUSH
70848: LD_INT 22
70850: PUSH
70851: LD_INT 0
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 25
70860: PUSH
70861: LD_INT 12
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 91
70870: PUSH
70871: LD_VAR 0 9
70875: PUSH
70876: LD_INT 20
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: LIST
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: LIST
70888: PPUSH
70889: CALL_OW 69
70893: UNION
70894: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70895: LD_ADDR_VAR 0 10
70899: PUSH
70900: LD_EXP 71
70904: PUSH
70905: LD_VAR 0 2
70909: ARRAY
70910: PPUSH
70911: LD_INT 81
70913: PUSH
70914: LD_VAR 0 11
70918: PUSH
70919: EMPTY
70920: LIST
70921: LIST
70922: PPUSH
70923: CALL_OW 70
70927: ST_TO_ADDR
// if not apes or danger_at_area then
70928: LD_VAR 0 7
70932: NOT
70933: PUSH
70934: LD_VAR 0 10
70938: OR
70939: IFFALSE 70989
// begin if mc_taming [ i ] then
70941: LD_EXP 74
70945: PUSH
70946: LD_VAR 0 2
70950: ARRAY
70951: IFFALSE 70987
// begin MC_Reset ( i , 121 ) ;
70953: LD_VAR 0 2
70957: PPUSH
70958: LD_INT 121
70960: PPUSH
70961: CALL 55905 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70965: LD_ADDR_EXP 74
70969: PUSH
70970: LD_EXP 74
70974: PPUSH
70975: LD_VAR 0 2
70979: PPUSH
70980: EMPTY
70981: PPUSH
70982: CALL_OW 1
70986: ST_TO_ADDR
// end ; continue ;
70987: GO 70555
// end ; for j in tmp do
70989: LD_ADDR_VAR 0 3
70993: PUSH
70994: LD_VAR 0 8
70998: PUSH
70999: FOR_IN
71000: IFFALSE 71336
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71002: LD_VAR 0 3
71006: PUSH
71007: LD_EXP 74
71011: PUSH
71012: LD_VAR 0 2
71016: ARRAY
71017: IN
71018: NOT
71019: PUSH
71020: LD_EXP 74
71024: PUSH
71025: LD_VAR 0 2
71029: ARRAY
71030: PUSH
71031: LD_INT 3
71033: LESS
71034: AND
71035: IFFALSE 71093
// begin SetTag ( j , 121 ) ;
71037: LD_VAR 0 3
71041: PPUSH
71042: LD_INT 121
71044: PPUSH
71045: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71049: LD_ADDR_EXP 74
71053: PUSH
71054: LD_EXP 74
71058: PPUSH
71059: LD_VAR 0 2
71063: PUSH
71064: LD_EXP 74
71068: PUSH
71069: LD_VAR 0 2
71073: ARRAY
71074: PUSH
71075: LD_INT 1
71077: PLUS
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PPUSH
71083: LD_VAR 0 3
71087: PPUSH
71088: CALL 14774 0 3
71092: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71093: LD_VAR 0 3
71097: PUSH
71098: LD_EXP 74
71102: PUSH
71103: LD_VAR 0 2
71107: ARRAY
71108: IN
71109: IFFALSE 71334
// begin if GetClass ( j ) <> 4 then
71111: LD_VAR 0 3
71115: PPUSH
71116: CALL_OW 257
71120: PUSH
71121: LD_INT 4
71123: NONEQUAL
71124: IFFALSE 71177
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71126: LD_ADDR_EXP 74
71130: PUSH
71131: LD_EXP 74
71135: PPUSH
71136: LD_VAR 0 2
71140: PPUSH
71141: LD_EXP 74
71145: PUSH
71146: LD_VAR 0 2
71150: ARRAY
71151: PUSH
71152: LD_VAR 0 3
71156: DIFF
71157: PPUSH
71158: CALL_OW 1
71162: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71163: LD_VAR 0 3
71167: PPUSH
71168: LD_INT 0
71170: PPUSH
71171: CALL_OW 109
// continue ;
71175: GO 70999
// end ; if IsInUnit ( j ) then
71177: LD_VAR 0 3
71181: PPUSH
71182: CALL_OW 310
71186: IFFALSE 71197
// ComExitBuilding ( j ) ;
71188: LD_VAR 0 3
71192: PPUSH
71193: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71197: LD_ADDR_VAR 0 6
71201: PUSH
71202: LD_VAR 0 7
71206: PPUSH
71207: LD_VAR 0 3
71211: PPUSH
71212: CALL_OW 74
71216: ST_TO_ADDR
// if not ape then
71217: LD_VAR 0 6
71221: NOT
71222: IFFALSE 71226
// break ;
71224: GO 71336
// x := GetX ( ape ) ;
71226: LD_ADDR_VAR 0 4
71230: PUSH
71231: LD_VAR 0 6
71235: PPUSH
71236: CALL_OW 250
71240: ST_TO_ADDR
// y := GetY ( ape ) ;
71241: LD_ADDR_VAR 0 5
71245: PUSH
71246: LD_VAR 0 6
71250: PPUSH
71251: CALL_OW 251
71255: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71256: LD_VAR 0 4
71260: PPUSH
71261: LD_VAR 0 5
71265: PPUSH
71266: CALL_OW 488
71270: NOT
71271: PUSH
71272: LD_VAR 0 11
71276: PPUSH
71277: LD_VAR 0 4
71281: PPUSH
71282: LD_VAR 0 5
71286: PPUSH
71287: LD_INT 20
71289: PPUSH
71290: CALL 16038 0 4
71294: PUSH
71295: LD_INT 4
71297: ARRAY
71298: OR
71299: IFFALSE 71303
// break ;
71301: GO 71336
// if not HasTask ( j ) then
71303: LD_VAR 0 3
71307: PPUSH
71308: CALL_OW 314
71312: NOT
71313: IFFALSE 71334
// ComTameXY ( j , x , y ) ;
71315: LD_VAR 0 3
71319: PPUSH
71320: LD_VAR 0 4
71324: PPUSH
71325: LD_VAR 0 5
71329: PPUSH
71330: CALL_OW 131
// end ; end ;
71334: GO 70999
71336: POP
71337: POP
// end ;
71338: GO 70555
71340: POP
71341: POP
// end ;
71342: LD_VAR 0 1
71346: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71347: LD_INT 0
71349: PPUSH
71350: PPUSH
71351: PPUSH
71352: PPUSH
71353: PPUSH
71354: PPUSH
71355: PPUSH
71356: PPUSH
// if not mc_bases then
71357: LD_EXP 43
71361: NOT
71362: IFFALSE 71366
// exit ;
71364: GO 71992
// for i = 1 to mc_bases do
71366: LD_ADDR_VAR 0 2
71370: PUSH
71371: DOUBLE
71372: LD_INT 1
71374: DEC
71375: ST_TO_ADDR
71376: LD_EXP 43
71380: PUSH
71381: FOR_TO
71382: IFFALSE 71990
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71384: LD_EXP 72
71388: PUSH
71389: LD_VAR 0 2
71393: ARRAY
71394: NOT
71395: PUSH
71396: LD_EXP 72
71400: PUSH
71401: LD_VAR 0 2
71405: ARRAY
71406: PPUSH
71407: LD_INT 25
71409: PUSH
71410: LD_INT 12
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PPUSH
71417: CALL_OW 72
71421: NOT
71422: OR
71423: IFFALSE 71427
// continue ;
71425: GO 71381
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
71427: LD_ADDR_VAR 0 5
71431: PUSH
71432: LD_EXP 72
71436: PUSH
71437: LD_VAR 0 2
71441: ARRAY
71442: PUSH
71443: LD_INT 1
71445: ARRAY
71446: PPUSH
71447: CALL_OW 255
71451: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
71452: LD_VAR 0 5
71456: PPUSH
71457: LD_INT 2
71459: PPUSH
71460: CALL_OW 325
71464: IFFALSE 71717
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71466: LD_ADDR_VAR 0 4
71470: PUSH
71471: LD_EXP 72
71475: PUSH
71476: LD_VAR 0 2
71480: ARRAY
71481: PPUSH
71482: LD_INT 25
71484: PUSH
71485: LD_INT 16
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: PPUSH
71492: CALL_OW 72
71496: ST_TO_ADDR
// if tmp < 6 then
71497: LD_VAR 0 4
71501: PUSH
71502: LD_INT 6
71504: LESS
71505: IFFALSE 71717
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71507: LD_ADDR_VAR 0 6
71511: PUSH
71512: LD_EXP 43
71516: PUSH
71517: LD_VAR 0 2
71521: ARRAY
71522: PPUSH
71523: LD_INT 2
71525: PUSH
71526: LD_INT 30
71528: PUSH
71529: LD_INT 0
71531: PUSH
71532: EMPTY
71533: LIST
71534: LIST
71535: PUSH
71536: LD_INT 30
71538: PUSH
71539: LD_INT 1
71541: PUSH
71542: EMPTY
71543: LIST
71544: LIST
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: LIST
71550: PPUSH
71551: CALL_OW 72
71555: ST_TO_ADDR
// if depot then
71556: LD_VAR 0 6
71560: IFFALSE 71717
// begin selected := 0 ;
71562: LD_ADDR_VAR 0 7
71566: PUSH
71567: LD_INT 0
71569: ST_TO_ADDR
// for j in depot do
71570: LD_ADDR_VAR 0 3
71574: PUSH
71575: LD_VAR 0 6
71579: PUSH
71580: FOR_IN
71581: IFFALSE 71612
// begin if UnitsInside ( j ) < 6 then
71583: LD_VAR 0 3
71587: PPUSH
71588: CALL_OW 313
71592: PUSH
71593: LD_INT 6
71595: LESS
71596: IFFALSE 71610
// begin selected := j ;
71598: LD_ADDR_VAR 0 7
71602: PUSH
71603: LD_VAR 0 3
71607: ST_TO_ADDR
// break ;
71608: GO 71612
// end ; end ;
71610: GO 71580
71612: POP
71613: POP
// if selected then
71614: LD_VAR 0 7
71618: IFFALSE 71717
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71620: LD_ADDR_VAR 0 3
71624: PUSH
71625: LD_EXP 72
71629: PUSH
71630: LD_VAR 0 2
71634: ARRAY
71635: PPUSH
71636: LD_INT 25
71638: PUSH
71639: LD_INT 12
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: PPUSH
71646: CALL_OW 72
71650: PUSH
71651: FOR_IN
71652: IFFALSE 71715
// if not HasTask ( j ) then
71654: LD_VAR 0 3
71658: PPUSH
71659: CALL_OW 314
71663: NOT
71664: IFFALSE 71713
// begin if not IsInUnit ( j ) then
71666: LD_VAR 0 3
71670: PPUSH
71671: CALL_OW 310
71675: NOT
71676: IFFALSE 71692
// ComEnterUnit ( j , selected ) ;
71678: LD_VAR 0 3
71682: PPUSH
71683: LD_VAR 0 7
71687: PPUSH
71688: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71692: LD_VAR 0 3
71696: PPUSH
71697: LD_INT 16
71699: PPUSH
71700: CALL_OW 183
// AddComExitBuilding ( j ) ;
71704: LD_VAR 0 3
71708: PPUSH
71709: CALL_OW 182
// end ;
71713: GO 71651
71715: POP
71716: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71717: LD_VAR 0 5
71721: PPUSH
71722: LD_INT 11
71724: PPUSH
71725: CALL_OW 325
71729: IFFALSE 71988
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71731: LD_ADDR_VAR 0 4
71735: PUSH
71736: LD_EXP 72
71740: PUSH
71741: LD_VAR 0 2
71745: ARRAY
71746: PPUSH
71747: LD_INT 25
71749: PUSH
71750: LD_INT 16
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PPUSH
71757: CALL_OW 72
71761: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71762: LD_VAR 0 4
71766: PUSH
71767: LD_INT 6
71769: GREATEREQUAL
71770: PUSH
71771: LD_VAR 0 5
71775: PPUSH
71776: LD_INT 2
71778: PPUSH
71779: CALL_OW 325
71783: NOT
71784: OR
71785: IFFALSE 71988
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71787: LD_ADDR_VAR 0 8
71791: PUSH
71792: LD_EXP 43
71796: PUSH
71797: LD_VAR 0 2
71801: ARRAY
71802: PPUSH
71803: LD_INT 2
71805: PUSH
71806: LD_INT 30
71808: PUSH
71809: LD_INT 4
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 30
71818: PUSH
71819: LD_INT 5
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: LIST
71830: PPUSH
71831: CALL_OW 72
71835: ST_TO_ADDR
// if barracks then
71836: LD_VAR 0 8
71840: IFFALSE 71988
// begin selected := 0 ;
71842: LD_ADDR_VAR 0 7
71846: PUSH
71847: LD_INT 0
71849: ST_TO_ADDR
// for j in barracks do
71850: LD_ADDR_VAR 0 3
71854: PUSH
71855: LD_VAR 0 8
71859: PUSH
71860: FOR_IN
71861: IFFALSE 71892
// begin if UnitsInside ( j ) < 6 then
71863: LD_VAR 0 3
71867: PPUSH
71868: CALL_OW 313
71872: PUSH
71873: LD_INT 6
71875: LESS
71876: IFFALSE 71890
// begin selected := j ;
71878: LD_ADDR_VAR 0 7
71882: PUSH
71883: LD_VAR 0 3
71887: ST_TO_ADDR
// break ;
71888: GO 71892
// end ; end ;
71890: GO 71860
71892: POP
71893: POP
// if selected then
71894: LD_VAR 0 7
71898: IFFALSE 71988
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71900: LD_ADDR_VAR 0 3
71904: PUSH
71905: LD_EXP 72
71909: PUSH
71910: LD_VAR 0 2
71914: ARRAY
71915: PPUSH
71916: LD_INT 25
71918: PUSH
71919: LD_INT 12
71921: PUSH
71922: EMPTY
71923: LIST
71924: LIST
71925: PPUSH
71926: CALL_OW 72
71930: PUSH
71931: FOR_IN
71932: IFFALSE 71986
// if not IsInUnit ( j ) and not HasTask ( j ) then
71934: LD_VAR 0 3
71938: PPUSH
71939: CALL_OW 310
71943: NOT
71944: PUSH
71945: LD_VAR 0 3
71949: PPUSH
71950: CALL_OW 314
71954: NOT
71955: AND
71956: IFFALSE 71984
// begin ComEnterUnit ( j , selected ) ;
71958: LD_VAR 0 3
71962: PPUSH
71963: LD_VAR 0 7
71967: PPUSH
71968: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71972: LD_VAR 0 3
71976: PPUSH
71977: LD_INT 15
71979: PPUSH
71980: CALL_OW 183
// end ;
71984: GO 71931
71986: POP
71987: POP
// end ; end ; end ; end ; end ;
71988: GO 71381
71990: POP
71991: POP
// end ;
71992: LD_VAR 0 1
71996: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71997: LD_INT 0
71999: PPUSH
72000: PPUSH
72001: PPUSH
72002: PPUSH
// if not mc_bases then
72003: LD_EXP 43
72007: NOT
72008: IFFALSE 72012
// exit ;
72010: GO 72190
// for i = 1 to mc_bases do
72012: LD_ADDR_VAR 0 2
72016: PUSH
72017: DOUBLE
72018: LD_INT 1
72020: DEC
72021: ST_TO_ADDR
72022: LD_EXP 43
72026: PUSH
72027: FOR_TO
72028: IFFALSE 72188
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72030: LD_ADDR_VAR 0 4
72034: PUSH
72035: LD_EXP 43
72039: PUSH
72040: LD_VAR 0 2
72044: ARRAY
72045: PPUSH
72046: LD_INT 25
72048: PUSH
72049: LD_INT 9
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PPUSH
72056: CALL_OW 72
72060: ST_TO_ADDR
// if not tmp then
72061: LD_VAR 0 4
72065: NOT
72066: IFFALSE 72070
// continue ;
72068: GO 72027
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72070: LD_EXP 69
72074: PUSH
72075: LD_VAR 0 2
72079: ARRAY
72080: PPUSH
72081: LD_INT 29
72083: PPUSH
72084: CALL_OW 325
72088: NOT
72089: PUSH
72090: LD_EXP 69
72094: PUSH
72095: LD_VAR 0 2
72099: ARRAY
72100: PPUSH
72101: LD_INT 28
72103: PPUSH
72104: CALL_OW 325
72108: NOT
72109: AND
72110: IFFALSE 72114
// continue ;
72112: GO 72027
// for j in tmp do
72114: LD_ADDR_VAR 0 3
72118: PUSH
72119: LD_VAR 0 4
72123: PUSH
72124: FOR_IN
72125: IFFALSE 72184
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72127: LD_VAR 0 3
72131: PUSH
72132: LD_EXP 46
72136: PUSH
72137: LD_VAR 0 2
72141: ARRAY
72142: PUSH
72143: LD_INT 1
72145: ARRAY
72146: IN
72147: NOT
72148: PUSH
72149: LD_VAR 0 3
72153: PUSH
72154: LD_EXP 46
72158: PUSH
72159: LD_VAR 0 2
72163: ARRAY
72164: PUSH
72165: LD_INT 2
72167: ARRAY
72168: IN
72169: NOT
72170: AND
72171: IFFALSE 72182
// ComSpaceTimeShoot ( j ) ;
72173: LD_VAR 0 3
72177: PPUSH
72178: CALL 10759 0 1
72182: GO 72124
72184: POP
72185: POP
// end ;
72186: GO 72027
72188: POP
72189: POP
// end ;
72190: LD_VAR 0 1
72194: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72195: LD_INT 0
72197: PPUSH
72198: PPUSH
72199: PPUSH
72200: PPUSH
72201: PPUSH
72202: PPUSH
72203: PPUSH
72204: PPUSH
72205: PPUSH
// if not mc_bases then
72206: LD_EXP 43
72210: NOT
72211: IFFALSE 72215
// exit ;
72213: GO 72837
// for i = 1 to mc_bases do
72215: LD_ADDR_VAR 0 2
72219: PUSH
72220: DOUBLE
72221: LD_INT 1
72223: DEC
72224: ST_TO_ADDR
72225: LD_EXP 43
72229: PUSH
72230: FOR_TO
72231: IFFALSE 72835
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72233: LD_EXP 78
72237: PUSH
72238: LD_VAR 0 2
72242: ARRAY
72243: NOT
72244: PUSH
72245: LD_INT 38
72247: PPUSH
72248: LD_EXP 69
72252: PUSH
72253: LD_VAR 0 2
72257: ARRAY
72258: PPUSH
72259: CALL_OW 321
72263: PUSH
72264: LD_INT 2
72266: NONEQUAL
72267: OR
72268: IFFALSE 72272
// continue ;
72270: GO 72230
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72272: LD_ADDR_VAR 0 8
72276: PUSH
72277: LD_EXP 43
72281: PUSH
72282: LD_VAR 0 2
72286: ARRAY
72287: PPUSH
72288: LD_INT 30
72290: PUSH
72291: LD_INT 34
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PPUSH
72298: CALL_OW 72
72302: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72303: LD_ADDR_VAR 0 9
72307: PUSH
72308: LD_EXP 43
72312: PUSH
72313: LD_VAR 0 2
72317: ARRAY
72318: PPUSH
72319: LD_INT 25
72321: PUSH
72322: LD_INT 4
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: PPUSH
72329: CALL_OW 72
72333: PPUSH
72334: LD_INT 0
72336: PPUSH
72337: CALL 45083 0 2
72341: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72342: LD_VAR 0 9
72346: NOT
72347: PUSH
72348: LD_VAR 0 8
72352: NOT
72353: OR
72354: PUSH
72355: LD_EXP 43
72359: PUSH
72360: LD_VAR 0 2
72364: ARRAY
72365: PPUSH
72366: LD_INT 124
72368: PPUSH
72369: CALL 45083 0 2
72373: OR
72374: IFFALSE 72378
// continue ;
72376: GO 72230
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72378: LD_EXP 79
72382: PUSH
72383: LD_VAR 0 2
72387: ARRAY
72388: PUSH
72389: LD_EXP 78
72393: PUSH
72394: LD_VAR 0 2
72398: ARRAY
72399: LESS
72400: PUSH
72401: LD_EXP 79
72405: PUSH
72406: LD_VAR 0 2
72410: ARRAY
72411: PUSH
72412: LD_VAR 0 8
72416: LESS
72417: AND
72418: IFFALSE 72833
// begin tmp := sci [ 1 ] ;
72420: LD_ADDR_VAR 0 7
72424: PUSH
72425: LD_VAR 0 9
72429: PUSH
72430: LD_INT 1
72432: ARRAY
72433: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
72434: LD_VAR 0 7
72438: PPUSH
72439: LD_INT 124
72441: PPUSH
72442: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
72446: LD_ADDR_VAR 0 3
72450: PUSH
72451: DOUBLE
72452: LD_EXP 78
72456: PUSH
72457: LD_VAR 0 2
72461: ARRAY
72462: INC
72463: ST_TO_ADDR
72464: LD_EXP 78
72468: PUSH
72469: LD_VAR 0 2
72473: ARRAY
72474: PUSH
72475: FOR_DOWNTO
72476: IFFALSE 72819
// begin if IsInUnit ( tmp ) then
72478: LD_VAR 0 7
72482: PPUSH
72483: CALL_OW 310
72487: IFFALSE 72498
// ComExitBuilding ( tmp ) ;
72489: LD_VAR 0 7
72493: PPUSH
72494: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72498: LD_INT 35
72500: PPUSH
72501: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72505: LD_VAR 0 7
72509: PPUSH
72510: CALL_OW 310
72514: NOT
72515: PUSH
72516: LD_VAR 0 7
72520: PPUSH
72521: CALL_OW 314
72525: NOT
72526: AND
72527: IFFALSE 72498
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72529: LD_ADDR_VAR 0 6
72533: PUSH
72534: LD_VAR 0 7
72538: PPUSH
72539: CALL_OW 250
72543: PUSH
72544: LD_VAR 0 7
72548: PPUSH
72549: CALL_OW 251
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72558: LD_INT 35
72560: PPUSH
72561: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72565: LD_ADDR_VAR 0 4
72569: PUSH
72570: LD_EXP 78
72574: PUSH
72575: LD_VAR 0 2
72579: ARRAY
72580: PUSH
72581: LD_VAR 0 3
72585: ARRAY
72586: PUSH
72587: LD_INT 1
72589: ARRAY
72590: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72591: LD_ADDR_VAR 0 5
72595: PUSH
72596: LD_EXP 78
72600: PUSH
72601: LD_VAR 0 2
72605: ARRAY
72606: PUSH
72607: LD_VAR 0 3
72611: ARRAY
72612: PUSH
72613: LD_INT 2
72615: ARRAY
72616: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72617: LD_VAR 0 7
72621: PPUSH
72622: LD_INT 10
72624: PPUSH
72625: CALL 17739 0 2
72629: PUSH
72630: LD_INT 4
72632: ARRAY
72633: IFFALSE 72671
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72635: LD_VAR 0 7
72639: PPUSH
72640: LD_VAR 0 6
72644: PUSH
72645: LD_INT 1
72647: ARRAY
72648: PPUSH
72649: LD_VAR 0 6
72653: PUSH
72654: LD_INT 2
72656: ARRAY
72657: PPUSH
72658: CALL_OW 111
// wait ( 0 0$10 ) ;
72662: LD_INT 350
72664: PPUSH
72665: CALL_OW 67
// end else
72669: GO 72697
// begin ComMoveXY ( tmp , x , y ) ;
72671: LD_VAR 0 7
72675: PPUSH
72676: LD_VAR 0 4
72680: PPUSH
72681: LD_VAR 0 5
72685: PPUSH
72686: CALL_OW 111
// wait ( 0 0$3 ) ;
72690: LD_INT 105
72692: PPUSH
72693: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72697: LD_VAR 0 7
72701: PPUSH
72702: LD_VAR 0 4
72706: PPUSH
72707: LD_VAR 0 5
72711: PPUSH
72712: CALL_OW 307
72716: IFFALSE 72558
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72718: LD_VAR 0 7
72722: PPUSH
72723: LD_VAR 0 4
72727: PPUSH
72728: LD_VAR 0 5
72732: PPUSH
72733: LD_VAR 0 8
72737: PUSH
72738: LD_VAR 0 3
72742: ARRAY
72743: PPUSH
72744: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72748: LD_INT 35
72750: PPUSH
72751: CALL_OW 67
// until not HasTask ( tmp ) ;
72755: LD_VAR 0 7
72759: PPUSH
72760: CALL_OW 314
72764: NOT
72765: IFFALSE 72748
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72767: LD_ADDR_EXP 79
72771: PUSH
72772: LD_EXP 79
72776: PPUSH
72777: LD_VAR 0 2
72781: PUSH
72782: LD_EXP 79
72786: PUSH
72787: LD_VAR 0 2
72791: ARRAY
72792: PUSH
72793: LD_INT 1
72795: PLUS
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PPUSH
72801: LD_VAR 0 8
72805: PUSH
72806: LD_VAR 0 3
72810: ARRAY
72811: PPUSH
72812: CALL 14774 0 3
72816: ST_TO_ADDR
// end ;
72817: GO 72475
72819: POP
72820: POP
// MC_Reset ( i , 124 ) ;
72821: LD_VAR 0 2
72825: PPUSH
72826: LD_INT 124
72828: PPUSH
72829: CALL 55905 0 2
// end ; end ;
72833: GO 72230
72835: POP
72836: POP
// end ;
72837: LD_VAR 0 1
72841: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72842: LD_INT 0
72844: PPUSH
72845: PPUSH
72846: PPUSH
// if not mc_bases then
72847: LD_EXP 43
72851: NOT
72852: IFFALSE 72856
// exit ;
72854: GO 73462
// for i = 1 to mc_bases do
72856: LD_ADDR_VAR 0 2
72860: PUSH
72861: DOUBLE
72862: LD_INT 1
72864: DEC
72865: ST_TO_ADDR
72866: LD_EXP 43
72870: PUSH
72871: FOR_TO
72872: IFFALSE 73460
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72874: LD_ADDR_VAR 0 3
72878: PUSH
72879: LD_EXP 43
72883: PUSH
72884: LD_VAR 0 2
72888: ARRAY
72889: PPUSH
72890: LD_INT 25
72892: PUSH
72893: LD_INT 4
72895: PUSH
72896: EMPTY
72897: LIST
72898: LIST
72899: PPUSH
72900: CALL_OW 72
72904: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72905: LD_VAR 0 3
72909: NOT
72910: PUSH
72911: LD_EXP 80
72915: PUSH
72916: LD_VAR 0 2
72920: ARRAY
72921: NOT
72922: OR
72923: PUSH
72924: LD_EXP 43
72928: PUSH
72929: LD_VAR 0 2
72933: ARRAY
72934: PPUSH
72935: LD_INT 2
72937: PUSH
72938: LD_INT 30
72940: PUSH
72941: LD_INT 0
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 30
72950: PUSH
72951: LD_INT 1
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: LIST
72962: PPUSH
72963: CALL_OW 72
72967: NOT
72968: OR
72969: IFFALSE 73019
// begin if mc_deposits_finder [ i ] then
72971: LD_EXP 81
72975: PUSH
72976: LD_VAR 0 2
72980: ARRAY
72981: IFFALSE 73017
// begin MC_Reset ( i , 125 ) ;
72983: LD_VAR 0 2
72987: PPUSH
72988: LD_INT 125
72990: PPUSH
72991: CALL 55905 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72995: LD_ADDR_EXP 81
72999: PUSH
73000: LD_EXP 81
73004: PPUSH
73005: LD_VAR 0 2
73009: PPUSH
73010: EMPTY
73011: PPUSH
73012: CALL_OW 1
73016: ST_TO_ADDR
// end ; continue ;
73017: GO 72871
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73019: LD_EXP 80
73023: PUSH
73024: LD_VAR 0 2
73028: ARRAY
73029: PUSH
73030: LD_INT 1
73032: ARRAY
73033: PUSH
73034: LD_INT 3
73036: ARRAY
73037: PUSH
73038: LD_INT 1
73040: EQUAL
73041: PUSH
73042: LD_INT 20
73044: PPUSH
73045: LD_EXP 69
73049: PUSH
73050: LD_VAR 0 2
73054: ARRAY
73055: PPUSH
73056: CALL_OW 321
73060: PUSH
73061: LD_INT 2
73063: NONEQUAL
73064: AND
73065: IFFALSE 73115
// begin if mc_deposits_finder [ i ] then
73067: LD_EXP 81
73071: PUSH
73072: LD_VAR 0 2
73076: ARRAY
73077: IFFALSE 73113
// begin MC_Reset ( i , 125 ) ;
73079: LD_VAR 0 2
73083: PPUSH
73084: LD_INT 125
73086: PPUSH
73087: CALL 55905 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73091: LD_ADDR_EXP 81
73095: PUSH
73096: LD_EXP 81
73100: PPUSH
73101: LD_VAR 0 2
73105: PPUSH
73106: EMPTY
73107: PPUSH
73108: CALL_OW 1
73112: ST_TO_ADDR
// end ; continue ;
73113: GO 72871
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73115: LD_EXP 80
73119: PUSH
73120: LD_VAR 0 2
73124: ARRAY
73125: PUSH
73126: LD_INT 1
73128: ARRAY
73129: PUSH
73130: LD_INT 1
73132: ARRAY
73133: PPUSH
73134: LD_EXP 80
73138: PUSH
73139: LD_VAR 0 2
73143: ARRAY
73144: PUSH
73145: LD_INT 1
73147: ARRAY
73148: PUSH
73149: LD_INT 2
73151: ARRAY
73152: PPUSH
73153: LD_EXP 69
73157: PUSH
73158: LD_VAR 0 2
73162: ARRAY
73163: PPUSH
73164: CALL_OW 440
73168: IFFALSE 73211
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73170: LD_ADDR_EXP 80
73174: PUSH
73175: LD_EXP 80
73179: PPUSH
73180: LD_VAR 0 2
73184: PPUSH
73185: LD_EXP 80
73189: PUSH
73190: LD_VAR 0 2
73194: ARRAY
73195: PPUSH
73196: LD_INT 1
73198: PPUSH
73199: CALL_OW 3
73203: PPUSH
73204: CALL_OW 1
73208: ST_TO_ADDR
73209: GO 73458
// begin if not mc_deposits_finder [ i ] then
73211: LD_EXP 81
73215: PUSH
73216: LD_VAR 0 2
73220: ARRAY
73221: NOT
73222: IFFALSE 73274
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73224: LD_ADDR_EXP 81
73228: PUSH
73229: LD_EXP 81
73233: PPUSH
73234: LD_VAR 0 2
73238: PPUSH
73239: LD_VAR 0 3
73243: PUSH
73244: LD_INT 1
73246: ARRAY
73247: PUSH
73248: EMPTY
73249: LIST
73250: PPUSH
73251: CALL_OW 1
73255: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73256: LD_VAR 0 3
73260: PUSH
73261: LD_INT 1
73263: ARRAY
73264: PPUSH
73265: LD_INT 125
73267: PPUSH
73268: CALL_OW 109
// end else
73272: GO 73458
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73274: LD_EXP 81
73278: PUSH
73279: LD_VAR 0 2
73283: ARRAY
73284: PUSH
73285: LD_INT 1
73287: ARRAY
73288: PPUSH
73289: CALL_OW 310
73293: IFFALSE 73316
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73295: LD_EXP 81
73299: PUSH
73300: LD_VAR 0 2
73304: ARRAY
73305: PUSH
73306: LD_INT 1
73308: ARRAY
73309: PPUSH
73310: CALL_OW 122
73314: GO 73458
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73316: LD_EXP 81
73320: PUSH
73321: LD_VAR 0 2
73325: ARRAY
73326: PUSH
73327: LD_INT 1
73329: ARRAY
73330: PPUSH
73331: CALL_OW 314
73335: NOT
73336: PUSH
73337: LD_EXP 81
73341: PUSH
73342: LD_VAR 0 2
73346: ARRAY
73347: PUSH
73348: LD_INT 1
73350: ARRAY
73351: PPUSH
73352: LD_EXP 80
73356: PUSH
73357: LD_VAR 0 2
73361: ARRAY
73362: PUSH
73363: LD_INT 1
73365: ARRAY
73366: PUSH
73367: LD_INT 1
73369: ARRAY
73370: PPUSH
73371: LD_EXP 80
73375: PUSH
73376: LD_VAR 0 2
73380: ARRAY
73381: PUSH
73382: LD_INT 1
73384: ARRAY
73385: PUSH
73386: LD_INT 2
73388: ARRAY
73389: PPUSH
73390: CALL_OW 297
73394: PUSH
73395: LD_INT 6
73397: GREATER
73398: AND
73399: IFFALSE 73458
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
73401: LD_EXP 81
73405: PUSH
73406: LD_VAR 0 2
73410: ARRAY
73411: PUSH
73412: LD_INT 1
73414: ARRAY
73415: PPUSH
73416: LD_EXP 80
73420: PUSH
73421: LD_VAR 0 2
73425: ARRAY
73426: PUSH
73427: LD_INT 1
73429: ARRAY
73430: PUSH
73431: LD_INT 1
73433: ARRAY
73434: PPUSH
73435: LD_EXP 80
73439: PUSH
73440: LD_VAR 0 2
73444: ARRAY
73445: PUSH
73446: LD_INT 1
73448: ARRAY
73449: PUSH
73450: LD_INT 2
73452: ARRAY
73453: PPUSH
73454: CALL_OW 111
// end ; end ; end ;
73458: GO 72871
73460: POP
73461: POP
// end ;
73462: LD_VAR 0 1
73466: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
73467: LD_INT 0
73469: PPUSH
73470: PPUSH
73471: PPUSH
73472: PPUSH
73473: PPUSH
73474: PPUSH
73475: PPUSH
73476: PPUSH
73477: PPUSH
73478: PPUSH
73479: PPUSH
// if not mc_bases then
73480: LD_EXP 43
73484: NOT
73485: IFFALSE 73489
// exit ;
73487: GO 74429
// for i = 1 to mc_bases do
73489: LD_ADDR_VAR 0 2
73493: PUSH
73494: DOUBLE
73495: LD_INT 1
73497: DEC
73498: ST_TO_ADDR
73499: LD_EXP 43
73503: PUSH
73504: FOR_TO
73505: IFFALSE 74427
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73507: LD_EXP 43
73511: PUSH
73512: LD_VAR 0 2
73516: ARRAY
73517: NOT
73518: PUSH
73519: LD_EXP 66
73523: PUSH
73524: LD_VAR 0 2
73528: ARRAY
73529: OR
73530: IFFALSE 73534
// continue ;
73532: GO 73504
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73534: LD_ADDR_VAR 0 7
73538: PUSH
73539: LD_EXP 43
73543: PUSH
73544: LD_VAR 0 2
73548: ARRAY
73549: PUSH
73550: LD_INT 1
73552: ARRAY
73553: PPUSH
73554: CALL_OW 248
73558: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73559: LD_VAR 0 7
73563: PUSH
73564: LD_INT 3
73566: EQUAL
73567: PUSH
73568: LD_EXP 62
73572: PUSH
73573: LD_VAR 0 2
73577: ARRAY
73578: PUSH
73579: LD_EXP 65
73583: PUSH
73584: LD_VAR 0 2
73588: ARRAY
73589: UNION
73590: PPUSH
73591: LD_INT 33
73593: PUSH
73594: LD_INT 2
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PPUSH
73601: CALL_OW 72
73605: NOT
73606: OR
73607: IFFALSE 73611
// continue ;
73609: GO 73504
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73611: LD_ADDR_VAR 0 9
73615: PUSH
73616: LD_EXP 43
73620: PUSH
73621: LD_VAR 0 2
73625: ARRAY
73626: PPUSH
73627: LD_INT 30
73629: PUSH
73630: LD_INT 36
73632: PUSH
73633: EMPTY
73634: LIST
73635: LIST
73636: PPUSH
73637: CALL_OW 72
73641: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73642: LD_ADDR_VAR 0 10
73646: PUSH
73647: LD_EXP 62
73651: PUSH
73652: LD_VAR 0 2
73656: ARRAY
73657: PPUSH
73658: LD_INT 34
73660: PUSH
73661: LD_INT 31
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: PPUSH
73668: CALL_OW 72
73672: ST_TO_ADDR
// if not cts and not mcts then
73673: LD_VAR 0 9
73677: NOT
73678: PUSH
73679: LD_VAR 0 10
73683: NOT
73684: AND
73685: IFFALSE 73689
// continue ;
73687: GO 73504
// x := cts ;
73689: LD_ADDR_VAR 0 11
73693: PUSH
73694: LD_VAR 0 9
73698: ST_TO_ADDR
// if not x then
73699: LD_VAR 0 11
73703: NOT
73704: IFFALSE 73716
// x := mcts ;
73706: LD_ADDR_VAR 0 11
73710: PUSH
73711: LD_VAR 0 10
73715: ST_TO_ADDR
// if not x then
73716: LD_VAR 0 11
73720: NOT
73721: IFFALSE 73725
// continue ;
73723: GO 73504
// if mc_remote_driver [ i ] then
73725: LD_EXP 83
73729: PUSH
73730: LD_VAR 0 2
73734: ARRAY
73735: IFFALSE 74122
// for j in mc_remote_driver [ i ] do
73737: LD_ADDR_VAR 0 3
73741: PUSH
73742: LD_EXP 83
73746: PUSH
73747: LD_VAR 0 2
73751: ARRAY
73752: PUSH
73753: FOR_IN
73754: IFFALSE 74120
// begin if GetClass ( j ) <> 3 then
73756: LD_VAR 0 3
73760: PPUSH
73761: CALL_OW 257
73765: PUSH
73766: LD_INT 3
73768: NONEQUAL
73769: IFFALSE 73822
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73771: LD_ADDR_EXP 83
73775: PUSH
73776: LD_EXP 83
73780: PPUSH
73781: LD_VAR 0 2
73785: PPUSH
73786: LD_EXP 83
73790: PUSH
73791: LD_VAR 0 2
73795: ARRAY
73796: PUSH
73797: LD_VAR 0 3
73801: DIFF
73802: PPUSH
73803: CALL_OW 1
73807: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73808: LD_VAR 0 3
73812: PPUSH
73813: LD_INT 0
73815: PPUSH
73816: CALL_OW 109
// continue ;
73820: GO 73753
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73822: LD_EXP 62
73826: PUSH
73827: LD_VAR 0 2
73831: ARRAY
73832: PPUSH
73833: LD_INT 34
73835: PUSH
73836: LD_INT 31
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: PUSH
73843: LD_INT 58
73845: PUSH
73846: EMPTY
73847: LIST
73848: PUSH
73849: EMPTY
73850: LIST
73851: LIST
73852: PPUSH
73853: CALL_OW 72
73857: PUSH
73858: LD_VAR 0 3
73862: PPUSH
73863: CALL 45118 0 1
73867: NOT
73868: AND
73869: IFFALSE 73940
// begin if IsInUnit ( j ) then
73871: LD_VAR 0 3
73875: PPUSH
73876: CALL_OW 310
73880: IFFALSE 73891
// ComExitBuilding ( j ) ;
73882: LD_VAR 0 3
73886: PPUSH
73887: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73891: LD_VAR 0 3
73895: PPUSH
73896: LD_EXP 62
73900: PUSH
73901: LD_VAR 0 2
73905: ARRAY
73906: PPUSH
73907: LD_INT 34
73909: PUSH
73910: LD_INT 31
73912: PUSH
73913: EMPTY
73914: LIST
73915: LIST
73916: PUSH
73917: LD_INT 58
73919: PUSH
73920: EMPTY
73921: LIST
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PPUSH
73927: CALL_OW 72
73931: PUSH
73932: LD_INT 1
73934: ARRAY
73935: PPUSH
73936: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73940: LD_VAR 0 3
73944: PPUSH
73945: CALL_OW 310
73949: NOT
73950: PUSH
73951: LD_VAR 0 3
73955: PPUSH
73956: CALL_OW 310
73960: PPUSH
73961: CALL_OW 266
73965: PUSH
73966: LD_INT 36
73968: NONEQUAL
73969: PUSH
73970: LD_VAR 0 3
73974: PPUSH
73975: CALL 45118 0 1
73979: NOT
73980: AND
73981: OR
73982: IFFALSE 74118
// begin if IsInUnit ( j ) then
73984: LD_VAR 0 3
73988: PPUSH
73989: CALL_OW 310
73993: IFFALSE 74004
// ComExitBuilding ( j ) ;
73995: LD_VAR 0 3
73999: PPUSH
74000: CALL_OW 122
// ct := 0 ;
74004: LD_ADDR_VAR 0 8
74008: PUSH
74009: LD_INT 0
74011: ST_TO_ADDR
// for k in x do
74012: LD_ADDR_VAR 0 4
74016: PUSH
74017: LD_VAR 0 11
74021: PUSH
74022: FOR_IN
74023: IFFALSE 74096
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74025: LD_VAR 0 4
74029: PPUSH
74030: CALL_OW 264
74034: PUSH
74035: LD_INT 31
74037: EQUAL
74038: PUSH
74039: LD_VAR 0 4
74043: PPUSH
74044: CALL_OW 311
74048: NOT
74049: AND
74050: PUSH
74051: LD_VAR 0 4
74055: PPUSH
74056: CALL_OW 266
74060: PUSH
74061: LD_INT 36
74063: EQUAL
74064: PUSH
74065: LD_VAR 0 4
74069: PPUSH
74070: CALL_OW 313
74074: PUSH
74075: LD_INT 3
74077: LESS
74078: AND
74079: OR
74080: IFFALSE 74094
// begin ct := k ;
74082: LD_ADDR_VAR 0 8
74086: PUSH
74087: LD_VAR 0 4
74091: ST_TO_ADDR
// break ;
74092: GO 74096
// end ;
74094: GO 74022
74096: POP
74097: POP
// if ct then
74098: LD_VAR 0 8
74102: IFFALSE 74118
// ComEnterUnit ( j , ct ) ;
74104: LD_VAR 0 3
74108: PPUSH
74109: LD_VAR 0 8
74113: PPUSH
74114: CALL_OW 120
// end ; end ;
74118: GO 73753
74120: POP
74121: POP
// places := 0 ;
74122: LD_ADDR_VAR 0 5
74126: PUSH
74127: LD_INT 0
74129: ST_TO_ADDR
// for j = 1 to x do
74130: LD_ADDR_VAR 0 3
74134: PUSH
74135: DOUBLE
74136: LD_INT 1
74138: DEC
74139: ST_TO_ADDR
74140: LD_VAR 0 11
74144: PUSH
74145: FOR_TO
74146: IFFALSE 74222
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74148: LD_VAR 0 11
74152: PUSH
74153: LD_VAR 0 3
74157: ARRAY
74158: PPUSH
74159: CALL_OW 264
74163: PUSH
74164: LD_INT 31
74166: EQUAL
74167: IFFALSE 74185
// places := places + 1 else
74169: LD_ADDR_VAR 0 5
74173: PUSH
74174: LD_VAR 0 5
74178: PUSH
74179: LD_INT 1
74181: PLUS
74182: ST_TO_ADDR
74183: GO 74220
// if GetBType ( x [ j ] ) = b_control_tower then
74185: LD_VAR 0 11
74189: PUSH
74190: LD_VAR 0 3
74194: ARRAY
74195: PPUSH
74196: CALL_OW 266
74200: PUSH
74201: LD_INT 36
74203: EQUAL
74204: IFFALSE 74220
// places := places + 3 ;
74206: LD_ADDR_VAR 0 5
74210: PUSH
74211: LD_VAR 0 5
74215: PUSH
74216: LD_INT 3
74218: PLUS
74219: ST_TO_ADDR
74220: GO 74145
74222: POP
74223: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74224: LD_VAR 0 5
74228: PUSH
74229: LD_INT 0
74231: EQUAL
74232: PUSH
74233: LD_VAR 0 5
74237: PUSH
74238: LD_EXP 83
74242: PUSH
74243: LD_VAR 0 2
74247: ARRAY
74248: LESSEQUAL
74249: OR
74250: IFFALSE 74254
// continue ;
74252: GO 73504
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74254: LD_ADDR_VAR 0 6
74258: PUSH
74259: LD_EXP 43
74263: PUSH
74264: LD_VAR 0 2
74268: ARRAY
74269: PPUSH
74270: LD_INT 25
74272: PUSH
74273: LD_INT 3
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PPUSH
74280: CALL_OW 72
74284: PUSH
74285: LD_EXP 83
74289: PUSH
74290: LD_VAR 0 2
74294: ARRAY
74295: DIFF
74296: PPUSH
74297: LD_INT 3
74299: PPUSH
74300: CALL 46018 0 2
74304: ST_TO_ADDR
// for j in tmp do
74305: LD_ADDR_VAR 0 3
74309: PUSH
74310: LD_VAR 0 6
74314: PUSH
74315: FOR_IN
74316: IFFALSE 74351
// if GetTag ( j ) > 0 then
74318: LD_VAR 0 3
74322: PPUSH
74323: CALL_OW 110
74327: PUSH
74328: LD_INT 0
74330: GREATER
74331: IFFALSE 74349
// tmp := tmp diff j ;
74333: LD_ADDR_VAR 0 6
74337: PUSH
74338: LD_VAR 0 6
74342: PUSH
74343: LD_VAR 0 3
74347: DIFF
74348: ST_TO_ADDR
74349: GO 74315
74351: POP
74352: POP
// if not tmp then
74353: LD_VAR 0 6
74357: NOT
74358: IFFALSE 74362
// continue ;
74360: GO 73504
// if places then
74362: LD_VAR 0 5
74366: IFFALSE 74425
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74368: LD_ADDR_EXP 83
74372: PUSH
74373: LD_EXP 83
74377: PPUSH
74378: LD_VAR 0 2
74382: PPUSH
74383: LD_EXP 83
74387: PUSH
74388: LD_VAR 0 2
74392: ARRAY
74393: PUSH
74394: LD_VAR 0 6
74398: PUSH
74399: LD_INT 1
74401: ARRAY
74402: UNION
74403: PPUSH
74404: CALL_OW 1
74408: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
74409: LD_VAR 0 6
74413: PUSH
74414: LD_INT 1
74416: ARRAY
74417: PPUSH
74418: LD_INT 126
74420: PPUSH
74421: CALL_OW 109
// end ; end ;
74425: GO 73504
74427: POP
74428: POP
// end ;
74429: LD_VAR 0 1
74433: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
74434: LD_INT 0
74436: PPUSH
74437: PPUSH
74438: PPUSH
74439: PPUSH
74440: PPUSH
74441: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
74442: LD_VAR 0 1
74446: NOT
74447: PUSH
74448: LD_VAR 0 2
74452: NOT
74453: OR
74454: PUSH
74455: LD_VAR 0 3
74459: NOT
74460: OR
74461: PUSH
74462: LD_VAR 0 4
74466: PUSH
74467: LD_INT 1
74469: PUSH
74470: LD_INT 2
74472: PUSH
74473: LD_INT 3
74475: PUSH
74476: LD_INT 4
74478: PUSH
74479: LD_INT 5
74481: PUSH
74482: LD_INT 8
74484: PUSH
74485: LD_INT 9
74487: PUSH
74488: LD_INT 15
74490: PUSH
74491: LD_INT 16
74493: PUSH
74494: EMPTY
74495: LIST
74496: LIST
74497: LIST
74498: LIST
74499: LIST
74500: LIST
74501: LIST
74502: LIST
74503: LIST
74504: IN
74505: NOT
74506: OR
74507: IFFALSE 74511
// exit ;
74509: GO 75369
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74511: LD_ADDR_VAR 0 2
74515: PUSH
74516: LD_VAR 0 2
74520: PPUSH
74521: LD_INT 21
74523: PUSH
74524: LD_INT 3
74526: PUSH
74527: EMPTY
74528: LIST
74529: LIST
74530: PUSH
74531: LD_INT 24
74533: PUSH
74534: LD_INT 250
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: PUSH
74541: EMPTY
74542: LIST
74543: LIST
74544: PPUSH
74545: CALL_OW 72
74549: ST_TO_ADDR
// case class of 1 , 15 :
74550: LD_VAR 0 4
74554: PUSH
74555: LD_INT 1
74557: DOUBLE
74558: EQUAL
74559: IFTRUE 74569
74561: LD_INT 15
74563: DOUBLE
74564: EQUAL
74565: IFTRUE 74569
74567: GO 74654
74569: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74570: LD_ADDR_VAR 0 8
74574: PUSH
74575: LD_VAR 0 2
74579: PPUSH
74580: LD_INT 2
74582: PUSH
74583: LD_INT 30
74585: PUSH
74586: LD_INT 32
74588: PUSH
74589: EMPTY
74590: LIST
74591: LIST
74592: PUSH
74593: LD_INT 30
74595: PUSH
74596: LD_INT 31
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: LIST
74607: PPUSH
74608: CALL_OW 72
74612: PUSH
74613: LD_VAR 0 2
74617: PPUSH
74618: LD_INT 2
74620: PUSH
74621: LD_INT 30
74623: PUSH
74624: LD_INT 4
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: LD_INT 30
74633: PUSH
74634: LD_INT 5
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: LIST
74645: PPUSH
74646: CALL_OW 72
74650: ADD
74651: ST_TO_ADDR
74652: GO 74900
74654: LD_INT 2
74656: DOUBLE
74657: EQUAL
74658: IFTRUE 74668
74660: LD_INT 16
74662: DOUBLE
74663: EQUAL
74664: IFTRUE 74668
74666: GO 74714
74668: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74669: LD_ADDR_VAR 0 8
74673: PUSH
74674: LD_VAR 0 2
74678: PPUSH
74679: LD_INT 2
74681: PUSH
74682: LD_INT 30
74684: PUSH
74685: LD_INT 0
74687: PUSH
74688: EMPTY
74689: LIST
74690: LIST
74691: PUSH
74692: LD_INT 30
74694: PUSH
74695: LD_INT 1
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: LIST
74706: PPUSH
74707: CALL_OW 72
74711: ST_TO_ADDR
74712: GO 74900
74714: LD_INT 3
74716: DOUBLE
74717: EQUAL
74718: IFTRUE 74722
74720: GO 74768
74722: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74723: LD_ADDR_VAR 0 8
74727: PUSH
74728: LD_VAR 0 2
74732: PPUSH
74733: LD_INT 2
74735: PUSH
74736: LD_INT 30
74738: PUSH
74739: LD_INT 2
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: LD_INT 30
74748: PUSH
74749: LD_INT 3
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: LIST
74760: PPUSH
74761: CALL_OW 72
74765: ST_TO_ADDR
74766: GO 74900
74768: LD_INT 4
74770: DOUBLE
74771: EQUAL
74772: IFTRUE 74776
74774: GO 74833
74776: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74777: LD_ADDR_VAR 0 8
74781: PUSH
74782: LD_VAR 0 2
74786: PPUSH
74787: LD_INT 2
74789: PUSH
74790: LD_INT 30
74792: PUSH
74793: LD_INT 6
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PUSH
74800: LD_INT 30
74802: PUSH
74803: LD_INT 7
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 30
74812: PUSH
74813: LD_INT 8
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: PUSH
74820: EMPTY
74821: LIST
74822: LIST
74823: LIST
74824: LIST
74825: PPUSH
74826: CALL_OW 72
74830: ST_TO_ADDR
74831: GO 74900
74833: LD_INT 5
74835: DOUBLE
74836: EQUAL
74837: IFTRUE 74853
74839: LD_INT 8
74841: DOUBLE
74842: EQUAL
74843: IFTRUE 74853
74845: LD_INT 9
74847: DOUBLE
74848: EQUAL
74849: IFTRUE 74853
74851: GO 74899
74853: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74854: LD_ADDR_VAR 0 8
74858: PUSH
74859: LD_VAR 0 2
74863: PPUSH
74864: LD_INT 2
74866: PUSH
74867: LD_INT 30
74869: PUSH
74870: LD_INT 4
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 30
74879: PUSH
74880: LD_INT 5
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: LIST
74891: PPUSH
74892: CALL_OW 72
74896: ST_TO_ADDR
74897: GO 74900
74899: POP
// if not tmp then
74900: LD_VAR 0 8
74904: NOT
74905: IFFALSE 74909
// exit ;
74907: GO 75369
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74909: LD_VAR 0 4
74913: PUSH
74914: LD_INT 1
74916: PUSH
74917: LD_INT 15
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: IN
74924: PUSH
74925: LD_EXP 52
74929: PUSH
74930: LD_VAR 0 1
74934: ARRAY
74935: AND
74936: IFFALSE 75092
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74938: LD_ADDR_VAR 0 9
74942: PUSH
74943: LD_EXP 52
74947: PUSH
74948: LD_VAR 0 1
74952: ARRAY
74953: PUSH
74954: LD_INT 1
74956: ARRAY
74957: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74958: LD_VAR 0 9
74962: PUSH
74963: LD_EXP 53
74967: PUSH
74968: LD_VAR 0 1
74972: ARRAY
74973: IN
74974: NOT
74975: IFFALSE 75090
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74977: LD_ADDR_EXP 53
74981: PUSH
74982: LD_EXP 53
74986: PPUSH
74987: LD_VAR 0 1
74991: PUSH
74992: LD_EXP 53
74996: PUSH
74997: LD_VAR 0 1
75001: ARRAY
75002: PUSH
75003: LD_INT 1
75005: PLUS
75006: PUSH
75007: EMPTY
75008: LIST
75009: LIST
75010: PPUSH
75011: LD_VAR 0 9
75015: PPUSH
75016: CALL 14774 0 3
75020: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75021: LD_ADDR_EXP 52
75025: PUSH
75026: LD_EXP 52
75030: PPUSH
75031: LD_VAR 0 1
75035: PPUSH
75036: LD_EXP 52
75040: PUSH
75041: LD_VAR 0 1
75045: ARRAY
75046: PUSH
75047: LD_VAR 0 9
75051: DIFF
75052: PPUSH
75053: CALL_OW 1
75057: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75058: LD_VAR 0 3
75062: PPUSH
75063: LD_EXP 53
75067: PUSH
75068: LD_VAR 0 1
75072: ARRAY
75073: PUSH
75074: LD_EXP 53
75078: PUSH
75079: LD_VAR 0 1
75083: ARRAY
75084: ARRAY
75085: PPUSH
75086: CALL_OW 120
// end ; exit ;
75090: GO 75369
// end ; if tmp > 1 then
75092: LD_VAR 0 8
75096: PUSH
75097: LD_INT 1
75099: GREATER
75100: IFFALSE 75204
// for i = 2 to tmp do
75102: LD_ADDR_VAR 0 6
75106: PUSH
75107: DOUBLE
75108: LD_INT 2
75110: DEC
75111: ST_TO_ADDR
75112: LD_VAR 0 8
75116: PUSH
75117: FOR_TO
75118: IFFALSE 75202
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75120: LD_VAR 0 8
75124: PUSH
75125: LD_VAR 0 6
75129: ARRAY
75130: PPUSH
75131: CALL_OW 461
75135: PUSH
75136: LD_INT 6
75138: EQUAL
75139: IFFALSE 75200
// begin x := tmp [ i ] ;
75141: LD_ADDR_VAR 0 9
75145: PUSH
75146: LD_VAR 0 8
75150: PUSH
75151: LD_VAR 0 6
75155: ARRAY
75156: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75157: LD_ADDR_VAR 0 8
75161: PUSH
75162: LD_VAR 0 8
75166: PPUSH
75167: LD_VAR 0 6
75171: PPUSH
75172: CALL_OW 3
75176: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75177: LD_ADDR_VAR 0 8
75181: PUSH
75182: LD_VAR 0 8
75186: PPUSH
75187: LD_INT 1
75189: PPUSH
75190: LD_VAR 0 9
75194: PPUSH
75195: CALL_OW 2
75199: ST_TO_ADDR
// end ;
75200: GO 75117
75202: POP
75203: POP
// for i in tmp do
75204: LD_ADDR_VAR 0 6
75208: PUSH
75209: LD_VAR 0 8
75213: PUSH
75214: FOR_IN
75215: IFFALSE 75242
// begin if IsNotFull ( i ) then
75217: LD_VAR 0 6
75221: PPUSH
75222: CALL 11996 0 1
75226: IFFALSE 75240
// begin j := i ;
75228: LD_ADDR_VAR 0 7
75232: PUSH
75233: LD_VAR 0 6
75237: ST_TO_ADDR
// break ;
75238: GO 75242
// end ; end ;
75240: GO 75214
75242: POP
75243: POP
// if j then
75244: LD_VAR 0 7
75248: IFFALSE 75266
// ComEnterUnit ( unit , j ) else
75250: LD_VAR 0 3
75254: PPUSH
75255: LD_VAR 0 7
75259: PPUSH
75260: CALL_OW 120
75264: GO 75369
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75266: LD_ADDR_VAR 0 10
75270: PUSH
75271: LD_VAR 0 2
75275: PPUSH
75276: LD_INT 2
75278: PUSH
75279: LD_INT 30
75281: PUSH
75282: LD_INT 0
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: LD_INT 30
75291: PUSH
75292: LD_INT 1
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: EMPTY
75300: LIST
75301: LIST
75302: LIST
75303: PPUSH
75304: CALL_OW 72
75308: ST_TO_ADDR
// if depot then
75309: LD_VAR 0 10
75313: IFFALSE 75369
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75315: LD_ADDR_VAR 0 10
75319: PUSH
75320: LD_VAR 0 10
75324: PPUSH
75325: LD_VAR 0 3
75329: PPUSH
75330: CALL_OW 74
75334: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75335: LD_VAR 0 3
75339: PPUSH
75340: LD_VAR 0 10
75344: PPUSH
75345: CALL_OW 296
75349: PUSH
75350: LD_INT 10
75352: GREATER
75353: IFFALSE 75369
// ComStandNearbyBuilding ( unit , depot ) ;
75355: LD_VAR 0 3
75359: PPUSH
75360: LD_VAR 0 10
75364: PPUSH
75365: CALL 11376 0 2
// end ; end ; end ;
75369: LD_VAR 0 5
75373: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
75374: LD_INT 0
75376: PPUSH
75377: PPUSH
75378: PPUSH
75379: PPUSH
// if not mc_bases then
75380: LD_EXP 43
75384: NOT
75385: IFFALSE 75389
// exit ;
75387: GO 75628
// for i = 1 to mc_bases do
75389: LD_ADDR_VAR 0 2
75393: PUSH
75394: DOUBLE
75395: LD_INT 1
75397: DEC
75398: ST_TO_ADDR
75399: LD_EXP 43
75403: PUSH
75404: FOR_TO
75405: IFFALSE 75626
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
75407: LD_ADDR_VAR 0 4
75411: PUSH
75412: LD_EXP 43
75416: PUSH
75417: LD_VAR 0 2
75421: ARRAY
75422: PPUSH
75423: LD_INT 21
75425: PUSH
75426: LD_INT 1
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PPUSH
75433: CALL_OW 72
75437: PUSH
75438: LD_EXP 72
75442: PUSH
75443: LD_VAR 0 2
75447: ARRAY
75448: UNION
75449: ST_TO_ADDR
// if not tmp then
75450: LD_VAR 0 4
75454: NOT
75455: IFFALSE 75459
// continue ;
75457: GO 75404
// for j in tmp do
75459: LD_ADDR_VAR 0 3
75463: PUSH
75464: LD_VAR 0 4
75468: PUSH
75469: FOR_IN
75470: IFFALSE 75622
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75472: LD_VAR 0 3
75476: PPUSH
75477: CALL_OW 110
75481: NOT
75482: PUSH
75483: LD_VAR 0 3
75487: PPUSH
75488: CALL_OW 314
75492: NOT
75493: AND
75494: PUSH
75495: LD_VAR 0 3
75499: PPUSH
75500: CALL_OW 311
75504: NOT
75505: AND
75506: PUSH
75507: LD_VAR 0 3
75511: PPUSH
75512: CALL_OW 310
75516: NOT
75517: AND
75518: PUSH
75519: LD_VAR 0 3
75523: PUSH
75524: LD_EXP 46
75528: PUSH
75529: LD_VAR 0 2
75533: ARRAY
75534: PUSH
75535: LD_INT 1
75537: ARRAY
75538: IN
75539: NOT
75540: AND
75541: PUSH
75542: LD_VAR 0 3
75546: PUSH
75547: LD_EXP 46
75551: PUSH
75552: LD_VAR 0 2
75556: ARRAY
75557: PUSH
75558: LD_INT 2
75560: ARRAY
75561: IN
75562: NOT
75563: AND
75564: PUSH
75565: LD_VAR 0 3
75569: PUSH
75570: LD_EXP 55
75574: PUSH
75575: LD_VAR 0 2
75579: ARRAY
75580: IN
75581: NOT
75582: AND
75583: IFFALSE 75620
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75585: LD_VAR 0 2
75589: PPUSH
75590: LD_EXP 43
75594: PUSH
75595: LD_VAR 0 2
75599: ARRAY
75600: PPUSH
75601: LD_VAR 0 3
75605: PPUSH
75606: LD_VAR 0 3
75610: PPUSH
75611: CALL_OW 257
75615: PPUSH
75616: CALL 74434 0 4
// end ;
75620: GO 75469
75622: POP
75623: POP
// end ;
75624: GO 75404
75626: POP
75627: POP
// end ;
75628: LD_VAR 0 1
75632: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
75633: LD_INT 0
75635: PPUSH
75636: PPUSH
75637: PPUSH
75638: PPUSH
75639: PPUSH
75640: PPUSH
// if not mc_bases [ base ] then
75641: LD_EXP 43
75645: PUSH
75646: LD_VAR 0 1
75650: ARRAY
75651: NOT
75652: IFFALSE 75656
// exit ;
75654: GO 75857
// tmp := [ ] ;
75656: LD_ADDR_VAR 0 6
75660: PUSH
75661: EMPTY
75662: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75663: LD_ADDR_VAR 0 7
75667: PUSH
75668: LD_VAR 0 3
75672: PPUSH
75673: LD_INT 0
75675: PPUSH
75676: CALL_OW 517
75680: ST_TO_ADDR
// if not list then
75681: LD_VAR 0 7
75685: NOT
75686: IFFALSE 75690
// exit ;
75688: GO 75857
// c := Count ( list [ 1 ] ) ;
75690: LD_ADDR_VAR 0 9
75694: PUSH
75695: LD_VAR 0 7
75699: PUSH
75700: LD_INT 1
75702: ARRAY
75703: PPUSH
75704: CALL 11914 0 1
75708: ST_TO_ADDR
// if amount > c then
75709: LD_VAR 0 2
75713: PUSH
75714: LD_VAR 0 9
75718: GREATER
75719: IFFALSE 75731
// amount := c ;
75721: LD_ADDR_VAR 0 2
75725: PUSH
75726: LD_VAR 0 9
75730: ST_TO_ADDR
// for i := 1 to amount do
75731: LD_ADDR_VAR 0 5
75735: PUSH
75736: DOUBLE
75737: LD_INT 1
75739: DEC
75740: ST_TO_ADDR
75741: LD_VAR 0 2
75745: PUSH
75746: FOR_TO
75747: IFFALSE 75805
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
75749: LD_ADDR_VAR 0 6
75753: PUSH
75754: LD_VAR 0 6
75758: PPUSH
75759: LD_VAR 0 5
75763: PPUSH
75764: LD_VAR 0 7
75768: PUSH
75769: LD_INT 1
75771: ARRAY
75772: PUSH
75773: LD_VAR 0 5
75777: ARRAY
75778: PUSH
75779: LD_VAR 0 7
75783: PUSH
75784: LD_INT 2
75786: ARRAY
75787: PUSH
75788: LD_VAR 0 5
75792: ARRAY
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PPUSH
75798: CALL_OW 1
75802: ST_TO_ADDR
75803: GO 75746
75805: POP
75806: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75807: LD_ADDR_EXP 56
75811: PUSH
75812: LD_EXP 56
75816: PPUSH
75817: LD_VAR 0 1
75821: PPUSH
75822: LD_VAR 0 6
75826: PPUSH
75827: CALL_OW 1
75831: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75832: LD_ADDR_EXP 58
75836: PUSH
75837: LD_EXP 58
75841: PPUSH
75842: LD_VAR 0 1
75846: PPUSH
75847: LD_VAR 0 3
75851: PPUSH
75852: CALL_OW 1
75856: ST_TO_ADDR
// end ;
75857: LD_VAR 0 4
75861: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75862: LD_INT 0
75864: PPUSH
// if not mc_bases [ base ] then
75865: LD_EXP 43
75869: PUSH
75870: LD_VAR 0 1
75874: ARRAY
75875: NOT
75876: IFFALSE 75880
// exit ;
75878: GO 75905
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75880: LD_ADDR_EXP 48
75884: PUSH
75885: LD_EXP 48
75889: PPUSH
75890: LD_VAR 0 1
75894: PPUSH
75895: LD_VAR 0 2
75899: PPUSH
75900: CALL_OW 1
75904: ST_TO_ADDR
// end ;
75905: LD_VAR 0 3
75909: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75910: LD_INT 0
75912: PPUSH
// if not mc_bases [ base ] then
75913: LD_EXP 43
75917: PUSH
75918: LD_VAR 0 1
75922: ARRAY
75923: NOT
75924: IFFALSE 75928
// exit ;
75926: GO 75965
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75928: LD_ADDR_EXP 48
75932: PUSH
75933: LD_EXP 48
75937: PPUSH
75938: LD_VAR 0 1
75942: PPUSH
75943: LD_EXP 48
75947: PUSH
75948: LD_VAR 0 1
75952: ARRAY
75953: PUSH
75954: LD_VAR 0 2
75958: UNION
75959: PPUSH
75960: CALL_OW 1
75964: ST_TO_ADDR
// end ;
75965: LD_VAR 0 3
75969: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75970: LD_INT 0
75972: PPUSH
// if not mc_bases [ base ] then
75973: LD_EXP 43
75977: PUSH
75978: LD_VAR 0 1
75982: ARRAY
75983: NOT
75984: IFFALSE 75988
// exit ;
75986: GO 76013
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75988: LD_ADDR_EXP 64
75992: PUSH
75993: LD_EXP 64
75997: PPUSH
75998: LD_VAR 0 1
76002: PPUSH
76003: LD_VAR 0 2
76007: PPUSH
76008: CALL_OW 1
76012: ST_TO_ADDR
// end ;
76013: LD_VAR 0 3
76017: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76018: LD_INT 0
76020: PPUSH
// if not mc_bases [ base ] then
76021: LD_EXP 43
76025: PUSH
76026: LD_VAR 0 1
76030: ARRAY
76031: NOT
76032: IFFALSE 76036
// exit ;
76034: GO 76073
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76036: LD_ADDR_EXP 64
76040: PUSH
76041: LD_EXP 64
76045: PPUSH
76046: LD_VAR 0 1
76050: PPUSH
76051: LD_EXP 64
76055: PUSH
76056: LD_VAR 0 1
76060: ARRAY
76061: PUSH
76062: LD_VAR 0 2
76066: ADD
76067: PPUSH
76068: CALL_OW 1
76072: ST_TO_ADDR
// end ;
76073: LD_VAR 0 3
76077: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76078: LD_INT 0
76080: PPUSH
// if not mc_bases [ base ] then
76081: LD_EXP 43
76085: PUSH
76086: LD_VAR 0 1
76090: ARRAY
76091: NOT
76092: IFFALSE 76096
// exit ;
76094: GO 76150
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76096: LD_ADDR_EXP 65
76100: PUSH
76101: LD_EXP 65
76105: PPUSH
76106: LD_VAR 0 1
76110: PPUSH
76111: LD_VAR 0 2
76115: PPUSH
76116: CALL_OW 1
76120: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76121: LD_ADDR_EXP 54
76125: PUSH
76126: LD_EXP 54
76130: PPUSH
76131: LD_VAR 0 1
76135: PPUSH
76136: LD_VAR 0 2
76140: PUSH
76141: LD_INT 0
76143: PLUS
76144: PPUSH
76145: CALL_OW 1
76149: ST_TO_ADDR
// end ;
76150: LD_VAR 0 3
76154: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76155: LD_INT 0
76157: PPUSH
// if not mc_bases [ base ] then
76158: LD_EXP 43
76162: PUSH
76163: LD_VAR 0 1
76167: ARRAY
76168: NOT
76169: IFFALSE 76173
// exit ;
76171: GO 76198
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76173: LD_ADDR_EXP 54
76177: PUSH
76178: LD_EXP 54
76182: PPUSH
76183: LD_VAR 0 1
76187: PPUSH
76188: LD_VAR 0 2
76192: PPUSH
76193: CALL_OW 1
76197: ST_TO_ADDR
// end ;
76198: LD_VAR 0 3
76202: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76203: LD_INT 0
76205: PPUSH
76206: PPUSH
76207: PPUSH
76208: PPUSH
// if not mc_bases [ base ] then
76209: LD_EXP 43
76213: PUSH
76214: LD_VAR 0 1
76218: ARRAY
76219: NOT
76220: IFFALSE 76224
// exit ;
76222: GO 76289
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76224: LD_ADDR_EXP 63
76228: PUSH
76229: LD_EXP 63
76233: PPUSH
76234: LD_VAR 0 1
76238: PUSH
76239: LD_EXP 63
76243: PUSH
76244: LD_VAR 0 1
76248: ARRAY
76249: PUSH
76250: LD_INT 1
76252: PLUS
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: PPUSH
76258: LD_VAR 0 1
76262: PUSH
76263: LD_VAR 0 2
76267: PUSH
76268: LD_VAR 0 3
76272: PUSH
76273: LD_VAR 0 4
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: LIST
76282: LIST
76283: PPUSH
76284: CALL 14774 0 3
76288: ST_TO_ADDR
// end ;
76289: LD_VAR 0 5
76293: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76294: LD_INT 0
76296: PPUSH
// if not mc_bases [ base ] then
76297: LD_EXP 43
76301: PUSH
76302: LD_VAR 0 1
76306: ARRAY
76307: NOT
76308: IFFALSE 76312
// exit ;
76310: GO 76337
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76312: LD_ADDR_EXP 80
76316: PUSH
76317: LD_EXP 80
76321: PPUSH
76322: LD_VAR 0 1
76326: PPUSH
76327: LD_VAR 0 2
76331: PPUSH
76332: CALL_OW 1
76336: ST_TO_ADDR
// end ;
76337: LD_VAR 0 3
76341: RET
// export function MC_GetMinesField ( base ) ; begin
76342: LD_INT 0
76344: PPUSH
// result := mc_mines [ base ] ;
76345: LD_ADDR_VAR 0 2
76349: PUSH
76350: LD_EXP 56
76354: PUSH
76355: LD_VAR 0 1
76359: ARRAY
76360: ST_TO_ADDR
// end ;
76361: LD_VAR 0 2
76365: RET
// export function MC_GetProduceList ( base ) ; begin
76366: LD_INT 0
76368: PPUSH
// result := mc_produce [ base ] ;
76369: LD_ADDR_VAR 0 2
76373: PUSH
76374: LD_EXP 64
76378: PUSH
76379: LD_VAR 0 1
76383: ARRAY
76384: ST_TO_ADDR
// end ;
76385: LD_VAR 0 2
76389: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
76390: LD_INT 0
76392: PPUSH
76393: PPUSH
// if not mc_bases then
76394: LD_EXP 43
76398: NOT
76399: IFFALSE 76403
// exit ;
76401: GO 76468
// if mc_bases [ base ] then
76403: LD_EXP 43
76407: PUSH
76408: LD_VAR 0 1
76412: ARRAY
76413: IFFALSE 76468
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76415: LD_ADDR_VAR 0 3
76419: PUSH
76420: LD_EXP 43
76424: PUSH
76425: LD_VAR 0 1
76429: ARRAY
76430: PPUSH
76431: LD_INT 30
76433: PUSH
76434: LD_VAR 0 2
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PPUSH
76443: CALL_OW 72
76447: ST_TO_ADDR
// if result then
76448: LD_VAR 0 3
76452: IFFALSE 76468
// result := result [ 1 ] ;
76454: LD_ADDR_VAR 0 3
76458: PUSH
76459: LD_VAR 0 3
76463: PUSH
76464: LD_INT 1
76466: ARRAY
76467: ST_TO_ADDR
// end ; end ;
76468: LD_VAR 0 3
76472: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76473: LD_INT 0
76475: PPUSH
76476: PPUSH
// if not mc_bases then
76477: LD_EXP 43
76481: NOT
76482: IFFALSE 76486
// exit ;
76484: GO 76531
// if mc_bases [ base ] then
76486: LD_EXP 43
76490: PUSH
76491: LD_VAR 0 1
76495: ARRAY
76496: IFFALSE 76531
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76498: LD_ADDR_VAR 0 3
76502: PUSH
76503: LD_EXP 43
76507: PUSH
76508: LD_VAR 0 1
76512: ARRAY
76513: PPUSH
76514: LD_INT 30
76516: PUSH
76517: LD_VAR 0 2
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PPUSH
76526: CALL_OW 72
76530: ST_TO_ADDR
// end ;
76531: LD_VAR 0 3
76535: RET
// export function MC_SetTame ( base , area ) ; begin
76536: LD_INT 0
76538: PPUSH
// if not mc_bases or not base then
76539: LD_EXP 43
76543: NOT
76544: PUSH
76545: LD_VAR 0 1
76549: NOT
76550: OR
76551: IFFALSE 76555
// exit ;
76553: GO 76580
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76555: LD_ADDR_EXP 71
76559: PUSH
76560: LD_EXP 71
76564: PPUSH
76565: LD_VAR 0 1
76569: PPUSH
76570: LD_VAR 0 2
76574: PPUSH
76575: CALL_OW 1
76579: ST_TO_ADDR
// end ;
76580: LD_VAR 0 3
76584: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76585: LD_INT 0
76587: PPUSH
76588: PPUSH
// if not mc_bases or not base then
76589: LD_EXP 43
76593: NOT
76594: PUSH
76595: LD_VAR 0 1
76599: NOT
76600: OR
76601: IFFALSE 76605
// exit ;
76603: GO 76707
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76605: LD_ADDR_VAR 0 4
76609: PUSH
76610: LD_EXP 43
76614: PUSH
76615: LD_VAR 0 1
76619: ARRAY
76620: PPUSH
76621: LD_INT 30
76623: PUSH
76624: LD_VAR 0 2
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PPUSH
76633: CALL_OW 72
76637: ST_TO_ADDR
// if not tmp then
76638: LD_VAR 0 4
76642: NOT
76643: IFFALSE 76647
// exit ;
76645: GO 76707
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76647: LD_ADDR_EXP 75
76651: PUSH
76652: LD_EXP 75
76656: PPUSH
76657: LD_VAR 0 1
76661: PPUSH
76662: LD_EXP 75
76666: PUSH
76667: LD_VAR 0 1
76671: ARRAY
76672: PPUSH
76673: LD_EXP 75
76677: PUSH
76678: LD_VAR 0 1
76682: ARRAY
76683: PUSH
76684: LD_INT 1
76686: PLUS
76687: PPUSH
76688: LD_VAR 0 4
76692: PUSH
76693: LD_INT 1
76695: ARRAY
76696: PPUSH
76697: CALL_OW 2
76701: PPUSH
76702: CALL_OW 1
76706: ST_TO_ADDR
// end ;
76707: LD_VAR 0 3
76711: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76712: LD_INT 0
76714: PPUSH
76715: PPUSH
// if not mc_bases or not base or not kinds then
76716: LD_EXP 43
76720: NOT
76721: PUSH
76722: LD_VAR 0 1
76726: NOT
76727: OR
76728: PUSH
76729: LD_VAR 0 2
76733: NOT
76734: OR
76735: IFFALSE 76739
// exit ;
76737: GO 76800
// for i in kinds do
76739: LD_ADDR_VAR 0 4
76743: PUSH
76744: LD_VAR 0 2
76748: PUSH
76749: FOR_IN
76750: IFFALSE 76798
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76752: LD_ADDR_EXP 77
76756: PUSH
76757: LD_EXP 77
76761: PPUSH
76762: LD_VAR 0 1
76766: PUSH
76767: LD_EXP 77
76771: PUSH
76772: LD_VAR 0 1
76776: ARRAY
76777: PUSH
76778: LD_INT 1
76780: PLUS
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PPUSH
76786: LD_VAR 0 4
76790: PPUSH
76791: CALL 14774 0 3
76795: ST_TO_ADDR
76796: GO 76749
76798: POP
76799: POP
// end ;
76800: LD_VAR 0 3
76804: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76805: LD_INT 0
76807: PPUSH
// if not mc_bases or not base or not areas then
76808: LD_EXP 43
76812: NOT
76813: PUSH
76814: LD_VAR 0 1
76818: NOT
76819: OR
76820: PUSH
76821: LD_VAR 0 2
76825: NOT
76826: OR
76827: IFFALSE 76831
// exit ;
76829: GO 76856
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76831: LD_ADDR_EXP 61
76835: PUSH
76836: LD_EXP 61
76840: PPUSH
76841: LD_VAR 0 1
76845: PPUSH
76846: LD_VAR 0 2
76850: PPUSH
76851: CALL_OW 1
76855: ST_TO_ADDR
// end ;
76856: LD_VAR 0 3
76860: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76861: LD_INT 0
76863: PPUSH
// if not mc_bases or not base or not teleports_exit then
76864: LD_EXP 43
76868: NOT
76869: PUSH
76870: LD_VAR 0 1
76874: NOT
76875: OR
76876: PUSH
76877: LD_VAR 0 2
76881: NOT
76882: OR
76883: IFFALSE 76887
// exit ;
76885: GO 76912
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76887: LD_ADDR_EXP 78
76891: PUSH
76892: LD_EXP 78
76896: PPUSH
76897: LD_VAR 0 1
76901: PPUSH
76902: LD_VAR 0 2
76906: PPUSH
76907: CALL_OW 1
76911: ST_TO_ADDR
// end ;
76912: LD_VAR 0 3
76916: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76917: LD_INT 0
76919: PPUSH
76920: PPUSH
76921: PPUSH
// if not mc_bases or not base or not ext_list then
76922: LD_EXP 43
76926: NOT
76927: PUSH
76928: LD_VAR 0 1
76932: NOT
76933: OR
76934: PUSH
76935: LD_VAR 0 5
76939: NOT
76940: OR
76941: IFFALSE 76945
// exit ;
76943: GO 77118
// tmp := GetFacExtXYD ( x , y , d ) ;
76945: LD_ADDR_VAR 0 8
76949: PUSH
76950: LD_VAR 0 2
76954: PPUSH
76955: LD_VAR 0 3
76959: PPUSH
76960: LD_VAR 0 4
76964: PPUSH
76965: CALL 45148 0 3
76969: ST_TO_ADDR
// if not tmp then
76970: LD_VAR 0 8
76974: NOT
76975: IFFALSE 76979
// exit ;
76977: GO 77118
// for i in tmp do
76979: LD_ADDR_VAR 0 7
76983: PUSH
76984: LD_VAR 0 8
76988: PUSH
76989: FOR_IN
76990: IFFALSE 77116
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76992: LD_ADDR_EXP 48
76996: PUSH
76997: LD_EXP 48
77001: PPUSH
77002: LD_VAR 0 1
77006: PPUSH
77007: LD_EXP 48
77011: PUSH
77012: LD_VAR 0 1
77016: ARRAY
77017: PPUSH
77018: LD_EXP 48
77022: PUSH
77023: LD_VAR 0 1
77027: ARRAY
77028: PUSH
77029: LD_INT 1
77031: PLUS
77032: PPUSH
77033: LD_VAR 0 5
77037: PUSH
77038: LD_INT 1
77040: ARRAY
77041: PUSH
77042: LD_VAR 0 7
77046: PUSH
77047: LD_INT 1
77049: ARRAY
77050: PUSH
77051: LD_VAR 0 7
77055: PUSH
77056: LD_INT 2
77058: ARRAY
77059: PUSH
77060: LD_VAR 0 7
77064: PUSH
77065: LD_INT 3
77067: ARRAY
77068: PUSH
77069: EMPTY
77070: LIST
77071: LIST
77072: LIST
77073: LIST
77074: PPUSH
77075: CALL_OW 2
77079: PPUSH
77080: CALL_OW 1
77084: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77085: LD_ADDR_VAR 0 5
77089: PUSH
77090: LD_VAR 0 5
77094: PPUSH
77095: LD_INT 1
77097: PPUSH
77098: CALL_OW 3
77102: ST_TO_ADDR
// if not ext_list then
77103: LD_VAR 0 5
77107: NOT
77108: IFFALSE 77114
// exit ;
77110: POP
77111: POP
77112: GO 77118
// end ;
77114: GO 76989
77116: POP
77117: POP
// end ;
77118: LD_VAR 0 6
77122: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77123: LD_INT 0
77125: PPUSH
// if not mc_bases or not base or not weapon_list then
77126: LD_EXP 43
77130: NOT
77131: PUSH
77132: LD_VAR 0 1
77136: NOT
77137: OR
77138: PUSH
77139: LD_VAR 0 2
77143: NOT
77144: OR
77145: IFFALSE 77149
// exit ;
77147: GO 77174
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77149: LD_ADDR_EXP 82
77153: PUSH
77154: LD_EXP 82
77158: PPUSH
77159: LD_VAR 0 1
77163: PPUSH
77164: LD_VAR 0 2
77168: PPUSH
77169: CALL_OW 1
77173: ST_TO_ADDR
// end ;
77174: LD_VAR 0 3
77178: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77179: LD_INT 0
77181: PPUSH
// if not mc_bases or not base or not tech_list then
77182: LD_EXP 43
77186: NOT
77187: PUSH
77188: LD_VAR 0 1
77192: NOT
77193: OR
77194: PUSH
77195: LD_VAR 0 2
77199: NOT
77200: OR
77201: IFFALSE 77205
// exit ;
77203: GO 77230
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77205: LD_ADDR_EXP 70
77209: PUSH
77210: LD_EXP 70
77214: PPUSH
77215: LD_VAR 0 1
77219: PPUSH
77220: LD_VAR 0 2
77224: PPUSH
77225: CALL_OW 1
77229: ST_TO_ADDR
// end ;
77230: LD_VAR 0 3
77234: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77235: LD_INT 0
77237: PPUSH
// if not mc_bases or not parking_area or not base then
77238: LD_EXP 43
77242: NOT
77243: PUSH
77244: LD_VAR 0 2
77248: NOT
77249: OR
77250: PUSH
77251: LD_VAR 0 1
77255: NOT
77256: OR
77257: IFFALSE 77261
// exit ;
77259: GO 77286
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77261: LD_ADDR_EXP 67
77265: PUSH
77266: LD_EXP 67
77270: PPUSH
77271: LD_VAR 0 1
77275: PPUSH
77276: LD_VAR 0 2
77280: PPUSH
77281: CALL_OW 1
77285: ST_TO_ADDR
// end ;
77286: LD_VAR 0 3
77290: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77291: LD_INT 0
77293: PPUSH
// if not mc_bases or not base or not scan_area then
77294: LD_EXP 43
77298: NOT
77299: PUSH
77300: LD_VAR 0 1
77304: NOT
77305: OR
77306: PUSH
77307: LD_VAR 0 2
77311: NOT
77312: OR
77313: IFFALSE 77317
// exit ;
77315: GO 77342
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77317: LD_ADDR_EXP 68
77321: PUSH
77322: LD_EXP 68
77326: PPUSH
77327: LD_VAR 0 1
77331: PPUSH
77332: LD_VAR 0 2
77336: PPUSH
77337: CALL_OW 1
77341: ST_TO_ADDR
// end ;
77342: LD_VAR 0 3
77346: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77347: LD_INT 0
77349: PPUSH
77350: PPUSH
// if not mc_bases or not base then
77351: LD_EXP 43
77355: NOT
77356: PUSH
77357: LD_VAR 0 1
77361: NOT
77362: OR
77363: IFFALSE 77367
// exit ;
77365: GO 77431
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
77367: LD_ADDR_VAR 0 3
77371: PUSH
77372: LD_INT 1
77374: PUSH
77375: LD_INT 2
77377: PUSH
77378: LD_INT 3
77380: PUSH
77381: LD_INT 4
77383: PUSH
77384: LD_INT 11
77386: PUSH
77387: EMPTY
77388: LIST
77389: LIST
77390: LIST
77391: LIST
77392: LIST
77393: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
77394: LD_ADDR_EXP 70
77398: PUSH
77399: LD_EXP 70
77403: PPUSH
77404: LD_VAR 0 1
77408: PPUSH
77409: LD_EXP 70
77413: PUSH
77414: LD_VAR 0 1
77418: ARRAY
77419: PUSH
77420: LD_VAR 0 3
77424: DIFF
77425: PPUSH
77426: CALL_OW 1
77430: ST_TO_ADDR
// end ;
77431: LD_VAR 0 2
77435: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
77436: LD_INT 0
77438: PPUSH
// result := mc_vehicles [ base ] ;
77439: LD_ADDR_VAR 0 3
77443: PUSH
77444: LD_EXP 62
77448: PUSH
77449: LD_VAR 0 1
77453: ARRAY
77454: ST_TO_ADDR
// if onlyCombat then
77455: LD_VAR 0 2
77459: IFFALSE 77631
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
77461: LD_ADDR_VAR 0 3
77465: PUSH
77466: LD_VAR 0 3
77470: PUSH
77471: LD_VAR 0 3
77475: PPUSH
77476: LD_INT 2
77478: PUSH
77479: LD_INT 34
77481: PUSH
77482: LD_INT 12
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 34
77491: PUSH
77492: LD_INT 51
77494: PUSH
77495: EMPTY
77496: LIST
77497: LIST
77498: PUSH
77499: LD_INT 34
77501: PUSH
77502: LD_INT 89
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 34
77511: PUSH
77512: LD_INT 32
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 34
77521: PUSH
77522: LD_INT 13
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: LD_INT 34
77531: PUSH
77532: LD_INT 52
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 34
77541: PUSH
77542: LD_INT 88
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 34
77551: PUSH
77552: LD_INT 14
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 34
77561: PUSH
77562: LD_INT 53
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 34
77571: PUSH
77572: LD_INT 98
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PUSH
77579: LD_INT 34
77581: PUSH
77582: LD_INT 31
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PUSH
77589: LD_INT 34
77591: PUSH
77592: LD_INT 48
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 34
77601: PUSH
77602: LD_INT 8
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: LIST
77613: LIST
77614: LIST
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: LIST
77621: LIST
77622: LIST
77623: LIST
77624: PPUSH
77625: CALL_OW 72
77629: DIFF
77630: ST_TO_ADDR
// end ; end_of_file
77631: LD_VAR 0 3
77635: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77636: LD_INT 0
77638: PPUSH
77639: PPUSH
77640: PPUSH
// if not mc_bases or not skirmish then
77641: LD_EXP 43
77645: NOT
77646: PUSH
77647: LD_EXP 41
77651: NOT
77652: OR
77653: IFFALSE 77657
// exit ;
77655: GO 77822
// for i = 1 to mc_bases do
77657: LD_ADDR_VAR 0 4
77661: PUSH
77662: DOUBLE
77663: LD_INT 1
77665: DEC
77666: ST_TO_ADDR
77667: LD_EXP 43
77671: PUSH
77672: FOR_TO
77673: IFFALSE 77820
// begin if sci in mc_bases [ i ] then
77675: LD_VAR 0 2
77679: PUSH
77680: LD_EXP 43
77684: PUSH
77685: LD_VAR 0 4
77689: ARRAY
77690: IN
77691: IFFALSE 77818
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77693: LD_ADDR_EXP 72
77697: PUSH
77698: LD_EXP 72
77702: PPUSH
77703: LD_VAR 0 4
77707: PUSH
77708: LD_EXP 72
77712: PUSH
77713: LD_VAR 0 4
77717: ARRAY
77718: PUSH
77719: LD_INT 1
77721: PLUS
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PPUSH
77727: LD_VAR 0 1
77731: PPUSH
77732: CALL 14774 0 3
77736: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77737: LD_ADDR_VAR 0 5
77741: PUSH
77742: LD_EXP 43
77746: PUSH
77747: LD_VAR 0 4
77751: ARRAY
77752: PPUSH
77753: LD_INT 2
77755: PUSH
77756: LD_INT 30
77758: PUSH
77759: LD_INT 0
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 30
77768: PUSH
77769: LD_INT 1
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: LIST
77780: PPUSH
77781: CALL_OW 72
77785: PPUSH
77786: LD_VAR 0 1
77790: PPUSH
77791: CALL_OW 74
77795: ST_TO_ADDR
// if tmp then
77796: LD_VAR 0 5
77800: IFFALSE 77816
// ComStandNearbyBuilding ( ape , tmp ) ;
77802: LD_VAR 0 1
77806: PPUSH
77807: LD_VAR 0 5
77811: PPUSH
77812: CALL 11376 0 2
// break ;
77816: GO 77820
// end ; end ;
77818: GO 77672
77820: POP
77821: POP
// end ;
77822: LD_VAR 0 3
77826: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77827: LD_INT 0
77829: PPUSH
77830: PPUSH
77831: PPUSH
// if not mc_bases or not skirmish then
77832: LD_EXP 43
77836: NOT
77837: PUSH
77838: LD_EXP 41
77842: NOT
77843: OR
77844: IFFALSE 77848
// exit ;
77846: GO 77937
// for i = 1 to mc_bases do
77848: LD_ADDR_VAR 0 4
77852: PUSH
77853: DOUBLE
77854: LD_INT 1
77856: DEC
77857: ST_TO_ADDR
77858: LD_EXP 43
77862: PUSH
77863: FOR_TO
77864: IFFALSE 77935
// begin if building in mc_busy_turret_list [ i ] then
77866: LD_VAR 0 1
77870: PUSH
77871: LD_EXP 53
77875: PUSH
77876: LD_VAR 0 4
77880: ARRAY
77881: IN
77882: IFFALSE 77933
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77884: LD_ADDR_VAR 0 5
77888: PUSH
77889: LD_EXP 53
77893: PUSH
77894: LD_VAR 0 4
77898: ARRAY
77899: PUSH
77900: LD_VAR 0 1
77904: DIFF
77905: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77906: LD_ADDR_EXP 53
77910: PUSH
77911: LD_EXP 53
77915: PPUSH
77916: LD_VAR 0 4
77920: PPUSH
77921: LD_VAR 0 5
77925: PPUSH
77926: CALL_OW 1
77930: ST_TO_ADDR
// break ;
77931: GO 77935
// end ; end ;
77933: GO 77863
77935: POP
77936: POP
// end ;
77937: LD_VAR 0 3
77941: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77942: LD_INT 0
77944: PPUSH
77945: PPUSH
77946: PPUSH
// if not mc_bases or not skirmish then
77947: LD_EXP 43
77951: NOT
77952: PUSH
77953: LD_EXP 41
77957: NOT
77958: OR
77959: IFFALSE 77963
// exit ;
77961: GO 78162
// for i = 1 to mc_bases do
77963: LD_ADDR_VAR 0 5
77967: PUSH
77968: DOUBLE
77969: LD_INT 1
77971: DEC
77972: ST_TO_ADDR
77973: LD_EXP 43
77977: PUSH
77978: FOR_TO
77979: IFFALSE 78160
// if building in mc_bases [ i ] then
77981: LD_VAR 0 1
77985: PUSH
77986: LD_EXP 43
77990: PUSH
77991: LD_VAR 0 5
77995: ARRAY
77996: IN
77997: IFFALSE 78158
// begin tmp := mc_bases [ i ] diff building ;
77999: LD_ADDR_VAR 0 6
78003: PUSH
78004: LD_EXP 43
78008: PUSH
78009: LD_VAR 0 5
78013: ARRAY
78014: PUSH
78015: LD_VAR 0 1
78019: DIFF
78020: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78021: LD_ADDR_EXP 43
78025: PUSH
78026: LD_EXP 43
78030: PPUSH
78031: LD_VAR 0 5
78035: PPUSH
78036: LD_VAR 0 6
78040: PPUSH
78041: CALL_OW 1
78045: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78046: LD_VAR 0 1
78050: PUSH
78051: LD_EXP 51
78055: PUSH
78056: LD_VAR 0 5
78060: ARRAY
78061: IN
78062: IFFALSE 78101
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78064: LD_ADDR_EXP 51
78068: PUSH
78069: LD_EXP 51
78073: PPUSH
78074: LD_VAR 0 5
78078: PPUSH
78079: LD_EXP 51
78083: PUSH
78084: LD_VAR 0 5
78088: ARRAY
78089: PUSH
78090: LD_VAR 0 1
78094: DIFF
78095: PPUSH
78096: CALL_OW 1
78100: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78101: LD_VAR 0 1
78105: PUSH
78106: LD_EXP 52
78110: PUSH
78111: LD_VAR 0 5
78115: ARRAY
78116: IN
78117: IFFALSE 78156
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78119: LD_ADDR_EXP 52
78123: PUSH
78124: LD_EXP 52
78128: PPUSH
78129: LD_VAR 0 5
78133: PPUSH
78134: LD_EXP 52
78138: PUSH
78139: LD_VAR 0 5
78143: ARRAY
78144: PUSH
78145: LD_VAR 0 1
78149: DIFF
78150: PPUSH
78151: CALL_OW 1
78155: ST_TO_ADDR
// break ;
78156: GO 78160
// end ;
78158: GO 77978
78160: POP
78161: POP
// end ;
78162: LD_VAR 0 4
78166: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78167: LD_INT 0
78169: PPUSH
78170: PPUSH
78171: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78172: LD_EXP 43
78176: NOT
78177: PUSH
78178: LD_EXP 41
78182: NOT
78183: OR
78184: PUSH
78185: LD_VAR 0 3
78189: PUSH
78190: LD_EXP 69
78194: IN
78195: NOT
78196: OR
78197: IFFALSE 78201
// exit ;
78199: GO 78324
// for i = 1 to mc_vehicles do
78201: LD_ADDR_VAR 0 6
78205: PUSH
78206: DOUBLE
78207: LD_INT 1
78209: DEC
78210: ST_TO_ADDR
78211: LD_EXP 62
78215: PUSH
78216: FOR_TO
78217: IFFALSE 78322
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78219: LD_VAR 0 2
78223: PUSH
78224: LD_EXP 62
78228: PUSH
78229: LD_VAR 0 6
78233: ARRAY
78234: IN
78235: PUSH
78236: LD_VAR 0 1
78240: PUSH
78241: LD_EXP 62
78245: PUSH
78246: LD_VAR 0 6
78250: ARRAY
78251: IN
78252: OR
78253: IFFALSE 78320
// begin tmp := mc_vehicles [ i ] diff old ;
78255: LD_ADDR_VAR 0 7
78259: PUSH
78260: LD_EXP 62
78264: PUSH
78265: LD_VAR 0 6
78269: ARRAY
78270: PUSH
78271: LD_VAR 0 2
78275: DIFF
78276: ST_TO_ADDR
// tmp := tmp diff new ;
78277: LD_ADDR_VAR 0 7
78281: PUSH
78282: LD_VAR 0 7
78286: PUSH
78287: LD_VAR 0 1
78291: DIFF
78292: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78293: LD_ADDR_EXP 62
78297: PUSH
78298: LD_EXP 62
78302: PPUSH
78303: LD_VAR 0 6
78307: PPUSH
78308: LD_VAR 0 7
78312: PPUSH
78313: CALL_OW 1
78317: ST_TO_ADDR
// break ;
78318: GO 78322
// end ;
78320: GO 78216
78322: POP
78323: POP
// end ;
78324: LD_VAR 0 5
78328: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78329: LD_INT 0
78331: PPUSH
78332: PPUSH
78333: PPUSH
78334: PPUSH
// if not mc_bases or not skirmish then
78335: LD_EXP 43
78339: NOT
78340: PUSH
78341: LD_EXP 41
78345: NOT
78346: OR
78347: IFFALSE 78351
// exit ;
78349: GO 78771
// repeat wait ( 0 0$1 ) ;
78351: LD_INT 35
78353: PPUSH
78354: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
78358: LD_EXP 87
78362: NOT
78363: IFFALSE 78351
// mc_block_vehicle_constructed_thread := true ;
78365: LD_ADDR_EXP 87
78369: PUSH
78370: LD_INT 1
78372: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
78373: LD_ADDR_VAR 0 5
78377: PUSH
78378: LD_VAR 0 1
78382: PPUSH
78383: CALL_OW 255
78387: ST_TO_ADDR
// for i = 1 to mc_bases do
78388: LD_ADDR_VAR 0 4
78392: PUSH
78393: DOUBLE
78394: LD_INT 1
78396: DEC
78397: ST_TO_ADDR
78398: LD_EXP 43
78402: PUSH
78403: FOR_TO
78404: IFFALSE 78761
// begin if factory in mc_bases [ i ] then
78406: LD_VAR 0 2
78410: PUSH
78411: LD_EXP 43
78415: PUSH
78416: LD_VAR 0 4
78420: ARRAY
78421: IN
78422: IFFALSE 78759
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
78424: LD_EXP 65
78428: PUSH
78429: LD_VAR 0 4
78433: ARRAY
78434: PUSH
78435: LD_EXP 54
78439: PUSH
78440: LD_VAR 0 4
78444: ARRAY
78445: LESS
78446: PUSH
78447: LD_VAR 0 1
78451: PPUSH
78452: CALL_OW 264
78456: PUSH
78457: LD_INT 31
78459: PUSH
78460: LD_INT 32
78462: PUSH
78463: LD_INT 51
78465: PUSH
78466: LD_INT 89
78468: PUSH
78469: LD_INT 12
78471: PUSH
78472: LD_INT 30
78474: PUSH
78475: LD_INT 98
78477: PUSH
78478: LD_INT 11
78480: PUSH
78481: LD_INT 53
78483: PUSH
78484: LD_INT 14
78486: PUSH
78487: LD_INT 91
78489: PUSH
78490: LD_INT 29
78492: PUSH
78493: LD_INT 99
78495: PUSH
78496: LD_INT 13
78498: PUSH
78499: LD_INT 52
78501: PUSH
78502: LD_INT 88
78504: PUSH
78505: LD_INT 48
78507: PUSH
78508: LD_INT 8
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: LIST
78515: LIST
78516: LIST
78517: LIST
78518: LIST
78519: LIST
78520: LIST
78521: LIST
78522: LIST
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: IN
78531: NOT
78532: AND
78533: IFFALSE 78581
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78535: LD_ADDR_EXP 65
78539: PUSH
78540: LD_EXP 65
78544: PPUSH
78545: LD_VAR 0 4
78549: PUSH
78550: LD_EXP 65
78554: PUSH
78555: LD_VAR 0 4
78559: ARRAY
78560: PUSH
78561: LD_INT 1
78563: PLUS
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: PPUSH
78569: LD_VAR 0 1
78573: PPUSH
78574: CALL 14774 0 3
78578: ST_TO_ADDR
78579: GO 78625
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78581: LD_ADDR_EXP 62
78585: PUSH
78586: LD_EXP 62
78590: PPUSH
78591: LD_VAR 0 4
78595: PUSH
78596: LD_EXP 62
78600: PUSH
78601: LD_VAR 0 4
78605: ARRAY
78606: PUSH
78607: LD_INT 1
78609: PLUS
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PPUSH
78615: LD_VAR 0 1
78619: PPUSH
78620: CALL 14774 0 3
78624: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
78625: LD_ADDR_EXP 87
78629: PUSH
78630: LD_INT 0
78632: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78633: LD_VAR 0 1
78637: PPUSH
78638: CALL_OW 263
78642: PUSH
78643: LD_INT 2
78645: EQUAL
78646: IFFALSE 78675
// begin repeat wait ( 0 0$3 ) ;
78648: LD_INT 105
78650: PPUSH
78651: CALL_OW 67
// Connect ( vehicle ) ;
78655: LD_VAR 0 1
78659: PPUSH
78660: CALL 18120 0 1
// until IsControledBy ( vehicle ) ;
78664: LD_VAR 0 1
78668: PPUSH
78669: CALL_OW 312
78673: IFFALSE 78648
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78675: LD_VAR 0 1
78679: PPUSH
78680: LD_EXP 67
78684: PUSH
78685: LD_VAR 0 4
78689: ARRAY
78690: PPUSH
78691: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78695: LD_VAR 0 1
78699: PPUSH
78700: CALL_OW 263
78704: PUSH
78705: LD_INT 1
78707: NONEQUAL
78708: IFFALSE 78712
// break ;
78710: GO 78761
// repeat wait ( 0 0$1 ) ;
78712: LD_INT 35
78714: PPUSH
78715: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78719: LD_VAR 0 1
78723: PPUSH
78724: LD_EXP 67
78728: PUSH
78729: LD_VAR 0 4
78733: ARRAY
78734: PPUSH
78735: CALL_OW 308
78739: IFFALSE 78712
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78741: LD_VAR 0 1
78745: PPUSH
78746: CALL_OW 311
78750: PPUSH
78751: CALL_OW 121
// exit ;
78755: POP
78756: POP
78757: GO 78771
// end ; end ;
78759: GO 78403
78761: POP
78762: POP
// mc_block_vehicle_constructed_thread := false ;
78763: LD_ADDR_EXP 87
78767: PUSH
78768: LD_INT 0
78770: ST_TO_ADDR
// end ;
78771: LD_VAR 0 3
78775: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78776: LD_INT 0
78778: PPUSH
78779: PPUSH
78780: PPUSH
78781: PPUSH
// if not mc_bases or not skirmish then
78782: LD_EXP 43
78786: NOT
78787: PUSH
78788: LD_EXP 41
78792: NOT
78793: OR
78794: IFFALSE 78798
// exit ;
78796: GO 79151
// repeat wait ( 0 0$1 ) ;
78798: LD_INT 35
78800: PPUSH
78801: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78805: LD_VAR 0 2
78809: PPUSH
78810: LD_VAR 0 3
78814: PPUSH
78815: CALL_OW 284
78819: IFFALSE 78798
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78821: LD_VAR 0 2
78825: PPUSH
78826: LD_VAR 0 3
78830: PPUSH
78831: CALL_OW 283
78835: PUSH
78836: LD_INT 4
78838: EQUAL
78839: IFFALSE 78843
// exit ;
78841: GO 79151
// for i = 1 to mc_bases do
78843: LD_ADDR_VAR 0 7
78847: PUSH
78848: DOUBLE
78849: LD_INT 1
78851: DEC
78852: ST_TO_ADDR
78853: LD_EXP 43
78857: PUSH
78858: FOR_TO
78859: IFFALSE 79149
// begin if mc_crates_area [ i ] then
78861: LD_EXP 61
78865: PUSH
78866: LD_VAR 0 7
78870: ARRAY
78871: IFFALSE 78982
// for j in mc_crates_area [ i ] do
78873: LD_ADDR_VAR 0 8
78877: PUSH
78878: LD_EXP 61
78882: PUSH
78883: LD_VAR 0 7
78887: ARRAY
78888: PUSH
78889: FOR_IN
78890: IFFALSE 78980
// if InArea ( x , y , j ) then
78892: LD_VAR 0 2
78896: PPUSH
78897: LD_VAR 0 3
78901: PPUSH
78902: LD_VAR 0 8
78906: PPUSH
78907: CALL_OW 309
78911: IFFALSE 78978
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78913: LD_ADDR_EXP 59
78917: PUSH
78918: LD_EXP 59
78922: PPUSH
78923: LD_VAR 0 7
78927: PUSH
78928: LD_EXP 59
78932: PUSH
78933: LD_VAR 0 7
78937: ARRAY
78938: PUSH
78939: LD_INT 1
78941: PLUS
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PPUSH
78947: LD_VAR 0 4
78951: PUSH
78952: LD_VAR 0 2
78956: PUSH
78957: LD_VAR 0 3
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: LIST
78966: PPUSH
78967: CALL 14774 0 3
78971: ST_TO_ADDR
// exit ;
78972: POP
78973: POP
78974: POP
78975: POP
78976: GO 79151
// end ;
78978: GO 78889
78980: POP
78981: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78982: LD_ADDR_VAR 0 9
78986: PUSH
78987: LD_EXP 43
78991: PUSH
78992: LD_VAR 0 7
78996: ARRAY
78997: PPUSH
78998: LD_INT 2
79000: PUSH
79001: LD_INT 30
79003: PUSH
79004: LD_INT 0
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 30
79013: PUSH
79014: LD_INT 1
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: LIST
79025: PPUSH
79026: CALL_OW 72
79030: ST_TO_ADDR
// if not depot then
79031: LD_VAR 0 9
79035: NOT
79036: IFFALSE 79040
// continue ;
79038: GO 78858
// for j in depot do
79040: LD_ADDR_VAR 0 8
79044: PUSH
79045: LD_VAR 0 9
79049: PUSH
79050: FOR_IN
79051: IFFALSE 79145
// if GetDistUnitXY ( j , x , y ) < 30 then
79053: LD_VAR 0 8
79057: PPUSH
79058: LD_VAR 0 2
79062: PPUSH
79063: LD_VAR 0 3
79067: PPUSH
79068: CALL_OW 297
79072: PUSH
79073: LD_INT 30
79075: LESS
79076: IFFALSE 79143
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79078: LD_ADDR_EXP 59
79082: PUSH
79083: LD_EXP 59
79087: PPUSH
79088: LD_VAR 0 7
79092: PUSH
79093: LD_EXP 59
79097: PUSH
79098: LD_VAR 0 7
79102: ARRAY
79103: PUSH
79104: LD_INT 1
79106: PLUS
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PPUSH
79112: LD_VAR 0 4
79116: PUSH
79117: LD_VAR 0 2
79121: PUSH
79122: LD_VAR 0 3
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: LIST
79131: PPUSH
79132: CALL 14774 0 3
79136: ST_TO_ADDR
// exit ;
79137: POP
79138: POP
79139: POP
79140: POP
79141: GO 79151
// end ;
79143: GO 79050
79145: POP
79146: POP
// end ;
79147: GO 78858
79149: POP
79150: POP
// end ;
79151: LD_VAR 0 6
79155: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79156: LD_INT 0
79158: PPUSH
79159: PPUSH
79160: PPUSH
79161: PPUSH
// if not mc_bases or not skirmish then
79162: LD_EXP 43
79166: NOT
79167: PUSH
79168: LD_EXP 41
79172: NOT
79173: OR
79174: IFFALSE 79178
// exit ;
79176: GO 79455
// side := GetSide ( lab ) ;
79178: LD_ADDR_VAR 0 4
79182: PUSH
79183: LD_VAR 0 2
79187: PPUSH
79188: CALL_OW 255
79192: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79193: LD_VAR 0 4
79197: PUSH
79198: LD_EXP 69
79202: IN
79203: NOT
79204: PUSH
79205: LD_EXP 70
79209: NOT
79210: OR
79211: PUSH
79212: LD_EXP 43
79216: NOT
79217: OR
79218: IFFALSE 79222
// exit ;
79220: GO 79455
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79222: LD_ADDR_EXP 70
79226: PUSH
79227: LD_EXP 70
79231: PPUSH
79232: LD_VAR 0 4
79236: PPUSH
79237: LD_EXP 70
79241: PUSH
79242: LD_VAR 0 4
79246: ARRAY
79247: PUSH
79248: LD_VAR 0 1
79252: DIFF
79253: PPUSH
79254: CALL_OW 1
79258: ST_TO_ADDR
// for i = 1 to mc_bases do
79259: LD_ADDR_VAR 0 5
79263: PUSH
79264: DOUBLE
79265: LD_INT 1
79267: DEC
79268: ST_TO_ADDR
79269: LD_EXP 43
79273: PUSH
79274: FOR_TO
79275: IFFALSE 79453
// begin if lab in mc_bases [ i ] then
79277: LD_VAR 0 2
79281: PUSH
79282: LD_EXP 43
79286: PUSH
79287: LD_VAR 0 5
79291: ARRAY
79292: IN
79293: IFFALSE 79451
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79295: LD_VAR 0 1
79299: PUSH
79300: LD_INT 11
79302: PUSH
79303: LD_INT 4
79305: PUSH
79306: LD_INT 3
79308: PUSH
79309: LD_INT 2
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: IN
79318: PUSH
79319: LD_EXP 73
79323: PUSH
79324: LD_VAR 0 5
79328: ARRAY
79329: AND
79330: IFFALSE 79451
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79332: LD_ADDR_VAR 0 6
79336: PUSH
79337: LD_EXP 73
79341: PUSH
79342: LD_VAR 0 5
79346: ARRAY
79347: PUSH
79348: LD_INT 1
79350: ARRAY
79351: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79352: LD_ADDR_EXP 73
79356: PUSH
79357: LD_EXP 73
79361: PPUSH
79362: LD_VAR 0 5
79366: PPUSH
79367: EMPTY
79368: PPUSH
79369: CALL_OW 1
79373: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79374: LD_VAR 0 6
79378: PPUSH
79379: LD_INT 0
79381: PPUSH
79382: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79386: LD_VAR 0 6
79390: PPUSH
79391: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79395: LD_ADDR_EXP 72
79399: PUSH
79400: LD_EXP 72
79404: PPUSH
79405: LD_VAR 0 5
79409: PPUSH
79410: LD_EXP 72
79414: PUSH
79415: LD_VAR 0 5
79419: ARRAY
79420: PPUSH
79421: LD_INT 1
79423: PPUSH
79424: LD_VAR 0 6
79428: PPUSH
79429: CALL_OW 2
79433: PPUSH
79434: CALL_OW 1
79438: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
79439: LD_VAR 0 5
79443: PPUSH
79444: LD_INT 112
79446: PPUSH
79447: CALL 55905 0 2
// end ; end ; end ;
79451: GO 79274
79453: POP
79454: POP
// end ;
79455: LD_VAR 0 3
79459: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
79460: LD_INT 0
79462: PPUSH
79463: PPUSH
79464: PPUSH
79465: PPUSH
79466: PPUSH
79467: PPUSH
79468: PPUSH
79469: PPUSH
// if not mc_bases or not skirmish then
79470: LD_EXP 43
79474: NOT
79475: PUSH
79476: LD_EXP 41
79480: NOT
79481: OR
79482: IFFALSE 79486
// exit ;
79484: GO 80855
// for i = 1 to mc_bases do
79486: LD_ADDR_VAR 0 3
79490: PUSH
79491: DOUBLE
79492: LD_INT 1
79494: DEC
79495: ST_TO_ADDR
79496: LD_EXP 43
79500: PUSH
79501: FOR_TO
79502: IFFALSE 80853
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79504: LD_VAR 0 1
79508: PUSH
79509: LD_EXP 43
79513: PUSH
79514: LD_VAR 0 3
79518: ARRAY
79519: IN
79520: PUSH
79521: LD_VAR 0 1
79525: PUSH
79526: LD_EXP 50
79530: PUSH
79531: LD_VAR 0 3
79535: ARRAY
79536: IN
79537: OR
79538: PUSH
79539: LD_VAR 0 1
79543: PUSH
79544: LD_EXP 65
79548: PUSH
79549: LD_VAR 0 3
79553: ARRAY
79554: IN
79555: OR
79556: PUSH
79557: LD_VAR 0 1
79561: PUSH
79562: LD_EXP 62
79566: PUSH
79567: LD_VAR 0 3
79571: ARRAY
79572: IN
79573: OR
79574: PUSH
79575: LD_VAR 0 1
79579: PUSH
79580: LD_EXP 72
79584: PUSH
79585: LD_VAR 0 3
79589: ARRAY
79590: IN
79591: OR
79592: PUSH
79593: LD_VAR 0 1
79597: PUSH
79598: LD_EXP 73
79602: PUSH
79603: LD_VAR 0 3
79607: ARRAY
79608: IN
79609: OR
79610: IFFALSE 80851
// begin if un in mc_ape [ i ] then
79612: LD_VAR 0 1
79616: PUSH
79617: LD_EXP 72
79621: PUSH
79622: LD_VAR 0 3
79626: ARRAY
79627: IN
79628: IFFALSE 79667
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79630: LD_ADDR_EXP 72
79634: PUSH
79635: LD_EXP 72
79639: PPUSH
79640: LD_VAR 0 3
79644: PPUSH
79645: LD_EXP 72
79649: PUSH
79650: LD_VAR 0 3
79654: ARRAY
79655: PUSH
79656: LD_VAR 0 1
79660: DIFF
79661: PPUSH
79662: CALL_OW 1
79666: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79667: LD_VAR 0 1
79671: PUSH
79672: LD_EXP 73
79676: PUSH
79677: LD_VAR 0 3
79681: ARRAY
79682: IN
79683: IFFALSE 79707
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79685: LD_ADDR_EXP 73
79689: PUSH
79690: LD_EXP 73
79694: PPUSH
79695: LD_VAR 0 3
79699: PPUSH
79700: EMPTY
79701: PPUSH
79702: CALL_OW 1
79706: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79707: LD_VAR 0 1
79711: PPUSH
79712: CALL_OW 247
79716: PUSH
79717: LD_INT 2
79719: EQUAL
79720: PUSH
79721: LD_VAR 0 1
79725: PPUSH
79726: CALL_OW 110
79730: PUSH
79731: LD_INT 20
79733: EQUAL
79734: PUSH
79735: LD_VAR 0 1
79739: PUSH
79740: LD_EXP 65
79744: PUSH
79745: LD_VAR 0 3
79749: ARRAY
79750: IN
79751: OR
79752: PUSH
79753: LD_VAR 0 1
79757: PPUSH
79758: CALL_OW 264
79762: PUSH
79763: LD_INT 12
79765: PUSH
79766: LD_INT 51
79768: PUSH
79769: LD_INT 89
79771: PUSH
79772: LD_INT 32
79774: PUSH
79775: LD_INT 13
79777: PUSH
79778: LD_INT 52
79780: PUSH
79781: LD_INT 31
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: LIST
79788: LIST
79789: LIST
79790: LIST
79791: LIST
79792: IN
79793: OR
79794: AND
79795: IFFALSE 80103
// begin if un in mc_defender [ i ] then
79797: LD_VAR 0 1
79801: PUSH
79802: LD_EXP 65
79806: PUSH
79807: LD_VAR 0 3
79811: ARRAY
79812: IN
79813: IFFALSE 79852
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79815: LD_ADDR_EXP 65
79819: PUSH
79820: LD_EXP 65
79824: PPUSH
79825: LD_VAR 0 3
79829: PPUSH
79830: LD_EXP 65
79834: PUSH
79835: LD_VAR 0 3
79839: ARRAY
79840: PUSH
79841: LD_VAR 0 1
79845: DIFF
79846: PPUSH
79847: CALL_OW 1
79851: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79852: LD_ADDR_VAR 0 8
79856: PUSH
79857: LD_VAR 0 3
79861: PPUSH
79862: LD_INT 3
79864: PPUSH
79865: CALL 76473 0 2
79869: ST_TO_ADDR
// if fac then
79870: LD_VAR 0 8
79874: IFFALSE 80103
// begin for j in fac do
79876: LD_ADDR_VAR 0 4
79880: PUSH
79881: LD_VAR 0 8
79885: PUSH
79886: FOR_IN
79887: IFFALSE 80101
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79889: LD_ADDR_VAR 0 9
79893: PUSH
79894: LD_VAR 0 8
79898: PPUSH
79899: LD_VAR 0 1
79903: PPUSH
79904: CALL_OW 265
79908: PPUSH
79909: LD_VAR 0 1
79913: PPUSH
79914: CALL_OW 262
79918: PPUSH
79919: LD_VAR 0 1
79923: PPUSH
79924: CALL_OW 263
79928: PPUSH
79929: LD_VAR 0 1
79933: PPUSH
79934: CALL_OW 264
79938: PPUSH
79939: CALL 12272 0 5
79943: ST_TO_ADDR
// if components then
79944: LD_VAR 0 9
79948: IFFALSE 80099
// begin if GetWeapon ( un ) = ar_control_tower then
79950: LD_VAR 0 1
79954: PPUSH
79955: CALL_OW 264
79959: PUSH
79960: LD_INT 31
79962: EQUAL
79963: IFFALSE 80080
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79965: LD_VAR 0 1
79969: PPUSH
79970: CALL_OW 311
79974: PPUSH
79975: LD_INT 0
79977: PPUSH
79978: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79982: LD_ADDR_EXP 83
79986: PUSH
79987: LD_EXP 83
79991: PPUSH
79992: LD_VAR 0 3
79996: PPUSH
79997: LD_EXP 83
80001: PUSH
80002: LD_VAR 0 3
80006: ARRAY
80007: PUSH
80008: LD_VAR 0 1
80012: PPUSH
80013: CALL_OW 311
80017: DIFF
80018: PPUSH
80019: CALL_OW 1
80023: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80024: LD_ADDR_VAR 0 7
80028: PUSH
80029: LD_EXP 64
80033: PUSH
80034: LD_VAR 0 3
80038: ARRAY
80039: PPUSH
80040: LD_INT 1
80042: PPUSH
80043: LD_VAR 0 9
80047: PPUSH
80048: CALL_OW 2
80052: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80053: LD_ADDR_EXP 64
80057: PUSH
80058: LD_EXP 64
80062: PPUSH
80063: LD_VAR 0 3
80067: PPUSH
80068: LD_VAR 0 7
80072: PPUSH
80073: CALL_OW 1
80077: ST_TO_ADDR
// end else
80078: GO 80097
// MC_InsertProduceList ( i , [ components ] ) ;
80080: LD_VAR 0 3
80084: PPUSH
80085: LD_VAR 0 9
80089: PUSH
80090: EMPTY
80091: LIST
80092: PPUSH
80093: CALL 76018 0 2
// break ;
80097: GO 80101
// end ; end ;
80099: GO 79886
80101: POP
80102: POP
// end ; end ; if GetType ( un ) = unit_building then
80103: LD_VAR 0 1
80107: PPUSH
80108: CALL_OW 247
80112: PUSH
80113: LD_INT 3
80115: EQUAL
80116: IFFALSE 80519
// begin btype := GetBType ( un ) ;
80118: LD_ADDR_VAR 0 5
80122: PUSH
80123: LD_VAR 0 1
80127: PPUSH
80128: CALL_OW 266
80132: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80133: LD_VAR 0 5
80137: PUSH
80138: LD_INT 29
80140: PUSH
80141: LD_INT 30
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: IN
80148: IFFALSE 80221
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80150: LD_VAR 0 1
80154: PPUSH
80155: CALL_OW 250
80159: PPUSH
80160: LD_VAR 0 1
80164: PPUSH
80165: CALL_OW 251
80169: PPUSH
80170: LD_VAR 0 1
80174: PPUSH
80175: CALL_OW 255
80179: PPUSH
80180: CALL_OW 440
80184: NOT
80185: IFFALSE 80221
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80187: LD_VAR 0 1
80191: PPUSH
80192: CALL_OW 250
80196: PPUSH
80197: LD_VAR 0 1
80201: PPUSH
80202: CALL_OW 251
80206: PPUSH
80207: LD_VAR 0 1
80211: PPUSH
80212: CALL_OW 255
80216: PPUSH
80217: CALL_OW 441
// end ; if btype = b_warehouse then
80221: LD_VAR 0 5
80225: PUSH
80226: LD_INT 1
80228: EQUAL
80229: IFFALSE 80247
// begin btype := b_depot ;
80231: LD_ADDR_VAR 0 5
80235: PUSH
80236: LD_INT 0
80238: ST_TO_ADDR
// pos := 1 ;
80239: LD_ADDR_VAR 0 6
80243: PUSH
80244: LD_INT 1
80246: ST_TO_ADDR
// end ; if btype = b_factory then
80247: LD_VAR 0 5
80251: PUSH
80252: LD_INT 3
80254: EQUAL
80255: IFFALSE 80273
// begin btype := b_workshop ;
80257: LD_ADDR_VAR 0 5
80261: PUSH
80262: LD_INT 2
80264: ST_TO_ADDR
// pos := 1 ;
80265: LD_ADDR_VAR 0 6
80269: PUSH
80270: LD_INT 1
80272: ST_TO_ADDR
// end ; if btype = b_barracks then
80273: LD_VAR 0 5
80277: PUSH
80278: LD_INT 5
80280: EQUAL
80281: IFFALSE 80291
// btype := b_armoury ;
80283: LD_ADDR_VAR 0 5
80287: PUSH
80288: LD_INT 4
80290: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80291: LD_VAR 0 5
80295: PUSH
80296: LD_INT 7
80298: PUSH
80299: LD_INT 8
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: IN
80306: IFFALSE 80316
// btype := b_lab ;
80308: LD_ADDR_VAR 0 5
80312: PUSH
80313: LD_INT 6
80315: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80316: LD_ADDR_EXP 48
80320: PUSH
80321: LD_EXP 48
80325: PPUSH
80326: LD_VAR 0 3
80330: PUSH
80331: LD_EXP 48
80335: PUSH
80336: LD_VAR 0 3
80340: ARRAY
80341: PUSH
80342: LD_INT 1
80344: PLUS
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PPUSH
80350: LD_VAR 0 5
80354: PUSH
80355: LD_VAR 0 1
80359: PPUSH
80360: CALL_OW 250
80364: PUSH
80365: LD_VAR 0 1
80369: PPUSH
80370: CALL_OW 251
80374: PUSH
80375: LD_VAR 0 1
80379: PPUSH
80380: CALL_OW 254
80384: PUSH
80385: EMPTY
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: PPUSH
80391: CALL 14774 0 3
80395: ST_TO_ADDR
// if pos = 1 then
80396: LD_VAR 0 6
80400: PUSH
80401: LD_INT 1
80403: EQUAL
80404: IFFALSE 80519
// begin tmp := mc_build_list [ i ] ;
80406: LD_ADDR_VAR 0 7
80410: PUSH
80411: LD_EXP 48
80415: PUSH
80416: LD_VAR 0 3
80420: ARRAY
80421: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80422: LD_VAR 0 7
80426: PPUSH
80427: LD_INT 2
80429: PUSH
80430: LD_INT 30
80432: PUSH
80433: LD_INT 0
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: LD_INT 30
80442: PUSH
80443: LD_INT 1
80445: PUSH
80446: EMPTY
80447: LIST
80448: LIST
80449: PUSH
80450: EMPTY
80451: LIST
80452: LIST
80453: LIST
80454: PPUSH
80455: CALL_OW 72
80459: IFFALSE 80469
// pos := 2 ;
80461: LD_ADDR_VAR 0 6
80465: PUSH
80466: LD_INT 2
80468: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80469: LD_ADDR_VAR 0 7
80473: PUSH
80474: LD_VAR 0 7
80478: PPUSH
80479: LD_VAR 0 6
80483: PPUSH
80484: LD_VAR 0 7
80488: PPUSH
80489: CALL 15100 0 3
80493: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80494: LD_ADDR_EXP 48
80498: PUSH
80499: LD_EXP 48
80503: PPUSH
80504: LD_VAR 0 3
80508: PPUSH
80509: LD_VAR 0 7
80513: PPUSH
80514: CALL_OW 1
80518: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80519: LD_VAR 0 1
80523: PUSH
80524: LD_EXP 43
80528: PUSH
80529: LD_VAR 0 3
80533: ARRAY
80534: IN
80535: IFFALSE 80574
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80537: LD_ADDR_EXP 43
80541: PUSH
80542: LD_EXP 43
80546: PPUSH
80547: LD_VAR 0 3
80551: PPUSH
80552: LD_EXP 43
80556: PUSH
80557: LD_VAR 0 3
80561: ARRAY
80562: PUSH
80563: LD_VAR 0 1
80567: DIFF
80568: PPUSH
80569: CALL_OW 1
80573: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80574: LD_VAR 0 1
80578: PUSH
80579: LD_EXP 50
80583: PUSH
80584: LD_VAR 0 3
80588: ARRAY
80589: IN
80590: IFFALSE 80629
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80592: LD_ADDR_EXP 50
80596: PUSH
80597: LD_EXP 50
80601: PPUSH
80602: LD_VAR 0 3
80606: PPUSH
80607: LD_EXP 50
80611: PUSH
80612: LD_VAR 0 3
80616: ARRAY
80617: PUSH
80618: LD_VAR 0 1
80622: DIFF
80623: PPUSH
80624: CALL_OW 1
80628: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80629: LD_VAR 0 1
80633: PUSH
80634: LD_EXP 62
80638: PUSH
80639: LD_VAR 0 3
80643: ARRAY
80644: IN
80645: IFFALSE 80684
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80647: LD_ADDR_EXP 62
80651: PUSH
80652: LD_EXP 62
80656: PPUSH
80657: LD_VAR 0 3
80661: PPUSH
80662: LD_EXP 62
80666: PUSH
80667: LD_VAR 0 3
80671: ARRAY
80672: PUSH
80673: LD_VAR 0 1
80677: DIFF
80678: PPUSH
80679: CALL_OW 1
80683: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80684: LD_VAR 0 1
80688: PUSH
80689: LD_EXP 65
80693: PUSH
80694: LD_VAR 0 3
80698: ARRAY
80699: IN
80700: IFFALSE 80739
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80702: LD_ADDR_EXP 65
80706: PUSH
80707: LD_EXP 65
80711: PPUSH
80712: LD_VAR 0 3
80716: PPUSH
80717: LD_EXP 65
80721: PUSH
80722: LD_VAR 0 3
80726: ARRAY
80727: PUSH
80728: LD_VAR 0 1
80732: DIFF
80733: PPUSH
80734: CALL_OW 1
80738: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80739: LD_VAR 0 1
80743: PUSH
80744: LD_EXP 52
80748: PUSH
80749: LD_VAR 0 3
80753: ARRAY
80754: IN
80755: IFFALSE 80794
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80757: LD_ADDR_EXP 52
80761: PUSH
80762: LD_EXP 52
80766: PPUSH
80767: LD_VAR 0 3
80771: PPUSH
80772: LD_EXP 52
80776: PUSH
80777: LD_VAR 0 3
80781: ARRAY
80782: PUSH
80783: LD_VAR 0 1
80787: DIFF
80788: PPUSH
80789: CALL_OW 1
80793: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80794: LD_VAR 0 1
80798: PUSH
80799: LD_EXP 51
80803: PUSH
80804: LD_VAR 0 3
80808: ARRAY
80809: IN
80810: IFFALSE 80849
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80812: LD_ADDR_EXP 51
80816: PUSH
80817: LD_EXP 51
80821: PPUSH
80822: LD_VAR 0 3
80826: PPUSH
80827: LD_EXP 51
80831: PUSH
80832: LD_VAR 0 3
80836: ARRAY
80837: PUSH
80838: LD_VAR 0 1
80842: DIFF
80843: PPUSH
80844: CALL_OW 1
80848: ST_TO_ADDR
// end ; break ;
80849: GO 80853
// end ;
80851: GO 79501
80853: POP
80854: POP
// end ;
80855: LD_VAR 0 2
80859: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80860: LD_INT 0
80862: PPUSH
80863: PPUSH
80864: PPUSH
// if not mc_bases or not skirmish then
80865: LD_EXP 43
80869: NOT
80870: PUSH
80871: LD_EXP 41
80875: NOT
80876: OR
80877: IFFALSE 80881
// exit ;
80879: GO 81096
// for i = 1 to mc_bases do
80881: LD_ADDR_VAR 0 3
80885: PUSH
80886: DOUBLE
80887: LD_INT 1
80889: DEC
80890: ST_TO_ADDR
80891: LD_EXP 43
80895: PUSH
80896: FOR_TO
80897: IFFALSE 81094
// begin if building in mc_construct_list [ i ] then
80899: LD_VAR 0 1
80903: PUSH
80904: LD_EXP 50
80908: PUSH
80909: LD_VAR 0 3
80913: ARRAY
80914: IN
80915: IFFALSE 81092
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80917: LD_ADDR_EXP 50
80921: PUSH
80922: LD_EXP 50
80926: PPUSH
80927: LD_VAR 0 3
80931: PPUSH
80932: LD_EXP 50
80936: PUSH
80937: LD_VAR 0 3
80941: ARRAY
80942: PUSH
80943: LD_VAR 0 1
80947: DIFF
80948: PPUSH
80949: CALL_OW 1
80953: ST_TO_ADDR
// if building in mc_lab [ i ] then
80954: LD_VAR 0 1
80958: PUSH
80959: LD_EXP 76
80963: PUSH
80964: LD_VAR 0 3
80968: ARRAY
80969: IN
80970: IFFALSE 81025
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80972: LD_ADDR_EXP 77
80976: PUSH
80977: LD_EXP 77
80981: PPUSH
80982: LD_VAR 0 3
80986: PPUSH
80987: LD_EXP 77
80991: PUSH
80992: LD_VAR 0 3
80996: ARRAY
80997: PPUSH
80998: LD_INT 1
81000: PPUSH
81001: LD_EXP 77
81005: PUSH
81006: LD_VAR 0 3
81010: ARRAY
81011: PPUSH
81012: LD_INT 0
81014: PPUSH
81015: CALL 14192 0 4
81019: PPUSH
81020: CALL_OW 1
81024: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81025: LD_VAR 0 1
81029: PUSH
81030: LD_EXP 43
81034: PUSH
81035: LD_VAR 0 3
81039: ARRAY
81040: IN
81041: NOT
81042: IFFALSE 81088
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81044: LD_ADDR_EXP 43
81048: PUSH
81049: LD_EXP 43
81053: PPUSH
81054: LD_VAR 0 3
81058: PUSH
81059: LD_EXP 43
81063: PUSH
81064: LD_VAR 0 3
81068: ARRAY
81069: PUSH
81070: LD_INT 1
81072: PLUS
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PPUSH
81078: LD_VAR 0 1
81082: PPUSH
81083: CALL 14774 0 3
81087: ST_TO_ADDR
// exit ;
81088: POP
81089: POP
81090: GO 81096
// end ; end ;
81092: GO 80896
81094: POP
81095: POP
// end ;
81096: LD_VAR 0 2
81100: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81101: LD_INT 0
81103: PPUSH
81104: PPUSH
81105: PPUSH
81106: PPUSH
81107: PPUSH
81108: PPUSH
81109: PPUSH
// if not mc_bases or not skirmish then
81110: LD_EXP 43
81114: NOT
81115: PUSH
81116: LD_EXP 41
81120: NOT
81121: OR
81122: IFFALSE 81126
// exit ;
81124: GO 81787
// for i = 1 to mc_bases do
81126: LD_ADDR_VAR 0 3
81130: PUSH
81131: DOUBLE
81132: LD_INT 1
81134: DEC
81135: ST_TO_ADDR
81136: LD_EXP 43
81140: PUSH
81141: FOR_TO
81142: IFFALSE 81785
// begin if building in mc_construct_list [ i ] then
81144: LD_VAR 0 1
81148: PUSH
81149: LD_EXP 50
81153: PUSH
81154: LD_VAR 0 3
81158: ARRAY
81159: IN
81160: IFFALSE 81783
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81162: LD_ADDR_EXP 50
81166: PUSH
81167: LD_EXP 50
81171: PPUSH
81172: LD_VAR 0 3
81176: PPUSH
81177: LD_EXP 50
81181: PUSH
81182: LD_VAR 0 3
81186: ARRAY
81187: PUSH
81188: LD_VAR 0 1
81192: DIFF
81193: PPUSH
81194: CALL_OW 1
81198: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81199: LD_ADDR_EXP 43
81203: PUSH
81204: LD_EXP 43
81208: PPUSH
81209: LD_VAR 0 3
81213: PUSH
81214: LD_EXP 43
81218: PUSH
81219: LD_VAR 0 3
81223: ARRAY
81224: PUSH
81225: LD_INT 1
81227: PLUS
81228: PUSH
81229: EMPTY
81230: LIST
81231: LIST
81232: PPUSH
81233: LD_VAR 0 1
81237: PPUSH
81238: CALL 14774 0 3
81242: ST_TO_ADDR
// btype := GetBType ( building ) ;
81243: LD_ADDR_VAR 0 5
81247: PUSH
81248: LD_VAR 0 1
81252: PPUSH
81253: CALL_OW 266
81257: ST_TO_ADDR
// side := GetSide ( building ) ;
81258: LD_ADDR_VAR 0 8
81262: PUSH
81263: LD_VAR 0 1
81267: PPUSH
81268: CALL_OW 255
81272: ST_TO_ADDR
// if btype = b_lab then
81273: LD_VAR 0 5
81277: PUSH
81278: LD_INT 6
81280: EQUAL
81281: IFFALSE 81331
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81283: LD_ADDR_EXP 76
81287: PUSH
81288: LD_EXP 76
81292: PPUSH
81293: LD_VAR 0 3
81297: PUSH
81298: LD_EXP 76
81302: PUSH
81303: LD_VAR 0 3
81307: ARRAY
81308: PUSH
81309: LD_INT 1
81311: PLUS
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PPUSH
81317: LD_VAR 0 1
81321: PPUSH
81322: CALL 14774 0 3
81326: ST_TO_ADDR
// exit ;
81327: POP
81328: POP
81329: GO 81787
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81331: LD_VAR 0 5
81335: PUSH
81336: LD_INT 0
81338: PUSH
81339: LD_INT 2
81341: PUSH
81342: LD_INT 4
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: LIST
81349: IN
81350: IFFALSE 81474
// begin if btype = b_armoury then
81352: LD_VAR 0 5
81356: PUSH
81357: LD_INT 4
81359: EQUAL
81360: IFFALSE 81370
// btype := b_barracks ;
81362: LD_ADDR_VAR 0 5
81366: PUSH
81367: LD_INT 5
81369: ST_TO_ADDR
// if btype = b_depot then
81370: LD_VAR 0 5
81374: PUSH
81375: LD_INT 0
81377: EQUAL
81378: IFFALSE 81388
// btype := b_warehouse ;
81380: LD_ADDR_VAR 0 5
81384: PUSH
81385: LD_INT 1
81387: ST_TO_ADDR
// if btype = b_workshop then
81388: LD_VAR 0 5
81392: PUSH
81393: LD_INT 2
81395: EQUAL
81396: IFFALSE 81406
// btype := b_factory ;
81398: LD_ADDR_VAR 0 5
81402: PUSH
81403: LD_INT 3
81405: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81406: LD_VAR 0 5
81410: PPUSH
81411: LD_VAR 0 8
81415: PPUSH
81416: CALL_OW 323
81420: PUSH
81421: LD_INT 1
81423: EQUAL
81424: IFFALSE 81470
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81426: LD_ADDR_EXP 75
81430: PUSH
81431: LD_EXP 75
81435: PPUSH
81436: LD_VAR 0 3
81440: PUSH
81441: LD_EXP 75
81445: PUSH
81446: LD_VAR 0 3
81450: ARRAY
81451: PUSH
81452: LD_INT 1
81454: PLUS
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PPUSH
81460: LD_VAR 0 1
81464: PPUSH
81465: CALL 14774 0 3
81469: ST_TO_ADDR
// exit ;
81470: POP
81471: POP
81472: GO 81787
// end ; if btype in [ b_bunker , b_turret ] then
81474: LD_VAR 0 5
81478: PUSH
81479: LD_INT 32
81481: PUSH
81482: LD_INT 33
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: IN
81489: IFFALSE 81779
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81491: LD_ADDR_EXP 51
81495: PUSH
81496: LD_EXP 51
81500: PPUSH
81501: LD_VAR 0 3
81505: PUSH
81506: LD_EXP 51
81510: PUSH
81511: LD_VAR 0 3
81515: ARRAY
81516: PUSH
81517: LD_INT 1
81519: PLUS
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PPUSH
81525: LD_VAR 0 1
81529: PPUSH
81530: CALL 14774 0 3
81534: ST_TO_ADDR
// if btype = b_bunker then
81535: LD_VAR 0 5
81539: PUSH
81540: LD_INT 32
81542: EQUAL
81543: IFFALSE 81779
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81545: LD_ADDR_EXP 52
81549: PUSH
81550: LD_EXP 52
81554: PPUSH
81555: LD_VAR 0 3
81559: PUSH
81560: LD_EXP 52
81564: PUSH
81565: LD_VAR 0 3
81569: ARRAY
81570: PUSH
81571: LD_INT 1
81573: PLUS
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PPUSH
81579: LD_VAR 0 1
81583: PPUSH
81584: CALL 14774 0 3
81588: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81589: LD_ADDR_VAR 0 6
81593: PUSH
81594: LD_EXP 43
81598: PUSH
81599: LD_VAR 0 3
81603: ARRAY
81604: PPUSH
81605: LD_INT 25
81607: PUSH
81608: LD_INT 1
81610: PUSH
81611: EMPTY
81612: LIST
81613: LIST
81614: PUSH
81615: LD_INT 3
81617: PUSH
81618: LD_INT 54
81620: PUSH
81621: EMPTY
81622: LIST
81623: PUSH
81624: EMPTY
81625: LIST
81626: LIST
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PPUSH
81632: CALL_OW 72
81636: ST_TO_ADDR
// if tmp then
81637: LD_VAR 0 6
81641: IFFALSE 81647
// exit ;
81643: POP
81644: POP
81645: GO 81787
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81647: LD_ADDR_VAR 0 6
81651: PUSH
81652: LD_EXP 43
81656: PUSH
81657: LD_VAR 0 3
81661: ARRAY
81662: PPUSH
81663: LD_INT 2
81665: PUSH
81666: LD_INT 30
81668: PUSH
81669: LD_INT 4
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: LD_INT 30
81678: PUSH
81679: LD_INT 5
81681: PUSH
81682: EMPTY
81683: LIST
81684: LIST
81685: PUSH
81686: EMPTY
81687: LIST
81688: LIST
81689: LIST
81690: PPUSH
81691: CALL_OW 72
81695: ST_TO_ADDR
// if not tmp then
81696: LD_VAR 0 6
81700: NOT
81701: IFFALSE 81707
// exit ;
81703: POP
81704: POP
81705: GO 81787
// for j in tmp do
81707: LD_ADDR_VAR 0 4
81711: PUSH
81712: LD_VAR 0 6
81716: PUSH
81717: FOR_IN
81718: IFFALSE 81777
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81720: LD_ADDR_VAR 0 7
81724: PUSH
81725: LD_VAR 0 4
81729: PPUSH
81730: CALL_OW 313
81734: PPUSH
81735: LD_INT 25
81737: PUSH
81738: LD_INT 1
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PPUSH
81745: CALL_OW 72
81749: ST_TO_ADDR
// if units then
81750: LD_VAR 0 7
81754: IFFALSE 81775
// begin ComExitBuilding ( units [ 1 ] ) ;
81756: LD_VAR 0 7
81760: PUSH
81761: LD_INT 1
81763: ARRAY
81764: PPUSH
81765: CALL_OW 122
// exit ;
81769: POP
81770: POP
81771: POP
81772: POP
81773: GO 81787
// end ; end ;
81775: GO 81717
81777: POP
81778: POP
// end ; end ; exit ;
81779: POP
81780: POP
81781: GO 81787
// end ; end ;
81783: GO 81141
81785: POP
81786: POP
// end ;
81787: LD_VAR 0 2
81791: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81792: LD_INT 0
81794: PPUSH
81795: PPUSH
81796: PPUSH
81797: PPUSH
81798: PPUSH
81799: PPUSH
81800: PPUSH
// if not mc_bases or not skirmish then
81801: LD_EXP 43
81805: NOT
81806: PUSH
81807: LD_EXP 41
81811: NOT
81812: OR
81813: IFFALSE 81817
// exit ;
81815: GO 82082
// btype := GetBType ( building ) ;
81817: LD_ADDR_VAR 0 6
81821: PUSH
81822: LD_VAR 0 1
81826: PPUSH
81827: CALL_OW 266
81831: ST_TO_ADDR
// x := GetX ( building ) ;
81832: LD_ADDR_VAR 0 7
81836: PUSH
81837: LD_VAR 0 1
81841: PPUSH
81842: CALL_OW 250
81846: ST_TO_ADDR
// y := GetY ( building ) ;
81847: LD_ADDR_VAR 0 8
81851: PUSH
81852: LD_VAR 0 1
81856: PPUSH
81857: CALL_OW 251
81861: ST_TO_ADDR
// d := GetDir ( building ) ;
81862: LD_ADDR_VAR 0 9
81866: PUSH
81867: LD_VAR 0 1
81871: PPUSH
81872: CALL_OW 254
81876: ST_TO_ADDR
// for i = 1 to mc_bases do
81877: LD_ADDR_VAR 0 4
81881: PUSH
81882: DOUBLE
81883: LD_INT 1
81885: DEC
81886: ST_TO_ADDR
81887: LD_EXP 43
81891: PUSH
81892: FOR_TO
81893: IFFALSE 82080
// begin if not mc_build_list [ i ] then
81895: LD_EXP 48
81899: PUSH
81900: LD_VAR 0 4
81904: ARRAY
81905: NOT
81906: IFFALSE 81910
// continue ;
81908: GO 81892
// for j := 1 to mc_build_list [ i ] do
81910: LD_ADDR_VAR 0 5
81914: PUSH
81915: DOUBLE
81916: LD_INT 1
81918: DEC
81919: ST_TO_ADDR
81920: LD_EXP 48
81924: PUSH
81925: LD_VAR 0 4
81929: ARRAY
81930: PUSH
81931: FOR_TO
81932: IFFALSE 82076
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81934: LD_VAR 0 6
81938: PUSH
81939: LD_VAR 0 7
81943: PUSH
81944: LD_VAR 0 8
81948: PUSH
81949: LD_VAR 0 9
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: LIST
81958: LIST
81959: PPUSH
81960: LD_EXP 48
81964: PUSH
81965: LD_VAR 0 4
81969: ARRAY
81970: PUSH
81971: LD_VAR 0 5
81975: ARRAY
81976: PPUSH
81977: CALL 21331 0 2
81981: IFFALSE 82074
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81983: LD_ADDR_EXP 48
81987: PUSH
81988: LD_EXP 48
81992: PPUSH
81993: LD_VAR 0 4
81997: PPUSH
81998: LD_EXP 48
82002: PUSH
82003: LD_VAR 0 4
82007: ARRAY
82008: PPUSH
82009: LD_VAR 0 5
82013: PPUSH
82014: CALL_OW 3
82018: PPUSH
82019: CALL_OW 1
82023: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82024: LD_ADDR_EXP 50
82028: PUSH
82029: LD_EXP 50
82033: PPUSH
82034: LD_VAR 0 4
82038: PUSH
82039: LD_EXP 50
82043: PUSH
82044: LD_VAR 0 4
82048: ARRAY
82049: PUSH
82050: LD_INT 1
82052: PLUS
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PPUSH
82058: LD_VAR 0 1
82062: PPUSH
82063: CALL 14774 0 3
82067: ST_TO_ADDR
// exit ;
82068: POP
82069: POP
82070: POP
82071: POP
82072: GO 82082
// end ;
82074: GO 81931
82076: POP
82077: POP
// end ;
82078: GO 81892
82080: POP
82081: POP
// end ;
82082: LD_VAR 0 3
82086: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82087: LD_INT 0
82089: PPUSH
82090: PPUSH
82091: PPUSH
// if not mc_bases or not skirmish then
82092: LD_EXP 43
82096: NOT
82097: PUSH
82098: LD_EXP 41
82102: NOT
82103: OR
82104: IFFALSE 82108
// exit ;
82106: GO 82298
// for i = 1 to mc_bases do
82108: LD_ADDR_VAR 0 4
82112: PUSH
82113: DOUBLE
82114: LD_INT 1
82116: DEC
82117: ST_TO_ADDR
82118: LD_EXP 43
82122: PUSH
82123: FOR_TO
82124: IFFALSE 82211
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82126: LD_VAR 0 1
82130: PUSH
82131: LD_EXP 51
82135: PUSH
82136: LD_VAR 0 4
82140: ARRAY
82141: IN
82142: PUSH
82143: LD_VAR 0 1
82147: PUSH
82148: LD_EXP 52
82152: PUSH
82153: LD_VAR 0 4
82157: ARRAY
82158: IN
82159: NOT
82160: AND
82161: IFFALSE 82209
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82163: LD_ADDR_EXP 52
82167: PUSH
82168: LD_EXP 52
82172: PPUSH
82173: LD_VAR 0 4
82177: PUSH
82178: LD_EXP 52
82182: PUSH
82183: LD_VAR 0 4
82187: ARRAY
82188: PUSH
82189: LD_INT 1
82191: PLUS
82192: PUSH
82193: EMPTY
82194: LIST
82195: LIST
82196: PPUSH
82197: LD_VAR 0 1
82201: PPUSH
82202: CALL 14774 0 3
82206: ST_TO_ADDR
// break ;
82207: GO 82211
// end ; end ;
82209: GO 82123
82211: POP
82212: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82213: LD_VAR 0 1
82217: PPUSH
82218: CALL_OW 257
82222: PUSH
82223: LD_EXP 69
82227: IN
82228: PUSH
82229: LD_VAR 0 1
82233: PPUSH
82234: CALL_OW 266
82238: PUSH
82239: LD_INT 5
82241: EQUAL
82242: AND
82243: PUSH
82244: LD_VAR 0 2
82248: PPUSH
82249: CALL_OW 110
82253: PUSH
82254: LD_INT 18
82256: NONEQUAL
82257: AND
82258: IFFALSE 82298
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82260: LD_VAR 0 2
82264: PPUSH
82265: CALL_OW 257
82269: PUSH
82270: LD_INT 5
82272: PUSH
82273: LD_INT 8
82275: PUSH
82276: LD_INT 9
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: LIST
82283: IN
82284: IFFALSE 82298
// SetClass ( unit , 1 ) ;
82286: LD_VAR 0 2
82290: PPUSH
82291: LD_INT 1
82293: PPUSH
82294: CALL_OW 336
// end ;
82298: LD_VAR 0 3
82302: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82303: LD_INT 0
82305: PPUSH
82306: PPUSH
// if not mc_bases or not skirmish then
82307: LD_EXP 43
82311: NOT
82312: PUSH
82313: LD_EXP 41
82317: NOT
82318: OR
82319: IFFALSE 82323
// exit ;
82321: GO 82439
// if GetLives ( abandoned_vehicle ) > 250 then
82323: LD_VAR 0 2
82327: PPUSH
82328: CALL_OW 256
82332: PUSH
82333: LD_INT 250
82335: GREATER
82336: IFFALSE 82340
// exit ;
82338: GO 82439
// for i = 1 to mc_bases do
82340: LD_ADDR_VAR 0 6
82344: PUSH
82345: DOUBLE
82346: LD_INT 1
82348: DEC
82349: ST_TO_ADDR
82350: LD_EXP 43
82354: PUSH
82355: FOR_TO
82356: IFFALSE 82437
// begin if driver in mc_bases [ i ] then
82358: LD_VAR 0 1
82362: PUSH
82363: LD_EXP 43
82367: PUSH
82368: LD_VAR 0 6
82372: ARRAY
82373: IN
82374: IFFALSE 82435
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82376: LD_VAR 0 1
82380: PPUSH
82381: LD_EXP 43
82385: PUSH
82386: LD_VAR 0 6
82390: ARRAY
82391: PPUSH
82392: LD_INT 2
82394: PUSH
82395: LD_INT 30
82397: PUSH
82398: LD_INT 0
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 30
82407: PUSH
82408: LD_INT 1
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: LIST
82419: PPUSH
82420: CALL_OW 72
82424: PUSH
82425: LD_INT 1
82427: ARRAY
82428: PPUSH
82429: CALL 48391 0 2
// break ;
82433: GO 82437
// end ; end ;
82435: GO 82355
82437: POP
82438: POP
// end ; end_of_file
82439: LD_VAR 0 5
82443: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
82444: LD_INT 0
82446: PPUSH
82447: PPUSH
82448: PPUSH
82449: PPUSH
82450: PPUSH
82451: PPUSH
82452: PPUSH
82453: PPUSH
82454: PPUSH
82455: PPUSH
82456: PPUSH
82457: PPUSH
82458: PPUSH
82459: PPUSH
82460: PPUSH
82461: PPUSH
82462: PPUSH
82463: PPUSH
82464: PPUSH
82465: PPUSH
82466: PPUSH
82467: PPUSH
82468: PPUSH
82469: PPUSH
82470: PPUSH
82471: PPUSH
82472: PPUSH
82473: PPUSH
82474: PPUSH
82475: PPUSH
82476: PPUSH
82477: PPUSH
82478: PPUSH
82479: PPUSH
// if not list then
82480: LD_VAR 0 1
82484: NOT
82485: IFFALSE 82489
// exit ;
82487: GO 87148
// base := list [ 1 ] ;
82489: LD_ADDR_VAR 0 3
82493: PUSH
82494: LD_VAR 0 1
82498: PUSH
82499: LD_INT 1
82501: ARRAY
82502: ST_TO_ADDR
// group := list [ 2 ] ;
82503: LD_ADDR_VAR 0 4
82507: PUSH
82508: LD_VAR 0 1
82512: PUSH
82513: LD_INT 2
82515: ARRAY
82516: ST_TO_ADDR
// path := list [ 3 ] ;
82517: LD_ADDR_VAR 0 5
82521: PUSH
82522: LD_VAR 0 1
82526: PUSH
82527: LD_INT 3
82529: ARRAY
82530: ST_TO_ADDR
// flags := list [ 4 ] ;
82531: LD_ADDR_VAR 0 6
82535: PUSH
82536: LD_VAR 0 1
82540: PUSH
82541: LD_INT 4
82543: ARRAY
82544: ST_TO_ADDR
// mined := [ ] ;
82545: LD_ADDR_VAR 0 27
82549: PUSH
82550: EMPTY
82551: ST_TO_ADDR
// bombed := [ ] ;
82552: LD_ADDR_VAR 0 28
82556: PUSH
82557: EMPTY
82558: ST_TO_ADDR
// healers := [ ] ;
82559: LD_ADDR_VAR 0 31
82563: PUSH
82564: EMPTY
82565: ST_TO_ADDR
// to_heal := [ ] ;
82566: LD_ADDR_VAR 0 30
82570: PUSH
82571: EMPTY
82572: ST_TO_ADDR
// repairs := [ ] ;
82573: LD_ADDR_VAR 0 33
82577: PUSH
82578: EMPTY
82579: ST_TO_ADDR
// to_repair := [ ] ;
82580: LD_ADDR_VAR 0 32
82584: PUSH
82585: EMPTY
82586: ST_TO_ADDR
// if not group or not path then
82587: LD_VAR 0 4
82591: NOT
82592: PUSH
82593: LD_VAR 0 5
82597: NOT
82598: OR
82599: IFFALSE 82603
// exit ;
82601: GO 87148
// side := GetSide ( group [ 1 ] ) ;
82603: LD_ADDR_VAR 0 35
82607: PUSH
82608: LD_VAR 0 4
82612: PUSH
82613: LD_INT 1
82615: ARRAY
82616: PPUSH
82617: CALL_OW 255
82621: ST_TO_ADDR
// if flags then
82622: LD_VAR 0 6
82626: IFFALSE 82770
// begin f_ignore_area := flags [ 1 ] ;
82628: LD_ADDR_VAR 0 17
82632: PUSH
82633: LD_VAR 0 6
82637: PUSH
82638: LD_INT 1
82640: ARRAY
82641: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82642: LD_ADDR_VAR 0 18
82646: PUSH
82647: LD_VAR 0 6
82651: PUSH
82652: LD_INT 2
82654: ARRAY
82655: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82656: LD_ADDR_VAR 0 19
82660: PUSH
82661: LD_VAR 0 6
82665: PUSH
82666: LD_INT 3
82668: ARRAY
82669: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82670: LD_ADDR_VAR 0 20
82674: PUSH
82675: LD_VAR 0 6
82679: PUSH
82680: LD_INT 4
82682: ARRAY
82683: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82684: LD_ADDR_VAR 0 21
82688: PUSH
82689: LD_VAR 0 6
82693: PUSH
82694: LD_INT 5
82696: ARRAY
82697: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82698: LD_ADDR_VAR 0 22
82702: PUSH
82703: LD_VAR 0 6
82707: PUSH
82708: LD_INT 6
82710: ARRAY
82711: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82712: LD_ADDR_VAR 0 23
82716: PUSH
82717: LD_VAR 0 6
82721: PUSH
82722: LD_INT 7
82724: ARRAY
82725: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82726: LD_ADDR_VAR 0 24
82730: PUSH
82731: LD_VAR 0 6
82735: PUSH
82736: LD_INT 8
82738: ARRAY
82739: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82740: LD_ADDR_VAR 0 25
82744: PUSH
82745: LD_VAR 0 6
82749: PUSH
82750: LD_INT 9
82752: ARRAY
82753: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82754: LD_ADDR_VAR 0 26
82758: PUSH
82759: LD_VAR 0 6
82763: PUSH
82764: LD_INT 10
82766: ARRAY
82767: ST_TO_ADDR
// end else
82768: GO 82850
// begin f_ignore_area := false ;
82770: LD_ADDR_VAR 0 17
82774: PUSH
82775: LD_INT 0
82777: ST_TO_ADDR
// f_capture := false ;
82778: LD_ADDR_VAR 0 18
82782: PUSH
82783: LD_INT 0
82785: ST_TO_ADDR
// f_ignore_civ := false ;
82786: LD_ADDR_VAR 0 19
82790: PUSH
82791: LD_INT 0
82793: ST_TO_ADDR
// f_murder := false ;
82794: LD_ADDR_VAR 0 20
82798: PUSH
82799: LD_INT 0
82801: ST_TO_ADDR
// f_mines := false ;
82802: LD_ADDR_VAR 0 21
82806: PUSH
82807: LD_INT 0
82809: ST_TO_ADDR
// f_repair := false ;
82810: LD_ADDR_VAR 0 22
82814: PUSH
82815: LD_INT 0
82817: ST_TO_ADDR
// f_heal := false ;
82818: LD_ADDR_VAR 0 23
82822: PUSH
82823: LD_INT 0
82825: ST_TO_ADDR
// f_spacetime := false ;
82826: LD_ADDR_VAR 0 24
82830: PUSH
82831: LD_INT 0
82833: ST_TO_ADDR
// f_attack_depot := false ;
82834: LD_ADDR_VAR 0 25
82838: PUSH
82839: LD_INT 0
82841: ST_TO_ADDR
// f_crawl := false ;
82842: LD_ADDR_VAR 0 26
82846: PUSH
82847: LD_INT 0
82849: ST_TO_ADDR
// end ; if f_heal then
82850: LD_VAR 0 23
82854: IFFALSE 82881
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82856: LD_ADDR_VAR 0 31
82860: PUSH
82861: LD_VAR 0 4
82865: PPUSH
82866: LD_INT 25
82868: PUSH
82869: LD_INT 4
82871: PUSH
82872: EMPTY
82873: LIST
82874: LIST
82875: PPUSH
82876: CALL_OW 72
82880: ST_TO_ADDR
// if f_repair then
82881: LD_VAR 0 22
82885: IFFALSE 82912
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82887: LD_ADDR_VAR 0 33
82891: PUSH
82892: LD_VAR 0 4
82896: PPUSH
82897: LD_INT 25
82899: PUSH
82900: LD_INT 3
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PPUSH
82907: CALL_OW 72
82911: ST_TO_ADDR
// units_path := [ ] ;
82912: LD_ADDR_VAR 0 16
82916: PUSH
82917: EMPTY
82918: ST_TO_ADDR
// for i = 1 to group do
82919: LD_ADDR_VAR 0 7
82923: PUSH
82924: DOUBLE
82925: LD_INT 1
82927: DEC
82928: ST_TO_ADDR
82929: LD_VAR 0 4
82933: PUSH
82934: FOR_TO
82935: IFFALSE 82964
// units_path := Replace ( units_path , i , path ) ;
82937: LD_ADDR_VAR 0 16
82941: PUSH
82942: LD_VAR 0 16
82946: PPUSH
82947: LD_VAR 0 7
82951: PPUSH
82952: LD_VAR 0 5
82956: PPUSH
82957: CALL_OW 1
82961: ST_TO_ADDR
82962: GO 82934
82964: POP
82965: POP
// repeat for i = group downto 1 do
82966: LD_ADDR_VAR 0 7
82970: PUSH
82971: DOUBLE
82972: LD_VAR 0 4
82976: INC
82977: ST_TO_ADDR
82978: LD_INT 1
82980: PUSH
82981: FOR_DOWNTO
82982: IFFALSE 87104
// begin wait ( 5 ) ;
82984: LD_INT 5
82986: PPUSH
82987: CALL_OW 67
// tmp := [ ] ;
82991: LD_ADDR_VAR 0 14
82995: PUSH
82996: EMPTY
82997: ST_TO_ADDR
// attacking := false ;
82998: LD_ADDR_VAR 0 29
83002: PUSH
83003: LD_INT 0
83005: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83006: LD_VAR 0 4
83010: PUSH
83011: LD_VAR 0 7
83015: ARRAY
83016: PPUSH
83017: CALL_OW 301
83021: PUSH
83022: LD_VAR 0 4
83026: PUSH
83027: LD_VAR 0 7
83031: ARRAY
83032: NOT
83033: OR
83034: IFFALSE 83143
// begin if GetType ( group [ i ] ) = unit_human then
83036: LD_VAR 0 4
83040: PUSH
83041: LD_VAR 0 7
83045: ARRAY
83046: PPUSH
83047: CALL_OW 247
83051: PUSH
83052: LD_INT 1
83054: EQUAL
83055: IFFALSE 83101
// begin to_heal := to_heal diff group [ i ] ;
83057: LD_ADDR_VAR 0 30
83061: PUSH
83062: LD_VAR 0 30
83066: PUSH
83067: LD_VAR 0 4
83071: PUSH
83072: LD_VAR 0 7
83076: ARRAY
83077: DIFF
83078: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83079: LD_ADDR_VAR 0 31
83083: PUSH
83084: LD_VAR 0 31
83088: PUSH
83089: LD_VAR 0 4
83093: PUSH
83094: LD_VAR 0 7
83098: ARRAY
83099: DIFF
83100: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83101: LD_ADDR_VAR 0 4
83105: PUSH
83106: LD_VAR 0 4
83110: PPUSH
83111: LD_VAR 0 7
83115: PPUSH
83116: CALL_OW 3
83120: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83121: LD_ADDR_VAR 0 16
83125: PUSH
83126: LD_VAR 0 16
83130: PPUSH
83131: LD_VAR 0 7
83135: PPUSH
83136: CALL_OW 3
83140: ST_TO_ADDR
// continue ;
83141: GO 82981
// end ; if f_repair then
83143: LD_VAR 0 22
83147: IFFALSE 83636
// begin if GetType ( group [ i ] ) = unit_vehicle then
83149: LD_VAR 0 4
83153: PUSH
83154: LD_VAR 0 7
83158: ARRAY
83159: PPUSH
83160: CALL_OW 247
83164: PUSH
83165: LD_INT 2
83167: EQUAL
83168: IFFALSE 83358
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83170: LD_VAR 0 4
83174: PUSH
83175: LD_VAR 0 7
83179: ARRAY
83180: PPUSH
83181: CALL_OW 256
83185: PUSH
83186: LD_INT 700
83188: LESS
83189: PUSH
83190: LD_VAR 0 4
83194: PUSH
83195: LD_VAR 0 7
83199: ARRAY
83200: PUSH
83201: LD_VAR 0 32
83205: IN
83206: NOT
83207: AND
83208: IFFALSE 83232
// to_repair := to_repair union group [ i ] ;
83210: LD_ADDR_VAR 0 32
83214: PUSH
83215: LD_VAR 0 32
83219: PUSH
83220: LD_VAR 0 4
83224: PUSH
83225: LD_VAR 0 7
83229: ARRAY
83230: UNION
83231: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83232: LD_VAR 0 4
83236: PUSH
83237: LD_VAR 0 7
83241: ARRAY
83242: PPUSH
83243: CALL_OW 256
83247: PUSH
83248: LD_INT 1000
83250: EQUAL
83251: PUSH
83252: LD_VAR 0 4
83256: PUSH
83257: LD_VAR 0 7
83261: ARRAY
83262: PUSH
83263: LD_VAR 0 32
83267: IN
83268: AND
83269: IFFALSE 83293
// to_repair := to_repair diff group [ i ] ;
83271: LD_ADDR_VAR 0 32
83275: PUSH
83276: LD_VAR 0 32
83280: PUSH
83281: LD_VAR 0 4
83285: PUSH
83286: LD_VAR 0 7
83290: ARRAY
83291: DIFF
83292: ST_TO_ADDR
// if group [ i ] in to_repair then
83293: LD_VAR 0 4
83297: PUSH
83298: LD_VAR 0 7
83302: ARRAY
83303: PUSH
83304: LD_VAR 0 32
83308: IN
83309: IFFALSE 83356
// begin if not IsInArea ( group [ i ] , f_repair ) then
83311: LD_VAR 0 4
83315: PUSH
83316: LD_VAR 0 7
83320: ARRAY
83321: PPUSH
83322: LD_VAR 0 22
83326: PPUSH
83327: CALL_OW 308
83331: NOT
83332: IFFALSE 83354
// ComMoveToArea ( group [ i ] , f_repair ) ;
83334: LD_VAR 0 4
83338: PUSH
83339: LD_VAR 0 7
83343: ARRAY
83344: PPUSH
83345: LD_VAR 0 22
83349: PPUSH
83350: CALL_OW 113
// continue ;
83354: GO 82981
// end ; end else
83356: GO 83636
// if group [ i ] in repairs then
83358: LD_VAR 0 4
83362: PUSH
83363: LD_VAR 0 7
83367: ARRAY
83368: PUSH
83369: LD_VAR 0 33
83373: IN
83374: IFFALSE 83636
// begin if IsInUnit ( group [ i ] ) then
83376: LD_VAR 0 4
83380: PUSH
83381: LD_VAR 0 7
83385: ARRAY
83386: PPUSH
83387: CALL_OW 310
83391: IFFALSE 83459
// begin z := IsInUnit ( group [ i ] ) ;
83393: LD_ADDR_VAR 0 13
83397: PUSH
83398: LD_VAR 0 4
83402: PUSH
83403: LD_VAR 0 7
83407: ARRAY
83408: PPUSH
83409: CALL_OW 310
83413: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83414: LD_VAR 0 13
83418: PUSH
83419: LD_VAR 0 32
83423: IN
83424: PUSH
83425: LD_VAR 0 13
83429: PPUSH
83430: LD_VAR 0 22
83434: PPUSH
83435: CALL_OW 308
83439: AND
83440: IFFALSE 83457
// ComExitVehicle ( group [ i ] ) ;
83442: LD_VAR 0 4
83446: PUSH
83447: LD_VAR 0 7
83451: ARRAY
83452: PPUSH
83453: CALL_OW 121
// end else
83457: GO 83636
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
83459: LD_ADDR_VAR 0 13
83463: PUSH
83464: LD_VAR 0 4
83468: PPUSH
83469: LD_INT 95
83471: PUSH
83472: LD_VAR 0 22
83476: PUSH
83477: EMPTY
83478: LIST
83479: LIST
83480: PUSH
83481: LD_INT 58
83483: PUSH
83484: EMPTY
83485: LIST
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PPUSH
83491: CALL_OW 72
83495: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
83496: LD_VAR 0 4
83500: PUSH
83501: LD_VAR 0 7
83505: ARRAY
83506: PPUSH
83507: CALL_OW 314
83511: NOT
83512: IFFALSE 83634
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83514: LD_ADDR_VAR 0 10
83518: PUSH
83519: LD_VAR 0 13
83523: PPUSH
83524: LD_VAR 0 4
83528: PUSH
83529: LD_VAR 0 7
83533: ARRAY
83534: PPUSH
83535: CALL_OW 74
83539: ST_TO_ADDR
// if not x then
83540: LD_VAR 0 10
83544: NOT
83545: IFFALSE 83549
// continue ;
83547: GO 82981
// if GetLives ( x ) < 1000 then
83549: LD_VAR 0 10
83553: PPUSH
83554: CALL_OW 256
83558: PUSH
83559: LD_INT 1000
83561: LESS
83562: IFFALSE 83586
// ComRepairVehicle ( group [ i ] , x ) else
83564: LD_VAR 0 4
83568: PUSH
83569: LD_VAR 0 7
83573: ARRAY
83574: PPUSH
83575: LD_VAR 0 10
83579: PPUSH
83580: CALL_OW 129
83584: GO 83634
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83586: LD_VAR 0 23
83590: PUSH
83591: LD_VAR 0 4
83595: PUSH
83596: LD_VAR 0 7
83600: ARRAY
83601: PPUSH
83602: CALL_OW 256
83606: PUSH
83607: LD_INT 1000
83609: LESS
83610: AND
83611: NOT
83612: IFFALSE 83634
// ComEnterUnit ( group [ i ] , x ) ;
83614: LD_VAR 0 4
83618: PUSH
83619: LD_VAR 0 7
83623: ARRAY
83624: PPUSH
83625: LD_VAR 0 10
83629: PPUSH
83630: CALL_OW 120
// end ; continue ;
83634: GO 82981
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83636: LD_VAR 0 23
83640: PUSH
83641: LD_VAR 0 4
83645: PUSH
83646: LD_VAR 0 7
83650: ARRAY
83651: PPUSH
83652: CALL_OW 247
83656: PUSH
83657: LD_INT 1
83659: EQUAL
83660: AND
83661: IFFALSE 84139
// begin if group [ i ] in healers then
83663: LD_VAR 0 4
83667: PUSH
83668: LD_VAR 0 7
83672: ARRAY
83673: PUSH
83674: LD_VAR 0 31
83678: IN
83679: IFFALSE 83952
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83681: LD_VAR 0 4
83685: PUSH
83686: LD_VAR 0 7
83690: ARRAY
83691: PPUSH
83692: LD_VAR 0 23
83696: PPUSH
83697: CALL_OW 308
83701: NOT
83702: PUSH
83703: LD_VAR 0 4
83707: PUSH
83708: LD_VAR 0 7
83712: ARRAY
83713: PPUSH
83714: CALL_OW 314
83718: NOT
83719: AND
83720: IFFALSE 83744
// ComMoveToArea ( group [ i ] , f_heal ) else
83722: LD_VAR 0 4
83726: PUSH
83727: LD_VAR 0 7
83731: ARRAY
83732: PPUSH
83733: LD_VAR 0 23
83737: PPUSH
83738: CALL_OW 113
83742: GO 83950
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83744: LD_VAR 0 4
83748: PUSH
83749: LD_VAR 0 7
83753: ARRAY
83754: PPUSH
83755: CALL 44894 0 1
83759: PPUSH
83760: CALL_OW 256
83764: PUSH
83765: LD_INT 1000
83767: EQUAL
83768: IFFALSE 83787
// ComStop ( group [ i ] ) else
83770: LD_VAR 0 4
83774: PUSH
83775: LD_VAR 0 7
83779: ARRAY
83780: PPUSH
83781: CALL_OW 141
83785: GO 83950
// if not HasTask ( group [ i ] ) and to_heal then
83787: LD_VAR 0 4
83791: PUSH
83792: LD_VAR 0 7
83796: ARRAY
83797: PPUSH
83798: CALL_OW 314
83802: NOT
83803: PUSH
83804: LD_VAR 0 30
83808: AND
83809: IFFALSE 83950
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83811: LD_ADDR_VAR 0 13
83815: PUSH
83816: LD_VAR 0 30
83820: PPUSH
83821: LD_INT 3
83823: PUSH
83824: LD_INT 54
83826: PUSH
83827: EMPTY
83828: LIST
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PPUSH
83834: CALL_OW 72
83838: PPUSH
83839: LD_VAR 0 4
83843: PUSH
83844: LD_VAR 0 7
83848: ARRAY
83849: PPUSH
83850: CALL_OW 74
83854: ST_TO_ADDR
// if z then
83855: LD_VAR 0 13
83859: IFFALSE 83950
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83861: LD_INT 91
83863: PUSH
83864: LD_VAR 0 13
83868: PUSH
83869: LD_INT 10
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: LIST
83876: PUSH
83877: LD_INT 81
83879: PUSH
83880: LD_VAR 0 13
83884: PPUSH
83885: CALL_OW 255
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: EMPTY
83895: LIST
83896: LIST
83897: PPUSH
83898: CALL_OW 69
83902: PUSH
83903: LD_INT 0
83905: EQUAL
83906: IFFALSE 83930
// ComHeal ( group [ i ] , z ) else
83908: LD_VAR 0 4
83912: PUSH
83913: LD_VAR 0 7
83917: ARRAY
83918: PPUSH
83919: LD_VAR 0 13
83923: PPUSH
83924: CALL_OW 128
83928: GO 83950
// ComMoveToArea ( group [ i ] , f_heal ) ;
83930: LD_VAR 0 4
83934: PUSH
83935: LD_VAR 0 7
83939: ARRAY
83940: PPUSH
83941: LD_VAR 0 23
83945: PPUSH
83946: CALL_OW 113
// end ; continue ;
83950: GO 82981
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83952: LD_VAR 0 4
83956: PUSH
83957: LD_VAR 0 7
83961: ARRAY
83962: PPUSH
83963: CALL_OW 256
83967: PUSH
83968: LD_INT 700
83970: LESS
83971: PUSH
83972: LD_VAR 0 4
83976: PUSH
83977: LD_VAR 0 7
83981: ARRAY
83982: PUSH
83983: LD_VAR 0 30
83987: IN
83988: NOT
83989: AND
83990: IFFALSE 84014
// to_heal := to_heal union group [ i ] ;
83992: LD_ADDR_VAR 0 30
83996: PUSH
83997: LD_VAR 0 30
84001: PUSH
84002: LD_VAR 0 4
84006: PUSH
84007: LD_VAR 0 7
84011: ARRAY
84012: UNION
84013: ST_TO_ADDR
// if group [ i ] in to_heal then
84014: LD_VAR 0 4
84018: PUSH
84019: LD_VAR 0 7
84023: ARRAY
84024: PUSH
84025: LD_VAR 0 30
84029: IN
84030: IFFALSE 84139
// begin if GetLives ( group [ i ] ) = 1000 then
84032: LD_VAR 0 4
84036: PUSH
84037: LD_VAR 0 7
84041: ARRAY
84042: PPUSH
84043: CALL_OW 256
84047: PUSH
84048: LD_INT 1000
84050: EQUAL
84051: IFFALSE 84077
// to_heal := to_heal diff group [ i ] else
84053: LD_ADDR_VAR 0 30
84057: PUSH
84058: LD_VAR 0 30
84062: PUSH
84063: LD_VAR 0 4
84067: PUSH
84068: LD_VAR 0 7
84072: ARRAY
84073: DIFF
84074: ST_TO_ADDR
84075: GO 84139
// begin if not IsInArea ( group [ i ] , to_heal ) then
84077: LD_VAR 0 4
84081: PUSH
84082: LD_VAR 0 7
84086: ARRAY
84087: PPUSH
84088: LD_VAR 0 30
84092: PPUSH
84093: CALL_OW 308
84097: NOT
84098: IFFALSE 84122
// ComMoveToArea ( group [ i ] , f_heal ) else
84100: LD_VAR 0 4
84104: PUSH
84105: LD_VAR 0 7
84109: ARRAY
84110: PPUSH
84111: LD_VAR 0 23
84115: PPUSH
84116: CALL_OW 113
84120: GO 84137
// ComHold ( group [ i ] ) ;
84122: LD_VAR 0 4
84126: PUSH
84127: LD_VAR 0 7
84131: ARRAY
84132: PPUSH
84133: CALL_OW 140
// continue ;
84137: GO 82981
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84139: LD_VAR 0 4
84143: PUSH
84144: LD_VAR 0 7
84148: ARRAY
84149: PPUSH
84150: LD_INT 10
84152: PPUSH
84153: CALL 42665 0 2
84157: NOT
84158: PUSH
84159: LD_VAR 0 16
84163: PUSH
84164: LD_VAR 0 7
84168: ARRAY
84169: PUSH
84170: EMPTY
84171: EQUAL
84172: NOT
84173: AND
84174: IFFALSE 84440
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84176: LD_VAR 0 4
84180: PUSH
84181: LD_VAR 0 7
84185: ARRAY
84186: PPUSH
84187: CALL_OW 262
84191: PUSH
84192: LD_INT 1
84194: PUSH
84195: LD_INT 2
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: IN
84202: IFFALSE 84243
// if GetFuel ( group [ i ] ) < 10 then
84204: LD_VAR 0 4
84208: PUSH
84209: LD_VAR 0 7
84213: ARRAY
84214: PPUSH
84215: CALL_OW 261
84219: PUSH
84220: LD_INT 10
84222: LESS
84223: IFFALSE 84243
// SetFuel ( group [ i ] , 12 ) ;
84225: LD_VAR 0 4
84229: PUSH
84230: LD_VAR 0 7
84234: ARRAY
84235: PPUSH
84236: LD_INT 12
84238: PPUSH
84239: CALL_OW 240
// if units_path [ i ] then
84243: LD_VAR 0 16
84247: PUSH
84248: LD_VAR 0 7
84252: ARRAY
84253: IFFALSE 84438
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84255: LD_VAR 0 4
84259: PUSH
84260: LD_VAR 0 7
84264: ARRAY
84265: PPUSH
84266: LD_VAR 0 16
84270: PUSH
84271: LD_VAR 0 7
84275: ARRAY
84276: PUSH
84277: LD_INT 1
84279: ARRAY
84280: PUSH
84281: LD_INT 1
84283: ARRAY
84284: PPUSH
84285: LD_VAR 0 16
84289: PUSH
84290: LD_VAR 0 7
84294: ARRAY
84295: PUSH
84296: LD_INT 1
84298: ARRAY
84299: PUSH
84300: LD_INT 2
84302: ARRAY
84303: PPUSH
84304: CALL_OW 297
84308: PUSH
84309: LD_INT 6
84311: GREATER
84312: IFFALSE 84387
// begin if not HasTask ( group [ i ] ) then
84314: LD_VAR 0 4
84318: PUSH
84319: LD_VAR 0 7
84323: ARRAY
84324: PPUSH
84325: CALL_OW 314
84329: NOT
84330: IFFALSE 84385
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84332: LD_VAR 0 4
84336: PUSH
84337: LD_VAR 0 7
84341: ARRAY
84342: PPUSH
84343: LD_VAR 0 16
84347: PUSH
84348: LD_VAR 0 7
84352: ARRAY
84353: PUSH
84354: LD_INT 1
84356: ARRAY
84357: PUSH
84358: LD_INT 1
84360: ARRAY
84361: PPUSH
84362: LD_VAR 0 16
84366: PUSH
84367: LD_VAR 0 7
84371: ARRAY
84372: PUSH
84373: LD_INT 1
84375: ARRAY
84376: PUSH
84377: LD_INT 2
84379: ARRAY
84380: PPUSH
84381: CALL_OW 114
// end else
84385: GO 84438
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84387: LD_ADDR_VAR 0 15
84391: PUSH
84392: LD_VAR 0 16
84396: PUSH
84397: LD_VAR 0 7
84401: ARRAY
84402: PPUSH
84403: LD_INT 1
84405: PPUSH
84406: CALL_OW 3
84410: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84411: LD_ADDR_VAR 0 16
84415: PUSH
84416: LD_VAR 0 16
84420: PPUSH
84421: LD_VAR 0 7
84425: PPUSH
84426: LD_VAR 0 15
84430: PPUSH
84431: CALL_OW 1
84435: ST_TO_ADDR
// continue ;
84436: GO 82981
// end ; end ; end else
84438: GO 87102
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
84440: LD_ADDR_VAR 0 14
84444: PUSH
84445: LD_INT 81
84447: PUSH
84448: LD_VAR 0 4
84452: PUSH
84453: LD_VAR 0 7
84457: ARRAY
84458: PPUSH
84459: CALL_OW 255
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PPUSH
84468: CALL_OW 69
84472: ST_TO_ADDR
// if not tmp then
84473: LD_VAR 0 14
84477: NOT
84478: IFFALSE 84482
// continue ;
84480: GO 82981
// if f_ignore_area then
84482: LD_VAR 0 17
84486: IFFALSE 84574
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84488: LD_ADDR_VAR 0 15
84492: PUSH
84493: LD_VAR 0 14
84497: PPUSH
84498: LD_INT 3
84500: PUSH
84501: LD_INT 92
84503: PUSH
84504: LD_VAR 0 17
84508: PUSH
84509: LD_INT 1
84511: ARRAY
84512: PUSH
84513: LD_VAR 0 17
84517: PUSH
84518: LD_INT 2
84520: ARRAY
84521: PUSH
84522: LD_VAR 0 17
84526: PUSH
84527: LD_INT 3
84529: ARRAY
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: PUSH
84537: EMPTY
84538: LIST
84539: LIST
84540: PPUSH
84541: CALL_OW 72
84545: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84546: LD_VAR 0 14
84550: PUSH
84551: LD_VAR 0 15
84555: DIFF
84556: IFFALSE 84574
// tmp := tmp diff tmp2 ;
84558: LD_ADDR_VAR 0 14
84562: PUSH
84563: LD_VAR 0 14
84567: PUSH
84568: LD_VAR 0 15
84572: DIFF
84573: ST_TO_ADDR
// end ; if not f_murder then
84574: LD_VAR 0 20
84578: NOT
84579: IFFALSE 84637
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84581: LD_ADDR_VAR 0 15
84585: PUSH
84586: LD_VAR 0 14
84590: PPUSH
84591: LD_INT 3
84593: PUSH
84594: LD_INT 50
84596: PUSH
84597: EMPTY
84598: LIST
84599: PUSH
84600: EMPTY
84601: LIST
84602: LIST
84603: PPUSH
84604: CALL_OW 72
84608: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84609: LD_VAR 0 14
84613: PUSH
84614: LD_VAR 0 15
84618: DIFF
84619: IFFALSE 84637
// tmp := tmp diff tmp2 ;
84621: LD_ADDR_VAR 0 14
84625: PUSH
84626: LD_VAR 0 14
84630: PUSH
84631: LD_VAR 0 15
84635: DIFF
84636: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84637: LD_ADDR_VAR 0 14
84641: PUSH
84642: LD_VAR 0 4
84646: PUSH
84647: LD_VAR 0 7
84651: ARRAY
84652: PPUSH
84653: LD_VAR 0 14
84657: PPUSH
84658: LD_INT 1
84660: PPUSH
84661: LD_INT 1
84663: PPUSH
84664: CALL 15209 0 4
84668: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84669: LD_VAR 0 4
84673: PUSH
84674: LD_VAR 0 7
84678: ARRAY
84679: PPUSH
84680: CALL_OW 257
84684: PUSH
84685: LD_INT 1
84687: EQUAL
84688: IFFALSE 85136
// begin if WantPlant ( group [ i ] ) then
84690: LD_VAR 0 4
84694: PUSH
84695: LD_VAR 0 7
84699: ARRAY
84700: PPUSH
84701: CALL 14710 0 1
84705: IFFALSE 84709
// continue ;
84707: GO 82981
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84709: LD_VAR 0 18
84713: PUSH
84714: LD_VAR 0 4
84718: PUSH
84719: LD_VAR 0 7
84723: ARRAY
84724: PPUSH
84725: CALL_OW 310
84729: NOT
84730: AND
84731: PUSH
84732: LD_VAR 0 14
84736: PUSH
84737: LD_INT 1
84739: ARRAY
84740: PUSH
84741: LD_VAR 0 14
84745: PPUSH
84746: LD_INT 21
84748: PUSH
84749: LD_INT 2
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: LD_INT 58
84758: PUSH
84759: EMPTY
84760: LIST
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: PPUSH
84766: CALL_OW 72
84770: IN
84771: AND
84772: IFFALSE 84808
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84774: LD_VAR 0 4
84778: PUSH
84779: LD_VAR 0 7
84783: ARRAY
84784: PPUSH
84785: LD_VAR 0 14
84789: PUSH
84790: LD_INT 1
84792: ARRAY
84793: PPUSH
84794: CALL_OW 120
// attacking := true ;
84798: LD_ADDR_VAR 0 29
84802: PUSH
84803: LD_INT 1
84805: ST_TO_ADDR
// continue ;
84806: GO 82981
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84808: LD_VAR 0 26
84812: PUSH
84813: LD_VAR 0 4
84817: PUSH
84818: LD_VAR 0 7
84822: ARRAY
84823: PPUSH
84824: CALL_OW 257
84828: PUSH
84829: LD_INT 1
84831: EQUAL
84832: AND
84833: PUSH
84834: LD_VAR 0 4
84838: PUSH
84839: LD_VAR 0 7
84843: ARRAY
84844: PPUSH
84845: CALL_OW 256
84849: PUSH
84850: LD_INT 800
84852: LESS
84853: AND
84854: PUSH
84855: LD_VAR 0 4
84859: PUSH
84860: LD_VAR 0 7
84864: ARRAY
84865: PPUSH
84866: CALL_OW 318
84870: NOT
84871: AND
84872: IFFALSE 84889
// ComCrawl ( group [ i ] ) ;
84874: LD_VAR 0 4
84878: PUSH
84879: LD_VAR 0 7
84883: ARRAY
84884: PPUSH
84885: CALL_OW 137
// if f_mines then
84889: LD_VAR 0 21
84893: IFFALSE 85136
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84895: LD_VAR 0 14
84899: PUSH
84900: LD_INT 1
84902: ARRAY
84903: PPUSH
84904: CALL_OW 247
84908: PUSH
84909: LD_INT 3
84911: EQUAL
84912: PUSH
84913: LD_VAR 0 14
84917: PUSH
84918: LD_INT 1
84920: ARRAY
84921: PUSH
84922: LD_VAR 0 27
84926: IN
84927: NOT
84928: AND
84929: IFFALSE 85136
// begin x := GetX ( tmp [ 1 ] ) ;
84931: LD_ADDR_VAR 0 10
84935: PUSH
84936: LD_VAR 0 14
84940: PUSH
84941: LD_INT 1
84943: ARRAY
84944: PPUSH
84945: CALL_OW 250
84949: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84950: LD_ADDR_VAR 0 11
84954: PUSH
84955: LD_VAR 0 14
84959: PUSH
84960: LD_INT 1
84962: ARRAY
84963: PPUSH
84964: CALL_OW 251
84968: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84969: LD_ADDR_VAR 0 12
84973: PUSH
84974: LD_VAR 0 4
84978: PUSH
84979: LD_VAR 0 7
84983: ARRAY
84984: PPUSH
84985: CALL 42750 0 1
84989: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84990: LD_VAR 0 4
84994: PUSH
84995: LD_VAR 0 7
84999: ARRAY
85000: PPUSH
85001: LD_VAR 0 10
85005: PPUSH
85006: LD_VAR 0 11
85010: PPUSH
85011: LD_VAR 0 14
85015: PUSH
85016: LD_INT 1
85018: ARRAY
85019: PPUSH
85020: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85024: LD_VAR 0 4
85028: PUSH
85029: LD_VAR 0 7
85033: ARRAY
85034: PPUSH
85035: LD_VAR 0 10
85039: PPUSH
85040: LD_VAR 0 12
85044: PPUSH
85045: LD_INT 7
85047: PPUSH
85048: CALL_OW 272
85052: PPUSH
85053: LD_VAR 0 11
85057: PPUSH
85058: LD_VAR 0 12
85062: PPUSH
85063: LD_INT 7
85065: PPUSH
85066: CALL_OW 273
85070: PPUSH
85071: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85075: LD_VAR 0 4
85079: PUSH
85080: LD_VAR 0 7
85084: ARRAY
85085: PPUSH
85086: LD_INT 71
85088: PPUSH
85089: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85093: LD_ADDR_VAR 0 27
85097: PUSH
85098: LD_VAR 0 27
85102: PPUSH
85103: LD_VAR 0 27
85107: PUSH
85108: LD_INT 1
85110: PLUS
85111: PPUSH
85112: LD_VAR 0 14
85116: PUSH
85117: LD_INT 1
85119: ARRAY
85120: PPUSH
85121: CALL_OW 1
85125: ST_TO_ADDR
// attacking := true ;
85126: LD_ADDR_VAR 0 29
85130: PUSH
85131: LD_INT 1
85133: ST_TO_ADDR
// continue ;
85134: GO 82981
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85136: LD_VAR 0 4
85140: PUSH
85141: LD_VAR 0 7
85145: ARRAY
85146: PPUSH
85147: CALL_OW 257
85151: PUSH
85152: LD_INT 17
85154: EQUAL
85155: PUSH
85156: LD_VAR 0 4
85160: PUSH
85161: LD_VAR 0 7
85165: ARRAY
85166: PPUSH
85167: CALL_OW 110
85171: PUSH
85172: LD_INT 71
85174: EQUAL
85175: NOT
85176: AND
85177: IFFALSE 85323
// begin attacking := false ;
85179: LD_ADDR_VAR 0 29
85183: PUSH
85184: LD_INT 0
85186: ST_TO_ADDR
// k := 5 ;
85187: LD_ADDR_VAR 0 9
85191: PUSH
85192: LD_INT 5
85194: ST_TO_ADDR
// if tmp < k then
85195: LD_VAR 0 14
85199: PUSH
85200: LD_VAR 0 9
85204: LESS
85205: IFFALSE 85217
// k := tmp ;
85207: LD_ADDR_VAR 0 9
85211: PUSH
85212: LD_VAR 0 14
85216: ST_TO_ADDR
// for j = 1 to k do
85217: LD_ADDR_VAR 0 8
85221: PUSH
85222: DOUBLE
85223: LD_INT 1
85225: DEC
85226: ST_TO_ADDR
85227: LD_VAR 0 9
85231: PUSH
85232: FOR_TO
85233: IFFALSE 85321
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85235: LD_VAR 0 14
85239: PUSH
85240: LD_VAR 0 8
85244: ARRAY
85245: PUSH
85246: LD_VAR 0 14
85250: PPUSH
85251: LD_INT 58
85253: PUSH
85254: EMPTY
85255: LIST
85256: PPUSH
85257: CALL_OW 72
85261: IN
85262: NOT
85263: IFFALSE 85319
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85265: LD_VAR 0 4
85269: PUSH
85270: LD_VAR 0 7
85274: ARRAY
85275: PPUSH
85276: LD_VAR 0 14
85280: PUSH
85281: LD_VAR 0 8
85285: ARRAY
85286: PPUSH
85287: CALL_OW 115
// attacking := true ;
85291: LD_ADDR_VAR 0 29
85295: PUSH
85296: LD_INT 1
85298: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85299: LD_VAR 0 4
85303: PUSH
85304: LD_VAR 0 7
85308: ARRAY
85309: PPUSH
85310: LD_INT 71
85312: PPUSH
85313: CALL_OW 109
// continue ;
85317: GO 85232
// end ; end ;
85319: GO 85232
85321: POP
85322: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85323: LD_VAR 0 4
85327: PUSH
85328: LD_VAR 0 7
85332: ARRAY
85333: PPUSH
85334: CALL_OW 257
85338: PUSH
85339: LD_INT 8
85341: EQUAL
85342: PUSH
85343: LD_VAR 0 4
85347: PUSH
85348: LD_VAR 0 7
85352: ARRAY
85353: PPUSH
85354: CALL_OW 264
85358: PUSH
85359: LD_INT 28
85361: PUSH
85362: LD_INT 45
85364: PUSH
85365: LD_INT 7
85367: PUSH
85368: LD_INT 47
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: IN
85377: OR
85378: IFFALSE 85634
// begin attacking := false ;
85380: LD_ADDR_VAR 0 29
85384: PUSH
85385: LD_INT 0
85387: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85388: LD_VAR 0 14
85392: PUSH
85393: LD_INT 1
85395: ARRAY
85396: PPUSH
85397: CALL_OW 266
85401: PUSH
85402: LD_INT 32
85404: PUSH
85405: LD_INT 31
85407: PUSH
85408: LD_INT 33
85410: PUSH
85411: LD_INT 4
85413: PUSH
85414: LD_INT 5
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: IN
85424: IFFALSE 85610
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85426: LD_ADDR_VAR 0 9
85430: PUSH
85431: LD_VAR 0 14
85435: PUSH
85436: LD_INT 1
85438: ARRAY
85439: PPUSH
85440: CALL_OW 266
85444: PPUSH
85445: LD_VAR 0 14
85449: PUSH
85450: LD_INT 1
85452: ARRAY
85453: PPUSH
85454: CALL_OW 250
85458: PPUSH
85459: LD_VAR 0 14
85463: PUSH
85464: LD_INT 1
85466: ARRAY
85467: PPUSH
85468: CALL_OW 251
85472: PPUSH
85473: LD_VAR 0 14
85477: PUSH
85478: LD_INT 1
85480: ARRAY
85481: PPUSH
85482: CALL_OW 254
85486: PPUSH
85487: LD_VAR 0 14
85491: PUSH
85492: LD_INT 1
85494: ARRAY
85495: PPUSH
85496: CALL_OW 248
85500: PPUSH
85501: LD_INT 0
85503: PPUSH
85504: CALL 24120 0 6
85508: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85509: LD_ADDR_VAR 0 8
85513: PUSH
85514: LD_VAR 0 4
85518: PUSH
85519: LD_VAR 0 7
85523: ARRAY
85524: PPUSH
85525: LD_VAR 0 9
85529: PPUSH
85530: CALL 42863 0 2
85534: ST_TO_ADDR
// if j then
85535: LD_VAR 0 8
85539: IFFALSE 85608
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85541: LD_VAR 0 8
85545: PUSH
85546: LD_INT 1
85548: ARRAY
85549: PPUSH
85550: LD_VAR 0 8
85554: PUSH
85555: LD_INT 2
85557: ARRAY
85558: PPUSH
85559: CALL_OW 488
85563: IFFALSE 85608
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85565: LD_VAR 0 4
85569: PUSH
85570: LD_VAR 0 7
85574: ARRAY
85575: PPUSH
85576: LD_VAR 0 8
85580: PUSH
85581: LD_INT 1
85583: ARRAY
85584: PPUSH
85585: LD_VAR 0 8
85589: PUSH
85590: LD_INT 2
85592: ARRAY
85593: PPUSH
85594: CALL_OW 116
// attacking := true ;
85598: LD_ADDR_VAR 0 29
85602: PUSH
85603: LD_INT 1
85605: ST_TO_ADDR
// continue ;
85606: GO 82981
// end ; end else
85608: GO 85634
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85610: LD_VAR 0 4
85614: PUSH
85615: LD_VAR 0 7
85619: ARRAY
85620: PPUSH
85621: LD_VAR 0 14
85625: PUSH
85626: LD_INT 1
85628: ARRAY
85629: PPUSH
85630: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85634: LD_VAR 0 4
85638: PUSH
85639: LD_VAR 0 7
85643: ARRAY
85644: PPUSH
85645: CALL_OW 265
85649: PUSH
85650: LD_INT 11
85652: EQUAL
85653: IFFALSE 85931
// begin k := 10 ;
85655: LD_ADDR_VAR 0 9
85659: PUSH
85660: LD_INT 10
85662: ST_TO_ADDR
// x := 0 ;
85663: LD_ADDR_VAR 0 10
85667: PUSH
85668: LD_INT 0
85670: ST_TO_ADDR
// if tmp < k then
85671: LD_VAR 0 14
85675: PUSH
85676: LD_VAR 0 9
85680: LESS
85681: IFFALSE 85693
// k := tmp ;
85683: LD_ADDR_VAR 0 9
85687: PUSH
85688: LD_VAR 0 14
85692: ST_TO_ADDR
// for j = k downto 1 do
85693: LD_ADDR_VAR 0 8
85697: PUSH
85698: DOUBLE
85699: LD_VAR 0 9
85703: INC
85704: ST_TO_ADDR
85705: LD_INT 1
85707: PUSH
85708: FOR_DOWNTO
85709: IFFALSE 85784
// begin if GetType ( tmp [ j ] ) = unit_human then
85711: LD_VAR 0 14
85715: PUSH
85716: LD_VAR 0 8
85720: ARRAY
85721: PPUSH
85722: CALL_OW 247
85726: PUSH
85727: LD_INT 1
85729: EQUAL
85730: IFFALSE 85782
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85732: LD_VAR 0 4
85736: PUSH
85737: LD_VAR 0 7
85741: ARRAY
85742: PPUSH
85743: LD_VAR 0 14
85747: PUSH
85748: LD_VAR 0 8
85752: ARRAY
85753: PPUSH
85754: CALL 43117 0 2
// x := tmp [ j ] ;
85758: LD_ADDR_VAR 0 10
85762: PUSH
85763: LD_VAR 0 14
85767: PUSH
85768: LD_VAR 0 8
85772: ARRAY
85773: ST_TO_ADDR
// attacking := true ;
85774: LD_ADDR_VAR 0 29
85778: PUSH
85779: LD_INT 1
85781: ST_TO_ADDR
// end ; end ;
85782: GO 85708
85784: POP
85785: POP
// if not x then
85786: LD_VAR 0 10
85790: NOT
85791: IFFALSE 85931
// begin attacking := true ;
85793: LD_ADDR_VAR 0 29
85797: PUSH
85798: LD_INT 1
85800: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85801: LD_VAR 0 4
85805: PUSH
85806: LD_VAR 0 7
85810: ARRAY
85811: PPUSH
85812: CALL_OW 250
85816: PPUSH
85817: LD_VAR 0 4
85821: PUSH
85822: LD_VAR 0 7
85826: ARRAY
85827: PPUSH
85828: CALL_OW 251
85832: PPUSH
85833: CALL_OW 546
85837: PUSH
85838: LD_INT 2
85840: ARRAY
85841: PUSH
85842: LD_VAR 0 14
85846: PUSH
85847: LD_INT 1
85849: ARRAY
85850: PPUSH
85851: CALL_OW 250
85855: PPUSH
85856: LD_VAR 0 14
85860: PUSH
85861: LD_INT 1
85863: ARRAY
85864: PPUSH
85865: CALL_OW 251
85869: PPUSH
85870: CALL_OW 546
85874: PUSH
85875: LD_INT 2
85877: ARRAY
85878: EQUAL
85879: IFFALSE 85907
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85881: LD_VAR 0 4
85885: PUSH
85886: LD_VAR 0 7
85890: ARRAY
85891: PPUSH
85892: LD_VAR 0 14
85896: PUSH
85897: LD_INT 1
85899: ARRAY
85900: PPUSH
85901: CALL 43117 0 2
85905: GO 85931
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85907: LD_VAR 0 4
85911: PUSH
85912: LD_VAR 0 7
85916: ARRAY
85917: PPUSH
85918: LD_VAR 0 14
85922: PUSH
85923: LD_INT 1
85925: ARRAY
85926: PPUSH
85927: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85931: LD_VAR 0 4
85935: PUSH
85936: LD_VAR 0 7
85940: ARRAY
85941: PPUSH
85942: CALL_OW 264
85946: PUSH
85947: LD_INT 29
85949: EQUAL
85950: IFFALSE 86316
// begin if WantsToAttack ( group [ i ] ) in bombed then
85952: LD_VAR 0 4
85956: PUSH
85957: LD_VAR 0 7
85961: ARRAY
85962: PPUSH
85963: CALL_OW 319
85967: PUSH
85968: LD_VAR 0 28
85972: IN
85973: IFFALSE 85977
// continue ;
85975: GO 82981
// k := 8 ;
85977: LD_ADDR_VAR 0 9
85981: PUSH
85982: LD_INT 8
85984: ST_TO_ADDR
// x := 0 ;
85985: LD_ADDR_VAR 0 10
85989: PUSH
85990: LD_INT 0
85992: ST_TO_ADDR
// if tmp < k then
85993: LD_VAR 0 14
85997: PUSH
85998: LD_VAR 0 9
86002: LESS
86003: IFFALSE 86015
// k := tmp ;
86005: LD_ADDR_VAR 0 9
86009: PUSH
86010: LD_VAR 0 14
86014: ST_TO_ADDR
// for j = 1 to k do
86015: LD_ADDR_VAR 0 8
86019: PUSH
86020: DOUBLE
86021: LD_INT 1
86023: DEC
86024: ST_TO_ADDR
86025: LD_VAR 0 9
86029: PUSH
86030: FOR_TO
86031: IFFALSE 86163
// begin if GetType ( tmp [ j ] ) = unit_building then
86033: LD_VAR 0 14
86037: PUSH
86038: LD_VAR 0 8
86042: ARRAY
86043: PPUSH
86044: CALL_OW 247
86048: PUSH
86049: LD_INT 3
86051: EQUAL
86052: IFFALSE 86161
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86054: LD_VAR 0 14
86058: PUSH
86059: LD_VAR 0 8
86063: ARRAY
86064: PUSH
86065: LD_VAR 0 28
86069: IN
86070: NOT
86071: PUSH
86072: LD_VAR 0 14
86076: PUSH
86077: LD_VAR 0 8
86081: ARRAY
86082: PPUSH
86083: CALL_OW 313
86087: AND
86088: IFFALSE 86161
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86090: LD_VAR 0 4
86094: PUSH
86095: LD_VAR 0 7
86099: ARRAY
86100: PPUSH
86101: LD_VAR 0 14
86105: PUSH
86106: LD_VAR 0 8
86110: ARRAY
86111: PPUSH
86112: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86116: LD_ADDR_VAR 0 28
86120: PUSH
86121: LD_VAR 0 28
86125: PPUSH
86126: LD_VAR 0 28
86130: PUSH
86131: LD_INT 1
86133: PLUS
86134: PPUSH
86135: LD_VAR 0 14
86139: PUSH
86140: LD_VAR 0 8
86144: ARRAY
86145: PPUSH
86146: CALL_OW 1
86150: ST_TO_ADDR
// attacking := true ;
86151: LD_ADDR_VAR 0 29
86155: PUSH
86156: LD_INT 1
86158: ST_TO_ADDR
// break ;
86159: GO 86163
// end ; end ;
86161: GO 86030
86163: POP
86164: POP
// if not attacking and f_attack_depot then
86165: LD_VAR 0 29
86169: NOT
86170: PUSH
86171: LD_VAR 0 25
86175: AND
86176: IFFALSE 86271
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86178: LD_ADDR_VAR 0 13
86182: PUSH
86183: LD_VAR 0 14
86187: PPUSH
86188: LD_INT 2
86190: PUSH
86191: LD_INT 30
86193: PUSH
86194: LD_INT 0
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 30
86203: PUSH
86204: LD_INT 1
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: EMPTY
86212: LIST
86213: LIST
86214: LIST
86215: PPUSH
86216: CALL_OW 72
86220: ST_TO_ADDR
// if z then
86221: LD_VAR 0 13
86225: IFFALSE 86271
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86227: LD_VAR 0 4
86231: PUSH
86232: LD_VAR 0 7
86236: ARRAY
86237: PPUSH
86238: LD_VAR 0 13
86242: PPUSH
86243: LD_VAR 0 4
86247: PUSH
86248: LD_VAR 0 7
86252: ARRAY
86253: PPUSH
86254: CALL_OW 74
86258: PPUSH
86259: CALL_OW 115
// attacking := true ;
86263: LD_ADDR_VAR 0 29
86267: PUSH
86268: LD_INT 1
86270: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86271: LD_VAR 0 4
86275: PUSH
86276: LD_VAR 0 7
86280: ARRAY
86281: PPUSH
86282: CALL_OW 256
86286: PUSH
86287: LD_INT 500
86289: LESS
86290: IFFALSE 86316
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86292: LD_VAR 0 4
86296: PUSH
86297: LD_VAR 0 7
86301: ARRAY
86302: PPUSH
86303: LD_VAR 0 14
86307: PUSH
86308: LD_INT 1
86310: ARRAY
86311: PPUSH
86312: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86316: LD_VAR 0 4
86320: PUSH
86321: LD_VAR 0 7
86325: ARRAY
86326: PPUSH
86327: CALL_OW 264
86331: PUSH
86332: LD_INT 49
86334: EQUAL
86335: IFFALSE 86456
// begin if not HasTask ( group [ i ] ) then
86337: LD_VAR 0 4
86341: PUSH
86342: LD_VAR 0 7
86346: ARRAY
86347: PPUSH
86348: CALL_OW 314
86352: NOT
86353: IFFALSE 86456
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86355: LD_ADDR_VAR 0 9
86359: PUSH
86360: LD_INT 81
86362: PUSH
86363: LD_VAR 0 4
86367: PUSH
86368: LD_VAR 0 7
86372: ARRAY
86373: PPUSH
86374: CALL_OW 255
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: PPUSH
86383: CALL_OW 69
86387: PPUSH
86388: LD_VAR 0 4
86392: PUSH
86393: LD_VAR 0 7
86397: ARRAY
86398: PPUSH
86399: CALL_OW 74
86403: ST_TO_ADDR
// if k then
86404: LD_VAR 0 9
86408: IFFALSE 86456
// if GetDistUnits ( group [ i ] , k ) > 10 then
86410: LD_VAR 0 4
86414: PUSH
86415: LD_VAR 0 7
86419: ARRAY
86420: PPUSH
86421: LD_VAR 0 9
86425: PPUSH
86426: CALL_OW 296
86430: PUSH
86431: LD_INT 10
86433: GREATER
86434: IFFALSE 86456
// ComMoveUnit ( group [ i ] , k ) ;
86436: LD_VAR 0 4
86440: PUSH
86441: LD_VAR 0 7
86445: ARRAY
86446: PPUSH
86447: LD_VAR 0 9
86451: PPUSH
86452: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86456: LD_VAR 0 4
86460: PUSH
86461: LD_VAR 0 7
86465: ARRAY
86466: PPUSH
86467: CALL_OW 256
86471: PUSH
86472: LD_INT 250
86474: LESS
86475: PUSH
86476: LD_VAR 0 4
86480: PUSH
86481: LD_VAR 0 7
86485: ARRAY
86486: PUSH
86487: LD_INT 21
86489: PUSH
86490: LD_INT 2
86492: PUSH
86493: EMPTY
86494: LIST
86495: LIST
86496: PUSH
86497: LD_INT 23
86499: PUSH
86500: LD_INT 2
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: PPUSH
86511: CALL_OW 69
86515: IN
86516: AND
86517: IFFALSE 86642
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86519: LD_ADDR_VAR 0 9
86523: PUSH
86524: LD_OWVAR 3
86528: PUSH
86529: LD_VAR 0 4
86533: PUSH
86534: LD_VAR 0 7
86538: ARRAY
86539: DIFF
86540: PPUSH
86541: LD_VAR 0 4
86545: PUSH
86546: LD_VAR 0 7
86550: ARRAY
86551: PPUSH
86552: CALL_OW 74
86556: ST_TO_ADDR
// if not k then
86557: LD_VAR 0 9
86561: NOT
86562: IFFALSE 86566
// continue ;
86564: GO 82981
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86566: LD_VAR 0 9
86570: PUSH
86571: LD_INT 81
86573: PUSH
86574: LD_VAR 0 4
86578: PUSH
86579: LD_VAR 0 7
86583: ARRAY
86584: PPUSH
86585: CALL_OW 255
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PPUSH
86594: CALL_OW 69
86598: IN
86599: PUSH
86600: LD_VAR 0 9
86604: PPUSH
86605: LD_VAR 0 4
86609: PUSH
86610: LD_VAR 0 7
86614: ARRAY
86615: PPUSH
86616: CALL_OW 296
86620: PUSH
86621: LD_INT 5
86623: LESS
86624: AND
86625: IFFALSE 86642
// ComAutodestruct ( group [ i ] ) ;
86627: LD_VAR 0 4
86631: PUSH
86632: LD_VAR 0 7
86636: ARRAY
86637: PPUSH
86638: CALL 43015 0 1
// end ; if f_attack_depot then
86642: LD_VAR 0 25
86646: IFFALSE 86758
// begin k := 6 ;
86648: LD_ADDR_VAR 0 9
86652: PUSH
86653: LD_INT 6
86655: ST_TO_ADDR
// if tmp < k then
86656: LD_VAR 0 14
86660: PUSH
86661: LD_VAR 0 9
86665: LESS
86666: IFFALSE 86678
// k := tmp ;
86668: LD_ADDR_VAR 0 9
86672: PUSH
86673: LD_VAR 0 14
86677: ST_TO_ADDR
// for j = 1 to k do
86678: LD_ADDR_VAR 0 8
86682: PUSH
86683: DOUBLE
86684: LD_INT 1
86686: DEC
86687: ST_TO_ADDR
86688: LD_VAR 0 9
86692: PUSH
86693: FOR_TO
86694: IFFALSE 86756
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86696: LD_VAR 0 8
86700: PPUSH
86701: CALL_OW 266
86705: PUSH
86706: LD_INT 0
86708: PUSH
86709: LD_INT 1
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: IN
86716: IFFALSE 86754
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86718: LD_VAR 0 4
86722: PUSH
86723: LD_VAR 0 7
86727: ARRAY
86728: PPUSH
86729: LD_VAR 0 14
86733: PUSH
86734: LD_VAR 0 8
86738: ARRAY
86739: PPUSH
86740: CALL_OW 115
// attacking := true ;
86744: LD_ADDR_VAR 0 29
86748: PUSH
86749: LD_INT 1
86751: ST_TO_ADDR
// break ;
86752: GO 86756
// end ;
86754: GO 86693
86756: POP
86757: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86758: LD_VAR 0 4
86762: PUSH
86763: LD_VAR 0 7
86767: ARRAY
86768: PPUSH
86769: CALL_OW 302
86773: PUSH
86774: LD_VAR 0 29
86778: NOT
86779: AND
86780: IFFALSE 87102
// begin if GetTag ( group [ i ] ) = 71 then
86782: LD_VAR 0 4
86786: PUSH
86787: LD_VAR 0 7
86791: ARRAY
86792: PPUSH
86793: CALL_OW 110
86797: PUSH
86798: LD_INT 71
86800: EQUAL
86801: IFFALSE 86842
// begin if HasTask ( group [ i ] ) then
86803: LD_VAR 0 4
86807: PUSH
86808: LD_VAR 0 7
86812: ARRAY
86813: PPUSH
86814: CALL_OW 314
86818: IFFALSE 86824
// continue else
86820: GO 82981
86822: GO 86842
// SetTag ( group [ i ] , 0 ) ;
86824: LD_VAR 0 4
86828: PUSH
86829: LD_VAR 0 7
86833: ARRAY
86834: PPUSH
86835: LD_INT 0
86837: PPUSH
86838: CALL_OW 109
// end ; k := 8 ;
86842: LD_ADDR_VAR 0 9
86846: PUSH
86847: LD_INT 8
86849: ST_TO_ADDR
// x := 0 ;
86850: LD_ADDR_VAR 0 10
86854: PUSH
86855: LD_INT 0
86857: ST_TO_ADDR
// if tmp < k then
86858: LD_VAR 0 14
86862: PUSH
86863: LD_VAR 0 9
86867: LESS
86868: IFFALSE 86880
// k := tmp ;
86870: LD_ADDR_VAR 0 9
86874: PUSH
86875: LD_VAR 0 14
86879: ST_TO_ADDR
// for j = 1 to k do
86880: LD_ADDR_VAR 0 8
86884: PUSH
86885: DOUBLE
86886: LD_INT 1
86888: DEC
86889: ST_TO_ADDR
86890: LD_VAR 0 9
86894: PUSH
86895: FOR_TO
86896: IFFALSE 86994
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86898: LD_VAR 0 14
86902: PUSH
86903: LD_VAR 0 8
86907: ARRAY
86908: PPUSH
86909: CALL_OW 247
86913: PUSH
86914: LD_INT 1
86916: EQUAL
86917: PUSH
86918: LD_VAR 0 14
86922: PUSH
86923: LD_VAR 0 8
86927: ARRAY
86928: PPUSH
86929: CALL_OW 256
86933: PUSH
86934: LD_INT 250
86936: LESS
86937: PUSH
86938: LD_VAR 0 20
86942: AND
86943: PUSH
86944: LD_VAR 0 20
86948: NOT
86949: PUSH
86950: LD_VAR 0 14
86954: PUSH
86955: LD_VAR 0 8
86959: ARRAY
86960: PPUSH
86961: CALL_OW 256
86965: PUSH
86966: LD_INT 250
86968: GREATEREQUAL
86969: AND
86970: OR
86971: AND
86972: IFFALSE 86992
// begin x := tmp [ j ] ;
86974: LD_ADDR_VAR 0 10
86978: PUSH
86979: LD_VAR 0 14
86983: PUSH
86984: LD_VAR 0 8
86988: ARRAY
86989: ST_TO_ADDR
// break ;
86990: GO 86994
// end ;
86992: GO 86895
86994: POP
86995: POP
// if x then
86996: LD_VAR 0 10
87000: IFFALSE 87024
// ComAttackUnit ( group [ i ] , x ) else
87002: LD_VAR 0 4
87006: PUSH
87007: LD_VAR 0 7
87011: ARRAY
87012: PPUSH
87013: LD_VAR 0 10
87017: PPUSH
87018: CALL_OW 115
87022: GO 87048
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87024: LD_VAR 0 4
87028: PUSH
87029: LD_VAR 0 7
87033: ARRAY
87034: PPUSH
87035: LD_VAR 0 14
87039: PUSH
87040: LD_INT 1
87042: ARRAY
87043: PPUSH
87044: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87048: LD_VAR 0 4
87052: PUSH
87053: LD_VAR 0 7
87057: ARRAY
87058: PPUSH
87059: CALL_OW 314
87063: NOT
87064: IFFALSE 87102
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87066: LD_VAR 0 4
87070: PUSH
87071: LD_VAR 0 7
87075: ARRAY
87076: PPUSH
87077: LD_VAR 0 14
87081: PPUSH
87082: LD_VAR 0 4
87086: PUSH
87087: LD_VAR 0 7
87091: ARRAY
87092: PPUSH
87093: CALL_OW 74
87097: PPUSH
87098: CALL_OW 115
// end ; end ; end ;
87102: GO 82981
87104: POP
87105: POP
// wait ( 0 0$2 ) ;
87106: LD_INT 70
87108: PPUSH
87109: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87113: LD_VAR 0 4
87117: NOT
87118: PUSH
87119: LD_VAR 0 4
87123: PUSH
87124: EMPTY
87125: EQUAL
87126: OR
87127: PUSH
87128: LD_INT 81
87130: PUSH
87131: LD_VAR 0 35
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PPUSH
87140: CALL_OW 69
87144: NOT
87145: OR
87146: IFFALSE 82966
// end ;
87148: LD_VAR 0 2
87152: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
87153: LD_INT 0
87155: PPUSH
87156: PPUSH
87157: PPUSH
87158: PPUSH
87159: PPUSH
87160: PPUSH
// if not base or not mc_bases [ base ] or not solds then
87161: LD_VAR 0 1
87165: NOT
87166: PUSH
87167: LD_EXP 43
87171: PUSH
87172: LD_VAR 0 1
87176: ARRAY
87177: NOT
87178: OR
87179: PUSH
87180: LD_VAR 0 2
87184: NOT
87185: OR
87186: IFFALSE 87190
// exit ;
87188: GO 87744
// side := mc_sides [ base ] ;
87190: LD_ADDR_VAR 0 6
87194: PUSH
87195: LD_EXP 69
87199: PUSH
87200: LD_VAR 0 1
87204: ARRAY
87205: ST_TO_ADDR
// if not side then
87206: LD_VAR 0 6
87210: NOT
87211: IFFALSE 87215
// exit ;
87213: GO 87744
// for i in solds do
87215: LD_ADDR_VAR 0 7
87219: PUSH
87220: LD_VAR 0 2
87224: PUSH
87225: FOR_IN
87226: IFFALSE 87287
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
87228: LD_VAR 0 7
87232: PPUSH
87233: CALL_OW 310
87237: PPUSH
87238: CALL_OW 266
87242: PUSH
87243: LD_INT 32
87245: PUSH
87246: LD_INT 31
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: IN
87253: IFFALSE 87273
// solds := solds diff i else
87255: LD_ADDR_VAR 0 2
87259: PUSH
87260: LD_VAR 0 2
87264: PUSH
87265: LD_VAR 0 7
87269: DIFF
87270: ST_TO_ADDR
87271: GO 87285
// SetTag ( i , 18 ) ;
87273: LD_VAR 0 7
87277: PPUSH
87278: LD_INT 18
87280: PPUSH
87281: CALL_OW 109
87285: GO 87225
87287: POP
87288: POP
// if not solds then
87289: LD_VAR 0 2
87293: NOT
87294: IFFALSE 87298
// exit ;
87296: GO 87744
// repeat wait ( 0 0$2 ) ;
87298: LD_INT 70
87300: PPUSH
87301: CALL_OW 67
// enemy := mc_scan [ base ] ;
87305: LD_ADDR_VAR 0 4
87309: PUSH
87310: LD_EXP 66
87314: PUSH
87315: LD_VAR 0 1
87319: ARRAY
87320: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87321: LD_EXP 43
87325: PUSH
87326: LD_VAR 0 1
87330: ARRAY
87331: NOT
87332: PUSH
87333: LD_EXP 43
87337: PUSH
87338: LD_VAR 0 1
87342: ARRAY
87343: PUSH
87344: EMPTY
87345: EQUAL
87346: OR
87347: IFFALSE 87384
// begin for i in solds do
87349: LD_ADDR_VAR 0 7
87353: PUSH
87354: LD_VAR 0 2
87358: PUSH
87359: FOR_IN
87360: IFFALSE 87373
// ComStop ( i ) ;
87362: LD_VAR 0 7
87366: PPUSH
87367: CALL_OW 141
87371: GO 87359
87373: POP
87374: POP
// solds := [ ] ;
87375: LD_ADDR_VAR 0 2
87379: PUSH
87380: EMPTY
87381: ST_TO_ADDR
// exit ;
87382: GO 87744
// end ; for i in solds do
87384: LD_ADDR_VAR 0 7
87388: PUSH
87389: LD_VAR 0 2
87393: PUSH
87394: FOR_IN
87395: IFFALSE 87716
// begin if IsInUnit ( i ) then
87397: LD_VAR 0 7
87401: PPUSH
87402: CALL_OW 310
87406: IFFALSE 87417
// ComExitBuilding ( i ) ;
87408: LD_VAR 0 7
87412: PPUSH
87413: CALL_OW 122
// if GetLives ( i ) > 500 then
87417: LD_VAR 0 7
87421: PPUSH
87422: CALL_OW 256
87426: PUSH
87427: LD_INT 500
87429: GREATER
87430: IFFALSE 87483
// begin e := NearestUnitToUnit ( enemy , i ) ;
87432: LD_ADDR_VAR 0 5
87436: PUSH
87437: LD_VAR 0 4
87441: PPUSH
87442: LD_VAR 0 7
87446: PPUSH
87447: CALL_OW 74
87451: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
87452: LD_VAR 0 7
87456: PPUSH
87457: LD_VAR 0 5
87461: PPUSH
87462: CALL_OW 250
87466: PPUSH
87467: LD_VAR 0 5
87471: PPUSH
87472: CALL_OW 251
87476: PPUSH
87477: CALL_OW 114
// end else
87481: GO 87714
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
87483: LD_VAR 0 7
87487: PPUSH
87488: LD_EXP 43
87492: PUSH
87493: LD_VAR 0 1
87497: ARRAY
87498: PPUSH
87499: LD_INT 2
87501: PUSH
87502: LD_INT 30
87504: PUSH
87505: LD_INT 0
87507: PUSH
87508: EMPTY
87509: LIST
87510: LIST
87511: PUSH
87512: LD_INT 30
87514: PUSH
87515: LD_INT 1
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 30
87524: PUSH
87525: LD_INT 6
87527: PUSH
87528: EMPTY
87529: LIST
87530: LIST
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: PPUSH
87538: CALL_OW 72
87542: PPUSH
87543: LD_VAR 0 7
87547: PPUSH
87548: CALL_OW 74
87552: PPUSH
87553: CALL_OW 296
87557: PUSH
87558: LD_INT 10
87560: GREATER
87561: IFFALSE 87714
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
87563: LD_ADDR_VAR 0 8
87567: PUSH
87568: LD_EXP 43
87572: PUSH
87573: LD_VAR 0 1
87577: ARRAY
87578: PPUSH
87579: LD_INT 2
87581: PUSH
87582: LD_INT 30
87584: PUSH
87585: LD_INT 0
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: PUSH
87592: LD_INT 30
87594: PUSH
87595: LD_INT 1
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 30
87604: PUSH
87605: LD_INT 6
87607: PUSH
87608: EMPTY
87609: LIST
87610: LIST
87611: PUSH
87612: EMPTY
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: PPUSH
87618: CALL_OW 72
87622: PPUSH
87623: LD_VAR 0 7
87627: PPUSH
87628: CALL_OW 74
87632: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87633: LD_VAR 0 7
87637: PPUSH
87638: LD_VAR 0 8
87642: PPUSH
87643: CALL_OW 250
87647: PPUSH
87648: LD_INT 3
87650: PPUSH
87651: LD_INT 5
87653: PPUSH
87654: CALL_OW 272
87658: PPUSH
87659: LD_VAR 0 8
87663: PPUSH
87664: CALL_OW 251
87668: PPUSH
87669: LD_INT 3
87671: PPUSH
87672: LD_INT 5
87674: PPUSH
87675: CALL_OW 273
87679: PPUSH
87680: CALL_OW 111
// SetTag ( i , 0 ) ;
87684: LD_VAR 0 7
87688: PPUSH
87689: LD_INT 0
87691: PPUSH
87692: CALL_OW 109
// solds := solds diff i ;
87696: LD_ADDR_VAR 0 2
87700: PUSH
87701: LD_VAR 0 2
87705: PUSH
87706: LD_VAR 0 7
87710: DIFF
87711: ST_TO_ADDR
// continue ;
87712: GO 87394
// end ; end ;
87714: GO 87394
87716: POP
87717: POP
// until not solds or not enemy ;
87718: LD_VAR 0 2
87722: NOT
87723: PUSH
87724: LD_VAR 0 4
87728: NOT
87729: OR
87730: IFFALSE 87298
// MC_Reset ( base , 18 ) ;
87732: LD_VAR 0 1
87736: PPUSH
87737: LD_INT 18
87739: PPUSH
87740: CALL 55905 0 2
// end ;
87744: LD_VAR 0 3
87748: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87749: LD_INT 0
87751: PPUSH
87752: PPUSH
87753: PPUSH
87754: PPUSH
87755: PPUSH
87756: PPUSH
87757: PPUSH
87758: PPUSH
87759: PPUSH
87760: PPUSH
87761: PPUSH
87762: PPUSH
87763: PPUSH
87764: PPUSH
87765: PPUSH
87766: PPUSH
87767: PPUSH
87768: PPUSH
87769: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87770: LD_ADDR_VAR 0 12
87774: PUSH
87775: LD_EXP 43
87779: PUSH
87780: LD_VAR 0 1
87784: ARRAY
87785: PPUSH
87786: LD_INT 25
87788: PUSH
87789: LD_INT 3
87791: PUSH
87792: EMPTY
87793: LIST
87794: LIST
87795: PPUSH
87796: CALL_OW 72
87800: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87801: LD_EXP 83
87805: PUSH
87806: LD_VAR 0 1
87810: ARRAY
87811: IFFALSE 87835
// mechs := mechs diff mc_remote_driver [ base ] ;
87813: LD_ADDR_VAR 0 12
87817: PUSH
87818: LD_VAR 0 12
87822: PUSH
87823: LD_EXP 83
87827: PUSH
87828: LD_VAR 0 1
87832: ARRAY
87833: DIFF
87834: ST_TO_ADDR
// for i in mechs do
87835: LD_ADDR_VAR 0 4
87839: PUSH
87840: LD_VAR 0 12
87844: PUSH
87845: FOR_IN
87846: IFFALSE 87881
// if GetTag ( i ) > 0 then
87848: LD_VAR 0 4
87852: PPUSH
87853: CALL_OW 110
87857: PUSH
87858: LD_INT 0
87860: GREATER
87861: IFFALSE 87879
// mechs := mechs diff i ;
87863: LD_ADDR_VAR 0 12
87867: PUSH
87868: LD_VAR 0 12
87872: PUSH
87873: LD_VAR 0 4
87877: DIFF
87878: ST_TO_ADDR
87879: GO 87845
87881: POP
87882: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87883: LD_ADDR_VAR 0 8
87887: PUSH
87888: LD_EXP 43
87892: PUSH
87893: LD_VAR 0 1
87897: ARRAY
87898: PPUSH
87899: LD_INT 2
87901: PUSH
87902: LD_INT 25
87904: PUSH
87905: LD_INT 1
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PUSH
87912: LD_INT 25
87914: PUSH
87915: LD_INT 5
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 25
87924: PUSH
87925: LD_INT 8
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 25
87934: PUSH
87935: LD_INT 9
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: LIST
87946: LIST
87947: LIST
87948: PPUSH
87949: CALL_OW 72
87953: ST_TO_ADDR
// if not defenders and not solds then
87954: LD_VAR 0 2
87958: NOT
87959: PUSH
87960: LD_VAR 0 8
87964: NOT
87965: AND
87966: IFFALSE 87970
// exit ;
87968: GO 89740
// depot_under_attack := false ;
87970: LD_ADDR_VAR 0 16
87974: PUSH
87975: LD_INT 0
87977: ST_TO_ADDR
// sold_defenders := [ ] ;
87978: LD_ADDR_VAR 0 17
87982: PUSH
87983: EMPTY
87984: ST_TO_ADDR
// if mechs then
87985: LD_VAR 0 12
87989: IFFALSE 88142
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87991: LD_ADDR_VAR 0 4
87995: PUSH
87996: LD_VAR 0 2
88000: PPUSH
88001: LD_INT 21
88003: PUSH
88004: LD_INT 2
88006: PUSH
88007: EMPTY
88008: LIST
88009: LIST
88010: PPUSH
88011: CALL_OW 72
88015: PUSH
88016: FOR_IN
88017: IFFALSE 88140
// begin if GetTag ( i ) <> 20 then
88019: LD_VAR 0 4
88023: PPUSH
88024: CALL_OW 110
88028: PUSH
88029: LD_INT 20
88031: NONEQUAL
88032: IFFALSE 88046
// SetTag ( i , 20 ) ;
88034: LD_VAR 0 4
88038: PPUSH
88039: LD_INT 20
88041: PPUSH
88042: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
88046: LD_VAR 0 4
88050: PPUSH
88051: CALL_OW 263
88055: PUSH
88056: LD_INT 1
88058: EQUAL
88059: PUSH
88060: LD_VAR 0 4
88064: PPUSH
88065: CALL_OW 311
88069: NOT
88070: AND
88071: IFFALSE 88138
// begin un := mechs [ 1 ] ;
88073: LD_ADDR_VAR 0 10
88077: PUSH
88078: LD_VAR 0 12
88082: PUSH
88083: LD_INT 1
88085: ARRAY
88086: ST_TO_ADDR
// ComExit ( un ) ;
88087: LD_VAR 0 10
88091: PPUSH
88092: CALL 47912 0 1
// AddComEnterUnit ( un , i ) ;
88096: LD_VAR 0 10
88100: PPUSH
88101: LD_VAR 0 4
88105: PPUSH
88106: CALL_OW 180
// SetTag ( un , 19 ) ;
88110: LD_VAR 0 10
88114: PPUSH
88115: LD_INT 19
88117: PPUSH
88118: CALL_OW 109
// mechs := mechs diff un ;
88122: LD_ADDR_VAR 0 12
88126: PUSH
88127: LD_VAR 0 12
88131: PUSH
88132: LD_VAR 0 10
88136: DIFF
88137: ST_TO_ADDR
// end ; end ;
88138: GO 88016
88140: POP
88141: POP
// if solds then
88142: LD_VAR 0 8
88146: IFFALSE 88205
// for i in solds do
88148: LD_ADDR_VAR 0 4
88152: PUSH
88153: LD_VAR 0 8
88157: PUSH
88158: FOR_IN
88159: IFFALSE 88203
// if not GetTag ( i ) then
88161: LD_VAR 0 4
88165: PPUSH
88166: CALL_OW 110
88170: NOT
88171: IFFALSE 88201
// begin defenders := defenders union i ;
88173: LD_ADDR_VAR 0 2
88177: PUSH
88178: LD_VAR 0 2
88182: PUSH
88183: LD_VAR 0 4
88187: UNION
88188: ST_TO_ADDR
// SetTag ( i , 18 ) ;
88189: LD_VAR 0 4
88193: PPUSH
88194: LD_INT 18
88196: PPUSH
88197: CALL_OW 109
// end ;
88201: GO 88158
88203: POP
88204: POP
// repeat wait ( 0 0$2 ) ;
88205: LD_INT 70
88207: PPUSH
88208: CALL_OW 67
// enemy := mc_scan [ base ] ;
88212: LD_ADDR_VAR 0 21
88216: PUSH
88217: LD_EXP 66
88221: PUSH
88222: LD_VAR 0 1
88226: ARRAY
88227: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88228: LD_EXP 43
88232: PUSH
88233: LD_VAR 0 1
88237: ARRAY
88238: NOT
88239: PUSH
88240: LD_EXP 43
88244: PUSH
88245: LD_VAR 0 1
88249: ARRAY
88250: PUSH
88251: EMPTY
88252: EQUAL
88253: OR
88254: IFFALSE 88291
// begin for i in defenders do
88256: LD_ADDR_VAR 0 4
88260: PUSH
88261: LD_VAR 0 2
88265: PUSH
88266: FOR_IN
88267: IFFALSE 88280
// ComStop ( i ) ;
88269: LD_VAR 0 4
88273: PPUSH
88274: CALL_OW 141
88278: GO 88266
88280: POP
88281: POP
// defenders := [ ] ;
88282: LD_ADDR_VAR 0 2
88286: PUSH
88287: EMPTY
88288: ST_TO_ADDR
// exit ;
88289: GO 89740
// end ; for i in defenders do
88291: LD_ADDR_VAR 0 4
88295: PUSH
88296: LD_VAR 0 2
88300: PUSH
88301: FOR_IN
88302: IFFALSE 89200
// begin e := NearestUnitToUnit ( enemy , i ) ;
88304: LD_ADDR_VAR 0 13
88308: PUSH
88309: LD_VAR 0 21
88313: PPUSH
88314: LD_VAR 0 4
88318: PPUSH
88319: CALL_OW 74
88323: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88324: LD_ADDR_VAR 0 7
88328: PUSH
88329: LD_EXP 43
88333: PUSH
88334: LD_VAR 0 1
88338: ARRAY
88339: PPUSH
88340: LD_INT 2
88342: PUSH
88343: LD_INT 30
88345: PUSH
88346: LD_INT 0
88348: PUSH
88349: EMPTY
88350: LIST
88351: LIST
88352: PUSH
88353: LD_INT 30
88355: PUSH
88356: LD_INT 1
88358: PUSH
88359: EMPTY
88360: LIST
88361: LIST
88362: PUSH
88363: EMPTY
88364: LIST
88365: LIST
88366: LIST
88367: PPUSH
88368: CALL_OW 72
88372: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
88373: LD_ADDR_VAR 0 16
88377: PUSH
88378: LD_VAR 0 7
88382: NOT
88383: PUSH
88384: LD_VAR 0 7
88388: PPUSH
88389: LD_INT 3
88391: PUSH
88392: LD_INT 24
88394: PUSH
88395: LD_INT 600
88397: PUSH
88398: EMPTY
88399: LIST
88400: LIST
88401: PUSH
88402: EMPTY
88403: LIST
88404: LIST
88405: PPUSH
88406: CALL_OW 72
88410: OR
88411: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
88412: LD_VAR 0 4
88416: PPUSH
88417: CALL_OW 247
88421: PUSH
88422: LD_INT 2
88424: DOUBLE
88425: EQUAL
88426: IFTRUE 88430
88428: GO 88826
88430: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
88431: LD_VAR 0 4
88435: PPUSH
88436: CALL_OW 256
88440: PUSH
88441: LD_INT 1000
88443: EQUAL
88444: PUSH
88445: LD_VAR 0 4
88449: PPUSH
88450: LD_VAR 0 13
88454: PPUSH
88455: CALL_OW 296
88459: PUSH
88460: LD_INT 40
88462: LESS
88463: PUSH
88464: LD_VAR 0 13
88468: PPUSH
88469: LD_EXP 68
88473: PUSH
88474: LD_VAR 0 1
88478: ARRAY
88479: PPUSH
88480: CALL_OW 308
88484: OR
88485: AND
88486: IFFALSE 88608
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
88488: LD_VAR 0 4
88492: PPUSH
88493: CALL_OW 262
88497: PUSH
88498: LD_INT 1
88500: EQUAL
88501: PUSH
88502: LD_VAR 0 4
88506: PPUSH
88507: CALL_OW 261
88511: PUSH
88512: LD_INT 30
88514: LESS
88515: AND
88516: PUSH
88517: LD_VAR 0 7
88521: AND
88522: IFFALSE 88592
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
88524: LD_VAR 0 4
88528: PPUSH
88529: LD_VAR 0 7
88533: PPUSH
88534: LD_VAR 0 4
88538: PPUSH
88539: CALL_OW 74
88543: PPUSH
88544: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
88548: LD_VAR 0 4
88552: PPUSH
88553: LD_VAR 0 7
88557: PPUSH
88558: LD_VAR 0 4
88562: PPUSH
88563: CALL_OW 74
88567: PPUSH
88568: CALL_OW 296
88572: PUSH
88573: LD_INT 6
88575: LESS
88576: IFFALSE 88590
// SetFuel ( i , 100 ) ;
88578: LD_VAR 0 4
88582: PPUSH
88583: LD_INT 100
88585: PPUSH
88586: CALL_OW 240
// end else
88590: GO 88606
// ComAttackUnit ( i , e ) ;
88592: LD_VAR 0 4
88596: PPUSH
88597: LD_VAR 0 13
88601: PPUSH
88602: CALL_OW 115
// end else
88606: GO 88709
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88608: LD_VAR 0 13
88612: PPUSH
88613: LD_EXP 68
88617: PUSH
88618: LD_VAR 0 1
88622: ARRAY
88623: PPUSH
88624: CALL_OW 308
88628: NOT
88629: PUSH
88630: LD_VAR 0 4
88634: PPUSH
88635: LD_VAR 0 13
88639: PPUSH
88640: CALL_OW 296
88644: PUSH
88645: LD_INT 40
88647: GREATEREQUAL
88648: AND
88649: PUSH
88650: LD_VAR 0 4
88654: PPUSH
88655: CALL_OW 256
88659: PUSH
88660: LD_INT 650
88662: LESSEQUAL
88663: OR
88664: PUSH
88665: LD_VAR 0 4
88669: PPUSH
88670: LD_EXP 67
88674: PUSH
88675: LD_VAR 0 1
88679: ARRAY
88680: PPUSH
88681: CALL_OW 308
88685: NOT
88686: AND
88687: IFFALSE 88709
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88689: LD_VAR 0 4
88693: PPUSH
88694: LD_EXP 67
88698: PUSH
88699: LD_VAR 0 1
88703: ARRAY
88704: PPUSH
88705: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88709: LD_VAR 0 4
88713: PPUSH
88714: CALL_OW 256
88718: PUSH
88719: LD_INT 1000
88721: LESS
88722: PUSH
88723: LD_VAR 0 4
88727: PPUSH
88728: CALL_OW 263
88732: PUSH
88733: LD_INT 1
88735: EQUAL
88736: AND
88737: PUSH
88738: LD_VAR 0 4
88742: PPUSH
88743: CALL_OW 311
88747: AND
88748: PUSH
88749: LD_VAR 0 4
88753: PPUSH
88754: LD_EXP 67
88758: PUSH
88759: LD_VAR 0 1
88763: ARRAY
88764: PPUSH
88765: CALL_OW 308
88769: AND
88770: IFFALSE 88824
// begin mech := IsDrivenBy ( i ) ;
88772: LD_ADDR_VAR 0 9
88776: PUSH
88777: LD_VAR 0 4
88781: PPUSH
88782: CALL_OW 311
88786: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88787: LD_VAR 0 9
88791: PPUSH
88792: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
88796: LD_VAR 0 9
88800: PPUSH
88801: LD_VAR 0 4
88805: PPUSH
88806: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
88810: LD_VAR 0 9
88814: PPUSH
88815: LD_VAR 0 4
88819: PPUSH
88820: CALL_OW 180
// end ; end ; unit_human :
88824: GO 89171
88826: LD_INT 1
88828: DOUBLE
88829: EQUAL
88830: IFTRUE 88834
88832: GO 89170
88834: POP
// begin b := IsInUnit ( i ) ;
88835: LD_ADDR_VAR 0 18
88839: PUSH
88840: LD_VAR 0 4
88844: PPUSH
88845: CALL_OW 310
88849: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88850: LD_ADDR_VAR 0 19
88854: PUSH
88855: LD_VAR 0 18
88859: NOT
88860: PUSH
88861: LD_VAR 0 18
88865: PPUSH
88866: CALL_OW 266
88870: PUSH
88871: LD_INT 32
88873: PUSH
88874: LD_INT 31
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: IN
88881: OR
88882: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88883: LD_VAR 0 18
88887: PPUSH
88888: CALL_OW 266
88892: PUSH
88893: LD_INT 5
88895: EQUAL
88896: PUSH
88897: LD_VAR 0 4
88901: PPUSH
88902: CALL_OW 257
88906: PUSH
88907: LD_INT 1
88909: PUSH
88910: LD_INT 2
88912: PUSH
88913: LD_INT 3
88915: PUSH
88916: LD_INT 4
88918: PUSH
88919: EMPTY
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: IN
88925: AND
88926: IFFALSE 88963
// begin class := AllowSpecClass ( i ) ;
88928: LD_ADDR_VAR 0 20
88932: PUSH
88933: LD_VAR 0 4
88937: PPUSH
88938: CALL 11598 0 1
88942: ST_TO_ADDR
// if class then
88943: LD_VAR 0 20
88947: IFFALSE 88963
// ComChangeProfession ( i , class ) ;
88949: LD_VAR 0 4
88953: PPUSH
88954: LD_VAR 0 20
88958: PPUSH
88959: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88963: LD_VAR 0 16
88967: PUSH
88968: LD_VAR 0 2
88972: PPUSH
88973: LD_INT 21
88975: PUSH
88976: LD_INT 2
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PPUSH
88983: CALL_OW 72
88987: PUSH
88988: LD_INT 1
88990: LESSEQUAL
88991: OR
88992: PUSH
88993: LD_VAR 0 19
88997: AND
88998: PUSH
88999: LD_VAR 0 4
89003: PUSH
89004: LD_VAR 0 17
89008: IN
89009: NOT
89010: AND
89011: IFFALSE 89104
// begin if b then
89013: LD_VAR 0 18
89017: IFFALSE 89066
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
89019: LD_VAR 0 18
89023: PPUSH
89024: LD_VAR 0 21
89028: PPUSH
89029: LD_VAR 0 18
89033: PPUSH
89034: CALL_OW 74
89038: PPUSH
89039: CALL_OW 296
89043: PUSH
89044: LD_INT 10
89046: LESS
89047: PUSH
89048: LD_VAR 0 18
89052: PPUSH
89053: CALL_OW 461
89057: PUSH
89058: LD_INT 7
89060: NONEQUAL
89061: AND
89062: IFFALSE 89066
// continue ;
89064: GO 88301
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
89066: LD_ADDR_VAR 0 17
89070: PUSH
89071: LD_VAR 0 17
89075: PPUSH
89076: LD_VAR 0 17
89080: PUSH
89081: LD_INT 1
89083: PLUS
89084: PPUSH
89085: LD_VAR 0 4
89089: PPUSH
89090: CALL_OW 1
89094: ST_TO_ADDR
// ComExitBuilding ( i ) ;
89095: LD_VAR 0 4
89099: PPUSH
89100: CALL_OW 122
// end ; if sold_defenders then
89104: LD_VAR 0 17
89108: IFFALSE 89168
// if i in sold_defenders then
89110: LD_VAR 0 4
89114: PUSH
89115: LD_VAR 0 17
89119: IN
89120: IFFALSE 89168
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
89122: LD_VAR 0 4
89126: PPUSH
89127: CALL_OW 314
89131: NOT
89132: PUSH
89133: LD_VAR 0 4
89137: PPUSH
89138: LD_VAR 0 13
89142: PPUSH
89143: CALL_OW 296
89147: PUSH
89148: LD_INT 30
89150: LESS
89151: AND
89152: IFFALSE 89168
// ComAttackUnit ( i , e ) ;
89154: LD_VAR 0 4
89158: PPUSH
89159: LD_VAR 0 13
89163: PPUSH
89164: CALL_OW 115
// end ; end ; end ;
89168: GO 89171
89170: POP
// if IsDead ( i ) then
89171: LD_VAR 0 4
89175: PPUSH
89176: CALL_OW 301
89180: IFFALSE 89198
// defenders := defenders diff i ;
89182: LD_ADDR_VAR 0 2
89186: PUSH
89187: LD_VAR 0 2
89191: PUSH
89192: LD_VAR 0 4
89196: DIFF
89197: ST_TO_ADDR
// end ;
89198: GO 88301
89200: POP
89201: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
89202: LD_VAR 0 21
89206: NOT
89207: PUSH
89208: LD_VAR 0 2
89212: NOT
89213: OR
89214: PUSH
89215: LD_EXP 43
89219: PUSH
89220: LD_VAR 0 1
89224: ARRAY
89225: NOT
89226: OR
89227: IFFALSE 88205
// MC_Reset ( base , 18 ) ;
89229: LD_VAR 0 1
89233: PPUSH
89234: LD_INT 18
89236: PPUSH
89237: CALL 55905 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89241: LD_ADDR_VAR 0 2
89245: PUSH
89246: LD_VAR 0 2
89250: PUSH
89251: LD_VAR 0 2
89255: PPUSH
89256: LD_INT 2
89258: PUSH
89259: LD_INT 25
89261: PUSH
89262: LD_INT 1
89264: PUSH
89265: EMPTY
89266: LIST
89267: LIST
89268: PUSH
89269: LD_INT 25
89271: PUSH
89272: LD_INT 5
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 25
89281: PUSH
89282: LD_INT 8
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 25
89291: PUSH
89292: LD_INT 9
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: PPUSH
89306: CALL_OW 72
89310: DIFF
89311: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
89312: LD_VAR 0 21
89316: NOT
89317: PUSH
89318: LD_VAR 0 2
89322: PPUSH
89323: LD_INT 21
89325: PUSH
89326: LD_INT 2
89328: PUSH
89329: EMPTY
89330: LIST
89331: LIST
89332: PPUSH
89333: CALL_OW 72
89337: AND
89338: IFFALSE 89676
// begin tmp := FilterByTag ( defenders , 19 ) ;
89340: LD_ADDR_VAR 0 11
89344: PUSH
89345: LD_VAR 0 2
89349: PPUSH
89350: LD_INT 19
89352: PPUSH
89353: CALL 45083 0 2
89357: ST_TO_ADDR
// if tmp then
89358: LD_VAR 0 11
89362: IFFALSE 89432
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
89364: LD_ADDR_VAR 0 11
89368: PUSH
89369: LD_VAR 0 11
89373: PPUSH
89374: LD_INT 25
89376: PUSH
89377: LD_INT 3
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PPUSH
89384: CALL_OW 72
89388: ST_TO_ADDR
// if tmp then
89389: LD_VAR 0 11
89393: IFFALSE 89432
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
89395: LD_ADDR_EXP 55
89399: PUSH
89400: LD_EXP 55
89404: PPUSH
89405: LD_VAR 0 1
89409: PPUSH
89410: LD_EXP 55
89414: PUSH
89415: LD_VAR 0 1
89419: ARRAY
89420: PUSH
89421: LD_VAR 0 11
89425: UNION
89426: PPUSH
89427: CALL_OW 1
89431: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
89432: LD_VAR 0 1
89436: PPUSH
89437: LD_INT 19
89439: PPUSH
89440: CALL 55905 0 2
// repeat wait ( 0 0$1 ) ;
89444: LD_INT 35
89446: PPUSH
89447: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
89451: LD_EXP 43
89455: PUSH
89456: LD_VAR 0 1
89460: ARRAY
89461: NOT
89462: PUSH
89463: LD_EXP 43
89467: PUSH
89468: LD_VAR 0 1
89472: ARRAY
89473: PUSH
89474: EMPTY
89475: EQUAL
89476: OR
89477: IFFALSE 89514
// begin for i in defenders do
89479: LD_ADDR_VAR 0 4
89483: PUSH
89484: LD_VAR 0 2
89488: PUSH
89489: FOR_IN
89490: IFFALSE 89503
// ComStop ( i ) ;
89492: LD_VAR 0 4
89496: PPUSH
89497: CALL_OW 141
89501: GO 89489
89503: POP
89504: POP
// defenders := [ ] ;
89505: LD_ADDR_VAR 0 2
89509: PUSH
89510: EMPTY
89511: ST_TO_ADDR
// exit ;
89512: GO 89740
// end ; for i in defenders do
89514: LD_ADDR_VAR 0 4
89518: PUSH
89519: LD_VAR 0 2
89523: PUSH
89524: FOR_IN
89525: IFFALSE 89614
// begin if not IsInArea ( i , mc_parking [ base ] ) then
89527: LD_VAR 0 4
89531: PPUSH
89532: LD_EXP 67
89536: PUSH
89537: LD_VAR 0 1
89541: ARRAY
89542: PPUSH
89543: CALL_OW 308
89547: NOT
89548: IFFALSE 89572
// ComMoveToArea ( i , mc_parking [ base ] ) else
89550: LD_VAR 0 4
89554: PPUSH
89555: LD_EXP 67
89559: PUSH
89560: LD_VAR 0 1
89564: ARRAY
89565: PPUSH
89566: CALL_OW 113
89570: GO 89612
// if GetControl ( i ) = control_manual then
89572: LD_VAR 0 4
89576: PPUSH
89577: CALL_OW 263
89581: PUSH
89582: LD_INT 1
89584: EQUAL
89585: IFFALSE 89612
// if IsDrivenBy ( i ) then
89587: LD_VAR 0 4
89591: PPUSH
89592: CALL_OW 311
89596: IFFALSE 89612
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89598: LD_VAR 0 4
89602: PPUSH
89603: CALL_OW 311
89607: PPUSH
89608: CALL_OW 121
// end ;
89612: GO 89524
89614: POP
89615: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89616: LD_VAR 0 2
89620: PPUSH
89621: LD_INT 95
89623: PUSH
89624: LD_EXP 67
89628: PUSH
89629: LD_VAR 0 1
89633: ARRAY
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PPUSH
89639: CALL_OW 72
89643: PUSH
89644: LD_VAR 0 2
89648: EQUAL
89649: PUSH
89650: LD_EXP 66
89654: PUSH
89655: LD_VAR 0 1
89659: ARRAY
89660: OR
89661: PUSH
89662: LD_EXP 43
89666: PUSH
89667: LD_VAR 0 1
89671: ARRAY
89672: NOT
89673: OR
89674: IFFALSE 89444
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89676: LD_ADDR_EXP 65
89680: PUSH
89681: LD_EXP 65
89685: PPUSH
89686: LD_VAR 0 1
89690: PPUSH
89691: LD_VAR 0 2
89695: PPUSH
89696: LD_INT 21
89698: PUSH
89699: LD_INT 2
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PPUSH
89706: CALL_OW 72
89710: PPUSH
89711: CALL_OW 1
89715: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89716: LD_VAR 0 1
89720: PPUSH
89721: LD_INT 19
89723: PPUSH
89724: CALL 55905 0 2
// MC_Reset ( base , 20 ) ;
89728: LD_VAR 0 1
89732: PPUSH
89733: LD_INT 20
89735: PPUSH
89736: CALL 55905 0 2
// end ; end_of_file
89740: LD_VAR 0 3
89744: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89745: LD_INT 0
89747: PPUSH
89748: PPUSH
89749: PPUSH
89750: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89751: LD_VAR 0 1
89755: PPUSH
89756: CALL_OW 264
89760: PUSH
89761: LD_INT 91
89763: EQUAL
89764: IFFALSE 89836
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89766: LD_INT 68
89768: PPUSH
89769: LD_VAR 0 1
89773: PPUSH
89774: CALL_OW 255
89778: PPUSH
89779: CALL_OW 321
89783: PUSH
89784: LD_INT 2
89786: EQUAL
89787: IFFALSE 89799
// eff := 70 else
89789: LD_ADDR_VAR 0 4
89793: PUSH
89794: LD_INT 70
89796: ST_TO_ADDR
89797: GO 89807
// eff := 30 ;
89799: LD_ADDR_VAR 0 4
89803: PUSH
89804: LD_INT 30
89806: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89807: LD_VAR 0 1
89811: PPUSH
89812: CALL_OW 250
89816: PPUSH
89817: LD_VAR 0 1
89821: PPUSH
89822: CALL_OW 251
89826: PPUSH
89827: LD_VAR 0 4
89831: PPUSH
89832: CALL_OW 495
// end ; end ;
89836: LD_VAR 0 2
89840: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89841: LD_INT 0
89843: PPUSH
// end ;
89844: LD_VAR 0 4
89848: RET
// export function SOS_Command ( cmd ) ; begin
89849: LD_INT 0
89851: PPUSH
// end ;
89852: LD_VAR 0 2
89856: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89857: LD_INT 0
89859: PPUSH
// end ;
89860: LD_VAR 0 6
89864: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
89865: LD_INT 0
89867: PPUSH
89868: PPUSH
// if not vehicle or not factory then
89869: LD_VAR 0 1
89873: NOT
89874: PUSH
89875: LD_VAR 0 2
89879: NOT
89880: OR
89881: IFFALSE 89885
// exit ;
89883: GO 90116
// if factoryWaypoints >= factory then
89885: LD_EXP 157
89889: PUSH
89890: LD_VAR 0 2
89894: GREATEREQUAL
89895: IFFALSE 90116
// if factoryWaypoints [ factory ] then
89897: LD_EXP 157
89901: PUSH
89902: LD_VAR 0 2
89906: ARRAY
89907: IFFALSE 90116
// begin if GetControl ( vehicle ) = control_manual then
89909: LD_VAR 0 1
89913: PPUSH
89914: CALL_OW 263
89918: PUSH
89919: LD_INT 1
89921: EQUAL
89922: IFFALSE 90003
// begin driver := IsDrivenBy ( vehicle ) ;
89924: LD_ADDR_VAR 0 4
89928: PUSH
89929: LD_VAR 0 1
89933: PPUSH
89934: CALL_OW 311
89938: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89939: LD_VAR 0 4
89943: PPUSH
89944: LD_EXP 157
89948: PUSH
89949: LD_VAR 0 2
89953: ARRAY
89954: PUSH
89955: LD_INT 3
89957: ARRAY
89958: PPUSH
89959: LD_EXP 157
89963: PUSH
89964: LD_VAR 0 2
89968: ARRAY
89969: PUSH
89970: LD_INT 4
89972: ARRAY
89973: PPUSH
89974: CALL_OW 171
// AddComExitVehicle ( driver ) ;
89978: LD_VAR 0 4
89982: PPUSH
89983: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
89987: LD_VAR 0 4
89991: PPUSH
89992: LD_VAR 0 2
89996: PPUSH
89997: CALL_OW 180
// end else
90001: GO 90116
// if GetControl ( vehicle ) = control_remote then
90003: LD_VAR 0 1
90007: PPUSH
90008: CALL_OW 263
90012: PUSH
90013: LD_INT 2
90015: EQUAL
90016: IFFALSE 90077
// begin wait ( 0 0$2 ) ;
90018: LD_INT 70
90020: PPUSH
90021: CALL_OW 67
// if Connect ( vehicle ) then
90025: LD_VAR 0 1
90029: PPUSH
90030: CALL 18120 0 1
90034: IFFALSE 90075
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90036: LD_VAR 0 1
90040: PPUSH
90041: LD_EXP 157
90045: PUSH
90046: LD_VAR 0 2
90050: ARRAY
90051: PUSH
90052: LD_INT 3
90054: ARRAY
90055: PPUSH
90056: LD_EXP 157
90060: PUSH
90061: LD_VAR 0 2
90065: ARRAY
90066: PUSH
90067: LD_INT 4
90069: ARRAY
90070: PPUSH
90071: CALL_OW 171
// end else
90075: GO 90116
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90077: LD_VAR 0 1
90081: PPUSH
90082: LD_EXP 157
90086: PUSH
90087: LD_VAR 0 2
90091: ARRAY
90092: PUSH
90093: LD_INT 3
90095: ARRAY
90096: PPUSH
90097: LD_EXP 157
90101: PUSH
90102: LD_VAR 0 2
90106: ARRAY
90107: PUSH
90108: LD_INT 4
90110: ARRAY
90111: PPUSH
90112: CALL_OW 171
// end ; end ;
90116: LD_VAR 0 3
90120: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
90121: LD_INT 0
90123: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
90124: LD_VAR 0 1
90128: PUSH
90129: LD_INT 250
90131: EQUAL
90132: PUSH
90133: LD_VAR 0 2
90137: PPUSH
90138: CALL_OW 264
90142: PUSH
90143: LD_INT 81
90145: EQUAL
90146: AND
90147: IFFALSE 90168
// MinerPlaceMine ( unit , x , y ) ;
90149: LD_VAR 0 2
90153: PPUSH
90154: LD_VAR 0 4
90158: PPUSH
90159: LD_VAR 0 5
90163: PPUSH
90164: CALL 92992 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
90168: LD_VAR 0 1
90172: PUSH
90173: LD_INT 251
90175: EQUAL
90176: PUSH
90177: LD_VAR 0 2
90181: PPUSH
90182: CALL_OW 264
90186: PUSH
90187: LD_INT 81
90189: EQUAL
90190: AND
90191: IFFALSE 90212
// MinerDetonateMine ( unit , x , y ) ;
90193: LD_VAR 0 2
90197: PPUSH
90198: LD_VAR 0 4
90202: PPUSH
90203: LD_VAR 0 5
90207: PPUSH
90208: CALL 93267 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
90212: LD_VAR 0 1
90216: PUSH
90217: LD_INT 252
90219: EQUAL
90220: PUSH
90221: LD_VAR 0 2
90225: PPUSH
90226: CALL_OW 264
90230: PUSH
90231: LD_INT 81
90233: EQUAL
90234: AND
90235: IFFALSE 90256
// MinerCreateMinefield ( unit , x , y ) ;
90237: LD_VAR 0 2
90241: PPUSH
90242: LD_VAR 0 4
90246: PPUSH
90247: LD_VAR 0 5
90251: PPUSH
90252: CALL 93684 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
90256: LD_VAR 0 1
90260: PUSH
90261: LD_INT 253
90263: EQUAL
90264: PUSH
90265: LD_VAR 0 2
90269: PPUSH
90270: CALL_OW 257
90274: PUSH
90275: LD_INT 5
90277: EQUAL
90278: AND
90279: IFFALSE 90300
// ComBinocular ( unit , x , y ) ;
90281: LD_VAR 0 2
90285: PPUSH
90286: LD_VAR 0 4
90290: PPUSH
90291: LD_VAR 0 5
90295: PPUSH
90296: CALL 94053 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
90300: LD_VAR 0 1
90304: PUSH
90305: LD_INT 254
90307: EQUAL
90308: PUSH
90309: LD_VAR 0 2
90313: PPUSH
90314: CALL_OW 264
90318: PUSH
90319: LD_INT 99
90321: EQUAL
90322: AND
90323: PUSH
90324: LD_VAR 0 3
90328: PPUSH
90329: CALL_OW 263
90333: PUSH
90334: LD_INT 3
90336: EQUAL
90337: AND
90338: IFFALSE 90354
// HackDestroyVehicle ( unit , selectedUnit ) ;
90340: LD_VAR 0 2
90344: PPUSH
90345: LD_VAR 0 3
90349: PPUSH
90350: CALL 92356 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
90354: LD_VAR 0 1
90358: PUSH
90359: LD_INT 255
90361: EQUAL
90362: PUSH
90363: LD_VAR 0 2
90367: PPUSH
90368: CALL_OW 264
90372: PUSH
90373: LD_INT 14
90375: PUSH
90376: LD_INT 53
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: IN
90383: AND
90384: PUSH
90385: LD_VAR 0 4
90389: PPUSH
90390: LD_VAR 0 5
90394: PPUSH
90395: CALL_OW 488
90399: AND
90400: IFFALSE 90424
// CutTreeXYR ( unit , x , y , 12 ) ;
90402: LD_VAR 0 2
90406: PPUSH
90407: LD_VAR 0 4
90411: PPUSH
90412: LD_VAR 0 5
90416: PPUSH
90417: LD_INT 12
90419: PPUSH
90420: CALL 90519 0 4
// if cmd = 256 then
90424: LD_VAR 0 1
90428: PUSH
90429: LD_INT 256
90431: EQUAL
90432: IFFALSE 90453
// SetFactoryWaypoint ( unit , x , y ) ;
90434: LD_VAR 0 2
90438: PPUSH
90439: LD_VAR 0 4
90443: PPUSH
90444: LD_VAR 0 5
90448: PPUSH
90449: CALL 109127 0 3
// if cmd = 257 then
90453: LD_VAR 0 1
90457: PUSH
90458: LD_INT 257
90460: EQUAL
90461: IFFALSE 90482
// SetWarehouseGatheringPoint ( unit , x , y ) ;
90463: LD_VAR 0 2
90467: PPUSH
90468: LD_VAR 0 4
90472: PPUSH
90473: LD_VAR 0 5
90477: PPUSH
90478: CALL 109489 0 3
// if cmd = 258 then
90482: LD_VAR 0 1
90486: PUSH
90487: LD_INT 258
90489: EQUAL
90490: IFFALSE 90514
// BurnTreeXYR ( unit , x , y , 8 ) ;
90492: LD_VAR 0 2
90496: PPUSH
90497: LD_VAR 0 4
90501: PPUSH
90502: LD_VAR 0 5
90506: PPUSH
90507: LD_INT 8
90509: PPUSH
90510: CALL 90913 0 4
// end ;
90514: LD_VAR 0 6
90518: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90519: LD_INT 0
90521: PPUSH
90522: PPUSH
90523: PPUSH
90524: PPUSH
90525: PPUSH
90526: PPUSH
90527: PPUSH
90528: PPUSH
90529: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
90530: LD_VAR 0 1
90534: PPUSH
90535: CALL_OW 302
90539: NOT
90540: PUSH
90541: LD_VAR 0 2
90545: PPUSH
90546: LD_VAR 0 3
90550: PPUSH
90551: CALL_OW 488
90555: NOT
90556: OR
90557: PUSH
90558: LD_VAR 0 4
90562: NOT
90563: OR
90564: IFFALSE 90568
// exit ;
90566: GO 90908
// list := [ ] ;
90568: LD_ADDR_VAR 0 13
90572: PUSH
90573: EMPTY
90574: ST_TO_ADDR
// if x - r < 0 then
90575: LD_VAR 0 2
90579: PUSH
90580: LD_VAR 0 4
90584: MINUS
90585: PUSH
90586: LD_INT 0
90588: LESS
90589: IFFALSE 90601
// min_x := 0 else
90591: LD_ADDR_VAR 0 7
90595: PUSH
90596: LD_INT 0
90598: ST_TO_ADDR
90599: GO 90617
// min_x := x - r ;
90601: LD_ADDR_VAR 0 7
90605: PUSH
90606: LD_VAR 0 2
90610: PUSH
90611: LD_VAR 0 4
90615: MINUS
90616: ST_TO_ADDR
// if y - r < 0 then
90617: LD_VAR 0 3
90621: PUSH
90622: LD_VAR 0 4
90626: MINUS
90627: PUSH
90628: LD_INT 0
90630: LESS
90631: IFFALSE 90643
// min_y := 0 else
90633: LD_ADDR_VAR 0 8
90637: PUSH
90638: LD_INT 0
90640: ST_TO_ADDR
90641: GO 90659
// min_y := y - r ;
90643: LD_ADDR_VAR 0 8
90647: PUSH
90648: LD_VAR 0 3
90652: PUSH
90653: LD_VAR 0 4
90657: MINUS
90658: ST_TO_ADDR
// max_x := x + r ;
90659: LD_ADDR_VAR 0 9
90663: PUSH
90664: LD_VAR 0 2
90668: PUSH
90669: LD_VAR 0 4
90673: PLUS
90674: ST_TO_ADDR
// max_y := y + r ;
90675: LD_ADDR_VAR 0 10
90679: PUSH
90680: LD_VAR 0 3
90684: PUSH
90685: LD_VAR 0 4
90689: PLUS
90690: ST_TO_ADDR
// for _x = min_x to max_x do
90691: LD_ADDR_VAR 0 11
90695: PUSH
90696: DOUBLE
90697: LD_VAR 0 7
90701: DEC
90702: ST_TO_ADDR
90703: LD_VAR 0 9
90707: PUSH
90708: FOR_TO
90709: IFFALSE 90826
// for _y = min_y to max_y do
90711: LD_ADDR_VAR 0 12
90715: PUSH
90716: DOUBLE
90717: LD_VAR 0 8
90721: DEC
90722: ST_TO_ADDR
90723: LD_VAR 0 10
90727: PUSH
90728: FOR_TO
90729: IFFALSE 90822
// begin if not ValidHex ( _x , _y ) then
90731: LD_VAR 0 11
90735: PPUSH
90736: LD_VAR 0 12
90740: PPUSH
90741: CALL_OW 488
90745: NOT
90746: IFFALSE 90750
// continue ;
90748: GO 90728
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90750: LD_VAR 0 11
90754: PPUSH
90755: LD_VAR 0 12
90759: PPUSH
90760: CALL_OW 351
90764: PUSH
90765: LD_VAR 0 11
90769: PPUSH
90770: LD_VAR 0 12
90774: PPUSH
90775: CALL_OW 554
90779: AND
90780: IFFALSE 90820
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90782: LD_ADDR_VAR 0 13
90786: PUSH
90787: LD_VAR 0 13
90791: PPUSH
90792: LD_VAR 0 13
90796: PUSH
90797: LD_INT 1
90799: PLUS
90800: PPUSH
90801: LD_VAR 0 11
90805: PUSH
90806: LD_VAR 0 12
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PPUSH
90815: CALL_OW 2
90819: ST_TO_ADDR
// end ;
90820: GO 90728
90822: POP
90823: POP
90824: GO 90708
90826: POP
90827: POP
// if not list then
90828: LD_VAR 0 13
90832: NOT
90833: IFFALSE 90837
// exit ;
90835: GO 90908
// for i in list do
90837: LD_ADDR_VAR 0 6
90841: PUSH
90842: LD_VAR 0 13
90846: PUSH
90847: FOR_IN
90848: IFFALSE 90906
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90850: LD_VAR 0 1
90854: PPUSH
90855: LD_STRING M
90857: PUSH
90858: LD_VAR 0 6
90862: PUSH
90863: LD_INT 1
90865: ARRAY
90866: PUSH
90867: LD_VAR 0 6
90871: PUSH
90872: LD_INT 2
90874: ARRAY
90875: PUSH
90876: LD_INT 0
90878: PUSH
90879: LD_INT 0
90881: PUSH
90882: LD_INT 0
90884: PUSH
90885: LD_INT 0
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: PUSH
90897: EMPTY
90898: LIST
90899: PPUSH
90900: CALL_OW 447
90904: GO 90847
90906: POP
90907: POP
// end ;
90908: LD_VAR 0 5
90912: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90913: LD_INT 0
90915: PPUSH
90916: PPUSH
90917: PPUSH
90918: PPUSH
90919: PPUSH
90920: PPUSH
90921: PPUSH
90922: PPUSH
90923: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
90924: LD_VAR 0 1
90928: PPUSH
90929: CALL_OW 302
90933: NOT
90934: PUSH
90935: LD_VAR 0 2
90939: PPUSH
90940: LD_VAR 0 3
90944: PPUSH
90945: CALL_OW 488
90949: NOT
90950: OR
90951: PUSH
90952: LD_VAR 0 4
90956: NOT
90957: OR
90958: IFFALSE 90962
// exit ;
90960: GO 91310
// list := [ ] ;
90962: LD_ADDR_VAR 0 13
90966: PUSH
90967: EMPTY
90968: ST_TO_ADDR
// if x - r < 0 then
90969: LD_VAR 0 2
90973: PUSH
90974: LD_VAR 0 4
90978: MINUS
90979: PUSH
90980: LD_INT 0
90982: LESS
90983: IFFALSE 90995
// min_x := 0 else
90985: LD_ADDR_VAR 0 7
90989: PUSH
90990: LD_INT 0
90992: ST_TO_ADDR
90993: GO 91011
// min_x := x - r ;
90995: LD_ADDR_VAR 0 7
90999: PUSH
91000: LD_VAR 0 2
91004: PUSH
91005: LD_VAR 0 4
91009: MINUS
91010: ST_TO_ADDR
// if y - r < 0 then
91011: LD_VAR 0 3
91015: PUSH
91016: LD_VAR 0 4
91020: MINUS
91021: PUSH
91022: LD_INT 0
91024: LESS
91025: IFFALSE 91037
// min_y := 0 else
91027: LD_ADDR_VAR 0 8
91031: PUSH
91032: LD_INT 0
91034: ST_TO_ADDR
91035: GO 91053
// min_y := y - r ;
91037: LD_ADDR_VAR 0 8
91041: PUSH
91042: LD_VAR 0 3
91046: PUSH
91047: LD_VAR 0 4
91051: MINUS
91052: ST_TO_ADDR
// max_x := x + r ;
91053: LD_ADDR_VAR 0 9
91057: PUSH
91058: LD_VAR 0 2
91062: PUSH
91063: LD_VAR 0 4
91067: PLUS
91068: ST_TO_ADDR
// max_y := y + r ;
91069: LD_ADDR_VAR 0 10
91073: PUSH
91074: LD_VAR 0 3
91078: PUSH
91079: LD_VAR 0 4
91083: PLUS
91084: ST_TO_ADDR
// for _x = min_x to max_x do
91085: LD_ADDR_VAR 0 11
91089: PUSH
91090: DOUBLE
91091: LD_VAR 0 7
91095: DEC
91096: ST_TO_ADDR
91097: LD_VAR 0 9
91101: PUSH
91102: FOR_TO
91103: IFFALSE 91220
// for _y = min_y to max_y do
91105: LD_ADDR_VAR 0 12
91109: PUSH
91110: DOUBLE
91111: LD_VAR 0 8
91115: DEC
91116: ST_TO_ADDR
91117: LD_VAR 0 10
91121: PUSH
91122: FOR_TO
91123: IFFALSE 91216
// begin if not ValidHex ( _x , _y ) then
91125: LD_VAR 0 11
91129: PPUSH
91130: LD_VAR 0 12
91134: PPUSH
91135: CALL_OW 488
91139: NOT
91140: IFFALSE 91144
// continue ;
91142: GO 91122
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91144: LD_VAR 0 11
91148: PPUSH
91149: LD_VAR 0 12
91153: PPUSH
91154: CALL_OW 351
91158: PUSH
91159: LD_VAR 0 11
91163: PPUSH
91164: LD_VAR 0 12
91168: PPUSH
91169: CALL_OW 554
91173: AND
91174: IFFALSE 91214
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91176: LD_ADDR_VAR 0 13
91180: PUSH
91181: LD_VAR 0 13
91185: PPUSH
91186: LD_VAR 0 13
91190: PUSH
91191: LD_INT 1
91193: PLUS
91194: PPUSH
91195: LD_VAR 0 11
91199: PUSH
91200: LD_VAR 0 12
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PPUSH
91209: CALL_OW 2
91213: ST_TO_ADDR
// end ;
91214: GO 91122
91216: POP
91217: POP
91218: GO 91102
91220: POP
91221: POP
// if not list then
91222: LD_VAR 0 13
91226: NOT
91227: IFFALSE 91231
// exit ;
91229: GO 91310
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
91231: LD_ADDR_VAR 0 13
91235: PUSH
91236: LD_VAR 0 1
91240: PPUSH
91241: LD_VAR 0 13
91245: PPUSH
91246: LD_INT 1
91248: PPUSH
91249: LD_INT 1
91251: PPUSH
91252: CALL 15262 0 4
91256: ST_TO_ADDR
// ComStop ( flame ) ;
91257: LD_VAR 0 1
91261: PPUSH
91262: CALL_OW 141
// for i in list do
91266: LD_ADDR_VAR 0 6
91270: PUSH
91271: LD_VAR 0 13
91275: PUSH
91276: FOR_IN
91277: IFFALSE 91308
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
91279: LD_VAR 0 1
91283: PPUSH
91284: LD_VAR 0 6
91288: PUSH
91289: LD_INT 1
91291: ARRAY
91292: PPUSH
91293: LD_VAR 0 6
91297: PUSH
91298: LD_INT 2
91300: ARRAY
91301: PPUSH
91302: CALL_OW 176
91306: GO 91276
91308: POP
91309: POP
// end ;
91310: LD_VAR 0 5
91314: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
91315: LD_EXP 88
91319: NOT
91320: IFFALSE 91370
91322: GO 91324
91324: DISABLE
// begin initHack := true ;
91325: LD_ADDR_EXP 88
91329: PUSH
91330: LD_INT 1
91332: ST_TO_ADDR
// hackTanks := [ ] ;
91333: LD_ADDR_EXP 89
91337: PUSH
91338: EMPTY
91339: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
91340: LD_ADDR_EXP 90
91344: PUSH
91345: EMPTY
91346: ST_TO_ADDR
// hackLimit := 3 ;
91347: LD_ADDR_EXP 91
91351: PUSH
91352: LD_INT 3
91354: ST_TO_ADDR
// hackDist := 12 ;
91355: LD_ADDR_EXP 92
91359: PUSH
91360: LD_INT 12
91362: ST_TO_ADDR
// hackCounter := [ ] ;
91363: LD_ADDR_EXP 93
91367: PUSH
91368: EMPTY
91369: ST_TO_ADDR
// end ;
91370: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
91371: LD_EXP 88
91375: PUSH
91376: LD_INT 34
91378: PUSH
91379: LD_INT 99
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PPUSH
91386: CALL_OW 69
91390: AND
91391: IFFALSE 91644
91393: GO 91395
91395: DISABLE
91396: LD_INT 0
91398: PPUSH
91399: PPUSH
// begin enable ;
91400: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
91401: LD_ADDR_VAR 0 1
91405: PUSH
91406: LD_INT 34
91408: PUSH
91409: LD_INT 99
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PPUSH
91416: CALL_OW 69
91420: PUSH
91421: FOR_IN
91422: IFFALSE 91642
// begin if not i in hackTanks then
91424: LD_VAR 0 1
91428: PUSH
91429: LD_EXP 89
91433: IN
91434: NOT
91435: IFFALSE 91518
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
91437: LD_ADDR_EXP 89
91441: PUSH
91442: LD_EXP 89
91446: PPUSH
91447: LD_EXP 89
91451: PUSH
91452: LD_INT 1
91454: PLUS
91455: PPUSH
91456: LD_VAR 0 1
91460: PPUSH
91461: CALL_OW 1
91465: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
91466: LD_ADDR_EXP 90
91470: PUSH
91471: LD_EXP 90
91475: PPUSH
91476: LD_EXP 90
91480: PUSH
91481: LD_INT 1
91483: PLUS
91484: PPUSH
91485: EMPTY
91486: PPUSH
91487: CALL_OW 1
91491: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
91492: LD_ADDR_EXP 93
91496: PUSH
91497: LD_EXP 93
91501: PPUSH
91502: LD_EXP 93
91506: PUSH
91507: LD_INT 1
91509: PLUS
91510: PPUSH
91511: EMPTY
91512: PPUSH
91513: CALL_OW 1
91517: ST_TO_ADDR
// end ; if not IsOk ( i ) then
91518: LD_VAR 0 1
91522: PPUSH
91523: CALL_OW 302
91527: NOT
91528: IFFALSE 91541
// begin HackUnlinkAll ( i ) ;
91530: LD_VAR 0 1
91534: PPUSH
91535: CALL 91647 0 1
// continue ;
91539: GO 91421
// end ; HackCheckCapturedStatus ( i ) ;
91541: LD_VAR 0 1
91545: PPUSH
91546: CALL 92090 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
91550: LD_ADDR_VAR 0 2
91554: PUSH
91555: LD_INT 81
91557: PUSH
91558: LD_VAR 0 1
91562: PPUSH
91563: CALL_OW 255
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: PUSH
91572: LD_INT 33
91574: PUSH
91575: LD_INT 3
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 91
91584: PUSH
91585: LD_VAR 0 1
91589: PUSH
91590: LD_EXP 92
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: LIST
91599: PUSH
91600: LD_INT 50
91602: PUSH
91603: EMPTY
91604: LIST
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: PPUSH
91612: CALL_OW 69
91616: ST_TO_ADDR
// if not tmp then
91617: LD_VAR 0 2
91621: NOT
91622: IFFALSE 91626
// continue ;
91624: GO 91421
// HackLink ( i , tmp ) ;
91626: LD_VAR 0 1
91630: PPUSH
91631: LD_VAR 0 2
91635: PPUSH
91636: CALL 91783 0 2
// end ;
91640: GO 91421
91642: POP
91643: POP
// end ;
91644: PPOPN 2
91646: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
91647: LD_INT 0
91649: PPUSH
91650: PPUSH
91651: PPUSH
// if not hack in hackTanks then
91652: LD_VAR 0 1
91656: PUSH
91657: LD_EXP 89
91661: IN
91662: NOT
91663: IFFALSE 91667
// exit ;
91665: GO 91778
// index := GetElementIndex ( hackTanks , hack ) ;
91667: LD_ADDR_VAR 0 4
91671: PUSH
91672: LD_EXP 89
91676: PPUSH
91677: LD_VAR 0 1
91681: PPUSH
91682: CALL 14559 0 2
91686: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
91687: LD_EXP 90
91691: PUSH
91692: LD_VAR 0 4
91696: ARRAY
91697: IFFALSE 91778
// begin for i in hackTanksCaptured [ index ] do
91699: LD_ADDR_VAR 0 3
91703: PUSH
91704: LD_EXP 90
91708: PUSH
91709: LD_VAR 0 4
91713: ARRAY
91714: PUSH
91715: FOR_IN
91716: IFFALSE 91742
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
91718: LD_VAR 0 3
91722: PUSH
91723: LD_INT 1
91725: ARRAY
91726: PPUSH
91727: LD_VAR 0 3
91731: PUSH
91732: LD_INT 2
91734: ARRAY
91735: PPUSH
91736: CALL_OW 235
91740: GO 91715
91742: POP
91743: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
91744: LD_ADDR_EXP 90
91748: PUSH
91749: LD_EXP 90
91753: PPUSH
91754: LD_VAR 0 4
91758: PPUSH
91759: EMPTY
91760: PPUSH
91761: CALL_OW 1
91765: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
91766: LD_VAR 0 1
91770: PPUSH
91771: LD_INT 0
91773: PPUSH
91774: CALL_OW 505
// end ; end ;
91778: LD_VAR 0 2
91782: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
91783: LD_INT 0
91785: PPUSH
91786: PPUSH
91787: PPUSH
// if not hack in hackTanks or not vehicles then
91788: LD_VAR 0 1
91792: PUSH
91793: LD_EXP 89
91797: IN
91798: NOT
91799: PUSH
91800: LD_VAR 0 2
91804: NOT
91805: OR
91806: IFFALSE 91810
// exit ;
91808: GO 92085
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
91810: LD_ADDR_VAR 0 2
91814: PUSH
91815: LD_VAR 0 1
91819: PPUSH
91820: LD_VAR 0 2
91824: PPUSH
91825: LD_INT 1
91827: PPUSH
91828: LD_INT 1
91830: PPUSH
91831: CALL 15209 0 4
91835: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
91836: LD_ADDR_VAR 0 5
91840: PUSH
91841: LD_EXP 89
91845: PPUSH
91846: LD_VAR 0 1
91850: PPUSH
91851: CALL 14559 0 2
91855: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
91856: LD_EXP 90
91860: PUSH
91861: LD_VAR 0 5
91865: ARRAY
91866: PUSH
91867: LD_EXP 91
91871: LESS
91872: IFFALSE 92061
// begin for i := 1 to vehicles do
91874: LD_ADDR_VAR 0 4
91878: PUSH
91879: DOUBLE
91880: LD_INT 1
91882: DEC
91883: ST_TO_ADDR
91884: LD_VAR 0 2
91888: PUSH
91889: FOR_TO
91890: IFFALSE 92059
// begin if hackTanksCaptured [ index ] = hackLimit then
91892: LD_EXP 90
91896: PUSH
91897: LD_VAR 0 5
91901: ARRAY
91902: PUSH
91903: LD_EXP 91
91907: EQUAL
91908: IFFALSE 91912
// break ;
91910: GO 92059
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
91912: LD_ADDR_EXP 93
91916: PUSH
91917: LD_EXP 93
91921: PPUSH
91922: LD_VAR 0 5
91926: PPUSH
91927: LD_EXP 93
91931: PUSH
91932: LD_VAR 0 5
91936: ARRAY
91937: PUSH
91938: LD_INT 1
91940: PLUS
91941: PPUSH
91942: CALL_OW 1
91946: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
91947: LD_ADDR_EXP 90
91951: PUSH
91952: LD_EXP 90
91956: PPUSH
91957: LD_VAR 0 5
91961: PUSH
91962: LD_EXP 90
91966: PUSH
91967: LD_VAR 0 5
91971: ARRAY
91972: PUSH
91973: LD_INT 1
91975: PLUS
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PPUSH
91981: LD_VAR 0 2
91985: PUSH
91986: LD_VAR 0 4
91990: ARRAY
91991: PUSH
91992: LD_VAR 0 2
91996: PUSH
91997: LD_VAR 0 4
92001: ARRAY
92002: PPUSH
92003: CALL_OW 255
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PPUSH
92012: CALL 14774 0 3
92016: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
92017: LD_VAR 0 2
92021: PUSH
92022: LD_VAR 0 4
92026: ARRAY
92027: PPUSH
92028: LD_VAR 0 1
92032: PPUSH
92033: CALL_OW 255
92037: PPUSH
92038: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
92042: LD_VAR 0 2
92046: PUSH
92047: LD_VAR 0 4
92051: ARRAY
92052: PPUSH
92053: CALL_OW 141
// end ;
92057: GO 91889
92059: POP
92060: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92061: LD_VAR 0 1
92065: PPUSH
92066: LD_EXP 90
92070: PUSH
92071: LD_VAR 0 5
92075: ARRAY
92076: PUSH
92077: LD_INT 0
92079: PLUS
92080: PPUSH
92081: CALL_OW 505
// end ;
92085: LD_VAR 0 3
92089: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
92090: LD_INT 0
92092: PPUSH
92093: PPUSH
92094: PPUSH
92095: PPUSH
// if not hack in hackTanks then
92096: LD_VAR 0 1
92100: PUSH
92101: LD_EXP 89
92105: IN
92106: NOT
92107: IFFALSE 92111
// exit ;
92109: GO 92351
// index := GetElementIndex ( hackTanks , hack ) ;
92111: LD_ADDR_VAR 0 4
92115: PUSH
92116: LD_EXP 89
92120: PPUSH
92121: LD_VAR 0 1
92125: PPUSH
92126: CALL 14559 0 2
92130: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
92131: LD_ADDR_VAR 0 3
92135: PUSH
92136: DOUBLE
92137: LD_EXP 90
92141: PUSH
92142: LD_VAR 0 4
92146: ARRAY
92147: INC
92148: ST_TO_ADDR
92149: LD_INT 1
92151: PUSH
92152: FOR_DOWNTO
92153: IFFALSE 92325
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
92155: LD_ADDR_VAR 0 5
92159: PUSH
92160: LD_EXP 90
92164: PUSH
92165: LD_VAR 0 4
92169: ARRAY
92170: PUSH
92171: LD_VAR 0 3
92175: ARRAY
92176: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
92177: LD_VAR 0 5
92181: PUSH
92182: LD_INT 1
92184: ARRAY
92185: PPUSH
92186: CALL_OW 302
92190: NOT
92191: PUSH
92192: LD_VAR 0 5
92196: PUSH
92197: LD_INT 1
92199: ARRAY
92200: PPUSH
92201: CALL_OW 255
92205: PUSH
92206: LD_VAR 0 1
92210: PPUSH
92211: CALL_OW 255
92215: NONEQUAL
92216: OR
92217: IFFALSE 92323
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
92219: LD_VAR 0 5
92223: PUSH
92224: LD_INT 1
92226: ARRAY
92227: PPUSH
92228: CALL_OW 305
92232: PUSH
92233: LD_VAR 0 5
92237: PUSH
92238: LD_INT 1
92240: ARRAY
92241: PPUSH
92242: CALL_OW 255
92246: PUSH
92247: LD_VAR 0 1
92251: PPUSH
92252: CALL_OW 255
92256: EQUAL
92257: AND
92258: IFFALSE 92282
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
92260: LD_VAR 0 5
92264: PUSH
92265: LD_INT 1
92267: ARRAY
92268: PPUSH
92269: LD_VAR 0 5
92273: PUSH
92274: LD_INT 2
92276: ARRAY
92277: PPUSH
92278: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
92282: LD_ADDR_EXP 90
92286: PUSH
92287: LD_EXP 90
92291: PPUSH
92292: LD_VAR 0 4
92296: PPUSH
92297: LD_EXP 90
92301: PUSH
92302: LD_VAR 0 4
92306: ARRAY
92307: PPUSH
92308: LD_VAR 0 3
92312: PPUSH
92313: CALL_OW 3
92317: PPUSH
92318: CALL_OW 1
92322: ST_TO_ADDR
// end ; end ;
92323: GO 92152
92325: POP
92326: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92327: LD_VAR 0 1
92331: PPUSH
92332: LD_EXP 90
92336: PUSH
92337: LD_VAR 0 4
92341: ARRAY
92342: PUSH
92343: LD_INT 0
92345: PLUS
92346: PPUSH
92347: CALL_OW 505
// end ;
92351: LD_VAR 0 2
92355: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
92356: LD_INT 0
92358: PPUSH
92359: PPUSH
92360: PPUSH
92361: PPUSH
// if not hack in hackTanks then
92362: LD_VAR 0 1
92366: PUSH
92367: LD_EXP 89
92371: IN
92372: NOT
92373: IFFALSE 92377
// exit ;
92375: GO 92462
// index := GetElementIndex ( hackTanks , hack ) ;
92377: LD_ADDR_VAR 0 5
92381: PUSH
92382: LD_EXP 89
92386: PPUSH
92387: LD_VAR 0 1
92391: PPUSH
92392: CALL 14559 0 2
92396: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
92397: LD_ADDR_VAR 0 4
92401: PUSH
92402: DOUBLE
92403: LD_INT 1
92405: DEC
92406: ST_TO_ADDR
92407: LD_EXP 90
92411: PUSH
92412: LD_VAR 0 5
92416: ARRAY
92417: PUSH
92418: FOR_TO
92419: IFFALSE 92460
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
92421: LD_EXP 90
92425: PUSH
92426: LD_VAR 0 5
92430: ARRAY
92431: PUSH
92432: LD_VAR 0 4
92436: ARRAY
92437: PUSH
92438: LD_INT 1
92440: ARRAY
92441: PUSH
92442: LD_VAR 0 2
92446: EQUAL
92447: IFFALSE 92458
// KillUnit ( vehicle ) ;
92449: LD_VAR 0 2
92453: PPUSH
92454: CALL_OW 66
92458: GO 92418
92460: POP
92461: POP
// end ;
92462: LD_VAR 0 3
92466: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
92467: LD_EXP 94
92471: NOT
92472: IFFALSE 92507
92474: GO 92476
92476: DISABLE
// begin initMiner := true ;
92477: LD_ADDR_EXP 94
92481: PUSH
92482: LD_INT 1
92484: ST_TO_ADDR
// minersList := [ ] ;
92485: LD_ADDR_EXP 95
92489: PUSH
92490: EMPTY
92491: ST_TO_ADDR
// minerMinesList := [ ] ;
92492: LD_ADDR_EXP 96
92496: PUSH
92497: EMPTY
92498: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
92499: LD_ADDR_EXP 97
92503: PUSH
92504: LD_INT 5
92506: ST_TO_ADDR
// end ;
92507: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
92508: LD_EXP 94
92512: PUSH
92513: LD_INT 34
92515: PUSH
92516: LD_INT 81
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PPUSH
92523: CALL_OW 69
92527: AND
92528: IFFALSE 92989
92530: GO 92532
92532: DISABLE
92533: LD_INT 0
92535: PPUSH
92536: PPUSH
92537: PPUSH
92538: PPUSH
// begin enable ;
92539: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
92540: LD_ADDR_VAR 0 1
92544: PUSH
92545: LD_INT 34
92547: PUSH
92548: LD_INT 81
92550: PUSH
92551: EMPTY
92552: LIST
92553: LIST
92554: PPUSH
92555: CALL_OW 69
92559: PUSH
92560: FOR_IN
92561: IFFALSE 92633
// begin if not i in minersList then
92563: LD_VAR 0 1
92567: PUSH
92568: LD_EXP 95
92572: IN
92573: NOT
92574: IFFALSE 92631
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
92576: LD_ADDR_EXP 95
92580: PUSH
92581: LD_EXP 95
92585: PPUSH
92586: LD_EXP 95
92590: PUSH
92591: LD_INT 1
92593: PLUS
92594: PPUSH
92595: LD_VAR 0 1
92599: PPUSH
92600: CALL_OW 1
92604: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
92605: LD_ADDR_EXP 96
92609: PUSH
92610: LD_EXP 96
92614: PPUSH
92615: LD_EXP 96
92619: PUSH
92620: LD_INT 1
92622: PLUS
92623: PPUSH
92624: EMPTY
92625: PPUSH
92626: CALL_OW 1
92630: ST_TO_ADDR
// end end ;
92631: GO 92560
92633: POP
92634: POP
// for i := minerMinesList downto 1 do
92635: LD_ADDR_VAR 0 1
92639: PUSH
92640: DOUBLE
92641: LD_EXP 96
92645: INC
92646: ST_TO_ADDR
92647: LD_INT 1
92649: PUSH
92650: FOR_DOWNTO
92651: IFFALSE 92987
// begin if IsLive ( minersList [ i ] ) then
92653: LD_EXP 95
92657: PUSH
92658: LD_VAR 0 1
92662: ARRAY
92663: PPUSH
92664: CALL_OW 300
92668: IFFALSE 92696
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
92670: LD_EXP 95
92674: PUSH
92675: LD_VAR 0 1
92679: ARRAY
92680: PPUSH
92681: LD_EXP 96
92685: PUSH
92686: LD_VAR 0 1
92690: ARRAY
92691: PPUSH
92692: CALL_OW 505
// if not minerMinesList [ i ] then
92696: LD_EXP 96
92700: PUSH
92701: LD_VAR 0 1
92705: ARRAY
92706: NOT
92707: IFFALSE 92711
// continue ;
92709: GO 92650
// for j := minerMinesList [ i ] downto 1 do
92711: LD_ADDR_VAR 0 2
92715: PUSH
92716: DOUBLE
92717: LD_EXP 96
92721: PUSH
92722: LD_VAR 0 1
92726: ARRAY
92727: INC
92728: ST_TO_ADDR
92729: LD_INT 1
92731: PUSH
92732: FOR_DOWNTO
92733: IFFALSE 92983
// begin side := GetSide ( minersList [ i ] ) ;
92735: LD_ADDR_VAR 0 3
92739: PUSH
92740: LD_EXP 95
92744: PUSH
92745: LD_VAR 0 1
92749: ARRAY
92750: PPUSH
92751: CALL_OW 255
92755: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
92756: LD_ADDR_VAR 0 4
92760: PUSH
92761: LD_EXP 96
92765: PUSH
92766: LD_VAR 0 1
92770: ARRAY
92771: PUSH
92772: LD_VAR 0 2
92776: ARRAY
92777: PUSH
92778: LD_INT 1
92780: ARRAY
92781: PPUSH
92782: LD_EXP 96
92786: PUSH
92787: LD_VAR 0 1
92791: ARRAY
92792: PUSH
92793: LD_VAR 0 2
92797: ARRAY
92798: PUSH
92799: LD_INT 2
92801: ARRAY
92802: PPUSH
92803: CALL_OW 428
92807: ST_TO_ADDR
// if not tmp then
92808: LD_VAR 0 4
92812: NOT
92813: IFFALSE 92817
// continue ;
92815: GO 92732
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
92817: LD_VAR 0 4
92821: PUSH
92822: LD_INT 81
92824: PUSH
92825: LD_VAR 0 3
92829: PUSH
92830: EMPTY
92831: LIST
92832: LIST
92833: PPUSH
92834: CALL_OW 69
92838: IN
92839: PUSH
92840: LD_EXP 96
92844: PUSH
92845: LD_VAR 0 1
92849: ARRAY
92850: PUSH
92851: LD_VAR 0 2
92855: ARRAY
92856: PUSH
92857: LD_INT 1
92859: ARRAY
92860: PPUSH
92861: LD_EXP 96
92865: PUSH
92866: LD_VAR 0 1
92870: ARRAY
92871: PUSH
92872: LD_VAR 0 2
92876: ARRAY
92877: PUSH
92878: LD_INT 2
92880: ARRAY
92881: PPUSH
92882: CALL_OW 458
92886: AND
92887: IFFALSE 92981
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
92889: LD_EXP 96
92893: PUSH
92894: LD_VAR 0 1
92898: ARRAY
92899: PUSH
92900: LD_VAR 0 2
92904: ARRAY
92905: PUSH
92906: LD_INT 1
92908: ARRAY
92909: PPUSH
92910: LD_EXP 96
92914: PUSH
92915: LD_VAR 0 1
92919: ARRAY
92920: PUSH
92921: LD_VAR 0 2
92925: ARRAY
92926: PUSH
92927: LD_INT 2
92929: ARRAY
92930: PPUSH
92931: LD_VAR 0 3
92935: PPUSH
92936: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
92940: LD_ADDR_EXP 96
92944: PUSH
92945: LD_EXP 96
92949: PPUSH
92950: LD_VAR 0 1
92954: PPUSH
92955: LD_EXP 96
92959: PUSH
92960: LD_VAR 0 1
92964: ARRAY
92965: PPUSH
92966: LD_VAR 0 2
92970: PPUSH
92971: CALL_OW 3
92975: PPUSH
92976: CALL_OW 1
92980: ST_TO_ADDR
// end ; end ;
92981: GO 92732
92983: POP
92984: POP
// end ;
92985: GO 92650
92987: POP
92988: POP
// end ;
92989: PPOPN 4
92991: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
92992: LD_INT 0
92994: PPUSH
92995: PPUSH
// result := false ;
92996: LD_ADDR_VAR 0 4
93000: PUSH
93001: LD_INT 0
93003: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
93004: LD_VAR 0 1
93008: PPUSH
93009: CALL_OW 264
93013: PUSH
93014: LD_INT 81
93016: EQUAL
93017: NOT
93018: IFFALSE 93022
// exit ;
93020: GO 93262
// index := GetElementIndex ( minersList , unit ) ;
93022: LD_ADDR_VAR 0 5
93026: PUSH
93027: LD_EXP 95
93031: PPUSH
93032: LD_VAR 0 1
93036: PPUSH
93037: CALL 14559 0 2
93041: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
93042: LD_EXP 96
93046: PUSH
93047: LD_VAR 0 5
93051: ARRAY
93052: PUSH
93053: LD_EXP 97
93057: GREATEREQUAL
93058: IFFALSE 93062
// exit ;
93060: GO 93262
// ComMoveXY ( unit , x , y ) ;
93062: LD_VAR 0 1
93066: PPUSH
93067: LD_VAR 0 2
93071: PPUSH
93072: LD_VAR 0 3
93076: PPUSH
93077: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93081: LD_INT 35
93083: PPUSH
93084: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
93088: LD_VAR 0 1
93092: PPUSH
93093: LD_VAR 0 2
93097: PPUSH
93098: LD_VAR 0 3
93102: PPUSH
93103: CALL 46311 0 3
93107: NOT
93108: PUSH
93109: LD_VAR 0 1
93113: PPUSH
93114: CALL_OW 314
93118: AND
93119: IFFALSE 93123
// exit ;
93121: GO 93262
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
93123: LD_VAR 0 2
93127: PPUSH
93128: LD_VAR 0 3
93132: PPUSH
93133: CALL_OW 428
93137: PUSH
93138: LD_VAR 0 1
93142: EQUAL
93143: PUSH
93144: LD_VAR 0 1
93148: PPUSH
93149: CALL_OW 314
93153: NOT
93154: AND
93155: IFFALSE 93081
// PlaySoundXY ( x , y , PlantMine ) ;
93157: LD_VAR 0 2
93161: PPUSH
93162: LD_VAR 0 3
93166: PPUSH
93167: LD_STRING PlantMine
93169: PPUSH
93170: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
93174: LD_VAR 0 2
93178: PPUSH
93179: LD_VAR 0 3
93183: PPUSH
93184: LD_VAR 0 1
93188: PPUSH
93189: CALL_OW 255
93193: PPUSH
93194: LD_INT 0
93196: PPUSH
93197: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
93201: LD_ADDR_EXP 96
93205: PUSH
93206: LD_EXP 96
93210: PPUSH
93211: LD_VAR 0 5
93215: PUSH
93216: LD_EXP 96
93220: PUSH
93221: LD_VAR 0 5
93225: ARRAY
93226: PUSH
93227: LD_INT 1
93229: PLUS
93230: PUSH
93231: EMPTY
93232: LIST
93233: LIST
93234: PPUSH
93235: LD_VAR 0 2
93239: PUSH
93240: LD_VAR 0 3
93244: PUSH
93245: EMPTY
93246: LIST
93247: LIST
93248: PPUSH
93249: CALL 14774 0 3
93253: ST_TO_ADDR
// result := true ;
93254: LD_ADDR_VAR 0 4
93258: PUSH
93259: LD_INT 1
93261: ST_TO_ADDR
// end ;
93262: LD_VAR 0 4
93266: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
93267: LD_INT 0
93269: PPUSH
93270: PPUSH
93271: PPUSH
// if not unit in minersList then
93272: LD_VAR 0 1
93276: PUSH
93277: LD_EXP 95
93281: IN
93282: NOT
93283: IFFALSE 93287
// exit ;
93285: GO 93679
// index := GetElementIndex ( minersList , unit ) ;
93287: LD_ADDR_VAR 0 6
93291: PUSH
93292: LD_EXP 95
93296: PPUSH
93297: LD_VAR 0 1
93301: PPUSH
93302: CALL 14559 0 2
93306: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
93307: LD_ADDR_VAR 0 5
93311: PUSH
93312: DOUBLE
93313: LD_EXP 96
93317: PUSH
93318: LD_VAR 0 6
93322: ARRAY
93323: INC
93324: ST_TO_ADDR
93325: LD_INT 1
93327: PUSH
93328: FOR_DOWNTO
93329: IFFALSE 93490
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
93331: LD_EXP 96
93335: PUSH
93336: LD_VAR 0 6
93340: ARRAY
93341: PUSH
93342: LD_VAR 0 5
93346: ARRAY
93347: PUSH
93348: LD_INT 1
93350: ARRAY
93351: PUSH
93352: LD_VAR 0 2
93356: EQUAL
93357: PUSH
93358: LD_EXP 96
93362: PUSH
93363: LD_VAR 0 6
93367: ARRAY
93368: PUSH
93369: LD_VAR 0 5
93373: ARRAY
93374: PUSH
93375: LD_INT 2
93377: ARRAY
93378: PUSH
93379: LD_VAR 0 3
93383: EQUAL
93384: AND
93385: IFFALSE 93488
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93387: LD_EXP 96
93391: PUSH
93392: LD_VAR 0 6
93396: ARRAY
93397: PUSH
93398: LD_VAR 0 5
93402: ARRAY
93403: PUSH
93404: LD_INT 1
93406: ARRAY
93407: PPUSH
93408: LD_EXP 96
93412: PUSH
93413: LD_VAR 0 6
93417: ARRAY
93418: PUSH
93419: LD_VAR 0 5
93423: ARRAY
93424: PUSH
93425: LD_INT 2
93427: ARRAY
93428: PPUSH
93429: LD_VAR 0 1
93433: PPUSH
93434: CALL_OW 255
93438: PPUSH
93439: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93443: LD_ADDR_EXP 96
93447: PUSH
93448: LD_EXP 96
93452: PPUSH
93453: LD_VAR 0 6
93457: PPUSH
93458: LD_EXP 96
93462: PUSH
93463: LD_VAR 0 6
93467: ARRAY
93468: PPUSH
93469: LD_VAR 0 5
93473: PPUSH
93474: CALL_OW 3
93478: PPUSH
93479: CALL_OW 1
93483: ST_TO_ADDR
// exit ;
93484: POP
93485: POP
93486: GO 93679
// end ; end ;
93488: GO 93328
93490: POP
93491: POP
// for i := minerMinesList [ index ] downto 1 do
93492: LD_ADDR_VAR 0 5
93496: PUSH
93497: DOUBLE
93498: LD_EXP 96
93502: PUSH
93503: LD_VAR 0 6
93507: ARRAY
93508: INC
93509: ST_TO_ADDR
93510: LD_INT 1
93512: PUSH
93513: FOR_DOWNTO
93514: IFFALSE 93677
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
93516: LD_EXP 96
93520: PUSH
93521: LD_VAR 0 6
93525: ARRAY
93526: PUSH
93527: LD_VAR 0 5
93531: ARRAY
93532: PUSH
93533: LD_INT 1
93535: ARRAY
93536: PPUSH
93537: LD_EXP 96
93541: PUSH
93542: LD_VAR 0 6
93546: ARRAY
93547: PUSH
93548: LD_VAR 0 5
93552: ARRAY
93553: PUSH
93554: LD_INT 2
93556: ARRAY
93557: PPUSH
93558: LD_VAR 0 2
93562: PPUSH
93563: LD_VAR 0 3
93567: PPUSH
93568: CALL_OW 298
93572: PUSH
93573: LD_INT 6
93575: LESS
93576: IFFALSE 93675
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93578: LD_EXP 96
93582: PUSH
93583: LD_VAR 0 6
93587: ARRAY
93588: PUSH
93589: LD_VAR 0 5
93593: ARRAY
93594: PUSH
93595: LD_INT 1
93597: ARRAY
93598: PPUSH
93599: LD_EXP 96
93603: PUSH
93604: LD_VAR 0 6
93608: ARRAY
93609: PUSH
93610: LD_VAR 0 5
93614: ARRAY
93615: PUSH
93616: LD_INT 2
93618: ARRAY
93619: PPUSH
93620: LD_VAR 0 1
93624: PPUSH
93625: CALL_OW 255
93629: PPUSH
93630: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93634: LD_ADDR_EXP 96
93638: PUSH
93639: LD_EXP 96
93643: PPUSH
93644: LD_VAR 0 6
93648: PPUSH
93649: LD_EXP 96
93653: PUSH
93654: LD_VAR 0 6
93658: ARRAY
93659: PPUSH
93660: LD_VAR 0 5
93664: PPUSH
93665: CALL_OW 3
93669: PPUSH
93670: CALL_OW 1
93674: ST_TO_ADDR
// end ; end ;
93675: GO 93513
93677: POP
93678: POP
// end ;
93679: LD_VAR 0 4
93683: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
93684: LD_INT 0
93686: PPUSH
93687: PPUSH
93688: PPUSH
93689: PPUSH
93690: PPUSH
93691: PPUSH
93692: PPUSH
93693: PPUSH
93694: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
93695: LD_VAR 0 1
93699: PPUSH
93700: CALL_OW 264
93704: PUSH
93705: LD_INT 81
93707: EQUAL
93708: NOT
93709: PUSH
93710: LD_VAR 0 1
93714: PUSH
93715: LD_EXP 95
93719: IN
93720: NOT
93721: OR
93722: IFFALSE 93726
// exit ;
93724: GO 94048
// index := GetElementIndex ( minersList , unit ) ;
93726: LD_ADDR_VAR 0 6
93730: PUSH
93731: LD_EXP 95
93735: PPUSH
93736: LD_VAR 0 1
93740: PPUSH
93741: CALL 14559 0 2
93745: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
93746: LD_ADDR_VAR 0 8
93750: PUSH
93751: LD_EXP 97
93755: PUSH
93756: LD_EXP 96
93760: PUSH
93761: LD_VAR 0 6
93765: ARRAY
93766: MINUS
93767: ST_TO_ADDR
// if not minesFreeAmount then
93768: LD_VAR 0 8
93772: NOT
93773: IFFALSE 93777
// exit ;
93775: GO 94048
// tmp := [ ] ;
93777: LD_ADDR_VAR 0 7
93781: PUSH
93782: EMPTY
93783: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
93784: LD_ADDR_VAR 0 5
93788: PUSH
93789: DOUBLE
93790: LD_INT 1
93792: DEC
93793: ST_TO_ADDR
93794: LD_VAR 0 8
93798: PUSH
93799: FOR_TO
93800: IFFALSE 93995
// begin _d := rand ( 0 , 5 ) ;
93802: LD_ADDR_VAR 0 11
93806: PUSH
93807: LD_INT 0
93809: PPUSH
93810: LD_INT 5
93812: PPUSH
93813: CALL_OW 12
93817: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
93818: LD_ADDR_VAR 0 12
93822: PUSH
93823: LD_INT 2
93825: PPUSH
93826: LD_INT 6
93828: PPUSH
93829: CALL_OW 12
93833: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
93834: LD_ADDR_VAR 0 9
93838: PUSH
93839: LD_VAR 0 2
93843: PPUSH
93844: LD_VAR 0 11
93848: PPUSH
93849: LD_VAR 0 12
93853: PPUSH
93854: CALL_OW 272
93858: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
93859: LD_ADDR_VAR 0 10
93863: PUSH
93864: LD_VAR 0 3
93868: PPUSH
93869: LD_VAR 0 11
93873: PPUSH
93874: LD_VAR 0 12
93878: PPUSH
93879: CALL_OW 273
93883: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
93884: LD_VAR 0 9
93888: PPUSH
93889: LD_VAR 0 10
93893: PPUSH
93894: CALL_OW 488
93898: PUSH
93899: LD_VAR 0 9
93903: PUSH
93904: LD_VAR 0 10
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PUSH
93913: LD_VAR 0 7
93917: IN
93918: NOT
93919: AND
93920: PUSH
93921: LD_VAR 0 9
93925: PPUSH
93926: LD_VAR 0 10
93930: PPUSH
93931: CALL_OW 458
93935: NOT
93936: AND
93937: IFFALSE 93979
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
93939: LD_ADDR_VAR 0 7
93943: PUSH
93944: LD_VAR 0 7
93948: PPUSH
93949: LD_VAR 0 7
93953: PUSH
93954: LD_INT 1
93956: PLUS
93957: PPUSH
93958: LD_VAR 0 9
93962: PUSH
93963: LD_VAR 0 10
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PPUSH
93972: CALL_OW 1
93976: ST_TO_ADDR
93977: GO 93993
// i := i - 1 ;
93979: LD_ADDR_VAR 0 5
93983: PUSH
93984: LD_VAR 0 5
93988: PUSH
93989: LD_INT 1
93991: MINUS
93992: ST_TO_ADDR
// end ;
93993: GO 93799
93995: POP
93996: POP
// for i in tmp do
93997: LD_ADDR_VAR 0 5
94001: PUSH
94002: LD_VAR 0 7
94006: PUSH
94007: FOR_IN
94008: IFFALSE 94046
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
94010: LD_VAR 0 1
94014: PPUSH
94015: LD_VAR 0 5
94019: PUSH
94020: LD_INT 1
94022: ARRAY
94023: PPUSH
94024: LD_VAR 0 5
94028: PUSH
94029: LD_INT 2
94031: ARRAY
94032: PPUSH
94033: CALL 92992 0 3
94037: NOT
94038: IFFALSE 94044
// exit ;
94040: POP
94041: POP
94042: GO 94048
94044: GO 94007
94046: POP
94047: POP
// end ;
94048: LD_VAR 0 4
94052: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
94053: LD_INT 0
94055: PPUSH
94056: PPUSH
94057: PPUSH
94058: PPUSH
94059: PPUSH
94060: PPUSH
94061: PPUSH
// if not GetClass ( unit ) = class_sniper then
94062: LD_VAR 0 1
94066: PPUSH
94067: CALL_OW 257
94071: PUSH
94072: LD_INT 5
94074: EQUAL
94075: NOT
94076: IFFALSE 94080
// exit ;
94078: GO 94468
// dist := 8 ;
94080: LD_ADDR_VAR 0 5
94084: PUSH
94085: LD_INT 8
94087: ST_TO_ADDR
// viewRange := 12 ;
94088: LD_ADDR_VAR 0 7
94092: PUSH
94093: LD_INT 12
94095: ST_TO_ADDR
// side := GetSide ( unit ) ;
94096: LD_ADDR_VAR 0 6
94100: PUSH
94101: LD_VAR 0 1
94105: PPUSH
94106: CALL_OW 255
94110: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
94111: LD_INT 61
94113: PPUSH
94114: LD_VAR 0 6
94118: PPUSH
94119: CALL_OW 321
94123: PUSH
94124: LD_INT 2
94126: EQUAL
94127: IFFALSE 94137
// viewRange := 16 ;
94129: LD_ADDR_VAR 0 7
94133: PUSH
94134: LD_INT 16
94136: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
94137: LD_VAR 0 1
94141: PPUSH
94142: LD_VAR 0 2
94146: PPUSH
94147: LD_VAR 0 3
94151: PPUSH
94152: CALL_OW 297
94156: PUSH
94157: LD_VAR 0 5
94161: GREATER
94162: IFFALSE 94241
// begin ComMoveXY ( unit , x , y ) ;
94164: LD_VAR 0 1
94168: PPUSH
94169: LD_VAR 0 2
94173: PPUSH
94174: LD_VAR 0 3
94178: PPUSH
94179: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94183: LD_INT 35
94185: PPUSH
94186: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
94190: LD_VAR 0 1
94194: PPUSH
94195: LD_VAR 0 2
94199: PPUSH
94200: LD_VAR 0 3
94204: PPUSH
94205: CALL 46311 0 3
94209: NOT
94210: IFFALSE 94214
// exit ;
94212: GO 94468
// until GetDistUnitXY ( unit , x , y ) < dist ;
94214: LD_VAR 0 1
94218: PPUSH
94219: LD_VAR 0 2
94223: PPUSH
94224: LD_VAR 0 3
94228: PPUSH
94229: CALL_OW 297
94233: PUSH
94234: LD_VAR 0 5
94238: LESS
94239: IFFALSE 94183
// end ; ComTurnXY ( unit , x , y ) ;
94241: LD_VAR 0 1
94245: PPUSH
94246: LD_VAR 0 2
94250: PPUSH
94251: LD_VAR 0 3
94255: PPUSH
94256: CALL_OW 118
// wait ( 5 ) ;
94260: LD_INT 5
94262: PPUSH
94263: CALL_OW 67
// _d := GetDir ( unit ) ;
94267: LD_ADDR_VAR 0 10
94271: PUSH
94272: LD_VAR 0 1
94276: PPUSH
94277: CALL_OW 254
94281: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
94282: LD_ADDR_VAR 0 8
94286: PUSH
94287: LD_VAR 0 1
94291: PPUSH
94292: CALL_OW 250
94296: PPUSH
94297: LD_VAR 0 10
94301: PPUSH
94302: LD_VAR 0 5
94306: PPUSH
94307: CALL_OW 272
94311: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
94312: LD_ADDR_VAR 0 9
94316: PUSH
94317: LD_VAR 0 1
94321: PPUSH
94322: CALL_OW 251
94326: PPUSH
94327: LD_VAR 0 10
94331: PPUSH
94332: LD_VAR 0 5
94336: PPUSH
94337: CALL_OW 273
94341: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94342: LD_VAR 0 8
94346: PPUSH
94347: LD_VAR 0 9
94351: PPUSH
94352: CALL_OW 488
94356: NOT
94357: IFFALSE 94361
// exit ;
94359: GO 94468
// ComAnimCustom ( unit , 1 ) ;
94361: LD_VAR 0 1
94365: PPUSH
94366: LD_INT 1
94368: PPUSH
94369: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
94373: LD_VAR 0 8
94377: PPUSH
94378: LD_VAR 0 9
94382: PPUSH
94383: LD_VAR 0 6
94387: PPUSH
94388: LD_VAR 0 7
94392: PPUSH
94393: CALL_OW 330
// repeat wait ( 1 ) ;
94397: LD_INT 1
94399: PPUSH
94400: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
94404: LD_VAR 0 1
94408: PPUSH
94409: CALL_OW 316
94413: PUSH
94414: LD_VAR 0 1
94418: PPUSH
94419: CALL_OW 314
94423: OR
94424: PUSH
94425: LD_VAR 0 1
94429: PPUSH
94430: CALL_OW 302
94434: NOT
94435: OR
94436: PUSH
94437: LD_VAR 0 1
94441: PPUSH
94442: CALL_OW 301
94446: OR
94447: IFFALSE 94397
// RemoveSeeing ( _x , _y , side ) ;
94449: LD_VAR 0 8
94453: PPUSH
94454: LD_VAR 0 9
94458: PPUSH
94459: LD_VAR 0 6
94463: PPUSH
94464: CALL_OW 331
// end ; end_of_file
94468: LD_VAR 0 4
94472: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
94473: LD_VAR 0 1
94477: PUSH
94478: LD_INT 200
94480: DOUBLE
94481: GREATEREQUAL
94482: IFFALSE 94490
94484: LD_INT 299
94486: DOUBLE
94487: LESSEQUAL
94488: IFTRUE 94492
94490: GO 94524
94492: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
94493: LD_VAR 0 1
94497: PPUSH
94498: LD_VAR 0 2
94502: PPUSH
94503: LD_VAR 0 3
94507: PPUSH
94508: LD_VAR 0 4
94512: PPUSH
94513: LD_VAR 0 5
94517: PPUSH
94518: CALL 90121 0 5
94522: GO 94601
94524: LD_INT 300
94526: DOUBLE
94527: GREATEREQUAL
94528: IFFALSE 94536
94530: LD_INT 399
94532: DOUBLE
94533: LESSEQUAL
94534: IFTRUE 94538
94536: GO 94600
94538: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
94539: LD_VAR 0 1
94543: PPUSH
94544: LD_VAR 0 2
94548: PPUSH
94549: LD_VAR 0 3
94553: PPUSH
94554: LD_VAR 0 4
94558: PPUSH
94559: LD_VAR 0 5
94563: PPUSH
94564: LD_VAR 0 6
94568: PPUSH
94569: LD_VAR 0 7
94573: PPUSH
94574: LD_VAR 0 8
94578: PPUSH
94579: LD_VAR 0 9
94583: PPUSH
94584: LD_VAR 0 10
94588: PPUSH
94589: LD_VAR 0 11
94593: PPUSH
94594: CALL 107139 0 11
94598: GO 94601
94600: POP
// end ;
94601: PPOPN 11
94603: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
94604: LD_VAR 0 1
94608: PPUSH
94609: LD_VAR 0 2
94613: PPUSH
94614: LD_VAR 0 3
94618: PPUSH
94619: LD_VAR 0 4
94623: PPUSH
94624: LD_VAR 0 5
94628: PPUSH
94629: CALL 89857 0 5
// end ; end_of_file
94633: PPOPN 5
94635: END
// export globalGameSaveCounter ; every 0 0$1 do
94636: GO 94638
94638: DISABLE
// begin enable ;
94639: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94640: LD_STRING updateTimer(
94642: PUSH
94643: LD_OWVAR 1
94647: STR
94648: PUSH
94649: LD_STRING );
94651: STR
94652: PPUSH
94653: CALL_OW 559
// end ;
94657: END
// every 0 0$1 do
94658: GO 94660
94660: DISABLE
// begin globalGameSaveCounter := 0 ;
94661: LD_ADDR_EXP 98
94665: PUSH
94666: LD_INT 0
94668: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
94669: LD_STRING setGameSaveCounter(0)
94671: PPUSH
94672: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
94676: LD_STRING initStreamRollete();
94678: PPUSH
94679: CALL_OW 559
// InitStreamMode ;
94683: CALL 96009 0 0
// DefineStreamItems ( false ) ;
94687: LD_INT 0
94689: PPUSH
94690: CALL 96473 0 1
// end ;
94694: END
// export function SOS_MapStart ( ) ; begin
94695: LD_INT 0
94697: PPUSH
// if streamModeActive then
94698: LD_EXP 99
94702: IFFALSE 94711
// DefineStreamItems ( true ) ;
94704: LD_INT 1
94706: PPUSH
94707: CALL 96473 0 1
// UpdateLuaVariables ( ) ;
94711: CALL 94728 0 0
// UpdateFactoryWaypoints ( ) ;
94715: CALL 109342 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94719: CALL 109599 0 0
// end ;
94723: LD_VAR 0 1
94727: RET
// function UpdateLuaVariables ( ) ; begin
94728: LD_INT 0
94730: PPUSH
// if globalGameSaveCounter then
94731: LD_EXP 98
94735: IFFALSE 94769
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
94737: LD_ADDR_EXP 98
94741: PUSH
94742: LD_EXP 98
94746: PPUSH
94747: CALL 48875 0 1
94751: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94752: LD_STRING setGameSaveCounter(
94754: PUSH
94755: LD_EXP 98
94759: STR
94760: PUSH
94761: LD_STRING )
94763: STR
94764: PPUSH
94765: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
94769: LD_STRING setGameDifficulty(
94771: PUSH
94772: LD_OWVAR 67
94776: STR
94777: PUSH
94778: LD_STRING )
94780: STR
94781: PPUSH
94782: CALL_OW 559
// end ;
94786: LD_VAR 0 1
94790: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94791: LD_INT 0
94793: PPUSH
// if p2 = stream_mode then
94794: LD_VAR 0 2
94798: PUSH
94799: LD_INT 100
94801: EQUAL
94802: IFFALSE 95805
// begin if not StreamModeActive then
94804: LD_EXP 99
94808: NOT
94809: IFFALSE 94819
// StreamModeActive := true ;
94811: LD_ADDR_EXP 99
94815: PUSH
94816: LD_INT 1
94818: ST_TO_ADDR
// if p3 = 0 then
94819: LD_VAR 0 3
94823: PUSH
94824: LD_INT 0
94826: EQUAL
94827: IFFALSE 94833
// InitStreamMode ;
94829: CALL 96009 0 0
// if p3 = 1 then
94833: LD_VAR 0 3
94837: PUSH
94838: LD_INT 1
94840: EQUAL
94841: IFFALSE 94851
// sRocket := true ;
94843: LD_ADDR_EXP 104
94847: PUSH
94848: LD_INT 1
94850: ST_TO_ADDR
// if p3 = 2 then
94851: LD_VAR 0 3
94855: PUSH
94856: LD_INT 2
94858: EQUAL
94859: IFFALSE 94869
// sSpeed := true ;
94861: LD_ADDR_EXP 103
94865: PUSH
94866: LD_INT 1
94868: ST_TO_ADDR
// if p3 = 3 then
94869: LD_VAR 0 3
94873: PUSH
94874: LD_INT 3
94876: EQUAL
94877: IFFALSE 94887
// sEngine := true ;
94879: LD_ADDR_EXP 105
94883: PUSH
94884: LD_INT 1
94886: ST_TO_ADDR
// if p3 = 4 then
94887: LD_VAR 0 3
94891: PUSH
94892: LD_INT 4
94894: EQUAL
94895: IFFALSE 94905
// sSpec := true ;
94897: LD_ADDR_EXP 102
94901: PUSH
94902: LD_INT 1
94904: ST_TO_ADDR
// if p3 = 5 then
94905: LD_VAR 0 3
94909: PUSH
94910: LD_INT 5
94912: EQUAL
94913: IFFALSE 94923
// sLevel := true ;
94915: LD_ADDR_EXP 106
94919: PUSH
94920: LD_INT 1
94922: ST_TO_ADDR
// if p3 = 6 then
94923: LD_VAR 0 3
94927: PUSH
94928: LD_INT 6
94930: EQUAL
94931: IFFALSE 94941
// sArmoury := true ;
94933: LD_ADDR_EXP 107
94937: PUSH
94938: LD_INT 1
94940: ST_TO_ADDR
// if p3 = 7 then
94941: LD_VAR 0 3
94945: PUSH
94946: LD_INT 7
94948: EQUAL
94949: IFFALSE 94959
// sRadar := true ;
94951: LD_ADDR_EXP 108
94955: PUSH
94956: LD_INT 1
94958: ST_TO_ADDR
// if p3 = 8 then
94959: LD_VAR 0 3
94963: PUSH
94964: LD_INT 8
94966: EQUAL
94967: IFFALSE 94977
// sBunker := true ;
94969: LD_ADDR_EXP 109
94973: PUSH
94974: LD_INT 1
94976: ST_TO_ADDR
// if p3 = 9 then
94977: LD_VAR 0 3
94981: PUSH
94982: LD_INT 9
94984: EQUAL
94985: IFFALSE 94995
// sHack := true ;
94987: LD_ADDR_EXP 110
94991: PUSH
94992: LD_INT 1
94994: ST_TO_ADDR
// if p3 = 10 then
94995: LD_VAR 0 3
94999: PUSH
95000: LD_INT 10
95002: EQUAL
95003: IFFALSE 95013
// sFire := true ;
95005: LD_ADDR_EXP 111
95009: PUSH
95010: LD_INT 1
95012: ST_TO_ADDR
// if p3 = 11 then
95013: LD_VAR 0 3
95017: PUSH
95018: LD_INT 11
95020: EQUAL
95021: IFFALSE 95031
// sRefresh := true ;
95023: LD_ADDR_EXP 112
95027: PUSH
95028: LD_INT 1
95030: ST_TO_ADDR
// if p3 = 12 then
95031: LD_VAR 0 3
95035: PUSH
95036: LD_INT 12
95038: EQUAL
95039: IFFALSE 95049
// sExp := true ;
95041: LD_ADDR_EXP 113
95045: PUSH
95046: LD_INT 1
95048: ST_TO_ADDR
// if p3 = 13 then
95049: LD_VAR 0 3
95053: PUSH
95054: LD_INT 13
95056: EQUAL
95057: IFFALSE 95067
// sDepot := true ;
95059: LD_ADDR_EXP 114
95063: PUSH
95064: LD_INT 1
95066: ST_TO_ADDR
// if p3 = 14 then
95067: LD_VAR 0 3
95071: PUSH
95072: LD_INT 14
95074: EQUAL
95075: IFFALSE 95085
// sFlag := true ;
95077: LD_ADDR_EXP 115
95081: PUSH
95082: LD_INT 1
95084: ST_TO_ADDR
// if p3 = 15 then
95085: LD_VAR 0 3
95089: PUSH
95090: LD_INT 15
95092: EQUAL
95093: IFFALSE 95103
// sKamikadze := true ;
95095: LD_ADDR_EXP 123
95099: PUSH
95100: LD_INT 1
95102: ST_TO_ADDR
// if p3 = 16 then
95103: LD_VAR 0 3
95107: PUSH
95108: LD_INT 16
95110: EQUAL
95111: IFFALSE 95121
// sTroll := true ;
95113: LD_ADDR_EXP 124
95117: PUSH
95118: LD_INT 1
95120: ST_TO_ADDR
// if p3 = 17 then
95121: LD_VAR 0 3
95125: PUSH
95126: LD_INT 17
95128: EQUAL
95129: IFFALSE 95139
// sSlow := true ;
95131: LD_ADDR_EXP 125
95135: PUSH
95136: LD_INT 1
95138: ST_TO_ADDR
// if p3 = 18 then
95139: LD_VAR 0 3
95143: PUSH
95144: LD_INT 18
95146: EQUAL
95147: IFFALSE 95157
// sLack := true ;
95149: LD_ADDR_EXP 126
95153: PUSH
95154: LD_INT 1
95156: ST_TO_ADDR
// if p3 = 19 then
95157: LD_VAR 0 3
95161: PUSH
95162: LD_INT 19
95164: EQUAL
95165: IFFALSE 95175
// sTank := true ;
95167: LD_ADDR_EXP 128
95171: PUSH
95172: LD_INT 1
95174: ST_TO_ADDR
// if p3 = 20 then
95175: LD_VAR 0 3
95179: PUSH
95180: LD_INT 20
95182: EQUAL
95183: IFFALSE 95193
// sRemote := true ;
95185: LD_ADDR_EXP 129
95189: PUSH
95190: LD_INT 1
95192: ST_TO_ADDR
// if p3 = 21 then
95193: LD_VAR 0 3
95197: PUSH
95198: LD_INT 21
95200: EQUAL
95201: IFFALSE 95211
// sPowell := true ;
95203: LD_ADDR_EXP 130
95207: PUSH
95208: LD_INT 1
95210: ST_TO_ADDR
// if p3 = 22 then
95211: LD_VAR 0 3
95215: PUSH
95216: LD_INT 22
95218: EQUAL
95219: IFFALSE 95229
// sTeleport := true ;
95221: LD_ADDR_EXP 133
95225: PUSH
95226: LD_INT 1
95228: ST_TO_ADDR
// if p3 = 23 then
95229: LD_VAR 0 3
95233: PUSH
95234: LD_INT 23
95236: EQUAL
95237: IFFALSE 95247
// sOilTower := true ;
95239: LD_ADDR_EXP 135
95243: PUSH
95244: LD_INT 1
95246: ST_TO_ADDR
// if p3 = 24 then
95247: LD_VAR 0 3
95251: PUSH
95252: LD_INT 24
95254: EQUAL
95255: IFFALSE 95265
// sShovel := true ;
95257: LD_ADDR_EXP 136
95261: PUSH
95262: LD_INT 1
95264: ST_TO_ADDR
// if p3 = 25 then
95265: LD_VAR 0 3
95269: PUSH
95270: LD_INT 25
95272: EQUAL
95273: IFFALSE 95283
// sSheik := true ;
95275: LD_ADDR_EXP 137
95279: PUSH
95280: LD_INT 1
95282: ST_TO_ADDR
// if p3 = 26 then
95283: LD_VAR 0 3
95287: PUSH
95288: LD_INT 26
95290: EQUAL
95291: IFFALSE 95301
// sEarthquake := true ;
95293: LD_ADDR_EXP 139
95297: PUSH
95298: LD_INT 1
95300: ST_TO_ADDR
// if p3 = 27 then
95301: LD_VAR 0 3
95305: PUSH
95306: LD_INT 27
95308: EQUAL
95309: IFFALSE 95319
// sAI := true ;
95311: LD_ADDR_EXP 140
95315: PUSH
95316: LD_INT 1
95318: ST_TO_ADDR
// if p3 = 28 then
95319: LD_VAR 0 3
95323: PUSH
95324: LD_INT 28
95326: EQUAL
95327: IFFALSE 95337
// sCargo := true ;
95329: LD_ADDR_EXP 143
95333: PUSH
95334: LD_INT 1
95336: ST_TO_ADDR
// if p3 = 29 then
95337: LD_VAR 0 3
95341: PUSH
95342: LD_INT 29
95344: EQUAL
95345: IFFALSE 95355
// sDLaser := true ;
95347: LD_ADDR_EXP 144
95351: PUSH
95352: LD_INT 1
95354: ST_TO_ADDR
// if p3 = 30 then
95355: LD_VAR 0 3
95359: PUSH
95360: LD_INT 30
95362: EQUAL
95363: IFFALSE 95373
// sExchange := true ;
95365: LD_ADDR_EXP 145
95369: PUSH
95370: LD_INT 1
95372: ST_TO_ADDR
// if p3 = 31 then
95373: LD_VAR 0 3
95377: PUSH
95378: LD_INT 31
95380: EQUAL
95381: IFFALSE 95391
// sFac := true ;
95383: LD_ADDR_EXP 146
95387: PUSH
95388: LD_INT 1
95390: ST_TO_ADDR
// if p3 = 32 then
95391: LD_VAR 0 3
95395: PUSH
95396: LD_INT 32
95398: EQUAL
95399: IFFALSE 95409
// sPower := true ;
95401: LD_ADDR_EXP 147
95405: PUSH
95406: LD_INT 1
95408: ST_TO_ADDR
// if p3 = 33 then
95409: LD_VAR 0 3
95413: PUSH
95414: LD_INT 33
95416: EQUAL
95417: IFFALSE 95427
// sRandom := true ;
95419: LD_ADDR_EXP 148
95423: PUSH
95424: LD_INT 1
95426: ST_TO_ADDR
// if p3 = 34 then
95427: LD_VAR 0 3
95431: PUSH
95432: LD_INT 34
95434: EQUAL
95435: IFFALSE 95445
// sShield := true ;
95437: LD_ADDR_EXP 149
95441: PUSH
95442: LD_INT 1
95444: ST_TO_ADDR
// if p3 = 35 then
95445: LD_VAR 0 3
95449: PUSH
95450: LD_INT 35
95452: EQUAL
95453: IFFALSE 95463
// sTime := true ;
95455: LD_ADDR_EXP 150
95459: PUSH
95460: LD_INT 1
95462: ST_TO_ADDR
// if p3 = 36 then
95463: LD_VAR 0 3
95467: PUSH
95468: LD_INT 36
95470: EQUAL
95471: IFFALSE 95481
// sTools := true ;
95473: LD_ADDR_EXP 151
95477: PUSH
95478: LD_INT 1
95480: ST_TO_ADDR
// if p3 = 101 then
95481: LD_VAR 0 3
95485: PUSH
95486: LD_INT 101
95488: EQUAL
95489: IFFALSE 95499
// sSold := true ;
95491: LD_ADDR_EXP 116
95495: PUSH
95496: LD_INT 1
95498: ST_TO_ADDR
// if p3 = 102 then
95499: LD_VAR 0 3
95503: PUSH
95504: LD_INT 102
95506: EQUAL
95507: IFFALSE 95517
// sDiff := true ;
95509: LD_ADDR_EXP 117
95513: PUSH
95514: LD_INT 1
95516: ST_TO_ADDR
// if p3 = 103 then
95517: LD_VAR 0 3
95521: PUSH
95522: LD_INT 103
95524: EQUAL
95525: IFFALSE 95535
// sFog := true ;
95527: LD_ADDR_EXP 120
95531: PUSH
95532: LD_INT 1
95534: ST_TO_ADDR
// if p3 = 104 then
95535: LD_VAR 0 3
95539: PUSH
95540: LD_INT 104
95542: EQUAL
95543: IFFALSE 95553
// sReset := true ;
95545: LD_ADDR_EXP 121
95549: PUSH
95550: LD_INT 1
95552: ST_TO_ADDR
// if p3 = 105 then
95553: LD_VAR 0 3
95557: PUSH
95558: LD_INT 105
95560: EQUAL
95561: IFFALSE 95571
// sSun := true ;
95563: LD_ADDR_EXP 122
95567: PUSH
95568: LD_INT 1
95570: ST_TO_ADDR
// if p3 = 106 then
95571: LD_VAR 0 3
95575: PUSH
95576: LD_INT 106
95578: EQUAL
95579: IFFALSE 95589
// sTiger := true ;
95581: LD_ADDR_EXP 118
95585: PUSH
95586: LD_INT 1
95588: ST_TO_ADDR
// if p3 = 107 then
95589: LD_VAR 0 3
95593: PUSH
95594: LD_INT 107
95596: EQUAL
95597: IFFALSE 95607
// sBomb := true ;
95599: LD_ADDR_EXP 119
95603: PUSH
95604: LD_INT 1
95606: ST_TO_ADDR
// if p3 = 108 then
95607: LD_VAR 0 3
95611: PUSH
95612: LD_INT 108
95614: EQUAL
95615: IFFALSE 95625
// sWound := true ;
95617: LD_ADDR_EXP 127
95621: PUSH
95622: LD_INT 1
95624: ST_TO_ADDR
// if p3 = 109 then
95625: LD_VAR 0 3
95629: PUSH
95630: LD_INT 109
95632: EQUAL
95633: IFFALSE 95643
// sBetray := true ;
95635: LD_ADDR_EXP 131
95639: PUSH
95640: LD_INT 1
95642: ST_TO_ADDR
// if p3 = 110 then
95643: LD_VAR 0 3
95647: PUSH
95648: LD_INT 110
95650: EQUAL
95651: IFFALSE 95661
// sContamin := true ;
95653: LD_ADDR_EXP 132
95657: PUSH
95658: LD_INT 1
95660: ST_TO_ADDR
// if p3 = 111 then
95661: LD_VAR 0 3
95665: PUSH
95666: LD_INT 111
95668: EQUAL
95669: IFFALSE 95679
// sOil := true ;
95671: LD_ADDR_EXP 134
95675: PUSH
95676: LD_INT 1
95678: ST_TO_ADDR
// if p3 = 112 then
95679: LD_VAR 0 3
95683: PUSH
95684: LD_INT 112
95686: EQUAL
95687: IFFALSE 95697
// sStu := true ;
95689: LD_ADDR_EXP 138
95693: PUSH
95694: LD_INT 1
95696: ST_TO_ADDR
// if p3 = 113 then
95697: LD_VAR 0 3
95701: PUSH
95702: LD_INT 113
95704: EQUAL
95705: IFFALSE 95715
// sBazooka := true ;
95707: LD_ADDR_EXP 141
95711: PUSH
95712: LD_INT 1
95714: ST_TO_ADDR
// if p3 = 114 then
95715: LD_VAR 0 3
95719: PUSH
95720: LD_INT 114
95722: EQUAL
95723: IFFALSE 95733
// sMortar := true ;
95725: LD_ADDR_EXP 142
95729: PUSH
95730: LD_INT 1
95732: ST_TO_ADDR
// if p3 = 115 then
95733: LD_VAR 0 3
95737: PUSH
95738: LD_INT 115
95740: EQUAL
95741: IFFALSE 95751
// sRanger := true ;
95743: LD_ADDR_EXP 152
95747: PUSH
95748: LD_INT 1
95750: ST_TO_ADDR
// if p3 = 116 then
95751: LD_VAR 0 3
95755: PUSH
95756: LD_INT 116
95758: EQUAL
95759: IFFALSE 95769
// sComputer := true ;
95761: LD_ADDR_EXP 153
95765: PUSH
95766: LD_INT 1
95768: ST_TO_ADDR
// if p3 = 117 then
95769: LD_VAR 0 3
95773: PUSH
95774: LD_INT 117
95776: EQUAL
95777: IFFALSE 95787
// s30 := true ;
95779: LD_ADDR_EXP 154
95783: PUSH
95784: LD_INT 1
95786: ST_TO_ADDR
// if p3 = 118 then
95787: LD_VAR 0 3
95791: PUSH
95792: LD_INT 118
95794: EQUAL
95795: IFFALSE 95805
// s60 := true ;
95797: LD_ADDR_EXP 155
95801: PUSH
95802: LD_INT 1
95804: ST_TO_ADDR
// end ; if p2 = hack_mode then
95805: LD_VAR 0 2
95809: PUSH
95810: LD_INT 101
95812: EQUAL
95813: IFFALSE 95941
// begin case p3 of 1 :
95815: LD_VAR 0 3
95819: PUSH
95820: LD_INT 1
95822: DOUBLE
95823: EQUAL
95824: IFTRUE 95828
95826: GO 95835
95828: POP
// hHackUnlimitedResources ; 2 :
95829: CALL 108088 0 0
95833: GO 95941
95835: LD_INT 2
95837: DOUBLE
95838: EQUAL
95839: IFTRUE 95843
95841: GO 95850
95843: POP
// hHackSetLevel10 ; 3 :
95844: CALL 108221 0 0
95848: GO 95941
95850: LD_INT 3
95852: DOUBLE
95853: EQUAL
95854: IFTRUE 95858
95856: GO 95865
95858: POP
// hHackSetLevel10YourUnits ; 4 :
95859: CALL 108306 0 0
95863: GO 95941
95865: LD_INT 4
95867: DOUBLE
95868: EQUAL
95869: IFTRUE 95873
95871: GO 95880
95873: POP
// hHackInvincible ; 5 :
95874: CALL 108754 0 0
95878: GO 95941
95880: LD_INT 5
95882: DOUBLE
95883: EQUAL
95884: IFTRUE 95888
95886: GO 95895
95888: POP
// hHackInvisible ; 6 :
95889: CALL 108865 0 0
95893: GO 95941
95895: LD_INT 6
95897: DOUBLE
95898: EQUAL
95899: IFTRUE 95903
95901: GO 95910
95903: POP
// hHackChangeYourSide ; 7 :
95904: CALL 108922 0 0
95908: GO 95941
95910: LD_INT 7
95912: DOUBLE
95913: EQUAL
95914: IFTRUE 95918
95916: GO 95925
95918: POP
// hHackChangeUnitSide ; 8 :
95919: CALL 108964 0 0
95923: GO 95941
95925: LD_INT 8
95927: DOUBLE
95928: EQUAL
95929: IFTRUE 95933
95931: GO 95940
95933: POP
// hHackFog ; end ;
95934: CALL 109065 0 0
95938: GO 95941
95940: POP
// end ; if p2 = game_save_mode then
95941: LD_VAR 0 2
95945: PUSH
95946: LD_INT 102
95948: EQUAL
95949: IFFALSE 96004
// begin if p3 = 1 then
95951: LD_VAR 0 3
95955: PUSH
95956: LD_INT 1
95958: EQUAL
95959: IFFALSE 95971
// globalGameSaveCounter := p4 ;
95961: LD_ADDR_EXP 98
95965: PUSH
95966: LD_VAR 0 4
95970: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95971: LD_VAR 0 3
95975: PUSH
95976: LD_INT 2
95978: EQUAL
95979: PUSH
95980: LD_EXP 98
95984: AND
95985: IFFALSE 96004
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95987: LD_STRING setGameSaveCounter(
95989: PUSH
95990: LD_EXP 98
95994: STR
95995: PUSH
95996: LD_STRING )
95998: STR
95999: PPUSH
96000: CALL_OW 559
// end ; end ;
96004: LD_VAR 0 7
96008: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
96009: LD_INT 0
96011: PPUSH
// streamModeActive := false ;
96012: LD_ADDR_EXP 99
96016: PUSH
96017: LD_INT 0
96019: ST_TO_ADDR
// normalCounter := 36 ;
96020: LD_ADDR_EXP 100
96024: PUSH
96025: LD_INT 36
96027: ST_TO_ADDR
// hardcoreCounter := 18 ;
96028: LD_ADDR_EXP 101
96032: PUSH
96033: LD_INT 18
96035: ST_TO_ADDR
// sRocket := false ;
96036: LD_ADDR_EXP 104
96040: PUSH
96041: LD_INT 0
96043: ST_TO_ADDR
// sSpeed := false ;
96044: LD_ADDR_EXP 103
96048: PUSH
96049: LD_INT 0
96051: ST_TO_ADDR
// sEngine := false ;
96052: LD_ADDR_EXP 105
96056: PUSH
96057: LD_INT 0
96059: ST_TO_ADDR
// sSpec := false ;
96060: LD_ADDR_EXP 102
96064: PUSH
96065: LD_INT 0
96067: ST_TO_ADDR
// sLevel := false ;
96068: LD_ADDR_EXP 106
96072: PUSH
96073: LD_INT 0
96075: ST_TO_ADDR
// sArmoury := false ;
96076: LD_ADDR_EXP 107
96080: PUSH
96081: LD_INT 0
96083: ST_TO_ADDR
// sRadar := false ;
96084: LD_ADDR_EXP 108
96088: PUSH
96089: LD_INT 0
96091: ST_TO_ADDR
// sBunker := false ;
96092: LD_ADDR_EXP 109
96096: PUSH
96097: LD_INT 0
96099: ST_TO_ADDR
// sHack := false ;
96100: LD_ADDR_EXP 110
96104: PUSH
96105: LD_INT 0
96107: ST_TO_ADDR
// sFire := false ;
96108: LD_ADDR_EXP 111
96112: PUSH
96113: LD_INT 0
96115: ST_TO_ADDR
// sRefresh := false ;
96116: LD_ADDR_EXP 112
96120: PUSH
96121: LD_INT 0
96123: ST_TO_ADDR
// sExp := false ;
96124: LD_ADDR_EXP 113
96128: PUSH
96129: LD_INT 0
96131: ST_TO_ADDR
// sDepot := false ;
96132: LD_ADDR_EXP 114
96136: PUSH
96137: LD_INT 0
96139: ST_TO_ADDR
// sFlag := false ;
96140: LD_ADDR_EXP 115
96144: PUSH
96145: LD_INT 0
96147: ST_TO_ADDR
// sKamikadze := false ;
96148: LD_ADDR_EXP 123
96152: PUSH
96153: LD_INT 0
96155: ST_TO_ADDR
// sTroll := false ;
96156: LD_ADDR_EXP 124
96160: PUSH
96161: LD_INT 0
96163: ST_TO_ADDR
// sSlow := false ;
96164: LD_ADDR_EXP 125
96168: PUSH
96169: LD_INT 0
96171: ST_TO_ADDR
// sLack := false ;
96172: LD_ADDR_EXP 126
96176: PUSH
96177: LD_INT 0
96179: ST_TO_ADDR
// sTank := false ;
96180: LD_ADDR_EXP 128
96184: PUSH
96185: LD_INT 0
96187: ST_TO_ADDR
// sRemote := false ;
96188: LD_ADDR_EXP 129
96192: PUSH
96193: LD_INT 0
96195: ST_TO_ADDR
// sPowell := false ;
96196: LD_ADDR_EXP 130
96200: PUSH
96201: LD_INT 0
96203: ST_TO_ADDR
// sTeleport := false ;
96204: LD_ADDR_EXP 133
96208: PUSH
96209: LD_INT 0
96211: ST_TO_ADDR
// sOilTower := false ;
96212: LD_ADDR_EXP 135
96216: PUSH
96217: LD_INT 0
96219: ST_TO_ADDR
// sShovel := false ;
96220: LD_ADDR_EXP 136
96224: PUSH
96225: LD_INT 0
96227: ST_TO_ADDR
// sSheik := false ;
96228: LD_ADDR_EXP 137
96232: PUSH
96233: LD_INT 0
96235: ST_TO_ADDR
// sEarthquake := false ;
96236: LD_ADDR_EXP 139
96240: PUSH
96241: LD_INT 0
96243: ST_TO_ADDR
// sAI := false ;
96244: LD_ADDR_EXP 140
96248: PUSH
96249: LD_INT 0
96251: ST_TO_ADDR
// sCargo := false ;
96252: LD_ADDR_EXP 143
96256: PUSH
96257: LD_INT 0
96259: ST_TO_ADDR
// sDLaser := false ;
96260: LD_ADDR_EXP 144
96264: PUSH
96265: LD_INT 0
96267: ST_TO_ADDR
// sExchange := false ;
96268: LD_ADDR_EXP 145
96272: PUSH
96273: LD_INT 0
96275: ST_TO_ADDR
// sFac := false ;
96276: LD_ADDR_EXP 146
96280: PUSH
96281: LD_INT 0
96283: ST_TO_ADDR
// sPower := false ;
96284: LD_ADDR_EXP 147
96288: PUSH
96289: LD_INT 0
96291: ST_TO_ADDR
// sRandom := false ;
96292: LD_ADDR_EXP 148
96296: PUSH
96297: LD_INT 0
96299: ST_TO_ADDR
// sShield := false ;
96300: LD_ADDR_EXP 149
96304: PUSH
96305: LD_INT 0
96307: ST_TO_ADDR
// sTime := false ;
96308: LD_ADDR_EXP 150
96312: PUSH
96313: LD_INT 0
96315: ST_TO_ADDR
// sTools := false ;
96316: LD_ADDR_EXP 151
96320: PUSH
96321: LD_INT 0
96323: ST_TO_ADDR
// sSold := false ;
96324: LD_ADDR_EXP 116
96328: PUSH
96329: LD_INT 0
96331: ST_TO_ADDR
// sDiff := false ;
96332: LD_ADDR_EXP 117
96336: PUSH
96337: LD_INT 0
96339: ST_TO_ADDR
// sFog := false ;
96340: LD_ADDR_EXP 120
96344: PUSH
96345: LD_INT 0
96347: ST_TO_ADDR
// sReset := false ;
96348: LD_ADDR_EXP 121
96352: PUSH
96353: LD_INT 0
96355: ST_TO_ADDR
// sSun := false ;
96356: LD_ADDR_EXP 122
96360: PUSH
96361: LD_INT 0
96363: ST_TO_ADDR
// sTiger := false ;
96364: LD_ADDR_EXP 118
96368: PUSH
96369: LD_INT 0
96371: ST_TO_ADDR
// sBomb := false ;
96372: LD_ADDR_EXP 119
96376: PUSH
96377: LD_INT 0
96379: ST_TO_ADDR
// sWound := false ;
96380: LD_ADDR_EXP 127
96384: PUSH
96385: LD_INT 0
96387: ST_TO_ADDR
// sBetray := false ;
96388: LD_ADDR_EXP 131
96392: PUSH
96393: LD_INT 0
96395: ST_TO_ADDR
// sContamin := false ;
96396: LD_ADDR_EXP 132
96400: PUSH
96401: LD_INT 0
96403: ST_TO_ADDR
// sOil := false ;
96404: LD_ADDR_EXP 134
96408: PUSH
96409: LD_INT 0
96411: ST_TO_ADDR
// sStu := false ;
96412: LD_ADDR_EXP 138
96416: PUSH
96417: LD_INT 0
96419: ST_TO_ADDR
// sBazooka := false ;
96420: LD_ADDR_EXP 141
96424: PUSH
96425: LD_INT 0
96427: ST_TO_ADDR
// sMortar := false ;
96428: LD_ADDR_EXP 142
96432: PUSH
96433: LD_INT 0
96435: ST_TO_ADDR
// sRanger := false ;
96436: LD_ADDR_EXP 152
96440: PUSH
96441: LD_INT 0
96443: ST_TO_ADDR
// sComputer := false ;
96444: LD_ADDR_EXP 153
96448: PUSH
96449: LD_INT 0
96451: ST_TO_ADDR
// s30 := false ;
96452: LD_ADDR_EXP 154
96456: PUSH
96457: LD_INT 0
96459: ST_TO_ADDR
// s60 := false ;
96460: LD_ADDR_EXP 155
96464: PUSH
96465: LD_INT 0
96467: ST_TO_ADDR
// end ;
96468: LD_VAR 0 1
96472: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96473: LD_INT 0
96475: PPUSH
96476: PPUSH
96477: PPUSH
96478: PPUSH
96479: PPUSH
96480: PPUSH
96481: PPUSH
// result := [ ] ;
96482: LD_ADDR_VAR 0 2
96486: PUSH
96487: EMPTY
96488: ST_TO_ADDR
// if campaign_id = 1 then
96489: LD_OWVAR 69
96493: PUSH
96494: LD_INT 1
96496: EQUAL
96497: IFFALSE 99663
// begin case mission_number of 1 :
96499: LD_OWVAR 70
96503: PUSH
96504: LD_INT 1
96506: DOUBLE
96507: EQUAL
96508: IFTRUE 96512
96510: GO 96588
96512: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96513: LD_ADDR_VAR 0 2
96517: PUSH
96518: LD_INT 2
96520: PUSH
96521: LD_INT 4
96523: PUSH
96524: LD_INT 11
96526: PUSH
96527: LD_INT 12
96529: PUSH
96530: LD_INT 15
96532: PUSH
96533: LD_INT 16
96535: PUSH
96536: LD_INT 22
96538: PUSH
96539: LD_INT 23
96541: PUSH
96542: LD_INT 26
96544: PUSH
96545: EMPTY
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: PUSH
96556: LD_INT 101
96558: PUSH
96559: LD_INT 102
96561: PUSH
96562: LD_INT 106
96564: PUSH
96565: LD_INT 116
96567: PUSH
96568: LD_INT 117
96570: PUSH
96571: LD_INT 118
96573: PUSH
96574: EMPTY
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: ST_TO_ADDR
96586: GO 99661
96588: LD_INT 2
96590: DOUBLE
96591: EQUAL
96592: IFTRUE 96596
96594: GO 96680
96596: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96597: LD_ADDR_VAR 0 2
96601: PUSH
96602: LD_INT 2
96604: PUSH
96605: LD_INT 4
96607: PUSH
96608: LD_INT 11
96610: PUSH
96611: LD_INT 12
96613: PUSH
96614: LD_INT 15
96616: PUSH
96617: LD_INT 16
96619: PUSH
96620: LD_INT 22
96622: PUSH
96623: LD_INT 23
96625: PUSH
96626: LD_INT 26
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: PUSH
96640: LD_INT 101
96642: PUSH
96643: LD_INT 102
96645: PUSH
96646: LD_INT 105
96648: PUSH
96649: LD_INT 106
96651: PUSH
96652: LD_INT 108
96654: PUSH
96655: LD_INT 116
96657: PUSH
96658: LD_INT 117
96660: PUSH
96661: LD_INT 118
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: ST_TO_ADDR
96678: GO 99661
96680: LD_INT 3
96682: DOUBLE
96683: EQUAL
96684: IFTRUE 96688
96686: GO 96776
96688: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96689: LD_ADDR_VAR 0 2
96693: PUSH
96694: LD_INT 2
96696: PUSH
96697: LD_INT 4
96699: PUSH
96700: LD_INT 5
96702: PUSH
96703: LD_INT 11
96705: PUSH
96706: LD_INT 12
96708: PUSH
96709: LD_INT 15
96711: PUSH
96712: LD_INT 16
96714: PUSH
96715: LD_INT 22
96717: PUSH
96718: LD_INT 26
96720: PUSH
96721: LD_INT 36
96723: PUSH
96724: EMPTY
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: PUSH
96736: LD_INT 101
96738: PUSH
96739: LD_INT 102
96741: PUSH
96742: LD_INT 105
96744: PUSH
96745: LD_INT 106
96747: PUSH
96748: LD_INT 108
96750: PUSH
96751: LD_INT 116
96753: PUSH
96754: LD_INT 117
96756: PUSH
96757: LD_INT 118
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: PUSH
96770: EMPTY
96771: LIST
96772: LIST
96773: ST_TO_ADDR
96774: GO 99661
96776: LD_INT 4
96778: DOUBLE
96779: EQUAL
96780: IFTRUE 96784
96782: GO 96880
96784: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96785: LD_ADDR_VAR 0 2
96789: PUSH
96790: LD_INT 2
96792: PUSH
96793: LD_INT 4
96795: PUSH
96796: LD_INT 5
96798: PUSH
96799: LD_INT 8
96801: PUSH
96802: LD_INT 11
96804: PUSH
96805: LD_INT 12
96807: PUSH
96808: LD_INT 15
96810: PUSH
96811: LD_INT 16
96813: PUSH
96814: LD_INT 22
96816: PUSH
96817: LD_INT 23
96819: PUSH
96820: LD_INT 26
96822: PUSH
96823: LD_INT 36
96825: PUSH
96826: EMPTY
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: PUSH
96840: LD_INT 101
96842: PUSH
96843: LD_INT 102
96845: PUSH
96846: LD_INT 105
96848: PUSH
96849: LD_INT 106
96851: PUSH
96852: LD_INT 108
96854: PUSH
96855: LD_INT 116
96857: PUSH
96858: LD_INT 117
96860: PUSH
96861: LD_INT 118
96863: PUSH
96864: EMPTY
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: PUSH
96874: EMPTY
96875: LIST
96876: LIST
96877: ST_TO_ADDR
96878: GO 99661
96880: LD_INT 5
96882: DOUBLE
96883: EQUAL
96884: IFTRUE 96888
96886: GO 97000
96888: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96889: LD_ADDR_VAR 0 2
96893: PUSH
96894: LD_INT 2
96896: PUSH
96897: LD_INT 4
96899: PUSH
96900: LD_INT 5
96902: PUSH
96903: LD_INT 6
96905: PUSH
96906: LD_INT 8
96908: PUSH
96909: LD_INT 11
96911: PUSH
96912: LD_INT 12
96914: PUSH
96915: LD_INT 15
96917: PUSH
96918: LD_INT 16
96920: PUSH
96921: LD_INT 22
96923: PUSH
96924: LD_INT 23
96926: PUSH
96927: LD_INT 25
96929: PUSH
96930: LD_INT 26
96932: PUSH
96933: LD_INT 36
96935: PUSH
96936: EMPTY
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: PUSH
96952: LD_INT 101
96954: PUSH
96955: LD_INT 102
96957: PUSH
96958: LD_INT 105
96960: PUSH
96961: LD_INT 106
96963: PUSH
96964: LD_INT 108
96966: PUSH
96967: LD_INT 109
96969: PUSH
96970: LD_INT 112
96972: PUSH
96973: LD_INT 116
96975: PUSH
96976: LD_INT 117
96978: PUSH
96979: LD_INT 118
96981: PUSH
96982: EMPTY
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: PUSH
96994: EMPTY
96995: LIST
96996: LIST
96997: ST_TO_ADDR
96998: GO 99661
97000: LD_INT 6
97002: DOUBLE
97003: EQUAL
97004: IFTRUE 97008
97006: GO 97140
97008: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97009: LD_ADDR_VAR 0 2
97013: PUSH
97014: LD_INT 2
97016: PUSH
97017: LD_INT 4
97019: PUSH
97020: LD_INT 5
97022: PUSH
97023: LD_INT 6
97025: PUSH
97026: LD_INT 8
97028: PUSH
97029: LD_INT 11
97031: PUSH
97032: LD_INT 12
97034: PUSH
97035: LD_INT 15
97037: PUSH
97038: LD_INT 16
97040: PUSH
97041: LD_INT 20
97043: PUSH
97044: LD_INT 21
97046: PUSH
97047: LD_INT 22
97049: PUSH
97050: LD_INT 23
97052: PUSH
97053: LD_INT 25
97055: PUSH
97056: LD_INT 26
97058: PUSH
97059: LD_INT 30
97061: PUSH
97062: LD_INT 31
97064: PUSH
97065: LD_INT 32
97067: PUSH
97068: LD_INT 36
97070: PUSH
97071: EMPTY
97072: LIST
97073: LIST
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: PUSH
97092: LD_INT 101
97094: PUSH
97095: LD_INT 102
97097: PUSH
97098: LD_INT 105
97100: PUSH
97101: LD_INT 106
97103: PUSH
97104: LD_INT 108
97106: PUSH
97107: LD_INT 109
97109: PUSH
97110: LD_INT 112
97112: PUSH
97113: LD_INT 116
97115: PUSH
97116: LD_INT 117
97118: PUSH
97119: LD_INT 118
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: PUSH
97134: EMPTY
97135: LIST
97136: LIST
97137: ST_TO_ADDR
97138: GO 99661
97140: LD_INT 7
97142: DOUBLE
97143: EQUAL
97144: IFTRUE 97148
97146: GO 97260
97148: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97149: LD_ADDR_VAR 0 2
97153: PUSH
97154: LD_INT 2
97156: PUSH
97157: LD_INT 4
97159: PUSH
97160: LD_INT 5
97162: PUSH
97163: LD_INT 7
97165: PUSH
97166: LD_INT 11
97168: PUSH
97169: LD_INT 12
97171: PUSH
97172: LD_INT 15
97174: PUSH
97175: LD_INT 16
97177: PUSH
97178: LD_INT 20
97180: PUSH
97181: LD_INT 21
97183: PUSH
97184: LD_INT 22
97186: PUSH
97187: LD_INT 23
97189: PUSH
97190: LD_INT 25
97192: PUSH
97193: LD_INT 26
97195: PUSH
97196: EMPTY
97197: LIST
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: PUSH
97212: LD_INT 101
97214: PUSH
97215: LD_INT 102
97217: PUSH
97218: LD_INT 103
97220: PUSH
97221: LD_INT 105
97223: PUSH
97224: LD_INT 106
97226: PUSH
97227: LD_INT 108
97229: PUSH
97230: LD_INT 112
97232: PUSH
97233: LD_INT 116
97235: PUSH
97236: LD_INT 117
97238: PUSH
97239: LD_INT 118
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: PUSH
97254: EMPTY
97255: LIST
97256: LIST
97257: ST_TO_ADDR
97258: GO 99661
97260: LD_INT 8
97262: DOUBLE
97263: EQUAL
97264: IFTRUE 97268
97266: GO 97408
97268: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97269: LD_ADDR_VAR 0 2
97273: PUSH
97274: LD_INT 2
97276: PUSH
97277: LD_INT 4
97279: PUSH
97280: LD_INT 5
97282: PUSH
97283: LD_INT 6
97285: PUSH
97286: LD_INT 7
97288: PUSH
97289: LD_INT 8
97291: PUSH
97292: LD_INT 11
97294: PUSH
97295: LD_INT 12
97297: PUSH
97298: LD_INT 15
97300: PUSH
97301: LD_INT 16
97303: PUSH
97304: LD_INT 20
97306: PUSH
97307: LD_INT 21
97309: PUSH
97310: LD_INT 22
97312: PUSH
97313: LD_INT 23
97315: PUSH
97316: LD_INT 25
97318: PUSH
97319: LD_INT 26
97321: PUSH
97322: LD_INT 30
97324: PUSH
97325: LD_INT 31
97327: PUSH
97328: LD_INT 32
97330: PUSH
97331: LD_INT 36
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: PUSH
97356: LD_INT 101
97358: PUSH
97359: LD_INT 102
97361: PUSH
97362: LD_INT 103
97364: PUSH
97365: LD_INT 105
97367: PUSH
97368: LD_INT 106
97370: PUSH
97371: LD_INT 108
97373: PUSH
97374: LD_INT 109
97376: PUSH
97377: LD_INT 112
97379: PUSH
97380: LD_INT 116
97382: PUSH
97383: LD_INT 117
97385: PUSH
97386: LD_INT 118
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: PUSH
97402: EMPTY
97403: LIST
97404: LIST
97405: ST_TO_ADDR
97406: GO 99661
97408: LD_INT 9
97410: DOUBLE
97411: EQUAL
97412: IFTRUE 97416
97414: GO 97564
97416: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97417: LD_ADDR_VAR 0 2
97421: PUSH
97422: LD_INT 2
97424: PUSH
97425: LD_INT 4
97427: PUSH
97428: LD_INT 5
97430: PUSH
97431: LD_INT 6
97433: PUSH
97434: LD_INT 7
97436: PUSH
97437: LD_INT 8
97439: PUSH
97440: LD_INT 11
97442: PUSH
97443: LD_INT 12
97445: PUSH
97446: LD_INT 15
97448: PUSH
97449: LD_INT 16
97451: PUSH
97452: LD_INT 20
97454: PUSH
97455: LD_INT 21
97457: PUSH
97458: LD_INT 22
97460: PUSH
97461: LD_INT 23
97463: PUSH
97464: LD_INT 25
97466: PUSH
97467: LD_INT 26
97469: PUSH
97470: LD_INT 28
97472: PUSH
97473: LD_INT 30
97475: PUSH
97476: LD_INT 31
97478: PUSH
97479: LD_INT 32
97481: PUSH
97482: LD_INT 36
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: PUSH
97508: LD_INT 101
97510: PUSH
97511: LD_INT 102
97513: PUSH
97514: LD_INT 103
97516: PUSH
97517: LD_INT 105
97519: PUSH
97520: LD_INT 106
97522: PUSH
97523: LD_INT 108
97525: PUSH
97526: LD_INT 109
97528: PUSH
97529: LD_INT 112
97531: PUSH
97532: LD_INT 114
97534: PUSH
97535: LD_INT 116
97537: PUSH
97538: LD_INT 117
97540: PUSH
97541: LD_INT 118
97543: PUSH
97544: EMPTY
97545: LIST
97546: LIST
97547: LIST
97548: LIST
97549: LIST
97550: LIST
97551: LIST
97552: LIST
97553: LIST
97554: LIST
97555: LIST
97556: LIST
97557: PUSH
97558: EMPTY
97559: LIST
97560: LIST
97561: ST_TO_ADDR
97562: GO 99661
97564: LD_INT 10
97566: DOUBLE
97567: EQUAL
97568: IFTRUE 97572
97570: GO 97768
97572: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97573: LD_ADDR_VAR 0 2
97577: PUSH
97578: LD_INT 2
97580: PUSH
97581: LD_INT 4
97583: PUSH
97584: LD_INT 5
97586: PUSH
97587: LD_INT 6
97589: PUSH
97590: LD_INT 7
97592: PUSH
97593: LD_INT 8
97595: PUSH
97596: LD_INT 9
97598: PUSH
97599: LD_INT 10
97601: PUSH
97602: LD_INT 11
97604: PUSH
97605: LD_INT 12
97607: PUSH
97608: LD_INT 13
97610: PUSH
97611: LD_INT 14
97613: PUSH
97614: LD_INT 15
97616: PUSH
97617: LD_INT 16
97619: PUSH
97620: LD_INT 17
97622: PUSH
97623: LD_INT 18
97625: PUSH
97626: LD_INT 19
97628: PUSH
97629: LD_INT 20
97631: PUSH
97632: LD_INT 21
97634: PUSH
97635: LD_INT 22
97637: PUSH
97638: LD_INT 23
97640: PUSH
97641: LD_INT 24
97643: PUSH
97644: LD_INT 25
97646: PUSH
97647: LD_INT 26
97649: PUSH
97650: LD_INT 28
97652: PUSH
97653: LD_INT 30
97655: PUSH
97656: LD_INT 31
97658: PUSH
97659: LD_INT 32
97661: PUSH
97662: LD_INT 36
97664: PUSH
97665: EMPTY
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: PUSH
97696: LD_INT 101
97698: PUSH
97699: LD_INT 102
97701: PUSH
97702: LD_INT 103
97704: PUSH
97705: LD_INT 104
97707: PUSH
97708: LD_INT 105
97710: PUSH
97711: LD_INT 106
97713: PUSH
97714: LD_INT 107
97716: PUSH
97717: LD_INT 108
97719: PUSH
97720: LD_INT 109
97722: PUSH
97723: LD_INT 110
97725: PUSH
97726: LD_INT 111
97728: PUSH
97729: LD_INT 112
97731: PUSH
97732: LD_INT 114
97734: PUSH
97735: LD_INT 116
97737: PUSH
97738: LD_INT 117
97740: PUSH
97741: LD_INT 118
97743: PUSH
97744: EMPTY
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: LIST
97760: LIST
97761: PUSH
97762: EMPTY
97763: LIST
97764: LIST
97765: ST_TO_ADDR
97766: GO 99661
97768: LD_INT 11
97770: DOUBLE
97771: EQUAL
97772: IFTRUE 97776
97774: GO 97980
97776: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97777: LD_ADDR_VAR 0 2
97781: PUSH
97782: LD_INT 2
97784: PUSH
97785: LD_INT 3
97787: PUSH
97788: LD_INT 4
97790: PUSH
97791: LD_INT 5
97793: PUSH
97794: LD_INT 6
97796: PUSH
97797: LD_INT 7
97799: PUSH
97800: LD_INT 8
97802: PUSH
97803: LD_INT 9
97805: PUSH
97806: LD_INT 10
97808: PUSH
97809: LD_INT 11
97811: PUSH
97812: LD_INT 12
97814: PUSH
97815: LD_INT 13
97817: PUSH
97818: LD_INT 14
97820: PUSH
97821: LD_INT 15
97823: PUSH
97824: LD_INT 16
97826: PUSH
97827: LD_INT 17
97829: PUSH
97830: LD_INT 18
97832: PUSH
97833: LD_INT 19
97835: PUSH
97836: LD_INT 20
97838: PUSH
97839: LD_INT 21
97841: PUSH
97842: LD_INT 22
97844: PUSH
97845: LD_INT 23
97847: PUSH
97848: LD_INT 24
97850: PUSH
97851: LD_INT 25
97853: PUSH
97854: LD_INT 26
97856: PUSH
97857: LD_INT 28
97859: PUSH
97860: LD_INT 30
97862: PUSH
97863: LD_INT 31
97865: PUSH
97866: LD_INT 32
97868: PUSH
97869: LD_INT 34
97871: PUSH
97872: LD_INT 36
97874: PUSH
97875: EMPTY
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: PUSH
97908: LD_INT 101
97910: PUSH
97911: LD_INT 102
97913: PUSH
97914: LD_INT 103
97916: PUSH
97917: LD_INT 104
97919: PUSH
97920: LD_INT 105
97922: PUSH
97923: LD_INT 106
97925: PUSH
97926: LD_INT 107
97928: PUSH
97929: LD_INT 108
97931: PUSH
97932: LD_INT 109
97934: PUSH
97935: LD_INT 110
97937: PUSH
97938: LD_INT 111
97940: PUSH
97941: LD_INT 112
97943: PUSH
97944: LD_INT 114
97946: PUSH
97947: LD_INT 116
97949: PUSH
97950: LD_INT 117
97952: PUSH
97953: LD_INT 118
97955: PUSH
97956: EMPTY
97957: LIST
97958: LIST
97959: LIST
97960: LIST
97961: LIST
97962: LIST
97963: LIST
97964: LIST
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: PUSH
97974: EMPTY
97975: LIST
97976: LIST
97977: ST_TO_ADDR
97978: GO 99661
97980: LD_INT 12
97982: DOUBLE
97983: EQUAL
97984: IFTRUE 97988
97986: GO 98208
97988: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97989: LD_ADDR_VAR 0 2
97993: PUSH
97994: LD_INT 1
97996: PUSH
97997: LD_INT 2
97999: PUSH
98000: LD_INT 3
98002: PUSH
98003: LD_INT 4
98005: PUSH
98006: LD_INT 5
98008: PUSH
98009: LD_INT 6
98011: PUSH
98012: LD_INT 7
98014: PUSH
98015: LD_INT 8
98017: PUSH
98018: LD_INT 9
98020: PUSH
98021: LD_INT 10
98023: PUSH
98024: LD_INT 11
98026: PUSH
98027: LD_INT 12
98029: PUSH
98030: LD_INT 13
98032: PUSH
98033: LD_INT 14
98035: PUSH
98036: LD_INT 15
98038: PUSH
98039: LD_INT 16
98041: PUSH
98042: LD_INT 17
98044: PUSH
98045: LD_INT 18
98047: PUSH
98048: LD_INT 19
98050: PUSH
98051: LD_INT 20
98053: PUSH
98054: LD_INT 21
98056: PUSH
98057: LD_INT 22
98059: PUSH
98060: LD_INT 23
98062: PUSH
98063: LD_INT 24
98065: PUSH
98066: LD_INT 25
98068: PUSH
98069: LD_INT 26
98071: PUSH
98072: LD_INT 27
98074: PUSH
98075: LD_INT 28
98077: PUSH
98078: LD_INT 30
98080: PUSH
98081: LD_INT 31
98083: PUSH
98084: LD_INT 32
98086: PUSH
98087: LD_INT 33
98089: PUSH
98090: LD_INT 34
98092: PUSH
98093: LD_INT 36
98095: PUSH
98096: EMPTY
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: LIST
98128: LIST
98129: LIST
98130: LIST
98131: PUSH
98132: LD_INT 101
98134: PUSH
98135: LD_INT 102
98137: PUSH
98138: LD_INT 103
98140: PUSH
98141: LD_INT 104
98143: PUSH
98144: LD_INT 105
98146: PUSH
98147: LD_INT 106
98149: PUSH
98150: LD_INT 107
98152: PUSH
98153: LD_INT 108
98155: PUSH
98156: LD_INT 109
98158: PUSH
98159: LD_INT 110
98161: PUSH
98162: LD_INT 111
98164: PUSH
98165: LD_INT 112
98167: PUSH
98168: LD_INT 113
98170: PUSH
98171: LD_INT 114
98173: PUSH
98174: LD_INT 116
98176: PUSH
98177: LD_INT 117
98179: PUSH
98180: LD_INT 118
98182: PUSH
98183: EMPTY
98184: LIST
98185: LIST
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: LIST
98191: LIST
98192: LIST
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: PUSH
98202: EMPTY
98203: LIST
98204: LIST
98205: ST_TO_ADDR
98206: GO 99661
98208: LD_INT 13
98210: DOUBLE
98211: EQUAL
98212: IFTRUE 98216
98214: GO 98424
98216: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98217: LD_ADDR_VAR 0 2
98221: PUSH
98222: LD_INT 1
98224: PUSH
98225: LD_INT 2
98227: PUSH
98228: LD_INT 3
98230: PUSH
98231: LD_INT 4
98233: PUSH
98234: LD_INT 5
98236: PUSH
98237: LD_INT 8
98239: PUSH
98240: LD_INT 9
98242: PUSH
98243: LD_INT 10
98245: PUSH
98246: LD_INT 11
98248: PUSH
98249: LD_INT 12
98251: PUSH
98252: LD_INT 14
98254: PUSH
98255: LD_INT 15
98257: PUSH
98258: LD_INT 16
98260: PUSH
98261: LD_INT 17
98263: PUSH
98264: LD_INT 18
98266: PUSH
98267: LD_INT 19
98269: PUSH
98270: LD_INT 20
98272: PUSH
98273: LD_INT 21
98275: PUSH
98276: LD_INT 22
98278: PUSH
98279: LD_INT 23
98281: PUSH
98282: LD_INT 24
98284: PUSH
98285: LD_INT 25
98287: PUSH
98288: LD_INT 26
98290: PUSH
98291: LD_INT 27
98293: PUSH
98294: LD_INT 28
98296: PUSH
98297: LD_INT 30
98299: PUSH
98300: LD_INT 31
98302: PUSH
98303: LD_INT 32
98305: PUSH
98306: LD_INT 33
98308: PUSH
98309: LD_INT 34
98311: PUSH
98312: LD_INT 36
98314: PUSH
98315: EMPTY
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: PUSH
98348: LD_INT 101
98350: PUSH
98351: LD_INT 102
98353: PUSH
98354: LD_INT 103
98356: PUSH
98357: LD_INT 104
98359: PUSH
98360: LD_INT 105
98362: PUSH
98363: LD_INT 106
98365: PUSH
98366: LD_INT 107
98368: PUSH
98369: LD_INT 108
98371: PUSH
98372: LD_INT 109
98374: PUSH
98375: LD_INT 110
98377: PUSH
98378: LD_INT 111
98380: PUSH
98381: LD_INT 112
98383: PUSH
98384: LD_INT 113
98386: PUSH
98387: LD_INT 114
98389: PUSH
98390: LD_INT 116
98392: PUSH
98393: LD_INT 117
98395: PUSH
98396: LD_INT 118
98398: PUSH
98399: EMPTY
98400: LIST
98401: LIST
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: LIST
98417: PUSH
98418: EMPTY
98419: LIST
98420: LIST
98421: ST_TO_ADDR
98422: GO 99661
98424: LD_INT 14
98426: DOUBLE
98427: EQUAL
98428: IFTRUE 98432
98430: GO 98656
98432: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98433: LD_ADDR_VAR 0 2
98437: PUSH
98438: LD_INT 1
98440: PUSH
98441: LD_INT 2
98443: PUSH
98444: LD_INT 3
98446: PUSH
98447: LD_INT 4
98449: PUSH
98450: LD_INT 5
98452: PUSH
98453: LD_INT 6
98455: PUSH
98456: LD_INT 7
98458: PUSH
98459: LD_INT 8
98461: PUSH
98462: LD_INT 9
98464: PUSH
98465: LD_INT 10
98467: PUSH
98468: LD_INT 11
98470: PUSH
98471: LD_INT 12
98473: PUSH
98474: LD_INT 13
98476: PUSH
98477: LD_INT 14
98479: PUSH
98480: LD_INT 15
98482: PUSH
98483: LD_INT 16
98485: PUSH
98486: LD_INT 17
98488: PUSH
98489: LD_INT 18
98491: PUSH
98492: LD_INT 19
98494: PUSH
98495: LD_INT 20
98497: PUSH
98498: LD_INT 21
98500: PUSH
98501: LD_INT 22
98503: PUSH
98504: LD_INT 23
98506: PUSH
98507: LD_INT 24
98509: PUSH
98510: LD_INT 25
98512: PUSH
98513: LD_INT 26
98515: PUSH
98516: LD_INT 27
98518: PUSH
98519: LD_INT 28
98521: PUSH
98522: LD_INT 29
98524: PUSH
98525: LD_INT 30
98527: PUSH
98528: LD_INT 31
98530: PUSH
98531: LD_INT 32
98533: PUSH
98534: LD_INT 33
98536: PUSH
98537: LD_INT 34
98539: PUSH
98540: LD_INT 36
98542: PUSH
98543: EMPTY
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: LIST
98565: LIST
98566: LIST
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: PUSH
98580: LD_INT 101
98582: PUSH
98583: LD_INT 102
98585: PUSH
98586: LD_INT 103
98588: PUSH
98589: LD_INT 104
98591: PUSH
98592: LD_INT 105
98594: PUSH
98595: LD_INT 106
98597: PUSH
98598: LD_INT 107
98600: PUSH
98601: LD_INT 108
98603: PUSH
98604: LD_INT 109
98606: PUSH
98607: LD_INT 110
98609: PUSH
98610: LD_INT 111
98612: PUSH
98613: LD_INT 112
98615: PUSH
98616: LD_INT 113
98618: PUSH
98619: LD_INT 114
98621: PUSH
98622: LD_INT 116
98624: PUSH
98625: LD_INT 117
98627: PUSH
98628: LD_INT 118
98630: PUSH
98631: EMPTY
98632: LIST
98633: LIST
98634: LIST
98635: LIST
98636: LIST
98637: LIST
98638: LIST
98639: LIST
98640: LIST
98641: LIST
98642: LIST
98643: LIST
98644: LIST
98645: LIST
98646: LIST
98647: LIST
98648: LIST
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: ST_TO_ADDR
98654: GO 99661
98656: LD_INT 15
98658: DOUBLE
98659: EQUAL
98660: IFTRUE 98664
98662: GO 98888
98664: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98665: LD_ADDR_VAR 0 2
98669: PUSH
98670: LD_INT 1
98672: PUSH
98673: LD_INT 2
98675: PUSH
98676: LD_INT 3
98678: PUSH
98679: LD_INT 4
98681: PUSH
98682: LD_INT 5
98684: PUSH
98685: LD_INT 6
98687: PUSH
98688: LD_INT 7
98690: PUSH
98691: LD_INT 8
98693: PUSH
98694: LD_INT 9
98696: PUSH
98697: LD_INT 10
98699: PUSH
98700: LD_INT 11
98702: PUSH
98703: LD_INT 12
98705: PUSH
98706: LD_INT 13
98708: PUSH
98709: LD_INT 14
98711: PUSH
98712: LD_INT 15
98714: PUSH
98715: LD_INT 16
98717: PUSH
98718: LD_INT 17
98720: PUSH
98721: LD_INT 18
98723: PUSH
98724: LD_INT 19
98726: PUSH
98727: LD_INT 20
98729: PUSH
98730: LD_INT 21
98732: PUSH
98733: LD_INT 22
98735: PUSH
98736: LD_INT 23
98738: PUSH
98739: LD_INT 24
98741: PUSH
98742: LD_INT 25
98744: PUSH
98745: LD_INT 26
98747: PUSH
98748: LD_INT 27
98750: PUSH
98751: LD_INT 28
98753: PUSH
98754: LD_INT 29
98756: PUSH
98757: LD_INT 30
98759: PUSH
98760: LD_INT 31
98762: PUSH
98763: LD_INT 32
98765: PUSH
98766: LD_INT 33
98768: PUSH
98769: LD_INT 34
98771: PUSH
98772: LD_INT 36
98774: PUSH
98775: EMPTY
98776: LIST
98777: LIST
98778: LIST
98779: LIST
98780: LIST
98781: LIST
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: LIST
98795: LIST
98796: LIST
98797: LIST
98798: LIST
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: PUSH
98812: LD_INT 101
98814: PUSH
98815: LD_INT 102
98817: PUSH
98818: LD_INT 103
98820: PUSH
98821: LD_INT 104
98823: PUSH
98824: LD_INT 105
98826: PUSH
98827: LD_INT 106
98829: PUSH
98830: LD_INT 107
98832: PUSH
98833: LD_INT 108
98835: PUSH
98836: LD_INT 109
98838: PUSH
98839: LD_INT 110
98841: PUSH
98842: LD_INT 111
98844: PUSH
98845: LD_INT 112
98847: PUSH
98848: LD_INT 113
98850: PUSH
98851: LD_INT 114
98853: PUSH
98854: LD_INT 116
98856: PUSH
98857: LD_INT 117
98859: PUSH
98860: LD_INT 118
98862: PUSH
98863: EMPTY
98864: LIST
98865: LIST
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: LIST
98874: LIST
98875: LIST
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: LIST
98881: PUSH
98882: EMPTY
98883: LIST
98884: LIST
98885: ST_TO_ADDR
98886: GO 99661
98888: LD_INT 16
98890: DOUBLE
98891: EQUAL
98892: IFTRUE 98896
98894: GO 99032
98896: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98897: LD_ADDR_VAR 0 2
98901: PUSH
98902: LD_INT 2
98904: PUSH
98905: LD_INT 4
98907: PUSH
98908: LD_INT 5
98910: PUSH
98911: LD_INT 7
98913: PUSH
98914: LD_INT 11
98916: PUSH
98917: LD_INT 12
98919: PUSH
98920: LD_INT 15
98922: PUSH
98923: LD_INT 16
98925: PUSH
98926: LD_INT 20
98928: PUSH
98929: LD_INT 21
98931: PUSH
98932: LD_INT 22
98934: PUSH
98935: LD_INT 23
98937: PUSH
98938: LD_INT 25
98940: PUSH
98941: LD_INT 26
98943: PUSH
98944: LD_INT 30
98946: PUSH
98947: LD_INT 31
98949: PUSH
98950: LD_INT 32
98952: PUSH
98953: LD_INT 33
98955: PUSH
98956: LD_INT 34
98958: PUSH
98959: EMPTY
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: PUSH
98980: LD_INT 101
98982: PUSH
98983: LD_INT 102
98985: PUSH
98986: LD_INT 103
98988: PUSH
98989: LD_INT 106
98991: PUSH
98992: LD_INT 108
98994: PUSH
98995: LD_INT 112
98997: PUSH
98998: LD_INT 113
99000: PUSH
99001: LD_INT 114
99003: PUSH
99004: LD_INT 116
99006: PUSH
99007: LD_INT 117
99009: PUSH
99010: LD_INT 118
99012: PUSH
99013: EMPTY
99014: LIST
99015: LIST
99016: LIST
99017: LIST
99018: LIST
99019: LIST
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: ST_TO_ADDR
99030: GO 99661
99032: LD_INT 17
99034: DOUBLE
99035: EQUAL
99036: IFTRUE 99040
99038: GO 99264
99040: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99041: LD_ADDR_VAR 0 2
99045: PUSH
99046: LD_INT 1
99048: PUSH
99049: LD_INT 2
99051: PUSH
99052: LD_INT 3
99054: PUSH
99055: LD_INT 4
99057: PUSH
99058: LD_INT 5
99060: PUSH
99061: LD_INT 6
99063: PUSH
99064: LD_INT 7
99066: PUSH
99067: LD_INT 8
99069: PUSH
99070: LD_INT 9
99072: PUSH
99073: LD_INT 10
99075: PUSH
99076: LD_INT 11
99078: PUSH
99079: LD_INT 12
99081: PUSH
99082: LD_INT 13
99084: PUSH
99085: LD_INT 14
99087: PUSH
99088: LD_INT 15
99090: PUSH
99091: LD_INT 16
99093: PUSH
99094: LD_INT 17
99096: PUSH
99097: LD_INT 18
99099: PUSH
99100: LD_INT 19
99102: PUSH
99103: LD_INT 20
99105: PUSH
99106: LD_INT 21
99108: PUSH
99109: LD_INT 22
99111: PUSH
99112: LD_INT 23
99114: PUSH
99115: LD_INT 24
99117: PUSH
99118: LD_INT 25
99120: PUSH
99121: LD_INT 26
99123: PUSH
99124: LD_INT 27
99126: PUSH
99127: LD_INT 28
99129: PUSH
99130: LD_INT 29
99132: PUSH
99133: LD_INT 30
99135: PUSH
99136: LD_INT 31
99138: PUSH
99139: LD_INT 32
99141: PUSH
99142: LD_INT 33
99144: PUSH
99145: LD_INT 34
99147: PUSH
99148: LD_INT 36
99150: PUSH
99151: EMPTY
99152: LIST
99153: LIST
99154: LIST
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: LIST
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: PUSH
99188: LD_INT 101
99190: PUSH
99191: LD_INT 102
99193: PUSH
99194: LD_INT 103
99196: PUSH
99197: LD_INT 104
99199: PUSH
99200: LD_INT 105
99202: PUSH
99203: LD_INT 106
99205: PUSH
99206: LD_INT 107
99208: PUSH
99209: LD_INT 108
99211: PUSH
99212: LD_INT 109
99214: PUSH
99215: LD_INT 110
99217: PUSH
99218: LD_INT 111
99220: PUSH
99221: LD_INT 112
99223: PUSH
99224: LD_INT 113
99226: PUSH
99227: LD_INT 114
99229: PUSH
99230: LD_INT 116
99232: PUSH
99233: LD_INT 117
99235: PUSH
99236: LD_INT 118
99238: PUSH
99239: EMPTY
99240: LIST
99241: LIST
99242: LIST
99243: LIST
99244: LIST
99245: LIST
99246: LIST
99247: LIST
99248: LIST
99249: LIST
99250: LIST
99251: LIST
99252: LIST
99253: LIST
99254: LIST
99255: LIST
99256: LIST
99257: PUSH
99258: EMPTY
99259: LIST
99260: LIST
99261: ST_TO_ADDR
99262: GO 99661
99264: LD_INT 18
99266: DOUBLE
99267: EQUAL
99268: IFTRUE 99272
99270: GO 99420
99272: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99273: LD_ADDR_VAR 0 2
99277: PUSH
99278: LD_INT 2
99280: PUSH
99281: LD_INT 4
99283: PUSH
99284: LD_INT 5
99286: PUSH
99287: LD_INT 7
99289: PUSH
99290: LD_INT 11
99292: PUSH
99293: LD_INT 12
99295: PUSH
99296: LD_INT 15
99298: PUSH
99299: LD_INT 16
99301: PUSH
99302: LD_INT 20
99304: PUSH
99305: LD_INT 21
99307: PUSH
99308: LD_INT 22
99310: PUSH
99311: LD_INT 23
99313: PUSH
99314: LD_INT 25
99316: PUSH
99317: LD_INT 26
99319: PUSH
99320: LD_INT 30
99322: PUSH
99323: LD_INT 31
99325: PUSH
99326: LD_INT 32
99328: PUSH
99329: LD_INT 33
99331: PUSH
99332: LD_INT 34
99334: PUSH
99335: LD_INT 35
99337: PUSH
99338: LD_INT 36
99340: PUSH
99341: EMPTY
99342: LIST
99343: LIST
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: LIST
99349: LIST
99350: LIST
99351: LIST
99352: LIST
99353: LIST
99354: LIST
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: LIST
99361: LIST
99362: LIST
99363: PUSH
99364: LD_INT 101
99366: PUSH
99367: LD_INT 102
99369: PUSH
99370: LD_INT 103
99372: PUSH
99373: LD_INT 106
99375: PUSH
99376: LD_INT 108
99378: PUSH
99379: LD_INT 112
99381: PUSH
99382: LD_INT 113
99384: PUSH
99385: LD_INT 114
99387: PUSH
99388: LD_INT 115
99390: PUSH
99391: LD_INT 116
99393: PUSH
99394: LD_INT 117
99396: PUSH
99397: LD_INT 118
99399: PUSH
99400: EMPTY
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: PUSH
99414: EMPTY
99415: LIST
99416: LIST
99417: ST_TO_ADDR
99418: GO 99661
99420: LD_INT 19
99422: DOUBLE
99423: EQUAL
99424: IFTRUE 99428
99426: GO 99660
99428: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99429: LD_ADDR_VAR 0 2
99433: PUSH
99434: LD_INT 1
99436: PUSH
99437: LD_INT 2
99439: PUSH
99440: LD_INT 3
99442: PUSH
99443: LD_INT 4
99445: PUSH
99446: LD_INT 5
99448: PUSH
99449: LD_INT 6
99451: PUSH
99452: LD_INT 7
99454: PUSH
99455: LD_INT 8
99457: PUSH
99458: LD_INT 9
99460: PUSH
99461: LD_INT 10
99463: PUSH
99464: LD_INT 11
99466: PUSH
99467: LD_INT 12
99469: PUSH
99470: LD_INT 13
99472: PUSH
99473: LD_INT 14
99475: PUSH
99476: LD_INT 15
99478: PUSH
99479: LD_INT 16
99481: PUSH
99482: LD_INT 17
99484: PUSH
99485: LD_INT 18
99487: PUSH
99488: LD_INT 19
99490: PUSH
99491: LD_INT 20
99493: PUSH
99494: LD_INT 21
99496: PUSH
99497: LD_INT 22
99499: PUSH
99500: LD_INT 23
99502: PUSH
99503: LD_INT 24
99505: PUSH
99506: LD_INT 25
99508: PUSH
99509: LD_INT 26
99511: PUSH
99512: LD_INT 27
99514: PUSH
99515: LD_INT 28
99517: PUSH
99518: LD_INT 29
99520: PUSH
99521: LD_INT 30
99523: PUSH
99524: LD_INT 31
99526: PUSH
99527: LD_INT 32
99529: PUSH
99530: LD_INT 33
99532: PUSH
99533: LD_INT 34
99535: PUSH
99536: LD_INT 35
99538: PUSH
99539: LD_INT 36
99541: PUSH
99542: EMPTY
99543: LIST
99544: LIST
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: LIST
99563: LIST
99564: LIST
99565: LIST
99566: LIST
99567: LIST
99568: LIST
99569: LIST
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: PUSH
99580: LD_INT 101
99582: PUSH
99583: LD_INT 102
99585: PUSH
99586: LD_INT 103
99588: PUSH
99589: LD_INT 104
99591: PUSH
99592: LD_INT 105
99594: PUSH
99595: LD_INT 106
99597: PUSH
99598: LD_INT 107
99600: PUSH
99601: LD_INT 108
99603: PUSH
99604: LD_INT 109
99606: PUSH
99607: LD_INT 110
99609: PUSH
99610: LD_INT 111
99612: PUSH
99613: LD_INT 112
99615: PUSH
99616: LD_INT 113
99618: PUSH
99619: LD_INT 114
99621: PUSH
99622: LD_INT 115
99624: PUSH
99625: LD_INT 116
99627: PUSH
99628: LD_INT 117
99630: PUSH
99631: LD_INT 118
99633: PUSH
99634: EMPTY
99635: LIST
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: PUSH
99654: EMPTY
99655: LIST
99656: LIST
99657: ST_TO_ADDR
99658: GO 99661
99660: POP
// end else
99661: GO 99892
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99663: LD_ADDR_VAR 0 2
99667: PUSH
99668: LD_INT 1
99670: PUSH
99671: LD_INT 2
99673: PUSH
99674: LD_INT 3
99676: PUSH
99677: LD_INT 4
99679: PUSH
99680: LD_INT 5
99682: PUSH
99683: LD_INT 6
99685: PUSH
99686: LD_INT 7
99688: PUSH
99689: LD_INT 8
99691: PUSH
99692: LD_INT 9
99694: PUSH
99695: LD_INT 10
99697: PUSH
99698: LD_INT 11
99700: PUSH
99701: LD_INT 12
99703: PUSH
99704: LD_INT 13
99706: PUSH
99707: LD_INT 14
99709: PUSH
99710: LD_INT 15
99712: PUSH
99713: LD_INT 16
99715: PUSH
99716: LD_INT 17
99718: PUSH
99719: LD_INT 18
99721: PUSH
99722: LD_INT 19
99724: PUSH
99725: LD_INT 20
99727: PUSH
99728: LD_INT 21
99730: PUSH
99731: LD_INT 22
99733: PUSH
99734: LD_INT 23
99736: PUSH
99737: LD_INT 24
99739: PUSH
99740: LD_INT 25
99742: PUSH
99743: LD_INT 26
99745: PUSH
99746: LD_INT 27
99748: PUSH
99749: LD_INT 28
99751: PUSH
99752: LD_INT 29
99754: PUSH
99755: LD_INT 30
99757: PUSH
99758: LD_INT 31
99760: PUSH
99761: LD_INT 32
99763: PUSH
99764: LD_INT 33
99766: PUSH
99767: LD_INT 34
99769: PUSH
99770: LD_INT 35
99772: PUSH
99773: LD_INT 36
99775: PUSH
99776: EMPTY
99777: LIST
99778: LIST
99779: LIST
99780: LIST
99781: LIST
99782: LIST
99783: LIST
99784: LIST
99785: LIST
99786: LIST
99787: LIST
99788: LIST
99789: LIST
99790: LIST
99791: LIST
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: LIST
99797: LIST
99798: LIST
99799: LIST
99800: LIST
99801: LIST
99802: LIST
99803: LIST
99804: LIST
99805: LIST
99806: LIST
99807: LIST
99808: LIST
99809: LIST
99810: LIST
99811: LIST
99812: LIST
99813: PUSH
99814: LD_INT 101
99816: PUSH
99817: LD_INT 102
99819: PUSH
99820: LD_INT 103
99822: PUSH
99823: LD_INT 104
99825: PUSH
99826: LD_INT 105
99828: PUSH
99829: LD_INT 106
99831: PUSH
99832: LD_INT 107
99834: PUSH
99835: LD_INT 108
99837: PUSH
99838: LD_INT 109
99840: PUSH
99841: LD_INT 110
99843: PUSH
99844: LD_INT 111
99846: PUSH
99847: LD_INT 112
99849: PUSH
99850: LD_INT 113
99852: PUSH
99853: LD_INT 114
99855: PUSH
99856: LD_INT 115
99858: PUSH
99859: LD_INT 116
99861: PUSH
99862: LD_INT 117
99864: PUSH
99865: LD_INT 118
99867: PUSH
99868: EMPTY
99869: LIST
99870: LIST
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: LIST
99883: LIST
99884: LIST
99885: LIST
99886: LIST
99887: PUSH
99888: EMPTY
99889: LIST
99890: LIST
99891: ST_TO_ADDR
// if result then
99892: LD_VAR 0 2
99896: IFFALSE 100682
// begin normal :=  ;
99898: LD_ADDR_VAR 0 5
99902: PUSH
99903: LD_STRING 
99905: ST_TO_ADDR
// hardcore :=  ;
99906: LD_ADDR_VAR 0 6
99910: PUSH
99911: LD_STRING 
99913: ST_TO_ADDR
// active :=  ;
99914: LD_ADDR_VAR 0 7
99918: PUSH
99919: LD_STRING 
99921: ST_TO_ADDR
// for i = 1 to normalCounter do
99922: LD_ADDR_VAR 0 8
99926: PUSH
99927: DOUBLE
99928: LD_INT 1
99930: DEC
99931: ST_TO_ADDR
99932: LD_EXP 100
99936: PUSH
99937: FOR_TO
99938: IFFALSE 100039
// begin tmp := 0 ;
99940: LD_ADDR_VAR 0 3
99944: PUSH
99945: LD_STRING 0
99947: ST_TO_ADDR
// if result [ 1 ] then
99948: LD_VAR 0 2
99952: PUSH
99953: LD_INT 1
99955: ARRAY
99956: IFFALSE 100021
// if result [ 1 ] [ 1 ] = i then
99958: LD_VAR 0 2
99962: PUSH
99963: LD_INT 1
99965: ARRAY
99966: PUSH
99967: LD_INT 1
99969: ARRAY
99970: PUSH
99971: LD_VAR 0 8
99975: EQUAL
99976: IFFALSE 100021
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99978: LD_ADDR_VAR 0 2
99982: PUSH
99983: LD_VAR 0 2
99987: PPUSH
99988: LD_INT 1
99990: PPUSH
99991: LD_VAR 0 2
99995: PUSH
99996: LD_INT 1
99998: ARRAY
99999: PPUSH
100000: LD_INT 1
100002: PPUSH
100003: CALL_OW 3
100007: PPUSH
100008: CALL_OW 1
100012: ST_TO_ADDR
// tmp := 1 ;
100013: LD_ADDR_VAR 0 3
100017: PUSH
100018: LD_STRING 1
100020: ST_TO_ADDR
// end ; normal := normal & tmp ;
100021: LD_ADDR_VAR 0 5
100025: PUSH
100026: LD_VAR 0 5
100030: PUSH
100031: LD_VAR 0 3
100035: STR
100036: ST_TO_ADDR
// end ;
100037: GO 99937
100039: POP
100040: POP
// for i = 1 to hardcoreCounter do
100041: LD_ADDR_VAR 0 8
100045: PUSH
100046: DOUBLE
100047: LD_INT 1
100049: DEC
100050: ST_TO_ADDR
100051: LD_EXP 101
100055: PUSH
100056: FOR_TO
100057: IFFALSE 100162
// begin tmp := 0 ;
100059: LD_ADDR_VAR 0 3
100063: PUSH
100064: LD_STRING 0
100066: ST_TO_ADDR
// if result [ 2 ] then
100067: LD_VAR 0 2
100071: PUSH
100072: LD_INT 2
100074: ARRAY
100075: IFFALSE 100144
// if result [ 2 ] [ 1 ] = 100 + i then
100077: LD_VAR 0 2
100081: PUSH
100082: LD_INT 2
100084: ARRAY
100085: PUSH
100086: LD_INT 1
100088: ARRAY
100089: PUSH
100090: LD_INT 100
100092: PUSH
100093: LD_VAR 0 8
100097: PLUS
100098: EQUAL
100099: IFFALSE 100144
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100101: LD_ADDR_VAR 0 2
100105: PUSH
100106: LD_VAR 0 2
100110: PPUSH
100111: LD_INT 2
100113: PPUSH
100114: LD_VAR 0 2
100118: PUSH
100119: LD_INT 2
100121: ARRAY
100122: PPUSH
100123: LD_INT 1
100125: PPUSH
100126: CALL_OW 3
100130: PPUSH
100131: CALL_OW 1
100135: ST_TO_ADDR
// tmp := 1 ;
100136: LD_ADDR_VAR 0 3
100140: PUSH
100141: LD_STRING 1
100143: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100144: LD_ADDR_VAR 0 6
100148: PUSH
100149: LD_VAR 0 6
100153: PUSH
100154: LD_VAR 0 3
100158: STR
100159: ST_TO_ADDR
// end ;
100160: GO 100056
100162: POP
100163: POP
// if isGameLoad then
100164: LD_VAR 0 1
100168: IFFALSE 100643
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100170: LD_ADDR_VAR 0 4
100174: PUSH
100175: LD_EXP 104
100179: PUSH
100180: LD_EXP 103
100184: PUSH
100185: LD_EXP 105
100189: PUSH
100190: LD_EXP 102
100194: PUSH
100195: LD_EXP 106
100199: PUSH
100200: LD_EXP 107
100204: PUSH
100205: LD_EXP 108
100209: PUSH
100210: LD_EXP 109
100214: PUSH
100215: LD_EXP 110
100219: PUSH
100220: LD_EXP 111
100224: PUSH
100225: LD_EXP 112
100229: PUSH
100230: LD_EXP 113
100234: PUSH
100235: LD_EXP 114
100239: PUSH
100240: LD_EXP 115
100244: PUSH
100245: LD_EXP 123
100249: PUSH
100250: LD_EXP 124
100254: PUSH
100255: LD_EXP 125
100259: PUSH
100260: LD_EXP 126
100264: PUSH
100265: LD_EXP 128
100269: PUSH
100270: LD_EXP 129
100274: PUSH
100275: LD_EXP 130
100279: PUSH
100280: LD_EXP 133
100284: PUSH
100285: LD_EXP 135
100289: PUSH
100290: LD_EXP 136
100294: PUSH
100295: LD_EXP 137
100299: PUSH
100300: LD_EXP 139
100304: PUSH
100305: LD_EXP 140
100309: PUSH
100310: LD_EXP 143
100314: PUSH
100315: LD_EXP 144
100319: PUSH
100320: LD_EXP 145
100324: PUSH
100325: LD_EXP 146
100329: PUSH
100330: LD_EXP 147
100334: PUSH
100335: LD_EXP 148
100339: PUSH
100340: LD_EXP 149
100344: PUSH
100345: LD_EXP 150
100349: PUSH
100350: LD_EXP 151
100354: PUSH
100355: LD_EXP 116
100359: PUSH
100360: LD_EXP 117
100364: PUSH
100365: LD_EXP 120
100369: PUSH
100370: LD_EXP 121
100374: PUSH
100375: LD_EXP 122
100379: PUSH
100380: LD_EXP 118
100384: PUSH
100385: LD_EXP 119
100389: PUSH
100390: LD_EXP 127
100394: PUSH
100395: LD_EXP 131
100399: PUSH
100400: LD_EXP 132
100404: PUSH
100405: LD_EXP 134
100409: PUSH
100410: LD_EXP 138
100414: PUSH
100415: LD_EXP 141
100419: PUSH
100420: LD_EXP 142
100424: PUSH
100425: LD_EXP 152
100429: PUSH
100430: LD_EXP 153
100434: PUSH
100435: LD_EXP 154
100439: PUSH
100440: LD_EXP 155
100444: PUSH
100445: EMPTY
100446: LIST
100447: LIST
100448: LIST
100449: LIST
100450: LIST
100451: LIST
100452: LIST
100453: LIST
100454: LIST
100455: LIST
100456: LIST
100457: LIST
100458: LIST
100459: LIST
100460: LIST
100461: LIST
100462: LIST
100463: LIST
100464: LIST
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: LIST
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: LIST
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: ST_TO_ADDR
// tmp :=  ;
100501: LD_ADDR_VAR 0 3
100505: PUSH
100506: LD_STRING 
100508: ST_TO_ADDR
// for i = 1 to normalCounter do
100509: LD_ADDR_VAR 0 8
100513: PUSH
100514: DOUBLE
100515: LD_INT 1
100517: DEC
100518: ST_TO_ADDR
100519: LD_EXP 100
100523: PUSH
100524: FOR_TO
100525: IFFALSE 100561
// begin if flags [ i ] then
100527: LD_VAR 0 4
100531: PUSH
100532: LD_VAR 0 8
100536: ARRAY
100537: IFFALSE 100559
// tmp := tmp & i & ; ;
100539: LD_ADDR_VAR 0 3
100543: PUSH
100544: LD_VAR 0 3
100548: PUSH
100549: LD_VAR 0 8
100553: STR
100554: PUSH
100555: LD_STRING ;
100557: STR
100558: ST_TO_ADDR
// end ;
100559: GO 100524
100561: POP
100562: POP
// for i = 1 to hardcoreCounter do
100563: LD_ADDR_VAR 0 8
100567: PUSH
100568: DOUBLE
100569: LD_INT 1
100571: DEC
100572: ST_TO_ADDR
100573: LD_EXP 101
100577: PUSH
100578: FOR_TO
100579: IFFALSE 100625
// begin if flags [ normalCounter + i ] then
100581: LD_VAR 0 4
100585: PUSH
100586: LD_EXP 100
100590: PUSH
100591: LD_VAR 0 8
100595: PLUS
100596: ARRAY
100597: IFFALSE 100623
// tmp := tmp & ( 100 + i ) & ; ;
100599: LD_ADDR_VAR 0 3
100603: PUSH
100604: LD_VAR 0 3
100608: PUSH
100609: LD_INT 100
100611: PUSH
100612: LD_VAR 0 8
100616: PLUS
100617: STR
100618: PUSH
100619: LD_STRING ;
100621: STR
100622: ST_TO_ADDR
// end ;
100623: GO 100578
100625: POP
100626: POP
// if tmp then
100627: LD_VAR 0 3
100631: IFFALSE 100643
// active := tmp ;
100633: LD_ADDR_VAR 0 7
100637: PUSH
100638: LD_VAR 0 3
100642: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100643: LD_STRING getStreamItemsFromMission("
100645: PUSH
100646: LD_VAR 0 5
100650: STR
100651: PUSH
100652: LD_STRING ","
100654: STR
100655: PUSH
100656: LD_VAR 0 6
100660: STR
100661: PUSH
100662: LD_STRING ","
100664: STR
100665: PUSH
100666: LD_VAR 0 7
100670: STR
100671: PUSH
100672: LD_STRING ")
100674: STR
100675: PPUSH
100676: CALL_OW 559
// end else
100680: GO 100689
// ToLua ( getStreamItemsFromMission("","","") ) ;
100682: LD_STRING getStreamItemsFromMission("","","")
100684: PPUSH
100685: CALL_OW 559
// end ;
100689: LD_VAR 0 2
100693: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100694: LD_EXP 99
100698: PUSH
100699: LD_EXP 104
100703: AND
100704: IFFALSE 100828
100706: GO 100708
100708: DISABLE
100709: LD_INT 0
100711: PPUSH
100712: PPUSH
// begin enable ;
100713: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100714: LD_ADDR_VAR 0 2
100718: PUSH
100719: LD_INT 22
100721: PUSH
100722: LD_OWVAR 2
100726: PUSH
100727: EMPTY
100728: LIST
100729: LIST
100730: PUSH
100731: LD_INT 2
100733: PUSH
100734: LD_INT 34
100736: PUSH
100737: LD_INT 7
100739: PUSH
100740: EMPTY
100741: LIST
100742: LIST
100743: PUSH
100744: LD_INT 34
100746: PUSH
100747: LD_INT 45
100749: PUSH
100750: EMPTY
100751: LIST
100752: LIST
100753: PUSH
100754: LD_INT 34
100756: PUSH
100757: LD_INT 28
100759: PUSH
100760: EMPTY
100761: LIST
100762: LIST
100763: PUSH
100764: LD_INT 34
100766: PUSH
100767: LD_INT 47
100769: PUSH
100770: EMPTY
100771: LIST
100772: LIST
100773: PUSH
100774: EMPTY
100775: LIST
100776: LIST
100777: LIST
100778: LIST
100779: LIST
100780: PUSH
100781: EMPTY
100782: LIST
100783: LIST
100784: PPUSH
100785: CALL_OW 69
100789: ST_TO_ADDR
// if not tmp then
100790: LD_VAR 0 2
100794: NOT
100795: IFFALSE 100799
// exit ;
100797: GO 100828
// for i in tmp do
100799: LD_ADDR_VAR 0 1
100803: PUSH
100804: LD_VAR 0 2
100808: PUSH
100809: FOR_IN
100810: IFFALSE 100826
// begin SetLives ( i , 0 ) ;
100812: LD_VAR 0 1
100816: PPUSH
100817: LD_INT 0
100819: PPUSH
100820: CALL_OW 234
// end ;
100824: GO 100809
100826: POP
100827: POP
// end ;
100828: PPOPN 2
100830: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100831: LD_EXP 99
100835: PUSH
100836: LD_EXP 105
100840: AND
100841: IFFALSE 100925
100843: GO 100845
100845: DISABLE
100846: LD_INT 0
100848: PPUSH
100849: PPUSH
// begin enable ;
100850: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100851: LD_ADDR_VAR 0 2
100855: PUSH
100856: LD_INT 22
100858: PUSH
100859: LD_OWVAR 2
100863: PUSH
100864: EMPTY
100865: LIST
100866: LIST
100867: PUSH
100868: LD_INT 32
100870: PUSH
100871: LD_INT 3
100873: PUSH
100874: EMPTY
100875: LIST
100876: LIST
100877: PUSH
100878: EMPTY
100879: LIST
100880: LIST
100881: PPUSH
100882: CALL_OW 69
100886: ST_TO_ADDR
// if not tmp then
100887: LD_VAR 0 2
100891: NOT
100892: IFFALSE 100896
// exit ;
100894: GO 100925
// for i in tmp do
100896: LD_ADDR_VAR 0 1
100900: PUSH
100901: LD_VAR 0 2
100905: PUSH
100906: FOR_IN
100907: IFFALSE 100923
// begin SetLives ( i , 0 ) ;
100909: LD_VAR 0 1
100913: PPUSH
100914: LD_INT 0
100916: PPUSH
100917: CALL_OW 234
// end ;
100921: GO 100906
100923: POP
100924: POP
// end ;
100925: PPOPN 2
100927: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100928: LD_EXP 99
100932: PUSH
100933: LD_EXP 102
100937: AND
100938: IFFALSE 101031
100940: GO 100942
100942: DISABLE
100943: LD_INT 0
100945: PPUSH
// begin enable ;
100946: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100947: LD_ADDR_VAR 0 1
100951: PUSH
100952: LD_INT 22
100954: PUSH
100955: LD_OWVAR 2
100959: PUSH
100960: EMPTY
100961: LIST
100962: LIST
100963: PUSH
100964: LD_INT 2
100966: PUSH
100967: LD_INT 25
100969: PUSH
100970: LD_INT 5
100972: PUSH
100973: EMPTY
100974: LIST
100975: LIST
100976: PUSH
100977: LD_INT 25
100979: PUSH
100980: LD_INT 9
100982: PUSH
100983: EMPTY
100984: LIST
100985: LIST
100986: PUSH
100987: LD_INT 25
100989: PUSH
100990: LD_INT 8
100992: PUSH
100993: EMPTY
100994: LIST
100995: LIST
100996: PUSH
100997: EMPTY
100998: LIST
100999: LIST
101000: LIST
101001: LIST
101002: PUSH
101003: EMPTY
101004: LIST
101005: LIST
101006: PPUSH
101007: CALL_OW 69
101011: PUSH
101012: FOR_IN
101013: IFFALSE 101029
// begin SetClass ( i , 1 ) ;
101015: LD_VAR 0 1
101019: PPUSH
101020: LD_INT 1
101022: PPUSH
101023: CALL_OW 336
// end ;
101027: GO 101012
101029: POP
101030: POP
// end ;
101031: PPOPN 1
101033: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101034: LD_EXP 99
101038: PUSH
101039: LD_EXP 103
101043: AND
101044: PUSH
101045: LD_OWVAR 65
101049: PUSH
101050: LD_INT 7
101052: LESS
101053: AND
101054: IFFALSE 101068
101056: GO 101058
101058: DISABLE
// begin enable ;
101059: ENABLE
// game_speed := 7 ;
101060: LD_ADDR_OWVAR 65
101064: PUSH
101065: LD_INT 7
101067: ST_TO_ADDR
// end ;
101068: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101069: LD_EXP 99
101073: PUSH
101074: LD_EXP 106
101078: AND
101079: IFFALSE 101281
101081: GO 101083
101083: DISABLE
101084: LD_INT 0
101086: PPUSH
101087: PPUSH
101088: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101089: LD_ADDR_VAR 0 3
101093: PUSH
101094: LD_INT 81
101096: PUSH
101097: LD_OWVAR 2
101101: PUSH
101102: EMPTY
101103: LIST
101104: LIST
101105: PUSH
101106: LD_INT 21
101108: PUSH
101109: LD_INT 1
101111: PUSH
101112: EMPTY
101113: LIST
101114: LIST
101115: PUSH
101116: EMPTY
101117: LIST
101118: LIST
101119: PPUSH
101120: CALL_OW 69
101124: ST_TO_ADDR
// if not tmp then
101125: LD_VAR 0 3
101129: NOT
101130: IFFALSE 101134
// exit ;
101132: GO 101281
// if tmp > 5 then
101134: LD_VAR 0 3
101138: PUSH
101139: LD_INT 5
101141: GREATER
101142: IFFALSE 101154
// k := 5 else
101144: LD_ADDR_VAR 0 2
101148: PUSH
101149: LD_INT 5
101151: ST_TO_ADDR
101152: GO 101164
// k := tmp ;
101154: LD_ADDR_VAR 0 2
101158: PUSH
101159: LD_VAR 0 3
101163: ST_TO_ADDR
// for i := 1 to k do
101164: LD_ADDR_VAR 0 1
101168: PUSH
101169: DOUBLE
101170: LD_INT 1
101172: DEC
101173: ST_TO_ADDR
101174: LD_VAR 0 2
101178: PUSH
101179: FOR_TO
101180: IFFALSE 101279
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101182: LD_VAR 0 3
101186: PUSH
101187: LD_VAR 0 1
101191: ARRAY
101192: PPUSH
101193: LD_VAR 0 1
101197: PUSH
101198: LD_INT 4
101200: MOD
101201: PUSH
101202: LD_INT 1
101204: PLUS
101205: PPUSH
101206: CALL_OW 259
101210: PUSH
101211: LD_INT 10
101213: LESS
101214: IFFALSE 101277
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101216: LD_VAR 0 3
101220: PUSH
101221: LD_VAR 0 1
101225: ARRAY
101226: PPUSH
101227: LD_VAR 0 1
101231: PUSH
101232: LD_INT 4
101234: MOD
101235: PUSH
101236: LD_INT 1
101238: PLUS
101239: PPUSH
101240: LD_VAR 0 3
101244: PUSH
101245: LD_VAR 0 1
101249: ARRAY
101250: PPUSH
101251: LD_VAR 0 1
101255: PUSH
101256: LD_INT 4
101258: MOD
101259: PUSH
101260: LD_INT 1
101262: PLUS
101263: PPUSH
101264: CALL_OW 259
101268: PUSH
101269: LD_INT 1
101271: PLUS
101272: PPUSH
101273: CALL_OW 237
101277: GO 101179
101279: POP
101280: POP
// end ;
101281: PPOPN 3
101283: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101284: LD_EXP 99
101288: PUSH
101289: LD_EXP 107
101293: AND
101294: IFFALSE 101314
101296: GO 101298
101298: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101299: LD_INT 4
101301: PPUSH
101302: LD_OWVAR 2
101306: PPUSH
101307: LD_INT 0
101309: PPUSH
101310: CALL_OW 324
101314: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101315: LD_EXP 99
101319: PUSH
101320: LD_EXP 136
101324: AND
101325: IFFALSE 101345
101327: GO 101329
101329: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101330: LD_INT 19
101332: PPUSH
101333: LD_OWVAR 2
101337: PPUSH
101338: LD_INT 0
101340: PPUSH
101341: CALL_OW 324
101345: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101346: LD_EXP 99
101350: PUSH
101351: LD_EXP 108
101355: AND
101356: IFFALSE 101458
101358: GO 101360
101360: DISABLE
101361: LD_INT 0
101363: PPUSH
101364: PPUSH
// begin enable ;
101365: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101366: LD_ADDR_VAR 0 2
101370: PUSH
101371: LD_INT 22
101373: PUSH
101374: LD_OWVAR 2
101378: PUSH
101379: EMPTY
101380: LIST
101381: LIST
101382: PUSH
101383: LD_INT 2
101385: PUSH
101386: LD_INT 34
101388: PUSH
101389: LD_INT 11
101391: PUSH
101392: EMPTY
101393: LIST
101394: LIST
101395: PUSH
101396: LD_INT 34
101398: PUSH
101399: LD_INT 30
101401: PUSH
101402: EMPTY
101403: LIST
101404: LIST
101405: PUSH
101406: EMPTY
101407: LIST
101408: LIST
101409: LIST
101410: PUSH
101411: EMPTY
101412: LIST
101413: LIST
101414: PPUSH
101415: CALL_OW 69
101419: ST_TO_ADDR
// if not tmp then
101420: LD_VAR 0 2
101424: NOT
101425: IFFALSE 101429
// exit ;
101427: GO 101458
// for i in tmp do
101429: LD_ADDR_VAR 0 1
101433: PUSH
101434: LD_VAR 0 2
101438: PUSH
101439: FOR_IN
101440: IFFALSE 101456
// begin SetLives ( i , 0 ) ;
101442: LD_VAR 0 1
101446: PPUSH
101447: LD_INT 0
101449: PPUSH
101450: CALL_OW 234
// end ;
101454: GO 101439
101456: POP
101457: POP
// end ;
101458: PPOPN 2
101460: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101461: LD_EXP 99
101465: PUSH
101466: LD_EXP 109
101470: AND
101471: IFFALSE 101491
101473: GO 101475
101475: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101476: LD_INT 32
101478: PPUSH
101479: LD_OWVAR 2
101483: PPUSH
101484: LD_INT 0
101486: PPUSH
101487: CALL_OW 324
101491: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101492: LD_EXP 99
101496: PUSH
101497: LD_EXP 110
101501: AND
101502: IFFALSE 101683
101504: GO 101506
101506: DISABLE
101507: LD_INT 0
101509: PPUSH
101510: PPUSH
101511: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101512: LD_ADDR_VAR 0 2
101516: PUSH
101517: LD_INT 22
101519: PUSH
101520: LD_OWVAR 2
101524: PUSH
101525: EMPTY
101526: LIST
101527: LIST
101528: PUSH
101529: LD_INT 33
101531: PUSH
101532: LD_INT 3
101534: PUSH
101535: EMPTY
101536: LIST
101537: LIST
101538: PUSH
101539: EMPTY
101540: LIST
101541: LIST
101542: PPUSH
101543: CALL_OW 69
101547: ST_TO_ADDR
// if not tmp then
101548: LD_VAR 0 2
101552: NOT
101553: IFFALSE 101557
// exit ;
101555: GO 101683
// side := 0 ;
101557: LD_ADDR_VAR 0 3
101561: PUSH
101562: LD_INT 0
101564: ST_TO_ADDR
// for i := 1 to 8 do
101565: LD_ADDR_VAR 0 1
101569: PUSH
101570: DOUBLE
101571: LD_INT 1
101573: DEC
101574: ST_TO_ADDR
101575: LD_INT 8
101577: PUSH
101578: FOR_TO
101579: IFFALSE 101627
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101581: LD_OWVAR 2
101585: PUSH
101586: LD_VAR 0 1
101590: NONEQUAL
101591: PUSH
101592: LD_OWVAR 2
101596: PPUSH
101597: LD_VAR 0 1
101601: PPUSH
101602: CALL_OW 81
101606: PUSH
101607: LD_INT 2
101609: EQUAL
101610: AND
101611: IFFALSE 101625
// begin side := i ;
101613: LD_ADDR_VAR 0 3
101617: PUSH
101618: LD_VAR 0 1
101622: ST_TO_ADDR
// break ;
101623: GO 101627
// end ;
101625: GO 101578
101627: POP
101628: POP
// if not side then
101629: LD_VAR 0 3
101633: NOT
101634: IFFALSE 101638
// exit ;
101636: GO 101683
// for i := 1 to tmp do
101638: LD_ADDR_VAR 0 1
101642: PUSH
101643: DOUBLE
101644: LD_INT 1
101646: DEC
101647: ST_TO_ADDR
101648: LD_VAR 0 2
101652: PUSH
101653: FOR_TO
101654: IFFALSE 101681
// if Prob ( 60 ) then
101656: LD_INT 60
101658: PPUSH
101659: CALL_OW 13
101663: IFFALSE 101679
// SetSide ( i , side ) ;
101665: LD_VAR 0 1
101669: PPUSH
101670: LD_VAR 0 3
101674: PPUSH
101675: CALL_OW 235
101679: GO 101653
101681: POP
101682: POP
// end ;
101683: PPOPN 3
101685: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101686: LD_EXP 99
101690: PUSH
101691: LD_EXP 112
101695: AND
101696: IFFALSE 101815
101698: GO 101700
101700: DISABLE
101701: LD_INT 0
101703: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101704: LD_ADDR_VAR 0 1
101708: PUSH
101709: LD_INT 22
101711: PUSH
101712: LD_OWVAR 2
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: PUSH
101721: LD_INT 21
101723: PUSH
101724: LD_INT 1
101726: PUSH
101727: EMPTY
101728: LIST
101729: LIST
101730: PUSH
101731: LD_INT 3
101733: PUSH
101734: LD_INT 23
101736: PUSH
101737: LD_INT 0
101739: PUSH
101740: EMPTY
101741: LIST
101742: LIST
101743: PUSH
101744: EMPTY
101745: LIST
101746: LIST
101747: PUSH
101748: EMPTY
101749: LIST
101750: LIST
101751: LIST
101752: PPUSH
101753: CALL_OW 69
101757: PUSH
101758: FOR_IN
101759: IFFALSE 101813
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101761: LD_VAR 0 1
101765: PPUSH
101766: CALL_OW 257
101770: PUSH
101771: LD_INT 1
101773: PUSH
101774: LD_INT 2
101776: PUSH
101777: LD_INT 3
101779: PUSH
101780: LD_INT 4
101782: PUSH
101783: EMPTY
101784: LIST
101785: LIST
101786: LIST
101787: LIST
101788: IN
101789: IFFALSE 101811
// SetClass ( un , rand ( 1 , 4 ) ) ;
101791: LD_VAR 0 1
101795: PPUSH
101796: LD_INT 1
101798: PPUSH
101799: LD_INT 4
101801: PPUSH
101802: CALL_OW 12
101806: PPUSH
101807: CALL_OW 336
101811: GO 101758
101813: POP
101814: POP
// end ;
101815: PPOPN 1
101817: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101818: LD_EXP 99
101822: PUSH
101823: LD_EXP 111
101827: AND
101828: IFFALSE 101907
101830: GO 101832
101832: DISABLE
101833: LD_INT 0
101835: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101836: LD_ADDR_VAR 0 1
101840: PUSH
101841: LD_INT 22
101843: PUSH
101844: LD_OWVAR 2
101848: PUSH
101849: EMPTY
101850: LIST
101851: LIST
101852: PUSH
101853: LD_INT 21
101855: PUSH
101856: LD_INT 3
101858: PUSH
101859: EMPTY
101860: LIST
101861: LIST
101862: PUSH
101863: EMPTY
101864: LIST
101865: LIST
101866: PPUSH
101867: CALL_OW 69
101871: ST_TO_ADDR
// if not tmp then
101872: LD_VAR 0 1
101876: NOT
101877: IFFALSE 101881
// exit ;
101879: GO 101907
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101881: LD_VAR 0 1
101885: PUSH
101886: LD_INT 1
101888: PPUSH
101889: LD_VAR 0 1
101893: PPUSH
101894: CALL_OW 12
101898: ARRAY
101899: PPUSH
101900: LD_INT 100
101902: PPUSH
101903: CALL_OW 234
// end ;
101907: PPOPN 1
101909: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101910: LD_EXP 99
101914: PUSH
101915: LD_EXP 113
101919: AND
101920: IFFALSE 102018
101922: GO 101924
101924: DISABLE
101925: LD_INT 0
101927: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101928: LD_ADDR_VAR 0 1
101932: PUSH
101933: LD_INT 22
101935: PUSH
101936: LD_OWVAR 2
101940: PUSH
101941: EMPTY
101942: LIST
101943: LIST
101944: PUSH
101945: LD_INT 21
101947: PUSH
101948: LD_INT 1
101950: PUSH
101951: EMPTY
101952: LIST
101953: LIST
101954: PUSH
101955: EMPTY
101956: LIST
101957: LIST
101958: PPUSH
101959: CALL_OW 69
101963: ST_TO_ADDR
// if not tmp then
101964: LD_VAR 0 1
101968: NOT
101969: IFFALSE 101973
// exit ;
101971: GO 102018
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101973: LD_VAR 0 1
101977: PUSH
101978: LD_INT 1
101980: PPUSH
101981: LD_VAR 0 1
101985: PPUSH
101986: CALL_OW 12
101990: ARRAY
101991: PPUSH
101992: LD_INT 1
101994: PPUSH
101995: LD_INT 4
101997: PPUSH
101998: CALL_OW 12
102002: PPUSH
102003: LD_INT 3000
102005: PPUSH
102006: LD_INT 9000
102008: PPUSH
102009: CALL_OW 12
102013: PPUSH
102014: CALL_OW 492
// end ;
102018: PPOPN 1
102020: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102021: LD_EXP 99
102025: PUSH
102026: LD_EXP 114
102030: AND
102031: IFFALSE 102051
102033: GO 102035
102035: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102036: LD_INT 1
102038: PPUSH
102039: LD_OWVAR 2
102043: PPUSH
102044: LD_INT 0
102046: PPUSH
102047: CALL_OW 324
102051: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102052: LD_EXP 99
102056: PUSH
102057: LD_EXP 115
102061: AND
102062: IFFALSE 102145
102064: GO 102066
102066: DISABLE
102067: LD_INT 0
102069: PPUSH
102070: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102071: LD_ADDR_VAR 0 2
102075: PUSH
102076: LD_INT 22
102078: PUSH
102079: LD_OWVAR 2
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: PUSH
102088: LD_INT 21
102090: PUSH
102091: LD_INT 3
102093: PUSH
102094: EMPTY
102095: LIST
102096: LIST
102097: PUSH
102098: EMPTY
102099: LIST
102100: LIST
102101: PPUSH
102102: CALL_OW 69
102106: ST_TO_ADDR
// if not tmp then
102107: LD_VAR 0 2
102111: NOT
102112: IFFALSE 102116
// exit ;
102114: GO 102145
// for i in tmp do
102116: LD_ADDR_VAR 0 1
102120: PUSH
102121: LD_VAR 0 2
102125: PUSH
102126: FOR_IN
102127: IFFALSE 102143
// SetBLevel ( i , 10 ) ;
102129: LD_VAR 0 1
102133: PPUSH
102134: LD_INT 10
102136: PPUSH
102137: CALL_OW 241
102141: GO 102126
102143: POP
102144: POP
// end ;
102145: PPOPN 2
102147: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102148: LD_EXP 99
102152: PUSH
102153: LD_EXP 116
102157: AND
102158: IFFALSE 102269
102160: GO 102162
102162: DISABLE
102163: LD_INT 0
102165: PPUSH
102166: PPUSH
102167: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102168: LD_ADDR_VAR 0 3
102172: PUSH
102173: LD_INT 22
102175: PUSH
102176: LD_OWVAR 2
102180: PUSH
102181: EMPTY
102182: LIST
102183: LIST
102184: PUSH
102185: LD_INT 25
102187: PUSH
102188: LD_INT 1
102190: PUSH
102191: EMPTY
102192: LIST
102193: LIST
102194: PUSH
102195: EMPTY
102196: LIST
102197: LIST
102198: PPUSH
102199: CALL_OW 69
102203: ST_TO_ADDR
// if not tmp then
102204: LD_VAR 0 3
102208: NOT
102209: IFFALSE 102213
// exit ;
102211: GO 102269
// un := tmp [ rand ( 1 , tmp ) ] ;
102213: LD_ADDR_VAR 0 2
102217: PUSH
102218: LD_VAR 0 3
102222: PUSH
102223: LD_INT 1
102225: PPUSH
102226: LD_VAR 0 3
102230: PPUSH
102231: CALL_OW 12
102235: ARRAY
102236: ST_TO_ADDR
// if Crawls ( un ) then
102237: LD_VAR 0 2
102241: PPUSH
102242: CALL_OW 318
102246: IFFALSE 102257
// ComWalk ( un ) ;
102248: LD_VAR 0 2
102252: PPUSH
102253: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102257: LD_VAR 0 2
102261: PPUSH
102262: LD_INT 5
102264: PPUSH
102265: CALL_OW 336
// end ;
102269: PPOPN 3
102271: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102272: LD_EXP 99
102276: PUSH
102277: LD_EXP 117
102281: AND
102282: PUSH
102283: LD_OWVAR 67
102287: PUSH
102288: LD_INT 4
102290: LESS
102291: AND
102292: IFFALSE 102311
102294: GO 102296
102296: DISABLE
// begin Difficulty := Difficulty + 1 ;
102297: LD_ADDR_OWVAR 67
102301: PUSH
102302: LD_OWVAR 67
102306: PUSH
102307: LD_INT 1
102309: PLUS
102310: ST_TO_ADDR
// end ;
102311: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102312: LD_EXP 99
102316: PUSH
102317: LD_EXP 118
102321: AND
102322: IFFALSE 102425
102324: GO 102326
102326: DISABLE
102327: LD_INT 0
102329: PPUSH
// begin for i := 1 to 5 do
102330: LD_ADDR_VAR 0 1
102334: PUSH
102335: DOUBLE
102336: LD_INT 1
102338: DEC
102339: ST_TO_ADDR
102340: LD_INT 5
102342: PUSH
102343: FOR_TO
102344: IFFALSE 102423
// begin uc_nation := nation_nature ;
102346: LD_ADDR_OWVAR 21
102350: PUSH
102351: LD_INT 0
102353: ST_TO_ADDR
// uc_side := 0 ;
102354: LD_ADDR_OWVAR 20
102358: PUSH
102359: LD_INT 0
102361: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102362: LD_ADDR_OWVAR 29
102366: PUSH
102367: LD_INT 12
102369: PUSH
102370: LD_INT 12
102372: PUSH
102373: EMPTY
102374: LIST
102375: LIST
102376: ST_TO_ADDR
// hc_agressivity := 20 ;
102377: LD_ADDR_OWVAR 35
102381: PUSH
102382: LD_INT 20
102384: ST_TO_ADDR
// hc_class := class_tiger ;
102385: LD_ADDR_OWVAR 28
102389: PUSH
102390: LD_INT 14
102392: ST_TO_ADDR
// hc_gallery :=  ;
102393: LD_ADDR_OWVAR 33
102397: PUSH
102398: LD_STRING 
102400: ST_TO_ADDR
// hc_name :=  ;
102401: LD_ADDR_OWVAR 26
102405: PUSH
102406: LD_STRING 
102408: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102409: CALL_OW 44
102413: PPUSH
102414: LD_INT 0
102416: PPUSH
102417: CALL_OW 51
// end ;
102421: GO 102343
102423: POP
102424: POP
// end ;
102425: PPOPN 1
102427: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102428: LD_EXP 99
102432: PUSH
102433: LD_EXP 119
102437: AND
102438: IFFALSE 102447
102440: GO 102442
102442: DISABLE
// StreamSibBomb ;
102443: CALL 102448 0 0
102447: END
// export function StreamSibBomb ; var i , x , y ; begin
102448: LD_INT 0
102450: PPUSH
102451: PPUSH
102452: PPUSH
102453: PPUSH
// result := false ;
102454: LD_ADDR_VAR 0 1
102458: PUSH
102459: LD_INT 0
102461: ST_TO_ADDR
// for i := 1 to 16 do
102462: LD_ADDR_VAR 0 2
102466: PUSH
102467: DOUBLE
102468: LD_INT 1
102470: DEC
102471: ST_TO_ADDR
102472: LD_INT 16
102474: PUSH
102475: FOR_TO
102476: IFFALSE 102675
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102478: LD_ADDR_VAR 0 3
102482: PUSH
102483: LD_INT 10
102485: PUSH
102486: LD_INT 20
102488: PUSH
102489: LD_INT 30
102491: PUSH
102492: LD_INT 40
102494: PUSH
102495: LD_INT 50
102497: PUSH
102498: LD_INT 60
102500: PUSH
102501: LD_INT 70
102503: PUSH
102504: LD_INT 80
102506: PUSH
102507: LD_INT 90
102509: PUSH
102510: LD_INT 100
102512: PUSH
102513: LD_INT 110
102515: PUSH
102516: LD_INT 120
102518: PUSH
102519: LD_INT 130
102521: PUSH
102522: LD_INT 140
102524: PUSH
102525: LD_INT 150
102527: PUSH
102528: EMPTY
102529: LIST
102530: LIST
102531: LIST
102532: LIST
102533: LIST
102534: LIST
102535: LIST
102536: LIST
102537: LIST
102538: LIST
102539: LIST
102540: LIST
102541: LIST
102542: LIST
102543: LIST
102544: PUSH
102545: LD_INT 1
102547: PPUSH
102548: LD_INT 15
102550: PPUSH
102551: CALL_OW 12
102555: ARRAY
102556: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102557: LD_ADDR_VAR 0 4
102561: PUSH
102562: LD_INT 10
102564: PUSH
102565: LD_INT 20
102567: PUSH
102568: LD_INT 30
102570: PUSH
102571: LD_INT 40
102573: PUSH
102574: LD_INT 50
102576: PUSH
102577: LD_INT 60
102579: PUSH
102580: LD_INT 70
102582: PUSH
102583: LD_INT 80
102585: PUSH
102586: LD_INT 90
102588: PUSH
102589: LD_INT 100
102591: PUSH
102592: LD_INT 110
102594: PUSH
102595: LD_INT 120
102597: PUSH
102598: LD_INT 130
102600: PUSH
102601: LD_INT 140
102603: PUSH
102604: LD_INT 150
102606: PUSH
102607: EMPTY
102608: LIST
102609: LIST
102610: LIST
102611: LIST
102612: LIST
102613: LIST
102614: LIST
102615: LIST
102616: LIST
102617: LIST
102618: LIST
102619: LIST
102620: LIST
102621: LIST
102622: LIST
102623: PUSH
102624: LD_INT 1
102626: PPUSH
102627: LD_INT 15
102629: PPUSH
102630: CALL_OW 12
102634: ARRAY
102635: ST_TO_ADDR
// if ValidHex ( x , y ) then
102636: LD_VAR 0 3
102640: PPUSH
102641: LD_VAR 0 4
102645: PPUSH
102646: CALL_OW 488
102650: IFFALSE 102673
// begin result := [ x , y ] ;
102652: LD_ADDR_VAR 0 1
102656: PUSH
102657: LD_VAR 0 3
102661: PUSH
102662: LD_VAR 0 4
102666: PUSH
102667: EMPTY
102668: LIST
102669: LIST
102670: ST_TO_ADDR
// break ;
102671: GO 102675
// end ; end ;
102673: GO 102475
102675: POP
102676: POP
// if result then
102677: LD_VAR 0 1
102681: IFFALSE 102741
// begin ToLua ( playSibBomb() ) ;
102683: LD_STRING playSibBomb()
102685: PPUSH
102686: CALL_OW 559
// wait ( 0 0$14 ) ;
102690: LD_INT 490
102692: PPUSH
102693: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102697: LD_VAR 0 1
102701: PUSH
102702: LD_INT 1
102704: ARRAY
102705: PPUSH
102706: LD_VAR 0 1
102710: PUSH
102711: LD_INT 2
102713: ARRAY
102714: PPUSH
102715: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102719: LD_VAR 0 1
102723: PUSH
102724: LD_INT 1
102726: ARRAY
102727: PPUSH
102728: LD_VAR 0 1
102732: PUSH
102733: LD_INT 2
102735: ARRAY
102736: PPUSH
102737: CALL_OW 429
// end ; end ;
102741: LD_VAR 0 1
102745: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102746: LD_EXP 99
102750: PUSH
102751: LD_EXP 121
102755: AND
102756: IFFALSE 102768
102758: GO 102760
102760: DISABLE
// YouLost (  ) ;
102761: LD_STRING 
102763: PPUSH
102764: CALL_OW 104
102768: END
// every 0 0$1 trigger StreamModeActive and sFog do
102769: LD_EXP 99
102773: PUSH
102774: LD_EXP 120
102778: AND
102779: IFFALSE 102793
102781: GO 102783
102783: DISABLE
// FogOff ( your_side ) ;
102784: LD_OWVAR 2
102788: PPUSH
102789: CALL_OW 344
102793: END
// every 0 0$1 trigger StreamModeActive and sSun do
102794: LD_EXP 99
102798: PUSH
102799: LD_EXP 122
102803: AND
102804: IFFALSE 102832
102806: GO 102808
102808: DISABLE
// begin solar_recharge_percent := 0 ;
102809: LD_ADDR_OWVAR 79
102813: PUSH
102814: LD_INT 0
102816: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102817: LD_INT 10500
102819: PPUSH
102820: CALL_OW 67
// solar_recharge_percent := 100 ;
102824: LD_ADDR_OWVAR 79
102828: PUSH
102829: LD_INT 100
102831: ST_TO_ADDR
// end ;
102832: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102833: LD_EXP 99
102837: PUSH
102838: LD_EXP 123
102842: AND
102843: IFFALSE 103082
102845: GO 102847
102847: DISABLE
102848: LD_INT 0
102850: PPUSH
102851: PPUSH
102852: PPUSH
// begin tmp := [ ] ;
102853: LD_ADDR_VAR 0 3
102857: PUSH
102858: EMPTY
102859: ST_TO_ADDR
// for i := 1 to 6 do
102860: LD_ADDR_VAR 0 1
102864: PUSH
102865: DOUBLE
102866: LD_INT 1
102868: DEC
102869: ST_TO_ADDR
102870: LD_INT 6
102872: PUSH
102873: FOR_TO
102874: IFFALSE 102979
// begin uc_nation := nation_nature ;
102876: LD_ADDR_OWVAR 21
102880: PUSH
102881: LD_INT 0
102883: ST_TO_ADDR
// uc_side := 0 ;
102884: LD_ADDR_OWVAR 20
102888: PUSH
102889: LD_INT 0
102891: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102892: LD_ADDR_OWVAR 29
102896: PUSH
102897: LD_INT 12
102899: PUSH
102900: LD_INT 12
102902: PUSH
102903: EMPTY
102904: LIST
102905: LIST
102906: ST_TO_ADDR
// hc_agressivity := 20 ;
102907: LD_ADDR_OWVAR 35
102911: PUSH
102912: LD_INT 20
102914: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102915: LD_ADDR_OWVAR 28
102919: PUSH
102920: LD_INT 17
102922: ST_TO_ADDR
// hc_gallery :=  ;
102923: LD_ADDR_OWVAR 33
102927: PUSH
102928: LD_STRING 
102930: ST_TO_ADDR
// hc_name :=  ;
102931: LD_ADDR_OWVAR 26
102935: PUSH
102936: LD_STRING 
102938: ST_TO_ADDR
// un := CreateHuman ;
102939: LD_ADDR_VAR 0 2
102943: PUSH
102944: CALL_OW 44
102948: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102949: LD_VAR 0 2
102953: PPUSH
102954: LD_INT 1
102956: PPUSH
102957: CALL_OW 51
// tmp := tmp ^ un ;
102961: LD_ADDR_VAR 0 3
102965: PUSH
102966: LD_VAR 0 3
102970: PUSH
102971: LD_VAR 0 2
102975: ADD
102976: ST_TO_ADDR
// end ;
102977: GO 102873
102979: POP
102980: POP
// repeat wait ( 0 0$1 ) ;
102981: LD_INT 35
102983: PPUSH
102984: CALL_OW 67
// for un in tmp do
102988: LD_ADDR_VAR 0 2
102992: PUSH
102993: LD_VAR 0 3
102997: PUSH
102998: FOR_IN
102999: IFFALSE 103073
// begin if IsDead ( un ) then
103001: LD_VAR 0 2
103005: PPUSH
103006: CALL_OW 301
103010: IFFALSE 103030
// begin tmp := tmp diff un ;
103012: LD_ADDR_VAR 0 3
103016: PUSH
103017: LD_VAR 0 3
103021: PUSH
103022: LD_VAR 0 2
103026: DIFF
103027: ST_TO_ADDR
// continue ;
103028: GO 102998
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103030: LD_VAR 0 2
103034: PPUSH
103035: LD_INT 3
103037: PUSH
103038: LD_INT 22
103040: PUSH
103041: LD_INT 0
103043: PUSH
103044: EMPTY
103045: LIST
103046: LIST
103047: PUSH
103048: EMPTY
103049: LIST
103050: LIST
103051: PPUSH
103052: CALL_OW 69
103056: PPUSH
103057: LD_VAR 0 2
103061: PPUSH
103062: CALL_OW 74
103066: PPUSH
103067: CALL_OW 115
// end ;
103071: GO 102998
103073: POP
103074: POP
// until not tmp ;
103075: LD_VAR 0 3
103079: NOT
103080: IFFALSE 102981
// end ;
103082: PPOPN 3
103084: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103085: LD_EXP 99
103089: PUSH
103090: LD_EXP 124
103094: AND
103095: IFFALSE 103149
103097: GO 103099
103099: DISABLE
// begin ToLua ( displayTroll(); ) ;
103100: LD_STRING displayTroll();
103102: PPUSH
103103: CALL_OW 559
// wait ( 3 3$00 ) ;
103107: LD_INT 6300
103109: PPUSH
103110: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103114: LD_STRING hideTroll();
103116: PPUSH
103117: CALL_OW 559
// wait ( 1 1$00 ) ;
103121: LD_INT 2100
103123: PPUSH
103124: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103128: LD_STRING displayTroll();
103130: PPUSH
103131: CALL_OW 559
// wait ( 1 1$00 ) ;
103135: LD_INT 2100
103137: PPUSH
103138: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103142: LD_STRING hideTroll();
103144: PPUSH
103145: CALL_OW 559
// end ;
103149: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103150: LD_EXP 99
103154: PUSH
103155: LD_EXP 125
103159: AND
103160: IFFALSE 103223
103162: GO 103164
103164: DISABLE
103165: LD_INT 0
103167: PPUSH
// begin p := 0 ;
103168: LD_ADDR_VAR 0 1
103172: PUSH
103173: LD_INT 0
103175: ST_TO_ADDR
// repeat game_speed := 1 ;
103176: LD_ADDR_OWVAR 65
103180: PUSH
103181: LD_INT 1
103183: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103184: LD_INT 35
103186: PPUSH
103187: CALL_OW 67
// p := p + 1 ;
103191: LD_ADDR_VAR 0 1
103195: PUSH
103196: LD_VAR 0 1
103200: PUSH
103201: LD_INT 1
103203: PLUS
103204: ST_TO_ADDR
// until p >= 60 ;
103205: LD_VAR 0 1
103209: PUSH
103210: LD_INT 60
103212: GREATEREQUAL
103213: IFFALSE 103176
// game_speed := 4 ;
103215: LD_ADDR_OWVAR 65
103219: PUSH
103220: LD_INT 4
103222: ST_TO_ADDR
// end ;
103223: PPOPN 1
103225: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103226: LD_EXP 99
103230: PUSH
103231: LD_EXP 126
103235: AND
103236: IFFALSE 103382
103238: GO 103240
103240: DISABLE
103241: LD_INT 0
103243: PPUSH
103244: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103245: LD_ADDR_VAR 0 1
103249: PUSH
103250: LD_INT 22
103252: PUSH
103253: LD_OWVAR 2
103257: PUSH
103258: EMPTY
103259: LIST
103260: LIST
103261: PUSH
103262: LD_INT 2
103264: PUSH
103265: LD_INT 30
103267: PUSH
103268: LD_INT 0
103270: PUSH
103271: EMPTY
103272: LIST
103273: LIST
103274: PUSH
103275: LD_INT 30
103277: PUSH
103278: LD_INT 1
103280: PUSH
103281: EMPTY
103282: LIST
103283: LIST
103284: PUSH
103285: EMPTY
103286: LIST
103287: LIST
103288: LIST
103289: PUSH
103290: EMPTY
103291: LIST
103292: LIST
103293: PPUSH
103294: CALL_OW 69
103298: ST_TO_ADDR
// if not depot then
103299: LD_VAR 0 1
103303: NOT
103304: IFFALSE 103308
// exit ;
103306: GO 103382
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103308: LD_ADDR_VAR 0 2
103312: PUSH
103313: LD_VAR 0 1
103317: PUSH
103318: LD_INT 1
103320: PPUSH
103321: LD_VAR 0 1
103325: PPUSH
103326: CALL_OW 12
103330: ARRAY
103331: PPUSH
103332: CALL_OW 274
103336: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103337: LD_VAR 0 2
103341: PPUSH
103342: LD_INT 1
103344: PPUSH
103345: LD_INT 0
103347: PPUSH
103348: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103352: LD_VAR 0 2
103356: PPUSH
103357: LD_INT 2
103359: PPUSH
103360: LD_INT 0
103362: PPUSH
103363: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103367: LD_VAR 0 2
103371: PPUSH
103372: LD_INT 3
103374: PPUSH
103375: LD_INT 0
103377: PPUSH
103378: CALL_OW 277
// end ;
103382: PPOPN 2
103384: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103385: LD_EXP 99
103389: PUSH
103390: LD_EXP 127
103394: AND
103395: IFFALSE 103492
103397: GO 103399
103399: DISABLE
103400: LD_INT 0
103402: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103403: LD_ADDR_VAR 0 1
103407: PUSH
103408: LD_INT 22
103410: PUSH
103411: LD_OWVAR 2
103415: PUSH
103416: EMPTY
103417: LIST
103418: LIST
103419: PUSH
103420: LD_INT 21
103422: PUSH
103423: LD_INT 1
103425: PUSH
103426: EMPTY
103427: LIST
103428: LIST
103429: PUSH
103430: LD_INT 3
103432: PUSH
103433: LD_INT 23
103435: PUSH
103436: LD_INT 0
103438: PUSH
103439: EMPTY
103440: LIST
103441: LIST
103442: PUSH
103443: EMPTY
103444: LIST
103445: LIST
103446: PUSH
103447: EMPTY
103448: LIST
103449: LIST
103450: LIST
103451: PPUSH
103452: CALL_OW 69
103456: ST_TO_ADDR
// if not tmp then
103457: LD_VAR 0 1
103461: NOT
103462: IFFALSE 103466
// exit ;
103464: GO 103492
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103466: LD_VAR 0 1
103470: PUSH
103471: LD_INT 1
103473: PPUSH
103474: LD_VAR 0 1
103478: PPUSH
103479: CALL_OW 12
103483: ARRAY
103484: PPUSH
103485: LD_INT 200
103487: PPUSH
103488: CALL_OW 234
// end ;
103492: PPOPN 1
103494: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103495: LD_EXP 99
103499: PUSH
103500: LD_EXP 128
103504: AND
103505: IFFALSE 103584
103507: GO 103509
103509: DISABLE
103510: LD_INT 0
103512: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103513: LD_ADDR_VAR 0 1
103517: PUSH
103518: LD_INT 22
103520: PUSH
103521: LD_OWVAR 2
103525: PUSH
103526: EMPTY
103527: LIST
103528: LIST
103529: PUSH
103530: LD_INT 21
103532: PUSH
103533: LD_INT 2
103535: PUSH
103536: EMPTY
103537: LIST
103538: LIST
103539: PUSH
103540: EMPTY
103541: LIST
103542: LIST
103543: PPUSH
103544: CALL_OW 69
103548: ST_TO_ADDR
// if not tmp then
103549: LD_VAR 0 1
103553: NOT
103554: IFFALSE 103558
// exit ;
103556: GO 103584
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103558: LD_VAR 0 1
103562: PUSH
103563: LD_INT 1
103565: PPUSH
103566: LD_VAR 0 1
103570: PPUSH
103571: CALL_OW 12
103575: ARRAY
103576: PPUSH
103577: LD_INT 60
103579: PPUSH
103580: CALL_OW 234
// end ;
103584: PPOPN 1
103586: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103587: LD_EXP 99
103591: PUSH
103592: LD_EXP 129
103596: AND
103597: IFFALSE 103696
103599: GO 103601
103601: DISABLE
103602: LD_INT 0
103604: PPUSH
103605: PPUSH
// begin enable ;
103606: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103607: LD_ADDR_VAR 0 1
103611: PUSH
103612: LD_INT 22
103614: PUSH
103615: LD_OWVAR 2
103619: PUSH
103620: EMPTY
103621: LIST
103622: LIST
103623: PUSH
103624: LD_INT 61
103626: PUSH
103627: EMPTY
103628: LIST
103629: PUSH
103630: LD_INT 33
103632: PUSH
103633: LD_INT 2
103635: PUSH
103636: EMPTY
103637: LIST
103638: LIST
103639: PUSH
103640: EMPTY
103641: LIST
103642: LIST
103643: LIST
103644: PPUSH
103645: CALL_OW 69
103649: ST_TO_ADDR
// if not tmp then
103650: LD_VAR 0 1
103654: NOT
103655: IFFALSE 103659
// exit ;
103657: GO 103696
// for i in tmp do
103659: LD_ADDR_VAR 0 2
103663: PUSH
103664: LD_VAR 0 1
103668: PUSH
103669: FOR_IN
103670: IFFALSE 103694
// if IsControledBy ( i ) then
103672: LD_VAR 0 2
103676: PPUSH
103677: CALL_OW 312
103681: IFFALSE 103692
// ComUnlink ( i ) ;
103683: LD_VAR 0 2
103687: PPUSH
103688: CALL_OW 136
103692: GO 103669
103694: POP
103695: POP
// end ;
103696: PPOPN 2
103698: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103699: LD_EXP 99
103703: PUSH
103704: LD_EXP 130
103708: AND
103709: IFFALSE 103849
103711: GO 103713
103713: DISABLE
103714: LD_INT 0
103716: PPUSH
103717: PPUSH
// begin ToLua ( displayPowell(); ) ;
103718: LD_STRING displayPowell();
103720: PPUSH
103721: CALL_OW 559
// uc_side := 0 ;
103725: LD_ADDR_OWVAR 20
103729: PUSH
103730: LD_INT 0
103732: ST_TO_ADDR
// uc_nation := 2 ;
103733: LD_ADDR_OWVAR 21
103737: PUSH
103738: LD_INT 2
103740: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103741: LD_ADDR_OWVAR 37
103745: PUSH
103746: LD_INT 14
103748: ST_TO_ADDR
// vc_engine := engine_siberite ;
103749: LD_ADDR_OWVAR 39
103753: PUSH
103754: LD_INT 3
103756: ST_TO_ADDR
// vc_control := control_apeman ;
103757: LD_ADDR_OWVAR 38
103761: PUSH
103762: LD_INT 5
103764: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103765: LD_ADDR_OWVAR 40
103769: PUSH
103770: LD_INT 29
103772: ST_TO_ADDR
// un := CreateVehicle ;
103773: LD_ADDR_VAR 0 2
103777: PUSH
103778: CALL_OW 45
103782: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103783: LD_VAR 0 2
103787: PPUSH
103788: LD_INT 1
103790: PPUSH
103791: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103795: LD_INT 35
103797: PPUSH
103798: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103802: LD_VAR 0 2
103806: PPUSH
103807: LD_INT 22
103809: PUSH
103810: LD_OWVAR 2
103814: PUSH
103815: EMPTY
103816: LIST
103817: LIST
103818: PPUSH
103819: CALL_OW 69
103823: PPUSH
103824: LD_VAR 0 2
103828: PPUSH
103829: CALL_OW 74
103833: PPUSH
103834: CALL_OW 115
// until IsDead ( un ) ;
103838: LD_VAR 0 2
103842: PPUSH
103843: CALL_OW 301
103847: IFFALSE 103795
// end ;
103849: PPOPN 2
103851: END
// every 0 0$1 trigger StreamModeActive and sStu do
103852: LD_EXP 99
103856: PUSH
103857: LD_EXP 138
103861: AND
103862: IFFALSE 103878
103864: GO 103866
103866: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103867: LD_STRING displayStucuk();
103869: PPUSH
103870: CALL_OW 559
// ResetFog ;
103874: CALL_OW 335
// end ;
103878: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103879: LD_EXP 99
103883: PUSH
103884: LD_EXP 131
103888: AND
103889: IFFALSE 104030
103891: GO 103893
103893: DISABLE
103894: LD_INT 0
103896: PPUSH
103897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103898: LD_ADDR_VAR 0 2
103902: PUSH
103903: LD_INT 22
103905: PUSH
103906: LD_OWVAR 2
103910: PUSH
103911: EMPTY
103912: LIST
103913: LIST
103914: PUSH
103915: LD_INT 21
103917: PUSH
103918: LD_INT 1
103920: PUSH
103921: EMPTY
103922: LIST
103923: LIST
103924: PUSH
103925: EMPTY
103926: LIST
103927: LIST
103928: PPUSH
103929: CALL_OW 69
103933: ST_TO_ADDR
// if not tmp then
103934: LD_VAR 0 2
103938: NOT
103939: IFFALSE 103943
// exit ;
103941: GO 104030
// un := tmp [ rand ( 1 , tmp ) ] ;
103943: LD_ADDR_VAR 0 1
103947: PUSH
103948: LD_VAR 0 2
103952: PUSH
103953: LD_INT 1
103955: PPUSH
103956: LD_VAR 0 2
103960: PPUSH
103961: CALL_OW 12
103965: ARRAY
103966: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103967: LD_VAR 0 1
103971: PPUSH
103972: LD_INT 0
103974: PPUSH
103975: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103979: LD_VAR 0 1
103983: PPUSH
103984: LD_OWVAR 3
103988: PUSH
103989: LD_VAR 0 1
103993: DIFF
103994: PPUSH
103995: LD_VAR 0 1
103999: PPUSH
104000: CALL_OW 74
104004: PPUSH
104005: CALL_OW 115
// wait ( 0 0$20 ) ;
104009: LD_INT 700
104011: PPUSH
104012: CALL_OW 67
// SetSide ( un , your_side ) ;
104016: LD_VAR 0 1
104020: PPUSH
104021: LD_OWVAR 2
104025: PPUSH
104026: CALL_OW 235
// end ;
104030: PPOPN 2
104032: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104033: LD_EXP 99
104037: PUSH
104038: LD_EXP 132
104042: AND
104043: IFFALSE 104149
104045: GO 104047
104047: DISABLE
104048: LD_INT 0
104050: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104051: LD_ADDR_VAR 0 1
104055: PUSH
104056: LD_INT 22
104058: PUSH
104059: LD_OWVAR 2
104063: PUSH
104064: EMPTY
104065: LIST
104066: LIST
104067: PUSH
104068: LD_INT 2
104070: PUSH
104071: LD_INT 30
104073: PUSH
104074: LD_INT 0
104076: PUSH
104077: EMPTY
104078: LIST
104079: LIST
104080: PUSH
104081: LD_INT 30
104083: PUSH
104084: LD_INT 1
104086: PUSH
104087: EMPTY
104088: LIST
104089: LIST
104090: PUSH
104091: EMPTY
104092: LIST
104093: LIST
104094: LIST
104095: PUSH
104096: EMPTY
104097: LIST
104098: LIST
104099: PPUSH
104100: CALL_OW 69
104104: ST_TO_ADDR
// if not depot then
104105: LD_VAR 0 1
104109: NOT
104110: IFFALSE 104114
// exit ;
104112: GO 104149
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104114: LD_VAR 0 1
104118: PUSH
104119: LD_INT 1
104121: ARRAY
104122: PPUSH
104123: CALL_OW 250
104127: PPUSH
104128: LD_VAR 0 1
104132: PUSH
104133: LD_INT 1
104135: ARRAY
104136: PPUSH
104137: CALL_OW 251
104141: PPUSH
104142: LD_INT 70
104144: PPUSH
104145: CALL_OW 495
// end ;
104149: PPOPN 1
104151: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104152: LD_EXP 99
104156: PUSH
104157: LD_EXP 133
104161: AND
104162: IFFALSE 104373
104164: GO 104166
104166: DISABLE
104167: LD_INT 0
104169: PPUSH
104170: PPUSH
104171: PPUSH
104172: PPUSH
104173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104174: LD_ADDR_VAR 0 5
104178: PUSH
104179: LD_INT 22
104181: PUSH
104182: LD_OWVAR 2
104186: PUSH
104187: EMPTY
104188: LIST
104189: LIST
104190: PUSH
104191: LD_INT 21
104193: PUSH
104194: LD_INT 1
104196: PUSH
104197: EMPTY
104198: LIST
104199: LIST
104200: PUSH
104201: EMPTY
104202: LIST
104203: LIST
104204: PPUSH
104205: CALL_OW 69
104209: ST_TO_ADDR
// if not tmp then
104210: LD_VAR 0 5
104214: NOT
104215: IFFALSE 104219
// exit ;
104217: GO 104373
// for i in tmp do
104219: LD_ADDR_VAR 0 1
104223: PUSH
104224: LD_VAR 0 5
104228: PUSH
104229: FOR_IN
104230: IFFALSE 104371
// begin d := rand ( 0 , 5 ) ;
104232: LD_ADDR_VAR 0 4
104236: PUSH
104237: LD_INT 0
104239: PPUSH
104240: LD_INT 5
104242: PPUSH
104243: CALL_OW 12
104247: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104248: LD_ADDR_VAR 0 2
104252: PUSH
104253: LD_VAR 0 1
104257: PPUSH
104258: CALL_OW 250
104262: PPUSH
104263: LD_VAR 0 4
104267: PPUSH
104268: LD_INT 3
104270: PPUSH
104271: LD_INT 12
104273: PPUSH
104274: CALL_OW 12
104278: PPUSH
104279: CALL_OW 272
104283: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104284: LD_ADDR_VAR 0 3
104288: PUSH
104289: LD_VAR 0 1
104293: PPUSH
104294: CALL_OW 251
104298: PPUSH
104299: LD_VAR 0 4
104303: PPUSH
104304: LD_INT 3
104306: PPUSH
104307: LD_INT 12
104309: PPUSH
104310: CALL_OW 12
104314: PPUSH
104315: CALL_OW 273
104319: ST_TO_ADDR
// if ValidHex ( x , y ) then
104320: LD_VAR 0 2
104324: PPUSH
104325: LD_VAR 0 3
104329: PPUSH
104330: CALL_OW 488
104334: IFFALSE 104369
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104336: LD_VAR 0 1
104340: PPUSH
104341: LD_VAR 0 2
104345: PPUSH
104346: LD_VAR 0 3
104350: PPUSH
104351: LD_INT 3
104353: PPUSH
104354: LD_INT 6
104356: PPUSH
104357: CALL_OW 12
104361: PPUSH
104362: LD_INT 1
104364: PPUSH
104365: CALL_OW 483
// end ;
104369: GO 104229
104371: POP
104372: POP
// end ;
104373: PPOPN 5
104375: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104376: LD_EXP 99
104380: PUSH
104381: LD_EXP 134
104385: AND
104386: IFFALSE 104480
104388: GO 104390
104390: DISABLE
104391: LD_INT 0
104393: PPUSH
104394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104395: LD_ADDR_VAR 0 2
104399: PUSH
104400: LD_INT 22
104402: PUSH
104403: LD_OWVAR 2
104407: PUSH
104408: EMPTY
104409: LIST
104410: LIST
104411: PUSH
104412: LD_INT 32
104414: PUSH
104415: LD_INT 1
104417: PUSH
104418: EMPTY
104419: LIST
104420: LIST
104421: PUSH
104422: LD_INT 21
104424: PUSH
104425: LD_INT 2
104427: PUSH
104428: EMPTY
104429: LIST
104430: LIST
104431: PUSH
104432: EMPTY
104433: LIST
104434: LIST
104435: LIST
104436: PPUSH
104437: CALL_OW 69
104441: ST_TO_ADDR
// if not tmp then
104442: LD_VAR 0 2
104446: NOT
104447: IFFALSE 104451
// exit ;
104449: GO 104480
// for i in tmp do
104451: LD_ADDR_VAR 0 1
104455: PUSH
104456: LD_VAR 0 2
104460: PUSH
104461: FOR_IN
104462: IFFALSE 104478
// SetFuel ( i , 0 ) ;
104464: LD_VAR 0 1
104468: PPUSH
104469: LD_INT 0
104471: PPUSH
104472: CALL_OW 240
104476: GO 104461
104478: POP
104479: POP
// end ;
104480: PPOPN 2
104482: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104483: LD_EXP 99
104487: PUSH
104488: LD_EXP 135
104492: AND
104493: IFFALSE 104559
104495: GO 104497
104497: DISABLE
104498: LD_INT 0
104500: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104501: LD_ADDR_VAR 0 1
104505: PUSH
104506: LD_INT 22
104508: PUSH
104509: LD_OWVAR 2
104513: PUSH
104514: EMPTY
104515: LIST
104516: LIST
104517: PUSH
104518: LD_INT 30
104520: PUSH
104521: LD_INT 29
104523: PUSH
104524: EMPTY
104525: LIST
104526: LIST
104527: PUSH
104528: EMPTY
104529: LIST
104530: LIST
104531: PPUSH
104532: CALL_OW 69
104536: ST_TO_ADDR
// if not tmp then
104537: LD_VAR 0 1
104541: NOT
104542: IFFALSE 104546
// exit ;
104544: GO 104559
// DestroyUnit ( tmp [ 1 ] ) ;
104546: LD_VAR 0 1
104550: PUSH
104551: LD_INT 1
104553: ARRAY
104554: PPUSH
104555: CALL_OW 65
// end ;
104559: PPOPN 1
104561: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104562: LD_EXP 99
104566: PUSH
104567: LD_EXP 137
104571: AND
104572: IFFALSE 104701
104574: GO 104576
104576: DISABLE
104577: LD_INT 0
104579: PPUSH
// begin uc_side := 0 ;
104580: LD_ADDR_OWVAR 20
104584: PUSH
104585: LD_INT 0
104587: ST_TO_ADDR
// uc_nation := nation_arabian ;
104588: LD_ADDR_OWVAR 21
104592: PUSH
104593: LD_INT 2
104595: ST_TO_ADDR
// hc_gallery :=  ;
104596: LD_ADDR_OWVAR 33
104600: PUSH
104601: LD_STRING 
104603: ST_TO_ADDR
// hc_name :=  ;
104604: LD_ADDR_OWVAR 26
104608: PUSH
104609: LD_STRING 
104611: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104612: LD_INT 1
104614: PPUSH
104615: LD_INT 11
104617: PPUSH
104618: LD_INT 10
104620: PPUSH
104621: CALL_OW 380
// un := CreateHuman ;
104625: LD_ADDR_VAR 0 1
104629: PUSH
104630: CALL_OW 44
104634: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104635: LD_VAR 0 1
104639: PPUSH
104640: LD_INT 1
104642: PPUSH
104643: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104647: LD_INT 35
104649: PPUSH
104650: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104654: LD_VAR 0 1
104658: PPUSH
104659: LD_INT 22
104661: PUSH
104662: LD_OWVAR 2
104666: PUSH
104667: EMPTY
104668: LIST
104669: LIST
104670: PPUSH
104671: CALL_OW 69
104675: PPUSH
104676: LD_VAR 0 1
104680: PPUSH
104681: CALL_OW 74
104685: PPUSH
104686: CALL_OW 115
// until IsDead ( un ) ;
104690: LD_VAR 0 1
104694: PPUSH
104695: CALL_OW 301
104699: IFFALSE 104647
// end ;
104701: PPOPN 1
104703: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104704: LD_EXP 99
104708: PUSH
104709: LD_EXP 139
104713: AND
104714: IFFALSE 104726
104716: GO 104718
104718: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104719: LD_STRING earthquake(getX(game), 0, 32)
104721: PPUSH
104722: CALL_OW 559
104726: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104727: LD_EXP 99
104731: PUSH
104732: LD_EXP 140
104736: AND
104737: IFFALSE 104828
104739: GO 104741
104741: DISABLE
104742: LD_INT 0
104744: PPUSH
// begin enable ;
104745: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104746: LD_ADDR_VAR 0 1
104750: PUSH
104751: LD_INT 22
104753: PUSH
104754: LD_OWVAR 2
104758: PUSH
104759: EMPTY
104760: LIST
104761: LIST
104762: PUSH
104763: LD_INT 21
104765: PUSH
104766: LD_INT 2
104768: PUSH
104769: EMPTY
104770: LIST
104771: LIST
104772: PUSH
104773: LD_INT 33
104775: PUSH
104776: LD_INT 3
104778: PUSH
104779: EMPTY
104780: LIST
104781: LIST
104782: PUSH
104783: EMPTY
104784: LIST
104785: LIST
104786: LIST
104787: PPUSH
104788: CALL_OW 69
104792: ST_TO_ADDR
// if not tmp then
104793: LD_VAR 0 1
104797: NOT
104798: IFFALSE 104802
// exit ;
104800: GO 104828
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104802: LD_VAR 0 1
104806: PUSH
104807: LD_INT 1
104809: PPUSH
104810: LD_VAR 0 1
104814: PPUSH
104815: CALL_OW 12
104819: ARRAY
104820: PPUSH
104821: LD_INT 1
104823: PPUSH
104824: CALL_OW 234
// end ;
104828: PPOPN 1
104830: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104831: LD_EXP 99
104835: PUSH
104836: LD_EXP 141
104840: AND
104841: IFFALSE 104982
104843: GO 104845
104845: DISABLE
104846: LD_INT 0
104848: PPUSH
104849: PPUSH
104850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104851: LD_ADDR_VAR 0 3
104855: PUSH
104856: LD_INT 22
104858: PUSH
104859: LD_OWVAR 2
104863: PUSH
104864: EMPTY
104865: LIST
104866: LIST
104867: PUSH
104868: LD_INT 25
104870: PUSH
104871: LD_INT 1
104873: PUSH
104874: EMPTY
104875: LIST
104876: LIST
104877: PUSH
104878: EMPTY
104879: LIST
104880: LIST
104881: PPUSH
104882: CALL_OW 69
104886: ST_TO_ADDR
// if not tmp then
104887: LD_VAR 0 3
104891: NOT
104892: IFFALSE 104896
// exit ;
104894: GO 104982
// un := tmp [ rand ( 1 , tmp ) ] ;
104896: LD_ADDR_VAR 0 2
104900: PUSH
104901: LD_VAR 0 3
104905: PUSH
104906: LD_INT 1
104908: PPUSH
104909: LD_VAR 0 3
104913: PPUSH
104914: CALL_OW 12
104918: ARRAY
104919: ST_TO_ADDR
// if Crawls ( un ) then
104920: LD_VAR 0 2
104924: PPUSH
104925: CALL_OW 318
104929: IFFALSE 104940
// ComWalk ( un ) ;
104931: LD_VAR 0 2
104935: PPUSH
104936: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104940: LD_VAR 0 2
104944: PPUSH
104945: LD_INT 9
104947: PPUSH
104948: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104952: LD_INT 28
104954: PPUSH
104955: LD_OWVAR 2
104959: PPUSH
104960: LD_INT 2
104962: PPUSH
104963: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104967: LD_INT 29
104969: PPUSH
104970: LD_OWVAR 2
104974: PPUSH
104975: LD_INT 2
104977: PPUSH
104978: CALL_OW 322
// end ;
104982: PPOPN 3
104984: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104985: LD_EXP 99
104989: PUSH
104990: LD_EXP 142
104994: AND
104995: IFFALSE 105106
104997: GO 104999
104999: DISABLE
105000: LD_INT 0
105002: PPUSH
105003: PPUSH
105004: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105005: LD_ADDR_VAR 0 3
105009: PUSH
105010: LD_INT 22
105012: PUSH
105013: LD_OWVAR 2
105017: PUSH
105018: EMPTY
105019: LIST
105020: LIST
105021: PUSH
105022: LD_INT 25
105024: PUSH
105025: LD_INT 1
105027: PUSH
105028: EMPTY
105029: LIST
105030: LIST
105031: PUSH
105032: EMPTY
105033: LIST
105034: LIST
105035: PPUSH
105036: CALL_OW 69
105040: ST_TO_ADDR
// if not tmp then
105041: LD_VAR 0 3
105045: NOT
105046: IFFALSE 105050
// exit ;
105048: GO 105106
// un := tmp [ rand ( 1 , tmp ) ] ;
105050: LD_ADDR_VAR 0 2
105054: PUSH
105055: LD_VAR 0 3
105059: PUSH
105060: LD_INT 1
105062: PPUSH
105063: LD_VAR 0 3
105067: PPUSH
105068: CALL_OW 12
105072: ARRAY
105073: ST_TO_ADDR
// if Crawls ( un ) then
105074: LD_VAR 0 2
105078: PPUSH
105079: CALL_OW 318
105083: IFFALSE 105094
// ComWalk ( un ) ;
105085: LD_VAR 0 2
105089: PPUSH
105090: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105094: LD_VAR 0 2
105098: PPUSH
105099: LD_INT 8
105101: PPUSH
105102: CALL_OW 336
// end ;
105106: PPOPN 3
105108: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105109: LD_EXP 99
105113: PUSH
105114: LD_EXP 143
105118: AND
105119: IFFALSE 105263
105121: GO 105123
105123: DISABLE
105124: LD_INT 0
105126: PPUSH
105127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105128: LD_ADDR_VAR 0 2
105132: PUSH
105133: LD_INT 22
105135: PUSH
105136: LD_OWVAR 2
105140: PUSH
105141: EMPTY
105142: LIST
105143: LIST
105144: PUSH
105145: LD_INT 21
105147: PUSH
105148: LD_INT 2
105150: PUSH
105151: EMPTY
105152: LIST
105153: LIST
105154: PUSH
105155: LD_INT 2
105157: PUSH
105158: LD_INT 34
105160: PUSH
105161: LD_INT 12
105163: PUSH
105164: EMPTY
105165: LIST
105166: LIST
105167: PUSH
105168: LD_INT 34
105170: PUSH
105171: LD_INT 51
105173: PUSH
105174: EMPTY
105175: LIST
105176: LIST
105177: PUSH
105178: LD_INT 34
105180: PUSH
105181: LD_INT 32
105183: PUSH
105184: EMPTY
105185: LIST
105186: LIST
105187: PUSH
105188: EMPTY
105189: LIST
105190: LIST
105191: LIST
105192: LIST
105193: PUSH
105194: EMPTY
105195: LIST
105196: LIST
105197: LIST
105198: PPUSH
105199: CALL_OW 69
105203: ST_TO_ADDR
// if not tmp then
105204: LD_VAR 0 2
105208: NOT
105209: IFFALSE 105213
// exit ;
105211: GO 105263
// for i in tmp do
105213: LD_ADDR_VAR 0 1
105217: PUSH
105218: LD_VAR 0 2
105222: PUSH
105223: FOR_IN
105224: IFFALSE 105261
// if GetCargo ( i , mat_artifact ) = 0 then
105226: LD_VAR 0 1
105230: PPUSH
105231: LD_INT 4
105233: PPUSH
105234: CALL_OW 289
105238: PUSH
105239: LD_INT 0
105241: EQUAL
105242: IFFALSE 105259
// SetCargo ( i , mat_siberit , 100 ) ;
105244: LD_VAR 0 1
105248: PPUSH
105249: LD_INT 3
105251: PPUSH
105252: LD_INT 100
105254: PPUSH
105255: CALL_OW 290
105259: GO 105223
105261: POP
105262: POP
// end ;
105263: PPOPN 2
105265: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105266: LD_EXP 99
105270: PUSH
105271: LD_EXP 144
105275: AND
105276: IFFALSE 105459
105278: GO 105280
105280: DISABLE
105281: LD_INT 0
105283: PPUSH
105284: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105285: LD_ADDR_VAR 0 2
105289: PUSH
105290: LD_INT 22
105292: PUSH
105293: LD_OWVAR 2
105297: PUSH
105298: EMPTY
105299: LIST
105300: LIST
105301: PPUSH
105302: CALL_OW 69
105306: ST_TO_ADDR
// if not tmp then
105307: LD_VAR 0 2
105311: NOT
105312: IFFALSE 105316
// exit ;
105314: GO 105459
// for i := 1 to 2 do
105316: LD_ADDR_VAR 0 1
105320: PUSH
105321: DOUBLE
105322: LD_INT 1
105324: DEC
105325: ST_TO_ADDR
105326: LD_INT 2
105328: PUSH
105329: FOR_TO
105330: IFFALSE 105457
// begin uc_side := your_side ;
105332: LD_ADDR_OWVAR 20
105336: PUSH
105337: LD_OWVAR 2
105341: ST_TO_ADDR
// uc_nation := nation_american ;
105342: LD_ADDR_OWVAR 21
105346: PUSH
105347: LD_INT 1
105349: ST_TO_ADDR
// vc_chassis := us_morphling ;
105350: LD_ADDR_OWVAR 37
105354: PUSH
105355: LD_INT 5
105357: ST_TO_ADDR
// vc_engine := engine_siberite ;
105358: LD_ADDR_OWVAR 39
105362: PUSH
105363: LD_INT 3
105365: ST_TO_ADDR
// vc_control := control_computer ;
105366: LD_ADDR_OWVAR 38
105370: PUSH
105371: LD_INT 3
105373: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105374: LD_ADDR_OWVAR 40
105378: PUSH
105379: LD_INT 10
105381: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105382: LD_VAR 0 2
105386: PUSH
105387: LD_INT 1
105389: ARRAY
105390: PPUSH
105391: CALL_OW 310
105395: NOT
105396: IFFALSE 105443
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105398: CALL_OW 45
105402: PPUSH
105403: LD_VAR 0 2
105407: PUSH
105408: LD_INT 1
105410: ARRAY
105411: PPUSH
105412: CALL_OW 250
105416: PPUSH
105417: LD_VAR 0 2
105421: PUSH
105422: LD_INT 1
105424: ARRAY
105425: PPUSH
105426: CALL_OW 251
105430: PPUSH
105431: LD_INT 12
105433: PPUSH
105434: LD_INT 1
105436: PPUSH
105437: CALL_OW 50
105441: GO 105455
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105443: CALL_OW 45
105447: PPUSH
105448: LD_INT 1
105450: PPUSH
105451: CALL_OW 51
// end ;
105455: GO 105329
105457: POP
105458: POP
// end ;
105459: PPOPN 2
105461: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105462: LD_EXP 99
105466: PUSH
105467: LD_EXP 145
105471: AND
105472: IFFALSE 105694
105474: GO 105476
105476: DISABLE
105477: LD_INT 0
105479: PPUSH
105480: PPUSH
105481: PPUSH
105482: PPUSH
105483: PPUSH
105484: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105485: LD_ADDR_VAR 0 6
105489: PUSH
105490: LD_INT 22
105492: PUSH
105493: LD_OWVAR 2
105497: PUSH
105498: EMPTY
105499: LIST
105500: LIST
105501: PUSH
105502: LD_INT 21
105504: PUSH
105505: LD_INT 1
105507: PUSH
105508: EMPTY
105509: LIST
105510: LIST
105511: PUSH
105512: LD_INT 3
105514: PUSH
105515: LD_INT 23
105517: PUSH
105518: LD_INT 0
105520: PUSH
105521: EMPTY
105522: LIST
105523: LIST
105524: PUSH
105525: EMPTY
105526: LIST
105527: LIST
105528: PUSH
105529: EMPTY
105530: LIST
105531: LIST
105532: LIST
105533: PPUSH
105534: CALL_OW 69
105538: ST_TO_ADDR
// if not tmp then
105539: LD_VAR 0 6
105543: NOT
105544: IFFALSE 105548
// exit ;
105546: GO 105694
// s1 := rand ( 1 , 4 ) ;
105548: LD_ADDR_VAR 0 2
105552: PUSH
105553: LD_INT 1
105555: PPUSH
105556: LD_INT 4
105558: PPUSH
105559: CALL_OW 12
105563: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105564: LD_ADDR_VAR 0 4
105568: PUSH
105569: LD_VAR 0 6
105573: PUSH
105574: LD_INT 1
105576: ARRAY
105577: PPUSH
105578: LD_VAR 0 2
105582: PPUSH
105583: CALL_OW 259
105587: ST_TO_ADDR
// if s1 = 1 then
105588: LD_VAR 0 2
105592: PUSH
105593: LD_INT 1
105595: EQUAL
105596: IFFALSE 105616
// s2 := rand ( 2 , 4 ) else
105598: LD_ADDR_VAR 0 3
105602: PUSH
105603: LD_INT 2
105605: PPUSH
105606: LD_INT 4
105608: PPUSH
105609: CALL_OW 12
105613: ST_TO_ADDR
105614: GO 105624
// s2 := 1 ;
105616: LD_ADDR_VAR 0 3
105620: PUSH
105621: LD_INT 1
105623: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105624: LD_ADDR_VAR 0 5
105628: PUSH
105629: LD_VAR 0 6
105633: PUSH
105634: LD_INT 1
105636: ARRAY
105637: PPUSH
105638: LD_VAR 0 3
105642: PPUSH
105643: CALL_OW 259
105647: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105648: LD_VAR 0 6
105652: PUSH
105653: LD_INT 1
105655: ARRAY
105656: PPUSH
105657: LD_VAR 0 2
105661: PPUSH
105662: LD_VAR 0 5
105666: PPUSH
105667: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105671: LD_VAR 0 6
105675: PUSH
105676: LD_INT 1
105678: ARRAY
105679: PPUSH
105680: LD_VAR 0 3
105684: PPUSH
105685: LD_VAR 0 4
105689: PPUSH
105690: CALL_OW 237
// end ;
105694: PPOPN 6
105696: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105697: LD_EXP 99
105701: PUSH
105702: LD_EXP 146
105706: AND
105707: IFFALSE 105786
105709: GO 105711
105711: DISABLE
105712: LD_INT 0
105714: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105715: LD_ADDR_VAR 0 1
105719: PUSH
105720: LD_INT 22
105722: PUSH
105723: LD_OWVAR 2
105727: PUSH
105728: EMPTY
105729: LIST
105730: LIST
105731: PUSH
105732: LD_INT 30
105734: PUSH
105735: LD_INT 3
105737: PUSH
105738: EMPTY
105739: LIST
105740: LIST
105741: PUSH
105742: EMPTY
105743: LIST
105744: LIST
105745: PPUSH
105746: CALL_OW 69
105750: ST_TO_ADDR
// if not tmp then
105751: LD_VAR 0 1
105755: NOT
105756: IFFALSE 105760
// exit ;
105758: GO 105786
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105760: LD_VAR 0 1
105764: PUSH
105765: LD_INT 1
105767: PPUSH
105768: LD_VAR 0 1
105772: PPUSH
105773: CALL_OW 12
105777: ARRAY
105778: PPUSH
105779: LD_INT 1
105781: PPUSH
105782: CALL_OW 234
// end ;
105786: PPOPN 1
105788: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105789: LD_EXP 99
105793: PUSH
105794: LD_EXP 147
105798: AND
105799: IFFALSE 105911
105801: GO 105803
105803: DISABLE
105804: LD_INT 0
105806: PPUSH
105807: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105808: LD_ADDR_VAR 0 2
105812: PUSH
105813: LD_INT 22
105815: PUSH
105816: LD_OWVAR 2
105820: PUSH
105821: EMPTY
105822: LIST
105823: LIST
105824: PUSH
105825: LD_INT 2
105827: PUSH
105828: LD_INT 30
105830: PUSH
105831: LD_INT 27
105833: PUSH
105834: EMPTY
105835: LIST
105836: LIST
105837: PUSH
105838: LD_INT 30
105840: PUSH
105841: LD_INT 26
105843: PUSH
105844: EMPTY
105845: LIST
105846: LIST
105847: PUSH
105848: LD_INT 30
105850: PUSH
105851: LD_INT 28
105853: PUSH
105854: EMPTY
105855: LIST
105856: LIST
105857: PUSH
105858: EMPTY
105859: LIST
105860: LIST
105861: LIST
105862: LIST
105863: PUSH
105864: EMPTY
105865: LIST
105866: LIST
105867: PPUSH
105868: CALL_OW 69
105872: ST_TO_ADDR
// if not tmp then
105873: LD_VAR 0 2
105877: NOT
105878: IFFALSE 105882
// exit ;
105880: GO 105911
// for i in tmp do
105882: LD_ADDR_VAR 0 1
105886: PUSH
105887: LD_VAR 0 2
105891: PUSH
105892: FOR_IN
105893: IFFALSE 105909
// SetLives ( i , 1 ) ;
105895: LD_VAR 0 1
105899: PPUSH
105900: LD_INT 1
105902: PPUSH
105903: CALL_OW 234
105907: GO 105892
105909: POP
105910: POP
// end ;
105911: PPOPN 2
105913: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105914: LD_EXP 99
105918: PUSH
105919: LD_EXP 148
105923: AND
105924: IFFALSE 106211
105926: GO 105928
105928: DISABLE
105929: LD_INT 0
105931: PPUSH
105932: PPUSH
105933: PPUSH
// begin i := rand ( 1 , 7 ) ;
105934: LD_ADDR_VAR 0 1
105938: PUSH
105939: LD_INT 1
105941: PPUSH
105942: LD_INT 7
105944: PPUSH
105945: CALL_OW 12
105949: ST_TO_ADDR
// case i of 1 :
105950: LD_VAR 0 1
105954: PUSH
105955: LD_INT 1
105957: DOUBLE
105958: EQUAL
105959: IFTRUE 105963
105961: GO 105973
105963: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105964: LD_STRING earthquake(getX(game), 0, 32)
105966: PPUSH
105967: CALL_OW 559
105971: GO 106211
105973: LD_INT 2
105975: DOUBLE
105976: EQUAL
105977: IFTRUE 105981
105979: GO 105995
105981: POP
// begin ToLua ( displayStucuk(); ) ;
105982: LD_STRING displayStucuk();
105984: PPUSH
105985: CALL_OW 559
// ResetFog ;
105989: CALL_OW 335
// end ; 3 :
105993: GO 106211
105995: LD_INT 3
105997: DOUBLE
105998: EQUAL
105999: IFTRUE 106003
106001: GO 106107
106003: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106004: LD_ADDR_VAR 0 2
106008: PUSH
106009: LD_INT 22
106011: PUSH
106012: LD_OWVAR 2
106016: PUSH
106017: EMPTY
106018: LIST
106019: LIST
106020: PUSH
106021: LD_INT 25
106023: PUSH
106024: LD_INT 1
106026: PUSH
106027: EMPTY
106028: LIST
106029: LIST
106030: PUSH
106031: EMPTY
106032: LIST
106033: LIST
106034: PPUSH
106035: CALL_OW 69
106039: ST_TO_ADDR
// if not tmp then
106040: LD_VAR 0 2
106044: NOT
106045: IFFALSE 106049
// exit ;
106047: GO 106211
// un := tmp [ rand ( 1 , tmp ) ] ;
106049: LD_ADDR_VAR 0 3
106053: PUSH
106054: LD_VAR 0 2
106058: PUSH
106059: LD_INT 1
106061: PPUSH
106062: LD_VAR 0 2
106066: PPUSH
106067: CALL_OW 12
106071: ARRAY
106072: ST_TO_ADDR
// if Crawls ( un ) then
106073: LD_VAR 0 3
106077: PPUSH
106078: CALL_OW 318
106082: IFFALSE 106093
// ComWalk ( un ) ;
106084: LD_VAR 0 3
106088: PPUSH
106089: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106093: LD_VAR 0 3
106097: PPUSH
106098: LD_INT 8
106100: PPUSH
106101: CALL_OW 336
// end ; 4 :
106105: GO 106211
106107: LD_INT 4
106109: DOUBLE
106110: EQUAL
106111: IFTRUE 106115
106113: GO 106189
106115: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106116: LD_ADDR_VAR 0 2
106120: PUSH
106121: LD_INT 22
106123: PUSH
106124: LD_OWVAR 2
106128: PUSH
106129: EMPTY
106130: LIST
106131: LIST
106132: PUSH
106133: LD_INT 30
106135: PUSH
106136: LD_INT 29
106138: PUSH
106139: EMPTY
106140: LIST
106141: LIST
106142: PUSH
106143: EMPTY
106144: LIST
106145: LIST
106146: PPUSH
106147: CALL_OW 69
106151: ST_TO_ADDR
// if not tmp then
106152: LD_VAR 0 2
106156: NOT
106157: IFFALSE 106161
// exit ;
106159: GO 106211
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106161: LD_VAR 0 2
106165: PUSH
106166: LD_INT 1
106168: ARRAY
106169: PPUSH
106170: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106174: LD_VAR 0 2
106178: PUSH
106179: LD_INT 1
106181: ARRAY
106182: PPUSH
106183: CALL_OW 65
// end ; 5 .. 7 :
106187: GO 106211
106189: LD_INT 5
106191: DOUBLE
106192: GREATEREQUAL
106193: IFFALSE 106201
106195: LD_INT 7
106197: DOUBLE
106198: LESSEQUAL
106199: IFTRUE 106203
106201: GO 106210
106203: POP
// StreamSibBomb ; end ;
106204: CALL 102448 0 0
106208: GO 106211
106210: POP
// end ;
106211: PPOPN 3
106213: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106214: LD_EXP 99
106218: PUSH
106219: LD_EXP 149
106223: AND
106224: IFFALSE 106380
106226: GO 106228
106228: DISABLE
106229: LD_INT 0
106231: PPUSH
106232: PPUSH
106233: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106234: LD_ADDR_VAR 0 2
106238: PUSH
106239: LD_INT 81
106241: PUSH
106242: LD_OWVAR 2
106246: PUSH
106247: EMPTY
106248: LIST
106249: LIST
106250: PUSH
106251: LD_INT 2
106253: PUSH
106254: LD_INT 21
106256: PUSH
106257: LD_INT 1
106259: PUSH
106260: EMPTY
106261: LIST
106262: LIST
106263: PUSH
106264: LD_INT 21
106266: PUSH
106267: LD_INT 2
106269: PUSH
106270: EMPTY
106271: LIST
106272: LIST
106273: PUSH
106274: EMPTY
106275: LIST
106276: LIST
106277: LIST
106278: PUSH
106279: EMPTY
106280: LIST
106281: LIST
106282: PPUSH
106283: CALL_OW 69
106287: ST_TO_ADDR
// if not tmp then
106288: LD_VAR 0 2
106292: NOT
106293: IFFALSE 106297
// exit ;
106295: GO 106380
// p := 0 ;
106297: LD_ADDR_VAR 0 3
106301: PUSH
106302: LD_INT 0
106304: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106305: LD_INT 35
106307: PPUSH
106308: CALL_OW 67
// p := p + 1 ;
106312: LD_ADDR_VAR 0 3
106316: PUSH
106317: LD_VAR 0 3
106321: PUSH
106322: LD_INT 1
106324: PLUS
106325: ST_TO_ADDR
// for i in tmp do
106326: LD_ADDR_VAR 0 1
106330: PUSH
106331: LD_VAR 0 2
106335: PUSH
106336: FOR_IN
106337: IFFALSE 106368
// if GetLives ( i ) < 1000 then
106339: LD_VAR 0 1
106343: PPUSH
106344: CALL_OW 256
106348: PUSH
106349: LD_INT 1000
106351: LESS
106352: IFFALSE 106366
// SetLives ( i , 1000 ) ;
106354: LD_VAR 0 1
106358: PPUSH
106359: LD_INT 1000
106361: PPUSH
106362: CALL_OW 234
106366: GO 106336
106368: POP
106369: POP
// until p > 20 ;
106370: LD_VAR 0 3
106374: PUSH
106375: LD_INT 20
106377: GREATER
106378: IFFALSE 106305
// end ;
106380: PPOPN 3
106382: END
// every 0 0$1 trigger StreamModeActive and sTime do
106383: LD_EXP 99
106387: PUSH
106388: LD_EXP 150
106392: AND
106393: IFFALSE 106428
106395: GO 106397
106397: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106398: LD_INT 28
106400: PPUSH
106401: LD_OWVAR 2
106405: PPUSH
106406: LD_INT 2
106408: PPUSH
106409: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106413: LD_INT 30
106415: PPUSH
106416: LD_OWVAR 2
106420: PPUSH
106421: LD_INT 2
106423: PPUSH
106424: CALL_OW 322
// end ;
106428: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106429: LD_EXP 99
106433: PUSH
106434: LD_EXP 151
106438: AND
106439: IFFALSE 106560
106441: GO 106443
106443: DISABLE
106444: LD_INT 0
106446: PPUSH
106447: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106448: LD_ADDR_VAR 0 2
106452: PUSH
106453: LD_INT 22
106455: PUSH
106456: LD_OWVAR 2
106460: PUSH
106461: EMPTY
106462: LIST
106463: LIST
106464: PUSH
106465: LD_INT 21
106467: PUSH
106468: LD_INT 1
106470: PUSH
106471: EMPTY
106472: LIST
106473: LIST
106474: PUSH
106475: LD_INT 3
106477: PUSH
106478: LD_INT 23
106480: PUSH
106481: LD_INT 0
106483: PUSH
106484: EMPTY
106485: LIST
106486: LIST
106487: PUSH
106488: EMPTY
106489: LIST
106490: LIST
106491: PUSH
106492: EMPTY
106493: LIST
106494: LIST
106495: LIST
106496: PPUSH
106497: CALL_OW 69
106501: ST_TO_ADDR
// if not tmp then
106502: LD_VAR 0 2
106506: NOT
106507: IFFALSE 106511
// exit ;
106509: GO 106560
// for i in tmp do
106511: LD_ADDR_VAR 0 1
106515: PUSH
106516: LD_VAR 0 2
106520: PUSH
106521: FOR_IN
106522: IFFALSE 106558
// begin if Crawls ( i ) then
106524: LD_VAR 0 1
106528: PPUSH
106529: CALL_OW 318
106533: IFFALSE 106544
// ComWalk ( i ) ;
106535: LD_VAR 0 1
106539: PPUSH
106540: CALL_OW 138
// SetClass ( i , 2 ) ;
106544: LD_VAR 0 1
106548: PPUSH
106549: LD_INT 2
106551: PPUSH
106552: CALL_OW 336
// end ;
106556: GO 106521
106558: POP
106559: POP
// end ;
106560: PPOPN 2
106562: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106563: LD_EXP 99
106567: PUSH
106568: LD_EXP 152
106572: AND
106573: IFFALSE 106861
106575: GO 106577
106577: DISABLE
106578: LD_INT 0
106580: PPUSH
106581: PPUSH
106582: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106583: LD_OWVAR 2
106587: PPUSH
106588: LD_INT 9
106590: PPUSH
106591: LD_INT 1
106593: PPUSH
106594: LD_INT 1
106596: PPUSH
106597: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106601: LD_INT 9
106603: PPUSH
106604: LD_OWVAR 2
106608: PPUSH
106609: CALL_OW 343
// uc_side := 9 ;
106613: LD_ADDR_OWVAR 20
106617: PUSH
106618: LD_INT 9
106620: ST_TO_ADDR
// uc_nation := 2 ;
106621: LD_ADDR_OWVAR 21
106625: PUSH
106626: LD_INT 2
106628: ST_TO_ADDR
// hc_name := Dark Warrior ;
106629: LD_ADDR_OWVAR 26
106633: PUSH
106634: LD_STRING Dark Warrior
106636: ST_TO_ADDR
// hc_gallery :=  ;
106637: LD_ADDR_OWVAR 33
106641: PUSH
106642: LD_STRING 
106644: ST_TO_ADDR
// hc_noskilllimit := true ;
106645: LD_ADDR_OWVAR 76
106649: PUSH
106650: LD_INT 1
106652: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106653: LD_ADDR_OWVAR 31
106657: PUSH
106658: LD_INT 30
106660: PUSH
106661: LD_INT 30
106663: PUSH
106664: LD_INT 30
106666: PUSH
106667: LD_INT 30
106669: PUSH
106670: EMPTY
106671: LIST
106672: LIST
106673: LIST
106674: LIST
106675: ST_TO_ADDR
// un := CreateHuman ;
106676: LD_ADDR_VAR 0 3
106680: PUSH
106681: CALL_OW 44
106685: ST_TO_ADDR
// hc_noskilllimit := false ;
106686: LD_ADDR_OWVAR 76
106690: PUSH
106691: LD_INT 0
106693: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106694: LD_VAR 0 3
106698: PPUSH
106699: LD_INT 1
106701: PPUSH
106702: CALL_OW 51
// ToLua ( playRanger() ) ;
106706: LD_STRING playRanger()
106708: PPUSH
106709: CALL_OW 559
// p := 0 ;
106713: LD_ADDR_VAR 0 2
106717: PUSH
106718: LD_INT 0
106720: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106721: LD_INT 35
106723: PPUSH
106724: CALL_OW 67
// p := p + 1 ;
106728: LD_ADDR_VAR 0 2
106732: PUSH
106733: LD_VAR 0 2
106737: PUSH
106738: LD_INT 1
106740: PLUS
106741: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106742: LD_VAR 0 3
106746: PPUSH
106747: CALL_OW 256
106751: PUSH
106752: LD_INT 1000
106754: LESS
106755: IFFALSE 106769
// SetLives ( un , 1000 ) ;
106757: LD_VAR 0 3
106761: PPUSH
106762: LD_INT 1000
106764: PPUSH
106765: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106769: LD_VAR 0 3
106773: PPUSH
106774: LD_INT 81
106776: PUSH
106777: LD_OWVAR 2
106781: PUSH
106782: EMPTY
106783: LIST
106784: LIST
106785: PUSH
106786: LD_INT 91
106788: PUSH
106789: LD_VAR 0 3
106793: PUSH
106794: LD_INT 30
106796: PUSH
106797: EMPTY
106798: LIST
106799: LIST
106800: LIST
106801: PUSH
106802: EMPTY
106803: LIST
106804: LIST
106805: PPUSH
106806: CALL_OW 69
106810: PPUSH
106811: LD_VAR 0 3
106815: PPUSH
106816: CALL_OW 74
106820: PPUSH
106821: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106825: LD_VAR 0 2
106829: PUSH
106830: LD_INT 80
106832: GREATER
106833: PUSH
106834: LD_VAR 0 3
106838: PPUSH
106839: CALL_OW 301
106843: OR
106844: IFFALSE 106721
// if un then
106846: LD_VAR 0 3
106850: IFFALSE 106861
// RemoveUnit ( un ) ;
106852: LD_VAR 0 3
106856: PPUSH
106857: CALL_OW 64
// end ;
106861: PPOPN 3
106863: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106864: LD_EXP 153
106868: IFFALSE 106984
106870: GO 106872
106872: DISABLE
106873: LD_INT 0
106875: PPUSH
106876: PPUSH
106877: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106878: LD_ADDR_VAR 0 2
106882: PUSH
106883: LD_INT 81
106885: PUSH
106886: LD_OWVAR 2
106890: PUSH
106891: EMPTY
106892: LIST
106893: LIST
106894: PUSH
106895: LD_INT 21
106897: PUSH
106898: LD_INT 1
106900: PUSH
106901: EMPTY
106902: LIST
106903: LIST
106904: PUSH
106905: EMPTY
106906: LIST
106907: LIST
106908: PPUSH
106909: CALL_OW 69
106913: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106914: LD_STRING playComputer()
106916: PPUSH
106917: CALL_OW 559
// if not tmp then
106921: LD_VAR 0 2
106925: NOT
106926: IFFALSE 106930
// exit ;
106928: GO 106984
// for i in tmp do
106930: LD_ADDR_VAR 0 1
106934: PUSH
106935: LD_VAR 0 2
106939: PUSH
106940: FOR_IN
106941: IFFALSE 106982
// for j := 1 to 4 do
106943: LD_ADDR_VAR 0 3
106947: PUSH
106948: DOUBLE
106949: LD_INT 1
106951: DEC
106952: ST_TO_ADDR
106953: LD_INT 4
106955: PUSH
106956: FOR_TO
106957: IFFALSE 106978
// SetSkill ( i , j , 10 ) ;
106959: LD_VAR 0 1
106963: PPUSH
106964: LD_VAR 0 3
106968: PPUSH
106969: LD_INT 10
106971: PPUSH
106972: CALL_OW 237
106976: GO 106956
106978: POP
106979: POP
106980: GO 106940
106982: POP
106983: POP
// end ;
106984: PPOPN 3
106986: END
// every 0 0$1 trigger s30 do var i , tmp ;
106987: LD_EXP 154
106991: IFFALSE 107060
106993: GO 106995
106995: DISABLE
106996: LD_INT 0
106998: PPUSH
106999: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107000: LD_ADDR_VAR 0 2
107004: PUSH
107005: LD_INT 22
107007: PUSH
107008: LD_OWVAR 2
107012: PUSH
107013: EMPTY
107014: LIST
107015: LIST
107016: PPUSH
107017: CALL_OW 69
107021: ST_TO_ADDR
// if not tmp then
107022: LD_VAR 0 2
107026: NOT
107027: IFFALSE 107031
// exit ;
107029: GO 107060
// for i in tmp do
107031: LD_ADDR_VAR 0 1
107035: PUSH
107036: LD_VAR 0 2
107040: PUSH
107041: FOR_IN
107042: IFFALSE 107058
// SetLives ( i , 300 ) ;
107044: LD_VAR 0 1
107048: PPUSH
107049: LD_INT 300
107051: PPUSH
107052: CALL_OW 234
107056: GO 107041
107058: POP
107059: POP
// end ;
107060: PPOPN 2
107062: END
// every 0 0$1 trigger s60 do var i , tmp ;
107063: LD_EXP 155
107067: IFFALSE 107136
107069: GO 107071
107071: DISABLE
107072: LD_INT 0
107074: PPUSH
107075: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107076: LD_ADDR_VAR 0 2
107080: PUSH
107081: LD_INT 22
107083: PUSH
107084: LD_OWVAR 2
107088: PUSH
107089: EMPTY
107090: LIST
107091: LIST
107092: PPUSH
107093: CALL_OW 69
107097: ST_TO_ADDR
// if not tmp then
107098: LD_VAR 0 2
107102: NOT
107103: IFFALSE 107107
// exit ;
107105: GO 107136
// for i in tmp do
107107: LD_ADDR_VAR 0 1
107111: PUSH
107112: LD_VAR 0 2
107116: PUSH
107117: FOR_IN
107118: IFFALSE 107134
// SetLives ( i , 600 ) ;
107120: LD_VAR 0 1
107124: PPUSH
107125: LD_INT 600
107127: PPUSH
107128: CALL_OW 234
107132: GO 107117
107134: POP
107135: POP
// end ;
107136: PPOPN 2
107138: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107139: LD_INT 0
107141: PPUSH
// case cmd of 301 :
107142: LD_VAR 0 1
107146: PUSH
107147: LD_INT 301
107149: DOUBLE
107150: EQUAL
107151: IFTRUE 107155
107153: GO 107187
107155: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107156: LD_VAR 0 6
107160: PPUSH
107161: LD_VAR 0 7
107165: PPUSH
107166: LD_VAR 0 8
107170: PPUSH
107171: LD_VAR 0 4
107175: PPUSH
107176: LD_VAR 0 5
107180: PPUSH
107181: CALL 108396 0 5
107185: GO 107308
107187: LD_INT 302
107189: DOUBLE
107190: EQUAL
107191: IFTRUE 107195
107193: GO 107232
107195: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107196: LD_VAR 0 6
107200: PPUSH
107201: LD_VAR 0 7
107205: PPUSH
107206: LD_VAR 0 8
107210: PPUSH
107211: LD_VAR 0 9
107215: PPUSH
107216: LD_VAR 0 4
107220: PPUSH
107221: LD_VAR 0 5
107225: PPUSH
107226: CALL 108487 0 6
107230: GO 107308
107232: LD_INT 303
107234: DOUBLE
107235: EQUAL
107236: IFTRUE 107240
107238: GO 107277
107240: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107241: LD_VAR 0 6
107245: PPUSH
107246: LD_VAR 0 7
107250: PPUSH
107251: LD_VAR 0 8
107255: PPUSH
107256: LD_VAR 0 9
107260: PPUSH
107261: LD_VAR 0 4
107265: PPUSH
107266: LD_VAR 0 5
107270: PPUSH
107271: CALL 107313 0 6
107275: GO 107308
107277: LD_INT 304
107279: DOUBLE
107280: EQUAL
107281: IFTRUE 107285
107283: GO 107307
107285: POP
// hHackTeleport ( unit , x , y ) ; end ;
107286: LD_VAR 0 2
107290: PPUSH
107291: LD_VAR 0 4
107295: PPUSH
107296: LD_VAR 0 5
107300: PPUSH
107301: CALL 109080 0 3
107305: GO 107308
107307: POP
// end ;
107308: LD_VAR 0 12
107312: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107313: LD_INT 0
107315: PPUSH
107316: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107317: LD_VAR 0 1
107321: PUSH
107322: LD_INT 1
107324: LESS
107325: PUSH
107326: LD_VAR 0 1
107330: PUSH
107331: LD_INT 3
107333: GREATER
107334: OR
107335: PUSH
107336: LD_VAR 0 5
107340: PPUSH
107341: LD_VAR 0 6
107345: PPUSH
107346: CALL_OW 428
107350: OR
107351: IFFALSE 107355
// exit ;
107353: GO 108083
// uc_side := your_side ;
107355: LD_ADDR_OWVAR 20
107359: PUSH
107360: LD_OWVAR 2
107364: ST_TO_ADDR
// uc_nation := nation ;
107365: LD_ADDR_OWVAR 21
107369: PUSH
107370: LD_VAR 0 1
107374: ST_TO_ADDR
// bc_level = 1 ;
107375: LD_ADDR_OWVAR 43
107379: PUSH
107380: LD_INT 1
107382: ST_TO_ADDR
// case btype of 1 :
107383: LD_VAR 0 2
107387: PUSH
107388: LD_INT 1
107390: DOUBLE
107391: EQUAL
107392: IFTRUE 107396
107394: GO 107407
107396: POP
// bc_type := b_depot ; 2 :
107397: LD_ADDR_OWVAR 42
107401: PUSH
107402: LD_INT 0
107404: ST_TO_ADDR
107405: GO 108027
107407: LD_INT 2
107409: DOUBLE
107410: EQUAL
107411: IFTRUE 107415
107413: GO 107426
107415: POP
// bc_type := b_warehouse ; 3 :
107416: LD_ADDR_OWVAR 42
107420: PUSH
107421: LD_INT 1
107423: ST_TO_ADDR
107424: GO 108027
107426: LD_INT 3
107428: DOUBLE
107429: EQUAL
107430: IFTRUE 107434
107432: GO 107445
107434: POP
// bc_type := b_lab ; 4 .. 9 :
107435: LD_ADDR_OWVAR 42
107439: PUSH
107440: LD_INT 6
107442: ST_TO_ADDR
107443: GO 108027
107445: LD_INT 4
107447: DOUBLE
107448: GREATEREQUAL
107449: IFFALSE 107457
107451: LD_INT 9
107453: DOUBLE
107454: LESSEQUAL
107455: IFTRUE 107459
107457: GO 107519
107459: POP
// begin bc_type := b_lab_half ;
107460: LD_ADDR_OWVAR 42
107464: PUSH
107465: LD_INT 7
107467: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107468: LD_ADDR_OWVAR 44
107472: PUSH
107473: LD_INT 10
107475: PUSH
107476: LD_INT 11
107478: PUSH
107479: LD_INT 12
107481: PUSH
107482: LD_INT 15
107484: PUSH
107485: LD_INT 14
107487: PUSH
107488: LD_INT 13
107490: PUSH
107491: EMPTY
107492: LIST
107493: LIST
107494: LIST
107495: LIST
107496: LIST
107497: LIST
107498: PUSH
107499: LD_VAR 0 2
107503: PUSH
107504: LD_INT 3
107506: MINUS
107507: ARRAY
107508: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
107509: LD_ADDR_OWVAR 45
107513: PUSH
107514: LD_INT 9
107516: ST_TO_ADDR
// end ; 10 .. 13 :
107517: GO 108027
107519: LD_INT 10
107521: DOUBLE
107522: GREATEREQUAL
107523: IFFALSE 107531
107525: LD_INT 13
107527: DOUBLE
107528: LESSEQUAL
107529: IFTRUE 107533
107531: GO 107610
107533: POP
// begin bc_type := b_lab_full ;
107534: LD_ADDR_OWVAR 42
107538: PUSH
107539: LD_INT 8
107541: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107542: LD_ADDR_OWVAR 44
107546: PUSH
107547: LD_INT 10
107549: PUSH
107550: LD_INT 12
107552: PUSH
107553: LD_INT 14
107555: PUSH
107556: LD_INT 13
107558: PUSH
107559: EMPTY
107560: LIST
107561: LIST
107562: LIST
107563: LIST
107564: PUSH
107565: LD_VAR 0 2
107569: PUSH
107570: LD_INT 9
107572: MINUS
107573: ARRAY
107574: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107575: LD_ADDR_OWVAR 45
107579: PUSH
107580: LD_INT 11
107582: PUSH
107583: LD_INT 15
107585: PUSH
107586: LD_INT 12
107588: PUSH
107589: LD_INT 15
107591: PUSH
107592: EMPTY
107593: LIST
107594: LIST
107595: LIST
107596: LIST
107597: PUSH
107598: LD_VAR 0 2
107602: PUSH
107603: LD_INT 9
107605: MINUS
107606: ARRAY
107607: ST_TO_ADDR
// end ; 14 :
107608: GO 108027
107610: LD_INT 14
107612: DOUBLE
107613: EQUAL
107614: IFTRUE 107618
107616: GO 107629
107618: POP
// bc_type := b_workshop ; 15 :
107619: LD_ADDR_OWVAR 42
107623: PUSH
107624: LD_INT 2
107626: ST_TO_ADDR
107627: GO 108027
107629: LD_INT 15
107631: DOUBLE
107632: EQUAL
107633: IFTRUE 107637
107635: GO 107648
107637: POP
// bc_type := b_factory ; 16 :
107638: LD_ADDR_OWVAR 42
107642: PUSH
107643: LD_INT 3
107645: ST_TO_ADDR
107646: GO 108027
107648: LD_INT 16
107650: DOUBLE
107651: EQUAL
107652: IFTRUE 107656
107654: GO 107667
107656: POP
// bc_type := b_ext_gun ; 17 :
107657: LD_ADDR_OWVAR 42
107661: PUSH
107662: LD_INT 17
107664: ST_TO_ADDR
107665: GO 108027
107667: LD_INT 17
107669: DOUBLE
107670: EQUAL
107671: IFTRUE 107675
107673: GO 107703
107675: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107676: LD_ADDR_OWVAR 42
107680: PUSH
107681: LD_INT 19
107683: PUSH
107684: LD_INT 23
107686: PUSH
107687: LD_INT 19
107689: PUSH
107690: EMPTY
107691: LIST
107692: LIST
107693: LIST
107694: PUSH
107695: LD_VAR 0 1
107699: ARRAY
107700: ST_TO_ADDR
107701: GO 108027
107703: LD_INT 18
107705: DOUBLE
107706: EQUAL
107707: IFTRUE 107711
107709: GO 107722
107711: POP
// bc_type := b_ext_radar ; 19 :
107712: LD_ADDR_OWVAR 42
107716: PUSH
107717: LD_INT 20
107719: ST_TO_ADDR
107720: GO 108027
107722: LD_INT 19
107724: DOUBLE
107725: EQUAL
107726: IFTRUE 107730
107728: GO 107741
107730: POP
// bc_type := b_ext_radio ; 20 :
107731: LD_ADDR_OWVAR 42
107735: PUSH
107736: LD_INT 22
107738: ST_TO_ADDR
107739: GO 108027
107741: LD_INT 20
107743: DOUBLE
107744: EQUAL
107745: IFTRUE 107749
107747: GO 107760
107749: POP
// bc_type := b_ext_siberium ; 21 :
107750: LD_ADDR_OWVAR 42
107754: PUSH
107755: LD_INT 21
107757: ST_TO_ADDR
107758: GO 108027
107760: LD_INT 21
107762: DOUBLE
107763: EQUAL
107764: IFTRUE 107768
107766: GO 107779
107768: POP
// bc_type := b_ext_computer ; 22 :
107769: LD_ADDR_OWVAR 42
107773: PUSH
107774: LD_INT 24
107776: ST_TO_ADDR
107777: GO 108027
107779: LD_INT 22
107781: DOUBLE
107782: EQUAL
107783: IFTRUE 107787
107785: GO 107798
107787: POP
// bc_type := b_ext_track ; 23 :
107788: LD_ADDR_OWVAR 42
107792: PUSH
107793: LD_INT 16
107795: ST_TO_ADDR
107796: GO 108027
107798: LD_INT 23
107800: DOUBLE
107801: EQUAL
107802: IFTRUE 107806
107804: GO 107817
107806: POP
// bc_type := b_ext_laser ; 24 :
107807: LD_ADDR_OWVAR 42
107811: PUSH
107812: LD_INT 25
107814: ST_TO_ADDR
107815: GO 108027
107817: LD_INT 24
107819: DOUBLE
107820: EQUAL
107821: IFTRUE 107825
107823: GO 107836
107825: POP
// bc_type := b_control_tower ; 25 :
107826: LD_ADDR_OWVAR 42
107830: PUSH
107831: LD_INT 36
107833: ST_TO_ADDR
107834: GO 108027
107836: LD_INT 25
107838: DOUBLE
107839: EQUAL
107840: IFTRUE 107844
107842: GO 107855
107844: POP
// bc_type := b_breastwork ; 26 :
107845: LD_ADDR_OWVAR 42
107849: PUSH
107850: LD_INT 31
107852: ST_TO_ADDR
107853: GO 108027
107855: LD_INT 26
107857: DOUBLE
107858: EQUAL
107859: IFTRUE 107863
107861: GO 107874
107863: POP
// bc_type := b_bunker ; 27 :
107864: LD_ADDR_OWVAR 42
107868: PUSH
107869: LD_INT 32
107871: ST_TO_ADDR
107872: GO 108027
107874: LD_INT 27
107876: DOUBLE
107877: EQUAL
107878: IFTRUE 107882
107880: GO 107893
107882: POP
// bc_type := b_turret ; 28 :
107883: LD_ADDR_OWVAR 42
107887: PUSH
107888: LD_INT 33
107890: ST_TO_ADDR
107891: GO 108027
107893: LD_INT 28
107895: DOUBLE
107896: EQUAL
107897: IFTRUE 107901
107899: GO 107912
107901: POP
// bc_type := b_armoury ; 29 :
107902: LD_ADDR_OWVAR 42
107906: PUSH
107907: LD_INT 4
107909: ST_TO_ADDR
107910: GO 108027
107912: LD_INT 29
107914: DOUBLE
107915: EQUAL
107916: IFTRUE 107920
107918: GO 107931
107920: POP
// bc_type := b_barracks ; 30 :
107921: LD_ADDR_OWVAR 42
107925: PUSH
107926: LD_INT 5
107928: ST_TO_ADDR
107929: GO 108027
107931: LD_INT 30
107933: DOUBLE
107934: EQUAL
107935: IFTRUE 107939
107937: GO 107950
107939: POP
// bc_type := b_solar_power ; 31 :
107940: LD_ADDR_OWVAR 42
107944: PUSH
107945: LD_INT 27
107947: ST_TO_ADDR
107948: GO 108027
107950: LD_INT 31
107952: DOUBLE
107953: EQUAL
107954: IFTRUE 107958
107956: GO 107969
107958: POP
// bc_type := b_oil_power ; 32 :
107959: LD_ADDR_OWVAR 42
107963: PUSH
107964: LD_INT 26
107966: ST_TO_ADDR
107967: GO 108027
107969: LD_INT 32
107971: DOUBLE
107972: EQUAL
107973: IFTRUE 107977
107975: GO 107988
107977: POP
// bc_type := b_siberite_power ; 33 :
107978: LD_ADDR_OWVAR 42
107982: PUSH
107983: LD_INT 28
107985: ST_TO_ADDR
107986: GO 108027
107988: LD_INT 33
107990: DOUBLE
107991: EQUAL
107992: IFTRUE 107996
107994: GO 108007
107996: POP
// bc_type := b_oil_mine ; 34 :
107997: LD_ADDR_OWVAR 42
108001: PUSH
108002: LD_INT 29
108004: ST_TO_ADDR
108005: GO 108027
108007: LD_INT 34
108009: DOUBLE
108010: EQUAL
108011: IFTRUE 108015
108013: GO 108026
108015: POP
// bc_type := b_siberite_mine ; end ;
108016: LD_ADDR_OWVAR 42
108020: PUSH
108021: LD_INT 30
108023: ST_TO_ADDR
108024: GO 108027
108026: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108027: LD_ADDR_VAR 0 8
108031: PUSH
108032: LD_VAR 0 5
108036: PPUSH
108037: LD_VAR 0 6
108041: PPUSH
108042: LD_VAR 0 3
108046: PPUSH
108047: CALL_OW 47
108051: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108052: LD_OWVAR 42
108056: PUSH
108057: LD_INT 32
108059: PUSH
108060: LD_INT 33
108062: PUSH
108063: EMPTY
108064: LIST
108065: LIST
108066: IN
108067: IFFALSE 108083
// PlaceWeaponTurret ( b , weapon ) ;
108069: LD_VAR 0 8
108073: PPUSH
108074: LD_VAR 0 4
108078: PPUSH
108079: CALL_OW 431
// end ;
108083: LD_VAR 0 7
108087: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108088: LD_INT 0
108090: PPUSH
108091: PPUSH
108092: PPUSH
108093: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108094: LD_ADDR_VAR 0 4
108098: PUSH
108099: LD_INT 22
108101: PUSH
108102: LD_OWVAR 2
108106: PUSH
108107: EMPTY
108108: LIST
108109: LIST
108110: PUSH
108111: LD_INT 2
108113: PUSH
108114: LD_INT 30
108116: PUSH
108117: LD_INT 0
108119: PUSH
108120: EMPTY
108121: LIST
108122: LIST
108123: PUSH
108124: LD_INT 30
108126: PUSH
108127: LD_INT 1
108129: PUSH
108130: EMPTY
108131: LIST
108132: LIST
108133: PUSH
108134: EMPTY
108135: LIST
108136: LIST
108137: LIST
108138: PUSH
108139: EMPTY
108140: LIST
108141: LIST
108142: PPUSH
108143: CALL_OW 69
108147: ST_TO_ADDR
// if not tmp then
108148: LD_VAR 0 4
108152: NOT
108153: IFFALSE 108157
// exit ;
108155: GO 108216
// for i in tmp do
108157: LD_ADDR_VAR 0 2
108161: PUSH
108162: LD_VAR 0 4
108166: PUSH
108167: FOR_IN
108168: IFFALSE 108214
// for j = 1 to 3 do
108170: LD_ADDR_VAR 0 3
108174: PUSH
108175: DOUBLE
108176: LD_INT 1
108178: DEC
108179: ST_TO_ADDR
108180: LD_INT 3
108182: PUSH
108183: FOR_TO
108184: IFFALSE 108210
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108186: LD_VAR 0 2
108190: PPUSH
108191: CALL_OW 274
108195: PPUSH
108196: LD_VAR 0 3
108200: PPUSH
108201: LD_INT 99999
108203: PPUSH
108204: CALL_OW 277
108208: GO 108183
108210: POP
108211: POP
108212: GO 108167
108214: POP
108215: POP
// end ;
108216: LD_VAR 0 1
108220: RET
// export function hHackSetLevel10 ; var i , j ; begin
108221: LD_INT 0
108223: PPUSH
108224: PPUSH
108225: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108226: LD_ADDR_VAR 0 2
108230: PUSH
108231: LD_INT 21
108233: PUSH
108234: LD_INT 1
108236: PUSH
108237: EMPTY
108238: LIST
108239: LIST
108240: PPUSH
108241: CALL_OW 69
108245: PUSH
108246: FOR_IN
108247: IFFALSE 108299
// if IsSelected ( i ) then
108249: LD_VAR 0 2
108253: PPUSH
108254: CALL_OW 306
108258: IFFALSE 108297
// begin for j := 1 to 4 do
108260: LD_ADDR_VAR 0 3
108264: PUSH
108265: DOUBLE
108266: LD_INT 1
108268: DEC
108269: ST_TO_ADDR
108270: LD_INT 4
108272: PUSH
108273: FOR_TO
108274: IFFALSE 108295
// SetSkill ( i , j , 10 ) ;
108276: LD_VAR 0 2
108280: PPUSH
108281: LD_VAR 0 3
108285: PPUSH
108286: LD_INT 10
108288: PPUSH
108289: CALL_OW 237
108293: GO 108273
108295: POP
108296: POP
// end ;
108297: GO 108246
108299: POP
108300: POP
// end ;
108301: LD_VAR 0 1
108305: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108306: LD_INT 0
108308: PPUSH
108309: PPUSH
108310: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108311: LD_ADDR_VAR 0 2
108315: PUSH
108316: LD_INT 22
108318: PUSH
108319: LD_OWVAR 2
108323: PUSH
108324: EMPTY
108325: LIST
108326: LIST
108327: PUSH
108328: LD_INT 21
108330: PUSH
108331: LD_INT 1
108333: PUSH
108334: EMPTY
108335: LIST
108336: LIST
108337: PUSH
108338: EMPTY
108339: LIST
108340: LIST
108341: PPUSH
108342: CALL_OW 69
108346: PUSH
108347: FOR_IN
108348: IFFALSE 108389
// begin for j := 1 to 4 do
108350: LD_ADDR_VAR 0 3
108354: PUSH
108355: DOUBLE
108356: LD_INT 1
108358: DEC
108359: ST_TO_ADDR
108360: LD_INT 4
108362: PUSH
108363: FOR_TO
108364: IFFALSE 108385
// SetSkill ( i , j , 10 ) ;
108366: LD_VAR 0 2
108370: PPUSH
108371: LD_VAR 0 3
108375: PPUSH
108376: LD_INT 10
108378: PPUSH
108379: CALL_OW 237
108383: GO 108363
108385: POP
108386: POP
// end ;
108387: GO 108347
108389: POP
108390: POP
// end ;
108391: LD_VAR 0 1
108395: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108396: LD_INT 0
108398: PPUSH
// uc_side := your_side ;
108399: LD_ADDR_OWVAR 20
108403: PUSH
108404: LD_OWVAR 2
108408: ST_TO_ADDR
// uc_nation := nation ;
108409: LD_ADDR_OWVAR 21
108413: PUSH
108414: LD_VAR 0 1
108418: ST_TO_ADDR
// InitHc ;
108419: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108423: LD_INT 0
108425: PPUSH
108426: LD_VAR 0 2
108430: PPUSH
108431: LD_VAR 0 3
108435: PPUSH
108436: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108440: LD_VAR 0 4
108444: PPUSH
108445: LD_VAR 0 5
108449: PPUSH
108450: CALL_OW 428
108454: PUSH
108455: LD_INT 0
108457: EQUAL
108458: IFFALSE 108482
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108460: CALL_OW 44
108464: PPUSH
108465: LD_VAR 0 4
108469: PPUSH
108470: LD_VAR 0 5
108474: PPUSH
108475: LD_INT 1
108477: PPUSH
108478: CALL_OW 48
// end ;
108482: LD_VAR 0 6
108486: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108487: LD_INT 0
108489: PPUSH
108490: PPUSH
// uc_side := your_side ;
108491: LD_ADDR_OWVAR 20
108495: PUSH
108496: LD_OWVAR 2
108500: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108501: LD_VAR 0 1
108505: PUSH
108506: LD_INT 1
108508: PUSH
108509: LD_INT 2
108511: PUSH
108512: LD_INT 3
108514: PUSH
108515: LD_INT 4
108517: PUSH
108518: LD_INT 5
108520: PUSH
108521: EMPTY
108522: LIST
108523: LIST
108524: LIST
108525: LIST
108526: LIST
108527: IN
108528: IFFALSE 108540
// uc_nation := nation_american else
108530: LD_ADDR_OWVAR 21
108534: PUSH
108535: LD_INT 1
108537: ST_TO_ADDR
108538: GO 108583
// if chassis in [ 11 , 12 , 13 , 14 ] then
108540: LD_VAR 0 1
108544: PUSH
108545: LD_INT 11
108547: PUSH
108548: LD_INT 12
108550: PUSH
108551: LD_INT 13
108553: PUSH
108554: LD_INT 14
108556: PUSH
108557: EMPTY
108558: LIST
108559: LIST
108560: LIST
108561: LIST
108562: IN
108563: IFFALSE 108575
// uc_nation := nation_arabian else
108565: LD_ADDR_OWVAR 21
108569: PUSH
108570: LD_INT 2
108572: ST_TO_ADDR
108573: GO 108583
// uc_nation := nation_russian ;
108575: LD_ADDR_OWVAR 21
108579: PUSH
108580: LD_INT 3
108582: ST_TO_ADDR
// vc_chassis := chassis ;
108583: LD_ADDR_OWVAR 37
108587: PUSH
108588: LD_VAR 0 1
108592: ST_TO_ADDR
// vc_engine := engine ;
108593: LD_ADDR_OWVAR 39
108597: PUSH
108598: LD_VAR 0 2
108602: ST_TO_ADDR
// vc_control := control ;
108603: LD_ADDR_OWVAR 38
108607: PUSH
108608: LD_VAR 0 3
108612: ST_TO_ADDR
// vc_weapon := weapon ;
108613: LD_ADDR_OWVAR 40
108617: PUSH
108618: LD_VAR 0 4
108622: ST_TO_ADDR
// un := CreateVehicle ;
108623: LD_ADDR_VAR 0 8
108627: PUSH
108628: CALL_OW 45
108632: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108633: LD_VAR 0 8
108637: PPUSH
108638: LD_INT 0
108640: PPUSH
108641: LD_INT 5
108643: PPUSH
108644: CALL_OW 12
108648: PPUSH
108649: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108653: LD_VAR 0 8
108657: PPUSH
108658: LD_VAR 0 5
108662: PPUSH
108663: LD_VAR 0 6
108667: PPUSH
108668: LD_INT 1
108670: PPUSH
108671: CALL_OW 48
// end ;
108675: LD_VAR 0 7
108679: RET
// export hInvincible ; every 1 do
108680: GO 108682
108682: DISABLE
// hInvincible := [ ] ;
108683: LD_ADDR_EXP 156
108687: PUSH
108688: EMPTY
108689: ST_TO_ADDR
108690: END
// every 10 do var i ;
108691: GO 108693
108693: DISABLE
108694: LD_INT 0
108696: PPUSH
// begin enable ;
108697: ENABLE
// if not hInvincible then
108698: LD_EXP 156
108702: NOT
108703: IFFALSE 108707
// exit ;
108705: GO 108751
// for i in hInvincible do
108707: LD_ADDR_VAR 0 1
108711: PUSH
108712: LD_EXP 156
108716: PUSH
108717: FOR_IN
108718: IFFALSE 108749
// if GetLives ( i ) < 1000 then
108720: LD_VAR 0 1
108724: PPUSH
108725: CALL_OW 256
108729: PUSH
108730: LD_INT 1000
108732: LESS
108733: IFFALSE 108747
// SetLives ( i , 1000 ) ;
108735: LD_VAR 0 1
108739: PPUSH
108740: LD_INT 1000
108742: PPUSH
108743: CALL_OW 234
108747: GO 108717
108749: POP
108750: POP
// end ;
108751: PPOPN 1
108753: END
// export function hHackInvincible ; var i ; begin
108754: LD_INT 0
108756: PPUSH
108757: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108758: LD_ADDR_VAR 0 2
108762: PUSH
108763: LD_INT 2
108765: PUSH
108766: LD_INT 21
108768: PUSH
108769: LD_INT 1
108771: PUSH
108772: EMPTY
108773: LIST
108774: LIST
108775: PUSH
108776: LD_INT 21
108778: PUSH
108779: LD_INT 2
108781: PUSH
108782: EMPTY
108783: LIST
108784: LIST
108785: PUSH
108786: EMPTY
108787: LIST
108788: LIST
108789: LIST
108790: PPUSH
108791: CALL_OW 69
108795: PUSH
108796: FOR_IN
108797: IFFALSE 108858
// if IsSelected ( i ) then
108799: LD_VAR 0 2
108803: PPUSH
108804: CALL_OW 306
108808: IFFALSE 108856
// begin if i in hInvincible then
108810: LD_VAR 0 2
108814: PUSH
108815: LD_EXP 156
108819: IN
108820: IFFALSE 108840
// hInvincible := hInvincible diff i else
108822: LD_ADDR_EXP 156
108826: PUSH
108827: LD_EXP 156
108831: PUSH
108832: LD_VAR 0 2
108836: DIFF
108837: ST_TO_ADDR
108838: GO 108856
// hInvincible := hInvincible union i ;
108840: LD_ADDR_EXP 156
108844: PUSH
108845: LD_EXP 156
108849: PUSH
108850: LD_VAR 0 2
108854: UNION
108855: ST_TO_ADDR
// end ;
108856: GO 108796
108858: POP
108859: POP
// end ;
108860: LD_VAR 0 1
108864: RET
// export function hHackInvisible ; var i , j ; begin
108865: LD_INT 0
108867: PPUSH
108868: PPUSH
108869: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108870: LD_ADDR_VAR 0 2
108874: PUSH
108875: LD_INT 21
108877: PUSH
108878: LD_INT 1
108880: PUSH
108881: EMPTY
108882: LIST
108883: LIST
108884: PPUSH
108885: CALL_OW 69
108889: PUSH
108890: FOR_IN
108891: IFFALSE 108915
// if IsSelected ( i ) then
108893: LD_VAR 0 2
108897: PPUSH
108898: CALL_OW 306
108902: IFFALSE 108913
// ComForceInvisible ( i ) ;
108904: LD_VAR 0 2
108908: PPUSH
108909: CALL_OW 496
108913: GO 108890
108915: POP
108916: POP
// end ;
108917: LD_VAR 0 1
108921: RET
// export function hHackChangeYourSide ; begin
108922: LD_INT 0
108924: PPUSH
// if your_side = 8 then
108925: LD_OWVAR 2
108929: PUSH
108930: LD_INT 8
108932: EQUAL
108933: IFFALSE 108945
// your_side := 0 else
108935: LD_ADDR_OWVAR 2
108939: PUSH
108940: LD_INT 0
108942: ST_TO_ADDR
108943: GO 108959
// your_side := your_side + 1 ;
108945: LD_ADDR_OWVAR 2
108949: PUSH
108950: LD_OWVAR 2
108954: PUSH
108955: LD_INT 1
108957: PLUS
108958: ST_TO_ADDR
// end ;
108959: LD_VAR 0 1
108963: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108964: LD_INT 0
108966: PPUSH
108967: PPUSH
108968: PPUSH
// for i in all_units do
108969: LD_ADDR_VAR 0 2
108973: PUSH
108974: LD_OWVAR 3
108978: PUSH
108979: FOR_IN
108980: IFFALSE 109058
// if IsSelected ( i ) then
108982: LD_VAR 0 2
108986: PPUSH
108987: CALL_OW 306
108991: IFFALSE 109056
// begin j := GetSide ( i ) ;
108993: LD_ADDR_VAR 0 3
108997: PUSH
108998: LD_VAR 0 2
109002: PPUSH
109003: CALL_OW 255
109007: ST_TO_ADDR
// if j = 8 then
109008: LD_VAR 0 3
109012: PUSH
109013: LD_INT 8
109015: EQUAL
109016: IFFALSE 109028
// j := 0 else
109018: LD_ADDR_VAR 0 3
109022: PUSH
109023: LD_INT 0
109025: ST_TO_ADDR
109026: GO 109042
// j := j + 1 ;
109028: LD_ADDR_VAR 0 3
109032: PUSH
109033: LD_VAR 0 3
109037: PUSH
109038: LD_INT 1
109040: PLUS
109041: ST_TO_ADDR
// SetSide ( i , j ) ;
109042: LD_VAR 0 2
109046: PPUSH
109047: LD_VAR 0 3
109051: PPUSH
109052: CALL_OW 235
// end ;
109056: GO 108979
109058: POP
109059: POP
// end ;
109060: LD_VAR 0 1
109064: RET
// export function hHackFog ; begin
109065: LD_INT 0
109067: PPUSH
// FogOff ( true ) ;
109068: LD_INT 1
109070: PPUSH
109071: CALL_OW 344
// end ;
109075: LD_VAR 0 1
109079: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109080: LD_INT 0
109082: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109083: LD_VAR 0 1
109087: PPUSH
109088: LD_VAR 0 2
109092: PPUSH
109093: LD_VAR 0 3
109097: PPUSH
109098: LD_INT 1
109100: PPUSH
109101: LD_INT 1
109103: PPUSH
109104: CALL_OW 483
// CenterOnXY ( x , y ) ;
109108: LD_VAR 0 2
109112: PPUSH
109113: LD_VAR 0 3
109117: PPUSH
109118: CALL_OW 84
// end ;
109122: LD_VAR 0 4
109126: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109127: LD_INT 0
109129: PPUSH
109130: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109131: LD_VAR 0 1
109135: NOT
109136: PUSH
109137: LD_VAR 0 2
109141: PPUSH
109142: LD_VAR 0 3
109146: PPUSH
109147: CALL_OW 488
109151: NOT
109152: OR
109153: PUSH
109154: LD_VAR 0 1
109158: PPUSH
109159: CALL_OW 266
109163: PUSH
109164: LD_INT 3
109166: NONEQUAL
109167: PUSH
109168: LD_VAR 0 1
109172: PPUSH
109173: CALL_OW 247
109177: PUSH
109178: LD_INT 1
109180: EQUAL
109181: NOT
109182: AND
109183: OR
109184: IFFALSE 109188
// exit ;
109186: GO 109337
// if GetType ( factory ) = unit_human then
109188: LD_VAR 0 1
109192: PPUSH
109193: CALL_OW 247
109197: PUSH
109198: LD_INT 1
109200: EQUAL
109201: IFFALSE 109218
// factory := IsInUnit ( factory ) ;
109203: LD_ADDR_VAR 0 1
109207: PUSH
109208: LD_VAR 0 1
109212: PPUSH
109213: CALL_OW 310
109217: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109218: LD_VAR 0 1
109222: PPUSH
109223: CALL_OW 266
109227: PUSH
109228: LD_INT 3
109230: NONEQUAL
109231: IFFALSE 109235
// exit ;
109233: GO 109337
// if HexInfo ( x , y ) = factory then
109235: LD_VAR 0 2
109239: PPUSH
109240: LD_VAR 0 3
109244: PPUSH
109245: CALL_OW 428
109249: PUSH
109250: LD_VAR 0 1
109254: EQUAL
109255: IFFALSE 109282
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109257: LD_ADDR_EXP 157
109261: PUSH
109262: LD_EXP 157
109266: PPUSH
109267: LD_VAR 0 1
109271: PPUSH
109272: LD_INT 0
109274: PPUSH
109275: CALL_OW 1
109279: ST_TO_ADDR
109280: GO 109333
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109282: LD_ADDR_EXP 157
109286: PUSH
109287: LD_EXP 157
109291: PPUSH
109292: LD_VAR 0 1
109296: PPUSH
109297: LD_VAR 0 1
109301: PPUSH
109302: CALL_OW 255
109306: PUSH
109307: LD_VAR 0 1
109311: PUSH
109312: LD_VAR 0 2
109316: PUSH
109317: LD_VAR 0 3
109321: PUSH
109322: EMPTY
109323: LIST
109324: LIST
109325: LIST
109326: LIST
109327: PPUSH
109328: CALL_OW 1
109332: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109333: CALL 109342 0 0
// end ;
109337: LD_VAR 0 4
109341: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109342: LD_INT 0
109344: PPUSH
109345: PPUSH
109346: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109347: LD_STRING resetFactoryWaypoint();
109349: PPUSH
109350: CALL_OW 559
// if factoryWaypoints then
109354: LD_EXP 157
109358: IFFALSE 109484
// begin list := PrepareArray ( factoryWaypoints ) ;
109360: LD_ADDR_VAR 0 3
109364: PUSH
109365: LD_EXP 157
109369: PPUSH
109370: CALL 51272 0 1
109374: ST_TO_ADDR
// for i := 1 to list do
109375: LD_ADDR_VAR 0 2
109379: PUSH
109380: DOUBLE
109381: LD_INT 1
109383: DEC
109384: ST_TO_ADDR
109385: LD_VAR 0 3
109389: PUSH
109390: FOR_TO
109391: IFFALSE 109482
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109393: LD_STRING setFactoryWaypointXY(
109395: PUSH
109396: LD_VAR 0 3
109400: PUSH
109401: LD_VAR 0 2
109405: ARRAY
109406: PUSH
109407: LD_INT 1
109409: ARRAY
109410: STR
109411: PUSH
109412: LD_STRING ,
109414: STR
109415: PUSH
109416: LD_VAR 0 3
109420: PUSH
109421: LD_VAR 0 2
109425: ARRAY
109426: PUSH
109427: LD_INT 2
109429: ARRAY
109430: STR
109431: PUSH
109432: LD_STRING ,
109434: STR
109435: PUSH
109436: LD_VAR 0 3
109440: PUSH
109441: LD_VAR 0 2
109445: ARRAY
109446: PUSH
109447: LD_INT 3
109449: ARRAY
109450: STR
109451: PUSH
109452: LD_STRING ,
109454: STR
109455: PUSH
109456: LD_VAR 0 3
109460: PUSH
109461: LD_VAR 0 2
109465: ARRAY
109466: PUSH
109467: LD_INT 4
109469: ARRAY
109470: STR
109471: PUSH
109472: LD_STRING )
109474: STR
109475: PPUSH
109476: CALL_OW 559
109480: GO 109390
109482: POP
109483: POP
// end ; end ;
109484: LD_VAR 0 1
109488: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109489: LD_INT 0
109491: PPUSH
// if HexInfo ( x , y ) = warehouse then
109492: LD_VAR 0 2
109496: PPUSH
109497: LD_VAR 0 3
109501: PPUSH
109502: CALL_OW 428
109506: PUSH
109507: LD_VAR 0 1
109511: EQUAL
109512: IFFALSE 109539
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109514: LD_ADDR_EXP 158
109518: PUSH
109519: LD_EXP 158
109523: PPUSH
109524: LD_VAR 0 1
109528: PPUSH
109529: LD_INT 0
109531: PPUSH
109532: CALL_OW 1
109536: ST_TO_ADDR
109537: GO 109590
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109539: LD_ADDR_EXP 158
109543: PUSH
109544: LD_EXP 158
109548: PPUSH
109549: LD_VAR 0 1
109553: PPUSH
109554: LD_VAR 0 1
109558: PPUSH
109559: CALL_OW 255
109563: PUSH
109564: LD_VAR 0 1
109568: PUSH
109569: LD_VAR 0 2
109573: PUSH
109574: LD_VAR 0 3
109578: PUSH
109579: EMPTY
109580: LIST
109581: LIST
109582: LIST
109583: LIST
109584: PPUSH
109585: CALL_OW 1
109589: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109590: CALL 109599 0 0
// end ;
109594: LD_VAR 0 4
109598: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109599: LD_INT 0
109601: PPUSH
109602: PPUSH
109603: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109604: LD_STRING resetWarehouseGatheringPoints();
109606: PPUSH
109607: CALL_OW 559
// if warehouseGatheringPoints then
109611: LD_EXP 158
109615: IFFALSE 109741
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109617: LD_ADDR_VAR 0 3
109621: PUSH
109622: LD_EXP 158
109626: PPUSH
109627: CALL 51272 0 1
109631: ST_TO_ADDR
// for i := 1 to list do
109632: LD_ADDR_VAR 0 2
109636: PUSH
109637: DOUBLE
109638: LD_INT 1
109640: DEC
109641: ST_TO_ADDR
109642: LD_VAR 0 3
109646: PUSH
109647: FOR_TO
109648: IFFALSE 109739
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109650: LD_STRING setWarehouseGatheringPointXY(
109652: PUSH
109653: LD_VAR 0 3
109657: PUSH
109658: LD_VAR 0 2
109662: ARRAY
109663: PUSH
109664: LD_INT 1
109666: ARRAY
109667: STR
109668: PUSH
109669: LD_STRING ,
109671: STR
109672: PUSH
109673: LD_VAR 0 3
109677: PUSH
109678: LD_VAR 0 2
109682: ARRAY
109683: PUSH
109684: LD_INT 2
109686: ARRAY
109687: STR
109688: PUSH
109689: LD_STRING ,
109691: STR
109692: PUSH
109693: LD_VAR 0 3
109697: PUSH
109698: LD_VAR 0 2
109702: ARRAY
109703: PUSH
109704: LD_INT 3
109706: ARRAY
109707: STR
109708: PUSH
109709: LD_STRING ,
109711: STR
109712: PUSH
109713: LD_VAR 0 3
109717: PUSH
109718: LD_VAR 0 2
109722: ARRAY
109723: PUSH
109724: LD_INT 4
109726: ARRAY
109727: STR
109728: PUSH
109729: LD_STRING )
109731: STR
109732: PPUSH
109733: CALL_OW 559
109737: GO 109647
109739: POP
109740: POP
// end ; end ;
109741: LD_VAR 0 1
109745: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109746: LD_EXP 158
109750: IFFALSE 110435
109752: GO 109754
109754: DISABLE
109755: LD_INT 0
109757: PPUSH
109758: PPUSH
109759: PPUSH
109760: PPUSH
109761: PPUSH
109762: PPUSH
109763: PPUSH
109764: PPUSH
109765: PPUSH
// begin enable ;
109766: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109767: LD_ADDR_VAR 0 3
109771: PUSH
109772: LD_EXP 158
109776: PPUSH
109777: CALL 51272 0 1
109781: ST_TO_ADDR
// if not list then
109782: LD_VAR 0 3
109786: NOT
109787: IFFALSE 109791
// exit ;
109789: GO 110435
// for i := 1 to list do
109791: LD_ADDR_VAR 0 1
109795: PUSH
109796: DOUBLE
109797: LD_INT 1
109799: DEC
109800: ST_TO_ADDR
109801: LD_VAR 0 3
109805: PUSH
109806: FOR_TO
109807: IFFALSE 110433
// begin depot := list [ i ] [ 2 ] ;
109809: LD_ADDR_VAR 0 8
109813: PUSH
109814: LD_VAR 0 3
109818: PUSH
109819: LD_VAR 0 1
109823: ARRAY
109824: PUSH
109825: LD_INT 2
109827: ARRAY
109828: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109829: LD_ADDR_VAR 0 5
109833: PUSH
109834: LD_VAR 0 3
109838: PUSH
109839: LD_VAR 0 1
109843: ARRAY
109844: PUSH
109845: LD_INT 1
109847: ARRAY
109848: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109849: LD_VAR 0 8
109853: PPUSH
109854: CALL_OW 301
109858: PUSH
109859: LD_VAR 0 5
109863: PUSH
109864: LD_VAR 0 8
109868: PPUSH
109869: CALL_OW 255
109873: NONEQUAL
109874: OR
109875: IFFALSE 109904
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109877: LD_ADDR_EXP 158
109881: PUSH
109882: LD_EXP 158
109886: PPUSH
109887: LD_VAR 0 8
109891: PPUSH
109892: LD_INT 0
109894: PPUSH
109895: CALL_OW 1
109899: ST_TO_ADDR
// exit ;
109900: POP
109901: POP
109902: GO 110435
// end ; x := list [ i ] [ 3 ] ;
109904: LD_ADDR_VAR 0 6
109908: PUSH
109909: LD_VAR 0 3
109913: PUSH
109914: LD_VAR 0 1
109918: ARRAY
109919: PUSH
109920: LD_INT 3
109922: ARRAY
109923: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109924: LD_ADDR_VAR 0 7
109928: PUSH
109929: LD_VAR 0 3
109933: PUSH
109934: LD_VAR 0 1
109938: ARRAY
109939: PUSH
109940: LD_INT 4
109942: ARRAY
109943: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109944: LD_ADDR_VAR 0 9
109948: PUSH
109949: LD_VAR 0 6
109953: PPUSH
109954: LD_VAR 0 7
109958: PPUSH
109959: LD_INT 16
109961: PPUSH
109962: CALL 49860 0 3
109966: ST_TO_ADDR
// if not cratesNearbyPoint then
109967: LD_VAR 0 9
109971: NOT
109972: IFFALSE 109978
// exit ;
109974: POP
109975: POP
109976: GO 110435
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109978: LD_ADDR_VAR 0 4
109982: PUSH
109983: LD_INT 22
109985: PUSH
109986: LD_VAR 0 5
109990: PUSH
109991: EMPTY
109992: LIST
109993: LIST
109994: PUSH
109995: LD_INT 3
109997: PUSH
109998: LD_INT 60
110000: PUSH
110001: EMPTY
110002: LIST
110003: PUSH
110004: EMPTY
110005: LIST
110006: LIST
110007: PUSH
110008: LD_INT 91
110010: PUSH
110011: LD_VAR 0 8
110015: PUSH
110016: LD_INT 6
110018: PUSH
110019: EMPTY
110020: LIST
110021: LIST
110022: LIST
110023: PUSH
110024: LD_INT 2
110026: PUSH
110027: LD_INT 25
110029: PUSH
110030: LD_INT 2
110032: PUSH
110033: EMPTY
110034: LIST
110035: LIST
110036: PUSH
110037: LD_INT 25
110039: PUSH
110040: LD_INT 16
110042: PUSH
110043: EMPTY
110044: LIST
110045: LIST
110046: PUSH
110047: EMPTY
110048: LIST
110049: LIST
110050: LIST
110051: PUSH
110052: EMPTY
110053: LIST
110054: LIST
110055: LIST
110056: LIST
110057: PPUSH
110058: CALL_OW 69
110062: PUSH
110063: LD_VAR 0 8
110067: PPUSH
110068: CALL_OW 313
110072: PPUSH
110073: LD_INT 3
110075: PUSH
110076: LD_INT 60
110078: PUSH
110079: EMPTY
110080: LIST
110081: PUSH
110082: EMPTY
110083: LIST
110084: LIST
110085: PUSH
110086: LD_INT 2
110088: PUSH
110089: LD_INT 25
110091: PUSH
110092: LD_INT 2
110094: PUSH
110095: EMPTY
110096: LIST
110097: LIST
110098: PUSH
110099: LD_INT 25
110101: PUSH
110102: LD_INT 16
110104: PUSH
110105: EMPTY
110106: LIST
110107: LIST
110108: PUSH
110109: EMPTY
110110: LIST
110111: LIST
110112: LIST
110113: PUSH
110114: EMPTY
110115: LIST
110116: LIST
110117: PPUSH
110118: CALL_OW 72
110122: UNION
110123: ST_TO_ADDR
// if tmp then
110124: LD_VAR 0 4
110128: IFFALSE 110208
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110130: LD_ADDR_VAR 0 4
110134: PUSH
110135: LD_VAR 0 4
110139: PPUSH
110140: LD_INT 3
110142: PPUSH
110143: CALL 47829 0 2
110147: ST_TO_ADDR
// for j in tmp do
110148: LD_ADDR_VAR 0 2
110152: PUSH
110153: LD_VAR 0 4
110157: PUSH
110158: FOR_IN
110159: IFFALSE 110202
// begin if IsInUnit ( j ) then
110161: LD_VAR 0 2
110165: PPUSH
110166: CALL_OW 310
110170: IFFALSE 110181
// ComExit ( j ) ;
110172: LD_VAR 0 2
110176: PPUSH
110177: CALL 47912 0 1
// AddComCollect ( j , x , y ) ;
110181: LD_VAR 0 2
110185: PPUSH
110186: LD_VAR 0 6
110190: PPUSH
110191: LD_VAR 0 7
110195: PPUSH
110196: CALL_OW 177
// end ;
110200: GO 110158
110202: POP
110203: POP
// exit ;
110204: POP
110205: POP
110206: GO 110435
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110208: LD_ADDR_VAR 0 4
110212: PUSH
110213: LD_INT 22
110215: PUSH
110216: LD_VAR 0 5
110220: PUSH
110221: EMPTY
110222: LIST
110223: LIST
110224: PUSH
110225: LD_INT 91
110227: PUSH
110228: LD_VAR 0 8
110232: PUSH
110233: LD_INT 8
110235: PUSH
110236: EMPTY
110237: LIST
110238: LIST
110239: LIST
110240: PUSH
110241: LD_INT 2
110243: PUSH
110244: LD_INT 34
110246: PUSH
110247: LD_INT 12
110249: PUSH
110250: EMPTY
110251: LIST
110252: LIST
110253: PUSH
110254: LD_INT 34
110256: PUSH
110257: LD_INT 51
110259: PUSH
110260: EMPTY
110261: LIST
110262: LIST
110263: PUSH
110264: LD_INT 34
110266: PUSH
110267: LD_INT 32
110269: PUSH
110270: EMPTY
110271: LIST
110272: LIST
110273: PUSH
110274: LD_INT 34
110276: PUSH
110277: LD_INT 89
110279: PUSH
110280: EMPTY
110281: LIST
110282: LIST
110283: PUSH
110284: EMPTY
110285: LIST
110286: LIST
110287: LIST
110288: LIST
110289: LIST
110290: PUSH
110291: EMPTY
110292: LIST
110293: LIST
110294: LIST
110295: PPUSH
110296: CALL_OW 69
110300: ST_TO_ADDR
// if tmp then
110301: LD_VAR 0 4
110305: IFFALSE 110431
// begin for j in tmp do
110307: LD_ADDR_VAR 0 2
110311: PUSH
110312: LD_VAR 0 4
110316: PUSH
110317: FOR_IN
110318: IFFALSE 110429
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110320: LD_VAR 0 2
110324: PPUSH
110325: CALL_OW 262
110329: PUSH
110330: LD_INT 3
110332: EQUAL
110333: PUSH
110334: LD_VAR 0 2
110338: PPUSH
110339: CALL_OW 261
110343: PUSH
110344: LD_INT 20
110346: GREATER
110347: OR
110348: PUSH
110349: LD_VAR 0 2
110353: PPUSH
110354: CALL_OW 314
110358: NOT
110359: AND
110360: PUSH
110361: LD_VAR 0 2
110365: PPUSH
110366: CALL_OW 263
110370: PUSH
110371: LD_INT 1
110373: NONEQUAL
110374: PUSH
110375: LD_VAR 0 2
110379: PPUSH
110380: CALL_OW 311
110384: OR
110385: AND
110386: IFFALSE 110427
// begin ComCollect ( j , x , y ) ;
110388: LD_VAR 0 2
110392: PPUSH
110393: LD_VAR 0 6
110397: PPUSH
110398: LD_VAR 0 7
110402: PPUSH
110403: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110407: LD_VAR 0 2
110411: PPUSH
110412: LD_VAR 0 8
110416: PPUSH
110417: CALL_OW 172
// exit ;
110421: POP
110422: POP
110423: POP
110424: POP
110425: GO 110435
// end ;
110427: GO 110317
110429: POP
110430: POP
// end ; end ;
110431: GO 109806
110433: POP
110434: POP
// end ; end_of_file
110435: PPOPN 9
110437: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110438: LD_VAR 0 1
110442: PPUSH
110443: LD_VAR 0 2
110447: PPUSH
110448: LD_VAR 0 3
110452: PPUSH
110453: LD_VAR 0 4
110457: PPUSH
110458: LD_VAR 0 5
110462: PPUSH
110463: LD_VAR 0 6
110467: PPUSH
110468: CALL 94791 0 6
// end ;
110472: PPOPN 6
110474: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
110475: LD_INT 0
110477: PPUSH
// begin if not units then
110478: LD_VAR 0 1
110482: NOT
110483: IFFALSE 110487
// exit ;
110485: GO 110487
// end ;
110487: PPOPN 7
110489: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
110490: CALL 94695 0 0
// end ;
110494: PPOPN 1
110496: END
