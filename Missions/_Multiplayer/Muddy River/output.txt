// starting begin ResetFog ;
   0: NOP4
// InitHc ;
   4: NOP4
// InitUc ;
   8: NOP4
// InitBc ;
  12: NOP4
// InitVariables ;
  16: NOP4
// InitMultiplayer ;
  20: NOP4
// InitMacro ;
  24: NOP4
// if debug then
  28: NOP4
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: NOP4
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: NOP4
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: NOP4
  79: PPUSH
  80: NOP4
// Multiplayer_Start ;
  84: NOP4
// MC_Start ( ) ;
  88: NOP4
// Multiplayer_End ;
  92: NOP4
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: NOP4
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: NOP4
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: NOP4
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: NOP4
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: NOP4
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: NOP4
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: NOP4
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: NOP4
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: NOP4
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: NOP4
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: NOP4
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: NOP4
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: NOP4
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: NOP4
 325: PPUSH
 326: NOP4
 330: PUSH
 331: NOP4
 335: ARRAY
 336: PPUSH
 337: NOP4
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := 1 ;
 353: NOP4
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: NOP4
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: NOP4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: NOP4
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: NOP4
 489: PUSH
 490: NOP4
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: NOP4
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: NOP4
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: NOP4
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: NOP4
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: NOP4
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: NOP4
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: NOP4
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: NOP4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: NOP4
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: NOP4
 646: PUSH
 647: NOP4
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: NOP4
 656: PUSH
 657: NOP4
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: NOP4
 666: PUSH
 667: NOP4
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: NOP4
 676: PUSH
 677: NOP4
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: NOP4
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: NOP4
 693: PUSH
 694: NOP4
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: NOP4
 706: PUSH
 707: NOP4
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: NOP4
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: NOP4
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: NOP4
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: NOP4
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: NOP4
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: NOP4
 772: PUSH
 773: NOP4
 777: PPUSH
 778: NOP4
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: NOP4
 791: PPUSH
 792: NOP4
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: NOP4
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: NOP4
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: NOP4
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: NOP4
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: NOP4
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: NOP4
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: NOP4
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: NOP4
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: NOP4
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: NOP4
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: NOP4
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: NOP4
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: NOP4
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: NOP4
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: NOP4
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: NOP4
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: NOP4
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: NOP4
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: NOP4
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: NOP4
1232: PPUSH
1233: NOP4
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: NOP4
1243: PUSH
1244: NOP4
1248: PPUSH
1249: NOP4
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: NOP4
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: NOP4
1266: PUSH
1267: NOP4
1271: PPUSH
1272: NOP4
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: NOP4
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: NOP4
1289: PUSH
1290: NOP4
1294: PPUSH
1295: NOP4
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: NOP4
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: NOP4
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: NOP4
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: NOP4
1330: PUSH
1331: NOP4
1335: PUSH
1336: NOP4
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: NOP4
1348: PUSH
1349: NOP4
1353: PUSH
1354: NOP4
1358: ARRAY
1359: PUSH
1360: NOP4
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: NOP4
1370: PUSH
1371: NOP4
1375: PPUSH
1376: NOP4
1380: PPUSH
1381: NOP4
1385: PPUSH
1386: NOP4
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: NOP4
1399: PUSH
1400: NOP4
1404: ARRAY
1405: PUSH
1406: NOP4
1410: PUSH
1411: NOP4
1415: ARRAY
1416: PUSH
1417: NOP4
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: NOP4
1430: PUSH
1431: NOP4
1435: PPUSH
1436: NOP4
1440: PPUSH
1441: NOP4
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: NOP4
1453: PPUSH
1454: NOP4
1458: ARRAY
1459: PPUSH
1460: NOP4
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: NOP4
1469: PUSH
1470: NOP4
1474: ARRAY
1475: NOT
1476: PUSH
1477: NOP4
1481: PUSH
1482: NOP4
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: NOP4
1494: PUSH
1495: NOP4
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: NOP4
1508: PUSH
1509: NOP4
1513: PPUSH
1514: NOP4
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: NOP4
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: NOP4
1531: PUSH
1532: NOP4
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: NOP4
1543: PUSH
1544: NOP4
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: NOP4
1561: PUSH
1562: NOP4
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: NOP4
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: NOP4
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: NOP4
1592: PUSH
1593: NOP4
1597: ARRAY
1598: PPUSH
1599: NOP4
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: NOP4
// for x = 1 to j - 1 do
1612: NOP4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: NOP4
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: NOP4
1638: PUSH
1639: NOP4
1643: ARRAY
1644: PPUSH
1645: NOP4
1649: PUSH
1650: NOP4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: NOP4
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: NOP4
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: NOP4
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: NOP4
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: NOP4
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: NOP4
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: NOP4
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: NOP4
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: NOP4
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: NOP4
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: NOP4
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: NOP4
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: NOP4
1901: PUSH
1902: NOP4
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: NOP4
1914: PUSH
1915: NOP4
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: NOP4
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: NOP4
1942: PUSH
1943: NOP4
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: NOP4
1955: PUSH
1956: NOP4
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: NOP4
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: NOP4
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: NOP4
2095: PUSH
2096: NOP4
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: NOP4
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: NOP4
2185: PUSH
2186: NOP4
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: NOP4
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: NOP4
2275: PUSH
2276: NOP4
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: NOP4
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: NOP4
2317: PUSH
2318: NOP4
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: NOP4
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: NOP4
2338: PUSH
2339: NOP4
2343: PPUSH
2344: NOP4
2348: PUSH
2349: NOP4
2353: ARRAY
2354: PPUSH
2355: NOP4
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: NOP4
2364: PUSH
2365: NOP4
2369: PPUSH
2370: NOP4
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: NOP4
2383: PPUSH
2384: NOP4
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: NOP4
2393: PPUSH
2394: NOP4
2398: PUSH
2399: NOP4
2403: PUSH
2404: NOP4
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: NOP4
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: NOP4
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: NOP4
2443: PUSH
2444: NOP4
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: NOP4
2468: PPUSH
2469: NOP4
// if multiplayer then
2473: NOP4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: NOP4
2488: PUSH
2489: NOP4
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: NOP4
2512: PPUSH
2513: NOP4
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: NOP4
2527: PPUSH
2528: NOP4
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: NOP4
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: NOP4
2571: PUSH
2572: NOP4
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: NOP4
2581: PPUSH
2582: NOP4
2586: PUSH
2587: NOP4
2591: PUSH
2592: NOP4
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: NOP4
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: NOP4
2614: PUSH
2615: NOP4
2619: PPUSH
2620: NOP4
2624: PPUSH
2625: NOP4
2629: PPUSH
2630: NOP4
2634: ST_TO_ADDR
// end ; InitHc ;
2635: NOP4
// InitUc ;
2639: NOP4
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: NOP4
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: NOP4
2662: PUSH
2663: NOP4
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: NOP4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: NOP4
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: NOP4
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: NOP4
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: NOP4
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: NOP4
2751: PUSH
2752: NOP4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: NOP4
2768: PPUSH
2769: NOP4
2773: PPUSH
2774: NOP4
// un := CreateHuman ;
2778: NOP4
2782: PUSH
2783: NOP4
2787: ST_TO_ADDR
// if j > copy then
2788: NOP4
2792: PUSH
2793: NOP4
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: NOP4
2804: PUSH
2805: NOP4
2809: PPUSH
2810: NOP4
2814: PPUSH
2815: NOP4
2819: PPUSH
2820: NOP4
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: NOP4
2831: PUSH
2832: NOP4
2836: ARRAY
2837: PPUSH
2838: NOP4
2842: PPUSH
2843: NOP4
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: NOP4
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: NOP4
2859: PUSH
2860: NOP4
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: NOP4
2873: PPUSH
2874: NOP4
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: NOP4
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: NOP4
2890: PUSH
2891: NOP4
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: NOP4
2904: PPUSH
2905: NOP4
// end ; if multi_pos_area then
2909: NOP4
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: NOP4
2919: PPUSH
2920: NOP4
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: NOP4
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: NOP4
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: NOP4
// veh := CreateVehicle ;
2995: NOP4
2999: PUSH
3000: NOP4
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: NOP4
3009: PPUSH
3010: NOP4
3014: PUSH
3015: NOP4
3019: PUSH
3020: NOP4
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: NOP4
// PlaceHumanInUnit ( un , veh ) ;
3038: NOP4
3042: PPUSH
3043: NOP4
3047: PPUSH
3048: NOP4
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: NOP4
3058: PPUSH
3059: NOP4
3063: PUSH
3064: NOP4
3068: PUSH
3069: NOP4
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: NOP4
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: NOP4
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: NOP4
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: NOP4
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: NOP4
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: NOP4
3166: PPUSH
3167: NOP4
3171: PUSH
3172: NOP4
3176: PUSH
3177: NOP4
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: NOP4
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: NOP4
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: NOP4
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: NOP4
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: NOP4
3251: PUSH
3252: NOP4
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: NOP4
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: NOP4
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: NOP4
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: NOP4
3295: PUSH
3296: NOP4
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: NOP4
// tmp := tmp ^ CreateVehicle ;
3321: NOP4
3325: PUSH
3326: NOP4
3330: PUSH
3331: NOP4
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: NOP4
// tmp := tmp ^ CreateVehicle ;
3356: NOP4
3360: PUSH
3361: NOP4
3365: PUSH
3366: NOP4
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: NOP4
// tmp := tmp ^ CreateVehicle ;
3391: NOP4
3395: PUSH
3396: NOP4
3400: PUSH
3401: NOP4
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: NOP4
// tmp := tmp ^ CreateVehicle ;
3426: NOP4
3430: PUSH
3431: NOP4
3435: PUSH
3436: NOP4
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: NOP4
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: NOP4
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: NOP4
3471: PUSH
3472: NOP4
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: NOP4
// tmp := tmp ^ CreateVehicle ;
3497: NOP4
3501: PUSH
3502: NOP4
3506: PUSH
3507: NOP4
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: NOP4
// tmp := tmp ^ CreateVehicle ;
3532: NOP4
3536: PUSH
3537: NOP4
3541: PUSH
3542: NOP4
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: NOP4
// tmp := tmp ^ CreateVehicle ;
3567: NOP4
3571: PUSH
3572: NOP4
3576: PUSH
3577: NOP4
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: NOP4
// tmp := tmp ^ CreateVehicle ;
3602: NOP4
3606: PUSH
3607: NOP4
3611: PUSH
3612: NOP4
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: NOP4
// tmp := tmp ^ CreateVehicle ;
3637: NOP4
3641: PUSH
3642: NOP4
3646: PUSH
3647: NOP4
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: NOP4
// tmp := tmp ^ CreateVehicle ;
3672: NOP4
3676: PUSH
3677: NOP4
3681: PUSH
3682: NOP4
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: NOP4
// tmp := tmp ^ CreateVehicle ;
3707: NOP4
3711: PUSH
3712: NOP4
3716: PUSH
3717: NOP4
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: NOP4
3727: PUSH
3728: NOP4
3732: PPUSH
3733: NOP4
3737: PPUSH
3738: NOP4
3742: PPUSH
3743: NOP4
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: NOP4
// Multiplayer_InitPointSystem ( ) ;
3764: NOP4
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: NOP4
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: NOP4
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: NOP4
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: NOP4
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: NOP4
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: NOP4
// Multiplayer_SpawnArtifact ;
3811: NOP4
// if multi_support then
3815: NOP4
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: NOP4
3825: PUSH
3826: NOP4
3830: ST_TO_ADDR
// game := true ;
3831: NOP4
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: NOP4
3843: PUSH
3844: NOP4
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: NOP4
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: NOP4
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: NOP4
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: NOP4
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: NOP4
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: NOP4
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: NOP4
3916: NOT
3917: AND
3918: PUSH
3919: NOP4
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: NOP4
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: NOP4
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: NOP4
3958: PUSH
3959: NOP4
3963: ARRAY
3964: PUSH
3965: NOP4
3969: PUSH
3970: NOP4
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: NOP4
3982: PUSH
3983: NOP4
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: NOP4
3995: PUSH
3996: NOP4
4000: PUSH
4001: NOP4
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: NOP4
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: NOP4
4027: PUSH
4028: NOP4
4032: ARRAY
4033: PPUSH
4034: NOP4
4038: PUSH
4039: NOP4
4043: PUSH
4044: NOP4
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: NOP4
// tmp := Delete ( tmp , 1 ) ;
4062: NOP4
4066: PUSH
4067: NOP4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: NOP4
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: NOP4
4088: PUSH
4089: NOP4
4093: PPUSH
4094: NOP4
4098: PPUSH
4099: NOP4
4103: PPUSH
4104: NOP4
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: NOP4
4117: PUSH
4118: NOP4
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: NOP4
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: NOP4
4136: LESS
4137: PUSH
4138: NOP4
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: NOP4
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: NOP4
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: NOP4
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: NOP4
4187: PUSH
4188: NOP4
4192: ARRAY
4193: PUSH
4194: NOP4
4198: PUSH
4199: NOP4
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: NOP4
4211: PUSH
4212: NOP4
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: NOP4
4224: PUSH
4225: NOP4
4229: PUSH
4230: NOP4
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: NOP4
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: NOP4
4256: PUSH
4257: NOP4
4261: ARRAY
4262: PPUSH
4263: NOP4
4267: PUSH
4268: NOP4
4272: PUSH
4273: NOP4
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: NOP4
// tmp := Delete ( tmp , 1 ) ;
4291: NOP4
4295: PUSH
4296: NOP4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: NOP4
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: NOP4
4317: PUSH
4318: NOP4
4322: PPUSH
4323: NOP4
4327: PPUSH
4328: NOP4
4332: PPUSH
4333: NOP4
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: NOP4
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: NOP4
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: NOP4
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: NOP4
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: NOP4
4390: PUSH
4391: NOP4
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: NOP4
4404: PUSH
4405: NOP4
4409: PPUSH
4410: NOP4
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: NOP4
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: NOP4
4427: PPUSH
4428: NOP4
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: NOP4
4440: PPUSH
4441: NOP4
4445: PUSH
4446: NOP4
4450: PPUSH
4451: NOP4
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: NOP4
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: NOP4
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: NOP4
4485: AND
4486: PUSH
4487: NOP4
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: NOP4
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: NOP4
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: NOP4
4523: PUSH
4524: NOP4
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: NOP4
4535: PPUSH
4536: NOP4
4540: PUSH
4541: NOP4
4545: ARRAY
4546: PPUSH
4547: NOP4
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: NOP4
4559: PUSH
4560: NOP4
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: NOP4
4571: GO 4577
// YouWinInMultiplayer ;
4573: NOP4
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: NOP4
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: NOP4
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: NOP4
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: NOP4
4623: PUSH
4624: NOP4
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: NOP4
4635: PUSH
4636: NOP4
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: NOP4
4648: PUSH
4649: NOP4
4653: PUSH
4654: NOP4
4658: PUSH
4659: NOP4
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: NOP4
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: NOP4
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: NOP4
4743: NOT
4744: PUSH
4745: NOP4
4749: NOT
4750: OR
4751: PUSH
4752: NOP4
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: NOP4
4769: PUSH
4770: NOP4
4774: PPUSH
4775: NOP4
4779: PPUSH
4780: NOP4
4784: PUSH
4785: NOP4
4789: ARRAY
4790: PUSH
4791: NOP4
4795: PLUS
4796: PPUSH
4797: NOP4
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: NOP4
4814: NOT
4815: PUSH
4816: NOP4
4820: NOT
4821: OR
4822: PUSH
4823: NOP4
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: NOP4
4840: PUSH
4841: NOP4
4845: PUSH
4846: NOP4
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: NOP4
4864: PUSH
4865: NOP4
4869: PPUSH
4870: NOP4
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: NOP4
4883: PPUSH
4884: NOP4
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: NOP4
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: NOP4
4910: PUSH
4911: NOP4
4915: PUSH
4916: NOP4
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: NOP4
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: NOP4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: NOP4
4961: PUSH
4962: NOP4
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: NOP4
4975: PUSH
4976: NOP4
4980: ARRAY
4981: PUSH
4982: NOP4
4986: PUSH
4987: NOP4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: NOP4
5000: PUSH
5001: NOP4
5005: PUSH
5006: NOP4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: NOP4
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: NOP4
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: NOP4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: NOP4
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: NOP4
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: NOP4
5074: PPUSH
5075: NOP4
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: NOP4
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: NOP4
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: NOP4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: NOP4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: NOP4
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: NOP4
5173: PPUSH
5174: NOP4
5178: PUSH
5179: NOP4
5183: ARRAY
5184: PPUSH
5185: NOP4
// if IsDrivenBy ( i ) then
5189: NOP4
5193: PPUSH
5194: NOP4
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: NOP4
5204: PPUSH
5205: NOP4
5209: PPUSH
5210: NOP4
5214: PUSH
5215: NOP4
5219: ARRAY
5220: PPUSH
5221: NOP4
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: NOP4
5229: PPUSH
5230: NOP4
5234: PPUSH
5235: NOP4
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: NOP4
5249: PPUSH
5250: NOP4
// j := j + 1 ;
5254: NOP4
5258: PUSH
5259: NOP4
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: NOP4
5272: PUSH
5273: NOP4
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: NOP4
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: NOP4
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: NOP4
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: NOP4
5365: PPUSH
5366: NOP4
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: NOP4
5381: PUSH
5382: NOP4
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: NOP4
5396: PUSH
5397: NOP4
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: NOP4
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: NOP4
5426: NOT
5427: PUSH
5428: NOP4
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: NOP4
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: NOP4
5453: PPUSH
5454: NOP4
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: NOP4
5470: NOT
5471: PUSH
5472: NOP4
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: NOP4
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: NOP4
5497: PPUSH
5498: NOP4
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: NOP4
5514: NOT
5515: PUSH
5516: NOP4
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: NOP4
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: NOP4
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: NOP4
5567: PPUSH
5568: NOP4
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: NOP4
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: NOP4
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: NOP4
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: NOP4
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: NOP4
5620: PUSH
5621: NOP4
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: NOP4
5630: PUSH
5631: NOP4
5635: PPUSH
5636: NOP4
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: NOP4
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: NOP4
5656: PUSH
5657: NOP4
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: NOP4
5666: PUSH
5667: NOP4
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: NOP4
5679: PPUSH
5680: NOP4
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: NOP4
5693: DIFF
5694: PPUSH
5695: NOP4
5699: PPUSH
5700: NOP4
5704: ST_TO_ADDR
// if nearest_unit then
5705: NOP4
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: NOP4
5715: PUSH
5716: NOP4
5720: PPUSH
5721: NOP4
5725: ST_TO_ADDR
// if not side and not side2 then
5726: NOP4
5730: NOT
5731: PUSH
5732: NOP4
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: NOP4
5746: PUSH
5747: NOP4
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: NOP4
5758: PPUSH
5759: NOP4
5763: PPUSH
5764: NOP4
5768: GO 5818
// begin if side then
5770: NOP4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: NOP4
5780: PPUSH
5781: NOP4
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: NOP4
// if side2 then
5794: NOP4
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: NOP4
5804: PPUSH
5805: NOP4
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: NOP4
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: NOP4
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: NOP4
5838: PPUSH
5839: NOP4
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: NOP4
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: NOP4
5878: ST_TO_ADDR
// side_bot := side ;
5879: NOP4
5883: PUSH
5884: NOP4
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: NOP4
5893: PUSH
5894: NOP4
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: NOP4
5909: PUSH
5910: NOP4
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: NOP4
5922: PPUSH
5923: NOP4
5927: PPUSH
5928: NOP4
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: NOP4
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: NOP4
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: NOP4
5999: PUSH
6000: NOP4
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: NOP4
6012: PPUSH
6013: NOP4
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: NOP4
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: NOP4
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: NOP4
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: NOP4
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: NOP4
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: NOP4
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: NOP4
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: NOP4
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: NOP4
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: NOP4
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: NOP4
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: NOP4
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: NOP4
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: NOP4
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: NOP4
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: NOP4
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: NOP4
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: NOP4
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: NOP4
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: NOP4
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: NOP4
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: NOP4
6377: PUSH
6378: NOP4
6382: PUSH
6383: NOP4
6387: PUSH
6388: NOP4
6392: PUSH
6393: NOP4
6397: PUSH
6398: NOP4
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: NOP4
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: NOP4
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: NOP4
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: NOP4
6511: PPUSH
6512: NOP4
// un := CreateVehicle ;
6516: NOP4
6520: PUSH
6521: NOP4
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: NOP4
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: NOP4
6541: PPUSH
6542: NOP4
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: NOP4
6550: PPUSH
6551: NOP4
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: NOP4
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: NOP4
// un2 := CreateHuman ;
6579: NOP4
6583: PUSH
6584: NOP4
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: NOP4
6593: PPUSH
6594: NOP4
6598: PPUSH
6599: NOP4
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: NOP4
6607: PUSH
6608: NOP4
6612: PPUSH
6613: NOP4
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: NOP4
6630: PUSH
6631: NOP4
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: NOP4
6657: PPUSH
6658: NOP4
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: NOP4
6667: PUSH
6668: NOP4
6672: PPUSH
6673: NOP4
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: NOP4
6690: PUSH
6691: NOP4
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: NOP4
6717: PPUSH
6718: NOP4
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: NOP4
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: NOP4
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: NOP4
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: NOP4
6777: PPUSH
6778: NOP4
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: NOP4
6790: PUSH
6791: NOP4
6795: PPUSH
6796: NOP4
6800: ST_TO_ADDR
// if d < 3 then
6801: NOP4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: NOP4
6815: PUSH
6816: NOP4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: NOP4
6831: PUSH
6832: NOP4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: NOP4
6851: PPUSH
6852: NOP4
// un := CreateHuman ;
6856: NOP4
6860: PUSH
6861: NOP4
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: NOP4
6870: PPUSH
6871: NOP4
6875: PPUSH
6876: NOP4
// PlaceHumanInUnit ( un , i ) ;
6880: NOP4
6884: PPUSH
6885: NOP4
6889: PPUSH
6890: NOP4
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: NOP4
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: NOP4
6915: PPUSH
6916: NOP4
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: NOP4
6940: PUSH
6941: NOP4
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: NOP4
6953: PPUSH
6954: NOP4
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: NOP4
6969: PPUSH
6970: NOP4
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: NOP4
6994: PUSH
6995: NOP4
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: NOP4
7007: PPUSH
7008: NOP4
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: NOP4
7023: PPUSH
7024: NOP4
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: NOP4
7040: PUSH
7041: NOP4
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: NOP4
7053: PPUSH
7054: NOP4
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: NOP4
7126: PUSH
7127: NOP4
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: NOP4
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: NOP4
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: NOP4
7203: PUSH
7204: NOP4
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: NOP4
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: NOP4
// InitHc ;
7221: NOP4
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: NOP4
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: NOP4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: NOP4
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: NOP4
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: NOP4
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: NOP4
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: NOP4
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: NOP4
// un := CreateVehicle ;
7377: NOP4
7381: PUSH
7382: NOP4
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: NOP4
7391: PUSH
7392: NOP4
7396: PPUSH
7397: NOP4
7401: PUSH
7402: NOP4
7406: PUSH
7407: NOP4
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: NOP4
7425: PPUSH
7426: NOP4
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: NOP4
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: NOP4
7446: PPUSH
7447: NOP4
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: NOP4
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: NOP4
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: NOP4
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: NOP4
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: NOP4
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: NOP4
7519: PUSH
7520: NOP4
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: NOP4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: NOP4
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: NOP4
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: NOP4
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: NOP4
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: NOP4
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: NOP4
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: NOP4
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: NOP4
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: NOP4
7785: PUSH
7786: NOP4
7790: PPUSH
7791: NOP4
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: NOP4
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: NOP4
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: NOP4
7858: PPUSH
7859: NOP4
7863: PPUSH
7864: NOP4
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: NOP4
// until MC_GetProduceList ( base ) = 0 ;
7875: NOP4
7879: PPUSH
7880: NOP4
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: NOP4
// for i = 1 to coords do
7897: NOP4
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: NOP4
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: NOP4
7919: PUSH
7920: NOP4
7924: PPUSH
7925: NOP4
7929: PUSH
7930: NOP4
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: NOP4
7944: PUSH
7945: NOP4
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: NOP4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: NOP4
7971: PUSH
7972: NOP4
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: NOP4
7983: PUSH
7984: NOP4
7988: ST_TO_ADDR
// target := i ;
7989: NOP4
7993: PUSH
7994: NOP4
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: NOP4
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: NOP4
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: NOP4
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: NOP4
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: NOP4
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: NOP4
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: NOP4
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: NOP4
8209: PPUSH
8210: NOP4
8214: PUSH
8215: NOP4
8219: ARRAY
8220: PPUSH
8221: NOP4
8225: PPUSH
8226: NOP4
8230: PPUSH
8231: NOP4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: NOP4
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: NOP4
8253: PUSH
8254: NOP4
8258: EQUAL
8259: AND
8260: PUSH
8261: NOP4
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: NOP4
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: NOP4
8286: PUSH
8287: NOP4
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: NOP4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: NOP4
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: NOP4
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: NOP4
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: NOP4
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: NOP4
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: NOP4
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: NOP4
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: NOP4
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: NOP4
8512: PUSH
8513: NOP4
8517: PPUSH
8518: NOP4
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: NOP4
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: NOP4
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: NOP4
8583: PPUSH
8584: NOP4
8588: PPUSH
8589: NOP4
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: NOP4
// until MC_GetProduceList ( base ) = 0 ;
8600: NOP4
8604: PPUSH
8605: NOP4
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: NOP4
// for i = 1 to coords do
8622: NOP4
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: NOP4
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: NOP4
8644: PUSH
8645: NOP4
8649: PPUSH
8650: NOP4
8654: PUSH
8655: NOP4
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: NOP4
8669: PUSH
8670: NOP4
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: NOP4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: NOP4
8696: PUSH
8697: NOP4
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: NOP4
8708: PUSH
8709: NOP4
8713: ST_TO_ADDR
// target := i ;
8714: NOP4
8718: PUSH
8719: NOP4
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: NOP4
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: NOP4
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: NOP4
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: NOP4
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: NOP4
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: NOP4
8854: PPUSH
8855: NOP4
8859: PUSH
8860: NOP4
8864: ARRAY
8865: PPUSH
8866: NOP4
8870: PPUSH
8871: NOP4
8875: PPUSH
8876: NOP4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: NOP4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: NOP4
8899: PPUSH
8900: NOP4
8904: PPUSH
8905: NOP4
// artifact_get := true ;
8909: NOP4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: NOP4
8928: PUSH
8929: NOP4
8933: PPUSH
8934: NOP4
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: NOP4
8943: PUSH
8944: NOP4
8948: IN
8949: NOT
8950: PUSH
8951: NOP4
8955: PUSH
8956: NOP4
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: NOP4
8968: PPUSH
8969: NOP4
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: NOP4
8983: PPUSH
8984: NOP4
// if side in mc_sides then
8988: NOP4
8992: PUSH
8993: NOP4
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: NOP4
9004: PUSH
9005: NOP4
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: NOP4
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: NOP4
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: NOP4
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: NOP4
9038: PPUSH
9039: NOP4
// if multi_commanders and multi_custom_commanders then
9043: NOP4
9047: PUSH
9048: NOP4
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: NOP4
9059: PUSH
9060: NOP4
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: NOP4
9071: PUSH
9072: NOP4
9076: PPUSH
9077: NOP4
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: NOP4
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: NOP4
9094: PUSH
9095: NOP4
9099: PUSH
9100: NOP4
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: NOP4
9110: PPUSH
9111: NOP4
// end ; MCE_UnitDestroyed ( un ) ;
9115: NOP4
9119: PPUSH
9120: NOP4
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: NOP4
9131: PPUSH
9132: NOP4
9136: PPUSH
9137: NOP4
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: NOP4
9152: PPUSH
9153: NOP4
9157: PUSH
9158: NOP4
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: NOP4
9169: PPUSH
9170: NOP4
9174: PPUSH
9175: NOP4
9179: PPUSH
9180: NOP4
9184: PPUSH
9185: NOP4
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: NOP4
9193: PPUSH
9194: NOP4
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: NOP4
9207: PPUSH
9208: NOP4
9212: PUSH
9213: NOP4
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: NOP4
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: NOP4
9232: PPUSH
9233: NOP4
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: NOP4
// base_names := Delete ( base_names , 1 ) ;
9246: NOP4
9250: PUSH
9251: NOP4
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: NOP4
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: NOP4
9268: PPUSH
9269: NOP4
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: NOP4
9280: PPUSH
9281: NOP4
9285: PPUSH
9286: NOP4
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: NOP4
9297: PPUSH
9298: NOP4
9302: PPUSH
9303: NOP4
9307: PPUSH
9308: NOP4
9312: PPUSH
9313: NOP4
9317: PPUSH
9318: NOP4
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: NOP4
9334: PUSH
9335: NOP4
9339: PPUSH
9340: NOP4
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: NOP4
9349: PUSH
9350: NOP4
9354: IN
9355: NOT
9356: PUSH
9357: NOP4
9361: PUSH
9362: NOP4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: NOP4
9374: PPUSH
9375: NOP4
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: NOP4
9383: PPUSH
9384: NOP4
9388: PPUSH
9389: NOP4
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: NOP4
9400: PPUSH
9401: NOP4
9405: PPUSH
9406: NOP4
9410: PPUSH
9411: NOP4
9415: PPUSH
9416: NOP4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: NOP4
9427: PPUSH
9428: NOP4
9432: PPUSH
9433: NOP4
9437: PPUSH
9438: NOP4
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: NOP4
9449: PPUSH
9450: NOP4
9454: PPUSH
9455: NOP4
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: NOP4
9466: PPUSH
9467: NOP4
9471: PPUSH
9472: NOP4
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: NOP4
9483: PPUSH
9484: NOP4
9488: PPUSH
9489: NOP4
9493: PPUSH
9494: NOP4
9498: PPUSH
9499: NOP4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: NOP4
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: NOP4
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: NOP4
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: NOP4
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: NOP4
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: NOP4
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: NOP4
9594: PPUSH
9595: NOP4
// x := 5 ;
9599: NOP4
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: NOP4
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: NOP4
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: NOP4
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: NOP4
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: NOP4
9656: PUSH
9657: NOP4
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: NOP4
9668: PPUSH
9669: NOP4
9673: PUSH
9674: NOP4
9678: PUSH
9679: NOP4
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: NOP4
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: NOP4
// end ; for i in areas do
9704: NOP4
9708: PUSH
9709: NOP4
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: NOP4
// CreateCratesArea ( x , i , true ) ;
9724: NOP4
9728: PPUSH
9729: NOP4
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: NOP4
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: NOP4
9749: PUSH
9750: NOP4
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: NOP4
9763: PUSH
9764: NOP4
9768: PUSH
9769: NOP4
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: NOP4
9783: PUSH
9784: NOP4
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: NOP4
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: NOP4
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: NOP4
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: NOP4
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: NOP4
9833: NOT
9834: PUSH
9835: NOP4
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: NOP4
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: NOP4
9865: PUSH
9866: NOP4
9870: PUSH
9871: NOP4
9875: STR
9876: PPUSH
9877: NOP4
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: NOP4
9888: PUSH
9889: NOP4
9893: PPUSH
9894: NOP4
9898: ST_TO_ADDR
// result := unit ;
9899: NOP4
9903: PUSH
9904: NOP4
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: NOP4
9922: NOT
9923: PUSH
9924: NOP4
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10702
// case nation of nation_american :
9934: NOP4
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: NOP4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10626
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10395
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10170: NOP4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: LD_INT 88
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: ST_TO_ADDR
10393: GO 10626
10395: LD_INT 3
10397: DOUBLE
10398: EQUAL
10399: IFTRUE 10403
10401: GO 10625
10403: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10404: NOP4
10408: PUSH
10409: LD_INT 46
10411: PUSH
10412: LD_INT 47
10414: PUSH
10415: LD_INT 1
10417: PUSH
10418: LD_INT 2
10420: PUSH
10421: LD_INT 82
10423: PUSH
10424: LD_INT 83
10426: PUSH
10427: LD_INT 84
10429: PUSH
10430: LD_INT 85
10432: PUSH
10433: LD_INT 86
10435: PUSH
10436: LD_INT 11
10438: PUSH
10439: LD_INT 9
10441: PUSH
10442: LD_INT 20
10444: PUSH
10445: LD_INT 19
10447: PUSH
10448: LD_INT 21
10450: PUSH
10451: LD_INT 24
10453: PUSH
10454: LD_INT 22
10456: PUSH
10457: LD_INT 25
10459: PUSH
10460: LD_INT 28
10462: PUSH
10463: LD_INT 29
10465: PUSH
10466: LD_INT 30
10468: PUSH
10469: LD_INT 31
10471: PUSH
10472: LD_INT 37
10474: PUSH
10475: LD_INT 38
10477: PUSH
10478: LD_INT 32
10480: PUSH
10481: LD_INT 27
10483: PUSH
10484: LD_INT 33
10486: PUSH
10487: LD_INT 69
10489: PUSH
10490: LD_INT 39
10492: PUSH
10493: LD_INT 34
10495: PUSH
10496: LD_INT 40
10498: PUSH
10499: LD_INT 71
10501: PUSH
10502: LD_INT 23
10504: PUSH
10505: LD_INT 44
10507: PUSH
10508: LD_INT 48
10510: PUSH
10511: LD_INT 49
10513: PUSH
10514: LD_INT 50
10516: PUSH
10517: LD_INT 51
10519: PUSH
10520: LD_INT 52
10522: PUSH
10523: LD_INT 53
10525: PUSH
10526: LD_INT 54
10528: PUSH
10529: LD_INT 55
10531: PUSH
10532: LD_INT 56
10534: PUSH
10535: LD_INT 57
10537: PUSH
10538: LD_INT 58
10540: PUSH
10541: LD_INT 59
10543: PUSH
10544: LD_INT 63
10546: PUSH
10547: LD_INT 64
10549: PUSH
10550: LD_INT 65
10552: PUSH
10553: LD_INT 82
10555: PUSH
10556: LD_INT 83
10558: PUSH
10559: LD_INT 84
10561: PUSH
10562: LD_INT 85
10564: PUSH
10565: LD_INT 86
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: ST_TO_ADDR
10623: GO 10626
10625: POP
// if state > - 1 and state < 3 then
10626: NOP4
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: GREATER
10635: PUSH
10636: NOP4
10640: PUSH
10641: LD_INT 3
10643: LESS
10644: AND
10645: IFFALSE 10702
// for i in result do
10647: NOP4
10651: PUSH
10652: NOP4
10656: PUSH
10657: FOR_IN
10658: IFFALSE 10700
// if GetTech ( i , side ) <> state then
10660: NOP4
10664: PPUSH
10665: NOP4
10669: PPUSH
10670: NOP4
10674: PUSH
10675: NOP4
10679: NONEQUAL
10680: IFFALSE 10698
// result := result diff i ;
10682: NOP4
10686: PUSH
10687: NOP4
10691: PUSH
10692: NOP4
10696: DIFF
10697: ST_TO_ADDR
10698: GO 10657
10700: POP
10701: POP
// end ;
10702: LD_VAR 0 4
10706: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// result := true ;
10712: NOP4
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10720: NOP4
10724: PUSH
10725: NOP4
10729: PPUSH
10730: NOP4
10734: ST_TO_ADDR
// if not tmp then
10735: NOP4
10739: NOT
10740: IFFALSE 10744
// exit ;
10742: GO 10793
// for i in tmp do
10744: NOP4
10748: PUSH
10749: NOP4
10753: PUSH
10754: FOR_IN
10755: IFFALSE 10791
// if GetTech ( i , side ) <> state_researched then
10757: NOP4
10761: PPUSH
10762: NOP4
10766: PPUSH
10767: NOP4
10771: PUSH
10772: LD_INT 2
10774: NONEQUAL
10775: IFFALSE 10789
// begin result := false ;
10777: NOP4
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// exit ;
10785: POP
10786: POP
10787: GO 10793
// end ;
10789: GO 10754
10791: POP
10792: POP
// end ;
10793: LD_VAR 0 3
10797: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10798: LD_INT 0
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10813: NOP4
10817: NOT
10818: PUSH
10819: NOP4
10823: PPUSH
10824: NOP4
10828: PUSH
10829: LD_INT 9
10831: NONEQUAL
10832: OR
10833: IFFALSE 10837
// exit ;
10835: GO 11410
// side := GetSide ( unit ) ;
10837: NOP4
10841: PUSH
10842: NOP4
10846: PPUSH
10847: NOP4
10851: ST_TO_ADDR
// tech_space := tech_spacanom ;
10852: NOP4
10856: PUSH
10857: LD_INT 29
10859: ST_TO_ADDR
// tech_time := tech_taurad ;
10860: NOP4
10864: PUSH
10865: LD_INT 28
10867: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10868: NOP4
10872: PUSH
10873: NOP4
10877: PPUSH
10878: NOP4
10882: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10883: NOP4
10887: PPUSH
10888: NOP4
10892: PUSH
10893: LD_INT 2
10895: EQUAL
10896: IFFALSE 10900
// exit ;
10898: GO 11410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10900: NOP4
10904: PUSH
10905: LD_INT 81
10907: PUSH
10908: NOP4
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PUSH
10917: LD_INT 3
10919: PUSH
10920: LD_INT 21
10922: PUSH
10923: LD_INT 3
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PPUSH
10938: NOP4
10942: ST_TO_ADDR
// if not tmp then
10943: NOP4
10947: NOT
10948: IFFALSE 10952
// exit ;
10950: GO 11410
// if in_unit then
10952: NOP4
10956: IFFALSE 10980
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10958: NOP4
10962: PUSH
10963: NOP4
10967: PPUSH
10968: NOP4
10972: PPUSH
10973: NOP4
10977: ST_TO_ADDR
10978: GO 11000
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10980: NOP4
10984: PUSH
10985: NOP4
10989: PPUSH
10990: NOP4
10994: PPUSH
10995: NOP4
10999: ST_TO_ADDR
// if not enemy then
11000: NOP4
11004: NOT
11005: IFFALSE 11009
// exit ;
11007: GO 11410
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11009: NOP4
11013: PUSH
11014: NOP4
11018: PPUSH
11019: NOP4
11023: PPUSH
11024: NOP4
11028: PUSH
11029: LD_INT 13
11031: GREATER
11032: AND
11033: PUSH
11034: NOP4
11038: PPUSH
11039: NOP4
11043: PPUSH
11044: NOP4
11048: PUSH
11049: LD_INT 12
11051: GREATER
11052: OR
11053: IFFALSE 11057
// exit ;
11055: GO 11410
// missile := [ 1 ] ;
11057: NOP4
11061: PUSH
11062: LD_INT 1
11064: PUSH
11065: EMPTY
11066: LIST
11067: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11068: NOP4
11072: PPUSH
11073: NOP4
11077: PPUSH
11078: NOP4
11082: IFFALSE 11111
// missile := Replace ( missile , missile + 1 , 2 ) ;
11084: NOP4
11088: PUSH
11089: NOP4
11093: PPUSH
11094: NOP4
11098: PUSH
11099: LD_INT 1
11101: PLUS
11102: PPUSH
11103: LD_INT 2
11105: PPUSH
11106: NOP4
11110: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11111: NOP4
11115: PPUSH
11116: NOP4
11120: PPUSH
11121: NOP4
11125: PUSH
11126: NOP4
11130: PPUSH
11131: NOP4
11135: PPUSH
11136: NOP4
11140: PPUSH
11141: NOP4
11145: NOT
11146: AND
11147: IFFALSE 11176
// missile := Replace ( missile , missile + 1 , 3 ) ;
11149: NOP4
11153: PUSH
11154: NOP4
11158: PPUSH
11159: NOP4
11163: PUSH
11164: LD_INT 1
11166: PLUS
11167: PPUSH
11168: LD_INT 3
11170: PPUSH
11171: NOP4
11175: ST_TO_ADDR
// if missile < 2 then
11176: NOP4
11180: PUSH
11181: LD_INT 2
11183: LESS
11184: IFFALSE 11188
// exit ;
11186: GO 11410
// x := GetX ( enemy ) ;
11188: NOP4
11192: PUSH
11193: NOP4
11197: PPUSH
11198: NOP4
11202: ST_TO_ADDR
// y := GetY ( enemy ) ;
11203: NOP4
11207: PUSH
11208: NOP4
11212: PPUSH
11213: NOP4
11217: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11218: NOP4
11222: PUSH
11223: NOP4
11227: PUSH
11228: LD_INT 1
11230: NEG
11231: PPUSH
11232: LD_INT 1
11234: PPUSH
11235: NOP4
11239: PLUS
11240: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11241: NOP4
11245: PUSH
11246: NOP4
11250: PUSH
11251: LD_INT 1
11253: NEG
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: NOP4
11262: PLUS
11263: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11264: NOP4
11268: PPUSH
11269: NOP4
11273: PPUSH
11274: NOP4
11278: NOT
11279: IFFALSE 11301
// begin _x := x ;
11281: NOP4
11285: PUSH
11286: NOP4
11290: ST_TO_ADDR
// _y := y ;
11291: NOP4
11295: PUSH
11296: NOP4
11300: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11301: NOP4
11305: PUSH
11306: LD_INT 1
11308: PPUSH
11309: NOP4
11313: PPUSH
11314: NOP4
11318: ST_TO_ADDR
// case i of 1 :
11319: NOP4
11323: PUSH
11324: LD_INT 1
11326: DOUBLE
11327: EQUAL
11328: IFTRUE 11332
11330: GO 11349
11332: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11333: NOP4
11337: PPUSH
11338: NOP4
11342: PPUSH
11343: NOP4
11347: GO 11410
11349: LD_INT 2
11351: DOUBLE
11352: EQUAL
11353: IFTRUE 11357
11355: GO 11379
11357: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11358: NOP4
11362: PPUSH
11363: NOP4
11367: PPUSH
11368: NOP4
11372: PPUSH
11373: NOP4
11377: GO 11410
11379: LD_INT 3
11381: DOUBLE
11382: EQUAL
11383: IFTRUE 11387
11385: GO 11409
11387: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11388: NOP4
11392: PPUSH
11393: NOP4
11397: PPUSH
11398: NOP4
11402: PPUSH
11403: NOP4
11407: GO 11410
11409: POP
// end ;
11410: LD_VAR 0 2
11414: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11415: LD_INT 0
11417: PPUSH
11418: PPUSH
11419: PPUSH
11420: PPUSH
11421: PPUSH
11422: PPUSH
// if not unit or not building then
11423: NOP4
11427: NOT
11428: PUSH
11429: NOP4
11433: NOT
11434: OR
11435: IFFALSE 11439
// exit ;
11437: GO 11597
// x := GetX ( building ) ;
11439: NOP4
11443: PUSH
11444: NOP4
11448: PPUSH
11449: NOP4
11453: ST_TO_ADDR
// y := GetY ( building ) ;
11454: NOP4
11458: PUSH
11459: NOP4
11463: PPUSH
11464: NOP4
11468: ST_TO_ADDR
// for i = 0 to 5 do
11469: NOP4
11473: PUSH
11474: DOUBLE
11475: LD_INT 0
11477: DEC
11478: ST_TO_ADDR
11479: LD_INT 5
11481: PUSH
11482: FOR_TO
11483: IFFALSE 11595
// begin _x := ShiftX ( x , i , 3 ) ;
11485: NOP4
11489: PUSH
11490: NOP4
11494: PPUSH
11495: NOP4
11499: PPUSH
11500: LD_INT 3
11502: PPUSH
11503: NOP4
11507: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11508: NOP4
11512: PUSH
11513: NOP4
11517: PPUSH
11518: NOP4
11522: PPUSH
11523: LD_INT 3
11525: PPUSH
11526: NOP4
11530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11531: NOP4
11535: PPUSH
11536: NOP4
11540: PPUSH
11541: NOP4
11545: NOT
11546: IFFALSE 11550
// continue ;
11548: GO 11482
// if HexInfo ( _x , _y ) = 0 then
11550: NOP4
11554: PPUSH
11555: NOP4
11559: PPUSH
11560: NOP4
11564: PUSH
11565: LD_INT 0
11567: EQUAL
11568: IFFALSE 11593
// begin ComMoveXY ( unit , _x , _y ) ;
11570: NOP4
11574: PPUSH
11575: NOP4
11579: PPUSH
11580: NOP4
11584: PPUSH
11585: NOP4
// exit ;
11589: POP
11590: POP
11591: GO 11597
// end ; end ;
11593: GO 11482
11595: POP
11596: POP
// end ;
11597: LD_VAR 0 3
11601: RET
// export function ScanBase ( side , base_area ) ; begin
11602: LD_INT 0
11604: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11605: NOP4
11609: PUSH
11610: NOP4
11614: PPUSH
11615: LD_INT 81
11617: PUSH
11618: NOP4
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PPUSH
11627: NOP4
11631: ST_TO_ADDR
// end ;
11632: LD_VAR 0 3
11636: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11637: LD_INT 0
11639: PPUSH
11640: PPUSH
11641: PPUSH
11642: PPUSH
// result := false ;
11643: NOP4
11647: PUSH
11648: LD_INT 0
11650: ST_TO_ADDR
// side := GetSide ( unit ) ;
11651: NOP4
11655: PUSH
11656: NOP4
11660: PPUSH
11661: NOP4
11665: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11666: NOP4
11670: PUSH
11671: NOP4
11675: PPUSH
11676: NOP4
11680: ST_TO_ADDR
// case nat of 1 :
11681: NOP4
11685: PUSH
11686: LD_INT 1
11688: DOUBLE
11689: EQUAL
11690: IFTRUE 11694
11692: GO 11705
11694: POP
// tech := tech_lassight ; 2 :
11695: NOP4
11699: PUSH
11700: LD_INT 12
11702: ST_TO_ADDR
11703: GO 11744
11705: LD_INT 2
11707: DOUBLE
11708: EQUAL
11709: IFTRUE 11713
11711: GO 11724
11713: POP
// tech := tech_mortar ; 3 :
11714: NOP4
11718: PUSH
11719: LD_INT 41
11721: ST_TO_ADDR
11722: GO 11744
11724: LD_INT 3
11726: DOUBLE
11727: EQUAL
11728: IFTRUE 11732
11730: GO 11743
11732: POP
// tech := tech_bazooka ; end ;
11733: NOP4
11737: PUSH
11738: LD_INT 44
11740: ST_TO_ADDR
11741: GO 11744
11743: POP
// if Researched ( side , tech ) then
11744: NOP4
11748: PPUSH
11749: NOP4
11753: PPUSH
11754: NOP4
11758: IFFALSE 11785
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11760: NOP4
11764: PUSH
11765: LD_INT 5
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: LD_INT 9
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: LIST
11778: PUSH
11779: NOP4
11783: ARRAY
11784: ST_TO_ADDR
// end ;
11785: LD_VAR 0 2
11789: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11790: LD_INT 0
11792: PPUSH
11793: PPUSH
11794: PPUSH
// if not mines then
11795: NOP4
11799: NOT
11800: IFFALSE 11804
// exit ;
11802: GO 11948
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11804: NOP4
11808: PUSH
11809: LD_INT 81
11811: PUSH
11812: NOP4
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: LD_INT 3
11823: PUSH
11824: LD_INT 21
11826: PUSH
11827: LD_INT 3
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PPUSH
11842: NOP4
11846: ST_TO_ADDR
// for i in mines do
11847: NOP4
11851: PUSH
11852: NOP4
11856: PUSH
11857: FOR_IN
11858: IFFALSE 11946
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11860: NOP4
11864: PUSH
11865: LD_INT 1
11867: ARRAY
11868: PPUSH
11869: NOP4
11873: PUSH
11874: LD_INT 2
11876: ARRAY
11877: PPUSH
11878: NOP4
11882: NOT
11883: IFFALSE 11887
// continue ;
11885: GO 11857
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11887: NOP4
11891: PUSH
11892: LD_INT 1
11894: ARRAY
11895: PPUSH
11896: NOP4
11900: PUSH
11901: LD_INT 2
11903: ARRAY
11904: PPUSH
11905: NOP4
11909: PUSH
11910: NOP4
11914: IN
11915: IFFALSE 11944
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11917: NOP4
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: NOP4
11930: PUSH
11931: LD_INT 2
11933: ARRAY
11934: PPUSH
11935: NOP4
11939: PPUSH
11940: NOP4
// end ;
11944: GO 11857
11946: POP
11947: POP
// end ;
11948: LD_VAR 0 3
11952: RET
// export function Count ( array ) ; var i ; begin
11953: LD_INT 0
11955: PPUSH
11956: PPUSH
// result := 0 ;
11957: NOP4
11961: PUSH
11962: LD_INT 0
11964: ST_TO_ADDR
// for i in array do
11965: NOP4
11969: PUSH
11970: NOP4
11974: PUSH
11975: FOR_IN
11976: IFFALSE 12000
// if i then
11978: NOP4
11982: IFFALSE 11998
// result := result + 1 ;
11984: NOP4
11988: PUSH
11989: NOP4
11993: PUSH
11994: LD_INT 1
11996: PLUS
11997: ST_TO_ADDR
11998: GO 11975
12000: POP
12001: POP
// end ;
12002: LD_VAR 0 2
12006: RET
// export function IsEmpty ( building ) ; begin
12007: LD_INT 0
12009: PPUSH
// if not building then
12010: NOP4
12014: NOT
12015: IFFALSE 12019
// exit ;
12017: GO 12062
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12019: NOP4
12023: PUSH
12024: NOP4
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: NOP4
12036: PPUSH
12037: NOP4
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 58
12048: PUSH
12049: EMPTY
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PPUSH
12056: NOP4
12060: IN
12061: ST_TO_ADDR
// end ;
12062: LD_VAR 0 2
12066: RET
// export function IsNotFull ( building ) ; begin
12067: LD_INT 0
12069: PPUSH
// if not building then
12070: NOP4
12074: NOT
12075: IFFALSE 12079
// exit ;
12077: GO 12098
// result := UnitsInside ( building ) < 6 ;
12079: NOP4
12083: PUSH
12084: NOP4
12088: PPUSH
12089: NOP4
12093: PUSH
12094: LD_INT 6
12096: LESS
12097: ST_TO_ADDR
// end ;
12098: LD_VAR 0 2
12102: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12103: LD_INT 0
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// tmp := [ ] ;
12109: NOP4
12113: PUSH
12114: EMPTY
12115: ST_TO_ADDR
// list := [ ] ;
12116: NOP4
12120: PUSH
12121: EMPTY
12122: ST_TO_ADDR
// for i = 16 to 25 do
12123: NOP4
12127: PUSH
12128: DOUBLE
12129: LD_INT 16
12131: DEC
12132: ST_TO_ADDR
12133: LD_INT 25
12135: PUSH
12136: FOR_TO
12137: IFFALSE 12210
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12139: NOP4
12143: PUSH
12144: NOP4
12148: PUSH
12149: LD_INT 22
12151: PUSH
12152: NOP4
12156: PPUSH
12157: NOP4
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: LD_INT 91
12168: PUSH
12169: NOP4
12173: PUSH
12174: LD_INT 6
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 30
12184: PUSH
12185: NOP4
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: LIST
12198: PUSH
12199: EMPTY
12200: LIST
12201: PPUSH
12202: NOP4
12206: ADD
12207: ST_TO_ADDR
12208: GO 12136
12210: POP
12211: POP
// for i = 1 to tmp do
12212: NOP4
12216: PUSH
12217: DOUBLE
12218: LD_INT 1
12220: DEC
12221: ST_TO_ADDR
12222: NOP4
12226: PUSH
12227: FOR_TO
12228: IFFALSE 12316
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12230: NOP4
12234: PUSH
12235: NOP4
12239: PUSH
12240: NOP4
12244: PUSH
12245: NOP4
12249: ARRAY
12250: PPUSH
12251: NOP4
12255: PUSH
12256: NOP4
12260: PUSH
12261: NOP4
12265: ARRAY
12266: PPUSH
12267: NOP4
12271: PUSH
12272: NOP4
12276: PUSH
12277: NOP4
12281: ARRAY
12282: PPUSH
12283: NOP4
12287: PUSH
12288: NOP4
12292: PUSH
12293: NOP4
12297: ARRAY
12298: PPUSH
12299: NOP4
12303: PUSH
12304: EMPTY
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: PUSH
12310: EMPTY
12311: LIST
12312: ADD
12313: ST_TO_ADDR
12314: GO 12227
12316: POP
12317: POP
// result := list ;
12318: NOP4
12322: PUSH
12323: NOP4
12327: ST_TO_ADDR
// end ;
12328: LD_VAR 0 2
12332: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12333: LD_INT 0
12335: PPUSH
12336: PPUSH
12337: PPUSH
12338: PPUSH
12339: PPUSH
12340: PPUSH
12341: PPUSH
// if not factory then
12342: NOP4
12346: NOT
12347: IFFALSE 12351
// exit ;
12349: GO 12944
// if control = control_apeman then
12351: NOP4
12355: PUSH
12356: LD_INT 5
12358: EQUAL
12359: IFFALSE 12468
// begin tmp := UnitsInside ( factory ) ;
12361: NOP4
12365: PUSH
12366: NOP4
12370: PPUSH
12371: NOP4
12375: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12376: NOP4
12380: PPUSH
12381: LD_INT 25
12383: PUSH
12384: LD_INT 12
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: PPUSH
12391: NOP4
12395: NOT
12396: IFFALSE 12406
// control := control_manual ;
12398: NOP4
12402: PUSH
12403: LD_INT 1
12405: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12406: NOP4
12410: PUSH
12411: NOP4
12415: PPUSH
12416: NOP4
12420: ST_TO_ADDR
// if tmp then
12421: NOP4
12425: IFFALSE 12468
// begin for i in tmp do
12427: NOP4
12431: PUSH
12432: NOP4
12436: PUSH
12437: FOR_IN
12438: IFFALSE 12466
// if i [ 1 ] = b_ext_radio then
12440: NOP4
12444: PUSH
12445: LD_INT 1
12447: ARRAY
12448: PUSH
12449: LD_INT 22
12451: EQUAL
12452: IFFALSE 12464
// begin control := control_remote ;
12454: NOP4
12458: PUSH
12459: LD_INT 2
12461: ST_TO_ADDR
// break ;
12462: GO 12466
// end ;
12464: GO 12437
12466: POP
12467: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12468: NOP4
12472: PPUSH
12473: NOP4
12477: PPUSH
12478: NOP4
12482: PPUSH
12483: NOP4
12487: PPUSH
12488: NOP4
12492: PPUSH
12493: NOP4
12497: IFFALSE 12532
// begin result := [ chassis , engine , control , weapon ] ;
12499: NOP4
12503: PUSH
12504: NOP4
12508: PUSH
12509: NOP4
12513: PUSH
12514: NOP4
12518: PUSH
12519: NOP4
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: ST_TO_ADDR
// exit ;
12530: GO 12944
// end ; _chassis := AvailableChassisList ( factory ) ;
12532: NOP4
12536: PUSH
12537: NOP4
12541: PPUSH
12542: NOP4
12546: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12547: NOP4
12551: PUSH
12552: NOP4
12556: PPUSH
12557: NOP4
12561: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12562: NOP4
12566: PUSH
12567: NOP4
12571: PPUSH
12572: NOP4
12576: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12577: NOP4
12581: PUSH
12582: NOP4
12586: PPUSH
12587: NOP4
12591: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12592: NOP4
12596: NOT
12597: PUSH
12598: NOP4
12602: NOT
12603: OR
12604: PUSH
12605: NOP4
12609: NOT
12610: OR
12611: PUSH
12612: NOP4
12616: NOT
12617: OR
12618: IFFALSE 12653
// begin result := [ chassis , engine , control , weapon ] ;
12620: NOP4
12624: PUSH
12625: NOP4
12629: PUSH
12630: NOP4
12634: PUSH
12635: NOP4
12639: PUSH
12640: NOP4
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: ST_TO_ADDR
// exit ;
12651: GO 12944
// end ; if not chassis in _chassis then
12653: NOP4
12657: PUSH
12658: NOP4
12662: IN
12663: NOT
12664: IFFALSE 12690
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12666: NOP4
12670: PUSH
12671: NOP4
12675: PUSH
12676: LD_INT 1
12678: PPUSH
12679: NOP4
12683: PPUSH
12684: NOP4
12688: ARRAY
12689: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12690: NOP4
12694: PPUSH
12695: NOP4
12699: PPUSH
12700: NOP4
12704: NOT
12705: IFFALSE 12764
// repeat engine := _engine [ 1 ] ;
12707: NOP4
12711: PUSH
12712: NOP4
12716: PUSH
12717: LD_INT 1
12719: ARRAY
12720: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12721: NOP4
12725: PUSH
12726: NOP4
12730: PPUSH
12731: LD_INT 1
12733: PPUSH
12734: NOP4
12738: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12739: NOP4
12743: PPUSH
12744: NOP4
12748: PPUSH
12749: NOP4
12753: PUSH
12754: NOP4
12758: PUSH
12759: EMPTY
12760: EQUAL
12761: OR
12762: IFFALSE 12707
// if not control in _control then
12764: NOP4
12768: PUSH
12769: NOP4
12773: IN
12774: NOT
12775: IFFALSE 12801
// control := _control [ rand ( 1 , _control ) ] ;
12777: NOP4
12781: PUSH
12782: NOP4
12786: PUSH
12787: LD_INT 1
12789: PPUSH
12790: NOP4
12794: PPUSH
12795: NOP4
12799: ARRAY
12800: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12801: NOP4
12805: PPUSH
12806: NOP4
12810: PPUSH
12811: NOP4
12815: NOT
12816: IFFALSE 12875
// repeat weapon := _weapon [ 1 ] ;
12818: NOP4
12822: PUSH
12823: NOP4
12827: PUSH
12828: LD_INT 1
12830: ARRAY
12831: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12832: NOP4
12836: PUSH
12837: NOP4
12841: PPUSH
12842: LD_INT 1
12844: PPUSH
12845: NOP4
12849: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12850: NOP4
12854: PPUSH
12855: NOP4
12859: PPUSH
12860: NOP4
12864: PUSH
12865: NOP4
12869: PUSH
12870: EMPTY
12871: EQUAL
12872: OR
12873: IFFALSE 12818
// result := [ ] ;
12875: NOP4
12879: PUSH
12880: EMPTY
12881: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12882: NOP4
12886: PPUSH
12887: NOP4
12891: PPUSH
12892: NOP4
12896: PPUSH
12897: NOP4
12901: PPUSH
12902: NOP4
12906: PPUSH
12907: NOP4
12911: IFFALSE 12944
// result := [ chassis , engine , control , weapon ] ;
12913: NOP4
12917: PUSH
12918: NOP4
12922: PUSH
12923: NOP4
12927: PUSH
12928: NOP4
12932: PUSH
12933: NOP4
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: LIST
12942: LIST
12943: ST_TO_ADDR
// end ;
12944: LD_VAR 0 6
12948: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12949: LD_INT 0
12951: PPUSH
// if not chassis or not engine then
12952: NOP4
12956: NOT
12957: PUSH
12958: NOP4
12962: NOT
12963: OR
12964: IFFALSE 12968
// exit ;
12966: GO 13164
// case engine of engine_solar :
12968: NOP4
12972: PUSH
12973: LD_INT 2
12975: DOUBLE
12976: EQUAL
12977: IFTRUE 12981
12979: GO 13019
12981: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12982: NOP4
12986: PUSH
12987: LD_INT 11
12989: PUSH
12990: LD_INT 12
12992: PUSH
12993: LD_INT 13
12995: PUSH
12996: LD_INT 14
12998: PUSH
12999: LD_INT 1
13001: PUSH
13002: LD_INT 2
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: ST_TO_ADDR
13017: GO 13148
13019: LD_INT 1
13021: DOUBLE
13022: EQUAL
13023: IFTRUE 13027
13025: GO 13089
13027: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13028: NOP4
13032: PUSH
13033: LD_INT 11
13035: PUSH
13036: LD_INT 12
13038: PUSH
13039: LD_INT 13
13041: PUSH
13042: LD_INT 14
13044: PUSH
13045: LD_INT 1
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 3
13053: PUSH
13054: LD_INT 4
13056: PUSH
13057: LD_INT 5
13059: PUSH
13060: LD_INT 21
13062: PUSH
13063: LD_INT 23
13065: PUSH
13066: LD_INT 22
13068: PUSH
13069: LD_INT 24
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: ST_TO_ADDR
13087: GO 13148
13089: LD_INT 3
13091: DOUBLE
13092: EQUAL
13093: IFTRUE 13097
13095: GO 13147
13097: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13098: NOP4
13102: PUSH
13103: LD_INT 13
13105: PUSH
13106: LD_INT 14
13108: PUSH
13109: LD_INT 2
13111: PUSH
13112: LD_INT 3
13114: PUSH
13115: LD_INT 4
13117: PUSH
13118: LD_INT 5
13120: PUSH
13121: LD_INT 21
13123: PUSH
13124: LD_INT 22
13126: PUSH
13127: LD_INT 23
13129: PUSH
13130: LD_INT 24
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: ST_TO_ADDR
13145: GO 13148
13147: POP
// result := ( chassis in result ) ;
13148: NOP4
13152: PUSH
13153: NOP4
13157: PUSH
13158: NOP4
13162: IN
13163: ST_TO_ADDR
// end ;
13164: LD_VAR 0 3
13168: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13169: LD_INT 0
13171: PPUSH
// if not chassis or not weapon then
13172: NOP4
13176: NOT
13177: PUSH
13178: NOP4
13182: NOT
13183: OR
13184: IFFALSE 13188
// exit ;
13186: GO 14250
// case weapon of us_machine_gun :
13188: NOP4
13192: PUSH
13193: LD_INT 2
13195: DOUBLE
13196: EQUAL
13197: IFTRUE 13201
13199: GO 13231
13201: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13202: NOP4
13206: PUSH
13207: LD_INT 1
13209: PUSH
13210: LD_INT 2
13212: PUSH
13213: LD_INT 3
13215: PUSH
13216: LD_INT 4
13218: PUSH
13219: LD_INT 5
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: LIST
13226: LIST
13227: LIST
13228: ST_TO_ADDR
13229: GO 14234
13231: LD_INT 3
13233: DOUBLE
13234: EQUAL
13235: IFTRUE 13239
13237: GO 13269
13239: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13240: NOP4
13244: PUSH
13245: LD_INT 1
13247: PUSH
13248: LD_INT 2
13250: PUSH
13251: LD_INT 3
13253: PUSH
13254: LD_INT 4
13256: PUSH
13257: LD_INT 5
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: ST_TO_ADDR
13267: GO 14234
13269: LD_INT 11
13271: DOUBLE
13272: EQUAL
13273: IFTRUE 13277
13275: GO 13307
13277: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13278: NOP4
13282: PUSH
13283: LD_INT 1
13285: PUSH
13286: LD_INT 2
13288: PUSH
13289: LD_INT 3
13291: PUSH
13292: LD_INT 4
13294: PUSH
13295: LD_INT 5
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: LIST
13302: LIST
13303: LIST
13304: ST_TO_ADDR
13305: GO 14234
13307: LD_INT 4
13309: DOUBLE
13310: EQUAL
13311: IFTRUE 13315
13313: GO 13341
13315: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13316: NOP4
13320: PUSH
13321: LD_INT 2
13323: PUSH
13324: LD_INT 3
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: LD_INT 5
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: ST_TO_ADDR
13339: GO 14234
13341: LD_INT 5
13343: DOUBLE
13344: EQUAL
13345: IFTRUE 13349
13347: GO 13375
13349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13350: NOP4
13354: PUSH
13355: LD_INT 2
13357: PUSH
13358: LD_INT 3
13360: PUSH
13361: LD_INT 4
13363: PUSH
13364: LD_INT 5
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: ST_TO_ADDR
13373: GO 14234
13375: LD_INT 9
13377: DOUBLE
13378: EQUAL
13379: IFTRUE 13383
13381: GO 13409
13383: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13384: NOP4
13388: PUSH
13389: LD_INT 2
13391: PUSH
13392: LD_INT 3
13394: PUSH
13395: LD_INT 4
13397: PUSH
13398: LD_INT 5
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: LIST
13405: LIST
13406: ST_TO_ADDR
13407: GO 14234
13409: LD_INT 7
13411: DOUBLE
13412: EQUAL
13413: IFTRUE 13417
13415: GO 13443
13417: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13418: NOP4
13422: PUSH
13423: LD_INT 2
13425: PUSH
13426: LD_INT 3
13428: PUSH
13429: LD_INT 4
13431: PUSH
13432: LD_INT 5
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: ST_TO_ADDR
13441: GO 14234
13443: LD_INT 12
13445: DOUBLE
13446: EQUAL
13447: IFTRUE 13451
13449: GO 13477
13451: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13452: NOP4
13456: PUSH
13457: LD_INT 2
13459: PUSH
13460: LD_INT 3
13462: PUSH
13463: LD_INT 4
13465: PUSH
13466: LD_INT 5
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: LIST
13473: LIST
13474: ST_TO_ADDR
13475: GO 14234
13477: LD_INT 13
13479: DOUBLE
13480: EQUAL
13481: IFTRUE 13485
13483: GO 13511
13485: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13486: NOP4
13490: PUSH
13491: LD_INT 2
13493: PUSH
13494: LD_INT 3
13496: PUSH
13497: LD_INT 4
13499: PUSH
13500: LD_INT 5
13502: PUSH
13503: EMPTY
13504: LIST
13505: LIST
13506: LIST
13507: LIST
13508: ST_TO_ADDR
13509: GO 14234
13511: LD_INT 14
13513: DOUBLE
13514: EQUAL
13515: IFTRUE 13519
13517: GO 13537
13519: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13520: NOP4
13524: PUSH
13525: LD_INT 4
13527: PUSH
13528: LD_INT 5
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: ST_TO_ADDR
13535: GO 14234
13537: LD_INT 6
13539: DOUBLE
13540: EQUAL
13541: IFTRUE 13545
13543: GO 13563
13545: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13546: NOP4
13550: PUSH
13551: LD_INT 4
13553: PUSH
13554: LD_INT 5
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: ST_TO_ADDR
13561: GO 14234
13563: LD_INT 10
13565: DOUBLE
13566: EQUAL
13567: IFTRUE 13571
13569: GO 13589
13571: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13572: NOP4
13576: PUSH
13577: LD_INT 4
13579: PUSH
13580: LD_INT 5
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: ST_TO_ADDR
13587: GO 14234
13589: LD_INT 22
13591: DOUBLE
13592: EQUAL
13593: IFTRUE 13597
13595: GO 13623
13597: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13598: NOP4
13602: PUSH
13603: LD_INT 11
13605: PUSH
13606: LD_INT 12
13608: PUSH
13609: LD_INT 13
13611: PUSH
13612: LD_INT 14
13614: PUSH
13615: EMPTY
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: ST_TO_ADDR
13621: GO 14234
13623: LD_INT 23
13625: DOUBLE
13626: EQUAL
13627: IFTRUE 13631
13629: GO 13657
13631: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13632: NOP4
13636: PUSH
13637: LD_INT 11
13639: PUSH
13640: LD_INT 12
13642: PUSH
13643: LD_INT 13
13645: PUSH
13646: LD_INT 14
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: LIST
13653: LIST
13654: ST_TO_ADDR
13655: GO 14234
13657: LD_INT 24
13659: DOUBLE
13660: EQUAL
13661: IFTRUE 13665
13663: GO 13691
13665: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13666: NOP4
13670: PUSH
13671: LD_INT 11
13673: PUSH
13674: LD_INT 12
13676: PUSH
13677: LD_INT 13
13679: PUSH
13680: LD_INT 14
13682: PUSH
13683: EMPTY
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: ST_TO_ADDR
13689: GO 14234
13691: LD_INT 30
13693: DOUBLE
13694: EQUAL
13695: IFTRUE 13699
13697: GO 13725
13699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13700: NOP4
13704: PUSH
13705: LD_INT 11
13707: PUSH
13708: LD_INT 12
13710: PUSH
13711: LD_INT 13
13713: PUSH
13714: LD_INT 14
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: LIST
13721: LIST
13722: ST_TO_ADDR
13723: GO 14234
13725: LD_INT 25
13727: DOUBLE
13728: EQUAL
13729: IFTRUE 13733
13731: GO 13751
13733: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13734: NOP4
13738: PUSH
13739: LD_INT 13
13741: PUSH
13742: LD_INT 14
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: ST_TO_ADDR
13749: GO 14234
13751: LD_INT 27
13753: DOUBLE
13754: EQUAL
13755: IFTRUE 13759
13757: GO 13777
13759: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13760: NOP4
13764: PUSH
13765: LD_INT 13
13767: PUSH
13768: LD_INT 14
13770: PUSH
13771: EMPTY
13772: LIST
13773: LIST
13774: ST_TO_ADDR
13775: GO 14234
13777: NOP4
13781: DOUBLE
13782: EQUAL
13783: IFTRUE 13787
13785: GO 13813
13787: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13788: NOP4
13792: PUSH
13793: LD_INT 11
13795: PUSH
13796: LD_INT 12
13798: PUSH
13799: LD_INT 13
13801: PUSH
13802: LD_INT 14
13804: PUSH
13805: EMPTY
13806: LIST
13807: LIST
13808: LIST
13809: LIST
13810: ST_TO_ADDR
13811: GO 14234
13813: LD_INT 28
13815: DOUBLE
13816: EQUAL
13817: IFTRUE 13821
13819: GO 13839
13821: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13822: NOP4
13826: PUSH
13827: LD_INT 13
13829: PUSH
13830: LD_INT 14
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: ST_TO_ADDR
13837: GO 14234
13839: LD_INT 29
13841: DOUBLE
13842: EQUAL
13843: IFTRUE 13847
13845: GO 13865
13847: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13848: NOP4
13852: PUSH
13853: LD_INT 13
13855: PUSH
13856: LD_INT 14
13858: PUSH
13859: EMPTY
13860: LIST
13861: LIST
13862: ST_TO_ADDR
13863: GO 14234
13865: LD_INT 31
13867: DOUBLE
13868: EQUAL
13869: IFTRUE 13873
13871: GO 13891
13873: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13874: NOP4
13878: PUSH
13879: LD_INT 13
13881: PUSH
13882: LD_INT 14
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: ST_TO_ADDR
13889: GO 14234
13891: LD_INT 26
13893: DOUBLE
13894: EQUAL
13895: IFTRUE 13899
13897: GO 13917
13899: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13900: NOP4
13904: PUSH
13905: LD_INT 13
13907: PUSH
13908: LD_INT 14
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: ST_TO_ADDR
13915: GO 14234
13917: LD_INT 42
13919: DOUBLE
13920: EQUAL
13921: IFTRUE 13925
13923: GO 13951
13925: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13926: NOP4
13930: PUSH
13931: LD_INT 21
13933: PUSH
13934: LD_INT 22
13936: PUSH
13937: LD_INT 23
13939: PUSH
13940: LD_INT 24
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: ST_TO_ADDR
13949: GO 14234
13951: LD_INT 43
13953: DOUBLE
13954: EQUAL
13955: IFTRUE 13959
13957: GO 13985
13959: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13960: NOP4
13964: PUSH
13965: LD_INT 21
13967: PUSH
13968: LD_INT 22
13970: PUSH
13971: LD_INT 23
13973: PUSH
13974: LD_INT 24
13976: PUSH
13977: EMPTY
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: ST_TO_ADDR
13983: GO 14234
13985: LD_INT 44
13987: DOUBLE
13988: EQUAL
13989: IFTRUE 13993
13991: GO 14019
13993: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13994: NOP4
13998: PUSH
13999: LD_INT 21
14001: PUSH
14002: LD_INT 22
14004: PUSH
14005: LD_INT 23
14007: PUSH
14008: LD_INT 24
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: LIST
14015: LIST
14016: ST_TO_ADDR
14017: GO 14234
14019: LD_INT 45
14021: DOUBLE
14022: EQUAL
14023: IFTRUE 14027
14025: GO 14053
14027: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14028: NOP4
14032: PUSH
14033: LD_INT 21
14035: PUSH
14036: LD_INT 22
14038: PUSH
14039: LD_INT 23
14041: PUSH
14042: LD_INT 24
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: LIST
14049: LIST
14050: ST_TO_ADDR
14051: GO 14234
14053: LD_INT 49
14055: DOUBLE
14056: EQUAL
14057: IFTRUE 14061
14059: GO 14087
14061: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14062: NOP4
14066: PUSH
14067: LD_INT 21
14069: PUSH
14070: LD_INT 22
14072: PUSH
14073: LD_INT 23
14075: PUSH
14076: LD_INT 24
14078: PUSH
14079: EMPTY
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: ST_TO_ADDR
14085: GO 14234
14087: LD_INT 51
14089: DOUBLE
14090: EQUAL
14091: IFTRUE 14095
14093: GO 14121
14095: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14096: NOP4
14100: PUSH
14101: LD_INT 21
14103: PUSH
14104: LD_INT 22
14106: PUSH
14107: LD_INT 23
14109: PUSH
14110: LD_INT 24
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: ST_TO_ADDR
14119: GO 14234
14121: LD_INT 52
14123: DOUBLE
14124: EQUAL
14125: IFTRUE 14129
14127: GO 14155
14129: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14130: NOP4
14134: PUSH
14135: LD_INT 21
14137: PUSH
14138: LD_INT 22
14140: PUSH
14141: LD_INT 23
14143: PUSH
14144: LD_INT 24
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: ST_TO_ADDR
14153: GO 14234
14155: LD_INT 53
14157: DOUBLE
14158: EQUAL
14159: IFTRUE 14163
14161: GO 14181
14163: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14164: NOP4
14168: PUSH
14169: LD_INT 23
14171: PUSH
14172: LD_INT 24
14174: PUSH
14175: EMPTY
14176: LIST
14177: LIST
14178: ST_TO_ADDR
14179: GO 14234
14181: LD_INT 46
14183: DOUBLE
14184: EQUAL
14185: IFTRUE 14189
14187: GO 14207
14189: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14190: NOP4
14194: PUSH
14195: LD_INT 23
14197: PUSH
14198: LD_INT 24
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: ST_TO_ADDR
14205: GO 14234
14207: LD_INT 47
14209: DOUBLE
14210: EQUAL
14211: IFTRUE 14215
14213: GO 14233
14215: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14216: NOP4
14220: PUSH
14221: LD_INT 23
14223: PUSH
14224: LD_INT 24
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: ST_TO_ADDR
14231: GO 14234
14233: POP
// result := ( chassis in result ) ;
14234: NOP4
14238: PUSH
14239: NOP4
14243: PUSH
14244: NOP4
14248: IN
14249: ST_TO_ADDR
// end ;
14250: LD_VAR 0 3
14254: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14255: LD_INT 0
14257: PPUSH
14258: PPUSH
14259: PPUSH
14260: PPUSH
14261: PPUSH
14262: PPUSH
14263: PPUSH
// result := array ;
14264: NOP4
14268: PUSH
14269: NOP4
14273: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14274: NOP4
14278: NOT
14279: PUSH
14280: NOP4
14284: NOT
14285: OR
14286: PUSH
14287: NOP4
14291: NOT
14292: OR
14293: PUSH
14294: NOP4
14298: PUSH
14299: NOP4
14303: GREATER
14304: OR
14305: PUSH
14306: NOP4
14310: PUSH
14311: NOP4
14315: GREATER
14316: OR
14317: IFFALSE 14321
// exit ;
14319: GO 14617
// if direction then
14321: NOP4
14325: IFFALSE 14389
// begin d := 1 ;
14327: NOP4
14331: PUSH
14332: LD_INT 1
14334: ST_TO_ADDR
// if i_from > i_to then
14335: NOP4
14339: PUSH
14340: NOP4
14344: GREATER
14345: IFFALSE 14371
// length := ( array - i_from ) + i_to else
14347: NOP4
14351: PUSH
14352: NOP4
14356: PUSH
14357: NOP4
14361: MINUS
14362: PUSH
14363: NOP4
14367: PLUS
14368: ST_TO_ADDR
14369: GO 14387
// length := i_to - i_from ;
14371: NOP4
14375: PUSH
14376: NOP4
14380: PUSH
14381: NOP4
14385: MINUS
14386: ST_TO_ADDR
// end else
14387: GO 14450
// begin d := - 1 ;
14389: NOP4
14393: PUSH
14394: LD_INT 1
14396: NEG
14397: ST_TO_ADDR
// if i_from > i_to then
14398: NOP4
14402: PUSH
14403: NOP4
14407: GREATER
14408: IFFALSE 14428
// length := i_from - i_to else
14410: NOP4
14414: PUSH
14415: NOP4
14419: PUSH
14420: NOP4
14424: MINUS
14425: ST_TO_ADDR
14426: GO 14450
// length := ( array - i_to ) + i_from ;
14428: NOP4
14432: PUSH
14433: NOP4
14437: PUSH
14438: NOP4
14442: MINUS
14443: PUSH
14444: NOP4
14448: PLUS
14449: ST_TO_ADDR
// end ; if not length then
14450: NOP4
14454: NOT
14455: IFFALSE 14459
// exit ;
14457: GO 14617
// tmp := array ;
14459: NOP4
14463: PUSH
14464: NOP4
14468: ST_TO_ADDR
// for i = 1 to length do
14469: NOP4
14473: PUSH
14474: DOUBLE
14475: LD_INT 1
14477: DEC
14478: ST_TO_ADDR
14479: NOP4
14483: PUSH
14484: FOR_TO
14485: IFFALSE 14605
// begin for j = 1 to array do
14487: NOP4
14491: PUSH
14492: DOUBLE
14493: LD_INT 1
14495: DEC
14496: ST_TO_ADDR
14497: NOP4
14501: PUSH
14502: FOR_TO
14503: IFFALSE 14591
// begin k := j + d ;
14505: NOP4
14509: PUSH
14510: NOP4
14514: PUSH
14515: NOP4
14519: PLUS
14520: ST_TO_ADDR
// if k > array then
14521: NOP4
14525: PUSH
14526: NOP4
14530: GREATER
14531: IFFALSE 14541
// k := 1 ;
14533: NOP4
14537: PUSH
14538: LD_INT 1
14540: ST_TO_ADDR
// if not k then
14541: NOP4
14545: NOT
14546: IFFALSE 14558
// k := array ;
14548: NOP4
14552: PUSH
14553: NOP4
14557: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14558: NOP4
14562: PUSH
14563: NOP4
14567: PPUSH
14568: NOP4
14572: PPUSH
14573: NOP4
14577: PUSH
14578: NOP4
14582: ARRAY
14583: PPUSH
14584: NOP4
14588: ST_TO_ADDR
// end ;
14589: GO 14502
14591: POP
14592: POP
// array := tmp ;
14593: NOP4
14597: PUSH
14598: NOP4
14602: ST_TO_ADDR
// end ;
14603: GO 14484
14605: POP
14606: POP
// result := array ;
14607: NOP4
14611: PUSH
14612: NOP4
14616: ST_TO_ADDR
// end ;
14617: LD_VAR 0 5
14621: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14622: LD_INT 0
14624: PPUSH
14625: PPUSH
// result := 0 ;
14626: NOP4
14630: PUSH
14631: LD_INT 0
14633: ST_TO_ADDR
// if not array or not value in array then
14634: NOP4
14638: NOT
14639: PUSH
14640: NOP4
14644: PUSH
14645: NOP4
14649: IN
14650: NOT
14651: OR
14652: IFFALSE 14656
// exit ;
14654: GO 14710
// for i = 1 to array do
14656: NOP4
14660: PUSH
14661: DOUBLE
14662: LD_INT 1
14664: DEC
14665: ST_TO_ADDR
14666: NOP4
14670: PUSH
14671: FOR_TO
14672: IFFALSE 14708
// if value = array [ i ] then
14674: NOP4
14678: PUSH
14679: NOP4
14683: PUSH
14684: NOP4
14688: ARRAY
14689: EQUAL
14690: IFFALSE 14706
// begin result := i ;
14692: NOP4
14696: PUSH
14697: NOP4
14701: ST_TO_ADDR
// exit ;
14702: POP
14703: POP
14704: GO 14710
// end ;
14706: GO 14671
14708: POP
14709: POP
// end ;
14710: LD_VAR 0 3
14714: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14715: LD_INT 0
14717: PPUSH
// vc_chassis := chassis ;
14718: LD_ADDR_OWVAR 37
14722: PUSH
14723: NOP4
14727: ST_TO_ADDR
// vc_engine := engine ;
14728: LD_ADDR_OWVAR 39
14732: PUSH
14733: NOP4
14737: ST_TO_ADDR
// vc_control := control ;
14738: LD_ADDR_OWVAR 38
14742: PUSH
14743: NOP4
14747: ST_TO_ADDR
// vc_weapon := weapon ;
14748: LD_ADDR_OWVAR 40
14752: PUSH
14753: NOP4
14757: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14758: LD_ADDR_OWVAR 41
14762: PUSH
14763: NOP4
14767: ST_TO_ADDR
// end ;
14768: LD_VAR 0 6
14772: RET
// export function WantPlant ( unit ) ; var task ; begin
14773: LD_INT 0
14775: PPUSH
14776: PPUSH
// result := false ;
14777: NOP4
14781: PUSH
14782: LD_INT 0
14784: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14785: NOP4
14789: PUSH
14790: NOP4
14794: PPUSH
14795: NOP4
14799: ST_TO_ADDR
// if task then
14800: NOP4
14804: IFFALSE 14832
// if task [ 1 ] [ 1 ] = p then
14806: NOP4
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: PUSH
14815: LD_INT 1
14817: ARRAY
14818: PUSH
14819: LD_STRING p
14821: EQUAL
14822: IFFALSE 14832
// result := true ;
14824: NOP4
14828: PUSH
14829: LD_INT 1
14831: ST_TO_ADDR
// end ;
14832: LD_VAR 0 2
14836: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14837: LD_INT 0
14839: PPUSH
14840: PPUSH
14841: PPUSH
14842: PPUSH
// if pos < 1 then
14843: NOP4
14847: PUSH
14848: LD_INT 1
14850: LESS
14851: IFFALSE 14855
// exit ;
14853: GO 15158
// if pos = 1 then
14855: NOP4
14859: PUSH
14860: LD_INT 1
14862: EQUAL
14863: IFFALSE 14896
// result := Replace ( arr , pos [ 1 ] , value ) else
14865: NOP4
14869: PUSH
14870: NOP4
14874: PPUSH
14875: NOP4
14879: PUSH
14880: LD_INT 1
14882: ARRAY
14883: PPUSH
14884: NOP4
14888: PPUSH
14889: NOP4
14893: ST_TO_ADDR
14894: GO 15158
// begin tmp := arr ;
14896: NOP4
14900: PUSH
14901: NOP4
14905: ST_TO_ADDR
// s_arr := [ tmp ] ;
14906: NOP4
14910: PUSH
14911: NOP4
14915: PUSH
14916: EMPTY
14917: LIST
14918: ST_TO_ADDR
// for i = 1 to pos - 1 do
14919: NOP4
14923: PUSH
14924: DOUBLE
14925: LD_INT 1
14927: DEC
14928: ST_TO_ADDR
14929: NOP4
14933: PUSH
14934: LD_INT 1
14936: MINUS
14937: PUSH
14938: FOR_TO
14939: IFFALSE 14984
// begin tmp := tmp [ pos [ i ] ] ;
14941: NOP4
14945: PUSH
14946: NOP4
14950: PUSH
14951: NOP4
14955: PUSH
14956: NOP4
14960: ARRAY
14961: ARRAY
14962: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14963: NOP4
14967: PUSH
14968: NOP4
14972: PUSH
14973: NOP4
14977: PUSH
14978: EMPTY
14979: LIST
14980: ADD
14981: ST_TO_ADDR
// end ;
14982: GO 14938
14984: POP
14985: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14986: NOP4
14990: PUSH
14991: NOP4
14995: PPUSH
14996: NOP4
15000: PUSH
15001: NOP4
15005: ARRAY
15006: PPUSH
15007: NOP4
15011: PPUSH
15012: NOP4
15016: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15017: NOP4
15021: PUSH
15022: NOP4
15026: PPUSH
15027: NOP4
15031: PPUSH
15032: NOP4
15036: PPUSH
15037: NOP4
15041: ST_TO_ADDR
// for i = s_arr downto 2 do
15042: NOP4
15046: PUSH
15047: DOUBLE
15048: NOP4
15052: INC
15053: ST_TO_ADDR
15054: LD_INT 2
15056: PUSH
15057: FOR_DOWNTO
15058: IFFALSE 15142
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15060: NOP4
15064: PUSH
15065: NOP4
15069: PUSH
15070: NOP4
15074: PUSH
15075: LD_INT 1
15077: MINUS
15078: ARRAY
15079: PPUSH
15080: NOP4
15084: PUSH
15085: NOP4
15089: PUSH
15090: LD_INT 1
15092: MINUS
15093: ARRAY
15094: PPUSH
15095: NOP4
15099: PUSH
15100: NOP4
15104: ARRAY
15105: PPUSH
15106: NOP4
15110: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15111: NOP4
15115: PUSH
15116: NOP4
15120: PPUSH
15121: NOP4
15125: PUSH
15126: LD_INT 1
15128: MINUS
15129: PPUSH
15130: NOP4
15134: PPUSH
15135: NOP4
15139: ST_TO_ADDR
// end ;
15140: GO 15057
15142: POP
15143: POP
// result := s_arr [ 1 ] ;
15144: NOP4
15148: PUSH
15149: NOP4
15153: PUSH
15154: LD_INT 1
15156: ARRAY
15157: ST_TO_ADDR
// end ; end ;
15158: LD_VAR 0 4
15162: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15163: LD_INT 0
15165: PPUSH
15166: PPUSH
// if not list then
15167: NOP4
15171: NOT
15172: IFFALSE 15176
// exit ;
15174: GO 15267
// i := list [ pos1 ] ;
15176: NOP4
15180: PUSH
15181: NOP4
15185: PUSH
15186: NOP4
15190: ARRAY
15191: ST_TO_ADDR
// if not i then
15192: NOP4
15196: NOT
15197: IFFALSE 15201
// exit ;
15199: GO 15267
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15201: NOP4
15205: PUSH
15206: NOP4
15210: PPUSH
15211: NOP4
15215: PPUSH
15216: NOP4
15220: PUSH
15221: NOP4
15225: ARRAY
15226: PPUSH
15227: NOP4
15231: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15232: NOP4
15236: PUSH
15237: NOP4
15241: PPUSH
15242: NOP4
15246: PPUSH
15247: NOP4
15251: PPUSH
15252: NOP4
15256: ST_TO_ADDR
// result := list ;
15257: NOP4
15261: PUSH
15262: NOP4
15266: ST_TO_ADDR
// end ;
15267: LD_VAR 0 4
15271: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15272: LD_INT 0
15274: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15275: NOP4
15279: PUSH
15280: NOP4
15284: PPUSH
15285: NOP4
15289: PPUSH
15290: NOP4
15294: PPUSH
15295: NOP4
15299: PPUSH
15300: NOP4
15304: PPUSH
15305: NOP4
15309: PPUSH
15310: NOP4
15314: PPUSH
15315: NOP4
15319: ST_TO_ADDR
// end ;
15320: LD_VAR 0 5
15324: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15325: LD_INT 0
15327: PPUSH
15328: PPUSH
15329: PPUSH
15330: PPUSH
// if not list then
15331: NOP4
15335: NOT
15336: IFFALSE 15340
// exit ;
15338: GO 15728
// result := [ ] ;
15340: NOP4
15344: PUSH
15345: EMPTY
15346: ST_TO_ADDR
// for i in list do
15347: NOP4
15351: PUSH
15352: NOP4
15356: PUSH
15357: FOR_IN
15358: IFFALSE 15560
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15360: NOP4
15364: PUSH
15365: NOP4
15369: PPUSH
15370: NOP4
15374: PPUSH
15375: NOP4
15379: PPUSH
15380: NOP4
15384: ST_TO_ADDR
// if not result then
15385: NOP4
15389: NOT
15390: IFFALSE 15416
// result := [ [ i , tmp ] ] else
15392: NOP4
15396: PUSH
15397: NOP4
15401: PUSH
15402: NOP4
15406: PUSH
15407: EMPTY
15408: LIST
15409: LIST
15410: PUSH
15411: EMPTY
15412: LIST
15413: ST_TO_ADDR
15414: GO 15558
// begin if result [ result ] [ 2 ] < tmp then
15416: NOP4
15420: PUSH
15421: NOP4
15425: ARRAY
15426: PUSH
15427: LD_INT 2
15429: ARRAY
15430: PUSH
15431: NOP4
15435: LESS
15436: IFFALSE 15478
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15438: NOP4
15442: PUSH
15443: NOP4
15447: PPUSH
15448: NOP4
15452: PUSH
15453: LD_INT 1
15455: PLUS
15456: PPUSH
15457: NOP4
15461: PUSH
15462: NOP4
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: PPUSH
15471: NOP4
15475: ST_TO_ADDR
15476: GO 15558
// for j = 1 to result do
15478: NOP4
15482: PUSH
15483: DOUBLE
15484: LD_INT 1
15486: DEC
15487: ST_TO_ADDR
15488: NOP4
15492: PUSH
15493: FOR_TO
15494: IFFALSE 15556
// begin if tmp < result [ j ] [ 2 ] then
15496: NOP4
15500: PUSH
15501: NOP4
15505: PUSH
15506: NOP4
15510: ARRAY
15511: PUSH
15512: LD_INT 2
15514: ARRAY
15515: LESS
15516: IFFALSE 15554
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15518: NOP4
15522: PUSH
15523: NOP4
15527: PPUSH
15528: NOP4
15532: PPUSH
15533: NOP4
15537: PUSH
15538: NOP4
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PPUSH
15547: NOP4
15551: ST_TO_ADDR
// break ;
15552: GO 15556
// end ; end ;
15554: GO 15493
15556: POP
15557: POP
// end ; end ;
15558: GO 15357
15560: POP
15561: POP
// if result and not asc then
15562: NOP4
15566: PUSH
15567: NOP4
15571: NOT
15572: AND
15573: IFFALSE 15648
// begin tmp := result ;
15575: NOP4
15579: PUSH
15580: NOP4
15584: ST_TO_ADDR
// for i = tmp downto 1 do
15585: NOP4
15589: PUSH
15590: DOUBLE
15591: NOP4
15595: INC
15596: ST_TO_ADDR
15597: LD_INT 1
15599: PUSH
15600: FOR_DOWNTO
15601: IFFALSE 15646
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15603: NOP4
15607: PUSH
15608: NOP4
15612: PPUSH
15613: NOP4
15617: PUSH
15618: NOP4
15622: MINUS
15623: PUSH
15624: LD_INT 1
15626: PLUS
15627: PPUSH
15628: NOP4
15632: PUSH
15633: NOP4
15637: ARRAY
15638: PPUSH
15639: NOP4
15643: ST_TO_ADDR
15644: GO 15600
15646: POP
15647: POP
// end ; tmp := [ ] ;
15648: NOP4
15652: PUSH
15653: EMPTY
15654: ST_TO_ADDR
// if mode then
15655: NOP4
15659: IFFALSE 15728
// begin for i = 1 to result do
15661: NOP4
15665: PUSH
15666: DOUBLE
15667: LD_INT 1
15669: DEC
15670: ST_TO_ADDR
15671: NOP4
15675: PUSH
15676: FOR_TO
15677: IFFALSE 15716
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15679: NOP4
15683: PUSH
15684: NOP4
15688: PPUSH
15689: NOP4
15693: PPUSH
15694: NOP4
15698: PUSH
15699: NOP4
15703: ARRAY
15704: PUSH
15705: LD_INT 1
15707: ARRAY
15708: PPUSH
15709: NOP4
15713: ST_TO_ADDR
15714: GO 15676
15716: POP
15717: POP
// result := tmp ;
15718: NOP4
15722: PUSH
15723: NOP4
15727: ST_TO_ADDR
// end ; end ;
15728: LD_VAR 0 6
15732: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15733: LD_INT 0
15735: PPUSH
15736: PPUSH
15737: PPUSH
15738: PPUSH
15739: PPUSH
15740: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15741: NOP4
15745: PUSH
15746: LD_INT 0
15748: PUSH
15749: LD_INT 0
15751: PUSH
15752: LD_INT 0
15754: PUSH
15755: EMPTY
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: LIST
15761: LIST
15762: ST_TO_ADDR
// if not x or not y then
15763: NOP4
15767: NOT
15768: PUSH
15769: NOP4
15773: NOT
15774: OR
15775: IFFALSE 15779
// exit ;
15777: GO 17431
// if not range then
15779: NOP4
15783: NOT
15784: IFFALSE 15794
// range := 10 ;
15786: NOP4
15790: PUSH
15791: LD_INT 10
15793: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15794: NOP4
15798: PUSH
15799: LD_INT 81
15801: PUSH
15802: NOP4
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PUSH
15811: LD_INT 92
15813: PUSH
15814: NOP4
15818: PUSH
15819: NOP4
15823: PUSH
15824: NOP4
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: PUSH
15835: LD_INT 3
15837: PUSH
15838: LD_INT 21
15840: PUSH
15841: LD_INT 3
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: EMPTY
15853: LIST
15854: LIST
15855: LIST
15856: PPUSH
15857: NOP4
15861: ST_TO_ADDR
// if not tmp then
15862: NOP4
15866: NOT
15867: IFFALSE 15871
// exit ;
15869: GO 17431
// for i in tmp do
15871: NOP4
15875: PUSH
15876: NOP4
15880: PUSH
15881: FOR_IN
15882: IFFALSE 17406
// begin points := [ 0 , 0 , 0 ] ;
15884: NOP4
15888: PUSH
15889: LD_INT 0
15891: PUSH
15892: LD_INT 0
15894: PUSH
15895: LD_INT 0
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: LIST
15902: ST_TO_ADDR
// bpoints := 1 ;
15903: NOP4
15907: PUSH
15908: LD_INT 1
15910: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15911: NOP4
15915: PPUSH
15916: NOP4
15920: PUSH
15921: LD_INT 1
15923: DOUBLE
15924: EQUAL
15925: IFTRUE 15929
15927: GO 16507
15929: POP
// begin if GetClass ( i ) = 1 then
15930: NOP4
15934: PPUSH
15935: NOP4
15939: PUSH
15940: LD_INT 1
15942: EQUAL
15943: IFFALSE 15964
// points := [ 10 , 5 , 3 ] ;
15945: NOP4
15949: PUSH
15950: LD_INT 10
15952: PUSH
15953: LD_INT 5
15955: PUSH
15956: LD_INT 3
15958: PUSH
15959: EMPTY
15960: LIST
15961: LIST
15962: LIST
15963: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15964: NOP4
15968: PPUSH
15969: NOP4
15973: PUSH
15974: LD_INT 2
15976: PUSH
15977: LD_INT 3
15979: PUSH
15980: LD_INT 4
15982: PUSH
15983: EMPTY
15984: LIST
15985: LIST
15986: LIST
15987: IN
15988: IFFALSE 16009
// points := [ 3 , 2 , 1 ] ;
15990: NOP4
15994: PUSH
15995: LD_INT 3
15997: PUSH
15998: LD_INT 2
16000: PUSH
16001: LD_INT 1
16003: PUSH
16004: EMPTY
16005: LIST
16006: LIST
16007: LIST
16008: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16009: NOP4
16013: PPUSH
16014: NOP4
16018: PUSH
16019: LD_INT 5
16021: EQUAL
16022: IFFALSE 16043
// points := [ 130 , 5 , 2 ] ;
16024: NOP4
16028: PUSH
16029: LD_INT 130
16031: PUSH
16032: LD_INT 5
16034: PUSH
16035: LD_INT 2
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: LIST
16042: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16043: NOP4
16047: PPUSH
16048: NOP4
16052: PUSH
16053: LD_INT 8
16055: EQUAL
16056: IFFALSE 16077
// points := [ 35 , 35 , 30 ] ;
16058: NOP4
16062: PUSH
16063: LD_INT 35
16065: PUSH
16066: LD_INT 35
16068: PUSH
16069: LD_INT 30
16071: PUSH
16072: EMPTY
16073: LIST
16074: LIST
16075: LIST
16076: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16077: NOP4
16081: PPUSH
16082: NOP4
16086: PUSH
16087: LD_INT 9
16089: EQUAL
16090: IFFALSE 16111
// points := [ 20 , 55 , 40 ] ;
16092: NOP4
16096: PUSH
16097: LD_INT 20
16099: PUSH
16100: LD_INT 55
16102: PUSH
16103: LD_INT 40
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: LIST
16110: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16111: NOP4
16115: PPUSH
16116: NOP4
16120: PUSH
16121: LD_INT 12
16123: PUSH
16124: LD_INT 16
16126: PUSH
16127: EMPTY
16128: LIST
16129: LIST
16130: IN
16131: IFFALSE 16152
// points := [ 5 , 3 , 2 ] ;
16133: NOP4
16137: PUSH
16138: LD_INT 5
16140: PUSH
16141: LD_INT 3
16143: PUSH
16144: LD_INT 2
16146: PUSH
16147: EMPTY
16148: LIST
16149: LIST
16150: LIST
16151: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16152: NOP4
16156: PPUSH
16157: NOP4
16161: PUSH
16162: LD_INT 17
16164: EQUAL
16165: IFFALSE 16186
// points := [ 100 , 50 , 75 ] ;
16167: NOP4
16171: PUSH
16172: LD_INT 100
16174: PUSH
16175: LD_INT 50
16177: PUSH
16178: LD_INT 75
16180: PUSH
16181: EMPTY
16182: LIST
16183: LIST
16184: LIST
16185: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16186: NOP4
16190: PPUSH
16191: NOP4
16195: PUSH
16196: LD_INT 15
16198: EQUAL
16199: IFFALSE 16220
// points := [ 10 , 5 , 3 ] ;
16201: NOP4
16205: PUSH
16206: LD_INT 10
16208: PUSH
16209: LD_INT 5
16211: PUSH
16212: LD_INT 3
16214: PUSH
16215: EMPTY
16216: LIST
16217: LIST
16218: LIST
16219: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16220: NOP4
16224: PPUSH
16225: NOP4
16229: PUSH
16230: LD_INT 14
16232: EQUAL
16233: IFFALSE 16254
// points := [ 10 , 0 , 0 ] ;
16235: NOP4
16239: PUSH
16240: LD_INT 10
16242: PUSH
16243: LD_INT 0
16245: PUSH
16246: LD_INT 0
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: LIST
16253: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16254: NOP4
16258: PPUSH
16259: NOP4
16263: PUSH
16264: LD_INT 11
16266: EQUAL
16267: IFFALSE 16288
// points := [ 30 , 10 , 5 ] ;
16269: NOP4
16273: PUSH
16274: LD_INT 30
16276: PUSH
16277: LD_INT 10
16279: PUSH
16280: LD_INT 5
16282: PUSH
16283: EMPTY
16284: LIST
16285: LIST
16286: LIST
16287: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16288: NOP4
16292: PPUSH
16293: LD_INT 5
16295: PPUSH
16296: NOP4
16300: PUSH
16301: LD_INT 2
16303: EQUAL
16304: IFFALSE 16321
// bpoints := bpoints * 1.8 ;
16306: NOP4
16310: PUSH
16311: NOP4
16315: PUSH
16316: LD_REAL  1.80000000000000E+0000
16319: MUL
16320: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16321: NOP4
16325: PPUSH
16326: NOP4
16330: PUSH
16331: LD_INT 1
16333: PUSH
16334: LD_INT 2
16336: PUSH
16337: LD_INT 3
16339: PUSH
16340: LD_INT 4
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: LIST
16347: LIST
16348: IN
16349: PUSH
16350: NOP4
16354: PPUSH
16355: LD_INT 51
16357: PPUSH
16358: NOP4
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: IFFALSE 16384
// bpoints := bpoints * 1.2 ;
16369: NOP4
16373: PUSH
16374: NOP4
16378: PUSH
16379: LD_REAL  1.20000000000000E+0000
16382: MUL
16383: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16384: NOP4
16388: PPUSH
16389: NOP4
16393: PUSH
16394: LD_INT 5
16396: PUSH
16397: LD_INT 7
16399: PUSH
16400: LD_INT 9
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: LIST
16407: IN
16408: PUSH
16409: NOP4
16413: PPUSH
16414: LD_INT 52
16416: PPUSH
16417: NOP4
16421: PUSH
16422: LD_INT 2
16424: EQUAL
16425: AND
16426: IFFALSE 16443
// bpoints := bpoints * 1.5 ;
16428: NOP4
16432: PUSH
16433: NOP4
16437: PUSH
16438: LD_REAL  1.50000000000000E+0000
16441: MUL
16442: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16443: NOP4
16447: PPUSH
16448: LD_INT 66
16450: PPUSH
16451: NOP4
16455: PUSH
16456: LD_INT 2
16458: EQUAL
16459: IFFALSE 16476
// bpoints := bpoints * 1.1 ;
16461: NOP4
16465: PUSH
16466: NOP4
16470: PUSH
16471: LD_REAL  1.10000000000000E+0000
16474: MUL
16475: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16476: NOP4
16480: PUSH
16481: NOP4
16485: PUSH
16486: NOP4
16490: PPUSH
16491: LD_INT 1
16493: PPUSH
16494: NOP4
16498: PUSH
16499: LD_REAL  1.15000000000000E+0000
16502: MUL
16503: MUL
16504: ST_TO_ADDR
// end ; unit_vehicle :
16505: GO 17335
16507: LD_INT 2
16509: DOUBLE
16510: EQUAL
16511: IFTRUE 16515
16513: GO 17323
16515: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16516: NOP4
16520: PPUSH
16521: NOP4
16525: PUSH
16526: LD_INT 2
16528: PUSH
16529: LD_INT 42
16531: PUSH
16532: LD_INT 24
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: LIST
16539: IN
16540: IFFALSE 16561
// points := [ 25 , 5 , 3 ] ;
16542: NOP4
16546: PUSH
16547: LD_INT 25
16549: PUSH
16550: LD_INT 5
16552: PUSH
16553: LD_INT 3
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: LIST
16560: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16561: NOP4
16565: PPUSH
16566: NOP4
16570: PUSH
16571: LD_INT 4
16573: PUSH
16574: LD_INT 43
16576: PUSH
16577: LD_INT 25
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: LIST
16584: IN
16585: IFFALSE 16606
// points := [ 40 , 15 , 5 ] ;
16587: NOP4
16591: PUSH
16592: LD_INT 40
16594: PUSH
16595: LD_INT 15
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: LIST
16605: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16606: NOP4
16610: PPUSH
16611: NOP4
16615: PUSH
16616: LD_INT 3
16618: PUSH
16619: LD_INT 23
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: IN
16626: IFFALSE 16647
// points := [ 7 , 25 , 8 ] ;
16628: NOP4
16632: PUSH
16633: LD_INT 7
16635: PUSH
16636: LD_INT 25
16638: PUSH
16639: LD_INT 8
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: LIST
16646: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16647: NOP4
16651: PPUSH
16652: NOP4
16656: PUSH
16657: LD_INT 5
16659: PUSH
16660: LD_INT 27
16662: PUSH
16663: LD_INT 44
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: LIST
16670: IN
16671: IFFALSE 16692
// points := [ 14 , 50 , 16 ] ;
16673: NOP4
16677: PUSH
16678: LD_INT 14
16680: PUSH
16681: LD_INT 50
16683: PUSH
16684: LD_INT 16
16686: PUSH
16687: EMPTY
16688: LIST
16689: LIST
16690: LIST
16691: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16692: NOP4
16696: PPUSH
16697: NOP4
16701: PUSH
16702: LD_INT 6
16704: PUSH
16705: LD_INT 46
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: IN
16712: IFFALSE 16733
// points := [ 32 , 120 , 70 ] ;
16714: NOP4
16718: PUSH
16719: LD_INT 32
16721: PUSH
16722: LD_INT 120
16724: PUSH
16725: LD_INT 70
16727: PUSH
16728: EMPTY
16729: LIST
16730: LIST
16731: LIST
16732: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16733: NOP4
16737: PPUSH
16738: NOP4
16742: PUSH
16743: LD_INT 7
16745: PUSH
16746: LD_INT 28
16748: PUSH
16749: LD_INT 45
16751: PUSH
16752: NOP4
16756: PUSH
16757: EMPTY
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: IN
16763: IFFALSE 16784
// points := [ 35 , 20 , 45 ] ;
16765: NOP4
16769: PUSH
16770: LD_INT 35
16772: PUSH
16773: LD_INT 20
16775: PUSH
16776: LD_INT 45
16778: PUSH
16779: EMPTY
16780: LIST
16781: LIST
16782: LIST
16783: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16784: NOP4
16788: PPUSH
16789: NOP4
16793: PUSH
16794: LD_INT 47
16796: PUSH
16797: EMPTY
16798: LIST
16799: IN
16800: IFFALSE 16821
// points := [ 67 , 45 , 75 ] ;
16802: NOP4
16806: PUSH
16807: LD_INT 67
16809: PUSH
16810: LD_INT 45
16812: PUSH
16813: LD_INT 75
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: LIST
16820: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16821: NOP4
16825: PPUSH
16826: NOP4
16830: PUSH
16831: LD_INT 26
16833: PUSH
16834: EMPTY
16835: LIST
16836: IN
16837: IFFALSE 16858
// points := [ 120 , 30 , 80 ] ;
16839: NOP4
16843: PUSH
16844: LD_INT 120
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 80
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: LIST
16857: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16858: NOP4
16862: PPUSH
16863: NOP4
16867: PUSH
16868: LD_INT 22
16870: PUSH
16871: EMPTY
16872: LIST
16873: IN
16874: IFFALSE 16895
// points := [ 40 , 1 , 1 ] ;
16876: NOP4
16880: PUSH
16881: LD_INT 40
16883: PUSH
16884: LD_INT 1
16886: PUSH
16887: LD_INT 1
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: LIST
16894: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16895: NOP4
16899: PPUSH
16900: NOP4
16904: PUSH
16905: LD_INT 29
16907: PUSH
16908: EMPTY
16909: LIST
16910: IN
16911: IFFALSE 16932
// points := [ 70 , 200 , 400 ] ;
16913: NOP4
16917: PUSH
16918: LD_INT 70
16920: PUSH
16921: LD_INT 200
16923: PUSH
16924: LD_INT 400
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: LIST
16931: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16932: NOP4
16936: PPUSH
16937: NOP4
16941: PUSH
16942: LD_INT 14
16944: PUSH
16945: LD_INT 53
16947: PUSH
16948: EMPTY
16949: LIST
16950: LIST
16951: IN
16952: IFFALSE 16973
// points := [ 40 , 10 , 20 ] ;
16954: NOP4
16958: PUSH
16959: LD_INT 40
16961: PUSH
16962: LD_INT 10
16964: PUSH
16965: LD_INT 20
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16973: NOP4
16977: PPUSH
16978: NOP4
16982: PUSH
16983: LD_INT 9
16985: PUSH
16986: EMPTY
16987: LIST
16988: IN
16989: IFFALSE 17010
// points := [ 5 , 70 , 20 ] ;
16991: NOP4
16995: PUSH
16996: LD_INT 5
16998: PUSH
16999: LD_INT 70
17001: PUSH
17002: LD_INT 20
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17010: NOP4
17014: PPUSH
17015: NOP4
17019: PUSH
17020: LD_INT 10
17022: PUSH
17023: EMPTY
17024: LIST
17025: IN
17026: IFFALSE 17047
// points := [ 35 , 110 , 70 ] ;
17028: NOP4
17032: PUSH
17033: LD_INT 35
17035: PUSH
17036: LD_INT 110
17038: PUSH
17039: LD_INT 70
17041: PUSH
17042: EMPTY
17043: LIST
17044: LIST
17045: LIST
17046: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17047: NOP4
17051: PPUSH
17052: NOP4
17056: PUSH
17057: LD_INT 25
17059: EQUAL
17060: IFFALSE 17081
// points := [ 80 , 65 , 100 ] ;
17062: NOP4
17066: PUSH
17067: LD_INT 80
17069: PUSH
17070: LD_INT 65
17072: PUSH
17073: LD_INT 100
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: LIST
17080: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17081: NOP4
17085: PPUSH
17086: NOP4
17090: PUSH
17091: LD_INT 1
17093: EQUAL
17094: IFFALSE 17129
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17096: NOP4
17100: PUSH
17101: NOP4
17105: PUSH
17106: NOP4
17110: PPUSH
17111: NOP4
17115: PPUSH
17116: LD_INT 3
17118: PPUSH
17119: NOP4
17123: PUSH
17124: LD_INT 4
17126: MUL
17127: MUL
17128: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17129: NOP4
17133: PPUSH
17134: NOP4
17138: PUSH
17139: LD_INT 2
17141: EQUAL
17142: IFFALSE 17193
// begin j := IsControledBy ( i ) ;
17144: NOP4
17148: PUSH
17149: NOP4
17153: PPUSH
17154: NOP4
17158: ST_TO_ADDR
// if j then
17159: NOP4
17163: IFFALSE 17193
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17165: NOP4
17169: PUSH
17170: NOP4
17174: PUSH
17175: NOP4
17179: PPUSH
17180: LD_INT 3
17182: PPUSH
17183: NOP4
17187: PUSH
17188: LD_INT 3
17190: MUL
17191: MUL
17192: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17193: NOP4
17197: PPUSH
17198: NOP4
17202: PUSH
17203: LD_INT 5
17205: PUSH
17206: LD_INT 6
17208: PUSH
17209: LD_INT 46
17211: PUSH
17212: LD_INT 44
17214: PUSH
17215: LD_INT 47
17217: PUSH
17218: LD_INT 45
17220: PUSH
17221: LD_INT 28
17223: PUSH
17224: LD_INT 7
17226: PUSH
17227: LD_INT 27
17229: PUSH
17230: LD_INT 29
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: LIST
17237: LIST
17238: LIST
17239: LIST
17240: LIST
17241: LIST
17242: LIST
17243: LIST
17244: IN
17245: PUSH
17246: NOP4
17250: PPUSH
17251: LD_INT 52
17253: PPUSH
17254: NOP4
17258: PUSH
17259: LD_INT 2
17261: EQUAL
17262: AND
17263: IFFALSE 17280
// bpoints := bpoints * 1.2 ;
17265: NOP4
17269: PUSH
17270: NOP4
17274: PUSH
17275: LD_REAL  1.20000000000000E+0000
17278: MUL
17279: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17280: NOP4
17284: PPUSH
17285: NOP4
17289: PUSH
17290: LD_INT 6
17292: PUSH
17293: LD_INT 46
17295: PUSH
17296: LD_INT 47
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: LIST
17303: IN
17304: IFFALSE 17321
// bpoints := bpoints * 1.2 ;
17306: NOP4
17310: PUSH
17311: NOP4
17315: PUSH
17316: LD_REAL  1.20000000000000E+0000
17319: MUL
17320: ST_TO_ADDR
// end ; unit_building :
17321: GO 17335
17323: LD_INT 3
17325: DOUBLE
17326: EQUAL
17327: IFTRUE 17331
17329: GO 17334
17331: POP
// ; end ;
17332: GO 17335
17334: POP
// for j = 1 to 3 do
17335: NOP4
17339: PUSH
17340: DOUBLE
17341: LD_INT 1
17343: DEC
17344: ST_TO_ADDR
17345: LD_INT 3
17347: PUSH
17348: FOR_TO
17349: IFFALSE 17402
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17351: NOP4
17355: PUSH
17356: NOP4
17360: PPUSH
17361: NOP4
17365: PPUSH
17366: NOP4
17370: PUSH
17371: NOP4
17375: ARRAY
17376: PUSH
17377: NOP4
17381: PUSH
17382: NOP4
17386: ARRAY
17387: PUSH
17388: NOP4
17392: MUL
17393: PLUS
17394: PPUSH
17395: NOP4
17399: ST_TO_ADDR
17400: GO 17348
17402: POP
17403: POP
// end ;
17404: GO 15881
17406: POP
17407: POP
// result := Replace ( result , 4 , tmp ) ;
17408: NOP4
17412: PUSH
17413: NOP4
17417: PPUSH
17418: LD_INT 4
17420: PPUSH
17421: NOP4
17425: PPUSH
17426: NOP4
17430: ST_TO_ADDR
// end ;
17431: LD_VAR 0 5
17435: RET
// export function DangerAtRange ( unit , range ) ; begin
17436: LD_INT 0
17438: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17439: NOP4
17443: PUSH
17444: NOP4
17448: PPUSH
17449: NOP4
17453: PPUSH
17454: NOP4
17458: PPUSH
17459: NOP4
17463: PPUSH
17464: NOP4
17468: PPUSH
17469: NOP4
17473: PPUSH
17474: NOP4
17478: PPUSH
17479: NOP4
17483: ST_TO_ADDR
// end ;
17484: LD_VAR 0 3
17488: RET
// export function DangerInArea ( side , area ) ; begin
17489: LD_INT 0
17491: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17492: NOP4
17496: PUSH
17497: NOP4
17501: PPUSH
17502: LD_INT 81
17504: PUSH
17505: NOP4
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: PPUSH
17514: NOP4
17518: ST_TO_ADDR
// end ;
17519: LD_VAR 0 3
17523: RET
// export function IsExtension ( b ) ; begin
17524: LD_INT 0
17526: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17527: NOP4
17531: PUSH
17532: NOP4
17536: PUSH
17537: LD_INT 23
17539: PUSH
17540: LD_INT 20
17542: PUSH
17543: LD_INT 22
17545: PUSH
17546: LD_INT 17
17548: PUSH
17549: LD_INT 24
17551: PUSH
17552: LD_INT 21
17554: PUSH
17555: LD_INT 19
17557: PUSH
17558: LD_INT 16
17560: PUSH
17561: LD_INT 25
17563: PUSH
17564: LD_INT 18
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: LIST
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: IN
17579: ST_TO_ADDR
// end ;
17580: LD_VAR 0 2
17584: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17585: LD_INT 0
17587: PPUSH
17588: PPUSH
17589: PPUSH
// result := [ ] ;
17590: NOP4
17594: PUSH
17595: EMPTY
17596: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17597: NOP4
17601: PUSH
17602: NOP4
17606: PPUSH
17607: LD_INT 21
17609: PUSH
17610: LD_INT 3
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: PPUSH
17617: NOP4
17621: ST_TO_ADDR
// if not tmp then
17622: NOP4
17626: NOT
17627: IFFALSE 17631
// exit ;
17629: GO 17695
// if checkLink then
17631: NOP4
17635: IFFALSE 17685
// begin for i in tmp do
17637: NOP4
17641: PUSH
17642: NOP4
17646: PUSH
17647: FOR_IN
17648: IFFALSE 17683
// if GetBase ( i ) <> base then
17650: NOP4
17654: PPUSH
17655: NOP4
17659: PUSH
17660: NOP4
17664: NONEQUAL
17665: IFFALSE 17681
// ComLinkToBase ( base , i ) ;
17667: NOP4
17671: PPUSH
17672: NOP4
17676: PPUSH
17677: NOP4
17681: GO 17647
17683: POP
17684: POP
// end ; result := tmp ;
17685: NOP4
17689: PUSH
17690: NOP4
17694: ST_TO_ADDR
// end ;
17695: LD_VAR 0 4
17699: RET
// export function ComComplete ( units , b ) ; var i ; begin
17700: LD_INT 0
17702: PPUSH
17703: PPUSH
// if not units then
17704: NOP4
17708: NOT
17709: IFFALSE 17713
// exit ;
17711: GO 17803
// for i in units do
17713: NOP4
17717: PUSH
17718: NOP4
17722: PUSH
17723: FOR_IN
17724: IFFALSE 17801
// if BuildingStatus ( b ) = bs_build then
17726: NOP4
17730: PPUSH
17731: NOP4
17735: PUSH
17736: LD_INT 1
17738: EQUAL
17739: IFFALSE 17799
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17741: NOP4
17745: PPUSH
17746: LD_STRING h
17748: PUSH
17749: NOP4
17753: PPUSH
17754: NOP4
17758: PUSH
17759: NOP4
17763: PPUSH
17764: NOP4
17768: PUSH
17769: NOP4
17773: PUSH
17774: LD_INT 0
17776: PUSH
17777: LD_INT 0
17779: PUSH
17780: LD_INT 0
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: PUSH
17792: EMPTY
17793: LIST
17794: PPUSH
17795: NOP4
17799: GO 17723
17801: POP
17802: POP
// end ;
17803: LD_VAR 0 3
17807: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17808: LD_INT 0
17810: PPUSH
17811: PPUSH
17812: PPUSH
17813: PPUSH
17814: PPUSH
17815: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17816: NOP4
17820: NOT
17821: PUSH
17822: NOP4
17826: PPUSH
17827: NOP4
17831: PUSH
17832: LD_INT 2
17834: NONEQUAL
17835: OR
17836: IFFALSE 17840
// exit ;
17838: GO 18156
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17840: NOP4
17844: PUSH
17845: LD_INT 22
17847: PUSH
17848: NOP4
17852: PPUSH
17853: NOP4
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: PUSH
17862: LD_INT 2
17864: PUSH
17865: LD_INT 30
17867: PUSH
17868: LD_INT 36
17870: PUSH
17871: EMPTY
17872: LIST
17873: LIST
17874: PUSH
17875: LD_INT 34
17877: PUSH
17878: LD_INT 31
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: LIST
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: PPUSH
17894: NOP4
17898: ST_TO_ADDR
// if not tmp then
17899: NOP4
17903: NOT
17904: IFFALSE 17908
// exit ;
17906: GO 18156
// result := [ ] ;
17908: NOP4
17912: PUSH
17913: EMPTY
17914: ST_TO_ADDR
// for i in tmp do
17915: NOP4
17919: PUSH
17920: NOP4
17924: PUSH
17925: FOR_IN
17926: IFFALSE 17997
// begin t := UnitsInside ( i ) ;
17928: NOP4
17932: PUSH
17933: NOP4
17937: PPUSH
17938: NOP4
17942: ST_TO_ADDR
// if t then
17943: NOP4
17947: IFFALSE 17995
// for j in t do
17949: NOP4
17953: PUSH
17954: NOP4
17958: PUSH
17959: FOR_IN
17960: IFFALSE 17993
// result := Replace ( result , result + 1 , j ) ;
17962: NOP4
17966: PUSH
17967: NOP4
17971: PPUSH
17972: NOP4
17976: PUSH
17977: LD_INT 1
17979: PLUS
17980: PPUSH
17981: NOP4
17985: PPUSH
17986: NOP4
17990: ST_TO_ADDR
17991: GO 17959
17993: POP
17994: POP
// end ;
17995: GO 17925
17997: POP
17998: POP
// if not result then
17999: NOP4
18003: NOT
18004: IFFALSE 18008
// exit ;
18006: GO 18156
// mech := result [ 1 ] ;
18008: NOP4
18012: PUSH
18013: NOP4
18017: PUSH
18018: LD_INT 1
18020: ARRAY
18021: ST_TO_ADDR
// if result > 1 then
18022: NOP4
18026: PUSH
18027: LD_INT 1
18029: GREATER
18030: IFFALSE 18142
// begin for i = 2 to result do
18032: NOP4
18036: PUSH
18037: DOUBLE
18038: LD_INT 2
18040: DEC
18041: ST_TO_ADDR
18042: NOP4
18046: PUSH
18047: FOR_TO
18048: IFFALSE 18140
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18050: NOP4
18054: PUSH
18055: NOP4
18059: PUSH
18060: NOP4
18064: ARRAY
18065: PPUSH
18066: LD_INT 3
18068: PPUSH
18069: NOP4
18073: PUSH
18074: NOP4
18078: PUSH
18079: NOP4
18083: ARRAY
18084: PPUSH
18085: NOP4
18089: MINUS
18090: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18091: NOP4
18095: PUSH
18096: NOP4
18100: PPUSH
18101: LD_INT 3
18103: PPUSH
18104: NOP4
18108: PUSH
18109: NOP4
18113: PPUSH
18114: NOP4
18118: MINUS
18119: GREATEREQUAL
18120: IFFALSE 18138
// mech := result [ i ] ;
18122: NOP4
18126: PUSH
18127: NOP4
18131: PUSH
18132: NOP4
18136: ARRAY
18137: ST_TO_ADDR
// end ;
18138: GO 18047
18140: POP
18141: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18142: NOP4
18146: PPUSH
18147: NOP4
18151: PPUSH
18152: NOP4
// end ;
18156: LD_VAR 0 2
18160: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18161: LD_INT 0
18163: PPUSH
18164: PPUSH
18165: PPUSH
18166: PPUSH
18167: PPUSH
18168: PPUSH
18169: PPUSH
18170: PPUSH
18171: PPUSH
18172: PPUSH
18173: PPUSH
18174: PPUSH
18175: PPUSH
// result := [ ] ;
18176: NOP4
18180: PUSH
18181: EMPTY
18182: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18183: NOP4
18187: PPUSH
18188: NOP4
18192: PUSH
18193: LD_INT 0
18195: PUSH
18196: LD_INT 1
18198: PUSH
18199: EMPTY
18200: LIST
18201: LIST
18202: IN
18203: NOT
18204: IFFALSE 18208
// exit ;
18206: GO 19842
// if name then
18208: NOP4
18212: IFFALSE 18228
// SetBName ( base_dep , name ) ;
18214: NOP4
18218: PPUSH
18219: NOP4
18223: PPUSH
18224: NOP4
// base := GetBase ( base_dep ) ;
18228: NOP4
18232: PUSH
18233: NOP4
18237: PPUSH
18238: NOP4
18242: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18243: NOP4
18247: PUSH
18248: NOP4
18252: PPUSH
18253: NOP4
18257: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18258: NOP4
18262: PUSH
18263: NOP4
18267: PPUSH
18268: NOP4
18272: ST_TO_ADDR
// if sources then
18273: NOP4
18277: IFFALSE 18324
// for i = 1 to 3 do
18279: NOP4
18283: PUSH
18284: DOUBLE
18285: LD_INT 1
18287: DEC
18288: ST_TO_ADDR
18289: LD_INT 3
18291: PUSH
18292: FOR_TO
18293: IFFALSE 18322
// AddResourceType ( base , i , sources [ i ] ) ;
18295: NOP4
18299: PPUSH
18300: NOP4
18304: PPUSH
18305: NOP4
18309: PUSH
18310: NOP4
18314: ARRAY
18315: PPUSH
18316: NOP4
18320: GO 18292
18322: POP
18323: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18324: NOP4
18328: PUSH
18329: NOP4
18333: PPUSH
18334: NOP4
18338: PPUSH
18339: LD_INT 1
18341: PPUSH
18342: NOP4
18346: ST_TO_ADDR
// InitHc ;
18347: NOP4
// InitUc ;
18351: NOP4
// uc_side := side ;
18355: LD_ADDR_OWVAR 20
18359: PUSH
18360: NOP4
18364: ST_TO_ADDR
// uc_nation := nation ;
18365: LD_ADDR_OWVAR 21
18369: PUSH
18370: NOP4
18374: ST_TO_ADDR
// if buildings then
18375: NOP4
18379: IFFALSE 19701
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18381: NOP4
18385: PUSH
18386: NOP4
18390: PPUSH
18391: LD_INT 2
18393: PUSH
18394: LD_INT 30
18396: PUSH
18397: LD_INT 29
18399: PUSH
18400: EMPTY
18401: LIST
18402: LIST
18403: PUSH
18404: LD_INT 30
18406: PUSH
18407: LD_INT 30
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: LIST
18418: PPUSH
18419: NOP4
18423: ST_TO_ADDR
// if tmp then
18424: NOP4
18428: IFFALSE 18476
// for i in tmp do
18430: NOP4
18434: PUSH
18435: NOP4
18439: PUSH
18440: FOR_IN
18441: IFFALSE 18474
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18443: NOP4
18447: PPUSH
18448: NOP4
18452: PPUSH
18453: NOP4
18457: PPUSH
18458: NOP4
18462: PPUSH
18463: NOP4
18467: PPUSH
18468: NOP4
18472: GO 18440
18474: POP
18475: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18476: NOP4
18480: PPUSH
18481: LD_INT 2
18483: PUSH
18484: LD_INT 30
18486: PUSH
18487: LD_INT 32
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: PUSH
18494: LD_INT 30
18496: PUSH
18497: LD_INT 33
18499: PUSH
18500: EMPTY
18501: LIST
18502: LIST
18503: PUSH
18504: EMPTY
18505: LIST
18506: LIST
18507: LIST
18508: PPUSH
18509: NOP4
18513: IFFALSE 18601
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18515: NOP4
18519: PUSH
18520: NOP4
18524: PPUSH
18525: LD_INT 2
18527: PUSH
18528: LD_INT 30
18530: PUSH
18531: LD_INT 32
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PUSH
18538: LD_INT 30
18540: PUSH
18541: LD_INT 33
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: LIST
18552: PPUSH
18553: NOP4
18557: PUSH
18558: FOR_IN
18559: IFFALSE 18599
// begin if not GetBWeapon ( i ) then
18561: NOP4
18565: PPUSH
18566: NOP4
18570: NOT
18571: IFFALSE 18597
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18573: NOP4
18577: PPUSH
18578: NOP4
18582: PPUSH
18583: NOP4
18587: PPUSH
18588: NOP4
18592: PPUSH
18593: NOP4
// end ;
18597: GO 18558
18599: POP
18600: POP
// end ; for i = 1 to personel do
18601: NOP4
18605: PUSH
18606: DOUBLE
18607: LD_INT 1
18609: DEC
18610: ST_TO_ADDR
18611: NOP4
18615: PUSH
18616: FOR_TO
18617: IFFALSE 19681
// begin if i > 4 then
18619: NOP4
18623: PUSH
18624: LD_INT 4
18626: GREATER
18627: IFFALSE 18631
// break ;
18629: GO 19681
// case i of 1 :
18631: NOP4
18635: PUSH
18636: LD_INT 1
18638: DOUBLE
18639: EQUAL
18640: IFTRUE 18644
18642: GO 18724
18644: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18645: NOP4
18649: PUSH
18650: NOP4
18654: PPUSH
18655: LD_INT 22
18657: PUSH
18658: NOP4
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 58
18669: PUSH
18670: EMPTY
18671: LIST
18672: PUSH
18673: LD_INT 2
18675: PUSH
18676: LD_INT 30
18678: PUSH
18679: LD_INT 32
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: PUSH
18686: LD_INT 30
18688: PUSH
18689: LD_INT 4
18691: PUSH
18692: EMPTY
18693: LIST
18694: LIST
18695: PUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 5
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PUSH
18706: EMPTY
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: LIST
18716: PPUSH
18717: NOP4
18721: ST_TO_ADDR
18722: GO 18946
18724: LD_INT 2
18726: DOUBLE
18727: EQUAL
18728: IFTRUE 18732
18730: GO 18794
18732: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18733: NOP4
18737: PUSH
18738: NOP4
18742: PPUSH
18743: LD_INT 22
18745: PUSH
18746: NOP4
18750: PUSH
18751: EMPTY
18752: LIST
18753: LIST
18754: PUSH
18755: LD_INT 2
18757: PUSH
18758: LD_INT 30
18760: PUSH
18761: LD_INT 0
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 1
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PPUSH
18787: NOP4
18791: ST_TO_ADDR
18792: GO 18946
18794: LD_INT 3
18796: DOUBLE
18797: EQUAL
18798: IFTRUE 18802
18800: GO 18864
18802: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18803: NOP4
18807: PUSH
18808: NOP4
18812: PPUSH
18813: LD_INT 22
18815: PUSH
18816: NOP4
18820: PUSH
18821: EMPTY
18822: LIST
18823: LIST
18824: PUSH
18825: LD_INT 2
18827: PUSH
18828: LD_INT 30
18830: PUSH
18831: LD_INT 2
18833: PUSH
18834: EMPTY
18835: LIST
18836: LIST
18837: PUSH
18838: LD_INT 30
18840: PUSH
18841: LD_INT 3
18843: PUSH
18844: EMPTY
18845: LIST
18846: LIST
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: LIST
18852: PUSH
18853: EMPTY
18854: LIST
18855: LIST
18856: PPUSH
18857: NOP4
18861: ST_TO_ADDR
18862: GO 18946
18864: LD_INT 4
18866: DOUBLE
18867: EQUAL
18868: IFTRUE 18872
18870: GO 18945
18872: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18873: NOP4
18877: PUSH
18878: NOP4
18882: PPUSH
18883: LD_INT 22
18885: PUSH
18886: NOP4
18890: PUSH
18891: EMPTY
18892: LIST
18893: LIST
18894: PUSH
18895: LD_INT 2
18897: PUSH
18898: LD_INT 30
18900: PUSH
18901: LD_INT 6
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 30
18910: PUSH
18911: LD_INT 7
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: LD_INT 30
18920: PUSH
18921: LD_INT 8
18923: PUSH
18924: EMPTY
18925: LIST
18926: LIST
18927: PUSH
18928: EMPTY
18929: LIST
18930: LIST
18931: LIST
18932: LIST
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: PPUSH
18938: NOP4
18942: ST_TO_ADDR
18943: GO 18946
18945: POP
// if i = 1 then
18946: NOP4
18950: PUSH
18951: LD_INT 1
18953: EQUAL
18954: IFFALSE 19065
// begin tmp := [ ] ;
18956: NOP4
18960: PUSH
18961: EMPTY
18962: ST_TO_ADDR
// for j in f do
18963: NOP4
18967: PUSH
18968: NOP4
18972: PUSH
18973: FOR_IN
18974: IFFALSE 19047
// if GetBType ( j ) = b_bunker then
18976: NOP4
18980: PPUSH
18981: NOP4
18985: PUSH
18986: LD_INT 32
18988: EQUAL
18989: IFFALSE 19016
// tmp := Insert ( tmp , 1 , j ) else
18991: NOP4
18995: PUSH
18996: NOP4
19000: PPUSH
19001: LD_INT 1
19003: PPUSH
19004: NOP4
19008: PPUSH
19009: NOP4
19013: ST_TO_ADDR
19014: GO 19045
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19016: NOP4
19020: PUSH
19021: NOP4
19025: PPUSH
19026: NOP4
19030: PUSH
19031: LD_INT 1
19033: PLUS
19034: PPUSH
19035: NOP4
19039: PPUSH
19040: NOP4
19044: ST_TO_ADDR
19045: GO 18973
19047: POP
19048: POP
// if tmp then
19049: NOP4
19053: IFFALSE 19065
// f := tmp ;
19055: NOP4
19059: PUSH
19060: NOP4
19064: ST_TO_ADDR
// end ; x := personel [ i ] ;
19065: NOP4
19069: PUSH
19070: NOP4
19074: PUSH
19075: NOP4
19079: ARRAY
19080: ST_TO_ADDR
// if x = - 1 then
19081: NOP4
19085: PUSH
19086: LD_INT 1
19088: NEG
19089: EQUAL
19090: IFFALSE 19299
// begin for j in f do
19092: NOP4
19096: PUSH
19097: NOP4
19101: PUSH
19102: FOR_IN
19103: IFFALSE 19295
// repeat InitHc ;
19105: NOP4
// if GetBType ( j ) = b_barracks then
19109: NOP4
19113: PPUSH
19114: NOP4
19118: PUSH
19119: LD_INT 5
19121: EQUAL
19122: IFFALSE 19192
// begin if UnitsInside ( j ) < 3 then
19124: NOP4
19128: PPUSH
19129: NOP4
19133: PUSH
19134: LD_INT 3
19136: LESS
19137: IFFALSE 19173
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19139: LD_INT 0
19141: PPUSH
19142: LD_INT 5
19144: PUSH
19145: LD_INT 8
19147: PUSH
19148: LD_INT 9
19150: PUSH
19151: EMPTY
19152: LIST
19153: LIST
19154: LIST
19155: PUSH
19156: NOP4
19160: ARRAY
19161: PPUSH
19162: NOP4
19166: PPUSH
19167: NOP4
19171: GO 19190
// PrepareHuman ( false , i , skill ) ;
19173: LD_INT 0
19175: PPUSH
19176: NOP4
19180: PPUSH
19181: NOP4
19185: PPUSH
19186: NOP4
// end else
19190: GO 19209
// PrepareHuman ( false , i , skill ) ;
19192: LD_INT 0
19194: PPUSH
19195: NOP4
19199: PPUSH
19200: NOP4
19204: PPUSH
19205: NOP4
// un := CreateHuman ;
19209: NOP4
19213: PUSH
19214: NOP4
19218: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19219: NOP4
19223: PUSH
19224: NOP4
19228: PPUSH
19229: LD_INT 1
19231: PPUSH
19232: NOP4
19236: PPUSH
19237: NOP4
19241: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19242: NOP4
19246: PPUSH
19247: NOP4
19251: PPUSH
19252: NOP4
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19256: NOP4
19260: PPUSH
19261: NOP4
19265: PUSH
19266: LD_INT 6
19268: EQUAL
19269: PUSH
19270: NOP4
19274: PPUSH
19275: NOP4
19279: PUSH
19280: LD_INT 32
19282: PUSH
19283: LD_INT 31
19285: PUSH
19286: EMPTY
19287: LIST
19288: LIST
19289: IN
19290: OR
19291: IFFALSE 19105
19293: GO 19102
19295: POP
19296: POP
// end else
19297: GO 19679
// for j = 1 to x do
19299: NOP4
19303: PUSH
19304: DOUBLE
19305: LD_INT 1
19307: DEC
19308: ST_TO_ADDR
19309: NOP4
19313: PUSH
19314: FOR_TO
19315: IFFALSE 19677
// begin InitHc ;
19317: NOP4
// if not f then
19321: NOP4
19325: NOT
19326: IFFALSE 19415
// begin PrepareHuman ( false , i , skill ) ;
19328: LD_INT 0
19330: PPUSH
19331: NOP4
19335: PPUSH
19336: NOP4
19340: PPUSH
19341: NOP4
// un := CreateHuman ;
19345: NOP4
19349: PUSH
19350: NOP4
19354: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19355: NOP4
19359: PUSH
19360: NOP4
19364: PPUSH
19365: LD_INT 1
19367: PPUSH
19368: NOP4
19372: PPUSH
19373: NOP4
19377: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19378: NOP4
19382: PPUSH
19383: NOP4
19387: PPUSH
19388: NOP4
19392: PPUSH
19393: NOP4
19397: PPUSH
19398: NOP4
19402: PPUSH
19403: LD_INT 10
19405: PPUSH
19406: LD_INT 0
19408: PPUSH
19409: NOP4
// continue ;
19413: GO 19314
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19415: NOP4
19419: PUSH
19420: LD_INT 1
19422: ARRAY
19423: PPUSH
19424: NOP4
19428: PUSH
19429: NOP4
19433: PUSH
19434: LD_INT 1
19436: ARRAY
19437: PPUSH
19438: NOP4
19442: PUSH
19443: LD_INT 32
19445: PUSH
19446: LD_INT 31
19448: PUSH
19449: EMPTY
19450: LIST
19451: LIST
19452: IN
19453: AND
19454: PUSH
19455: NOP4
19459: PUSH
19460: LD_INT 1
19462: ARRAY
19463: PPUSH
19464: NOP4
19468: PUSH
19469: LD_INT 6
19471: EQUAL
19472: OR
19473: IFFALSE 19493
// f := Delete ( f , 1 ) ;
19475: NOP4
19479: PUSH
19480: NOP4
19484: PPUSH
19485: LD_INT 1
19487: PPUSH
19488: NOP4
19492: ST_TO_ADDR
// if not f then
19493: NOP4
19497: NOT
19498: IFFALSE 19516
// begin x := x + 2 ;
19500: NOP4
19504: PUSH
19505: NOP4
19509: PUSH
19510: LD_INT 2
19512: PLUS
19513: ST_TO_ADDR
// continue ;
19514: GO 19314
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19516: NOP4
19520: PUSH
19521: LD_INT 1
19523: ARRAY
19524: PPUSH
19525: NOP4
19529: PUSH
19530: LD_INT 5
19532: EQUAL
19533: IFFALSE 19607
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19535: NOP4
19539: PUSH
19540: LD_INT 1
19542: ARRAY
19543: PPUSH
19544: NOP4
19548: PUSH
19549: LD_INT 3
19551: LESS
19552: IFFALSE 19588
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19554: LD_INT 0
19556: PPUSH
19557: LD_INT 5
19559: PUSH
19560: LD_INT 8
19562: PUSH
19563: LD_INT 9
19565: PUSH
19566: EMPTY
19567: LIST
19568: LIST
19569: LIST
19570: PUSH
19571: NOP4
19575: ARRAY
19576: PPUSH
19577: NOP4
19581: PPUSH
19582: NOP4
19586: GO 19605
// PrepareHuman ( false , i , skill ) ;
19588: LD_INT 0
19590: PPUSH
19591: NOP4
19595: PPUSH
19596: NOP4
19600: PPUSH
19601: NOP4
// end else
19605: GO 19624
// PrepareHuman ( false , i , skill ) ;
19607: LD_INT 0
19609: PPUSH
19610: NOP4
19614: PPUSH
19615: NOP4
19619: PPUSH
19620: NOP4
// un := CreateHuman ;
19624: NOP4
19628: PUSH
19629: NOP4
19633: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19634: NOP4
19638: PUSH
19639: NOP4
19643: PPUSH
19644: LD_INT 1
19646: PPUSH
19647: NOP4
19651: PPUSH
19652: NOP4
19656: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19657: NOP4
19661: PPUSH
19662: NOP4
19666: PUSH
19667: LD_INT 1
19669: ARRAY
19670: PPUSH
19671: NOP4
// end ;
19675: GO 19314
19677: POP
19678: POP
// end ;
19679: GO 18616
19681: POP
19682: POP
// result := result ^ buildings ;
19683: NOP4
19687: PUSH
19688: NOP4
19692: PUSH
19693: NOP4
19697: ADD
19698: ST_TO_ADDR
// end else
19699: GO 19842
// begin for i = 1 to personel do
19701: NOP4
19705: PUSH
19706: DOUBLE
19707: LD_INT 1
19709: DEC
19710: ST_TO_ADDR
19711: NOP4
19715: PUSH
19716: FOR_TO
19717: IFFALSE 19840
// begin if i > 4 then
19719: NOP4
19723: PUSH
19724: LD_INT 4
19726: GREATER
19727: IFFALSE 19731
// break ;
19729: GO 19840
// x := personel [ i ] ;
19731: NOP4
19735: PUSH
19736: NOP4
19740: PUSH
19741: NOP4
19745: ARRAY
19746: ST_TO_ADDR
// if x = - 1 then
19747: NOP4
19751: PUSH
19752: LD_INT 1
19754: NEG
19755: EQUAL
19756: IFFALSE 19760
// continue ;
19758: GO 19716
// PrepareHuman ( false , i , skill ) ;
19760: LD_INT 0
19762: PPUSH
19763: NOP4
19767: PPUSH
19768: NOP4
19772: PPUSH
19773: NOP4
// un := CreateHuman ;
19777: NOP4
19781: PUSH
19782: NOP4
19786: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19787: NOP4
19791: PPUSH
19792: NOP4
19796: PPUSH
19797: NOP4
19801: PPUSH
19802: NOP4
19806: PPUSH
19807: NOP4
19811: PPUSH
19812: LD_INT 10
19814: PPUSH
19815: LD_INT 0
19817: PPUSH
19818: NOP4
// result := result ^ un ;
19822: NOP4
19826: PUSH
19827: NOP4
19831: PUSH
19832: NOP4
19836: ADD
19837: ST_TO_ADDR
// end ;
19838: GO 19716
19840: POP
19841: POP
// end ; end ;
19842: LD_VAR 0 7
19846: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19847: LD_INT 0
19849: PPUSH
19850: PPUSH
19851: PPUSH
19852: PPUSH
19853: PPUSH
19854: PPUSH
19855: PPUSH
19856: PPUSH
19857: PPUSH
19858: PPUSH
19859: PPUSH
19860: PPUSH
19861: PPUSH
19862: PPUSH
19863: PPUSH
19864: PPUSH
// result := false ;
19865: NOP4
19869: PUSH
19870: LD_INT 0
19872: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19873: NOP4
19877: NOT
19878: PUSH
19879: NOP4
19883: PPUSH
19884: NOP4
19888: PUSH
19889: LD_INT 32
19891: PUSH
19892: LD_INT 33
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: IN
19899: NOT
19900: OR
19901: IFFALSE 19905
// exit ;
19903: GO 21014
// nat := GetNation ( tower ) ;
19905: NOP4
19909: PUSH
19910: NOP4
19914: PPUSH
19915: NOP4
19919: ST_TO_ADDR
// side := GetSide ( tower ) ;
19920: NOP4
19924: PUSH
19925: NOP4
19929: PPUSH
19930: NOP4
19934: ST_TO_ADDR
// x := GetX ( tower ) ;
19935: NOP4
19939: PUSH
19940: NOP4
19944: PPUSH
19945: NOP4
19949: ST_TO_ADDR
// y := GetY ( tower ) ;
19950: NOP4
19954: PUSH
19955: NOP4
19959: PPUSH
19960: NOP4
19964: ST_TO_ADDR
// if not x or not y then
19965: NOP4
19969: NOT
19970: PUSH
19971: NOP4
19975: NOT
19976: OR
19977: IFFALSE 19981
// exit ;
19979: GO 21014
// weapon := 0 ;
19981: NOP4
19985: PUSH
19986: LD_INT 0
19988: ST_TO_ADDR
// fac_list := [ ] ;
19989: NOP4
19993: PUSH
19994: EMPTY
19995: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19996: NOP4
20000: PUSH
20001: NOP4
20005: PPUSH
20006: NOP4
20010: PPUSH
20011: NOP4
20015: PPUSH
20016: LD_INT 0
20018: PPUSH
20019: NOP4
20023: PPUSH
20024: LD_INT 30
20026: PUSH
20027: LD_INT 3
20029: PUSH
20030: EMPTY
20031: LIST
20032: LIST
20033: PPUSH
20034: NOP4
20038: ST_TO_ADDR
// if not factories then
20039: NOP4
20043: NOT
20044: IFFALSE 20048
// exit ;
20046: GO 21014
// for i in factories do
20048: NOP4
20052: PUSH
20053: NOP4
20057: PUSH
20058: FOR_IN
20059: IFFALSE 20084
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20061: NOP4
20065: PUSH
20066: NOP4
20070: PUSH
20071: NOP4
20075: PPUSH
20076: NOP4
20080: UNION
20081: ST_TO_ADDR
20082: GO 20058
20084: POP
20085: POP
// if not fac_list then
20086: NOP4
20090: NOT
20091: IFFALSE 20095
// exit ;
20093: GO 21014
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20095: NOP4
20099: PUSH
20100: LD_INT 4
20102: PUSH
20103: LD_INT 5
20105: PUSH
20106: LD_INT 9
20108: PUSH
20109: LD_INT 10
20111: PUSH
20112: LD_INT 6
20114: PUSH
20115: LD_INT 7
20117: PUSH
20118: LD_INT 11
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: LIST
20127: LIST
20128: LIST
20129: PUSH
20130: LD_INT 27
20132: PUSH
20133: LD_INT 28
20135: PUSH
20136: LD_INT 26
20138: PUSH
20139: LD_INT 30
20141: PUSH
20142: EMPTY
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: PUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: LD_INT 46
20156: PUSH
20157: LD_INT 45
20159: PUSH
20160: LD_INT 47
20162: PUSH
20163: LD_INT 49
20165: PUSH
20166: EMPTY
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: LIST
20178: PUSH
20179: NOP4
20183: ARRAY
20184: ST_TO_ADDR
// list := list isect fac_list ;
20185: NOP4
20189: PUSH
20190: NOP4
20194: PUSH
20195: NOP4
20199: ISECT
20200: ST_TO_ADDR
// if not list then
20201: NOP4
20205: NOT
20206: IFFALSE 20210
// exit ;
20208: GO 21014
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20210: NOP4
20214: PUSH
20215: LD_INT 3
20217: EQUAL
20218: PUSH
20219: LD_INT 49
20221: PUSH
20222: NOP4
20226: IN
20227: AND
20228: PUSH
20229: LD_INT 31
20231: PPUSH
20232: NOP4
20236: PPUSH
20237: NOP4
20241: PUSH
20242: LD_INT 2
20244: EQUAL
20245: AND
20246: IFFALSE 20306
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20248: LD_INT 22
20250: PUSH
20251: NOP4
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: PUSH
20260: LD_INT 35
20262: PUSH
20263: LD_INT 49
20265: PUSH
20266: EMPTY
20267: LIST
20268: LIST
20269: PUSH
20270: LD_INT 91
20272: PUSH
20273: NOP4
20277: PUSH
20278: LD_INT 10
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: LIST
20290: PPUSH
20291: NOP4
20295: NOT
20296: IFFALSE 20306
// weapon := ru_time_lapser ;
20298: NOP4
20302: PUSH
20303: LD_INT 49
20305: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20306: NOP4
20310: PUSH
20311: LD_INT 1
20313: PUSH
20314: LD_INT 2
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: IN
20321: PUSH
20322: LD_INT 11
20324: PUSH
20325: NOP4
20329: IN
20330: PUSH
20331: LD_INT 30
20333: PUSH
20334: NOP4
20338: IN
20339: OR
20340: AND
20341: PUSH
20342: LD_INT 6
20344: PPUSH
20345: NOP4
20349: PPUSH
20350: NOP4
20354: PUSH
20355: LD_INT 2
20357: EQUAL
20358: AND
20359: IFFALSE 20524
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20361: LD_INT 22
20363: PUSH
20364: NOP4
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: PUSH
20373: LD_INT 2
20375: PUSH
20376: LD_INT 35
20378: PUSH
20379: LD_INT 11
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: PUSH
20386: LD_INT 35
20388: PUSH
20389: LD_INT 30
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: EMPTY
20397: LIST
20398: LIST
20399: LIST
20400: PUSH
20401: LD_INT 91
20403: PUSH
20404: NOP4
20408: PUSH
20409: LD_INT 18
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: LIST
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: PPUSH
20422: NOP4
20426: NOT
20427: PUSH
20428: LD_INT 22
20430: PUSH
20431: NOP4
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: PUSH
20440: LD_INT 2
20442: PUSH
20443: LD_INT 30
20445: PUSH
20446: LD_INT 32
20448: PUSH
20449: EMPTY
20450: LIST
20451: LIST
20452: PUSH
20453: LD_INT 30
20455: PUSH
20456: LD_INT 33
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 91
20470: PUSH
20471: NOP4
20475: PUSH
20476: LD_INT 12
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: LIST
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: LIST
20488: PUSH
20489: EMPTY
20490: LIST
20491: PPUSH
20492: NOP4
20496: PUSH
20497: LD_INT 2
20499: GREATER
20500: AND
20501: IFFALSE 20524
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20503: NOP4
20507: PUSH
20508: LD_INT 11
20510: PUSH
20511: LD_INT 30
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: PUSH
20518: NOP4
20522: ARRAY
20523: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20524: NOP4
20528: NOT
20529: PUSH
20530: LD_INT 40
20532: PPUSH
20533: NOP4
20537: PPUSH
20538: NOP4
20542: PUSH
20543: LD_INT 2
20545: EQUAL
20546: AND
20547: PUSH
20548: LD_INT 7
20550: PUSH
20551: NOP4
20555: IN
20556: PUSH
20557: LD_INT 28
20559: PUSH
20560: NOP4
20564: IN
20565: OR
20566: PUSH
20567: LD_INT 45
20569: PUSH
20570: NOP4
20574: IN
20575: OR
20576: AND
20577: IFFALSE 20831
// begin hex := GetHexInfo ( x , y ) ;
20579: NOP4
20583: PUSH
20584: NOP4
20588: PPUSH
20589: NOP4
20593: PPUSH
20594: NOP4
20598: ST_TO_ADDR
// if hex [ 1 ] then
20599: NOP4
20603: PUSH
20604: LD_INT 1
20606: ARRAY
20607: IFFALSE 20611
// exit ;
20609: GO 21014
// height := hex [ 2 ] ;
20611: NOP4
20615: PUSH
20616: NOP4
20620: PUSH
20621: LD_INT 2
20623: ARRAY
20624: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20625: NOP4
20629: PUSH
20630: LD_INT 0
20632: PUSH
20633: LD_INT 2
20635: PUSH
20636: LD_INT 3
20638: PUSH
20639: LD_INT 5
20641: PUSH
20642: EMPTY
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: ST_TO_ADDR
// for i in tmp do
20648: NOP4
20652: PUSH
20653: NOP4
20657: PUSH
20658: FOR_IN
20659: IFFALSE 20829
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20661: NOP4
20665: PUSH
20666: NOP4
20670: PPUSH
20671: NOP4
20675: PPUSH
20676: LD_INT 5
20678: PPUSH
20679: NOP4
20683: PUSH
20684: NOP4
20688: PPUSH
20689: NOP4
20693: PPUSH
20694: LD_INT 5
20696: PPUSH
20697: NOP4
20701: PUSH
20702: EMPTY
20703: LIST
20704: LIST
20705: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20706: NOP4
20710: PUSH
20711: LD_INT 1
20713: ARRAY
20714: PPUSH
20715: NOP4
20719: PUSH
20720: LD_INT 2
20722: ARRAY
20723: PPUSH
20724: NOP4
20728: IFFALSE 20827
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20730: NOP4
20734: PUSH
20735: NOP4
20739: PUSH
20740: LD_INT 1
20742: ARRAY
20743: PPUSH
20744: NOP4
20748: PUSH
20749: LD_INT 2
20751: ARRAY
20752: PPUSH
20753: NOP4
20757: ST_TO_ADDR
// if hex [ 1 ] then
20758: NOP4
20762: PUSH
20763: LD_INT 1
20765: ARRAY
20766: IFFALSE 20770
// continue ;
20768: GO 20658
// h := hex [ 2 ] ;
20770: NOP4
20774: PUSH
20775: NOP4
20779: PUSH
20780: LD_INT 2
20782: ARRAY
20783: ST_TO_ADDR
// if h + 7 < height then
20784: NOP4
20788: PUSH
20789: LD_INT 7
20791: PLUS
20792: PUSH
20793: NOP4
20797: LESS
20798: IFFALSE 20827
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20800: NOP4
20804: PUSH
20805: LD_INT 7
20807: PUSH
20808: LD_INT 28
20810: PUSH
20811: LD_INT 45
20813: PUSH
20814: EMPTY
20815: LIST
20816: LIST
20817: LIST
20818: PUSH
20819: NOP4
20823: ARRAY
20824: ST_TO_ADDR
// break ;
20825: GO 20829
// end ; end ; end ;
20827: GO 20658
20829: POP
20830: POP
// end ; if not weapon then
20831: NOP4
20835: NOT
20836: IFFALSE 20896
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20838: NOP4
20842: PUSH
20843: NOP4
20847: PUSH
20848: LD_INT 11
20850: PUSH
20851: LD_INT 30
20853: PUSH
20854: LD_INT 49
20856: PUSH
20857: EMPTY
20858: LIST
20859: LIST
20860: LIST
20861: DIFF
20862: ST_TO_ADDR
// if not list then
20863: NOP4
20867: NOT
20868: IFFALSE 20872
// exit ;
20870: GO 21014
// weapon := list [ rand ( 1 , list ) ] ;
20872: NOP4
20876: PUSH
20877: NOP4
20881: PUSH
20882: LD_INT 1
20884: PPUSH
20885: NOP4
20889: PPUSH
20890: NOP4
20894: ARRAY
20895: ST_TO_ADDR
// end ; if weapon then
20896: NOP4
20900: IFFALSE 21014
// begin tmp := CostOfWeapon ( weapon ) ;
20902: NOP4
20906: PUSH
20907: NOP4
20911: PPUSH
20912: NOP4
20916: ST_TO_ADDR
// j := GetBase ( tower ) ;
20917: NOP4
20921: PUSH
20922: NOP4
20926: PPUSH
20927: NOP4
20931: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20932: NOP4
20936: PPUSH
20937: LD_INT 1
20939: PPUSH
20940: NOP4
20944: PUSH
20945: NOP4
20949: PUSH
20950: LD_INT 1
20952: ARRAY
20953: GREATEREQUAL
20954: PUSH
20955: NOP4
20959: PPUSH
20960: LD_INT 2
20962: PPUSH
20963: NOP4
20967: PUSH
20968: NOP4
20972: PUSH
20973: LD_INT 2
20975: ARRAY
20976: GREATEREQUAL
20977: AND
20978: PUSH
20979: NOP4
20983: PPUSH
20984: LD_INT 3
20986: PPUSH
20987: NOP4
20991: PUSH
20992: NOP4
20996: PUSH
20997: LD_INT 3
20999: ARRAY
21000: GREATEREQUAL
21001: AND
21002: IFFALSE 21014
// result := weapon ;
21004: NOP4
21008: PUSH
21009: NOP4
21013: ST_TO_ADDR
// end ; end ;
21014: LD_VAR 0 3
21018: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21019: LD_INT 0
21021: PPUSH
21022: PPUSH
// result := true ;
21023: NOP4
21027: PUSH
21028: LD_INT 1
21030: ST_TO_ADDR
// if array1 = array2 then
21031: NOP4
21035: PUSH
21036: NOP4
21040: EQUAL
21041: IFFALSE 21101
// begin for i = 1 to array1 do
21043: NOP4
21047: PUSH
21048: DOUBLE
21049: LD_INT 1
21051: DEC
21052: ST_TO_ADDR
21053: NOP4
21057: PUSH
21058: FOR_TO
21059: IFFALSE 21097
// if array1 [ i ] <> array2 [ i ] then
21061: NOP4
21065: PUSH
21066: NOP4
21070: ARRAY
21071: PUSH
21072: NOP4
21076: PUSH
21077: NOP4
21081: ARRAY
21082: NONEQUAL
21083: IFFALSE 21095
// begin result := false ;
21085: NOP4
21089: PUSH
21090: LD_INT 0
21092: ST_TO_ADDR
// break ;
21093: GO 21097
// end ;
21095: GO 21058
21097: POP
21098: POP
// end else
21099: GO 21109
// result := false ;
21101: NOP4
21105: PUSH
21106: LD_INT 0
21108: ST_TO_ADDR
// end ;
21109: LD_VAR 0 3
21113: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21114: LD_INT 0
21116: PPUSH
21117: PPUSH
// if not array1 or not array2 then
21118: NOP4
21122: NOT
21123: PUSH
21124: NOP4
21128: NOT
21129: OR
21130: IFFALSE 21134
// exit ;
21132: GO 21198
// result := true ;
21134: NOP4
21138: PUSH
21139: LD_INT 1
21141: ST_TO_ADDR
// for i = 1 to array1 do
21142: NOP4
21146: PUSH
21147: DOUBLE
21148: LD_INT 1
21150: DEC
21151: ST_TO_ADDR
21152: NOP4
21156: PUSH
21157: FOR_TO
21158: IFFALSE 21196
// if array1 [ i ] <> array2 [ i ] then
21160: NOP4
21164: PUSH
21165: NOP4
21169: ARRAY
21170: PUSH
21171: NOP4
21175: PUSH
21176: NOP4
21180: ARRAY
21181: NONEQUAL
21182: IFFALSE 21194
// begin result := false ;
21184: NOP4
21188: PUSH
21189: LD_INT 0
21191: ST_TO_ADDR
// break ;
21192: GO 21196
// end ;
21194: GO 21157
21196: POP
21197: POP
// end ;
21198: LD_VAR 0 3
21202: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21203: LD_INT 0
21205: PPUSH
21206: PPUSH
21207: PPUSH
// pom := GetBase ( fac ) ;
21208: NOP4
21212: PUSH
21213: NOP4
21217: PPUSH
21218: NOP4
21222: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21223: NOP4
21227: PUSH
21228: NOP4
21232: PUSH
21233: LD_INT 1
21235: ARRAY
21236: PPUSH
21237: NOP4
21241: PUSH
21242: LD_INT 2
21244: ARRAY
21245: PPUSH
21246: NOP4
21250: PUSH
21251: LD_INT 3
21253: ARRAY
21254: PPUSH
21255: NOP4
21259: PUSH
21260: LD_INT 4
21262: ARRAY
21263: PPUSH
21264: NOP4
21268: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21269: NOP4
21273: PUSH
21274: NOP4
21278: PPUSH
21279: LD_INT 1
21281: PPUSH
21282: NOP4
21286: PUSH
21287: NOP4
21291: PUSH
21292: LD_INT 1
21294: ARRAY
21295: GREATEREQUAL
21296: PUSH
21297: NOP4
21301: PPUSH
21302: LD_INT 2
21304: PPUSH
21305: NOP4
21309: PUSH
21310: NOP4
21314: PUSH
21315: LD_INT 2
21317: ARRAY
21318: GREATEREQUAL
21319: AND
21320: PUSH
21321: NOP4
21325: PPUSH
21326: LD_INT 3
21328: PPUSH
21329: NOP4
21333: PUSH
21334: NOP4
21338: PUSH
21339: LD_INT 3
21341: ARRAY
21342: GREATEREQUAL
21343: AND
21344: ST_TO_ADDR
// end ;
21345: LD_VAR 0 3
21349: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21350: LD_INT 0
21352: PPUSH
21353: PPUSH
21354: PPUSH
21355: PPUSH
// pom := GetBase ( building ) ;
21356: NOP4
21360: PUSH
21361: NOP4
21365: PPUSH
21366: NOP4
21370: ST_TO_ADDR
// if not pom then
21371: NOP4
21375: NOT
21376: IFFALSE 21380
// exit ;
21378: GO 21550
// btype := GetBType ( building ) ;
21380: NOP4
21384: PUSH
21385: NOP4
21389: PPUSH
21390: NOP4
21394: ST_TO_ADDR
// if btype = b_armoury then
21395: NOP4
21399: PUSH
21400: LD_INT 4
21402: EQUAL
21403: IFFALSE 21413
// btype := b_barracks ;
21405: NOP4
21409: PUSH
21410: LD_INT 5
21412: ST_TO_ADDR
// if btype = b_depot then
21413: NOP4
21417: PUSH
21418: LD_INT 0
21420: EQUAL
21421: IFFALSE 21431
// btype := b_warehouse ;
21423: NOP4
21427: PUSH
21428: LD_INT 1
21430: ST_TO_ADDR
// if btype = b_workshop then
21431: NOP4
21435: PUSH
21436: LD_INT 2
21438: EQUAL
21439: IFFALSE 21449
// btype := b_factory ;
21441: NOP4
21445: PUSH
21446: LD_INT 3
21448: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21449: NOP4
21453: PUSH
21454: NOP4
21458: PPUSH
21459: NOP4
21463: PPUSH
21464: NOP4
21468: PPUSH
21469: NOP4
21473: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21474: NOP4
21478: PUSH
21479: NOP4
21483: PPUSH
21484: LD_INT 1
21486: PPUSH
21487: NOP4
21491: PUSH
21492: NOP4
21496: PUSH
21497: LD_INT 1
21499: ARRAY
21500: GREATEREQUAL
21501: PUSH
21502: NOP4
21506: PPUSH
21507: LD_INT 2
21509: PPUSH
21510: NOP4
21514: PUSH
21515: NOP4
21519: PUSH
21520: LD_INT 2
21522: ARRAY
21523: GREATEREQUAL
21524: AND
21525: PUSH
21526: NOP4
21530: PPUSH
21531: LD_INT 3
21533: PPUSH
21534: NOP4
21538: PUSH
21539: NOP4
21543: PUSH
21544: LD_INT 3
21546: ARRAY
21547: GREATEREQUAL
21548: AND
21549: ST_TO_ADDR
// end ;
21550: LD_VAR 0 2
21554: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21555: LD_INT 0
21557: PPUSH
21558: PPUSH
21559: PPUSH
// pom := GetBase ( building ) ;
21560: NOP4
21564: PUSH
21565: NOP4
21569: PPUSH
21570: NOP4
21574: ST_TO_ADDR
// if not pom then
21575: NOP4
21579: NOT
21580: IFFALSE 21584
// exit ;
21582: GO 21685
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21584: NOP4
21588: PUSH
21589: NOP4
21593: PPUSH
21594: NOP4
21598: PPUSH
21599: NOP4
21603: PPUSH
21604: NOP4
21608: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21609: NOP4
21613: PUSH
21614: NOP4
21618: PPUSH
21619: LD_INT 1
21621: PPUSH
21622: NOP4
21626: PUSH
21627: NOP4
21631: PUSH
21632: LD_INT 1
21634: ARRAY
21635: GREATEREQUAL
21636: PUSH
21637: NOP4
21641: PPUSH
21642: LD_INT 2
21644: PPUSH
21645: NOP4
21649: PUSH
21650: NOP4
21654: PUSH
21655: LD_INT 2
21657: ARRAY
21658: GREATEREQUAL
21659: AND
21660: PUSH
21661: NOP4
21665: PPUSH
21666: LD_INT 3
21668: PPUSH
21669: NOP4
21673: PUSH
21674: NOP4
21678: PUSH
21679: LD_INT 3
21681: ARRAY
21682: GREATEREQUAL
21683: AND
21684: ST_TO_ADDR
// end ;
21685: LD_VAR 0 3
21689: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21690: LD_INT 0
21692: PPUSH
21693: PPUSH
21694: PPUSH
21695: PPUSH
21696: PPUSH
21697: PPUSH
21698: PPUSH
21699: PPUSH
21700: PPUSH
21701: PPUSH
21702: PPUSH
// result := false ;
21703: NOP4
21707: PUSH
21708: LD_INT 0
21710: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21711: NOP4
21715: NOT
21716: PUSH
21717: NOP4
21721: NOT
21722: OR
21723: PUSH
21724: NOP4
21728: NOT
21729: OR
21730: PUSH
21731: NOP4
21735: NOT
21736: OR
21737: IFFALSE 21741
// exit ;
21739: GO 22555
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21741: NOP4
21745: PUSH
21746: NOP4
21750: PPUSH
21751: NOP4
21755: PPUSH
21756: NOP4
21760: PPUSH
21761: NOP4
21765: PPUSH
21766: NOP4
21770: PUSH
21771: LD_INT 1
21773: ARRAY
21774: PPUSH
21775: NOP4
21779: PPUSH
21780: LD_INT 0
21782: PPUSH
21783: NOP4
21787: ST_TO_ADDR
// if not hexes then
21788: NOP4
21792: NOT
21793: IFFALSE 21797
// exit ;
21795: GO 22555
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21797: NOP4
21801: PUSH
21802: NOP4
21806: PPUSH
21807: LD_INT 22
21809: PUSH
21810: NOP4
21814: PPUSH
21815: NOP4
21819: PUSH
21820: EMPTY
21821: LIST
21822: LIST
21823: PUSH
21824: LD_INT 2
21826: PUSH
21827: LD_INT 30
21829: PUSH
21830: LD_INT 0
21832: PUSH
21833: EMPTY
21834: LIST
21835: LIST
21836: PUSH
21837: LD_INT 30
21839: PUSH
21840: LD_INT 1
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: PUSH
21847: EMPTY
21848: LIST
21849: LIST
21850: LIST
21851: PUSH
21852: EMPTY
21853: LIST
21854: LIST
21855: PPUSH
21856: NOP4
21860: ST_TO_ADDR
// for i = 1 to hexes do
21861: NOP4
21865: PUSH
21866: DOUBLE
21867: LD_INT 1
21869: DEC
21870: ST_TO_ADDR
21871: NOP4
21875: PUSH
21876: FOR_TO
21877: IFFALSE 22553
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21879: NOP4
21883: PUSH
21884: NOP4
21888: PUSH
21889: NOP4
21893: ARRAY
21894: PUSH
21895: LD_INT 1
21897: ARRAY
21898: PPUSH
21899: NOP4
21903: PUSH
21904: NOP4
21908: ARRAY
21909: PUSH
21910: LD_INT 2
21912: ARRAY
21913: PPUSH
21914: NOP4
21918: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21919: NOP4
21923: PUSH
21924: NOP4
21928: ARRAY
21929: PUSH
21930: LD_INT 1
21932: ARRAY
21933: PPUSH
21934: NOP4
21938: PUSH
21939: NOP4
21943: ARRAY
21944: PUSH
21945: LD_INT 2
21947: ARRAY
21948: PPUSH
21949: NOP4
21953: PUSH
21954: NOP4
21958: PUSH
21959: NOP4
21963: ARRAY
21964: PUSH
21965: LD_INT 1
21967: ARRAY
21968: PPUSH
21969: NOP4
21973: PUSH
21974: NOP4
21978: ARRAY
21979: PUSH
21980: LD_INT 2
21982: ARRAY
21983: PPUSH
21984: NOP4
21988: NOT
21989: OR
21990: PUSH
21991: NOP4
21995: PPUSH
21996: NOP4
22000: PUSH
22001: LD_INT 3
22003: EQUAL
22004: OR
22005: IFFALSE 22011
// exit ;
22007: POP
22008: POP
22009: GO 22555
// if not tmp then
22011: NOP4
22015: NOT
22016: IFFALSE 22020
// continue ;
22018: GO 21876
// result := true ;
22020: NOP4
22024: PUSH
22025: LD_INT 1
22027: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22028: NOP4
22032: PUSH
22033: NOP4
22037: PPUSH
22038: NOP4
22042: PUSH
22043: LD_INT 2
22045: EQUAL
22046: AND
22047: PUSH
22048: NOP4
22052: PPUSH
22053: NOP4
22057: PUSH
22058: LD_INT 1
22060: EQUAL
22061: AND
22062: IFFALSE 22226
// begin if IsDrivenBy ( tmp ) then
22064: NOP4
22068: PPUSH
22069: NOP4
22073: IFFALSE 22077
// continue ;
22075: GO 21876
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22077: NOP4
22081: PPUSH
22082: LD_INT 3
22084: PUSH
22085: LD_INT 60
22087: PUSH
22088: EMPTY
22089: LIST
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PUSH
22095: LD_INT 3
22097: PUSH
22098: LD_INT 55
22100: PUSH
22101: EMPTY
22102: LIST
22103: PUSH
22104: EMPTY
22105: LIST
22106: LIST
22107: PUSH
22108: EMPTY
22109: LIST
22110: LIST
22111: PPUSH
22112: NOP4
22116: IFFALSE 22224
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22118: NOP4
22122: PUSH
22123: NOP4
22127: PPUSH
22128: LD_INT 3
22130: PUSH
22131: LD_INT 60
22133: PUSH
22134: EMPTY
22135: LIST
22136: PUSH
22137: EMPTY
22138: LIST
22139: LIST
22140: PUSH
22141: LD_INT 3
22143: PUSH
22144: LD_INT 55
22146: PUSH
22147: EMPTY
22148: LIST
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PPUSH
22158: NOP4
22162: PUSH
22163: LD_INT 1
22165: ARRAY
22166: ST_TO_ADDR
// if IsInUnit ( driver ) then
22167: NOP4
22171: PPUSH
22172: NOP4
22176: IFFALSE 22187
// ComExit ( driver ) ;
22178: NOP4
22182: PPUSH
22183: NOP4
// AddComEnterUnit ( driver , tmp ) ;
22187: NOP4
22191: PPUSH
22192: NOP4
22196: PPUSH
22197: NOP4
// AddComMoveToArea ( driver , parking ) ;
22201: NOP4
22205: PPUSH
22206: NOP4
22210: PPUSH
22211: NOP4
// AddComExitVehicle ( driver ) ;
22215: NOP4
22219: PPUSH
22220: NOP4
// end ; continue ;
22224: GO 21876
// end ; if not cleaners or not tmp in cleaners then
22226: NOP4
22230: NOT
22231: PUSH
22232: NOP4
22236: PUSH
22237: NOP4
22241: IN
22242: NOT
22243: OR
22244: IFFALSE 22551
// begin if dep then
22246: NOP4
22250: IFFALSE 22386
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22252: NOP4
22256: PUSH
22257: NOP4
22261: PUSH
22262: LD_INT 1
22264: ARRAY
22265: PPUSH
22266: NOP4
22270: PPUSH
22271: NOP4
22275: PUSH
22276: LD_INT 1
22278: ARRAY
22279: PPUSH
22280: NOP4
22284: PPUSH
22285: LD_INT 5
22287: PPUSH
22288: NOP4
22292: PUSH
22293: NOP4
22297: PUSH
22298: LD_INT 1
22300: ARRAY
22301: PPUSH
22302: NOP4
22306: PPUSH
22307: NOP4
22311: PUSH
22312: LD_INT 1
22314: ARRAY
22315: PPUSH
22316: NOP4
22320: PPUSH
22321: LD_INT 5
22323: PPUSH
22324: NOP4
22328: PUSH
22329: EMPTY
22330: LIST
22331: LIST
22332: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22333: NOP4
22337: PUSH
22338: LD_INT 1
22340: ARRAY
22341: PPUSH
22342: NOP4
22346: PUSH
22347: LD_INT 2
22349: ARRAY
22350: PPUSH
22351: NOP4
22355: IFFALSE 22386
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22357: NOP4
22361: PPUSH
22362: NOP4
22366: PUSH
22367: LD_INT 1
22369: ARRAY
22370: PPUSH
22371: NOP4
22375: PUSH
22376: LD_INT 2
22378: ARRAY
22379: PPUSH
22380: NOP4
// continue ;
22384: GO 21876
// end ; end ; r := GetDir ( tmp ) ;
22386: NOP4
22390: PUSH
22391: NOP4
22395: PPUSH
22396: NOP4
22400: ST_TO_ADDR
// if r = 5 then
22401: NOP4
22405: PUSH
22406: LD_INT 5
22408: EQUAL
22409: IFFALSE 22419
// r := 0 ;
22411: NOP4
22415: PUSH
22416: LD_INT 0
22418: ST_TO_ADDR
// for j = r to 5 do
22419: NOP4
22423: PUSH
22424: DOUBLE
22425: NOP4
22429: DEC
22430: ST_TO_ADDR
22431: LD_INT 5
22433: PUSH
22434: FOR_TO
22435: IFFALSE 22549
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22437: NOP4
22441: PUSH
22442: NOP4
22446: PPUSH
22447: NOP4
22451: PPUSH
22452: NOP4
22456: PPUSH
22457: LD_INT 2
22459: PPUSH
22460: NOP4
22464: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22465: NOP4
22469: PUSH
22470: NOP4
22474: PPUSH
22475: NOP4
22479: PPUSH
22480: NOP4
22484: PPUSH
22485: LD_INT 2
22487: PPUSH
22488: NOP4
22492: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22493: NOP4
22497: PPUSH
22498: NOP4
22502: PPUSH
22503: NOP4
22507: PUSH
22508: NOP4
22512: PPUSH
22513: NOP4
22517: PPUSH
22518: NOP4
22522: NOT
22523: AND
22524: IFFALSE 22547
// begin ComMoveXY ( tmp , _x , _y ) ;
22526: NOP4
22530: PPUSH
22531: NOP4
22535: PPUSH
22536: NOP4
22540: PPUSH
22541: NOP4
// break ;
22545: GO 22549
// end ; end ;
22547: GO 22434
22549: POP
22550: POP
// end ; end ;
22551: GO 21876
22553: POP
22554: POP
// end ;
22555: LD_VAR 0 8
22559: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22560: LD_INT 0
22562: PPUSH
// result := true ;
22563: NOP4
22567: PUSH
22568: LD_INT 1
22570: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22571: NOP4
22575: PUSH
22576: LD_INT 24
22578: DOUBLE
22579: EQUAL
22580: IFTRUE 22590
22582: LD_INT 33
22584: DOUBLE
22585: EQUAL
22586: IFTRUE 22590
22588: GO 22615
22590: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22591: NOP4
22595: PUSH
22596: LD_INT 32
22598: PPUSH
22599: NOP4
22603: PPUSH
22604: NOP4
22608: PUSH
22609: LD_INT 2
22611: EQUAL
22612: ST_TO_ADDR
22613: GO 22935
22615: LD_INT 20
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22648
22623: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22624: NOP4
22628: PUSH
22629: LD_INT 6
22631: PPUSH
22632: NOP4
22636: PPUSH
22637: NOP4
22641: PUSH
22642: LD_INT 2
22644: EQUAL
22645: ST_TO_ADDR
22646: GO 22935
22648: LD_INT 22
22650: DOUBLE
22651: EQUAL
22652: IFTRUE 22662
22654: LD_INT 36
22656: DOUBLE
22657: EQUAL
22658: IFTRUE 22662
22660: GO 22687
22662: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22663: NOP4
22667: PUSH
22668: LD_INT 15
22670: PPUSH
22671: NOP4
22675: PPUSH
22676: NOP4
22680: PUSH
22681: LD_INT 2
22683: EQUAL
22684: ST_TO_ADDR
22685: GO 22935
22687: LD_INT 30
22689: DOUBLE
22690: EQUAL
22691: IFTRUE 22695
22693: GO 22720
22695: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22696: NOP4
22700: PUSH
22701: LD_INT 20
22703: PPUSH
22704: NOP4
22708: PPUSH
22709: NOP4
22713: PUSH
22714: LD_INT 2
22716: EQUAL
22717: ST_TO_ADDR
22718: GO 22935
22720: LD_INT 28
22722: DOUBLE
22723: EQUAL
22724: IFTRUE 22734
22726: LD_INT 21
22728: DOUBLE
22729: EQUAL
22730: IFTRUE 22734
22732: GO 22759
22734: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22735: NOP4
22739: PUSH
22740: LD_INT 21
22742: PPUSH
22743: NOP4
22747: PPUSH
22748: NOP4
22752: PUSH
22753: LD_INT 2
22755: EQUAL
22756: ST_TO_ADDR
22757: GO 22935
22759: LD_INT 16
22761: DOUBLE
22762: EQUAL
22763: IFTRUE 22767
22765: GO 22794
22767: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22768: NOP4
22772: PUSH
22773: NOP4
22777: PPUSH
22778: NOP4
22782: PPUSH
22783: NOP4
22787: PUSH
22788: LD_INT 2
22790: EQUAL
22791: ST_TO_ADDR
22792: GO 22935
22794: LD_INT 19
22796: DOUBLE
22797: EQUAL
22798: IFTRUE 22808
22800: LD_INT 23
22802: DOUBLE
22803: EQUAL
22804: IFTRUE 22808
22806: GO 22835
22808: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22809: NOP4
22813: PUSH
22814: NOP4
22818: PPUSH
22819: NOP4
22823: PPUSH
22824: NOP4
22828: PUSH
22829: LD_INT 2
22831: EQUAL
22832: ST_TO_ADDR
22833: GO 22935
22835: LD_INT 17
22837: DOUBLE
22838: EQUAL
22839: IFTRUE 22843
22841: GO 22868
22843: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22844: NOP4
22848: PUSH
22849: LD_INT 39
22851: PPUSH
22852: NOP4
22856: PPUSH
22857: NOP4
22861: PUSH
22862: LD_INT 2
22864: EQUAL
22865: ST_TO_ADDR
22866: GO 22935
22868: LD_INT 18
22870: DOUBLE
22871: EQUAL
22872: IFTRUE 22876
22874: GO 22901
22876: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
22877: NOP4
22881: PUSH
22882: LD_INT 40
22884: PPUSH
22885: NOP4
22889: PPUSH
22890: NOP4
22894: PUSH
22895: LD_INT 2
22897: EQUAL
22898: ST_TO_ADDR
22899: GO 22935
22901: LD_INT 27
22903: DOUBLE
22904: EQUAL
22905: IFTRUE 22909
22907: GO 22934
22909: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
22910: NOP4
22914: PUSH
22915: LD_INT 35
22917: PPUSH
22918: NOP4
22922: PPUSH
22923: NOP4
22927: PUSH
22928: LD_INT 2
22930: EQUAL
22931: ST_TO_ADDR
22932: GO 22935
22934: POP
// end ;
22935: LD_VAR 0 3
22939: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
22940: LD_INT 0
22942: PPUSH
22943: PPUSH
22944: PPUSH
22945: PPUSH
22946: PPUSH
22947: PPUSH
22948: PPUSH
22949: PPUSH
22950: PPUSH
22951: PPUSH
22952: PPUSH
// result := false ;
22953: NOP4
22957: PUSH
22958: LD_INT 0
22960: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22961: NOP4
22965: NOT
22966: PUSH
22967: NOP4
22971: PPUSH
22972: NOP4
22976: PUSH
22977: LD_INT 0
22979: PUSH
22980: LD_INT 1
22982: PUSH
22983: EMPTY
22984: LIST
22985: LIST
22986: IN
22987: NOT
22988: OR
22989: PUSH
22990: NOP4
22994: NOT
22995: OR
22996: PUSH
22997: NOP4
23001: PUSH
23002: LD_INT 0
23004: PUSH
23005: LD_INT 1
23007: PUSH
23008: LD_INT 2
23010: PUSH
23011: LD_INT 3
23013: PUSH
23014: LD_INT 4
23016: PUSH
23017: LD_INT 5
23019: PUSH
23020: EMPTY
23021: LIST
23022: LIST
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: IN
23028: NOT
23029: OR
23030: PUSH
23031: NOP4
23035: PPUSH
23036: NOP4
23040: PPUSH
23041: NOP4
23045: NOT
23046: OR
23047: IFFALSE 23051
// exit ;
23049: GO 23787
// side := GetSide ( depot ) ;
23051: NOP4
23055: PUSH
23056: NOP4
23060: PPUSH
23061: NOP4
23065: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23066: NOP4
23070: PPUSH
23071: NOP4
23075: PPUSH
23076: NOP4
23080: NOT
23081: IFFALSE 23085
// exit ;
23083: GO 23787
// pom := GetBase ( depot ) ;
23085: NOP4
23089: PUSH
23090: NOP4
23094: PPUSH
23095: NOP4
23099: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23100: NOP4
23104: PUSH
23105: NOP4
23109: PPUSH
23110: NOP4
23114: PPUSH
23115: NOP4
23119: PPUSH
23120: NOP4
23124: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23125: NOP4
23129: PPUSH
23130: LD_INT 1
23132: PPUSH
23133: NOP4
23137: PUSH
23138: NOP4
23142: PUSH
23143: LD_INT 1
23145: ARRAY
23146: GREATEREQUAL
23147: PUSH
23148: NOP4
23152: PPUSH
23153: LD_INT 2
23155: PPUSH
23156: NOP4
23160: PUSH
23161: NOP4
23165: PUSH
23166: LD_INT 2
23168: ARRAY
23169: GREATEREQUAL
23170: AND
23171: PUSH
23172: NOP4
23176: PPUSH
23177: LD_INT 3
23179: PPUSH
23180: NOP4
23184: PUSH
23185: NOP4
23189: PUSH
23190: LD_INT 3
23192: ARRAY
23193: GREATEREQUAL
23194: AND
23195: NOT
23196: IFFALSE 23200
// exit ;
23198: GO 23787
// if GetBType ( depot ) = b_depot then
23200: NOP4
23204: PPUSH
23205: NOP4
23209: PUSH
23210: LD_INT 0
23212: EQUAL
23213: IFFALSE 23225
// dist := 28 else
23215: NOP4
23219: PUSH
23220: LD_INT 28
23222: ST_TO_ADDR
23223: GO 23233
// dist := 36 ;
23225: NOP4
23229: PUSH
23230: LD_INT 36
23232: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23233: NOP4
23237: PPUSH
23238: NOP4
23242: PPUSH
23243: NOP4
23247: PPUSH
23248: NOP4
23252: PUSH
23253: NOP4
23257: GREATER
23258: IFFALSE 23262
// exit ;
23260: GO 23787
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23262: NOP4
23266: PUSH
23267: NOP4
23271: PPUSH
23272: NOP4
23276: PPUSH
23277: NOP4
23281: PPUSH
23282: NOP4
23286: PPUSH
23287: NOP4
23291: PPUSH
23292: NOP4
23296: PPUSH
23297: LD_INT 0
23299: PPUSH
23300: NOP4
23304: ST_TO_ADDR
// if not hexes then
23305: NOP4
23309: NOT
23310: IFFALSE 23314
// exit ;
23312: GO 23787
// hex := GetHexInfo ( x , y ) ;
23314: NOP4
23318: PUSH
23319: NOP4
23323: PPUSH
23324: NOP4
23328: PPUSH
23329: NOP4
23333: ST_TO_ADDR
// if hex [ 1 ] then
23334: NOP4
23338: PUSH
23339: LD_INT 1
23341: ARRAY
23342: IFFALSE 23346
// exit ;
23344: GO 23787
// height := hex [ 2 ] ;
23346: NOP4
23350: PUSH
23351: NOP4
23355: PUSH
23356: LD_INT 2
23358: ARRAY
23359: ST_TO_ADDR
// for i = 1 to hexes do
23360: NOP4
23364: PUSH
23365: DOUBLE
23366: LD_INT 1
23368: DEC
23369: ST_TO_ADDR
23370: NOP4
23374: PUSH
23375: FOR_TO
23376: IFFALSE 23706
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23378: NOP4
23382: PUSH
23383: NOP4
23387: ARRAY
23388: PUSH
23389: LD_INT 1
23391: ARRAY
23392: PPUSH
23393: NOP4
23397: PUSH
23398: NOP4
23402: ARRAY
23403: PUSH
23404: LD_INT 2
23406: ARRAY
23407: PPUSH
23408: NOP4
23412: NOT
23413: PUSH
23414: NOP4
23418: PUSH
23419: NOP4
23423: ARRAY
23424: PUSH
23425: LD_INT 1
23427: ARRAY
23428: PPUSH
23429: NOP4
23433: PUSH
23434: NOP4
23438: ARRAY
23439: PUSH
23440: LD_INT 2
23442: ARRAY
23443: PPUSH
23444: NOP4
23448: PUSH
23449: LD_INT 0
23451: GREATER
23452: OR
23453: PUSH
23454: NOP4
23458: PUSH
23459: NOP4
23463: ARRAY
23464: PUSH
23465: LD_INT 1
23467: ARRAY
23468: PPUSH
23469: NOP4
23473: PUSH
23474: NOP4
23478: ARRAY
23479: PUSH
23480: LD_INT 2
23482: ARRAY
23483: PPUSH
23484: NOP4
23488: OR
23489: IFFALSE 23495
// exit ;
23491: POP
23492: POP
23493: GO 23787
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23495: NOP4
23499: PUSH
23500: NOP4
23504: PUSH
23505: NOP4
23509: ARRAY
23510: PUSH
23511: LD_INT 1
23513: ARRAY
23514: PPUSH
23515: NOP4
23519: PUSH
23520: NOP4
23524: ARRAY
23525: PUSH
23526: LD_INT 2
23528: ARRAY
23529: PPUSH
23530: NOP4
23534: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23535: NOP4
23539: PUSH
23540: LD_INT 1
23542: ARRAY
23543: PUSH
23544: NOP4
23548: PUSH
23549: LD_INT 2
23551: ARRAY
23552: PUSH
23553: NOP4
23557: PUSH
23558: LD_INT 2
23560: PLUS
23561: GREATER
23562: OR
23563: PUSH
23564: NOP4
23568: PUSH
23569: LD_INT 2
23571: ARRAY
23572: PUSH
23573: NOP4
23577: PUSH
23578: LD_INT 2
23580: MINUS
23581: LESS
23582: OR
23583: PUSH
23584: NOP4
23588: PUSH
23589: LD_INT 3
23591: ARRAY
23592: PUSH
23593: LD_INT 0
23595: PUSH
23596: LD_INT 8
23598: PUSH
23599: LD_INT 9
23601: PUSH
23602: LD_INT 10
23604: PUSH
23605: LD_INT 11
23607: PUSH
23608: LD_INT 12
23610: PUSH
23611: LD_INT 13
23613: PUSH
23614: LD_INT 16
23616: PUSH
23617: LD_INT 17
23619: PUSH
23620: LD_INT 18
23622: PUSH
23623: LD_INT 19
23625: PUSH
23626: LD_INT 20
23628: PUSH
23629: LD_INT 21
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: LIST
23637: LIST
23638: LIST
23639: LIST
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: LIST
23646: IN
23647: NOT
23648: OR
23649: PUSH
23650: NOP4
23654: PUSH
23655: LD_INT 5
23657: ARRAY
23658: NOT
23659: OR
23660: PUSH
23661: NOP4
23665: PUSH
23666: LD_INT 6
23668: ARRAY
23669: PUSH
23670: LD_INT 1
23672: PUSH
23673: LD_INT 2
23675: PUSH
23676: LD_INT 7
23678: PUSH
23679: LD_INT 9
23681: PUSH
23682: LD_INT 10
23684: PUSH
23685: LD_INT 11
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: LIST
23695: IN
23696: NOT
23697: OR
23698: IFFALSE 23704
// exit ;
23700: POP
23701: POP
23702: GO 23787
// end ;
23704: GO 23375
23706: POP
23707: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23708: NOP4
23712: PPUSH
23713: NOP4
23717: PPUSH
23718: NOP4
23722: PPUSH
23723: LD_INT 20
23725: PPUSH
23726: NOP4
23730: PUSH
23731: LD_INT 4
23733: ARRAY
23734: IFFALSE 23738
// exit ;
23736: GO 23787
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23738: NOP4
23742: PUSH
23743: LD_INT 29
23745: PUSH
23746: LD_INT 30
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: IN
23753: PUSH
23754: NOP4
23758: PPUSH
23759: NOP4
23763: PPUSH
23764: NOP4
23768: PPUSH
23769: NOP4
23773: NOT
23774: AND
23775: IFFALSE 23779
// exit ;
23777: GO 23787
// result := true ;
23779: NOP4
23783: PUSH
23784: LD_INT 1
23786: ST_TO_ADDR
// end ;
23787: LD_VAR 0 6
23791: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23792: LD_INT 0
23794: PPUSH
23795: PPUSH
23796: PPUSH
23797: PPUSH
23798: PPUSH
23799: PPUSH
23800: PPUSH
23801: PPUSH
23802: PPUSH
23803: PPUSH
23804: PPUSH
23805: PPUSH
23806: PPUSH
23807: PPUSH
23808: PPUSH
23809: PPUSH
23810: PPUSH
23811: PPUSH
23812: PPUSH
23813: PPUSH
23814: PPUSH
23815: PPUSH
23816: PPUSH
23817: PPUSH
23818: PPUSH
23819: PPUSH
23820: PPUSH
23821: PPUSH
23822: PPUSH
23823: PPUSH
23824: PPUSH
23825: PPUSH
23826: PPUSH
23827: PPUSH
23828: PPUSH
23829: PPUSH
23830: PPUSH
23831: PPUSH
23832: PPUSH
23833: PPUSH
23834: PPUSH
23835: PPUSH
23836: PPUSH
23837: PPUSH
23838: PPUSH
23839: PPUSH
23840: PPUSH
23841: PPUSH
23842: PPUSH
23843: PPUSH
23844: PPUSH
23845: PPUSH
23846: PPUSH
23847: PPUSH
23848: PPUSH
23849: PPUSH
23850: PPUSH
23851: PPUSH
// result = [ ] ;
23852: NOP4
23856: PUSH
23857: EMPTY
23858: ST_TO_ADDR
// temp_list = [ ] ;
23859: NOP4
23863: PUSH
23864: EMPTY
23865: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23866: NOP4
23870: PUSH
23871: LD_INT 0
23873: PUSH
23874: LD_INT 1
23876: PUSH
23877: LD_INT 2
23879: PUSH
23880: LD_INT 3
23882: PUSH
23883: LD_INT 4
23885: PUSH
23886: LD_INT 5
23888: PUSH
23889: EMPTY
23890: LIST
23891: LIST
23892: LIST
23893: LIST
23894: LIST
23895: LIST
23896: IN
23897: NOT
23898: PUSH
23899: NOP4
23903: PUSH
23904: LD_INT 0
23906: PUSH
23907: LD_INT 1
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: IN
23914: PUSH
23915: NOP4
23919: PUSH
23920: LD_INT 1
23922: PUSH
23923: LD_INT 2
23925: PUSH
23926: LD_INT 3
23928: PUSH
23929: EMPTY
23930: LIST
23931: LIST
23932: LIST
23933: IN
23934: NOT
23935: AND
23936: OR
23937: IFFALSE 23941
// exit ;
23939: GO 42332
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23941: NOP4
23945: PUSH
23946: LD_INT 6
23948: PUSH
23949: LD_INT 7
23951: PUSH
23952: LD_INT 8
23954: PUSH
23955: LD_INT 13
23957: PUSH
23958: LD_INT 12
23960: PUSH
23961: LD_INT 15
23963: PUSH
23964: LD_INT 11
23966: PUSH
23967: LD_INT 14
23969: PUSH
23970: LD_INT 10
23972: PUSH
23973: EMPTY
23974: LIST
23975: LIST
23976: LIST
23977: LIST
23978: LIST
23979: LIST
23980: LIST
23981: LIST
23982: LIST
23983: IN
23984: IFFALSE 23994
// btype = b_lab ;
23986: NOP4
23990: PUSH
23991: LD_INT 6
23993: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23994: NOP4
23998: PUSH
23999: LD_INT 0
24001: PUSH
24002: LD_INT 1
24004: PUSH
24005: LD_INT 2
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: LIST
24012: IN
24013: NOT
24014: PUSH
24015: NOP4
24019: PUSH
24020: LD_INT 0
24022: PUSH
24023: LD_INT 1
24025: PUSH
24026: LD_INT 2
24028: PUSH
24029: LD_INT 3
24031: PUSH
24032: LD_INT 6
24034: PUSH
24035: LD_INT 36
24037: PUSH
24038: LD_INT 4
24040: PUSH
24041: LD_INT 5
24043: PUSH
24044: LD_INT 31
24046: PUSH
24047: LD_INT 32
24049: PUSH
24050: LD_INT 33
24052: PUSH
24053: EMPTY
24054: LIST
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: LIST
24060: LIST
24061: LIST
24062: LIST
24063: LIST
24064: LIST
24065: IN
24066: NOT
24067: PUSH
24068: NOP4
24072: PUSH
24073: LD_INT 1
24075: EQUAL
24076: AND
24077: OR
24078: PUSH
24079: NOP4
24083: PUSH
24084: LD_INT 2
24086: PUSH
24087: LD_INT 3
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: IN
24094: NOT
24095: PUSH
24096: NOP4
24100: PUSH
24101: LD_INT 2
24103: EQUAL
24104: AND
24105: OR
24106: IFFALSE 24116
// mode = 0 ;
24108: NOP4
24112: PUSH
24113: LD_INT 0
24115: ST_TO_ADDR
// case mode of 0 :
24116: NOP4
24120: PUSH
24121: LD_INT 0
24123: DOUBLE
24124: EQUAL
24125: IFTRUE 24129
24127: GO 35582
24129: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24130: NOP4
24134: PUSH
24135: LD_INT 0
24137: PUSH
24138: LD_INT 0
24140: PUSH
24141: EMPTY
24142: LIST
24143: LIST
24144: PUSH
24145: LD_INT 0
24147: PUSH
24148: LD_INT 1
24150: NEG
24151: PUSH
24152: EMPTY
24153: LIST
24154: LIST
24155: PUSH
24156: LD_INT 1
24158: PUSH
24159: LD_INT 0
24161: PUSH
24162: EMPTY
24163: LIST
24164: LIST
24165: PUSH
24166: LD_INT 1
24168: PUSH
24169: LD_INT 1
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: PUSH
24176: LD_INT 0
24178: PUSH
24179: LD_INT 1
24181: PUSH
24182: EMPTY
24183: LIST
24184: LIST
24185: PUSH
24186: LD_INT 1
24188: NEG
24189: PUSH
24190: LD_INT 0
24192: PUSH
24193: EMPTY
24194: LIST
24195: LIST
24196: PUSH
24197: LD_INT 1
24199: NEG
24200: PUSH
24201: LD_INT 1
24203: NEG
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: LD_INT 1
24211: NEG
24212: PUSH
24213: LD_INT 2
24215: NEG
24216: PUSH
24217: EMPTY
24218: LIST
24219: LIST
24220: PUSH
24221: LD_INT 0
24223: PUSH
24224: LD_INT 2
24226: NEG
24227: PUSH
24228: EMPTY
24229: LIST
24230: LIST
24231: PUSH
24232: LD_INT 1
24234: PUSH
24235: LD_INT 1
24237: NEG
24238: PUSH
24239: EMPTY
24240: LIST
24241: LIST
24242: PUSH
24243: LD_INT 1
24245: PUSH
24246: LD_INT 2
24248: PUSH
24249: EMPTY
24250: LIST
24251: LIST
24252: PUSH
24253: LD_INT 0
24255: PUSH
24256: LD_INT 2
24258: PUSH
24259: EMPTY
24260: LIST
24261: LIST
24262: PUSH
24263: LD_INT 1
24265: NEG
24266: PUSH
24267: LD_INT 1
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: PUSH
24274: LD_INT 1
24276: PUSH
24277: LD_INT 3
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: LD_INT 0
24286: PUSH
24287: LD_INT 3
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: PUSH
24294: LD_INT 1
24296: NEG
24297: PUSH
24298: LD_INT 2
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: LIST
24309: LIST
24310: LIST
24311: LIST
24312: LIST
24313: LIST
24314: LIST
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: LIST
24320: LIST
24321: LIST
24322: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24323: NOP4
24327: PUSH
24328: LD_INT 0
24330: PUSH
24331: LD_INT 0
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PUSH
24338: LD_INT 0
24340: PUSH
24341: LD_INT 1
24343: NEG
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 1
24351: PUSH
24352: LD_INT 0
24354: PUSH
24355: EMPTY
24356: LIST
24357: LIST
24358: PUSH
24359: LD_INT 1
24361: PUSH
24362: LD_INT 1
24364: PUSH
24365: EMPTY
24366: LIST
24367: LIST
24368: PUSH
24369: LD_INT 0
24371: PUSH
24372: LD_INT 1
24374: PUSH
24375: EMPTY
24376: LIST
24377: LIST
24378: PUSH
24379: LD_INT 1
24381: NEG
24382: PUSH
24383: LD_INT 0
24385: PUSH
24386: EMPTY
24387: LIST
24388: LIST
24389: PUSH
24390: LD_INT 1
24392: NEG
24393: PUSH
24394: LD_INT 1
24396: NEG
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: PUSH
24402: LD_INT 1
24404: PUSH
24405: LD_INT 1
24407: NEG
24408: PUSH
24409: EMPTY
24410: LIST
24411: LIST
24412: PUSH
24413: LD_INT 2
24415: PUSH
24416: LD_INT 0
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: PUSH
24423: LD_INT 2
24425: PUSH
24426: LD_INT 1
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: PUSH
24433: LD_INT 1
24435: NEG
24436: PUSH
24437: LD_INT 1
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PUSH
24444: LD_INT 2
24446: NEG
24447: PUSH
24448: LD_INT 0
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: PUSH
24455: LD_INT 2
24457: NEG
24458: PUSH
24459: LD_INT 1
24461: NEG
24462: PUSH
24463: EMPTY
24464: LIST
24465: LIST
24466: PUSH
24467: LD_INT 2
24469: NEG
24470: PUSH
24471: LD_INT 1
24473: PUSH
24474: EMPTY
24475: LIST
24476: LIST
24477: PUSH
24478: LD_INT 3
24480: NEG
24481: PUSH
24482: LD_INT 0
24484: PUSH
24485: EMPTY
24486: LIST
24487: LIST
24488: PUSH
24489: LD_INT 3
24491: NEG
24492: PUSH
24493: LD_INT 1
24495: NEG
24496: PUSH
24497: EMPTY
24498: LIST
24499: LIST
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: LIST
24514: LIST
24515: LIST
24516: LIST
24517: LIST
24518: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24519: NOP4
24523: PUSH
24524: LD_INT 0
24526: PUSH
24527: LD_INT 0
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: PUSH
24534: LD_INT 0
24536: PUSH
24537: LD_INT 1
24539: NEG
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: LD_INT 1
24547: PUSH
24548: LD_INT 0
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: PUSH
24555: LD_INT 1
24557: PUSH
24558: LD_INT 1
24560: PUSH
24561: EMPTY
24562: LIST
24563: LIST
24564: PUSH
24565: LD_INT 0
24567: PUSH
24568: LD_INT 1
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PUSH
24575: LD_INT 1
24577: NEG
24578: PUSH
24579: LD_INT 0
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 1
24588: NEG
24589: PUSH
24590: LD_INT 1
24592: NEG
24593: PUSH
24594: EMPTY
24595: LIST
24596: LIST
24597: PUSH
24598: LD_INT 1
24600: NEG
24601: PUSH
24602: LD_INT 2
24604: NEG
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 2
24612: PUSH
24613: LD_INT 1
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 2
24622: PUSH
24623: LD_INT 2
24625: PUSH
24626: EMPTY
24627: LIST
24628: LIST
24629: PUSH
24630: LD_INT 1
24632: PUSH
24633: LD_INT 2
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: PUSH
24640: LD_INT 2
24642: NEG
24643: PUSH
24644: LD_INT 1
24646: NEG
24647: PUSH
24648: EMPTY
24649: LIST
24650: LIST
24651: PUSH
24652: LD_INT 2
24654: NEG
24655: PUSH
24656: LD_INT 2
24658: NEG
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: PUSH
24664: LD_INT 2
24666: NEG
24667: PUSH
24668: LD_INT 3
24670: NEG
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: PUSH
24676: LD_INT 3
24678: NEG
24679: PUSH
24680: LD_INT 2
24682: NEG
24683: PUSH
24684: EMPTY
24685: LIST
24686: LIST
24687: PUSH
24688: LD_INT 3
24690: NEG
24691: PUSH
24692: LD_INT 3
24694: NEG
24695: PUSH
24696: EMPTY
24697: LIST
24698: LIST
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: LIST
24704: LIST
24705: LIST
24706: LIST
24707: LIST
24708: LIST
24709: LIST
24710: LIST
24711: LIST
24712: LIST
24713: LIST
24714: LIST
24715: LIST
24716: LIST
24717: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24718: NOP4
24722: PUSH
24723: LD_INT 0
24725: PUSH
24726: LD_INT 0
24728: PUSH
24729: EMPTY
24730: LIST
24731: LIST
24732: PUSH
24733: LD_INT 0
24735: PUSH
24736: LD_INT 1
24738: NEG
24739: PUSH
24740: EMPTY
24741: LIST
24742: LIST
24743: PUSH
24744: LD_INT 1
24746: PUSH
24747: LD_INT 0
24749: PUSH
24750: EMPTY
24751: LIST
24752: LIST
24753: PUSH
24754: LD_INT 1
24756: PUSH
24757: LD_INT 1
24759: PUSH
24760: EMPTY
24761: LIST
24762: LIST
24763: PUSH
24764: LD_INT 0
24766: PUSH
24767: LD_INT 1
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 1
24776: NEG
24777: PUSH
24778: LD_INT 0
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 1
24787: NEG
24788: PUSH
24789: LD_INT 1
24791: NEG
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 1
24799: NEG
24800: PUSH
24801: LD_INT 2
24803: NEG
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: LD_INT 0
24811: PUSH
24812: LD_INT 2
24814: NEG
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PUSH
24820: LD_INT 1
24822: PUSH
24823: LD_INT 1
24825: NEG
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: PUSH
24831: LD_INT 1
24833: PUSH
24834: LD_INT 2
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 0
24843: PUSH
24844: LD_INT 2
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: LD_INT 1
24853: NEG
24854: PUSH
24855: LD_INT 1
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PUSH
24862: LD_INT 1
24864: NEG
24865: PUSH
24866: LD_INT 3
24868: NEG
24869: PUSH
24870: EMPTY
24871: LIST
24872: LIST
24873: PUSH
24874: LD_INT 0
24876: PUSH
24877: LD_INT 3
24879: NEG
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PUSH
24885: LD_INT 1
24887: PUSH
24888: LD_INT 2
24890: NEG
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: LIST
24907: LIST
24908: LIST
24909: LIST
24910: LIST
24911: LIST
24912: LIST
24913: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24914: NOP4
24918: PUSH
24919: LD_INT 0
24921: PUSH
24922: LD_INT 0
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PUSH
24929: LD_INT 0
24931: PUSH
24932: LD_INT 1
24934: NEG
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: LD_INT 1
24942: PUSH
24943: LD_INT 0
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: PUSH
24950: LD_INT 1
24952: PUSH
24953: LD_INT 1
24955: PUSH
24956: EMPTY
24957: LIST
24958: LIST
24959: PUSH
24960: LD_INT 0
24962: PUSH
24963: LD_INT 1
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 1
24972: NEG
24973: PUSH
24974: LD_INT 0
24976: PUSH
24977: EMPTY
24978: LIST
24979: LIST
24980: PUSH
24981: LD_INT 1
24983: NEG
24984: PUSH
24985: LD_INT 1
24987: NEG
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: PUSH
24993: LD_INT 1
24995: PUSH
24996: LD_INT 1
24998: NEG
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: PUSH
25004: LD_INT 2
25006: PUSH
25007: LD_INT 0
25009: PUSH
25010: EMPTY
25011: LIST
25012: LIST
25013: PUSH
25014: LD_INT 2
25016: PUSH
25017: LD_INT 1
25019: PUSH
25020: EMPTY
25021: LIST
25022: LIST
25023: PUSH
25024: LD_INT 1
25026: NEG
25027: PUSH
25028: LD_INT 1
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: PUSH
25035: LD_INT 2
25037: NEG
25038: PUSH
25039: LD_INT 0
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: PUSH
25046: LD_INT 2
25048: NEG
25049: PUSH
25050: LD_INT 1
25052: NEG
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 2
25060: PUSH
25061: LD_INT 1
25063: NEG
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: PUSH
25069: LD_INT 3
25071: PUSH
25072: LD_INT 0
25074: PUSH
25075: EMPTY
25076: LIST
25077: LIST
25078: PUSH
25079: LD_INT 3
25081: PUSH
25082: LD_INT 1
25084: PUSH
25085: EMPTY
25086: LIST
25087: LIST
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: LIST
25093: LIST
25094: LIST
25095: LIST
25096: LIST
25097: LIST
25098: LIST
25099: LIST
25100: LIST
25101: LIST
25102: LIST
25103: LIST
25104: LIST
25105: LIST
25106: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25107: NOP4
25111: PUSH
25112: LD_INT 0
25114: PUSH
25115: LD_INT 0
25117: PUSH
25118: EMPTY
25119: LIST
25120: LIST
25121: PUSH
25122: LD_INT 0
25124: PUSH
25125: LD_INT 1
25127: NEG
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: PUSH
25133: LD_INT 1
25135: PUSH
25136: LD_INT 0
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PUSH
25143: LD_INT 1
25145: PUSH
25146: LD_INT 1
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: PUSH
25153: LD_INT 0
25155: PUSH
25156: LD_INT 1
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: PUSH
25163: LD_INT 1
25165: NEG
25166: PUSH
25167: LD_INT 0
25169: PUSH
25170: EMPTY
25171: LIST
25172: LIST
25173: PUSH
25174: LD_INT 1
25176: NEG
25177: PUSH
25178: LD_INT 1
25180: NEG
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: PUSH
25186: LD_INT 1
25188: NEG
25189: PUSH
25190: LD_INT 2
25192: NEG
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: PUSH
25198: LD_INT 2
25200: PUSH
25201: LD_INT 1
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 2
25210: PUSH
25211: LD_INT 2
25213: PUSH
25214: EMPTY
25215: LIST
25216: LIST
25217: PUSH
25218: LD_INT 1
25220: PUSH
25221: LD_INT 2
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: PUSH
25228: LD_INT 2
25230: NEG
25231: PUSH
25232: LD_INT 1
25234: NEG
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: PUSH
25240: LD_INT 2
25242: NEG
25243: PUSH
25244: LD_INT 2
25246: NEG
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: LD_INT 3
25254: PUSH
25255: LD_INT 2
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PUSH
25262: LD_INT 3
25264: PUSH
25265: LD_INT 3
25267: PUSH
25268: EMPTY
25269: LIST
25270: LIST
25271: PUSH
25272: LD_INT 2
25274: PUSH
25275: LD_INT 3
25277: PUSH
25278: EMPTY
25279: LIST
25280: LIST
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: LIST
25286: LIST
25287: LIST
25288: LIST
25289: LIST
25290: LIST
25291: LIST
25292: LIST
25293: LIST
25294: LIST
25295: LIST
25296: LIST
25297: LIST
25298: LIST
25299: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25300: NOP4
25304: PUSH
25305: LD_INT 0
25307: PUSH
25308: LD_INT 0
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: PUSH
25315: LD_INT 0
25317: PUSH
25318: LD_INT 1
25320: NEG
25321: PUSH
25322: EMPTY
25323: LIST
25324: LIST
25325: PUSH
25326: LD_INT 1
25328: PUSH
25329: LD_INT 0
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: PUSH
25336: LD_INT 1
25338: PUSH
25339: LD_INT 1
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PUSH
25346: LD_INT 0
25348: PUSH
25349: LD_INT 1
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: PUSH
25356: LD_INT 1
25358: NEG
25359: PUSH
25360: LD_INT 0
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: LD_INT 1
25369: NEG
25370: PUSH
25371: LD_INT 1
25373: NEG
25374: PUSH
25375: EMPTY
25376: LIST
25377: LIST
25378: PUSH
25379: LD_INT 1
25381: NEG
25382: PUSH
25383: LD_INT 2
25385: NEG
25386: PUSH
25387: EMPTY
25388: LIST
25389: LIST
25390: PUSH
25391: LD_INT 0
25393: PUSH
25394: LD_INT 2
25396: NEG
25397: PUSH
25398: EMPTY
25399: LIST
25400: LIST
25401: PUSH
25402: LD_INT 1
25404: PUSH
25405: LD_INT 1
25407: NEG
25408: PUSH
25409: EMPTY
25410: LIST
25411: LIST
25412: PUSH
25413: LD_INT 2
25415: PUSH
25416: LD_INT 0
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PUSH
25423: LD_INT 2
25425: PUSH
25426: LD_INT 1
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: PUSH
25433: LD_INT 2
25435: PUSH
25436: LD_INT 2
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: PUSH
25443: LD_INT 1
25445: PUSH
25446: LD_INT 2
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: PUSH
25453: LD_INT 0
25455: PUSH
25456: LD_INT 2
25458: PUSH
25459: EMPTY
25460: LIST
25461: LIST
25462: PUSH
25463: LD_INT 1
25465: NEG
25466: PUSH
25467: LD_INT 1
25469: PUSH
25470: EMPTY
25471: LIST
25472: LIST
25473: PUSH
25474: LD_INT 2
25476: NEG
25477: PUSH
25478: LD_INT 0
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: LD_INT 2
25487: NEG
25488: PUSH
25489: LD_INT 1
25491: NEG
25492: PUSH
25493: EMPTY
25494: LIST
25495: LIST
25496: PUSH
25497: LD_INT 2
25499: NEG
25500: PUSH
25501: LD_INT 2
25503: NEG
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: LIST
25513: LIST
25514: LIST
25515: LIST
25516: LIST
25517: LIST
25518: LIST
25519: LIST
25520: LIST
25521: LIST
25522: LIST
25523: LIST
25524: LIST
25525: LIST
25526: LIST
25527: LIST
25528: LIST
25529: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25530: NOP4
25534: PUSH
25535: LD_INT 0
25537: PUSH
25538: LD_INT 0
25540: PUSH
25541: EMPTY
25542: LIST
25543: LIST
25544: PUSH
25545: LD_INT 0
25547: PUSH
25548: LD_INT 1
25550: NEG
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PUSH
25556: LD_INT 1
25558: PUSH
25559: LD_INT 0
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 1
25568: PUSH
25569: LD_INT 1
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 0
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 1
25588: NEG
25589: PUSH
25590: LD_INT 0
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 1
25599: NEG
25600: PUSH
25601: LD_INT 1
25603: NEG
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: PUSH
25609: LD_INT 1
25611: NEG
25612: PUSH
25613: LD_INT 2
25615: NEG
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 0
25623: PUSH
25624: LD_INT 2
25626: NEG
25627: PUSH
25628: EMPTY
25629: LIST
25630: LIST
25631: PUSH
25632: LD_INT 1
25634: PUSH
25635: LD_INT 1
25637: NEG
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 2
25645: PUSH
25646: LD_INT 0
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 2
25655: PUSH
25656: LD_INT 1
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 2
25665: PUSH
25666: LD_INT 2
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PUSH
25673: LD_INT 1
25675: PUSH
25676: LD_INT 2
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: LD_INT 0
25685: PUSH
25686: LD_INT 2
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: PUSH
25693: LD_INT 1
25695: NEG
25696: PUSH
25697: LD_INT 1
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: LD_INT 2
25706: NEG
25707: PUSH
25708: LD_INT 0
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: PUSH
25715: LD_INT 2
25717: NEG
25718: PUSH
25719: LD_INT 1
25721: NEG
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: PUSH
25727: LD_INT 2
25729: NEG
25730: PUSH
25731: LD_INT 2
25733: NEG
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: LIST
25743: LIST
25744: LIST
25745: LIST
25746: LIST
25747: LIST
25748: LIST
25749: LIST
25750: LIST
25751: LIST
25752: LIST
25753: LIST
25754: LIST
25755: LIST
25756: LIST
25757: LIST
25758: LIST
25759: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25760: NOP4
25764: PUSH
25765: LD_INT 0
25767: PUSH
25768: LD_INT 0
25770: PUSH
25771: EMPTY
25772: LIST
25773: LIST
25774: PUSH
25775: LD_INT 0
25777: PUSH
25778: LD_INT 1
25780: NEG
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PUSH
25786: LD_INT 1
25788: PUSH
25789: LD_INT 0
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 1
25798: PUSH
25799: LD_INT 1
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 0
25808: PUSH
25809: LD_INT 1
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: LD_INT 1
25818: NEG
25819: PUSH
25820: LD_INT 0
25822: PUSH
25823: EMPTY
25824: LIST
25825: LIST
25826: PUSH
25827: LD_INT 1
25829: NEG
25830: PUSH
25831: LD_INT 1
25833: NEG
25834: PUSH
25835: EMPTY
25836: LIST
25837: LIST
25838: PUSH
25839: LD_INT 1
25841: NEG
25842: PUSH
25843: LD_INT 2
25845: NEG
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PUSH
25851: LD_INT 0
25853: PUSH
25854: LD_INT 2
25856: NEG
25857: PUSH
25858: EMPTY
25859: LIST
25860: LIST
25861: PUSH
25862: LD_INT 1
25864: PUSH
25865: LD_INT 1
25867: NEG
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 2
25875: PUSH
25876: LD_INT 0
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 2
25885: PUSH
25886: LD_INT 1
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: LD_INT 2
25895: PUSH
25896: LD_INT 2
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: LD_INT 1
25905: PUSH
25906: LD_INT 2
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PUSH
25913: LD_INT 0
25915: PUSH
25916: LD_INT 2
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: LD_INT 1
25925: NEG
25926: PUSH
25927: LD_INT 1
25929: PUSH
25930: EMPTY
25931: LIST
25932: LIST
25933: PUSH
25934: LD_INT 2
25936: NEG
25937: PUSH
25938: LD_INT 0
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: PUSH
25945: LD_INT 2
25947: NEG
25948: PUSH
25949: LD_INT 1
25951: NEG
25952: PUSH
25953: EMPTY
25954: LIST
25955: LIST
25956: PUSH
25957: LD_INT 2
25959: NEG
25960: PUSH
25961: LD_INT 2
25963: NEG
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: LIST
25973: LIST
25974: LIST
25975: LIST
25976: LIST
25977: LIST
25978: LIST
25979: LIST
25980: LIST
25981: LIST
25982: LIST
25983: LIST
25984: LIST
25985: LIST
25986: LIST
25987: LIST
25988: LIST
25989: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25990: NOP4
25994: PUSH
25995: LD_INT 0
25997: PUSH
25998: LD_INT 0
26000: PUSH
26001: EMPTY
26002: LIST
26003: LIST
26004: PUSH
26005: LD_INT 0
26007: PUSH
26008: LD_INT 1
26010: NEG
26011: PUSH
26012: EMPTY
26013: LIST
26014: LIST
26015: PUSH
26016: LD_INT 1
26018: PUSH
26019: LD_INT 0
26021: PUSH
26022: EMPTY
26023: LIST
26024: LIST
26025: PUSH
26026: LD_INT 1
26028: PUSH
26029: LD_INT 1
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: LD_INT 0
26038: PUSH
26039: LD_INT 1
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 1
26048: NEG
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PUSH
26057: LD_INT 1
26059: NEG
26060: PUSH
26061: LD_INT 1
26063: NEG
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PUSH
26069: LD_INT 1
26071: NEG
26072: PUSH
26073: LD_INT 2
26075: NEG
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PUSH
26081: LD_INT 0
26083: PUSH
26084: LD_INT 2
26086: NEG
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 1
26094: PUSH
26095: LD_INT 1
26097: NEG
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 2
26105: PUSH
26106: LD_INT 0
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 2
26115: PUSH
26116: LD_INT 1
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 2
26125: PUSH
26126: LD_INT 2
26128: PUSH
26129: EMPTY
26130: LIST
26131: LIST
26132: PUSH
26133: LD_INT 1
26135: PUSH
26136: LD_INT 2
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 0
26145: PUSH
26146: LD_INT 2
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: PUSH
26153: LD_INT 1
26155: NEG
26156: PUSH
26157: LD_INT 1
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: PUSH
26164: LD_INT 2
26166: NEG
26167: PUSH
26168: LD_INT 0
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PUSH
26175: LD_INT 2
26177: NEG
26178: PUSH
26179: LD_INT 1
26181: NEG
26182: PUSH
26183: EMPTY
26184: LIST
26185: LIST
26186: PUSH
26187: LD_INT 2
26189: NEG
26190: PUSH
26191: LD_INT 2
26193: NEG
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: LIST
26203: LIST
26204: LIST
26205: LIST
26206: LIST
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: LIST
26216: LIST
26217: LIST
26218: LIST
26219: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26220: NOP4
26224: PUSH
26225: LD_INT 0
26227: PUSH
26228: LD_INT 0
26230: PUSH
26231: EMPTY
26232: LIST
26233: LIST
26234: PUSH
26235: LD_INT 0
26237: PUSH
26238: LD_INT 1
26240: NEG
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: PUSH
26246: LD_INT 1
26248: PUSH
26249: LD_INT 0
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: LD_INT 1
26258: PUSH
26259: LD_INT 1
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: LD_INT 0
26268: PUSH
26269: LD_INT 1
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 1
26278: NEG
26279: PUSH
26280: LD_INT 0
26282: PUSH
26283: EMPTY
26284: LIST
26285: LIST
26286: PUSH
26287: LD_INT 1
26289: NEG
26290: PUSH
26291: LD_INT 1
26293: NEG
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: PUSH
26299: LD_INT 1
26301: NEG
26302: PUSH
26303: LD_INT 2
26305: NEG
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: PUSH
26311: LD_INT 0
26313: PUSH
26314: LD_INT 2
26316: NEG
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: LD_INT 1
26324: PUSH
26325: LD_INT 1
26327: NEG
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 2
26335: PUSH
26336: LD_INT 0
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 2
26345: PUSH
26346: LD_INT 1
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: PUSH
26353: LD_INT 2
26355: PUSH
26356: LD_INT 2
26358: PUSH
26359: EMPTY
26360: LIST
26361: LIST
26362: PUSH
26363: LD_INT 1
26365: PUSH
26366: LD_INT 2
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: PUSH
26373: LD_INT 0
26375: PUSH
26376: LD_INT 2
26378: PUSH
26379: EMPTY
26380: LIST
26381: LIST
26382: PUSH
26383: LD_INT 1
26385: NEG
26386: PUSH
26387: LD_INT 1
26389: PUSH
26390: EMPTY
26391: LIST
26392: LIST
26393: PUSH
26394: LD_INT 2
26396: NEG
26397: PUSH
26398: LD_INT 0
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 2
26407: NEG
26408: PUSH
26409: LD_INT 1
26411: NEG
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: PUSH
26417: LD_INT 2
26419: NEG
26420: PUSH
26421: LD_INT 2
26423: NEG
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: LIST
26433: LIST
26434: LIST
26435: LIST
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26450: NOP4
26454: PUSH
26455: LD_INT 0
26457: PUSH
26458: LD_INT 0
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 0
26467: PUSH
26468: LD_INT 1
26470: NEG
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PUSH
26476: LD_INT 1
26478: PUSH
26479: LD_INT 0
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 1
26488: PUSH
26489: LD_INT 1
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: LD_INT 0
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 1
26508: NEG
26509: PUSH
26510: LD_INT 0
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 1
26519: NEG
26520: PUSH
26521: LD_INT 1
26523: NEG
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: LD_INT 1
26531: NEG
26532: PUSH
26533: LD_INT 2
26535: NEG
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 0
26543: PUSH
26544: LD_INT 2
26546: NEG
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PUSH
26552: LD_INT 1
26554: PUSH
26555: LD_INT 1
26557: NEG
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 2
26565: PUSH
26566: LD_INT 0
26568: PUSH
26569: EMPTY
26570: LIST
26571: LIST
26572: PUSH
26573: LD_INT 2
26575: PUSH
26576: LD_INT 1
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: LD_INT 2
26585: PUSH
26586: LD_INT 2
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PUSH
26593: LD_INT 1
26595: PUSH
26596: LD_INT 2
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: PUSH
26603: LD_INT 0
26605: PUSH
26606: LD_INT 2
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PUSH
26613: LD_INT 1
26615: NEG
26616: PUSH
26617: LD_INT 1
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 2
26626: NEG
26627: PUSH
26628: LD_INT 0
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 2
26637: NEG
26638: PUSH
26639: LD_INT 1
26641: NEG
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 2
26649: NEG
26650: PUSH
26651: LD_INT 2
26653: NEG
26654: PUSH
26655: EMPTY
26656: LIST
26657: LIST
26658: PUSH
26659: EMPTY
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26680: NOP4
26684: PUSH
26685: LD_INT 0
26687: PUSH
26688: LD_INT 0
26690: PUSH
26691: EMPTY
26692: LIST
26693: LIST
26694: PUSH
26695: LD_INT 0
26697: PUSH
26698: LD_INT 1
26700: NEG
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: LD_INT 1
26708: PUSH
26709: LD_INT 0
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 1
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 0
26728: PUSH
26729: LD_INT 1
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 1
26738: NEG
26739: PUSH
26740: LD_INT 0
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: PUSH
26747: LD_INT 1
26749: NEG
26750: PUSH
26751: LD_INT 1
26753: NEG
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: PUSH
26759: LD_INT 1
26761: NEG
26762: PUSH
26763: LD_INT 2
26765: NEG
26766: PUSH
26767: EMPTY
26768: LIST
26769: LIST
26770: PUSH
26771: LD_INT 0
26773: PUSH
26774: LD_INT 2
26776: NEG
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 1
26784: PUSH
26785: LD_INT 1
26787: NEG
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PUSH
26793: LD_INT 2
26795: PUSH
26796: LD_INT 0
26798: PUSH
26799: EMPTY
26800: LIST
26801: LIST
26802: PUSH
26803: LD_INT 2
26805: PUSH
26806: LD_INT 1
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PUSH
26813: LD_INT 2
26815: PUSH
26816: LD_INT 2
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PUSH
26823: LD_INT 1
26825: PUSH
26826: LD_INT 2
26828: PUSH
26829: EMPTY
26830: LIST
26831: LIST
26832: PUSH
26833: LD_INT 0
26835: PUSH
26836: LD_INT 2
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: PUSH
26843: LD_INT 1
26845: NEG
26846: PUSH
26847: LD_INT 1
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 2
26856: NEG
26857: PUSH
26858: LD_INT 0
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 2
26867: NEG
26868: PUSH
26869: LD_INT 1
26871: NEG
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 2
26879: NEG
26880: PUSH
26881: LD_INT 2
26883: NEG
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 2
26891: NEG
26892: PUSH
26893: LD_INT 3
26895: NEG
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 1
26903: NEG
26904: PUSH
26905: LD_INT 3
26907: NEG
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: LD_INT 1
26915: PUSH
26916: LD_INT 2
26918: NEG
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 2
26926: PUSH
26927: LD_INT 1
26929: NEG
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: LIST
26939: LIST
26940: LIST
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: LIST
26946: LIST
26947: LIST
26948: LIST
26949: LIST
26950: LIST
26951: LIST
26952: LIST
26953: LIST
26954: LIST
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26960: NOP4
26964: PUSH
26965: LD_INT 0
26967: PUSH
26968: LD_INT 0
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 0
26977: PUSH
26978: LD_INT 1
26980: NEG
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: LD_INT 1
26988: PUSH
26989: LD_INT 0
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: LD_INT 1
26998: PUSH
26999: LD_INT 1
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 0
27008: PUSH
27009: LD_INT 1
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: PUSH
27016: LD_INT 1
27018: NEG
27019: PUSH
27020: LD_INT 0
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: PUSH
27027: LD_INT 1
27029: NEG
27030: PUSH
27031: LD_INT 1
27033: NEG
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: PUSH
27039: LD_INT 1
27041: NEG
27042: PUSH
27043: LD_INT 2
27045: NEG
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PUSH
27051: LD_INT 0
27053: PUSH
27054: LD_INT 2
27056: NEG
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 1
27064: PUSH
27065: LD_INT 1
27067: NEG
27068: PUSH
27069: EMPTY
27070: LIST
27071: LIST
27072: PUSH
27073: LD_INT 2
27075: PUSH
27076: LD_INT 0
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 2
27085: PUSH
27086: LD_INT 1
27088: PUSH
27089: EMPTY
27090: LIST
27091: LIST
27092: PUSH
27093: LD_INT 2
27095: PUSH
27096: LD_INT 2
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: PUSH
27103: LD_INT 1
27105: PUSH
27106: LD_INT 2
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 0
27115: PUSH
27116: LD_INT 2
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PUSH
27123: LD_INT 1
27125: NEG
27126: PUSH
27127: LD_INT 1
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: LD_INT 2
27136: NEG
27137: PUSH
27138: LD_INT 0
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 2
27147: NEG
27148: PUSH
27149: LD_INT 1
27151: NEG
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: PUSH
27157: LD_INT 2
27159: NEG
27160: PUSH
27161: LD_INT 2
27163: NEG
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: LD_INT 2
27174: NEG
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 2
27182: PUSH
27183: LD_INT 1
27185: NEG
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 3
27193: PUSH
27194: LD_INT 1
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 3
27203: PUSH
27204: LD_INT 2
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: LIST
27215: LIST
27216: LIST
27217: LIST
27218: LIST
27219: LIST
27220: LIST
27221: LIST
27222: LIST
27223: LIST
27224: LIST
27225: LIST
27226: LIST
27227: LIST
27228: LIST
27229: LIST
27230: LIST
27231: LIST
27232: LIST
27233: LIST
27234: LIST
27235: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27236: NOP4
27240: PUSH
27241: LD_INT 0
27243: PUSH
27244: LD_INT 0
27246: PUSH
27247: EMPTY
27248: LIST
27249: LIST
27250: PUSH
27251: LD_INT 0
27253: PUSH
27254: LD_INT 1
27256: NEG
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: PUSH
27262: LD_INT 1
27264: PUSH
27265: LD_INT 0
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: LD_INT 1
27274: PUSH
27275: LD_INT 1
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PUSH
27282: LD_INT 0
27284: PUSH
27285: LD_INT 1
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: LD_INT 1
27294: NEG
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: EMPTY
27300: LIST
27301: LIST
27302: PUSH
27303: LD_INT 1
27305: NEG
27306: PUSH
27307: LD_INT 1
27309: NEG
27310: PUSH
27311: EMPTY
27312: LIST
27313: LIST
27314: PUSH
27315: LD_INT 1
27317: NEG
27318: PUSH
27319: LD_INT 2
27321: NEG
27322: PUSH
27323: EMPTY
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 0
27329: PUSH
27330: LD_INT 2
27332: NEG
27333: PUSH
27334: EMPTY
27335: LIST
27336: LIST
27337: PUSH
27338: LD_INT 1
27340: PUSH
27341: LD_INT 1
27343: NEG
27344: PUSH
27345: EMPTY
27346: LIST
27347: LIST
27348: PUSH
27349: LD_INT 2
27351: PUSH
27352: LD_INT 0
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: PUSH
27359: LD_INT 2
27361: PUSH
27362: LD_INT 1
27364: PUSH
27365: EMPTY
27366: LIST
27367: LIST
27368: PUSH
27369: LD_INT 2
27371: PUSH
27372: LD_INT 2
27374: PUSH
27375: EMPTY
27376: LIST
27377: LIST
27378: PUSH
27379: LD_INT 1
27381: PUSH
27382: LD_INT 2
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: LD_INT 0
27391: PUSH
27392: LD_INT 2
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: PUSH
27399: LD_INT 1
27401: NEG
27402: PUSH
27403: LD_INT 1
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PUSH
27410: LD_INT 2
27412: NEG
27413: PUSH
27414: LD_INT 0
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 2
27423: NEG
27424: PUSH
27425: LD_INT 1
27427: NEG
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: PUSH
27433: LD_INT 2
27435: NEG
27436: PUSH
27437: LD_INT 2
27439: NEG
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 3
27447: PUSH
27448: LD_INT 1
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: LD_INT 3
27457: PUSH
27458: LD_INT 2
27460: PUSH
27461: EMPTY
27462: LIST
27463: LIST
27464: PUSH
27465: LD_INT 2
27467: PUSH
27468: LD_INT 3
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 1
27477: PUSH
27478: LD_INT 3
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: LIST
27489: LIST
27490: LIST
27491: LIST
27492: LIST
27493: LIST
27494: LIST
27495: LIST
27496: LIST
27497: LIST
27498: LIST
27499: LIST
27500: LIST
27501: LIST
27502: LIST
27503: LIST
27504: LIST
27505: LIST
27506: LIST
27507: LIST
27508: LIST
27509: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27510: NOP4
27514: PUSH
27515: LD_INT 0
27517: PUSH
27518: LD_INT 0
27520: PUSH
27521: EMPTY
27522: LIST
27523: LIST
27524: PUSH
27525: LD_INT 0
27527: PUSH
27528: LD_INT 1
27530: NEG
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 1
27538: PUSH
27539: LD_INT 0
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PUSH
27546: LD_INT 1
27548: PUSH
27549: LD_INT 1
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: PUSH
27556: LD_INT 0
27558: PUSH
27559: LD_INT 1
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 1
27568: NEG
27569: PUSH
27570: LD_INT 0
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: PUSH
27577: LD_INT 1
27579: NEG
27580: PUSH
27581: LD_INT 1
27583: NEG
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: NEG
27592: PUSH
27593: LD_INT 2
27595: NEG
27596: PUSH
27597: EMPTY
27598: LIST
27599: LIST
27600: PUSH
27601: LD_INT 0
27603: PUSH
27604: LD_INT 2
27606: NEG
27607: PUSH
27608: EMPTY
27609: LIST
27610: LIST
27611: PUSH
27612: LD_INT 1
27614: PUSH
27615: LD_INT 1
27617: NEG
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: LD_INT 2
27625: PUSH
27626: LD_INT 0
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 2
27635: PUSH
27636: LD_INT 1
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: LD_INT 2
27645: PUSH
27646: LD_INT 2
27648: PUSH
27649: EMPTY
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 1
27655: PUSH
27656: LD_INT 2
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: LD_INT 2
27668: PUSH
27669: EMPTY
27670: LIST
27671: LIST
27672: PUSH
27673: LD_INT 1
27675: NEG
27676: PUSH
27677: LD_INT 1
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: PUSH
27684: LD_INT 2
27686: NEG
27687: PUSH
27688: LD_INT 0
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: PUSH
27695: LD_INT 2
27697: NEG
27698: PUSH
27699: LD_INT 1
27701: NEG
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 2
27709: NEG
27710: PUSH
27711: LD_INT 2
27713: NEG
27714: PUSH
27715: EMPTY
27716: LIST
27717: LIST
27718: PUSH
27719: LD_INT 2
27721: PUSH
27722: LD_INT 3
27724: PUSH
27725: EMPTY
27726: LIST
27727: LIST
27728: PUSH
27729: LD_INT 1
27731: PUSH
27732: LD_INT 3
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: PUSH
27739: LD_INT 1
27741: NEG
27742: PUSH
27743: LD_INT 2
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: PUSH
27750: LD_INT 2
27752: NEG
27753: PUSH
27754: LD_INT 1
27756: PUSH
27757: EMPTY
27758: LIST
27759: LIST
27760: PUSH
27761: EMPTY
27762: LIST
27763: LIST
27764: LIST
27765: LIST
27766: LIST
27767: LIST
27768: LIST
27769: LIST
27770: LIST
27771: LIST
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: LIST
27777: LIST
27778: LIST
27779: LIST
27780: LIST
27781: LIST
27782: LIST
27783: LIST
27784: LIST
27785: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27786: NOP4
27790: PUSH
27791: LD_INT 0
27793: PUSH
27794: LD_INT 0
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: LD_INT 0
27803: PUSH
27804: LD_INT 1
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: LD_INT 1
27814: PUSH
27815: LD_INT 0
27817: PUSH
27818: EMPTY
27819: LIST
27820: LIST
27821: PUSH
27822: LD_INT 1
27824: PUSH
27825: LD_INT 1
27827: PUSH
27828: EMPTY
27829: LIST
27830: LIST
27831: PUSH
27832: LD_INT 0
27834: PUSH
27835: LD_INT 1
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: PUSH
27842: LD_INT 1
27844: NEG
27845: PUSH
27846: LD_INT 0
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: PUSH
27853: LD_INT 1
27855: NEG
27856: PUSH
27857: LD_INT 1
27859: NEG
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 1
27867: NEG
27868: PUSH
27869: LD_INT 2
27871: NEG
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 0
27879: PUSH
27880: LD_INT 2
27882: NEG
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 1
27890: PUSH
27891: LD_INT 1
27893: NEG
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 2
27901: PUSH
27902: LD_INT 0
27904: PUSH
27905: EMPTY
27906: LIST
27907: LIST
27908: PUSH
27909: LD_INT 2
27911: PUSH
27912: LD_INT 1
27914: PUSH
27915: EMPTY
27916: LIST
27917: LIST
27918: PUSH
27919: LD_INT 2
27921: PUSH
27922: LD_INT 2
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: PUSH
27929: LD_INT 1
27931: PUSH
27932: LD_INT 2
27934: PUSH
27935: EMPTY
27936: LIST
27937: LIST
27938: PUSH
27939: LD_INT 0
27941: PUSH
27942: LD_INT 2
27944: PUSH
27945: EMPTY
27946: LIST
27947: LIST
27948: PUSH
27949: LD_INT 1
27951: NEG
27952: PUSH
27953: LD_INT 1
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: LD_INT 2
27962: NEG
27963: PUSH
27964: LD_INT 0
27966: PUSH
27967: EMPTY
27968: LIST
27969: LIST
27970: PUSH
27971: LD_INT 2
27973: NEG
27974: PUSH
27975: LD_INT 1
27977: NEG
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 2
27985: NEG
27986: PUSH
27987: LD_INT 2
27989: NEG
27990: PUSH
27991: EMPTY
27992: LIST
27993: LIST
27994: PUSH
27995: LD_INT 1
27997: NEG
27998: PUSH
27999: LD_INT 2
28001: PUSH
28002: EMPTY
28003: LIST
28004: LIST
28005: PUSH
28006: LD_INT 2
28008: NEG
28009: PUSH
28010: LD_INT 1
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PUSH
28017: LD_INT 3
28019: NEG
28020: PUSH
28021: LD_INT 1
28023: NEG
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: LD_INT 3
28031: NEG
28032: PUSH
28033: LD_INT 2
28035: NEG
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: LIST
28045: LIST
28046: LIST
28047: LIST
28048: LIST
28049: LIST
28050: LIST
28051: LIST
28052: LIST
28053: LIST
28054: LIST
28055: LIST
28056: LIST
28057: LIST
28058: LIST
28059: LIST
28060: LIST
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28066: NOP4
28070: PUSH
28071: LD_INT 0
28073: PUSH
28074: LD_INT 0
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 0
28083: PUSH
28084: LD_INT 1
28086: NEG
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 1
28094: PUSH
28095: LD_INT 0
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 1
28104: PUSH
28105: LD_INT 1
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: PUSH
28112: LD_INT 0
28114: PUSH
28115: LD_INT 1
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 1
28124: NEG
28125: PUSH
28126: LD_INT 0
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 1
28135: NEG
28136: PUSH
28137: LD_INT 1
28139: NEG
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 1
28147: NEG
28148: PUSH
28149: LD_INT 2
28151: NEG
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: PUSH
28157: LD_INT 0
28159: PUSH
28160: LD_INT 2
28162: NEG
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: PUSH
28168: LD_INT 1
28170: PUSH
28171: LD_INT 1
28173: NEG
28174: PUSH
28175: EMPTY
28176: LIST
28177: LIST
28178: PUSH
28179: LD_INT 2
28181: PUSH
28182: LD_INT 0
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 2
28191: PUSH
28192: LD_INT 1
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 2
28201: PUSH
28202: LD_INT 2
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: LD_INT 1
28211: PUSH
28212: LD_INT 2
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: LD_INT 0
28221: PUSH
28222: LD_INT 2
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 1
28231: NEG
28232: PUSH
28233: LD_INT 1
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: LD_INT 2
28242: NEG
28243: PUSH
28244: LD_INT 0
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 2
28253: NEG
28254: PUSH
28255: LD_INT 1
28257: NEG
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 2
28265: NEG
28266: PUSH
28267: LD_INT 2
28269: NEG
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: PUSH
28275: LD_INT 2
28277: NEG
28278: PUSH
28279: LD_INT 3
28281: NEG
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 1
28289: NEG
28290: PUSH
28291: LD_INT 3
28293: NEG
28294: PUSH
28295: EMPTY
28296: LIST
28297: LIST
28298: PUSH
28299: LD_INT 3
28301: NEG
28302: PUSH
28303: LD_INT 1
28305: NEG
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: LD_INT 3
28313: NEG
28314: PUSH
28315: LD_INT 2
28317: NEG
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: LIST
28327: LIST
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: LIST
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: LIST
28339: LIST
28340: LIST
28341: LIST
28342: LIST
28343: LIST
28344: LIST
28345: LIST
28346: LIST
28347: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28348: NOP4
28352: PUSH
28353: LD_INT 0
28355: PUSH
28356: LD_INT 0
28358: PUSH
28359: EMPTY
28360: LIST
28361: LIST
28362: PUSH
28363: LD_INT 0
28365: PUSH
28366: LD_INT 1
28368: NEG
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: LD_INT 1
28376: PUSH
28377: LD_INT 0
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: PUSH
28384: LD_INT 1
28386: PUSH
28387: LD_INT 1
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: LD_INT 1
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 1
28406: NEG
28407: PUSH
28408: LD_INT 0
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 1
28417: NEG
28418: PUSH
28419: LD_INT 1
28421: NEG
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 1
28429: NEG
28430: PUSH
28431: LD_INT 2
28433: NEG
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: PUSH
28439: LD_INT 0
28441: PUSH
28442: LD_INT 2
28444: NEG
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: LD_INT 1
28455: NEG
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PUSH
28461: LD_INT 2
28463: PUSH
28464: LD_INT 0
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: LD_INT 2
28473: PUSH
28474: LD_INT 1
28476: PUSH
28477: EMPTY
28478: LIST
28479: LIST
28480: PUSH
28481: LD_INT 1
28483: PUSH
28484: LD_INT 2
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 0
28493: PUSH
28494: LD_INT 2
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PUSH
28501: LD_INT 1
28503: NEG
28504: PUSH
28505: LD_INT 1
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: LD_INT 2
28514: NEG
28515: PUSH
28516: LD_INT 1
28518: NEG
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 2
28526: NEG
28527: PUSH
28528: LD_INT 2
28530: NEG
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: LD_INT 2
28538: NEG
28539: PUSH
28540: LD_INT 3
28542: NEG
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 2
28550: PUSH
28551: LD_INT 1
28553: NEG
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 3
28561: PUSH
28562: LD_INT 1
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: LD_INT 3
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 1
28581: NEG
28582: PUSH
28583: LD_INT 2
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: LD_INT 3
28592: NEG
28593: PUSH
28594: LD_INT 2
28596: NEG
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: LIST
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: LIST
28611: LIST
28612: LIST
28613: LIST
28614: LIST
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28627: NOP4
28631: PUSH
28632: LD_INT 0
28634: PUSH
28635: LD_INT 0
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PUSH
28642: LD_INT 0
28644: PUSH
28645: LD_INT 1
28647: NEG
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 1
28655: PUSH
28656: LD_INT 0
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: PUSH
28663: LD_INT 1
28665: PUSH
28666: LD_INT 1
28668: PUSH
28669: EMPTY
28670: LIST
28671: LIST
28672: PUSH
28673: LD_INT 0
28675: PUSH
28676: LD_INT 1
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: LD_INT 1
28685: NEG
28686: PUSH
28687: LD_INT 0
28689: PUSH
28690: EMPTY
28691: LIST
28692: LIST
28693: PUSH
28694: LD_INT 1
28696: NEG
28697: PUSH
28698: LD_INT 1
28700: NEG
28701: PUSH
28702: EMPTY
28703: LIST
28704: LIST
28705: PUSH
28706: LD_INT 1
28708: NEG
28709: PUSH
28710: LD_INT 2
28712: NEG
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 0
28720: PUSH
28721: LD_INT 2
28723: NEG
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: PUSH
28729: LD_INT 1
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 2
28742: PUSH
28743: LD_INT 0
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 2
28752: PUSH
28753: LD_INT 1
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: LD_INT 2
28762: PUSH
28763: LD_INT 2
28765: PUSH
28766: EMPTY
28767: LIST
28768: LIST
28769: PUSH
28770: LD_INT 1
28772: PUSH
28773: LD_INT 2
28775: PUSH
28776: EMPTY
28777: LIST
28778: LIST
28779: PUSH
28780: LD_INT 1
28782: NEG
28783: PUSH
28784: LD_INT 1
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: PUSH
28791: LD_INT 2
28793: NEG
28794: PUSH
28795: LD_INT 0
28797: PUSH
28798: EMPTY
28799: LIST
28800: LIST
28801: PUSH
28802: LD_INT 2
28804: NEG
28805: PUSH
28806: LD_INT 1
28808: NEG
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: LD_INT 1
28816: NEG
28817: PUSH
28818: LD_INT 3
28820: NEG
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: PUSH
28829: LD_INT 2
28831: NEG
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 3
28839: PUSH
28840: LD_INT 2
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 2
28849: PUSH
28850: LD_INT 3
28852: PUSH
28853: EMPTY
28854: LIST
28855: LIST
28856: PUSH
28857: LD_INT 2
28859: NEG
28860: PUSH
28861: LD_INT 1
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 3
28870: NEG
28871: PUSH
28872: LD_INT 1
28874: NEG
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: LIST
28901: LIST
28902: LIST
28903: LIST
28904: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28905: NOP4
28909: PUSH
28910: LD_INT 0
28912: PUSH
28913: LD_INT 0
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 0
28922: PUSH
28923: LD_INT 1
28925: NEG
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: LD_INT 1
28933: PUSH
28934: LD_INT 0
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: LD_INT 1
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 0
28953: PUSH
28954: LD_INT 1
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PUSH
28961: LD_INT 1
28963: NEG
28964: PUSH
28965: LD_INT 0
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 1
28974: NEG
28975: PUSH
28976: LD_INT 1
28978: NEG
28979: PUSH
28980: EMPTY
28981: LIST
28982: LIST
28983: PUSH
28984: LD_INT 1
28986: NEG
28987: PUSH
28988: LD_INT 2
28990: NEG
28991: PUSH
28992: EMPTY
28993: LIST
28994: LIST
28995: PUSH
28996: LD_INT 1
28998: PUSH
28999: LD_INT 1
29001: NEG
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 2
29009: PUSH
29010: LD_INT 0
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: PUSH
29017: LD_INT 2
29019: PUSH
29020: LD_INT 1
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: PUSH
29027: LD_INT 2
29029: PUSH
29030: LD_INT 2
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: PUSH
29037: LD_INT 1
29039: PUSH
29040: LD_INT 2
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PUSH
29047: LD_INT 0
29049: PUSH
29050: LD_INT 2
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 1
29059: NEG
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 2
29070: NEG
29071: PUSH
29072: LD_INT 1
29074: NEG
29075: PUSH
29076: EMPTY
29077: LIST
29078: LIST
29079: PUSH
29080: LD_INT 2
29082: NEG
29083: PUSH
29084: LD_INT 2
29086: NEG
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 2
29094: NEG
29095: PUSH
29096: LD_INT 3
29098: NEG
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 2
29106: PUSH
29107: LD_INT 1
29109: NEG
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: LD_INT 3
29117: PUSH
29118: LD_INT 1
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: LD_INT 3
29130: PUSH
29131: EMPTY
29132: LIST
29133: LIST
29134: PUSH
29135: LD_INT 1
29137: NEG
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 3
29148: NEG
29149: PUSH
29150: LD_INT 2
29152: NEG
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: LIST
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: LIST
29168: LIST
29169: LIST
29170: LIST
29171: LIST
29172: LIST
29173: LIST
29174: LIST
29175: LIST
29176: LIST
29177: LIST
29178: LIST
29179: LIST
29180: LIST
29181: LIST
29182: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29183: NOP4
29187: PUSH
29188: LD_INT 0
29190: PUSH
29191: LD_INT 0
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 0
29200: PUSH
29201: LD_INT 1
29203: NEG
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 1
29211: PUSH
29212: LD_INT 0
29214: PUSH
29215: EMPTY
29216: LIST
29217: LIST
29218: PUSH
29219: LD_INT 1
29221: PUSH
29222: LD_INT 1
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: PUSH
29229: LD_INT 0
29231: PUSH
29232: LD_INT 1
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 1
29241: NEG
29242: PUSH
29243: LD_INT 0
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: PUSH
29250: LD_INT 1
29252: NEG
29253: PUSH
29254: LD_INT 1
29256: NEG
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: NEG
29265: PUSH
29266: LD_INT 2
29268: NEG
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: LD_INT 0
29276: PUSH
29277: LD_INT 2
29279: NEG
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PUSH
29285: LD_INT 1
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 2
29298: PUSH
29299: LD_INT 1
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: PUSH
29306: LD_INT 2
29308: PUSH
29309: LD_INT 2
29311: PUSH
29312: EMPTY
29313: LIST
29314: LIST
29315: PUSH
29316: LD_INT 1
29318: PUSH
29319: LD_INT 2
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 0
29328: PUSH
29329: LD_INT 2
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 1
29338: NEG
29339: PUSH
29340: LD_INT 1
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PUSH
29347: LD_INT 2
29349: NEG
29350: PUSH
29351: LD_INT 0
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: PUSH
29358: LD_INT 2
29360: NEG
29361: PUSH
29362: LD_INT 1
29364: NEG
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: LD_INT 1
29372: NEG
29373: PUSH
29374: LD_INT 3
29376: NEG
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: PUSH
29385: LD_INT 2
29387: NEG
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 3
29395: PUSH
29396: LD_INT 2
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 2
29405: PUSH
29406: LD_INT 3
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: LD_INT 2
29415: NEG
29416: PUSH
29417: LD_INT 1
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 3
29426: NEG
29427: PUSH
29428: LD_INT 1
29430: NEG
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: LIST
29453: LIST
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: LIST
29459: LIST
29460: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29461: NOP4
29465: PUSH
29466: LD_INT 0
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 0
29478: PUSH
29479: LD_INT 1
29481: NEG
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 1
29489: PUSH
29490: LD_INT 0
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 1
29499: PUSH
29500: LD_INT 1
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 0
29509: PUSH
29510: LD_INT 1
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 1
29519: NEG
29520: PUSH
29521: LD_INT 0
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 1
29530: NEG
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 1
29542: NEG
29543: PUSH
29544: LD_INT 2
29546: NEG
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: LD_INT 1
29554: PUSH
29555: LD_INT 1
29557: NEG
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 2
29565: PUSH
29566: LD_INT 0
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PUSH
29573: LD_INT 2
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PUSH
29583: LD_INT 1
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 0
29595: PUSH
29596: LD_INT 2
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: NEG
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 2
29616: NEG
29617: PUSH
29618: LD_INT 0
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: PUSH
29625: LD_INT 2
29627: NEG
29628: PUSH
29629: LD_INT 1
29631: NEG
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 2
29639: NEG
29640: PUSH
29641: LD_INT 2
29643: NEG
29644: PUSH
29645: EMPTY
29646: LIST
29647: LIST
29648: PUSH
29649: LD_INT 2
29651: NEG
29652: PUSH
29653: LD_INT 3
29655: NEG
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: PUSH
29661: LD_INT 2
29663: PUSH
29664: LD_INT 1
29666: NEG
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 3
29674: PUSH
29675: LD_INT 1
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 1
29684: PUSH
29685: LD_INT 3
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: LD_INT 2
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 3
29705: NEG
29706: PUSH
29707: LD_INT 2
29709: NEG
29710: PUSH
29711: EMPTY
29712: LIST
29713: LIST
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: LIST
29719: LIST
29720: LIST
29721: LIST
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29740: NOP4
29744: PUSH
29745: LD_INT 0
29747: PUSH
29748: LD_INT 0
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: LD_INT 0
29757: PUSH
29758: LD_INT 1
29760: NEG
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 1
29768: PUSH
29769: LD_INT 0
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 1
29778: PUSH
29779: LD_INT 1
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 0
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 1
29798: NEG
29799: PUSH
29800: LD_INT 0
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 1
29809: NEG
29810: PUSH
29811: LD_INT 1
29813: NEG
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 1
29821: NEG
29822: PUSH
29823: LD_INT 2
29825: NEG
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 0
29833: PUSH
29834: LD_INT 2
29836: NEG
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 1
29844: PUSH
29845: LD_INT 1
29847: NEG
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 2
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 2
29865: PUSH
29866: LD_INT 2
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: PUSH
29873: LD_INT 1
29875: PUSH
29876: LD_INT 2
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 1
29885: NEG
29886: PUSH
29887: LD_INT 1
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 2
29896: NEG
29897: PUSH
29898: LD_INT 0
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 2
29907: NEG
29908: PUSH
29909: LD_INT 1
29911: NEG
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: LD_INT 2
29919: NEG
29920: PUSH
29921: LD_INT 2
29923: NEG
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: NEG
29932: PUSH
29933: LD_INT 3
29935: NEG
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PUSH
29941: LD_INT 1
29943: PUSH
29944: LD_INT 2
29946: NEG
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 3
29954: PUSH
29955: LD_INT 2
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 2
29964: PUSH
29965: LD_INT 3
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 2
29974: NEG
29975: PUSH
29976: LD_INT 1
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 3
29985: NEG
29986: PUSH
29987: LD_INT 1
29989: NEG
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: LIST
30016: LIST
30017: LIST
30018: LIST
30019: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30020: NOP4
30024: PUSH
30025: LD_INT 0
30027: PUSH
30028: LD_INT 0
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 0
30037: PUSH
30038: LD_INT 1
30040: NEG
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: LD_INT 0
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: LD_INT 1
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: LD_INT 1
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 0
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 1
30089: NEG
30090: PUSH
30091: LD_INT 1
30093: NEG
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 2
30101: PUSH
30102: LD_INT 1
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 2
30111: NEG
30112: PUSH
30113: LD_INT 1
30115: NEG
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30132: NOP4
30136: PUSH
30137: LD_INT 0
30139: PUSH
30140: LD_INT 0
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 0
30149: PUSH
30150: LD_INT 1
30152: NEG
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 1
30160: PUSH
30161: LD_INT 0
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 1
30170: PUSH
30171: LD_INT 1
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 0
30180: PUSH
30181: LD_INT 1
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 1
30190: NEG
30191: PUSH
30192: LD_INT 0
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 1
30201: NEG
30202: PUSH
30203: LD_INT 1
30205: NEG
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 1
30213: NEG
30214: PUSH
30215: LD_INT 2
30217: NEG
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 1
30225: PUSH
30226: LD_INT 2
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30244: NOP4
30248: PUSH
30249: LD_INT 0
30251: PUSH
30252: LD_INT 0
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: LD_INT 1
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: LD_INT 0
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 1
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 0
30292: PUSH
30293: LD_INT 1
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 1
30302: NEG
30303: PUSH
30304: LD_INT 0
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: NEG
30314: PUSH
30315: LD_INT 1
30317: NEG
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 1
30325: PUSH
30326: LD_INT 1
30328: NEG
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: LD_INT 1
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: LIST
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30356: NOP4
30360: PUSH
30361: LD_INT 0
30363: PUSH
30364: LD_INT 0
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 0
30373: PUSH
30374: LD_INT 1
30376: NEG
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 1
30384: PUSH
30385: LD_INT 0
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: PUSH
30395: LD_INT 1
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: LD_INT 1
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: LD_INT 1
30414: NEG
30415: PUSH
30416: LD_INT 0
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 1
30425: NEG
30426: PUSH
30427: LD_INT 1
30429: NEG
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 2
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 2
30447: NEG
30448: PUSH
30449: LD_INT 1
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30468: NOP4
30472: PUSH
30473: LD_INT 0
30475: PUSH
30476: LD_INT 0
30478: PUSH
30479: EMPTY
30480: LIST
30481: LIST
30482: PUSH
30483: LD_INT 0
30485: PUSH
30486: LD_INT 1
30488: NEG
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 1
30496: PUSH
30497: LD_INT 0
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: LD_INT 1
30509: PUSH
30510: EMPTY
30511: LIST
30512: LIST
30513: PUSH
30514: LD_INT 0
30516: PUSH
30517: LD_INT 1
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: LD_INT 1
30526: NEG
30527: PUSH
30528: LD_INT 0
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: NEG
30538: PUSH
30539: LD_INT 1
30541: NEG
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 1
30549: NEG
30550: PUSH
30551: LD_INT 2
30553: NEG
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: PUSH
30562: LD_INT 2
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: LIST
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30580: NOP4
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: LD_INT 0
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PUSH
30595: LD_INT 0
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 1
30618: PUSH
30619: LD_INT 1
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 0
30628: PUSH
30629: LD_INT 1
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 1
30638: NEG
30639: PUSH
30640: LD_INT 0
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: NEG
30650: PUSH
30651: LD_INT 1
30653: NEG
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 1
30661: PUSH
30662: LD_INT 1
30664: NEG
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: NEG
30673: PUSH
30674: LD_INT 1
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30692: NOP4
30696: PUSH
30697: LD_INT 0
30699: PUSH
30700: LD_INT 0
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: LD_INT 1
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 1
30720: PUSH
30721: LD_INT 0
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 1
30730: PUSH
30731: LD_INT 1
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: LD_INT 1
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: PUSH
30748: LD_INT 1
30750: NEG
30751: PUSH
30752: LD_INT 0
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 1
30761: NEG
30762: PUSH
30763: LD_INT 1
30765: NEG
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 1
30773: NEG
30774: PUSH
30775: LD_INT 2
30777: NEG
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: LD_INT 1
30788: NEG
30789: PUSH
30790: EMPTY
30791: LIST
30792: LIST
30793: PUSH
30794: LD_INT 2
30796: PUSH
30797: LD_INT 0
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 2
30806: PUSH
30807: LD_INT 1
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: LD_INT 2
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 1
30826: PUSH
30827: LD_INT 2
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 1
30836: NEG
30837: PUSH
30838: LD_INT 1
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 2
30847: NEG
30848: PUSH
30849: LD_INT 0
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 2
30858: NEG
30859: PUSH
30860: LD_INT 1
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 2
30870: NEG
30871: PUSH
30872: LD_INT 2
30874: NEG
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 2
30882: NEG
30883: PUSH
30884: LD_INT 3
30886: NEG
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 2
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 3
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 3
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 3
30925: PUSH
30926: LD_INT 2
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: LD_INT 3
30935: PUSH
30936: LD_INT 3
30938: PUSH
30939: EMPTY
30940: LIST
30941: LIST
30942: PUSH
30943: LD_INT 2
30945: PUSH
30946: LD_INT 3
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 2
30955: NEG
30956: PUSH
30957: LD_INT 1
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 3
30966: NEG
30967: PUSH
30968: LD_INT 0
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 3
30977: NEG
30978: PUSH
30979: LD_INT 1
30981: NEG
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 3
30989: NEG
30990: PUSH
30991: LD_INT 2
30993: NEG
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 3
31001: NEG
31002: PUSH
31003: LD_INT 3
31005: NEG
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: LIST
31034: LIST
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: LIST
31040: LIST
31041: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31042: NOP4
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: LD_INT 0
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: LD_INT 1
31062: NEG
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 1
31070: PUSH
31071: LD_INT 0
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 1
31080: PUSH
31081: LD_INT 1
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 0
31090: PUSH
31091: LD_INT 1
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: NEG
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: NEG
31112: PUSH
31113: LD_INT 1
31115: NEG
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 1
31123: NEG
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: LD_INT 2
31138: NEG
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 1
31146: PUSH
31147: LD_INT 1
31149: NEG
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 2
31157: PUSH
31158: LD_INT 1
31160: PUSH
31161: EMPTY
31162: LIST
31163: LIST
31164: PUSH
31165: LD_INT 2
31167: PUSH
31168: LD_INT 2
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: LD_INT 2
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 0
31187: PUSH
31188: LD_INT 2
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 2
31208: NEG
31209: PUSH
31210: LD_INT 1
31212: NEG
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 2
31220: NEG
31221: PUSH
31222: LD_INT 2
31224: NEG
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 2
31232: NEG
31233: PUSH
31234: LD_INT 3
31236: NEG
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 1
31244: NEG
31245: PUSH
31246: LD_INT 3
31248: NEG
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 0
31256: PUSH
31257: LD_INT 3
31259: NEG
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PUSH
31265: LD_INT 1
31267: PUSH
31268: LD_INT 2
31270: NEG
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 3
31278: PUSH
31279: LD_INT 2
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 3
31288: PUSH
31289: LD_INT 3
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 2
31298: PUSH
31299: LD_INT 3
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 1
31308: PUSH
31309: LD_INT 3
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: LD_INT 3
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 1
31328: NEG
31329: PUSH
31330: LD_INT 2
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: LD_INT 3
31339: NEG
31340: PUSH
31341: LD_INT 2
31343: NEG
31344: PUSH
31345: EMPTY
31346: LIST
31347: LIST
31348: PUSH
31349: LD_INT 3
31351: NEG
31352: PUSH
31353: LD_INT 3
31355: NEG
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31392: NOP4
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: LD_INT 0
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: LD_INT 1
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: LD_INT 1
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 1
31450: NEG
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 1
31461: NEG
31462: PUSH
31463: LD_INT 1
31465: NEG
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: LD_INT 2
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 0
31485: PUSH
31486: LD_INT 2
31488: NEG
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 1
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 2
31507: PUSH
31508: LD_INT 0
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 2
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 1
31527: PUSH
31528: LD_INT 2
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 0
31537: PUSH
31538: LD_INT 2
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: NEG
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 2
31558: NEG
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 2
31569: NEG
31570: PUSH
31571: LD_INT 1
31573: NEG
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 1
31581: NEG
31582: PUSH
31583: LD_INT 3
31585: NEG
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 0
31593: PUSH
31594: LD_INT 3
31596: NEG
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 1
31604: PUSH
31605: LD_INT 2
31607: NEG
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 2
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 3
31626: PUSH
31627: LD_INT 0
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 3
31636: PUSH
31637: LD_INT 1
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 1
31646: PUSH
31647: LD_INT 3
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 0
31656: PUSH
31657: LD_INT 3
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 1
31666: NEG
31667: PUSH
31668: LD_INT 2
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 2
31677: NEG
31678: PUSH
31679: LD_INT 1
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 3
31688: NEG
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 3
31699: NEG
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31740: NOP4
31744: PUSH
31745: LD_INT 0
31747: PUSH
31748: LD_INT 0
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 0
31757: PUSH
31758: LD_INT 1
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 1
31768: PUSH
31769: LD_INT 0
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 1
31778: PUSH
31779: LD_INT 1
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: LD_INT 1
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 1
31798: NEG
31799: PUSH
31800: LD_INT 0
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: LD_INT 1
31813: NEG
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 1
31821: NEG
31822: PUSH
31823: LD_INT 2
31825: NEG
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 1
31833: PUSH
31834: LD_INT 1
31836: NEG
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 2
31844: PUSH
31845: LD_INT 0
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 2
31854: PUSH
31855: LD_INT 1
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 2
31864: PUSH
31865: LD_INT 2
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 2
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 2
31895: NEG
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 2
31906: NEG
31907: PUSH
31908: LD_INT 1
31910: NEG
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 2
31918: NEG
31919: PUSH
31920: LD_INT 2
31922: NEG
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 2
31930: NEG
31931: PUSH
31932: LD_INT 3
31934: NEG
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: LD_INT 1
31945: NEG
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 3
31953: PUSH
31954: LD_INT 0
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 3
31963: PUSH
31964: LD_INT 1
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 3
31973: PUSH
31974: LD_INT 2
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 3
31983: PUSH
31984: LD_INT 3
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 2
31993: PUSH
31994: LD_INT 3
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PUSH
32001: LD_INT 2
32003: NEG
32004: PUSH
32005: LD_INT 1
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 3
32014: NEG
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 3
32025: NEG
32026: PUSH
32027: LD_INT 1
32029: NEG
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 3
32037: NEG
32038: PUSH
32039: LD_INT 2
32041: NEG
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 3
32049: NEG
32050: PUSH
32051: LD_INT 3
32053: NEG
32054: PUSH
32055: EMPTY
32056: LIST
32057: LIST
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: LIST
32070: LIST
32071: LIST
32072: LIST
32073: LIST
32074: LIST
32075: LIST
32076: LIST
32077: LIST
32078: LIST
32079: LIST
32080: LIST
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32090: NOP4
32094: PUSH
32095: LD_INT 0
32097: PUSH
32098: LD_INT 0
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: LD_INT 0
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 1
32118: PUSH
32119: LD_INT 0
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 1
32128: PUSH
32129: LD_INT 1
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 0
32138: PUSH
32139: LD_INT 1
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: PUSH
32146: LD_INT 1
32148: NEG
32149: PUSH
32150: LD_INT 0
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 1
32159: NEG
32160: PUSH
32161: LD_INT 1
32163: NEG
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 1
32171: NEG
32172: PUSH
32173: LD_INT 2
32175: NEG
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 0
32183: PUSH
32184: LD_INT 2
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: LD_INT 1
32197: NEG
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 2
32205: PUSH
32206: LD_INT 1
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 2
32215: PUSH
32216: LD_INT 2
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 1
32225: PUSH
32226: LD_INT 2
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: LD_INT 2
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: NEG
32246: PUSH
32247: LD_INT 1
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: LD_INT 1
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 2
32268: NEG
32269: PUSH
32270: LD_INT 2
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 2
32280: NEG
32281: PUSH
32282: LD_INT 3
32284: NEG
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 1
32292: NEG
32293: PUSH
32294: LD_INT 3
32296: NEG
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 0
32304: PUSH
32305: LD_INT 3
32307: NEG
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: LD_INT 2
32318: NEG
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 3
32326: PUSH
32327: LD_INT 2
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 3
32336: PUSH
32337: LD_INT 3
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 2
32346: PUSH
32347: LD_INT 3
32349: PUSH
32350: EMPTY
32351: LIST
32352: LIST
32353: PUSH
32354: LD_INT 1
32356: PUSH
32357: LD_INT 3
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 0
32366: PUSH
32367: LD_INT 3
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 1
32376: NEG
32377: PUSH
32378: LD_INT 2
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 3
32387: NEG
32388: PUSH
32389: LD_INT 2
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 3
32399: NEG
32400: PUSH
32401: LD_INT 3
32403: NEG
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: LIST
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: LIST
32434: LIST
32435: LIST
32436: LIST
32437: LIST
32438: LIST
32439: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32440: NOP4
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 0
32457: PUSH
32458: LD_INT 1
32460: NEG
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 1
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 1
32478: PUSH
32479: LD_INT 1
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: LD_INT 1
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PUSH
32496: LD_INT 1
32498: NEG
32499: PUSH
32500: LD_INT 0
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: LD_INT 1
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: LD_INT 2
32525: NEG
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 0
32533: PUSH
32534: LD_INT 2
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: LD_INT 1
32547: NEG
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 2
32555: PUSH
32556: LD_INT 0
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 2
32565: PUSH
32566: LD_INT 1
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 1
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: LD_INT 2
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 1
32595: NEG
32596: PUSH
32597: LD_INT 1
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 2
32606: NEG
32607: PUSH
32608: LD_INT 0
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 2
32617: NEG
32618: PUSH
32619: LD_INT 1
32621: NEG
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 1
32629: NEG
32630: PUSH
32631: LD_INT 3
32633: NEG
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 0
32641: PUSH
32642: LD_INT 3
32644: NEG
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 1
32652: PUSH
32653: LD_INT 2
32655: NEG
32656: PUSH
32657: EMPTY
32658: LIST
32659: LIST
32660: PUSH
32661: LD_INT 2
32663: PUSH
32664: LD_INT 1
32666: NEG
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 3
32674: PUSH
32675: LD_INT 0
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 3
32684: PUSH
32685: LD_INT 1
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: LD_INT 3
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 3
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: NEG
32715: PUSH
32716: LD_INT 2
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 2
32725: NEG
32726: PUSH
32727: LD_INT 1
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: LD_INT 3
32736: NEG
32737: PUSH
32738: LD_INT 0
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 3
32747: NEG
32748: PUSH
32749: LD_INT 1
32751: NEG
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: LIST
32786: LIST
32787: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32788: NOP4
32792: PUSH
32793: LD_INT 0
32795: PUSH
32796: LD_INT 0
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 0
32805: PUSH
32806: LD_INT 1
32808: NEG
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PUSH
32814: LD_INT 1
32816: PUSH
32817: LD_INT 0
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 1
32826: PUSH
32827: LD_INT 1
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 1
32846: NEG
32847: PUSH
32848: LD_INT 0
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: LD_INT 1
32861: NEG
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 1
32869: NEG
32870: PUSH
32871: LD_INT 2
32873: NEG
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PUSH
32879: LD_INT 0
32881: PUSH
32882: LD_INT 2
32884: NEG
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 1
32892: PUSH
32893: LD_INT 1
32895: NEG
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 2
32903: NEG
32904: PUSH
32905: LD_INT 1
32907: NEG
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: PUSH
32913: LD_INT 2
32915: NEG
32916: PUSH
32917: LD_INT 2
32919: NEG
32920: PUSH
32921: EMPTY
32922: LIST
32923: LIST
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32939: NOP4
32943: PUSH
32944: LD_INT 0
32946: PUSH
32947: LD_INT 0
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: PUSH
32954: LD_INT 0
32956: PUSH
32957: LD_INT 1
32959: NEG
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: LD_INT 1
32967: PUSH
32968: LD_INT 0
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 1
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 0
32987: PUSH
32988: LD_INT 1
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 1
32997: NEG
32998: PUSH
32999: LD_INT 0
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 1
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 1
33020: NEG
33021: PUSH
33022: LD_INT 2
33024: NEG
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 0
33032: PUSH
33033: LD_INT 2
33035: NEG
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 1
33043: PUSH
33044: LD_INT 1
33046: NEG
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 2
33054: PUSH
33055: LD_INT 0
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 2
33064: PUSH
33065: LD_INT 1
33067: PUSH
33068: EMPTY
33069: LIST
33070: LIST
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33086: NOP4
33090: PUSH
33091: LD_INT 0
33093: PUSH
33094: LD_INT 0
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 1
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 0
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: NEG
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 1
33155: NEG
33156: PUSH
33157: LD_INT 1
33159: NEG
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 1
33167: PUSH
33168: LD_INT 1
33170: NEG
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 2
33178: PUSH
33179: LD_INT 0
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: LD_INT 1
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 2
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: LD_INT 1
33208: PUSH
33209: LD_INT 2
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: EMPTY
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33230: NOP4
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: LD_INT 0
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 0
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 1
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 0
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 1
33288: NEG
33289: PUSH
33290: LD_INT 0
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 1
33299: NEG
33300: PUSH
33301: LD_INT 1
33303: NEG
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 2
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 2
33321: PUSH
33322: LD_INT 2
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 1
33331: PUSH
33332: LD_INT 2
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: LD_INT 2
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 1
33351: NEG
33352: PUSH
33353: LD_INT 1
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: EMPTY
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33374: NOP4
33378: PUSH
33379: LD_INT 0
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 1
33394: NEG
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: PUSH
33413: LD_INT 1
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 0
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 1
33432: NEG
33433: PUSH
33434: LD_INT 0
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 1
33443: NEG
33444: PUSH
33445: LD_INT 1
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: PUSH
33456: LD_INT 2
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: LD_INT 2
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 1
33475: NEG
33476: PUSH
33477: LD_INT 1
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 2
33486: NEG
33487: PUSH
33488: LD_INT 0
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 2
33497: NEG
33498: PUSH
33499: LD_INT 1
33501: NEG
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33521: NOP4
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: LD_INT 0
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 0
33538: PUSH
33539: LD_INT 1
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: PUSH
33550: LD_INT 0
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 1
33559: PUSH
33560: LD_INT 1
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 0
33569: PUSH
33570: LD_INT 1
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 1
33579: NEG
33580: PUSH
33581: LD_INT 0
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: NEG
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 1
33602: NEG
33603: PUSH
33604: LD_INT 2
33606: NEG
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 1
33614: NEG
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 2
33625: NEG
33626: PUSH
33627: LD_INT 0
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 2
33636: NEG
33637: PUSH
33638: LD_INT 1
33640: NEG
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 2
33648: NEG
33649: PUSH
33650: LD_INT 2
33652: NEG
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: LIST
33666: LIST
33667: LIST
33668: LIST
33669: LIST
33670: LIST
33671: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33672: NOP4
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 0
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 0
33689: PUSH
33690: LD_INT 1
33692: NEG
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 1
33710: PUSH
33711: LD_INT 1
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 1
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: NEG
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 1
33741: NEG
33742: PUSH
33743: LD_INT 1
33745: NEG
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 0
33765: PUSH
33766: LD_INT 2
33768: NEG
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 2
33787: PUSH
33788: LD_INT 0
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 2
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 2
33807: PUSH
33808: LD_INT 2
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 1
33817: PUSH
33818: LD_INT 2
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 0
33827: PUSH
33828: LD_INT 2
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 1
33837: NEG
33838: PUSH
33839: LD_INT 1
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: LD_INT 2
33848: NEG
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: LD_INT 1
33863: NEG
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: NEG
33872: PUSH
33873: LD_INT 2
33875: NEG
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33902: NOP4
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 0
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 0
33919: PUSH
33920: LD_INT 1
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 0
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 1
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: LD_INT 1
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 1
33960: NEG
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 1
33971: NEG
33972: PUSH
33973: LD_INT 1
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 1
33983: NEG
33984: PUSH
33985: LD_INT 2
33987: NEG
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: LD_INT 2
33998: NEG
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 1
34006: PUSH
34007: LD_INT 1
34009: NEG
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 2
34017: PUSH
34018: LD_INT 0
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: PUSH
34028: LD_INT 1
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 2
34037: PUSH
34038: LD_INT 2
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: LD_INT 1
34047: PUSH
34048: LD_INT 2
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: LD_INT 2
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 1
34067: NEG
34068: PUSH
34069: LD_INT 1
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 2
34078: NEG
34079: PUSH
34080: LD_INT 0
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 2
34089: NEG
34090: PUSH
34091: LD_INT 1
34093: NEG
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 2
34101: NEG
34102: PUSH
34103: LD_INT 2
34105: NEG
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: LIST
34120: LIST
34121: LIST
34122: LIST
34123: LIST
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34132: NOP4
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 0
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 0
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 1
34170: PUSH
34171: LD_INT 1
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: LD_INT 1
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 1
34201: NEG
34202: PUSH
34203: LD_INT 1
34205: NEG
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 1
34213: NEG
34214: PUSH
34215: LD_INT 2
34217: NEG
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 0
34225: PUSH
34226: LD_INT 2
34228: NEG
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 1
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 2
34247: PUSH
34248: LD_INT 0
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 2
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 2
34267: PUSH
34268: LD_INT 2
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 2
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: LD_INT 2
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 2
34308: NEG
34309: PUSH
34310: LD_INT 0
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: PUSH
34317: LD_INT 2
34319: NEG
34320: PUSH
34321: LD_INT 1
34323: NEG
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: NEG
34332: PUSH
34333: LD_INT 2
34335: NEG
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34362: NOP4
34366: PUSH
34367: LD_INT 0
34369: PUSH
34370: LD_INT 0
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 0
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 1
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 0
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: NEG
34421: PUSH
34422: LD_INT 0
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: LD_INT 1
34435: NEG
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 2
34447: NEG
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: LD_INT 2
34458: NEG
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: LD_INT 1
34469: NEG
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: LD_INT 0
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: LD_INT 1
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: LD_INT 2
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 1
34507: PUSH
34508: LD_INT 2
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 0
34517: PUSH
34518: LD_INT 2
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: LD_INT 1
34527: NEG
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 2
34538: NEG
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 2
34549: NEG
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 2
34561: NEG
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: LIST
34575: LIST
34576: LIST
34577: LIST
34578: LIST
34579: LIST
34580: LIST
34581: LIST
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34592: NOP4
34596: PUSH
34597: LD_INT 0
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 0
34609: PUSH
34610: LD_INT 1
34612: NEG
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 1
34620: PUSH
34621: LD_INT 0
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 1
34630: PUSH
34631: LD_INT 1
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 0
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 1
34650: NEG
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 1
34661: NEG
34662: PUSH
34663: LD_INT 1
34665: NEG
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 1
34673: NEG
34674: PUSH
34675: LD_INT 2
34677: NEG
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 2
34688: NEG
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 1
34696: PUSH
34697: LD_INT 1
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 2
34707: PUSH
34708: LD_INT 0
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 2
34717: PUSH
34718: LD_INT 1
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: LD_INT 2
34727: PUSH
34728: LD_INT 2
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 1
34737: PUSH
34738: LD_INT 2
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: LD_INT 2
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: LD_INT 1
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 2
34768: NEG
34769: PUSH
34770: LD_INT 0
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 2
34779: NEG
34780: PUSH
34781: LD_INT 1
34783: NEG
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 2
34791: NEG
34792: PUSH
34793: LD_INT 2
34795: NEG
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34822: NOP4
34826: PUSH
34827: LD_INT 0
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 0
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 1
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: LD_INT 1
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 1
34880: NEG
34881: PUSH
34882: LD_INT 0
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 1
34891: NEG
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: LD_INT 1
34903: NEG
34904: PUSH
34905: LD_INT 2
34907: NEG
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 0
34915: PUSH
34916: LD_INT 2
34918: NEG
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 1
34926: PUSH
34927: LD_INT 1
34929: NEG
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 2
34937: PUSH
34938: LD_INT 0
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: LD_INT 1
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: LD_INT 2
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: LD_INT 2
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 1
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 2
34998: NEG
34999: PUSH
35000: LD_INT 0
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: NEG
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: LIST
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35052: NOP4
35056: PUSH
35057: LD_INT 0
35059: PUSH
35060: LD_INT 0
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: LD_INT 1
35072: NEG
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 1
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 1
35090: PUSH
35091: LD_INT 1
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 0
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 1
35110: NEG
35111: PUSH
35112: LD_INT 0
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: LD_INT 1
35125: NEG
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: EMPTY
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35140: NOP4
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 0
35157: PUSH
35158: LD_INT 1
35160: NEG
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 1
35168: PUSH
35169: LD_INT 0
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 1
35178: PUSH
35179: LD_INT 1
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 0
35188: PUSH
35189: LD_INT 1
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 1
35198: NEG
35199: PUSH
35200: LD_INT 0
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 1
35209: NEG
35210: PUSH
35211: LD_INT 1
35213: NEG
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: LIST
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35228: NOP4
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: LD_INT 0
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 0
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 1
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 0
35276: PUSH
35277: LD_INT 1
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 1
35286: NEG
35287: PUSH
35288: LD_INT 0
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 1
35297: NEG
35298: PUSH
35299: LD_INT 1
35301: NEG
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: LIST
35311: LIST
35312: LIST
35313: LIST
35314: LIST
35315: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35316: NOP4
35320: PUSH
35321: LD_INT 0
35323: PUSH
35324: LD_INT 0
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 1
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: LD_INT 1
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: LD_INT 1
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: NEG
35375: PUSH
35376: LD_INT 0
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 1
35385: NEG
35386: PUSH
35387: LD_INT 1
35389: NEG
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: LIST
35399: LIST
35400: LIST
35401: LIST
35402: LIST
35403: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35404: NOP4
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: LD_INT 0
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: LD_INT 1
35424: NEG
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: LD_INT 0
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 1
35442: PUSH
35443: LD_INT 1
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: LD_INT 1
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 1
35462: NEG
35463: PUSH
35464: LD_INT 0
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: NEG
35474: PUSH
35475: LD_INT 1
35477: NEG
35478: PUSH
35479: EMPTY
35480: LIST
35481: LIST
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: LIST
35491: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35492: NOP4
35496: PUSH
35497: LD_INT 0
35499: PUSH
35500: LD_INT 0
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: LD_INT 1
35512: NEG
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: LD_INT 1
35520: PUSH
35521: LD_INT 0
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: PUSH
35531: LD_INT 1
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: LD_INT 1
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 1
35550: NEG
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: NEG
35562: PUSH
35563: LD_INT 1
35565: NEG
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: ST_TO_ADDR
// end ; 1 :
35580: GO 41477
35582: LD_INT 1
35584: DOUBLE
35585: EQUAL
35586: IFTRUE 35590
35588: GO 38213
35590: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35591: NOP4
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: LD_INT 3
35602: NEG
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: LD_INT 3
35613: NEG
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 2
35624: NEG
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: LIST
35634: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35635: NOP4
35639: PUSH
35640: LD_INT 2
35642: PUSH
35643: LD_INT 1
35645: NEG
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 3
35653: PUSH
35654: LD_INT 0
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 3
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: LIST
35675: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35676: NOP4
35680: PUSH
35681: LD_INT 3
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 3
35693: PUSH
35694: LD_INT 3
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: PUSH
35704: LD_INT 3
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: LIST
35715: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35716: NOP4
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: LD_INT 3
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 0
35733: PUSH
35734: LD_INT 3
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 1
35743: NEG
35744: PUSH
35745: LD_INT 2
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: LIST
35756: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35757: NOP4
35761: PUSH
35762: LD_INT 2
35764: NEG
35765: PUSH
35766: LD_INT 1
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 3
35775: NEG
35776: PUSH
35777: LD_INT 0
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 3
35786: NEG
35787: PUSH
35788: LD_INT 1
35790: NEG
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: LIST
35800: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35801: NOP4
35805: PUSH
35806: LD_INT 2
35808: NEG
35809: PUSH
35810: LD_INT 3
35812: NEG
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 3
35820: NEG
35821: PUSH
35822: LD_INT 2
35824: NEG
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 3
35832: NEG
35833: PUSH
35834: LD_INT 3
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: EMPTY
35843: LIST
35844: LIST
35845: LIST
35846: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35847: NOP4
35851: PUSH
35852: LD_INT 1
35854: NEG
35855: PUSH
35856: LD_INT 3
35858: NEG
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: LD_INT 3
35869: NEG
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: LD_INT 2
35880: NEG
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: LIST
35890: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35891: NOP4
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 1
35901: NEG
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 3
35909: PUSH
35910: LD_INT 0
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 3
35919: PUSH
35920: LD_INT 1
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: LIST
35931: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35932: NOP4
35936: PUSH
35937: LD_INT 3
35939: PUSH
35940: LD_INT 2
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 3
35949: PUSH
35950: LD_INT 3
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 2
35959: PUSH
35960: LD_INT 3
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: LIST
35971: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35972: NOP4
35976: PUSH
35977: LD_INT 1
35979: PUSH
35980: LD_INT 3
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: LD_INT 0
35989: PUSH
35990: LD_INT 3
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 1
35999: NEG
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: LIST
36012: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36013: NOP4
36017: PUSH
36018: LD_INT 2
36020: NEG
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 3
36031: NEG
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 3
36042: NEG
36043: PUSH
36044: LD_INT 1
36046: NEG
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: LIST
36056: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36057: NOP4
36061: PUSH
36062: LD_INT 2
36064: NEG
36065: PUSH
36066: LD_INT 3
36068: NEG
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 3
36076: NEG
36077: PUSH
36078: LD_INT 2
36080: NEG
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 3
36088: NEG
36089: PUSH
36090: LD_INT 3
36092: NEG
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: LIST
36102: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36103: NOP4
36107: PUSH
36108: LD_INT 0
36110: PUSH
36111: LD_INT 3
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 1
36121: NEG
36122: PUSH
36123: LD_INT 4
36125: NEG
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: PUSH
36134: LD_INT 3
36136: NEG
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: LIST
36146: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36147: NOP4
36151: PUSH
36152: LD_INT 3
36154: PUSH
36155: LD_INT 0
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 3
36164: PUSH
36165: LD_INT 1
36167: NEG
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 4
36175: PUSH
36176: LD_INT 1
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: LIST
36187: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36188: NOP4
36192: PUSH
36193: LD_INT 3
36195: PUSH
36196: LD_INT 3
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 4
36205: PUSH
36206: LD_INT 3
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 3
36215: PUSH
36216: LD_INT 4
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: LIST
36227: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36228: NOP4
36232: PUSH
36233: LD_INT 0
36235: PUSH
36236: LD_INT 3
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 1
36245: PUSH
36246: LD_INT 4
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 1
36255: NEG
36256: PUSH
36257: LD_INT 3
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: LIST
36268: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36269: NOP4
36273: PUSH
36274: LD_INT 3
36276: NEG
36277: PUSH
36278: LD_INT 0
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: LD_INT 3
36287: NEG
36288: PUSH
36289: LD_INT 1
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 4
36298: NEG
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: LIST
36312: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36313: NOP4
36317: PUSH
36318: LD_INT 3
36320: NEG
36321: PUSH
36322: LD_INT 3
36324: NEG
36325: PUSH
36326: EMPTY
36327: LIST
36328: LIST
36329: PUSH
36330: LD_INT 3
36332: NEG
36333: PUSH
36334: LD_INT 4
36336: NEG
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 4
36344: NEG
36345: PUSH
36346: LD_INT 3
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: LIST
36358: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36359: NOP4
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: LD_INT 3
36370: NEG
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: LD_INT 3
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 1
36389: PUSH
36390: LD_INT 2
36392: NEG
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 1
36400: NEG
36401: PUSH
36402: LD_INT 4
36404: NEG
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: LD_INT 4
36415: NEG
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 1
36423: PUSH
36424: LD_INT 3
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: LD_INT 5
36438: NEG
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 0
36446: PUSH
36447: LD_INT 5
36449: NEG
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 1
36457: PUSH
36458: LD_INT 4
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 1
36468: NEG
36469: PUSH
36470: LD_INT 6
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 0
36480: PUSH
36481: LD_INT 6
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: LD_INT 5
36494: NEG
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36514: NOP4
36518: PUSH
36519: LD_INT 2
36521: PUSH
36522: LD_INT 1
36524: NEG
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 3
36532: PUSH
36533: LD_INT 0
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 3
36542: PUSH
36543: LD_INT 1
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 3
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 4
36563: PUSH
36564: LD_INT 0
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: LD_INT 4
36573: PUSH
36574: LD_INT 1
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 4
36583: PUSH
36584: LD_INT 1
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 5
36594: PUSH
36595: LD_INT 0
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 5
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 5
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 6
36625: PUSH
36626: LD_INT 0
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 6
36635: PUSH
36636: LD_INT 1
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36657: NOP4
36661: PUSH
36662: LD_INT 3
36664: PUSH
36665: LD_INT 2
36667: PUSH
36668: EMPTY
36669: LIST
36670: LIST
36671: PUSH
36672: LD_INT 3
36674: PUSH
36675: LD_INT 3
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 2
36684: PUSH
36685: LD_INT 3
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: PUSH
36692: LD_INT 4
36694: PUSH
36695: LD_INT 3
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 4
36704: PUSH
36705: LD_INT 4
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 3
36714: PUSH
36715: LD_INT 4
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 5
36724: PUSH
36725: LD_INT 4
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 5
36734: PUSH
36735: LD_INT 5
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 4
36744: PUSH
36745: LD_INT 5
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 6
36754: PUSH
36755: LD_INT 5
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 6
36764: PUSH
36765: LD_INT 6
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 5
36774: PUSH
36775: LD_INT 6
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: LIST
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36796: NOP4
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: LD_INT 3
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 0
36813: PUSH
36814: LD_INT 3
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 1
36823: NEG
36824: PUSH
36825: LD_INT 2
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 1
36834: PUSH
36835: LD_INT 4
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 0
36844: PUSH
36845: LD_INT 4
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 1
36854: NEG
36855: PUSH
36856: LD_INT 3
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 1
36865: PUSH
36866: LD_INT 5
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: LD_INT 5
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 1
36885: NEG
36886: PUSH
36887: LD_INT 4
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: LD_INT 6
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 0
36906: PUSH
36907: LD_INT 6
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 1
36916: NEG
36917: PUSH
36918: LD_INT 5
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: LIST
36929: LIST
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36939: NOP4
36943: PUSH
36944: LD_INT 2
36946: NEG
36947: PUSH
36948: LD_INT 1
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 3
36957: NEG
36958: PUSH
36959: LD_INT 0
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 3
36968: NEG
36969: PUSH
36970: LD_INT 1
36972: NEG
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 3
36980: NEG
36981: PUSH
36982: LD_INT 1
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PUSH
36989: LD_INT 4
36991: NEG
36992: PUSH
36993: LD_INT 0
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 4
37002: NEG
37003: PUSH
37004: LD_INT 1
37006: NEG
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: LD_INT 4
37014: NEG
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: LD_INT 5
37025: NEG
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 5
37036: NEG
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 5
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 6
37059: NEG
37060: PUSH
37061: LD_INT 0
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 6
37070: NEG
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: LIST
37091: LIST
37092: LIST
37093: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37094: NOP4
37098: PUSH
37099: LD_INT 2
37101: NEG
37102: PUSH
37103: LD_INT 3
37105: NEG
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 3
37113: NEG
37114: PUSH
37115: LD_INT 2
37117: NEG
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 3
37125: NEG
37126: PUSH
37127: LD_INT 3
37129: NEG
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PUSH
37135: LD_INT 3
37137: NEG
37138: PUSH
37139: LD_INT 4
37141: NEG
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 4
37149: NEG
37150: PUSH
37151: LD_INT 3
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 4
37161: NEG
37162: PUSH
37163: LD_INT 4
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 4
37173: NEG
37174: PUSH
37175: LD_INT 5
37177: NEG
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 5
37185: NEG
37186: PUSH
37187: LD_INT 4
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 5
37197: NEG
37198: PUSH
37199: LD_INT 5
37201: NEG
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 5
37209: NEG
37210: PUSH
37211: LD_INT 6
37213: NEG
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PUSH
37219: LD_INT 6
37221: NEG
37222: PUSH
37223: LD_INT 5
37225: NEG
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 6
37233: NEG
37234: PUSH
37235: LD_INT 6
37237: NEG
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: LIST
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37257: NOP4
37261: PUSH
37262: LD_INT 0
37264: PUSH
37265: LD_INT 2
37267: NEG
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 1
37275: NEG
37276: PUSH
37277: LD_INT 3
37279: NEG
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: LD_INT 2
37290: NEG
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: LIST
37300: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37301: NOP4
37305: PUSH
37306: LD_INT 2
37308: PUSH
37309: LD_INT 0
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 2
37318: PUSH
37319: LD_INT 1
37321: NEG
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 3
37329: PUSH
37330: LD_INT 1
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: LIST
37341: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37342: NOP4
37346: PUSH
37347: LD_INT 2
37349: PUSH
37350: LD_INT 2
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 3
37359: PUSH
37360: LD_INT 2
37362: PUSH
37363: EMPTY
37364: LIST
37365: LIST
37366: PUSH
37367: LD_INT 2
37369: PUSH
37370: LD_INT 3
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: LIST
37381: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37382: NOP4
37386: PUSH
37387: LD_INT 0
37389: PUSH
37390: LD_INT 2
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 1
37399: PUSH
37400: LD_INT 3
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: LD_INT 1
37409: NEG
37410: PUSH
37411: LD_INT 2
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: LIST
37422: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37423: NOP4
37427: PUSH
37428: LD_INT 2
37430: NEG
37431: PUSH
37432: LD_INT 0
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 2
37441: NEG
37442: PUSH
37443: LD_INT 1
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 3
37452: NEG
37453: PUSH
37454: LD_INT 1
37456: NEG
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: LIST
37466: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37467: NOP4
37471: PUSH
37472: LD_INT 2
37474: NEG
37475: PUSH
37476: LD_INT 2
37478: NEG
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 2
37486: NEG
37487: PUSH
37488: LD_INT 3
37490: NEG
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 3
37498: NEG
37499: PUSH
37500: LD_INT 2
37502: NEG
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: LIST
37512: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37513: NOP4
37517: PUSH
37518: LD_INT 2
37520: NEG
37521: PUSH
37522: LD_INT 3
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 1
37532: NEG
37533: PUSH
37534: LD_INT 3
37536: NEG
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37546: NOP4
37550: PUSH
37551: LD_INT 1
37553: PUSH
37554: LD_INT 2
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: PUSH
37565: LD_INT 1
37567: NEG
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37577: NOP4
37581: PUSH
37582: LD_INT 3
37584: PUSH
37585: LD_INT 1
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 3
37594: PUSH
37595: LD_INT 2
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37606: NOP4
37610: PUSH
37611: LD_INT 2
37613: PUSH
37614: LD_INT 3
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 3
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37635: NOP4
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 2
37653: NEG
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37666: NOP4
37670: PUSH
37671: LD_INT 3
37673: NEG
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 3
37685: NEG
37686: PUSH
37687: LD_INT 2
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37699: NOP4
37703: PUSH
37704: LD_INT 1
37706: NEG
37707: PUSH
37708: LD_INT 3
37710: NEG
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: PUSH
37716: LD_INT 0
37718: PUSH
37719: LD_INT 3
37721: NEG
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: LD_INT 2
37732: NEG
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: LIST
37742: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37743: NOP4
37747: PUSH
37748: LD_INT 2
37750: PUSH
37751: LD_INT 1
37753: NEG
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 3
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 3
37771: PUSH
37772: LD_INT 1
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: LIST
37783: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37784: NOP4
37788: PUSH
37789: LD_INT 3
37791: PUSH
37792: LD_INT 2
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 3
37801: PUSH
37802: LD_INT 3
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 2
37811: PUSH
37812: LD_INT 3
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: LIST
37823: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37824: NOP4
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: LD_INT 3
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 0
37841: PUSH
37842: LD_INT 3
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: LD_INT 2
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: LIST
37864: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37865: NOP4
37869: PUSH
37870: LD_INT 2
37872: NEG
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 3
37883: NEG
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 3
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: LIST
37908: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37909: NOP4
37913: PUSH
37914: LD_INT 2
37916: NEG
37917: PUSH
37918: LD_INT 3
37920: NEG
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 3
37928: NEG
37929: PUSH
37930: LD_INT 2
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 3
37940: NEG
37941: PUSH
37942: LD_INT 3
37944: NEG
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: LIST
37954: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37955: NOP4
37959: PUSH
37960: LD_INT 1
37962: NEG
37963: PUSH
37964: LD_INT 2
37966: NEG
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: LD_INT 2
37977: NEG
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 1
37985: PUSH
37986: LD_INT 1
37988: NEG
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: LIST
37998: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37999: NOP4
38003: PUSH
38004: LD_INT 1
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: PUSH
38018: LD_INT 0
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 2
38027: PUSH
38028: LD_INT 1
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: LIST
38039: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38040: NOP4
38044: PUSH
38045: LD_INT 2
38047: PUSH
38048: LD_INT 1
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 2
38057: PUSH
38058: LD_INT 2
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 1
38067: PUSH
38068: LD_INT 2
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: LIST
38079: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38080: NOP4
38084: PUSH
38085: LD_INT 1
38087: PUSH
38088: LD_INT 2
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: LD_INT 2
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: LIST
38120: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38121: NOP4
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 2
38139: NEG
38140: PUSH
38141: LD_INT 0
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 2
38150: NEG
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: LIST
38164: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38165: NOP4
38169: PUSH
38170: LD_INT 1
38172: NEG
38173: PUSH
38174: LD_INT 2
38176: NEG
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 2
38184: NEG
38185: PUSH
38186: LD_INT 1
38188: NEG
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 2
38196: NEG
38197: PUSH
38198: LD_INT 2
38200: NEG
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: LIST
38210: ST_TO_ADDR
// end ; 2 :
38211: GO 41477
38213: LD_INT 2
38215: DOUBLE
38216: EQUAL
38217: IFTRUE 38221
38219: GO 41476
38221: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38222: NOP4
38226: PUSH
38227: LD_INT 4
38229: PUSH
38230: LD_INT 0
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 4
38239: PUSH
38240: LD_INT 1
38242: NEG
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 5
38250: PUSH
38251: LD_INT 0
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 5
38260: PUSH
38261: LD_INT 1
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 4
38270: PUSH
38271: LD_INT 1
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 3
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: PUSH
38291: LD_INT 1
38293: NEG
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: LD_INT 3
38301: PUSH
38302: LD_INT 2
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 5
38312: PUSH
38313: LD_INT 2
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 3
38322: PUSH
38323: LD_INT 3
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 3
38332: PUSH
38333: LD_INT 2
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 4
38342: PUSH
38343: LD_INT 3
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 4
38352: PUSH
38353: LD_INT 4
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 3
38362: PUSH
38363: LD_INT 4
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 2
38372: PUSH
38373: LD_INT 3
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: LD_INT 2
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 4
38392: PUSH
38393: LD_INT 2
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: LD_INT 4
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 0
38412: PUSH
38413: LD_INT 4
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: LD_INT 3
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: PUSH
38433: LD_INT 4
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 1
38442: PUSH
38443: LD_INT 5
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: LD_INT 5
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 1
38462: NEG
38463: PUSH
38464: LD_INT 4
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: LD_INT 1
38473: NEG
38474: PUSH
38475: LD_INT 3
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: PUSH
38485: LD_INT 5
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: NEG
38495: PUSH
38496: LD_INT 3
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 3
38505: NEG
38506: PUSH
38507: LD_INT 0
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 3
38516: NEG
38517: PUSH
38518: LD_INT 1
38520: NEG
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 2
38528: NEG
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 2
38539: NEG
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 3
38550: NEG
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: LD_INT 4
38561: NEG
38562: PUSH
38563: LD_INT 0
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 4
38572: NEG
38573: PUSH
38574: LD_INT 1
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 4
38584: NEG
38585: PUSH
38586: LD_INT 2
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 2
38596: NEG
38597: PUSH
38598: LD_INT 2
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 4
38607: NEG
38608: PUSH
38609: LD_INT 4
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 4
38619: NEG
38620: PUSH
38621: LD_INT 5
38623: NEG
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 3
38631: NEG
38632: PUSH
38633: LD_INT 4
38635: NEG
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 3
38643: NEG
38644: PUSH
38645: LD_INT 3
38647: NEG
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 4
38655: NEG
38656: PUSH
38657: LD_INT 3
38659: NEG
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 5
38667: NEG
38668: PUSH
38669: LD_INT 4
38671: NEG
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 5
38679: NEG
38680: PUSH
38681: LD_INT 5
38683: NEG
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 3
38691: NEG
38692: PUSH
38693: LD_INT 5
38695: NEG
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PUSH
38701: LD_INT 5
38703: NEG
38704: PUSH
38705: LD_INT 3
38707: NEG
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: LIST
38720: LIST
38721: LIST
38722: LIST
38723: LIST
38724: LIST
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38760: NOP4
38764: PUSH
38765: LD_INT 4
38767: PUSH
38768: LD_INT 4
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 4
38777: PUSH
38778: LD_INT 3
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 5
38787: PUSH
38788: LD_INT 4
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 5
38797: PUSH
38798: LD_INT 5
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 4
38807: PUSH
38808: LD_INT 5
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 3
38817: PUSH
38818: LD_INT 4
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 3
38827: PUSH
38828: LD_INT 3
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 5
38837: PUSH
38838: LD_INT 3
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: LD_INT 3
38847: PUSH
38848: LD_INT 5
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: LD_INT 3
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: LD_INT 2
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 1
38877: PUSH
38878: LD_INT 3
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 1
38887: PUSH
38888: LD_INT 4
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 0
38897: PUSH
38898: LD_INT 4
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: LD_INT 3
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: PUSH
38916: LD_INT 1
38918: NEG
38919: PUSH
38920: LD_INT 2
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 2
38929: PUSH
38930: LD_INT 4
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 2
38939: NEG
38940: PUSH
38941: LD_INT 2
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 4
38950: NEG
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 4
38961: NEG
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 3
38973: NEG
38974: PUSH
38975: LD_INT 0
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 3
38984: NEG
38985: PUSH
38986: LD_INT 1
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 4
38995: NEG
38996: PUSH
38997: LD_INT 1
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 5
39006: NEG
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 5
39017: NEG
39018: PUSH
39019: LD_INT 1
39021: NEG
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 5
39029: NEG
39030: PUSH
39031: LD_INT 2
39033: NEG
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 3
39041: NEG
39042: PUSH
39043: LD_INT 2
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 3
39052: NEG
39053: PUSH
39054: LD_INT 3
39056: NEG
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 3
39064: NEG
39065: PUSH
39066: LD_INT 4
39068: NEG
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 2
39076: NEG
39077: PUSH
39078: LD_INT 3
39080: NEG
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 2
39088: NEG
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 3
39100: NEG
39101: PUSH
39102: LD_INT 2
39104: NEG
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: LD_INT 4
39112: NEG
39113: PUSH
39114: LD_INT 3
39116: NEG
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 4
39124: NEG
39125: PUSH
39126: LD_INT 4
39128: NEG
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 2
39136: NEG
39137: PUSH
39138: LD_INT 4
39140: NEG
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 4
39148: NEG
39149: PUSH
39150: LD_INT 2
39152: NEG
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 0
39160: PUSH
39161: LD_INT 4
39163: NEG
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 0
39171: PUSH
39172: LD_INT 5
39174: NEG
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 1
39182: PUSH
39183: LD_INT 4
39185: NEG
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 1
39193: PUSH
39194: LD_INT 3
39196: NEG
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 0
39204: PUSH
39205: LD_INT 3
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 1
39215: NEG
39216: PUSH
39217: LD_INT 4
39219: NEG
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 1
39227: NEG
39228: PUSH
39229: LD_INT 5
39231: NEG
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 2
39239: PUSH
39240: LD_INT 3
39242: NEG
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 2
39250: NEG
39251: PUSH
39252: LD_INT 5
39254: NEG
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: LIST
39273: LIST
39274: LIST
39275: LIST
39276: LIST
39277: LIST
39278: LIST
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: LIST
39299: LIST
39300: LIST
39301: LIST
39302: LIST
39303: LIST
39304: LIST
39305: LIST
39306: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39307: NOP4
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: LD_INT 4
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 0
39324: PUSH
39325: LD_INT 3
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 1
39334: PUSH
39335: LD_INT 4
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 1
39344: PUSH
39345: LD_INT 5
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 0
39354: PUSH
39355: LD_INT 5
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 1
39364: NEG
39365: PUSH
39366: LD_INT 4
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 1
39375: NEG
39376: PUSH
39377: LD_INT 3
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 2
39386: PUSH
39387: LD_INT 5
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 2
39396: NEG
39397: PUSH
39398: LD_INT 3
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 3
39407: NEG
39408: PUSH
39409: LD_INT 0
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: LD_INT 3
39418: NEG
39419: PUSH
39420: LD_INT 1
39422: NEG
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 2
39430: NEG
39431: PUSH
39432: LD_INT 0
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 2
39441: NEG
39442: PUSH
39443: LD_INT 1
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 3
39452: NEG
39453: PUSH
39454: LD_INT 1
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 4
39463: NEG
39464: PUSH
39465: LD_INT 0
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 4
39474: NEG
39475: PUSH
39476: LD_INT 1
39478: NEG
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 4
39486: NEG
39487: PUSH
39488: LD_INT 2
39490: NEG
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 2
39498: NEG
39499: PUSH
39500: LD_INT 2
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 4
39509: NEG
39510: PUSH
39511: LD_INT 4
39513: NEG
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 4
39521: NEG
39522: PUSH
39523: LD_INT 5
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 3
39533: NEG
39534: PUSH
39535: LD_INT 4
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 3
39545: NEG
39546: PUSH
39547: LD_INT 3
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 4
39557: NEG
39558: PUSH
39559: LD_INT 3
39561: NEG
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 5
39569: NEG
39570: PUSH
39571: LD_INT 4
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 5
39581: NEG
39582: PUSH
39583: LD_INT 5
39585: NEG
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 3
39593: NEG
39594: PUSH
39595: LD_INT 5
39597: NEG
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 5
39605: NEG
39606: PUSH
39607: LD_INT 3
39609: NEG
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 0
39617: PUSH
39618: LD_INT 3
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: LD_INT 4
39631: NEG
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 1
39639: PUSH
39640: LD_INT 3
39642: NEG
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: PUSH
39648: LD_INT 1
39650: PUSH
39651: LD_INT 2
39653: NEG
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 0
39661: PUSH
39662: LD_INT 2
39664: NEG
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 1
39672: NEG
39673: PUSH
39674: LD_INT 3
39676: NEG
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 1
39684: NEG
39685: PUSH
39686: LD_INT 4
39688: NEG
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 2
39696: PUSH
39697: LD_INT 2
39699: NEG
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 2
39707: NEG
39708: PUSH
39709: LD_INT 4
39711: NEG
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 4
39719: PUSH
39720: LD_INT 0
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 4
39729: PUSH
39730: LD_INT 1
39732: NEG
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 5
39740: PUSH
39741: LD_INT 0
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 5
39750: PUSH
39751: LD_INT 1
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 4
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 3
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PUSH
39778: LD_INT 3
39780: PUSH
39781: LD_INT 1
39783: NEG
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 3
39791: PUSH
39792: LD_INT 2
39794: NEG
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 5
39802: PUSH
39803: LD_INT 2
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: LIST
39814: LIST
39815: LIST
39816: LIST
39817: LIST
39818: LIST
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: LIST
39824: LIST
39825: LIST
39826: LIST
39827: LIST
39828: LIST
39829: LIST
39830: LIST
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: LIST
39836: LIST
39837: LIST
39838: LIST
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: LIST
39848: LIST
39849: LIST
39850: LIST
39851: LIST
39852: LIST
39853: LIST
39854: LIST
39855: LIST
39856: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39857: NOP4
39861: PUSH
39862: LD_INT 4
39864: NEG
39865: PUSH
39866: LD_INT 0
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 4
39875: NEG
39876: PUSH
39877: LD_INT 1
39879: NEG
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: PUSH
39885: LD_INT 3
39887: NEG
39888: PUSH
39889: LD_INT 0
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 3
39898: NEG
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 4
39909: NEG
39910: PUSH
39911: LD_INT 1
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 5
39920: NEG
39921: PUSH
39922: LD_INT 0
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 5
39931: NEG
39932: PUSH
39933: LD_INT 1
39935: NEG
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 5
39943: NEG
39944: PUSH
39945: LD_INT 2
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 3
39955: NEG
39956: PUSH
39957: LD_INT 2
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 3
39966: NEG
39967: PUSH
39968: LD_INT 3
39970: NEG
39971: PUSH
39972: EMPTY
39973: LIST
39974: LIST
39975: PUSH
39976: LD_INT 3
39978: NEG
39979: PUSH
39980: LD_INT 4
39982: NEG
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 2
39990: NEG
39991: PUSH
39992: LD_INT 3
39994: NEG
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: LD_INT 2
40002: NEG
40003: PUSH
40004: LD_INT 2
40006: NEG
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 3
40014: NEG
40015: PUSH
40016: LD_INT 2
40018: NEG
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 4
40026: NEG
40027: PUSH
40028: LD_INT 3
40030: NEG
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 4
40038: NEG
40039: PUSH
40040: LD_INT 4
40042: NEG
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 2
40050: NEG
40051: PUSH
40052: LD_INT 4
40054: NEG
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 4
40062: NEG
40063: PUSH
40064: LD_INT 2
40066: NEG
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 0
40074: PUSH
40075: LD_INT 4
40077: NEG
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: LD_INT 5
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 1
40096: PUSH
40097: LD_INT 4
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 1
40107: PUSH
40108: LD_INT 3
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: LD_INT 3
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 1
40129: NEG
40130: PUSH
40131: LD_INT 4
40133: NEG
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: LD_INT 1
40141: NEG
40142: PUSH
40143: LD_INT 5
40145: NEG
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 2
40153: PUSH
40154: LD_INT 3
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 2
40164: NEG
40165: PUSH
40166: LD_INT 5
40168: NEG
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 3
40176: PUSH
40177: LD_INT 0
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 3
40186: PUSH
40187: LD_INT 1
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 4
40197: PUSH
40198: LD_INT 0
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 4
40207: PUSH
40208: LD_INT 1
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 3
40217: PUSH
40218: LD_INT 1
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 2
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 2
40237: PUSH
40238: LD_INT 1
40240: NEG
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 2
40248: PUSH
40249: LD_INT 2
40251: NEG
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 4
40259: PUSH
40260: LD_INT 2
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 4
40269: PUSH
40270: LD_INT 4
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 4
40279: PUSH
40280: LD_INT 3
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 5
40289: PUSH
40290: LD_INT 4
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 5
40299: PUSH
40300: LD_INT 5
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 4
40309: PUSH
40310: LD_INT 5
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 3
40319: PUSH
40320: LD_INT 4
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 3
40329: PUSH
40330: LD_INT 3
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 5
40339: PUSH
40340: LD_INT 3
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 3
40349: PUSH
40350: LD_INT 5
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: LIST
40375: LIST
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: LIST
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40404: NOP4
40408: PUSH
40409: LD_INT 4
40411: NEG
40412: PUSH
40413: LD_INT 4
40415: NEG
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 4
40423: NEG
40424: PUSH
40425: LD_INT 5
40427: NEG
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 3
40435: NEG
40436: PUSH
40437: LD_INT 4
40439: NEG
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 3
40447: NEG
40448: PUSH
40449: LD_INT 3
40451: NEG
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PUSH
40457: LD_INT 4
40459: NEG
40460: PUSH
40461: LD_INT 3
40463: NEG
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 5
40471: NEG
40472: PUSH
40473: LD_INT 4
40475: NEG
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 5
40483: NEG
40484: PUSH
40485: LD_INT 5
40487: NEG
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 3
40495: NEG
40496: PUSH
40497: LD_INT 5
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 5
40507: NEG
40508: PUSH
40509: LD_INT 3
40511: NEG
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 0
40519: PUSH
40520: LD_INT 3
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 4
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: PUSH
40542: LD_INT 3
40544: NEG
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 1
40552: PUSH
40553: LD_INT 2
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: LD_INT 0
40563: PUSH
40564: LD_INT 2
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 1
40574: NEG
40575: PUSH
40576: LD_INT 3
40578: NEG
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 1
40586: NEG
40587: PUSH
40588: LD_INT 4
40590: NEG
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 2
40598: PUSH
40599: LD_INT 2
40601: NEG
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 2
40609: NEG
40610: PUSH
40611: LD_INT 4
40613: NEG
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 4
40621: PUSH
40622: LD_INT 0
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 4
40631: PUSH
40632: LD_INT 1
40634: NEG
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 5
40642: PUSH
40643: LD_INT 0
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 5
40652: PUSH
40653: LD_INT 1
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 4
40662: PUSH
40663: LD_INT 1
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 3
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 3
40682: PUSH
40683: LD_INT 1
40685: NEG
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 3
40693: PUSH
40694: LD_INT 2
40696: NEG
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 5
40704: PUSH
40705: LD_INT 2
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: PUSH
40712: LD_INT 3
40714: PUSH
40715: LD_INT 3
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 3
40724: PUSH
40725: LD_INT 2
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 4
40734: PUSH
40735: LD_INT 3
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: LD_INT 4
40744: PUSH
40745: LD_INT 4
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 3
40754: PUSH
40755: LD_INT 4
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 2
40764: PUSH
40765: LD_INT 3
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 2
40774: PUSH
40775: LD_INT 2
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 4
40784: PUSH
40785: LD_INT 2
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: PUSH
40792: LD_INT 2
40794: PUSH
40795: LD_INT 4
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 0
40804: PUSH
40805: LD_INT 4
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 1
40824: PUSH
40825: LD_INT 4
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 5
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 0
40844: PUSH
40845: LD_INT 5
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: LD_INT 4
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: LD_INT 1
40865: NEG
40866: PUSH
40867: LD_INT 3
40869: PUSH
40870: EMPTY
40871: LIST
40872: LIST
40873: PUSH
40874: LD_INT 2
40876: PUSH
40877: LD_INT 5
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 2
40886: NEG
40887: PUSH
40888: LD_INT 3
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: LIST
40918: LIST
40919: LIST
40920: LIST
40921: LIST
40922: LIST
40923: LIST
40924: LIST
40925: LIST
40926: LIST
40927: LIST
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: LIST
40937: LIST
40938: LIST
40939: LIST
40940: LIST
40941: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40942: NOP4
40946: PUSH
40947: LD_INT 0
40949: PUSH
40950: LD_INT 4
40952: NEG
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 0
40960: PUSH
40961: LD_INT 5
40963: NEG
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 1
40971: PUSH
40972: LD_INT 4
40974: NEG
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 1
40982: PUSH
40983: LD_INT 3
40985: NEG
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 0
40993: PUSH
40994: LD_INT 3
40996: NEG
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: NEG
41005: PUSH
41006: LD_INT 4
41008: NEG
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: LD_INT 1
41016: NEG
41017: PUSH
41018: LD_INT 5
41020: NEG
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 2
41028: PUSH
41029: LD_INT 3
41031: NEG
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 2
41039: NEG
41040: PUSH
41041: LD_INT 5
41043: NEG
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: LD_INT 0
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 3
41061: PUSH
41062: LD_INT 1
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 4
41072: PUSH
41073: LD_INT 0
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: LD_INT 4
41082: PUSH
41083: LD_INT 1
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 3
41092: PUSH
41093: LD_INT 1
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 2
41102: PUSH
41103: LD_INT 0
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: LD_INT 1
41115: NEG
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 2
41123: PUSH
41124: LD_INT 2
41126: NEG
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 4
41134: PUSH
41135: LD_INT 2
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 4
41144: PUSH
41145: LD_INT 4
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 4
41154: PUSH
41155: LD_INT 3
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 5
41164: PUSH
41165: LD_INT 4
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 5
41174: PUSH
41175: LD_INT 5
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 4
41184: PUSH
41185: LD_INT 5
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 3
41194: PUSH
41195: LD_INT 4
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 3
41204: PUSH
41205: LD_INT 3
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 5
41214: PUSH
41215: LD_INT 3
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: LD_INT 3
41224: PUSH
41225: LD_INT 5
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: PUSH
41232: LD_INT 0
41234: PUSH
41235: LD_INT 3
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: LD_INT 0
41244: PUSH
41245: LD_INT 2
41247: PUSH
41248: EMPTY
41249: LIST
41250: LIST
41251: PUSH
41252: LD_INT 1
41254: PUSH
41255: LD_INT 3
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 1
41264: PUSH
41265: LD_INT 4
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 0
41274: PUSH
41275: LD_INT 4
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 1
41284: NEG
41285: PUSH
41286: LD_INT 3
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: LD_INT 1
41295: NEG
41296: PUSH
41297: LD_INT 2
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 4
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 2
41316: NEG
41317: PUSH
41318: LD_INT 2
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 4
41327: NEG
41328: PUSH
41329: LD_INT 0
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 4
41338: NEG
41339: PUSH
41340: LD_INT 1
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 3
41350: NEG
41351: PUSH
41352: LD_INT 0
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 3
41361: NEG
41362: PUSH
41363: LD_INT 1
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 4
41372: NEG
41373: PUSH
41374: LD_INT 1
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 5
41383: NEG
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 5
41394: NEG
41395: PUSH
41396: LD_INT 1
41398: NEG
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 5
41406: NEG
41407: PUSH
41408: LD_INT 2
41410: NEG
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 3
41418: NEG
41419: PUSH
41420: LD_INT 2
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: LIST
41431: LIST
41432: LIST
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: LIST
41463: LIST
41464: LIST
41465: LIST
41466: LIST
41467: LIST
41468: LIST
41469: LIST
41470: LIST
41471: LIST
41472: LIST
41473: ST_TO_ADDR
// end ; end ;
41474: GO 41477
41476: POP
// case btype of b_depot , b_warehouse :
41477: NOP4
41481: PUSH
41482: LD_INT 0
41484: DOUBLE
41485: EQUAL
41486: IFTRUE 41496
41488: LD_INT 1
41490: DOUBLE
41491: EQUAL
41492: IFTRUE 41496
41494: GO 41697
41496: POP
// case nation of nation_american :
41497: NOP4
41501: PUSH
41502: LD_INT 1
41504: DOUBLE
41505: EQUAL
41506: IFTRUE 41510
41508: GO 41566
41510: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41511: NOP4
41515: PUSH
41516: NOP4
41520: PUSH
41521: NOP4
41525: PUSH
41526: NOP4
41530: PUSH
41531: NOP4
41535: PUSH
41536: NOP4
41540: PUSH
41541: NOP4
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: PUSH
41554: NOP4
41558: PUSH
41559: LD_INT 1
41561: PLUS
41562: ARRAY
41563: ST_TO_ADDR
41564: GO 41695
41566: LD_INT 2
41568: DOUBLE
41569: EQUAL
41570: IFTRUE 41574
41572: GO 41630
41574: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41575: NOP4
41579: PUSH
41580: NOP4
41584: PUSH
41585: NOP4
41589: PUSH
41590: NOP4
41594: PUSH
41595: NOP4
41599: PUSH
41600: NOP4
41604: PUSH
41605: NOP4
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: PUSH
41618: NOP4
41622: PUSH
41623: LD_INT 1
41625: PLUS
41626: ARRAY
41627: ST_TO_ADDR
41628: GO 41695
41630: LD_INT 3
41632: DOUBLE
41633: EQUAL
41634: IFTRUE 41638
41636: GO 41694
41638: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41639: NOP4
41643: PUSH
41644: NOP4
41648: PUSH
41649: NOP4
41653: PUSH
41654: NOP4
41658: PUSH
41659: NOP4
41663: PUSH
41664: NOP4
41668: PUSH
41669: NOP4
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: PUSH
41682: NOP4
41686: PUSH
41687: LD_INT 1
41689: PLUS
41690: ARRAY
41691: ST_TO_ADDR
41692: GO 41695
41694: POP
41695: GO 42250
41697: LD_INT 2
41699: DOUBLE
41700: EQUAL
41701: IFTRUE 41711
41703: LD_INT 3
41705: DOUBLE
41706: EQUAL
41707: IFTRUE 41711
41709: GO 41767
41711: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41712: NOP4
41716: PUSH
41717: NOP4
41721: PUSH
41722: NOP4
41726: PUSH
41727: NOP4
41731: PUSH
41732: NOP4
41736: PUSH
41737: NOP4
41741: PUSH
41742: NOP4
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: PUSH
41755: NOP4
41759: PUSH
41760: LD_INT 1
41762: PLUS
41763: ARRAY
41764: ST_TO_ADDR
41765: GO 42250
41767: LD_INT 16
41769: DOUBLE
41770: EQUAL
41771: IFTRUE 41829
41773: LD_INT 17
41775: DOUBLE
41776: EQUAL
41777: IFTRUE 41829
41779: LD_INT 18
41781: DOUBLE
41782: EQUAL
41783: IFTRUE 41829
41785: LD_INT 19
41787: DOUBLE
41788: EQUAL
41789: IFTRUE 41829
41791: LD_INT 22
41793: DOUBLE
41794: EQUAL
41795: IFTRUE 41829
41797: LD_INT 20
41799: DOUBLE
41800: EQUAL
41801: IFTRUE 41829
41803: LD_INT 21
41805: DOUBLE
41806: EQUAL
41807: IFTRUE 41829
41809: LD_INT 23
41811: DOUBLE
41812: EQUAL
41813: IFTRUE 41829
41815: LD_INT 24
41817: DOUBLE
41818: EQUAL
41819: IFTRUE 41829
41821: LD_INT 25
41823: DOUBLE
41824: EQUAL
41825: IFTRUE 41829
41827: GO 41885
41829: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41830: NOP4
41834: PUSH
41835: NOP4
41839: PUSH
41840: NOP4
41844: PUSH
41845: NOP4
41849: PUSH
41850: NOP4
41854: PUSH
41855: NOP4
41859: PUSH
41860: NOP4
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: LIST
41869: LIST
41870: LIST
41871: LIST
41872: PUSH
41873: NOP4
41877: PUSH
41878: LD_INT 1
41880: PLUS
41881: ARRAY
41882: ST_TO_ADDR
41883: GO 42250
41885: LD_INT 6
41887: DOUBLE
41888: EQUAL
41889: IFTRUE 41941
41891: LD_INT 7
41893: DOUBLE
41894: EQUAL
41895: IFTRUE 41941
41897: LD_INT 8
41899: DOUBLE
41900: EQUAL
41901: IFTRUE 41941
41903: LD_INT 13
41905: DOUBLE
41906: EQUAL
41907: IFTRUE 41941
41909: LD_INT 12
41911: DOUBLE
41912: EQUAL
41913: IFTRUE 41941
41915: LD_INT 15
41917: DOUBLE
41918: EQUAL
41919: IFTRUE 41941
41921: LD_INT 11
41923: DOUBLE
41924: EQUAL
41925: IFTRUE 41941
41927: LD_INT 14
41929: DOUBLE
41930: EQUAL
41931: IFTRUE 41941
41933: LD_INT 10
41935: DOUBLE
41936: EQUAL
41937: IFTRUE 41941
41939: GO 41997
41941: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41942: NOP4
41946: PUSH
41947: NOP4
41951: PUSH
41952: NOP4
41956: PUSH
41957: NOP4
41961: PUSH
41962: NOP4
41966: PUSH
41967: NOP4
41971: PUSH
41972: NOP4
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: LIST
41981: LIST
41982: LIST
41983: LIST
41984: PUSH
41985: NOP4
41989: PUSH
41990: LD_INT 1
41992: PLUS
41993: ARRAY
41994: ST_TO_ADDR
41995: GO 42250
41997: LD_INT 36
41999: DOUBLE
42000: EQUAL
42001: IFTRUE 42005
42003: GO 42061
42005: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42006: NOP4
42010: PUSH
42011: NOP4
42015: PUSH
42016: NOP4
42020: PUSH
42021: NOP4
42025: PUSH
42026: NOP4
42030: PUSH
42031: NOP4
42035: PUSH
42036: NOP4
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: LIST
42045: LIST
42046: LIST
42047: LIST
42048: PUSH
42049: NOP4
42053: PUSH
42054: LD_INT 1
42056: PLUS
42057: ARRAY
42058: ST_TO_ADDR
42059: GO 42250
42061: LD_INT 4
42063: DOUBLE
42064: EQUAL
42065: IFTRUE 42087
42067: LD_INT 5
42069: DOUBLE
42070: EQUAL
42071: IFTRUE 42087
42073: LD_INT 34
42075: DOUBLE
42076: EQUAL
42077: IFTRUE 42087
42079: LD_INT 37
42081: DOUBLE
42082: EQUAL
42083: IFTRUE 42087
42085: GO 42143
42087: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42088: NOP4
42092: PUSH
42093: NOP4
42097: PUSH
42098: NOP4
42102: PUSH
42103: NOP4
42107: PUSH
42108: NOP4
42112: PUSH
42113: NOP4
42117: PUSH
42118: NOP4
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: LIST
42127: LIST
42128: LIST
42129: LIST
42130: PUSH
42131: NOP4
42135: PUSH
42136: LD_INT 1
42138: PLUS
42139: ARRAY
42140: ST_TO_ADDR
42141: GO 42250
42143: LD_INT 31
42145: DOUBLE
42146: EQUAL
42147: IFTRUE 42193
42149: LD_INT 32
42151: DOUBLE
42152: EQUAL
42153: IFTRUE 42193
42155: LD_INT 33
42157: DOUBLE
42158: EQUAL
42159: IFTRUE 42193
42161: LD_INT 27
42163: DOUBLE
42164: EQUAL
42165: IFTRUE 42193
42167: LD_INT 26
42169: DOUBLE
42170: EQUAL
42171: IFTRUE 42193
42173: LD_INT 28
42175: DOUBLE
42176: EQUAL
42177: IFTRUE 42193
42179: LD_INT 29
42181: DOUBLE
42182: EQUAL
42183: IFTRUE 42193
42185: LD_INT 30
42187: DOUBLE
42188: EQUAL
42189: IFTRUE 42193
42191: GO 42249
42193: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42194: NOP4
42198: PUSH
42199: NOP4
42203: PUSH
42204: NOP4
42208: PUSH
42209: NOP4
42213: PUSH
42214: NOP4
42218: PUSH
42219: NOP4
42223: PUSH
42224: NOP4
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: PUSH
42237: NOP4
42241: PUSH
42242: LD_INT 1
42244: PLUS
42245: ARRAY
42246: ST_TO_ADDR
42247: GO 42250
42249: POP
// temp_list2 = [ ] ;
42250: NOP4
42254: PUSH
42255: EMPTY
42256: ST_TO_ADDR
// for i in temp_list do
42257: NOP4
42261: PUSH
42262: NOP4
42266: PUSH
42267: FOR_IN
42268: IFFALSE 42320
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42270: NOP4
42274: PUSH
42275: NOP4
42279: PUSH
42280: NOP4
42284: PUSH
42285: LD_INT 1
42287: ARRAY
42288: PUSH
42289: NOP4
42293: PLUS
42294: PUSH
42295: NOP4
42299: PUSH
42300: LD_INT 2
42302: ARRAY
42303: PUSH
42304: NOP4
42308: PLUS
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: EMPTY
42315: LIST
42316: ADD
42317: ST_TO_ADDR
42318: GO 42267
42320: POP
42321: POP
// result = temp_list2 ;
42322: NOP4
42326: PUSH
42327: NOP4
42331: ST_TO_ADDR
// end ;
42332: LD_VAR 0 7
42336: RET
// export function EnemyInRange ( unit , dist ) ; begin
42337: LD_INT 0
42339: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42340: NOP4
42344: PUSH
42345: NOP4
42349: PPUSH
42350: NOP4
42354: PPUSH
42355: NOP4
42359: PPUSH
42360: NOP4
42364: PPUSH
42365: NOP4
42369: PPUSH
42370: NOP4
42374: PPUSH
42375: NOP4
42379: PPUSH
42380: NOP4
42384: PUSH
42385: LD_INT 4
42387: ARRAY
42388: ST_TO_ADDR
// end ;
42389: LD_VAR 0 3
42393: RET
// export function PlayerSeeMe ( unit ) ; begin
42394: LD_INT 0
42396: PPUSH
// result := See ( your_side , unit ) ;
42397: NOP4
42401: PUSH
42402: NOP4
42406: PPUSH
42407: NOP4
42411: PPUSH
42412: NOP4
42416: ST_TO_ADDR
// end ;
42417: LD_VAR 0 2
42421: RET
// export function ReverseDir ( unit ) ; begin
42422: LD_INT 0
42424: PPUSH
// if not unit then
42425: NOP4
42429: NOT
42430: IFFALSE 42434
// exit ;
42432: GO 42457
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42434: NOP4
42438: PUSH
42439: NOP4
42443: PPUSH
42444: NOP4
42448: PUSH
42449: LD_INT 3
42451: PLUS
42452: PUSH
42453: LD_INT 6
42455: MOD
42456: ST_TO_ADDR
// end ;
42457: LD_VAR 0 2
42461: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
42462: LD_INT 0
42464: PPUSH
42465: PPUSH
42466: PPUSH
42467: PPUSH
42468: PPUSH
// if not hexes then
42469: NOP4
42473: NOT
42474: IFFALSE 42478
// exit ;
42476: GO 42626
// dist := 9999 ;
42478: NOP4
42482: PUSH
42483: LD_INT 9999
42485: ST_TO_ADDR
// for i = 1 to hexes do
42486: NOP4
42490: PUSH
42491: DOUBLE
42492: LD_INT 1
42494: DEC
42495: ST_TO_ADDR
42496: NOP4
42500: PUSH
42501: FOR_TO
42502: IFFALSE 42614
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
42504: NOP4
42508: PPUSH
42509: NOP4
42513: PUSH
42514: NOP4
42518: ARRAY
42519: PUSH
42520: LD_INT 1
42522: ARRAY
42523: PPUSH
42524: NOP4
42528: PUSH
42529: NOP4
42533: ARRAY
42534: PUSH
42535: LD_INT 2
42537: ARRAY
42538: PPUSH
42539: NOP4
42543: PUSH
42544: NOP4
42548: LESS
42549: IFFALSE 42612
// begin hex := hexes [ i ] ;
42551: NOP4
42555: PUSH
42556: NOP4
42560: PUSH
42561: NOP4
42565: ARRAY
42566: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42567: NOP4
42571: PUSH
42572: NOP4
42576: PPUSH
42577: NOP4
42581: PUSH
42582: NOP4
42586: ARRAY
42587: PUSH
42588: LD_INT 1
42590: ARRAY
42591: PPUSH
42592: NOP4
42596: PUSH
42597: NOP4
42601: ARRAY
42602: PUSH
42603: LD_INT 2
42605: ARRAY
42606: PPUSH
42607: NOP4
42611: ST_TO_ADDR
// end ; end ;
42612: GO 42501
42614: POP
42615: POP
// result := hex ;
42616: NOP4
42620: PUSH
42621: NOP4
42625: ST_TO_ADDR
// end ;
42626: LD_VAR 0 3
42630: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42631: LD_INT 0
42633: PPUSH
42634: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42635: NOP4
42639: NOT
42640: PUSH
42641: NOP4
42645: PUSH
42646: LD_INT 21
42648: PUSH
42649: LD_INT 2
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 23
42658: PUSH
42659: LD_INT 2
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PPUSH
42670: NOP4
42674: IN
42675: NOT
42676: OR
42677: IFFALSE 42681
// exit ;
42679: GO 42728
// for i = 1 to 3 do
42681: NOP4
42685: PUSH
42686: DOUBLE
42687: LD_INT 1
42689: DEC
42690: ST_TO_ADDR
42691: LD_INT 3
42693: PUSH
42694: FOR_TO
42695: IFFALSE 42726
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42697: NOP4
42701: PPUSH
42702: NOP4
42706: PPUSH
42707: NOP4
42711: PPUSH
42712: NOP4
42716: PPUSH
42717: LD_INT 1
42719: PPUSH
42720: NOP4
42724: GO 42694
42726: POP
42727: POP
// end ;
42728: LD_VAR 0 2
42732: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42733: LD_INT 0
42735: PPUSH
42736: PPUSH
42737: PPUSH
42738: PPUSH
42739: PPUSH
42740: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42741: NOP4
42745: NOT
42746: PUSH
42747: NOP4
42751: NOT
42752: OR
42753: PUSH
42754: NOP4
42758: PPUSH
42759: NOP4
42763: OR
42764: IFFALSE 42768
// exit ;
42766: GO 43209
// x := GetX ( enemy_unit ) ;
42768: NOP4
42772: PUSH
42773: NOP4
42777: PPUSH
42778: NOP4
42782: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42783: NOP4
42787: PUSH
42788: NOP4
42792: PPUSH
42793: NOP4
42797: ST_TO_ADDR
// if not x or not y then
42798: NOP4
42802: NOT
42803: PUSH
42804: NOP4
42808: NOT
42809: OR
42810: IFFALSE 42814
// exit ;
42812: GO 43209
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42814: NOP4
42818: PUSH
42819: NOP4
42823: PPUSH
42824: LD_INT 0
42826: PPUSH
42827: LD_INT 4
42829: PPUSH
42830: NOP4
42834: PUSH
42835: NOP4
42839: PPUSH
42840: LD_INT 0
42842: PPUSH
42843: LD_INT 4
42845: PPUSH
42846: NOP4
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: NOP4
42859: PPUSH
42860: LD_INT 1
42862: PPUSH
42863: LD_INT 4
42865: PPUSH
42866: NOP4
42870: PUSH
42871: NOP4
42875: PPUSH
42876: LD_INT 1
42878: PPUSH
42879: LD_INT 4
42881: PPUSH
42882: NOP4
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: NOP4
42895: PPUSH
42896: LD_INT 2
42898: PPUSH
42899: LD_INT 4
42901: PPUSH
42902: NOP4
42906: PUSH
42907: NOP4
42911: PPUSH
42912: LD_INT 2
42914: PPUSH
42915: LD_INT 4
42917: PPUSH
42918: NOP4
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: NOP4
42931: PPUSH
42932: LD_INT 3
42934: PPUSH
42935: LD_INT 4
42937: PPUSH
42938: NOP4
42942: PUSH
42943: NOP4
42947: PPUSH
42948: LD_INT 3
42950: PPUSH
42951: LD_INT 4
42953: PPUSH
42954: NOP4
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: NOP4
42967: PPUSH
42968: LD_INT 4
42970: PPUSH
42971: LD_INT 4
42973: PPUSH
42974: NOP4
42978: PUSH
42979: NOP4
42983: PPUSH
42984: LD_INT 4
42986: PPUSH
42987: LD_INT 4
42989: PPUSH
42990: NOP4
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: NOP4
43003: PPUSH
43004: LD_INT 5
43006: PPUSH
43007: LD_INT 4
43009: PPUSH
43010: NOP4
43014: PUSH
43015: NOP4
43019: PPUSH
43020: LD_INT 5
43022: PPUSH
43023: LD_INT 4
43025: PPUSH
43026: NOP4
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: ST_TO_ADDR
// for i = tmp downto 1 do
43043: NOP4
43047: PUSH
43048: DOUBLE
43049: NOP4
43053: INC
43054: ST_TO_ADDR
43055: LD_INT 1
43057: PUSH
43058: FOR_DOWNTO
43059: IFFALSE 43160
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43061: NOP4
43065: PUSH
43066: NOP4
43070: ARRAY
43071: PUSH
43072: LD_INT 1
43074: ARRAY
43075: PPUSH
43076: NOP4
43080: PUSH
43081: NOP4
43085: ARRAY
43086: PUSH
43087: LD_INT 2
43089: ARRAY
43090: PPUSH
43091: NOP4
43095: NOT
43096: PUSH
43097: NOP4
43101: PUSH
43102: NOP4
43106: ARRAY
43107: PUSH
43108: LD_INT 1
43110: ARRAY
43111: PPUSH
43112: NOP4
43116: PUSH
43117: NOP4
43121: ARRAY
43122: PUSH
43123: LD_INT 2
43125: ARRAY
43126: PPUSH
43127: NOP4
43131: PUSH
43132: LD_INT 0
43134: NONEQUAL
43135: OR
43136: IFFALSE 43158
// tmp := Delete ( tmp , i ) ;
43138: NOP4
43142: PUSH
43143: NOP4
43147: PPUSH
43148: NOP4
43152: PPUSH
43153: NOP4
43157: ST_TO_ADDR
43158: GO 43058
43160: POP
43161: POP
// j := GetClosestHex ( unit , tmp ) ;
43162: NOP4
43166: PUSH
43167: NOP4
43171: PPUSH
43172: NOP4
43176: PPUSH
43177: NOP4
43181: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43182: NOP4
43186: PPUSH
43187: NOP4
43191: PUSH
43192: LD_INT 1
43194: ARRAY
43195: PPUSH
43196: NOP4
43200: PUSH
43201: LD_INT 2
43203: ARRAY
43204: PPUSH
43205: NOP4
// end ;
43209: LD_VAR 0 3
43213: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43214: LD_INT 0
43216: PPUSH
43217: PPUSH
43218: PPUSH
// uc_side = 0 ;
43219: LD_ADDR_OWVAR 20
43223: PUSH
43224: LD_INT 0
43226: ST_TO_ADDR
// uc_nation = 0 ;
43227: LD_ADDR_OWVAR 21
43231: PUSH
43232: LD_INT 0
43234: ST_TO_ADDR
// InitHc_All ( ) ;
43235: NOP4
// InitVc ;
43239: NOP4
// if mastodonts then
43243: NOP4
43247: IFFALSE 43314
// for i = 1 to mastodonts do
43249: NOP4
43253: PUSH
43254: DOUBLE
43255: LD_INT 1
43257: DEC
43258: ST_TO_ADDR
43259: NOP4
43263: PUSH
43264: FOR_TO
43265: IFFALSE 43312
// begin vc_chassis := 31 ;
43267: LD_ADDR_OWVAR 37
43271: PUSH
43272: LD_INT 31
43274: ST_TO_ADDR
// vc_control := control_rider ;
43275: LD_ADDR_OWVAR 38
43279: PUSH
43280: LD_INT 4
43282: ST_TO_ADDR
// animal := CreateVehicle ;
43283: NOP4
43287: PUSH
43288: NOP4
43292: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43293: NOP4
43297: PPUSH
43298: NOP4
43302: PPUSH
43303: LD_INT 0
43305: PPUSH
43306: NOP4
// end ;
43310: GO 43264
43312: POP
43313: POP
// if horses then
43314: NOP4
43318: IFFALSE 43385
// for i = 1 to horses do
43320: NOP4
43324: PUSH
43325: DOUBLE
43326: LD_INT 1
43328: DEC
43329: ST_TO_ADDR
43330: NOP4
43334: PUSH
43335: FOR_TO
43336: IFFALSE 43383
// begin hc_class := 21 ;
43338: LD_ADDR_OWVAR 28
43342: PUSH
43343: LD_INT 21
43345: ST_TO_ADDR
// hc_gallery :=  ;
43346: LD_ADDR_OWVAR 33
43350: PUSH
43351: LD_STRING 
43353: ST_TO_ADDR
// animal := CreateHuman ;
43354: NOP4
43358: PUSH
43359: NOP4
43363: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43364: NOP4
43368: PPUSH
43369: NOP4
43373: PPUSH
43374: LD_INT 0
43376: PPUSH
43377: NOP4
// end ;
43381: GO 43335
43383: POP
43384: POP
// if birds then
43385: NOP4
43389: IFFALSE 43456
// for i = 1 to birds do
43391: NOP4
43395: PUSH
43396: DOUBLE
43397: LD_INT 1
43399: DEC
43400: ST_TO_ADDR
43401: NOP4
43405: PUSH
43406: FOR_TO
43407: IFFALSE 43454
// begin hc_class = 18 ;
43409: LD_ADDR_OWVAR 28
43413: PUSH
43414: LD_INT 18
43416: ST_TO_ADDR
// hc_gallery =  ;
43417: LD_ADDR_OWVAR 33
43421: PUSH
43422: LD_STRING 
43424: ST_TO_ADDR
// animal := CreateHuman ;
43425: NOP4
43429: PUSH
43430: NOP4
43434: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43435: NOP4
43439: PPUSH
43440: NOP4
43444: PPUSH
43445: LD_INT 0
43447: PPUSH
43448: NOP4
// end ;
43452: GO 43406
43454: POP
43455: POP
// if tigers then
43456: NOP4
43460: IFFALSE 43544
// for i = 1 to tigers do
43462: NOP4
43466: PUSH
43467: DOUBLE
43468: LD_INT 1
43470: DEC
43471: ST_TO_ADDR
43472: NOP4
43476: PUSH
43477: FOR_TO
43478: IFFALSE 43542
// begin hc_class = class_tiger ;
43480: LD_ADDR_OWVAR 28
43484: PUSH
43485: LD_INT 14
43487: ST_TO_ADDR
// hc_gallery =  ;
43488: LD_ADDR_OWVAR 33
43492: PUSH
43493: LD_STRING 
43495: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
43496: LD_ADDR_OWVAR 35
43500: PUSH
43501: LD_INT 7
43503: NEG
43504: PPUSH
43505: LD_INT 7
43507: PPUSH
43508: NOP4
43512: ST_TO_ADDR
// animal := CreateHuman ;
43513: NOP4
43517: PUSH
43518: NOP4
43522: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43523: NOP4
43527: PPUSH
43528: NOP4
43532: PPUSH
43533: LD_INT 0
43535: PPUSH
43536: NOP4
// end ;
43540: GO 43477
43542: POP
43543: POP
// if apemans then
43544: NOP4
43548: IFFALSE 43671
// for i = 1 to apemans do
43550: NOP4
43554: PUSH
43555: DOUBLE
43556: LD_INT 1
43558: DEC
43559: ST_TO_ADDR
43560: NOP4
43564: PUSH
43565: FOR_TO
43566: IFFALSE 43669
// begin hc_class = class_apeman ;
43568: LD_ADDR_OWVAR 28
43572: PUSH
43573: LD_INT 12
43575: ST_TO_ADDR
// hc_gallery =  ;
43576: LD_ADDR_OWVAR 33
43580: PUSH
43581: LD_STRING 
43583: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
43584: LD_ADDR_OWVAR 35
43588: PUSH
43589: LD_INT 2
43591: NEG
43592: PPUSH
43593: LD_INT 2
43595: PPUSH
43596: NOP4
43600: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
43601: LD_ADDR_OWVAR 31
43605: PUSH
43606: LD_INT 1
43608: PPUSH
43609: LD_INT 3
43611: PPUSH
43612: NOP4
43616: PUSH
43617: LD_INT 1
43619: PPUSH
43620: LD_INT 3
43622: PPUSH
43623: NOP4
43627: PUSH
43628: LD_INT 0
43630: PUSH
43631: LD_INT 0
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: LIST
43638: LIST
43639: ST_TO_ADDR
// animal := CreateHuman ;
43640: NOP4
43644: PUSH
43645: NOP4
43649: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43650: NOP4
43654: PPUSH
43655: NOP4
43659: PPUSH
43660: LD_INT 0
43662: PPUSH
43663: NOP4
// end ;
43667: GO 43565
43669: POP
43670: POP
// if enchidnas then
43671: NOP4
43675: IFFALSE 43742
// for i = 1 to enchidnas do
43677: NOP4
43681: PUSH
43682: DOUBLE
43683: LD_INT 1
43685: DEC
43686: ST_TO_ADDR
43687: NOP4
43691: PUSH
43692: FOR_TO
43693: IFFALSE 43740
// begin hc_class = 13 ;
43695: LD_ADDR_OWVAR 28
43699: PUSH
43700: LD_INT 13
43702: ST_TO_ADDR
// hc_gallery =  ;
43703: LD_ADDR_OWVAR 33
43707: PUSH
43708: LD_STRING 
43710: ST_TO_ADDR
// animal := CreateHuman ;
43711: NOP4
43715: PUSH
43716: NOP4
43720: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43721: NOP4
43725: PPUSH
43726: NOP4
43730: PPUSH
43731: LD_INT 0
43733: PPUSH
43734: NOP4
// end ;
43738: GO 43692
43740: POP
43741: POP
// if fishes then
43742: NOP4
43746: IFFALSE 43813
// for i = 1 to fishes do
43748: NOP4
43752: PUSH
43753: DOUBLE
43754: LD_INT 1
43756: DEC
43757: ST_TO_ADDR
43758: NOP4
43762: PUSH
43763: FOR_TO
43764: IFFALSE 43811
// begin hc_class = 20 ;
43766: LD_ADDR_OWVAR 28
43770: PUSH
43771: LD_INT 20
43773: ST_TO_ADDR
// hc_gallery =  ;
43774: LD_ADDR_OWVAR 33
43778: PUSH
43779: LD_STRING 
43781: ST_TO_ADDR
// animal := CreateHuman ;
43782: NOP4
43786: PUSH
43787: NOP4
43791: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43792: NOP4
43796: PPUSH
43797: NOP4
43801: PPUSH
43802: LD_INT 0
43804: PPUSH
43805: NOP4
// end ;
43809: GO 43763
43811: POP
43812: POP
// end ;
43813: LD_VAR 0 10
43817: RET
// export function WantHeal ( sci , unit ) ; begin
43818: LD_INT 0
43820: PPUSH
// if GetTaskList ( sci ) > 0 then
43821: NOP4
43825: PPUSH
43826: NOP4
43830: PUSH
43831: LD_INT 0
43833: GREATER
43834: IFFALSE 43904
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43836: NOP4
43840: PPUSH
43841: NOP4
43845: PUSH
43846: LD_INT 1
43848: ARRAY
43849: PUSH
43850: LD_INT 1
43852: ARRAY
43853: PUSH
43854: LD_STRING l
43856: EQUAL
43857: PUSH
43858: NOP4
43862: PPUSH
43863: NOP4
43867: PUSH
43868: LD_INT 1
43870: ARRAY
43871: PUSH
43872: LD_INT 4
43874: ARRAY
43875: PUSH
43876: NOP4
43880: EQUAL
43881: AND
43882: IFFALSE 43894
// result := true else
43884: NOP4
43888: PUSH
43889: LD_INT 1
43891: ST_TO_ADDR
43892: GO 43902
// result := false ;
43894: NOP4
43898: PUSH
43899: LD_INT 0
43901: ST_TO_ADDR
// end else
43902: GO 43912
// result := false ;
43904: NOP4
43908: PUSH
43909: LD_INT 0
43911: ST_TO_ADDR
// end ;
43912: LD_VAR 0 3
43916: RET
// export function HealTarget ( sci ) ; begin
43917: LD_INT 0
43919: PPUSH
// if not sci then
43920: NOP4
43924: NOT
43925: IFFALSE 43929
// exit ;
43927: GO 43994
// result := 0 ;
43929: NOP4
43933: PUSH
43934: LD_INT 0
43936: ST_TO_ADDR
// if GetTaskList ( sci ) then
43937: NOP4
43941: PPUSH
43942: NOP4
43946: IFFALSE 43994
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43948: NOP4
43952: PPUSH
43953: NOP4
43957: PUSH
43958: LD_INT 1
43960: ARRAY
43961: PUSH
43962: LD_INT 1
43964: ARRAY
43965: PUSH
43966: LD_STRING l
43968: EQUAL
43969: IFFALSE 43994
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43971: NOP4
43975: PUSH
43976: NOP4
43980: PPUSH
43981: NOP4
43985: PUSH
43986: LD_INT 1
43988: ARRAY
43989: PUSH
43990: LD_INT 4
43992: ARRAY
43993: ST_TO_ADDR
// end ;
43994: LD_VAR 0 2
43998: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43999: LD_INT 0
44001: PPUSH
44002: PPUSH
44003: PPUSH
44004: PPUSH
// if not base_units then
44005: NOP4
44009: NOT
44010: IFFALSE 44014
// exit ;
44012: GO 44101
// result := false ;
44014: NOP4
44018: PUSH
44019: LD_INT 0
44021: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44022: NOP4
44026: PUSH
44027: NOP4
44031: PPUSH
44032: LD_INT 21
44034: PUSH
44035: LD_INT 3
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PPUSH
44042: NOP4
44046: ST_TO_ADDR
// if not tmp then
44047: NOP4
44051: NOT
44052: IFFALSE 44056
// exit ;
44054: GO 44101
// for i in tmp do
44056: NOP4
44060: PUSH
44061: NOP4
44065: PUSH
44066: FOR_IN
44067: IFFALSE 44099
// begin result := EnemyInRange ( i , 22 ) ;
44069: NOP4
44073: PUSH
44074: NOP4
44078: PPUSH
44079: LD_INT 22
44081: PPUSH
44082: NOP4
44086: ST_TO_ADDR
// if result then
44087: NOP4
44091: IFFALSE 44097
// exit ;
44093: POP
44094: POP
44095: GO 44101
// end ;
44097: GO 44066
44099: POP
44100: POP
// end ;
44101: LD_VAR 0 2
44105: RET
// export function FilterByTag ( units , tag ) ; begin
44106: LD_INT 0
44108: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
44109: NOP4
44113: PUSH
44114: NOP4
44118: PPUSH
44119: LD_INT 120
44121: PUSH
44122: NOP4
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PPUSH
44131: NOP4
44135: ST_TO_ADDR
// end ;
44136: LD_VAR 0 3
44140: RET
// export function IsDriver ( un ) ; begin
44141: LD_INT 0
44143: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44144: NOP4
44148: PUSH
44149: NOP4
44153: PUSH
44154: LD_INT 55
44156: PUSH
44157: EMPTY
44158: LIST
44159: PPUSH
44160: NOP4
44164: IN
44165: ST_TO_ADDR
// end ;
44166: LD_VAR 0 2
44170: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44171: LD_INT 0
44173: PPUSH
44174: PPUSH
// list := [ ] ;
44175: NOP4
44179: PUSH
44180: EMPTY
44181: ST_TO_ADDR
// case d of 0 :
44182: NOP4
44186: PUSH
44187: LD_INT 0
44189: DOUBLE
44190: EQUAL
44191: IFTRUE 44195
44193: GO 44328
44195: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44196: NOP4
44200: PUSH
44201: NOP4
44205: PUSH
44206: LD_INT 4
44208: MINUS
44209: PUSH
44210: NOP4
44214: PUSH
44215: LD_INT 4
44217: MINUS
44218: PUSH
44219: LD_INT 2
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: LIST
44226: PUSH
44227: NOP4
44231: PUSH
44232: LD_INT 3
44234: MINUS
44235: PUSH
44236: NOP4
44240: PUSH
44241: LD_INT 1
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: LIST
44248: PUSH
44249: NOP4
44253: PUSH
44254: LD_INT 4
44256: PLUS
44257: PUSH
44258: NOP4
44262: PUSH
44263: LD_INT 4
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: LIST
44270: PUSH
44271: NOP4
44275: PUSH
44276: LD_INT 3
44278: PLUS
44279: PUSH
44280: NOP4
44284: PUSH
44285: LD_INT 3
44287: PLUS
44288: PUSH
44289: LD_INT 5
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: LIST
44296: PUSH
44297: NOP4
44301: PUSH
44302: NOP4
44306: PUSH
44307: LD_INT 4
44309: PLUS
44310: PUSH
44311: LD_INT 0
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: LIST
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: LIST
44325: ST_TO_ADDR
// end ; 1 :
44326: GO 45026
44328: LD_INT 1
44330: DOUBLE
44331: EQUAL
44332: IFTRUE 44336
44334: GO 44469
44336: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
44337: NOP4
44341: PUSH
44342: NOP4
44346: PUSH
44347: NOP4
44351: PUSH
44352: LD_INT 4
44354: MINUS
44355: PUSH
44356: LD_INT 3
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: LIST
44363: PUSH
44364: NOP4
44368: PUSH
44369: LD_INT 3
44371: MINUS
44372: PUSH
44373: NOP4
44377: PUSH
44378: LD_INT 3
44380: MINUS
44381: PUSH
44382: LD_INT 2
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: LIST
44389: PUSH
44390: NOP4
44394: PUSH
44395: LD_INT 4
44397: MINUS
44398: PUSH
44399: NOP4
44403: PUSH
44404: LD_INT 1
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: LIST
44411: PUSH
44412: NOP4
44416: PUSH
44417: NOP4
44421: PUSH
44422: LD_INT 3
44424: PLUS
44425: PUSH
44426: LD_INT 0
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: LIST
44433: PUSH
44434: NOP4
44438: PUSH
44439: LD_INT 4
44441: PLUS
44442: PUSH
44443: NOP4
44447: PUSH
44448: LD_INT 4
44450: PLUS
44451: PUSH
44452: LD_INT 5
44454: PUSH
44455: EMPTY
44456: LIST
44457: LIST
44458: LIST
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: ST_TO_ADDR
// end ; 2 :
44467: GO 45026
44469: LD_INT 2
44471: DOUBLE
44472: EQUAL
44473: IFTRUE 44477
44475: GO 44606
44477: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
44478: NOP4
44482: PUSH
44483: NOP4
44487: PUSH
44488: NOP4
44492: PUSH
44493: LD_INT 3
44495: MINUS
44496: PUSH
44497: LD_INT 3
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: LIST
44504: PUSH
44505: NOP4
44509: PUSH
44510: LD_INT 4
44512: PLUS
44513: PUSH
44514: NOP4
44518: PUSH
44519: LD_INT 4
44521: PUSH
44522: EMPTY
44523: LIST
44524: LIST
44525: LIST
44526: PUSH
44527: NOP4
44531: PUSH
44532: NOP4
44536: PUSH
44537: LD_INT 4
44539: PLUS
44540: PUSH
44541: LD_INT 0
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: LIST
44548: PUSH
44549: NOP4
44553: PUSH
44554: LD_INT 3
44556: MINUS
44557: PUSH
44558: NOP4
44562: PUSH
44563: LD_INT 1
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: LIST
44570: PUSH
44571: NOP4
44575: PUSH
44576: LD_INT 4
44578: MINUS
44579: PUSH
44580: NOP4
44584: PUSH
44585: LD_INT 4
44587: MINUS
44588: PUSH
44589: LD_INT 2
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: LIST
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: LIST
44601: LIST
44602: LIST
44603: ST_TO_ADDR
// end ; 3 :
44604: GO 45026
44606: LD_INT 3
44608: DOUBLE
44609: EQUAL
44610: IFTRUE 44614
44612: GO 44747
44614: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
44615: NOP4
44619: PUSH
44620: NOP4
44624: PUSH
44625: LD_INT 3
44627: PLUS
44628: PUSH
44629: NOP4
44633: PUSH
44634: LD_INT 4
44636: PUSH
44637: EMPTY
44638: LIST
44639: LIST
44640: LIST
44641: PUSH
44642: NOP4
44646: PUSH
44647: LD_INT 4
44649: PLUS
44650: PUSH
44651: NOP4
44655: PUSH
44656: LD_INT 4
44658: PLUS
44659: PUSH
44660: LD_INT 5
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: LIST
44667: PUSH
44668: NOP4
44672: PUSH
44673: LD_INT 4
44675: MINUS
44676: PUSH
44677: NOP4
44681: PUSH
44682: LD_INT 1
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: LIST
44689: PUSH
44690: NOP4
44694: PUSH
44695: NOP4
44699: PUSH
44700: LD_INT 4
44702: MINUS
44703: PUSH
44704: LD_INT 3
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: LIST
44711: PUSH
44712: NOP4
44716: PUSH
44717: LD_INT 3
44719: MINUS
44720: PUSH
44721: NOP4
44725: PUSH
44726: LD_INT 3
44728: MINUS
44729: PUSH
44730: LD_INT 2
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: LIST
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: ST_TO_ADDR
// end ; 4 :
44745: GO 45026
44747: LD_INT 4
44749: DOUBLE
44750: EQUAL
44751: IFTRUE 44755
44753: GO 44888
44755: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44756: NOP4
44760: PUSH
44761: NOP4
44765: PUSH
44766: NOP4
44770: PUSH
44771: LD_INT 4
44773: PLUS
44774: PUSH
44775: LD_INT 0
44777: PUSH
44778: EMPTY
44779: LIST
44780: LIST
44781: LIST
44782: PUSH
44783: NOP4
44787: PUSH
44788: LD_INT 3
44790: PLUS
44791: PUSH
44792: NOP4
44796: PUSH
44797: LD_INT 3
44799: PLUS
44800: PUSH
44801: LD_INT 5
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: LIST
44808: PUSH
44809: NOP4
44813: PUSH
44814: LD_INT 4
44816: PLUS
44817: PUSH
44818: NOP4
44822: PUSH
44823: LD_INT 4
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: LIST
44830: PUSH
44831: NOP4
44835: PUSH
44836: NOP4
44840: PUSH
44841: LD_INT 3
44843: MINUS
44844: PUSH
44845: LD_INT 3
44847: PUSH
44848: EMPTY
44849: LIST
44850: LIST
44851: LIST
44852: PUSH
44853: NOP4
44857: PUSH
44858: LD_INT 4
44860: MINUS
44861: PUSH
44862: NOP4
44866: PUSH
44867: LD_INT 4
44869: MINUS
44870: PUSH
44871: LD_INT 2
44873: PUSH
44874: EMPTY
44875: LIST
44876: LIST
44877: LIST
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: LIST
44883: LIST
44884: LIST
44885: ST_TO_ADDR
// end ; 5 :
44886: GO 45026
44888: LD_INT 5
44890: DOUBLE
44891: EQUAL
44892: IFTRUE 44896
44894: GO 45025
44896: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44897: NOP4
44901: PUSH
44902: NOP4
44906: PUSH
44907: LD_INT 4
44909: MINUS
44910: PUSH
44911: NOP4
44915: PUSH
44916: LD_INT 1
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: LIST
44923: PUSH
44924: NOP4
44928: PUSH
44929: NOP4
44933: PUSH
44934: LD_INT 4
44936: MINUS
44937: PUSH
44938: LD_INT 3
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: LIST
44945: PUSH
44946: NOP4
44950: PUSH
44951: LD_INT 4
44953: PLUS
44954: PUSH
44955: NOP4
44959: PUSH
44960: LD_INT 4
44962: PLUS
44963: PUSH
44964: LD_INT 5
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: LIST
44971: PUSH
44972: NOP4
44976: PUSH
44977: LD_INT 3
44979: PLUS
44980: PUSH
44981: NOP4
44985: PUSH
44986: LD_INT 4
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: LIST
44993: PUSH
44994: NOP4
44998: PUSH
44999: NOP4
45003: PUSH
45004: LD_INT 3
45006: PLUS
45007: PUSH
45008: LD_INT 0
45010: PUSH
45011: EMPTY
45012: LIST
45013: LIST
45014: LIST
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: LIST
45020: LIST
45021: LIST
45022: ST_TO_ADDR
// end ; end ;
45023: GO 45026
45025: POP
// result := list ;
45026: NOP4
45030: PUSH
45031: NOP4
45035: ST_TO_ADDR
// end ;
45036: LD_VAR 0 4
45040: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45041: LD_INT 0
45043: PPUSH
45044: PPUSH
45045: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45046: NOP4
45050: NOT
45051: PUSH
45052: NOP4
45056: PUSH
45057: LD_INT 1
45059: PUSH
45060: LD_INT 2
45062: PUSH
45063: LD_INT 3
45065: PUSH
45066: LD_INT 4
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: IN
45075: NOT
45076: OR
45077: IFFALSE 45081
// exit ;
45079: GO 45173
// tmp := [ ] ;
45081: NOP4
45085: PUSH
45086: EMPTY
45087: ST_TO_ADDR
// for i in units do
45088: NOP4
45092: PUSH
45093: NOP4
45097: PUSH
45098: FOR_IN
45099: IFFALSE 45142
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
45101: NOP4
45105: PUSH
45106: NOP4
45110: PPUSH
45111: NOP4
45115: PUSH
45116: LD_INT 1
45118: PLUS
45119: PPUSH
45120: NOP4
45124: PPUSH
45125: NOP4
45129: PPUSH
45130: NOP4
45134: PPUSH
45135: NOP4
45139: ST_TO_ADDR
45140: GO 45098
45142: POP
45143: POP
// if not tmp then
45144: NOP4
45148: NOT
45149: IFFALSE 45153
// exit ;
45151: GO 45173
// result := SortListByListDesc ( units , tmp ) ;
45153: NOP4
45157: PUSH
45158: NOP4
45162: PPUSH
45163: NOP4
45167: PPUSH
45168: NOP4
45172: ST_TO_ADDR
// end ;
45173: LD_VAR 0 3
45177: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45178: LD_INT 0
45180: PPUSH
45181: PPUSH
45182: PPUSH
// result := false ;
45183: NOP4
45187: PUSH
45188: LD_INT 0
45190: ST_TO_ADDR
// x := GetX ( building ) ;
45191: NOP4
45195: PUSH
45196: NOP4
45200: PPUSH
45201: NOP4
45205: ST_TO_ADDR
// y := GetY ( building ) ;
45206: NOP4
45210: PUSH
45211: NOP4
45215: PPUSH
45216: NOP4
45220: ST_TO_ADDR
// if not building or not x or not y then
45221: NOP4
45225: NOT
45226: PUSH
45227: NOP4
45231: NOT
45232: OR
45233: PUSH
45234: NOP4
45238: NOT
45239: OR
45240: IFFALSE 45244
// exit ;
45242: GO 45336
// if GetTaskList ( unit ) then
45244: NOP4
45248: PPUSH
45249: NOP4
45253: IFFALSE 45336
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45255: LD_STRING e
45257: PUSH
45258: NOP4
45262: PPUSH
45263: NOP4
45267: PUSH
45268: LD_INT 1
45270: ARRAY
45271: PUSH
45272: LD_INT 1
45274: ARRAY
45275: EQUAL
45276: PUSH
45277: NOP4
45281: PUSH
45282: NOP4
45286: PPUSH
45287: NOP4
45291: PUSH
45292: LD_INT 1
45294: ARRAY
45295: PUSH
45296: LD_INT 2
45298: ARRAY
45299: EQUAL
45300: AND
45301: PUSH
45302: NOP4
45306: PUSH
45307: NOP4
45311: PPUSH
45312: NOP4
45316: PUSH
45317: LD_INT 1
45319: ARRAY
45320: PUSH
45321: LD_INT 3
45323: ARRAY
45324: EQUAL
45325: AND
45326: IFFALSE 45336
// result := true end ;
45328: NOP4
45332: PUSH
45333: LD_INT 1
45335: ST_TO_ADDR
// end ;
45336: LD_VAR 0 3
45340: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
45341: LD_INT 0
45343: PPUSH
// result := false ;
45344: NOP4
45348: PUSH
45349: LD_INT 0
45351: ST_TO_ADDR
// if GetTaskList ( unit ) then
45352: NOP4
45356: PPUSH
45357: NOP4
45361: IFFALSE 45444
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45363: LD_STRING M
45365: PUSH
45366: NOP4
45370: PPUSH
45371: NOP4
45375: PUSH
45376: LD_INT 1
45378: ARRAY
45379: PUSH
45380: LD_INT 1
45382: ARRAY
45383: EQUAL
45384: PUSH
45385: NOP4
45389: PUSH
45390: NOP4
45394: PPUSH
45395: NOP4
45399: PUSH
45400: LD_INT 1
45402: ARRAY
45403: PUSH
45404: LD_INT 2
45406: ARRAY
45407: EQUAL
45408: AND
45409: PUSH
45410: NOP4
45414: PUSH
45415: NOP4
45419: PPUSH
45420: NOP4
45424: PUSH
45425: LD_INT 1
45427: ARRAY
45428: PUSH
45429: LD_INT 3
45431: ARRAY
45432: EQUAL
45433: AND
45434: IFFALSE 45444
// result := true ;
45436: NOP4
45440: PUSH
45441: LD_INT 1
45443: ST_TO_ADDR
// end ; end ;
45444: LD_VAR 0 4
45448: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
45449: LD_INT 0
45451: PPUSH
45452: PPUSH
45453: PPUSH
45454: PPUSH
// if not unit or not area then
45455: NOP4
45459: NOT
45460: PUSH
45461: NOP4
45465: NOT
45466: OR
45467: IFFALSE 45471
// exit ;
45469: GO 45635
// tmp := AreaToList ( area , i ) ;
45471: NOP4
45475: PUSH
45476: NOP4
45480: PPUSH
45481: NOP4
45485: PPUSH
45486: NOP4
45490: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
45491: NOP4
45495: PUSH
45496: DOUBLE
45497: LD_INT 1
45499: DEC
45500: ST_TO_ADDR
45501: NOP4
45505: PUSH
45506: LD_INT 1
45508: ARRAY
45509: PUSH
45510: FOR_TO
45511: IFFALSE 45633
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
45513: NOP4
45517: PUSH
45518: NOP4
45522: PUSH
45523: LD_INT 1
45525: ARRAY
45526: PUSH
45527: NOP4
45531: ARRAY
45532: PUSH
45533: NOP4
45537: PUSH
45538: LD_INT 2
45540: ARRAY
45541: PUSH
45542: NOP4
45546: ARRAY
45547: PUSH
45548: EMPTY
45549: LIST
45550: LIST
45551: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
45552: NOP4
45556: PUSH
45557: LD_INT 1
45559: ARRAY
45560: PPUSH
45561: NOP4
45565: PUSH
45566: LD_INT 2
45568: ARRAY
45569: PPUSH
45570: NOP4
45574: PUSH
45575: LD_INT 0
45577: EQUAL
45578: IFFALSE 45631
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
45580: NOP4
45584: PPUSH
45585: NOP4
45589: PUSH
45590: LD_INT 1
45592: ARRAY
45593: PPUSH
45594: NOP4
45598: PUSH
45599: LD_INT 2
45601: ARRAY
45602: PPUSH
45603: NOP4
45607: PPUSH
45608: NOP4
// result := IsPlaced ( unit ) ;
45612: NOP4
45616: PUSH
45617: NOP4
45621: PPUSH
45622: NOP4
45626: ST_TO_ADDR
// exit ;
45627: POP
45628: POP
45629: GO 45635
// end ; end ;
45631: GO 45510
45633: POP
45634: POP
// end ;
45635: LD_VAR 0 4
45639: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
45640: LD_INT 0
45642: PPUSH
45643: PPUSH
45644: PPUSH
// if not side or side > 8 then
45645: NOP4
45649: NOT
45650: PUSH
45651: NOP4
45655: PUSH
45656: LD_INT 8
45658: GREATER
45659: OR
45660: IFFALSE 45664
// exit ;
45662: GO 45851
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
45664: NOP4
45668: PUSH
45669: LD_INT 22
45671: PUSH
45672: NOP4
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 21
45683: PUSH
45684: LD_INT 3
45686: PUSH
45687: EMPTY
45688: LIST
45689: LIST
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PPUSH
45695: NOP4
45699: ST_TO_ADDR
// if not tmp then
45700: NOP4
45704: NOT
45705: IFFALSE 45709
// exit ;
45707: GO 45851
// enable_addtolog := true ;
45709: LD_ADDR_OWVAR 81
45713: PUSH
45714: LD_INT 1
45716: ST_TO_ADDR
// AddToLog ( [ ) ;
45717: LD_STRING [
45719: PPUSH
45720: NOP4
// for i in tmp do
45724: NOP4
45728: PUSH
45729: NOP4
45733: PUSH
45734: FOR_IN
45735: IFFALSE 45842
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45737: LD_STRING [
45739: PUSH
45740: NOP4
45744: PPUSH
45745: NOP4
45749: STR
45750: PUSH
45751: LD_STRING , 
45753: STR
45754: PUSH
45755: NOP4
45759: PPUSH
45760: NOP4
45764: STR
45765: PUSH
45766: LD_STRING , 
45768: STR
45769: PUSH
45770: NOP4
45774: PPUSH
45775: NOP4
45779: STR
45780: PUSH
45781: LD_STRING , 
45783: STR
45784: PUSH
45785: NOP4
45789: PPUSH
45790: NOP4
45794: STR
45795: PUSH
45796: LD_STRING , 
45798: STR
45799: PUSH
45800: NOP4
45804: PPUSH
45805: LD_INT 1
45807: PPUSH
45808: NOP4
45812: STR
45813: PUSH
45814: LD_STRING , 
45816: STR
45817: PUSH
45818: NOP4
45822: PPUSH
45823: LD_INT 2
45825: PPUSH
45826: NOP4
45830: STR
45831: PUSH
45832: LD_STRING ],
45834: STR
45835: PPUSH
45836: NOP4
// end ;
45840: GO 45734
45842: POP
45843: POP
// AddToLog ( ]; ) ;
45844: LD_STRING ];
45846: PPUSH
45847: NOP4
// end ;
45851: LD_VAR 0 2
45855: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45856: LD_INT 0
45858: PPUSH
45859: PPUSH
45860: PPUSH
45861: PPUSH
45862: PPUSH
// if not area or not rate or not max then
45863: NOP4
45867: NOT
45868: PUSH
45869: NOP4
45873: NOT
45874: OR
45875: PUSH
45876: NOP4
45880: NOT
45881: OR
45882: IFFALSE 45886
// exit ;
45884: GO 46075
// while 1 do
45886: LD_INT 1
45888: IFFALSE 46075
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45890: NOP4
45894: PUSH
45895: NOP4
45899: PPUSH
45900: LD_INT 1
45902: PPUSH
45903: NOP4
45907: PUSH
45908: LD_INT 10
45910: MUL
45911: ST_TO_ADDR
// r := rate / 10 ;
45912: NOP4
45916: PUSH
45917: NOP4
45921: PUSH
45922: LD_INT 10
45924: DIVREAL
45925: ST_TO_ADDR
// time := 1 1$00 ;
45926: NOP4
45930: PUSH
45931: LD_INT 2100
45933: ST_TO_ADDR
// if amount < min then
45934: NOP4
45938: PUSH
45939: NOP4
45943: LESS
45944: IFFALSE 45962
// r := r * 2 else
45946: NOP4
45950: PUSH
45951: NOP4
45955: PUSH
45956: LD_INT 2
45958: MUL
45959: ST_TO_ADDR
45960: GO 45988
// if amount > max then
45962: NOP4
45966: PUSH
45967: NOP4
45971: GREATER
45972: IFFALSE 45988
// r := r / 2 ;
45974: NOP4
45978: PUSH
45979: NOP4
45983: PUSH
45984: LD_INT 2
45986: DIVREAL
45987: ST_TO_ADDR
// time := time / r ;
45988: NOP4
45992: PUSH
45993: NOP4
45997: PUSH
45998: NOP4
46002: DIVREAL
46003: ST_TO_ADDR
// if time < 0 then
46004: NOP4
46008: PUSH
46009: LD_INT 0
46011: LESS
46012: IFFALSE 46029
// time := time * - 1 ;
46014: NOP4
46018: PUSH
46019: NOP4
46023: PUSH
46024: LD_INT 1
46026: NEG
46027: MUL
46028: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
46029: NOP4
46033: PUSH
46034: LD_INT 35
46036: PPUSH
46037: LD_INT 875
46039: PPUSH
46040: NOP4
46044: PLUS
46045: PPUSH
46046: NOP4
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46050: LD_INT 1
46052: PPUSH
46053: LD_INT 5
46055: PPUSH
46056: NOP4
46060: PPUSH
46061: NOP4
46065: PPUSH
46066: LD_INT 1
46068: PPUSH
46069: NOP4
// end ;
46073: GO 45886
// end ;
46075: LD_VAR 0 5
46079: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46080: LD_INT 0
46082: PPUSH
46083: PPUSH
46084: PPUSH
46085: PPUSH
46086: PPUSH
46087: PPUSH
46088: PPUSH
46089: PPUSH
// if not turrets or not factories then
46090: NOP4
46094: NOT
46095: PUSH
46096: NOP4
46100: NOT
46101: OR
46102: IFFALSE 46106
// exit ;
46104: GO 46413
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46106: NOP4
46110: PUSH
46111: LD_INT 5
46113: PUSH
46114: LD_INT 6
46116: PUSH
46117: EMPTY
46118: LIST
46119: LIST
46120: PUSH
46121: LD_INT 2
46123: PUSH
46124: LD_INT 4
46126: PUSH
46127: EMPTY
46128: LIST
46129: LIST
46130: PUSH
46131: LD_INT 3
46133: PUSH
46134: LD_INT 5
46136: PUSH
46137: EMPTY
46138: LIST
46139: LIST
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 24
46148: PUSH
46149: LD_INT 25
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 23
46158: PUSH
46159: LD_INT 27
46161: PUSH
46162: EMPTY
46163: LIST
46164: LIST
46165: PUSH
46166: EMPTY
46167: LIST
46168: LIST
46169: PUSH
46170: LD_INT 42
46172: PUSH
46173: LD_INT 43
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: PUSH
46180: LD_INT 44
46182: PUSH
46183: LD_INT 46
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PUSH
46190: LD_INT 45
46192: PUSH
46193: LD_INT 47
46195: PUSH
46196: EMPTY
46197: LIST
46198: LIST
46199: PUSH
46200: EMPTY
46201: LIST
46202: LIST
46203: LIST
46204: PUSH
46205: EMPTY
46206: LIST
46207: LIST
46208: LIST
46209: ST_TO_ADDR
// result := [ ] ;
46210: NOP4
46214: PUSH
46215: EMPTY
46216: ST_TO_ADDR
// for i in turrets do
46217: NOP4
46221: PUSH
46222: NOP4
46226: PUSH
46227: FOR_IN
46228: IFFALSE 46411
// begin nat := GetNation ( i ) ;
46230: NOP4
46234: PUSH
46235: NOP4
46239: PPUSH
46240: NOP4
46244: ST_TO_ADDR
// weapon := 0 ;
46245: NOP4
46249: PUSH
46250: LD_INT 0
46252: ST_TO_ADDR
// if not nat then
46253: NOP4
46257: NOT
46258: IFFALSE 46262
// continue ;
46260: GO 46227
// for j in list [ nat ] do
46262: NOP4
46266: PUSH
46267: NOP4
46271: PUSH
46272: NOP4
46276: ARRAY
46277: PUSH
46278: FOR_IN
46279: IFFALSE 46320
// if GetBWeapon ( i ) = j [ 1 ] then
46281: NOP4
46285: PPUSH
46286: NOP4
46290: PUSH
46291: NOP4
46295: PUSH
46296: LD_INT 1
46298: ARRAY
46299: EQUAL
46300: IFFALSE 46318
// begin weapon := j [ 2 ] ;
46302: NOP4
46306: PUSH
46307: NOP4
46311: PUSH
46312: LD_INT 2
46314: ARRAY
46315: ST_TO_ADDR
// break ;
46316: GO 46320
// end ;
46318: GO 46278
46320: POP
46321: POP
// if not weapon then
46322: NOP4
46326: NOT
46327: IFFALSE 46331
// continue ;
46329: GO 46227
// for k in factories do
46331: NOP4
46335: PUSH
46336: NOP4
46340: PUSH
46341: FOR_IN
46342: IFFALSE 46407
// begin weapons := AvailableWeaponList ( k ) ;
46344: NOP4
46348: PUSH
46349: NOP4
46353: PPUSH
46354: NOP4
46358: ST_TO_ADDR
// if not weapons then
46359: NOP4
46363: NOT
46364: IFFALSE 46368
// continue ;
46366: GO 46341
// if weapon in weapons then
46368: NOP4
46372: PUSH
46373: NOP4
46377: IN
46378: IFFALSE 46405
// begin result := [ i , weapon ] ;
46380: NOP4
46384: PUSH
46385: NOP4
46389: PUSH
46390: NOP4
46394: PUSH
46395: EMPTY
46396: LIST
46397: LIST
46398: ST_TO_ADDR
// exit ;
46399: POP
46400: POP
46401: POP
46402: POP
46403: GO 46413
// end ; end ;
46405: GO 46341
46407: POP
46408: POP
// end ;
46409: GO 46227
46411: POP
46412: POP
// end ;
46413: LD_VAR 0 3
46417: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
46418: LD_INT 0
46420: PPUSH
// if not side or side > 8 then
46421: NOP4
46425: NOT
46426: PUSH
46427: NOP4
46431: PUSH
46432: LD_INT 8
46434: GREATER
46435: OR
46436: IFFALSE 46440
// exit ;
46438: GO 46499
// if not range then
46440: NOP4
46444: NOT
46445: IFFALSE 46456
// range := - 12 ;
46447: NOP4
46451: PUSH
46452: LD_INT 12
46454: NEG
46455: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
46456: NOP4
46460: PPUSH
46461: NOP4
46465: PPUSH
46466: NOP4
46470: PPUSH
46471: NOP4
46475: PPUSH
46476: NOP4
// RemoveSeeing ( x , y , side ) ;
46480: NOP4
46484: PPUSH
46485: NOP4
46489: PPUSH
46490: NOP4
46494: PPUSH
46495: NOP4
// end ;
46499: LD_VAR 0 5
46503: RET
// export function Video ( mode ) ; begin
46504: LD_INT 0
46506: PPUSH
// ingame_video = mode ;
46507: LD_ADDR_OWVAR 52
46511: PUSH
46512: NOP4
46516: ST_TO_ADDR
// interface_hidden = mode ;
46517: LD_ADDR_OWVAR 54
46521: PUSH
46522: NOP4
46526: ST_TO_ADDR
// end ;
46527: LD_VAR 0 2
46531: RET
// export function Join ( array , element ) ; begin
46532: LD_INT 0
46534: PPUSH
// result := Replace ( array , array + 1 , element ) ;
46535: NOP4
46539: PUSH
46540: NOP4
46544: PPUSH
46545: NOP4
46549: PUSH
46550: LD_INT 1
46552: PLUS
46553: PPUSH
46554: NOP4
46558: PPUSH
46559: NOP4
46563: ST_TO_ADDR
// end ;
46564: LD_VAR 0 3
46568: RET
// export function JoinUnion ( array , element ) ; begin
46569: LD_INT 0
46571: PPUSH
// result := array union element ;
46572: NOP4
46576: PUSH
46577: NOP4
46581: PUSH
46582: NOP4
46586: UNION
46587: ST_TO_ADDR
// end ;
46588: LD_VAR 0 3
46592: RET
// export function GetBehemoths ( side ) ; begin
46593: LD_INT 0
46595: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
46596: NOP4
46600: PUSH
46601: LD_INT 22
46603: PUSH
46604: NOP4
46608: PUSH
46609: EMPTY
46610: LIST
46611: LIST
46612: PUSH
46613: LD_INT 31
46615: PUSH
46616: LD_INT 25
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PPUSH
46627: NOP4
46631: ST_TO_ADDR
// end ;
46632: LD_VAR 0 2
46636: RET
// export function Shuffle ( array ) ; var i , index ; begin
46637: LD_INT 0
46639: PPUSH
46640: PPUSH
46641: PPUSH
// result := [ ] ;
46642: NOP4
46646: PUSH
46647: EMPTY
46648: ST_TO_ADDR
// if not array then
46649: NOP4
46653: NOT
46654: IFFALSE 46658
// exit ;
46656: GO 46757
// Randomize ;
46658: NOP4
// for i = array downto 1 do
46662: NOP4
46666: PUSH
46667: DOUBLE
46668: NOP4
46672: INC
46673: ST_TO_ADDR
46674: LD_INT 1
46676: PUSH
46677: FOR_DOWNTO
46678: IFFALSE 46755
// begin index := rand ( 1 , array ) ;
46680: NOP4
46684: PUSH
46685: LD_INT 1
46687: PPUSH
46688: NOP4
46692: PPUSH
46693: NOP4
46697: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46698: NOP4
46702: PUSH
46703: NOP4
46707: PPUSH
46708: NOP4
46712: PUSH
46713: LD_INT 1
46715: PLUS
46716: PPUSH
46717: NOP4
46721: PUSH
46722: NOP4
46726: ARRAY
46727: PPUSH
46728: NOP4
46732: ST_TO_ADDR
// array := Delete ( array , index ) ;
46733: NOP4
46737: PUSH
46738: NOP4
46742: PPUSH
46743: NOP4
46747: PPUSH
46748: NOP4
46752: ST_TO_ADDR
// end ;
46753: GO 46677
46755: POP
46756: POP
// end ;
46757: LD_VAR 0 2
46761: RET
// export function GetBaseMaterials ( base ) ; begin
46762: LD_INT 0
46764: PPUSH
// result := [ 0 , 0 , 0 ] ;
46765: NOP4
46769: PUSH
46770: LD_INT 0
46772: PUSH
46773: LD_INT 0
46775: PUSH
46776: LD_INT 0
46778: PUSH
46779: EMPTY
46780: LIST
46781: LIST
46782: LIST
46783: ST_TO_ADDR
// if not base then
46784: NOP4
46788: NOT
46789: IFFALSE 46793
// exit ;
46791: GO 46842
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46793: NOP4
46797: PUSH
46798: NOP4
46802: PPUSH
46803: LD_INT 1
46805: PPUSH
46806: NOP4
46810: PUSH
46811: NOP4
46815: PPUSH
46816: LD_INT 2
46818: PPUSH
46819: NOP4
46823: PUSH
46824: NOP4
46828: PPUSH
46829: LD_INT 3
46831: PPUSH
46832: NOP4
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: LIST
46841: ST_TO_ADDR
// end ;
46842: LD_VAR 0 2
46846: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46847: LD_INT 0
46849: PPUSH
46850: PPUSH
// result := array ;
46851: NOP4
46855: PUSH
46856: NOP4
46860: ST_TO_ADDR
// if size > 0 then
46861: NOP4
46865: PUSH
46866: LD_INT 0
46868: GREATER
46869: IFFALSE 46915
// for i := array downto size do
46871: NOP4
46875: PUSH
46876: DOUBLE
46877: NOP4
46881: INC
46882: ST_TO_ADDR
46883: NOP4
46887: PUSH
46888: FOR_DOWNTO
46889: IFFALSE 46913
// result := Delete ( result , result ) ;
46891: NOP4
46895: PUSH
46896: NOP4
46900: PPUSH
46901: NOP4
46905: PPUSH
46906: NOP4
46910: ST_TO_ADDR
46911: GO 46888
46913: POP
46914: POP
// end ;
46915: LD_VAR 0 3
46919: RET
// export function ComExit ( unit ) ; var tmp ; begin
46920: LD_INT 0
46922: PPUSH
46923: PPUSH
// if not IsInUnit ( unit ) then
46924: NOP4
46928: PPUSH
46929: NOP4
46933: NOT
46934: IFFALSE 46938
// exit ;
46936: GO 46998
// tmp := IsInUnit ( unit ) ;
46938: NOP4
46942: PUSH
46943: NOP4
46947: PPUSH
46948: NOP4
46952: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
46953: NOP4
46957: PPUSH
46958: NOP4
46962: PUSH
46963: LD_INT 2
46965: EQUAL
46966: IFFALSE 46979
// ComExitVehicle ( unit ) else
46968: NOP4
46972: PPUSH
46973: NOP4
46977: GO 46988
// ComExitBuilding ( unit ) ;
46979: NOP4
46983: PPUSH
46984: NOP4
// result := tmp ;
46988: NOP4
46992: PUSH
46993: NOP4
46997: ST_TO_ADDR
// end ;
46998: LD_VAR 0 2
47002: RET
// export function ComExitAll ( units ) ; var i ; begin
47003: LD_INT 0
47005: PPUSH
47006: PPUSH
// if not units then
47007: NOP4
47011: NOT
47012: IFFALSE 47016
// exit ;
47014: GO 47042
// for i in units do
47016: NOP4
47020: PUSH
47021: NOP4
47025: PUSH
47026: FOR_IN
47027: IFFALSE 47040
// ComExit ( i ) ;
47029: NOP4
47033: PPUSH
47034: NOP4
47038: GO 47026
47040: POP
47041: POP
// end ;
47042: LD_VAR 0 2
47046: RET
// export function ResetHc ; begin
47047: LD_INT 0
47049: PPUSH
// InitHc ;
47050: NOP4
// hc_importance := 0 ;
47054: LD_ADDR_OWVAR 32
47058: PUSH
47059: LD_INT 0
47061: ST_TO_ADDR
// end ;
47062: LD_VAR 0 1
47066: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47067: LD_INT 0
47069: PPUSH
47070: PPUSH
47071: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47072: NOP4
47076: PUSH
47077: NOP4
47081: PUSH
47082: NOP4
47086: PLUS
47087: PUSH
47088: LD_INT 2
47090: DIV
47091: ST_TO_ADDR
// if _x < 0 then
47092: NOP4
47096: PUSH
47097: LD_INT 0
47099: LESS
47100: IFFALSE 47117
// _x := _x * - 1 ;
47102: NOP4
47106: PUSH
47107: NOP4
47111: PUSH
47112: LD_INT 1
47114: NEG
47115: MUL
47116: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47117: NOP4
47121: PUSH
47122: NOP4
47126: PUSH
47127: NOP4
47131: PLUS
47132: PUSH
47133: LD_INT 2
47135: DIV
47136: ST_TO_ADDR
// if _y < 0 then
47137: NOP4
47141: PUSH
47142: LD_INT 0
47144: LESS
47145: IFFALSE 47162
// _y := _y * - 1 ;
47147: NOP4
47151: PUSH
47152: NOP4
47156: PUSH
47157: LD_INT 1
47159: NEG
47160: MUL
47161: ST_TO_ADDR
// result := [ _x , _y ] ;
47162: NOP4
47166: PUSH
47167: NOP4
47171: PUSH
47172: NOP4
47176: PUSH
47177: EMPTY
47178: LIST
47179: LIST
47180: ST_TO_ADDR
// end ;
47181: LD_VAR 0 5
47185: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47186: LD_INT 0
47188: PPUSH
47189: PPUSH
47190: PPUSH
47191: PPUSH
// task := GetTaskList ( unit ) ;
47192: NOP4
47196: PUSH
47197: NOP4
47201: PPUSH
47202: NOP4
47206: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47207: NOP4
47211: NOT
47212: PUSH
47213: NOP4
47217: PPUSH
47218: NOP4
47222: PPUSH
47223: NOP4
47227: NOT
47228: AND
47229: IFFALSE 47233
// exit ;
47231: GO 47351
// if IsInArea ( unit , area ) then
47233: NOP4
47237: PPUSH
47238: NOP4
47242: PPUSH
47243: NOP4
47247: IFFALSE 47265
// begin ComMoveToArea ( unit , goAway ) ;
47249: NOP4
47253: PPUSH
47254: NOP4
47258: PPUSH
47259: NOP4
// exit ;
47263: GO 47351
// end ; if task [ 1 ] [ 1 ] <> M then
47265: NOP4
47269: PUSH
47270: LD_INT 1
47272: ARRAY
47273: PUSH
47274: LD_INT 1
47276: ARRAY
47277: PUSH
47278: LD_STRING M
47280: NONEQUAL
47281: IFFALSE 47285
// exit ;
47283: GO 47351
// x := task [ 1 ] [ 2 ] ;
47285: NOP4
47289: PUSH
47290: NOP4
47294: PUSH
47295: LD_INT 1
47297: ARRAY
47298: PUSH
47299: LD_INT 2
47301: ARRAY
47302: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
47303: NOP4
47307: PUSH
47308: NOP4
47312: PUSH
47313: LD_INT 1
47315: ARRAY
47316: PUSH
47317: LD_INT 3
47319: ARRAY
47320: ST_TO_ADDR
// if InArea ( x , y , area ) then
47321: NOP4
47325: PPUSH
47326: NOP4
47330: PPUSH
47331: NOP4
47335: PPUSH
47336: NOP4
47340: IFFALSE 47351
// ComStop ( unit ) ;
47342: NOP4
47346: PPUSH
47347: NOP4
// end ;
47351: LD_VAR 0 4
47355: RET
// export function Abs ( value ) ; begin
47356: LD_INT 0
47358: PPUSH
// result := value ;
47359: NOP4
47363: PUSH
47364: NOP4
47368: ST_TO_ADDR
// if value < 0 then
47369: NOP4
47373: PUSH
47374: LD_INT 0
47376: LESS
47377: IFFALSE 47394
// result := value * - 1 ;
47379: NOP4
47383: PUSH
47384: NOP4
47388: PUSH
47389: LD_INT 1
47391: NEG
47392: MUL
47393: ST_TO_ADDR
// end ;
47394: LD_VAR 0 2
47398: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
47399: LD_INT 0
47401: PPUSH
47402: PPUSH
47403: PPUSH
47404: PPUSH
47405: PPUSH
47406: PPUSH
47407: PPUSH
47408: PPUSH
// if not unit or not building then
47409: NOP4
47413: NOT
47414: PUSH
47415: NOP4
47419: NOT
47420: OR
47421: IFFALSE 47425
// exit ;
47423: GO 47651
// x := GetX ( building ) ;
47425: NOP4
47429: PUSH
47430: NOP4
47434: PPUSH
47435: NOP4
47439: ST_TO_ADDR
// y := GetY ( building ) ;
47440: NOP4
47444: PUSH
47445: NOP4
47449: PPUSH
47450: NOP4
47454: ST_TO_ADDR
// d := GetDir ( building ) ;
47455: NOP4
47459: PUSH
47460: NOP4
47464: PPUSH
47465: NOP4
47469: ST_TO_ADDR
// r := 4 ;
47470: NOP4
47474: PUSH
47475: LD_INT 4
47477: ST_TO_ADDR
// for i := 1 to 5 do
47478: NOP4
47482: PUSH
47483: DOUBLE
47484: LD_INT 1
47486: DEC
47487: ST_TO_ADDR
47488: LD_INT 5
47490: PUSH
47491: FOR_TO
47492: IFFALSE 47649
// begin _x := ShiftX ( x , d , r + i ) ;
47494: NOP4
47498: PUSH
47499: NOP4
47503: PPUSH
47504: NOP4
47508: PPUSH
47509: NOP4
47513: PUSH
47514: NOP4
47518: PLUS
47519: PPUSH
47520: NOP4
47524: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
47525: NOP4
47529: PUSH
47530: NOP4
47534: PPUSH
47535: NOP4
47539: PPUSH
47540: NOP4
47544: PUSH
47545: NOP4
47549: PLUS
47550: PPUSH
47551: NOP4
47555: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
47556: NOP4
47560: PPUSH
47561: NOP4
47565: PPUSH
47566: NOP4
47570: PUSH
47571: NOP4
47575: PPUSH
47576: NOP4
47580: PPUSH
47581: NOP4
47585: PPUSH
47586: NOP4
47590: PUSH
47591: LD_INT 3
47593: PUSH
47594: LD_INT 2
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: IN
47601: NOT
47602: AND
47603: IFFALSE 47647
// begin ComMoveXY ( unit , _x , _y ) ;
47605: NOP4
47609: PPUSH
47610: NOP4
47614: PPUSH
47615: NOP4
47619: PPUSH
47620: NOP4
// result := [ _x , _y ] ;
47624: NOP4
47628: PUSH
47629: NOP4
47633: PUSH
47634: NOP4
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: ST_TO_ADDR
// exit ;
47643: POP
47644: POP
47645: GO 47651
// end ; end ;
47647: GO 47491
47649: POP
47650: POP
// end ;
47651: LD_VAR 0 3
47655: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
47656: LD_INT 0
47658: PPUSH
47659: PPUSH
47660: PPUSH
// result := 0 ;
47661: NOP4
47665: PUSH
47666: LD_INT 0
47668: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
47669: NOP4
47673: PUSH
47674: LD_INT 0
47676: LESS
47677: PUSH
47678: NOP4
47682: PUSH
47683: LD_INT 8
47685: GREATER
47686: OR
47687: PUSH
47688: NOP4
47692: PUSH
47693: LD_INT 0
47695: LESS
47696: OR
47697: PUSH
47698: NOP4
47702: PUSH
47703: LD_INT 8
47705: GREATER
47706: OR
47707: IFFALSE 47711
// exit ;
47709: GO 47786
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
47711: NOP4
47715: PUSH
47716: LD_INT 22
47718: PUSH
47719: NOP4
47723: PUSH
47724: EMPTY
47725: LIST
47726: LIST
47727: PPUSH
47728: NOP4
47732: PUSH
47733: FOR_IN
47734: IFFALSE 47784
// begin un := UnitShoot ( i ) ;
47736: NOP4
47740: PUSH
47741: NOP4
47745: PPUSH
47746: NOP4
47750: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47751: NOP4
47755: PPUSH
47756: NOP4
47760: PUSH
47761: NOP4
47765: EQUAL
47766: IFFALSE 47782
// begin result := un ;
47768: NOP4
47772: PUSH
47773: NOP4
47777: ST_TO_ADDR
// exit ;
47778: POP
47779: POP
47780: GO 47786
// end ; end ;
47782: GO 47733
47784: POP
47785: POP
// end ;
47786: LD_VAR 0 3
47790: RET
// export function GetCargoBay ( units ) ; begin
47791: LD_INT 0
47793: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
47794: NOP4
47798: PUSH
47799: NOP4
47803: PPUSH
47804: LD_INT 2
47806: PUSH
47807: LD_INT 34
47809: PUSH
47810: LD_INT 12
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: PUSH
47817: LD_INT 34
47819: PUSH
47820: LD_INT 51
47822: PUSH
47823: EMPTY
47824: LIST
47825: LIST
47826: PUSH
47827: LD_INT 34
47829: PUSH
47830: LD_INT 32
47832: PUSH
47833: EMPTY
47834: LIST
47835: LIST
47836: PUSH
47837: LD_INT 34
47839: PUSH
47840: NOP4
47844: PUSH
47845: EMPTY
47846: LIST
47847: LIST
47848: PUSH
47849: EMPTY
47850: LIST
47851: LIST
47852: LIST
47853: LIST
47854: LIST
47855: PPUSH
47856: NOP4
47860: ST_TO_ADDR
// end ;
47861: LD_VAR 0 2
47865: RET
// export function Negate ( value ) ; begin
47866: LD_INT 0
47868: PPUSH
// result := not value ;
47869: NOP4
47873: PUSH
47874: NOP4
47878: NOT
47879: ST_TO_ADDR
// end ;
47880: LD_VAR 0 2
47884: RET
// export function Inc ( value ) ; begin
47885: LD_INT 0
47887: PPUSH
// result := value + 1 ;
47888: NOP4
47892: PUSH
47893: NOP4
47897: PUSH
47898: LD_INT 1
47900: PLUS
47901: ST_TO_ADDR
// end ;
47902: LD_VAR 0 2
47906: RET
// export function Dec ( value ) ; begin
47907: LD_INT 0
47909: PPUSH
// result := value - 1 ;
47910: NOP4
47914: PUSH
47915: NOP4
47919: PUSH
47920: LD_INT 1
47922: MINUS
47923: ST_TO_ADDR
// end ;
47924: LD_VAR 0 2
47928: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
47929: LD_INT 0
47931: PPUSH
47932: PPUSH
47933: PPUSH
47934: PPUSH
47935: PPUSH
47936: PPUSH
47937: PPUSH
47938: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
47939: NOP4
47943: PPUSH
47944: NOP4
47948: PPUSH
47949: NOP4
47953: NOT
47954: PUSH
47955: NOP4
47959: PPUSH
47960: NOP4
47964: PPUSH
47965: NOP4
47969: NOT
47970: OR
47971: IFFALSE 47984
// begin result := - 1 ;
47973: NOP4
47977: PUSH
47978: LD_INT 1
47980: NEG
47981: ST_TO_ADDR
// exit ;
47982: GO 48219
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
47984: NOP4
47988: PUSH
47989: NOP4
47993: PPUSH
47994: NOP4
47998: PPUSH
47999: NOP4
48003: PPUSH
48004: NOP4
48008: PPUSH
48009: NOP4
48013: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
48014: NOP4
48018: PUSH
48019: NOP4
48023: PPUSH
48024: NOP4
48028: PPUSH
48029: NOP4
48033: PUSH
48034: LD_INT 1
48036: ARRAY
48037: PPUSH
48038: NOP4
48042: PUSH
48043: LD_INT 2
48045: ARRAY
48046: PPUSH
48047: NOP4
48051: ST_TO_ADDR
// distance := 9999 ;
48052: NOP4
48056: PUSH
48057: LD_INT 9999
48059: ST_TO_ADDR
// for i := 0 to 5 do
48060: NOP4
48064: PUSH
48065: DOUBLE
48066: LD_INT 0
48068: DEC
48069: ST_TO_ADDR
48070: LD_INT 5
48072: PUSH
48073: FOR_TO
48074: IFFALSE 48217
// begin _x := ShiftX ( x1 , i , centerDist ) ;
48076: NOP4
48080: PUSH
48081: NOP4
48085: PPUSH
48086: NOP4
48090: PPUSH
48091: NOP4
48095: PPUSH
48096: NOP4
48100: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
48101: NOP4
48105: PUSH
48106: NOP4
48110: PPUSH
48111: NOP4
48115: PPUSH
48116: NOP4
48120: PPUSH
48121: NOP4
48125: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48126: NOP4
48130: PPUSH
48131: NOP4
48135: PPUSH
48136: NOP4
48140: NOT
48141: IFFALSE 48145
// continue ;
48143: GO 48073
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
48145: NOP4
48149: PUSH
48150: NOP4
48154: PUSH
48155: LD_INT 1
48157: ARRAY
48158: PPUSH
48159: NOP4
48163: PUSH
48164: LD_INT 2
48166: ARRAY
48167: PPUSH
48168: NOP4
48172: PPUSH
48173: NOP4
48177: PPUSH
48178: NOP4
48182: ST_TO_ADDR
// if tmp < distance then
48183: NOP4
48187: PUSH
48188: NOP4
48192: LESS
48193: IFFALSE 48215
// begin result := i ;
48195: NOP4
48199: PUSH
48200: NOP4
48204: ST_TO_ADDR
// distance := tmp ;
48205: NOP4
48209: PUSH
48210: NOP4
48214: ST_TO_ADDR
// end ; end ;
48215: GO 48073
48217: POP
48218: POP
// end ;
48219: LD_VAR 0 5
48223: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48224: LD_INT 0
48226: PPUSH
48227: PPUSH
// if not driver or not IsInUnit ( driver ) then
48228: NOP4
48232: NOT
48233: PUSH
48234: NOP4
48238: PPUSH
48239: NOP4
48243: NOT
48244: OR
48245: IFFALSE 48249
// exit ;
48247: GO 48339
// vehicle := IsInUnit ( driver ) ;
48249: NOP4
48253: PUSH
48254: NOP4
48258: PPUSH
48259: NOP4
48263: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48264: NOP4
48268: PPUSH
48269: LD_STRING \
48271: PUSH
48272: LD_INT 0
48274: PUSH
48275: LD_INT 0
48277: PUSH
48278: LD_INT 0
48280: PUSH
48281: LD_INT 0
48283: PUSH
48284: LD_INT 0
48286: PUSH
48287: LD_INT 0
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: LIST
48294: LIST
48295: LIST
48296: LIST
48297: LIST
48298: PUSH
48299: LD_STRING E
48301: PUSH
48302: LD_INT 0
48304: PUSH
48305: LD_INT 0
48307: PUSH
48308: NOP4
48312: PUSH
48313: LD_INT 0
48315: PUSH
48316: LD_INT 0
48318: PUSH
48319: LD_INT 0
48321: PUSH
48322: EMPTY
48323: LIST
48324: LIST
48325: LIST
48326: LIST
48327: LIST
48328: LIST
48329: LIST
48330: PUSH
48331: EMPTY
48332: LIST
48333: LIST
48334: PPUSH
48335: NOP4
// end ;
48339: LD_VAR 0 2
48343: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48344: LD_INT 0
48346: PPUSH
48347: PPUSH
// if not driver or not IsInUnit ( driver ) then
48348: NOP4
48352: NOT
48353: PUSH
48354: NOP4
48358: PPUSH
48359: NOP4
48363: NOT
48364: OR
48365: IFFALSE 48369
// exit ;
48367: GO 48459
// vehicle := IsInUnit ( driver ) ;
48369: NOP4
48373: PUSH
48374: NOP4
48378: PPUSH
48379: NOP4
48383: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48384: NOP4
48388: PPUSH
48389: LD_STRING \
48391: PUSH
48392: LD_INT 0
48394: PUSH
48395: LD_INT 0
48397: PUSH
48398: LD_INT 0
48400: PUSH
48401: LD_INT 0
48403: PUSH
48404: LD_INT 0
48406: PUSH
48407: LD_INT 0
48409: PUSH
48410: EMPTY
48411: LIST
48412: LIST
48413: LIST
48414: LIST
48415: LIST
48416: LIST
48417: LIST
48418: PUSH
48419: LD_STRING E
48421: PUSH
48422: LD_INT 0
48424: PUSH
48425: LD_INT 0
48427: PUSH
48428: NOP4
48432: PUSH
48433: LD_INT 0
48435: PUSH
48436: LD_INT 0
48438: PUSH
48439: LD_INT 0
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: LIST
48450: PUSH
48451: EMPTY
48452: LIST
48453: LIST
48454: PPUSH
48455: NOP4
// end ;
48459: LD_VAR 0 2
48463: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
48464: LD_INT 0
48466: PPUSH
48467: PPUSH
48468: PPUSH
// tmp := [ ] ;
48469: NOP4
48473: PUSH
48474: EMPTY
48475: ST_TO_ADDR
// for i in units do
48476: NOP4
48480: PUSH
48481: NOP4
48485: PUSH
48486: FOR_IN
48487: IFFALSE 48525
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
48489: NOP4
48493: PUSH
48494: NOP4
48498: PPUSH
48499: NOP4
48503: PUSH
48504: LD_INT 1
48506: PLUS
48507: PPUSH
48508: NOP4
48512: PPUSH
48513: NOP4
48517: PPUSH
48518: NOP4
48522: ST_TO_ADDR
48523: GO 48486
48525: POP
48526: POP
// if not tmp then
48527: NOP4
48531: NOT
48532: IFFALSE 48536
// exit ;
48534: GO 48584
// if asc then
48536: NOP4
48540: IFFALSE 48564
// result := SortListByListAsc ( units , tmp ) else
48542: NOP4
48546: PUSH
48547: NOP4
48551: PPUSH
48552: NOP4
48556: PPUSH
48557: NOP4
48561: ST_TO_ADDR
48562: GO 48584
// result := SortListByListDesc ( units , tmp ) ;
48564: NOP4
48568: PUSH
48569: NOP4
48573: PPUSH
48574: NOP4
48578: PPUSH
48579: NOP4
48583: ST_TO_ADDR
// end ;
48584: LD_VAR 0 3
48588: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
48589: LD_INT 0
48591: PPUSH
48592: PPUSH
// task := GetTaskList ( mech ) ;
48593: NOP4
48597: PUSH
48598: NOP4
48602: PPUSH
48603: NOP4
48607: ST_TO_ADDR
// if not task then
48608: NOP4
48612: NOT
48613: IFFALSE 48617
// exit ;
48615: GO 48659
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
48617: NOP4
48621: PUSH
48622: NOP4
48626: PUSH
48627: LD_INT 1
48629: ARRAY
48630: PUSH
48631: LD_INT 1
48633: ARRAY
48634: PUSH
48635: LD_STRING r
48637: EQUAL
48638: PUSH
48639: NOP4
48643: PUSH
48644: LD_INT 1
48646: ARRAY
48647: PUSH
48648: LD_INT 4
48650: ARRAY
48651: PUSH
48652: NOP4
48656: EQUAL
48657: AND
48658: ST_TO_ADDR
// end ;
48659: LD_VAR 0 3
48663: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
48664: LD_INT 0
48666: PPUSH
// SetDir ( unit , d ) ;
48667: NOP4
48671: PPUSH
48672: NOP4
48676: PPUSH
48677: NOP4
// PlaceUnitXY ( unit , x , y , mode ) ;
48681: NOP4
48685: PPUSH
48686: NOP4
48690: PPUSH
48691: NOP4
48695: PPUSH
48696: NOP4
48700: PPUSH
48701: NOP4
// end ;
48705: LD_VAR 0 6
48709: RET
// export function ToNaturalNumber ( number ) ; begin
48710: LD_INT 0
48712: PPUSH
// result := number div 1 ;
48713: NOP4
48717: PUSH
48718: NOP4
48722: PUSH
48723: LD_INT 1
48725: DIV
48726: ST_TO_ADDR
// if number < 0 then
48727: NOP4
48731: PUSH
48732: LD_INT 0
48734: LESS
48735: IFFALSE 48745
// result := 0 ;
48737: NOP4
48741: PUSH
48742: LD_INT 0
48744: ST_TO_ADDR
// end ;
48745: LD_VAR 0 2
48749: RET
// export function SortByClass ( units , class ) ; var un ; begin
48750: LD_INT 0
48752: PPUSH
48753: PPUSH
// if not units or not class then
48754: NOP4
48758: NOT
48759: PUSH
48760: NOP4
48764: NOT
48765: OR
48766: IFFALSE 48770
// exit ;
48768: GO 48865
// result := [ ] ;
48770: NOP4
48774: PUSH
48775: EMPTY
48776: ST_TO_ADDR
// for un in units do
48777: NOP4
48781: PUSH
48782: NOP4
48786: PUSH
48787: FOR_IN
48788: IFFALSE 48863
// if GetClass ( un ) = class then
48790: NOP4
48794: PPUSH
48795: NOP4
48799: PUSH
48800: NOP4
48804: EQUAL
48805: IFFALSE 48832
// result := Insert ( result , 1 , un ) else
48807: NOP4
48811: PUSH
48812: NOP4
48816: PPUSH
48817: LD_INT 1
48819: PPUSH
48820: NOP4
48824: PPUSH
48825: NOP4
48829: ST_TO_ADDR
48830: GO 48861
// result := Replace ( result , result + 1 , un ) ;
48832: NOP4
48836: PUSH
48837: NOP4
48841: PPUSH
48842: NOP4
48846: PUSH
48847: LD_INT 1
48849: PLUS
48850: PPUSH
48851: NOP4
48855: PPUSH
48856: NOP4
48860: ST_TO_ADDR
48861: GO 48787
48863: POP
48864: POP
// end ;
48865: LD_VAR 0 3
48869: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
48870: LD_INT 0
48872: PPUSH
48873: PPUSH
48874: PPUSH
48875: PPUSH
48876: PPUSH
48877: PPUSH
48878: PPUSH
// result := [ ] ;
48879: NOP4
48883: PUSH
48884: EMPTY
48885: ST_TO_ADDR
// if x - r < 0 then
48886: NOP4
48890: PUSH
48891: NOP4
48895: MINUS
48896: PUSH
48897: LD_INT 0
48899: LESS
48900: IFFALSE 48912
// min_x := 0 else
48902: NOP4
48906: PUSH
48907: LD_INT 0
48909: ST_TO_ADDR
48910: GO 48928
// min_x := x - r ;
48912: NOP4
48916: PUSH
48917: NOP4
48921: PUSH
48922: NOP4
48926: MINUS
48927: ST_TO_ADDR
// if y - r < 0 then
48928: NOP4
48932: PUSH
48933: NOP4
48937: MINUS
48938: PUSH
48939: LD_INT 0
48941: LESS
48942: IFFALSE 48954
// min_y := 0 else
48944: NOP4
48948: PUSH
48949: LD_INT 0
48951: ST_TO_ADDR
48952: GO 48970
// min_y := y - r ;
48954: NOP4
48958: PUSH
48959: NOP4
48963: PUSH
48964: NOP4
48968: MINUS
48969: ST_TO_ADDR
// max_x := x + r ;
48970: NOP4
48974: PUSH
48975: NOP4
48979: PUSH
48980: NOP4
48984: PLUS
48985: ST_TO_ADDR
// max_y := y + r ;
48986: NOP4
48990: PUSH
48991: NOP4
48995: PUSH
48996: NOP4
49000: PLUS
49001: ST_TO_ADDR
// for _x = min_x to max_x do
49002: NOP4
49006: PUSH
49007: DOUBLE
49008: NOP4
49012: DEC
49013: ST_TO_ADDR
49014: NOP4
49018: PUSH
49019: FOR_TO
49020: IFFALSE 49121
// for _y = min_y to max_y do
49022: NOP4
49026: PUSH
49027: DOUBLE
49028: NOP4
49032: DEC
49033: ST_TO_ADDR
49034: NOP4
49038: PUSH
49039: FOR_TO
49040: IFFALSE 49117
// begin if not ValidHex ( _x , _y ) then
49042: NOP4
49046: PPUSH
49047: NOP4
49051: PPUSH
49052: NOP4
49056: NOT
49057: IFFALSE 49061
// continue ;
49059: GO 49039
// if GetResourceTypeXY ( _x , _y ) then
49061: NOP4
49065: PPUSH
49066: NOP4
49070: PPUSH
49071: NOP4
49075: IFFALSE 49115
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
49077: NOP4
49081: PUSH
49082: NOP4
49086: PPUSH
49087: NOP4
49091: PUSH
49092: LD_INT 1
49094: PLUS
49095: PPUSH
49096: NOP4
49100: PUSH
49101: NOP4
49105: PUSH
49106: EMPTY
49107: LIST
49108: LIST
49109: PPUSH
49110: NOP4
49114: ST_TO_ADDR
// end ;
49115: GO 49039
49117: POP
49118: POP
49119: GO 49019
49121: POP
49122: POP
// end ;
49123: LD_VAR 0 4
49127: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
49128: LD_INT 0
49130: PPUSH
49131: PPUSH
49132: PPUSH
49133: PPUSH
49134: PPUSH
49135: PPUSH
49136: PPUSH
49137: PPUSH
// if not units then
49138: NOP4
49142: NOT
49143: IFFALSE 49147
// exit ;
49145: GO 49572
// result := UnitFilter ( units , [ f_ok ] ) ;
49147: NOP4
49151: PUSH
49152: NOP4
49156: PPUSH
49157: LD_INT 50
49159: PUSH
49160: EMPTY
49161: LIST
49162: PPUSH
49163: NOP4
49167: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49168: NOP4
49172: PUSH
49173: NOP4
49177: PUSH
49178: LD_INT 1
49180: ARRAY
49181: PPUSH
49182: NOP4
49186: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
49187: NOP4
49191: PUSH
49192: LD_INT 29
49194: PUSH
49195: NOP4
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: ST_TO_ADDR
// if not result then
49204: NOP4
49208: NOT
49209: IFFALSE 49213
// exit ;
49211: GO 49572
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
49213: NOP4
49217: PUSH
49218: LD_INT 81
49220: PUSH
49221: NOP4
49225: PUSH
49226: EMPTY
49227: LIST
49228: LIST
49229: PPUSH
49230: NOP4
49234: ST_TO_ADDR
// for i in result do
49235: NOP4
49239: PUSH
49240: NOP4
49244: PUSH
49245: FOR_IN
49246: IFFALSE 49570
// begin tag := GetTag ( i ) + 1 ;
49248: NOP4
49252: PUSH
49253: NOP4
49257: PPUSH
49258: NOP4
49262: PUSH
49263: LD_INT 1
49265: PLUS
49266: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
49267: NOP4
49271: PUSH
49272: NOP4
49276: PPUSH
49277: NOP4
49281: PPUSH
49282: NOP4
49286: PPUSH
49287: NOP4
49291: PPUSH
49292: LD_INT 6
49294: PPUSH
49295: NOP4
49299: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
49300: NOP4
49304: PUSH
49305: NOP4
49309: PPUSH
49310: NOP4
49314: PUSH
49315: NOP4
49319: IN
49320: NOT
49321: AND
49322: IFFALSE 49361
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
49324: NOP4
49328: PPUSH
49329: NOP4
49333: PUSH
49334: LD_INT 1
49336: ARRAY
49337: PUSH
49338: LD_INT 1
49340: ARRAY
49341: PPUSH
49342: NOP4
49346: PUSH
49347: LD_INT 1
49349: ARRAY
49350: PUSH
49351: LD_INT 2
49353: ARRAY
49354: PPUSH
49355: NOP4
49359: GO 49568
// if path > tag then
49361: NOP4
49365: PUSH
49366: NOP4
49370: GREATER
49371: IFFALSE 49538
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
49373: NOP4
49377: PUSH
49378: NOP4
49382: PPUSH
49383: LD_INT 91
49385: PUSH
49386: NOP4
49390: PUSH
49391: LD_INT 12
49393: PUSH
49394: EMPTY
49395: LIST
49396: LIST
49397: LIST
49398: PPUSH
49399: NOP4
49403: ST_TO_ADDR
// if nearEnemy then
49404: NOP4
49408: IFFALSE 49436
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
49410: NOP4
49414: PPUSH
49415: NOP4
49419: PPUSH
49420: NOP4
49424: PPUSH
49425: NOP4
49429: PPUSH
49430: NOP4
49434: GO 49536
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
49436: NOP4
49440: PPUSH
49441: NOP4
49445: PUSH
49446: NOP4
49450: ARRAY
49451: PUSH
49452: LD_INT 1
49454: ARRAY
49455: PPUSH
49456: NOP4
49460: PUSH
49461: NOP4
49465: ARRAY
49466: PUSH
49467: LD_INT 2
49469: ARRAY
49470: PPUSH
49471: NOP4
49475: PUSH
49476: LD_INT 6
49478: GREATER
49479: IFFALSE 49522
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
49481: NOP4
49485: PPUSH
49486: NOP4
49490: PUSH
49491: NOP4
49495: ARRAY
49496: PUSH
49497: LD_INT 1
49499: ARRAY
49500: PPUSH
49501: NOP4
49505: PUSH
49506: NOP4
49510: ARRAY
49511: PUSH
49512: LD_INT 2
49514: ARRAY
49515: PPUSH
49516: NOP4
49520: GO 49536
// SetTag ( i , tag ) ;
49522: NOP4
49526: PPUSH
49527: NOP4
49531: PPUSH
49532: NOP4
// end else
49536: GO 49568
// if enemy then
49538: NOP4
49542: IFFALSE 49568
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
49544: NOP4
49548: PPUSH
49549: NOP4
49553: PPUSH
49554: NOP4
49558: PPUSH
49559: NOP4
49563: PPUSH
49564: NOP4
// end ;
49568: GO 49245
49570: POP
49571: POP
// end ;
49572: LD_VAR 0 3
49576: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
49577: LD_INT 0
49579: PPUSH
49580: PPUSH
49581: PPUSH
// if not unit or IsInUnit ( unit ) then
49582: NOP4
49586: NOT
49587: PUSH
49588: NOP4
49592: PPUSH
49593: NOP4
49597: OR
49598: IFFALSE 49602
// exit ;
49600: GO 49693
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
49602: NOP4
49606: PUSH
49607: NOP4
49611: PPUSH
49612: NOP4
49616: PPUSH
49617: NOP4
49621: PPUSH
49622: LD_INT 1
49624: PPUSH
49625: NOP4
49629: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
49630: NOP4
49634: PUSH
49635: NOP4
49639: PPUSH
49640: NOP4
49644: PPUSH
49645: NOP4
49649: PPUSH
49650: LD_INT 1
49652: PPUSH
49653: NOP4
49657: ST_TO_ADDR
// if ValidHex ( x , y ) then
49658: NOP4
49662: PPUSH
49663: NOP4
49667: PPUSH
49668: NOP4
49672: IFFALSE 49693
// ComTurnXY ( unit , x , y ) ;
49674: NOP4
49678: PPUSH
49679: NOP4
49683: PPUSH
49684: NOP4
49688: PPUSH
49689: NOP4
// end ;
49693: LD_VAR 0 3
49697: RET
// export function SeeUnits ( side , units ) ; var i ; begin
49698: LD_INT 0
49700: PPUSH
49701: PPUSH
// result := false ;
49702: NOP4
49706: PUSH
49707: LD_INT 0
49709: ST_TO_ADDR
// if not units then
49710: NOP4
49714: NOT
49715: IFFALSE 49719
// exit ;
49717: GO 49764
// for i in units do
49719: NOP4
49723: PUSH
49724: NOP4
49728: PUSH
49729: FOR_IN
49730: IFFALSE 49762
// if See ( side , i ) then
49732: NOP4
49736: PPUSH
49737: NOP4
49741: PPUSH
49742: NOP4
49746: IFFALSE 49760
// begin result := true ;
49748: NOP4
49752: PUSH
49753: LD_INT 1
49755: ST_TO_ADDR
// exit ;
49756: POP
49757: POP
49758: GO 49764
// end ;
49760: GO 49729
49762: POP
49763: POP
// end ;
49764: LD_VAR 0 3
49768: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
49769: LD_INT 0
49771: PPUSH
49772: PPUSH
49773: PPUSH
49774: PPUSH
// if not unit or not points then
49775: NOP4
49779: NOT
49780: PUSH
49781: NOP4
49785: NOT
49786: OR
49787: IFFALSE 49791
// exit ;
49789: GO 49881
// dist := 99999 ;
49791: NOP4
49795: PUSH
49796: LD_INT 99999
49798: ST_TO_ADDR
// for i in points do
49799: NOP4
49803: PUSH
49804: NOP4
49808: PUSH
49809: FOR_IN
49810: IFFALSE 49879
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
49812: NOP4
49816: PUSH
49817: NOP4
49821: PPUSH
49822: NOP4
49826: PUSH
49827: LD_INT 1
49829: ARRAY
49830: PPUSH
49831: NOP4
49835: PUSH
49836: LD_INT 2
49838: ARRAY
49839: PPUSH
49840: NOP4
49844: ST_TO_ADDR
// if tmpDist < dist then
49845: NOP4
49849: PUSH
49850: NOP4
49854: LESS
49855: IFFALSE 49877
// begin result := i ;
49857: NOP4
49861: PUSH
49862: NOP4
49866: ST_TO_ADDR
// dist := tmpDist ;
49867: NOP4
49871: PUSH
49872: NOP4
49876: ST_TO_ADDR
// end ; end ;
49877: GO 49809
49879: POP
49880: POP
// end ;
49881: LD_VAR 0 3
49885: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
49886: LD_INT 0
49888: PPUSH
// uc_side := side ;
49889: LD_ADDR_OWVAR 20
49893: PUSH
49894: NOP4
49898: ST_TO_ADDR
// uc_nation := 3 ;
49899: LD_ADDR_OWVAR 21
49903: PUSH
49904: LD_INT 3
49906: ST_TO_ADDR
// vc_chassis := 25 ;
49907: LD_ADDR_OWVAR 37
49911: PUSH
49912: LD_INT 25
49914: ST_TO_ADDR
// vc_engine := engine_siberite ;
49915: LD_ADDR_OWVAR 39
49919: PUSH
49920: LD_INT 3
49922: ST_TO_ADDR
// vc_control := control_computer ;
49923: LD_ADDR_OWVAR 38
49927: PUSH
49928: LD_INT 3
49930: ST_TO_ADDR
// vc_weapon := 59 ;
49931: LD_ADDR_OWVAR 40
49935: PUSH
49936: LD_INT 59
49938: ST_TO_ADDR
// result := CreateVehicle ;
49939: NOP4
49943: PUSH
49944: NOP4
49948: ST_TO_ADDR
// SetDir ( result , d ) ;
49949: NOP4
49953: PPUSH
49954: NOP4
49958: PPUSH
49959: NOP4
// PlaceUnitXY ( result , x , y , false ) ;
49963: NOP4
49967: PPUSH
49968: NOP4
49972: PPUSH
49973: NOP4
49977: PPUSH
49978: LD_INT 0
49980: PPUSH
49981: NOP4
// end ; end_of_file
49985: LD_VAR 0 5
49989: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
49990: LD_INT 0
49992: PPUSH
49993: PPUSH
// skirmish := false ;
49994: NOP4
49998: PUSH
49999: LD_INT 0
50001: ST_TO_ADDR
// debug_mc := false ;
50002: NOP4
50006: PUSH
50007: LD_INT 0
50009: ST_TO_ADDR
// mc_bases := [ ] ;
50010: NOP4
50014: PUSH
50015: EMPTY
50016: ST_TO_ADDR
// mc_sides := [ ] ;
50017: NOP4
50021: PUSH
50022: EMPTY
50023: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50024: NOP4
50028: PUSH
50029: EMPTY
50030: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50031: NOP4
50035: PUSH
50036: EMPTY
50037: ST_TO_ADDR
// mc_need_heal := [ ] ;
50038: NOP4
50042: PUSH
50043: EMPTY
50044: ST_TO_ADDR
// mc_healers := [ ] ;
50045: NOP4
50049: PUSH
50050: EMPTY
50051: ST_TO_ADDR
// mc_build_list := [ ] ;
50052: NOP4
50056: PUSH
50057: EMPTY
50058: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50059: NOP4
50063: PUSH
50064: EMPTY
50065: ST_TO_ADDR
// mc_builders := [ ] ;
50066: NOP4
50070: PUSH
50071: EMPTY
50072: ST_TO_ADDR
// mc_construct_list := [ ] ;
50073: NOP4
50077: PUSH
50078: EMPTY
50079: ST_TO_ADDR
// mc_turret_list := [ ] ;
50080: NOP4
50084: PUSH
50085: EMPTY
50086: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50087: NOP4
50091: PUSH
50092: EMPTY
50093: ST_TO_ADDR
// mc_miners := [ ] ;
50094: NOP4
50098: PUSH
50099: EMPTY
50100: ST_TO_ADDR
// mc_mines := [ ] ;
50101: NOP4
50105: PUSH
50106: EMPTY
50107: ST_TO_ADDR
// mc_minefields := [ ] ;
50108: NOP4
50112: PUSH
50113: EMPTY
50114: ST_TO_ADDR
// mc_crates := [ ] ;
50115: NOP4
50119: PUSH
50120: EMPTY
50121: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50122: NOP4
50126: PUSH
50127: EMPTY
50128: ST_TO_ADDR
// mc_crates_area := [ ] ;
50129: NOP4
50133: PUSH
50134: EMPTY
50135: ST_TO_ADDR
// mc_vehicles := [ ] ;
50136: NOP4
50140: PUSH
50141: EMPTY
50142: ST_TO_ADDR
// mc_attack := [ ] ;
50143: NOP4
50147: PUSH
50148: EMPTY
50149: ST_TO_ADDR
// mc_produce := [ ] ;
50150: NOP4
50154: PUSH
50155: EMPTY
50156: ST_TO_ADDR
// mc_defender := [ ] ;
50157: NOP4
50161: PUSH
50162: EMPTY
50163: ST_TO_ADDR
// mc_parking := [ ] ;
50164: NOP4
50168: PUSH
50169: EMPTY
50170: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50171: NOP4
50175: PUSH
50176: EMPTY
50177: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50178: NOP4
50182: PUSH
50183: EMPTY
50184: ST_TO_ADDR
// mc_scan := [ ] ;
50185: NOP4
50189: PUSH
50190: EMPTY
50191: ST_TO_ADDR
// mc_scan_area := [ ] ;
50192: NOP4
50196: PUSH
50197: EMPTY
50198: ST_TO_ADDR
// mc_tech := [ ] ;
50199: NOP4
50203: PUSH
50204: EMPTY
50205: ST_TO_ADDR
// mc_class := [ ] ;
50206: NOP4
50210: PUSH
50211: EMPTY
50212: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50213: NOP4
50217: PUSH
50218: EMPTY
50219: ST_TO_ADDR
// mc_is_defending := [ ] ;
50220: NOP4
50224: PUSH
50225: EMPTY
50226: ST_TO_ADDR
// end ;
50227: LD_VAR 0 1
50231: RET
// export function MC_Kill ( base ) ; begin
50232: LD_INT 0
50234: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50235: NOP4
50239: PUSH
50240: NOP4
50244: PPUSH
50245: NOP4
50249: PPUSH
50250: EMPTY
50251: PPUSH
50252: NOP4
50256: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50257: NOP4
50261: PUSH
50262: NOP4
50266: PPUSH
50267: NOP4
50271: PPUSH
50272: EMPTY
50273: PPUSH
50274: NOP4
50278: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50279: NOP4
50283: PUSH
50284: NOP4
50288: PPUSH
50289: NOP4
50293: PPUSH
50294: EMPTY
50295: PPUSH
50296: NOP4
50300: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50301: NOP4
50305: PUSH
50306: NOP4
50310: PPUSH
50311: NOP4
50315: PPUSH
50316: EMPTY
50317: PPUSH
50318: NOP4
50322: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50323: NOP4
50327: PUSH
50328: NOP4
50332: PPUSH
50333: NOP4
50337: PPUSH
50338: EMPTY
50339: PPUSH
50340: NOP4
50344: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50345: NOP4
50349: PUSH
50350: NOP4
50354: PPUSH
50355: NOP4
50359: PPUSH
50360: EMPTY
50361: PPUSH
50362: NOP4
50366: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50367: NOP4
50371: PUSH
50372: NOP4
50376: PPUSH
50377: NOP4
50381: PPUSH
50382: EMPTY
50383: PPUSH
50384: NOP4
50388: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50389: NOP4
50393: PUSH
50394: NOP4
50398: PPUSH
50399: NOP4
50403: PPUSH
50404: EMPTY
50405: PPUSH
50406: NOP4
50410: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50411: NOP4
50415: PUSH
50416: NOP4
50420: PPUSH
50421: NOP4
50425: PPUSH
50426: EMPTY
50427: PPUSH
50428: NOP4
50432: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50433: NOP4
50437: PUSH
50438: NOP4
50442: PPUSH
50443: NOP4
50447: PPUSH
50448: EMPTY
50449: PPUSH
50450: NOP4
50454: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50455: NOP4
50459: PUSH
50460: NOP4
50464: PPUSH
50465: NOP4
50469: PPUSH
50470: EMPTY
50471: PPUSH
50472: NOP4
50476: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
50477: NOP4
50481: PUSH
50482: NOP4
50486: PPUSH
50487: NOP4
50491: PPUSH
50492: LD_INT 0
50494: PPUSH
50495: NOP4
50499: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50500: NOP4
50504: PUSH
50505: NOP4
50509: PPUSH
50510: NOP4
50514: PPUSH
50515: EMPTY
50516: PPUSH
50517: NOP4
50521: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50522: NOP4
50526: PUSH
50527: NOP4
50531: PPUSH
50532: NOP4
50536: PPUSH
50537: EMPTY
50538: PPUSH
50539: NOP4
50543: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
50544: NOP4
50548: PUSH
50549: NOP4
50553: PPUSH
50554: NOP4
50558: PPUSH
50559: EMPTY
50560: PPUSH
50561: NOP4
50565: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
50566: NOP4
50570: PUSH
50571: NOP4
50575: PPUSH
50576: NOP4
50580: PPUSH
50581: EMPTY
50582: PPUSH
50583: NOP4
50587: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
50588: NOP4
50592: PUSH
50593: NOP4
50597: PPUSH
50598: NOP4
50602: PPUSH
50603: EMPTY
50604: PPUSH
50605: NOP4
50609: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
50610: NOP4
50614: PUSH
50615: NOP4
50619: PPUSH
50620: NOP4
50624: PPUSH
50625: EMPTY
50626: PPUSH
50627: NOP4
50631: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
50632: NOP4
50636: PUSH
50637: NOP4
50641: PPUSH
50642: NOP4
50646: PPUSH
50647: EMPTY
50648: PPUSH
50649: NOP4
50653: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
50654: NOP4
50658: PUSH
50659: NOP4
50663: PPUSH
50664: NOP4
50668: PPUSH
50669: EMPTY
50670: PPUSH
50671: NOP4
50675: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
50676: NOP4
50680: PUSH
50681: NOP4
50685: PPUSH
50686: NOP4
50690: PPUSH
50691: EMPTY
50692: PPUSH
50693: NOP4
50697: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
50698: NOP4
50702: PUSH
50703: NOP4
50707: PPUSH
50708: NOP4
50712: PPUSH
50713: EMPTY
50714: PPUSH
50715: NOP4
50719: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
50720: NOP4
50724: PUSH
50725: NOP4
50729: PPUSH
50730: NOP4
50734: PPUSH
50735: EMPTY
50736: PPUSH
50737: NOP4
50741: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
50742: NOP4
50746: PUSH
50747: NOP4
50751: PPUSH
50752: NOP4
50756: PPUSH
50757: EMPTY
50758: PPUSH
50759: NOP4
50763: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
50764: NOP4
50768: PUSH
50769: NOP4
50773: PPUSH
50774: NOP4
50778: PPUSH
50779: EMPTY
50780: PPUSH
50781: NOP4
50785: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
50786: NOP4
50790: PUSH
50791: NOP4
50795: PPUSH
50796: NOP4
50800: PPUSH
50801: EMPTY
50802: PPUSH
50803: NOP4
50807: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
50808: NOP4
50812: PUSH
50813: NOP4
50817: PPUSH
50818: NOP4
50822: PPUSH
50823: EMPTY
50824: PPUSH
50825: NOP4
50829: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
50830: NOP4
50834: PUSH
50835: NOP4
50839: PPUSH
50840: NOP4
50844: PPUSH
50845: EMPTY
50846: PPUSH
50847: NOP4
50851: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
50852: NOP4
50856: PUSH
50857: NOP4
50861: PPUSH
50862: NOP4
50866: PPUSH
50867: EMPTY
50868: PPUSH
50869: NOP4
50873: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
50874: NOP4
50878: PUSH
50879: NOP4
50883: PPUSH
50884: NOP4
50888: PPUSH
50889: EMPTY
50890: PPUSH
50891: NOP4
50895: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
50896: NOP4
50900: PUSH
50901: NOP4
50905: PPUSH
50906: NOP4
50910: PPUSH
50911: EMPTY
50912: PPUSH
50913: NOP4
50917: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
50918: NOP4
50922: PUSH
50923: NOP4
50927: PPUSH
50928: NOP4
50932: PPUSH
50933: EMPTY
50934: PPUSH
50935: NOP4
50939: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
50940: NOP4
50944: PUSH
50945: NOP4
50949: PPUSH
50950: NOP4
50954: PPUSH
50955: EMPTY
50956: PPUSH
50957: NOP4
50961: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
50962: NOP4
50966: PUSH
50967: NOP4
50971: PPUSH
50972: NOP4
50976: PPUSH
50977: EMPTY
50978: PPUSH
50979: NOP4
50983: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
50984: NOP4
50988: PUSH
50989: NOP4
50993: PPUSH
50994: NOP4
50998: PPUSH
50999: EMPTY
51000: PPUSH
51001: NOP4
51005: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51006: NOP4
51010: PUSH
51011: NOP4
51015: PPUSH
51016: NOP4
51020: PPUSH
51021: EMPTY
51022: PPUSH
51023: NOP4
51027: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51028: NOP4
51032: PUSH
51033: NOP4
51037: PPUSH
51038: NOP4
51042: PPUSH
51043: EMPTY
51044: PPUSH
51045: NOP4
51049: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51050: NOP4
51054: PUSH
51055: NOP4
51059: PPUSH
51060: NOP4
51064: PPUSH
51065: EMPTY
51066: PPUSH
51067: NOP4
51071: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51072: NOP4
51076: PUSH
51077: NOP4
51081: PPUSH
51082: NOP4
51086: PPUSH
51087: EMPTY
51088: PPUSH
51089: NOP4
51093: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51094: NOP4
51098: PUSH
51099: NOP4
51103: PPUSH
51104: NOP4
51108: PPUSH
51109: EMPTY
51110: PPUSH
51111: NOP4
51115: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51116: NOP4
51120: PUSH
51121: NOP4
51125: PPUSH
51126: NOP4
51130: PPUSH
51131: LD_INT 0
51133: PPUSH
51134: NOP4
51138: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
51139: NOP4
51143: PUSH
51144: NOP4
51148: PPUSH
51149: NOP4
51153: PPUSH
51154: LD_INT 0
51156: PPUSH
51157: NOP4
51161: ST_TO_ADDR
// end ;
51162: LD_VAR 0 2
51166: RET
// export function MC_Add ( side , units ) ; var base ; begin
51167: LD_INT 0
51169: PPUSH
51170: PPUSH
// base := mc_bases + 1 ;
51171: NOP4
51175: PUSH
51176: NOP4
51180: PUSH
51181: LD_INT 1
51183: PLUS
51184: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51185: NOP4
51189: PUSH
51190: NOP4
51194: PPUSH
51195: NOP4
51199: PPUSH
51200: NOP4
51204: PPUSH
51205: NOP4
51209: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51210: NOP4
51214: PUSH
51215: NOP4
51219: PPUSH
51220: NOP4
51224: PPUSH
51225: NOP4
51229: PPUSH
51230: NOP4
51234: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51235: NOP4
51239: PUSH
51240: NOP4
51244: PPUSH
51245: NOP4
51249: PPUSH
51250: EMPTY
51251: PPUSH
51252: NOP4
51256: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51257: NOP4
51261: PUSH
51262: NOP4
51266: PPUSH
51267: NOP4
51271: PPUSH
51272: EMPTY
51273: PPUSH
51274: NOP4
51278: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51279: NOP4
51283: PUSH
51284: NOP4
51288: PPUSH
51289: NOP4
51293: PPUSH
51294: EMPTY
51295: PPUSH
51296: NOP4
51300: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51301: NOP4
51305: PUSH
51306: NOP4
51310: PPUSH
51311: NOP4
51315: PPUSH
51316: EMPTY
51317: PPUSH
51318: NOP4
51322: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51323: NOP4
51327: PUSH
51328: NOP4
51332: PPUSH
51333: NOP4
51337: PPUSH
51338: EMPTY
51339: PPUSH
51340: NOP4
51344: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51345: NOP4
51349: PUSH
51350: NOP4
51354: PPUSH
51355: NOP4
51359: PPUSH
51360: EMPTY
51361: PPUSH
51362: NOP4
51366: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51367: NOP4
51371: PUSH
51372: NOP4
51376: PPUSH
51377: NOP4
51381: PPUSH
51382: EMPTY
51383: PPUSH
51384: NOP4
51388: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51389: NOP4
51393: PUSH
51394: NOP4
51398: PPUSH
51399: NOP4
51403: PPUSH
51404: EMPTY
51405: PPUSH
51406: NOP4
51410: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51411: NOP4
51415: PUSH
51416: NOP4
51420: PPUSH
51421: NOP4
51425: PPUSH
51426: EMPTY
51427: PPUSH
51428: NOP4
51432: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51433: NOP4
51437: PUSH
51438: NOP4
51442: PPUSH
51443: NOP4
51447: PPUSH
51448: EMPTY
51449: PPUSH
51450: NOP4
51454: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51455: NOP4
51459: PUSH
51460: NOP4
51464: PPUSH
51465: NOP4
51469: PPUSH
51470: LD_INT 0
51472: PPUSH
51473: NOP4
51477: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51478: NOP4
51482: PUSH
51483: NOP4
51487: PPUSH
51488: NOP4
51492: PPUSH
51493: EMPTY
51494: PPUSH
51495: NOP4
51499: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51500: NOP4
51504: PUSH
51505: NOP4
51509: PPUSH
51510: NOP4
51514: PPUSH
51515: EMPTY
51516: PPUSH
51517: NOP4
51521: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51522: NOP4
51526: PUSH
51527: NOP4
51531: PPUSH
51532: NOP4
51536: PPUSH
51537: EMPTY
51538: PPUSH
51539: NOP4
51543: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51544: NOP4
51548: PUSH
51549: NOP4
51553: PPUSH
51554: NOP4
51558: PPUSH
51559: EMPTY
51560: PPUSH
51561: NOP4
51565: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51566: NOP4
51570: PUSH
51571: NOP4
51575: PPUSH
51576: NOP4
51580: PPUSH
51581: EMPTY
51582: PPUSH
51583: NOP4
51587: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51588: NOP4
51592: PUSH
51593: NOP4
51597: PPUSH
51598: NOP4
51602: PPUSH
51603: EMPTY
51604: PPUSH
51605: NOP4
51609: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51610: NOP4
51614: PUSH
51615: NOP4
51619: PPUSH
51620: NOP4
51624: PPUSH
51625: EMPTY
51626: PPUSH
51627: NOP4
51631: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51632: NOP4
51636: PUSH
51637: NOP4
51641: PPUSH
51642: NOP4
51646: PPUSH
51647: EMPTY
51648: PPUSH
51649: NOP4
51653: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51654: NOP4
51658: PUSH
51659: NOP4
51663: PPUSH
51664: NOP4
51668: PPUSH
51669: EMPTY
51670: PPUSH
51671: NOP4
51675: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51676: NOP4
51680: PUSH
51681: NOP4
51685: PPUSH
51686: NOP4
51690: PPUSH
51691: EMPTY
51692: PPUSH
51693: NOP4
51697: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51698: NOP4
51702: PUSH
51703: NOP4
51707: PPUSH
51708: NOP4
51712: PPUSH
51713: EMPTY
51714: PPUSH
51715: NOP4
51719: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51720: NOP4
51724: PUSH
51725: NOP4
51729: PPUSH
51730: NOP4
51734: PPUSH
51735: EMPTY
51736: PPUSH
51737: NOP4
51741: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51742: NOP4
51746: PUSH
51747: NOP4
51751: PPUSH
51752: NOP4
51756: PPUSH
51757: EMPTY
51758: PPUSH
51759: NOP4
51763: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51764: NOP4
51768: PUSH
51769: NOP4
51773: PPUSH
51774: NOP4
51778: PPUSH
51779: EMPTY
51780: PPUSH
51781: NOP4
51785: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51786: NOP4
51790: PUSH
51791: NOP4
51795: PPUSH
51796: NOP4
51800: PPUSH
51801: EMPTY
51802: PPUSH
51803: NOP4
51807: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51808: NOP4
51812: PUSH
51813: NOP4
51817: PPUSH
51818: NOP4
51822: PPUSH
51823: EMPTY
51824: PPUSH
51825: NOP4
51829: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51830: NOP4
51834: PUSH
51835: NOP4
51839: PPUSH
51840: NOP4
51844: PPUSH
51845: EMPTY
51846: PPUSH
51847: NOP4
51851: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51852: NOP4
51856: PUSH
51857: NOP4
51861: PPUSH
51862: NOP4
51866: PPUSH
51867: EMPTY
51868: PPUSH
51869: NOP4
51873: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51874: NOP4
51878: PUSH
51879: NOP4
51883: PPUSH
51884: NOP4
51888: PPUSH
51889: EMPTY
51890: PPUSH
51891: NOP4
51895: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51896: NOP4
51900: PUSH
51901: NOP4
51905: PPUSH
51906: NOP4
51910: PPUSH
51911: EMPTY
51912: PPUSH
51913: NOP4
51917: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51918: NOP4
51922: PUSH
51923: NOP4
51927: PPUSH
51928: NOP4
51932: PPUSH
51933: EMPTY
51934: PPUSH
51935: NOP4
51939: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51940: NOP4
51944: PUSH
51945: NOP4
51949: PPUSH
51950: NOP4
51954: PPUSH
51955: EMPTY
51956: PPUSH
51957: NOP4
51961: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51962: NOP4
51966: PUSH
51967: NOP4
51971: PPUSH
51972: NOP4
51976: PPUSH
51977: EMPTY
51978: PPUSH
51979: NOP4
51983: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51984: NOP4
51988: PUSH
51989: NOP4
51993: PPUSH
51994: NOP4
51998: PPUSH
51999: EMPTY
52000: PPUSH
52001: NOP4
52005: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52006: NOP4
52010: PUSH
52011: NOP4
52015: PPUSH
52016: NOP4
52020: PPUSH
52021: EMPTY
52022: PPUSH
52023: NOP4
52027: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52028: NOP4
52032: PUSH
52033: NOP4
52037: PPUSH
52038: NOP4
52042: PPUSH
52043: EMPTY
52044: PPUSH
52045: NOP4
52049: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52050: NOP4
52054: PUSH
52055: NOP4
52059: PPUSH
52060: NOP4
52064: PPUSH
52065: EMPTY
52066: PPUSH
52067: NOP4
52071: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52072: NOP4
52076: PUSH
52077: NOP4
52081: PPUSH
52082: NOP4
52086: PPUSH
52087: EMPTY
52088: PPUSH
52089: NOP4
52093: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52094: NOP4
52098: PUSH
52099: NOP4
52103: PPUSH
52104: NOP4
52108: PPUSH
52109: LD_INT 0
52111: PPUSH
52112: NOP4
52116: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52117: NOP4
52121: PUSH
52122: NOP4
52126: PPUSH
52127: NOP4
52131: PPUSH
52132: LD_INT 0
52134: PPUSH
52135: NOP4
52139: ST_TO_ADDR
// result := base ;
52140: NOP4
52144: PUSH
52145: NOP4
52149: ST_TO_ADDR
// end ;
52150: LD_VAR 0 3
52154: RET
// export function MC_Start ( ) ; var i ; begin
52155: LD_INT 0
52157: PPUSH
52158: PPUSH
// for i = 1 to mc_bases do
52159: NOP4
52163: PUSH
52164: DOUBLE
52165: LD_INT 1
52167: DEC
52168: ST_TO_ADDR
52169: NOP4
52173: PUSH
52174: FOR_TO
52175: IFFALSE 53275
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52177: NOP4
52181: PUSH
52182: NOP4
52186: PPUSH
52187: NOP4
52191: PPUSH
52192: NOP4
52196: PUSH
52197: NOP4
52201: ARRAY
52202: PUSH
52203: LD_INT 0
52205: DIFF
52206: PPUSH
52207: NOP4
52211: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52212: NOP4
52216: PUSH
52217: NOP4
52221: PPUSH
52222: NOP4
52226: PPUSH
52227: EMPTY
52228: PPUSH
52229: NOP4
52233: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52234: NOP4
52238: PUSH
52239: NOP4
52243: PPUSH
52244: NOP4
52248: PPUSH
52249: EMPTY
52250: PPUSH
52251: NOP4
52255: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52256: NOP4
52260: PUSH
52261: NOP4
52265: PPUSH
52266: NOP4
52270: PPUSH
52271: EMPTY
52272: PPUSH
52273: NOP4
52277: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52278: NOP4
52282: PUSH
52283: NOP4
52287: PPUSH
52288: NOP4
52292: PPUSH
52293: EMPTY
52294: PUSH
52295: EMPTY
52296: PUSH
52297: EMPTY
52298: LIST
52299: LIST
52300: PPUSH
52301: NOP4
52305: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52306: NOP4
52310: PUSH
52311: NOP4
52315: PPUSH
52316: NOP4
52320: PPUSH
52321: EMPTY
52322: PPUSH
52323: NOP4
52327: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52328: NOP4
52332: PUSH
52333: NOP4
52337: PPUSH
52338: NOP4
52342: PPUSH
52343: EMPTY
52344: PPUSH
52345: NOP4
52349: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52350: NOP4
52354: PUSH
52355: NOP4
52359: PPUSH
52360: NOP4
52364: PPUSH
52365: EMPTY
52366: PPUSH
52367: NOP4
52371: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52372: NOP4
52376: PUSH
52377: NOP4
52381: PPUSH
52382: NOP4
52386: PPUSH
52387: EMPTY
52388: PPUSH
52389: NOP4
52393: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
52394: NOP4
52398: PUSH
52399: NOP4
52403: PPUSH
52404: NOP4
52408: PPUSH
52409: NOP4
52413: PUSH
52414: NOP4
52418: ARRAY
52419: PPUSH
52420: LD_INT 2
52422: PUSH
52423: LD_INT 30
52425: PUSH
52426: LD_INT 32
52428: PUSH
52429: EMPTY
52430: LIST
52431: LIST
52432: PUSH
52433: LD_INT 30
52435: PUSH
52436: LD_INT 33
52438: PUSH
52439: EMPTY
52440: LIST
52441: LIST
52442: PUSH
52443: EMPTY
52444: LIST
52445: LIST
52446: LIST
52447: PPUSH
52448: NOP4
52452: PPUSH
52453: NOP4
52457: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
52458: NOP4
52462: PUSH
52463: NOP4
52467: PPUSH
52468: NOP4
52472: PPUSH
52473: NOP4
52477: PUSH
52478: NOP4
52482: ARRAY
52483: PPUSH
52484: LD_INT 2
52486: PUSH
52487: LD_INT 30
52489: PUSH
52490: LD_INT 32
52492: PUSH
52493: EMPTY
52494: LIST
52495: LIST
52496: PUSH
52497: LD_INT 30
52499: PUSH
52500: LD_INT 31
52502: PUSH
52503: EMPTY
52504: LIST
52505: LIST
52506: PUSH
52507: EMPTY
52508: LIST
52509: LIST
52510: LIST
52511: PUSH
52512: LD_INT 58
52514: PUSH
52515: EMPTY
52516: LIST
52517: PUSH
52518: EMPTY
52519: LIST
52520: LIST
52521: PPUSH
52522: NOP4
52526: PPUSH
52527: NOP4
52531: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
52532: NOP4
52536: PUSH
52537: NOP4
52541: PPUSH
52542: NOP4
52546: PPUSH
52547: EMPTY
52548: PPUSH
52549: NOP4
52553: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
52554: NOP4
52558: PUSH
52559: NOP4
52563: PPUSH
52564: NOP4
52568: PPUSH
52569: EMPTY
52570: PPUSH
52571: NOP4
52575: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
52576: NOP4
52580: PUSH
52581: NOP4
52585: PPUSH
52586: NOP4
52590: PPUSH
52591: EMPTY
52592: PPUSH
52593: NOP4
52597: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
52598: NOP4
52602: PUSH
52603: NOP4
52607: PPUSH
52608: NOP4
52612: PPUSH
52613: EMPTY
52614: PPUSH
52615: NOP4
52619: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
52620: NOP4
52624: PUSH
52625: NOP4
52629: PPUSH
52630: NOP4
52634: PPUSH
52635: EMPTY
52636: PPUSH
52637: NOP4
52641: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52642: NOP4
52646: PUSH
52647: NOP4
52651: PPUSH
52652: NOP4
52656: PPUSH
52657: EMPTY
52658: PPUSH
52659: NOP4
52663: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
52664: NOP4
52668: PUSH
52669: NOP4
52673: PPUSH
52674: NOP4
52678: PPUSH
52679: EMPTY
52680: PPUSH
52681: NOP4
52685: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
52686: NOP4
52690: PUSH
52691: NOP4
52695: PPUSH
52696: NOP4
52700: PPUSH
52701: EMPTY
52702: PPUSH
52703: NOP4
52707: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52708: NOP4
52712: PUSH
52713: NOP4
52717: PPUSH
52718: NOP4
52722: PPUSH
52723: EMPTY
52724: PPUSH
52725: NOP4
52729: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
52730: NOP4
52734: PUSH
52735: NOP4
52739: PPUSH
52740: NOP4
52744: PPUSH
52745: EMPTY
52746: PPUSH
52747: NOP4
52751: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
52752: NOP4
52756: PUSH
52757: NOP4
52761: PPUSH
52762: NOP4
52766: PPUSH
52767: EMPTY
52768: PPUSH
52769: NOP4
52773: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
52774: NOP4
52778: PUSH
52779: NOP4
52783: PPUSH
52784: NOP4
52788: PPUSH
52789: LD_INT 0
52791: PPUSH
52792: NOP4
52796: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
52797: NOP4
52801: PUSH
52802: NOP4
52806: PPUSH
52807: NOP4
52811: PPUSH
52812: LD_INT 0
52814: PPUSH
52815: NOP4
52819: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52820: NOP4
52824: PUSH
52825: NOP4
52829: PPUSH
52830: NOP4
52834: PPUSH
52835: EMPTY
52836: PPUSH
52837: NOP4
52841: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
52842: NOP4
52846: PUSH
52847: NOP4
52851: PPUSH
52852: NOP4
52856: PPUSH
52857: LD_INT 0
52859: PPUSH
52860: NOP4
52864: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
52865: NOP4
52869: PUSH
52870: NOP4
52874: PPUSH
52875: NOP4
52879: PPUSH
52880: EMPTY
52881: PPUSH
52882: NOP4
52886: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
52887: NOP4
52891: PUSH
52892: NOP4
52896: PPUSH
52897: NOP4
52901: PPUSH
52902: LD_INT 0
52904: PPUSH
52905: NOP4
52909: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
52910: NOP4
52914: PUSH
52915: NOP4
52919: PPUSH
52920: NOP4
52924: PPUSH
52925: EMPTY
52926: PPUSH
52927: NOP4
52931: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
52932: NOP4
52936: PUSH
52937: NOP4
52941: PPUSH
52942: NOP4
52946: PPUSH
52947: EMPTY
52948: PPUSH
52949: NOP4
52953: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52954: NOP4
52958: PUSH
52959: NOP4
52963: PPUSH
52964: NOP4
52968: PPUSH
52969: EMPTY
52970: PPUSH
52971: NOP4
52975: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
52976: NOP4
52980: PUSH
52981: NOP4
52985: PPUSH
52986: NOP4
52990: PPUSH
52991: NOP4
52995: PUSH
52996: NOP4
53000: ARRAY
53001: PPUSH
53002: LD_INT 2
53004: PUSH
53005: LD_INT 30
53007: PUSH
53008: LD_INT 6
53010: PUSH
53011: EMPTY
53012: LIST
53013: LIST
53014: PUSH
53015: LD_INT 30
53017: PUSH
53018: LD_INT 7
53020: PUSH
53021: EMPTY
53022: LIST
53023: LIST
53024: PUSH
53025: LD_INT 30
53027: PUSH
53028: LD_INT 8
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: LIST
53039: LIST
53040: PPUSH
53041: NOP4
53045: PPUSH
53046: NOP4
53050: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53051: NOP4
53055: PUSH
53056: NOP4
53060: PPUSH
53061: NOP4
53065: PPUSH
53066: EMPTY
53067: PPUSH
53068: NOP4
53072: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53073: NOP4
53077: PUSH
53078: NOP4
53082: PPUSH
53083: NOP4
53087: PPUSH
53088: EMPTY
53089: PPUSH
53090: NOP4
53094: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53095: NOP4
53099: PUSH
53100: NOP4
53104: PPUSH
53105: NOP4
53109: PPUSH
53110: EMPTY
53111: PPUSH
53112: NOP4
53116: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53117: NOP4
53121: PUSH
53122: NOP4
53126: PPUSH
53127: NOP4
53131: PPUSH
53132: EMPTY
53133: PPUSH
53134: NOP4
53138: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53139: NOP4
53143: PUSH
53144: NOP4
53148: PPUSH
53149: NOP4
53153: PPUSH
53154: EMPTY
53155: PPUSH
53156: NOP4
53160: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53161: NOP4
53165: PUSH
53166: NOP4
53170: PPUSH
53171: NOP4
53175: PPUSH
53176: EMPTY
53177: PPUSH
53178: NOP4
53182: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53183: NOP4
53187: PUSH
53188: NOP4
53192: PPUSH
53193: NOP4
53197: PPUSH
53198: EMPTY
53199: PPUSH
53200: NOP4
53204: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53205: NOP4
53209: PUSH
53210: NOP4
53214: PPUSH
53215: NOP4
53219: PPUSH
53220: EMPTY
53221: PPUSH
53222: NOP4
53226: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53227: NOP4
53231: PUSH
53232: NOP4
53236: PPUSH
53237: NOP4
53241: PPUSH
53242: LD_INT 0
53244: PPUSH
53245: NOP4
53249: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
53250: NOP4
53254: PUSH
53255: NOP4
53259: PPUSH
53260: NOP4
53264: PPUSH
53265: LD_INT 0
53267: PPUSH
53268: NOP4
53272: ST_TO_ADDR
// end ;
53273: GO 52174
53275: POP
53276: POP
// MC_InitSides ( ) ;
53277: NOP4
// MC_InitResearch ( ) ;
53281: NOP4
// CustomInitMacro ( ) ;
53285: NOP4
// skirmish := true ;
53289: NOP4
53293: PUSH
53294: LD_INT 1
53296: ST_TO_ADDR
// end ;
53297: LD_VAR 0 1
53301: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53302: LD_INT 0
53304: PPUSH
53305: PPUSH
53306: PPUSH
53307: PPUSH
53308: PPUSH
53309: PPUSH
// if not mc_bases then
53310: NOP4
53314: NOT
53315: IFFALSE 53319
// exit ;
53317: GO 53558
// for i = 1 to 8 do
53319: NOP4
53323: PUSH
53324: DOUBLE
53325: LD_INT 1
53327: DEC
53328: ST_TO_ADDR
53329: LD_INT 8
53331: PUSH
53332: FOR_TO
53333: IFFALSE 53359
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53335: NOP4
53339: PUSH
53340: NOP4
53344: PPUSH
53345: NOP4
53349: PPUSH
53350: EMPTY
53351: PPUSH
53352: NOP4
53356: ST_TO_ADDR
53357: GO 53332
53359: POP
53360: POP
// tmp := [ ] ;
53361: NOP4
53365: PUSH
53366: EMPTY
53367: ST_TO_ADDR
// for i = 1 to mc_sides do
53368: NOP4
53372: PUSH
53373: DOUBLE
53374: LD_INT 1
53376: DEC
53377: ST_TO_ADDR
53378: NOP4
53382: PUSH
53383: FOR_TO
53384: IFFALSE 53442
// if not mc_sides [ i ] in tmp then
53386: NOP4
53390: PUSH
53391: NOP4
53395: ARRAY
53396: PUSH
53397: NOP4
53401: IN
53402: NOT
53403: IFFALSE 53440
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53405: NOP4
53409: PUSH
53410: NOP4
53414: PPUSH
53415: NOP4
53419: PUSH
53420: LD_INT 1
53422: PLUS
53423: PPUSH
53424: NOP4
53428: PUSH
53429: NOP4
53433: ARRAY
53434: PPUSH
53435: NOP4
53439: ST_TO_ADDR
53440: GO 53383
53442: POP
53443: POP
// if not tmp then
53444: NOP4
53448: NOT
53449: IFFALSE 53453
// exit ;
53451: GO 53558
// for j in tmp do
53453: NOP4
53457: PUSH
53458: NOP4
53462: PUSH
53463: FOR_IN
53464: IFFALSE 53556
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
53466: NOP4
53470: PUSH
53471: LD_INT 22
53473: PUSH
53474: NOP4
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: PPUSH
53483: NOP4
53487: ST_TO_ADDR
// if not un then
53488: NOP4
53492: NOT
53493: IFFALSE 53497
// continue ;
53495: GO 53463
// nation := GetNation ( un [ 1 ] ) ;
53497: NOP4
53501: PUSH
53502: NOP4
53506: PUSH
53507: LD_INT 1
53509: ARRAY
53510: PPUSH
53511: NOP4
53515: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
53516: NOP4
53520: PUSH
53521: NOP4
53525: PPUSH
53526: NOP4
53530: PPUSH
53531: NOP4
53535: PPUSH
53536: NOP4
53540: PPUSH
53541: LD_INT 1
53543: PPUSH
53544: NOP4
53548: PPUSH
53549: NOP4
53553: ST_TO_ADDR
// end ;
53554: GO 53463
53556: POP
53557: POP
// end ;
53558: LD_VAR 0 1
53562: RET
// export function MC_InitSides ( ) ; var i ; begin
53563: LD_INT 0
53565: PPUSH
53566: PPUSH
// if not mc_bases then
53567: NOP4
53571: NOT
53572: IFFALSE 53576
// exit ;
53574: GO 53650
// for i = 1 to mc_bases do
53576: NOP4
53580: PUSH
53581: DOUBLE
53582: LD_INT 1
53584: DEC
53585: ST_TO_ADDR
53586: NOP4
53590: PUSH
53591: FOR_TO
53592: IFFALSE 53648
// if mc_bases [ i ] then
53594: NOP4
53598: PUSH
53599: NOP4
53603: ARRAY
53604: IFFALSE 53646
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
53606: NOP4
53610: PUSH
53611: NOP4
53615: PPUSH
53616: NOP4
53620: PPUSH
53621: NOP4
53625: PUSH
53626: NOP4
53630: ARRAY
53631: PUSH
53632: LD_INT 1
53634: ARRAY
53635: PPUSH
53636: NOP4
53640: PPUSH
53641: NOP4
53645: ST_TO_ADDR
53646: GO 53591
53648: POP
53649: POP
// end ;
53650: LD_VAR 0 1
53654: RET
// every 0 0$03 trigger skirmish do
53655: NOP4
53659: IFFALSE 53813
53661: GO 53663
53663: DISABLE
// begin enable ;
53664: ENABLE
// MC_CheckBuildings ( ) ;
53665: NOP4
// MC_CheckPeopleLife ( ) ;
53669: NOP4
// RaiseSailEvent ( 100 ) ;
53673: LD_INT 100
53675: PPUSH
53676: NOP4
// RaiseSailEvent ( 103 ) ;
53680: LD_INT 103
53682: PPUSH
53683: NOP4
// RaiseSailEvent ( 104 ) ;
53687: LD_INT 104
53689: PPUSH
53690: NOP4
// RaiseSailEvent ( 105 ) ;
53694: LD_INT 105
53696: PPUSH
53697: NOP4
// RaiseSailEvent ( 106 ) ;
53701: LD_INT 106
53703: PPUSH
53704: NOP4
// RaiseSailEvent ( 107 ) ;
53708: LD_INT 107
53710: PPUSH
53711: NOP4
// RaiseSailEvent ( 108 ) ;
53715: LD_INT 108
53717: PPUSH
53718: NOP4
// RaiseSailEvent ( 109 ) ;
53722: LD_INT 109
53724: PPUSH
53725: NOP4
// RaiseSailEvent ( 110 ) ;
53729: LD_INT 110
53731: PPUSH
53732: NOP4
// RaiseSailEvent ( 111 ) ;
53736: LD_INT 111
53738: PPUSH
53739: NOP4
// RaiseSailEvent ( 112 ) ;
53743: LD_INT 112
53745: PPUSH
53746: NOP4
// RaiseSailEvent ( 113 ) ;
53750: LD_INT 113
53752: PPUSH
53753: NOP4
// RaiseSailEvent ( 120 ) ;
53757: LD_INT 120
53759: PPUSH
53760: NOP4
// RaiseSailEvent ( 121 ) ;
53764: LD_INT 121
53766: PPUSH
53767: NOP4
// RaiseSailEvent ( 122 ) ;
53771: LD_INT 122
53773: PPUSH
53774: NOP4
// RaiseSailEvent ( 123 ) ;
53778: LD_INT 123
53780: PPUSH
53781: NOP4
// RaiseSailEvent ( 124 ) ;
53785: LD_INT 124
53787: PPUSH
53788: NOP4
// RaiseSailEvent ( 125 ) ;
53792: LD_INT 125
53794: PPUSH
53795: NOP4
// RaiseSailEvent ( 126 ) ;
53799: LD_INT 126
53801: PPUSH
53802: NOP4
// RaiseSailEvent ( 200 ) ;
53806: LD_INT 200
53808: PPUSH
53809: NOP4
// end ;
53813: END
// on SailEvent ( event ) do begin if event < 100 then
53814: NOP4
53818: PUSH
53819: LD_INT 100
53821: LESS
53822: IFFALSE 53833
// CustomEvent ( event ) ;
53824: NOP4
53828: PPUSH
53829: NOP4
// if event = 100 then
53833: NOP4
53837: PUSH
53838: LD_INT 100
53840: EQUAL
53841: IFFALSE 53847
// MC_ClassManager ( ) ;
53843: NOP4
// if event = 101 then
53847: NOP4
53851: PUSH
53852: LD_INT 101
53854: EQUAL
53855: IFFALSE 53861
// MC_RepairBuildings ( ) ;
53857: NOP4
// if event = 102 then
53861: NOP4
53865: PUSH
53866: LD_INT 102
53868: EQUAL
53869: IFFALSE 53875
// MC_Heal ( ) ;
53871: NOP4
// if event = 103 then
53875: NOP4
53879: PUSH
53880: LD_INT 103
53882: EQUAL
53883: IFFALSE 53889
// MC_Build ( ) ;
53885: NOP4
// if event = 104 then
53889: NOP4
53893: PUSH
53894: LD_INT 104
53896: EQUAL
53897: IFFALSE 53903
// MC_TurretWeapon ( ) ;
53899: NOP4
// if event = 105 then
53903: NOP4
53907: PUSH
53908: LD_INT 105
53910: EQUAL
53911: IFFALSE 53917
// MC_BuildUpgrade ( ) ;
53913: NOP4
// if event = 106 then
53917: NOP4
53921: PUSH
53922: LD_INT 106
53924: EQUAL
53925: IFFALSE 53931
// MC_PlantMines ( ) ;
53927: NOP4
// if event = 107 then
53931: NOP4
53935: PUSH
53936: LD_INT 107
53938: EQUAL
53939: IFFALSE 53945
// MC_CollectCrates ( ) ;
53941: NOP4
// if event = 108 then
53945: NOP4
53949: PUSH
53950: LD_INT 108
53952: EQUAL
53953: IFFALSE 53959
// MC_LinkRemoteControl ( ) ;
53955: NOP4
// if event = 109 then
53959: NOP4
53963: PUSH
53964: LD_INT 109
53966: EQUAL
53967: IFFALSE 53973
// MC_ProduceVehicle ( ) ;
53969: NOP4
// if event = 110 then
53973: NOP4
53977: PUSH
53978: LD_INT 110
53980: EQUAL
53981: IFFALSE 53987
// MC_SendAttack ( ) ;
53983: NOP4
// if event = 111 then
53987: NOP4
53991: PUSH
53992: LD_INT 111
53994: EQUAL
53995: IFFALSE 54001
// MC_Defend ( ) ;
53997: NOP4
// if event = 112 then
54001: NOP4
54005: PUSH
54006: LD_INT 112
54008: EQUAL
54009: IFFALSE 54015
// MC_Research ( ) ;
54011: NOP4
// if event = 113 then
54015: NOP4
54019: PUSH
54020: LD_INT 113
54022: EQUAL
54023: IFFALSE 54029
// MC_MinesTrigger ( ) ;
54025: NOP4
// if event = 120 then
54029: NOP4
54033: PUSH
54034: LD_INT 120
54036: EQUAL
54037: IFFALSE 54043
// MC_RepairVehicle ( ) ;
54039: NOP4
// if event = 121 then
54043: NOP4
54047: PUSH
54048: LD_INT 121
54050: EQUAL
54051: IFFALSE 54057
// MC_TameApe ( ) ;
54053: NOP4
// if event = 122 then
54057: NOP4
54061: PUSH
54062: LD_INT 122
54064: EQUAL
54065: IFFALSE 54071
// MC_ChangeApeClass ( ) ;
54067: NOP4
// if event = 123 then
54071: NOP4
54075: PUSH
54076: LD_INT 123
54078: EQUAL
54079: IFFALSE 54085
// MC_Bazooka ( ) ;
54081: NOP4
// if event = 124 then
54085: NOP4
54089: PUSH
54090: LD_INT 124
54092: EQUAL
54093: IFFALSE 54099
// MC_TeleportExit ( ) ;
54095: NOP4
// if event = 125 then
54099: NOP4
54103: PUSH
54104: LD_INT 125
54106: EQUAL
54107: IFFALSE 54113
// MC_Deposits ( ) ;
54109: NOP4
// if event = 126 then
54113: NOP4
54117: PUSH
54118: LD_INT 126
54120: EQUAL
54121: IFFALSE 54127
// MC_RemoteDriver ( ) ;
54123: NOP4
// if event = 200 then
54127: NOP4
54131: PUSH
54132: LD_INT 200
54134: EQUAL
54135: IFFALSE 54141
// MC_Idle ( ) ;
54137: NOP4
// end ;
54141: PPOPN 1
54143: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54144: LD_INT 0
54146: PPUSH
54147: PPUSH
// if not mc_bases [ base ] or not tag then
54148: NOP4
54152: PUSH
54153: NOP4
54157: ARRAY
54158: NOT
54159: PUSH
54160: NOP4
54164: NOT
54165: OR
54166: IFFALSE 54170
// exit ;
54168: GO 54234
// for i in mc_bases [ base ] union mc_ape [ base ] do
54170: NOP4
54174: PUSH
54175: NOP4
54179: PUSH
54180: NOP4
54184: ARRAY
54185: PUSH
54186: NOP4
54190: PUSH
54191: NOP4
54195: ARRAY
54196: UNION
54197: PUSH
54198: FOR_IN
54199: IFFALSE 54232
// if GetTag ( i ) = tag then
54201: NOP4
54205: PPUSH
54206: NOP4
54210: PUSH
54211: NOP4
54215: EQUAL
54216: IFFALSE 54230
// SetTag ( i , 0 ) ;
54218: NOP4
54222: PPUSH
54223: LD_INT 0
54225: PPUSH
54226: NOP4
54230: GO 54198
54232: POP
54233: POP
// end ;
54234: LD_VAR 0 3
54238: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54239: LD_INT 0
54241: PPUSH
54242: PPUSH
54243: PPUSH
54244: PPUSH
54245: PPUSH
54246: PPUSH
54247: PPUSH
54248: PPUSH
// if not mc_bases then
54249: NOP4
54253: NOT
54254: IFFALSE 54258
// exit ;
54256: GO 54716
// for i = 1 to mc_bases do
54258: NOP4
54262: PUSH
54263: DOUBLE
54264: LD_INT 1
54266: DEC
54267: ST_TO_ADDR
54268: NOP4
54272: PUSH
54273: FOR_TO
54274: IFFALSE 54714
// begin tmp := MC_ClassCheckReq ( i ) ;
54276: NOP4
54280: PUSH
54281: NOP4
54285: PPUSH
54286: NOP4
54290: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54291: NOP4
54295: PUSH
54296: NOP4
54300: PPUSH
54301: NOP4
54305: PPUSH
54306: NOP4
54310: PPUSH
54311: NOP4
54315: ST_TO_ADDR
// if not tmp then
54316: NOP4
54320: NOT
54321: IFFALSE 54325
// continue ;
54323: GO 54273
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54325: NOP4
54329: PUSH
54330: NOP4
54334: PUSH
54335: NOP4
54339: ARRAY
54340: PPUSH
54341: LD_INT 2
54343: PUSH
54344: LD_INT 30
54346: PUSH
54347: LD_INT 4
54349: PUSH
54350: EMPTY
54351: LIST
54352: LIST
54353: PUSH
54354: LD_INT 30
54356: PUSH
54357: LD_INT 5
54359: PUSH
54360: EMPTY
54361: LIST
54362: LIST
54363: PUSH
54364: EMPTY
54365: LIST
54366: LIST
54367: LIST
54368: PPUSH
54369: NOP4
54373: PUSH
54374: NOP4
54378: PUSH
54379: NOP4
54383: ARRAY
54384: PPUSH
54385: LD_INT 2
54387: PUSH
54388: LD_INT 30
54390: PUSH
54391: LD_INT 0
54393: PUSH
54394: EMPTY
54395: LIST
54396: LIST
54397: PUSH
54398: LD_INT 30
54400: PUSH
54401: LD_INT 1
54403: PUSH
54404: EMPTY
54405: LIST
54406: LIST
54407: PUSH
54408: EMPTY
54409: LIST
54410: LIST
54411: LIST
54412: PPUSH
54413: NOP4
54417: PUSH
54418: NOP4
54422: PUSH
54423: NOP4
54427: ARRAY
54428: PPUSH
54429: LD_INT 30
54431: PUSH
54432: LD_INT 3
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: PPUSH
54439: NOP4
54443: PUSH
54444: NOP4
54448: PUSH
54449: NOP4
54453: ARRAY
54454: PPUSH
54455: LD_INT 2
54457: PUSH
54458: LD_INT 30
54460: PUSH
54461: LD_INT 6
54463: PUSH
54464: EMPTY
54465: LIST
54466: LIST
54467: PUSH
54468: LD_INT 30
54470: PUSH
54471: LD_INT 7
54473: PUSH
54474: EMPTY
54475: LIST
54476: LIST
54477: PUSH
54478: LD_INT 30
54480: PUSH
54481: LD_INT 8
54483: PUSH
54484: EMPTY
54485: LIST
54486: LIST
54487: PUSH
54488: EMPTY
54489: LIST
54490: LIST
54491: LIST
54492: LIST
54493: PPUSH
54494: NOP4
54498: PUSH
54499: EMPTY
54500: LIST
54501: LIST
54502: LIST
54503: LIST
54504: ST_TO_ADDR
// for j = 1 to 4 do
54505: NOP4
54509: PUSH
54510: DOUBLE
54511: LD_INT 1
54513: DEC
54514: ST_TO_ADDR
54515: LD_INT 4
54517: PUSH
54518: FOR_TO
54519: IFFALSE 54710
// begin if not tmp [ j ] then
54521: NOP4
54525: PUSH
54526: NOP4
54530: ARRAY
54531: NOT
54532: IFFALSE 54536
// continue ;
54534: GO 54518
// for p in tmp [ j ] do
54536: NOP4
54540: PUSH
54541: NOP4
54545: PUSH
54546: NOP4
54550: ARRAY
54551: PUSH
54552: FOR_IN
54553: IFFALSE 54706
// begin if not b [ j ] then
54555: NOP4
54559: PUSH
54560: NOP4
54564: ARRAY
54565: NOT
54566: IFFALSE 54570
// break ;
54568: GO 54706
// e := 0 ;
54570: NOP4
54574: PUSH
54575: LD_INT 0
54577: ST_TO_ADDR
// for k in b [ j ] do
54578: NOP4
54582: PUSH
54583: NOP4
54587: PUSH
54588: NOP4
54592: ARRAY
54593: PUSH
54594: FOR_IN
54595: IFFALSE 54622
// if IsNotFull ( k ) then
54597: NOP4
54601: PPUSH
54602: NOP4
54606: IFFALSE 54620
// begin e := k ;
54608: NOP4
54612: PUSH
54613: NOP4
54617: ST_TO_ADDR
// break ;
54618: GO 54622
// end ;
54620: GO 54594
54622: POP
54623: POP
// if e and not UnitGoingToBuilding ( p , e ) then
54624: NOP4
54628: PUSH
54629: NOP4
54633: PPUSH
54634: NOP4
54638: PPUSH
54639: NOP4
54643: NOT
54644: AND
54645: IFFALSE 54704
// begin if IsInUnit ( p ) then
54647: NOP4
54651: PPUSH
54652: NOP4
54656: IFFALSE 54667
// ComExitBuilding ( p ) ;
54658: NOP4
54662: PPUSH
54663: NOP4
// ComEnterUnit ( p , e ) ;
54667: NOP4
54671: PPUSH
54672: NOP4
54676: PPUSH
54677: NOP4
// AddComChangeProfession ( p , j ) ;
54681: NOP4
54685: PPUSH
54686: NOP4
54690: PPUSH
54691: NOP4
// AddComExitBuilding ( p ) ;
54695: NOP4
54699: PPUSH
54700: NOP4
// end ; end ;
54704: GO 54552
54706: POP
54707: POP
// end ;
54708: GO 54518
54710: POP
54711: POP
// end ;
54712: GO 54273
54714: POP
54715: POP
// end ;
54716: LD_VAR 0 1
54720: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
54721: LD_INT 0
54723: PPUSH
54724: PPUSH
54725: PPUSH
54726: PPUSH
54727: PPUSH
54728: PPUSH
54729: PPUSH
54730: PPUSH
54731: PPUSH
54732: PPUSH
54733: PPUSH
54734: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54735: NOP4
54739: NOT
54740: PUSH
54741: NOP4
54745: PUSH
54746: NOP4
54750: ARRAY
54751: NOT
54752: OR
54753: PUSH
54754: NOP4
54758: PUSH
54759: NOP4
54763: ARRAY
54764: PPUSH
54765: LD_INT 2
54767: PUSH
54768: LD_INT 30
54770: PUSH
54771: LD_INT 0
54773: PUSH
54774: EMPTY
54775: LIST
54776: LIST
54777: PUSH
54778: LD_INT 30
54780: PUSH
54781: LD_INT 1
54783: PUSH
54784: EMPTY
54785: LIST
54786: LIST
54787: PUSH
54788: EMPTY
54789: LIST
54790: LIST
54791: LIST
54792: PPUSH
54793: NOP4
54797: NOT
54798: OR
54799: IFFALSE 54803
// exit ;
54801: GO 58306
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54803: NOP4
54807: PUSH
54808: NOP4
54812: PUSH
54813: NOP4
54817: ARRAY
54818: PPUSH
54819: LD_INT 2
54821: PUSH
54822: LD_INT 25
54824: PUSH
54825: LD_INT 1
54827: PUSH
54828: EMPTY
54829: LIST
54830: LIST
54831: PUSH
54832: LD_INT 25
54834: PUSH
54835: LD_INT 2
54837: PUSH
54838: EMPTY
54839: LIST
54840: LIST
54841: PUSH
54842: LD_INT 25
54844: PUSH
54845: LD_INT 3
54847: PUSH
54848: EMPTY
54849: LIST
54850: LIST
54851: PUSH
54852: LD_INT 25
54854: PUSH
54855: LD_INT 4
54857: PUSH
54858: EMPTY
54859: LIST
54860: LIST
54861: PUSH
54862: LD_INT 25
54864: PUSH
54865: LD_INT 5
54867: PUSH
54868: EMPTY
54869: LIST
54870: LIST
54871: PUSH
54872: LD_INT 25
54874: PUSH
54875: LD_INT 8
54877: PUSH
54878: EMPTY
54879: LIST
54880: LIST
54881: PUSH
54882: LD_INT 25
54884: PUSH
54885: LD_INT 9
54887: PUSH
54888: EMPTY
54889: LIST
54890: LIST
54891: PUSH
54892: EMPTY
54893: LIST
54894: LIST
54895: LIST
54896: LIST
54897: LIST
54898: LIST
54899: LIST
54900: LIST
54901: PPUSH
54902: NOP4
54906: ST_TO_ADDR
// if not tmp then
54907: NOP4
54911: NOT
54912: IFFALSE 54916
// exit ;
54914: GO 58306
// for i in tmp do
54916: NOP4
54920: PUSH
54921: NOP4
54925: PUSH
54926: FOR_IN
54927: IFFALSE 54958
// if GetTag ( i ) then
54929: NOP4
54933: PPUSH
54934: NOP4
54938: IFFALSE 54956
// tmp := tmp diff i ;
54940: NOP4
54944: PUSH
54945: NOP4
54949: PUSH
54950: NOP4
54954: DIFF
54955: ST_TO_ADDR
54956: GO 54926
54958: POP
54959: POP
// if not tmp then
54960: NOP4
54964: NOT
54965: IFFALSE 54969
// exit ;
54967: GO 58306
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54969: NOP4
54973: PUSH
54974: NOP4
54978: PUSH
54979: NOP4
54983: ARRAY
54984: PPUSH
54985: LD_INT 2
54987: PUSH
54988: LD_INT 25
54990: PUSH
54991: LD_INT 1
54993: PUSH
54994: EMPTY
54995: LIST
54996: LIST
54997: PUSH
54998: LD_INT 25
55000: PUSH
55001: LD_INT 5
55003: PUSH
55004: EMPTY
55005: LIST
55006: LIST
55007: PUSH
55008: LD_INT 25
55010: PUSH
55011: LD_INT 8
55013: PUSH
55014: EMPTY
55015: LIST
55016: LIST
55017: PUSH
55018: LD_INT 25
55020: PUSH
55021: LD_INT 9
55023: PUSH
55024: EMPTY
55025: LIST
55026: LIST
55027: PUSH
55028: EMPTY
55029: LIST
55030: LIST
55031: LIST
55032: LIST
55033: LIST
55034: PPUSH
55035: NOP4
55039: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55040: NOP4
55044: PUSH
55045: NOP4
55049: PUSH
55050: NOP4
55054: ARRAY
55055: PPUSH
55056: LD_INT 25
55058: PUSH
55059: LD_INT 2
55061: PUSH
55062: EMPTY
55063: LIST
55064: LIST
55065: PPUSH
55066: NOP4
55070: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55071: NOP4
55075: PUSH
55076: NOP4
55080: PUSH
55081: NOP4
55085: ARRAY
55086: PPUSH
55087: LD_INT 25
55089: PUSH
55090: LD_INT 3
55092: PUSH
55093: EMPTY
55094: LIST
55095: LIST
55096: PPUSH
55097: NOP4
55101: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55102: NOP4
55106: PUSH
55107: NOP4
55111: PUSH
55112: NOP4
55116: ARRAY
55117: PPUSH
55118: LD_INT 25
55120: PUSH
55121: LD_INT 4
55123: PUSH
55124: EMPTY
55125: LIST
55126: LIST
55127: PUSH
55128: LD_INT 24
55130: PUSH
55131: LD_INT 251
55133: PUSH
55134: EMPTY
55135: LIST
55136: LIST
55137: PUSH
55138: EMPTY
55139: LIST
55140: LIST
55141: PPUSH
55142: NOP4
55146: ST_TO_ADDR
// if mc_is_defending [ base ] then
55147: NOP4
55151: PUSH
55152: NOP4
55156: ARRAY
55157: IFFALSE 55618
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55159: NOP4
55163: PUSH
55164: NOP4
55168: PPUSH
55169: NOP4
55173: PPUSH
55174: LD_INT 4
55176: PPUSH
55177: NOP4
55181: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55182: NOP4
55186: PUSH
55187: NOP4
55191: PUSH
55192: NOP4
55196: ARRAY
55197: PPUSH
55198: LD_INT 2
55200: PUSH
55201: LD_INT 30
55203: PUSH
55204: LD_INT 4
55206: PUSH
55207: EMPTY
55208: LIST
55209: LIST
55210: PUSH
55211: LD_INT 30
55213: PUSH
55214: LD_INT 5
55216: PUSH
55217: EMPTY
55218: LIST
55219: LIST
55220: PUSH
55221: EMPTY
55222: LIST
55223: LIST
55224: LIST
55225: PPUSH
55226: NOP4
55230: ST_TO_ADDR
// if not b then
55231: NOP4
55235: NOT
55236: IFFALSE 55240
// exit ;
55238: GO 58306
// p := [ ] ;
55240: NOP4
55244: PUSH
55245: EMPTY
55246: ST_TO_ADDR
// if sci >= 2 then
55247: NOP4
55251: PUSH
55252: LD_INT 2
55254: GREATEREQUAL
55255: IFFALSE 55286
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55257: NOP4
55261: PUSH
55262: NOP4
55266: PUSH
55267: LD_INT 1
55269: ARRAY
55270: PUSH
55271: NOP4
55275: PUSH
55276: LD_INT 2
55278: ARRAY
55279: PUSH
55280: EMPTY
55281: LIST
55282: LIST
55283: ST_TO_ADDR
55284: GO 55347
// if sci = 1 then
55286: NOP4
55290: PUSH
55291: LD_INT 1
55293: EQUAL
55294: IFFALSE 55315
// sci := [ sci [ 1 ] ] else
55296: NOP4
55300: PUSH
55301: NOP4
55305: PUSH
55306: LD_INT 1
55308: ARRAY
55309: PUSH
55310: EMPTY
55311: LIST
55312: ST_TO_ADDR
55313: GO 55347
// if sci = 0 then
55315: NOP4
55319: PUSH
55320: LD_INT 0
55322: EQUAL
55323: IFFALSE 55347
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55325: NOP4
55329: PUSH
55330: NOP4
55334: PPUSH
55335: LD_INT 4
55337: PPUSH
55338: NOP4
55342: PUSH
55343: LD_INT 1
55345: ARRAY
55346: ST_TO_ADDR
// if eng > 4 then
55347: NOP4
55351: PUSH
55352: LD_INT 4
55354: GREATER
55355: IFFALSE 55401
// for i = eng downto 4 do
55357: NOP4
55361: PUSH
55362: DOUBLE
55363: NOP4
55367: INC
55368: ST_TO_ADDR
55369: LD_INT 4
55371: PUSH
55372: FOR_DOWNTO
55373: IFFALSE 55399
// eng := eng diff eng [ i ] ;
55375: NOP4
55379: PUSH
55380: NOP4
55384: PUSH
55385: NOP4
55389: PUSH
55390: NOP4
55394: ARRAY
55395: DIFF
55396: ST_TO_ADDR
55397: GO 55372
55399: POP
55400: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55401: NOP4
55405: PUSH
55406: NOP4
55410: PUSH
55411: NOP4
55415: PUSH
55416: NOP4
55420: UNION
55421: PUSH
55422: NOP4
55426: UNION
55427: PUSH
55428: NOP4
55432: UNION
55433: DIFF
55434: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
55435: NOP4
55439: PUSH
55440: NOP4
55444: PUSH
55445: NOP4
55449: ARRAY
55450: PPUSH
55451: LD_INT 2
55453: PUSH
55454: LD_INT 30
55456: PUSH
55457: LD_INT 32
55459: PUSH
55460: EMPTY
55461: LIST
55462: LIST
55463: PUSH
55464: LD_INT 30
55466: PUSH
55467: LD_INT 31
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: PUSH
55474: EMPTY
55475: LIST
55476: LIST
55477: LIST
55478: PPUSH
55479: NOP4
55483: PUSH
55484: NOP4
55488: PUSH
55489: NOP4
55493: ARRAY
55494: PPUSH
55495: LD_INT 2
55497: PUSH
55498: LD_INT 30
55500: PUSH
55501: LD_INT 4
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: PUSH
55508: LD_INT 30
55510: PUSH
55511: LD_INT 5
55513: PUSH
55514: EMPTY
55515: LIST
55516: LIST
55517: PUSH
55518: EMPTY
55519: LIST
55520: LIST
55521: LIST
55522: PPUSH
55523: NOP4
55527: PUSH
55528: LD_INT 6
55530: MUL
55531: PLUS
55532: ST_TO_ADDR
// if bcount < tmp then
55533: NOP4
55537: PUSH
55538: NOP4
55542: LESS
55543: IFFALSE 55589
// for i = tmp downto bcount do
55545: NOP4
55549: PUSH
55550: DOUBLE
55551: NOP4
55555: INC
55556: ST_TO_ADDR
55557: NOP4
55561: PUSH
55562: FOR_DOWNTO
55563: IFFALSE 55587
// tmp := Delete ( tmp , tmp ) ;
55565: NOP4
55569: PUSH
55570: NOP4
55574: PPUSH
55575: NOP4
55579: PPUSH
55580: NOP4
55584: ST_TO_ADDR
55585: GO 55562
55587: POP
55588: POP
// result := [ tmp , 0 , 0 , p ] ;
55589: NOP4
55593: PUSH
55594: NOP4
55598: PUSH
55599: LD_INT 0
55601: PUSH
55602: LD_INT 0
55604: PUSH
55605: NOP4
55609: PUSH
55610: EMPTY
55611: LIST
55612: LIST
55613: LIST
55614: LIST
55615: ST_TO_ADDR
// exit ;
55616: GO 58306
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55618: NOP4
55622: PUSH
55623: NOP4
55627: ARRAY
55628: PPUSH
55629: LD_INT 2
55631: PUSH
55632: LD_INT 30
55634: PUSH
55635: LD_INT 6
55637: PUSH
55638: EMPTY
55639: LIST
55640: LIST
55641: PUSH
55642: LD_INT 30
55644: PUSH
55645: LD_INT 7
55647: PUSH
55648: EMPTY
55649: LIST
55650: LIST
55651: PUSH
55652: LD_INT 30
55654: PUSH
55655: LD_INT 8
55657: PUSH
55658: EMPTY
55659: LIST
55660: LIST
55661: PUSH
55662: EMPTY
55663: LIST
55664: LIST
55665: LIST
55666: LIST
55667: PPUSH
55668: NOP4
55672: NOT
55673: PUSH
55674: NOP4
55678: PUSH
55679: NOP4
55683: ARRAY
55684: PPUSH
55685: LD_INT 30
55687: PUSH
55688: LD_INT 3
55690: PUSH
55691: EMPTY
55692: LIST
55693: LIST
55694: PPUSH
55695: NOP4
55699: NOT
55700: AND
55701: IFFALSE 55773
// begin if eng = tmp then
55703: NOP4
55707: PUSH
55708: NOP4
55712: EQUAL
55713: IFFALSE 55717
// exit ;
55715: GO 58306
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
55717: NOP4
55721: PUSH
55722: NOP4
55726: PPUSH
55727: NOP4
55731: PPUSH
55732: LD_INT 1
55734: PPUSH
55735: NOP4
55739: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
55740: NOP4
55744: PUSH
55745: LD_INT 0
55747: PUSH
55748: NOP4
55752: PUSH
55753: NOP4
55757: DIFF
55758: PUSH
55759: LD_INT 0
55761: PUSH
55762: LD_INT 0
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: LIST
55769: LIST
55770: ST_TO_ADDR
// exit ;
55771: GO 58306
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55773: NOP4
55777: PUSH
55778: NOP4
55782: PUSH
55783: NOP4
55787: ARRAY
55788: ARRAY
55789: PUSH
55790: NOP4
55794: PUSH
55795: NOP4
55799: ARRAY
55800: PPUSH
55801: LD_INT 2
55803: PUSH
55804: LD_INT 30
55806: PUSH
55807: LD_INT 6
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: PUSH
55814: LD_INT 30
55816: PUSH
55817: LD_INT 7
55819: PUSH
55820: EMPTY
55821: LIST
55822: LIST
55823: PUSH
55824: LD_INT 30
55826: PUSH
55827: LD_INT 8
55829: PUSH
55830: EMPTY
55831: LIST
55832: LIST
55833: PUSH
55834: EMPTY
55835: LIST
55836: LIST
55837: LIST
55838: LIST
55839: PPUSH
55840: NOP4
55844: AND
55845: PUSH
55846: NOP4
55850: PUSH
55851: NOP4
55855: ARRAY
55856: PPUSH
55857: LD_INT 30
55859: PUSH
55860: LD_INT 3
55862: PUSH
55863: EMPTY
55864: LIST
55865: LIST
55866: PPUSH
55867: NOP4
55871: NOT
55872: AND
55873: IFFALSE 56087
// begin if sci >= 6 then
55875: NOP4
55879: PUSH
55880: LD_INT 6
55882: GREATEREQUAL
55883: IFFALSE 55887
// exit ;
55885: GO 58306
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
55887: NOP4
55891: PUSH
55892: NOP4
55896: PPUSH
55897: NOP4
55901: PPUSH
55902: LD_INT 2
55904: PPUSH
55905: NOP4
55909: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
55910: NOP4
55914: PUSH
55915: NOP4
55919: PUSH
55920: NOP4
55924: DIFF
55925: PPUSH
55926: LD_INT 4
55928: PPUSH
55929: NOP4
55933: ST_TO_ADDR
// p := [ ] ;
55934: NOP4
55938: PUSH
55939: EMPTY
55940: ST_TO_ADDR
// if sci < 6 and sort > 6 then
55941: NOP4
55945: PUSH
55946: LD_INT 6
55948: LESS
55949: PUSH
55950: NOP4
55954: PUSH
55955: LD_INT 6
55957: GREATER
55958: AND
55959: IFFALSE 56040
// begin for i = 1 to 6 - sci do
55961: NOP4
55965: PUSH
55966: DOUBLE
55967: LD_INT 1
55969: DEC
55970: ST_TO_ADDR
55971: LD_INT 6
55973: PUSH
55974: NOP4
55978: MINUS
55979: PUSH
55980: FOR_TO
55981: IFFALSE 56036
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
55983: NOP4
55987: PUSH
55988: NOP4
55992: PPUSH
55993: NOP4
55997: PUSH
55998: LD_INT 1
56000: PLUS
56001: PPUSH
56002: NOP4
56006: PUSH
56007: LD_INT 1
56009: ARRAY
56010: PPUSH
56011: NOP4
56015: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56016: NOP4
56020: PUSH
56021: NOP4
56025: PPUSH
56026: LD_INT 1
56028: PPUSH
56029: NOP4
56033: ST_TO_ADDR
// end ;
56034: GO 55980
56036: POP
56037: POP
// end else
56038: GO 56060
// if sort then
56040: NOP4
56044: IFFALSE 56060
// p := sort [ 1 ] ;
56046: NOP4
56050: PUSH
56051: NOP4
56055: PUSH
56056: LD_INT 1
56058: ARRAY
56059: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56060: NOP4
56064: PUSH
56065: LD_INT 0
56067: PUSH
56068: LD_INT 0
56070: PUSH
56071: LD_INT 0
56073: PUSH
56074: NOP4
56078: PUSH
56079: EMPTY
56080: LIST
56081: LIST
56082: LIST
56083: LIST
56084: ST_TO_ADDR
// exit ;
56085: GO 58306
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56087: NOP4
56091: PUSH
56092: NOP4
56096: PUSH
56097: NOP4
56101: ARRAY
56102: ARRAY
56103: PUSH
56104: NOP4
56108: PUSH
56109: NOP4
56113: ARRAY
56114: PPUSH
56115: LD_INT 2
56117: PUSH
56118: LD_INT 30
56120: PUSH
56121: LD_INT 6
56123: PUSH
56124: EMPTY
56125: LIST
56126: LIST
56127: PUSH
56128: LD_INT 30
56130: PUSH
56131: LD_INT 7
56133: PUSH
56134: EMPTY
56135: LIST
56136: LIST
56137: PUSH
56138: LD_INT 30
56140: PUSH
56141: LD_INT 8
56143: PUSH
56144: EMPTY
56145: LIST
56146: LIST
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: LIST
56152: LIST
56153: PPUSH
56154: NOP4
56158: AND
56159: PUSH
56160: NOP4
56164: PUSH
56165: NOP4
56169: ARRAY
56170: PPUSH
56171: LD_INT 30
56173: PUSH
56174: LD_INT 3
56176: PUSH
56177: EMPTY
56178: LIST
56179: LIST
56180: PPUSH
56181: NOP4
56185: AND
56186: IFFALSE 56920
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56188: NOP4
56192: PUSH
56193: NOP4
56197: PPUSH
56198: NOP4
56202: PPUSH
56203: LD_INT 3
56205: PPUSH
56206: NOP4
56210: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56211: NOP4
56215: PUSH
56216: LD_INT 0
56218: PUSH
56219: LD_INT 0
56221: PUSH
56222: LD_INT 0
56224: PUSH
56225: LD_INT 0
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: LIST
56232: LIST
56233: ST_TO_ADDR
// if not eng then
56234: NOP4
56238: NOT
56239: IFFALSE 56302
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56241: NOP4
56245: PUSH
56246: NOP4
56250: PPUSH
56251: LD_INT 2
56253: PPUSH
56254: NOP4
56258: PUSH
56259: LD_INT 1
56261: ARRAY
56262: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56263: NOP4
56267: PUSH
56268: NOP4
56272: PPUSH
56273: LD_INT 2
56275: PPUSH
56276: NOP4
56280: PPUSH
56281: NOP4
56285: ST_TO_ADDR
// tmp := tmp diff p ;
56286: NOP4
56290: PUSH
56291: NOP4
56295: PUSH
56296: NOP4
56300: DIFF
56301: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56302: NOP4
56306: PUSH
56307: NOP4
56311: PUSH
56312: LD_INT 6
56314: LESS
56315: AND
56316: IFFALSE 56504
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56318: NOP4
56322: PUSH
56323: NOP4
56327: PUSH
56328: NOP4
56332: PUSH
56333: NOP4
56337: UNION
56338: DIFF
56339: PPUSH
56340: LD_INT 4
56342: PPUSH
56343: NOP4
56347: ST_TO_ADDR
// p := [ ] ;
56348: NOP4
56352: PUSH
56353: EMPTY
56354: ST_TO_ADDR
// if sort then
56355: NOP4
56359: IFFALSE 56475
// for i = 1 to 6 - sci do
56361: NOP4
56365: PUSH
56366: DOUBLE
56367: LD_INT 1
56369: DEC
56370: ST_TO_ADDR
56371: LD_INT 6
56373: PUSH
56374: NOP4
56378: MINUS
56379: PUSH
56380: FOR_TO
56381: IFFALSE 56473
// begin if i = sort then
56383: NOP4
56387: PUSH
56388: NOP4
56392: EQUAL
56393: IFFALSE 56397
// break ;
56395: GO 56473
// if GetClass ( i ) = 4 then
56397: NOP4
56401: PPUSH
56402: NOP4
56406: PUSH
56407: LD_INT 4
56409: EQUAL
56410: IFFALSE 56414
// continue ;
56412: GO 56380
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56414: NOP4
56418: PUSH
56419: NOP4
56423: PPUSH
56424: NOP4
56428: PUSH
56429: LD_INT 1
56431: PLUS
56432: PPUSH
56433: NOP4
56437: PUSH
56438: NOP4
56442: ARRAY
56443: PPUSH
56444: NOP4
56448: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56449: NOP4
56453: PUSH
56454: NOP4
56458: PUSH
56459: NOP4
56463: PUSH
56464: NOP4
56468: ARRAY
56469: DIFF
56470: ST_TO_ADDR
// end ;
56471: GO 56380
56473: POP
56474: POP
// if p then
56475: NOP4
56479: IFFALSE 56504
// result := Replace ( result , 4 , p ) ;
56481: NOP4
56485: PUSH
56486: NOP4
56490: PPUSH
56491: LD_INT 4
56493: PPUSH
56494: NOP4
56498: PPUSH
56499: NOP4
56503: ST_TO_ADDR
// end ; if tmp and mech < 6 then
56504: NOP4
56508: PUSH
56509: NOP4
56513: PUSH
56514: LD_INT 6
56516: LESS
56517: AND
56518: IFFALSE 56706
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56520: NOP4
56524: PUSH
56525: NOP4
56529: PUSH
56530: NOP4
56534: PUSH
56535: NOP4
56539: UNION
56540: DIFF
56541: PPUSH
56542: LD_INT 3
56544: PPUSH
56545: NOP4
56549: ST_TO_ADDR
// p := [ ] ;
56550: NOP4
56554: PUSH
56555: EMPTY
56556: ST_TO_ADDR
// if sort then
56557: NOP4
56561: IFFALSE 56677
// for i = 1 to 6 - mech do
56563: NOP4
56567: PUSH
56568: DOUBLE
56569: LD_INT 1
56571: DEC
56572: ST_TO_ADDR
56573: LD_INT 6
56575: PUSH
56576: NOP4
56580: MINUS
56581: PUSH
56582: FOR_TO
56583: IFFALSE 56675
// begin if i = sort then
56585: NOP4
56589: PUSH
56590: NOP4
56594: EQUAL
56595: IFFALSE 56599
// break ;
56597: GO 56675
// if GetClass ( i ) = 3 then
56599: NOP4
56603: PPUSH
56604: NOP4
56608: PUSH
56609: LD_INT 3
56611: EQUAL
56612: IFFALSE 56616
// continue ;
56614: GO 56582
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56616: NOP4
56620: PUSH
56621: NOP4
56625: PPUSH
56626: NOP4
56630: PUSH
56631: LD_INT 1
56633: PLUS
56634: PPUSH
56635: NOP4
56639: PUSH
56640: NOP4
56644: ARRAY
56645: PPUSH
56646: NOP4
56650: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56651: NOP4
56655: PUSH
56656: NOP4
56660: PUSH
56661: NOP4
56665: PUSH
56666: NOP4
56670: ARRAY
56671: DIFF
56672: ST_TO_ADDR
// end ;
56673: GO 56582
56675: POP
56676: POP
// if p then
56677: NOP4
56681: IFFALSE 56706
// result := Replace ( result , 3 , p ) ;
56683: NOP4
56687: PUSH
56688: NOP4
56692: PPUSH
56693: LD_INT 3
56695: PPUSH
56696: NOP4
56700: PPUSH
56701: NOP4
56705: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
56706: NOP4
56710: PUSH
56711: LD_INT 6
56713: GREATER
56714: PUSH
56715: NOP4
56719: PUSH
56720: LD_INT 6
56722: LESS
56723: AND
56724: IFFALSE 56918
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
56726: NOP4
56730: PUSH
56731: NOP4
56735: PUSH
56736: NOP4
56740: PUSH
56741: NOP4
56745: UNION
56746: PUSH
56747: NOP4
56751: UNION
56752: DIFF
56753: PPUSH
56754: LD_INT 2
56756: PPUSH
56757: NOP4
56761: ST_TO_ADDR
// p := [ ] ;
56762: NOP4
56766: PUSH
56767: EMPTY
56768: ST_TO_ADDR
// if sort then
56769: NOP4
56773: IFFALSE 56889
// for i = 1 to 6 - eng do
56775: NOP4
56779: PUSH
56780: DOUBLE
56781: LD_INT 1
56783: DEC
56784: ST_TO_ADDR
56785: LD_INT 6
56787: PUSH
56788: NOP4
56792: MINUS
56793: PUSH
56794: FOR_TO
56795: IFFALSE 56887
// begin if i = sort then
56797: NOP4
56801: PUSH
56802: NOP4
56806: EQUAL
56807: IFFALSE 56811
// break ;
56809: GO 56887
// if GetClass ( i ) = 2 then
56811: NOP4
56815: PPUSH
56816: NOP4
56820: PUSH
56821: LD_INT 2
56823: EQUAL
56824: IFFALSE 56828
// continue ;
56826: GO 56794
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56828: NOP4
56832: PUSH
56833: NOP4
56837: PPUSH
56838: NOP4
56842: PUSH
56843: LD_INT 1
56845: PLUS
56846: PPUSH
56847: NOP4
56851: PUSH
56852: NOP4
56856: ARRAY
56857: PPUSH
56858: NOP4
56862: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56863: NOP4
56867: PUSH
56868: NOP4
56872: PUSH
56873: NOP4
56877: PUSH
56878: NOP4
56882: ARRAY
56883: DIFF
56884: ST_TO_ADDR
// end ;
56885: GO 56794
56887: POP
56888: POP
// if p then
56889: NOP4
56893: IFFALSE 56918
// result := Replace ( result , 2 , p ) ;
56895: NOP4
56899: PUSH
56900: NOP4
56904: PPUSH
56905: LD_INT 2
56907: PPUSH
56908: NOP4
56912: PPUSH
56913: NOP4
56917: ST_TO_ADDR
// end ; exit ;
56918: GO 58306
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
56920: NOP4
56924: PUSH
56925: NOP4
56929: PUSH
56930: NOP4
56934: ARRAY
56935: ARRAY
56936: NOT
56937: PUSH
56938: NOP4
56942: PUSH
56943: NOP4
56947: ARRAY
56948: PPUSH
56949: LD_INT 30
56951: PUSH
56952: LD_INT 3
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: PPUSH
56959: NOP4
56963: AND
56964: PUSH
56965: NOP4
56969: PUSH
56970: NOP4
56974: ARRAY
56975: AND
56976: IFFALSE 57584
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
56978: NOP4
56982: PUSH
56983: NOP4
56987: PPUSH
56988: NOP4
56992: PPUSH
56993: LD_INT 5
56995: PPUSH
56996: NOP4
57000: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57001: NOP4
57005: PUSH
57006: LD_INT 0
57008: PUSH
57009: LD_INT 0
57011: PUSH
57012: LD_INT 0
57014: PUSH
57015: LD_INT 0
57017: PUSH
57018: EMPTY
57019: LIST
57020: LIST
57021: LIST
57022: LIST
57023: ST_TO_ADDR
// if sci > 1 then
57024: NOP4
57028: PUSH
57029: LD_INT 1
57031: GREATER
57032: IFFALSE 57060
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57034: NOP4
57038: PUSH
57039: NOP4
57043: PUSH
57044: NOP4
57048: PUSH
57049: NOP4
57053: PUSH
57054: LD_INT 1
57056: ARRAY
57057: DIFF
57058: DIFF
57059: ST_TO_ADDR
// if tmp and not sci then
57060: NOP4
57064: PUSH
57065: NOP4
57069: NOT
57070: AND
57071: IFFALSE 57140
// begin sort := SortBySkill ( tmp , 4 ) ;
57073: NOP4
57077: PUSH
57078: NOP4
57082: PPUSH
57083: LD_INT 4
57085: PPUSH
57086: NOP4
57090: ST_TO_ADDR
// if sort then
57091: NOP4
57095: IFFALSE 57111
// p := sort [ 1 ] ;
57097: NOP4
57101: PUSH
57102: NOP4
57106: PUSH
57107: LD_INT 1
57109: ARRAY
57110: ST_TO_ADDR
// if p then
57111: NOP4
57115: IFFALSE 57140
// result := Replace ( result , 4 , p ) ;
57117: NOP4
57121: PUSH
57122: NOP4
57126: PPUSH
57127: LD_INT 4
57129: PPUSH
57130: NOP4
57134: PPUSH
57135: NOP4
57139: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57140: NOP4
57144: PUSH
57145: NOP4
57149: PUSH
57150: NOP4
57154: DIFF
57155: ST_TO_ADDR
// if tmp and mech < 6 then
57156: NOP4
57160: PUSH
57161: NOP4
57165: PUSH
57166: LD_INT 6
57168: LESS
57169: AND
57170: IFFALSE 57358
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57172: NOP4
57176: PUSH
57177: NOP4
57181: PUSH
57182: NOP4
57186: PUSH
57187: NOP4
57191: UNION
57192: DIFF
57193: PPUSH
57194: LD_INT 3
57196: PPUSH
57197: NOP4
57201: ST_TO_ADDR
// p := [ ] ;
57202: NOP4
57206: PUSH
57207: EMPTY
57208: ST_TO_ADDR
// if sort then
57209: NOP4
57213: IFFALSE 57329
// for i = 1 to 6 - mech do
57215: NOP4
57219: PUSH
57220: DOUBLE
57221: LD_INT 1
57223: DEC
57224: ST_TO_ADDR
57225: LD_INT 6
57227: PUSH
57228: NOP4
57232: MINUS
57233: PUSH
57234: FOR_TO
57235: IFFALSE 57327
// begin if i = sort then
57237: NOP4
57241: PUSH
57242: NOP4
57246: EQUAL
57247: IFFALSE 57251
// break ;
57249: GO 57327
// if GetClass ( i ) = 3 then
57251: NOP4
57255: PPUSH
57256: NOP4
57260: PUSH
57261: LD_INT 3
57263: EQUAL
57264: IFFALSE 57268
// continue ;
57266: GO 57234
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57268: NOP4
57272: PUSH
57273: NOP4
57277: PPUSH
57278: NOP4
57282: PUSH
57283: LD_INT 1
57285: PLUS
57286: PPUSH
57287: NOP4
57291: PUSH
57292: NOP4
57296: ARRAY
57297: PPUSH
57298: NOP4
57302: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57303: NOP4
57307: PUSH
57308: NOP4
57312: PUSH
57313: NOP4
57317: PUSH
57318: NOP4
57322: ARRAY
57323: DIFF
57324: ST_TO_ADDR
// end ;
57325: GO 57234
57327: POP
57328: POP
// if p then
57329: NOP4
57333: IFFALSE 57358
// result := Replace ( result , 3 , p ) ;
57335: NOP4
57339: PUSH
57340: NOP4
57344: PPUSH
57345: LD_INT 3
57347: PPUSH
57348: NOP4
57352: PPUSH
57353: NOP4
57357: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57358: NOP4
57362: PUSH
57363: NOP4
57367: PUSH
57368: NOP4
57372: DIFF
57373: ST_TO_ADDR
// if tmp and eng < 6 then
57374: NOP4
57378: PUSH
57379: NOP4
57383: PUSH
57384: LD_INT 6
57386: LESS
57387: AND
57388: IFFALSE 57582
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57390: NOP4
57394: PUSH
57395: NOP4
57399: PUSH
57400: NOP4
57404: PUSH
57405: NOP4
57409: UNION
57410: PUSH
57411: NOP4
57415: UNION
57416: DIFF
57417: PPUSH
57418: LD_INT 2
57420: PPUSH
57421: NOP4
57425: ST_TO_ADDR
// p := [ ] ;
57426: NOP4
57430: PUSH
57431: EMPTY
57432: ST_TO_ADDR
// if sort then
57433: NOP4
57437: IFFALSE 57553
// for i = 1 to 6 - eng do
57439: NOP4
57443: PUSH
57444: DOUBLE
57445: LD_INT 1
57447: DEC
57448: ST_TO_ADDR
57449: LD_INT 6
57451: PUSH
57452: NOP4
57456: MINUS
57457: PUSH
57458: FOR_TO
57459: IFFALSE 57551
// begin if i = sort then
57461: NOP4
57465: PUSH
57466: NOP4
57470: EQUAL
57471: IFFALSE 57475
// break ;
57473: GO 57551
// if GetClass ( i ) = 2 then
57475: NOP4
57479: PPUSH
57480: NOP4
57484: PUSH
57485: LD_INT 2
57487: EQUAL
57488: IFFALSE 57492
// continue ;
57490: GO 57458
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57492: NOP4
57496: PUSH
57497: NOP4
57501: PPUSH
57502: NOP4
57506: PUSH
57507: LD_INT 1
57509: PLUS
57510: PPUSH
57511: NOP4
57515: PUSH
57516: NOP4
57520: ARRAY
57521: PPUSH
57522: NOP4
57526: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57527: NOP4
57531: PUSH
57532: NOP4
57536: PUSH
57537: NOP4
57541: PUSH
57542: NOP4
57546: ARRAY
57547: DIFF
57548: ST_TO_ADDR
// end ;
57549: GO 57458
57551: POP
57552: POP
// if p then
57553: NOP4
57557: IFFALSE 57582
// result := Replace ( result , 2 , p ) ;
57559: NOP4
57563: PUSH
57564: NOP4
57568: PPUSH
57569: LD_INT 2
57571: PPUSH
57572: NOP4
57576: PPUSH
57577: NOP4
57581: ST_TO_ADDR
// end ; exit ;
57582: GO 58306
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
57584: NOP4
57588: PUSH
57589: NOP4
57593: PUSH
57594: NOP4
57598: ARRAY
57599: ARRAY
57600: NOT
57601: PUSH
57602: NOP4
57606: PUSH
57607: NOP4
57611: ARRAY
57612: PPUSH
57613: LD_INT 30
57615: PUSH
57616: LD_INT 3
57618: PUSH
57619: EMPTY
57620: LIST
57621: LIST
57622: PPUSH
57623: NOP4
57627: AND
57628: PUSH
57629: NOP4
57633: PUSH
57634: NOP4
57638: ARRAY
57639: NOT
57640: AND
57641: IFFALSE 58306
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
57643: NOP4
57647: PUSH
57648: NOP4
57652: PPUSH
57653: NOP4
57657: PPUSH
57658: LD_INT 6
57660: PPUSH
57661: NOP4
57665: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57666: NOP4
57670: PUSH
57671: LD_INT 0
57673: PUSH
57674: LD_INT 0
57676: PUSH
57677: LD_INT 0
57679: PUSH
57680: LD_INT 0
57682: PUSH
57683: EMPTY
57684: LIST
57685: LIST
57686: LIST
57687: LIST
57688: ST_TO_ADDR
// if sci >= 1 then
57689: NOP4
57693: PUSH
57694: LD_INT 1
57696: GREATEREQUAL
57697: IFFALSE 57719
// tmp := tmp diff sci [ 1 ] ;
57699: NOP4
57703: PUSH
57704: NOP4
57708: PUSH
57709: NOP4
57713: PUSH
57714: LD_INT 1
57716: ARRAY
57717: DIFF
57718: ST_TO_ADDR
// if tmp and not sci then
57719: NOP4
57723: PUSH
57724: NOP4
57728: NOT
57729: AND
57730: IFFALSE 57799
// begin sort := SortBySkill ( tmp , 4 ) ;
57732: NOP4
57736: PUSH
57737: NOP4
57741: PPUSH
57742: LD_INT 4
57744: PPUSH
57745: NOP4
57749: ST_TO_ADDR
// if sort then
57750: NOP4
57754: IFFALSE 57770
// p := sort [ 1 ] ;
57756: NOP4
57760: PUSH
57761: NOP4
57765: PUSH
57766: LD_INT 1
57768: ARRAY
57769: ST_TO_ADDR
// if p then
57770: NOP4
57774: IFFALSE 57799
// result := Replace ( result , 4 , p ) ;
57776: NOP4
57780: PUSH
57781: NOP4
57785: PPUSH
57786: LD_INT 4
57788: PPUSH
57789: NOP4
57793: PPUSH
57794: NOP4
57798: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57799: NOP4
57803: PUSH
57804: NOP4
57808: PUSH
57809: NOP4
57813: DIFF
57814: ST_TO_ADDR
// if tmp and mech < 6 then
57815: NOP4
57819: PUSH
57820: NOP4
57824: PUSH
57825: LD_INT 6
57827: LESS
57828: AND
57829: IFFALSE 58011
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
57831: NOP4
57835: PUSH
57836: NOP4
57840: PUSH
57841: NOP4
57845: DIFF
57846: PPUSH
57847: LD_INT 3
57849: PPUSH
57850: NOP4
57854: ST_TO_ADDR
// p := [ ] ;
57855: NOP4
57859: PUSH
57860: EMPTY
57861: ST_TO_ADDR
// if sort then
57862: NOP4
57866: IFFALSE 57982
// for i = 1 to 6 - mech do
57868: NOP4
57872: PUSH
57873: DOUBLE
57874: LD_INT 1
57876: DEC
57877: ST_TO_ADDR
57878: LD_INT 6
57880: PUSH
57881: NOP4
57885: MINUS
57886: PUSH
57887: FOR_TO
57888: IFFALSE 57980
// begin if i = sort then
57890: NOP4
57894: PUSH
57895: NOP4
57899: EQUAL
57900: IFFALSE 57904
// break ;
57902: GO 57980
// if GetClass ( i ) = 3 then
57904: NOP4
57908: PPUSH
57909: NOP4
57913: PUSH
57914: LD_INT 3
57916: EQUAL
57917: IFFALSE 57921
// continue ;
57919: GO 57887
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57921: NOP4
57925: PUSH
57926: NOP4
57930: PPUSH
57931: NOP4
57935: PUSH
57936: LD_INT 1
57938: PLUS
57939: PPUSH
57940: NOP4
57944: PUSH
57945: NOP4
57949: ARRAY
57950: PPUSH
57951: NOP4
57955: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57956: NOP4
57960: PUSH
57961: NOP4
57965: PUSH
57966: NOP4
57970: PUSH
57971: NOP4
57975: ARRAY
57976: DIFF
57977: ST_TO_ADDR
// end ;
57978: GO 57887
57980: POP
57981: POP
// if p then
57982: NOP4
57986: IFFALSE 58011
// result := Replace ( result , 3 , p ) ;
57988: NOP4
57992: PUSH
57993: NOP4
57997: PPUSH
57998: LD_INT 3
58000: PPUSH
58001: NOP4
58005: PPUSH
58006: NOP4
58010: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58011: NOP4
58015: PUSH
58016: NOP4
58020: PUSH
58021: NOP4
58025: DIFF
58026: ST_TO_ADDR
// if tmp and eng < 4 then
58027: NOP4
58031: PUSH
58032: NOP4
58036: PUSH
58037: LD_INT 4
58039: LESS
58040: AND
58041: IFFALSE 58231
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58043: NOP4
58047: PUSH
58048: NOP4
58052: PUSH
58053: NOP4
58057: PUSH
58058: NOP4
58062: UNION
58063: DIFF
58064: PPUSH
58065: LD_INT 2
58067: PPUSH
58068: NOP4
58072: ST_TO_ADDR
// p := [ ] ;
58073: NOP4
58077: PUSH
58078: EMPTY
58079: ST_TO_ADDR
// if sort then
58080: NOP4
58084: IFFALSE 58200
// for i = 1 to 4 - eng do
58086: NOP4
58090: PUSH
58091: DOUBLE
58092: LD_INT 1
58094: DEC
58095: ST_TO_ADDR
58096: LD_INT 4
58098: PUSH
58099: NOP4
58103: MINUS
58104: PUSH
58105: FOR_TO
58106: IFFALSE 58198
// begin if i = sort then
58108: NOP4
58112: PUSH
58113: NOP4
58117: EQUAL
58118: IFFALSE 58122
// break ;
58120: GO 58198
// if GetClass ( i ) = 2 then
58122: NOP4
58126: PPUSH
58127: NOP4
58131: PUSH
58132: LD_INT 2
58134: EQUAL
58135: IFFALSE 58139
// continue ;
58137: GO 58105
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58139: NOP4
58143: PUSH
58144: NOP4
58148: PPUSH
58149: NOP4
58153: PUSH
58154: LD_INT 1
58156: PLUS
58157: PPUSH
58158: NOP4
58162: PUSH
58163: NOP4
58167: ARRAY
58168: PPUSH
58169: NOP4
58173: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58174: NOP4
58178: PUSH
58179: NOP4
58183: PUSH
58184: NOP4
58188: PUSH
58189: NOP4
58193: ARRAY
58194: DIFF
58195: ST_TO_ADDR
// end ;
58196: GO 58105
58198: POP
58199: POP
// if p then
58200: NOP4
58204: IFFALSE 58229
// result := Replace ( result , 2 , p ) ;
58206: NOP4
58210: PUSH
58211: NOP4
58215: PPUSH
58216: LD_INT 2
58218: PPUSH
58219: NOP4
58223: PPUSH
58224: NOP4
58228: ST_TO_ADDR
// end else
58229: GO 58275
// for i = eng downto 5 do
58231: NOP4
58235: PUSH
58236: DOUBLE
58237: NOP4
58241: INC
58242: ST_TO_ADDR
58243: LD_INT 5
58245: PUSH
58246: FOR_DOWNTO
58247: IFFALSE 58273
// tmp := tmp union eng [ i ] ;
58249: NOP4
58253: PUSH
58254: NOP4
58258: PUSH
58259: NOP4
58263: PUSH
58264: NOP4
58268: ARRAY
58269: UNION
58270: ST_TO_ADDR
58271: GO 58246
58273: POP
58274: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58275: NOP4
58279: PUSH
58280: NOP4
58284: PPUSH
58285: LD_INT 1
58287: PPUSH
58288: NOP4
58292: PUSH
58293: NOP4
58297: DIFF
58298: PPUSH
58299: NOP4
58303: ST_TO_ADDR
// exit ;
58304: GO 58306
// end ; end ;
58306: LD_VAR 0 2
58310: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58311: LD_INT 0
58313: PPUSH
58314: PPUSH
58315: PPUSH
// if not mc_bases then
58316: NOP4
58320: NOT
58321: IFFALSE 58325
// exit ;
58323: GO 58467
// for i = 1 to mc_bases do
58325: NOP4
58329: PUSH
58330: DOUBLE
58331: LD_INT 1
58333: DEC
58334: ST_TO_ADDR
58335: NOP4
58339: PUSH
58340: FOR_TO
58341: IFFALSE 58458
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58343: NOP4
58347: PUSH
58348: NOP4
58352: PUSH
58353: NOP4
58357: ARRAY
58358: PPUSH
58359: LD_INT 21
58361: PUSH
58362: LD_INT 3
58364: PUSH
58365: EMPTY
58366: LIST
58367: LIST
58368: PUSH
58369: LD_INT 3
58371: PUSH
58372: LD_INT 2
58374: PUSH
58375: LD_INT 30
58377: PUSH
58378: LD_INT 29
58380: PUSH
58381: EMPTY
58382: LIST
58383: LIST
58384: PUSH
58385: LD_INT 30
58387: PUSH
58388: LD_INT 30
58390: PUSH
58391: EMPTY
58392: LIST
58393: LIST
58394: PUSH
58395: EMPTY
58396: LIST
58397: LIST
58398: LIST
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: PUSH
58404: LD_INT 3
58406: PUSH
58407: LD_INT 24
58409: PUSH
58410: LD_INT 1000
58412: PUSH
58413: EMPTY
58414: LIST
58415: LIST
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: PUSH
58421: EMPTY
58422: LIST
58423: LIST
58424: LIST
58425: PPUSH
58426: NOP4
58430: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58431: NOP4
58435: PUSH
58436: NOP4
58440: PPUSH
58441: NOP4
58445: PPUSH
58446: NOP4
58450: PPUSH
58451: NOP4
58455: ST_TO_ADDR
// end ;
58456: GO 58340
58458: POP
58459: POP
// RaiseSailEvent ( 101 ) ;
58460: LD_INT 101
58462: PPUSH
58463: NOP4
// end ;
58467: LD_VAR 0 1
58471: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
58472: LD_INT 0
58474: PPUSH
58475: PPUSH
58476: PPUSH
58477: PPUSH
58478: PPUSH
58479: PPUSH
58480: PPUSH
// if not mc_bases then
58481: NOP4
58485: NOT
58486: IFFALSE 58490
// exit ;
58488: GO 59052
// for i = 1 to mc_bases do
58490: NOP4
58494: PUSH
58495: DOUBLE
58496: LD_INT 1
58498: DEC
58499: ST_TO_ADDR
58500: NOP4
58504: PUSH
58505: FOR_TO
58506: IFFALSE 59043
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
58508: NOP4
58512: PUSH
58513: NOP4
58517: PUSH
58518: NOP4
58522: ARRAY
58523: PUSH
58524: NOP4
58528: PUSH
58529: NOP4
58533: ARRAY
58534: UNION
58535: PPUSH
58536: LD_INT 21
58538: PUSH
58539: LD_INT 1
58541: PUSH
58542: EMPTY
58543: LIST
58544: LIST
58545: PUSH
58546: LD_INT 1
58548: PUSH
58549: LD_INT 3
58551: PUSH
58552: LD_INT 54
58554: PUSH
58555: EMPTY
58556: LIST
58557: PUSH
58558: EMPTY
58559: LIST
58560: LIST
58561: PUSH
58562: LD_INT 3
58564: PUSH
58565: LD_INT 24
58567: PUSH
58568: LD_INT 1000
58570: PUSH
58571: EMPTY
58572: LIST
58573: LIST
58574: PUSH
58575: EMPTY
58576: LIST
58577: LIST
58578: PUSH
58579: EMPTY
58580: LIST
58581: LIST
58582: LIST
58583: PUSH
58584: EMPTY
58585: LIST
58586: LIST
58587: PPUSH
58588: NOP4
58592: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
58593: NOP4
58597: PUSH
58598: NOP4
58602: PUSH
58603: NOP4
58607: ARRAY
58608: PPUSH
58609: LD_INT 21
58611: PUSH
58612: LD_INT 1
58614: PUSH
58615: EMPTY
58616: LIST
58617: LIST
58618: PUSH
58619: LD_INT 1
58621: PUSH
58622: LD_INT 3
58624: PUSH
58625: LD_INT 54
58627: PUSH
58628: EMPTY
58629: LIST
58630: PUSH
58631: EMPTY
58632: LIST
58633: LIST
58634: PUSH
58635: LD_INT 3
58637: PUSH
58638: LD_INT 24
58640: PUSH
58641: LD_INT 250
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: PUSH
58648: EMPTY
58649: LIST
58650: LIST
58651: PUSH
58652: EMPTY
58653: LIST
58654: LIST
58655: LIST
58656: PUSH
58657: EMPTY
58658: LIST
58659: LIST
58660: PPUSH
58661: NOP4
58665: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
58666: NOP4
58670: PUSH
58671: NOP4
58675: PUSH
58676: NOP4
58680: DIFF
58681: ST_TO_ADDR
// if not need_heal_1 then
58682: NOP4
58686: NOT
58687: IFFALSE 58720
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
58689: NOP4
58693: PUSH
58694: NOP4
58698: PPUSH
58699: NOP4
58703: PUSH
58704: LD_INT 1
58706: PUSH
58707: EMPTY
58708: LIST
58709: LIST
58710: PPUSH
58711: EMPTY
58712: PPUSH
58713: NOP4
58717: ST_TO_ADDR
58718: GO 58790
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
58720: NOP4
58724: PUSH
58725: NOP4
58729: PPUSH
58730: NOP4
58734: PUSH
58735: LD_INT 1
58737: PUSH
58738: EMPTY
58739: LIST
58740: LIST
58741: PPUSH
58742: NOP4
58746: PUSH
58747: NOP4
58751: ARRAY
58752: PUSH
58753: LD_INT 1
58755: ARRAY
58756: PPUSH
58757: LD_INT 3
58759: PUSH
58760: LD_INT 24
58762: PUSH
58763: LD_INT 1000
58765: PUSH
58766: EMPTY
58767: LIST
58768: LIST
58769: PUSH
58770: EMPTY
58771: LIST
58772: LIST
58773: PPUSH
58774: NOP4
58778: PUSH
58779: NOP4
58783: UNION
58784: PPUSH
58785: NOP4
58789: ST_TO_ADDR
// if not need_heal_2 then
58790: NOP4
58794: NOT
58795: IFFALSE 58828
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
58797: NOP4
58801: PUSH
58802: NOP4
58806: PPUSH
58807: NOP4
58811: PUSH
58812: LD_INT 2
58814: PUSH
58815: EMPTY
58816: LIST
58817: LIST
58818: PPUSH
58819: EMPTY
58820: PPUSH
58821: NOP4
58825: ST_TO_ADDR
58826: GO 58860
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
58828: NOP4
58832: PUSH
58833: NOP4
58837: PPUSH
58838: NOP4
58842: PUSH
58843: LD_INT 2
58845: PUSH
58846: EMPTY
58847: LIST
58848: LIST
58849: PPUSH
58850: NOP4
58854: PPUSH
58855: NOP4
58859: ST_TO_ADDR
// if need_heal_2 then
58860: NOP4
58864: IFFALSE 59025
// for j in need_heal_2 do
58866: NOP4
58870: PUSH
58871: NOP4
58875: PUSH
58876: FOR_IN
58877: IFFALSE 59023
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58879: NOP4
58883: PUSH
58884: NOP4
58888: PUSH
58889: NOP4
58893: ARRAY
58894: PPUSH
58895: LD_INT 2
58897: PUSH
58898: LD_INT 30
58900: PUSH
58901: LD_INT 6
58903: PUSH
58904: EMPTY
58905: LIST
58906: LIST
58907: PUSH
58908: LD_INT 30
58910: PUSH
58911: LD_INT 7
58913: PUSH
58914: EMPTY
58915: LIST
58916: LIST
58917: PUSH
58918: LD_INT 30
58920: PUSH
58921: LD_INT 8
58923: PUSH
58924: EMPTY
58925: LIST
58926: LIST
58927: PUSH
58928: LD_INT 30
58930: PUSH
58931: LD_INT 0
58933: PUSH
58934: EMPTY
58935: LIST
58936: LIST
58937: PUSH
58938: LD_INT 30
58940: PUSH
58941: LD_INT 1
58943: PUSH
58944: EMPTY
58945: LIST
58946: LIST
58947: PUSH
58948: EMPTY
58949: LIST
58950: LIST
58951: LIST
58952: LIST
58953: LIST
58954: LIST
58955: PPUSH
58956: NOP4
58960: ST_TO_ADDR
// if tmp then
58961: NOP4
58965: IFFALSE 59021
// begin k := NearestUnitToUnit ( tmp , j ) ;
58967: NOP4
58971: PUSH
58972: NOP4
58976: PPUSH
58977: NOP4
58981: PPUSH
58982: NOP4
58986: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
58987: NOP4
58991: PPUSH
58992: NOP4
58996: PPUSH
58997: NOP4
59001: PUSH
59002: LD_INT 5
59004: GREATER
59005: IFFALSE 59021
// ComMoveToNearbyEntrance ( j , k ) ;
59007: NOP4
59011: PPUSH
59012: NOP4
59016: PPUSH
59017: NOP4
// end ; end ;
59021: GO 58876
59023: POP
59024: POP
// if not need_heal_1 and not need_heal_2 then
59025: NOP4
59029: NOT
59030: PUSH
59031: NOP4
59035: NOT
59036: AND
59037: IFFALSE 59041
// continue ;
59039: GO 58505
// end ;
59041: GO 58505
59043: POP
59044: POP
// RaiseSailEvent ( 102 ) ;
59045: LD_INT 102
59047: PPUSH
59048: NOP4
// end ;
59052: LD_VAR 0 1
59056: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59057: LD_INT 0
59059: PPUSH
59060: PPUSH
59061: PPUSH
59062: PPUSH
59063: PPUSH
59064: PPUSH
59065: PPUSH
59066: PPUSH
// if not mc_bases then
59067: NOP4
59071: NOT
59072: IFFALSE 59076
// exit ;
59074: GO 59959
// for i = 1 to mc_bases do
59076: NOP4
59080: PUSH
59081: DOUBLE
59082: LD_INT 1
59084: DEC
59085: ST_TO_ADDR
59086: NOP4
59090: PUSH
59091: FOR_TO
59092: IFFALSE 59957
// begin if not mc_building_need_repair [ i ] then
59094: NOP4
59098: PUSH
59099: NOP4
59103: ARRAY
59104: NOT
59105: IFFALSE 59292
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
59107: NOP4
59111: PUSH
59112: NOP4
59116: PUSH
59117: NOP4
59121: ARRAY
59122: PPUSH
59123: LD_INT 3
59125: PUSH
59126: LD_INT 24
59128: PUSH
59129: LD_INT 1000
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: PUSH
59136: EMPTY
59137: LIST
59138: LIST
59139: PUSH
59140: LD_INT 2
59142: PUSH
59143: LD_INT 34
59145: PUSH
59146: LD_INT 13
59148: PUSH
59149: EMPTY
59150: LIST
59151: LIST
59152: PUSH
59153: LD_INT 34
59155: PUSH
59156: LD_INT 52
59158: PUSH
59159: EMPTY
59160: LIST
59161: LIST
59162: PUSH
59163: LD_INT 34
59165: PUSH
59166: NOP4
59170: PUSH
59171: EMPTY
59172: LIST
59173: LIST
59174: PUSH
59175: EMPTY
59176: LIST
59177: LIST
59178: LIST
59179: LIST
59180: PUSH
59181: EMPTY
59182: LIST
59183: LIST
59184: PPUSH
59185: NOP4
59189: ST_TO_ADDR
// if cranes then
59190: NOP4
59194: IFFALSE 59256
// for j in cranes do
59196: NOP4
59200: PUSH
59201: NOP4
59205: PUSH
59206: FOR_IN
59207: IFFALSE 59254
// if not IsInArea ( j , mc_parking [ i ] ) then
59209: NOP4
59213: PPUSH
59214: NOP4
59218: PUSH
59219: NOP4
59223: ARRAY
59224: PPUSH
59225: NOP4
59229: NOT
59230: IFFALSE 59252
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59232: NOP4
59236: PPUSH
59237: NOP4
59241: PUSH
59242: NOP4
59246: ARRAY
59247: PPUSH
59248: NOP4
59252: GO 59206
59254: POP
59255: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59256: NOP4
59260: PUSH
59261: NOP4
59265: PPUSH
59266: NOP4
59270: PPUSH
59271: EMPTY
59272: PPUSH
59273: NOP4
59277: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59278: NOP4
59282: PPUSH
59283: LD_INT 101
59285: PPUSH
59286: NOP4
// continue ;
59290: GO 59091
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59292: NOP4
59296: PUSH
59297: NOP4
59301: PPUSH
59302: NOP4
59306: PPUSH
59307: EMPTY
59308: PPUSH
59309: NOP4
59313: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59314: NOP4
59318: PPUSH
59319: LD_INT 103
59321: PPUSH
59322: NOP4
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
59326: NOP4
59330: PUSH
59331: NOP4
59335: PUSH
59336: NOP4
59340: ARRAY
59341: PUSH
59342: NOP4
59346: PUSH
59347: NOP4
59351: ARRAY
59352: UNION
59353: PPUSH
59354: LD_INT 2
59356: PUSH
59357: LD_INT 25
59359: PUSH
59360: LD_INT 2
59362: PUSH
59363: EMPTY
59364: LIST
59365: LIST
59366: PUSH
59367: LD_INT 25
59369: PUSH
59370: LD_INT 16
59372: PUSH
59373: EMPTY
59374: LIST
59375: LIST
59376: PUSH
59377: EMPTY
59378: LIST
59379: LIST
59380: LIST
59381: PUSH
59382: EMPTY
59383: LIST
59384: PPUSH
59385: NOP4
59389: ST_TO_ADDR
// if mc_need_heal [ i ] then
59390: NOP4
59394: PUSH
59395: NOP4
59399: ARRAY
59400: IFFALSE 59444
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59402: NOP4
59406: PUSH
59407: NOP4
59411: PUSH
59412: NOP4
59416: PUSH
59417: NOP4
59421: ARRAY
59422: PUSH
59423: LD_INT 1
59425: ARRAY
59426: PUSH
59427: NOP4
59431: PUSH
59432: NOP4
59436: ARRAY
59437: PUSH
59438: LD_INT 2
59440: ARRAY
59441: UNION
59442: DIFF
59443: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
59444: NOP4
59448: PUSH
59449: NOP4
59453: PUSH
59454: NOP4
59458: ARRAY
59459: PPUSH
59460: LD_INT 2
59462: PUSH
59463: LD_INT 34
59465: PUSH
59466: LD_INT 13
59468: PUSH
59469: EMPTY
59470: LIST
59471: LIST
59472: PUSH
59473: LD_INT 34
59475: PUSH
59476: LD_INT 52
59478: PUSH
59479: EMPTY
59480: LIST
59481: LIST
59482: PUSH
59483: LD_INT 34
59485: PUSH
59486: NOP4
59490: PUSH
59491: EMPTY
59492: LIST
59493: LIST
59494: PUSH
59495: EMPTY
59496: LIST
59497: LIST
59498: LIST
59499: LIST
59500: PPUSH
59501: NOP4
59505: ST_TO_ADDR
// if cranes then
59506: NOP4
59510: IFFALSE 59646
// begin for j in cranes do
59512: NOP4
59516: PUSH
59517: NOP4
59521: PUSH
59522: FOR_IN
59523: IFFALSE 59644
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
59525: NOP4
59529: PPUSH
59530: NOP4
59534: PUSH
59535: LD_INT 1000
59537: EQUAL
59538: PUSH
59539: NOP4
59543: PPUSH
59544: NOP4
59548: NOT
59549: AND
59550: IFFALSE 59584
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
59552: NOP4
59556: PPUSH
59557: NOP4
59561: PUSH
59562: NOP4
59566: ARRAY
59567: PPUSH
59568: NOP4
59572: PPUSH
59573: NOP4
59577: PPUSH
59578: NOP4
59582: GO 59642
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59584: NOP4
59588: PPUSH
59589: NOP4
59593: PUSH
59594: LD_INT 500
59596: LESS
59597: PUSH
59598: NOP4
59602: PPUSH
59603: NOP4
59607: PUSH
59608: NOP4
59612: ARRAY
59613: PPUSH
59614: NOP4
59618: NOT
59619: AND
59620: IFFALSE 59642
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59622: NOP4
59626: PPUSH
59627: NOP4
59631: PUSH
59632: NOP4
59636: ARRAY
59637: PPUSH
59638: NOP4
// end ;
59642: GO 59522
59644: POP
59645: POP
// end ; if tmp > 3 then
59646: NOP4
59650: PUSH
59651: LD_INT 3
59653: GREATER
59654: IFFALSE 59674
// tmp := ShrinkArray ( tmp , 4 ) ;
59656: NOP4
59660: PUSH
59661: NOP4
59665: PPUSH
59666: LD_INT 4
59668: PPUSH
59669: NOP4
59673: ST_TO_ADDR
// if not tmp then
59674: NOP4
59678: NOT
59679: IFFALSE 59683
// continue ;
59681: GO 59091
// for j in tmp do
59683: NOP4
59687: PUSH
59688: NOP4
59692: PUSH
59693: FOR_IN
59694: IFFALSE 59953
// begin if IsInUnit ( j ) then
59696: NOP4
59700: PPUSH
59701: NOP4
59705: IFFALSE 59716
// ComExitBuilding ( j ) ;
59707: NOP4
59711: PPUSH
59712: NOP4
// if not j in mc_building_repairs [ i ] then
59716: NOP4
59720: PUSH
59721: NOP4
59725: PUSH
59726: NOP4
59730: ARRAY
59731: IN
59732: NOT
59733: IFFALSE 59791
// begin SetTag ( j , 101 ) ;
59735: NOP4
59739: PPUSH
59740: LD_INT 101
59742: PPUSH
59743: NOP4
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
59747: NOP4
59751: PUSH
59752: NOP4
59756: PPUSH
59757: NOP4
59761: PUSH
59762: NOP4
59766: PUSH
59767: NOP4
59771: ARRAY
59772: PUSH
59773: LD_INT 1
59775: PLUS
59776: PUSH
59777: EMPTY
59778: LIST
59779: LIST
59780: PPUSH
59781: NOP4
59785: PPUSH
59786: NOP4
59790: ST_TO_ADDR
// end ; wait ( 1 ) ;
59791: LD_INT 1
59793: PPUSH
59794: NOP4
// to_repair_tmp := mc_building_need_repair [ i ] ;
59798: NOP4
59802: PUSH
59803: NOP4
59807: PUSH
59808: NOP4
59812: ARRAY
59813: ST_TO_ADDR
// if mc_scan [ i ] then
59814: NOP4
59818: PUSH
59819: NOP4
59823: ARRAY
59824: IFFALSE 59886
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
59826: NOP4
59830: PUSH
59831: NOP4
59835: PUSH
59836: NOP4
59840: ARRAY
59841: PPUSH
59842: LD_INT 3
59844: PUSH
59845: LD_INT 30
59847: PUSH
59848: LD_INT 32
59850: PUSH
59851: EMPTY
59852: LIST
59853: LIST
59854: PUSH
59855: LD_INT 30
59857: PUSH
59858: LD_INT 33
59860: PUSH
59861: EMPTY
59862: LIST
59863: LIST
59864: PUSH
59865: LD_INT 30
59867: PUSH
59868: LD_INT 31
59870: PUSH
59871: EMPTY
59872: LIST
59873: LIST
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: LIST
59879: LIST
59880: PPUSH
59881: NOP4
59885: ST_TO_ADDR
// if not to_repair_tmp then
59886: NOP4
59890: NOT
59891: IFFALSE 59895
// continue ;
59893: GO 59693
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
59895: NOP4
59899: PUSH
59900: NOP4
59904: PPUSH
59905: NOP4
59909: PPUSH
59910: NOP4
59914: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
59915: NOP4
59919: PPUSH
59920: LD_INT 16
59922: PPUSH
59923: NOP4
59927: PUSH
59928: LD_INT 4
59930: ARRAY
59931: PUSH
59932: LD_INT 10
59934: LESS
59935: IFFALSE 59951
// ComRepairBuilding ( j , to_repair ) ;
59937: NOP4
59941: PPUSH
59942: NOP4
59946: PPUSH
59947: NOP4
// end ;
59951: GO 59693
59953: POP
59954: POP
// end ;
59955: GO 59091
59957: POP
59958: POP
// end ;
59959: LD_VAR 0 1
59963: RET
// export function MC_Heal ; var i , j , tmp ; begin
59964: LD_INT 0
59966: PPUSH
59967: PPUSH
59968: PPUSH
59969: PPUSH
// if not mc_bases then
59970: NOP4
59974: NOT
59975: IFFALSE 59979
// exit ;
59977: GO 60381
// for i = 1 to mc_bases do
59979: NOP4
59983: PUSH
59984: DOUBLE
59985: LD_INT 1
59987: DEC
59988: ST_TO_ADDR
59989: NOP4
59993: PUSH
59994: FOR_TO
59995: IFFALSE 60379
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
59997: NOP4
60001: PUSH
60002: NOP4
60006: ARRAY
60007: PUSH
60008: LD_INT 1
60010: ARRAY
60011: NOT
60012: PUSH
60013: NOP4
60017: PUSH
60018: NOP4
60022: ARRAY
60023: PUSH
60024: LD_INT 2
60026: ARRAY
60027: NOT
60028: AND
60029: IFFALSE 60067
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60031: NOP4
60035: PUSH
60036: NOP4
60040: PPUSH
60041: NOP4
60045: PPUSH
60046: EMPTY
60047: PPUSH
60048: NOP4
60052: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60053: NOP4
60057: PPUSH
60058: LD_INT 102
60060: PPUSH
60061: NOP4
// continue ;
60065: GO 59994
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60067: NOP4
60071: PUSH
60072: NOP4
60076: PUSH
60077: NOP4
60081: ARRAY
60082: PPUSH
60083: LD_INT 25
60085: PUSH
60086: LD_INT 4
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: PPUSH
60093: NOP4
60097: ST_TO_ADDR
// if not tmp then
60098: NOP4
60102: NOT
60103: IFFALSE 60107
// continue ;
60105: GO 59994
// if mc_taming [ i ] then
60107: NOP4
60111: PUSH
60112: NOP4
60116: ARRAY
60117: IFFALSE 60141
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60119: NOP4
60123: PUSH
60124: NOP4
60128: PPUSH
60129: NOP4
60133: PPUSH
60134: EMPTY
60135: PPUSH
60136: NOP4
60140: ST_TO_ADDR
// for j in tmp do
60141: NOP4
60145: PUSH
60146: NOP4
60150: PUSH
60151: FOR_IN
60152: IFFALSE 60375
// begin if IsInUnit ( j ) then
60154: NOP4
60158: PPUSH
60159: NOP4
60163: IFFALSE 60174
// ComExitBuilding ( j ) ;
60165: NOP4
60169: PPUSH
60170: NOP4
// if not j in mc_healers [ i ] then
60174: NOP4
60178: PUSH
60179: NOP4
60183: PUSH
60184: NOP4
60188: ARRAY
60189: IN
60190: NOT
60191: IFFALSE 60237
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60193: NOP4
60197: PUSH
60198: NOP4
60202: PPUSH
60203: NOP4
60207: PUSH
60208: NOP4
60212: PUSH
60213: NOP4
60217: ARRAY
60218: PUSH
60219: LD_INT 1
60221: PLUS
60222: PUSH
60223: EMPTY
60224: LIST
60225: LIST
60226: PPUSH
60227: NOP4
60231: PPUSH
60232: NOP4
60236: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60237: NOP4
60241: PPUSH
60242: NOP4
60246: PUSH
60247: LD_INT 102
60249: NONEQUAL
60250: IFFALSE 60264
// SetTag ( j , 102 ) ;
60252: NOP4
60256: PPUSH
60257: LD_INT 102
60259: PPUSH
60260: NOP4
// Wait ( 3 ) ;
60264: LD_INT 3
60266: PPUSH
60267: NOP4
// if mc_need_heal [ i ] [ 1 ] then
60271: NOP4
60275: PUSH
60276: NOP4
60280: ARRAY
60281: PUSH
60282: LD_INT 1
60284: ARRAY
60285: IFFALSE 60317
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60287: NOP4
60291: PPUSH
60292: NOP4
60296: PUSH
60297: NOP4
60301: ARRAY
60302: PUSH
60303: LD_INT 1
60305: ARRAY
60306: PUSH
60307: LD_INT 1
60309: ARRAY
60310: PPUSH
60311: NOP4
60315: GO 60373
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60317: NOP4
60321: PPUSH
60322: NOP4
60326: NOT
60327: PUSH
60328: NOP4
60332: PUSH
60333: NOP4
60337: ARRAY
60338: PUSH
60339: LD_INT 2
60341: ARRAY
60342: AND
60343: IFFALSE 60373
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60345: NOP4
60349: PPUSH
60350: NOP4
60354: PUSH
60355: NOP4
60359: ARRAY
60360: PUSH
60361: LD_INT 2
60363: ARRAY
60364: PUSH
60365: LD_INT 1
60367: ARRAY
60368: PPUSH
60369: NOP4
// end ;
60373: GO 60151
60375: POP
60376: POP
// end ;
60377: GO 59994
60379: POP
60380: POP
// end ;
60381: LD_VAR 0 1
60385: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60386: LD_INT 0
60388: PPUSH
60389: PPUSH
60390: PPUSH
60391: PPUSH
60392: PPUSH
// if not mc_bases then
60393: NOP4
60397: NOT
60398: IFFALSE 60402
// exit ;
60400: GO 61573
// for i = 1 to mc_bases do
60402: NOP4
60406: PUSH
60407: DOUBLE
60408: LD_INT 1
60410: DEC
60411: ST_TO_ADDR
60412: NOP4
60416: PUSH
60417: FOR_TO
60418: IFFALSE 61571
// begin if mc_scan [ i ] then
60420: NOP4
60424: PUSH
60425: NOP4
60429: ARRAY
60430: IFFALSE 60434
// continue ;
60432: GO 60417
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60434: NOP4
60438: PUSH
60439: NOP4
60443: ARRAY
60444: NOT
60445: PUSH
60446: NOP4
60450: PUSH
60451: NOP4
60455: ARRAY
60456: NOT
60457: AND
60458: PUSH
60459: NOP4
60463: PUSH
60464: NOP4
60468: ARRAY
60469: AND
60470: IFFALSE 60508
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60472: NOP4
60476: PUSH
60477: NOP4
60481: PPUSH
60482: NOP4
60486: PPUSH
60487: EMPTY
60488: PPUSH
60489: NOP4
60493: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60494: NOP4
60498: PPUSH
60499: LD_INT 103
60501: PPUSH
60502: NOP4
// continue ;
60506: GO 60417
// end ; if mc_construct_list [ i ] then
60508: NOP4
60512: PUSH
60513: NOP4
60517: ARRAY
60518: IFFALSE 60738
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60520: NOP4
60524: PUSH
60525: NOP4
60529: PUSH
60530: NOP4
60534: ARRAY
60535: PPUSH
60536: LD_INT 25
60538: PUSH
60539: LD_INT 2
60541: PUSH
60542: EMPTY
60543: LIST
60544: LIST
60545: PPUSH
60546: NOP4
60550: PUSH
60551: NOP4
60555: PUSH
60556: NOP4
60560: ARRAY
60561: DIFF
60562: ST_TO_ADDR
// if not tmp then
60563: NOP4
60567: NOT
60568: IFFALSE 60572
// continue ;
60570: GO 60417
// for j in tmp do
60572: NOP4
60576: PUSH
60577: NOP4
60581: PUSH
60582: FOR_IN
60583: IFFALSE 60734
// begin if not mc_builders [ i ] then
60585: NOP4
60589: PUSH
60590: NOP4
60594: ARRAY
60595: NOT
60596: IFFALSE 60654
// begin SetTag ( j , 103 ) ;
60598: NOP4
60602: PPUSH
60603: LD_INT 103
60605: PPUSH
60606: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60610: NOP4
60614: PUSH
60615: NOP4
60619: PPUSH
60620: NOP4
60624: PUSH
60625: NOP4
60629: PUSH
60630: NOP4
60634: ARRAY
60635: PUSH
60636: LD_INT 1
60638: PLUS
60639: PUSH
60640: EMPTY
60641: LIST
60642: LIST
60643: PPUSH
60644: NOP4
60648: PPUSH
60649: NOP4
60653: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60654: NOP4
60658: PPUSH
60659: NOP4
60663: IFFALSE 60674
// ComExitBuilding ( j ) ;
60665: NOP4
60669: PPUSH
60670: NOP4
// wait ( 3 ) ;
60674: LD_INT 3
60676: PPUSH
60677: NOP4
// if not mc_construct_list [ i ] then
60681: NOP4
60685: PUSH
60686: NOP4
60690: ARRAY
60691: NOT
60692: IFFALSE 60696
// break ;
60694: GO 60734
// if not HasTask ( j ) then
60696: NOP4
60700: PPUSH
60701: NOP4
60705: NOT
60706: IFFALSE 60732
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
60708: NOP4
60712: PPUSH
60713: NOP4
60717: PUSH
60718: NOP4
60722: ARRAY
60723: PUSH
60724: LD_INT 1
60726: ARRAY
60727: PPUSH
60728: NOP4
// end ;
60732: GO 60582
60734: POP
60735: POP
// end else
60736: GO 61569
// if mc_build_list [ i ] then
60738: NOP4
60742: PUSH
60743: NOP4
60747: ARRAY
60748: IFFALSE 61569
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60750: NOP4
60754: PUSH
60755: NOP4
60759: PUSH
60760: NOP4
60764: ARRAY
60765: PPUSH
60766: LD_INT 2
60768: PUSH
60769: LD_INT 30
60771: PUSH
60772: LD_INT 0
60774: PUSH
60775: EMPTY
60776: LIST
60777: LIST
60778: PUSH
60779: LD_INT 30
60781: PUSH
60782: LD_INT 1
60784: PUSH
60785: EMPTY
60786: LIST
60787: LIST
60788: PUSH
60789: EMPTY
60790: LIST
60791: LIST
60792: LIST
60793: PPUSH
60794: NOP4
60798: ST_TO_ADDR
// if depot then
60799: NOP4
60803: IFFALSE 60821
// depot := depot [ 1 ] else
60805: NOP4
60809: PUSH
60810: NOP4
60814: PUSH
60815: LD_INT 1
60817: ARRAY
60818: ST_TO_ADDR
60819: GO 60829
// depot := 0 ;
60821: NOP4
60825: PUSH
60826: LD_INT 0
60828: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
60829: NOP4
60833: PUSH
60834: NOP4
60838: ARRAY
60839: PUSH
60840: LD_INT 1
60842: ARRAY
60843: PUSH
60844: LD_INT 1
60846: ARRAY
60847: PPUSH
60848: NOP4
60852: PUSH
60853: NOP4
60857: PUSH
60858: NOP4
60862: ARRAY
60863: PPUSH
60864: LD_INT 2
60866: PUSH
60867: LD_INT 30
60869: PUSH
60870: LD_INT 2
60872: PUSH
60873: EMPTY
60874: LIST
60875: LIST
60876: PUSH
60877: LD_INT 30
60879: PUSH
60880: LD_INT 3
60882: PUSH
60883: EMPTY
60884: LIST
60885: LIST
60886: PUSH
60887: EMPTY
60888: LIST
60889: LIST
60890: LIST
60891: PPUSH
60892: NOP4
60896: NOT
60897: AND
60898: IFFALSE 61003
// begin for j = 1 to mc_build_list [ i ] do
60900: NOP4
60904: PUSH
60905: DOUBLE
60906: LD_INT 1
60908: DEC
60909: ST_TO_ADDR
60910: NOP4
60914: PUSH
60915: NOP4
60919: ARRAY
60920: PUSH
60921: FOR_TO
60922: IFFALSE 61001
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
60924: NOP4
60928: PUSH
60929: NOP4
60933: ARRAY
60934: PUSH
60935: NOP4
60939: ARRAY
60940: PUSH
60941: LD_INT 1
60943: ARRAY
60944: PUSH
60945: LD_INT 2
60947: EQUAL
60948: IFFALSE 60999
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
60950: NOP4
60954: PUSH
60955: NOP4
60959: PPUSH
60960: NOP4
60964: PPUSH
60965: NOP4
60969: PUSH
60970: NOP4
60974: ARRAY
60975: PPUSH
60976: NOP4
60980: PPUSH
60981: LD_INT 1
60983: PPUSH
60984: LD_INT 0
60986: PPUSH
60987: NOP4
60991: PPUSH
60992: NOP4
60996: ST_TO_ADDR
// break ;
60997: GO 61001
// end ;
60999: GO 60921
61001: POP
61002: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61003: NOP4
61007: PUSH
61008: NOP4
61012: ARRAY
61013: PUSH
61014: LD_INT 1
61016: ARRAY
61017: PUSH
61018: LD_INT 1
61020: ARRAY
61021: PUSH
61022: LD_INT 0
61024: EQUAL
61025: PUSH
61026: NOP4
61030: PUSH
61031: NOP4
61035: PPUSH
61036: NOP4
61040: PUSH
61041: NOP4
61045: ARRAY
61046: PUSH
61047: LD_INT 1
61049: ARRAY
61050: PUSH
61051: LD_INT 1
61053: ARRAY
61054: PPUSH
61055: NOP4
61059: PUSH
61060: NOP4
61064: ARRAY
61065: PUSH
61066: LD_INT 1
61068: ARRAY
61069: PUSH
61070: LD_INT 2
61072: ARRAY
61073: PPUSH
61074: NOP4
61078: PUSH
61079: NOP4
61083: ARRAY
61084: PUSH
61085: LD_INT 1
61087: ARRAY
61088: PUSH
61089: LD_INT 3
61091: ARRAY
61092: PPUSH
61093: NOP4
61097: PUSH
61098: NOP4
61102: ARRAY
61103: PUSH
61104: LD_INT 1
61106: ARRAY
61107: PUSH
61108: LD_INT 4
61110: ARRAY
61111: PPUSH
61112: NOP4
61116: AND
61117: OR
61118: IFFALSE 61399
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61120: NOP4
61124: PUSH
61125: NOP4
61129: PUSH
61130: NOP4
61134: ARRAY
61135: PPUSH
61136: LD_INT 25
61138: PUSH
61139: LD_INT 2
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PPUSH
61146: NOP4
61150: PUSH
61151: NOP4
61155: PUSH
61156: NOP4
61160: ARRAY
61161: DIFF
61162: ST_TO_ADDR
// if not tmp then
61163: NOP4
61167: NOT
61168: IFFALSE 61172
// continue ;
61170: GO 60417
// for j in tmp do
61172: NOP4
61176: PUSH
61177: NOP4
61181: PUSH
61182: FOR_IN
61183: IFFALSE 61395
// begin if not mc_builders [ i ] then
61185: NOP4
61189: PUSH
61190: NOP4
61194: ARRAY
61195: NOT
61196: IFFALSE 61254
// begin SetTag ( j , 103 ) ;
61198: NOP4
61202: PPUSH
61203: LD_INT 103
61205: PPUSH
61206: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61210: NOP4
61214: PUSH
61215: NOP4
61219: PPUSH
61220: NOP4
61224: PUSH
61225: NOP4
61229: PUSH
61230: NOP4
61234: ARRAY
61235: PUSH
61236: LD_INT 1
61238: PLUS
61239: PUSH
61240: EMPTY
61241: LIST
61242: LIST
61243: PPUSH
61244: NOP4
61248: PPUSH
61249: NOP4
61253: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61254: NOP4
61258: PPUSH
61259: NOP4
61263: IFFALSE 61274
// ComExitBuilding ( j ) ;
61265: NOP4
61269: PPUSH
61270: NOP4
// wait ( 3 ) ;
61274: LD_INT 3
61276: PPUSH
61277: NOP4
// if not mc_build_list [ i ] then
61281: NOP4
61285: PUSH
61286: NOP4
61290: ARRAY
61291: NOT
61292: IFFALSE 61296
// break ;
61294: GO 61395
// if not HasTask ( j ) then
61296: NOP4
61300: PPUSH
61301: NOP4
61305: NOT
61306: IFFALSE 61393
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61308: NOP4
61312: PPUSH
61313: NOP4
61317: PUSH
61318: NOP4
61322: ARRAY
61323: PUSH
61324: LD_INT 1
61326: ARRAY
61327: PUSH
61328: LD_INT 1
61330: ARRAY
61331: PPUSH
61332: NOP4
61336: PUSH
61337: NOP4
61341: ARRAY
61342: PUSH
61343: LD_INT 1
61345: ARRAY
61346: PUSH
61347: LD_INT 2
61349: ARRAY
61350: PPUSH
61351: NOP4
61355: PUSH
61356: NOP4
61360: ARRAY
61361: PUSH
61362: LD_INT 1
61364: ARRAY
61365: PUSH
61366: LD_INT 3
61368: ARRAY
61369: PPUSH
61370: NOP4
61374: PUSH
61375: NOP4
61379: ARRAY
61380: PUSH
61381: LD_INT 1
61383: ARRAY
61384: PUSH
61385: LD_INT 4
61387: ARRAY
61388: PPUSH
61389: NOP4
// end ;
61393: GO 61182
61395: POP
61396: POP
// end else
61397: GO 61569
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
61399: NOP4
61403: PUSH
61404: NOP4
61408: ARRAY
61409: PPUSH
61410: NOP4
61414: PUSH
61415: NOP4
61419: ARRAY
61420: PUSH
61421: LD_INT 1
61423: ARRAY
61424: PUSH
61425: LD_INT 1
61427: ARRAY
61428: PPUSH
61429: NOP4
61433: PUSH
61434: NOP4
61438: ARRAY
61439: PUSH
61440: LD_INT 1
61442: ARRAY
61443: PUSH
61444: LD_INT 2
61446: ARRAY
61447: PPUSH
61448: NOP4
61452: PUSH
61453: NOP4
61457: ARRAY
61458: PUSH
61459: LD_INT 1
61461: ARRAY
61462: PUSH
61463: LD_INT 3
61465: ARRAY
61466: PPUSH
61467: NOP4
61471: PUSH
61472: NOP4
61476: ARRAY
61477: PUSH
61478: LD_INT 1
61480: ARRAY
61481: PUSH
61482: LD_INT 4
61484: ARRAY
61485: PPUSH
61486: NOP4
61490: PUSH
61491: NOP4
61495: ARRAY
61496: PPUSH
61497: LD_INT 21
61499: PUSH
61500: LD_INT 3
61502: PUSH
61503: EMPTY
61504: LIST
61505: LIST
61506: PPUSH
61507: NOP4
61511: PPUSH
61512: EMPTY
61513: PPUSH
61514: NOP4
61518: NOT
61519: IFFALSE 61569
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61521: NOP4
61525: PUSH
61526: NOP4
61530: PPUSH
61531: NOP4
61535: PPUSH
61536: NOP4
61540: PUSH
61541: NOP4
61545: ARRAY
61546: PPUSH
61547: LD_INT 1
61549: PPUSH
61550: LD_INT 1
61552: NEG
61553: PPUSH
61554: LD_INT 0
61556: PPUSH
61557: NOP4
61561: PPUSH
61562: NOP4
61566: ST_TO_ADDR
// continue ;
61567: GO 60417
// end ; end ; end ;
61569: GO 60417
61571: POP
61572: POP
// end ;
61573: LD_VAR 0 1
61577: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
61578: LD_INT 0
61580: PPUSH
61581: PPUSH
61582: PPUSH
61583: PPUSH
61584: PPUSH
61585: PPUSH
// if not mc_bases then
61586: NOP4
61590: NOT
61591: IFFALSE 61595
// exit ;
61593: GO 62022
// for i = 1 to mc_bases do
61595: NOP4
61599: PUSH
61600: DOUBLE
61601: LD_INT 1
61603: DEC
61604: ST_TO_ADDR
61605: NOP4
61609: PUSH
61610: FOR_TO
61611: IFFALSE 62020
// begin tmp := mc_build_upgrade [ i ] ;
61613: NOP4
61617: PUSH
61618: NOP4
61622: PUSH
61623: NOP4
61627: ARRAY
61628: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
61629: NOP4
61633: PUSH
61634: NOP4
61638: PUSH
61639: NOP4
61643: ARRAY
61644: PPUSH
61645: LD_INT 2
61647: PUSH
61648: LD_INT 30
61650: PUSH
61651: LD_INT 6
61653: PUSH
61654: EMPTY
61655: LIST
61656: LIST
61657: PUSH
61658: LD_INT 30
61660: PUSH
61661: LD_INT 7
61663: PUSH
61664: EMPTY
61665: LIST
61666: LIST
61667: PUSH
61668: EMPTY
61669: LIST
61670: LIST
61671: LIST
61672: PPUSH
61673: NOP4
61677: ST_TO_ADDR
// if not tmp and not lab then
61678: NOP4
61682: NOT
61683: PUSH
61684: NOP4
61688: NOT
61689: AND
61690: IFFALSE 61694
// continue ;
61692: GO 61610
// if tmp then
61694: NOP4
61698: IFFALSE 61818
// for j in tmp do
61700: NOP4
61704: PUSH
61705: NOP4
61709: PUSH
61710: FOR_IN
61711: IFFALSE 61816
// begin if UpgradeCost ( j ) then
61713: NOP4
61717: PPUSH
61718: NOP4
61722: IFFALSE 61814
// begin ComUpgrade ( j ) ;
61724: NOP4
61728: PPUSH
61729: NOP4
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
61733: NOP4
61737: PUSH
61738: NOP4
61742: PPUSH
61743: NOP4
61747: PPUSH
61748: NOP4
61752: PUSH
61753: NOP4
61757: ARRAY
61758: PUSH
61759: NOP4
61763: DIFF
61764: PPUSH
61765: NOP4
61769: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61770: NOP4
61774: PUSH
61775: NOP4
61779: PPUSH
61780: NOP4
61784: PUSH
61785: NOP4
61789: PUSH
61790: NOP4
61794: ARRAY
61795: PUSH
61796: LD_INT 1
61798: PLUS
61799: PUSH
61800: EMPTY
61801: LIST
61802: LIST
61803: PPUSH
61804: NOP4
61808: PPUSH
61809: NOP4
61813: ST_TO_ADDR
// end ; end ;
61814: GO 61710
61816: POP
61817: POP
// if not lab or not mc_lab_upgrade [ i ] then
61818: NOP4
61822: NOT
61823: PUSH
61824: NOP4
61828: PUSH
61829: NOP4
61833: ARRAY
61834: NOT
61835: OR
61836: IFFALSE 61840
// continue ;
61838: GO 61610
// for j in lab do
61840: NOP4
61844: PUSH
61845: NOP4
61849: PUSH
61850: FOR_IN
61851: IFFALSE 62016
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
61853: NOP4
61857: PPUSH
61858: NOP4
61862: PUSH
61863: LD_INT 6
61865: PUSH
61866: LD_INT 7
61868: PUSH
61869: EMPTY
61870: LIST
61871: LIST
61872: IN
61873: PUSH
61874: NOP4
61878: PPUSH
61879: NOP4
61883: PUSH
61884: LD_INT 1
61886: NONEQUAL
61887: AND
61888: IFFALSE 62014
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
61890: NOP4
61894: PPUSH
61895: NOP4
61899: PUSH
61900: NOP4
61904: ARRAY
61905: PUSH
61906: LD_INT 1
61908: ARRAY
61909: PPUSH
61910: NOP4
61914: IFFALSE 62014
// begin ComCancel ( j ) ;
61916: NOP4
61920: PPUSH
61921: NOP4
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
61925: NOP4
61929: PPUSH
61930: NOP4
61934: PUSH
61935: NOP4
61939: ARRAY
61940: PUSH
61941: LD_INT 1
61943: ARRAY
61944: PPUSH
61945: NOP4
// if not j in mc_construct_list [ i ] then
61949: NOP4
61953: PUSH
61954: NOP4
61958: PUSH
61959: NOP4
61963: ARRAY
61964: IN
61965: NOT
61966: IFFALSE 62012
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61968: NOP4
61972: PUSH
61973: NOP4
61977: PPUSH
61978: NOP4
61982: PUSH
61983: NOP4
61987: PUSH
61988: NOP4
61992: ARRAY
61993: PUSH
61994: LD_INT 1
61996: PLUS
61997: PUSH
61998: EMPTY
61999: LIST
62000: LIST
62001: PPUSH
62002: NOP4
62006: PPUSH
62007: NOP4
62011: ST_TO_ADDR
// break ;
62012: GO 62016
// end ; end ; end ;
62014: GO 61850
62016: POP
62017: POP
// end ;
62018: GO 61610
62020: POP
62021: POP
// end ;
62022: LD_VAR 0 1
62026: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62027: LD_INT 0
62029: PPUSH
62030: PPUSH
62031: PPUSH
62032: PPUSH
62033: PPUSH
62034: PPUSH
62035: PPUSH
62036: PPUSH
62037: PPUSH
// if not mc_bases then
62038: NOP4
62042: NOT
62043: IFFALSE 62047
// exit ;
62045: GO 62452
// for i = 1 to mc_bases do
62047: NOP4
62051: PUSH
62052: DOUBLE
62053: LD_INT 1
62055: DEC
62056: ST_TO_ADDR
62057: NOP4
62061: PUSH
62062: FOR_TO
62063: IFFALSE 62450
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62065: NOP4
62069: PUSH
62070: NOP4
62074: ARRAY
62075: NOT
62076: PUSH
62077: NOP4
62081: PUSH
62082: NOP4
62086: ARRAY
62087: PPUSH
62088: LD_INT 30
62090: PUSH
62091: LD_INT 3
62093: PUSH
62094: EMPTY
62095: LIST
62096: LIST
62097: PPUSH
62098: NOP4
62102: NOT
62103: OR
62104: IFFALSE 62108
// continue ;
62106: GO 62062
// busy := false ;
62108: NOP4
62112: PUSH
62113: LD_INT 0
62115: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62116: NOP4
62120: PUSH
62121: NOP4
62125: PUSH
62126: NOP4
62130: ARRAY
62131: PPUSH
62132: LD_INT 30
62134: PUSH
62135: LD_INT 3
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PPUSH
62142: NOP4
62146: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62147: NOP4
62151: PUSH
62152: NOP4
62156: PUSH
62157: NOP4
62161: ARRAY
62162: PPUSH
62163: LD_INT 2
62165: PUSH
62166: LD_INT 30
62168: PUSH
62169: LD_INT 32
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: PUSH
62176: LD_INT 30
62178: PUSH
62179: LD_INT 33
62181: PUSH
62182: EMPTY
62183: LIST
62184: LIST
62185: PUSH
62186: EMPTY
62187: LIST
62188: LIST
62189: LIST
62190: PPUSH
62191: NOP4
62195: ST_TO_ADDR
// if not t then
62196: NOP4
62200: NOT
62201: IFFALSE 62205
// continue ;
62203: GO 62062
// for j in tmp do
62205: NOP4
62209: PUSH
62210: NOP4
62214: PUSH
62215: FOR_IN
62216: IFFALSE 62246
// if not BuildingStatus ( j ) = bs_idle then
62218: NOP4
62222: PPUSH
62223: NOP4
62227: PUSH
62228: LD_INT 2
62230: EQUAL
62231: NOT
62232: IFFALSE 62244
// begin busy := true ;
62234: NOP4
62238: PUSH
62239: LD_INT 1
62241: ST_TO_ADDR
// break ;
62242: GO 62246
// end ;
62244: GO 62215
62246: POP
62247: POP
// if busy then
62248: NOP4
62252: IFFALSE 62256
// continue ;
62254: GO 62062
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62256: NOP4
62260: PUSH
62261: NOP4
62265: PPUSH
62266: LD_INT 35
62268: PUSH
62269: LD_INT 0
62271: PUSH
62272: EMPTY
62273: LIST
62274: LIST
62275: PPUSH
62276: NOP4
62280: ST_TO_ADDR
// if tw then
62281: NOP4
62285: IFFALSE 62362
// begin tw := tw [ 1 ] ;
62287: NOP4
62291: PUSH
62292: NOP4
62296: PUSH
62297: LD_INT 1
62299: ARRAY
62300: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62301: NOP4
62305: PUSH
62306: NOP4
62310: PPUSH
62311: NOP4
62315: PUSH
62316: NOP4
62320: ARRAY
62321: PPUSH
62322: NOP4
62326: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62327: NOP4
62331: PUSH
62332: NOP4
62336: ARRAY
62337: IFFALSE 62360
// if not weapon in mc_allowed_tower_weapons [ i ] then
62339: NOP4
62343: PUSH
62344: NOP4
62348: PUSH
62349: NOP4
62353: ARRAY
62354: IN
62355: NOT
62356: IFFALSE 62360
// continue ;
62358: GO 62062
// end else
62360: GO 62425
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62362: NOP4
62366: PUSH
62367: NOP4
62371: PUSH
62372: NOP4
62376: ARRAY
62377: PPUSH
62378: NOP4
62382: PPUSH
62383: NOP4
62387: ST_TO_ADDR
// if not tmp2 then
62388: NOP4
62392: NOT
62393: IFFALSE 62397
// continue ;
62395: GO 62062
// tw := tmp2 [ 1 ] ;
62397: NOP4
62401: PUSH
62402: NOP4
62406: PUSH
62407: LD_INT 1
62409: ARRAY
62410: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62411: NOP4
62415: PUSH
62416: NOP4
62420: PUSH
62421: LD_INT 2
62423: ARRAY
62424: ST_TO_ADDR
// end ; if not weapon then
62425: NOP4
62429: NOT
62430: IFFALSE 62434
// continue ;
62432: GO 62062
// ComPlaceWeapon ( tw , weapon ) ;
62434: NOP4
62438: PPUSH
62439: NOP4
62443: PPUSH
62444: NOP4
// end ;
62448: GO 62062
62450: POP
62451: POP
// end ;
62452: LD_VAR 0 1
62456: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
62457: LD_INT 0
62459: PPUSH
62460: PPUSH
62461: PPUSH
62462: PPUSH
62463: PPUSH
62464: PPUSH
62465: PPUSH
// if not mc_bases then
62466: NOP4
62470: NOT
62471: IFFALSE 62475
// exit ;
62473: GO 63243
// for i = 1 to mc_bases do
62475: NOP4
62479: PUSH
62480: DOUBLE
62481: LD_INT 1
62483: DEC
62484: ST_TO_ADDR
62485: NOP4
62489: PUSH
62490: FOR_TO
62491: IFFALSE 63241
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62493: NOP4
62497: PUSH
62498: NOP4
62502: ARRAY
62503: NOT
62504: PUSH
62505: NOP4
62509: PUSH
62510: NOP4
62514: ARRAY
62515: PUSH
62516: NOP4
62520: PUSH
62521: NOP4
62525: ARRAY
62526: EQUAL
62527: OR
62528: PUSH
62529: NOP4
62533: PUSH
62534: NOP4
62538: ARRAY
62539: OR
62540: IFFALSE 62544
// continue ;
62542: GO 62490
// if mc_miners [ i ] then
62544: NOP4
62548: PUSH
62549: NOP4
62553: ARRAY
62554: IFFALSE 62928
// begin for j = mc_miners [ i ] downto 1 do
62556: NOP4
62560: PUSH
62561: DOUBLE
62562: NOP4
62566: PUSH
62567: NOP4
62571: ARRAY
62572: INC
62573: ST_TO_ADDR
62574: LD_INT 1
62576: PUSH
62577: FOR_DOWNTO
62578: IFFALSE 62926
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
62580: NOP4
62584: PUSH
62585: NOP4
62589: ARRAY
62590: PUSH
62591: NOP4
62595: ARRAY
62596: PPUSH
62597: NOP4
62601: PUSH
62602: NOP4
62606: PUSH
62607: NOP4
62611: ARRAY
62612: PUSH
62613: NOP4
62617: ARRAY
62618: PPUSH
62619: NOP4
62623: PUSH
62624: LD_INT 1
62626: NONEQUAL
62627: OR
62628: IFFALSE 62691
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
62630: NOP4
62634: PUSH
62635: NOP4
62639: PUSH
62640: NOP4
62644: ARRAY
62645: PUSH
62646: NOP4
62650: PUSH
62651: NOP4
62655: ARRAY
62656: PUSH
62657: NOP4
62661: ARRAY
62662: DIFF
62663: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
62664: NOP4
62668: PUSH
62669: NOP4
62673: PPUSH
62674: NOP4
62678: PPUSH
62679: NOP4
62683: PPUSH
62684: NOP4
62688: ST_TO_ADDR
// continue ;
62689: GO 62577
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
62691: NOP4
62695: PUSH
62696: NOP4
62700: ARRAY
62701: PUSH
62702: NOP4
62706: ARRAY
62707: PPUSH
62708: NOP4
62712: PUSH
62713: LD_INT 1
62715: EQUAL
62716: PUSH
62717: NOP4
62721: PUSH
62722: NOP4
62726: ARRAY
62727: PUSH
62728: NOP4
62732: ARRAY
62733: PPUSH
62734: NOP4
62738: NOT
62739: AND
62740: PUSH
62741: NOP4
62745: PUSH
62746: NOP4
62750: ARRAY
62751: PUSH
62752: NOP4
62756: ARRAY
62757: PPUSH
62758: NOP4
62762: NOT
62763: AND
62764: IFFALSE 62924
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
62766: NOP4
62770: PUSH
62771: NOP4
62775: ARRAY
62776: PUSH
62777: NOP4
62781: ARRAY
62782: PPUSH
62783: NOP4
62787: IFFALSE 62810
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
62789: NOP4
62793: PUSH
62794: NOP4
62798: ARRAY
62799: PUSH
62800: NOP4
62804: ARRAY
62805: PPUSH
62806: NOP4
// if not HasTask ( mc_miners [ i ] [ j ] ) then
62810: NOP4
62814: PUSH
62815: NOP4
62819: ARRAY
62820: PUSH
62821: NOP4
62825: ARRAY
62826: PPUSH
62827: NOP4
62831: NOT
62832: IFFALSE 62924
// begin r := rand ( 1 , mc_mines [ i ] ) ;
62834: NOP4
62838: PUSH
62839: LD_INT 1
62841: PPUSH
62842: NOP4
62846: PUSH
62847: NOP4
62851: ARRAY
62852: PPUSH
62853: NOP4
62857: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
62858: NOP4
62862: PUSH
62863: NOP4
62867: ARRAY
62868: PUSH
62869: NOP4
62873: ARRAY
62874: PPUSH
62875: NOP4
62879: PUSH
62880: NOP4
62884: ARRAY
62885: PUSH
62886: NOP4
62890: ARRAY
62891: PUSH
62892: LD_INT 1
62894: ARRAY
62895: PPUSH
62896: NOP4
62900: PUSH
62901: NOP4
62905: ARRAY
62906: PUSH
62907: NOP4
62911: ARRAY
62912: PUSH
62913: LD_INT 2
62915: ARRAY
62916: PPUSH
62917: LD_INT 0
62919: PPUSH
62920: NOP4
// end ; end ; end ;
62924: GO 62577
62926: POP
62927: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
62928: NOP4
62932: PUSH
62933: NOP4
62937: PUSH
62938: NOP4
62942: ARRAY
62943: PPUSH
62944: LD_INT 2
62946: PUSH
62947: LD_INT 30
62949: PUSH
62950: LD_INT 4
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: PUSH
62957: LD_INT 30
62959: PUSH
62960: LD_INT 5
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: PUSH
62967: LD_INT 30
62969: PUSH
62970: LD_INT 32
62972: PUSH
62973: EMPTY
62974: LIST
62975: LIST
62976: PUSH
62977: EMPTY
62978: LIST
62979: LIST
62980: LIST
62981: LIST
62982: PPUSH
62983: NOP4
62987: ST_TO_ADDR
// if not tmp then
62988: NOP4
62992: NOT
62993: IFFALSE 62997
// continue ;
62995: GO 62490
// list := [ ] ;
62997: NOP4
63001: PUSH
63002: EMPTY
63003: ST_TO_ADDR
// for j in tmp do
63004: NOP4
63008: PUSH
63009: NOP4
63013: PUSH
63014: FOR_IN
63015: IFFALSE 63084
// begin for k in UnitsInside ( j ) do
63017: NOP4
63021: PUSH
63022: NOP4
63026: PPUSH
63027: NOP4
63031: PUSH
63032: FOR_IN
63033: IFFALSE 63080
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63035: NOP4
63039: PPUSH
63040: NOP4
63044: PUSH
63045: LD_INT 1
63047: EQUAL
63048: PUSH
63049: NOP4
63053: PPUSH
63054: NOP4
63058: NOT
63059: AND
63060: IFFALSE 63078
// list := list ^ k ;
63062: NOP4
63066: PUSH
63067: NOP4
63071: PUSH
63072: NOP4
63076: ADD
63077: ST_TO_ADDR
63078: GO 63032
63080: POP
63081: POP
// end ;
63082: GO 63014
63084: POP
63085: POP
// list := list diff mc_miners [ i ] ;
63086: NOP4
63090: PUSH
63091: NOP4
63095: PUSH
63096: NOP4
63100: PUSH
63101: NOP4
63105: ARRAY
63106: DIFF
63107: ST_TO_ADDR
// if not list then
63108: NOP4
63112: NOT
63113: IFFALSE 63117
// continue ;
63115: GO 62490
// k := mc_mines [ i ] - mc_miners [ i ] ;
63117: NOP4
63121: PUSH
63122: NOP4
63126: PUSH
63127: NOP4
63131: ARRAY
63132: PUSH
63133: NOP4
63137: PUSH
63138: NOP4
63142: ARRAY
63143: MINUS
63144: ST_TO_ADDR
// if k > list then
63145: NOP4
63149: PUSH
63150: NOP4
63154: GREATER
63155: IFFALSE 63167
// k := list ;
63157: NOP4
63161: PUSH
63162: NOP4
63166: ST_TO_ADDR
// for j = 1 to k do
63167: NOP4
63171: PUSH
63172: DOUBLE
63173: LD_INT 1
63175: DEC
63176: ST_TO_ADDR
63177: NOP4
63181: PUSH
63182: FOR_TO
63183: IFFALSE 63237
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63185: NOP4
63189: PUSH
63190: NOP4
63194: PPUSH
63195: NOP4
63199: PUSH
63200: NOP4
63204: PUSH
63205: NOP4
63209: ARRAY
63210: PUSH
63211: LD_INT 1
63213: PLUS
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: PPUSH
63219: NOP4
63223: PUSH
63224: NOP4
63228: ARRAY
63229: PPUSH
63230: NOP4
63234: ST_TO_ADDR
63235: GO 63182
63237: POP
63238: POP
// end ;
63239: GO 62490
63241: POP
63242: POP
// end ;
63243: LD_VAR 0 1
63247: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
63248: LD_INT 0
63250: PPUSH
63251: PPUSH
63252: PPUSH
63253: PPUSH
63254: PPUSH
63255: PPUSH
63256: PPUSH
63257: PPUSH
63258: PPUSH
63259: PPUSH
63260: PPUSH
// if not mc_bases then
63261: NOP4
63265: NOT
63266: IFFALSE 63270
// exit ;
63268: GO 65093
// for i = 1 to mc_bases do
63270: NOP4
63274: PUSH
63275: DOUBLE
63276: LD_INT 1
63278: DEC
63279: ST_TO_ADDR
63280: NOP4
63284: PUSH
63285: FOR_TO
63286: IFFALSE 65091
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63288: NOP4
63292: PUSH
63293: NOP4
63297: ARRAY
63298: NOT
63299: PUSH
63300: NOP4
63304: PUSH
63305: NOP4
63309: ARRAY
63310: OR
63311: IFFALSE 63315
// continue ;
63313: GO 63285
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63315: NOP4
63319: PUSH
63320: NOP4
63324: ARRAY
63325: NOT
63326: PUSH
63327: NOP4
63331: PUSH
63332: NOP4
63336: ARRAY
63337: AND
63338: IFFALSE 63376
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63340: NOP4
63344: PUSH
63345: NOP4
63349: PPUSH
63350: NOP4
63354: PPUSH
63355: EMPTY
63356: PPUSH
63357: NOP4
63361: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63362: NOP4
63366: PPUSH
63367: LD_INT 107
63369: PPUSH
63370: NOP4
// continue ;
63374: GO 63285
// end ; target := [ ] ;
63376: NOP4
63380: PUSH
63381: EMPTY
63382: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
63383: NOP4
63387: PUSH
63388: NOP4
63392: PUSH
63393: NOP4
63397: ARRAY
63398: PUSH
63399: LD_INT 1
63401: ARRAY
63402: PPUSH
63403: NOP4
63407: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63408: NOP4
63412: PUSH
63413: NOP4
63417: PUSH
63418: NOP4
63422: ARRAY
63423: PPUSH
63424: LD_INT 2
63426: PUSH
63427: LD_INT 30
63429: PUSH
63430: LD_INT 0
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 30
63439: PUSH
63440: LD_INT 1
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: LIST
63451: PPUSH
63452: NOP4
63456: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63457: NOP4
63461: PUSH
63462: DOUBLE
63463: NOP4
63467: PUSH
63468: NOP4
63472: ARRAY
63473: INC
63474: ST_TO_ADDR
63475: LD_INT 1
63477: PUSH
63478: FOR_DOWNTO
63479: IFFALSE 63724
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63481: NOP4
63485: PUSH
63486: NOP4
63490: ARRAY
63491: PUSH
63492: NOP4
63496: ARRAY
63497: PUSH
63498: LD_INT 2
63500: ARRAY
63501: PPUSH
63502: NOP4
63506: PUSH
63507: NOP4
63511: ARRAY
63512: PUSH
63513: NOP4
63517: ARRAY
63518: PUSH
63519: LD_INT 3
63521: ARRAY
63522: PPUSH
63523: NOP4
63527: PUSH
63528: NOP4
63532: PUSH
63533: NOP4
63537: ARRAY
63538: PUSH
63539: NOP4
63543: ARRAY
63544: PUSH
63545: LD_INT 2
63547: ARRAY
63548: PPUSH
63549: NOP4
63553: PUSH
63554: NOP4
63558: ARRAY
63559: PUSH
63560: NOP4
63564: ARRAY
63565: PUSH
63566: LD_INT 3
63568: ARRAY
63569: PPUSH
63570: NOP4
63574: PUSH
63575: LD_INT 0
63577: EQUAL
63578: AND
63579: IFFALSE 63634
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63581: NOP4
63585: PUSH
63586: NOP4
63590: PUSH
63591: NOP4
63595: ARRAY
63596: PPUSH
63597: NOP4
63601: PPUSH
63602: NOP4
63606: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63607: NOP4
63611: PUSH
63612: NOP4
63616: PPUSH
63617: NOP4
63621: PPUSH
63622: NOP4
63626: PPUSH
63627: NOP4
63631: ST_TO_ADDR
// continue ;
63632: GO 63478
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63634: NOP4
63638: PPUSH
63639: NOP4
63643: PUSH
63644: NOP4
63648: ARRAY
63649: PUSH
63650: NOP4
63654: ARRAY
63655: PUSH
63656: LD_INT 2
63658: ARRAY
63659: PPUSH
63660: NOP4
63664: PUSH
63665: NOP4
63669: ARRAY
63670: PUSH
63671: NOP4
63675: ARRAY
63676: PUSH
63677: LD_INT 3
63679: ARRAY
63680: PPUSH
63681: LD_INT 30
63683: PPUSH
63684: NOP4
63688: PUSH
63689: LD_INT 4
63691: ARRAY
63692: PUSH
63693: LD_INT 0
63695: EQUAL
63696: IFFALSE 63722
// begin target := mc_crates [ i ] [ j ] ;
63698: NOP4
63702: PUSH
63703: NOP4
63707: PUSH
63708: NOP4
63712: ARRAY
63713: PUSH
63714: NOP4
63718: ARRAY
63719: ST_TO_ADDR
// break ;
63720: GO 63724
// end ; end ;
63722: GO 63478
63724: POP
63725: POP
// if not target then
63726: NOP4
63730: NOT
63731: IFFALSE 63735
// continue ;
63733: GO 63285
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
63735: NOP4
63739: PUSH
63740: NOP4
63744: PUSH
63745: NOP4
63749: ARRAY
63750: PPUSH
63751: LD_INT 2
63753: PUSH
63754: LD_INT 3
63756: PUSH
63757: LD_INT 58
63759: PUSH
63760: EMPTY
63761: LIST
63762: PUSH
63763: EMPTY
63764: LIST
63765: LIST
63766: PUSH
63767: LD_INT 61
63769: PUSH
63770: EMPTY
63771: LIST
63772: PUSH
63773: LD_INT 33
63775: PUSH
63776: LD_INT 5
63778: PUSH
63779: EMPTY
63780: LIST
63781: LIST
63782: PUSH
63783: LD_INT 33
63785: PUSH
63786: LD_INT 3
63788: PUSH
63789: EMPTY
63790: LIST
63791: LIST
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: LIST
63797: LIST
63798: LIST
63799: PUSH
63800: LD_INT 2
63802: PUSH
63803: LD_INT 34
63805: PUSH
63806: LD_INT 32
63808: PUSH
63809: EMPTY
63810: LIST
63811: LIST
63812: PUSH
63813: LD_INT 34
63815: PUSH
63816: LD_INT 51
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: PUSH
63823: LD_INT 34
63825: PUSH
63826: LD_INT 12
63828: PUSH
63829: EMPTY
63830: LIST
63831: LIST
63832: PUSH
63833: EMPTY
63834: LIST
63835: LIST
63836: LIST
63837: LIST
63838: PUSH
63839: EMPTY
63840: LIST
63841: LIST
63842: PPUSH
63843: NOP4
63847: ST_TO_ADDR
// if not cargo then
63848: NOP4
63852: NOT
63853: IFFALSE 64559
// begin if mc_crates_collector [ i ] < 5 then
63855: NOP4
63859: PUSH
63860: NOP4
63864: ARRAY
63865: PUSH
63866: LD_INT 5
63868: LESS
63869: IFFALSE 64235
// begin if mc_ape [ i ] then
63871: NOP4
63875: PUSH
63876: NOP4
63880: ARRAY
63881: IFFALSE 63928
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
63883: NOP4
63887: PUSH
63888: NOP4
63892: PUSH
63893: NOP4
63897: ARRAY
63898: PPUSH
63899: LD_INT 25
63901: PUSH
63902: LD_INT 16
63904: PUSH
63905: EMPTY
63906: LIST
63907: LIST
63908: PUSH
63909: LD_INT 24
63911: PUSH
63912: LD_INT 750
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: PUSH
63919: EMPTY
63920: LIST
63921: LIST
63922: PPUSH
63923: NOP4
63927: ST_TO_ADDR
// if not tmp then
63928: NOP4
63932: NOT
63933: IFFALSE 63980
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
63935: NOP4
63939: PUSH
63940: NOP4
63944: PUSH
63945: NOP4
63949: ARRAY
63950: PPUSH
63951: LD_INT 25
63953: PUSH
63954: LD_INT 2
63956: PUSH
63957: EMPTY
63958: LIST
63959: LIST
63960: PUSH
63961: LD_INT 24
63963: PUSH
63964: LD_INT 750
63966: PUSH
63967: EMPTY
63968: LIST
63969: LIST
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PPUSH
63975: NOP4
63979: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
63980: NOP4
63984: PUSH
63985: NOP4
63989: ARRAY
63990: PUSH
63991: NOP4
63995: PUSH
63996: NOP4
64000: ARRAY
64001: PPUSH
64002: LD_INT 25
64004: PUSH
64005: LD_INT 2
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PUSH
64012: LD_INT 24
64014: PUSH
64015: LD_INT 750
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: PPUSH
64026: NOP4
64030: AND
64031: PUSH
64032: NOP4
64036: PUSH
64037: LD_INT 5
64039: LESS
64040: AND
64041: IFFALSE 64123
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64043: NOP4
64047: PUSH
64048: NOP4
64052: PUSH
64053: NOP4
64057: ARRAY
64058: PPUSH
64059: LD_INT 25
64061: PUSH
64062: LD_INT 2
64064: PUSH
64065: EMPTY
64066: LIST
64067: LIST
64068: PUSH
64069: LD_INT 24
64071: PUSH
64072: LD_INT 750
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: EMPTY
64080: LIST
64081: LIST
64082: PPUSH
64083: NOP4
64087: PUSH
64088: FOR_IN
64089: IFFALSE 64121
// begin tmp := tmp union j ;
64091: NOP4
64095: PUSH
64096: NOP4
64100: PUSH
64101: NOP4
64105: UNION
64106: ST_TO_ADDR
// if tmp >= 5 then
64107: NOP4
64111: PUSH
64112: LD_INT 5
64114: GREATEREQUAL
64115: IFFALSE 64119
// break ;
64117: GO 64121
// end ;
64119: GO 64088
64121: POP
64122: POP
// end ; if not tmp then
64123: NOP4
64127: NOT
64128: IFFALSE 64132
// continue ;
64130: GO 63285
// for j in tmp do
64132: NOP4
64136: PUSH
64137: NOP4
64141: PUSH
64142: FOR_IN
64143: IFFALSE 64233
// if not GetTag ( j ) then
64145: NOP4
64149: PPUSH
64150: NOP4
64154: NOT
64155: IFFALSE 64231
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64157: NOP4
64161: PUSH
64162: NOP4
64166: PPUSH
64167: NOP4
64171: PUSH
64172: NOP4
64176: PUSH
64177: NOP4
64181: ARRAY
64182: PUSH
64183: LD_INT 1
64185: PLUS
64186: PUSH
64187: EMPTY
64188: LIST
64189: LIST
64190: PPUSH
64191: NOP4
64195: PPUSH
64196: NOP4
64200: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64201: NOP4
64205: PPUSH
64206: LD_INT 107
64208: PPUSH
64209: NOP4
// if mc_crates_collector [ i ] >= 5 then
64213: NOP4
64217: PUSH
64218: NOP4
64222: ARRAY
64223: PUSH
64224: LD_INT 5
64226: GREATEREQUAL
64227: IFFALSE 64231
// break ;
64229: GO 64233
// end ;
64231: GO 64142
64233: POP
64234: POP
// end ; if mc_crates_collector [ i ] and target then
64235: NOP4
64239: PUSH
64240: NOP4
64244: ARRAY
64245: PUSH
64246: NOP4
64250: AND
64251: IFFALSE 64557
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64253: NOP4
64257: PUSH
64258: NOP4
64262: ARRAY
64263: PUSH
64264: NOP4
64268: PUSH
64269: LD_INT 1
64271: ARRAY
64272: LESS
64273: IFFALSE 64293
// tmp := mc_crates_collector [ i ] else
64275: NOP4
64279: PUSH
64280: NOP4
64284: PUSH
64285: NOP4
64289: ARRAY
64290: ST_TO_ADDR
64291: GO 64307
// tmp := target [ 1 ] ;
64293: NOP4
64297: PUSH
64298: NOP4
64302: PUSH
64303: LD_INT 1
64305: ARRAY
64306: ST_TO_ADDR
// k := 0 ;
64307: NOP4
64311: PUSH
64312: LD_INT 0
64314: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64315: NOP4
64319: PUSH
64320: NOP4
64324: PUSH
64325: NOP4
64329: ARRAY
64330: PUSH
64331: FOR_IN
64332: IFFALSE 64555
// begin k := k + 1 ;
64334: NOP4
64338: PUSH
64339: NOP4
64343: PUSH
64344: LD_INT 1
64346: PLUS
64347: ST_TO_ADDR
// if k > tmp then
64348: NOP4
64352: PUSH
64353: NOP4
64357: GREATER
64358: IFFALSE 64362
// break ;
64360: GO 64555
// if not GetClass ( j ) in [ 2 , 16 ] then
64362: NOP4
64366: PPUSH
64367: NOP4
64371: PUSH
64372: LD_INT 2
64374: PUSH
64375: LD_INT 16
64377: PUSH
64378: EMPTY
64379: LIST
64380: LIST
64381: IN
64382: NOT
64383: IFFALSE 64436
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64385: NOP4
64389: PUSH
64390: NOP4
64394: PPUSH
64395: NOP4
64399: PPUSH
64400: NOP4
64404: PUSH
64405: NOP4
64409: ARRAY
64410: PUSH
64411: NOP4
64415: DIFF
64416: PPUSH
64417: NOP4
64421: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64422: NOP4
64426: PPUSH
64427: LD_INT 0
64429: PPUSH
64430: NOP4
// continue ;
64434: GO 64331
// end ; if IsInUnit ( j ) then
64436: NOP4
64440: PPUSH
64441: NOP4
64445: IFFALSE 64456
// ComExitBuilding ( j ) ;
64447: NOP4
64451: PPUSH
64452: NOP4
// wait ( 3 ) ;
64456: LD_INT 3
64458: PPUSH
64459: NOP4
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
64463: NOP4
64467: PPUSH
64468: NOP4
64472: PUSH
64473: NOP4
64477: PPUSH
64478: NOP4
64482: PUSH
64483: LD_INT 2
64485: ARRAY
64486: PPUSH
64487: NOP4
64491: PUSH
64492: LD_INT 3
64494: ARRAY
64495: PPUSH
64496: LD_INT 30
64498: PPUSH
64499: NOP4
64503: PUSH
64504: LD_INT 4
64506: ARRAY
64507: AND
64508: IFFALSE 64526
// ComStandNearbyBuilding ( j , depot ) else
64510: NOP4
64514: PPUSH
64515: NOP4
64519: PPUSH
64520: NOP4
64524: GO 64553
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64526: NOP4
64530: PPUSH
64531: NOP4
64535: PUSH
64536: LD_INT 2
64538: ARRAY
64539: PPUSH
64540: NOP4
64544: PUSH
64545: LD_INT 3
64547: ARRAY
64548: PPUSH
64549: NOP4
// end ;
64553: GO 64331
64555: POP
64556: POP
// end ; end else
64557: GO 65089
// begin for j in cargo do
64559: NOP4
64563: PUSH
64564: NOP4
64568: PUSH
64569: FOR_IN
64570: IFFALSE 65087
// begin if GetTag ( j ) <> 0 then
64572: NOP4
64576: PPUSH
64577: NOP4
64581: PUSH
64582: LD_INT 0
64584: NONEQUAL
64585: IFFALSE 64589
// continue ;
64587: GO 64569
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64589: NOP4
64593: PPUSH
64594: NOP4
64598: PUSH
64599: LD_INT 1000
64601: LESS
64602: PUSH
64603: NOP4
64607: PPUSH
64608: NOP4
64612: PUSH
64613: NOP4
64617: ARRAY
64618: PPUSH
64619: NOP4
64623: NOT
64624: AND
64625: IFFALSE 64647
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64627: NOP4
64631: PPUSH
64632: NOP4
64636: PUSH
64637: NOP4
64641: ARRAY
64642: PPUSH
64643: NOP4
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64647: NOP4
64651: PPUSH
64652: NOP4
64656: PUSH
64657: LD_INT 1000
64659: LESS
64660: PUSH
64661: NOP4
64665: PPUSH
64666: NOP4
64670: PUSH
64671: NOP4
64675: ARRAY
64676: PPUSH
64677: NOP4
64681: AND
64682: IFFALSE 64686
// continue ;
64684: GO 64569
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64686: NOP4
64690: PPUSH
64691: NOP4
64695: PUSH
64696: LD_INT 2
64698: EQUAL
64699: PUSH
64700: NOP4
64704: PPUSH
64705: NOP4
64709: PUSH
64710: LD_INT 15
64712: LESS
64713: AND
64714: IFFALSE 64718
// continue ;
64716: GO 64569
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64718: NOP4
64722: PPUSH
64723: NOP4
64727: PUSH
64728: LD_INT 1
64730: EQUAL
64731: PUSH
64732: NOP4
64736: PPUSH
64737: NOP4
64741: PUSH
64742: LD_INT 10
64744: LESS
64745: AND
64746: IFFALSE 65026
// begin if not depot then
64748: NOP4
64752: NOT
64753: IFFALSE 64757
// continue ;
64755: GO 64569
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
64757: NOP4
64761: PPUSH
64762: NOP4
64766: PPUSH
64767: NOP4
64771: PPUSH
64772: NOP4
64776: PPUSH
64777: NOP4
64781: PUSH
64782: LD_INT 6
64784: LESS
64785: IFFALSE 64801
// SetFuel ( j , 100 ) else
64787: NOP4
64791: PPUSH
64792: LD_INT 100
64794: PPUSH
64795: NOP4
64799: GO 65026
// if GetFuel ( j ) = 0 then
64801: NOP4
64805: PPUSH
64806: NOP4
64810: PUSH
64811: LD_INT 0
64813: EQUAL
64814: IFFALSE 65026
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
64816: NOP4
64820: PUSH
64821: NOP4
64825: PPUSH
64826: NOP4
64830: PPUSH
64831: NOP4
64835: PUSH
64836: NOP4
64840: ARRAY
64841: PUSH
64842: NOP4
64846: DIFF
64847: PPUSH
64848: NOP4
64852: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
64853: NOP4
64857: PPUSH
64858: NOP4
64862: PUSH
64863: LD_INT 1
64865: EQUAL
64866: IFFALSE 64882
// ComExitVehicle ( IsInUnit ( j ) ) ;
64868: NOP4
64872: PPUSH
64873: NOP4
64877: PPUSH
64878: NOP4
// if GetControl ( j ) = control_remote then
64882: NOP4
64886: PPUSH
64887: NOP4
64891: PUSH
64892: LD_INT 2
64894: EQUAL
64895: IFFALSE 64906
// ComUnlink ( j ) ;
64897: NOP4
64901: PPUSH
64902: NOP4
// fac := MC_GetBuildings ( i , b_factory ) ;
64906: NOP4
64910: PUSH
64911: NOP4
64915: PPUSH
64916: LD_INT 3
64918: PPUSH
64919: NOP4
64923: ST_TO_ADDR
// if fac then
64924: NOP4
64928: IFFALSE 65024
// begin for k in fac do
64930: NOP4
64934: PUSH
64935: NOP4
64939: PUSH
64940: FOR_IN
64941: IFFALSE 65022
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
64943: NOP4
64947: PUSH
64948: NOP4
64952: PPUSH
64953: NOP4
64957: PPUSH
64958: NOP4
64962: PPUSH
64963: NOP4
64967: PPUSH
64968: NOP4
64972: PPUSH
64973: NOP4
64977: PPUSH
64978: NOP4
64982: PPUSH
64983: NOP4
64987: PPUSH
64988: NOP4
64992: PPUSH
64993: NOP4
64997: ST_TO_ADDR
// if components then
64998: NOP4
65002: IFFALSE 65020
// begin MC_InsertProduceList ( i , components ) ;
65004: NOP4
65008: PPUSH
65009: NOP4
65013: PPUSH
65014: NOP4
// break ;
65018: GO 65022
// end ; end ;
65020: GO 64940
65022: POP
65023: POP
// end ; continue ;
65024: GO 64569
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65026: NOP4
65030: PPUSH
65031: LD_INT 1
65033: PPUSH
65034: NOP4
65038: PUSH
65039: LD_INT 100
65041: LESS
65042: PUSH
65043: NOP4
65047: PPUSH
65048: NOP4
65052: NOT
65053: AND
65054: IFFALSE 65083
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65056: NOP4
65060: PPUSH
65061: NOP4
65065: PUSH
65066: LD_INT 2
65068: ARRAY
65069: PPUSH
65070: NOP4
65074: PUSH
65075: LD_INT 3
65077: ARRAY
65078: PPUSH
65079: NOP4
// break ;
65083: GO 65087
// end ;
65085: GO 64569
65087: POP
65088: POP
// end ; end ;
65089: GO 63285
65091: POP
65092: POP
// end ;
65093: LD_VAR 0 1
65097: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65098: LD_INT 0
65100: PPUSH
65101: PPUSH
65102: PPUSH
65103: PPUSH
// if not mc_bases then
65104: NOP4
65108: NOT
65109: IFFALSE 65113
// exit ;
65111: GO 65274
// for i = 1 to mc_bases do
65113: NOP4
65117: PUSH
65118: DOUBLE
65119: LD_INT 1
65121: DEC
65122: ST_TO_ADDR
65123: NOP4
65127: PUSH
65128: FOR_TO
65129: IFFALSE 65272
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65131: NOP4
65135: PUSH
65136: NOP4
65140: PUSH
65141: NOP4
65145: ARRAY
65146: PUSH
65147: NOP4
65151: PUSH
65152: NOP4
65156: ARRAY
65157: UNION
65158: PPUSH
65159: LD_INT 33
65161: PUSH
65162: LD_INT 2
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PPUSH
65169: NOP4
65173: ST_TO_ADDR
// if tmp then
65174: NOP4
65178: IFFALSE 65270
// for j in tmp do
65180: NOP4
65184: PUSH
65185: NOP4
65189: PUSH
65190: FOR_IN
65191: IFFALSE 65268
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65193: NOP4
65197: PPUSH
65198: NOP4
65202: NOT
65203: PUSH
65204: NOP4
65208: PPUSH
65209: NOP4
65213: PUSH
65214: LD_INT 250
65216: GREATEREQUAL
65217: AND
65218: IFFALSE 65231
// Connect ( j ) else
65220: NOP4
65224: PPUSH
65225: NOP4
65229: GO 65266
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65231: NOP4
65235: PPUSH
65236: NOP4
65240: PUSH
65241: LD_INT 250
65243: LESS
65244: PUSH
65245: NOP4
65249: PPUSH
65250: NOP4
65254: AND
65255: IFFALSE 65266
// ComUnlink ( j ) ;
65257: NOP4
65261: PPUSH
65262: NOP4
65266: GO 65190
65268: POP
65269: POP
// end ;
65270: GO 65128
65272: POP
65273: POP
// end ;
65274: LD_VAR 0 1
65278: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65279: LD_INT 0
65281: PPUSH
65282: PPUSH
65283: PPUSH
65284: PPUSH
65285: PPUSH
// if not mc_bases then
65286: NOP4
65290: NOT
65291: IFFALSE 65295
// exit ;
65293: GO 65740
// for i = 1 to mc_bases do
65295: NOP4
65299: PUSH
65300: DOUBLE
65301: LD_INT 1
65303: DEC
65304: ST_TO_ADDR
65305: NOP4
65309: PUSH
65310: FOR_TO
65311: IFFALSE 65738
// begin if not mc_produce [ i ] then
65313: NOP4
65317: PUSH
65318: NOP4
65322: ARRAY
65323: NOT
65324: IFFALSE 65328
// continue ;
65326: GO 65310
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65328: NOP4
65332: PUSH
65333: NOP4
65337: PUSH
65338: NOP4
65342: ARRAY
65343: PPUSH
65344: LD_INT 30
65346: PUSH
65347: LD_INT 3
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PPUSH
65354: NOP4
65358: ST_TO_ADDR
// if not fac then
65359: NOP4
65363: NOT
65364: IFFALSE 65368
// continue ;
65366: GO 65310
// for j in fac do
65368: NOP4
65372: PUSH
65373: NOP4
65377: PUSH
65378: FOR_IN
65379: IFFALSE 65734
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65381: NOP4
65385: PPUSH
65386: NOP4
65390: PUSH
65391: LD_INT 2
65393: NONEQUAL
65394: PUSH
65395: NOP4
65399: PPUSH
65400: LD_INT 15
65402: PPUSH
65403: NOP4
65407: PUSH
65408: LD_INT 4
65410: ARRAY
65411: OR
65412: IFFALSE 65416
// continue ;
65414: GO 65378
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65416: NOP4
65420: PPUSH
65421: NOP4
65425: PUSH
65426: NOP4
65430: ARRAY
65431: PUSH
65432: LD_INT 1
65434: ARRAY
65435: PUSH
65436: LD_INT 1
65438: ARRAY
65439: PPUSH
65440: NOP4
65444: PUSH
65445: NOP4
65449: ARRAY
65450: PUSH
65451: LD_INT 1
65453: ARRAY
65454: PUSH
65455: LD_INT 2
65457: ARRAY
65458: PPUSH
65459: NOP4
65463: PUSH
65464: NOP4
65468: ARRAY
65469: PUSH
65470: LD_INT 1
65472: ARRAY
65473: PUSH
65474: LD_INT 3
65476: ARRAY
65477: PPUSH
65478: NOP4
65482: PUSH
65483: NOP4
65487: ARRAY
65488: PUSH
65489: LD_INT 1
65491: ARRAY
65492: PUSH
65493: LD_INT 4
65495: ARRAY
65496: PPUSH
65497: NOP4
65501: PUSH
65502: NOP4
65506: PPUSH
65507: NOP4
65511: PUSH
65512: NOP4
65516: ARRAY
65517: PUSH
65518: LD_INT 1
65520: ARRAY
65521: PUSH
65522: LD_INT 1
65524: ARRAY
65525: PUSH
65526: NOP4
65530: PUSH
65531: NOP4
65535: ARRAY
65536: PUSH
65537: LD_INT 1
65539: ARRAY
65540: PUSH
65541: LD_INT 2
65543: ARRAY
65544: PUSH
65545: NOP4
65549: PUSH
65550: NOP4
65554: ARRAY
65555: PUSH
65556: LD_INT 1
65558: ARRAY
65559: PUSH
65560: LD_INT 3
65562: ARRAY
65563: PUSH
65564: NOP4
65568: PUSH
65569: NOP4
65573: ARRAY
65574: PUSH
65575: LD_INT 1
65577: ARRAY
65578: PUSH
65579: LD_INT 4
65581: ARRAY
65582: PUSH
65583: EMPTY
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: PPUSH
65589: NOP4
65593: AND
65594: IFFALSE 65732
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65596: NOP4
65600: PPUSH
65601: NOP4
65605: PUSH
65606: NOP4
65610: ARRAY
65611: PUSH
65612: LD_INT 1
65614: ARRAY
65615: PUSH
65616: LD_INT 1
65618: ARRAY
65619: PPUSH
65620: NOP4
65624: PUSH
65625: NOP4
65629: ARRAY
65630: PUSH
65631: LD_INT 1
65633: ARRAY
65634: PUSH
65635: LD_INT 2
65637: ARRAY
65638: PPUSH
65639: NOP4
65643: PUSH
65644: NOP4
65648: ARRAY
65649: PUSH
65650: LD_INT 1
65652: ARRAY
65653: PUSH
65654: LD_INT 3
65656: ARRAY
65657: PPUSH
65658: NOP4
65662: PUSH
65663: NOP4
65667: ARRAY
65668: PUSH
65669: LD_INT 1
65671: ARRAY
65672: PUSH
65673: LD_INT 4
65675: ARRAY
65676: PPUSH
65677: NOP4
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65681: NOP4
65685: PUSH
65686: NOP4
65690: PUSH
65691: NOP4
65695: ARRAY
65696: PPUSH
65697: LD_INT 1
65699: PPUSH
65700: NOP4
65704: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65705: NOP4
65709: PUSH
65710: NOP4
65714: PPUSH
65715: NOP4
65719: PPUSH
65720: NOP4
65724: PPUSH
65725: NOP4
65729: ST_TO_ADDR
// break ;
65730: GO 65734
// end ; end ;
65732: GO 65378
65734: POP
65735: POP
// end ;
65736: GO 65310
65738: POP
65739: POP
// end ;
65740: LD_VAR 0 1
65744: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
65745: LD_INT 0
65747: PPUSH
65748: PPUSH
65749: PPUSH
// if not mc_bases then
65750: NOP4
65754: NOT
65755: IFFALSE 65759
// exit ;
65757: GO 65848
// for i = 1 to mc_bases do
65759: NOP4
65763: PUSH
65764: DOUBLE
65765: LD_INT 1
65767: DEC
65768: ST_TO_ADDR
65769: NOP4
65773: PUSH
65774: FOR_TO
65775: IFFALSE 65846
// begin if mc_attack [ i ] then
65777: NOP4
65781: PUSH
65782: NOP4
65786: ARRAY
65787: IFFALSE 65844
// begin tmp := mc_attack [ i ] [ 1 ] ;
65789: NOP4
65793: PUSH
65794: NOP4
65798: PUSH
65799: NOP4
65803: ARRAY
65804: PUSH
65805: LD_INT 1
65807: ARRAY
65808: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
65809: NOP4
65813: PUSH
65814: NOP4
65818: PPUSH
65819: NOP4
65823: PPUSH
65824: EMPTY
65825: PPUSH
65826: NOP4
65830: ST_TO_ADDR
// Attack ( tmp ) ;
65831: NOP4
65835: PPUSH
65836: NOP4
// exit ;
65840: POP
65841: POP
65842: GO 65848
// end ; end ;
65844: GO 65774
65846: POP
65847: POP
// end ;
65848: LD_VAR 0 1
65852: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
65853: LD_INT 0
65855: PPUSH
65856: PPUSH
65857: PPUSH
65858: PPUSH
65859: PPUSH
65860: PPUSH
65861: PPUSH
// if not mc_bases then
65862: NOP4
65866: NOT
65867: IFFALSE 65871
// exit ;
65869: GO 66728
// for i = 1 to mc_bases do
65871: NOP4
65875: PUSH
65876: DOUBLE
65877: LD_INT 1
65879: DEC
65880: ST_TO_ADDR
65881: NOP4
65885: PUSH
65886: FOR_TO
65887: IFFALSE 66726
// begin if not mc_bases [ i ] then
65889: NOP4
65893: PUSH
65894: NOP4
65898: ARRAY
65899: NOT
65900: IFFALSE 65904
// continue ;
65902: GO 65886
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
65904: NOP4
65908: PUSH
65909: NOP4
65913: PUSH
65914: NOP4
65918: ARRAY
65919: PUSH
65920: LD_INT 1
65922: ARRAY
65923: PPUSH
65924: NOP4
65928: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
65929: NOP4
65933: PUSH
65934: NOP4
65938: PPUSH
65939: NOP4
65943: PPUSH
65944: NOP4
65948: PUSH
65949: NOP4
65953: ARRAY
65954: PUSH
65955: LD_INT 1
65957: ARRAY
65958: PPUSH
65959: NOP4
65963: PPUSH
65964: NOP4
65968: PUSH
65969: NOP4
65973: ARRAY
65974: PPUSH
65975: NOP4
65979: PPUSH
65980: NOP4
65984: ST_TO_ADDR
// if not mc_scan [ i ] then
65985: NOP4
65989: PUSH
65990: NOP4
65994: ARRAY
65995: NOT
65996: IFFALSE 66174
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
65998: NOP4
66002: PUSH
66003: NOP4
66007: PPUSH
66008: NOP4
66012: PPUSH
66013: LD_INT 0
66015: PPUSH
66016: NOP4
66020: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66021: NOP4
66025: PUSH
66026: NOP4
66030: PUSH
66031: NOP4
66035: ARRAY
66036: PPUSH
66037: LD_INT 2
66039: PUSH
66040: LD_INT 25
66042: PUSH
66043: LD_INT 5
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 25
66052: PUSH
66053: LD_INT 8
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 25
66062: PUSH
66063: LD_INT 9
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: PUSH
66070: EMPTY
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: PPUSH
66076: NOP4
66080: ST_TO_ADDR
// if not tmp then
66081: NOP4
66085: NOT
66086: IFFALSE 66090
// continue ;
66088: GO 65886
// for j in tmp do
66090: NOP4
66094: PUSH
66095: NOP4
66099: PUSH
66100: FOR_IN
66101: IFFALSE 66172
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66103: NOP4
66107: PPUSH
66108: NOP4
66112: PPUSH
66113: NOP4
66117: PUSH
66118: LD_INT 5
66120: EQUAL
66121: PUSH
66122: NOP4
66126: PPUSH
66127: NOP4
66131: PUSH
66132: LD_INT 1
66134: EQUAL
66135: AND
66136: PUSH
66137: NOP4
66141: PPUSH
66142: NOP4
66146: NOT
66147: AND
66148: PUSH
66149: NOP4
66153: AND
66154: IFFALSE 66170
// ComChangeProfession ( j , class ) ;
66156: NOP4
66160: PPUSH
66161: NOP4
66165: PPUSH
66166: NOP4
66170: GO 66100
66172: POP
66173: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
66174: NOP4
66178: PUSH
66179: NOP4
66183: ARRAY
66184: PUSH
66185: NOP4
66189: PUSH
66190: NOP4
66194: ARRAY
66195: NOT
66196: AND
66197: PUSH
66198: NOP4
66202: PUSH
66203: NOP4
66207: ARRAY
66208: NOT
66209: AND
66210: PUSH
66211: NOP4
66215: PUSH
66216: NOP4
66220: ARRAY
66221: PPUSH
66222: LD_INT 50
66224: PUSH
66225: EMPTY
66226: LIST
66227: PUSH
66228: LD_INT 2
66230: PUSH
66231: LD_INT 30
66233: PUSH
66234: LD_INT 32
66236: PUSH
66237: EMPTY
66238: LIST
66239: LIST
66240: PUSH
66241: LD_INT 30
66243: PUSH
66244: LD_INT 33
66246: PUSH
66247: EMPTY
66248: LIST
66249: LIST
66250: PUSH
66251: LD_INT 30
66253: PUSH
66254: LD_INT 4
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 30
66263: PUSH
66264: LD_INT 5
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: LIST
66275: LIST
66276: LIST
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PPUSH
66282: NOP4
66286: PUSH
66287: LD_INT 4
66289: LESS
66290: PUSH
66291: NOP4
66295: PUSH
66296: NOP4
66300: ARRAY
66301: PPUSH
66302: LD_INT 3
66304: PUSH
66305: LD_INT 24
66307: PUSH
66308: LD_INT 1000
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: EMPTY
66316: LIST
66317: LIST
66318: PUSH
66319: LD_INT 2
66321: PUSH
66322: LD_INT 30
66324: PUSH
66325: LD_INT 0
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PUSH
66332: LD_INT 30
66334: PUSH
66335: LD_INT 1
66337: PUSH
66338: EMPTY
66339: LIST
66340: LIST
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: LIST
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PPUSH
66351: NOP4
66355: OR
66356: AND
66357: IFFALSE 66608
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
66359: NOP4
66363: PUSH
66364: NOP4
66368: PPUSH
66369: NOP4
66373: PPUSH
66374: LD_INT 1
66376: PPUSH
66377: NOP4
66381: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66382: NOP4
66386: PUSH
66387: NOP4
66391: PUSH
66392: NOP4
66396: ARRAY
66397: PPUSH
66398: LD_INT 2
66400: PUSH
66401: LD_INT 25
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 25
66413: PUSH
66414: LD_INT 5
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 25
66423: PUSH
66424: LD_INT 8
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: LD_INT 25
66433: PUSH
66434: LD_INT 9
66436: PUSH
66437: EMPTY
66438: LIST
66439: LIST
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: PPUSH
66448: NOP4
66452: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66453: NOP4
66457: PUSH
66458: NOP4
66462: PUSH
66463: NOP4
66467: PPUSH
66468: LD_INT 18
66470: PPUSH
66471: NOP4
66475: DIFF
66476: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
66477: NOP4
66481: NOT
66482: PUSH
66483: NOP4
66487: PUSH
66488: NOP4
66492: ARRAY
66493: PPUSH
66494: LD_INT 2
66496: PUSH
66497: LD_INT 30
66499: PUSH
66500: LD_INT 4
66502: PUSH
66503: EMPTY
66504: LIST
66505: LIST
66506: PUSH
66507: LD_INT 30
66509: PUSH
66510: LD_INT 5
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: LIST
66521: PPUSH
66522: NOP4
66526: NOT
66527: AND
66528: IFFALSE 66590
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
66530: NOP4
66534: PUSH
66535: NOP4
66539: PUSH
66540: NOP4
66544: ARRAY
66545: PPUSH
66546: LD_INT 2
66548: PUSH
66549: LD_INT 25
66551: PUSH
66552: LD_INT 2
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PUSH
66559: LD_INT 25
66561: PUSH
66562: LD_INT 3
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 25
66571: PUSH
66572: LD_INT 4
66574: PUSH
66575: EMPTY
66576: LIST
66577: LIST
66578: PUSH
66579: EMPTY
66580: LIST
66581: LIST
66582: LIST
66583: LIST
66584: PPUSH
66585: NOP4
66589: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
66590: NOP4
66594: PPUSH
66595: NOP4
66599: PPUSH
66600: NOP4
// exit ;
66604: POP
66605: POP
66606: GO 66728
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
66608: NOP4
66612: PUSH
66613: NOP4
66617: ARRAY
66618: PUSH
66619: NOP4
66623: PUSH
66624: NOP4
66628: ARRAY
66629: NOT
66630: AND
66631: PUSH
66632: NOP4
66636: PUSH
66637: NOP4
66641: ARRAY
66642: AND
66643: IFFALSE 66724
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
66645: NOP4
66649: PUSH
66650: NOP4
66654: PPUSH
66655: NOP4
66659: PPUSH
66660: LD_INT 1
66662: PPUSH
66663: NOP4
66667: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
66668: NOP4
66672: PUSH
66673: NOP4
66677: PUSH
66678: NOP4
66682: ARRAY
66683: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
66684: NOP4
66688: PUSH
66689: NOP4
66693: PPUSH
66694: NOP4
66698: PPUSH
66699: EMPTY
66700: PPUSH
66701: NOP4
66705: ST_TO_ADDR
// Defend ( i , tmp ) ;
66706: NOP4
66710: PPUSH
66711: NOP4
66715: PPUSH
66716: NOP4
// exit ;
66720: POP
66721: POP
66722: GO 66728
// end ; end ;
66724: GO 65886
66726: POP
66727: POP
// end ;
66728: LD_VAR 0 1
66732: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66733: LD_INT 0
66735: PPUSH
66736: PPUSH
66737: PPUSH
66738: PPUSH
66739: PPUSH
66740: PPUSH
66741: PPUSH
66742: PPUSH
66743: PPUSH
66744: PPUSH
66745: PPUSH
// if not mc_bases then
66746: NOP4
66750: NOT
66751: IFFALSE 66755
// exit ;
66753: GO 67842
// for i = 1 to mc_bases do
66755: NOP4
66759: PUSH
66760: DOUBLE
66761: LD_INT 1
66763: DEC
66764: ST_TO_ADDR
66765: NOP4
66769: PUSH
66770: FOR_TO
66771: IFFALSE 67840
// begin tmp := mc_lab [ i ] ;
66773: NOP4
66777: PUSH
66778: NOP4
66782: PUSH
66783: NOP4
66787: ARRAY
66788: ST_TO_ADDR
// if not tmp then
66789: NOP4
66793: NOT
66794: IFFALSE 66798
// continue ;
66796: GO 66770
// idle_lab := 0 ;
66798: NOP4
66802: PUSH
66803: LD_INT 0
66805: ST_TO_ADDR
// for j in tmp do
66806: NOP4
66810: PUSH
66811: NOP4
66815: PUSH
66816: FOR_IN
66817: IFFALSE 67836
// begin researching := false ;
66819: NOP4
66823: PUSH
66824: LD_INT 0
66826: ST_TO_ADDR
// side := GetSide ( j ) ;
66827: NOP4
66831: PUSH
66832: NOP4
66836: PPUSH
66837: NOP4
66841: ST_TO_ADDR
// if not mc_tech [ side ] then
66842: NOP4
66846: PUSH
66847: NOP4
66851: ARRAY
66852: NOT
66853: IFFALSE 66857
// continue ;
66855: GO 66816
// if BuildingStatus ( j ) = bs_idle then
66857: NOP4
66861: PPUSH
66862: NOP4
66866: PUSH
66867: LD_INT 2
66869: EQUAL
66870: IFFALSE 67058
// begin if idle_lab and UnitsInside ( j ) < 6 then
66872: NOP4
66876: PUSH
66877: NOP4
66881: PPUSH
66882: NOP4
66886: PUSH
66887: LD_INT 6
66889: LESS
66890: AND
66891: IFFALSE 66962
// begin tmp2 := UnitsInside ( idle_lab ) ;
66893: NOP4
66897: PUSH
66898: NOP4
66902: PPUSH
66903: NOP4
66907: ST_TO_ADDR
// if tmp2 then
66908: NOP4
66912: IFFALSE 66954
// for x in tmp2 do
66914: NOP4
66918: PUSH
66919: NOP4
66923: PUSH
66924: FOR_IN
66925: IFFALSE 66952
// begin ComExitBuilding ( x ) ;
66927: NOP4
66931: PPUSH
66932: NOP4
// AddComEnterUnit ( x , j ) ;
66936: NOP4
66940: PPUSH
66941: NOP4
66945: PPUSH
66946: NOP4
// end ;
66950: GO 66924
66952: POP
66953: POP
// idle_lab := 0 ;
66954: NOP4
66958: PUSH
66959: LD_INT 0
66961: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
66962: NOP4
66966: PUSH
66967: NOP4
66971: PUSH
66972: NOP4
66976: ARRAY
66977: PUSH
66978: FOR_IN
66979: IFFALSE 67039
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
66981: NOP4
66985: PPUSH
66986: NOP4
66990: PPUSH
66991: NOP4
66995: PUSH
66996: NOP4
67000: PPUSH
67001: NOP4
67005: PPUSH
67006: NOP4
67010: AND
67011: IFFALSE 67037
// begin researching := true ;
67013: NOP4
67017: PUSH
67018: LD_INT 1
67020: ST_TO_ADDR
// ComResearch ( j , t ) ;
67021: NOP4
67025: PPUSH
67026: NOP4
67030: PPUSH
67031: NOP4
// break ;
67035: GO 67039
// end ;
67037: GO 66978
67039: POP
67040: POP
// if not researching then
67041: NOP4
67045: NOT
67046: IFFALSE 67058
// idle_lab := j ;
67048: NOP4
67052: PUSH
67053: NOP4
67057: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67058: NOP4
67062: PPUSH
67063: NOP4
67067: PUSH
67068: LD_INT 10
67070: EQUAL
67071: IFFALSE 67659
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67073: NOP4
67077: PUSH
67078: NOP4
67082: ARRAY
67083: NOT
67084: PUSH
67085: NOP4
67089: PUSH
67090: NOP4
67094: ARRAY
67095: NOT
67096: AND
67097: PUSH
67098: NOP4
67102: PUSH
67103: NOP4
67107: ARRAY
67108: PUSH
67109: LD_INT 1
67111: GREATER
67112: AND
67113: IFFALSE 67244
// begin ComCancel ( j ) ;
67115: NOP4
67119: PPUSH
67120: NOP4
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67124: NOP4
67128: PUSH
67129: NOP4
67133: PPUSH
67134: NOP4
67138: PPUSH
67139: NOP4
67143: PUSH
67144: NOP4
67148: ARRAY
67149: PPUSH
67150: NOP4
67154: PUSH
67155: NOP4
67159: ARRAY
67160: PUSH
67161: LD_INT 1
67163: MINUS
67164: PPUSH
67165: NOP4
67169: PUSH
67170: NOP4
67174: ARRAY
67175: PPUSH
67176: LD_INT 0
67178: PPUSH
67179: NOP4
67183: PPUSH
67184: NOP4
67188: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67189: NOP4
67193: PUSH
67194: NOP4
67198: PPUSH
67199: NOP4
67203: PPUSH
67204: NOP4
67208: PUSH
67209: NOP4
67213: ARRAY
67214: PPUSH
67215: NOP4
67219: PUSH
67220: NOP4
67224: ARRAY
67225: PPUSH
67226: LD_INT 1
67228: PPUSH
67229: LD_INT 0
67231: PPUSH
67232: NOP4
67236: PPUSH
67237: NOP4
67241: ST_TO_ADDR
// continue ;
67242: GO 66816
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67244: NOP4
67248: PUSH
67249: NOP4
67253: ARRAY
67254: PUSH
67255: NOP4
67259: PUSH
67260: NOP4
67264: ARRAY
67265: NOT
67266: AND
67267: IFFALSE 67394
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67269: NOP4
67273: PUSH
67274: NOP4
67278: PPUSH
67279: NOP4
67283: PUSH
67284: NOP4
67288: PUSH
67289: NOP4
67293: ARRAY
67294: PUSH
67295: LD_INT 1
67297: PLUS
67298: PUSH
67299: EMPTY
67300: LIST
67301: LIST
67302: PPUSH
67303: NOP4
67307: PUSH
67308: NOP4
67312: ARRAY
67313: PUSH
67314: LD_INT 1
67316: ARRAY
67317: PPUSH
67318: NOP4
67322: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67323: NOP4
67327: PUSH
67328: NOP4
67332: ARRAY
67333: PUSH
67334: LD_INT 1
67336: ARRAY
67337: PPUSH
67338: LD_INT 112
67340: PPUSH
67341: NOP4
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67345: NOP4
67349: PUSH
67350: NOP4
67354: PUSH
67355: NOP4
67359: ARRAY
67360: PPUSH
67361: LD_INT 1
67363: PPUSH
67364: NOP4
67368: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67369: NOP4
67373: PUSH
67374: NOP4
67378: PPUSH
67379: NOP4
67383: PPUSH
67384: NOP4
67388: PPUSH
67389: NOP4
67393: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67394: NOP4
67398: PUSH
67399: NOP4
67403: ARRAY
67404: PUSH
67405: NOP4
67409: PUSH
67410: NOP4
67414: ARRAY
67415: AND
67416: PUSH
67417: NOP4
67421: PUSH
67422: NOP4
67426: ARRAY
67427: PUSH
67428: LD_INT 1
67430: ARRAY
67431: PPUSH
67432: NOP4
67436: NOT
67437: AND
67438: PUSH
67439: NOP4
67443: PPUSH
67444: NOP4
67448: PUSH
67449: LD_INT 6
67451: EQUAL
67452: AND
67453: IFFALSE 67509
// begin tmp2 := UnitsInside ( j ) ;
67455: NOP4
67459: PUSH
67460: NOP4
67464: PPUSH
67465: NOP4
67469: ST_TO_ADDR
// if tmp2 = 6 then
67470: NOP4
67474: PUSH
67475: LD_INT 6
67477: EQUAL
67478: IFFALSE 67509
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67480: NOP4
67484: PUSH
67485: LD_INT 1
67487: ARRAY
67488: PPUSH
67489: LD_INT 112
67491: PPUSH
67492: NOP4
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67496: NOP4
67500: PUSH
67501: LD_INT 1
67503: ARRAY
67504: PPUSH
67505: NOP4
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67509: NOP4
67513: PUSH
67514: NOP4
67518: ARRAY
67519: PUSH
67520: NOP4
67524: PUSH
67525: NOP4
67529: ARRAY
67530: PUSH
67531: LD_INT 1
67533: ARRAY
67534: PPUSH
67535: NOP4
67539: NOT
67540: AND
67541: PUSH
67542: NOP4
67546: PUSH
67547: NOP4
67551: ARRAY
67552: PUSH
67553: LD_INT 1
67555: ARRAY
67556: PPUSH
67557: NOP4
67561: NOT
67562: AND
67563: IFFALSE 67589
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67565: NOP4
67569: PUSH
67570: NOP4
67574: ARRAY
67575: PUSH
67576: LD_INT 1
67578: ARRAY
67579: PPUSH
67580: NOP4
67584: PPUSH
67585: NOP4
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67589: NOP4
67593: PUSH
67594: NOP4
67598: ARRAY
67599: PUSH
67600: LD_INT 1
67602: ARRAY
67603: PPUSH
67604: NOP4
67608: PUSH
67609: NOP4
67613: PUSH
67614: NOP4
67618: ARRAY
67619: PUSH
67620: LD_INT 1
67622: ARRAY
67623: PPUSH
67624: NOP4
67628: PPUSH
67629: NOP4
67633: PUSH
67634: LD_INT 3
67636: NONEQUAL
67637: AND
67638: IFFALSE 67659
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67640: NOP4
67644: PUSH
67645: NOP4
67649: ARRAY
67650: PUSH
67651: LD_INT 1
67653: ARRAY
67654: PPUSH
67655: NOP4
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67659: NOP4
67663: PPUSH
67664: NOP4
67668: PUSH
67669: LD_INT 6
67671: EQUAL
67672: PUSH
67673: NOP4
67677: PUSH
67678: LD_INT 1
67680: GREATER
67681: AND
67682: IFFALSE 67834
// begin sci := [ ] ;
67684: NOP4
67688: PUSH
67689: EMPTY
67690: ST_TO_ADDR
// for x in ( tmp diff j ) do
67691: NOP4
67695: PUSH
67696: NOP4
67700: PUSH
67701: NOP4
67705: DIFF
67706: PUSH
67707: FOR_IN
67708: IFFALSE 67760
// begin if sci = 6 then
67710: NOP4
67714: PUSH
67715: LD_INT 6
67717: EQUAL
67718: IFFALSE 67722
// break ;
67720: GO 67760
// if BuildingStatus ( x ) = bs_idle then
67722: NOP4
67726: PPUSH
67727: NOP4
67731: PUSH
67732: LD_INT 2
67734: EQUAL
67735: IFFALSE 67758
// sci := sci ^ UnitsInside ( x ) ;
67737: NOP4
67741: PUSH
67742: NOP4
67746: PUSH
67747: NOP4
67751: PPUSH
67752: NOP4
67756: ADD
67757: ST_TO_ADDR
// end ;
67758: GO 67707
67760: POP
67761: POP
// if not sci then
67762: NOP4
67766: NOT
67767: IFFALSE 67771
// continue ;
67769: GO 66816
// for x in sci do
67771: NOP4
67775: PUSH
67776: NOP4
67780: PUSH
67781: FOR_IN
67782: IFFALSE 67832
// if IsInUnit ( x ) and not HasTask ( x ) then
67784: NOP4
67788: PPUSH
67789: NOP4
67793: PUSH
67794: NOP4
67798: PPUSH
67799: NOP4
67803: NOT
67804: AND
67805: IFFALSE 67830
// begin ComExitBuilding ( x ) ;
67807: NOP4
67811: PPUSH
67812: NOP4
// AddComEnterUnit ( x , j ) ;
67816: NOP4
67820: PPUSH
67821: NOP4
67825: PPUSH
67826: NOP4
// end ;
67830: GO 67781
67832: POP
67833: POP
// end ; end ;
67834: GO 66816
67836: POP
67837: POP
// end ;
67838: GO 66770
67840: POP
67841: POP
// end ;
67842: LD_VAR 0 1
67846: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67847: LD_INT 0
67849: PPUSH
67850: PPUSH
// if not mc_bases then
67851: NOP4
67855: NOT
67856: IFFALSE 67860
// exit ;
67858: GO 67941
// for i = 1 to mc_bases do
67860: NOP4
67864: PUSH
67865: DOUBLE
67866: LD_INT 1
67868: DEC
67869: ST_TO_ADDR
67870: NOP4
67874: PUSH
67875: FOR_TO
67876: IFFALSE 67939
// if mc_mines [ i ] and mc_miners [ i ] then
67878: NOP4
67882: PUSH
67883: NOP4
67887: ARRAY
67888: PUSH
67889: NOP4
67893: PUSH
67894: NOP4
67898: ARRAY
67899: AND
67900: IFFALSE 67937
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67902: NOP4
67906: PUSH
67907: NOP4
67911: ARRAY
67912: PUSH
67913: LD_INT 1
67915: ARRAY
67916: PPUSH
67917: NOP4
67921: PPUSH
67922: NOP4
67926: PUSH
67927: NOP4
67931: ARRAY
67932: PPUSH
67933: NOP4
67937: GO 67875
67939: POP
67940: POP
// end ;
67941: LD_VAR 0 1
67945: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67946: LD_INT 0
67948: PPUSH
67949: PPUSH
67950: PPUSH
67951: PPUSH
67952: PPUSH
67953: PPUSH
67954: PPUSH
67955: PPUSH
// if not mc_bases or not mc_parking then
67956: NOP4
67960: NOT
67961: PUSH
67962: NOP4
67966: NOT
67967: OR
67968: IFFALSE 67972
// exit ;
67970: GO 68682
// for i = 1 to mc_bases do
67972: NOP4
67976: PUSH
67977: DOUBLE
67978: LD_INT 1
67980: DEC
67981: ST_TO_ADDR
67982: NOP4
67986: PUSH
67987: FOR_TO
67988: IFFALSE 68680
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
67990: NOP4
67994: PUSH
67995: NOP4
67999: ARRAY
68000: NOT
68001: PUSH
68002: NOP4
68006: PUSH
68007: NOP4
68011: ARRAY
68012: NOT
68013: OR
68014: IFFALSE 68018
// continue ;
68016: GO 67987
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68018: NOP4
68022: PUSH
68023: NOP4
68027: PUSH
68028: NOP4
68032: ARRAY
68033: PUSH
68034: LD_INT 1
68036: ARRAY
68037: PPUSH
68038: NOP4
68042: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68043: NOP4
68047: PUSH
68048: NOP4
68052: PUSH
68053: NOP4
68057: ARRAY
68058: PPUSH
68059: LD_INT 30
68061: PUSH
68062: LD_INT 3
68064: PUSH
68065: EMPTY
68066: LIST
68067: LIST
68068: PPUSH
68069: NOP4
68073: ST_TO_ADDR
// if not fac then
68074: NOP4
68078: NOT
68079: IFFALSE 68130
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68081: NOP4
68085: PUSH
68086: NOP4
68090: PUSH
68091: NOP4
68095: ARRAY
68096: PPUSH
68097: LD_INT 2
68099: PUSH
68100: LD_INT 30
68102: PUSH
68103: LD_INT 0
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 30
68112: PUSH
68113: LD_INT 1
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: LIST
68124: PPUSH
68125: NOP4
68129: ST_TO_ADDR
// if not fac then
68130: NOP4
68134: NOT
68135: IFFALSE 68139
// continue ;
68137: GO 67987
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68139: NOP4
68143: PUSH
68144: NOP4
68148: PUSH
68149: NOP4
68153: ARRAY
68154: PPUSH
68155: LD_INT 22
68157: PUSH
68158: NOP4
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: PUSH
68167: LD_INT 21
68169: PUSH
68170: LD_INT 2
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 3
68179: PUSH
68180: LD_INT 24
68182: PUSH
68183: LD_INT 1000
68185: PUSH
68186: EMPTY
68187: LIST
68188: LIST
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: LIST
68198: PPUSH
68199: NOP4
68203: ST_TO_ADDR
// for j in fac do
68204: NOP4
68208: PUSH
68209: NOP4
68213: PUSH
68214: FOR_IN
68215: IFFALSE 68296
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68217: NOP4
68221: PUSH
68222: NOP4
68226: PUSH
68227: LD_INT 22
68229: PUSH
68230: NOP4
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 91
68241: PUSH
68242: NOP4
68246: PUSH
68247: LD_INT 15
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: LIST
68254: PUSH
68255: LD_INT 21
68257: PUSH
68258: LD_INT 2
68260: PUSH
68261: EMPTY
68262: LIST
68263: LIST
68264: PUSH
68265: LD_INT 3
68267: PUSH
68268: LD_INT 24
68270: PUSH
68271: LD_INT 1000
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: PUSH
68282: EMPTY
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: PPUSH
68288: NOP4
68292: UNION
68293: ST_TO_ADDR
68294: GO 68214
68296: POP
68297: POP
// if not vehs then
68298: NOP4
68302: NOT
68303: IFFALSE 68329
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68305: NOP4
68309: PUSH
68310: NOP4
68314: PPUSH
68315: NOP4
68319: PPUSH
68320: EMPTY
68321: PPUSH
68322: NOP4
68326: ST_TO_ADDR
// continue ;
68327: GO 67987
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68329: NOP4
68333: PUSH
68334: NOP4
68338: PUSH
68339: NOP4
68343: ARRAY
68344: PPUSH
68345: LD_INT 30
68347: PUSH
68348: LD_INT 3
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: PPUSH
68355: NOP4
68359: ST_TO_ADDR
// if tmp then
68360: NOP4
68364: IFFALSE 68467
// begin for j in tmp do
68366: NOP4
68370: PUSH
68371: NOP4
68375: PUSH
68376: FOR_IN
68377: IFFALSE 68465
// for k in UnitsInside ( j ) do
68379: NOP4
68383: PUSH
68384: NOP4
68388: PPUSH
68389: NOP4
68393: PUSH
68394: FOR_IN
68395: IFFALSE 68461
// if k then
68397: NOP4
68401: IFFALSE 68459
// if not k in mc_repair_vehicle [ i ] then
68403: NOP4
68407: PUSH
68408: NOP4
68412: PUSH
68413: NOP4
68417: ARRAY
68418: IN
68419: NOT
68420: IFFALSE 68459
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68422: NOP4
68426: PUSH
68427: NOP4
68431: PPUSH
68432: NOP4
68436: PPUSH
68437: NOP4
68441: PUSH
68442: NOP4
68446: ARRAY
68447: PUSH
68448: NOP4
68452: UNION
68453: PPUSH
68454: NOP4
68458: ST_TO_ADDR
68459: GO 68394
68461: POP
68462: POP
68463: GO 68376
68465: POP
68466: POP
// end ; if not mc_repair_vehicle [ i ] then
68467: NOP4
68471: PUSH
68472: NOP4
68476: ARRAY
68477: NOT
68478: IFFALSE 68482
// continue ;
68480: GO 67987
// for j in mc_repair_vehicle [ i ] do
68482: NOP4
68486: PUSH
68487: NOP4
68491: PUSH
68492: NOP4
68496: ARRAY
68497: PUSH
68498: FOR_IN
68499: IFFALSE 68676
// begin if GetClass ( j ) <> 3 then
68501: NOP4
68505: PPUSH
68506: NOP4
68510: PUSH
68511: LD_INT 3
68513: NONEQUAL
68514: IFFALSE 68555
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68516: NOP4
68520: PUSH
68521: NOP4
68525: PPUSH
68526: NOP4
68530: PPUSH
68531: NOP4
68535: PUSH
68536: NOP4
68540: ARRAY
68541: PUSH
68542: NOP4
68546: DIFF
68547: PPUSH
68548: NOP4
68552: ST_TO_ADDR
// continue ;
68553: GO 68498
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68555: NOP4
68559: PPUSH
68560: NOP4
68564: NOT
68565: PUSH
68566: NOP4
68570: PUSH
68571: NOP4
68575: PUSH
68576: NOP4
68580: ARRAY
68581: PUSH
68582: LD_INT 1
68584: ARRAY
68585: IN
68586: NOT
68587: AND
68588: PUSH
68589: NOP4
68593: PUSH
68594: NOP4
68598: PUSH
68599: NOP4
68603: ARRAY
68604: PUSH
68605: LD_INT 2
68607: ARRAY
68608: IN
68609: NOT
68610: AND
68611: IFFALSE 68674
// begin if IsInUnit ( j ) then
68613: NOP4
68617: PPUSH
68618: NOP4
68622: IFFALSE 68635
// ComExitBuilding ( j ) else
68624: NOP4
68628: PPUSH
68629: NOP4
68633: GO 68674
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
68635: NOP4
68639: PPUSH
68640: NOP4
68644: PUSH
68645: LD_INT 1
68647: ARRAY
68648: PPUSH
68649: NOP4
68653: NOT
68654: IFFALSE 68674
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
68656: NOP4
68660: PPUSH
68661: NOP4
68665: PUSH
68666: LD_INT 1
68668: ARRAY
68669: PPUSH
68670: NOP4
// end ; end ;
68674: GO 68498
68676: POP
68677: POP
// end ;
68678: GO 67987
68680: POP
68681: POP
// end ;
68682: LD_VAR 0 1
68686: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68687: LD_INT 0
68689: PPUSH
68690: PPUSH
68691: PPUSH
68692: PPUSH
68693: PPUSH
68694: PPUSH
68695: PPUSH
68696: PPUSH
68697: PPUSH
68698: PPUSH
68699: PPUSH
// if not mc_bases then
68700: NOP4
68704: NOT
68705: IFFALSE 68709
// exit ;
68707: GO 69511
// for i = 1 to mc_bases do
68709: NOP4
68713: PUSH
68714: DOUBLE
68715: LD_INT 1
68717: DEC
68718: ST_TO_ADDR
68719: NOP4
68723: PUSH
68724: FOR_TO
68725: IFFALSE 69509
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68727: NOP4
68731: PUSH
68732: NOP4
68736: ARRAY
68737: NOT
68738: PUSH
68739: NOP4
68743: PUSH
68744: NOP4
68748: ARRAY
68749: PUSH
68750: LD_INT 1
68752: ARRAY
68753: OR
68754: PUSH
68755: NOP4
68759: PUSH
68760: NOP4
68764: ARRAY
68765: PUSH
68766: LD_INT 2
68768: ARRAY
68769: OR
68770: PUSH
68771: NOP4
68775: PUSH
68776: NOP4
68780: ARRAY
68781: PPUSH
68782: LD_INT 1
68784: PPUSH
68785: NOP4
68789: NOT
68790: OR
68791: PUSH
68792: NOP4
68796: PUSH
68797: NOP4
68801: ARRAY
68802: OR
68803: IFFALSE 68807
// continue ;
68805: GO 68724
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68807: NOP4
68811: PUSH
68812: NOP4
68816: PUSH
68817: NOP4
68821: ARRAY
68822: PPUSH
68823: LD_INT 25
68825: PUSH
68826: LD_INT 4
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 50
68835: PUSH
68836: EMPTY
68837: LIST
68838: PUSH
68839: LD_INT 3
68841: PUSH
68842: LD_INT 60
68844: PUSH
68845: EMPTY
68846: LIST
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: LIST
68856: PPUSH
68857: NOP4
68861: PUSH
68862: NOP4
68866: PUSH
68867: NOP4
68871: ARRAY
68872: DIFF
68873: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68874: NOP4
68878: PUSH
68879: NOP4
68883: PUSH
68884: NOP4
68888: ARRAY
68889: PPUSH
68890: LD_INT 2
68892: PUSH
68893: LD_INT 30
68895: PUSH
68896: LD_INT 0
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 30
68905: PUSH
68906: LD_INT 1
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: LIST
68917: PPUSH
68918: NOP4
68922: ST_TO_ADDR
// if not tmp or not dep then
68923: NOP4
68927: NOT
68928: PUSH
68929: NOP4
68933: NOT
68934: OR
68935: IFFALSE 68939
// continue ;
68937: GO 68724
// side := GetSide ( tmp [ 1 ] ) ;
68939: NOP4
68943: PUSH
68944: NOP4
68948: PUSH
68949: LD_INT 1
68951: ARRAY
68952: PPUSH
68953: NOP4
68957: ST_TO_ADDR
// dep := dep [ 1 ] ;
68958: NOP4
68962: PUSH
68963: NOP4
68967: PUSH
68968: LD_INT 1
68970: ARRAY
68971: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68972: NOP4
68976: PUSH
68977: NOP4
68981: PUSH
68982: NOP4
68986: ARRAY
68987: PPUSH
68988: LD_INT 22
68990: PUSH
68991: LD_INT 0
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 25
69000: PUSH
69001: LD_INT 12
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PPUSH
69012: NOP4
69016: PUSH
69017: LD_INT 22
69019: PUSH
69020: LD_INT 0
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 25
69029: PUSH
69030: LD_INT 12
69032: PUSH
69033: EMPTY
69034: LIST
69035: LIST
69036: PUSH
69037: LD_INT 91
69039: PUSH
69040: NOP4
69044: PUSH
69045: LD_INT 20
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: LIST
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: LIST
69057: PPUSH
69058: NOP4
69062: UNION
69063: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69064: NOP4
69068: PUSH
69069: NOP4
69073: PUSH
69074: NOP4
69078: ARRAY
69079: PPUSH
69080: LD_INT 81
69082: PUSH
69083: NOP4
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PPUSH
69092: NOP4
69096: ST_TO_ADDR
// if not apes or danger_at_area then
69097: NOP4
69101: NOT
69102: PUSH
69103: NOP4
69107: OR
69108: IFFALSE 69158
// begin if mc_taming [ i ] then
69110: NOP4
69114: PUSH
69115: NOP4
69119: ARRAY
69120: IFFALSE 69156
// begin MC_Reset ( i , 121 ) ;
69122: NOP4
69126: PPUSH
69127: LD_INT 121
69129: PPUSH
69130: NOP4
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69134: NOP4
69138: PUSH
69139: NOP4
69143: PPUSH
69144: NOP4
69148: PPUSH
69149: EMPTY
69150: PPUSH
69151: NOP4
69155: ST_TO_ADDR
// end ; continue ;
69156: GO 68724
// end ; for j in tmp do
69158: NOP4
69162: PUSH
69163: NOP4
69167: PUSH
69168: FOR_IN
69169: IFFALSE 69505
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69171: NOP4
69175: PUSH
69176: NOP4
69180: PUSH
69181: NOP4
69185: ARRAY
69186: IN
69187: NOT
69188: PUSH
69189: NOP4
69193: PUSH
69194: NOP4
69198: ARRAY
69199: PUSH
69200: LD_INT 3
69202: LESS
69203: AND
69204: IFFALSE 69262
// begin SetTag ( j , 121 ) ;
69206: NOP4
69210: PPUSH
69211: LD_INT 121
69213: PPUSH
69214: NOP4
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69218: NOP4
69222: PUSH
69223: NOP4
69227: PPUSH
69228: NOP4
69232: PUSH
69233: NOP4
69237: PUSH
69238: NOP4
69242: ARRAY
69243: PUSH
69244: LD_INT 1
69246: PLUS
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: PPUSH
69252: NOP4
69256: PPUSH
69257: NOP4
69261: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69262: NOP4
69266: PUSH
69267: NOP4
69271: PUSH
69272: NOP4
69276: ARRAY
69277: IN
69278: IFFALSE 69503
// begin if GetClass ( j ) <> 4 then
69280: NOP4
69284: PPUSH
69285: NOP4
69289: PUSH
69290: LD_INT 4
69292: NONEQUAL
69293: IFFALSE 69346
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69295: NOP4
69299: PUSH
69300: NOP4
69304: PPUSH
69305: NOP4
69309: PPUSH
69310: NOP4
69314: PUSH
69315: NOP4
69319: ARRAY
69320: PUSH
69321: NOP4
69325: DIFF
69326: PPUSH
69327: NOP4
69331: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69332: NOP4
69336: PPUSH
69337: LD_INT 0
69339: PPUSH
69340: NOP4
// continue ;
69344: GO 69168
// end ; if IsInUnit ( j ) then
69346: NOP4
69350: PPUSH
69351: NOP4
69355: IFFALSE 69366
// ComExitBuilding ( j ) ;
69357: NOP4
69361: PPUSH
69362: NOP4
// ape := NearestUnitToUnit ( apes , j ) ;
69366: NOP4
69370: PUSH
69371: NOP4
69375: PPUSH
69376: NOP4
69380: PPUSH
69381: NOP4
69385: ST_TO_ADDR
// if not ape then
69386: NOP4
69390: NOT
69391: IFFALSE 69395
// break ;
69393: GO 69505
// x := GetX ( ape ) ;
69395: NOP4
69399: PUSH
69400: NOP4
69404: PPUSH
69405: NOP4
69409: ST_TO_ADDR
// y := GetY ( ape ) ;
69410: NOP4
69414: PUSH
69415: NOP4
69419: PPUSH
69420: NOP4
69424: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69425: NOP4
69429: PPUSH
69430: NOP4
69434: PPUSH
69435: NOP4
69439: NOT
69440: PUSH
69441: NOP4
69445: PPUSH
69446: NOP4
69450: PPUSH
69451: NOP4
69455: PPUSH
69456: LD_INT 20
69458: PPUSH
69459: NOP4
69463: PUSH
69464: LD_INT 4
69466: ARRAY
69467: OR
69468: IFFALSE 69472
// break ;
69470: GO 69505
// if not HasTask ( j ) then
69472: NOP4
69476: PPUSH
69477: NOP4
69481: NOT
69482: IFFALSE 69503
// ComTameXY ( j , x , y ) ;
69484: NOP4
69488: PPUSH
69489: NOP4
69493: PPUSH
69494: NOP4
69498: PPUSH
69499: NOP4
// end ; end ;
69503: GO 69168
69505: POP
69506: POP
// end ;
69507: GO 68724
69509: POP
69510: POP
// end ;
69511: LD_VAR 0 1
69515: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69516: LD_INT 0
69518: PPUSH
69519: PPUSH
69520: PPUSH
69521: PPUSH
69522: PPUSH
69523: PPUSH
69524: PPUSH
69525: PPUSH
// if not mc_bases then
69526: NOP4
69530: NOT
69531: IFFALSE 69535
// exit ;
69533: GO 70161
// for i = 1 to mc_bases do
69535: NOP4
69539: PUSH
69540: DOUBLE
69541: LD_INT 1
69543: DEC
69544: ST_TO_ADDR
69545: NOP4
69549: PUSH
69550: FOR_TO
69551: IFFALSE 70159
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69553: NOP4
69557: PUSH
69558: NOP4
69562: ARRAY
69563: NOT
69564: PUSH
69565: NOP4
69569: PUSH
69570: NOP4
69574: ARRAY
69575: PPUSH
69576: LD_INT 25
69578: PUSH
69579: LD_INT 12
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: PPUSH
69586: NOP4
69590: NOT
69591: OR
69592: IFFALSE 69596
// continue ;
69594: GO 69550
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69596: NOP4
69600: PUSH
69601: NOP4
69605: PUSH
69606: NOP4
69610: ARRAY
69611: PUSH
69612: LD_INT 1
69614: ARRAY
69615: PPUSH
69616: NOP4
69620: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69621: NOP4
69625: PPUSH
69626: LD_INT 2
69628: PPUSH
69629: NOP4
69633: IFFALSE 69886
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69635: NOP4
69639: PUSH
69640: NOP4
69644: PUSH
69645: NOP4
69649: ARRAY
69650: PPUSH
69651: LD_INT 25
69653: PUSH
69654: LD_INT 16
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PPUSH
69661: NOP4
69665: ST_TO_ADDR
// if tmp < 6 then
69666: NOP4
69670: PUSH
69671: LD_INT 6
69673: LESS
69674: IFFALSE 69886
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69676: NOP4
69680: PUSH
69681: NOP4
69685: PUSH
69686: NOP4
69690: ARRAY
69691: PPUSH
69692: LD_INT 2
69694: PUSH
69695: LD_INT 30
69697: PUSH
69698: LD_INT 0
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 30
69707: PUSH
69708: LD_INT 1
69710: PUSH
69711: EMPTY
69712: LIST
69713: LIST
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: LIST
69719: PPUSH
69720: NOP4
69724: ST_TO_ADDR
// if depot then
69725: NOP4
69729: IFFALSE 69886
// begin selected := 0 ;
69731: NOP4
69735: PUSH
69736: LD_INT 0
69738: ST_TO_ADDR
// for j in depot do
69739: NOP4
69743: PUSH
69744: NOP4
69748: PUSH
69749: FOR_IN
69750: IFFALSE 69781
// begin if UnitsInside ( j ) < 6 then
69752: NOP4
69756: PPUSH
69757: NOP4
69761: PUSH
69762: LD_INT 6
69764: LESS
69765: IFFALSE 69779
// begin selected := j ;
69767: NOP4
69771: PUSH
69772: NOP4
69776: ST_TO_ADDR
// break ;
69777: GO 69781
// end ; end ;
69779: GO 69749
69781: POP
69782: POP
// if selected then
69783: NOP4
69787: IFFALSE 69886
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69789: NOP4
69793: PUSH
69794: NOP4
69798: PUSH
69799: NOP4
69803: ARRAY
69804: PPUSH
69805: LD_INT 25
69807: PUSH
69808: LD_INT 12
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: PPUSH
69815: NOP4
69819: PUSH
69820: FOR_IN
69821: IFFALSE 69884
// if not HasTask ( j ) then
69823: NOP4
69827: PPUSH
69828: NOP4
69832: NOT
69833: IFFALSE 69882
// begin if not IsInUnit ( j ) then
69835: NOP4
69839: PPUSH
69840: NOP4
69844: NOT
69845: IFFALSE 69861
// ComEnterUnit ( j , selected ) ;
69847: NOP4
69851: PPUSH
69852: NOP4
69856: PPUSH
69857: NOP4
// AddComChangeProfession ( j , 16 ) ;
69861: NOP4
69865: PPUSH
69866: LD_INT 16
69868: PPUSH
69869: NOP4
// AddComExitBuilding ( j ) ;
69873: NOP4
69877: PPUSH
69878: NOP4
// end ;
69882: GO 69820
69884: POP
69885: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69886: NOP4
69890: PPUSH
69891: LD_INT 11
69893: PPUSH
69894: NOP4
69898: IFFALSE 70157
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69900: NOP4
69904: PUSH
69905: NOP4
69909: PUSH
69910: NOP4
69914: ARRAY
69915: PPUSH
69916: LD_INT 25
69918: PUSH
69919: LD_INT 16
69921: PUSH
69922: EMPTY
69923: LIST
69924: LIST
69925: PPUSH
69926: NOP4
69930: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69931: NOP4
69935: PUSH
69936: LD_INT 6
69938: GREATEREQUAL
69939: PUSH
69940: NOP4
69944: PPUSH
69945: LD_INT 2
69947: PPUSH
69948: NOP4
69952: NOT
69953: OR
69954: IFFALSE 70157
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69956: NOP4
69960: PUSH
69961: NOP4
69965: PUSH
69966: NOP4
69970: ARRAY
69971: PPUSH
69972: LD_INT 2
69974: PUSH
69975: LD_INT 30
69977: PUSH
69978: LD_INT 4
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 30
69987: PUSH
69988: LD_INT 5
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: LIST
69999: PPUSH
70000: NOP4
70004: ST_TO_ADDR
// if barracks then
70005: NOP4
70009: IFFALSE 70157
// begin selected := 0 ;
70011: NOP4
70015: PUSH
70016: LD_INT 0
70018: ST_TO_ADDR
// for j in barracks do
70019: NOP4
70023: PUSH
70024: NOP4
70028: PUSH
70029: FOR_IN
70030: IFFALSE 70061
// begin if UnitsInside ( j ) < 6 then
70032: NOP4
70036: PPUSH
70037: NOP4
70041: PUSH
70042: LD_INT 6
70044: LESS
70045: IFFALSE 70059
// begin selected := j ;
70047: NOP4
70051: PUSH
70052: NOP4
70056: ST_TO_ADDR
// break ;
70057: GO 70061
// end ; end ;
70059: GO 70029
70061: POP
70062: POP
// if selected then
70063: NOP4
70067: IFFALSE 70157
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70069: NOP4
70073: PUSH
70074: NOP4
70078: PUSH
70079: NOP4
70083: ARRAY
70084: PPUSH
70085: LD_INT 25
70087: PUSH
70088: LD_INT 12
70090: PUSH
70091: EMPTY
70092: LIST
70093: LIST
70094: PPUSH
70095: NOP4
70099: PUSH
70100: FOR_IN
70101: IFFALSE 70155
// if not IsInUnit ( j ) and not HasTask ( j ) then
70103: NOP4
70107: PPUSH
70108: NOP4
70112: NOT
70113: PUSH
70114: NOP4
70118: PPUSH
70119: NOP4
70123: NOT
70124: AND
70125: IFFALSE 70153
// begin ComEnterUnit ( j , selected ) ;
70127: NOP4
70131: PPUSH
70132: NOP4
70136: PPUSH
70137: NOP4
// AddComChangeProfession ( j , 15 ) ;
70141: NOP4
70145: PPUSH
70146: LD_INT 15
70148: PPUSH
70149: NOP4
// end ;
70153: GO 70100
70155: POP
70156: POP
// end ; end ; end ; end ; end ;
70157: GO 69550
70159: POP
70160: POP
// end ;
70161: LD_VAR 0 1
70165: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70166: LD_INT 0
70168: PPUSH
70169: PPUSH
70170: PPUSH
70171: PPUSH
// if not mc_bases then
70172: NOP4
70176: NOT
70177: IFFALSE 70181
// exit ;
70179: GO 70359
// for i = 1 to mc_bases do
70181: NOP4
70185: PUSH
70186: DOUBLE
70187: LD_INT 1
70189: DEC
70190: ST_TO_ADDR
70191: NOP4
70195: PUSH
70196: FOR_TO
70197: IFFALSE 70357
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70199: NOP4
70203: PUSH
70204: NOP4
70208: PUSH
70209: NOP4
70213: ARRAY
70214: PPUSH
70215: LD_INT 25
70217: PUSH
70218: LD_INT 9
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: PPUSH
70225: NOP4
70229: ST_TO_ADDR
// if not tmp then
70230: NOP4
70234: NOT
70235: IFFALSE 70239
// continue ;
70237: GO 70196
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70239: NOP4
70243: PUSH
70244: NOP4
70248: ARRAY
70249: PPUSH
70250: LD_INT 29
70252: PPUSH
70253: NOP4
70257: NOT
70258: PUSH
70259: NOP4
70263: PUSH
70264: NOP4
70268: ARRAY
70269: PPUSH
70270: LD_INT 28
70272: PPUSH
70273: NOP4
70277: NOT
70278: AND
70279: IFFALSE 70283
// continue ;
70281: GO 70196
// for j in tmp do
70283: NOP4
70287: PUSH
70288: NOP4
70292: PUSH
70293: FOR_IN
70294: IFFALSE 70353
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70296: NOP4
70300: PUSH
70301: NOP4
70305: PUSH
70306: NOP4
70310: ARRAY
70311: PUSH
70312: LD_INT 1
70314: ARRAY
70315: IN
70316: NOT
70317: PUSH
70318: NOP4
70322: PUSH
70323: NOP4
70327: PUSH
70328: NOP4
70332: ARRAY
70333: PUSH
70334: LD_INT 2
70336: ARRAY
70337: IN
70338: NOT
70339: AND
70340: IFFALSE 70351
// ComSpaceTimeShoot ( j ) ;
70342: NOP4
70346: PPUSH
70347: NOP4
70351: GO 70293
70353: POP
70354: POP
// end ;
70355: GO 70196
70357: POP
70358: POP
// end ;
70359: LD_VAR 0 1
70363: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70364: LD_INT 0
70366: PPUSH
70367: PPUSH
70368: PPUSH
70369: PPUSH
70370: PPUSH
70371: PPUSH
70372: PPUSH
70373: PPUSH
70374: PPUSH
// if not mc_bases then
70375: NOP4
70379: NOT
70380: IFFALSE 70384
// exit ;
70382: GO 71006
// for i = 1 to mc_bases do
70384: NOP4
70388: PUSH
70389: DOUBLE
70390: LD_INT 1
70392: DEC
70393: ST_TO_ADDR
70394: NOP4
70398: PUSH
70399: FOR_TO
70400: IFFALSE 71004
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70402: NOP4
70406: PUSH
70407: NOP4
70411: ARRAY
70412: NOT
70413: PUSH
70414: LD_INT 38
70416: PPUSH
70417: NOP4
70421: PUSH
70422: NOP4
70426: ARRAY
70427: PPUSH
70428: NOP4
70432: PUSH
70433: LD_INT 2
70435: NONEQUAL
70436: OR
70437: IFFALSE 70441
// continue ;
70439: GO 70399
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
70441: NOP4
70445: PUSH
70446: NOP4
70450: PUSH
70451: NOP4
70455: ARRAY
70456: PPUSH
70457: LD_INT 30
70459: PUSH
70460: LD_INT 34
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PPUSH
70467: NOP4
70471: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
70472: NOP4
70476: PUSH
70477: NOP4
70481: PUSH
70482: NOP4
70486: ARRAY
70487: PPUSH
70488: LD_INT 25
70490: PUSH
70491: LD_INT 4
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PPUSH
70498: NOP4
70502: PPUSH
70503: LD_INT 0
70505: PPUSH
70506: NOP4
70510: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70511: NOP4
70515: NOT
70516: PUSH
70517: NOP4
70521: NOT
70522: OR
70523: PUSH
70524: NOP4
70528: PUSH
70529: NOP4
70533: ARRAY
70534: PPUSH
70535: LD_INT 124
70537: PPUSH
70538: NOP4
70542: OR
70543: IFFALSE 70547
// continue ;
70545: GO 70399
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70547: NOP4
70551: PUSH
70552: NOP4
70556: ARRAY
70557: PUSH
70558: NOP4
70562: PUSH
70563: NOP4
70567: ARRAY
70568: LESS
70569: PUSH
70570: NOP4
70574: PUSH
70575: NOP4
70579: ARRAY
70580: PUSH
70581: NOP4
70585: LESS
70586: AND
70587: IFFALSE 71002
// begin tmp := sci [ 1 ] ;
70589: NOP4
70593: PUSH
70594: NOP4
70598: PUSH
70599: LD_INT 1
70601: ARRAY
70602: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70603: NOP4
70607: PPUSH
70608: LD_INT 124
70610: PPUSH
70611: NOP4
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70615: NOP4
70619: PUSH
70620: DOUBLE
70621: NOP4
70625: PUSH
70626: NOP4
70630: ARRAY
70631: INC
70632: ST_TO_ADDR
70633: NOP4
70637: PUSH
70638: NOP4
70642: ARRAY
70643: PUSH
70644: FOR_DOWNTO
70645: IFFALSE 70988
// begin if IsInUnit ( tmp ) then
70647: NOP4
70651: PPUSH
70652: NOP4
70656: IFFALSE 70667
// ComExitBuilding ( tmp ) ;
70658: NOP4
70662: PPUSH
70663: NOP4
// repeat wait ( 0 0$1 ) ;
70667: LD_INT 35
70669: PPUSH
70670: NOP4
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70674: NOP4
70678: PPUSH
70679: NOP4
70683: NOT
70684: PUSH
70685: NOP4
70689: PPUSH
70690: NOP4
70694: NOT
70695: AND
70696: IFFALSE 70667
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70698: NOP4
70702: PUSH
70703: NOP4
70707: PPUSH
70708: NOP4
70712: PUSH
70713: NOP4
70717: PPUSH
70718: NOP4
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70727: LD_INT 35
70729: PPUSH
70730: NOP4
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70734: NOP4
70738: PUSH
70739: NOP4
70743: PUSH
70744: NOP4
70748: ARRAY
70749: PUSH
70750: NOP4
70754: ARRAY
70755: PUSH
70756: LD_INT 1
70758: ARRAY
70759: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70760: NOP4
70764: PUSH
70765: NOP4
70769: PUSH
70770: NOP4
70774: ARRAY
70775: PUSH
70776: NOP4
70780: ARRAY
70781: PUSH
70782: LD_INT 2
70784: ARRAY
70785: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70786: NOP4
70790: PPUSH
70791: LD_INT 10
70793: PPUSH
70794: NOP4
70798: PUSH
70799: LD_INT 4
70801: ARRAY
70802: IFFALSE 70840
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70804: NOP4
70808: PPUSH
70809: NOP4
70813: PUSH
70814: LD_INT 1
70816: ARRAY
70817: PPUSH
70818: NOP4
70822: PUSH
70823: LD_INT 2
70825: ARRAY
70826: PPUSH
70827: NOP4
// wait ( 0 0$10 ) ;
70831: LD_INT 350
70833: PPUSH
70834: NOP4
// end else
70838: GO 70866
// begin ComMoveXY ( tmp , x , y ) ;
70840: NOP4
70844: PPUSH
70845: NOP4
70849: PPUSH
70850: NOP4
70854: PPUSH
70855: NOP4
// wait ( 0 0$3 ) ;
70859: LD_INT 105
70861: PPUSH
70862: NOP4
// end ; until IsAt ( tmp , x , y ) ;
70866: NOP4
70870: PPUSH
70871: NOP4
70875: PPUSH
70876: NOP4
70880: PPUSH
70881: NOP4
70885: IFFALSE 70727
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70887: NOP4
70891: PPUSH
70892: NOP4
70896: PPUSH
70897: NOP4
70901: PPUSH
70902: NOP4
70906: PUSH
70907: NOP4
70911: ARRAY
70912: PPUSH
70913: NOP4
// repeat wait ( 0 0$1 ) ;
70917: LD_INT 35
70919: PPUSH
70920: NOP4
// until not HasTask ( tmp ) ;
70924: NOP4
70928: PPUSH
70929: NOP4
70933: NOT
70934: IFFALSE 70917
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70936: NOP4
70940: PUSH
70941: NOP4
70945: PPUSH
70946: NOP4
70950: PUSH
70951: NOP4
70955: PUSH
70956: NOP4
70960: ARRAY
70961: PUSH
70962: LD_INT 1
70964: PLUS
70965: PUSH
70966: EMPTY
70967: LIST
70968: LIST
70969: PPUSH
70970: NOP4
70974: PUSH
70975: NOP4
70979: ARRAY
70980: PPUSH
70981: NOP4
70985: ST_TO_ADDR
// end ;
70986: GO 70644
70988: POP
70989: POP
// MC_Reset ( i , 124 ) ;
70990: NOP4
70994: PPUSH
70995: LD_INT 124
70997: PPUSH
70998: NOP4
// end ; end ;
71002: GO 70399
71004: POP
71005: POP
// end ;
71006: LD_VAR 0 1
71010: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71011: LD_INT 0
71013: PPUSH
71014: PPUSH
71015: PPUSH
// if not mc_bases then
71016: NOP4
71020: NOT
71021: IFFALSE 71025
// exit ;
71023: GO 71631
// for i = 1 to mc_bases do
71025: NOP4
71029: PUSH
71030: DOUBLE
71031: LD_INT 1
71033: DEC
71034: ST_TO_ADDR
71035: NOP4
71039: PUSH
71040: FOR_TO
71041: IFFALSE 71629
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71043: NOP4
71047: PUSH
71048: NOP4
71052: PUSH
71053: NOP4
71057: ARRAY
71058: PPUSH
71059: LD_INT 25
71061: PUSH
71062: LD_INT 4
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PPUSH
71069: NOP4
71073: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71074: NOP4
71078: NOT
71079: PUSH
71080: NOP4
71084: PUSH
71085: NOP4
71089: ARRAY
71090: NOT
71091: OR
71092: PUSH
71093: NOP4
71097: PUSH
71098: NOP4
71102: ARRAY
71103: PPUSH
71104: LD_INT 2
71106: PUSH
71107: LD_INT 30
71109: PUSH
71110: LD_INT 0
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PUSH
71117: LD_INT 30
71119: PUSH
71120: LD_INT 1
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: LIST
71131: PPUSH
71132: NOP4
71136: NOT
71137: OR
71138: IFFALSE 71188
// begin if mc_deposits_finder [ i ] then
71140: NOP4
71144: PUSH
71145: NOP4
71149: ARRAY
71150: IFFALSE 71186
// begin MC_Reset ( i , 125 ) ;
71152: NOP4
71156: PPUSH
71157: LD_INT 125
71159: PPUSH
71160: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71164: NOP4
71168: PUSH
71169: NOP4
71173: PPUSH
71174: NOP4
71178: PPUSH
71179: EMPTY
71180: PPUSH
71181: NOP4
71185: ST_TO_ADDR
// end ; continue ;
71186: GO 71040
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71188: NOP4
71192: PUSH
71193: NOP4
71197: ARRAY
71198: PUSH
71199: LD_INT 1
71201: ARRAY
71202: PUSH
71203: LD_INT 3
71205: ARRAY
71206: PUSH
71207: LD_INT 1
71209: EQUAL
71210: PUSH
71211: LD_INT 20
71213: PPUSH
71214: NOP4
71218: PUSH
71219: NOP4
71223: ARRAY
71224: PPUSH
71225: NOP4
71229: PUSH
71230: LD_INT 2
71232: NONEQUAL
71233: AND
71234: IFFALSE 71284
// begin if mc_deposits_finder [ i ] then
71236: NOP4
71240: PUSH
71241: NOP4
71245: ARRAY
71246: IFFALSE 71282
// begin MC_Reset ( i , 125 ) ;
71248: NOP4
71252: PPUSH
71253: LD_INT 125
71255: PPUSH
71256: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71260: NOP4
71264: PUSH
71265: NOP4
71269: PPUSH
71270: NOP4
71274: PPUSH
71275: EMPTY
71276: PPUSH
71277: NOP4
71281: ST_TO_ADDR
// end ; continue ;
71282: GO 71040
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71284: NOP4
71288: PUSH
71289: NOP4
71293: ARRAY
71294: PUSH
71295: LD_INT 1
71297: ARRAY
71298: PUSH
71299: LD_INT 1
71301: ARRAY
71302: PPUSH
71303: NOP4
71307: PUSH
71308: NOP4
71312: ARRAY
71313: PUSH
71314: LD_INT 1
71316: ARRAY
71317: PUSH
71318: LD_INT 2
71320: ARRAY
71321: PPUSH
71322: NOP4
71326: PUSH
71327: NOP4
71331: ARRAY
71332: PPUSH
71333: NOP4
71337: IFFALSE 71380
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71339: NOP4
71343: PUSH
71344: NOP4
71348: PPUSH
71349: NOP4
71353: PPUSH
71354: NOP4
71358: PUSH
71359: NOP4
71363: ARRAY
71364: PPUSH
71365: LD_INT 1
71367: PPUSH
71368: NOP4
71372: PPUSH
71373: NOP4
71377: ST_TO_ADDR
71378: GO 71627
// begin if not mc_deposits_finder [ i ] then
71380: NOP4
71384: PUSH
71385: NOP4
71389: ARRAY
71390: NOT
71391: IFFALSE 71443
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71393: NOP4
71397: PUSH
71398: NOP4
71402: PPUSH
71403: NOP4
71407: PPUSH
71408: NOP4
71412: PUSH
71413: LD_INT 1
71415: ARRAY
71416: PUSH
71417: EMPTY
71418: LIST
71419: PPUSH
71420: NOP4
71424: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71425: NOP4
71429: PUSH
71430: LD_INT 1
71432: ARRAY
71433: PPUSH
71434: LD_INT 125
71436: PPUSH
71437: NOP4
// end else
71441: GO 71627
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
71443: NOP4
71447: PUSH
71448: NOP4
71452: ARRAY
71453: PUSH
71454: LD_INT 1
71456: ARRAY
71457: PPUSH
71458: NOP4
71462: IFFALSE 71485
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
71464: NOP4
71468: PUSH
71469: NOP4
71473: ARRAY
71474: PUSH
71475: LD_INT 1
71477: ARRAY
71478: PPUSH
71479: NOP4
71483: GO 71627
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71485: NOP4
71489: PUSH
71490: NOP4
71494: ARRAY
71495: PUSH
71496: LD_INT 1
71498: ARRAY
71499: PPUSH
71500: NOP4
71504: NOT
71505: PUSH
71506: NOP4
71510: PUSH
71511: NOP4
71515: ARRAY
71516: PUSH
71517: LD_INT 1
71519: ARRAY
71520: PPUSH
71521: NOP4
71525: PUSH
71526: NOP4
71530: ARRAY
71531: PUSH
71532: LD_INT 1
71534: ARRAY
71535: PUSH
71536: LD_INT 1
71538: ARRAY
71539: PPUSH
71540: NOP4
71544: PUSH
71545: NOP4
71549: ARRAY
71550: PUSH
71551: LD_INT 1
71553: ARRAY
71554: PUSH
71555: LD_INT 2
71557: ARRAY
71558: PPUSH
71559: NOP4
71563: PUSH
71564: LD_INT 6
71566: GREATER
71567: AND
71568: IFFALSE 71627
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71570: NOP4
71574: PUSH
71575: NOP4
71579: ARRAY
71580: PUSH
71581: LD_INT 1
71583: ARRAY
71584: PPUSH
71585: NOP4
71589: PUSH
71590: NOP4
71594: ARRAY
71595: PUSH
71596: LD_INT 1
71598: ARRAY
71599: PUSH
71600: LD_INT 1
71602: ARRAY
71603: PPUSH
71604: NOP4
71608: PUSH
71609: NOP4
71613: ARRAY
71614: PUSH
71615: LD_INT 1
71617: ARRAY
71618: PUSH
71619: LD_INT 2
71621: ARRAY
71622: PPUSH
71623: NOP4
// end ; end ; end ;
71627: GO 71040
71629: POP
71630: POP
// end ;
71631: LD_VAR 0 1
71635: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71636: LD_INT 0
71638: PPUSH
71639: PPUSH
71640: PPUSH
71641: PPUSH
71642: PPUSH
71643: PPUSH
71644: PPUSH
71645: PPUSH
71646: PPUSH
71647: PPUSH
71648: PPUSH
// if not mc_bases then
71649: NOP4
71653: NOT
71654: IFFALSE 71658
// exit ;
71656: GO 72598
// for i = 1 to mc_bases do
71658: NOP4
71662: PUSH
71663: DOUBLE
71664: LD_INT 1
71666: DEC
71667: ST_TO_ADDR
71668: NOP4
71672: PUSH
71673: FOR_TO
71674: IFFALSE 72596
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71676: NOP4
71680: PUSH
71681: NOP4
71685: ARRAY
71686: NOT
71687: PUSH
71688: NOP4
71692: PUSH
71693: NOP4
71697: ARRAY
71698: OR
71699: IFFALSE 71703
// continue ;
71701: GO 71673
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71703: NOP4
71707: PUSH
71708: NOP4
71712: PUSH
71713: NOP4
71717: ARRAY
71718: PUSH
71719: LD_INT 1
71721: ARRAY
71722: PPUSH
71723: NOP4
71727: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71728: NOP4
71732: PUSH
71733: LD_INT 3
71735: EQUAL
71736: PUSH
71737: NOP4
71741: PUSH
71742: NOP4
71746: ARRAY
71747: PUSH
71748: NOP4
71752: PUSH
71753: NOP4
71757: ARRAY
71758: UNION
71759: PPUSH
71760: LD_INT 33
71762: PUSH
71763: LD_INT 2
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PPUSH
71770: NOP4
71774: NOT
71775: OR
71776: IFFALSE 71780
// continue ;
71778: GO 71673
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71780: NOP4
71784: PUSH
71785: NOP4
71789: PUSH
71790: NOP4
71794: ARRAY
71795: PPUSH
71796: LD_INT 30
71798: PUSH
71799: LD_INT 36
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PPUSH
71806: NOP4
71810: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71811: NOP4
71815: PUSH
71816: NOP4
71820: PUSH
71821: NOP4
71825: ARRAY
71826: PPUSH
71827: LD_INT 34
71829: PUSH
71830: LD_INT 31
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PPUSH
71837: NOP4
71841: ST_TO_ADDR
// if not cts and not mcts then
71842: NOP4
71846: NOT
71847: PUSH
71848: NOP4
71852: NOT
71853: AND
71854: IFFALSE 71858
// continue ;
71856: GO 71673
// x := cts ;
71858: NOP4
71862: PUSH
71863: NOP4
71867: ST_TO_ADDR
// if not x then
71868: NOP4
71872: NOT
71873: IFFALSE 71885
// x := mcts ;
71875: NOP4
71879: PUSH
71880: NOP4
71884: ST_TO_ADDR
// if not x then
71885: NOP4
71889: NOT
71890: IFFALSE 71894
// continue ;
71892: GO 71673
// if mc_remote_driver [ i ] then
71894: NOP4
71898: PUSH
71899: NOP4
71903: ARRAY
71904: IFFALSE 72291
// for j in mc_remote_driver [ i ] do
71906: NOP4
71910: PUSH
71911: NOP4
71915: PUSH
71916: NOP4
71920: ARRAY
71921: PUSH
71922: FOR_IN
71923: IFFALSE 72289
// begin if GetClass ( j ) <> 3 then
71925: NOP4
71929: PPUSH
71930: NOP4
71934: PUSH
71935: LD_INT 3
71937: NONEQUAL
71938: IFFALSE 71991
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71940: NOP4
71944: PUSH
71945: NOP4
71949: PPUSH
71950: NOP4
71954: PPUSH
71955: NOP4
71959: PUSH
71960: NOP4
71964: ARRAY
71965: PUSH
71966: NOP4
71970: DIFF
71971: PPUSH
71972: NOP4
71976: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71977: NOP4
71981: PPUSH
71982: LD_INT 0
71984: PPUSH
71985: NOP4
// continue ;
71989: GO 71922
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
71991: NOP4
71995: PUSH
71996: NOP4
72000: ARRAY
72001: PPUSH
72002: LD_INT 34
72004: PUSH
72005: LD_INT 31
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: PUSH
72012: LD_INT 58
72014: PUSH
72015: EMPTY
72016: LIST
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: PPUSH
72022: NOP4
72026: PUSH
72027: NOP4
72031: PPUSH
72032: NOP4
72036: NOT
72037: AND
72038: IFFALSE 72109
// begin if IsInUnit ( j ) then
72040: NOP4
72044: PPUSH
72045: NOP4
72049: IFFALSE 72060
// ComExitBuilding ( j ) ;
72051: NOP4
72055: PPUSH
72056: NOP4
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72060: NOP4
72064: PPUSH
72065: NOP4
72069: PUSH
72070: NOP4
72074: ARRAY
72075: PPUSH
72076: LD_INT 34
72078: PUSH
72079: LD_INT 31
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: LD_INT 58
72088: PUSH
72089: EMPTY
72090: LIST
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PPUSH
72096: NOP4
72100: PUSH
72101: LD_INT 1
72103: ARRAY
72104: PPUSH
72105: NOP4
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72109: NOP4
72113: PPUSH
72114: NOP4
72118: NOT
72119: PUSH
72120: NOP4
72124: PPUSH
72125: NOP4
72129: PPUSH
72130: NOP4
72134: PUSH
72135: LD_INT 36
72137: NONEQUAL
72138: PUSH
72139: NOP4
72143: PPUSH
72144: NOP4
72148: NOT
72149: AND
72150: OR
72151: IFFALSE 72287
// begin if IsInUnit ( j ) then
72153: NOP4
72157: PPUSH
72158: NOP4
72162: IFFALSE 72173
// ComExitBuilding ( j ) ;
72164: NOP4
72168: PPUSH
72169: NOP4
// ct := 0 ;
72173: NOP4
72177: PUSH
72178: LD_INT 0
72180: ST_TO_ADDR
// for k in x do
72181: NOP4
72185: PUSH
72186: NOP4
72190: PUSH
72191: FOR_IN
72192: IFFALSE 72265
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72194: NOP4
72198: PPUSH
72199: NOP4
72203: PUSH
72204: LD_INT 31
72206: EQUAL
72207: PUSH
72208: NOP4
72212: PPUSH
72213: NOP4
72217: NOT
72218: AND
72219: PUSH
72220: NOP4
72224: PPUSH
72225: NOP4
72229: PUSH
72230: LD_INT 36
72232: EQUAL
72233: PUSH
72234: NOP4
72238: PPUSH
72239: NOP4
72243: PUSH
72244: LD_INT 3
72246: LESS
72247: AND
72248: OR
72249: IFFALSE 72263
// begin ct := k ;
72251: NOP4
72255: PUSH
72256: NOP4
72260: ST_TO_ADDR
// break ;
72261: GO 72265
// end ;
72263: GO 72191
72265: POP
72266: POP
// if ct then
72267: NOP4
72271: IFFALSE 72287
// ComEnterUnit ( j , ct ) ;
72273: NOP4
72277: PPUSH
72278: NOP4
72282: PPUSH
72283: NOP4
// end ; end ;
72287: GO 71922
72289: POP
72290: POP
// places := 0 ;
72291: NOP4
72295: PUSH
72296: LD_INT 0
72298: ST_TO_ADDR
// for j = 1 to x do
72299: NOP4
72303: PUSH
72304: DOUBLE
72305: LD_INT 1
72307: DEC
72308: ST_TO_ADDR
72309: NOP4
72313: PUSH
72314: FOR_TO
72315: IFFALSE 72391
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72317: NOP4
72321: PUSH
72322: NOP4
72326: ARRAY
72327: PPUSH
72328: NOP4
72332: PUSH
72333: LD_INT 31
72335: EQUAL
72336: IFFALSE 72354
// places := places + 1 else
72338: NOP4
72342: PUSH
72343: NOP4
72347: PUSH
72348: LD_INT 1
72350: PLUS
72351: ST_TO_ADDR
72352: GO 72389
// if GetBType ( x [ j ] ) = b_control_tower then
72354: NOP4
72358: PUSH
72359: NOP4
72363: ARRAY
72364: PPUSH
72365: NOP4
72369: PUSH
72370: LD_INT 36
72372: EQUAL
72373: IFFALSE 72389
// places := places + 3 ;
72375: NOP4
72379: PUSH
72380: NOP4
72384: PUSH
72385: LD_INT 3
72387: PLUS
72388: ST_TO_ADDR
72389: GO 72314
72391: POP
72392: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72393: NOP4
72397: PUSH
72398: LD_INT 0
72400: EQUAL
72401: PUSH
72402: NOP4
72406: PUSH
72407: NOP4
72411: PUSH
72412: NOP4
72416: ARRAY
72417: LESSEQUAL
72418: OR
72419: IFFALSE 72423
// continue ;
72421: GO 71673
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72423: NOP4
72427: PUSH
72428: NOP4
72432: PUSH
72433: NOP4
72437: ARRAY
72438: PPUSH
72439: LD_INT 25
72441: PUSH
72442: LD_INT 3
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PPUSH
72449: NOP4
72453: PUSH
72454: NOP4
72458: PUSH
72459: NOP4
72463: ARRAY
72464: DIFF
72465: PPUSH
72466: LD_INT 3
72468: PPUSH
72469: NOP4
72473: ST_TO_ADDR
// for j in tmp do
72474: NOP4
72478: PUSH
72479: NOP4
72483: PUSH
72484: FOR_IN
72485: IFFALSE 72520
// if GetTag ( j ) > 0 then
72487: NOP4
72491: PPUSH
72492: NOP4
72496: PUSH
72497: LD_INT 0
72499: GREATER
72500: IFFALSE 72518
// tmp := tmp diff j ;
72502: NOP4
72506: PUSH
72507: NOP4
72511: PUSH
72512: NOP4
72516: DIFF
72517: ST_TO_ADDR
72518: GO 72484
72520: POP
72521: POP
// if not tmp then
72522: NOP4
72526: NOT
72527: IFFALSE 72531
// continue ;
72529: GO 71673
// if places then
72531: NOP4
72535: IFFALSE 72594
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72537: NOP4
72541: PUSH
72542: NOP4
72546: PPUSH
72547: NOP4
72551: PPUSH
72552: NOP4
72556: PUSH
72557: NOP4
72561: ARRAY
72562: PUSH
72563: NOP4
72567: PUSH
72568: LD_INT 1
72570: ARRAY
72571: UNION
72572: PPUSH
72573: NOP4
72577: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72578: NOP4
72582: PUSH
72583: LD_INT 1
72585: ARRAY
72586: PPUSH
72587: LD_INT 126
72589: PPUSH
72590: NOP4
// end ; end ;
72594: GO 71673
72596: POP
72597: POP
// end ;
72598: LD_VAR 0 1
72602: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72603: LD_INT 0
72605: PPUSH
72606: PPUSH
72607: PPUSH
72608: PPUSH
72609: PPUSH
72610: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72611: NOP4
72615: NOT
72616: PUSH
72617: NOP4
72621: NOT
72622: OR
72623: PUSH
72624: NOP4
72628: NOT
72629: OR
72630: PUSH
72631: NOP4
72635: PUSH
72636: LD_INT 1
72638: PUSH
72639: LD_INT 2
72641: PUSH
72642: LD_INT 3
72644: PUSH
72645: LD_INT 4
72647: PUSH
72648: LD_INT 5
72650: PUSH
72651: LD_INT 8
72653: PUSH
72654: LD_INT 9
72656: PUSH
72657: LD_INT 15
72659: PUSH
72660: LD_INT 16
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: IN
72674: NOT
72675: OR
72676: IFFALSE 72680
// exit ;
72678: GO 73580
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72680: NOP4
72684: PUSH
72685: NOP4
72689: PPUSH
72690: LD_INT 21
72692: PUSH
72693: LD_INT 3
72695: PUSH
72696: EMPTY
72697: LIST
72698: LIST
72699: PUSH
72700: LD_INT 24
72702: PUSH
72703: LD_INT 250
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PPUSH
72714: NOP4
72718: ST_TO_ADDR
// case class of 1 , 15 :
72719: NOP4
72723: PUSH
72724: LD_INT 1
72726: DOUBLE
72727: EQUAL
72728: IFTRUE 72738
72730: LD_INT 15
72732: DOUBLE
72733: EQUAL
72734: IFTRUE 72738
72736: GO 72823
72738: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72739: NOP4
72743: PUSH
72744: NOP4
72748: PPUSH
72749: LD_INT 2
72751: PUSH
72752: LD_INT 30
72754: PUSH
72755: LD_INT 32
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 30
72764: PUSH
72765: LD_INT 31
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: LIST
72776: PPUSH
72777: NOP4
72781: PUSH
72782: NOP4
72786: PPUSH
72787: LD_INT 2
72789: PUSH
72790: LD_INT 30
72792: PUSH
72793: LD_INT 4
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 30
72802: PUSH
72803: LD_INT 5
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: LIST
72814: PPUSH
72815: NOP4
72819: ADD
72820: ST_TO_ADDR
72821: GO 73069
72823: LD_INT 2
72825: DOUBLE
72826: EQUAL
72827: IFTRUE 72837
72829: LD_INT 16
72831: DOUBLE
72832: EQUAL
72833: IFTRUE 72837
72835: GO 72883
72837: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72838: NOP4
72842: PUSH
72843: NOP4
72847: PPUSH
72848: LD_INT 2
72850: PUSH
72851: LD_INT 30
72853: PUSH
72854: LD_INT 0
72856: PUSH
72857: EMPTY
72858: LIST
72859: LIST
72860: PUSH
72861: LD_INT 30
72863: PUSH
72864: LD_INT 1
72866: PUSH
72867: EMPTY
72868: LIST
72869: LIST
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: LIST
72875: PPUSH
72876: NOP4
72880: ST_TO_ADDR
72881: GO 73069
72883: LD_INT 3
72885: DOUBLE
72886: EQUAL
72887: IFTRUE 72891
72889: GO 72937
72891: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72892: NOP4
72896: PUSH
72897: NOP4
72901: PPUSH
72902: LD_INT 2
72904: PUSH
72905: LD_INT 30
72907: PUSH
72908: LD_INT 2
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 30
72917: PUSH
72918: LD_INT 3
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: LIST
72929: PPUSH
72930: NOP4
72934: ST_TO_ADDR
72935: GO 73069
72937: LD_INT 4
72939: DOUBLE
72940: EQUAL
72941: IFTRUE 72945
72943: GO 73002
72945: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72946: NOP4
72950: PUSH
72951: NOP4
72955: PPUSH
72956: LD_INT 2
72958: PUSH
72959: LD_INT 30
72961: PUSH
72962: LD_INT 6
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: LD_INT 30
72971: PUSH
72972: LD_INT 7
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 30
72981: PUSH
72982: LD_INT 8
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: LIST
72993: LIST
72994: PPUSH
72995: NOP4
72999: ST_TO_ADDR
73000: GO 73069
73002: LD_INT 5
73004: DOUBLE
73005: EQUAL
73006: IFTRUE 73022
73008: LD_INT 8
73010: DOUBLE
73011: EQUAL
73012: IFTRUE 73022
73014: LD_INT 9
73016: DOUBLE
73017: EQUAL
73018: IFTRUE 73022
73020: GO 73068
73022: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73023: NOP4
73027: PUSH
73028: NOP4
73032: PPUSH
73033: LD_INT 2
73035: PUSH
73036: LD_INT 30
73038: PUSH
73039: LD_INT 4
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 30
73048: PUSH
73049: LD_INT 5
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: LIST
73060: PPUSH
73061: NOP4
73065: ST_TO_ADDR
73066: GO 73069
73068: POP
// if not tmp then
73069: NOP4
73073: NOT
73074: IFFALSE 73078
// exit ;
73076: GO 73580
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73078: NOP4
73082: PUSH
73083: LD_INT 1
73085: PUSH
73086: LD_INT 15
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: IN
73093: PUSH
73094: NOP4
73098: PUSH
73099: NOP4
73103: ARRAY
73104: AND
73105: IFFALSE 73261
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73107: NOP4
73111: PUSH
73112: NOP4
73116: PUSH
73117: NOP4
73121: ARRAY
73122: PUSH
73123: LD_INT 1
73125: ARRAY
73126: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73127: NOP4
73131: PUSH
73132: NOP4
73136: PUSH
73137: NOP4
73141: ARRAY
73142: IN
73143: NOT
73144: IFFALSE 73259
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73146: NOP4
73150: PUSH
73151: NOP4
73155: PPUSH
73156: NOP4
73160: PUSH
73161: NOP4
73165: PUSH
73166: NOP4
73170: ARRAY
73171: PUSH
73172: LD_INT 1
73174: PLUS
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PPUSH
73180: NOP4
73184: PPUSH
73185: NOP4
73189: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73190: NOP4
73194: PUSH
73195: NOP4
73199: PPUSH
73200: NOP4
73204: PPUSH
73205: NOP4
73209: PUSH
73210: NOP4
73214: ARRAY
73215: PUSH
73216: NOP4
73220: DIFF
73221: PPUSH
73222: NOP4
73226: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73227: NOP4
73231: PPUSH
73232: NOP4
73236: PUSH
73237: NOP4
73241: ARRAY
73242: PUSH
73243: NOP4
73247: PUSH
73248: NOP4
73252: ARRAY
73253: ARRAY
73254: PPUSH
73255: NOP4
// end ; exit ;
73259: GO 73580
// end ; if tmp > 1 then
73261: NOP4
73265: PUSH
73266: LD_INT 1
73268: GREATER
73269: IFFALSE 73373
// for i = 2 to tmp do
73271: NOP4
73275: PUSH
73276: DOUBLE
73277: LD_INT 2
73279: DEC
73280: ST_TO_ADDR
73281: NOP4
73285: PUSH
73286: FOR_TO
73287: IFFALSE 73371
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73289: NOP4
73293: PUSH
73294: NOP4
73298: ARRAY
73299: PPUSH
73300: NOP4
73304: PUSH
73305: LD_INT 6
73307: EQUAL
73308: IFFALSE 73369
// begin x := tmp [ i ] ;
73310: NOP4
73314: PUSH
73315: NOP4
73319: PUSH
73320: NOP4
73324: ARRAY
73325: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73326: NOP4
73330: PUSH
73331: NOP4
73335: PPUSH
73336: NOP4
73340: PPUSH
73341: NOP4
73345: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73346: NOP4
73350: PUSH
73351: NOP4
73355: PPUSH
73356: LD_INT 1
73358: PPUSH
73359: NOP4
73363: PPUSH
73364: NOP4
73368: ST_TO_ADDR
// end ;
73369: GO 73286
73371: POP
73372: POP
// for i in tmp do
73373: NOP4
73377: PUSH
73378: NOP4
73382: PUSH
73383: FOR_IN
73384: IFFALSE 73453
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73386: NOP4
73390: PPUSH
73391: NOP4
73395: PUSH
73396: LD_INT 6
73398: LESS
73399: PUSH
73400: NOP4
73404: PPUSH
73405: NOP4
73409: PUSH
73410: LD_INT 31
73412: PUSH
73413: LD_INT 32
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: IN
73420: NOT
73421: AND
73422: PUSH
73423: NOP4
73427: PPUSH
73428: NOP4
73432: PUSH
73433: LD_INT 0
73435: EQUAL
73436: OR
73437: IFFALSE 73451
// begin j := i ;
73439: NOP4
73443: PUSH
73444: NOP4
73448: ST_TO_ADDR
// break ;
73449: GO 73453
// end ; end ;
73451: GO 73383
73453: POP
73454: POP
// if j then
73455: NOP4
73459: IFFALSE 73477
// ComEnterUnit ( unit , j ) else
73461: NOP4
73465: PPUSH
73466: NOP4
73470: PPUSH
73471: NOP4
73475: GO 73580
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73477: NOP4
73481: PUSH
73482: NOP4
73486: PPUSH
73487: LD_INT 2
73489: PUSH
73490: LD_INT 30
73492: PUSH
73493: LD_INT 0
73495: PUSH
73496: EMPTY
73497: LIST
73498: LIST
73499: PUSH
73500: LD_INT 30
73502: PUSH
73503: LD_INT 1
73505: PUSH
73506: EMPTY
73507: LIST
73508: LIST
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: LIST
73514: PPUSH
73515: NOP4
73519: ST_TO_ADDR
// if depot then
73520: NOP4
73524: IFFALSE 73580
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73526: NOP4
73530: PUSH
73531: NOP4
73535: PPUSH
73536: NOP4
73540: PPUSH
73541: NOP4
73545: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73546: NOP4
73550: PPUSH
73551: NOP4
73555: PPUSH
73556: NOP4
73560: PUSH
73561: LD_INT 10
73563: GREATER
73564: IFFALSE 73580
// ComStandNearbyBuilding ( unit , depot ) ;
73566: NOP4
73570: PPUSH
73571: NOP4
73575: PPUSH
73576: NOP4
// end ; end ; end ;
73580: LD_VAR 0 5
73584: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73585: LD_INT 0
73587: PPUSH
73588: PPUSH
73589: PPUSH
73590: PPUSH
// if not mc_bases then
73591: NOP4
73595: NOT
73596: IFFALSE 73600
// exit ;
73598: GO 73839
// for i = 1 to mc_bases do
73600: NOP4
73604: PUSH
73605: DOUBLE
73606: LD_INT 1
73608: DEC
73609: ST_TO_ADDR
73610: NOP4
73614: PUSH
73615: FOR_TO
73616: IFFALSE 73837
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73618: NOP4
73622: PUSH
73623: NOP4
73627: PUSH
73628: NOP4
73632: ARRAY
73633: PPUSH
73634: LD_INT 21
73636: PUSH
73637: LD_INT 1
73639: PUSH
73640: EMPTY
73641: LIST
73642: LIST
73643: PPUSH
73644: NOP4
73648: PUSH
73649: NOP4
73653: PUSH
73654: NOP4
73658: ARRAY
73659: UNION
73660: ST_TO_ADDR
// if not tmp then
73661: NOP4
73665: NOT
73666: IFFALSE 73670
// continue ;
73668: GO 73615
// for j in tmp do
73670: NOP4
73674: PUSH
73675: NOP4
73679: PUSH
73680: FOR_IN
73681: IFFALSE 73833
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73683: NOP4
73687: PPUSH
73688: NOP4
73692: NOT
73693: PUSH
73694: NOP4
73698: PPUSH
73699: NOP4
73703: NOT
73704: AND
73705: PUSH
73706: NOP4
73710: PPUSH
73711: NOP4
73715: NOT
73716: AND
73717: PUSH
73718: NOP4
73722: PPUSH
73723: NOP4
73727: NOT
73728: AND
73729: PUSH
73730: NOP4
73734: PUSH
73735: NOP4
73739: PUSH
73740: NOP4
73744: ARRAY
73745: PUSH
73746: LD_INT 1
73748: ARRAY
73749: IN
73750: NOT
73751: AND
73752: PUSH
73753: NOP4
73757: PUSH
73758: NOP4
73762: PUSH
73763: NOP4
73767: ARRAY
73768: PUSH
73769: LD_INT 2
73771: ARRAY
73772: IN
73773: NOT
73774: AND
73775: PUSH
73776: NOP4
73780: PUSH
73781: NOP4
73785: PUSH
73786: NOP4
73790: ARRAY
73791: IN
73792: NOT
73793: AND
73794: IFFALSE 73831
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73796: NOP4
73800: PPUSH
73801: NOP4
73805: PUSH
73806: NOP4
73810: ARRAY
73811: PPUSH
73812: NOP4
73816: PPUSH
73817: NOP4
73821: PPUSH
73822: NOP4
73826: PPUSH
73827: NOP4
// end ;
73831: GO 73680
73833: POP
73834: POP
// end ;
73835: GO 73615
73837: POP
73838: POP
// end ;
73839: LD_VAR 0 1
73843: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73844: LD_INT 0
73846: PPUSH
73847: PPUSH
73848: PPUSH
73849: PPUSH
73850: PPUSH
73851: PPUSH
// if not mc_bases [ base ] then
73852: NOP4
73856: PUSH
73857: NOP4
73861: ARRAY
73862: NOT
73863: IFFALSE 73867
// exit ;
73865: GO 74049
// tmp := [ ] ;
73867: NOP4
73871: PUSH
73872: EMPTY
73873: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73874: NOP4
73878: PUSH
73879: NOP4
73883: PPUSH
73884: LD_INT 0
73886: PPUSH
73887: NOP4
73891: ST_TO_ADDR
// if not list then
73892: NOP4
73896: NOT
73897: IFFALSE 73901
// exit ;
73899: GO 74049
// for i = 1 to amount do
73901: NOP4
73905: PUSH
73906: DOUBLE
73907: LD_INT 1
73909: DEC
73910: ST_TO_ADDR
73911: NOP4
73915: PUSH
73916: FOR_TO
73917: IFFALSE 73997
// begin x := rand ( 1 , list [ 1 ] ) ;
73919: NOP4
73923: PUSH
73924: LD_INT 1
73926: PPUSH
73927: NOP4
73931: PUSH
73932: LD_INT 1
73934: ARRAY
73935: PPUSH
73936: NOP4
73940: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73941: NOP4
73945: PUSH
73946: NOP4
73950: PPUSH
73951: NOP4
73955: PPUSH
73956: NOP4
73960: PUSH
73961: LD_INT 1
73963: ARRAY
73964: PUSH
73965: NOP4
73969: ARRAY
73970: PUSH
73971: NOP4
73975: PUSH
73976: LD_INT 2
73978: ARRAY
73979: PUSH
73980: NOP4
73984: ARRAY
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PPUSH
73990: NOP4
73994: ST_TO_ADDR
// end ;
73995: GO 73916
73997: POP
73998: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
73999: NOP4
74003: PUSH
74004: NOP4
74008: PPUSH
74009: NOP4
74013: PPUSH
74014: NOP4
74018: PPUSH
74019: NOP4
74023: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74024: NOP4
74028: PUSH
74029: NOP4
74033: PPUSH
74034: NOP4
74038: PPUSH
74039: NOP4
74043: PPUSH
74044: NOP4
74048: ST_TO_ADDR
// end ;
74049: LD_VAR 0 4
74053: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74054: LD_INT 0
74056: PPUSH
// if not mc_bases [ base ] then
74057: NOP4
74061: PUSH
74062: NOP4
74066: ARRAY
74067: NOT
74068: IFFALSE 74072
// exit ;
74070: GO 74097
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74072: NOP4
74076: PUSH
74077: NOP4
74081: PPUSH
74082: NOP4
74086: PPUSH
74087: NOP4
74091: PPUSH
74092: NOP4
74096: ST_TO_ADDR
// end ;
74097: LD_VAR 0 3
74101: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74102: LD_INT 0
74104: PPUSH
// if not mc_bases [ base ] then
74105: NOP4
74109: PUSH
74110: NOP4
74114: ARRAY
74115: NOT
74116: IFFALSE 74120
// exit ;
74118: GO 74157
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74120: NOP4
74124: PUSH
74125: NOP4
74129: PPUSH
74130: NOP4
74134: PPUSH
74135: NOP4
74139: PUSH
74140: NOP4
74144: ARRAY
74145: PUSH
74146: NOP4
74150: UNION
74151: PPUSH
74152: NOP4
74156: ST_TO_ADDR
// end ;
74157: LD_VAR 0 3
74161: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74162: LD_INT 0
74164: PPUSH
// if not mc_bases [ base ] then
74165: NOP4
74169: PUSH
74170: NOP4
74174: ARRAY
74175: NOT
74176: IFFALSE 74180
// exit ;
74178: GO 74205
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74180: NOP4
74184: PUSH
74185: NOP4
74189: PPUSH
74190: NOP4
74194: PPUSH
74195: NOP4
74199: PPUSH
74200: NOP4
74204: ST_TO_ADDR
// end ;
74205: LD_VAR 0 3
74209: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74210: LD_INT 0
74212: PPUSH
// if not mc_bases [ base ] then
74213: NOP4
74217: PUSH
74218: NOP4
74222: ARRAY
74223: NOT
74224: IFFALSE 74228
// exit ;
74226: GO 74265
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74228: NOP4
74232: PUSH
74233: NOP4
74237: PPUSH
74238: NOP4
74242: PPUSH
74243: NOP4
74247: PUSH
74248: NOP4
74252: ARRAY
74253: PUSH
74254: NOP4
74258: ADD
74259: PPUSH
74260: NOP4
74264: ST_TO_ADDR
// end ;
74265: LD_VAR 0 3
74269: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74270: LD_INT 0
74272: PPUSH
// if not mc_bases [ base ] then
74273: NOP4
74277: PUSH
74278: NOP4
74282: ARRAY
74283: NOT
74284: IFFALSE 74288
// exit ;
74286: GO 74342
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74288: NOP4
74292: PUSH
74293: NOP4
74297: PPUSH
74298: NOP4
74302: PPUSH
74303: NOP4
74307: PPUSH
74308: NOP4
74312: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74313: NOP4
74317: PUSH
74318: NOP4
74322: PPUSH
74323: NOP4
74327: PPUSH
74328: NOP4
74332: PUSH
74333: LD_INT 0
74335: PLUS
74336: PPUSH
74337: NOP4
74341: ST_TO_ADDR
// end ;
74342: LD_VAR 0 3
74346: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74347: LD_INT 0
74349: PPUSH
// if not mc_bases [ base ] then
74350: NOP4
74354: PUSH
74355: NOP4
74359: ARRAY
74360: NOT
74361: IFFALSE 74365
// exit ;
74363: GO 74390
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74365: NOP4
74369: PUSH
74370: NOP4
74374: PPUSH
74375: NOP4
74379: PPUSH
74380: NOP4
74384: PPUSH
74385: NOP4
74389: ST_TO_ADDR
// end ;
74390: LD_VAR 0 3
74394: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74395: LD_INT 0
74397: PPUSH
74398: PPUSH
74399: PPUSH
74400: PPUSH
// if not mc_bases [ base ] then
74401: NOP4
74405: PUSH
74406: NOP4
74410: ARRAY
74411: NOT
74412: IFFALSE 74416
// exit ;
74414: GO 74481
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74416: NOP4
74420: PUSH
74421: NOP4
74425: PPUSH
74426: NOP4
74430: PUSH
74431: NOP4
74435: PUSH
74436: NOP4
74440: ARRAY
74441: PUSH
74442: LD_INT 1
74444: PLUS
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PPUSH
74450: NOP4
74454: PUSH
74455: NOP4
74459: PUSH
74460: NOP4
74464: PUSH
74465: NOP4
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: LIST
74474: LIST
74475: PPUSH
74476: NOP4
74480: ST_TO_ADDR
// end ;
74481: LD_VAR 0 5
74485: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74486: LD_INT 0
74488: PPUSH
// if not mc_bases [ base ] then
74489: NOP4
74493: PUSH
74494: NOP4
74498: ARRAY
74499: NOT
74500: IFFALSE 74504
// exit ;
74502: GO 74529
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74504: NOP4
74508: PUSH
74509: NOP4
74513: PPUSH
74514: NOP4
74518: PPUSH
74519: NOP4
74523: PPUSH
74524: NOP4
74528: ST_TO_ADDR
// end ;
74529: LD_VAR 0 3
74533: RET
// export function MC_GetMinesField ( base ) ; begin
74534: LD_INT 0
74536: PPUSH
// result := mc_mines [ base ] ;
74537: NOP4
74541: PUSH
74542: NOP4
74546: PUSH
74547: NOP4
74551: ARRAY
74552: ST_TO_ADDR
// end ;
74553: LD_VAR 0 2
74557: RET
// export function MC_GetProduceList ( base ) ; begin
74558: LD_INT 0
74560: PPUSH
// result := mc_produce [ base ] ;
74561: NOP4
74565: PUSH
74566: NOP4
74570: PUSH
74571: NOP4
74575: ARRAY
74576: ST_TO_ADDR
// end ;
74577: LD_VAR 0 2
74581: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74582: LD_INT 0
74584: PPUSH
74585: PPUSH
// if not mc_bases then
74586: NOP4
74590: NOT
74591: IFFALSE 74595
// exit ;
74593: GO 74660
// if mc_bases [ base ] then
74595: NOP4
74599: PUSH
74600: NOP4
74604: ARRAY
74605: IFFALSE 74660
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74607: NOP4
74611: PUSH
74612: NOP4
74616: PUSH
74617: NOP4
74621: ARRAY
74622: PPUSH
74623: LD_INT 30
74625: PUSH
74626: NOP4
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PPUSH
74635: NOP4
74639: ST_TO_ADDR
// if result then
74640: NOP4
74644: IFFALSE 74660
// result := result [ 1 ] ;
74646: NOP4
74650: PUSH
74651: NOP4
74655: PUSH
74656: LD_INT 1
74658: ARRAY
74659: ST_TO_ADDR
// end ; end ;
74660: LD_VAR 0 3
74664: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74665: LD_INT 0
74667: PPUSH
74668: PPUSH
// if not mc_bases then
74669: NOP4
74673: NOT
74674: IFFALSE 74678
// exit ;
74676: GO 74723
// if mc_bases [ base ] then
74678: NOP4
74682: PUSH
74683: NOP4
74687: ARRAY
74688: IFFALSE 74723
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74690: NOP4
74694: PUSH
74695: NOP4
74699: PUSH
74700: NOP4
74704: ARRAY
74705: PPUSH
74706: LD_INT 30
74708: PUSH
74709: NOP4
74713: PUSH
74714: EMPTY
74715: LIST
74716: LIST
74717: PPUSH
74718: NOP4
74722: ST_TO_ADDR
// end ;
74723: LD_VAR 0 3
74727: RET
// export function MC_SetTame ( base , area ) ; begin
74728: LD_INT 0
74730: PPUSH
// if not mc_bases or not base then
74731: NOP4
74735: NOT
74736: PUSH
74737: NOP4
74741: NOT
74742: OR
74743: IFFALSE 74747
// exit ;
74745: GO 74772
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74747: NOP4
74751: PUSH
74752: NOP4
74756: PPUSH
74757: NOP4
74761: PPUSH
74762: NOP4
74766: PPUSH
74767: NOP4
74771: ST_TO_ADDR
// end ;
74772: LD_VAR 0 3
74776: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74777: LD_INT 0
74779: PPUSH
74780: PPUSH
// if not mc_bases or not base then
74781: NOP4
74785: NOT
74786: PUSH
74787: NOP4
74791: NOT
74792: OR
74793: IFFALSE 74797
// exit ;
74795: GO 74899
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74797: NOP4
74801: PUSH
74802: NOP4
74806: PUSH
74807: NOP4
74811: ARRAY
74812: PPUSH
74813: LD_INT 30
74815: PUSH
74816: NOP4
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PPUSH
74825: NOP4
74829: ST_TO_ADDR
// if not tmp then
74830: NOP4
74834: NOT
74835: IFFALSE 74839
// exit ;
74837: GO 74899
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74839: NOP4
74843: PUSH
74844: NOP4
74848: PPUSH
74849: NOP4
74853: PPUSH
74854: NOP4
74858: PUSH
74859: NOP4
74863: ARRAY
74864: PPUSH
74865: NOP4
74869: PUSH
74870: NOP4
74874: ARRAY
74875: PUSH
74876: LD_INT 1
74878: PLUS
74879: PPUSH
74880: NOP4
74884: PUSH
74885: LD_INT 1
74887: ARRAY
74888: PPUSH
74889: NOP4
74893: PPUSH
74894: NOP4
74898: ST_TO_ADDR
// end ;
74899: LD_VAR 0 3
74903: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74904: LD_INT 0
74906: PPUSH
74907: PPUSH
// if not mc_bases or not base or not kinds then
74908: NOP4
74912: NOT
74913: PUSH
74914: NOP4
74918: NOT
74919: OR
74920: PUSH
74921: NOP4
74925: NOT
74926: OR
74927: IFFALSE 74931
// exit ;
74929: GO 74992
// for i in kinds do
74931: NOP4
74935: PUSH
74936: NOP4
74940: PUSH
74941: FOR_IN
74942: IFFALSE 74990
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74944: NOP4
74948: PUSH
74949: NOP4
74953: PPUSH
74954: NOP4
74958: PUSH
74959: NOP4
74963: PUSH
74964: NOP4
74968: ARRAY
74969: PUSH
74970: LD_INT 1
74972: PLUS
74973: PUSH
74974: EMPTY
74975: LIST
74976: LIST
74977: PPUSH
74978: NOP4
74982: PPUSH
74983: NOP4
74987: ST_TO_ADDR
74988: GO 74941
74990: POP
74991: POP
// end ;
74992: LD_VAR 0 3
74996: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
74997: LD_INT 0
74999: PPUSH
// if not mc_bases or not base or not areas then
75000: NOP4
75004: NOT
75005: PUSH
75006: NOP4
75010: NOT
75011: OR
75012: PUSH
75013: NOP4
75017: NOT
75018: OR
75019: IFFALSE 75023
// exit ;
75021: GO 75048
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75023: NOP4
75027: PUSH
75028: NOP4
75032: PPUSH
75033: NOP4
75037: PPUSH
75038: NOP4
75042: PPUSH
75043: NOP4
75047: ST_TO_ADDR
// end ;
75048: LD_VAR 0 3
75052: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75053: LD_INT 0
75055: PPUSH
// if not mc_bases or not base or not teleports_exit then
75056: NOP4
75060: NOT
75061: PUSH
75062: NOP4
75066: NOT
75067: OR
75068: PUSH
75069: NOP4
75073: NOT
75074: OR
75075: IFFALSE 75079
// exit ;
75077: GO 75104
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75079: NOP4
75083: PUSH
75084: NOP4
75088: PPUSH
75089: NOP4
75093: PPUSH
75094: NOP4
75098: PPUSH
75099: NOP4
75103: ST_TO_ADDR
// end ;
75104: LD_VAR 0 3
75108: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75109: LD_INT 0
75111: PPUSH
75112: PPUSH
75113: PPUSH
// if not mc_bases or not base or not ext_list then
75114: NOP4
75118: NOT
75119: PUSH
75120: NOP4
75124: NOT
75125: OR
75126: PUSH
75127: NOP4
75131: NOT
75132: OR
75133: IFFALSE 75137
// exit ;
75135: GO 75310
// tmp := GetFacExtXYD ( x , y , d ) ;
75137: NOP4
75141: PUSH
75142: NOP4
75146: PPUSH
75147: NOP4
75151: PPUSH
75152: NOP4
75156: PPUSH
75157: NOP4
75161: ST_TO_ADDR
// if not tmp then
75162: NOP4
75166: NOT
75167: IFFALSE 75171
// exit ;
75169: GO 75310
// for i in tmp do
75171: NOP4
75175: PUSH
75176: NOP4
75180: PUSH
75181: FOR_IN
75182: IFFALSE 75308
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75184: NOP4
75188: PUSH
75189: NOP4
75193: PPUSH
75194: NOP4
75198: PPUSH
75199: NOP4
75203: PUSH
75204: NOP4
75208: ARRAY
75209: PPUSH
75210: NOP4
75214: PUSH
75215: NOP4
75219: ARRAY
75220: PUSH
75221: LD_INT 1
75223: PLUS
75224: PPUSH
75225: NOP4
75229: PUSH
75230: LD_INT 1
75232: ARRAY
75233: PUSH
75234: NOP4
75238: PUSH
75239: LD_INT 1
75241: ARRAY
75242: PUSH
75243: NOP4
75247: PUSH
75248: LD_INT 2
75250: ARRAY
75251: PUSH
75252: NOP4
75256: PUSH
75257: LD_INT 3
75259: ARRAY
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: LIST
75265: LIST
75266: PPUSH
75267: NOP4
75271: PPUSH
75272: NOP4
75276: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75277: NOP4
75281: PUSH
75282: NOP4
75286: PPUSH
75287: LD_INT 1
75289: PPUSH
75290: NOP4
75294: ST_TO_ADDR
// if not ext_list then
75295: NOP4
75299: NOT
75300: IFFALSE 75306
// exit ;
75302: POP
75303: POP
75304: GO 75310
// end ;
75306: GO 75181
75308: POP
75309: POP
// end ;
75310: LD_VAR 0 6
75314: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75315: LD_INT 0
75317: PPUSH
// if not mc_bases or not base or not weapon_list then
75318: NOP4
75322: NOT
75323: PUSH
75324: NOP4
75328: NOT
75329: OR
75330: PUSH
75331: NOP4
75335: NOT
75336: OR
75337: IFFALSE 75341
// exit ;
75339: GO 75366
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75341: NOP4
75345: PUSH
75346: NOP4
75350: PPUSH
75351: NOP4
75355: PPUSH
75356: NOP4
75360: PPUSH
75361: NOP4
75365: ST_TO_ADDR
// end ;
75366: LD_VAR 0 3
75370: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75371: LD_INT 0
75373: PPUSH
// if not mc_bases or not base or not tech_list then
75374: NOP4
75378: NOT
75379: PUSH
75380: NOP4
75384: NOT
75385: OR
75386: PUSH
75387: NOP4
75391: NOT
75392: OR
75393: IFFALSE 75397
// exit ;
75395: GO 75422
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75397: NOP4
75401: PUSH
75402: NOP4
75406: PPUSH
75407: NOP4
75411: PPUSH
75412: NOP4
75416: PPUSH
75417: NOP4
75421: ST_TO_ADDR
// end ;
75422: LD_VAR 0 3
75426: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75427: LD_INT 0
75429: PPUSH
// if not mc_bases or not parking_area or not base then
75430: NOP4
75434: NOT
75435: PUSH
75436: NOP4
75440: NOT
75441: OR
75442: PUSH
75443: NOP4
75447: NOT
75448: OR
75449: IFFALSE 75453
// exit ;
75451: GO 75478
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
75453: NOP4
75457: PUSH
75458: NOP4
75462: PPUSH
75463: NOP4
75467: PPUSH
75468: NOP4
75472: PPUSH
75473: NOP4
75477: ST_TO_ADDR
// end ;
75478: LD_VAR 0 3
75482: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75483: LD_INT 0
75485: PPUSH
// if not mc_bases or not base or not scan_area then
75486: NOP4
75490: NOT
75491: PUSH
75492: NOP4
75496: NOT
75497: OR
75498: PUSH
75499: NOP4
75503: NOT
75504: OR
75505: IFFALSE 75509
// exit ;
75507: GO 75534
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75509: NOP4
75513: PUSH
75514: NOP4
75518: PPUSH
75519: NOP4
75523: PPUSH
75524: NOP4
75528: PPUSH
75529: NOP4
75533: ST_TO_ADDR
// end ;
75534: LD_VAR 0 3
75538: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75539: LD_INT 0
75541: PPUSH
75542: PPUSH
// if not mc_bases or not base then
75543: NOP4
75547: NOT
75548: PUSH
75549: NOP4
75553: NOT
75554: OR
75555: IFFALSE 75559
// exit ;
75557: GO 75623
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75559: NOP4
75563: PUSH
75564: LD_INT 1
75566: PUSH
75567: LD_INT 2
75569: PUSH
75570: LD_INT 3
75572: PUSH
75573: LD_INT 4
75575: PUSH
75576: LD_INT 11
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: LIST
75583: LIST
75584: LIST
75585: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75586: NOP4
75590: PUSH
75591: NOP4
75595: PPUSH
75596: NOP4
75600: PPUSH
75601: NOP4
75605: PUSH
75606: NOP4
75610: ARRAY
75611: PUSH
75612: NOP4
75616: DIFF
75617: PPUSH
75618: NOP4
75622: ST_TO_ADDR
// end ;
75623: LD_VAR 0 2
75627: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75628: LD_INT 0
75630: PPUSH
// result := mc_vehicles [ base ] ;
75631: NOP4
75635: PUSH
75636: NOP4
75640: PUSH
75641: NOP4
75645: ARRAY
75646: ST_TO_ADDR
// if onlyCombat then
75647: NOP4
75651: IFFALSE 75829
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75653: NOP4
75657: PUSH
75658: NOP4
75662: PUSH
75663: NOP4
75667: PPUSH
75668: LD_INT 2
75670: PUSH
75671: LD_INT 34
75673: PUSH
75674: LD_INT 12
75676: PUSH
75677: EMPTY
75678: LIST
75679: LIST
75680: PUSH
75681: LD_INT 34
75683: PUSH
75684: LD_INT 51
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 34
75693: PUSH
75694: NOP4
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 34
75705: PUSH
75706: LD_INT 32
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: LD_INT 34
75715: PUSH
75716: LD_INT 13
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PUSH
75723: LD_INT 34
75725: PUSH
75726: LD_INT 52
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 34
75735: PUSH
75736: NOP4
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 34
75747: PUSH
75748: LD_INT 14
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: LD_INT 34
75757: PUSH
75758: LD_INT 53
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 34
75767: PUSH
75768: NOP4
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PUSH
75777: LD_INT 34
75779: PUSH
75780: LD_INT 31
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: LD_INT 34
75789: PUSH
75790: LD_INT 48
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 34
75799: PUSH
75800: LD_INT 8
75802: PUSH
75803: EMPTY
75804: LIST
75805: LIST
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: LIST
75814: LIST
75815: LIST
75816: LIST
75817: LIST
75818: LIST
75819: LIST
75820: LIST
75821: LIST
75822: PPUSH
75823: NOP4
75827: DIFF
75828: ST_TO_ADDR
// end ; end_of_file
75829: LD_VAR 0 3
75833: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75834: LD_INT 0
75836: PPUSH
75837: PPUSH
75838: PPUSH
// if not mc_bases or not skirmish then
75839: NOP4
75843: NOT
75844: PUSH
75845: NOP4
75849: NOT
75850: OR
75851: IFFALSE 75855
// exit ;
75853: GO 76020
// for i = 1 to mc_bases do
75855: NOP4
75859: PUSH
75860: DOUBLE
75861: LD_INT 1
75863: DEC
75864: ST_TO_ADDR
75865: NOP4
75869: PUSH
75870: FOR_TO
75871: IFFALSE 76018
// begin if sci in mc_bases [ i ] then
75873: NOP4
75877: PUSH
75878: NOP4
75882: PUSH
75883: NOP4
75887: ARRAY
75888: IN
75889: IFFALSE 76016
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75891: NOP4
75895: PUSH
75896: NOP4
75900: PPUSH
75901: NOP4
75905: PUSH
75906: NOP4
75910: PUSH
75911: NOP4
75915: ARRAY
75916: PUSH
75917: LD_INT 1
75919: PLUS
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: PPUSH
75925: NOP4
75929: PPUSH
75930: NOP4
75934: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75935: NOP4
75939: PUSH
75940: NOP4
75944: PUSH
75945: NOP4
75949: ARRAY
75950: PPUSH
75951: LD_INT 2
75953: PUSH
75954: LD_INT 30
75956: PUSH
75957: LD_INT 0
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: PUSH
75964: LD_INT 30
75966: PUSH
75967: LD_INT 1
75969: PUSH
75970: EMPTY
75971: LIST
75972: LIST
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: LIST
75978: PPUSH
75979: NOP4
75983: PPUSH
75984: NOP4
75988: PPUSH
75989: NOP4
75993: ST_TO_ADDR
// if tmp then
75994: NOP4
75998: IFFALSE 76014
// ComStandNearbyBuilding ( ape , tmp ) ;
76000: NOP4
76004: PPUSH
76005: NOP4
76009: PPUSH
76010: NOP4
// break ;
76014: GO 76018
// end ; end ;
76016: GO 75870
76018: POP
76019: POP
// end ;
76020: LD_VAR 0 3
76024: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76025: LD_INT 0
76027: PPUSH
76028: PPUSH
76029: PPUSH
// if not mc_bases or not skirmish then
76030: NOP4
76034: NOT
76035: PUSH
76036: NOP4
76040: NOT
76041: OR
76042: IFFALSE 76046
// exit ;
76044: GO 76135
// for i = 1 to mc_bases do
76046: NOP4
76050: PUSH
76051: DOUBLE
76052: LD_INT 1
76054: DEC
76055: ST_TO_ADDR
76056: NOP4
76060: PUSH
76061: FOR_TO
76062: IFFALSE 76133
// begin if building in mc_busy_turret_list [ i ] then
76064: NOP4
76068: PUSH
76069: NOP4
76073: PUSH
76074: NOP4
76078: ARRAY
76079: IN
76080: IFFALSE 76131
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76082: NOP4
76086: PUSH
76087: NOP4
76091: PUSH
76092: NOP4
76096: ARRAY
76097: PUSH
76098: NOP4
76102: DIFF
76103: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76104: NOP4
76108: PUSH
76109: NOP4
76113: PPUSH
76114: NOP4
76118: PPUSH
76119: NOP4
76123: PPUSH
76124: NOP4
76128: ST_TO_ADDR
// break ;
76129: GO 76133
// end ; end ;
76131: GO 76061
76133: POP
76134: POP
// end ;
76135: LD_VAR 0 3
76139: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76140: LD_INT 0
76142: PPUSH
76143: PPUSH
76144: PPUSH
// if not mc_bases or not skirmish then
76145: NOP4
76149: NOT
76150: PUSH
76151: NOP4
76155: NOT
76156: OR
76157: IFFALSE 76161
// exit ;
76159: GO 76360
// for i = 1 to mc_bases do
76161: NOP4
76165: PUSH
76166: DOUBLE
76167: LD_INT 1
76169: DEC
76170: ST_TO_ADDR
76171: NOP4
76175: PUSH
76176: FOR_TO
76177: IFFALSE 76358
// if building in mc_bases [ i ] then
76179: NOP4
76183: PUSH
76184: NOP4
76188: PUSH
76189: NOP4
76193: ARRAY
76194: IN
76195: IFFALSE 76356
// begin tmp := mc_bases [ i ] diff building ;
76197: NOP4
76201: PUSH
76202: NOP4
76206: PUSH
76207: NOP4
76211: ARRAY
76212: PUSH
76213: NOP4
76217: DIFF
76218: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76219: NOP4
76223: PUSH
76224: NOP4
76228: PPUSH
76229: NOP4
76233: PPUSH
76234: NOP4
76238: PPUSH
76239: NOP4
76243: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76244: NOP4
76248: PUSH
76249: NOP4
76253: PUSH
76254: NOP4
76258: ARRAY
76259: IN
76260: IFFALSE 76299
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76262: NOP4
76266: PUSH
76267: NOP4
76271: PPUSH
76272: NOP4
76276: PPUSH
76277: NOP4
76281: PUSH
76282: NOP4
76286: ARRAY
76287: PUSH
76288: NOP4
76292: DIFF
76293: PPUSH
76294: NOP4
76298: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76299: NOP4
76303: PUSH
76304: NOP4
76308: PUSH
76309: NOP4
76313: ARRAY
76314: IN
76315: IFFALSE 76354
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76317: NOP4
76321: PUSH
76322: NOP4
76326: PPUSH
76327: NOP4
76331: PPUSH
76332: NOP4
76336: PUSH
76337: NOP4
76341: ARRAY
76342: PUSH
76343: NOP4
76347: DIFF
76348: PPUSH
76349: NOP4
76353: ST_TO_ADDR
// break ;
76354: GO 76358
// end ;
76356: GO 76176
76358: POP
76359: POP
// end ;
76360: LD_VAR 0 4
76364: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76365: LD_INT 0
76367: PPUSH
76368: PPUSH
76369: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76370: NOP4
76374: NOT
76375: PUSH
76376: NOP4
76380: NOT
76381: OR
76382: PUSH
76383: NOP4
76387: PUSH
76388: NOP4
76392: IN
76393: NOT
76394: OR
76395: IFFALSE 76399
// exit ;
76397: GO 76522
// for i = 1 to mc_vehicles do
76399: NOP4
76403: PUSH
76404: DOUBLE
76405: LD_INT 1
76407: DEC
76408: ST_TO_ADDR
76409: NOP4
76413: PUSH
76414: FOR_TO
76415: IFFALSE 76520
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76417: NOP4
76421: PUSH
76422: NOP4
76426: PUSH
76427: NOP4
76431: ARRAY
76432: IN
76433: PUSH
76434: NOP4
76438: PUSH
76439: NOP4
76443: PUSH
76444: NOP4
76448: ARRAY
76449: IN
76450: OR
76451: IFFALSE 76518
// begin tmp := mc_vehicles [ i ] diff old ;
76453: NOP4
76457: PUSH
76458: NOP4
76462: PUSH
76463: NOP4
76467: ARRAY
76468: PUSH
76469: NOP4
76473: DIFF
76474: ST_TO_ADDR
// tmp := tmp diff new ;
76475: NOP4
76479: PUSH
76480: NOP4
76484: PUSH
76485: NOP4
76489: DIFF
76490: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76491: NOP4
76495: PUSH
76496: NOP4
76500: PPUSH
76501: NOP4
76505: PPUSH
76506: NOP4
76510: PPUSH
76511: NOP4
76515: ST_TO_ADDR
// break ;
76516: GO 76520
// end ;
76518: GO 76414
76520: POP
76521: POP
// end ;
76522: LD_VAR 0 5
76526: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76527: LD_INT 0
76529: PPUSH
76530: PPUSH
76531: PPUSH
76532: PPUSH
// if not mc_bases or not skirmish then
76533: NOP4
76537: NOT
76538: PUSH
76539: NOP4
76543: NOT
76544: OR
76545: IFFALSE 76549
// exit ;
76547: GO 76941
// side := GetSide ( vehicle ) ;
76549: NOP4
76553: PUSH
76554: NOP4
76558: PPUSH
76559: NOP4
76563: ST_TO_ADDR
// for i = 1 to mc_bases do
76564: NOP4
76568: PUSH
76569: DOUBLE
76570: LD_INT 1
76572: DEC
76573: ST_TO_ADDR
76574: NOP4
76578: PUSH
76579: FOR_TO
76580: IFFALSE 76939
// begin if factory in mc_bases [ i ] then
76582: NOP4
76586: PUSH
76587: NOP4
76591: PUSH
76592: NOP4
76596: ARRAY
76597: IN
76598: IFFALSE 76937
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
76600: NOP4
76604: PUSH
76605: NOP4
76609: ARRAY
76610: PUSH
76611: NOP4
76615: PUSH
76616: NOP4
76620: ARRAY
76621: LESS
76622: PUSH
76623: NOP4
76627: PPUSH
76628: NOP4
76632: PUSH
76633: LD_INT 31
76635: PUSH
76636: LD_INT 32
76638: PUSH
76639: LD_INT 51
76641: PUSH
76642: NOP4
76646: PUSH
76647: LD_INT 12
76649: PUSH
76650: LD_INT 30
76652: PUSH
76653: NOP4
76657: PUSH
76658: LD_INT 11
76660: PUSH
76661: LD_INT 53
76663: PUSH
76664: LD_INT 14
76666: PUSH
76667: NOP4
76671: PUSH
76672: LD_INT 29
76674: PUSH
76675: NOP4
76679: PUSH
76680: LD_INT 13
76682: PUSH
76683: LD_INT 52
76685: PUSH
76686: NOP4
76690: PUSH
76691: LD_INT 48
76693: PUSH
76694: LD_INT 8
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: LIST
76701: LIST
76702: LIST
76703: LIST
76704: LIST
76705: LIST
76706: LIST
76707: LIST
76708: LIST
76709: LIST
76710: LIST
76711: LIST
76712: LIST
76713: LIST
76714: LIST
76715: LIST
76716: IN
76717: NOT
76718: AND
76719: IFFALSE 76767
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76721: NOP4
76725: PUSH
76726: NOP4
76730: PPUSH
76731: NOP4
76735: PUSH
76736: NOP4
76740: PUSH
76741: NOP4
76745: ARRAY
76746: PUSH
76747: LD_INT 1
76749: PLUS
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: PPUSH
76755: NOP4
76759: PPUSH
76760: NOP4
76764: ST_TO_ADDR
76765: GO 76811
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76767: NOP4
76771: PUSH
76772: NOP4
76776: PPUSH
76777: NOP4
76781: PUSH
76782: NOP4
76786: PUSH
76787: NOP4
76791: ARRAY
76792: PUSH
76793: LD_INT 1
76795: PLUS
76796: PUSH
76797: EMPTY
76798: LIST
76799: LIST
76800: PPUSH
76801: NOP4
76805: PPUSH
76806: NOP4
76810: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76811: NOP4
76815: PPUSH
76816: NOP4
76820: PUSH
76821: LD_INT 2
76823: EQUAL
76824: IFFALSE 76853
// begin repeat wait ( 0 0$3 ) ;
76826: LD_INT 105
76828: PPUSH
76829: NOP4
// Connect ( vehicle ) ;
76833: NOP4
76837: PPUSH
76838: NOP4
// until IsControledBy ( vehicle ) ;
76842: NOP4
76846: PPUSH
76847: NOP4
76851: IFFALSE 76826
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76853: NOP4
76857: PPUSH
76858: NOP4
76862: PUSH
76863: NOP4
76867: ARRAY
76868: PPUSH
76869: NOP4
// if GetControl ( vehicle ) <> control_manual then
76873: NOP4
76877: PPUSH
76878: NOP4
76882: PUSH
76883: LD_INT 1
76885: NONEQUAL
76886: IFFALSE 76890
// break ;
76888: GO 76939
// repeat wait ( 0 0$1 ) ;
76890: LD_INT 35
76892: PPUSH
76893: NOP4
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76897: NOP4
76901: PPUSH
76902: NOP4
76906: PUSH
76907: NOP4
76911: ARRAY
76912: PPUSH
76913: NOP4
76917: IFFALSE 76890
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76919: NOP4
76923: PPUSH
76924: NOP4
76928: PPUSH
76929: NOP4
// exit ;
76933: POP
76934: POP
76935: GO 76941
// end ; end ;
76937: GO 76579
76939: POP
76940: POP
// end ;
76941: LD_VAR 0 3
76945: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76946: LD_INT 0
76948: PPUSH
76949: PPUSH
76950: PPUSH
76951: PPUSH
// if not mc_bases or not skirmish then
76952: NOP4
76956: NOT
76957: PUSH
76958: NOP4
76962: NOT
76963: OR
76964: IFFALSE 76968
// exit ;
76966: GO 77321
// repeat wait ( 0 0$1 ) ;
76968: LD_INT 35
76970: PPUSH
76971: NOP4
// until GetResourceAmountXY ( x , y ) ;
76975: NOP4
76979: PPUSH
76980: NOP4
76984: PPUSH
76985: NOP4
76989: IFFALSE 76968
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76991: NOP4
76995: PPUSH
76996: NOP4
77000: PPUSH
77001: NOP4
77005: PUSH
77006: LD_INT 4
77008: EQUAL
77009: IFFALSE 77013
// exit ;
77011: GO 77321
// for i = 1 to mc_bases do
77013: NOP4
77017: PUSH
77018: DOUBLE
77019: LD_INT 1
77021: DEC
77022: ST_TO_ADDR
77023: NOP4
77027: PUSH
77028: FOR_TO
77029: IFFALSE 77319
// begin if mc_crates_area [ i ] then
77031: NOP4
77035: PUSH
77036: NOP4
77040: ARRAY
77041: IFFALSE 77152
// for j in mc_crates_area [ i ] do
77043: NOP4
77047: PUSH
77048: NOP4
77052: PUSH
77053: NOP4
77057: ARRAY
77058: PUSH
77059: FOR_IN
77060: IFFALSE 77150
// if InArea ( x , y , j ) then
77062: NOP4
77066: PPUSH
77067: NOP4
77071: PPUSH
77072: NOP4
77076: PPUSH
77077: NOP4
77081: IFFALSE 77148
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77083: NOP4
77087: PUSH
77088: NOP4
77092: PPUSH
77093: NOP4
77097: PUSH
77098: NOP4
77102: PUSH
77103: NOP4
77107: ARRAY
77108: PUSH
77109: LD_INT 1
77111: PLUS
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: PPUSH
77117: NOP4
77121: PUSH
77122: NOP4
77126: PUSH
77127: NOP4
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: LIST
77136: PPUSH
77137: NOP4
77141: ST_TO_ADDR
// exit ;
77142: POP
77143: POP
77144: POP
77145: POP
77146: GO 77321
// end ;
77148: GO 77059
77150: POP
77151: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77152: NOP4
77156: PUSH
77157: NOP4
77161: PUSH
77162: NOP4
77166: ARRAY
77167: PPUSH
77168: LD_INT 2
77170: PUSH
77171: LD_INT 30
77173: PUSH
77174: LD_INT 0
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PUSH
77181: LD_INT 30
77183: PUSH
77184: LD_INT 1
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: EMPTY
77192: LIST
77193: LIST
77194: LIST
77195: PPUSH
77196: NOP4
77200: ST_TO_ADDR
// if not depot then
77201: NOP4
77205: NOT
77206: IFFALSE 77210
// continue ;
77208: GO 77028
// for j in depot do
77210: NOP4
77214: PUSH
77215: NOP4
77219: PUSH
77220: FOR_IN
77221: IFFALSE 77315
// if GetDistUnitXY ( j , x , y ) < 30 then
77223: NOP4
77227: PPUSH
77228: NOP4
77232: PPUSH
77233: NOP4
77237: PPUSH
77238: NOP4
77242: PUSH
77243: LD_INT 30
77245: LESS
77246: IFFALSE 77313
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77248: NOP4
77252: PUSH
77253: NOP4
77257: PPUSH
77258: NOP4
77262: PUSH
77263: NOP4
77267: PUSH
77268: NOP4
77272: ARRAY
77273: PUSH
77274: LD_INT 1
77276: PLUS
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: PPUSH
77282: NOP4
77286: PUSH
77287: NOP4
77291: PUSH
77292: NOP4
77296: PUSH
77297: EMPTY
77298: LIST
77299: LIST
77300: LIST
77301: PPUSH
77302: NOP4
77306: ST_TO_ADDR
// exit ;
77307: POP
77308: POP
77309: POP
77310: POP
77311: GO 77321
// end ;
77313: GO 77220
77315: POP
77316: POP
// end ;
77317: GO 77028
77319: POP
77320: POP
// end ;
77321: LD_VAR 0 6
77325: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77326: LD_INT 0
77328: PPUSH
77329: PPUSH
77330: PPUSH
77331: PPUSH
// if not mc_bases or not skirmish then
77332: NOP4
77336: NOT
77337: PUSH
77338: NOP4
77342: NOT
77343: OR
77344: IFFALSE 77348
// exit ;
77346: GO 77625
// side := GetSide ( lab ) ;
77348: NOP4
77352: PUSH
77353: NOP4
77357: PPUSH
77358: NOP4
77362: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77363: NOP4
77367: PUSH
77368: NOP4
77372: IN
77373: NOT
77374: PUSH
77375: NOP4
77379: NOT
77380: OR
77381: PUSH
77382: NOP4
77386: NOT
77387: OR
77388: IFFALSE 77392
// exit ;
77390: GO 77625
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77392: NOP4
77396: PUSH
77397: NOP4
77401: PPUSH
77402: NOP4
77406: PPUSH
77407: NOP4
77411: PUSH
77412: NOP4
77416: ARRAY
77417: PUSH
77418: NOP4
77422: DIFF
77423: PPUSH
77424: NOP4
77428: ST_TO_ADDR
// for i = 1 to mc_bases do
77429: NOP4
77433: PUSH
77434: DOUBLE
77435: LD_INT 1
77437: DEC
77438: ST_TO_ADDR
77439: NOP4
77443: PUSH
77444: FOR_TO
77445: IFFALSE 77623
// begin if lab in mc_bases [ i ] then
77447: NOP4
77451: PUSH
77452: NOP4
77456: PUSH
77457: NOP4
77461: ARRAY
77462: IN
77463: IFFALSE 77621
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
77465: NOP4
77469: PUSH
77470: LD_INT 11
77472: PUSH
77473: LD_INT 4
77475: PUSH
77476: LD_INT 3
77478: PUSH
77479: LD_INT 2
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: LIST
77486: LIST
77487: IN
77488: PUSH
77489: NOP4
77493: PUSH
77494: NOP4
77498: ARRAY
77499: AND
77500: IFFALSE 77621
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
77502: NOP4
77506: PUSH
77507: NOP4
77511: PUSH
77512: NOP4
77516: ARRAY
77517: PUSH
77518: LD_INT 1
77520: ARRAY
77521: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77522: NOP4
77526: PUSH
77527: NOP4
77531: PPUSH
77532: NOP4
77536: PPUSH
77537: EMPTY
77538: PPUSH
77539: NOP4
77543: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77544: NOP4
77548: PPUSH
77549: LD_INT 0
77551: PPUSH
77552: NOP4
// ComExitBuilding ( tmp ) ;
77556: NOP4
77560: PPUSH
77561: NOP4
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77565: NOP4
77569: PUSH
77570: NOP4
77574: PPUSH
77575: NOP4
77579: PPUSH
77580: NOP4
77584: PUSH
77585: NOP4
77589: ARRAY
77590: PPUSH
77591: LD_INT 1
77593: PPUSH
77594: NOP4
77598: PPUSH
77599: NOP4
77603: PPUSH
77604: NOP4
77608: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77609: NOP4
77613: PPUSH
77614: LD_INT 112
77616: PPUSH
77617: NOP4
// end ; end ; end ;
77621: GO 77444
77623: POP
77624: POP
// end ;
77625: LD_VAR 0 3
77629: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77630: LD_INT 0
77632: PPUSH
77633: PPUSH
77634: PPUSH
77635: PPUSH
77636: PPUSH
77637: PPUSH
77638: PPUSH
77639: PPUSH
// if not mc_bases or not skirmish then
77640: NOP4
77644: NOT
77645: PUSH
77646: NOP4
77650: NOT
77651: OR
77652: IFFALSE 77656
// exit ;
77654: GO 79027
// for i = 1 to mc_bases do
77656: NOP4
77660: PUSH
77661: DOUBLE
77662: LD_INT 1
77664: DEC
77665: ST_TO_ADDR
77666: NOP4
77670: PUSH
77671: FOR_TO
77672: IFFALSE 79025
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77674: NOP4
77678: PUSH
77679: NOP4
77683: PUSH
77684: NOP4
77688: ARRAY
77689: IN
77690: PUSH
77691: NOP4
77695: PUSH
77696: NOP4
77700: PUSH
77701: NOP4
77705: ARRAY
77706: IN
77707: OR
77708: PUSH
77709: NOP4
77713: PUSH
77714: NOP4
77718: PUSH
77719: NOP4
77723: ARRAY
77724: IN
77725: OR
77726: PUSH
77727: NOP4
77731: PUSH
77732: NOP4
77736: PUSH
77737: NOP4
77741: ARRAY
77742: IN
77743: OR
77744: PUSH
77745: NOP4
77749: PUSH
77750: NOP4
77754: PUSH
77755: NOP4
77759: ARRAY
77760: IN
77761: OR
77762: PUSH
77763: NOP4
77767: PUSH
77768: NOP4
77772: PUSH
77773: NOP4
77777: ARRAY
77778: IN
77779: OR
77780: IFFALSE 79023
// begin if un in mc_ape [ i ] then
77782: NOP4
77786: PUSH
77787: NOP4
77791: PUSH
77792: NOP4
77796: ARRAY
77797: IN
77798: IFFALSE 77837
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77800: NOP4
77804: PUSH
77805: NOP4
77809: PPUSH
77810: NOP4
77814: PPUSH
77815: NOP4
77819: PUSH
77820: NOP4
77824: ARRAY
77825: PUSH
77826: NOP4
77830: DIFF
77831: PPUSH
77832: NOP4
77836: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77837: NOP4
77841: PUSH
77842: NOP4
77846: PUSH
77847: NOP4
77851: ARRAY
77852: IN
77853: IFFALSE 77877
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77855: NOP4
77859: PUSH
77860: NOP4
77864: PPUSH
77865: NOP4
77869: PPUSH
77870: EMPTY
77871: PPUSH
77872: NOP4
77876: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77877: NOP4
77881: PPUSH
77882: NOP4
77886: PUSH
77887: LD_INT 2
77889: EQUAL
77890: PUSH
77891: NOP4
77895: PPUSH
77896: NOP4
77900: PUSH
77901: LD_INT 20
77903: EQUAL
77904: PUSH
77905: NOP4
77909: PUSH
77910: NOP4
77914: PUSH
77915: NOP4
77919: ARRAY
77920: IN
77921: OR
77922: PUSH
77923: NOP4
77927: PPUSH
77928: NOP4
77932: PUSH
77933: LD_INT 12
77935: PUSH
77936: LD_INT 51
77938: PUSH
77939: NOP4
77943: PUSH
77944: LD_INT 32
77946: PUSH
77947: LD_INT 13
77949: PUSH
77950: LD_INT 52
77952: PUSH
77953: LD_INT 31
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: LIST
77960: LIST
77961: LIST
77962: LIST
77963: LIST
77964: IN
77965: OR
77966: AND
77967: IFFALSE 78275
// begin if un in mc_defender [ i ] then
77969: NOP4
77973: PUSH
77974: NOP4
77978: PUSH
77979: NOP4
77983: ARRAY
77984: IN
77985: IFFALSE 78024
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77987: NOP4
77991: PUSH
77992: NOP4
77996: PPUSH
77997: NOP4
78001: PPUSH
78002: NOP4
78006: PUSH
78007: NOP4
78011: ARRAY
78012: PUSH
78013: NOP4
78017: DIFF
78018: PPUSH
78019: NOP4
78023: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78024: NOP4
78028: PUSH
78029: NOP4
78033: PPUSH
78034: LD_INT 3
78036: PPUSH
78037: NOP4
78041: ST_TO_ADDR
// if fac then
78042: NOP4
78046: IFFALSE 78275
// begin for j in fac do
78048: NOP4
78052: PUSH
78053: NOP4
78057: PUSH
78058: FOR_IN
78059: IFFALSE 78273
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78061: NOP4
78065: PUSH
78066: NOP4
78070: PPUSH
78071: NOP4
78075: PPUSH
78076: NOP4
78080: PPUSH
78081: NOP4
78085: PPUSH
78086: NOP4
78090: PPUSH
78091: NOP4
78095: PPUSH
78096: NOP4
78100: PPUSH
78101: NOP4
78105: PPUSH
78106: NOP4
78110: PPUSH
78111: NOP4
78115: ST_TO_ADDR
// if components then
78116: NOP4
78120: IFFALSE 78271
// begin if GetWeapon ( un ) = ar_control_tower then
78122: NOP4
78126: PPUSH
78127: NOP4
78131: PUSH
78132: LD_INT 31
78134: EQUAL
78135: IFFALSE 78252
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
78137: NOP4
78141: PPUSH
78142: NOP4
78146: PPUSH
78147: LD_INT 0
78149: PPUSH
78150: NOP4
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78154: NOP4
78158: PUSH
78159: NOP4
78163: PPUSH
78164: NOP4
78168: PPUSH
78169: NOP4
78173: PUSH
78174: NOP4
78178: ARRAY
78179: PUSH
78180: NOP4
78184: PPUSH
78185: NOP4
78189: DIFF
78190: PPUSH
78191: NOP4
78195: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78196: NOP4
78200: PUSH
78201: NOP4
78205: PUSH
78206: NOP4
78210: ARRAY
78211: PPUSH
78212: LD_INT 1
78214: PPUSH
78215: NOP4
78219: PPUSH
78220: NOP4
78224: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78225: NOP4
78229: PUSH
78230: NOP4
78234: PPUSH
78235: NOP4
78239: PPUSH
78240: NOP4
78244: PPUSH
78245: NOP4
78249: ST_TO_ADDR
// end else
78250: GO 78269
// MC_InsertProduceList ( i , [ components ] ) ;
78252: NOP4
78256: PPUSH
78257: NOP4
78261: PUSH
78262: EMPTY
78263: LIST
78264: PPUSH
78265: NOP4
// break ;
78269: GO 78273
// end ; end ;
78271: GO 78058
78273: POP
78274: POP
// end ; end ; if GetType ( un ) = unit_building then
78275: NOP4
78279: PPUSH
78280: NOP4
78284: PUSH
78285: LD_INT 3
78287: EQUAL
78288: IFFALSE 78691
// begin btype := GetBType ( un ) ;
78290: NOP4
78294: PUSH
78295: NOP4
78299: PPUSH
78300: NOP4
78304: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78305: NOP4
78309: PUSH
78310: LD_INT 29
78312: PUSH
78313: LD_INT 30
78315: PUSH
78316: EMPTY
78317: LIST
78318: LIST
78319: IN
78320: IFFALSE 78393
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78322: NOP4
78326: PPUSH
78327: NOP4
78331: PPUSH
78332: NOP4
78336: PPUSH
78337: NOP4
78341: PPUSH
78342: NOP4
78346: PPUSH
78347: NOP4
78351: PPUSH
78352: NOP4
78356: NOT
78357: IFFALSE 78393
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78359: NOP4
78363: PPUSH
78364: NOP4
78368: PPUSH
78369: NOP4
78373: PPUSH
78374: NOP4
78378: PPUSH
78379: NOP4
78383: PPUSH
78384: NOP4
78388: PPUSH
78389: NOP4
// end ; if btype = b_warehouse then
78393: NOP4
78397: PUSH
78398: LD_INT 1
78400: EQUAL
78401: IFFALSE 78419
// begin btype := b_depot ;
78403: NOP4
78407: PUSH
78408: LD_INT 0
78410: ST_TO_ADDR
// pos := 1 ;
78411: NOP4
78415: PUSH
78416: LD_INT 1
78418: ST_TO_ADDR
// end ; if btype = b_factory then
78419: NOP4
78423: PUSH
78424: LD_INT 3
78426: EQUAL
78427: IFFALSE 78445
// begin btype := b_workshop ;
78429: NOP4
78433: PUSH
78434: LD_INT 2
78436: ST_TO_ADDR
// pos := 1 ;
78437: NOP4
78441: PUSH
78442: LD_INT 1
78444: ST_TO_ADDR
// end ; if btype = b_barracks then
78445: NOP4
78449: PUSH
78450: LD_INT 5
78452: EQUAL
78453: IFFALSE 78463
// btype := b_armoury ;
78455: NOP4
78459: PUSH
78460: LD_INT 4
78462: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
78463: NOP4
78467: PUSH
78468: LD_INT 7
78470: PUSH
78471: LD_INT 8
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: IN
78478: IFFALSE 78488
// btype := b_lab ;
78480: NOP4
78484: PUSH
78485: LD_INT 6
78487: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
78488: NOP4
78492: PUSH
78493: NOP4
78497: PPUSH
78498: NOP4
78502: PUSH
78503: NOP4
78507: PUSH
78508: NOP4
78512: ARRAY
78513: PUSH
78514: LD_INT 1
78516: PLUS
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PPUSH
78522: NOP4
78526: PUSH
78527: NOP4
78531: PPUSH
78532: NOP4
78536: PUSH
78537: NOP4
78541: PPUSH
78542: NOP4
78546: PUSH
78547: NOP4
78551: PPUSH
78552: NOP4
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: LIST
78561: LIST
78562: PPUSH
78563: NOP4
78567: ST_TO_ADDR
// if pos = 1 then
78568: NOP4
78572: PUSH
78573: LD_INT 1
78575: EQUAL
78576: IFFALSE 78691
// begin tmp := mc_build_list [ i ] ;
78578: NOP4
78582: PUSH
78583: NOP4
78587: PUSH
78588: NOP4
78592: ARRAY
78593: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78594: NOP4
78598: PPUSH
78599: LD_INT 2
78601: PUSH
78602: LD_INT 30
78604: PUSH
78605: LD_INT 0
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PUSH
78612: LD_INT 30
78614: PUSH
78615: LD_INT 1
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: LIST
78626: PPUSH
78627: NOP4
78631: IFFALSE 78641
// pos := 2 ;
78633: NOP4
78637: PUSH
78638: LD_INT 2
78640: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78641: NOP4
78645: PUSH
78646: NOP4
78650: PPUSH
78651: NOP4
78655: PPUSH
78656: NOP4
78660: PPUSH
78661: NOP4
78665: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78666: NOP4
78670: PUSH
78671: NOP4
78675: PPUSH
78676: NOP4
78680: PPUSH
78681: NOP4
78685: PPUSH
78686: NOP4
78690: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78691: NOP4
78695: PUSH
78696: NOP4
78700: PUSH
78701: NOP4
78705: ARRAY
78706: IN
78707: IFFALSE 78746
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78709: NOP4
78713: PUSH
78714: NOP4
78718: PPUSH
78719: NOP4
78723: PPUSH
78724: NOP4
78728: PUSH
78729: NOP4
78733: ARRAY
78734: PUSH
78735: NOP4
78739: DIFF
78740: PPUSH
78741: NOP4
78745: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78746: NOP4
78750: PUSH
78751: NOP4
78755: PUSH
78756: NOP4
78760: ARRAY
78761: IN
78762: IFFALSE 78801
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78764: NOP4
78768: PUSH
78769: NOP4
78773: PPUSH
78774: NOP4
78778: PPUSH
78779: NOP4
78783: PUSH
78784: NOP4
78788: ARRAY
78789: PUSH
78790: NOP4
78794: DIFF
78795: PPUSH
78796: NOP4
78800: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78801: NOP4
78805: PUSH
78806: NOP4
78810: PUSH
78811: NOP4
78815: ARRAY
78816: IN
78817: IFFALSE 78856
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78819: NOP4
78823: PUSH
78824: NOP4
78828: PPUSH
78829: NOP4
78833: PPUSH
78834: NOP4
78838: PUSH
78839: NOP4
78843: ARRAY
78844: PUSH
78845: NOP4
78849: DIFF
78850: PPUSH
78851: NOP4
78855: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78856: NOP4
78860: PUSH
78861: NOP4
78865: PUSH
78866: NOP4
78870: ARRAY
78871: IN
78872: IFFALSE 78911
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78874: NOP4
78878: PUSH
78879: NOP4
78883: PPUSH
78884: NOP4
78888: PPUSH
78889: NOP4
78893: PUSH
78894: NOP4
78898: ARRAY
78899: PUSH
78900: NOP4
78904: DIFF
78905: PPUSH
78906: NOP4
78910: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78911: NOP4
78915: PUSH
78916: NOP4
78920: PUSH
78921: NOP4
78925: ARRAY
78926: IN
78927: IFFALSE 78966
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78929: NOP4
78933: PUSH
78934: NOP4
78938: PPUSH
78939: NOP4
78943: PPUSH
78944: NOP4
78948: PUSH
78949: NOP4
78953: ARRAY
78954: PUSH
78955: NOP4
78959: DIFF
78960: PPUSH
78961: NOP4
78965: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78966: NOP4
78970: PUSH
78971: NOP4
78975: PUSH
78976: NOP4
78980: ARRAY
78981: IN
78982: IFFALSE 79021
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78984: NOP4
78988: PUSH
78989: NOP4
78993: PPUSH
78994: NOP4
78998: PPUSH
78999: NOP4
79003: PUSH
79004: NOP4
79008: ARRAY
79009: PUSH
79010: NOP4
79014: DIFF
79015: PPUSH
79016: NOP4
79020: ST_TO_ADDR
// end ; break ;
79021: GO 79025
// end ;
79023: GO 77671
79025: POP
79026: POP
// end ;
79027: LD_VAR 0 2
79031: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79032: LD_INT 0
79034: PPUSH
79035: PPUSH
79036: PPUSH
// if not mc_bases or not skirmish then
79037: NOP4
79041: NOT
79042: PUSH
79043: NOP4
79047: NOT
79048: OR
79049: IFFALSE 79053
// exit ;
79051: GO 79268
// for i = 1 to mc_bases do
79053: NOP4
79057: PUSH
79058: DOUBLE
79059: LD_INT 1
79061: DEC
79062: ST_TO_ADDR
79063: NOP4
79067: PUSH
79068: FOR_TO
79069: IFFALSE 79266
// begin if building in mc_construct_list [ i ] then
79071: NOP4
79075: PUSH
79076: NOP4
79080: PUSH
79081: NOP4
79085: ARRAY
79086: IN
79087: IFFALSE 79264
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79089: NOP4
79093: PUSH
79094: NOP4
79098: PPUSH
79099: NOP4
79103: PPUSH
79104: NOP4
79108: PUSH
79109: NOP4
79113: ARRAY
79114: PUSH
79115: NOP4
79119: DIFF
79120: PPUSH
79121: NOP4
79125: ST_TO_ADDR
// if building in mc_lab [ i ] then
79126: NOP4
79130: PUSH
79131: NOP4
79135: PUSH
79136: NOP4
79140: ARRAY
79141: IN
79142: IFFALSE 79197
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79144: NOP4
79148: PUSH
79149: NOP4
79153: PPUSH
79154: NOP4
79158: PPUSH
79159: NOP4
79163: PUSH
79164: NOP4
79168: ARRAY
79169: PPUSH
79170: LD_INT 1
79172: PPUSH
79173: NOP4
79177: PUSH
79178: NOP4
79182: ARRAY
79183: PPUSH
79184: LD_INT 0
79186: PPUSH
79187: NOP4
79191: PPUSH
79192: NOP4
79196: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79197: NOP4
79201: PUSH
79202: NOP4
79206: PUSH
79207: NOP4
79211: ARRAY
79212: IN
79213: NOT
79214: IFFALSE 79260
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79216: NOP4
79220: PUSH
79221: NOP4
79225: PPUSH
79226: NOP4
79230: PUSH
79231: NOP4
79235: PUSH
79236: NOP4
79240: ARRAY
79241: PUSH
79242: LD_INT 1
79244: PLUS
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PPUSH
79250: NOP4
79254: PPUSH
79255: NOP4
79259: ST_TO_ADDR
// exit ;
79260: POP
79261: POP
79262: GO 79268
// end ; end ;
79264: GO 79068
79266: POP
79267: POP
// end ;
79268: LD_VAR 0 2
79272: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79273: LD_INT 0
79275: PPUSH
79276: PPUSH
79277: PPUSH
79278: PPUSH
79279: PPUSH
79280: PPUSH
79281: PPUSH
// if not mc_bases or not skirmish then
79282: NOP4
79286: NOT
79287: PUSH
79288: NOP4
79292: NOT
79293: OR
79294: IFFALSE 79298
// exit ;
79296: GO 79959
// for i = 1 to mc_bases do
79298: NOP4
79302: PUSH
79303: DOUBLE
79304: LD_INT 1
79306: DEC
79307: ST_TO_ADDR
79308: NOP4
79312: PUSH
79313: FOR_TO
79314: IFFALSE 79957
// begin if building in mc_construct_list [ i ] then
79316: NOP4
79320: PUSH
79321: NOP4
79325: PUSH
79326: NOP4
79330: ARRAY
79331: IN
79332: IFFALSE 79955
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79334: NOP4
79338: PUSH
79339: NOP4
79343: PPUSH
79344: NOP4
79348: PPUSH
79349: NOP4
79353: PUSH
79354: NOP4
79358: ARRAY
79359: PUSH
79360: NOP4
79364: DIFF
79365: PPUSH
79366: NOP4
79370: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79371: NOP4
79375: PUSH
79376: NOP4
79380: PPUSH
79381: NOP4
79385: PUSH
79386: NOP4
79390: PUSH
79391: NOP4
79395: ARRAY
79396: PUSH
79397: LD_INT 1
79399: PLUS
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PPUSH
79405: NOP4
79409: PPUSH
79410: NOP4
79414: ST_TO_ADDR
// btype := GetBType ( building ) ;
79415: NOP4
79419: PUSH
79420: NOP4
79424: PPUSH
79425: NOP4
79429: ST_TO_ADDR
// side := GetSide ( building ) ;
79430: NOP4
79434: PUSH
79435: NOP4
79439: PPUSH
79440: NOP4
79444: ST_TO_ADDR
// if btype = b_lab then
79445: NOP4
79449: PUSH
79450: LD_INT 6
79452: EQUAL
79453: IFFALSE 79503
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
79455: NOP4
79459: PUSH
79460: NOP4
79464: PPUSH
79465: NOP4
79469: PUSH
79470: NOP4
79474: PUSH
79475: NOP4
79479: ARRAY
79480: PUSH
79481: LD_INT 1
79483: PLUS
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PPUSH
79489: NOP4
79493: PPUSH
79494: NOP4
79498: ST_TO_ADDR
// exit ;
79499: POP
79500: POP
79501: GO 79959
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
79503: NOP4
79507: PUSH
79508: LD_INT 0
79510: PUSH
79511: LD_INT 2
79513: PUSH
79514: LD_INT 4
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: LIST
79521: IN
79522: IFFALSE 79646
// begin if btype = b_armoury then
79524: NOP4
79528: PUSH
79529: LD_INT 4
79531: EQUAL
79532: IFFALSE 79542
// btype := b_barracks ;
79534: NOP4
79538: PUSH
79539: LD_INT 5
79541: ST_TO_ADDR
// if btype = b_depot then
79542: NOP4
79546: PUSH
79547: LD_INT 0
79549: EQUAL
79550: IFFALSE 79560
// btype := b_warehouse ;
79552: NOP4
79556: PUSH
79557: LD_INT 1
79559: ST_TO_ADDR
// if btype = b_workshop then
79560: NOP4
79564: PUSH
79565: LD_INT 2
79567: EQUAL
79568: IFFALSE 79578
// btype := b_factory ;
79570: NOP4
79574: PUSH
79575: LD_INT 3
79577: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79578: NOP4
79582: PPUSH
79583: NOP4
79587: PPUSH
79588: NOP4
79592: PUSH
79593: LD_INT 1
79595: EQUAL
79596: IFFALSE 79642
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79598: NOP4
79602: PUSH
79603: NOP4
79607: PPUSH
79608: NOP4
79612: PUSH
79613: NOP4
79617: PUSH
79618: NOP4
79622: ARRAY
79623: PUSH
79624: LD_INT 1
79626: PLUS
79627: PUSH
79628: EMPTY
79629: LIST
79630: LIST
79631: PPUSH
79632: NOP4
79636: PPUSH
79637: NOP4
79641: ST_TO_ADDR
// exit ;
79642: POP
79643: POP
79644: GO 79959
// end ; if btype in [ b_bunker , b_turret ] then
79646: NOP4
79650: PUSH
79651: LD_INT 32
79653: PUSH
79654: LD_INT 33
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: IN
79661: IFFALSE 79951
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79663: NOP4
79667: PUSH
79668: NOP4
79672: PPUSH
79673: NOP4
79677: PUSH
79678: NOP4
79682: PUSH
79683: NOP4
79687: ARRAY
79688: PUSH
79689: LD_INT 1
79691: PLUS
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PPUSH
79697: NOP4
79701: PPUSH
79702: NOP4
79706: ST_TO_ADDR
// if btype = b_bunker then
79707: NOP4
79711: PUSH
79712: LD_INT 32
79714: EQUAL
79715: IFFALSE 79951
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79717: NOP4
79721: PUSH
79722: NOP4
79726: PPUSH
79727: NOP4
79731: PUSH
79732: NOP4
79736: PUSH
79737: NOP4
79741: ARRAY
79742: PUSH
79743: LD_INT 1
79745: PLUS
79746: PUSH
79747: EMPTY
79748: LIST
79749: LIST
79750: PPUSH
79751: NOP4
79755: PPUSH
79756: NOP4
79760: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79761: NOP4
79765: PUSH
79766: NOP4
79770: PUSH
79771: NOP4
79775: ARRAY
79776: PPUSH
79777: LD_INT 25
79779: PUSH
79780: LD_INT 1
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: PUSH
79787: LD_INT 3
79789: PUSH
79790: LD_INT 54
79792: PUSH
79793: EMPTY
79794: LIST
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: PPUSH
79804: NOP4
79808: ST_TO_ADDR
// if tmp then
79809: NOP4
79813: IFFALSE 79819
// exit ;
79815: POP
79816: POP
79817: GO 79959
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79819: NOP4
79823: PUSH
79824: NOP4
79828: PUSH
79829: NOP4
79833: ARRAY
79834: PPUSH
79835: LD_INT 2
79837: PUSH
79838: LD_INT 30
79840: PUSH
79841: LD_INT 4
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 30
79850: PUSH
79851: LD_INT 5
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: LIST
79862: PPUSH
79863: NOP4
79867: ST_TO_ADDR
// if not tmp then
79868: NOP4
79872: NOT
79873: IFFALSE 79879
// exit ;
79875: POP
79876: POP
79877: GO 79959
// for j in tmp do
79879: NOP4
79883: PUSH
79884: NOP4
79888: PUSH
79889: FOR_IN
79890: IFFALSE 79949
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79892: NOP4
79896: PUSH
79897: NOP4
79901: PPUSH
79902: NOP4
79906: PPUSH
79907: LD_INT 25
79909: PUSH
79910: LD_INT 1
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PPUSH
79917: NOP4
79921: ST_TO_ADDR
// if units then
79922: NOP4
79926: IFFALSE 79947
// begin ComExitBuilding ( units [ 1 ] ) ;
79928: NOP4
79932: PUSH
79933: LD_INT 1
79935: ARRAY
79936: PPUSH
79937: NOP4
// exit ;
79941: POP
79942: POP
79943: POP
79944: POP
79945: GO 79959
// end ; end ;
79947: GO 79889
79949: POP
79950: POP
// end ; end ; exit ;
79951: POP
79952: POP
79953: GO 79959
// end ; end ;
79955: GO 79313
79957: POP
79958: POP
// end ;
79959: LD_VAR 0 2
79963: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79964: LD_INT 0
79966: PPUSH
79967: PPUSH
79968: PPUSH
79969: PPUSH
79970: PPUSH
79971: PPUSH
79972: PPUSH
// if not mc_bases or not skirmish then
79973: NOP4
79977: NOT
79978: PUSH
79979: NOP4
79983: NOT
79984: OR
79985: IFFALSE 79989
// exit ;
79987: GO 80254
// btype := GetBType ( building ) ;
79989: NOP4
79993: PUSH
79994: NOP4
79998: PPUSH
79999: NOP4
80003: ST_TO_ADDR
// x := GetX ( building ) ;
80004: NOP4
80008: PUSH
80009: NOP4
80013: PPUSH
80014: NOP4
80018: ST_TO_ADDR
// y := GetY ( building ) ;
80019: NOP4
80023: PUSH
80024: NOP4
80028: PPUSH
80029: NOP4
80033: ST_TO_ADDR
// d := GetDir ( building ) ;
80034: NOP4
80038: PUSH
80039: NOP4
80043: PPUSH
80044: NOP4
80048: ST_TO_ADDR
// for i = 1 to mc_bases do
80049: NOP4
80053: PUSH
80054: DOUBLE
80055: LD_INT 1
80057: DEC
80058: ST_TO_ADDR
80059: NOP4
80063: PUSH
80064: FOR_TO
80065: IFFALSE 80252
// begin if not mc_build_list [ i ] then
80067: NOP4
80071: PUSH
80072: NOP4
80076: ARRAY
80077: NOT
80078: IFFALSE 80082
// continue ;
80080: GO 80064
// for j := 1 to mc_build_list [ i ] do
80082: NOP4
80086: PUSH
80087: DOUBLE
80088: LD_INT 1
80090: DEC
80091: ST_TO_ADDR
80092: NOP4
80096: PUSH
80097: NOP4
80101: ARRAY
80102: PUSH
80103: FOR_TO
80104: IFFALSE 80248
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
80106: NOP4
80110: PUSH
80111: NOP4
80115: PUSH
80116: NOP4
80120: PUSH
80121: NOP4
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: PPUSH
80132: NOP4
80136: PUSH
80137: NOP4
80141: ARRAY
80142: PUSH
80143: NOP4
80147: ARRAY
80148: PPUSH
80149: NOP4
80153: IFFALSE 80246
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
80155: NOP4
80159: PUSH
80160: NOP4
80164: PPUSH
80165: NOP4
80169: PPUSH
80170: NOP4
80174: PUSH
80175: NOP4
80179: ARRAY
80180: PPUSH
80181: NOP4
80185: PPUSH
80186: NOP4
80190: PPUSH
80191: NOP4
80195: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80196: NOP4
80200: PUSH
80201: NOP4
80205: PPUSH
80206: NOP4
80210: PUSH
80211: NOP4
80215: PUSH
80216: NOP4
80220: ARRAY
80221: PUSH
80222: LD_INT 1
80224: PLUS
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PPUSH
80230: NOP4
80234: PPUSH
80235: NOP4
80239: ST_TO_ADDR
// exit ;
80240: POP
80241: POP
80242: POP
80243: POP
80244: GO 80254
// end ;
80246: GO 80103
80248: POP
80249: POP
// end ;
80250: GO 80064
80252: POP
80253: POP
// end ;
80254: LD_VAR 0 3
80258: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80259: LD_INT 0
80261: PPUSH
80262: PPUSH
80263: PPUSH
// if not mc_bases or not skirmish then
80264: NOP4
80268: NOT
80269: PUSH
80270: NOP4
80274: NOT
80275: OR
80276: IFFALSE 80280
// exit ;
80278: GO 80470
// for i = 1 to mc_bases do
80280: NOP4
80284: PUSH
80285: DOUBLE
80286: LD_INT 1
80288: DEC
80289: ST_TO_ADDR
80290: NOP4
80294: PUSH
80295: FOR_TO
80296: IFFALSE 80383
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80298: NOP4
80302: PUSH
80303: NOP4
80307: PUSH
80308: NOP4
80312: ARRAY
80313: IN
80314: PUSH
80315: NOP4
80319: PUSH
80320: NOP4
80324: PUSH
80325: NOP4
80329: ARRAY
80330: IN
80331: NOT
80332: AND
80333: IFFALSE 80381
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80335: NOP4
80339: PUSH
80340: NOP4
80344: PPUSH
80345: NOP4
80349: PUSH
80350: NOP4
80354: PUSH
80355: NOP4
80359: ARRAY
80360: PUSH
80361: LD_INT 1
80363: PLUS
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PPUSH
80369: NOP4
80373: PPUSH
80374: NOP4
80378: ST_TO_ADDR
// break ;
80379: GO 80383
// end ; end ;
80381: GO 80295
80383: POP
80384: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80385: NOP4
80389: PPUSH
80390: NOP4
80394: PUSH
80395: NOP4
80399: IN
80400: PUSH
80401: NOP4
80405: PPUSH
80406: NOP4
80410: PUSH
80411: LD_INT 5
80413: EQUAL
80414: AND
80415: PUSH
80416: NOP4
80420: PPUSH
80421: NOP4
80425: PUSH
80426: LD_INT 18
80428: NONEQUAL
80429: AND
80430: IFFALSE 80470
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80432: NOP4
80436: PPUSH
80437: NOP4
80441: PUSH
80442: LD_INT 5
80444: PUSH
80445: LD_INT 8
80447: PUSH
80448: LD_INT 9
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: LIST
80455: IN
80456: IFFALSE 80470
// SetClass ( unit , 1 ) ;
80458: NOP4
80462: PPUSH
80463: LD_INT 1
80465: PPUSH
80466: NOP4
// end ;
80470: LD_VAR 0 3
80474: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80475: LD_INT 0
80477: PPUSH
80478: PPUSH
// if not mc_bases or not skirmish then
80479: NOP4
80483: NOT
80484: PUSH
80485: NOP4
80489: NOT
80490: OR
80491: IFFALSE 80495
// exit ;
80493: GO 80611
// if GetLives ( abandoned_vehicle ) > 250 then
80495: NOP4
80499: PPUSH
80500: NOP4
80504: PUSH
80505: LD_INT 250
80507: GREATER
80508: IFFALSE 80512
// exit ;
80510: GO 80611
// for i = 1 to mc_bases do
80512: NOP4
80516: PUSH
80517: DOUBLE
80518: LD_INT 1
80520: DEC
80521: ST_TO_ADDR
80522: NOP4
80526: PUSH
80527: FOR_TO
80528: IFFALSE 80609
// begin if driver in mc_bases [ i ] then
80530: NOP4
80534: PUSH
80535: NOP4
80539: PUSH
80540: NOP4
80544: ARRAY
80545: IN
80546: IFFALSE 80607
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80548: NOP4
80552: PPUSH
80553: NOP4
80557: PUSH
80558: NOP4
80562: ARRAY
80563: PPUSH
80564: LD_INT 2
80566: PUSH
80567: LD_INT 30
80569: PUSH
80570: LD_INT 0
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PUSH
80577: LD_INT 30
80579: PUSH
80580: LD_INT 1
80582: PUSH
80583: EMPTY
80584: LIST
80585: LIST
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: LIST
80591: PPUSH
80592: NOP4
80596: PUSH
80597: LD_INT 1
80599: ARRAY
80600: PPUSH
80601: NOP4
// break ;
80605: GO 80609
// end ; end ;
80607: GO 80527
80609: POP
80610: POP
// end ; end_of_file
80611: LD_VAR 0 5
80615: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
80616: LD_INT 0
80618: PPUSH
// ar_miner := 81 ;
80619: NOP4
80623: PUSH
80624: LD_INT 81
80626: ST_TO_ADDR
// ar_crane := 88 ;
80627: NOP4
80631: PUSH
80632: LD_INT 88
80634: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80635: NOP4
80639: PUSH
80640: LD_INT 89
80642: ST_TO_ADDR
// us_hack := 99 ;
80643: NOP4
80647: PUSH
80648: LD_INT 99
80650: ST_TO_ADDR
// us_artillery := 97 ;
80651: NOP4
80655: PUSH
80656: LD_INT 97
80658: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80659: NOP4
80663: PUSH
80664: LD_INT 91
80666: ST_TO_ADDR
// ar_mortar := 92 ;
80667: NOP4
80671: PUSH
80672: LD_INT 92
80674: ST_TO_ADDR
// ru_flamethrower := 93 ;
80675: NOP4
80679: PUSH
80680: LD_INT 93
80682: ST_TO_ADDR
// ru_radar := 98 ;
80683: NOP4
80687: PUSH
80688: LD_INT 98
80690: ST_TO_ADDR
// tech_Artillery := 80 ;
80691: NOP4
80695: PUSH
80696: LD_INT 80
80698: ST_TO_ADDR
// tech_RadMat := 81 ;
80699: NOP4
80703: PUSH
80704: LD_INT 81
80706: ST_TO_ADDR
// tech_BasicTools := 82 ;
80707: NOP4
80711: PUSH
80712: LD_INT 82
80714: ST_TO_ADDR
// tech_Cargo := 83 ;
80715: NOP4
80719: PUSH
80720: LD_INT 83
80722: ST_TO_ADDR
// tech_Track := 84 ;
80723: NOP4
80727: PUSH
80728: LD_INT 84
80730: ST_TO_ADDR
// tech_Crane := 85 ;
80731: NOP4
80735: PUSH
80736: LD_INT 85
80738: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80739: NOP4
80743: PUSH
80744: LD_INT 86
80746: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80747: NOP4
80751: PUSH
80752: LD_INT 87
80754: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
80755: NOP4
80759: PUSH
80760: LD_INT 88
80762: ST_TO_ADDR
// class_mastodont := 31 ;
80763: NOP4
80767: PUSH
80768: LD_INT 31
80770: ST_TO_ADDR
// class_horse := 21 ;
80771: NOP4
80775: PUSH
80776: LD_INT 21
80778: ST_TO_ADDR
// end ;
80779: LD_VAR 0 1
80783: RET
// every 1 do
80784: GO 80786
80786: DISABLE
// InitGlobalVariables ; end_of_file
80787: NOP4
80791: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
80792: LD_INT 0
80794: PPUSH
80795: PPUSH
80796: PPUSH
80797: PPUSH
80798: PPUSH
80799: PPUSH
80800: PPUSH
80801: PPUSH
80802: PPUSH
80803: PPUSH
80804: PPUSH
80805: PPUSH
80806: PPUSH
80807: PPUSH
80808: PPUSH
80809: PPUSH
80810: PPUSH
80811: PPUSH
80812: PPUSH
80813: PPUSH
80814: PPUSH
80815: PPUSH
80816: PPUSH
80817: PPUSH
80818: PPUSH
80819: PPUSH
80820: PPUSH
80821: PPUSH
80822: PPUSH
80823: PPUSH
80824: PPUSH
80825: PPUSH
80826: PPUSH
80827: PPUSH
// if not list then
80828: NOP4
80832: NOT
80833: IFFALSE 80837
// exit ;
80835: GO 85496
// base := list [ 1 ] ;
80837: NOP4
80841: PUSH
80842: NOP4
80846: PUSH
80847: LD_INT 1
80849: ARRAY
80850: ST_TO_ADDR
// group := list [ 2 ] ;
80851: NOP4
80855: PUSH
80856: NOP4
80860: PUSH
80861: LD_INT 2
80863: ARRAY
80864: ST_TO_ADDR
// path := list [ 3 ] ;
80865: NOP4
80869: PUSH
80870: NOP4
80874: PUSH
80875: LD_INT 3
80877: ARRAY
80878: ST_TO_ADDR
// flags := list [ 4 ] ;
80879: NOP4
80883: PUSH
80884: NOP4
80888: PUSH
80889: LD_INT 4
80891: ARRAY
80892: ST_TO_ADDR
// mined := [ ] ;
80893: NOP4
80897: PUSH
80898: EMPTY
80899: ST_TO_ADDR
// bombed := [ ] ;
80900: NOP4
80904: PUSH
80905: EMPTY
80906: ST_TO_ADDR
// healers := [ ] ;
80907: NOP4
80911: PUSH
80912: EMPTY
80913: ST_TO_ADDR
// to_heal := [ ] ;
80914: NOP4
80918: PUSH
80919: EMPTY
80920: ST_TO_ADDR
// repairs := [ ] ;
80921: NOP4
80925: PUSH
80926: EMPTY
80927: ST_TO_ADDR
// to_repair := [ ] ;
80928: NOP4
80932: PUSH
80933: EMPTY
80934: ST_TO_ADDR
// if not group or not path then
80935: NOP4
80939: NOT
80940: PUSH
80941: NOP4
80945: NOT
80946: OR
80947: IFFALSE 80951
// exit ;
80949: GO 85496
// side := GetSide ( group [ 1 ] ) ;
80951: NOP4
80955: PUSH
80956: NOP4
80960: PUSH
80961: LD_INT 1
80963: ARRAY
80964: PPUSH
80965: NOP4
80969: ST_TO_ADDR
// if flags then
80970: NOP4
80974: IFFALSE 81118
// begin f_ignore_area := flags [ 1 ] ;
80976: NOP4
80980: PUSH
80981: NOP4
80985: PUSH
80986: LD_INT 1
80988: ARRAY
80989: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
80990: NOP4
80994: PUSH
80995: NOP4
80999: PUSH
81000: LD_INT 2
81002: ARRAY
81003: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
81004: NOP4
81008: PUSH
81009: NOP4
81013: PUSH
81014: LD_INT 3
81016: ARRAY
81017: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
81018: NOP4
81022: PUSH
81023: NOP4
81027: PUSH
81028: LD_INT 4
81030: ARRAY
81031: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
81032: NOP4
81036: PUSH
81037: NOP4
81041: PUSH
81042: LD_INT 5
81044: ARRAY
81045: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
81046: NOP4
81050: PUSH
81051: NOP4
81055: PUSH
81056: LD_INT 6
81058: ARRAY
81059: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
81060: NOP4
81064: PUSH
81065: NOP4
81069: PUSH
81070: LD_INT 7
81072: ARRAY
81073: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
81074: NOP4
81078: PUSH
81079: NOP4
81083: PUSH
81084: LD_INT 8
81086: ARRAY
81087: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
81088: NOP4
81092: PUSH
81093: NOP4
81097: PUSH
81098: LD_INT 9
81100: ARRAY
81101: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
81102: NOP4
81106: PUSH
81107: NOP4
81111: PUSH
81112: LD_INT 10
81114: ARRAY
81115: ST_TO_ADDR
// end else
81116: GO 81198
// begin f_ignore_area := false ;
81118: NOP4
81122: PUSH
81123: LD_INT 0
81125: ST_TO_ADDR
// f_capture := false ;
81126: NOP4
81130: PUSH
81131: LD_INT 0
81133: ST_TO_ADDR
// f_ignore_civ := false ;
81134: NOP4
81138: PUSH
81139: LD_INT 0
81141: ST_TO_ADDR
// f_murder := false ;
81142: NOP4
81146: PUSH
81147: LD_INT 0
81149: ST_TO_ADDR
// f_mines := false ;
81150: NOP4
81154: PUSH
81155: LD_INT 0
81157: ST_TO_ADDR
// f_repair := false ;
81158: NOP4
81162: PUSH
81163: LD_INT 0
81165: ST_TO_ADDR
// f_heal := false ;
81166: NOP4
81170: PUSH
81171: LD_INT 0
81173: ST_TO_ADDR
// f_spacetime := false ;
81174: NOP4
81178: PUSH
81179: LD_INT 0
81181: ST_TO_ADDR
// f_attack_depot := false ;
81182: NOP4
81186: PUSH
81187: LD_INT 0
81189: ST_TO_ADDR
// f_crawl := false ;
81190: NOP4
81194: PUSH
81195: LD_INT 0
81197: ST_TO_ADDR
// end ; if f_heal then
81198: NOP4
81202: IFFALSE 81229
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
81204: NOP4
81208: PUSH
81209: NOP4
81213: PPUSH
81214: LD_INT 25
81216: PUSH
81217: LD_INT 4
81219: PUSH
81220: EMPTY
81221: LIST
81222: LIST
81223: PPUSH
81224: NOP4
81228: ST_TO_ADDR
// if f_repair then
81229: NOP4
81233: IFFALSE 81260
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
81235: NOP4
81239: PUSH
81240: NOP4
81244: PPUSH
81245: LD_INT 25
81247: PUSH
81248: LD_INT 3
81250: PUSH
81251: EMPTY
81252: LIST
81253: LIST
81254: PPUSH
81255: NOP4
81259: ST_TO_ADDR
// units_path := [ ] ;
81260: NOP4
81264: PUSH
81265: EMPTY
81266: ST_TO_ADDR
// for i = 1 to group do
81267: NOP4
81271: PUSH
81272: DOUBLE
81273: LD_INT 1
81275: DEC
81276: ST_TO_ADDR
81277: NOP4
81281: PUSH
81282: FOR_TO
81283: IFFALSE 81312
// units_path := Replace ( units_path , i , path ) ;
81285: NOP4
81289: PUSH
81290: NOP4
81294: PPUSH
81295: NOP4
81299: PPUSH
81300: NOP4
81304: PPUSH
81305: NOP4
81309: ST_TO_ADDR
81310: GO 81282
81312: POP
81313: POP
// repeat for i = group downto 1 do
81314: NOP4
81318: PUSH
81319: DOUBLE
81320: NOP4
81324: INC
81325: ST_TO_ADDR
81326: LD_INT 1
81328: PUSH
81329: FOR_DOWNTO
81330: IFFALSE 85452
// begin wait ( 5 ) ;
81332: LD_INT 5
81334: PPUSH
81335: NOP4
// tmp := [ ] ;
81339: NOP4
81343: PUSH
81344: EMPTY
81345: ST_TO_ADDR
// attacking := false ;
81346: NOP4
81350: PUSH
81351: LD_INT 0
81353: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
81354: NOP4
81358: PUSH
81359: NOP4
81363: ARRAY
81364: PPUSH
81365: NOP4
81369: PUSH
81370: NOP4
81374: PUSH
81375: NOP4
81379: ARRAY
81380: NOT
81381: OR
81382: IFFALSE 81491
// begin if GetType ( group [ i ] ) = unit_human then
81384: NOP4
81388: PUSH
81389: NOP4
81393: ARRAY
81394: PPUSH
81395: NOP4
81399: PUSH
81400: LD_INT 1
81402: EQUAL
81403: IFFALSE 81449
// begin to_heal := to_heal diff group [ i ] ;
81405: NOP4
81409: PUSH
81410: NOP4
81414: PUSH
81415: NOP4
81419: PUSH
81420: NOP4
81424: ARRAY
81425: DIFF
81426: ST_TO_ADDR
// healers := healers diff group [ i ] ;
81427: NOP4
81431: PUSH
81432: NOP4
81436: PUSH
81437: NOP4
81441: PUSH
81442: NOP4
81446: ARRAY
81447: DIFF
81448: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
81449: NOP4
81453: PUSH
81454: NOP4
81458: PPUSH
81459: NOP4
81463: PPUSH
81464: NOP4
81468: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
81469: NOP4
81473: PUSH
81474: NOP4
81478: PPUSH
81479: NOP4
81483: PPUSH
81484: NOP4
81488: ST_TO_ADDR
// continue ;
81489: GO 81329
// end ; if f_repair then
81491: NOP4
81495: IFFALSE 81984
// begin if GetType ( group [ i ] ) = unit_vehicle then
81497: NOP4
81501: PUSH
81502: NOP4
81506: ARRAY
81507: PPUSH
81508: NOP4
81512: PUSH
81513: LD_INT 2
81515: EQUAL
81516: IFFALSE 81706
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
81518: NOP4
81522: PUSH
81523: NOP4
81527: ARRAY
81528: PPUSH
81529: NOP4
81533: PUSH
81534: LD_INT 700
81536: LESS
81537: PUSH
81538: NOP4
81542: PUSH
81543: NOP4
81547: ARRAY
81548: PUSH
81549: NOP4
81553: IN
81554: NOT
81555: AND
81556: IFFALSE 81580
// to_repair := to_repair union group [ i ] ;
81558: NOP4
81562: PUSH
81563: NOP4
81567: PUSH
81568: NOP4
81572: PUSH
81573: NOP4
81577: ARRAY
81578: UNION
81579: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
81580: NOP4
81584: PUSH
81585: NOP4
81589: ARRAY
81590: PPUSH
81591: NOP4
81595: PUSH
81596: LD_INT 1000
81598: EQUAL
81599: PUSH
81600: NOP4
81604: PUSH
81605: NOP4
81609: ARRAY
81610: PUSH
81611: NOP4
81615: IN
81616: AND
81617: IFFALSE 81641
// to_repair := to_repair diff group [ i ] ;
81619: NOP4
81623: PUSH
81624: NOP4
81628: PUSH
81629: NOP4
81633: PUSH
81634: NOP4
81638: ARRAY
81639: DIFF
81640: ST_TO_ADDR
// if group [ i ] in to_repair then
81641: NOP4
81645: PUSH
81646: NOP4
81650: ARRAY
81651: PUSH
81652: NOP4
81656: IN
81657: IFFALSE 81704
// begin if not IsInArea ( group [ i ] , f_repair ) then
81659: NOP4
81663: PUSH
81664: NOP4
81668: ARRAY
81669: PPUSH
81670: NOP4
81674: PPUSH
81675: NOP4
81679: NOT
81680: IFFALSE 81702
// ComMoveToArea ( group [ i ] , f_repair ) ;
81682: NOP4
81686: PUSH
81687: NOP4
81691: ARRAY
81692: PPUSH
81693: NOP4
81697: PPUSH
81698: NOP4
// continue ;
81702: GO 81329
// end ; end else
81704: GO 81984
// if group [ i ] in repairs then
81706: NOP4
81710: PUSH
81711: NOP4
81715: ARRAY
81716: PUSH
81717: NOP4
81721: IN
81722: IFFALSE 81984
// begin if IsInUnit ( group [ i ] ) then
81724: NOP4
81728: PUSH
81729: NOP4
81733: ARRAY
81734: PPUSH
81735: NOP4
81739: IFFALSE 81807
// begin z := IsInUnit ( group [ i ] ) ;
81741: NOP4
81745: PUSH
81746: NOP4
81750: PUSH
81751: NOP4
81755: ARRAY
81756: PPUSH
81757: NOP4
81761: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81762: NOP4
81766: PUSH
81767: NOP4
81771: IN
81772: PUSH
81773: NOP4
81777: PPUSH
81778: NOP4
81782: PPUSH
81783: NOP4
81787: AND
81788: IFFALSE 81805
// ComExitVehicle ( group [ i ] ) ;
81790: NOP4
81794: PUSH
81795: NOP4
81799: ARRAY
81800: PPUSH
81801: NOP4
// end else
81805: GO 81984
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81807: NOP4
81811: PUSH
81812: NOP4
81816: PPUSH
81817: LD_INT 95
81819: PUSH
81820: NOP4
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 58
81831: PUSH
81832: EMPTY
81833: LIST
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PPUSH
81839: NOP4
81843: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81844: NOP4
81848: PUSH
81849: NOP4
81853: ARRAY
81854: PPUSH
81855: NOP4
81859: NOT
81860: IFFALSE 81982
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81862: NOP4
81866: PUSH
81867: NOP4
81871: PPUSH
81872: NOP4
81876: PUSH
81877: NOP4
81881: ARRAY
81882: PPUSH
81883: NOP4
81887: ST_TO_ADDR
// if not x then
81888: NOP4
81892: NOT
81893: IFFALSE 81897
// continue ;
81895: GO 81329
// if GetLives ( x ) < 1000 then
81897: NOP4
81901: PPUSH
81902: NOP4
81906: PUSH
81907: LD_INT 1000
81909: LESS
81910: IFFALSE 81934
// ComRepairVehicle ( group [ i ] , x ) else
81912: NOP4
81916: PUSH
81917: NOP4
81921: ARRAY
81922: PPUSH
81923: NOP4
81927: PPUSH
81928: NOP4
81932: GO 81982
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
81934: NOP4
81938: PUSH
81939: NOP4
81943: PUSH
81944: NOP4
81948: ARRAY
81949: PPUSH
81950: NOP4
81954: PUSH
81955: LD_INT 1000
81957: LESS
81958: AND
81959: NOT
81960: IFFALSE 81982
// ComEnterUnit ( group [ i ] , x ) ;
81962: NOP4
81966: PUSH
81967: NOP4
81971: ARRAY
81972: PPUSH
81973: NOP4
81977: PPUSH
81978: NOP4
// end ; continue ;
81982: GO 81329
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
81984: NOP4
81988: PUSH
81989: NOP4
81993: PUSH
81994: NOP4
81998: ARRAY
81999: PPUSH
82000: NOP4
82004: PUSH
82005: LD_INT 1
82007: EQUAL
82008: AND
82009: IFFALSE 82487
// begin if group [ i ] in healers then
82011: NOP4
82015: PUSH
82016: NOP4
82020: ARRAY
82021: PUSH
82022: NOP4
82026: IN
82027: IFFALSE 82300
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
82029: NOP4
82033: PUSH
82034: NOP4
82038: ARRAY
82039: PPUSH
82040: NOP4
82044: PPUSH
82045: NOP4
82049: NOT
82050: PUSH
82051: NOP4
82055: PUSH
82056: NOP4
82060: ARRAY
82061: PPUSH
82062: NOP4
82066: NOT
82067: AND
82068: IFFALSE 82092
// ComMoveToArea ( group [ i ] , f_heal ) else
82070: NOP4
82074: PUSH
82075: NOP4
82079: ARRAY
82080: PPUSH
82081: NOP4
82085: PPUSH
82086: NOP4
82090: GO 82298
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
82092: NOP4
82096: PUSH
82097: NOP4
82101: ARRAY
82102: PPUSH
82103: NOP4
82107: PPUSH
82108: NOP4
82112: PUSH
82113: LD_INT 1000
82115: EQUAL
82116: IFFALSE 82135
// ComStop ( group [ i ] ) else
82118: NOP4
82122: PUSH
82123: NOP4
82127: ARRAY
82128: PPUSH
82129: NOP4
82133: GO 82298
// if not HasTask ( group [ i ] ) and to_heal then
82135: NOP4
82139: PUSH
82140: NOP4
82144: ARRAY
82145: PPUSH
82146: NOP4
82150: NOT
82151: PUSH
82152: NOP4
82156: AND
82157: IFFALSE 82298
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
82159: NOP4
82163: PUSH
82164: NOP4
82168: PPUSH
82169: LD_INT 3
82171: PUSH
82172: LD_INT 54
82174: PUSH
82175: EMPTY
82176: LIST
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PPUSH
82182: NOP4
82186: PPUSH
82187: NOP4
82191: PUSH
82192: NOP4
82196: ARRAY
82197: PPUSH
82198: NOP4
82202: ST_TO_ADDR
// if z then
82203: NOP4
82207: IFFALSE 82298
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
82209: LD_INT 91
82211: PUSH
82212: NOP4
82216: PUSH
82217: LD_INT 10
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: LIST
82224: PUSH
82225: LD_INT 81
82227: PUSH
82228: NOP4
82232: PPUSH
82233: NOP4
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PPUSH
82246: NOP4
82250: PUSH
82251: LD_INT 0
82253: EQUAL
82254: IFFALSE 82278
// ComHeal ( group [ i ] , z ) else
82256: NOP4
82260: PUSH
82261: NOP4
82265: ARRAY
82266: PPUSH
82267: NOP4
82271: PPUSH
82272: NOP4
82276: GO 82298
// ComMoveToArea ( group [ i ] , f_heal ) ;
82278: NOP4
82282: PUSH
82283: NOP4
82287: ARRAY
82288: PPUSH
82289: NOP4
82293: PPUSH
82294: NOP4
// end ; continue ;
82298: GO 81329
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
82300: NOP4
82304: PUSH
82305: NOP4
82309: ARRAY
82310: PPUSH
82311: NOP4
82315: PUSH
82316: LD_INT 700
82318: LESS
82319: PUSH
82320: NOP4
82324: PUSH
82325: NOP4
82329: ARRAY
82330: PUSH
82331: NOP4
82335: IN
82336: NOT
82337: AND
82338: IFFALSE 82362
// to_heal := to_heal union group [ i ] ;
82340: NOP4
82344: PUSH
82345: NOP4
82349: PUSH
82350: NOP4
82354: PUSH
82355: NOP4
82359: ARRAY
82360: UNION
82361: ST_TO_ADDR
// if group [ i ] in to_heal then
82362: NOP4
82366: PUSH
82367: NOP4
82371: ARRAY
82372: PUSH
82373: NOP4
82377: IN
82378: IFFALSE 82487
// begin if GetLives ( group [ i ] ) = 1000 then
82380: NOP4
82384: PUSH
82385: NOP4
82389: ARRAY
82390: PPUSH
82391: NOP4
82395: PUSH
82396: LD_INT 1000
82398: EQUAL
82399: IFFALSE 82425
// to_heal := to_heal diff group [ i ] else
82401: NOP4
82405: PUSH
82406: NOP4
82410: PUSH
82411: NOP4
82415: PUSH
82416: NOP4
82420: ARRAY
82421: DIFF
82422: ST_TO_ADDR
82423: GO 82487
// begin if not IsInArea ( group [ i ] , to_heal ) then
82425: NOP4
82429: PUSH
82430: NOP4
82434: ARRAY
82435: PPUSH
82436: NOP4
82440: PPUSH
82441: NOP4
82445: NOT
82446: IFFALSE 82470
// ComMoveToArea ( group [ i ] , f_heal ) else
82448: NOP4
82452: PUSH
82453: NOP4
82457: ARRAY
82458: PPUSH
82459: NOP4
82463: PPUSH
82464: NOP4
82468: GO 82485
// ComHold ( group [ i ] ) ;
82470: NOP4
82474: PUSH
82475: NOP4
82479: ARRAY
82480: PPUSH
82481: NOP4
// continue ;
82485: GO 81329
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
82487: NOP4
82491: PUSH
82492: NOP4
82496: ARRAY
82497: PPUSH
82498: LD_INT 10
82500: PPUSH
82501: NOP4
82505: NOT
82506: PUSH
82507: NOP4
82511: PUSH
82512: NOP4
82516: ARRAY
82517: PUSH
82518: EMPTY
82519: EQUAL
82520: NOT
82521: AND
82522: IFFALSE 82788
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
82524: NOP4
82528: PUSH
82529: NOP4
82533: ARRAY
82534: PPUSH
82535: NOP4
82539: PUSH
82540: LD_INT 1
82542: PUSH
82543: LD_INT 2
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: IN
82550: IFFALSE 82591
// if GetFuel ( group [ i ] ) < 10 then
82552: NOP4
82556: PUSH
82557: NOP4
82561: ARRAY
82562: PPUSH
82563: NOP4
82567: PUSH
82568: LD_INT 10
82570: LESS
82571: IFFALSE 82591
// SetFuel ( group [ i ] , 12 ) ;
82573: NOP4
82577: PUSH
82578: NOP4
82582: ARRAY
82583: PPUSH
82584: LD_INT 12
82586: PPUSH
82587: NOP4
// if units_path [ i ] then
82591: NOP4
82595: PUSH
82596: NOP4
82600: ARRAY
82601: IFFALSE 82786
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82603: NOP4
82607: PUSH
82608: NOP4
82612: ARRAY
82613: PPUSH
82614: NOP4
82618: PUSH
82619: NOP4
82623: ARRAY
82624: PUSH
82625: LD_INT 1
82627: ARRAY
82628: PUSH
82629: LD_INT 1
82631: ARRAY
82632: PPUSH
82633: NOP4
82637: PUSH
82638: NOP4
82642: ARRAY
82643: PUSH
82644: LD_INT 1
82646: ARRAY
82647: PUSH
82648: LD_INT 2
82650: ARRAY
82651: PPUSH
82652: NOP4
82656: PUSH
82657: LD_INT 6
82659: GREATER
82660: IFFALSE 82735
// begin if not HasTask ( group [ i ] ) then
82662: NOP4
82666: PUSH
82667: NOP4
82671: ARRAY
82672: PPUSH
82673: NOP4
82677: NOT
82678: IFFALSE 82733
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82680: NOP4
82684: PUSH
82685: NOP4
82689: ARRAY
82690: PPUSH
82691: NOP4
82695: PUSH
82696: NOP4
82700: ARRAY
82701: PUSH
82702: LD_INT 1
82704: ARRAY
82705: PUSH
82706: LD_INT 1
82708: ARRAY
82709: PPUSH
82710: NOP4
82714: PUSH
82715: NOP4
82719: ARRAY
82720: PUSH
82721: LD_INT 1
82723: ARRAY
82724: PUSH
82725: LD_INT 2
82727: ARRAY
82728: PPUSH
82729: NOP4
// end else
82733: GO 82786
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82735: NOP4
82739: PUSH
82740: NOP4
82744: PUSH
82745: NOP4
82749: ARRAY
82750: PPUSH
82751: LD_INT 1
82753: PPUSH
82754: NOP4
82758: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82759: NOP4
82763: PUSH
82764: NOP4
82768: PPUSH
82769: NOP4
82773: PPUSH
82774: NOP4
82778: PPUSH
82779: NOP4
82783: ST_TO_ADDR
// continue ;
82784: GO 81329
// end ; end ; end else
82786: GO 85450
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82788: NOP4
82792: PUSH
82793: LD_INT 81
82795: PUSH
82796: NOP4
82800: PUSH
82801: NOP4
82805: ARRAY
82806: PPUSH
82807: NOP4
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PPUSH
82816: NOP4
82820: ST_TO_ADDR
// if not tmp then
82821: NOP4
82825: NOT
82826: IFFALSE 82830
// continue ;
82828: GO 81329
// if f_ignore_area then
82830: NOP4
82834: IFFALSE 82922
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82836: NOP4
82840: PUSH
82841: NOP4
82845: PPUSH
82846: LD_INT 3
82848: PUSH
82849: LD_INT 92
82851: PUSH
82852: NOP4
82856: PUSH
82857: LD_INT 1
82859: ARRAY
82860: PUSH
82861: NOP4
82865: PUSH
82866: LD_INT 2
82868: ARRAY
82869: PUSH
82870: NOP4
82874: PUSH
82875: LD_INT 3
82877: ARRAY
82878: PUSH
82879: EMPTY
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PPUSH
82889: NOP4
82893: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82894: NOP4
82898: PUSH
82899: NOP4
82903: DIFF
82904: IFFALSE 82922
// tmp := tmp diff tmp2 ;
82906: NOP4
82910: PUSH
82911: NOP4
82915: PUSH
82916: NOP4
82920: DIFF
82921: ST_TO_ADDR
// end ; if not f_murder then
82922: NOP4
82926: NOT
82927: IFFALSE 82985
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
82929: NOP4
82933: PUSH
82934: NOP4
82938: PPUSH
82939: LD_INT 3
82941: PUSH
82942: LD_INT 50
82944: PUSH
82945: EMPTY
82946: LIST
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PPUSH
82952: NOP4
82956: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82957: NOP4
82961: PUSH
82962: NOP4
82966: DIFF
82967: IFFALSE 82985
// tmp := tmp diff tmp2 ;
82969: NOP4
82973: PUSH
82974: NOP4
82978: PUSH
82979: NOP4
82983: DIFF
82984: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
82985: NOP4
82989: PUSH
82990: NOP4
82994: PUSH
82995: NOP4
82999: ARRAY
83000: PPUSH
83001: NOP4
83005: PPUSH
83006: LD_INT 1
83008: PPUSH
83009: LD_INT 1
83011: PPUSH
83012: NOP4
83016: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
83017: NOP4
83021: PUSH
83022: NOP4
83026: ARRAY
83027: PPUSH
83028: NOP4
83032: PUSH
83033: LD_INT 1
83035: EQUAL
83036: IFFALSE 83484
// begin if WantPlant ( group [ i ] ) then
83038: NOP4
83042: PUSH
83043: NOP4
83047: ARRAY
83048: PPUSH
83049: NOP4
83053: IFFALSE 83057
// continue ;
83055: GO 81329
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
83057: NOP4
83061: PUSH
83062: NOP4
83066: PUSH
83067: NOP4
83071: ARRAY
83072: PPUSH
83073: NOP4
83077: NOT
83078: AND
83079: PUSH
83080: NOP4
83084: PUSH
83085: LD_INT 1
83087: ARRAY
83088: PUSH
83089: NOP4
83093: PPUSH
83094: LD_INT 21
83096: PUSH
83097: LD_INT 2
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: LD_INT 58
83106: PUSH
83107: EMPTY
83108: LIST
83109: PUSH
83110: EMPTY
83111: LIST
83112: LIST
83113: PPUSH
83114: NOP4
83118: IN
83119: AND
83120: IFFALSE 83156
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
83122: NOP4
83126: PUSH
83127: NOP4
83131: ARRAY
83132: PPUSH
83133: NOP4
83137: PUSH
83138: LD_INT 1
83140: ARRAY
83141: PPUSH
83142: NOP4
// attacking := true ;
83146: NOP4
83150: PUSH
83151: LD_INT 1
83153: ST_TO_ADDR
// continue ;
83154: GO 81329
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
83156: NOP4
83160: PUSH
83161: NOP4
83165: PUSH
83166: NOP4
83170: ARRAY
83171: PPUSH
83172: NOP4
83176: PUSH
83177: LD_INT 1
83179: EQUAL
83180: AND
83181: PUSH
83182: NOP4
83186: PUSH
83187: NOP4
83191: ARRAY
83192: PPUSH
83193: NOP4
83197: PUSH
83198: LD_INT 800
83200: LESS
83201: AND
83202: PUSH
83203: NOP4
83207: PUSH
83208: NOP4
83212: ARRAY
83213: PPUSH
83214: NOP4
83218: NOT
83219: AND
83220: IFFALSE 83237
// ComCrawl ( group [ i ] ) ;
83222: NOP4
83226: PUSH
83227: NOP4
83231: ARRAY
83232: PPUSH
83233: NOP4
// if f_mines then
83237: NOP4
83241: IFFALSE 83484
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
83243: NOP4
83247: PUSH
83248: LD_INT 1
83250: ARRAY
83251: PPUSH
83252: NOP4
83256: PUSH
83257: LD_INT 3
83259: EQUAL
83260: PUSH
83261: NOP4
83265: PUSH
83266: LD_INT 1
83268: ARRAY
83269: PUSH
83270: NOP4
83274: IN
83275: NOT
83276: AND
83277: IFFALSE 83484
// begin x := GetX ( tmp [ 1 ] ) ;
83279: NOP4
83283: PUSH
83284: NOP4
83288: PUSH
83289: LD_INT 1
83291: ARRAY
83292: PPUSH
83293: NOP4
83297: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
83298: NOP4
83302: PUSH
83303: NOP4
83307: PUSH
83308: LD_INT 1
83310: ARRAY
83311: PPUSH
83312: NOP4
83316: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
83317: NOP4
83321: PUSH
83322: NOP4
83326: PUSH
83327: NOP4
83331: ARRAY
83332: PPUSH
83333: NOP4
83337: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
83338: NOP4
83342: PUSH
83343: NOP4
83347: ARRAY
83348: PPUSH
83349: NOP4
83353: PPUSH
83354: NOP4
83358: PPUSH
83359: NOP4
83363: PUSH
83364: LD_INT 1
83366: ARRAY
83367: PPUSH
83368: NOP4
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
83372: NOP4
83376: PUSH
83377: NOP4
83381: ARRAY
83382: PPUSH
83383: NOP4
83387: PPUSH
83388: NOP4
83392: PPUSH
83393: LD_INT 7
83395: PPUSH
83396: NOP4
83400: PPUSH
83401: NOP4
83405: PPUSH
83406: NOP4
83410: PPUSH
83411: LD_INT 7
83413: PPUSH
83414: NOP4
83418: PPUSH
83419: NOP4
// SetTag ( group [ i ] , 71 ) ;
83423: NOP4
83427: PUSH
83428: NOP4
83432: ARRAY
83433: PPUSH
83434: LD_INT 71
83436: PPUSH
83437: NOP4
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
83441: NOP4
83445: PUSH
83446: NOP4
83450: PPUSH
83451: NOP4
83455: PUSH
83456: LD_INT 1
83458: PLUS
83459: PPUSH
83460: NOP4
83464: PUSH
83465: LD_INT 1
83467: ARRAY
83468: PPUSH
83469: NOP4
83473: ST_TO_ADDR
// attacking := true ;
83474: NOP4
83478: PUSH
83479: LD_INT 1
83481: ST_TO_ADDR
// continue ;
83482: GO 81329
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
83484: NOP4
83488: PUSH
83489: NOP4
83493: ARRAY
83494: PPUSH
83495: NOP4
83499: PUSH
83500: LD_INT 17
83502: EQUAL
83503: PUSH
83504: NOP4
83508: PUSH
83509: NOP4
83513: ARRAY
83514: PPUSH
83515: NOP4
83519: PUSH
83520: LD_INT 71
83522: EQUAL
83523: NOT
83524: AND
83525: IFFALSE 83671
// begin attacking := false ;
83527: NOP4
83531: PUSH
83532: LD_INT 0
83534: ST_TO_ADDR
// k := 5 ;
83535: NOP4
83539: PUSH
83540: LD_INT 5
83542: ST_TO_ADDR
// if tmp < k then
83543: NOP4
83547: PUSH
83548: NOP4
83552: LESS
83553: IFFALSE 83565
// k := tmp ;
83555: NOP4
83559: PUSH
83560: NOP4
83564: ST_TO_ADDR
// for j = 1 to k do
83565: NOP4
83569: PUSH
83570: DOUBLE
83571: LD_INT 1
83573: DEC
83574: ST_TO_ADDR
83575: NOP4
83579: PUSH
83580: FOR_TO
83581: IFFALSE 83669
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
83583: NOP4
83587: PUSH
83588: NOP4
83592: ARRAY
83593: PUSH
83594: NOP4
83598: PPUSH
83599: LD_INT 58
83601: PUSH
83602: EMPTY
83603: LIST
83604: PPUSH
83605: NOP4
83609: IN
83610: NOT
83611: IFFALSE 83667
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83613: NOP4
83617: PUSH
83618: NOP4
83622: ARRAY
83623: PPUSH
83624: NOP4
83628: PUSH
83629: NOP4
83633: ARRAY
83634: PPUSH
83635: NOP4
// attacking := true ;
83639: NOP4
83643: PUSH
83644: LD_INT 1
83646: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83647: NOP4
83651: PUSH
83652: NOP4
83656: ARRAY
83657: PPUSH
83658: LD_INT 71
83660: PPUSH
83661: NOP4
// continue ;
83665: GO 83580
// end ; end ;
83667: GO 83580
83669: POP
83670: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83671: NOP4
83675: PUSH
83676: NOP4
83680: ARRAY
83681: PPUSH
83682: NOP4
83686: PUSH
83687: LD_INT 8
83689: EQUAL
83690: PUSH
83691: NOP4
83695: PUSH
83696: NOP4
83700: ARRAY
83701: PPUSH
83702: NOP4
83706: PUSH
83707: LD_INT 28
83709: PUSH
83710: LD_INT 45
83712: PUSH
83713: LD_INT 7
83715: PUSH
83716: LD_INT 47
83718: PUSH
83719: EMPTY
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: IN
83725: OR
83726: IFFALSE 83982
// begin attacking := false ;
83728: NOP4
83732: PUSH
83733: LD_INT 0
83735: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83736: NOP4
83740: PUSH
83741: LD_INT 1
83743: ARRAY
83744: PPUSH
83745: NOP4
83749: PUSH
83750: LD_INT 32
83752: PUSH
83753: LD_INT 31
83755: PUSH
83756: LD_INT 33
83758: PUSH
83759: LD_INT 4
83761: PUSH
83762: LD_INT 5
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: LIST
83769: LIST
83770: LIST
83771: IN
83772: IFFALSE 83958
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83774: NOP4
83778: PUSH
83779: NOP4
83783: PUSH
83784: LD_INT 1
83786: ARRAY
83787: PPUSH
83788: NOP4
83792: PPUSH
83793: NOP4
83797: PUSH
83798: LD_INT 1
83800: ARRAY
83801: PPUSH
83802: NOP4
83806: PPUSH
83807: NOP4
83811: PUSH
83812: LD_INT 1
83814: ARRAY
83815: PPUSH
83816: NOP4
83820: PPUSH
83821: NOP4
83825: PUSH
83826: LD_INT 1
83828: ARRAY
83829: PPUSH
83830: NOP4
83834: PPUSH
83835: NOP4
83839: PUSH
83840: LD_INT 1
83842: ARRAY
83843: PPUSH
83844: NOP4
83848: PPUSH
83849: LD_INT 0
83851: PPUSH
83852: NOP4
83856: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83857: NOP4
83861: PUSH
83862: NOP4
83866: PUSH
83867: NOP4
83871: ARRAY
83872: PPUSH
83873: NOP4
83877: PPUSH
83878: NOP4
83882: ST_TO_ADDR
// if j then
83883: NOP4
83887: IFFALSE 83956
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83889: NOP4
83893: PUSH
83894: LD_INT 1
83896: ARRAY
83897: PPUSH
83898: NOP4
83902: PUSH
83903: LD_INT 2
83905: ARRAY
83906: PPUSH
83907: NOP4
83911: IFFALSE 83956
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
83913: NOP4
83917: PUSH
83918: NOP4
83922: ARRAY
83923: PPUSH
83924: NOP4
83928: PUSH
83929: LD_INT 1
83931: ARRAY
83932: PPUSH
83933: NOP4
83937: PUSH
83938: LD_INT 2
83940: ARRAY
83941: PPUSH
83942: NOP4
// attacking := true ;
83946: NOP4
83950: PUSH
83951: LD_INT 1
83953: ST_TO_ADDR
// continue ;
83954: GO 81329
// end ; end else
83956: GO 83982
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83958: NOP4
83962: PUSH
83963: NOP4
83967: ARRAY
83968: PPUSH
83969: NOP4
83973: PUSH
83974: LD_INT 1
83976: ARRAY
83977: PPUSH
83978: NOP4
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
83982: NOP4
83986: PUSH
83987: NOP4
83991: ARRAY
83992: PPUSH
83993: NOP4
83997: PUSH
83998: LD_INT 11
84000: EQUAL
84001: IFFALSE 84279
// begin k := 10 ;
84003: NOP4
84007: PUSH
84008: LD_INT 10
84010: ST_TO_ADDR
// x := 0 ;
84011: NOP4
84015: PUSH
84016: LD_INT 0
84018: ST_TO_ADDR
// if tmp < k then
84019: NOP4
84023: PUSH
84024: NOP4
84028: LESS
84029: IFFALSE 84041
// k := tmp ;
84031: NOP4
84035: PUSH
84036: NOP4
84040: ST_TO_ADDR
// for j = k downto 1 do
84041: NOP4
84045: PUSH
84046: DOUBLE
84047: NOP4
84051: INC
84052: ST_TO_ADDR
84053: LD_INT 1
84055: PUSH
84056: FOR_DOWNTO
84057: IFFALSE 84132
// begin if GetType ( tmp [ j ] ) = unit_human then
84059: NOP4
84063: PUSH
84064: NOP4
84068: ARRAY
84069: PPUSH
84070: NOP4
84074: PUSH
84075: LD_INT 1
84077: EQUAL
84078: IFFALSE 84130
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
84080: NOP4
84084: PUSH
84085: NOP4
84089: ARRAY
84090: PPUSH
84091: NOP4
84095: PUSH
84096: NOP4
84100: ARRAY
84101: PPUSH
84102: NOP4
// x := tmp [ j ] ;
84106: NOP4
84110: PUSH
84111: NOP4
84115: PUSH
84116: NOP4
84120: ARRAY
84121: ST_TO_ADDR
// attacking := true ;
84122: NOP4
84126: PUSH
84127: LD_INT 1
84129: ST_TO_ADDR
// end ; end ;
84130: GO 84056
84132: POP
84133: POP
// if not x then
84134: NOP4
84138: NOT
84139: IFFALSE 84279
// begin attacking := true ;
84141: NOP4
84145: PUSH
84146: LD_INT 1
84148: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
84149: NOP4
84153: PUSH
84154: NOP4
84158: ARRAY
84159: PPUSH
84160: NOP4
84164: PPUSH
84165: NOP4
84169: PUSH
84170: NOP4
84174: ARRAY
84175: PPUSH
84176: NOP4
84180: PPUSH
84181: NOP4
84185: PUSH
84186: LD_INT 2
84188: ARRAY
84189: PUSH
84190: NOP4
84194: PUSH
84195: LD_INT 1
84197: ARRAY
84198: PPUSH
84199: NOP4
84203: PPUSH
84204: NOP4
84208: PUSH
84209: LD_INT 1
84211: ARRAY
84212: PPUSH
84213: NOP4
84217: PPUSH
84218: NOP4
84222: PUSH
84223: LD_INT 2
84225: ARRAY
84226: EQUAL
84227: IFFALSE 84255
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
84229: NOP4
84233: PUSH
84234: NOP4
84238: ARRAY
84239: PPUSH
84240: NOP4
84244: PUSH
84245: LD_INT 1
84247: ARRAY
84248: PPUSH
84249: NOP4
84253: GO 84279
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84255: NOP4
84259: PUSH
84260: NOP4
84264: ARRAY
84265: PPUSH
84266: NOP4
84270: PUSH
84271: LD_INT 1
84273: ARRAY
84274: PPUSH
84275: NOP4
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
84279: NOP4
84283: PUSH
84284: NOP4
84288: ARRAY
84289: PPUSH
84290: NOP4
84294: PUSH
84295: LD_INT 29
84297: EQUAL
84298: IFFALSE 84664
// begin if WantsToAttack ( group [ i ] ) in bombed then
84300: NOP4
84304: PUSH
84305: NOP4
84309: ARRAY
84310: PPUSH
84311: NOP4
84315: PUSH
84316: NOP4
84320: IN
84321: IFFALSE 84325
// continue ;
84323: GO 81329
// k := 8 ;
84325: NOP4
84329: PUSH
84330: LD_INT 8
84332: ST_TO_ADDR
// x := 0 ;
84333: NOP4
84337: PUSH
84338: LD_INT 0
84340: ST_TO_ADDR
// if tmp < k then
84341: NOP4
84345: PUSH
84346: NOP4
84350: LESS
84351: IFFALSE 84363
// k := tmp ;
84353: NOP4
84357: PUSH
84358: NOP4
84362: ST_TO_ADDR
// for j = 1 to k do
84363: NOP4
84367: PUSH
84368: DOUBLE
84369: LD_INT 1
84371: DEC
84372: ST_TO_ADDR
84373: NOP4
84377: PUSH
84378: FOR_TO
84379: IFFALSE 84511
// begin if GetType ( tmp [ j ] ) = unit_building then
84381: NOP4
84385: PUSH
84386: NOP4
84390: ARRAY
84391: PPUSH
84392: NOP4
84396: PUSH
84397: LD_INT 3
84399: EQUAL
84400: IFFALSE 84509
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
84402: NOP4
84406: PUSH
84407: NOP4
84411: ARRAY
84412: PUSH
84413: NOP4
84417: IN
84418: NOT
84419: PUSH
84420: NOP4
84424: PUSH
84425: NOP4
84429: ARRAY
84430: PPUSH
84431: NOP4
84435: AND
84436: IFFALSE 84509
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84438: NOP4
84442: PUSH
84443: NOP4
84447: ARRAY
84448: PPUSH
84449: NOP4
84453: PUSH
84454: NOP4
84458: ARRAY
84459: PPUSH
84460: NOP4
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
84464: NOP4
84468: PUSH
84469: NOP4
84473: PPUSH
84474: NOP4
84478: PUSH
84479: LD_INT 1
84481: PLUS
84482: PPUSH
84483: NOP4
84487: PUSH
84488: NOP4
84492: ARRAY
84493: PPUSH
84494: NOP4
84498: ST_TO_ADDR
// attacking := true ;
84499: NOP4
84503: PUSH
84504: LD_INT 1
84506: ST_TO_ADDR
// break ;
84507: GO 84511
// end ; end ;
84509: GO 84378
84511: POP
84512: POP
// if not attacking and f_attack_depot then
84513: NOP4
84517: NOT
84518: PUSH
84519: NOP4
84523: AND
84524: IFFALSE 84619
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84526: NOP4
84530: PUSH
84531: NOP4
84535: PPUSH
84536: LD_INT 2
84538: PUSH
84539: LD_INT 30
84541: PUSH
84542: LD_INT 0
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: LD_INT 30
84551: PUSH
84552: LD_INT 1
84554: PUSH
84555: EMPTY
84556: LIST
84557: LIST
84558: PUSH
84559: EMPTY
84560: LIST
84561: LIST
84562: LIST
84563: PPUSH
84564: NOP4
84568: ST_TO_ADDR
// if z then
84569: NOP4
84573: IFFALSE 84619
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
84575: NOP4
84579: PUSH
84580: NOP4
84584: ARRAY
84585: PPUSH
84586: NOP4
84590: PPUSH
84591: NOP4
84595: PUSH
84596: NOP4
84600: ARRAY
84601: PPUSH
84602: NOP4
84606: PPUSH
84607: NOP4
// attacking := true ;
84611: NOP4
84615: PUSH
84616: LD_INT 1
84618: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84619: NOP4
84623: PUSH
84624: NOP4
84628: ARRAY
84629: PPUSH
84630: NOP4
84634: PUSH
84635: LD_INT 500
84637: LESS
84638: IFFALSE 84664
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84640: NOP4
84644: PUSH
84645: NOP4
84649: ARRAY
84650: PPUSH
84651: NOP4
84655: PUSH
84656: LD_INT 1
84658: ARRAY
84659: PPUSH
84660: NOP4
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84664: NOP4
84668: PUSH
84669: NOP4
84673: ARRAY
84674: PPUSH
84675: NOP4
84679: PUSH
84680: LD_INT 49
84682: EQUAL
84683: IFFALSE 84804
// begin if not HasTask ( group [ i ] ) then
84685: NOP4
84689: PUSH
84690: NOP4
84694: ARRAY
84695: PPUSH
84696: NOP4
84700: NOT
84701: IFFALSE 84804
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84703: NOP4
84707: PUSH
84708: LD_INT 81
84710: PUSH
84711: NOP4
84715: PUSH
84716: NOP4
84720: ARRAY
84721: PPUSH
84722: NOP4
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PPUSH
84731: NOP4
84735: PPUSH
84736: NOP4
84740: PUSH
84741: NOP4
84745: ARRAY
84746: PPUSH
84747: NOP4
84751: ST_TO_ADDR
// if k then
84752: NOP4
84756: IFFALSE 84804
// if GetDistUnits ( group [ i ] , k ) > 10 then
84758: NOP4
84762: PUSH
84763: NOP4
84767: ARRAY
84768: PPUSH
84769: NOP4
84773: PPUSH
84774: NOP4
84778: PUSH
84779: LD_INT 10
84781: GREATER
84782: IFFALSE 84804
// ComMoveUnit ( group [ i ] , k ) ;
84784: NOP4
84788: PUSH
84789: NOP4
84793: ARRAY
84794: PPUSH
84795: NOP4
84799: PPUSH
84800: NOP4
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84804: NOP4
84808: PUSH
84809: NOP4
84813: ARRAY
84814: PPUSH
84815: NOP4
84819: PUSH
84820: LD_INT 250
84822: LESS
84823: PUSH
84824: NOP4
84828: PUSH
84829: NOP4
84833: ARRAY
84834: PUSH
84835: LD_INT 21
84837: PUSH
84838: LD_INT 2
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 23
84847: PUSH
84848: LD_INT 2
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: PUSH
84855: EMPTY
84856: LIST
84857: LIST
84858: PPUSH
84859: NOP4
84863: IN
84864: AND
84865: IFFALSE 84990
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84867: NOP4
84871: PUSH
84872: NOP4
84876: PUSH
84877: NOP4
84881: PUSH
84882: NOP4
84886: ARRAY
84887: DIFF
84888: PPUSH
84889: NOP4
84893: PUSH
84894: NOP4
84898: ARRAY
84899: PPUSH
84900: NOP4
84904: ST_TO_ADDR
// if not k then
84905: NOP4
84909: NOT
84910: IFFALSE 84914
// continue ;
84912: GO 81329
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
84914: NOP4
84918: PUSH
84919: LD_INT 81
84921: PUSH
84922: NOP4
84926: PUSH
84927: NOP4
84931: ARRAY
84932: PPUSH
84933: NOP4
84937: PUSH
84938: EMPTY
84939: LIST
84940: LIST
84941: PPUSH
84942: NOP4
84946: IN
84947: PUSH
84948: NOP4
84952: PPUSH
84953: NOP4
84957: PUSH
84958: NOP4
84962: ARRAY
84963: PPUSH
84964: NOP4
84968: PUSH
84969: LD_INT 5
84971: LESS
84972: AND
84973: IFFALSE 84990
// ComAutodestruct ( group [ i ] ) ;
84975: NOP4
84979: PUSH
84980: NOP4
84984: ARRAY
84985: PPUSH
84986: NOP4
// end ; if f_attack_depot then
84990: NOP4
84994: IFFALSE 85106
// begin k := 6 ;
84996: NOP4
85000: PUSH
85001: LD_INT 6
85003: ST_TO_ADDR
// if tmp < k then
85004: NOP4
85008: PUSH
85009: NOP4
85013: LESS
85014: IFFALSE 85026
// k := tmp ;
85016: NOP4
85020: PUSH
85021: NOP4
85025: ST_TO_ADDR
// for j = 1 to k do
85026: NOP4
85030: PUSH
85031: DOUBLE
85032: LD_INT 1
85034: DEC
85035: ST_TO_ADDR
85036: NOP4
85040: PUSH
85041: FOR_TO
85042: IFFALSE 85104
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
85044: NOP4
85048: PPUSH
85049: NOP4
85053: PUSH
85054: LD_INT 0
85056: PUSH
85057: LD_INT 1
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: IN
85064: IFFALSE 85102
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85066: NOP4
85070: PUSH
85071: NOP4
85075: ARRAY
85076: PPUSH
85077: NOP4
85081: PUSH
85082: NOP4
85086: ARRAY
85087: PPUSH
85088: NOP4
// attacking := true ;
85092: NOP4
85096: PUSH
85097: LD_INT 1
85099: ST_TO_ADDR
// break ;
85100: GO 85104
// end ;
85102: GO 85041
85104: POP
85105: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
85106: NOP4
85110: PUSH
85111: NOP4
85115: ARRAY
85116: PPUSH
85117: NOP4
85121: PUSH
85122: NOP4
85126: NOT
85127: AND
85128: IFFALSE 85450
// begin if GetTag ( group [ i ] ) = 71 then
85130: NOP4
85134: PUSH
85135: NOP4
85139: ARRAY
85140: PPUSH
85141: NOP4
85145: PUSH
85146: LD_INT 71
85148: EQUAL
85149: IFFALSE 85190
// begin if HasTask ( group [ i ] ) then
85151: NOP4
85155: PUSH
85156: NOP4
85160: ARRAY
85161: PPUSH
85162: NOP4
85166: IFFALSE 85172
// continue else
85168: GO 81329
85170: GO 85190
// SetTag ( group [ i ] , 0 ) ;
85172: NOP4
85176: PUSH
85177: NOP4
85181: ARRAY
85182: PPUSH
85183: LD_INT 0
85185: PPUSH
85186: NOP4
// end ; k := 8 ;
85190: NOP4
85194: PUSH
85195: LD_INT 8
85197: ST_TO_ADDR
// x := 0 ;
85198: NOP4
85202: PUSH
85203: LD_INT 0
85205: ST_TO_ADDR
// if tmp < k then
85206: NOP4
85210: PUSH
85211: NOP4
85215: LESS
85216: IFFALSE 85228
// k := tmp ;
85218: NOP4
85222: PUSH
85223: NOP4
85227: ST_TO_ADDR
// for j = 1 to k do
85228: NOP4
85232: PUSH
85233: DOUBLE
85234: LD_INT 1
85236: DEC
85237: ST_TO_ADDR
85238: NOP4
85242: PUSH
85243: FOR_TO
85244: IFFALSE 85342
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
85246: NOP4
85250: PUSH
85251: NOP4
85255: ARRAY
85256: PPUSH
85257: NOP4
85261: PUSH
85262: LD_INT 1
85264: EQUAL
85265: PUSH
85266: NOP4
85270: PUSH
85271: NOP4
85275: ARRAY
85276: PPUSH
85277: NOP4
85281: PUSH
85282: LD_INT 250
85284: LESS
85285: PUSH
85286: NOP4
85290: AND
85291: PUSH
85292: NOP4
85296: NOT
85297: PUSH
85298: NOP4
85302: PUSH
85303: NOP4
85307: ARRAY
85308: PPUSH
85309: NOP4
85313: PUSH
85314: LD_INT 250
85316: GREATEREQUAL
85317: AND
85318: OR
85319: AND
85320: IFFALSE 85340
// begin x := tmp [ j ] ;
85322: NOP4
85326: PUSH
85327: NOP4
85331: PUSH
85332: NOP4
85336: ARRAY
85337: ST_TO_ADDR
// break ;
85338: GO 85342
// end ;
85340: GO 85243
85342: POP
85343: POP
// if x then
85344: NOP4
85348: IFFALSE 85372
// ComAttackUnit ( group [ i ] , x ) else
85350: NOP4
85354: PUSH
85355: NOP4
85359: ARRAY
85360: PPUSH
85361: NOP4
85365: PPUSH
85366: NOP4
85370: GO 85396
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85372: NOP4
85376: PUSH
85377: NOP4
85381: ARRAY
85382: PPUSH
85383: NOP4
85387: PUSH
85388: LD_INT 1
85390: ARRAY
85391: PPUSH
85392: NOP4
// if not HasTask ( group [ i ] ) then
85396: NOP4
85400: PUSH
85401: NOP4
85405: ARRAY
85406: PPUSH
85407: NOP4
85411: NOT
85412: IFFALSE 85450
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
85414: NOP4
85418: PUSH
85419: NOP4
85423: ARRAY
85424: PPUSH
85425: NOP4
85429: PPUSH
85430: NOP4
85434: PUSH
85435: NOP4
85439: ARRAY
85440: PPUSH
85441: NOP4
85445: PPUSH
85446: NOP4
// end ; end ; end ;
85450: GO 81329
85452: POP
85453: POP
// wait ( 0 0$2 ) ;
85454: LD_INT 70
85456: PPUSH
85457: NOP4
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
85461: NOP4
85465: NOT
85466: PUSH
85467: NOP4
85471: PUSH
85472: EMPTY
85473: EQUAL
85474: OR
85475: PUSH
85476: LD_INT 81
85478: PUSH
85479: NOP4
85483: PUSH
85484: EMPTY
85485: LIST
85486: LIST
85487: PPUSH
85488: NOP4
85492: NOT
85493: OR
85494: IFFALSE 81314
// end ;
85496: LD_VAR 0 2
85500: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
85501: LD_INT 0
85503: PPUSH
85504: PPUSH
85505: PPUSH
85506: PPUSH
85507: PPUSH
85508: PPUSH
// if not base or not mc_bases [ base ] or not solds then
85509: NOP4
85513: NOT
85514: PUSH
85515: NOP4
85519: PUSH
85520: NOP4
85524: ARRAY
85525: NOT
85526: OR
85527: PUSH
85528: NOP4
85532: NOT
85533: OR
85534: IFFALSE 85538
// exit ;
85536: GO 86092
// side := mc_sides [ base ] ;
85538: NOP4
85542: PUSH
85543: NOP4
85547: PUSH
85548: NOP4
85552: ARRAY
85553: ST_TO_ADDR
// if not side then
85554: NOP4
85558: NOT
85559: IFFALSE 85563
// exit ;
85561: GO 86092
// for i in solds do
85563: NOP4
85567: PUSH
85568: NOP4
85572: PUSH
85573: FOR_IN
85574: IFFALSE 85635
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
85576: NOP4
85580: PPUSH
85581: NOP4
85585: PPUSH
85586: NOP4
85590: PUSH
85591: LD_INT 32
85593: PUSH
85594: LD_INT 31
85596: PUSH
85597: EMPTY
85598: LIST
85599: LIST
85600: IN
85601: IFFALSE 85621
// solds := solds diff i else
85603: NOP4
85607: PUSH
85608: NOP4
85612: PUSH
85613: NOP4
85617: DIFF
85618: ST_TO_ADDR
85619: GO 85633
// SetTag ( i , 18 ) ;
85621: NOP4
85625: PPUSH
85626: LD_INT 18
85628: PPUSH
85629: NOP4
85633: GO 85573
85635: POP
85636: POP
// if not solds then
85637: NOP4
85641: NOT
85642: IFFALSE 85646
// exit ;
85644: GO 86092
// repeat wait ( 0 0$2 ) ;
85646: LD_INT 70
85648: PPUSH
85649: NOP4
// enemy := mc_scan [ base ] ;
85653: NOP4
85657: PUSH
85658: NOP4
85662: PUSH
85663: NOP4
85667: ARRAY
85668: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85669: NOP4
85673: PUSH
85674: NOP4
85678: ARRAY
85679: NOT
85680: PUSH
85681: NOP4
85685: PUSH
85686: NOP4
85690: ARRAY
85691: PUSH
85692: EMPTY
85693: EQUAL
85694: OR
85695: IFFALSE 85732
// begin for i in solds do
85697: NOP4
85701: PUSH
85702: NOP4
85706: PUSH
85707: FOR_IN
85708: IFFALSE 85721
// ComStop ( i ) ;
85710: NOP4
85714: PPUSH
85715: NOP4
85719: GO 85707
85721: POP
85722: POP
// solds := [ ] ;
85723: NOP4
85727: PUSH
85728: EMPTY
85729: ST_TO_ADDR
// exit ;
85730: GO 86092
// end ; for i in solds do
85732: NOP4
85736: PUSH
85737: NOP4
85741: PUSH
85742: FOR_IN
85743: IFFALSE 86064
// begin if IsInUnit ( i ) then
85745: NOP4
85749: PPUSH
85750: NOP4
85754: IFFALSE 85765
// ComExitBuilding ( i ) ;
85756: NOP4
85760: PPUSH
85761: NOP4
// if GetLives ( i ) > 500 then
85765: NOP4
85769: PPUSH
85770: NOP4
85774: PUSH
85775: LD_INT 500
85777: GREATER
85778: IFFALSE 85831
// begin e := NearestUnitToUnit ( enemy , i ) ;
85780: NOP4
85784: PUSH
85785: NOP4
85789: PPUSH
85790: NOP4
85794: PPUSH
85795: NOP4
85799: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
85800: NOP4
85804: PPUSH
85805: NOP4
85809: PPUSH
85810: NOP4
85814: PPUSH
85815: NOP4
85819: PPUSH
85820: NOP4
85824: PPUSH
85825: NOP4
// end else
85829: GO 86062
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
85831: NOP4
85835: PPUSH
85836: NOP4
85840: PUSH
85841: NOP4
85845: ARRAY
85846: PPUSH
85847: LD_INT 2
85849: PUSH
85850: LD_INT 30
85852: PUSH
85853: LD_INT 0
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: PUSH
85860: LD_INT 30
85862: PUSH
85863: LD_INT 1
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 30
85872: PUSH
85873: LD_INT 6
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: LIST
85884: LIST
85885: PPUSH
85886: NOP4
85890: PPUSH
85891: NOP4
85895: PPUSH
85896: NOP4
85900: PPUSH
85901: NOP4
85905: PUSH
85906: LD_INT 10
85908: GREATER
85909: IFFALSE 86062
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
85911: NOP4
85915: PUSH
85916: NOP4
85920: PUSH
85921: NOP4
85925: ARRAY
85926: PPUSH
85927: LD_INT 2
85929: PUSH
85930: LD_INT 30
85932: PUSH
85933: LD_INT 0
85935: PUSH
85936: EMPTY
85937: LIST
85938: LIST
85939: PUSH
85940: LD_INT 30
85942: PUSH
85943: LD_INT 1
85945: PUSH
85946: EMPTY
85947: LIST
85948: LIST
85949: PUSH
85950: LD_INT 30
85952: PUSH
85953: LD_INT 6
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: PPUSH
85966: NOP4
85970: PPUSH
85971: NOP4
85975: PPUSH
85976: NOP4
85980: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
85981: NOP4
85985: PPUSH
85986: NOP4
85990: PPUSH
85991: NOP4
85995: PPUSH
85996: LD_INT 3
85998: PPUSH
85999: LD_INT 5
86001: PPUSH
86002: NOP4
86006: PPUSH
86007: NOP4
86011: PPUSH
86012: NOP4
86016: PPUSH
86017: LD_INT 3
86019: PPUSH
86020: LD_INT 5
86022: PPUSH
86023: NOP4
86027: PPUSH
86028: NOP4
// SetTag ( i , 0 ) ;
86032: NOP4
86036: PPUSH
86037: LD_INT 0
86039: PPUSH
86040: NOP4
// solds := solds diff i ;
86044: NOP4
86048: PUSH
86049: NOP4
86053: PUSH
86054: NOP4
86058: DIFF
86059: ST_TO_ADDR
// continue ;
86060: GO 85742
// end ; end ;
86062: GO 85742
86064: POP
86065: POP
// until not solds or not enemy ;
86066: NOP4
86070: NOT
86071: PUSH
86072: NOP4
86076: NOT
86077: OR
86078: IFFALSE 85646
// MC_Reset ( base , 18 ) ;
86080: NOP4
86084: PPUSH
86085: LD_INT 18
86087: PPUSH
86088: NOP4
// end ;
86092: LD_VAR 0 3
86096: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
86097: LD_INT 0
86099: PPUSH
86100: PPUSH
86101: PPUSH
86102: PPUSH
86103: PPUSH
86104: PPUSH
86105: PPUSH
86106: PPUSH
86107: PPUSH
86108: PPUSH
86109: PPUSH
86110: PPUSH
86111: PPUSH
86112: PPUSH
86113: PPUSH
86114: PPUSH
86115: PPUSH
86116: PPUSH
86117: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86118: NOP4
86122: PUSH
86123: NOP4
86127: PUSH
86128: NOP4
86132: ARRAY
86133: PPUSH
86134: LD_INT 25
86136: PUSH
86137: LD_INT 3
86139: PUSH
86140: EMPTY
86141: LIST
86142: LIST
86143: PPUSH
86144: NOP4
86148: ST_TO_ADDR
// if mc_remote_driver [ base ] then
86149: NOP4
86153: PUSH
86154: NOP4
86158: ARRAY
86159: IFFALSE 86183
// mechs := mechs diff mc_remote_driver [ base ] ;
86161: NOP4
86165: PUSH
86166: NOP4
86170: PUSH
86171: NOP4
86175: PUSH
86176: NOP4
86180: ARRAY
86181: DIFF
86182: ST_TO_ADDR
// for i in mechs do
86183: NOP4
86187: PUSH
86188: NOP4
86192: PUSH
86193: FOR_IN
86194: IFFALSE 86229
// if GetTag ( i ) > 0 then
86196: NOP4
86200: PPUSH
86201: NOP4
86205: PUSH
86206: LD_INT 0
86208: GREATER
86209: IFFALSE 86227
// mechs := mechs diff i ;
86211: NOP4
86215: PUSH
86216: NOP4
86220: PUSH
86221: NOP4
86225: DIFF
86226: ST_TO_ADDR
86227: GO 86193
86229: POP
86230: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86231: NOP4
86235: PUSH
86236: NOP4
86240: PUSH
86241: NOP4
86245: ARRAY
86246: PPUSH
86247: LD_INT 2
86249: PUSH
86250: LD_INT 25
86252: PUSH
86253: LD_INT 1
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 25
86262: PUSH
86263: LD_INT 5
86265: PUSH
86266: EMPTY
86267: LIST
86268: LIST
86269: PUSH
86270: LD_INT 25
86272: PUSH
86273: LD_INT 8
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 25
86282: PUSH
86283: LD_INT 9
86285: PUSH
86286: EMPTY
86287: LIST
86288: LIST
86289: PUSH
86290: EMPTY
86291: LIST
86292: LIST
86293: LIST
86294: LIST
86295: LIST
86296: PPUSH
86297: NOP4
86301: ST_TO_ADDR
// if not defenders and not solds then
86302: NOP4
86306: NOT
86307: PUSH
86308: NOP4
86312: NOT
86313: AND
86314: IFFALSE 86318
// exit ;
86316: GO 88088
// depot_under_attack := false ;
86318: NOP4
86322: PUSH
86323: LD_INT 0
86325: ST_TO_ADDR
// sold_defenders := [ ] ;
86326: NOP4
86330: PUSH
86331: EMPTY
86332: ST_TO_ADDR
// if mechs then
86333: NOP4
86337: IFFALSE 86490
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
86339: NOP4
86343: PUSH
86344: NOP4
86348: PPUSH
86349: LD_INT 21
86351: PUSH
86352: LD_INT 2
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PPUSH
86359: NOP4
86363: PUSH
86364: FOR_IN
86365: IFFALSE 86488
// begin if GetTag ( i ) <> 20 then
86367: NOP4
86371: PPUSH
86372: NOP4
86376: PUSH
86377: LD_INT 20
86379: NONEQUAL
86380: IFFALSE 86394
// SetTag ( i , 20 ) ;
86382: NOP4
86386: PPUSH
86387: LD_INT 20
86389: PPUSH
86390: NOP4
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
86394: NOP4
86398: PPUSH
86399: NOP4
86403: PUSH
86404: LD_INT 1
86406: EQUAL
86407: PUSH
86408: NOP4
86412: PPUSH
86413: NOP4
86417: NOT
86418: AND
86419: IFFALSE 86486
// begin un := mechs [ 1 ] ;
86421: NOP4
86425: PUSH
86426: NOP4
86430: PUSH
86431: LD_INT 1
86433: ARRAY
86434: ST_TO_ADDR
// ComExit ( un ) ;
86435: NOP4
86439: PPUSH
86440: NOP4
// AddComEnterUnit ( un , i ) ;
86444: NOP4
86448: PPUSH
86449: NOP4
86453: PPUSH
86454: NOP4
// SetTag ( un , 19 ) ;
86458: NOP4
86462: PPUSH
86463: LD_INT 19
86465: PPUSH
86466: NOP4
// mechs := mechs diff un ;
86470: NOP4
86474: PUSH
86475: NOP4
86479: PUSH
86480: NOP4
86484: DIFF
86485: ST_TO_ADDR
// end ; end ;
86486: GO 86364
86488: POP
86489: POP
// if solds then
86490: NOP4
86494: IFFALSE 86553
// for i in solds do
86496: NOP4
86500: PUSH
86501: NOP4
86505: PUSH
86506: FOR_IN
86507: IFFALSE 86551
// if not GetTag ( i ) then
86509: NOP4
86513: PPUSH
86514: NOP4
86518: NOT
86519: IFFALSE 86549
// begin defenders := defenders union i ;
86521: NOP4
86525: PUSH
86526: NOP4
86530: PUSH
86531: NOP4
86535: UNION
86536: ST_TO_ADDR
// SetTag ( i , 18 ) ;
86537: NOP4
86541: PPUSH
86542: LD_INT 18
86544: PPUSH
86545: NOP4
// end ;
86549: GO 86506
86551: POP
86552: POP
// repeat wait ( 0 0$2 ) ;
86553: LD_INT 70
86555: PPUSH
86556: NOP4
// enemy := mc_scan [ base ] ;
86560: NOP4
86564: PUSH
86565: NOP4
86569: PUSH
86570: NOP4
86574: ARRAY
86575: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86576: NOP4
86580: PUSH
86581: NOP4
86585: ARRAY
86586: NOT
86587: PUSH
86588: NOP4
86592: PUSH
86593: NOP4
86597: ARRAY
86598: PUSH
86599: EMPTY
86600: EQUAL
86601: OR
86602: IFFALSE 86639
// begin for i in defenders do
86604: NOP4
86608: PUSH
86609: NOP4
86613: PUSH
86614: FOR_IN
86615: IFFALSE 86628
// ComStop ( i ) ;
86617: NOP4
86621: PPUSH
86622: NOP4
86626: GO 86614
86628: POP
86629: POP
// defenders := [ ] ;
86630: NOP4
86634: PUSH
86635: EMPTY
86636: ST_TO_ADDR
// exit ;
86637: GO 88088
// end ; for i in defenders do
86639: NOP4
86643: PUSH
86644: NOP4
86648: PUSH
86649: FOR_IN
86650: IFFALSE 87548
// begin e := NearestUnitToUnit ( enemy , i ) ;
86652: NOP4
86656: PUSH
86657: NOP4
86661: PPUSH
86662: NOP4
86666: PPUSH
86667: NOP4
86671: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86672: NOP4
86676: PUSH
86677: NOP4
86681: PUSH
86682: NOP4
86686: ARRAY
86687: PPUSH
86688: LD_INT 2
86690: PUSH
86691: LD_INT 30
86693: PUSH
86694: LD_INT 0
86696: PUSH
86697: EMPTY
86698: LIST
86699: LIST
86700: PUSH
86701: LD_INT 30
86703: PUSH
86704: LD_INT 1
86706: PUSH
86707: EMPTY
86708: LIST
86709: LIST
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: LIST
86715: PPUSH
86716: NOP4
86720: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86721: NOP4
86725: PUSH
86726: NOP4
86730: NOT
86731: PUSH
86732: NOP4
86736: PPUSH
86737: LD_INT 3
86739: PUSH
86740: LD_INT 24
86742: PUSH
86743: LD_INT 600
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PPUSH
86754: NOP4
86758: OR
86759: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86760: NOP4
86764: PPUSH
86765: NOP4
86769: PUSH
86770: LD_INT 2
86772: DOUBLE
86773: EQUAL
86774: IFTRUE 86778
86776: GO 87174
86778: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
86779: NOP4
86783: PPUSH
86784: NOP4
86788: PUSH
86789: LD_INT 1000
86791: EQUAL
86792: PUSH
86793: NOP4
86797: PPUSH
86798: NOP4
86802: PPUSH
86803: NOP4
86807: PUSH
86808: LD_INT 40
86810: LESS
86811: PUSH
86812: NOP4
86816: PPUSH
86817: NOP4
86821: PUSH
86822: NOP4
86826: ARRAY
86827: PPUSH
86828: NOP4
86832: OR
86833: AND
86834: IFFALSE 86956
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
86836: NOP4
86840: PPUSH
86841: NOP4
86845: PUSH
86846: LD_INT 1
86848: EQUAL
86849: PUSH
86850: NOP4
86854: PPUSH
86855: NOP4
86859: PUSH
86860: LD_INT 30
86862: LESS
86863: AND
86864: PUSH
86865: NOP4
86869: AND
86870: IFFALSE 86940
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
86872: NOP4
86876: PPUSH
86877: NOP4
86881: PPUSH
86882: NOP4
86886: PPUSH
86887: NOP4
86891: PPUSH
86892: NOP4
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
86896: NOP4
86900: PPUSH
86901: NOP4
86905: PPUSH
86906: NOP4
86910: PPUSH
86911: NOP4
86915: PPUSH
86916: NOP4
86920: PUSH
86921: LD_INT 6
86923: LESS
86924: IFFALSE 86938
// SetFuel ( i , 100 ) ;
86926: NOP4
86930: PPUSH
86931: LD_INT 100
86933: PPUSH
86934: NOP4
// end else
86938: GO 86954
// ComAttackUnit ( i , e ) ;
86940: NOP4
86944: PPUSH
86945: NOP4
86949: PPUSH
86950: NOP4
// end else
86954: GO 87057
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
86956: NOP4
86960: PPUSH
86961: NOP4
86965: PUSH
86966: NOP4
86970: ARRAY
86971: PPUSH
86972: NOP4
86976: NOT
86977: PUSH
86978: NOP4
86982: PPUSH
86983: NOP4
86987: PPUSH
86988: NOP4
86992: PUSH
86993: LD_INT 40
86995: GREATEREQUAL
86996: AND
86997: PUSH
86998: NOP4
87002: PPUSH
87003: NOP4
87007: PUSH
87008: LD_INT 650
87010: LESSEQUAL
87011: OR
87012: PUSH
87013: NOP4
87017: PPUSH
87018: NOP4
87022: PUSH
87023: NOP4
87027: ARRAY
87028: PPUSH
87029: NOP4
87033: NOT
87034: AND
87035: IFFALSE 87057
// ComMoveToArea ( i , mc_parking [ base ] ) ;
87037: NOP4
87041: PPUSH
87042: NOP4
87046: PUSH
87047: NOP4
87051: ARRAY
87052: PPUSH
87053: NOP4
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
87057: NOP4
87061: PPUSH
87062: NOP4
87066: PUSH
87067: LD_INT 1000
87069: LESS
87070: PUSH
87071: NOP4
87075: PPUSH
87076: NOP4
87080: PUSH
87081: LD_INT 1
87083: EQUAL
87084: AND
87085: PUSH
87086: NOP4
87090: PPUSH
87091: NOP4
87095: AND
87096: PUSH
87097: NOP4
87101: PPUSH
87102: NOP4
87106: PUSH
87107: NOP4
87111: ARRAY
87112: PPUSH
87113: NOP4
87117: AND
87118: IFFALSE 87172
// begin mech := IsDrivenBy ( i ) ;
87120: NOP4
87124: PUSH
87125: NOP4
87129: PPUSH
87130: NOP4
87134: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
87135: NOP4
87139: PPUSH
87140: NOP4
// AddComRepairVehicle ( mech , i ) ;
87144: NOP4
87148: PPUSH
87149: NOP4
87153: PPUSH
87154: NOP4
// AddComEnterUnit ( mech , i ) ;
87158: NOP4
87162: PPUSH
87163: NOP4
87167: PPUSH
87168: NOP4
// end ; end ; unit_human :
87172: GO 87519
87174: LD_INT 1
87176: DOUBLE
87177: EQUAL
87178: IFTRUE 87182
87180: GO 87518
87182: POP
// begin b := IsInUnit ( i ) ;
87183: NOP4
87187: PUSH
87188: NOP4
87192: PPUSH
87193: NOP4
87197: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
87198: NOP4
87202: PUSH
87203: NOP4
87207: NOT
87208: PUSH
87209: NOP4
87213: PPUSH
87214: NOP4
87218: PUSH
87219: LD_INT 32
87221: PUSH
87222: LD_INT 31
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: IN
87229: OR
87230: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
87231: NOP4
87235: PPUSH
87236: NOP4
87240: PUSH
87241: LD_INT 5
87243: EQUAL
87244: PUSH
87245: NOP4
87249: PPUSH
87250: NOP4
87254: PUSH
87255: LD_INT 1
87257: PUSH
87258: LD_INT 2
87260: PUSH
87261: LD_INT 3
87263: PUSH
87264: LD_INT 4
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: IN
87273: AND
87274: IFFALSE 87311
// begin class := AllowSpecClass ( i ) ;
87276: NOP4
87280: PUSH
87281: NOP4
87285: PPUSH
87286: NOP4
87290: ST_TO_ADDR
// if class then
87291: NOP4
87295: IFFALSE 87311
// ComChangeProfession ( i , class ) ;
87297: NOP4
87301: PPUSH
87302: NOP4
87306: PPUSH
87307: NOP4
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
87311: NOP4
87315: PUSH
87316: NOP4
87320: PPUSH
87321: LD_INT 21
87323: PUSH
87324: LD_INT 2
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: PPUSH
87331: NOP4
87335: PUSH
87336: LD_INT 1
87338: LESSEQUAL
87339: OR
87340: PUSH
87341: NOP4
87345: AND
87346: PUSH
87347: NOP4
87351: PUSH
87352: NOP4
87356: IN
87357: NOT
87358: AND
87359: IFFALSE 87452
// begin if b then
87361: NOP4
87365: IFFALSE 87414
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
87367: NOP4
87371: PPUSH
87372: NOP4
87376: PPUSH
87377: NOP4
87381: PPUSH
87382: NOP4
87386: PPUSH
87387: NOP4
87391: PUSH
87392: LD_INT 10
87394: LESS
87395: PUSH
87396: NOP4
87400: PPUSH
87401: NOP4
87405: PUSH
87406: LD_INT 7
87408: NONEQUAL
87409: AND
87410: IFFALSE 87414
// continue ;
87412: GO 86649
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
87414: NOP4
87418: PUSH
87419: NOP4
87423: PPUSH
87424: NOP4
87428: PUSH
87429: LD_INT 1
87431: PLUS
87432: PPUSH
87433: NOP4
87437: PPUSH
87438: NOP4
87442: ST_TO_ADDR
// ComExitBuilding ( i ) ;
87443: NOP4
87447: PPUSH
87448: NOP4
// end ; if sold_defenders then
87452: NOP4
87456: IFFALSE 87516
// if i in sold_defenders then
87458: NOP4
87462: PUSH
87463: NOP4
87467: IN
87468: IFFALSE 87516
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
87470: NOP4
87474: PPUSH
87475: NOP4
87479: NOT
87480: PUSH
87481: NOP4
87485: PPUSH
87486: NOP4
87490: PPUSH
87491: NOP4
87495: PUSH
87496: LD_INT 30
87498: LESS
87499: AND
87500: IFFALSE 87516
// ComAttackUnit ( i , e ) ;
87502: NOP4
87506: PPUSH
87507: NOP4
87511: PPUSH
87512: NOP4
// end ; end ; end ;
87516: GO 87519
87518: POP
// if IsDead ( i ) then
87519: NOP4
87523: PPUSH
87524: NOP4
87528: IFFALSE 87546
// defenders := defenders diff i ;
87530: NOP4
87534: PUSH
87535: NOP4
87539: PUSH
87540: NOP4
87544: DIFF
87545: ST_TO_ADDR
// end ;
87546: GO 86649
87548: POP
87549: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
87550: NOP4
87554: NOT
87555: PUSH
87556: NOP4
87560: NOT
87561: OR
87562: PUSH
87563: NOP4
87567: PUSH
87568: NOP4
87572: ARRAY
87573: NOT
87574: OR
87575: IFFALSE 86553
// MC_Reset ( base , 18 ) ;
87577: NOP4
87581: PPUSH
87582: LD_INT 18
87584: PPUSH
87585: NOP4
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87589: NOP4
87593: PUSH
87594: NOP4
87598: PUSH
87599: NOP4
87603: PPUSH
87604: LD_INT 2
87606: PUSH
87607: LD_INT 25
87609: PUSH
87610: LD_INT 1
87612: PUSH
87613: EMPTY
87614: LIST
87615: LIST
87616: PUSH
87617: LD_INT 25
87619: PUSH
87620: LD_INT 5
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PUSH
87627: LD_INT 25
87629: PUSH
87630: LD_INT 8
87632: PUSH
87633: EMPTY
87634: LIST
87635: LIST
87636: PUSH
87637: LD_INT 25
87639: PUSH
87640: LD_INT 9
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: EMPTY
87648: LIST
87649: LIST
87650: LIST
87651: LIST
87652: LIST
87653: PPUSH
87654: NOP4
87658: DIFF
87659: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87660: NOP4
87664: NOT
87665: PUSH
87666: NOP4
87670: PPUSH
87671: LD_INT 21
87673: PUSH
87674: LD_INT 2
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PPUSH
87681: NOP4
87685: AND
87686: IFFALSE 88024
// begin tmp := FilterByTag ( defenders , 19 ) ;
87688: NOP4
87692: PUSH
87693: NOP4
87697: PPUSH
87698: LD_INT 19
87700: PPUSH
87701: NOP4
87705: ST_TO_ADDR
// if tmp then
87706: NOP4
87710: IFFALSE 87780
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87712: NOP4
87716: PUSH
87717: NOP4
87721: PPUSH
87722: LD_INT 25
87724: PUSH
87725: LD_INT 3
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: PPUSH
87732: NOP4
87736: ST_TO_ADDR
// if tmp then
87737: NOP4
87741: IFFALSE 87780
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87743: NOP4
87747: PUSH
87748: NOP4
87752: PPUSH
87753: NOP4
87757: PPUSH
87758: NOP4
87762: PUSH
87763: NOP4
87767: ARRAY
87768: PUSH
87769: NOP4
87773: UNION
87774: PPUSH
87775: NOP4
87779: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
87780: NOP4
87784: PPUSH
87785: LD_INT 19
87787: PPUSH
87788: NOP4
// repeat wait ( 0 0$1 ) ;
87792: LD_INT 35
87794: PPUSH
87795: NOP4
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87799: NOP4
87803: PUSH
87804: NOP4
87808: ARRAY
87809: NOT
87810: PUSH
87811: NOP4
87815: PUSH
87816: NOP4
87820: ARRAY
87821: PUSH
87822: EMPTY
87823: EQUAL
87824: OR
87825: IFFALSE 87862
// begin for i in defenders do
87827: NOP4
87831: PUSH
87832: NOP4
87836: PUSH
87837: FOR_IN
87838: IFFALSE 87851
// ComStop ( i ) ;
87840: NOP4
87844: PPUSH
87845: NOP4
87849: GO 87837
87851: POP
87852: POP
// defenders := [ ] ;
87853: NOP4
87857: PUSH
87858: EMPTY
87859: ST_TO_ADDR
// exit ;
87860: GO 88088
// end ; for i in defenders do
87862: NOP4
87866: PUSH
87867: NOP4
87871: PUSH
87872: FOR_IN
87873: IFFALSE 87962
// begin if not IsInArea ( i , mc_parking [ base ] ) then
87875: NOP4
87879: PPUSH
87880: NOP4
87884: PUSH
87885: NOP4
87889: ARRAY
87890: PPUSH
87891: NOP4
87895: NOT
87896: IFFALSE 87920
// ComMoveToArea ( i , mc_parking [ base ] ) else
87898: NOP4
87902: PPUSH
87903: NOP4
87907: PUSH
87908: NOP4
87912: ARRAY
87913: PPUSH
87914: NOP4
87918: GO 87960
// if GetControl ( i ) = control_manual then
87920: NOP4
87924: PPUSH
87925: NOP4
87929: PUSH
87930: LD_INT 1
87932: EQUAL
87933: IFFALSE 87960
// if IsDrivenBy ( i ) then
87935: NOP4
87939: PPUSH
87940: NOP4
87944: IFFALSE 87960
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
87946: NOP4
87950: PPUSH
87951: NOP4
87955: PPUSH
87956: NOP4
// end ;
87960: GO 87872
87962: POP
87963: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
87964: NOP4
87968: PPUSH
87969: LD_INT 95
87971: PUSH
87972: NOP4
87976: PUSH
87977: NOP4
87981: ARRAY
87982: PUSH
87983: EMPTY
87984: LIST
87985: LIST
87986: PPUSH
87987: NOP4
87991: PUSH
87992: NOP4
87996: EQUAL
87997: PUSH
87998: NOP4
88002: PUSH
88003: NOP4
88007: ARRAY
88008: OR
88009: PUSH
88010: NOP4
88014: PUSH
88015: NOP4
88019: ARRAY
88020: NOT
88021: OR
88022: IFFALSE 87792
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
88024: NOP4
88028: PUSH
88029: NOP4
88033: PPUSH
88034: NOP4
88038: PPUSH
88039: NOP4
88043: PPUSH
88044: LD_INT 21
88046: PUSH
88047: LD_INT 2
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: PPUSH
88054: NOP4
88058: PPUSH
88059: NOP4
88063: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
88064: NOP4
88068: PPUSH
88069: LD_INT 19
88071: PPUSH
88072: NOP4
// MC_Reset ( base , 20 ) ;
88076: NOP4
88080: PPUSH
88081: LD_INT 20
88083: PPUSH
88084: NOP4
// end ; end_of_file
88088: LD_VAR 0 3
88092: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
88093: LD_INT 0
88095: PPUSH
88096: PPUSH
88097: PPUSH
88098: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
88099: NOP4
88103: PPUSH
88104: NOP4
88108: PUSH
88109: NOP4
88113: EQUAL
88114: IFFALSE 88186
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
88116: LD_INT 68
88118: PPUSH
88119: NOP4
88123: PPUSH
88124: NOP4
88128: PPUSH
88129: NOP4
88133: PUSH
88134: LD_INT 2
88136: EQUAL
88137: IFFALSE 88149
// eff := 70 else
88139: NOP4
88143: PUSH
88144: LD_INT 70
88146: ST_TO_ADDR
88147: GO 88157
// eff := 30 ;
88149: NOP4
88153: PUSH
88154: LD_INT 30
88156: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
88157: NOP4
88161: PPUSH
88162: NOP4
88166: PPUSH
88167: NOP4
88171: PPUSH
88172: NOP4
88176: PPUSH
88177: NOP4
88181: PPUSH
88182: NOP4
// end ; end ;
88186: LD_VAR 0 2
88190: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
88191: LD_INT 0
88193: PPUSH
// end ;
88194: LD_VAR 0 4
88198: RET
// export function SOS_Command ( cmd ) ; begin
88199: LD_INT 0
88201: PPUSH
// end ;
88202: LD_VAR 0 2
88206: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
88207: LD_INT 0
88209: PPUSH
// end ;
88210: LD_VAR 0 6
88214: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
88215: LD_INT 0
88217: PPUSH
88218: PPUSH
// if not vehicle or not factory then
88219: NOP4
88223: NOT
88224: PUSH
88225: NOP4
88229: NOT
88230: OR
88231: IFFALSE 88235
// exit ;
88233: GO 88466
// if factoryWaypoints >= factory then
88235: NOP4
88239: PUSH
88240: NOP4
88244: GREATEREQUAL
88245: IFFALSE 88466
// if factoryWaypoints [ factory ] then
88247: NOP4
88251: PUSH
88252: NOP4
88256: ARRAY
88257: IFFALSE 88466
// begin if GetControl ( vehicle ) = control_manual then
88259: NOP4
88263: PPUSH
88264: NOP4
88268: PUSH
88269: LD_INT 1
88271: EQUAL
88272: IFFALSE 88353
// begin driver := IsDrivenBy ( vehicle ) ;
88274: NOP4
88278: PUSH
88279: NOP4
88283: PPUSH
88284: NOP4
88288: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
88289: NOP4
88293: PPUSH
88294: NOP4
88298: PUSH
88299: NOP4
88303: ARRAY
88304: PUSH
88305: LD_INT 3
88307: ARRAY
88308: PPUSH
88309: NOP4
88313: PUSH
88314: NOP4
88318: ARRAY
88319: PUSH
88320: LD_INT 4
88322: ARRAY
88323: PPUSH
88324: NOP4
// AddComExitVehicle ( driver ) ;
88328: NOP4
88332: PPUSH
88333: NOP4
// AddComEnterUnit ( driver , factory ) ;
88337: NOP4
88341: PPUSH
88342: NOP4
88346: PPUSH
88347: NOP4
// end else
88351: GO 88466
// if GetControl ( vehicle ) = control_remote then
88353: NOP4
88357: PPUSH
88358: NOP4
88362: PUSH
88363: LD_INT 2
88365: EQUAL
88366: IFFALSE 88427
// begin wait ( 0 0$2 ) ;
88368: LD_INT 70
88370: PPUSH
88371: NOP4
// if Connect ( vehicle ) then
88375: NOP4
88379: PPUSH
88380: NOP4
88384: IFFALSE 88425
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
88386: NOP4
88390: PPUSH
88391: NOP4
88395: PUSH
88396: NOP4
88400: ARRAY
88401: PUSH
88402: LD_INT 3
88404: ARRAY
88405: PPUSH
88406: NOP4
88410: PUSH
88411: NOP4
88415: ARRAY
88416: PUSH
88417: LD_INT 4
88419: ARRAY
88420: PPUSH
88421: NOP4
// end else
88425: GO 88466
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
88427: NOP4
88431: PPUSH
88432: NOP4
88436: PUSH
88437: NOP4
88441: ARRAY
88442: PUSH
88443: LD_INT 3
88445: ARRAY
88446: PPUSH
88447: NOP4
88451: PUSH
88452: NOP4
88456: ARRAY
88457: PUSH
88458: LD_INT 4
88460: ARRAY
88461: PPUSH
88462: NOP4
// end ; end ;
88466: LD_VAR 0 3
88470: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
88471: LD_INT 0
88473: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
88474: NOP4
88478: PUSH
88479: LD_INT 250
88481: EQUAL
88482: PUSH
88483: NOP4
88487: PPUSH
88488: NOP4
88492: PUSH
88493: NOP4
88497: EQUAL
88498: AND
88499: IFFALSE 88520
// MinerPlaceMine ( unit , x , y ) ;
88501: NOP4
88505: PPUSH
88506: NOP4
88510: PPUSH
88511: NOP4
88515: PPUSH
88516: NOP4
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
88520: NOP4
88524: PUSH
88525: LD_INT 251
88527: EQUAL
88528: PUSH
88529: NOP4
88533: PPUSH
88534: NOP4
88538: PUSH
88539: NOP4
88543: EQUAL
88544: AND
88545: IFFALSE 88566
// MinerDetonateMine ( unit , x , y ) ;
88547: NOP4
88551: PPUSH
88552: NOP4
88556: PPUSH
88557: NOP4
88561: PPUSH
88562: NOP4
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
88566: NOP4
88570: PUSH
88571: LD_INT 252
88573: EQUAL
88574: PUSH
88575: NOP4
88579: PPUSH
88580: NOP4
88584: PUSH
88585: NOP4
88589: EQUAL
88590: AND
88591: IFFALSE 88612
// MinerCreateMinefield ( unit , x , y ) ;
88593: NOP4
88597: PPUSH
88598: NOP4
88602: PPUSH
88603: NOP4
88607: PPUSH
88608: NOP4
// if cmd = 253 and GetClass ( unit ) = class_sniper then
88612: NOP4
88616: PUSH
88617: LD_INT 253
88619: EQUAL
88620: PUSH
88621: NOP4
88625: PPUSH
88626: NOP4
88630: PUSH
88631: LD_INT 5
88633: EQUAL
88634: AND
88635: IFFALSE 88656
// ComBinocular ( unit , x , y ) ;
88637: NOP4
88641: PPUSH
88642: NOP4
88646: PPUSH
88647: NOP4
88651: PPUSH
88652: NOP4
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
88656: NOP4
88660: PUSH
88661: LD_INT 254
88663: EQUAL
88664: PUSH
88665: NOP4
88669: PPUSH
88670: NOP4
88674: PUSH
88675: NOP4
88679: EQUAL
88680: AND
88681: PUSH
88682: NOP4
88686: PPUSH
88687: NOP4
88691: PUSH
88692: LD_INT 3
88694: EQUAL
88695: AND
88696: IFFALSE 88712
// HackDestroyVehicle ( unit , selectedUnit ) ;
88698: NOP4
88702: PPUSH
88703: NOP4
88707: PPUSH
88708: NOP4
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
88712: NOP4
88716: PUSH
88717: LD_INT 255
88719: EQUAL
88720: PUSH
88721: NOP4
88725: PPUSH
88726: NOP4
88730: PUSH
88731: LD_INT 14
88733: PUSH
88734: LD_INT 53
88736: PUSH
88737: EMPTY
88738: LIST
88739: LIST
88740: IN
88741: AND
88742: PUSH
88743: NOP4
88747: PPUSH
88748: NOP4
88752: PPUSH
88753: NOP4
88757: AND
88758: IFFALSE 88782
// CutTreeXYR ( unit , x , y , 12 ) ;
88760: NOP4
88764: PPUSH
88765: NOP4
88769: PPUSH
88770: NOP4
88774: PPUSH
88775: LD_INT 12
88777: PPUSH
88778: NOP4
// if cmd = 256 then
88782: NOP4
88786: PUSH
88787: LD_INT 256
88789: EQUAL
88790: IFFALSE 88811
// SetFactoryWaypoint ( unit , x , y ) ;
88792: NOP4
88796: PPUSH
88797: NOP4
88801: PPUSH
88802: NOP4
88806: PPUSH
88807: NOP4
// end ;
88811: LD_VAR 0 6
88815: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
88816: LD_INT 0
88818: PPUSH
88819: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
88820: NOP4
88824: NOT
88825: PUSH
88826: NOP4
88830: PPUSH
88831: NOP4
88835: PPUSH
88836: NOP4
88840: NOT
88841: OR
88842: PUSH
88843: NOP4
88847: PPUSH
88848: NOP4
88852: PUSH
88853: LD_INT 3
88855: NONEQUAL
88856: PUSH
88857: NOP4
88861: PPUSH
88862: NOP4
88866: PUSH
88867: LD_INT 1
88869: EQUAL
88870: NOT
88871: AND
88872: OR
88873: IFFALSE 88877
// exit ;
88875: GO 89026
// if GetType ( factory ) = unit_human then
88877: NOP4
88881: PPUSH
88882: NOP4
88886: PUSH
88887: LD_INT 1
88889: EQUAL
88890: IFFALSE 88907
// factory := IsInUnit ( factory ) ;
88892: NOP4
88896: PUSH
88897: NOP4
88901: PPUSH
88902: NOP4
88906: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
88907: NOP4
88911: PPUSH
88912: NOP4
88916: PUSH
88917: LD_INT 3
88919: NONEQUAL
88920: IFFALSE 88924
// exit ;
88922: GO 89026
// if HexInfo ( x , y ) = factory then
88924: NOP4
88928: PPUSH
88929: NOP4
88933: PPUSH
88934: NOP4
88938: PUSH
88939: NOP4
88943: EQUAL
88944: IFFALSE 88971
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
88946: NOP4
88950: PUSH
88951: NOP4
88955: PPUSH
88956: NOP4
88960: PPUSH
88961: LD_INT 0
88963: PPUSH
88964: NOP4
88968: ST_TO_ADDR
88969: GO 89022
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
88971: NOP4
88975: PUSH
88976: NOP4
88980: PPUSH
88981: NOP4
88985: PPUSH
88986: NOP4
88990: PPUSH
88991: NOP4
88995: PUSH
88996: NOP4
89000: PUSH
89001: NOP4
89005: PUSH
89006: NOP4
89010: PUSH
89011: EMPTY
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: PPUSH
89017: NOP4
89021: ST_TO_ADDR
// UpdateFactoryWaypoints ;
89022: NOP4
// end ;
89026: LD_VAR 0 4
89030: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
89031: LD_INT 0
89033: PPUSH
89034: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
89035: LD_STRING resetFactoryWaypoint();
89037: PPUSH
89038: NOP4
// if factoryWaypoints then
89042: NOP4
89046: IFFALSE 89169
// begin for i := 1 to factoryWaypoints do
89048: NOP4
89052: PUSH
89053: DOUBLE
89054: LD_INT 1
89056: DEC
89057: ST_TO_ADDR
89058: NOP4
89062: PUSH
89063: FOR_TO
89064: IFFALSE 89167
// if factoryWaypoints [ i ] then
89066: NOP4
89070: PUSH
89071: NOP4
89075: ARRAY
89076: IFFALSE 89165
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
89078: LD_STRING setFactoryWaypointXY(
89080: PUSH
89081: NOP4
89085: PUSH
89086: NOP4
89090: ARRAY
89091: PUSH
89092: LD_INT 1
89094: ARRAY
89095: STR
89096: PUSH
89097: LD_STRING ,
89099: STR
89100: PUSH
89101: NOP4
89105: PUSH
89106: NOP4
89110: ARRAY
89111: PUSH
89112: LD_INT 2
89114: ARRAY
89115: STR
89116: PUSH
89117: LD_STRING ,
89119: STR
89120: PUSH
89121: NOP4
89125: PUSH
89126: NOP4
89130: ARRAY
89131: PUSH
89132: LD_INT 3
89134: ARRAY
89135: STR
89136: PUSH
89137: LD_STRING ,
89139: STR
89140: PUSH
89141: NOP4
89145: PUSH
89146: NOP4
89150: ARRAY
89151: PUSH
89152: LD_INT 4
89154: ARRAY
89155: STR
89156: PUSH
89157: LD_STRING )
89159: STR
89160: PPUSH
89161: NOP4
89165: GO 89063
89167: POP
89168: POP
// end ; end ;
89169: LD_VAR 0 1
89173: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
89174: LD_INT 0
89176: PPUSH
89177: PPUSH
89178: PPUSH
89179: PPUSH
89180: PPUSH
89181: PPUSH
89182: PPUSH
89183: PPUSH
89184: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
89185: NOP4
89189: NOT
89190: PUSH
89191: NOP4
89195: PPUSH
89196: NOP4
89200: PPUSH
89201: NOP4
89205: NOT
89206: OR
89207: PUSH
89208: NOP4
89212: NOT
89213: OR
89214: IFFALSE 89218
// exit ;
89216: GO 89558
// list := [ ] ;
89218: NOP4
89222: PUSH
89223: EMPTY
89224: ST_TO_ADDR
// if x - r < 0 then
89225: NOP4
89229: PUSH
89230: NOP4
89234: MINUS
89235: PUSH
89236: LD_INT 0
89238: LESS
89239: IFFALSE 89251
// min_x := 0 else
89241: NOP4
89245: PUSH
89246: LD_INT 0
89248: ST_TO_ADDR
89249: GO 89267
// min_x := x - r ;
89251: NOP4
89255: PUSH
89256: NOP4
89260: PUSH
89261: NOP4
89265: MINUS
89266: ST_TO_ADDR
// if y - r < 0 then
89267: NOP4
89271: PUSH
89272: NOP4
89276: MINUS
89277: PUSH
89278: LD_INT 0
89280: LESS
89281: IFFALSE 89293
// min_y := 0 else
89283: NOP4
89287: PUSH
89288: LD_INT 0
89290: ST_TO_ADDR
89291: GO 89309
// min_y := y - r ;
89293: NOP4
89297: PUSH
89298: NOP4
89302: PUSH
89303: NOP4
89307: MINUS
89308: ST_TO_ADDR
// max_x := x + r ;
89309: NOP4
89313: PUSH
89314: NOP4
89318: PUSH
89319: NOP4
89323: PLUS
89324: ST_TO_ADDR
// max_y := y + r ;
89325: NOP4
89329: PUSH
89330: NOP4
89334: PUSH
89335: NOP4
89339: PLUS
89340: ST_TO_ADDR
// for _x = min_x to max_x do
89341: NOP4
89345: PUSH
89346: DOUBLE
89347: NOP4
89351: DEC
89352: ST_TO_ADDR
89353: NOP4
89357: PUSH
89358: FOR_TO
89359: IFFALSE 89476
// for _y = min_y to max_y do
89361: NOP4
89365: PUSH
89366: DOUBLE
89367: NOP4
89371: DEC
89372: ST_TO_ADDR
89373: NOP4
89377: PUSH
89378: FOR_TO
89379: IFFALSE 89472
// begin if not ValidHex ( _x , _y ) then
89381: NOP4
89385: PPUSH
89386: NOP4
89390: PPUSH
89391: NOP4
89395: NOT
89396: IFFALSE 89400
// continue ;
89398: GO 89378
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
89400: NOP4
89404: PPUSH
89405: NOP4
89409: PPUSH
89410: NOP4
89414: PUSH
89415: NOP4
89419: PPUSH
89420: NOP4
89424: PPUSH
89425: NOP4
89429: AND
89430: IFFALSE 89470
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
89432: NOP4
89436: PUSH
89437: NOP4
89441: PPUSH
89442: NOP4
89446: PUSH
89447: LD_INT 1
89449: PLUS
89450: PPUSH
89451: NOP4
89455: PUSH
89456: NOP4
89460: PUSH
89461: EMPTY
89462: LIST
89463: LIST
89464: PPUSH
89465: NOP4
89469: ST_TO_ADDR
// end ;
89470: GO 89378
89472: POP
89473: POP
89474: GO 89358
89476: POP
89477: POP
// if not list then
89478: NOP4
89482: NOT
89483: IFFALSE 89487
// exit ;
89485: GO 89558
// for i in list do
89487: NOP4
89491: PUSH
89492: NOP4
89496: PUSH
89497: FOR_IN
89498: IFFALSE 89556
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
89500: NOP4
89504: PPUSH
89505: LD_STRING M
89507: PUSH
89508: NOP4
89512: PUSH
89513: LD_INT 1
89515: ARRAY
89516: PUSH
89517: NOP4
89521: PUSH
89522: LD_INT 2
89524: ARRAY
89525: PUSH
89526: LD_INT 0
89528: PUSH
89529: LD_INT 0
89531: PUSH
89532: LD_INT 0
89534: PUSH
89535: LD_INT 0
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: LIST
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: PUSH
89547: EMPTY
89548: LIST
89549: PPUSH
89550: NOP4
89554: GO 89497
89556: POP
89557: POP
// end ;
89558: LD_VAR 0 5
89562: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
89563: NOP4
89567: NOT
89568: IFFALSE 89618
89570: GO 89572
89572: DISABLE
// begin initHack := true ;
89573: NOP4
89577: PUSH
89578: LD_INT 1
89580: ST_TO_ADDR
// hackTanks := [ ] ;
89581: NOP4
89585: PUSH
89586: EMPTY
89587: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
89588: NOP4
89592: PUSH
89593: EMPTY
89594: ST_TO_ADDR
// hackLimit := 3 ;
89595: NOP4
89599: PUSH
89600: LD_INT 3
89602: ST_TO_ADDR
// hackDist := 12 ;
89603: NOP4
89607: PUSH
89608: LD_INT 12
89610: ST_TO_ADDR
// hackCounter := [ ] ;
89611: NOP4
89615: PUSH
89616: EMPTY
89617: ST_TO_ADDR
// end ;
89618: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
89619: NOP4
89623: PUSH
89624: LD_INT 34
89626: PUSH
89627: NOP4
89631: PUSH
89632: EMPTY
89633: LIST
89634: LIST
89635: PPUSH
89636: NOP4
89640: AND
89641: IFFALSE 89896
89643: GO 89645
89645: DISABLE
89646: LD_INT 0
89648: PPUSH
89649: PPUSH
// begin enable ;
89650: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
89651: NOP4
89655: PUSH
89656: LD_INT 34
89658: PUSH
89659: NOP4
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: PPUSH
89668: NOP4
89672: PUSH
89673: FOR_IN
89674: IFFALSE 89894
// begin if not i in hackTanks then
89676: NOP4
89680: PUSH
89681: NOP4
89685: IN
89686: NOT
89687: IFFALSE 89770
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
89689: NOP4
89693: PUSH
89694: NOP4
89698: PPUSH
89699: NOP4
89703: PUSH
89704: LD_INT 1
89706: PLUS
89707: PPUSH
89708: NOP4
89712: PPUSH
89713: NOP4
89717: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
89718: NOP4
89722: PUSH
89723: NOP4
89727: PPUSH
89728: NOP4
89732: PUSH
89733: LD_INT 1
89735: PLUS
89736: PPUSH
89737: EMPTY
89738: PPUSH
89739: NOP4
89743: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
89744: NOP4
89748: PUSH
89749: NOP4
89753: PPUSH
89754: NOP4
89758: PUSH
89759: LD_INT 1
89761: PLUS
89762: PPUSH
89763: EMPTY
89764: PPUSH
89765: NOP4
89769: ST_TO_ADDR
// end ; if not IsOk ( i ) then
89770: NOP4
89774: PPUSH
89775: NOP4
89779: NOT
89780: IFFALSE 89793
// begin HackUnlinkAll ( i ) ;
89782: NOP4
89786: PPUSH
89787: NOP4
// continue ;
89791: GO 89673
// end ; HackCheckCapturedStatus ( i ) ;
89793: NOP4
89797: PPUSH
89798: NOP4
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
89802: NOP4
89806: PUSH
89807: LD_INT 81
89809: PUSH
89810: NOP4
89814: PPUSH
89815: NOP4
89819: PUSH
89820: EMPTY
89821: LIST
89822: LIST
89823: PUSH
89824: LD_INT 33
89826: PUSH
89827: LD_INT 3
89829: PUSH
89830: EMPTY
89831: LIST
89832: LIST
89833: PUSH
89834: LD_INT 91
89836: PUSH
89837: NOP4
89841: PUSH
89842: NOP4
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 50
89854: PUSH
89855: EMPTY
89856: LIST
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: PPUSH
89864: NOP4
89868: ST_TO_ADDR
// if not tmp then
89869: NOP4
89873: NOT
89874: IFFALSE 89878
// continue ;
89876: GO 89673
// HackLink ( i , tmp ) ;
89878: NOP4
89882: PPUSH
89883: NOP4
89887: PPUSH
89888: NOP4
// end ;
89892: GO 89673
89894: POP
89895: POP
// end ;
89896: PPOPN 2
89898: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
89899: LD_INT 0
89901: PPUSH
89902: PPUSH
89903: PPUSH
// if not hack in hackTanks then
89904: NOP4
89908: PUSH
89909: NOP4
89913: IN
89914: NOT
89915: IFFALSE 89919
// exit ;
89917: GO 90030
// index := GetElementIndex ( hackTanks , hack ) ;
89919: NOP4
89923: PUSH
89924: NOP4
89928: PPUSH
89929: NOP4
89933: PPUSH
89934: NOP4
89938: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
89939: NOP4
89943: PUSH
89944: NOP4
89948: ARRAY
89949: IFFALSE 90030
// begin for i in hackTanksCaptured [ index ] do
89951: NOP4
89955: PUSH
89956: NOP4
89960: PUSH
89961: NOP4
89965: ARRAY
89966: PUSH
89967: FOR_IN
89968: IFFALSE 89994
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
89970: NOP4
89974: PUSH
89975: LD_INT 1
89977: ARRAY
89978: PPUSH
89979: NOP4
89983: PUSH
89984: LD_INT 2
89986: ARRAY
89987: PPUSH
89988: NOP4
89992: GO 89967
89994: POP
89995: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
89996: NOP4
90000: PUSH
90001: NOP4
90005: PPUSH
90006: NOP4
90010: PPUSH
90011: EMPTY
90012: PPUSH
90013: NOP4
90017: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90018: NOP4
90022: PPUSH
90023: LD_INT 0
90025: PPUSH
90026: NOP4
// end ; end ;
90030: LD_VAR 0 2
90034: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90035: LD_INT 0
90037: PPUSH
90038: PPUSH
90039: PPUSH
// if not hack in hackTanks or not vehicles then
90040: NOP4
90044: PUSH
90045: NOP4
90049: IN
90050: NOT
90051: PUSH
90052: NOP4
90056: NOT
90057: OR
90058: IFFALSE 90062
// exit ;
90060: GO 90337
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90062: NOP4
90066: PUSH
90067: NOP4
90071: PPUSH
90072: NOP4
90076: PPUSH
90077: LD_INT 1
90079: PPUSH
90080: LD_INT 1
90082: PPUSH
90083: NOP4
90087: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90088: NOP4
90092: PUSH
90093: NOP4
90097: PPUSH
90098: NOP4
90102: PPUSH
90103: NOP4
90107: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90108: NOP4
90112: PUSH
90113: NOP4
90117: ARRAY
90118: PUSH
90119: NOP4
90123: LESS
90124: IFFALSE 90313
// begin for i := 1 to vehicles do
90126: NOP4
90130: PUSH
90131: DOUBLE
90132: LD_INT 1
90134: DEC
90135: ST_TO_ADDR
90136: NOP4
90140: PUSH
90141: FOR_TO
90142: IFFALSE 90311
// begin if hackTanksCaptured [ index ] = hackLimit then
90144: NOP4
90148: PUSH
90149: NOP4
90153: ARRAY
90154: PUSH
90155: NOP4
90159: EQUAL
90160: IFFALSE 90164
// break ;
90162: GO 90311
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
90164: NOP4
90168: PUSH
90169: NOP4
90173: PPUSH
90174: NOP4
90178: PPUSH
90179: NOP4
90183: PUSH
90184: NOP4
90188: ARRAY
90189: PUSH
90190: LD_INT 1
90192: PLUS
90193: PPUSH
90194: NOP4
90198: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
90199: NOP4
90203: PUSH
90204: NOP4
90208: PPUSH
90209: NOP4
90213: PUSH
90214: NOP4
90218: PUSH
90219: NOP4
90223: ARRAY
90224: PUSH
90225: LD_INT 1
90227: PLUS
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PPUSH
90233: NOP4
90237: PUSH
90238: NOP4
90242: ARRAY
90243: PUSH
90244: NOP4
90248: PUSH
90249: NOP4
90253: ARRAY
90254: PPUSH
90255: NOP4
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PPUSH
90264: NOP4
90268: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
90269: NOP4
90273: PUSH
90274: NOP4
90278: ARRAY
90279: PPUSH
90280: NOP4
90284: PPUSH
90285: NOP4
90289: PPUSH
90290: NOP4
// ComStop ( vehicles [ i ] ) ;
90294: NOP4
90298: PUSH
90299: NOP4
90303: ARRAY
90304: PPUSH
90305: NOP4
// end ;
90309: GO 90141
90311: POP
90312: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
90313: NOP4
90317: PPUSH
90318: NOP4
90322: PUSH
90323: NOP4
90327: ARRAY
90328: PUSH
90329: LD_INT 0
90331: PLUS
90332: PPUSH
90333: NOP4
// end ;
90337: LD_VAR 0 3
90341: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
90342: LD_INT 0
90344: PPUSH
90345: PPUSH
90346: PPUSH
90347: PPUSH
// if not hack in hackTanks then
90348: NOP4
90352: PUSH
90353: NOP4
90357: IN
90358: NOT
90359: IFFALSE 90363
// exit ;
90361: GO 90603
// index := GetElementIndex ( hackTanks , hack ) ;
90363: NOP4
90367: PUSH
90368: NOP4
90372: PPUSH
90373: NOP4
90377: PPUSH
90378: NOP4
90382: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
90383: NOP4
90387: PUSH
90388: DOUBLE
90389: NOP4
90393: PUSH
90394: NOP4
90398: ARRAY
90399: INC
90400: ST_TO_ADDR
90401: LD_INT 1
90403: PUSH
90404: FOR_DOWNTO
90405: IFFALSE 90577
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
90407: NOP4
90411: PUSH
90412: NOP4
90416: PUSH
90417: NOP4
90421: ARRAY
90422: PUSH
90423: NOP4
90427: ARRAY
90428: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
90429: NOP4
90433: PUSH
90434: LD_INT 1
90436: ARRAY
90437: PPUSH
90438: NOP4
90442: NOT
90443: PUSH
90444: NOP4
90448: PUSH
90449: LD_INT 1
90451: ARRAY
90452: PPUSH
90453: NOP4
90457: PUSH
90458: NOP4
90462: PPUSH
90463: NOP4
90467: NONEQUAL
90468: OR
90469: IFFALSE 90575
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
90471: NOP4
90475: PUSH
90476: LD_INT 1
90478: ARRAY
90479: PPUSH
90480: NOP4
90484: PUSH
90485: NOP4
90489: PUSH
90490: LD_INT 1
90492: ARRAY
90493: PPUSH
90494: NOP4
90498: PUSH
90499: NOP4
90503: PPUSH
90504: NOP4
90508: EQUAL
90509: AND
90510: IFFALSE 90534
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
90512: NOP4
90516: PUSH
90517: LD_INT 1
90519: ARRAY
90520: PPUSH
90521: NOP4
90525: PUSH
90526: LD_INT 2
90528: ARRAY
90529: PPUSH
90530: NOP4
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
90534: NOP4
90538: PUSH
90539: NOP4
90543: PPUSH
90544: NOP4
90548: PPUSH
90549: NOP4
90553: PUSH
90554: NOP4
90558: ARRAY
90559: PPUSH
90560: NOP4
90564: PPUSH
90565: NOP4
90569: PPUSH
90570: NOP4
90574: ST_TO_ADDR
// end ; end ;
90575: GO 90404
90577: POP
90578: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
90579: NOP4
90583: PPUSH
90584: NOP4
90588: PUSH
90589: NOP4
90593: ARRAY
90594: PUSH
90595: LD_INT 0
90597: PLUS
90598: PPUSH
90599: NOP4
// end ;
90603: LD_VAR 0 2
90607: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
90608: LD_INT 0
90610: PPUSH
90611: PPUSH
90612: PPUSH
90613: PPUSH
// if not hack in hackTanks then
90614: NOP4
90618: PUSH
90619: NOP4
90623: IN
90624: NOT
90625: IFFALSE 90629
// exit ;
90627: GO 90714
// index := GetElementIndex ( hackTanks , hack ) ;
90629: NOP4
90633: PUSH
90634: NOP4
90638: PPUSH
90639: NOP4
90643: PPUSH
90644: NOP4
90648: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
90649: NOP4
90653: PUSH
90654: DOUBLE
90655: LD_INT 1
90657: DEC
90658: ST_TO_ADDR
90659: NOP4
90663: PUSH
90664: NOP4
90668: ARRAY
90669: PUSH
90670: FOR_TO
90671: IFFALSE 90712
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
90673: NOP4
90677: PUSH
90678: NOP4
90682: ARRAY
90683: PUSH
90684: NOP4
90688: ARRAY
90689: PUSH
90690: LD_INT 1
90692: ARRAY
90693: PUSH
90694: NOP4
90698: EQUAL
90699: IFFALSE 90710
// KillUnit ( vehicle ) ;
90701: NOP4
90705: PPUSH
90706: NOP4
90710: GO 90670
90712: POP
90713: POP
// end ;
90714: LD_VAR 0 3
90718: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
90719: NOP4
90723: NOT
90724: IFFALSE 90759
90726: GO 90728
90728: DISABLE
// begin initMiner := true ;
90729: NOP4
90733: PUSH
90734: LD_INT 1
90736: ST_TO_ADDR
// minersList := [ ] ;
90737: NOP4
90741: PUSH
90742: EMPTY
90743: ST_TO_ADDR
// minerMinesList := [ ] ;
90744: NOP4
90748: PUSH
90749: EMPTY
90750: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
90751: NOP4
90755: PUSH
90756: LD_INT 5
90758: ST_TO_ADDR
// end ;
90759: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
90760: NOP4
90764: PUSH
90765: LD_INT 34
90767: PUSH
90768: NOP4
90772: PUSH
90773: EMPTY
90774: LIST
90775: LIST
90776: PPUSH
90777: NOP4
90781: AND
90782: IFFALSE 91245
90784: GO 90786
90786: DISABLE
90787: LD_INT 0
90789: PPUSH
90790: PPUSH
90791: PPUSH
90792: PPUSH
// begin enable ;
90793: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
90794: NOP4
90798: PUSH
90799: LD_INT 34
90801: PUSH
90802: NOP4
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: PPUSH
90811: NOP4
90815: PUSH
90816: FOR_IN
90817: IFFALSE 90889
// begin if not i in minersList then
90819: NOP4
90823: PUSH
90824: NOP4
90828: IN
90829: NOT
90830: IFFALSE 90887
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
90832: NOP4
90836: PUSH
90837: NOP4
90841: PPUSH
90842: NOP4
90846: PUSH
90847: LD_INT 1
90849: PLUS
90850: PPUSH
90851: NOP4
90855: PPUSH
90856: NOP4
90860: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
90861: NOP4
90865: PUSH
90866: NOP4
90870: PPUSH
90871: NOP4
90875: PUSH
90876: LD_INT 1
90878: PLUS
90879: PPUSH
90880: EMPTY
90881: PPUSH
90882: NOP4
90886: ST_TO_ADDR
// end end ;
90887: GO 90816
90889: POP
90890: POP
// for i := minerMinesList downto 1 do
90891: NOP4
90895: PUSH
90896: DOUBLE
90897: NOP4
90901: INC
90902: ST_TO_ADDR
90903: LD_INT 1
90905: PUSH
90906: FOR_DOWNTO
90907: IFFALSE 91243
// begin if IsLive ( minersList [ i ] ) then
90909: NOP4
90913: PUSH
90914: NOP4
90918: ARRAY
90919: PPUSH
90920: NOP4
90924: IFFALSE 90952
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
90926: NOP4
90930: PUSH
90931: NOP4
90935: ARRAY
90936: PPUSH
90937: NOP4
90941: PUSH
90942: NOP4
90946: ARRAY
90947: PPUSH
90948: NOP4
// if not minerMinesList [ i ] then
90952: NOP4
90956: PUSH
90957: NOP4
90961: ARRAY
90962: NOT
90963: IFFALSE 90967
// continue ;
90965: GO 90906
// for j := minerMinesList [ i ] downto 1 do
90967: NOP4
90971: PUSH
90972: DOUBLE
90973: NOP4
90977: PUSH
90978: NOP4
90982: ARRAY
90983: INC
90984: ST_TO_ADDR
90985: LD_INT 1
90987: PUSH
90988: FOR_DOWNTO
90989: IFFALSE 91239
// begin side := GetSide ( minersList [ i ] ) ;
90991: NOP4
90995: PUSH
90996: NOP4
91000: PUSH
91001: NOP4
91005: ARRAY
91006: PPUSH
91007: NOP4
91011: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91012: NOP4
91016: PUSH
91017: NOP4
91021: PUSH
91022: NOP4
91026: ARRAY
91027: PUSH
91028: NOP4
91032: ARRAY
91033: PUSH
91034: LD_INT 1
91036: ARRAY
91037: PPUSH
91038: NOP4
91042: PUSH
91043: NOP4
91047: ARRAY
91048: PUSH
91049: NOP4
91053: ARRAY
91054: PUSH
91055: LD_INT 2
91057: ARRAY
91058: PPUSH
91059: NOP4
91063: ST_TO_ADDR
// if not tmp then
91064: NOP4
91068: NOT
91069: IFFALSE 91073
// continue ;
91071: GO 90988
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91073: NOP4
91077: PUSH
91078: LD_INT 81
91080: PUSH
91081: NOP4
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: PPUSH
91090: NOP4
91094: IN
91095: PUSH
91096: NOP4
91100: PUSH
91101: NOP4
91105: ARRAY
91106: PUSH
91107: NOP4
91111: ARRAY
91112: PUSH
91113: LD_INT 1
91115: ARRAY
91116: PPUSH
91117: NOP4
91121: PUSH
91122: NOP4
91126: ARRAY
91127: PUSH
91128: NOP4
91132: ARRAY
91133: PUSH
91134: LD_INT 2
91136: ARRAY
91137: PPUSH
91138: NOP4
91142: AND
91143: IFFALSE 91237
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91145: NOP4
91149: PUSH
91150: NOP4
91154: ARRAY
91155: PUSH
91156: NOP4
91160: ARRAY
91161: PUSH
91162: LD_INT 1
91164: ARRAY
91165: PPUSH
91166: NOP4
91170: PUSH
91171: NOP4
91175: ARRAY
91176: PUSH
91177: NOP4
91181: ARRAY
91182: PUSH
91183: LD_INT 2
91185: ARRAY
91186: PPUSH
91187: NOP4
91191: PPUSH
91192: NOP4
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
91196: NOP4
91200: PUSH
91201: NOP4
91205: PPUSH
91206: NOP4
91210: PPUSH
91211: NOP4
91215: PUSH
91216: NOP4
91220: ARRAY
91221: PPUSH
91222: NOP4
91226: PPUSH
91227: NOP4
91231: PPUSH
91232: NOP4
91236: ST_TO_ADDR
// end ; end ;
91237: GO 90988
91239: POP
91240: POP
// end ;
91241: GO 90906
91243: POP
91244: POP
// end ;
91245: PPOPN 4
91247: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
91248: LD_INT 0
91250: PPUSH
91251: PPUSH
// result := false ;
91252: NOP4
91256: PUSH
91257: LD_INT 0
91259: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
91260: NOP4
91264: PPUSH
91265: NOP4
91269: PUSH
91270: NOP4
91274: EQUAL
91275: NOT
91276: IFFALSE 91280
// exit ;
91278: GO 91520
// index := GetElementIndex ( minersList , unit ) ;
91280: NOP4
91284: PUSH
91285: NOP4
91289: PPUSH
91290: NOP4
91294: PPUSH
91295: NOP4
91299: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
91300: NOP4
91304: PUSH
91305: NOP4
91309: ARRAY
91310: PUSH
91311: NOP4
91315: GREATEREQUAL
91316: IFFALSE 91320
// exit ;
91318: GO 91520
// ComMoveXY ( unit , x , y ) ;
91320: NOP4
91324: PPUSH
91325: NOP4
91329: PPUSH
91330: NOP4
91334: PPUSH
91335: NOP4
// repeat wait ( 0 0$1 ) ;
91339: LD_INT 35
91341: PPUSH
91342: NOP4
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
91346: NOP4
91350: PPUSH
91351: NOP4
91355: PPUSH
91356: NOP4
91360: PPUSH
91361: NOP4
91365: NOT
91366: PUSH
91367: NOP4
91371: PPUSH
91372: NOP4
91376: AND
91377: IFFALSE 91381
// exit ;
91379: GO 91520
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
91381: NOP4
91385: PPUSH
91386: NOP4
91390: PPUSH
91391: NOP4
91395: PUSH
91396: NOP4
91400: EQUAL
91401: PUSH
91402: NOP4
91406: PPUSH
91407: NOP4
91411: NOT
91412: AND
91413: IFFALSE 91339
// PlaySoundXY ( x , y , PlantMine ) ;
91415: NOP4
91419: PPUSH
91420: NOP4
91424: PPUSH
91425: LD_STRING PlantMine
91427: PPUSH
91428: NOP4
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
91432: NOP4
91436: PPUSH
91437: NOP4
91441: PPUSH
91442: NOP4
91446: PPUSH
91447: NOP4
91451: PPUSH
91452: LD_INT 0
91454: PPUSH
91455: NOP4
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
91459: NOP4
91463: PUSH
91464: NOP4
91468: PPUSH
91469: NOP4
91473: PUSH
91474: NOP4
91478: PUSH
91479: NOP4
91483: ARRAY
91484: PUSH
91485: LD_INT 1
91487: PLUS
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PPUSH
91493: NOP4
91497: PUSH
91498: NOP4
91502: PUSH
91503: EMPTY
91504: LIST
91505: LIST
91506: PPUSH
91507: NOP4
91511: ST_TO_ADDR
// result := true ;
91512: NOP4
91516: PUSH
91517: LD_INT 1
91519: ST_TO_ADDR
// end ;
91520: LD_VAR 0 4
91524: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
91525: LD_INT 0
91527: PPUSH
91528: PPUSH
91529: PPUSH
// if not unit in minersList then
91530: NOP4
91534: PUSH
91535: NOP4
91539: IN
91540: NOT
91541: IFFALSE 91545
// exit ;
91543: GO 91937
// index := GetElementIndex ( minersList , unit ) ;
91545: NOP4
91549: PUSH
91550: NOP4
91554: PPUSH
91555: NOP4
91559: PPUSH
91560: NOP4
91564: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
91565: NOP4
91569: PUSH
91570: DOUBLE
91571: NOP4
91575: PUSH
91576: NOP4
91580: ARRAY
91581: INC
91582: ST_TO_ADDR
91583: LD_INT 1
91585: PUSH
91586: FOR_DOWNTO
91587: IFFALSE 91748
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
91589: NOP4
91593: PUSH
91594: NOP4
91598: ARRAY
91599: PUSH
91600: NOP4
91604: ARRAY
91605: PUSH
91606: LD_INT 1
91608: ARRAY
91609: PUSH
91610: NOP4
91614: EQUAL
91615: PUSH
91616: NOP4
91620: PUSH
91621: NOP4
91625: ARRAY
91626: PUSH
91627: NOP4
91631: ARRAY
91632: PUSH
91633: LD_INT 2
91635: ARRAY
91636: PUSH
91637: NOP4
91641: EQUAL
91642: AND
91643: IFFALSE 91746
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
91645: NOP4
91649: PUSH
91650: NOP4
91654: ARRAY
91655: PUSH
91656: NOP4
91660: ARRAY
91661: PUSH
91662: LD_INT 1
91664: ARRAY
91665: PPUSH
91666: NOP4
91670: PUSH
91671: NOP4
91675: ARRAY
91676: PUSH
91677: NOP4
91681: ARRAY
91682: PUSH
91683: LD_INT 2
91685: ARRAY
91686: PPUSH
91687: NOP4
91691: PPUSH
91692: NOP4
91696: PPUSH
91697: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
91701: NOP4
91705: PUSH
91706: NOP4
91710: PPUSH
91711: NOP4
91715: PPUSH
91716: NOP4
91720: PUSH
91721: NOP4
91725: ARRAY
91726: PPUSH
91727: NOP4
91731: PPUSH
91732: NOP4
91736: PPUSH
91737: NOP4
91741: ST_TO_ADDR
// exit ;
91742: POP
91743: POP
91744: GO 91937
// end ; end ;
91746: GO 91586
91748: POP
91749: POP
// for i := minerMinesList [ index ] downto 1 do
91750: NOP4
91754: PUSH
91755: DOUBLE
91756: NOP4
91760: PUSH
91761: NOP4
91765: ARRAY
91766: INC
91767: ST_TO_ADDR
91768: LD_INT 1
91770: PUSH
91771: FOR_DOWNTO
91772: IFFALSE 91935
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
91774: NOP4
91778: PUSH
91779: NOP4
91783: ARRAY
91784: PUSH
91785: NOP4
91789: ARRAY
91790: PUSH
91791: LD_INT 1
91793: ARRAY
91794: PPUSH
91795: NOP4
91799: PUSH
91800: NOP4
91804: ARRAY
91805: PUSH
91806: NOP4
91810: ARRAY
91811: PUSH
91812: LD_INT 2
91814: ARRAY
91815: PPUSH
91816: NOP4
91820: PPUSH
91821: NOP4
91825: PPUSH
91826: NOP4
91830: PUSH
91831: LD_INT 6
91833: LESS
91834: IFFALSE 91933
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
91836: NOP4
91840: PUSH
91841: NOP4
91845: ARRAY
91846: PUSH
91847: NOP4
91851: ARRAY
91852: PUSH
91853: LD_INT 1
91855: ARRAY
91856: PPUSH
91857: NOP4
91861: PUSH
91862: NOP4
91866: ARRAY
91867: PUSH
91868: NOP4
91872: ARRAY
91873: PUSH
91874: LD_INT 2
91876: ARRAY
91877: PPUSH
91878: NOP4
91882: PPUSH
91883: NOP4
91887: PPUSH
91888: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
91892: NOP4
91896: PUSH
91897: NOP4
91901: PPUSH
91902: NOP4
91906: PPUSH
91907: NOP4
91911: PUSH
91912: NOP4
91916: ARRAY
91917: PPUSH
91918: NOP4
91922: PPUSH
91923: NOP4
91927: PPUSH
91928: NOP4
91932: ST_TO_ADDR
// end ; end ;
91933: GO 91771
91935: POP
91936: POP
// end ;
91937: LD_VAR 0 4
91941: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
91942: LD_INT 0
91944: PPUSH
91945: PPUSH
91946: PPUSH
91947: PPUSH
91948: PPUSH
91949: PPUSH
91950: PPUSH
91951: PPUSH
91952: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
91953: NOP4
91957: PPUSH
91958: NOP4
91962: PUSH
91963: NOP4
91967: EQUAL
91968: NOT
91969: PUSH
91970: NOP4
91974: PUSH
91975: NOP4
91979: IN
91980: NOT
91981: OR
91982: IFFALSE 91986
// exit ;
91984: GO 92308
// index := GetElementIndex ( minersList , unit ) ;
91986: NOP4
91990: PUSH
91991: NOP4
91995: PPUSH
91996: NOP4
92000: PPUSH
92001: NOP4
92005: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92006: NOP4
92010: PUSH
92011: NOP4
92015: PUSH
92016: NOP4
92020: PUSH
92021: NOP4
92025: ARRAY
92026: MINUS
92027: ST_TO_ADDR
// if not minesFreeAmount then
92028: NOP4
92032: NOT
92033: IFFALSE 92037
// exit ;
92035: GO 92308
// tmp := [ ] ;
92037: NOP4
92041: PUSH
92042: EMPTY
92043: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92044: NOP4
92048: PUSH
92049: DOUBLE
92050: LD_INT 1
92052: DEC
92053: ST_TO_ADDR
92054: NOP4
92058: PUSH
92059: FOR_TO
92060: IFFALSE 92255
// begin _d := rand ( 0 , 5 ) ;
92062: NOP4
92066: PUSH
92067: LD_INT 0
92069: PPUSH
92070: LD_INT 5
92072: PPUSH
92073: NOP4
92077: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92078: NOP4
92082: PUSH
92083: LD_INT 2
92085: PPUSH
92086: LD_INT 6
92088: PPUSH
92089: NOP4
92093: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92094: NOP4
92098: PUSH
92099: NOP4
92103: PPUSH
92104: NOP4
92108: PPUSH
92109: NOP4
92113: PPUSH
92114: NOP4
92118: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92119: NOP4
92123: PUSH
92124: NOP4
92128: PPUSH
92129: NOP4
92133: PPUSH
92134: NOP4
92138: PPUSH
92139: NOP4
92143: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92144: NOP4
92148: PPUSH
92149: NOP4
92153: PPUSH
92154: NOP4
92158: PUSH
92159: NOP4
92163: PUSH
92164: NOP4
92168: PUSH
92169: EMPTY
92170: LIST
92171: LIST
92172: PUSH
92173: NOP4
92177: IN
92178: NOT
92179: AND
92180: PUSH
92181: NOP4
92185: PPUSH
92186: NOP4
92190: PPUSH
92191: NOP4
92195: NOT
92196: AND
92197: IFFALSE 92239
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
92199: NOP4
92203: PUSH
92204: NOP4
92208: PPUSH
92209: NOP4
92213: PUSH
92214: LD_INT 1
92216: PLUS
92217: PPUSH
92218: NOP4
92222: PUSH
92223: NOP4
92227: PUSH
92228: EMPTY
92229: LIST
92230: LIST
92231: PPUSH
92232: NOP4
92236: ST_TO_ADDR
92237: GO 92253
// i := i - 1 ;
92239: NOP4
92243: PUSH
92244: NOP4
92248: PUSH
92249: LD_INT 1
92251: MINUS
92252: ST_TO_ADDR
// end ;
92253: GO 92059
92255: POP
92256: POP
// for i in tmp do
92257: NOP4
92261: PUSH
92262: NOP4
92266: PUSH
92267: FOR_IN
92268: IFFALSE 92306
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
92270: NOP4
92274: PPUSH
92275: NOP4
92279: PUSH
92280: LD_INT 1
92282: ARRAY
92283: PPUSH
92284: NOP4
92288: PUSH
92289: LD_INT 2
92291: ARRAY
92292: PPUSH
92293: NOP4
92297: NOT
92298: IFFALSE 92304
// exit ;
92300: POP
92301: POP
92302: GO 92308
92304: GO 92267
92306: POP
92307: POP
// end ;
92308: LD_VAR 0 4
92312: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
92313: LD_INT 0
92315: PPUSH
92316: PPUSH
92317: PPUSH
92318: PPUSH
92319: PPUSH
92320: PPUSH
92321: PPUSH
// if not GetClass ( unit ) = class_sniper then
92322: NOP4
92326: PPUSH
92327: NOP4
92331: PUSH
92332: LD_INT 5
92334: EQUAL
92335: NOT
92336: IFFALSE 92340
// exit ;
92338: GO 92728
// dist := 8 ;
92340: NOP4
92344: PUSH
92345: LD_INT 8
92347: ST_TO_ADDR
// viewRange := 12 ;
92348: NOP4
92352: PUSH
92353: LD_INT 12
92355: ST_TO_ADDR
// side := GetSide ( unit ) ;
92356: NOP4
92360: PUSH
92361: NOP4
92365: PPUSH
92366: NOP4
92370: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
92371: LD_INT 61
92373: PPUSH
92374: NOP4
92378: PPUSH
92379: NOP4
92383: PUSH
92384: LD_INT 2
92386: EQUAL
92387: IFFALSE 92397
// viewRange := 16 ;
92389: NOP4
92393: PUSH
92394: LD_INT 16
92396: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
92397: NOP4
92401: PPUSH
92402: NOP4
92406: PPUSH
92407: NOP4
92411: PPUSH
92412: NOP4
92416: PUSH
92417: NOP4
92421: GREATER
92422: IFFALSE 92501
// begin ComMoveXY ( unit , x , y ) ;
92424: NOP4
92428: PPUSH
92429: NOP4
92433: PPUSH
92434: NOP4
92438: PPUSH
92439: NOP4
// repeat wait ( 0 0$1 ) ;
92443: LD_INT 35
92445: PPUSH
92446: NOP4
// if not UnitGoingToXY ( unit , x , y ) then
92450: NOP4
92454: PPUSH
92455: NOP4
92459: PPUSH
92460: NOP4
92464: PPUSH
92465: NOP4
92469: NOT
92470: IFFALSE 92474
// exit ;
92472: GO 92728
// until GetDistUnitXY ( unit , x , y ) < dist ;
92474: NOP4
92478: PPUSH
92479: NOP4
92483: PPUSH
92484: NOP4
92488: PPUSH
92489: NOP4
92493: PUSH
92494: NOP4
92498: LESS
92499: IFFALSE 92443
// end ; ComTurnXY ( unit , x , y ) ;
92501: NOP4
92505: PPUSH
92506: NOP4
92510: PPUSH
92511: NOP4
92515: PPUSH
92516: NOP4
// wait ( 5 ) ;
92520: LD_INT 5
92522: PPUSH
92523: NOP4
// _d := GetDir ( unit ) ;
92527: NOP4
92531: PUSH
92532: NOP4
92536: PPUSH
92537: NOP4
92541: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
92542: NOP4
92546: PUSH
92547: NOP4
92551: PPUSH
92552: NOP4
92556: PPUSH
92557: NOP4
92561: PPUSH
92562: NOP4
92566: PPUSH
92567: NOP4
92571: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
92572: NOP4
92576: PUSH
92577: NOP4
92581: PPUSH
92582: NOP4
92586: PPUSH
92587: NOP4
92591: PPUSH
92592: NOP4
92596: PPUSH
92597: NOP4
92601: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92602: NOP4
92606: PPUSH
92607: NOP4
92611: PPUSH
92612: NOP4
92616: NOT
92617: IFFALSE 92621
// exit ;
92619: GO 92728
// ComAnimCustom ( unit , 1 ) ;
92621: NOP4
92625: PPUSH
92626: LD_INT 1
92628: PPUSH
92629: NOP4
// PlaceSeeing ( _x , _y , side , viewRange ) ;
92633: NOP4
92637: PPUSH
92638: NOP4
92642: PPUSH
92643: NOP4
92647: PPUSH
92648: NOP4
92652: PPUSH
92653: NOP4
// repeat wait ( 1 ) ;
92657: LD_INT 1
92659: PPUSH
92660: NOP4
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
92664: NOP4
92668: PPUSH
92669: NOP4
92673: PUSH
92674: NOP4
92678: PPUSH
92679: NOP4
92683: OR
92684: PUSH
92685: NOP4
92689: PPUSH
92690: NOP4
92694: NOT
92695: OR
92696: PUSH
92697: NOP4
92701: PPUSH
92702: NOP4
92706: OR
92707: IFFALSE 92657
// RemoveSeeing ( _x , _y , side ) ;
92709: NOP4
92713: PPUSH
92714: NOP4
92718: PPUSH
92719: NOP4
92723: PPUSH
92724: NOP4
// end ; end_of_file
92728: LD_VAR 0 4
92732: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
92733: NOP4
92737: PUSH
92738: LD_INT 200
92740: DOUBLE
92741: GREATEREQUAL
92742: IFFALSE 92750
92744: LD_INT 299
92746: DOUBLE
92747: LESSEQUAL
92748: IFTRUE 92752
92750: GO 92784
92752: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
92753: NOP4
92757: PPUSH
92758: NOP4
92762: PPUSH
92763: NOP4
92767: PPUSH
92768: NOP4
92772: PPUSH
92773: NOP4
92777: PPUSH
92778: NOP4
92782: GO 92861
92784: LD_INT 300
92786: DOUBLE
92787: GREATEREQUAL
92788: IFFALSE 92796
92790: LD_INT 399
92792: DOUBLE
92793: LESSEQUAL
92794: IFTRUE 92798
92796: GO 92860
92798: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
92799: NOP4
92803: PPUSH
92804: NOP4
92808: PPUSH
92809: NOP4
92813: PPUSH
92814: NOP4
92818: PPUSH
92819: NOP4
92823: PPUSH
92824: NOP4
92828: PPUSH
92829: NOP4
92833: PPUSH
92834: NOP4
92838: PPUSH
92839: NOP4
92843: PPUSH
92844: NOP4
92848: PPUSH
92849: NOP4
92853: PPUSH
92854: NOP4
92858: GO 92861
92860: POP
// end ;
92861: PPOPN 11
92863: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
92864: NOP4
92868: PPUSH
92869: NOP4
92873: PPUSH
92874: NOP4
92878: PPUSH
92879: NOP4
92883: PPUSH
92884: NOP4
92888: PPUSH
92889: NOP4
// end ;
92893: PPOPN 5
92895: END
