// starting begin ResetFog ;
   0: CALL_OW 335
// InitHc ;
   4: CALL_OW 19
// InitUc ;
   8: CALL_OW 18
// InitBc ;
  12: CALL_OW 21
// InitVariables ;
  16: CALL 331 0 0
// InitMultiplayer ;
  20: CALL 592 0 0
// if debug then
  24: LD_EXP 1
  28: IFFALSE 37
// FogOff ( 1 ) ;
  30: LD_INT 1
  32: PPUSH
  33: CALL_OW 344
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  37: LD_INT 2
  39: PPUSH
  40: CALL 1868 0 1
  44: PPUSH
  45: CALL 5813 0 1
// Multiplayer_Start ;
  49: CALL 3730 0 0
// ResetFog ;
  53: CALL_OW 335
// InitMacro ;
  57: CALL 51355 0 0
// MC_Start ( ) ;
  61: CALL 53535 0 0
// game := true ;
  65: LD_ADDR_EXP 2
  69: PUSH
  70: LD_INT 1
  72: ST_TO_ADDR
// Multiplayer_End ;
  73: CALL 3846 0 0
// end ;
  77: END
// export function CustomInitMacro ; var i ; begin
  78: LD_INT 0
  80: PPUSH
  81: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
  82: LD_INT 1
  84: PPUSH
  85: LD_INT 8
  87: PUSH
  88: LD_INT 10
  90: PUSH
  91: LD_INT 12
  93: PUSH
  94: EMPTY
  95: LIST
  96: LIST
  97: LIST
  98: PUSH
  99: LD_OWVAR 67
 103: ARRAY
 104: PPUSH
 105: LD_INT 3
 107: PPUSH
 108: CALL 75252 0 3
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 112: LD_INT 2
 114: PPUSH
 115: LD_INT 6
 117: PUSH
 118: LD_INT 8
 120: PUSH
 121: LD_INT 9
 123: PUSH
 124: EMPTY
 125: LIST
 126: LIST
 127: LIST
 128: PUSH
 129: LD_OWVAR 67
 133: ARRAY
 134: PPUSH
 135: LD_INT 2
 137: PPUSH
 138: CALL 75252 0 3
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 142: LD_INT 3
 144: PPUSH
 145: LD_INT 6
 147: PUSH
 148: LD_INT 7
 150: PUSH
 151: LD_INT 9
 153: PUSH
 154: EMPTY
 155: LIST
 156: LIST
 157: LIST
 158: PUSH
 159: LD_OWVAR 67
 163: ARRAY
 164: PPUSH
 165: LD_INT 1
 167: PPUSH
 168: CALL 75252 0 3
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 172: LD_INT 4
 174: PPUSH
 175: LD_INT 6
 177: PUSH
 178: LD_INT 7
 180: PUSH
 181: LD_INT 9
 183: PUSH
 184: EMPTY
 185: LIST
 186: LIST
 187: LIST
 188: PUSH
 189: LD_OWVAR 67
 193: ARRAY
 194: PPUSH
 195: LD_INT 25
 197: PPUSH
 198: CALL 75252 0 3
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 202: LD_INT 5
 204: PPUSH
 205: LD_INT 4
 207: PUSH
 208: LD_INT 5
 210: PUSH
 211: LD_INT 6
 213: PUSH
 214: EMPTY
 215: LIST
 216: LIST
 217: LIST
 218: PUSH
 219: LD_OWVAR 67
 223: ARRAY
 224: PPUSH
 225: LD_INT 39
 227: PPUSH
 228: CALL 75252 0 3
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 232: LD_ADDR_EXP 67
 236: PUSH
 237: LD_INT 20
 239: PUSH
 240: LD_INT 21
 242: PUSH
 243: LD_INT 22
 245: PUSH
 246: LD_INT 24
 248: PUSH
 249: LD_INT 20
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: LIST
 258: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 259: LD_ADDR_EXP 68
 263: PUSH
 264: LD_INT 35
 266: PUSH
 267: LD_INT 34
 269: PUSH
 270: LD_INT 36
 272: PUSH
 273: LD_INT 33
 275: PUSH
 276: LD_INT 38
 278: PUSH
 279: EMPTY
 280: LIST
 281: LIST
 282: LIST
 283: LIST
 284: LIST
 285: ST_TO_ADDR
// for i = 1 to 4 do
 286: LD_ADDR_VAR 0 2
 290: PUSH
 291: DOUBLE
 292: LD_INT 1
 294: DEC
 295: ST_TO_ADDR
 296: LD_INT 4
 298: PUSH
 299: FOR_TO
 300: IFFALSE 324
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 302: LD_VAR 0 2
 306: PPUSH
 307: LD_EXP 38
 311: PUSH
 312: LD_VAR 0 2
 316: ARRAY
 317: PPUSH
 318: CALL 75697 0 2
 322: GO 299
 324: POP
 325: POP
// end ;
 326: LD_VAR 0 1
 330: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 331: LD_INT 0
 333: PPUSH
// debug := 1 ;
 334: LD_ADDR_EXP 1
 338: PUSH
 339: LD_INT 1
 341: ST_TO_ADDR
// side_bot := 2 ;
 342: LD_ADDR_EXP 3
 346: PUSH
 347: LD_INT 2
 349: ST_TO_ADDR
// artifact_get := false ;
 350: LD_ADDR_EXP 4
 354: PUSH
 355: LD_INT 0
 357: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 358: LD_ADDR_EXP 5
 362: PUSH
 363: LD_STRING base_a
 365: PUSH
 366: LD_STRING base_b
 368: PUSH
 369: LD_STRING base_c
 371: PUSH
 372: LD_STRING base_d
 374: PUSH
 375: LD_STRING base_e
 377: PUSH
 378: LD_STRING base_f
 380: PUSH
 381: LD_STRING base_g
 383: PUSH
 384: LD_STRING base_h
 386: PUSH
 387: LD_STRING base_i
 389: PUSH
 390: LD_STRING base_j
 392: PUSH
 393: LD_STRING base_k
 395: PUSH
 396: LD_STRING base_l
 398: PUSH
 399: LD_STRING base_m
 401: PUSH
 402: LD_STRING base_n
 404: PUSH
 405: LD_STRING base_o
 407: PUSH
 408: LD_STRING base_p
 410: PUSH
 411: LD_STRING base_r
 413: PUSH
 414: LD_STRING base_s
 416: PUSH
 417: LD_STRING base_t
 419: PUSH
 420: LD_STRING base_u
 422: PUSH
 423: LD_STRING base_w
 425: PUSH
 426: LD_STRING base_x
 428: PUSH
 429: LD_STRING base_y
 431: PUSH
 432: LD_STRING base_z
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: ST_TO_ADDR
// end ;
 461: LD_VAR 0 1
 465: RET
// every 0 0$01 trigger game and not debug_strings do
 466: LD_EXP 2
 470: PUSH
 471: LD_OWVAR 48
 475: NOT
 476: AND
 477: IFFALSE 493
 479: GO 481
 481: DISABLE
// begin enable ;
 482: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 483: LD_ADDR_OWVAR 47
 487: PUSH
 488: CALL 4547 0 0
 492: ST_TO_ADDR
// end ;
 493: END
// function Debuger ; var i ; begin
 494: LD_INT 0
 496: PPUSH
 497: PPUSH
// if not debug then
 498: LD_EXP 1
 502: NOT
 503: IFFALSE 507
// exit ;
 505: GO 579
// game_speed := 5 ;
 507: LD_ADDR_OWVAR 65
 511: PUSH
 512: LD_INT 5
 514: ST_TO_ADDR
// uc_side := 1 ;
 515: LD_ADDR_OWVAR 20
 519: PUSH
 520: LD_INT 1
 522: ST_TO_ADDR
// uc_nation := 1 ;
 523: LD_ADDR_OWVAR 21
 527: PUSH
 528: LD_INT 1
 530: ST_TO_ADDR
// for i = 1 to 10 do
 531: LD_ADDR_VAR 0 2
 535: PUSH
 536: DOUBLE
 537: LD_INT 1
 539: DEC
 540: ST_TO_ADDR
 541: LD_INT 10
 543: PUSH
 544: FOR_TO
 545: IFFALSE 577
// begin PrepareHuman ( false , 1 , 10 ) ;
 547: LD_INT 0
 549: PPUSH
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 10
 555: PPUSH
 556: CALL_OW 380
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 560: CALL_OW 44
 564: PPUSH
 565: LD_INT 9
 567: PPUSH
 568: LD_INT 0
 570: PPUSH
 571: CALL_OW 49
// end ;
 575: GO 544
 577: POP
 578: POP
// end ;
 579: LD_VAR 0 1
 583: RET
// export function CustomEvent ( event ) ; begin
 584: LD_INT 0
 586: PPUSH
// end ; end_of_file
 587: LD_VAR 0 2
 591: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 592: LD_INT 0
 594: PPUSH
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
// multi_settings_counter := 6 ;
 599: LD_ADDR_EXP 18
 603: PUSH
 604: LD_INT 6
 606: ST_TO_ADDR
// if multiplayer then
 607: LD_OWVAR 4
 611: IFFALSE 791
// begin your_side := mp_player_side ;
 613: LD_ADDR_OWVAR 2
 617: PUSH
 618: LD_OWVAR 7
 622: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 623: LD_ADDR_EXP 6
 627: PUSH
 628: LD_OWVAR 6
 632: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 633: LD_ADDR_EXP 7
 637: PUSH
 638: LD_OWVAR 17
 642: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 643: LD_ADDR_EXP 8
 647: PUSH
 648: LD_OWVAR 15
 652: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 653: LD_ADDR_EXP 9
 657: PUSH
 658: LD_OWVAR 16
 662: ST_TO_ADDR
// multi_teams := [ [ ] ] ;
 663: LD_ADDR_EXP 10
 667: PUSH
 668: EMPTY
 669: PUSH
 670: EMPTY
 671: LIST
 672: ST_TO_ADDR
// for i in mp_teams do
 673: LD_ADDR_VAR 0 2
 677: PUSH
 678: LD_OWVAR 12
 682: PUSH
 683: FOR_IN
 684: IFFALSE 727
// if i then
 686: LD_VAR 0 2
 690: IFFALSE 725
// multi_teams := Replace ( multi_teams , 1 , multi_teams [ 1 ] union i ) ;
 692: LD_ADDR_EXP 10
 696: PUSH
 697: LD_EXP 10
 701: PPUSH
 702: LD_INT 1
 704: PPUSH
 705: LD_EXP 10
 709: PUSH
 710: LD_INT 1
 712: ARRAY
 713: PUSH
 714: LD_VAR 0 2
 718: UNION
 719: PPUSH
 720: CALL_OW 1
 724: ST_TO_ADDR
 725: GO 683
 727: POP
 728: POP
// for i = 1 to multi_settings_counter do
 729: LD_ADDR_VAR 0 2
 733: PUSH
 734: DOUBLE
 735: LD_INT 1
 737: DEC
 738: ST_TO_ADDR
 739: LD_EXP 18
 743: PUSH
 744: FOR_TO
 745: IFFALSE 787
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 747: LD_ADDR_EXP 17
 751: PUSH
 752: LD_EXP 17
 756: PPUSH
 757: LD_EXP 17
 761: PUSH
 762: LD_INT 1
 764: PLUS
 765: PPUSH
 766: LD_VAR 0 2
 770: PPUSH
 771: CALL_OW 426
 775: PUSH
 776: LD_INT 1
 778: PLUS
 779: PPUSH
 780: CALL_OW 2
 784: ST_TO_ADDR
 785: GO 744
 787: POP
 788: POP
// end else
 789: GO 973
// begin your_side := 1 ;
 791: LD_ADDR_OWVAR 2
 795: PUSH
 796: LD_INT 1
 798: ST_TO_ADDR
// multi_gametype := 1 ;
 799: LD_ADDR_EXP 6
 803: PUSH
 804: LD_INT 1
 806: ST_TO_ADDR
// multi_sides := [ 2 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 807: LD_ADDR_EXP 7
 811: PUSH
 812: LD_INT 2
 814: PUSH
 815: LD_INT 1
 817: PUSH
 818: LD_INT 0
 820: PUSH
 821: LD_INT 0
 823: PUSH
 824: LD_INT 0
 826: PUSH
 827: LD_INT 0
 829: PUSH
 830: LD_INT 0
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: ST_TO_ADDR
// multi_side_teams := [ 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 846: LD_ADDR_EXP 8
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 1
 856: PUSH
 857: LD_INT 0
 859: PUSH
 860: LD_INT 0
 862: PUSH
 863: LD_INT 0
 865: PUSH
 866: LD_INT 0
 868: PUSH
 869: LD_INT 0
 871: PUSH
 872: LD_INT 0
 874: PUSH
 875: EMPTY
 876: LIST
 877: LIST
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: ST_TO_ADDR
// multi_nations := [ 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 885: LD_ADDR_EXP 9
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 1
 895: PUSH
 896: LD_INT 0
 898: PUSH
 899: LD_INT 0
 901: PUSH
 902: LD_INT 0
 904: PUSH
 905: LD_INT 0
 907: PUSH
 908: LD_INT 0
 910: PUSH
 911: LD_INT 0
 913: PUSH
 914: EMPTY
 915: LIST
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: LIST
 921: LIST
 922: LIST
 923: ST_TO_ADDR
// multi_teams := [ [ 1 , 2 ] ] ;
 924: LD_ADDR_EXP 10
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 2
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: PUSH
 939: EMPTY
 940: LIST
 941: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 942: LD_ADDR_EXP 17
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 2
 952: PUSH
 953: LD_INT 1
 955: PUSH
 956: LD_INT 3
 958: PUSH
 959: LD_INT 1
 961: PUSH
 962: LD_INT 1
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 973: LD_ADDR_EXP 11
 977: PUSH
 978: LD_INT 0
 980: PUSH
 981: LD_INT 0
 983: PUSH
 984: LD_INT 0
 986: PUSH
 987: LD_INT 0
 989: PUSH
 990: LD_INT 0
 992: PUSH
 993: LD_INT 0
 995: PUSH
 996: LD_INT 0
 998: PUSH
 999: LD_INT 0
1001: PUSH
1002: EMPTY
1003: LIST
1004: LIST
1005: LIST
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: LIST
1011: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1012: LD_ADDR_EXP 14
1016: PUSH
1017: LD_INT 0
1019: PUSH
1020: LD_INT 0
1022: PUSH
1023: LD_INT 0
1025: PUSH
1026: LD_INT 0
1028: PUSH
1029: LD_INT 0
1031: PUSH
1032: LD_INT 0
1034: PUSH
1035: LD_INT 0
1037: PUSH
1038: LD_INT 0
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1051: LD_ADDR_EXP 25
1055: PUSH
1056: LD_INT 0
1058: PUSH
1059: LD_INT 0
1061: PUSH
1062: LD_INT 0
1064: PUSH
1065: LD_INT 0
1067: PUSH
1068: LD_INT 0
1070: PUSH
1071: LD_INT 0
1073: PUSH
1074: LD_INT 0
1076: PUSH
1077: LD_INT 0
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: ST_TO_ADDR
// multi_teamgame := true ;
1090: LD_ADDR_EXP 15
1094: PUSH
1095: LD_INT 1
1097: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1098: LD_ADDR_EXP 13
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: EMPTY
1107: LIST
1108: ST_TO_ADDR
// multi_custom_commanders := true ;
1109: LD_ADDR_EXP 16
1113: PUSH
1114: LD_INT 1
1116: ST_TO_ADDR
// multi_commanders := [ ] ;
1117: LD_ADDR_EXP 24
1121: PUSH
1122: EMPTY
1123: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1124: LD_ADDR_EXP 27
1128: PUSH
1129: EMPTY
1130: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1131: LD_ADDR_EXP 28
1135: PUSH
1136: LD_INT 0
1138: ST_TO_ADDR
// multi_players_amount := 0 ;
1139: LD_ADDR_EXP 26
1143: PUSH
1144: LD_INT 0
1146: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1147: LD_ADDR_EXP 12
1151: PUSH
1152: LD_INT 9
1154: PUSH
1155: LD_INT 8
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 27
1164: PUSH
1165: LD_INT 26
1167: PUSH
1168: EMPTY
1169: LIST
1170: LIST
1171: PUSH
1172: LD_INT 29
1174: PUSH
1175: LD_INT 28
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: LIST
1186: ST_TO_ADDR
// for i = 1 to 8 do
1187: LD_ADDR_VAR 0 2
1191: PUSH
1192: DOUBLE
1193: LD_INT 1
1195: DEC
1196: ST_TO_ADDR
1197: LD_INT 8
1199: PUSH
1200: FOR_TO
1201: IFFALSE 1530
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1203: LD_VAR 0 2
1207: PPUSH
1208: CALL_OW 530
1212: IFFALSE 1370
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1214: LD_ADDR_EXP 11
1218: PUSH
1219: LD_EXP 11
1223: PPUSH
1224: LD_VAR 0 2
1228: PPUSH
1229: LD_INT 1
1231: PPUSH
1232: CALL_OW 1
1236: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1237: LD_ADDR_EXP 9
1241: PUSH
1242: LD_EXP 9
1246: PPUSH
1247: LD_VAR 0 2
1251: PPUSH
1252: LD_INT 0
1254: PPUSH
1255: CALL_OW 1
1259: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1260: LD_ADDR_EXP 7
1264: PUSH
1265: LD_EXP 7
1269: PPUSH
1270: LD_VAR 0 2
1274: PPUSH
1275: LD_INT 0
1277: PPUSH
1278: CALL_OW 1
1282: ST_TO_ADDR
// for j = 1 to multi_teams do
1283: LD_ADDR_VAR 0 3
1287: PUSH
1288: DOUBLE
1289: LD_INT 1
1291: DEC
1292: ST_TO_ADDR
1293: LD_EXP 10
1297: PUSH
1298: FOR_TO
1299: IFFALSE 1368
// begin if i in multi_teams [ j ] then
1301: LD_VAR 0 2
1305: PUSH
1306: LD_EXP 10
1310: PUSH
1311: LD_VAR 0 3
1315: ARRAY
1316: IN
1317: IFFALSE 1366
// begin tmp := multi_teams [ j ] diff i ;
1319: LD_ADDR_VAR 0 5
1323: PUSH
1324: LD_EXP 10
1328: PUSH
1329: LD_VAR 0 3
1333: ARRAY
1334: PUSH
1335: LD_VAR 0 2
1339: DIFF
1340: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1341: LD_ADDR_EXP 10
1345: PUSH
1346: LD_EXP 10
1350: PPUSH
1351: LD_VAR 0 3
1355: PPUSH
1356: LD_VAR 0 5
1360: PPUSH
1361: CALL_OW 1
1365: ST_TO_ADDR
// end ; end ;
1366: GO 1298
1368: POP
1369: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1370: LD_EXP 9
1374: PUSH
1375: LD_VAR 0 2
1379: ARRAY
1380: PUSH
1381: LD_EXP 9
1385: PUSH
1386: LD_VAR 0 2
1390: ARRAY
1391: PUSH
1392: LD_EXP 13
1396: IN
1397: NOT
1398: AND
1399: IFFALSE 1440
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1401: LD_ADDR_EXP 9
1405: PUSH
1406: LD_EXP 9
1410: PPUSH
1411: LD_VAR 0 2
1415: PPUSH
1416: LD_EXP 13
1420: PUSH
1421: LD_INT 1
1423: PPUSH
1424: LD_EXP 13
1428: PPUSH
1429: CALL_OW 12
1433: ARRAY
1434: PPUSH
1435: CALL_OW 1
1439: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1440: LD_EXP 9
1444: PUSH
1445: LD_VAR 0 2
1449: ARRAY
1450: NOT
1451: PUSH
1452: LD_EXP 7
1456: PUSH
1457: LD_VAR 0 2
1461: ARRAY
1462: NOT
1463: AND
1464: PUSH
1465: LD_EXP 11
1469: PUSH
1470: LD_VAR 0 2
1474: ARRAY
1475: NOT
1476: AND
1477: IFFALSE 1502
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1479: LD_ADDR_EXP 14
1483: PUSH
1484: LD_EXP 14
1488: PPUSH
1489: LD_VAR 0 2
1493: PPUSH
1494: LD_INT 1
1496: PPUSH
1497: CALL_OW 1
1501: ST_TO_ADDR
// if multi_sides [ i ] then
1502: LD_EXP 7
1506: PUSH
1507: LD_VAR 0 2
1511: ARRAY
1512: IFFALSE 1528
// multi_players_amount := multi_players_amount + 1 ;
1514: LD_ADDR_EXP 26
1518: PUSH
1519: LD_EXP 26
1523: PUSH
1524: LD_INT 1
1526: PLUS
1527: ST_TO_ADDR
// end ;
1528: GO 1200
1530: POP
1531: POP
// for i in multi_teams do
1532: LD_ADDR_VAR 0 2
1536: PUSH
1537: LD_EXP 10
1541: PUSH
1542: FOR_IN
1543: IFFALSE 1651
// begin for j = 2 to i do
1545: LD_ADDR_VAR 0 3
1549: PUSH
1550: DOUBLE
1551: LD_INT 2
1553: DEC
1554: ST_TO_ADDR
1555: LD_VAR 0 2
1559: PUSH
1560: FOR_TO
1561: IFFALSE 1647
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1563: LD_VAR 0 2
1567: PUSH
1568: LD_VAR 0 3
1572: ARRAY
1573: PPUSH
1574: LD_VAR 0 2
1578: PUSH
1579: LD_INT 1
1581: ARRAY
1582: PPUSH
1583: CALL_OW 343
// for x = 1 to j - 1 do
1587: LD_ADDR_VAR 0 4
1591: PUSH
1592: DOUBLE
1593: LD_INT 1
1595: DEC
1596: ST_TO_ADDR
1597: LD_VAR 0 3
1601: PUSH
1602: LD_INT 1
1604: MINUS
1605: PUSH
1606: FOR_TO
1607: IFFALSE 1643
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1609: LD_VAR 0 2
1613: PUSH
1614: LD_VAR 0 3
1618: ARRAY
1619: PPUSH
1620: LD_VAR 0 2
1624: PUSH
1625: LD_VAR 0 4
1629: ARRAY
1630: PPUSH
1631: LD_INT 1
1633: PPUSH
1634: LD_INT 1
1636: PPUSH
1637: CALL_OW 80
1641: GO 1606
1643: POP
1644: POP
// end ;
1645: GO 1560
1647: POP
1648: POP
// end ;
1649: GO 1542
1651: POP
1652: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1653: LD_ADDR_OWVAR 67
1657: PUSH
1658: LD_INT 1
1660: PUSH
1661: LD_INT 2
1663: PUSH
1664: LD_INT 3
1666: PUSH
1667: EMPTY
1668: LIST
1669: LIST
1670: LIST
1671: PUSH
1672: LD_EXP 17
1676: PUSH
1677: LD_INT 1
1679: ARRAY
1680: ARRAY
1681: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1682: LD_ADDR_EXP 19
1686: PUSH
1687: LD_INT 9
1689: PUSH
1690: LD_INT 12
1692: PUSH
1693: LD_INT 15
1695: PUSH
1696: LD_INT 18
1698: PUSH
1699: EMPTY
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: PUSH
1705: LD_EXP 17
1709: PUSH
1710: LD_INT 2
1712: ARRAY
1713: ARRAY
1714: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1715: LD_ADDR_EXP 20
1719: PUSH
1720: LD_INT 5
1722: PUSH
1723: LD_INT 7
1725: PUSH
1726: LD_INT 9
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: PUSH
1734: LD_EXP 17
1738: PUSH
1739: LD_INT 3
1741: ARRAY
1742: ARRAY
1743: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1744: LD_ADDR_EXP 21
1748: PUSH
1749: LD_INT 6000
1751: PUSH
1752: LD_INT 1575
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: PUSH
1759: LD_INT 8000
1761: PUSH
1762: LD_INT 1260
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: PUSH
1769: LD_INT 10000
1771: PUSH
1772: LD_INT 770
1774: PUSH
1775: EMPTY
1776: LIST
1777: LIST
1778: PUSH
1779: LD_INT 15000
1781: PUSH
1782: LD_INT 770
1784: PUSH
1785: EMPTY
1786: LIST
1787: LIST
1788: PUSH
1789: EMPTY
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: PUSH
1795: LD_EXP 17
1799: PUSH
1800: LD_INT 4
1802: ARRAY
1803: ARRAY
1804: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1805: LD_ADDR_EXP 22
1809: PUSH
1810: LD_INT 6
1812: PUSH
1813: LD_INT 8
1815: PUSH
1816: LD_INT 10
1818: PUSH
1819: EMPTY
1820: LIST
1821: LIST
1822: LIST
1823: PUSH
1824: LD_EXP 17
1828: PUSH
1829: LD_INT 5
1831: ARRAY
1832: ARRAY
1833: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1834: LD_ADDR_EXP 23
1838: PUSH
1839: LD_INT 0
1841: PUSH
1842: LD_INT 1
1844: PUSH
1845: LD_INT 2
1847: PUSH
1848: EMPTY
1849: LIST
1850: LIST
1851: LIST
1852: PUSH
1853: LD_EXP 17
1857: PUSH
1858: LD_INT 6
1860: ARRAY
1861: ARRAY
1862: ST_TO_ADDR
// end ;
1863: LD_VAR 0 1
1867: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1868: LD_INT 0
1870: PPUSH
1871: PPUSH
// if not multi_sides [ 2 ] then
1872: LD_EXP 7
1876: PUSH
1877: LD_INT 2
1879: ARRAY
1880: NOT
1881: IFFALSE 1895
// begin result := preferSide ;
1883: LD_ADDR_VAR 0 2
1887: PUSH
1888: LD_VAR 0 1
1892: ST_TO_ADDR
// exit ;
1893: GO 1942
// end ; for i := 1 to 8 do
1895: LD_ADDR_VAR 0 3
1899: PUSH
1900: DOUBLE
1901: LD_INT 1
1903: DEC
1904: ST_TO_ADDR
1905: LD_INT 8
1907: PUSH
1908: FOR_TO
1909: IFFALSE 1940
// if not multi_sides [ i ] then
1911: LD_EXP 7
1915: PUSH
1916: LD_VAR 0 3
1920: ARRAY
1921: NOT
1922: IFFALSE 1938
// begin result := i ;
1924: LD_ADDR_VAR 0 2
1928: PUSH
1929: LD_VAR 0 3
1933: ST_TO_ADDR
// exit ;
1934: POP
1935: POP
1936: GO 1942
// end ;
1938: GO 1908
1940: POP
1941: POP
// end ;
1942: LD_VAR 0 2
1946: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1947: LD_INT 0
1949: PPUSH
// uc_side := side ;
1950: LD_ADDR_OWVAR 20
1954: PUSH
1955: LD_VAR 0 1
1959: ST_TO_ADDR
// uc_nation := 1 ;
1960: LD_ADDR_OWVAR 21
1964: PUSH
1965: LD_INT 1
1967: ST_TO_ADDR
// hc_importance := 100 ;
1968: LD_ADDR_OWVAR 32
1972: PUSH
1973: LD_INT 100
1975: ST_TO_ADDR
// hc_class := 1 ;
1976: LD_ADDR_OWVAR 28
1980: PUSH
1981: LD_INT 1
1983: ST_TO_ADDR
// if num = 1 then
1984: LD_VAR 0 2
1988: PUSH
1989: LD_INT 1
1991: EQUAL
1992: IFFALSE 2074
// begin hc_gallery := us ;
1994: LD_ADDR_OWVAR 33
1998: PUSH
1999: LD_STRING us
2001: ST_TO_ADDR
// hc_face_number := 5 ;
2002: LD_ADDR_OWVAR 34
2006: PUSH
2007: LD_INT 5
2009: ST_TO_ADDR
// hc_name := John Macmilan ;
2010: LD_ADDR_OWVAR 26
2014: PUSH
2015: LD_STRING John Macmilan
2017: ST_TO_ADDR
// hc_sex := sex_male ;
2018: LD_ADDR_OWVAR 27
2022: PUSH
2023: LD_INT 1
2025: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2026: LD_ADDR_OWVAR 31
2030: PUSH
2031: LD_INT 7
2033: PUSH
2034: LD_INT 2
2036: PUSH
2037: LD_INT 4
2039: PUSH
2040: LD_INT 4
2042: PUSH
2043: EMPTY
2044: LIST
2045: LIST
2046: LIST
2047: LIST
2048: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2049: LD_ADDR_OWVAR 29
2053: PUSH
2054: LD_INT 11
2056: PUSH
2057: LD_INT 10
2059: PUSH
2060: EMPTY
2061: LIST
2062: LIST
2063: ST_TO_ADDR
// result := CreateHuman ;
2064: LD_ADDR_VAR 0 3
2068: PUSH
2069: CALL_OW 44
2073: ST_TO_ADDR
// end ; if num = 2 then
2074: LD_VAR 0 2
2078: PUSH
2079: LD_INT 2
2081: EQUAL
2082: IFFALSE 2164
// begin hc_gallery := us ;
2084: LD_ADDR_OWVAR 33
2088: PUSH
2089: LD_STRING us
2091: ST_TO_ADDR
// hc_face_number := 2 ;
2092: LD_ADDR_OWVAR 34
2096: PUSH
2097: LD_INT 2
2099: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2100: LD_ADDR_OWVAR 26
2104: PUSH
2105: LD_STRING Lucy Donaldson
2107: ST_TO_ADDR
// hc_sex := sex_female ;
2108: LD_ADDR_OWVAR 27
2112: PUSH
2113: LD_INT 2
2115: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2116: LD_ADDR_OWVAR 31
2120: PUSH
2121: LD_INT 6
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: LD_INT 4
2129: PUSH
2130: LD_INT 3
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2139: LD_ADDR_OWVAR 29
2143: PUSH
2144: LD_INT 9
2146: PUSH
2147: LD_INT 12
2149: PUSH
2150: EMPTY
2151: LIST
2152: LIST
2153: ST_TO_ADDR
// result := CreateHuman ;
2154: LD_ADDR_VAR 0 3
2158: PUSH
2159: CALL_OW 44
2163: ST_TO_ADDR
// end ; if num = 3 then
2164: LD_VAR 0 2
2168: PUSH
2169: LD_INT 3
2171: EQUAL
2172: IFFALSE 2254
// begin hc_gallery := us ;
2174: LD_ADDR_OWVAR 33
2178: PUSH
2179: LD_STRING us
2181: ST_TO_ADDR
// hc_face_number := 7 ;
2182: LD_ADDR_OWVAR 34
2186: PUSH
2187: LD_INT 7
2189: ST_TO_ADDR
// hc_name := Arthur Powell ;
2190: LD_ADDR_OWVAR 26
2194: PUSH
2195: LD_STRING Arthur Powell
2197: ST_TO_ADDR
// hc_sex := sex_male ;
2198: LD_ADDR_OWVAR 27
2202: PUSH
2203: LD_INT 1
2205: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2206: LD_ADDR_OWVAR 31
2210: PUSH
2211: LD_INT 8
2213: PUSH
2214: LD_INT 2
2216: PUSH
2217: LD_INT 5
2219: PUSH
2220: LD_INT 2
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: LIST
2227: LIST
2228: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2229: LD_ADDR_OWVAR 29
2233: PUSH
2234: LD_INT 10
2236: PUSH
2237: LD_INT 11
2239: PUSH
2240: EMPTY
2241: LIST
2242: LIST
2243: ST_TO_ADDR
// result := CreateHuman ;
2244: LD_ADDR_VAR 0 3
2248: PUSH
2249: CALL_OW 44
2253: ST_TO_ADDR
// end ; end ;
2254: LD_VAR 0 3
2258: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2259: LD_INT 0
2261: PPUSH
2262: PPUSH
2263: PPUSH
2264: PPUSH
2265: PPUSH
2266: PPUSH
2267: PPUSH
2268: PPUSH
2269: PPUSH
// for i = 1 to 8 do
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: DOUBLE
2276: LD_INT 1
2278: DEC
2279: ST_TO_ADDR
2280: LD_INT 8
2282: PUSH
2283: FOR_TO
2284: IFFALSE 3174
// begin if not multi_sides [ i ] then
2286: LD_EXP 7
2290: PUSH
2291: LD_VAR 0 2
2295: ARRAY
2296: NOT
2297: IFFALSE 2301
// continue ;
2299: GO 2283
// if multi_custom_commanders then
2301: LD_EXP 16
2305: IFFALSE 2397
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2307: LD_ADDR_VAR 0 5
2311: PUSH
2312: LD_VAR 0 2
2316: PPUSH
2317: LD_EXP 7
2321: PUSH
2322: LD_VAR 0 2
2326: ARRAY
2327: PPUSH
2328: CALL 1947 0 2
2332: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2333: LD_ADDR_EXP 24
2337: PUSH
2338: LD_EXP 24
2342: PPUSH
2343: LD_EXP 24
2347: PUSH
2348: LD_INT 1
2350: PLUS
2351: PPUSH
2352: LD_VAR 0 5
2356: PPUSH
2357: CALL_OW 2
2361: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2362: LD_VAR 0 5
2366: PPUSH
2367: LD_EXP 12
2371: PUSH
2372: LD_EXP 7
2376: PUSH
2377: LD_VAR 0 2
2381: ARRAY
2382: ARRAY
2383: PUSH
2384: LD_INT 1
2386: ARRAY
2387: PPUSH
2388: LD_INT 0
2390: PPUSH
2391: CALL_OW 49
// end else
2395: GO 2608
// begin uc_side := i ;
2397: LD_ADDR_OWVAR 20
2401: PUSH
2402: LD_VAR 0 2
2406: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2407: LD_ADDR_OWVAR 21
2411: PUSH
2412: LD_EXP 9
2416: PUSH
2417: LD_VAR 0 2
2421: ARRAY
2422: ST_TO_ADDR
// hc_importance := 100 ;
2423: LD_ADDR_OWVAR 32
2427: PUSH
2428: LD_INT 100
2430: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2431: LD_INT 0
2433: PPUSH
2434: LD_INT 1
2436: PPUSH
2437: LD_EXP 20
2441: PPUSH
2442: CALL_OW 380
// if multiplayer then
2446: LD_OWVAR 4
2450: IFFALSE 2508
// begin hc_name := mp_sides_players_names [ i ] ;
2452: LD_ADDR_OWVAR 26
2456: PUSH
2457: LD_OWVAR 19
2461: PUSH
2462: LD_VAR 0 2
2466: ARRAY
2467: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2468: LD_ADDR_OWVAR 33
2472: PUSH
2473: LD_STRING MULTIAVATARS
2475: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2476: LD_ADDR_OWVAR 34
2480: PUSH
2481: LD_VAR 0 2
2485: PPUSH
2486: CALL_OW 525
2490: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2491: LD_ADDR_OWVAR 27
2495: PUSH
2496: LD_VAR 0 2
2500: PPUSH
2501: CALL_OW 526
2505: ST_TO_ADDR
// end else
2506: GO 2540
// begin hc_gallery :=  ;
2508: LD_ADDR_OWVAR 33
2512: PUSH
2513: LD_STRING 
2515: ST_TO_ADDR
// hc_name :=  ;
2516: LD_ADDR_OWVAR 26
2520: PUSH
2521: LD_STRING 
2523: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2524: LD_ADDR_OWVAR 27
2528: PUSH
2529: LD_INT 1
2531: PPUSH
2532: LD_INT 2
2534: PPUSH
2535: CALL_OW 12
2539: ST_TO_ADDR
// end ; un := CreateHuman ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: CALL_OW 44
2549: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2550: LD_VAR 0 5
2554: PPUSH
2555: LD_EXP 12
2559: PUSH
2560: LD_EXP 7
2564: PUSH
2565: LD_VAR 0 2
2569: ARRAY
2570: ARRAY
2571: PUSH
2572: LD_INT 1
2574: ARRAY
2575: PPUSH
2576: LD_INT 0
2578: PPUSH
2579: CALL_OW 49
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2583: LD_ADDR_EXP 24
2587: PUSH
2588: LD_EXP 24
2592: PPUSH
2593: LD_VAR 0 2
2597: PPUSH
2598: LD_VAR 0 5
2602: PPUSH
2603: CALL_OW 1
2607: ST_TO_ADDR
// end ; InitHc ;
2608: CALL_OW 19
// InitUc ;
2612: CALL_OW 18
// uc_side := i ;
2616: LD_ADDR_OWVAR 20
2620: PUSH
2621: LD_VAR 0 2
2625: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2626: LD_ADDR_OWVAR 21
2630: PUSH
2631: LD_EXP 9
2635: PUSH
2636: LD_VAR 0 2
2640: ARRAY
2641: ST_TO_ADDR
// hc_gallery :=  ;
2642: LD_ADDR_OWVAR 33
2646: PUSH
2647: LD_STRING 
2649: ST_TO_ADDR
// hc_name :=  ;
2650: LD_ADDR_OWVAR 26
2654: PUSH
2655: LD_STRING 
2657: ST_TO_ADDR
// hc_importance := 0 ;
2658: LD_ADDR_OWVAR 32
2662: PUSH
2663: LD_INT 0
2665: ST_TO_ADDR
// cl := 1 ;
2666: LD_ADDR_VAR 0 4
2670: PUSH
2671: LD_INT 1
2673: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2674: LD_ADDR_VAR 0 3
2678: PUSH
2679: DOUBLE
2680: LD_INT 2
2682: DEC
2683: ST_TO_ADDR
2684: LD_EXP 19
2688: PUSH
2689: FOR_TO
2690: IFFALSE 3062
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2692: LD_VAR 0 3
2696: PUSH
2697: LD_INT 1
2699: MINUS
2700: PUSH
2701: LD_EXP 19
2705: PUSH
2706: LD_INT 1
2708: MINUS
2709: PUSH
2710: LD_INT 4
2712: DIVREAL
2713: MOD
2714: PUSH
2715: LD_INT 0
2717: EQUAL
2718: IFFALSE 2734
// cl := cl + 1 ;
2720: LD_ADDR_VAR 0 4
2724: PUSH
2725: LD_VAR 0 4
2729: PUSH
2730: LD_INT 1
2732: PLUS
2733: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2734: LD_INT 0
2736: PPUSH
2737: LD_VAR 0 4
2741: PPUSH
2742: LD_EXP 20
2746: PPUSH
2747: CALL_OW 380
// un := CreateHuman ;
2751: LD_ADDR_VAR 0 5
2755: PUSH
2756: CALL_OW 44
2760: ST_TO_ADDR
// if j > copy then
2761: LD_VAR 0 3
2765: PUSH
2766: LD_VAR 0 8
2770: GREATER
2771: IFFALSE 2800
// copy := Replace ( copy , j , un ) else
2773: LD_ADDR_VAR 0 8
2777: PUSH
2778: LD_VAR 0 8
2782: PPUSH
2783: LD_VAR 0 3
2787: PPUSH
2788: LD_VAR 0 5
2792: PPUSH
2793: CALL_OW 1
2797: ST_TO_ADDR
2798: GO 2882
// begin CopySkills ( copy [ j ] , un ) ;
2800: LD_VAR 0 8
2804: PUSH
2805: LD_VAR 0 3
2809: ARRAY
2810: PPUSH
2811: LD_VAR 0 5
2815: PPUSH
2816: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2820: LD_VAR 0 5
2824: PPUSH
2825: LD_INT 2
2827: PPUSH
2828: LD_VAR 0 8
2832: PUSH
2833: LD_VAR 0 3
2837: ARRAY
2838: PPUSH
2839: LD_INT 2
2841: PPUSH
2842: CALL_OW 260
2846: PPUSH
2847: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2851: LD_VAR 0 5
2855: PPUSH
2856: LD_INT 1
2858: PPUSH
2859: LD_VAR 0 8
2863: PUSH
2864: LD_VAR 0 3
2868: ARRAY
2869: PPUSH
2870: LD_INT 1
2872: PPUSH
2873: CALL_OW 260
2877: PPUSH
2878: CALL_OW 239
// end ; if multi_pos_area then
2882: LD_EXP 12
2886: IFFALSE 3060
// begin if GetClass ( un ) = 3 then
2888: LD_VAR 0 5
2892: PPUSH
2893: CALL_OW 257
2897: PUSH
2898: LD_INT 3
2900: EQUAL
2901: IFFALSE 3027
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2903: LD_INT 3
2905: PUSH
2906: LD_INT 2
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: PUSH
2913: LD_VAR 0 3
2917: PUSH
2918: LD_INT 2
2920: MOD
2921: PUSH
2922: LD_INT 1
2924: PLUS
2925: ARRAY
2926: PPUSH
2927: LD_INT 2
2929: PPUSH
2930: LD_INT 1
2932: PPUSH
2933: LD_INT 5
2935: PUSH
2936: LD_INT 4
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: LD_VAR 0 3
2951: PUSH
2952: LD_INT 3
2954: MOD
2955: PUSH
2956: LD_INT 1
2958: PLUS
2959: ARRAY
2960: PPUSH
2961: LD_INT 100
2963: PPUSH
2964: CALL 14652 0 5
// veh := CreateVehicle ;
2968: LD_ADDR_VAR 0 6
2972: PUSH
2973: CALL_OW 45
2977: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
2978: LD_VAR 0 6
2982: PPUSH
2983: LD_EXP 12
2987: PUSH
2988: LD_EXP 7
2992: PUSH
2993: LD_VAR 0 2
2997: ARRAY
2998: ARRAY
2999: PUSH
3000: LD_INT 2
3002: ARRAY
3003: PPUSH
3004: LD_INT 0
3006: PPUSH
3007: CALL_OW 49
// PlaceHumanInUnit ( un , veh ) ;
3011: LD_VAR 0 5
3015: PPUSH
3016: LD_VAR 0 6
3020: PPUSH
3021: CALL_OW 52
// continue ;
3025: GO 2689
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3027: LD_VAR 0 5
3031: PPUSH
3032: LD_EXP 12
3036: PUSH
3037: LD_EXP 7
3041: PUSH
3042: LD_VAR 0 2
3046: ARRAY
3047: ARRAY
3048: PUSH
3049: LD_INT 1
3051: ARRAY
3052: PPUSH
3053: LD_INT 0
3055: PPUSH
3056: CALL_OW 49
// end ; end ;
3060: GO 2689
3062: POP
3063: POP
// for j = 1 to 3 do
3064: LD_ADDR_VAR 0 3
3068: PUSH
3069: DOUBLE
3070: LD_INT 1
3072: DEC
3073: ST_TO_ADDR
3074: LD_INT 3
3076: PUSH
3077: FOR_TO
3078: IFFALSE 3170
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3080: LD_INT 2
3082: PUSH
3083: LD_INT 3
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: PUSH
3090: LD_INT 1
3092: PPUSH
3093: LD_INT 2
3095: PPUSH
3096: CALL_OW 12
3100: ARRAY
3101: PPUSH
3102: LD_INT 2
3104: PPUSH
3105: LD_INT 3
3107: PPUSH
3108: LD_INT 11
3110: PUSH
3111: LD_INT 7
3113: PUSH
3114: LD_INT 4
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: PUSH
3122: LD_VAR 0 3
3126: ARRAY
3127: PPUSH
3128: LD_INT 100
3130: PPUSH
3131: CALL 14652 0 5
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3135: CALL_OW 45
3139: PPUSH
3140: LD_EXP 12
3144: PUSH
3145: LD_EXP 7
3149: PUSH
3150: LD_VAR 0 2
3154: ARRAY
3155: ARRAY
3156: PUSH
3157: LD_INT 1
3159: ARRAY
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 49
// end ;
3168: GO 3077
3170: POP
3171: POP
// end ;
3172: GO 2283
3174: POP
3175: POP
// end ;
3176: LD_VAR 0 1
3180: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3181: LD_INT 0
3183: PPUSH
3184: PPUSH
3185: PPUSH
3186: PPUSH
3187: PPUSH
// if not multi_support then
3188: LD_EXP 23
3192: NOT
3193: IFFALSE 3197
// exit ;
3195: GO 3725
// result := [ ] ;
3197: LD_ADDR_VAR 0 1
3201: PUSH
3202: EMPTY
3203: ST_TO_ADDR
// for i = 1 to 8 do
3204: LD_ADDR_VAR 0 2
3208: PUSH
3209: DOUBLE
3210: LD_INT 1
3212: DEC
3213: ST_TO_ADDR
3214: LD_INT 8
3216: PUSH
3217: FOR_TO
3218: IFFALSE 3723
// begin if multi_sides [ i ] then
3220: LD_EXP 7
3224: PUSH
3225: LD_VAR 0 2
3229: ARRAY
3230: IFFALSE 3721
// begin tmp := [ ] ;
3232: LD_ADDR_VAR 0 5
3236: PUSH
3237: EMPTY
3238: ST_TO_ADDR
// if multi_support = 1 then
3239: LD_EXP 23
3243: PUSH
3244: LD_INT 1
3246: EQUAL
3247: IFFALSE 3415
// begin uc_side := i ;
3249: LD_ADDR_OWVAR 20
3253: PUSH
3254: LD_VAR 0 2
3258: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3259: LD_ADDR_OWVAR 21
3263: PUSH
3264: LD_EXP 9
3268: PUSH
3269: LD_VAR 0 2
3273: ARRAY
3274: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3275: LD_INT 3
3277: PPUSH
3278: LD_INT 1
3280: PPUSH
3281: LD_INT 3
3283: PPUSH
3284: LD_INT 11
3286: PPUSH
3287: LD_INT 40
3289: PPUSH
3290: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3294: LD_ADDR_VAR 0 5
3298: PUSH
3299: LD_VAR 0 5
3303: PUSH
3304: CALL_OW 45
3308: ADD
3309: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3310: LD_INT 2
3312: PPUSH
3313: LD_INT 1
3315: PPUSH
3316: LD_INT 3
3318: PPUSH
3319: LD_INT 5
3321: PPUSH
3322: LD_INT 40
3324: PPUSH
3325: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3329: LD_ADDR_VAR 0 5
3333: PUSH
3334: LD_VAR 0 5
3338: PUSH
3339: CALL_OW 45
3343: ADD
3344: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3345: LD_INT 2
3347: PPUSH
3348: LD_INT 3
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 4
3356: PPUSH
3357: LD_INT 40
3359: PPUSH
3360: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3364: LD_ADDR_VAR 0 5
3368: PUSH
3369: LD_VAR 0 5
3373: PUSH
3374: CALL_OW 45
3378: ADD
3379: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3380: LD_INT 3
3382: PPUSH
3383: LD_INT 2
3385: PPUSH
3386: LD_INT 3
3388: PPUSH
3389: LD_INT 9
3391: PPUSH
3392: LD_INT 40
3394: PPUSH
3395: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3399: LD_ADDR_VAR 0 5
3403: PUSH
3404: LD_VAR 0 5
3408: PUSH
3409: CALL_OW 45
3413: ADD
3414: ST_TO_ADDR
// end ; if multi_support = 2 then
3415: LD_EXP 23
3419: PUSH
3420: LD_INT 2
3422: EQUAL
3423: IFFALSE 3696
// begin uc_side := i ;
3425: LD_ADDR_OWVAR 20
3429: PUSH
3430: LD_VAR 0 2
3434: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3435: LD_ADDR_OWVAR 21
3439: PUSH
3440: LD_EXP 9
3444: PUSH
3445: LD_VAR 0 2
3449: ARRAY
3450: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3451: LD_INT 3
3453: PPUSH
3454: LD_INT 1
3456: PPUSH
3457: LD_INT 3
3459: PPUSH
3460: LD_INT 11
3462: PPUSH
3463: LD_INT 40
3465: PPUSH
3466: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3470: LD_ADDR_VAR 0 5
3474: PUSH
3475: LD_VAR 0 5
3479: PUSH
3480: CALL_OW 45
3484: ADD
3485: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3486: LD_INT 3
3488: PPUSH
3489: LD_INT 3
3491: PPUSH
3492: LD_INT 3
3494: PPUSH
3495: LD_INT 12
3497: PPUSH
3498: LD_INT 40
3500: PPUSH
3501: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3505: LD_ADDR_VAR 0 5
3509: PUSH
3510: LD_VAR 0 5
3514: PUSH
3515: CALL_OW 45
3519: ADD
3520: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3521: LD_INT 2
3523: PPUSH
3524: LD_INT 3
3526: PPUSH
3527: LD_INT 3
3529: PPUSH
3530: LD_INT 5
3532: PPUSH
3533: LD_INT 40
3535: PPUSH
3536: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3540: LD_ADDR_VAR 0 5
3544: PUSH
3545: LD_VAR 0 5
3549: PUSH
3550: CALL_OW 45
3554: ADD
3555: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3556: LD_INT 4
3558: PPUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_INT 3
3564: PPUSH
3565: LD_INT 6
3567: PPUSH
3568: LD_INT 40
3570: PPUSH
3571: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3575: LD_ADDR_VAR 0 5
3579: PUSH
3580: LD_VAR 0 5
3584: PUSH
3585: CALL_OW 45
3589: ADD
3590: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3591: LD_INT 2
3593: PPUSH
3594: LD_INT 3
3596: PPUSH
3597: LD_INT 3
3599: PPUSH
3600: LD_INT 9
3602: PPUSH
3603: LD_INT 40
3605: PPUSH
3606: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3610: LD_ADDR_VAR 0 5
3614: PUSH
3615: LD_VAR 0 5
3619: PUSH
3620: CALL_OW 45
3624: ADD
3625: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 3
3631: PPUSH
3632: LD_INT 3
3634: PPUSH
3635: LD_INT 9
3637: PPUSH
3638: LD_INT 40
3640: PPUSH
3641: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3645: LD_ADDR_VAR 0 5
3649: PUSH
3650: LD_VAR 0 5
3654: PUSH
3655: CALL_OW 45
3659: ADD
3660: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3661: LD_INT 4
3663: PPUSH
3664: LD_INT 1
3666: PPUSH
3667: LD_INT 3
3669: PPUSH
3670: LD_INT 6
3672: PPUSH
3673: LD_INT 40
3675: PPUSH
3676: CALL 14652 0 5
// tmp := tmp ^ CreateVehicle ;
3680: LD_ADDR_VAR 0 5
3684: PUSH
3685: LD_VAR 0 5
3689: PUSH
3690: CALL_OW 45
3694: ADD
3695: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3696: LD_ADDR_VAR 0 1
3700: PUSH
3701: LD_VAR 0 1
3705: PPUSH
3706: LD_VAR 0 2
3710: PPUSH
3711: LD_VAR 0 5
3715: PPUSH
3716: CALL_OW 2
3720: ST_TO_ADDR
// end ; end ;
3721: GO 3217
3723: POP
3724: POP
// end ;
3725: LD_VAR 0 1
3729: RET
// export function Multiplayer_Start ( ) ; begin
3730: LD_INT 0
3732: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3733: CALL 2259 0 0
// Multiplayer_InitPointSystem ( ) ;
3737: CALL 4646 0 0
// Multiplayer_RegisterCondition ( 20 ) ;
3741: LD_INT 20
3743: PPUSH
3744: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 150 ) ;
3748: LD_INT 150
3750: PPUSH
3751: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 5 ) ;
3755: LD_INT 5
3757: PPUSH
3758: CALL 4822 0 1
// Multiplayer_RegisterCondition ( - 40 ) ;
3762: LD_INT 40
3764: NEG
3765: PPUSH
3766: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 200 ) ;
3770: LD_INT 200
3772: PPUSH
3773: CALL 4822 0 1
// Multiplayer_RegisterCondition ( 2 ) ;
3777: LD_INT 2
3779: PPUSH
3780: CALL 4822 0 1
// Multiplayer_SpawnArtifact ;
3784: CALL 5262 0 0
// if multi_support then
3788: LD_EXP 23
3792: IFFALSE 3804
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3794: LD_ADDR_EXP 27
3798: PUSH
3799: CALL 3181 0 0
3803: ST_TO_ADDR
// if multi_sides [ your_side ] then
3804: LD_EXP 7
3808: PUSH
3809: LD_OWVAR 2
3813: ARRAY
3814: IFFALSE 3841
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3816: LD_INT 22
3818: PUSH
3819: LD_OWVAR 2
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 69
3832: PUSH
3833: LD_INT 1
3835: ARRAY
3836: PPUSH
3837: CALL_OW 87
// end ;
3841: LD_VAR 0 1
3845: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3846: LD_INT 0
3848: PPUSH
3849: PPUSH
3850: PPUSH
3851: PPUSH
3852: PPUSH
// reinforcements_arrive := 0 ;
3853: LD_ADDR_VAR 0 5
3857: PUSH
3858: LD_INT 0
3860: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3861: LD_INT 35
3863: PPUSH
3864: CALL_OW 67
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3868: LD_OWVAR 1
3872: PUSH
3873: LD_INT 21000
3875: GREATER
3876: PUSH
3877: LD_EXP 28
3881: NOT
3882: AND
3883: PUSH
3884: LD_EXP 23
3888: PUSH
3889: LD_INT 1
3891: EQUAL
3892: AND
3893: IFFALSE 4088
// begin multi_reinforcements_spawned := 1 ;
3895: LD_ADDR_EXP 28
3899: PUSH
3900: LD_INT 1
3902: ST_TO_ADDR
// for i = 1 to 8 do
3903: LD_ADDR_VAR 0 2
3907: PUSH
3908: DOUBLE
3909: LD_INT 1
3911: DEC
3912: ST_TO_ADDR
3913: LD_INT 8
3915: PUSH
3916: FOR_TO
3917: IFFALSE 4076
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3919: LD_EXP 7
3923: PUSH
3924: LD_VAR 0 2
3928: ARRAY
3929: PUSH
3930: LD_EXP 25
3934: PUSH
3935: LD_VAR 0 2
3939: ARRAY
3940: NOT
3941: AND
3942: PUSH
3943: LD_EXP 27
3947: PUSH
3948: LD_VAR 0 2
3952: ARRAY
3953: AND
3954: IFFALSE 4074
// begin tmp := multi_reinforcements [ i ] ;
3956: LD_ADDR_VAR 0 4
3960: PUSH
3961: LD_EXP 27
3965: PUSH
3966: LD_VAR 0 2
3970: ARRAY
3971: ST_TO_ADDR
// for j = 1 to 4 do
3972: LD_ADDR_VAR 0 3
3976: PUSH
3977: DOUBLE
3978: LD_INT 1
3980: DEC
3981: ST_TO_ADDR
3982: LD_INT 4
3984: PUSH
3985: FOR_TO
3986: IFFALSE 4047
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3988: LD_VAR 0 4
3992: PUSH
3993: LD_VAR 0 3
3997: ARRAY
3998: PPUSH
3999: LD_EXP 12
4003: PUSH
4004: LD_EXP 7
4008: PUSH
4009: LD_VAR 0 2
4013: ARRAY
4014: ARRAY
4015: PUSH
4016: LD_INT 2
4018: ARRAY
4019: PPUSH
4020: LD_INT 0
4022: PPUSH
4023: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4027: LD_ADDR_VAR 0 4
4031: PUSH
4032: LD_VAR 0 4
4036: PPUSH
4037: LD_INT 1
4039: PPUSH
4040: CALL_OW 3
4044: ST_TO_ADDR
// end ;
4045: GO 3985
4047: POP
4048: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4049: LD_ADDR_EXP 27
4053: PUSH
4054: LD_EXP 27
4058: PPUSH
4059: LD_VAR 0 2
4063: PPUSH
4064: LD_VAR 0 4
4068: PPUSH
4069: CALL_OW 1
4073: ST_TO_ADDR
// end ; end ;
4074: GO 3916
4076: POP
4077: POP
// reinforcements_arrive := tick ;
4078: LD_ADDR_VAR 0 5
4082: PUSH
4083: LD_OWVAR 1
4087: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4088: LD_VAR 0 5
4092: PUSH
4093: LD_INT 21000
4095: PLUS
4096: PUSH
4097: LD_OWVAR 1
4101: LESS
4102: PUSH
4103: LD_EXP 28
4107: PUSH
4108: LD_INT 1
4110: EQUAL
4111: AND
4112: PUSH
4113: LD_EXP 23
4117: PUSH
4118: LD_INT 2
4120: EQUAL
4121: AND
4122: IFFALSE 4307
// begin multi_reinforcements_spawned := 2 ;
4124: LD_ADDR_EXP 28
4128: PUSH
4129: LD_INT 2
4131: ST_TO_ADDR
// for i = 1 to 8 do
4132: LD_ADDR_VAR 0 2
4136: PUSH
4137: DOUBLE
4138: LD_INT 1
4140: DEC
4141: ST_TO_ADDR
4142: LD_INT 8
4144: PUSH
4145: FOR_TO
4146: IFFALSE 4305
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4148: LD_EXP 7
4152: PUSH
4153: LD_VAR 0 2
4157: ARRAY
4158: PUSH
4159: LD_EXP 25
4163: PUSH
4164: LD_VAR 0 2
4168: ARRAY
4169: NOT
4170: AND
4171: PUSH
4172: LD_EXP 27
4176: PUSH
4177: LD_VAR 0 2
4181: ARRAY
4182: AND
4183: IFFALSE 4303
// begin tmp := multi_reinforcements [ i ] ;
4185: LD_ADDR_VAR 0 4
4189: PUSH
4190: LD_EXP 27
4194: PUSH
4195: LD_VAR 0 2
4199: ARRAY
4200: ST_TO_ADDR
// for j = 1 to 3 do
4201: LD_ADDR_VAR 0 3
4205: PUSH
4206: DOUBLE
4207: LD_INT 1
4209: DEC
4210: ST_TO_ADDR
4211: LD_INT 3
4213: PUSH
4214: FOR_TO
4215: IFFALSE 4276
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4217: LD_VAR 0 4
4221: PUSH
4222: LD_VAR 0 3
4226: ARRAY
4227: PPUSH
4228: LD_EXP 12
4232: PUSH
4233: LD_EXP 7
4237: PUSH
4238: LD_VAR 0 2
4242: ARRAY
4243: ARRAY
4244: PUSH
4245: LD_INT 2
4247: ARRAY
4248: PPUSH
4249: LD_INT 0
4251: PPUSH
4252: CALL_OW 49
// tmp := Delete ( tmp , 1 ) ;
4256: LD_ADDR_VAR 0 4
4260: PUSH
4261: LD_VAR 0 4
4265: PPUSH
4266: LD_INT 1
4268: PPUSH
4269: CALL_OW 3
4273: ST_TO_ADDR
// end ;
4274: GO 4214
4276: POP
4277: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4278: LD_ADDR_EXP 27
4282: PUSH
4283: LD_EXP 27
4287: PPUSH
4288: LD_VAR 0 2
4292: PPUSH
4293: LD_VAR 0 4
4297: PPUSH
4298: CALL_OW 1
4302: ST_TO_ADDR
// end ; end ;
4303: GO 4145
4305: POP
4306: POP
// end ; if not multi_custom_commanders then
4307: LD_EXP 16
4311: NOT
4312: IFFALSE 4425
// begin for i = 1 to 8 do
4314: LD_ADDR_VAR 0 2
4318: PUSH
4319: DOUBLE
4320: LD_INT 1
4322: DEC
4323: ST_TO_ADDR
4324: LD_INT 8
4326: PUSH
4327: FOR_TO
4328: IFFALSE 4399
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4330: LD_INT 22
4332: PUSH
4333: LD_VAR 0 2
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PPUSH
4342: CALL_OW 69
4346: PUSH
4347: LD_INT 0
4349: EQUAL
4350: PUSH
4351: LD_EXP 25
4355: PUSH
4356: LD_VAR 0 2
4360: ARRAY
4361: NOT
4362: AND
4363: IFFALSE 4397
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4365: LD_ADDR_EXP 25
4369: PUSH
4370: LD_EXP 25
4374: PPUSH
4375: LD_VAR 0 2
4379: PPUSH
4380: LD_INT 1
4382: PPUSH
4383: CALL_OW 1
4387: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4388: LD_VAR 0 2
4392: PPUSH
4393: CALL 4892 0 1
// end ; end ;
4397: GO 4327
4399: POP
4400: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4401: LD_EXP 25
4405: PPUSH
4406: CALL 11914 0 1
4410: PUSH
4411: LD_EXP 7
4415: PPUSH
4416: CALL 11914 0 1
4420: EQUAL
4421: IFFALSE 4425
// break ;
4423: GO 4460
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4425: LD_INT 22
4427: PUSH
4428: LD_EXP 3
4432: PUSH
4433: EMPTY
4434: LIST
4435: LIST
4436: PPUSH
4437: CALL_OW 69
4441: PUSH
4442: LD_INT 0
4444: EQUAL
4445: PUSH
4446: LD_EXP 2
4450: AND
4451: PUSH
4452: LD_EXP 24
4456: NOT
4457: OR
4458: IFFALSE 3861
// game := false ;
4460: LD_ADDR_EXP 2
4464: PUSH
4465: LD_INT 0
4467: ST_TO_ADDR
// for i = 1 to 8 do
4468: LD_ADDR_VAR 0 2
4472: PUSH
4473: DOUBLE
4474: LD_INT 1
4476: DEC
4477: ST_TO_ADDR
4478: LD_INT 8
4480: PUSH
4481: FOR_TO
4482: IFFALSE 4518
// begin if multi_sides [ i ] then
4484: LD_EXP 7
4488: PUSH
4489: LD_VAR 0 2
4493: ARRAY
4494: IFFALSE 4516
// SetMultiScore ( i , multi_points [ i ] ) ;
4496: LD_VAR 0 2
4500: PPUSH
4501: LD_EXP 29
4505: PUSH
4506: LD_VAR 0 2
4510: ARRAY
4511: PPUSH
4512: CALL_OW 506
// end ;
4516: GO 4481
4518: POP
4519: POP
// if multi_loosers [ your_side ] then
4520: LD_EXP 25
4524: PUSH
4525: LD_OWVAR 2
4529: ARRAY
4530: IFFALSE 4538
// YouLostInMultiplayer else
4532: CALL_OW 107
4536: GO 4542
// YouWinInMultiplayer ;
4538: CALL_OW 106
// end ;
4542: LD_VAR 0 1
4546: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4547: LD_INT 0
4549: PPUSH
4550: PPUSH
// result := [ #tick , tick ] ;
4551: LD_ADDR_VAR 0 1
4555: PUSH
4556: LD_STRING #tick
4558: PUSH
4559: LD_OWVAR 1
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: ST_TO_ADDR
// for i = 1 to 8 do
4568: LD_ADDR_VAR 0 2
4572: PUSH
4573: DOUBLE
4574: LD_INT 1
4576: DEC
4577: ST_TO_ADDR
4578: LD_INT 8
4580: PUSH
4581: FOR_TO
4582: IFFALSE 4639
// begin if multi_sides [ i ] then
4584: LD_EXP 7
4588: PUSH
4589: LD_VAR 0 2
4593: ARRAY
4594: IFFALSE 4637
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4596: LD_ADDR_VAR 0 1
4600: PUSH
4601: LD_VAR 0 1
4605: PUSH
4606: LD_STRING #coop-points
4608: PUSH
4609: LD_VAR 0 2
4613: PUSH
4614: LD_VAR 0 2
4618: PUSH
4619: LD_EXP 29
4623: PUSH
4624: LD_VAR 0 2
4628: ARRAY
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: ADD
4636: ST_TO_ADDR
// end ; end ;
4637: GO 4581
4639: POP
4640: POP
// end ;
4641: LD_VAR 0 1
4645: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4646: LD_INT 0
4648: PPUSH
4649: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4650: LD_ADDR_EXP 29
4654: PUSH
4655: LD_INT 0
4657: PUSH
4658: LD_INT 0
4660: PUSH
4661: LD_INT 0
4663: PUSH
4664: LD_INT 0
4666: PUSH
4667: LD_INT 0
4669: PUSH
4670: LD_INT 0
4672: PUSH
4673: LD_INT 0
4675: PUSH
4676: LD_INT 0
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: LIST
4683: LIST
4684: LIST
4685: LIST
4686: LIST
4687: LIST
4688: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4689: LD_ADDR_EXP 30
4693: PUSH
4694: EMPTY
4695: ST_TO_ADDR
// end ;
4696: LD_VAR 0 1
4700: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4701: LD_INT 0
4703: PPUSH
// if not multi_points or not side or side > 8 then
4704: LD_EXP 29
4708: NOT
4709: PUSH
4710: LD_VAR 0 1
4714: NOT
4715: OR
4716: PUSH
4717: LD_VAR 0 1
4721: PUSH
4722: LD_INT 8
4724: GREATER
4725: OR
4726: IFFALSE 4730
// exit ;
4728: GO 4767
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4730: LD_ADDR_EXP 29
4734: PUSH
4735: LD_EXP 29
4739: PPUSH
4740: LD_VAR 0 1
4744: PPUSH
4745: LD_EXP 29
4749: PUSH
4750: LD_VAR 0 1
4754: ARRAY
4755: PUSH
4756: LD_VAR 0 2
4760: PLUS
4761: PPUSH
4762: CALL_OW 1
4766: ST_TO_ADDR
// end ;
4767: LD_VAR 0 3
4771: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4772: LD_INT 0
4774: PPUSH
// if not multi_points or not side or side > 8 then
4775: LD_EXP 29
4779: NOT
4780: PUSH
4781: LD_VAR 0 1
4785: NOT
4786: OR
4787: PUSH
4788: LD_VAR 0 1
4792: PUSH
4793: LD_INT 8
4795: GREATER
4796: OR
4797: IFFALSE 4801
// exit ;
4799: GO 4817
// result := multi_points [ side ] ;
4801: LD_ADDR_VAR 0 2
4805: PUSH
4806: LD_EXP 29
4810: PUSH
4811: LD_VAR 0 1
4815: ARRAY
4816: ST_TO_ADDR
// end ;
4817: LD_VAR 0 2
4821: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4822: LD_INT 0
4824: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4825: LD_ADDR_EXP 30
4829: PUSH
4830: LD_EXP 30
4834: PPUSH
4835: LD_EXP 30
4839: PUSH
4840: LD_INT 1
4842: PLUS
4843: PPUSH
4844: LD_VAR 0 1
4848: PPUSH
4849: CALL_OW 2
4853: ST_TO_ADDR
// end ;
4854: LD_VAR 0 2
4858: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4859: LD_INT 0
4861: PPUSH
// if not id then
4862: LD_VAR 0 1
4866: NOT
4867: IFFALSE 4871
// exit ;
4869: GO 4887
// result := multi_points_conditions [ id ] ;
4871: LD_ADDR_VAR 0 2
4875: PUSH
4876: LD_EXP 30
4880: PUSH
4881: LD_VAR 0 1
4885: ARRAY
4886: ST_TO_ADDR
// end ;
4887: LD_VAR 0 2
4891: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
4897: PPUSH
4898: PPUSH
// players := [ ] ;
4899: LD_ADDR_VAR 0 3
4903: PUSH
4904: EMPTY
4905: ST_TO_ADDR
// for i = 1 to 8 do
4906: LD_ADDR_VAR 0 4
4910: PUSH
4911: DOUBLE
4912: LD_INT 1
4914: DEC
4915: ST_TO_ADDR
4916: LD_INT 8
4918: PUSH
4919: FOR_TO
4920: IFFALSE 4979
// begin if i = side then
4922: LD_VAR 0 4
4926: PUSH
4927: LD_VAR 0 1
4931: EQUAL
4932: IFFALSE 4936
// continue ;
4934: GO 4919
// if multi_sides [ i ] and not multi_loosers [ i ] then
4936: LD_EXP 7
4940: PUSH
4941: LD_VAR 0 4
4945: ARRAY
4946: PUSH
4947: LD_EXP 25
4951: PUSH
4952: LD_VAR 0 4
4956: ARRAY
4957: NOT
4958: AND
4959: IFFALSE 4977
// players := players ^ i ;
4961: LD_ADDR_VAR 0 3
4965: PUSH
4966: LD_VAR 0 3
4970: PUSH
4971: LD_VAR 0 4
4975: ADD
4976: ST_TO_ADDR
// end ;
4977: GO 4919
4979: POP
4980: POP
// if not players then
4981: LD_VAR 0 3
4985: NOT
4986: IFFALSE 4990
// exit ;
4988: GO 5257
// if players = 1 then
4990: LD_VAR 0 3
4994: PUSH
4995: LD_INT 1
4997: EQUAL
4998: IFFALSE 5059
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5000: LD_ADDR_VAR 0 4
5004: PUSH
5005: LD_INT 22
5007: PUSH
5008: LD_VAR 0 1
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 51
5019: PUSH
5020: EMPTY
5021: LIST
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PPUSH
5027: CALL_OW 69
5031: PUSH
5032: FOR_IN
5033: IFFALSE 5055
// SetSide ( i , players [ 1 ] ) ;
5035: LD_VAR 0 4
5039: PPUSH
5040: LD_VAR 0 3
5044: PUSH
5045: LD_INT 1
5047: ARRAY
5048: PPUSH
5049: CALL_OW 235
5053: GO 5032
5055: POP
5056: POP
// end else
5057: GO 5257
// begin j := 1 ;
5059: LD_ADDR_VAR 0 5
5063: PUSH
5064: LD_INT 1
5066: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5067: LD_ADDR_VAR 0 4
5071: PUSH
5072: LD_INT 22
5074: PUSH
5075: LD_VAR 0 1
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 2
5086: PUSH
5087: LD_INT 21
5089: PUSH
5090: LD_INT 1
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: LD_INT 51
5099: PUSH
5100: EMPTY
5101: LIST
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 21
5109: PUSH
5110: LD_INT 2
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PPUSH
5126: CALL_OW 69
5130: PUSH
5131: FOR_IN
5132: IFFALSE 5255
// begin SetSide ( i , players [ j ] ) ;
5134: LD_VAR 0 4
5138: PPUSH
5139: LD_VAR 0 3
5143: PUSH
5144: LD_VAR 0 5
5148: ARRAY
5149: PPUSH
5150: CALL_OW 235
// if IsDrivenBy ( i ) then
5154: LD_VAR 0 4
5158: PPUSH
5159: CALL_OW 311
5163: IFFALSE 5190
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5165: LD_VAR 0 4
5169: PPUSH
5170: CALL_OW 311
5174: PPUSH
5175: LD_VAR 0 3
5179: PUSH
5180: LD_VAR 0 5
5184: ARRAY
5185: PPUSH
5186: CALL_OW 235
// if GetType ( IsInUnit ( i ) ) = unit_building then
5190: LD_VAR 0 4
5194: PPUSH
5195: CALL_OW 310
5199: PPUSH
5200: CALL_OW 247
5204: PUSH
5205: LD_INT 3
5207: EQUAL
5208: IFFALSE 5219
// ComExitBuilding ( i ) ;
5210: LD_VAR 0 4
5214: PPUSH
5215: CALL_OW 122
// j := j + 1 ;
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_VAR 0 5
5228: PUSH
5229: LD_INT 1
5231: PLUS
5232: ST_TO_ADDR
// if j > players then
5233: LD_VAR 0 5
5237: PUSH
5238: LD_VAR 0 3
5242: GREATER
5243: IFFALSE 5253
// j := 1 ;
5245: LD_ADDR_VAR 0 5
5249: PUSH
5250: LD_INT 1
5252: ST_TO_ADDR
// end ;
5253: GO 5131
5255: POP
5256: POP
// end ; end ;
5257: LD_VAR 0 2
5261: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5262: LD_INT 0
5264: PPUSH
5265: PPUSH
5266: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5267: LD_ADDR_VAR 0 3
5271: PUSH
5272: LD_INT 5
5274: PUSH
5275: LD_INT 10
5277: PUSH
5278: EMPTY
5279: LIST
5280: LIST
5281: PUSH
5282: LD_INT 120
5284: PUSH
5285: LD_INT 2
5287: PUSH
5288: EMPTY
5289: LIST
5290: LIST
5291: PUSH
5292: LD_INT 101
5294: PUSH
5295: LD_INT 8
5297: PUSH
5298: EMPTY
5299: LIST
5300: LIST
5301: PUSH
5302: LD_INT 27
5304: PUSH
5305: LD_INT 4
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: LIST
5316: LIST
5317: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5318: LD_ADDR_VAR 0 2
5322: PUSH
5323: LD_INT 1
5325: PPUSH
5326: LD_VAR 0 3
5330: PPUSH
5331: CALL_OW 12
5335: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5336: LD_INT 4
5338: PPUSH
5339: LD_INT 5
5341: PPUSH
5342: LD_VAR 0 3
5346: PUSH
5347: LD_VAR 0 2
5351: ARRAY
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_VAR 0 3
5361: PUSH
5362: LD_VAR 0 2
5366: ARRAY
5367: PUSH
5368: LD_INT 2
5370: ARRAY
5371: PPUSH
5372: LD_INT 0
5374: PPUSH
5375: CALL_OW 58
// end ;
5379: LD_VAR 0 1
5383: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5384: LD_INT 0
5386: PPUSH
// if not side or side > 8 then
5387: LD_VAR 0 1
5391: NOT
5392: PUSH
5393: LD_VAR 0 1
5397: PUSH
5398: LD_INT 8
5400: GREATER
5401: OR
5402: IFFALSE 5406
// exit ;
5404: GO 5423
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5406: LD_VAR 0 1
5410: PPUSH
5411: LD_INT 6
5413: PPUSH
5414: CALL 4859 0 1
5418: PPUSH
5419: CALL 4701 0 2
// end ;
5423: LD_VAR 0 2
5427: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5428: LD_INT 0
5430: PPUSH
// if not side or side > 8 then
5431: LD_VAR 0 1
5435: NOT
5436: PUSH
5437: LD_VAR 0 1
5441: PUSH
5442: LD_INT 8
5444: GREATER
5445: OR
5446: IFFALSE 5450
// exit ;
5448: GO 5467
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5450: LD_VAR 0 1
5454: PPUSH
5455: LD_INT 4
5457: PPUSH
5458: CALL 4859 0 1
5462: PPUSH
5463: CALL 4701 0 2
// end ;
5467: LD_VAR 0 2
5471: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5472: LD_INT 0
5474: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5475: LD_VAR 0 1
5479: NOT
5480: PUSH
5481: LD_VAR 0 1
5485: PUSH
5486: LD_INT 8
5488: GREATER
5489: OR
5490: PUSH
5491: LD_VAR 0 2
5495: PUSH
5496: LD_INT 2
5498: PUSH
5499: LD_INT 6
5501: PUSH
5502: LD_INT 36
5504: PUSH
5505: LD_INT 0
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: IN
5514: NOT
5515: OR
5516: IFFALSE 5520
// exit ;
5518: GO 5537
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5520: LD_VAR 0 1
5524: PPUSH
5525: LD_INT 3
5527: PPUSH
5528: CALL 4859 0 1
5532: PPUSH
5533: CALL 4701 0 2
// end ;
5537: LD_VAR 0 3
5541: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5542: LD_INT 0
5544: PPUSH
5545: PPUSH
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
// if not un then
5550: LD_VAR 0 1
5554: NOT
5555: IFFALSE 5559
// exit ;
5557: GO 5783
// if not points then
5559: LD_VAR 0 2
5563: NOT
5564: IFFALSE 5581
// gained_points := Multiplayer_GetCondition ( 1 ) else
5566: LD_ADDR_VAR 0 8
5570: PUSH
5571: LD_INT 1
5573: PPUSH
5574: CALL 4859 0 1
5578: ST_TO_ADDR
5579: GO 5591
// gained_points := points ;
5581: LD_ADDR_VAR 0 8
5585: PUSH
5586: LD_VAR 0 2
5590: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5591: LD_ADDR_VAR 0 6
5595: PUSH
5596: LD_VAR 0 1
5600: PPUSH
5601: CALL_OW 503
5605: ST_TO_ADDR
// if last_shoot > - 1 then
5606: LD_VAR 0 6
5610: PUSH
5611: LD_INT 1
5613: NEG
5614: GREATER
5615: IFFALSE 5627
// begin side := last_shoot ;
5617: LD_ADDR_VAR 0 4
5621: PUSH
5622: LD_VAR 0 6
5626: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5627: LD_ADDR_VAR 0 7
5631: PUSH
5632: LD_OWVAR 3
5636: PUSH
5637: LD_INT 22
5639: PUSH
5640: LD_VAR 0 1
5644: PPUSH
5645: CALL_OW 255
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PPUSH
5654: CALL_OW 69
5658: DIFF
5659: PPUSH
5660: LD_VAR 0 1
5664: PPUSH
5665: CALL_OW 74
5669: ST_TO_ADDR
// if nearest_unit then
5670: LD_VAR 0 7
5674: IFFALSE 5691
// side2 := GetSide ( nearest_unit ) ;
5676: LD_ADDR_VAR 0 5
5680: PUSH
5681: LD_VAR 0 7
5685: PPUSH
5686: CALL_OW 255
5690: ST_TO_ADDR
// if not side and not side2 then
5691: LD_VAR 0 4
5695: NOT
5696: PUSH
5697: LD_VAR 0 5
5701: NOT
5702: AND
5703: IFFALSE 5707
// exit ;
5705: GO 5783
// if side = side2 then
5707: LD_VAR 0 4
5711: PUSH
5712: LD_VAR 0 5
5716: EQUAL
5717: IFFALSE 5735
// Multiplayer_AddPoints ( side , gained_points ) else
5719: LD_VAR 0 4
5723: PPUSH
5724: LD_VAR 0 8
5728: PPUSH
5729: CALL 4701 0 2
5733: GO 5783
// begin if side then
5735: LD_VAR 0 4
5739: IFFALSE 5759
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5741: LD_VAR 0 4
5745: PPUSH
5746: LD_VAR 0 8
5750: PUSH
5751: LD_INT 2
5753: DIV
5754: PPUSH
5755: CALL 4701 0 2
// if side2 then
5759: LD_VAR 0 5
5763: IFFALSE 5783
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5765: LD_VAR 0 5
5769: PPUSH
5770: LD_VAR 0 8
5774: PUSH
5775: LD_INT 2
5777: DIV
5778: PPUSH
5779: CALL 4701 0 2
// end ; end ;
5783: LD_VAR 0 3
5787: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5788: LD_INT 0
5790: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5791: LD_VAR 0 1
5795: PPUSH
5796: LD_INT 2
5798: PPUSH
5799: CALL 4859 0 1
5803: PPUSH
5804: CALL 4701 0 2
// end ; end_of_file
5808: LD_VAR 0 2
5812: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5813: LD_INT 0
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
5821: PPUSH
5822: PPUSH
5823: PPUSH
// side_bot := side ;
5824: LD_ADDR_EXP 3
5828: PUSH
5829: LD_VAR 0 1
5833: ST_TO_ADDR
// techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5834: LD_ADDR_VAR 0 10
5838: PUSH
5839: LD_INT 11
5841: PUSH
5842: LD_INT 4
5844: PUSH
5845: LD_INT 3
5847: PUSH
5848: LD_INT 5
5850: PUSH
5851: LD_INT 66
5853: PUSH
5854: LD_INT 67
5856: PUSH
5857: LD_INT 53
5859: PUSH
5860: LD_INT 18
5862: PUSH
5863: LD_INT 40
5865: PUSH
5866: LD_INT 22
5868: PUSH
5869: LD_INT 72
5871: PUSH
5872: LD_INT 55
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: LIST
5888: ST_TO_ADDR
// for i in techs do
5889: LD_ADDR_VAR 0 3
5893: PUSH
5894: LD_VAR 0 10
5898: PUSH
5899: FOR_IN
5900: IFFALSE 5921
// SetTech ( i , side , state_researched ) ;
5902: LD_VAR 0 3
5906: PPUSH
5907: LD_VAR 0 1
5911: PPUSH
5912: LD_INT 2
5914: PPUSH
5915: CALL_OW 322
5919: GO 5899
5921: POP
5922: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
5923: LD_ADDR_VAR 0 8
5927: PUSH
5928: LD_INT 6
5930: PUSH
5931: LD_INT 7
5933: PUSH
5934: LD_INT 8
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: PUSH
5942: LD_OWVAR 67
5946: ARRAY
5947: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
5948: LD_INT 69
5950: PUSH
5951: EMPTY
5952: LIST
5953: PPUSH
5954: LD_INT 141
5956: PPUSH
5957: CALL_OW 169
// wait ( 1 ) ;
5961: LD_INT 1
5963: PPUSH
5964: CALL_OW 67
// uc_side := side ;
5968: LD_ADDR_OWVAR 20
5972: PUSH
5973: LD_VAR 0 1
5977: ST_TO_ADDR
// uc_nation := 2 ;
5978: LD_ADDR_OWVAR 21
5982: PUSH
5983: LD_INT 2
5985: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
5986: LD_ADDR_EXP 33
5990: PUSH
5991: LD_INT 94
5993: PPUSH
5994: LD_INT 35
5996: PPUSH
5997: LD_STRING dammam
5999: PPUSH
6000: LD_VAR 0 8
6004: PPUSH
6005: LD_INT 10000
6007: PUSH
6008: LD_INT 1000
6010: PUSH
6011: LD_INT 300
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: LIST
6018: PPUSH
6019: LD_INT 12
6021: PUSH
6022: LD_INT 4
6024: PUSH
6025: LD_INT 1
6027: NEG
6028: PUSH
6029: LD_INT 4
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: LIST
6036: LIST
6037: PPUSH
6038: CALL 18105 0 6
6042: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6043: LD_ADDR_EXP 34
6047: PUSH
6048: LD_INT 122
6050: PPUSH
6051: LD_INT 38
6053: PPUSH
6054: LD_STRING 
6056: PPUSH
6057: LD_VAR 0 8
6061: PPUSH
6062: LD_INT 1000
6064: PUSH
6065: LD_INT 100
6067: PUSH
6068: LD_INT 0
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: PPUSH
6076: LD_INT 12
6078: PUSH
6079: LD_INT 4
6081: PUSH
6082: LD_INT 2
6084: PUSH
6085: LD_INT 0
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: LIST
6092: LIST
6093: PPUSH
6094: CALL 18105 0 6
6098: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6099: LD_ADDR_EXP 31
6103: PUSH
6104: LD_INT 45
6106: PPUSH
6107: LD_INT 34
6109: PPUSH
6110: LD_STRING jeddah
6112: PPUSH
6113: LD_VAR 0 8
6117: PPUSH
6118: LD_INT 700
6120: PUSH
6121: LD_INT 300
6123: PUSH
6124: LD_INT 10
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: PPUSH
6132: LD_INT 12
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: LD_INT 3
6140: PUSH
6141: LD_INT 2
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: PPUSH
6150: CALL 18105 0 6
6154: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6155: LD_ADDR_EXP 32
6159: PUSH
6160: LD_INT 7
6162: PPUSH
6163: LD_INT 33
6165: PPUSH
6166: LD_STRING riyadh
6168: PPUSH
6169: LD_VAR 0 8
6173: PPUSH
6174: LD_INT 500
6176: PUSH
6177: LD_INT 60
6179: PUSH
6180: LD_INT 0
6182: PUSH
6183: EMPTY
6184: LIST
6185: LIST
6186: LIST
6187: PPUSH
6188: LD_INT 4
6190: PUSH
6191: LD_INT 2
6193: PUSH
6194: LD_INT 3
6196: PUSH
6197: LD_INT 1
6199: PUSH
6200: EMPTY
6201: LIST
6202: LIST
6203: LIST
6204: LIST
6205: PPUSH
6206: CALL 18105 0 6
6210: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6211: LD_ADDR_EXP 35
6215: PUSH
6216: LD_INT 69
6218: PPUSH
6219: LD_INT 36
6221: PPUSH
6222: LD_STRING 
6224: PPUSH
6225: LD_VAR 0 8
6229: PPUSH
6230: LD_INT 500
6232: PUSH
6233: LD_INT 50
6235: PUSH
6236: LD_INT 0
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: PPUSH
6244: LD_INT 11
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: LD_INT 3
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: PPUSH
6262: CALL 18105 0 6
6266: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6267: LD_ADDR_EXP 43
6271: PUSH
6272: LD_EXP 33
6276: PUSH
6277: LD_EXP 31
6281: PUSH
6282: LD_EXP 35
6286: PUSH
6287: LD_EXP 32
6291: PUSH
6292: LD_EXP 34
6296: PUSH
6297: EMPTY
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6304: LD_ADDR_OWVAR 37
6308: PUSH
6309: LD_INT 14
6311: ST_TO_ADDR
// vc_engine := engine_siberite ;
6312: LD_ADDR_OWVAR 39
6316: PUSH
6317: LD_INT 3
6319: ST_TO_ADDR
// vc_control := control_manual ;
6320: LD_ADDR_OWVAR 38
6324: PUSH
6325: LD_INT 1
6327: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6328: LD_ADDR_OWVAR 40
6332: PUSH
6333: LD_INT 31
6335: ST_TO_ADDR
// for i = 1 to 4 do
6336: LD_ADDR_VAR 0 3
6340: PUSH
6341: DOUBLE
6342: LD_INT 1
6344: DEC
6345: ST_TO_ADDR
6346: LD_INT 4
6348: PUSH
6349: FOR_TO
6350: IFFALSE 6619
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6352: LD_ADDR_VAR 0 5
6356: PUSH
6357: LD_INT 156
6359: PUSH
6360: LD_INT 15
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: PUSH
6367: LD_INT 12
6369: PUSH
6370: LD_INT 7
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: PUSH
6377: EMPTY
6378: LIST
6379: LIST
6380: PUSH
6381: LD_VAR 0 3
6385: PUSH
6386: LD_INT 2
6388: MOD
6389: PUSH
6390: LD_INT 1
6392: PLUS
6393: ARRAY
6394: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6395: LD_INT 0
6397: PPUSH
6398: LD_INT 3
6400: PPUSH
6401: LD_VAR 0 8
6405: PPUSH
6406: CALL_OW 380
// un := CreateVehicle ;
6410: LD_ADDR_VAR 0 6
6414: PUSH
6415: CALL_OW 45
6419: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6420: LD_VAR 0 6
6424: PPUSH
6425: LD_INT 0
6427: PPUSH
6428: LD_INT 5
6430: PPUSH
6431: CALL_OW 12
6435: PPUSH
6436: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6440: LD_VAR 0 6
6444: PPUSH
6445: LD_VAR 0 5
6449: PUSH
6450: LD_INT 1
6452: ARRAY
6453: PPUSH
6454: LD_VAR 0 5
6458: PUSH
6459: LD_INT 2
6461: ARRAY
6462: PPUSH
6463: LD_INT 6
6465: PPUSH
6466: LD_INT 0
6468: PPUSH
6469: CALL_OW 50
// un2 := CreateHuman ;
6473: LD_ADDR_VAR 0 7
6477: PUSH
6478: CALL_OW 44
6482: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6483: LD_VAR 0 7
6487: PPUSH
6488: LD_VAR 0 6
6492: PPUSH
6493: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6497: LD_ADDR_EXP 43
6501: PUSH
6502: LD_EXP 43
6506: PPUSH
6507: LD_VAR 0 3
6511: PUSH
6512: LD_INT 2
6514: MOD
6515: PUSH
6516: LD_INT 1
6518: PLUS
6519: PUSH
6520: LD_EXP 43
6524: PUSH
6525: LD_VAR 0 3
6529: PUSH
6530: LD_INT 2
6532: MOD
6533: PUSH
6534: LD_INT 1
6536: PLUS
6537: ARRAY
6538: PUSH
6539: LD_INT 1
6541: PLUS
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PPUSH
6547: LD_VAR 0 6
6551: PPUSH
6552: CALL 14774 0 3
6556: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6557: LD_ADDR_EXP 43
6561: PUSH
6562: LD_EXP 43
6566: PPUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 2
6574: MOD
6575: PUSH
6576: LD_INT 1
6578: PLUS
6579: PUSH
6580: LD_EXP 43
6584: PUSH
6585: LD_VAR 0 3
6589: PUSH
6590: LD_INT 2
6592: MOD
6593: PUSH
6594: LD_INT 1
6596: PLUS
6597: ARRAY
6598: PUSH
6599: LD_INT 1
6601: PLUS
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: PPUSH
6607: LD_VAR 0 7
6611: PPUSH
6612: CALL 14774 0 3
6616: ST_TO_ADDR
// end ;
6617: GO 6349
6619: POP
6620: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6621: LD_ADDR_VAR 0 3
6625: PUSH
6626: LD_INT 22
6628: PUSH
6629: LD_EXP 3
6633: PUSH
6634: EMPTY
6635: LIST
6636: LIST
6637: PUSH
6638: LD_INT 30
6640: PUSH
6641: LD_INT 31
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: PUSH
6648: LD_INT 58
6650: PUSH
6651: EMPTY
6652: LIST
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: PPUSH
6659: CALL_OW 69
6663: PUSH
6664: FOR_IN
6665: IFFALSE 6790
// begin if GetBase ( i ) then
6667: LD_VAR 0 3
6671: PPUSH
6672: CALL_OW 274
6676: IFFALSE 6680
// continue ;
6678: GO 6664
// d := GetDir ( i ) ;
6680: LD_ADDR_VAR 0 4
6684: PUSH
6685: LD_VAR 0 3
6689: PPUSH
6690: CALL_OW 254
6694: ST_TO_ADDR
// if d < 3 then
6695: LD_VAR 0 4
6699: PUSH
6700: LD_INT 3
6702: LESS
6703: IFFALSE 6721
// d := d + 3 else
6705: LD_ADDR_VAR 0 4
6709: PUSH
6710: LD_VAR 0 4
6714: PUSH
6715: LD_INT 3
6717: PLUS
6718: ST_TO_ADDR
6719: GO 6735
// d := d - 3 ;
6721: LD_ADDR_VAR 0 4
6725: PUSH
6726: LD_VAR 0 4
6730: PUSH
6731: LD_INT 3
6733: MINUS
6734: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6735: LD_INT 0
6737: PPUSH
6738: LD_INT 8
6740: PPUSH
6741: LD_VAR 0 8
6745: PPUSH
6746: CALL_OW 380
// un := CreateHuman ;
6750: LD_ADDR_VAR 0 6
6754: PUSH
6755: CALL_OW 44
6759: ST_TO_ADDR
// SetDir ( un , d ) ;
6760: LD_VAR 0 6
6764: PPUSH
6765: LD_VAR 0 4
6769: PPUSH
6770: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
6774: LD_VAR 0 6
6778: PPUSH
6779: LD_VAR 0 3
6783: PPUSH
6784: CALL_OW 52
// end ;
6788: GO 6664
6790: POP
6791: POP
// ar_force_tmp := [ ] ;
6792: LD_ADDR_EXP 36
6796: PUSH
6797: EMPTY
6798: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6799: LD_INT 1
6801: PPUSH
6802: LD_INT 1
6804: PPUSH
6805: LD_VAR 0 8
6809: PPUSH
6810: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6814: LD_ADDR_OWVAR 33
6818: PUSH
6819: LD_STRING SecondCharsGal
6821: ST_TO_ADDR
// hc_face_number := 4 ;
6822: LD_ADDR_OWVAR 34
6826: PUSH
6827: LD_INT 4
6829: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6830: LD_ADDR_EXP 36
6834: PUSH
6835: LD_EXP 36
6839: PPUSH
6840: LD_INT 1
6842: PPUSH
6843: CALL_OW 44
6847: PPUSH
6848: CALL_OW 1
6852: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6853: LD_INT 2
6855: PPUSH
6856: LD_INT 4
6858: PPUSH
6859: LD_VAR 0 8
6863: PPUSH
6864: CALL_OW 380
// hc_gallery := SecondCharsGal ;
6868: LD_ADDR_OWVAR 33
6872: PUSH
6873: LD_STRING SecondCharsGal
6875: ST_TO_ADDR
// hc_face_number := 15 ;
6876: LD_ADDR_OWVAR 34
6880: PUSH
6881: LD_INT 15
6883: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6884: LD_ADDR_EXP 36
6888: PUSH
6889: LD_EXP 36
6893: PPUSH
6894: LD_INT 2
6896: PPUSH
6897: CALL_OW 44
6901: PPUSH
6902: CALL_OW 1
6906: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6907: LD_INT 2
6909: PPUSH
6910: LD_INT 4
6912: PPUSH
6913: LD_VAR 0 8
6917: PPUSH
6918: CALL_OW 380
// hc_gallery :=  ;
6922: LD_ADDR_OWVAR 33
6926: PUSH
6927: LD_STRING 
6929: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
6930: LD_ADDR_EXP 36
6934: PUSH
6935: LD_EXP 36
6939: PPUSH
6940: LD_INT 3
6942: PPUSH
6943: CALL_OW 44
6947: PPUSH
6948: CALL_OW 1
6952: ST_TO_ADDR
// hc_sex := sex_male ;
6953: LD_ADDR_OWVAR 27
6957: PUSH
6958: LD_INT 1
6960: ST_TO_ADDR
// hc_class = 11 ;
6961: LD_ADDR_OWVAR 28
6965: PUSH
6966: LD_INT 11
6968: ST_TO_ADDR
// hc_gallery = sandar ;
6969: LD_ADDR_OWVAR 33
6973: PUSH
6974: LD_STRING sandar
6976: ST_TO_ADDR
// hc_face_number = 33 ;
6977: LD_ADDR_OWVAR 34
6981: PUSH
6982: LD_INT 33
6984: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
6985: LD_ADDR_OWVAR 26
6989: PUSH
6990: LD_STRING Thabit Muhair Saliba
6992: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
6993: LD_ADDR_OWVAR 31
6997: PUSH
6998: LD_INT 5
7000: PUSH
7001: LD_INT 5
7003: PUSH
7004: LD_INT 3
7006: PUSH
7007: LD_INT 3
7009: PUSH
7010: EMPTY
7011: LIST
7012: LIST
7013: LIST
7014: LIST
7015: ST_TO_ADDR
// Saliba = CreateHuman ;
7016: LD_ADDR_EXP 39
7020: PUSH
7021: CALL_OW 44
7025: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7026: LD_EXP 39
7030: PPUSH
7031: LD_INT 7
7033: PPUSH
7034: CALL_OW 52
// hc_name := Dietrich Gensher ;
7038: LD_ADDR_OWVAR 26
7042: PUSH
7043: LD_STRING Dietrich Gensher
7045: ST_TO_ADDR
// hc_class := 1 ;
7046: LD_ADDR_OWVAR 28
7050: PUSH
7051: LD_INT 1
7053: ST_TO_ADDR
// hc_gallery := sandar ;
7054: LD_ADDR_OWVAR 33
7058: PUSH
7059: LD_STRING sandar
7061: ST_TO_ADDR
// hc_face_number := 2 ;
7062: LD_ADDR_OWVAR 34
7066: PUSH
7067: LD_INT 2
7069: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7070: LD_ADDR_OWVAR 31
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 6
7080: PUSH
7081: LD_INT 5
7083: PUSH
7084: LD_INT 4
7086: PUSH
7087: EMPTY
7088: LIST
7089: LIST
7090: LIST
7091: LIST
7092: ST_TO_ADDR
// Gensher := CreateHuman ;
7093: LD_ADDR_EXP 40
7097: PUSH
7098: CALL_OW 44
7102: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7103: LD_EXP 40
7107: PPUSH
7108: LD_INT 94
7110: PPUSH
7111: CALL_OW 52
// InitHc ;
7115: CALL_OW 19
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7119: LD_ADDR_EXP 38
7123: PUSH
7124: EMPTY
7125: PUSH
7126: EMPTY
7127: PUSH
7128: EMPTY
7129: PUSH
7130: EMPTY
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: LIST
7136: LIST
7137: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7138: LD_ADDR_VAR 0 4
7142: PUSH
7143: DOUBLE
7144: LD_INT 1
7146: DEC
7147: ST_TO_ADDR
7148: LD_INT 3
7150: PUSH
7151: LD_INT 3
7153: PUSH
7154: LD_INT 4
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: LIST
7161: PUSH
7162: LD_OWVAR 67
7166: ARRAY
7167: PUSH
7168: FOR_TO
7169: IFFALSE 7387
// for i = 1 to 3 do
7171: LD_ADDR_VAR 0 3
7175: PUSH
7176: DOUBLE
7177: LD_INT 1
7179: DEC
7180: ST_TO_ADDR
7181: LD_INT 3
7183: PUSH
7184: FOR_TO
7185: IFFALSE 7383
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7187: LD_INT 14
7189: PPUSH
7190: LD_INT 3
7192: PUSH
7193: LD_INT 2
7195: PUSH
7196: EMPTY
7197: LIST
7198: LIST
7199: PUSH
7200: LD_INT 1
7202: PPUSH
7203: LD_INT 2
7205: PPUSH
7206: CALL_OW 12
7210: ARRAY
7211: PPUSH
7212: LD_INT 1
7214: PUSH
7215: LD_INT 5
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: PUSH
7222: LD_INT 1
7224: PPUSH
7225: LD_INT 2
7227: PPUSH
7228: CALL_OW 12
7232: ARRAY
7233: PPUSH
7234: LD_INT 25
7236: PUSH
7237: LD_INT 27
7239: PUSH
7240: LD_INT 26
7242: PUSH
7243: LD_INT 28
7245: PUSH
7246: EMPTY
7247: LIST
7248: LIST
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 1
7254: PPUSH
7255: LD_INT 4
7257: PPUSH
7258: CALL_OW 12
7262: ARRAY
7263: PPUSH
7264: LD_INT 100
7266: PPUSH
7267: CALL 14652 0 5
// un := CreateVehicle ;
7271: LD_ADDR_VAR 0 6
7275: PUSH
7276: CALL_OW 45
7280: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7281: LD_ADDR_EXP 38
7285: PUSH
7286: LD_EXP 38
7290: PPUSH
7291: LD_VAR 0 3
7295: PUSH
7296: LD_EXP 38
7300: PUSH
7301: LD_VAR 0 3
7305: ARRAY
7306: PUSH
7307: LD_INT 1
7309: PLUS
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: PPUSH
7315: LD_VAR 0 6
7319: PPUSH
7320: CALL 14774 0 3
7324: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7325: LD_VAR 0 6
7329: PPUSH
7330: LD_INT 0
7332: PPUSH
7333: LD_INT 5
7335: PPUSH
7336: CALL_OW 12
7340: PPUSH
7341: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7345: LD_VAR 0 6
7349: PPUSH
7350: LD_INT 20
7352: PUSH
7353: LD_INT 21
7355: PUSH
7356: LD_INT 22
7358: PUSH
7359: LD_INT 24
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: LIST
7367: PUSH
7368: LD_VAR 0 3
7372: ARRAY
7373: PPUSH
7374: LD_INT 0
7376: PPUSH
7377: CALL_OW 49
// end ;
7381: GO 7184
7383: POP
7384: POP
7385: GO 7168
7387: POP
7388: POP
// InitHc ;
7389: CALL_OW 19
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
7393: LD_ADDR_VAR 0 9
7397: PUSH
7398: LD_INT 22
7400: PUSH
7401: LD_INT 2
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: ST_TO_ADDR
// if tmp and side <> 2 then
7413: LD_VAR 0 9
7417: PUSH
7418: LD_VAR 0 1
7422: PUSH
7423: LD_INT 2
7425: NONEQUAL
7426: AND
7427: IFFALSE 7460
// begin for i in tmp do
7429: LD_ADDR_VAR 0 3
7433: PUSH
7434: LD_VAR 0 9
7438: PUSH
7439: FOR_IN
7440: IFFALSE 7458
// SetSide ( i , side ) ;
7442: LD_VAR 0 3
7446: PPUSH
7447: LD_VAR 0 1
7451: PPUSH
7452: CALL_OW 235
7456: GO 7439
7458: POP
7459: POP
// end ; end ;
7460: LD_VAR 0 2
7464: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7465: LD_INT 94
7467: PPUSH
7468: CALL_OW 302
7472: PUSH
7473: LD_INT 94
7475: PPUSH
7476: CALL_OW 255
7480: PUSH
7481: LD_EXP 3
7485: EQUAL
7486: AND
7487: IFFALSE 8196
7489: GO 7491
7491: DISABLE
7492: LD_INT 0
7494: PPUSH
7495: PPUSH
7496: PPUSH
7497: PPUSH
7498: PPUSH
7499: PPUSH
7500: PPUSH
7501: PPUSH
7502: PPUSH
7503: PPUSH
// begin enable ;
7504: ENABLE
// base := 1 ;
7505: LD_ADDR_VAR 0 4
7509: PUSH
7510: LD_INT 1
7512: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7513: LD_ADDR_VAR 0 7
7517: PUSH
7518: LD_INT 0
7520: PUSH
7521: LD_INT 0
7523: PUSH
7524: LD_INT 0
7526: PUSH
7527: LD_INT 0
7529: PUSH
7530: LD_INT 1
7532: PUSH
7533: LD_INT 0
7535: PUSH
7536: LD_INT 0
7538: PUSH
7539: LD_INT 0
7541: PUSH
7542: LD_INT 1
7544: PUSH
7545: LD_INT 0
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: LIST
7557: LIST
7558: LIST
7559: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7560: LD_ADDR_VAR 0 6
7564: PUSH
7565: LD_INT 28
7567: PUSH
7568: LD_INT 14
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 107
7577: PUSH
7578: LD_INT 119
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 127
7587: PUSH
7588: LD_INT 97
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: LD_INT 185
7597: PUSH
7598: LD_INT 127
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: LIST
7609: LIST
7610: ST_TO_ADDR
// target := 0 ;
7611: LD_ADDR_VAR 0 9
7615: PUSH
7616: LD_INT 0
7618: ST_TO_ADDR
// x := 0 ;
7619: LD_ADDR_VAR 0 3
7623: PUSH
7624: LD_INT 0
7626: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7627: LD_ADDR_VAR 0 5
7631: PUSH
7632: LD_INT 14
7634: PUSH
7635: LD_INT 1
7637: PUSH
7638: LD_INT 2
7640: PUSH
7641: LD_INT 28
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: PUSH
7650: LD_INT 14
7652: PUSH
7653: LD_INT 1
7655: PUSH
7656: LD_INT 2
7658: PUSH
7659: LD_INT 25
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 14
7670: PUSH
7671: LD_INT 1
7673: PUSH
7674: LD_INT 2
7676: PUSH
7677: LD_INT 28
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: LIST
7685: PUSH
7686: LD_INT 14
7688: PUSH
7689: LD_INT 1
7691: PUSH
7692: LD_INT 2
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: ST_TO_ADDR
// if Difficulty > 1 then
7710: LD_OWVAR 67
7714: PUSH
7715: LD_INT 1
7717: GREATER
7718: IFFALSE 7815
// for i = 1 to Difficulty + 2 do
7720: LD_ADDR_VAR 0 1
7724: PUSH
7725: DOUBLE
7726: LD_INT 1
7728: DEC
7729: ST_TO_ADDR
7730: LD_OWVAR 67
7734: PUSH
7735: LD_INT 2
7737: PLUS
7738: PUSH
7739: FOR_TO
7740: IFFALSE 7813
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7742: LD_ADDR_VAR 0 5
7746: PUSH
7747: LD_VAR 0 5
7751: PPUSH
7752: LD_VAR 0 5
7756: PUSH
7757: LD_INT 1
7759: PLUS
7760: PPUSH
7761: LD_INT 14
7763: PUSH
7764: LD_INT 1
7766: PUSH
7767: LD_INT 2
7769: PUSH
7770: LD_INT 28
7772: PUSH
7773: LD_INT 27
7775: PUSH
7776: LD_INT 27
7778: PUSH
7779: LD_INT 29
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: LIST
7786: LIST
7787: PUSH
7788: LD_INT 1
7790: PPUSH
7791: LD_INT 4
7793: PPUSH
7794: CALL_OW 12
7798: ARRAY
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: PPUSH
7806: CALL_OW 2
7810: ST_TO_ADDR
7811: GO 7739
7813: POP
7814: POP
// MC_SetProduceList ( base , tmp ) ;
7815: LD_VAR 0 4
7819: PPUSH
7820: LD_VAR 0 5
7824: PPUSH
7825: CALL 75589 0 2
// repeat wait ( 0 0$1 ) ;
7829: LD_INT 35
7831: PPUSH
7832: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
7836: LD_VAR 0 4
7840: PPUSH
7841: CALL 75985 0 1
7845: PUSH
7846: LD_INT 0
7848: EQUAL
7849: IFFALSE 7829
// wait ( 0 0$10 ) ;
7851: LD_INT 350
7853: PPUSH
7854: CALL_OW 67
// for i = 1 to coords do
7858: LD_ADDR_VAR 0 1
7862: PUSH
7863: DOUBLE
7864: LD_INT 1
7866: DEC
7867: ST_TO_ADDR
7868: LD_VAR 0 6
7872: PUSH
7873: FOR_TO
7874: IFFALSE 7962
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7876: LD_ADDR_VAR 0 2
7880: PUSH
7881: LD_EXP 3
7885: PPUSH
7886: LD_VAR 0 6
7890: PUSH
7891: LD_VAR 0 1
7895: ARRAY
7896: PUSH
7897: LD_INT 1
7899: ARRAY
7900: PPUSH
7901: LD_VAR 0 6
7905: PUSH
7906: LD_VAR 0 1
7910: ARRAY
7911: PUSH
7912: LD_INT 2
7914: ARRAY
7915: PPUSH
7916: LD_INT 35
7918: PPUSH
7919: CALL 15670 0 4
7923: PUSH
7924: LD_INT 4
7926: ARRAY
7927: ST_TO_ADDR
// if t > x then
7928: LD_VAR 0 2
7932: PUSH
7933: LD_VAR 0 3
7937: GREATER
7938: IFFALSE 7960
// begin x := t ;
7940: LD_ADDR_VAR 0 3
7944: PUSH
7945: LD_VAR 0 2
7949: ST_TO_ADDR
// target := i ;
7950: LD_ADDR_VAR 0 9
7954: PUSH
7955: LD_VAR 0 1
7959: ST_TO_ADDR
// end ; end ;
7960: GO 7873
7962: POP
7963: POP
// case target of 1 :
7964: LD_VAR 0 9
7968: PUSH
7969: LD_INT 1
7971: DOUBLE
7972: EQUAL
7973: IFTRUE 7977
7975: GO 8009
7977: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
7978: LD_ADDR_VAR 0 10
7982: PUSH
7983: LD_INT 60
7985: PUSH
7986: LD_INT 8
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 28
7995: PUSH
7996: LD_INT 15
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: ST_TO_ADDR
8007: GO 8130
8009: LD_INT 2
8011: DOUBLE
8012: EQUAL
8013: IFTRUE 8017
8015: GO 8049
8017: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8018: LD_ADDR_VAR 0 10
8022: PUSH
8023: LD_INT 52
8025: PUSH
8026: LD_INT 11
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 76
8035: PUSH
8036: LD_INT 90
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: ST_TO_ADDR
8047: GO 8130
8049: LD_INT 3
8051: DOUBLE
8052: EQUAL
8053: IFTRUE 8057
8055: GO 8089
8057: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8058: LD_ADDR_VAR 0 10
8062: PUSH
8063: LD_INT 129
8065: PUSH
8066: LD_INT 66
8068: PUSH
8069: EMPTY
8070: LIST
8071: LIST
8072: PUSH
8073: LD_INT 130
8075: PUSH
8076: LD_INT 97
8078: PUSH
8079: EMPTY
8080: LIST
8081: LIST
8082: PUSH
8083: EMPTY
8084: LIST
8085: LIST
8086: ST_TO_ADDR
8087: GO 8130
8089: LD_INT 4
8091: DOUBLE
8092: EQUAL
8093: IFTRUE 8097
8095: GO 8129
8097: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8098: LD_ADDR_VAR 0 10
8102: PUSH
8103: LD_INT 156
8105: PUSH
8106: LD_INT 87
8108: PUSH
8109: EMPTY
8110: LIST
8111: LIST
8112: PUSH
8113: LD_INT 183
8115: PUSH
8116: LD_INT 127
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: ST_TO_ADDR
8127: GO 8130
8129: POP
// if not _target then
8130: LD_VAR 0 10
8134: NOT
8135: IFFALSE 8166
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8137: LD_ADDR_VAR 0 10
8141: PUSH
8142: LD_INT 52
8144: PUSH
8145: LD_INT 11
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 76
8154: PUSH
8155: LD_INT 90
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8166: LD_VAR 0 4
8170: PPUSH
8171: LD_EXP 62
8175: PUSH
8176: LD_VAR 0 4
8180: ARRAY
8181: PPUSH
8182: LD_VAR 0 10
8186: PPUSH
8187: LD_VAR 0 7
8191: PPUSH
8192: CALL 75822 0 4
// end ;
8196: PPOPN 10
8198: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8199: LD_INT 45
8201: PPUSH
8202: CALL_OW 302
8206: PUSH
8207: LD_INT 45
8209: PPUSH
8210: CALL_OW 255
8214: PUSH
8215: LD_EXP 3
8219: EQUAL
8220: AND
8221: PUSH
8222: LD_EXP 26
8226: PUSH
8227: LD_INT 3
8229: EQUAL
8230: PUSH
8231: LD_INT 94
8233: PPUSH
8234: CALL_OW 301
8238: OR
8239: PUSH
8240: LD_INT 94
8242: PPUSH
8243: CALL_OW 255
8247: PUSH
8248: LD_EXP 3
8252: NONEQUAL
8253: OR
8254: AND
8255: IFFALSE 8841
8257: GO 8259
8259: DISABLE
8260: LD_INT 0
8262: PPUSH
8263: PPUSH
8264: PPUSH
8265: PPUSH
8266: PPUSH
8267: PPUSH
8268: PPUSH
8269: PPUSH
8270: PPUSH
8271: PPUSH
// begin enable ;
8272: ENABLE
// base := 2 ;
8273: LD_ADDR_VAR 0 4
8277: PUSH
8278: LD_INT 2
8280: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8281: LD_ADDR_VAR 0 7
8285: PUSH
8286: LD_INT 0
8288: PUSH
8289: LD_INT 0
8291: PUSH
8292: LD_INT 0
8294: PUSH
8295: LD_INT 0
8297: PUSH
8298: LD_INT 1
8300: PUSH
8301: LD_INT 0
8303: PUSH
8304: LD_INT 0
8306: PUSH
8307: LD_INT 0
8309: PUSH
8310: LD_INT 1
8312: PUSH
8313: LD_INT 0
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: LIST
8321: LIST
8322: LIST
8323: LIST
8324: LIST
8325: LIST
8326: LIST
8327: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8328: LD_ADDR_VAR 0 6
8332: PUSH
8333: LD_INT 101
8335: PUSH
8336: LD_INT 110
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PUSH
8343: LD_INT 100
8345: PUSH
8346: LD_INT 21
8348: PUSH
8349: EMPTY
8350: LIST
8351: LIST
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: ST_TO_ADDR
// target := 0 ;
8357: LD_ADDR_VAR 0 9
8361: PUSH
8362: LD_INT 0
8364: ST_TO_ADDR
// x := 0 ;
8365: LD_ADDR_VAR 0 3
8369: PUSH
8370: LD_INT 0
8372: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8373: LD_ADDR_VAR 0 5
8377: PUSH
8378: LD_INT 14
8380: PUSH
8381: LD_INT 1
8383: PUSH
8384: LD_INT 2
8386: PUSH
8387: LD_INT 28
8389: PUSH
8390: EMPTY
8391: LIST
8392: LIST
8393: LIST
8394: LIST
8395: PUSH
8396: LD_INT 14
8398: PUSH
8399: LD_INT 1
8401: PUSH
8402: LD_INT 2
8404: PUSH
8405: LD_INT 25
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 14
8416: PUSH
8417: LD_INT 1
8419: PUSH
8420: LD_INT 2
8422: PUSH
8423: LD_INT 28
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: LIST
8430: LIST
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: LIST
8436: ST_TO_ADDR
// if Difficulty > 1 then
8437: LD_OWVAR 67
8441: PUSH
8442: LD_INT 1
8444: GREATER
8445: IFFALSE 8540
// for i = 1 to Difficulty + 1 do
8447: LD_ADDR_VAR 0 1
8451: PUSH
8452: DOUBLE
8453: LD_INT 1
8455: DEC
8456: ST_TO_ADDR
8457: LD_OWVAR 67
8461: PUSH
8462: LD_INT 1
8464: PLUS
8465: PUSH
8466: FOR_TO
8467: IFFALSE 8538
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8469: LD_ADDR_VAR 0 5
8473: PUSH
8474: LD_VAR 0 5
8478: PPUSH
8479: LD_VAR 0 5
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: PPUSH
8488: LD_INT 14
8490: PUSH
8491: LD_INT 1
8493: PUSH
8494: LD_INT 2
8496: PUSH
8497: LD_INT 28
8499: PUSH
8500: LD_INT 27
8502: PUSH
8503: LD_INT 27
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: LIST
8510: PUSH
8511: LD_VAR 0 1
8515: PUSH
8516: LD_INT 2
8518: MOD
8519: PUSH
8520: LD_INT 1
8522: PLUS
8523: ARRAY
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: LIST
8529: LIST
8530: PPUSH
8531: CALL_OW 2
8535: ST_TO_ADDR
8536: GO 8466
8538: POP
8539: POP
// MC_SetProduceList ( base , tmp ) ;
8540: LD_VAR 0 4
8544: PPUSH
8545: LD_VAR 0 5
8549: PPUSH
8550: CALL 75589 0 2
// repeat wait ( 0 0$1 ) ;
8554: LD_INT 35
8556: PPUSH
8557: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
8561: LD_VAR 0 4
8565: PPUSH
8566: CALL 75985 0 1
8570: PUSH
8571: LD_INT 0
8573: EQUAL
8574: IFFALSE 8554
// wait ( 0 0$10 ) ;
8576: LD_INT 350
8578: PPUSH
8579: CALL_OW 67
// for i = 1 to coords do
8583: LD_ADDR_VAR 0 1
8587: PUSH
8588: DOUBLE
8589: LD_INT 1
8591: DEC
8592: ST_TO_ADDR
8593: LD_VAR 0 6
8597: PUSH
8598: FOR_TO
8599: IFFALSE 8687
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8601: LD_ADDR_VAR 0 2
8605: PUSH
8606: LD_EXP 3
8610: PPUSH
8611: LD_VAR 0 6
8615: PUSH
8616: LD_VAR 0 1
8620: ARRAY
8621: PUSH
8622: LD_INT 1
8624: ARRAY
8625: PPUSH
8626: LD_VAR 0 6
8630: PUSH
8631: LD_VAR 0 1
8635: ARRAY
8636: PUSH
8637: LD_INT 2
8639: ARRAY
8640: PPUSH
8641: LD_INT 35
8643: PPUSH
8644: CALL 15670 0 4
8648: PUSH
8649: LD_INT 4
8651: ARRAY
8652: ST_TO_ADDR
// if t > x then
8653: LD_VAR 0 2
8657: PUSH
8658: LD_VAR 0 3
8662: GREATER
8663: IFFALSE 8685
// begin x := t ;
8665: LD_ADDR_VAR 0 3
8669: PUSH
8670: LD_VAR 0 2
8674: ST_TO_ADDR
// target := i ;
8675: LD_ADDR_VAR 0 9
8679: PUSH
8680: LD_VAR 0 1
8684: ST_TO_ADDR
// end ; end ;
8685: GO 8598
8687: POP
8688: POP
// case target of 1 :
8689: LD_VAR 0 9
8693: PUSH
8694: LD_INT 1
8696: DOUBLE
8697: EQUAL
8698: IFTRUE 8702
8700: GO 8734
8702: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8703: LD_ADDR_VAR 0 10
8707: PUSH
8708: LD_INT 49
8710: PUSH
8711: LD_INT 35
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: PUSH
8718: LD_INT 76
8720: PUSH
8721: LD_INT 90
8723: PUSH
8724: EMPTY
8725: LIST
8726: LIST
8727: PUSH
8728: EMPTY
8729: LIST
8730: LIST
8731: ST_TO_ADDR
8732: GO 8775
8734: LD_INT 2
8736: DOUBLE
8737: EQUAL
8738: IFTRUE 8742
8740: GO 8774
8742: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8743: LD_ADDR_VAR 0 10
8747: PUSH
8748: LD_INT 79
8750: PUSH
8751: LD_INT 13
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: PUSH
8758: LD_INT 100
8760: PUSH
8761: LD_INT 22
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: ST_TO_ADDR
8772: GO 8775
8774: POP
// if not _target then
8775: LD_VAR 0 10
8779: NOT
8780: IFFALSE 8811
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8782: LD_ADDR_VAR 0 10
8786: PUSH
8787: LD_INT 49
8789: PUSH
8790: LD_INT 35
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 76
8799: PUSH
8800: LD_INT 90
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8811: LD_VAR 0 4
8815: PPUSH
8816: LD_EXP 62
8820: PUSH
8821: LD_VAR 0 4
8825: ARRAY
8826: PPUSH
8827: LD_VAR 0 10
8831: PPUSH
8832: LD_VAR 0 7
8836: PPUSH
8837: CALL 75822 0 4
// end ; end_of_file
8841: PPOPN 10
8843: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8844: LD_INT 0
8846: PPUSH
8847: PPUSH
// begin if artifact_get then
8848: LD_EXP 4
8852: IFFALSE 8856
// exit ;
8854: GO 8878
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8856: LD_VAR 0 1
8860: PPUSH
8861: CALL_OW 255
8865: PPUSH
8866: CALL 5788 0 1
// artifact_get := true ;
8870: LD_ADDR_EXP 4
8874: PUSH
8875: LD_INT 1
8877: ST_TO_ADDR
// end ;
8878: PPOPN 4
8880: END
// on UnitDestroyed ( un ) do var i , side ;
8881: LD_INT 0
8883: PPUSH
8884: PPUSH
// begin side := GetSide ( un ) ;
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: LD_VAR 0 1
8894: PPUSH
8895: CALL_OW 255
8899: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8900: LD_VAR 0 3
8904: PUSH
8905: LD_EXP 69
8909: IN
8910: NOT
8911: PUSH
8912: LD_EXP 7
8916: PUSH
8917: LD_VAR 0 3
8921: ARRAY
8922: AND
8923: IFFALSE 8949
// if GetType ( un ) = unit_human then
8925: LD_VAR 0 1
8929: PPUSH
8930: CALL_OW 247
8934: PUSH
8935: LD_INT 1
8937: EQUAL
8938: IFFALSE 8949
// MultiplayerEvent_HumanLost ( side ) ;
8940: LD_VAR 0 3
8944: PPUSH
8945: CALL 5428 0 1
// if side in mc_sides then
8949: LD_VAR 0 3
8953: PUSH
8954: LD_EXP 69
8958: IN
8959: IFFALSE 9004
// if un <> Gensher then
8961: LD_VAR 0 1
8965: PUSH
8966: LD_EXP 40
8970: NONEQUAL
8971: IFFALSE 8987
// MultiplayerEvent_UnitKilled ( un , false ) else
8973: LD_VAR 0 1
8977: PPUSH
8978: LD_INT 0
8980: PPUSH
8981: CALL 5542 0 2
8985: GO 9004
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
8987: LD_VAR 0 1
8991: PPUSH
8992: LD_INT 5
8994: PPUSH
8995: CALL 4859 0 1
8999: PPUSH
9000: CALL 5542 0 2
// if multi_commanders and multi_custom_commanders then
9004: LD_EXP 24
9008: PUSH
9009: LD_EXP 16
9013: AND
9014: IFFALSE 9076
// if un in multi_commanders then
9016: LD_VAR 0 1
9020: PUSH
9021: LD_EXP 24
9025: IN
9026: IFFALSE 9076
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9028: LD_ADDR_EXP 25
9032: PUSH
9033: LD_EXP 25
9037: PPUSH
9038: LD_VAR 0 3
9042: PPUSH
9043: LD_INT 1
9045: PPUSH
9046: CALL_OW 1
9050: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9051: LD_ADDR_EXP 24
9055: PUSH
9056: LD_EXP 24
9060: PUSH
9061: LD_VAR 0 1
9065: DIFF
9066: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9067: LD_VAR 0 3
9071: PPUSH
9072: CALL 4892 0 1
// end ; MCE_UnitDestroyed ( un ) ;
9076: LD_VAR 0 1
9080: PPUSH
9081: CALL 79079 0 1
// end ;
9085: PPOPN 3
9087: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9088: LD_VAR 0 1
9092: PPUSH
9093: LD_VAR 0 2
9097: PPUSH
9098: CALL 81411 0 2
// end ;
9102: PPOPN 2
9104: END
// on BuildingComplete ( building ) do var i , j ;
9105: LD_INT 0
9107: PPUSH
9108: PPUSH
// begin if GetSide ( building ) in mc_sides then
9109: LD_VAR 0 1
9113: PPUSH
9114: CALL_OW 255
9118: PUSH
9119: LD_EXP 69
9123: IN
9124: IFFALSE 9150
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9126: LD_VAR 0 1
9130: PPUSH
9131: CALL_OW 255
9135: PPUSH
9136: LD_VAR 0 1
9140: PPUSH
9141: CALL_OW 266
9145: PPUSH
9146: CALL 5472 0 2
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9150: LD_VAR 0 1
9154: PPUSH
9155: CALL_OW 266
9159: PUSH
9160: LD_INT 0
9162: EQUAL
9163: PUSH
9164: LD_VAR 0 1
9168: PPUSH
9169: CALL_OW 255
9173: PUSH
9174: LD_EXP 69
9178: IN
9179: NOT
9180: AND
9181: PUSH
9182: LD_EXP 5
9186: AND
9187: IFFALSE 9225
// begin SetBName ( building , base_names [ 1 ] ) ;
9189: LD_VAR 0 1
9193: PPUSH
9194: LD_EXP 5
9198: PUSH
9199: LD_INT 1
9201: ARRAY
9202: PPUSH
9203: CALL_OW 500
// base_names := Delete ( base_names , 1 ) ;
9207: LD_ADDR_EXP 5
9211: PUSH
9212: LD_EXP 5
9216: PPUSH
9217: LD_INT 1
9219: PPUSH
9220: CALL_OW 3
9224: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9225: LD_VAR 0 1
9229: PPUSH
9230: CALL 80720 0 1
// end ;
9234: PPOPN 3
9236: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9237: LD_VAR 0 1
9241: PPUSH
9242: LD_VAR 0 2
9246: PPUSH
9247: CALL 78775 0 2
// end ;
9251: PPOPN 2
9253: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9254: LD_VAR 0 1
9258: PPUSH
9259: LD_VAR 0 2
9263: PPUSH
9264: LD_VAR 0 3
9268: PPUSH
9269: LD_VAR 0 4
9273: PPUSH
9274: LD_VAR 0 5
9278: PPUSH
9279: CALL 78395 0 5
// end ;
9283: PPOPN 5
9285: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9286: LD_INT 0
9288: PPUSH
9289: PPUSH
9290: PPUSH
// begin side := GetSide ( vehicle ) ;
9291: LD_ADDR_VAR 0 4
9295: PUSH
9296: LD_VAR 0 1
9300: PPUSH
9301: CALL_OW 255
9305: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9306: LD_VAR 0 4
9310: PUSH
9311: LD_EXP 69
9315: IN
9316: NOT
9317: PUSH
9318: LD_EXP 7
9322: PUSH
9323: LD_VAR 0 4
9327: ARRAY
9328: AND
9329: IFFALSE 9340
// MultiplayerEvent_Produced ( side ) ;
9331: LD_VAR 0 4
9335: PPUSH
9336: CALL 5384 0 1
// MCE_VehicleConstructed ( vehicle , factory ) ;
9340: LD_VAR 0 1
9344: PPUSH
9345: LD_VAR 0 2
9349: PPUSH
9350: CALL 77948 0 2
// end ;
9354: PPOPN 5
9356: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9357: LD_VAR 0 1
9361: PPUSH
9362: LD_VAR 0 2
9366: PPUSH
9367: LD_VAR 0 3
9371: PPUSH
9372: LD_VAR 0 4
9376: PPUSH
9377: CALL 77786 0 4
// end ;
9381: PPOPN 4
9383: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9384: LD_VAR 0 1
9388: PPUSH
9389: LD_VAR 0 2
9393: PPUSH
9394: LD_VAR 0 3
9398: PPUSH
9399: CALL 77561 0 3
// end ;
9403: PPOPN 3
9405: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9406: LD_VAR 0 1
9410: PPUSH
9411: LD_VAR 0 2
9415: PPUSH
9416: CALL 77446 0 2
// end ;
9420: PPOPN 2
9422: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: LD_VAR 0 2
9432: PPUSH
9433: CALL 81706 0 2
// end ;
9437: PPOPN 2
9439: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9440: LD_VAR 0 1
9444: PPUSH
9445: LD_VAR 0 2
9449: PPUSH
9450: LD_VAR 0 3
9454: PPUSH
9455: LD_VAR 0 4
9459: PPUSH
9460: CALL 81922 0 4
// end ; end_of_file
9464: PPOPN 4
9466: END
// every 0 0$20 trigger game do
9467: LD_EXP 2
9471: IFFALSE 9516
9473: GO 9475
9475: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9476: LD_INT 7
9478: PUSH
9479: LD_INT 6
9481: PUSH
9482: LD_INT 4
9484: PUSH
9485: LD_INT 6
9487: PUSH
9488: EMPTY
9489: LIST
9490: LIST
9491: LIST
9492: LIST
9493: PPUSH
9494: LD_EXP 21
9498: PUSH
9499: LD_INT 2
9501: ARRAY
9502: PPUSH
9503: LD_EXP 21
9507: PUSH
9508: LD_INT 1
9510: ARRAY
9511: PPUSH
9512: CALL 9517 0 3
9516: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9517: LD_INT 0
9519: PPUSH
9520: PPUSH
9521: PPUSH
9522: PPUSH
// if not areas then
9523: LD_VAR 0 1
9527: NOT
9528: IFFALSE 9532
// exit ;
9530: GO 9807
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9532: LD_ADDR_VAR 0 7
9536: PUSH
9537: LD_INT 31
9539: PUSH
9540: LD_INT 32
9542: PUSH
9543: LD_INT 30
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: ST_TO_ADDR
// repeat wait ( time ) ;
9551: LD_VAR 0 2
9555: PPUSH
9556: CALL_OW 67
// x := 5 ;
9560: LD_ADDR_VAR 0 6
9564: PUSH
9565: LD_INT 5
9567: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9568: LD_OWVAR 1
9572: PUSH
9573: LD_INT 42000
9575: PUSH
9576: LD_INT 37800
9578: PUSH
9579: LD_INT 29400
9581: PUSH
9582: EMPTY
9583: LIST
9584: LIST
9585: LIST
9586: PUSH
9587: LD_OWVAR 67
9591: ARRAY
9592: LESS
9593: IFFALSE 9665
// begin for i = 1 to multi_sides do
9595: LD_ADDR_VAR 0 5
9599: PUSH
9600: DOUBLE
9601: LD_INT 1
9603: DEC
9604: ST_TO_ADDR
9605: LD_EXP 7
9609: PUSH
9610: FOR_TO
9611: IFFALSE 9656
// if multi_sides [ i ] then
9613: LD_EXP 7
9617: PUSH
9618: LD_VAR 0 5
9622: ARRAY
9623: IFFALSE 9654
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9625: LD_VAR 0 6
9629: PPUSH
9630: LD_VAR 0 7
9634: PUSH
9635: LD_EXP 7
9639: PUSH
9640: LD_VAR 0 5
9644: ARRAY
9645: ARRAY
9646: PPUSH
9647: LD_INT 1
9649: PPUSH
9650: CALL_OW 55
9654: GO 9610
9656: POP
9657: POP
// wait ( 0 0$6 ) ;
9658: LD_INT 210
9660: PPUSH
9661: CALL_OW 67
// end ; for i in areas do
9665: LD_ADDR_VAR 0 5
9669: PUSH
9670: LD_VAR 0 1
9674: PUSH
9675: FOR_IN
9676: IFFALSE 9704
// begin wait ( 0 0$6 ) ;
9678: LD_INT 210
9680: PPUSH
9681: CALL_OW 67
// CreateCratesArea ( x , i , true ) ;
9685: LD_VAR 0 6
9689: PPUSH
9690: LD_VAR 0 5
9694: PPUSH
9695: LD_INT 1
9697: PPUSH
9698: CALL_OW 55
// end ;
9702: GO 9675
9704: POP
9705: POP
// time := time + 0 0$2 ;
9706: LD_ADDR_VAR 0 2
9710: PUSH
9711: LD_VAR 0 2
9715: PUSH
9716: LD_INT 70
9718: PLUS
9719: ST_TO_ADDR
// amount := amount - x * 10 ;
9720: LD_ADDR_VAR 0 3
9724: PUSH
9725: LD_VAR 0 3
9729: PUSH
9730: LD_VAR 0 6
9734: PUSH
9735: LD_INT 10
9737: MUL
9738: MINUS
9739: ST_TO_ADDR
// x := x - 1 ;
9740: LD_ADDR_VAR 0 6
9744: PUSH
9745: LD_VAR 0 6
9749: PUSH
9750: LD_INT 1
9752: MINUS
9753: ST_TO_ADDR
// if x = 0 then
9754: LD_VAR 0 6
9758: PUSH
9759: LD_INT 0
9761: EQUAL
9762: IFFALSE 9772
// x := 5 ;
9764: LD_ADDR_VAR 0 6
9768: PUSH
9769: LD_INT 5
9771: ST_TO_ADDR
// if time > 4 4$00 then
9772: LD_VAR 0 2
9776: PUSH
9777: LD_INT 8400
9779: GREATER
9780: IFFALSE 9790
// time := 0 0$40 ;
9782: LD_ADDR_VAR 0 2
9786: PUSH
9787: LD_INT 1400
9789: ST_TO_ADDR
// until not game or amount <= 0 ;
9790: LD_EXP 2
9794: NOT
9795: PUSH
9796: LD_VAR 0 3
9800: PUSH
9801: LD_INT 0
9803: LESSEQUAL
9804: OR
9805: IFFALSE 9551
// end ; end_of_file
9807: LD_VAR 0 4
9811: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9812: LD_INT 0
9814: PPUSH
9815: PPUSH
// if exist_mode then
9816: LD_VAR 0 2
9820: IFFALSE 9845
// unit := CreateCharacter ( prefix & ident ) else
9822: LD_ADDR_VAR 0 5
9826: PUSH
9827: LD_VAR 0 3
9831: PUSH
9832: LD_VAR 0 1
9836: STR
9837: PPUSH
9838: CALL_OW 34
9842: ST_TO_ADDR
9843: GO 9860
// unit := NewCharacter ( ident ) ;
9845: LD_ADDR_VAR 0 5
9849: PUSH
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 25
9859: ST_TO_ADDR
// result := unit ;
9860: LD_ADDR_VAR 0 4
9864: PUSH
9865: LD_VAR 0 5
9869: ST_TO_ADDR
// end ;
9870: LD_VAR 0 4
9874: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9875: LD_INT 0
9877: PPUSH
9878: PPUSH
// if not side or not nation then
9879: LD_VAR 0 1
9883: NOT
9884: PUSH
9885: LD_VAR 0 2
9889: NOT
9890: OR
9891: IFFALSE 9895
// exit ;
9893: GO 10663
// case nation of nation_american :
9895: LD_VAR 0 2
9899: PUSH
9900: LD_INT 1
9902: DOUBLE
9903: EQUAL
9904: IFTRUE 9908
9906: GO 10122
9908: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9909: LD_ADDR_VAR 0 4
9913: PUSH
9914: LD_INT 35
9916: PUSH
9917: LD_INT 45
9919: PUSH
9920: LD_INT 46
9922: PUSH
9923: LD_INT 47
9925: PUSH
9926: LD_INT 82
9928: PUSH
9929: LD_INT 83
9931: PUSH
9932: LD_INT 84
9934: PUSH
9935: LD_INT 85
9937: PUSH
9938: LD_INT 86
9940: PUSH
9941: LD_INT 1
9943: PUSH
9944: LD_INT 2
9946: PUSH
9947: LD_INT 6
9949: PUSH
9950: LD_INT 15
9952: PUSH
9953: LD_INT 16
9955: PUSH
9956: LD_INT 7
9958: PUSH
9959: LD_INT 12
9961: PUSH
9962: LD_INT 13
9964: PUSH
9965: LD_INT 10
9967: PUSH
9968: LD_INT 14
9970: PUSH
9971: LD_INT 20
9973: PUSH
9974: LD_INT 21
9976: PUSH
9977: LD_INT 22
9979: PUSH
9980: LD_INT 25
9982: PUSH
9983: LD_INT 32
9985: PUSH
9986: LD_INT 27
9988: PUSH
9989: LD_INT 36
9991: PUSH
9992: LD_INT 69
9994: PUSH
9995: LD_INT 39
9997: PUSH
9998: LD_INT 34
10000: PUSH
10001: LD_INT 40
10003: PUSH
10004: LD_INT 48
10006: PUSH
10007: LD_INT 49
10009: PUSH
10010: LD_INT 50
10012: PUSH
10013: LD_INT 51
10015: PUSH
10016: LD_INT 52
10018: PUSH
10019: LD_INT 53
10021: PUSH
10022: LD_INT 54
10024: PUSH
10025: LD_INT 55
10027: PUSH
10028: LD_INT 56
10030: PUSH
10031: LD_INT 57
10033: PUSH
10034: LD_INT 58
10036: PUSH
10037: LD_INT 59
10039: PUSH
10040: LD_INT 60
10042: PUSH
10043: LD_INT 61
10045: PUSH
10046: LD_INT 62
10048: PUSH
10049: LD_INT 80
10051: PUSH
10052: LD_INT 82
10054: PUSH
10055: LD_INT 83
10057: PUSH
10058: LD_INT 84
10060: PUSH
10061: LD_INT 85
10063: PUSH
10064: LD_INT 86
10066: PUSH
10067: EMPTY
10068: LIST
10069: LIST
10070: LIST
10071: LIST
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: LIST
10078: LIST
10079: LIST
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: LIST
10096: LIST
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: ST_TO_ADDR
10120: GO 10587
10122: LD_INT 2
10124: DOUBLE
10125: EQUAL
10126: IFTRUE 10130
10128: GO 10356
10130: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10131: LD_ADDR_VAR 0 4
10135: PUSH
10136: LD_INT 35
10138: PUSH
10139: LD_INT 45
10141: PUSH
10142: LD_INT 46
10144: PUSH
10145: LD_INT 47
10147: PUSH
10148: LD_INT 82
10150: PUSH
10151: LD_INT 83
10153: PUSH
10154: LD_INT 84
10156: PUSH
10157: LD_INT 85
10159: PUSH
10160: LD_INT 87
10162: PUSH
10163: LD_INT 70
10165: PUSH
10166: LD_INT 1
10168: PUSH
10169: LD_INT 11
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 4
10177: PUSH
10178: LD_INT 5
10180: PUSH
10181: LD_INT 6
10183: PUSH
10184: LD_INT 15
10186: PUSH
10187: LD_INT 18
10189: PUSH
10190: LD_INT 7
10192: PUSH
10193: LD_INT 17
10195: PUSH
10196: LD_INT 8
10198: PUSH
10199: LD_INT 20
10201: PUSH
10202: LD_INT 21
10204: PUSH
10205: LD_INT 22
10207: PUSH
10208: LD_INT 72
10210: PUSH
10211: LD_INT 26
10213: PUSH
10214: LD_INT 69
10216: PUSH
10217: LD_INT 39
10219: PUSH
10220: LD_INT 40
10222: PUSH
10223: LD_INT 41
10225: PUSH
10226: LD_INT 42
10228: PUSH
10229: LD_INT 43
10231: PUSH
10232: LD_INT 48
10234: PUSH
10235: LD_INT 49
10237: PUSH
10238: LD_INT 50
10240: PUSH
10241: LD_INT 51
10243: PUSH
10244: LD_INT 52
10246: PUSH
10247: LD_INT 53
10249: PUSH
10250: LD_INT 54
10252: PUSH
10253: LD_INT 55
10255: PUSH
10256: LD_INT 56
10258: PUSH
10259: LD_INT 60
10261: PUSH
10262: LD_INT 61
10264: PUSH
10265: LD_INT 62
10267: PUSH
10268: LD_INT 66
10270: PUSH
10271: LD_INT 67
10273: PUSH
10274: LD_INT 68
10276: PUSH
10277: LD_INT 81
10279: PUSH
10280: LD_INT 82
10282: PUSH
10283: LD_INT 83
10285: PUSH
10286: LD_INT 84
10288: PUSH
10289: LD_INT 85
10291: PUSH
10292: LD_INT 87
10294: PUSH
10295: LD_INT 88
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: LIST
10307: LIST
10308: LIST
10309: LIST
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: LIST
10315: LIST
10316: LIST
10317: LIST
10318: LIST
10319: LIST
10320: LIST
10321: LIST
10322: LIST
10323: LIST
10324: LIST
10325: LIST
10326: LIST
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: ST_TO_ADDR
10354: GO 10587
10356: LD_INT 3
10358: DOUBLE
10359: EQUAL
10360: IFTRUE 10364
10362: GO 10586
10364: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10365: LD_ADDR_VAR 0 4
10369: PUSH
10370: LD_INT 46
10372: PUSH
10373: LD_INT 47
10375: PUSH
10376: LD_INT 1
10378: PUSH
10379: LD_INT 2
10381: PUSH
10382: LD_INT 82
10384: PUSH
10385: LD_INT 83
10387: PUSH
10388: LD_INT 84
10390: PUSH
10391: LD_INT 85
10393: PUSH
10394: LD_INT 86
10396: PUSH
10397: LD_INT 11
10399: PUSH
10400: LD_INT 9
10402: PUSH
10403: LD_INT 20
10405: PUSH
10406: LD_INT 19
10408: PUSH
10409: LD_INT 21
10411: PUSH
10412: LD_INT 24
10414: PUSH
10415: LD_INT 22
10417: PUSH
10418: LD_INT 25
10420: PUSH
10421: LD_INT 28
10423: PUSH
10424: LD_INT 29
10426: PUSH
10427: LD_INT 30
10429: PUSH
10430: LD_INT 31
10432: PUSH
10433: LD_INT 37
10435: PUSH
10436: LD_INT 38
10438: PUSH
10439: LD_INT 32
10441: PUSH
10442: LD_INT 27
10444: PUSH
10445: LD_INT 33
10447: PUSH
10448: LD_INT 69
10450: PUSH
10451: LD_INT 39
10453: PUSH
10454: LD_INT 34
10456: PUSH
10457: LD_INT 40
10459: PUSH
10460: LD_INT 71
10462: PUSH
10463: LD_INT 23
10465: PUSH
10466: LD_INT 44
10468: PUSH
10469: LD_INT 48
10471: PUSH
10472: LD_INT 49
10474: PUSH
10475: LD_INT 50
10477: PUSH
10478: LD_INT 51
10480: PUSH
10481: LD_INT 52
10483: PUSH
10484: LD_INT 53
10486: PUSH
10487: LD_INT 54
10489: PUSH
10490: LD_INT 55
10492: PUSH
10493: LD_INT 56
10495: PUSH
10496: LD_INT 57
10498: PUSH
10499: LD_INT 58
10501: PUSH
10502: LD_INT 59
10504: PUSH
10505: LD_INT 63
10507: PUSH
10508: LD_INT 64
10510: PUSH
10511: LD_INT 65
10513: PUSH
10514: LD_INT 82
10516: PUSH
10517: LD_INT 83
10519: PUSH
10520: LD_INT 84
10522: PUSH
10523: LD_INT 85
10525: PUSH
10526: LD_INT 86
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: LIST
10538: LIST
10539: LIST
10540: LIST
10541: LIST
10542: LIST
10543: LIST
10544: LIST
10545: LIST
10546: LIST
10547: LIST
10548: LIST
10549: LIST
10550: LIST
10551: LIST
10552: LIST
10553: LIST
10554: LIST
10555: LIST
10556: LIST
10557: LIST
10558: LIST
10559: LIST
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: ST_TO_ADDR
10584: GO 10587
10586: POP
// if state > - 1 and state < 3 then
10587: LD_VAR 0 3
10591: PUSH
10592: LD_INT 1
10594: NEG
10595: GREATER
10596: PUSH
10597: LD_VAR 0 3
10601: PUSH
10602: LD_INT 3
10604: LESS
10605: AND
10606: IFFALSE 10663
// for i in result do
10608: LD_ADDR_VAR 0 5
10612: PUSH
10613: LD_VAR 0 4
10617: PUSH
10618: FOR_IN
10619: IFFALSE 10661
// if GetTech ( i , side ) <> state then
10621: LD_VAR 0 5
10625: PPUSH
10626: LD_VAR 0 1
10630: PPUSH
10631: CALL_OW 321
10635: PUSH
10636: LD_VAR 0 3
10640: NONEQUAL
10641: IFFALSE 10659
// result := result diff i ;
10643: LD_ADDR_VAR 0 4
10647: PUSH
10648: LD_VAR 0 4
10652: PUSH
10653: LD_VAR 0 5
10657: DIFF
10658: ST_TO_ADDR
10659: GO 10618
10661: POP
10662: POP
// end ;
10663: LD_VAR 0 4
10667: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10668: LD_INT 0
10670: PPUSH
10671: PPUSH
10672: PPUSH
// result := true ;
10673: LD_ADDR_VAR 0 3
10677: PUSH
10678: LD_INT 1
10680: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10681: LD_ADDR_VAR 0 5
10685: PUSH
10686: LD_VAR 0 2
10690: PPUSH
10691: CALL_OW 480
10695: ST_TO_ADDR
// if not tmp then
10696: LD_VAR 0 5
10700: NOT
10701: IFFALSE 10705
// exit ;
10703: GO 10754
// for i in tmp do
10705: LD_ADDR_VAR 0 4
10709: PUSH
10710: LD_VAR 0 5
10714: PUSH
10715: FOR_IN
10716: IFFALSE 10752
// if GetTech ( i , side ) <> state_researched then
10718: LD_VAR 0 4
10722: PPUSH
10723: LD_VAR 0 1
10727: PPUSH
10728: CALL_OW 321
10732: PUSH
10733: LD_INT 2
10735: NONEQUAL
10736: IFFALSE 10750
// begin result := false ;
10738: LD_ADDR_VAR 0 3
10742: PUSH
10743: LD_INT 0
10745: ST_TO_ADDR
// exit ;
10746: POP
10747: POP
10748: GO 10754
// end ;
10750: GO 10715
10752: POP
10753: POP
// end ;
10754: LD_VAR 0 3
10758: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10759: LD_INT 0
10761: PPUSH
10762: PPUSH
10763: PPUSH
10764: PPUSH
10765: PPUSH
10766: PPUSH
10767: PPUSH
10768: PPUSH
10769: PPUSH
10770: PPUSH
10771: PPUSH
10772: PPUSH
10773: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10774: LD_VAR 0 1
10778: NOT
10779: PUSH
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 257
10789: PUSH
10790: LD_INT 9
10792: NONEQUAL
10793: OR
10794: IFFALSE 10798
// exit ;
10796: GO 11371
// side := GetSide ( unit ) ;
10798: LD_ADDR_VAR 0 9
10802: PUSH
10803: LD_VAR 0 1
10807: PPUSH
10808: CALL_OW 255
10812: ST_TO_ADDR
// tech_space := tech_spacanom ;
10813: LD_ADDR_VAR 0 12
10817: PUSH
10818: LD_INT 29
10820: ST_TO_ADDR
// tech_time := tech_taurad ;
10821: LD_ADDR_VAR 0 13
10825: PUSH
10826: LD_INT 28
10828: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10829: LD_ADDR_VAR 0 11
10833: PUSH
10834: LD_VAR 0 1
10838: PPUSH
10839: CALL_OW 310
10843: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10844: LD_VAR 0 11
10848: PPUSH
10849: CALL_OW 247
10853: PUSH
10854: LD_INT 2
10856: EQUAL
10857: IFFALSE 10861
// exit ;
10859: GO 11371
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10861: LD_ADDR_VAR 0 8
10865: PUSH
10866: LD_INT 81
10868: PUSH
10869: LD_VAR 0 9
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PUSH
10878: LD_INT 3
10880: PUSH
10881: LD_INT 21
10883: PUSH
10884: LD_INT 3
10886: PUSH
10887: EMPTY
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: LIST
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: PPUSH
10899: CALL_OW 69
10903: ST_TO_ADDR
// if not tmp then
10904: LD_VAR 0 8
10908: NOT
10909: IFFALSE 10913
// exit ;
10911: GO 11371
// if in_unit then
10913: LD_VAR 0 11
10917: IFFALSE 10941
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10919: LD_ADDR_VAR 0 10
10923: PUSH
10924: LD_VAR 0 8
10928: PPUSH
10929: LD_VAR 0 11
10933: PPUSH
10934: CALL_OW 74
10938: ST_TO_ADDR
10939: GO 10961
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10941: LD_ADDR_VAR 0 10
10945: PUSH
10946: LD_VAR 0 8
10950: PPUSH
10951: LD_VAR 0 1
10955: PPUSH
10956: CALL_OW 74
10960: ST_TO_ADDR
// if not enemy then
10961: LD_VAR 0 10
10965: NOT
10966: IFFALSE 10970
// exit ;
10968: GO 11371
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
10970: LD_VAR 0 11
10974: PUSH
10975: LD_VAR 0 11
10979: PPUSH
10980: LD_VAR 0 10
10984: PPUSH
10985: CALL_OW 296
10989: PUSH
10990: LD_INT 13
10992: GREATER
10993: AND
10994: PUSH
10995: LD_VAR 0 1
10999: PPUSH
11000: LD_VAR 0 10
11004: PPUSH
11005: CALL_OW 296
11009: PUSH
11010: LD_INT 12
11012: GREATER
11013: OR
11014: IFFALSE 11018
// exit ;
11016: GO 11371
// missile := [ 1 ] ;
11018: LD_ADDR_VAR 0 14
11022: PUSH
11023: LD_INT 1
11025: PUSH
11026: EMPTY
11027: LIST
11028: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11029: LD_VAR 0 9
11033: PPUSH
11034: LD_VAR 0 12
11038: PPUSH
11039: CALL_OW 325
11043: IFFALSE 11072
// missile := Replace ( missile , missile + 1 , 2 ) ;
11045: LD_ADDR_VAR 0 14
11049: PUSH
11050: LD_VAR 0 14
11054: PPUSH
11055: LD_VAR 0 14
11059: PUSH
11060: LD_INT 1
11062: PLUS
11063: PPUSH
11064: LD_INT 2
11066: PPUSH
11067: CALL_OW 1
11071: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11072: LD_VAR 0 9
11076: PPUSH
11077: LD_VAR 0 13
11081: PPUSH
11082: CALL_OW 325
11086: PUSH
11087: LD_VAR 0 10
11091: PPUSH
11092: CALL_OW 255
11096: PPUSH
11097: LD_VAR 0 13
11101: PPUSH
11102: CALL_OW 325
11106: NOT
11107: AND
11108: IFFALSE 11137
// missile := Replace ( missile , missile + 1 , 3 ) ;
11110: LD_ADDR_VAR 0 14
11114: PUSH
11115: LD_VAR 0 14
11119: PPUSH
11120: LD_VAR 0 14
11124: PUSH
11125: LD_INT 1
11127: PLUS
11128: PPUSH
11129: LD_INT 3
11131: PPUSH
11132: CALL_OW 1
11136: ST_TO_ADDR
// if missile < 2 then
11137: LD_VAR 0 14
11141: PUSH
11142: LD_INT 2
11144: LESS
11145: IFFALSE 11149
// exit ;
11147: GO 11371
// x := GetX ( enemy ) ;
11149: LD_ADDR_VAR 0 4
11153: PUSH
11154: LD_VAR 0 10
11158: PPUSH
11159: CALL_OW 250
11163: ST_TO_ADDR
// y := GetY ( enemy ) ;
11164: LD_ADDR_VAR 0 5
11168: PUSH
11169: LD_VAR 0 10
11173: PPUSH
11174: CALL_OW 251
11178: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11179: LD_ADDR_VAR 0 6
11183: PUSH
11184: LD_VAR 0 4
11188: PUSH
11189: LD_INT 1
11191: NEG
11192: PPUSH
11193: LD_INT 1
11195: PPUSH
11196: CALL_OW 12
11200: PLUS
11201: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11202: LD_ADDR_VAR 0 7
11206: PUSH
11207: LD_VAR 0 5
11211: PUSH
11212: LD_INT 1
11214: NEG
11215: PPUSH
11216: LD_INT 1
11218: PPUSH
11219: CALL_OW 12
11223: PLUS
11224: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11225: LD_VAR 0 6
11229: PPUSH
11230: LD_VAR 0 7
11234: PPUSH
11235: CALL_OW 488
11239: NOT
11240: IFFALSE 11262
// begin _x := x ;
11242: LD_ADDR_VAR 0 6
11246: PUSH
11247: LD_VAR 0 4
11251: ST_TO_ADDR
// _y := y ;
11252: LD_ADDR_VAR 0 7
11256: PUSH
11257: LD_VAR 0 5
11261: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11262: LD_ADDR_VAR 0 3
11266: PUSH
11267: LD_INT 1
11269: PPUSH
11270: LD_VAR 0 14
11274: PPUSH
11275: CALL_OW 12
11279: ST_TO_ADDR
// case i of 1 :
11280: LD_VAR 0 3
11284: PUSH
11285: LD_INT 1
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11310
11293: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11294: LD_VAR 0 1
11298: PPUSH
11299: LD_VAR 0 10
11303: PPUSH
11304: CALL_OW 115
11308: GO 11371
11310: LD_INT 2
11312: DOUBLE
11313: EQUAL
11314: IFTRUE 11318
11316: GO 11340
11318: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11319: LD_VAR 0 1
11323: PPUSH
11324: LD_VAR 0 6
11328: PPUSH
11329: LD_VAR 0 7
11333: PPUSH
11334: CALL_OW 153
11338: GO 11371
11340: LD_INT 3
11342: DOUBLE
11343: EQUAL
11344: IFTRUE 11348
11346: GO 11370
11348: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11349: LD_VAR 0 1
11353: PPUSH
11354: LD_VAR 0 6
11358: PPUSH
11359: LD_VAR 0 7
11363: PPUSH
11364: CALL_OW 154
11368: GO 11371
11370: POP
// end ;
11371: LD_VAR 0 2
11375: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11376: LD_INT 0
11378: PPUSH
11379: PPUSH
11380: PPUSH
11381: PPUSH
11382: PPUSH
11383: PPUSH
// if not unit or not building then
11384: LD_VAR 0 1
11388: NOT
11389: PUSH
11390: LD_VAR 0 2
11394: NOT
11395: OR
11396: IFFALSE 11400
// exit ;
11398: GO 11558
// x := GetX ( building ) ;
11400: LD_ADDR_VAR 0 5
11404: PUSH
11405: LD_VAR 0 2
11409: PPUSH
11410: CALL_OW 250
11414: ST_TO_ADDR
// y := GetY ( building ) ;
11415: LD_ADDR_VAR 0 6
11419: PUSH
11420: LD_VAR 0 2
11424: PPUSH
11425: CALL_OW 251
11429: ST_TO_ADDR
// for i = 0 to 5 do
11430: LD_ADDR_VAR 0 4
11434: PUSH
11435: DOUBLE
11436: LD_INT 0
11438: DEC
11439: ST_TO_ADDR
11440: LD_INT 5
11442: PUSH
11443: FOR_TO
11444: IFFALSE 11556
// begin _x := ShiftX ( x , i , 3 ) ;
11446: LD_ADDR_VAR 0 7
11450: PUSH
11451: LD_VAR 0 5
11455: PPUSH
11456: LD_VAR 0 4
11460: PPUSH
11461: LD_INT 3
11463: PPUSH
11464: CALL_OW 272
11468: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11469: LD_ADDR_VAR 0 8
11473: PUSH
11474: LD_VAR 0 6
11478: PPUSH
11479: LD_VAR 0 4
11483: PPUSH
11484: LD_INT 3
11486: PPUSH
11487: CALL_OW 273
11491: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11492: LD_VAR 0 7
11496: PPUSH
11497: LD_VAR 0 8
11501: PPUSH
11502: CALL_OW 488
11506: NOT
11507: IFFALSE 11511
// continue ;
11509: GO 11443
// if HexInfo ( _x , _y ) = 0 then
11511: LD_VAR 0 7
11515: PPUSH
11516: LD_VAR 0 8
11520: PPUSH
11521: CALL_OW 428
11525: PUSH
11526: LD_INT 0
11528: EQUAL
11529: IFFALSE 11554
// begin ComMoveXY ( unit , _x , _y ) ;
11531: LD_VAR 0 1
11535: PPUSH
11536: LD_VAR 0 7
11540: PPUSH
11541: LD_VAR 0 8
11545: PPUSH
11546: CALL_OW 111
// exit ;
11550: POP
11551: POP
11552: GO 11558
// end ; end ;
11554: GO 11443
11556: POP
11557: POP
// end ;
11558: LD_VAR 0 3
11562: RET
// export function ScanBase ( side , base_area ) ; begin
11563: LD_INT 0
11565: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11566: LD_ADDR_VAR 0 3
11570: PUSH
11571: LD_VAR 0 2
11575: PPUSH
11576: LD_INT 81
11578: PUSH
11579: LD_VAR 0 1
11583: PUSH
11584: EMPTY
11585: LIST
11586: LIST
11587: PPUSH
11588: CALL_OW 70
11592: ST_TO_ADDR
// end ;
11593: LD_VAR 0 3
11597: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11598: LD_INT 0
11600: PPUSH
11601: PPUSH
11602: PPUSH
11603: PPUSH
// result := false ;
11604: LD_ADDR_VAR 0 2
11608: PUSH
11609: LD_INT 0
11611: ST_TO_ADDR
// side := GetSide ( unit ) ;
11612: LD_ADDR_VAR 0 3
11616: PUSH
11617: LD_VAR 0 1
11621: PPUSH
11622: CALL_OW 255
11626: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11627: LD_ADDR_VAR 0 4
11631: PUSH
11632: LD_VAR 0 1
11636: PPUSH
11637: CALL_OW 248
11641: ST_TO_ADDR
// case nat of 1 :
11642: LD_VAR 0 4
11646: PUSH
11647: LD_INT 1
11649: DOUBLE
11650: EQUAL
11651: IFTRUE 11655
11653: GO 11666
11655: POP
// tech := tech_lassight ; 2 :
11656: LD_ADDR_VAR 0 5
11660: PUSH
11661: LD_INT 12
11663: ST_TO_ADDR
11664: GO 11705
11666: LD_INT 2
11668: DOUBLE
11669: EQUAL
11670: IFTRUE 11674
11672: GO 11685
11674: POP
// tech := tech_mortar ; 3 :
11675: LD_ADDR_VAR 0 5
11679: PUSH
11680: LD_INT 41
11682: ST_TO_ADDR
11683: GO 11705
11685: LD_INT 3
11687: DOUBLE
11688: EQUAL
11689: IFTRUE 11693
11691: GO 11704
11693: POP
// tech := tech_bazooka ; end ;
11694: LD_ADDR_VAR 0 5
11698: PUSH
11699: LD_INT 44
11701: ST_TO_ADDR
11702: GO 11705
11704: POP
// if Researched ( side , tech ) then
11705: LD_VAR 0 3
11709: PPUSH
11710: LD_VAR 0 5
11714: PPUSH
11715: CALL_OW 325
11719: IFFALSE 11746
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11721: LD_ADDR_VAR 0 2
11725: PUSH
11726: LD_INT 5
11728: PUSH
11729: LD_INT 8
11731: PUSH
11732: LD_INT 9
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: LIST
11739: PUSH
11740: LD_VAR 0 4
11744: ARRAY
11745: ST_TO_ADDR
// end ;
11746: LD_VAR 0 2
11750: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11751: LD_INT 0
11753: PPUSH
11754: PPUSH
11755: PPUSH
// if not mines then
11756: LD_VAR 0 2
11760: NOT
11761: IFFALSE 11765
// exit ;
11763: GO 11909
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11765: LD_ADDR_VAR 0 5
11769: PUSH
11770: LD_INT 81
11772: PUSH
11773: LD_VAR 0 1
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: LD_INT 3
11784: PUSH
11785: LD_INT 21
11787: PUSH
11788: LD_INT 3
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: PPUSH
11803: CALL_OW 69
11807: ST_TO_ADDR
// for i in mines do
11808: LD_ADDR_VAR 0 4
11812: PUSH
11813: LD_VAR 0 2
11817: PUSH
11818: FOR_IN
11819: IFFALSE 11907
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11821: LD_VAR 0 4
11825: PUSH
11826: LD_INT 1
11828: ARRAY
11829: PPUSH
11830: LD_VAR 0 4
11834: PUSH
11835: LD_INT 2
11837: ARRAY
11838: PPUSH
11839: CALL_OW 458
11843: NOT
11844: IFFALSE 11848
// continue ;
11846: GO 11818
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11848: LD_VAR 0 4
11852: PUSH
11853: LD_INT 1
11855: ARRAY
11856: PPUSH
11857: LD_VAR 0 4
11861: PUSH
11862: LD_INT 2
11864: ARRAY
11865: PPUSH
11866: CALL_OW 428
11870: PUSH
11871: LD_VAR 0 5
11875: IN
11876: IFFALSE 11905
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11878: LD_VAR 0 4
11882: PUSH
11883: LD_INT 1
11885: ARRAY
11886: PPUSH
11887: LD_VAR 0 4
11891: PUSH
11892: LD_INT 2
11894: ARRAY
11895: PPUSH
11896: LD_VAR 0 1
11900: PPUSH
11901: CALL_OW 456
// end ;
11905: GO 11818
11907: POP
11908: POP
// end ;
11909: LD_VAR 0 3
11913: RET
// export function Count ( array ) ; begin
11914: LD_INT 0
11916: PPUSH
// result := array + 0 ;
11917: LD_ADDR_VAR 0 2
11921: PUSH
11922: LD_VAR 0 1
11926: PUSH
11927: LD_INT 0
11929: PLUS
11930: ST_TO_ADDR
// end ;
11931: LD_VAR 0 2
11935: RET
// export function IsEmpty ( building ) ; begin
11936: LD_INT 0
11938: PPUSH
// if not building then
11939: LD_VAR 0 1
11943: NOT
11944: IFFALSE 11948
// exit ;
11946: GO 11991
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
11948: LD_ADDR_VAR 0 2
11952: PUSH
11953: LD_VAR 0 1
11957: PUSH
11958: LD_INT 22
11960: PUSH
11961: LD_VAR 0 1
11965: PPUSH
11966: CALL_OW 255
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PUSH
11975: LD_INT 58
11977: PUSH
11978: EMPTY
11979: LIST
11980: PUSH
11981: EMPTY
11982: LIST
11983: LIST
11984: PPUSH
11985: CALL_OW 69
11989: IN
11990: ST_TO_ADDR
// end ;
11991: LD_VAR 0 2
11995: RET
// export function IsNotFull ( building ) ; var places ; begin
11996: LD_INT 0
11998: PPUSH
11999: PPUSH
// if not building then
12000: LD_VAR 0 1
12004: NOT
12005: IFFALSE 12009
// exit ;
12007: GO 12037
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
12009: LD_ADDR_VAR 0 2
12013: PUSH
12014: LD_VAR 0 1
12018: PPUSH
12019: LD_INT 3
12021: PUSH
12022: LD_INT 62
12024: PUSH
12025: EMPTY
12026: LIST
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PPUSH
12032: CALL_OW 72
12036: ST_TO_ADDR
// end ;
12037: LD_VAR 0 2
12041: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12042: LD_INT 0
12044: PPUSH
12045: PPUSH
12046: PPUSH
12047: PPUSH
// tmp := [ ] ;
12048: LD_ADDR_VAR 0 3
12052: PUSH
12053: EMPTY
12054: ST_TO_ADDR
// list := [ ] ;
12055: LD_ADDR_VAR 0 5
12059: PUSH
12060: EMPTY
12061: ST_TO_ADDR
// for i = 16 to 25 do
12062: LD_ADDR_VAR 0 4
12066: PUSH
12067: DOUBLE
12068: LD_INT 16
12070: DEC
12071: ST_TO_ADDR
12072: LD_INT 25
12074: PUSH
12075: FOR_TO
12076: IFFALSE 12149
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12078: LD_ADDR_VAR 0 3
12082: PUSH
12083: LD_VAR 0 3
12087: PUSH
12088: LD_INT 22
12090: PUSH
12091: LD_VAR 0 1
12095: PPUSH
12096: CALL_OW 255
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: LD_INT 91
12107: PUSH
12108: LD_VAR 0 1
12112: PUSH
12113: LD_INT 6
12115: PUSH
12116: EMPTY
12117: LIST
12118: LIST
12119: LIST
12120: PUSH
12121: LD_INT 30
12123: PUSH
12124: LD_VAR 0 4
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: PUSH
12138: EMPTY
12139: LIST
12140: PPUSH
12141: CALL_OW 69
12145: ADD
12146: ST_TO_ADDR
12147: GO 12075
12149: POP
12150: POP
// for i = 1 to tmp do
12151: LD_ADDR_VAR 0 4
12155: PUSH
12156: DOUBLE
12157: LD_INT 1
12159: DEC
12160: ST_TO_ADDR
12161: LD_VAR 0 3
12165: PUSH
12166: FOR_TO
12167: IFFALSE 12255
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12169: LD_ADDR_VAR 0 5
12173: PUSH
12174: LD_VAR 0 5
12178: PUSH
12179: LD_VAR 0 3
12183: PUSH
12184: LD_VAR 0 4
12188: ARRAY
12189: PPUSH
12190: CALL_OW 266
12194: PUSH
12195: LD_VAR 0 3
12199: PUSH
12200: LD_VAR 0 4
12204: ARRAY
12205: PPUSH
12206: CALL_OW 250
12210: PUSH
12211: LD_VAR 0 3
12215: PUSH
12216: LD_VAR 0 4
12220: ARRAY
12221: PPUSH
12222: CALL_OW 251
12226: PUSH
12227: LD_VAR 0 3
12231: PUSH
12232: LD_VAR 0 4
12236: ARRAY
12237: PPUSH
12238: CALL_OW 254
12242: PUSH
12243: EMPTY
12244: LIST
12245: LIST
12246: LIST
12247: LIST
12248: PUSH
12249: EMPTY
12250: LIST
12251: ADD
12252: ST_TO_ADDR
12253: GO 12166
12255: POP
12256: POP
// result := list ;
12257: LD_ADDR_VAR 0 2
12261: PUSH
12262: LD_VAR 0 5
12266: ST_TO_ADDR
// end ;
12267: LD_VAR 0 2
12271: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12272: LD_INT 0
12274: PPUSH
12275: PPUSH
12276: PPUSH
12277: PPUSH
12278: PPUSH
12279: PPUSH
12280: PPUSH
// if not factory then
12281: LD_VAR 0 1
12285: NOT
12286: IFFALSE 12290
// exit ;
12288: GO 12883
// if control = control_apeman then
12290: LD_VAR 0 4
12294: PUSH
12295: LD_INT 5
12297: EQUAL
12298: IFFALSE 12407
// begin tmp := UnitsInside ( factory ) ;
12300: LD_ADDR_VAR 0 8
12304: PUSH
12305: LD_VAR 0 1
12309: PPUSH
12310: CALL_OW 313
12314: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12315: LD_VAR 0 8
12319: PPUSH
12320: LD_INT 25
12322: PUSH
12323: LD_INT 12
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PPUSH
12330: CALL_OW 72
12334: NOT
12335: IFFALSE 12345
// control := control_manual ;
12337: LD_ADDR_VAR 0 4
12341: PUSH
12342: LD_INT 1
12344: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12345: LD_ADDR_VAR 0 8
12349: PUSH
12350: LD_VAR 0 1
12354: PPUSH
12355: CALL 12042 0 1
12359: ST_TO_ADDR
// if tmp then
12360: LD_VAR 0 8
12364: IFFALSE 12407
// begin for i in tmp do
12366: LD_ADDR_VAR 0 7
12370: PUSH
12371: LD_VAR 0 8
12375: PUSH
12376: FOR_IN
12377: IFFALSE 12405
// if i [ 1 ] = b_ext_radio then
12379: LD_VAR 0 7
12383: PUSH
12384: LD_INT 1
12386: ARRAY
12387: PUSH
12388: LD_INT 22
12390: EQUAL
12391: IFFALSE 12403
// begin control := control_remote ;
12393: LD_ADDR_VAR 0 4
12397: PUSH
12398: LD_INT 2
12400: ST_TO_ADDR
// break ;
12401: GO 12405
// end ;
12403: GO 12376
12405: POP
12406: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12407: LD_VAR 0 1
12411: PPUSH
12412: LD_VAR 0 2
12416: PPUSH
12417: LD_VAR 0 3
12421: PPUSH
12422: LD_VAR 0 4
12426: PPUSH
12427: LD_VAR 0 5
12431: PPUSH
12432: CALL_OW 448
12436: IFFALSE 12471
// begin result := [ chassis , engine , control , weapon ] ;
12438: LD_ADDR_VAR 0 6
12442: PUSH
12443: LD_VAR 0 2
12447: PUSH
12448: LD_VAR 0 3
12452: PUSH
12453: LD_VAR 0 4
12457: PUSH
12458: LD_VAR 0 5
12462: PUSH
12463: EMPTY
12464: LIST
12465: LIST
12466: LIST
12467: LIST
12468: ST_TO_ADDR
// exit ;
12469: GO 12883
// end ; _chassis := AvailableChassisList ( factory ) ;
12471: LD_ADDR_VAR 0 9
12475: PUSH
12476: LD_VAR 0 1
12480: PPUSH
12481: CALL_OW 475
12485: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12486: LD_ADDR_VAR 0 11
12490: PUSH
12491: LD_VAR 0 1
12495: PPUSH
12496: CALL_OW 476
12500: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12501: LD_ADDR_VAR 0 12
12505: PUSH
12506: LD_VAR 0 1
12510: PPUSH
12511: CALL_OW 477
12515: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12516: LD_ADDR_VAR 0 10
12520: PUSH
12521: LD_VAR 0 1
12525: PPUSH
12526: CALL_OW 478
12530: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12531: LD_VAR 0 9
12535: NOT
12536: PUSH
12537: LD_VAR 0 11
12541: NOT
12542: OR
12543: PUSH
12544: LD_VAR 0 12
12548: NOT
12549: OR
12550: PUSH
12551: LD_VAR 0 10
12555: NOT
12556: OR
12557: IFFALSE 12592
// begin result := [ chassis , engine , control , weapon ] ;
12559: LD_ADDR_VAR 0 6
12563: PUSH
12564: LD_VAR 0 2
12568: PUSH
12569: LD_VAR 0 3
12573: PUSH
12574: LD_VAR 0 4
12578: PUSH
12579: LD_VAR 0 5
12583: PUSH
12584: EMPTY
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: ST_TO_ADDR
// exit ;
12590: GO 12883
// end ; if not chassis in _chassis then
12592: LD_VAR 0 2
12596: PUSH
12597: LD_VAR 0 9
12601: IN
12602: NOT
12603: IFFALSE 12629
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12605: LD_ADDR_VAR 0 2
12609: PUSH
12610: LD_VAR 0 9
12614: PUSH
12615: LD_INT 1
12617: PPUSH
12618: LD_VAR 0 9
12622: PPUSH
12623: CALL_OW 12
12627: ARRAY
12628: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12629: LD_VAR 0 2
12633: PPUSH
12634: LD_VAR 0 3
12638: PPUSH
12639: CALL 12888 0 2
12643: NOT
12644: IFFALSE 12703
// repeat engine := _engine [ 1 ] ;
12646: LD_ADDR_VAR 0 3
12650: PUSH
12651: LD_VAR 0 11
12655: PUSH
12656: LD_INT 1
12658: ARRAY
12659: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12660: LD_ADDR_VAR 0 11
12664: PUSH
12665: LD_VAR 0 11
12669: PPUSH
12670: LD_INT 1
12672: PPUSH
12673: CALL_OW 3
12677: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12678: LD_VAR 0 2
12682: PPUSH
12683: LD_VAR 0 3
12687: PPUSH
12688: CALL 12888 0 2
12692: PUSH
12693: LD_VAR 0 11
12697: PUSH
12698: EMPTY
12699: EQUAL
12700: OR
12701: IFFALSE 12646
// if not control in _control then
12703: LD_VAR 0 4
12707: PUSH
12708: LD_VAR 0 12
12712: IN
12713: NOT
12714: IFFALSE 12740
// control := _control [ rand ( 1 , _control ) ] ;
12716: LD_ADDR_VAR 0 4
12720: PUSH
12721: LD_VAR 0 12
12725: PUSH
12726: LD_INT 1
12728: PPUSH
12729: LD_VAR 0 12
12733: PPUSH
12734: CALL_OW 12
12738: ARRAY
12739: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12740: LD_VAR 0 2
12744: PPUSH
12745: LD_VAR 0 5
12749: PPUSH
12750: CALL 13108 0 2
12754: NOT
12755: IFFALSE 12814
// repeat weapon := _weapon [ 1 ] ;
12757: LD_ADDR_VAR 0 5
12761: PUSH
12762: LD_VAR 0 10
12766: PUSH
12767: LD_INT 1
12769: ARRAY
12770: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12771: LD_ADDR_VAR 0 10
12775: PUSH
12776: LD_VAR 0 10
12780: PPUSH
12781: LD_INT 1
12783: PPUSH
12784: CALL_OW 3
12788: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12789: LD_VAR 0 2
12793: PPUSH
12794: LD_VAR 0 5
12798: PPUSH
12799: CALL 13108 0 2
12803: PUSH
12804: LD_VAR 0 10
12808: PUSH
12809: EMPTY
12810: EQUAL
12811: OR
12812: IFFALSE 12757
// result := [ ] ;
12814: LD_ADDR_VAR 0 6
12818: PUSH
12819: EMPTY
12820: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12821: LD_VAR 0 1
12825: PPUSH
12826: LD_VAR 0 2
12830: PPUSH
12831: LD_VAR 0 3
12835: PPUSH
12836: LD_VAR 0 4
12840: PPUSH
12841: LD_VAR 0 5
12845: PPUSH
12846: CALL_OW 448
12850: IFFALSE 12883
// result := [ chassis , engine , control , weapon ] ;
12852: LD_ADDR_VAR 0 6
12856: PUSH
12857: LD_VAR 0 2
12861: PUSH
12862: LD_VAR 0 3
12866: PUSH
12867: LD_VAR 0 4
12871: PUSH
12872: LD_VAR 0 5
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: ST_TO_ADDR
// end ;
12883: LD_VAR 0 6
12887: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12888: LD_INT 0
12890: PPUSH
// if not chassis or not engine then
12891: LD_VAR 0 1
12895: NOT
12896: PUSH
12897: LD_VAR 0 2
12901: NOT
12902: OR
12903: IFFALSE 12907
// exit ;
12905: GO 13103
// case engine of engine_solar :
12907: LD_VAR 0 2
12911: PUSH
12912: LD_INT 2
12914: DOUBLE
12915: EQUAL
12916: IFTRUE 12920
12918: GO 12958
12920: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12921: LD_ADDR_VAR 0 3
12925: PUSH
12926: LD_INT 11
12928: PUSH
12929: LD_INT 12
12931: PUSH
12932: LD_INT 13
12934: PUSH
12935: LD_INT 14
12937: PUSH
12938: LD_INT 1
12940: PUSH
12941: LD_INT 2
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: LIST
12953: LIST
12954: LIST
12955: ST_TO_ADDR
12956: GO 13087
12958: LD_INT 1
12960: DOUBLE
12961: EQUAL
12962: IFTRUE 12966
12964: GO 13028
12966: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
12967: LD_ADDR_VAR 0 3
12971: PUSH
12972: LD_INT 11
12974: PUSH
12975: LD_INT 12
12977: PUSH
12978: LD_INT 13
12980: PUSH
12981: LD_INT 14
12983: PUSH
12984: LD_INT 1
12986: PUSH
12987: LD_INT 2
12989: PUSH
12990: LD_INT 3
12992: PUSH
12993: LD_INT 4
12995: PUSH
12996: LD_INT 5
12998: PUSH
12999: LD_INT 21
13001: PUSH
13002: LD_INT 23
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 24
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: LIST
13024: LIST
13025: ST_TO_ADDR
13026: GO 13087
13028: LD_INT 3
13030: DOUBLE
13031: EQUAL
13032: IFTRUE 13036
13034: GO 13086
13036: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13037: LD_ADDR_VAR 0 3
13041: PUSH
13042: LD_INT 13
13044: PUSH
13045: LD_INT 14
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 3
13053: PUSH
13054: LD_INT 4
13056: PUSH
13057: LD_INT 5
13059: PUSH
13060: LD_INT 21
13062: PUSH
13063: LD_INT 22
13065: PUSH
13066: LD_INT 23
13068: PUSH
13069: LD_INT 24
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: ST_TO_ADDR
13084: GO 13087
13086: POP
// result := ( chassis in result ) ;
13087: LD_ADDR_VAR 0 3
13091: PUSH
13092: LD_VAR 0 1
13096: PUSH
13097: LD_VAR 0 3
13101: IN
13102: ST_TO_ADDR
// end ;
13103: LD_VAR 0 3
13107: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13108: LD_INT 0
13110: PPUSH
// if not chassis or not weapon then
13111: LD_VAR 0 1
13115: NOT
13116: PUSH
13117: LD_VAR 0 2
13121: NOT
13122: OR
13123: IFFALSE 13127
// exit ;
13125: GO 14187
// case weapon of us_machine_gun :
13127: LD_VAR 0 2
13131: PUSH
13132: LD_INT 2
13134: DOUBLE
13135: EQUAL
13136: IFTRUE 13140
13138: GO 13170
13140: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13141: LD_ADDR_VAR 0 3
13145: PUSH
13146: LD_INT 1
13148: PUSH
13149: LD_INT 2
13151: PUSH
13152: LD_INT 3
13154: PUSH
13155: LD_INT 4
13157: PUSH
13158: LD_INT 5
13160: PUSH
13161: EMPTY
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: ST_TO_ADDR
13168: GO 14171
13170: LD_INT 3
13172: DOUBLE
13173: EQUAL
13174: IFTRUE 13178
13176: GO 13208
13178: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13179: LD_ADDR_VAR 0 3
13183: PUSH
13184: LD_INT 1
13186: PUSH
13187: LD_INT 2
13189: PUSH
13190: LD_INT 3
13192: PUSH
13193: LD_INT 4
13195: PUSH
13196: LD_INT 5
13198: PUSH
13199: EMPTY
13200: LIST
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: ST_TO_ADDR
13206: GO 14171
13208: LD_INT 11
13210: DOUBLE
13211: EQUAL
13212: IFTRUE 13216
13214: GO 13246
13216: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13217: LD_ADDR_VAR 0 3
13221: PUSH
13222: LD_INT 1
13224: PUSH
13225: LD_INT 2
13227: PUSH
13228: LD_INT 3
13230: PUSH
13231: LD_INT 4
13233: PUSH
13234: LD_INT 5
13236: PUSH
13237: EMPTY
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: ST_TO_ADDR
13244: GO 14171
13246: LD_INT 4
13248: DOUBLE
13249: EQUAL
13250: IFTRUE 13254
13252: GO 13280
13254: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13255: LD_ADDR_VAR 0 3
13259: PUSH
13260: LD_INT 2
13262: PUSH
13263: LD_INT 3
13265: PUSH
13266: LD_INT 4
13268: PUSH
13269: LD_INT 5
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: ST_TO_ADDR
13278: GO 14171
13280: LD_INT 5
13282: DOUBLE
13283: EQUAL
13284: IFTRUE 13288
13286: GO 13314
13288: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13289: LD_ADDR_VAR 0 3
13293: PUSH
13294: LD_INT 2
13296: PUSH
13297: LD_INT 3
13299: PUSH
13300: LD_INT 4
13302: PUSH
13303: LD_INT 5
13305: PUSH
13306: EMPTY
13307: LIST
13308: LIST
13309: LIST
13310: LIST
13311: ST_TO_ADDR
13312: GO 14171
13314: LD_INT 9
13316: DOUBLE
13317: EQUAL
13318: IFTRUE 13322
13320: GO 13348
13322: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13323: LD_ADDR_VAR 0 3
13327: PUSH
13328: LD_INT 2
13330: PUSH
13331: LD_INT 3
13333: PUSH
13334: LD_INT 4
13336: PUSH
13337: LD_INT 5
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: LIST
13344: LIST
13345: ST_TO_ADDR
13346: GO 14171
13348: LD_INT 7
13350: DOUBLE
13351: EQUAL
13352: IFTRUE 13356
13354: GO 13382
13356: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13357: LD_ADDR_VAR 0 3
13361: PUSH
13362: LD_INT 2
13364: PUSH
13365: LD_INT 3
13367: PUSH
13368: LD_INT 4
13370: PUSH
13371: LD_INT 5
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: ST_TO_ADDR
13380: GO 14171
13382: LD_INT 12
13384: DOUBLE
13385: EQUAL
13386: IFTRUE 13390
13388: GO 13416
13390: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13391: LD_ADDR_VAR 0 3
13395: PUSH
13396: LD_INT 2
13398: PUSH
13399: LD_INT 3
13401: PUSH
13402: LD_INT 4
13404: PUSH
13405: LD_INT 5
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: LIST
13412: LIST
13413: ST_TO_ADDR
13414: GO 14171
13416: LD_INT 13
13418: DOUBLE
13419: EQUAL
13420: IFTRUE 13424
13422: GO 13450
13424: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13425: LD_ADDR_VAR 0 3
13429: PUSH
13430: LD_INT 2
13432: PUSH
13433: LD_INT 3
13435: PUSH
13436: LD_INT 4
13438: PUSH
13439: LD_INT 5
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: ST_TO_ADDR
13448: GO 14171
13450: LD_INT 14
13452: DOUBLE
13453: EQUAL
13454: IFTRUE 13458
13456: GO 13476
13458: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13459: LD_ADDR_VAR 0 3
13463: PUSH
13464: LD_INT 4
13466: PUSH
13467: LD_INT 5
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: ST_TO_ADDR
13474: GO 14171
13476: LD_INT 6
13478: DOUBLE
13479: EQUAL
13480: IFTRUE 13484
13482: GO 13502
13484: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13485: LD_ADDR_VAR 0 3
13489: PUSH
13490: LD_INT 4
13492: PUSH
13493: LD_INT 5
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: ST_TO_ADDR
13500: GO 14171
13502: LD_INT 10
13504: DOUBLE
13505: EQUAL
13506: IFTRUE 13510
13508: GO 13528
13510: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13511: LD_ADDR_VAR 0 3
13515: PUSH
13516: LD_INT 4
13518: PUSH
13519: LD_INT 5
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: ST_TO_ADDR
13526: GO 14171
13528: LD_INT 22
13530: DOUBLE
13531: EQUAL
13532: IFTRUE 13536
13534: GO 13562
13536: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13537: LD_ADDR_VAR 0 3
13541: PUSH
13542: LD_INT 11
13544: PUSH
13545: LD_INT 12
13547: PUSH
13548: LD_INT 13
13550: PUSH
13551: LD_INT 14
13553: PUSH
13554: EMPTY
13555: LIST
13556: LIST
13557: LIST
13558: LIST
13559: ST_TO_ADDR
13560: GO 14171
13562: LD_INT 23
13564: DOUBLE
13565: EQUAL
13566: IFTRUE 13570
13568: GO 13596
13570: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13571: LD_ADDR_VAR 0 3
13575: PUSH
13576: LD_INT 11
13578: PUSH
13579: LD_INT 12
13581: PUSH
13582: LD_INT 13
13584: PUSH
13585: LD_INT 14
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: ST_TO_ADDR
13594: GO 14171
13596: LD_INT 24
13598: DOUBLE
13599: EQUAL
13600: IFTRUE 13604
13602: GO 13630
13604: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13605: LD_ADDR_VAR 0 3
13609: PUSH
13610: LD_INT 11
13612: PUSH
13613: LD_INT 12
13615: PUSH
13616: LD_INT 13
13618: PUSH
13619: LD_INT 14
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: ST_TO_ADDR
13628: GO 14171
13630: LD_INT 30
13632: DOUBLE
13633: EQUAL
13634: IFTRUE 13638
13636: GO 13664
13638: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13639: LD_ADDR_VAR 0 3
13643: PUSH
13644: LD_INT 11
13646: PUSH
13647: LD_INT 12
13649: PUSH
13650: LD_INT 13
13652: PUSH
13653: LD_INT 14
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: ST_TO_ADDR
13662: GO 14171
13664: LD_INT 25
13666: DOUBLE
13667: EQUAL
13668: IFTRUE 13672
13670: GO 13690
13672: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13673: LD_ADDR_VAR 0 3
13677: PUSH
13678: LD_INT 13
13680: PUSH
13681: LD_INT 14
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: ST_TO_ADDR
13688: GO 14171
13690: LD_INT 27
13692: DOUBLE
13693: EQUAL
13694: IFTRUE 13698
13696: GO 13716
13698: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13699: LD_ADDR_VAR 0 3
13703: PUSH
13704: LD_INT 13
13706: PUSH
13707: LD_INT 14
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: ST_TO_ADDR
13714: GO 14171
13716: LD_INT 92
13718: DOUBLE
13719: EQUAL
13720: IFTRUE 13724
13722: GO 13750
13724: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13725: LD_ADDR_VAR 0 3
13729: PUSH
13730: LD_INT 11
13732: PUSH
13733: LD_INT 12
13735: PUSH
13736: LD_INT 13
13738: PUSH
13739: LD_INT 14
13741: PUSH
13742: EMPTY
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: ST_TO_ADDR
13748: GO 14171
13750: LD_INT 28
13752: DOUBLE
13753: EQUAL
13754: IFTRUE 13758
13756: GO 13776
13758: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13759: LD_ADDR_VAR 0 3
13763: PUSH
13764: LD_INT 13
13766: PUSH
13767: LD_INT 14
13769: PUSH
13770: EMPTY
13771: LIST
13772: LIST
13773: ST_TO_ADDR
13774: GO 14171
13776: LD_INT 29
13778: DOUBLE
13779: EQUAL
13780: IFTRUE 13784
13782: GO 13802
13784: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13785: LD_ADDR_VAR 0 3
13789: PUSH
13790: LD_INT 13
13792: PUSH
13793: LD_INT 14
13795: PUSH
13796: EMPTY
13797: LIST
13798: LIST
13799: ST_TO_ADDR
13800: GO 14171
13802: LD_INT 31
13804: DOUBLE
13805: EQUAL
13806: IFTRUE 13810
13808: GO 13828
13810: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13811: LD_ADDR_VAR 0 3
13815: PUSH
13816: LD_INT 13
13818: PUSH
13819: LD_INT 14
13821: PUSH
13822: EMPTY
13823: LIST
13824: LIST
13825: ST_TO_ADDR
13826: GO 14171
13828: LD_INT 26
13830: DOUBLE
13831: EQUAL
13832: IFTRUE 13836
13834: GO 13854
13836: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13837: LD_ADDR_VAR 0 3
13841: PUSH
13842: LD_INT 13
13844: PUSH
13845: LD_INT 14
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: ST_TO_ADDR
13852: GO 14171
13854: LD_INT 42
13856: DOUBLE
13857: EQUAL
13858: IFTRUE 13862
13860: GO 13888
13862: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13863: LD_ADDR_VAR 0 3
13867: PUSH
13868: LD_INT 21
13870: PUSH
13871: LD_INT 22
13873: PUSH
13874: LD_INT 23
13876: PUSH
13877: LD_INT 24
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: ST_TO_ADDR
13886: GO 14171
13888: LD_INT 43
13890: DOUBLE
13891: EQUAL
13892: IFTRUE 13896
13894: GO 13922
13896: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13897: LD_ADDR_VAR 0 3
13901: PUSH
13902: LD_INT 21
13904: PUSH
13905: LD_INT 22
13907: PUSH
13908: LD_INT 23
13910: PUSH
13911: LD_INT 24
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: ST_TO_ADDR
13920: GO 14171
13922: LD_INT 44
13924: DOUBLE
13925: EQUAL
13926: IFTRUE 13930
13928: GO 13956
13930: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13931: LD_ADDR_VAR 0 3
13935: PUSH
13936: LD_INT 21
13938: PUSH
13939: LD_INT 22
13941: PUSH
13942: LD_INT 23
13944: PUSH
13945: LD_INT 24
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: ST_TO_ADDR
13954: GO 14171
13956: LD_INT 45
13958: DOUBLE
13959: EQUAL
13960: IFTRUE 13964
13962: GO 13990
13964: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13965: LD_ADDR_VAR 0 3
13969: PUSH
13970: LD_INT 21
13972: PUSH
13973: LD_INT 22
13975: PUSH
13976: LD_INT 23
13978: PUSH
13979: LD_INT 24
13981: PUSH
13982: EMPTY
13983: LIST
13984: LIST
13985: LIST
13986: LIST
13987: ST_TO_ADDR
13988: GO 14171
13990: LD_INT 49
13992: DOUBLE
13993: EQUAL
13994: IFTRUE 13998
13996: GO 14024
13998: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
13999: LD_ADDR_VAR 0 3
14003: PUSH
14004: LD_INT 21
14006: PUSH
14007: LD_INT 22
14009: PUSH
14010: LD_INT 23
14012: PUSH
14013: LD_INT 24
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: ST_TO_ADDR
14022: GO 14171
14024: LD_INT 51
14026: DOUBLE
14027: EQUAL
14028: IFTRUE 14032
14030: GO 14058
14032: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14033: LD_ADDR_VAR 0 3
14037: PUSH
14038: LD_INT 21
14040: PUSH
14041: LD_INT 22
14043: PUSH
14044: LD_INT 23
14046: PUSH
14047: LD_INT 24
14049: PUSH
14050: EMPTY
14051: LIST
14052: LIST
14053: LIST
14054: LIST
14055: ST_TO_ADDR
14056: GO 14171
14058: LD_INT 52
14060: DOUBLE
14061: EQUAL
14062: IFTRUE 14066
14064: GO 14092
14066: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14067: LD_ADDR_VAR 0 3
14071: PUSH
14072: LD_INT 21
14074: PUSH
14075: LD_INT 22
14077: PUSH
14078: LD_INT 23
14080: PUSH
14081: LD_INT 24
14083: PUSH
14084: EMPTY
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: ST_TO_ADDR
14090: GO 14171
14092: LD_INT 53
14094: DOUBLE
14095: EQUAL
14096: IFTRUE 14100
14098: GO 14118
14100: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14101: LD_ADDR_VAR 0 3
14105: PUSH
14106: LD_INT 23
14108: PUSH
14109: LD_INT 24
14111: PUSH
14112: EMPTY
14113: LIST
14114: LIST
14115: ST_TO_ADDR
14116: GO 14171
14118: LD_INT 46
14120: DOUBLE
14121: EQUAL
14122: IFTRUE 14126
14124: GO 14144
14126: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14127: LD_ADDR_VAR 0 3
14131: PUSH
14132: LD_INT 23
14134: PUSH
14135: LD_INT 24
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: ST_TO_ADDR
14142: GO 14171
14144: LD_INT 47
14146: DOUBLE
14147: EQUAL
14148: IFTRUE 14152
14150: GO 14170
14152: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14153: LD_ADDR_VAR 0 3
14157: PUSH
14158: LD_INT 23
14160: PUSH
14161: LD_INT 24
14163: PUSH
14164: EMPTY
14165: LIST
14166: LIST
14167: ST_TO_ADDR
14168: GO 14171
14170: POP
// result := ( chassis in result ) ;
14171: LD_ADDR_VAR 0 3
14175: PUSH
14176: LD_VAR 0 1
14180: PUSH
14181: LD_VAR 0 3
14185: IN
14186: ST_TO_ADDR
// end ;
14187: LD_VAR 0 3
14191: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14192: LD_INT 0
14194: PPUSH
14195: PPUSH
14196: PPUSH
14197: PPUSH
14198: PPUSH
14199: PPUSH
14200: PPUSH
// result := array ;
14201: LD_ADDR_VAR 0 5
14205: PUSH
14206: LD_VAR 0 1
14210: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14211: LD_VAR 0 1
14215: NOT
14216: PUSH
14217: LD_VAR 0 2
14221: NOT
14222: OR
14223: PUSH
14224: LD_VAR 0 3
14228: NOT
14229: OR
14230: PUSH
14231: LD_VAR 0 2
14235: PUSH
14236: LD_VAR 0 1
14240: GREATER
14241: OR
14242: PUSH
14243: LD_VAR 0 3
14247: PUSH
14248: LD_VAR 0 1
14252: GREATER
14253: OR
14254: IFFALSE 14258
// exit ;
14256: GO 14554
// if direction then
14258: LD_VAR 0 4
14262: IFFALSE 14326
// begin d := 1 ;
14264: LD_ADDR_VAR 0 9
14268: PUSH
14269: LD_INT 1
14271: ST_TO_ADDR
// if i_from > i_to then
14272: LD_VAR 0 2
14276: PUSH
14277: LD_VAR 0 3
14281: GREATER
14282: IFFALSE 14308
// length := ( array - i_from ) + i_to else
14284: LD_ADDR_VAR 0 11
14288: PUSH
14289: LD_VAR 0 1
14293: PUSH
14294: LD_VAR 0 2
14298: MINUS
14299: PUSH
14300: LD_VAR 0 3
14304: PLUS
14305: ST_TO_ADDR
14306: GO 14324
// length := i_to - i_from ;
14308: LD_ADDR_VAR 0 11
14312: PUSH
14313: LD_VAR 0 3
14317: PUSH
14318: LD_VAR 0 2
14322: MINUS
14323: ST_TO_ADDR
// end else
14324: GO 14387
// begin d := - 1 ;
14326: LD_ADDR_VAR 0 9
14330: PUSH
14331: LD_INT 1
14333: NEG
14334: ST_TO_ADDR
// if i_from > i_to then
14335: LD_VAR 0 2
14339: PUSH
14340: LD_VAR 0 3
14344: GREATER
14345: IFFALSE 14365
// length := i_from - i_to else
14347: LD_ADDR_VAR 0 11
14351: PUSH
14352: LD_VAR 0 2
14356: PUSH
14357: LD_VAR 0 3
14361: MINUS
14362: ST_TO_ADDR
14363: GO 14387
// length := ( array - i_to ) + i_from ;
14365: LD_ADDR_VAR 0 11
14369: PUSH
14370: LD_VAR 0 1
14374: PUSH
14375: LD_VAR 0 3
14379: MINUS
14380: PUSH
14381: LD_VAR 0 2
14385: PLUS
14386: ST_TO_ADDR
// end ; if not length then
14387: LD_VAR 0 11
14391: NOT
14392: IFFALSE 14396
// exit ;
14394: GO 14554
// tmp := array ;
14396: LD_ADDR_VAR 0 10
14400: PUSH
14401: LD_VAR 0 1
14405: ST_TO_ADDR
// for i = 1 to length do
14406: LD_ADDR_VAR 0 6
14410: PUSH
14411: DOUBLE
14412: LD_INT 1
14414: DEC
14415: ST_TO_ADDR
14416: LD_VAR 0 11
14420: PUSH
14421: FOR_TO
14422: IFFALSE 14542
// begin for j = 1 to array do
14424: LD_ADDR_VAR 0 7
14428: PUSH
14429: DOUBLE
14430: LD_INT 1
14432: DEC
14433: ST_TO_ADDR
14434: LD_VAR 0 1
14438: PUSH
14439: FOR_TO
14440: IFFALSE 14528
// begin k := j + d ;
14442: LD_ADDR_VAR 0 8
14446: PUSH
14447: LD_VAR 0 7
14451: PUSH
14452: LD_VAR 0 9
14456: PLUS
14457: ST_TO_ADDR
// if k > array then
14458: LD_VAR 0 8
14462: PUSH
14463: LD_VAR 0 1
14467: GREATER
14468: IFFALSE 14478
// k := 1 ;
14470: LD_ADDR_VAR 0 8
14474: PUSH
14475: LD_INT 1
14477: ST_TO_ADDR
// if not k then
14478: LD_VAR 0 8
14482: NOT
14483: IFFALSE 14495
// k := array ;
14485: LD_ADDR_VAR 0 8
14489: PUSH
14490: LD_VAR 0 1
14494: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14495: LD_ADDR_VAR 0 10
14499: PUSH
14500: LD_VAR 0 10
14504: PPUSH
14505: LD_VAR 0 8
14509: PPUSH
14510: LD_VAR 0 1
14514: PUSH
14515: LD_VAR 0 7
14519: ARRAY
14520: PPUSH
14521: CALL_OW 1
14525: ST_TO_ADDR
// end ;
14526: GO 14439
14528: POP
14529: POP
// array := tmp ;
14530: LD_ADDR_VAR 0 1
14534: PUSH
14535: LD_VAR 0 10
14539: ST_TO_ADDR
// end ;
14540: GO 14421
14542: POP
14543: POP
// result := array ;
14544: LD_ADDR_VAR 0 5
14548: PUSH
14549: LD_VAR 0 1
14553: ST_TO_ADDR
// end ;
14554: LD_VAR 0 5
14558: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14559: LD_INT 0
14561: PPUSH
14562: PPUSH
// result := 0 ;
14563: LD_ADDR_VAR 0 3
14567: PUSH
14568: LD_INT 0
14570: ST_TO_ADDR
// if not array or not value in array then
14571: LD_VAR 0 1
14575: NOT
14576: PUSH
14577: LD_VAR 0 2
14581: PUSH
14582: LD_VAR 0 1
14586: IN
14587: NOT
14588: OR
14589: IFFALSE 14593
// exit ;
14591: GO 14647
// for i = 1 to array do
14593: LD_ADDR_VAR 0 4
14597: PUSH
14598: DOUBLE
14599: LD_INT 1
14601: DEC
14602: ST_TO_ADDR
14603: LD_VAR 0 1
14607: PUSH
14608: FOR_TO
14609: IFFALSE 14645
// if value = array [ i ] then
14611: LD_VAR 0 2
14615: PUSH
14616: LD_VAR 0 1
14620: PUSH
14621: LD_VAR 0 4
14625: ARRAY
14626: EQUAL
14627: IFFALSE 14643
// begin result := i ;
14629: LD_ADDR_VAR 0 3
14633: PUSH
14634: LD_VAR 0 4
14638: ST_TO_ADDR
// exit ;
14639: POP
14640: POP
14641: GO 14647
// end ;
14643: GO 14608
14645: POP
14646: POP
// end ;
14647: LD_VAR 0 3
14651: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14652: LD_INT 0
14654: PPUSH
// vc_chassis := chassis ;
14655: LD_ADDR_OWVAR 37
14659: PUSH
14660: LD_VAR 0 1
14664: ST_TO_ADDR
// vc_engine := engine ;
14665: LD_ADDR_OWVAR 39
14669: PUSH
14670: LD_VAR 0 2
14674: ST_TO_ADDR
// vc_control := control ;
14675: LD_ADDR_OWVAR 38
14679: PUSH
14680: LD_VAR 0 3
14684: ST_TO_ADDR
// vc_weapon := weapon ;
14685: LD_ADDR_OWVAR 40
14689: PUSH
14690: LD_VAR 0 4
14694: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14695: LD_ADDR_OWVAR 41
14699: PUSH
14700: LD_VAR 0 5
14704: ST_TO_ADDR
// end ;
14705: LD_VAR 0 6
14709: RET
// export function WantPlant ( unit ) ; var task ; begin
14710: LD_INT 0
14712: PPUSH
14713: PPUSH
// result := false ;
14714: LD_ADDR_VAR 0 2
14718: PUSH
14719: LD_INT 0
14721: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14722: LD_ADDR_VAR 0 3
14726: PUSH
14727: LD_VAR 0 1
14731: PPUSH
14732: CALL_OW 437
14736: ST_TO_ADDR
// if task then
14737: LD_VAR 0 3
14741: IFFALSE 14769
// if task [ 1 ] [ 1 ] = p then
14743: LD_VAR 0 3
14747: PUSH
14748: LD_INT 1
14750: ARRAY
14751: PUSH
14752: LD_INT 1
14754: ARRAY
14755: PUSH
14756: LD_STRING p
14758: EQUAL
14759: IFFALSE 14769
// result := true ;
14761: LD_ADDR_VAR 0 2
14765: PUSH
14766: LD_INT 1
14768: ST_TO_ADDR
// end ;
14769: LD_VAR 0 2
14773: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14774: LD_INT 0
14776: PPUSH
14777: PPUSH
14778: PPUSH
14779: PPUSH
// if pos < 1 then
14780: LD_VAR 0 2
14784: PUSH
14785: LD_INT 1
14787: LESS
14788: IFFALSE 14792
// exit ;
14790: GO 15095
// if pos = 1 then
14792: LD_VAR 0 2
14796: PUSH
14797: LD_INT 1
14799: EQUAL
14800: IFFALSE 14833
// result := Replace ( arr , pos [ 1 ] , value ) else
14802: LD_ADDR_VAR 0 4
14806: PUSH
14807: LD_VAR 0 1
14811: PPUSH
14812: LD_VAR 0 2
14816: PUSH
14817: LD_INT 1
14819: ARRAY
14820: PPUSH
14821: LD_VAR 0 3
14825: PPUSH
14826: CALL_OW 1
14830: ST_TO_ADDR
14831: GO 15095
// begin tmp := arr ;
14833: LD_ADDR_VAR 0 6
14837: PUSH
14838: LD_VAR 0 1
14842: ST_TO_ADDR
// s_arr := [ tmp ] ;
14843: LD_ADDR_VAR 0 7
14847: PUSH
14848: LD_VAR 0 6
14852: PUSH
14853: EMPTY
14854: LIST
14855: ST_TO_ADDR
// for i = 1 to pos - 1 do
14856: LD_ADDR_VAR 0 5
14860: PUSH
14861: DOUBLE
14862: LD_INT 1
14864: DEC
14865: ST_TO_ADDR
14866: LD_VAR 0 2
14870: PUSH
14871: LD_INT 1
14873: MINUS
14874: PUSH
14875: FOR_TO
14876: IFFALSE 14921
// begin tmp := tmp [ pos [ i ] ] ;
14878: LD_ADDR_VAR 0 6
14882: PUSH
14883: LD_VAR 0 6
14887: PUSH
14888: LD_VAR 0 2
14892: PUSH
14893: LD_VAR 0 5
14897: ARRAY
14898: ARRAY
14899: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14900: LD_ADDR_VAR 0 7
14904: PUSH
14905: LD_VAR 0 7
14909: PUSH
14910: LD_VAR 0 6
14914: PUSH
14915: EMPTY
14916: LIST
14917: ADD
14918: ST_TO_ADDR
// end ;
14919: GO 14875
14921: POP
14922: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14923: LD_ADDR_VAR 0 6
14927: PUSH
14928: LD_VAR 0 6
14932: PPUSH
14933: LD_VAR 0 2
14937: PUSH
14938: LD_VAR 0 2
14942: ARRAY
14943: PPUSH
14944: LD_VAR 0 3
14948: PPUSH
14949: CALL_OW 1
14953: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14954: LD_ADDR_VAR 0 7
14958: PUSH
14959: LD_VAR 0 7
14963: PPUSH
14964: LD_VAR 0 7
14968: PPUSH
14969: LD_VAR 0 6
14973: PPUSH
14974: CALL_OW 1
14978: ST_TO_ADDR
// for i = s_arr downto 2 do
14979: LD_ADDR_VAR 0 5
14983: PUSH
14984: DOUBLE
14985: LD_VAR 0 7
14989: INC
14990: ST_TO_ADDR
14991: LD_INT 2
14993: PUSH
14994: FOR_DOWNTO
14995: IFFALSE 15079
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
14997: LD_ADDR_VAR 0 6
15001: PUSH
15002: LD_VAR 0 7
15006: PUSH
15007: LD_VAR 0 5
15011: PUSH
15012: LD_INT 1
15014: MINUS
15015: ARRAY
15016: PPUSH
15017: LD_VAR 0 2
15021: PUSH
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 1
15029: MINUS
15030: ARRAY
15031: PPUSH
15032: LD_VAR 0 7
15036: PUSH
15037: LD_VAR 0 5
15041: ARRAY
15042: PPUSH
15043: CALL_OW 1
15047: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15048: LD_ADDR_VAR 0 7
15052: PUSH
15053: LD_VAR 0 7
15057: PPUSH
15058: LD_VAR 0 5
15062: PUSH
15063: LD_INT 1
15065: MINUS
15066: PPUSH
15067: LD_VAR 0 6
15071: PPUSH
15072: CALL_OW 1
15076: ST_TO_ADDR
// end ;
15077: GO 14994
15079: POP
15080: POP
// result := s_arr [ 1 ] ;
15081: LD_ADDR_VAR 0 4
15085: PUSH
15086: LD_VAR 0 7
15090: PUSH
15091: LD_INT 1
15093: ARRAY
15094: ST_TO_ADDR
// end ; end ;
15095: LD_VAR 0 4
15099: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15100: LD_INT 0
15102: PPUSH
15103: PPUSH
// if not list then
15104: LD_VAR 0 1
15108: NOT
15109: IFFALSE 15113
// exit ;
15111: GO 15204
// i := list [ pos1 ] ;
15113: LD_ADDR_VAR 0 5
15117: PUSH
15118: LD_VAR 0 1
15122: PUSH
15123: LD_VAR 0 2
15127: ARRAY
15128: ST_TO_ADDR
// if not i then
15129: LD_VAR 0 5
15133: NOT
15134: IFFALSE 15138
// exit ;
15136: GO 15204
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15138: LD_ADDR_VAR 0 1
15142: PUSH
15143: LD_VAR 0 1
15147: PPUSH
15148: LD_VAR 0 2
15152: PPUSH
15153: LD_VAR 0 1
15157: PUSH
15158: LD_VAR 0 3
15162: ARRAY
15163: PPUSH
15164: CALL_OW 1
15168: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15169: LD_ADDR_VAR 0 1
15173: PUSH
15174: LD_VAR 0 1
15178: PPUSH
15179: LD_VAR 0 3
15183: PPUSH
15184: LD_VAR 0 5
15188: PPUSH
15189: CALL_OW 1
15193: ST_TO_ADDR
// result := list ;
15194: LD_ADDR_VAR 0 4
15198: PUSH
15199: LD_VAR 0 1
15203: ST_TO_ADDR
// end ;
15204: LD_VAR 0 4
15208: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15209: LD_INT 0
15211: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15212: LD_ADDR_VAR 0 5
15216: PUSH
15217: LD_VAR 0 1
15221: PPUSH
15222: CALL_OW 250
15226: PPUSH
15227: LD_VAR 0 1
15231: PPUSH
15232: CALL_OW 251
15236: PPUSH
15237: LD_VAR 0 2
15241: PPUSH
15242: LD_VAR 0 3
15246: PPUSH
15247: LD_VAR 0 4
15251: PPUSH
15252: CALL 15262 0 5
15256: ST_TO_ADDR
// end ;
15257: LD_VAR 0 5
15261: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15262: LD_INT 0
15264: PPUSH
15265: PPUSH
15266: PPUSH
15267: PPUSH
// if not list then
15268: LD_VAR 0 3
15272: NOT
15273: IFFALSE 15277
// exit ;
15275: GO 15665
// result := [ ] ;
15277: LD_ADDR_VAR 0 6
15281: PUSH
15282: EMPTY
15283: ST_TO_ADDR
// for i in list do
15284: LD_ADDR_VAR 0 7
15288: PUSH
15289: LD_VAR 0 3
15293: PUSH
15294: FOR_IN
15295: IFFALSE 15497
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15297: LD_ADDR_VAR 0 9
15301: PUSH
15302: LD_VAR 0 7
15306: PPUSH
15307: LD_VAR 0 1
15311: PPUSH
15312: LD_VAR 0 2
15316: PPUSH
15317: CALL_OW 297
15321: ST_TO_ADDR
// if not result then
15322: LD_VAR 0 6
15326: NOT
15327: IFFALSE 15353
// result := [ [ i , tmp ] ] else
15329: LD_ADDR_VAR 0 6
15333: PUSH
15334: LD_VAR 0 7
15338: PUSH
15339: LD_VAR 0 9
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: PUSH
15348: EMPTY
15349: LIST
15350: ST_TO_ADDR
15351: GO 15495
// begin if result [ result ] [ 2 ] < tmp then
15353: LD_VAR 0 6
15357: PUSH
15358: LD_VAR 0 6
15362: ARRAY
15363: PUSH
15364: LD_INT 2
15366: ARRAY
15367: PUSH
15368: LD_VAR 0 9
15372: LESS
15373: IFFALSE 15415
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15375: LD_ADDR_VAR 0 6
15379: PUSH
15380: LD_VAR 0 6
15384: PPUSH
15385: LD_VAR 0 6
15389: PUSH
15390: LD_INT 1
15392: PLUS
15393: PPUSH
15394: LD_VAR 0 7
15398: PUSH
15399: LD_VAR 0 9
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PPUSH
15408: CALL_OW 2
15412: ST_TO_ADDR
15413: GO 15495
// for j = 1 to result do
15415: LD_ADDR_VAR 0 8
15419: PUSH
15420: DOUBLE
15421: LD_INT 1
15423: DEC
15424: ST_TO_ADDR
15425: LD_VAR 0 6
15429: PUSH
15430: FOR_TO
15431: IFFALSE 15493
// begin if tmp < result [ j ] [ 2 ] then
15433: LD_VAR 0 9
15437: PUSH
15438: LD_VAR 0 6
15442: PUSH
15443: LD_VAR 0 8
15447: ARRAY
15448: PUSH
15449: LD_INT 2
15451: ARRAY
15452: LESS
15453: IFFALSE 15491
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15455: LD_ADDR_VAR 0 6
15459: PUSH
15460: LD_VAR 0 6
15464: PPUSH
15465: LD_VAR 0 8
15469: PPUSH
15470: LD_VAR 0 7
15474: PUSH
15475: LD_VAR 0 9
15479: PUSH
15480: EMPTY
15481: LIST
15482: LIST
15483: PPUSH
15484: CALL_OW 2
15488: ST_TO_ADDR
// break ;
15489: GO 15493
// end ; end ;
15491: GO 15430
15493: POP
15494: POP
// end ; end ;
15495: GO 15294
15497: POP
15498: POP
// if result and not asc then
15499: LD_VAR 0 6
15503: PUSH
15504: LD_VAR 0 4
15508: NOT
15509: AND
15510: IFFALSE 15585
// begin tmp := result ;
15512: LD_ADDR_VAR 0 9
15516: PUSH
15517: LD_VAR 0 6
15521: ST_TO_ADDR
// for i = tmp downto 1 do
15522: LD_ADDR_VAR 0 7
15526: PUSH
15527: DOUBLE
15528: LD_VAR 0 9
15532: INC
15533: ST_TO_ADDR
15534: LD_INT 1
15536: PUSH
15537: FOR_DOWNTO
15538: IFFALSE 15583
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15540: LD_ADDR_VAR 0 6
15544: PUSH
15545: LD_VAR 0 6
15549: PPUSH
15550: LD_VAR 0 9
15554: PUSH
15555: LD_VAR 0 7
15559: MINUS
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_VAR 0 9
15569: PUSH
15570: LD_VAR 0 7
15574: ARRAY
15575: PPUSH
15576: CALL_OW 1
15580: ST_TO_ADDR
15581: GO 15537
15583: POP
15584: POP
// end ; tmp := [ ] ;
15585: LD_ADDR_VAR 0 9
15589: PUSH
15590: EMPTY
15591: ST_TO_ADDR
// if mode then
15592: LD_VAR 0 5
15596: IFFALSE 15665
// begin for i = 1 to result do
15598: LD_ADDR_VAR 0 7
15602: PUSH
15603: DOUBLE
15604: LD_INT 1
15606: DEC
15607: ST_TO_ADDR
15608: LD_VAR 0 6
15612: PUSH
15613: FOR_TO
15614: IFFALSE 15653
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15616: LD_ADDR_VAR 0 9
15620: PUSH
15621: LD_VAR 0 9
15625: PPUSH
15626: LD_VAR 0 7
15630: PPUSH
15631: LD_VAR 0 6
15635: PUSH
15636: LD_VAR 0 7
15640: ARRAY
15641: PUSH
15642: LD_INT 1
15644: ARRAY
15645: PPUSH
15646: CALL_OW 1
15650: ST_TO_ADDR
15651: GO 15613
15653: POP
15654: POP
// result := tmp ;
15655: LD_ADDR_VAR 0 6
15659: PUSH
15660: LD_VAR 0 9
15664: ST_TO_ADDR
// end ; end ;
15665: LD_VAR 0 6
15669: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15670: LD_INT 0
15672: PPUSH
15673: PPUSH
15674: PPUSH
15675: PPUSH
15676: PPUSH
15677: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15678: LD_ADDR_VAR 0 5
15682: PUSH
15683: LD_INT 0
15685: PUSH
15686: LD_INT 0
15688: PUSH
15689: LD_INT 0
15691: PUSH
15692: EMPTY
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: LIST
15698: LIST
15699: ST_TO_ADDR
// if not x or not y then
15700: LD_VAR 0 2
15704: NOT
15705: PUSH
15706: LD_VAR 0 3
15710: NOT
15711: OR
15712: IFFALSE 15716
// exit ;
15714: GO 17366
// if not range then
15716: LD_VAR 0 4
15720: NOT
15721: IFFALSE 15731
// range := 10 ;
15723: LD_ADDR_VAR 0 4
15727: PUSH
15728: LD_INT 10
15730: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15731: LD_ADDR_VAR 0 8
15735: PUSH
15736: LD_INT 81
15738: PUSH
15739: LD_VAR 0 1
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: PUSH
15748: LD_INT 92
15750: PUSH
15751: LD_VAR 0 2
15755: PUSH
15756: LD_VAR 0 3
15760: PUSH
15761: LD_VAR 0 4
15765: PUSH
15766: EMPTY
15767: LIST
15768: LIST
15769: LIST
15770: LIST
15771: PUSH
15772: LD_INT 3
15774: PUSH
15775: LD_INT 21
15777: PUSH
15778: LD_INT 3
15780: PUSH
15781: EMPTY
15782: LIST
15783: LIST
15784: PUSH
15785: EMPTY
15786: LIST
15787: LIST
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: LIST
15793: PPUSH
15794: CALL_OW 69
15798: ST_TO_ADDR
// if not tmp then
15799: LD_VAR 0 8
15803: NOT
15804: IFFALSE 15808
// exit ;
15806: GO 17366
// for i in tmp do
15808: LD_ADDR_VAR 0 6
15812: PUSH
15813: LD_VAR 0 8
15817: PUSH
15818: FOR_IN
15819: IFFALSE 17341
// begin points := [ 0 , 0 , 0 ] ;
15821: LD_ADDR_VAR 0 9
15825: PUSH
15826: LD_INT 0
15828: PUSH
15829: LD_INT 0
15831: PUSH
15832: LD_INT 0
15834: PUSH
15835: EMPTY
15836: LIST
15837: LIST
15838: LIST
15839: ST_TO_ADDR
// bpoints := 1 ;
15840: LD_ADDR_VAR 0 10
15844: PUSH
15845: LD_INT 1
15847: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15848: LD_VAR 0 6
15852: PPUSH
15853: CALL_OW 247
15857: PUSH
15858: LD_INT 1
15860: DOUBLE
15861: EQUAL
15862: IFTRUE 15866
15864: GO 16444
15866: POP
// begin if GetClass ( i ) = 1 then
15867: LD_VAR 0 6
15871: PPUSH
15872: CALL_OW 257
15876: PUSH
15877: LD_INT 1
15879: EQUAL
15880: IFFALSE 15901
// points := [ 10 , 5 , 3 ] ;
15882: LD_ADDR_VAR 0 9
15886: PUSH
15887: LD_INT 10
15889: PUSH
15890: LD_INT 5
15892: PUSH
15893: LD_INT 3
15895: PUSH
15896: EMPTY
15897: LIST
15898: LIST
15899: LIST
15900: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15901: LD_VAR 0 6
15905: PPUSH
15906: CALL_OW 257
15910: PUSH
15911: LD_INT 2
15913: PUSH
15914: LD_INT 3
15916: PUSH
15917: LD_INT 4
15919: PUSH
15920: EMPTY
15921: LIST
15922: LIST
15923: LIST
15924: IN
15925: IFFALSE 15946
// points := [ 3 , 2 , 1 ] ;
15927: LD_ADDR_VAR 0 9
15931: PUSH
15932: LD_INT 3
15934: PUSH
15935: LD_INT 2
15937: PUSH
15938: LD_INT 1
15940: PUSH
15941: EMPTY
15942: LIST
15943: LIST
15944: LIST
15945: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15946: LD_VAR 0 6
15950: PPUSH
15951: CALL_OW 257
15955: PUSH
15956: LD_INT 5
15958: EQUAL
15959: IFFALSE 15980
// points := [ 130 , 5 , 2 ] ;
15961: LD_ADDR_VAR 0 9
15965: PUSH
15966: LD_INT 130
15968: PUSH
15969: LD_INT 5
15971: PUSH
15972: LD_INT 2
15974: PUSH
15975: EMPTY
15976: LIST
15977: LIST
15978: LIST
15979: ST_TO_ADDR
// if GetClass ( i ) = 8 then
15980: LD_VAR 0 6
15984: PPUSH
15985: CALL_OW 257
15989: PUSH
15990: LD_INT 8
15992: EQUAL
15993: IFFALSE 16014
// points := [ 35 , 35 , 30 ] ;
15995: LD_ADDR_VAR 0 9
15999: PUSH
16000: LD_INT 35
16002: PUSH
16003: LD_INT 35
16005: PUSH
16006: LD_INT 30
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: LIST
16013: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16014: LD_VAR 0 6
16018: PPUSH
16019: CALL_OW 257
16023: PUSH
16024: LD_INT 9
16026: EQUAL
16027: IFFALSE 16048
// points := [ 20 , 55 , 40 ] ;
16029: LD_ADDR_VAR 0 9
16033: PUSH
16034: LD_INT 20
16036: PUSH
16037: LD_INT 55
16039: PUSH
16040: LD_INT 40
16042: PUSH
16043: EMPTY
16044: LIST
16045: LIST
16046: LIST
16047: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16048: LD_VAR 0 6
16052: PPUSH
16053: CALL_OW 257
16057: PUSH
16058: LD_INT 12
16060: PUSH
16061: LD_INT 16
16063: PUSH
16064: EMPTY
16065: LIST
16066: LIST
16067: IN
16068: IFFALSE 16089
// points := [ 5 , 3 , 2 ] ;
16070: LD_ADDR_VAR 0 9
16074: PUSH
16075: LD_INT 5
16077: PUSH
16078: LD_INT 3
16080: PUSH
16081: LD_INT 2
16083: PUSH
16084: EMPTY
16085: LIST
16086: LIST
16087: LIST
16088: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16089: LD_VAR 0 6
16093: PPUSH
16094: CALL_OW 257
16098: PUSH
16099: LD_INT 17
16101: EQUAL
16102: IFFALSE 16123
// points := [ 100 , 50 , 75 ] ;
16104: LD_ADDR_VAR 0 9
16108: PUSH
16109: LD_INT 100
16111: PUSH
16112: LD_INT 50
16114: PUSH
16115: LD_INT 75
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: LIST
16122: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16123: LD_VAR 0 6
16127: PPUSH
16128: CALL_OW 257
16132: PUSH
16133: LD_INT 15
16135: EQUAL
16136: IFFALSE 16157
// points := [ 10 , 5 , 3 ] ;
16138: LD_ADDR_VAR 0 9
16142: PUSH
16143: LD_INT 10
16145: PUSH
16146: LD_INT 5
16148: PUSH
16149: LD_INT 3
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: LIST
16156: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16157: LD_VAR 0 6
16161: PPUSH
16162: CALL_OW 257
16166: PUSH
16167: LD_INT 14
16169: EQUAL
16170: IFFALSE 16191
// points := [ 10 , 0 , 0 ] ;
16172: LD_ADDR_VAR 0 9
16176: PUSH
16177: LD_INT 10
16179: PUSH
16180: LD_INT 0
16182: PUSH
16183: LD_INT 0
16185: PUSH
16186: EMPTY
16187: LIST
16188: LIST
16189: LIST
16190: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16191: LD_VAR 0 6
16195: PPUSH
16196: CALL_OW 257
16200: PUSH
16201: LD_INT 11
16203: EQUAL
16204: IFFALSE 16225
// points := [ 30 , 10 , 5 ] ;
16206: LD_ADDR_VAR 0 9
16210: PUSH
16211: LD_INT 30
16213: PUSH
16214: LD_INT 10
16216: PUSH
16217: LD_INT 5
16219: PUSH
16220: EMPTY
16221: LIST
16222: LIST
16223: LIST
16224: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16225: LD_VAR 0 1
16229: PPUSH
16230: LD_INT 5
16232: PPUSH
16233: CALL_OW 321
16237: PUSH
16238: LD_INT 2
16240: EQUAL
16241: IFFALSE 16258
// bpoints := bpoints * 1.8 ;
16243: LD_ADDR_VAR 0 10
16247: PUSH
16248: LD_VAR 0 10
16252: PUSH
16253: LD_REAL  1.80000000000000E+0000
16256: MUL
16257: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16258: LD_VAR 0 6
16262: PPUSH
16263: CALL_OW 257
16267: PUSH
16268: LD_INT 1
16270: PUSH
16271: LD_INT 2
16273: PUSH
16274: LD_INT 3
16276: PUSH
16277: LD_INT 4
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: LIST
16284: LIST
16285: IN
16286: PUSH
16287: LD_VAR 0 1
16291: PPUSH
16292: LD_INT 51
16294: PPUSH
16295: CALL_OW 321
16299: PUSH
16300: LD_INT 2
16302: EQUAL
16303: AND
16304: IFFALSE 16321
// bpoints := bpoints * 1.2 ;
16306: LD_ADDR_VAR 0 10
16310: PUSH
16311: LD_VAR 0 10
16315: PUSH
16316: LD_REAL  1.20000000000000E+0000
16319: MUL
16320: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16321: LD_VAR 0 6
16325: PPUSH
16326: CALL_OW 257
16330: PUSH
16331: LD_INT 5
16333: PUSH
16334: LD_INT 7
16336: PUSH
16337: LD_INT 9
16339: PUSH
16340: EMPTY
16341: LIST
16342: LIST
16343: LIST
16344: IN
16345: PUSH
16346: LD_VAR 0 1
16350: PPUSH
16351: LD_INT 52
16353: PPUSH
16354: CALL_OW 321
16358: PUSH
16359: LD_INT 2
16361: EQUAL
16362: AND
16363: IFFALSE 16380
// bpoints := bpoints * 1.5 ;
16365: LD_ADDR_VAR 0 10
16369: PUSH
16370: LD_VAR 0 10
16374: PUSH
16375: LD_REAL  1.50000000000000E+0000
16378: MUL
16379: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16380: LD_VAR 0 1
16384: PPUSH
16385: LD_INT 66
16387: PPUSH
16388: CALL_OW 321
16392: PUSH
16393: LD_INT 2
16395: EQUAL
16396: IFFALSE 16413
// bpoints := bpoints * 1.1 ;
16398: LD_ADDR_VAR 0 10
16402: PUSH
16403: LD_VAR 0 10
16407: PUSH
16408: LD_REAL  1.10000000000000E+0000
16411: MUL
16412: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16413: LD_ADDR_VAR 0 10
16417: PUSH
16418: LD_VAR 0 10
16422: PUSH
16423: LD_VAR 0 6
16427: PPUSH
16428: LD_INT 1
16430: PPUSH
16431: CALL_OW 259
16435: PUSH
16436: LD_REAL  1.15000000000000E+0000
16439: MUL
16440: MUL
16441: ST_TO_ADDR
// end ; unit_vehicle :
16442: GO 17270
16444: LD_INT 2
16446: DOUBLE
16447: EQUAL
16448: IFTRUE 16452
16450: GO 17258
16452: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16453: LD_VAR 0 6
16457: PPUSH
16458: CALL_OW 264
16462: PUSH
16463: LD_INT 2
16465: PUSH
16466: LD_INT 42
16468: PUSH
16469: LD_INT 24
16471: PUSH
16472: EMPTY
16473: LIST
16474: LIST
16475: LIST
16476: IN
16477: IFFALSE 16498
// points := [ 25 , 5 , 3 ] ;
16479: LD_ADDR_VAR 0 9
16483: PUSH
16484: LD_INT 25
16486: PUSH
16487: LD_INT 5
16489: PUSH
16490: LD_INT 3
16492: PUSH
16493: EMPTY
16494: LIST
16495: LIST
16496: LIST
16497: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16498: LD_VAR 0 6
16502: PPUSH
16503: CALL_OW 264
16507: PUSH
16508: LD_INT 4
16510: PUSH
16511: LD_INT 43
16513: PUSH
16514: LD_INT 25
16516: PUSH
16517: EMPTY
16518: LIST
16519: LIST
16520: LIST
16521: IN
16522: IFFALSE 16543
// points := [ 40 , 15 , 5 ] ;
16524: LD_ADDR_VAR 0 9
16528: PUSH
16529: LD_INT 40
16531: PUSH
16532: LD_INT 15
16534: PUSH
16535: LD_INT 5
16537: PUSH
16538: EMPTY
16539: LIST
16540: LIST
16541: LIST
16542: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16543: LD_VAR 0 6
16547: PPUSH
16548: CALL_OW 264
16552: PUSH
16553: LD_INT 3
16555: PUSH
16556: LD_INT 23
16558: PUSH
16559: EMPTY
16560: LIST
16561: LIST
16562: IN
16563: IFFALSE 16584
// points := [ 7 , 25 , 8 ] ;
16565: LD_ADDR_VAR 0 9
16569: PUSH
16570: LD_INT 7
16572: PUSH
16573: LD_INT 25
16575: PUSH
16576: LD_INT 8
16578: PUSH
16579: EMPTY
16580: LIST
16581: LIST
16582: LIST
16583: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16584: LD_VAR 0 6
16588: PPUSH
16589: CALL_OW 264
16593: PUSH
16594: LD_INT 5
16596: PUSH
16597: LD_INT 27
16599: PUSH
16600: LD_INT 44
16602: PUSH
16603: EMPTY
16604: LIST
16605: LIST
16606: LIST
16607: IN
16608: IFFALSE 16629
// points := [ 14 , 50 , 16 ] ;
16610: LD_ADDR_VAR 0 9
16614: PUSH
16615: LD_INT 14
16617: PUSH
16618: LD_INT 50
16620: PUSH
16621: LD_INT 16
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16629: LD_VAR 0 6
16633: PPUSH
16634: CALL_OW 264
16638: PUSH
16639: LD_INT 6
16641: PUSH
16642: LD_INT 46
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: IN
16649: IFFALSE 16670
// points := [ 32 , 120 , 70 ] ;
16651: LD_ADDR_VAR 0 9
16655: PUSH
16656: LD_INT 32
16658: PUSH
16659: LD_INT 120
16661: PUSH
16662: LD_INT 70
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: LIST
16669: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16670: LD_VAR 0 6
16674: PPUSH
16675: CALL_OW 264
16679: PUSH
16680: LD_INT 7
16682: PUSH
16683: LD_INT 28
16685: PUSH
16686: LD_INT 45
16688: PUSH
16689: LD_INT 92
16691: PUSH
16692: EMPTY
16693: LIST
16694: LIST
16695: LIST
16696: LIST
16697: IN
16698: IFFALSE 16719
// points := [ 35 , 20 , 45 ] ;
16700: LD_ADDR_VAR 0 9
16704: PUSH
16705: LD_INT 35
16707: PUSH
16708: LD_INT 20
16710: PUSH
16711: LD_INT 45
16713: PUSH
16714: EMPTY
16715: LIST
16716: LIST
16717: LIST
16718: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16719: LD_VAR 0 6
16723: PPUSH
16724: CALL_OW 264
16728: PUSH
16729: LD_INT 47
16731: PUSH
16732: EMPTY
16733: LIST
16734: IN
16735: IFFALSE 16756
// points := [ 67 , 45 , 75 ] ;
16737: LD_ADDR_VAR 0 9
16741: PUSH
16742: LD_INT 67
16744: PUSH
16745: LD_INT 45
16747: PUSH
16748: LD_INT 75
16750: PUSH
16751: EMPTY
16752: LIST
16753: LIST
16754: LIST
16755: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16756: LD_VAR 0 6
16760: PPUSH
16761: CALL_OW 264
16765: PUSH
16766: LD_INT 26
16768: PUSH
16769: EMPTY
16770: LIST
16771: IN
16772: IFFALSE 16793
// points := [ 120 , 30 , 80 ] ;
16774: LD_ADDR_VAR 0 9
16778: PUSH
16779: LD_INT 120
16781: PUSH
16782: LD_INT 30
16784: PUSH
16785: LD_INT 80
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: LIST
16792: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16793: LD_VAR 0 6
16797: PPUSH
16798: CALL_OW 264
16802: PUSH
16803: LD_INT 22
16805: PUSH
16806: EMPTY
16807: LIST
16808: IN
16809: IFFALSE 16830
// points := [ 40 , 1 , 1 ] ;
16811: LD_ADDR_VAR 0 9
16815: PUSH
16816: LD_INT 40
16818: PUSH
16819: LD_INT 1
16821: PUSH
16822: LD_INT 1
16824: PUSH
16825: EMPTY
16826: LIST
16827: LIST
16828: LIST
16829: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16830: LD_VAR 0 6
16834: PPUSH
16835: CALL_OW 264
16839: PUSH
16840: LD_INT 29
16842: PUSH
16843: EMPTY
16844: LIST
16845: IN
16846: IFFALSE 16867
// points := [ 70 , 200 , 400 ] ;
16848: LD_ADDR_VAR 0 9
16852: PUSH
16853: LD_INT 70
16855: PUSH
16856: LD_INT 200
16858: PUSH
16859: LD_INT 400
16861: PUSH
16862: EMPTY
16863: LIST
16864: LIST
16865: LIST
16866: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16867: LD_VAR 0 6
16871: PPUSH
16872: CALL_OW 264
16876: PUSH
16877: LD_INT 14
16879: PUSH
16880: LD_INT 53
16882: PUSH
16883: EMPTY
16884: LIST
16885: LIST
16886: IN
16887: IFFALSE 16908
// points := [ 40 , 10 , 20 ] ;
16889: LD_ADDR_VAR 0 9
16893: PUSH
16894: LD_INT 40
16896: PUSH
16897: LD_INT 10
16899: PUSH
16900: LD_INT 20
16902: PUSH
16903: EMPTY
16904: LIST
16905: LIST
16906: LIST
16907: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16908: LD_VAR 0 6
16912: PPUSH
16913: CALL_OW 264
16917: PUSH
16918: LD_INT 9
16920: PUSH
16921: EMPTY
16922: LIST
16923: IN
16924: IFFALSE 16945
// points := [ 5 , 70 , 20 ] ;
16926: LD_ADDR_VAR 0 9
16930: PUSH
16931: LD_INT 5
16933: PUSH
16934: LD_INT 70
16936: PUSH
16937: LD_INT 20
16939: PUSH
16940: EMPTY
16941: LIST
16942: LIST
16943: LIST
16944: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16945: LD_VAR 0 6
16949: PPUSH
16950: CALL_OW 264
16954: PUSH
16955: LD_INT 10
16957: PUSH
16958: EMPTY
16959: LIST
16960: IN
16961: IFFALSE 16982
// points := [ 35 , 110 , 70 ] ;
16963: LD_ADDR_VAR 0 9
16967: PUSH
16968: LD_INT 35
16970: PUSH
16971: LD_INT 110
16973: PUSH
16974: LD_INT 70
16976: PUSH
16977: EMPTY
16978: LIST
16979: LIST
16980: LIST
16981: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
16982: LD_VAR 0 6
16986: PPUSH
16987: CALL_OW 265
16991: PUSH
16992: LD_INT 25
16994: EQUAL
16995: IFFALSE 17016
// points := [ 80 , 65 , 100 ] ;
16997: LD_ADDR_VAR 0 9
17001: PUSH
17002: LD_INT 80
17004: PUSH
17005: LD_INT 65
17007: PUSH
17008: LD_INT 100
17010: PUSH
17011: EMPTY
17012: LIST
17013: LIST
17014: LIST
17015: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17016: LD_VAR 0 6
17020: PPUSH
17021: CALL_OW 263
17025: PUSH
17026: LD_INT 1
17028: EQUAL
17029: IFFALSE 17064
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17031: LD_ADDR_VAR 0 10
17035: PUSH
17036: LD_VAR 0 10
17040: PUSH
17041: LD_VAR 0 6
17045: PPUSH
17046: CALL_OW 311
17050: PPUSH
17051: LD_INT 3
17053: PPUSH
17054: CALL_OW 259
17058: PUSH
17059: LD_INT 4
17061: MUL
17062: MUL
17063: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17064: LD_VAR 0 6
17068: PPUSH
17069: CALL_OW 263
17073: PUSH
17074: LD_INT 2
17076: EQUAL
17077: IFFALSE 17128
// begin j := IsControledBy ( i ) ;
17079: LD_ADDR_VAR 0 7
17083: PUSH
17084: LD_VAR 0 6
17088: PPUSH
17089: CALL_OW 312
17093: ST_TO_ADDR
// if j then
17094: LD_VAR 0 7
17098: IFFALSE 17128
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17100: LD_ADDR_VAR 0 10
17104: PUSH
17105: LD_VAR 0 10
17109: PUSH
17110: LD_VAR 0 7
17114: PPUSH
17115: LD_INT 3
17117: PPUSH
17118: CALL_OW 259
17122: PUSH
17123: LD_INT 3
17125: MUL
17126: MUL
17127: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17128: LD_VAR 0 6
17132: PPUSH
17133: CALL_OW 264
17137: PUSH
17138: LD_INT 5
17140: PUSH
17141: LD_INT 6
17143: PUSH
17144: LD_INT 46
17146: PUSH
17147: LD_INT 44
17149: PUSH
17150: LD_INT 47
17152: PUSH
17153: LD_INT 45
17155: PUSH
17156: LD_INT 28
17158: PUSH
17159: LD_INT 7
17161: PUSH
17162: LD_INT 27
17164: PUSH
17165: LD_INT 29
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: LIST
17172: LIST
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: LIST
17178: LIST
17179: IN
17180: PUSH
17181: LD_VAR 0 1
17185: PPUSH
17186: LD_INT 52
17188: PPUSH
17189: CALL_OW 321
17193: PUSH
17194: LD_INT 2
17196: EQUAL
17197: AND
17198: IFFALSE 17215
// bpoints := bpoints * 1.2 ;
17200: LD_ADDR_VAR 0 10
17204: PUSH
17205: LD_VAR 0 10
17209: PUSH
17210: LD_REAL  1.20000000000000E+0000
17213: MUL
17214: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17215: LD_VAR 0 6
17219: PPUSH
17220: CALL_OW 264
17224: PUSH
17225: LD_INT 6
17227: PUSH
17228: LD_INT 46
17230: PUSH
17231: LD_INT 47
17233: PUSH
17234: EMPTY
17235: LIST
17236: LIST
17237: LIST
17238: IN
17239: IFFALSE 17256
// bpoints := bpoints * 1.2 ;
17241: LD_ADDR_VAR 0 10
17245: PUSH
17246: LD_VAR 0 10
17250: PUSH
17251: LD_REAL  1.20000000000000E+0000
17254: MUL
17255: ST_TO_ADDR
// end ; unit_building :
17256: GO 17270
17258: LD_INT 3
17260: DOUBLE
17261: EQUAL
17262: IFTRUE 17266
17264: GO 17269
17266: POP
// ; end ;
17267: GO 17270
17269: POP
// for j = 1 to 3 do
17270: LD_ADDR_VAR 0 7
17274: PUSH
17275: DOUBLE
17276: LD_INT 1
17278: DEC
17279: ST_TO_ADDR
17280: LD_INT 3
17282: PUSH
17283: FOR_TO
17284: IFFALSE 17337
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17286: LD_ADDR_VAR 0 5
17290: PUSH
17291: LD_VAR 0 5
17295: PPUSH
17296: LD_VAR 0 7
17300: PPUSH
17301: LD_VAR 0 5
17305: PUSH
17306: LD_VAR 0 7
17310: ARRAY
17311: PUSH
17312: LD_VAR 0 9
17316: PUSH
17317: LD_VAR 0 7
17321: ARRAY
17322: PUSH
17323: LD_VAR 0 10
17327: MUL
17328: PLUS
17329: PPUSH
17330: CALL_OW 1
17334: ST_TO_ADDR
17335: GO 17283
17337: POP
17338: POP
// end ;
17339: GO 15818
17341: POP
17342: POP
// result := Replace ( result , 4 , tmp ) ;
17343: LD_ADDR_VAR 0 5
17347: PUSH
17348: LD_VAR 0 5
17352: PPUSH
17353: LD_INT 4
17355: PPUSH
17356: LD_VAR 0 8
17360: PPUSH
17361: CALL_OW 1
17365: ST_TO_ADDR
// end ;
17366: LD_VAR 0 5
17370: RET
// export function DangerAtRange ( unit , range ) ; begin
17371: LD_INT 0
17373: PPUSH
// if not unit then
17374: LD_VAR 0 1
17378: NOT
17379: IFFALSE 17383
// exit ;
17381: GO 17428
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17383: LD_ADDR_VAR 0 3
17387: PUSH
17388: LD_VAR 0 1
17392: PPUSH
17393: CALL_OW 255
17397: PPUSH
17398: LD_VAR 0 1
17402: PPUSH
17403: CALL_OW 250
17407: PPUSH
17408: LD_VAR 0 1
17412: PPUSH
17413: CALL_OW 251
17417: PPUSH
17418: LD_VAR 0 2
17422: PPUSH
17423: CALL 15670 0 4
17427: ST_TO_ADDR
// end ;
17428: LD_VAR 0 3
17432: RET
// export function DangerInArea ( side , area ) ; begin
17433: LD_INT 0
17435: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17436: LD_ADDR_VAR 0 3
17440: PUSH
17441: LD_VAR 0 2
17445: PPUSH
17446: LD_INT 81
17448: PUSH
17449: LD_VAR 0 1
17453: PUSH
17454: EMPTY
17455: LIST
17456: LIST
17457: PPUSH
17458: CALL_OW 70
17462: ST_TO_ADDR
// end ;
17463: LD_VAR 0 3
17467: RET
// export function IsExtension ( b ) ; begin
17468: LD_INT 0
17470: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17471: LD_ADDR_VAR 0 2
17475: PUSH
17476: LD_VAR 0 1
17480: PUSH
17481: LD_INT 23
17483: PUSH
17484: LD_INT 20
17486: PUSH
17487: LD_INT 22
17489: PUSH
17490: LD_INT 17
17492: PUSH
17493: LD_INT 24
17495: PUSH
17496: LD_INT 21
17498: PUSH
17499: LD_INT 19
17501: PUSH
17502: LD_INT 16
17504: PUSH
17505: LD_INT 25
17507: PUSH
17508: LD_INT 18
17510: PUSH
17511: EMPTY
17512: LIST
17513: LIST
17514: LIST
17515: LIST
17516: LIST
17517: LIST
17518: LIST
17519: LIST
17520: LIST
17521: LIST
17522: IN
17523: ST_TO_ADDR
// end ;
17524: LD_VAR 0 2
17528: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17529: LD_INT 0
17531: PPUSH
17532: PPUSH
17533: PPUSH
// result := [ ] ;
17534: LD_ADDR_VAR 0 4
17538: PUSH
17539: EMPTY
17540: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17541: LD_ADDR_VAR 0 5
17545: PUSH
17546: LD_VAR 0 2
17550: PPUSH
17551: LD_INT 21
17553: PUSH
17554: LD_INT 3
17556: PUSH
17557: EMPTY
17558: LIST
17559: LIST
17560: PPUSH
17561: CALL_OW 70
17565: ST_TO_ADDR
// if not tmp then
17566: LD_VAR 0 5
17570: NOT
17571: IFFALSE 17575
// exit ;
17573: GO 17639
// if checkLink then
17575: LD_VAR 0 3
17579: IFFALSE 17629
// begin for i in tmp do
17581: LD_ADDR_VAR 0 6
17585: PUSH
17586: LD_VAR 0 5
17590: PUSH
17591: FOR_IN
17592: IFFALSE 17627
// if GetBase ( i ) <> base then
17594: LD_VAR 0 6
17598: PPUSH
17599: CALL_OW 274
17603: PUSH
17604: LD_VAR 0 1
17608: NONEQUAL
17609: IFFALSE 17625
// ComLinkToBase ( base , i ) ;
17611: LD_VAR 0 1
17615: PPUSH
17616: LD_VAR 0 6
17620: PPUSH
17621: CALL_OW 169
17625: GO 17591
17627: POP
17628: POP
// end ; result := tmp ;
17629: LD_ADDR_VAR 0 4
17633: PUSH
17634: LD_VAR 0 5
17638: ST_TO_ADDR
// end ;
17639: LD_VAR 0 4
17643: RET
// export function ComComplete ( units , b ) ; var i ; begin
17644: LD_INT 0
17646: PPUSH
17647: PPUSH
// if not units then
17648: LD_VAR 0 1
17652: NOT
17653: IFFALSE 17657
// exit ;
17655: GO 17747
// for i in units do
17657: LD_ADDR_VAR 0 4
17661: PUSH
17662: LD_VAR 0 1
17666: PUSH
17667: FOR_IN
17668: IFFALSE 17745
// if BuildingStatus ( b ) = bs_build then
17670: LD_VAR 0 2
17674: PPUSH
17675: CALL_OW 461
17679: PUSH
17680: LD_INT 1
17682: EQUAL
17683: IFFALSE 17743
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17685: LD_VAR 0 4
17689: PPUSH
17690: LD_STRING h
17692: PUSH
17693: LD_VAR 0 2
17697: PPUSH
17698: CALL_OW 250
17702: PUSH
17703: LD_VAR 0 2
17707: PPUSH
17708: CALL_OW 251
17712: PUSH
17713: LD_VAR 0 2
17717: PUSH
17718: LD_INT 0
17720: PUSH
17721: LD_INT 0
17723: PUSH
17724: LD_INT 0
17726: PUSH
17727: EMPTY
17728: LIST
17729: LIST
17730: LIST
17731: LIST
17732: LIST
17733: LIST
17734: LIST
17735: PUSH
17736: EMPTY
17737: LIST
17738: PPUSH
17739: CALL_OW 446
17743: GO 17667
17745: POP
17746: POP
// end ;
17747: LD_VAR 0 3
17751: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17752: LD_INT 0
17754: PPUSH
17755: PPUSH
17756: PPUSH
17757: PPUSH
17758: PPUSH
17759: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17760: LD_VAR 0 1
17764: NOT
17765: PUSH
17766: LD_VAR 0 1
17770: PPUSH
17771: CALL_OW 263
17775: PUSH
17776: LD_INT 2
17778: NONEQUAL
17779: OR
17780: IFFALSE 17784
// exit ;
17782: GO 18100
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17784: LD_ADDR_VAR 0 6
17788: PUSH
17789: LD_INT 22
17791: PUSH
17792: LD_VAR 0 1
17796: PPUSH
17797: CALL_OW 255
17801: PUSH
17802: EMPTY
17803: LIST
17804: LIST
17805: PUSH
17806: LD_INT 2
17808: PUSH
17809: LD_INT 30
17811: PUSH
17812: LD_INT 36
17814: PUSH
17815: EMPTY
17816: LIST
17817: LIST
17818: PUSH
17819: LD_INT 34
17821: PUSH
17822: LD_INT 31
17824: PUSH
17825: EMPTY
17826: LIST
17827: LIST
17828: PUSH
17829: EMPTY
17830: LIST
17831: LIST
17832: LIST
17833: PUSH
17834: EMPTY
17835: LIST
17836: LIST
17837: PPUSH
17838: CALL_OW 69
17842: ST_TO_ADDR
// if not tmp then
17843: LD_VAR 0 6
17847: NOT
17848: IFFALSE 17852
// exit ;
17850: GO 18100
// result := [ ] ;
17852: LD_ADDR_VAR 0 2
17856: PUSH
17857: EMPTY
17858: ST_TO_ADDR
// for i in tmp do
17859: LD_ADDR_VAR 0 3
17863: PUSH
17864: LD_VAR 0 6
17868: PUSH
17869: FOR_IN
17870: IFFALSE 17941
// begin t := UnitsInside ( i ) ;
17872: LD_ADDR_VAR 0 4
17876: PUSH
17877: LD_VAR 0 3
17881: PPUSH
17882: CALL_OW 313
17886: ST_TO_ADDR
// if t then
17887: LD_VAR 0 4
17891: IFFALSE 17939
// for j in t do
17893: LD_ADDR_VAR 0 7
17897: PUSH
17898: LD_VAR 0 4
17902: PUSH
17903: FOR_IN
17904: IFFALSE 17937
// result := Replace ( result , result + 1 , j ) ;
17906: LD_ADDR_VAR 0 2
17910: PUSH
17911: LD_VAR 0 2
17915: PPUSH
17916: LD_VAR 0 2
17920: PUSH
17921: LD_INT 1
17923: PLUS
17924: PPUSH
17925: LD_VAR 0 7
17929: PPUSH
17930: CALL_OW 1
17934: ST_TO_ADDR
17935: GO 17903
17937: POP
17938: POP
// end ;
17939: GO 17869
17941: POP
17942: POP
// if not result then
17943: LD_VAR 0 2
17947: NOT
17948: IFFALSE 17952
// exit ;
17950: GO 18100
// mech := result [ 1 ] ;
17952: LD_ADDR_VAR 0 5
17956: PUSH
17957: LD_VAR 0 2
17961: PUSH
17962: LD_INT 1
17964: ARRAY
17965: ST_TO_ADDR
// if result > 1 then
17966: LD_VAR 0 2
17970: PUSH
17971: LD_INT 1
17973: GREATER
17974: IFFALSE 18086
// begin for i = 2 to result do
17976: LD_ADDR_VAR 0 3
17980: PUSH
17981: DOUBLE
17982: LD_INT 2
17984: DEC
17985: ST_TO_ADDR
17986: LD_VAR 0 2
17990: PUSH
17991: FOR_TO
17992: IFFALSE 18084
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
17994: LD_ADDR_VAR 0 4
17998: PUSH
17999: LD_VAR 0 2
18003: PUSH
18004: LD_VAR 0 3
18008: ARRAY
18009: PPUSH
18010: LD_INT 3
18012: PPUSH
18013: CALL_OW 259
18017: PUSH
18018: LD_VAR 0 2
18022: PUSH
18023: LD_VAR 0 3
18027: ARRAY
18028: PPUSH
18029: CALL_OW 432
18033: MINUS
18034: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18035: LD_VAR 0 4
18039: PUSH
18040: LD_VAR 0 5
18044: PPUSH
18045: LD_INT 3
18047: PPUSH
18048: CALL_OW 259
18052: PUSH
18053: LD_VAR 0 5
18057: PPUSH
18058: CALL_OW 432
18062: MINUS
18063: GREATEREQUAL
18064: IFFALSE 18082
// mech := result [ i ] ;
18066: LD_ADDR_VAR 0 5
18070: PUSH
18071: LD_VAR 0 2
18075: PUSH
18076: LD_VAR 0 3
18080: ARRAY
18081: ST_TO_ADDR
// end ;
18082: GO 17991
18084: POP
18085: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18086: LD_VAR 0 1
18090: PPUSH
18091: LD_VAR 0 5
18095: PPUSH
18096: CALL_OW 135
// end ;
18100: LD_VAR 0 2
18104: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18105: LD_INT 0
18107: PPUSH
18108: PPUSH
18109: PPUSH
18110: PPUSH
18111: PPUSH
18112: PPUSH
18113: PPUSH
18114: PPUSH
18115: PPUSH
18116: PPUSH
18117: PPUSH
18118: PPUSH
18119: PPUSH
// result := [ ] ;
18120: LD_ADDR_VAR 0 7
18124: PUSH
18125: EMPTY
18126: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18127: LD_VAR 0 1
18131: PPUSH
18132: CALL_OW 266
18136: PUSH
18137: LD_INT 0
18139: PUSH
18140: LD_INT 1
18142: PUSH
18143: EMPTY
18144: LIST
18145: LIST
18146: IN
18147: NOT
18148: IFFALSE 18152
// exit ;
18150: GO 19786
// if name then
18152: LD_VAR 0 3
18156: IFFALSE 18172
// SetBName ( base_dep , name ) ;
18158: LD_VAR 0 1
18162: PPUSH
18163: LD_VAR 0 3
18167: PPUSH
18168: CALL_OW 500
// base := GetBase ( base_dep ) ;
18172: LD_ADDR_VAR 0 15
18176: PUSH
18177: LD_VAR 0 1
18181: PPUSH
18182: CALL_OW 274
18186: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18187: LD_ADDR_VAR 0 16
18191: PUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: CALL_OW 255
18201: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18202: LD_ADDR_VAR 0 17
18206: PUSH
18207: LD_VAR 0 1
18211: PPUSH
18212: CALL_OW 248
18216: ST_TO_ADDR
// if sources then
18217: LD_VAR 0 5
18221: IFFALSE 18268
// for i = 1 to 3 do
18223: LD_ADDR_VAR 0 8
18227: PUSH
18228: DOUBLE
18229: LD_INT 1
18231: DEC
18232: ST_TO_ADDR
18233: LD_INT 3
18235: PUSH
18236: FOR_TO
18237: IFFALSE 18266
// AddResourceType ( base , i , sources [ i ] ) ;
18239: LD_VAR 0 15
18243: PPUSH
18244: LD_VAR 0 8
18248: PPUSH
18249: LD_VAR 0 5
18253: PUSH
18254: LD_VAR 0 8
18258: ARRAY
18259: PPUSH
18260: CALL_OW 276
18264: GO 18236
18266: POP
18267: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18268: LD_ADDR_VAR 0 18
18272: PUSH
18273: LD_VAR 0 15
18277: PPUSH
18278: LD_VAR 0 2
18282: PPUSH
18283: LD_INT 1
18285: PPUSH
18286: CALL 17529 0 3
18290: ST_TO_ADDR
// InitHc ;
18291: CALL_OW 19
// InitUc ;
18295: CALL_OW 18
// uc_side := side ;
18299: LD_ADDR_OWVAR 20
18303: PUSH
18304: LD_VAR 0 16
18308: ST_TO_ADDR
// uc_nation := nation ;
18309: LD_ADDR_OWVAR 21
18313: PUSH
18314: LD_VAR 0 17
18318: ST_TO_ADDR
// if buildings then
18319: LD_VAR 0 18
18323: IFFALSE 19645
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18325: LD_ADDR_VAR 0 19
18329: PUSH
18330: LD_VAR 0 18
18334: PPUSH
18335: LD_INT 2
18337: PUSH
18338: LD_INT 30
18340: PUSH
18341: LD_INT 29
18343: PUSH
18344: EMPTY
18345: LIST
18346: LIST
18347: PUSH
18348: LD_INT 30
18350: PUSH
18351: LD_INT 30
18353: PUSH
18354: EMPTY
18355: LIST
18356: LIST
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: LIST
18362: PPUSH
18363: CALL_OW 72
18367: ST_TO_ADDR
// if tmp then
18368: LD_VAR 0 19
18372: IFFALSE 18420
// for i in tmp do
18374: LD_ADDR_VAR 0 8
18378: PUSH
18379: LD_VAR 0 19
18383: PUSH
18384: FOR_IN
18385: IFFALSE 18418
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18387: LD_VAR 0 8
18391: PPUSH
18392: CALL_OW 250
18396: PPUSH
18397: LD_VAR 0 8
18401: PPUSH
18402: CALL_OW 251
18406: PPUSH
18407: LD_VAR 0 16
18411: PPUSH
18412: CALL_OW 441
18416: GO 18384
18418: POP
18419: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18420: LD_VAR 0 18
18424: PPUSH
18425: LD_INT 2
18427: PUSH
18428: LD_INT 30
18430: PUSH
18431: LD_INT 32
18433: PUSH
18434: EMPTY
18435: LIST
18436: LIST
18437: PUSH
18438: LD_INT 30
18440: PUSH
18441: LD_INT 33
18443: PUSH
18444: EMPTY
18445: LIST
18446: LIST
18447: PUSH
18448: EMPTY
18449: LIST
18450: LIST
18451: LIST
18452: PPUSH
18453: CALL_OW 72
18457: IFFALSE 18545
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18459: LD_ADDR_VAR 0 8
18463: PUSH
18464: LD_VAR 0 18
18468: PPUSH
18469: LD_INT 2
18471: PUSH
18472: LD_INT 30
18474: PUSH
18475: LD_INT 32
18477: PUSH
18478: EMPTY
18479: LIST
18480: LIST
18481: PUSH
18482: LD_INT 30
18484: PUSH
18485: LD_INT 33
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: PUSH
18492: EMPTY
18493: LIST
18494: LIST
18495: LIST
18496: PPUSH
18497: CALL_OW 72
18501: PUSH
18502: FOR_IN
18503: IFFALSE 18543
// begin if not GetBWeapon ( i ) then
18505: LD_VAR 0 8
18509: PPUSH
18510: CALL_OW 269
18514: NOT
18515: IFFALSE 18541
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18517: LD_VAR 0 8
18521: PPUSH
18522: LD_VAR 0 8
18526: PPUSH
18527: LD_VAR 0 2
18531: PPUSH
18532: CALL 19791 0 2
18536: PPUSH
18537: CALL_OW 431
// end ;
18541: GO 18502
18543: POP
18544: POP
// end ; for i = 1 to personel do
18545: LD_ADDR_VAR 0 8
18549: PUSH
18550: DOUBLE
18551: LD_INT 1
18553: DEC
18554: ST_TO_ADDR
18555: LD_VAR 0 6
18559: PUSH
18560: FOR_TO
18561: IFFALSE 19625
// begin if i > 4 then
18563: LD_VAR 0 8
18567: PUSH
18568: LD_INT 4
18570: GREATER
18571: IFFALSE 18575
// break ;
18573: GO 19625
// case i of 1 :
18575: LD_VAR 0 8
18579: PUSH
18580: LD_INT 1
18582: DOUBLE
18583: EQUAL
18584: IFTRUE 18588
18586: GO 18668
18588: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18589: LD_ADDR_VAR 0 12
18593: PUSH
18594: LD_VAR 0 18
18598: PPUSH
18599: LD_INT 22
18601: PUSH
18602: LD_VAR 0 16
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PUSH
18611: LD_INT 58
18613: PUSH
18614: EMPTY
18615: LIST
18616: PUSH
18617: LD_INT 2
18619: PUSH
18620: LD_INT 30
18622: PUSH
18623: LD_INT 32
18625: PUSH
18626: EMPTY
18627: LIST
18628: LIST
18629: PUSH
18630: LD_INT 30
18632: PUSH
18633: LD_INT 4
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: PUSH
18640: LD_INT 30
18642: PUSH
18643: LD_INT 5
18645: PUSH
18646: EMPTY
18647: LIST
18648: LIST
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: LIST
18654: LIST
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: LIST
18660: PPUSH
18661: CALL_OW 72
18665: ST_TO_ADDR
18666: GO 18890
18668: LD_INT 2
18670: DOUBLE
18671: EQUAL
18672: IFTRUE 18676
18674: GO 18738
18676: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18677: LD_ADDR_VAR 0 12
18681: PUSH
18682: LD_VAR 0 18
18686: PPUSH
18687: LD_INT 22
18689: PUSH
18690: LD_VAR 0 16
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PUSH
18699: LD_INT 2
18701: PUSH
18702: LD_INT 30
18704: PUSH
18705: LD_INT 0
18707: PUSH
18708: EMPTY
18709: LIST
18710: LIST
18711: PUSH
18712: LD_INT 30
18714: PUSH
18715: LD_INT 1
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PUSH
18722: EMPTY
18723: LIST
18724: LIST
18725: LIST
18726: PUSH
18727: EMPTY
18728: LIST
18729: LIST
18730: PPUSH
18731: CALL_OW 72
18735: ST_TO_ADDR
18736: GO 18890
18738: LD_INT 3
18740: DOUBLE
18741: EQUAL
18742: IFTRUE 18746
18744: GO 18808
18746: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18747: LD_ADDR_VAR 0 12
18751: PUSH
18752: LD_VAR 0 18
18756: PPUSH
18757: LD_INT 22
18759: PUSH
18760: LD_VAR 0 16
18764: PUSH
18765: EMPTY
18766: LIST
18767: LIST
18768: PUSH
18769: LD_INT 2
18771: PUSH
18772: LD_INT 30
18774: PUSH
18775: LD_INT 2
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: PUSH
18782: LD_INT 30
18784: PUSH
18785: LD_INT 3
18787: PUSH
18788: EMPTY
18789: LIST
18790: LIST
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: LIST
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: PPUSH
18801: CALL_OW 72
18805: ST_TO_ADDR
18806: GO 18890
18808: LD_INT 4
18810: DOUBLE
18811: EQUAL
18812: IFTRUE 18816
18814: GO 18889
18816: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18817: LD_ADDR_VAR 0 12
18821: PUSH
18822: LD_VAR 0 18
18826: PPUSH
18827: LD_INT 22
18829: PUSH
18830: LD_VAR 0 16
18834: PUSH
18835: EMPTY
18836: LIST
18837: LIST
18838: PUSH
18839: LD_INT 2
18841: PUSH
18842: LD_INT 30
18844: PUSH
18845: LD_INT 6
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: PUSH
18852: LD_INT 30
18854: PUSH
18855: LD_INT 7
18857: PUSH
18858: EMPTY
18859: LIST
18860: LIST
18861: PUSH
18862: LD_INT 30
18864: PUSH
18865: LD_INT 8
18867: PUSH
18868: EMPTY
18869: LIST
18870: LIST
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: LIST
18876: LIST
18877: PUSH
18878: EMPTY
18879: LIST
18880: LIST
18881: PPUSH
18882: CALL_OW 72
18886: ST_TO_ADDR
18887: GO 18890
18889: POP
// if i = 1 then
18890: LD_VAR 0 8
18894: PUSH
18895: LD_INT 1
18897: EQUAL
18898: IFFALSE 19009
// begin tmp := [ ] ;
18900: LD_ADDR_VAR 0 19
18904: PUSH
18905: EMPTY
18906: ST_TO_ADDR
// for j in f do
18907: LD_ADDR_VAR 0 9
18911: PUSH
18912: LD_VAR 0 12
18916: PUSH
18917: FOR_IN
18918: IFFALSE 18991
// if GetBType ( j ) = b_bunker then
18920: LD_VAR 0 9
18924: PPUSH
18925: CALL_OW 266
18929: PUSH
18930: LD_INT 32
18932: EQUAL
18933: IFFALSE 18960
// tmp := Insert ( tmp , 1 , j ) else
18935: LD_ADDR_VAR 0 19
18939: PUSH
18940: LD_VAR 0 19
18944: PPUSH
18945: LD_INT 1
18947: PPUSH
18948: LD_VAR 0 9
18952: PPUSH
18953: CALL_OW 2
18957: ST_TO_ADDR
18958: GO 18989
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18960: LD_ADDR_VAR 0 19
18964: PUSH
18965: LD_VAR 0 19
18969: PPUSH
18970: LD_VAR 0 19
18974: PUSH
18975: LD_INT 1
18977: PLUS
18978: PPUSH
18979: LD_VAR 0 9
18983: PPUSH
18984: CALL_OW 2
18988: ST_TO_ADDR
18989: GO 18917
18991: POP
18992: POP
// if tmp then
18993: LD_VAR 0 19
18997: IFFALSE 19009
// f := tmp ;
18999: LD_ADDR_VAR 0 12
19003: PUSH
19004: LD_VAR 0 19
19008: ST_TO_ADDR
// end ; x := personel [ i ] ;
19009: LD_ADDR_VAR 0 13
19013: PUSH
19014: LD_VAR 0 6
19018: PUSH
19019: LD_VAR 0 8
19023: ARRAY
19024: ST_TO_ADDR
// if x = - 1 then
19025: LD_VAR 0 13
19029: PUSH
19030: LD_INT 1
19032: NEG
19033: EQUAL
19034: IFFALSE 19243
// begin for j in f do
19036: LD_ADDR_VAR 0 9
19040: PUSH
19041: LD_VAR 0 12
19045: PUSH
19046: FOR_IN
19047: IFFALSE 19239
// repeat InitHc ;
19049: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19053: LD_VAR 0 9
19057: PPUSH
19058: CALL_OW 266
19062: PUSH
19063: LD_INT 5
19065: EQUAL
19066: IFFALSE 19136
// begin if UnitsInside ( j ) < 3 then
19068: LD_VAR 0 9
19072: PPUSH
19073: CALL_OW 313
19077: PUSH
19078: LD_INT 3
19080: LESS
19081: IFFALSE 19117
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19083: LD_INT 0
19085: PPUSH
19086: LD_INT 5
19088: PUSH
19089: LD_INT 8
19091: PUSH
19092: LD_INT 9
19094: PUSH
19095: EMPTY
19096: LIST
19097: LIST
19098: LIST
19099: PUSH
19100: LD_VAR 0 17
19104: ARRAY
19105: PPUSH
19106: LD_VAR 0 4
19110: PPUSH
19111: CALL_OW 380
19115: GO 19134
// PrepareHuman ( false , i , skill ) ;
19117: LD_INT 0
19119: PPUSH
19120: LD_VAR 0 8
19124: PPUSH
19125: LD_VAR 0 4
19129: PPUSH
19130: CALL_OW 380
// end else
19134: GO 19153
// PrepareHuman ( false , i , skill ) ;
19136: LD_INT 0
19138: PPUSH
19139: LD_VAR 0 8
19143: PPUSH
19144: LD_VAR 0 4
19148: PPUSH
19149: CALL_OW 380
// un := CreateHuman ;
19153: LD_ADDR_VAR 0 14
19157: PUSH
19158: CALL_OW 44
19162: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19163: LD_ADDR_VAR 0 7
19167: PUSH
19168: LD_VAR 0 7
19172: PPUSH
19173: LD_INT 1
19175: PPUSH
19176: LD_VAR 0 14
19180: PPUSH
19181: CALL_OW 2
19185: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19186: LD_VAR 0 14
19190: PPUSH
19191: LD_VAR 0 9
19195: PPUSH
19196: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19200: LD_VAR 0 9
19204: PPUSH
19205: CALL_OW 313
19209: PUSH
19210: LD_INT 6
19212: EQUAL
19213: PUSH
19214: LD_VAR 0 9
19218: PPUSH
19219: CALL_OW 266
19223: PUSH
19224: LD_INT 32
19226: PUSH
19227: LD_INT 31
19229: PUSH
19230: EMPTY
19231: LIST
19232: LIST
19233: IN
19234: OR
19235: IFFALSE 19049
19237: GO 19046
19239: POP
19240: POP
// end else
19241: GO 19623
// for j = 1 to x do
19243: LD_ADDR_VAR 0 9
19247: PUSH
19248: DOUBLE
19249: LD_INT 1
19251: DEC
19252: ST_TO_ADDR
19253: LD_VAR 0 13
19257: PUSH
19258: FOR_TO
19259: IFFALSE 19621
// begin InitHc ;
19261: CALL_OW 19
// if not f then
19265: LD_VAR 0 12
19269: NOT
19270: IFFALSE 19359
// begin PrepareHuman ( false , i , skill ) ;
19272: LD_INT 0
19274: PPUSH
19275: LD_VAR 0 8
19279: PPUSH
19280: LD_VAR 0 4
19284: PPUSH
19285: CALL_OW 380
// un := CreateHuman ;
19289: LD_ADDR_VAR 0 14
19293: PUSH
19294: CALL_OW 44
19298: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19299: LD_ADDR_VAR 0 7
19303: PUSH
19304: LD_VAR 0 7
19308: PPUSH
19309: LD_INT 1
19311: PPUSH
19312: LD_VAR 0 14
19316: PPUSH
19317: CALL_OW 2
19321: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19322: LD_VAR 0 14
19326: PPUSH
19327: LD_VAR 0 1
19331: PPUSH
19332: CALL_OW 250
19336: PPUSH
19337: LD_VAR 0 1
19341: PPUSH
19342: CALL_OW 251
19346: PPUSH
19347: LD_INT 10
19349: PPUSH
19350: LD_INT 0
19352: PPUSH
19353: CALL_OW 50
// continue ;
19357: GO 19258
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19359: LD_VAR 0 12
19363: PUSH
19364: LD_INT 1
19366: ARRAY
19367: PPUSH
19368: CALL_OW 313
19372: PUSH
19373: LD_VAR 0 12
19377: PUSH
19378: LD_INT 1
19380: ARRAY
19381: PPUSH
19382: CALL_OW 266
19386: PUSH
19387: LD_INT 32
19389: PUSH
19390: LD_INT 31
19392: PUSH
19393: EMPTY
19394: LIST
19395: LIST
19396: IN
19397: AND
19398: PUSH
19399: LD_VAR 0 12
19403: PUSH
19404: LD_INT 1
19406: ARRAY
19407: PPUSH
19408: CALL_OW 313
19412: PUSH
19413: LD_INT 6
19415: EQUAL
19416: OR
19417: IFFALSE 19437
// f := Delete ( f , 1 ) ;
19419: LD_ADDR_VAR 0 12
19423: PUSH
19424: LD_VAR 0 12
19428: PPUSH
19429: LD_INT 1
19431: PPUSH
19432: CALL_OW 3
19436: ST_TO_ADDR
// if not f then
19437: LD_VAR 0 12
19441: NOT
19442: IFFALSE 19460
// begin x := x + 2 ;
19444: LD_ADDR_VAR 0 13
19448: PUSH
19449: LD_VAR 0 13
19453: PUSH
19454: LD_INT 2
19456: PLUS
19457: ST_TO_ADDR
// continue ;
19458: GO 19258
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19460: LD_VAR 0 12
19464: PUSH
19465: LD_INT 1
19467: ARRAY
19468: PPUSH
19469: CALL_OW 266
19473: PUSH
19474: LD_INT 5
19476: EQUAL
19477: IFFALSE 19551
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19479: LD_VAR 0 12
19483: PUSH
19484: LD_INT 1
19486: ARRAY
19487: PPUSH
19488: CALL_OW 313
19492: PUSH
19493: LD_INT 3
19495: LESS
19496: IFFALSE 19532
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19498: LD_INT 0
19500: PPUSH
19501: LD_INT 5
19503: PUSH
19504: LD_INT 8
19506: PUSH
19507: LD_INT 9
19509: PUSH
19510: EMPTY
19511: LIST
19512: LIST
19513: LIST
19514: PUSH
19515: LD_VAR 0 17
19519: ARRAY
19520: PPUSH
19521: LD_VAR 0 4
19525: PPUSH
19526: CALL_OW 380
19530: GO 19549
// PrepareHuman ( false , i , skill ) ;
19532: LD_INT 0
19534: PPUSH
19535: LD_VAR 0 8
19539: PPUSH
19540: LD_VAR 0 4
19544: PPUSH
19545: CALL_OW 380
// end else
19549: GO 19568
// PrepareHuman ( false , i , skill ) ;
19551: LD_INT 0
19553: PPUSH
19554: LD_VAR 0 8
19558: PPUSH
19559: LD_VAR 0 4
19563: PPUSH
19564: CALL_OW 380
// un := CreateHuman ;
19568: LD_ADDR_VAR 0 14
19572: PUSH
19573: CALL_OW 44
19577: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19578: LD_ADDR_VAR 0 7
19582: PUSH
19583: LD_VAR 0 7
19587: PPUSH
19588: LD_INT 1
19590: PPUSH
19591: LD_VAR 0 14
19595: PPUSH
19596: CALL_OW 2
19600: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19601: LD_VAR 0 14
19605: PPUSH
19606: LD_VAR 0 12
19610: PUSH
19611: LD_INT 1
19613: ARRAY
19614: PPUSH
19615: CALL_OW 52
// end ;
19619: GO 19258
19621: POP
19622: POP
// end ;
19623: GO 18560
19625: POP
19626: POP
// result := result ^ buildings ;
19627: LD_ADDR_VAR 0 7
19631: PUSH
19632: LD_VAR 0 7
19636: PUSH
19637: LD_VAR 0 18
19641: ADD
19642: ST_TO_ADDR
// end else
19643: GO 19786
// begin for i = 1 to personel do
19645: LD_ADDR_VAR 0 8
19649: PUSH
19650: DOUBLE
19651: LD_INT 1
19653: DEC
19654: ST_TO_ADDR
19655: LD_VAR 0 6
19659: PUSH
19660: FOR_TO
19661: IFFALSE 19784
// begin if i > 4 then
19663: LD_VAR 0 8
19667: PUSH
19668: LD_INT 4
19670: GREATER
19671: IFFALSE 19675
// break ;
19673: GO 19784
// x := personel [ i ] ;
19675: LD_ADDR_VAR 0 13
19679: PUSH
19680: LD_VAR 0 6
19684: PUSH
19685: LD_VAR 0 8
19689: ARRAY
19690: ST_TO_ADDR
// if x = - 1 then
19691: LD_VAR 0 13
19695: PUSH
19696: LD_INT 1
19698: NEG
19699: EQUAL
19700: IFFALSE 19704
// continue ;
19702: GO 19660
// PrepareHuman ( false , i , skill ) ;
19704: LD_INT 0
19706: PPUSH
19707: LD_VAR 0 8
19711: PPUSH
19712: LD_VAR 0 4
19716: PPUSH
19717: CALL_OW 380
// un := CreateHuman ;
19721: LD_ADDR_VAR 0 14
19725: PUSH
19726: CALL_OW 44
19730: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19731: LD_VAR 0 14
19735: PPUSH
19736: LD_VAR 0 1
19740: PPUSH
19741: CALL_OW 250
19745: PPUSH
19746: LD_VAR 0 1
19750: PPUSH
19751: CALL_OW 251
19755: PPUSH
19756: LD_INT 10
19758: PPUSH
19759: LD_INT 0
19761: PPUSH
19762: CALL_OW 50
// result := result ^ un ;
19766: LD_ADDR_VAR 0 7
19770: PUSH
19771: LD_VAR 0 7
19775: PUSH
19776: LD_VAR 0 14
19780: ADD
19781: ST_TO_ADDR
// end ;
19782: GO 19660
19784: POP
19785: POP
// end ; end ;
19786: LD_VAR 0 7
19790: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19791: LD_INT 0
19793: PPUSH
19794: PPUSH
19795: PPUSH
19796: PPUSH
19797: PPUSH
19798: PPUSH
19799: PPUSH
19800: PPUSH
19801: PPUSH
19802: PPUSH
19803: PPUSH
19804: PPUSH
19805: PPUSH
19806: PPUSH
19807: PPUSH
19808: PPUSH
// result := false ;
19809: LD_ADDR_VAR 0 3
19813: PUSH
19814: LD_INT 0
19816: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19817: LD_VAR 0 1
19821: NOT
19822: PUSH
19823: LD_VAR 0 1
19827: PPUSH
19828: CALL_OW 266
19832: PUSH
19833: LD_INT 32
19835: PUSH
19836: LD_INT 33
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: IN
19843: NOT
19844: OR
19845: IFFALSE 19849
// exit ;
19847: GO 20958
// nat := GetNation ( tower ) ;
19849: LD_ADDR_VAR 0 12
19853: PUSH
19854: LD_VAR 0 1
19858: PPUSH
19859: CALL_OW 248
19863: ST_TO_ADDR
// side := GetSide ( tower ) ;
19864: LD_ADDR_VAR 0 16
19868: PUSH
19869: LD_VAR 0 1
19873: PPUSH
19874: CALL_OW 255
19878: ST_TO_ADDR
// x := GetX ( tower ) ;
19879: LD_ADDR_VAR 0 10
19883: PUSH
19884: LD_VAR 0 1
19888: PPUSH
19889: CALL_OW 250
19893: ST_TO_ADDR
// y := GetY ( tower ) ;
19894: LD_ADDR_VAR 0 11
19898: PUSH
19899: LD_VAR 0 1
19903: PPUSH
19904: CALL_OW 251
19908: ST_TO_ADDR
// if not x or not y then
19909: LD_VAR 0 10
19913: NOT
19914: PUSH
19915: LD_VAR 0 11
19919: NOT
19920: OR
19921: IFFALSE 19925
// exit ;
19923: GO 20958
// weapon := 0 ;
19925: LD_ADDR_VAR 0 18
19929: PUSH
19930: LD_INT 0
19932: ST_TO_ADDR
// fac_list := [ ] ;
19933: LD_ADDR_VAR 0 17
19937: PUSH
19938: EMPTY
19939: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19940: LD_ADDR_VAR 0 6
19944: PUSH
19945: LD_VAR 0 1
19949: PPUSH
19950: CALL_OW 274
19954: PPUSH
19955: LD_VAR 0 2
19959: PPUSH
19960: LD_INT 0
19962: PPUSH
19963: CALL 17529 0 3
19967: PPUSH
19968: LD_INT 30
19970: PUSH
19971: LD_INT 3
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: PPUSH
19978: CALL_OW 72
19982: ST_TO_ADDR
// if not factories then
19983: LD_VAR 0 6
19987: NOT
19988: IFFALSE 19992
// exit ;
19990: GO 20958
// for i in factories do
19992: LD_ADDR_VAR 0 8
19996: PUSH
19997: LD_VAR 0 6
20001: PUSH
20002: FOR_IN
20003: IFFALSE 20028
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20005: LD_ADDR_VAR 0 17
20009: PUSH
20010: LD_VAR 0 17
20014: PUSH
20015: LD_VAR 0 8
20019: PPUSH
20020: CALL_OW 478
20024: UNION
20025: ST_TO_ADDR
20026: GO 20002
20028: POP
20029: POP
// if not fac_list then
20030: LD_VAR 0 17
20034: NOT
20035: IFFALSE 20039
// exit ;
20037: GO 20958
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20039: LD_ADDR_VAR 0 5
20043: PUSH
20044: LD_INT 4
20046: PUSH
20047: LD_INT 5
20049: PUSH
20050: LD_INT 9
20052: PUSH
20053: LD_INT 10
20055: PUSH
20056: LD_INT 6
20058: PUSH
20059: LD_INT 7
20061: PUSH
20062: LD_INT 11
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: LIST
20069: LIST
20070: LIST
20071: LIST
20072: LIST
20073: PUSH
20074: LD_INT 27
20076: PUSH
20077: LD_INT 28
20079: PUSH
20080: LD_INT 26
20082: PUSH
20083: LD_INT 30
20085: PUSH
20086: EMPTY
20087: LIST
20088: LIST
20089: LIST
20090: LIST
20091: PUSH
20092: LD_INT 43
20094: PUSH
20095: LD_INT 44
20097: PUSH
20098: LD_INT 46
20100: PUSH
20101: LD_INT 45
20103: PUSH
20104: LD_INT 47
20106: PUSH
20107: LD_INT 49
20109: PUSH
20110: EMPTY
20111: LIST
20112: LIST
20113: LIST
20114: LIST
20115: LIST
20116: LIST
20117: PUSH
20118: EMPTY
20119: LIST
20120: LIST
20121: LIST
20122: PUSH
20123: LD_VAR 0 12
20127: ARRAY
20128: ST_TO_ADDR
// list := list isect fac_list ;
20129: LD_ADDR_VAR 0 5
20133: PUSH
20134: LD_VAR 0 5
20138: PUSH
20139: LD_VAR 0 17
20143: ISECT
20144: ST_TO_ADDR
// if not list then
20145: LD_VAR 0 5
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20958
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20154: LD_VAR 0 12
20158: PUSH
20159: LD_INT 3
20161: EQUAL
20162: PUSH
20163: LD_INT 49
20165: PUSH
20166: LD_VAR 0 5
20170: IN
20171: AND
20172: PUSH
20173: LD_INT 31
20175: PPUSH
20176: LD_VAR 0 16
20180: PPUSH
20181: CALL_OW 321
20185: PUSH
20186: LD_INT 2
20188: EQUAL
20189: AND
20190: IFFALSE 20250
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20192: LD_INT 22
20194: PUSH
20195: LD_VAR 0 16
20199: PUSH
20200: EMPTY
20201: LIST
20202: LIST
20203: PUSH
20204: LD_INT 35
20206: PUSH
20207: LD_INT 49
20209: PUSH
20210: EMPTY
20211: LIST
20212: LIST
20213: PUSH
20214: LD_INT 91
20216: PUSH
20217: LD_VAR 0 1
20221: PUSH
20222: LD_INT 10
20224: PUSH
20225: EMPTY
20226: LIST
20227: LIST
20228: LIST
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: LIST
20234: PPUSH
20235: CALL_OW 69
20239: NOT
20240: IFFALSE 20250
// weapon := ru_time_lapser ;
20242: LD_ADDR_VAR 0 18
20246: PUSH
20247: LD_INT 49
20249: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20250: LD_VAR 0 12
20254: PUSH
20255: LD_INT 1
20257: PUSH
20258: LD_INT 2
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: IN
20265: PUSH
20266: LD_INT 11
20268: PUSH
20269: LD_VAR 0 5
20273: IN
20274: PUSH
20275: LD_INT 30
20277: PUSH
20278: LD_VAR 0 5
20282: IN
20283: OR
20284: AND
20285: PUSH
20286: LD_INT 6
20288: PPUSH
20289: LD_VAR 0 16
20293: PPUSH
20294: CALL_OW 321
20298: PUSH
20299: LD_INT 2
20301: EQUAL
20302: AND
20303: IFFALSE 20468
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20305: LD_INT 22
20307: PUSH
20308: LD_VAR 0 16
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: PUSH
20317: LD_INT 2
20319: PUSH
20320: LD_INT 35
20322: PUSH
20323: LD_INT 11
20325: PUSH
20326: EMPTY
20327: LIST
20328: LIST
20329: PUSH
20330: LD_INT 35
20332: PUSH
20333: LD_INT 30
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: PUSH
20340: EMPTY
20341: LIST
20342: LIST
20343: LIST
20344: PUSH
20345: LD_INT 91
20347: PUSH
20348: LD_VAR 0 1
20352: PUSH
20353: LD_INT 18
20355: PUSH
20356: EMPTY
20357: LIST
20358: LIST
20359: LIST
20360: PUSH
20361: EMPTY
20362: LIST
20363: LIST
20364: LIST
20365: PPUSH
20366: CALL_OW 69
20370: NOT
20371: PUSH
20372: LD_INT 22
20374: PUSH
20375: LD_VAR 0 16
20379: PUSH
20380: EMPTY
20381: LIST
20382: LIST
20383: PUSH
20384: LD_INT 2
20386: PUSH
20387: LD_INT 30
20389: PUSH
20390: LD_INT 32
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 30
20399: PUSH
20400: LD_INT 33
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: PUSH
20407: EMPTY
20408: LIST
20409: LIST
20410: LIST
20411: PUSH
20412: LD_INT 91
20414: PUSH
20415: LD_VAR 0 1
20419: PUSH
20420: LD_INT 12
20422: PUSH
20423: EMPTY
20424: LIST
20425: LIST
20426: LIST
20427: PUSH
20428: EMPTY
20429: LIST
20430: LIST
20431: LIST
20432: PUSH
20433: EMPTY
20434: LIST
20435: PPUSH
20436: CALL_OW 69
20440: PUSH
20441: LD_INT 2
20443: GREATER
20444: AND
20445: IFFALSE 20468
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20447: LD_ADDR_VAR 0 18
20451: PUSH
20452: LD_INT 11
20454: PUSH
20455: LD_INT 30
20457: PUSH
20458: EMPTY
20459: LIST
20460: LIST
20461: PUSH
20462: LD_VAR 0 12
20466: ARRAY
20467: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20468: LD_VAR 0 18
20472: NOT
20473: PUSH
20474: LD_INT 40
20476: PPUSH
20477: LD_VAR 0 16
20481: PPUSH
20482: CALL_OW 321
20486: PUSH
20487: LD_INT 2
20489: EQUAL
20490: AND
20491: PUSH
20492: LD_INT 7
20494: PUSH
20495: LD_VAR 0 5
20499: IN
20500: PUSH
20501: LD_INT 28
20503: PUSH
20504: LD_VAR 0 5
20508: IN
20509: OR
20510: PUSH
20511: LD_INT 45
20513: PUSH
20514: LD_VAR 0 5
20518: IN
20519: OR
20520: AND
20521: IFFALSE 20775
// begin hex := GetHexInfo ( x , y ) ;
20523: LD_ADDR_VAR 0 4
20527: PUSH
20528: LD_VAR 0 10
20532: PPUSH
20533: LD_VAR 0 11
20537: PPUSH
20538: CALL_OW 546
20542: ST_TO_ADDR
// if hex [ 1 ] then
20543: LD_VAR 0 4
20547: PUSH
20548: LD_INT 1
20550: ARRAY
20551: IFFALSE 20555
// exit ;
20553: GO 20958
// height := hex [ 2 ] ;
20555: LD_ADDR_VAR 0 15
20559: PUSH
20560: LD_VAR 0 4
20564: PUSH
20565: LD_INT 2
20567: ARRAY
20568: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20569: LD_ADDR_VAR 0 14
20573: PUSH
20574: LD_INT 0
20576: PUSH
20577: LD_INT 2
20579: PUSH
20580: LD_INT 3
20582: PUSH
20583: LD_INT 5
20585: PUSH
20586: EMPTY
20587: LIST
20588: LIST
20589: LIST
20590: LIST
20591: ST_TO_ADDR
// for i in tmp do
20592: LD_ADDR_VAR 0 8
20596: PUSH
20597: LD_VAR 0 14
20601: PUSH
20602: FOR_IN
20603: IFFALSE 20773
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20605: LD_ADDR_VAR 0 9
20609: PUSH
20610: LD_VAR 0 10
20614: PPUSH
20615: LD_VAR 0 8
20619: PPUSH
20620: LD_INT 5
20622: PPUSH
20623: CALL_OW 272
20627: PUSH
20628: LD_VAR 0 11
20632: PPUSH
20633: LD_VAR 0 8
20637: PPUSH
20638: LD_INT 5
20640: PPUSH
20641: CALL_OW 273
20645: PUSH
20646: EMPTY
20647: LIST
20648: LIST
20649: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20650: LD_VAR 0 9
20654: PUSH
20655: LD_INT 1
20657: ARRAY
20658: PPUSH
20659: LD_VAR 0 9
20663: PUSH
20664: LD_INT 2
20666: ARRAY
20667: PPUSH
20668: CALL_OW 488
20672: IFFALSE 20771
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20674: LD_ADDR_VAR 0 4
20678: PUSH
20679: LD_VAR 0 9
20683: PUSH
20684: LD_INT 1
20686: ARRAY
20687: PPUSH
20688: LD_VAR 0 9
20692: PUSH
20693: LD_INT 2
20695: ARRAY
20696: PPUSH
20697: CALL_OW 546
20701: ST_TO_ADDR
// if hex [ 1 ] then
20702: LD_VAR 0 4
20706: PUSH
20707: LD_INT 1
20709: ARRAY
20710: IFFALSE 20714
// continue ;
20712: GO 20602
// h := hex [ 2 ] ;
20714: LD_ADDR_VAR 0 13
20718: PUSH
20719: LD_VAR 0 4
20723: PUSH
20724: LD_INT 2
20726: ARRAY
20727: ST_TO_ADDR
// if h + 7 < height then
20728: LD_VAR 0 13
20732: PUSH
20733: LD_INT 7
20735: PLUS
20736: PUSH
20737: LD_VAR 0 15
20741: LESS
20742: IFFALSE 20771
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20744: LD_ADDR_VAR 0 18
20748: PUSH
20749: LD_INT 7
20751: PUSH
20752: LD_INT 28
20754: PUSH
20755: LD_INT 45
20757: PUSH
20758: EMPTY
20759: LIST
20760: LIST
20761: LIST
20762: PUSH
20763: LD_VAR 0 12
20767: ARRAY
20768: ST_TO_ADDR
// break ;
20769: GO 20773
// end ; end ; end ;
20771: GO 20602
20773: POP
20774: POP
// end ; if not weapon then
20775: LD_VAR 0 18
20779: NOT
20780: IFFALSE 20840
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20782: LD_ADDR_VAR 0 5
20786: PUSH
20787: LD_VAR 0 5
20791: PUSH
20792: LD_INT 11
20794: PUSH
20795: LD_INT 30
20797: PUSH
20798: LD_INT 49
20800: PUSH
20801: EMPTY
20802: LIST
20803: LIST
20804: LIST
20805: DIFF
20806: ST_TO_ADDR
// if not list then
20807: LD_VAR 0 5
20811: NOT
20812: IFFALSE 20816
// exit ;
20814: GO 20958
// weapon := list [ rand ( 1 , list ) ] ;
20816: LD_ADDR_VAR 0 18
20820: PUSH
20821: LD_VAR 0 5
20825: PUSH
20826: LD_INT 1
20828: PPUSH
20829: LD_VAR 0 5
20833: PPUSH
20834: CALL_OW 12
20838: ARRAY
20839: ST_TO_ADDR
// end ; if weapon then
20840: LD_VAR 0 18
20844: IFFALSE 20958
// begin tmp := CostOfWeapon ( weapon ) ;
20846: LD_ADDR_VAR 0 14
20850: PUSH
20851: LD_VAR 0 18
20855: PPUSH
20856: CALL_OW 451
20860: ST_TO_ADDR
// j := GetBase ( tower ) ;
20861: LD_ADDR_VAR 0 9
20865: PUSH
20866: LD_VAR 0 1
20870: PPUSH
20871: CALL_OW 274
20875: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20876: LD_VAR 0 9
20880: PPUSH
20881: LD_INT 1
20883: PPUSH
20884: CALL_OW 275
20888: PUSH
20889: LD_VAR 0 14
20893: PUSH
20894: LD_INT 1
20896: ARRAY
20897: GREATEREQUAL
20898: PUSH
20899: LD_VAR 0 9
20903: PPUSH
20904: LD_INT 2
20906: PPUSH
20907: CALL_OW 275
20911: PUSH
20912: LD_VAR 0 14
20916: PUSH
20917: LD_INT 2
20919: ARRAY
20920: GREATEREQUAL
20921: AND
20922: PUSH
20923: LD_VAR 0 9
20927: PPUSH
20928: LD_INT 3
20930: PPUSH
20931: CALL_OW 275
20935: PUSH
20936: LD_VAR 0 14
20940: PUSH
20941: LD_INT 3
20943: ARRAY
20944: GREATEREQUAL
20945: AND
20946: IFFALSE 20958
// result := weapon ;
20948: LD_ADDR_VAR 0 3
20952: PUSH
20953: LD_VAR 0 18
20957: ST_TO_ADDR
// end ; end ;
20958: LD_VAR 0 3
20962: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
20963: LD_INT 0
20965: PPUSH
20966: PPUSH
// result := true ;
20967: LD_ADDR_VAR 0 3
20971: PUSH
20972: LD_INT 1
20974: ST_TO_ADDR
// if array1 = array2 then
20975: LD_VAR 0 1
20979: PUSH
20980: LD_VAR 0 2
20984: EQUAL
20985: IFFALSE 21045
// begin for i = 1 to array1 do
20987: LD_ADDR_VAR 0 4
20991: PUSH
20992: DOUBLE
20993: LD_INT 1
20995: DEC
20996: ST_TO_ADDR
20997: LD_VAR 0 1
21001: PUSH
21002: FOR_TO
21003: IFFALSE 21041
// if array1 [ i ] <> array2 [ i ] then
21005: LD_VAR 0 1
21009: PUSH
21010: LD_VAR 0 4
21014: ARRAY
21015: PUSH
21016: LD_VAR 0 2
21020: PUSH
21021: LD_VAR 0 4
21025: ARRAY
21026: NONEQUAL
21027: IFFALSE 21039
// begin result := false ;
21029: LD_ADDR_VAR 0 3
21033: PUSH
21034: LD_INT 0
21036: ST_TO_ADDR
// break ;
21037: GO 21041
// end ;
21039: GO 21002
21041: POP
21042: POP
// end else
21043: GO 21053
// result := false ;
21045: LD_ADDR_VAR 0 3
21049: PUSH
21050: LD_INT 0
21052: ST_TO_ADDR
// end ;
21053: LD_VAR 0 3
21057: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21058: LD_INT 0
21060: PPUSH
21061: PPUSH
// if not array1 or not array2 then
21062: LD_VAR 0 1
21066: NOT
21067: PUSH
21068: LD_VAR 0 2
21072: NOT
21073: OR
21074: IFFALSE 21078
// exit ;
21076: GO 21142
// result := true ;
21078: LD_ADDR_VAR 0 3
21082: PUSH
21083: LD_INT 1
21085: ST_TO_ADDR
// for i = 1 to array1 do
21086: LD_ADDR_VAR 0 4
21090: PUSH
21091: DOUBLE
21092: LD_INT 1
21094: DEC
21095: ST_TO_ADDR
21096: LD_VAR 0 1
21100: PUSH
21101: FOR_TO
21102: IFFALSE 21140
// if array1 [ i ] <> array2 [ i ] then
21104: LD_VAR 0 1
21108: PUSH
21109: LD_VAR 0 4
21113: ARRAY
21114: PUSH
21115: LD_VAR 0 2
21119: PUSH
21120: LD_VAR 0 4
21124: ARRAY
21125: NONEQUAL
21126: IFFALSE 21138
// begin result := false ;
21128: LD_ADDR_VAR 0 3
21132: PUSH
21133: LD_INT 0
21135: ST_TO_ADDR
// break ;
21136: GO 21140
// end ;
21138: GO 21101
21140: POP
21141: POP
// end ;
21142: LD_VAR 0 3
21146: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21147: LD_INT 0
21149: PPUSH
21150: PPUSH
21151: PPUSH
// pom := GetBase ( fac ) ;
21152: LD_ADDR_VAR 0 5
21156: PUSH
21157: LD_VAR 0 1
21161: PPUSH
21162: CALL_OW 274
21166: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21167: LD_ADDR_VAR 0 4
21171: PUSH
21172: LD_VAR 0 2
21176: PUSH
21177: LD_INT 1
21179: ARRAY
21180: PPUSH
21181: LD_VAR 0 2
21185: PUSH
21186: LD_INT 2
21188: ARRAY
21189: PPUSH
21190: LD_VAR 0 2
21194: PUSH
21195: LD_INT 3
21197: ARRAY
21198: PPUSH
21199: LD_VAR 0 2
21203: PUSH
21204: LD_INT 4
21206: ARRAY
21207: PPUSH
21208: CALL_OW 449
21212: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21213: LD_ADDR_VAR 0 3
21217: PUSH
21218: LD_VAR 0 5
21222: PPUSH
21223: LD_INT 1
21225: PPUSH
21226: CALL_OW 275
21230: PUSH
21231: LD_VAR 0 4
21235: PUSH
21236: LD_INT 1
21238: ARRAY
21239: GREATEREQUAL
21240: PUSH
21241: LD_VAR 0 5
21245: PPUSH
21246: LD_INT 2
21248: PPUSH
21249: CALL_OW 275
21253: PUSH
21254: LD_VAR 0 4
21258: PUSH
21259: LD_INT 2
21261: ARRAY
21262: GREATEREQUAL
21263: AND
21264: PUSH
21265: LD_VAR 0 5
21269: PPUSH
21270: LD_INT 3
21272: PPUSH
21273: CALL_OW 275
21277: PUSH
21278: LD_VAR 0 4
21282: PUSH
21283: LD_INT 3
21285: ARRAY
21286: GREATEREQUAL
21287: AND
21288: ST_TO_ADDR
// end ;
21289: LD_VAR 0 3
21293: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21294: LD_INT 0
21296: PPUSH
21297: PPUSH
21298: PPUSH
21299: PPUSH
// pom := GetBase ( building ) ;
21300: LD_ADDR_VAR 0 3
21304: PUSH
21305: LD_VAR 0 1
21309: PPUSH
21310: CALL_OW 274
21314: ST_TO_ADDR
// if not pom then
21315: LD_VAR 0 3
21319: NOT
21320: IFFALSE 21324
// exit ;
21322: GO 21494
// btype := GetBType ( building ) ;
21324: LD_ADDR_VAR 0 5
21328: PUSH
21329: LD_VAR 0 1
21333: PPUSH
21334: CALL_OW 266
21338: ST_TO_ADDR
// if btype = b_armoury then
21339: LD_VAR 0 5
21343: PUSH
21344: LD_INT 4
21346: EQUAL
21347: IFFALSE 21357
// btype := b_barracks ;
21349: LD_ADDR_VAR 0 5
21353: PUSH
21354: LD_INT 5
21356: ST_TO_ADDR
// if btype = b_depot then
21357: LD_VAR 0 5
21361: PUSH
21362: LD_INT 0
21364: EQUAL
21365: IFFALSE 21375
// btype := b_warehouse ;
21367: LD_ADDR_VAR 0 5
21371: PUSH
21372: LD_INT 1
21374: ST_TO_ADDR
// if btype = b_workshop then
21375: LD_VAR 0 5
21379: PUSH
21380: LD_INT 2
21382: EQUAL
21383: IFFALSE 21393
// btype := b_factory ;
21385: LD_ADDR_VAR 0 5
21389: PUSH
21390: LD_INT 3
21392: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21393: LD_ADDR_VAR 0 4
21397: PUSH
21398: LD_VAR 0 5
21402: PPUSH
21403: LD_VAR 0 1
21407: PPUSH
21408: CALL_OW 248
21412: PPUSH
21413: CALL_OW 450
21417: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21418: LD_ADDR_VAR 0 2
21422: PUSH
21423: LD_VAR 0 3
21427: PPUSH
21428: LD_INT 1
21430: PPUSH
21431: CALL_OW 275
21435: PUSH
21436: LD_VAR 0 4
21440: PUSH
21441: LD_INT 1
21443: ARRAY
21444: GREATEREQUAL
21445: PUSH
21446: LD_VAR 0 3
21450: PPUSH
21451: LD_INT 2
21453: PPUSH
21454: CALL_OW 275
21458: PUSH
21459: LD_VAR 0 4
21463: PUSH
21464: LD_INT 2
21466: ARRAY
21467: GREATEREQUAL
21468: AND
21469: PUSH
21470: LD_VAR 0 3
21474: PPUSH
21475: LD_INT 3
21477: PPUSH
21478: CALL_OW 275
21482: PUSH
21483: LD_VAR 0 4
21487: PUSH
21488: LD_INT 3
21490: ARRAY
21491: GREATEREQUAL
21492: AND
21493: ST_TO_ADDR
// end ;
21494: LD_VAR 0 2
21498: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21499: LD_INT 0
21501: PPUSH
21502: PPUSH
21503: PPUSH
// pom := GetBase ( building ) ;
21504: LD_ADDR_VAR 0 4
21508: PUSH
21509: LD_VAR 0 1
21513: PPUSH
21514: CALL_OW 274
21518: ST_TO_ADDR
// if not pom then
21519: LD_VAR 0 4
21523: NOT
21524: IFFALSE 21528
// exit ;
21526: GO 21629
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21528: LD_ADDR_VAR 0 5
21532: PUSH
21533: LD_VAR 0 2
21537: PPUSH
21538: LD_VAR 0 1
21542: PPUSH
21543: CALL_OW 248
21547: PPUSH
21548: CALL_OW 450
21552: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21553: LD_ADDR_VAR 0 3
21557: PUSH
21558: LD_VAR 0 4
21562: PPUSH
21563: LD_INT 1
21565: PPUSH
21566: CALL_OW 275
21570: PUSH
21571: LD_VAR 0 5
21575: PUSH
21576: LD_INT 1
21578: ARRAY
21579: GREATEREQUAL
21580: PUSH
21581: LD_VAR 0 4
21585: PPUSH
21586: LD_INT 2
21588: PPUSH
21589: CALL_OW 275
21593: PUSH
21594: LD_VAR 0 5
21598: PUSH
21599: LD_INT 2
21601: ARRAY
21602: GREATEREQUAL
21603: AND
21604: PUSH
21605: LD_VAR 0 4
21609: PPUSH
21610: LD_INT 3
21612: PPUSH
21613: CALL_OW 275
21617: PUSH
21618: LD_VAR 0 5
21622: PUSH
21623: LD_INT 3
21625: ARRAY
21626: GREATEREQUAL
21627: AND
21628: ST_TO_ADDR
// end ;
21629: LD_VAR 0 3
21633: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21634: LD_INT 0
21636: PPUSH
21637: PPUSH
21638: PPUSH
21639: PPUSH
21640: PPUSH
21641: PPUSH
21642: PPUSH
21643: PPUSH
21644: PPUSH
21645: PPUSH
21646: PPUSH
// result := false ;
21647: LD_ADDR_VAR 0 8
21651: PUSH
21652: LD_INT 0
21654: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21655: LD_VAR 0 5
21659: NOT
21660: PUSH
21661: LD_VAR 0 1
21665: NOT
21666: OR
21667: PUSH
21668: LD_VAR 0 2
21672: NOT
21673: OR
21674: PUSH
21675: LD_VAR 0 3
21679: NOT
21680: OR
21681: IFFALSE 21685
// exit ;
21683: GO 22499
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21685: LD_ADDR_VAR 0 14
21689: PUSH
21690: LD_VAR 0 1
21694: PPUSH
21695: LD_VAR 0 2
21699: PPUSH
21700: LD_VAR 0 3
21704: PPUSH
21705: LD_VAR 0 4
21709: PPUSH
21710: LD_VAR 0 5
21714: PUSH
21715: LD_INT 1
21717: ARRAY
21718: PPUSH
21719: CALL_OW 248
21723: PPUSH
21724: LD_INT 0
21726: PPUSH
21727: CALL 23752 0 6
21731: ST_TO_ADDR
// if not hexes then
21732: LD_VAR 0 14
21736: NOT
21737: IFFALSE 21741
// exit ;
21739: GO 22499
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21741: LD_ADDR_VAR 0 17
21745: PUSH
21746: LD_VAR 0 5
21750: PPUSH
21751: LD_INT 22
21753: PUSH
21754: LD_VAR 0 13
21758: PPUSH
21759: CALL_OW 255
21763: PUSH
21764: EMPTY
21765: LIST
21766: LIST
21767: PUSH
21768: LD_INT 2
21770: PUSH
21771: LD_INT 30
21773: PUSH
21774: LD_INT 0
21776: PUSH
21777: EMPTY
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 30
21783: PUSH
21784: LD_INT 1
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: PUSH
21791: EMPTY
21792: LIST
21793: LIST
21794: LIST
21795: PUSH
21796: EMPTY
21797: LIST
21798: LIST
21799: PPUSH
21800: CALL_OW 72
21804: ST_TO_ADDR
// for i = 1 to hexes do
21805: LD_ADDR_VAR 0 9
21809: PUSH
21810: DOUBLE
21811: LD_INT 1
21813: DEC
21814: ST_TO_ADDR
21815: LD_VAR 0 14
21819: PUSH
21820: FOR_TO
21821: IFFALSE 22497
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21823: LD_ADDR_VAR 0 13
21827: PUSH
21828: LD_VAR 0 14
21832: PUSH
21833: LD_VAR 0 9
21837: ARRAY
21838: PUSH
21839: LD_INT 1
21841: ARRAY
21842: PPUSH
21843: LD_VAR 0 14
21847: PUSH
21848: LD_VAR 0 9
21852: ARRAY
21853: PUSH
21854: LD_INT 2
21856: ARRAY
21857: PPUSH
21858: CALL_OW 428
21862: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21863: LD_VAR 0 14
21867: PUSH
21868: LD_VAR 0 9
21872: ARRAY
21873: PUSH
21874: LD_INT 1
21876: ARRAY
21877: PPUSH
21878: LD_VAR 0 14
21882: PUSH
21883: LD_VAR 0 9
21887: ARRAY
21888: PUSH
21889: LD_INT 2
21891: ARRAY
21892: PPUSH
21893: CALL_OW 351
21897: PUSH
21898: LD_VAR 0 14
21902: PUSH
21903: LD_VAR 0 9
21907: ARRAY
21908: PUSH
21909: LD_INT 1
21911: ARRAY
21912: PPUSH
21913: LD_VAR 0 14
21917: PUSH
21918: LD_VAR 0 9
21922: ARRAY
21923: PUSH
21924: LD_INT 2
21926: ARRAY
21927: PPUSH
21928: CALL_OW 488
21932: NOT
21933: OR
21934: PUSH
21935: LD_VAR 0 13
21939: PPUSH
21940: CALL_OW 247
21944: PUSH
21945: LD_INT 3
21947: EQUAL
21948: OR
21949: IFFALSE 21955
// exit ;
21951: POP
21952: POP
21953: GO 22499
// if not tmp then
21955: LD_VAR 0 13
21959: NOT
21960: IFFALSE 21964
// continue ;
21962: GO 21820
// result := true ;
21964: LD_ADDR_VAR 0 8
21968: PUSH
21969: LD_INT 1
21971: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
21972: LD_VAR 0 6
21976: PUSH
21977: LD_VAR 0 13
21981: PPUSH
21982: CALL_OW 247
21986: PUSH
21987: LD_INT 2
21989: EQUAL
21990: AND
21991: PUSH
21992: LD_VAR 0 13
21996: PPUSH
21997: CALL_OW 263
22001: PUSH
22002: LD_INT 1
22004: EQUAL
22005: AND
22006: IFFALSE 22170
// begin if IsDrivenBy ( tmp ) then
22008: LD_VAR 0 13
22012: PPUSH
22013: CALL_OW 311
22017: IFFALSE 22021
// continue ;
22019: GO 21820
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22021: LD_VAR 0 6
22025: PPUSH
22026: LD_INT 3
22028: PUSH
22029: LD_INT 60
22031: PUSH
22032: EMPTY
22033: LIST
22034: PUSH
22035: EMPTY
22036: LIST
22037: LIST
22038: PUSH
22039: LD_INT 3
22041: PUSH
22042: LD_INT 55
22044: PUSH
22045: EMPTY
22046: LIST
22047: PUSH
22048: EMPTY
22049: LIST
22050: LIST
22051: PUSH
22052: EMPTY
22053: LIST
22054: LIST
22055: PPUSH
22056: CALL_OW 72
22060: IFFALSE 22168
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22062: LD_ADDR_VAR 0 18
22066: PUSH
22067: LD_VAR 0 6
22071: PPUSH
22072: LD_INT 3
22074: PUSH
22075: LD_INT 60
22077: PUSH
22078: EMPTY
22079: LIST
22080: PUSH
22081: EMPTY
22082: LIST
22083: LIST
22084: PUSH
22085: LD_INT 3
22087: PUSH
22088: LD_INT 55
22090: PUSH
22091: EMPTY
22092: LIST
22093: PUSH
22094: EMPTY
22095: LIST
22096: LIST
22097: PUSH
22098: EMPTY
22099: LIST
22100: LIST
22101: PPUSH
22102: CALL_OW 72
22106: PUSH
22107: LD_INT 1
22109: ARRAY
22110: ST_TO_ADDR
// if IsInUnit ( driver ) then
22111: LD_VAR 0 18
22115: PPUSH
22116: CALL_OW 310
22120: IFFALSE 22131
// ComExit ( driver ) ;
22122: LD_VAR 0 18
22126: PPUSH
22127: CALL 47531 0 1
// AddComEnterUnit ( driver , tmp ) ;
22131: LD_VAR 0 18
22135: PPUSH
22136: LD_VAR 0 13
22140: PPUSH
22141: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
22145: LD_VAR 0 18
22149: PPUSH
22150: LD_VAR 0 7
22154: PPUSH
22155: CALL_OW 173
// AddComExitVehicle ( driver ) ;
22159: LD_VAR 0 18
22163: PPUSH
22164: CALL_OW 181
// end ; continue ;
22168: GO 21820
// end ; if not cleaners or not tmp in cleaners then
22170: LD_VAR 0 6
22174: NOT
22175: PUSH
22176: LD_VAR 0 13
22180: PUSH
22181: LD_VAR 0 6
22185: IN
22186: NOT
22187: OR
22188: IFFALSE 22495
// begin if dep then
22190: LD_VAR 0 17
22194: IFFALSE 22330
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22196: LD_ADDR_VAR 0 16
22200: PUSH
22201: LD_VAR 0 17
22205: PUSH
22206: LD_INT 1
22208: ARRAY
22209: PPUSH
22210: CALL_OW 250
22214: PPUSH
22215: LD_VAR 0 17
22219: PUSH
22220: LD_INT 1
22222: ARRAY
22223: PPUSH
22224: CALL_OW 254
22228: PPUSH
22229: LD_INT 5
22231: PPUSH
22232: CALL_OW 272
22236: PUSH
22237: LD_VAR 0 17
22241: PUSH
22242: LD_INT 1
22244: ARRAY
22245: PPUSH
22246: CALL_OW 251
22250: PPUSH
22251: LD_VAR 0 17
22255: PUSH
22256: LD_INT 1
22258: ARRAY
22259: PPUSH
22260: CALL_OW 254
22264: PPUSH
22265: LD_INT 5
22267: PPUSH
22268: CALL_OW 273
22272: PUSH
22273: EMPTY
22274: LIST
22275: LIST
22276: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22277: LD_VAR 0 16
22281: PUSH
22282: LD_INT 1
22284: ARRAY
22285: PPUSH
22286: LD_VAR 0 16
22290: PUSH
22291: LD_INT 2
22293: ARRAY
22294: PPUSH
22295: CALL_OW 488
22299: IFFALSE 22330
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22301: LD_VAR 0 13
22305: PPUSH
22306: LD_VAR 0 16
22310: PUSH
22311: LD_INT 1
22313: ARRAY
22314: PPUSH
22315: LD_VAR 0 16
22319: PUSH
22320: LD_INT 2
22322: ARRAY
22323: PPUSH
22324: CALL_OW 111
// continue ;
22328: GO 21820
// end ; end ; r := GetDir ( tmp ) ;
22330: LD_ADDR_VAR 0 15
22334: PUSH
22335: LD_VAR 0 13
22339: PPUSH
22340: CALL_OW 254
22344: ST_TO_ADDR
// if r = 5 then
22345: LD_VAR 0 15
22349: PUSH
22350: LD_INT 5
22352: EQUAL
22353: IFFALSE 22363
// r := 0 ;
22355: LD_ADDR_VAR 0 15
22359: PUSH
22360: LD_INT 0
22362: ST_TO_ADDR
// for j = r to 5 do
22363: LD_ADDR_VAR 0 10
22367: PUSH
22368: DOUBLE
22369: LD_VAR 0 15
22373: DEC
22374: ST_TO_ADDR
22375: LD_INT 5
22377: PUSH
22378: FOR_TO
22379: IFFALSE 22493
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22381: LD_ADDR_VAR 0 11
22385: PUSH
22386: LD_VAR 0 13
22390: PPUSH
22391: CALL_OW 250
22395: PPUSH
22396: LD_VAR 0 10
22400: PPUSH
22401: LD_INT 2
22403: PPUSH
22404: CALL_OW 272
22408: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22409: LD_ADDR_VAR 0 12
22413: PUSH
22414: LD_VAR 0 13
22418: PPUSH
22419: CALL_OW 251
22423: PPUSH
22424: LD_VAR 0 10
22428: PPUSH
22429: LD_INT 2
22431: PPUSH
22432: CALL_OW 273
22436: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22437: LD_VAR 0 11
22441: PPUSH
22442: LD_VAR 0 12
22446: PPUSH
22447: CALL_OW 488
22451: PUSH
22452: LD_VAR 0 11
22456: PPUSH
22457: LD_VAR 0 12
22461: PPUSH
22462: CALL_OW 428
22466: NOT
22467: AND
22468: IFFALSE 22491
// begin ComMoveXY ( tmp , _x , _y ) ;
22470: LD_VAR 0 13
22474: PPUSH
22475: LD_VAR 0 11
22479: PPUSH
22480: LD_VAR 0 12
22484: PPUSH
22485: CALL_OW 111
// break ;
22489: GO 22493
// end ; end ;
22491: GO 22378
22493: POP
22494: POP
// end ; end ;
22495: GO 21820
22497: POP
22498: POP
// end ;
22499: LD_VAR 0 8
22503: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22504: LD_INT 0
22506: PPUSH
// result := true ;
22507: LD_ADDR_VAR 0 3
22511: PUSH
22512: LD_INT 1
22514: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22515: LD_VAR 0 2
22519: PUSH
22520: LD_INT 24
22522: DOUBLE
22523: EQUAL
22524: IFTRUE 22534
22526: LD_INT 33
22528: DOUBLE
22529: EQUAL
22530: IFTRUE 22534
22532: GO 22559
22534: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22535: LD_ADDR_VAR 0 3
22539: PUSH
22540: LD_INT 32
22542: PPUSH
22543: LD_VAR 0 1
22547: PPUSH
22548: CALL_OW 321
22552: PUSH
22553: LD_INT 2
22555: EQUAL
22556: ST_TO_ADDR
22557: GO 22875
22559: LD_INT 20
22561: DOUBLE
22562: EQUAL
22563: IFTRUE 22567
22565: GO 22592
22567: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22568: LD_ADDR_VAR 0 3
22572: PUSH
22573: LD_INT 6
22575: PPUSH
22576: LD_VAR 0 1
22580: PPUSH
22581: CALL_OW 321
22585: PUSH
22586: LD_INT 2
22588: EQUAL
22589: ST_TO_ADDR
22590: GO 22875
22592: LD_INT 22
22594: DOUBLE
22595: EQUAL
22596: IFTRUE 22606
22598: LD_INT 36
22600: DOUBLE
22601: EQUAL
22602: IFTRUE 22606
22604: GO 22631
22606: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22607: LD_ADDR_VAR 0 3
22611: PUSH
22612: LD_INT 15
22614: PPUSH
22615: LD_VAR 0 1
22619: PPUSH
22620: CALL_OW 321
22624: PUSH
22625: LD_INT 2
22627: EQUAL
22628: ST_TO_ADDR
22629: GO 22875
22631: LD_INT 30
22633: DOUBLE
22634: EQUAL
22635: IFTRUE 22639
22637: GO 22664
22639: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22640: LD_ADDR_VAR 0 3
22644: PUSH
22645: LD_INT 20
22647: PPUSH
22648: LD_VAR 0 1
22652: PPUSH
22653: CALL_OW 321
22657: PUSH
22658: LD_INT 2
22660: EQUAL
22661: ST_TO_ADDR
22662: GO 22875
22664: LD_INT 28
22666: DOUBLE
22667: EQUAL
22668: IFTRUE 22678
22670: LD_INT 21
22672: DOUBLE
22673: EQUAL
22674: IFTRUE 22678
22676: GO 22703
22678: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22679: LD_ADDR_VAR 0 3
22683: PUSH
22684: LD_INT 21
22686: PPUSH
22687: LD_VAR 0 1
22691: PPUSH
22692: CALL_OW 321
22696: PUSH
22697: LD_INT 2
22699: EQUAL
22700: ST_TO_ADDR
22701: GO 22875
22703: LD_INT 16
22705: DOUBLE
22706: EQUAL
22707: IFTRUE 22711
22709: GO 22736
22711: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22712: LD_ADDR_VAR 0 3
22716: PUSH
22717: LD_INT 84
22719: PPUSH
22720: LD_VAR 0 1
22724: PPUSH
22725: CALL_OW 321
22729: PUSH
22730: LD_INT 2
22732: EQUAL
22733: ST_TO_ADDR
22734: GO 22875
22736: LD_INT 19
22738: DOUBLE
22739: EQUAL
22740: IFTRUE 22750
22742: LD_INT 23
22744: DOUBLE
22745: EQUAL
22746: IFTRUE 22750
22748: GO 22775
22750: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22751: LD_ADDR_VAR 0 3
22755: PUSH
22756: LD_INT 83
22758: PPUSH
22759: LD_VAR 0 1
22763: PPUSH
22764: CALL_OW 321
22768: PUSH
22769: LD_INT 2
22771: EQUAL
22772: ST_TO_ADDR
22773: GO 22875
22775: LD_INT 17
22777: DOUBLE
22778: EQUAL
22779: IFTRUE 22783
22781: GO 22808
22783: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22784: LD_ADDR_VAR 0 3
22788: PUSH
22789: LD_INT 39
22791: PPUSH
22792: LD_VAR 0 1
22796: PPUSH
22797: CALL_OW 321
22801: PUSH
22802: LD_INT 2
22804: EQUAL
22805: ST_TO_ADDR
22806: GO 22875
22808: LD_INT 18
22810: DOUBLE
22811: EQUAL
22812: IFTRUE 22816
22814: GO 22841
22816: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
22817: LD_ADDR_VAR 0 3
22821: PUSH
22822: LD_INT 40
22824: PPUSH
22825: LD_VAR 0 1
22829: PPUSH
22830: CALL_OW 321
22834: PUSH
22835: LD_INT 2
22837: EQUAL
22838: ST_TO_ADDR
22839: GO 22875
22841: LD_INT 27
22843: DOUBLE
22844: EQUAL
22845: IFTRUE 22849
22847: GO 22874
22849: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
22850: LD_ADDR_VAR 0 3
22854: PUSH
22855: LD_INT 35
22857: PPUSH
22858: LD_VAR 0 1
22862: PPUSH
22863: CALL_OW 321
22867: PUSH
22868: LD_INT 2
22870: EQUAL
22871: ST_TO_ADDR
22872: GO 22875
22874: POP
// end ;
22875: LD_VAR 0 3
22879: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
22880: LD_INT 0
22882: PPUSH
22883: PPUSH
22884: PPUSH
22885: PPUSH
22886: PPUSH
22887: PPUSH
22888: PPUSH
22889: PPUSH
22890: PPUSH
22891: PPUSH
22892: PPUSH
// result := false ;
22893: LD_ADDR_VAR 0 6
22897: PUSH
22898: LD_INT 0
22900: ST_TO_ADDR
// if btype = b_depot then
22901: LD_VAR 0 2
22905: PUSH
22906: LD_INT 0
22908: EQUAL
22909: IFFALSE 22921
// begin result := true ;
22911: LD_ADDR_VAR 0 6
22915: PUSH
22916: LD_INT 1
22918: ST_TO_ADDR
// exit ;
22919: GO 23747
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22921: LD_VAR 0 1
22925: NOT
22926: PUSH
22927: LD_VAR 0 1
22931: PPUSH
22932: CALL_OW 266
22936: PUSH
22937: LD_INT 0
22939: PUSH
22940: LD_INT 1
22942: PUSH
22943: EMPTY
22944: LIST
22945: LIST
22946: IN
22947: NOT
22948: OR
22949: PUSH
22950: LD_VAR 0 2
22954: NOT
22955: OR
22956: PUSH
22957: LD_VAR 0 5
22961: PUSH
22962: LD_INT 0
22964: PUSH
22965: LD_INT 1
22967: PUSH
22968: LD_INT 2
22970: PUSH
22971: LD_INT 3
22973: PUSH
22974: LD_INT 4
22976: PUSH
22977: LD_INT 5
22979: PUSH
22980: EMPTY
22981: LIST
22982: LIST
22983: LIST
22984: LIST
22985: LIST
22986: LIST
22987: IN
22988: NOT
22989: OR
22990: PUSH
22991: LD_VAR 0 3
22995: PPUSH
22996: LD_VAR 0 4
23000: PPUSH
23001: CALL_OW 488
23005: NOT
23006: OR
23007: IFFALSE 23011
// exit ;
23009: GO 23747
// side := GetSide ( depot ) ;
23011: LD_ADDR_VAR 0 9
23015: PUSH
23016: LD_VAR 0 1
23020: PPUSH
23021: CALL_OW 255
23025: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23026: LD_VAR 0 9
23030: PPUSH
23031: LD_VAR 0 2
23035: PPUSH
23036: CALL 22504 0 2
23040: NOT
23041: IFFALSE 23045
// exit ;
23043: GO 23747
// pom := GetBase ( depot ) ;
23045: LD_ADDR_VAR 0 10
23049: PUSH
23050: LD_VAR 0 1
23054: PPUSH
23055: CALL_OW 274
23059: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23060: LD_ADDR_VAR 0 11
23064: PUSH
23065: LD_VAR 0 2
23069: PPUSH
23070: LD_VAR 0 1
23074: PPUSH
23075: CALL_OW 248
23079: PPUSH
23080: CALL_OW 450
23084: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23085: LD_VAR 0 10
23089: PPUSH
23090: LD_INT 1
23092: PPUSH
23093: CALL_OW 275
23097: PUSH
23098: LD_VAR 0 11
23102: PUSH
23103: LD_INT 1
23105: ARRAY
23106: GREATEREQUAL
23107: PUSH
23108: LD_VAR 0 10
23112: PPUSH
23113: LD_INT 2
23115: PPUSH
23116: CALL_OW 275
23120: PUSH
23121: LD_VAR 0 11
23125: PUSH
23126: LD_INT 2
23128: ARRAY
23129: GREATEREQUAL
23130: AND
23131: PUSH
23132: LD_VAR 0 10
23136: PPUSH
23137: LD_INT 3
23139: PPUSH
23140: CALL_OW 275
23144: PUSH
23145: LD_VAR 0 11
23149: PUSH
23150: LD_INT 3
23152: ARRAY
23153: GREATEREQUAL
23154: AND
23155: NOT
23156: IFFALSE 23160
// exit ;
23158: GO 23747
// if GetBType ( depot ) = b_depot then
23160: LD_VAR 0 1
23164: PPUSH
23165: CALL_OW 266
23169: PUSH
23170: LD_INT 0
23172: EQUAL
23173: IFFALSE 23185
// dist := 28 else
23175: LD_ADDR_VAR 0 14
23179: PUSH
23180: LD_INT 28
23182: ST_TO_ADDR
23183: GO 23193
// dist := 36 ;
23185: LD_ADDR_VAR 0 14
23189: PUSH
23190: LD_INT 36
23192: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23193: LD_VAR 0 1
23197: PPUSH
23198: LD_VAR 0 3
23202: PPUSH
23203: LD_VAR 0 4
23207: PPUSH
23208: CALL_OW 297
23212: PUSH
23213: LD_VAR 0 14
23217: GREATER
23218: IFFALSE 23222
// exit ;
23220: GO 23747
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23222: LD_ADDR_VAR 0 12
23226: PUSH
23227: LD_VAR 0 2
23231: PPUSH
23232: LD_VAR 0 3
23236: PPUSH
23237: LD_VAR 0 4
23241: PPUSH
23242: LD_VAR 0 5
23246: PPUSH
23247: LD_VAR 0 1
23251: PPUSH
23252: CALL_OW 248
23256: PPUSH
23257: LD_INT 0
23259: PPUSH
23260: CALL 23752 0 6
23264: ST_TO_ADDR
// if not hexes then
23265: LD_VAR 0 12
23269: NOT
23270: IFFALSE 23274
// exit ;
23272: GO 23747
// hex := GetHexInfo ( x , y ) ;
23274: LD_ADDR_VAR 0 15
23278: PUSH
23279: LD_VAR 0 3
23283: PPUSH
23284: LD_VAR 0 4
23288: PPUSH
23289: CALL_OW 546
23293: ST_TO_ADDR
// if hex [ 1 ] then
23294: LD_VAR 0 15
23298: PUSH
23299: LD_INT 1
23301: ARRAY
23302: IFFALSE 23306
// exit ;
23304: GO 23747
// height := hex [ 2 ] ;
23306: LD_ADDR_VAR 0 13
23310: PUSH
23311: LD_VAR 0 15
23315: PUSH
23316: LD_INT 2
23318: ARRAY
23319: ST_TO_ADDR
// for i = 1 to hexes do
23320: LD_ADDR_VAR 0 7
23324: PUSH
23325: DOUBLE
23326: LD_INT 1
23328: DEC
23329: ST_TO_ADDR
23330: LD_VAR 0 12
23334: PUSH
23335: FOR_TO
23336: IFFALSE 23666
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23338: LD_VAR 0 12
23342: PUSH
23343: LD_VAR 0 7
23347: ARRAY
23348: PUSH
23349: LD_INT 1
23351: ARRAY
23352: PPUSH
23353: LD_VAR 0 12
23357: PUSH
23358: LD_VAR 0 7
23362: ARRAY
23363: PUSH
23364: LD_INT 2
23366: ARRAY
23367: PPUSH
23368: CALL_OW 488
23372: NOT
23373: PUSH
23374: LD_VAR 0 12
23378: PUSH
23379: LD_VAR 0 7
23383: ARRAY
23384: PUSH
23385: LD_INT 1
23387: ARRAY
23388: PPUSH
23389: LD_VAR 0 12
23393: PUSH
23394: LD_VAR 0 7
23398: ARRAY
23399: PUSH
23400: LD_INT 2
23402: ARRAY
23403: PPUSH
23404: CALL_OW 428
23408: PUSH
23409: LD_INT 0
23411: GREATER
23412: OR
23413: PUSH
23414: LD_VAR 0 12
23418: PUSH
23419: LD_VAR 0 7
23423: ARRAY
23424: PUSH
23425: LD_INT 1
23427: ARRAY
23428: PPUSH
23429: LD_VAR 0 12
23433: PUSH
23434: LD_VAR 0 7
23438: ARRAY
23439: PUSH
23440: LD_INT 2
23442: ARRAY
23443: PPUSH
23444: CALL_OW 351
23448: OR
23449: IFFALSE 23455
// exit ;
23451: POP
23452: POP
23453: GO 23747
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23455: LD_ADDR_VAR 0 8
23459: PUSH
23460: LD_VAR 0 12
23464: PUSH
23465: LD_VAR 0 7
23469: ARRAY
23470: PUSH
23471: LD_INT 1
23473: ARRAY
23474: PPUSH
23475: LD_VAR 0 12
23479: PUSH
23480: LD_VAR 0 7
23484: ARRAY
23485: PUSH
23486: LD_INT 2
23488: ARRAY
23489: PPUSH
23490: CALL_OW 546
23494: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23495: LD_VAR 0 8
23499: PUSH
23500: LD_INT 1
23502: ARRAY
23503: PUSH
23504: LD_VAR 0 8
23508: PUSH
23509: LD_INT 2
23511: ARRAY
23512: PUSH
23513: LD_VAR 0 13
23517: PUSH
23518: LD_INT 2
23520: PLUS
23521: GREATER
23522: OR
23523: PUSH
23524: LD_VAR 0 8
23528: PUSH
23529: LD_INT 2
23531: ARRAY
23532: PUSH
23533: LD_VAR 0 13
23537: PUSH
23538: LD_INT 2
23540: MINUS
23541: LESS
23542: OR
23543: PUSH
23544: LD_VAR 0 8
23548: PUSH
23549: LD_INT 3
23551: ARRAY
23552: PUSH
23553: LD_INT 0
23555: PUSH
23556: LD_INT 8
23558: PUSH
23559: LD_INT 9
23561: PUSH
23562: LD_INT 10
23564: PUSH
23565: LD_INT 11
23567: PUSH
23568: LD_INT 12
23570: PUSH
23571: LD_INT 13
23573: PUSH
23574: LD_INT 16
23576: PUSH
23577: LD_INT 17
23579: PUSH
23580: LD_INT 18
23582: PUSH
23583: LD_INT 19
23585: PUSH
23586: LD_INT 20
23588: PUSH
23589: LD_INT 21
23591: PUSH
23592: EMPTY
23593: LIST
23594: LIST
23595: LIST
23596: LIST
23597: LIST
23598: LIST
23599: LIST
23600: LIST
23601: LIST
23602: LIST
23603: LIST
23604: LIST
23605: LIST
23606: IN
23607: NOT
23608: OR
23609: PUSH
23610: LD_VAR 0 8
23614: PUSH
23615: LD_INT 5
23617: ARRAY
23618: NOT
23619: OR
23620: PUSH
23621: LD_VAR 0 8
23625: PUSH
23626: LD_INT 6
23628: ARRAY
23629: PUSH
23630: LD_INT 1
23632: PUSH
23633: LD_INT 2
23635: PUSH
23636: LD_INT 7
23638: PUSH
23639: LD_INT 9
23641: PUSH
23642: LD_INT 10
23644: PUSH
23645: LD_INT 11
23647: PUSH
23648: EMPTY
23649: LIST
23650: LIST
23651: LIST
23652: LIST
23653: LIST
23654: LIST
23655: IN
23656: NOT
23657: OR
23658: IFFALSE 23664
// exit ;
23660: POP
23661: POP
23662: GO 23747
// end ;
23664: GO 23335
23666: POP
23667: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23668: LD_VAR 0 9
23672: PPUSH
23673: LD_VAR 0 3
23677: PPUSH
23678: LD_VAR 0 4
23682: PPUSH
23683: LD_INT 20
23685: PPUSH
23686: CALL 15670 0 4
23690: PUSH
23691: LD_INT 4
23693: ARRAY
23694: IFFALSE 23698
// exit ;
23696: GO 23747
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23698: LD_VAR 0 2
23702: PUSH
23703: LD_INT 29
23705: PUSH
23706: LD_INT 30
23708: PUSH
23709: EMPTY
23710: LIST
23711: LIST
23712: IN
23713: PUSH
23714: LD_VAR 0 3
23718: PPUSH
23719: LD_VAR 0 4
23723: PPUSH
23724: LD_VAR 0 9
23728: PPUSH
23729: CALL_OW 440
23733: NOT
23734: AND
23735: IFFALSE 23739
// exit ;
23737: GO 23747
// result := true ;
23739: LD_ADDR_VAR 0 6
23743: PUSH
23744: LD_INT 1
23746: ST_TO_ADDR
// end ;
23747: LD_VAR 0 6
23751: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23752: LD_INT 0
23754: PPUSH
23755: PPUSH
23756: PPUSH
23757: PPUSH
23758: PPUSH
23759: PPUSH
23760: PPUSH
23761: PPUSH
23762: PPUSH
23763: PPUSH
23764: PPUSH
23765: PPUSH
23766: PPUSH
23767: PPUSH
23768: PPUSH
23769: PPUSH
23770: PPUSH
23771: PPUSH
23772: PPUSH
23773: PPUSH
23774: PPUSH
23775: PPUSH
23776: PPUSH
23777: PPUSH
23778: PPUSH
23779: PPUSH
23780: PPUSH
23781: PPUSH
23782: PPUSH
23783: PPUSH
23784: PPUSH
23785: PPUSH
23786: PPUSH
23787: PPUSH
23788: PPUSH
23789: PPUSH
23790: PPUSH
23791: PPUSH
23792: PPUSH
23793: PPUSH
23794: PPUSH
23795: PPUSH
23796: PPUSH
23797: PPUSH
23798: PPUSH
23799: PPUSH
23800: PPUSH
23801: PPUSH
23802: PPUSH
23803: PPUSH
23804: PPUSH
23805: PPUSH
23806: PPUSH
23807: PPUSH
23808: PPUSH
23809: PPUSH
23810: PPUSH
23811: PPUSH
// result = [ ] ;
23812: LD_ADDR_VAR 0 7
23816: PUSH
23817: EMPTY
23818: ST_TO_ADDR
// temp_list = [ ] ;
23819: LD_ADDR_VAR 0 9
23823: PUSH
23824: EMPTY
23825: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23826: LD_VAR 0 4
23830: PUSH
23831: LD_INT 0
23833: PUSH
23834: LD_INT 1
23836: PUSH
23837: LD_INT 2
23839: PUSH
23840: LD_INT 3
23842: PUSH
23843: LD_INT 4
23845: PUSH
23846: LD_INT 5
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: LIST
23853: LIST
23854: LIST
23855: LIST
23856: IN
23857: NOT
23858: PUSH
23859: LD_VAR 0 1
23863: PUSH
23864: LD_INT 0
23866: PUSH
23867: LD_INT 1
23869: PUSH
23870: EMPTY
23871: LIST
23872: LIST
23873: IN
23874: PUSH
23875: LD_VAR 0 5
23879: PUSH
23880: LD_INT 1
23882: PUSH
23883: LD_INT 2
23885: PUSH
23886: LD_INT 3
23888: PUSH
23889: EMPTY
23890: LIST
23891: LIST
23892: LIST
23893: IN
23894: NOT
23895: AND
23896: OR
23897: IFFALSE 23901
// exit ;
23899: GO 42292
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23901: LD_VAR 0 1
23905: PUSH
23906: LD_INT 6
23908: PUSH
23909: LD_INT 7
23911: PUSH
23912: LD_INT 8
23914: PUSH
23915: LD_INT 13
23917: PUSH
23918: LD_INT 12
23920: PUSH
23921: LD_INT 15
23923: PUSH
23924: LD_INT 11
23926: PUSH
23927: LD_INT 14
23929: PUSH
23930: LD_INT 10
23932: PUSH
23933: EMPTY
23934: LIST
23935: LIST
23936: LIST
23937: LIST
23938: LIST
23939: LIST
23940: LIST
23941: LIST
23942: LIST
23943: IN
23944: IFFALSE 23954
// btype = b_lab ;
23946: LD_ADDR_VAR 0 1
23950: PUSH
23951: LD_INT 6
23953: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23954: LD_VAR 0 6
23958: PUSH
23959: LD_INT 0
23961: PUSH
23962: LD_INT 1
23964: PUSH
23965: LD_INT 2
23967: PUSH
23968: EMPTY
23969: LIST
23970: LIST
23971: LIST
23972: IN
23973: NOT
23974: PUSH
23975: LD_VAR 0 1
23979: PUSH
23980: LD_INT 0
23982: PUSH
23983: LD_INT 1
23985: PUSH
23986: LD_INT 2
23988: PUSH
23989: LD_INT 3
23991: PUSH
23992: LD_INT 6
23994: PUSH
23995: LD_INT 36
23997: PUSH
23998: LD_INT 4
24000: PUSH
24001: LD_INT 5
24003: PUSH
24004: LD_INT 31
24006: PUSH
24007: LD_INT 32
24009: PUSH
24010: LD_INT 33
24012: PUSH
24013: EMPTY
24014: LIST
24015: LIST
24016: LIST
24017: LIST
24018: LIST
24019: LIST
24020: LIST
24021: LIST
24022: LIST
24023: LIST
24024: LIST
24025: IN
24026: NOT
24027: PUSH
24028: LD_VAR 0 6
24032: PUSH
24033: LD_INT 1
24035: EQUAL
24036: AND
24037: OR
24038: PUSH
24039: LD_VAR 0 1
24043: PUSH
24044: LD_INT 2
24046: PUSH
24047: LD_INT 3
24049: PUSH
24050: EMPTY
24051: LIST
24052: LIST
24053: IN
24054: NOT
24055: PUSH
24056: LD_VAR 0 6
24060: PUSH
24061: LD_INT 2
24063: EQUAL
24064: AND
24065: OR
24066: IFFALSE 24076
// mode = 0 ;
24068: LD_ADDR_VAR 0 6
24072: PUSH
24073: LD_INT 0
24075: ST_TO_ADDR
// case mode of 0 :
24076: LD_VAR 0 6
24080: PUSH
24081: LD_INT 0
24083: DOUBLE
24084: EQUAL
24085: IFTRUE 24089
24087: GO 35542
24089: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24090: LD_ADDR_VAR 0 11
24094: PUSH
24095: LD_INT 0
24097: PUSH
24098: LD_INT 0
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: PUSH
24105: LD_INT 0
24107: PUSH
24108: LD_INT 1
24110: NEG
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: PUSH
24116: LD_INT 1
24118: PUSH
24119: LD_INT 0
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: PUSH
24126: LD_INT 1
24128: PUSH
24129: LD_INT 1
24131: PUSH
24132: EMPTY
24133: LIST
24134: LIST
24135: PUSH
24136: LD_INT 0
24138: PUSH
24139: LD_INT 1
24141: PUSH
24142: EMPTY
24143: LIST
24144: LIST
24145: PUSH
24146: LD_INT 1
24148: NEG
24149: PUSH
24150: LD_INT 0
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: PUSH
24157: LD_INT 1
24159: NEG
24160: PUSH
24161: LD_INT 1
24163: NEG
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: PUSH
24169: LD_INT 1
24171: NEG
24172: PUSH
24173: LD_INT 2
24175: NEG
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: PUSH
24181: LD_INT 0
24183: PUSH
24184: LD_INT 2
24186: NEG
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PUSH
24192: LD_INT 1
24194: PUSH
24195: LD_INT 1
24197: NEG
24198: PUSH
24199: EMPTY
24200: LIST
24201: LIST
24202: PUSH
24203: LD_INT 1
24205: PUSH
24206: LD_INT 2
24208: PUSH
24209: EMPTY
24210: LIST
24211: LIST
24212: PUSH
24213: LD_INT 0
24215: PUSH
24216: LD_INT 2
24218: PUSH
24219: EMPTY
24220: LIST
24221: LIST
24222: PUSH
24223: LD_INT 1
24225: NEG
24226: PUSH
24227: LD_INT 1
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: PUSH
24234: LD_INT 1
24236: PUSH
24237: LD_INT 3
24239: PUSH
24240: EMPTY
24241: LIST
24242: LIST
24243: PUSH
24244: LD_INT 0
24246: PUSH
24247: LD_INT 3
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: PUSH
24254: LD_INT 1
24256: NEG
24257: PUSH
24258: LD_INT 2
24260: PUSH
24261: EMPTY
24262: LIST
24263: LIST
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: LIST
24269: LIST
24270: LIST
24271: LIST
24272: LIST
24273: LIST
24274: LIST
24275: LIST
24276: LIST
24277: LIST
24278: LIST
24279: LIST
24280: LIST
24281: LIST
24282: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24283: LD_ADDR_VAR 0 12
24287: PUSH
24288: LD_INT 0
24290: PUSH
24291: LD_INT 0
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: PUSH
24298: LD_INT 0
24300: PUSH
24301: LD_INT 1
24303: NEG
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: PUSH
24309: LD_INT 1
24311: PUSH
24312: LD_INT 0
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PUSH
24319: LD_INT 1
24321: PUSH
24322: LD_INT 1
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: LD_INT 0
24331: PUSH
24332: LD_INT 1
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: LD_INT 1
24341: NEG
24342: PUSH
24343: LD_INT 0
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: PUSH
24350: LD_INT 1
24352: NEG
24353: PUSH
24354: LD_INT 1
24356: NEG
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: PUSH
24362: LD_INT 1
24364: PUSH
24365: LD_INT 1
24367: NEG
24368: PUSH
24369: EMPTY
24370: LIST
24371: LIST
24372: PUSH
24373: LD_INT 2
24375: PUSH
24376: LD_INT 0
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: PUSH
24383: LD_INT 2
24385: PUSH
24386: LD_INT 1
24388: PUSH
24389: EMPTY
24390: LIST
24391: LIST
24392: PUSH
24393: LD_INT 1
24395: NEG
24396: PUSH
24397: LD_INT 1
24399: PUSH
24400: EMPTY
24401: LIST
24402: LIST
24403: PUSH
24404: LD_INT 2
24406: NEG
24407: PUSH
24408: LD_INT 0
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: PUSH
24415: LD_INT 2
24417: NEG
24418: PUSH
24419: LD_INT 1
24421: NEG
24422: PUSH
24423: EMPTY
24424: LIST
24425: LIST
24426: PUSH
24427: LD_INT 2
24429: NEG
24430: PUSH
24431: LD_INT 1
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: PUSH
24438: LD_INT 3
24440: NEG
24441: PUSH
24442: LD_INT 0
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: PUSH
24449: LD_INT 3
24451: NEG
24452: PUSH
24453: LD_INT 1
24455: NEG
24456: PUSH
24457: EMPTY
24458: LIST
24459: LIST
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: LIST
24465: LIST
24466: LIST
24467: LIST
24468: LIST
24469: LIST
24470: LIST
24471: LIST
24472: LIST
24473: LIST
24474: LIST
24475: LIST
24476: LIST
24477: LIST
24478: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24479: LD_ADDR_VAR 0 13
24483: PUSH
24484: LD_INT 0
24486: PUSH
24487: LD_INT 0
24489: PUSH
24490: EMPTY
24491: LIST
24492: LIST
24493: PUSH
24494: LD_INT 0
24496: PUSH
24497: LD_INT 1
24499: NEG
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: PUSH
24505: LD_INT 1
24507: PUSH
24508: LD_INT 0
24510: PUSH
24511: EMPTY
24512: LIST
24513: LIST
24514: PUSH
24515: LD_INT 1
24517: PUSH
24518: LD_INT 1
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PUSH
24525: LD_INT 0
24527: PUSH
24528: LD_INT 1
24530: PUSH
24531: EMPTY
24532: LIST
24533: LIST
24534: PUSH
24535: LD_INT 1
24537: NEG
24538: PUSH
24539: LD_INT 0
24541: PUSH
24542: EMPTY
24543: LIST
24544: LIST
24545: PUSH
24546: LD_INT 1
24548: NEG
24549: PUSH
24550: LD_INT 1
24552: NEG
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: PUSH
24558: LD_INT 1
24560: NEG
24561: PUSH
24562: LD_INT 2
24564: NEG
24565: PUSH
24566: EMPTY
24567: LIST
24568: LIST
24569: PUSH
24570: LD_INT 2
24572: PUSH
24573: LD_INT 1
24575: PUSH
24576: EMPTY
24577: LIST
24578: LIST
24579: PUSH
24580: LD_INT 2
24582: PUSH
24583: LD_INT 2
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: PUSH
24590: LD_INT 1
24592: PUSH
24593: LD_INT 2
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: LD_INT 2
24602: NEG
24603: PUSH
24604: LD_INT 1
24606: NEG
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: PUSH
24612: LD_INT 2
24614: NEG
24615: PUSH
24616: LD_INT 2
24618: NEG
24619: PUSH
24620: EMPTY
24621: LIST
24622: LIST
24623: PUSH
24624: LD_INT 2
24626: NEG
24627: PUSH
24628: LD_INT 3
24630: NEG
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: LD_INT 3
24638: NEG
24639: PUSH
24640: LD_INT 2
24642: NEG
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PUSH
24648: LD_INT 3
24650: NEG
24651: PUSH
24652: LD_INT 3
24654: NEG
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: LIST
24664: LIST
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: LIST
24670: LIST
24671: LIST
24672: LIST
24673: LIST
24674: LIST
24675: LIST
24676: LIST
24677: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24678: LD_ADDR_VAR 0 14
24682: PUSH
24683: LD_INT 0
24685: PUSH
24686: LD_INT 0
24688: PUSH
24689: EMPTY
24690: LIST
24691: LIST
24692: PUSH
24693: LD_INT 0
24695: PUSH
24696: LD_INT 1
24698: NEG
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: PUSH
24704: LD_INT 1
24706: PUSH
24707: LD_INT 0
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: PUSH
24714: LD_INT 1
24716: PUSH
24717: LD_INT 1
24719: PUSH
24720: EMPTY
24721: LIST
24722: LIST
24723: PUSH
24724: LD_INT 0
24726: PUSH
24727: LD_INT 1
24729: PUSH
24730: EMPTY
24731: LIST
24732: LIST
24733: PUSH
24734: LD_INT 1
24736: NEG
24737: PUSH
24738: LD_INT 0
24740: PUSH
24741: EMPTY
24742: LIST
24743: LIST
24744: PUSH
24745: LD_INT 1
24747: NEG
24748: PUSH
24749: LD_INT 1
24751: NEG
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: PUSH
24757: LD_INT 1
24759: NEG
24760: PUSH
24761: LD_INT 2
24763: NEG
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: PUSH
24769: LD_INT 0
24771: PUSH
24772: LD_INT 2
24774: NEG
24775: PUSH
24776: EMPTY
24777: LIST
24778: LIST
24779: PUSH
24780: LD_INT 1
24782: PUSH
24783: LD_INT 1
24785: NEG
24786: PUSH
24787: EMPTY
24788: LIST
24789: LIST
24790: PUSH
24791: LD_INT 1
24793: PUSH
24794: LD_INT 2
24796: PUSH
24797: EMPTY
24798: LIST
24799: LIST
24800: PUSH
24801: LD_INT 0
24803: PUSH
24804: LD_INT 2
24806: PUSH
24807: EMPTY
24808: LIST
24809: LIST
24810: PUSH
24811: LD_INT 1
24813: NEG
24814: PUSH
24815: LD_INT 1
24817: PUSH
24818: EMPTY
24819: LIST
24820: LIST
24821: PUSH
24822: LD_INT 1
24824: NEG
24825: PUSH
24826: LD_INT 3
24828: NEG
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: PUSH
24834: LD_INT 0
24836: PUSH
24837: LD_INT 3
24839: NEG
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: PUSH
24845: LD_INT 1
24847: PUSH
24848: LD_INT 2
24850: NEG
24851: PUSH
24852: EMPTY
24853: LIST
24854: LIST
24855: PUSH
24856: EMPTY
24857: LIST
24858: LIST
24859: LIST
24860: LIST
24861: LIST
24862: LIST
24863: LIST
24864: LIST
24865: LIST
24866: LIST
24867: LIST
24868: LIST
24869: LIST
24870: LIST
24871: LIST
24872: LIST
24873: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24874: LD_ADDR_VAR 0 15
24878: PUSH
24879: LD_INT 0
24881: PUSH
24882: LD_INT 0
24884: PUSH
24885: EMPTY
24886: LIST
24887: LIST
24888: PUSH
24889: LD_INT 0
24891: PUSH
24892: LD_INT 1
24894: NEG
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PUSH
24900: LD_INT 1
24902: PUSH
24903: LD_INT 0
24905: PUSH
24906: EMPTY
24907: LIST
24908: LIST
24909: PUSH
24910: LD_INT 1
24912: PUSH
24913: LD_INT 1
24915: PUSH
24916: EMPTY
24917: LIST
24918: LIST
24919: PUSH
24920: LD_INT 0
24922: PUSH
24923: LD_INT 1
24925: PUSH
24926: EMPTY
24927: LIST
24928: LIST
24929: PUSH
24930: LD_INT 1
24932: NEG
24933: PUSH
24934: LD_INT 0
24936: PUSH
24937: EMPTY
24938: LIST
24939: LIST
24940: PUSH
24941: LD_INT 1
24943: NEG
24944: PUSH
24945: LD_INT 1
24947: NEG
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: PUSH
24953: LD_INT 1
24955: PUSH
24956: LD_INT 1
24958: NEG
24959: PUSH
24960: EMPTY
24961: LIST
24962: LIST
24963: PUSH
24964: LD_INT 2
24966: PUSH
24967: LD_INT 0
24969: PUSH
24970: EMPTY
24971: LIST
24972: LIST
24973: PUSH
24974: LD_INT 2
24976: PUSH
24977: LD_INT 1
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: PUSH
24984: LD_INT 1
24986: NEG
24987: PUSH
24988: LD_INT 1
24990: PUSH
24991: EMPTY
24992: LIST
24993: LIST
24994: PUSH
24995: LD_INT 2
24997: NEG
24998: PUSH
24999: LD_INT 0
25001: PUSH
25002: EMPTY
25003: LIST
25004: LIST
25005: PUSH
25006: LD_INT 2
25008: NEG
25009: PUSH
25010: LD_INT 1
25012: NEG
25013: PUSH
25014: EMPTY
25015: LIST
25016: LIST
25017: PUSH
25018: LD_INT 2
25020: PUSH
25021: LD_INT 1
25023: NEG
25024: PUSH
25025: EMPTY
25026: LIST
25027: LIST
25028: PUSH
25029: LD_INT 3
25031: PUSH
25032: LD_INT 0
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 3
25041: PUSH
25042: LD_INT 1
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: EMPTY
25050: LIST
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: LIST
25056: LIST
25057: LIST
25058: LIST
25059: LIST
25060: LIST
25061: LIST
25062: LIST
25063: LIST
25064: LIST
25065: LIST
25066: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25067: LD_ADDR_VAR 0 16
25071: PUSH
25072: LD_INT 0
25074: PUSH
25075: LD_INT 0
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 0
25084: PUSH
25085: LD_INT 1
25087: NEG
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: PUSH
25093: LD_INT 1
25095: PUSH
25096: LD_INT 0
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PUSH
25103: LD_INT 1
25105: PUSH
25106: LD_INT 1
25108: PUSH
25109: EMPTY
25110: LIST
25111: LIST
25112: PUSH
25113: LD_INT 0
25115: PUSH
25116: LD_INT 1
25118: PUSH
25119: EMPTY
25120: LIST
25121: LIST
25122: PUSH
25123: LD_INT 1
25125: NEG
25126: PUSH
25127: LD_INT 0
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: PUSH
25134: LD_INT 1
25136: NEG
25137: PUSH
25138: LD_INT 1
25140: NEG
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PUSH
25146: LD_INT 1
25148: NEG
25149: PUSH
25150: LD_INT 2
25152: NEG
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: LD_INT 2
25160: PUSH
25161: LD_INT 1
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: PUSH
25168: LD_INT 2
25170: PUSH
25171: LD_INT 2
25173: PUSH
25174: EMPTY
25175: LIST
25176: LIST
25177: PUSH
25178: LD_INT 1
25180: PUSH
25181: LD_INT 2
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PUSH
25188: LD_INT 2
25190: NEG
25191: PUSH
25192: LD_INT 1
25194: NEG
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: LD_INT 2
25202: NEG
25203: PUSH
25204: LD_INT 2
25206: NEG
25207: PUSH
25208: EMPTY
25209: LIST
25210: LIST
25211: PUSH
25212: LD_INT 3
25214: PUSH
25215: LD_INT 2
25217: PUSH
25218: EMPTY
25219: LIST
25220: LIST
25221: PUSH
25222: LD_INT 3
25224: PUSH
25225: LD_INT 3
25227: PUSH
25228: EMPTY
25229: LIST
25230: LIST
25231: PUSH
25232: LD_INT 2
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: LIST
25254: LIST
25255: LIST
25256: LIST
25257: LIST
25258: LIST
25259: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25260: LD_ADDR_VAR 0 17
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: PUSH
25275: LD_INT 0
25277: PUSH
25278: LD_INT 1
25280: NEG
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: PUSH
25286: LD_INT 1
25288: PUSH
25289: LD_INT 0
25291: PUSH
25292: EMPTY
25293: LIST
25294: LIST
25295: PUSH
25296: LD_INT 1
25298: PUSH
25299: LD_INT 1
25301: PUSH
25302: EMPTY
25303: LIST
25304: LIST
25305: PUSH
25306: LD_INT 0
25308: PUSH
25309: LD_INT 1
25311: PUSH
25312: EMPTY
25313: LIST
25314: LIST
25315: PUSH
25316: LD_INT 1
25318: NEG
25319: PUSH
25320: LD_INT 0
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: PUSH
25327: LD_INT 1
25329: NEG
25330: PUSH
25331: LD_INT 1
25333: NEG
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 1
25341: NEG
25342: PUSH
25343: LD_INT 2
25345: NEG
25346: PUSH
25347: EMPTY
25348: LIST
25349: LIST
25350: PUSH
25351: LD_INT 0
25353: PUSH
25354: LD_INT 2
25356: NEG
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: LD_INT 1
25364: PUSH
25365: LD_INT 1
25367: NEG
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: PUSH
25373: LD_INT 2
25375: PUSH
25376: LD_INT 0
25378: PUSH
25379: EMPTY
25380: LIST
25381: LIST
25382: PUSH
25383: LD_INT 2
25385: PUSH
25386: LD_INT 1
25388: PUSH
25389: EMPTY
25390: LIST
25391: LIST
25392: PUSH
25393: LD_INT 2
25395: PUSH
25396: LD_INT 2
25398: PUSH
25399: EMPTY
25400: LIST
25401: LIST
25402: PUSH
25403: LD_INT 1
25405: PUSH
25406: LD_INT 2
25408: PUSH
25409: EMPTY
25410: LIST
25411: LIST
25412: PUSH
25413: LD_INT 0
25415: PUSH
25416: LD_INT 2
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PUSH
25423: LD_INT 1
25425: NEG
25426: PUSH
25427: LD_INT 1
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: PUSH
25434: LD_INT 2
25436: NEG
25437: PUSH
25438: LD_INT 0
25440: PUSH
25441: EMPTY
25442: LIST
25443: LIST
25444: PUSH
25445: LD_INT 2
25447: NEG
25448: PUSH
25449: LD_INT 1
25451: NEG
25452: PUSH
25453: EMPTY
25454: LIST
25455: LIST
25456: PUSH
25457: LD_INT 2
25459: NEG
25460: PUSH
25461: LD_INT 2
25463: NEG
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: LIST
25476: LIST
25477: LIST
25478: LIST
25479: LIST
25480: LIST
25481: LIST
25482: LIST
25483: LIST
25484: LIST
25485: LIST
25486: LIST
25487: LIST
25488: LIST
25489: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25490: LD_ADDR_VAR 0 18
25494: PUSH
25495: LD_INT 0
25497: PUSH
25498: LD_INT 0
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: LD_INT 1
25510: NEG
25511: PUSH
25512: EMPTY
25513: LIST
25514: LIST
25515: PUSH
25516: LD_INT 1
25518: PUSH
25519: LD_INT 0
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PUSH
25526: LD_INT 1
25528: PUSH
25529: LD_INT 1
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: LD_INT 1
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 1
25548: NEG
25549: PUSH
25550: LD_INT 0
25552: PUSH
25553: EMPTY
25554: LIST
25555: LIST
25556: PUSH
25557: LD_INT 1
25559: NEG
25560: PUSH
25561: LD_INT 1
25563: NEG
25564: PUSH
25565: EMPTY
25566: LIST
25567: LIST
25568: PUSH
25569: LD_INT 1
25571: NEG
25572: PUSH
25573: LD_INT 2
25575: NEG
25576: PUSH
25577: EMPTY
25578: LIST
25579: LIST
25580: PUSH
25581: LD_INT 0
25583: PUSH
25584: LD_INT 2
25586: NEG
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: PUSH
25592: LD_INT 1
25594: PUSH
25595: LD_INT 1
25597: NEG
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: LD_INT 2
25605: PUSH
25606: LD_INT 0
25608: PUSH
25609: EMPTY
25610: LIST
25611: LIST
25612: PUSH
25613: LD_INT 2
25615: PUSH
25616: LD_INT 1
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 2
25625: PUSH
25626: LD_INT 2
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: LD_INT 1
25635: PUSH
25636: LD_INT 2
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 0
25645: PUSH
25646: LD_INT 2
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 1
25655: NEG
25656: PUSH
25657: LD_INT 1
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 2
25666: NEG
25667: PUSH
25668: LD_INT 0
25670: PUSH
25671: EMPTY
25672: LIST
25673: LIST
25674: PUSH
25675: LD_INT 2
25677: NEG
25678: PUSH
25679: LD_INT 1
25681: NEG
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: LD_INT 2
25689: NEG
25690: PUSH
25691: LD_INT 2
25693: NEG
25694: PUSH
25695: EMPTY
25696: LIST
25697: LIST
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: LIST
25703: LIST
25704: LIST
25705: LIST
25706: LIST
25707: LIST
25708: LIST
25709: LIST
25710: LIST
25711: LIST
25712: LIST
25713: LIST
25714: LIST
25715: LIST
25716: LIST
25717: LIST
25718: LIST
25719: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25720: LD_ADDR_VAR 0 19
25724: PUSH
25725: LD_INT 0
25727: PUSH
25728: LD_INT 0
25730: PUSH
25731: EMPTY
25732: LIST
25733: LIST
25734: PUSH
25735: LD_INT 0
25737: PUSH
25738: LD_INT 1
25740: NEG
25741: PUSH
25742: EMPTY
25743: LIST
25744: LIST
25745: PUSH
25746: LD_INT 1
25748: PUSH
25749: LD_INT 0
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 1
25758: PUSH
25759: LD_INT 1
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: LD_INT 0
25768: PUSH
25769: LD_INT 1
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: LD_INT 1
25778: NEG
25779: PUSH
25780: LD_INT 0
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PUSH
25787: LD_INT 1
25789: NEG
25790: PUSH
25791: LD_INT 1
25793: NEG
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: PUSH
25799: LD_INT 1
25801: NEG
25802: PUSH
25803: LD_INT 2
25805: NEG
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: PUSH
25811: LD_INT 0
25813: PUSH
25814: LD_INT 2
25816: NEG
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: LD_INT 1
25824: PUSH
25825: LD_INT 1
25827: NEG
25828: PUSH
25829: EMPTY
25830: LIST
25831: LIST
25832: PUSH
25833: LD_INT 2
25835: PUSH
25836: LD_INT 0
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: PUSH
25843: LD_INT 2
25845: PUSH
25846: LD_INT 1
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 2
25855: PUSH
25856: LD_INT 2
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: LD_INT 1
25865: PUSH
25866: LD_INT 2
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 0
25875: PUSH
25876: LD_INT 2
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 1
25885: NEG
25886: PUSH
25887: LD_INT 1
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: LD_INT 2
25896: NEG
25897: PUSH
25898: LD_INT 0
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: LD_INT 2
25907: NEG
25908: PUSH
25909: LD_INT 1
25911: NEG
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 2
25919: NEG
25920: PUSH
25921: LD_INT 2
25923: NEG
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: PUSH
25929: EMPTY
25930: LIST
25931: LIST
25932: LIST
25933: LIST
25934: LIST
25935: LIST
25936: LIST
25937: LIST
25938: LIST
25939: LIST
25940: LIST
25941: LIST
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: LIST
25947: LIST
25948: LIST
25949: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25950: LD_ADDR_VAR 0 20
25954: PUSH
25955: LD_INT 0
25957: PUSH
25958: LD_INT 0
25960: PUSH
25961: EMPTY
25962: LIST
25963: LIST
25964: PUSH
25965: LD_INT 0
25967: PUSH
25968: LD_INT 1
25970: NEG
25971: PUSH
25972: EMPTY
25973: LIST
25974: LIST
25975: PUSH
25976: LD_INT 1
25978: PUSH
25979: LD_INT 0
25981: PUSH
25982: EMPTY
25983: LIST
25984: LIST
25985: PUSH
25986: LD_INT 1
25988: PUSH
25989: LD_INT 1
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: PUSH
25996: LD_INT 0
25998: PUSH
25999: LD_INT 1
26001: PUSH
26002: EMPTY
26003: LIST
26004: LIST
26005: PUSH
26006: LD_INT 1
26008: NEG
26009: PUSH
26010: LD_INT 0
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: LD_INT 1
26019: NEG
26020: PUSH
26021: LD_INT 1
26023: NEG
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: LD_INT 1
26031: NEG
26032: PUSH
26033: LD_INT 2
26035: NEG
26036: PUSH
26037: EMPTY
26038: LIST
26039: LIST
26040: PUSH
26041: LD_INT 0
26043: PUSH
26044: LD_INT 2
26046: NEG
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: PUSH
26052: LD_INT 1
26054: PUSH
26055: LD_INT 1
26057: NEG
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: LD_INT 2
26065: PUSH
26066: LD_INT 0
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PUSH
26073: LD_INT 2
26075: PUSH
26076: LD_INT 1
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: LD_INT 2
26085: PUSH
26086: LD_INT 2
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: LD_INT 1
26095: PUSH
26096: LD_INT 2
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 0
26105: PUSH
26106: LD_INT 2
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 1
26115: NEG
26116: PUSH
26117: LD_INT 1
26119: PUSH
26120: EMPTY
26121: LIST
26122: LIST
26123: PUSH
26124: LD_INT 2
26126: NEG
26127: PUSH
26128: LD_INT 0
26130: PUSH
26131: EMPTY
26132: LIST
26133: LIST
26134: PUSH
26135: LD_INT 2
26137: NEG
26138: PUSH
26139: LD_INT 1
26141: NEG
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: PUSH
26147: LD_INT 2
26149: NEG
26150: PUSH
26151: LD_INT 2
26153: NEG
26154: PUSH
26155: EMPTY
26156: LIST
26157: LIST
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: LIST
26163: LIST
26164: LIST
26165: LIST
26166: LIST
26167: LIST
26168: LIST
26169: LIST
26170: LIST
26171: LIST
26172: LIST
26173: LIST
26174: LIST
26175: LIST
26176: LIST
26177: LIST
26178: LIST
26179: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26180: LD_ADDR_VAR 0 21
26184: PUSH
26185: LD_INT 0
26187: PUSH
26188: LD_INT 0
26190: PUSH
26191: EMPTY
26192: LIST
26193: LIST
26194: PUSH
26195: LD_INT 0
26197: PUSH
26198: LD_INT 1
26200: NEG
26201: PUSH
26202: EMPTY
26203: LIST
26204: LIST
26205: PUSH
26206: LD_INT 1
26208: PUSH
26209: LD_INT 0
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 1
26218: PUSH
26219: LD_INT 1
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: PUSH
26226: LD_INT 0
26228: PUSH
26229: LD_INT 1
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: PUSH
26236: LD_INT 1
26238: NEG
26239: PUSH
26240: LD_INT 0
26242: PUSH
26243: EMPTY
26244: LIST
26245: LIST
26246: PUSH
26247: LD_INT 1
26249: NEG
26250: PUSH
26251: LD_INT 1
26253: NEG
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: PUSH
26259: LD_INT 1
26261: NEG
26262: PUSH
26263: LD_INT 2
26265: NEG
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 0
26273: PUSH
26274: LD_INT 2
26276: NEG
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: PUSH
26282: LD_INT 1
26284: PUSH
26285: LD_INT 1
26287: NEG
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: PUSH
26293: LD_INT 2
26295: PUSH
26296: LD_INT 0
26298: PUSH
26299: EMPTY
26300: LIST
26301: LIST
26302: PUSH
26303: LD_INT 2
26305: PUSH
26306: LD_INT 1
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: PUSH
26313: LD_INT 2
26315: PUSH
26316: LD_INT 2
26318: PUSH
26319: EMPTY
26320: LIST
26321: LIST
26322: PUSH
26323: LD_INT 1
26325: PUSH
26326: LD_INT 2
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 0
26335: PUSH
26336: LD_INT 2
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 1
26345: NEG
26346: PUSH
26347: LD_INT 1
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 2
26356: NEG
26357: PUSH
26358: LD_INT 0
26360: PUSH
26361: EMPTY
26362: LIST
26363: LIST
26364: PUSH
26365: LD_INT 2
26367: NEG
26368: PUSH
26369: LD_INT 1
26371: NEG
26372: PUSH
26373: EMPTY
26374: LIST
26375: LIST
26376: PUSH
26377: LD_INT 2
26379: NEG
26380: PUSH
26381: LD_INT 2
26383: NEG
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: LIST
26393: LIST
26394: LIST
26395: LIST
26396: LIST
26397: LIST
26398: LIST
26399: LIST
26400: LIST
26401: LIST
26402: LIST
26403: LIST
26404: LIST
26405: LIST
26406: LIST
26407: LIST
26408: LIST
26409: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26410: LD_ADDR_VAR 0 22
26414: PUSH
26415: LD_INT 0
26417: PUSH
26418: LD_INT 0
26420: PUSH
26421: EMPTY
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 0
26427: PUSH
26428: LD_INT 1
26430: NEG
26431: PUSH
26432: EMPTY
26433: LIST
26434: LIST
26435: PUSH
26436: LD_INT 1
26438: PUSH
26439: LD_INT 0
26441: PUSH
26442: EMPTY
26443: LIST
26444: LIST
26445: PUSH
26446: LD_INT 1
26448: PUSH
26449: LD_INT 1
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: PUSH
26456: LD_INT 0
26458: PUSH
26459: LD_INT 1
26461: PUSH
26462: EMPTY
26463: LIST
26464: LIST
26465: PUSH
26466: LD_INT 1
26468: NEG
26469: PUSH
26470: LD_INT 0
26472: PUSH
26473: EMPTY
26474: LIST
26475: LIST
26476: PUSH
26477: LD_INT 1
26479: NEG
26480: PUSH
26481: LD_INT 1
26483: NEG
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: PUSH
26489: LD_INT 1
26491: NEG
26492: PUSH
26493: LD_INT 2
26495: NEG
26496: PUSH
26497: EMPTY
26498: LIST
26499: LIST
26500: PUSH
26501: LD_INT 0
26503: PUSH
26504: LD_INT 2
26506: NEG
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PUSH
26512: LD_INT 1
26514: PUSH
26515: LD_INT 1
26517: NEG
26518: PUSH
26519: EMPTY
26520: LIST
26521: LIST
26522: PUSH
26523: LD_INT 2
26525: PUSH
26526: LD_INT 0
26528: PUSH
26529: EMPTY
26530: LIST
26531: LIST
26532: PUSH
26533: LD_INT 2
26535: PUSH
26536: LD_INT 1
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 2
26545: PUSH
26546: LD_INT 2
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PUSH
26553: LD_INT 1
26555: PUSH
26556: LD_INT 2
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 0
26565: PUSH
26566: LD_INT 2
26568: PUSH
26569: EMPTY
26570: LIST
26571: LIST
26572: PUSH
26573: LD_INT 1
26575: NEG
26576: PUSH
26577: LD_INT 1
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: LD_INT 2
26586: NEG
26587: PUSH
26588: LD_INT 0
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 2
26597: NEG
26598: PUSH
26599: LD_INT 1
26601: NEG
26602: PUSH
26603: EMPTY
26604: LIST
26605: LIST
26606: PUSH
26607: LD_INT 2
26609: NEG
26610: PUSH
26611: LD_INT 2
26613: NEG
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: LIST
26623: LIST
26624: LIST
26625: LIST
26626: LIST
26627: LIST
26628: LIST
26629: LIST
26630: LIST
26631: LIST
26632: LIST
26633: LIST
26634: LIST
26635: LIST
26636: LIST
26637: LIST
26638: LIST
26639: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26640: LD_ADDR_VAR 0 23
26644: PUSH
26645: LD_INT 0
26647: PUSH
26648: LD_INT 0
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: PUSH
26655: LD_INT 0
26657: PUSH
26658: LD_INT 1
26660: NEG
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: PUSH
26666: LD_INT 1
26668: PUSH
26669: LD_INT 0
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: PUSH
26676: LD_INT 1
26678: PUSH
26679: LD_INT 1
26681: PUSH
26682: EMPTY
26683: LIST
26684: LIST
26685: PUSH
26686: LD_INT 0
26688: PUSH
26689: LD_INT 1
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 1
26698: NEG
26699: PUSH
26700: LD_INT 0
26702: PUSH
26703: EMPTY
26704: LIST
26705: LIST
26706: PUSH
26707: LD_INT 1
26709: NEG
26710: PUSH
26711: LD_INT 1
26713: NEG
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 1
26721: NEG
26722: PUSH
26723: LD_INT 2
26725: NEG
26726: PUSH
26727: EMPTY
26728: LIST
26729: LIST
26730: PUSH
26731: LD_INT 0
26733: PUSH
26734: LD_INT 2
26736: NEG
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: PUSH
26742: LD_INT 1
26744: PUSH
26745: LD_INT 1
26747: NEG
26748: PUSH
26749: EMPTY
26750: LIST
26751: LIST
26752: PUSH
26753: LD_INT 2
26755: PUSH
26756: LD_INT 0
26758: PUSH
26759: EMPTY
26760: LIST
26761: LIST
26762: PUSH
26763: LD_INT 2
26765: PUSH
26766: LD_INT 1
26768: PUSH
26769: EMPTY
26770: LIST
26771: LIST
26772: PUSH
26773: LD_INT 2
26775: PUSH
26776: LD_INT 2
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 1
26785: PUSH
26786: LD_INT 2
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PUSH
26793: LD_INT 0
26795: PUSH
26796: LD_INT 2
26798: PUSH
26799: EMPTY
26800: LIST
26801: LIST
26802: PUSH
26803: LD_INT 1
26805: NEG
26806: PUSH
26807: LD_INT 1
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: PUSH
26814: LD_INT 2
26816: NEG
26817: PUSH
26818: LD_INT 0
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: PUSH
26825: LD_INT 2
26827: NEG
26828: PUSH
26829: LD_INT 1
26831: NEG
26832: PUSH
26833: EMPTY
26834: LIST
26835: LIST
26836: PUSH
26837: LD_INT 2
26839: NEG
26840: PUSH
26841: LD_INT 2
26843: NEG
26844: PUSH
26845: EMPTY
26846: LIST
26847: LIST
26848: PUSH
26849: LD_INT 2
26851: NEG
26852: PUSH
26853: LD_INT 3
26855: NEG
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: PUSH
26861: LD_INT 1
26863: NEG
26864: PUSH
26865: LD_INT 3
26867: NEG
26868: PUSH
26869: EMPTY
26870: LIST
26871: LIST
26872: PUSH
26873: LD_INT 1
26875: PUSH
26876: LD_INT 2
26878: NEG
26879: PUSH
26880: EMPTY
26881: LIST
26882: LIST
26883: PUSH
26884: LD_INT 2
26886: PUSH
26887: LD_INT 1
26889: NEG
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: LIST
26899: LIST
26900: LIST
26901: LIST
26902: LIST
26903: LIST
26904: LIST
26905: LIST
26906: LIST
26907: LIST
26908: LIST
26909: LIST
26910: LIST
26911: LIST
26912: LIST
26913: LIST
26914: LIST
26915: LIST
26916: LIST
26917: LIST
26918: LIST
26919: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26920: LD_ADDR_VAR 0 24
26924: PUSH
26925: LD_INT 0
26927: PUSH
26928: LD_INT 0
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: LD_INT 0
26937: PUSH
26938: LD_INT 1
26940: NEG
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 1
26948: PUSH
26949: LD_INT 0
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: LD_INT 1
26958: PUSH
26959: LD_INT 1
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: LD_INT 0
26968: PUSH
26969: LD_INT 1
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: PUSH
26976: LD_INT 1
26978: NEG
26979: PUSH
26980: LD_INT 0
26982: PUSH
26983: EMPTY
26984: LIST
26985: LIST
26986: PUSH
26987: LD_INT 1
26989: NEG
26990: PUSH
26991: LD_INT 1
26993: NEG
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: PUSH
26999: LD_INT 1
27001: NEG
27002: PUSH
27003: LD_INT 2
27005: NEG
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: PUSH
27011: LD_INT 0
27013: PUSH
27014: LD_INT 2
27016: NEG
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 1
27024: PUSH
27025: LD_INT 1
27027: NEG
27028: PUSH
27029: EMPTY
27030: LIST
27031: LIST
27032: PUSH
27033: LD_INT 2
27035: PUSH
27036: LD_INT 0
27038: PUSH
27039: EMPTY
27040: LIST
27041: LIST
27042: PUSH
27043: LD_INT 2
27045: PUSH
27046: LD_INT 1
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PUSH
27053: LD_INT 2
27055: PUSH
27056: LD_INT 2
27058: PUSH
27059: EMPTY
27060: LIST
27061: LIST
27062: PUSH
27063: LD_INT 1
27065: PUSH
27066: LD_INT 2
27068: PUSH
27069: EMPTY
27070: LIST
27071: LIST
27072: PUSH
27073: LD_INT 0
27075: PUSH
27076: LD_INT 2
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 1
27085: NEG
27086: PUSH
27087: LD_INT 1
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 2
27096: NEG
27097: PUSH
27098: LD_INT 0
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 2
27107: NEG
27108: PUSH
27109: LD_INT 1
27111: NEG
27112: PUSH
27113: EMPTY
27114: LIST
27115: LIST
27116: PUSH
27117: LD_INT 2
27119: NEG
27120: PUSH
27121: LD_INT 2
27123: NEG
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 1
27131: PUSH
27132: LD_INT 2
27134: NEG
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: LD_INT 2
27142: PUSH
27143: LD_INT 1
27145: NEG
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 3
27153: PUSH
27154: LD_INT 1
27156: PUSH
27157: EMPTY
27158: LIST
27159: LIST
27160: PUSH
27161: LD_INT 3
27163: PUSH
27164: LD_INT 2
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: EMPTY
27172: LIST
27173: LIST
27174: LIST
27175: LIST
27176: LIST
27177: LIST
27178: LIST
27179: LIST
27180: LIST
27181: LIST
27182: LIST
27183: LIST
27184: LIST
27185: LIST
27186: LIST
27187: LIST
27188: LIST
27189: LIST
27190: LIST
27191: LIST
27192: LIST
27193: LIST
27194: LIST
27195: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27196: LD_ADDR_VAR 0 25
27200: PUSH
27201: LD_INT 0
27203: PUSH
27204: LD_INT 0
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 0
27213: PUSH
27214: LD_INT 1
27216: NEG
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 1
27224: PUSH
27225: LD_INT 0
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: PUSH
27232: LD_INT 1
27234: PUSH
27235: LD_INT 1
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: LD_INT 0
27244: PUSH
27245: LD_INT 1
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 1
27254: NEG
27255: PUSH
27256: LD_INT 0
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: PUSH
27263: LD_INT 1
27265: NEG
27266: PUSH
27267: LD_INT 1
27269: NEG
27270: PUSH
27271: EMPTY
27272: LIST
27273: LIST
27274: PUSH
27275: LD_INT 1
27277: NEG
27278: PUSH
27279: LD_INT 2
27281: NEG
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: LD_INT 0
27289: PUSH
27290: LD_INT 2
27292: NEG
27293: PUSH
27294: EMPTY
27295: LIST
27296: LIST
27297: PUSH
27298: LD_INT 1
27300: PUSH
27301: LD_INT 1
27303: NEG
27304: PUSH
27305: EMPTY
27306: LIST
27307: LIST
27308: PUSH
27309: LD_INT 2
27311: PUSH
27312: LD_INT 0
27314: PUSH
27315: EMPTY
27316: LIST
27317: LIST
27318: PUSH
27319: LD_INT 2
27321: PUSH
27322: LD_INT 1
27324: PUSH
27325: EMPTY
27326: LIST
27327: LIST
27328: PUSH
27329: LD_INT 2
27331: PUSH
27332: LD_INT 2
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: LD_INT 1
27341: PUSH
27342: LD_INT 2
27344: PUSH
27345: EMPTY
27346: LIST
27347: LIST
27348: PUSH
27349: LD_INT 0
27351: PUSH
27352: LD_INT 2
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: PUSH
27359: LD_INT 1
27361: NEG
27362: PUSH
27363: LD_INT 1
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: PUSH
27370: LD_INT 2
27372: NEG
27373: PUSH
27374: LD_INT 0
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: PUSH
27381: LD_INT 2
27383: NEG
27384: PUSH
27385: LD_INT 1
27387: NEG
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: PUSH
27393: LD_INT 2
27395: NEG
27396: PUSH
27397: LD_INT 2
27399: NEG
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 3
27407: PUSH
27408: LD_INT 1
27410: PUSH
27411: EMPTY
27412: LIST
27413: LIST
27414: PUSH
27415: LD_INT 3
27417: PUSH
27418: LD_INT 2
27420: PUSH
27421: EMPTY
27422: LIST
27423: LIST
27424: PUSH
27425: LD_INT 2
27427: PUSH
27428: LD_INT 3
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: PUSH
27435: LD_INT 1
27437: PUSH
27438: LD_INT 3
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: LIST
27449: LIST
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: LIST
27455: LIST
27456: LIST
27457: LIST
27458: LIST
27459: LIST
27460: LIST
27461: LIST
27462: LIST
27463: LIST
27464: LIST
27465: LIST
27466: LIST
27467: LIST
27468: LIST
27469: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27470: LD_ADDR_VAR 0 26
27474: PUSH
27475: LD_INT 0
27477: PUSH
27478: LD_INT 0
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PUSH
27485: LD_INT 0
27487: PUSH
27488: LD_INT 1
27490: NEG
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 1
27498: PUSH
27499: LD_INT 0
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PUSH
27506: LD_INT 1
27508: PUSH
27509: LD_INT 1
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 0
27518: PUSH
27519: LD_INT 1
27521: PUSH
27522: EMPTY
27523: LIST
27524: LIST
27525: PUSH
27526: LD_INT 1
27528: NEG
27529: PUSH
27530: LD_INT 0
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: LD_INT 1
27539: NEG
27540: PUSH
27541: LD_INT 1
27543: NEG
27544: PUSH
27545: EMPTY
27546: LIST
27547: LIST
27548: PUSH
27549: LD_INT 1
27551: NEG
27552: PUSH
27553: LD_INT 2
27555: NEG
27556: PUSH
27557: EMPTY
27558: LIST
27559: LIST
27560: PUSH
27561: LD_INT 0
27563: PUSH
27564: LD_INT 2
27566: NEG
27567: PUSH
27568: EMPTY
27569: LIST
27570: LIST
27571: PUSH
27572: LD_INT 1
27574: PUSH
27575: LD_INT 1
27577: NEG
27578: PUSH
27579: EMPTY
27580: LIST
27581: LIST
27582: PUSH
27583: LD_INT 2
27585: PUSH
27586: LD_INT 0
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: PUSH
27593: LD_INT 2
27595: PUSH
27596: LD_INT 1
27598: PUSH
27599: EMPTY
27600: LIST
27601: LIST
27602: PUSH
27603: LD_INT 2
27605: PUSH
27606: LD_INT 2
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: LD_INT 2
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: LD_INT 0
27625: PUSH
27626: LD_INT 2
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 1
27635: NEG
27636: PUSH
27637: LD_INT 1
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: PUSH
27644: LD_INT 2
27646: NEG
27647: PUSH
27648: LD_INT 0
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PUSH
27655: LD_INT 2
27657: NEG
27658: PUSH
27659: LD_INT 1
27661: NEG
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: LD_INT 2
27669: NEG
27670: PUSH
27671: LD_INT 2
27673: NEG
27674: PUSH
27675: EMPTY
27676: LIST
27677: LIST
27678: PUSH
27679: LD_INT 2
27681: PUSH
27682: LD_INT 3
27684: PUSH
27685: EMPTY
27686: LIST
27687: LIST
27688: PUSH
27689: LD_INT 1
27691: PUSH
27692: LD_INT 3
27694: PUSH
27695: EMPTY
27696: LIST
27697: LIST
27698: PUSH
27699: LD_INT 1
27701: NEG
27702: PUSH
27703: LD_INT 2
27705: PUSH
27706: EMPTY
27707: LIST
27708: LIST
27709: PUSH
27710: LD_INT 2
27712: NEG
27713: PUSH
27714: LD_INT 1
27716: PUSH
27717: EMPTY
27718: LIST
27719: LIST
27720: PUSH
27721: EMPTY
27722: LIST
27723: LIST
27724: LIST
27725: LIST
27726: LIST
27727: LIST
27728: LIST
27729: LIST
27730: LIST
27731: LIST
27732: LIST
27733: LIST
27734: LIST
27735: LIST
27736: LIST
27737: LIST
27738: LIST
27739: LIST
27740: LIST
27741: LIST
27742: LIST
27743: LIST
27744: LIST
27745: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27746: LD_ADDR_VAR 0 27
27750: PUSH
27751: LD_INT 0
27753: PUSH
27754: LD_INT 0
27756: PUSH
27757: EMPTY
27758: LIST
27759: LIST
27760: PUSH
27761: LD_INT 0
27763: PUSH
27764: LD_INT 1
27766: NEG
27767: PUSH
27768: EMPTY
27769: LIST
27770: LIST
27771: PUSH
27772: LD_INT 1
27774: PUSH
27775: LD_INT 0
27777: PUSH
27778: EMPTY
27779: LIST
27780: LIST
27781: PUSH
27782: LD_INT 1
27784: PUSH
27785: LD_INT 1
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: PUSH
27792: LD_INT 0
27794: PUSH
27795: LD_INT 1
27797: PUSH
27798: EMPTY
27799: LIST
27800: LIST
27801: PUSH
27802: LD_INT 1
27804: NEG
27805: PUSH
27806: LD_INT 0
27808: PUSH
27809: EMPTY
27810: LIST
27811: LIST
27812: PUSH
27813: LD_INT 1
27815: NEG
27816: PUSH
27817: LD_INT 1
27819: NEG
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: LD_INT 1
27827: NEG
27828: PUSH
27829: LD_INT 2
27831: NEG
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: LD_INT 0
27839: PUSH
27840: LD_INT 2
27842: NEG
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 1
27850: PUSH
27851: LD_INT 1
27853: NEG
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PUSH
27859: LD_INT 2
27861: PUSH
27862: LD_INT 0
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 2
27871: PUSH
27872: LD_INT 1
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 2
27881: PUSH
27882: LD_INT 2
27884: PUSH
27885: EMPTY
27886: LIST
27887: LIST
27888: PUSH
27889: LD_INT 1
27891: PUSH
27892: LD_INT 2
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 0
27901: PUSH
27902: LD_INT 2
27904: PUSH
27905: EMPTY
27906: LIST
27907: LIST
27908: PUSH
27909: LD_INT 1
27911: NEG
27912: PUSH
27913: LD_INT 1
27915: PUSH
27916: EMPTY
27917: LIST
27918: LIST
27919: PUSH
27920: LD_INT 2
27922: NEG
27923: PUSH
27924: LD_INT 0
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: PUSH
27931: LD_INT 2
27933: NEG
27934: PUSH
27935: LD_INT 1
27937: NEG
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: PUSH
27943: LD_INT 2
27945: NEG
27946: PUSH
27947: LD_INT 2
27949: NEG
27950: PUSH
27951: EMPTY
27952: LIST
27953: LIST
27954: PUSH
27955: LD_INT 1
27957: NEG
27958: PUSH
27959: LD_INT 2
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 2
27968: NEG
27969: PUSH
27970: LD_INT 1
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: LD_INT 3
27979: NEG
27980: PUSH
27981: LD_INT 1
27983: NEG
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 3
27991: NEG
27992: PUSH
27993: LD_INT 2
27995: NEG
27996: PUSH
27997: EMPTY
27998: LIST
27999: LIST
28000: PUSH
28001: EMPTY
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: LIST
28013: LIST
28014: LIST
28015: LIST
28016: LIST
28017: LIST
28018: LIST
28019: LIST
28020: LIST
28021: LIST
28022: LIST
28023: LIST
28024: LIST
28025: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28026: LD_ADDR_VAR 0 28
28030: PUSH
28031: LD_INT 0
28033: PUSH
28034: LD_INT 0
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: LD_INT 0
28043: PUSH
28044: LD_INT 1
28046: NEG
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: LD_INT 1
28054: PUSH
28055: LD_INT 0
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: LD_INT 1
28064: PUSH
28065: LD_INT 1
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 0
28074: PUSH
28075: LD_INT 1
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: PUSH
28082: LD_INT 1
28084: NEG
28085: PUSH
28086: LD_INT 0
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: PUSH
28093: LD_INT 1
28095: NEG
28096: PUSH
28097: LD_INT 1
28099: NEG
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PUSH
28105: LD_INT 1
28107: NEG
28108: PUSH
28109: LD_INT 2
28111: NEG
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: LD_INT 0
28119: PUSH
28120: LD_INT 2
28122: NEG
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 1
28130: PUSH
28131: LD_INT 1
28133: NEG
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: LD_INT 2
28141: PUSH
28142: LD_INT 0
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 2
28151: PUSH
28152: LD_INT 1
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PUSH
28159: LD_INT 2
28161: PUSH
28162: LD_INT 2
28164: PUSH
28165: EMPTY
28166: LIST
28167: LIST
28168: PUSH
28169: LD_INT 1
28171: PUSH
28172: LD_INT 2
28174: PUSH
28175: EMPTY
28176: LIST
28177: LIST
28178: PUSH
28179: LD_INT 0
28181: PUSH
28182: LD_INT 2
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 1
28191: NEG
28192: PUSH
28193: LD_INT 1
28195: PUSH
28196: EMPTY
28197: LIST
28198: LIST
28199: PUSH
28200: LD_INT 2
28202: NEG
28203: PUSH
28204: LD_INT 0
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 2
28213: NEG
28214: PUSH
28215: LD_INT 1
28217: NEG
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: PUSH
28223: LD_INT 2
28225: NEG
28226: PUSH
28227: LD_INT 2
28229: NEG
28230: PUSH
28231: EMPTY
28232: LIST
28233: LIST
28234: PUSH
28235: LD_INT 2
28237: NEG
28238: PUSH
28239: LD_INT 3
28241: NEG
28242: PUSH
28243: EMPTY
28244: LIST
28245: LIST
28246: PUSH
28247: LD_INT 1
28249: NEG
28250: PUSH
28251: LD_INT 3
28253: NEG
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 3
28261: NEG
28262: PUSH
28263: LD_INT 1
28265: NEG
28266: PUSH
28267: EMPTY
28268: LIST
28269: LIST
28270: PUSH
28271: LD_INT 3
28273: NEG
28274: PUSH
28275: LD_INT 2
28277: NEG
28278: PUSH
28279: EMPTY
28280: LIST
28281: LIST
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: LIST
28287: LIST
28288: LIST
28289: LIST
28290: LIST
28291: LIST
28292: LIST
28293: LIST
28294: LIST
28295: LIST
28296: LIST
28297: LIST
28298: LIST
28299: LIST
28300: LIST
28301: LIST
28302: LIST
28303: LIST
28304: LIST
28305: LIST
28306: LIST
28307: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28308: LD_ADDR_VAR 0 29
28312: PUSH
28313: LD_INT 0
28315: PUSH
28316: LD_INT 0
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 0
28325: PUSH
28326: LD_INT 1
28328: NEG
28329: PUSH
28330: EMPTY
28331: LIST
28332: LIST
28333: PUSH
28334: LD_INT 1
28336: PUSH
28337: LD_INT 0
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 1
28346: PUSH
28347: LD_INT 1
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 0
28356: PUSH
28357: LD_INT 1
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: LD_INT 1
28366: NEG
28367: PUSH
28368: LD_INT 0
28370: PUSH
28371: EMPTY
28372: LIST
28373: LIST
28374: PUSH
28375: LD_INT 1
28377: NEG
28378: PUSH
28379: LD_INT 1
28381: NEG
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: LD_INT 1
28389: NEG
28390: PUSH
28391: LD_INT 2
28393: NEG
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: PUSH
28399: LD_INT 0
28401: PUSH
28402: LD_INT 2
28404: NEG
28405: PUSH
28406: EMPTY
28407: LIST
28408: LIST
28409: PUSH
28410: LD_INT 1
28412: PUSH
28413: LD_INT 1
28415: NEG
28416: PUSH
28417: EMPTY
28418: LIST
28419: LIST
28420: PUSH
28421: LD_INT 2
28423: PUSH
28424: LD_INT 0
28426: PUSH
28427: EMPTY
28428: LIST
28429: LIST
28430: PUSH
28431: LD_INT 2
28433: PUSH
28434: LD_INT 1
28436: PUSH
28437: EMPTY
28438: LIST
28439: LIST
28440: PUSH
28441: LD_INT 1
28443: PUSH
28444: LD_INT 2
28446: PUSH
28447: EMPTY
28448: LIST
28449: LIST
28450: PUSH
28451: LD_INT 0
28453: PUSH
28454: LD_INT 2
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PUSH
28461: LD_INT 1
28463: NEG
28464: PUSH
28465: LD_INT 1
28467: PUSH
28468: EMPTY
28469: LIST
28470: LIST
28471: PUSH
28472: LD_INT 2
28474: NEG
28475: PUSH
28476: LD_INT 1
28478: NEG
28479: PUSH
28480: EMPTY
28481: LIST
28482: LIST
28483: PUSH
28484: LD_INT 2
28486: NEG
28487: PUSH
28488: LD_INT 2
28490: NEG
28491: PUSH
28492: EMPTY
28493: LIST
28494: LIST
28495: PUSH
28496: LD_INT 2
28498: NEG
28499: PUSH
28500: LD_INT 3
28502: NEG
28503: PUSH
28504: EMPTY
28505: LIST
28506: LIST
28507: PUSH
28508: LD_INT 2
28510: PUSH
28511: LD_INT 1
28513: NEG
28514: PUSH
28515: EMPTY
28516: LIST
28517: LIST
28518: PUSH
28519: LD_INT 3
28521: PUSH
28522: LD_INT 1
28524: PUSH
28525: EMPTY
28526: LIST
28527: LIST
28528: PUSH
28529: LD_INT 1
28531: PUSH
28532: LD_INT 3
28534: PUSH
28535: EMPTY
28536: LIST
28537: LIST
28538: PUSH
28539: LD_INT 1
28541: NEG
28542: PUSH
28543: LD_INT 2
28545: PUSH
28546: EMPTY
28547: LIST
28548: LIST
28549: PUSH
28550: LD_INT 3
28552: NEG
28553: PUSH
28554: LD_INT 2
28556: NEG
28557: PUSH
28558: EMPTY
28559: LIST
28560: LIST
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: LIST
28566: LIST
28567: LIST
28568: LIST
28569: LIST
28570: LIST
28571: LIST
28572: LIST
28573: LIST
28574: LIST
28575: LIST
28576: LIST
28577: LIST
28578: LIST
28579: LIST
28580: LIST
28581: LIST
28582: LIST
28583: LIST
28584: LIST
28585: LIST
28586: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28587: LD_ADDR_VAR 0 30
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 0
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 0
28604: PUSH
28605: LD_INT 1
28607: NEG
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: LD_INT 1
28615: PUSH
28616: LD_INT 0
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: PUSH
28623: LD_INT 1
28625: PUSH
28626: LD_INT 1
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 0
28635: PUSH
28636: LD_INT 1
28638: PUSH
28639: EMPTY
28640: LIST
28641: LIST
28642: PUSH
28643: LD_INT 1
28645: NEG
28646: PUSH
28647: LD_INT 0
28649: PUSH
28650: EMPTY
28651: LIST
28652: LIST
28653: PUSH
28654: LD_INT 1
28656: NEG
28657: PUSH
28658: LD_INT 1
28660: NEG
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 1
28668: NEG
28669: PUSH
28670: LD_INT 2
28672: NEG
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 0
28680: PUSH
28681: LD_INT 2
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 1
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 2
28702: PUSH
28703: LD_INT 0
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 2
28712: PUSH
28713: LD_INT 1
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 2
28722: PUSH
28723: LD_INT 2
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 1
28732: PUSH
28733: LD_INT 2
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 1
28742: NEG
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: PUSH
28751: LD_INT 2
28753: NEG
28754: PUSH
28755: LD_INT 0
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 2
28764: NEG
28765: PUSH
28766: LD_INT 1
28768: NEG
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: PUSH
28774: LD_INT 1
28776: NEG
28777: PUSH
28778: LD_INT 3
28780: NEG
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 1
28788: PUSH
28789: LD_INT 2
28791: NEG
28792: PUSH
28793: EMPTY
28794: LIST
28795: LIST
28796: PUSH
28797: LD_INT 3
28799: PUSH
28800: LD_INT 2
28802: PUSH
28803: EMPTY
28804: LIST
28805: LIST
28806: PUSH
28807: LD_INT 2
28809: PUSH
28810: LD_INT 3
28812: PUSH
28813: EMPTY
28814: LIST
28815: LIST
28816: PUSH
28817: LD_INT 2
28819: NEG
28820: PUSH
28821: LD_INT 1
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 3
28830: NEG
28831: PUSH
28832: LD_INT 1
28834: NEG
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: LIST
28844: LIST
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28865: LD_ADDR_VAR 0 31
28869: PUSH
28870: LD_INT 0
28872: PUSH
28873: LD_INT 0
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: LD_INT 0
28882: PUSH
28883: LD_INT 1
28885: NEG
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 1
28893: PUSH
28894: LD_INT 0
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 1
28903: PUSH
28904: LD_INT 1
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 0
28913: PUSH
28914: LD_INT 1
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 1
28923: NEG
28924: PUSH
28925: LD_INT 0
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: PUSH
28932: LD_INT 1
28934: NEG
28935: PUSH
28936: LD_INT 1
28938: NEG
28939: PUSH
28940: EMPTY
28941: LIST
28942: LIST
28943: PUSH
28944: LD_INT 1
28946: NEG
28947: PUSH
28948: LD_INT 2
28950: NEG
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: LD_INT 1
28958: PUSH
28959: LD_INT 1
28961: NEG
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 2
28969: PUSH
28970: LD_INT 0
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: PUSH
28977: LD_INT 2
28979: PUSH
28980: LD_INT 1
28982: PUSH
28983: EMPTY
28984: LIST
28985: LIST
28986: PUSH
28987: LD_INT 2
28989: PUSH
28990: LD_INT 2
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: PUSH
28997: LD_INT 1
28999: PUSH
29000: LD_INT 2
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 0
29009: PUSH
29010: LD_INT 2
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: PUSH
29017: LD_INT 1
29019: NEG
29020: PUSH
29021: LD_INT 1
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PUSH
29028: LD_INT 2
29030: NEG
29031: PUSH
29032: LD_INT 1
29034: NEG
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: LD_INT 2
29042: NEG
29043: PUSH
29044: LD_INT 2
29046: NEG
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 2
29054: NEG
29055: PUSH
29056: LD_INT 3
29058: NEG
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 2
29066: PUSH
29067: LD_INT 1
29069: NEG
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: LD_INT 3
29077: PUSH
29078: LD_INT 1
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 1
29087: PUSH
29088: LD_INT 3
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: NEG
29098: PUSH
29099: LD_INT 2
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 3
29108: NEG
29109: PUSH
29110: LD_INT 2
29112: NEG
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: LIST
29122: LIST
29123: LIST
29124: LIST
29125: LIST
29126: LIST
29127: LIST
29128: LIST
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: LIST
29136: LIST
29137: LIST
29138: LIST
29139: LIST
29140: LIST
29141: LIST
29142: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29143: LD_ADDR_VAR 0 32
29147: PUSH
29148: LD_INT 0
29150: PUSH
29151: LD_INT 0
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: LD_INT 0
29160: PUSH
29161: LD_INT 1
29163: NEG
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: PUSH
29169: LD_INT 1
29171: PUSH
29172: LD_INT 0
29174: PUSH
29175: EMPTY
29176: LIST
29177: LIST
29178: PUSH
29179: LD_INT 1
29181: PUSH
29182: LD_INT 1
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PUSH
29189: LD_INT 0
29191: PUSH
29192: LD_INT 1
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PUSH
29199: LD_INT 1
29201: NEG
29202: PUSH
29203: LD_INT 0
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 1
29212: NEG
29213: PUSH
29214: LD_INT 1
29216: NEG
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 1
29224: NEG
29225: PUSH
29226: LD_INT 2
29228: NEG
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: LD_INT 2
29239: NEG
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 1
29247: PUSH
29248: LD_INT 1
29250: NEG
29251: PUSH
29252: EMPTY
29253: LIST
29254: LIST
29255: PUSH
29256: LD_INT 2
29258: PUSH
29259: LD_INT 1
29261: PUSH
29262: EMPTY
29263: LIST
29264: LIST
29265: PUSH
29266: LD_INT 2
29268: PUSH
29269: LD_INT 2
29271: PUSH
29272: EMPTY
29273: LIST
29274: LIST
29275: PUSH
29276: LD_INT 1
29278: PUSH
29279: LD_INT 2
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: LD_INT 2
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 1
29298: NEG
29299: PUSH
29300: LD_INT 1
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: PUSH
29307: LD_INT 2
29309: NEG
29310: PUSH
29311: LD_INT 0
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 2
29320: NEG
29321: PUSH
29322: LD_INT 1
29324: NEG
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 1
29332: NEG
29333: PUSH
29334: LD_INT 3
29336: NEG
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 1
29344: PUSH
29345: LD_INT 2
29347: NEG
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: LD_INT 3
29355: PUSH
29356: LD_INT 2
29358: PUSH
29359: EMPTY
29360: LIST
29361: LIST
29362: PUSH
29363: LD_INT 2
29365: PUSH
29366: LD_INT 3
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: LD_INT 2
29375: NEG
29376: PUSH
29377: LD_INT 1
29379: PUSH
29380: EMPTY
29381: LIST
29382: LIST
29383: PUSH
29384: LD_INT 3
29386: NEG
29387: PUSH
29388: LD_INT 1
29390: NEG
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: LIST
29400: LIST
29401: LIST
29402: LIST
29403: LIST
29404: LIST
29405: LIST
29406: LIST
29407: LIST
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29421: LD_ADDR_VAR 0 33
29425: PUSH
29426: LD_INT 0
29428: PUSH
29429: LD_INT 0
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: LD_INT 0
29438: PUSH
29439: LD_INT 1
29441: NEG
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: LD_INT 1
29449: PUSH
29450: LD_INT 0
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: PUSH
29457: LD_INT 1
29459: PUSH
29460: LD_INT 1
29462: PUSH
29463: EMPTY
29464: LIST
29465: LIST
29466: PUSH
29467: LD_INT 0
29469: PUSH
29470: LD_INT 1
29472: PUSH
29473: EMPTY
29474: LIST
29475: LIST
29476: PUSH
29477: LD_INT 1
29479: NEG
29480: PUSH
29481: LD_INT 0
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: LD_INT 1
29490: NEG
29491: PUSH
29492: LD_INT 1
29494: NEG
29495: PUSH
29496: EMPTY
29497: LIST
29498: LIST
29499: PUSH
29500: LD_INT 1
29502: NEG
29503: PUSH
29504: LD_INT 2
29506: NEG
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: LD_INT 1
29514: PUSH
29515: LD_INT 1
29517: NEG
29518: PUSH
29519: EMPTY
29520: LIST
29521: LIST
29522: PUSH
29523: LD_INT 2
29525: PUSH
29526: LD_INT 0
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: LD_INT 2
29535: PUSH
29536: LD_INT 1
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: LD_INT 1
29545: PUSH
29546: LD_INT 2
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: LD_INT 0
29555: PUSH
29556: LD_INT 2
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 1
29565: NEG
29566: PUSH
29567: LD_INT 1
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: LD_INT 2
29576: NEG
29577: PUSH
29578: LD_INT 0
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PUSH
29585: LD_INT 2
29587: NEG
29588: PUSH
29589: LD_INT 1
29591: NEG
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: LD_INT 2
29599: NEG
29600: PUSH
29601: LD_INT 2
29603: NEG
29604: PUSH
29605: EMPTY
29606: LIST
29607: LIST
29608: PUSH
29609: LD_INT 2
29611: NEG
29612: PUSH
29613: LD_INT 3
29615: NEG
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 2
29623: PUSH
29624: LD_INT 1
29626: NEG
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: LD_INT 3
29634: PUSH
29635: LD_INT 1
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: LD_INT 1
29644: PUSH
29645: LD_INT 3
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 1
29654: NEG
29655: PUSH
29656: LD_INT 2
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PUSH
29663: LD_INT 3
29665: NEG
29666: PUSH
29667: LD_INT 2
29669: NEG
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: LIST
29683: LIST
29684: LIST
29685: LIST
29686: LIST
29687: LIST
29688: LIST
29689: LIST
29690: LIST
29691: LIST
29692: LIST
29693: LIST
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29700: LD_ADDR_VAR 0 34
29704: PUSH
29705: LD_INT 0
29707: PUSH
29708: LD_INT 0
29710: PUSH
29711: EMPTY
29712: LIST
29713: LIST
29714: PUSH
29715: LD_INT 0
29717: PUSH
29718: LD_INT 1
29720: NEG
29721: PUSH
29722: EMPTY
29723: LIST
29724: LIST
29725: PUSH
29726: LD_INT 1
29728: PUSH
29729: LD_INT 0
29731: PUSH
29732: EMPTY
29733: LIST
29734: LIST
29735: PUSH
29736: LD_INT 1
29738: PUSH
29739: LD_INT 1
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: LD_INT 1
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 1
29758: NEG
29759: PUSH
29760: LD_INT 0
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 1
29769: NEG
29770: PUSH
29771: LD_INT 1
29773: NEG
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PUSH
29779: LD_INT 1
29781: NEG
29782: PUSH
29783: LD_INT 2
29785: NEG
29786: PUSH
29787: EMPTY
29788: LIST
29789: LIST
29790: PUSH
29791: LD_INT 0
29793: PUSH
29794: LD_INT 2
29796: NEG
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: LD_INT 1
29804: PUSH
29805: LD_INT 1
29807: NEG
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 2
29815: PUSH
29816: LD_INT 1
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: LD_INT 2
29825: PUSH
29826: LD_INT 2
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 1
29835: PUSH
29836: LD_INT 2
29838: PUSH
29839: EMPTY
29840: LIST
29841: LIST
29842: PUSH
29843: LD_INT 1
29845: NEG
29846: PUSH
29847: LD_INT 1
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: LD_INT 2
29856: NEG
29857: PUSH
29858: LD_INT 0
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 2
29867: NEG
29868: PUSH
29869: LD_INT 1
29871: NEG
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: PUSH
29877: LD_INT 2
29879: NEG
29880: PUSH
29881: LD_INT 2
29883: NEG
29884: PUSH
29885: EMPTY
29886: LIST
29887: LIST
29888: PUSH
29889: LD_INT 1
29891: NEG
29892: PUSH
29893: LD_INT 3
29895: NEG
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: PUSH
29901: LD_INT 1
29903: PUSH
29904: LD_INT 2
29906: NEG
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 3
29914: PUSH
29915: LD_INT 2
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 2
29924: PUSH
29925: LD_INT 3
29927: PUSH
29928: EMPTY
29929: LIST
29930: LIST
29931: PUSH
29932: LD_INT 2
29934: NEG
29935: PUSH
29936: LD_INT 1
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 3
29945: NEG
29946: PUSH
29947: LD_INT 1
29949: NEG
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: LIST
29971: LIST
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: LIST
29979: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29980: LD_ADDR_VAR 0 35
29984: PUSH
29985: LD_INT 0
29987: PUSH
29988: LD_INT 0
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: LD_INT 0
29997: PUSH
29998: LD_INT 1
30000: NEG
30001: PUSH
30002: EMPTY
30003: LIST
30004: LIST
30005: PUSH
30006: LD_INT 1
30008: PUSH
30009: LD_INT 0
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 1
30018: PUSH
30019: LD_INT 1
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 0
30028: PUSH
30029: LD_INT 1
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 1
30038: NEG
30039: PUSH
30040: LD_INT 0
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 1
30049: NEG
30050: PUSH
30051: LD_INT 1
30053: NEG
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 2
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 2
30071: NEG
30072: PUSH
30073: LD_INT 1
30075: NEG
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: LIST
30085: LIST
30086: LIST
30087: LIST
30088: LIST
30089: LIST
30090: LIST
30091: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30092: LD_ADDR_VAR 0 36
30096: PUSH
30097: LD_INT 0
30099: PUSH
30100: LD_INT 0
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 0
30109: PUSH
30110: LD_INT 1
30112: NEG
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 1
30120: PUSH
30121: LD_INT 0
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: LD_INT 1
30130: PUSH
30131: LD_INT 1
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: LD_INT 0
30140: PUSH
30141: LD_INT 1
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 1
30150: NEG
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 1
30161: NEG
30162: PUSH
30163: LD_INT 1
30165: NEG
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: LD_INT 1
30173: NEG
30174: PUSH
30175: LD_INT 2
30177: NEG
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: LD_INT 2
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30204: LD_ADDR_VAR 0 37
30208: PUSH
30209: LD_INT 0
30211: PUSH
30212: LD_INT 0
30214: PUSH
30215: EMPTY
30216: LIST
30217: LIST
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: LD_INT 1
30224: NEG
30225: PUSH
30226: EMPTY
30227: LIST
30228: LIST
30229: PUSH
30230: LD_INT 1
30232: PUSH
30233: LD_INT 0
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: LD_INT 1
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 0
30252: PUSH
30253: LD_INT 1
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 1
30262: NEG
30263: PUSH
30264: LD_INT 0
30266: PUSH
30267: EMPTY
30268: LIST
30269: LIST
30270: PUSH
30271: LD_INT 1
30273: NEG
30274: PUSH
30275: LD_INT 1
30277: NEG
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: LD_INT 1
30288: NEG
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 1
30296: NEG
30297: PUSH
30298: LD_INT 1
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: EMPTY
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: LIST
30312: LIST
30313: LIST
30314: LIST
30315: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30316: LD_ADDR_VAR 0 38
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: LD_INT 0
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 0
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 1
30344: PUSH
30345: LD_INT 0
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: PUSH
30355: LD_INT 1
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 0
30364: PUSH
30365: LD_INT 1
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 1
30374: NEG
30375: PUSH
30376: LD_INT 0
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: PUSH
30383: LD_INT 1
30385: NEG
30386: PUSH
30387: LD_INT 1
30389: NEG
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: PUSH
30395: LD_INT 2
30397: PUSH
30398: LD_INT 1
30400: PUSH
30401: EMPTY
30402: LIST
30403: LIST
30404: PUSH
30405: LD_INT 2
30407: NEG
30408: PUSH
30409: LD_INT 1
30411: NEG
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: EMPTY
30418: LIST
30419: LIST
30420: LIST
30421: LIST
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: LIST
30427: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30428: LD_ADDR_VAR 0 39
30432: PUSH
30433: LD_INT 0
30435: PUSH
30436: LD_INT 0
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 0
30445: PUSH
30446: LD_INT 1
30448: NEG
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 1
30456: PUSH
30457: LD_INT 0
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 1
30466: PUSH
30467: LD_INT 1
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: PUSH
30474: LD_INT 0
30476: PUSH
30477: LD_INT 1
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 1
30486: NEG
30487: PUSH
30488: LD_INT 0
30490: PUSH
30491: EMPTY
30492: LIST
30493: LIST
30494: PUSH
30495: LD_INT 1
30497: NEG
30498: PUSH
30499: LD_INT 1
30501: NEG
30502: PUSH
30503: EMPTY
30504: LIST
30505: LIST
30506: PUSH
30507: LD_INT 1
30509: NEG
30510: PUSH
30511: LD_INT 2
30513: NEG
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 1
30521: PUSH
30522: LD_INT 2
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: LIST
30539: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30540: LD_ADDR_VAR 0 40
30544: PUSH
30545: LD_INT 0
30547: PUSH
30548: LD_INT 0
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: LD_INT 1
30560: NEG
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 1
30568: PUSH
30569: LD_INT 0
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 1
30578: PUSH
30579: LD_INT 1
30581: PUSH
30582: EMPTY
30583: LIST
30584: LIST
30585: PUSH
30586: LD_INT 0
30588: PUSH
30589: LD_INT 1
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: LD_INT 1
30598: NEG
30599: PUSH
30600: LD_INT 0
30602: PUSH
30603: EMPTY
30604: LIST
30605: LIST
30606: PUSH
30607: LD_INT 1
30609: NEG
30610: PUSH
30611: LD_INT 1
30613: NEG
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 1
30621: PUSH
30622: LD_INT 1
30624: NEG
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: LD_INT 1
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30652: LD_ADDR_VAR 0 41
30656: PUSH
30657: LD_INT 0
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 0
30669: PUSH
30670: LD_INT 1
30672: NEG
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 1
30680: PUSH
30681: LD_INT 0
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: PUSH
30691: LD_INT 1
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 0
30700: PUSH
30701: LD_INT 1
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: PUSH
30708: LD_INT 1
30710: NEG
30711: PUSH
30712: LD_INT 0
30714: PUSH
30715: EMPTY
30716: LIST
30717: LIST
30718: PUSH
30719: LD_INT 1
30721: NEG
30722: PUSH
30723: LD_INT 1
30725: NEG
30726: PUSH
30727: EMPTY
30728: LIST
30729: LIST
30730: PUSH
30731: LD_INT 1
30733: NEG
30734: PUSH
30735: LD_INT 2
30737: NEG
30738: PUSH
30739: EMPTY
30740: LIST
30741: LIST
30742: PUSH
30743: LD_INT 1
30745: PUSH
30746: LD_INT 1
30748: NEG
30749: PUSH
30750: EMPTY
30751: LIST
30752: LIST
30753: PUSH
30754: LD_INT 2
30756: PUSH
30757: LD_INT 0
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 2
30766: PUSH
30767: LD_INT 1
30769: PUSH
30770: EMPTY
30771: LIST
30772: LIST
30773: PUSH
30774: LD_INT 2
30776: PUSH
30777: LD_INT 2
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: LD_INT 2
30789: PUSH
30790: EMPTY
30791: LIST
30792: LIST
30793: PUSH
30794: LD_INT 1
30796: NEG
30797: PUSH
30798: LD_INT 1
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: PUSH
30805: LD_INT 2
30807: NEG
30808: PUSH
30809: LD_INT 0
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 2
30818: NEG
30819: PUSH
30820: LD_INT 1
30822: NEG
30823: PUSH
30824: EMPTY
30825: LIST
30826: LIST
30827: PUSH
30828: LD_INT 2
30830: NEG
30831: PUSH
30832: LD_INT 2
30834: NEG
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 2
30842: NEG
30843: PUSH
30844: LD_INT 3
30846: NEG
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 2
30854: PUSH
30855: LD_INT 1
30857: NEG
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 3
30865: PUSH
30866: LD_INT 0
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 3
30875: PUSH
30876: LD_INT 1
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 3
30885: PUSH
30886: LD_INT 2
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 3
30895: PUSH
30896: LD_INT 3
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 2
30905: PUSH
30906: LD_INT 3
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 2
30915: NEG
30916: PUSH
30917: LD_INT 1
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 3
30926: NEG
30927: PUSH
30928: LD_INT 0
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PUSH
30935: LD_INT 3
30937: NEG
30938: PUSH
30939: LD_INT 1
30941: NEG
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 3
30949: NEG
30950: PUSH
30951: LD_INT 2
30953: NEG
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 3
30961: NEG
30962: PUSH
30963: LD_INT 3
30965: NEG
30966: PUSH
30967: EMPTY
30968: LIST
30969: LIST
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: LIST
30999: LIST
31000: LIST
31001: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31002: LD_ADDR_VAR 0 42
31006: PUSH
31007: LD_INT 0
31009: PUSH
31010: LD_INT 0
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: LD_INT 0
31019: PUSH
31020: LD_INT 1
31022: NEG
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 1
31030: PUSH
31031: LD_INT 0
31033: PUSH
31034: EMPTY
31035: LIST
31036: LIST
31037: PUSH
31038: LD_INT 1
31040: PUSH
31041: LD_INT 1
31043: PUSH
31044: EMPTY
31045: LIST
31046: LIST
31047: PUSH
31048: LD_INT 0
31050: PUSH
31051: LD_INT 1
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: LD_INT 0
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: PUSH
31069: LD_INT 1
31071: NEG
31072: PUSH
31073: LD_INT 1
31075: NEG
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PUSH
31081: LD_INT 1
31083: NEG
31084: PUSH
31085: LD_INT 2
31087: NEG
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: PUSH
31093: LD_INT 0
31095: PUSH
31096: LD_INT 2
31098: NEG
31099: PUSH
31100: EMPTY
31101: LIST
31102: LIST
31103: PUSH
31104: LD_INT 1
31106: PUSH
31107: LD_INT 1
31109: NEG
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 2
31117: PUSH
31118: LD_INT 1
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 2
31127: PUSH
31128: LD_INT 2
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: PUSH
31135: LD_INT 1
31137: PUSH
31138: LD_INT 2
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: LD_INT 0
31147: PUSH
31148: LD_INT 2
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 1
31157: NEG
31158: PUSH
31159: LD_INT 1
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: PUSH
31166: LD_INT 2
31168: NEG
31169: PUSH
31170: LD_INT 1
31172: NEG
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 2
31180: NEG
31181: PUSH
31182: LD_INT 2
31184: NEG
31185: PUSH
31186: EMPTY
31187: LIST
31188: LIST
31189: PUSH
31190: LD_INT 2
31192: NEG
31193: PUSH
31194: LD_INT 3
31196: NEG
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 1
31204: NEG
31205: PUSH
31206: LD_INT 3
31208: NEG
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 0
31216: PUSH
31217: LD_INT 3
31219: NEG
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: LD_INT 2
31230: NEG
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 3
31238: PUSH
31239: LD_INT 2
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: LD_INT 3
31248: PUSH
31249: LD_INT 3
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: LD_INT 2
31258: PUSH
31259: LD_INT 3
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 1
31268: PUSH
31269: LD_INT 3
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 0
31278: PUSH
31279: LD_INT 3
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 1
31288: NEG
31289: PUSH
31290: LD_INT 2
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 3
31299: NEG
31300: PUSH
31301: LD_INT 2
31303: NEG
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 3
31311: NEG
31312: PUSH
31313: LD_INT 3
31315: NEG
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: LIST
31345: LIST
31346: LIST
31347: LIST
31348: LIST
31349: LIST
31350: LIST
31351: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31352: LD_ADDR_VAR 0 43
31356: PUSH
31357: LD_INT 0
31359: PUSH
31360: LD_INT 0
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: LD_INT 0
31369: PUSH
31370: LD_INT 1
31372: NEG
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: LD_INT 0
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: LD_INT 1
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 0
31400: PUSH
31401: LD_INT 1
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 1
31410: NEG
31411: PUSH
31412: LD_INT 0
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: LD_INT 1
31421: NEG
31422: PUSH
31423: LD_INT 1
31425: NEG
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 1
31433: NEG
31434: PUSH
31435: LD_INT 2
31437: NEG
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 0
31445: PUSH
31446: LD_INT 2
31448: NEG
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 1
31456: PUSH
31457: LD_INT 1
31459: NEG
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 2
31467: PUSH
31468: LD_INT 0
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 2
31477: PUSH
31478: LD_INT 1
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 1
31487: PUSH
31488: LD_INT 2
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 0
31497: PUSH
31498: LD_INT 2
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 1
31507: NEG
31508: PUSH
31509: LD_INT 1
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 2
31518: NEG
31519: PUSH
31520: LD_INT 0
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 2
31529: NEG
31530: PUSH
31531: LD_INT 1
31533: NEG
31534: PUSH
31535: EMPTY
31536: LIST
31537: LIST
31538: PUSH
31539: LD_INT 1
31541: NEG
31542: PUSH
31543: LD_INT 3
31545: NEG
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: LD_INT 0
31553: PUSH
31554: LD_INT 3
31556: NEG
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 1
31564: PUSH
31565: LD_INT 2
31567: NEG
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 2
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: LD_INT 3
31586: PUSH
31587: LD_INT 0
31589: PUSH
31590: EMPTY
31591: LIST
31592: LIST
31593: PUSH
31594: LD_INT 3
31596: PUSH
31597: LD_INT 1
31599: PUSH
31600: EMPTY
31601: LIST
31602: LIST
31603: PUSH
31604: LD_INT 1
31606: PUSH
31607: LD_INT 3
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 0
31616: PUSH
31617: LD_INT 3
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 1
31626: NEG
31627: PUSH
31628: LD_INT 2
31630: PUSH
31631: EMPTY
31632: LIST
31633: LIST
31634: PUSH
31635: LD_INT 2
31637: NEG
31638: PUSH
31639: LD_INT 1
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: PUSH
31646: LD_INT 3
31648: NEG
31649: PUSH
31650: LD_INT 0
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 3
31659: NEG
31660: PUSH
31661: LD_INT 1
31663: NEG
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: EMPTY
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: LIST
31692: LIST
31693: LIST
31694: LIST
31695: LIST
31696: LIST
31697: LIST
31698: LIST
31699: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31700: LD_ADDR_VAR 0 44
31704: PUSH
31705: LD_INT 0
31707: PUSH
31708: LD_INT 0
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 0
31717: PUSH
31718: LD_INT 1
31720: NEG
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 1
31728: PUSH
31729: LD_INT 0
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 1
31738: PUSH
31739: LD_INT 1
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 0
31748: PUSH
31749: LD_INT 1
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 1
31758: NEG
31759: PUSH
31760: LD_INT 0
31762: PUSH
31763: EMPTY
31764: LIST
31765: LIST
31766: PUSH
31767: LD_INT 1
31769: NEG
31770: PUSH
31771: LD_INT 1
31773: NEG
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 1
31781: NEG
31782: PUSH
31783: LD_INT 2
31785: NEG
31786: PUSH
31787: EMPTY
31788: LIST
31789: LIST
31790: PUSH
31791: LD_INT 1
31793: PUSH
31794: LD_INT 1
31796: NEG
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 2
31804: PUSH
31805: LD_INT 0
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 2
31814: PUSH
31815: LD_INT 1
31817: PUSH
31818: EMPTY
31819: LIST
31820: LIST
31821: PUSH
31822: LD_INT 2
31824: PUSH
31825: LD_INT 2
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 1
31834: PUSH
31835: LD_INT 2
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 1
31844: NEG
31845: PUSH
31846: LD_INT 1
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 2
31855: NEG
31856: PUSH
31857: LD_INT 0
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: LD_INT 1
31870: NEG
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: LD_INT 2
31878: NEG
31879: PUSH
31880: LD_INT 2
31882: NEG
31883: PUSH
31884: EMPTY
31885: LIST
31886: LIST
31887: PUSH
31888: LD_INT 2
31890: NEG
31891: PUSH
31892: LD_INT 3
31894: NEG
31895: PUSH
31896: EMPTY
31897: LIST
31898: LIST
31899: PUSH
31900: LD_INT 2
31902: PUSH
31903: LD_INT 1
31905: NEG
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 3
31913: PUSH
31914: LD_INT 0
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 3
31923: PUSH
31924: LD_INT 1
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 3
31933: PUSH
31934: LD_INT 2
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 3
31943: PUSH
31944: LD_INT 3
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 2
31953: PUSH
31954: LD_INT 3
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 2
31963: NEG
31964: PUSH
31965: LD_INT 1
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 3
31974: NEG
31975: PUSH
31976: LD_INT 0
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 3
31985: NEG
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: PUSH
31995: LD_INT 3
31997: NEG
31998: PUSH
31999: LD_INT 2
32001: NEG
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 3
32009: NEG
32010: PUSH
32011: LD_INT 3
32013: NEG
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32050: LD_ADDR_VAR 0 45
32054: PUSH
32055: LD_INT 0
32057: PUSH
32058: LD_INT 0
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 0
32067: PUSH
32068: LD_INT 1
32070: NEG
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 1
32078: PUSH
32079: LD_INT 0
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 1
32088: PUSH
32089: LD_INT 1
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 0
32098: PUSH
32099: LD_INT 1
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 1
32108: NEG
32109: PUSH
32110: LD_INT 0
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: LD_INT 1
32123: NEG
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: LD_INT 2
32135: NEG
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 0
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 2
32165: PUSH
32166: LD_INT 1
32168: PUSH
32169: EMPTY
32170: LIST
32171: LIST
32172: PUSH
32173: LD_INT 2
32175: PUSH
32176: LD_INT 2
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 1
32185: PUSH
32186: LD_INT 2
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 0
32195: PUSH
32196: LD_INT 2
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 1
32205: NEG
32206: PUSH
32207: LD_INT 1
32209: PUSH
32210: EMPTY
32211: LIST
32212: LIST
32213: PUSH
32214: LD_INT 2
32216: NEG
32217: PUSH
32218: LD_INT 1
32220: NEG
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 2
32228: NEG
32229: PUSH
32230: LD_INT 2
32232: NEG
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PUSH
32238: LD_INT 2
32240: NEG
32241: PUSH
32242: LD_INT 3
32244: NEG
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 1
32252: NEG
32253: PUSH
32254: LD_INT 3
32256: NEG
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 0
32264: PUSH
32265: LD_INT 3
32267: NEG
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 1
32275: PUSH
32276: LD_INT 2
32278: NEG
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 3
32286: PUSH
32287: LD_INT 2
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PUSH
32294: LD_INT 3
32296: PUSH
32297: LD_INT 3
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: LD_INT 2
32306: PUSH
32307: LD_INT 3
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: LD_INT 1
32316: PUSH
32317: LD_INT 3
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 0
32326: PUSH
32327: LD_INT 3
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 1
32336: NEG
32337: PUSH
32338: LD_INT 2
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 3
32347: NEG
32348: PUSH
32349: LD_INT 2
32351: NEG
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 3
32359: NEG
32360: PUSH
32361: LD_INT 3
32363: NEG
32364: PUSH
32365: EMPTY
32366: LIST
32367: LIST
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: LIST
32373: LIST
32374: LIST
32375: LIST
32376: LIST
32377: LIST
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: LIST
32383: LIST
32384: LIST
32385: LIST
32386: LIST
32387: LIST
32388: LIST
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32400: LD_ADDR_VAR 0 46
32404: PUSH
32405: LD_INT 0
32407: PUSH
32408: LD_INT 0
32410: PUSH
32411: EMPTY
32412: LIST
32413: LIST
32414: PUSH
32415: LD_INT 0
32417: PUSH
32418: LD_INT 1
32420: NEG
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: PUSH
32426: LD_INT 1
32428: PUSH
32429: LD_INT 0
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 1
32438: PUSH
32439: LD_INT 1
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 0
32448: PUSH
32449: LD_INT 1
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 1
32458: NEG
32459: PUSH
32460: LD_INT 0
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PUSH
32467: LD_INT 1
32469: NEG
32470: PUSH
32471: LD_INT 1
32473: NEG
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 1
32481: NEG
32482: PUSH
32483: LD_INT 2
32485: NEG
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 0
32493: PUSH
32494: LD_INT 2
32496: NEG
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: PUSH
32502: LD_INT 1
32504: PUSH
32505: LD_INT 1
32507: NEG
32508: PUSH
32509: EMPTY
32510: LIST
32511: LIST
32512: PUSH
32513: LD_INT 2
32515: PUSH
32516: LD_INT 0
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 2
32525: PUSH
32526: LD_INT 1
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: LD_INT 1
32535: PUSH
32536: LD_INT 2
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 0
32545: PUSH
32546: LD_INT 2
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 1
32555: NEG
32556: PUSH
32557: LD_INT 1
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 2
32566: NEG
32567: PUSH
32568: LD_INT 0
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 2
32577: NEG
32578: PUSH
32579: LD_INT 1
32581: NEG
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: LD_INT 1
32589: NEG
32590: PUSH
32591: LD_INT 3
32593: NEG
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: PUSH
32599: LD_INT 0
32601: PUSH
32602: LD_INT 3
32604: NEG
32605: PUSH
32606: EMPTY
32607: LIST
32608: LIST
32609: PUSH
32610: LD_INT 1
32612: PUSH
32613: LD_INT 2
32615: NEG
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 2
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: PUSH
32632: LD_INT 3
32634: PUSH
32635: LD_INT 0
32637: PUSH
32638: EMPTY
32639: LIST
32640: LIST
32641: PUSH
32642: LD_INT 3
32644: PUSH
32645: LD_INT 1
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 1
32654: PUSH
32655: LD_INT 3
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 0
32664: PUSH
32665: LD_INT 3
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 1
32674: NEG
32675: PUSH
32676: LD_INT 2
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 2
32685: NEG
32686: PUSH
32687: LD_INT 1
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: PUSH
32694: LD_INT 3
32696: NEG
32697: PUSH
32698: LD_INT 0
32700: PUSH
32701: EMPTY
32702: LIST
32703: LIST
32704: PUSH
32705: LD_INT 3
32707: NEG
32708: PUSH
32709: LD_INT 1
32711: NEG
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: LIST
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: LIST
32726: LIST
32727: LIST
32728: LIST
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: LIST
32745: LIST
32746: LIST
32747: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32748: LD_ADDR_VAR 0 47
32752: PUSH
32753: LD_INT 0
32755: PUSH
32756: LD_INT 0
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 0
32765: PUSH
32766: LD_INT 1
32768: NEG
32769: PUSH
32770: EMPTY
32771: LIST
32772: LIST
32773: PUSH
32774: LD_INT 1
32776: PUSH
32777: LD_INT 0
32779: PUSH
32780: EMPTY
32781: LIST
32782: LIST
32783: PUSH
32784: LD_INT 1
32786: PUSH
32787: LD_INT 1
32789: PUSH
32790: EMPTY
32791: LIST
32792: LIST
32793: PUSH
32794: LD_INT 0
32796: PUSH
32797: LD_INT 1
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PUSH
32804: LD_INT 1
32806: NEG
32807: PUSH
32808: LD_INT 0
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: LD_INT 1
32817: NEG
32818: PUSH
32819: LD_INT 1
32821: NEG
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 1
32829: NEG
32830: PUSH
32831: LD_INT 2
32833: NEG
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 0
32841: PUSH
32842: LD_INT 2
32844: NEG
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 1
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 2
32863: NEG
32864: PUSH
32865: LD_INT 1
32867: NEG
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 2
32875: NEG
32876: PUSH
32877: LD_INT 2
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: LIST
32895: LIST
32896: LIST
32897: LIST
32898: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32899: LD_ADDR_VAR 0 48
32903: PUSH
32904: LD_INT 0
32906: PUSH
32907: LD_INT 0
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 0
32916: PUSH
32917: LD_INT 1
32919: NEG
32920: PUSH
32921: EMPTY
32922: LIST
32923: LIST
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: LD_INT 0
32930: PUSH
32931: EMPTY
32932: LIST
32933: LIST
32934: PUSH
32935: LD_INT 1
32937: PUSH
32938: LD_INT 1
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PUSH
32945: LD_INT 0
32947: PUSH
32948: LD_INT 1
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 0
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 1
32968: NEG
32969: PUSH
32970: LD_INT 1
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: NEG
32981: PUSH
32982: LD_INT 2
32984: NEG
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 0
32992: PUSH
32993: LD_INT 2
32995: NEG
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 1
33003: PUSH
33004: LD_INT 1
33006: NEG
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: PUSH
33012: LD_INT 2
33014: PUSH
33015: LD_INT 0
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 2
33024: PUSH
33025: LD_INT 1
33027: PUSH
33028: EMPTY
33029: LIST
33030: LIST
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33046: LD_ADDR_VAR 0 49
33050: PUSH
33051: LD_INT 0
33053: PUSH
33054: LD_INT 0
33056: PUSH
33057: EMPTY
33058: LIST
33059: LIST
33060: PUSH
33061: LD_INT 0
33063: PUSH
33064: LD_INT 1
33066: NEG
33067: PUSH
33068: EMPTY
33069: LIST
33070: LIST
33071: PUSH
33072: LD_INT 1
33074: PUSH
33075: LD_INT 0
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: PUSH
33082: LD_INT 1
33084: PUSH
33085: LD_INT 1
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 0
33094: PUSH
33095: LD_INT 1
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 1
33104: NEG
33105: PUSH
33106: LD_INT 0
33108: PUSH
33109: EMPTY
33110: LIST
33111: LIST
33112: PUSH
33113: LD_INT 1
33115: NEG
33116: PUSH
33117: LD_INT 1
33119: NEG
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: LD_INT 1
33130: NEG
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 2
33138: PUSH
33139: LD_INT 0
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PUSH
33146: LD_INT 2
33148: PUSH
33149: LD_INT 1
33151: PUSH
33152: EMPTY
33153: LIST
33154: LIST
33155: PUSH
33156: LD_INT 2
33158: PUSH
33159: LD_INT 2
33161: PUSH
33162: EMPTY
33163: LIST
33164: LIST
33165: PUSH
33166: LD_INT 1
33168: PUSH
33169: LD_INT 2
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: LIST
33180: LIST
33181: LIST
33182: LIST
33183: LIST
33184: LIST
33185: LIST
33186: LIST
33187: LIST
33188: LIST
33189: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33190: LD_ADDR_VAR 0 50
33194: PUSH
33195: LD_INT 0
33197: PUSH
33198: LD_INT 0
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 0
33207: PUSH
33208: LD_INT 1
33210: NEG
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: LD_INT 1
33218: PUSH
33219: LD_INT 0
33221: PUSH
33222: EMPTY
33223: LIST
33224: LIST
33225: PUSH
33226: LD_INT 1
33228: PUSH
33229: LD_INT 1
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: PUSH
33236: LD_INT 0
33238: PUSH
33239: LD_INT 1
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 1
33248: NEG
33249: PUSH
33250: LD_INT 0
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: LD_INT 1
33259: NEG
33260: PUSH
33261: LD_INT 1
33263: NEG
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 2
33271: PUSH
33272: LD_INT 1
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 2
33281: PUSH
33282: LD_INT 2
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 1
33291: PUSH
33292: LD_INT 2
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 0
33301: PUSH
33302: LD_INT 2
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 1
33311: NEG
33312: PUSH
33313: LD_INT 1
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33334: LD_ADDR_VAR 0 51
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: LD_INT 0
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 0
33351: PUSH
33352: LD_INT 1
33354: NEG
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 1
33362: PUSH
33363: LD_INT 0
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: LD_INT 1
33372: PUSH
33373: LD_INT 1
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 0
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 1
33392: NEG
33393: PUSH
33394: LD_INT 0
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 1
33403: NEG
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 1
33415: PUSH
33416: LD_INT 2
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 0
33425: PUSH
33426: LD_INT 2
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: LD_INT 1
33435: NEG
33436: PUSH
33437: LD_INT 1
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 2
33446: NEG
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 2
33457: NEG
33458: PUSH
33459: LD_INT 1
33461: NEG
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33481: LD_ADDR_VAR 0 52
33485: PUSH
33486: LD_INT 0
33488: PUSH
33489: LD_INT 0
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 1
33501: NEG
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: LD_INT 0
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: LD_INT 1
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 0
33529: PUSH
33530: LD_INT 1
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 1
33539: NEG
33540: PUSH
33541: LD_INT 0
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 1
33550: NEG
33551: PUSH
33552: LD_INT 1
33554: NEG
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 1
33562: NEG
33563: PUSH
33564: LD_INT 2
33566: NEG
33567: PUSH
33568: EMPTY
33569: LIST
33570: LIST
33571: PUSH
33572: LD_INT 1
33574: NEG
33575: PUSH
33576: LD_INT 1
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 2
33585: NEG
33586: PUSH
33587: LD_INT 0
33589: PUSH
33590: EMPTY
33591: LIST
33592: LIST
33593: PUSH
33594: LD_INT 2
33596: NEG
33597: PUSH
33598: LD_INT 1
33600: NEG
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 2
33608: NEG
33609: PUSH
33610: LD_INT 2
33612: NEG
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: LIST
33627: LIST
33628: LIST
33629: LIST
33630: LIST
33631: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33632: LD_ADDR_VAR 0 53
33636: PUSH
33637: LD_INT 0
33639: PUSH
33640: LD_INT 0
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 0
33649: PUSH
33650: LD_INT 1
33652: NEG
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 1
33660: PUSH
33661: LD_INT 0
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 1
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 0
33680: PUSH
33681: LD_INT 1
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 1
33690: NEG
33691: PUSH
33692: LD_INT 0
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 1
33701: NEG
33702: PUSH
33703: LD_INT 1
33705: NEG
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 1
33713: NEG
33714: PUSH
33715: LD_INT 2
33717: NEG
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 0
33725: PUSH
33726: LD_INT 2
33728: NEG
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 1
33736: PUSH
33737: LD_INT 1
33739: NEG
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: LD_INT 2
33747: PUSH
33748: LD_INT 0
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 2
33757: PUSH
33758: LD_INT 1
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: PUSH
33765: LD_INT 2
33767: PUSH
33768: LD_INT 2
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: LD_INT 2
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 0
33787: PUSH
33788: LD_INT 2
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 1
33797: NEG
33798: PUSH
33799: LD_INT 1
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: LD_INT 0
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: NEG
33820: PUSH
33821: LD_INT 1
33823: NEG
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 2
33831: NEG
33832: PUSH
33833: LD_INT 2
33835: NEG
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: LIST
33855: LIST
33856: LIST
33857: LIST
33858: LIST
33859: LIST
33860: LIST
33861: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33862: LD_ADDR_VAR 0 54
33866: PUSH
33867: LD_INT 0
33869: PUSH
33870: LD_INT 0
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 0
33879: PUSH
33880: LD_INT 1
33882: NEG
33883: PUSH
33884: EMPTY
33885: LIST
33886: LIST
33887: PUSH
33888: LD_INT 1
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 1
33900: PUSH
33901: LD_INT 1
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 0
33910: PUSH
33911: LD_INT 1
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: NEG
33921: PUSH
33922: LD_INT 0
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 1
33931: NEG
33932: PUSH
33933: LD_INT 1
33935: NEG
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 1
33943: NEG
33944: PUSH
33945: LD_INT 2
33947: NEG
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 0
33955: PUSH
33956: LD_INT 2
33958: NEG
33959: PUSH
33960: EMPTY
33961: LIST
33962: LIST
33963: PUSH
33964: LD_INT 1
33966: PUSH
33967: LD_INT 1
33969: NEG
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: LD_INT 2
33977: PUSH
33978: LD_INT 0
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 2
33987: PUSH
33988: LD_INT 1
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 2
33997: PUSH
33998: LD_INT 2
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 1
34007: PUSH
34008: LD_INT 2
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 0
34017: PUSH
34018: LD_INT 2
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: LD_INT 1
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 2
34038: NEG
34039: PUSH
34040: LD_INT 0
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 2
34049: NEG
34050: PUSH
34051: LD_INT 1
34053: NEG
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: LD_INT 2
34061: NEG
34062: PUSH
34063: LD_INT 2
34065: NEG
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34092: LD_ADDR_VAR 0 55
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 0
34109: PUSH
34110: LD_INT 1
34112: NEG
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 1
34120: PUSH
34121: LD_INT 0
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 1
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 0
34140: PUSH
34141: LD_INT 1
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: LD_INT 0
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 1
34173: NEG
34174: PUSH
34175: LD_INT 2
34177: NEG
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 0
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 1
34199: NEG
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 2
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 2
34217: PUSH
34218: LD_INT 1
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: LD_INT 2
34227: PUSH
34228: LD_INT 2
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: PUSH
34238: LD_INT 2
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 0
34247: PUSH
34248: LD_INT 2
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 1
34257: NEG
34258: PUSH
34259: LD_INT 1
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 2
34268: NEG
34269: PUSH
34270: LD_INT 0
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: LD_INT 2
34279: NEG
34280: PUSH
34281: LD_INT 1
34283: NEG
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 2
34291: NEG
34292: PUSH
34293: LD_INT 2
34295: NEG
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: LIST
34305: LIST
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: LIST
34321: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34322: LD_ADDR_VAR 0 56
34326: PUSH
34327: LD_INT 0
34329: PUSH
34330: LD_INT 0
34332: PUSH
34333: EMPTY
34334: LIST
34335: LIST
34336: PUSH
34337: LD_INT 0
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: PUSH
34348: LD_INT 1
34350: PUSH
34351: LD_INT 0
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 1
34360: PUSH
34361: LD_INT 1
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: LD_INT 1
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: LD_INT 1
34380: NEG
34381: PUSH
34382: LD_INT 0
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 1
34391: NEG
34392: PUSH
34393: LD_INT 1
34395: NEG
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PUSH
34401: LD_INT 1
34403: NEG
34404: PUSH
34405: LD_INT 2
34407: NEG
34408: PUSH
34409: EMPTY
34410: LIST
34411: LIST
34412: PUSH
34413: LD_INT 0
34415: PUSH
34416: LD_INT 2
34418: NEG
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: PUSH
34424: LD_INT 1
34426: PUSH
34427: LD_INT 1
34429: NEG
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: LD_INT 2
34437: PUSH
34438: LD_INT 0
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 2
34447: PUSH
34448: LD_INT 1
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 2
34457: PUSH
34458: LD_INT 2
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: LD_INT 2
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 0
34477: PUSH
34478: LD_INT 2
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 1
34487: NEG
34488: PUSH
34489: LD_INT 1
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 2
34498: NEG
34499: PUSH
34500: LD_INT 0
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 2
34509: NEG
34510: PUSH
34511: LD_INT 1
34513: NEG
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 2
34521: NEG
34522: PUSH
34523: LD_INT 2
34525: NEG
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: LIST
34540: LIST
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34552: LD_ADDR_VAR 0 57
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: LD_INT 0
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 0
34569: PUSH
34570: LD_INT 1
34572: NEG
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 1
34580: PUSH
34581: LD_INT 0
34583: PUSH
34584: EMPTY
34585: LIST
34586: LIST
34587: PUSH
34588: LD_INT 1
34590: PUSH
34591: LD_INT 1
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: PUSH
34598: LD_INT 0
34600: PUSH
34601: LD_INT 1
34603: PUSH
34604: EMPTY
34605: LIST
34606: LIST
34607: PUSH
34608: LD_INT 1
34610: NEG
34611: PUSH
34612: LD_INT 0
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: LD_INT 1
34625: NEG
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 1
34633: NEG
34634: PUSH
34635: LD_INT 2
34637: NEG
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 0
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 1
34656: PUSH
34657: LD_INT 1
34659: NEG
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 2
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PUSH
34675: LD_INT 2
34677: PUSH
34678: LD_INT 1
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 2
34687: PUSH
34688: LD_INT 2
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 1
34697: PUSH
34698: LD_INT 2
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 0
34707: PUSH
34708: LD_INT 2
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 1
34717: NEG
34718: PUSH
34719: LD_INT 1
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 2
34728: NEG
34729: PUSH
34730: LD_INT 0
34732: PUSH
34733: EMPTY
34734: LIST
34735: LIST
34736: PUSH
34737: LD_INT 2
34739: NEG
34740: PUSH
34741: LD_INT 1
34743: NEG
34744: PUSH
34745: EMPTY
34746: LIST
34747: LIST
34748: PUSH
34749: LD_INT 2
34751: NEG
34752: PUSH
34753: LD_INT 2
34755: NEG
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: LIST
34765: LIST
34766: LIST
34767: LIST
34768: LIST
34769: LIST
34770: LIST
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34782: LD_ADDR_VAR 0 58
34786: PUSH
34787: LD_INT 0
34789: PUSH
34790: LD_INT 0
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: LD_INT 1
34802: NEG
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: PUSH
34808: LD_INT 1
34810: PUSH
34811: LD_INT 0
34813: PUSH
34814: EMPTY
34815: LIST
34816: LIST
34817: PUSH
34818: LD_INT 1
34820: PUSH
34821: LD_INT 1
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: LD_INT 1
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 1
34840: NEG
34841: PUSH
34842: LD_INT 0
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PUSH
34849: LD_INT 1
34851: NEG
34852: PUSH
34853: LD_INT 1
34855: NEG
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: NEG
34864: PUSH
34865: LD_INT 2
34867: NEG
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 0
34875: PUSH
34876: LD_INT 2
34878: NEG
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 1
34886: PUSH
34887: LD_INT 1
34889: NEG
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 2
34897: PUSH
34898: LD_INT 0
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 2
34907: PUSH
34908: LD_INT 1
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 2
34917: PUSH
34918: LD_INT 2
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 1
34927: PUSH
34928: LD_INT 2
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 0
34937: PUSH
34938: LD_INT 2
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 1
34947: NEG
34948: PUSH
34949: LD_INT 1
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 2
34958: NEG
34959: PUSH
34960: LD_INT 0
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PUSH
34967: LD_INT 2
34969: NEG
34970: PUSH
34971: LD_INT 1
34973: NEG
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 2
34981: NEG
34982: PUSH
34983: LD_INT 2
34985: NEG
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35012: LD_ADDR_VAR 0 59
35016: PUSH
35017: LD_INT 0
35019: PUSH
35020: LD_INT 0
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: LD_INT 1
35032: NEG
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 1
35040: PUSH
35041: LD_INT 0
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 1
35050: PUSH
35051: LD_INT 1
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: PUSH
35058: LD_INT 0
35060: PUSH
35061: LD_INT 1
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 1
35070: NEG
35071: PUSH
35072: LD_INT 0
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: PUSH
35079: LD_INT 1
35081: NEG
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35100: LD_ADDR_VAR 0 60
35104: PUSH
35105: LD_INT 0
35107: PUSH
35108: LD_INT 0
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: LD_INT 1
35120: NEG
35121: PUSH
35122: EMPTY
35123: LIST
35124: LIST
35125: PUSH
35126: LD_INT 1
35128: PUSH
35129: LD_INT 0
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 1
35138: PUSH
35139: LD_INT 1
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 0
35148: PUSH
35149: LD_INT 1
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: LD_INT 0
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 1
35169: NEG
35170: PUSH
35171: LD_INT 1
35173: NEG
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: LIST
35186: LIST
35187: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35188: LD_ADDR_VAR 0 61
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: LD_INT 0
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 0
35205: PUSH
35206: LD_INT 1
35208: NEG
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 1
35216: PUSH
35217: LD_INT 0
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 1
35226: PUSH
35227: LD_INT 1
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: LD_INT 1
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: LD_INT 1
35246: NEG
35247: PUSH
35248: LD_INT 0
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 1
35257: NEG
35258: PUSH
35259: LD_INT 1
35261: NEG
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35276: LD_ADDR_VAR 0 62
35280: PUSH
35281: LD_INT 0
35283: PUSH
35284: LD_INT 0
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: PUSH
35291: LD_INT 0
35293: PUSH
35294: LD_INT 1
35296: NEG
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 1
35304: PUSH
35305: LD_INT 0
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: LD_INT 1
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 1
35334: NEG
35335: PUSH
35336: LD_INT 0
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 1
35345: NEG
35346: PUSH
35347: LD_INT 1
35349: NEG
35350: PUSH
35351: EMPTY
35352: LIST
35353: LIST
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: LIST
35359: LIST
35360: LIST
35361: LIST
35362: LIST
35363: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35364: LD_ADDR_VAR 0 63
35368: PUSH
35369: LD_INT 0
35371: PUSH
35372: LD_INT 0
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 0
35381: PUSH
35382: LD_INT 1
35384: NEG
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 1
35392: PUSH
35393: LD_INT 0
35395: PUSH
35396: EMPTY
35397: LIST
35398: LIST
35399: PUSH
35400: LD_INT 1
35402: PUSH
35403: LD_INT 1
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 0
35412: PUSH
35413: LD_INT 1
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 1
35422: NEG
35423: PUSH
35424: LD_INT 0
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 1
35433: NEG
35434: PUSH
35435: LD_INT 1
35437: NEG
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35452: LD_ADDR_VAR 0 64
35456: PUSH
35457: LD_INT 0
35459: PUSH
35460: LD_INT 0
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 0
35469: PUSH
35470: LD_INT 1
35472: NEG
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 1
35480: PUSH
35481: LD_INT 0
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 1
35490: PUSH
35491: LD_INT 1
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: PUSH
35498: LD_INT 0
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 1
35510: NEG
35511: PUSH
35512: LD_INT 0
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 1
35521: NEG
35522: PUSH
35523: LD_INT 1
35525: NEG
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: LIST
35535: LIST
35536: LIST
35537: LIST
35538: LIST
35539: ST_TO_ADDR
// end ; 1 :
35540: GO 41437
35542: LD_INT 1
35544: DOUBLE
35545: EQUAL
35546: IFTRUE 35550
35548: GO 38173
35550: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35551: LD_ADDR_VAR 0 11
35555: PUSH
35556: LD_INT 1
35558: NEG
35559: PUSH
35560: LD_INT 3
35562: NEG
35563: PUSH
35564: EMPTY
35565: LIST
35566: LIST
35567: PUSH
35568: LD_INT 0
35570: PUSH
35571: LD_INT 3
35573: NEG
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 1
35581: PUSH
35582: LD_INT 2
35584: NEG
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: LIST
35594: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35595: LD_ADDR_VAR 0 12
35599: PUSH
35600: LD_INT 2
35602: PUSH
35603: LD_INT 1
35605: NEG
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 3
35613: PUSH
35614: LD_INT 0
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 3
35623: PUSH
35624: LD_INT 1
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: LIST
35635: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35636: LD_ADDR_VAR 0 13
35640: PUSH
35641: LD_INT 3
35643: PUSH
35644: LD_INT 2
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 3
35653: PUSH
35654: LD_INT 3
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 2
35663: PUSH
35664: LD_INT 3
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: LIST
35675: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35676: LD_ADDR_VAR 0 14
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: LD_INT 3
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: LD_INT 3
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 2
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: LIST
35716: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35717: LD_ADDR_VAR 0 15
35721: PUSH
35722: LD_INT 2
35724: NEG
35725: PUSH
35726: LD_INT 1
35728: PUSH
35729: EMPTY
35730: LIST
35731: LIST
35732: PUSH
35733: LD_INT 3
35735: NEG
35736: PUSH
35737: LD_INT 0
35739: PUSH
35740: EMPTY
35741: LIST
35742: LIST
35743: PUSH
35744: LD_INT 3
35746: NEG
35747: PUSH
35748: LD_INT 1
35750: NEG
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: LIST
35760: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35761: LD_ADDR_VAR 0 16
35765: PUSH
35766: LD_INT 2
35768: NEG
35769: PUSH
35770: LD_INT 3
35772: NEG
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 3
35780: NEG
35781: PUSH
35782: LD_INT 2
35784: NEG
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: LD_INT 3
35792: NEG
35793: PUSH
35794: LD_INT 3
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: LIST
35806: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35807: LD_ADDR_VAR 0 17
35811: PUSH
35812: LD_INT 1
35814: NEG
35815: PUSH
35816: LD_INT 3
35818: NEG
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 0
35826: PUSH
35827: LD_INT 3
35829: NEG
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: PUSH
35835: LD_INT 1
35837: PUSH
35838: LD_INT 2
35840: NEG
35841: PUSH
35842: EMPTY
35843: LIST
35844: LIST
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: LIST
35850: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35851: LD_ADDR_VAR 0 18
35855: PUSH
35856: LD_INT 2
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 3
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 3
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: LIST
35891: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35892: LD_ADDR_VAR 0 19
35896: PUSH
35897: LD_INT 3
35899: PUSH
35900: LD_INT 2
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 3
35909: PUSH
35910: LD_INT 3
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 2
35919: PUSH
35920: LD_INT 3
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: LIST
35931: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35932: LD_ADDR_VAR 0 20
35936: PUSH
35937: LD_INT 1
35939: PUSH
35940: LD_INT 3
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 0
35949: PUSH
35950: LD_INT 3
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 1
35959: NEG
35960: PUSH
35961: LD_INT 2
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: LIST
35972: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35973: LD_ADDR_VAR 0 21
35977: PUSH
35978: LD_INT 2
35980: NEG
35981: PUSH
35982: LD_INT 1
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 3
35991: NEG
35992: PUSH
35993: LD_INT 0
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 3
36002: NEG
36003: PUSH
36004: LD_INT 1
36006: NEG
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: LIST
36016: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36017: LD_ADDR_VAR 0 22
36021: PUSH
36022: LD_INT 2
36024: NEG
36025: PUSH
36026: LD_INT 3
36028: NEG
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 3
36036: NEG
36037: PUSH
36038: LD_INT 2
36040: NEG
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: PUSH
36046: LD_INT 3
36048: NEG
36049: PUSH
36050: LD_INT 3
36052: NEG
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: LIST
36062: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36063: LD_ADDR_VAR 0 23
36067: PUSH
36068: LD_INT 0
36070: PUSH
36071: LD_INT 3
36073: NEG
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 1
36081: NEG
36082: PUSH
36083: LD_INT 4
36085: NEG
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 1
36093: PUSH
36094: LD_INT 3
36096: NEG
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: LIST
36106: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36107: LD_ADDR_VAR 0 24
36111: PUSH
36112: LD_INT 3
36114: PUSH
36115: LD_INT 0
36117: PUSH
36118: EMPTY
36119: LIST
36120: LIST
36121: PUSH
36122: LD_INT 3
36124: PUSH
36125: LD_INT 1
36127: NEG
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: PUSH
36133: LD_INT 4
36135: PUSH
36136: LD_INT 1
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: LIST
36147: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36148: LD_ADDR_VAR 0 25
36152: PUSH
36153: LD_INT 3
36155: PUSH
36156: LD_INT 3
36158: PUSH
36159: EMPTY
36160: LIST
36161: LIST
36162: PUSH
36163: LD_INT 4
36165: PUSH
36166: LD_INT 3
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 3
36175: PUSH
36176: LD_INT 4
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: LIST
36187: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36188: LD_ADDR_VAR 0 26
36192: PUSH
36193: LD_INT 0
36195: PUSH
36196: LD_INT 3
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 1
36205: PUSH
36206: LD_INT 4
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 1
36215: NEG
36216: PUSH
36217: LD_INT 3
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: LIST
36228: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36229: LD_ADDR_VAR 0 27
36233: PUSH
36234: LD_INT 3
36236: NEG
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: LD_INT 3
36247: NEG
36248: PUSH
36249: LD_INT 1
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 4
36258: NEG
36259: PUSH
36260: LD_INT 1
36262: NEG
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: LIST
36272: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36273: LD_ADDR_VAR 0 28
36277: PUSH
36278: LD_INT 3
36280: NEG
36281: PUSH
36282: LD_INT 3
36284: NEG
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 3
36292: NEG
36293: PUSH
36294: LD_INT 4
36296: NEG
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: LD_INT 4
36304: NEG
36305: PUSH
36306: LD_INT 3
36308: NEG
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: LIST
36318: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36319: LD_ADDR_VAR 0 29
36323: PUSH
36324: LD_INT 1
36326: NEG
36327: PUSH
36328: LD_INT 3
36330: NEG
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 0
36338: PUSH
36339: LD_INT 3
36341: NEG
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 1
36349: PUSH
36350: LD_INT 2
36352: NEG
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 1
36360: NEG
36361: PUSH
36362: LD_INT 4
36364: NEG
36365: PUSH
36366: EMPTY
36367: LIST
36368: LIST
36369: PUSH
36370: LD_INT 0
36372: PUSH
36373: LD_INT 4
36375: NEG
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: PUSH
36381: LD_INT 1
36383: PUSH
36384: LD_INT 3
36386: NEG
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 1
36394: NEG
36395: PUSH
36396: LD_INT 5
36398: NEG
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 0
36406: PUSH
36407: LD_INT 5
36409: NEG
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 1
36417: PUSH
36418: LD_INT 4
36420: NEG
36421: PUSH
36422: EMPTY
36423: LIST
36424: LIST
36425: PUSH
36426: LD_INT 1
36428: NEG
36429: PUSH
36430: LD_INT 6
36432: NEG
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 0
36440: PUSH
36441: LD_INT 6
36443: NEG
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 1
36451: PUSH
36452: LD_INT 5
36454: NEG
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36474: LD_ADDR_VAR 0 30
36478: PUSH
36479: LD_INT 2
36481: PUSH
36482: LD_INT 1
36484: NEG
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 3
36492: PUSH
36493: LD_INT 0
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 3
36502: PUSH
36503: LD_INT 1
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: LD_INT 3
36512: PUSH
36513: LD_INT 1
36515: NEG
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 4
36523: PUSH
36524: LD_INT 0
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 4
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 4
36543: PUSH
36544: LD_INT 1
36546: NEG
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 5
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 5
36564: PUSH
36565: LD_INT 1
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 5
36574: PUSH
36575: LD_INT 1
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 6
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 6
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36617: LD_ADDR_VAR 0 31
36621: PUSH
36622: LD_INT 3
36624: PUSH
36625: LD_INT 2
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: PUSH
36632: LD_INT 3
36634: PUSH
36635: LD_INT 3
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 2
36644: PUSH
36645: LD_INT 3
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 4
36654: PUSH
36655: LD_INT 3
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: LD_INT 4
36664: PUSH
36665: LD_INT 4
36667: PUSH
36668: EMPTY
36669: LIST
36670: LIST
36671: PUSH
36672: LD_INT 3
36674: PUSH
36675: LD_INT 4
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 5
36684: PUSH
36685: LD_INT 4
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: PUSH
36692: LD_INT 5
36694: PUSH
36695: LD_INT 5
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 4
36704: PUSH
36705: LD_INT 5
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 6
36714: PUSH
36715: LD_INT 5
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 6
36724: PUSH
36725: LD_INT 6
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 5
36734: PUSH
36735: LD_INT 6
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36756: LD_ADDR_VAR 0 32
36760: PUSH
36761: LD_INT 1
36763: PUSH
36764: LD_INT 3
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 0
36773: PUSH
36774: LD_INT 3
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 1
36783: NEG
36784: PUSH
36785: LD_INT 2
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 1
36794: PUSH
36795: LD_INT 4
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 0
36804: PUSH
36805: LD_INT 4
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 1
36814: NEG
36815: PUSH
36816: LD_INT 3
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 1
36825: PUSH
36826: LD_INT 5
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: PUSH
36833: LD_INT 0
36835: PUSH
36836: LD_INT 5
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: LD_INT 1
36845: NEG
36846: PUSH
36847: LD_INT 4
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 1
36856: PUSH
36857: LD_INT 6
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 0
36866: PUSH
36867: LD_INT 6
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: PUSH
36874: LD_INT 1
36876: NEG
36877: PUSH
36878: LD_INT 5
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: LIST
36889: LIST
36890: LIST
36891: LIST
36892: LIST
36893: LIST
36894: LIST
36895: LIST
36896: LIST
36897: LIST
36898: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36899: LD_ADDR_VAR 0 33
36903: PUSH
36904: LD_INT 2
36906: NEG
36907: PUSH
36908: LD_INT 1
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 3
36917: NEG
36918: PUSH
36919: LD_INT 0
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 3
36928: NEG
36929: PUSH
36930: LD_INT 1
36932: NEG
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 3
36940: NEG
36941: PUSH
36942: LD_INT 1
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 4
36951: NEG
36952: PUSH
36953: LD_INT 0
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 4
36962: NEG
36963: PUSH
36964: LD_INT 1
36966: NEG
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: LD_INT 4
36974: NEG
36975: PUSH
36976: LD_INT 1
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 5
36985: NEG
36986: PUSH
36987: LD_INT 0
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: LD_INT 5
36996: NEG
36997: PUSH
36998: LD_INT 1
37000: NEG
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 5
37008: NEG
37009: PUSH
37010: LD_INT 1
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 6
37019: NEG
37020: PUSH
37021: LD_INT 0
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 6
37030: NEG
37031: PUSH
37032: LD_INT 1
37034: NEG
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: LIST
37044: LIST
37045: LIST
37046: LIST
37047: LIST
37048: LIST
37049: LIST
37050: LIST
37051: LIST
37052: LIST
37053: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37054: LD_ADDR_VAR 0 34
37058: PUSH
37059: LD_INT 2
37061: NEG
37062: PUSH
37063: LD_INT 3
37065: NEG
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 3
37073: NEG
37074: PUSH
37075: LD_INT 2
37077: NEG
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 3
37085: NEG
37086: PUSH
37087: LD_INT 3
37089: NEG
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 3
37097: NEG
37098: PUSH
37099: LD_INT 4
37101: NEG
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: LD_INT 4
37109: NEG
37110: PUSH
37111: LD_INT 3
37113: NEG
37114: PUSH
37115: EMPTY
37116: LIST
37117: LIST
37118: PUSH
37119: LD_INT 4
37121: NEG
37122: PUSH
37123: LD_INT 4
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 4
37133: NEG
37134: PUSH
37135: LD_INT 5
37137: NEG
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 5
37145: NEG
37146: PUSH
37147: LD_INT 4
37149: NEG
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: LD_INT 5
37157: NEG
37158: PUSH
37159: LD_INT 5
37161: NEG
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 5
37169: NEG
37170: PUSH
37171: LD_INT 6
37173: NEG
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 6
37181: NEG
37182: PUSH
37183: LD_INT 5
37185: NEG
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 6
37193: NEG
37194: PUSH
37195: LD_INT 6
37197: NEG
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: LIST
37214: LIST
37215: LIST
37216: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37217: LD_ADDR_VAR 0 41
37221: PUSH
37222: LD_INT 0
37224: PUSH
37225: LD_INT 2
37227: NEG
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 1
37235: NEG
37236: PUSH
37237: LD_INT 3
37239: NEG
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 1
37247: PUSH
37248: LD_INT 2
37250: NEG
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: LIST
37260: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37261: LD_ADDR_VAR 0 42
37265: PUSH
37266: LD_INT 2
37268: PUSH
37269: LD_INT 0
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 2
37278: PUSH
37279: LD_INT 1
37281: NEG
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: LD_INT 3
37289: PUSH
37290: LD_INT 1
37292: PUSH
37293: EMPTY
37294: LIST
37295: LIST
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: LIST
37301: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37302: LD_ADDR_VAR 0 43
37306: PUSH
37307: LD_INT 2
37309: PUSH
37310: LD_INT 2
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 3
37319: PUSH
37320: LD_INT 2
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 2
37329: PUSH
37330: LD_INT 3
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: LIST
37341: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37342: LD_ADDR_VAR 0 44
37346: PUSH
37347: LD_INT 0
37349: PUSH
37350: LD_INT 2
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 1
37359: PUSH
37360: LD_INT 3
37362: PUSH
37363: EMPTY
37364: LIST
37365: LIST
37366: PUSH
37367: LD_INT 1
37369: NEG
37370: PUSH
37371: LD_INT 2
37373: PUSH
37374: EMPTY
37375: LIST
37376: LIST
37377: PUSH
37378: EMPTY
37379: LIST
37380: LIST
37381: LIST
37382: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37383: LD_ADDR_VAR 0 45
37387: PUSH
37388: LD_INT 2
37390: NEG
37391: PUSH
37392: LD_INT 0
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 2
37401: NEG
37402: PUSH
37403: LD_INT 1
37405: PUSH
37406: EMPTY
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 3
37412: NEG
37413: PUSH
37414: LD_INT 1
37416: NEG
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: LIST
37426: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37427: LD_ADDR_VAR 0 46
37431: PUSH
37432: LD_INT 2
37434: NEG
37435: PUSH
37436: LD_INT 2
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 2
37446: NEG
37447: PUSH
37448: LD_INT 3
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 3
37458: NEG
37459: PUSH
37460: LD_INT 2
37462: NEG
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: LIST
37472: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37473: LD_ADDR_VAR 0 47
37477: PUSH
37478: LD_INT 2
37480: NEG
37481: PUSH
37482: LD_INT 3
37484: NEG
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: LD_INT 3
37496: NEG
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37506: LD_ADDR_VAR 0 48
37510: PUSH
37511: LD_INT 1
37513: PUSH
37514: LD_INT 2
37516: NEG
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 2
37524: PUSH
37525: LD_INT 1
37527: NEG
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37537: LD_ADDR_VAR 0 49
37541: PUSH
37542: LD_INT 3
37544: PUSH
37545: LD_INT 1
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 3
37554: PUSH
37555: LD_INT 2
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37566: LD_ADDR_VAR 0 50
37570: PUSH
37571: LD_INT 2
37573: PUSH
37574: LD_INT 3
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: LD_INT 3
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37595: LD_ADDR_VAR 0 51
37599: PUSH
37600: LD_INT 1
37602: NEG
37603: PUSH
37604: LD_INT 2
37606: PUSH
37607: EMPTY
37608: LIST
37609: LIST
37610: PUSH
37611: LD_INT 2
37613: NEG
37614: PUSH
37615: LD_INT 1
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: PUSH
37622: EMPTY
37623: LIST
37624: LIST
37625: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37626: LD_ADDR_VAR 0 52
37630: PUSH
37631: LD_INT 3
37633: NEG
37634: PUSH
37635: LD_INT 1
37637: NEG
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 3
37645: NEG
37646: PUSH
37647: LD_INT 2
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37659: LD_ADDR_VAR 0 53
37663: PUSH
37664: LD_INT 1
37666: NEG
37667: PUSH
37668: LD_INT 3
37670: NEG
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 0
37678: PUSH
37679: LD_INT 3
37681: NEG
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 1
37689: PUSH
37690: LD_INT 2
37692: NEG
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: LIST
37702: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37703: LD_ADDR_VAR 0 54
37707: PUSH
37708: LD_INT 2
37710: PUSH
37711: LD_INT 1
37713: NEG
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 3
37721: PUSH
37722: LD_INT 0
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 3
37731: PUSH
37732: LD_INT 1
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: EMPTY
37740: LIST
37741: LIST
37742: LIST
37743: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37744: LD_ADDR_VAR 0 55
37748: PUSH
37749: LD_INT 3
37751: PUSH
37752: LD_INT 2
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 3
37761: PUSH
37762: LD_INT 3
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: PUSH
37772: LD_INT 3
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: LIST
37783: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37784: LD_ADDR_VAR 0 56
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: LD_INT 3
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 0
37801: PUSH
37802: LD_INT 3
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 1
37811: NEG
37812: PUSH
37813: LD_INT 2
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: LIST
37824: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37825: LD_ADDR_VAR 0 57
37829: PUSH
37830: LD_INT 2
37832: NEG
37833: PUSH
37834: LD_INT 1
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 3
37843: NEG
37844: PUSH
37845: LD_INT 0
37847: PUSH
37848: EMPTY
37849: LIST
37850: LIST
37851: PUSH
37852: LD_INT 3
37854: NEG
37855: PUSH
37856: LD_INT 1
37858: NEG
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: LIST
37868: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37869: LD_ADDR_VAR 0 58
37873: PUSH
37874: LD_INT 2
37876: NEG
37877: PUSH
37878: LD_INT 3
37880: NEG
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 3
37888: NEG
37889: PUSH
37890: LD_INT 2
37892: NEG
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 3
37900: NEG
37901: PUSH
37902: LD_INT 3
37904: NEG
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: PUSH
37910: EMPTY
37911: LIST
37912: LIST
37913: LIST
37914: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37915: LD_ADDR_VAR 0 59
37919: PUSH
37920: LD_INT 1
37922: NEG
37923: PUSH
37924: LD_INT 2
37926: NEG
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 0
37934: PUSH
37935: LD_INT 2
37937: NEG
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: PUSH
37943: LD_INT 1
37945: PUSH
37946: LD_INT 1
37948: NEG
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: LIST
37958: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37959: LD_ADDR_VAR 0 60
37963: PUSH
37964: LD_INT 1
37966: PUSH
37967: LD_INT 1
37969: NEG
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 2
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 2
37987: PUSH
37988: LD_INT 1
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: LIST
37999: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38000: LD_ADDR_VAR 0 61
38004: PUSH
38005: LD_INT 2
38007: PUSH
38008: LD_INT 1
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: PUSH
38018: LD_INT 2
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 1
38027: PUSH
38028: LD_INT 2
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: LIST
38039: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38040: LD_ADDR_VAR 0 62
38044: PUSH
38045: LD_INT 1
38047: PUSH
38048: LD_INT 2
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 0
38057: PUSH
38058: LD_INT 2
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 1
38067: NEG
38068: PUSH
38069: LD_INT 1
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: EMPTY
38077: LIST
38078: LIST
38079: LIST
38080: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38081: LD_ADDR_VAR 0 63
38085: PUSH
38086: LD_INT 1
38088: NEG
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 2
38099: NEG
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 2
38110: NEG
38111: PUSH
38112: LD_INT 1
38114: NEG
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: LIST
38124: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38125: LD_ADDR_VAR 0 64
38129: PUSH
38130: LD_INT 1
38132: NEG
38133: PUSH
38134: LD_INT 2
38136: NEG
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 2
38144: NEG
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 2
38156: NEG
38157: PUSH
38158: LD_INT 2
38160: NEG
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: LIST
38170: ST_TO_ADDR
// end ; 2 :
38171: GO 41437
38173: LD_INT 2
38175: DOUBLE
38176: EQUAL
38177: IFTRUE 38181
38179: GO 41436
38181: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38182: LD_ADDR_VAR 0 29
38186: PUSH
38187: LD_INT 4
38189: PUSH
38190: LD_INT 0
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 4
38199: PUSH
38200: LD_INT 1
38202: NEG
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 5
38210: PUSH
38211: LD_INT 0
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 5
38220: PUSH
38221: LD_INT 1
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 4
38230: PUSH
38231: LD_INT 1
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 3
38240: PUSH
38241: LD_INT 0
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 3
38250: PUSH
38251: LD_INT 1
38253: NEG
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 3
38261: PUSH
38262: LD_INT 2
38264: NEG
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: PUSH
38270: LD_INT 5
38272: PUSH
38273: LD_INT 2
38275: PUSH
38276: EMPTY
38277: LIST
38278: LIST
38279: PUSH
38280: LD_INT 3
38282: PUSH
38283: LD_INT 3
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 3
38292: PUSH
38293: LD_INT 2
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 4
38302: PUSH
38303: LD_INT 3
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 4
38312: PUSH
38313: LD_INT 4
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 3
38322: PUSH
38323: LD_INT 4
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 2
38332: PUSH
38333: LD_INT 3
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 2
38342: PUSH
38343: LD_INT 2
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 4
38352: PUSH
38353: LD_INT 2
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 2
38362: PUSH
38363: LD_INT 4
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: LD_INT 4
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 0
38382: PUSH
38383: LD_INT 3
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 1
38392: PUSH
38393: LD_INT 4
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 1
38402: PUSH
38403: LD_INT 5
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 0
38412: PUSH
38413: LD_INT 5
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 1
38422: NEG
38423: PUSH
38424: LD_INT 4
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 1
38433: NEG
38434: PUSH
38435: LD_INT 3
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 2
38444: PUSH
38445: LD_INT 5
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 2
38454: NEG
38455: PUSH
38456: LD_INT 3
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 3
38465: NEG
38466: PUSH
38467: LD_INT 0
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 3
38476: NEG
38477: PUSH
38478: LD_INT 1
38480: NEG
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 2
38488: NEG
38489: PUSH
38490: LD_INT 0
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PUSH
38497: LD_INT 2
38499: NEG
38500: PUSH
38501: LD_INT 1
38503: PUSH
38504: EMPTY
38505: LIST
38506: LIST
38507: PUSH
38508: LD_INT 3
38510: NEG
38511: PUSH
38512: LD_INT 1
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 4
38521: NEG
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 4
38532: NEG
38533: PUSH
38534: LD_INT 1
38536: NEG
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 4
38544: NEG
38545: PUSH
38546: LD_INT 2
38548: NEG
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: LD_INT 2
38556: NEG
38557: PUSH
38558: LD_INT 2
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 4
38567: NEG
38568: PUSH
38569: LD_INT 4
38571: NEG
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: LD_INT 4
38579: NEG
38580: PUSH
38581: LD_INT 5
38583: NEG
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: PUSH
38589: LD_INT 3
38591: NEG
38592: PUSH
38593: LD_INT 4
38595: NEG
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 3
38603: NEG
38604: PUSH
38605: LD_INT 3
38607: NEG
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: PUSH
38613: LD_INT 4
38615: NEG
38616: PUSH
38617: LD_INT 3
38619: NEG
38620: PUSH
38621: EMPTY
38622: LIST
38623: LIST
38624: PUSH
38625: LD_INT 5
38627: NEG
38628: PUSH
38629: LD_INT 4
38631: NEG
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 5
38639: NEG
38640: PUSH
38641: LD_INT 5
38643: NEG
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 3
38651: NEG
38652: PUSH
38653: LD_INT 5
38655: NEG
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 5
38663: NEG
38664: PUSH
38665: LD_INT 3
38667: NEG
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: LIST
38687: LIST
38688: LIST
38689: LIST
38690: LIST
38691: LIST
38692: LIST
38693: LIST
38694: LIST
38695: LIST
38696: LIST
38697: LIST
38698: LIST
38699: LIST
38700: LIST
38701: LIST
38702: LIST
38703: LIST
38704: LIST
38705: LIST
38706: LIST
38707: LIST
38708: LIST
38709: LIST
38710: LIST
38711: LIST
38712: LIST
38713: LIST
38714: LIST
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38720: LD_ADDR_VAR 0 30
38724: PUSH
38725: LD_INT 4
38727: PUSH
38728: LD_INT 4
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 4
38737: PUSH
38738: LD_INT 3
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 5
38747: PUSH
38748: LD_INT 4
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 5
38757: PUSH
38758: LD_INT 5
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 4
38767: PUSH
38768: LD_INT 5
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 3
38777: PUSH
38778: LD_INT 4
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 3
38787: PUSH
38788: LD_INT 3
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 5
38797: PUSH
38798: LD_INT 3
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 3
38807: PUSH
38808: LD_INT 5
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 0
38817: PUSH
38818: LD_INT 3
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 0
38827: PUSH
38828: LD_INT 2
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 1
38837: PUSH
38838: LD_INT 3
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: LD_INT 1
38847: PUSH
38848: LD_INT 4
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: LD_INT 4
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 1
38867: NEG
38868: PUSH
38869: LD_INT 3
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: LD_INT 2
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: LD_INT 2
38889: PUSH
38890: LD_INT 4
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 2
38899: NEG
38900: PUSH
38901: LD_INT 2
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: PUSH
38908: LD_INT 4
38910: NEG
38911: PUSH
38912: LD_INT 0
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: LD_INT 4
38921: NEG
38922: PUSH
38923: LD_INT 1
38925: NEG
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: PUSH
38931: LD_INT 3
38933: NEG
38934: PUSH
38935: LD_INT 0
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: LD_INT 3
38944: NEG
38945: PUSH
38946: LD_INT 1
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 4
38955: NEG
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PUSH
38964: LD_INT 5
38966: NEG
38967: PUSH
38968: LD_INT 0
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: PUSH
38975: LD_INT 5
38977: NEG
38978: PUSH
38979: LD_INT 1
38981: NEG
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: PUSH
38987: LD_INT 5
38989: NEG
38990: PUSH
38991: LD_INT 2
38993: NEG
38994: PUSH
38995: EMPTY
38996: LIST
38997: LIST
38998: PUSH
38999: LD_INT 3
39001: NEG
39002: PUSH
39003: LD_INT 2
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 3
39012: NEG
39013: PUSH
39014: LD_INT 3
39016: NEG
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 3
39024: NEG
39025: PUSH
39026: LD_INT 4
39028: NEG
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 2
39036: NEG
39037: PUSH
39038: LD_INT 3
39040: NEG
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 2
39048: NEG
39049: PUSH
39050: LD_INT 2
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 3
39060: NEG
39061: PUSH
39062: LD_INT 2
39064: NEG
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 4
39072: NEG
39073: PUSH
39074: LD_INT 3
39076: NEG
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 4
39084: NEG
39085: PUSH
39086: LD_INT 4
39088: NEG
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: LD_INT 2
39096: NEG
39097: PUSH
39098: LD_INT 4
39100: NEG
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 4
39108: NEG
39109: PUSH
39110: LD_INT 2
39112: NEG
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: LD_INT 4
39123: NEG
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: LD_INT 5
39134: NEG
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: LD_INT 1
39142: PUSH
39143: LD_INT 4
39145: NEG
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: PUSH
39151: LD_INT 1
39153: PUSH
39154: LD_INT 3
39156: NEG
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 0
39164: PUSH
39165: LD_INT 3
39167: NEG
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 1
39175: NEG
39176: PUSH
39177: LD_INT 4
39179: NEG
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 1
39187: NEG
39188: PUSH
39189: LD_INT 5
39191: NEG
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: LD_INT 2
39199: PUSH
39200: LD_INT 3
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 2
39210: NEG
39211: PUSH
39212: LD_INT 5
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: LIST
39224: LIST
39225: LIST
39226: LIST
39227: LIST
39228: LIST
39229: LIST
39230: LIST
39231: LIST
39232: LIST
39233: LIST
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: LIST
39253: LIST
39254: LIST
39255: LIST
39256: LIST
39257: LIST
39258: LIST
39259: LIST
39260: LIST
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: LIST
39266: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39267: LD_ADDR_VAR 0 31
39271: PUSH
39272: LD_INT 0
39274: PUSH
39275: LD_INT 4
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 0
39284: PUSH
39285: LD_INT 3
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: LD_INT 4
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: PUSH
39305: LD_INT 5
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: LD_INT 5
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 1
39324: NEG
39325: PUSH
39326: LD_INT 4
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: LD_INT 3
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 2
39346: PUSH
39347: LD_INT 5
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 2
39356: NEG
39357: PUSH
39358: LD_INT 3
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 3
39367: NEG
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: LD_INT 3
39378: NEG
39379: PUSH
39380: LD_INT 1
39382: NEG
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: LD_INT 2
39390: NEG
39391: PUSH
39392: LD_INT 0
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: PUSH
39399: LD_INT 2
39401: NEG
39402: PUSH
39403: LD_INT 1
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: LD_INT 3
39412: NEG
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 4
39423: NEG
39424: PUSH
39425: LD_INT 0
39427: PUSH
39428: EMPTY
39429: LIST
39430: LIST
39431: PUSH
39432: LD_INT 4
39434: NEG
39435: PUSH
39436: LD_INT 1
39438: NEG
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 4
39446: NEG
39447: PUSH
39448: LD_INT 2
39450: NEG
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: PUSH
39456: LD_INT 2
39458: NEG
39459: PUSH
39460: LD_INT 2
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 4
39469: NEG
39470: PUSH
39471: LD_INT 4
39473: NEG
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 4
39481: NEG
39482: PUSH
39483: LD_INT 5
39485: NEG
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 3
39493: NEG
39494: PUSH
39495: LD_INT 4
39497: NEG
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 3
39505: NEG
39506: PUSH
39507: LD_INT 3
39509: NEG
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 4
39517: NEG
39518: PUSH
39519: LD_INT 3
39521: NEG
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: PUSH
39527: LD_INT 5
39529: NEG
39530: PUSH
39531: LD_INT 4
39533: NEG
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 5
39541: NEG
39542: PUSH
39543: LD_INT 5
39545: NEG
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 3
39553: NEG
39554: PUSH
39555: LD_INT 5
39557: NEG
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 5
39565: NEG
39566: PUSH
39567: LD_INT 3
39569: NEG
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 0
39577: PUSH
39578: LD_INT 3
39580: NEG
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 0
39588: PUSH
39589: LD_INT 4
39591: NEG
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 1
39599: PUSH
39600: LD_INT 3
39602: NEG
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 1
39610: PUSH
39611: LD_INT 2
39613: NEG
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 0
39621: PUSH
39622: LD_INT 2
39624: NEG
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 1
39632: NEG
39633: PUSH
39634: LD_INT 3
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: LD_INT 1
39644: NEG
39645: PUSH
39646: LD_INT 4
39648: NEG
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 2
39656: PUSH
39657: LD_INT 2
39659: NEG
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 2
39667: NEG
39668: PUSH
39669: LD_INT 4
39671: NEG
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 4
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 4
39689: PUSH
39690: LD_INT 1
39692: NEG
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 5
39700: PUSH
39701: LD_INT 0
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 5
39710: PUSH
39711: LD_INT 1
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: LD_INT 4
39720: PUSH
39721: LD_INT 1
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: PUSH
39728: LD_INT 3
39730: PUSH
39731: LD_INT 0
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 3
39740: PUSH
39741: LD_INT 1
39743: NEG
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 3
39751: PUSH
39752: LD_INT 2
39754: NEG
39755: PUSH
39756: EMPTY
39757: LIST
39758: LIST
39759: PUSH
39760: LD_INT 5
39762: PUSH
39763: LD_INT 2
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: LIST
39774: LIST
39775: LIST
39776: LIST
39777: LIST
39778: LIST
39779: LIST
39780: LIST
39781: LIST
39782: LIST
39783: LIST
39784: LIST
39785: LIST
39786: LIST
39787: LIST
39788: LIST
39789: LIST
39790: LIST
39791: LIST
39792: LIST
39793: LIST
39794: LIST
39795: LIST
39796: LIST
39797: LIST
39798: LIST
39799: LIST
39800: LIST
39801: LIST
39802: LIST
39803: LIST
39804: LIST
39805: LIST
39806: LIST
39807: LIST
39808: LIST
39809: LIST
39810: LIST
39811: LIST
39812: LIST
39813: LIST
39814: LIST
39815: LIST
39816: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39817: LD_ADDR_VAR 0 32
39821: PUSH
39822: LD_INT 4
39824: NEG
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 4
39835: NEG
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 3
39847: NEG
39848: PUSH
39849: LD_INT 0
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: PUSH
39856: LD_INT 3
39858: NEG
39859: PUSH
39860: LD_INT 1
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 4
39869: NEG
39870: PUSH
39871: LD_INT 1
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: PUSH
39878: LD_INT 5
39880: NEG
39881: PUSH
39882: LD_INT 0
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 5
39891: NEG
39892: PUSH
39893: LD_INT 1
39895: NEG
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 5
39903: NEG
39904: PUSH
39905: LD_INT 2
39907: NEG
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 3
39915: NEG
39916: PUSH
39917: LD_INT 2
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 3
39926: NEG
39927: PUSH
39928: LD_INT 3
39930: NEG
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 3
39938: NEG
39939: PUSH
39940: LD_INT 4
39942: NEG
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 2
39950: NEG
39951: PUSH
39952: LD_INT 3
39954: NEG
39955: PUSH
39956: EMPTY
39957: LIST
39958: LIST
39959: PUSH
39960: LD_INT 2
39962: NEG
39963: PUSH
39964: LD_INT 2
39966: NEG
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 3
39974: NEG
39975: PUSH
39976: LD_INT 2
39978: NEG
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 4
39986: NEG
39987: PUSH
39988: LD_INT 3
39990: NEG
39991: PUSH
39992: EMPTY
39993: LIST
39994: LIST
39995: PUSH
39996: LD_INT 4
39998: NEG
39999: PUSH
40000: LD_INT 4
40002: NEG
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 2
40010: NEG
40011: PUSH
40012: LD_INT 4
40014: NEG
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 4
40022: NEG
40023: PUSH
40024: LD_INT 2
40026: NEG
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 0
40034: PUSH
40035: LD_INT 4
40037: NEG
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: LD_INT 0
40045: PUSH
40046: LD_INT 5
40048: NEG
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 1
40056: PUSH
40057: LD_INT 4
40059: NEG
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 1
40067: PUSH
40068: LD_INT 3
40070: NEG
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: LD_INT 3
40081: NEG
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: LD_INT 4
40093: NEG
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: PUSH
40099: LD_INT 1
40101: NEG
40102: PUSH
40103: LD_INT 5
40105: NEG
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 2
40113: PUSH
40114: LD_INT 3
40116: NEG
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: LD_INT 2
40124: NEG
40125: PUSH
40126: LD_INT 5
40128: NEG
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 3
40136: PUSH
40137: LD_INT 0
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 3
40146: PUSH
40147: LD_INT 1
40149: NEG
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: PUSH
40155: LD_INT 4
40157: PUSH
40158: LD_INT 0
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PUSH
40165: LD_INT 4
40167: PUSH
40168: LD_INT 1
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: LD_INT 3
40177: PUSH
40178: LD_INT 1
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 2
40187: PUSH
40188: LD_INT 0
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 2
40197: PUSH
40198: LD_INT 1
40200: NEG
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 2
40208: PUSH
40209: LD_INT 2
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 4
40219: PUSH
40220: LD_INT 2
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 4
40229: PUSH
40230: LD_INT 4
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: LD_INT 4
40239: PUSH
40240: LD_INT 3
40242: PUSH
40243: EMPTY
40244: LIST
40245: LIST
40246: PUSH
40247: LD_INT 5
40249: PUSH
40250: LD_INT 4
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 5
40259: PUSH
40260: LD_INT 5
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 4
40269: PUSH
40270: LD_INT 5
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 3
40279: PUSH
40280: LD_INT 4
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 3
40289: PUSH
40290: LD_INT 3
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 5
40299: PUSH
40300: LD_INT 3
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 3
40309: PUSH
40310: LD_INT 5
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: LIST
40338: LIST
40339: LIST
40340: LIST
40341: LIST
40342: LIST
40343: LIST
40344: LIST
40345: LIST
40346: LIST
40347: LIST
40348: LIST
40349: LIST
40350: LIST
40351: LIST
40352: LIST
40353: LIST
40354: LIST
40355: LIST
40356: LIST
40357: LIST
40358: LIST
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40364: LD_ADDR_VAR 0 33
40368: PUSH
40369: LD_INT 4
40371: NEG
40372: PUSH
40373: LD_INT 4
40375: NEG
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 4
40383: NEG
40384: PUSH
40385: LD_INT 5
40387: NEG
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 3
40395: NEG
40396: PUSH
40397: LD_INT 4
40399: NEG
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 3
40407: NEG
40408: PUSH
40409: LD_INT 3
40411: NEG
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 4
40419: NEG
40420: PUSH
40421: LD_INT 3
40423: NEG
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 5
40431: NEG
40432: PUSH
40433: LD_INT 4
40435: NEG
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 5
40443: NEG
40444: PUSH
40445: LD_INT 5
40447: NEG
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 3
40455: NEG
40456: PUSH
40457: LD_INT 5
40459: NEG
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 5
40467: NEG
40468: PUSH
40469: LD_INT 3
40471: NEG
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: LD_INT 3
40482: NEG
40483: PUSH
40484: EMPTY
40485: LIST
40486: LIST
40487: PUSH
40488: LD_INT 0
40490: PUSH
40491: LD_INT 4
40493: NEG
40494: PUSH
40495: EMPTY
40496: LIST
40497: LIST
40498: PUSH
40499: LD_INT 1
40501: PUSH
40502: LD_INT 3
40504: NEG
40505: PUSH
40506: EMPTY
40507: LIST
40508: LIST
40509: PUSH
40510: LD_INT 1
40512: PUSH
40513: LD_INT 2
40515: NEG
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: LD_INT 0
40523: PUSH
40524: LD_INT 2
40526: NEG
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 1
40534: NEG
40535: PUSH
40536: LD_INT 3
40538: NEG
40539: PUSH
40540: EMPTY
40541: LIST
40542: LIST
40543: PUSH
40544: LD_INT 1
40546: NEG
40547: PUSH
40548: LD_INT 4
40550: NEG
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 2
40558: PUSH
40559: LD_INT 2
40561: NEG
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 2
40569: NEG
40570: PUSH
40571: LD_INT 4
40573: NEG
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 4
40581: PUSH
40582: LD_INT 0
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 4
40591: PUSH
40592: LD_INT 1
40594: NEG
40595: PUSH
40596: EMPTY
40597: LIST
40598: LIST
40599: PUSH
40600: LD_INT 5
40602: PUSH
40603: LD_INT 0
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 5
40612: PUSH
40613: LD_INT 1
40615: PUSH
40616: EMPTY
40617: LIST
40618: LIST
40619: PUSH
40620: LD_INT 4
40622: PUSH
40623: LD_INT 1
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 3
40632: PUSH
40633: LD_INT 0
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 3
40642: PUSH
40643: LD_INT 1
40645: NEG
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 3
40653: PUSH
40654: LD_INT 2
40656: NEG
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 5
40664: PUSH
40665: LD_INT 2
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 3
40674: PUSH
40675: LD_INT 3
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 3
40684: PUSH
40685: LD_INT 2
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 4
40694: PUSH
40695: LD_INT 3
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 4
40704: PUSH
40705: LD_INT 4
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: PUSH
40712: LD_INT 3
40714: PUSH
40715: LD_INT 4
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 2
40724: PUSH
40725: LD_INT 3
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 2
40734: PUSH
40735: LD_INT 2
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: LD_INT 4
40744: PUSH
40745: LD_INT 2
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 2
40754: PUSH
40755: LD_INT 4
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 0
40764: PUSH
40765: LD_INT 4
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 0
40774: PUSH
40775: LD_INT 3
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 1
40784: PUSH
40785: LD_INT 4
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: PUSH
40792: LD_INT 1
40794: PUSH
40795: LD_INT 5
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 0
40804: PUSH
40805: LD_INT 5
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 1
40814: NEG
40815: PUSH
40816: LD_INT 4
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: LD_INT 3
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: LD_INT 2
40836: PUSH
40837: LD_INT 5
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 2
40846: NEG
40847: PUSH
40848: LD_INT 3
40850: PUSH
40851: EMPTY
40852: LIST
40853: LIST
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: LIST
40859: LIST
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: LIST
40870: LIST
40871: LIST
40872: LIST
40873: LIST
40874: LIST
40875: LIST
40876: LIST
40877: LIST
40878: LIST
40879: LIST
40880: LIST
40881: LIST
40882: LIST
40883: LIST
40884: LIST
40885: LIST
40886: LIST
40887: LIST
40888: LIST
40889: LIST
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: LIST
40895: LIST
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40902: LD_ADDR_VAR 0 34
40906: PUSH
40907: LD_INT 0
40909: PUSH
40910: LD_INT 4
40912: NEG
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 0
40920: PUSH
40921: LD_INT 5
40923: NEG
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: PUSH
40929: LD_INT 1
40931: PUSH
40932: LD_INT 4
40934: NEG
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 1
40942: PUSH
40943: LD_INT 3
40945: NEG
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: LD_INT 0
40953: PUSH
40954: LD_INT 3
40956: NEG
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: LD_INT 1
40964: NEG
40965: PUSH
40966: LD_INT 4
40968: NEG
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 1
40976: NEG
40977: PUSH
40978: LD_INT 5
40980: NEG
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 2
40988: PUSH
40989: LD_INT 3
40991: NEG
40992: PUSH
40993: EMPTY
40994: LIST
40995: LIST
40996: PUSH
40997: LD_INT 2
40999: NEG
41000: PUSH
41001: LD_INT 5
41003: NEG
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 3
41011: PUSH
41012: LD_INT 0
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 3
41021: PUSH
41022: LD_INT 1
41024: NEG
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: LD_INT 4
41032: PUSH
41033: LD_INT 0
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: LD_INT 4
41042: PUSH
41043: LD_INT 1
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 3
41052: PUSH
41053: LD_INT 1
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 2
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 2
41072: PUSH
41073: LD_INT 1
41075: NEG
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 2
41083: PUSH
41084: LD_INT 2
41086: NEG
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: LD_INT 4
41094: PUSH
41095: LD_INT 2
41097: PUSH
41098: EMPTY
41099: LIST
41100: LIST
41101: PUSH
41102: LD_INT 4
41104: PUSH
41105: LD_INT 4
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PUSH
41112: LD_INT 4
41114: PUSH
41115: LD_INT 3
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PUSH
41122: LD_INT 5
41124: PUSH
41125: LD_INT 4
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 5
41134: PUSH
41135: LD_INT 5
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 4
41144: PUSH
41145: LD_INT 5
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 3
41154: PUSH
41155: LD_INT 4
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 3
41164: PUSH
41165: LD_INT 3
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 5
41174: PUSH
41175: LD_INT 3
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 3
41184: PUSH
41185: LD_INT 5
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 0
41194: PUSH
41195: LD_INT 3
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 0
41204: PUSH
41205: LD_INT 2
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 1
41214: PUSH
41215: LD_INT 3
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: LD_INT 1
41224: PUSH
41225: LD_INT 4
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: PUSH
41232: LD_INT 0
41234: PUSH
41235: LD_INT 4
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: LD_INT 1
41244: NEG
41245: PUSH
41246: LD_INT 3
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: LD_INT 1
41255: NEG
41256: PUSH
41257: LD_INT 2
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 2
41266: PUSH
41267: LD_INT 4
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 2
41276: NEG
41277: PUSH
41278: LD_INT 2
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 4
41287: NEG
41288: PUSH
41289: LD_INT 0
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: PUSH
41296: LD_INT 4
41298: NEG
41299: PUSH
41300: LD_INT 1
41302: NEG
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: LD_INT 3
41310: NEG
41311: PUSH
41312: LD_INT 0
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 3
41321: NEG
41322: PUSH
41323: LD_INT 1
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 4
41332: NEG
41333: PUSH
41334: LD_INT 1
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PUSH
41341: LD_INT 5
41343: NEG
41344: PUSH
41345: LD_INT 0
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: LD_INT 5
41354: NEG
41355: PUSH
41356: LD_INT 1
41358: NEG
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: PUSH
41364: LD_INT 5
41366: NEG
41367: PUSH
41368: LD_INT 2
41370: NEG
41371: PUSH
41372: EMPTY
41373: LIST
41374: LIST
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: LD_INT 2
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: LIST
41391: LIST
41392: LIST
41393: LIST
41394: LIST
41395: LIST
41396: LIST
41397: LIST
41398: LIST
41399: LIST
41400: LIST
41401: LIST
41402: LIST
41403: LIST
41404: LIST
41405: LIST
41406: LIST
41407: LIST
41408: LIST
41409: LIST
41410: LIST
41411: LIST
41412: LIST
41413: LIST
41414: LIST
41415: LIST
41416: LIST
41417: LIST
41418: LIST
41419: LIST
41420: LIST
41421: LIST
41422: LIST
41423: LIST
41424: LIST
41425: LIST
41426: LIST
41427: LIST
41428: LIST
41429: LIST
41430: LIST
41431: LIST
41432: LIST
41433: ST_TO_ADDR
// end ; end ;
41434: GO 41437
41436: POP
// case btype of b_depot , b_warehouse :
41437: LD_VAR 0 1
41441: PUSH
41442: LD_INT 0
41444: DOUBLE
41445: EQUAL
41446: IFTRUE 41456
41448: LD_INT 1
41450: DOUBLE
41451: EQUAL
41452: IFTRUE 41456
41454: GO 41657
41456: POP
// case nation of nation_american :
41457: LD_VAR 0 5
41461: PUSH
41462: LD_INT 1
41464: DOUBLE
41465: EQUAL
41466: IFTRUE 41470
41468: GO 41526
41470: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41471: LD_ADDR_VAR 0 9
41475: PUSH
41476: LD_VAR 0 11
41480: PUSH
41481: LD_VAR 0 12
41485: PUSH
41486: LD_VAR 0 13
41490: PUSH
41491: LD_VAR 0 14
41495: PUSH
41496: LD_VAR 0 15
41500: PUSH
41501: LD_VAR 0 16
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: LIST
41510: LIST
41511: LIST
41512: LIST
41513: PUSH
41514: LD_VAR 0 4
41518: PUSH
41519: LD_INT 1
41521: PLUS
41522: ARRAY
41523: ST_TO_ADDR
41524: GO 41655
41526: LD_INT 2
41528: DOUBLE
41529: EQUAL
41530: IFTRUE 41534
41532: GO 41590
41534: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41535: LD_ADDR_VAR 0 9
41539: PUSH
41540: LD_VAR 0 17
41544: PUSH
41545: LD_VAR 0 18
41549: PUSH
41550: LD_VAR 0 19
41554: PUSH
41555: LD_VAR 0 20
41559: PUSH
41560: LD_VAR 0 21
41564: PUSH
41565: LD_VAR 0 22
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: LIST
41574: LIST
41575: LIST
41576: LIST
41577: PUSH
41578: LD_VAR 0 4
41582: PUSH
41583: LD_INT 1
41585: PLUS
41586: ARRAY
41587: ST_TO_ADDR
41588: GO 41655
41590: LD_INT 3
41592: DOUBLE
41593: EQUAL
41594: IFTRUE 41598
41596: GO 41654
41598: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41599: LD_ADDR_VAR 0 9
41603: PUSH
41604: LD_VAR 0 23
41608: PUSH
41609: LD_VAR 0 24
41613: PUSH
41614: LD_VAR 0 25
41618: PUSH
41619: LD_VAR 0 26
41623: PUSH
41624: LD_VAR 0 27
41628: PUSH
41629: LD_VAR 0 28
41633: PUSH
41634: EMPTY
41635: LIST
41636: LIST
41637: LIST
41638: LIST
41639: LIST
41640: LIST
41641: PUSH
41642: LD_VAR 0 4
41646: PUSH
41647: LD_INT 1
41649: PLUS
41650: ARRAY
41651: ST_TO_ADDR
41652: GO 41655
41654: POP
41655: GO 42210
41657: LD_INT 2
41659: DOUBLE
41660: EQUAL
41661: IFTRUE 41671
41663: LD_INT 3
41665: DOUBLE
41666: EQUAL
41667: IFTRUE 41671
41669: GO 41727
41671: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41672: LD_ADDR_VAR 0 9
41676: PUSH
41677: LD_VAR 0 29
41681: PUSH
41682: LD_VAR 0 30
41686: PUSH
41687: LD_VAR 0 31
41691: PUSH
41692: LD_VAR 0 32
41696: PUSH
41697: LD_VAR 0 33
41701: PUSH
41702: LD_VAR 0 34
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: LIST
41711: LIST
41712: LIST
41713: LIST
41714: PUSH
41715: LD_VAR 0 4
41719: PUSH
41720: LD_INT 1
41722: PLUS
41723: ARRAY
41724: ST_TO_ADDR
41725: GO 42210
41727: LD_INT 16
41729: DOUBLE
41730: EQUAL
41731: IFTRUE 41789
41733: LD_INT 17
41735: DOUBLE
41736: EQUAL
41737: IFTRUE 41789
41739: LD_INT 18
41741: DOUBLE
41742: EQUAL
41743: IFTRUE 41789
41745: LD_INT 19
41747: DOUBLE
41748: EQUAL
41749: IFTRUE 41789
41751: LD_INT 22
41753: DOUBLE
41754: EQUAL
41755: IFTRUE 41789
41757: LD_INT 20
41759: DOUBLE
41760: EQUAL
41761: IFTRUE 41789
41763: LD_INT 21
41765: DOUBLE
41766: EQUAL
41767: IFTRUE 41789
41769: LD_INT 23
41771: DOUBLE
41772: EQUAL
41773: IFTRUE 41789
41775: LD_INT 24
41777: DOUBLE
41778: EQUAL
41779: IFTRUE 41789
41781: LD_INT 25
41783: DOUBLE
41784: EQUAL
41785: IFTRUE 41789
41787: GO 41845
41789: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41790: LD_ADDR_VAR 0 9
41794: PUSH
41795: LD_VAR 0 35
41799: PUSH
41800: LD_VAR 0 36
41804: PUSH
41805: LD_VAR 0 37
41809: PUSH
41810: LD_VAR 0 38
41814: PUSH
41815: LD_VAR 0 39
41819: PUSH
41820: LD_VAR 0 40
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: LIST
41829: LIST
41830: LIST
41831: LIST
41832: PUSH
41833: LD_VAR 0 4
41837: PUSH
41838: LD_INT 1
41840: PLUS
41841: ARRAY
41842: ST_TO_ADDR
41843: GO 42210
41845: LD_INT 6
41847: DOUBLE
41848: EQUAL
41849: IFTRUE 41901
41851: LD_INT 7
41853: DOUBLE
41854: EQUAL
41855: IFTRUE 41901
41857: LD_INT 8
41859: DOUBLE
41860: EQUAL
41861: IFTRUE 41901
41863: LD_INT 13
41865: DOUBLE
41866: EQUAL
41867: IFTRUE 41901
41869: LD_INT 12
41871: DOUBLE
41872: EQUAL
41873: IFTRUE 41901
41875: LD_INT 15
41877: DOUBLE
41878: EQUAL
41879: IFTRUE 41901
41881: LD_INT 11
41883: DOUBLE
41884: EQUAL
41885: IFTRUE 41901
41887: LD_INT 14
41889: DOUBLE
41890: EQUAL
41891: IFTRUE 41901
41893: LD_INT 10
41895: DOUBLE
41896: EQUAL
41897: IFTRUE 41901
41899: GO 41957
41901: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41902: LD_ADDR_VAR 0 9
41906: PUSH
41907: LD_VAR 0 41
41911: PUSH
41912: LD_VAR 0 42
41916: PUSH
41917: LD_VAR 0 43
41921: PUSH
41922: LD_VAR 0 44
41926: PUSH
41927: LD_VAR 0 45
41931: PUSH
41932: LD_VAR 0 46
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: LIST
41941: LIST
41942: LIST
41943: LIST
41944: PUSH
41945: LD_VAR 0 4
41949: PUSH
41950: LD_INT 1
41952: PLUS
41953: ARRAY
41954: ST_TO_ADDR
41955: GO 42210
41957: LD_INT 36
41959: DOUBLE
41960: EQUAL
41961: IFTRUE 41965
41963: GO 42021
41965: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
41966: LD_ADDR_VAR 0 9
41970: PUSH
41971: LD_VAR 0 47
41975: PUSH
41976: LD_VAR 0 48
41980: PUSH
41981: LD_VAR 0 49
41985: PUSH
41986: LD_VAR 0 50
41990: PUSH
41991: LD_VAR 0 51
41995: PUSH
41996: LD_VAR 0 52
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: LIST
42005: LIST
42006: LIST
42007: LIST
42008: PUSH
42009: LD_VAR 0 4
42013: PUSH
42014: LD_INT 1
42016: PLUS
42017: ARRAY
42018: ST_TO_ADDR
42019: GO 42210
42021: LD_INT 4
42023: DOUBLE
42024: EQUAL
42025: IFTRUE 42047
42027: LD_INT 5
42029: DOUBLE
42030: EQUAL
42031: IFTRUE 42047
42033: LD_INT 34
42035: DOUBLE
42036: EQUAL
42037: IFTRUE 42047
42039: LD_INT 37
42041: DOUBLE
42042: EQUAL
42043: IFTRUE 42047
42045: GO 42103
42047: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42048: LD_ADDR_VAR 0 9
42052: PUSH
42053: LD_VAR 0 53
42057: PUSH
42058: LD_VAR 0 54
42062: PUSH
42063: LD_VAR 0 55
42067: PUSH
42068: LD_VAR 0 56
42072: PUSH
42073: LD_VAR 0 57
42077: PUSH
42078: LD_VAR 0 58
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: PUSH
42091: LD_VAR 0 4
42095: PUSH
42096: LD_INT 1
42098: PLUS
42099: ARRAY
42100: ST_TO_ADDR
42101: GO 42210
42103: LD_INT 31
42105: DOUBLE
42106: EQUAL
42107: IFTRUE 42153
42109: LD_INT 32
42111: DOUBLE
42112: EQUAL
42113: IFTRUE 42153
42115: LD_INT 33
42117: DOUBLE
42118: EQUAL
42119: IFTRUE 42153
42121: LD_INT 27
42123: DOUBLE
42124: EQUAL
42125: IFTRUE 42153
42127: LD_INT 26
42129: DOUBLE
42130: EQUAL
42131: IFTRUE 42153
42133: LD_INT 28
42135: DOUBLE
42136: EQUAL
42137: IFTRUE 42153
42139: LD_INT 29
42141: DOUBLE
42142: EQUAL
42143: IFTRUE 42153
42145: LD_INT 30
42147: DOUBLE
42148: EQUAL
42149: IFTRUE 42153
42151: GO 42209
42153: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42154: LD_ADDR_VAR 0 9
42158: PUSH
42159: LD_VAR 0 59
42163: PUSH
42164: LD_VAR 0 60
42168: PUSH
42169: LD_VAR 0 61
42173: PUSH
42174: LD_VAR 0 62
42178: PUSH
42179: LD_VAR 0 63
42183: PUSH
42184: LD_VAR 0 64
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: LIST
42196: PUSH
42197: LD_VAR 0 4
42201: PUSH
42202: LD_INT 1
42204: PLUS
42205: ARRAY
42206: ST_TO_ADDR
42207: GO 42210
42209: POP
// temp_list2 = [ ] ;
42210: LD_ADDR_VAR 0 10
42214: PUSH
42215: EMPTY
42216: ST_TO_ADDR
// for i in temp_list do
42217: LD_ADDR_VAR 0 8
42221: PUSH
42222: LD_VAR 0 9
42226: PUSH
42227: FOR_IN
42228: IFFALSE 42280
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42230: LD_ADDR_VAR 0 10
42234: PUSH
42235: LD_VAR 0 10
42239: PUSH
42240: LD_VAR 0 8
42244: PUSH
42245: LD_INT 1
42247: ARRAY
42248: PUSH
42249: LD_VAR 0 2
42253: PLUS
42254: PUSH
42255: LD_VAR 0 8
42259: PUSH
42260: LD_INT 2
42262: ARRAY
42263: PUSH
42264: LD_VAR 0 3
42268: PLUS
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: EMPTY
42275: LIST
42276: ADD
42277: ST_TO_ADDR
42278: GO 42227
42280: POP
42281: POP
// result = temp_list2 ;
42282: LD_ADDR_VAR 0 7
42286: PUSH
42287: LD_VAR 0 10
42291: ST_TO_ADDR
// end ;
42292: LD_VAR 0 7
42296: RET
// export function EnemyInRange ( unit , dist ) ; begin
42297: LD_INT 0
42299: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42300: LD_ADDR_VAR 0 3
42304: PUSH
42305: LD_VAR 0 1
42309: PPUSH
42310: CALL_OW 255
42314: PPUSH
42315: LD_VAR 0 1
42319: PPUSH
42320: CALL_OW 250
42324: PPUSH
42325: LD_VAR 0 1
42329: PPUSH
42330: CALL_OW 251
42334: PPUSH
42335: LD_VAR 0 2
42339: PPUSH
42340: CALL 15670 0 4
42344: PUSH
42345: LD_INT 4
42347: ARRAY
42348: ST_TO_ADDR
// end ;
42349: LD_VAR 0 3
42353: RET
// export function PlayerSeeMe ( unit ) ; begin
42354: LD_INT 0
42356: PPUSH
// result := See ( your_side , unit ) ;
42357: LD_ADDR_VAR 0 2
42361: PUSH
42362: LD_OWVAR 2
42366: PPUSH
42367: LD_VAR 0 1
42371: PPUSH
42372: CALL_OW 292
42376: ST_TO_ADDR
// end ;
42377: LD_VAR 0 2
42381: RET
// export function ReverseDir ( unit ) ; begin
42382: LD_INT 0
42384: PPUSH
// if not unit then
42385: LD_VAR 0 1
42389: NOT
42390: IFFALSE 42394
// exit ;
42392: GO 42417
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42394: LD_ADDR_VAR 0 2
42398: PUSH
42399: LD_VAR 0 1
42403: PPUSH
42404: CALL_OW 254
42408: PUSH
42409: LD_INT 3
42411: PLUS
42412: PUSH
42413: LD_INT 6
42415: MOD
42416: ST_TO_ADDR
// end ;
42417: LD_VAR 0 2
42421: RET
// export function ReverseArray ( array ) ; var i ; begin
42422: LD_INT 0
42424: PPUSH
42425: PPUSH
// if not array then
42426: LD_VAR 0 1
42430: NOT
42431: IFFALSE 42435
// exit ;
42433: GO 42490
// result := [ ] ;
42435: LD_ADDR_VAR 0 2
42439: PUSH
42440: EMPTY
42441: ST_TO_ADDR
// for i := array downto 1 do
42442: LD_ADDR_VAR 0 3
42446: PUSH
42447: DOUBLE
42448: LD_VAR 0 1
42452: INC
42453: ST_TO_ADDR
42454: LD_INT 1
42456: PUSH
42457: FOR_DOWNTO
42458: IFFALSE 42488
// result := Join ( result , array [ i ] ) ;
42460: LD_ADDR_VAR 0 2
42464: PUSH
42465: LD_VAR 0 2
42469: PPUSH
42470: LD_VAR 0 1
42474: PUSH
42475: LD_VAR 0 3
42479: ARRAY
42480: PPUSH
42481: CALL 47133 0 2
42485: ST_TO_ADDR
42486: GO 42457
42488: POP
42489: POP
// end ;
42490: LD_VAR 0 2
42494: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
42495: LD_INT 0
42497: PPUSH
42498: PPUSH
42499: PPUSH
42500: PPUSH
42501: PPUSH
42502: PPUSH
// if not unit or not hexes then
42503: LD_VAR 0 1
42507: NOT
42508: PUSH
42509: LD_VAR 0 2
42513: NOT
42514: OR
42515: IFFALSE 42519
// exit ;
42517: GO 42642
// dist := 9999 ;
42519: LD_ADDR_VAR 0 5
42523: PUSH
42524: LD_INT 9999
42526: ST_TO_ADDR
// for i = 1 to hexes do
42527: LD_ADDR_VAR 0 4
42531: PUSH
42532: DOUBLE
42533: LD_INT 1
42535: DEC
42536: ST_TO_ADDR
42537: LD_VAR 0 2
42541: PUSH
42542: FOR_TO
42543: IFFALSE 42630
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42545: LD_ADDR_VAR 0 6
42549: PUSH
42550: LD_VAR 0 1
42554: PPUSH
42555: LD_VAR 0 2
42559: PUSH
42560: LD_VAR 0 4
42564: ARRAY
42565: PUSH
42566: LD_INT 1
42568: ARRAY
42569: PPUSH
42570: LD_VAR 0 2
42574: PUSH
42575: LD_VAR 0 4
42579: ARRAY
42580: PUSH
42581: LD_INT 2
42583: ARRAY
42584: PPUSH
42585: CALL_OW 297
42589: ST_TO_ADDR
// if tdist < dist then
42590: LD_VAR 0 6
42594: PUSH
42595: LD_VAR 0 5
42599: LESS
42600: IFFALSE 42628
// begin hex := hexes [ i ] ;
42602: LD_ADDR_VAR 0 8
42606: PUSH
42607: LD_VAR 0 2
42611: PUSH
42612: LD_VAR 0 4
42616: ARRAY
42617: ST_TO_ADDR
// dist := tdist ;
42618: LD_ADDR_VAR 0 5
42622: PUSH
42623: LD_VAR 0 6
42627: ST_TO_ADDR
// end ; end ;
42628: GO 42542
42630: POP
42631: POP
// result := hex ;
42632: LD_ADDR_VAR 0 3
42636: PUSH
42637: LD_VAR 0 8
42641: ST_TO_ADDR
// end ;
42642: LD_VAR 0 3
42646: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42647: LD_INT 0
42649: PPUSH
42650: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42651: LD_VAR 0 1
42655: NOT
42656: PUSH
42657: LD_VAR 0 1
42661: PUSH
42662: LD_INT 21
42664: PUSH
42665: LD_INT 2
42667: PUSH
42668: EMPTY
42669: LIST
42670: LIST
42671: PUSH
42672: LD_INT 23
42674: PUSH
42675: LD_INT 2
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PPUSH
42686: CALL_OW 69
42690: IN
42691: NOT
42692: OR
42693: IFFALSE 42697
// exit ;
42695: GO 42744
// for i = 1 to 3 do
42697: LD_ADDR_VAR 0 3
42701: PUSH
42702: DOUBLE
42703: LD_INT 1
42705: DEC
42706: ST_TO_ADDR
42707: LD_INT 3
42709: PUSH
42710: FOR_TO
42711: IFFALSE 42742
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42713: LD_VAR 0 1
42717: PPUSH
42718: CALL_OW 250
42722: PPUSH
42723: LD_VAR 0 1
42727: PPUSH
42728: CALL_OW 251
42732: PPUSH
42733: LD_INT 1
42735: PPUSH
42736: CALL_OW 453
42740: GO 42710
42742: POP
42743: POP
// end ;
42744: LD_VAR 0 2
42748: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42749: LD_INT 0
42751: PPUSH
42752: PPUSH
42753: PPUSH
42754: PPUSH
42755: PPUSH
42756: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42757: LD_VAR 0 1
42761: NOT
42762: PUSH
42763: LD_VAR 0 2
42767: NOT
42768: OR
42769: PUSH
42770: LD_VAR 0 1
42774: PPUSH
42775: CALL_OW 314
42779: OR
42780: IFFALSE 42784
// exit ;
42782: GO 43251
// if GetLives ( i ) < 250 then
42784: LD_VAR 0 4
42788: PPUSH
42789: CALL_OW 256
42793: PUSH
42794: LD_INT 250
42796: LESS
42797: IFFALSE 42810
// begin ComAutodestruct ( i ) ;
42799: LD_VAR 0 4
42803: PPUSH
42804: CALL 42647 0 1
// exit ;
42808: GO 43251
// end ; x := GetX ( enemy_unit ) ;
42810: LD_ADDR_VAR 0 7
42814: PUSH
42815: LD_VAR 0 2
42819: PPUSH
42820: CALL_OW 250
42824: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42825: LD_ADDR_VAR 0 8
42829: PUSH
42830: LD_VAR 0 2
42834: PPUSH
42835: CALL_OW 251
42839: ST_TO_ADDR
// if not x or not y then
42840: LD_VAR 0 7
42844: NOT
42845: PUSH
42846: LD_VAR 0 8
42850: NOT
42851: OR
42852: IFFALSE 42856
// exit ;
42854: GO 43251
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42856: LD_ADDR_VAR 0 6
42860: PUSH
42861: LD_VAR 0 7
42865: PPUSH
42866: LD_INT 0
42868: PPUSH
42869: LD_INT 4
42871: PPUSH
42872: CALL_OW 272
42876: PUSH
42877: LD_VAR 0 8
42881: PPUSH
42882: LD_INT 0
42884: PPUSH
42885: LD_INT 4
42887: PPUSH
42888: CALL_OW 273
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: LD_VAR 0 7
42901: PPUSH
42902: LD_INT 1
42904: PPUSH
42905: LD_INT 4
42907: PPUSH
42908: CALL_OW 272
42912: PUSH
42913: LD_VAR 0 8
42917: PPUSH
42918: LD_INT 1
42920: PPUSH
42921: LD_INT 4
42923: PPUSH
42924: CALL_OW 273
42928: PUSH
42929: EMPTY
42930: LIST
42931: LIST
42932: PUSH
42933: LD_VAR 0 7
42937: PPUSH
42938: LD_INT 2
42940: PPUSH
42941: LD_INT 4
42943: PPUSH
42944: CALL_OW 272
42948: PUSH
42949: LD_VAR 0 8
42953: PPUSH
42954: LD_INT 2
42956: PPUSH
42957: LD_INT 4
42959: PPUSH
42960: CALL_OW 273
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: PUSH
42969: LD_VAR 0 7
42973: PPUSH
42974: LD_INT 3
42976: PPUSH
42977: LD_INT 4
42979: PPUSH
42980: CALL_OW 272
42984: PUSH
42985: LD_VAR 0 8
42989: PPUSH
42990: LD_INT 3
42992: PPUSH
42993: LD_INT 4
42995: PPUSH
42996: CALL_OW 273
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_VAR 0 7
43009: PPUSH
43010: LD_INT 4
43012: PPUSH
43013: LD_INT 4
43015: PPUSH
43016: CALL_OW 272
43020: PUSH
43021: LD_VAR 0 8
43025: PPUSH
43026: LD_INT 4
43028: PPUSH
43029: LD_INT 4
43031: PPUSH
43032: CALL_OW 273
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PUSH
43041: LD_VAR 0 7
43045: PPUSH
43046: LD_INT 5
43048: PPUSH
43049: LD_INT 4
43051: PPUSH
43052: CALL_OW 272
43056: PUSH
43057: LD_VAR 0 8
43061: PPUSH
43062: LD_INT 5
43064: PPUSH
43065: LD_INT 4
43067: PPUSH
43068: CALL_OW 273
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: LIST
43081: LIST
43082: LIST
43083: LIST
43084: ST_TO_ADDR
// for i = tmp downto 1 do
43085: LD_ADDR_VAR 0 4
43089: PUSH
43090: DOUBLE
43091: LD_VAR 0 6
43095: INC
43096: ST_TO_ADDR
43097: LD_INT 1
43099: PUSH
43100: FOR_DOWNTO
43101: IFFALSE 43202
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43103: LD_VAR 0 6
43107: PUSH
43108: LD_VAR 0 4
43112: ARRAY
43113: PUSH
43114: LD_INT 1
43116: ARRAY
43117: PPUSH
43118: LD_VAR 0 6
43122: PUSH
43123: LD_VAR 0 4
43127: ARRAY
43128: PUSH
43129: LD_INT 2
43131: ARRAY
43132: PPUSH
43133: CALL_OW 488
43137: NOT
43138: PUSH
43139: LD_VAR 0 6
43143: PUSH
43144: LD_VAR 0 4
43148: ARRAY
43149: PUSH
43150: LD_INT 1
43152: ARRAY
43153: PPUSH
43154: LD_VAR 0 6
43158: PUSH
43159: LD_VAR 0 4
43163: ARRAY
43164: PUSH
43165: LD_INT 2
43167: ARRAY
43168: PPUSH
43169: CALL_OW 428
43173: PUSH
43174: LD_INT 0
43176: NONEQUAL
43177: OR
43178: IFFALSE 43200
// tmp := Delete ( tmp , i ) ;
43180: LD_ADDR_VAR 0 6
43184: PUSH
43185: LD_VAR 0 6
43189: PPUSH
43190: LD_VAR 0 4
43194: PPUSH
43195: CALL_OW 3
43199: ST_TO_ADDR
43200: GO 43100
43202: POP
43203: POP
// j := GetClosestHex ( unit , tmp ) ;
43204: LD_ADDR_VAR 0 5
43208: PUSH
43209: LD_VAR 0 1
43213: PPUSH
43214: LD_VAR 0 6
43218: PPUSH
43219: CALL 42495 0 2
43223: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43224: LD_VAR 0 1
43228: PPUSH
43229: LD_VAR 0 5
43233: PUSH
43234: LD_INT 1
43236: ARRAY
43237: PPUSH
43238: LD_VAR 0 5
43242: PUSH
43243: LD_INT 2
43245: ARRAY
43246: PPUSH
43247: CALL_OW 111
// end ;
43251: LD_VAR 0 3
43255: RET
// export function PrepareApemanSoldier ( ) ; begin
43256: LD_INT 0
43258: PPUSH
// uc_nation := 0 ;
43259: LD_ADDR_OWVAR 21
43263: PUSH
43264: LD_INT 0
43266: ST_TO_ADDR
// hc_sex := sex_male ;
43267: LD_ADDR_OWVAR 27
43271: PUSH
43272: LD_INT 1
43274: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
43275: LD_ADDR_OWVAR 28
43279: PUSH
43280: LD_INT 15
43282: ST_TO_ADDR
// hc_gallery :=  ;
43283: LD_ADDR_OWVAR 33
43287: PUSH
43288: LD_STRING 
43290: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43291: LD_ADDR_OWVAR 31
43295: PUSH
43296: LD_INT 0
43298: PPUSH
43299: LD_INT 3
43301: PPUSH
43302: CALL_OW 12
43306: PUSH
43307: LD_INT 0
43309: PPUSH
43310: LD_INT 3
43312: PPUSH
43313: CALL_OW 12
43317: PUSH
43318: LD_INT 0
43320: PUSH
43321: LD_INT 0
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: LIST
43328: LIST
43329: ST_TO_ADDR
// end ;
43330: LD_VAR 0 1
43334: RET
// export function PrepareApemanEngineer ( ) ; begin
43335: LD_INT 0
43337: PPUSH
// uc_nation := 0 ;
43338: LD_ADDR_OWVAR 21
43342: PUSH
43343: LD_INT 0
43345: ST_TO_ADDR
// hc_sex := sex_male ;
43346: LD_ADDR_OWVAR 27
43350: PUSH
43351: LD_INT 1
43353: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
43354: LD_ADDR_OWVAR 28
43358: PUSH
43359: LD_INT 16
43361: ST_TO_ADDR
// hc_gallery :=  ;
43362: LD_ADDR_OWVAR 33
43366: PUSH
43367: LD_STRING 
43369: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43370: LD_ADDR_OWVAR 31
43374: PUSH
43375: LD_INT 0
43377: PPUSH
43378: LD_INT 3
43380: PPUSH
43381: CALL_OW 12
43385: PUSH
43386: LD_INT 0
43388: PPUSH
43389: LD_INT 3
43391: PPUSH
43392: CALL_OW 12
43396: PUSH
43397: LD_INT 0
43399: PUSH
43400: LD_INT 0
43402: PUSH
43403: EMPTY
43404: LIST
43405: LIST
43406: LIST
43407: LIST
43408: ST_TO_ADDR
// end ;
43409: LD_VAR 0 1
43413: RET
// export function PrepareApeman ( agressivity ) ; begin
43414: LD_INT 0
43416: PPUSH
// uc_side := 0 ;
43417: LD_ADDR_OWVAR 20
43421: PUSH
43422: LD_INT 0
43424: ST_TO_ADDR
// uc_nation := 0 ;
43425: LD_ADDR_OWVAR 21
43429: PUSH
43430: LD_INT 0
43432: ST_TO_ADDR
// hc_sex := sex_male ;
43433: LD_ADDR_OWVAR 27
43437: PUSH
43438: LD_INT 1
43440: ST_TO_ADDR
// hc_class := class_apeman ;
43441: LD_ADDR_OWVAR 28
43445: PUSH
43446: LD_INT 12
43448: ST_TO_ADDR
// hc_gallery :=  ;
43449: LD_ADDR_OWVAR 33
43453: PUSH
43454: LD_STRING 
43456: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43457: LD_ADDR_OWVAR 35
43461: PUSH
43462: LD_VAR 0 1
43466: NEG
43467: PPUSH
43468: LD_VAR 0 1
43472: PPUSH
43473: CALL_OW 12
43477: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
43478: LD_ADDR_OWVAR 31
43482: PUSH
43483: LD_INT 0
43485: PPUSH
43486: LD_INT 3
43488: PPUSH
43489: CALL_OW 12
43493: PUSH
43494: LD_INT 0
43496: PPUSH
43497: LD_INT 3
43499: PPUSH
43500: CALL_OW 12
43504: PUSH
43505: LD_INT 0
43507: PUSH
43508: LD_INT 0
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: LIST
43515: LIST
43516: ST_TO_ADDR
// end ;
43517: LD_VAR 0 2
43521: RET
// export function PrepareTiger ( agressivity ) ; begin
43522: LD_INT 0
43524: PPUSH
// uc_side := 0 ;
43525: LD_ADDR_OWVAR 20
43529: PUSH
43530: LD_INT 0
43532: ST_TO_ADDR
// uc_nation := 0 ;
43533: LD_ADDR_OWVAR 21
43537: PUSH
43538: LD_INT 0
43540: ST_TO_ADDR
// hc_class := class_tiger ;
43541: LD_ADDR_OWVAR 28
43545: PUSH
43546: LD_INT 14
43548: ST_TO_ADDR
// hc_gallery :=  ;
43549: LD_ADDR_OWVAR 33
43553: PUSH
43554: LD_STRING 
43556: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
43557: LD_ADDR_OWVAR 35
43561: PUSH
43562: LD_VAR 0 1
43566: NEG
43567: PPUSH
43568: LD_VAR 0 1
43572: PPUSH
43573: CALL_OW 12
43577: ST_TO_ADDR
// end ;
43578: LD_VAR 0 2
43582: RET
// export function PrepareEnchidna ( ) ; begin
43583: LD_INT 0
43585: PPUSH
// uc_side := 0 ;
43586: LD_ADDR_OWVAR 20
43590: PUSH
43591: LD_INT 0
43593: ST_TO_ADDR
// uc_nation := 0 ;
43594: LD_ADDR_OWVAR 21
43598: PUSH
43599: LD_INT 0
43601: ST_TO_ADDR
// hc_class := class_baggie ;
43602: LD_ADDR_OWVAR 28
43606: PUSH
43607: LD_INT 13
43609: ST_TO_ADDR
// hc_gallery :=  ;
43610: LD_ADDR_OWVAR 33
43614: PUSH
43615: LD_STRING 
43617: ST_TO_ADDR
// end ;
43618: LD_VAR 0 1
43622: RET
// export function PrepareFrog ( ) ; begin
43623: LD_INT 0
43625: PPUSH
// uc_side := 0 ;
43626: LD_ADDR_OWVAR 20
43630: PUSH
43631: LD_INT 0
43633: ST_TO_ADDR
// uc_nation := 0 ;
43634: LD_ADDR_OWVAR 21
43638: PUSH
43639: LD_INT 0
43641: ST_TO_ADDR
// hc_class := class_frog ;
43642: LD_ADDR_OWVAR 28
43646: PUSH
43647: LD_INT 19
43649: ST_TO_ADDR
// hc_gallery :=  ;
43650: LD_ADDR_OWVAR 33
43654: PUSH
43655: LD_STRING 
43657: ST_TO_ADDR
// end ;
43658: LD_VAR 0 1
43662: RET
// export function PrepareFish ( ) ; begin
43663: LD_INT 0
43665: PPUSH
// uc_side := 0 ;
43666: LD_ADDR_OWVAR 20
43670: PUSH
43671: LD_INT 0
43673: ST_TO_ADDR
// uc_nation := 0 ;
43674: LD_ADDR_OWVAR 21
43678: PUSH
43679: LD_INT 0
43681: ST_TO_ADDR
// hc_class := class_fish ;
43682: LD_ADDR_OWVAR 28
43686: PUSH
43687: LD_INT 20
43689: ST_TO_ADDR
// hc_gallery :=  ;
43690: LD_ADDR_OWVAR 33
43694: PUSH
43695: LD_STRING 
43697: ST_TO_ADDR
// end ;
43698: LD_VAR 0 1
43702: RET
// export function PrepareBird ( ) ; begin
43703: LD_INT 0
43705: PPUSH
// uc_side := 0 ;
43706: LD_ADDR_OWVAR 20
43710: PUSH
43711: LD_INT 0
43713: ST_TO_ADDR
// uc_nation := 0 ;
43714: LD_ADDR_OWVAR 21
43718: PUSH
43719: LD_INT 0
43721: ST_TO_ADDR
// hc_class := class_phororhacos ;
43722: LD_ADDR_OWVAR 28
43726: PUSH
43727: LD_INT 18
43729: ST_TO_ADDR
// hc_gallery :=  ;
43730: LD_ADDR_OWVAR 33
43734: PUSH
43735: LD_STRING 
43737: ST_TO_ADDR
// end ;
43738: LD_VAR 0 1
43742: RET
// export function PrepareHorse ( ) ; begin
43743: LD_INT 0
43745: PPUSH
// uc_side := 0 ;
43746: LD_ADDR_OWVAR 20
43750: PUSH
43751: LD_INT 0
43753: ST_TO_ADDR
// uc_nation := 0 ;
43754: LD_ADDR_OWVAR 21
43758: PUSH
43759: LD_INT 0
43761: ST_TO_ADDR
// hc_class := class_horse ;
43762: LD_ADDR_OWVAR 28
43766: PUSH
43767: LD_INT 21
43769: ST_TO_ADDR
// hc_gallery :=  ;
43770: LD_ADDR_OWVAR 33
43774: PUSH
43775: LD_STRING 
43777: ST_TO_ADDR
// end ;
43778: LD_VAR 0 1
43782: RET
// export function PrepareMastodont ( ) ; begin
43783: LD_INT 0
43785: PPUSH
// uc_side := 0 ;
43786: LD_ADDR_OWVAR 20
43790: PUSH
43791: LD_INT 0
43793: ST_TO_ADDR
// uc_nation := 0 ;
43794: LD_ADDR_OWVAR 21
43798: PUSH
43799: LD_INT 0
43801: ST_TO_ADDR
// vc_chassis := class_mastodont ;
43802: LD_ADDR_OWVAR 37
43806: PUSH
43807: LD_INT 31
43809: ST_TO_ADDR
// vc_control := control_rider ;
43810: LD_ADDR_OWVAR 38
43814: PUSH
43815: LD_INT 4
43817: ST_TO_ADDR
// end ;
43818: LD_VAR 0 1
43822: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43823: LD_INT 0
43825: PPUSH
43826: PPUSH
43827: PPUSH
// uc_side = 0 ;
43828: LD_ADDR_OWVAR 20
43832: PUSH
43833: LD_INT 0
43835: ST_TO_ADDR
// uc_nation = 0 ;
43836: LD_ADDR_OWVAR 21
43840: PUSH
43841: LD_INT 0
43843: ST_TO_ADDR
// InitHc_All ( ) ;
43844: CALL_OW 584
// InitVc ;
43848: CALL_OW 20
// if mastodonts then
43852: LD_VAR 0 6
43856: IFFALSE 43923
// for i = 1 to mastodonts do
43858: LD_ADDR_VAR 0 11
43862: PUSH
43863: DOUBLE
43864: LD_INT 1
43866: DEC
43867: ST_TO_ADDR
43868: LD_VAR 0 6
43872: PUSH
43873: FOR_TO
43874: IFFALSE 43921
// begin vc_chassis := 31 ;
43876: LD_ADDR_OWVAR 37
43880: PUSH
43881: LD_INT 31
43883: ST_TO_ADDR
// vc_control := control_rider ;
43884: LD_ADDR_OWVAR 38
43888: PUSH
43889: LD_INT 4
43891: ST_TO_ADDR
// animal := CreateVehicle ;
43892: LD_ADDR_VAR 0 12
43896: PUSH
43897: CALL_OW 45
43901: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43902: LD_VAR 0 12
43906: PPUSH
43907: LD_VAR 0 8
43911: PPUSH
43912: LD_INT 0
43914: PPUSH
43915: CALL 46051 0 3
// end ;
43919: GO 43873
43921: POP
43922: POP
// if horses then
43923: LD_VAR 0 5
43927: IFFALSE 43994
// for i = 1 to horses do
43929: LD_ADDR_VAR 0 11
43933: PUSH
43934: DOUBLE
43935: LD_INT 1
43937: DEC
43938: ST_TO_ADDR
43939: LD_VAR 0 5
43943: PUSH
43944: FOR_TO
43945: IFFALSE 43992
// begin hc_class := 21 ;
43947: LD_ADDR_OWVAR 28
43951: PUSH
43952: LD_INT 21
43954: ST_TO_ADDR
// hc_gallery :=  ;
43955: LD_ADDR_OWVAR 33
43959: PUSH
43960: LD_STRING 
43962: ST_TO_ADDR
// animal := CreateHuman ;
43963: LD_ADDR_VAR 0 12
43967: PUSH
43968: CALL_OW 44
43972: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43973: LD_VAR 0 12
43977: PPUSH
43978: LD_VAR 0 8
43982: PPUSH
43983: LD_INT 0
43985: PPUSH
43986: CALL 46051 0 3
// end ;
43990: GO 43944
43992: POP
43993: POP
// if birds then
43994: LD_VAR 0 1
43998: IFFALSE 44065
// for i = 1 to birds do
44000: LD_ADDR_VAR 0 11
44004: PUSH
44005: DOUBLE
44006: LD_INT 1
44008: DEC
44009: ST_TO_ADDR
44010: LD_VAR 0 1
44014: PUSH
44015: FOR_TO
44016: IFFALSE 44063
// begin hc_class := 18 ;
44018: LD_ADDR_OWVAR 28
44022: PUSH
44023: LD_INT 18
44025: ST_TO_ADDR
// hc_gallery =  ;
44026: LD_ADDR_OWVAR 33
44030: PUSH
44031: LD_STRING 
44033: ST_TO_ADDR
// animal := CreateHuman ;
44034: LD_ADDR_VAR 0 12
44038: PUSH
44039: CALL_OW 44
44043: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44044: LD_VAR 0 12
44048: PPUSH
44049: LD_VAR 0 8
44053: PPUSH
44054: LD_INT 0
44056: PPUSH
44057: CALL 46051 0 3
// end ;
44061: GO 44015
44063: POP
44064: POP
// if tigers then
44065: LD_VAR 0 2
44069: IFFALSE 44153
// for i = 1 to tigers do
44071: LD_ADDR_VAR 0 11
44075: PUSH
44076: DOUBLE
44077: LD_INT 1
44079: DEC
44080: ST_TO_ADDR
44081: LD_VAR 0 2
44085: PUSH
44086: FOR_TO
44087: IFFALSE 44151
// begin hc_class = class_tiger ;
44089: LD_ADDR_OWVAR 28
44093: PUSH
44094: LD_INT 14
44096: ST_TO_ADDR
// hc_gallery =  ;
44097: LD_ADDR_OWVAR 33
44101: PUSH
44102: LD_STRING 
44104: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44105: LD_ADDR_OWVAR 35
44109: PUSH
44110: LD_INT 7
44112: NEG
44113: PPUSH
44114: LD_INT 7
44116: PPUSH
44117: CALL_OW 12
44121: ST_TO_ADDR
// animal := CreateHuman ;
44122: LD_ADDR_VAR 0 12
44126: PUSH
44127: CALL_OW 44
44131: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44132: LD_VAR 0 12
44136: PPUSH
44137: LD_VAR 0 8
44141: PPUSH
44142: LD_INT 0
44144: PPUSH
44145: CALL 46051 0 3
// end ;
44149: GO 44086
44151: POP
44152: POP
// if apemans then
44153: LD_VAR 0 3
44157: IFFALSE 44280
// for i = 1 to apemans do
44159: LD_ADDR_VAR 0 11
44163: PUSH
44164: DOUBLE
44165: LD_INT 1
44167: DEC
44168: ST_TO_ADDR
44169: LD_VAR 0 3
44173: PUSH
44174: FOR_TO
44175: IFFALSE 44278
// begin hc_class = class_apeman ;
44177: LD_ADDR_OWVAR 28
44181: PUSH
44182: LD_INT 12
44184: ST_TO_ADDR
// hc_gallery =  ;
44185: LD_ADDR_OWVAR 33
44189: PUSH
44190: LD_STRING 
44192: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44193: LD_ADDR_OWVAR 35
44197: PUSH
44198: LD_INT 2
44200: NEG
44201: PPUSH
44202: LD_INT 2
44204: PPUSH
44205: CALL_OW 12
44209: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44210: LD_ADDR_OWVAR 31
44214: PUSH
44215: LD_INT 1
44217: PPUSH
44218: LD_INT 3
44220: PPUSH
44221: CALL_OW 12
44225: PUSH
44226: LD_INT 1
44228: PPUSH
44229: LD_INT 3
44231: PPUSH
44232: CALL_OW 12
44236: PUSH
44237: LD_INT 0
44239: PUSH
44240: LD_INT 0
44242: PUSH
44243: EMPTY
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: ST_TO_ADDR
// animal := CreateHuman ;
44249: LD_ADDR_VAR 0 12
44253: PUSH
44254: CALL_OW 44
44258: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44259: LD_VAR 0 12
44263: PPUSH
44264: LD_VAR 0 8
44268: PPUSH
44269: LD_INT 0
44271: PPUSH
44272: CALL 46051 0 3
// end ;
44276: GO 44174
44278: POP
44279: POP
// if enchidnas then
44280: LD_VAR 0 4
44284: IFFALSE 44351
// for i = 1 to enchidnas do
44286: LD_ADDR_VAR 0 11
44290: PUSH
44291: DOUBLE
44292: LD_INT 1
44294: DEC
44295: ST_TO_ADDR
44296: LD_VAR 0 4
44300: PUSH
44301: FOR_TO
44302: IFFALSE 44349
// begin hc_class = 13 ;
44304: LD_ADDR_OWVAR 28
44308: PUSH
44309: LD_INT 13
44311: ST_TO_ADDR
// hc_gallery =  ;
44312: LD_ADDR_OWVAR 33
44316: PUSH
44317: LD_STRING 
44319: ST_TO_ADDR
// animal := CreateHuman ;
44320: LD_ADDR_VAR 0 12
44324: PUSH
44325: CALL_OW 44
44329: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44330: LD_VAR 0 12
44334: PPUSH
44335: LD_VAR 0 8
44339: PPUSH
44340: LD_INT 0
44342: PPUSH
44343: CALL 46051 0 3
// end ;
44347: GO 44301
44349: POP
44350: POP
// if fishes then
44351: LD_VAR 0 7
44355: IFFALSE 44422
// for i = 1 to fishes do
44357: LD_ADDR_VAR 0 11
44361: PUSH
44362: DOUBLE
44363: LD_INT 1
44365: DEC
44366: ST_TO_ADDR
44367: LD_VAR 0 7
44371: PUSH
44372: FOR_TO
44373: IFFALSE 44420
// begin hc_class = 20 ;
44375: LD_ADDR_OWVAR 28
44379: PUSH
44380: LD_INT 20
44382: ST_TO_ADDR
// hc_gallery =  ;
44383: LD_ADDR_OWVAR 33
44387: PUSH
44388: LD_STRING 
44390: ST_TO_ADDR
// animal := CreateHuman ;
44391: LD_ADDR_VAR 0 12
44395: PUSH
44396: CALL_OW 44
44400: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44401: LD_VAR 0 12
44405: PPUSH
44406: LD_VAR 0 9
44410: PPUSH
44411: LD_INT 0
44413: PPUSH
44414: CALL 46051 0 3
// end ;
44418: GO 44372
44420: POP
44421: POP
// end ;
44422: LD_VAR 0 10
44426: RET
// export function WantHeal ( sci , unit ) ; begin
44427: LD_INT 0
44429: PPUSH
// if GetTaskList ( sci ) > 0 then
44430: LD_VAR 0 1
44434: PPUSH
44435: CALL_OW 437
44439: PUSH
44440: LD_INT 0
44442: GREATER
44443: IFFALSE 44513
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44445: LD_VAR 0 1
44449: PPUSH
44450: CALL_OW 437
44454: PUSH
44455: LD_INT 1
44457: ARRAY
44458: PUSH
44459: LD_INT 1
44461: ARRAY
44462: PUSH
44463: LD_STRING l
44465: EQUAL
44466: PUSH
44467: LD_VAR 0 1
44471: PPUSH
44472: CALL_OW 437
44476: PUSH
44477: LD_INT 1
44479: ARRAY
44480: PUSH
44481: LD_INT 4
44483: ARRAY
44484: PUSH
44485: LD_VAR 0 2
44489: EQUAL
44490: AND
44491: IFFALSE 44503
// result := true else
44493: LD_ADDR_VAR 0 3
44497: PUSH
44498: LD_INT 1
44500: ST_TO_ADDR
44501: GO 44511
// result := false ;
44503: LD_ADDR_VAR 0 3
44507: PUSH
44508: LD_INT 0
44510: ST_TO_ADDR
// end else
44511: GO 44521
// result := false ;
44513: LD_ADDR_VAR 0 3
44517: PUSH
44518: LD_INT 0
44520: ST_TO_ADDR
// end ;
44521: LD_VAR 0 3
44525: RET
// export function HealTarget ( sci ) ; begin
44526: LD_INT 0
44528: PPUSH
// if not sci then
44529: LD_VAR 0 1
44533: NOT
44534: IFFALSE 44538
// exit ;
44536: GO 44603
// result := 0 ;
44538: LD_ADDR_VAR 0 2
44542: PUSH
44543: LD_INT 0
44545: ST_TO_ADDR
// if GetTaskList ( sci ) then
44546: LD_VAR 0 1
44550: PPUSH
44551: CALL_OW 437
44555: IFFALSE 44603
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44557: LD_VAR 0 1
44561: PPUSH
44562: CALL_OW 437
44566: PUSH
44567: LD_INT 1
44569: ARRAY
44570: PUSH
44571: LD_INT 1
44573: ARRAY
44574: PUSH
44575: LD_STRING l
44577: EQUAL
44578: IFFALSE 44603
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44580: LD_ADDR_VAR 0 2
44584: PUSH
44585: LD_VAR 0 1
44589: PPUSH
44590: CALL_OW 437
44594: PUSH
44595: LD_INT 1
44597: ARRAY
44598: PUSH
44599: LD_INT 4
44601: ARRAY
44602: ST_TO_ADDR
// end ;
44603: LD_VAR 0 2
44607: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44608: LD_INT 0
44610: PPUSH
44611: PPUSH
44612: PPUSH
44613: PPUSH
// if not base_units then
44614: LD_VAR 0 1
44618: NOT
44619: IFFALSE 44623
// exit ;
44621: GO 44710
// result := false ;
44623: LD_ADDR_VAR 0 2
44627: PUSH
44628: LD_INT 0
44630: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44631: LD_ADDR_VAR 0 5
44635: PUSH
44636: LD_VAR 0 1
44640: PPUSH
44641: LD_INT 21
44643: PUSH
44644: LD_INT 3
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PPUSH
44651: CALL_OW 72
44655: ST_TO_ADDR
// if not tmp then
44656: LD_VAR 0 5
44660: NOT
44661: IFFALSE 44665
// exit ;
44663: GO 44710
// for i in tmp do
44665: LD_ADDR_VAR 0 3
44669: PUSH
44670: LD_VAR 0 5
44674: PUSH
44675: FOR_IN
44676: IFFALSE 44708
// begin result := EnemyInRange ( i , 22 ) ;
44678: LD_ADDR_VAR 0 2
44682: PUSH
44683: LD_VAR 0 3
44687: PPUSH
44688: LD_INT 22
44690: PPUSH
44691: CALL 42297 0 2
44695: ST_TO_ADDR
// if result then
44696: LD_VAR 0 2
44700: IFFALSE 44706
// exit ;
44702: POP
44703: POP
44704: GO 44710
// end ;
44706: GO 44675
44708: POP
44709: POP
// end ;
44710: LD_VAR 0 2
44714: RET
// export function FilterByTag ( units , tag ) ; begin
44715: LD_INT 0
44717: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
44718: LD_ADDR_VAR 0 3
44722: PUSH
44723: LD_VAR 0 1
44727: PPUSH
44728: LD_INT 120
44730: PUSH
44731: LD_VAR 0 2
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PPUSH
44740: CALL_OW 72
44744: ST_TO_ADDR
// end ;
44745: LD_VAR 0 3
44749: RET
// export function IsDriver ( un ) ; begin
44750: LD_INT 0
44752: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44753: LD_ADDR_VAR 0 2
44757: PUSH
44758: LD_VAR 0 1
44762: PUSH
44763: LD_INT 55
44765: PUSH
44766: EMPTY
44767: LIST
44768: PPUSH
44769: CALL_OW 69
44773: IN
44774: ST_TO_ADDR
// end ;
44775: LD_VAR 0 2
44779: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44780: LD_INT 0
44782: PPUSH
44783: PPUSH
// list := [ ] ;
44784: LD_ADDR_VAR 0 5
44788: PUSH
44789: EMPTY
44790: ST_TO_ADDR
// case d of 0 :
44791: LD_VAR 0 3
44795: PUSH
44796: LD_INT 0
44798: DOUBLE
44799: EQUAL
44800: IFTRUE 44804
44802: GO 44937
44804: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44805: LD_ADDR_VAR 0 5
44809: PUSH
44810: LD_VAR 0 1
44814: PUSH
44815: LD_INT 4
44817: MINUS
44818: PUSH
44819: LD_VAR 0 2
44823: PUSH
44824: LD_INT 4
44826: MINUS
44827: PUSH
44828: LD_INT 2
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: LIST
44835: PUSH
44836: LD_VAR 0 1
44840: PUSH
44841: LD_INT 3
44843: MINUS
44844: PUSH
44845: LD_VAR 0 2
44849: PUSH
44850: LD_INT 1
44852: PUSH
44853: EMPTY
44854: LIST
44855: LIST
44856: LIST
44857: PUSH
44858: LD_VAR 0 1
44862: PUSH
44863: LD_INT 4
44865: PLUS
44866: PUSH
44867: LD_VAR 0 2
44871: PUSH
44872: LD_INT 4
44874: PUSH
44875: EMPTY
44876: LIST
44877: LIST
44878: LIST
44879: PUSH
44880: LD_VAR 0 1
44884: PUSH
44885: LD_INT 3
44887: PLUS
44888: PUSH
44889: LD_VAR 0 2
44893: PUSH
44894: LD_INT 3
44896: PLUS
44897: PUSH
44898: LD_INT 5
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: LIST
44905: PUSH
44906: LD_VAR 0 1
44910: PUSH
44911: LD_VAR 0 2
44915: PUSH
44916: LD_INT 4
44918: PLUS
44919: PUSH
44920: LD_INT 0
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: LIST
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: ST_TO_ADDR
// end ; 1 :
44935: GO 45635
44937: LD_INT 1
44939: DOUBLE
44940: EQUAL
44941: IFTRUE 44945
44943: GO 45078
44945: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
44946: LD_ADDR_VAR 0 5
44950: PUSH
44951: LD_VAR 0 1
44955: PUSH
44956: LD_VAR 0 2
44960: PUSH
44961: LD_INT 4
44963: MINUS
44964: PUSH
44965: LD_INT 3
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: LIST
44972: PUSH
44973: LD_VAR 0 1
44977: PUSH
44978: LD_INT 3
44980: MINUS
44981: PUSH
44982: LD_VAR 0 2
44986: PUSH
44987: LD_INT 3
44989: MINUS
44990: PUSH
44991: LD_INT 2
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: LIST
44998: PUSH
44999: LD_VAR 0 1
45003: PUSH
45004: LD_INT 4
45006: MINUS
45007: PUSH
45008: LD_VAR 0 2
45012: PUSH
45013: LD_INT 1
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: LIST
45020: PUSH
45021: LD_VAR 0 1
45025: PUSH
45026: LD_VAR 0 2
45030: PUSH
45031: LD_INT 3
45033: PLUS
45034: PUSH
45035: LD_INT 0
45037: PUSH
45038: EMPTY
45039: LIST
45040: LIST
45041: LIST
45042: PUSH
45043: LD_VAR 0 1
45047: PUSH
45048: LD_INT 4
45050: PLUS
45051: PUSH
45052: LD_VAR 0 2
45056: PUSH
45057: LD_INT 4
45059: PLUS
45060: PUSH
45061: LD_INT 5
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: LIST
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: ST_TO_ADDR
// end ; 2 :
45076: GO 45635
45078: LD_INT 2
45080: DOUBLE
45081: EQUAL
45082: IFTRUE 45086
45084: GO 45215
45086: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45087: LD_ADDR_VAR 0 5
45091: PUSH
45092: LD_VAR 0 1
45096: PUSH
45097: LD_VAR 0 2
45101: PUSH
45102: LD_INT 3
45104: MINUS
45105: PUSH
45106: LD_INT 3
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: LIST
45113: PUSH
45114: LD_VAR 0 1
45118: PUSH
45119: LD_INT 4
45121: PLUS
45122: PUSH
45123: LD_VAR 0 2
45127: PUSH
45128: LD_INT 4
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: LIST
45135: PUSH
45136: LD_VAR 0 1
45140: PUSH
45141: LD_VAR 0 2
45145: PUSH
45146: LD_INT 4
45148: PLUS
45149: PUSH
45150: LD_INT 0
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: LIST
45157: PUSH
45158: LD_VAR 0 1
45162: PUSH
45163: LD_INT 3
45165: MINUS
45166: PUSH
45167: LD_VAR 0 2
45171: PUSH
45172: LD_INT 1
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: LIST
45179: PUSH
45180: LD_VAR 0 1
45184: PUSH
45185: LD_INT 4
45187: MINUS
45188: PUSH
45189: LD_VAR 0 2
45193: PUSH
45194: LD_INT 4
45196: MINUS
45197: PUSH
45198: LD_INT 2
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: LIST
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: LIST
45210: LIST
45211: LIST
45212: ST_TO_ADDR
// end ; 3 :
45213: GO 45635
45215: LD_INT 3
45217: DOUBLE
45218: EQUAL
45219: IFTRUE 45223
45221: GO 45356
45223: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45224: LD_ADDR_VAR 0 5
45228: PUSH
45229: LD_VAR 0 1
45233: PUSH
45234: LD_INT 3
45236: PLUS
45237: PUSH
45238: LD_VAR 0 2
45242: PUSH
45243: LD_INT 4
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: LIST
45250: PUSH
45251: LD_VAR 0 1
45255: PUSH
45256: LD_INT 4
45258: PLUS
45259: PUSH
45260: LD_VAR 0 2
45264: PUSH
45265: LD_INT 4
45267: PLUS
45268: PUSH
45269: LD_INT 5
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: LIST
45276: PUSH
45277: LD_VAR 0 1
45281: PUSH
45282: LD_INT 4
45284: MINUS
45285: PUSH
45286: LD_VAR 0 2
45290: PUSH
45291: LD_INT 1
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: LIST
45298: PUSH
45299: LD_VAR 0 1
45303: PUSH
45304: LD_VAR 0 2
45308: PUSH
45309: LD_INT 4
45311: MINUS
45312: PUSH
45313: LD_INT 3
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: LIST
45320: PUSH
45321: LD_VAR 0 1
45325: PUSH
45326: LD_INT 3
45328: MINUS
45329: PUSH
45330: LD_VAR 0 2
45334: PUSH
45335: LD_INT 3
45337: MINUS
45338: PUSH
45339: LD_INT 2
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: LIST
45346: PUSH
45347: EMPTY
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: ST_TO_ADDR
// end ; 4 :
45354: GO 45635
45356: LD_INT 4
45358: DOUBLE
45359: EQUAL
45360: IFTRUE 45364
45362: GO 45497
45364: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45365: LD_ADDR_VAR 0 5
45369: PUSH
45370: LD_VAR 0 1
45374: PUSH
45375: LD_VAR 0 2
45379: PUSH
45380: LD_INT 4
45382: PLUS
45383: PUSH
45384: LD_INT 0
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: LIST
45391: PUSH
45392: LD_VAR 0 1
45396: PUSH
45397: LD_INT 3
45399: PLUS
45400: PUSH
45401: LD_VAR 0 2
45405: PUSH
45406: LD_INT 3
45408: PLUS
45409: PUSH
45410: LD_INT 5
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: LIST
45417: PUSH
45418: LD_VAR 0 1
45422: PUSH
45423: LD_INT 4
45425: PLUS
45426: PUSH
45427: LD_VAR 0 2
45431: PUSH
45432: LD_INT 4
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: LIST
45439: PUSH
45440: LD_VAR 0 1
45444: PUSH
45445: LD_VAR 0 2
45449: PUSH
45450: LD_INT 3
45452: MINUS
45453: PUSH
45454: LD_INT 3
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: LIST
45461: PUSH
45462: LD_VAR 0 1
45466: PUSH
45467: LD_INT 4
45469: MINUS
45470: PUSH
45471: LD_VAR 0 2
45475: PUSH
45476: LD_INT 4
45478: MINUS
45479: PUSH
45480: LD_INT 2
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: LIST
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: ST_TO_ADDR
// end ; 5 :
45495: GO 45635
45497: LD_INT 5
45499: DOUBLE
45500: EQUAL
45501: IFTRUE 45505
45503: GO 45634
45505: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45506: LD_ADDR_VAR 0 5
45510: PUSH
45511: LD_VAR 0 1
45515: PUSH
45516: LD_INT 4
45518: MINUS
45519: PUSH
45520: LD_VAR 0 2
45524: PUSH
45525: LD_INT 1
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: LIST
45532: PUSH
45533: LD_VAR 0 1
45537: PUSH
45538: LD_VAR 0 2
45542: PUSH
45543: LD_INT 4
45545: MINUS
45546: PUSH
45547: LD_INT 3
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: LIST
45554: PUSH
45555: LD_VAR 0 1
45559: PUSH
45560: LD_INT 4
45562: PLUS
45563: PUSH
45564: LD_VAR 0 2
45568: PUSH
45569: LD_INT 4
45571: PLUS
45572: PUSH
45573: LD_INT 5
45575: PUSH
45576: EMPTY
45577: LIST
45578: LIST
45579: LIST
45580: PUSH
45581: LD_VAR 0 1
45585: PUSH
45586: LD_INT 3
45588: PLUS
45589: PUSH
45590: LD_VAR 0 2
45594: PUSH
45595: LD_INT 4
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: LIST
45602: PUSH
45603: LD_VAR 0 1
45607: PUSH
45608: LD_VAR 0 2
45612: PUSH
45613: LD_INT 3
45615: PLUS
45616: PUSH
45617: LD_INT 0
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: LIST
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: ST_TO_ADDR
// end ; end ;
45632: GO 45635
45634: POP
// result := list ;
45635: LD_ADDR_VAR 0 4
45639: PUSH
45640: LD_VAR 0 5
45644: ST_TO_ADDR
// end ;
45645: LD_VAR 0 4
45649: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45650: LD_INT 0
45652: PPUSH
45653: PPUSH
45654: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45655: LD_VAR 0 1
45659: NOT
45660: PUSH
45661: LD_VAR 0 2
45665: PUSH
45666: LD_INT 1
45668: PUSH
45669: LD_INT 2
45671: PUSH
45672: LD_INT 3
45674: PUSH
45675: LD_INT 4
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: LIST
45682: LIST
45683: IN
45684: NOT
45685: OR
45686: IFFALSE 45690
// exit ;
45688: GO 45773
// tmp := [ ] ;
45690: LD_ADDR_VAR 0 5
45694: PUSH
45695: EMPTY
45696: ST_TO_ADDR
// for i in units do
45697: LD_ADDR_VAR 0 4
45701: PUSH
45702: LD_VAR 0 1
45706: PUSH
45707: FOR_IN
45708: IFFALSE 45742
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
45710: LD_ADDR_VAR 0 5
45714: PUSH
45715: LD_VAR 0 5
45719: PPUSH
45720: LD_VAR 0 4
45724: PPUSH
45725: LD_VAR 0 2
45729: PPUSH
45730: CALL_OW 259
45734: PPUSH
45735: CALL 47133 0 2
45739: ST_TO_ADDR
45740: GO 45707
45742: POP
45743: POP
// if not tmp then
45744: LD_VAR 0 5
45748: NOT
45749: IFFALSE 45753
// exit ;
45751: GO 45773
// result := SortListByListDesc ( units , tmp ) ;
45753: LD_ADDR_VAR 0 3
45757: PUSH
45758: LD_VAR 0 1
45762: PPUSH
45763: LD_VAR 0 5
45767: PPUSH
45768: CALL_OW 77
45772: ST_TO_ADDR
// end ;
45773: LD_VAR 0 3
45777: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45778: LD_INT 0
45780: PPUSH
45781: PPUSH
45782: PPUSH
// result := false ;
45783: LD_ADDR_VAR 0 3
45787: PUSH
45788: LD_INT 0
45790: ST_TO_ADDR
// if not building then
45791: LD_VAR 0 2
45795: NOT
45796: IFFALSE 45800
// exit ;
45798: GO 45938
// x := GetX ( building ) ;
45800: LD_ADDR_VAR 0 4
45804: PUSH
45805: LD_VAR 0 2
45809: PPUSH
45810: CALL_OW 250
45814: ST_TO_ADDR
// y := GetY ( building ) ;
45815: LD_ADDR_VAR 0 5
45819: PUSH
45820: LD_VAR 0 2
45824: PPUSH
45825: CALL_OW 251
45829: ST_TO_ADDR
// if not x or not y then
45830: LD_VAR 0 4
45834: NOT
45835: PUSH
45836: LD_VAR 0 5
45840: NOT
45841: OR
45842: IFFALSE 45846
// exit ;
45844: GO 45938
// if GetTaskList ( unit ) then
45846: LD_VAR 0 1
45850: PPUSH
45851: CALL_OW 437
45855: IFFALSE 45938
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45857: LD_STRING e
45859: PUSH
45860: LD_VAR 0 1
45864: PPUSH
45865: CALL_OW 437
45869: PUSH
45870: LD_INT 1
45872: ARRAY
45873: PUSH
45874: LD_INT 1
45876: ARRAY
45877: EQUAL
45878: PUSH
45879: LD_VAR 0 4
45883: PUSH
45884: LD_VAR 0 1
45888: PPUSH
45889: CALL_OW 437
45893: PUSH
45894: LD_INT 1
45896: ARRAY
45897: PUSH
45898: LD_INT 2
45900: ARRAY
45901: EQUAL
45902: AND
45903: PUSH
45904: LD_VAR 0 5
45908: PUSH
45909: LD_VAR 0 1
45913: PPUSH
45914: CALL_OW 437
45918: PUSH
45919: LD_INT 1
45921: ARRAY
45922: PUSH
45923: LD_INT 3
45925: ARRAY
45926: EQUAL
45927: AND
45928: IFFALSE 45938
// result := true end ;
45930: LD_ADDR_VAR 0 3
45934: PUSH
45935: LD_INT 1
45937: ST_TO_ADDR
// end ;
45938: LD_VAR 0 3
45942: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
45943: LD_INT 0
45945: PPUSH
// result := false ;
45946: LD_ADDR_VAR 0 4
45950: PUSH
45951: LD_INT 0
45953: ST_TO_ADDR
// if GetTaskList ( unit ) then
45954: LD_VAR 0 1
45958: PPUSH
45959: CALL_OW 437
45963: IFFALSE 46046
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45965: LD_STRING M
45967: PUSH
45968: LD_VAR 0 1
45972: PPUSH
45973: CALL_OW 437
45977: PUSH
45978: LD_INT 1
45980: ARRAY
45981: PUSH
45982: LD_INT 1
45984: ARRAY
45985: EQUAL
45986: PUSH
45987: LD_VAR 0 2
45991: PUSH
45992: LD_VAR 0 1
45996: PPUSH
45997: CALL_OW 437
46001: PUSH
46002: LD_INT 1
46004: ARRAY
46005: PUSH
46006: LD_INT 2
46008: ARRAY
46009: EQUAL
46010: AND
46011: PUSH
46012: LD_VAR 0 3
46016: PUSH
46017: LD_VAR 0 1
46021: PPUSH
46022: CALL_OW 437
46026: PUSH
46027: LD_INT 1
46029: ARRAY
46030: PUSH
46031: LD_INT 3
46033: ARRAY
46034: EQUAL
46035: AND
46036: IFFALSE 46046
// result := true ;
46038: LD_ADDR_VAR 0 4
46042: PUSH
46043: LD_INT 1
46045: ST_TO_ADDR
// end ; end ;
46046: LD_VAR 0 4
46050: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46051: LD_INT 0
46053: PPUSH
46054: PPUSH
46055: PPUSH
46056: PPUSH
// if not unit or not area then
46057: LD_VAR 0 1
46061: NOT
46062: PUSH
46063: LD_VAR 0 2
46067: NOT
46068: OR
46069: IFFALSE 46073
// exit ;
46071: GO 46236
// tmp := AreaToList ( area , i ) ;
46073: LD_ADDR_VAR 0 6
46077: PUSH
46078: LD_VAR 0 2
46082: PPUSH
46083: LD_VAR 0 5
46087: PPUSH
46088: CALL_OW 517
46092: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46093: LD_ADDR_VAR 0 5
46097: PUSH
46098: DOUBLE
46099: LD_INT 1
46101: DEC
46102: ST_TO_ADDR
46103: LD_VAR 0 6
46107: PUSH
46108: LD_INT 1
46110: ARRAY
46111: PUSH
46112: FOR_TO
46113: IFFALSE 46234
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46115: LD_ADDR_VAR 0 7
46119: PUSH
46120: LD_VAR 0 6
46124: PUSH
46125: LD_INT 1
46127: ARRAY
46128: PUSH
46129: LD_VAR 0 5
46133: ARRAY
46134: PUSH
46135: LD_VAR 0 6
46139: PUSH
46140: LD_INT 2
46142: ARRAY
46143: PUSH
46144: LD_VAR 0 5
46148: ARRAY
46149: PUSH
46150: EMPTY
46151: LIST
46152: LIST
46153: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
46154: LD_INT 92
46156: PUSH
46157: LD_VAR 0 7
46161: PUSH
46162: LD_INT 1
46164: ARRAY
46165: PUSH
46166: LD_VAR 0 7
46170: PUSH
46171: LD_INT 2
46173: ARRAY
46174: PUSH
46175: LD_INT 3
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: PPUSH
46184: CALL_OW 69
46188: PUSH
46189: LD_INT 0
46191: EQUAL
46192: IFFALSE 46232
// begin PlaceUnitArea ( unit , area , mode ) ;
46194: LD_VAR 0 1
46198: PPUSH
46199: LD_VAR 0 2
46203: PPUSH
46204: LD_VAR 0 3
46208: PPUSH
46209: CALL_OW 49
// result := IsPlaced ( unit ) ;
46213: LD_ADDR_VAR 0 4
46217: PUSH
46218: LD_VAR 0 1
46222: PPUSH
46223: CALL_OW 305
46227: ST_TO_ADDR
// exit ;
46228: POP
46229: POP
46230: GO 46236
// end ; end ;
46232: GO 46112
46234: POP
46235: POP
// end ;
46236: LD_VAR 0 4
46240: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46241: LD_INT 0
46243: PPUSH
46244: PPUSH
46245: PPUSH
// if not side or side > 8 then
46246: LD_VAR 0 1
46250: NOT
46251: PUSH
46252: LD_VAR 0 1
46256: PUSH
46257: LD_INT 8
46259: GREATER
46260: OR
46261: IFFALSE 46265
// exit ;
46263: GO 46452
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46265: LD_ADDR_VAR 0 4
46269: PUSH
46270: LD_INT 22
46272: PUSH
46273: LD_VAR 0 1
46277: PUSH
46278: EMPTY
46279: LIST
46280: LIST
46281: PUSH
46282: LD_INT 21
46284: PUSH
46285: LD_INT 3
46287: PUSH
46288: EMPTY
46289: LIST
46290: LIST
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: PPUSH
46296: CALL_OW 69
46300: ST_TO_ADDR
// if not tmp then
46301: LD_VAR 0 4
46305: NOT
46306: IFFALSE 46310
// exit ;
46308: GO 46452
// enable_addtolog := true ;
46310: LD_ADDR_OWVAR 81
46314: PUSH
46315: LD_INT 1
46317: ST_TO_ADDR
// AddToLog ( [ ) ;
46318: LD_STRING [
46320: PPUSH
46321: CALL_OW 561
// for i in tmp do
46325: LD_ADDR_VAR 0 3
46329: PUSH
46330: LD_VAR 0 4
46334: PUSH
46335: FOR_IN
46336: IFFALSE 46443
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46338: LD_STRING [
46340: PUSH
46341: LD_VAR 0 3
46345: PPUSH
46346: CALL_OW 266
46350: STR
46351: PUSH
46352: LD_STRING , 
46354: STR
46355: PUSH
46356: LD_VAR 0 3
46360: PPUSH
46361: CALL_OW 250
46365: STR
46366: PUSH
46367: LD_STRING , 
46369: STR
46370: PUSH
46371: LD_VAR 0 3
46375: PPUSH
46376: CALL_OW 251
46380: STR
46381: PUSH
46382: LD_STRING , 
46384: STR
46385: PUSH
46386: LD_VAR 0 3
46390: PPUSH
46391: CALL_OW 254
46395: STR
46396: PUSH
46397: LD_STRING , 
46399: STR
46400: PUSH
46401: LD_VAR 0 3
46405: PPUSH
46406: LD_INT 1
46408: PPUSH
46409: CALL_OW 268
46413: STR
46414: PUSH
46415: LD_STRING , 
46417: STR
46418: PUSH
46419: LD_VAR 0 3
46423: PPUSH
46424: LD_INT 2
46426: PPUSH
46427: CALL_OW 268
46431: STR
46432: PUSH
46433: LD_STRING ],
46435: STR
46436: PPUSH
46437: CALL_OW 561
// end ;
46441: GO 46335
46443: POP
46444: POP
// AddToLog ( ]; ) ;
46445: LD_STRING ];
46447: PPUSH
46448: CALL_OW 561
// end ;
46452: LD_VAR 0 2
46456: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46457: LD_INT 0
46459: PPUSH
46460: PPUSH
46461: PPUSH
46462: PPUSH
46463: PPUSH
// if not area or not rate or not max then
46464: LD_VAR 0 1
46468: NOT
46469: PUSH
46470: LD_VAR 0 2
46474: NOT
46475: OR
46476: PUSH
46477: LD_VAR 0 4
46481: NOT
46482: OR
46483: IFFALSE 46487
// exit ;
46485: GO 46676
// while 1 do
46487: LD_INT 1
46489: IFFALSE 46676
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46491: LD_ADDR_VAR 0 9
46495: PUSH
46496: LD_VAR 0 1
46500: PPUSH
46501: LD_INT 1
46503: PPUSH
46504: CALL_OW 287
46508: PUSH
46509: LD_INT 10
46511: MUL
46512: ST_TO_ADDR
// r := rate / 10 ;
46513: LD_ADDR_VAR 0 7
46517: PUSH
46518: LD_VAR 0 2
46522: PUSH
46523: LD_INT 10
46525: DIVREAL
46526: ST_TO_ADDR
// time := 1 1$00 ;
46527: LD_ADDR_VAR 0 8
46531: PUSH
46532: LD_INT 2100
46534: ST_TO_ADDR
// if amount < min then
46535: LD_VAR 0 9
46539: PUSH
46540: LD_VAR 0 3
46544: LESS
46545: IFFALSE 46563
// r := r * 2 else
46547: LD_ADDR_VAR 0 7
46551: PUSH
46552: LD_VAR 0 7
46556: PUSH
46557: LD_INT 2
46559: MUL
46560: ST_TO_ADDR
46561: GO 46589
// if amount > max then
46563: LD_VAR 0 9
46567: PUSH
46568: LD_VAR 0 4
46572: GREATER
46573: IFFALSE 46589
// r := r / 2 ;
46575: LD_ADDR_VAR 0 7
46579: PUSH
46580: LD_VAR 0 7
46584: PUSH
46585: LD_INT 2
46587: DIVREAL
46588: ST_TO_ADDR
// time := time / r ;
46589: LD_ADDR_VAR 0 8
46593: PUSH
46594: LD_VAR 0 8
46598: PUSH
46599: LD_VAR 0 7
46603: DIVREAL
46604: ST_TO_ADDR
// if time < 0 then
46605: LD_VAR 0 8
46609: PUSH
46610: LD_INT 0
46612: LESS
46613: IFFALSE 46630
// time := time * - 1 ;
46615: LD_ADDR_VAR 0 8
46619: PUSH
46620: LD_VAR 0 8
46624: PUSH
46625: LD_INT 1
46627: NEG
46628: MUL
46629: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
46630: LD_VAR 0 8
46634: PUSH
46635: LD_INT 35
46637: PPUSH
46638: LD_INT 875
46640: PPUSH
46641: CALL_OW 12
46645: PLUS
46646: PPUSH
46647: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46651: LD_INT 1
46653: PPUSH
46654: LD_INT 5
46656: PPUSH
46657: CALL_OW 12
46661: PPUSH
46662: LD_VAR 0 1
46666: PPUSH
46667: LD_INT 1
46669: PPUSH
46670: CALL_OW 55
// end ;
46674: GO 46487
// end ;
46676: LD_VAR 0 5
46680: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46681: LD_INT 0
46683: PPUSH
46684: PPUSH
46685: PPUSH
46686: PPUSH
46687: PPUSH
46688: PPUSH
46689: PPUSH
46690: PPUSH
// if not turrets or not factories then
46691: LD_VAR 0 1
46695: NOT
46696: PUSH
46697: LD_VAR 0 2
46701: NOT
46702: OR
46703: IFFALSE 46707
// exit ;
46705: GO 47014
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46707: LD_ADDR_VAR 0 10
46711: PUSH
46712: LD_INT 5
46714: PUSH
46715: LD_INT 6
46717: PUSH
46718: EMPTY
46719: LIST
46720: LIST
46721: PUSH
46722: LD_INT 2
46724: PUSH
46725: LD_INT 4
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: PUSH
46732: LD_INT 3
46734: PUSH
46735: LD_INT 5
46737: PUSH
46738: EMPTY
46739: LIST
46740: LIST
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: LIST
46746: PUSH
46747: LD_INT 24
46749: PUSH
46750: LD_INT 25
46752: PUSH
46753: EMPTY
46754: LIST
46755: LIST
46756: PUSH
46757: LD_INT 23
46759: PUSH
46760: LD_INT 27
46762: PUSH
46763: EMPTY
46764: LIST
46765: LIST
46766: PUSH
46767: EMPTY
46768: LIST
46769: LIST
46770: PUSH
46771: LD_INT 42
46773: PUSH
46774: LD_INT 43
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PUSH
46781: LD_INT 44
46783: PUSH
46784: LD_INT 46
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: LD_INT 45
46793: PUSH
46794: LD_INT 47
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: PUSH
46801: EMPTY
46802: LIST
46803: LIST
46804: LIST
46805: PUSH
46806: EMPTY
46807: LIST
46808: LIST
46809: LIST
46810: ST_TO_ADDR
// result := [ ] ;
46811: LD_ADDR_VAR 0 3
46815: PUSH
46816: EMPTY
46817: ST_TO_ADDR
// for i in turrets do
46818: LD_ADDR_VAR 0 4
46822: PUSH
46823: LD_VAR 0 1
46827: PUSH
46828: FOR_IN
46829: IFFALSE 47012
// begin nat := GetNation ( i ) ;
46831: LD_ADDR_VAR 0 7
46835: PUSH
46836: LD_VAR 0 4
46840: PPUSH
46841: CALL_OW 248
46845: ST_TO_ADDR
// weapon := 0 ;
46846: LD_ADDR_VAR 0 8
46850: PUSH
46851: LD_INT 0
46853: ST_TO_ADDR
// if not nat then
46854: LD_VAR 0 7
46858: NOT
46859: IFFALSE 46863
// continue ;
46861: GO 46828
// for j in list [ nat ] do
46863: LD_ADDR_VAR 0 5
46867: PUSH
46868: LD_VAR 0 10
46872: PUSH
46873: LD_VAR 0 7
46877: ARRAY
46878: PUSH
46879: FOR_IN
46880: IFFALSE 46921
// if GetBWeapon ( i ) = j [ 1 ] then
46882: LD_VAR 0 4
46886: PPUSH
46887: CALL_OW 269
46891: PUSH
46892: LD_VAR 0 5
46896: PUSH
46897: LD_INT 1
46899: ARRAY
46900: EQUAL
46901: IFFALSE 46919
// begin weapon := j [ 2 ] ;
46903: LD_ADDR_VAR 0 8
46907: PUSH
46908: LD_VAR 0 5
46912: PUSH
46913: LD_INT 2
46915: ARRAY
46916: ST_TO_ADDR
// break ;
46917: GO 46921
// end ;
46919: GO 46879
46921: POP
46922: POP
// if not weapon then
46923: LD_VAR 0 8
46927: NOT
46928: IFFALSE 46932
// continue ;
46930: GO 46828
// for k in factories do
46932: LD_ADDR_VAR 0 6
46936: PUSH
46937: LD_VAR 0 2
46941: PUSH
46942: FOR_IN
46943: IFFALSE 47008
// begin weapons := AvailableWeaponList ( k ) ;
46945: LD_ADDR_VAR 0 9
46949: PUSH
46950: LD_VAR 0 6
46954: PPUSH
46955: CALL_OW 478
46959: ST_TO_ADDR
// if not weapons then
46960: LD_VAR 0 9
46964: NOT
46965: IFFALSE 46969
// continue ;
46967: GO 46942
// if weapon in weapons then
46969: LD_VAR 0 8
46973: PUSH
46974: LD_VAR 0 9
46978: IN
46979: IFFALSE 47006
// begin result := [ i , weapon ] ;
46981: LD_ADDR_VAR 0 3
46985: PUSH
46986: LD_VAR 0 4
46990: PUSH
46991: LD_VAR 0 8
46995: PUSH
46996: EMPTY
46997: LIST
46998: LIST
46999: ST_TO_ADDR
// exit ;
47000: POP
47001: POP
47002: POP
47003: POP
47004: GO 47014
// end ; end ;
47006: GO 46942
47008: POP
47009: POP
// end ;
47010: GO 46828
47012: POP
47013: POP
// end ;
47014: LD_VAR 0 3
47018: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47019: LD_INT 0
47021: PPUSH
// if not side or side > 8 then
47022: LD_VAR 0 3
47026: NOT
47027: PUSH
47028: LD_VAR 0 3
47032: PUSH
47033: LD_INT 8
47035: GREATER
47036: OR
47037: IFFALSE 47041
// exit ;
47039: GO 47100
// if not range then
47041: LD_VAR 0 4
47045: NOT
47046: IFFALSE 47057
// range := - 12 ;
47048: LD_ADDR_VAR 0 4
47052: PUSH
47053: LD_INT 12
47055: NEG
47056: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47057: LD_VAR 0 1
47061: PPUSH
47062: LD_VAR 0 2
47066: PPUSH
47067: LD_VAR 0 3
47071: PPUSH
47072: LD_VAR 0 4
47076: PPUSH
47077: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47081: LD_VAR 0 1
47085: PPUSH
47086: LD_VAR 0 2
47090: PPUSH
47091: LD_VAR 0 3
47095: PPUSH
47096: CALL_OW 331
// end ;
47100: LD_VAR 0 5
47104: RET
// export function Video ( mode ) ; begin
47105: LD_INT 0
47107: PPUSH
// ingame_video = mode ;
47108: LD_ADDR_OWVAR 52
47112: PUSH
47113: LD_VAR 0 1
47117: ST_TO_ADDR
// interface_hidden = mode ;
47118: LD_ADDR_OWVAR 54
47122: PUSH
47123: LD_VAR 0 1
47127: ST_TO_ADDR
// end ;
47128: LD_VAR 0 2
47132: RET
// export function Join ( array , element ) ; begin
47133: LD_INT 0
47135: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47136: LD_ADDR_VAR 0 3
47140: PUSH
47141: LD_VAR 0 1
47145: PPUSH
47146: LD_VAR 0 1
47150: PUSH
47151: LD_INT 1
47153: PLUS
47154: PPUSH
47155: LD_VAR 0 2
47159: PPUSH
47160: CALL_OW 1
47164: ST_TO_ADDR
// end ;
47165: LD_VAR 0 3
47169: RET
// export function JoinUnion ( array , element ) ; begin
47170: LD_INT 0
47172: PPUSH
// result := array union element ;
47173: LD_ADDR_VAR 0 3
47177: PUSH
47178: LD_VAR 0 1
47182: PUSH
47183: LD_VAR 0 2
47187: UNION
47188: ST_TO_ADDR
// end ;
47189: LD_VAR 0 3
47193: RET
// export function GetBehemoths ( side ) ; begin
47194: LD_INT 0
47196: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
47197: LD_ADDR_VAR 0 2
47201: PUSH
47202: LD_INT 22
47204: PUSH
47205: LD_VAR 0 1
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: PUSH
47214: LD_INT 31
47216: PUSH
47217: LD_INT 25
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PPUSH
47228: CALL_OW 69
47232: ST_TO_ADDR
// end ;
47233: LD_VAR 0 2
47237: RET
// export function Shuffle ( array ) ; var i , index ; begin
47238: LD_INT 0
47240: PPUSH
47241: PPUSH
47242: PPUSH
// result := [ ] ;
47243: LD_ADDR_VAR 0 2
47247: PUSH
47248: EMPTY
47249: ST_TO_ADDR
// if not array then
47250: LD_VAR 0 1
47254: NOT
47255: IFFALSE 47259
// exit ;
47257: GO 47358
// Randomize ;
47259: CALL_OW 10
// for i = array downto 1 do
47263: LD_ADDR_VAR 0 3
47267: PUSH
47268: DOUBLE
47269: LD_VAR 0 1
47273: INC
47274: ST_TO_ADDR
47275: LD_INT 1
47277: PUSH
47278: FOR_DOWNTO
47279: IFFALSE 47356
// begin index := rand ( 1 , array ) ;
47281: LD_ADDR_VAR 0 4
47285: PUSH
47286: LD_INT 1
47288: PPUSH
47289: LD_VAR 0 1
47293: PPUSH
47294: CALL_OW 12
47298: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47299: LD_ADDR_VAR 0 2
47303: PUSH
47304: LD_VAR 0 2
47308: PPUSH
47309: LD_VAR 0 2
47313: PUSH
47314: LD_INT 1
47316: PLUS
47317: PPUSH
47318: LD_VAR 0 1
47322: PUSH
47323: LD_VAR 0 4
47327: ARRAY
47328: PPUSH
47329: CALL_OW 2
47333: ST_TO_ADDR
// array := Delete ( array , index ) ;
47334: LD_ADDR_VAR 0 1
47338: PUSH
47339: LD_VAR 0 1
47343: PPUSH
47344: LD_VAR 0 4
47348: PPUSH
47349: CALL_OW 3
47353: ST_TO_ADDR
// end ;
47354: GO 47278
47356: POP
47357: POP
// end ;
47358: LD_VAR 0 2
47362: RET
// export function GetBaseMaterials ( base ) ; begin
47363: LD_INT 0
47365: PPUSH
// result := [ 0 , 0 , 0 ] ;
47366: LD_ADDR_VAR 0 2
47370: PUSH
47371: LD_INT 0
47373: PUSH
47374: LD_INT 0
47376: PUSH
47377: LD_INT 0
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: LIST
47384: ST_TO_ADDR
// if not base then
47385: LD_VAR 0 1
47389: NOT
47390: IFFALSE 47394
// exit ;
47392: GO 47443
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47394: LD_ADDR_VAR 0 2
47398: PUSH
47399: LD_VAR 0 1
47403: PPUSH
47404: LD_INT 1
47406: PPUSH
47407: CALL_OW 275
47411: PUSH
47412: LD_VAR 0 1
47416: PPUSH
47417: LD_INT 2
47419: PPUSH
47420: CALL_OW 275
47424: PUSH
47425: LD_VAR 0 1
47429: PPUSH
47430: LD_INT 3
47432: PPUSH
47433: CALL_OW 275
47437: PUSH
47438: EMPTY
47439: LIST
47440: LIST
47441: LIST
47442: ST_TO_ADDR
// end ;
47443: LD_VAR 0 2
47447: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47448: LD_INT 0
47450: PPUSH
47451: PPUSH
// result := array ;
47452: LD_ADDR_VAR 0 3
47456: PUSH
47457: LD_VAR 0 1
47461: ST_TO_ADDR
// if size >= result then
47462: LD_VAR 0 2
47466: PUSH
47467: LD_VAR 0 3
47471: GREATEREQUAL
47472: IFFALSE 47476
// exit ;
47474: GO 47526
// if size then
47476: LD_VAR 0 2
47480: IFFALSE 47526
// for i := array downto size do
47482: LD_ADDR_VAR 0 4
47486: PUSH
47487: DOUBLE
47488: LD_VAR 0 1
47492: INC
47493: ST_TO_ADDR
47494: LD_VAR 0 2
47498: PUSH
47499: FOR_DOWNTO
47500: IFFALSE 47524
// result := Delete ( result , result ) ;
47502: LD_ADDR_VAR 0 3
47506: PUSH
47507: LD_VAR 0 3
47511: PPUSH
47512: LD_VAR 0 3
47516: PPUSH
47517: CALL_OW 3
47521: ST_TO_ADDR
47522: GO 47499
47524: POP
47525: POP
// end ;
47526: LD_VAR 0 3
47530: RET
// export function ComExit ( unit ) ; var tmp ; begin
47531: LD_INT 0
47533: PPUSH
47534: PPUSH
// if not IsInUnit ( unit ) then
47535: LD_VAR 0 1
47539: PPUSH
47540: CALL_OW 310
47544: NOT
47545: IFFALSE 47549
// exit ;
47547: GO 47609
// tmp := IsInUnit ( unit ) ;
47549: LD_ADDR_VAR 0 3
47553: PUSH
47554: LD_VAR 0 1
47558: PPUSH
47559: CALL_OW 310
47563: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47564: LD_VAR 0 3
47568: PPUSH
47569: CALL_OW 247
47573: PUSH
47574: LD_INT 2
47576: EQUAL
47577: IFFALSE 47590
// ComExitVehicle ( unit ) else
47579: LD_VAR 0 1
47583: PPUSH
47584: CALL_OW 121
47588: GO 47599
// ComExitBuilding ( unit ) ;
47590: LD_VAR 0 1
47594: PPUSH
47595: CALL_OW 122
// result := tmp ;
47599: LD_ADDR_VAR 0 2
47603: PUSH
47604: LD_VAR 0 3
47608: ST_TO_ADDR
// end ;
47609: LD_VAR 0 2
47613: RET
// export function ComExitAll ( units ) ; var i ; begin
47614: LD_INT 0
47616: PPUSH
47617: PPUSH
// if not units then
47618: LD_VAR 0 1
47622: NOT
47623: IFFALSE 47627
// exit ;
47625: GO 47653
// for i in units do
47627: LD_ADDR_VAR 0 3
47631: PUSH
47632: LD_VAR 0 1
47636: PUSH
47637: FOR_IN
47638: IFFALSE 47651
// ComExit ( i ) ;
47640: LD_VAR 0 3
47644: PPUSH
47645: CALL 47531 0 1
47649: GO 47637
47651: POP
47652: POP
// end ;
47653: LD_VAR 0 2
47657: RET
// export function ResetHc ; begin
47658: LD_INT 0
47660: PPUSH
// InitHc ;
47661: CALL_OW 19
// hc_importance := 0 ;
47665: LD_ADDR_OWVAR 32
47669: PUSH
47670: LD_INT 0
47672: ST_TO_ADDR
// end ;
47673: LD_VAR 0 1
47677: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47678: LD_INT 0
47680: PPUSH
47681: PPUSH
47682: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47683: LD_ADDR_VAR 0 6
47687: PUSH
47688: LD_VAR 0 1
47692: PUSH
47693: LD_VAR 0 3
47697: PLUS
47698: PUSH
47699: LD_INT 2
47701: DIV
47702: ST_TO_ADDR
// if _x < 0 then
47703: LD_VAR 0 6
47707: PUSH
47708: LD_INT 0
47710: LESS
47711: IFFALSE 47728
// _x := _x * - 1 ;
47713: LD_ADDR_VAR 0 6
47717: PUSH
47718: LD_VAR 0 6
47722: PUSH
47723: LD_INT 1
47725: NEG
47726: MUL
47727: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47728: LD_ADDR_VAR 0 7
47732: PUSH
47733: LD_VAR 0 2
47737: PUSH
47738: LD_VAR 0 4
47742: PLUS
47743: PUSH
47744: LD_INT 2
47746: DIV
47747: ST_TO_ADDR
// if _y < 0 then
47748: LD_VAR 0 7
47752: PUSH
47753: LD_INT 0
47755: LESS
47756: IFFALSE 47773
// _y := _y * - 1 ;
47758: LD_ADDR_VAR 0 7
47762: PUSH
47763: LD_VAR 0 7
47767: PUSH
47768: LD_INT 1
47770: NEG
47771: MUL
47772: ST_TO_ADDR
// result := [ _x , _y ] ;
47773: LD_ADDR_VAR 0 5
47777: PUSH
47778: LD_VAR 0 6
47782: PUSH
47783: LD_VAR 0 7
47787: PUSH
47788: EMPTY
47789: LIST
47790: LIST
47791: ST_TO_ADDR
// end ;
47792: LD_VAR 0 5
47796: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47797: LD_INT 0
47799: PPUSH
47800: PPUSH
47801: PPUSH
47802: PPUSH
// task := GetTaskList ( unit ) ;
47803: LD_ADDR_VAR 0 7
47807: PUSH
47808: LD_VAR 0 1
47812: PPUSH
47813: CALL_OW 437
47817: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47818: LD_VAR 0 7
47822: NOT
47823: PUSH
47824: LD_VAR 0 1
47828: PPUSH
47829: LD_VAR 0 2
47833: PPUSH
47834: CALL_OW 308
47838: NOT
47839: AND
47840: IFFALSE 47844
// exit ;
47842: GO 47962
// if IsInArea ( unit , area ) then
47844: LD_VAR 0 1
47848: PPUSH
47849: LD_VAR 0 2
47853: PPUSH
47854: CALL_OW 308
47858: IFFALSE 47876
// begin ComMoveToArea ( unit , goAway ) ;
47860: LD_VAR 0 1
47864: PPUSH
47865: LD_VAR 0 3
47869: PPUSH
47870: CALL_OW 113
// exit ;
47874: GO 47962
// end ; if task [ 1 ] [ 1 ] <> M then
47876: LD_VAR 0 7
47880: PUSH
47881: LD_INT 1
47883: ARRAY
47884: PUSH
47885: LD_INT 1
47887: ARRAY
47888: PUSH
47889: LD_STRING M
47891: NONEQUAL
47892: IFFALSE 47896
// exit ;
47894: GO 47962
// x := task [ 1 ] [ 2 ] ;
47896: LD_ADDR_VAR 0 5
47900: PUSH
47901: LD_VAR 0 7
47905: PUSH
47906: LD_INT 1
47908: ARRAY
47909: PUSH
47910: LD_INT 2
47912: ARRAY
47913: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
47914: LD_ADDR_VAR 0 6
47918: PUSH
47919: LD_VAR 0 7
47923: PUSH
47924: LD_INT 1
47926: ARRAY
47927: PUSH
47928: LD_INT 3
47930: ARRAY
47931: ST_TO_ADDR
// if InArea ( x , y , area ) then
47932: LD_VAR 0 5
47936: PPUSH
47937: LD_VAR 0 6
47941: PPUSH
47942: LD_VAR 0 2
47946: PPUSH
47947: CALL_OW 309
47951: IFFALSE 47962
// ComStop ( unit ) ;
47953: LD_VAR 0 1
47957: PPUSH
47958: CALL_OW 141
// end ;
47962: LD_VAR 0 4
47966: RET
// export function Abs ( value ) ; begin
47967: LD_INT 0
47969: PPUSH
// result := value ;
47970: LD_ADDR_VAR 0 2
47974: PUSH
47975: LD_VAR 0 1
47979: ST_TO_ADDR
// if value < 0 then
47980: LD_VAR 0 1
47984: PUSH
47985: LD_INT 0
47987: LESS
47988: IFFALSE 48005
// result := value * - 1 ;
47990: LD_ADDR_VAR 0 2
47994: PUSH
47995: LD_VAR 0 1
47999: PUSH
48000: LD_INT 1
48002: NEG
48003: MUL
48004: ST_TO_ADDR
// end ;
48005: LD_VAR 0 2
48009: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48010: LD_INT 0
48012: PPUSH
48013: PPUSH
48014: PPUSH
48015: PPUSH
48016: PPUSH
48017: PPUSH
48018: PPUSH
48019: PPUSH
// if not unit or not building then
48020: LD_VAR 0 1
48024: NOT
48025: PUSH
48026: LD_VAR 0 2
48030: NOT
48031: OR
48032: IFFALSE 48036
// exit ;
48034: GO 48262
// x := GetX ( building ) ;
48036: LD_ADDR_VAR 0 4
48040: PUSH
48041: LD_VAR 0 2
48045: PPUSH
48046: CALL_OW 250
48050: ST_TO_ADDR
// y := GetY ( building ) ;
48051: LD_ADDR_VAR 0 6
48055: PUSH
48056: LD_VAR 0 2
48060: PPUSH
48061: CALL_OW 251
48065: ST_TO_ADDR
// d := GetDir ( building ) ;
48066: LD_ADDR_VAR 0 8
48070: PUSH
48071: LD_VAR 0 2
48075: PPUSH
48076: CALL_OW 254
48080: ST_TO_ADDR
// r := 4 ;
48081: LD_ADDR_VAR 0 9
48085: PUSH
48086: LD_INT 4
48088: ST_TO_ADDR
// for i := 1 to 5 do
48089: LD_ADDR_VAR 0 10
48093: PUSH
48094: DOUBLE
48095: LD_INT 1
48097: DEC
48098: ST_TO_ADDR
48099: LD_INT 5
48101: PUSH
48102: FOR_TO
48103: IFFALSE 48260
// begin _x := ShiftX ( x , d , r + i ) ;
48105: LD_ADDR_VAR 0 5
48109: PUSH
48110: LD_VAR 0 4
48114: PPUSH
48115: LD_VAR 0 8
48119: PPUSH
48120: LD_VAR 0 9
48124: PUSH
48125: LD_VAR 0 10
48129: PLUS
48130: PPUSH
48131: CALL_OW 272
48135: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48136: LD_ADDR_VAR 0 7
48140: PUSH
48141: LD_VAR 0 6
48145: PPUSH
48146: LD_VAR 0 8
48150: PPUSH
48151: LD_VAR 0 9
48155: PUSH
48156: LD_VAR 0 10
48160: PLUS
48161: PPUSH
48162: CALL_OW 273
48166: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48167: LD_VAR 0 5
48171: PPUSH
48172: LD_VAR 0 7
48176: PPUSH
48177: CALL_OW 488
48181: PUSH
48182: LD_VAR 0 5
48186: PPUSH
48187: LD_VAR 0 7
48191: PPUSH
48192: CALL_OW 428
48196: PPUSH
48197: CALL_OW 247
48201: PUSH
48202: LD_INT 3
48204: PUSH
48205: LD_INT 2
48207: PUSH
48208: EMPTY
48209: LIST
48210: LIST
48211: IN
48212: NOT
48213: AND
48214: IFFALSE 48258
// begin ComMoveXY ( unit , _x , _y ) ;
48216: LD_VAR 0 1
48220: PPUSH
48221: LD_VAR 0 5
48225: PPUSH
48226: LD_VAR 0 7
48230: PPUSH
48231: CALL_OW 111
// result := [ _x , _y ] ;
48235: LD_ADDR_VAR 0 3
48239: PUSH
48240: LD_VAR 0 5
48244: PUSH
48245: LD_VAR 0 7
48249: PUSH
48250: EMPTY
48251: LIST
48252: LIST
48253: ST_TO_ADDR
// exit ;
48254: POP
48255: POP
48256: GO 48262
// end ; end ;
48258: GO 48102
48260: POP
48261: POP
// end ;
48262: LD_VAR 0 3
48266: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48267: LD_INT 0
48269: PPUSH
48270: PPUSH
48271: PPUSH
// result := 0 ;
48272: LD_ADDR_VAR 0 3
48276: PUSH
48277: LD_INT 0
48279: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48280: LD_VAR 0 1
48284: PUSH
48285: LD_INT 0
48287: LESS
48288: PUSH
48289: LD_VAR 0 1
48293: PUSH
48294: LD_INT 8
48296: GREATER
48297: OR
48298: PUSH
48299: LD_VAR 0 2
48303: PUSH
48304: LD_INT 0
48306: LESS
48307: OR
48308: PUSH
48309: LD_VAR 0 2
48313: PUSH
48314: LD_INT 8
48316: GREATER
48317: OR
48318: IFFALSE 48322
// exit ;
48320: GO 48397
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48322: LD_ADDR_VAR 0 4
48326: PUSH
48327: LD_INT 22
48329: PUSH
48330: LD_VAR 0 2
48334: PUSH
48335: EMPTY
48336: LIST
48337: LIST
48338: PPUSH
48339: CALL_OW 69
48343: PUSH
48344: FOR_IN
48345: IFFALSE 48395
// begin un := UnitShoot ( i ) ;
48347: LD_ADDR_VAR 0 5
48351: PUSH
48352: LD_VAR 0 4
48356: PPUSH
48357: CALL_OW 504
48361: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48362: LD_VAR 0 5
48366: PPUSH
48367: CALL_OW 255
48371: PUSH
48372: LD_VAR 0 1
48376: EQUAL
48377: IFFALSE 48393
// begin result := un ;
48379: LD_ADDR_VAR 0 3
48383: PUSH
48384: LD_VAR 0 5
48388: ST_TO_ADDR
// exit ;
48389: POP
48390: POP
48391: GO 48397
// end ; end ;
48393: GO 48344
48395: POP
48396: POP
// end ;
48397: LD_VAR 0 3
48401: RET
// export function GetCargoBay ( units ) ; begin
48402: LD_INT 0
48404: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48405: LD_ADDR_VAR 0 2
48409: PUSH
48410: LD_VAR 0 1
48414: PPUSH
48415: LD_INT 2
48417: PUSH
48418: LD_INT 34
48420: PUSH
48421: LD_INT 12
48423: PUSH
48424: EMPTY
48425: LIST
48426: LIST
48427: PUSH
48428: LD_INT 34
48430: PUSH
48431: LD_INT 51
48433: PUSH
48434: EMPTY
48435: LIST
48436: LIST
48437: PUSH
48438: LD_INT 34
48440: PUSH
48441: LD_INT 32
48443: PUSH
48444: EMPTY
48445: LIST
48446: LIST
48447: PUSH
48448: LD_INT 34
48450: PUSH
48451: LD_INT 89
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PUSH
48458: EMPTY
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: LIST
48464: PPUSH
48465: CALL_OW 72
48469: ST_TO_ADDR
// end ;
48470: LD_VAR 0 2
48474: RET
// export function Negate ( value ) ; begin
48475: LD_INT 0
48477: PPUSH
// result := not value ;
48478: LD_ADDR_VAR 0 2
48482: PUSH
48483: LD_VAR 0 1
48487: NOT
48488: ST_TO_ADDR
// end ;
48489: LD_VAR 0 2
48493: RET
// export function Inc ( value ) ; begin
48494: LD_INT 0
48496: PPUSH
// result := value + 1 ;
48497: LD_ADDR_VAR 0 2
48501: PUSH
48502: LD_VAR 0 1
48506: PUSH
48507: LD_INT 1
48509: PLUS
48510: ST_TO_ADDR
// end ;
48511: LD_VAR 0 2
48515: RET
// export function Dec ( value ) ; begin
48516: LD_INT 0
48518: PPUSH
// result := value - 1 ;
48519: LD_ADDR_VAR 0 2
48523: PUSH
48524: LD_VAR 0 1
48528: PUSH
48529: LD_INT 1
48531: MINUS
48532: ST_TO_ADDR
// end ;
48533: LD_VAR 0 2
48537: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
48538: LD_INT 0
48540: PPUSH
48541: PPUSH
48542: PPUSH
48543: PPUSH
48544: PPUSH
48545: PPUSH
48546: PPUSH
48547: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
48548: LD_VAR 0 1
48552: PPUSH
48553: LD_VAR 0 2
48557: PPUSH
48558: CALL_OW 488
48562: NOT
48563: PUSH
48564: LD_VAR 0 3
48568: PPUSH
48569: LD_VAR 0 4
48573: PPUSH
48574: CALL_OW 488
48578: NOT
48579: OR
48580: IFFALSE 48593
// begin result := - 1 ;
48582: LD_ADDR_VAR 0 5
48586: PUSH
48587: LD_INT 1
48589: NEG
48590: ST_TO_ADDR
// exit ;
48591: GO 48828
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
48593: LD_ADDR_VAR 0 12
48597: PUSH
48598: LD_VAR 0 1
48602: PPUSH
48603: LD_VAR 0 2
48607: PPUSH
48608: LD_VAR 0 3
48612: PPUSH
48613: LD_VAR 0 4
48617: PPUSH
48618: CALL 47678 0 4
48622: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
48623: LD_ADDR_VAR 0 11
48627: PUSH
48628: LD_VAR 0 1
48632: PPUSH
48633: LD_VAR 0 2
48637: PPUSH
48638: LD_VAR 0 12
48642: PUSH
48643: LD_INT 1
48645: ARRAY
48646: PPUSH
48647: LD_VAR 0 12
48651: PUSH
48652: LD_INT 2
48654: ARRAY
48655: PPUSH
48656: CALL_OW 298
48660: ST_TO_ADDR
// distance := 9999 ;
48661: LD_ADDR_VAR 0 10
48665: PUSH
48666: LD_INT 9999
48668: ST_TO_ADDR
// for i := 0 to 5 do
48669: LD_ADDR_VAR 0 6
48673: PUSH
48674: DOUBLE
48675: LD_INT 0
48677: DEC
48678: ST_TO_ADDR
48679: LD_INT 5
48681: PUSH
48682: FOR_TO
48683: IFFALSE 48826
// begin _x := ShiftX ( x1 , i , centerDist ) ;
48685: LD_ADDR_VAR 0 7
48689: PUSH
48690: LD_VAR 0 1
48694: PPUSH
48695: LD_VAR 0 6
48699: PPUSH
48700: LD_VAR 0 11
48704: PPUSH
48705: CALL_OW 272
48709: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
48710: LD_ADDR_VAR 0 8
48714: PUSH
48715: LD_VAR 0 2
48719: PPUSH
48720: LD_VAR 0 6
48724: PPUSH
48725: LD_VAR 0 11
48729: PPUSH
48730: CALL_OW 273
48734: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48735: LD_VAR 0 7
48739: PPUSH
48740: LD_VAR 0 8
48744: PPUSH
48745: CALL_OW 488
48749: NOT
48750: IFFALSE 48754
// continue ;
48752: GO 48682
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
48754: LD_ADDR_VAR 0 9
48758: PUSH
48759: LD_VAR 0 12
48763: PUSH
48764: LD_INT 1
48766: ARRAY
48767: PPUSH
48768: LD_VAR 0 12
48772: PUSH
48773: LD_INT 2
48775: ARRAY
48776: PPUSH
48777: LD_VAR 0 7
48781: PPUSH
48782: LD_VAR 0 8
48786: PPUSH
48787: CALL_OW 298
48791: ST_TO_ADDR
// if tmp < distance then
48792: LD_VAR 0 9
48796: PUSH
48797: LD_VAR 0 10
48801: LESS
48802: IFFALSE 48824
// begin result := i ;
48804: LD_ADDR_VAR 0 5
48808: PUSH
48809: LD_VAR 0 6
48813: ST_TO_ADDR
// distance := tmp ;
48814: LD_ADDR_VAR 0 10
48818: PUSH
48819: LD_VAR 0 9
48823: ST_TO_ADDR
// end ; end ;
48824: GO 48682
48826: POP
48827: POP
// end ;
48828: LD_VAR 0 5
48832: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48833: LD_INT 0
48835: PPUSH
48836: PPUSH
// if not driver or not IsInUnit ( driver ) then
48837: LD_VAR 0 1
48841: NOT
48842: PUSH
48843: LD_VAR 0 1
48847: PPUSH
48848: CALL_OW 310
48852: NOT
48853: OR
48854: IFFALSE 48858
// exit ;
48856: GO 48948
// vehicle := IsInUnit ( driver ) ;
48858: LD_ADDR_VAR 0 3
48862: PUSH
48863: LD_VAR 0 1
48867: PPUSH
48868: CALL_OW 310
48872: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48873: LD_VAR 0 1
48877: PPUSH
48878: LD_STRING \
48880: PUSH
48881: LD_INT 0
48883: PUSH
48884: LD_INT 0
48886: PUSH
48887: LD_INT 0
48889: PUSH
48890: LD_INT 0
48892: PUSH
48893: LD_INT 0
48895: PUSH
48896: LD_INT 0
48898: PUSH
48899: EMPTY
48900: LIST
48901: LIST
48902: LIST
48903: LIST
48904: LIST
48905: LIST
48906: LIST
48907: PUSH
48908: LD_STRING E
48910: PUSH
48911: LD_INT 0
48913: PUSH
48914: LD_INT 0
48916: PUSH
48917: LD_VAR 0 3
48921: PUSH
48922: LD_INT 0
48924: PUSH
48925: LD_INT 0
48927: PUSH
48928: LD_INT 0
48930: PUSH
48931: EMPTY
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: PPUSH
48944: CALL_OW 446
// end ;
48948: LD_VAR 0 2
48952: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48953: LD_INT 0
48955: PPUSH
48956: PPUSH
// if not driver or not IsInUnit ( driver ) then
48957: LD_VAR 0 1
48961: NOT
48962: PUSH
48963: LD_VAR 0 1
48967: PPUSH
48968: CALL_OW 310
48972: NOT
48973: OR
48974: IFFALSE 48978
// exit ;
48976: GO 49068
// vehicle := IsInUnit ( driver ) ;
48978: LD_ADDR_VAR 0 3
48982: PUSH
48983: LD_VAR 0 1
48987: PPUSH
48988: CALL_OW 310
48992: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48993: LD_VAR 0 1
48997: PPUSH
48998: LD_STRING \
49000: PUSH
49001: LD_INT 0
49003: PUSH
49004: LD_INT 0
49006: PUSH
49007: LD_INT 0
49009: PUSH
49010: LD_INT 0
49012: PUSH
49013: LD_INT 0
49015: PUSH
49016: LD_INT 0
49018: PUSH
49019: EMPTY
49020: LIST
49021: LIST
49022: LIST
49023: LIST
49024: LIST
49025: LIST
49026: LIST
49027: PUSH
49028: LD_STRING E
49030: PUSH
49031: LD_INT 0
49033: PUSH
49034: LD_INT 0
49036: PUSH
49037: LD_VAR 0 3
49041: PUSH
49042: LD_INT 0
49044: PUSH
49045: LD_INT 0
49047: PUSH
49048: LD_INT 0
49050: PUSH
49051: EMPTY
49052: LIST
49053: LIST
49054: LIST
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: PUSH
49060: EMPTY
49061: LIST
49062: LIST
49063: PPUSH
49064: CALL_OW 447
// end ;
49068: LD_VAR 0 2
49072: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49073: LD_INT 0
49075: PPUSH
49076: PPUSH
49077: PPUSH
// tmp := [ ] ;
49078: LD_ADDR_VAR 0 5
49082: PUSH
49083: EMPTY
49084: ST_TO_ADDR
// for i in units do
49085: LD_ADDR_VAR 0 4
49089: PUSH
49090: LD_VAR 0 1
49094: PUSH
49095: FOR_IN
49096: IFFALSE 49134
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49098: LD_ADDR_VAR 0 5
49102: PUSH
49103: LD_VAR 0 5
49107: PPUSH
49108: LD_VAR 0 5
49112: PUSH
49113: LD_INT 1
49115: PLUS
49116: PPUSH
49117: LD_VAR 0 4
49121: PPUSH
49122: CALL_OW 256
49126: PPUSH
49127: CALL_OW 2
49131: ST_TO_ADDR
49132: GO 49095
49134: POP
49135: POP
// if not tmp then
49136: LD_VAR 0 5
49140: NOT
49141: IFFALSE 49145
// exit ;
49143: GO 49193
// if asc then
49145: LD_VAR 0 2
49149: IFFALSE 49173
// result := SortListByListAsc ( units , tmp ) else
49151: LD_ADDR_VAR 0 3
49155: PUSH
49156: LD_VAR 0 1
49160: PPUSH
49161: LD_VAR 0 5
49165: PPUSH
49166: CALL_OW 76
49170: ST_TO_ADDR
49171: GO 49193
// result := SortListByListDesc ( units , tmp ) ;
49173: LD_ADDR_VAR 0 3
49177: PUSH
49178: LD_VAR 0 1
49182: PPUSH
49183: LD_VAR 0 5
49187: PPUSH
49188: CALL_OW 77
49192: ST_TO_ADDR
// end ;
49193: LD_VAR 0 3
49197: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49198: LD_INT 0
49200: PPUSH
49201: PPUSH
// task := GetTaskList ( mech ) ;
49202: LD_ADDR_VAR 0 4
49206: PUSH
49207: LD_VAR 0 1
49211: PPUSH
49212: CALL_OW 437
49216: ST_TO_ADDR
// if not task then
49217: LD_VAR 0 4
49221: NOT
49222: IFFALSE 49226
// exit ;
49224: GO 49268
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49226: LD_ADDR_VAR 0 3
49230: PUSH
49231: LD_VAR 0 4
49235: PUSH
49236: LD_INT 1
49238: ARRAY
49239: PUSH
49240: LD_INT 1
49242: ARRAY
49243: PUSH
49244: LD_STRING r
49246: EQUAL
49247: PUSH
49248: LD_VAR 0 4
49252: PUSH
49253: LD_INT 1
49255: ARRAY
49256: PUSH
49257: LD_INT 4
49259: ARRAY
49260: PUSH
49261: LD_VAR 0 2
49265: EQUAL
49266: AND
49267: ST_TO_ADDR
// end ;
49268: LD_VAR 0 3
49272: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49273: LD_INT 0
49275: PPUSH
// SetDir ( unit , d ) ;
49276: LD_VAR 0 1
49280: PPUSH
49281: LD_VAR 0 4
49285: PPUSH
49286: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49290: LD_VAR 0 1
49294: PPUSH
49295: LD_VAR 0 2
49299: PPUSH
49300: LD_VAR 0 3
49304: PPUSH
49305: LD_VAR 0 5
49309: PPUSH
49310: CALL_OW 48
// end ;
49314: LD_VAR 0 6
49318: RET
// export function ToNaturalNumber ( number ) ; begin
49319: LD_INT 0
49321: PPUSH
// result := number div 1 ;
49322: LD_ADDR_VAR 0 2
49326: PUSH
49327: LD_VAR 0 1
49331: PUSH
49332: LD_INT 1
49334: DIV
49335: ST_TO_ADDR
// if number < 0 then
49336: LD_VAR 0 1
49340: PUSH
49341: LD_INT 0
49343: LESS
49344: IFFALSE 49354
// result := 0 ;
49346: LD_ADDR_VAR 0 2
49350: PUSH
49351: LD_INT 0
49353: ST_TO_ADDR
// end ;
49354: LD_VAR 0 2
49358: RET
// export function SortByClass ( units , class ) ; var un ; begin
49359: LD_INT 0
49361: PPUSH
49362: PPUSH
// if not units or not class then
49363: LD_VAR 0 1
49367: NOT
49368: PUSH
49369: LD_VAR 0 2
49373: NOT
49374: OR
49375: IFFALSE 49379
// exit ;
49377: GO 49474
// result := [ ] ;
49379: LD_ADDR_VAR 0 3
49383: PUSH
49384: EMPTY
49385: ST_TO_ADDR
// for un in units do
49386: LD_ADDR_VAR 0 4
49390: PUSH
49391: LD_VAR 0 1
49395: PUSH
49396: FOR_IN
49397: IFFALSE 49472
// if GetClass ( un ) = class then
49399: LD_VAR 0 4
49403: PPUSH
49404: CALL_OW 257
49408: PUSH
49409: LD_VAR 0 2
49413: EQUAL
49414: IFFALSE 49441
// result := Insert ( result , 1 , un ) else
49416: LD_ADDR_VAR 0 3
49420: PUSH
49421: LD_VAR 0 3
49425: PPUSH
49426: LD_INT 1
49428: PPUSH
49429: LD_VAR 0 4
49433: PPUSH
49434: CALL_OW 2
49438: ST_TO_ADDR
49439: GO 49470
// result := Replace ( result , result + 1 , un ) ;
49441: LD_ADDR_VAR 0 3
49445: PUSH
49446: LD_VAR 0 3
49450: PPUSH
49451: LD_VAR 0 3
49455: PUSH
49456: LD_INT 1
49458: PLUS
49459: PPUSH
49460: LD_VAR 0 4
49464: PPUSH
49465: CALL_OW 1
49469: ST_TO_ADDR
49470: GO 49396
49472: POP
49473: POP
// end ;
49474: LD_VAR 0 3
49478: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
49479: LD_INT 0
49481: PPUSH
49482: PPUSH
49483: PPUSH
49484: PPUSH
49485: PPUSH
49486: PPUSH
49487: PPUSH
// result := [ ] ;
49488: LD_ADDR_VAR 0 4
49492: PUSH
49493: EMPTY
49494: ST_TO_ADDR
// if x - r < 0 then
49495: LD_VAR 0 1
49499: PUSH
49500: LD_VAR 0 3
49504: MINUS
49505: PUSH
49506: LD_INT 0
49508: LESS
49509: IFFALSE 49521
// min_x := 0 else
49511: LD_ADDR_VAR 0 8
49515: PUSH
49516: LD_INT 0
49518: ST_TO_ADDR
49519: GO 49537
// min_x := x - r ;
49521: LD_ADDR_VAR 0 8
49525: PUSH
49526: LD_VAR 0 1
49530: PUSH
49531: LD_VAR 0 3
49535: MINUS
49536: ST_TO_ADDR
// if y - r < 0 then
49537: LD_VAR 0 2
49541: PUSH
49542: LD_VAR 0 3
49546: MINUS
49547: PUSH
49548: LD_INT 0
49550: LESS
49551: IFFALSE 49563
// min_y := 0 else
49553: LD_ADDR_VAR 0 7
49557: PUSH
49558: LD_INT 0
49560: ST_TO_ADDR
49561: GO 49579
// min_y := y - r ;
49563: LD_ADDR_VAR 0 7
49567: PUSH
49568: LD_VAR 0 2
49572: PUSH
49573: LD_VAR 0 3
49577: MINUS
49578: ST_TO_ADDR
// max_x := x + r ;
49579: LD_ADDR_VAR 0 9
49583: PUSH
49584: LD_VAR 0 1
49588: PUSH
49589: LD_VAR 0 3
49593: PLUS
49594: ST_TO_ADDR
// max_y := y + r ;
49595: LD_ADDR_VAR 0 10
49599: PUSH
49600: LD_VAR 0 2
49604: PUSH
49605: LD_VAR 0 3
49609: PLUS
49610: ST_TO_ADDR
// for _x = min_x to max_x do
49611: LD_ADDR_VAR 0 5
49615: PUSH
49616: DOUBLE
49617: LD_VAR 0 8
49621: DEC
49622: ST_TO_ADDR
49623: LD_VAR 0 9
49627: PUSH
49628: FOR_TO
49629: IFFALSE 49730
// for _y = min_y to max_y do
49631: LD_ADDR_VAR 0 6
49635: PUSH
49636: DOUBLE
49637: LD_VAR 0 7
49641: DEC
49642: ST_TO_ADDR
49643: LD_VAR 0 10
49647: PUSH
49648: FOR_TO
49649: IFFALSE 49726
// begin if not ValidHex ( _x , _y ) then
49651: LD_VAR 0 5
49655: PPUSH
49656: LD_VAR 0 6
49660: PPUSH
49661: CALL_OW 488
49665: NOT
49666: IFFALSE 49670
// continue ;
49668: GO 49648
// if GetResourceTypeXY ( _x , _y ) then
49670: LD_VAR 0 5
49674: PPUSH
49675: LD_VAR 0 6
49679: PPUSH
49680: CALL_OW 283
49684: IFFALSE 49724
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
49686: LD_ADDR_VAR 0 4
49690: PUSH
49691: LD_VAR 0 4
49695: PPUSH
49696: LD_VAR 0 4
49700: PUSH
49701: LD_INT 1
49703: PLUS
49704: PPUSH
49705: LD_VAR 0 5
49709: PUSH
49710: LD_VAR 0 6
49714: PUSH
49715: EMPTY
49716: LIST
49717: LIST
49718: PPUSH
49719: CALL_OW 1
49723: ST_TO_ADDR
// end ;
49724: GO 49648
49726: POP
49727: POP
49728: GO 49628
49730: POP
49731: POP
// end ;
49732: LD_VAR 0 4
49736: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
49737: LD_INT 0
49739: PPUSH
49740: PPUSH
49741: PPUSH
49742: PPUSH
49743: PPUSH
49744: PPUSH
49745: PPUSH
49746: PPUSH
// if not units then
49747: LD_VAR 0 1
49751: NOT
49752: IFFALSE 49756
// exit ;
49754: GO 50280
// result := UnitFilter ( units , [ f_ok ] ) ;
49756: LD_ADDR_VAR 0 3
49760: PUSH
49761: LD_VAR 0 1
49765: PPUSH
49766: LD_INT 50
49768: PUSH
49769: EMPTY
49770: LIST
49771: PPUSH
49772: CALL_OW 72
49776: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49777: LD_ADDR_VAR 0 8
49781: PUSH
49782: LD_VAR 0 1
49786: PUSH
49787: LD_INT 1
49789: ARRAY
49790: PPUSH
49791: CALL_OW 255
49795: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
49796: LD_ADDR_VAR 0 10
49800: PUSH
49801: LD_INT 29
49803: PUSH
49804: LD_INT 91
49806: PUSH
49807: LD_INT 49
49809: PUSH
49810: EMPTY
49811: LIST
49812: LIST
49813: LIST
49814: ST_TO_ADDR
// if not result then
49815: LD_VAR 0 3
49819: NOT
49820: IFFALSE 49824
// exit ;
49822: GO 50280
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
49824: LD_ADDR_VAR 0 5
49828: PUSH
49829: LD_INT 81
49831: PUSH
49832: LD_VAR 0 8
49836: PUSH
49837: EMPTY
49838: LIST
49839: LIST
49840: PPUSH
49841: CALL_OW 69
49845: ST_TO_ADDR
// for i in result do
49846: LD_ADDR_VAR 0 4
49850: PUSH
49851: LD_VAR 0 3
49855: PUSH
49856: FOR_IN
49857: IFFALSE 50278
// begin tag := GetTag ( i ) + 1 ;
49859: LD_ADDR_VAR 0 9
49863: PUSH
49864: LD_VAR 0 4
49868: PPUSH
49869: CALL_OW 110
49873: PUSH
49874: LD_INT 1
49876: PLUS
49877: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
49878: LD_ADDR_VAR 0 7
49882: PUSH
49883: LD_VAR 0 4
49887: PPUSH
49888: CALL_OW 250
49892: PPUSH
49893: LD_VAR 0 4
49897: PPUSH
49898: CALL_OW 251
49902: PPUSH
49903: LD_INT 6
49905: PPUSH
49906: CALL 49479 0 3
49910: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
49911: LD_VAR 0 4
49915: PPUSH
49916: CALL_OW 247
49920: PUSH
49921: LD_INT 2
49923: EQUAL
49924: PUSH
49925: LD_VAR 0 7
49929: AND
49930: PUSH
49931: LD_VAR 0 4
49935: PPUSH
49936: CALL_OW 264
49940: PUSH
49941: LD_VAR 0 10
49945: IN
49946: NOT
49947: AND
49948: IFFALSE 49987
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
49950: LD_VAR 0 4
49954: PPUSH
49955: LD_VAR 0 7
49959: PUSH
49960: LD_INT 1
49962: ARRAY
49963: PUSH
49964: LD_INT 1
49966: ARRAY
49967: PPUSH
49968: LD_VAR 0 7
49972: PUSH
49973: LD_INT 1
49975: ARRAY
49976: PUSH
49977: LD_INT 2
49979: ARRAY
49980: PPUSH
49981: CALL_OW 116
49985: GO 50276
// if path > tag then
49987: LD_VAR 0 2
49991: PUSH
49992: LD_VAR 0 9
49996: GREATER
49997: IFFALSE 50205
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
49999: LD_ADDR_VAR 0 6
50003: PUSH
50004: LD_VAR 0 5
50008: PPUSH
50009: LD_INT 91
50011: PUSH
50012: LD_VAR 0 4
50016: PUSH
50017: LD_INT 8
50019: PUSH
50020: EMPTY
50021: LIST
50022: LIST
50023: LIST
50024: PPUSH
50025: CALL_OW 72
50029: ST_TO_ADDR
// if nearEnemy then
50030: LD_VAR 0 6
50034: IFFALSE 50103
// begin if GetWeapon ( i ) = ru_time_lapser then
50036: LD_VAR 0 4
50040: PPUSH
50041: CALL_OW 264
50045: PUSH
50046: LD_INT 49
50048: EQUAL
50049: IFFALSE 50077
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50051: LD_VAR 0 4
50055: PPUSH
50056: LD_VAR 0 6
50060: PPUSH
50061: LD_VAR 0 4
50065: PPUSH
50066: CALL_OW 74
50070: PPUSH
50071: CALL_OW 112
50075: GO 50101
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
50077: LD_VAR 0 4
50081: PPUSH
50082: LD_VAR 0 6
50086: PPUSH
50087: LD_VAR 0 4
50091: PPUSH
50092: CALL_OW 74
50096: PPUSH
50097: CALL 51205 0 2
// end else
50101: GO 50203
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50103: LD_VAR 0 4
50107: PPUSH
50108: LD_VAR 0 2
50112: PUSH
50113: LD_VAR 0 9
50117: ARRAY
50118: PUSH
50119: LD_INT 1
50121: ARRAY
50122: PPUSH
50123: LD_VAR 0 2
50127: PUSH
50128: LD_VAR 0 9
50132: ARRAY
50133: PUSH
50134: LD_INT 2
50136: ARRAY
50137: PPUSH
50138: CALL_OW 297
50142: PUSH
50143: LD_INT 6
50145: GREATER
50146: IFFALSE 50189
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50148: LD_VAR 0 4
50152: PPUSH
50153: LD_VAR 0 2
50157: PUSH
50158: LD_VAR 0 9
50162: ARRAY
50163: PUSH
50164: LD_INT 1
50166: ARRAY
50167: PPUSH
50168: LD_VAR 0 2
50172: PUSH
50173: LD_VAR 0 9
50177: ARRAY
50178: PUSH
50179: LD_INT 2
50181: ARRAY
50182: PPUSH
50183: CALL_OW 114
50187: GO 50203
// SetTag ( i , tag ) ;
50189: LD_VAR 0 4
50193: PPUSH
50194: LD_VAR 0 9
50198: PPUSH
50199: CALL_OW 109
// end else
50203: GO 50276
// if enemy then
50205: LD_VAR 0 5
50209: IFFALSE 50276
// begin if GetWeapon ( i ) = ru_time_lapser then
50211: LD_VAR 0 4
50215: PPUSH
50216: CALL_OW 264
50220: PUSH
50221: LD_INT 49
50223: EQUAL
50224: IFFALSE 50252
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
50226: LD_VAR 0 4
50230: PPUSH
50231: LD_VAR 0 5
50235: PPUSH
50236: LD_VAR 0 4
50240: PPUSH
50241: CALL_OW 74
50245: PPUSH
50246: CALL_OW 112
50250: GO 50276
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50252: LD_VAR 0 4
50256: PPUSH
50257: LD_VAR 0 5
50261: PPUSH
50262: LD_VAR 0 4
50266: PPUSH
50267: CALL_OW 74
50271: PPUSH
50272: CALL 51205 0 2
// end ; end ;
50276: GO 49856
50278: POP
50279: POP
// end ;
50280: LD_VAR 0 3
50284: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50285: LD_INT 0
50287: PPUSH
50288: PPUSH
50289: PPUSH
// if not unit or IsInUnit ( unit ) then
50290: LD_VAR 0 1
50294: NOT
50295: PUSH
50296: LD_VAR 0 1
50300: PPUSH
50301: CALL_OW 310
50305: OR
50306: IFFALSE 50310
// exit ;
50308: GO 50401
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50310: LD_ADDR_VAR 0 4
50314: PUSH
50315: LD_VAR 0 1
50319: PPUSH
50320: CALL_OW 250
50324: PPUSH
50325: LD_VAR 0 2
50329: PPUSH
50330: LD_INT 1
50332: PPUSH
50333: CALL_OW 272
50337: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50338: LD_ADDR_VAR 0 5
50342: PUSH
50343: LD_VAR 0 1
50347: PPUSH
50348: CALL_OW 251
50352: PPUSH
50353: LD_VAR 0 2
50357: PPUSH
50358: LD_INT 1
50360: PPUSH
50361: CALL_OW 273
50365: ST_TO_ADDR
// if ValidHex ( x , y ) then
50366: LD_VAR 0 4
50370: PPUSH
50371: LD_VAR 0 5
50375: PPUSH
50376: CALL_OW 488
50380: IFFALSE 50401
// ComTurnXY ( unit , x , y ) ;
50382: LD_VAR 0 1
50386: PPUSH
50387: LD_VAR 0 4
50391: PPUSH
50392: LD_VAR 0 5
50396: PPUSH
50397: CALL_OW 118
// end ;
50401: LD_VAR 0 3
50405: RET
// export function SeeUnits ( side , units ) ; var i ; begin
50406: LD_INT 0
50408: PPUSH
50409: PPUSH
// result := false ;
50410: LD_ADDR_VAR 0 3
50414: PUSH
50415: LD_INT 0
50417: ST_TO_ADDR
// if not units then
50418: LD_VAR 0 2
50422: NOT
50423: IFFALSE 50427
// exit ;
50425: GO 50472
// for i in units do
50427: LD_ADDR_VAR 0 4
50431: PUSH
50432: LD_VAR 0 2
50436: PUSH
50437: FOR_IN
50438: IFFALSE 50470
// if See ( side , i ) then
50440: LD_VAR 0 1
50444: PPUSH
50445: LD_VAR 0 4
50449: PPUSH
50450: CALL_OW 292
50454: IFFALSE 50468
// begin result := true ;
50456: LD_ADDR_VAR 0 3
50460: PUSH
50461: LD_INT 1
50463: ST_TO_ADDR
// exit ;
50464: POP
50465: POP
50466: GO 50472
// end ;
50468: GO 50437
50470: POP
50471: POP
// end ;
50472: LD_VAR 0 3
50476: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
50477: LD_INT 0
50479: PPUSH
50480: PPUSH
50481: PPUSH
50482: PPUSH
// if not unit or not points then
50483: LD_VAR 0 1
50487: NOT
50488: PUSH
50489: LD_VAR 0 2
50493: NOT
50494: OR
50495: IFFALSE 50499
// exit ;
50497: GO 50589
// dist := 99999 ;
50499: LD_ADDR_VAR 0 5
50503: PUSH
50504: LD_INT 99999
50506: ST_TO_ADDR
// for i in points do
50507: LD_ADDR_VAR 0 4
50511: PUSH
50512: LD_VAR 0 2
50516: PUSH
50517: FOR_IN
50518: IFFALSE 50587
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
50520: LD_ADDR_VAR 0 6
50524: PUSH
50525: LD_VAR 0 1
50529: PPUSH
50530: LD_VAR 0 4
50534: PUSH
50535: LD_INT 1
50537: ARRAY
50538: PPUSH
50539: LD_VAR 0 4
50543: PUSH
50544: LD_INT 2
50546: ARRAY
50547: PPUSH
50548: CALL_OW 297
50552: ST_TO_ADDR
// if tmpDist < dist then
50553: LD_VAR 0 6
50557: PUSH
50558: LD_VAR 0 5
50562: LESS
50563: IFFALSE 50585
// begin result := i ;
50565: LD_ADDR_VAR 0 3
50569: PUSH
50570: LD_VAR 0 4
50574: ST_TO_ADDR
// dist := tmpDist ;
50575: LD_ADDR_VAR 0 5
50579: PUSH
50580: LD_VAR 0 6
50584: ST_TO_ADDR
// end ; end ;
50585: GO 50517
50587: POP
50588: POP
// end ;
50589: LD_VAR 0 3
50593: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
50594: LD_INT 0
50596: PPUSH
// uc_side := side ;
50597: LD_ADDR_OWVAR 20
50601: PUSH
50602: LD_VAR 0 1
50606: ST_TO_ADDR
// uc_nation := 3 ;
50607: LD_ADDR_OWVAR 21
50611: PUSH
50612: LD_INT 3
50614: ST_TO_ADDR
// vc_chassis := 25 ;
50615: LD_ADDR_OWVAR 37
50619: PUSH
50620: LD_INT 25
50622: ST_TO_ADDR
// vc_engine := engine_siberite ;
50623: LD_ADDR_OWVAR 39
50627: PUSH
50628: LD_INT 3
50630: ST_TO_ADDR
// vc_control := control_computer ;
50631: LD_ADDR_OWVAR 38
50635: PUSH
50636: LD_INT 3
50638: ST_TO_ADDR
// vc_weapon := 59 ;
50639: LD_ADDR_OWVAR 40
50643: PUSH
50644: LD_INT 59
50646: ST_TO_ADDR
// result := CreateVehicle ;
50647: LD_ADDR_VAR 0 5
50651: PUSH
50652: CALL_OW 45
50656: ST_TO_ADDR
// SetDir ( result , d ) ;
50657: LD_VAR 0 5
50661: PPUSH
50662: LD_VAR 0 4
50666: PPUSH
50667: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
50671: LD_VAR 0 5
50675: PPUSH
50676: LD_VAR 0 2
50680: PPUSH
50681: LD_VAR 0 3
50685: PPUSH
50686: LD_INT 0
50688: PPUSH
50689: CALL_OW 48
// end ;
50693: LD_VAR 0 5
50697: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
50698: LD_INT 0
50700: PPUSH
50701: PPUSH
50702: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
50703: LD_ADDR_VAR 0 2
50707: PUSH
50708: LD_INT 0
50710: PUSH
50711: LD_INT 0
50713: PUSH
50714: LD_INT 0
50716: PUSH
50717: LD_INT 0
50719: PUSH
50720: EMPTY
50721: LIST
50722: LIST
50723: LIST
50724: LIST
50725: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
50726: LD_VAR 0 1
50730: NOT
50731: PUSH
50732: LD_VAR 0 1
50736: PPUSH
50737: CALL_OW 264
50741: PUSH
50742: LD_INT 12
50744: PUSH
50745: LD_INT 51
50747: PUSH
50748: LD_INT 32
50750: PUSH
50751: LD_INT 89
50753: PUSH
50754: EMPTY
50755: LIST
50756: LIST
50757: LIST
50758: LIST
50759: IN
50760: NOT
50761: OR
50762: IFFALSE 50766
// exit ;
50764: GO 50864
// for i := 1 to 3 do
50766: LD_ADDR_VAR 0 3
50770: PUSH
50771: DOUBLE
50772: LD_INT 1
50774: DEC
50775: ST_TO_ADDR
50776: LD_INT 3
50778: PUSH
50779: FOR_TO
50780: IFFALSE 50862
// begin tmp := GetCargo ( cargo , i ) ;
50782: LD_ADDR_VAR 0 4
50786: PUSH
50787: LD_VAR 0 1
50791: PPUSH
50792: LD_VAR 0 3
50796: PPUSH
50797: CALL_OW 289
50801: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
50802: LD_ADDR_VAR 0 2
50806: PUSH
50807: LD_VAR 0 2
50811: PPUSH
50812: LD_VAR 0 3
50816: PPUSH
50817: LD_VAR 0 4
50821: PPUSH
50822: CALL_OW 1
50826: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
50827: LD_ADDR_VAR 0 2
50831: PUSH
50832: LD_VAR 0 2
50836: PPUSH
50837: LD_INT 4
50839: PPUSH
50840: LD_VAR 0 2
50844: PUSH
50845: LD_INT 4
50847: ARRAY
50848: PUSH
50849: LD_VAR 0 4
50853: PLUS
50854: PPUSH
50855: CALL_OW 1
50859: ST_TO_ADDR
// end ;
50860: GO 50779
50862: POP
50863: POP
// end ;
50864: LD_VAR 0 2
50868: RET
// export function Length ( array ) ; begin
50869: LD_INT 0
50871: PPUSH
// result := array + 0 ;
50872: LD_ADDR_VAR 0 2
50876: PUSH
50877: LD_VAR 0 1
50881: PUSH
50882: LD_INT 0
50884: PLUS
50885: ST_TO_ADDR
// end ;
50886: LD_VAR 0 2
50890: RET
// export function PrepareArray ( array ) ; begin
50891: LD_INT 0
50893: PPUSH
// result := array diff 0 ;
50894: LD_ADDR_VAR 0 2
50898: PUSH
50899: LD_VAR 0 1
50903: PUSH
50904: LD_INT 0
50906: DIFF
50907: ST_TO_ADDR
// if not result [ 1 ] then
50908: LD_VAR 0 2
50912: PUSH
50913: LD_INT 1
50915: ARRAY
50916: NOT
50917: IFFALSE 50937
// result := Delete ( result , 1 ) ;
50919: LD_ADDR_VAR 0 2
50923: PUSH
50924: LD_VAR 0 2
50928: PPUSH
50929: LD_INT 1
50931: PPUSH
50932: CALL_OW 3
50936: ST_TO_ADDR
// end ;
50937: LD_VAR 0 2
50941: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
50942: LD_INT 0
50944: PPUSH
50945: PPUSH
50946: PPUSH
50947: PPUSH
// sibRocketRange := 25 ;
50948: LD_ADDR_VAR 0 6
50952: PUSH
50953: LD_INT 25
50955: ST_TO_ADDR
// result := false ;
50956: LD_ADDR_VAR 0 4
50960: PUSH
50961: LD_INT 0
50963: ST_TO_ADDR
// for i := 0 to 5 do
50964: LD_ADDR_VAR 0 5
50968: PUSH
50969: DOUBLE
50970: LD_INT 0
50972: DEC
50973: ST_TO_ADDR
50974: LD_INT 5
50976: PUSH
50977: FOR_TO
50978: IFFALSE 51045
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
50980: LD_VAR 0 1
50984: PPUSH
50985: LD_VAR 0 5
50989: PPUSH
50990: LD_VAR 0 6
50994: PPUSH
50995: CALL_OW 272
50999: PPUSH
51000: LD_VAR 0 2
51004: PPUSH
51005: LD_VAR 0 5
51009: PPUSH
51010: LD_VAR 0 6
51014: PPUSH
51015: CALL_OW 273
51019: PPUSH
51020: LD_VAR 0 3
51024: PPUSH
51025: CALL_OW 309
51029: IFFALSE 51043
// begin result := true ;
51031: LD_ADDR_VAR 0 4
51035: PUSH
51036: LD_INT 1
51038: ST_TO_ADDR
// exit ;
51039: POP
51040: POP
51041: GO 51047
// end ;
51043: GO 50977
51045: POP
51046: POP
// end ;
51047: LD_VAR 0 4
51051: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
51052: LD_INT 0
51054: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
51055: LD_VAR 0 1
51059: PPUSH
51060: LD_VAR 0 2
51064: PPUSH
51065: LD_INT 0
51067: PPUSH
51068: LD_INT 0
51070: PPUSH
51071: LD_INT 1
51073: PPUSH
51074: LD_INT 0
51076: PPUSH
51077: CALL_OW 587
// end ;
51081: LD_VAR 0 3
51085: RET
// export function CenterOnNow ( unit ) ; begin
51086: LD_INT 0
51088: PPUSH
// result := IsInUnit ( unit ) ;
51089: LD_ADDR_VAR 0 2
51093: PUSH
51094: LD_VAR 0 1
51098: PPUSH
51099: CALL_OW 310
51103: ST_TO_ADDR
// if not result then
51104: LD_VAR 0 2
51108: NOT
51109: IFFALSE 51121
// result := unit ;
51111: LD_ADDR_VAR 0 2
51115: PUSH
51116: LD_VAR 0 1
51120: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
51121: LD_VAR 0 1
51125: PPUSH
51126: CALL_OW 87
// end ;
51130: LD_VAR 0 2
51134: RET
// export function ComMoveHex ( unit , hex ) ; begin
51135: LD_INT 0
51137: PPUSH
// if not hex then
51138: LD_VAR 0 2
51142: NOT
51143: IFFALSE 51147
// exit ;
51145: GO 51200
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
51147: LD_VAR 0 2
51151: PUSH
51152: LD_INT 1
51154: ARRAY
51155: PPUSH
51156: LD_VAR 0 2
51160: PUSH
51161: LD_INT 2
51163: ARRAY
51164: PPUSH
51165: CALL_OW 428
51169: IFFALSE 51173
// exit ;
51171: GO 51200
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
51173: LD_VAR 0 1
51177: PPUSH
51178: LD_VAR 0 2
51182: PUSH
51183: LD_INT 1
51185: ARRAY
51186: PPUSH
51187: LD_VAR 0 2
51191: PUSH
51192: LD_INT 2
51194: ARRAY
51195: PPUSH
51196: CALL_OW 111
// end ;
51200: LD_VAR 0 3
51204: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
51205: LD_INT 0
51207: PPUSH
51208: PPUSH
51209: PPUSH
// if not unit or not enemy then
51210: LD_VAR 0 1
51214: NOT
51215: PUSH
51216: LD_VAR 0 2
51220: NOT
51221: OR
51222: IFFALSE 51226
// exit ;
51224: GO 51350
// x := GetX ( enemy ) ;
51226: LD_ADDR_VAR 0 4
51230: PUSH
51231: LD_VAR 0 2
51235: PPUSH
51236: CALL_OW 250
51240: ST_TO_ADDR
// y := GetY ( enemy ) ;
51241: LD_ADDR_VAR 0 5
51245: PUSH
51246: LD_VAR 0 2
51250: PPUSH
51251: CALL_OW 251
51255: ST_TO_ADDR
// if ValidHex ( x , y ) then
51256: LD_VAR 0 4
51260: PPUSH
51261: LD_VAR 0 5
51265: PPUSH
51266: CALL_OW 488
51270: IFFALSE 51350
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
51272: LD_VAR 0 2
51276: PPUSH
51277: CALL_OW 247
51281: PUSH
51282: LD_INT 3
51284: PUSH
51285: LD_INT 2
51287: PUSH
51288: EMPTY
51289: LIST
51290: LIST
51291: IN
51292: PUSH
51293: LD_VAR 0 1
51297: PPUSH
51298: CALL_OW 255
51302: PPUSH
51303: LD_VAR 0 2
51307: PPUSH
51308: CALL_OW 292
51312: AND
51313: IFFALSE 51331
// ComAttackUnit ( unit , enemy ) else
51315: LD_VAR 0 1
51319: PPUSH
51320: LD_VAR 0 2
51324: PPUSH
51325: CALL_OW 115
51329: GO 51350
// ComAgressiveMove ( unit , x , y ) ;
51331: LD_VAR 0 1
51335: PPUSH
51336: LD_VAR 0 4
51340: PPUSH
51341: LD_VAR 0 5
51345: PPUSH
51346: CALL_OW 114
// end ; end_of_file
51350: LD_VAR 0 3
51354: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
51355: LD_INT 0
51357: PPUSH
51358: PPUSH
// skirmish := false ;
51359: LD_ADDR_EXP 41
51363: PUSH
51364: LD_INT 0
51366: ST_TO_ADDR
// debug_mc := false ;
51367: LD_ADDR_EXP 42
51371: PUSH
51372: LD_INT 0
51374: ST_TO_ADDR
// mc_bases := [ ] ;
51375: LD_ADDR_EXP 43
51379: PUSH
51380: EMPTY
51381: ST_TO_ADDR
// mc_sides := [ ] ;
51382: LD_ADDR_EXP 69
51386: PUSH
51387: EMPTY
51388: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51389: LD_ADDR_EXP 44
51393: PUSH
51394: EMPTY
51395: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51396: LD_ADDR_EXP 45
51400: PUSH
51401: EMPTY
51402: ST_TO_ADDR
// mc_need_heal := [ ] ;
51403: LD_ADDR_EXP 46
51407: PUSH
51408: EMPTY
51409: ST_TO_ADDR
// mc_healers := [ ] ;
51410: LD_ADDR_EXP 47
51414: PUSH
51415: EMPTY
51416: ST_TO_ADDR
// mc_build_list := [ ] ;
51417: LD_ADDR_EXP 48
51421: PUSH
51422: EMPTY
51423: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51424: LD_ADDR_EXP 75
51428: PUSH
51429: EMPTY
51430: ST_TO_ADDR
// mc_builders := [ ] ;
51431: LD_ADDR_EXP 49
51435: PUSH
51436: EMPTY
51437: ST_TO_ADDR
// mc_construct_list := [ ] ;
51438: LD_ADDR_EXP 50
51442: PUSH
51443: EMPTY
51444: ST_TO_ADDR
// mc_turret_list := [ ] ;
51445: LD_ADDR_EXP 51
51449: PUSH
51450: EMPTY
51451: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51452: LD_ADDR_EXP 52
51456: PUSH
51457: EMPTY
51458: ST_TO_ADDR
// mc_miners := [ ] ;
51459: LD_ADDR_EXP 57
51463: PUSH
51464: EMPTY
51465: ST_TO_ADDR
// mc_mines := [ ] ;
51466: LD_ADDR_EXP 56
51470: PUSH
51471: EMPTY
51472: ST_TO_ADDR
// mc_minefields := [ ] ;
51473: LD_ADDR_EXP 58
51477: PUSH
51478: EMPTY
51479: ST_TO_ADDR
// mc_crates := [ ] ;
51480: LD_ADDR_EXP 59
51484: PUSH
51485: EMPTY
51486: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51487: LD_ADDR_EXP 60
51491: PUSH
51492: EMPTY
51493: ST_TO_ADDR
// mc_crates_area := [ ] ;
51494: LD_ADDR_EXP 61
51498: PUSH
51499: EMPTY
51500: ST_TO_ADDR
// mc_vehicles := [ ] ;
51501: LD_ADDR_EXP 62
51505: PUSH
51506: EMPTY
51507: ST_TO_ADDR
// mc_attack := [ ] ;
51508: LD_ADDR_EXP 63
51512: PUSH
51513: EMPTY
51514: ST_TO_ADDR
// mc_produce := [ ] ;
51515: LD_ADDR_EXP 64
51519: PUSH
51520: EMPTY
51521: ST_TO_ADDR
// mc_defender := [ ] ;
51522: LD_ADDR_EXP 65
51526: PUSH
51527: EMPTY
51528: ST_TO_ADDR
// mc_parking := [ ] ;
51529: LD_ADDR_EXP 67
51533: PUSH
51534: EMPTY
51535: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51536: LD_ADDR_EXP 53
51540: PUSH
51541: EMPTY
51542: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51543: LD_ADDR_EXP 55
51547: PUSH
51548: EMPTY
51549: ST_TO_ADDR
// mc_scan := [ ] ;
51550: LD_ADDR_EXP 66
51554: PUSH
51555: EMPTY
51556: ST_TO_ADDR
// mc_scan_area := [ ] ;
51557: LD_ADDR_EXP 68
51561: PUSH
51562: EMPTY
51563: ST_TO_ADDR
// mc_tech := [ ] ;
51564: LD_ADDR_EXP 70
51568: PUSH
51569: EMPTY
51570: ST_TO_ADDR
// mc_class := [ ] ;
51571: LD_ADDR_EXP 84
51575: PUSH
51576: EMPTY
51577: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51578: LD_ADDR_EXP 85
51582: PUSH
51583: EMPTY
51584: ST_TO_ADDR
// mc_is_defending := [ ] ;
51585: LD_ADDR_EXP 86
51589: PUSH
51590: EMPTY
51591: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
51592: LD_ADDR_EXP 77
51596: PUSH
51597: EMPTY
51598: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
51599: LD_ADDR_EXP 87
51603: PUSH
51604: LD_INT 0
51606: ST_TO_ADDR
// end ;
51607: LD_VAR 0 1
51611: RET
// export function MC_Kill ( base ) ; begin
51612: LD_INT 0
51614: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51615: LD_ADDR_EXP 43
51619: PUSH
51620: LD_EXP 43
51624: PPUSH
51625: LD_VAR 0 1
51629: PPUSH
51630: EMPTY
51631: PPUSH
51632: CALL_OW 1
51636: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51637: LD_ADDR_EXP 44
51641: PUSH
51642: LD_EXP 44
51646: PPUSH
51647: LD_VAR 0 1
51651: PPUSH
51652: EMPTY
51653: PPUSH
51654: CALL_OW 1
51658: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51659: LD_ADDR_EXP 45
51663: PUSH
51664: LD_EXP 45
51668: PPUSH
51669: LD_VAR 0 1
51673: PPUSH
51674: EMPTY
51675: PPUSH
51676: CALL_OW 1
51680: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51681: LD_ADDR_EXP 46
51685: PUSH
51686: LD_EXP 46
51690: PPUSH
51691: LD_VAR 0 1
51695: PPUSH
51696: EMPTY
51697: PPUSH
51698: CALL_OW 1
51702: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51703: LD_ADDR_EXP 47
51707: PUSH
51708: LD_EXP 47
51712: PPUSH
51713: LD_VAR 0 1
51717: PPUSH
51718: EMPTY
51719: PPUSH
51720: CALL_OW 1
51724: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51725: LD_ADDR_EXP 48
51729: PUSH
51730: LD_EXP 48
51734: PPUSH
51735: LD_VAR 0 1
51739: PPUSH
51740: EMPTY
51741: PPUSH
51742: CALL_OW 1
51746: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51747: LD_ADDR_EXP 49
51751: PUSH
51752: LD_EXP 49
51756: PPUSH
51757: LD_VAR 0 1
51761: PPUSH
51762: EMPTY
51763: PPUSH
51764: CALL_OW 1
51768: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51769: LD_ADDR_EXP 50
51773: PUSH
51774: LD_EXP 50
51778: PPUSH
51779: LD_VAR 0 1
51783: PPUSH
51784: EMPTY
51785: PPUSH
51786: CALL_OW 1
51790: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51791: LD_ADDR_EXP 51
51795: PUSH
51796: LD_EXP 51
51800: PPUSH
51801: LD_VAR 0 1
51805: PPUSH
51806: EMPTY
51807: PPUSH
51808: CALL_OW 1
51812: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51813: LD_ADDR_EXP 52
51817: PUSH
51818: LD_EXP 52
51822: PPUSH
51823: LD_VAR 0 1
51827: PPUSH
51828: EMPTY
51829: PPUSH
51830: CALL_OW 1
51834: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51835: LD_ADDR_EXP 53
51839: PUSH
51840: LD_EXP 53
51844: PPUSH
51845: LD_VAR 0 1
51849: PPUSH
51850: EMPTY
51851: PPUSH
51852: CALL_OW 1
51856: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51857: LD_ADDR_EXP 54
51861: PUSH
51862: LD_EXP 54
51866: PPUSH
51867: LD_VAR 0 1
51871: PPUSH
51872: LD_INT 0
51874: PPUSH
51875: CALL_OW 1
51879: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51880: LD_ADDR_EXP 55
51884: PUSH
51885: LD_EXP 55
51889: PPUSH
51890: LD_VAR 0 1
51894: PPUSH
51895: EMPTY
51896: PPUSH
51897: CALL_OW 1
51901: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51902: LD_ADDR_EXP 56
51906: PUSH
51907: LD_EXP 56
51911: PPUSH
51912: LD_VAR 0 1
51916: PPUSH
51917: EMPTY
51918: PPUSH
51919: CALL_OW 1
51923: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51924: LD_ADDR_EXP 57
51928: PUSH
51929: LD_EXP 57
51933: PPUSH
51934: LD_VAR 0 1
51938: PPUSH
51939: EMPTY
51940: PPUSH
51941: CALL_OW 1
51945: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51946: LD_ADDR_EXP 58
51950: PUSH
51951: LD_EXP 58
51955: PPUSH
51956: LD_VAR 0 1
51960: PPUSH
51961: EMPTY
51962: PPUSH
51963: CALL_OW 1
51967: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51968: LD_ADDR_EXP 59
51972: PUSH
51973: LD_EXP 59
51977: PPUSH
51978: LD_VAR 0 1
51982: PPUSH
51983: EMPTY
51984: PPUSH
51985: CALL_OW 1
51989: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51990: LD_ADDR_EXP 60
51994: PUSH
51995: LD_EXP 60
51999: PPUSH
52000: LD_VAR 0 1
52004: PPUSH
52005: EMPTY
52006: PPUSH
52007: CALL_OW 1
52011: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52012: LD_ADDR_EXP 61
52016: PUSH
52017: LD_EXP 61
52021: PPUSH
52022: LD_VAR 0 1
52026: PPUSH
52027: EMPTY
52028: PPUSH
52029: CALL_OW 1
52033: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52034: LD_ADDR_EXP 62
52038: PUSH
52039: LD_EXP 62
52043: PPUSH
52044: LD_VAR 0 1
52048: PPUSH
52049: EMPTY
52050: PPUSH
52051: CALL_OW 1
52055: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52056: LD_ADDR_EXP 63
52060: PUSH
52061: LD_EXP 63
52065: PPUSH
52066: LD_VAR 0 1
52070: PPUSH
52071: EMPTY
52072: PPUSH
52073: CALL_OW 1
52077: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52078: LD_ADDR_EXP 64
52082: PUSH
52083: LD_EXP 64
52087: PPUSH
52088: LD_VAR 0 1
52092: PPUSH
52093: EMPTY
52094: PPUSH
52095: CALL_OW 1
52099: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52100: LD_ADDR_EXP 65
52104: PUSH
52105: LD_EXP 65
52109: PPUSH
52110: LD_VAR 0 1
52114: PPUSH
52115: EMPTY
52116: PPUSH
52117: CALL_OW 1
52121: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52122: LD_ADDR_EXP 66
52126: PUSH
52127: LD_EXP 66
52131: PPUSH
52132: LD_VAR 0 1
52136: PPUSH
52137: EMPTY
52138: PPUSH
52139: CALL_OW 1
52143: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52144: LD_ADDR_EXP 67
52148: PUSH
52149: LD_EXP 67
52153: PPUSH
52154: LD_VAR 0 1
52158: PPUSH
52159: EMPTY
52160: PPUSH
52161: CALL_OW 1
52165: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52166: LD_ADDR_EXP 68
52170: PUSH
52171: LD_EXP 68
52175: PPUSH
52176: LD_VAR 0 1
52180: PPUSH
52181: EMPTY
52182: PPUSH
52183: CALL_OW 1
52187: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52188: LD_ADDR_EXP 70
52192: PUSH
52193: LD_EXP 70
52197: PPUSH
52198: LD_VAR 0 1
52202: PPUSH
52203: EMPTY
52204: PPUSH
52205: CALL_OW 1
52209: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52210: LD_ADDR_EXP 72
52214: PUSH
52215: LD_EXP 72
52219: PPUSH
52220: LD_VAR 0 1
52224: PPUSH
52225: EMPTY
52226: PPUSH
52227: CALL_OW 1
52231: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52232: LD_ADDR_EXP 73
52236: PUSH
52237: LD_EXP 73
52241: PPUSH
52242: LD_VAR 0 1
52246: PPUSH
52247: EMPTY
52248: PPUSH
52249: CALL_OW 1
52253: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52254: LD_ADDR_EXP 74
52258: PUSH
52259: LD_EXP 74
52263: PPUSH
52264: LD_VAR 0 1
52268: PPUSH
52269: EMPTY
52270: PPUSH
52271: CALL_OW 1
52275: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52276: LD_ADDR_EXP 75
52280: PUSH
52281: LD_EXP 75
52285: PPUSH
52286: LD_VAR 0 1
52290: PPUSH
52291: EMPTY
52292: PPUSH
52293: CALL_OW 1
52297: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52298: LD_ADDR_EXP 76
52302: PUSH
52303: LD_EXP 76
52307: PPUSH
52308: LD_VAR 0 1
52312: PPUSH
52313: EMPTY
52314: PPUSH
52315: CALL_OW 1
52319: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52320: LD_ADDR_EXP 77
52324: PUSH
52325: LD_EXP 77
52329: PPUSH
52330: LD_VAR 0 1
52334: PPUSH
52335: EMPTY
52336: PPUSH
52337: CALL_OW 1
52341: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52342: LD_ADDR_EXP 78
52346: PUSH
52347: LD_EXP 78
52351: PPUSH
52352: LD_VAR 0 1
52356: PPUSH
52357: EMPTY
52358: PPUSH
52359: CALL_OW 1
52363: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52364: LD_ADDR_EXP 79
52368: PUSH
52369: LD_EXP 79
52373: PPUSH
52374: LD_VAR 0 1
52378: PPUSH
52379: EMPTY
52380: PPUSH
52381: CALL_OW 1
52385: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52386: LD_ADDR_EXP 80
52390: PUSH
52391: LD_EXP 80
52395: PPUSH
52396: LD_VAR 0 1
52400: PPUSH
52401: EMPTY
52402: PPUSH
52403: CALL_OW 1
52407: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52408: LD_ADDR_EXP 81
52412: PUSH
52413: LD_EXP 81
52417: PPUSH
52418: LD_VAR 0 1
52422: PPUSH
52423: EMPTY
52424: PPUSH
52425: CALL_OW 1
52429: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52430: LD_ADDR_EXP 82
52434: PUSH
52435: LD_EXP 82
52439: PPUSH
52440: LD_VAR 0 1
52444: PPUSH
52445: EMPTY
52446: PPUSH
52447: CALL_OW 1
52451: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52452: LD_ADDR_EXP 83
52456: PUSH
52457: LD_EXP 83
52461: PPUSH
52462: LD_VAR 0 1
52466: PPUSH
52467: EMPTY
52468: PPUSH
52469: CALL_OW 1
52473: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52474: LD_ADDR_EXP 84
52478: PUSH
52479: LD_EXP 84
52483: PPUSH
52484: LD_VAR 0 1
52488: PPUSH
52489: EMPTY
52490: PPUSH
52491: CALL_OW 1
52495: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52496: LD_ADDR_EXP 85
52500: PUSH
52501: LD_EXP 85
52505: PPUSH
52506: LD_VAR 0 1
52510: PPUSH
52511: LD_INT 0
52513: PPUSH
52514: CALL_OW 1
52518: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52519: LD_ADDR_EXP 86
52523: PUSH
52524: LD_EXP 86
52528: PPUSH
52529: LD_VAR 0 1
52533: PPUSH
52534: LD_INT 0
52536: PPUSH
52537: CALL_OW 1
52541: ST_TO_ADDR
// end ;
52542: LD_VAR 0 2
52546: RET
// export function MC_Add ( side , units ) ; var base ; begin
52547: LD_INT 0
52549: PPUSH
52550: PPUSH
// base := mc_bases + 1 ;
52551: LD_ADDR_VAR 0 4
52555: PUSH
52556: LD_EXP 43
52560: PUSH
52561: LD_INT 1
52563: PLUS
52564: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52565: LD_ADDR_EXP 69
52569: PUSH
52570: LD_EXP 69
52574: PPUSH
52575: LD_VAR 0 4
52579: PPUSH
52580: LD_VAR 0 1
52584: PPUSH
52585: CALL_OW 1
52589: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52590: LD_ADDR_EXP 43
52594: PUSH
52595: LD_EXP 43
52599: PPUSH
52600: LD_VAR 0 4
52604: PPUSH
52605: LD_VAR 0 2
52609: PPUSH
52610: CALL_OW 1
52614: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52615: LD_ADDR_EXP 44
52619: PUSH
52620: LD_EXP 44
52624: PPUSH
52625: LD_VAR 0 4
52629: PPUSH
52630: EMPTY
52631: PPUSH
52632: CALL_OW 1
52636: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52637: LD_ADDR_EXP 45
52641: PUSH
52642: LD_EXP 45
52646: PPUSH
52647: LD_VAR 0 4
52651: PPUSH
52652: EMPTY
52653: PPUSH
52654: CALL_OW 1
52658: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52659: LD_ADDR_EXP 46
52663: PUSH
52664: LD_EXP 46
52668: PPUSH
52669: LD_VAR 0 4
52673: PPUSH
52674: EMPTY
52675: PPUSH
52676: CALL_OW 1
52680: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52681: LD_ADDR_EXP 47
52685: PUSH
52686: LD_EXP 47
52690: PPUSH
52691: LD_VAR 0 4
52695: PPUSH
52696: EMPTY
52697: PPUSH
52698: CALL_OW 1
52702: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52703: LD_ADDR_EXP 48
52707: PUSH
52708: LD_EXP 48
52712: PPUSH
52713: LD_VAR 0 4
52717: PPUSH
52718: EMPTY
52719: PPUSH
52720: CALL_OW 1
52724: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52725: LD_ADDR_EXP 49
52729: PUSH
52730: LD_EXP 49
52734: PPUSH
52735: LD_VAR 0 4
52739: PPUSH
52740: EMPTY
52741: PPUSH
52742: CALL_OW 1
52746: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52747: LD_ADDR_EXP 50
52751: PUSH
52752: LD_EXP 50
52756: PPUSH
52757: LD_VAR 0 4
52761: PPUSH
52762: EMPTY
52763: PPUSH
52764: CALL_OW 1
52768: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52769: LD_ADDR_EXP 51
52773: PUSH
52774: LD_EXP 51
52778: PPUSH
52779: LD_VAR 0 4
52783: PPUSH
52784: EMPTY
52785: PPUSH
52786: CALL_OW 1
52790: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52791: LD_ADDR_EXP 52
52795: PUSH
52796: LD_EXP 52
52800: PPUSH
52801: LD_VAR 0 4
52805: PPUSH
52806: EMPTY
52807: PPUSH
52808: CALL_OW 1
52812: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52813: LD_ADDR_EXP 53
52817: PUSH
52818: LD_EXP 53
52822: PPUSH
52823: LD_VAR 0 4
52827: PPUSH
52828: EMPTY
52829: PPUSH
52830: CALL_OW 1
52834: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52835: LD_ADDR_EXP 54
52839: PUSH
52840: LD_EXP 54
52844: PPUSH
52845: LD_VAR 0 4
52849: PPUSH
52850: LD_INT 0
52852: PPUSH
52853: CALL_OW 1
52857: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52858: LD_ADDR_EXP 55
52862: PUSH
52863: LD_EXP 55
52867: PPUSH
52868: LD_VAR 0 4
52872: PPUSH
52873: EMPTY
52874: PPUSH
52875: CALL_OW 1
52879: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52880: LD_ADDR_EXP 56
52884: PUSH
52885: LD_EXP 56
52889: PPUSH
52890: LD_VAR 0 4
52894: PPUSH
52895: EMPTY
52896: PPUSH
52897: CALL_OW 1
52901: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52902: LD_ADDR_EXP 57
52906: PUSH
52907: LD_EXP 57
52911: PPUSH
52912: LD_VAR 0 4
52916: PPUSH
52917: EMPTY
52918: PPUSH
52919: CALL_OW 1
52923: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52924: LD_ADDR_EXP 58
52928: PUSH
52929: LD_EXP 58
52933: PPUSH
52934: LD_VAR 0 4
52938: PPUSH
52939: EMPTY
52940: PPUSH
52941: CALL_OW 1
52945: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52946: LD_ADDR_EXP 59
52950: PUSH
52951: LD_EXP 59
52955: PPUSH
52956: LD_VAR 0 4
52960: PPUSH
52961: EMPTY
52962: PPUSH
52963: CALL_OW 1
52967: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52968: LD_ADDR_EXP 60
52972: PUSH
52973: LD_EXP 60
52977: PPUSH
52978: LD_VAR 0 4
52982: PPUSH
52983: EMPTY
52984: PPUSH
52985: CALL_OW 1
52989: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52990: LD_ADDR_EXP 61
52994: PUSH
52995: LD_EXP 61
52999: PPUSH
53000: LD_VAR 0 4
53004: PPUSH
53005: EMPTY
53006: PPUSH
53007: CALL_OW 1
53011: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53012: LD_ADDR_EXP 62
53016: PUSH
53017: LD_EXP 62
53021: PPUSH
53022: LD_VAR 0 4
53026: PPUSH
53027: EMPTY
53028: PPUSH
53029: CALL_OW 1
53033: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53034: LD_ADDR_EXP 63
53038: PUSH
53039: LD_EXP 63
53043: PPUSH
53044: LD_VAR 0 4
53048: PPUSH
53049: EMPTY
53050: PPUSH
53051: CALL_OW 1
53055: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53056: LD_ADDR_EXP 64
53060: PUSH
53061: LD_EXP 64
53065: PPUSH
53066: LD_VAR 0 4
53070: PPUSH
53071: EMPTY
53072: PPUSH
53073: CALL_OW 1
53077: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53078: LD_ADDR_EXP 65
53082: PUSH
53083: LD_EXP 65
53087: PPUSH
53088: LD_VAR 0 4
53092: PPUSH
53093: EMPTY
53094: PPUSH
53095: CALL_OW 1
53099: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53100: LD_ADDR_EXP 66
53104: PUSH
53105: LD_EXP 66
53109: PPUSH
53110: LD_VAR 0 4
53114: PPUSH
53115: EMPTY
53116: PPUSH
53117: CALL_OW 1
53121: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53122: LD_ADDR_EXP 67
53126: PUSH
53127: LD_EXP 67
53131: PPUSH
53132: LD_VAR 0 4
53136: PPUSH
53137: EMPTY
53138: PPUSH
53139: CALL_OW 1
53143: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53144: LD_ADDR_EXP 68
53148: PUSH
53149: LD_EXP 68
53153: PPUSH
53154: LD_VAR 0 4
53158: PPUSH
53159: EMPTY
53160: PPUSH
53161: CALL_OW 1
53165: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53166: LD_ADDR_EXP 70
53170: PUSH
53171: LD_EXP 70
53175: PPUSH
53176: LD_VAR 0 4
53180: PPUSH
53181: EMPTY
53182: PPUSH
53183: CALL_OW 1
53187: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53188: LD_ADDR_EXP 72
53192: PUSH
53193: LD_EXP 72
53197: PPUSH
53198: LD_VAR 0 4
53202: PPUSH
53203: EMPTY
53204: PPUSH
53205: CALL_OW 1
53209: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53210: LD_ADDR_EXP 73
53214: PUSH
53215: LD_EXP 73
53219: PPUSH
53220: LD_VAR 0 4
53224: PPUSH
53225: EMPTY
53226: PPUSH
53227: CALL_OW 1
53231: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53232: LD_ADDR_EXP 74
53236: PUSH
53237: LD_EXP 74
53241: PPUSH
53242: LD_VAR 0 4
53246: PPUSH
53247: EMPTY
53248: PPUSH
53249: CALL_OW 1
53253: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53254: LD_ADDR_EXP 75
53258: PUSH
53259: LD_EXP 75
53263: PPUSH
53264: LD_VAR 0 4
53268: PPUSH
53269: EMPTY
53270: PPUSH
53271: CALL_OW 1
53275: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53276: LD_ADDR_EXP 76
53280: PUSH
53281: LD_EXP 76
53285: PPUSH
53286: LD_VAR 0 4
53290: PPUSH
53291: EMPTY
53292: PPUSH
53293: CALL_OW 1
53297: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53298: LD_ADDR_EXP 77
53302: PUSH
53303: LD_EXP 77
53307: PPUSH
53308: LD_VAR 0 4
53312: PPUSH
53313: EMPTY
53314: PPUSH
53315: CALL_OW 1
53319: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53320: LD_ADDR_EXP 78
53324: PUSH
53325: LD_EXP 78
53329: PPUSH
53330: LD_VAR 0 4
53334: PPUSH
53335: EMPTY
53336: PPUSH
53337: CALL_OW 1
53341: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53342: LD_ADDR_EXP 79
53346: PUSH
53347: LD_EXP 79
53351: PPUSH
53352: LD_VAR 0 4
53356: PPUSH
53357: EMPTY
53358: PPUSH
53359: CALL_OW 1
53363: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53364: LD_ADDR_EXP 80
53368: PUSH
53369: LD_EXP 80
53373: PPUSH
53374: LD_VAR 0 4
53378: PPUSH
53379: EMPTY
53380: PPUSH
53381: CALL_OW 1
53385: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53386: LD_ADDR_EXP 81
53390: PUSH
53391: LD_EXP 81
53395: PPUSH
53396: LD_VAR 0 4
53400: PPUSH
53401: EMPTY
53402: PPUSH
53403: CALL_OW 1
53407: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53408: LD_ADDR_EXP 82
53412: PUSH
53413: LD_EXP 82
53417: PPUSH
53418: LD_VAR 0 4
53422: PPUSH
53423: EMPTY
53424: PPUSH
53425: CALL_OW 1
53429: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53430: LD_ADDR_EXP 83
53434: PUSH
53435: LD_EXP 83
53439: PPUSH
53440: LD_VAR 0 4
53444: PPUSH
53445: EMPTY
53446: PPUSH
53447: CALL_OW 1
53451: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53452: LD_ADDR_EXP 84
53456: PUSH
53457: LD_EXP 84
53461: PPUSH
53462: LD_VAR 0 4
53466: PPUSH
53467: EMPTY
53468: PPUSH
53469: CALL_OW 1
53473: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53474: LD_ADDR_EXP 85
53478: PUSH
53479: LD_EXP 85
53483: PPUSH
53484: LD_VAR 0 4
53488: PPUSH
53489: LD_INT 0
53491: PPUSH
53492: CALL_OW 1
53496: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53497: LD_ADDR_EXP 86
53501: PUSH
53502: LD_EXP 86
53506: PPUSH
53507: LD_VAR 0 4
53511: PPUSH
53512: LD_INT 0
53514: PPUSH
53515: CALL_OW 1
53519: ST_TO_ADDR
// result := base ;
53520: LD_ADDR_VAR 0 3
53524: PUSH
53525: LD_VAR 0 4
53529: ST_TO_ADDR
// end ;
53530: LD_VAR 0 3
53534: RET
// export function MC_Start ( ) ; var i ; begin
53535: LD_INT 0
53537: PPUSH
53538: PPUSH
// for i = 1 to mc_bases do
53539: LD_ADDR_VAR 0 2
53543: PUSH
53544: DOUBLE
53545: LD_INT 1
53547: DEC
53548: ST_TO_ADDR
53549: LD_EXP 43
53553: PUSH
53554: FOR_TO
53555: IFFALSE 54655
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53557: LD_ADDR_EXP 43
53561: PUSH
53562: LD_EXP 43
53566: PPUSH
53567: LD_VAR 0 2
53571: PPUSH
53572: LD_EXP 43
53576: PUSH
53577: LD_VAR 0 2
53581: ARRAY
53582: PUSH
53583: LD_INT 0
53585: DIFF
53586: PPUSH
53587: CALL_OW 1
53591: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53592: LD_ADDR_EXP 44
53596: PUSH
53597: LD_EXP 44
53601: PPUSH
53602: LD_VAR 0 2
53606: PPUSH
53607: EMPTY
53608: PPUSH
53609: CALL_OW 1
53613: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53614: LD_ADDR_EXP 45
53618: PUSH
53619: LD_EXP 45
53623: PPUSH
53624: LD_VAR 0 2
53628: PPUSH
53629: EMPTY
53630: PPUSH
53631: CALL_OW 1
53635: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53636: LD_ADDR_EXP 46
53640: PUSH
53641: LD_EXP 46
53645: PPUSH
53646: LD_VAR 0 2
53650: PPUSH
53651: EMPTY
53652: PPUSH
53653: CALL_OW 1
53657: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53658: LD_ADDR_EXP 47
53662: PUSH
53663: LD_EXP 47
53667: PPUSH
53668: LD_VAR 0 2
53672: PPUSH
53673: EMPTY
53674: PUSH
53675: EMPTY
53676: PUSH
53677: EMPTY
53678: LIST
53679: LIST
53680: PPUSH
53681: CALL_OW 1
53685: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53686: LD_ADDR_EXP 48
53690: PUSH
53691: LD_EXP 48
53695: PPUSH
53696: LD_VAR 0 2
53700: PPUSH
53701: EMPTY
53702: PPUSH
53703: CALL_OW 1
53707: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53708: LD_ADDR_EXP 75
53712: PUSH
53713: LD_EXP 75
53717: PPUSH
53718: LD_VAR 0 2
53722: PPUSH
53723: EMPTY
53724: PPUSH
53725: CALL_OW 1
53729: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53730: LD_ADDR_EXP 49
53734: PUSH
53735: LD_EXP 49
53739: PPUSH
53740: LD_VAR 0 2
53744: PPUSH
53745: EMPTY
53746: PPUSH
53747: CALL_OW 1
53751: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53752: LD_ADDR_EXP 50
53756: PUSH
53757: LD_EXP 50
53761: PPUSH
53762: LD_VAR 0 2
53766: PPUSH
53767: EMPTY
53768: PPUSH
53769: CALL_OW 1
53773: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53774: LD_ADDR_EXP 51
53778: PUSH
53779: LD_EXP 51
53783: PPUSH
53784: LD_VAR 0 2
53788: PPUSH
53789: LD_EXP 43
53793: PUSH
53794: LD_VAR 0 2
53798: ARRAY
53799: PPUSH
53800: LD_INT 2
53802: PUSH
53803: LD_INT 30
53805: PUSH
53806: LD_INT 32
53808: PUSH
53809: EMPTY
53810: LIST
53811: LIST
53812: PUSH
53813: LD_INT 30
53815: PUSH
53816: LD_INT 33
53818: PUSH
53819: EMPTY
53820: LIST
53821: LIST
53822: PUSH
53823: EMPTY
53824: LIST
53825: LIST
53826: LIST
53827: PPUSH
53828: CALL_OW 72
53832: PPUSH
53833: CALL_OW 1
53837: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53838: LD_ADDR_EXP 52
53842: PUSH
53843: LD_EXP 52
53847: PPUSH
53848: LD_VAR 0 2
53852: PPUSH
53853: LD_EXP 43
53857: PUSH
53858: LD_VAR 0 2
53862: ARRAY
53863: PPUSH
53864: LD_INT 2
53866: PUSH
53867: LD_INT 30
53869: PUSH
53870: LD_INT 32
53872: PUSH
53873: EMPTY
53874: LIST
53875: LIST
53876: PUSH
53877: LD_INT 30
53879: PUSH
53880: LD_INT 31
53882: PUSH
53883: EMPTY
53884: LIST
53885: LIST
53886: PUSH
53887: EMPTY
53888: LIST
53889: LIST
53890: LIST
53891: PUSH
53892: LD_INT 58
53894: PUSH
53895: EMPTY
53896: LIST
53897: PUSH
53898: EMPTY
53899: LIST
53900: LIST
53901: PPUSH
53902: CALL_OW 72
53906: PPUSH
53907: CALL_OW 1
53911: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53912: LD_ADDR_EXP 53
53916: PUSH
53917: LD_EXP 53
53921: PPUSH
53922: LD_VAR 0 2
53926: PPUSH
53927: EMPTY
53928: PPUSH
53929: CALL_OW 1
53933: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53934: LD_ADDR_EXP 57
53938: PUSH
53939: LD_EXP 57
53943: PPUSH
53944: LD_VAR 0 2
53948: PPUSH
53949: EMPTY
53950: PPUSH
53951: CALL_OW 1
53955: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53956: LD_ADDR_EXP 56
53960: PUSH
53961: LD_EXP 56
53965: PPUSH
53966: LD_VAR 0 2
53970: PPUSH
53971: EMPTY
53972: PPUSH
53973: CALL_OW 1
53977: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53978: LD_ADDR_EXP 58
53982: PUSH
53983: LD_EXP 58
53987: PPUSH
53988: LD_VAR 0 2
53992: PPUSH
53993: EMPTY
53994: PPUSH
53995: CALL_OW 1
53999: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54000: LD_ADDR_EXP 59
54004: PUSH
54005: LD_EXP 59
54009: PPUSH
54010: LD_VAR 0 2
54014: PPUSH
54015: EMPTY
54016: PPUSH
54017: CALL_OW 1
54021: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54022: LD_ADDR_EXP 60
54026: PUSH
54027: LD_EXP 60
54031: PPUSH
54032: LD_VAR 0 2
54036: PPUSH
54037: EMPTY
54038: PPUSH
54039: CALL_OW 1
54043: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54044: LD_ADDR_EXP 61
54048: PUSH
54049: LD_EXP 61
54053: PPUSH
54054: LD_VAR 0 2
54058: PPUSH
54059: EMPTY
54060: PPUSH
54061: CALL_OW 1
54065: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54066: LD_ADDR_EXP 62
54070: PUSH
54071: LD_EXP 62
54075: PPUSH
54076: LD_VAR 0 2
54080: PPUSH
54081: EMPTY
54082: PPUSH
54083: CALL_OW 1
54087: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54088: LD_ADDR_EXP 63
54092: PUSH
54093: LD_EXP 63
54097: PPUSH
54098: LD_VAR 0 2
54102: PPUSH
54103: EMPTY
54104: PPUSH
54105: CALL_OW 1
54109: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54110: LD_ADDR_EXP 64
54114: PUSH
54115: LD_EXP 64
54119: PPUSH
54120: LD_VAR 0 2
54124: PPUSH
54125: EMPTY
54126: PPUSH
54127: CALL_OW 1
54131: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54132: LD_ADDR_EXP 65
54136: PUSH
54137: LD_EXP 65
54141: PPUSH
54142: LD_VAR 0 2
54146: PPUSH
54147: EMPTY
54148: PPUSH
54149: CALL_OW 1
54153: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54154: LD_ADDR_EXP 54
54158: PUSH
54159: LD_EXP 54
54163: PPUSH
54164: LD_VAR 0 2
54168: PPUSH
54169: LD_INT 0
54171: PPUSH
54172: CALL_OW 1
54176: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54177: LD_ADDR_EXP 67
54181: PUSH
54182: LD_EXP 67
54186: PPUSH
54187: LD_VAR 0 2
54191: PPUSH
54192: LD_INT 0
54194: PPUSH
54195: CALL_OW 1
54199: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54200: LD_ADDR_EXP 55
54204: PUSH
54205: LD_EXP 55
54209: PPUSH
54210: LD_VAR 0 2
54214: PPUSH
54215: EMPTY
54216: PPUSH
54217: CALL_OW 1
54221: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54222: LD_ADDR_EXP 66
54226: PUSH
54227: LD_EXP 66
54231: PPUSH
54232: LD_VAR 0 2
54236: PPUSH
54237: LD_INT 0
54239: PPUSH
54240: CALL_OW 1
54244: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54245: LD_ADDR_EXP 68
54249: PUSH
54250: LD_EXP 68
54254: PPUSH
54255: LD_VAR 0 2
54259: PPUSH
54260: EMPTY
54261: PPUSH
54262: CALL_OW 1
54266: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54267: LD_ADDR_EXP 71
54271: PUSH
54272: LD_EXP 71
54276: PPUSH
54277: LD_VAR 0 2
54281: PPUSH
54282: LD_INT 0
54284: PPUSH
54285: CALL_OW 1
54289: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54290: LD_ADDR_EXP 72
54294: PUSH
54295: LD_EXP 72
54299: PPUSH
54300: LD_VAR 0 2
54304: PPUSH
54305: EMPTY
54306: PPUSH
54307: CALL_OW 1
54311: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54312: LD_ADDR_EXP 73
54316: PUSH
54317: LD_EXP 73
54321: PPUSH
54322: LD_VAR 0 2
54326: PPUSH
54327: EMPTY
54328: PPUSH
54329: CALL_OW 1
54333: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54334: LD_ADDR_EXP 74
54338: PUSH
54339: LD_EXP 74
54343: PPUSH
54344: LD_VAR 0 2
54348: PPUSH
54349: EMPTY
54350: PPUSH
54351: CALL_OW 1
54355: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54356: LD_ADDR_EXP 76
54360: PUSH
54361: LD_EXP 76
54365: PPUSH
54366: LD_VAR 0 2
54370: PPUSH
54371: LD_EXP 43
54375: PUSH
54376: LD_VAR 0 2
54380: ARRAY
54381: PPUSH
54382: LD_INT 2
54384: PUSH
54385: LD_INT 30
54387: PUSH
54388: LD_INT 6
54390: PUSH
54391: EMPTY
54392: LIST
54393: LIST
54394: PUSH
54395: LD_INT 30
54397: PUSH
54398: LD_INT 7
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: PUSH
54405: LD_INT 30
54407: PUSH
54408: LD_INT 8
54410: PUSH
54411: EMPTY
54412: LIST
54413: LIST
54414: PUSH
54415: EMPTY
54416: LIST
54417: LIST
54418: LIST
54419: LIST
54420: PPUSH
54421: CALL_OW 72
54425: PPUSH
54426: CALL_OW 1
54430: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54431: LD_ADDR_EXP 77
54435: PUSH
54436: LD_EXP 77
54440: PPUSH
54441: LD_VAR 0 2
54445: PPUSH
54446: EMPTY
54447: PPUSH
54448: CALL_OW 1
54452: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54453: LD_ADDR_EXP 78
54457: PUSH
54458: LD_EXP 78
54462: PPUSH
54463: LD_VAR 0 2
54467: PPUSH
54468: EMPTY
54469: PPUSH
54470: CALL_OW 1
54474: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54475: LD_ADDR_EXP 79
54479: PUSH
54480: LD_EXP 79
54484: PPUSH
54485: LD_VAR 0 2
54489: PPUSH
54490: EMPTY
54491: PPUSH
54492: CALL_OW 1
54496: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54497: LD_ADDR_EXP 80
54501: PUSH
54502: LD_EXP 80
54506: PPUSH
54507: LD_VAR 0 2
54511: PPUSH
54512: EMPTY
54513: PPUSH
54514: CALL_OW 1
54518: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54519: LD_ADDR_EXP 81
54523: PUSH
54524: LD_EXP 81
54528: PPUSH
54529: LD_VAR 0 2
54533: PPUSH
54534: EMPTY
54535: PPUSH
54536: CALL_OW 1
54540: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54541: LD_ADDR_EXP 82
54545: PUSH
54546: LD_EXP 82
54550: PPUSH
54551: LD_VAR 0 2
54555: PPUSH
54556: EMPTY
54557: PPUSH
54558: CALL_OW 1
54562: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54563: LD_ADDR_EXP 83
54567: PUSH
54568: LD_EXP 83
54572: PPUSH
54573: LD_VAR 0 2
54577: PPUSH
54578: EMPTY
54579: PPUSH
54580: CALL_OW 1
54584: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54585: LD_ADDR_EXP 84
54589: PUSH
54590: LD_EXP 84
54594: PPUSH
54595: LD_VAR 0 2
54599: PPUSH
54600: EMPTY
54601: PPUSH
54602: CALL_OW 1
54606: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54607: LD_ADDR_EXP 85
54611: PUSH
54612: LD_EXP 85
54616: PPUSH
54617: LD_VAR 0 2
54621: PPUSH
54622: LD_INT 0
54624: PPUSH
54625: CALL_OW 1
54629: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54630: LD_ADDR_EXP 86
54634: PUSH
54635: LD_EXP 86
54639: PPUSH
54640: LD_VAR 0 2
54644: PPUSH
54645: LD_INT 0
54647: PPUSH
54648: CALL_OW 1
54652: ST_TO_ADDR
// end ;
54653: GO 53554
54655: POP
54656: POP
// MC_InitSides ( ) ;
54657: CALL 54943 0 0
// MC_InitResearch ( ) ;
54661: CALL 54682 0 0
// CustomInitMacro ( ) ;
54665: CALL 78 0 0
// skirmish := true ;
54669: LD_ADDR_EXP 41
54673: PUSH
54674: LD_INT 1
54676: ST_TO_ADDR
// end ;
54677: LD_VAR 0 1
54681: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54682: LD_INT 0
54684: PPUSH
54685: PPUSH
54686: PPUSH
54687: PPUSH
54688: PPUSH
54689: PPUSH
// if not mc_bases then
54690: LD_EXP 43
54694: NOT
54695: IFFALSE 54699
// exit ;
54697: GO 54938
// for i = 1 to 8 do
54699: LD_ADDR_VAR 0 2
54703: PUSH
54704: DOUBLE
54705: LD_INT 1
54707: DEC
54708: ST_TO_ADDR
54709: LD_INT 8
54711: PUSH
54712: FOR_TO
54713: IFFALSE 54739
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54715: LD_ADDR_EXP 70
54719: PUSH
54720: LD_EXP 70
54724: PPUSH
54725: LD_VAR 0 2
54729: PPUSH
54730: EMPTY
54731: PPUSH
54732: CALL_OW 1
54736: ST_TO_ADDR
54737: GO 54712
54739: POP
54740: POP
// tmp := [ ] ;
54741: LD_ADDR_VAR 0 5
54745: PUSH
54746: EMPTY
54747: ST_TO_ADDR
// for i = 1 to mc_sides do
54748: LD_ADDR_VAR 0 2
54752: PUSH
54753: DOUBLE
54754: LD_INT 1
54756: DEC
54757: ST_TO_ADDR
54758: LD_EXP 69
54762: PUSH
54763: FOR_TO
54764: IFFALSE 54822
// if not mc_sides [ i ] in tmp then
54766: LD_EXP 69
54770: PUSH
54771: LD_VAR 0 2
54775: ARRAY
54776: PUSH
54777: LD_VAR 0 5
54781: IN
54782: NOT
54783: IFFALSE 54820
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54785: LD_ADDR_VAR 0 5
54789: PUSH
54790: LD_VAR 0 5
54794: PPUSH
54795: LD_VAR 0 5
54799: PUSH
54800: LD_INT 1
54802: PLUS
54803: PPUSH
54804: LD_EXP 69
54808: PUSH
54809: LD_VAR 0 2
54813: ARRAY
54814: PPUSH
54815: CALL_OW 2
54819: ST_TO_ADDR
54820: GO 54763
54822: POP
54823: POP
// if not tmp then
54824: LD_VAR 0 5
54828: NOT
54829: IFFALSE 54833
// exit ;
54831: GO 54938
// for j in tmp do
54833: LD_ADDR_VAR 0 3
54837: PUSH
54838: LD_VAR 0 5
54842: PUSH
54843: FOR_IN
54844: IFFALSE 54936
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54846: LD_ADDR_VAR 0 6
54850: PUSH
54851: LD_INT 22
54853: PUSH
54854: LD_VAR 0 3
54858: PUSH
54859: EMPTY
54860: LIST
54861: LIST
54862: PPUSH
54863: CALL_OW 69
54867: ST_TO_ADDR
// if not un then
54868: LD_VAR 0 6
54872: NOT
54873: IFFALSE 54877
// continue ;
54875: GO 54843
// nation := GetNation ( un [ 1 ] ) ;
54877: LD_ADDR_VAR 0 4
54881: PUSH
54882: LD_VAR 0 6
54886: PUSH
54887: LD_INT 1
54889: ARRAY
54890: PPUSH
54891: CALL_OW 248
54895: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54896: LD_ADDR_EXP 70
54900: PUSH
54901: LD_EXP 70
54905: PPUSH
54906: LD_VAR 0 3
54910: PPUSH
54911: LD_VAR 0 3
54915: PPUSH
54916: LD_VAR 0 4
54920: PPUSH
54921: LD_INT 1
54923: PPUSH
54924: CALL 9875 0 3
54928: PPUSH
54929: CALL_OW 1
54933: ST_TO_ADDR
// end ;
54934: GO 54843
54936: POP
54937: POP
// end ;
54938: LD_VAR 0 1
54942: RET
// export function MC_InitSides ( ) ; var i ; begin
54943: LD_INT 0
54945: PPUSH
54946: PPUSH
// if not mc_bases then
54947: LD_EXP 43
54951: NOT
54952: IFFALSE 54956
// exit ;
54954: GO 55030
// for i = 1 to mc_bases do
54956: LD_ADDR_VAR 0 2
54960: PUSH
54961: DOUBLE
54962: LD_INT 1
54964: DEC
54965: ST_TO_ADDR
54966: LD_EXP 43
54970: PUSH
54971: FOR_TO
54972: IFFALSE 55028
// if mc_bases [ i ] then
54974: LD_EXP 43
54978: PUSH
54979: LD_VAR 0 2
54983: ARRAY
54984: IFFALSE 55026
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54986: LD_ADDR_EXP 69
54990: PUSH
54991: LD_EXP 69
54995: PPUSH
54996: LD_VAR 0 2
55000: PPUSH
55001: LD_EXP 43
55005: PUSH
55006: LD_VAR 0 2
55010: ARRAY
55011: PUSH
55012: LD_INT 1
55014: ARRAY
55015: PPUSH
55016: CALL_OW 255
55020: PPUSH
55021: CALL_OW 1
55025: ST_TO_ADDR
55026: GO 54971
55028: POP
55029: POP
// end ;
55030: LD_VAR 0 1
55034: RET
// every 0 0$03 trigger skirmish do
55035: LD_EXP 41
55039: IFFALSE 55193
55041: GO 55043
55043: DISABLE
// begin enable ;
55044: ENABLE
// MC_CheckBuildings ( ) ;
55045: CALL 59705 0 0
// MC_CheckPeopleLife ( ) ;
55049: CALL 59866 0 0
// RaiseSailEvent ( 100 ) ;
55053: LD_INT 100
55055: PPUSH
55056: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55060: LD_INT 103
55062: PPUSH
55063: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55067: LD_INT 104
55069: PPUSH
55070: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55074: LD_INT 105
55076: PPUSH
55077: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55081: LD_INT 106
55083: PPUSH
55084: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55088: LD_INT 107
55090: PPUSH
55091: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55095: LD_INT 108
55097: PPUSH
55098: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55102: LD_INT 109
55104: PPUSH
55105: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55109: LD_INT 110
55111: PPUSH
55112: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55116: LD_INT 111
55118: PPUSH
55119: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55123: LD_INT 112
55125: PPUSH
55126: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55130: LD_INT 113
55132: PPUSH
55133: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55137: LD_INT 120
55139: PPUSH
55140: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55144: LD_INT 121
55146: PPUSH
55147: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55151: LD_INT 122
55153: PPUSH
55154: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55158: LD_INT 123
55160: PPUSH
55161: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55165: LD_INT 124
55167: PPUSH
55168: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55172: LD_INT 125
55174: PPUSH
55175: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55179: LD_INT 126
55181: PPUSH
55182: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55186: LD_INT 200
55188: PPUSH
55189: CALL_OW 427
// end ;
55193: END
// on SailEvent ( event ) do begin if event < 100 then
55194: LD_VAR 0 1
55198: PUSH
55199: LD_INT 100
55201: LESS
55202: IFFALSE 55213
// CustomEvent ( event ) ;
55204: LD_VAR 0 1
55208: PPUSH
55209: CALL 584 0 1
// if event = 100 then
55213: LD_VAR 0 1
55217: PUSH
55218: LD_INT 100
55220: EQUAL
55221: IFFALSE 55227
// MC_ClassManager ( ) ;
55223: CALL 55619 0 0
// if event = 101 then
55227: LD_VAR 0 1
55231: PUSH
55232: LD_INT 101
55234: EQUAL
55235: IFFALSE 55241
// MC_RepairBuildings ( ) ;
55237: CALL 60451 0 0
// if event = 102 then
55241: LD_VAR 0 1
55245: PUSH
55246: LD_INT 102
55248: EQUAL
55249: IFFALSE 55255
// MC_Heal ( ) ;
55251: CALL 61386 0 0
// if event = 103 then
55255: LD_VAR 0 1
55259: PUSH
55260: LD_INT 103
55262: EQUAL
55263: IFFALSE 55269
// MC_Build ( ) ;
55265: CALL 61808 0 0
// if event = 104 then
55269: LD_VAR 0 1
55273: PUSH
55274: LD_INT 104
55276: EQUAL
55277: IFFALSE 55283
// MC_TurretWeapon ( ) ;
55279: CALL 63442 0 0
// if event = 105 then
55283: LD_VAR 0 1
55287: PUSH
55288: LD_INT 105
55290: EQUAL
55291: IFFALSE 55297
// MC_BuildUpgrade ( ) ;
55293: CALL 62993 0 0
// if event = 106 then
55297: LD_VAR 0 1
55301: PUSH
55302: LD_INT 106
55304: EQUAL
55305: IFFALSE 55311
// MC_PlantMines ( ) ;
55307: CALL 63872 0 0
// if event = 107 then
55311: LD_VAR 0 1
55315: PUSH
55316: LD_INT 107
55318: EQUAL
55319: IFFALSE 55325
// MC_CollectCrates ( ) ;
55321: CALL 64670 0 0
// if event = 108 then
55325: LD_VAR 0 1
55329: PUSH
55330: LD_INT 108
55332: EQUAL
55333: IFFALSE 55339
// MC_LinkRemoteControl ( ) ;
55335: CALL 66520 0 0
// if event = 109 then
55339: LD_VAR 0 1
55343: PUSH
55344: LD_INT 109
55346: EQUAL
55347: IFFALSE 55353
// MC_ProduceVehicle ( ) ;
55349: CALL 66701 0 0
// if event = 110 then
55353: LD_VAR 0 1
55357: PUSH
55358: LD_INT 110
55360: EQUAL
55361: IFFALSE 55367
// MC_SendAttack ( ) ;
55363: CALL 67167 0 0
// if event = 111 then
55367: LD_VAR 0 1
55371: PUSH
55372: LD_INT 111
55374: EQUAL
55375: IFFALSE 55381
// MC_Defend ( ) ;
55377: CALL 67275 0 0
// if event = 112 then
55381: LD_VAR 0 1
55385: PUSH
55386: LD_INT 112
55388: EQUAL
55389: IFFALSE 55395
// MC_Research ( ) ;
55391: CALL 68155 0 0
// if event = 113 then
55395: LD_VAR 0 1
55399: PUSH
55400: LD_INT 113
55402: EQUAL
55403: IFFALSE 55409
// MC_MinesTrigger ( ) ;
55405: CALL 69269 0 0
// if event = 120 then
55409: LD_VAR 0 1
55413: PUSH
55414: LD_INT 120
55416: EQUAL
55417: IFFALSE 55423
// MC_RepairVehicle ( ) ;
55419: CALL 69368 0 0
// if event = 121 then
55423: LD_VAR 0 1
55427: PUSH
55428: LD_INT 121
55430: EQUAL
55431: IFFALSE 55437
// MC_TameApe ( ) ;
55433: CALL 70137 0 0
// if event = 122 then
55437: LD_VAR 0 1
55441: PUSH
55442: LD_INT 122
55444: EQUAL
55445: IFFALSE 55451
// MC_ChangeApeClass ( ) ;
55447: CALL 70966 0 0
// if event = 123 then
55451: LD_VAR 0 1
55455: PUSH
55456: LD_INT 123
55458: EQUAL
55459: IFFALSE 55465
// MC_Bazooka ( ) ;
55461: CALL 71616 0 0
// if event = 124 then
55465: LD_VAR 0 1
55469: PUSH
55470: LD_INT 124
55472: EQUAL
55473: IFFALSE 55479
// MC_TeleportExit ( ) ;
55475: CALL 71814 0 0
// if event = 125 then
55479: LD_VAR 0 1
55483: PUSH
55484: LD_INT 125
55486: EQUAL
55487: IFFALSE 55493
// MC_Deposits ( ) ;
55489: CALL 72461 0 0
// if event = 126 then
55493: LD_VAR 0 1
55497: PUSH
55498: LD_INT 126
55500: EQUAL
55501: IFFALSE 55507
// MC_RemoteDriver ( ) ;
55503: CALL 73086 0 0
// if event = 200 then
55507: LD_VAR 0 1
55511: PUSH
55512: LD_INT 200
55514: EQUAL
55515: IFFALSE 55521
// MC_Idle ( ) ;
55517: CALL 74993 0 0
// end ;
55521: PPOPN 1
55523: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55524: LD_INT 0
55526: PPUSH
55527: PPUSH
// if not mc_bases [ base ] or not tag then
55528: LD_EXP 43
55532: PUSH
55533: LD_VAR 0 1
55537: ARRAY
55538: NOT
55539: PUSH
55540: LD_VAR 0 2
55544: NOT
55545: OR
55546: IFFALSE 55550
// exit ;
55548: GO 55614
// for i in mc_bases [ base ] union mc_ape [ base ] do
55550: LD_ADDR_VAR 0 4
55554: PUSH
55555: LD_EXP 43
55559: PUSH
55560: LD_VAR 0 1
55564: ARRAY
55565: PUSH
55566: LD_EXP 72
55570: PUSH
55571: LD_VAR 0 1
55575: ARRAY
55576: UNION
55577: PUSH
55578: FOR_IN
55579: IFFALSE 55612
// if GetTag ( i ) = tag then
55581: LD_VAR 0 4
55585: PPUSH
55586: CALL_OW 110
55590: PUSH
55591: LD_VAR 0 2
55595: EQUAL
55596: IFFALSE 55610
// SetTag ( i , 0 ) ;
55598: LD_VAR 0 4
55602: PPUSH
55603: LD_INT 0
55605: PPUSH
55606: CALL_OW 109
55610: GO 55578
55612: POP
55613: POP
// end ;
55614: LD_VAR 0 3
55618: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55619: LD_INT 0
55621: PPUSH
55622: PPUSH
55623: PPUSH
55624: PPUSH
55625: PPUSH
55626: PPUSH
55627: PPUSH
55628: PPUSH
// if not mc_bases then
55629: LD_EXP 43
55633: NOT
55634: IFFALSE 55638
// exit ;
55636: GO 56087
// for i = 1 to mc_bases do
55638: LD_ADDR_VAR 0 2
55642: PUSH
55643: DOUBLE
55644: LD_INT 1
55646: DEC
55647: ST_TO_ADDR
55648: LD_EXP 43
55652: PUSH
55653: FOR_TO
55654: IFFALSE 56085
// begin tmp := MC_ClassCheckReq ( i ) ;
55656: LD_ADDR_VAR 0 4
55660: PUSH
55661: LD_VAR 0 2
55665: PPUSH
55666: CALL 56092 0 1
55670: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55671: LD_ADDR_EXP 84
55675: PUSH
55676: LD_EXP 84
55680: PPUSH
55681: LD_VAR 0 2
55685: PPUSH
55686: LD_VAR 0 4
55690: PPUSH
55691: CALL_OW 1
55695: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55696: LD_ADDR_VAR 0 6
55700: PUSH
55701: LD_EXP 43
55705: PUSH
55706: LD_VAR 0 2
55710: ARRAY
55711: PPUSH
55712: LD_INT 2
55714: PUSH
55715: LD_INT 30
55717: PUSH
55718: LD_INT 4
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: PUSH
55725: LD_INT 30
55727: PUSH
55728: LD_INT 5
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: PUSH
55735: EMPTY
55736: LIST
55737: LIST
55738: LIST
55739: PPUSH
55740: CALL_OW 72
55744: PUSH
55745: LD_EXP 43
55749: PUSH
55750: LD_VAR 0 2
55754: ARRAY
55755: PPUSH
55756: LD_INT 2
55758: PUSH
55759: LD_INT 30
55761: PUSH
55762: LD_INT 0
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: PUSH
55769: LD_INT 30
55771: PUSH
55772: LD_INT 1
55774: PUSH
55775: EMPTY
55776: LIST
55777: LIST
55778: PUSH
55779: EMPTY
55780: LIST
55781: LIST
55782: LIST
55783: PPUSH
55784: CALL_OW 72
55788: PUSH
55789: LD_EXP 43
55793: PUSH
55794: LD_VAR 0 2
55798: ARRAY
55799: PPUSH
55800: LD_INT 30
55802: PUSH
55803: LD_INT 3
55805: PUSH
55806: EMPTY
55807: LIST
55808: LIST
55809: PPUSH
55810: CALL_OW 72
55814: PUSH
55815: LD_EXP 43
55819: PUSH
55820: LD_VAR 0 2
55824: ARRAY
55825: PPUSH
55826: LD_INT 2
55828: PUSH
55829: LD_INT 30
55831: PUSH
55832: LD_INT 6
55834: PUSH
55835: EMPTY
55836: LIST
55837: LIST
55838: PUSH
55839: LD_INT 30
55841: PUSH
55842: LD_INT 7
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: PUSH
55849: LD_INT 30
55851: PUSH
55852: LD_INT 8
55854: PUSH
55855: EMPTY
55856: LIST
55857: LIST
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: LIST
55863: LIST
55864: PPUSH
55865: CALL_OW 72
55869: PUSH
55870: EMPTY
55871: LIST
55872: LIST
55873: LIST
55874: LIST
55875: ST_TO_ADDR
// for j := 1 to 4 do
55876: LD_ADDR_VAR 0 3
55880: PUSH
55881: DOUBLE
55882: LD_INT 1
55884: DEC
55885: ST_TO_ADDR
55886: LD_INT 4
55888: PUSH
55889: FOR_TO
55890: IFFALSE 56081
// begin if not tmp [ j ] then
55892: LD_VAR 0 4
55896: PUSH
55897: LD_VAR 0 3
55901: ARRAY
55902: NOT
55903: IFFALSE 55907
// continue ;
55905: GO 55889
// for p in tmp [ j ] do
55907: LD_ADDR_VAR 0 5
55911: PUSH
55912: LD_VAR 0 4
55916: PUSH
55917: LD_VAR 0 3
55921: ARRAY
55922: PUSH
55923: FOR_IN
55924: IFFALSE 56077
// begin if not b [ j ] then
55926: LD_VAR 0 6
55930: PUSH
55931: LD_VAR 0 3
55935: ARRAY
55936: NOT
55937: IFFALSE 55941
// break ;
55939: GO 56077
// e := 0 ;
55941: LD_ADDR_VAR 0 7
55945: PUSH
55946: LD_INT 0
55948: ST_TO_ADDR
// for k in b [ j ] do
55949: LD_ADDR_VAR 0 8
55953: PUSH
55954: LD_VAR 0 6
55958: PUSH
55959: LD_VAR 0 3
55963: ARRAY
55964: PUSH
55965: FOR_IN
55966: IFFALSE 55993
// if IsNotFull ( k ) then
55968: LD_VAR 0 8
55972: PPUSH
55973: CALL 11996 0 1
55977: IFFALSE 55991
// begin e := k ;
55979: LD_ADDR_VAR 0 7
55983: PUSH
55984: LD_VAR 0 8
55988: ST_TO_ADDR
// break ;
55989: GO 55993
// end ;
55991: GO 55965
55993: POP
55994: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55995: LD_VAR 0 7
55999: PUSH
56000: LD_VAR 0 5
56004: PPUSH
56005: LD_VAR 0 7
56009: PPUSH
56010: CALL 45778 0 2
56014: NOT
56015: AND
56016: IFFALSE 56075
// begin if IsInUnit ( p ) then
56018: LD_VAR 0 5
56022: PPUSH
56023: CALL_OW 310
56027: IFFALSE 56038
// ComExitBuilding ( p ) ;
56029: LD_VAR 0 5
56033: PPUSH
56034: CALL_OW 122
// ComEnterUnit ( p , e ) ;
56038: LD_VAR 0 5
56042: PPUSH
56043: LD_VAR 0 7
56047: PPUSH
56048: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56052: LD_VAR 0 5
56056: PPUSH
56057: LD_VAR 0 3
56061: PPUSH
56062: CALL_OW 183
// AddComExitBuilding ( p ) ;
56066: LD_VAR 0 5
56070: PPUSH
56071: CALL_OW 182
// end ; end ;
56075: GO 55923
56077: POP
56078: POP
// end ;
56079: GO 55889
56081: POP
56082: POP
// end ;
56083: GO 55653
56085: POP
56086: POP
// end ;
56087: LD_VAR 0 1
56091: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56092: LD_INT 0
56094: PPUSH
56095: PPUSH
56096: PPUSH
56097: PPUSH
56098: PPUSH
56099: PPUSH
56100: PPUSH
56101: PPUSH
56102: PPUSH
56103: PPUSH
56104: PPUSH
56105: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
56106: LD_ADDR_VAR 0 2
56110: PUSH
56111: LD_INT 0
56113: PUSH
56114: LD_INT 0
56116: PUSH
56117: LD_INT 0
56119: PUSH
56120: LD_INT 0
56122: PUSH
56123: EMPTY
56124: LIST
56125: LIST
56126: LIST
56127: LIST
56128: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56129: LD_VAR 0 1
56133: NOT
56134: PUSH
56135: LD_EXP 43
56139: PUSH
56140: LD_VAR 0 1
56144: ARRAY
56145: NOT
56146: OR
56147: PUSH
56148: LD_EXP 43
56152: PUSH
56153: LD_VAR 0 1
56157: ARRAY
56158: PPUSH
56159: LD_INT 2
56161: PUSH
56162: LD_INT 30
56164: PUSH
56165: LD_INT 0
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: PUSH
56172: LD_INT 30
56174: PUSH
56175: LD_INT 1
56177: PUSH
56178: EMPTY
56179: LIST
56180: LIST
56181: PUSH
56182: EMPTY
56183: LIST
56184: LIST
56185: LIST
56186: PPUSH
56187: CALL_OW 72
56191: NOT
56192: OR
56193: IFFALSE 56197
// exit ;
56195: GO 59700
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56197: LD_ADDR_VAR 0 4
56201: PUSH
56202: LD_EXP 43
56206: PUSH
56207: LD_VAR 0 1
56211: ARRAY
56212: PPUSH
56213: LD_INT 2
56215: PUSH
56216: LD_INT 25
56218: PUSH
56219: LD_INT 1
56221: PUSH
56222: EMPTY
56223: LIST
56224: LIST
56225: PUSH
56226: LD_INT 25
56228: PUSH
56229: LD_INT 2
56231: PUSH
56232: EMPTY
56233: LIST
56234: LIST
56235: PUSH
56236: LD_INT 25
56238: PUSH
56239: LD_INT 3
56241: PUSH
56242: EMPTY
56243: LIST
56244: LIST
56245: PUSH
56246: LD_INT 25
56248: PUSH
56249: LD_INT 4
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: PUSH
56256: LD_INT 25
56258: PUSH
56259: LD_INT 5
56261: PUSH
56262: EMPTY
56263: LIST
56264: LIST
56265: PUSH
56266: LD_INT 25
56268: PUSH
56269: LD_INT 8
56271: PUSH
56272: EMPTY
56273: LIST
56274: LIST
56275: PUSH
56276: LD_INT 25
56278: PUSH
56279: LD_INT 9
56281: PUSH
56282: EMPTY
56283: LIST
56284: LIST
56285: PUSH
56286: EMPTY
56287: LIST
56288: LIST
56289: LIST
56290: LIST
56291: LIST
56292: LIST
56293: LIST
56294: LIST
56295: PPUSH
56296: CALL_OW 72
56300: ST_TO_ADDR
// if not tmp then
56301: LD_VAR 0 4
56305: NOT
56306: IFFALSE 56310
// exit ;
56308: GO 59700
// for i in tmp do
56310: LD_ADDR_VAR 0 3
56314: PUSH
56315: LD_VAR 0 4
56319: PUSH
56320: FOR_IN
56321: IFFALSE 56352
// if GetTag ( i ) then
56323: LD_VAR 0 3
56327: PPUSH
56328: CALL_OW 110
56332: IFFALSE 56350
// tmp := tmp diff i ;
56334: LD_ADDR_VAR 0 4
56338: PUSH
56339: LD_VAR 0 4
56343: PUSH
56344: LD_VAR 0 3
56348: DIFF
56349: ST_TO_ADDR
56350: GO 56320
56352: POP
56353: POP
// if not tmp then
56354: LD_VAR 0 4
56358: NOT
56359: IFFALSE 56363
// exit ;
56361: GO 59700
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56363: LD_ADDR_VAR 0 5
56367: PUSH
56368: LD_EXP 43
56372: PUSH
56373: LD_VAR 0 1
56377: ARRAY
56378: PPUSH
56379: LD_INT 2
56381: PUSH
56382: LD_INT 25
56384: PUSH
56385: LD_INT 1
56387: PUSH
56388: EMPTY
56389: LIST
56390: LIST
56391: PUSH
56392: LD_INT 25
56394: PUSH
56395: LD_INT 5
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: PUSH
56402: LD_INT 25
56404: PUSH
56405: LD_INT 8
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: PUSH
56412: LD_INT 25
56414: PUSH
56415: LD_INT 9
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: PUSH
56422: EMPTY
56423: LIST
56424: LIST
56425: LIST
56426: LIST
56427: LIST
56428: PPUSH
56429: CALL_OW 72
56433: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56434: LD_ADDR_VAR 0 6
56438: PUSH
56439: LD_EXP 43
56443: PUSH
56444: LD_VAR 0 1
56448: ARRAY
56449: PPUSH
56450: LD_INT 25
56452: PUSH
56453: LD_INT 2
56455: PUSH
56456: EMPTY
56457: LIST
56458: LIST
56459: PPUSH
56460: CALL_OW 72
56464: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56465: LD_ADDR_VAR 0 7
56469: PUSH
56470: LD_EXP 43
56474: PUSH
56475: LD_VAR 0 1
56479: ARRAY
56480: PPUSH
56481: LD_INT 25
56483: PUSH
56484: LD_INT 3
56486: PUSH
56487: EMPTY
56488: LIST
56489: LIST
56490: PPUSH
56491: CALL_OW 72
56495: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56496: LD_ADDR_VAR 0 8
56500: PUSH
56501: LD_EXP 43
56505: PUSH
56506: LD_VAR 0 1
56510: ARRAY
56511: PPUSH
56512: LD_INT 25
56514: PUSH
56515: LD_INT 4
56517: PUSH
56518: EMPTY
56519: LIST
56520: LIST
56521: PUSH
56522: LD_INT 24
56524: PUSH
56525: LD_INT 251
56527: PUSH
56528: EMPTY
56529: LIST
56530: LIST
56531: PUSH
56532: EMPTY
56533: LIST
56534: LIST
56535: PPUSH
56536: CALL_OW 72
56540: ST_TO_ADDR
// if mc_is_defending [ base ] then
56541: LD_EXP 86
56545: PUSH
56546: LD_VAR 0 1
56550: ARRAY
56551: IFFALSE 57012
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56553: LD_ADDR_EXP 85
56557: PUSH
56558: LD_EXP 85
56562: PPUSH
56563: LD_VAR 0 1
56567: PPUSH
56568: LD_INT 4
56570: PPUSH
56571: CALL_OW 1
56575: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56576: LD_ADDR_VAR 0 12
56580: PUSH
56581: LD_EXP 43
56585: PUSH
56586: LD_VAR 0 1
56590: ARRAY
56591: PPUSH
56592: LD_INT 2
56594: PUSH
56595: LD_INT 30
56597: PUSH
56598: LD_INT 4
56600: PUSH
56601: EMPTY
56602: LIST
56603: LIST
56604: PUSH
56605: LD_INT 30
56607: PUSH
56608: LD_INT 5
56610: PUSH
56611: EMPTY
56612: LIST
56613: LIST
56614: PUSH
56615: EMPTY
56616: LIST
56617: LIST
56618: LIST
56619: PPUSH
56620: CALL_OW 72
56624: ST_TO_ADDR
// if not b then
56625: LD_VAR 0 12
56629: NOT
56630: IFFALSE 56634
// exit ;
56632: GO 59700
// p := [ ] ;
56634: LD_ADDR_VAR 0 11
56638: PUSH
56639: EMPTY
56640: ST_TO_ADDR
// if sci >= 2 then
56641: LD_VAR 0 8
56645: PUSH
56646: LD_INT 2
56648: GREATEREQUAL
56649: IFFALSE 56680
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56651: LD_ADDR_VAR 0 8
56655: PUSH
56656: LD_VAR 0 8
56660: PUSH
56661: LD_INT 1
56663: ARRAY
56664: PUSH
56665: LD_VAR 0 8
56669: PUSH
56670: LD_INT 2
56672: ARRAY
56673: PUSH
56674: EMPTY
56675: LIST
56676: LIST
56677: ST_TO_ADDR
56678: GO 56741
// if sci = 1 then
56680: LD_VAR 0 8
56684: PUSH
56685: LD_INT 1
56687: EQUAL
56688: IFFALSE 56709
// sci := [ sci [ 1 ] ] else
56690: LD_ADDR_VAR 0 8
56694: PUSH
56695: LD_VAR 0 8
56699: PUSH
56700: LD_INT 1
56702: ARRAY
56703: PUSH
56704: EMPTY
56705: LIST
56706: ST_TO_ADDR
56707: GO 56741
// if sci = 0 then
56709: LD_VAR 0 8
56713: PUSH
56714: LD_INT 0
56716: EQUAL
56717: IFFALSE 56741
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56719: LD_ADDR_VAR 0 11
56723: PUSH
56724: LD_VAR 0 4
56728: PPUSH
56729: LD_INT 4
56731: PPUSH
56732: CALL 45650 0 2
56736: PUSH
56737: LD_INT 1
56739: ARRAY
56740: ST_TO_ADDR
// if eng > 4 then
56741: LD_VAR 0 6
56745: PUSH
56746: LD_INT 4
56748: GREATER
56749: IFFALSE 56795
// for i = eng downto 4 do
56751: LD_ADDR_VAR 0 3
56755: PUSH
56756: DOUBLE
56757: LD_VAR 0 6
56761: INC
56762: ST_TO_ADDR
56763: LD_INT 4
56765: PUSH
56766: FOR_DOWNTO
56767: IFFALSE 56793
// eng := eng diff eng [ i ] ;
56769: LD_ADDR_VAR 0 6
56773: PUSH
56774: LD_VAR 0 6
56778: PUSH
56779: LD_VAR 0 6
56783: PUSH
56784: LD_VAR 0 3
56788: ARRAY
56789: DIFF
56790: ST_TO_ADDR
56791: GO 56766
56793: POP
56794: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56795: LD_ADDR_VAR 0 4
56799: PUSH
56800: LD_VAR 0 4
56804: PUSH
56805: LD_VAR 0 5
56809: PUSH
56810: LD_VAR 0 6
56814: UNION
56815: PUSH
56816: LD_VAR 0 7
56820: UNION
56821: PUSH
56822: LD_VAR 0 8
56826: UNION
56827: DIFF
56828: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56829: LD_ADDR_VAR 0 13
56833: PUSH
56834: LD_EXP 43
56838: PUSH
56839: LD_VAR 0 1
56843: ARRAY
56844: PPUSH
56845: LD_INT 2
56847: PUSH
56848: LD_INT 30
56850: PUSH
56851: LD_INT 32
56853: PUSH
56854: EMPTY
56855: LIST
56856: LIST
56857: PUSH
56858: LD_INT 30
56860: PUSH
56861: LD_INT 31
56863: PUSH
56864: EMPTY
56865: LIST
56866: LIST
56867: PUSH
56868: EMPTY
56869: LIST
56870: LIST
56871: LIST
56872: PPUSH
56873: CALL_OW 72
56877: PUSH
56878: LD_EXP 43
56882: PUSH
56883: LD_VAR 0 1
56887: ARRAY
56888: PPUSH
56889: LD_INT 2
56891: PUSH
56892: LD_INT 30
56894: PUSH
56895: LD_INT 4
56897: PUSH
56898: EMPTY
56899: LIST
56900: LIST
56901: PUSH
56902: LD_INT 30
56904: PUSH
56905: LD_INT 5
56907: PUSH
56908: EMPTY
56909: LIST
56910: LIST
56911: PUSH
56912: EMPTY
56913: LIST
56914: LIST
56915: LIST
56916: PPUSH
56917: CALL_OW 72
56921: PUSH
56922: LD_INT 6
56924: MUL
56925: PLUS
56926: ST_TO_ADDR
// if bcount < tmp then
56927: LD_VAR 0 13
56931: PUSH
56932: LD_VAR 0 4
56936: LESS
56937: IFFALSE 56983
// for i = tmp downto bcount do
56939: LD_ADDR_VAR 0 3
56943: PUSH
56944: DOUBLE
56945: LD_VAR 0 4
56949: INC
56950: ST_TO_ADDR
56951: LD_VAR 0 13
56955: PUSH
56956: FOR_DOWNTO
56957: IFFALSE 56981
// tmp := Delete ( tmp , tmp ) ;
56959: LD_ADDR_VAR 0 4
56963: PUSH
56964: LD_VAR 0 4
56968: PPUSH
56969: LD_VAR 0 4
56973: PPUSH
56974: CALL_OW 3
56978: ST_TO_ADDR
56979: GO 56956
56981: POP
56982: POP
// result := [ tmp , 0 , 0 , p ] ;
56983: LD_ADDR_VAR 0 2
56987: PUSH
56988: LD_VAR 0 4
56992: PUSH
56993: LD_INT 0
56995: PUSH
56996: LD_INT 0
56998: PUSH
56999: LD_VAR 0 11
57003: PUSH
57004: EMPTY
57005: LIST
57006: LIST
57007: LIST
57008: LIST
57009: ST_TO_ADDR
// exit ;
57010: GO 59700
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57012: LD_EXP 43
57016: PUSH
57017: LD_VAR 0 1
57021: ARRAY
57022: PPUSH
57023: LD_INT 2
57025: PUSH
57026: LD_INT 30
57028: PUSH
57029: LD_INT 6
57031: PUSH
57032: EMPTY
57033: LIST
57034: LIST
57035: PUSH
57036: LD_INT 30
57038: PUSH
57039: LD_INT 7
57041: PUSH
57042: EMPTY
57043: LIST
57044: LIST
57045: PUSH
57046: LD_INT 30
57048: PUSH
57049: LD_INT 8
57051: PUSH
57052: EMPTY
57053: LIST
57054: LIST
57055: PUSH
57056: EMPTY
57057: LIST
57058: LIST
57059: LIST
57060: LIST
57061: PPUSH
57062: CALL_OW 72
57066: NOT
57067: PUSH
57068: LD_EXP 43
57072: PUSH
57073: LD_VAR 0 1
57077: ARRAY
57078: PPUSH
57079: LD_INT 30
57081: PUSH
57082: LD_INT 3
57084: PUSH
57085: EMPTY
57086: LIST
57087: LIST
57088: PPUSH
57089: CALL_OW 72
57093: NOT
57094: AND
57095: IFFALSE 57167
// begin if eng = tmp then
57097: LD_VAR 0 6
57101: PUSH
57102: LD_VAR 0 4
57106: EQUAL
57107: IFFALSE 57111
// exit ;
57109: GO 59700
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57111: LD_ADDR_EXP 85
57115: PUSH
57116: LD_EXP 85
57120: PPUSH
57121: LD_VAR 0 1
57125: PPUSH
57126: LD_INT 1
57128: PPUSH
57129: CALL_OW 1
57133: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57134: LD_ADDR_VAR 0 2
57138: PUSH
57139: LD_INT 0
57141: PUSH
57142: LD_VAR 0 4
57146: PUSH
57147: LD_VAR 0 6
57151: DIFF
57152: PUSH
57153: LD_INT 0
57155: PUSH
57156: LD_INT 0
57158: PUSH
57159: EMPTY
57160: LIST
57161: LIST
57162: LIST
57163: LIST
57164: ST_TO_ADDR
// exit ;
57165: GO 59700
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57167: LD_EXP 70
57171: PUSH
57172: LD_EXP 69
57176: PUSH
57177: LD_VAR 0 1
57181: ARRAY
57182: ARRAY
57183: PUSH
57184: LD_EXP 43
57188: PUSH
57189: LD_VAR 0 1
57193: ARRAY
57194: PPUSH
57195: LD_INT 2
57197: PUSH
57198: LD_INT 30
57200: PUSH
57201: LD_INT 6
57203: PUSH
57204: EMPTY
57205: LIST
57206: LIST
57207: PUSH
57208: LD_INT 30
57210: PUSH
57211: LD_INT 7
57213: PUSH
57214: EMPTY
57215: LIST
57216: LIST
57217: PUSH
57218: LD_INT 30
57220: PUSH
57221: LD_INT 8
57223: PUSH
57224: EMPTY
57225: LIST
57226: LIST
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: LIST
57232: LIST
57233: PPUSH
57234: CALL_OW 72
57238: AND
57239: PUSH
57240: LD_EXP 43
57244: PUSH
57245: LD_VAR 0 1
57249: ARRAY
57250: PPUSH
57251: LD_INT 30
57253: PUSH
57254: LD_INT 3
57256: PUSH
57257: EMPTY
57258: LIST
57259: LIST
57260: PPUSH
57261: CALL_OW 72
57265: NOT
57266: AND
57267: IFFALSE 57481
// begin if sci >= 6 then
57269: LD_VAR 0 8
57273: PUSH
57274: LD_INT 6
57276: GREATEREQUAL
57277: IFFALSE 57281
// exit ;
57279: GO 59700
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57281: LD_ADDR_EXP 85
57285: PUSH
57286: LD_EXP 85
57290: PPUSH
57291: LD_VAR 0 1
57295: PPUSH
57296: LD_INT 2
57298: PPUSH
57299: CALL_OW 1
57303: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57304: LD_ADDR_VAR 0 9
57308: PUSH
57309: LD_VAR 0 4
57313: PUSH
57314: LD_VAR 0 8
57318: DIFF
57319: PPUSH
57320: LD_INT 4
57322: PPUSH
57323: CALL 45650 0 2
57327: ST_TO_ADDR
// p := [ ] ;
57328: LD_ADDR_VAR 0 11
57332: PUSH
57333: EMPTY
57334: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57335: LD_VAR 0 8
57339: PUSH
57340: LD_INT 6
57342: LESS
57343: PUSH
57344: LD_VAR 0 9
57348: PUSH
57349: LD_INT 6
57351: GREATER
57352: AND
57353: IFFALSE 57434
// begin for i = 1 to 6 - sci do
57355: LD_ADDR_VAR 0 3
57359: PUSH
57360: DOUBLE
57361: LD_INT 1
57363: DEC
57364: ST_TO_ADDR
57365: LD_INT 6
57367: PUSH
57368: LD_VAR 0 8
57372: MINUS
57373: PUSH
57374: FOR_TO
57375: IFFALSE 57430
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57377: LD_ADDR_VAR 0 11
57381: PUSH
57382: LD_VAR 0 11
57386: PPUSH
57387: LD_VAR 0 11
57391: PUSH
57392: LD_INT 1
57394: PLUS
57395: PPUSH
57396: LD_VAR 0 9
57400: PUSH
57401: LD_INT 1
57403: ARRAY
57404: PPUSH
57405: CALL_OW 2
57409: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57410: LD_ADDR_VAR 0 9
57414: PUSH
57415: LD_VAR 0 9
57419: PPUSH
57420: LD_INT 1
57422: PPUSH
57423: CALL_OW 3
57427: ST_TO_ADDR
// end ;
57428: GO 57374
57430: POP
57431: POP
// end else
57432: GO 57454
// if sort then
57434: LD_VAR 0 9
57438: IFFALSE 57454
// p := sort [ 1 ] ;
57440: LD_ADDR_VAR 0 11
57444: PUSH
57445: LD_VAR 0 9
57449: PUSH
57450: LD_INT 1
57452: ARRAY
57453: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57454: LD_ADDR_VAR 0 2
57458: PUSH
57459: LD_INT 0
57461: PUSH
57462: LD_INT 0
57464: PUSH
57465: LD_INT 0
57467: PUSH
57468: LD_VAR 0 11
57472: PUSH
57473: EMPTY
57474: LIST
57475: LIST
57476: LIST
57477: LIST
57478: ST_TO_ADDR
// exit ;
57479: GO 59700
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57481: LD_EXP 70
57485: PUSH
57486: LD_EXP 69
57490: PUSH
57491: LD_VAR 0 1
57495: ARRAY
57496: ARRAY
57497: PUSH
57498: LD_EXP 43
57502: PUSH
57503: LD_VAR 0 1
57507: ARRAY
57508: PPUSH
57509: LD_INT 2
57511: PUSH
57512: LD_INT 30
57514: PUSH
57515: LD_INT 6
57517: PUSH
57518: EMPTY
57519: LIST
57520: LIST
57521: PUSH
57522: LD_INT 30
57524: PUSH
57525: LD_INT 7
57527: PUSH
57528: EMPTY
57529: LIST
57530: LIST
57531: PUSH
57532: LD_INT 30
57534: PUSH
57535: LD_INT 8
57537: PUSH
57538: EMPTY
57539: LIST
57540: LIST
57541: PUSH
57542: EMPTY
57543: LIST
57544: LIST
57545: LIST
57546: LIST
57547: PPUSH
57548: CALL_OW 72
57552: AND
57553: PUSH
57554: LD_EXP 43
57558: PUSH
57559: LD_VAR 0 1
57563: ARRAY
57564: PPUSH
57565: LD_INT 30
57567: PUSH
57568: LD_INT 3
57570: PUSH
57571: EMPTY
57572: LIST
57573: LIST
57574: PPUSH
57575: CALL_OW 72
57579: AND
57580: IFFALSE 58314
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57582: LD_ADDR_EXP 85
57586: PUSH
57587: LD_EXP 85
57591: PPUSH
57592: LD_VAR 0 1
57596: PPUSH
57597: LD_INT 3
57599: PPUSH
57600: CALL_OW 1
57604: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57605: LD_ADDR_VAR 0 2
57609: PUSH
57610: LD_INT 0
57612: PUSH
57613: LD_INT 0
57615: PUSH
57616: LD_INT 0
57618: PUSH
57619: LD_INT 0
57621: PUSH
57622: EMPTY
57623: LIST
57624: LIST
57625: LIST
57626: LIST
57627: ST_TO_ADDR
// if not eng then
57628: LD_VAR 0 6
57632: NOT
57633: IFFALSE 57696
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57635: LD_ADDR_VAR 0 11
57639: PUSH
57640: LD_VAR 0 4
57644: PPUSH
57645: LD_INT 2
57647: PPUSH
57648: CALL 45650 0 2
57652: PUSH
57653: LD_INT 1
57655: ARRAY
57656: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57657: LD_ADDR_VAR 0 2
57661: PUSH
57662: LD_VAR 0 2
57666: PPUSH
57667: LD_INT 2
57669: PPUSH
57670: LD_VAR 0 11
57674: PPUSH
57675: CALL_OW 1
57679: ST_TO_ADDR
// tmp := tmp diff p ;
57680: LD_ADDR_VAR 0 4
57684: PUSH
57685: LD_VAR 0 4
57689: PUSH
57690: LD_VAR 0 11
57694: DIFF
57695: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57696: LD_VAR 0 4
57700: PUSH
57701: LD_VAR 0 8
57705: PUSH
57706: LD_INT 6
57708: LESS
57709: AND
57710: IFFALSE 57898
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57712: LD_ADDR_VAR 0 9
57716: PUSH
57717: LD_VAR 0 4
57721: PUSH
57722: LD_VAR 0 8
57726: PUSH
57727: LD_VAR 0 7
57731: UNION
57732: DIFF
57733: PPUSH
57734: LD_INT 4
57736: PPUSH
57737: CALL 45650 0 2
57741: ST_TO_ADDR
// p := [ ] ;
57742: LD_ADDR_VAR 0 11
57746: PUSH
57747: EMPTY
57748: ST_TO_ADDR
// if sort then
57749: LD_VAR 0 9
57753: IFFALSE 57869
// for i = 1 to 6 - sci do
57755: LD_ADDR_VAR 0 3
57759: PUSH
57760: DOUBLE
57761: LD_INT 1
57763: DEC
57764: ST_TO_ADDR
57765: LD_INT 6
57767: PUSH
57768: LD_VAR 0 8
57772: MINUS
57773: PUSH
57774: FOR_TO
57775: IFFALSE 57867
// begin if i = sort then
57777: LD_VAR 0 3
57781: PUSH
57782: LD_VAR 0 9
57786: EQUAL
57787: IFFALSE 57791
// break ;
57789: GO 57867
// if GetClass ( i ) = 4 then
57791: LD_VAR 0 3
57795: PPUSH
57796: CALL_OW 257
57800: PUSH
57801: LD_INT 4
57803: EQUAL
57804: IFFALSE 57808
// continue ;
57806: GO 57774
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57808: LD_ADDR_VAR 0 11
57812: PUSH
57813: LD_VAR 0 11
57817: PPUSH
57818: LD_VAR 0 11
57822: PUSH
57823: LD_INT 1
57825: PLUS
57826: PPUSH
57827: LD_VAR 0 9
57831: PUSH
57832: LD_VAR 0 3
57836: ARRAY
57837: PPUSH
57838: CALL_OW 2
57842: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57843: LD_ADDR_VAR 0 4
57847: PUSH
57848: LD_VAR 0 4
57852: PUSH
57853: LD_VAR 0 9
57857: PUSH
57858: LD_VAR 0 3
57862: ARRAY
57863: DIFF
57864: ST_TO_ADDR
// end ;
57865: GO 57774
57867: POP
57868: POP
// if p then
57869: LD_VAR 0 11
57873: IFFALSE 57898
// result := Replace ( result , 4 , p ) ;
57875: LD_ADDR_VAR 0 2
57879: PUSH
57880: LD_VAR 0 2
57884: PPUSH
57885: LD_INT 4
57887: PPUSH
57888: LD_VAR 0 11
57892: PPUSH
57893: CALL_OW 1
57897: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57898: LD_VAR 0 4
57902: PUSH
57903: LD_VAR 0 7
57907: PUSH
57908: LD_INT 6
57910: LESS
57911: AND
57912: IFFALSE 58100
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57914: LD_ADDR_VAR 0 9
57918: PUSH
57919: LD_VAR 0 4
57923: PUSH
57924: LD_VAR 0 8
57928: PUSH
57929: LD_VAR 0 7
57933: UNION
57934: DIFF
57935: PPUSH
57936: LD_INT 3
57938: PPUSH
57939: CALL 45650 0 2
57943: ST_TO_ADDR
// p := [ ] ;
57944: LD_ADDR_VAR 0 11
57948: PUSH
57949: EMPTY
57950: ST_TO_ADDR
// if sort then
57951: LD_VAR 0 9
57955: IFFALSE 58071
// for i = 1 to 6 - mech do
57957: LD_ADDR_VAR 0 3
57961: PUSH
57962: DOUBLE
57963: LD_INT 1
57965: DEC
57966: ST_TO_ADDR
57967: LD_INT 6
57969: PUSH
57970: LD_VAR 0 7
57974: MINUS
57975: PUSH
57976: FOR_TO
57977: IFFALSE 58069
// begin if i = sort then
57979: LD_VAR 0 3
57983: PUSH
57984: LD_VAR 0 9
57988: EQUAL
57989: IFFALSE 57993
// break ;
57991: GO 58069
// if GetClass ( i ) = 3 then
57993: LD_VAR 0 3
57997: PPUSH
57998: CALL_OW 257
58002: PUSH
58003: LD_INT 3
58005: EQUAL
58006: IFFALSE 58010
// continue ;
58008: GO 57976
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58010: LD_ADDR_VAR 0 11
58014: PUSH
58015: LD_VAR 0 11
58019: PPUSH
58020: LD_VAR 0 11
58024: PUSH
58025: LD_INT 1
58027: PLUS
58028: PPUSH
58029: LD_VAR 0 9
58033: PUSH
58034: LD_VAR 0 3
58038: ARRAY
58039: PPUSH
58040: CALL_OW 2
58044: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58045: LD_ADDR_VAR 0 4
58049: PUSH
58050: LD_VAR 0 4
58054: PUSH
58055: LD_VAR 0 9
58059: PUSH
58060: LD_VAR 0 3
58064: ARRAY
58065: DIFF
58066: ST_TO_ADDR
// end ;
58067: GO 57976
58069: POP
58070: POP
// if p then
58071: LD_VAR 0 11
58075: IFFALSE 58100
// result := Replace ( result , 3 , p ) ;
58077: LD_ADDR_VAR 0 2
58081: PUSH
58082: LD_VAR 0 2
58086: PPUSH
58087: LD_INT 3
58089: PPUSH
58090: LD_VAR 0 11
58094: PPUSH
58095: CALL_OW 1
58099: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58100: LD_VAR 0 4
58104: PUSH
58105: LD_INT 6
58107: GREATER
58108: PUSH
58109: LD_VAR 0 6
58113: PUSH
58114: LD_INT 6
58116: LESS
58117: AND
58118: IFFALSE 58312
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58120: LD_ADDR_VAR 0 9
58124: PUSH
58125: LD_VAR 0 4
58129: PUSH
58130: LD_VAR 0 8
58134: PUSH
58135: LD_VAR 0 7
58139: UNION
58140: PUSH
58141: LD_VAR 0 6
58145: UNION
58146: DIFF
58147: PPUSH
58148: LD_INT 2
58150: PPUSH
58151: CALL 45650 0 2
58155: ST_TO_ADDR
// p := [ ] ;
58156: LD_ADDR_VAR 0 11
58160: PUSH
58161: EMPTY
58162: ST_TO_ADDR
// if sort then
58163: LD_VAR 0 9
58167: IFFALSE 58283
// for i = 1 to 6 - eng do
58169: LD_ADDR_VAR 0 3
58173: PUSH
58174: DOUBLE
58175: LD_INT 1
58177: DEC
58178: ST_TO_ADDR
58179: LD_INT 6
58181: PUSH
58182: LD_VAR 0 6
58186: MINUS
58187: PUSH
58188: FOR_TO
58189: IFFALSE 58281
// begin if i = sort then
58191: LD_VAR 0 3
58195: PUSH
58196: LD_VAR 0 9
58200: EQUAL
58201: IFFALSE 58205
// break ;
58203: GO 58281
// if GetClass ( i ) = 2 then
58205: LD_VAR 0 3
58209: PPUSH
58210: CALL_OW 257
58214: PUSH
58215: LD_INT 2
58217: EQUAL
58218: IFFALSE 58222
// continue ;
58220: GO 58188
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58222: LD_ADDR_VAR 0 11
58226: PUSH
58227: LD_VAR 0 11
58231: PPUSH
58232: LD_VAR 0 11
58236: PUSH
58237: LD_INT 1
58239: PLUS
58240: PPUSH
58241: LD_VAR 0 9
58245: PUSH
58246: LD_VAR 0 3
58250: ARRAY
58251: PPUSH
58252: CALL_OW 2
58256: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58257: LD_ADDR_VAR 0 4
58261: PUSH
58262: LD_VAR 0 4
58266: PUSH
58267: LD_VAR 0 9
58271: PUSH
58272: LD_VAR 0 3
58276: ARRAY
58277: DIFF
58278: ST_TO_ADDR
// end ;
58279: GO 58188
58281: POP
58282: POP
// if p then
58283: LD_VAR 0 11
58287: IFFALSE 58312
// result := Replace ( result , 2 , p ) ;
58289: LD_ADDR_VAR 0 2
58293: PUSH
58294: LD_VAR 0 2
58298: PPUSH
58299: LD_INT 2
58301: PPUSH
58302: LD_VAR 0 11
58306: PPUSH
58307: CALL_OW 1
58311: ST_TO_ADDR
// end ; exit ;
58312: GO 59700
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58314: LD_EXP 70
58318: PUSH
58319: LD_EXP 69
58323: PUSH
58324: LD_VAR 0 1
58328: ARRAY
58329: ARRAY
58330: NOT
58331: PUSH
58332: LD_EXP 43
58336: PUSH
58337: LD_VAR 0 1
58341: ARRAY
58342: PPUSH
58343: LD_INT 30
58345: PUSH
58346: LD_INT 3
58348: PUSH
58349: EMPTY
58350: LIST
58351: LIST
58352: PPUSH
58353: CALL_OW 72
58357: AND
58358: PUSH
58359: LD_EXP 48
58363: PUSH
58364: LD_VAR 0 1
58368: ARRAY
58369: AND
58370: IFFALSE 58978
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58372: LD_ADDR_EXP 85
58376: PUSH
58377: LD_EXP 85
58381: PPUSH
58382: LD_VAR 0 1
58386: PPUSH
58387: LD_INT 5
58389: PPUSH
58390: CALL_OW 1
58394: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58395: LD_ADDR_VAR 0 2
58399: PUSH
58400: LD_INT 0
58402: PUSH
58403: LD_INT 0
58405: PUSH
58406: LD_INT 0
58408: PUSH
58409: LD_INT 0
58411: PUSH
58412: EMPTY
58413: LIST
58414: LIST
58415: LIST
58416: LIST
58417: ST_TO_ADDR
// if sci > 1 then
58418: LD_VAR 0 8
58422: PUSH
58423: LD_INT 1
58425: GREATER
58426: IFFALSE 58454
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58428: LD_ADDR_VAR 0 4
58432: PUSH
58433: LD_VAR 0 4
58437: PUSH
58438: LD_VAR 0 8
58442: PUSH
58443: LD_VAR 0 8
58447: PUSH
58448: LD_INT 1
58450: ARRAY
58451: DIFF
58452: DIFF
58453: ST_TO_ADDR
// if tmp and not sci then
58454: LD_VAR 0 4
58458: PUSH
58459: LD_VAR 0 8
58463: NOT
58464: AND
58465: IFFALSE 58534
// begin sort := SortBySkill ( tmp , 4 ) ;
58467: LD_ADDR_VAR 0 9
58471: PUSH
58472: LD_VAR 0 4
58476: PPUSH
58477: LD_INT 4
58479: PPUSH
58480: CALL 45650 0 2
58484: ST_TO_ADDR
// if sort then
58485: LD_VAR 0 9
58489: IFFALSE 58505
// p := sort [ 1 ] ;
58491: LD_ADDR_VAR 0 11
58495: PUSH
58496: LD_VAR 0 9
58500: PUSH
58501: LD_INT 1
58503: ARRAY
58504: ST_TO_ADDR
// if p then
58505: LD_VAR 0 11
58509: IFFALSE 58534
// result := Replace ( result , 4 , p ) ;
58511: LD_ADDR_VAR 0 2
58515: PUSH
58516: LD_VAR 0 2
58520: PPUSH
58521: LD_INT 4
58523: PPUSH
58524: LD_VAR 0 11
58528: PPUSH
58529: CALL_OW 1
58533: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58534: LD_ADDR_VAR 0 4
58538: PUSH
58539: LD_VAR 0 4
58543: PUSH
58544: LD_VAR 0 7
58548: DIFF
58549: ST_TO_ADDR
// if tmp and mech < 6 then
58550: LD_VAR 0 4
58554: PUSH
58555: LD_VAR 0 7
58559: PUSH
58560: LD_INT 6
58562: LESS
58563: AND
58564: IFFALSE 58752
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58566: LD_ADDR_VAR 0 9
58570: PUSH
58571: LD_VAR 0 4
58575: PUSH
58576: LD_VAR 0 8
58580: PUSH
58581: LD_VAR 0 7
58585: UNION
58586: DIFF
58587: PPUSH
58588: LD_INT 3
58590: PPUSH
58591: CALL 45650 0 2
58595: ST_TO_ADDR
// p := [ ] ;
58596: LD_ADDR_VAR 0 11
58600: PUSH
58601: EMPTY
58602: ST_TO_ADDR
// if sort then
58603: LD_VAR 0 9
58607: IFFALSE 58723
// for i = 1 to 6 - mech do
58609: LD_ADDR_VAR 0 3
58613: PUSH
58614: DOUBLE
58615: LD_INT 1
58617: DEC
58618: ST_TO_ADDR
58619: LD_INT 6
58621: PUSH
58622: LD_VAR 0 7
58626: MINUS
58627: PUSH
58628: FOR_TO
58629: IFFALSE 58721
// begin if i = sort then
58631: LD_VAR 0 3
58635: PUSH
58636: LD_VAR 0 9
58640: EQUAL
58641: IFFALSE 58645
// break ;
58643: GO 58721
// if GetClass ( i ) = 3 then
58645: LD_VAR 0 3
58649: PPUSH
58650: CALL_OW 257
58654: PUSH
58655: LD_INT 3
58657: EQUAL
58658: IFFALSE 58662
// continue ;
58660: GO 58628
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58662: LD_ADDR_VAR 0 11
58666: PUSH
58667: LD_VAR 0 11
58671: PPUSH
58672: LD_VAR 0 11
58676: PUSH
58677: LD_INT 1
58679: PLUS
58680: PPUSH
58681: LD_VAR 0 9
58685: PUSH
58686: LD_VAR 0 3
58690: ARRAY
58691: PPUSH
58692: CALL_OW 2
58696: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58697: LD_ADDR_VAR 0 4
58701: PUSH
58702: LD_VAR 0 4
58706: PUSH
58707: LD_VAR 0 9
58711: PUSH
58712: LD_VAR 0 3
58716: ARRAY
58717: DIFF
58718: ST_TO_ADDR
// end ;
58719: GO 58628
58721: POP
58722: POP
// if p then
58723: LD_VAR 0 11
58727: IFFALSE 58752
// result := Replace ( result , 3 , p ) ;
58729: LD_ADDR_VAR 0 2
58733: PUSH
58734: LD_VAR 0 2
58738: PPUSH
58739: LD_INT 3
58741: PPUSH
58742: LD_VAR 0 11
58746: PPUSH
58747: CALL_OW 1
58751: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58752: LD_ADDR_VAR 0 4
58756: PUSH
58757: LD_VAR 0 4
58761: PUSH
58762: LD_VAR 0 6
58766: DIFF
58767: ST_TO_ADDR
// if tmp and eng < 6 then
58768: LD_VAR 0 4
58772: PUSH
58773: LD_VAR 0 6
58777: PUSH
58778: LD_INT 6
58780: LESS
58781: AND
58782: IFFALSE 58976
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58784: LD_ADDR_VAR 0 9
58788: PUSH
58789: LD_VAR 0 4
58793: PUSH
58794: LD_VAR 0 8
58798: PUSH
58799: LD_VAR 0 7
58803: UNION
58804: PUSH
58805: LD_VAR 0 6
58809: UNION
58810: DIFF
58811: PPUSH
58812: LD_INT 2
58814: PPUSH
58815: CALL 45650 0 2
58819: ST_TO_ADDR
// p := [ ] ;
58820: LD_ADDR_VAR 0 11
58824: PUSH
58825: EMPTY
58826: ST_TO_ADDR
// if sort then
58827: LD_VAR 0 9
58831: IFFALSE 58947
// for i = 1 to 6 - eng do
58833: LD_ADDR_VAR 0 3
58837: PUSH
58838: DOUBLE
58839: LD_INT 1
58841: DEC
58842: ST_TO_ADDR
58843: LD_INT 6
58845: PUSH
58846: LD_VAR 0 6
58850: MINUS
58851: PUSH
58852: FOR_TO
58853: IFFALSE 58945
// begin if i = sort then
58855: LD_VAR 0 3
58859: PUSH
58860: LD_VAR 0 9
58864: EQUAL
58865: IFFALSE 58869
// break ;
58867: GO 58945
// if GetClass ( i ) = 2 then
58869: LD_VAR 0 3
58873: PPUSH
58874: CALL_OW 257
58878: PUSH
58879: LD_INT 2
58881: EQUAL
58882: IFFALSE 58886
// continue ;
58884: GO 58852
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58886: LD_ADDR_VAR 0 11
58890: PUSH
58891: LD_VAR 0 11
58895: PPUSH
58896: LD_VAR 0 11
58900: PUSH
58901: LD_INT 1
58903: PLUS
58904: PPUSH
58905: LD_VAR 0 9
58909: PUSH
58910: LD_VAR 0 3
58914: ARRAY
58915: PPUSH
58916: CALL_OW 2
58920: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58921: LD_ADDR_VAR 0 4
58925: PUSH
58926: LD_VAR 0 4
58930: PUSH
58931: LD_VAR 0 9
58935: PUSH
58936: LD_VAR 0 3
58940: ARRAY
58941: DIFF
58942: ST_TO_ADDR
// end ;
58943: GO 58852
58945: POP
58946: POP
// if p then
58947: LD_VAR 0 11
58951: IFFALSE 58976
// result := Replace ( result , 2 , p ) ;
58953: LD_ADDR_VAR 0 2
58957: PUSH
58958: LD_VAR 0 2
58962: PPUSH
58963: LD_INT 2
58965: PPUSH
58966: LD_VAR 0 11
58970: PPUSH
58971: CALL_OW 1
58975: ST_TO_ADDR
// end ; exit ;
58976: GO 59700
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58978: LD_EXP 70
58982: PUSH
58983: LD_EXP 69
58987: PUSH
58988: LD_VAR 0 1
58992: ARRAY
58993: ARRAY
58994: NOT
58995: PUSH
58996: LD_EXP 43
59000: PUSH
59001: LD_VAR 0 1
59005: ARRAY
59006: PPUSH
59007: LD_INT 30
59009: PUSH
59010: LD_INT 3
59012: PUSH
59013: EMPTY
59014: LIST
59015: LIST
59016: PPUSH
59017: CALL_OW 72
59021: AND
59022: PUSH
59023: LD_EXP 48
59027: PUSH
59028: LD_VAR 0 1
59032: ARRAY
59033: NOT
59034: AND
59035: IFFALSE 59700
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59037: LD_ADDR_EXP 85
59041: PUSH
59042: LD_EXP 85
59046: PPUSH
59047: LD_VAR 0 1
59051: PPUSH
59052: LD_INT 6
59054: PPUSH
59055: CALL_OW 1
59059: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59060: LD_ADDR_VAR 0 2
59064: PUSH
59065: LD_INT 0
59067: PUSH
59068: LD_INT 0
59070: PUSH
59071: LD_INT 0
59073: PUSH
59074: LD_INT 0
59076: PUSH
59077: EMPTY
59078: LIST
59079: LIST
59080: LIST
59081: LIST
59082: ST_TO_ADDR
// if sci >= 1 then
59083: LD_VAR 0 8
59087: PUSH
59088: LD_INT 1
59090: GREATEREQUAL
59091: IFFALSE 59113
// tmp := tmp diff sci [ 1 ] ;
59093: LD_ADDR_VAR 0 4
59097: PUSH
59098: LD_VAR 0 4
59102: PUSH
59103: LD_VAR 0 8
59107: PUSH
59108: LD_INT 1
59110: ARRAY
59111: DIFF
59112: ST_TO_ADDR
// if tmp and not sci then
59113: LD_VAR 0 4
59117: PUSH
59118: LD_VAR 0 8
59122: NOT
59123: AND
59124: IFFALSE 59193
// begin sort := SortBySkill ( tmp , 4 ) ;
59126: LD_ADDR_VAR 0 9
59130: PUSH
59131: LD_VAR 0 4
59135: PPUSH
59136: LD_INT 4
59138: PPUSH
59139: CALL 45650 0 2
59143: ST_TO_ADDR
// if sort then
59144: LD_VAR 0 9
59148: IFFALSE 59164
// p := sort [ 1 ] ;
59150: LD_ADDR_VAR 0 11
59154: PUSH
59155: LD_VAR 0 9
59159: PUSH
59160: LD_INT 1
59162: ARRAY
59163: ST_TO_ADDR
// if p then
59164: LD_VAR 0 11
59168: IFFALSE 59193
// result := Replace ( result , 4 , p ) ;
59170: LD_ADDR_VAR 0 2
59174: PUSH
59175: LD_VAR 0 2
59179: PPUSH
59180: LD_INT 4
59182: PPUSH
59183: LD_VAR 0 11
59187: PPUSH
59188: CALL_OW 1
59192: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59193: LD_ADDR_VAR 0 4
59197: PUSH
59198: LD_VAR 0 4
59202: PUSH
59203: LD_VAR 0 7
59207: DIFF
59208: ST_TO_ADDR
// if tmp and mech < 6 then
59209: LD_VAR 0 4
59213: PUSH
59214: LD_VAR 0 7
59218: PUSH
59219: LD_INT 6
59221: LESS
59222: AND
59223: IFFALSE 59405
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59225: LD_ADDR_VAR 0 9
59229: PUSH
59230: LD_VAR 0 4
59234: PUSH
59235: LD_VAR 0 7
59239: DIFF
59240: PPUSH
59241: LD_INT 3
59243: PPUSH
59244: CALL 45650 0 2
59248: ST_TO_ADDR
// p := [ ] ;
59249: LD_ADDR_VAR 0 11
59253: PUSH
59254: EMPTY
59255: ST_TO_ADDR
// if sort then
59256: LD_VAR 0 9
59260: IFFALSE 59376
// for i = 1 to 6 - mech do
59262: LD_ADDR_VAR 0 3
59266: PUSH
59267: DOUBLE
59268: LD_INT 1
59270: DEC
59271: ST_TO_ADDR
59272: LD_INT 6
59274: PUSH
59275: LD_VAR 0 7
59279: MINUS
59280: PUSH
59281: FOR_TO
59282: IFFALSE 59374
// begin if i = sort then
59284: LD_VAR 0 3
59288: PUSH
59289: LD_VAR 0 9
59293: EQUAL
59294: IFFALSE 59298
// break ;
59296: GO 59374
// if GetClass ( i ) = 3 then
59298: LD_VAR 0 3
59302: PPUSH
59303: CALL_OW 257
59307: PUSH
59308: LD_INT 3
59310: EQUAL
59311: IFFALSE 59315
// continue ;
59313: GO 59281
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59315: LD_ADDR_VAR 0 11
59319: PUSH
59320: LD_VAR 0 11
59324: PPUSH
59325: LD_VAR 0 11
59329: PUSH
59330: LD_INT 1
59332: PLUS
59333: PPUSH
59334: LD_VAR 0 9
59338: PUSH
59339: LD_VAR 0 3
59343: ARRAY
59344: PPUSH
59345: CALL_OW 2
59349: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59350: LD_ADDR_VAR 0 4
59354: PUSH
59355: LD_VAR 0 4
59359: PUSH
59360: LD_VAR 0 9
59364: PUSH
59365: LD_VAR 0 3
59369: ARRAY
59370: DIFF
59371: ST_TO_ADDR
// end ;
59372: GO 59281
59374: POP
59375: POP
// if p then
59376: LD_VAR 0 11
59380: IFFALSE 59405
// result := Replace ( result , 3 , p ) ;
59382: LD_ADDR_VAR 0 2
59386: PUSH
59387: LD_VAR 0 2
59391: PPUSH
59392: LD_INT 3
59394: PPUSH
59395: LD_VAR 0 11
59399: PPUSH
59400: CALL_OW 1
59404: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59405: LD_ADDR_VAR 0 4
59409: PUSH
59410: LD_VAR 0 4
59414: PUSH
59415: LD_VAR 0 6
59419: DIFF
59420: ST_TO_ADDR
// if tmp and eng < 4 then
59421: LD_VAR 0 4
59425: PUSH
59426: LD_VAR 0 6
59430: PUSH
59431: LD_INT 4
59433: LESS
59434: AND
59435: IFFALSE 59625
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59437: LD_ADDR_VAR 0 9
59441: PUSH
59442: LD_VAR 0 4
59446: PUSH
59447: LD_VAR 0 7
59451: PUSH
59452: LD_VAR 0 6
59456: UNION
59457: DIFF
59458: PPUSH
59459: LD_INT 2
59461: PPUSH
59462: CALL 45650 0 2
59466: ST_TO_ADDR
// p := [ ] ;
59467: LD_ADDR_VAR 0 11
59471: PUSH
59472: EMPTY
59473: ST_TO_ADDR
// if sort then
59474: LD_VAR 0 9
59478: IFFALSE 59594
// for i = 1 to 4 - eng do
59480: LD_ADDR_VAR 0 3
59484: PUSH
59485: DOUBLE
59486: LD_INT 1
59488: DEC
59489: ST_TO_ADDR
59490: LD_INT 4
59492: PUSH
59493: LD_VAR 0 6
59497: MINUS
59498: PUSH
59499: FOR_TO
59500: IFFALSE 59592
// begin if i = sort then
59502: LD_VAR 0 3
59506: PUSH
59507: LD_VAR 0 9
59511: EQUAL
59512: IFFALSE 59516
// break ;
59514: GO 59592
// if GetClass ( i ) = 2 then
59516: LD_VAR 0 3
59520: PPUSH
59521: CALL_OW 257
59525: PUSH
59526: LD_INT 2
59528: EQUAL
59529: IFFALSE 59533
// continue ;
59531: GO 59499
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59533: LD_ADDR_VAR 0 11
59537: PUSH
59538: LD_VAR 0 11
59542: PPUSH
59543: LD_VAR 0 11
59547: PUSH
59548: LD_INT 1
59550: PLUS
59551: PPUSH
59552: LD_VAR 0 9
59556: PUSH
59557: LD_VAR 0 3
59561: ARRAY
59562: PPUSH
59563: CALL_OW 2
59567: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59568: LD_ADDR_VAR 0 4
59572: PUSH
59573: LD_VAR 0 4
59577: PUSH
59578: LD_VAR 0 9
59582: PUSH
59583: LD_VAR 0 3
59587: ARRAY
59588: DIFF
59589: ST_TO_ADDR
// end ;
59590: GO 59499
59592: POP
59593: POP
// if p then
59594: LD_VAR 0 11
59598: IFFALSE 59623
// result := Replace ( result , 2 , p ) ;
59600: LD_ADDR_VAR 0 2
59604: PUSH
59605: LD_VAR 0 2
59609: PPUSH
59610: LD_INT 2
59612: PPUSH
59613: LD_VAR 0 11
59617: PPUSH
59618: CALL_OW 1
59622: ST_TO_ADDR
// end else
59623: GO 59669
// for i = eng downto 5 do
59625: LD_ADDR_VAR 0 3
59629: PUSH
59630: DOUBLE
59631: LD_VAR 0 6
59635: INC
59636: ST_TO_ADDR
59637: LD_INT 5
59639: PUSH
59640: FOR_DOWNTO
59641: IFFALSE 59667
// tmp := tmp union eng [ i ] ;
59643: LD_ADDR_VAR 0 4
59647: PUSH
59648: LD_VAR 0 4
59652: PUSH
59653: LD_VAR 0 6
59657: PUSH
59658: LD_VAR 0 3
59662: ARRAY
59663: UNION
59664: ST_TO_ADDR
59665: GO 59640
59667: POP
59668: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59669: LD_ADDR_VAR 0 2
59673: PUSH
59674: LD_VAR 0 2
59678: PPUSH
59679: LD_INT 1
59681: PPUSH
59682: LD_VAR 0 4
59686: PUSH
59687: LD_VAR 0 5
59691: DIFF
59692: PPUSH
59693: CALL_OW 1
59697: ST_TO_ADDR
// exit ;
59698: GO 59700
// end ; end ;
59700: LD_VAR 0 2
59704: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59705: LD_INT 0
59707: PPUSH
59708: PPUSH
59709: PPUSH
// if not mc_bases then
59710: LD_EXP 43
59714: NOT
59715: IFFALSE 59719
// exit ;
59717: GO 59861
// for i = 1 to mc_bases do
59719: LD_ADDR_VAR 0 2
59723: PUSH
59724: DOUBLE
59725: LD_INT 1
59727: DEC
59728: ST_TO_ADDR
59729: LD_EXP 43
59733: PUSH
59734: FOR_TO
59735: IFFALSE 59852
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59737: LD_ADDR_VAR 0 3
59741: PUSH
59742: LD_EXP 43
59746: PUSH
59747: LD_VAR 0 2
59751: ARRAY
59752: PPUSH
59753: LD_INT 21
59755: PUSH
59756: LD_INT 3
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: PUSH
59763: LD_INT 3
59765: PUSH
59766: LD_INT 2
59768: PUSH
59769: LD_INT 30
59771: PUSH
59772: LD_INT 29
59774: PUSH
59775: EMPTY
59776: LIST
59777: LIST
59778: PUSH
59779: LD_INT 30
59781: PUSH
59782: LD_INT 30
59784: PUSH
59785: EMPTY
59786: LIST
59787: LIST
59788: PUSH
59789: EMPTY
59790: LIST
59791: LIST
59792: LIST
59793: PUSH
59794: EMPTY
59795: LIST
59796: LIST
59797: PUSH
59798: LD_INT 3
59800: PUSH
59801: LD_INT 24
59803: PUSH
59804: LD_INT 1000
59806: PUSH
59807: EMPTY
59808: LIST
59809: LIST
59810: PUSH
59811: EMPTY
59812: LIST
59813: LIST
59814: PUSH
59815: EMPTY
59816: LIST
59817: LIST
59818: LIST
59819: PPUSH
59820: CALL_OW 72
59824: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59825: LD_ADDR_EXP 44
59829: PUSH
59830: LD_EXP 44
59834: PPUSH
59835: LD_VAR 0 2
59839: PPUSH
59840: LD_VAR 0 3
59844: PPUSH
59845: CALL_OW 1
59849: ST_TO_ADDR
// end ;
59850: GO 59734
59852: POP
59853: POP
// RaiseSailEvent ( 101 ) ;
59854: LD_INT 101
59856: PPUSH
59857: CALL_OW 427
// end ;
59861: LD_VAR 0 1
59865: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59866: LD_INT 0
59868: PPUSH
59869: PPUSH
59870: PPUSH
59871: PPUSH
59872: PPUSH
59873: PPUSH
59874: PPUSH
// if not mc_bases then
59875: LD_EXP 43
59879: NOT
59880: IFFALSE 59884
// exit ;
59882: GO 60446
// for i = 1 to mc_bases do
59884: LD_ADDR_VAR 0 2
59888: PUSH
59889: DOUBLE
59890: LD_INT 1
59892: DEC
59893: ST_TO_ADDR
59894: LD_EXP 43
59898: PUSH
59899: FOR_TO
59900: IFFALSE 60437
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59902: LD_ADDR_VAR 0 5
59906: PUSH
59907: LD_EXP 43
59911: PUSH
59912: LD_VAR 0 2
59916: ARRAY
59917: PUSH
59918: LD_EXP 72
59922: PUSH
59923: LD_VAR 0 2
59927: ARRAY
59928: UNION
59929: PPUSH
59930: LD_INT 21
59932: PUSH
59933: LD_INT 1
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: PUSH
59940: LD_INT 1
59942: PUSH
59943: LD_INT 3
59945: PUSH
59946: LD_INT 54
59948: PUSH
59949: EMPTY
59950: LIST
59951: PUSH
59952: EMPTY
59953: LIST
59954: LIST
59955: PUSH
59956: LD_INT 3
59958: PUSH
59959: LD_INT 24
59961: PUSH
59962: LD_INT 1000
59964: PUSH
59965: EMPTY
59966: LIST
59967: LIST
59968: PUSH
59969: EMPTY
59970: LIST
59971: LIST
59972: PUSH
59973: EMPTY
59974: LIST
59975: LIST
59976: LIST
59977: PUSH
59978: EMPTY
59979: LIST
59980: LIST
59981: PPUSH
59982: CALL_OW 72
59986: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59987: LD_ADDR_VAR 0 6
59991: PUSH
59992: LD_EXP 43
59996: PUSH
59997: LD_VAR 0 2
60001: ARRAY
60002: PPUSH
60003: LD_INT 21
60005: PUSH
60006: LD_INT 1
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: PUSH
60013: LD_INT 1
60015: PUSH
60016: LD_INT 3
60018: PUSH
60019: LD_INT 54
60021: PUSH
60022: EMPTY
60023: LIST
60024: PUSH
60025: EMPTY
60026: LIST
60027: LIST
60028: PUSH
60029: LD_INT 3
60031: PUSH
60032: LD_INT 24
60034: PUSH
60035: LD_INT 250
60037: PUSH
60038: EMPTY
60039: LIST
60040: LIST
60041: PUSH
60042: EMPTY
60043: LIST
60044: LIST
60045: PUSH
60046: EMPTY
60047: LIST
60048: LIST
60049: LIST
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: PPUSH
60055: CALL_OW 72
60059: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60060: LD_ADDR_VAR 0 7
60064: PUSH
60065: LD_VAR 0 5
60069: PUSH
60070: LD_VAR 0 6
60074: DIFF
60075: ST_TO_ADDR
// if not need_heal_1 then
60076: LD_VAR 0 6
60080: NOT
60081: IFFALSE 60114
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
60083: LD_ADDR_EXP 46
60087: PUSH
60088: LD_EXP 46
60092: PPUSH
60093: LD_VAR 0 2
60097: PUSH
60098: LD_INT 1
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: PPUSH
60105: EMPTY
60106: PPUSH
60107: CALL 14774 0 3
60111: ST_TO_ADDR
60112: GO 60184
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60114: LD_ADDR_EXP 46
60118: PUSH
60119: LD_EXP 46
60123: PPUSH
60124: LD_VAR 0 2
60128: PUSH
60129: LD_INT 1
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PPUSH
60136: LD_EXP 46
60140: PUSH
60141: LD_VAR 0 2
60145: ARRAY
60146: PUSH
60147: LD_INT 1
60149: ARRAY
60150: PPUSH
60151: LD_INT 3
60153: PUSH
60154: LD_INT 24
60156: PUSH
60157: LD_INT 1000
60159: PUSH
60160: EMPTY
60161: LIST
60162: LIST
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: PPUSH
60168: CALL_OW 72
60172: PUSH
60173: LD_VAR 0 6
60177: UNION
60178: PPUSH
60179: CALL 14774 0 3
60183: ST_TO_ADDR
// if not need_heal_2 then
60184: LD_VAR 0 7
60188: NOT
60189: IFFALSE 60222
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60191: LD_ADDR_EXP 46
60195: PUSH
60196: LD_EXP 46
60200: PPUSH
60201: LD_VAR 0 2
60205: PUSH
60206: LD_INT 2
60208: PUSH
60209: EMPTY
60210: LIST
60211: LIST
60212: PPUSH
60213: EMPTY
60214: PPUSH
60215: CALL 14774 0 3
60219: ST_TO_ADDR
60220: GO 60254
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60222: LD_ADDR_EXP 46
60226: PUSH
60227: LD_EXP 46
60231: PPUSH
60232: LD_VAR 0 2
60236: PUSH
60237: LD_INT 2
60239: PUSH
60240: EMPTY
60241: LIST
60242: LIST
60243: PPUSH
60244: LD_VAR 0 7
60248: PPUSH
60249: CALL 14774 0 3
60253: ST_TO_ADDR
// if need_heal_2 then
60254: LD_VAR 0 7
60258: IFFALSE 60419
// for j in need_heal_2 do
60260: LD_ADDR_VAR 0 3
60264: PUSH
60265: LD_VAR 0 7
60269: PUSH
60270: FOR_IN
60271: IFFALSE 60417
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60273: LD_ADDR_VAR 0 5
60277: PUSH
60278: LD_EXP 43
60282: PUSH
60283: LD_VAR 0 2
60287: ARRAY
60288: PPUSH
60289: LD_INT 2
60291: PUSH
60292: LD_INT 30
60294: PUSH
60295: LD_INT 6
60297: PUSH
60298: EMPTY
60299: LIST
60300: LIST
60301: PUSH
60302: LD_INT 30
60304: PUSH
60305: LD_INT 7
60307: PUSH
60308: EMPTY
60309: LIST
60310: LIST
60311: PUSH
60312: LD_INT 30
60314: PUSH
60315: LD_INT 8
60317: PUSH
60318: EMPTY
60319: LIST
60320: LIST
60321: PUSH
60322: LD_INT 30
60324: PUSH
60325: LD_INT 0
60327: PUSH
60328: EMPTY
60329: LIST
60330: LIST
60331: PUSH
60332: LD_INT 30
60334: PUSH
60335: LD_INT 1
60337: PUSH
60338: EMPTY
60339: LIST
60340: LIST
60341: PUSH
60342: EMPTY
60343: LIST
60344: LIST
60345: LIST
60346: LIST
60347: LIST
60348: LIST
60349: PPUSH
60350: CALL_OW 72
60354: ST_TO_ADDR
// if tmp then
60355: LD_VAR 0 5
60359: IFFALSE 60415
// begin k := NearestUnitToUnit ( tmp , j ) ;
60361: LD_ADDR_VAR 0 4
60365: PUSH
60366: LD_VAR 0 5
60370: PPUSH
60371: LD_VAR 0 3
60375: PPUSH
60376: CALL_OW 74
60380: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60381: LD_VAR 0 3
60385: PPUSH
60386: LD_VAR 0 4
60390: PPUSH
60391: CALL_OW 296
60395: PUSH
60396: LD_INT 5
60398: GREATER
60399: IFFALSE 60415
// ComMoveToNearbyEntrance ( j , k ) ;
60401: LD_VAR 0 3
60405: PPUSH
60406: LD_VAR 0 4
60410: PPUSH
60411: CALL 48010 0 2
// end ; end ;
60415: GO 60270
60417: POP
60418: POP
// if not need_heal_1 and not need_heal_2 then
60419: LD_VAR 0 6
60423: NOT
60424: PUSH
60425: LD_VAR 0 7
60429: NOT
60430: AND
60431: IFFALSE 60435
// continue ;
60433: GO 59899
// end ;
60435: GO 59899
60437: POP
60438: POP
// RaiseSailEvent ( 102 ) ;
60439: LD_INT 102
60441: PPUSH
60442: CALL_OW 427
// end ;
60446: LD_VAR 0 1
60450: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60451: LD_INT 0
60453: PPUSH
60454: PPUSH
60455: PPUSH
60456: PPUSH
60457: PPUSH
60458: PPUSH
60459: PPUSH
60460: PPUSH
// if not mc_bases then
60461: LD_EXP 43
60465: NOT
60466: IFFALSE 60470
// exit ;
60468: GO 61381
// for i = 1 to mc_bases do
60470: LD_ADDR_VAR 0 2
60474: PUSH
60475: DOUBLE
60476: LD_INT 1
60478: DEC
60479: ST_TO_ADDR
60480: LD_EXP 43
60484: PUSH
60485: FOR_TO
60486: IFFALSE 61379
// begin if not mc_building_need_repair [ i ] then
60488: LD_EXP 44
60492: PUSH
60493: LD_VAR 0 2
60497: ARRAY
60498: NOT
60499: IFFALSE 60684
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60501: LD_ADDR_VAR 0 6
60505: PUSH
60506: LD_EXP 62
60510: PUSH
60511: LD_VAR 0 2
60515: ARRAY
60516: PPUSH
60517: LD_INT 3
60519: PUSH
60520: LD_INT 24
60522: PUSH
60523: LD_INT 1000
60525: PUSH
60526: EMPTY
60527: LIST
60528: LIST
60529: PUSH
60530: EMPTY
60531: LIST
60532: LIST
60533: PUSH
60534: LD_INT 2
60536: PUSH
60537: LD_INT 34
60539: PUSH
60540: LD_INT 13
60542: PUSH
60543: EMPTY
60544: LIST
60545: LIST
60546: PUSH
60547: LD_INT 34
60549: PUSH
60550: LD_INT 52
60552: PUSH
60553: EMPTY
60554: LIST
60555: LIST
60556: PUSH
60557: LD_INT 34
60559: PUSH
60560: LD_INT 88
60562: PUSH
60563: EMPTY
60564: LIST
60565: LIST
60566: PUSH
60567: EMPTY
60568: LIST
60569: LIST
60570: LIST
60571: LIST
60572: PUSH
60573: EMPTY
60574: LIST
60575: LIST
60576: PPUSH
60577: CALL_OW 72
60581: ST_TO_ADDR
// if cranes then
60582: LD_VAR 0 6
60586: IFFALSE 60648
// for j in cranes do
60588: LD_ADDR_VAR 0 3
60592: PUSH
60593: LD_VAR 0 6
60597: PUSH
60598: FOR_IN
60599: IFFALSE 60646
// if not IsInArea ( j , mc_parking [ i ] ) then
60601: LD_VAR 0 3
60605: PPUSH
60606: LD_EXP 67
60610: PUSH
60611: LD_VAR 0 2
60615: ARRAY
60616: PPUSH
60617: CALL_OW 308
60621: NOT
60622: IFFALSE 60644
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60624: LD_VAR 0 3
60628: PPUSH
60629: LD_EXP 67
60633: PUSH
60634: LD_VAR 0 2
60638: ARRAY
60639: PPUSH
60640: CALL_OW 113
60644: GO 60598
60646: POP
60647: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60648: LD_ADDR_EXP 45
60652: PUSH
60653: LD_EXP 45
60657: PPUSH
60658: LD_VAR 0 2
60662: PPUSH
60663: EMPTY
60664: PPUSH
60665: CALL_OW 1
60669: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60670: LD_VAR 0 2
60674: PPUSH
60675: LD_INT 101
60677: PPUSH
60678: CALL 55524 0 2
// continue ;
60682: GO 60485
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60684: LD_ADDR_EXP 49
60688: PUSH
60689: LD_EXP 49
60693: PPUSH
60694: LD_VAR 0 2
60698: PPUSH
60699: EMPTY
60700: PPUSH
60701: CALL_OW 1
60705: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60706: LD_VAR 0 2
60710: PPUSH
60711: LD_INT 103
60713: PPUSH
60714: CALL 55524 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60718: LD_ADDR_VAR 0 5
60722: PUSH
60723: LD_EXP 43
60727: PUSH
60728: LD_VAR 0 2
60732: ARRAY
60733: PUSH
60734: LD_EXP 72
60738: PUSH
60739: LD_VAR 0 2
60743: ARRAY
60744: UNION
60745: PPUSH
60746: LD_INT 2
60748: PUSH
60749: LD_INT 25
60751: PUSH
60752: LD_INT 2
60754: PUSH
60755: EMPTY
60756: LIST
60757: LIST
60758: PUSH
60759: LD_INT 25
60761: PUSH
60762: LD_INT 16
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: PUSH
60769: EMPTY
60770: LIST
60771: LIST
60772: LIST
60773: PUSH
60774: EMPTY
60775: LIST
60776: PPUSH
60777: CALL_OW 72
60781: ST_TO_ADDR
// if mc_need_heal [ i ] then
60782: LD_EXP 46
60786: PUSH
60787: LD_VAR 0 2
60791: ARRAY
60792: IFFALSE 60836
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60794: LD_ADDR_VAR 0 5
60798: PUSH
60799: LD_VAR 0 5
60803: PUSH
60804: LD_EXP 46
60808: PUSH
60809: LD_VAR 0 2
60813: ARRAY
60814: PUSH
60815: LD_INT 1
60817: ARRAY
60818: PUSH
60819: LD_EXP 46
60823: PUSH
60824: LD_VAR 0 2
60828: ARRAY
60829: PUSH
60830: LD_INT 2
60832: ARRAY
60833: UNION
60834: DIFF
60835: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60836: LD_ADDR_VAR 0 6
60840: PUSH
60841: LD_EXP 62
60845: PUSH
60846: LD_VAR 0 2
60850: ARRAY
60851: PPUSH
60852: LD_INT 2
60854: PUSH
60855: LD_INT 34
60857: PUSH
60858: LD_INT 13
60860: PUSH
60861: EMPTY
60862: LIST
60863: LIST
60864: PUSH
60865: LD_INT 34
60867: PUSH
60868: LD_INT 52
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: PUSH
60875: LD_INT 34
60877: PUSH
60878: LD_INT 88
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: PUSH
60885: EMPTY
60886: LIST
60887: LIST
60888: LIST
60889: LIST
60890: PPUSH
60891: CALL_OW 72
60895: ST_TO_ADDR
// if cranes then
60896: LD_VAR 0 6
60900: IFFALSE 61068
// begin for j in cranes do
60902: LD_ADDR_VAR 0 3
60906: PUSH
60907: LD_VAR 0 6
60911: PUSH
60912: FOR_IN
60913: IFFALSE 61066
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60915: LD_VAR 0 3
60919: PPUSH
60920: CALL_OW 256
60924: PUSH
60925: LD_INT 1000
60927: EQUAL
60928: PUSH
60929: LD_VAR 0 3
60933: PPUSH
60934: CALL_OW 314
60938: NOT
60939: AND
60940: IFFALSE 61006
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
60942: LD_ADDR_VAR 0 8
60946: PUSH
60947: LD_EXP 44
60951: PUSH
60952: LD_VAR 0 2
60956: ARRAY
60957: PPUSH
60958: LD_VAR 0 3
60962: PPUSH
60963: CALL_OW 74
60967: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60968: LD_VAR 0 8
60972: PPUSH
60973: LD_INT 16
60975: PPUSH
60976: CALL 17371 0 2
60980: PUSH
60981: LD_INT 4
60983: ARRAY
60984: PUSH
60985: LD_INT 10
60987: LESS
60988: IFFALSE 61004
// ComRepairBuilding ( j , to_repair ) ;
60990: LD_VAR 0 3
60994: PPUSH
60995: LD_VAR 0 8
60999: PPUSH
61000: CALL_OW 130
// end else
61004: GO 61064
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61006: LD_VAR 0 3
61010: PPUSH
61011: CALL_OW 256
61015: PUSH
61016: LD_INT 500
61018: LESS
61019: PUSH
61020: LD_VAR 0 3
61024: PPUSH
61025: LD_EXP 67
61029: PUSH
61030: LD_VAR 0 2
61034: ARRAY
61035: PPUSH
61036: CALL_OW 308
61040: NOT
61041: AND
61042: IFFALSE 61064
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61044: LD_VAR 0 3
61048: PPUSH
61049: LD_EXP 67
61053: PUSH
61054: LD_VAR 0 2
61058: ARRAY
61059: PPUSH
61060: CALL_OW 113
// end ;
61064: GO 60912
61066: POP
61067: POP
// end ; if tmp > 3 then
61068: LD_VAR 0 5
61072: PUSH
61073: LD_INT 3
61075: GREATER
61076: IFFALSE 61096
// tmp := ShrinkArray ( tmp , 4 ) ;
61078: LD_ADDR_VAR 0 5
61082: PUSH
61083: LD_VAR 0 5
61087: PPUSH
61088: LD_INT 4
61090: PPUSH
61091: CALL 47448 0 2
61095: ST_TO_ADDR
// if not tmp then
61096: LD_VAR 0 5
61100: NOT
61101: IFFALSE 61105
// continue ;
61103: GO 60485
// for j in tmp do
61105: LD_ADDR_VAR 0 3
61109: PUSH
61110: LD_VAR 0 5
61114: PUSH
61115: FOR_IN
61116: IFFALSE 61375
// begin if IsInUnit ( j ) then
61118: LD_VAR 0 3
61122: PPUSH
61123: CALL_OW 310
61127: IFFALSE 61138
// ComExitBuilding ( j ) ;
61129: LD_VAR 0 3
61133: PPUSH
61134: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61138: LD_VAR 0 3
61142: PUSH
61143: LD_EXP 45
61147: PUSH
61148: LD_VAR 0 2
61152: ARRAY
61153: IN
61154: NOT
61155: IFFALSE 61213
// begin SetTag ( j , 101 ) ;
61157: LD_VAR 0 3
61161: PPUSH
61162: LD_INT 101
61164: PPUSH
61165: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61169: LD_ADDR_EXP 45
61173: PUSH
61174: LD_EXP 45
61178: PPUSH
61179: LD_VAR 0 2
61183: PUSH
61184: LD_EXP 45
61188: PUSH
61189: LD_VAR 0 2
61193: ARRAY
61194: PUSH
61195: LD_INT 1
61197: PLUS
61198: PUSH
61199: EMPTY
61200: LIST
61201: LIST
61202: PPUSH
61203: LD_VAR 0 3
61207: PPUSH
61208: CALL 14774 0 3
61212: ST_TO_ADDR
// end ; wait ( 1 ) ;
61213: LD_INT 1
61215: PPUSH
61216: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61220: LD_ADDR_VAR 0 7
61224: PUSH
61225: LD_EXP 44
61229: PUSH
61230: LD_VAR 0 2
61234: ARRAY
61235: ST_TO_ADDR
// if mc_scan [ i ] then
61236: LD_EXP 66
61240: PUSH
61241: LD_VAR 0 2
61245: ARRAY
61246: IFFALSE 61308
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61248: LD_ADDR_VAR 0 7
61252: PUSH
61253: LD_EXP 44
61257: PUSH
61258: LD_VAR 0 2
61262: ARRAY
61263: PPUSH
61264: LD_INT 3
61266: PUSH
61267: LD_INT 30
61269: PUSH
61270: LD_INT 32
61272: PUSH
61273: EMPTY
61274: LIST
61275: LIST
61276: PUSH
61277: LD_INT 30
61279: PUSH
61280: LD_INT 33
61282: PUSH
61283: EMPTY
61284: LIST
61285: LIST
61286: PUSH
61287: LD_INT 30
61289: PUSH
61290: LD_INT 31
61292: PUSH
61293: EMPTY
61294: LIST
61295: LIST
61296: PUSH
61297: EMPTY
61298: LIST
61299: LIST
61300: LIST
61301: LIST
61302: PPUSH
61303: CALL_OW 72
61307: ST_TO_ADDR
// if not to_repair_tmp then
61308: LD_VAR 0 7
61312: NOT
61313: IFFALSE 61317
// continue ;
61315: GO 61115
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61317: LD_ADDR_VAR 0 8
61321: PUSH
61322: LD_VAR 0 7
61326: PPUSH
61327: LD_VAR 0 3
61331: PPUSH
61332: CALL_OW 74
61336: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
61337: LD_VAR 0 8
61341: PPUSH
61342: LD_INT 16
61344: PPUSH
61345: CALL 17371 0 2
61349: PUSH
61350: LD_INT 4
61352: ARRAY
61353: PUSH
61354: LD_INT 14
61356: LESS
61357: IFFALSE 61373
// ComRepairBuilding ( j , to_repair ) ;
61359: LD_VAR 0 3
61363: PPUSH
61364: LD_VAR 0 8
61368: PPUSH
61369: CALL_OW 130
// end ;
61373: GO 61115
61375: POP
61376: POP
// end ;
61377: GO 60485
61379: POP
61380: POP
// end ;
61381: LD_VAR 0 1
61385: RET
// export function MC_Heal ; var i , j , tmp ; begin
61386: LD_INT 0
61388: PPUSH
61389: PPUSH
61390: PPUSH
61391: PPUSH
// if not mc_bases then
61392: LD_EXP 43
61396: NOT
61397: IFFALSE 61401
// exit ;
61399: GO 61803
// for i = 1 to mc_bases do
61401: LD_ADDR_VAR 0 2
61405: PUSH
61406: DOUBLE
61407: LD_INT 1
61409: DEC
61410: ST_TO_ADDR
61411: LD_EXP 43
61415: PUSH
61416: FOR_TO
61417: IFFALSE 61801
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61419: LD_EXP 46
61423: PUSH
61424: LD_VAR 0 2
61428: ARRAY
61429: PUSH
61430: LD_INT 1
61432: ARRAY
61433: NOT
61434: PUSH
61435: LD_EXP 46
61439: PUSH
61440: LD_VAR 0 2
61444: ARRAY
61445: PUSH
61446: LD_INT 2
61448: ARRAY
61449: NOT
61450: AND
61451: IFFALSE 61489
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61453: LD_ADDR_EXP 47
61457: PUSH
61458: LD_EXP 47
61462: PPUSH
61463: LD_VAR 0 2
61467: PPUSH
61468: EMPTY
61469: PPUSH
61470: CALL_OW 1
61474: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61475: LD_VAR 0 2
61479: PPUSH
61480: LD_INT 102
61482: PPUSH
61483: CALL 55524 0 2
// continue ;
61487: GO 61416
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61489: LD_ADDR_VAR 0 4
61493: PUSH
61494: LD_EXP 43
61498: PUSH
61499: LD_VAR 0 2
61503: ARRAY
61504: PPUSH
61505: LD_INT 25
61507: PUSH
61508: LD_INT 4
61510: PUSH
61511: EMPTY
61512: LIST
61513: LIST
61514: PPUSH
61515: CALL_OW 72
61519: ST_TO_ADDR
// if not tmp then
61520: LD_VAR 0 4
61524: NOT
61525: IFFALSE 61529
// continue ;
61527: GO 61416
// if mc_taming [ i ] then
61529: LD_EXP 74
61533: PUSH
61534: LD_VAR 0 2
61538: ARRAY
61539: IFFALSE 61563
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61541: LD_ADDR_EXP 74
61545: PUSH
61546: LD_EXP 74
61550: PPUSH
61551: LD_VAR 0 2
61555: PPUSH
61556: EMPTY
61557: PPUSH
61558: CALL_OW 1
61562: ST_TO_ADDR
// for j in tmp do
61563: LD_ADDR_VAR 0 3
61567: PUSH
61568: LD_VAR 0 4
61572: PUSH
61573: FOR_IN
61574: IFFALSE 61797
// begin if IsInUnit ( j ) then
61576: LD_VAR 0 3
61580: PPUSH
61581: CALL_OW 310
61585: IFFALSE 61596
// ComExitBuilding ( j ) ;
61587: LD_VAR 0 3
61591: PPUSH
61592: CALL_OW 122
// if not j in mc_healers [ i ] then
61596: LD_VAR 0 3
61600: PUSH
61601: LD_EXP 47
61605: PUSH
61606: LD_VAR 0 2
61610: ARRAY
61611: IN
61612: NOT
61613: IFFALSE 61659
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61615: LD_ADDR_EXP 47
61619: PUSH
61620: LD_EXP 47
61624: PPUSH
61625: LD_VAR 0 2
61629: PUSH
61630: LD_EXP 47
61634: PUSH
61635: LD_VAR 0 2
61639: ARRAY
61640: PUSH
61641: LD_INT 1
61643: PLUS
61644: PUSH
61645: EMPTY
61646: LIST
61647: LIST
61648: PPUSH
61649: LD_VAR 0 3
61653: PPUSH
61654: CALL 14774 0 3
61658: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61659: LD_VAR 0 3
61663: PPUSH
61664: CALL_OW 110
61668: PUSH
61669: LD_INT 102
61671: NONEQUAL
61672: IFFALSE 61686
// SetTag ( j , 102 ) ;
61674: LD_VAR 0 3
61678: PPUSH
61679: LD_INT 102
61681: PPUSH
61682: CALL_OW 109
// Wait ( 3 ) ;
61686: LD_INT 3
61688: PPUSH
61689: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61693: LD_EXP 46
61697: PUSH
61698: LD_VAR 0 2
61702: ARRAY
61703: PUSH
61704: LD_INT 1
61706: ARRAY
61707: IFFALSE 61739
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61709: LD_VAR 0 3
61713: PPUSH
61714: LD_EXP 46
61718: PUSH
61719: LD_VAR 0 2
61723: ARRAY
61724: PUSH
61725: LD_INT 1
61727: ARRAY
61728: PUSH
61729: LD_INT 1
61731: ARRAY
61732: PPUSH
61733: CALL_OW 128
61737: GO 61795
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61739: LD_VAR 0 3
61743: PPUSH
61744: CALL_OW 314
61748: NOT
61749: PUSH
61750: LD_EXP 46
61754: PUSH
61755: LD_VAR 0 2
61759: ARRAY
61760: PUSH
61761: LD_INT 2
61763: ARRAY
61764: AND
61765: IFFALSE 61795
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61767: LD_VAR 0 3
61771: PPUSH
61772: LD_EXP 46
61776: PUSH
61777: LD_VAR 0 2
61781: ARRAY
61782: PUSH
61783: LD_INT 2
61785: ARRAY
61786: PUSH
61787: LD_INT 1
61789: ARRAY
61790: PPUSH
61791: CALL_OW 128
// end ;
61795: GO 61573
61797: POP
61798: POP
// end ;
61799: GO 61416
61801: POP
61802: POP
// end ;
61803: LD_VAR 0 1
61807: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
61808: LD_INT 0
61810: PPUSH
61811: PPUSH
61812: PPUSH
61813: PPUSH
61814: PPUSH
61815: PPUSH
// if not mc_bases then
61816: LD_EXP 43
61820: NOT
61821: IFFALSE 61825
// exit ;
61823: GO 62988
// for i = 1 to mc_bases do
61825: LD_ADDR_VAR 0 2
61829: PUSH
61830: DOUBLE
61831: LD_INT 1
61833: DEC
61834: ST_TO_ADDR
61835: LD_EXP 43
61839: PUSH
61840: FOR_TO
61841: IFFALSE 62986
// begin if mc_scan [ i ] then
61843: LD_EXP 66
61847: PUSH
61848: LD_VAR 0 2
61852: ARRAY
61853: IFFALSE 61857
// continue ;
61855: GO 61840
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61857: LD_EXP 48
61861: PUSH
61862: LD_VAR 0 2
61866: ARRAY
61867: NOT
61868: PUSH
61869: LD_EXP 50
61873: PUSH
61874: LD_VAR 0 2
61878: ARRAY
61879: NOT
61880: AND
61881: PUSH
61882: LD_EXP 49
61886: PUSH
61887: LD_VAR 0 2
61891: ARRAY
61892: AND
61893: IFFALSE 61931
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61895: LD_ADDR_EXP 49
61899: PUSH
61900: LD_EXP 49
61904: PPUSH
61905: LD_VAR 0 2
61909: PPUSH
61910: EMPTY
61911: PPUSH
61912: CALL_OW 1
61916: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61917: LD_VAR 0 2
61921: PPUSH
61922: LD_INT 103
61924: PPUSH
61925: CALL 55524 0 2
// continue ;
61929: GO 61840
// end ; if mc_construct_list [ i ] then
61931: LD_EXP 50
61935: PUSH
61936: LD_VAR 0 2
61940: ARRAY
61941: IFFALSE 62161
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61943: LD_ADDR_VAR 0 5
61947: PUSH
61948: LD_EXP 43
61952: PUSH
61953: LD_VAR 0 2
61957: ARRAY
61958: PPUSH
61959: LD_INT 25
61961: PUSH
61962: LD_INT 2
61964: PUSH
61965: EMPTY
61966: LIST
61967: LIST
61968: PPUSH
61969: CALL_OW 72
61973: PUSH
61974: LD_EXP 45
61978: PUSH
61979: LD_VAR 0 2
61983: ARRAY
61984: DIFF
61985: ST_TO_ADDR
// if not tmp then
61986: LD_VAR 0 5
61990: NOT
61991: IFFALSE 61995
// continue ;
61993: GO 61840
// for j in tmp do
61995: LD_ADDR_VAR 0 3
61999: PUSH
62000: LD_VAR 0 5
62004: PUSH
62005: FOR_IN
62006: IFFALSE 62157
// begin if not mc_builders [ i ] then
62008: LD_EXP 49
62012: PUSH
62013: LD_VAR 0 2
62017: ARRAY
62018: NOT
62019: IFFALSE 62077
// begin SetTag ( j , 103 ) ;
62021: LD_VAR 0 3
62025: PPUSH
62026: LD_INT 103
62028: PPUSH
62029: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62033: LD_ADDR_EXP 49
62037: PUSH
62038: LD_EXP 49
62042: PPUSH
62043: LD_VAR 0 2
62047: PUSH
62048: LD_EXP 49
62052: PUSH
62053: LD_VAR 0 2
62057: ARRAY
62058: PUSH
62059: LD_INT 1
62061: PLUS
62062: PUSH
62063: EMPTY
62064: LIST
62065: LIST
62066: PPUSH
62067: LD_VAR 0 3
62071: PPUSH
62072: CALL 14774 0 3
62076: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62077: LD_VAR 0 3
62081: PPUSH
62082: CALL_OW 310
62086: IFFALSE 62097
// ComExitBuilding ( j ) ;
62088: LD_VAR 0 3
62092: PPUSH
62093: CALL_OW 122
// wait ( 3 ) ;
62097: LD_INT 3
62099: PPUSH
62100: CALL_OW 67
// if not mc_construct_list [ i ] then
62104: LD_EXP 50
62108: PUSH
62109: LD_VAR 0 2
62113: ARRAY
62114: NOT
62115: IFFALSE 62119
// break ;
62117: GO 62157
// if not HasTask ( j ) then
62119: LD_VAR 0 3
62123: PPUSH
62124: CALL_OW 314
62128: NOT
62129: IFFALSE 62155
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62131: LD_VAR 0 3
62135: PPUSH
62136: LD_EXP 50
62140: PUSH
62141: LD_VAR 0 2
62145: ARRAY
62146: PUSH
62147: LD_INT 1
62149: ARRAY
62150: PPUSH
62151: CALL 17644 0 2
// end ;
62155: GO 62005
62157: POP
62158: POP
// end else
62159: GO 62984
// if mc_build_list [ i ] then
62161: LD_EXP 48
62165: PUSH
62166: LD_VAR 0 2
62170: ARRAY
62171: IFFALSE 62984
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62173: LD_EXP 48
62177: PUSH
62178: LD_VAR 0 2
62182: ARRAY
62183: PUSH
62184: LD_INT 1
62186: ARRAY
62187: PUSH
62188: LD_INT 1
62190: ARRAY
62191: PPUSH
62192: CALL 17468 0 1
62196: PUSH
62197: LD_EXP 43
62201: PUSH
62202: LD_VAR 0 2
62206: ARRAY
62207: PPUSH
62208: LD_INT 2
62210: PUSH
62211: LD_INT 30
62213: PUSH
62214: LD_INT 2
62216: PUSH
62217: EMPTY
62218: LIST
62219: LIST
62220: PUSH
62221: LD_INT 30
62223: PUSH
62224: LD_INT 3
62226: PUSH
62227: EMPTY
62228: LIST
62229: LIST
62230: PUSH
62231: EMPTY
62232: LIST
62233: LIST
62234: LIST
62235: PPUSH
62236: CALL_OW 72
62240: NOT
62241: AND
62242: IFFALSE 62347
// begin for j = 1 to mc_build_list [ i ] do
62244: LD_ADDR_VAR 0 3
62248: PUSH
62249: DOUBLE
62250: LD_INT 1
62252: DEC
62253: ST_TO_ADDR
62254: LD_EXP 48
62258: PUSH
62259: LD_VAR 0 2
62263: ARRAY
62264: PUSH
62265: FOR_TO
62266: IFFALSE 62345
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62268: LD_EXP 48
62272: PUSH
62273: LD_VAR 0 2
62277: ARRAY
62278: PUSH
62279: LD_VAR 0 3
62283: ARRAY
62284: PUSH
62285: LD_INT 1
62287: ARRAY
62288: PUSH
62289: LD_INT 2
62291: EQUAL
62292: IFFALSE 62343
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62294: LD_ADDR_EXP 48
62298: PUSH
62299: LD_EXP 48
62303: PPUSH
62304: LD_VAR 0 2
62308: PPUSH
62309: LD_EXP 48
62313: PUSH
62314: LD_VAR 0 2
62318: ARRAY
62319: PPUSH
62320: LD_VAR 0 3
62324: PPUSH
62325: LD_INT 1
62327: PPUSH
62328: LD_INT 0
62330: PPUSH
62331: CALL 14192 0 4
62335: PPUSH
62336: CALL_OW 1
62340: ST_TO_ADDR
// break ;
62341: GO 62345
// end ;
62343: GO 62265
62345: POP
62346: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62347: LD_ADDR_VAR 0 6
62351: PUSH
62352: LD_EXP 43
62356: PUSH
62357: LD_VAR 0 2
62361: ARRAY
62362: PPUSH
62363: LD_INT 2
62365: PUSH
62366: LD_INT 30
62368: PUSH
62369: LD_INT 0
62371: PUSH
62372: EMPTY
62373: LIST
62374: LIST
62375: PUSH
62376: LD_INT 30
62378: PUSH
62379: LD_INT 1
62381: PUSH
62382: EMPTY
62383: LIST
62384: LIST
62385: PUSH
62386: EMPTY
62387: LIST
62388: LIST
62389: LIST
62390: PPUSH
62391: CALL_OW 72
62395: ST_TO_ADDR
// for k := 1 to depot do
62396: LD_ADDR_VAR 0 4
62400: PUSH
62401: DOUBLE
62402: LD_INT 1
62404: DEC
62405: ST_TO_ADDR
62406: LD_VAR 0 6
62410: PUSH
62411: FOR_TO
62412: IFFALSE 62982
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62414: LD_EXP 48
62418: PUSH
62419: LD_VAR 0 2
62423: ARRAY
62424: PUSH
62425: LD_INT 1
62427: ARRAY
62428: PUSH
62429: LD_INT 1
62431: ARRAY
62432: PUSH
62433: LD_INT 0
62435: EQUAL
62436: PUSH
62437: LD_VAR 0 6
62441: PUSH
62442: LD_VAR 0 4
62446: ARRAY
62447: PPUSH
62448: LD_EXP 48
62452: PUSH
62453: LD_VAR 0 2
62457: ARRAY
62458: PUSH
62459: LD_INT 1
62461: ARRAY
62462: PUSH
62463: LD_INT 1
62465: ARRAY
62466: PPUSH
62467: LD_EXP 48
62471: PUSH
62472: LD_VAR 0 2
62476: ARRAY
62477: PUSH
62478: LD_INT 1
62480: ARRAY
62481: PUSH
62482: LD_INT 2
62484: ARRAY
62485: PPUSH
62486: LD_EXP 48
62490: PUSH
62491: LD_VAR 0 2
62495: ARRAY
62496: PUSH
62497: LD_INT 1
62499: ARRAY
62500: PUSH
62501: LD_INT 3
62503: ARRAY
62504: PPUSH
62505: LD_EXP 48
62509: PUSH
62510: LD_VAR 0 2
62514: ARRAY
62515: PUSH
62516: LD_INT 1
62518: ARRAY
62519: PUSH
62520: LD_INT 4
62522: ARRAY
62523: PPUSH
62524: CALL 22880 0 5
62528: OR
62529: IFFALSE 62810
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62531: LD_ADDR_VAR 0 5
62535: PUSH
62536: LD_EXP 43
62540: PUSH
62541: LD_VAR 0 2
62545: ARRAY
62546: PPUSH
62547: LD_INT 25
62549: PUSH
62550: LD_INT 2
62552: PUSH
62553: EMPTY
62554: LIST
62555: LIST
62556: PPUSH
62557: CALL_OW 72
62561: PUSH
62562: LD_EXP 45
62566: PUSH
62567: LD_VAR 0 2
62571: ARRAY
62572: DIFF
62573: ST_TO_ADDR
// if not tmp then
62574: LD_VAR 0 5
62578: NOT
62579: IFFALSE 62583
// continue ;
62581: GO 62411
// for j in tmp do
62583: LD_ADDR_VAR 0 3
62587: PUSH
62588: LD_VAR 0 5
62592: PUSH
62593: FOR_IN
62594: IFFALSE 62806
// begin if not mc_builders [ i ] then
62596: LD_EXP 49
62600: PUSH
62601: LD_VAR 0 2
62605: ARRAY
62606: NOT
62607: IFFALSE 62665
// begin SetTag ( j , 103 ) ;
62609: LD_VAR 0 3
62613: PPUSH
62614: LD_INT 103
62616: PPUSH
62617: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62621: LD_ADDR_EXP 49
62625: PUSH
62626: LD_EXP 49
62630: PPUSH
62631: LD_VAR 0 2
62635: PUSH
62636: LD_EXP 49
62640: PUSH
62641: LD_VAR 0 2
62645: ARRAY
62646: PUSH
62647: LD_INT 1
62649: PLUS
62650: PUSH
62651: EMPTY
62652: LIST
62653: LIST
62654: PPUSH
62655: LD_VAR 0 3
62659: PPUSH
62660: CALL 14774 0 3
62664: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62665: LD_VAR 0 3
62669: PPUSH
62670: CALL_OW 310
62674: IFFALSE 62685
// ComExitBuilding ( j ) ;
62676: LD_VAR 0 3
62680: PPUSH
62681: CALL_OW 122
// wait ( 3 ) ;
62685: LD_INT 3
62687: PPUSH
62688: CALL_OW 67
// if not mc_build_list [ i ] then
62692: LD_EXP 48
62696: PUSH
62697: LD_VAR 0 2
62701: ARRAY
62702: NOT
62703: IFFALSE 62707
// break ;
62705: GO 62806
// if not HasTask ( j ) then
62707: LD_VAR 0 3
62711: PPUSH
62712: CALL_OW 314
62716: NOT
62717: IFFALSE 62804
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62719: LD_VAR 0 3
62723: PPUSH
62724: LD_EXP 48
62728: PUSH
62729: LD_VAR 0 2
62733: ARRAY
62734: PUSH
62735: LD_INT 1
62737: ARRAY
62738: PUSH
62739: LD_INT 1
62741: ARRAY
62742: PPUSH
62743: LD_EXP 48
62747: PUSH
62748: LD_VAR 0 2
62752: ARRAY
62753: PUSH
62754: LD_INT 1
62756: ARRAY
62757: PUSH
62758: LD_INT 2
62760: ARRAY
62761: PPUSH
62762: LD_EXP 48
62766: PUSH
62767: LD_VAR 0 2
62771: ARRAY
62772: PUSH
62773: LD_INT 1
62775: ARRAY
62776: PUSH
62777: LD_INT 3
62779: ARRAY
62780: PPUSH
62781: LD_EXP 48
62785: PUSH
62786: LD_VAR 0 2
62790: ARRAY
62791: PUSH
62792: LD_INT 1
62794: ARRAY
62795: PUSH
62796: LD_INT 4
62798: ARRAY
62799: PPUSH
62800: CALL_OW 145
// end ;
62804: GO 62593
62806: POP
62807: POP
// end else
62808: GO 62980
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62810: LD_EXP 43
62814: PUSH
62815: LD_VAR 0 2
62819: ARRAY
62820: PPUSH
62821: LD_EXP 48
62825: PUSH
62826: LD_VAR 0 2
62830: ARRAY
62831: PUSH
62832: LD_INT 1
62834: ARRAY
62835: PUSH
62836: LD_INT 1
62838: ARRAY
62839: PPUSH
62840: LD_EXP 48
62844: PUSH
62845: LD_VAR 0 2
62849: ARRAY
62850: PUSH
62851: LD_INT 1
62853: ARRAY
62854: PUSH
62855: LD_INT 2
62857: ARRAY
62858: PPUSH
62859: LD_EXP 48
62863: PUSH
62864: LD_VAR 0 2
62868: ARRAY
62869: PUSH
62870: LD_INT 1
62872: ARRAY
62873: PUSH
62874: LD_INT 3
62876: ARRAY
62877: PPUSH
62878: LD_EXP 48
62882: PUSH
62883: LD_VAR 0 2
62887: ARRAY
62888: PUSH
62889: LD_INT 1
62891: ARRAY
62892: PUSH
62893: LD_INT 4
62895: ARRAY
62896: PPUSH
62897: LD_EXP 43
62901: PUSH
62902: LD_VAR 0 2
62906: ARRAY
62907: PPUSH
62908: LD_INT 21
62910: PUSH
62911: LD_INT 3
62913: PUSH
62914: EMPTY
62915: LIST
62916: LIST
62917: PPUSH
62918: CALL_OW 72
62922: PPUSH
62923: EMPTY
62924: PPUSH
62925: CALL 21634 0 7
62929: NOT
62930: IFFALSE 62980
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62932: LD_ADDR_EXP 48
62936: PUSH
62937: LD_EXP 48
62941: PPUSH
62942: LD_VAR 0 2
62946: PPUSH
62947: LD_EXP 48
62951: PUSH
62952: LD_VAR 0 2
62956: ARRAY
62957: PPUSH
62958: LD_INT 1
62960: PPUSH
62961: LD_INT 1
62963: NEG
62964: PPUSH
62965: LD_INT 0
62967: PPUSH
62968: CALL 14192 0 4
62972: PPUSH
62973: CALL_OW 1
62977: ST_TO_ADDR
// continue ;
62978: GO 62411
// end ; end ;
62980: GO 62411
62982: POP
62983: POP
// end ; end ;
62984: GO 61840
62986: POP
62987: POP
// end ;
62988: LD_VAR 0 1
62992: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62993: LD_INT 0
62995: PPUSH
62996: PPUSH
62997: PPUSH
62998: PPUSH
62999: PPUSH
63000: PPUSH
// if not mc_bases then
63001: LD_EXP 43
63005: NOT
63006: IFFALSE 63010
// exit ;
63008: GO 63437
// for i = 1 to mc_bases do
63010: LD_ADDR_VAR 0 2
63014: PUSH
63015: DOUBLE
63016: LD_INT 1
63018: DEC
63019: ST_TO_ADDR
63020: LD_EXP 43
63024: PUSH
63025: FOR_TO
63026: IFFALSE 63435
// begin tmp := mc_build_upgrade [ i ] ;
63028: LD_ADDR_VAR 0 4
63032: PUSH
63033: LD_EXP 75
63037: PUSH
63038: LD_VAR 0 2
63042: ARRAY
63043: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
63044: LD_ADDR_VAR 0 6
63048: PUSH
63049: LD_EXP 76
63053: PUSH
63054: LD_VAR 0 2
63058: ARRAY
63059: PPUSH
63060: LD_INT 2
63062: PUSH
63063: LD_INT 30
63065: PUSH
63066: LD_INT 6
63068: PUSH
63069: EMPTY
63070: LIST
63071: LIST
63072: PUSH
63073: LD_INT 30
63075: PUSH
63076: LD_INT 7
63078: PUSH
63079: EMPTY
63080: LIST
63081: LIST
63082: PUSH
63083: EMPTY
63084: LIST
63085: LIST
63086: LIST
63087: PPUSH
63088: CALL_OW 72
63092: ST_TO_ADDR
// if not tmp and not lab then
63093: LD_VAR 0 4
63097: NOT
63098: PUSH
63099: LD_VAR 0 6
63103: NOT
63104: AND
63105: IFFALSE 63109
// continue ;
63107: GO 63025
// if tmp then
63109: LD_VAR 0 4
63113: IFFALSE 63233
// for j in tmp do
63115: LD_ADDR_VAR 0 3
63119: PUSH
63120: LD_VAR 0 4
63124: PUSH
63125: FOR_IN
63126: IFFALSE 63231
// begin if UpgradeCost ( j ) then
63128: LD_VAR 0 3
63132: PPUSH
63133: CALL 21294 0 1
63137: IFFALSE 63229
// begin ComUpgrade ( j ) ;
63139: LD_VAR 0 3
63143: PPUSH
63144: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63148: LD_ADDR_EXP 75
63152: PUSH
63153: LD_EXP 75
63157: PPUSH
63158: LD_VAR 0 2
63162: PPUSH
63163: LD_EXP 75
63167: PUSH
63168: LD_VAR 0 2
63172: ARRAY
63173: PUSH
63174: LD_VAR 0 3
63178: DIFF
63179: PPUSH
63180: CALL_OW 1
63184: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63185: LD_ADDR_EXP 50
63189: PUSH
63190: LD_EXP 50
63194: PPUSH
63195: LD_VAR 0 2
63199: PUSH
63200: LD_EXP 50
63204: PUSH
63205: LD_VAR 0 2
63209: ARRAY
63210: PUSH
63211: LD_INT 1
63213: PLUS
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: PPUSH
63219: LD_VAR 0 3
63223: PPUSH
63224: CALL 14774 0 3
63228: ST_TO_ADDR
// end ; end ;
63229: GO 63125
63231: POP
63232: POP
// if not lab or not mc_lab_upgrade [ i ] then
63233: LD_VAR 0 6
63237: NOT
63238: PUSH
63239: LD_EXP 77
63243: PUSH
63244: LD_VAR 0 2
63248: ARRAY
63249: NOT
63250: OR
63251: IFFALSE 63255
// continue ;
63253: GO 63025
// for j in lab do
63255: LD_ADDR_VAR 0 3
63259: PUSH
63260: LD_VAR 0 6
63264: PUSH
63265: FOR_IN
63266: IFFALSE 63431
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63268: LD_VAR 0 3
63272: PPUSH
63273: CALL_OW 266
63277: PUSH
63278: LD_INT 6
63280: PUSH
63281: LD_INT 7
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: IN
63288: PUSH
63289: LD_VAR 0 3
63293: PPUSH
63294: CALL_OW 461
63298: PUSH
63299: LD_INT 1
63301: NONEQUAL
63302: AND
63303: IFFALSE 63429
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63305: LD_VAR 0 3
63309: PPUSH
63310: LD_EXP 77
63314: PUSH
63315: LD_VAR 0 2
63319: ARRAY
63320: PUSH
63321: LD_INT 1
63323: ARRAY
63324: PPUSH
63325: CALL 21499 0 2
63329: IFFALSE 63429
// begin ComCancel ( j ) ;
63331: LD_VAR 0 3
63335: PPUSH
63336: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63340: LD_VAR 0 3
63344: PPUSH
63345: LD_EXP 77
63349: PUSH
63350: LD_VAR 0 2
63354: ARRAY
63355: PUSH
63356: LD_INT 1
63358: ARRAY
63359: PPUSH
63360: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63364: LD_VAR 0 3
63368: PUSH
63369: LD_EXP 50
63373: PUSH
63374: LD_VAR 0 2
63378: ARRAY
63379: IN
63380: NOT
63381: IFFALSE 63427
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63383: LD_ADDR_EXP 50
63387: PUSH
63388: LD_EXP 50
63392: PPUSH
63393: LD_VAR 0 2
63397: PUSH
63398: LD_EXP 50
63402: PUSH
63403: LD_VAR 0 2
63407: ARRAY
63408: PUSH
63409: LD_INT 1
63411: PLUS
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: PPUSH
63417: LD_VAR 0 3
63421: PPUSH
63422: CALL 14774 0 3
63426: ST_TO_ADDR
// break ;
63427: GO 63431
// end ; end ; end ;
63429: GO 63265
63431: POP
63432: POP
// end ;
63433: GO 63025
63435: POP
63436: POP
// end ;
63437: LD_VAR 0 1
63441: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63442: LD_INT 0
63444: PPUSH
63445: PPUSH
63446: PPUSH
63447: PPUSH
63448: PPUSH
63449: PPUSH
63450: PPUSH
63451: PPUSH
63452: PPUSH
// if not mc_bases then
63453: LD_EXP 43
63457: NOT
63458: IFFALSE 63462
// exit ;
63460: GO 63867
// for i = 1 to mc_bases do
63462: LD_ADDR_VAR 0 2
63466: PUSH
63467: DOUBLE
63468: LD_INT 1
63470: DEC
63471: ST_TO_ADDR
63472: LD_EXP 43
63476: PUSH
63477: FOR_TO
63478: IFFALSE 63865
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63480: LD_EXP 51
63484: PUSH
63485: LD_VAR 0 2
63489: ARRAY
63490: NOT
63491: PUSH
63492: LD_EXP 43
63496: PUSH
63497: LD_VAR 0 2
63501: ARRAY
63502: PPUSH
63503: LD_INT 30
63505: PUSH
63506: LD_INT 3
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PPUSH
63513: CALL_OW 72
63517: NOT
63518: OR
63519: IFFALSE 63523
// continue ;
63521: GO 63477
// busy := false ;
63523: LD_ADDR_VAR 0 8
63527: PUSH
63528: LD_INT 0
63530: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63531: LD_ADDR_VAR 0 4
63535: PUSH
63536: LD_EXP 43
63540: PUSH
63541: LD_VAR 0 2
63545: ARRAY
63546: PPUSH
63547: LD_INT 30
63549: PUSH
63550: LD_INT 3
63552: PUSH
63553: EMPTY
63554: LIST
63555: LIST
63556: PPUSH
63557: CALL_OW 72
63561: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63562: LD_ADDR_VAR 0 6
63566: PUSH
63567: LD_EXP 51
63571: PUSH
63572: LD_VAR 0 2
63576: ARRAY
63577: PPUSH
63578: LD_INT 2
63580: PUSH
63581: LD_INT 30
63583: PUSH
63584: LD_INT 32
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: PUSH
63591: LD_INT 30
63593: PUSH
63594: LD_INT 33
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: PUSH
63601: EMPTY
63602: LIST
63603: LIST
63604: LIST
63605: PPUSH
63606: CALL_OW 72
63610: ST_TO_ADDR
// if not t then
63611: LD_VAR 0 6
63615: NOT
63616: IFFALSE 63620
// continue ;
63618: GO 63477
// for j in tmp do
63620: LD_ADDR_VAR 0 3
63624: PUSH
63625: LD_VAR 0 4
63629: PUSH
63630: FOR_IN
63631: IFFALSE 63661
// if not BuildingStatus ( j ) = bs_idle then
63633: LD_VAR 0 3
63637: PPUSH
63638: CALL_OW 461
63642: PUSH
63643: LD_INT 2
63645: EQUAL
63646: NOT
63647: IFFALSE 63659
// begin busy := true ;
63649: LD_ADDR_VAR 0 8
63653: PUSH
63654: LD_INT 1
63656: ST_TO_ADDR
// break ;
63657: GO 63661
// end ;
63659: GO 63630
63661: POP
63662: POP
// if busy then
63663: LD_VAR 0 8
63667: IFFALSE 63671
// continue ;
63669: GO 63477
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63671: LD_ADDR_VAR 0 7
63675: PUSH
63676: LD_VAR 0 6
63680: PPUSH
63681: LD_INT 35
63683: PUSH
63684: LD_INT 0
63686: PUSH
63687: EMPTY
63688: LIST
63689: LIST
63690: PPUSH
63691: CALL_OW 72
63695: ST_TO_ADDR
// if tw then
63696: LD_VAR 0 7
63700: IFFALSE 63777
// begin tw := tw [ 1 ] ;
63702: LD_ADDR_VAR 0 7
63706: PUSH
63707: LD_VAR 0 7
63711: PUSH
63712: LD_INT 1
63714: ARRAY
63715: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63716: LD_ADDR_VAR 0 9
63720: PUSH
63721: LD_VAR 0 7
63725: PPUSH
63726: LD_EXP 68
63730: PUSH
63731: LD_VAR 0 2
63735: ARRAY
63736: PPUSH
63737: CALL 19791 0 2
63741: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63742: LD_EXP 82
63746: PUSH
63747: LD_VAR 0 2
63751: ARRAY
63752: IFFALSE 63775
// if not weapon in mc_allowed_tower_weapons [ i ] then
63754: LD_VAR 0 9
63758: PUSH
63759: LD_EXP 82
63763: PUSH
63764: LD_VAR 0 2
63768: ARRAY
63769: IN
63770: NOT
63771: IFFALSE 63775
// continue ;
63773: GO 63477
// end else
63775: GO 63840
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63777: LD_ADDR_VAR 0 5
63781: PUSH
63782: LD_EXP 51
63786: PUSH
63787: LD_VAR 0 2
63791: ARRAY
63792: PPUSH
63793: LD_VAR 0 4
63797: PPUSH
63798: CALL 46681 0 2
63802: ST_TO_ADDR
// if not tmp2 then
63803: LD_VAR 0 5
63807: NOT
63808: IFFALSE 63812
// continue ;
63810: GO 63477
// tw := tmp2 [ 1 ] ;
63812: LD_ADDR_VAR 0 7
63816: PUSH
63817: LD_VAR 0 5
63821: PUSH
63822: LD_INT 1
63824: ARRAY
63825: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63826: LD_ADDR_VAR 0 9
63830: PUSH
63831: LD_VAR 0 5
63835: PUSH
63836: LD_INT 2
63838: ARRAY
63839: ST_TO_ADDR
// end ; if not weapon then
63840: LD_VAR 0 9
63844: NOT
63845: IFFALSE 63849
// continue ;
63847: GO 63477
// ComPlaceWeapon ( tw , weapon ) ;
63849: LD_VAR 0 7
63853: PPUSH
63854: LD_VAR 0 9
63858: PPUSH
63859: CALL_OW 148
// end ;
63863: GO 63477
63865: POP
63866: POP
// end ;
63867: LD_VAR 0 1
63871: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63872: LD_INT 0
63874: PPUSH
63875: PPUSH
63876: PPUSH
63877: PPUSH
63878: PPUSH
63879: PPUSH
63880: PPUSH
// if not mc_bases then
63881: LD_EXP 43
63885: NOT
63886: IFFALSE 63890
// exit ;
63888: GO 64665
// for i = 1 to mc_bases do
63890: LD_ADDR_VAR 0 2
63894: PUSH
63895: DOUBLE
63896: LD_INT 1
63898: DEC
63899: ST_TO_ADDR
63900: LD_EXP 43
63904: PUSH
63905: FOR_TO
63906: IFFALSE 64663
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63908: LD_EXP 56
63912: PUSH
63913: LD_VAR 0 2
63917: ARRAY
63918: NOT
63919: PUSH
63920: LD_EXP 56
63924: PUSH
63925: LD_VAR 0 2
63929: ARRAY
63930: PUSH
63931: LD_EXP 57
63935: PUSH
63936: LD_VAR 0 2
63940: ARRAY
63941: EQUAL
63942: OR
63943: PUSH
63944: LD_EXP 66
63948: PUSH
63949: LD_VAR 0 2
63953: ARRAY
63954: OR
63955: IFFALSE 63959
// continue ;
63957: GO 63905
// if mc_miners [ i ] then
63959: LD_EXP 57
63963: PUSH
63964: LD_VAR 0 2
63968: ARRAY
63969: IFFALSE 64350
// begin for j = mc_miners [ i ] downto 1 do
63971: LD_ADDR_VAR 0 3
63975: PUSH
63976: DOUBLE
63977: LD_EXP 57
63981: PUSH
63982: LD_VAR 0 2
63986: ARRAY
63987: INC
63988: ST_TO_ADDR
63989: LD_INT 1
63991: PUSH
63992: FOR_DOWNTO
63993: IFFALSE 64348
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63995: LD_EXP 57
63999: PUSH
64000: LD_VAR 0 2
64004: ARRAY
64005: PUSH
64006: LD_VAR 0 3
64010: ARRAY
64011: PPUSH
64012: CALL_OW 301
64016: PUSH
64017: LD_EXP 57
64021: PUSH
64022: LD_VAR 0 2
64026: ARRAY
64027: PUSH
64028: LD_VAR 0 3
64032: ARRAY
64033: PPUSH
64034: CALL_OW 257
64038: PUSH
64039: LD_INT 1
64041: NONEQUAL
64042: OR
64043: IFFALSE 64106
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
64045: LD_ADDR_VAR 0 5
64049: PUSH
64050: LD_EXP 57
64054: PUSH
64055: LD_VAR 0 2
64059: ARRAY
64060: PUSH
64061: LD_EXP 57
64065: PUSH
64066: LD_VAR 0 2
64070: ARRAY
64071: PUSH
64072: LD_VAR 0 3
64076: ARRAY
64077: DIFF
64078: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64079: LD_ADDR_EXP 57
64083: PUSH
64084: LD_EXP 57
64088: PPUSH
64089: LD_VAR 0 2
64093: PPUSH
64094: LD_VAR 0 5
64098: PPUSH
64099: CALL_OW 1
64103: ST_TO_ADDR
// continue ;
64104: GO 63992
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64106: LD_EXP 57
64110: PUSH
64111: LD_VAR 0 2
64115: ARRAY
64116: PUSH
64117: LD_VAR 0 3
64121: ARRAY
64122: PPUSH
64123: CALL_OW 257
64127: PUSH
64128: LD_INT 1
64130: EQUAL
64131: PUSH
64132: LD_EXP 57
64136: PUSH
64137: LD_VAR 0 2
64141: ARRAY
64142: PUSH
64143: LD_VAR 0 3
64147: ARRAY
64148: PPUSH
64149: CALL_OW 459
64153: NOT
64154: AND
64155: PUSH
64156: LD_EXP 57
64160: PUSH
64161: LD_VAR 0 2
64165: ARRAY
64166: PUSH
64167: LD_VAR 0 3
64171: ARRAY
64172: PPUSH
64173: CALL_OW 314
64177: NOT
64178: AND
64179: IFFALSE 64346
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64181: LD_EXP 57
64185: PUSH
64186: LD_VAR 0 2
64190: ARRAY
64191: PUSH
64192: LD_VAR 0 3
64196: ARRAY
64197: PPUSH
64198: CALL_OW 310
64202: IFFALSE 64225
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64204: LD_EXP 57
64208: PUSH
64209: LD_VAR 0 2
64213: ARRAY
64214: PUSH
64215: LD_VAR 0 3
64219: ARRAY
64220: PPUSH
64221: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64225: LD_EXP 57
64229: PUSH
64230: LD_VAR 0 2
64234: ARRAY
64235: PUSH
64236: LD_VAR 0 3
64240: ARRAY
64241: PPUSH
64242: CALL_OW 314
64246: NOT
64247: IFFALSE 64346
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
64249: LD_ADDR_VAR 0 7
64253: PUSH
64254: LD_VAR 0 3
64258: PUSH
64259: LD_EXP 56
64263: PUSH
64264: LD_VAR 0 2
64268: ARRAY
64269: PPUSH
64270: CALL 11914 0 1
64274: MOD
64275: PUSH
64276: LD_INT 1
64278: PLUS
64279: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64280: LD_EXP 57
64284: PUSH
64285: LD_VAR 0 2
64289: ARRAY
64290: PUSH
64291: LD_VAR 0 3
64295: ARRAY
64296: PPUSH
64297: LD_EXP 56
64301: PUSH
64302: LD_VAR 0 2
64306: ARRAY
64307: PUSH
64308: LD_VAR 0 7
64312: ARRAY
64313: PUSH
64314: LD_INT 1
64316: ARRAY
64317: PPUSH
64318: LD_EXP 56
64322: PUSH
64323: LD_VAR 0 2
64327: ARRAY
64328: PUSH
64329: LD_VAR 0 7
64333: ARRAY
64334: PUSH
64335: LD_INT 2
64337: ARRAY
64338: PPUSH
64339: LD_INT 0
64341: PPUSH
64342: CALL_OW 193
// end ; end ; end ;
64346: GO 63992
64348: POP
64349: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64350: LD_ADDR_VAR 0 5
64354: PUSH
64355: LD_EXP 43
64359: PUSH
64360: LD_VAR 0 2
64364: ARRAY
64365: PPUSH
64366: LD_INT 2
64368: PUSH
64369: LD_INT 30
64371: PUSH
64372: LD_INT 4
64374: PUSH
64375: EMPTY
64376: LIST
64377: LIST
64378: PUSH
64379: LD_INT 30
64381: PUSH
64382: LD_INT 5
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 30
64391: PUSH
64392: LD_INT 32
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: EMPTY
64400: LIST
64401: LIST
64402: LIST
64403: LIST
64404: PPUSH
64405: CALL_OW 72
64409: ST_TO_ADDR
// if not tmp then
64410: LD_VAR 0 5
64414: NOT
64415: IFFALSE 64419
// continue ;
64417: GO 63905
// list := [ ] ;
64419: LD_ADDR_VAR 0 6
64423: PUSH
64424: EMPTY
64425: ST_TO_ADDR
// for j in tmp do
64426: LD_ADDR_VAR 0 3
64430: PUSH
64431: LD_VAR 0 5
64435: PUSH
64436: FOR_IN
64437: IFFALSE 64506
// begin for k in UnitsInside ( j ) do
64439: LD_ADDR_VAR 0 4
64443: PUSH
64444: LD_VAR 0 3
64448: PPUSH
64449: CALL_OW 313
64453: PUSH
64454: FOR_IN
64455: IFFALSE 64502
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64457: LD_VAR 0 4
64461: PPUSH
64462: CALL_OW 257
64466: PUSH
64467: LD_INT 1
64469: EQUAL
64470: PUSH
64471: LD_VAR 0 4
64475: PPUSH
64476: CALL_OW 459
64480: NOT
64481: AND
64482: IFFALSE 64500
// list := list ^ k ;
64484: LD_ADDR_VAR 0 6
64488: PUSH
64489: LD_VAR 0 6
64493: PUSH
64494: LD_VAR 0 4
64498: ADD
64499: ST_TO_ADDR
64500: GO 64454
64502: POP
64503: POP
// end ;
64504: GO 64436
64506: POP
64507: POP
// list := list diff mc_miners [ i ] ;
64508: LD_ADDR_VAR 0 6
64512: PUSH
64513: LD_VAR 0 6
64517: PUSH
64518: LD_EXP 57
64522: PUSH
64523: LD_VAR 0 2
64527: ARRAY
64528: DIFF
64529: ST_TO_ADDR
// if not list then
64530: LD_VAR 0 6
64534: NOT
64535: IFFALSE 64539
// continue ;
64537: GO 63905
// k := mc_mines [ i ] - mc_miners [ i ] ;
64539: LD_ADDR_VAR 0 4
64543: PUSH
64544: LD_EXP 56
64548: PUSH
64549: LD_VAR 0 2
64553: ARRAY
64554: PUSH
64555: LD_EXP 57
64559: PUSH
64560: LD_VAR 0 2
64564: ARRAY
64565: MINUS
64566: ST_TO_ADDR
// if k > list then
64567: LD_VAR 0 4
64571: PUSH
64572: LD_VAR 0 6
64576: GREATER
64577: IFFALSE 64589
// k := list ;
64579: LD_ADDR_VAR 0 4
64583: PUSH
64584: LD_VAR 0 6
64588: ST_TO_ADDR
// for j = 1 to k do
64589: LD_ADDR_VAR 0 3
64593: PUSH
64594: DOUBLE
64595: LD_INT 1
64597: DEC
64598: ST_TO_ADDR
64599: LD_VAR 0 4
64603: PUSH
64604: FOR_TO
64605: IFFALSE 64659
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64607: LD_ADDR_EXP 57
64611: PUSH
64612: LD_EXP 57
64616: PPUSH
64617: LD_VAR 0 2
64621: PUSH
64622: LD_EXP 57
64626: PUSH
64627: LD_VAR 0 2
64631: ARRAY
64632: PUSH
64633: LD_INT 1
64635: PLUS
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: PPUSH
64641: LD_VAR 0 6
64645: PUSH
64646: LD_VAR 0 3
64650: ARRAY
64651: PPUSH
64652: CALL 14774 0 3
64656: ST_TO_ADDR
64657: GO 64604
64659: POP
64660: POP
// end ;
64661: GO 63905
64663: POP
64664: POP
// end ;
64665: LD_VAR 0 1
64669: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64670: LD_INT 0
64672: PPUSH
64673: PPUSH
64674: PPUSH
64675: PPUSH
64676: PPUSH
64677: PPUSH
64678: PPUSH
64679: PPUSH
64680: PPUSH
64681: PPUSH
64682: PPUSH
// if not mc_bases then
64683: LD_EXP 43
64687: NOT
64688: IFFALSE 64692
// exit ;
64690: GO 66515
// for i = 1 to mc_bases do
64692: LD_ADDR_VAR 0 2
64696: PUSH
64697: DOUBLE
64698: LD_INT 1
64700: DEC
64701: ST_TO_ADDR
64702: LD_EXP 43
64706: PUSH
64707: FOR_TO
64708: IFFALSE 66513
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64710: LD_EXP 43
64714: PUSH
64715: LD_VAR 0 2
64719: ARRAY
64720: NOT
64721: PUSH
64722: LD_EXP 50
64726: PUSH
64727: LD_VAR 0 2
64731: ARRAY
64732: OR
64733: IFFALSE 64737
// continue ;
64735: GO 64707
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64737: LD_EXP 59
64741: PUSH
64742: LD_VAR 0 2
64746: ARRAY
64747: NOT
64748: PUSH
64749: LD_EXP 60
64753: PUSH
64754: LD_VAR 0 2
64758: ARRAY
64759: AND
64760: IFFALSE 64798
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64762: LD_ADDR_EXP 60
64766: PUSH
64767: LD_EXP 60
64771: PPUSH
64772: LD_VAR 0 2
64776: PPUSH
64777: EMPTY
64778: PPUSH
64779: CALL_OW 1
64783: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64784: LD_VAR 0 2
64788: PPUSH
64789: LD_INT 107
64791: PPUSH
64792: CALL 55524 0 2
// continue ;
64796: GO 64707
// end ; target := [ ] ;
64798: LD_ADDR_VAR 0 7
64802: PUSH
64803: EMPTY
64804: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64805: LD_ADDR_VAR 0 6
64809: PUSH
64810: LD_EXP 43
64814: PUSH
64815: LD_VAR 0 2
64819: ARRAY
64820: PUSH
64821: LD_INT 1
64823: ARRAY
64824: PPUSH
64825: CALL_OW 255
64829: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64830: LD_ADDR_VAR 0 9
64834: PUSH
64835: LD_EXP 43
64839: PUSH
64840: LD_VAR 0 2
64844: ARRAY
64845: PPUSH
64846: LD_INT 2
64848: PUSH
64849: LD_INT 30
64851: PUSH
64852: LD_INT 0
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: PUSH
64859: LD_INT 30
64861: PUSH
64862: LD_INT 1
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: PUSH
64869: EMPTY
64870: LIST
64871: LIST
64872: LIST
64873: PPUSH
64874: CALL_OW 72
64878: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64879: LD_ADDR_VAR 0 3
64883: PUSH
64884: DOUBLE
64885: LD_EXP 59
64889: PUSH
64890: LD_VAR 0 2
64894: ARRAY
64895: INC
64896: ST_TO_ADDR
64897: LD_INT 1
64899: PUSH
64900: FOR_DOWNTO
64901: IFFALSE 65146
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64903: LD_EXP 59
64907: PUSH
64908: LD_VAR 0 2
64912: ARRAY
64913: PUSH
64914: LD_VAR 0 3
64918: ARRAY
64919: PUSH
64920: LD_INT 2
64922: ARRAY
64923: PPUSH
64924: LD_EXP 59
64928: PUSH
64929: LD_VAR 0 2
64933: ARRAY
64934: PUSH
64935: LD_VAR 0 3
64939: ARRAY
64940: PUSH
64941: LD_INT 3
64943: ARRAY
64944: PPUSH
64945: CALL_OW 488
64949: PUSH
64950: LD_EXP 59
64954: PUSH
64955: LD_VAR 0 2
64959: ARRAY
64960: PUSH
64961: LD_VAR 0 3
64965: ARRAY
64966: PUSH
64967: LD_INT 2
64969: ARRAY
64970: PPUSH
64971: LD_EXP 59
64975: PUSH
64976: LD_VAR 0 2
64980: ARRAY
64981: PUSH
64982: LD_VAR 0 3
64986: ARRAY
64987: PUSH
64988: LD_INT 3
64990: ARRAY
64991: PPUSH
64992: CALL_OW 284
64996: PUSH
64997: LD_INT 0
64999: EQUAL
65000: AND
65001: IFFALSE 65056
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65003: LD_ADDR_VAR 0 5
65007: PUSH
65008: LD_EXP 59
65012: PUSH
65013: LD_VAR 0 2
65017: ARRAY
65018: PPUSH
65019: LD_VAR 0 3
65023: PPUSH
65024: CALL_OW 3
65028: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
65029: LD_ADDR_EXP 59
65033: PUSH
65034: LD_EXP 59
65038: PPUSH
65039: LD_VAR 0 2
65043: PPUSH
65044: LD_VAR 0 5
65048: PPUSH
65049: CALL_OW 1
65053: ST_TO_ADDR
// continue ;
65054: GO 64900
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
65056: LD_VAR 0 6
65060: PPUSH
65061: LD_EXP 59
65065: PUSH
65066: LD_VAR 0 2
65070: ARRAY
65071: PUSH
65072: LD_VAR 0 3
65076: ARRAY
65077: PUSH
65078: LD_INT 2
65080: ARRAY
65081: PPUSH
65082: LD_EXP 59
65086: PUSH
65087: LD_VAR 0 2
65091: ARRAY
65092: PUSH
65093: LD_VAR 0 3
65097: ARRAY
65098: PUSH
65099: LD_INT 3
65101: ARRAY
65102: PPUSH
65103: LD_INT 30
65105: PPUSH
65106: CALL 15670 0 4
65110: PUSH
65111: LD_INT 4
65113: ARRAY
65114: PUSH
65115: LD_INT 0
65117: EQUAL
65118: IFFALSE 65144
// begin target := mc_crates [ i ] [ j ] ;
65120: LD_ADDR_VAR 0 7
65124: PUSH
65125: LD_EXP 59
65129: PUSH
65130: LD_VAR 0 2
65134: ARRAY
65135: PUSH
65136: LD_VAR 0 3
65140: ARRAY
65141: ST_TO_ADDR
// break ;
65142: GO 65146
// end ; end ;
65144: GO 64900
65146: POP
65147: POP
// if not target then
65148: LD_VAR 0 7
65152: NOT
65153: IFFALSE 65157
// continue ;
65155: GO 64707
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65157: LD_ADDR_VAR 0 8
65161: PUSH
65162: LD_EXP 62
65166: PUSH
65167: LD_VAR 0 2
65171: ARRAY
65172: PPUSH
65173: LD_INT 2
65175: PUSH
65176: LD_INT 3
65178: PUSH
65179: LD_INT 58
65181: PUSH
65182: EMPTY
65183: LIST
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: PUSH
65189: LD_INT 61
65191: PUSH
65192: EMPTY
65193: LIST
65194: PUSH
65195: LD_INT 33
65197: PUSH
65198: LD_INT 5
65200: PUSH
65201: EMPTY
65202: LIST
65203: LIST
65204: PUSH
65205: LD_INT 33
65207: PUSH
65208: LD_INT 3
65210: PUSH
65211: EMPTY
65212: LIST
65213: LIST
65214: PUSH
65215: EMPTY
65216: LIST
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: PUSH
65222: LD_INT 2
65224: PUSH
65225: LD_INT 34
65227: PUSH
65228: LD_INT 32
65230: PUSH
65231: EMPTY
65232: LIST
65233: LIST
65234: PUSH
65235: LD_INT 34
65237: PUSH
65238: LD_INT 51
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 34
65247: PUSH
65248: LD_INT 12
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: PUSH
65255: EMPTY
65256: LIST
65257: LIST
65258: LIST
65259: LIST
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: PPUSH
65265: CALL_OW 72
65269: ST_TO_ADDR
// if not cargo then
65270: LD_VAR 0 8
65274: NOT
65275: IFFALSE 65981
// begin if mc_crates_collector [ i ] < 5 then
65277: LD_EXP 60
65281: PUSH
65282: LD_VAR 0 2
65286: ARRAY
65287: PUSH
65288: LD_INT 5
65290: LESS
65291: IFFALSE 65657
// begin if mc_ape [ i ] then
65293: LD_EXP 72
65297: PUSH
65298: LD_VAR 0 2
65302: ARRAY
65303: IFFALSE 65350
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65305: LD_ADDR_VAR 0 5
65309: PUSH
65310: LD_EXP 72
65314: PUSH
65315: LD_VAR 0 2
65319: ARRAY
65320: PPUSH
65321: LD_INT 25
65323: PUSH
65324: LD_INT 16
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 24
65333: PUSH
65334: LD_INT 750
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: PUSH
65341: EMPTY
65342: LIST
65343: LIST
65344: PPUSH
65345: CALL_OW 72
65349: ST_TO_ADDR
// if not tmp then
65350: LD_VAR 0 5
65354: NOT
65355: IFFALSE 65402
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65357: LD_ADDR_VAR 0 5
65361: PUSH
65362: LD_EXP 43
65366: PUSH
65367: LD_VAR 0 2
65371: ARRAY
65372: PPUSH
65373: LD_INT 25
65375: PUSH
65376: LD_INT 2
65378: PUSH
65379: EMPTY
65380: LIST
65381: LIST
65382: PUSH
65383: LD_INT 24
65385: PUSH
65386: LD_INT 750
65388: PUSH
65389: EMPTY
65390: LIST
65391: LIST
65392: PUSH
65393: EMPTY
65394: LIST
65395: LIST
65396: PPUSH
65397: CALL_OW 72
65401: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65402: LD_EXP 72
65406: PUSH
65407: LD_VAR 0 2
65411: ARRAY
65412: PUSH
65413: LD_EXP 43
65417: PUSH
65418: LD_VAR 0 2
65422: ARRAY
65423: PPUSH
65424: LD_INT 25
65426: PUSH
65427: LD_INT 2
65429: PUSH
65430: EMPTY
65431: LIST
65432: LIST
65433: PUSH
65434: LD_INT 24
65436: PUSH
65437: LD_INT 750
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: PUSH
65444: EMPTY
65445: LIST
65446: LIST
65447: PPUSH
65448: CALL_OW 72
65452: AND
65453: PUSH
65454: LD_VAR 0 5
65458: PUSH
65459: LD_INT 5
65461: LESS
65462: AND
65463: IFFALSE 65545
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65465: LD_ADDR_VAR 0 3
65469: PUSH
65470: LD_EXP 43
65474: PUSH
65475: LD_VAR 0 2
65479: ARRAY
65480: PPUSH
65481: LD_INT 25
65483: PUSH
65484: LD_INT 2
65486: PUSH
65487: EMPTY
65488: LIST
65489: LIST
65490: PUSH
65491: LD_INT 24
65493: PUSH
65494: LD_INT 750
65496: PUSH
65497: EMPTY
65498: LIST
65499: LIST
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PPUSH
65505: CALL_OW 72
65509: PUSH
65510: FOR_IN
65511: IFFALSE 65543
// begin tmp := tmp union j ;
65513: LD_ADDR_VAR 0 5
65517: PUSH
65518: LD_VAR 0 5
65522: PUSH
65523: LD_VAR 0 3
65527: UNION
65528: ST_TO_ADDR
// if tmp >= 5 then
65529: LD_VAR 0 5
65533: PUSH
65534: LD_INT 5
65536: GREATEREQUAL
65537: IFFALSE 65541
// break ;
65539: GO 65543
// end ;
65541: GO 65510
65543: POP
65544: POP
// end ; if not tmp then
65545: LD_VAR 0 5
65549: NOT
65550: IFFALSE 65554
// continue ;
65552: GO 64707
// for j in tmp do
65554: LD_ADDR_VAR 0 3
65558: PUSH
65559: LD_VAR 0 5
65563: PUSH
65564: FOR_IN
65565: IFFALSE 65655
// if not GetTag ( j ) then
65567: LD_VAR 0 3
65571: PPUSH
65572: CALL_OW 110
65576: NOT
65577: IFFALSE 65653
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65579: LD_ADDR_EXP 60
65583: PUSH
65584: LD_EXP 60
65588: PPUSH
65589: LD_VAR 0 2
65593: PUSH
65594: LD_EXP 60
65598: PUSH
65599: LD_VAR 0 2
65603: ARRAY
65604: PUSH
65605: LD_INT 1
65607: PLUS
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PPUSH
65613: LD_VAR 0 3
65617: PPUSH
65618: CALL 14774 0 3
65622: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65623: LD_VAR 0 3
65627: PPUSH
65628: LD_INT 107
65630: PPUSH
65631: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65635: LD_EXP 60
65639: PUSH
65640: LD_VAR 0 2
65644: ARRAY
65645: PUSH
65646: LD_INT 5
65648: GREATEREQUAL
65649: IFFALSE 65653
// break ;
65651: GO 65655
// end ;
65653: GO 65564
65655: POP
65656: POP
// end ; if mc_crates_collector [ i ] and target then
65657: LD_EXP 60
65661: PUSH
65662: LD_VAR 0 2
65666: ARRAY
65667: PUSH
65668: LD_VAR 0 7
65672: AND
65673: IFFALSE 65979
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65675: LD_EXP 60
65679: PUSH
65680: LD_VAR 0 2
65684: ARRAY
65685: PUSH
65686: LD_VAR 0 7
65690: PUSH
65691: LD_INT 1
65693: ARRAY
65694: LESS
65695: IFFALSE 65715
// tmp := mc_crates_collector [ i ] else
65697: LD_ADDR_VAR 0 5
65701: PUSH
65702: LD_EXP 60
65706: PUSH
65707: LD_VAR 0 2
65711: ARRAY
65712: ST_TO_ADDR
65713: GO 65729
// tmp := target [ 1 ] ;
65715: LD_ADDR_VAR 0 5
65719: PUSH
65720: LD_VAR 0 7
65724: PUSH
65725: LD_INT 1
65727: ARRAY
65728: ST_TO_ADDR
// k := 0 ;
65729: LD_ADDR_VAR 0 4
65733: PUSH
65734: LD_INT 0
65736: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65737: LD_ADDR_VAR 0 3
65741: PUSH
65742: LD_EXP 60
65746: PUSH
65747: LD_VAR 0 2
65751: ARRAY
65752: PUSH
65753: FOR_IN
65754: IFFALSE 65977
// begin k := k + 1 ;
65756: LD_ADDR_VAR 0 4
65760: PUSH
65761: LD_VAR 0 4
65765: PUSH
65766: LD_INT 1
65768: PLUS
65769: ST_TO_ADDR
// if k > tmp then
65770: LD_VAR 0 4
65774: PUSH
65775: LD_VAR 0 5
65779: GREATER
65780: IFFALSE 65784
// break ;
65782: GO 65977
// if not GetClass ( j ) in [ 2 , 16 ] then
65784: LD_VAR 0 3
65788: PPUSH
65789: CALL_OW 257
65793: PUSH
65794: LD_INT 2
65796: PUSH
65797: LD_INT 16
65799: PUSH
65800: EMPTY
65801: LIST
65802: LIST
65803: IN
65804: NOT
65805: IFFALSE 65858
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65807: LD_ADDR_EXP 60
65811: PUSH
65812: LD_EXP 60
65816: PPUSH
65817: LD_VAR 0 2
65821: PPUSH
65822: LD_EXP 60
65826: PUSH
65827: LD_VAR 0 2
65831: ARRAY
65832: PUSH
65833: LD_VAR 0 3
65837: DIFF
65838: PPUSH
65839: CALL_OW 1
65843: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65844: LD_VAR 0 3
65848: PPUSH
65849: LD_INT 0
65851: PPUSH
65852: CALL_OW 109
// continue ;
65856: GO 65753
// end ; if IsInUnit ( j ) then
65858: LD_VAR 0 3
65862: PPUSH
65863: CALL_OW 310
65867: IFFALSE 65878
// ComExitBuilding ( j ) ;
65869: LD_VAR 0 3
65873: PPUSH
65874: CALL_OW 122
// wait ( 3 ) ;
65878: LD_INT 3
65880: PPUSH
65881: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65885: LD_VAR 0 3
65889: PPUSH
65890: CALL_OW 314
65894: PUSH
65895: LD_VAR 0 6
65899: PPUSH
65900: LD_VAR 0 7
65904: PUSH
65905: LD_INT 2
65907: ARRAY
65908: PPUSH
65909: LD_VAR 0 7
65913: PUSH
65914: LD_INT 3
65916: ARRAY
65917: PPUSH
65918: LD_INT 30
65920: PPUSH
65921: CALL 15670 0 4
65925: PUSH
65926: LD_INT 4
65928: ARRAY
65929: AND
65930: IFFALSE 65948
// ComStandNearbyBuilding ( j , depot ) else
65932: LD_VAR 0 3
65936: PPUSH
65937: LD_VAR 0 9
65941: PPUSH
65942: CALL 11376 0 2
65946: GO 65975
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65948: LD_VAR 0 3
65952: PPUSH
65953: LD_VAR 0 7
65957: PUSH
65958: LD_INT 2
65960: ARRAY
65961: PPUSH
65962: LD_VAR 0 7
65966: PUSH
65967: LD_INT 3
65969: ARRAY
65970: PPUSH
65971: CALL_OW 117
// end ;
65975: GO 65753
65977: POP
65978: POP
// end ; end else
65979: GO 66511
// begin for j in cargo do
65981: LD_ADDR_VAR 0 3
65985: PUSH
65986: LD_VAR 0 8
65990: PUSH
65991: FOR_IN
65992: IFFALSE 66509
// begin if GetTag ( j ) <> 0 then
65994: LD_VAR 0 3
65998: PPUSH
65999: CALL_OW 110
66003: PUSH
66004: LD_INT 0
66006: NONEQUAL
66007: IFFALSE 66011
// continue ;
66009: GO 65991
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66011: LD_VAR 0 3
66015: PPUSH
66016: CALL_OW 256
66020: PUSH
66021: LD_INT 1000
66023: LESS
66024: PUSH
66025: LD_VAR 0 3
66029: PPUSH
66030: LD_EXP 67
66034: PUSH
66035: LD_VAR 0 2
66039: ARRAY
66040: PPUSH
66041: CALL_OW 308
66045: NOT
66046: AND
66047: IFFALSE 66069
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66049: LD_VAR 0 3
66053: PPUSH
66054: LD_EXP 67
66058: PUSH
66059: LD_VAR 0 2
66063: ARRAY
66064: PPUSH
66065: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
66069: LD_VAR 0 3
66073: PPUSH
66074: CALL_OW 256
66078: PUSH
66079: LD_INT 1000
66081: LESS
66082: PUSH
66083: LD_VAR 0 3
66087: PPUSH
66088: LD_EXP 67
66092: PUSH
66093: LD_VAR 0 2
66097: ARRAY
66098: PPUSH
66099: CALL_OW 308
66103: AND
66104: IFFALSE 66108
// continue ;
66106: GO 65991
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66108: LD_VAR 0 3
66112: PPUSH
66113: CALL_OW 262
66117: PUSH
66118: LD_INT 2
66120: EQUAL
66121: PUSH
66122: LD_VAR 0 3
66126: PPUSH
66127: CALL_OW 261
66131: PUSH
66132: LD_INT 15
66134: LESS
66135: AND
66136: IFFALSE 66140
// continue ;
66138: GO 65991
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66140: LD_VAR 0 3
66144: PPUSH
66145: CALL_OW 262
66149: PUSH
66150: LD_INT 1
66152: EQUAL
66153: PUSH
66154: LD_VAR 0 3
66158: PPUSH
66159: CALL_OW 261
66163: PUSH
66164: LD_INT 10
66166: LESS
66167: AND
66168: IFFALSE 66448
// begin if not depot then
66170: LD_VAR 0 9
66174: NOT
66175: IFFALSE 66179
// continue ;
66177: GO 65991
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66179: LD_VAR 0 3
66183: PPUSH
66184: LD_VAR 0 9
66188: PPUSH
66189: LD_VAR 0 3
66193: PPUSH
66194: CALL_OW 74
66198: PPUSH
66199: CALL_OW 296
66203: PUSH
66204: LD_INT 6
66206: LESS
66207: IFFALSE 66223
// SetFuel ( j , 100 ) else
66209: LD_VAR 0 3
66213: PPUSH
66214: LD_INT 100
66216: PPUSH
66217: CALL_OW 240
66221: GO 66448
// if GetFuel ( j ) = 0 then
66223: LD_VAR 0 3
66227: PPUSH
66228: CALL_OW 261
66232: PUSH
66233: LD_INT 0
66235: EQUAL
66236: IFFALSE 66448
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66238: LD_ADDR_EXP 62
66242: PUSH
66243: LD_EXP 62
66247: PPUSH
66248: LD_VAR 0 2
66252: PPUSH
66253: LD_EXP 62
66257: PUSH
66258: LD_VAR 0 2
66262: ARRAY
66263: PUSH
66264: LD_VAR 0 3
66268: DIFF
66269: PPUSH
66270: CALL_OW 1
66274: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66275: LD_VAR 0 3
66279: PPUSH
66280: CALL_OW 263
66284: PUSH
66285: LD_INT 1
66287: EQUAL
66288: IFFALSE 66304
// ComExitVehicle ( IsInUnit ( j ) ) ;
66290: LD_VAR 0 3
66294: PPUSH
66295: CALL_OW 310
66299: PPUSH
66300: CALL_OW 121
// if GetControl ( j ) = control_remote then
66304: LD_VAR 0 3
66308: PPUSH
66309: CALL_OW 263
66313: PUSH
66314: LD_INT 2
66316: EQUAL
66317: IFFALSE 66328
// ComUnlink ( j ) ;
66319: LD_VAR 0 3
66323: PPUSH
66324: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66328: LD_ADDR_VAR 0 10
66332: PUSH
66333: LD_VAR 0 2
66337: PPUSH
66338: LD_INT 3
66340: PPUSH
66341: CALL 76092 0 2
66345: ST_TO_ADDR
// if fac then
66346: LD_VAR 0 10
66350: IFFALSE 66446
// begin for k in fac do
66352: LD_ADDR_VAR 0 4
66356: PUSH
66357: LD_VAR 0 10
66361: PUSH
66362: FOR_IN
66363: IFFALSE 66444
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66365: LD_ADDR_VAR 0 11
66369: PUSH
66370: LD_VAR 0 10
66374: PPUSH
66375: LD_VAR 0 3
66379: PPUSH
66380: CALL_OW 265
66384: PPUSH
66385: LD_VAR 0 3
66389: PPUSH
66390: CALL_OW 262
66394: PPUSH
66395: LD_VAR 0 3
66399: PPUSH
66400: CALL_OW 263
66404: PPUSH
66405: LD_VAR 0 3
66409: PPUSH
66410: CALL_OW 264
66414: PPUSH
66415: CALL 12272 0 5
66419: ST_TO_ADDR
// if components then
66420: LD_VAR 0 11
66424: IFFALSE 66442
// begin MC_InsertProduceList ( i , components ) ;
66426: LD_VAR 0 2
66430: PPUSH
66431: LD_VAR 0 11
66435: PPUSH
66436: CALL 75637 0 2
// break ;
66440: GO 66444
// end ; end ;
66442: GO 66362
66444: POP
66445: POP
// end ; continue ;
66446: GO 65991
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66448: LD_VAR 0 3
66452: PPUSH
66453: LD_INT 1
66455: PPUSH
66456: CALL_OW 289
66460: PUSH
66461: LD_INT 100
66463: LESS
66464: PUSH
66465: LD_VAR 0 3
66469: PPUSH
66470: CALL_OW 314
66474: NOT
66475: AND
66476: IFFALSE 66505
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66478: LD_VAR 0 3
66482: PPUSH
66483: LD_VAR 0 7
66487: PUSH
66488: LD_INT 2
66490: ARRAY
66491: PPUSH
66492: LD_VAR 0 7
66496: PUSH
66497: LD_INT 3
66499: ARRAY
66500: PPUSH
66501: CALL_OW 117
// break ;
66505: GO 66509
// end ;
66507: GO 65991
66509: POP
66510: POP
// end ; end ;
66511: GO 64707
66513: POP
66514: POP
// end ;
66515: LD_VAR 0 1
66519: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66520: LD_INT 0
66522: PPUSH
66523: PPUSH
66524: PPUSH
66525: PPUSH
// if not mc_bases then
66526: LD_EXP 43
66530: NOT
66531: IFFALSE 66535
// exit ;
66533: GO 66696
// for i = 1 to mc_bases do
66535: LD_ADDR_VAR 0 2
66539: PUSH
66540: DOUBLE
66541: LD_INT 1
66543: DEC
66544: ST_TO_ADDR
66545: LD_EXP 43
66549: PUSH
66550: FOR_TO
66551: IFFALSE 66694
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66553: LD_ADDR_VAR 0 4
66557: PUSH
66558: LD_EXP 62
66562: PUSH
66563: LD_VAR 0 2
66567: ARRAY
66568: PUSH
66569: LD_EXP 65
66573: PUSH
66574: LD_VAR 0 2
66578: ARRAY
66579: UNION
66580: PPUSH
66581: LD_INT 33
66583: PUSH
66584: LD_INT 2
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PPUSH
66591: CALL_OW 72
66595: ST_TO_ADDR
// if tmp then
66596: LD_VAR 0 4
66600: IFFALSE 66692
// for j in tmp do
66602: LD_ADDR_VAR 0 3
66606: PUSH
66607: LD_VAR 0 4
66611: PUSH
66612: FOR_IN
66613: IFFALSE 66690
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66615: LD_VAR 0 3
66619: PPUSH
66620: CALL_OW 312
66624: NOT
66625: PUSH
66626: LD_VAR 0 3
66630: PPUSH
66631: CALL_OW 256
66635: PUSH
66636: LD_INT 250
66638: GREATEREQUAL
66639: AND
66640: IFFALSE 66653
// Connect ( j ) else
66642: LD_VAR 0 3
66646: PPUSH
66647: CALL 17752 0 1
66651: GO 66688
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66653: LD_VAR 0 3
66657: PPUSH
66658: CALL_OW 256
66662: PUSH
66663: LD_INT 250
66665: LESS
66666: PUSH
66667: LD_VAR 0 3
66671: PPUSH
66672: CALL_OW 312
66676: AND
66677: IFFALSE 66688
// ComUnlink ( j ) ;
66679: LD_VAR 0 3
66683: PPUSH
66684: CALL_OW 136
66688: GO 66612
66690: POP
66691: POP
// end ;
66692: GO 66550
66694: POP
66695: POP
// end ;
66696: LD_VAR 0 1
66700: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66701: LD_INT 0
66703: PPUSH
66704: PPUSH
66705: PPUSH
66706: PPUSH
66707: PPUSH
// if not mc_bases then
66708: LD_EXP 43
66712: NOT
66713: IFFALSE 66717
// exit ;
66715: GO 67162
// for i = 1 to mc_bases do
66717: LD_ADDR_VAR 0 2
66721: PUSH
66722: DOUBLE
66723: LD_INT 1
66725: DEC
66726: ST_TO_ADDR
66727: LD_EXP 43
66731: PUSH
66732: FOR_TO
66733: IFFALSE 67160
// begin if not mc_produce [ i ] then
66735: LD_EXP 64
66739: PUSH
66740: LD_VAR 0 2
66744: ARRAY
66745: NOT
66746: IFFALSE 66750
// continue ;
66748: GO 66732
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66750: LD_ADDR_VAR 0 5
66754: PUSH
66755: LD_EXP 43
66759: PUSH
66760: LD_VAR 0 2
66764: ARRAY
66765: PPUSH
66766: LD_INT 30
66768: PUSH
66769: LD_INT 3
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PPUSH
66776: CALL_OW 72
66780: ST_TO_ADDR
// if not fac then
66781: LD_VAR 0 5
66785: NOT
66786: IFFALSE 66790
// continue ;
66788: GO 66732
// for j in fac do
66790: LD_ADDR_VAR 0 3
66794: PUSH
66795: LD_VAR 0 5
66799: PUSH
66800: FOR_IN
66801: IFFALSE 67156
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66803: LD_VAR 0 3
66807: PPUSH
66808: CALL_OW 461
66812: PUSH
66813: LD_INT 2
66815: NONEQUAL
66816: PUSH
66817: LD_VAR 0 3
66821: PPUSH
66822: LD_INT 15
66824: PPUSH
66825: CALL 17371 0 2
66829: PUSH
66830: LD_INT 4
66832: ARRAY
66833: OR
66834: IFFALSE 66838
// continue ;
66836: GO 66800
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66838: LD_VAR 0 3
66842: PPUSH
66843: LD_EXP 64
66847: PUSH
66848: LD_VAR 0 2
66852: ARRAY
66853: PUSH
66854: LD_INT 1
66856: ARRAY
66857: PUSH
66858: LD_INT 1
66860: ARRAY
66861: PPUSH
66862: LD_EXP 64
66866: PUSH
66867: LD_VAR 0 2
66871: ARRAY
66872: PUSH
66873: LD_INT 1
66875: ARRAY
66876: PUSH
66877: LD_INT 2
66879: ARRAY
66880: PPUSH
66881: LD_EXP 64
66885: PUSH
66886: LD_VAR 0 2
66890: ARRAY
66891: PUSH
66892: LD_INT 1
66894: ARRAY
66895: PUSH
66896: LD_INT 3
66898: ARRAY
66899: PPUSH
66900: LD_EXP 64
66904: PUSH
66905: LD_VAR 0 2
66909: ARRAY
66910: PUSH
66911: LD_INT 1
66913: ARRAY
66914: PUSH
66915: LD_INT 4
66917: ARRAY
66918: PPUSH
66919: CALL_OW 448
66923: PUSH
66924: LD_VAR 0 3
66928: PPUSH
66929: LD_EXP 64
66933: PUSH
66934: LD_VAR 0 2
66938: ARRAY
66939: PUSH
66940: LD_INT 1
66942: ARRAY
66943: PUSH
66944: LD_INT 1
66946: ARRAY
66947: PUSH
66948: LD_EXP 64
66952: PUSH
66953: LD_VAR 0 2
66957: ARRAY
66958: PUSH
66959: LD_INT 1
66961: ARRAY
66962: PUSH
66963: LD_INT 2
66965: ARRAY
66966: PUSH
66967: LD_EXP 64
66971: PUSH
66972: LD_VAR 0 2
66976: ARRAY
66977: PUSH
66978: LD_INT 1
66980: ARRAY
66981: PUSH
66982: LD_INT 3
66984: ARRAY
66985: PUSH
66986: LD_EXP 64
66990: PUSH
66991: LD_VAR 0 2
66995: ARRAY
66996: PUSH
66997: LD_INT 1
66999: ARRAY
67000: PUSH
67001: LD_INT 4
67003: ARRAY
67004: PUSH
67005: EMPTY
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: PPUSH
67011: CALL 21147 0 2
67015: AND
67016: IFFALSE 67154
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
67018: LD_VAR 0 3
67022: PPUSH
67023: LD_EXP 64
67027: PUSH
67028: LD_VAR 0 2
67032: ARRAY
67033: PUSH
67034: LD_INT 1
67036: ARRAY
67037: PUSH
67038: LD_INT 1
67040: ARRAY
67041: PPUSH
67042: LD_EXP 64
67046: PUSH
67047: LD_VAR 0 2
67051: ARRAY
67052: PUSH
67053: LD_INT 1
67055: ARRAY
67056: PUSH
67057: LD_INT 2
67059: ARRAY
67060: PPUSH
67061: LD_EXP 64
67065: PUSH
67066: LD_VAR 0 2
67070: ARRAY
67071: PUSH
67072: LD_INT 1
67074: ARRAY
67075: PUSH
67076: LD_INT 3
67078: ARRAY
67079: PPUSH
67080: LD_EXP 64
67084: PUSH
67085: LD_VAR 0 2
67089: ARRAY
67090: PUSH
67091: LD_INT 1
67093: ARRAY
67094: PUSH
67095: LD_INT 4
67097: ARRAY
67098: PPUSH
67099: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
67103: LD_ADDR_VAR 0 4
67107: PUSH
67108: LD_EXP 64
67112: PUSH
67113: LD_VAR 0 2
67117: ARRAY
67118: PPUSH
67119: LD_INT 1
67121: PPUSH
67122: CALL_OW 3
67126: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67127: LD_ADDR_EXP 64
67131: PUSH
67132: LD_EXP 64
67136: PPUSH
67137: LD_VAR 0 2
67141: PPUSH
67142: LD_VAR 0 4
67146: PPUSH
67147: CALL_OW 1
67151: ST_TO_ADDR
// break ;
67152: GO 67156
// end ; end ;
67154: GO 66800
67156: POP
67157: POP
// end ;
67158: GO 66732
67160: POP
67161: POP
// end ;
67162: LD_VAR 0 1
67166: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67167: LD_INT 0
67169: PPUSH
67170: PPUSH
67171: PPUSH
// if not mc_bases then
67172: LD_EXP 43
67176: NOT
67177: IFFALSE 67181
// exit ;
67179: GO 67270
// for i = 1 to mc_bases do
67181: LD_ADDR_VAR 0 2
67185: PUSH
67186: DOUBLE
67187: LD_INT 1
67189: DEC
67190: ST_TO_ADDR
67191: LD_EXP 43
67195: PUSH
67196: FOR_TO
67197: IFFALSE 67268
// begin if mc_attack [ i ] then
67199: LD_EXP 63
67203: PUSH
67204: LD_VAR 0 2
67208: ARRAY
67209: IFFALSE 67266
// begin tmp := mc_attack [ i ] [ 1 ] ;
67211: LD_ADDR_VAR 0 3
67215: PUSH
67216: LD_EXP 63
67220: PUSH
67221: LD_VAR 0 2
67225: ARRAY
67226: PUSH
67227: LD_INT 1
67229: ARRAY
67230: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67231: LD_ADDR_EXP 63
67235: PUSH
67236: LD_EXP 63
67240: PPUSH
67241: LD_VAR 0 2
67245: PPUSH
67246: EMPTY
67247: PPUSH
67248: CALL_OW 1
67252: ST_TO_ADDR
// Attack ( tmp ) ;
67253: LD_VAR 0 3
67257: PPUSH
67258: CALL 82063 0 1
// exit ;
67262: POP
67263: POP
67264: GO 67270
// end ; end ;
67266: GO 67196
67268: POP
67269: POP
// end ;
67270: LD_VAR 0 1
67274: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67275: LD_INT 0
67277: PPUSH
67278: PPUSH
67279: PPUSH
67280: PPUSH
67281: PPUSH
67282: PPUSH
67283: PPUSH
// if not mc_bases then
67284: LD_EXP 43
67288: NOT
67289: IFFALSE 67293
// exit ;
67291: GO 68150
// for i = 1 to mc_bases do
67293: LD_ADDR_VAR 0 2
67297: PUSH
67298: DOUBLE
67299: LD_INT 1
67301: DEC
67302: ST_TO_ADDR
67303: LD_EXP 43
67307: PUSH
67308: FOR_TO
67309: IFFALSE 68148
// begin if not mc_bases [ i ] then
67311: LD_EXP 43
67315: PUSH
67316: LD_VAR 0 2
67320: ARRAY
67321: NOT
67322: IFFALSE 67326
// continue ;
67324: GO 67308
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67326: LD_ADDR_VAR 0 7
67330: PUSH
67331: LD_EXP 43
67335: PUSH
67336: LD_VAR 0 2
67340: ARRAY
67341: PUSH
67342: LD_INT 1
67344: ARRAY
67345: PPUSH
67346: CALL 11598 0 1
67350: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67351: LD_ADDR_EXP 66
67355: PUSH
67356: LD_EXP 66
67360: PPUSH
67361: LD_VAR 0 2
67365: PPUSH
67366: LD_EXP 43
67370: PUSH
67371: LD_VAR 0 2
67375: ARRAY
67376: PUSH
67377: LD_INT 1
67379: ARRAY
67380: PPUSH
67381: CALL_OW 255
67385: PPUSH
67386: LD_EXP 68
67390: PUSH
67391: LD_VAR 0 2
67395: ARRAY
67396: PPUSH
67397: CALL 11563 0 2
67401: PPUSH
67402: CALL_OW 1
67406: ST_TO_ADDR
// if not mc_scan [ i ] then
67407: LD_EXP 66
67411: PUSH
67412: LD_VAR 0 2
67416: ARRAY
67417: NOT
67418: IFFALSE 67596
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
67420: LD_ADDR_EXP 86
67424: PUSH
67425: LD_EXP 86
67429: PPUSH
67430: LD_VAR 0 2
67434: PPUSH
67435: LD_INT 0
67437: PPUSH
67438: CALL_OW 1
67442: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67443: LD_ADDR_VAR 0 4
67447: PUSH
67448: LD_EXP 43
67452: PUSH
67453: LD_VAR 0 2
67457: ARRAY
67458: PPUSH
67459: LD_INT 2
67461: PUSH
67462: LD_INT 25
67464: PUSH
67465: LD_INT 5
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: PUSH
67472: LD_INT 25
67474: PUSH
67475: LD_INT 8
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 25
67484: PUSH
67485: LD_INT 9
67487: PUSH
67488: EMPTY
67489: LIST
67490: LIST
67491: PUSH
67492: EMPTY
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: PPUSH
67498: CALL_OW 72
67502: ST_TO_ADDR
// if not tmp then
67503: LD_VAR 0 4
67507: NOT
67508: IFFALSE 67512
// continue ;
67510: GO 67308
// for j in tmp do
67512: LD_ADDR_VAR 0 3
67516: PUSH
67517: LD_VAR 0 4
67521: PUSH
67522: FOR_IN
67523: IFFALSE 67594
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67525: LD_VAR 0 3
67529: PPUSH
67530: CALL_OW 310
67534: PPUSH
67535: CALL_OW 266
67539: PUSH
67540: LD_INT 5
67542: EQUAL
67543: PUSH
67544: LD_VAR 0 3
67548: PPUSH
67549: CALL_OW 257
67553: PUSH
67554: LD_INT 1
67556: EQUAL
67557: AND
67558: PUSH
67559: LD_VAR 0 3
67563: PPUSH
67564: CALL_OW 459
67568: NOT
67569: AND
67570: PUSH
67571: LD_VAR 0 7
67575: AND
67576: IFFALSE 67592
// ComChangeProfession ( j , class ) ;
67578: LD_VAR 0 3
67582: PPUSH
67583: LD_VAR 0 7
67587: PPUSH
67588: CALL_OW 123
67592: GO 67522
67594: POP
67595: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67596: LD_EXP 66
67600: PUSH
67601: LD_VAR 0 2
67605: ARRAY
67606: PUSH
67607: LD_EXP 86
67611: PUSH
67612: LD_VAR 0 2
67616: ARRAY
67617: NOT
67618: AND
67619: PUSH
67620: LD_EXP 65
67624: PUSH
67625: LD_VAR 0 2
67629: ARRAY
67630: NOT
67631: AND
67632: PUSH
67633: LD_EXP 43
67637: PUSH
67638: LD_VAR 0 2
67642: ARRAY
67643: PPUSH
67644: LD_INT 50
67646: PUSH
67647: EMPTY
67648: LIST
67649: PUSH
67650: LD_INT 2
67652: PUSH
67653: LD_INT 30
67655: PUSH
67656: LD_INT 32
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: PUSH
67663: LD_INT 30
67665: PUSH
67666: LD_INT 33
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 30
67675: PUSH
67676: LD_INT 4
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 30
67685: PUSH
67686: LD_INT 5
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: PUSH
67700: EMPTY
67701: LIST
67702: LIST
67703: PPUSH
67704: CALL_OW 72
67708: PUSH
67709: LD_INT 4
67711: LESS
67712: PUSH
67713: LD_EXP 43
67717: PUSH
67718: LD_VAR 0 2
67722: ARRAY
67723: PPUSH
67724: LD_INT 3
67726: PUSH
67727: LD_INT 24
67729: PUSH
67730: LD_INT 1000
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 2
67743: PUSH
67744: LD_INT 30
67746: PUSH
67747: LD_INT 0
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 30
67756: PUSH
67757: LD_INT 1
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: LIST
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: PPUSH
67773: CALL_OW 72
67777: OR
67778: AND
67779: IFFALSE 68030
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67781: LD_ADDR_EXP 86
67785: PUSH
67786: LD_EXP 86
67790: PPUSH
67791: LD_VAR 0 2
67795: PPUSH
67796: LD_INT 1
67798: PPUSH
67799: CALL_OW 1
67803: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67804: LD_ADDR_VAR 0 4
67808: PUSH
67809: LD_EXP 43
67813: PUSH
67814: LD_VAR 0 2
67818: ARRAY
67819: PPUSH
67820: LD_INT 2
67822: PUSH
67823: LD_INT 25
67825: PUSH
67826: LD_INT 1
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: PUSH
67833: LD_INT 25
67835: PUSH
67836: LD_INT 5
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 25
67845: PUSH
67846: LD_INT 8
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 25
67855: PUSH
67856: LD_INT 9
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: PPUSH
67870: CALL_OW 72
67874: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67875: LD_ADDR_VAR 0 4
67879: PUSH
67880: LD_VAR 0 4
67884: PUSH
67885: LD_VAR 0 4
67889: PPUSH
67890: LD_INT 18
67892: PPUSH
67893: CALL 44715 0 2
67897: DIFF
67898: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67899: LD_VAR 0 4
67903: NOT
67904: PUSH
67905: LD_EXP 43
67909: PUSH
67910: LD_VAR 0 2
67914: ARRAY
67915: PPUSH
67916: LD_INT 2
67918: PUSH
67919: LD_INT 30
67921: PUSH
67922: LD_INT 4
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: LD_INT 30
67931: PUSH
67932: LD_INT 5
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: LIST
67943: PPUSH
67944: CALL_OW 72
67948: NOT
67949: AND
67950: IFFALSE 68012
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67952: LD_ADDR_VAR 0 4
67956: PUSH
67957: LD_EXP 43
67961: PUSH
67962: LD_VAR 0 2
67966: ARRAY
67967: PPUSH
67968: LD_INT 2
67970: PUSH
67971: LD_INT 25
67973: PUSH
67974: LD_INT 2
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 25
67983: PUSH
67984: LD_INT 3
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 25
67993: PUSH
67994: LD_INT 4
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: LIST
68005: LIST
68006: PPUSH
68007: CALL_OW 72
68011: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
68012: LD_VAR 0 2
68016: PPUSH
68017: LD_VAR 0 4
68021: PPUSH
68022: CALL 86772 0 2
// exit ;
68026: POP
68027: POP
68028: GO 68150
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
68030: LD_EXP 66
68034: PUSH
68035: LD_VAR 0 2
68039: ARRAY
68040: PUSH
68041: LD_EXP 86
68045: PUSH
68046: LD_VAR 0 2
68050: ARRAY
68051: NOT
68052: AND
68053: PUSH
68054: LD_EXP 65
68058: PUSH
68059: LD_VAR 0 2
68063: ARRAY
68064: AND
68065: IFFALSE 68146
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68067: LD_ADDR_EXP 86
68071: PUSH
68072: LD_EXP 86
68076: PPUSH
68077: LD_VAR 0 2
68081: PPUSH
68082: LD_INT 1
68084: PPUSH
68085: CALL_OW 1
68089: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
68090: LD_ADDR_VAR 0 4
68094: PUSH
68095: LD_EXP 65
68099: PUSH
68100: LD_VAR 0 2
68104: ARRAY
68105: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68106: LD_ADDR_EXP 65
68110: PUSH
68111: LD_EXP 65
68115: PPUSH
68116: LD_VAR 0 2
68120: PPUSH
68121: EMPTY
68122: PPUSH
68123: CALL_OW 1
68127: ST_TO_ADDR
// Defend ( i , tmp ) ;
68128: LD_VAR 0 2
68132: PPUSH
68133: LD_VAR 0 4
68137: PPUSH
68138: CALL 87368 0 2
// exit ;
68142: POP
68143: POP
68144: GO 68150
// end ; end ;
68146: GO 67308
68148: POP
68149: POP
// end ;
68150: LD_VAR 0 1
68154: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68155: LD_INT 0
68157: PPUSH
68158: PPUSH
68159: PPUSH
68160: PPUSH
68161: PPUSH
68162: PPUSH
68163: PPUSH
68164: PPUSH
68165: PPUSH
68166: PPUSH
68167: PPUSH
// if not mc_bases then
68168: LD_EXP 43
68172: NOT
68173: IFFALSE 68177
// exit ;
68175: GO 69264
// for i = 1 to mc_bases do
68177: LD_ADDR_VAR 0 2
68181: PUSH
68182: DOUBLE
68183: LD_INT 1
68185: DEC
68186: ST_TO_ADDR
68187: LD_EXP 43
68191: PUSH
68192: FOR_TO
68193: IFFALSE 69262
// begin tmp := mc_lab [ i ] ;
68195: LD_ADDR_VAR 0 6
68199: PUSH
68200: LD_EXP 76
68204: PUSH
68205: LD_VAR 0 2
68209: ARRAY
68210: ST_TO_ADDR
// if not tmp then
68211: LD_VAR 0 6
68215: NOT
68216: IFFALSE 68220
// continue ;
68218: GO 68192
// idle_lab := 0 ;
68220: LD_ADDR_VAR 0 11
68224: PUSH
68225: LD_INT 0
68227: ST_TO_ADDR
// for j in tmp do
68228: LD_ADDR_VAR 0 3
68232: PUSH
68233: LD_VAR 0 6
68237: PUSH
68238: FOR_IN
68239: IFFALSE 69258
// begin researching := false ;
68241: LD_ADDR_VAR 0 10
68245: PUSH
68246: LD_INT 0
68248: ST_TO_ADDR
// side := GetSide ( j ) ;
68249: LD_ADDR_VAR 0 4
68253: PUSH
68254: LD_VAR 0 3
68258: PPUSH
68259: CALL_OW 255
68263: ST_TO_ADDR
// if not mc_tech [ side ] then
68264: LD_EXP 70
68268: PUSH
68269: LD_VAR 0 4
68273: ARRAY
68274: NOT
68275: IFFALSE 68279
// continue ;
68277: GO 68238
// if BuildingStatus ( j ) = bs_idle then
68279: LD_VAR 0 3
68283: PPUSH
68284: CALL_OW 461
68288: PUSH
68289: LD_INT 2
68291: EQUAL
68292: IFFALSE 68480
// begin if idle_lab and UnitsInside ( j ) < 6 then
68294: LD_VAR 0 11
68298: PUSH
68299: LD_VAR 0 3
68303: PPUSH
68304: CALL_OW 313
68308: PUSH
68309: LD_INT 6
68311: LESS
68312: AND
68313: IFFALSE 68384
// begin tmp2 := UnitsInside ( idle_lab ) ;
68315: LD_ADDR_VAR 0 9
68319: PUSH
68320: LD_VAR 0 11
68324: PPUSH
68325: CALL_OW 313
68329: ST_TO_ADDR
// if tmp2 then
68330: LD_VAR 0 9
68334: IFFALSE 68376
// for x in tmp2 do
68336: LD_ADDR_VAR 0 7
68340: PUSH
68341: LD_VAR 0 9
68345: PUSH
68346: FOR_IN
68347: IFFALSE 68374
// begin ComExitBuilding ( x ) ;
68349: LD_VAR 0 7
68353: PPUSH
68354: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68358: LD_VAR 0 7
68362: PPUSH
68363: LD_VAR 0 3
68367: PPUSH
68368: CALL_OW 180
// end ;
68372: GO 68346
68374: POP
68375: POP
// idle_lab := 0 ;
68376: LD_ADDR_VAR 0 11
68380: PUSH
68381: LD_INT 0
68383: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68384: LD_ADDR_VAR 0 5
68388: PUSH
68389: LD_EXP 70
68393: PUSH
68394: LD_VAR 0 4
68398: ARRAY
68399: PUSH
68400: FOR_IN
68401: IFFALSE 68461
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68403: LD_VAR 0 3
68407: PPUSH
68408: LD_VAR 0 5
68412: PPUSH
68413: CALL_OW 430
68417: PUSH
68418: LD_VAR 0 4
68422: PPUSH
68423: LD_VAR 0 5
68427: PPUSH
68428: CALL 10668 0 2
68432: AND
68433: IFFALSE 68459
// begin researching := true ;
68435: LD_ADDR_VAR 0 10
68439: PUSH
68440: LD_INT 1
68442: ST_TO_ADDR
// ComResearch ( j , t ) ;
68443: LD_VAR 0 3
68447: PPUSH
68448: LD_VAR 0 5
68452: PPUSH
68453: CALL_OW 124
// break ;
68457: GO 68461
// end ;
68459: GO 68400
68461: POP
68462: POP
// if not researching then
68463: LD_VAR 0 10
68467: NOT
68468: IFFALSE 68480
// idle_lab := j ;
68470: LD_ADDR_VAR 0 11
68474: PUSH
68475: LD_VAR 0 3
68479: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68480: LD_VAR 0 3
68484: PPUSH
68485: CALL_OW 461
68489: PUSH
68490: LD_INT 10
68492: EQUAL
68493: IFFALSE 69081
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68495: LD_EXP 72
68499: PUSH
68500: LD_VAR 0 2
68504: ARRAY
68505: NOT
68506: PUSH
68507: LD_EXP 73
68511: PUSH
68512: LD_VAR 0 2
68516: ARRAY
68517: NOT
68518: AND
68519: PUSH
68520: LD_EXP 70
68524: PUSH
68525: LD_VAR 0 4
68529: ARRAY
68530: PUSH
68531: LD_INT 1
68533: GREATER
68534: AND
68535: IFFALSE 68666
// begin ComCancel ( j ) ;
68537: LD_VAR 0 3
68541: PPUSH
68542: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68546: LD_ADDR_EXP 70
68550: PUSH
68551: LD_EXP 70
68555: PPUSH
68556: LD_VAR 0 4
68560: PPUSH
68561: LD_EXP 70
68565: PUSH
68566: LD_VAR 0 4
68570: ARRAY
68571: PPUSH
68572: LD_EXP 70
68576: PUSH
68577: LD_VAR 0 4
68581: ARRAY
68582: PUSH
68583: LD_INT 1
68585: MINUS
68586: PPUSH
68587: LD_EXP 70
68591: PUSH
68592: LD_VAR 0 4
68596: ARRAY
68597: PPUSH
68598: LD_INT 0
68600: PPUSH
68601: CALL 14192 0 4
68605: PPUSH
68606: CALL_OW 1
68610: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68611: LD_ADDR_EXP 70
68615: PUSH
68616: LD_EXP 70
68620: PPUSH
68621: LD_VAR 0 4
68625: PPUSH
68626: LD_EXP 70
68630: PUSH
68631: LD_VAR 0 4
68635: ARRAY
68636: PPUSH
68637: LD_EXP 70
68641: PUSH
68642: LD_VAR 0 4
68646: ARRAY
68647: PPUSH
68648: LD_INT 1
68650: PPUSH
68651: LD_INT 0
68653: PPUSH
68654: CALL 14192 0 4
68658: PPUSH
68659: CALL_OW 1
68663: ST_TO_ADDR
// continue ;
68664: GO 68238
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68666: LD_EXP 72
68670: PUSH
68671: LD_VAR 0 2
68675: ARRAY
68676: PUSH
68677: LD_EXP 73
68681: PUSH
68682: LD_VAR 0 2
68686: ARRAY
68687: NOT
68688: AND
68689: IFFALSE 68816
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68691: LD_ADDR_EXP 73
68695: PUSH
68696: LD_EXP 73
68700: PPUSH
68701: LD_VAR 0 2
68705: PUSH
68706: LD_EXP 73
68710: PUSH
68711: LD_VAR 0 2
68715: ARRAY
68716: PUSH
68717: LD_INT 1
68719: PLUS
68720: PUSH
68721: EMPTY
68722: LIST
68723: LIST
68724: PPUSH
68725: LD_EXP 72
68729: PUSH
68730: LD_VAR 0 2
68734: ARRAY
68735: PUSH
68736: LD_INT 1
68738: ARRAY
68739: PPUSH
68740: CALL 14774 0 3
68744: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68745: LD_EXP 72
68749: PUSH
68750: LD_VAR 0 2
68754: ARRAY
68755: PUSH
68756: LD_INT 1
68758: ARRAY
68759: PPUSH
68760: LD_INT 112
68762: PPUSH
68763: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68767: LD_ADDR_VAR 0 9
68771: PUSH
68772: LD_EXP 72
68776: PUSH
68777: LD_VAR 0 2
68781: ARRAY
68782: PPUSH
68783: LD_INT 1
68785: PPUSH
68786: CALL_OW 3
68790: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68791: LD_ADDR_EXP 72
68795: PUSH
68796: LD_EXP 72
68800: PPUSH
68801: LD_VAR 0 2
68805: PPUSH
68806: LD_VAR 0 9
68810: PPUSH
68811: CALL_OW 1
68815: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68816: LD_EXP 72
68820: PUSH
68821: LD_VAR 0 2
68825: ARRAY
68826: PUSH
68827: LD_EXP 73
68831: PUSH
68832: LD_VAR 0 2
68836: ARRAY
68837: AND
68838: PUSH
68839: LD_EXP 73
68843: PUSH
68844: LD_VAR 0 2
68848: ARRAY
68849: PUSH
68850: LD_INT 1
68852: ARRAY
68853: PPUSH
68854: CALL_OW 310
68858: NOT
68859: AND
68860: PUSH
68861: LD_VAR 0 3
68865: PPUSH
68866: CALL_OW 313
68870: PUSH
68871: LD_INT 6
68873: EQUAL
68874: AND
68875: IFFALSE 68931
// begin tmp2 := UnitsInside ( j ) ;
68877: LD_ADDR_VAR 0 9
68881: PUSH
68882: LD_VAR 0 3
68886: PPUSH
68887: CALL_OW 313
68891: ST_TO_ADDR
// if tmp2 = 6 then
68892: LD_VAR 0 9
68896: PUSH
68897: LD_INT 6
68899: EQUAL
68900: IFFALSE 68931
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68902: LD_VAR 0 9
68906: PUSH
68907: LD_INT 1
68909: ARRAY
68910: PPUSH
68911: LD_INT 112
68913: PPUSH
68914: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68918: LD_VAR 0 9
68922: PUSH
68923: LD_INT 1
68925: ARRAY
68926: PPUSH
68927: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68931: LD_EXP 73
68935: PUSH
68936: LD_VAR 0 2
68940: ARRAY
68941: PUSH
68942: LD_EXP 73
68946: PUSH
68947: LD_VAR 0 2
68951: ARRAY
68952: PUSH
68953: LD_INT 1
68955: ARRAY
68956: PPUSH
68957: CALL_OW 314
68961: NOT
68962: AND
68963: PUSH
68964: LD_EXP 73
68968: PUSH
68969: LD_VAR 0 2
68973: ARRAY
68974: PUSH
68975: LD_INT 1
68977: ARRAY
68978: PPUSH
68979: CALL_OW 310
68983: NOT
68984: AND
68985: IFFALSE 69011
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68987: LD_EXP 73
68991: PUSH
68992: LD_VAR 0 2
68996: ARRAY
68997: PUSH
68998: LD_INT 1
69000: ARRAY
69001: PPUSH
69002: LD_VAR 0 3
69006: PPUSH
69007: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69011: LD_EXP 73
69015: PUSH
69016: LD_VAR 0 2
69020: ARRAY
69021: PUSH
69022: LD_INT 1
69024: ARRAY
69025: PPUSH
69026: CALL_OW 310
69030: PUSH
69031: LD_EXP 73
69035: PUSH
69036: LD_VAR 0 2
69040: ARRAY
69041: PUSH
69042: LD_INT 1
69044: ARRAY
69045: PPUSH
69046: CALL_OW 310
69050: PPUSH
69051: CALL_OW 461
69055: PUSH
69056: LD_INT 3
69058: NONEQUAL
69059: AND
69060: IFFALSE 69081
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
69062: LD_EXP 73
69066: PUSH
69067: LD_VAR 0 2
69071: ARRAY
69072: PUSH
69073: LD_INT 1
69075: ARRAY
69076: PPUSH
69077: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
69081: LD_VAR 0 3
69085: PPUSH
69086: CALL_OW 461
69090: PUSH
69091: LD_INT 6
69093: EQUAL
69094: PUSH
69095: LD_VAR 0 6
69099: PUSH
69100: LD_INT 1
69102: GREATER
69103: AND
69104: IFFALSE 69256
// begin sci := [ ] ;
69106: LD_ADDR_VAR 0 8
69110: PUSH
69111: EMPTY
69112: ST_TO_ADDR
// for x in ( tmp diff j ) do
69113: LD_ADDR_VAR 0 7
69117: PUSH
69118: LD_VAR 0 6
69122: PUSH
69123: LD_VAR 0 3
69127: DIFF
69128: PUSH
69129: FOR_IN
69130: IFFALSE 69182
// begin if sci = 6 then
69132: LD_VAR 0 8
69136: PUSH
69137: LD_INT 6
69139: EQUAL
69140: IFFALSE 69144
// break ;
69142: GO 69182
// if BuildingStatus ( x ) = bs_idle then
69144: LD_VAR 0 7
69148: PPUSH
69149: CALL_OW 461
69153: PUSH
69154: LD_INT 2
69156: EQUAL
69157: IFFALSE 69180
// sci := sci ^ UnitsInside ( x ) ;
69159: LD_ADDR_VAR 0 8
69163: PUSH
69164: LD_VAR 0 8
69168: PUSH
69169: LD_VAR 0 7
69173: PPUSH
69174: CALL_OW 313
69178: ADD
69179: ST_TO_ADDR
// end ;
69180: GO 69129
69182: POP
69183: POP
// if not sci then
69184: LD_VAR 0 8
69188: NOT
69189: IFFALSE 69193
// continue ;
69191: GO 68238
// for x in sci do
69193: LD_ADDR_VAR 0 7
69197: PUSH
69198: LD_VAR 0 8
69202: PUSH
69203: FOR_IN
69204: IFFALSE 69254
// if IsInUnit ( x ) and not HasTask ( x ) then
69206: LD_VAR 0 7
69210: PPUSH
69211: CALL_OW 310
69215: PUSH
69216: LD_VAR 0 7
69220: PPUSH
69221: CALL_OW 314
69225: NOT
69226: AND
69227: IFFALSE 69252
// begin ComExitBuilding ( x ) ;
69229: LD_VAR 0 7
69233: PPUSH
69234: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69238: LD_VAR 0 7
69242: PPUSH
69243: LD_VAR 0 3
69247: PPUSH
69248: CALL_OW 180
// end ;
69252: GO 69203
69254: POP
69255: POP
// end ; end ;
69256: GO 68238
69258: POP
69259: POP
// end ;
69260: GO 68192
69262: POP
69263: POP
// end ;
69264: LD_VAR 0 1
69268: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69269: LD_INT 0
69271: PPUSH
69272: PPUSH
// if not mc_bases then
69273: LD_EXP 43
69277: NOT
69278: IFFALSE 69282
// exit ;
69280: GO 69363
// for i = 1 to mc_bases do
69282: LD_ADDR_VAR 0 2
69286: PUSH
69287: DOUBLE
69288: LD_INT 1
69290: DEC
69291: ST_TO_ADDR
69292: LD_EXP 43
69296: PUSH
69297: FOR_TO
69298: IFFALSE 69361
// if mc_mines [ i ] and mc_miners [ i ] then
69300: LD_EXP 56
69304: PUSH
69305: LD_VAR 0 2
69309: ARRAY
69310: PUSH
69311: LD_EXP 57
69315: PUSH
69316: LD_VAR 0 2
69320: ARRAY
69321: AND
69322: IFFALSE 69359
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69324: LD_EXP 57
69328: PUSH
69329: LD_VAR 0 2
69333: ARRAY
69334: PUSH
69335: LD_INT 1
69337: ARRAY
69338: PPUSH
69339: CALL_OW 255
69343: PPUSH
69344: LD_EXP 56
69348: PUSH
69349: LD_VAR 0 2
69353: ARRAY
69354: PPUSH
69355: CALL 11751 0 2
69359: GO 69297
69361: POP
69362: POP
// end ;
69363: LD_VAR 0 1
69367: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69368: LD_INT 0
69370: PPUSH
69371: PPUSH
69372: PPUSH
69373: PPUSH
69374: PPUSH
69375: PPUSH
69376: PPUSH
69377: PPUSH
// if not mc_bases or not mc_parking then
69378: LD_EXP 43
69382: NOT
69383: PUSH
69384: LD_EXP 67
69388: NOT
69389: OR
69390: IFFALSE 69394
// exit ;
69392: GO 70132
// for i = 1 to mc_bases do
69394: LD_ADDR_VAR 0 2
69398: PUSH
69399: DOUBLE
69400: LD_INT 1
69402: DEC
69403: ST_TO_ADDR
69404: LD_EXP 43
69408: PUSH
69409: FOR_TO
69410: IFFALSE 70130
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69412: LD_EXP 43
69416: PUSH
69417: LD_VAR 0 2
69421: ARRAY
69422: NOT
69423: PUSH
69424: LD_EXP 67
69428: PUSH
69429: LD_VAR 0 2
69433: ARRAY
69434: NOT
69435: OR
69436: IFFALSE 69440
// continue ;
69438: GO 69409
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69440: LD_ADDR_VAR 0 5
69444: PUSH
69445: LD_EXP 43
69449: PUSH
69450: LD_VAR 0 2
69454: ARRAY
69455: PUSH
69456: LD_INT 1
69458: ARRAY
69459: PPUSH
69460: CALL_OW 255
69464: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69465: LD_ADDR_VAR 0 6
69469: PUSH
69470: LD_EXP 43
69474: PUSH
69475: LD_VAR 0 2
69479: ARRAY
69480: PPUSH
69481: LD_INT 30
69483: PUSH
69484: LD_INT 3
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PPUSH
69491: CALL_OW 72
69495: ST_TO_ADDR
// if not fac then
69496: LD_VAR 0 6
69500: NOT
69501: IFFALSE 69552
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69503: LD_ADDR_VAR 0 6
69507: PUSH
69508: LD_EXP 43
69512: PUSH
69513: LD_VAR 0 2
69517: ARRAY
69518: PPUSH
69519: LD_INT 2
69521: PUSH
69522: LD_INT 30
69524: PUSH
69525: LD_INT 0
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 30
69534: PUSH
69535: LD_INT 1
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: EMPTY
69543: LIST
69544: LIST
69545: LIST
69546: PPUSH
69547: CALL_OW 72
69551: ST_TO_ADDR
// if not fac then
69552: LD_VAR 0 6
69556: NOT
69557: IFFALSE 69561
// continue ;
69559: GO 69409
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69561: LD_ADDR_VAR 0 7
69565: PUSH
69566: LD_EXP 67
69570: PUSH
69571: LD_VAR 0 2
69575: ARRAY
69576: PPUSH
69577: LD_INT 22
69579: PUSH
69580: LD_VAR 0 5
69584: PUSH
69585: EMPTY
69586: LIST
69587: LIST
69588: PUSH
69589: LD_INT 21
69591: PUSH
69592: LD_INT 2
69594: PUSH
69595: EMPTY
69596: LIST
69597: LIST
69598: PUSH
69599: LD_INT 3
69601: PUSH
69602: LD_INT 60
69604: PUSH
69605: EMPTY
69606: LIST
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 3
69614: PUSH
69615: LD_INT 24
69617: PUSH
69618: LD_INT 1000
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: EMPTY
69626: LIST
69627: LIST
69628: PUSH
69629: EMPTY
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: PPUSH
69635: CALL_OW 70
69639: ST_TO_ADDR
// for j in fac do
69640: LD_ADDR_VAR 0 3
69644: PUSH
69645: LD_VAR 0 6
69649: PUSH
69650: FOR_IN
69651: IFFALSE 69746
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69653: LD_ADDR_VAR 0 7
69657: PUSH
69658: LD_VAR 0 7
69662: PUSH
69663: LD_INT 22
69665: PUSH
69666: LD_VAR 0 5
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: PUSH
69675: LD_INT 91
69677: PUSH
69678: LD_VAR 0 3
69682: PUSH
69683: LD_INT 15
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: LIST
69690: PUSH
69691: LD_INT 21
69693: PUSH
69694: LD_INT 2
69696: PUSH
69697: EMPTY
69698: LIST
69699: LIST
69700: PUSH
69701: LD_INT 3
69703: PUSH
69704: LD_INT 60
69706: PUSH
69707: EMPTY
69708: LIST
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 3
69716: PUSH
69717: LD_INT 24
69719: PUSH
69720: LD_INT 1000
69722: PUSH
69723: EMPTY
69724: LIST
69725: LIST
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: PPUSH
69738: CALL_OW 69
69742: UNION
69743: ST_TO_ADDR
69744: GO 69650
69746: POP
69747: POP
// if not vehs then
69748: LD_VAR 0 7
69752: NOT
69753: IFFALSE 69779
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69755: LD_ADDR_EXP 55
69759: PUSH
69760: LD_EXP 55
69764: PPUSH
69765: LD_VAR 0 2
69769: PPUSH
69770: EMPTY
69771: PPUSH
69772: CALL_OW 1
69776: ST_TO_ADDR
// continue ;
69777: GO 69409
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69779: LD_ADDR_VAR 0 8
69783: PUSH
69784: LD_EXP 43
69788: PUSH
69789: LD_VAR 0 2
69793: ARRAY
69794: PPUSH
69795: LD_INT 30
69797: PUSH
69798: LD_INT 3
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PPUSH
69805: CALL_OW 72
69809: ST_TO_ADDR
// if tmp then
69810: LD_VAR 0 8
69814: IFFALSE 69917
// begin for j in tmp do
69816: LD_ADDR_VAR 0 3
69820: PUSH
69821: LD_VAR 0 8
69825: PUSH
69826: FOR_IN
69827: IFFALSE 69915
// for k in UnitsInside ( j ) do
69829: LD_ADDR_VAR 0 4
69833: PUSH
69834: LD_VAR 0 3
69838: PPUSH
69839: CALL_OW 313
69843: PUSH
69844: FOR_IN
69845: IFFALSE 69911
// if k then
69847: LD_VAR 0 4
69851: IFFALSE 69909
// if not k in mc_repair_vehicle [ i ] then
69853: LD_VAR 0 4
69857: PUSH
69858: LD_EXP 55
69862: PUSH
69863: LD_VAR 0 2
69867: ARRAY
69868: IN
69869: NOT
69870: IFFALSE 69909
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69872: LD_ADDR_EXP 55
69876: PUSH
69877: LD_EXP 55
69881: PPUSH
69882: LD_VAR 0 2
69886: PPUSH
69887: LD_EXP 55
69891: PUSH
69892: LD_VAR 0 2
69896: ARRAY
69897: PUSH
69898: LD_VAR 0 4
69902: UNION
69903: PPUSH
69904: CALL_OW 1
69908: ST_TO_ADDR
69909: GO 69844
69911: POP
69912: POP
69913: GO 69826
69915: POP
69916: POP
// end ; if not mc_repair_vehicle [ i ] then
69917: LD_EXP 55
69921: PUSH
69922: LD_VAR 0 2
69926: ARRAY
69927: NOT
69928: IFFALSE 69932
// continue ;
69930: GO 69409
// for j in mc_repair_vehicle [ i ] do
69932: LD_ADDR_VAR 0 3
69936: PUSH
69937: LD_EXP 55
69941: PUSH
69942: LD_VAR 0 2
69946: ARRAY
69947: PUSH
69948: FOR_IN
69949: IFFALSE 70126
// begin if GetClass ( j ) <> 3 then
69951: LD_VAR 0 3
69955: PPUSH
69956: CALL_OW 257
69960: PUSH
69961: LD_INT 3
69963: NONEQUAL
69964: IFFALSE 70005
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69966: LD_ADDR_EXP 55
69970: PUSH
69971: LD_EXP 55
69975: PPUSH
69976: LD_VAR 0 2
69980: PPUSH
69981: LD_EXP 55
69985: PUSH
69986: LD_VAR 0 2
69990: ARRAY
69991: PUSH
69992: LD_VAR 0 3
69996: DIFF
69997: PPUSH
69998: CALL_OW 1
70002: ST_TO_ADDR
// continue ;
70003: GO 69948
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70005: LD_VAR 0 3
70009: PPUSH
70010: CALL_OW 311
70014: NOT
70015: PUSH
70016: LD_VAR 0 3
70020: PUSH
70021: LD_EXP 46
70025: PUSH
70026: LD_VAR 0 2
70030: ARRAY
70031: PUSH
70032: LD_INT 1
70034: ARRAY
70035: IN
70036: NOT
70037: AND
70038: PUSH
70039: LD_VAR 0 3
70043: PUSH
70044: LD_EXP 46
70048: PUSH
70049: LD_VAR 0 2
70053: ARRAY
70054: PUSH
70055: LD_INT 2
70057: ARRAY
70058: IN
70059: NOT
70060: AND
70061: IFFALSE 70124
// begin if IsInUnit ( j ) then
70063: LD_VAR 0 3
70067: PPUSH
70068: CALL_OW 310
70072: IFFALSE 70085
// ComExitBuilding ( j ) else
70074: LD_VAR 0 3
70078: PPUSH
70079: CALL_OW 122
70083: GO 70124
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
70085: LD_VAR 0 3
70089: PPUSH
70090: LD_VAR 0 7
70094: PUSH
70095: LD_INT 1
70097: ARRAY
70098: PPUSH
70099: CALL 49198 0 2
70103: NOT
70104: IFFALSE 70124
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
70106: LD_VAR 0 3
70110: PPUSH
70111: LD_VAR 0 7
70115: PUSH
70116: LD_INT 1
70118: ARRAY
70119: PPUSH
70120: CALL_OW 129
// end ; end ;
70124: GO 69948
70126: POP
70127: POP
// end ;
70128: GO 69409
70130: POP
70131: POP
// end ;
70132: LD_VAR 0 1
70136: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70137: LD_INT 0
70139: PPUSH
70140: PPUSH
70141: PPUSH
70142: PPUSH
70143: PPUSH
70144: PPUSH
70145: PPUSH
70146: PPUSH
70147: PPUSH
70148: PPUSH
70149: PPUSH
// if not mc_bases then
70150: LD_EXP 43
70154: NOT
70155: IFFALSE 70159
// exit ;
70157: GO 70961
// for i = 1 to mc_bases do
70159: LD_ADDR_VAR 0 2
70163: PUSH
70164: DOUBLE
70165: LD_INT 1
70167: DEC
70168: ST_TO_ADDR
70169: LD_EXP 43
70173: PUSH
70174: FOR_TO
70175: IFFALSE 70959
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70177: LD_EXP 71
70181: PUSH
70182: LD_VAR 0 2
70186: ARRAY
70187: NOT
70188: PUSH
70189: LD_EXP 46
70193: PUSH
70194: LD_VAR 0 2
70198: ARRAY
70199: PUSH
70200: LD_INT 1
70202: ARRAY
70203: OR
70204: PUSH
70205: LD_EXP 46
70209: PUSH
70210: LD_VAR 0 2
70214: ARRAY
70215: PUSH
70216: LD_INT 2
70218: ARRAY
70219: OR
70220: PUSH
70221: LD_EXP 69
70225: PUSH
70226: LD_VAR 0 2
70230: ARRAY
70231: PPUSH
70232: LD_INT 1
70234: PPUSH
70235: CALL_OW 325
70239: NOT
70240: OR
70241: PUSH
70242: LD_EXP 66
70246: PUSH
70247: LD_VAR 0 2
70251: ARRAY
70252: OR
70253: IFFALSE 70257
// continue ;
70255: GO 70174
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70257: LD_ADDR_VAR 0 8
70261: PUSH
70262: LD_EXP 43
70266: PUSH
70267: LD_VAR 0 2
70271: ARRAY
70272: PPUSH
70273: LD_INT 25
70275: PUSH
70276: LD_INT 4
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 50
70285: PUSH
70286: EMPTY
70287: LIST
70288: PUSH
70289: LD_INT 3
70291: PUSH
70292: LD_INT 60
70294: PUSH
70295: EMPTY
70296: LIST
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: LIST
70306: PPUSH
70307: CALL_OW 72
70311: PUSH
70312: LD_EXP 47
70316: PUSH
70317: LD_VAR 0 2
70321: ARRAY
70322: DIFF
70323: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70324: LD_ADDR_VAR 0 9
70328: PUSH
70329: LD_EXP 43
70333: PUSH
70334: LD_VAR 0 2
70338: ARRAY
70339: PPUSH
70340: LD_INT 2
70342: PUSH
70343: LD_INT 30
70345: PUSH
70346: LD_INT 0
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 30
70355: PUSH
70356: LD_INT 1
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: LIST
70367: PPUSH
70368: CALL_OW 72
70372: ST_TO_ADDR
// if not tmp or not dep then
70373: LD_VAR 0 8
70377: NOT
70378: PUSH
70379: LD_VAR 0 9
70383: NOT
70384: OR
70385: IFFALSE 70389
// continue ;
70387: GO 70174
// side := GetSide ( tmp [ 1 ] ) ;
70389: LD_ADDR_VAR 0 11
70393: PUSH
70394: LD_VAR 0 8
70398: PUSH
70399: LD_INT 1
70401: ARRAY
70402: PPUSH
70403: CALL_OW 255
70407: ST_TO_ADDR
// dep := dep [ 1 ] ;
70408: LD_ADDR_VAR 0 9
70412: PUSH
70413: LD_VAR 0 9
70417: PUSH
70418: LD_INT 1
70420: ARRAY
70421: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70422: LD_ADDR_VAR 0 7
70426: PUSH
70427: LD_EXP 71
70431: PUSH
70432: LD_VAR 0 2
70436: ARRAY
70437: PPUSH
70438: LD_INT 22
70440: PUSH
70441: LD_INT 0
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 25
70450: PUSH
70451: LD_INT 12
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PPUSH
70462: CALL_OW 70
70466: PUSH
70467: LD_INT 22
70469: PUSH
70470: LD_INT 0
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: PUSH
70477: LD_INT 25
70479: PUSH
70480: LD_INT 12
70482: PUSH
70483: EMPTY
70484: LIST
70485: LIST
70486: PUSH
70487: LD_INT 91
70489: PUSH
70490: LD_VAR 0 9
70494: PUSH
70495: LD_INT 20
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: LIST
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: LIST
70507: PPUSH
70508: CALL_OW 69
70512: UNION
70513: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70514: LD_ADDR_VAR 0 10
70518: PUSH
70519: LD_EXP 71
70523: PUSH
70524: LD_VAR 0 2
70528: ARRAY
70529: PPUSH
70530: LD_INT 81
70532: PUSH
70533: LD_VAR 0 11
70537: PUSH
70538: EMPTY
70539: LIST
70540: LIST
70541: PPUSH
70542: CALL_OW 70
70546: ST_TO_ADDR
// if not apes or danger_at_area then
70547: LD_VAR 0 7
70551: NOT
70552: PUSH
70553: LD_VAR 0 10
70557: OR
70558: IFFALSE 70608
// begin if mc_taming [ i ] then
70560: LD_EXP 74
70564: PUSH
70565: LD_VAR 0 2
70569: ARRAY
70570: IFFALSE 70606
// begin MC_Reset ( i , 121 ) ;
70572: LD_VAR 0 2
70576: PPUSH
70577: LD_INT 121
70579: PPUSH
70580: CALL 55524 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70584: LD_ADDR_EXP 74
70588: PUSH
70589: LD_EXP 74
70593: PPUSH
70594: LD_VAR 0 2
70598: PPUSH
70599: EMPTY
70600: PPUSH
70601: CALL_OW 1
70605: ST_TO_ADDR
// end ; continue ;
70606: GO 70174
// end ; for j in tmp do
70608: LD_ADDR_VAR 0 3
70612: PUSH
70613: LD_VAR 0 8
70617: PUSH
70618: FOR_IN
70619: IFFALSE 70955
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70621: LD_VAR 0 3
70625: PUSH
70626: LD_EXP 74
70630: PUSH
70631: LD_VAR 0 2
70635: ARRAY
70636: IN
70637: NOT
70638: PUSH
70639: LD_EXP 74
70643: PUSH
70644: LD_VAR 0 2
70648: ARRAY
70649: PUSH
70650: LD_INT 3
70652: LESS
70653: AND
70654: IFFALSE 70712
// begin SetTag ( j , 121 ) ;
70656: LD_VAR 0 3
70660: PPUSH
70661: LD_INT 121
70663: PPUSH
70664: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70668: LD_ADDR_EXP 74
70672: PUSH
70673: LD_EXP 74
70677: PPUSH
70678: LD_VAR 0 2
70682: PUSH
70683: LD_EXP 74
70687: PUSH
70688: LD_VAR 0 2
70692: ARRAY
70693: PUSH
70694: LD_INT 1
70696: PLUS
70697: PUSH
70698: EMPTY
70699: LIST
70700: LIST
70701: PPUSH
70702: LD_VAR 0 3
70706: PPUSH
70707: CALL 14774 0 3
70711: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70712: LD_VAR 0 3
70716: PUSH
70717: LD_EXP 74
70721: PUSH
70722: LD_VAR 0 2
70726: ARRAY
70727: IN
70728: IFFALSE 70953
// begin if GetClass ( j ) <> 4 then
70730: LD_VAR 0 3
70734: PPUSH
70735: CALL_OW 257
70739: PUSH
70740: LD_INT 4
70742: NONEQUAL
70743: IFFALSE 70796
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70745: LD_ADDR_EXP 74
70749: PUSH
70750: LD_EXP 74
70754: PPUSH
70755: LD_VAR 0 2
70759: PPUSH
70760: LD_EXP 74
70764: PUSH
70765: LD_VAR 0 2
70769: ARRAY
70770: PUSH
70771: LD_VAR 0 3
70775: DIFF
70776: PPUSH
70777: CALL_OW 1
70781: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70782: LD_VAR 0 3
70786: PPUSH
70787: LD_INT 0
70789: PPUSH
70790: CALL_OW 109
// continue ;
70794: GO 70618
// end ; if IsInUnit ( j ) then
70796: LD_VAR 0 3
70800: PPUSH
70801: CALL_OW 310
70805: IFFALSE 70816
// ComExitBuilding ( j ) ;
70807: LD_VAR 0 3
70811: PPUSH
70812: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70816: LD_ADDR_VAR 0 6
70820: PUSH
70821: LD_VAR 0 7
70825: PPUSH
70826: LD_VAR 0 3
70830: PPUSH
70831: CALL_OW 74
70835: ST_TO_ADDR
// if not ape then
70836: LD_VAR 0 6
70840: NOT
70841: IFFALSE 70845
// break ;
70843: GO 70955
// x := GetX ( ape ) ;
70845: LD_ADDR_VAR 0 4
70849: PUSH
70850: LD_VAR 0 6
70854: PPUSH
70855: CALL_OW 250
70859: ST_TO_ADDR
// y := GetY ( ape ) ;
70860: LD_ADDR_VAR 0 5
70864: PUSH
70865: LD_VAR 0 6
70869: PPUSH
70870: CALL_OW 251
70874: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70875: LD_VAR 0 4
70879: PPUSH
70880: LD_VAR 0 5
70884: PPUSH
70885: CALL_OW 488
70889: NOT
70890: PUSH
70891: LD_VAR 0 11
70895: PPUSH
70896: LD_VAR 0 4
70900: PPUSH
70901: LD_VAR 0 5
70905: PPUSH
70906: LD_INT 20
70908: PPUSH
70909: CALL 15670 0 4
70913: PUSH
70914: LD_INT 4
70916: ARRAY
70917: OR
70918: IFFALSE 70922
// break ;
70920: GO 70955
// if not HasTask ( j ) then
70922: LD_VAR 0 3
70926: PPUSH
70927: CALL_OW 314
70931: NOT
70932: IFFALSE 70953
// ComTameXY ( j , x , y ) ;
70934: LD_VAR 0 3
70938: PPUSH
70939: LD_VAR 0 4
70943: PPUSH
70944: LD_VAR 0 5
70948: PPUSH
70949: CALL_OW 131
// end ; end ;
70953: GO 70618
70955: POP
70956: POP
// end ;
70957: GO 70174
70959: POP
70960: POP
// end ;
70961: LD_VAR 0 1
70965: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70966: LD_INT 0
70968: PPUSH
70969: PPUSH
70970: PPUSH
70971: PPUSH
70972: PPUSH
70973: PPUSH
70974: PPUSH
70975: PPUSH
// if not mc_bases then
70976: LD_EXP 43
70980: NOT
70981: IFFALSE 70985
// exit ;
70983: GO 71611
// for i = 1 to mc_bases do
70985: LD_ADDR_VAR 0 2
70989: PUSH
70990: DOUBLE
70991: LD_INT 1
70993: DEC
70994: ST_TO_ADDR
70995: LD_EXP 43
70999: PUSH
71000: FOR_TO
71001: IFFALSE 71609
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71003: LD_EXP 72
71007: PUSH
71008: LD_VAR 0 2
71012: ARRAY
71013: NOT
71014: PUSH
71015: LD_EXP 72
71019: PUSH
71020: LD_VAR 0 2
71024: ARRAY
71025: PPUSH
71026: LD_INT 25
71028: PUSH
71029: LD_INT 12
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PPUSH
71036: CALL_OW 72
71040: NOT
71041: OR
71042: IFFALSE 71046
// continue ;
71044: GO 71000
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
71046: LD_ADDR_VAR 0 5
71050: PUSH
71051: LD_EXP 72
71055: PUSH
71056: LD_VAR 0 2
71060: ARRAY
71061: PUSH
71062: LD_INT 1
71064: ARRAY
71065: PPUSH
71066: CALL_OW 255
71070: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
71071: LD_VAR 0 5
71075: PPUSH
71076: LD_INT 2
71078: PPUSH
71079: CALL_OW 325
71083: IFFALSE 71336
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71085: LD_ADDR_VAR 0 4
71089: PUSH
71090: LD_EXP 72
71094: PUSH
71095: LD_VAR 0 2
71099: ARRAY
71100: PPUSH
71101: LD_INT 25
71103: PUSH
71104: LD_INT 16
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: PPUSH
71111: CALL_OW 72
71115: ST_TO_ADDR
// if tmp < 6 then
71116: LD_VAR 0 4
71120: PUSH
71121: LD_INT 6
71123: LESS
71124: IFFALSE 71336
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71126: LD_ADDR_VAR 0 6
71130: PUSH
71131: LD_EXP 43
71135: PUSH
71136: LD_VAR 0 2
71140: ARRAY
71141: PPUSH
71142: LD_INT 2
71144: PUSH
71145: LD_INT 30
71147: PUSH
71148: LD_INT 0
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: LD_INT 30
71157: PUSH
71158: LD_INT 1
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: LIST
71169: PPUSH
71170: CALL_OW 72
71174: ST_TO_ADDR
// if depot then
71175: LD_VAR 0 6
71179: IFFALSE 71336
// begin selected := 0 ;
71181: LD_ADDR_VAR 0 7
71185: PUSH
71186: LD_INT 0
71188: ST_TO_ADDR
// for j in depot do
71189: LD_ADDR_VAR 0 3
71193: PUSH
71194: LD_VAR 0 6
71198: PUSH
71199: FOR_IN
71200: IFFALSE 71231
// begin if UnitsInside ( j ) < 6 then
71202: LD_VAR 0 3
71206: PPUSH
71207: CALL_OW 313
71211: PUSH
71212: LD_INT 6
71214: LESS
71215: IFFALSE 71229
// begin selected := j ;
71217: LD_ADDR_VAR 0 7
71221: PUSH
71222: LD_VAR 0 3
71226: ST_TO_ADDR
// break ;
71227: GO 71231
// end ; end ;
71229: GO 71199
71231: POP
71232: POP
// if selected then
71233: LD_VAR 0 7
71237: IFFALSE 71336
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71239: LD_ADDR_VAR 0 3
71243: PUSH
71244: LD_EXP 72
71248: PUSH
71249: LD_VAR 0 2
71253: ARRAY
71254: PPUSH
71255: LD_INT 25
71257: PUSH
71258: LD_INT 12
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PPUSH
71265: CALL_OW 72
71269: PUSH
71270: FOR_IN
71271: IFFALSE 71334
// if not HasTask ( j ) then
71273: LD_VAR 0 3
71277: PPUSH
71278: CALL_OW 314
71282: NOT
71283: IFFALSE 71332
// begin if not IsInUnit ( j ) then
71285: LD_VAR 0 3
71289: PPUSH
71290: CALL_OW 310
71294: NOT
71295: IFFALSE 71311
// ComEnterUnit ( j , selected ) ;
71297: LD_VAR 0 3
71301: PPUSH
71302: LD_VAR 0 7
71306: PPUSH
71307: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71311: LD_VAR 0 3
71315: PPUSH
71316: LD_INT 16
71318: PPUSH
71319: CALL_OW 183
// AddComExitBuilding ( j ) ;
71323: LD_VAR 0 3
71327: PPUSH
71328: CALL_OW 182
// end ;
71332: GO 71270
71334: POP
71335: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71336: LD_VAR 0 5
71340: PPUSH
71341: LD_INT 11
71343: PPUSH
71344: CALL_OW 325
71348: IFFALSE 71607
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71350: LD_ADDR_VAR 0 4
71354: PUSH
71355: LD_EXP 72
71359: PUSH
71360: LD_VAR 0 2
71364: ARRAY
71365: PPUSH
71366: LD_INT 25
71368: PUSH
71369: LD_INT 16
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PPUSH
71376: CALL_OW 72
71380: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71381: LD_VAR 0 4
71385: PUSH
71386: LD_INT 6
71388: GREATEREQUAL
71389: PUSH
71390: LD_VAR 0 5
71394: PPUSH
71395: LD_INT 2
71397: PPUSH
71398: CALL_OW 325
71402: NOT
71403: OR
71404: IFFALSE 71607
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71406: LD_ADDR_VAR 0 8
71410: PUSH
71411: LD_EXP 43
71415: PUSH
71416: LD_VAR 0 2
71420: ARRAY
71421: PPUSH
71422: LD_INT 2
71424: PUSH
71425: LD_INT 30
71427: PUSH
71428: LD_INT 4
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: PUSH
71435: LD_INT 30
71437: PUSH
71438: LD_INT 5
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: LIST
71449: PPUSH
71450: CALL_OW 72
71454: ST_TO_ADDR
// if barracks then
71455: LD_VAR 0 8
71459: IFFALSE 71607
// begin selected := 0 ;
71461: LD_ADDR_VAR 0 7
71465: PUSH
71466: LD_INT 0
71468: ST_TO_ADDR
// for j in barracks do
71469: LD_ADDR_VAR 0 3
71473: PUSH
71474: LD_VAR 0 8
71478: PUSH
71479: FOR_IN
71480: IFFALSE 71511
// begin if UnitsInside ( j ) < 6 then
71482: LD_VAR 0 3
71486: PPUSH
71487: CALL_OW 313
71491: PUSH
71492: LD_INT 6
71494: LESS
71495: IFFALSE 71509
// begin selected := j ;
71497: LD_ADDR_VAR 0 7
71501: PUSH
71502: LD_VAR 0 3
71506: ST_TO_ADDR
// break ;
71507: GO 71511
// end ; end ;
71509: GO 71479
71511: POP
71512: POP
// if selected then
71513: LD_VAR 0 7
71517: IFFALSE 71607
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71519: LD_ADDR_VAR 0 3
71523: PUSH
71524: LD_EXP 72
71528: PUSH
71529: LD_VAR 0 2
71533: ARRAY
71534: PPUSH
71535: LD_INT 25
71537: PUSH
71538: LD_INT 12
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PPUSH
71545: CALL_OW 72
71549: PUSH
71550: FOR_IN
71551: IFFALSE 71605
// if not IsInUnit ( j ) and not HasTask ( j ) then
71553: LD_VAR 0 3
71557: PPUSH
71558: CALL_OW 310
71562: NOT
71563: PUSH
71564: LD_VAR 0 3
71568: PPUSH
71569: CALL_OW 314
71573: NOT
71574: AND
71575: IFFALSE 71603
// begin ComEnterUnit ( j , selected ) ;
71577: LD_VAR 0 3
71581: PPUSH
71582: LD_VAR 0 7
71586: PPUSH
71587: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71591: LD_VAR 0 3
71595: PPUSH
71596: LD_INT 15
71598: PPUSH
71599: CALL_OW 183
// end ;
71603: GO 71550
71605: POP
71606: POP
// end ; end ; end ; end ; end ;
71607: GO 71000
71609: POP
71610: POP
// end ;
71611: LD_VAR 0 1
71615: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71616: LD_INT 0
71618: PPUSH
71619: PPUSH
71620: PPUSH
71621: PPUSH
// if not mc_bases then
71622: LD_EXP 43
71626: NOT
71627: IFFALSE 71631
// exit ;
71629: GO 71809
// for i = 1 to mc_bases do
71631: LD_ADDR_VAR 0 2
71635: PUSH
71636: DOUBLE
71637: LD_INT 1
71639: DEC
71640: ST_TO_ADDR
71641: LD_EXP 43
71645: PUSH
71646: FOR_TO
71647: IFFALSE 71807
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71649: LD_ADDR_VAR 0 4
71653: PUSH
71654: LD_EXP 43
71658: PUSH
71659: LD_VAR 0 2
71663: ARRAY
71664: PPUSH
71665: LD_INT 25
71667: PUSH
71668: LD_INT 9
71670: PUSH
71671: EMPTY
71672: LIST
71673: LIST
71674: PPUSH
71675: CALL_OW 72
71679: ST_TO_ADDR
// if not tmp then
71680: LD_VAR 0 4
71684: NOT
71685: IFFALSE 71689
// continue ;
71687: GO 71646
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71689: LD_EXP 69
71693: PUSH
71694: LD_VAR 0 2
71698: ARRAY
71699: PPUSH
71700: LD_INT 29
71702: PPUSH
71703: CALL_OW 325
71707: NOT
71708: PUSH
71709: LD_EXP 69
71713: PUSH
71714: LD_VAR 0 2
71718: ARRAY
71719: PPUSH
71720: LD_INT 28
71722: PPUSH
71723: CALL_OW 325
71727: NOT
71728: AND
71729: IFFALSE 71733
// continue ;
71731: GO 71646
// for j in tmp do
71733: LD_ADDR_VAR 0 3
71737: PUSH
71738: LD_VAR 0 4
71742: PUSH
71743: FOR_IN
71744: IFFALSE 71803
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71746: LD_VAR 0 3
71750: PUSH
71751: LD_EXP 46
71755: PUSH
71756: LD_VAR 0 2
71760: ARRAY
71761: PUSH
71762: LD_INT 1
71764: ARRAY
71765: IN
71766: NOT
71767: PUSH
71768: LD_VAR 0 3
71772: PUSH
71773: LD_EXP 46
71777: PUSH
71778: LD_VAR 0 2
71782: ARRAY
71783: PUSH
71784: LD_INT 2
71786: ARRAY
71787: IN
71788: NOT
71789: AND
71790: IFFALSE 71801
// ComSpaceTimeShoot ( j ) ;
71792: LD_VAR 0 3
71796: PPUSH
71797: CALL 10759 0 1
71801: GO 71743
71803: POP
71804: POP
// end ;
71805: GO 71646
71807: POP
71808: POP
// end ;
71809: LD_VAR 0 1
71813: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71814: LD_INT 0
71816: PPUSH
71817: PPUSH
71818: PPUSH
71819: PPUSH
71820: PPUSH
71821: PPUSH
71822: PPUSH
71823: PPUSH
71824: PPUSH
// if not mc_bases then
71825: LD_EXP 43
71829: NOT
71830: IFFALSE 71834
// exit ;
71832: GO 72456
// for i = 1 to mc_bases do
71834: LD_ADDR_VAR 0 2
71838: PUSH
71839: DOUBLE
71840: LD_INT 1
71842: DEC
71843: ST_TO_ADDR
71844: LD_EXP 43
71848: PUSH
71849: FOR_TO
71850: IFFALSE 72454
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71852: LD_EXP 78
71856: PUSH
71857: LD_VAR 0 2
71861: ARRAY
71862: NOT
71863: PUSH
71864: LD_INT 38
71866: PPUSH
71867: LD_EXP 69
71871: PUSH
71872: LD_VAR 0 2
71876: ARRAY
71877: PPUSH
71878: CALL_OW 321
71882: PUSH
71883: LD_INT 2
71885: NONEQUAL
71886: OR
71887: IFFALSE 71891
// continue ;
71889: GO 71849
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71891: LD_ADDR_VAR 0 8
71895: PUSH
71896: LD_EXP 43
71900: PUSH
71901: LD_VAR 0 2
71905: ARRAY
71906: PPUSH
71907: LD_INT 30
71909: PUSH
71910: LD_INT 34
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PPUSH
71917: CALL_OW 72
71921: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71922: LD_ADDR_VAR 0 9
71926: PUSH
71927: LD_EXP 43
71931: PUSH
71932: LD_VAR 0 2
71936: ARRAY
71937: PPUSH
71938: LD_INT 25
71940: PUSH
71941: LD_INT 4
71943: PUSH
71944: EMPTY
71945: LIST
71946: LIST
71947: PPUSH
71948: CALL_OW 72
71952: PPUSH
71953: LD_INT 0
71955: PPUSH
71956: CALL 44715 0 2
71960: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71961: LD_VAR 0 9
71965: NOT
71966: PUSH
71967: LD_VAR 0 8
71971: NOT
71972: OR
71973: PUSH
71974: LD_EXP 43
71978: PUSH
71979: LD_VAR 0 2
71983: ARRAY
71984: PPUSH
71985: LD_INT 124
71987: PPUSH
71988: CALL 44715 0 2
71992: OR
71993: IFFALSE 71997
// continue ;
71995: GO 71849
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71997: LD_EXP 79
72001: PUSH
72002: LD_VAR 0 2
72006: ARRAY
72007: PUSH
72008: LD_EXP 78
72012: PUSH
72013: LD_VAR 0 2
72017: ARRAY
72018: LESS
72019: PUSH
72020: LD_EXP 79
72024: PUSH
72025: LD_VAR 0 2
72029: ARRAY
72030: PUSH
72031: LD_VAR 0 8
72035: LESS
72036: AND
72037: IFFALSE 72452
// begin tmp := sci [ 1 ] ;
72039: LD_ADDR_VAR 0 7
72043: PUSH
72044: LD_VAR 0 9
72048: PUSH
72049: LD_INT 1
72051: ARRAY
72052: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
72053: LD_VAR 0 7
72057: PPUSH
72058: LD_INT 124
72060: PPUSH
72061: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
72065: LD_ADDR_VAR 0 3
72069: PUSH
72070: DOUBLE
72071: LD_EXP 78
72075: PUSH
72076: LD_VAR 0 2
72080: ARRAY
72081: INC
72082: ST_TO_ADDR
72083: LD_EXP 78
72087: PUSH
72088: LD_VAR 0 2
72092: ARRAY
72093: PUSH
72094: FOR_DOWNTO
72095: IFFALSE 72438
// begin if IsInUnit ( tmp ) then
72097: LD_VAR 0 7
72101: PPUSH
72102: CALL_OW 310
72106: IFFALSE 72117
// ComExitBuilding ( tmp ) ;
72108: LD_VAR 0 7
72112: PPUSH
72113: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72117: LD_INT 35
72119: PPUSH
72120: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72124: LD_VAR 0 7
72128: PPUSH
72129: CALL_OW 310
72133: NOT
72134: PUSH
72135: LD_VAR 0 7
72139: PPUSH
72140: CALL_OW 314
72144: NOT
72145: AND
72146: IFFALSE 72117
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72148: LD_ADDR_VAR 0 6
72152: PUSH
72153: LD_VAR 0 7
72157: PPUSH
72158: CALL_OW 250
72162: PUSH
72163: LD_VAR 0 7
72167: PPUSH
72168: CALL_OW 251
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72177: LD_INT 35
72179: PPUSH
72180: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72184: LD_ADDR_VAR 0 4
72188: PUSH
72189: LD_EXP 78
72193: PUSH
72194: LD_VAR 0 2
72198: ARRAY
72199: PUSH
72200: LD_VAR 0 3
72204: ARRAY
72205: PUSH
72206: LD_INT 1
72208: ARRAY
72209: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72210: LD_ADDR_VAR 0 5
72214: PUSH
72215: LD_EXP 78
72219: PUSH
72220: LD_VAR 0 2
72224: ARRAY
72225: PUSH
72226: LD_VAR 0 3
72230: ARRAY
72231: PUSH
72232: LD_INT 2
72234: ARRAY
72235: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72236: LD_VAR 0 7
72240: PPUSH
72241: LD_INT 10
72243: PPUSH
72244: CALL 17371 0 2
72248: PUSH
72249: LD_INT 4
72251: ARRAY
72252: IFFALSE 72290
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72254: LD_VAR 0 7
72258: PPUSH
72259: LD_VAR 0 6
72263: PUSH
72264: LD_INT 1
72266: ARRAY
72267: PPUSH
72268: LD_VAR 0 6
72272: PUSH
72273: LD_INT 2
72275: ARRAY
72276: PPUSH
72277: CALL_OW 111
// wait ( 0 0$10 ) ;
72281: LD_INT 350
72283: PPUSH
72284: CALL_OW 67
// end else
72288: GO 72316
// begin ComMoveXY ( tmp , x , y ) ;
72290: LD_VAR 0 7
72294: PPUSH
72295: LD_VAR 0 4
72299: PPUSH
72300: LD_VAR 0 5
72304: PPUSH
72305: CALL_OW 111
// wait ( 0 0$3 ) ;
72309: LD_INT 105
72311: PPUSH
72312: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72316: LD_VAR 0 7
72320: PPUSH
72321: LD_VAR 0 4
72325: PPUSH
72326: LD_VAR 0 5
72330: PPUSH
72331: CALL_OW 307
72335: IFFALSE 72177
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72337: LD_VAR 0 7
72341: PPUSH
72342: LD_VAR 0 4
72346: PPUSH
72347: LD_VAR 0 5
72351: PPUSH
72352: LD_VAR 0 8
72356: PUSH
72357: LD_VAR 0 3
72361: ARRAY
72362: PPUSH
72363: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72367: LD_INT 35
72369: PPUSH
72370: CALL_OW 67
// until not HasTask ( tmp ) ;
72374: LD_VAR 0 7
72378: PPUSH
72379: CALL_OW 314
72383: NOT
72384: IFFALSE 72367
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72386: LD_ADDR_EXP 79
72390: PUSH
72391: LD_EXP 79
72395: PPUSH
72396: LD_VAR 0 2
72400: PUSH
72401: LD_EXP 79
72405: PUSH
72406: LD_VAR 0 2
72410: ARRAY
72411: PUSH
72412: LD_INT 1
72414: PLUS
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: PPUSH
72420: LD_VAR 0 8
72424: PUSH
72425: LD_VAR 0 3
72429: ARRAY
72430: PPUSH
72431: CALL 14774 0 3
72435: ST_TO_ADDR
// end ;
72436: GO 72094
72438: POP
72439: POP
// MC_Reset ( i , 124 ) ;
72440: LD_VAR 0 2
72444: PPUSH
72445: LD_INT 124
72447: PPUSH
72448: CALL 55524 0 2
// end ; end ;
72452: GO 71849
72454: POP
72455: POP
// end ;
72456: LD_VAR 0 1
72460: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72461: LD_INT 0
72463: PPUSH
72464: PPUSH
72465: PPUSH
// if not mc_bases then
72466: LD_EXP 43
72470: NOT
72471: IFFALSE 72475
// exit ;
72473: GO 73081
// for i = 1 to mc_bases do
72475: LD_ADDR_VAR 0 2
72479: PUSH
72480: DOUBLE
72481: LD_INT 1
72483: DEC
72484: ST_TO_ADDR
72485: LD_EXP 43
72489: PUSH
72490: FOR_TO
72491: IFFALSE 73079
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72493: LD_ADDR_VAR 0 3
72497: PUSH
72498: LD_EXP 43
72502: PUSH
72503: LD_VAR 0 2
72507: ARRAY
72508: PPUSH
72509: LD_INT 25
72511: PUSH
72512: LD_INT 4
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PPUSH
72519: CALL_OW 72
72523: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72524: LD_VAR 0 3
72528: NOT
72529: PUSH
72530: LD_EXP 80
72534: PUSH
72535: LD_VAR 0 2
72539: ARRAY
72540: NOT
72541: OR
72542: PUSH
72543: LD_EXP 43
72547: PUSH
72548: LD_VAR 0 2
72552: ARRAY
72553: PPUSH
72554: LD_INT 2
72556: PUSH
72557: LD_INT 30
72559: PUSH
72560: LD_INT 0
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 30
72569: PUSH
72570: LD_INT 1
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: LIST
72581: PPUSH
72582: CALL_OW 72
72586: NOT
72587: OR
72588: IFFALSE 72638
// begin if mc_deposits_finder [ i ] then
72590: LD_EXP 81
72594: PUSH
72595: LD_VAR 0 2
72599: ARRAY
72600: IFFALSE 72636
// begin MC_Reset ( i , 125 ) ;
72602: LD_VAR 0 2
72606: PPUSH
72607: LD_INT 125
72609: PPUSH
72610: CALL 55524 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72614: LD_ADDR_EXP 81
72618: PUSH
72619: LD_EXP 81
72623: PPUSH
72624: LD_VAR 0 2
72628: PPUSH
72629: EMPTY
72630: PPUSH
72631: CALL_OW 1
72635: ST_TO_ADDR
// end ; continue ;
72636: GO 72490
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72638: LD_EXP 80
72642: PUSH
72643: LD_VAR 0 2
72647: ARRAY
72648: PUSH
72649: LD_INT 1
72651: ARRAY
72652: PUSH
72653: LD_INT 3
72655: ARRAY
72656: PUSH
72657: LD_INT 1
72659: EQUAL
72660: PUSH
72661: LD_INT 20
72663: PPUSH
72664: LD_EXP 69
72668: PUSH
72669: LD_VAR 0 2
72673: ARRAY
72674: PPUSH
72675: CALL_OW 321
72679: PUSH
72680: LD_INT 2
72682: NONEQUAL
72683: AND
72684: IFFALSE 72734
// begin if mc_deposits_finder [ i ] then
72686: LD_EXP 81
72690: PUSH
72691: LD_VAR 0 2
72695: ARRAY
72696: IFFALSE 72732
// begin MC_Reset ( i , 125 ) ;
72698: LD_VAR 0 2
72702: PPUSH
72703: LD_INT 125
72705: PPUSH
72706: CALL 55524 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72710: LD_ADDR_EXP 81
72714: PUSH
72715: LD_EXP 81
72719: PPUSH
72720: LD_VAR 0 2
72724: PPUSH
72725: EMPTY
72726: PPUSH
72727: CALL_OW 1
72731: ST_TO_ADDR
// end ; continue ;
72732: GO 72490
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72734: LD_EXP 80
72738: PUSH
72739: LD_VAR 0 2
72743: ARRAY
72744: PUSH
72745: LD_INT 1
72747: ARRAY
72748: PUSH
72749: LD_INT 1
72751: ARRAY
72752: PPUSH
72753: LD_EXP 80
72757: PUSH
72758: LD_VAR 0 2
72762: ARRAY
72763: PUSH
72764: LD_INT 1
72766: ARRAY
72767: PUSH
72768: LD_INT 2
72770: ARRAY
72771: PPUSH
72772: LD_EXP 69
72776: PUSH
72777: LD_VAR 0 2
72781: ARRAY
72782: PPUSH
72783: CALL_OW 440
72787: IFFALSE 72830
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72789: LD_ADDR_EXP 80
72793: PUSH
72794: LD_EXP 80
72798: PPUSH
72799: LD_VAR 0 2
72803: PPUSH
72804: LD_EXP 80
72808: PUSH
72809: LD_VAR 0 2
72813: ARRAY
72814: PPUSH
72815: LD_INT 1
72817: PPUSH
72818: CALL_OW 3
72822: PPUSH
72823: CALL_OW 1
72827: ST_TO_ADDR
72828: GO 73077
// begin if not mc_deposits_finder [ i ] then
72830: LD_EXP 81
72834: PUSH
72835: LD_VAR 0 2
72839: ARRAY
72840: NOT
72841: IFFALSE 72893
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72843: LD_ADDR_EXP 81
72847: PUSH
72848: LD_EXP 81
72852: PPUSH
72853: LD_VAR 0 2
72857: PPUSH
72858: LD_VAR 0 3
72862: PUSH
72863: LD_INT 1
72865: ARRAY
72866: PUSH
72867: EMPTY
72868: LIST
72869: PPUSH
72870: CALL_OW 1
72874: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72875: LD_VAR 0 3
72879: PUSH
72880: LD_INT 1
72882: ARRAY
72883: PPUSH
72884: LD_INT 125
72886: PPUSH
72887: CALL_OW 109
// end else
72891: GO 73077
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72893: LD_EXP 81
72897: PUSH
72898: LD_VAR 0 2
72902: ARRAY
72903: PUSH
72904: LD_INT 1
72906: ARRAY
72907: PPUSH
72908: CALL_OW 310
72912: IFFALSE 72935
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72914: LD_EXP 81
72918: PUSH
72919: LD_VAR 0 2
72923: ARRAY
72924: PUSH
72925: LD_INT 1
72927: ARRAY
72928: PPUSH
72929: CALL_OW 122
72933: GO 73077
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72935: LD_EXP 81
72939: PUSH
72940: LD_VAR 0 2
72944: ARRAY
72945: PUSH
72946: LD_INT 1
72948: ARRAY
72949: PPUSH
72950: CALL_OW 314
72954: NOT
72955: PUSH
72956: LD_EXP 81
72960: PUSH
72961: LD_VAR 0 2
72965: ARRAY
72966: PUSH
72967: LD_INT 1
72969: ARRAY
72970: PPUSH
72971: LD_EXP 80
72975: PUSH
72976: LD_VAR 0 2
72980: ARRAY
72981: PUSH
72982: LD_INT 1
72984: ARRAY
72985: PUSH
72986: LD_INT 1
72988: ARRAY
72989: PPUSH
72990: LD_EXP 80
72994: PUSH
72995: LD_VAR 0 2
72999: ARRAY
73000: PUSH
73001: LD_INT 1
73003: ARRAY
73004: PUSH
73005: LD_INT 2
73007: ARRAY
73008: PPUSH
73009: CALL_OW 297
73013: PUSH
73014: LD_INT 6
73016: GREATER
73017: AND
73018: IFFALSE 73077
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
73020: LD_EXP 81
73024: PUSH
73025: LD_VAR 0 2
73029: ARRAY
73030: PUSH
73031: LD_INT 1
73033: ARRAY
73034: PPUSH
73035: LD_EXP 80
73039: PUSH
73040: LD_VAR 0 2
73044: ARRAY
73045: PUSH
73046: LD_INT 1
73048: ARRAY
73049: PUSH
73050: LD_INT 1
73052: ARRAY
73053: PPUSH
73054: LD_EXP 80
73058: PUSH
73059: LD_VAR 0 2
73063: ARRAY
73064: PUSH
73065: LD_INT 1
73067: ARRAY
73068: PUSH
73069: LD_INT 2
73071: ARRAY
73072: PPUSH
73073: CALL_OW 111
// end ; end ; end ;
73077: GO 72490
73079: POP
73080: POP
// end ;
73081: LD_VAR 0 1
73085: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
73086: LD_INT 0
73088: PPUSH
73089: PPUSH
73090: PPUSH
73091: PPUSH
73092: PPUSH
73093: PPUSH
73094: PPUSH
73095: PPUSH
73096: PPUSH
73097: PPUSH
73098: PPUSH
// if not mc_bases then
73099: LD_EXP 43
73103: NOT
73104: IFFALSE 73108
// exit ;
73106: GO 74048
// for i = 1 to mc_bases do
73108: LD_ADDR_VAR 0 2
73112: PUSH
73113: DOUBLE
73114: LD_INT 1
73116: DEC
73117: ST_TO_ADDR
73118: LD_EXP 43
73122: PUSH
73123: FOR_TO
73124: IFFALSE 74046
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73126: LD_EXP 43
73130: PUSH
73131: LD_VAR 0 2
73135: ARRAY
73136: NOT
73137: PUSH
73138: LD_EXP 66
73142: PUSH
73143: LD_VAR 0 2
73147: ARRAY
73148: OR
73149: IFFALSE 73153
// continue ;
73151: GO 73123
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73153: LD_ADDR_VAR 0 7
73157: PUSH
73158: LD_EXP 43
73162: PUSH
73163: LD_VAR 0 2
73167: ARRAY
73168: PUSH
73169: LD_INT 1
73171: ARRAY
73172: PPUSH
73173: CALL_OW 248
73177: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73178: LD_VAR 0 7
73182: PUSH
73183: LD_INT 3
73185: EQUAL
73186: PUSH
73187: LD_EXP 62
73191: PUSH
73192: LD_VAR 0 2
73196: ARRAY
73197: PUSH
73198: LD_EXP 65
73202: PUSH
73203: LD_VAR 0 2
73207: ARRAY
73208: UNION
73209: PPUSH
73210: LD_INT 33
73212: PUSH
73213: LD_INT 2
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PPUSH
73220: CALL_OW 72
73224: NOT
73225: OR
73226: IFFALSE 73230
// continue ;
73228: GO 73123
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73230: LD_ADDR_VAR 0 9
73234: PUSH
73235: LD_EXP 43
73239: PUSH
73240: LD_VAR 0 2
73244: ARRAY
73245: PPUSH
73246: LD_INT 30
73248: PUSH
73249: LD_INT 36
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PPUSH
73256: CALL_OW 72
73260: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73261: LD_ADDR_VAR 0 10
73265: PUSH
73266: LD_EXP 62
73270: PUSH
73271: LD_VAR 0 2
73275: ARRAY
73276: PPUSH
73277: LD_INT 34
73279: PUSH
73280: LD_INT 31
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: PPUSH
73287: CALL_OW 72
73291: ST_TO_ADDR
// if not cts and not mcts then
73292: LD_VAR 0 9
73296: NOT
73297: PUSH
73298: LD_VAR 0 10
73302: NOT
73303: AND
73304: IFFALSE 73308
// continue ;
73306: GO 73123
// x := cts ;
73308: LD_ADDR_VAR 0 11
73312: PUSH
73313: LD_VAR 0 9
73317: ST_TO_ADDR
// if not x then
73318: LD_VAR 0 11
73322: NOT
73323: IFFALSE 73335
// x := mcts ;
73325: LD_ADDR_VAR 0 11
73329: PUSH
73330: LD_VAR 0 10
73334: ST_TO_ADDR
// if not x then
73335: LD_VAR 0 11
73339: NOT
73340: IFFALSE 73344
// continue ;
73342: GO 73123
// if mc_remote_driver [ i ] then
73344: LD_EXP 83
73348: PUSH
73349: LD_VAR 0 2
73353: ARRAY
73354: IFFALSE 73741
// for j in mc_remote_driver [ i ] do
73356: LD_ADDR_VAR 0 3
73360: PUSH
73361: LD_EXP 83
73365: PUSH
73366: LD_VAR 0 2
73370: ARRAY
73371: PUSH
73372: FOR_IN
73373: IFFALSE 73739
// begin if GetClass ( j ) <> 3 then
73375: LD_VAR 0 3
73379: PPUSH
73380: CALL_OW 257
73384: PUSH
73385: LD_INT 3
73387: NONEQUAL
73388: IFFALSE 73441
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73390: LD_ADDR_EXP 83
73394: PUSH
73395: LD_EXP 83
73399: PPUSH
73400: LD_VAR 0 2
73404: PPUSH
73405: LD_EXP 83
73409: PUSH
73410: LD_VAR 0 2
73414: ARRAY
73415: PUSH
73416: LD_VAR 0 3
73420: DIFF
73421: PPUSH
73422: CALL_OW 1
73426: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73427: LD_VAR 0 3
73431: PPUSH
73432: LD_INT 0
73434: PPUSH
73435: CALL_OW 109
// continue ;
73439: GO 73372
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73441: LD_EXP 62
73445: PUSH
73446: LD_VAR 0 2
73450: ARRAY
73451: PPUSH
73452: LD_INT 34
73454: PUSH
73455: LD_INT 31
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PUSH
73462: LD_INT 58
73464: PUSH
73465: EMPTY
73466: LIST
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PPUSH
73472: CALL_OW 72
73476: PUSH
73477: LD_VAR 0 3
73481: PPUSH
73482: CALL 44750 0 1
73486: NOT
73487: AND
73488: IFFALSE 73559
// begin if IsInUnit ( j ) then
73490: LD_VAR 0 3
73494: PPUSH
73495: CALL_OW 310
73499: IFFALSE 73510
// ComExitBuilding ( j ) ;
73501: LD_VAR 0 3
73505: PPUSH
73506: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73510: LD_VAR 0 3
73514: PPUSH
73515: LD_EXP 62
73519: PUSH
73520: LD_VAR 0 2
73524: ARRAY
73525: PPUSH
73526: LD_INT 34
73528: PUSH
73529: LD_INT 31
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: LD_INT 58
73538: PUSH
73539: EMPTY
73540: LIST
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PPUSH
73546: CALL_OW 72
73550: PUSH
73551: LD_INT 1
73553: ARRAY
73554: PPUSH
73555: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73559: LD_VAR 0 3
73563: PPUSH
73564: CALL_OW 310
73568: NOT
73569: PUSH
73570: LD_VAR 0 3
73574: PPUSH
73575: CALL_OW 310
73579: PPUSH
73580: CALL_OW 266
73584: PUSH
73585: LD_INT 36
73587: NONEQUAL
73588: PUSH
73589: LD_VAR 0 3
73593: PPUSH
73594: CALL 44750 0 1
73598: NOT
73599: AND
73600: OR
73601: IFFALSE 73737
// begin if IsInUnit ( j ) then
73603: LD_VAR 0 3
73607: PPUSH
73608: CALL_OW 310
73612: IFFALSE 73623
// ComExitBuilding ( j ) ;
73614: LD_VAR 0 3
73618: PPUSH
73619: CALL_OW 122
// ct := 0 ;
73623: LD_ADDR_VAR 0 8
73627: PUSH
73628: LD_INT 0
73630: ST_TO_ADDR
// for k in x do
73631: LD_ADDR_VAR 0 4
73635: PUSH
73636: LD_VAR 0 11
73640: PUSH
73641: FOR_IN
73642: IFFALSE 73715
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73644: LD_VAR 0 4
73648: PPUSH
73649: CALL_OW 264
73653: PUSH
73654: LD_INT 31
73656: EQUAL
73657: PUSH
73658: LD_VAR 0 4
73662: PPUSH
73663: CALL_OW 311
73667: NOT
73668: AND
73669: PUSH
73670: LD_VAR 0 4
73674: PPUSH
73675: CALL_OW 266
73679: PUSH
73680: LD_INT 36
73682: EQUAL
73683: PUSH
73684: LD_VAR 0 4
73688: PPUSH
73689: CALL_OW 313
73693: PUSH
73694: LD_INT 3
73696: LESS
73697: AND
73698: OR
73699: IFFALSE 73713
// begin ct := k ;
73701: LD_ADDR_VAR 0 8
73705: PUSH
73706: LD_VAR 0 4
73710: ST_TO_ADDR
// break ;
73711: GO 73715
// end ;
73713: GO 73641
73715: POP
73716: POP
// if ct then
73717: LD_VAR 0 8
73721: IFFALSE 73737
// ComEnterUnit ( j , ct ) ;
73723: LD_VAR 0 3
73727: PPUSH
73728: LD_VAR 0 8
73732: PPUSH
73733: CALL_OW 120
// end ; end ;
73737: GO 73372
73739: POP
73740: POP
// places := 0 ;
73741: LD_ADDR_VAR 0 5
73745: PUSH
73746: LD_INT 0
73748: ST_TO_ADDR
// for j = 1 to x do
73749: LD_ADDR_VAR 0 3
73753: PUSH
73754: DOUBLE
73755: LD_INT 1
73757: DEC
73758: ST_TO_ADDR
73759: LD_VAR 0 11
73763: PUSH
73764: FOR_TO
73765: IFFALSE 73841
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73767: LD_VAR 0 11
73771: PUSH
73772: LD_VAR 0 3
73776: ARRAY
73777: PPUSH
73778: CALL_OW 264
73782: PUSH
73783: LD_INT 31
73785: EQUAL
73786: IFFALSE 73804
// places := places + 1 else
73788: LD_ADDR_VAR 0 5
73792: PUSH
73793: LD_VAR 0 5
73797: PUSH
73798: LD_INT 1
73800: PLUS
73801: ST_TO_ADDR
73802: GO 73839
// if GetBType ( x [ j ] ) = b_control_tower then
73804: LD_VAR 0 11
73808: PUSH
73809: LD_VAR 0 3
73813: ARRAY
73814: PPUSH
73815: CALL_OW 266
73819: PUSH
73820: LD_INT 36
73822: EQUAL
73823: IFFALSE 73839
// places := places + 3 ;
73825: LD_ADDR_VAR 0 5
73829: PUSH
73830: LD_VAR 0 5
73834: PUSH
73835: LD_INT 3
73837: PLUS
73838: ST_TO_ADDR
73839: GO 73764
73841: POP
73842: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73843: LD_VAR 0 5
73847: PUSH
73848: LD_INT 0
73850: EQUAL
73851: PUSH
73852: LD_VAR 0 5
73856: PUSH
73857: LD_EXP 83
73861: PUSH
73862: LD_VAR 0 2
73866: ARRAY
73867: LESSEQUAL
73868: OR
73869: IFFALSE 73873
// continue ;
73871: GO 73123
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73873: LD_ADDR_VAR 0 6
73877: PUSH
73878: LD_EXP 43
73882: PUSH
73883: LD_VAR 0 2
73887: ARRAY
73888: PPUSH
73889: LD_INT 25
73891: PUSH
73892: LD_INT 3
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PPUSH
73899: CALL_OW 72
73903: PUSH
73904: LD_EXP 83
73908: PUSH
73909: LD_VAR 0 2
73913: ARRAY
73914: DIFF
73915: PPUSH
73916: LD_INT 3
73918: PPUSH
73919: CALL 45650 0 2
73923: ST_TO_ADDR
// for j in tmp do
73924: LD_ADDR_VAR 0 3
73928: PUSH
73929: LD_VAR 0 6
73933: PUSH
73934: FOR_IN
73935: IFFALSE 73970
// if GetTag ( j ) > 0 then
73937: LD_VAR 0 3
73941: PPUSH
73942: CALL_OW 110
73946: PUSH
73947: LD_INT 0
73949: GREATER
73950: IFFALSE 73968
// tmp := tmp diff j ;
73952: LD_ADDR_VAR 0 6
73956: PUSH
73957: LD_VAR 0 6
73961: PUSH
73962: LD_VAR 0 3
73966: DIFF
73967: ST_TO_ADDR
73968: GO 73934
73970: POP
73971: POP
// if not tmp then
73972: LD_VAR 0 6
73976: NOT
73977: IFFALSE 73981
// continue ;
73979: GO 73123
// if places then
73981: LD_VAR 0 5
73985: IFFALSE 74044
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73987: LD_ADDR_EXP 83
73991: PUSH
73992: LD_EXP 83
73996: PPUSH
73997: LD_VAR 0 2
74001: PPUSH
74002: LD_EXP 83
74006: PUSH
74007: LD_VAR 0 2
74011: ARRAY
74012: PUSH
74013: LD_VAR 0 6
74017: PUSH
74018: LD_INT 1
74020: ARRAY
74021: UNION
74022: PPUSH
74023: CALL_OW 1
74027: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
74028: LD_VAR 0 6
74032: PUSH
74033: LD_INT 1
74035: ARRAY
74036: PPUSH
74037: LD_INT 126
74039: PPUSH
74040: CALL_OW 109
// end ; end ;
74044: GO 73123
74046: POP
74047: POP
// end ;
74048: LD_VAR 0 1
74052: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
74053: LD_INT 0
74055: PPUSH
74056: PPUSH
74057: PPUSH
74058: PPUSH
74059: PPUSH
74060: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
74061: LD_VAR 0 1
74065: NOT
74066: PUSH
74067: LD_VAR 0 2
74071: NOT
74072: OR
74073: PUSH
74074: LD_VAR 0 3
74078: NOT
74079: OR
74080: PUSH
74081: LD_VAR 0 4
74085: PUSH
74086: LD_INT 1
74088: PUSH
74089: LD_INT 2
74091: PUSH
74092: LD_INT 3
74094: PUSH
74095: LD_INT 4
74097: PUSH
74098: LD_INT 5
74100: PUSH
74101: LD_INT 8
74103: PUSH
74104: LD_INT 9
74106: PUSH
74107: LD_INT 15
74109: PUSH
74110: LD_INT 16
74112: PUSH
74113: EMPTY
74114: LIST
74115: LIST
74116: LIST
74117: LIST
74118: LIST
74119: LIST
74120: LIST
74121: LIST
74122: LIST
74123: IN
74124: NOT
74125: OR
74126: IFFALSE 74130
// exit ;
74128: GO 74988
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74130: LD_ADDR_VAR 0 2
74134: PUSH
74135: LD_VAR 0 2
74139: PPUSH
74140: LD_INT 21
74142: PUSH
74143: LD_INT 3
74145: PUSH
74146: EMPTY
74147: LIST
74148: LIST
74149: PUSH
74150: LD_INT 24
74152: PUSH
74153: LD_INT 250
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: EMPTY
74161: LIST
74162: LIST
74163: PPUSH
74164: CALL_OW 72
74168: ST_TO_ADDR
// case class of 1 , 15 :
74169: LD_VAR 0 4
74173: PUSH
74174: LD_INT 1
74176: DOUBLE
74177: EQUAL
74178: IFTRUE 74188
74180: LD_INT 15
74182: DOUBLE
74183: EQUAL
74184: IFTRUE 74188
74186: GO 74273
74188: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74189: LD_ADDR_VAR 0 8
74193: PUSH
74194: LD_VAR 0 2
74198: PPUSH
74199: LD_INT 2
74201: PUSH
74202: LD_INT 30
74204: PUSH
74205: LD_INT 32
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: PUSH
74212: LD_INT 30
74214: PUSH
74215: LD_INT 31
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: EMPTY
74223: LIST
74224: LIST
74225: LIST
74226: PPUSH
74227: CALL_OW 72
74231: PUSH
74232: LD_VAR 0 2
74236: PPUSH
74237: LD_INT 2
74239: PUSH
74240: LD_INT 30
74242: PUSH
74243: LD_INT 4
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: PUSH
74250: LD_INT 30
74252: PUSH
74253: LD_INT 5
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: LIST
74264: PPUSH
74265: CALL_OW 72
74269: ADD
74270: ST_TO_ADDR
74271: GO 74519
74273: LD_INT 2
74275: DOUBLE
74276: EQUAL
74277: IFTRUE 74287
74279: LD_INT 16
74281: DOUBLE
74282: EQUAL
74283: IFTRUE 74287
74285: GO 74333
74287: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74288: LD_ADDR_VAR 0 8
74292: PUSH
74293: LD_VAR 0 2
74297: PPUSH
74298: LD_INT 2
74300: PUSH
74301: LD_INT 30
74303: PUSH
74304: LD_INT 0
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 30
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: EMPTY
74322: LIST
74323: LIST
74324: LIST
74325: PPUSH
74326: CALL_OW 72
74330: ST_TO_ADDR
74331: GO 74519
74333: LD_INT 3
74335: DOUBLE
74336: EQUAL
74337: IFTRUE 74341
74339: GO 74387
74341: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74342: LD_ADDR_VAR 0 8
74346: PUSH
74347: LD_VAR 0 2
74351: PPUSH
74352: LD_INT 2
74354: PUSH
74355: LD_INT 30
74357: PUSH
74358: LD_INT 2
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 30
74367: PUSH
74368: LD_INT 3
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: LIST
74379: PPUSH
74380: CALL_OW 72
74384: ST_TO_ADDR
74385: GO 74519
74387: LD_INT 4
74389: DOUBLE
74390: EQUAL
74391: IFTRUE 74395
74393: GO 74452
74395: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74396: LD_ADDR_VAR 0 8
74400: PUSH
74401: LD_VAR 0 2
74405: PPUSH
74406: LD_INT 2
74408: PUSH
74409: LD_INT 30
74411: PUSH
74412: LD_INT 6
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PUSH
74419: LD_INT 30
74421: PUSH
74422: LD_INT 7
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 30
74431: PUSH
74432: LD_INT 8
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: LIST
74443: LIST
74444: PPUSH
74445: CALL_OW 72
74449: ST_TO_ADDR
74450: GO 74519
74452: LD_INT 5
74454: DOUBLE
74455: EQUAL
74456: IFTRUE 74472
74458: LD_INT 8
74460: DOUBLE
74461: EQUAL
74462: IFTRUE 74472
74464: LD_INT 9
74466: DOUBLE
74467: EQUAL
74468: IFTRUE 74472
74470: GO 74518
74472: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74473: LD_ADDR_VAR 0 8
74477: PUSH
74478: LD_VAR 0 2
74482: PPUSH
74483: LD_INT 2
74485: PUSH
74486: LD_INT 30
74488: PUSH
74489: LD_INT 4
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 30
74498: PUSH
74499: LD_INT 5
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: LIST
74510: PPUSH
74511: CALL_OW 72
74515: ST_TO_ADDR
74516: GO 74519
74518: POP
// if not tmp then
74519: LD_VAR 0 8
74523: NOT
74524: IFFALSE 74528
// exit ;
74526: GO 74988
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74528: LD_VAR 0 4
74532: PUSH
74533: LD_INT 1
74535: PUSH
74536: LD_INT 15
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: IN
74543: PUSH
74544: LD_EXP 52
74548: PUSH
74549: LD_VAR 0 1
74553: ARRAY
74554: AND
74555: IFFALSE 74711
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74557: LD_ADDR_VAR 0 9
74561: PUSH
74562: LD_EXP 52
74566: PUSH
74567: LD_VAR 0 1
74571: ARRAY
74572: PUSH
74573: LD_INT 1
74575: ARRAY
74576: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74577: LD_VAR 0 9
74581: PUSH
74582: LD_EXP 53
74586: PUSH
74587: LD_VAR 0 1
74591: ARRAY
74592: IN
74593: NOT
74594: IFFALSE 74709
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74596: LD_ADDR_EXP 53
74600: PUSH
74601: LD_EXP 53
74605: PPUSH
74606: LD_VAR 0 1
74610: PUSH
74611: LD_EXP 53
74615: PUSH
74616: LD_VAR 0 1
74620: ARRAY
74621: PUSH
74622: LD_INT 1
74624: PLUS
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PPUSH
74630: LD_VAR 0 9
74634: PPUSH
74635: CALL 14774 0 3
74639: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74640: LD_ADDR_EXP 52
74644: PUSH
74645: LD_EXP 52
74649: PPUSH
74650: LD_VAR 0 1
74654: PPUSH
74655: LD_EXP 52
74659: PUSH
74660: LD_VAR 0 1
74664: ARRAY
74665: PUSH
74666: LD_VAR 0 9
74670: DIFF
74671: PPUSH
74672: CALL_OW 1
74676: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74677: LD_VAR 0 3
74681: PPUSH
74682: LD_EXP 53
74686: PUSH
74687: LD_VAR 0 1
74691: ARRAY
74692: PUSH
74693: LD_EXP 53
74697: PUSH
74698: LD_VAR 0 1
74702: ARRAY
74703: ARRAY
74704: PPUSH
74705: CALL_OW 120
// end ; exit ;
74709: GO 74988
// end ; if tmp > 1 then
74711: LD_VAR 0 8
74715: PUSH
74716: LD_INT 1
74718: GREATER
74719: IFFALSE 74823
// for i = 2 to tmp do
74721: LD_ADDR_VAR 0 6
74725: PUSH
74726: DOUBLE
74727: LD_INT 2
74729: DEC
74730: ST_TO_ADDR
74731: LD_VAR 0 8
74735: PUSH
74736: FOR_TO
74737: IFFALSE 74821
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74739: LD_VAR 0 8
74743: PUSH
74744: LD_VAR 0 6
74748: ARRAY
74749: PPUSH
74750: CALL_OW 461
74754: PUSH
74755: LD_INT 6
74757: EQUAL
74758: IFFALSE 74819
// begin x := tmp [ i ] ;
74760: LD_ADDR_VAR 0 9
74764: PUSH
74765: LD_VAR 0 8
74769: PUSH
74770: LD_VAR 0 6
74774: ARRAY
74775: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74776: LD_ADDR_VAR 0 8
74780: PUSH
74781: LD_VAR 0 8
74785: PPUSH
74786: LD_VAR 0 6
74790: PPUSH
74791: CALL_OW 3
74795: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74796: LD_ADDR_VAR 0 8
74800: PUSH
74801: LD_VAR 0 8
74805: PPUSH
74806: LD_INT 1
74808: PPUSH
74809: LD_VAR 0 9
74813: PPUSH
74814: CALL_OW 2
74818: ST_TO_ADDR
// end ;
74819: GO 74736
74821: POP
74822: POP
// for i in tmp do
74823: LD_ADDR_VAR 0 6
74827: PUSH
74828: LD_VAR 0 8
74832: PUSH
74833: FOR_IN
74834: IFFALSE 74861
// begin if IsNotFull ( i ) then
74836: LD_VAR 0 6
74840: PPUSH
74841: CALL 11996 0 1
74845: IFFALSE 74859
// begin j := i ;
74847: LD_ADDR_VAR 0 7
74851: PUSH
74852: LD_VAR 0 6
74856: ST_TO_ADDR
// break ;
74857: GO 74861
// end ; end ;
74859: GO 74833
74861: POP
74862: POP
// if j then
74863: LD_VAR 0 7
74867: IFFALSE 74885
// ComEnterUnit ( unit , j ) else
74869: LD_VAR 0 3
74873: PPUSH
74874: LD_VAR 0 7
74878: PPUSH
74879: CALL_OW 120
74883: GO 74988
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74885: LD_ADDR_VAR 0 10
74889: PUSH
74890: LD_VAR 0 2
74894: PPUSH
74895: LD_INT 2
74897: PUSH
74898: LD_INT 30
74900: PUSH
74901: LD_INT 0
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 30
74910: PUSH
74911: LD_INT 1
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: LIST
74922: PPUSH
74923: CALL_OW 72
74927: ST_TO_ADDR
// if depot then
74928: LD_VAR 0 10
74932: IFFALSE 74988
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74934: LD_ADDR_VAR 0 10
74938: PUSH
74939: LD_VAR 0 10
74943: PPUSH
74944: LD_VAR 0 3
74948: PPUSH
74949: CALL_OW 74
74953: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74954: LD_VAR 0 3
74958: PPUSH
74959: LD_VAR 0 10
74963: PPUSH
74964: CALL_OW 296
74968: PUSH
74969: LD_INT 10
74971: GREATER
74972: IFFALSE 74988
// ComStandNearbyBuilding ( unit , depot ) ;
74974: LD_VAR 0 3
74978: PPUSH
74979: LD_VAR 0 10
74983: PPUSH
74984: CALL 11376 0 2
// end ; end ; end ;
74988: LD_VAR 0 5
74992: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74993: LD_INT 0
74995: PPUSH
74996: PPUSH
74997: PPUSH
74998: PPUSH
// if not mc_bases then
74999: LD_EXP 43
75003: NOT
75004: IFFALSE 75008
// exit ;
75006: GO 75247
// for i = 1 to mc_bases do
75008: LD_ADDR_VAR 0 2
75012: PUSH
75013: DOUBLE
75014: LD_INT 1
75016: DEC
75017: ST_TO_ADDR
75018: LD_EXP 43
75022: PUSH
75023: FOR_TO
75024: IFFALSE 75245
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
75026: LD_ADDR_VAR 0 4
75030: PUSH
75031: LD_EXP 43
75035: PUSH
75036: LD_VAR 0 2
75040: ARRAY
75041: PPUSH
75042: LD_INT 21
75044: PUSH
75045: LD_INT 1
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PPUSH
75052: CALL_OW 72
75056: PUSH
75057: LD_EXP 72
75061: PUSH
75062: LD_VAR 0 2
75066: ARRAY
75067: UNION
75068: ST_TO_ADDR
// if not tmp then
75069: LD_VAR 0 4
75073: NOT
75074: IFFALSE 75078
// continue ;
75076: GO 75023
// for j in tmp do
75078: LD_ADDR_VAR 0 3
75082: PUSH
75083: LD_VAR 0 4
75087: PUSH
75088: FOR_IN
75089: IFFALSE 75241
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75091: LD_VAR 0 3
75095: PPUSH
75096: CALL_OW 110
75100: NOT
75101: PUSH
75102: LD_VAR 0 3
75106: PPUSH
75107: CALL_OW 314
75111: NOT
75112: AND
75113: PUSH
75114: LD_VAR 0 3
75118: PPUSH
75119: CALL_OW 311
75123: NOT
75124: AND
75125: PUSH
75126: LD_VAR 0 3
75130: PPUSH
75131: CALL_OW 310
75135: NOT
75136: AND
75137: PUSH
75138: LD_VAR 0 3
75142: PUSH
75143: LD_EXP 46
75147: PUSH
75148: LD_VAR 0 2
75152: ARRAY
75153: PUSH
75154: LD_INT 1
75156: ARRAY
75157: IN
75158: NOT
75159: AND
75160: PUSH
75161: LD_VAR 0 3
75165: PUSH
75166: LD_EXP 46
75170: PUSH
75171: LD_VAR 0 2
75175: ARRAY
75176: PUSH
75177: LD_INT 2
75179: ARRAY
75180: IN
75181: NOT
75182: AND
75183: PUSH
75184: LD_VAR 0 3
75188: PUSH
75189: LD_EXP 55
75193: PUSH
75194: LD_VAR 0 2
75198: ARRAY
75199: IN
75200: NOT
75201: AND
75202: IFFALSE 75239
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75204: LD_VAR 0 2
75208: PPUSH
75209: LD_EXP 43
75213: PUSH
75214: LD_VAR 0 2
75218: ARRAY
75219: PPUSH
75220: LD_VAR 0 3
75224: PPUSH
75225: LD_VAR 0 3
75229: PPUSH
75230: CALL_OW 257
75234: PPUSH
75235: CALL 74053 0 4
// end ;
75239: GO 75088
75241: POP
75242: POP
// end ;
75243: GO 75023
75245: POP
75246: POP
// end ;
75247: LD_VAR 0 1
75251: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
75252: LD_INT 0
75254: PPUSH
75255: PPUSH
75256: PPUSH
75257: PPUSH
75258: PPUSH
75259: PPUSH
// if not mc_bases [ base ] then
75260: LD_EXP 43
75264: PUSH
75265: LD_VAR 0 1
75269: ARRAY
75270: NOT
75271: IFFALSE 75275
// exit ;
75273: GO 75476
// tmp := [ ] ;
75275: LD_ADDR_VAR 0 6
75279: PUSH
75280: EMPTY
75281: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75282: LD_ADDR_VAR 0 7
75286: PUSH
75287: LD_VAR 0 3
75291: PPUSH
75292: LD_INT 0
75294: PPUSH
75295: CALL_OW 517
75299: ST_TO_ADDR
// if not list then
75300: LD_VAR 0 7
75304: NOT
75305: IFFALSE 75309
// exit ;
75307: GO 75476
// c := Count ( list [ 1 ] ) ;
75309: LD_ADDR_VAR 0 9
75313: PUSH
75314: LD_VAR 0 7
75318: PUSH
75319: LD_INT 1
75321: ARRAY
75322: PPUSH
75323: CALL 11914 0 1
75327: ST_TO_ADDR
// if amount > c then
75328: LD_VAR 0 2
75332: PUSH
75333: LD_VAR 0 9
75337: GREATER
75338: IFFALSE 75350
// amount := c ;
75340: LD_ADDR_VAR 0 2
75344: PUSH
75345: LD_VAR 0 9
75349: ST_TO_ADDR
// for i := 1 to amount do
75350: LD_ADDR_VAR 0 5
75354: PUSH
75355: DOUBLE
75356: LD_INT 1
75358: DEC
75359: ST_TO_ADDR
75360: LD_VAR 0 2
75364: PUSH
75365: FOR_TO
75366: IFFALSE 75424
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
75368: LD_ADDR_VAR 0 6
75372: PUSH
75373: LD_VAR 0 6
75377: PPUSH
75378: LD_VAR 0 5
75382: PPUSH
75383: LD_VAR 0 7
75387: PUSH
75388: LD_INT 1
75390: ARRAY
75391: PUSH
75392: LD_VAR 0 5
75396: ARRAY
75397: PUSH
75398: LD_VAR 0 7
75402: PUSH
75403: LD_INT 2
75405: ARRAY
75406: PUSH
75407: LD_VAR 0 5
75411: ARRAY
75412: PUSH
75413: EMPTY
75414: LIST
75415: LIST
75416: PPUSH
75417: CALL_OW 1
75421: ST_TO_ADDR
75422: GO 75365
75424: POP
75425: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75426: LD_ADDR_EXP 56
75430: PUSH
75431: LD_EXP 56
75435: PPUSH
75436: LD_VAR 0 1
75440: PPUSH
75441: LD_VAR 0 6
75445: PPUSH
75446: CALL_OW 1
75450: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75451: LD_ADDR_EXP 58
75455: PUSH
75456: LD_EXP 58
75460: PPUSH
75461: LD_VAR 0 1
75465: PPUSH
75466: LD_VAR 0 3
75470: PPUSH
75471: CALL_OW 1
75475: ST_TO_ADDR
// end ;
75476: LD_VAR 0 4
75480: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75481: LD_INT 0
75483: PPUSH
// if not mc_bases [ base ] then
75484: LD_EXP 43
75488: PUSH
75489: LD_VAR 0 1
75493: ARRAY
75494: NOT
75495: IFFALSE 75499
// exit ;
75497: GO 75524
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75499: LD_ADDR_EXP 48
75503: PUSH
75504: LD_EXP 48
75508: PPUSH
75509: LD_VAR 0 1
75513: PPUSH
75514: LD_VAR 0 2
75518: PPUSH
75519: CALL_OW 1
75523: ST_TO_ADDR
// end ;
75524: LD_VAR 0 3
75528: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75529: LD_INT 0
75531: PPUSH
// if not mc_bases [ base ] then
75532: LD_EXP 43
75536: PUSH
75537: LD_VAR 0 1
75541: ARRAY
75542: NOT
75543: IFFALSE 75547
// exit ;
75545: GO 75584
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75547: LD_ADDR_EXP 48
75551: PUSH
75552: LD_EXP 48
75556: PPUSH
75557: LD_VAR 0 1
75561: PPUSH
75562: LD_EXP 48
75566: PUSH
75567: LD_VAR 0 1
75571: ARRAY
75572: PUSH
75573: LD_VAR 0 2
75577: UNION
75578: PPUSH
75579: CALL_OW 1
75583: ST_TO_ADDR
// end ;
75584: LD_VAR 0 3
75588: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75589: LD_INT 0
75591: PPUSH
// if not mc_bases [ base ] then
75592: LD_EXP 43
75596: PUSH
75597: LD_VAR 0 1
75601: ARRAY
75602: NOT
75603: IFFALSE 75607
// exit ;
75605: GO 75632
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75607: LD_ADDR_EXP 64
75611: PUSH
75612: LD_EXP 64
75616: PPUSH
75617: LD_VAR 0 1
75621: PPUSH
75622: LD_VAR 0 2
75626: PPUSH
75627: CALL_OW 1
75631: ST_TO_ADDR
// end ;
75632: LD_VAR 0 3
75636: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75637: LD_INT 0
75639: PPUSH
// if not mc_bases [ base ] then
75640: LD_EXP 43
75644: PUSH
75645: LD_VAR 0 1
75649: ARRAY
75650: NOT
75651: IFFALSE 75655
// exit ;
75653: GO 75692
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75655: LD_ADDR_EXP 64
75659: PUSH
75660: LD_EXP 64
75664: PPUSH
75665: LD_VAR 0 1
75669: PPUSH
75670: LD_EXP 64
75674: PUSH
75675: LD_VAR 0 1
75679: ARRAY
75680: PUSH
75681: LD_VAR 0 2
75685: ADD
75686: PPUSH
75687: CALL_OW 1
75691: ST_TO_ADDR
// end ;
75692: LD_VAR 0 3
75696: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75697: LD_INT 0
75699: PPUSH
// if not mc_bases [ base ] then
75700: LD_EXP 43
75704: PUSH
75705: LD_VAR 0 1
75709: ARRAY
75710: NOT
75711: IFFALSE 75715
// exit ;
75713: GO 75769
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75715: LD_ADDR_EXP 65
75719: PUSH
75720: LD_EXP 65
75724: PPUSH
75725: LD_VAR 0 1
75729: PPUSH
75730: LD_VAR 0 2
75734: PPUSH
75735: CALL_OW 1
75739: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75740: LD_ADDR_EXP 54
75744: PUSH
75745: LD_EXP 54
75749: PPUSH
75750: LD_VAR 0 1
75754: PPUSH
75755: LD_VAR 0 2
75759: PUSH
75760: LD_INT 0
75762: PLUS
75763: PPUSH
75764: CALL_OW 1
75768: ST_TO_ADDR
// end ;
75769: LD_VAR 0 3
75773: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75774: LD_INT 0
75776: PPUSH
// if not mc_bases [ base ] then
75777: LD_EXP 43
75781: PUSH
75782: LD_VAR 0 1
75786: ARRAY
75787: NOT
75788: IFFALSE 75792
// exit ;
75790: GO 75817
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75792: LD_ADDR_EXP 54
75796: PUSH
75797: LD_EXP 54
75801: PPUSH
75802: LD_VAR 0 1
75806: PPUSH
75807: LD_VAR 0 2
75811: PPUSH
75812: CALL_OW 1
75816: ST_TO_ADDR
// end ;
75817: LD_VAR 0 3
75821: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75822: LD_INT 0
75824: PPUSH
75825: PPUSH
75826: PPUSH
75827: PPUSH
// if not mc_bases [ base ] then
75828: LD_EXP 43
75832: PUSH
75833: LD_VAR 0 1
75837: ARRAY
75838: NOT
75839: IFFALSE 75843
// exit ;
75841: GO 75908
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75843: LD_ADDR_EXP 63
75847: PUSH
75848: LD_EXP 63
75852: PPUSH
75853: LD_VAR 0 1
75857: PUSH
75858: LD_EXP 63
75862: PUSH
75863: LD_VAR 0 1
75867: ARRAY
75868: PUSH
75869: LD_INT 1
75871: PLUS
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PPUSH
75877: LD_VAR 0 1
75881: PUSH
75882: LD_VAR 0 2
75886: PUSH
75887: LD_VAR 0 3
75891: PUSH
75892: LD_VAR 0 4
75896: PUSH
75897: EMPTY
75898: LIST
75899: LIST
75900: LIST
75901: LIST
75902: PPUSH
75903: CALL 14774 0 3
75907: ST_TO_ADDR
// end ;
75908: LD_VAR 0 5
75912: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75913: LD_INT 0
75915: PPUSH
// if not mc_bases [ base ] then
75916: LD_EXP 43
75920: PUSH
75921: LD_VAR 0 1
75925: ARRAY
75926: NOT
75927: IFFALSE 75931
// exit ;
75929: GO 75956
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75931: LD_ADDR_EXP 80
75935: PUSH
75936: LD_EXP 80
75940: PPUSH
75941: LD_VAR 0 1
75945: PPUSH
75946: LD_VAR 0 2
75950: PPUSH
75951: CALL_OW 1
75955: ST_TO_ADDR
// end ;
75956: LD_VAR 0 3
75960: RET
// export function MC_GetMinesField ( base ) ; begin
75961: LD_INT 0
75963: PPUSH
// result := mc_mines [ base ] ;
75964: LD_ADDR_VAR 0 2
75968: PUSH
75969: LD_EXP 56
75973: PUSH
75974: LD_VAR 0 1
75978: ARRAY
75979: ST_TO_ADDR
// end ;
75980: LD_VAR 0 2
75984: RET
// export function MC_GetProduceList ( base ) ; begin
75985: LD_INT 0
75987: PPUSH
// result := mc_produce [ base ] ;
75988: LD_ADDR_VAR 0 2
75992: PUSH
75993: LD_EXP 64
75997: PUSH
75998: LD_VAR 0 1
76002: ARRAY
76003: ST_TO_ADDR
// end ;
76004: LD_VAR 0 2
76008: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
76009: LD_INT 0
76011: PPUSH
76012: PPUSH
// if not mc_bases then
76013: LD_EXP 43
76017: NOT
76018: IFFALSE 76022
// exit ;
76020: GO 76087
// if mc_bases [ base ] then
76022: LD_EXP 43
76026: PUSH
76027: LD_VAR 0 1
76031: ARRAY
76032: IFFALSE 76087
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76034: LD_ADDR_VAR 0 3
76038: PUSH
76039: LD_EXP 43
76043: PUSH
76044: LD_VAR 0 1
76048: ARRAY
76049: PPUSH
76050: LD_INT 30
76052: PUSH
76053: LD_VAR 0 2
76057: PUSH
76058: EMPTY
76059: LIST
76060: LIST
76061: PPUSH
76062: CALL_OW 72
76066: ST_TO_ADDR
// if result then
76067: LD_VAR 0 3
76071: IFFALSE 76087
// result := result [ 1 ] ;
76073: LD_ADDR_VAR 0 3
76077: PUSH
76078: LD_VAR 0 3
76082: PUSH
76083: LD_INT 1
76085: ARRAY
76086: ST_TO_ADDR
// end ; end ;
76087: LD_VAR 0 3
76091: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76092: LD_INT 0
76094: PPUSH
76095: PPUSH
// if not mc_bases then
76096: LD_EXP 43
76100: NOT
76101: IFFALSE 76105
// exit ;
76103: GO 76150
// if mc_bases [ base ] then
76105: LD_EXP 43
76109: PUSH
76110: LD_VAR 0 1
76114: ARRAY
76115: IFFALSE 76150
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76117: LD_ADDR_VAR 0 3
76121: PUSH
76122: LD_EXP 43
76126: PUSH
76127: LD_VAR 0 1
76131: ARRAY
76132: PPUSH
76133: LD_INT 30
76135: PUSH
76136: LD_VAR 0 2
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PPUSH
76145: CALL_OW 72
76149: ST_TO_ADDR
// end ;
76150: LD_VAR 0 3
76154: RET
// export function MC_SetTame ( base , area ) ; begin
76155: LD_INT 0
76157: PPUSH
// if not mc_bases or not base then
76158: LD_EXP 43
76162: NOT
76163: PUSH
76164: LD_VAR 0 1
76168: NOT
76169: OR
76170: IFFALSE 76174
// exit ;
76172: GO 76199
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76174: LD_ADDR_EXP 71
76178: PUSH
76179: LD_EXP 71
76183: PPUSH
76184: LD_VAR 0 1
76188: PPUSH
76189: LD_VAR 0 2
76193: PPUSH
76194: CALL_OW 1
76198: ST_TO_ADDR
// end ;
76199: LD_VAR 0 3
76203: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76204: LD_INT 0
76206: PPUSH
76207: PPUSH
// if not mc_bases or not base then
76208: LD_EXP 43
76212: NOT
76213: PUSH
76214: LD_VAR 0 1
76218: NOT
76219: OR
76220: IFFALSE 76224
// exit ;
76222: GO 76326
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76224: LD_ADDR_VAR 0 4
76228: PUSH
76229: LD_EXP 43
76233: PUSH
76234: LD_VAR 0 1
76238: ARRAY
76239: PPUSH
76240: LD_INT 30
76242: PUSH
76243: LD_VAR 0 2
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PPUSH
76252: CALL_OW 72
76256: ST_TO_ADDR
// if not tmp then
76257: LD_VAR 0 4
76261: NOT
76262: IFFALSE 76266
// exit ;
76264: GO 76326
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76266: LD_ADDR_EXP 75
76270: PUSH
76271: LD_EXP 75
76275: PPUSH
76276: LD_VAR 0 1
76280: PPUSH
76281: LD_EXP 75
76285: PUSH
76286: LD_VAR 0 1
76290: ARRAY
76291: PPUSH
76292: LD_EXP 75
76296: PUSH
76297: LD_VAR 0 1
76301: ARRAY
76302: PUSH
76303: LD_INT 1
76305: PLUS
76306: PPUSH
76307: LD_VAR 0 4
76311: PUSH
76312: LD_INT 1
76314: ARRAY
76315: PPUSH
76316: CALL_OW 2
76320: PPUSH
76321: CALL_OW 1
76325: ST_TO_ADDR
// end ;
76326: LD_VAR 0 3
76330: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76331: LD_INT 0
76333: PPUSH
76334: PPUSH
// if not mc_bases or not base or not kinds then
76335: LD_EXP 43
76339: NOT
76340: PUSH
76341: LD_VAR 0 1
76345: NOT
76346: OR
76347: PUSH
76348: LD_VAR 0 2
76352: NOT
76353: OR
76354: IFFALSE 76358
// exit ;
76356: GO 76419
// for i in kinds do
76358: LD_ADDR_VAR 0 4
76362: PUSH
76363: LD_VAR 0 2
76367: PUSH
76368: FOR_IN
76369: IFFALSE 76417
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76371: LD_ADDR_EXP 77
76375: PUSH
76376: LD_EXP 77
76380: PPUSH
76381: LD_VAR 0 1
76385: PUSH
76386: LD_EXP 77
76390: PUSH
76391: LD_VAR 0 1
76395: ARRAY
76396: PUSH
76397: LD_INT 1
76399: PLUS
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PPUSH
76405: LD_VAR 0 4
76409: PPUSH
76410: CALL 14774 0 3
76414: ST_TO_ADDR
76415: GO 76368
76417: POP
76418: POP
// end ;
76419: LD_VAR 0 3
76423: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76424: LD_INT 0
76426: PPUSH
// if not mc_bases or not base or not areas then
76427: LD_EXP 43
76431: NOT
76432: PUSH
76433: LD_VAR 0 1
76437: NOT
76438: OR
76439: PUSH
76440: LD_VAR 0 2
76444: NOT
76445: OR
76446: IFFALSE 76450
// exit ;
76448: GO 76475
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76450: LD_ADDR_EXP 61
76454: PUSH
76455: LD_EXP 61
76459: PPUSH
76460: LD_VAR 0 1
76464: PPUSH
76465: LD_VAR 0 2
76469: PPUSH
76470: CALL_OW 1
76474: ST_TO_ADDR
// end ;
76475: LD_VAR 0 3
76479: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76480: LD_INT 0
76482: PPUSH
// if not mc_bases or not base or not teleports_exit then
76483: LD_EXP 43
76487: NOT
76488: PUSH
76489: LD_VAR 0 1
76493: NOT
76494: OR
76495: PUSH
76496: LD_VAR 0 2
76500: NOT
76501: OR
76502: IFFALSE 76506
// exit ;
76504: GO 76531
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76506: LD_ADDR_EXP 78
76510: PUSH
76511: LD_EXP 78
76515: PPUSH
76516: LD_VAR 0 1
76520: PPUSH
76521: LD_VAR 0 2
76525: PPUSH
76526: CALL_OW 1
76530: ST_TO_ADDR
// end ;
76531: LD_VAR 0 3
76535: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76536: LD_INT 0
76538: PPUSH
76539: PPUSH
76540: PPUSH
// if not mc_bases or not base or not ext_list then
76541: LD_EXP 43
76545: NOT
76546: PUSH
76547: LD_VAR 0 1
76551: NOT
76552: OR
76553: PUSH
76554: LD_VAR 0 5
76558: NOT
76559: OR
76560: IFFALSE 76564
// exit ;
76562: GO 76737
// tmp := GetFacExtXYD ( x , y , d ) ;
76564: LD_ADDR_VAR 0 8
76568: PUSH
76569: LD_VAR 0 2
76573: PPUSH
76574: LD_VAR 0 3
76578: PPUSH
76579: LD_VAR 0 4
76583: PPUSH
76584: CALL 44780 0 3
76588: ST_TO_ADDR
// if not tmp then
76589: LD_VAR 0 8
76593: NOT
76594: IFFALSE 76598
// exit ;
76596: GO 76737
// for i in tmp do
76598: LD_ADDR_VAR 0 7
76602: PUSH
76603: LD_VAR 0 8
76607: PUSH
76608: FOR_IN
76609: IFFALSE 76735
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76611: LD_ADDR_EXP 48
76615: PUSH
76616: LD_EXP 48
76620: PPUSH
76621: LD_VAR 0 1
76625: PPUSH
76626: LD_EXP 48
76630: PUSH
76631: LD_VAR 0 1
76635: ARRAY
76636: PPUSH
76637: LD_EXP 48
76641: PUSH
76642: LD_VAR 0 1
76646: ARRAY
76647: PUSH
76648: LD_INT 1
76650: PLUS
76651: PPUSH
76652: LD_VAR 0 5
76656: PUSH
76657: LD_INT 1
76659: ARRAY
76660: PUSH
76661: LD_VAR 0 7
76665: PUSH
76666: LD_INT 1
76668: ARRAY
76669: PUSH
76670: LD_VAR 0 7
76674: PUSH
76675: LD_INT 2
76677: ARRAY
76678: PUSH
76679: LD_VAR 0 7
76683: PUSH
76684: LD_INT 3
76686: ARRAY
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: LIST
76692: LIST
76693: PPUSH
76694: CALL_OW 2
76698: PPUSH
76699: CALL_OW 1
76703: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76704: LD_ADDR_VAR 0 5
76708: PUSH
76709: LD_VAR 0 5
76713: PPUSH
76714: LD_INT 1
76716: PPUSH
76717: CALL_OW 3
76721: ST_TO_ADDR
// if not ext_list then
76722: LD_VAR 0 5
76726: NOT
76727: IFFALSE 76733
// exit ;
76729: POP
76730: POP
76731: GO 76737
// end ;
76733: GO 76608
76735: POP
76736: POP
// end ;
76737: LD_VAR 0 6
76741: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76742: LD_INT 0
76744: PPUSH
// if not mc_bases or not base or not weapon_list then
76745: LD_EXP 43
76749: NOT
76750: PUSH
76751: LD_VAR 0 1
76755: NOT
76756: OR
76757: PUSH
76758: LD_VAR 0 2
76762: NOT
76763: OR
76764: IFFALSE 76768
// exit ;
76766: GO 76793
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76768: LD_ADDR_EXP 82
76772: PUSH
76773: LD_EXP 82
76777: PPUSH
76778: LD_VAR 0 1
76782: PPUSH
76783: LD_VAR 0 2
76787: PPUSH
76788: CALL_OW 1
76792: ST_TO_ADDR
// end ;
76793: LD_VAR 0 3
76797: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76798: LD_INT 0
76800: PPUSH
// if not mc_bases or not base or not tech_list then
76801: LD_EXP 43
76805: NOT
76806: PUSH
76807: LD_VAR 0 1
76811: NOT
76812: OR
76813: PUSH
76814: LD_VAR 0 2
76818: NOT
76819: OR
76820: IFFALSE 76824
// exit ;
76822: GO 76849
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76824: LD_ADDR_EXP 70
76828: PUSH
76829: LD_EXP 70
76833: PPUSH
76834: LD_VAR 0 1
76838: PPUSH
76839: LD_VAR 0 2
76843: PPUSH
76844: CALL_OW 1
76848: ST_TO_ADDR
// end ;
76849: LD_VAR 0 3
76853: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76854: LD_INT 0
76856: PPUSH
// if not mc_bases or not parking_area or not base then
76857: LD_EXP 43
76861: NOT
76862: PUSH
76863: LD_VAR 0 2
76867: NOT
76868: OR
76869: PUSH
76870: LD_VAR 0 1
76874: NOT
76875: OR
76876: IFFALSE 76880
// exit ;
76878: GO 76905
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76880: LD_ADDR_EXP 67
76884: PUSH
76885: LD_EXP 67
76889: PPUSH
76890: LD_VAR 0 1
76894: PPUSH
76895: LD_VAR 0 2
76899: PPUSH
76900: CALL_OW 1
76904: ST_TO_ADDR
// end ;
76905: LD_VAR 0 3
76909: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76910: LD_INT 0
76912: PPUSH
// if not mc_bases or not base or not scan_area then
76913: LD_EXP 43
76917: NOT
76918: PUSH
76919: LD_VAR 0 1
76923: NOT
76924: OR
76925: PUSH
76926: LD_VAR 0 2
76930: NOT
76931: OR
76932: IFFALSE 76936
// exit ;
76934: GO 76961
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76936: LD_ADDR_EXP 68
76940: PUSH
76941: LD_EXP 68
76945: PPUSH
76946: LD_VAR 0 1
76950: PPUSH
76951: LD_VAR 0 2
76955: PPUSH
76956: CALL_OW 1
76960: ST_TO_ADDR
// end ;
76961: LD_VAR 0 3
76965: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76966: LD_INT 0
76968: PPUSH
76969: PPUSH
// if not mc_bases or not base then
76970: LD_EXP 43
76974: NOT
76975: PUSH
76976: LD_VAR 0 1
76980: NOT
76981: OR
76982: IFFALSE 76986
// exit ;
76984: GO 77050
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76986: LD_ADDR_VAR 0 3
76990: PUSH
76991: LD_INT 1
76993: PUSH
76994: LD_INT 2
76996: PUSH
76997: LD_INT 3
76999: PUSH
77000: LD_INT 4
77002: PUSH
77003: LD_INT 11
77005: PUSH
77006: EMPTY
77007: LIST
77008: LIST
77009: LIST
77010: LIST
77011: LIST
77012: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
77013: LD_ADDR_EXP 70
77017: PUSH
77018: LD_EXP 70
77022: PPUSH
77023: LD_VAR 0 1
77027: PPUSH
77028: LD_EXP 70
77032: PUSH
77033: LD_VAR 0 1
77037: ARRAY
77038: PUSH
77039: LD_VAR 0 3
77043: DIFF
77044: PPUSH
77045: CALL_OW 1
77049: ST_TO_ADDR
// end ;
77050: LD_VAR 0 2
77054: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
77055: LD_INT 0
77057: PPUSH
// result := mc_vehicles [ base ] ;
77058: LD_ADDR_VAR 0 3
77062: PUSH
77063: LD_EXP 62
77067: PUSH
77068: LD_VAR 0 1
77072: ARRAY
77073: ST_TO_ADDR
// if onlyCombat then
77074: LD_VAR 0 2
77078: IFFALSE 77250
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
77080: LD_ADDR_VAR 0 3
77084: PUSH
77085: LD_VAR 0 3
77089: PUSH
77090: LD_VAR 0 3
77094: PPUSH
77095: LD_INT 2
77097: PUSH
77098: LD_INT 34
77100: PUSH
77101: LD_INT 12
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: PUSH
77108: LD_INT 34
77110: PUSH
77111: LD_INT 51
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: LD_INT 34
77120: PUSH
77121: LD_INT 89
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: PUSH
77128: LD_INT 34
77130: PUSH
77131: LD_INT 32
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: PUSH
77138: LD_INT 34
77140: PUSH
77141: LD_INT 13
77143: PUSH
77144: EMPTY
77145: LIST
77146: LIST
77147: PUSH
77148: LD_INT 34
77150: PUSH
77151: LD_INT 52
77153: PUSH
77154: EMPTY
77155: LIST
77156: LIST
77157: PUSH
77158: LD_INT 34
77160: PUSH
77161: LD_INT 88
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PUSH
77168: LD_INT 34
77170: PUSH
77171: LD_INT 14
77173: PUSH
77174: EMPTY
77175: LIST
77176: LIST
77177: PUSH
77178: LD_INT 34
77180: PUSH
77181: LD_INT 53
77183: PUSH
77184: EMPTY
77185: LIST
77186: LIST
77187: PUSH
77188: LD_INT 34
77190: PUSH
77191: LD_INT 98
77193: PUSH
77194: EMPTY
77195: LIST
77196: LIST
77197: PUSH
77198: LD_INT 34
77200: PUSH
77201: LD_INT 31
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: PUSH
77208: LD_INT 34
77210: PUSH
77211: LD_INT 48
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: PUSH
77218: LD_INT 34
77220: PUSH
77221: LD_INT 8
77223: PUSH
77224: EMPTY
77225: LIST
77226: LIST
77227: PUSH
77228: EMPTY
77229: LIST
77230: LIST
77231: LIST
77232: LIST
77233: LIST
77234: LIST
77235: LIST
77236: LIST
77237: LIST
77238: LIST
77239: LIST
77240: LIST
77241: LIST
77242: LIST
77243: PPUSH
77244: CALL_OW 72
77248: DIFF
77249: ST_TO_ADDR
// end ; end_of_file
77250: LD_VAR 0 3
77254: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77255: LD_INT 0
77257: PPUSH
77258: PPUSH
77259: PPUSH
// if not mc_bases or not skirmish then
77260: LD_EXP 43
77264: NOT
77265: PUSH
77266: LD_EXP 41
77270: NOT
77271: OR
77272: IFFALSE 77276
// exit ;
77274: GO 77441
// for i = 1 to mc_bases do
77276: LD_ADDR_VAR 0 4
77280: PUSH
77281: DOUBLE
77282: LD_INT 1
77284: DEC
77285: ST_TO_ADDR
77286: LD_EXP 43
77290: PUSH
77291: FOR_TO
77292: IFFALSE 77439
// begin if sci in mc_bases [ i ] then
77294: LD_VAR 0 2
77298: PUSH
77299: LD_EXP 43
77303: PUSH
77304: LD_VAR 0 4
77308: ARRAY
77309: IN
77310: IFFALSE 77437
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77312: LD_ADDR_EXP 72
77316: PUSH
77317: LD_EXP 72
77321: PPUSH
77322: LD_VAR 0 4
77326: PUSH
77327: LD_EXP 72
77331: PUSH
77332: LD_VAR 0 4
77336: ARRAY
77337: PUSH
77338: LD_INT 1
77340: PLUS
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PPUSH
77346: LD_VAR 0 1
77350: PPUSH
77351: CALL 14774 0 3
77355: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77356: LD_ADDR_VAR 0 5
77360: PUSH
77361: LD_EXP 43
77365: PUSH
77366: LD_VAR 0 4
77370: ARRAY
77371: PPUSH
77372: LD_INT 2
77374: PUSH
77375: LD_INT 30
77377: PUSH
77378: LD_INT 0
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 30
77387: PUSH
77388: LD_INT 1
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: LIST
77399: PPUSH
77400: CALL_OW 72
77404: PPUSH
77405: LD_VAR 0 1
77409: PPUSH
77410: CALL_OW 74
77414: ST_TO_ADDR
// if tmp then
77415: LD_VAR 0 5
77419: IFFALSE 77435
// ComStandNearbyBuilding ( ape , tmp ) ;
77421: LD_VAR 0 1
77425: PPUSH
77426: LD_VAR 0 5
77430: PPUSH
77431: CALL 11376 0 2
// break ;
77435: GO 77439
// end ; end ;
77437: GO 77291
77439: POP
77440: POP
// end ;
77441: LD_VAR 0 3
77445: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77446: LD_INT 0
77448: PPUSH
77449: PPUSH
77450: PPUSH
// if not mc_bases or not skirmish then
77451: LD_EXP 43
77455: NOT
77456: PUSH
77457: LD_EXP 41
77461: NOT
77462: OR
77463: IFFALSE 77467
// exit ;
77465: GO 77556
// for i = 1 to mc_bases do
77467: LD_ADDR_VAR 0 4
77471: PUSH
77472: DOUBLE
77473: LD_INT 1
77475: DEC
77476: ST_TO_ADDR
77477: LD_EXP 43
77481: PUSH
77482: FOR_TO
77483: IFFALSE 77554
// begin if building in mc_busy_turret_list [ i ] then
77485: LD_VAR 0 1
77489: PUSH
77490: LD_EXP 53
77494: PUSH
77495: LD_VAR 0 4
77499: ARRAY
77500: IN
77501: IFFALSE 77552
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77503: LD_ADDR_VAR 0 5
77507: PUSH
77508: LD_EXP 53
77512: PUSH
77513: LD_VAR 0 4
77517: ARRAY
77518: PUSH
77519: LD_VAR 0 1
77523: DIFF
77524: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77525: LD_ADDR_EXP 53
77529: PUSH
77530: LD_EXP 53
77534: PPUSH
77535: LD_VAR 0 4
77539: PPUSH
77540: LD_VAR 0 5
77544: PPUSH
77545: CALL_OW 1
77549: ST_TO_ADDR
// break ;
77550: GO 77554
// end ; end ;
77552: GO 77482
77554: POP
77555: POP
// end ;
77556: LD_VAR 0 3
77560: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77561: LD_INT 0
77563: PPUSH
77564: PPUSH
77565: PPUSH
// if not mc_bases or not skirmish then
77566: LD_EXP 43
77570: NOT
77571: PUSH
77572: LD_EXP 41
77576: NOT
77577: OR
77578: IFFALSE 77582
// exit ;
77580: GO 77781
// for i = 1 to mc_bases do
77582: LD_ADDR_VAR 0 5
77586: PUSH
77587: DOUBLE
77588: LD_INT 1
77590: DEC
77591: ST_TO_ADDR
77592: LD_EXP 43
77596: PUSH
77597: FOR_TO
77598: IFFALSE 77779
// if building in mc_bases [ i ] then
77600: LD_VAR 0 1
77604: PUSH
77605: LD_EXP 43
77609: PUSH
77610: LD_VAR 0 5
77614: ARRAY
77615: IN
77616: IFFALSE 77777
// begin tmp := mc_bases [ i ] diff building ;
77618: LD_ADDR_VAR 0 6
77622: PUSH
77623: LD_EXP 43
77627: PUSH
77628: LD_VAR 0 5
77632: ARRAY
77633: PUSH
77634: LD_VAR 0 1
77638: DIFF
77639: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77640: LD_ADDR_EXP 43
77644: PUSH
77645: LD_EXP 43
77649: PPUSH
77650: LD_VAR 0 5
77654: PPUSH
77655: LD_VAR 0 6
77659: PPUSH
77660: CALL_OW 1
77664: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77665: LD_VAR 0 1
77669: PUSH
77670: LD_EXP 51
77674: PUSH
77675: LD_VAR 0 5
77679: ARRAY
77680: IN
77681: IFFALSE 77720
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77683: LD_ADDR_EXP 51
77687: PUSH
77688: LD_EXP 51
77692: PPUSH
77693: LD_VAR 0 5
77697: PPUSH
77698: LD_EXP 51
77702: PUSH
77703: LD_VAR 0 5
77707: ARRAY
77708: PUSH
77709: LD_VAR 0 1
77713: DIFF
77714: PPUSH
77715: CALL_OW 1
77719: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77720: LD_VAR 0 1
77724: PUSH
77725: LD_EXP 52
77729: PUSH
77730: LD_VAR 0 5
77734: ARRAY
77735: IN
77736: IFFALSE 77775
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77738: LD_ADDR_EXP 52
77742: PUSH
77743: LD_EXP 52
77747: PPUSH
77748: LD_VAR 0 5
77752: PPUSH
77753: LD_EXP 52
77757: PUSH
77758: LD_VAR 0 5
77762: ARRAY
77763: PUSH
77764: LD_VAR 0 1
77768: DIFF
77769: PPUSH
77770: CALL_OW 1
77774: ST_TO_ADDR
// break ;
77775: GO 77779
// end ;
77777: GO 77597
77779: POP
77780: POP
// end ;
77781: LD_VAR 0 4
77785: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77786: LD_INT 0
77788: PPUSH
77789: PPUSH
77790: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77791: LD_EXP 43
77795: NOT
77796: PUSH
77797: LD_EXP 41
77801: NOT
77802: OR
77803: PUSH
77804: LD_VAR 0 3
77808: PUSH
77809: LD_EXP 69
77813: IN
77814: NOT
77815: OR
77816: IFFALSE 77820
// exit ;
77818: GO 77943
// for i = 1 to mc_vehicles do
77820: LD_ADDR_VAR 0 6
77824: PUSH
77825: DOUBLE
77826: LD_INT 1
77828: DEC
77829: ST_TO_ADDR
77830: LD_EXP 62
77834: PUSH
77835: FOR_TO
77836: IFFALSE 77941
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77838: LD_VAR 0 2
77842: PUSH
77843: LD_EXP 62
77847: PUSH
77848: LD_VAR 0 6
77852: ARRAY
77853: IN
77854: PUSH
77855: LD_VAR 0 1
77859: PUSH
77860: LD_EXP 62
77864: PUSH
77865: LD_VAR 0 6
77869: ARRAY
77870: IN
77871: OR
77872: IFFALSE 77939
// begin tmp := mc_vehicles [ i ] diff old ;
77874: LD_ADDR_VAR 0 7
77878: PUSH
77879: LD_EXP 62
77883: PUSH
77884: LD_VAR 0 6
77888: ARRAY
77889: PUSH
77890: LD_VAR 0 2
77894: DIFF
77895: ST_TO_ADDR
// tmp := tmp diff new ;
77896: LD_ADDR_VAR 0 7
77900: PUSH
77901: LD_VAR 0 7
77905: PUSH
77906: LD_VAR 0 1
77910: DIFF
77911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77912: LD_ADDR_EXP 62
77916: PUSH
77917: LD_EXP 62
77921: PPUSH
77922: LD_VAR 0 6
77926: PPUSH
77927: LD_VAR 0 7
77931: PPUSH
77932: CALL_OW 1
77936: ST_TO_ADDR
// break ;
77937: GO 77941
// end ;
77939: GO 77835
77941: POP
77942: POP
// end ;
77943: LD_VAR 0 5
77947: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77948: LD_INT 0
77950: PPUSH
77951: PPUSH
77952: PPUSH
77953: PPUSH
// if not mc_bases or not skirmish then
77954: LD_EXP 43
77958: NOT
77959: PUSH
77960: LD_EXP 41
77964: NOT
77965: OR
77966: IFFALSE 77970
// exit ;
77968: GO 78390
// repeat wait ( 0 0$1 ) ;
77970: LD_INT 35
77972: PPUSH
77973: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
77977: LD_EXP 87
77981: NOT
77982: IFFALSE 77970
// mc_block_vehicle_constructed_thread := true ;
77984: LD_ADDR_EXP 87
77988: PUSH
77989: LD_INT 1
77991: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
77992: LD_ADDR_VAR 0 5
77996: PUSH
77997: LD_VAR 0 1
78001: PPUSH
78002: CALL_OW 255
78006: ST_TO_ADDR
// for i = 1 to mc_bases do
78007: LD_ADDR_VAR 0 4
78011: PUSH
78012: DOUBLE
78013: LD_INT 1
78015: DEC
78016: ST_TO_ADDR
78017: LD_EXP 43
78021: PUSH
78022: FOR_TO
78023: IFFALSE 78380
// begin if factory in mc_bases [ i ] then
78025: LD_VAR 0 2
78029: PUSH
78030: LD_EXP 43
78034: PUSH
78035: LD_VAR 0 4
78039: ARRAY
78040: IN
78041: IFFALSE 78378
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
78043: LD_EXP 65
78047: PUSH
78048: LD_VAR 0 4
78052: ARRAY
78053: PUSH
78054: LD_EXP 54
78058: PUSH
78059: LD_VAR 0 4
78063: ARRAY
78064: LESS
78065: PUSH
78066: LD_VAR 0 1
78070: PPUSH
78071: CALL_OW 264
78075: PUSH
78076: LD_INT 31
78078: PUSH
78079: LD_INT 32
78081: PUSH
78082: LD_INT 51
78084: PUSH
78085: LD_INT 89
78087: PUSH
78088: LD_INT 12
78090: PUSH
78091: LD_INT 30
78093: PUSH
78094: LD_INT 98
78096: PUSH
78097: LD_INT 11
78099: PUSH
78100: LD_INT 53
78102: PUSH
78103: LD_INT 14
78105: PUSH
78106: LD_INT 91
78108: PUSH
78109: LD_INT 29
78111: PUSH
78112: LD_INT 99
78114: PUSH
78115: LD_INT 13
78117: PUSH
78118: LD_INT 52
78120: PUSH
78121: LD_INT 88
78123: PUSH
78124: LD_INT 48
78126: PUSH
78127: LD_INT 8
78129: PUSH
78130: EMPTY
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: LIST
78136: LIST
78137: LIST
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: IN
78150: NOT
78151: AND
78152: IFFALSE 78200
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78154: LD_ADDR_EXP 65
78158: PUSH
78159: LD_EXP 65
78163: PPUSH
78164: LD_VAR 0 4
78168: PUSH
78169: LD_EXP 65
78173: PUSH
78174: LD_VAR 0 4
78178: ARRAY
78179: PUSH
78180: LD_INT 1
78182: PLUS
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PPUSH
78188: LD_VAR 0 1
78192: PPUSH
78193: CALL 14774 0 3
78197: ST_TO_ADDR
78198: GO 78244
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78200: LD_ADDR_EXP 62
78204: PUSH
78205: LD_EXP 62
78209: PPUSH
78210: LD_VAR 0 4
78214: PUSH
78215: LD_EXP 62
78219: PUSH
78220: LD_VAR 0 4
78224: ARRAY
78225: PUSH
78226: LD_INT 1
78228: PLUS
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: PPUSH
78234: LD_VAR 0 1
78238: PPUSH
78239: CALL 14774 0 3
78243: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
78244: LD_ADDR_EXP 87
78248: PUSH
78249: LD_INT 0
78251: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78252: LD_VAR 0 1
78256: PPUSH
78257: CALL_OW 263
78261: PUSH
78262: LD_INT 2
78264: EQUAL
78265: IFFALSE 78294
// begin repeat wait ( 0 0$3 ) ;
78267: LD_INT 105
78269: PPUSH
78270: CALL_OW 67
// Connect ( vehicle ) ;
78274: LD_VAR 0 1
78278: PPUSH
78279: CALL 17752 0 1
// until IsControledBy ( vehicle ) ;
78283: LD_VAR 0 1
78287: PPUSH
78288: CALL_OW 312
78292: IFFALSE 78267
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78294: LD_VAR 0 1
78298: PPUSH
78299: LD_EXP 67
78303: PUSH
78304: LD_VAR 0 4
78308: ARRAY
78309: PPUSH
78310: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78314: LD_VAR 0 1
78318: PPUSH
78319: CALL_OW 263
78323: PUSH
78324: LD_INT 1
78326: NONEQUAL
78327: IFFALSE 78331
// break ;
78329: GO 78380
// repeat wait ( 0 0$1 ) ;
78331: LD_INT 35
78333: PPUSH
78334: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78338: LD_VAR 0 1
78342: PPUSH
78343: LD_EXP 67
78347: PUSH
78348: LD_VAR 0 4
78352: ARRAY
78353: PPUSH
78354: CALL_OW 308
78358: IFFALSE 78331
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78360: LD_VAR 0 1
78364: PPUSH
78365: CALL_OW 311
78369: PPUSH
78370: CALL_OW 121
// exit ;
78374: POP
78375: POP
78376: GO 78390
// end ; end ;
78378: GO 78022
78380: POP
78381: POP
// mc_block_vehicle_constructed_thread := false ;
78382: LD_ADDR_EXP 87
78386: PUSH
78387: LD_INT 0
78389: ST_TO_ADDR
// end ;
78390: LD_VAR 0 3
78394: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78395: LD_INT 0
78397: PPUSH
78398: PPUSH
78399: PPUSH
78400: PPUSH
// if not mc_bases or not skirmish then
78401: LD_EXP 43
78405: NOT
78406: PUSH
78407: LD_EXP 41
78411: NOT
78412: OR
78413: IFFALSE 78417
// exit ;
78415: GO 78770
// repeat wait ( 0 0$1 ) ;
78417: LD_INT 35
78419: PPUSH
78420: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78424: LD_VAR 0 2
78428: PPUSH
78429: LD_VAR 0 3
78433: PPUSH
78434: CALL_OW 284
78438: IFFALSE 78417
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78440: LD_VAR 0 2
78444: PPUSH
78445: LD_VAR 0 3
78449: PPUSH
78450: CALL_OW 283
78454: PUSH
78455: LD_INT 4
78457: EQUAL
78458: IFFALSE 78462
// exit ;
78460: GO 78770
// for i = 1 to mc_bases do
78462: LD_ADDR_VAR 0 7
78466: PUSH
78467: DOUBLE
78468: LD_INT 1
78470: DEC
78471: ST_TO_ADDR
78472: LD_EXP 43
78476: PUSH
78477: FOR_TO
78478: IFFALSE 78768
// begin if mc_crates_area [ i ] then
78480: LD_EXP 61
78484: PUSH
78485: LD_VAR 0 7
78489: ARRAY
78490: IFFALSE 78601
// for j in mc_crates_area [ i ] do
78492: LD_ADDR_VAR 0 8
78496: PUSH
78497: LD_EXP 61
78501: PUSH
78502: LD_VAR 0 7
78506: ARRAY
78507: PUSH
78508: FOR_IN
78509: IFFALSE 78599
// if InArea ( x , y , j ) then
78511: LD_VAR 0 2
78515: PPUSH
78516: LD_VAR 0 3
78520: PPUSH
78521: LD_VAR 0 8
78525: PPUSH
78526: CALL_OW 309
78530: IFFALSE 78597
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78532: LD_ADDR_EXP 59
78536: PUSH
78537: LD_EXP 59
78541: PPUSH
78542: LD_VAR 0 7
78546: PUSH
78547: LD_EXP 59
78551: PUSH
78552: LD_VAR 0 7
78556: ARRAY
78557: PUSH
78558: LD_INT 1
78560: PLUS
78561: PUSH
78562: EMPTY
78563: LIST
78564: LIST
78565: PPUSH
78566: LD_VAR 0 4
78570: PUSH
78571: LD_VAR 0 2
78575: PUSH
78576: LD_VAR 0 3
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: LIST
78585: PPUSH
78586: CALL 14774 0 3
78590: ST_TO_ADDR
// exit ;
78591: POP
78592: POP
78593: POP
78594: POP
78595: GO 78770
// end ;
78597: GO 78508
78599: POP
78600: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78601: LD_ADDR_VAR 0 9
78605: PUSH
78606: LD_EXP 43
78610: PUSH
78611: LD_VAR 0 7
78615: ARRAY
78616: PPUSH
78617: LD_INT 2
78619: PUSH
78620: LD_INT 30
78622: PUSH
78623: LD_INT 0
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 30
78632: PUSH
78633: LD_INT 1
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: LIST
78644: PPUSH
78645: CALL_OW 72
78649: ST_TO_ADDR
// if not depot then
78650: LD_VAR 0 9
78654: NOT
78655: IFFALSE 78659
// continue ;
78657: GO 78477
// for j in depot do
78659: LD_ADDR_VAR 0 8
78663: PUSH
78664: LD_VAR 0 9
78668: PUSH
78669: FOR_IN
78670: IFFALSE 78764
// if GetDistUnitXY ( j , x , y ) < 30 then
78672: LD_VAR 0 8
78676: PPUSH
78677: LD_VAR 0 2
78681: PPUSH
78682: LD_VAR 0 3
78686: PPUSH
78687: CALL_OW 297
78691: PUSH
78692: LD_INT 30
78694: LESS
78695: IFFALSE 78762
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78697: LD_ADDR_EXP 59
78701: PUSH
78702: LD_EXP 59
78706: PPUSH
78707: LD_VAR 0 7
78711: PUSH
78712: LD_EXP 59
78716: PUSH
78717: LD_VAR 0 7
78721: ARRAY
78722: PUSH
78723: LD_INT 1
78725: PLUS
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PPUSH
78731: LD_VAR 0 4
78735: PUSH
78736: LD_VAR 0 2
78740: PUSH
78741: LD_VAR 0 3
78745: PUSH
78746: EMPTY
78747: LIST
78748: LIST
78749: LIST
78750: PPUSH
78751: CALL 14774 0 3
78755: ST_TO_ADDR
// exit ;
78756: POP
78757: POP
78758: POP
78759: POP
78760: GO 78770
// end ;
78762: GO 78669
78764: POP
78765: POP
// end ;
78766: GO 78477
78768: POP
78769: POP
// end ;
78770: LD_VAR 0 6
78774: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78775: LD_INT 0
78777: PPUSH
78778: PPUSH
78779: PPUSH
78780: PPUSH
// if not mc_bases or not skirmish then
78781: LD_EXP 43
78785: NOT
78786: PUSH
78787: LD_EXP 41
78791: NOT
78792: OR
78793: IFFALSE 78797
// exit ;
78795: GO 79074
// side := GetSide ( lab ) ;
78797: LD_ADDR_VAR 0 4
78801: PUSH
78802: LD_VAR 0 2
78806: PPUSH
78807: CALL_OW 255
78811: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78812: LD_VAR 0 4
78816: PUSH
78817: LD_EXP 69
78821: IN
78822: NOT
78823: PUSH
78824: LD_EXP 70
78828: NOT
78829: OR
78830: PUSH
78831: LD_EXP 43
78835: NOT
78836: OR
78837: IFFALSE 78841
// exit ;
78839: GO 79074
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78841: LD_ADDR_EXP 70
78845: PUSH
78846: LD_EXP 70
78850: PPUSH
78851: LD_VAR 0 4
78855: PPUSH
78856: LD_EXP 70
78860: PUSH
78861: LD_VAR 0 4
78865: ARRAY
78866: PUSH
78867: LD_VAR 0 1
78871: DIFF
78872: PPUSH
78873: CALL_OW 1
78877: ST_TO_ADDR
// for i = 1 to mc_bases do
78878: LD_ADDR_VAR 0 5
78882: PUSH
78883: DOUBLE
78884: LD_INT 1
78886: DEC
78887: ST_TO_ADDR
78888: LD_EXP 43
78892: PUSH
78893: FOR_TO
78894: IFFALSE 79072
// begin if lab in mc_bases [ i ] then
78896: LD_VAR 0 2
78900: PUSH
78901: LD_EXP 43
78905: PUSH
78906: LD_VAR 0 5
78910: ARRAY
78911: IN
78912: IFFALSE 79070
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78914: LD_VAR 0 1
78918: PUSH
78919: LD_INT 11
78921: PUSH
78922: LD_INT 4
78924: PUSH
78925: LD_INT 3
78927: PUSH
78928: LD_INT 2
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: LIST
78935: LIST
78936: IN
78937: PUSH
78938: LD_EXP 73
78942: PUSH
78943: LD_VAR 0 5
78947: ARRAY
78948: AND
78949: IFFALSE 79070
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78951: LD_ADDR_VAR 0 6
78955: PUSH
78956: LD_EXP 73
78960: PUSH
78961: LD_VAR 0 5
78965: ARRAY
78966: PUSH
78967: LD_INT 1
78969: ARRAY
78970: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78971: LD_ADDR_EXP 73
78975: PUSH
78976: LD_EXP 73
78980: PPUSH
78981: LD_VAR 0 5
78985: PPUSH
78986: EMPTY
78987: PPUSH
78988: CALL_OW 1
78992: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78993: LD_VAR 0 6
78997: PPUSH
78998: LD_INT 0
79000: PPUSH
79001: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79005: LD_VAR 0 6
79009: PPUSH
79010: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79014: LD_ADDR_EXP 72
79018: PUSH
79019: LD_EXP 72
79023: PPUSH
79024: LD_VAR 0 5
79028: PPUSH
79029: LD_EXP 72
79033: PUSH
79034: LD_VAR 0 5
79038: ARRAY
79039: PPUSH
79040: LD_INT 1
79042: PPUSH
79043: LD_VAR 0 6
79047: PPUSH
79048: CALL_OW 2
79052: PPUSH
79053: CALL_OW 1
79057: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
79058: LD_VAR 0 5
79062: PPUSH
79063: LD_INT 112
79065: PPUSH
79066: CALL 55524 0 2
// end ; end ; end ;
79070: GO 78893
79072: POP
79073: POP
// end ;
79074: LD_VAR 0 3
79078: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
79079: LD_INT 0
79081: PPUSH
79082: PPUSH
79083: PPUSH
79084: PPUSH
79085: PPUSH
79086: PPUSH
79087: PPUSH
79088: PPUSH
// if not mc_bases or not skirmish then
79089: LD_EXP 43
79093: NOT
79094: PUSH
79095: LD_EXP 41
79099: NOT
79100: OR
79101: IFFALSE 79105
// exit ;
79103: GO 80474
// for i = 1 to mc_bases do
79105: LD_ADDR_VAR 0 3
79109: PUSH
79110: DOUBLE
79111: LD_INT 1
79113: DEC
79114: ST_TO_ADDR
79115: LD_EXP 43
79119: PUSH
79120: FOR_TO
79121: IFFALSE 80472
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79123: LD_VAR 0 1
79127: PUSH
79128: LD_EXP 43
79132: PUSH
79133: LD_VAR 0 3
79137: ARRAY
79138: IN
79139: PUSH
79140: LD_VAR 0 1
79144: PUSH
79145: LD_EXP 50
79149: PUSH
79150: LD_VAR 0 3
79154: ARRAY
79155: IN
79156: OR
79157: PUSH
79158: LD_VAR 0 1
79162: PUSH
79163: LD_EXP 65
79167: PUSH
79168: LD_VAR 0 3
79172: ARRAY
79173: IN
79174: OR
79175: PUSH
79176: LD_VAR 0 1
79180: PUSH
79181: LD_EXP 62
79185: PUSH
79186: LD_VAR 0 3
79190: ARRAY
79191: IN
79192: OR
79193: PUSH
79194: LD_VAR 0 1
79198: PUSH
79199: LD_EXP 72
79203: PUSH
79204: LD_VAR 0 3
79208: ARRAY
79209: IN
79210: OR
79211: PUSH
79212: LD_VAR 0 1
79216: PUSH
79217: LD_EXP 73
79221: PUSH
79222: LD_VAR 0 3
79226: ARRAY
79227: IN
79228: OR
79229: IFFALSE 80470
// begin if un in mc_ape [ i ] then
79231: LD_VAR 0 1
79235: PUSH
79236: LD_EXP 72
79240: PUSH
79241: LD_VAR 0 3
79245: ARRAY
79246: IN
79247: IFFALSE 79286
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79249: LD_ADDR_EXP 72
79253: PUSH
79254: LD_EXP 72
79258: PPUSH
79259: LD_VAR 0 3
79263: PPUSH
79264: LD_EXP 72
79268: PUSH
79269: LD_VAR 0 3
79273: ARRAY
79274: PUSH
79275: LD_VAR 0 1
79279: DIFF
79280: PPUSH
79281: CALL_OW 1
79285: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79286: LD_VAR 0 1
79290: PUSH
79291: LD_EXP 73
79295: PUSH
79296: LD_VAR 0 3
79300: ARRAY
79301: IN
79302: IFFALSE 79326
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79304: LD_ADDR_EXP 73
79308: PUSH
79309: LD_EXP 73
79313: PPUSH
79314: LD_VAR 0 3
79318: PPUSH
79319: EMPTY
79320: PPUSH
79321: CALL_OW 1
79325: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79326: LD_VAR 0 1
79330: PPUSH
79331: CALL_OW 247
79335: PUSH
79336: LD_INT 2
79338: EQUAL
79339: PUSH
79340: LD_VAR 0 1
79344: PPUSH
79345: CALL_OW 110
79349: PUSH
79350: LD_INT 20
79352: EQUAL
79353: PUSH
79354: LD_VAR 0 1
79358: PUSH
79359: LD_EXP 65
79363: PUSH
79364: LD_VAR 0 3
79368: ARRAY
79369: IN
79370: OR
79371: PUSH
79372: LD_VAR 0 1
79376: PPUSH
79377: CALL_OW 264
79381: PUSH
79382: LD_INT 12
79384: PUSH
79385: LD_INT 51
79387: PUSH
79388: LD_INT 89
79390: PUSH
79391: LD_INT 32
79393: PUSH
79394: LD_INT 13
79396: PUSH
79397: LD_INT 52
79399: PUSH
79400: LD_INT 31
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: IN
79412: OR
79413: AND
79414: IFFALSE 79722
// begin if un in mc_defender [ i ] then
79416: LD_VAR 0 1
79420: PUSH
79421: LD_EXP 65
79425: PUSH
79426: LD_VAR 0 3
79430: ARRAY
79431: IN
79432: IFFALSE 79471
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79434: LD_ADDR_EXP 65
79438: PUSH
79439: LD_EXP 65
79443: PPUSH
79444: LD_VAR 0 3
79448: PPUSH
79449: LD_EXP 65
79453: PUSH
79454: LD_VAR 0 3
79458: ARRAY
79459: PUSH
79460: LD_VAR 0 1
79464: DIFF
79465: PPUSH
79466: CALL_OW 1
79470: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79471: LD_ADDR_VAR 0 8
79475: PUSH
79476: LD_VAR 0 3
79480: PPUSH
79481: LD_INT 3
79483: PPUSH
79484: CALL 76092 0 2
79488: ST_TO_ADDR
// if fac then
79489: LD_VAR 0 8
79493: IFFALSE 79722
// begin for j in fac do
79495: LD_ADDR_VAR 0 4
79499: PUSH
79500: LD_VAR 0 8
79504: PUSH
79505: FOR_IN
79506: IFFALSE 79720
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79508: LD_ADDR_VAR 0 9
79512: PUSH
79513: LD_VAR 0 8
79517: PPUSH
79518: LD_VAR 0 1
79522: PPUSH
79523: CALL_OW 265
79527: PPUSH
79528: LD_VAR 0 1
79532: PPUSH
79533: CALL_OW 262
79537: PPUSH
79538: LD_VAR 0 1
79542: PPUSH
79543: CALL_OW 263
79547: PPUSH
79548: LD_VAR 0 1
79552: PPUSH
79553: CALL_OW 264
79557: PPUSH
79558: CALL 12272 0 5
79562: ST_TO_ADDR
// if components then
79563: LD_VAR 0 9
79567: IFFALSE 79718
// begin if GetWeapon ( un ) = ar_control_tower then
79569: LD_VAR 0 1
79573: PPUSH
79574: CALL_OW 264
79578: PUSH
79579: LD_INT 31
79581: EQUAL
79582: IFFALSE 79699
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79584: LD_VAR 0 1
79588: PPUSH
79589: CALL_OW 311
79593: PPUSH
79594: LD_INT 0
79596: PPUSH
79597: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79601: LD_ADDR_EXP 83
79605: PUSH
79606: LD_EXP 83
79610: PPUSH
79611: LD_VAR 0 3
79615: PPUSH
79616: LD_EXP 83
79620: PUSH
79621: LD_VAR 0 3
79625: ARRAY
79626: PUSH
79627: LD_VAR 0 1
79631: PPUSH
79632: CALL_OW 311
79636: DIFF
79637: PPUSH
79638: CALL_OW 1
79642: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79643: LD_ADDR_VAR 0 7
79647: PUSH
79648: LD_EXP 64
79652: PUSH
79653: LD_VAR 0 3
79657: ARRAY
79658: PPUSH
79659: LD_INT 1
79661: PPUSH
79662: LD_VAR 0 9
79666: PPUSH
79667: CALL_OW 2
79671: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79672: LD_ADDR_EXP 64
79676: PUSH
79677: LD_EXP 64
79681: PPUSH
79682: LD_VAR 0 3
79686: PPUSH
79687: LD_VAR 0 7
79691: PPUSH
79692: CALL_OW 1
79696: ST_TO_ADDR
// end else
79697: GO 79716
// MC_InsertProduceList ( i , [ components ] ) ;
79699: LD_VAR 0 3
79703: PPUSH
79704: LD_VAR 0 9
79708: PUSH
79709: EMPTY
79710: LIST
79711: PPUSH
79712: CALL 75637 0 2
// break ;
79716: GO 79720
// end ; end ;
79718: GO 79505
79720: POP
79721: POP
// end ; end ; if GetType ( un ) = unit_building then
79722: LD_VAR 0 1
79726: PPUSH
79727: CALL_OW 247
79731: PUSH
79732: LD_INT 3
79734: EQUAL
79735: IFFALSE 80138
// begin btype := GetBType ( un ) ;
79737: LD_ADDR_VAR 0 5
79741: PUSH
79742: LD_VAR 0 1
79746: PPUSH
79747: CALL_OW 266
79751: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79752: LD_VAR 0 5
79756: PUSH
79757: LD_INT 29
79759: PUSH
79760: LD_INT 30
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: IN
79767: IFFALSE 79840
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79769: LD_VAR 0 1
79773: PPUSH
79774: CALL_OW 250
79778: PPUSH
79779: LD_VAR 0 1
79783: PPUSH
79784: CALL_OW 251
79788: PPUSH
79789: LD_VAR 0 1
79793: PPUSH
79794: CALL_OW 255
79798: PPUSH
79799: CALL_OW 440
79803: NOT
79804: IFFALSE 79840
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79806: LD_VAR 0 1
79810: PPUSH
79811: CALL_OW 250
79815: PPUSH
79816: LD_VAR 0 1
79820: PPUSH
79821: CALL_OW 251
79825: PPUSH
79826: LD_VAR 0 1
79830: PPUSH
79831: CALL_OW 255
79835: PPUSH
79836: CALL_OW 441
// end ; if btype = b_warehouse then
79840: LD_VAR 0 5
79844: PUSH
79845: LD_INT 1
79847: EQUAL
79848: IFFALSE 79866
// begin btype := b_depot ;
79850: LD_ADDR_VAR 0 5
79854: PUSH
79855: LD_INT 0
79857: ST_TO_ADDR
// pos := 1 ;
79858: LD_ADDR_VAR 0 6
79862: PUSH
79863: LD_INT 1
79865: ST_TO_ADDR
// end ; if btype = b_factory then
79866: LD_VAR 0 5
79870: PUSH
79871: LD_INT 3
79873: EQUAL
79874: IFFALSE 79892
// begin btype := b_workshop ;
79876: LD_ADDR_VAR 0 5
79880: PUSH
79881: LD_INT 2
79883: ST_TO_ADDR
// pos := 1 ;
79884: LD_ADDR_VAR 0 6
79888: PUSH
79889: LD_INT 1
79891: ST_TO_ADDR
// end ; if btype = b_barracks then
79892: LD_VAR 0 5
79896: PUSH
79897: LD_INT 5
79899: EQUAL
79900: IFFALSE 79910
// btype := b_armoury ;
79902: LD_ADDR_VAR 0 5
79906: PUSH
79907: LD_INT 4
79909: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79910: LD_VAR 0 5
79914: PUSH
79915: LD_INT 7
79917: PUSH
79918: LD_INT 8
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: IN
79925: IFFALSE 79935
// btype := b_lab ;
79927: LD_ADDR_VAR 0 5
79931: PUSH
79932: LD_INT 6
79934: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79935: LD_ADDR_EXP 48
79939: PUSH
79940: LD_EXP 48
79944: PPUSH
79945: LD_VAR 0 3
79949: PUSH
79950: LD_EXP 48
79954: PUSH
79955: LD_VAR 0 3
79959: ARRAY
79960: PUSH
79961: LD_INT 1
79963: PLUS
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PPUSH
79969: LD_VAR 0 5
79973: PUSH
79974: LD_VAR 0 1
79978: PPUSH
79979: CALL_OW 250
79983: PUSH
79984: LD_VAR 0 1
79988: PPUSH
79989: CALL_OW 251
79993: PUSH
79994: LD_VAR 0 1
79998: PPUSH
79999: CALL_OW 254
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: LIST
80008: LIST
80009: PPUSH
80010: CALL 14774 0 3
80014: ST_TO_ADDR
// if pos = 1 then
80015: LD_VAR 0 6
80019: PUSH
80020: LD_INT 1
80022: EQUAL
80023: IFFALSE 80138
// begin tmp := mc_build_list [ i ] ;
80025: LD_ADDR_VAR 0 7
80029: PUSH
80030: LD_EXP 48
80034: PUSH
80035: LD_VAR 0 3
80039: ARRAY
80040: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80041: LD_VAR 0 7
80045: PPUSH
80046: LD_INT 2
80048: PUSH
80049: LD_INT 30
80051: PUSH
80052: LD_INT 0
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 30
80061: PUSH
80062: LD_INT 1
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: LIST
80073: PPUSH
80074: CALL_OW 72
80078: IFFALSE 80088
// pos := 2 ;
80080: LD_ADDR_VAR 0 6
80084: PUSH
80085: LD_INT 2
80087: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80088: LD_ADDR_VAR 0 7
80092: PUSH
80093: LD_VAR 0 7
80097: PPUSH
80098: LD_VAR 0 6
80102: PPUSH
80103: LD_VAR 0 7
80107: PPUSH
80108: CALL 15100 0 3
80112: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80113: LD_ADDR_EXP 48
80117: PUSH
80118: LD_EXP 48
80122: PPUSH
80123: LD_VAR 0 3
80127: PPUSH
80128: LD_VAR 0 7
80132: PPUSH
80133: CALL_OW 1
80137: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80138: LD_VAR 0 1
80142: PUSH
80143: LD_EXP 43
80147: PUSH
80148: LD_VAR 0 3
80152: ARRAY
80153: IN
80154: IFFALSE 80193
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80156: LD_ADDR_EXP 43
80160: PUSH
80161: LD_EXP 43
80165: PPUSH
80166: LD_VAR 0 3
80170: PPUSH
80171: LD_EXP 43
80175: PUSH
80176: LD_VAR 0 3
80180: ARRAY
80181: PUSH
80182: LD_VAR 0 1
80186: DIFF
80187: PPUSH
80188: CALL_OW 1
80192: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80193: LD_VAR 0 1
80197: PUSH
80198: LD_EXP 50
80202: PUSH
80203: LD_VAR 0 3
80207: ARRAY
80208: IN
80209: IFFALSE 80248
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80211: LD_ADDR_EXP 50
80215: PUSH
80216: LD_EXP 50
80220: PPUSH
80221: LD_VAR 0 3
80225: PPUSH
80226: LD_EXP 50
80230: PUSH
80231: LD_VAR 0 3
80235: ARRAY
80236: PUSH
80237: LD_VAR 0 1
80241: DIFF
80242: PPUSH
80243: CALL_OW 1
80247: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80248: LD_VAR 0 1
80252: PUSH
80253: LD_EXP 62
80257: PUSH
80258: LD_VAR 0 3
80262: ARRAY
80263: IN
80264: IFFALSE 80303
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80266: LD_ADDR_EXP 62
80270: PUSH
80271: LD_EXP 62
80275: PPUSH
80276: LD_VAR 0 3
80280: PPUSH
80281: LD_EXP 62
80285: PUSH
80286: LD_VAR 0 3
80290: ARRAY
80291: PUSH
80292: LD_VAR 0 1
80296: DIFF
80297: PPUSH
80298: CALL_OW 1
80302: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80303: LD_VAR 0 1
80307: PUSH
80308: LD_EXP 65
80312: PUSH
80313: LD_VAR 0 3
80317: ARRAY
80318: IN
80319: IFFALSE 80358
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80321: LD_ADDR_EXP 65
80325: PUSH
80326: LD_EXP 65
80330: PPUSH
80331: LD_VAR 0 3
80335: PPUSH
80336: LD_EXP 65
80340: PUSH
80341: LD_VAR 0 3
80345: ARRAY
80346: PUSH
80347: LD_VAR 0 1
80351: DIFF
80352: PPUSH
80353: CALL_OW 1
80357: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80358: LD_VAR 0 1
80362: PUSH
80363: LD_EXP 52
80367: PUSH
80368: LD_VAR 0 3
80372: ARRAY
80373: IN
80374: IFFALSE 80413
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80376: LD_ADDR_EXP 52
80380: PUSH
80381: LD_EXP 52
80385: PPUSH
80386: LD_VAR 0 3
80390: PPUSH
80391: LD_EXP 52
80395: PUSH
80396: LD_VAR 0 3
80400: ARRAY
80401: PUSH
80402: LD_VAR 0 1
80406: DIFF
80407: PPUSH
80408: CALL_OW 1
80412: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80413: LD_VAR 0 1
80417: PUSH
80418: LD_EXP 51
80422: PUSH
80423: LD_VAR 0 3
80427: ARRAY
80428: IN
80429: IFFALSE 80468
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80431: LD_ADDR_EXP 51
80435: PUSH
80436: LD_EXP 51
80440: PPUSH
80441: LD_VAR 0 3
80445: PPUSH
80446: LD_EXP 51
80450: PUSH
80451: LD_VAR 0 3
80455: ARRAY
80456: PUSH
80457: LD_VAR 0 1
80461: DIFF
80462: PPUSH
80463: CALL_OW 1
80467: ST_TO_ADDR
// end ; break ;
80468: GO 80472
// end ;
80470: GO 79120
80472: POP
80473: POP
// end ;
80474: LD_VAR 0 2
80478: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80479: LD_INT 0
80481: PPUSH
80482: PPUSH
80483: PPUSH
// if not mc_bases or not skirmish then
80484: LD_EXP 43
80488: NOT
80489: PUSH
80490: LD_EXP 41
80494: NOT
80495: OR
80496: IFFALSE 80500
// exit ;
80498: GO 80715
// for i = 1 to mc_bases do
80500: LD_ADDR_VAR 0 3
80504: PUSH
80505: DOUBLE
80506: LD_INT 1
80508: DEC
80509: ST_TO_ADDR
80510: LD_EXP 43
80514: PUSH
80515: FOR_TO
80516: IFFALSE 80713
// begin if building in mc_construct_list [ i ] then
80518: LD_VAR 0 1
80522: PUSH
80523: LD_EXP 50
80527: PUSH
80528: LD_VAR 0 3
80532: ARRAY
80533: IN
80534: IFFALSE 80711
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80536: LD_ADDR_EXP 50
80540: PUSH
80541: LD_EXP 50
80545: PPUSH
80546: LD_VAR 0 3
80550: PPUSH
80551: LD_EXP 50
80555: PUSH
80556: LD_VAR 0 3
80560: ARRAY
80561: PUSH
80562: LD_VAR 0 1
80566: DIFF
80567: PPUSH
80568: CALL_OW 1
80572: ST_TO_ADDR
// if building in mc_lab [ i ] then
80573: LD_VAR 0 1
80577: PUSH
80578: LD_EXP 76
80582: PUSH
80583: LD_VAR 0 3
80587: ARRAY
80588: IN
80589: IFFALSE 80644
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80591: LD_ADDR_EXP 77
80595: PUSH
80596: LD_EXP 77
80600: PPUSH
80601: LD_VAR 0 3
80605: PPUSH
80606: LD_EXP 77
80610: PUSH
80611: LD_VAR 0 3
80615: ARRAY
80616: PPUSH
80617: LD_INT 1
80619: PPUSH
80620: LD_EXP 77
80624: PUSH
80625: LD_VAR 0 3
80629: ARRAY
80630: PPUSH
80631: LD_INT 0
80633: PPUSH
80634: CALL 14192 0 4
80638: PPUSH
80639: CALL_OW 1
80643: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80644: LD_VAR 0 1
80648: PUSH
80649: LD_EXP 43
80653: PUSH
80654: LD_VAR 0 3
80658: ARRAY
80659: IN
80660: NOT
80661: IFFALSE 80707
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80663: LD_ADDR_EXP 43
80667: PUSH
80668: LD_EXP 43
80672: PPUSH
80673: LD_VAR 0 3
80677: PUSH
80678: LD_EXP 43
80682: PUSH
80683: LD_VAR 0 3
80687: ARRAY
80688: PUSH
80689: LD_INT 1
80691: PLUS
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PPUSH
80697: LD_VAR 0 1
80701: PPUSH
80702: CALL 14774 0 3
80706: ST_TO_ADDR
// exit ;
80707: POP
80708: POP
80709: GO 80715
// end ; end ;
80711: GO 80515
80713: POP
80714: POP
// end ;
80715: LD_VAR 0 2
80719: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80720: LD_INT 0
80722: PPUSH
80723: PPUSH
80724: PPUSH
80725: PPUSH
80726: PPUSH
80727: PPUSH
80728: PPUSH
// if not mc_bases or not skirmish then
80729: LD_EXP 43
80733: NOT
80734: PUSH
80735: LD_EXP 41
80739: NOT
80740: OR
80741: IFFALSE 80745
// exit ;
80743: GO 81406
// for i = 1 to mc_bases do
80745: LD_ADDR_VAR 0 3
80749: PUSH
80750: DOUBLE
80751: LD_INT 1
80753: DEC
80754: ST_TO_ADDR
80755: LD_EXP 43
80759: PUSH
80760: FOR_TO
80761: IFFALSE 81404
// begin if building in mc_construct_list [ i ] then
80763: LD_VAR 0 1
80767: PUSH
80768: LD_EXP 50
80772: PUSH
80773: LD_VAR 0 3
80777: ARRAY
80778: IN
80779: IFFALSE 81402
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80781: LD_ADDR_EXP 50
80785: PUSH
80786: LD_EXP 50
80790: PPUSH
80791: LD_VAR 0 3
80795: PPUSH
80796: LD_EXP 50
80800: PUSH
80801: LD_VAR 0 3
80805: ARRAY
80806: PUSH
80807: LD_VAR 0 1
80811: DIFF
80812: PPUSH
80813: CALL_OW 1
80817: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80818: LD_ADDR_EXP 43
80822: PUSH
80823: LD_EXP 43
80827: PPUSH
80828: LD_VAR 0 3
80832: PUSH
80833: LD_EXP 43
80837: PUSH
80838: LD_VAR 0 3
80842: ARRAY
80843: PUSH
80844: LD_INT 1
80846: PLUS
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PPUSH
80852: LD_VAR 0 1
80856: PPUSH
80857: CALL 14774 0 3
80861: ST_TO_ADDR
// btype := GetBType ( building ) ;
80862: LD_ADDR_VAR 0 5
80866: PUSH
80867: LD_VAR 0 1
80871: PPUSH
80872: CALL_OW 266
80876: ST_TO_ADDR
// side := GetSide ( building ) ;
80877: LD_ADDR_VAR 0 8
80881: PUSH
80882: LD_VAR 0 1
80886: PPUSH
80887: CALL_OW 255
80891: ST_TO_ADDR
// if btype = b_lab then
80892: LD_VAR 0 5
80896: PUSH
80897: LD_INT 6
80899: EQUAL
80900: IFFALSE 80950
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80902: LD_ADDR_EXP 76
80906: PUSH
80907: LD_EXP 76
80911: PPUSH
80912: LD_VAR 0 3
80916: PUSH
80917: LD_EXP 76
80921: PUSH
80922: LD_VAR 0 3
80926: ARRAY
80927: PUSH
80928: LD_INT 1
80930: PLUS
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PPUSH
80936: LD_VAR 0 1
80940: PPUSH
80941: CALL 14774 0 3
80945: ST_TO_ADDR
// exit ;
80946: POP
80947: POP
80948: GO 81406
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80950: LD_VAR 0 5
80954: PUSH
80955: LD_INT 0
80957: PUSH
80958: LD_INT 2
80960: PUSH
80961: LD_INT 4
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: LIST
80968: IN
80969: IFFALSE 81093
// begin if btype = b_armoury then
80971: LD_VAR 0 5
80975: PUSH
80976: LD_INT 4
80978: EQUAL
80979: IFFALSE 80989
// btype := b_barracks ;
80981: LD_ADDR_VAR 0 5
80985: PUSH
80986: LD_INT 5
80988: ST_TO_ADDR
// if btype = b_depot then
80989: LD_VAR 0 5
80993: PUSH
80994: LD_INT 0
80996: EQUAL
80997: IFFALSE 81007
// btype := b_warehouse ;
80999: LD_ADDR_VAR 0 5
81003: PUSH
81004: LD_INT 1
81006: ST_TO_ADDR
// if btype = b_workshop then
81007: LD_VAR 0 5
81011: PUSH
81012: LD_INT 2
81014: EQUAL
81015: IFFALSE 81025
// btype := b_factory ;
81017: LD_ADDR_VAR 0 5
81021: PUSH
81022: LD_INT 3
81024: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81025: LD_VAR 0 5
81029: PPUSH
81030: LD_VAR 0 8
81034: PPUSH
81035: CALL_OW 323
81039: PUSH
81040: LD_INT 1
81042: EQUAL
81043: IFFALSE 81089
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81045: LD_ADDR_EXP 75
81049: PUSH
81050: LD_EXP 75
81054: PPUSH
81055: LD_VAR 0 3
81059: PUSH
81060: LD_EXP 75
81064: PUSH
81065: LD_VAR 0 3
81069: ARRAY
81070: PUSH
81071: LD_INT 1
81073: PLUS
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PPUSH
81079: LD_VAR 0 1
81083: PPUSH
81084: CALL 14774 0 3
81088: ST_TO_ADDR
// exit ;
81089: POP
81090: POP
81091: GO 81406
// end ; if btype in [ b_bunker , b_turret ] then
81093: LD_VAR 0 5
81097: PUSH
81098: LD_INT 32
81100: PUSH
81101: LD_INT 33
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: IN
81108: IFFALSE 81398
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81110: LD_ADDR_EXP 51
81114: PUSH
81115: LD_EXP 51
81119: PPUSH
81120: LD_VAR 0 3
81124: PUSH
81125: LD_EXP 51
81129: PUSH
81130: LD_VAR 0 3
81134: ARRAY
81135: PUSH
81136: LD_INT 1
81138: PLUS
81139: PUSH
81140: EMPTY
81141: LIST
81142: LIST
81143: PPUSH
81144: LD_VAR 0 1
81148: PPUSH
81149: CALL 14774 0 3
81153: ST_TO_ADDR
// if btype = b_bunker then
81154: LD_VAR 0 5
81158: PUSH
81159: LD_INT 32
81161: EQUAL
81162: IFFALSE 81398
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81164: LD_ADDR_EXP 52
81168: PUSH
81169: LD_EXP 52
81173: PPUSH
81174: LD_VAR 0 3
81178: PUSH
81179: LD_EXP 52
81183: PUSH
81184: LD_VAR 0 3
81188: ARRAY
81189: PUSH
81190: LD_INT 1
81192: PLUS
81193: PUSH
81194: EMPTY
81195: LIST
81196: LIST
81197: PPUSH
81198: LD_VAR 0 1
81202: PPUSH
81203: CALL 14774 0 3
81207: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81208: LD_ADDR_VAR 0 6
81212: PUSH
81213: LD_EXP 43
81217: PUSH
81218: LD_VAR 0 3
81222: ARRAY
81223: PPUSH
81224: LD_INT 25
81226: PUSH
81227: LD_INT 1
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: PUSH
81234: LD_INT 3
81236: PUSH
81237: LD_INT 54
81239: PUSH
81240: EMPTY
81241: LIST
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: PPUSH
81251: CALL_OW 72
81255: ST_TO_ADDR
// if tmp then
81256: LD_VAR 0 6
81260: IFFALSE 81266
// exit ;
81262: POP
81263: POP
81264: GO 81406
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81266: LD_ADDR_VAR 0 6
81270: PUSH
81271: LD_EXP 43
81275: PUSH
81276: LD_VAR 0 3
81280: ARRAY
81281: PPUSH
81282: LD_INT 2
81284: PUSH
81285: LD_INT 30
81287: PUSH
81288: LD_INT 4
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 30
81297: PUSH
81298: LD_INT 5
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: LIST
81309: PPUSH
81310: CALL_OW 72
81314: ST_TO_ADDR
// if not tmp then
81315: LD_VAR 0 6
81319: NOT
81320: IFFALSE 81326
// exit ;
81322: POP
81323: POP
81324: GO 81406
// for j in tmp do
81326: LD_ADDR_VAR 0 4
81330: PUSH
81331: LD_VAR 0 6
81335: PUSH
81336: FOR_IN
81337: IFFALSE 81396
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81339: LD_ADDR_VAR 0 7
81343: PUSH
81344: LD_VAR 0 4
81348: PPUSH
81349: CALL_OW 313
81353: PPUSH
81354: LD_INT 25
81356: PUSH
81357: LD_INT 1
81359: PUSH
81360: EMPTY
81361: LIST
81362: LIST
81363: PPUSH
81364: CALL_OW 72
81368: ST_TO_ADDR
// if units then
81369: LD_VAR 0 7
81373: IFFALSE 81394
// begin ComExitBuilding ( units [ 1 ] ) ;
81375: LD_VAR 0 7
81379: PUSH
81380: LD_INT 1
81382: ARRAY
81383: PPUSH
81384: CALL_OW 122
// exit ;
81388: POP
81389: POP
81390: POP
81391: POP
81392: GO 81406
// end ; end ;
81394: GO 81336
81396: POP
81397: POP
// end ; end ; exit ;
81398: POP
81399: POP
81400: GO 81406
// end ; end ;
81402: GO 80760
81404: POP
81405: POP
// end ;
81406: LD_VAR 0 2
81410: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81411: LD_INT 0
81413: PPUSH
81414: PPUSH
81415: PPUSH
81416: PPUSH
81417: PPUSH
81418: PPUSH
81419: PPUSH
// if not mc_bases or not skirmish then
81420: LD_EXP 43
81424: NOT
81425: PUSH
81426: LD_EXP 41
81430: NOT
81431: OR
81432: IFFALSE 81436
// exit ;
81434: GO 81701
// btype := GetBType ( building ) ;
81436: LD_ADDR_VAR 0 6
81440: PUSH
81441: LD_VAR 0 1
81445: PPUSH
81446: CALL_OW 266
81450: ST_TO_ADDR
// x := GetX ( building ) ;
81451: LD_ADDR_VAR 0 7
81455: PUSH
81456: LD_VAR 0 1
81460: PPUSH
81461: CALL_OW 250
81465: ST_TO_ADDR
// y := GetY ( building ) ;
81466: LD_ADDR_VAR 0 8
81470: PUSH
81471: LD_VAR 0 1
81475: PPUSH
81476: CALL_OW 251
81480: ST_TO_ADDR
// d := GetDir ( building ) ;
81481: LD_ADDR_VAR 0 9
81485: PUSH
81486: LD_VAR 0 1
81490: PPUSH
81491: CALL_OW 254
81495: ST_TO_ADDR
// for i = 1 to mc_bases do
81496: LD_ADDR_VAR 0 4
81500: PUSH
81501: DOUBLE
81502: LD_INT 1
81504: DEC
81505: ST_TO_ADDR
81506: LD_EXP 43
81510: PUSH
81511: FOR_TO
81512: IFFALSE 81699
// begin if not mc_build_list [ i ] then
81514: LD_EXP 48
81518: PUSH
81519: LD_VAR 0 4
81523: ARRAY
81524: NOT
81525: IFFALSE 81529
// continue ;
81527: GO 81511
// for j := 1 to mc_build_list [ i ] do
81529: LD_ADDR_VAR 0 5
81533: PUSH
81534: DOUBLE
81535: LD_INT 1
81537: DEC
81538: ST_TO_ADDR
81539: LD_EXP 48
81543: PUSH
81544: LD_VAR 0 4
81548: ARRAY
81549: PUSH
81550: FOR_TO
81551: IFFALSE 81695
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
81553: LD_VAR 0 6
81557: PUSH
81558: LD_VAR 0 7
81562: PUSH
81563: LD_VAR 0 8
81567: PUSH
81568: LD_VAR 0 9
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: LIST
81577: LIST
81578: PPUSH
81579: LD_EXP 48
81583: PUSH
81584: LD_VAR 0 4
81588: ARRAY
81589: PUSH
81590: LD_VAR 0 5
81594: ARRAY
81595: PPUSH
81596: CALL 20963 0 2
81600: IFFALSE 81693
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81602: LD_ADDR_EXP 48
81606: PUSH
81607: LD_EXP 48
81611: PPUSH
81612: LD_VAR 0 4
81616: PPUSH
81617: LD_EXP 48
81621: PUSH
81622: LD_VAR 0 4
81626: ARRAY
81627: PPUSH
81628: LD_VAR 0 5
81632: PPUSH
81633: CALL_OW 3
81637: PPUSH
81638: CALL_OW 1
81642: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81643: LD_ADDR_EXP 50
81647: PUSH
81648: LD_EXP 50
81652: PPUSH
81653: LD_VAR 0 4
81657: PUSH
81658: LD_EXP 50
81662: PUSH
81663: LD_VAR 0 4
81667: ARRAY
81668: PUSH
81669: LD_INT 1
81671: PLUS
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PPUSH
81677: LD_VAR 0 1
81681: PPUSH
81682: CALL 14774 0 3
81686: ST_TO_ADDR
// exit ;
81687: POP
81688: POP
81689: POP
81690: POP
81691: GO 81701
// end ;
81693: GO 81550
81695: POP
81696: POP
// end ;
81697: GO 81511
81699: POP
81700: POP
// end ;
81701: LD_VAR 0 3
81705: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81706: LD_INT 0
81708: PPUSH
81709: PPUSH
81710: PPUSH
// if not mc_bases or not skirmish then
81711: LD_EXP 43
81715: NOT
81716: PUSH
81717: LD_EXP 41
81721: NOT
81722: OR
81723: IFFALSE 81727
// exit ;
81725: GO 81917
// for i = 1 to mc_bases do
81727: LD_ADDR_VAR 0 4
81731: PUSH
81732: DOUBLE
81733: LD_INT 1
81735: DEC
81736: ST_TO_ADDR
81737: LD_EXP 43
81741: PUSH
81742: FOR_TO
81743: IFFALSE 81830
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81745: LD_VAR 0 1
81749: PUSH
81750: LD_EXP 51
81754: PUSH
81755: LD_VAR 0 4
81759: ARRAY
81760: IN
81761: PUSH
81762: LD_VAR 0 1
81766: PUSH
81767: LD_EXP 52
81771: PUSH
81772: LD_VAR 0 4
81776: ARRAY
81777: IN
81778: NOT
81779: AND
81780: IFFALSE 81828
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81782: LD_ADDR_EXP 52
81786: PUSH
81787: LD_EXP 52
81791: PPUSH
81792: LD_VAR 0 4
81796: PUSH
81797: LD_EXP 52
81801: PUSH
81802: LD_VAR 0 4
81806: ARRAY
81807: PUSH
81808: LD_INT 1
81810: PLUS
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PPUSH
81816: LD_VAR 0 1
81820: PPUSH
81821: CALL 14774 0 3
81825: ST_TO_ADDR
// break ;
81826: GO 81830
// end ; end ;
81828: GO 81742
81830: POP
81831: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81832: LD_VAR 0 1
81836: PPUSH
81837: CALL_OW 257
81841: PUSH
81842: LD_EXP 69
81846: IN
81847: PUSH
81848: LD_VAR 0 1
81852: PPUSH
81853: CALL_OW 266
81857: PUSH
81858: LD_INT 5
81860: EQUAL
81861: AND
81862: PUSH
81863: LD_VAR 0 2
81867: PPUSH
81868: CALL_OW 110
81872: PUSH
81873: LD_INT 18
81875: NONEQUAL
81876: AND
81877: IFFALSE 81917
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81879: LD_VAR 0 2
81883: PPUSH
81884: CALL_OW 257
81888: PUSH
81889: LD_INT 5
81891: PUSH
81892: LD_INT 8
81894: PUSH
81895: LD_INT 9
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: LIST
81902: IN
81903: IFFALSE 81917
// SetClass ( unit , 1 ) ;
81905: LD_VAR 0 2
81909: PPUSH
81910: LD_INT 1
81912: PPUSH
81913: CALL_OW 336
// end ;
81917: LD_VAR 0 3
81921: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81922: LD_INT 0
81924: PPUSH
81925: PPUSH
// if not mc_bases or not skirmish then
81926: LD_EXP 43
81930: NOT
81931: PUSH
81932: LD_EXP 41
81936: NOT
81937: OR
81938: IFFALSE 81942
// exit ;
81940: GO 82058
// if GetLives ( abandoned_vehicle ) > 250 then
81942: LD_VAR 0 2
81946: PPUSH
81947: CALL_OW 256
81951: PUSH
81952: LD_INT 250
81954: GREATER
81955: IFFALSE 81959
// exit ;
81957: GO 82058
// for i = 1 to mc_bases do
81959: LD_ADDR_VAR 0 6
81963: PUSH
81964: DOUBLE
81965: LD_INT 1
81967: DEC
81968: ST_TO_ADDR
81969: LD_EXP 43
81973: PUSH
81974: FOR_TO
81975: IFFALSE 82056
// begin if driver in mc_bases [ i ] then
81977: LD_VAR 0 1
81981: PUSH
81982: LD_EXP 43
81986: PUSH
81987: LD_VAR 0 6
81991: ARRAY
81992: IN
81993: IFFALSE 82054
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81995: LD_VAR 0 1
81999: PPUSH
82000: LD_EXP 43
82004: PUSH
82005: LD_VAR 0 6
82009: ARRAY
82010: PPUSH
82011: LD_INT 2
82013: PUSH
82014: LD_INT 30
82016: PUSH
82017: LD_INT 0
82019: PUSH
82020: EMPTY
82021: LIST
82022: LIST
82023: PUSH
82024: LD_INT 30
82026: PUSH
82027: LD_INT 1
82029: PUSH
82030: EMPTY
82031: LIST
82032: LIST
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: LIST
82038: PPUSH
82039: CALL_OW 72
82043: PUSH
82044: LD_INT 1
82046: ARRAY
82047: PPUSH
82048: CALL 48010 0 2
// break ;
82052: GO 82056
// end ; end ;
82054: GO 81974
82056: POP
82057: POP
// end ; end_of_file
82058: LD_VAR 0 5
82062: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
82063: LD_INT 0
82065: PPUSH
82066: PPUSH
82067: PPUSH
82068: PPUSH
82069: PPUSH
82070: PPUSH
82071: PPUSH
82072: PPUSH
82073: PPUSH
82074: PPUSH
82075: PPUSH
82076: PPUSH
82077: PPUSH
82078: PPUSH
82079: PPUSH
82080: PPUSH
82081: PPUSH
82082: PPUSH
82083: PPUSH
82084: PPUSH
82085: PPUSH
82086: PPUSH
82087: PPUSH
82088: PPUSH
82089: PPUSH
82090: PPUSH
82091: PPUSH
82092: PPUSH
82093: PPUSH
82094: PPUSH
82095: PPUSH
82096: PPUSH
82097: PPUSH
82098: PPUSH
// if not list then
82099: LD_VAR 0 1
82103: NOT
82104: IFFALSE 82108
// exit ;
82106: GO 86767
// base := list [ 1 ] ;
82108: LD_ADDR_VAR 0 3
82112: PUSH
82113: LD_VAR 0 1
82117: PUSH
82118: LD_INT 1
82120: ARRAY
82121: ST_TO_ADDR
// group := list [ 2 ] ;
82122: LD_ADDR_VAR 0 4
82126: PUSH
82127: LD_VAR 0 1
82131: PUSH
82132: LD_INT 2
82134: ARRAY
82135: ST_TO_ADDR
// path := list [ 3 ] ;
82136: LD_ADDR_VAR 0 5
82140: PUSH
82141: LD_VAR 0 1
82145: PUSH
82146: LD_INT 3
82148: ARRAY
82149: ST_TO_ADDR
// flags := list [ 4 ] ;
82150: LD_ADDR_VAR 0 6
82154: PUSH
82155: LD_VAR 0 1
82159: PUSH
82160: LD_INT 4
82162: ARRAY
82163: ST_TO_ADDR
// mined := [ ] ;
82164: LD_ADDR_VAR 0 27
82168: PUSH
82169: EMPTY
82170: ST_TO_ADDR
// bombed := [ ] ;
82171: LD_ADDR_VAR 0 28
82175: PUSH
82176: EMPTY
82177: ST_TO_ADDR
// healers := [ ] ;
82178: LD_ADDR_VAR 0 31
82182: PUSH
82183: EMPTY
82184: ST_TO_ADDR
// to_heal := [ ] ;
82185: LD_ADDR_VAR 0 30
82189: PUSH
82190: EMPTY
82191: ST_TO_ADDR
// repairs := [ ] ;
82192: LD_ADDR_VAR 0 33
82196: PUSH
82197: EMPTY
82198: ST_TO_ADDR
// to_repair := [ ] ;
82199: LD_ADDR_VAR 0 32
82203: PUSH
82204: EMPTY
82205: ST_TO_ADDR
// if not group or not path then
82206: LD_VAR 0 4
82210: NOT
82211: PUSH
82212: LD_VAR 0 5
82216: NOT
82217: OR
82218: IFFALSE 82222
// exit ;
82220: GO 86767
// side := GetSide ( group [ 1 ] ) ;
82222: LD_ADDR_VAR 0 35
82226: PUSH
82227: LD_VAR 0 4
82231: PUSH
82232: LD_INT 1
82234: ARRAY
82235: PPUSH
82236: CALL_OW 255
82240: ST_TO_ADDR
// if flags then
82241: LD_VAR 0 6
82245: IFFALSE 82389
// begin f_ignore_area := flags [ 1 ] ;
82247: LD_ADDR_VAR 0 17
82251: PUSH
82252: LD_VAR 0 6
82256: PUSH
82257: LD_INT 1
82259: ARRAY
82260: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
82261: LD_ADDR_VAR 0 18
82265: PUSH
82266: LD_VAR 0 6
82270: PUSH
82271: LD_INT 2
82273: ARRAY
82274: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
82275: LD_ADDR_VAR 0 19
82279: PUSH
82280: LD_VAR 0 6
82284: PUSH
82285: LD_INT 3
82287: ARRAY
82288: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
82289: LD_ADDR_VAR 0 20
82293: PUSH
82294: LD_VAR 0 6
82298: PUSH
82299: LD_INT 4
82301: ARRAY
82302: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
82303: LD_ADDR_VAR 0 21
82307: PUSH
82308: LD_VAR 0 6
82312: PUSH
82313: LD_INT 5
82315: ARRAY
82316: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
82317: LD_ADDR_VAR 0 22
82321: PUSH
82322: LD_VAR 0 6
82326: PUSH
82327: LD_INT 6
82329: ARRAY
82330: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
82331: LD_ADDR_VAR 0 23
82335: PUSH
82336: LD_VAR 0 6
82340: PUSH
82341: LD_INT 7
82343: ARRAY
82344: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
82345: LD_ADDR_VAR 0 24
82349: PUSH
82350: LD_VAR 0 6
82354: PUSH
82355: LD_INT 8
82357: ARRAY
82358: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
82359: LD_ADDR_VAR 0 25
82363: PUSH
82364: LD_VAR 0 6
82368: PUSH
82369: LD_INT 9
82371: ARRAY
82372: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
82373: LD_ADDR_VAR 0 26
82377: PUSH
82378: LD_VAR 0 6
82382: PUSH
82383: LD_INT 10
82385: ARRAY
82386: ST_TO_ADDR
// end else
82387: GO 82469
// begin f_ignore_area := false ;
82389: LD_ADDR_VAR 0 17
82393: PUSH
82394: LD_INT 0
82396: ST_TO_ADDR
// f_capture := false ;
82397: LD_ADDR_VAR 0 18
82401: PUSH
82402: LD_INT 0
82404: ST_TO_ADDR
// f_ignore_civ := false ;
82405: LD_ADDR_VAR 0 19
82409: PUSH
82410: LD_INT 0
82412: ST_TO_ADDR
// f_murder := false ;
82413: LD_ADDR_VAR 0 20
82417: PUSH
82418: LD_INT 0
82420: ST_TO_ADDR
// f_mines := false ;
82421: LD_ADDR_VAR 0 21
82425: PUSH
82426: LD_INT 0
82428: ST_TO_ADDR
// f_repair := false ;
82429: LD_ADDR_VAR 0 22
82433: PUSH
82434: LD_INT 0
82436: ST_TO_ADDR
// f_heal := false ;
82437: LD_ADDR_VAR 0 23
82441: PUSH
82442: LD_INT 0
82444: ST_TO_ADDR
// f_spacetime := false ;
82445: LD_ADDR_VAR 0 24
82449: PUSH
82450: LD_INT 0
82452: ST_TO_ADDR
// f_attack_depot := false ;
82453: LD_ADDR_VAR 0 25
82457: PUSH
82458: LD_INT 0
82460: ST_TO_ADDR
// f_crawl := false ;
82461: LD_ADDR_VAR 0 26
82465: PUSH
82466: LD_INT 0
82468: ST_TO_ADDR
// end ; if f_heal then
82469: LD_VAR 0 23
82473: IFFALSE 82500
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82475: LD_ADDR_VAR 0 31
82479: PUSH
82480: LD_VAR 0 4
82484: PPUSH
82485: LD_INT 25
82487: PUSH
82488: LD_INT 4
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PPUSH
82495: CALL_OW 72
82499: ST_TO_ADDR
// if f_repair then
82500: LD_VAR 0 22
82504: IFFALSE 82531
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82506: LD_ADDR_VAR 0 33
82510: PUSH
82511: LD_VAR 0 4
82515: PPUSH
82516: LD_INT 25
82518: PUSH
82519: LD_INT 3
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PPUSH
82526: CALL_OW 72
82530: ST_TO_ADDR
// units_path := [ ] ;
82531: LD_ADDR_VAR 0 16
82535: PUSH
82536: EMPTY
82537: ST_TO_ADDR
// for i = 1 to group do
82538: LD_ADDR_VAR 0 7
82542: PUSH
82543: DOUBLE
82544: LD_INT 1
82546: DEC
82547: ST_TO_ADDR
82548: LD_VAR 0 4
82552: PUSH
82553: FOR_TO
82554: IFFALSE 82583
// units_path := Replace ( units_path , i , path ) ;
82556: LD_ADDR_VAR 0 16
82560: PUSH
82561: LD_VAR 0 16
82565: PPUSH
82566: LD_VAR 0 7
82570: PPUSH
82571: LD_VAR 0 5
82575: PPUSH
82576: CALL_OW 1
82580: ST_TO_ADDR
82581: GO 82553
82583: POP
82584: POP
// repeat for i = group downto 1 do
82585: LD_ADDR_VAR 0 7
82589: PUSH
82590: DOUBLE
82591: LD_VAR 0 4
82595: INC
82596: ST_TO_ADDR
82597: LD_INT 1
82599: PUSH
82600: FOR_DOWNTO
82601: IFFALSE 86723
// begin wait ( 5 ) ;
82603: LD_INT 5
82605: PPUSH
82606: CALL_OW 67
// tmp := [ ] ;
82610: LD_ADDR_VAR 0 14
82614: PUSH
82615: EMPTY
82616: ST_TO_ADDR
// attacking := false ;
82617: LD_ADDR_VAR 0 29
82621: PUSH
82622: LD_INT 0
82624: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82625: LD_VAR 0 4
82629: PUSH
82630: LD_VAR 0 7
82634: ARRAY
82635: PPUSH
82636: CALL_OW 301
82640: PUSH
82641: LD_VAR 0 4
82645: PUSH
82646: LD_VAR 0 7
82650: ARRAY
82651: NOT
82652: OR
82653: IFFALSE 82762
// begin if GetType ( group [ i ] ) = unit_human then
82655: LD_VAR 0 4
82659: PUSH
82660: LD_VAR 0 7
82664: ARRAY
82665: PPUSH
82666: CALL_OW 247
82670: PUSH
82671: LD_INT 1
82673: EQUAL
82674: IFFALSE 82720
// begin to_heal := to_heal diff group [ i ] ;
82676: LD_ADDR_VAR 0 30
82680: PUSH
82681: LD_VAR 0 30
82685: PUSH
82686: LD_VAR 0 4
82690: PUSH
82691: LD_VAR 0 7
82695: ARRAY
82696: DIFF
82697: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82698: LD_ADDR_VAR 0 31
82702: PUSH
82703: LD_VAR 0 31
82707: PUSH
82708: LD_VAR 0 4
82712: PUSH
82713: LD_VAR 0 7
82717: ARRAY
82718: DIFF
82719: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82720: LD_ADDR_VAR 0 4
82724: PUSH
82725: LD_VAR 0 4
82729: PPUSH
82730: LD_VAR 0 7
82734: PPUSH
82735: CALL_OW 3
82739: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82740: LD_ADDR_VAR 0 16
82744: PUSH
82745: LD_VAR 0 16
82749: PPUSH
82750: LD_VAR 0 7
82754: PPUSH
82755: CALL_OW 3
82759: ST_TO_ADDR
// continue ;
82760: GO 82600
// end ; if f_repair then
82762: LD_VAR 0 22
82766: IFFALSE 83255
// begin if GetType ( group [ i ] ) = unit_vehicle then
82768: LD_VAR 0 4
82772: PUSH
82773: LD_VAR 0 7
82777: ARRAY
82778: PPUSH
82779: CALL_OW 247
82783: PUSH
82784: LD_INT 2
82786: EQUAL
82787: IFFALSE 82977
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82789: LD_VAR 0 4
82793: PUSH
82794: LD_VAR 0 7
82798: ARRAY
82799: PPUSH
82800: CALL_OW 256
82804: PUSH
82805: LD_INT 700
82807: LESS
82808: PUSH
82809: LD_VAR 0 4
82813: PUSH
82814: LD_VAR 0 7
82818: ARRAY
82819: PUSH
82820: LD_VAR 0 32
82824: IN
82825: NOT
82826: AND
82827: IFFALSE 82851
// to_repair := to_repair union group [ i ] ;
82829: LD_ADDR_VAR 0 32
82833: PUSH
82834: LD_VAR 0 32
82838: PUSH
82839: LD_VAR 0 4
82843: PUSH
82844: LD_VAR 0 7
82848: ARRAY
82849: UNION
82850: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82851: LD_VAR 0 4
82855: PUSH
82856: LD_VAR 0 7
82860: ARRAY
82861: PPUSH
82862: CALL_OW 256
82866: PUSH
82867: LD_INT 1000
82869: EQUAL
82870: PUSH
82871: LD_VAR 0 4
82875: PUSH
82876: LD_VAR 0 7
82880: ARRAY
82881: PUSH
82882: LD_VAR 0 32
82886: IN
82887: AND
82888: IFFALSE 82912
// to_repair := to_repair diff group [ i ] ;
82890: LD_ADDR_VAR 0 32
82894: PUSH
82895: LD_VAR 0 32
82899: PUSH
82900: LD_VAR 0 4
82904: PUSH
82905: LD_VAR 0 7
82909: ARRAY
82910: DIFF
82911: ST_TO_ADDR
// if group [ i ] in to_repair then
82912: LD_VAR 0 4
82916: PUSH
82917: LD_VAR 0 7
82921: ARRAY
82922: PUSH
82923: LD_VAR 0 32
82927: IN
82928: IFFALSE 82975
// begin if not IsInArea ( group [ i ] , f_repair ) then
82930: LD_VAR 0 4
82934: PUSH
82935: LD_VAR 0 7
82939: ARRAY
82940: PPUSH
82941: LD_VAR 0 22
82945: PPUSH
82946: CALL_OW 308
82950: NOT
82951: IFFALSE 82973
// ComMoveToArea ( group [ i ] , f_repair ) ;
82953: LD_VAR 0 4
82957: PUSH
82958: LD_VAR 0 7
82962: ARRAY
82963: PPUSH
82964: LD_VAR 0 22
82968: PPUSH
82969: CALL_OW 113
// continue ;
82973: GO 82600
// end ; end else
82975: GO 83255
// if group [ i ] in repairs then
82977: LD_VAR 0 4
82981: PUSH
82982: LD_VAR 0 7
82986: ARRAY
82987: PUSH
82988: LD_VAR 0 33
82992: IN
82993: IFFALSE 83255
// begin if IsInUnit ( group [ i ] ) then
82995: LD_VAR 0 4
82999: PUSH
83000: LD_VAR 0 7
83004: ARRAY
83005: PPUSH
83006: CALL_OW 310
83010: IFFALSE 83078
// begin z := IsInUnit ( group [ i ] ) ;
83012: LD_ADDR_VAR 0 13
83016: PUSH
83017: LD_VAR 0 4
83021: PUSH
83022: LD_VAR 0 7
83026: ARRAY
83027: PPUSH
83028: CALL_OW 310
83032: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83033: LD_VAR 0 13
83037: PUSH
83038: LD_VAR 0 32
83042: IN
83043: PUSH
83044: LD_VAR 0 13
83048: PPUSH
83049: LD_VAR 0 22
83053: PPUSH
83054: CALL_OW 308
83058: AND
83059: IFFALSE 83076
// ComExitVehicle ( group [ i ] ) ;
83061: LD_VAR 0 4
83065: PUSH
83066: LD_VAR 0 7
83070: ARRAY
83071: PPUSH
83072: CALL_OW 121
// end else
83076: GO 83255
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
83078: LD_ADDR_VAR 0 13
83082: PUSH
83083: LD_VAR 0 4
83087: PPUSH
83088: LD_INT 95
83090: PUSH
83091: LD_VAR 0 22
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 58
83102: PUSH
83103: EMPTY
83104: LIST
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PPUSH
83110: CALL_OW 72
83114: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
83115: LD_VAR 0 4
83119: PUSH
83120: LD_VAR 0 7
83124: ARRAY
83125: PPUSH
83126: CALL_OW 314
83130: NOT
83131: IFFALSE 83253
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
83133: LD_ADDR_VAR 0 10
83137: PUSH
83138: LD_VAR 0 13
83142: PPUSH
83143: LD_VAR 0 4
83147: PUSH
83148: LD_VAR 0 7
83152: ARRAY
83153: PPUSH
83154: CALL_OW 74
83158: ST_TO_ADDR
// if not x then
83159: LD_VAR 0 10
83163: NOT
83164: IFFALSE 83168
// continue ;
83166: GO 82600
// if GetLives ( x ) < 1000 then
83168: LD_VAR 0 10
83172: PPUSH
83173: CALL_OW 256
83177: PUSH
83178: LD_INT 1000
83180: LESS
83181: IFFALSE 83205
// ComRepairVehicle ( group [ i ] , x ) else
83183: LD_VAR 0 4
83187: PUSH
83188: LD_VAR 0 7
83192: ARRAY
83193: PPUSH
83194: LD_VAR 0 10
83198: PPUSH
83199: CALL_OW 129
83203: GO 83253
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
83205: LD_VAR 0 23
83209: PUSH
83210: LD_VAR 0 4
83214: PUSH
83215: LD_VAR 0 7
83219: ARRAY
83220: PPUSH
83221: CALL_OW 256
83225: PUSH
83226: LD_INT 1000
83228: LESS
83229: AND
83230: NOT
83231: IFFALSE 83253
// ComEnterUnit ( group [ i ] , x ) ;
83233: LD_VAR 0 4
83237: PUSH
83238: LD_VAR 0 7
83242: ARRAY
83243: PPUSH
83244: LD_VAR 0 10
83248: PPUSH
83249: CALL_OW 120
// end ; continue ;
83253: GO 82600
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
83255: LD_VAR 0 23
83259: PUSH
83260: LD_VAR 0 4
83264: PUSH
83265: LD_VAR 0 7
83269: ARRAY
83270: PPUSH
83271: CALL_OW 247
83275: PUSH
83276: LD_INT 1
83278: EQUAL
83279: AND
83280: IFFALSE 83758
// begin if group [ i ] in healers then
83282: LD_VAR 0 4
83286: PUSH
83287: LD_VAR 0 7
83291: ARRAY
83292: PUSH
83293: LD_VAR 0 31
83297: IN
83298: IFFALSE 83571
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
83300: LD_VAR 0 4
83304: PUSH
83305: LD_VAR 0 7
83309: ARRAY
83310: PPUSH
83311: LD_VAR 0 23
83315: PPUSH
83316: CALL_OW 308
83320: NOT
83321: PUSH
83322: LD_VAR 0 4
83326: PUSH
83327: LD_VAR 0 7
83331: ARRAY
83332: PPUSH
83333: CALL_OW 314
83337: NOT
83338: AND
83339: IFFALSE 83363
// ComMoveToArea ( group [ i ] , f_heal ) else
83341: LD_VAR 0 4
83345: PUSH
83346: LD_VAR 0 7
83350: ARRAY
83351: PPUSH
83352: LD_VAR 0 23
83356: PPUSH
83357: CALL_OW 113
83361: GO 83569
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
83363: LD_VAR 0 4
83367: PUSH
83368: LD_VAR 0 7
83372: ARRAY
83373: PPUSH
83374: CALL 44526 0 1
83378: PPUSH
83379: CALL_OW 256
83383: PUSH
83384: LD_INT 1000
83386: EQUAL
83387: IFFALSE 83406
// ComStop ( group [ i ] ) else
83389: LD_VAR 0 4
83393: PUSH
83394: LD_VAR 0 7
83398: ARRAY
83399: PPUSH
83400: CALL_OW 141
83404: GO 83569
// if not HasTask ( group [ i ] ) and to_heal then
83406: LD_VAR 0 4
83410: PUSH
83411: LD_VAR 0 7
83415: ARRAY
83416: PPUSH
83417: CALL_OW 314
83421: NOT
83422: PUSH
83423: LD_VAR 0 30
83427: AND
83428: IFFALSE 83569
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83430: LD_ADDR_VAR 0 13
83434: PUSH
83435: LD_VAR 0 30
83439: PPUSH
83440: LD_INT 3
83442: PUSH
83443: LD_INT 54
83445: PUSH
83446: EMPTY
83447: LIST
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PPUSH
83453: CALL_OW 72
83457: PPUSH
83458: LD_VAR 0 4
83462: PUSH
83463: LD_VAR 0 7
83467: ARRAY
83468: PPUSH
83469: CALL_OW 74
83473: ST_TO_ADDR
// if z then
83474: LD_VAR 0 13
83478: IFFALSE 83569
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83480: LD_INT 91
83482: PUSH
83483: LD_VAR 0 13
83487: PUSH
83488: LD_INT 10
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: LIST
83495: PUSH
83496: LD_INT 81
83498: PUSH
83499: LD_VAR 0 13
83503: PPUSH
83504: CALL_OW 255
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PPUSH
83517: CALL_OW 69
83521: PUSH
83522: LD_INT 0
83524: EQUAL
83525: IFFALSE 83549
// ComHeal ( group [ i ] , z ) else
83527: LD_VAR 0 4
83531: PUSH
83532: LD_VAR 0 7
83536: ARRAY
83537: PPUSH
83538: LD_VAR 0 13
83542: PPUSH
83543: CALL_OW 128
83547: GO 83569
// ComMoveToArea ( group [ i ] , f_heal ) ;
83549: LD_VAR 0 4
83553: PUSH
83554: LD_VAR 0 7
83558: ARRAY
83559: PPUSH
83560: LD_VAR 0 23
83564: PPUSH
83565: CALL_OW 113
// end ; continue ;
83569: GO 82600
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83571: LD_VAR 0 4
83575: PUSH
83576: LD_VAR 0 7
83580: ARRAY
83581: PPUSH
83582: CALL_OW 256
83586: PUSH
83587: LD_INT 700
83589: LESS
83590: PUSH
83591: LD_VAR 0 4
83595: PUSH
83596: LD_VAR 0 7
83600: ARRAY
83601: PUSH
83602: LD_VAR 0 30
83606: IN
83607: NOT
83608: AND
83609: IFFALSE 83633
// to_heal := to_heal union group [ i ] ;
83611: LD_ADDR_VAR 0 30
83615: PUSH
83616: LD_VAR 0 30
83620: PUSH
83621: LD_VAR 0 4
83625: PUSH
83626: LD_VAR 0 7
83630: ARRAY
83631: UNION
83632: ST_TO_ADDR
// if group [ i ] in to_heal then
83633: LD_VAR 0 4
83637: PUSH
83638: LD_VAR 0 7
83642: ARRAY
83643: PUSH
83644: LD_VAR 0 30
83648: IN
83649: IFFALSE 83758
// begin if GetLives ( group [ i ] ) = 1000 then
83651: LD_VAR 0 4
83655: PUSH
83656: LD_VAR 0 7
83660: ARRAY
83661: PPUSH
83662: CALL_OW 256
83666: PUSH
83667: LD_INT 1000
83669: EQUAL
83670: IFFALSE 83696
// to_heal := to_heal diff group [ i ] else
83672: LD_ADDR_VAR 0 30
83676: PUSH
83677: LD_VAR 0 30
83681: PUSH
83682: LD_VAR 0 4
83686: PUSH
83687: LD_VAR 0 7
83691: ARRAY
83692: DIFF
83693: ST_TO_ADDR
83694: GO 83758
// begin if not IsInArea ( group [ i ] , to_heal ) then
83696: LD_VAR 0 4
83700: PUSH
83701: LD_VAR 0 7
83705: ARRAY
83706: PPUSH
83707: LD_VAR 0 30
83711: PPUSH
83712: CALL_OW 308
83716: NOT
83717: IFFALSE 83741
// ComMoveToArea ( group [ i ] , f_heal ) else
83719: LD_VAR 0 4
83723: PUSH
83724: LD_VAR 0 7
83728: ARRAY
83729: PPUSH
83730: LD_VAR 0 23
83734: PPUSH
83735: CALL_OW 113
83739: GO 83756
// ComHold ( group [ i ] ) ;
83741: LD_VAR 0 4
83745: PUSH
83746: LD_VAR 0 7
83750: ARRAY
83751: PPUSH
83752: CALL_OW 140
// continue ;
83756: GO 82600
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83758: LD_VAR 0 4
83762: PUSH
83763: LD_VAR 0 7
83767: ARRAY
83768: PPUSH
83769: LD_INT 10
83771: PPUSH
83772: CALL 42297 0 2
83776: NOT
83777: PUSH
83778: LD_VAR 0 16
83782: PUSH
83783: LD_VAR 0 7
83787: ARRAY
83788: PUSH
83789: EMPTY
83790: EQUAL
83791: NOT
83792: AND
83793: IFFALSE 84059
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83795: LD_VAR 0 4
83799: PUSH
83800: LD_VAR 0 7
83804: ARRAY
83805: PPUSH
83806: CALL_OW 262
83810: PUSH
83811: LD_INT 1
83813: PUSH
83814: LD_INT 2
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: IN
83821: IFFALSE 83862
// if GetFuel ( group [ i ] ) < 10 then
83823: LD_VAR 0 4
83827: PUSH
83828: LD_VAR 0 7
83832: ARRAY
83833: PPUSH
83834: CALL_OW 261
83838: PUSH
83839: LD_INT 10
83841: LESS
83842: IFFALSE 83862
// SetFuel ( group [ i ] , 12 ) ;
83844: LD_VAR 0 4
83848: PUSH
83849: LD_VAR 0 7
83853: ARRAY
83854: PPUSH
83855: LD_INT 12
83857: PPUSH
83858: CALL_OW 240
// if units_path [ i ] then
83862: LD_VAR 0 16
83866: PUSH
83867: LD_VAR 0 7
83871: ARRAY
83872: IFFALSE 84057
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83874: LD_VAR 0 4
83878: PUSH
83879: LD_VAR 0 7
83883: ARRAY
83884: PPUSH
83885: LD_VAR 0 16
83889: PUSH
83890: LD_VAR 0 7
83894: ARRAY
83895: PUSH
83896: LD_INT 1
83898: ARRAY
83899: PUSH
83900: LD_INT 1
83902: ARRAY
83903: PPUSH
83904: LD_VAR 0 16
83908: PUSH
83909: LD_VAR 0 7
83913: ARRAY
83914: PUSH
83915: LD_INT 1
83917: ARRAY
83918: PUSH
83919: LD_INT 2
83921: ARRAY
83922: PPUSH
83923: CALL_OW 297
83927: PUSH
83928: LD_INT 6
83930: GREATER
83931: IFFALSE 84006
// begin if not HasTask ( group [ i ] ) then
83933: LD_VAR 0 4
83937: PUSH
83938: LD_VAR 0 7
83942: ARRAY
83943: PPUSH
83944: CALL_OW 314
83948: NOT
83949: IFFALSE 84004
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83951: LD_VAR 0 4
83955: PUSH
83956: LD_VAR 0 7
83960: ARRAY
83961: PPUSH
83962: LD_VAR 0 16
83966: PUSH
83967: LD_VAR 0 7
83971: ARRAY
83972: PUSH
83973: LD_INT 1
83975: ARRAY
83976: PUSH
83977: LD_INT 1
83979: ARRAY
83980: PPUSH
83981: LD_VAR 0 16
83985: PUSH
83986: LD_VAR 0 7
83990: ARRAY
83991: PUSH
83992: LD_INT 1
83994: ARRAY
83995: PUSH
83996: LD_INT 2
83998: ARRAY
83999: PPUSH
84000: CALL_OW 114
// end else
84004: GO 84057
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84006: LD_ADDR_VAR 0 15
84010: PUSH
84011: LD_VAR 0 16
84015: PUSH
84016: LD_VAR 0 7
84020: ARRAY
84021: PPUSH
84022: LD_INT 1
84024: PPUSH
84025: CALL_OW 3
84029: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84030: LD_ADDR_VAR 0 16
84034: PUSH
84035: LD_VAR 0 16
84039: PPUSH
84040: LD_VAR 0 7
84044: PPUSH
84045: LD_VAR 0 15
84049: PPUSH
84050: CALL_OW 1
84054: ST_TO_ADDR
// continue ;
84055: GO 82600
// end ; end ; end else
84057: GO 86721
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
84059: LD_ADDR_VAR 0 14
84063: PUSH
84064: LD_INT 81
84066: PUSH
84067: LD_VAR 0 4
84071: PUSH
84072: LD_VAR 0 7
84076: ARRAY
84077: PPUSH
84078: CALL_OW 255
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PPUSH
84087: CALL_OW 69
84091: ST_TO_ADDR
// if not tmp then
84092: LD_VAR 0 14
84096: NOT
84097: IFFALSE 84101
// continue ;
84099: GO 82600
// if f_ignore_area then
84101: LD_VAR 0 17
84105: IFFALSE 84193
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84107: LD_ADDR_VAR 0 15
84111: PUSH
84112: LD_VAR 0 14
84116: PPUSH
84117: LD_INT 3
84119: PUSH
84120: LD_INT 92
84122: PUSH
84123: LD_VAR 0 17
84127: PUSH
84128: LD_INT 1
84130: ARRAY
84131: PUSH
84132: LD_VAR 0 17
84136: PUSH
84137: LD_INT 2
84139: ARRAY
84140: PUSH
84141: LD_VAR 0 17
84145: PUSH
84146: LD_INT 3
84148: ARRAY
84149: PUSH
84150: EMPTY
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PPUSH
84160: CALL_OW 72
84164: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84165: LD_VAR 0 14
84169: PUSH
84170: LD_VAR 0 15
84174: DIFF
84175: IFFALSE 84193
// tmp := tmp diff tmp2 ;
84177: LD_ADDR_VAR 0 14
84181: PUSH
84182: LD_VAR 0 14
84186: PUSH
84187: LD_VAR 0 15
84191: DIFF
84192: ST_TO_ADDR
// end ; if not f_murder then
84193: LD_VAR 0 20
84197: NOT
84198: IFFALSE 84256
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
84200: LD_ADDR_VAR 0 15
84204: PUSH
84205: LD_VAR 0 14
84209: PPUSH
84210: LD_INT 3
84212: PUSH
84213: LD_INT 50
84215: PUSH
84216: EMPTY
84217: LIST
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PPUSH
84223: CALL_OW 72
84227: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
84228: LD_VAR 0 14
84232: PUSH
84233: LD_VAR 0 15
84237: DIFF
84238: IFFALSE 84256
// tmp := tmp diff tmp2 ;
84240: LD_ADDR_VAR 0 14
84244: PUSH
84245: LD_VAR 0 14
84249: PUSH
84250: LD_VAR 0 15
84254: DIFF
84255: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
84256: LD_ADDR_VAR 0 14
84260: PUSH
84261: LD_VAR 0 4
84265: PUSH
84266: LD_VAR 0 7
84270: ARRAY
84271: PPUSH
84272: LD_VAR 0 14
84276: PPUSH
84277: LD_INT 1
84279: PPUSH
84280: LD_INT 1
84282: PPUSH
84283: CALL 15209 0 4
84287: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
84288: LD_VAR 0 4
84292: PUSH
84293: LD_VAR 0 7
84297: ARRAY
84298: PPUSH
84299: CALL_OW 257
84303: PUSH
84304: LD_INT 1
84306: EQUAL
84307: IFFALSE 84755
// begin if WantPlant ( group [ i ] ) then
84309: LD_VAR 0 4
84313: PUSH
84314: LD_VAR 0 7
84318: ARRAY
84319: PPUSH
84320: CALL 14710 0 1
84324: IFFALSE 84328
// continue ;
84326: GO 82600
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
84328: LD_VAR 0 18
84332: PUSH
84333: LD_VAR 0 4
84337: PUSH
84338: LD_VAR 0 7
84342: ARRAY
84343: PPUSH
84344: CALL_OW 310
84348: NOT
84349: AND
84350: PUSH
84351: LD_VAR 0 14
84355: PUSH
84356: LD_INT 1
84358: ARRAY
84359: PUSH
84360: LD_VAR 0 14
84364: PPUSH
84365: LD_INT 21
84367: PUSH
84368: LD_INT 2
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 58
84377: PUSH
84378: EMPTY
84379: LIST
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: PPUSH
84385: CALL_OW 72
84389: IN
84390: AND
84391: IFFALSE 84427
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
84393: LD_VAR 0 4
84397: PUSH
84398: LD_VAR 0 7
84402: ARRAY
84403: PPUSH
84404: LD_VAR 0 14
84408: PUSH
84409: LD_INT 1
84411: ARRAY
84412: PPUSH
84413: CALL_OW 120
// attacking := true ;
84417: LD_ADDR_VAR 0 29
84421: PUSH
84422: LD_INT 1
84424: ST_TO_ADDR
// continue ;
84425: GO 82600
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84427: LD_VAR 0 26
84431: PUSH
84432: LD_VAR 0 4
84436: PUSH
84437: LD_VAR 0 7
84441: ARRAY
84442: PPUSH
84443: CALL_OW 257
84447: PUSH
84448: LD_INT 1
84450: EQUAL
84451: AND
84452: PUSH
84453: LD_VAR 0 4
84457: PUSH
84458: LD_VAR 0 7
84462: ARRAY
84463: PPUSH
84464: CALL_OW 256
84468: PUSH
84469: LD_INT 800
84471: LESS
84472: AND
84473: PUSH
84474: LD_VAR 0 4
84478: PUSH
84479: LD_VAR 0 7
84483: ARRAY
84484: PPUSH
84485: CALL_OW 318
84489: NOT
84490: AND
84491: IFFALSE 84508
// ComCrawl ( group [ i ] ) ;
84493: LD_VAR 0 4
84497: PUSH
84498: LD_VAR 0 7
84502: ARRAY
84503: PPUSH
84504: CALL_OW 137
// if f_mines then
84508: LD_VAR 0 21
84512: IFFALSE 84755
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84514: LD_VAR 0 14
84518: PUSH
84519: LD_INT 1
84521: ARRAY
84522: PPUSH
84523: CALL_OW 247
84527: PUSH
84528: LD_INT 3
84530: EQUAL
84531: PUSH
84532: LD_VAR 0 14
84536: PUSH
84537: LD_INT 1
84539: ARRAY
84540: PUSH
84541: LD_VAR 0 27
84545: IN
84546: NOT
84547: AND
84548: IFFALSE 84755
// begin x := GetX ( tmp [ 1 ] ) ;
84550: LD_ADDR_VAR 0 10
84554: PUSH
84555: LD_VAR 0 14
84559: PUSH
84560: LD_INT 1
84562: ARRAY
84563: PPUSH
84564: CALL_OW 250
84568: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84569: LD_ADDR_VAR 0 11
84573: PUSH
84574: LD_VAR 0 14
84578: PUSH
84579: LD_INT 1
84581: ARRAY
84582: PPUSH
84583: CALL_OW 251
84587: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84588: LD_ADDR_VAR 0 12
84592: PUSH
84593: LD_VAR 0 4
84597: PUSH
84598: LD_VAR 0 7
84602: ARRAY
84603: PPUSH
84604: CALL 42382 0 1
84608: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84609: LD_VAR 0 4
84613: PUSH
84614: LD_VAR 0 7
84618: ARRAY
84619: PPUSH
84620: LD_VAR 0 10
84624: PPUSH
84625: LD_VAR 0 11
84629: PPUSH
84630: LD_VAR 0 14
84634: PUSH
84635: LD_INT 1
84637: ARRAY
84638: PPUSH
84639: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84643: LD_VAR 0 4
84647: PUSH
84648: LD_VAR 0 7
84652: ARRAY
84653: PPUSH
84654: LD_VAR 0 10
84658: PPUSH
84659: LD_VAR 0 12
84663: PPUSH
84664: LD_INT 7
84666: PPUSH
84667: CALL_OW 272
84671: PPUSH
84672: LD_VAR 0 11
84676: PPUSH
84677: LD_VAR 0 12
84681: PPUSH
84682: LD_INT 7
84684: PPUSH
84685: CALL_OW 273
84689: PPUSH
84690: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
84694: LD_VAR 0 4
84698: PUSH
84699: LD_VAR 0 7
84703: ARRAY
84704: PPUSH
84705: LD_INT 71
84707: PPUSH
84708: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84712: LD_ADDR_VAR 0 27
84716: PUSH
84717: LD_VAR 0 27
84721: PPUSH
84722: LD_VAR 0 27
84726: PUSH
84727: LD_INT 1
84729: PLUS
84730: PPUSH
84731: LD_VAR 0 14
84735: PUSH
84736: LD_INT 1
84738: ARRAY
84739: PPUSH
84740: CALL_OW 1
84744: ST_TO_ADDR
// attacking := true ;
84745: LD_ADDR_VAR 0 29
84749: PUSH
84750: LD_INT 1
84752: ST_TO_ADDR
// continue ;
84753: GO 82600
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84755: LD_VAR 0 4
84759: PUSH
84760: LD_VAR 0 7
84764: ARRAY
84765: PPUSH
84766: CALL_OW 257
84770: PUSH
84771: LD_INT 17
84773: EQUAL
84774: PUSH
84775: LD_VAR 0 4
84779: PUSH
84780: LD_VAR 0 7
84784: ARRAY
84785: PPUSH
84786: CALL_OW 110
84790: PUSH
84791: LD_INT 71
84793: EQUAL
84794: NOT
84795: AND
84796: IFFALSE 84942
// begin attacking := false ;
84798: LD_ADDR_VAR 0 29
84802: PUSH
84803: LD_INT 0
84805: ST_TO_ADDR
// k := 5 ;
84806: LD_ADDR_VAR 0 9
84810: PUSH
84811: LD_INT 5
84813: ST_TO_ADDR
// if tmp < k then
84814: LD_VAR 0 14
84818: PUSH
84819: LD_VAR 0 9
84823: LESS
84824: IFFALSE 84836
// k := tmp ;
84826: LD_ADDR_VAR 0 9
84830: PUSH
84831: LD_VAR 0 14
84835: ST_TO_ADDR
// for j = 1 to k do
84836: LD_ADDR_VAR 0 8
84840: PUSH
84841: DOUBLE
84842: LD_INT 1
84844: DEC
84845: ST_TO_ADDR
84846: LD_VAR 0 9
84850: PUSH
84851: FOR_TO
84852: IFFALSE 84940
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84854: LD_VAR 0 14
84858: PUSH
84859: LD_VAR 0 8
84863: ARRAY
84864: PUSH
84865: LD_VAR 0 14
84869: PPUSH
84870: LD_INT 58
84872: PUSH
84873: EMPTY
84874: LIST
84875: PPUSH
84876: CALL_OW 72
84880: IN
84881: NOT
84882: IFFALSE 84938
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84884: LD_VAR 0 4
84888: PUSH
84889: LD_VAR 0 7
84893: ARRAY
84894: PPUSH
84895: LD_VAR 0 14
84899: PUSH
84900: LD_VAR 0 8
84904: ARRAY
84905: PPUSH
84906: CALL_OW 115
// attacking := true ;
84910: LD_ADDR_VAR 0 29
84914: PUSH
84915: LD_INT 1
84917: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84918: LD_VAR 0 4
84922: PUSH
84923: LD_VAR 0 7
84927: ARRAY
84928: PPUSH
84929: LD_INT 71
84931: PPUSH
84932: CALL_OW 109
// continue ;
84936: GO 84851
// end ; end ;
84938: GO 84851
84940: POP
84941: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84942: LD_VAR 0 4
84946: PUSH
84947: LD_VAR 0 7
84951: ARRAY
84952: PPUSH
84953: CALL_OW 257
84957: PUSH
84958: LD_INT 8
84960: EQUAL
84961: PUSH
84962: LD_VAR 0 4
84966: PUSH
84967: LD_VAR 0 7
84971: ARRAY
84972: PPUSH
84973: CALL_OW 264
84977: PUSH
84978: LD_INT 28
84980: PUSH
84981: LD_INT 45
84983: PUSH
84984: LD_INT 7
84986: PUSH
84987: LD_INT 47
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: LIST
84994: LIST
84995: IN
84996: OR
84997: IFFALSE 85253
// begin attacking := false ;
84999: LD_ADDR_VAR 0 29
85003: PUSH
85004: LD_INT 0
85006: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85007: LD_VAR 0 14
85011: PUSH
85012: LD_INT 1
85014: ARRAY
85015: PPUSH
85016: CALL_OW 266
85020: PUSH
85021: LD_INT 32
85023: PUSH
85024: LD_INT 31
85026: PUSH
85027: LD_INT 33
85029: PUSH
85030: LD_INT 4
85032: PUSH
85033: LD_INT 5
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: LIST
85040: LIST
85041: LIST
85042: IN
85043: IFFALSE 85229
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85045: LD_ADDR_VAR 0 9
85049: PUSH
85050: LD_VAR 0 14
85054: PUSH
85055: LD_INT 1
85057: ARRAY
85058: PPUSH
85059: CALL_OW 266
85063: PPUSH
85064: LD_VAR 0 14
85068: PUSH
85069: LD_INT 1
85071: ARRAY
85072: PPUSH
85073: CALL_OW 250
85077: PPUSH
85078: LD_VAR 0 14
85082: PUSH
85083: LD_INT 1
85085: ARRAY
85086: PPUSH
85087: CALL_OW 251
85091: PPUSH
85092: LD_VAR 0 14
85096: PUSH
85097: LD_INT 1
85099: ARRAY
85100: PPUSH
85101: CALL_OW 254
85105: PPUSH
85106: LD_VAR 0 14
85110: PUSH
85111: LD_INT 1
85113: ARRAY
85114: PPUSH
85115: CALL_OW 248
85119: PPUSH
85120: LD_INT 0
85122: PPUSH
85123: CALL 23752 0 6
85127: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
85128: LD_ADDR_VAR 0 8
85132: PUSH
85133: LD_VAR 0 4
85137: PUSH
85138: LD_VAR 0 7
85142: ARRAY
85143: PPUSH
85144: LD_VAR 0 9
85148: PPUSH
85149: CALL 42495 0 2
85153: ST_TO_ADDR
// if j then
85154: LD_VAR 0 8
85158: IFFALSE 85227
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
85160: LD_VAR 0 8
85164: PUSH
85165: LD_INT 1
85167: ARRAY
85168: PPUSH
85169: LD_VAR 0 8
85173: PUSH
85174: LD_INT 2
85176: ARRAY
85177: PPUSH
85178: CALL_OW 488
85182: IFFALSE 85227
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
85184: LD_VAR 0 4
85188: PUSH
85189: LD_VAR 0 7
85193: ARRAY
85194: PPUSH
85195: LD_VAR 0 8
85199: PUSH
85200: LD_INT 1
85202: ARRAY
85203: PPUSH
85204: LD_VAR 0 8
85208: PUSH
85209: LD_INT 2
85211: ARRAY
85212: PPUSH
85213: CALL_OW 116
// attacking := true ;
85217: LD_ADDR_VAR 0 29
85221: PUSH
85222: LD_INT 1
85224: ST_TO_ADDR
// continue ;
85225: GO 82600
// end ; end else
85227: GO 85253
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85229: LD_VAR 0 4
85233: PUSH
85234: LD_VAR 0 7
85238: ARRAY
85239: PPUSH
85240: LD_VAR 0 14
85244: PUSH
85245: LD_INT 1
85247: ARRAY
85248: PPUSH
85249: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
85253: LD_VAR 0 4
85257: PUSH
85258: LD_VAR 0 7
85262: ARRAY
85263: PPUSH
85264: CALL_OW 265
85268: PUSH
85269: LD_INT 11
85271: EQUAL
85272: IFFALSE 85550
// begin k := 10 ;
85274: LD_ADDR_VAR 0 9
85278: PUSH
85279: LD_INT 10
85281: ST_TO_ADDR
// x := 0 ;
85282: LD_ADDR_VAR 0 10
85286: PUSH
85287: LD_INT 0
85289: ST_TO_ADDR
// if tmp < k then
85290: LD_VAR 0 14
85294: PUSH
85295: LD_VAR 0 9
85299: LESS
85300: IFFALSE 85312
// k := tmp ;
85302: LD_ADDR_VAR 0 9
85306: PUSH
85307: LD_VAR 0 14
85311: ST_TO_ADDR
// for j = k downto 1 do
85312: LD_ADDR_VAR 0 8
85316: PUSH
85317: DOUBLE
85318: LD_VAR 0 9
85322: INC
85323: ST_TO_ADDR
85324: LD_INT 1
85326: PUSH
85327: FOR_DOWNTO
85328: IFFALSE 85403
// begin if GetType ( tmp [ j ] ) = unit_human then
85330: LD_VAR 0 14
85334: PUSH
85335: LD_VAR 0 8
85339: ARRAY
85340: PPUSH
85341: CALL_OW 247
85345: PUSH
85346: LD_INT 1
85348: EQUAL
85349: IFFALSE 85401
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
85351: LD_VAR 0 4
85355: PUSH
85356: LD_VAR 0 7
85360: ARRAY
85361: PPUSH
85362: LD_VAR 0 14
85366: PUSH
85367: LD_VAR 0 8
85371: ARRAY
85372: PPUSH
85373: CALL 42749 0 2
// x := tmp [ j ] ;
85377: LD_ADDR_VAR 0 10
85381: PUSH
85382: LD_VAR 0 14
85386: PUSH
85387: LD_VAR 0 8
85391: ARRAY
85392: ST_TO_ADDR
// attacking := true ;
85393: LD_ADDR_VAR 0 29
85397: PUSH
85398: LD_INT 1
85400: ST_TO_ADDR
// end ; end ;
85401: GO 85327
85403: POP
85404: POP
// if not x then
85405: LD_VAR 0 10
85409: NOT
85410: IFFALSE 85550
// begin attacking := true ;
85412: LD_ADDR_VAR 0 29
85416: PUSH
85417: LD_INT 1
85419: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85420: LD_VAR 0 4
85424: PUSH
85425: LD_VAR 0 7
85429: ARRAY
85430: PPUSH
85431: CALL_OW 250
85435: PPUSH
85436: LD_VAR 0 4
85440: PUSH
85441: LD_VAR 0 7
85445: ARRAY
85446: PPUSH
85447: CALL_OW 251
85451: PPUSH
85452: CALL_OW 546
85456: PUSH
85457: LD_INT 2
85459: ARRAY
85460: PUSH
85461: LD_VAR 0 14
85465: PUSH
85466: LD_INT 1
85468: ARRAY
85469: PPUSH
85470: CALL_OW 250
85474: PPUSH
85475: LD_VAR 0 14
85479: PUSH
85480: LD_INT 1
85482: ARRAY
85483: PPUSH
85484: CALL_OW 251
85488: PPUSH
85489: CALL_OW 546
85493: PUSH
85494: LD_INT 2
85496: ARRAY
85497: EQUAL
85498: IFFALSE 85526
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85500: LD_VAR 0 4
85504: PUSH
85505: LD_VAR 0 7
85509: ARRAY
85510: PPUSH
85511: LD_VAR 0 14
85515: PUSH
85516: LD_INT 1
85518: ARRAY
85519: PPUSH
85520: CALL 42749 0 2
85524: GO 85550
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85526: LD_VAR 0 4
85530: PUSH
85531: LD_VAR 0 7
85535: ARRAY
85536: PPUSH
85537: LD_VAR 0 14
85541: PUSH
85542: LD_INT 1
85544: ARRAY
85545: PPUSH
85546: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85550: LD_VAR 0 4
85554: PUSH
85555: LD_VAR 0 7
85559: ARRAY
85560: PPUSH
85561: CALL_OW 264
85565: PUSH
85566: LD_INT 29
85568: EQUAL
85569: IFFALSE 85935
// begin if WantsToAttack ( group [ i ] ) in bombed then
85571: LD_VAR 0 4
85575: PUSH
85576: LD_VAR 0 7
85580: ARRAY
85581: PPUSH
85582: CALL_OW 319
85586: PUSH
85587: LD_VAR 0 28
85591: IN
85592: IFFALSE 85596
// continue ;
85594: GO 82600
// k := 8 ;
85596: LD_ADDR_VAR 0 9
85600: PUSH
85601: LD_INT 8
85603: ST_TO_ADDR
// x := 0 ;
85604: LD_ADDR_VAR 0 10
85608: PUSH
85609: LD_INT 0
85611: ST_TO_ADDR
// if tmp < k then
85612: LD_VAR 0 14
85616: PUSH
85617: LD_VAR 0 9
85621: LESS
85622: IFFALSE 85634
// k := tmp ;
85624: LD_ADDR_VAR 0 9
85628: PUSH
85629: LD_VAR 0 14
85633: ST_TO_ADDR
// for j = 1 to k do
85634: LD_ADDR_VAR 0 8
85638: PUSH
85639: DOUBLE
85640: LD_INT 1
85642: DEC
85643: ST_TO_ADDR
85644: LD_VAR 0 9
85648: PUSH
85649: FOR_TO
85650: IFFALSE 85782
// begin if GetType ( tmp [ j ] ) = unit_building then
85652: LD_VAR 0 14
85656: PUSH
85657: LD_VAR 0 8
85661: ARRAY
85662: PPUSH
85663: CALL_OW 247
85667: PUSH
85668: LD_INT 3
85670: EQUAL
85671: IFFALSE 85780
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85673: LD_VAR 0 14
85677: PUSH
85678: LD_VAR 0 8
85682: ARRAY
85683: PUSH
85684: LD_VAR 0 28
85688: IN
85689: NOT
85690: PUSH
85691: LD_VAR 0 14
85695: PUSH
85696: LD_VAR 0 8
85700: ARRAY
85701: PPUSH
85702: CALL_OW 313
85706: AND
85707: IFFALSE 85780
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85709: LD_VAR 0 4
85713: PUSH
85714: LD_VAR 0 7
85718: ARRAY
85719: PPUSH
85720: LD_VAR 0 14
85724: PUSH
85725: LD_VAR 0 8
85729: ARRAY
85730: PPUSH
85731: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85735: LD_ADDR_VAR 0 28
85739: PUSH
85740: LD_VAR 0 28
85744: PPUSH
85745: LD_VAR 0 28
85749: PUSH
85750: LD_INT 1
85752: PLUS
85753: PPUSH
85754: LD_VAR 0 14
85758: PUSH
85759: LD_VAR 0 8
85763: ARRAY
85764: PPUSH
85765: CALL_OW 1
85769: ST_TO_ADDR
// attacking := true ;
85770: LD_ADDR_VAR 0 29
85774: PUSH
85775: LD_INT 1
85777: ST_TO_ADDR
// break ;
85778: GO 85782
// end ; end ;
85780: GO 85649
85782: POP
85783: POP
// if not attacking and f_attack_depot then
85784: LD_VAR 0 29
85788: NOT
85789: PUSH
85790: LD_VAR 0 25
85794: AND
85795: IFFALSE 85890
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85797: LD_ADDR_VAR 0 13
85801: PUSH
85802: LD_VAR 0 14
85806: PPUSH
85807: LD_INT 2
85809: PUSH
85810: LD_INT 30
85812: PUSH
85813: LD_INT 0
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 30
85822: PUSH
85823: LD_INT 1
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: EMPTY
85831: LIST
85832: LIST
85833: LIST
85834: PPUSH
85835: CALL_OW 72
85839: ST_TO_ADDR
// if z then
85840: LD_VAR 0 13
85844: IFFALSE 85890
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85846: LD_VAR 0 4
85850: PUSH
85851: LD_VAR 0 7
85855: ARRAY
85856: PPUSH
85857: LD_VAR 0 13
85861: PPUSH
85862: LD_VAR 0 4
85866: PUSH
85867: LD_VAR 0 7
85871: ARRAY
85872: PPUSH
85873: CALL_OW 74
85877: PPUSH
85878: CALL_OW 115
// attacking := true ;
85882: LD_ADDR_VAR 0 29
85886: PUSH
85887: LD_INT 1
85889: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85890: LD_VAR 0 4
85894: PUSH
85895: LD_VAR 0 7
85899: ARRAY
85900: PPUSH
85901: CALL_OW 256
85905: PUSH
85906: LD_INT 500
85908: LESS
85909: IFFALSE 85935
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85911: LD_VAR 0 4
85915: PUSH
85916: LD_VAR 0 7
85920: ARRAY
85921: PPUSH
85922: LD_VAR 0 14
85926: PUSH
85927: LD_INT 1
85929: ARRAY
85930: PPUSH
85931: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85935: LD_VAR 0 4
85939: PUSH
85940: LD_VAR 0 7
85944: ARRAY
85945: PPUSH
85946: CALL_OW 264
85950: PUSH
85951: LD_INT 49
85953: EQUAL
85954: IFFALSE 86075
// begin if not HasTask ( group [ i ] ) then
85956: LD_VAR 0 4
85960: PUSH
85961: LD_VAR 0 7
85965: ARRAY
85966: PPUSH
85967: CALL_OW 314
85971: NOT
85972: IFFALSE 86075
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85974: LD_ADDR_VAR 0 9
85978: PUSH
85979: LD_INT 81
85981: PUSH
85982: LD_VAR 0 4
85986: PUSH
85987: LD_VAR 0 7
85991: ARRAY
85992: PPUSH
85993: CALL_OW 255
85997: PUSH
85998: EMPTY
85999: LIST
86000: LIST
86001: PPUSH
86002: CALL_OW 69
86006: PPUSH
86007: LD_VAR 0 4
86011: PUSH
86012: LD_VAR 0 7
86016: ARRAY
86017: PPUSH
86018: CALL_OW 74
86022: ST_TO_ADDR
// if k then
86023: LD_VAR 0 9
86027: IFFALSE 86075
// if GetDistUnits ( group [ i ] , k ) > 10 then
86029: LD_VAR 0 4
86033: PUSH
86034: LD_VAR 0 7
86038: ARRAY
86039: PPUSH
86040: LD_VAR 0 9
86044: PPUSH
86045: CALL_OW 296
86049: PUSH
86050: LD_INT 10
86052: GREATER
86053: IFFALSE 86075
// ComMoveUnit ( group [ i ] , k ) ;
86055: LD_VAR 0 4
86059: PUSH
86060: LD_VAR 0 7
86064: ARRAY
86065: PPUSH
86066: LD_VAR 0 9
86070: PPUSH
86071: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86075: LD_VAR 0 4
86079: PUSH
86080: LD_VAR 0 7
86084: ARRAY
86085: PPUSH
86086: CALL_OW 256
86090: PUSH
86091: LD_INT 250
86093: LESS
86094: PUSH
86095: LD_VAR 0 4
86099: PUSH
86100: LD_VAR 0 7
86104: ARRAY
86105: PUSH
86106: LD_INT 21
86108: PUSH
86109: LD_INT 2
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 23
86118: PUSH
86119: LD_INT 2
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PPUSH
86130: CALL_OW 69
86134: IN
86135: AND
86136: IFFALSE 86261
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
86138: LD_ADDR_VAR 0 9
86142: PUSH
86143: LD_OWVAR 3
86147: PUSH
86148: LD_VAR 0 4
86152: PUSH
86153: LD_VAR 0 7
86157: ARRAY
86158: DIFF
86159: PPUSH
86160: LD_VAR 0 4
86164: PUSH
86165: LD_VAR 0 7
86169: ARRAY
86170: PPUSH
86171: CALL_OW 74
86175: ST_TO_ADDR
// if not k then
86176: LD_VAR 0 9
86180: NOT
86181: IFFALSE 86185
// continue ;
86183: GO 82600
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
86185: LD_VAR 0 9
86189: PUSH
86190: LD_INT 81
86192: PUSH
86193: LD_VAR 0 4
86197: PUSH
86198: LD_VAR 0 7
86202: ARRAY
86203: PPUSH
86204: CALL_OW 255
86208: PUSH
86209: EMPTY
86210: LIST
86211: LIST
86212: PPUSH
86213: CALL_OW 69
86217: IN
86218: PUSH
86219: LD_VAR 0 9
86223: PPUSH
86224: LD_VAR 0 4
86228: PUSH
86229: LD_VAR 0 7
86233: ARRAY
86234: PPUSH
86235: CALL_OW 296
86239: PUSH
86240: LD_INT 5
86242: LESS
86243: AND
86244: IFFALSE 86261
// ComAutodestruct ( group [ i ] ) ;
86246: LD_VAR 0 4
86250: PUSH
86251: LD_VAR 0 7
86255: ARRAY
86256: PPUSH
86257: CALL 42647 0 1
// end ; if f_attack_depot then
86261: LD_VAR 0 25
86265: IFFALSE 86377
// begin k := 6 ;
86267: LD_ADDR_VAR 0 9
86271: PUSH
86272: LD_INT 6
86274: ST_TO_ADDR
// if tmp < k then
86275: LD_VAR 0 14
86279: PUSH
86280: LD_VAR 0 9
86284: LESS
86285: IFFALSE 86297
// k := tmp ;
86287: LD_ADDR_VAR 0 9
86291: PUSH
86292: LD_VAR 0 14
86296: ST_TO_ADDR
// for j = 1 to k do
86297: LD_ADDR_VAR 0 8
86301: PUSH
86302: DOUBLE
86303: LD_INT 1
86305: DEC
86306: ST_TO_ADDR
86307: LD_VAR 0 9
86311: PUSH
86312: FOR_TO
86313: IFFALSE 86375
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
86315: LD_VAR 0 8
86319: PPUSH
86320: CALL_OW 266
86324: PUSH
86325: LD_INT 0
86327: PUSH
86328: LD_INT 1
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: IN
86335: IFFALSE 86373
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86337: LD_VAR 0 4
86341: PUSH
86342: LD_VAR 0 7
86346: ARRAY
86347: PPUSH
86348: LD_VAR 0 14
86352: PUSH
86353: LD_VAR 0 8
86357: ARRAY
86358: PPUSH
86359: CALL_OW 115
// attacking := true ;
86363: LD_ADDR_VAR 0 29
86367: PUSH
86368: LD_INT 1
86370: ST_TO_ADDR
// break ;
86371: GO 86375
// end ;
86373: GO 86312
86375: POP
86376: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
86377: LD_VAR 0 4
86381: PUSH
86382: LD_VAR 0 7
86386: ARRAY
86387: PPUSH
86388: CALL_OW 302
86392: PUSH
86393: LD_VAR 0 29
86397: NOT
86398: AND
86399: IFFALSE 86721
// begin if GetTag ( group [ i ] ) = 71 then
86401: LD_VAR 0 4
86405: PUSH
86406: LD_VAR 0 7
86410: ARRAY
86411: PPUSH
86412: CALL_OW 110
86416: PUSH
86417: LD_INT 71
86419: EQUAL
86420: IFFALSE 86461
// begin if HasTask ( group [ i ] ) then
86422: LD_VAR 0 4
86426: PUSH
86427: LD_VAR 0 7
86431: ARRAY
86432: PPUSH
86433: CALL_OW 314
86437: IFFALSE 86443
// continue else
86439: GO 82600
86441: GO 86461
// SetTag ( group [ i ] , 0 ) ;
86443: LD_VAR 0 4
86447: PUSH
86448: LD_VAR 0 7
86452: ARRAY
86453: PPUSH
86454: LD_INT 0
86456: PPUSH
86457: CALL_OW 109
// end ; k := 8 ;
86461: LD_ADDR_VAR 0 9
86465: PUSH
86466: LD_INT 8
86468: ST_TO_ADDR
// x := 0 ;
86469: LD_ADDR_VAR 0 10
86473: PUSH
86474: LD_INT 0
86476: ST_TO_ADDR
// if tmp < k then
86477: LD_VAR 0 14
86481: PUSH
86482: LD_VAR 0 9
86486: LESS
86487: IFFALSE 86499
// k := tmp ;
86489: LD_ADDR_VAR 0 9
86493: PUSH
86494: LD_VAR 0 14
86498: ST_TO_ADDR
// for j = 1 to k do
86499: LD_ADDR_VAR 0 8
86503: PUSH
86504: DOUBLE
86505: LD_INT 1
86507: DEC
86508: ST_TO_ADDR
86509: LD_VAR 0 9
86513: PUSH
86514: FOR_TO
86515: IFFALSE 86613
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86517: LD_VAR 0 14
86521: PUSH
86522: LD_VAR 0 8
86526: ARRAY
86527: PPUSH
86528: CALL_OW 247
86532: PUSH
86533: LD_INT 1
86535: EQUAL
86536: PUSH
86537: LD_VAR 0 14
86541: PUSH
86542: LD_VAR 0 8
86546: ARRAY
86547: PPUSH
86548: CALL_OW 256
86552: PUSH
86553: LD_INT 250
86555: LESS
86556: PUSH
86557: LD_VAR 0 20
86561: AND
86562: PUSH
86563: LD_VAR 0 20
86567: NOT
86568: PUSH
86569: LD_VAR 0 14
86573: PUSH
86574: LD_VAR 0 8
86578: ARRAY
86579: PPUSH
86580: CALL_OW 256
86584: PUSH
86585: LD_INT 250
86587: GREATEREQUAL
86588: AND
86589: OR
86590: AND
86591: IFFALSE 86611
// begin x := tmp [ j ] ;
86593: LD_ADDR_VAR 0 10
86597: PUSH
86598: LD_VAR 0 14
86602: PUSH
86603: LD_VAR 0 8
86607: ARRAY
86608: ST_TO_ADDR
// break ;
86609: GO 86613
// end ;
86611: GO 86514
86613: POP
86614: POP
// if x then
86615: LD_VAR 0 10
86619: IFFALSE 86643
// ComAttackUnit ( group [ i ] , x ) else
86621: LD_VAR 0 4
86625: PUSH
86626: LD_VAR 0 7
86630: ARRAY
86631: PPUSH
86632: LD_VAR 0 10
86636: PPUSH
86637: CALL_OW 115
86641: GO 86667
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86643: LD_VAR 0 4
86647: PUSH
86648: LD_VAR 0 7
86652: ARRAY
86653: PPUSH
86654: LD_VAR 0 14
86658: PUSH
86659: LD_INT 1
86661: ARRAY
86662: PPUSH
86663: CALL_OW 115
// if not HasTask ( group [ i ] ) then
86667: LD_VAR 0 4
86671: PUSH
86672: LD_VAR 0 7
86676: ARRAY
86677: PPUSH
86678: CALL_OW 314
86682: NOT
86683: IFFALSE 86721
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86685: LD_VAR 0 4
86689: PUSH
86690: LD_VAR 0 7
86694: ARRAY
86695: PPUSH
86696: LD_VAR 0 14
86700: PPUSH
86701: LD_VAR 0 4
86705: PUSH
86706: LD_VAR 0 7
86710: ARRAY
86711: PPUSH
86712: CALL_OW 74
86716: PPUSH
86717: CALL_OW 115
// end ; end ; end ;
86721: GO 82600
86723: POP
86724: POP
// wait ( 0 0$2 ) ;
86725: LD_INT 70
86727: PPUSH
86728: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86732: LD_VAR 0 4
86736: NOT
86737: PUSH
86738: LD_VAR 0 4
86742: PUSH
86743: EMPTY
86744: EQUAL
86745: OR
86746: PUSH
86747: LD_INT 81
86749: PUSH
86750: LD_VAR 0 35
86754: PUSH
86755: EMPTY
86756: LIST
86757: LIST
86758: PPUSH
86759: CALL_OW 69
86763: NOT
86764: OR
86765: IFFALSE 82585
// end ;
86767: LD_VAR 0 2
86771: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86772: LD_INT 0
86774: PPUSH
86775: PPUSH
86776: PPUSH
86777: PPUSH
86778: PPUSH
86779: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86780: LD_VAR 0 1
86784: NOT
86785: PUSH
86786: LD_EXP 43
86790: PUSH
86791: LD_VAR 0 1
86795: ARRAY
86796: NOT
86797: OR
86798: PUSH
86799: LD_VAR 0 2
86803: NOT
86804: OR
86805: IFFALSE 86809
// exit ;
86807: GO 87363
// side := mc_sides [ base ] ;
86809: LD_ADDR_VAR 0 6
86813: PUSH
86814: LD_EXP 69
86818: PUSH
86819: LD_VAR 0 1
86823: ARRAY
86824: ST_TO_ADDR
// if not side then
86825: LD_VAR 0 6
86829: NOT
86830: IFFALSE 86834
// exit ;
86832: GO 87363
// for i in solds do
86834: LD_ADDR_VAR 0 7
86838: PUSH
86839: LD_VAR 0 2
86843: PUSH
86844: FOR_IN
86845: IFFALSE 86906
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86847: LD_VAR 0 7
86851: PPUSH
86852: CALL_OW 310
86856: PPUSH
86857: CALL_OW 266
86861: PUSH
86862: LD_INT 32
86864: PUSH
86865: LD_INT 31
86867: PUSH
86868: EMPTY
86869: LIST
86870: LIST
86871: IN
86872: IFFALSE 86892
// solds := solds diff i else
86874: LD_ADDR_VAR 0 2
86878: PUSH
86879: LD_VAR 0 2
86883: PUSH
86884: LD_VAR 0 7
86888: DIFF
86889: ST_TO_ADDR
86890: GO 86904
// SetTag ( i , 18 ) ;
86892: LD_VAR 0 7
86896: PPUSH
86897: LD_INT 18
86899: PPUSH
86900: CALL_OW 109
86904: GO 86844
86906: POP
86907: POP
// if not solds then
86908: LD_VAR 0 2
86912: NOT
86913: IFFALSE 86917
// exit ;
86915: GO 87363
// repeat wait ( 0 0$2 ) ;
86917: LD_INT 70
86919: PPUSH
86920: CALL_OW 67
// enemy := mc_scan [ base ] ;
86924: LD_ADDR_VAR 0 4
86928: PUSH
86929: LD_EXP 66
86933: PUSH
86934: LD_VAR 0 1
86938: ARRAY
86939: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86940: LD_EXP 43
86944: PUSH
86945: LD_VAR 0 1
86949: ARRAY
86950: NOT
86951: PUSH
86952: LD_EXP 43
86956: PUSH
86957: LD_VAR 0 1
86961: ARRAY
86962: PUSH
86963: EMPTY
86964: EQUAL
86965: OR
86966: IFFALSE 87003
// begin for i in solds do
86968: LD_ADDR_VAR 0 7
86972: PUSH
86973: LD_VAR 0 2
86977: PUSH
86978: FOR_IN
86979: IFFALSE 86992
// ComStop ( i ) ;
86981: LD_VAR 0 7
86985: PPUSH
86986: CALL_OW 141
86990: GO 86978
86992: POP
86993: POP
// solds := [ ] ;
86994: LD_ADDR_VAR 0 2
86998: PUSH
86999: EMPTY
87000: ST_TO_ADDR
// exit ;
87001: GO 87363
// end ; for i in solds do
87003: LD_ADDR_VAR 0 7
87007: PUSH
87008: LD_VAR 0 2
87012: PUSH
87013: FOR_IN
87014: IFFALSE 87335
// begin if IsInUnit ( i ) then
87016: LD_VAR 0 7
87020: PPUSH
87021: CALL_OW 310
87025: IFFALSE 87036
// ComExitBuilding ( i ) ;
87027: LD_VAR 0 7
87031: PPUSH
87032: CALL_OW 122
// if GetLives ( i ) > 500 then
87036: LD_VAR 0 7
87040: PPUSH
87041: CALL_OW 256
87045: PUSH
87046: LD_INT 500
87048: GREATER
87049: IFFALSE 87102
// begin e := NearestUnitToUnit ( enemy , i ) ;
87051: LD_ADDR_VAR 0 5
87055: PUSH
87056: LD_VAR 0 4
87060: PPUSH
87061: LD_VAR 0 7
87065: PPUSH
87066: CALL_OW 74
87070: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
87071: LD_VAR 0 7
87075: PPUSH
87076: LD_VAR 0 5
87080: PPUSH
87081: CALL_OW 250
87085: PPUSH
87086: LD_VAR 0 5
87090: PPUSH
87091: CALL_OW 251
87095: PPUSH
87096: CALL_OW 114
// end else
87100: GO 87333
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
87102: LD_VAR 0 7
87106: PPUSH
87107: LD_EXP 43
87111: PUSH
87112: LD_VAR 0 1
87116: ARRAY
87117: PPUSH
87118: LD_INT 2
87120: PUSH
87121: LD_INT 30
87123: PUSH
87124: LD_INT 0
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: PUSH
87131: LD_INT 30
87133: PUSH
87134: LD_INT 1
87136: PUSH
87137: EMPTY
87138: LIST
87139: LIST
87140: PUSH
87141: LD_INT 30
87143: PUSH
87144: LD_INT 6
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: LIST
87155: LIST
87156: PPUSH
87157: CALL_OW 72
87161: PPUSH
87162: LD_VAR 0 7
87166: PPUSH
87167: CALL_OW 74
87171: PPUSH
87172: CALL_OW 296
87176: PUSH
87177: LD_INT 10
87179: GREATER
87180: IFFALSE 87333
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
87182: LD_ADDR_VAR 0 8
87186: PUSH
87187: LD_EXP 43
87191: PUSH
87192: LD_VAR 0 1
87196: ARRAY
87197: PPUSH
87198: LD_INT 2
87200: PUSH
87201: LD_INT 30
87203: PUSH
87204: LD_INT 0
87206: PUSH
87207: EMPTY
87208: LIST
87209: LIST
87210: PUSH
87211: LD_INT 30
87213: PUSH
87214: LD_INT 1
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: PUSH
87221: LD_INT 30
87223: PUSH
87224: LD_INT 6
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: LIST
87235: LIST
87236: PPUSH
87237: CALL_OW 72
87241: PPUSH
87242: LD_VAR 0 7
87246: PPUSH
87247: CALL_OW 74
87251: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
87252: LD_VAR 0 7
87256: PPUSH
87257: LD_VAR 0 8
87261: PPUSH
87262: CALL_OW 250
87266: PPUSH
87267: LD_INT 3
87269: PPUSH
87270: LD_INT 5
87272: PPUSH
87273: CALL_OW 272
87277: PPUSH
87278: LD_VAR 0 8
87282: PPUSH
87283: CALL_OW 251
87287: PPUSH
87288: LD_INT 3
87290: PPUSH
87291: LD_INT 5
87293: PPUSH
87294: CALL_OW 273
87298: PPUSH
87299: CALL_OW 111
// SetTag ( i , 0 ) ;
87303: LD_VAR 0 7
87307: PPUSH
87308: LD_INT 0
87310: PPUSH
87311: CALL_OW 109
// solds := solds diff i ;
87315: LD_ADDR_VAR 0 2
87319: PUSH
87320: LD_VAR 0 2
87324: PUSH
87325: LD_VAR 0 7
87329: DIFF
87330: ST_TO_ADDR
// continue ;
87331: GO 87013
// end ; end ;
87333: GO 87013
87335: POP
87336: POP
// until not solds or not enemy ;
87337: LD_VAR 0 2
87341: NOT
87342: PUSH
87343: LD_VAR 0 4
87347: NOT
87348: OR
87349: IFFALSE 86917
// MC_Reset ( base , 18 ) ;
87351: LD_VAR 0 1
87355: PPUSH
87356: LD_INT 18
87358: PPUSH
87359: CALL 55524 0 2
// end ;
87363: LD_VAR 0 3
87367: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
87368: LD_INT 0
87370: PPUSH
87371: PPUSH
87372: PPUSH
87373: PPUSH
87374: PPUSH
87375: PPUSH
87376: PPUSH
87377: PPUSH
87378: PPUSH
87379: PPUSH
87380: PPUSH
87381: PPUSH
87382: PPUSH
87383: PPUSH
87384: PPUSH
87385: PPUSH
87386: PPUSH
87387: PPUSH
87388: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
87389: LD_ADDR_VAR 0 12
87393: PUSH
87394: LD_EXP 43
87398: PUSH
87399: LD_VAR 0 1
87403: ARRAY
87404: PPUSH
87405: LD_INT 25
87407: PUSH
87408: LD_INT 3
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PPUSH
87415: CALL_OW 72
87419: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87420: LD_EXP 83
87424: PUSH
87425: LD_VAR 0 1
87429: ARRAY
87430: IFFALSE 87454
// mechs := mechs diff mc_remote_driver [ base ] ;
87432: LD_ADDR_VAR 0 12
87436: PUSH
87437: LD_VAR 0 12
87441: PUSH
87442: LD_EXP 83
87446: PUSH
87447: LD_VAR 0 1
87451: ARRAY
87452: DIFF
87453: ST_TO_ADDR
// for i in mechs do
87454: LD_ADDR_VAR 0 4
87458: PUSH
87459: LD_VAR 0 12
87463: PUSH
87464: FOR_IN
87465: IFFALSE 87500
// if GetTag ( i ) > 0 then
87467: LD_VAR 0 4
87471: PPUSH
87472: CALL_OW 110
87476: PUSH
87477: LD_INT 0
87479: GREATER
87480: IFFALSE 87498
// mechs := mechs diff i ;
87482: LD_ADDR_VAR 0 12
87486: PUSH
87487: LD_VAR 0 12
87491: PUSH
87492: LD_VAR 0 4
87496: DIFF
87497: ST_TO_ADDR
87498: GO 87464
87500: POP
87501: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87502: LD_ADDR_VAR 0 8
87506: PUSH
87507: LD_EXP 43
87511: PUSH
87512: LD_VAR 0 1
87516: ARRAY
87517: PPUSH
87518: LD_INT 2
87520: PUSH
87521: LD_INT 25
87523: PUSH
87524: LD_INT 1
87526: PUSH
87527: EMPTY
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 25
87533: PUSH
87534: LD_INT 5
87536: PUSH
87537: EMPTY
87538: LIST
87539: LIST
87540: PUSH
87541: LD_INT 25
87543: PUSH
87544: LD_INT 8
87546: PUSH
87547: EMPTY
87548: LIST
87549: LIST
87550: PUSH
87551: LD_INT 25
87553: PUSH
87554: LD_INT 9
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: LIST
87565: LIST
87566: LIST
87567: PPUSH
87568: CALL_OW 72
87572: ST_TO_ADDR
// if not defenders and not solds then
87573: LD_VAR 0 2
87577: NOT
87578: PUSH
87579: LD_VAR 0 8
87583: NOT
87584: AND
87585: IFFALSE 87589
// exit ;
87587: GO 89359
// depot_under_attack := false ;
87589: LD_ADDR_VAR 0 16
87593: PUSH
87594: LD_INT 0
87596: ST_TO_ADDR
// sold_defenders := [ ] ;
87597: LD_ADDR_VAR 0 17
87601: PUSH
87602: EMPTY
87603: ST_TO_ADDR
// if mechs then
87604: LD_VAR 0 12
87608: IFFALSE 87761
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87610: LD_ADDR_VAR 0 4
87614: PUSH
87615: LD_VAR 0 2
87619: PPUSH
87620: LD_INT 21
87622: PUSH
87623: LD_INT 2
87625: PUSH
87626: EMPTY
87627: LIST
87628: LIST
87629: PPUSH
87630: CALL_OW 72
87634: PUSH
87635: FOR_IN
87636: IFFALSE 87759
// begin if GetTag ( i ) <> 20 then
87638: LD_VAR 0 4
87642: PPUSH
87643: CALL_OW 110
87647: PUSH
87648: LD_INT 20
87650: NONEQUAL
87651: IFFALSE 87665
// SetTag ( i , 20 ) ;
87653: LD_VAR 0 4
87657: PPUSH
87658: LD_INT 20
87660: PPUSH
87661: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87665: LD_VAR 0 4
87669: PPUSH
87670: CALL_OW 263
87674: PUSH
87675: LD_INT 1
87677: EQUAL
87678: PUSH
87679: LD_VAR 0 4
87683: PPUSH
87684: CALL_OW 311
87688: NOT
87689: AND
87690: IFFALSE 87757
// begin un := mechs [ 1 ] ;
87692: LD_ADDR_VAR 0 10
87696: PUSH
87697: LD_VAR 0 12
87701: PUSH
87702: LD_INT 1
87704: ARRAY
87705: ST_TO_ADDR
// ComExit ( un ) ;
87706: LD_VAR 0 10
87710: PPUSH
87711: CALL 47531 0 1
// AddComEnterUnit ( un , i ) ;
87715: LD_VAR 0 10
87719: PPUSH
87720: LD_VAR 0 4
87724: PPUSH
87725: CALL_OW 180
// SetTag ( un , 19 ) ;
87729: LD_VAR 0 10
87733: PPUSH
87734: LD_INT 19
87736: PPUSH
87737: CALL_OW 109
// mechs := mechs diff un ;
87741: LD_ADDR_VAR 0 12
87745: PUSH
87746: LD_VAR 0 12
87750: PUSH
87751: LD_VAR 0 10
87755: DIFF
87756: ST_TO_ADDR
// end ; end ;
87757: GO 87635
87759: POP
87760: POP
// if solds then
87761: LD_VAR 0 8
87765: IFFALSE 87824
// for i in solds do
87767: LD_ADDR_VAR 0 4
87771: PUSH
87772: LD_VAR 0 8
87776: PUSH
87777: FOR_IN
87778: IFFALSE 87822
// if not GetTag ( i ) then
87780: LD_VAR 0 4
87784: PPUSH
87785: CALL_OW 110
87789: NOT
87790: IFFALSE 87820
// begin defenders := defenders union i ;
87792: LD_ADDR_VAR 0 2
87796: PUSH
87797: LD_VAR 0 2
87801: PUSH
87802: LD_VAR 0 4
87806: UNION
87807: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87808: LD_VAR 0 4
87812: PPUSH
87813: LD_INT 18
87815: PPUSH
87816: CALL_OW 109
// end ;
87820: GO 87777
87822: POP
87823: POP
// repeat wait ( 0 0$2 ) ;
87824: LD_INT 70
87826: PPUSH
87827: CALL_OW 67
// enemy := mc_scan [ base ] ;
87831: LD_ADDR_VAR 0 21
87835: PUSH
87836: LD_EXP 66
87840: PUSH
87841: LD_VAR 0 1
87845: ARRAY
87846: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87847: LD_EXP 43
87851: PUSH
87852: LD_VAR 0 1
87856: ARRAY
87857: NOT
87858: PUSH
87859: LD_EXP 43
87863: PUSH
87864: LD_VAR 0 1
87868: ARRAY
87869: PUSH
87870: EMPTY
87871: EQUAL
87872: OR
87873: IFFALSE 87910
// begin for i in defenders do
87875: LD_ADDR_VAR 0 4
87879: PUSH
87880: LD_VAR 0 2
87884: PUSH
87885: FOR_IN
87886: IFFALSE 87899
// ComStop ( i ) ;
87888: LD_VAR 0 4
87892: PPUSH
87893: CALL_OW 141
87897: GO 87885
87899: POP
87900: POP
// defenders := [ ] ;
87901: LD_ADDR_VAR 0 2
87905: PUSH
87906: EMPTY
87907: ST_TO_ADDR
// exit ;
87908: GO 89359
// end ; for i in defenders do
87910: LD_ADDR_VAR 0 4
87914: PUSH
87915: LD_VAR 0 2
87919: PUSH
87920: FOR_IN
87921: IFFALSE 88819
// begin e := NearestUnitToUnit ( enemy , i ) ;
87923: LD_ADDR_VAR 0 13
87927: PUSH
87928: LD_VAR 0 21
87932: PPUSH
87933: LD_VAR 0 4
87937: PPUSH
87938: CALL_OW 74
87942: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87943: LD_ADDR_VAR 0 7
87947: PUSH
87948: LD_EXP 43
87952: PUSH
87953: LD_VAR 0 1
87957: ARRAY
87958: PPUSH
87959: LD_INT 2
87961: PUSH
87962: LD_INT 30
87964: PUSH
87965: LD_INT 0
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: LD_INT 30
87974: PUSH
87975: LD_INT 1
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: PUSH
87982: EMPTY
87983: LIST
87984: LIST
87985: LIST
87986: PPUSH
87987: CALL_OW 72
87991: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87992: LD_ADDR_VAR 0 16
87996: PUSH
87997: LD_VAR 0 7
88001: NOT
88002: PUSH
88003: LD_VAR 0 7
88007: PPUSH
88008: LD_INT 3
88010: PUSH
88011: LD_INT 24
88013: PUSH
88014: LD_INT 600
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PPUSH
88025: CALL_OW 72
88029: OR
88030: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
88031: LD_VAR 0 4
88035: PPUSH
88036: CALL_OW 247
88040: PUSH
88041: LD_INT 2
88043: DOUBLE
88044: EQUAL
88045: IFTRUE 88049
88047: GO 88445
88049: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
88050: LD_VAR 0 4
88054: PPUSH
88055: CALL_OW 256
88059: PUSH
88060: LD_INT 1000
88062: EQUAL
88063: PUSH
88064: LD_VAR 0 4
88068: PPUSH
88069: LD_VAR 0 13
88073: PPUSH
88074: CALL_OW 296
88078: PUSH
88079: LD_INT 40
88081: LESS
88082: PUSH
88083: LD_VAR 0 13
88087: PPUSH
88088: LD_EXP 68
88092: PUSH
88093: LD_VAR 0 1
88097: ARRAY
88098: PPUSH
88099: CALL_OW 308
88103: OR
88104: AND
88105: IFFALSE 88227
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
88107: LD_VAR 0 4
88111: PPUSH
88112: CALL_OW 262
88116: PUSH
88117: LD_INT 1
88119: EQUAL
88120: PUSH
88121: LD_VAR 0 4
88125: PPUSH
88126: CALL_OW 261
88130: PUSH
88131: LD_INT 30
88133: LESS
88134: AND
88135: PUSH
88136: LD_VAR 0 7
88140: AND
88141: IFFALSE 88211
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
88143: LD_VAR 0 4
88147: PPUSH
88148: LD_VAR 0 7
88152: PPUSH
88153: LD_VAR 0 4
88157: PPUSH
88158: CALL_OW 74
88162: PPUSH
88163: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
88167: LD_VAR 0 4
88171: PPUSH
88172: LD_VAR 0 7
88176: PPUSH
88177: LD_VAR 0 4
88181: PPUSH
88182: CALL_OW 74
88186: PPUSH
88187: CALL_OW 296
88191: PUSH
88192: LD_INT 6
88194: LESS
88195: IFFALSE 88209
// SetFuel ( i , 100 ) ;
88197: LD_VAR 0 4
88201: PPUSH
88202: LD_INT 100
88204: PPUSH
88205: CALL_OW 240
// end else
88209: GO 88225
// ComAttackUnit ( i , e ) ;
88211: LD_VAR 0 4
88215: PPUSH
88216: LD_VAR 0 13
88220: PPUSH
88221: CALL_OW 115
// end else
88225: GO 88328
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
88227: LD_VAR 0 13
88231: PPUSH
88232: LD_EXP 68
88236: PUSH
88237: LD_VAR 0 1
88241: ARRAY
88242: PPUSH
88243: CALL_OW 308
88247: NOT
88248: PUSH
88249: LD_VAR 0 4
88253: PPUSH
88254: LD_VAR 0 13
88258: PPUSH
88259: CALL_OW 296
88263: PUSH
88264: LD_INT 40
88266: GREATEREQUAL
88267: AND
88268: PUSH
88269: LD_VAR 0 4
88273: PPUSH
88274: CALL_OW 256
88278: PUSH
88279: LD_INT 650
88281: LESSEQUAL
88282: OR
88283: PUSH
88284: LD_VAR 0 4
88288: PPUSH
88289: LD_EXP 67
88293: PUSH
88294: LD_VAR 0 1
88298: ARRAY
88299: PPUSH
88300: CALL_OW 308
88304: NOT
88305: AND
88306: IFFALSE 88328
// ComMoveToArea ( i , mc_parking [ base ] ) ;
88308: LD_VAR 0 4
88312: PPUSH
88313: LD_EXP 67
88317: PUSH
88318: LD_VAR 0 1
88322: ARRAY
88323: PPUSH
88324: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
88328: LD_VAR 0 4
88332: PPUSH
88333: CALL_OW 256
88337: PUSH
88338: LD_INT 1000
88340: LESS
88341: PUSH
88342: LD_VAR 0 4
88346: PPUSH
88347: CALL_OW 263
88351: PUSH
88352: LD_INT 1
88354: EQUAL
88355: AND
88356: PUSH
88357: LD_VAR 0 4
88361: PPUSH
88362: CALL_OW 311
88366: AND
88367: PUSH
88368: LD_VAR 0 4
88372: PPUSH
88373: LD_EXP 67
88377: PUSH
88378: LD_VAR 0 1
88382: ARRAY
88383: PPUSH
88384: CALL_OW 308
88388: AND
88389: IFFALSE 88443
// begin mech := IsDrivenBy ( i ) ;
88391: LD_ADDR_VAR 0 9
88395: PUSH
88396: LD_VAR 0 4
88400: PPUSH
88401: CALL_OW 311
88405: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88406: LD_VAR 0 9
88410: PPUSH
88411: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
88415: LD_VAR 0 9
88419: PPUSH
88420: LD_VAR 0 4
88424: PPUSH
88425: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
88429: LD_VAR 0 9
88433: PPUSH
88434: LD_VAR 0 4
88438: PPUSH
88439: CALL_OW 180
// end ; end ; unit_human :
88443: GO 88790
88445: LD_INT 1
88447: DOUBLE
88448: EQUAL
88449: IFTRUE 88453
88451: GO 88789
88453: POP
// begin b := IsInUnit ( i ) ;
88454: LD_ADDR_VAR 0 18
88458: PUSH
88459: LD_VAR 0 4
88463: PPUSH
88464: CALL_OW 310
88468: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88469: LD_ADDR_VAR 0 19
88473: PUSH
88474: LD_VAR 0 18
88478: NOT
88479: PUSH
88480: LD_VAR 0 18
88484: PPUSH
88485: CALL_OW 266
88489: PUSH
88490: LD_INT 32
88492: PUSH
88493: LD_INT 31
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: IN
88500: OR
88501: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88502: LD_VAR 0 18
88506: PPUSH
88507: CALL_OW 266
88511: PUSH
88512: LD_INT 5
88514: EQUAL
88515: PUSH
88516: LD_VAR 0 4
88520: PPUSH
88521: CALL_OW 257
88525: PUSH
88526: LD_INT 1
88528: PUSH
88529: LD_INT 2
88531: PUSH
88532: LD_INT 3
88534: PUSH
88535: LD_INT 4
88537: PUSH
88538: EMPTY
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: IN
88544: AND
88545: IFFALSE 88582
// begin class := AllowSpecClass ( i ) ;
88547: LD_ADDR_VAR 0 20
88551: PUSH
88552: LD_VAR 0 4
88556: PPUSH
88557: CALL 11598 0 1
88561: ST_TO_ADDR
// if class then
88562: LD_VAR 0 20
88566: IFFALSE 88582
// ComChangeProfession ( i , class ) ;
88568: LD_VAR 0 4
88572: PPUSH
88573: LD_VAR 0 20
88577: PPUSH
88578: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88582: LD_VAR 0 16
88586: PUSH
88587: LD_VAR 0 2
88591: PPUSH
88592: LD_INT 21
88594: PUSH
88595: LD_INT 2
88597: PUSH
88598: EMPTY
88599: LIST
88600: LIST
88601: PPUSH
88602: CALL_OW 72
88606: PUSH
88607: LD_INT 1
88609: LESSEQUAL
88610: OR
88611: PUSH
88612: LD_VAR 0 19
88616: AND
88617: PUSH
88618: LD_VAR 0 4
88622: PUSH
88623: LD_VAR 0 17
88627: IN
88628: NOT
88629: AND
88630: IFFALSE 88723
// begin if b then
88632: LD_VAR 0 18
88636: IFFALSE 88685
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88638: LD_VAR 0 18
88642: PPUSH
88643: LD_VAR 0 21
88647: PPUSH
88648: LD_VAR 0 18
88652: PPUSH
88653: CALL_OW 74
88657: PPUSH
88658: CALL_OW 296
88662: PUSH
88663: LD_INT 10
88665: LESS
88666: PUSH
88667: LD_VAR 0 18
88671: PPUSH
88672: CALL_OW 461
88676: PUSH
88677: LD_INT 7
88679: NONEQUAL
88680: AND
88681: IFFALSE 88685
// continue ;
88683: GO 87920
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88685: LD_ADDR_VAR 0 17
88689: PUSH
88690: LD_VAR 0 17
88694: PPUSH
88695: LD_VAR 0 17
88699: PUSH
88700: LD_INT 1
88702: PLUS
88703: PPUSH
88704: LD_VAR 0 4
88708: PPUSH
88709: CALL_OW 1
88713: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88714: LD_VAR 0 4
88718: PPUSH
88719: CALL_OW 122
// end ; if sold_defenders then
88723: LD_VAR 0 17
88727: IFFALSE 88787
// if i in sold_defenders then
88729: LD_VAR 0 4
88733: PUSH
88734: LD_VAR 0 17
88738: IN
88739: IFFALSE 88787
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88741: LD_VAR 0 4
88745: PPUSH
88746: CALL_OW 314
88750: NOT
88751: PUSH
88752: LD_VAR 0 4
88756: PPUSH
88757: LD_VAR 0 13
88761: PPUSH
88762: CALL_OW 296
88766: PUSH
88767: LD_INT 30
88769: LESS
88770: AND
88771: IFFALSE 88787
// ComAttackUnit ( i , e ) ;
88773: LD_VAR 0 4
88777: PPUSH
88778: LD_VAR 0 13
88782: PPUSH
88783: CALL_OW 115
// end ; end ; end ;
88787: GO 88790
88789: POP
// if IsDead ( i ) then
88790: LD_VAR 0 4
88794: PPUSH
88795: CALL_OW 301
88799: IFFALSE 88817
// defenders := defenders diff i ;
88801: LD_ADDR_VAR 0 2
88805: PUSH
88806: LD_VAR 0 2
88810: PUSH
88811: LD_VAR 0 4
88815: DIFF
88816: ST_TO_ADDR
// end ;
88817: GO 87920
88819: POP
88820: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88821: LD_VAR 0 21
88825: NOT
88826: PUSH
88827: LD_VAR 0 2
88831: NOT
88832: OR
88833: PUSH
88834: LD_EXP 43
88838: PUSH
88839: LD_VAR 0 1
88843: ARRAY
88844: NOT
88845: OR
88846: IFFALSE 87824
// MC_Reset ( base , 18 ) ;
88848: LD_VAR 0 1
88852: PPUSH
88853: LD_INT 18
88855: PPUSH
88856: CALL 55524 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88860: LD_ADDR_VAR 0 2
88864: PUSH
88865: LD_VAR 0 2
88869: PUSH
88870: LD_VAR 0 2
88874: PPUSH
88875: LD_INT 2
88877: PUSH
88878: LD_INT 25
88880: PUSH
88881: LD_INT 1
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: PUSH
88888: LD_INT 25
88890: PUSH
88891: LD_INT 5
88893: PUSH
88894: EMPTY
88895: LIST
88896: LIST
88897: PUSH
88898: LD_INT 25
88900: PUSH
88901: LD_INT 8
88903: PUSH
88904: EMPTY
88905: LIST
88906: LIST
88907: PUSH
88908: LD_INT 25
88910: PUSH
88911: LD_INT 9
88913: PUSH
88914: EMPTY
88915: LIST
88916: LIST
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: PPUSH
88925: CALL_OW 72
88929: DIFF
88930: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88931: LD_VAR 0 21
88935: NOT
88936: PUSH
88937: LD_VAR 0 2
88941: PPUSH
88942: LD_INT 21
88944: PUSH
88945: LD_INT 2
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PPUSH
88952: CALL_OW 72
88956: AND
88957: IFFALSE 89295
// begin tmp := FilterByTag ( defenders , 19 ) ;
88959: LD_ADDR_VAR 0 11
88963: PUSH
88964: LD_VAR 0 2
88968: PPUSH
88969: LD_INT 19
88971: PPUSH
88972: CALL 44715 0 2
88976: ST_TO_ADDR
// if tmp then
88977: LD_VAR 0 11
88981: IFFALSE 89051
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88983: LD_ADDR_VAR 0 11
88987: PUSH
88988: LD_VAR 0 11
88992: PPUSH
88993: LD_INT 25
88995: PUSH
88996: LD_INT 3
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: PPUSH
89003: CALL_OW 72
89007: ST_TO_ADDR
// if tmp then
89008: LD_VAR 0 11
89012: IFFALSE 89051
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
89014: LD_ADDR_EXP 55
89018: PUSH
89019: LD_EXP 55
89023: PPUSH
89024: LD_VAR 0 1
89028: PPUSH
89029: LD_EXP 55
89033: PUSH
89034: LD_VAR 0 1
89038: ARRAY
89039: PUSH
89040: LD_VAR 0 11
89044: UNION
89045: PPUSH
89046: CALL_OW 1
89050: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
89051: LD_VAR 0 1
89055: PPUSH
89056: LD_INT 19
89058: PPUSH
89059: CALL 55524 0 2
// repeat wait ( 0 0$1 ) ;
89063: LD_INT 35
89065: PPUSH
89066: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
89070: LD_EXP 43
89074: PUSH
89075: LD_VAR 0 1
89079: ARRAY
89080: NOT
89081: PUSH
89082: LD_EXP 43
89086: PUSH
89087: LD_VAR 0 1
89091: ARRAY
89092: PUSH
89093: EMPTY
89094: EQUAL
89095: OR
89096: IFFALSE 89133
// begin for i in defenders do
89098: LD_ADDR_VAR 0 4
89102: PUSH
89103: LD_VAR 0 2
89107: PUSH
89108: FOR_IN
89109: IFFALSE 89122
// ComStop ( i ) ;
89111: LD_VAR 0 4
89115: PPUSH
89116: CALL_OW 141
89120: GO 89108
89122: POP
89123: POP
// defenders := [ ] ;
89124: LD_ADDR_VAR 0 2
89128: PUSH
89129: EMPTY
89130: ST_TO_ADDR
// exit ;
89131: GO 89359
// end ; for i in defenders do
89133: LD_ADDR_VAR 0 4
89137: PUSH
89138: LD_VAR 0 2
89142: PUSH
89143: FOR_IN
89144: IFFALSE 89233
// begin if not IsInArea ( i , mc_parking [ base ] ) then
89146: LD_VAR 0 4
89150: PPUSH
89151: LD_EXP 67
89155: PUSH
89156: LD_VAR 0 1
89160: ARRAY
89161: PPUSH
89162: CALL_OW 308
89166: NOT
89167: IFFALSE 89191
// ComMoveToArea ( i , mc_parking [ base ] ) else
89169: LD_VAR 0 4
89173: PPUSH
89174: LD_EXP 67
89178: PUSH
89179: LD_VAR 0 1
89183: ARRAY
89184: PPUSH
89185: CALL_OW 113
89189: GO 89231
// if GetControl ( i ) = control_manual then
89191: LD_VAR 0 4
89195: PPUSH
89196: CALL_OW 263
89200: PUSH
89201: LD_INT 1
89203: EQUAL
89204: IFFALSE 89231
// if IsDrivenBy ( i ) then
89206: LD_VAR 0 4
89210: PPUSH
89211: CALL_OW 311
89215: IFFALSE 89231
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
89217: LD_VAR 0 4
89221: PPUSH
89222: CALL_OW 311
89226: PPUSH
89227: CALL_OW 121
// end ;
89231: GO 89143
89233: POP
89234: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
89235: LD_VAR 0 2
89239: PPUSH
89240: LD_INT 95
89242: PUSH
89243: LD_EXP 67
89247: PUSH
89248: LD_VAR 0 1
89252: ARRAY
89253: PUSH
89254: EMPTY
89255: LIST
89256: LIST
89257: PPUSH
89258: CALL_OW 72
89262: PUSH
89263: LD_VAR 0 2
89267: EQUAL
89268: PUSH
89269: LD_EXP 66
89273: PUSH
89274: LD_VAR 0 1
89278: ARRAY
89279: OR
89280: PUSH
89281: LD_EXP 43
89285: PUSH
89286: LD_VAR 0 1
89290: ARRAY
89291: NOT
89292: OR
89293: IFFALSE 89063
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
89295: LD_ADDR_EXP 65
89299: PUSH
89300: LD_EXP 65
89304: PPUSH
89305: LD_VAR 0 1
89309: PPUSH
89310: LD_VAR 0 2
89314: PPUSH
89315: LD_INT 21
89317: PUSH
89318: LD_INT 2
89320: PUSH
89321: EMPTY
89322: LIST
89323: LIST
89324: PPUSH
89325: CALL_OW 72
89329: PPUSH
89330: CALL_OW 1
89334: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
89335: LD_VAR 0 1
89339: PPUSH
89340: LD_INT 19
89342: PPUSH
89343: CALL 55524 0 2
// MC_Reset ( base , 20 ) ;
89347: LD_VAR 0 1
89351: PPUSH
89352: LD_INT 20
89354: PPUSH
89355: CALL 55524 0 2
// end ; end_of_file
89359: LD_VAR 0 3
89363: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
89364: LD_INT 0
89366: PPUSH
89367: PPUSH
89368: PPUSH
89369: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
89370: LD_VAR 0 1
89374: PPUSH
89375: CALL_OW 264
89379: PUSH
89380: LD_INT 91
89382: EQUAL
89383: IFFALSE 89455
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
89385: LD_INT 68
89387: PPUSH
89388: LD_VAR 0 1
89392: PPUSH
89393: CALL_OW 255
89397: PPUSH
89398: CALL_OW 321
89402: PUSH
89403: LD_INT 2
89405: EQUAL
89406: IFFALSE 89418
// eff := 70 else
89408: LD_ADDR_VAR 0 4
89412: PUSH
89413: LD_INT 70
89415: ST_TO_ADDR
89416: GO 89426
// eff := 30 ;
89418: LD_ADDR_VAR 0 4
89422: PUSH
89423: LD_INT 30
89425: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89426: LD_VAR 0 1
89430: PPUSH
89431: CALL_OW 250
89435: PPUSH
89436: LD_VAR 0 1
89440: PPUSH
89441: CALL_OW 251
89445: PPUSH
89446: LD_VAR 0 4
89450: PPUSH
89451: CALL_OW 495
// end ; end ;
89455: LD_VAR 0 2
89459: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89460: LD_INT 0
89462: PPUSH
// end ;
89463: LD_VAR 0 4
89467: RET
// export function SOS_Command ( cmd ) ; begin
89468: LD_INT 0
89470: PPUSH
// end ;
89471: LD_VAR 0 2
89475: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89476: LD_INT 0
89478: PPUSH
// end ;
89479: LD_VAR 0 6
89483: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
89484: LD_INT 0
89486: PPUSH
89487: PPUSH
// if not vehicle or not factory then
89488: LD_VAR 0 1
89492: NOT
89493: PUSH
89494: LD_VAR 0 2
89498: NOT
89499: OR
89500: IFFALSE 89504
// exit ;
89502: GO 89735
// if factoryWaypoints >= factory then
89504: LD_EXP 157
89508: PUSH
89509: LD_VAR 0 2
89513: GREATEREQUAL
89514: IFFALSE 89735
// if factoryWaypoints [ factory ] then
89516: LD_EXP 157
89520: PUSH
89521: LD_VAR 0 2
89525: ARRAY
89526: IFFALSE 89735
// begin if GetControl ( vehicle ) = control_manual then
89528: LD_VAR 0 1
89532: PPUSH
89533: CALL_OW 263
89537: PUSH
89538: LD_INT 1
89540: EQUAL
89541: IFFALSE 89622
// begin driver := IsDrivenBy ( vehicle ) ;
89543: LD_ADDR_VAR 0 4
89547: PUSH
89548: LD_VAR 0 1
89552: PPUSH
89553: CALL_OW 311
89557: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89558: LD_VAR 0 4
89562: PPUSH
89563: LD_EXP 157
89567: PUSH
89568: LD_VAR 0 2
89572: ARRAY
89573: PUSH
89574: LD_INT 3
89576: ARRAY
89577: PPUSH
89578: LD_EXP 157
89582: PUSH
89583: LD_VAR 0 2
89587: ARRAY
89588: PUSH
89589: LD_INT 4
89591: ARRAY
89592: PPUSH
89593: CALL_OW 171
// AddComExitVehicle ( driver ) ;
89597: LD_VAR 0 4
89601: PPUSH
89602: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
89606: LD_VAR 0 4
89610: PPUSH
89611: LD_VAR 0 2
89615: PPUSH
89616: CALL_OW 180
// end else
89620: GO 89735
// if GetControl ( vehicle ) = control_remote then
89622: LD_VAR 0 1
89626: PPUSH
89627: CALL_OW 263
89631: PUSH
89632: LD_INT 2
89634: EQUAL
89635: IFFALSE 89696
// begin wait ( 0 0$2 ) ;
89637: LD_INT 70
89639: PPUSH
89640: CALL_OW 67
// if Connect ( vehicle ) then
89644: LD_VAR 0 1
89648: PPUSH
89649: CALL 17752 0 1
89653: IFFALSE 89694
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89655: LD_VAR 0 1
89659: PPUSH
89660: LD_EXP 157
89664: PUSH
89665: LD_VAR 0 2
89669: ARRAY
89670: PUSH
89671: LD_INT 3
89673: ARRAY
89674: PPUSH
89675: LD_EXP 157
89679: PUSH
89680: LD_VAR 0 2
89684: ARRAY
89685: PUSH
89686: LD_INT 4
89688: ARRAY
89689: PPUSH
89690: CALL_OW 171
// end else
89694: GO 89735
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
89696: LD_VAR 0 1
89700: PPUSH
89701: LD_EXP 157
89705: PUSH
89706: LD_VAR 0 2
89710: ARRAY
89711: PUSH
89712: LD_INT 3
89714: ARRAY
89715: PPUSH
89716: LD_EXP 157
89720: PUSH
89721: LD_VAR 0 2
89725: ARRAY
89726: PUSH
89727: LD_INT 4
89729: ARRAY
89730: PPUSH
89731: CALL_OW 171
// end ; end ;
89735: LD_VAR 0 3
89739: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89740: LD_INT 0
89742: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89743: LD_VAR 0 1
89747: PUSH
89748: LD_INT 250
89750: EQUAL
89751: PUSH
89752: LD_VAR 0 2
89756: PPUSH
89757: CALL_OW 264
89761: PUSH
89762: LD_INT 81
89764: EQUAL
89765: AND
89766: IFFALSE 89787
// MinerPlaceMine ( unit , x , y ) ;
89768: LD_VAR 0 2
89772: PPUSH
89773: LD_VAR 0 4
89777: PPUSH
89778: LD_VAR 0 5
89782: PPUSH
89783: CALL 92172 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89787: LD_VAR 0 1
89791: PUSH
89792: LD_INT 251
89794: EQUAL
89795: PUSH
89796: LD_VAR 0 2
89800: PPUSH
89801: CALL_OW 264
89805: PUSH
89806: LD_INT 81
89808: EQUAL
89809: AND
89810: IFFALSE 89831
// MinerDetonateMine ( unit , x , y ) ;
89812: LD_VAR 0 2
89816: PPUSH
89817: LD_VAR 0 4
89821: PPUSH
89822: LD_VAR 0 5
89826: PPUSH
89827: CALL 92447 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89831: LD_VAR 0 1
89835: PUSH
89836: LD_INT 252
89838: EQUAL
89839: PUSH
89840: LD_VAR 0 2
89844: PPUSH
89845: CALL_OW 264
89849: PUSH
89850: LD_INT 81
89852: EQUAL
89853: AND
89854: IFFALSE 89875
// MinerCreateMinefield ( unit , x , y ) ;
89856: LD_VAR 0 2
89860: PPUSH
89861: LD_VAR 0 4
89865: PPUSH
89866: LD_VAR 0 5
89870: PPUSH
89871: CALL 92864 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89875: LD_VAR 0 1
89879: PUSH
89880: LD_INT 253
89882: EQUAL
89883: PUSH
89884: LD_VAR 0 2
89888: PPUSH
89889: CALL_OW 257
89893: PUSH
89894: LD_INT 5
89896: EQUAL
89897: AND
89898: IFFALSE 89919
// ComBinocular ( unit , x , y ) ;
89900: LD_VAR 0 2
89904: PPUSH
89905: LD_VAR 0 4
89909: PPUSH
89910: LD_VAR 0 5
89914: PPUSH
89915: CALL 93233 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89919: LD_VAR 0 1
89923: PUSH
89924: LD_INT 254
89926: EQUAL
89927: PUSH
89928: LD_VAR 0 2
89932: PPUSH
89933: CALL_OW 264
89937: PUSH
89938: LD_INT 99
89940: EQUAL
89941: AND
89942: PUSH
89943: LD_VAR 0 3
89947: PPUSH
89948: CALL_OW 263
89952: PUSH
89953: LD_INT 3
89955: EQUAL
89956: AND
89957: IFFALSE 89973
// HackDestroyVehicle ( unit , selectedUnit ) ;
89959: LD_VAR 0 2
89963: PPUSH
89964: LD_VAR 0 3
89968: PPUSH
89969: CALL 91536 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89973: LD_VAR 0 1
89977: PUSH
89978: LD_INT 255
89980: EQUAL
89981: PUSH
89982: LD_VAR 0 2
89986: PPUSH
89987: CALL_OW 264
89991: PUSH
89992: LD_INT 14
89994: PUSH
89995: LD_INT 53
89997: PUSH
89998: EMPTY
89999: LIST
90000: LIST
90001: IN
90002: AND
90003: PUSH
90004: LD_VAR 0 4
90008: PPUSH
90009: LD_VAR 0 5
90013: PPUSH
90014: CALL_OW 488
90018: AND
90019: IFFALSE 90043
// CutTreeXYR ( unit , x , y , 12 ) ;
90021: LD_VAR 0 2
90025: PPUSH
90026: LD_VAR 0 4
90030: PPUSH
90031: LD_VAR 0 5
90035: PPUSH
90036: LD_INT 12
90038: PPUSH
90039: CALL 90106 0 4
// if cmd = 256 then
90043: LD_VAR 0 1
90047: PUSH
90048: LD_INT 256
90050: EQUAL
90051: IFFALSE 90072
// SetFactoryWaypoint ( unit , x , y ) ;
90053: LD_VAR 0 2
90057: PPUSH
90058: LD_VAR 0 4
90062: PPUSH
90063: LD_VAR 0 5
90067: PPUSH
90068: CALL 108307 0 3
// if cmd = 257 then
90072: LD_VAR 0 1
90076: PUSH
90077: LD_INT 257
90079: EQUAL
90080: IFFALSE 90101
// SetWarehouseGatheringPoint ( unit , x , y ) ;
90082: LD_VAR 0 2
90086: PPUSH
90087: LD_VAR 0 4
90091: PPUSH
90092: LD_VAR 0 5
90096: PPUSH
90097: CALL 108669 0 3
// end ;
90101: LD_VAR 0 6
90105: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90106: LD_INT 0
90108: PPUSH
90109: PPUSH
90110: PPUSH
90111: PPUSH
90112: PPUSH
90113: PPUSH
90114: PPUSH
90115: PPUSH
90116: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90117: LD_VAR 0 1
90121: NOT
90122: PUSH
90123: LD_VAR 0 2
90127: PPUSH
90128: LD_VAR 0 3
90132: PPUSH
90133: CALL_OW 488
90137: NOT
90138: OR
90139: PUSH
90140: LD_VAR 0 4
90144: NOT
90145: OR
90146: IFFALSE 90150
// exit ;
90148: GO 90490
// list := [ ] ;
90150: LD_ADDR_VAR 0 13
90154: PUSH
90155: EMPTY
90156: ST_TO_ADDR
// if x - r < 0 then
90157: LD_VAR 0 2
90161: PUSH
90162: LD_VAR 0 4
90166: MINUS
90167: PUSH
90168: LD_INT 0
90170: LESS
90171: IFFALSE 90183
// min_x := 0 else
90173: LD_ADDR_VAR 0 7
90177: PUSH
90178: LD_INT 0
90180: ST_TO_ADDR
90181: GO 90199
// min_x := x - r ;
90183: LD_ADDR_VAR 0 7
90187: PUSH
90188: LD_VAR 0 2
90192: PUSH
90193: LD_VAR 0 4
90197: MINUS
90198: ST_TO_ADDR
// if y - r < 0 then
90199: LD_VAR 0 3
90203: PUSH
90204: LD_VAR 0 4
90208: MINUS
90209: PUSH
90210: LD_INT 0
90212: LESS
90213: IFFALSE 90225
// min_y := 0 else
90215: LD_ADDR_VAR 0 8
90219: PUSH
90220: LD_INT 0
90222: ST_TO_ADDR
90223: GO 90241
// min_y := y - r ;
90225: LD_ADDR_VAR 0 8
90229: PUSH
90230: LD_VAR 0 3
90234: PUSH
90235: LD_VAR 0 4
90239: MINUS
90240: ST_TO_ADDR
// max_x := x + r ;
90241: LD_ADDR_VAR 0 9
90245: PUSH
90246: LD_VAR 0 2
90250: PUSH
90251: LD_VAR 0 4
90255: PLUS
90256: ST_TO_ADDR
// max_y := y + r ;
90257: LD_ADDR_VAR 0 10
90261: PUSH
90262: LD_VAR 0 3
90266: PUSH
90267: LD_VAR 0 4
90271: PLUS
90272: ST_TO_ADDR
// for _x = min_x to max_x do
90273: LD_ADDR_VAR 0 11
90277: PUSH
90278: DOUBLE
90279: LD_VAR 0 7
90283: DEC
90284: ST_TO_ADDR
90285: LD_VAR 0 9
90289: PUSH
90290: FOR_TO
90291: IFFALSE 90408
// for _y = min_y to max_y do
90293: LD_ADDR_VAR 0 12
90297: PUSH
90298: DOUBLE
90299: LD_VAR 0 8
90303: DEC
90304: ST_TO_ADDR
90305: LD_VAR 0 10
90309: PUSH
90310: FOR_TO
90311: IFFALSE 90404
// begin if not ValidHex ( _x , _y ) then
90313: LD_VAR 0 11
90317: PPUSH
90318: LD_VAR 0 12
90322: PPUSH
90323: CALL_OW 488
90327: NOT
90328: IFFALSE 90332
// continue ;
90330: GO 90310
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
90332: LD_VAR 0 11
90336: PPUSH
90337: LD_VAR 0 12
90341: PPUSH
90342: CALL_OW 351
90346: PUSH
90347: LD_VAR 0 11
90351: PPUSH
90352: LD_VAR 0 12
90356: PPUSH
90357: CALL_OW 554
90361: AND
90362: IFFALSE 90402
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
90364: LD_ADDR_VAR 0 13
90368: PUSH
90369: LD_VAR 0 13
90373: PPUSH
90374: LD_VAR 0 13
90378: PUSH
90379: LD_INT 1
90381: PLUS
90382: PPUSH
90383: LD_VAR 0 11
90387: PUSH
90388: LD_VAR 0 12
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PPUSH
90397: CALL_OW 2
90401: ST_TO_ADDR
// end ;
90402: GO 90310
90404: POP
90405: POP
90406: GO 90290
90408: POP
90409: POP
// if not list then
90410: LD_VAR 0 13
90414: NOT
90415: IFFALSE 90419
// exit ;
90417: GO 90490
// for i in list do
90419: LD_ADDR_VAR 0 6
90423: PUSH
90424: LD_VAR 0 13
90428: PUSH
90429: FOR_IN
90430: IFFALSE 90488
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
90432: LD_VAR 0 1
90436: PPUSH
90437: LD_STRING M
90439: PUSH
90440: LD_VAR 0 6
90444: PUSH
90445: LD_INT 1
90447: ARRAY
90448: PUSH
90449: LD_VAR 0 6
90453: PUSH
90454: LD_INT 2
90456: ARRAY
90457: PUSH
90458: LD_INT 0
90460: PUSH
90461: LD_INT 0
90463: PUSH
90464: LD_INT 0
90466: PUSH
90467: LD_INT 0
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: PUSH
90479: EMPTY
90480: LIST
90481: PPUSH
90482: CALL_OW 447
90486: GO 90429
90488: POP
90489: POP
// end ;
90490: LD_VAR 0 5
90494: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
90495: LD_EXP 88
90499: NOT
90500: IFFALSE 90550
90502: GO 90504
90504: DISABLE
// begin initHack := true ;
90505: LD_ADDR_EXP 88
90509: PUSH
90510: LD_INT 1
90512: ST_TO_ADDR
// hackTanks := [ ] ;
90513: LD_ADDR_EXP 89
90517: PUSH
90518: EMPTY
90519: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
90520: LD_ADDR_EXP 90
90524: PUSH
90525: EMPTY
90526: ST_TO_ADDR
// hackLimit := 3 ;
90527: LD_ADDR_EXP 91
90531: PUSH
90532: LD_INT 3
90534: ST_TO_ADDR
// hackDist := 12 ;
90535: LD_ADDR_EXP 92
90539: PUSH
90540: LD_INT 12
90542: ST_TO_ADDR
// hackCounter := [ ] ;
90543: LD_ADDR_EXP 93
90547: PUSH
90548: EMPTY
90549: ST_TO_ADDR
// end ;
90550: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
90551: LD_EXP 88
90555: PUSH
90556: LD_INT 34
90558: PUSH
90559: LD_INT 99
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PPUSH
90566: CALL_OW 69
90570: AND
90571: IFFALSE 90824
90573: GO 90575
90575: DISABLE
90576: LD_INT 0
90578: PPUSH
90579: PPUSH
// begin enable ;
90580: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
90581: LD_ADDR_VAR 0 1
90585: PUSH
90586: LD_INT 34
90588: PUSH
90589: LD_INT 99
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PPUSH
90596: CALL_OW 69
90600: PUSH
90601: FOR_IN
90602: IFFALSE 90822
// begin if not i in hackTanks then
90604: LD_VAR 0 1
90608: PUSH
90609: LD_EXP 89
90613: IN
90614: NOT
90615: IFFALSE 90698
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
90617: LD_ADDR_EXP 89
90621: PUSH
90622: LD_EXP 89
90626: PPUSH
90627: LD_EXP 89
90631: PUSH
90632: LD_INT 1
90634: PLUS
90635: PPUSH
90636: LD_VAR 0 1
90640: PPUSH
90641: CALL_OW 1
90645: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
90646: LD_ADDR_EXP 90
90650: PUSH
90651: LD_EXP 90
90655: PPUSH
90656: LD_EXP 90
90660: PUSH
90661: LD_INT 1
90663: PLUS
90664: PPUSH
90665: EMPTY
90666: PPUSH
90667: CALL_OW 1
90671: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
90672: LD_ADDR_EXP 93
90676: PUSH
90677: LD_EXP 93
90681: PPUSH
90682: LD_EXP 93
90686: PUSH
90687: LD_INT 1
90689: PLUS
90690: PPUSH
90691: EMPTY
90692: PPUSH
90693: CALL_OW 1
90697: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90698: LD_VAR 0 1
90702: PPUSH
90703: CALL_OW 302
90707: NOT
90708: IFFALSE 90721
// begin HackUnlinkAll ( i ) ;
90710: LD_VAR 0 1
90714: PPUSH
90715: CALL 90827 0 1
// continue ;
90719: GO 90601
// end ; HackCheckCapturedStatus ( i ) ;
90721: LD_VAR 0 1
90725: PPUSH
90726: CALL 91270 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90730: LD_ADDR_VAR 0 2
90734: PUSH
90735: LD_INT 81
90737: PUSH
90738: LD_VAR 0 1
90742: PPUSH
90743: CALL_OW 255
90747: PUSH
90748: EMPTY
90749: LIST
90750: LIST
90751: PUSH
90752: LD_INT 33
90754: PUSH
90755: LD_INT 3
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 91
90764: PUSH
90765: LD_VAR 0 1
90769: PUSH
90770: LD_EXP 92
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: LIST
90779: PUSH
90780: LD_INT 50
90782: PUSH
90783: EMPTY
90784: LIST
90785: PUSH
90786: EMPTY
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: PPUSH
90792: CALL_OW 69
90796: ST_TO_ADDR
// if not tmp then
90797: LD_VAR 0 2
90801: NOT
90802: IFFALSE 90806
// continue ;
90804: GO 90601
// HackLink ( i , tmp ) ;
90806: LD_VAR 0 1
90810: PPUSH
90811: LD_VAR 0 2
90815: PPUSH
90816: CALL 90963 0 2
// end ;
90820: GO 90601
90822: POP
90823: POP
// end ;
90824: PPOPN 2
90826: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90827: LD_INT 0
90829: PPUSH
90830: PPUSH
90831: PPUSH
// if not hack in hackTanks then
90832: LD_VAR 0 1
90836: PUSH
90837: LD_EXP 89
90841: IN
90842: NOT
90843: IFFALSE 90847
// exit ;
90845: GO 90958
// index := GetElementIndex ( hackTanks , hack ) ;
90847: LD_ADDR_VAR 0 4
90851: PUSH
90852: LD_EXP 89
90856: PPUSH
90857: LD_VAR 0 1
90861: PPUSH
90862: CALL 14559 0 2
90866: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
90867: LD_EXP 90
90871: PUSH
90872: LD_VAR 0 4
90876: ARRAY
90877: IFFALSE 90958
// begin for i in hackTanksCaptured [ index ] do
90879: LD_ADDR_VAR 0 3
90883: PUSH
90884: LD_EXP 90
90888: PUSH
90889: LD_VAR 0 4
90893: ARRAY
90894: PUSH
90895: FOR_IN
90896: IFFALSE 90922
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
90898: LD_VAR 0 3
90902: PUSH
90903: LD_INT 1
90905: ARRAY
90906: PPUSH
90907: LD_VAR 0 3
90911: PUSH
90912: LD_INT 2
90914: ARRAY
90915: PPUSH
90916: CALL_OW 235
90920: GO 90895
90922: POP
90923: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
90924: LD_ADDR_EXP 90
90928: PUSH
90929: LD_EXP 90
90933: PPUSH
90934: LD_VAR 0 4
90938: PPUSH
90939: EMPTY
90940: PPUSH
90941: CALL_OW 1
90945: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90946: LD_VAR 0 1
90950: PPUSH
90951: LD_INT 0
90953: PPUSH
90954: CALL_OW 505
// end ; end ;
90958: LD_VAR 0 2
90962: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90963: LD_INT 0
90965: PPUSH
90966: PPUSH
90967: PPUSH
// if not hack in hackTanks or not vehicles then
90968: LD_VAR 0 1
90972: PUSH
90973: LD_EXP 89
90977: IN
90978: NOT
90979: PUSH
90980: LD_VAR 0 2
90984: NOT
90985: OR
90986: IFFALSE 90990
// exit ;
90988: GO 91265
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90990: LD_ADDR_VAR 0 2
90994: PUSH
90995: LD_VAR 0 1
90999: PPUSH
91000: LD_VAR 0 2
91004: PPUSH
91005: LD_INT 1
91007: PPUSH
91008: LD_INT 1
91010: PPUSH
91011: CALL 15209 0 4
91015: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
91016: LD_ADDR_VAR 0 5
91020: PUSH
91021: LD_EXP 89
91025: PPUSH
91026: LD_VAR 0 1
91030: PPUSH
91031: CALL 14559 0 2
91035: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
91036: LD_EXP 90
91040: PUSH
91041: LD_VAR 0 5
91045: ARRAY
91046: PUSH
91047: LD_EXP 91
91051: LESS
91052: IFFALSE 91241
// begin for i := 1 to vehicles do
91054: LD_ADDR_VAR 0 4
91058: PUSH
91059: DOUBLE
91060: LD_INT 1
91062: DEC
91063: ST_TO_ADDR
91064: LD_VAR 0 2
91068: PUSH
91069: FOR_TO
91070: IFFALSE 91239
// begin if hackTanksCaptured [ index ] = hackLimit then
91072: LD_EXP 90
91076: PUSH
91077: LD_VAR 0 5
91081: ARRAY
91082: PUSH
91083: LD_EXP 91
91087: EQUAL
91088: IFFALSE 91092
// break ;
91090: GO 91239
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
91092: LD_ADDR_EXP 93
91096: PUSH
91097: LD_EXP 93
91101: PPUSH
91102: LD_VAR 0 5
91106: PPUSH
91107: LD_EXP 93
91111: PUSH
91112: LD_VAR 0 5
91116: ARRAY
91117: PUSH
91118: LD_INT 1
91120: PLUS
91121: PPUSH
91122: CALL_OW 1
91126: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
91127: LD_ADDR_EXP 90
91131: PUSH
91132: LD_EXP 90
91136: PPUSH
91137: LD_VAR 0 5
91141: PUSH
91142: LD_EXP 90
91146: PUSH
91147: LD_VAR 0 5
91151: ARRAY
91152: PUSH
91153: LD_INT 1
91155: PLUS
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: PPUSH
91161: LD_VAR 0 2
91165: PUSH
91166: LD_VAR 0 4
91170: ARRAY
91171: PUSH
91172: LD_VAR 0 2
91176: PUSH
91177: LD_VAR 0 4
91181: ARRAY
91182: PPUSH
91183: CALL_OW 255
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: PPUSH
91192: CALL 14774 0 3
91196: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
91197: LD_VAR 0 2
91201: PUSH
91202: LD_VAR 0 4
91206: ARRAY
91207: PPUSH
91208: LD_VAR 0 1
91212: PPUSH
91213: CALL_OW 255
91217: PPUSH
91218: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
91222: LD_VAR 0 2
91226: PUSH
91227: LD_VAR 0 4
91231: ARRAY
91232: PPUSH
91233: CALL_OW 141
// end ;
91237: GO 91069
91239: POP
91240: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91241: LD_VAR 0 1
91245: PPUSH
91246: LD_EXP 90
91250: PUSH
91251: LD_VAR 0 5
91255: ARRAY
91256: PUSH
91257: LD_INT 0
91259: PLUS
91260: PPUSH
91261: CALL_OW 505
// end ;
91265: LD_VAR 0 3
91269: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
91270: LD_INT 0
91272: PPUSH
91273: PPUSH
91274: PPUSH
91275: PPUSH
// if not hack in hackTanks then
91276: LD_VAR 0 1
91280: PUSH
91281: LD_EXP 89
91285: IN
91286: NOT
91287: IFFALSE 91291
// exit ;
91289: GO 91531
// index := GetElementIndex ( hackTanks , hack ) ;
91291: LD_ADDR_VAR 0 4
91295: PUSH
91296: LD_EXP 89
91300: PPUSH
91301: LD_VAR 0 1
91305: PPUSH
91306: CALL 14559 0 2
91310: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
91311: LD_ADDR_VAR 0 3
91315: PUSH
91316: DOUBLE
91317: LD_EXP 90
91321: PUSH
91322: LD_VAR 0 4
91326: ARRAY
91327: INC
91328: ST_TO_ADDR
91329: LD_INT 1
91331: PUSH
91332: FOR_DOWNTO
91333: IFFALSE 91505
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
91335: LD_ADDR_VAR 0 5
91339: PUSH
91340: LD_EXP 90
91344: PUSH
91345: LD_VAR 0 4
91349: ARRAY
91350: PUSH
91351: LD_VAR 0 3
91355: ARRAY
91356: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
91357: LD_VAR 0 5
91361: PUSH
91362: LD_INT 1
91364: ARRAY
91365: PPUSH
91366: CALL_OW 302
91370: NOT
91371: PUSH
91372: LD_VAR 0 5
91376: PUSH
91377: LD_INT 1
91379: ARRAY
91380: PPUSH
91381: CALL_OW 255
91385: PUSH
91386: LD_VAR 0 1
91390: PPUSH
91391: CALL_OW 255
91395: NONEQUAL
91396: OR
91397: IFFALSE 91503
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
91399: LD_VAR 0 5
91403: PUSH
91404: LD_INT 1
91406: ARRAY
91407: PPUSH
91408: CALL_OW 305
91412: PUSH
91413: LD_VAR 0 5
91417: PUSH
91418: LD_INT 1
91420: ARRAY
91421: PPUSH
91422: CALL_OW 255
91426: PUSH
91427: LD_VAR 0 1
91431: PPUSH
91432: CALL_OW 255
91436: EQUAL
91437: AND
91438: IFFALSE 91462
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
91440: LD_VAR 0 5
91444: PUSH
91445: LD_INT 1
91447: ARRAY
91448: PPUSH
91449: LD_VAR 0 5
91453: PUSH
91454: LD_INT 2
91456: ARRAY
91457: PPUSH
91458: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
91462: LD_ADDR_EXP 90
91466: PUSH
91467: LD_EXP 90
91471: PPUSH
91472: LD_VAR 0 4
91476: PPUSH
91477: LD_EXP 90
91481: PUSH
91482: LD_VAR 0 4
91486: ARRAY
91487: PPUSH
91488: LD_VAR 0 3
91492: PPUSH
91493: CALL_OW 3
91497: PPUSH
91498: CALL_OW 1
91502: ST_TO_ADDR
// end ; end ;
91503: GO 91332
91505: POP
91506: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
91507: LD_VAR 0 1
91511: PPUSH
91512: LD_EXP 90
91516: PUSH
91517: LD_VAR 0 4
91521: ARRAY
91522: PUSH
91523: LD_INT 0
91525: PLUS
91526: PPUSH
91527: CALL_OW 505
// end ;
91531: LD_VAR 0 2
91535: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
91536: LD_INT 0
91538: PPUSH
91539: PPUSH
91540: PPUSH
91541: PPUSH
// if not hack in hackTanks then
91542: LD_VAR 0 1
91546: PUSH
91547: LD_EXP 89
91551: IN
91552: NOT
91553: IFFALSE 91557
// exit ;
91555: GO 91642
// index := GetElementIndex ( hackTanks , hack ) ;
91557: LD_ADDR_VAR 0 5
91561: PUSH
91562: LD_EXP 89
91566: PPUSH
91567: LD_VAR 0 1
91571: PPUSH
91572: CALL 14559 0 2
91576: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
91577: LD_ADDR_VAR 0 4
91581: PUSH
91582: DOUBLE
91583: LD_INT 1
91585: DEC
91586: ST_TO_ADDR
91587: LD_EXP 90
91591: PUSH
91592: LD_VAR 0 5
91596: ARRAY
91597: PUSH
91598: FOR_TO
91599: IFFALSE 91640
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
91601: LD_EXP 90
91605: PUSH
91606: LD_VAR 0 5
91610: ARRAY
91611: PUSH
91612: LD_VAR 0 4
91616: ARRAY
91617: PUSH
91618: LD_INT 1
91620: ARRAY
91621: PUSH
91622: LD_VAR 0 2
91626: EQUAL
91627: IFFALSE 91638
// KillUnit ( vehicle ) ;
91629: LD_VAR 0 2
91633: PPUSH
91634: CALL_OW 66
91638: GO 91598
91640: POP
91641: POP
// end ;
91642: LD_VAR 0 3
91646: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
91647: LD_EXP 94
91651: NOT
91652: IFFALSE 91687
91654: GO 91656
91656: DISABLE
// begin initMiner := true ;
91657: LD_ADDR_EXP 94
91661: PUSH
91662: LD_INT 1
91664: ST_TO_ADDR
// minersList := [ ] ;
91665: LD_ADDR_EXP 95
91669: PUSH
91670: EMPTY
91671: ST_TO_ADDR
// minerMinesList := [ ] ;
91672: LD_ADDR_EXP 96
91676: PUSH
91677: EMPTY
91678: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
91679: LD_ADDR_EXP 97
91683: PUSH
91684: LD_INT 5
91686: ST_TO_ADDR
// end ;
91687: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
91688: LD_EXP 94
91692: PUSH
91693: LD_INT 34
91695: PUSH
91696: LD_INT 81
91698: PUSH
91699: EMPTY
91700: LIST
91701: LIST
91702: PPUSH
91703: CALL_OW 69
91707: AND
91708: IFFALSE 92169
91710: GO 91712
91712: DISABLE
91713: LD_INT 0
91715: PPUSH
91716: PPUSH
91717: PPUSH
91718: PPUSH
// begin enable ;
91719: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91720: LD_ADDR_VAR 0 1
91724: PUSH
91725: LD_INT 34
91727: PUSH
91728: LD_INT 81
91730: PUSH
91731: EMPTY
91732: LIST
91733: LIST
91734: PPUSH
91735: CALL_OW 69
91739: PUSH
91740: FOR_IN
91741: IFFALSE 91813
// begin if not i in minersList then
91743: LD_VAR 0 1
91747: PUSH
91748: LD_EXP 95
91752: IN
91753: NOT
91754: IFFALSE 91811
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91756: LD_ADDR_EXP 95
91760: PUSH
91761: LD_EXP 95
91765: PPUSH
91766: LD_EXP 95
91770: PUSH
91771: LD_INT 1
91773: PLUS
91774: PPUSH
91775: LD_VAR 0 1
91779: PPUSH
91780: CALL_OW 1
91784: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91785: LD_ADDR_EXP 96
91789: PUSH
91790: LD_EXP 96
91794: PPUSH
91795: LD_EXP 96
91799: PUSH
91800: LD_INT 1
91802: PLUS
91803: PPUSH
91804: EMPTY
91805: PPUSH
91806: CALL_OW 1
91810: ST_TO_ADDR
// end end ;
91811: GO 91740
91813: POP
91814: POP
// for i := minerMinesList downto 1 do
91815: LD_ADDR_VAR 0 1
91819: PUSH
91820: DOUBLE
91821: LD_EXP 96
91825: INC
91826: ST_TO_ADDR
91827: LD_INT 1
91829: PUSH
91830: FOR_DOWNTO
91831: IFFALSE 92167
// begin if IsLive ( minersList [ i ] ) then
91833: LD_EXP 95
91837: PUSH
91838: LD_VAR 0 1
91842: ARRAY
91843: PPUSH
91844: CALL_OW 300
91848: IFFALSE 91876
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91850: LD_EXP 95
91854: PUSH
91855: LD_VAR 0 1
91859: ARRAY
91860: PPUSH
91861: LD_EXP 96
91865: PUSH
91866: LD_VAR 0 1
91870: ARRAY
91871: PPUSH
91872: CALL_OW 505
// if not minerMinesList [ i ] then
91876: LD_EXP 96
91880: PUSH
91881: LD_VAR 0 1
91885: ARRAY
91886: NOT
91887: IFFALSE 91891
// continue ;
91889: GO 91830
// for j := minerMinesList [ i ] downto 1 do
91891: LD_ADDR_VAR 0 2
91895: PUSH
91896: DOUBLE
91897: LD_EXP 96
91901: PUSH
91902: LD_VAR 0 1
91906: ARRAY
91907: INC
91908: ST_TO_ADDR
91909: LD_INT 1
91911: PUSH
91912: FOR_DOWNTO
91913: IFFALSE 92163
// begin side := GetSide ( minersList [ i ] ) ;
91915: LD_ADDR_VAR 0 3
91919: PUSH
91920: LD_EXP 95
91924: PUSH
91925: LD_VAR 0 1
91929: ARRAY
91930: PPUSH
91931: CALL_OW 255
91935: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91936: LD_ADDR_VAR 0 4
91940: PUSH
91941: LD_EXP 96
91945: PUSH
91946: LD_VAR 0 1
91950: ARRAY
91951: PUSH
91952: LD_VAR 0 2
91956: ARRAY
91957: PUSH
91958: LD_INT 1
91960: ARRAY
91961: PPUSH
91962: LD_EXP 96
91966: PUSH
91967: LD_VAR 0 1
91971: ARRAY
91972: PUSH
91973: LD_VAR 0 2
91977: ARRAY
91978: PUSH
91979: LD_INT 2
91981: ARRAY
91982: PPUSH
91983: CALL_OW 428
91987: ST_TO_ADDR
// if not tmp then
91988: LD_VAR 0 4
91992: NOT
91993: IFFALSE 91997
// continue ;
91995: GO 91912
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91997: LD_VAR 0 4
92001: PUSH
92002: LD_INT 81
92004: PUSH
92005: LD_VAR 0 3
92009: PUSH
92010: EMPTY
92011: LIST
92012: LIST
92013: PPUSH
92014: CALL_OW 69
92018: IN
92019: PUSH
92020: LD_EXP 96
92024: PUSH
92025: LD_VAR 0 1
92029: ARRAY
92030: PUSH
92031: LD_VAR 0 2
92035: ARRAY
92036: PUSH
92037: LD_INT 1
92039: ARRAY
92040: PPUSH
92041: LD_EXP 96
92045: PUSH
92046: LD_VAR 0 1
92050: ARRAY
92051: PUSH
92052: LD_VAR 0 2
92056: ARRAY
92057: PUSH
92058: LD_INT 2
92060: ARRAY
92061: PPUSH
92062: CALL_OW 458
92066: AND
92067: IFFALSE 92161
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
92069: LD_EXP 96
92073: PUSH
92074: LD_VAR 0 1
92078: ARRAY
92079: PUSH
92080: LD_VAR 0 2
92084: ARRAY
92085: PUSH
92086: LD_INT 1
92088: ARRAY
92089: PPUSH
92090: LD_EXP 96
92094: PUSH
92095: LD_VAR 0 1
92099: ARRAY
92100: PUSH
92101: LD_VAR 0 2
92105: ARRAY
92106: PUSH
92107: LD_INT 2
92109: ARRAY
92110: PPUSH
92111: LD_VAR 0 3
92115: PPUSH
92116: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
92120: LD_ADDR_EXP 96
92124: PUSH
92125: LD_EXP 96
92129: PPUSH
92130: LD_VAR 0 1
92134: PPUSH
92135: LD_EXP 96
92139: PUSH
92140: LD_VAR 0 1
92144: ARRAY
92145: PPUSH
92146: LD_VAR 0 2
92150: PPUSH
92151: CALL_OW 3
92155: PPUSH
92156: CALL_OW 1
92160: ST_TO_ADDR
// end ; end ;
92161: GO 91912
92163: POP
92164: POP
// end ;
92165: GO 91830
92167: POP
92168: POP
// end ;
92169: PPOPN 4
92171: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
92172: LD_INT 0
92174: PPUSH
92175: PPUSH
// result := false ;
92176: LD_ADDR_VAR 0 4
92180: PUSH
92181: LD_INT 0
92183: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
92184: LD_VAR 0 1
92188: PPUSH
92189: CALL_OW 264
92193: PUSH
92194: LD_INT 81
92196: EQUAL
92197: NOT
92198: IFFALSE 92202
// exit ;
92200: GO 92442
// index := GetElementIndex ( minersList , unit ) ;
92202: LD_ADDR_VAR 0 5
92206: PUSH
92207: LD_EXP 95
92211: PPUSH
92212: LD_VAR 0 1
92216: PPUSH
92217: CALL 14559 0 2
92221: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
92222: LD_EXP 96
92226: PUSH
92227: LD_VAR 0 5
92231: ARRAY
92232: PUSH
92233: LD_EXP 97
92237: GREATEREQUAL
92238: IFFALSE 92242
// exit ;
92240: GO 92442
// ComMoveXY ( unit , x , y ) ;
92242: LD_VAR 0 1
92246: PPUSH
92247: LD_VAR 0 2
92251: PPUSH
92252: LD_VAR 0 3
92256: PPUSH
92257: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
92261: LD_INT 35
92263: PPUSH
92264: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
92268: LD_VAR 0 1
92272: PPUSH
92273: LD_VAR 0 2
92277: PPUSH
92278: LD_VAR 0 3
92282: PPUSH
92283: CALL 45943 0 3
92287: NOT
92288: PUSH
92289: LD_VAR 0 1
92293: PPUSH
92294: CALL_OW 314
92298: AND
92299: IFFALSE 92303
// exit ;
92301: GO 92442
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
92303: LD_VAR 0 2
92307: PPUSH
92308: LD_VAR 0 3
92312: PPUSH
92313: CALL_OW 428
92317: PUSH
92318: LD_VAR 0 1
92322: EQUAL
92323: PUSH
92324: LD_VAR 0 1
92328: PPUSH
92329: CALL_OW 314
92333: NOT
92334: AND
92335: IFFALSE 92261
// PlaySoundXY ( x , y , PlantMine ) ;
92337: LD_VAR 0 2
92341: PPUSH
92342: LD_VAR 0 3
92346: PPUSH
92347: LD_STRING PlantMine
92349: PPUSH
92350: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
92354: LD_VAR 0 2
92358: PPUSH
92359: LD_VAR 0 3
92363: PPUSH
92364: LD_VAR 0 1
92368: PPUSH
92369: CALL_OW 255
92373: PPUSH
92374: LD_INT 0
92376: PPUSH
92377: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
92381: LD_ADDR_EXP 96
92385: PUSH
92386: LD_EXP 96
92390: PPUSH
92391: LD_VAR 0 5
92395: PUSH
92396: LD_EXP 96
92400: PUSH
92401: LD_VAR 0 5
92405: ARRAY
92406: PUSH
92407: LD_INT 1
92409: PLUS
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PPUSH
92415: LD_VAR 0 2
92419: PUSH
92420: LD_VAR 0 3
92424: PUSH
92425: EMPTY
92426: LIST
92427: LIST
92428: PPUSH
92429: CALL 14774 0 3
92433: ST_TO_ADDR
// result := true ;
92434: LD_ADDR_VAR 0 4
92438: PUSH
92439: LD_INT 1
92441: ST_TO_ADDR
// end ;
92442: LD_VAR 0 4
92446: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
92447: LD_INT 0
92449: PPUSH
92450: PPUSH
92451: PPUSH
// if not unit in minersList then
92452: LD_VAR 0 1
92456: PUSH
92457: LD_EXP 95
92461: IN
92462: NOT
92463: IFFALSE 92467
// exit ;
92465: GO 92859
// index := GetElementIndex ( minersList , unit ) ;
92467: LD_ADDR_VAR 0 6
92471: PUSH
92472: LD_EXP 95
92476: PPUSH
92477: LD_VAR 0 1
92481: PPUSH
92482: CALL 14559 0 2
92486: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
92487: LD_ADDR_VAR 0 5
92491: PUSH
92492: DOUBLE
92493: LD_EXP 96
92497: PUSH
92498: LD_VAR 0 6
92502: ARRAY
92503: INC
92504: ST_TO_ADDR
92505: LD_INT 1
92507: PUSH
92508: FOR_DOWNTO
92509: IFFALSE 92670
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
92511: LD_EXP 96
92515: PUSH
92516: LD_VAR 0 6
92520: ARRAY
92521: PUSH
92522: LD_VAR 0 5
92526: ARRAY
92527: PUSH
92528: LD_INT 1
92530: ARRAY
92531: PUSH
92532: LD_VAR 0 2
92536: EQUAL
92537: PUSH
92538: LD_EXP 96
92542: PUSH
92543: LD_VAR 0 6
92547: ARRAY
92548: PUSH
92549: LD_VAR 0 5
92553: ARRAY
92554: PUSH
92555: LD_INT 2
92557: ARRAY
92558: PUSH
92559: LD_VAR 0 3
92563: EQUAL
92564: AND
92565: IFFALSE 92668
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92567: LD_EXP 96
92571: PUSH
92572: LD_VAR 0 6
92576: ARRAY
92577: PUSH
92578: LD_VAR 0 5
92582: ARRAY
92583: PUSH
92584: LD_INT 1
92586: ARRAY
92587: PPUSH
92588: LD_EXP 96
92592: PUSH
92593: LD_VAR 0 6
92597: ARRAY
92598: PUSH
92599: LD_VAR 0 5
92603: ARRAY
92604: PUSH
92605: LD_INT 2
92607: ARRAY
92608: PPUSH
92609: LD_VAR 0 1
92613: PPUSH
92614: CALL_OW 255
92618: PPUSH
92619: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92623: LD_ADDR_EXP 96
92627: PUSH
92628: LD_EXP 96
92632: PPUSH
92633: LD_VAR 0 6
92637: PPUSH
92638: LD_EXP 96
92642: PUSH
92643: LD_VAR 0 6
92647: ARRAY
92648: PPUSH
92649: LD_VAR 0 5
92653: PPUSH
92654: CALL_OW 3
92658: PPUSH
92659: CALL_OW 1
92663: ST_TO_ADDR
// exit ;
92664: POP
92665: POP
92666: GO 92859
// end ; end ;
92668: GO 92508
92670: POP
92671: POP
// for i := minerMinesList [ index ] downto 1 do
92672: LD_ADDR_VAR 0 5
92676: PUSH
92677: DOUBLE
92678: LD_EXP 96
92682: PUSH
92683: LD_VAR 0 6
92687: ARRAY
92688: INC
92689: ST_TO_ADDR
92690: LD_INT 1
92692: PUSH
92693: FOR_DOWNTO
92694: IFFALSE 92857
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92696: LD_EXP 96
92700: PUSH
92701: LD_VAR 0 6
92705: ARRAY
92706: PUSH
92707: LD_VAR 0 5
92711: ARRAY
92712: PUSH
92713: LD_INT 1
92715: ARRAY
92716: PPUSH
92717: LD_EXP 96
92721: PUSH
92722: LD_VAR 0 6
92726: ARRAY
92727: PUSH
92728: LD_VAR 0 5
92732: ARRAY
92733: PUSH
92734: LD_INT 2
92736: ARRAY
92737: PPUSH
92738: LD_VAR 0 2
92742: PPUSH
92743: LD_VAR 0 3
92747: PPUSH
92748: CALL_OW 298
92752: PUSH
92753: LD_INT 6
92755: LESS
92756: IFFALSE 92855
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92758: LD_EXP 96
92762: PUSH
92763: LD_VAR 0 6
92767: ARRAY
92768: PUSH
92769: LD_VAR 0 5
92773: ARRAY
92774: PUSH
92775: LD_INT 1
92777: ARRAY
92778: PPUSH
92779: LD_EXP 96
92783: PUSH
92784: LD_VAR 0 6
92788: ARRAY
92789: PUSH
92790: LD_VAR 0 5
92794: ARRAY
92795: PUSH
92796: LD_INT 2
92798: ARRAY
92799: PPUSH
92800: LD_VAR 0 1
92804: PPUSH
92805: CALL_OW 255
92809: PPUSH
92810: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92814: LD_ADDR_EXP 96
92818: PUSH
92819: LD_EXP 96
92823: PPUSH
92824: LD_VAR 0 6
92828: PPUSH
92829: LD_EXP 96
92833: PUSH
92834: LD_VAR 0 6
92838: ARRAY
92839: PPUSH
92840: LD_VAR 0 5
92844: PPUSH
92845: CALL_OW 3
92849: PPUSH
92850: CALL_OW 1
92854: ST_TO_ADDR
// end ; end ;
92855: GO 92693
92857: POP
92858: POP
// end ;
92859: LD_VAR 0 4
92863: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
92864: LD_INT 0
92866: PPUSH
92867: PPUSH
92868: PPUSH
92869: PPUSH
92870: PPUSH
92871: PPUSH
92872: PPUSH
92873: PPUSH
92874: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
92875: LD_VAR 0 1
92879: PPUSH
92880: CALL_OW 264
92884: PUSH
92885: LD_INT 81
92887: EQUAL
92888: NOT
92889: PUSH
92890: LD_VAR 0 1
92894: PUSH
92895: LD_EXP 95
92899: IN
92900: NOT
92901: OR
92902: IFFALSE 92906
// exit ;
92904: GO 93228
// index := GetElementIndex ( minersList , unit ) ;
92906: LD_ADDR_VAR 0 6
92910: PUSH
92911: LD_EXP 95
92915: PPUSH
92916: LD_VAR 0 1
92920: PPUSH
92921: CALL 14559 0 2
92925: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92926: LD_ADDR_VAR 0 8
92930: PUSH
92931: LD_EXP 97
92935: PUSH
92936: LD_EXP 96
92940: PUSH
92941: LD_VAR 0 6
92945: ARRAY
92946: MINUS
92947: ST_TO_ADDR
// if not minesFreeAmount then
92948: LD_VAR 0 8
92952: NOT
92953: IFFALSE 92957
// exit ;
92955: GO 93228
// tmp := [ ] ;
92957: LD_ADDR_VAR 0 7
92961: PUSH
92962: EMPTY
92963: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92964: LD_ADDR_VAR 0 5
92968: PUSH
92969: DOUBLE
92970: LD_INT 1
92972: DEC
92973: ST_TO_ADDR
92974: LD_VAR 0 8
92978: PUSH
92979: FOR_TO
92980: IFFALSE 93175
// begin _d := rand ( 0 , 5 ) ;
92982: LD_ADDR_VAR 0 11
92986: PUSH
92987: LD_INT 0
92989: PPUSH
92990: LD_INT 5
92992: PPUSH
92993: CALL_OW 12
92997: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92998: LD_ADDR_VAR 0 12
93002: PUSH
93003: LD_INT 2
93005: PPUSH
93006: LD_INT 6
93008: PPUSH
93009: CALL_OW 12
93013: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
93014: LD_ADDR_VAR 0 9
93018: PUSH
93019: LD_VAR 0 2
93023: PPUSH
93024: LD_VAR 0 11
93028: PPUSH
93029: LD_VAR 0 12
93033: PPUSH
93034: CALL_OW 272
93038: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
93039: LD_ADDR_VAR 0 10
93043: PUSH
93044: LD_VAR 0 3
93048: PPUSH
93049: LD_VAR 0 11
93053: PPUSH
93054: LD_VAR 0 12
93058: PPUSH
93059: CALL_OW 273
93063: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
93064: LD_VAR 0 9
93068: PPUSH
93069: LD_VAR 0 10
93073: PPUSH
93074: CALL_OW 488
93078: PUSH
93079: LD_VAR 0 9
93083: PUSH
93084: LD_VAR 0 10
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: PUSH
93093: LD_VAR 0 7
93097: IN
93098: NOT
93099: AND
93100: PUSH
93101: LD_VAR 0 9
93105: PPUSH
93106: LD_VAR 0 10
93110: PPUSH
93111: CALL_OW 458
93115: NOT
93116: AND
93117: IFFALSE 93159
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
93119: LD_ADDR_VAR 0 7
93123: PUSH
93124: LD_VAR 0 7
93128: PPUSH
93129: LD_VAR 0 7
93133: PUSH
93134: LD_INT 1
93136: PLUS
93137: PPUSH
93138: LD_VAR 0 9
93142: PUSH
93143: LD_VAR 0 10
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: PPUSH
93152: CALL_OW 1
93156: ST_TO_ADDR
93157: GO 93173
// i := i - 1 ;
93159: LD_ADDR_VAR 0 5
93163: PUSH
93164: LD_VAR 0 5
93168: PUSH
93169: LD_INT 1
93171: MINUS
93172: ST_TO_ADDR
// end ;
93173: GO 92979
93175: POP
93176: POP
// for i in tmp do
93177: LD_ADDR_VAR 0 5
93181: PUSH
93182: LD_VAR 0 7
93186: PUSH
93187: FOR_IN
93188: IFFALSE 93226
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
93190: LD_VAR 0 1
93194: PPUSH
93195: LD_VAR 0 5
93199: PUSH
93200: LD_INT 1
93202: ARRAY
93203: PPUSH
93204: LD_VAR 0 5
93208: PUSH
93209: LD_INT 2
93211: ARRAY
93212: PPUSH
93213: CALL 92172 0 3
93217: NOT
93218: IFFALSE 93224
// exit ;
93220: POP
93221: POP
93222: GO 93228
93224: GO 93187
93226: POP
93227: POP
// end ;
93228: LD_VAR 0 4
93232: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
93233: LD_INT 0
93235: PPUSH
93236: PPUSH
93237: PPUSH
93238: PPUSH
93239: PPUSH
93240: PPUSH
93241: PPUSH
// if not GetClass ( unit ) = class_sniper then
93242: LD_VAR 0 1
93246: PPUSH
93247: CALL_OW 257
93251: PUSH
93252: LD_INT 5
93254: EQUAL
93255: NOT
93256: IFFALSE 93260
// exit ;
93258: GO 93648
// dist := 8 ;
93260: LD_ADDR_VAR 0 5
93264: PUSH
93265: LD_INT 8
93267: ST_TO_ADDR
// viewRange := 12 ;
93268: LD_ADDR_VAR 0 7
93272: PUSH
93273: LD_INT 12
93275: ST_TO_ADDR
// side := GetSide ( unit ) ;
93276: LD_ADDR_VAR 0 6
93280: PUSH
93281: LD_VAR 0 1
93285: PPUSH
93286: CALL_OW 255
93290: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
93291: LD_INT 61
93293: PPUSH
93294: LD_VAR 0 6
93298: PPUSH
93299: CALL_OW 321
93303: PUSH
93304: LD_INT 2
93306: EQUAL
93307: IFFALSE 93317
// viewRange := 16 ;
93309: LD_ADDR_VAR 0 7
93313: PUSH
93314: LD_INT 16
93316: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
93317: LD_VAR 0 1
93321: PPUSH
93322: LD_VAR 0 2
93326: PPUSH
93327: LD_VAR 0 3
93331: PPUSH
93332: CALL_OW 297
93336: PUSH
93337: LD_VAR 0 5
93341: GREATER
93342: IFFALSE 93421
// begin ComMoveXY ( unit , x , y ) ;
93344: LD_VAR 0 1
93348: PPUSH
93349: LD_VAR 0 2
93353: PPUSH
93354: LD_VAR 0 3
93358: PPUSH
93359: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93363: LD_INT 35
93365: PPUSH
93366: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
93370: LD_VAR 0 1
93374: PPUSH
93375: LD_VAR 0 2
93379: PPUSH
93380: LD_VAR 0 3
93384: PPUSH
93385: CALL 45943 0 3
93389: NOT
93390: IFFALSE 93394
// exit ;
93392: GO 93648
// until GetDistUnitXY ( unit , x , y ) < dist ;
93394: LD_VAR 0 1
93398: PPUSH
93399: LD_VAR 0 2
93403: PPUSH
93404: LD_VAR 0 3
93408: PPUSH
93409: CALL_OW 297
93413: PUSH
93414: LD_VAR 0 5
93418: LESS
93419: IFFALSE 93363
// end ; ComTurnXY ( unit , x , y ) ;
93421: LD_VAR 0 1
93425: PPUSH
93426: LD_VAR 0 2
93430: PPUSH
93431: LD_VAR 0 3
93435: PPUSH
93436: CALL_OW 118
// wait ( 5 ) ;
93440: LD_INT 5
93442: PPUSH
93443: CALL_OW 67
// _d := GetDir ( unit ) ;
93447: LD_ADDR_VAR 0 10
93451: PUSH
93452: LD_VAR 0 1
93456: PPUSH
93457: CALL_OW 254
93461: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
93462: LD_ADDR_VAR 0 8
93466: PUSH
93467: LD_VAR 0 1
93471: PPUSH
93472: CALL_OW 250
93476: PPUSH
93477: LD_VAR 0 10
93481: PPUSH
93482: LD_VAR 0 5
93486: PPUSH
93487: CALL_OW 272
93491: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
93492: LD_ADDR_VAR 0 9
93496: PUSH
93497: LD_VAR 0 1
93501: PPUSH
93502: CALL_OW 251
93506: PPUSH
93507: LD_VAR 0 10
93511: PPUSH
93512: LD_VAR 0 5
93516: PPUSH
93517: CALL_OW 273
93521: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
93522: LD_VAR 0 8
93526: PPUSH
93527: LD_VAR 0 9
93531: PPUSH
93532: CALL_OW 488
93536: NOT
93537: IFFALSE 93541
// exit ;
93539: GO 93648
// ComAnimCustom ( unit , 1 ) ;
93541: LD_VAR 0 1
93545: PPUSH
93546: LD_INT 1
93548: PPUSH
93549: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
93553: LD_VAR 0 8
93557: PPUSH
93558: LD_VAR 0 9
93562: PPUSH
93563: LD_VAR 0 6
93567: PPUSH
93568: LD_VAR 0 7
93572: PPUSH
93573: CALL_OW 330
// repeat wait ( 1 ) ;
93577: LD_INT 1
93579: PPUSH
93580: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
93584: LD_VAR 0 1
93588: PPUSH
93589: CALL_OW 316
93593: PUSH
93594: LD_VAR 0 1
93598: PPUSH
93599: CALL_OW 314
93603: OR
93604: PUSH
93605: LD_VAR 0 1
93609: PPUSH
93610: CALL_OW 302
93614: NOT
93615: OR
93616: PUSH
93617: LD_VAR 0 1
93621: PPUSH
93622: CALL_OW 301
93626: OR
93627: IFFALSE 93577
// RemoveSeeing ( _x , _y , side ) ;
93629: LD_VAR 0 8
93633: PPUSH
93634: LD_VAR 0 9
93638: PPUSH
93639: LD_VAR 0 6
93643: PPUSH
93644: CALL_OW 331
// end ; end_of_file
93648: LD_VAR 0 4
93652: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
93653: LD_VAR 0 1
93657: PUSH
93658: LD_INT 200
93660: DOUBLE
93661: GREATEREQUAL
93662: IFFALSE 93670
93664: LD_INT 299
93666: DOUBLE
93667: LESSEQUAL
93668: IFTRUE 93672
93670: GO 93704
93672: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
93673: LD_VAR 0 1
93677: PPUSH
93678: LD_VAR 0 2
93682: PPUSH
93683: LD_VAR 0 3
93687: PPUSH
93688: LD_VAR 0 4
93692: PPUSH
93693: LD_VAR 0 5
93697: PPUSH
93698: CALL 89740 0 5
93702: GO 93781
93704: LD_INT 300
93706: DOUBLE
93707: GREATEREQUAL
93708: IFFALSE 93716
93710: LD_INT 399
93712: DOUBLE
93713: LESSEQUAL
93714: IFTRUE 93718
93716: GO 93780
93718: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93719: LD_VAR 0 1
93723: PPUSH
93724: LD_VAR 0 2
93728: PPUSH
93729: LD_VAR 0 3
93733: PPUSH
93734: LD_VAR 0 4
93738: PPUSH
93739: LD_VAR 0 5
93743: PPUSH
93744: LD_VAR 0 6
93748: PPUSH
93749: LD_VAR 0 7
93753: PPUSH
93754: LD_VAR 0 8
93758: PPUSH
93759: LD_VAR 0 9
93763: PPUSH
93764: LD_VAR 0 10
93768: PPUSH
93769: LD_VAR 0 11
93773: PPUSH
93774: CALL 106319 0 11
93778: GO 93781
93780: POP
// end ;
93781: PPOPN 11
93783: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93784: LD_VAR 0 1
93788: PPUSH
93789: LD_VAR 0 2
93793: PPUSH
93794: LD_VAR 0 3
93798: PPUSH
93799: LD_VAR 0 4
93803: PPUSH
93804: LD_VAR 0 5
93808: PPUSH
93809: CALL 89476 0 5
// end ; end_of_file
93813: PPOPN 5
93815: END
// export globalGameSaveCounter ; every 0 0$1 do
93816: GO 93818
93818: DISABLE
// begin enable ;
93819: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
93820: LD_STRING updateTimer(
93822: PUSH
93823: LD_OWVAR 1
93827: STR
93828: PUSH
93829: LD_STRING );
93831: STR
93832: PPUSH
93833: CALL_OW 559
// end ;
93837: END
// every 0 0$1 do
93838: GO 93840
93840: DISABLE
// begin globalGameSaveCounter := 0 ;
93841: LD_ADDR_EXP 98
93845: PUSH
93846: LD_INT 0
93848: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
93849: LD_STRING setGameSaveCounter(0)
93851: PPUSH
93852: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
93856: LD_STRING initStreamRollete();
93858: PPUSH
93859: CALL_OW 559
// InitStreamMode ;
93863: CALL 95189 0 0
// DefineStreamItems ( false ) ;
93867: LD_INT 0
93869: PPUSH
93870: CALL 95653 0 1
// end ;
93874: END
// export function SOS_MapStart ( ) ; begin
93875: LD_INT 0
93877: PPUSH
// if streamModeActive then
93878: LD_EXP 99
93882: IFFALSE 93891
// DefineStreamItems ( true ) ;
93884: LD_INT 1
93886: PPUSH
93887: CALL 95653 0 1
// UpdateLuaVariables ( ) ;
93891: CALL 93908 0 0
// UpdateFactoryWaypoints ( ) ;
93895: CALL 108522 0 0
// UpdateWarehouseGatheringPoints ( ) ;
93899: CALL 108779 0 0
// end ;
93903: LD_VAR 0 1
93907: RET
// function UpdateLuaVariables ( ) ; begin
93908: LD_INT 0
93910: PPUSH
// if globalGameSaveCounter then
93911: LD_EXP 98
93915: IFFALSE 93949
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
93917: LD_ADDR_EXP 98
93921: PUSH
93922: LD_EXP 98
93926: PPUSH
93927: CALL 48494 0 1
93931: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93932: LD_STRING setGameSaveCounter(
93934: PUSH
93935: LD_EXP 98
93939: STR
93940: PUSH
93941: LD_STRING )
93943: STR
93944: PPUSH
93945: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
93949: LD_STRING setGameDifficulty(
93951: PUSH
93952: LD_OWVAR 67
93956: STR
93957: PUSH
93958: LD_STRING )
93960: STR
93961: PPUSH
93962: CALL_OW 559
// end ;
93966: LD_VAR 0 1
93970: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93971: LD_INT 0
93973: PPUSH
// if p2 = stream_mode then
93974: LD_VAR 0 2
93978: PUSH
93979: LD_INT 100
93981: EQUAL
93982: IFFALSE 94985
// begin if not StreamModeActive then
93984: LD_EXP 99
93988: NOT
93989: IFFALSE 93999
// StreamModeActive := true ;
93991: LD_ADDR_EXP 99
93995: PUSH
93996: LD_INT 1
93998: ST_TO_ADDR
// if p3 = 0 then
93999: LD_VAR 0 3
94003: PUSH
94004: LD_INT 0
94006: EQUAL
94007: IFFALSE 94013
// InitStreamMode ;
94009: CALL 95189 0 0
// if p3 = 1 then
94013: LD_VAR 0 3
94017: PUSH
94018: LD_INT 1
94020: EQUAL
94021: IFFALSE 94031
// sRocket := true ;
94023: LD_ADDR_EXP 104
94027: PUSH
94028: LD_INT 1
94030: ST_TO_ADDR
// if p3 = 2 then
94031: LD_VAR 0 3
94035: PUSH
94036: LD_INT 2
94038: EQUAL
94039: IFFALSE 94049
// sSpeed := true ;
94041: LD_ADDR_EXP 103
94045: PUSH
94046: LD_INT 1
94048: ST_TO_ADDR
// if p3 = 3 then
94049: LD_VAR 0 3
94053: PUSH
94054: LD_INT 3
94056: EQUAL
94057: IFFALSE 94067
// sEngine := true ;
94059: LD_ADDR_EXP 105
94063: PUSH
94064: LD_INT 1
94066: ST_TO_ADDR
// if p3 = 4 then
94067: LD_VAR 0 3
94071: PUSH
94072: LD_INT 4
94074: EQUAL
94075: IFFALSE 94085
// sSpec := true ;
94077: LD_ADDR_EXP 102
94081: PUSH
94082: LD_INT 1
94084: ST_TO_ADDR
// if p3 = 5 then
94085: LD_VAR 0 3
94089: PUSH
94090: LD_INT 5
94092: EQUAL
94093: IFFALSE 94103
// sLevel := true ;
94095: LD_ADDR_EXP 106
94099: PUSH
94100: LD_INT 1
94102: ST_TO_ADDR
// if p3 = 6 then
94103: LD_VAR 0 3
94107: PUSH
94108: LD_INT 6
94110: EQUAL
94111: IFFALSE 94121
// sArmoury := true ;
94113: LD_ADDR_EXP 107
94117: PUSH
94118: LD_INT 1
94120: ST_TO_ADDR
// if p3 = 7 then
94121: LD_VAR 0 3
94125: PUSH
94126: LD_INT 7
94128: EQUAL
94129: IFFALSE 94139
// sRadar := true ;
94131: LD_ADDR_EXP 108
94135: PUSH
94136: LD_INT 1
94138: ST_TO_ADDR
// if p3 = 8 then
94139: LD_VAR 0 3
94143: PUSH
94144: LD_INT 8
94146: EQUAL
94147: IFFALSE 94157
// sBunker := true ;
94149: LD_ADDR_EXP 109
94153: PUSH
94154: LD_INT 1
94156: ST_TO_ADDR
// if p3 = 9 then
94157: LD_VAR 0 3
94161: PUSH
94162: LD_INT 9
94164: EQUAL
94165: IFFALSE 94175
// sHack := true ;
94167: LD_ADDR_EXP 110
94171: PUSH
94172: LD_INT 1
94174: ST_TO_ADDR
// if p3 = 10 then
94175: LD_VAR 0 3
94179: PUSH
94180: LD_INT 10
94182: EQUAL
94183: IFFALSE 94193
// sFire := true ;
94185: LD_ADDR_EXP 111
94189: PUSH
94190: LD_INT 1
94192: ST_TO_ADDR
// if p3 = 11 then
94193: LD_VAR 0 3
94197: PUSH
94198: LD_INT 11
94200: EQUAL
94201: IFFALSE 94211
// sRefresh := true ;
94203: LD_ADDR_EXP 112
94207: PUSH
94208: LD_INT 1
94210: ST_TO_ADDR
// if p3 = 12 then
94211: LD_VAR 0 3
94215: PUSH
94216: LD_INT 12
94218: EQUAL
94219: IFFALSE 94229
// sExp := true ;
94221: LD_ADDR_EXP 113
94225: PUSH
94226: LD_INT 1
94228: ST_TO_ADDR
// if p3 = 13 then
94229: LD_VAR 0 3
94233: PUSH
94234: LD_INT 13
94236: EQUAL
94237: IFFALSE 94247
// sDepot := true ;
94239: LD_ADDR_EXP 114
94243: PUSH
94244: LD_INT 1
94246: ST_TO_ADDR
// if p3 = 14 then
94247: LD_VAR 0 3
94251: PUSH
94252: LD_INT 14
94254: EQUAL
94255: IFFALSE 94265
// sFlag := true ;
94257: LD_ADDR_EXP 115
94261: PUSH
94262: LD_INT 1
94264: ST_TO_ADDR
// if p3 = 15 then
94265: LD_VAR 0 3
94269: PUSH
94270: LD_INT 15
94272: EQUAL
94273: IFFALSE 94283
// sKamikadze := true ;
94275: LD_ADDR_EXP 123
94279: PUSH
94280: LD_INT 1
94282: ST_TO_ADDR
// if p3 = 16 then
94283: LD_VAR 0 3
94287: PUSH
94288: LD_INT 16
94290: EQUAL
94291: IFFALSE 94301
// sTroll := true ;
94293: LD_ADDR_EXP 124
94297: PUSH
94298: LD_INT 1
94300: ST_TO_ADDR
// if p3 = 17 then
94301: LD_VAR 0 3
94305: PUSH
94306: LD_INT 17
94308: EQUAL
94309: IFFALSE 94319
// sSlow := true ;
94311: LD_ADDR_EXP 125
94315: PUSH
94316: LD_INT 1
94318: ST_TO_ADDR
// if p3 = 18 then
94319: LD_VAR 0 3
94323: PUSH
94324: LD_INT 18
94326: EQUAL
94327: IFFALSE 94337
// sLack := true ;
94329: LD_ADDR_EXP 126
94333: PUSH
94334: LD_INT 1
94336: ST_TO_ADDR
// if p3 = 19 then
94337: LD_VAR 0 3
94341: PUSH
94342: LD_INT 19
94344: EQUAL
94345: IFFALSE 94355
// sTank := true ;
94347: LD_ADDR_EXP 128
94351: PUSH
94352: LD_INT 1
94354: ST_TO_ADDR
// if p3 = 20 then
94355: LD_VAR 0 3
94359: PUSH
94360: LD_INT 20
94362: EQUAL
94363: IFFALSE 94373
// sRemote := true ;
94365: LD_ADDR_EXP 129
94369: PUSH
94370: LD_INT 1
94372: ST_TO_ADDR
// if p3 = 21 then
94373: LD_VAR 0 3
94377: PUSH
94378: LD_INT 21
94380: EQUAL
94381: IFFALSE 94391
// sPowell := true ;
94383: LD_ADDR_EXP 130
94387: PUSH
94388: LD_INT 1
94390: ST_TO_ADDR
// if p3 = 22 then
94391: LD_VAR 0 3
94395: PUSH
94396: LD_INT 22
94398: EQUAL
94399: IFFALSE 94409
// sTeleport := true ;
94401: LD_ADDR_EXP 133
94405: PUSH
94406: LD_INT 1
94408: ST_TO_ADDR
// if p3 = 23 then
94409: LD_VAR 0 3
94413: PUSH
94414: LD_INT 23
94416: EQUAL
94417: IFFALSE 94427
// sOilTower := true ;
94419: LD_ADDR_EXP 135
94423: PUSH
94424: LD_INT 1
94426: ST_TO_ADDR
// if p3 = 24 then
94427: LD_VAR 0 3
94431: PUSH
94432: LD_INT 24
94434: EQUAL
94435: IFFALSE 94445
// sShovel := true ;
94437: LD_ADDR_EXP 136
94441: PUSH
94442: LD_INT 1
94444: ST_TO_ADDR
// if p3 = 25 then
94445: LD_VAR 0 3
94449: PUSH
94450: LD_INT 25
94452: EQUAL
94453: IFFALSE 94463
// sSheik := true ;
94455: LD_ADDR_EXP 137
94459: PUSH
94460: LD_INT 1
94462: ST_TO_ADDR
// if p3 = 26 then
94463: LD_VAR 0 3
94467: PUSH
94468: LD_INT 26
94470: EQUAL
94471: IFFALSE 94481
// sEarthquake := true ;
94473: LD_ADDR_EXP 139
94477: PUSH
94478: LD_INT 1
94480: ST_TO_ADDR
// if p3 = 27 then
94481: LD_VAR 0 3
94485: PUSH
94486: LD_INT 27
94488: EQUAL
94489: IFFALSE 94499
// sAI := true ;
94491: LD_ADDR_EXP 140
94495: PUSH
94496: LD_INT 1
94498: ST_TO_ADDR
// if p3 = 28 then
94499: LD_VAR 0 3
94503: PUSH
94504: LD_INT 28
94506: EQUAL
94507: IFFALSE 94517
// sCargo := true ;
94509: LD_ADDR_EXP 143
94513: PUSH
94514: LD_INT 1
94516: ST_TO_ADDR
// if p3 = 29 then
94517: LD_VAR 0 3
94521: PUSH
94522: LD_INT 29
94524: EQUAL
94525: IFFALSE 94535
// sDLaser := true ;
94527: LD_ADDR_EXP 144
94531: PUSH
94532: LD_INT 1
94534: ST_TO_ADDR
// if p3 = 30 then
94535: LD_VAR 0 3
94539: PUSH
94540: LD_INT 30
94542: EQUAL
94543: IFFALSE 94553
// sExchange := true ;
94545: LD_ADDR_EXP 145
94549: PUSH
94550: LD_INT 1
94552: ST_TO_ADDR
// if p3 = 31 then
94553: LD_VAR 0 3
94557: PUSH
94558: LD_INT 31
94560: EQUAL
94561: IFFALSE 94571
// sFac := true ;
94563: LD_ADDR_EXP 146
94567: PUSH
94568: LD_INT 1
94570: ST_TO_ADDR
// if p3 = 32 then
94571: LD_VAR 0 3
94575: PUSH
94576: LD_INT 32
94578: EQUAL
94579: IFFALSE 94589
// sPower := true ;
94581: LD_ADDR_EXP 147
94585: PUSH
94586: LD_INT 1
94588: ST_TO_ADDR
// if p3 = 33 then
94589: LD_VAR 0 3
94593: PUSH
94594: LD_INT 33
94596: EQUAL
94597: IFFALSE 94607
// sRandom := true ;
94599: LD_ADDR_EXP 148
94603: PUSH
94604: LD_INT 1
94606: ST_TO_ADDR
// if p3 = 34 then
94607: LD_VAR 0 3
94611: PUSH
94612: LD_INT 34
94614: EQUAL
94615: IFFALSE 94625
// sShield := true ;
94617: LD_ADDR_EXP 149
94621: PUSH
94622: LD_INT 1
94624: ST_TO_ADDR
// if p3 = 35 then
94625: LD_VAR 0 3
94629: PUSH
94630: LD_INT 35
94632: EQUAL
94633: IFFALSE 94643
// sTime := true ;
94635: LD_ADDR_EXP 150
94639: PUSH
94640: LD_INT 1
94642: ST_TO_ADDR
// if p3 = 36 then
94643: LD_VAR 0 3
94647: PUSH
94648: LD_INT 36
94650: EQUAL
94651: IFFALSE 94661
// sTools := true ;
94653: LD_ADDR_EXP 151
94657: PUSH
94658: LD_INT 1
94660: ST_TO_ADDR
// if p3 = 101 then
94661: LD_VAR 0 3
94665: PUSH
94666: LD_INT 101
94668: EQUAL
94669: IFFALSE 94679
// sSold := true ;
94671: LD_ADDR_EXP 116
94675: PUSH
94676: LD_INT 1
94678: ST_TO_ADDR
// if p3 = 102 then
94679: LD_VAR 0 3
94683: PUSH
94684: LD_INT 102
94686: EQUAL
94687: IFFALSE 94697
// sDiff := true ;
94689: LD_ADDR_EXP 117
94693: PUSH
94694: LD_INT 1
94696: ST_TO_ADDR
// if p3 = 103 then
94697: LD_VAR 0 3
94701: PUSH
94702: LD_INT 103
94704: EQUAL
94705: IFFALSE 94715
// sFog := true ;
94707: LD_ADDR_EXP 120
94711: PUSH
94712: LD_INT 1
94714: ST_TO_ADDR
// if p3 = 104 then
94715: LD_VAR 0 3
94719: PUSH
94720: LD_INT 104
94722: EQUAL
94723: IFFALSE 94733
// sReset := true ;
94725: LD_ADDR_EXP 121
94729: PUSH
94730: LD_INT 1
94732: ST_TO_ADDR
// if p3 = 105 then
94733: LD_VAR 0 3
94737: PUSH
94738: LD_INT 105
94740: EQUAL
94741: IFFALSE 94751
// sSun := true ;
94743: LD_ADDR_EXP 122
94747: PUSH
94748: LD_INT 1
94750: ST_TO_ADDR
// if p3 = 106 then
94751: LD_VAR 0 3
94755: PUSH
94756: LD_INT 106
94758: EQUAL
94759: IFFALSE 94769
// sTiger := true ;
94761: LD_ADDR_EXP 118
94765: PUSH
94766: LD_INT 1
94768: ST_TO_ADDR
// if p3 = 107 then
94769: LD_VAR 0 3
94773: PUSH
94774: LD_INT 107
94776: EQUAL
94777: IFFALSE 94787
// sBomb := true ;
94779: LD_ADDR_EXP 119
94783: PUSH
94784: LD_INT 1
94786: ST_TO_ADDR
// if p3 = 108 then
94787: LD_VAR 0 3
94791: PUSH
94792: LD_INT 108
94794: EQUAL
94795: IFFALSE 94805
// sWound := true ;
94797: LD_ADDR_EXP 127
94801: PUSH
94802: LD_INT 1
94804: ST_TO_ADDR
// if p3 = 109 then
94805: LD_VAR 0 3
94809: PUSH
94810: LD_INT 109
94812: EQUAL
94813: IFFALSE 94823
// sBetray := true ;
94815: LD_ADDR_EXP 131
94819: PUSH
94820: LD_INT 1
94822: ST_TO_ADDR
// if p3 = 110 then
94823: LD_VAR 0 3
94827: PUSH
94828: LD_INT 110
94830: EQUAL
94831: IFFALSE 94841
// sContamin := true ;
94833: LD_ADDR_EXP 132
94837: PUSH
94838: LD_INT 1
94840: ST_TO_ADDR
// if p3 = 111 then
94841: LD_VAR 0 3
94845: PUSH
94846: LD_INT 111
94848: EQUAL
94849: IFFALSE 94859
// sOil := true ;
94851: LD_ADDR_EXP 134
94855: PUSH
94856: LD_INT 1
94858: ST_TO_ADDR
// if p3 = 112 then
94859: LD_VAR 0 3
94863: PUSH
94864: LD_INT 112
94866: EQUAL
94867: IFFALSE 94877
// sStu := true ;
94869: LD_ADDR_EXP 138
94873: PUSH
94874: LD_INT 1
94876: ST_TO_ADDR
// if p3 = 113 then
94877: LD_VAR 0 3
94881: PUSH
94882: LD_INT 113
94884: EQUAL
94885: IFFALSE 94895
// sBazooka := true ;
94887: LD_ADDR_EXP 141
94891: PUSH
94892: LD_INT 1
94894: ST_TO_ADDR
// if p3 = 114 then
94895: LD_VAR 0 3
94899: PUSH
94900: LD_INT 114
94902: EQUAL
94903: IFFALSE 94913
// sMortar := true ;
94905: LD_ADDR_EXP 142
94909: PUSH
94910: LD_INT 1
94912: ST_TO_ADDR
// if p3 = 115 then
94913: LD_VAR 0 3
94917: PUSH
94918: LD_INT 115
94920: EQUAL
94921: IFFALSE 94931
// sRanger := true ;
94923: LD_ADDR_EXP 152
94927: PUSH
94928: LD_INT 1
94930: ST_TO_ADDR
// if p3 = 116 then
94931: LD_VAR 0 3
94935: PUSH
94936: LD_INT 116
94938: EQUAL
94939: IFFALSE 94949
// sComputer := true ;
94941: LD_ADDR_EXP 153
94945: PUSH
94946: LD_INT 1
94948: ST_TO_ADDR
// if p3 = 117 then
94949: LD_VAR 0 3
94953: PUSH
94954: LD_INT 117
94956: EQUAL
94957: IFFALSE 94967
// s30 := true ;
94959: LD_ADDR_EXP 154
94963: PUSH
94964: LD_INT 1
94966: ST_TO_ADDR
// if p3 = 118 then
94967: LD_VAR 0 3
94971: PUSH
94972: LD_INT 118
94974: EQUAL
94975: IFFALSE 94985
// s60 := true ;
94977: LD_ADDR_EXP 155
94981: PUSH
94982: LD_INT 1
94984: ST_TO_ADDR
// end ; if p2 = hack_mode then
94985: LD_VAR 0 2
94989: PUSH
94990: LD_INT 101
94992: EQUAL
94993: IFFALSE 95121
// begin case p3 of 1 :
94995: LD_VAR 0 3
94999: PUSH
95000: LD_INT 1
95002: DOUBLE
95003: EQUAL
95004: IFTRUE 95008
95006: GO 95015
95008: POP
// hHackUnlimitedResources ; 2 :
95009: CALL 107268 0 0
95013: GO 95121
95015: LD_INT 2
95017: DOUBLE
95018: EQUAL
95019: IFTRUE 95023
95021: GO 95030
95023: POP
// hHackSetLevel10 ; 3 :
95024: CALL 107401 0 0
95028: GO 95121
95030: LD_INT 3
95032: DOUBLE
95033: EQUAL
95034: IFTRUE 95038
95036: GO 95045
95038: POP
// hHackSetLevel10YourUnits ; 4 :
95039: CALL 107486 0 0
95043: GO 95121
95045: LD_INT 4
95047: DOUBLE
95048: EQUAL
95049: IFTRUE 95053
95051: GO 95060
95053: POP
// hHackInvincible ; 5 :
95054: CALL 107934 0 0
95058: GO 95121
95060: LD_INT 5
95062: DOUBLE
95063: EQUAL
95064: IFTRUE 95068
95066: GO 95075
95068: POP
// hHackInvisible ; 6 :
95069: CALL 108045 0 0
95073: GO 95121
95075: LD_INT 6
95077: DOUBLE
95078: EQUAL
95079: IFTRUE 95083
95081: GO 95090
95083: POP
// hHackChangeYourSide ; 7 :
95084: CALL 108102 0 0
95088: GO 95121
95090: LD_INT 7
95092: DOUBLE
95093: EQUAL
95094: IFTRUE 95098
95096: GO 95105
95098: POP
// hHackChangeUnitSide ; 8 :
95099: CALL 108144 0 0
95103: GO 95121
95105: LD_INT 8
95107: DOUBLE
95108: EQUAL
95109: IFTRUE 95113
95111: GO 95120
95113: POP
// hHackFog ; end ;
95114: CALL 108245 0 0
95118: GO 95121
95120: POP
// end ; if p2 = game_save_mode then
95121: LD_VAR 0 2
95125: PUSH
95126: LD_INT 102
95128: EQUAL
95129: IFFALSE 95184
// begin if p3 = 1 then
95131: LD_VAR 0 3
95135: PUSH
95136: LD_INT 1
95138: EQUAL
95139: IFFALSE 95151
// globalGameSaveCounter := p4 ;
95141: LD_ADDR_EXP 98
95145: PUSH
95146: LD_VAR 0 4
95150: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
95151: LD_VAR 0 3
95155: PUSH
95156: LD_INT 2
95158: EQUAL
95159: PUSH
95160: LD_EXP 98
95164: AND
95165: IFFALSE 95184
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95167: LD_STRING setGameSaveCounter(
95169: PUSH
95170: LD_EXP 98
95174: STR
95175: PUSH
95176: LD_STRING )
95178: STR
95179: PPUSH
95180: CALL_OW 559
// end ; end ;
95184: LD_VAR 0 7
95188: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
95189: LD_INT 0
95191: PPUSH
// streamModeActive := false ;
95192: LD_ADDR_EXP 99
95196: PUSH
95197: LD_INT 0
95199: ST_TO_ADDR
// normalCounter := 36 ;
95200: LD_ADDR_EXP 100
95204: PUSH
95205: LD_INT 36
95207: ST_TO_ADDR
// hardcoreCounter := 18 ;
95208: LD_ADDR_EXP 101
95212: PUSH
95213: LD_INT 18
95215: ST_TO_ADDR
// sRocket := false ;
95216: LD_ADDR_EXP 104
95220: PUSH
95221: LD_INT 0
95223: ST_TO_ADDR
// sSpeed := false ;
95224: LD_ADDR_EXP 103
95228: PUSH
95229: LD_INT 0
95231: ST_TO_ADDR
// sEngine := false ;
95232: LD_ADDR_EXP 105
95236: PUSH
95237: LD_INT 0
95239: ST_TO_ADDR
// sSpec := false ;
95240: LD_ADDR_EXP 102
95244: PUSH
95245: LD_INT 0
95247: ST_TO_ADDR
// sLevel := false ;
95248: LD_ADDR_EXP 106
95252: PUSH
95253: LD_INT 0
95255: ST_TO_ADDR
// sArmoury := false ;
95256: LD_ADDR_EXP 107
95260: PUSH
95261: LD_INT 0
95263: ST_TO_ADDR
// sRadar := false ;
95264: LD_ADDR_EXP 108
95268: PUSH
95269: LD_INT 0
95271: ST_TO_ADDR
// sBunker := false ;
95272: LD_ADDR_EXP 109
95276: PUSH
95277: LD_INT 0
95279: ST_TO_ADDR
// sHack := false ;
95280: LD_ADDR_EXP 110
95284: PUSH
95285: LD_INT 0
95287: ST_TO_ADDR
// sFire := false ;
95288: LD_ADDR_EXP 111
95292: PUSH
95293: LD_INT 0
95295: ST_TO_ADDR
// sRefresh := false ;
95296: LD_ADDR_EXP 112
95300: PUSH
95301: LD_INT 0
95303: ST_TO_ADDR
// sExp := false ;
95304: LD_ADDR_EXP 113
95308: PUSH
95309: LD_INT 0
95311: ST_TO_ADDR
// sDepot := false ;
95312: LD_ADDR_EXP 114
95316: PUSH
95317: LD_INT 0
95319: ST_TO_ADDR
// sFlag := false ;
95320: LD_ADDR_EXP 115
95324: PUSH
95325: LD_INT 0
95327: ST_TO_ADDR
// sKamikadze := false ;
95328: LD_ADDR_EXP 123
95332: PUSH
95333: LD_INT 0
95335: ST_TO_ADDR
// sTroll := false ;
95336: LD_ADDR_EXP 124
95340: PUSH
95341: LD_INT 0
95343: ST_TO_ADDR
// sSlow := false ;
95344: LD_ADDR_EXP 125
95348: PUSH
95349: LD_INT 0
95351: ST_TO_ADDR
// sLack := false ;
95352: LD_ADDR_EXP 126
95356: PUSH
95357: LD_INT 0
95359: ST_TO_ADDR
// sTank := false ;
95360: LD_ADDR_EXP 128
95364: PUSH
95365: LD_INT 0
95367: ST_TO_ADDR
// sRemote := false ;
95368: LD_ADDR_EXP 129
95372: PUSH
95373: LD_INT 0
95375: ST_TO_ADDR
// sPowell := false ;
95376: LD_ADDR_EXP 130
95380: PUSH
95381: LD_INT 0
95383: ST_TO_ADDR
// sTeleport := false ;
95384: LD_ADDR_EXP 133
95388: PUSH
95389: LD_INT 0
95391: ST_TO_ADDR
// sOilTower := false ;
95392: LD_ADDR_EXP 135
95396: PUSH
95397: LD_INT 0
95399: ST_TO_ADDR
// sShovel := false ;
95400: LD_ADDR_EXP 136
95404: PUSH
95405: LD_INT 0
95407: ST_TO_ADDR
// sSheik := false ;
95408: LD_ADDR_EXP 137
95412: PUSH
95413: LD_INT 0
95415: ST_TO_ADDR
// sEarthquake := false ;
95416: LD_ADDR_EXP 139
95420: PUSH
95421: LD_INT 0
95423: ST_TO_ADDR
// sAI := false ;
95424: LD_ADDR_EXP 140
95428: PUSH
95429: LD_INT 0
95431: ST_TO_ADDR
// sCargo := false ;
95432: LD_ADDR_EXP 143
95436: PUSH
95437: LD_INT 0
95439: ST_TO_ADDR
// sDLaser := false ;
95440: LD_ADDR_EXP 144
95444: PUSH
95445: LD_INT 0
95447: ST_TO_ADDR
// sExchange := false ;
95448: LD_ADDR_EXP 145
95452: PUSH
95453: LD_INT 0
95455: ST_TO_ADDR
// sFac := false ;
95456: LD_ADDR_EXP 146
95460: PUSH
95461: LD_INT 0
95463: ST_TO_ADDR
// sPower := false ;
95464: LD_ADDR_EXP 147
95468: PUSH
95469: LD_INT 0
95471: ST_TO_ADDR
// sRandom := false ;
95472: LD_ADDR_EXP 148
95476: PUSH
95477: LD_INT 0
95479: ST_TO_ADDR
// sShield := false ;
95480: LD_ADDR_EXP 149
95484: PUSH
95485: LD_INT 0
95487: ST_TO_ADDR
// sTime := false ;
95488: LD_ADDR_EXP 150
95492: PUSH
95493: LD_INT 0
95495: ST_TO_ADDR
// sTools := false ;
95496: LD_ADDR_EXP 151
95500: PUSH
95501: LD_INT 0
95503: ST_TO_ADDR
// sSold := false ;
95504: LD_ADDR_EXP 116
95508: PUSH
95509: LD_INT 0
95511: ST_TO_ADDR
// sDiff := false ;
95512: LD_ADDR_EXP 117
95516: PUSH
95517: LD_INT 0
95519: ST_TO_ADDR
// sFog := false ;
95520: LD_ADDR_EXP 120
95524: PUSH
95525: LD_INT 0
95527: ST_TO_ADDR
// sReset := false ;
95528: LD_ADDR_EXP 121
95532: PUSH
95533: LD_INT 0
95535: ST_TO_ADDR
// sSun := false ;
95536: LD_ADDR_EXP 122
95540: PUSH
95541: LD_INT 0
95543: ST_TO_ADDR
// sTiger := false ;
95544: LD_ADDR_EXP 118
95548: PUSH
95549: LD_INT 0
95551: ST_TO_ADDR
// sBomb := false ;
95552: LD_ADDR_EXP 119
95556: PUSH
95557: LD_INT 0
95559: ST_TO_ADDR
// sWound := false ;
95560: LD_ADDR_EXP 127
95564: PUSH
95565: LD_INT 0
95567: ST_TO_ADDR
// sBetray := false ;
95568: LD_ADDR_EXP 131
95572: PUSH
95573: LD_INT 0
95575: ST_TO_ADDR
// sContamin := false ;
95576: LD_ADDR_EXP 132
95580: PUSH
95581: LD_INT 0
95583: ST_TO_ADDR
// sOil := false ;
95584: LD_ADDR_EXP 134
95588: PUSH
95589: LD_INT 0
95591: ST_TO_ADDR
// sStu := false ;
95592: LD_ADDR_EXP 138
95596: PUSH
95597: LD_INT 0
95599: ST_TO_ADDR
// sBazooka := false ;
95600: LD_ADDR_EXP 141
95604: PUSH
95605: LD_INT 0
95607: ST_TO_ADDR
// sMortar := false ;
95608: LD_ADDR_EXP 142
95612: PUSH
95613: LD_INT 0
95615: ST_TO_ADDR
// sRanger := false ;
95616: LD_ADDR_EXP 152
95620: PUSH
95621: LD_INT 0
95623: ST_TO_ADDR
// sComputer := false ;
95624: LD_ADDR_EXP 153
95628: PUSH
95629: LD_INT 0
95631: ST_TO_ADDR
// s30 := false ;
95632: LD_ADDR_EXP 154
95636: PUSH
95637: LD_INT 0
95639: ST_TO_ADDR
// s60 := false ;
95640: LD_ADDR_EXP 155
95644: PUSH
95645: LD_INT 0
95647: ST_TO_ADDR
// end ;
95648: LD_VAR 0 1
95652: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
95653: LD_INT 0
95655: PPUSH
95656: PPUSH
95657: PPUSH
95658: PPUSH
95659: PPUSH
95660: PPUSH
95661: PPUSH
// result := [ ] ;
95662: LD_ADDR_VAR 0 2
95666: PUSH
95667: EMPTY
95668: ST_TO_ADDR
// if campaign_id = 1 then
95669: LD_OWVAR 69
95673: PUSH
95674: LD_INT 1
95676: EQUAL
95677: IFFALSE 98843
// begin case mission_number of 1 :
95679: LD_OWVAR 70
95683: PUSH
95684: LD_INT 1
95686: DOUBLE
95687: EQUAL
95688: IFTRUE 95692
95690: GO 95768
95692: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
95693: LD_ADDR_VAR 0 2
95697: PUSH
95698: LD_INT 2
95700: PUSH
95701: LD_INT 4
95703: PUSH
95704: LD_INT 11
95706: PUSH
95707: LD_INT 12
95709: PUSH
95710: LD_INT 15
95712: PUSH
95713: LD_INT 16
95715: PUSH
95716: LD_INT 22
95718: PUSH
95719: LD_INT 23
95721: PUSH
95722: LD_INT 26
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: PUSH
95736: LD_INT 101
95738: PUSH
95739: LD_INT 102
95741: PUSH
95742: LD_INT 106
95744: PUSH
95745: LD_INT 116
95747: PUSH
95748: LD_INT 117
95750: PUSH
95751: LD_INT 118
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: PUSH
95762: EMPTY
95763: LIST
95764: LIST
95765: ST_TO_ADDR
95766: GO 98841
95768: LD_INT 2
95770: DOUBLE
95771: EQUAL
95772: IFTRUE 95776
95774: GO 95860
95776: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
95777: LD_ADDR_VAR 0 2
95781: PUSH
95782: LD_INT 2
95784: PUSH
95785: LD_INT 4
95787: PUSH
95788: LD_INT 11
95790: PUSH
95791: LD_INT 12
95793: PUSH
95794: LD_INT 15
95796: PUSH
95797: LD_INT 16
95799: PUSH
95800: LD_INT 22
95802: PUSH
95803: LD_INT 23
95805: PUSH
95806: LD_INT 26
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: PUSH
95820: LD_INT 101
95822: PUSH
95823: LD_INT 102
95825: PUSH
95826: LD_INT 105
95828: PUSH
95829: LD_INT 106
95831: PUSH
95832: LD_INT 108
95834: PUSH
95835: LD_INT 116
95837: PUSH
95838: LD_INT 117
95840: PUSH
95841: LD_INT 118
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: PUSH
95854: EMPTY
95855: LIST
95856: LIST
95857: ST_TO_ADDR
95858: GO 98841
95860: LD_INT 3
95862: DOUBLE
95863: EQUAL
95864: IFTRUE 95868
95866: GO 95956
95868: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
95869: LD_ADDR_VAR 0 2
95873: PUSH
95874: LD_INT 2
95876: PUSH
95877: LD_INT 4
95879: PUSH
95880: LD_INT 5
95882: PUSH
95883: LD_INT 11
95885: PUSH
95886: LD_INT 12
95888: PUSH
95889: LD_INT 15
95891: PUSH
95892: LD_INT 16
95894: PUSH
95895: LD_INT 22
95897: PUSH
95898: LD_INT 26
95900: PUSH
95901: LD_INT 36
95903: PUSH
95904: EMPTY
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: PUSH
95916: LD_INT 101
95918: PUSH
95919: LD_INT 102
95921: PUSH
95922: LD_INT 105
95924: PUSH
95925: LD_INT 106
95927: PUSH
95928: LD_INT 108
95930: PUSH
95931: LD_INT 116
95933: PUSH
95934: LD_INT 117
95936: PUSH
95937: LD_INT 118
95939: PUSH
95940: EMPTY
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: PUSH
95950: EMPTY
95951: LIST
95952: LIST
95953: ST_TO_ADDR
95954: GO 98841
95956: LD_INT 4
95958: DOUBLE
95959: EQUAL
95960: IFTRUE 95964
95962: GO 96060
95964: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95965: LD_ADDR_VAR 0 2
95969: PUSH
95970: LD_INT 2
95972: PUSH
95973: LD_INT 4
95975: PUSH
95976: LD_INT 5
95978: PUSH
95979: LD_INT 8
95981: PUSH
95982: LD_INT 11
95984: PUSH
95985: LD_INT 12
95987: PUSH
95988: LD_INT 15
95990: PUSH
95991: LD_INT 16
95993: PUSH
95994: LD_INT 22
95996: PUSH
95997: LD_INT 23
95999: PUSH
96000: LD_INT 26
96002: PUSH
96003: LD_INT 36
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: LIST
96010: LIST
96011: LIST
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: PUSH
96020: LD_INT 101
96022: PUSH
96023: LD_INT 102
96025: PUSH
96026: LD_INT 105
96028: PUSH
96029: LD_INT 106
96031: PUSH
96032: LD_INT 108
96034: PUSH
96035: LD_INT 116
96037: PUSH
96038: LD_INT 117
96040: PUSH
96041: LD_INT 118
96043: PUSH
96044: EMPTY
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: ST_TO_ADDR
96058: GO 98841
96060: LD_INT 5
96062: DOUBLE
96063: EQUAL
96064: IFTRUE 96068
96066: GO 96180
96068: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96069: LD_ADDR_VAR 0 2
96073: PUSH
96074: LD_INT 2
96076: PUSH
96077: LD_INT 4
96079: PUSH
96080: LD_INT 5
96082: PUSH
96083: LD_INT 6
96085: PUSH
96086: LD_INT 8
96088: PUSH
96089: LD_INT 11
96091: PUSH
96092: LD_INT 12
96094: PUSH
96095: LD_INT 15
96097: PUSH
96098: LD_INT 16
96100: PUSH
96101: LD_INT 22
96103: PUSH
96104: LD_INT 23
96106: PUSH
96107: LD_INT 25
96109: PUSH
96110: LD_INT 26
96112: PUSH
96113: LD_INT 36
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: PUSH
96132: LD_INT 101
96134: PUSH
96135: LD_INT 102
96137: PUSH
96138: LD_INT 105
96140: PUSH
96141: LD_INT 106
96143: PUSH
96144: LD_INT 108
96146: PUSH
96147: LD_INT 109
96149: PUSH
96150: LD_INT 112
96152: PUSH
96153: LD_INT 116
96155: PUSH
96156: LD_INT 117
96158: PUSH
96159: LD_INT 118
96161: PUSH
96162: EMPTY
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: PUSH
96174: EMPTY
96175: LIST
96176: LIST
96177: ST_TO_ADDR
96178: GO 98841
96180: LD_INT 6
96182: DOUBLE
96183: EQUAL
96184: IFTRUE 96188
96186: GO 96320
96188: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96189: LD_ADDR_VAR 0 2
96193: PUSH
96194: LD_INT 2
96196: PUSH
96197: LD_INT 4
96199: PUSH
96200: LD_INT 5
96202: PUSH
96203: LD_INT 6
96205: PUSH
96206: LD_INT 8
96208: PUSH
96209: LD_INT 11
96211: PUSH
96212: LD_INT 12
96214: PUSH
96215: LD_INT 15
96217: PUSH
96218: LD_INT 16
96220: PUSH
96221: LD_INT 20
96223: PUSH
96224: LD_INT 21
96226: PUSH
96227: LD_INT 22
96229: PUSH
96230: LD_INT 23
96232: PUSH
96233: LD_INT 25
96235: PUSH
96236: LD_INT 26
96238: PUSH
96239: LD_INT 30
96241: PUSH
96242: LD_INT 31
96244: PUSH
96245: LD_INT 32
96247: PUSH
96248: LD_INT 36
96250: PUSH
96251: EMPTY
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 101
96274: PUSH
96275: LD_INT 102
96277: PUSH
96278: LD_INT 105
96280: PUSH
96281: LD_INT 106
96283: PUSH
96284: LD_INT 108
96286: PUSH
96287: LD_INT 109
96289: PUSH
96290: LD_INT 112
96292: PUSH
96293: LD_INT 116
96295: PUSH
96296: LD_INT 117
96298: PUSH
96299: LD_INT 118
96301: PUSH
96302: EMPTY
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: ST_TO_ADDR
96318: GO 98841
96320: LD_INT 7
96322: DOUBLE
96323: EQUAL
96324: IFTRUE 96328
96326: GO 96440
96328: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
96329: LD_ADDR_VAR 0 2
96333: PUSH
96334: LD_INT 2
96336: PUSH
96337: LD_INT 4
96339: PUSH
96340: LD_INT 5
96342: PUSH
96343: LD_INT 7
96345: PUSH
96346: LD_INT 11
96348: PUSH
96349: LD_INT 12
96351: PUSH
96352: LD_INT 15
96354: PUSH
96355: LD_INT 16
96357: PUSH
96358: LD_INT 20
96360: PUSH
96361: LD_INT 21
96363: PUSH
96364: LD_INT 22
96366: PUSH
96367: LD_INT 23
96369: PUSH
96370: LD_INT 25
96372: PUSH
96373: LD_INT 26
96375: PUSH
96376: EMPTY
96377: LIST
96378: LIST
96379: LIST
96380: LIST
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: LIST
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: PUSH
96392: LD_INT 101
96394: PUSH
96395: LD_INT 102
96397: PUSH
96398: LD_INT 103
96400: PUSH
96401: LD_INT 105
96403: PUSH
96404: LD_INT 106
96406: PUSH
96407: LD_INT 108
96409: PUSH
96410: LD_INT 112
96412: PUSH
96413: LD_INT 116
96415: PUSH
96416: LD_INT 117
96418: PUSH
96419: LD_INT 118
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: PUSH
96434: EMPTY
96435: LIST
96436: LIST
96437: ST_TO_ADDR
96438: GO 98841
96440: LD_INT 8
96442: DOUBLE
96443: EQUAL
96444: IFTRUE 96448
96446: GO 96588
96448: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
96449: LD_ADDR_VAR 0 2
96453: PUSH
96454: LD_INT 2
96456: PUSH
96457: LD_INT 4
96459: PUSH
96460: LD_INT 5
96462: PUSH
96463: LD_INT 6
96465: PUSH
96466: LD_INT 7
96468: PUSH
96469: LD_INT 8
96471: PUSH
96472: LD_INT 11
96474: PUSH
96475: LD_INT 12
96477: PUSH
96478: LD_INT 15
96480: PUSH
96481: LD_INT 16
96483: PUSH
96484: LD_INT 20
96486: PUSH
96487: LD_INT 21
96489: PUSH
96490: LD_INT 22
96492: PUSH
96493: LD_INT 23
96495: PUSH
96496: LD_INT 25
96498: PUSH
96499: LD_INT 26
96501: PUSH
96502: LD_INT 30
96504: PUSH
96505: LD_INT 31
96507: PUSH
96508: LD_INT 32
96510: PUSH
96511: LD_INT 36
96513: PUSH
96514: EMPTY
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: PUSH
96536: LD_INT 101
96538: PUSH
96539: LD_INT 102
96541: PUSH
96542: LD_INT 103
96544: PUSH
96545: LD_INT 105
96547: PUSH
96548: LD_INT 106
96550: PUSH
96551: LD_INT 108
96553: PUSH
96554: LD_INT 109
96556: PUSH
96557: LD_INT 112
96559: PUSH
96560: LD_INT 116
96562: PUSH
96563: LD_INT 117
96565: PUSH
96566: LD_INT 118
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: ST_TO_ADDR
96586: GO 98841
96588: LD_INT 9
96590: DOUBLE
96591: EQUAL
96592: IFTRUE 96596
96594: GO 96744
96596: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
96597: LD_ADDR_VAR 0 2
96601: PUSH
96602: LD_INT 2
96604: PUSH
96605: LD_INT 4
96607: PUSH
96608: LD_INT 5
96610: PUSH
96611: LD_INT 6
96613: PUSH
96614: LD_INT 7
96616: PUSH
96617: LD_INT 8
96619: PUSH
96620: LD_INT 11
96622: PUSH
96623: LD_INT 12
96625: PUSH
96626: LD_INT 15
96628: PUSH
96629: LD_INT 16
96631: PUSH
96632: LD_INT 20
96634: PUSH
96635: LD_INT 21
96637: PUSH
96638: LD_INT 22
96640: PUSH
96641: LD_INT 23
96643: PUSH
96644: LD_INT 25
96646: PUSH
96647: LD_INT 26
96649: PUSH
96650: LD_INT 28
96652: PUSH
96653: LD_INT 30
96655: PUSH
96656: LD_INT 31
96658: PUSH
96659: LD_INT 32
96661: PUSH
96662: LD_INT 36
96664: PUSH
96665: EMPTY
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: PUSH
96688: LD_INT 101
96690: PUSH
96691: LD_INT 102
96693: PUSH
96694: LD_INT 103
96696: PUSH
96697: LD_INT 105
96699: PUSH
96700: LD_INT 106
96702: PUSH
96703: LD_INT 108
96705: PUSH
96706: LD_INT 109
96708: PUSH
96709: LD_INT 112
96711: PUSH
96712: LD_INT 114
96714: PUSH
96715: LD_INT 116
96717: PUSH
96718: LD_INT 117
96720: PUSH
96721: LD_INT 118
96723: PUSH
96724: EMPTY
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: PUSH
96738: EMPTY
96739: LIST
96740: LIST
96741: ST_TO_ADDR
96742: GO 98841
96744: LD_INT 10
96746: DOUBLE
96747: EQUAL
96748: IFTRUE 96752
96750: GO 96948
96752: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
96753: LD_ADDR_VAR 0 2
96757: PUSH
96758: LD_INT 2
96760: PUSH
96761: LD_INT 4
96763: PUSH
96764: LD_INT 5
96766: PUSH
96767: LD_INT 6
96769: PUSH
96770: LD_INT 7
96772: PUSH
96773: LD_INT 8
96775: PUSH
96776: LD_INT 9
96778: PUSH
96779: LD_INT 10
96781: PUSH
96782: LD_INT 11
96784: PUSH
96785: LD_INT 12
96787: PUSH
96788: LD_INT 13
96790: PUSH
96791: LD_INT 14
96793: PUSH
96794: LD_INT 15
96796: PUSH
96797: LD_INT 16
96799: PUSH
96800: LD_INT 17
96802: PUSH
96803: LD_INT 18
96805: PUSH
96806: LD_INT 19
96808: PUSH
96809: LD_INT 20
96811: PUSH
96812: LD_INT 21
96814: PUSH
96815: LD_INT 22
96817: PUSH
96818: LD_INT 23
96820: PUSH
96821: LD_INT 24
96823: PUSH
96824: LD_INT 25
96826: PUSH
96827: LD_INT 26
96829: PUSH
96830: LD_INT 28
96832: PUSH
96833: LD_INT 30
96835: PUSH
96836: LD_INT 31
96838: PUSH
96839: LD_INT 32
96841: PUSH
96842: LD_INT 36
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: LIST
96869: LIST
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: PUSH
96876: LD_INT 101
96878: PUSH
96879: LD_INT 102
96881: PUSH
96882: LD_INT 103
96884: PUSH
96885: LD_INT 104
96887: PUSH
96888: LD_INT 105
96890: PUSH
96891: LD_INT 106
96893: PUSH
96894: LD_INT 107
96896: PUSH
96897: LD_INT 108
96899: PUSH
96900: LD_INT 109
96902: PUSH
96903: LD_INT 110
96905: PUSH
96906: LD_INT 111
96908: PUSH
96909: LD_INT 112
96911: PUSH
96912: LD_INT 114
96914: PUSH
96915: LD_INT 116
96917: PUSH
96918: LD_INT 117
96920: PUSH
96921: LD_INT 118
96923: PUSH
96924: EMPTY
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: PUSH
96942: EMPTY
96943: LIST
96944: LIST
96945: ST_TO_ADDR
96946: GO 98841
96948: LD_INT 11
96950: DOUBLE
96951: EQUAL
96952: IFTRUE 96956
96954: GO 97160
96956: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96957: LD_ADDR_VAR 0 2
96961: PUSH
96962: LD_INT 2
96964: PUSH
96965: LD_INT 3
96967: PUSH
96968: LD_INT 4
96970: PUSH
96971: LD_INT 5
96973: PUSH
96974: LD_INT 6
96976: PUSH
96977: LD_INT 7
96979: PUSH
96980: LD_INT 8
96982: PUSH
96983: LD_INT 9
96985: PUSH
96986: LD_INT 10
96988: PUSH
96989: LD_INT 11
96991: PUSH
96992: LD_INT 12
96994: PUSH
96995: LD_INT 13
96997: PUSH
96998: LD_INT 14
97000: PUSH
97001: LD_INT 15
97003: PUSH
97004: LD_INT 16
97006: PUSH
97007: LD_INT 17
97009: PUSH
97010: LD_INT 18
97012: PUSH
97013: LD_INT 19
97015: PUSH
97016: LD_INT 20
97018: PUSH
97019: LD_INT 21
97021: PUSH
97022: LD_INT 22
97024: PUSH
97025: LD_INT 23
97027: PUSH
97028: LD_INT 24
97030: PUSH
97031: LD_INT 25
97033: PUSH
97034: LD_INT 26
97036: PUSH
97037: LD_INT 28
97039: PUSH
97040: LD_INT 30
97042: PUSH
97043: LD_INT 31
97045: PUSH
97046: LD_INT 32
97048: PUSH
97049: LD_INT 34
97051: PUSH
97052: LD_INT 36
97054: PUSH
97055: EMPTY
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: LIST
97073: LIST
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: PUSH
97088: LD_INT 101
97090: PUSH
97091: LD_INT 102
97093: PUSH
97094: LD_INT 103
97096: PUSH
97097: LD_INT 104
97099: PUSH
97100: LD_INT 105
97102: PUSH
97103: LD_INT 106
97105: PUSH
97106: LD_INT 107
97108: PUSH
97109: LD_INT 108
97111: PUSH
97112: LD_INT 109
97114: PUSH
97115: LD_INT 110
97117: PUSH
97118: LD_INT 111
97120: PUSH
97121: LD_INT 112
97123: PUSH
97124: LD_INT 114
97126: PUSH
97127: LD_INT 116
97129: PUSH
97130: LD_INT 117
97132: PUSH
97133: LD_INT 118
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: LIST
97153: PUSH
97154: EMPTY
97155: LIST
97156: LIST
97157: ST_TO_ADDR
97158: GO 98841
97160: LD_INT 12
97162: DOUBLE
97163: EQUAL
97164: IFTRUE 97168
97166: GO 97388
97168: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97169: LD_ADDR_VAR 0 2
97173: PUSH
97174: LD_INT 1
97176: PUSH
97177: LD_INT 2
97179: PUSH
97180: LD_INT 3
97182: PUSH
97183: LD_INT 4
97185: PUSH
97186: LD_INT 5
97188: PUSH
97189: LD_INT 6
97191: PUSH
97192: LD_INT 7
97194: PUSH
97195: LD_INT 8
97197: PUSH
97198: LD_INT 9
97200: PUSH
97201: LD_INT 10
97203: PUSH
97204: LD_INT 11
97206: PUSH
97207: LD_INT 12
97209: PUSH
97210: LD_INT 13
97212: PUSH
97213: LD_INT 14
97215: PUSH
97216: LD_INT 15
97218: PUSH
97219: LD_INT 16
97221: PUSH
97222: LD_INT 17
97224: PUSH
97225: LD_INT 18
97227: PUSH
97228: LD_INT 19
97230: PUSH
97231: LD_INT 20
97233: PUSH
97234: LD_INT 21
97236: PUSH
97237: LD_INT 22
97239: PUSH
97240: LD_INT 23
97242: PUSH
97243: LD_INT 24
97245: PUSH
97246: LD_INT 25
97248: PUSH
97249: LD_INT 26
97251: PUSH
97252: LD_INT 27
97254: PUSH
97255: LD_INT 28
97257: PUSH
97258: LD_INT 30
97260: PUSH
97261: LD_INT 31
97263: PUSH
97264: LD_INT 32
97266: PUSH
97267: LD_INT 33
97269: PUSH
97270: LD_INT 34
97272: PUSH
97273: LD_INT 36
97275: PUSH
97276: EMPTY
97277: LIST
97278: LIST
97279: LIST
97280: LIST
97281: LIST
97282: LIST
97283: LIST
97284: LIST
97285: LIST
97286: LIST
97287: LIST
97288: LIST
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: LIST
97294: LIST
97295: LIST
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: PUSH
97312: LD_INT 101
97314: PUSH
97315: LD_INT 102
97317: PUSH
97318: LD_INT 103
97320: PUSH
97321: LD_INT 104
97323: PUSH
97324: LD_INT 105
97326: PUSH
97327: LD_INT 106
97329: PUSH
97330: LD_INT 107
97332: PUSH
97333: LD_INT 108
97335: PUSH
97336: LD_INT 109
97338: PUSH
97339: LD_INT 110
97341: PUSH
97342: LD_INT 111
97344: PUSH
97345: LD_INT 112
97347: PUSH
97348: LD_INT 113
97350: PUSH
97351: LD_INT 114
97353: PUSH
97354: LD_INT 116
97356: PUSH
97357: LD_INT 117
97359: PUSH
97360: LD_INT 118
97362: PUSH
97363: EMPTY
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: PUSH
97382: EMPTY
97383: LIST
97384: LIST
97385: ST_TO_ADDR
97386: GO 98841
97388: LD_INT 13
97390: DOUBLE
97391: EQUAL
97392: IFTRUE 97396
97394: GO 97604
97396: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
97397: LD_ADDR_VAR 0 2
97401: PUSH
97402: LD_INT 1
97404: PUSH
97405: LD_INT 2
97407: PUSH
97408: LD_INT 3
97410: PUSH
97411: LD_INT 4
97413: PUSH
97414: LD_INT 5
97416: PUSH
97417: LD_INT 8
97419: PUSH
97420: LD_INT 9
97422: PUSH
97423: LD_INT 10
97425: PUSH
97426: LD_INT 11
97428: PUSH
97429: LD_INT 12
97431: PUSH
97432: LD_INT 14
97434: PUSH
97435: LD_INT 15
97437: PUSH
97438: LD_INT 16
97440: PUSH
97441: LD_INT 17
97443: PUSH
97444: LD_INT 18
97446: PUSH
97447: LD_INT 19
97449: PUSH
97450: LD_INT 20
97452: PUSH
97453: LD_INT 21
97455: PUSH
97456: LD_INT 22
97458: PUSH
97459: LD_INT 23
97461: PUSH
97462: LD_INT 24
97464: PUSH
97465: LD_INT 25
97467: PUSH
97468: LD_INT 26
97470: PUSH
97471: LD_INT 27
97473: PUSH
97474: LD_INT 28
97476: PUSH
97477: LD_INT 30
97479: PUSH
97480: LD_INT 31
97482: PUSH
97483: LD_INT 32
97485: PUSH
97486: LD_INT 33
97488: PUSH
97489: LD_INT 34
97491: PUSH
97492: LD_INT 36
97494: PUSH
97495: EMPTY
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: LIST
97508: LIST
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: PUSH
97528: LD_INT 101
97530: PUSH
97531: LD_INT 102
97533: PUSH
97534: LD_INT 103
97536: PUSH
97537: LD_INT 104
97539: PUSH
97540: LD_INT 105
97542: PUSH
97543: LD_INT 106
97545: PUSH
97546: LD_INT 107
97548: PUSH
97549: LD_INT 108
97551: PUSH
97552: LD_INT 109
97554: PUSH
97555: LD_INT 110
97557: PUSH
97558: LD_INT 111
97560: PUSH
97561: LD_INT 112
97563: PUSH
97564: LD_INT 113
97566: PUSH
97567: LD_INT 114
97569: PUSH
97570: LD_INT 116
97572: PUSH
97573: LD_INT 117
97575: PUSH
97576: LD_INT 118
97578: PUSH
97579: EMPTY
97580: LIST
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: LIST
97594: LIST
97595: LIST
97596: LIST
97597: PUSH
97598: EMPTY
97599: LIST
97600: LIST
97601: ST_TO_ADDR
97602: GO 98841
97604: LD_INT 14
97606: DOUBLE
97607: EQUAL
97608: IFTRUE 97612
97610: GO 97836
97612: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
97613: LD_ADDR_VAR 0 2
97617: PUSH
97618: LD_INT 1
97620: PUSH
97621: LD_INT 2
97623: PUSH
97624: LD_INT 3
97626: PUSH
97627: LD_INT 4
97629: PUSH
97630: LD_INT 5
97632: PUSH
97633: LD_INT 6
97635: PUSH
97636: LD_INT 7
97638: PUSH
97639: LD_INT 8
97641: PUSH
97642: LD_INT 9
97644: PUSH
97645: LD_INT 10
97647: PUSH
97648: LD_INT 11
97650: PUSH
97651: LD_INT 12
97653: PUSH
97654: LD_INT 13
97656: PUSH
97657: LD_INT 14
97659: PUSH
97660: LD_INT 15
97662: PUSH
97663: LD_INT 16
97665: PUSH
97666: LD_INT 17
97668: PUSH
97669: LD_INT 18
97671: PUSH
97672: LD_INT 19
97674: PUSH
97675: LD_INT 20
97677: PUSH
97678: LD_INT 21
97680: PUSH
97681: LD_INT 22
97683: PUSH
97684: LD_INT 23
97686: PUSH
97687: LD_INT 24
97689: PUSH
97690: LD_INT 25
97692: PUSH
97693: LD_INT 26
97695: PUSH
97696: LD_INT 27
97698: PUSH
97699: LD_INT 28
97701: PUSH
97702: LD_INT 29
97704: PUSH
97705: LD_INT 30
97707: PUSH
97708: LD_INT 31
97710: PUSH
97711: LD_INT 32
97713: PUSH
97714: LD_INT 33
97716: PUSH
97717: LD_INT 34
97719: PUSH
97720: LD_INT 36
97722: PUSH
97723: EMPTY
97724: LIST
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: PUSH
97760: LD_INT 101
97762: PUSH
97763: LD_INT 102
97765: PUSH
97766: LD_INT 103
97768: PUSH
97769: LD_INT 104
97771: PUSH
97772: LD_INT 105
97774: PUSH
97775: LD_INT 106
97777: PUSH
97778: LD_INT 107
97780: PUSH
97781: LD_INT 108
97783: PUSH
97784: LD_INT 109
97786: PUSH
97787: LD_INT 110
97789: PUSH
97790: LD_INT 111
97792: PUSH
97793: LD_INT 112
97795: PUSH
97796: LD_INT 113
97798: PUSH
97799: LD_INT 114
97801: PUSH
97802: LD_INT 116
97804: PUSH
97805: LD_INT 117
97807: PUSH
97808: LD_INT 118
97810: PUSH
97811: EMPTY
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: PUSH
97830: EMPTY
97831: LIST
97832: LIST
97833: ST_TO_ADDR
97834: GO 98841
97836: LD_INT 15
97838: DOUBLE
97839: EQUAL
97840: IFTRUE 97844
97842: GO 98068
97844: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
97845: LD_ADDR_VAR 0 2
97849: PUSH
97850: LD_INT 1
97852: PUSH
97853: LD_INT 2
97855: PUSH
97856: LD_INT 3
97858: PUSH
97859: LD_INT 4
97861: PUSH
97862: LD_INT 5
97864: PUSH
97865: LD_INT 6
97867: PUSH
97868: LD_INT 7
97870: PUSH
97871: LD_INT 8
97873: PUSH
97874: LD_INT 9
97876: PUSH
97877: LD_INT 10
97879: PUSH
97880: LD_INT 11
97882: PUSH
97883: LD_INT 12
97885: PUSH
97886: LD_INT 13
97888: PUSH
97889: LD_INT 14
97891: PUSH
97892: LD_INT 15
97894: PUSH
97895: LD_INT 16
97897: PUSH
97898: LD_INT 17
97900: PUSH
97901: LD_INT 18
97903: PUSH
97904: LD_INT 19
97906: PUSH
97907: LD_INT 20
97909: PUSH
97910: LD_INT 21
97912: PUSH
97913: LD_INT 22
97915: PUSH
97916: LD_INT 23
97918: PUSH
97919: LD_INT 24
97921: PUSH
97922: LD_INT 25
97924: PUSH
97925: LD_INT 26
97927: PUSH
97928: LD_INT 27
97930: PUSH
97931: LD_INT 28
97933: PUSH
97934: LD_INT 29
97936: PUSH
97937: LD_INT 30
97939: PUSH
97940: LD_INT 31
97942: PUSH
97943: LD_INT 32
97945: PUSH
97946: LD_INT 33
97948: PUSH
97949: LD_INT 34
97951: PUSH
97952: LD_INT 36
97954: PUSH
97955: EMPTY
97956: LIST
97957: LIST
97958: LIST
97959: LIST
97960: LIST
97961: LIST
97962: LIST
97963: LIST
97964: LIST
97965: LIST
97966: LIST
97967: LIST
97968: LIST
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: LIST
97990: LIST
97991: PUSH
97992: LD_INT 101
97994: PUSH
97995: LD_INT 102
97997: PUSH
97998: LD_INT 103
98000: PUSH
98001: LD_INT 104
98003: PUSH
98004: LD_INT 105
98006: PUSH
98007: LD_INT 106
98009: PUSH
98010: LD_INT 107
98012: PUSH
98013: LD_INT 108
98015: PUSH
98016: LD_INT 109
98018: PUSH
98019: LD_INT 110
98021: PUSH
98022: LD_INT 111
98024: PUSH
98025: LD_INT 112
98027: PUSH
98028: LD_INT 113
98030: PUSH
98031: LD_INT 114
98033: PUSH
98034: LD_INT 116
98036: PUSH
98037: LD_INT 117
98039: PUSH
98040: LD_INT 118
98042: PUSH
98043: EMPTY
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: LIST
98058: LIST
98059: LIST
98060: LIST
98061: PUSH
98062: EMPTY
98063: LIST
98064: LIST
98065: ST_TO_ADDR
98066: GO 98841
98068: LD_INT 16
98070: DOUBLE
98071: EQUAL
98072: IFTRUE 98076
98074: GO 98212
98076: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98077: LD_ADDR_VAR 0 2
98081: PUSH
98082: LD_INT 2
98084: PUSH
98085: LD_INT 4
98087: PUSH
98088: LD_INT 5
98090: PUSH
98091: LD_INT 7
98093: PUSH
98094: LD_INT 11
98096: PUSH
98097: LD_INT 12
98099: PUSH
98100: LD_INT 15
98102: PUSH
98103: LD_INT 16
98105: PUSH
98106: LD_INT 20
98108: PUSH
98109: LD_INT 21
98111: PUSH
98112: LD_INT 22
98114: PUSH
98115: LD_INT 23
98117: PUSH
98118: LD_INT 25
98120: PUSH
98121: LD_INT 26
98123: PUSH
98124: LD_INT 30
98126: PUSH
98127: LD_INT 31
98129: PUSH
98130: LD_INT 32
98132: PUSH
98133: LD_INT 33
98135: PUSH
98136: LD_INT 34
98138: PUSH
98139: EMPTY
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: LIST
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: LIST
98151: LIST
98152: LIST
98153: LIST
98154: LIST
98155: LIST
98156: LIST
98157: LIST
98158: LIST
98159: PUSH
98160: LD_INT 101
98162: PUSH
98163: LD_INT 102
98165: PUSH
98166: LD_INT 103
98168: PUSH
98169: LD_INT 106
98171: PUSH
98172: LD_INT 108
98174: PUSH
98175: LD_INT 112
98177: PUSH
98178: LD_INT 113
98180: PUSH
98181: LD_INT 114
98183: PUSH
98184: LD_INT 116
98186: PUSH
98187: LD_INT 117
98189: PUSH
98190: LD_INT 118
98192: PUSH
98193: EMPTY
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: LIST
98201: LIST
98202: LIST
98203: LIST
98204: LIST
98205: PUSH
98206: EMPTY
98207: LIST
98208: LIST
98209: ST_TO_ADDR
98210: GO 98841
98212: LD_INT 17
98214: DOUBLE
98215: EQUAL
98216: IFTRUE 98220
98218: GO 98444
98220: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98221: LD_ADDR_VAR 0 2
98225: PUSH
98226: LD_INT 1
98228: PUSH
98229: LD_INT 2
98231: PUSH
98232: LD_INT 3
98234: PUSH
98235: LD_INT 4
98237: PUSH
98238: LD_INT 5
98240: PUSH
98241: LD_INT 6
98243: PUSH
98244: LD_INT 7
98246: PUSH
98247: LD_INT 8
98249: PUSH
98250: LD_INT 9
98252: PUSH
98253: LD_INT 10
98255: PUSH
98256: LD_INT 11
98258: PUSH
98259: LD_INT 12
98261: PUSH
98262: LD_INT 13
98264: PUSH
98265: LD_INT 14
98267: PUSH
98268: LD_INT 15
98270: PUSH
98271: LD_INT 16
98273: PUSH
98274: LD_INT 17
98276: PUSH
98277: LD_INT 18
98279: PUSH
98280: LD_INT 19
98282: PUSH
98283: LD_INT 20
98285: PUSH
98286: LD_INT 21
98288: PUSH
98289: LD_INT 22
98291: PUSH
98292: LD_INT 23
98294: PUSH
98295: LD_INT 24
98297: PUSH
98298: LD_INT 25
98300: PUSH
98301: LD_INT 26
98303: PUSH
98304: LD_INT 27
98306: PUSH
98307: LD_INT 28
98309: PUSH
98310: LD_INT 29
98312: PUSH
98313: LD_INT 30
98315: PUSH
98316: LD_INT 31
98318: PUSH
98319: LD_INT 32
98321: PUSH
98322: LD_INT 33
98324: PUSH
98325: LD_INT 34
98327: PUSH
98328: LD_INT 36
98330: PUSH
98331: EMPTY
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: LIST
98366: LIST
98367: PUSH
98368: LD_INT 101
98370: PUSH
98371: LD_INT 102
98373: PUSH
98374: LD_INT 103
98376: PUSH
98377: LD_INT 104
98379: PUSH
98380: LD_INT 105
98382: PUSH
98383: LD_INT 106
98385: PUSH
98386: LD_INT 107
98388: PUSH
98389: LD_INT 108
98391: PUSH
98392: LD_INT 109
98394: PUSH
98395: LD_INT 110
98397: PUSH
98398: LD_INT 111
98400: PUSH
98401: LD_INT 112
98403: PUSH
98404: LD_INT 113
98406: PUSH
98407: LD_INT 114
98409: PUSH
98410: LD_INT 116
98412: PUSH
98413: LD_INT 117
98415: PUSH
98416: LD_INT 118
98418: PUSH
98419: EMPTY
98420: LIST
98421: LIST
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: LIST
98431: LIST
98432: LIST
98433: LIST
98434: LIST
98435: LIST
98436: LIST
98437: PUSH
98438: EMPTY
98439: LIST
98440: LIST
98441: ST_TO_ADDR
98442: GO 98841
98444: LD_INT 18
98446: DOUBLE
98447: EQUAL
98448: IFTRUE 98452
98450: GO 98600
98452: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
98453: LD_ADDR_VAR 0 2
98457: PUSH
98458: LD_INT 2
98460: PUSH
98461: LD_INT 4
98463: PUSH
98464: LD_INT 5
98466: PUSH
98467: LD_INT 7
98469: PUSH
98470: LD_INT 11
98472: PUSH
98473: LD_INT 12
98475: PUSH
98476: LD_INT 15
98478: PUSH
98479: LD_INT 16
98481: PUSH
98482: LD_INT 20
98484: PUSH
98485: LD_INT 21
98487: PUSH
98488: LD_INT 22
98490: PUSH
98491: LD_INT 23
98493: PUSH
98494: LD_INT 25
98496: PUSH
98497: LD_INT 26
98499: PUSH
98500: LD_INT 30
98502: PUSH
98503: LD_INT 31
98505: PUSH
98506: LD_INT 32
98508: PUSH
98509: LD_INT 33
98511: PUSH
98512: LD_INT 34
98514: PUSH
98515: LD_INT 35
98517: PUSH
98518: LD_INT 36
98520: PUSH
98521: EMPTY
98522: LIST
98523: LIST
98524: LIST
98525: LIST
98526: LIST
98527: LIST
98528: LIST
98529: LIST
98530: LIST
98531: LIST
98532: LIST
98533: LIST
98534: LIST
98535: LIST
98536: LIST
98537: LIST
98538: LIST
98539: LIST
98540: LIST
98541: LIST
98542: LIST
98543: PUSH
98544: LD_INT 101
98546: PUSH
98547: LD_INT 102
98549: PUSH
98550: LD_INT 103
98552: PUSH
98553: LD_INT 106
98555: PUSH
98556: LD_INT 108
98558: PUSH
98559: LD_INT 112
98561: PUSH
98562: LD_INT 113
98564: PUSH
98565: LD_INT 114
98567: PUSH
98568: LD_INT 115
98570: PUSH
98571: LD_INT 116
98573: PUSH
98574: LD_INT 117
98576: PUSH
98577: LD_INT 118
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: LIST
98587: LIST
98588: LIST
98589: LIST
98590: LIST
98591: LIST
98592: LIST
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: ST_TO_ADDR
98598: GO 98841
98600: LD_INT 19
98602: DOUBLE
98603: EQUAL
98604: IFTRUE 98608
98606: GO 98840
98608: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
98609: LD_ADDR_VAR 0 2
98613: PUSH
98614: LD_INT 1
98616: PUSH
98617: LD_INT 2
98619: PUSH
98620: LD_INT 3
98622: PUSH
98623: LD_INT 4
98625: PUSH
98626: LD_INT 5
98628: PUSH
98629: LD_INT 6
98631: PUSH
98632: LD_INT 7
98634: PUSH
98635: LD_INT 8
98637: PUSH
98638: LD_INT 9
98640: PUSH
98641: LD_INT 10
98643: PUSH
98644: LD_INT 11
98646: PUSH
98647: LD_INT 12
98649: PUSH
98650: LD_INT 13
98652: PUSH
98653: LD_INT 14
98655: PUSH
98656: LD_INT 15
98658: PUSH
98659: LD_INT 16
98661: PUSH
98662: LD_INT 17
98664: PUSH
98665: LD_INT 18
98667: PUSH
98668: LD_INT 19
98670: PUSH
98671: LD_INT 20
98673: PUSH
98674: LD_INT 21
98676: PUSH
98677: LD_INT 22
98679: PUSH
98680: LD_INT 23
98682: PUSH
98683: LD_INT 24
98685: PUSH
98686: LD_INT 25
98688: PUSH
98689: LD_INT 26
98691: PUSH
98692: LD_INT 27
98694: PUSH
98695: LD_INT 28
98697: PUSH
98698: LD_INT 29
98700: PUSH
98701: LD_INT 30
98703: PUSH
98704: LD_INT 31
98706: PUSH
98707: LD_INT 32
98709: PUSH
98710: LD_INT 33
98712: PUSH
98713: LD_INT 34
98715: PUSH
98716: LD_INT 35
98718: PUSH
98719: LD_INT 36
98721: PUSH
98722: EMPTY
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: PUSH
98760: LD_INT 101
98762: PUSH
98763: LD_INT 102
98765: PUSH
98766: LD_INT 103
98768: PUSH
98769: LD_INT 104
98771: PUSH
98772: LD_INT 105
98774: PUSH
98775: LD_INT 106
98777: PUSH
98778: LD_INT 107
98780: PUSH
98781: LD_INT 108
98783: PUSH
98784: LD_INT 109
98786: PUSH
98787: LD_INT 110
98789: PUSH
98790: LD_INT 111
98792: PUSH
98793: LD_INT 112
98795: PUSH
98796: LD_INT 113
98798: PUSH
98799: LD_INT 114
98801: PUSH
98802: LD_INT 115
98804: PUSH
98805: LD_INT 116
98807: PUSH
98808: LD_INT 117
98810: PUSH
98811: LD_INT 118
98813: PUSH
98814: EMPTY
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: PUSH
98834: EMPTY
98835: LIST
98836: LIST
98837: ST_TO_ADDR
98838: GO 98841
98840: POP
// end else
98841: GO 99072
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
98843: LD_ADDR_VAR 0 2
98847: PUSH
98848: LD_INT 1
98850: PUSH
98851: LD_INT 2
98853: PUSH
98854: LD_INT 3
98856: PUSH
98857: LD_INT 4
98859: PUSH
98860: LD_INT 5
98862: PUSH
98863: LD_INT 6
98865: PUSH
98866: LD_INT 7
98868: PUSH
98869: LD_INT 8
98871: PUSH
98872: LD_INT 9
98874: PUSH
98875: LD_INT 10
98877: PUSH
98878: LD_INT 11
98880: PUSH
98881: LD_INT 12
98883: PUSH
98884: LD_INT 13
98886: PUSH
98887: LD_INT 14
98889: PUSH
98890: LD_INT 15
98892: PUSH
98893: LD_INT 16
98895: PUSH
98896: LD_INT 17
98898: PUSH
98899: LD_INT 18
98901: PUSH
98902: LD_INT 19
98904: PUSH
98905: LD_INT 20
98907: PUSH
98908: LD_INT 21
98910: PUSH
98911: LD_INT 22
98913: PUSH
98914: LD_INT 23
98916: PUSH
98917: LD_INT 24
98919: PUSH
98920: LD_INT 25
98922: PUSH
98923: LD_INT 26
98925: PUSH
98926: LD_INT 27
98928: PUSH
98929: LD_INT 28
98931: PUSH
98932: LD_INT 29
98934: PUSH
98935: LD_INT 30
98937: PUSH
98938: LD_INT 31
98940: PUSH
98941: LD_INT 32
98943: PUSH
98944: LD_INT 33
98946: PUSH
98947: LD_INT 34
98949: PUSH
98950: LD_INT 35
98952: PUSH
98953: LD_INT 36
98955: PUSH
98956: EMPTY
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: LIST
98991: LIST
98992: LIST
98993: PUSH
98994: LD_INT 101
98996: PUSH
98997: LD_INT 102
98999: PUSH
99000: LD_INT 103
99002: PUSH
99003: LD_INT 104
99005: PUSH
99006: LD_INT 105
99008: PUSH
99009: LD_INT 106
99011: PUSH
99012: LD_INT 107
99014: PUSH
99015: LD_INT 108
99017: PUSH
99018: LD_INT 109
99020: PUSH
99021: LD_INT 110
99023: PUSH
99024: LD_INT 111
99026: PUSH
99027: LD_INT 112
99029: PUSH
99030: LD_INT 113
99032: PUSH
99033: LD_INT 114
99035: PUSH
99036: LD_INT 115
99038: PUSH
99039: LD_INT 116
99041: PUSH
99042: LD_INT 117
99044: PUSH
99045: LD_INT 118
99047: PUSH
99048: EMPTY
99049: LIST
99050: LIST
99051: LIST
99052: LIST
99053: LIST
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: LIST
99063: LIST
99064: LIST
99065: LIST
99066: LIST
99067: PUSH
99068: EMPTY
99069: LIST
99070: LIST
99071: ST_TO_ADDR
// if result then
99072: LD_VAR 0 2
99076: IFFALSE 99862
// begin normal :=  ;
99078: LD_ADDR_VAR 0 5
99082: PUSH
99083: LD_STRING 
99085: ST_TO_ADDR
// hardcore :=  ;
99086: LD_ADDR_VAR 0 6
99090: PUSH
99091: LD_STRING 
99093: ST_TO_ADDR
// active :=  ;
99094: LD_ADDR_VAR 0 7
99098: PUSH
99099: LD_STRING 
99101: ST_TO_ADDR
// for i = 1 to normalCounter do
99102: LD_ADDR_VAR 0 8
99106: PUSH
99107: DOUBLE
99108: LD_INT 1
99110: DEC
99111: ST_TO_ADDR
99112: LD_EXP 100
99116: PUSH
99117: FOR_TO
99118: IFFALSE 99219
// begin tmp := 0 ;
99120: LD_ADDR_VAR 0 3
99124: PUSH
99125: LD_STRING 0
99127: ST_TO_ADDR
// if result [ 1 ] then
99128: LD_VAR 0 2
99132: PUSH
99133: LD_INT 1
99135: ARRAY
99136: IFFALSE 99201
// if result [ 1 ] [ 1 ] = i then
99138: LD_VAR 0 2
99142: PUSH
99143: LD_INT 1
99145: ARRAY
99146: PUSH
99147: LD_INT 1
99149: ARRAY
99150: PUSH
99151: LD_VAR 0 8
99155: EQUAL
99156: IFFALSE 99201
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99158: LD_ADDR_VAR 0 2
99162: PUSH
99163: LD_VAR 0 2
99167: PPUSH
99168: LD_INT 1
99170: PPUSH
99171: LD_VAR 0 2
99175: PUSH
99176: LD_INT 1
99178: ARRAY
99179: PPUSH
99180: LD_INT 1
99182: PPUSH
99183: CALL_OW 3
99187: PPUSH
99188: CALL_OW 1
99192: ST_TO_ADDR
// tmp := 1 ;
99193: LD_ADDR_VAR 0 3
99197: PUSH
99198: LD_STRING 1
99200: ST_TO_ADDR
// end ; normal := normal & tmp ;
99201: LD_ADDR_VAR 0 5
99205: PUSH
99206: LD_VAR 0 5
99210: PUSH
99211: LD_VAR 0 3
99215: STR
99216: ST_TO_ADDR
// end ;
99217: GO 99117
99219: POP
99220: POP
// for i = 1 to hardcoreCounter do
99221: LD_ADDR_VAR 0 8
99225: PUSH
99226: DOUBLE
99227: LD_INT 1
99229: DEC
99230: ST_TO_ADDR
99231: LD_EXP 101
99235: PUSH
99236: FOR_TO
99237: IFFALSE 99342
// begin tmp := 0 ;
99239: LD_ADDR_VAR 0 3
99243: PUSH
99244: LD_STRING 0
99246: ST_TO_ADDR
// if result [ 2 ] then
99247: LD_VAR 0 2
99251: PUSH
99252: LD_INT 2
99254: ARRAY
99255: IFFALSE 99324
// if result [ 2 ] [ 1 ] = 100 + i then
99257: LD_VAR 0 2
99261: PUSH
99262: LD_INT 2
99264: ARRAY
99265: PUSH
99266: LD_INT 1
99268: ARRAY
99269: PUSH
99270: LD_INT 100
99272: PUSH
99273: LD_VAR 0 8
99277: PLUS
99278: EQUAL
99279: IFFALSE 99324
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
99281: LD_ADDR_VAR 0 2
99285: PUSH
99286: LD_VAR 0 2
99290: PPUSH
99291: LD_INT 2
99293: PPUSH
99294: LD_VAR 0 2
99298: PUSH
99299: LD_INT 2
99301: ARRAY
99302: PPUSH
99303: LD_INT 1
99305: PPUSH
99306: CALL_OW 3
99310: PPUSH
99311: CALL_OW 1
99315: ST_TO_ADDR
// tmp := 1 ;
99316: LD_ADDR_VAR 0 3
99320: PUSH
99321: LD_STRING 1
99323: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
99324: LD_ADDR_VAR 0 6
99328: PUSH
99329: LD_VAR 0 6
99333: PUSH
99334: LD_VAR 0 3
99338: STR
99339: ST_TO_ADDR
// end ;
99340: GO 99236
99342: POP
99343: POP
// if isGameLoad then
99344: LD_VAR 0 1
99348: IFFALSE 99823
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
99350: LD_ADDR_VAR 0 4
99354: PUSH
99355: LD_EXP 104
99359: PUSH
99360: LD_EXP 103
99364: PUSH
99365: LD_EXP 105
99369: PUSH
99370: LD_EXP 102
99374: PUSH
99375: LD_EXP 106
99379: PUSH
99380: LD_EXP 107
99384: PUSH
99385: LD_EXP 108
99389: PUSH
99390: LD_EXP 109
99394: PUSH
99395: LD_EXP 110
99399: PUSH
99400: LD_EXP 111
99404: PUSH
99405: LD_EXP 112
99409: PUSH
99410: LD_EXP 113
99414: PUSH
99415: LD_EXP 114
99419: PUSH
99420: LD_EXP 115
99424: PUSH
99425: LD_EXP 123
99429: PUSH
99430: LD_EXP 124
99434: PUSH
99435: LD_EXP 125
99439: PUSH
99440: LD_EXP 126
99444: PUSH
99445: LD_EXP 128
99449: PUSH
99450: LD_EXP 129
99454: PUSH
99455: LD_EXP 130
99459: PUSH
99460: LD_EXP 133
99464: PUSH
99465: LD_EXP 135
99469: PUSH
99470: LD_EXP 136
99474: PUSH
99475: LD_EXP 137
99479: PUSH
99480: LD_EXP 139
99484: PUSH
99485: LD_EXP 140
99489: PUSH
99490: LD_EXP 143
99494: PUSH
99495: LD_EXP 144
99499: PUSH
99500: LD_EXP 145
99504: PUSH
99505: LD_EXP 146
99509: PUSH
99510: LD_EXP 147
99514: PUSH
99515: LD_EXP 148
99519: PUSH
99520: LD_EXP 149
99524: PUSH
99525: LD_EXP 150
99529: PUSH
99530: LD_EXP 151
99534: PUSH
99535: LD_EXP 116
99539: PUSH
99540: LD_EXP 117
99544: PUSH
99545: LD_EXP 120
99549: PUSH
99550: LD_EXP 121
99554: PUSH
99555: LD_EXP 122
99559: PUSH
99560: LD_EXP 118
99564: PUSH
99565: LD_EXP 119
99569: PUSH
99570: LD_EXP 127
99574: PUSH
99575: LD_EXP 131
99579: PUSH
99580: LD_EXP 132
99584: PUSH
99585: LD_EXP 134
99589: PUSH
99590: LD_EXP 138
99594: PUSH
99595: LD_EXP 141
99599: PUSH
99600: LD_EXP 142
99604: PUSH
99605: LD_EXP 152
99609: PUSH
99610: LD_EXP 153
99614: PUSH
99615: LD_EXP 154
99619: PUSH
99620: LD_EXP 155
99624: PUSH
99625: EMPTY
99626: LIST
99627: LIST
99628: LIST
99629: LIST
99630: LIST
99631: LIST
99632: LIST
99633: LIST
99634: LIST
99635: LIST
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: LIST
99677: LIST
99678: LIST
99679: LIST
99680: ST_TO_ADDR
// tmp :=  ;
99681: LD_ADDR_VAR 0 3
99685: PUSH
99686: LD_STRING 
99688: ST_TO_ADDR
// for i = 1 to normalCounter do
99689: LD_ADDR_VAR 0 8
99693: PUSH
99694: DOUBLE
99695: LD_INT 1
99697: DEC
99698: ST_TO_ADDR
99699: LD_EXP 100
99703: PUSH
99704: FOR_TO
99705: IFFALSE 99741
// begin if flags [ i ] then
99707: LD_VAR 0 4
99711: PUSH
99712: LD_VAR 0 8
99716: ARRAY
99717: IFFALSE 99739
// tmp := tmp & i & ; ;
99719: LD_ADDR_VAR 0 3
99723: PUSH
99724: LD_VAR 0 3
99728: PUSH
99729: LD_VAR 0 8
99733: STR
99734: PUSH
99735: LD_STRING ;
99737: STR
99738: ST_TO_ADDR
// end ;
99739: GO 99704
99741: POP
99742: POP
// for i = 1 to hardcoreCounter do
99743: LD_ADDR_VAR 0 8
99747: PUSH
99748: DOUBLE
99749: LD_INT 1
99751: DEC
99752: ST_TO_ADDR
99753: LD_EXP 101
99757: PUSH
99758: FOR_TO
99759: IFFALSE 99805
// begin if flags [ normalCounter + i ] then
99761: LD_VAR 0 4
99765: PUSH
99766: LD_EXP 100
99770: PUSH
99771: LD_VAR 0 8
99775: PLUS
99776: ARRAY
99777: IFFALSE 99803
// tmp := tmp & ( 100 + i ) & ; ;
99779: LD_ADDR_VAR 0 3
99783: PUSH
99784: LD_VAR 0 3
99788: PUSH
99789: LD_INT 100
99791: PUSH
99792: LD_VAR 0 8
99796: PLUS
99797: STR
99798: PUSH
99799: LD_STRING ;
99801: STR
99802: ST_TO_ADDR
// end ;
99803: GO 99758
99805: POP
99806: POP
// if tmp then
99807: LD_VAR 0 3
99811: IFFALSE 99823
// active := tmp ;
99813: LD_ADDR_VAR 0 7
99817: PUSH
99818: LD_VAR 0 3
99822: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
99823: LD_STRING getStreamItemsFromMission("
99825: PUSH
99826: LD_VAR 0 5
99830: STR
99831: PUSH
99832: LD_STRING ","
99834: STR
99835: PUSH
99836: LD_VAR 0 6
99840: STR
99841: PUSH
99842: LD_STRING ","
99844: STR
99845: PUSH
99846: LD_VAR 0 7
99850: STR
99851: PUSH
99852: LD_STRING ")
99854: STR
99855: PPUSH
99856: CALL_OW 559
// end else
99860: GO 99869
// ToLua ( getStreamItemsFromMission("","","") ) ;
99862: LD_STRING getStreamItemsFromMission("","","")
99864: PPUSH
99865: CALL_OW 559
// end ;
99869: LD_VAR 0 2
99873: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
99874: LD_EXP 99
99878: PUSH
99879: LD_EXP 104
99883: AND
99884: IFFALSE 100008
99886: GO 99888
99888: DISABLE
99889: LD_INT 0
99891: PPUSH
99892: PPUSH
// begin enable ;
99893: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
99894: LD_ADDR_VAR 0 2
99898: PUSH
99899: LD_INT 22
99901: PUSH
99902: LD_OWVAR 2
99906: PUSH
99907: EMPTY
99908: LIST
99909: LIST
99910: PUSH
99911: LD_INT 2
99913: PUSH
99914: LD_INT 34
99916: PUSH
99917: LD_INT 7
99919: PUSH
99920: EMPTY
99921: LIST
99922: LIST
99923: PUSH
99924: LD_INT 34
99926: PUSH
99927: LD_INT 45
99929: PUSH
99930: EMPTY
99931: LIST
99932: LIST
99933: PUSH
99934: LD_INT 34
99936: PUSH
99937: LD_INT 28
99939: PUSH
99940: EMPTY
99941: LIST
99942: LIST
99943: PUSH
99944: LD_INT 34
99946: PUSH
99947: LD_INT 47
99949: PUSH
99950: EMPTY
99951: LIST
99952: LIST
99953: PUSH
99954: EMPTY
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: PUSH
99961: EMPTY
99962: LIST
99963: LIST
99964: PPUSH
99965: CALL_OW 69
99969: ST_TO_ADDR
// if not tmp then
99970: LD_VAR 0 2
99974: NOT
99975: IFFALSE 99979
// exit ;
99977: GO 100008
// for i in tmp do
99979: LD_ADDR_VAR 0 1
99983: PUSH
99984: LD_VAR 0 2
99988: PUSH
99989: FOR_IN
99990: IFFALSE 100006
// begin SetLives ( i , 0 ) ;
99992: LD_VAR 0 1
99996: PPUSH
99997: LD_INT 0
99999: PPUSH
100000: CALL_OW 234
// end ;
100004: GO 99989
100006: POP
100007: POP
// end ;
100008: PPOPN 2
100010: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100011: LD_EXP 99
100015: PUSH
100016: LD_EXP 105
100020: AND
100021: IFFALSE 100105
100023: GO 100025
100025: DISABLE
100026: LD_INT 0
100028: PPUSH
100029: PPUSH
// begin enable ;
100030: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100031: LD_ADDR_VAR 0 2
100035: PUSH
100036: LD_INT 22
100038: PUSH
100039: LD_OWVAR 2
100043: PUSH
100044: EMPTY
100045: LIST
100046: LIST
100047: PUSH
100048: LD_INT 32
100050: PUSH
100051: LD_INT 3
100053: PUSH
100054: EMPTY
100055: LIST
100056: LIST
100057: PUSH
100058: EMPTY
100059: LIST
100060: LIST
100061: PPUSH
100062: CALL_OW 69
100066: ST_TO_ADDR
// if not tmp then
100067: LD_VAR 0 2
100071: NOT
100072: IFFALSE 100076
// exit ;
100074: GO 100105
// for i in tmp do
100076: LD_ADDR_VAR 0 1
100080: PUSH
100081: LD_VAR 0 2
100085: PUSH
100086: FOR_IN
100087: IFFALSE 100103
// begin SetLives ( i , 0 ) ;
100089: LD_VAR 0 1
100093: PPUSH
100094: LD_INT 0
100096: PPUSH
100097: CALL_OW 234
// end ;
100101: GO 100086
100103: POP
100104: POP
// end ;
100105: PPOPN 2
100107: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100108: LD_EXP 99
100112: PUSH
100113: LD_EXP 102
100117: AND
100118: IFFALSE 100211
100120: GO 100122
100122: DISABLE
100123: LD_INT 0
100125: PPUSH
// begin enable ;
100126: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100127: LD_ADDR_VAR 0 1
100131: PUSH
100132: LD_INT 22
100134: PUSH
100135: LD_OWVAR 2
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: PUSH
100144: LD_INT 2
100146: PUSH
100147: LD_INT 25
100149: PUSH
100150: LD_INT 5
100152: PUSH
100153: EMPTY
100154: LIST
100155: LIST
100156: PUSH
100157: LD_INT 25
100159: PUSH
100160: LD_INT 9
100162: PUSH
100163: EMPTY
100164: LIST
100165: LIST
100166: PUSH
100167: LD_INT 25
100169: PUSH
100170: LD_INT 8
100172: PUSH
100173: EMPTY
100174: LIST
100175: LIST
100176: PUSH
100177: EMPTY
100178: LIST
100179: LIST
100180: LIST
100181: LIST
100182: PUSH
100183: EMPTY
100184: LIST
100185: LIST
100186: PPUSH
100187: CALL_OW 69
100191: PUSH
100192: FOR_IN
100193: IFFALSE 100209
// begin SetClass ( i , 1 ) ;
100195: LD_VAR 0 1
100199: PPUSH
100200: LD_INT 1
100202: PPUSH
100203: CALL_OW 336
// end ;
100207: GO 100192
100209: POP
100210: POP
// end ;
100211: PPOPN 1
100213: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100214: LD_EXP 99
100218: PUSH
100219: LD_EXP 103
100223: AND
100224: PUSH
100225: LD_OWVAR 65
100229: PUSH
100230: LD_INT 7
100232: LESS
100233: AND
100234: IFFALSE 100248
100236: GO 100238
100238: DISABLE
// begin enable ;
100239: ENABLE
// game_speed := 7 ;
100240: LD_ADDR_OWVAR 65
100244: PUSH
100245: LD_INT 7
100247: ST_TO_ADDR
// end ;
100248: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100249: LD_EXP 99
100253: PUSH
100254: LD_EXP 106
100258: AND
100259: IFFALSE 100461
100261: GO 100263
100263: DISABLE
100264: LD_INT 0
100266: PPUSH
100267: PPUSH
100268: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100269: LD_ADDR_VAR 0 3
100273: PUSH
100274: LD_INT 81
100276: PUSH
100277: LD_OWVAR 2
100281: PUSH
100282: EMPTY
100283: LIST
100284: LIST
100285: PUSH
100286: LD_INT 21
100288: PUSH
100289: LD_INT 1
100291: PUSH
100292: EMPTY
100293: LIST
100294: LIST
100295: PUSH
100296: EMPTY
100297: LIST
100298: LIST
100299: PPUSH
100300: CALL_OW 69
100304: ST_TO_ADDR
// if not tmp then
100305: LD_VAR 0 3
100309: NOT
100310: IFFALSE 100314
// exit ;
100312: GO 100461
// if tmp > 5 then
100314: LD_VAR 0 3
100318: PUSH
100319: LD_INT 5
100321: GREATER
100322: IFFALSE 100334
// k := 5 else
100324: LD_ADDR_VAR 0 2
100328: PUSH
100329: LD_INT 5
100331: ST_TO_ADDR
100332: GO 100344
// k := tmp ;
100334: LD_ADDR_VAR 0 2
100338: PUSH
100339: LD_VAR 0 3
100343: ST_TO_ADDR
// for i := 1 to k do
100344: LD_ADDR_VAR 0 1
100348: PUSH
100349: DOUBLE
100350: LD_INT 1
100352: DEC
100353: ST_TO_ADDR
100354: LD_VAR 0 2
100358: PUSH
100359: FOR_TO
100360: IFFALSE 100459
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
100362: LD_VAR 0 3
100366: PUSH
100367: LD_VAR 0 1
100371: ARRAY
100372: PPUSH
100373: LD_VAR 0 1
100377: PUSH
100378: LD_INT 4
100380: MOD
100381: PUSH
100382: LD_INT 1
100384: PLUS
100385: PPUSH
100386: CALL_OW 259
100390: PUSH
100391: LD_INT 10
100393: LESS
100394: IFFALSE 100457
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
100396: LD_VAR 0 3
100400: PUSH
100401: LD_VAR 0 1
100405: ARRAY
100406: PPUSH
100407: LD_VAR 0 1
100411: PUSH
100412: LD_INT 4
100414: MOD
100415: PUSH
100416: LD_INT 1
100418: PLUS
100419: PPUSH
100420: LD_VAR 0 3
100424: PUSH
100425: LD_VAR 0 1
100429: ARRAY
100430: PPUSH
100431: LD_VAR 0 1
100435: PUSH
100436: LD_INT 4
100438: MOD
100439: PUSH
100440: LD_INT 1
100442: PLUS
100443: PPUSH
100444: CALL_OW 259
100448: PUSH
100449: LD_INT 1
100451: PLUS
100452: PPUSH
100453: CALL_OW 237
100457: GO 100359
100459: POP
100460: POP
// end ;
100461: PPOPN 3
100463: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
100464: LD_EXP 99
100468: PUSH
100469: LD_EXP 107
100473: AND
100474: IFFALSE 100494
100476: GO 100478
100478: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
100479: LD_INT 4
100481: PPUSH
100482: LD_OWVAR 2
100486: PPUSH
100487: LD_INT 0
100489: PPUSH
100490: CALL_OW 324
100494: END
// every 0 0$1 trigger StreamModeActive and sShovel do
100495: LD_EXP 99
100499: PUSH
100500: LD_EXP 136
100504: AND
100505: IFFALSE 100525
100507: GO 100509
100509: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
100510: LD_INT 19
100512: PPUSH
100513: LD_OWVAR 2
100517: PPUSH
100518: LD_INT 0
100520: PPUSH
100521: CALL_OW 324
100525: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
100526: LD_EXP 99
100530: PUSH
100531: LD_EXP 108
100535: AND
100536: IFFALSE 100638
100538: GO 100540
100540: DISABLE
100541: LD_INT 0
100543: PPUSH
100544: PPUSH
// begin enable ;
100545: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
100546: LD_ADDR_VAR 0 2
100550: PUSH
100551: LD_INT 22
100553: PUSH
100554: LD_OWVAR 2
100558: PUSH
100559: EMPTY
100560: LIST
100561: LIST
100562: PUSH
100563: LD_INT 2
100565: PUSH
100566: LD_INT 34
100568: PUSH
100569: LD_INT 11
100571: PUSH
100572: EMPTY
100573: LIST
100574: LIST
100575: PUSH
100576: LD_INT 34
100578: PUSH
100579: LD_INT 30
100581: PUSH
100582: EMPTY
100583: LIST
100584: LIST
100585: PUSH
100586: EMPTY
100587: LIST
100588: LIST
100589: LIST
100590: PUSH
100591: EMPTY
100592: LIST
100593: LIST
100594: PPUSH
100595: CALL_OW 69
100599: ST_TO_ADDR
// if not tmp then
100600: LD_VAR 0 2
100604: NOT
100605: IFFALSE 100609
// exit ;
100607: GO 100638
// for i in tmp do
100609: LD_ADDR_VAR 0 1
100613: PUSH
100614: LD_VAR 0 2
100618: PUSH
100619: FOR_IN
100620: IFFALSE 100636
// begin SetLives ( i , 0 ) ;
100622: LD_VAR 0 1
100626: PPUSH
100627: LD_INT 0
100629: PPUSH
100630: CALL_OW 234
// end ;
100634: GO 100619
100636: POP
100637: POP
// end ;
100638: PPOPN 2
100640: END
// every 0 0$1 trigger StreamModeActive and sBunker do
100641: LD_EXP 99
100645: PUSH
100646: LD_EXP 109
100650: AND
100651: IFFALSE 100671
100653: GO 100655
100655: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
100656: LD_INT 32
100658: PPUSH
100659: LD_OWVAR 2
100663: PPUSH
100664: LD_INT 0
100666: PPUSH
100667: CALL_OW 324
100671: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
100672: LD_EXP 99
100676: PUSH
100677: LD_EXP 110
100681: AND
100682: IFFALSE 100863
100684: GO 100686
100686: DISABLE
100687: LD_INT 0
100689: PPUSH
100690: PPUSH
100691: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
100692: LD_ADDR_VAR 0 2
100696: PUSH
100697: LD_INT 22
100699: PUSH
100700: LD_OWVAR 2
100704: PUSH
100705: EMPTY
100706: LIST
100707: LIST
100708: PUSH
100709: LD_INT 33
100711: PUSH
100712: LD_INT 3
100714: PUSH
100715: EMPTY
100716: LIST
100717: LIST
100718: PUSH
100719: EMPTY
100720: LIST
100721: LIST
100722: PPUSH
100723: CALL_OW 69
100727: ST_TO_ADDR
// if not tmp then
100728: LD_VAR 0 2
100732: NOT
100733: IFFALSE 100737
// exit ;
100735: GO 100863
// side := 0 ;
100737: LD_ADDR_VAR 0 3
100741: PUSH
100742: LD_INT 0
100744: ST_TO_ADDR
// for i := 1 to 8 do
100745: LD_ADDR_VAR 0 1
100749: PUSH
100750: DOUBLE
100751: LD_INT 1
100753: DEC
100754: ST_TO_ADDR
100755: LD_INT 8
100757: PUSH
100758: FOR_TO
100759: IFFALSE 100807
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
100761: LD_OWVAR 2
100765: PUSH
100766: LD_VAR 0 1
100770: NONEQUAL
100771: PUSH
100772: LD_OWVAR 2
100776: PPUSH
100777: LD_VAR 0 1
100781: PPUSH
100782: CALL_OW 81
100786: PUSH
100787: LD_INT 2
100789: EQUAL
100790: AND
100791: IFFALSE 100805
// begin side := i ;
100793: LD_ADDR_VAR 0 3
100797: PUSH
100798: LD_VAR 0 1
100802: ST_TO_ADDR
// break ;
100803: GO 100807
// end ;
100805: GO 100758
100807: POP
100808: POP
// if not side then
100809: LD_VAR 0 3
100813: NOT
100814: IFFALSE 100818
// exit ;
100816: GO 100863
// for i := 1 to tmp do
100818: LD_ADDR_VAR 0 1
100822: PUSH
100823: DOUBLE
100824: LD_INT 1
100826: DEC
100827: ST_TO_ADDR
100828: LD_VAR 0 2
100832: PUSH
100833: FOR_TO
100834: IFFALSE 100861
// if Prob ( 60 ) then
100836: LD_INT 60
100838: PPUSH
100839: CALL_OW 13
100843: IFFALSE 100859
// SetSide ( i , side ) ;
100845: LD_VAR 0 1
100849: PPUSH
100850: LD_VAR 0 3
100854: PPUSH
100855: CALL_OW 235
100859: GO 100833
100861: POP
100862: POP
// end ;
100863: PPOPN 3
100865: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
100866: LD_EXP 99
100870: PUSH
100871: LD_EXP 112
100875: AND
100876: IFFALSE 100995
100878: GO 100880
100880: DISABLE
100881: LD_INT 0
100883: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
100884: LD_ADDR_VAR 0 1
100888: PUSH
100889: LD_INT 22
100891: PUSH
100892: LD_OWVAR 2
100896: PUSH
100897: EMPTY
100898: LIST
100899: LIST
100900: PUSH
100901: LD_INT 21
100903: PUSH
100904: LD_INT 1
100906: PUSH
100907: EMPTY
100908: LIST
100909: LIST
100910: PUSH
100911: LD_INT 3
100913: PUSH
100914: LD_INT 23
100916: PUSH
100917: LD_INT 0
100919: PUSH
100920: EMPTY
100921: LIST
100922: LIST
100923: PUSH
100924: EMPTY
100925: LIST
100926: LIST
100927: PUSH
100928: EMPTY
100929: LIST
100930: LIST
100931: LIST
100932: PPUSH
100933: CALL_OW 69
100937: PUSH
100938: FOR_IN
100939: IFFALSE 100993
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
100941: LD_VAR 0 1
100945: PPUSH
100946: CALL_OW 257
100950: PUSH
100951: LD_INT 1
100953: PUSH
100954: LD_INT 2
100956: PUSH
100957: LD_INT 3
100959: PUSH
100960: LD_INT 4
100962: PUSH
100963: EMPTY
100964: LIST
100965: LIST
100966: LIST
100967: LIST
100968: IN
100969: IFFALSE 100991
// SetClass ( un , rand ( 1 , 4 ) ) ;
100971: LD_VAR 0 1
100975: PPUSH
100976: LD_INT 1
100978: PPUSH
100979: LD_INT 4
100981: PPUSH
100982: CALL_OW 12
100986: PPUSH
100987: CALL_OW 336
100991: GO 100938
100993: POP
100994: POP
// end ;
100995: PPOPN 1
100997: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
100998: LD_EXP 99
101002: PUSH
101003: LD_EXP 111
101007: AND
101008: IFFALSE 101087
101010: GO 101012
101012: DISABLE
101013: LD_INT 0
101015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101016: LD_ADDR_VAR 0 1
101020: PUSH
101021: LD_INT 22
101023: PUSH
101024: LD_OWVAR 2
101028: PUSH
101029: EMPTY
101030: LIST
101031: LIST
101032: PUSH
101033: LD_INT 21
101035: PUSH
101036: LD_INT 3
101038: PUSH
101039: EMPTY
101040: LIST
101041: LIST
101042: PUSH
101043: EMPTY
101044: LIST
101045: LIST
101046: PPUSH
101047: CALL_OW 69
101051: ST_TO_ADDR
// if not tmp then
101052: LD_VAR 0 1
101056: NOT
101057: IFFALSE 101061
// exit ;
101059: GO 101087
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101061: LD_VAR 0 1
101065: PUSH
101066: LD_INT 1
101068: PPUSH
101069: LD_VAR 0 1
101073: PPUSH
101074: CALL_OW 12
101078: ARRAY
101079: PPUSH
101080: LD_INT 100
101082: PPUSH
101083: CALL_OW 234
// end ;
101087: PPOPN 1
101089: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101090: LD_EXP 99
101094: PUSH
101095: LD_EXP 113
101099: AND
101100: IFFALSE 101198
101102: GO 101104
101104: DISABLE
101105: LD_INT 0
101107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101108: LD_ADDR_VAR 0 1
101112: PUSH
101113: LD_INT 22
101115: PUSH
101116: LD_OWVAR 2
101120: PUSH
101121: EMPTY
101122: LIST
101123: LIST
101124: PUSH
101125: LD_INT 21
101127: PUSH
101128: LD_INT 1
101130: PUSH
101131: EMPTY
101132: LIST
101133: LIST
101134: PUSH
101135: EMPTY
101136: LIST
101137: LIST
101138: PPUSH
101139: CALL_OW 69
101143: ST_TO_ADDR
// if not tmp then
101144: LD_VAR 0 1
101148: NOT
101149: IFFALSE 101153
// exit ;
101151: GO 101198
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101153: LD_VAR 0 1
101157: PUSH
101158: LD_INT 1
101160: PPUSH
101161: LD_VAR 0 1
101165: PPUSH
101166: CALL_OW 12
101170: ARRAY
101171: PPUSH
101172: LD_INT 1
101174: PPUSH
101175: LD_INT 4
101177: PPUSH
101178: CALL_OW 12
101182: PPUSH
101183: LD_INT 3000
101185: PPUSH
101186: LD_INT 9000
101188: PPUSH
101189: CALL_OW 12
101193: PPUSH
101194: CALL_OW 492
// end ;
101198: PPOPN 1
101200: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101201: LD_EXP 99
101205: PUSH
101206: LD_EXP 114
101210: AND
101211: IFFALSE 101231
101213: GO 101215
101215: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101216: LD_INT 1
101218: PPUSH
101219: LD_OWVAR 2
101223: PPUSH
101224: LD_INT 0
101226: PPUSH
101227: CALL_OW 324
101231: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101232: LD_EXP 99
101236: PUSH
101237: LD_EXP 115
101241: AND
101242: IFFALSE 101325
101244: GO 101246
101246: DISABLE
101247: LD_INT 0
101249: PPUSH
101250: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101251: LD_ADDR_VAR 0 2
101255: PUSH
101256: LD_INT 22
101258: PUSH
101259: LD_OWVAR 2
101263: PUSH
101264: EMPTY
101265: LIST
101266: LIST
101267: PUSH
101268: LD_INT 21
101270: PUSH
101271: LD_INT 3
101273: PUSH
101274: EMPTY
101275: LIST
101276: LIST
101277: PUSH
101278: EMPTY
101279: LIST
101280: LIST
101281: PPUSH
101282: CALL_OW 69
101286: ST_TO_ADDR
// if not tmp then
101287: LD_VAR 0 2
101291: NOT
101292: IFFALSE 101296
// exit ;
101294: GO 101325
// for i in tmp do
101296: LD_ADDR_VAR 0 1
101300: PUSH
101301: LD_VAR 0 2
101305: PUSH
101306: FOR_IN
101307: IFFALSE 101323
// SetBLevel ( i , 10 ) ;
101309: LD_VAR 0 1
101313: PPUSH
101314: LD_INT 10
101316: PPUSH
101317: CALL_OW 241
101321: GO 101306
101323: POP
101324: POP
// end ;
101325: PPOPN 2
101327: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
101328: LD_EXP 99
101332: PUSH
101333: LD_EXP 116
101337: AND
101338: IFFALSE 101449
101340: GO 101342
101342: DISABLE
101343: LD_INT 0
101345: PPUSH
101346: PPUSH
101347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101348: LD_ADDR_VAR 0 3
101352: PUSH
101353: LD_INT 22
101355: PUSH
101356: LD_OWVAR 2
101360: PUSH
101361: EMPTY
101362: LIST
101363: LIST
101364: PUSH
101365: LD_INT 25
101367: PUSH
101368: LD_INT 1
101370: PUSH
101371: EMPTY
101372: LIST
101373: LIST
101374: PUSH
101375: EMPTY
101376: LIST
101377: LIST
101378: PPUSH
101379: CALL_OW 69
101383: ST_TO_ADDR
// if not tmp then
101384: LD_VAR 0 3
101388: NOT
101389: IFFALSE 101393
// exit ;
101391: GO 101449
// un := tmp [ rand ( 1 , tmp ) ] ;
101393: LD_ADDR_VAR 0 2
101397: PUSH
101398: LD_VAR 0 3
101402: PUSH
101403: LD_INT 1
101405: PPUSH
101406: LD_VAR 0 3
101410: PPUSH
101411: CALL_OW 12
101415: ARRAY
101416: ST_TO_ADDR
// if Crawls ( un ) then
101417: LD_VAR 0 2
101421: PPUSH
101422: CALL_OW 318
101426: IFFALSE 101437
// ComWalk ( un ) ;
101428: LD_VAR 0 2
101432: PPUSH
101433: CALL_OW 138
// SetClass ( un , class_sniper ) ;
101437: LD_VAR 0 2
101441: PPUSH
101442: LD_INT 5
101444: PPUSH
101445: CALL_OW 336
// end ;
101449: PPOPN 3
101451: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
101452: LD_EXP 99
101456: PUSH
101457: LD_EXP 117
101461: AND
101462: PUSH
101463: LD_OWVAR 67
101467: PUSH
101468: LD_INT 4
101470: LESS
101471: AND
101472: IFFALSE 101491
101474: GO 101476
101476: DISABLE
// begin Difficulty := Difficulty + 1 ;
101477: LD_ADDR_OWVAR 67
101481: PUSH
101482: LD_OWVAR 67
101486: PUSH
101487: LD_INT 1
101489: PLUS
101490: ST_TO_ADDR
// end ;
101491: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
101492: LD_EXP 99
101496: PUSH
101497: LD_EXP 118
101501: AND
101502: IFFALSE 101605
101504: GO 101506
101506: DISABLE
101507: LD_INT 0
101509: PPUSH
// begin for i := 1 to 5 do
101510: LD_ADDR_VAR 0 1
101514: PUSH
101515: DOUBLE
101516: LD_INT 1
101518: DEC
101519: ST_TO_ADDR
101520: LD_INT 5
101522: PUSH
101523: FOR_TO
101524: IFFALSE 101603
// begin uc_nation := nation_nature ;
101526: LD_ADDR_OWVAR 21
101530: PUSH
101531: LD_INT 0
101533: ST_TO_ADDR
// uc_side := 0 ;
101534: LD_ADDR_OWVAR 20
101538: PUSH
101539: LD_INT 0
101541: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
101542: LD_ADDR_OWVAR 29
101546: PUSH
101547: LD_INT 12
101549: PUSH
101550: LD_INT 12
101552: PUSH
101553: EMPTY
101554: LIST
101555: LIST
101556: ST_TO_ADDR
// hc_agressivity := 20 ;
101557: LD_ADDR_OWVAR 35
101561: PUSH
101562: LD_INT 20
101564: ST_TO_ADDR
// hc_class := class_tiger ;
101565: LD_ADDR_OWVAR 28
101569: PUSH
101570: LD_INT 14
101572: ST_TO_ADDR
// hc_gallery :=  ;
101573: LD_ADDR_OWVAR 33
101577: PUSH
101578: LD_STRING 
101580: ST_TO_ADDR
// hc_name :=  ;
101581: LD_ADDR_OWVAR 26
101585: PUSH
101586: LD_STRING 
101588: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
101589: CALL_OW 44
101593: PPUSH
101594: LD_INT 0
101596: PPUSH
101597: CALL_OW 51
// end ;
101601: GO 101523
101603: POP
101604: POP
// end ;
101605: PPOPN 1
101607: END
// every 0 0$1 trigger StreamModeActive and sBomb do
101608: LD_EXP 99
101612: PUSH
101613: LD_EXP 119
101617: AND
101618: IFFALSE 101627
101620: GO 101622
101622: DISABLE
// StreamSibBomb ;
101623: CALL 101628 0 0
101627: END
// export function StreamSibBomb ; var i , x , y ; begin
101628: LD_INT 0
101630: PPUSH
101631: PPUSH
101632: PPUSH
101633: PPUSH
// result := false ;
101634: LD_ADDR_VAR 0 1
101638: PUSH
101639: LD_INT 0
101641: ST_TO_ADDR
// for i := 1 to 16 do
101642: LD_ADDR_VAR 0 2
101646: PUSH
101647: DOUBLE
101648: LD_INT 1
101650: DEC
101651: ST_TO_ADDR
101652: LD_INT 16
101654: PUSH
101655: FOR_TO
101656: IFFALSE 101855
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101658: LD_ADDR_VAR 0 3
101662: PUSH
101663: LD_INT 10
101665: PUSH
101666: LD_INT 20
101668: PUSH
101669: LD_INT 30
101671: PUSH
101672: LD_INT 40
101674: PUSH
101675: LD_INT 50
101677: PUSH
101678: LD_INT 60
101680: PUSH
101681: LD_INT 70
101683: PUSH
101684: LD_INT 80
101686: PUSH
101687: LD_INT 90
101689: PUSH
101690: LD_INT 100
101692: PUSH
101693: LD_INT 110
101695: PUSH
101696: LD_INT 120
101698: PUSH
101699: LD_INT 130
101701: PUSH
101702: LD_INT 140
101704: PUSH
101705: LD_INT 150
101707: PUSH
101708: EMPTY
101709: LIST
101710: LIST
101711: LIST
101712: LIST
101713: LIST
101714: LIST
101715: LIST
101716: LIST
101717: LIST
101718: LIST
101719: LIST
101720: LIST
101721: LIST
101722: LIST
101723: LIST
101724: PUSH
101725: LD_INT 1
101727: PPUSH
101728: LD_INT 15
101730: PPUSH
101731: CALL_OW 12
101735: ARRAY
101736: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
101737: LD_ADDR_VAR 0 4
101741: PUSH
101742: LD_INT 10
101744: PUSH
101745: LD_INT 20
101747: PUSH
101748: LD_INT 30
101750: PUSH
101751: LD_INT 40
101753: PUSH
101754: LD_INT 50
101756: PUSH
101757: LD_INT 60
101759: PUSH
101760: LD_INT 70
101762: PUSH
101763: LD_INT 80
101765: PUSH
101766: LD_INT 90
101768: PUSH
101769: LD_INT 100
101771: PUSH
101772: LD_INT 110
101774: PUSH
101775: LD_INT 120
101777: PUSH
101778: LD_INT 130
101780: PUSH
101781: LD_INT 140
101783: PUSH
101784: LD_INT 150
101786: PUSH
101787: EMPTY
101788: LIST
101789: LIST
101790: LIST
101791: LIST
101792: LIST
101793: LIST
101794: LIST
101795: LIST
101796: LIST
101797: LIST
101798: LIST
101799: LIST
101800: LIST
101801: LIST
101802: LIST
101803: PUSH
101804: LD_INT 1
101806: PPUSH
101807: LD_INT 15
101809: PPUSH
101810: CALL_OW 12
101814: ARRAY
101815: ST_TO_ADDR
// if ValidHex ( x , y ) then
101816: LD_VAR 0 3
101820: PPUSH
101821: LD_VAR 0 4
101825: PPUSH
101826: CALL_OW 488
101830: IFFALSE 101853
// begin result := [ x , y ] ;
101832: LD_ADDR_VAR 0 1
101836: PUSH
101837: LD_VAR 0 3
101841: PUSH
101842: LD_VAR 0 4
101846: PUSH
101847: EMPTY
101848: LIST
101849: LIST
101850: ST_TO_ADDR
// break ;
101851: GO 101855
// end ; end ;
101853: GO 101655
101855: POP
101856: POP
// if result then
101857: LD_VAR 0 1
101861: IFFALSE 101921
// begin ToLua ( playSibBomb() ) ;
101863: LD_STRING playSibBomb()
101865: PPUSH
101866: CALL_OW 559
// wait ( 0 0$14 ) ;
101870: LD_INT 490
101872: PPUSH
101873: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
101877: LD_VAR 0 1
101881: PUSH
101882: LD_INT 1
101884: ARRAY
101885: PPUSH
101886: LD_VAR 0 1
101890: PUSH
101891: LD_INT 2
101893: ARRAY
101894: PPUSH
101895: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
101899: LD_VAR 0 1
101903: PUSH
101904: LD_INT 1
101906: ARRAY
101907: PPUSH
101908: LD_VAR 0 1
101912: PUSH
101913: LD_INT 2
101915: ARRAY
101916: PPUSH
101917: CALL_OW 429
// end ; end ;
101921: LD_VAR 0 1
101925: RET
// every 0 0$1 trigger StreamModeActive and sReset do
101926: LD_EXP 99
101930: PUSH
101931: LD_EXP 121
101935: AND
101936: IFFALSE 101948
101938: GO 101940
101940: DISABLE
// YouLost (  ) ;
101941: LD_STRING 
101943: PPUSH
101944: CALL_OW 104
101948: END
// every 0 0$1 trigger StreamModeActive and sFog do
101949: LD_EXP 99
101953: PUSH
101954: LD_EXP 120
101958: AND
101959: IFFALSE 101973
101961: GO 101963
101963: DISABLE
// FogOff ( your_side ) ;
101964: LD_OWVAR 2
101968: PPUSH
101969: CALL_OW 344
101973: END
// every 0 0$1 trigger StreamModeActive and sSun do
101974: LD_EXP 99
101978: PUSH
101979: LD_EXP 122
101983: AND
101984: IFFALSE 102012
101986: GO 101988
101988: DISABLE
// begin solar_recharge_percent := 0 ;
101989: LD_ADDR_OWVAR 79
101993: PUSH
101994: LD_INT 0
101996: ST_TO_ADDR
// wait ( 5 5$00 ) ;
101997: LD_INT 10500
101999: PPUSH
102000: CALL_OW 67
// solar_recharge_percent := 100 ;
102004: LD_ADDR_OWVAR 79
102008: PUSH
102009: LD_INT 100
102011: ST_TO_ADDR
// end ;
102012: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102013: LD_EXP 99
102017: PUSH
102018: LD_EXP 123
102022: AND
102023: IFFALSE 102262
102025: GO 102027
102027: DISABLE
102028: LD_INT 0
102030: PPUSH
102031: PPUSH
102032: PPUSH
// begin tmp := [ ] ;
102033: LD_ADDR_VAR 0 3
102037: PUSH
102038: EMPTY
102039: ST_TO_ADDR
// for i := 1 to 6 do
102040: LD_ADDR_VAR 0 1
102044: PUSH
102045: DOUBLE
102046: LD_INT 1
102048: DEC
102049: ST_TO_ADDR
102050: LD_INT 6
102052: PUSH
102053: FOR_TO
102054: IFFALSE 102159
// begin uc_nation := nation_nature ;
102056: LD_ADDR_OWVAR 21
102060: PUSH
102061: LD_INT 0
102063: ST_TO_ADDR
// uc_side := 0 ;
102064: LD_ADDR_OWVAR 20
102068: PUSH
102069: LD_INT 0
102071: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102072: LD_ADDR_OWVAR 29
102076: PUSH
102077: LD_INT 12
102079: PUSH
102080: LD_INT 12
102082: PUSH
102083: EMPTY
102084: LIST
102085: LIST
102086: ST_TO_ADDR
// hc_agressivity := 20 ;
102087: LD_ADDR_OWVAR 35
102091: PUSH
102092: LD_INT 20
102094: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102095: LD_ADDR_OWVAR 28
102099: PUSH
102100: LD_INT 17
102102: ST_TO_ADDR
// hc_gallery :=  ;
102103: LD_ADDR_OWVAR 33
102107: PUSH
102108: LD_STRING 
102110: ST_TO_ADDR
// hc_name :=  ;
102111: LD_ADDR_OWVAR 26
102115: PUSH
102116: LD_STRING 
102118: ST_TO_ADDR
// un := CreateHuman ;
102119: LD_ADDR_VAR 0 2
102123: PUSH
102124: CALL_OW 44
102128: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102129: LD_VAR 0 2
102133: PPUSH
102134: LD_INT 1
102136: PPUSH
102137: CALL_OW 51
// tmp := tmp ^ un ;
102141: LD_ADDR_VAR 0 3
102145: PUSH
102146: LD_VAR 0 3
102150: PUSH
102151: LD_VAR 0 2
102155: ADD
102156: ST_TO_ADDR
// end ;
102157: GO 102053
102159: POP
102160: POP
// repeat wait ( 0 0$1 ) ;
102161: LD_INT 35
102163: PPUSH
102164: CALL_OW 67
// for un in tmp do
102168: LD_ADDR_VAR 0 2
102172: PUSH
102173: LD_VAR 0 3
102177: PUSH
102178: FOR_IN
102179: IFFALSE 102253
// begin if IsDead ( un ) then
102181: LD_VAR 0 2
102185: PPUSH
102186: CALL_OW 301
102190: IFFALSE 102210
// begin tmp := tmp diff un ;
102192: LD_ADDR_VAR 0 3
102196: PUSH
102197: LD_VAR 0 3
102201: PUSH
102202: LD_VAR 0 2
102206: DIFF
102207: ST_TO_ADDR
// continue ;
102208: GO 102178
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102210: LD_VAR 0 2
102214: PPUSH
102215: LD_INT 3
102217: PUSH
102218: LD_INT 22
102220: PUSH
102221: LD_INT 0
102223: PUSH
102224: EMPTY
102225: LIST
102226: LIST
102227: PUSH
102228: EMPTY
102229: LIST
102230: LIST
102231: PPUSH
102232: CALL_OW 69
102236: PPUSH
102237: LD_VAR 0 2
102241: PPUSH
102242: CALL_OW 74
102246: PPUSH
102247: CALL_OW 115
// end ;
102251: GO 102178
102253: POP
102254: POP
// until not tmp ;
102255: LD_VAR 0 3
102259: NOT
102260: IFFALSE 102161
// end ;
102262: PPOPN 3
102264: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102265: LD_EXP 99
102269: PUSH
102270: LD_EXP 124
102274: AND
102275: IFFALSE 102329
102277: GO 102279
102279: DISABLE
// begin ToLua ( displayTroll(); ) ;
102280: LD_STRING displayTroll();
102282: PPUSH
102283: CALL_OW 559
// wait ( 3 3$00 ) ;
102287: LD_INT 6300
102289: PPUSH
102290: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102294: LD_STRING hideTroll();
102296: PPUSH
102297: CALL_OW 559
// wait ( 1 1$00 ) ;
102301: LD_INT 2100
102303: PPUSH
102304: CALL_OW 67
// ToLua ( displayTroll(); ) ;
102308: LD_STRING displayTroll();
102310: PPUSH
102311: CALL_OW 559
// wait ( 1 1$00 ) ;
102315: LD_INT 2100
102317: PPUSH
102318: CALL_OW 67
// ToLua ( hideTroll(); ) ;
102322: LD_STRING hideTroll();
102324: PPUSH
102325: CALL_OW 559
// end ;
102329: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
102330: LD_EXP 99
102334: PUSH
102335: LD_EXP 125
102339: AND
102340: IFFALSE 102403
102342: GO 102344
102344: DISABLE
102345: LD_INT 0
102347: PPUSH
// begin p := 0 ;
102348: LD_ADDR_VAR 0 1
102352: PUSH
102353: LD_INT 0
102355: ST_TO_ADDR
// repeat game_speed := 1 ;
102356: LD_ADDR_OWVAR 65
102360: PUSH
102361: LD_INT 1
102363: ST_TO_ADDR
// wait ( 0 0$1 ) ;
102364: LD_INT 35
102366: PPUSH
102367: CALL_OW 67
// p := p + 1 ;
102371: LD_ADDR_VAR 0 1
102375: PUSH
102376: LD_VAR 0 1
102380: PUSH
102381: LD_INT 1
102383: PLUS
102384: ST_TO_ADDR
// until p >= 60 ;
102385: LD_VAR 0 1
102389: PUSH
102390: LD_INT 60
102392: GREATEREQUAL
102393: IFFALSE 102356
// game_speed := 4 ;
102395: LD_ADDR_OWVAR 65
102399: PUSH
102400: LD_INT 4
102402: ST_TO_ADDR
// end ;
102403: PPOPN 1
102405: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
102406: LD_EXP 99
102410: PUSH
102411: LD_EXP 126
102415: AND
102416: IFFALSE 102562
102418: GO 102420
102420: DISABLE
102421: LD_INT 0
102423: PPUSH
102424: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
102425: LD_ADDR_VAR 0 1
102429: PUSH
102430: LD_INT 22
102432: PUSH
102433: LD_OWVAR 2
102437: PUSH
102438: EMPTY
102439: LIST
102440: LIST
102441: PUSH
102442: LD_INT 2
102444: PUSH
102445: LD_INT 30
102447: PUSH
102448: LD_INT 0
102450: PUSH
102451: EMPTY
102452: LIST
102453: LIST
102454: PUSH
102455: LD_INT 30
102457: PUSH
102458: LD_INT 1
102460: PUSH
102461: EMPTY
102462: LIST
102463: LIST
102464: PUSH
102465: EMPTY
102466: LIST
102467: LIST
102468: LIST
102469: PUSH
102470: EMPTY
102471: LIST
102472: LIST
102473: PPUSH
102474: CALL_OW 69
102478: ST_TO_ADDR
// if not depot then
102479: LD_VAR 0 1
102483: NOT
102484: IFFALSE 102488
// exit ;
102486: GO 102562
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
102488: LD_ADDR_VAR 0 2
102492: PUSH
102493: LD_VAR 0 1
102497: PUSH
102498: LD_INT 1
102500: PPUSH
102501: LD_VAR 0 1
102505: PPUSH
102506: CALL_OW 12
102510: ARRAY
102511: PPUSH
102512: CALL_OW 274
102516: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
102517: LD_VAR 0 2
102521: PPUSH
102522: LD_INT 1
102524: PPUSH
102525: LD_INT 0
102527: PPUSH
102528: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
102532: LD_VAR 0 2
102536: PPUSH
102537: LD_INT 2
102539: PPUSH
102540: LD_INT 0
102542: PPUSH
102543: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
102547: LD_VAR 0 2
102551: PPUSH
102552: LD_INT 3
102554: PPUSH
102555: LD_INT 0
102557: PPUSH
102558: CALL_OW 277
// end ;
102562: PPOPN 2
102564: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
102565: LD_EXP 99
102569: PUSH
102570: LD_EXP 127
102574: AND
102575: IFFALSE 102672
102577: GO 102579
102579: DISABLE
102580: LD_INT 0
102582: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102583: LD_ADDR_VAR 0 1
102587: PUSH
102588: LD_INT 22
102590: PUSH
102591: LD_OWVAR 2
102595: PUSH
102596: EMPTY
102597: LIST
102598: LIST
102599: PUSH
102600: LD_INT 21
102602: PUSH
102603: LD_INT 1
102605: PUSH
102606: EMPTY
102607: LIST
102608: LIST
102609: PUSH
102610: LD_INT 3
102612: PUSH
102613: LD_INT 23
102615: PUSH
102616: LD_INT 0
102618: PUSH
102619: EMPTY
102620: LIST
102621: LIST
102622: PUSH
102623: EMPTY
102624: LIST
102625: LIST
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: LIST
102631: PPUSH
102632: CALL_OW 69
102636: ST_TO_ADDR
// if not tmp then
102637: LD_VAR 0 1
102641: NOT
102642: IFFALSE 102646
// exit ;
102644: GO 102672
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
102646: LD_VAR 0 1
102650: PUSH
102651: LD_INT 1
102653: PPUSH
102654: LD_VAR 0 1
102658: PPUSH
102659: CALL_OW 12
102663: ARRAY
102664: PPUSH
102665: LD_INT 200
102667: PPUSH
102668: CALL_OW 234
// end ;
102672: PPOPN 1
102674: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
102675: LD_EXP 99
102679: PUSH
102680: LD_EXP 128
102684: AND
102685: IFFALSE 102764
102687: GO 102689
102689: DISABLE
102690: LD_INT 0
102692: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
102693: LD_ADDR_VAR 0 1
102697: PUSH
102698: LD_INT 22
102700: PUSH
102701: LD_OWVAR 2
102705: PUSH
102706: EMPTY
102707: LIST
102708: LIST
102709: PUSH
102710: LD_INT 21
102712: PUSH
102713: LD_INT 2
102715: PUSH
102716: EMPTY
102717: LIST
102718: LIST
102719: PUSH
102720: EMPTY
102721: LIST
102722: LIST
102723: PPUSH
102724: CALL_OW 69
102728: ST_TO_ADDR
// if not tmp then
102729: LD_VAR 0 1
102733: NOT
102734: IFFALSE 102738
// exit ;
102736: GO 102764
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
102738: LD_VAR 0 1
102742: PUSH
102743: LD_INT 1
102745: PPUSH
102746: LD_VAR 0 1
102750: PPUSH
102751: CALL_OW 12
102755: ARRAY
102756: PPUSH
102757: LD_INT 60
102759: PPUSH
102760: CALL_OW 234
// end ;
102764: PPOPN 1
102766: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
102767: LD_EXP 99
102771: PUSH
102772: LD_EXP 129
102776: AND
102777: IFFALSE 102876
102779: GO 102781
102781: DISABLE
102782: LD_INT 0
102784: PPUSH
102785: PPUSH
// begin enable ;
102786: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
102787: LD_ADDR_VAR 0 1
102791: PUSH
102792: LD_INT 22
102794: PUSH
102795: LD_OWVAR 2
102799: PUSH
102800: EMPTY
102801: LIST
102802: LIST
102803: PUSH
102804: LD_INT 61
102806: PUSH
102807: EMPTY
102808: LIST
102809: PUSH
102810: LD_INT 33
102812: PUSH
102813: LD_INT 2
102815: PUSH
102816: EMPTY
102817: LIST
102818: LIST
102819: PUSH
102820: EMPTY
102821: LIST
102822: LIST
102823: LIST
102824: PPUSH
102825: CALL_OW 69
102829: ST_TO_ADDR
// if not tmp then
102830: LD_VAR 0 1
102834: NOT
102835: IFFALSE 102839
// exit ;
102837: GO 102876
// for i in tmp do
102839: LD_ADDR_VAR 0 2
102843: PUSH
102844: LD_VAR 0 1
102848: PUSH
102849: FOR_IN
102850: IFFALSE 102874
// if IsControledBy ( i ) then
102852: LD_VAR 0 2
102856: PPUSH
102857: CALL_OW 312
102861: IFFALSE 102872
// ComUnlink ( i ) ;
102863: LD_VAR 0 2
102867: PPUSH
102868: CALL_OW 136
102872: GO 102849
102874: POP
102875: POP
// end ;
102876: PPOPN 2
102878: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
102879: LD_EXP 99
102883: PUSH
102884: LD_EXP 130
102888: AND
102889: IFFALSE 103029
102891: GO 102893
102893: DISABLE
102894: LD_INT 0
102896: PPUSH
102897: PPUSH
// begin ToLua ( displayPowell(); ) ;
102898: LD_STRING displayPowell();
102900: PPUSH
102901: CALL_OW 559
// uc_side := 0 ;
102905: LD_ADDR_OWVAR 20
102909: PUSH
102910: LD_INT 0
102912: ST_TO_ADDR
// uc_nation := 2 ;
102913: LD_ADDR_OWVAR 21
102917: PUSH
102918: LD_INT 2
102920: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
102921: LD_ADDR_OWVAR 37
102925: PUSH
102926: LD_INT 14
102928: ST_TO_ADDR
// vc_engine := engine_siberite ;
102929: LD_ADDR_OWVAR 39
102933: PUSH
102934: LD_INT 3
102936: ST_TO_ADDR
// vc_control := control_apeman ;
102937: LD_ADDR_OWVAR 38
102941: PUSH
102942: LD_INT 5
102944: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
102945: LD_ADDR_OWVAR 40
102949: PUSH
102950: LD_INT 29
102952: ST_TO_ADDR
// un := CreateVehicle ;
102953: LD_ADDR_VAR 0 2
102957: PUSH
102958: CALL_OW 45
102962: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102963: LD_VAR 0 2
102967: PPUSH
102968: LD_INT 1
102970: PPUSH
102971: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102975: LD_INT 35
102977: PPUSH
102978: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102982: LD_VAR 0 2
102986: PPUSH
102987: LD_INT 22
102989: PUSH
102990: LD_OWVAR 2
102994: PUSH
102995: EMPTY
102996: LIST
102997: LIST
102998: PPUSH
102999: CALL_OW 69
103003: PPUSH
103004: LD_VAR 0 2
103008: PPUSH
103009: CALL_OW 74
103013: PPUSH
103014: CALL_OW 115
// until IsDead ( un ) ;
103018: LD_VAR 0 2
103022: PPUSH
103023: CALL_OW 301
103027: IFFALSE 102975
// end ;
103029: PPOPN 2
103031: END
// every 0 0$1 trigger StreamModeActive and sStu do
103032: LD_EXP 99
103036: PUSH
103037: LD_EXP 138
103041: AND
103042: IFFALSE 103058
103044: GO 103046
103046: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103047: LD_STRING displayStucuk();
103049: PPUSH
103050: CALL_OW 559
// ResetFog ;
103054: CALL_OW 335
// end ;
103058: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103059: LD_EXP 99
103063: PUSH
103064: LD_EXP 131
103068: AND
103069: IFFALSE 103210
103071: GO 103073
103073: DISABLE
103074: LD_INT 0
103076: PPUSH
103077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103078: LD_ADDR_VAR 0 2
103082: PUSH
103083: LD_INT 22
103085: PUSH
103086: LD_OWVAR 2
103090: PUSH
103091: EMPTY
103092: LIST
103093: LIST
103094: PUSH
103095: LD_INT 21
103097: PUSH
103098: LD_INT 1
103100: PUSH
103101: EMPTY
103102: LIST
103103: LIST
103104: PUSH
103105: EMPTY
103106: LIST
103107: LIST
103108: PPUSH
103109: CALL_OW 69
103113: ST_TO_ADDR
// if not tmp then
103114: LD_VAR 0 2
103118: NOT
103119: IFFALSE 103123
// exit ;
103121: GO 103210
// un := tmp [ rand ( 1 , tmp ) ] ;
103123: LD_ADDR_VAR 0 1
103127: PUSH
103128: LD_VAR 0 2
103132: PUSH
103133: LD_INT 1
103135: PPUSH
103136: LD_VAR 0 2
103140: PPUSH
103141: CALL_OW 12
103145: ARRAY
103146: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103147: LD_VAR 0 1
103151: PPUSH
103152: LD_INT 0
103154: PPUSH
103155: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103159: LD_VAR 0 1
103163: PPUSH
103164: LD_OWVAR 3
103168: PUSH
103169: LD_VAR 0 1
103173: DIFF
103174: PPUSH
103175: LD_VAR 0 1
103179: PPUSH
103180: CALL_OW 74
103184: PPUSH
103185: CALL_OW 115
// wait ( 0 0$20 ) ;
103189: LD_INT 700
103191: PPUSH
103192: CALL_OW 67
// SetSide ( un , your_side ) ;
103196: LD_VAR 0 1
103200: PPUSH
103201: LD_OWVAR 2
103205: PPUSH
103206: CALL_OW 235
// end ;
103210: PPOPN 2
103212: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103213: LD_EXP 99
103217: PUSH
103218: LD_EXP 132
103222: AND
103223: IFFALSE 103329
103225: GO 103227
103227: DISABLE
103228: LD_INT 0
103230: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103231: LD_ADDR_VAR 0 1
103235: PUSH
103236: LD_INT 22
103238: PUSH
103239: LD_OWVAR 2
103243: PUSH
103244: EMPTY
103245: LIST
103246: LIST
103247: PUSH
103248: LD_INT 2
103250: PUSH
103251: LD_INT 30
103253: PUSH
103254: LD_INT 0
103256: PUSH
103257: EMPTY
103258: LIST
103259: LIST
103260: PUSH
103261: LD_INT 30
103263: PUSH
103264: LD_INT 1
103266: PUSH
103267: EMPTY
103268: LIST
103269: LIST
103270: PUSH
103271: EMPTY
103272: LIST
103273: LIST
103274: LIST
103275: PUSH
103276: EMPTY
103277: LIST
103278: LIST
103279: PPUSH
103280: CALL_OW 69
103284: ST_TO_ADDR
// if not depot then
103285: LD_VAR 0 1
103289: NOT
103290: IFFALSE 103294
// exit ;
103292: GO 103329
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
103294: LD_VAR 0 1
103298: PUSH
103299: LD_INT 1
103301: ARRAY
103302: PPUSH
103303: CALL_OW 250
103307: PPUSH
103308: LD_VAR 0 1
103312: PUSH
103313: LD_INT 1
103315: ARRAY
103316: PPUSH
103317: CALL_OW 251
103321: PPUSH
103322: LD_INT 70
103324: PPUSH
103325: CALL_OW 495
// end ;
103329: PPOPN 1
103331: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
103332: LD_EXP 99
103336: PUSH
103337: LD_EXP 133
103341: AND
103342: IFFALSE 103553
103344: GO 103346
103346: DISABLE
103347: LD_INT 0
103349: PPUSH
103350: PPUSH
103351: PPUSH
103352: PPUSH
103353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103354: LD_ADDR_VAR 0 5
103358: PUSH
103359: LD_INT 22
103361: PUSH
103362: LD_OWVAR 2
103366: PUSH
103367: EMPTY
103368: LIST
103369: LIST
103370: PUSH
103371: LD_INT 21
103373: PUSH
103374: LD_INT 1
103376: PUSH
103377: EMPTY
103378: LIST
103379: LIST
103380: PUSH
103381: EMPTY
103382: LIST
103383: LIST
103384: PPUSH
103385: CALL_OW 69
103389: ST_TO_ADDR
// if not tmp then
103390: LD_VAR 0 5
103394: NOT
103395: IFFALSE 103399
// exit ;
103397: GO 103553
// for i in tmp do
103399: LD_ADDR_VAR 0 1
103403: PUSH
103404: LD_VAR 0 5
103408: PUSH
103409: FOR_IN
103410: IFFALSE 103551
// begin d := rand ( 0 , 5 ) ;
103412: LD_ADDR_VAR 0 4
103416: PUSH
103417: LD_INT 0
103419: PPUSH
103420: LD_INT 5
103422: PPUSH
103423: CALL_OW 12
103427: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
103428: LD_ADDR_VAR 0 2
103432: PUSH
103433: LD_VAR 0 1
103437: PPUSH
103438: CALL_OW 250
103442: PPUSH
103443: LD_VAR 0 4
103447: PPUSH
103448: LD_INT 3
103450: PPUSH
103451: LD_INT 12
103453: PPUSH
103454: CALL_OW 12
103458: PPUSH
103459: CALL_OW 272
103463: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
103464: LD_ADDR_VAR 0 3
103468: PUSH
103469: LD_VAR 0 1
103473: PPUSH
103474: CALL_OW 251
103478: PPUSH
103479: LD_VAR 0 4
103483: PPUSH
103484: LD_INT 3
103486: PPUSH
103487: LD_INT 12
103489: PPUSH
103490: CALL_OW 12
103494: PPUSH
103495: CALL_OW 273
103499: ST_TO_ADDR
// if ValidHex ( x , y ) then
103500: LD_VAR 0 2
103504: PPUSH
103505: LD_VAR 0 3
103509: PPUSH
103510: CALL_OW 488
103514: IFFALSE 103549
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
103516: LD_VAR 0 1
103520: PPUSH
103521: LD_VAR 0 2
103525: PPUSH
103526: LD_VAR 0 3
103530: PPUSH
103531: LD_INT 3
103533: PPUSH
103534: LD_INT 6
103536: PPUSH
103537: CALL_OW 12
103541: PPUSH
103542: LD_INT 1
103544: PPUSH
103545: CALL_OW 483
// end ;
103549: GO 103409
103551: POP
103552: POP
// end ;
103553: PPOPN 5
103555: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
103556: LD_EXP 99
103560: PUSH
103561: LD_EXP 134
103565: AND
103566: IFFALSE 103660
103568: GO 103570
103570: DISABLE
103571: LD_INT 0
103573: PPUSH
103574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
103575: LD_ADDR_VAR 0 2
103579: PUSH
103580: LD_INT 22
103582: PUSH
103583: LD_OWVAR 2
103587: PUSH
103588: EMPTY
103589: LIST
103590: LIST
103591: PUSH
103592: LD_INT 32
103594: PUSH
103595: LD_INT 1
103597: PUSH
103598: EMPTY
103599: LIST
103600: LIST
103601: PUSH
103602: LD_INT 21
103604: PUSH
103605: LD_INT 2
103607: PUSH
103608: EMPTY
103609: LIST
103610: LIST
103611: PUSH
103612: EMPTY
103613: LIST
103614: LIST
103615: LIST
103616: PPUSH
103617: CALL_OW 69
103621: ST_TO_ADDR
// if not tmp then
103622: LD_VAR 0 2
103626: NOT
103627: IFFALSE 103631
// exit ;
103629: GO 103660
// for i in tmp do
103631: LD_ADDR_VAR 0 1
103635: PUSH
103636: LD_VAR 0 2
103640: PUSH
103641: FOR_IN
103642: IFFALSE 103658
// SetFuel ( i , 0 ) ;
103644: LD_VAR 0 1
103648: PPUSH
103649: LD_INT 0
103651: PPUSH
103652: CALL_OW 240
103656: GO 103641
103658: POP
103659: POP
// end ;
103660: PPOPN 2
103662: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
103663: LD_EXP 99
103667: PUSH
103668: LD_EXP 135
103672: AND
103673: IFFALSE 103739
103675: GO 103677
103677: DISABLE
103678: LD_INT 0
103680: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103681: LD_ADDR_VAR 0 1
103685: PUSH
103686: LD_INT 22
103688: PUSH
103689: LD_OWVAR 2
103693: PUSH
103694: EMPTY
103695: LIST
103696: LIST
103697: PUSH
103698: LD_INT 30
103700: PUSH
103701: LD_INT 29
103703: PUSH
103704: EMPTY
103705: LIST
103706: LIST
103707: PUSH
103708: EMPTY
103709: LIST
103710: LIST
103711: PPUSH
103712: CALL_OW 69
103716: ST_TO_ADDR
// if not tmp then
103717: LD_VAR 0 1
103721: NOT
103722: IFFALSE 103726
// exit ;
103724: GO 103739
// DestroyUnit ( tmp [ 1 ] ) ;
103726: LD_VAR 0 1
103730: PUSH
103731: LD_INT 1
103733: ARRAY
103734: PPUSH
103735: CALL_OW 65
// end ;
103739: PPOPN 1
103741: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
103742: LD_EXP 99
103746: PUSH
103747: LD_EXP 137
103751: AND
103752: IFFALSE 103881
103754: GO 103756
103756: DISABLE
103757: LD_INT 0
103759: PPUSH
// begin uc_side := 0 ;
103760: LD_ADDR_OWVAR 20
103764: PUSH
103765: LD_INT 0
103767: ST_TO_ADDR
// uc_nation := nation_arabian ;
103768: LD_ADDR_OWVAR 21
103772: PUSH
103773: LD_INT 2
103775: ST_TO_ADDR
// hc_gallery :=  ;
103776: LD_ADDR_OWVAR 33
103780: PUSH
103781: LD_STRING 
103783: ST_TO_ADDR
// hc_name :=  ;
103784: LD_ADDR_OWVAR 26
103788: PUSH
103789: LD_STRING 
103791: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
103792: LD_INT 1
103794: PPUSH
103795: LD_INT 11
103797: PPUSH
103798: LD_INT 10
103800: PPUSH
103801: CALL_OW 380
// un := CreateHuman ;
103805: LD_ADDR_VAR 0 1
103809: PUSH
103810: CALL_OW 44
103814: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103815: LD_VAR 0 1
103819: PPUSH
103820: LD_INT 1
103822: PPUSH
103823: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103827: LD_INT 35
103829: PPUSH
103830: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103834: LD_VAR 0 1
103838: PPUSH
103839: LD_INT 22
103841: PUSH
103842: LD_OWVAR 2
103846: PUSH
103847: EMPTY
103848: LIST
103849: LIST
103850: PPUSH
103851: CALL_OW 69
103855: PPUSH
103856: LD_VAR 0 1
103860: PPUSH
103861: CALL_OW 74
103865: PPUSH
103866: CALL_OW 115
// until IsDead ( un ) ;
103870: LD_VAR 0 1
103874: PPUSH
103875: CALL_OW 301
103879: IFFALSE 103827
// end ;
103881: PPOPN 1
103883: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
103884: LD_EXP 99
103888: PUSH
103889: LD_EXP 139
103893: AND
103894: IFFALSE 103906
103896: GO 103898
103898: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
103899: LD_STRING earthquake(getX(game), 0, 32)
103901: PPUSH
103902: CALL_OW 559
103906: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
103907: LD_EXP 99
103911: PUSH
103912: LD_EXP 140
103916: AND
103917: IFFALSE 104008
103919: GO 103921
103921: DISABLE
103922: LD_INT 0
103924: PPUSH
// begin enable ;
103925: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
103926: LD_ADDR_VAR 0 1
103930: PUSH
103931: LD_INT 22
103933: PUSH
103934: LD_OWVAR 2
103938: PUSH
103939: EMPTY
103940: LIST
103941: LIST
103942: PUSH
103943: LD_INT 21
103945: PUSH
103946: LD_INT 2
103948: PUSH
103949: EMPTY
103950: LIST
103951: LIST
103952: PUSH
103953: LD_INT 33
103955: PUSH
103956: LD_INT 3
103958: PUSH
103959: EMPTY
103960: LIST
103961: LIST
103962: PUSH
103963: EMPTY
103964: LIST
103965: LIST
103966: LIST
103967: PPUSH
103968: CALL_OW 69
103972: ST_TO_ADDR
// if not tmp then
103973: LD_VAR 0 1
103977: NOT
103978: IFFALSE 103982
// exit ;
103980: GO 104008
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103982: LD_VAR 0 1
103986: PUSH
103987: LD_INT 1
103989: PPUSH
103990: LD_VAR 0 1
103994: PPUSH
103995: CALL_OW 12
103999: ARRAY
104000: PPUSH
104001: LD_INT 1
104003: PPUSH
104004: CALL_OW 234
// end ;
104008: PPOPN 1
104010: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104011: LD_EXP 99
104015: PUSH
104016: LD_EXP 141
104020: AND
104021: IFFALSE 104162
104023: GO 104025
104025: DISABLE
104026: LD_INT 0
104028: PPUSH
104029: PPUSH
104030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104031: LD_ADDR_VAR 0 3
104035: PUSH
104036: LD_INT 22
104038: PUSH
104039: LD_OWVAR 2
104043: PUSH
104044: EMPTY
104045: LIST
104046: LIST
104047: PUSH
104048: LD_INT 25
104050: PUSH
104051: LD_INT 1
104053: PUSH
104054: EMPTY
104055: LIST
104056: LIST
104057: PUSH
104058: EMPTY
104059: LIST
104060: LIST
104061: PPUSH
104062: CALL_OW 69
104066: ST_TO_ADDR
// if not tmp then
104067: LD_VAR 0 3
104071: NOT
104072: IFFALSE 104076
// exit ;
104074: GO 104162
// un := tmp [ rand ( 1 , tmp ) ] ;
104076: LD_ADDR_VAR 0 2
104080: PUSH
104081: LD_VAR 0 3
104085: PUSH
104086: LD_INT 1
104088: PPUSH
104089: LD_VAR 0 3
104093: PPUSH
104094: CALL_OW 12
104098: ARRAY
104099: ST_TO_ADDR
// if Crawls ( un ) then
104100: LD_VAR 0 2
104104: PPUSH
104105: CALL_OW 318
104109: IFFALSE 104120
// ComWalk ( un ) ;
104111: LD_VAR 0 2
104115: PPUSH
104116: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104120: LD_VAR 0 2
104124: PPUSH
104125: LD_INT 9
104127: PPUSH
104128: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104132: LD_INT 28
104134: PPUSH
104135: LD_OWVAR 2
104139: PPUSH
104140: LD_INT 2
104142: PPUSH
104143: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104147: LD_INT 29
104149: PPUSH
104150: LD_OWVAR 2
104154: PPUSH
104155: LD_INT 2
104157: PPUSH
104158: CALL_OW 322
// end ;
104162: PPOPN 3
104164: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104165: LD_EXP 99
104169: PUSH
104170: LD_EXP 142
104174: AND
104175: IFFALSE 104286
104177: GO 104179
104179: DISABLE
104180: LD_INT 0
104182: PPUSH
104183: PPUSH
104184: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104185: LD_ADDR_VAR 0 3
104189: PUSH
104190: LD_INT 22
104192: PUSH
104193: LD_OWVAR 2
104197: PUSH
104198: EMPTY
104199: LIST
104200: LIST
104201: PUSH
104202: LD_INT 25
104204: PUSH
104205: LD_INT 1
104207: PUSH
104208: EMPTY
104209: LIST
104210: LIST
104211: PUSH
104212: EMPTY
104213: LIST
104214: LIST
104215: PPUSH
104216: CALL_OW 69
104220: ST_TO_ADDR
// if not tmp then
104221: LD_VAR 0 3
104225: NOT
104226: IFFALSE 104230
// exit ;
104228: GO 104286
// un := tmp [ rand ( 1 , tmp ) ] ;
104230: LD_ADDR_VAR 0 2
104234: PUSH
104235: LD_VAR 0 3
104239: PUSH
104240: LD_INT 1
104242: PPUSH
104243: LD_VAR 0 3
104247: PPUSH
104248: CALL_OW 12
104252: ARRAY
104253: ST_TO_ADDR
// if Crawls ( un ) then
104254: LD_VAR 0 2
104258: PPUSH
104259: CALL_OW 318
104263: IFFALSE 104274
// ComWalk ( un ) ;
104265: LD_VAR 0 2
104269: PPUSH
104270: CALL_OW 138
// SetClass ( un , class_mortar ) ;
104274: LD_VAR 0 2
104278: PPUSH
104279: LD_INT 8
104281: PPUSH
104282: CALL_OW 336
// end ;
104286: PPOPN 3
104288: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
104289: LD_EXP 99
104293: PUSH
104294: LD_EXP 143
104298: AND
104299: IFFALSE 104443
104301: GO 104303
104303: DISABLE
104304: LD_INT 0
104306: PPUSH
104307: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
104308: LD_ADDR_VAR 0 2
104312: PUSH
104313: LD_INT 22
104315: PUSH
104316: LD_OWVAR 2
104320: PUSH
104321: EMPTY
104322: LIST
104323: LIST
104324: PUSH
104325: LD_INT 21
104327: PUSH
104328: LD_INT 2
104330: PUSH
104331: EMPTY
104332: LIST
104333: LIST
104334: PUSH
104335: LD_INT 2
104337: PUSH
104338: LD_INT 34
104340: PUSH
104341: LD_INT 12
104343: PUSH
104344: EMPTY
104345: LIST
104346: LIST
104347: PUSH
104348: LD_INT 34
104350: PUSH
104351: LD_INT 51
104353: PUSH
104354: EMPTY
104355: LIST
104356: LIST
104357: PUSH
104358: LD_INT 34
104360: PUSH
104361: LD_INT 32
104363: PUSH
104364: EMPTY
104365: LIST
104366: LIST
104367: PUSH
104368: EMPTY
104369: LIST
104370: LIST
104371: LIST
104372: LIST
104373: PUSH
104374: EMPTY
104375: LIST
104376: LIST
104377: LIST
104378: PPUSH
104379: CALL_OW 69
104383: ST_TO_ADDR
// if not tmp then
104384: LD_VAR 0 2
104388: NOT
104389: IFFALSE 104393
// exit ;
104391: GO 104443
// for i in tmp do
104393: LD_ADDR_VAR 0 1
104397: PUSH
104398: LD_VAR 0 2
104402: PUSH
104403: FOR_IN
104404: IFFALSE 104441
// if GetCargo ( i , mat_artifact ) = 0 then
104406: LD_VAR 0 1
104410: PPUSH
104411: LD_INT 4
104413: PPUSH
104414: CALL_OW 289
104418: PUSH
104419: LD_INT 0
104421: EQUAL
104422: IFFALSE 104439
// SetCargo ( i , mat_siberit , 100 ) ;
104424: LD_VAR 0 1
104428: PPUSH
104429: LD_INT 3
104431: PPUSH
104432: LD_INT 100
104434: PPUSH
104435: CALL_OW 290
104439: GO 104403
104441: POP
104442: POP
// end ;
104443: PPOPN 2
104445: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
104446: LD_EXP 99
104450: PUSH
104451: LD_EXP 144
104455: AND
104456: IFFALSE 104639
104458: GO 104460
104460: DISABLE
104461: LD_INT 0
104463: PPUSH
104464: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104465: LD_ADDR_VAR 0 2
104469: PUSH
104470: LD_INT 22
104472: PUSH
104473: LD_OWVAR 2
104477: PUSH
104478: EMPTY
104479: LIST
104480: LIST
104481: PPUSH
104482: CALL_OW 69
104486: ST_TO_ADDR
// if not tmp then
104487: LD_VAR 0 2
104491: NOT
104492: IFFALSE 104496
// exit ;
104494: GO 104639
// for i := 1 to 2 do
104496: LD_ADDR_VAR 0 1
104500: PUSH
104501: DOUBLE
104502: LD_INT 1
104504: DEC
104505: ST_TO_ADDR
104506: LD_INT 2
104508: PUSH
104509: FOR_TO
104510: IFFALSE 104637
// begin uc_side := your_side ;
104512: LD_ADDR_OWVAR 20
104516: PUSH
104517: LD_OWVAR 2
104521: ST_TO_ADDR
// uc_nation := nation_american ;
104522: LD_ADDR_OWVAR 21
104526: PUSH
104527: LD_INT 1
104529: ST_TO_ADDR
// vc_chassis := us_morphling ;
104530: LD_ADDR_OWVAR 37
104534: PUSH
104535: LD_INT 5
104537: ST_TO_ADDR
// vc_engine := engine_siberite ;
104538: LD_ADDR_OWVAR 39
104542: PUSH
104543: LD_INT 3
104545: ST_TO_ADDR
// vc_control := control_computer ;
104546: LD_ADDR_OWVAR 38
104550: PUSH
104551: LD_INT 3
104553: ST_TO_ADDR
// vc_weapon := us_double_laser ;
104554: LD_ADDR_OWVAR 40
104558: PUSH
104559: LD_INT 10
104561: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
104562: LD_VAR 0 2
104566: PUSH
104567: LD_INT 1
104569: ARRAY
104570: PPUSH
104571: CALL_OW 310
104575: NOT
104576: IFFALSE 104623
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
104578: CALL_OW 45
104582: PPUSH
104583: LD_VAR 0 2
104587: PUSH
104588: LD_INT 1
104590: ARRAY
104591: PPUSH
104592: CALL_OW 250
104596: PPUSH
104597: LD_VAR 0 2
104601: PUSH
104602: LD_INT 1
104604: ARRAY
104605: PPUSH
104606: CALL_OW 251
104610: PPUSH
104611: LD_INT 12
104613: PPUSH
104614: LD_INT 1
104616: PPUSH
104617: CALL_OW 50
104621: GO 104635
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
104623: CALL_OW 45
104627: PPUSH
104628: LD_INT 1
104630: PPUSH
104631: CALL_OW 51
// end ;
104635: GO 104509
104637: POP
104638: POP
// end ;
104639: PPOPN 2
104641: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
104642: LD_EXP 99
104646: PUSH
104647: LD_EXP 145
104651: AND
104652: IFFALSE 104874
104654: GO 104656
104656: DISABLE
104657: LD_INT 0
104659: PPUSH
104660: PPUSH
104661: PPUSH
104662: PPUSH
104663: PPUSH
104664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104665: LD_ADDR_VAR 0 6
104669: PUSH
104670: LD_INT 22
104672: PUSH
104673: LD_OWVAR 2
104677: PUSH
104678: EMPTY
104679: LIST
104680: LIST
104681: PUSH
104682: LD_INT 21
104684: PUSH
104685: LD_INT 1
104687: PUSH
104688: EMPTY
104689: LIST
104690: LIST
104691: PUSH
104692: LD_INT 3
104694: PUSH
104695: LD_INT 23
104697: PUSH
104698: LD_INT 0
104700: PUSH
104701: EMPTY
104702: LIST
104703: LIST
104704: PUSH
104705: EMPTY
104706: LIST
104707: LIST
104708: PUSH
104709: EMPTY
104710: LIST
104711: LIST
104712: LIST
104713: PPUSH
104714: CALL_OW 69
104718: ST_TO_ADDR
// if not tmp then
104719: LD_VAR 0 6
104723: NOT
104724: IFFALSE 104728
// exit ;
104726: GO 104874
// s1 := rand ( 1 , 4 ) ;
104728: LD_ADDR_VAR 0 2
104732: PUSH
104733: LD_INT 1
104735: PPUSH
104736: LD_INT 4
104738: PPUSH
104739: CALL_OW 12
104743: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
104744: LD_ADDR_VAR 0 4
104748: PUSH
104749: LD_VAR 0 6
104753: PUSH
104754: LD_INT 1
104756: ARRAY
104757: PPUSH
104758: LD_VAR 0 2
104762: PPUSH
104763: CALL_OW 259
104767: ST_TO_ADDR
// if s1 = 1 then
104768: LD_VAR 0 2
104772: PUSH
104773: LD_INT 1
104775: EQUAL
104776: IFFALSE 104796
// s2 := rand ( 2 , 4 ) else
104778: LD_ADDR_VAR 0 3
104782: PUSH
104783: LD_INT 2
104785: PPUSH
104786: LD_INT 4
104788: PPUSH
104789: CALL_OW 12
104793: ST_TO_ADDR
104794: GO 104804
// s2 := 1 ;
104796: LD_ADDR_VAR 0 3
104800: PUSH
104801: LD_INT 1
104803: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
104804: LD_ADDR_VAR 0 5
104808: PUSH
104809: LD_VAR 0 6
104813: PUSH
104814: LD_INT 1
104816: ARRAY
104817: PPUSH
104818: LD_VAR 0 3
104822: PPUSH
104823: CALL_OW 259
104827: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
104828: LD_VAR 0 6
104832: PUSH
104833: LD_INT 1
104835: ARRAY
104836: PPUSH
104837: LD_VAR 0 2
104841: PPUSH
104842: LD_VAR 0 5
104846: PPUSH
104847: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
104851: LD_VAR 0 6
104855: PUSH
104856: LD_INT 1
104858: ARRAY
104859: PPUSH
104860: LD_VAR 0 3
104864: PPUSH
104865: LD_VAR 0 4
104869: PPUSH
104870: CALL_OW 237
// end ;
104874: PPOPN 6
104876: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
104877: LD_EXP 99
104881: PUSH
104882: LD_EXP 146
104886: AND
104887: IFFALSE 104966
104889: GO 104891
104891: DISABLE
104892: LD_INT 0
104894: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
104895: LD_ADDR_VAR 0 1
104899: PUSH
104900: LD_INT 22
104902: PUSH
104903: LD_OWVAR 2
104907: PUSH
104908: EMPTY
104909: LIST
104910: LIST
104911: PUSH
104912: LD_INT 30
104914: PUSH
104915: LD_INT 3
104917: PUSH
104918: EMPTY
104919: LIST
104920: LIST
104921: PUSH
104922: EMPTY
104923: LIST
104924: LIST
104925: PPUSH
104926: CALL_OW 69
104930: ST_TO_ADDR
// if not tmp then
104931: LD_VAR 0 1
104935: NOT
104936: IFFALSE 104940
// exit ;
104938: GO 104966
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104940: LD_VAR 0 1
104944: PUSH
104945: LD_INT 1
104947: PPUSH
104948: LD_VAR 0 1
104952: PPUSH
104953: CALL_OW 12
104957: ARRAY
104958: PPUSH
104959: LD_INT 1
104961: PPUSH
104962: CALL_OW 234
// end ;
104966: PPOPN 1
104968: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
104969: LD_EXP 99
104973: PUSH
104974: LD_EXP 147
104978: AND
104979: IFFALSE 105091
104981: GO 104983
104983: DISABLE
104984: LD_INT 0
104986: PPUSH
104987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
104988: LD_ADDR_VAR 0 2
104992: PUSH
104993: LD_INT 22
104995: PUSH
104996: LD_OWVAR 2
105000: PUSH
105001: EMPTY
105002: LIST
105003: LIST
105004: PUSH
105005: LD_INT 2
105007: PUSH
105008: LD_INT 30
105010: PUSH
105011: LD_INT 27
105013: PUSH
105014: EMPTY
105015: LIST
105016: LIST
105017: PUSH
105018: LD_INT 30
105020: PUSH
105021: LD_INT 26
105023: PUSH
105024: EMPTY
105025: LIST
105026: LIST
105027: PUSH
105028: LD_INT 30
105030: PUSH
105031: LD_INT 28
105033: PUSH
105034: EMPTY
105035: LIST
105036: LIST
105037: PUSH
105038: EMPTY
105039: LIST
105040: LIST
105041: LIST
105042: LIST
105043: PUSH
105044: EMPTY
105045: LIST
105046: LIST
105047: PPUSH
105048: CALL_OW 69
105052: ST_TO_ADDR
// if not tmp then
105053: LD_VAR 0 2
105057: NOT
105058: IFFALSE 105062
// exit ;
105060: GO 105091
// for i in tmp do
105062: LD_ADDR_VAR 0 1
105066: PUSH
105067: LD_VAR 0 2
105071: PUSH
105072: FOR_IN
105073: IFFALSE 105089
// SetLives ( i , 1 ) ;
105075: LD_VAR 0 1
105079: PPUSH
105080: LD_INT 1
105082: PPUSH
105083: CALL_OW 234
105087: GO 105072
105089: POP
105090: POP
// end ;
105091: PPOPN 2
105093: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105094: LD_EXP 99
105098: PUSH
105099: LD_EXP 148
105103: AND
105104: IFFALSE 105391
105106: GO 105108
105108: DISABLE
105109: LD_INT 0
105111: PPUSH
105112: PPUSH
105113: PPUSH
// begin i := rand ( 1 , 7 ) ;
105114: LD_ADDR_VAR 0 1
105118: PUSH
105119: LD_INT 1
105121: PPUSH
105122: LD_INT 7
105124: PPUSH
105125: CALL_OW 12
105129: ST_TO_ADDR
// case i of 1 :
105130: LD_VAR 0 1
105134: PUSH
105135: LD_INT 1
105137: DOUBLE
105138: EQUAL
105139: IFTRUE 105143
105141: GO 105153
105143: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105144: LD_STRING earthquake(getX(game), 0, 32)
105146: PPUSH
105147: CALL_OW 559
105151: GO 105391
105153: LD_INT 2
105155: DOUBLE
105156: EQUAL
105157: IFTRUE 105161
105159: GO 105175
105161: POP
// begin ToLua ( displayStucuk(); ) ;
105162: LD_STRING displayStucuk();
105164: PPUSH
105165: CALL_OW 559
// ResetFog ;
105169: CALL_OW 335
// end ; 3 :
105173: GO 105391
105175: LD_INT 3
105177: DOUBLE
105178: EQUAL
105179: IFTRUE 105183
105181: GO 105287
105183: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105184: LD_ADDR_VAR 0 2
105188: PUSH
105189: LD_INT 22
105191: PUSH
105192: LD_OWVAR 2
105196: PUSH
105197: EMPTY
105198: LIST
105199: LIST
105200: PUSH
105201: LD_INT 25
105203: PUSH
105204: LD_INT 1
105206: PUSH
105207: EMPTY
105208: LIST
105209: LIST
105210: PUSH
105211: EMPTY
105212: LIST
105213: LIST
105214: PPUSH
105215: CALL_OW 69
105219: ST_TO_ADDR
// if not tmp then
105220: LD_VAR 0 2
105224: NOT
105225: IFFALSE 105229
// exit ;
105227: GO 105391
// un := tmp [ rand ( 1 , tmp ) ] ;
105229: LD_ADDR_VAR 0 3
105233: PUSH
105234: LD_VAR 0 2
105238: PUSH
105239: LD_INT 1
105241: PPUSH
105242: LD_VAR 0 2
105246: PPUSH
105247: CALL_OW 12
105251: ARRAY
105252: ST_TO_ADDR
// if Crawls ( un ) then
105253: LD_VAR 0 3
105257: PPUSH
105258: CALL_OW 318
105262: IFFALSE 105273
// ComWalk ( un ) ;
105264: LD_VAR 0 3
105268: PPUSH
105269: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105273: LD_VAR 0 3
105277: PPUSH
105278: LD_INT 8
105280: PPUSH
105281: CALL_OW 336
// end ; 4 :
105285: GO 105391
105287: LD_INT 4
105289: DOUBLE
105290: EQUAL
105291: IFTRUE 105295
105293: GO 105369
105295: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
105296: LD_ADDR_VAR 0 2
105300: PUSH
105301: LD_INT 22
105303: PUSH
105304: LD_OWVAR 2
105308: PUSH
105309: EMPTY
105310: LIST
105311: LIST
105312: PUSH
105313: LD_INT 30
105315: PUSH
105316: LD_INT 29
105318: PUSH
105319: EMPTY
105320: LIST
105321: LIST
105322: PUSH
105323: EMPTY
105324: LIST
105325: LIST
105326: PPUSH
105327: CALL_OW 69
105331: ST_TO_ADDR
// if not tmp then
105332: LD_VAR 0 2
105336: NOT
105337: IFFALSE 105341
// exit ;
105339: GO 105391
// CenterNowOnUnits ( tmp [ 1 ] ) ;
105341: LD_VAR 0 2
105345: PUSH
105346: LD_INT 1
105348: ARRAY
105349: PPUSH
105350: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
105354: LD_VAR 0 2
105358: PUSH
105359: LD_INT 1
105361: ARRAY
105362: PPUSH
105363: CALL_OW 65
// end ; 5 .. 7 :
105367: GO 105391
105369: LD_INT 5
105371: DOUBLE
105372: GREATEREQUAL
105373: IFFALSE 105381
105375: LD_INT 7
105377: DOUBLE
105378: LESSEQUAL
105379: IFTRUE 105383
105381: GO 105390
105383: POP
// StreamSibBomb ; end ;
105384: CALL 101628 0 0
105388: GO 105391
105390: POP
// end ;
105391: PPOPN 3
105393: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
105394: LD_EXP 99
105398: PUSH
105399: LD_EXP 149
105403: AND
105404: IFFALSE 105560
105406: GO 105408
105408: DISABLE
105409: LD_INT 0
105411: PPUSH
105412: PPUSH
105413: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
105414: LD_ADDR_VAR 0 2
105418: PUSH
105419: LD_INT 81
105421: PUSH
105422: LD_OWVAR 2
105426: PUSH
105427: EMPTY
105428: LIST
105429: LIST
105430: PUSH
105431: LD_INT 2
105433: PUSH
105434: LD_INT 21
105436: PUSH
105437: LD_INT 1
105439: PUSH
105440: EMPTY
105441: LIST
105442: LIST
105443: PUSH
105444: LD_INT 21
105446: PUSH
105447: LD_INT 2
105449: PUSH
105450: EMPTY
105451: LIST
105452: LIST
105453: PUSH
105454: EMPTY
105455: LIST
105456: LIST
105457: LIST
105458: PUSH
105459: EMPTY
105460: LIST
105461: LIST
105462: PPUSH
105463: CALL_OW 69
105467: ST_TO_ADDR
// if not tmp then
105468: LD_VAR 0 2
105472: NOT
105473: IFFALSE 105477
// exit ;
105475: GO 105560
// p := 0 ;
105477: LD_ADDR_VAR 0 3
105481: PUSH
105482: LD_INT 0
105484: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105485: LD_INT 35
105487: PPUSH
105488: CALL_OW 67
// p := p + 1 ;
105492: LD_ADDR_VAR 0 3
105496: PUSH
105497: LD_VAR 0 3
105501: PUSH
105502: LD_INT 1
105504: PLUS
105505: ST_TO_ADDR
// for i in tmp do
105506: LD_ADDR_VAR 0 1
105510: PUSH
105511: LD_VAR 0 2
105515: PUSH
105516: FOR_IN
105517: IFFALSE 105548
// if GetLives ( i ) < 1000 then
105519: LD_VAR 0 1
105523: PPUSH
105524: CALL_OW 256
105528: PUSH
105529: LD_INT 1000
105531: LESS
105532: IFFALSE 105546
// SetLives ( i , 1000 ) ;
105534: LD_VAR 0 1
105538: PPUSH
105539: LD_INT 1000
105541: PPUSH
105542: CALL_OW 234
105546: GO 105516
105548: POP
105549: POP
// until p > 20 ;
105550: LD_VAR 0 3
105554: PUSH
105555: LD_INT 20
105557: GREATER
105558: IFFALSE 105485
// end ;
105560: PPOPN 3
105562: END
// every 0 0$1 trigger StreamModeActive and sTime do
105563: LD_EXP 99
105567: PUSH
105568: LD_EXP 150
105572: AND
105573: IFFALSE 105608
105575: GO 105577
105577: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
105578: LD_INT 28
105580: PPUSH
105581: LD_OWVAR 2
105585: PPUSH
105586: LD_INT 2
105588: PPUSH
105589: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
105593: LD_INT 30
105595: PPUSH
105596: LD_OWVAR 2
105600: PPUSH
105601: LD_INT 2
105603: PPUSH
105604: CALL_OW 322
// end ;
105608: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
105609: LD_EXP 99
105613: PUSH
105614: LD_EXP 151
105618: AND
105619: IFFALSE 105740
105621: GO 105623
105623: DISABLE
105624: LD_INT 0
105626: PPUSH
105627: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105628: LD_ADDR_VAR 0 2
105632: PUSH
105633: LD_INT 22
105635: PUSH
105636: LD_OWVAR 2
105640: PUSH
105641: EMPTY
105642: LIST
105643: LIST
105644: PUSH
105645: LD_INT 21
105647: PUSH
105648: LD_INT 1
105650: PUSH
105651: EMPTY
105652: LIST
105653: LIST
105654: PUSH
105655: LD_INT 3
105657: PUSH
105658: LD_INT 23
105660: PUSH
105661: LD_INT 0
105663: PUSH
105664: EMPTY
105665: LIST
105666: LIST
105667: PUSH
105668: EMPTY
105669: LIST
105670: LIST
105671: PUSH
105672: EMPTY
105673: LIST
105674: LIST
105675: LIST
105676: PPUSH
105677: CALL_OW 69
105681: ST_TO_ADDR
// if not tmp then
105682: LD_VAR 0 2
105686: NOT
105687: IFFALSE 105691
// exit ;
105689: GO 105740
// for i in tmp do
105691: LD_ADDR_VAR 0 1
105695: PUSH
105696: LD_VAR 0 2
105700: PUSH
105701: FOR_IN
105702: IFFALSE 105738
// begin if Crawls ( i ) then
105704: LD_VAR 0 1
105708: PPUSH
105709: CALL_OW 318
105713: IFFALSE 105724
// ComWalk ( i ) ;
105715: LD_VAR 0 1
105719: PPUSH
105720: CALL_OW 138
// SetClass ( i , 2 ) ;
105724: LD_VAR 0 1
105728: PPUSH
105729: LD_INT 2
105731: PPUSH
105732: CALL_OW 336
// end ;
105736: GO 105701
105738: POP
105739: POP
// end ;
105740: PPOPN 2
105742: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
105743: LD_EXP 99
105747: PUSH
105748: LD_EXP 152
105752: AND
105753: IFFALSE 106041
105755: GO 105757
105757: DISABLE
105758: LD_INT 0
105760: PPUSH
105761: PPUSH
105762: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
105763: LD_OWVAR 2
105767: PPUSH
105768: LD_INT 9
105770: PPUSH
105771: LD_INT 1
105773: PPUSH
105774: LD_INT 1
105776: PPUSH
105777: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
105781: LD_INT 9
105783: PPUSH
105784: LD_OWVAR 2
105788: PPUSH
105789: CALL_OW 343
// uc_side := 9 ;
105793: LD_ADDR_OWVAR 20
105797: PUSH
105798: LD_INT 9
105800: ST_TO_ADDR
// uc_nation := 2 ;
105801: LD_ADDR_OWVAR 21
105805: PUSH
105806: LD_INT 2
105808: ST_TO_ADDR
// hc_name := Dark Warrior ;
105809: LD_ADDR_OWVAR 26
105813: PUSH
105814: LD_STRING Dark Warrior
105816: ST_TO_ADDR
// hc_gallery :=  ;
105817: LD_ADDR_OWVAR 33
105821: PUSH
105822: LD_STRING 
105824: ST_TO_ADDR
// hc_noskilllimit := true ;
105825: LD_ADDR_OWVAR 76
105829: PUSH
105830: LD_INT 1
105832: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
105833: LD_ADDR_OWVAR 31
105837: PUSH
105838: LD_INT 30
105840: PUSH
105841: LD_INT 30
105843: PUSH
105844: LD_INT 30
105846: PUSH
105847: LD_INT 30
105849: PUSH
105850: EMPTY
105851: LIST
105852: LIST
105853: LIST
105854: LIST
105855: ST_TO_ADDR
// un := CreateHuman ;
105856: LD_ADDR_VAR 0 3
105860: PUSH
105861: CALL_OW 44
105865: ST_TO_ADDR
// hc_noskilllimit := false ;
105866: LD_ADDR_OWVAR 76
105870: PUSH
105871: LD_INT 0
105873: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105874: LD_VAR 0 3
105878: PPUSH
105879: LD_INT 1
105881: PPUSH
105882: CALL_OW 51
// ToLua ( playRanger() ) ;
105886: LD_STRING playRanger()
105888: PPUSH
105889: CALL_OW 559
// p := 0 ;
105893: LD_ADDR_VAR 0 2
105897: PUSH
105898: LD_INT 0
105900: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
105901: LD_INT 35
105903: PPUSH
105904: CALL_OW 67
// p := p + 1 ;
105908: LD_ADDR_VAR 0 2
105912: PUSH
105913: LD_VAR 0 2
105917: PUSH
105918: LD_INT 1
105920: PLUS
105921: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
105922: LD_VAR 0 3
105926: PPUSH
105927: CALL_OW 256
105931: PUSH
105932: LD_INT 1000
105934: LESS
105935: IFFALSE 105949
// SetLives ( un , 1000 ) ;
105937: LD_VAR 0 3
105941: PPUSH
105942: LD_INT 1000
105944: PPUSH
105945: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
105949: LD_VAR 0 3
105953: PPUSH
105954: LD_INT 81
105956: PUSH
105957: LD_OWVAR 2
105961: PUSH
105962: EMPTY
105963: LIST
105964: LIST
105965: PUSH
105966: LD_INT 91
105968: PUSH
105969: LD_VAR 0 3
105973: PUSH
105974: LD_INT 30
105976: PUSH
105977: EMPTY
105978: LIST
105979: LIST
105980: LIST
105981: PUSH
105982: EMPTY
105983: LIST
105984: LIST
105985: PPUSH
105986: CALL_OW 69
105990: PPUSH
105991: LD_VAR 0 3
105995: PPUSH
105996: CALL_OW 74
106000: PPUSH
106001: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106005: LD_VAR 0 2
106009: PUSH
106010: LD_INT 80
106012: GREATER
106013: PUSH
106014: LD_VAR 0 3
106018: PPUSH
106019: CALL_OW 301
106023: OR
106024: IFFALSE 105901
// if un then
106026: LD_VAR 0 3
106030: IFFALSE 106041
// RemoveUnit ( un ) ;
106032: LD_VAR 0 3
106036: PPUSH
106037: CALL_OW 64
// end ;
106041: PPOPN 3
106043: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106044: LD_EXP 153
106048: IFFALSE 106164
106050: GO 106052
106052: DISABLE
106053: LD_INT 0
106055: PPUSH
106056: PPUSH
106057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106058: LD_ADDR_VAR 0 2
106062: PUSH
106063: LD_INT 81
106065: PUSH
106066: LD_OWVAR 2
106070: PUSH
106071: EMPTY
106072: LIST
106073: LIST
106074: PUSH
106075: LD_INT 21
106077: PUSH
106078: LD_INT 1
106080: PUSH
106081: EMPTY
106082: LIST
106083: LIST
106084: PUSH
106085: EMPTY
106086: LIST
106087: LIST
106088: PPUSH
106089: CALL_OW 69
106093: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106094: LD_STRING playComputer()
106096: PPUSH
106097: CALL_OW 559
// if not tmp then
106101: LD_VAR 0 2
106105: NOT
106106: IFFALSE 106110
// exit ;
106108: GO 106164
// for i in tmp do
106110: LD_ADDR_VAR 0 1
106114: PUSH
106115: LD_VAR 0 2
106119: PUSH
106120: FOR_IN
106121: IFFALSE 106162
// for j := 1 to 4 do
106123: LD_ADDR_VAR 0 3
106127: PUSH
106128: DOUBLE
106129: LD_INT 1
106131: DEC
106132: ST_TO_ADDR
106133: LD_INT 4
106135: PUSH
106136: FOR_TO
106137: IFFALSE 106158
// SetSkill ( i , j , 10 ) ;
106139: LD_VAR 0 1
106143: PPUSH
106144: LD_VAR 0 3
106148: PPUSH
106149: LD_INT 10
106151: PPUSH
106152: CALL_OW 237
106156: GO 106136
106158: POP
106159: POP
106160: GO 106120
106162: POP
106163: POP
// end ;
106164: PPOPN 3
106166: END
// every 0 0$1 trigger s30 do var i , tmp ;
106167: LD_EXP 154
106171: IFFALSE 106240
106173: GO 106175
106175: DISABLE
106176: LD_INT 0
106178: PPUSH
106179: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106180: LD_ADDR_VAR 0 2
106184: PUSH
106185: LD_INT 22
106187: PUSH
106188: LD_OWVAR 2
106192: PUSH
106193: EMPTY
106194: LIST
106195: LIST
106196: PPUSH
106197: CALL_OW 69
106201: ST_TO_ADDR
// if not tmp then
106202: LD_VAR 0 2
106206: NOT
106207: IFFALSE 106211
// exit ;
106209: GO 106240
// for i in tmp do
106211: LD_ADDR_VAR 0 1
106215: PUSH
106216: LD_VAR 0 2
106220: PUSH
106221: FOR_IN
106222: IFFALSE 106238
// SetLives ( i , 300 ) ;
106224: LD_VAR 0 1
106228: PPUSH
106229: LD_INT 300
106231: PPUSH
106232: CALL_OW 234
106236: GO 106221
106238: POP
106239: POP
// end ;
106240: PPOPN 2
106242: END
// every 0 0$1 trigger s60 do var i , tmp ;
106243: LD_EXP 155
106247: IFFALSE 106316
106249: GO 106251
106251: DISABLE
106252: LD_INT 0
106254: PPUSH
106255: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106256: LD_ADDR_VAR 0 2
106260: PUSH
106261: LD_INT 22
106263: PUSH
106264: LD_OWVAR 2
106268: PUSH
106269: EMPTY
106270: LIST
106271: LIST
106272: PPUSH
106273: CALL_OW 69
106277: ST_TO_ADDR
// if not tmp then
106278: LD_VAR 0 2
106282: NOT
106283: IFFALSE 106287
// exit ;
106285: GO 106316
// for i in tmp do
106287: LD_ADDR_VAR 0 1
106291: PUSH
106292: LD_VAR 0 2
106296: PUSH
106297: FOR_IN
106298: IFFALSE 106314
// SetLives ( i , 600 ) ;
106300: LD_VAR 0 1
106304: PPUSH
106305: LD_INT 600
106307: PPUSH
106308: CALL_OW 234
106312: GO 106297
106314: POP
106315: POP
// end ;
106316: PPOPN 2
106318: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
106319: LD_INT 0
106321: PPUSH
// case cmd of 301 :
106322: LD_VAR 0 1
106326: PUSH
106327: LD_INT 301
106329: DOUBLE
106330: EQUAL
106331: IFTRUE 106335
106333: GO 106367
106335: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
106336: LD_VAR 0 6
106340: PPUSH
106341: LD_VAR 0 7
106345: PPUSH
106346: LD_VAR 0 8
106350: PPUSH
106351: LD_VAR 0 4
106355: PPUSH
106356: LD_VAR 0 5
106360: PPUSH
106361: CALL 107576 0 5
106365: GO 106488
106367: LD_INT 302
106369: DOUBLE
106370: EQUAL
106371: IFTRUE 106375
106373: GO 106412
106375: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
106376: LD_VAR 0 6
106380: PPUSH
106381: LD_VAR 0 7
106385: PPUSH
106386: LD_VAR 0 8
106390: PPUSH
106391: LD_VAR 0 9
106395: PPUSH
106396: LD_VAR 0 4
106400: PPUSH
106401: LD_VAR 0 5
106405: PPUSH
106406: CALL 107667 0 6
106410: GO 106488
106412: LD_INT 303
106414: DOUBLE
106415: EQUAL
106416: IFTRUE 106420
106418: GO 106457
106420: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
106421: LD_VAR 0 6
106425: PPUSH
106426: LD_VAR 0 7
106430: PPUSH
106431: LD_VAR 0 8
106435: PPUSH
106436: LD_VAR 0 9
106440: PPUSH
106441: LD_VAR 0 4
106445: PPUSH
106446: LD_VAR 0 5
106450: PPUSH
106451: CALL 106493 0 6
106455: GO 106488
106457: LD_INT 304
106459: DOUBLE
106460: EQUAL
106461: IFTRUE 106465
106463: GO 106487
106465: POP
// hHackTeleport ( unit , x , y ) ; end ;
106466: LD_VAR 0 2
106470: PPUSH
106471: LD_VAR 0 4
106475: PPUSH
106476: LD_VAR 0 5
106480: PPUSH
106481: CALL 108260 0 3
106485: GO 106488
106487: POP
// end ;
106488: LD_VAR 0 12
106492: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
106493: LD_INT 0
106495: PPUSH
106496: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
106497: LD_VAR 0 1
106501: PUSH
106502: LD_INT 1
106504: LESS
106505: PUSH
106506: LD_VAR 0 1
106510: PUSH
106511: LD_INT 3
106513: GREATER
106514: OR
106515: PUSH
106516: LD_VAR 0 5
106520: PPUSH
106521: LD_VAR 0 6
106525: PPUSH
106526: CALL_OW 428
106530: OR
106531: IFFALSE 106535
// exit ;
106533: GO 107263
// uc_side := your_side ;
106535: LD_ADDR_OWVAR 20
106539: PUSH
106540: LD_OWVAR 2
106544: ST_TO_ADDR
// uc_nation := nation ;
106545: LD_ADDR_OWVAR 21
106549: PUSH
106550: LD_VAR 0 1
106554: ST_TO_ADDR
// bc_level = 1 ;
106555: LD_ADDR_OWVAR 43
106559: PUSH
106560: LD_INT 1
106562: ST_TO_ADDR
// case btype of 1 :
106563: LD_VAR 0 2
106567: PUSH
106568: LD_INT 1
106570: DOUBLE
106571: EQUAL
106572: IFTRUE 106576
106574: GO 106587
106576: POP
// bc_type := b_depot ; 2 :
106577: LD_ADDR_OWVAR 42
106581: PUSH
106582: LD_INT 0
106584: ST_TO_ADDR
106585: GO 107207
106587: LD_INT 2
106589: DOUBLE
106590: EQUAL
106591: IFTRUE 106595
106593: GO 106606
106595: POP
// bc_type := b_warehouse ; 3 :
106596: LD_ADDR_OWVAR 42
106600: PUSH
106601: LD_INT 1
106603: ST_TO_ADDR
106604: GO 107207
106606: LD_INT 3
106608: DOUBLE
106609: EQUAL
106610: IFTRUE 106614
106612: GO 106625
106614: POP
// bc_type := b_lab ; 4 .. 9 :
106615: LD_ADDR_OWVAR 42
106619: PUSH
106620: LD_INT 6
106622: ST_TO_ADDR
106623: GO 107207
106625: LD_INT 4
106627: DOUBLE
106628: GREATEREQUAL
106629: IFFALSE 106637
106631: LD_INT 9
106633: DOUBLE
106634: LESSEQUAL
106635: IFTRUE 106639
106637: GO 106699
106639: POP
// begin bc_type := b_lab_half ;
106640: LD_ADDR_OWVAR 42
106644: PUSH
106645: LD_INT 7
106647: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
106648: LD_ADDR_OWVAR 44
106652: PUSH
106653: LD_INT 10
106655: PUSH
106656: LD_INT 11
106658: PUSH
106659: LD_INT 12
106661: PUSH
106662: LD_INT 15
106664: PUSH
106665: LD_INT 14
106667: PUSH
106668: LD_INT 13
106670: PUSH
106671: EMPTY
106672: LIST
106673: LIST
106674: LIST
106675: LIST
106676: LIST
106677: LIST
106678: PUSH
106679: LD_VAR 0 2
106683: PUSH
106684: LD_INT 3
106686: MINUS
106687: ARRAY
106688: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
106689: LD_ADDR_OWVAR 45
106693: PUSH
106694: LD_INT 9
106696: ST_TO_ADDR
// end ; 10 .. 13 :
106697: GO 107207
106699: LD_INT 10
106701: DOUBLE
106702: GREATEREQUAL
106703: IFFALSE 106711
106705: LD_INT 13
106707: DOUBLE
106708: LESSEQUAL
106709: IFTRUE 106713
106711: GO 106790
106713: POP
// begin bc_type := b_lab_full ;
106714: LD_ADDR_OWVAR 42
106718: PUSH
106719: LD_INT 8
106721: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
106722: LD_ADDR_OWVAR 44
106726: PUSH
106727: LD_INT 10
106729: PUSH
106730: LD_INT 12
106732: PUSH
106733: LD_INT 14
106735: PUSH
106736: LD_INT 13
106738: PUSH
106739: EMPTY
106740: LIST
106741: LIST
106742: LIST
106743: LIST
106744: PUSH
106745: LD_VAR 0 2
106749: PUSH
106750: LD_INT 9
106752: MINUS
106753: ARRAY
106754: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
106755: LD_ADDR_OWVAR 45
106759: PUSH
106760: LD_INT 11
106762: PUSH
106763: LD_INT 15
106765: PUSH
106766: LD_INT 12
106768: PUSH
106769: LD_INT 15
106771: PUSH
106772: EMPTY
106773: LIST
106774: LIST
106775: LIST
106776: LIST
106777: PUSH
106778: LD_VAR 0 2
106782: PUSH
106783: LD_INT 9
106785: MINUS
106786: ARRAY
106787: ST_TO_ADDR
// end ; 14 :
106788: GO 107207
106790: LD_INT 14
106792: DOUBLE
106793: EQUAL
106794: IFTRUE 106798
106796: GO 106809
106798: POP
// bc_type := b_workshop ; 15 :
106799: LD_ADDR_OWVAR 42
106803: PUSH
106804: LD_INT 2
106806: ST_TO_ADDR
106807: GO 107207
106809: LD_INT 15
106811: DOUBLE
106812: EQUAL
106813: IFTRUE 106817
106815: GO 106828
106817: POP
// bc_type := b_factory ; 16 :
106818: LD_ADDR_OWVAR 42
106822: PUSH
106823: LD_INT 3
106825: ST_TO_ADDR
106826: GO 107207
106828: LD_INT 16
106830: DOUBLE
106831: EQUAL
106832: IFTRUE 106836
106834: GO 106847
106836: POP
// bc_type := b_ext_gun ; 17 :
106837: LD_ADDR_OWVAR 42
106841: PUSH
106842: LD_INT 17
106844: ST_TO_ADDR
106845: GO 107207
106847: LD_INT 17
106849: DOUBLE
106850: EQUAL
106851: IFTRUE 106855
106853: GO 106883
106855: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
106856: LD_ADDR_OWVAR 42
106860: PUSH
106861: LD_INT 19
106863: PUSH
106864: LD_INT 23
106866: PUSH
106867: LD_INT 19
106869: PUSH
106870: EMPTY
106871: LIST
106872: LIST
106873: LIST
106874: PUSH
106875: LD_VAR 0 1
106879: ARRAY
106880: ST_TO_ADDR
106881: GO 107207
106883: LD_INT 18
106885: DOUBLE
106886: EQUAL
106887: IFTRUE 106891
106889: GO 106902
106891: POP
// bc_type := b_ext_radar ; 19 :
106892: LD_ADDR_OWVAR 42
106896: PUSH
106897: LD_INT 20
106899: ST_TO_ADDR
106900: GO 107207
106902: LD_INT 19
106904: DOUBLE
106905: EQUAL
106906: IFTRUE 106910
106908: GO 106921
106910: POP
// bc_type := b_ext_radio ; 20 :
106911: LD_ADDR_OWVAR 42
106915: PUSH
106916: LD_INT 22
106918: ST_TO_ADDR
106919: GO 107207
106921: LD_INT 20
106923: DOUBLE
106924: EQUAL
106925: IFTRUE 106929
106927: GO 106940
106929: POP
// bc_type := b_ext_siberium ; 21 :
106930: LD_ADDR_OWVAR 42
106934: PUSH
106935: LD_INT 21
106937: ST_TO_ADDR
106938: GO 107207
106940: LD_INT 21
106942: DOUBLE
106943: EQUAL
106944: IFTRUE 106948
106946: GO 106959
106948: POP
// bc_type := b_ext_computer ; 22 :
106949: LD_ADDR_OWVAR 42
106953: PUSH
106954: LD_INT 24
106956: ST_TO_ADDR
106957: GO 107207
106959: LD_INT 22
106961: DOUBLE
106962: EQUAL
106963: IFTRUE 106967
106965: GO 106978
106967: POP
// bc_type := b_ext_track ; 23 :
106968: LD_ADDR_OWVAR 42
106972: PUSH
106973: LD_INT 16
106975: ST_TO_ADDR
106976: GO 107207
106978: LD_INT 23
106980: DOUBLE
106981: EQUAL
106982: IFTRUE 106986
106984: GO 106997
106986: POP
// bc_type := b_ext_laser ; 24 :
106987: LD_ADDR_OWVAR 42
106991: PUSH
106992: LD_INT 25
106994: ST_TO_ADDR
106995: GO 107207
106997: LD_INT 24
106999: DOUBLE
107000: EQUAL
107001: IFTRUE 107005
107003: GO 107016
107005: POP
// bc_type := b_control_tower ; 25 :
107006: LD_ADDR_OWVAR 42
107010: PUSH
107011: LD_INT 36
107013: ST_TO_ADDR
107014: GO 107207
107016: LD_INT 25
107018: DOUBLE
107019: EQUAL
107020: IFTRUE 107024
107022: GO 107035
107024: POP
// bc_type := b_breastwork ; 26 :
107025: LD_ADDR_OWVAR 42
107029: PUSH
107030: LD_INT 31
107032: ST_TO_ADDR
107033: GO 107207
107035: LD_INT 26
107037: DOUBLE
107038: EQUAL
107039: IFTRUE 107043
107041: GO 107054
107043: POP
// bc_type := b_bunker ; 27 :
107044: LD_ADDR_OWVAR 42
107048: PUSH
107049: LD_INT 32
107051: ST_TO_ADDR
107052: GO 107207
107054: LD_INT 27
107056: DOUBLE
107057: EQUAL
107058: IFTRUE 107062
107060: GO 107073
107062: POP
// bc_type := b_turret ; 28 :
107063: LD_ADDR_OWVAR 42
107067: PUSH
107068: LD_INT 33
107070: ST_TO_ADDR
107071: GO 107207
107073: LD_INT 28
107075: DOUBLE
107076: EQUAL
107077: IFTRUE 107081
107079: GO 107092
107081: POP
// bc_type := b_armoury ; 29 :
107082: LD_ADDR_OWVAR 42
107086: PUSH
107087: LD_INT 4
107089: ST_TO_ADDR
107090: GO 107207
107092: LD_INT 29
107094: DOUBLE
107095: EQUAL
107096: IFTRUE 107100
107098: GO 107111
107100: POP
// bc_type := b_barracks ; 30 :
107101: LD_ADDR_OWVAR 42
107105: PUSH
107106: LD_INT 5
107108: ST_TO_ADDR
107109: GO 107207
107111: LD_INT 30
107113: DOUBLE
107114: EQUAL
107115: IFTRUE 107119
107117: GO 107130
107119: POP
// bc_type := b_solar_power ; 31 :
107120: LD_ADDR_OWVAR 42
107124: PUSH
107125: LD_INT 27
107127: ST_TO_ADDR
107128: GO 107207
107130: LD_INT 31
107132: DOUBLE
107133: EQUAL
107134: IFTRUE 107138
107136: GO 107149
107138: POP
// bc_type := b_oil_power ; 32 :
107139: LD_ADDR_OWVAR 42
107143: PUSH
107144: LD_INT 26
107146: ST_TO_ADDR
107147: GO 107207
107149: LD_INT 32
107151: DOUBLE
107152: EQUAL
107153: IFTRUE 107157
107155: GO 107168
107157: POP
// bc_type := b_siberite_power ; 33 :
107158: LD_ADDR_OWVAR 42
107162: PUSH
107163: LD_INT 28
107165: ST_TO_ADDR
107166: GO 107207
107168: LD_INT 33
107170: DOUBLE
107171: EQUAL
107172: IFTRUE 107176
107174: GO 107187
107176: POP
// bc_type := b_oil_mine ; 34 :
107177: LD_ADDR_OWVAR 42
107181: PUSH
107182: LD_INT 29
107184: ST_TO_ADDR
107185: GO 107207
107187: LD_INT 34
107189: DOUBLE
107190: EQUAL
107191: IFTRUE 107195
107193: GO 107206
107195: POP
// bc_type := b_siberite_mine ; end ;
107196: LD_ADDR_OWVAR 42
107200: PUSH
107201: LD_INT 30
107203: ST_TO_ADDR
107204: GO 107207
107206: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107207: LD_ADDR_VAR 0 8
107211: PUSH
107212: LD_VAR 0 5
107216: PPUSH
107217: LD_VAR 0 6
107221: PPUSH
107222: LD_VAR 0 3
107226: PPUSH
107227: CALL_OW 47
107231: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107232: LD_OWVAR 42
107236: PUSH
107237: LD_INT 32
107239: PUSH
107240: LD_INT 33
107242: PUSH
107243: EMPTY
107244: LIST
107245: LIST
107246: IN
107247: IFFALSE 107263
// PlaceWeaponTurret ( b , weapon ) ;
107249: LD_VAR 0 8
107253: PPUSH
107254: LD_VAR 0 4
107258: PPUSH
107259: CALL_OW 431
// end ;
107263: LD_VAR 0 7
107267: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107268: LD_INT 0
107270: PPUSH
107271: PPUSH
107272: PPUSH
107273: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107274: LD_ADDR_VAR 0 4
107278: PUSH
107279: LD_INT 22
107281: PUSH
107282: LD_OWVAR 2
107286: PUSH
107287: EMPTY
107288: LIST
107289: LIST
107290: PUSH
107291: LD_INT 2
107293: PUSH
107294: LD_INT 30
107296: PUSH
107297: LD_INT 0
107299: PUSH
107300: EMPTY
107301: LIST
107302: LIST
107303: PUSH
107304: LD_INT 30
107306: PUSH
107307: LD_INT 1
107309: PUSH
107310: EMPTY
107311: LIST
107312: LIST
107313: PUSH
107314: EMPTY
107315: LIST
107316: LIST
107317: LIST
107318: PUSH
107319: EMPTY
107320: LIST
107321: LIST
107322: PPUSH
107323: CALL_OW 69
107327: ST_TO_ADDR
// if not tmp then
107328: LD_VAR 0 4
107332: NOT
107333: IFFALSE 107337
// exit ;
107335: GO 107396
// for i in tmp do
107337: LD_ADDR_VAR 0 2
107341: PUSH
107342: LD_VAR 0 4
107346: PUSH
107347: FOR_IN
107348: IFFALSE 107394
// for j = 1 to 3 do
107350: LD_ADDR_VAR 0 3
107354: PUSH
107355: DOUBLE
107356: LD_INT 1
107358: DEC
107359: ST_TO_ADDR
107360: LD_INT 3
107362: PUSH
107363: FOR_TO
107364: IFFALSE 107390
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
107366: LD_VAR 0 2
107370: PPUSH
107371: CALL_OW 274
107375: PPUSH
107376: LD_VAR 0 3
107380: PPUSH
107381: LD_INT 99999
107383: PPUSH
107384: CALL_OW 277
107388: GO 107363
107390: POP
107391: POP
107392: GO 107347
107394: POP
107395: POP
// end ;
107396: LD_VAR 0 1
107400: RET
// export function hHackSetLevel10 ; var i , j ; begin
107401: LD_INT 0
107403: PPUSH
107404: PPUSH
107405: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
107406: LD_ADDR_VAR 0 2
107410: PUSH
107411: LD_INT 21
107413: PUSH
107414: LD_INT 1
107416: PUSH
107417: EMPTY
107418: LIST
107419: LIST
107420: PPUSH
107421: CALL_OW 69
107425: PUSH
107426: FOR_IN
107427: IFFALSE 107479
// if IsSelected ( i ) then
107429: LD_VAR 0 2
107433: PPUSH
107434: CALL_OW 306
107438: IFFALSE 107477
// begin for j := 1 to 4 do
107440: LD_ADDR_VAR 0 3
107444: PUSH
107445: DOUBLE
107446: LD_INT 1
107448: DEC
107449: ST_TO_ADDR
107450: LD_INT 4
107452: PUSH
107453: FOR_TO
107454: IFFALSE 107475
// SetSkill ( i , j , 10 ) ;
107456: LD_VAR 0 2
107460: PPUSH
107461: LD_VAR 0 3
107465: PPUSH
107466: LD_INT 10
107468: PPUSH
107469: CALL_OW 237
107473: GO 107453
107475: POP
107476: POP
// end ;
107477: GO 107426
107479: POP
107480: POP
// end ;
107481: LD_VAR 0 1
107485: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
107486: LD_INT 0
107488: PPUSH
107489: PPUSH
107490: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
107491: LD_ADDR_VAR 0 2
107495: PUSH
107496: LD_INT 22
107498: PUSH
107499: LD_OWVAR 2
107503: PUSH
107504: EMPTY
107505: LIST
107506: LIST
107507: PUSH
107508: LD_INT 21
107510: PUSH
107511: LD_INT 1
107513: PUSH
107514: EMPTY
107515: LIST
107516: LIST
107517: PUSH
107518: EMPTY
107519: LIST
107520: LIST
107521: PPUSH
107522: CALL_OW 69
107526: PUSH
107527: FOR_IN
107528: IFFALSE 107569
// begin for j := 1 to 4 do
107530: LD_ADDR_VAR 0 3
107534: PUSH
107535: DOUBLE
107536: LD_INT 1
107538: DEC
107539: ST_TO_ADDR
107540: LD_INT 4
107542: PUSH
107543: FOR_TO
107544: IFFALSE 107565
// SetSkill ( i , j , 10 ) ;
107546: LD_VAR 0 2
107550: PPUSH
107551: LD_VAR 0 3
107555: PPUSH
107556: LD_INT 10
107558: PPUSH
107559: CALL_OW 237
107563: GO 107543
107565: POP
107566: POP
// end ;
107567: GO 107527
107569: POP
107570: POP
// end ;
107571: LD_VAR 0 1
107575: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
107576: LD_INT 0
107578: PPUSH
// uc_side := your_side ;
107579: LD_ADDR_OWVAR 20
107583: PUSH
107584: LD_OWVAR 2
107588: ST_TO_ADDR
// uc_nation := nation ;
107589: LD_ADDR_OWVAR 21
107593: PUSH
107594: LD_VAR 0 1
107598: ST_TO_ADDR
// InitHc ;
107599: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
107603: LD_INT 0
107605: PPUSH
107606: LD_VAR 0 2
107610: PPUSH
107611: LD_VAR 0 3
107615: PPUSH
107616: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
107620: LD_VAR 0 4
107624: PPUSH
107625: LD_VAR 0 5
107629: PPUSH
107630: CALL_OW 428
107634: PUSH
107635: LD_INT 0
107637: EQUAL
107638: IFFALSE 107662
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
107640: CALL_OW 44
107644: PPUSH
107645: LD_VAR 0 4
107649: PPUSH
107650: LD_VAR 0 5
107654: PPUSH
107655: LD_INT 1
107657: PPUSH
107658: CALL_OW 48
// end ;
107662: LD_VAR 0 6
107666: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
107667: LD_INT 0
107669: PPUSH
107670: PPUSH
// uc_side := your_side ;
107671: LD_ADDR_OWVAR 20
107675: PUSH
107676: LD_OWVAR 2
107680: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
107681: LD_VAR 0 1
107685: PUSH
107686: LD_INT 1
107688: PUSH
107689: LD_INT 2
107691: PUSH
107692: LD_INT 3
107694: PUSH
107695: LD_INT 4
107697: PUSH
107698: LD_INT 5
107700: PUSH
107701: EMPTY
107702: LIST
107703: LIST
107704: LIST
107705: LIST
107706: LIST
107707: IN
107708: IFFALSE 107720
// uc_nation := nation_american else
107710: LD_ADDR_OWVAR 21
107714: PUSH
107715: LD_INT 1
107717: ST_TO_ADDR
107718: GO 107763
// if chassis in [ 11 , 12 , 13 , 14 ] then
107720: LD_VAR 0 1
107724: PUSH
107725: LD_INT 11
107727: PUSH
107728: LD_INT 12
107730: PUSH
107731: LD_INT 13
107733: PUSH
107734: LD_INT 14
107736: PUSH
107737: EMPTY
107738: LIST
107739: LIST
107740: LIST
107741: LIST
107742: IN
107743: IFFALSE 107755
// uc_nation := nation_arabian else
107745: LD_ADDR_OWVAR 21
107749: PUSH
107750: LD_INT 2
107752: ST_TO_ADDR
107753: GO 107763
// uc_nation := nation_russian ;
107755: LD_ADDR_OWVAR 21
107759: PUSH
107760: LD_INT 3
107762: ST_TO_ADDR
// vc_chassis := chassis ;
107763: LD_ADDR_OWVAR 37
107767: PUSH
107768: LD_VAR 0 1
107772: ST_TO_ADDR
// vc_engine := engine ;
107773: LD_ADDR_OWVAR 39
107777: PUSH
107778: LD_VAR 0 2
107782: ST_TO_ADDR
// vc_control := control ;
107783: LD_ADDR_OWVAR 38
107787: PUSH
107788: LD_VAR 0 3
107792: ST_TO_ADDR
// vc_weapon := weapon ;
107793: LD_ADDR_OWVAR 40
107797: PUSH
107798: LD_VAR 0 4
107802: ST_TO_ADDR
// un := CreateVehicle ;
107803: LD_ADDR_VAR 0 8
107807: PUSH
107808: CALL_OW 45
107812: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
107813: LD_VAR 0 8
107817: PPUSH
107818: LD_INT 0
107820: PPUSH
107821: LD_INT 5
107823: PPUSH
107824: CALL_OW 12
107828: PPUSH
107829: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
107833: LD_VAR 0 8
107837: PPUSH
107838: LD_VAR 0 5
107842: PPUSH
107843: LD_VAR 0 6
107847: PPUSH
107848: LD_INT 1
107850: PPUSH
107851: CALL_OW 48
// end ;
107855: LD_VAR 0 7
107859: RET
// export hInvincible ; every 1 do
107860: GO 107862
107862: DISABLE
// hInvincible := [ ] ;
107863: LD_ADDR_EXP 156
107867: PUSH
107868: EMPTY
107869: ST_TO_ADDR
107870: END
// every 10 do var i ;
107871: GO 107873
107873: DISABLE
107874: LD_INT 0
107876: PPUSH
// begin enable ;
107877: ENABLE
// if not hInvincible then
107878: LD_EXP 156
107882: NOT
107883: IFFALSE 107887
// exit ;
107885: GO 107931
// for i in hInvincible do
107887: LD_ADDR_VAR 0 1
107891: PUSH
107892: LD_EXP 156
107896: PUSH
107897: FOR_IN
107898: IFFALSE 107929
// if GetLives ( i ) < 1000 then
107900: LD_VAR 0 1
107904: PPUSH
107905: CALL_OW 256
107909: PUSH
107910: LD_INT 1000
107912: LESS
107913: IFFALSE 107927
// SetLives ( i , 1000 ) ;
107915: LD_VAR 0 1
107919: PPUSH
107920: LD_INT 1000
107922: PPUSH
107923: CALL_OW 234
107927: GO 107897
107929: POP
107930: POP
// end ;
107931: PPOPN 1
107933: END
// export function hHackInvincible ; var i ; begin
107934: LD_INT 0
107936: PPUSH
107937: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
107938: LD_ADDR_VAR 0 2
107942: PUSH
107943: LD_INT 2
107945: PUSH
107946: LD_INT 21
107948: PUSH
107949: LD_INT 1
107951: PUSH
107952: EMPTY
107953: LIST
107954: LIST
107955: PUSH
107956: LD_INT 21
107958: PUSH
107959: LD_INT 2
107961: PUSH
107962: EMPTY
107963: LIST
107964: LIST
107965: PUSH
107966: EMPTY
107967: LIST
107968: LIST
107969: LIST
107970: PPUSH
107971: CALL_OW 69
107975: PUSH
107976: FOR_IN
107977: IFFALSE 108038
// if IsSelected ( i ) then
107979: LD_VAR 0 2
107983: PPUSH
107984: CALL_OW 306
107988: IFFALSE 108036
// begin if i in hInvincible then
107990: LD_VAR 0 2
107994: PUSH
107995: LD_EXP 156
107999: IN
108000: IFFALSE 108020
// hInvincible := hInvincible diff i else
108002: LD_ADDR_EXP 156
108006: PUSH
108007: LD_EXP 156
108011: PUSH
108012: LD_VAR 0 2
108016: DIFF
108017: ST_TO_ADDR
108018: GO 108036
// hInvincible := hInvincible union i ;
108020: LD_ADDR_EXP 156
108024: PUSH
108025: LD_EXP 156
108029: PUSH
108030: LD_VAR 0 2
108034: UNION
108035: ST_TO_ADDR
// end ;
108036: GO 107976
108038: POP
108039: POP
// end ;
108040: LD_VAR 0 1
108044: RET
// export function hHackInvisible ; var i , j ; begin
108045: LD_INT 0
108047: PPUSH
108048: PPUSH
108049: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108050: LD_ADDR_VAR 0 2
108054: PUSH
108055: LD_INT 21
108057: PUSH
108058: LD_INT 1
108060: PUSH
108061: EMPTY
108062: LIST
108063: LIST
108064: PPUSH
108065: CALL_OW 69
108069: PUSH
108070: FOR_IN
108071: IFFALSE 108095
// if IsSelected ( i ) then
108073: LD_VAR 0 2
108077: PPUSH
108078: CALL_OW 306
108082: IFFALSE 108093
// ComForceInvisible ( i ) ;
108084: LD_VAR 0 2
108088: PPUSH
108089: CALL_OW 496
108093: GO 108070
108095: POP
108096: POP
// end ;
108097: LD_VAR 0 1
108101: RET
// export function hHackChangeYourSide ; begin
108102: LD_INT 0
108104: PPUSH
// if your_side = 8 then
108105: LD_OWVAR 2
108109: PUSH
108110: LD_INT 8
108112: EQUAL
108113: IFFALSE 108125
// your_side := 0 else
108115: LD_ADDR_OWVAR 2
108119: PUSH
108120: LD_INT 0
108122: ST_TO_ADDR
108123: GO 108139
// your_side := your_side + 1 ;
108125: LD_ADDR_OWVAR 2
108129: PUSH
108130: LD_OWVAR 2
108134: PUSH
108135: LD_INT 1
108137: PLUS
108138: ST_TO_ADDR
// end ;
108139: LD_VAR 0 1
108143: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108144: LD_INT 0
108146: PPUSH
108147: PPUSH
108148: PPUSH
// for i in all_units do
108149: LD_ADDR_VAR 0 2
108153: PUSH
108154: LD_OWVAR 3
108158: PUSH
108159: FOR_IN
108160: IFFALSE 108238
// if IsSelected ( i ) then
108162: LD_VAR 0 2
108166: PPUSH
108167: CALL_OW 306
108171: IFFALSE 108236
// begin j := GetSide ( i ) ;
108173: LD_ADDR_VAR 0 3
108177: PUSH
108178: LD_VAR 0 2
108182: PPUSH
108183: CALL_OW 255
108187: ST_TO_ADDR
// if j = 8 then
108188: LD_VAR 0 3
108192: PUSH
108193: LD_INT 8
108195: EQUAL
108196: IFFALSE 108208
// j := 0 else
108198: LD_ADDR_VAR 0 3
108202: PUSH
108203: LD_INT 0
108205: ST_TO_ADDR
108206: GO 108222
// j := j + 1 ;
108208: LD_ADDR_VAR 0 3
108212: PUSH
108213: LD_VAR 0 3
108217: PUSH
108218: LD_INT 1
108220: PLUS
108221: ST_TO_ADDR
// SetSide ( i , j ) ;
108222: LD_VAR 0 2
108226: PPUSH
108227: LD_VAR 0 3
108231: PPUSH
108232: CALL_OW 235
// end ;
108236: GO 108159
108238: POP
108239: POP
// end ;
108240: LD_VAR 0 1
108244: RET
// export function hHackFog ; begin
108245: LD_INT 0
108247: PPUSH
// FogOff ( true ) ;
108248: LD_INT 1
108250: PPUSH
108251: CALL_OW 344
// end ;
108255: LD_VAR 0 1
108259: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108260: LD_INT 0
108262: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108263: LD_VAR 0 1
108267: PPUSH
108268: LD_VAR 0 2
108272: PPUSH
108273: LD_VAR 0 3
108277: PPUSH
108278: LD_INT 1
108280: PPUSH
108281: LD_INT 1
108283: PPUSH
108284: CALL_OW 483
// CenterOnXY ( x , y ) ;
108288: LD_VAR 0 2
108292: PPUSH
108293: LD_VAR 0 3
108297: PPUSH
108298: CALL_OW 84
// end ;
108302: LD_VAR 0 4
108306: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
108307: LD_INT 0
108309: PPUSH
108310: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
108311: LD_VAR 0 1
108315: NOT
108316: PUSH
108317: LD_VAR 0 2
108321: PPUSH
108322: LD_VAR 0 3
108326: PPUSH
108327: CALL_OW 488
108331: NOT
108332: OR
108333: PUSH
108334: LD_VAR 0 1
108338: PPUSH
108339: CALL_OW 266
108343: PUSH
108344: LD_INT 3
108346: NONEQUAL
108347: PUSH
108348: LD_VAR 0 1
108352: PPUSH
108353: CALL_OW 247
108357: PUSH
108358: LD_INT 1
108360: EQUAL
108361: NOT
108362: AND
108363: OR
108364: IFFALSE 108368
// exit ;
108366: GO 108517
// if GetType ( factory ) = unit_human then
108368: LD_VAR 0 1
108372: PPUSH
108373: CALL_OW 247
108377: PUSH
108378: LD_INT 1
108380: EQUAL
108381: IFFALSE 108398
// factory := IsInUnit ( factory ) ;
108383: LD_ADDR_VAR 0 1
108387: PUSH
108388: LD_VAR 0 1
108392: PPUSH
108393: CALL_OW 310
108397: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
108398: LD_VAR 0 1
108402: PPUSH
108403: CALL_OW 266
108407: PUSH
108408: LD_INT 3
108410: NONEQUAL
108411: IFFALSE 108415
// exit ;
108413: GO 108517
// if HexInfo ( x , y ) = factory then
108415: LD_VAR 0 2
108419: PPUSH
108420: LD_VAR 0 3
108424: PPUSH
108425: CALL_OW 428
108429: PUSH
108430: LD_VAR 0 1
108434: EQUAL
108435: IFFALSE 108462
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
108437: LD_ADDR_EXP 157
108441: PUSH
108442: LD_EXP 157
108446: PPUSH
108447: LD_VAR 0 1
108451: PPUSH
108452: LD_INT 0
108454: PPUSH
108455: CALL_OW 1
108459: ST_TO_ADDR
108460: GO 108513
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
108462: LD_ADDR_EXP 157
108466: PUSH
108467: LD_EXP 157
108471: PPUSH
108472: LD_VAR 0 1
108476: PPUSH
108477: LD_VAR 0 1
108481: PPUSH
108482: CALL_OW 255
108486: PUSH
108487: LD_VAR 0 1
108491: PUSH
108492: LD_VAR 0 2
108496: PUSH
108497: LD_VAR 0 3
108501: PUSH
108502: EMPTY
108503: LIST
108504: LIST
108505: LIST
108506: LIST
108507: PPUSH
108508: CALL_OW 1
108512: ST_TO_ADDR
// UpdateFactoryWaypoints ;
108513: CALL 108522 0 0
// end ;
108517: LD_VAR 0 4
108521: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
108522: LD_INT 0
108524: PPUSH
108525: PPUSH
108526: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
108527: LD_STRING resetFactoryWaypoint();
108529: PPUSH
108530: CALL_OW 559
// if factoryWaypoints then
108534: LD_EXP 157
108538: IFFALSE 108664
// begin list := PrepareArray ( factoryWaypoints ) ;
108540: LD_ADDR_VAR 0 3
108544: PUSH
108545: LD_EXP 157
108549: PPUSH
108550: CALL 50891 0 1
108554: ST_TO_ADDR
// for i := 1 to list do
108555: LD_ADDR_VAR 0 2
108559: PUSH
108560: DOUBLE
108561: LD_INT 1
108563: DEC
108564: ST_TO_ADDR
108565: LD_VAR 0 3
108569: PUSH
108570: FOR_TO
108571: IFFALSE 108662
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108573: LD_STRING setFactoryWaypointXY(
108575: PUSH
108576: LD_VAR 0 3
108580: PUSH
108581: LD_VAR 0 2
108585: ARRAY
108586: PUSH
108587: LD_INT 1
108589: ARRAY
108590: STR
108591: PUSH
108592: LD_STRING ,
108594: STR
108595: PUSH
108596: LD_VAR 0 3
108600: PUSH
108601: LD_VAR 0 2
108605: ARRAY
108606: PUSH
108607: LD_INT 2
108609: ARRAY
108610: STR
108611: PUSH
108612: LD_STRING ,
108614: STR
108615: PUSH
108616: LD_VAR 0 3
108620: PUSH
108621: LD_VAR 0 2
108625: ARRAY
108626: PUSH
108627: LD_INT 3
108629: ARRAY
108630: STR
108631: PUSH
108632: LD_STRING ,
108634: STR
108635: PUSH
108636: LD_VAR 0 3
108640: PUSH
108641: LD_VAR 0 2
108645: ARRAY
108646: PUSH
108647: LD_INT 4
108649: ARRAY
108650: STR
108651: PUSH
108652: LD_STRING )
108654: STR
108655: PPUSH
108656: CALL_OW 559
108660: GO 108570
108662: POP
108663: POP
// end ; end ;
108664: LD_VAR 0 1
108668: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
108669: LD_INT 0
108671: PPUSH
// if HexInfo ( x , y ) = warehouse then
108672: LD_VAR 0 2
108676: PPUSH
108677: LD_VAR 0 3
108681: PPUSH
108682: CALL_OW 428
108686: PUSH
108687: LD_VAR 0 1
108691: EQUAL
108692: IFFALSE 108719
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
108694: LD_ADDR_EXP 158
108698: PUSH
108699: LD_EXP 158
108703: PPUSH
108704: LD_VAR 0 1
108708: PPUSH
108709: LD_INT 0
108711: PPUSH
108712: CALL_OW 1
108716: ST_TO_ADDR
108717: GO 108770
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
108719: LD_ADDR_EXP 158
108723: PUSH
108724: LD_EXP 158
108728: PPUSH
108729: LD_VAR 0 1
108733: PPUSH
108734: LD_VAR 0 1
108738: PPUSH
108739: CALL_OW 255
108743: PUSH
108744: LD_VAR 0 1
108748: PUSH
108749: LD_VAR 0 2
108753: PUSH
108754: LD_VAR 0 3
108758: PUSH
108759: EMPTY
108760: LIST
108761: LIST
108762: LIST
108763: LIST
108764: PPUSH
108765: CALL_OW 1
108769: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
108770: CALL 108779 0 0
// end ;
108774: LD_VAR 0 4
108778: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
108779: LD_INT 0
108781: PPUSH
108782: PPUSH
108783: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
108784: LD_STRING resetWarehouseGatheringPoints();
108786: PPUSH
108787: CALL_OW 559
// if warehouseGatheringPoints then
108791: LD_EXP 158
108795: IFFALSE 108921
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
108797: LD_ADDR_VAR 0 3
108801: PUSH
108802: LD_EXP 158
108806: PPUSH
108807: CALL 50891 0 1
108811: ST_TO_ADDR
// for i := 1 to list do
108812: LD_ADDR_VAR 0 2
108816: PUSH
108817: DOUBLE
108818: LD_INT 1
108820: DEC
108821: ST_TO_ADDR
108822: LD_VAR 0 3
108826: PUSH
108827: FOR_TO
108828: IFFALSE 108919
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
108830: LD_STRING setWarehouseGatheringPointXY(
108832: PUSH
108833: LD_VAR 0 3
108837: PUSH
108838: LD_VAR 0 2
108842: ARRAY
108843: PUSH
108844: LD_INT 1
108846: ARRAY
108847: STR
108848: PUSH
108849: LD_STRING ,
108851: STR
108852: PUSH
108853: LD_VAR 0 3
108857: PUSH
108858: LD_VAR 0 2
108862: ARRAY
108863: PUSH
108864: LD_INT 2
108866: ARRAY
108867: STR
108868: PUSH
108869: LD_STRING ,
108871: STR
108872: PUSH
108873: LD_VAR 0 3
108877: PUSH
108878: LD_VAR 0 2
108882: ARRAY
108883: PUSH
108884: LD_INT 3
108886: ARRAY
108887: STR
108888: PUSH
108889: LD_STRING ,
108891: STR
108892: PUSH
108893: LD_VAR 0 3
108897: PUSH
108898: LD_VAR 0 2
108902: ARRAY
108903: PUSH
108904: LD_INT 4
108906: ARRAY
108907: STR
108908: PUSH
108909: LD_STRING )
108911: STR
108912: PPUSH
108913: CALL_OW 559
108917: GO 108827
108919: POP
108920: POP
// end ; end ;
108921: LD_VAR 0 1
108925: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
108926: LD_EXP 158
108930: IFFALSE 109615
108932: GO 108934
108934: DISABLE
108935: LD_INT 0
108937: PPUSH
108938: PPUSH
108939: PPUSH
108940: PPUSH
108941: PPUSH
108942: PPUSH
108943: PPUSH
108944: PPUSH
108945: PPUSH
// begin enable ;
108946: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
108947: LD_ADDR_VAR 0 3
108951: PUSH
108952: LD_EXP 158
108956: PPUSH
108957: CALL 50891 0 1
108961: ST_TO_ADDR
// if not list then
108962: LD_VAR 0 3
108966: NOT
108967: IFFALSE 108971
// exit ;
108969: GO 109615
// for i := 1 to list do
108971: LD_ADDR_VAR 0 1
108975: PUSH
108976: DOUBLE
108977: LD_INT 1
108979: DEC
108980: ST_TO_ADDR
108981: LD_VAR 0 3
108985: PUSH
108986: FOR_TO
108987: IFFALSE 109613
// begin depot := list [ i ] [ 2 ] ;
108989: LD_ADDR_VAR 0 8
108993: PUSH
108994: LD_VAR 0 3
108998: PUSH
108999: LD_VAR 0 1
109003: ARRAY
109004: PUSH
109005: LD_INT 2
109007: ARRAY
109008: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109009: LD_ADDR_VAR 0 5
109013: PUSH
109014: LD_VAR 0 3
109018: PUSH
109019: LD_VAR 0 1
109023: ARRAY
109024: PUSH
109025: LD_INT 1
109027: ARRAY
109028: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109029: LD_VAR 0 8
109033: PPUSH
109034: CALL_OW 301
109038: PUSH
109039: LD_VAR 0 5
109043: PUSH
109044: LD_VAR 0 8
109048: PPUSH
109049: CALL_OW 255
109053: NONEQUAL
109054: OR
109055: IFFALSE 109084
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109057: LD_ADDR_EXP 158
109061: PUSH
109062: LD_EXP 158
109066: PPUSH
109067: LD_VAR 0 8
109071: PPUSH
109072: LD_INT 0
109074: PPUSH
109075: CALL_OW 1
109079: ST_TO_ADDR
// exit ;
109080: POP
109081: POP
109082: GO 109615
// end ; x := list [ i ] [ 3 ] ;
109084: LD_ADDR_VAR 0 6
109088: PUSH
109089: LD_VAR 0 3
109093: PUSH
109094: LD_VAR 0 1
109098: ARRAY
109099: PUSH
109100: LD_INT 3
109102: ARRAY
109103: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109104: LD_ADDR_VAR 0 7
109108: PUSH
109109: LD_VAR 0 3
109113: PUSH
109114: LD_VAR 0 1
109118: ARRAY
109119: PUSH
109120: LD_INT 4
109122: ARRAY
109123: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109124: LD_ADDR_VAR 0 9
109128: PUSH
109129: LD_VAR 0 6
109133: PPUSH
109134: LD_VAR 0 7
109138: PPUSH
109139: LD_INT 16
109141: PPUSH
109142: CALL 49479 0 3
109146: ST_TO_ADDR
// if not cratesNearbyPoint then
109147: LD_VAR 0 9
109151: NOT
109152: IFFALSE 109158
// exit ;
109154: POP
109155: POP
109156: GO 109615
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109158: LD_ADDR_VAR 0 4
109162: PUSH
109163: LD_INT 22
109165: PUSH
109166: LD_VAR 0 5
109170: PUSH
109171: EMPTY
109172: LIST
109173: LIST
109174: PUSH
109175: LD_INT 3
109177: PUSH
109178: LD_INT 60
109180: PUSH
109181: EMPTY
109182: LIST
109183: PUSH
109184: EMPTY
109185: LIST
109186: LIST
109187: PUSH
109188: LD_INT 91
109190: PUSH
109191: LD_VAR 0 8
109195: PUSH
109196: LD_INT 6
109198: PUSH
109199: EMPTY
109200: LIST
109201: LIST
109202: LIST
109203: PUSH
109204: LD_INT 2
109206: PUSH
109207: LD_INT 25
109209: PUSH
109210: LD_INT 2
109212: PUSH
109213: EMPTY
109214: LIST
109215: LIST
109216: PUSH
109217: LD_INT 25
109219: PUSH
109220: LD_INT 16
109222: PUSH
109223: EMPTY
109224: LIST
109225: LIST
109226: PUSH
109227: EMPTY
109228: LIST
109229: LIST
109230: LIST
109231: PUSH
109232: EMPTY
109233: LIST
109234: LIST
109235: LIST
109236: LIST
109237: PPUSH
109238: CALL_OW 69
109242: PUSH
109243: LD_VAR 0 8
109247: PPUSH
109248: CALL_OW 313
109252: PPUSH
109253: LD_INT 3
109255: PUSH
109256: LD_INT 60
109258: PUSH
109259: EMPTY
109260: LIST
109261: PUSH
109262: EMPTY
109263: LIST
109264: LIST
109265: PUSH
109266: LD_INT 2
109268: PUSH
109269: LD_INT 25
109271: PUSH
109272: LD_INT 2
109274: PUSH
109275: EMPTY
109276: LIST
109277: LIST
109278: PUSH
109279: LD_INT 25
109281: PUSH
109282: LD_INT 16
109284: PUSH
109285: EMPTY
109286: LIST
109287: LIST
109288: PUSH
109289: EMPTY
109290: LIST
109291: LIST
109292: LIST
109293: PUSH
109294: EMPTY
109295: LIST
109296: LIST
109297: PPUSH
109298: CALL_OW 72
109302: UNION
109303: ST_TO_ADDR
// if tmp then
109304: LD_VAR 0 4
109308: IFFALSE 109388
// begin tmp := ShrinkArray ( tmp , 3 ) ;
109310: LD_ADDR_VAR 0 4
109314: PUSH
109315: LD_VAR 0 4
109319: PPUSH
109320: LD_INT 3
109322: PPUSH
109323: CALL 47448 0 2
109327: ST_TO_ADDR
// for j in tmp do
109328: LD_ADDR_VAR 0 2
109332: PUSH
109333: LD_VAR 0 4
109337: PUSH
109338: FOR_IN
109339: IFFALSE 109382
// begin if IsInUnit ( j ) then
109341: LD_VAR 0 2
109345: PPUSH
109346: CALL_OW 310
109350: IFFALSE 109361
// ComExit ( j ) ;
109352: LD_VAR 0 2
109356: PPUSH
109357: CALL 47531 0 1
// AddComCollect ( j , x , y ) ;
109361: LD_VAR 0 2
109365: PPUSH
109366: LD_VAR 0 6
109370: PPUSH
109371: LD_VAR 0 7
109375: PPUSH
109376: CALL_OW 177
// end ;
109380: GO 109338
109382: POP
109383: POP
// exit ;
109384: POP
109385: POP
109386: GO 109615
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
109388: LD_ADDR_VAR 0 4
109392: PUSH
109393: LD_INT 22
109395: PUSH
109396: LD_VAR 0 5
109400: PUSH
109401: EMPTY
109402: LIST
109403: LIST
109404: PUSH
109405: LD_INT 91
109407: PUSH
109408: LD_VAR 0 8
109412: PUSH
109413: LD_INT 8
109415: PUSH
109416: EMPTY
109417: LIST
109418: LIST
109419: LIST
109420: PUSH
109421: LD_INT 2
109423: PUSH
109424: LD_INT 34
109426: PUSH
109427: LD_INT 12
109429: PUSH
109430: EMPTY
109431: LIST
109432: LIST
109433: PUSH
109434: LD_INT 34
109436: PUSH
109437: LD_INT 51
109439: PUSH
109440: EMPTY
109441: LIST
109442: LIST
109443: PUSH
109444: LD_INT 34
109446: PUSH
109447: LD_INT 32
109449: PUSH
109450: EMPTY
109451: LIST
109452: LIST
109453: PUSH
109454: LD_INT 34
109456: PUSH
109457: LD_INT 89
109459: PUSH
109460: EMPTY
109461: LIST
109462: LIST
109463: PUSH
109464: EMPTY
109465: LIST
109466: LIST
109467: LIST
109468: LIST
109469: LIST
109470: PUSH
109471: EMPTY
109472: LIST
109473: LIST
109474: LIST
109475: PPUSH
109476: CALL_OW 69
109480: ST_TO_ADDR
// if tmp then
109481: LD_VAR 0 4
109485: IFFALSE 109611
// begin for j in tmp do
109487: LD_ADDR_VAR 0 2
109491: PUSH
109492: LD_VAR 0 4
109496: PUSH
109497: FOR_IN
109498: IFFALSE 109609
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
109500: LD_VAR 0 2
109504: PPUSH
109505: CALL_OW 262
109509: PUSH
109510: LD_INT 3
109512: EQUAL
109513: PUSH
109514: LD_VAR 0 2
109518: PPUSH
109519: CALL_OW 261
109523: PUSH
109524: LD_INT 20
109526: GREATER
109527: OR
109528: PUSH
109529: LD_VAR 0 2
109533: PPUSH
109534: CALL_OW 314
109538: NOT
109539: AND
109540: PUSH
109541: LD_VAR 0 2
109545: PPUSH
109546: CALL_OW 263
109550: PUSH
109551: LD_INT 1
109553: NONEQUAL
109554: PUSH
109555: LD_VAR 0 2
109559: PPUSH
109560: CALL_OW 311
109564: OR
109565: AND
109566: IFFALSE 109607
// begin ComCollect ( j , x , y ) ;
109568: LD_VAR 0 2
109572: PPUSH
109573: LD_VAR 0 6
109577: PPUSH
109578: LD_VAR 0 7
109582: PPUSH
109583: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
109587: LD_VAR 0 2
109591: PPUSH
109592: LD_VAR 0 8
109596: PPUSH
109597: CALL_OW 172
// exit ;
109601: POP
109602: POP
109603: POP
109604: POP
109605: GO 109615
// end ;
109607: GO 109497
109609: POP
109610: POP
// end ; end ;
109611: GO 108986
109613: POP
109614: POP
// end ; end_of_file
109615: PPOPN 9
109617: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
109618: LD_VAR 0 1
109622: PPUSH
109623: LD_VAR 0 2
109627: PPUSH
109628: LD_VAR 0 3
109632: PPUSH
109633: LD_VAR 0 4
109637: PPUSH
109638: LD_VAR 0 5
109642: PPUSH
109643: LD_VAR 0 6
109647: PPUSH
109648: CALL 93971 0 6
// end ;
109652: PPOPN 6
109654: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
109655: LD_INT 0
109657: PPUSH
// begin if not units then
109658: LD_VAR 0 1
109662: NOT
109663: IFFALSE 109667
// exit ;
109665: GO 109667
// end ;
109667: PPOPN 7
109669: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
109670: CALL 93875 0 0
// end ;
109674: PPOPN 1
109676: END
