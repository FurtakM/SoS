// starting begin ResetFog ;
   0: NOP4
// InitHc ;
   4: NOP4
// InitUc ;
   8: NOP4
// InitBc ;
  12: NOP4
// InitVariables ;
  16: NOP4
// InitMultiplayer ;
  20: NOP4
// InitMacro ;
  24: NOP4
// if debug then
  28: NOP4
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: NOP4
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: NOP4
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: NOP4
  79: PPUSH
  80: NOP4
// Multiplayer_Start ;
  84: NOP4
// MC_Start ( ) ;
  88: NOP4
// Multiplayer_End ;
  92: NOP4
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: NOP4
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: NOP4
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: NOP4
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: NOP4
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: NOP4
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: NOP4
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: NOP4
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: NOP4
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: NOP4
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: NOP4
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: NOP4
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: NOP4
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: NOP4
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: NOP4
 325: PPUSH
 326: NOP4
 330: PUSH
 331: NOP4
 335: ARRAY
 336: PPUSH
 337: NOP4
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := 1 ;
 353: NOP4
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: NOP4
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: NOP4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: NOP4
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: NOP4
 489: PUSH
 490: NOP4
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: NOP4
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: NOP4
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: NOP4
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: NOP4
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: NOP4
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: NOP4
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: NOP4
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: NOP4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: NOP4
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: NOP4
 646: PUSH
 647: NOP4
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: NOP4
 656: PUSH
 657: NOP4
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: NOP4
 666: PUSH
 667: NOP4
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: NOP4
 676: PUSH
 677: NOP4
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: NOP4
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: NOP4
 693: PUSH
 694: NOP4
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: NOP4
 706: PUSH
 707: NOP4
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: NOP4
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: NOP4
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: NOP4
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: NOP4
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: NOP4
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: NOP4
 772: PUSH
 773: NOP4
 777: PPUSH
 778: NOP4
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: NOP4
 791: PPUSH
 792: NOP4
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: NOP4
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: NOP4
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: NOP4
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: NOP4
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: NOP4
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: NOP4
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: NOP4
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: NOP4
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: NOP4
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: NOP4
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: NOP4
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: NOP4
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: NOP4
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: NOP4
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: NOP4
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: NOP4
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: NOP4
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: NOP4
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: NOP4
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: NOP4
1232: PPUSH
1233: NOP4
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: NOP4
1243: PUSH
1244: NOP4
1248: PPUSH
1249: NOP4
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: NOP4
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: NOP4
1266: PUSH
1267: NOP4
1271: PPUSH
1272: NOP4
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: NOP4
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: NOP4
1289: PUSH
1290: NOP4
1294: PPUSH
1295: NOP4
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: NOP4
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: NOP4
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: NOP4
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: NOP4
1330: PUSH
1331: NOP4
1335: PUSH
1336: NOP4
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: NOP4
1348: PUSH
1349: NOP4
1353: PUSH
1354: NOP4
1358: ARRAY
1359: PUSH
1360: NOP4
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: NOP4
1370: PUSH
1371: NOP4
1375: PPUSH
1376: NOP4
1380: PPUSH
1381: NOP4
1385: PPUSH
1386: NOP4
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: NOP4
1399: PUSH
1400: NOP4
1404: ARRAY
1405: PUSH
1406: NOP4
1410: PUSH
1411: NOP4
1415: ARRAY
1416: PUSH
1417: NOP4
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: NOP4
1430: PUSH
1431: NOP4
1435: PPUSH
1436: NOP4
1440: PPUSH
1441: NOP4
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: NOP4
1453: PPUSH
1454: NOP4
1458: ARRAY
1459: PPUSH
1460: NOP4
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: NOP4
1469: PUSH
1470: NOP4
1474: ARRAY
1475: NOT
1476: PUSH
1477: NOP4
1481: PUSH
1482: NOP4
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: NOP4
1494: PUSH
1495: NOP4
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: NOP4
1508: PUSH
1509: NOP4
1513: PPUSH
1514: NOP4
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: NOP4
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: NOP4
1531: PUSH
1532: NOP4
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: NOP4
1543: PUSH
1544: NOP4
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: NOP4
1561: PUSH
1562: NOP4
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: NOP4
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: NOP4
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: NOP4
1592: PUSH
1593: NOP4
1597: ARRAY
1598: PPUSH
1599: NOP4
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: NOP4
// for x = 1 to j - 1 do
1612: NOP4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: NOP4
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: NOP4
1638: PUSH
1639: NOP4
1643: ARRAY
1644: PPUSH
1645: NOP4
1649: PUSH
1650: NOP4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: NOP4
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: NOP4
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: NOP4
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: NOP4
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: NOP4
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: NOP4
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: NOP4
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: NOP4
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: NOP4
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: NOP4
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: NOP4
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: NOP4
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: NOP4
1901: PUSH
1902: NOP4
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: NOP4
1914: PUSH
1915: NOP4
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: NOP4
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: NOP4
1942: PUSH
1943: NOP4
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: NOP4
1955: PUSH
1956: NOP4
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: NOP4
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: NOP4
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: NOP4
2095: PUSH
2096: NOP4
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: NOP4
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: NOP4
2185: PUSH
2186: NOP4
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: NOP4
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: NOP4
2275: PUSH
2276: NOP4
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: NOP4
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: NOP4
2317: PUSH
2318: NOP4
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: NOP4
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: NOP4
2338: PUSH
2339: NOP4
2343: PPUSH
2344: NOP4
2348: PUSH
2349: NOP4
2353: ARRAY
2354: PPUSH
2355: NOP4
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: NOP4
2364: PUSH
2365: NOP4
2369: PPUSH
2370: NOP4
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: NOP4
2383: PPUSH
2384: NOP4
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: NOP4
2393: PPUSH
2394: NOP4
2398: PUSH
2399: NOP4
2403: PUSH
2404: NOP4
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: NOP4
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: NOP4
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: NOP4
2443: PUSH
2444: NOP4
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: NOP4
2468: PPUSH
2469: NOP4
// if multiplayer then
2473: NOP4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: NOP4
2488: PUSH
2489: NOP4
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: NOP4
2512: PPUSH
2513: NOP4
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: NOP4
2527: PPUSH
2528: NOP4
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: NOP4
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: NOP4
2571: PUSH
2572: NOP4
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: NOP4
2581: PPUSH
2582: NOP4
2586: PUSH
2587: NOP4
2591: PUSH
2592: NOP4
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: NOP4
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: NOP4
2614: PUSH
2615: NOP4
2619: PPUSH
2620: NOP4
2624: PPUSH
2625: NOP4
2629: PPUSH
2630: NOP4
2634: ST_TO_ADDR
// end ; InitHc ;
2635: NOP4
// InitUc ;
2639: NOP4
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: NOP4
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: NOP4
2662: PUSH
2663: NOP4
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: NOP4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: NOP4
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: NOP4
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: NOP4
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: NOP4
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: NOP4
2751: PUSH
2752: NOP4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: NOP4
2768: PPUSH
2769: NOP4
2773: PPUSH
2774: NOP4
// un := CreateHuman ;
2778: NOP4
2782: PUSH
2783: NOP4
2787: ST_TO_ADDR
// if j > copy then
2788: NOP4
2792: PUSH
2793: NOP4
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: NOP4
2804: PUSH
2805: NOP4
2809: PPUSH
2810: NOP4
2814: PPUSH
2815: NOP4
2819: PPUSH
2820: NOP4
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: NOP4
2831: PUSH
2832: NOP4
2836: ARRAY
2837: PPUSH
2838: NOP4
2842: PPUSH
2843: NOP4
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: NOP4
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: NOP4
2859: PUSH
2860: NOP4
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: NOP4
2873: PPUSH
2874: NOP4
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: NOP4
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: NOP4
2890: PUSH
2891: NOP4
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: NOP4
2904: PPUSH
2905: NOP4
// end ; if multi_pos_area then
2909: NOP4
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: NOP4
2919: PPUSH
2920: NOP4
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: NOP4
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: NOP4
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: NOP4
// veh := CreateVehicle ;
2995: NOP4
2999: PUSH
3000: NOP4
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: NOP4
3009: PPUSH
3010: NOP4
3014: PUSH
3015: NOP4
3019: PUSH
3020: NOP4
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: NOP4
// PlaceHumanInUnit ( un , veh ) ;
3038: NOP4
3042: PPUSH
3043: NOP4
3047: PPUSH
3048: NOP4
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: NOP4
3058: PPUSH
3059: NOP4
3063: PUSH
3064: NOP4
3068: PUSH
3069: NOP4
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: NOP4
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: NOP4
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: NOP4
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: NOP4
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: NOP4
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: NOP4
3166: PPUSH
3167: NOP4
3171: PUSH
3172: NOP4
3176: PUSH
3177: NOP4
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: NOP4
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: NOP4
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: NOP4
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: NOP4
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: NOP4
3251: PUSH
3252: NOP4
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: NOP4
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: NOP4
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: NOP4
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: NOP4
3295: PUSH
3296: NOP4
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: NOP4
// tmp := tmp ^ CreateVehicle ;
3321: NOP4
3325: PUSH
3326: NOP4
3330: PUSH
3331: NOP4
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: NOP4
// tmp := tmp ^ CreateVehicle ;
3356: NOP4
3360: PUSH
3361: NOP4
3365: PUSH
3366: NOP4
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: NOP4
// tmp := tmp ^ CreateVehicle ;
3391: NOP4
3395: PUSH
3396: NOP4
3400: PUSH
3401: NOP4
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: NOP4
// tmp := tmp ^ CreateVehicle ;
3426: NOP4
3430: PUSH
3431: NOP4
3435: PUSH
3436: NOP4
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: NOP4
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: NOP4
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: NOP4
3471: PUSH
3472: NOP4
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: NOP4
// tmp := tmp ^ CreateVehicle ;
3497: NOP4
3501: PUSH
3502: NOP4
3506: PUSH
3507: NOP4
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: NOP4
// tmp := tmp ^ CreateVehicle ;
3532: NOP4
3536: PUSH
3537: NOP4
3541: PUSH
3542: NOP4
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: NOP4
// tmp := tmp ^ CreateVehicle ;
3567: NOP4
3571: PUSH
3572: NOP4
3576: PUSH
3577: NOP4
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: NOP4
// tmp := tmp ^ CreateVehicle ;
3602: NOP4
3606: PUSH
3607: NOP4
3611: PUSH
3612: NOP4
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: NOP4
// tmp := tmp ^ CreateVehicle ;
3637: NOP4
3641: PUSH
3642: NOP4
3646: PUSH
3647: NOP4
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: NOP4
// tmp := tmp ^ CreateVehicle ;
3672: NOP4
3676: PUSH
3677: NOP4
3681: PUSH
3682: NOP4
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: NOP4
// tmp := tmp ^ CreateVehicle ;
3707: NOP4
3711: PUSH
3712: NOP4
3716: PUSH
3717: NOP4
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: NOP4
3727: PUSH
3728: NOP4
3732: PPUSH
3733: NOP4
3737: PPUSH
3738: NOP4
3742: PPUSH
3743: NOP4
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: NOP4
// Multiplayer_InitPointSystem ( ) ;
3764: NOP4
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: NOP4
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: NOP4
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: NOP4
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: NOP4
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: NOP4
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: NOP4
// Multiplayer_SpawnArtifact ;
3811: NOP4
// if multi_support then
3815: NOP4
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: NOP4
3825: PUSH
3826: NOP4
3830: ST_TO_ADDR
// game := true ;
3831: NOP4
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: NOP4
3843: PUSH
3844: NOP4
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: NOP4
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: NOP4
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: NOP4
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: NOP4
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: NOP4
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: NOP4
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: NOP4
3916: NOT
3917: AND
3918: PUSH
3919: NOP4
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: NOP4
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: NOP4
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: NOP4
3958: PUSH
3959: NOP4
3963: ARRAY
3964: PUSH
3965: NOP4
3969: PUSH
3970: NOP4
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: NOP4
3982: PUSH
3983: NOP4
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: NOP4
3995: PUSH
3996: NOP4
4000: PUSH
4001: NOP4
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: NOP4
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: NOP4
4027: PUSH
4028: NOP4
4032: ARRAY
4033: PPUSH
4034: NOP4
4038: PUSH
4039: NOP4
4043: PUSH
4044: NOP4
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: NOP4
// tmp := Delete ( tmp , 1 ) ;
4062: NOP4
4066: PUSH
4067: NOP4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: NOP4
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: NOP4
4088: PUSH
4089: NOP4
4093: PPUSH
4094: NOP4
4098: PPUSH
4099: NOP4
4103: PPUSH
4104: NOP4
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: NOP4
4117: PUSH
4118: NOP4
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: NOP4
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: NOP4
4136: LESS
4137: PUSH
4138: NOP4
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: NOP4
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: NOP4
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: NOP4
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: NOP4
4187: PUSH
4188: NOP4
4192: ARRAY
4193: PUSH
4194: NOP4
4198: PUSH
4199: NOP4
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: NOP4
4211: PUSH
4212: NOP4
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: NOP4
4224: PUSH
4225: NOP4
4229: PUSH
4230: NOP4
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: NOP4
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: NOP4
4256: PUSH
4257: NOP4
4261: ARRAY
4262: PPUSH
4263: NOP4
4267: PUSH
4268: NOP4
4272: PUSH
4273: NOP4
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: NOP4
// tmp := Delete ( tmp , 1 ) ;
4291: NOP4
4295: PUSH
4296: NOP4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: NOP4
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: NOP4
4317: PUSH
4318: NOP4
4322: PPUSH
4323: NOP4
4327: PPUSH
4328: NOP4
4332: PPUSH
4333: NOP4
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: NOP4
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: NOP4
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: NOP4
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: NOP4
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: NOP4
4390: PUSH
4391: NOP4
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: NOP4
4404: PUSH
4405: NOP4
4409: PPUSH
4410: NOP4
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: NOP4
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: NOP4
4427: PPUSH
4428: NOP4
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: NOP4
4440: PPUSH
4441: NOP4
4445: PUSH
4446: NOP4
4450: PPUSH
4451: NOP4
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: NOP4
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: NOP4
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: NOP4
4485: AND
4486: PUSH
4487: NOP4
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: NOP4
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: NOP4
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: NOP4
4523: PUSH
4524: NOP4
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: NOP4
4535: PPUSH
4536: NOP4
4540: PUSH
4541: NOP4
4545: ARRAY
4546: PPUSH
4547: NOP4
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: NOP4
4559: PUSH
4560: NOP4
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: NOP4
4571: GO 4577
// YouWinInMultiplayer ;
4573: NOP4
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: NOP4
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: NOP4
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: NOP4
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: NOP4
4623: PUSH
4624: NOP4
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: NOP4
4635: PUSH
4636: NOP4
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: NOP4
4648: PUSH
4649: NOP4
4653: PUSH
4654: NOP4
4658: PUSH
4659: NOP4
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: NOP4
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: NOP4
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: NOP4
4743: NOT
4744: PUSH
4745: NOP4
4749: NOT
4750: OR
4751: PUSH
4752: NOP4
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: NOP4
4769: PUSH
4770: NOP4
4774: PPUSH
4775: NOP4
4779: PPUSH
4780: NOP4
4784: PUSH
4785: NOP4
4789: ARRAY
4790: PUSH
4791: NOP4
4795: PLUS
4796: PPUSH
4797: NOP4
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: NOP4
4814: NOT
4815: PUSH
4816: NOP4
4820: NOT
4821: OR
4822: PUSH
4823: NOP4
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: NOP4
4840: PUSH
4841: NOP4
4845: PUSH
4846: NOP4
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: NOP4
4864: PUSH
4865: NOP4
4869: PPUSH
4870: NOP4
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: NOP4
4883: PPUSH
4884: NOP4
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: NOP4
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: NOP4
4910: PUSH
4911: NOP4
4915: PUSH
4916: NOP4
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: NOP4
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: NOP4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: NOP4
4961: PUSH
4962: NOP4
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: NOP4
4975: PUSH
4976: NOP4
4980: ARRAY
4981: PUSH
4982: NOP4
4986: PUSH
4987: NOP4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: NOP4
5000: PUSH
5001: NOP4
5005: PUSH
5006: NOP4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: NOP4
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: NOP4
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: NOP4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: NOP4
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: NOP4
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: NOP4
5074: PPUSH
5075: NOP4
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: NOP4
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: NOP4
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: NOP4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: NOP4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: NOP4
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: NOP4
5173: PPUSH
5174: NOP4
5178: PUSH
5179: NOP4
5183: ARRAY
5184: PPUSH
5185: NOP4
// if IsDrivenBy ( i ) then
5189: NOP4
5193: PPUSH
5194: NOP4
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: NOP4
5204: PPUSH
5205: NOP4
5209: PPUSH
5210: NOP4
5214: PUSH
5215: NOP4
5219: ARRAY
5220: PPUSH
5221: NOP4
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: NOP4
5229: PPUSH
5230: NOP4
5234: PPUSH
5235: NOP4
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: NOP4
5249: PPUSH
5250: NOP4
// j := j + 1 ;
5254: NOP4
5258: PUSH
5259: NOP4
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: NOP4
5272: PUSH
5273: NOP4
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: NOP4
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: NOP4
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: NOP4
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: NOP4
5365: PPUSH
5366: NOP4
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: NOP4
5381: PUSH
5382: NOP4
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: NOP4
5396: PUSH
5397: NOP4
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: NOP4
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: NOP4
5426: NOT
5427: PUSH
5428: NOP4
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: NOP4
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: NOP4
5453: PPUSH
5454: NOP4
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: NOP4
5470: NOT
5471: PUSH
5472: NOP4
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: NOP4
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: NOP4
5497: PPUSH
5498: NOP4
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: NOP4
5514: NOT
5515: PUSH
5516: NOP4
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: NOP4
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: NOP4
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: NOP4
5567: PPUSH
5568: NOP4
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: NOP4
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: NOP4
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: NOP4
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: NOP4
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: NOP4
5620: PUSH
5621: NOP4
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: NOP4
5630: PUSH
5631: NOP4
5635: PPUSH
5636: NOP4
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: NOP4
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: NOP4
5656: PUSH
5657: NOP4
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: NOP4
5666: PUSH
5667: NOP4
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: NOP4
5679: PPUSH
5680: NOP4
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: NOP4
5693: DIFF
5694: PPUSH
5695: NOP4
5699: PPUSH
5700: NOP4
5704: ST_TO_ADDR
// if nearest_unit then
5705: NOP4
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: NOP4
5715: PUSH
5716: NOP4
5720: PPUSH
5721: NOP4
5725: ST_TO_ADDR
// if not side and not side2 then
5726: NOP4
5730: NOT
5731: PUSH
5732: NOP4
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: NOP4
5746: PUSH
5747: NOP4
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: NOP4
5758: PPUSH
5759: NOP4
5763: PPUSH
5764: NOP4
5768: GO 5818
// begin if side then
5770: NOP4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: NOP4
5780: PPUSH
5781: NOP4
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: NOP4
// if side2 then
5794: NOP4
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: NOP4
5804: PPUSH
5805: NOP4
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: NOP4
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: NOP4
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: NOP4
5838: PPUSH
5839: NOP4
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: NOP4
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: NOP4
5878: ST_TO_ADDR
// side_bot := side ;
5879: NOP4
5883: PUSH
5884: NOP4
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: NOP4
5893: PUSH
5894: NOP4
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: NOP4
5909: PUSH
5910: NOP4
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: NOP4
5922: PPUSH
5923: NOP4
5927: PPUSH
5928: NOP4
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: NOP4
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: NOP4
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: NOP4
5999: PUSH
6000: NOP4
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: NOP4
6012: PPUSH
6013: NOP4
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: NOP4
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: NOP4
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: NOP4
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: NOP4
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: NOP4
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: NOP4
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: NOP4
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: NOP4
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: NOP4
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: NOP4
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: NOP4
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: NOP4
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: NOP4
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: NOP4
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: NOP4
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: NOP4
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: NOP4
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: NOP4
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: NOP4
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: NOP4
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: NOP4
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: NOP4
6377: PUSH
6378: NOP4
6382: PUSH
6383: NOP4
6387: PUSH
6388: NOP4
6392: PUSH
6393: NOP4
6397: PUSH
6398: NOP4
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: NOP4
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: NOP4
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: NOP4
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: NOP4
6511: PPUSH
6512: NOP4
// un := CreateVehicle ;
6516: NOP4
6520: PUSH
6521: NOP4
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: NOP4
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: NOP4
6541: PPUSH
6542: NOP4
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: NOP4
6550: PPUSH
6551: NOP4
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: NOP4
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: NOP4
// un2 := CreateHuman ;
6579: NOP4
6583: PUSH
6584: NOP4
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: NOP4
6593: PPUSH
6594: NOP4
6598: PPUSH
6599: NOP4
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: NOP4
6607: PUSH
6608: NOP4
6612: PPUSH
6613: NOP4
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: NOP4
6630: PUSH
6631: NOP4
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: NOP4
6657: PPUSH
6658: NOP4
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: NOP4
6667: PUSH
6668: NOP4
6672: PPUSH
6673: NOP4
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: NOP4
6690: PUSH
6691: NOP4
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: NOP4
6717: PPUSH
6718: NOP4
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: NOP4
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: NOP4
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: NOP4
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: NOP4
6777: PPUSH
6778: NOP4
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: NOP4
6790: PUSH
6791: NOP4
6795: PPUSH
6796: NOP4
6800: ST_TO_ADDR
// if d < 3 then
6801: NOP4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: NOP4
6815: PUSH
6816: NOP4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: NOP4
6831: PUSH
6832: NOP4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: NOP4
6851: PPUSH
6852: NOP4
// un := CreateHuman ;
6856: NOP4
6860: PUSH
6861: NOP4
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: NOP4
6870: PPUSH
6871: NOP4
6875: PPUSH
6876: NOP4
// PlaceHumanInUnit ( un , i ) ;
6880: NOP4
6884: PPUSH
6885: NOP4
6889: PPUSH
6890: NOP4
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: NOP4
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: NOP4
6915: PPUSH
6916: NOP4
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: NOP4
6940: PUSH
6941: NOP4
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: NOP4
6953: PPUSH
6954: NOP4
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: NOP4
6969: PPUSH
6970: NOP4
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: NOP4
6994: PUSH
6995: NOP4
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: NOP4
7007: PPUSH
7008: NOP4
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: NOP4
7023: PPUSH
7024: NOP4
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: NOP4
7040: PUSH
7041: NOP4
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: NOP4
7053: PPUSH
7054: NOP4
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: NOP4
7126: PUSH
7127: NOP4
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: NOP4
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: NOP4
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: NOP4
7203: PUSH
7204: NOP4
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: NOP4
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: NOP4
// InitHc ;
7221: NOP4
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: NOP4
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: NOP4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: NOP4
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: NOP4
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: NOP4
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: NOP4
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: NOP4
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: NOP4
// un := CreateVehicle ;
7377: NOP4
7381: PUSH
7382: NOP4
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: NOP4
7391: PUSH
7392: NOP4
7396: PPUSH
7397: NOP4
7401: PUSH
7402: NOP4
7406: PUSH
7407: NOP4
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: NOP4
7425: PPUSH
7426: NOP4
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: NOP4
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: NOP4
7446: PPUSH
7447: NOP4
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: NOP4
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: NOP4
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: NOP4
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: NOP4
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: NOP4
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: NOP4
7519: PUSH
7520: NOP4
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: NOP4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: NOP4
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: NOP4
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: NOP4
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: NOP4
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: NOP4
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: NOP4
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: NOP4
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: NOP4
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: NOP4
7785: PUSH
7786: NOP4
7790: PPUSH
7791: NOP4
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: NOP4
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: NOP4
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: NOP4
7858: PPUSH
7859: NOP4
7863: PPUSH
7864: NOP4
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: NOP4
// until MC_GetProduceList ( base ) = 0 ;
7875: NOP4
7879: PPUSH
7880: NOP4
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: NOP4
// for i = 1 to coords do
7897: NOP4
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: NOP4
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: NOP4
7919: PUSH
7920: NOP4
7924: PPUSH
7925: NOP4
7929: PUSH
7930: NOP4
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: NOP4
7944: PUSH
7945: NOP4
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: NOP4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: NOP4
7971: PUSH
7972: NOP4
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: NOP4
7983: PUSH
7984: NOP4
7988: ST_TO_ADDR
// target := i ;
7989: NOP4
7993: PUSH
7994: NOP4
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: NOP4
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: NOP4
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: NOP4
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: NOP4
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: NOP4
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: NOP4
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: NOP4
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: NOP4
8209: PPUSH
8210: NOP4
8214: PUSH
8215: NOP4
8219: ARRAY
8220: PPUSH
8221: NOP4
8225: PPUSH
8226: NOP4
8230: PPUSH
8231: NOP4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: NOP4
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: NOP4
8253: PUSH
8254: NOP4
8258: EQUAL
8259: AND
8260: PUSH
8261: NOP4
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: NOP4
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: NOP4
8286: PUSH
8287: NOP4
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: NOP4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: NOP4
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: NOP4
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: NOP4
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: NOP4
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: NOP4
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: NOP4
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: NOP4
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: NOP4
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: NOP4
8512: PUSH
8513: NOP4
8517: PPUSH
8518: NOP4
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: NOP4
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: NOP4
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: NOP4
8583: PPUSH
8584: NOP4
8588: PPUSH
8589: NOP4
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: NOP4
// until MC_GetProduceList ( base ) = 0 ;
8600: NOP4
8604: PPUSH
8605: NOP4
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: NOP4
// for i = 1 to coords do
8622: NOP4
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: NOP4
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: NOP4
8644: PUSH
8645: NOP4
8649: PPUSH
8650: NOP4
8654: PUSH
8655: NOP4
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: NOP4
8669: PUSH
8670: NOP4
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: NOP4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: NOP4
8696: PUSH
8697: NOP4
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: NOP4
8708: PUSH
8709: NOP4
8713: ST_TO_ADDR
// target := i ;
8714: NOP4
8718: PUSH
8719: NOP4
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: NOP4
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: NOP4
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: NOP4
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: NOP4
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: NOP4
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: NOP4
8854: PPUSH
8855: NOP4
8859: PUSH
8860: NOP4
8864: ARRAY
8865: PPUSH
8866: NOP4
8870: PPUSH
8871: NOP4
8875: PPUSH
8876: NOP4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: NOP4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: NOP4
8899: PPUSH
8900: NOP4
8904: PPUSH
8905: NOP4
// artifact_get := true ;
8909: NOP4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: NOP4
8928: PUSH
8929: NOP4
8933: PPUSH
8934: NOP4
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: NOP4
8943: PUSH
8944: NOP4
8948: IN
8949: NOT
8950: PUSH
8951: NOP4
8955: PUSH
8956: NOP4
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: NOP4
8968: PPUSH
8969: NOP4
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: NOP4
8983: PPUSH
8984: NOP4
// if side in mc_sides then
8988: NOP4
8992: PUSH
8993: NOP4
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: NOP4
9004: PUSH
9005: NOP4
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: NOP4
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: NOP4
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: NOP4
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: NOP4
9038: PPUSH
9039: NOP4
// if multi_commanders and multi_custom_commanders then
9043: NOP4
9047: PUSH
9048: NOP4
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: NOP4
9059: PUSH
9060: NOP4
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: NOP4
9071: PUSH
9072: NOP4
9076: PPUSH
9077: NOP4
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: NOP4
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: NOP4
9094: PUSH
9095: NOP4
9099: PUSH
9100: NOP4
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: NOP4
9110: PPUSH
9111: NOP4
// end ; MCE_UnitDestroyed ( un ) ;
9115: NOP4
9119: PPUSH
9120: NOP4
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: NOP4
9131: PPUSH
9132: NOP4
9136: PPUSH
9137: NOP4
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: NOP4
9152: PPUSH
9153: NOP4
9157: PUSH
9158: NOP4
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: NOP4
9169: PPUSH
9170: NOP4
9174: PPUSH
9175: NOP4
9179: PPUSH
9180: NOP4
9184: PPUSH
9185: NOP4
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: NOP4
9193: PPUSH
9194: NOP4
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: NOP4
9207: PPUSH
9208: NOP4
9212: PUSH
9213: NOP4
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: NOP4
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: NOP4
9232: PPUSH
9233: NOP4
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: NOP4
// base_names := Delete ( base_names , 1 ) ;
9246: NOP4
9250: PUSH
9251: NOP4
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: NOP4
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: NOP4
9268: PPUSH
9269: NOP4
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: NOP4
9280: PPUSH
9281: NOP4
9285: PPUSH
9286: NOP4
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: NOP4
9297: PPUSH
9298: NOP4
9302: PPUSH
9303: NOP4
9307: PPUSH
9308: NOP4
9312: PPUSH
9313: NOP4
9317: PPUSH
9318: NOP4
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: NOP4
9334: PUSH
9335: NOP4
9339: PPUSH
9340: NOP4
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: NOP4
9349: PUSH
9350: NOP4
9354: IN
9355: NOT
9356: PUSH
9357: NOP4
9361: PUSH
9362: NOP4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: NOP4
9374: PPUSH
9375: NOP4
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: NOP4
9383: PPUSH
9384: NOP4
9388: PPUSH
9389: NOP4
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: NOP4
9400: PPUSH
9401: NOP4
9405: PPUSH
9406: NOP4
9410: PPUSH
9411: NOP4
9415: PPUSH
9416: NOP4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: NOP4
9427: PPUSH
9428: NOP4
9432: PPUSH
9433: NOP4
9437: PPUSH
9438: NOP4
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: NOP4
9449: PPUSH
9450: NOP4
9454: PPUSH
9455: NOP4
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: NOP4
9466: PPUSH
9467: NOP4
9471: PPUSH
9472: NOP4
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: NOP4
9483: PPUSH
9484: NOP4
9488: PPUSH
9489: NOP4
9493: PPUSH
9494: NOP4
9498: PPUSH
9499: NOP4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: NOP4
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: NOP4
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: NOP4
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: NOP4
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: NOP4
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: NOP4
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: NOP4
9594: PPUSH
9595: NOP4
// x := 5 ;
9599: NOP4
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: NOP4
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: NOP4
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: NOP4
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: NOP4
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: NOP4
9656: PUSH
9657: NOP4
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: NOP4
9668: PPUSH
9669: NOP4
9673: PUSH
9674: NOP4
9678: PUSH
9679: NOP4
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: NOP4
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: NOP4
// end ; for i in areas do
9704: NOP4
9708: PUSH
9709: NOP4
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: NOP4
// CreateCratesArea ( x , i , true ) ;
9724: NOP4
9728: PPUSH
9729: NOP4
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: NOP4
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: NOP4
9749: PUSH
9750: NOP4
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: NOP4
9763: PUSH
9764: NOP4
9768: PUSH
9769: NOP4
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: NOP4
9783: PUSH
9784: NOP4
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: NOP4
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: NOP4
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: NOP4
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: NOP4
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: NOP4
9833: NOT
9834: PUSH
9835: NOP4
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: NOP4
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: NOP4
9865: PUSH
9866: NOP4
9870: PUSH
9871: NOP4
9875: STR
9876: PPUSH
9877: NOP4
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: NOP4
9888: PUSH
9889: NOP4
9893: PPUSH
9894: NOP4
9898: ST_TO_ADDR
// result := unit ;
9899: NOP4
9903: PUSH
9904: NOP4
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: NOP4
9922: NOT
9923: PUSH
9924: NOP4
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10702
// case nation of nation_american :
9934: NOP4
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: NOP4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10626
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10395
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
10170: NOP4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: LD_INT 88
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: LIST
10390: LIST
10391: LIST
10392: ST_TO_ADDR
10393: GO 10626
10395: LD_INT 3
10397: DOUBLE
10398: EQUAL
10399: IFTRUE 10403
10401: GO 10625
10403: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10404: NOP4
10408: PUSH
10409: LD_INT 46
10411: PUSH
10412: LD_INT 47
10414: PUSH
10415: LD_INT 1
10417: PUSH
10418: LD_INT 2
10420: PUSH
10421: LD_INT 82
10423: PUSH
10424: LD_INT 83
10426: PUSH
10427: LD_INT 84
10429: PUSH
10430: LD_INT 85
10432: PUSH
10433: LD_INT 86
10435: PUSH
10436: LD_INT 11
10438: PUSH
10439: LD_INT 9
10441: PUSH
10442: LD_INT 20
10444: PUSH
10445: LD_INT 19
10447: PUSH
10448: LD_INT 21
10450: PUSH
10451: LD_INT 24
10453: PUSH
10454: LD_INT 22
10456: PUSH
10457: LD_INT 25
10459: PUSH
10460: LD_INT 28
10462: PUSH
10463: LD_INT 29
10465: PUSH
10466: LD_INT 30
10468: PUSH
10469: LD_INT 31
10471: PUSH
10472: LD_INT 37
10474: PUSH
10475: LD_INT 38
10477: PUSH
10478: LD_INT 32
10480: PUSH
10481: LD_INT 27
10483: PUSH
10484: LD_INT 33
10486: PUSH
10487: LD_INT 69
10489: PUSH
10490: LD_INT 39
10492: PUSH
10493: LD_INT 34
10495: PUSH
10496: LD_INT 40
10498: PUSH
10499: LD_INT 71
10501: PUSH
10502: LD_INT 23
10504: PUSH
10505: LD_INT 44
10507: PUSH
10508: LD_INT 48
10510: PUSH
10511: LD_INT 49
10513: PUSH
10514: LD_INT 50
10516: PUSH
10517: LD_INT 51
10519: PUSH
10520: LD_INT 52
10522: PUSH
10523: LD_INT 53
10525: PUSH
10526: LD_INT 54
10528: PUSH
10529: LD_INT 55
10531: PUSH
10532: LD_INT 56
10534: PUSH
10535: LD_INT 57
10537: PUSH
10538: LD_INT 58
10540: PUSH
10541: LD_INT 59
10543: PUSH
10544: LD_INT 63
10546: PUSH
10547: LD_INT 64
10549: PUSH
10550: LD_INT 65
10552: PUSH
10553: LD_INT 82
10555: PUSH
10556: LD_INT 83
10558: PUSH
10559: LD_INT 84
10561: PUSH
10562: LD_INT 85
10564: PUSH
10565: LD_INT 86
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: LIST
10619: LIST
10620: LIST
10621: LIST
10622: ST_TO_ADDR
10623: GO 10626
10625: POP
// if state > - 1 and state < 3 then
10626: NOP4
10630: PUSH
10631: LD_INT 1
10633: NEG
10634: GREATER
10635: PUSH
10636: NOP4
10640: PUSH
10641: LD_INT 3
10643: LESS
10644: AND
10645: IFFALSE 10702
// for i in result do
10647: NOP4
10651: PUSH
10652: NOP4
10656: PUSH
10657: FOR_IN
10658: IFFALSE 10700
// if GetTech ( i , side ) <> state then
10660: NOP4
10664: PPUSH
10665: NOP4
10669: PPUSH
10670: NOP4
10674: PUSH
10675: NOP4
10679: NONEQUAL
10680: IFFALSE 10698
// result := result diff i ;
10682: NOP4
10686: PUSH
10687: NOP4
10691: PUSH
10692: NOP4
10696: DIFF
10697: ST_TO_ADDR
10698: GO 10657
10700: POP
10701: POP
// end ;
10702: LD_VAR 0 4
10706: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// result := true ;
10712: NOP4
10716: PUSH
10717: LD_INT 1
10719: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10720: NOP4
10724: PUSH
10725: NOP4
10729: PPUSH
10730: NOP4
10734: ST_TO_ADDR
// if not tmp then
10735: NOP4
10739: NOT
10740: IFFALSE 10744
// exit ;
10742: GO 10793
// for i in tmp do
10744: NOP4
10748: PUSH
10749: NOP4
10753: PUSH
10754: FOR_IN
10755: IFFALSE 10791
// if GetTech ( i , side ) <> state_researched then
10757: NOP4
10761: PPUSH
10762: NOP4
10766: PPUSH
10767: NOP4
10771: PUSH
10772: LD_INT 2
10774: NONEQUAL
10775: IFFALSE 10789
// begin result := false ;
10777: NOP4
10781: PUSH
10782: LD_INT 0
10784: ST_TO_ADDR
// exit ;
10785: POP
10786: POP
10787: GO 10793
// end ;
10789: GO 10754
10791: POP
10792: POP
// end ;
10793: LD_VAR 0 3
10797: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10798: LD_INT 0
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10813: NOP4
10817: NOT
10818: PUSH
10819: NOP4
10823: PPUSH
10824: NOP4
10828: PUSH
10829: LD_INT 9
10831: NONEQUAL
10832: OR
10833: IFFALSE 10837
// exit ;
10835: GO 11410
// side := GetSide ( unit ) ;
10837: NOP4
10841: PUSH
10842: NOP4
10846: PPUSH
10847: NOP4
10851: ST_TO_ADDR
// tech_space := tech_spacanom ;
10852: NOP4
10856: PUSH
10857: LD_INT 29
10859: ST_TO_ADDR
// tech_time := tech_taurad ;
10860: NOP4
10864: PUSH
10865: LD_INT 28
10867: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10868: NOP4
10872: PUSH
10873: NOP4
10877: PPUSH
10878: NOP4
10882: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10883: NOP4
10887: PPUSH
10888: NOP4
10892: PUSH
10893: LD_INT 2
10895: EQUAL
10896: IFFALSE 10900
// exit ;
10898: GO 11410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10900: NOP4
10904: PUSH
10905: LD_INT 81
10907: PUSH
10908: NOP4
10912: PUSH
10913: EMPTY
10914: LIST
10915: LIST
10916: PUSH
10917: LD_INT 3
10919: PUSH
10920: LD_INT 21
10922: PUSH
10923: LD_INT 3
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PPUSH
10938: NOP4
10942: ST_TO_ADDR
// if not tmp then
10943: NOP4
10947: NOT
10948: IFFALSE 10952
// exit ;
10950: GO 11410
// if in_unit then
10952: NOP4
10956: IFFALSE 10980
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10958: NOP4
10962: PUSH
10963: NOP4
10967: PPUSH
10968: NOP4
10972: PPUSH
10973: NOP4
10977: ST_TO_ADDR
10978: GO 11000
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10980: NOP4
10984: PUSH
10985: NOP4
10989: PPUSH
10990: NOP4
10994: PPUSH
10995: NOP4
10999: ST_TO_ADDR
// if not enemy then
11000: NOP4
11004: NOT
11005: IFFALSE 11009
// exit ;
11007: GO 11410
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11009: NOP4
11013: PUSH
11014: NOP4
11018: PPUSH
11019: NOP4
11023: PPUSH
11024: NOP4
11028: PUSH
11029: LD_INT 13
11031: GREATER
11032: AND
11033: PUSH
11034: NOP4
11038: PPUSH
11039: NOP4
11043: PPUSH
11044: NOP4
11048: PUSH
11049: LD_INT 12
11051: GREATER
11052: OR
11053: IFFALSE 11057
// exit ;
11055: GO 11410
// missile := [ 1 ] ;
11057: NOP4
11061: PUSH
11062: LD_INT 1
11064: PUSH
11065: EMPTY
11066: LIST
11067: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11068: NOP4
11072: PPUSH
11073: NOP4
11077: PPUSH
11078: NOP4
11082: IFFALSE 11111
// missile := Insert ( missile , missile + 1 , 2 ) ;
11084: NOP4
11088: PUSH
11089: NOP4
11093: PPUSH
11094: NOP4
11098: PUSH
11099: LD_INT 1
11101: PLUS
11102: PPUSH
11103: LD_INT 2
11105: PPUSH
11106: NOP4
11110: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11111: NOP4
11115: PPUSH
11116: NOP4
11120: PPUSH
11121: NOP4
11125: PUSH
11126: NOP4
11130: PPUSH
11131: NOP4
11135: PPUSH
11136: NOP4
11140: PPUSH
11141: NOP4
11145: NOT
11146: AND
11147: IFFALSE 11176
// missile := Insert ( missile , missile + 1 , 3 ) ;
11149: NOP4
11153: PUSH
11154: NOP4
11158: PPUSH
11159: NOP4
11163: PUSH
11164: LD_INT 1
11166: PLUS
11167: PPUSH
11168: LD_INT 3
11170: PPUSH
11171: NOP4
11175: ST_TO_ADDR
// if missile < 2 then
11176: NOP4
11180: PUSH
11181: LD_INT 2
11183: LESS
11184: IFFALSE 11188
// exit ;
11186: GO 11410
// x := GetX ( enemy ) ;
11188: NOP4
11192: PUSH
11193: NOP4
11197: PPUSH
11198: NOP4
11202: ST_TO_ADDR
// y := GetY ( enemy ) ;
11203: NOP4
11207: PUSH
11208: NOP4
11212: PPUSH
11213: NOP4
11217: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11218: NOP4
11222: PUSH
11223: NOP4
11227: PUSH
11228: LD_INT 1
11230: NEG
11231: PPUSH
11232: LD_INT 1
11234: PPUSH
11235: NOP4
11239: PLUS
11240: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11241: NOP4
11245: PUSH
11246: NOP4
11250: PUSH
11251: LD_INT 1
11253: NEG
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: NOP4
11262: PLUS
11263: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11264: NOP4
11268: PPUSH
11269: NOP4
11273: PPUSH
11274: NOP4
11278: NOT
11279: IFFALSE 11301
// begin _x := x ;
11281: NOP4
11285: PUSH
11286: NOP4
11290: ST_TO_ADDR
// _y := y ;
11291: NOP4
11295: PUSH
11296: NOP4
11300: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11301: NOP4
11305: PUSH
11306: LD_INT 1
11308: PPUSH
11309: NOP4
11313: PPUSH
11314: NOP4
11318: ST_TO_ADDR
// case i of 1 :
11319: NOP4
11323: PUSH
11324: LD_INT 1
11326: DOUBLE
11327: EQUAL
11328: IFTRUE 11332
11330: GO 11349
11332: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11333: NOP4
11337: PPUSH
11338: NOP4
11342: PPUSH
11343: NOP4
11347: GO 11410
11349: LD_INT 2
11351: DOUBLE
11352: EQUAL
11353: IFTRUE 11357
11355: GO 11379
11357: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11358: NOP4
11362: PPUSH
11363: NOP4
11367: PPUSH
11368: NOP4
11372: PPUSH
11373: NOP4
11377: GO 11410
11379: LD_INT 3
11381: DOUBLE
11382: EQUAL
11383: IFTRUE 11387
11385: GO 11409
11387: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11388: NOP4
11392: PPUSH
11393: NOP4
11397: PPUSH
11398: NOP4
11402: PPUSH
11403: NOP4
11407: GO 11410
11409: POP
// end ;
11410: LD_VAR 0 2
11414: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11415: LD_INT 0
11417: PPUSH
11418: PPUSH
11419: PPUSH
11420: PPUSH
11421: PPUSH
11422: PPUSH
// if not unit or not building then
11423: NOP4
11427: NOT
11428: PUSH
11429: NOP4
11433: NOT
11434: OR
11435: IFFALSE 11439
// exit ;
11437: GO 11597
// x := GetX ( building ) ;
11439: NOP4
11443: PUSH
11444: NOP4
11448: PPUSH
11449: NOP4
11453: ST_TO_ADDR
// y := GetY ( building ) ;
11454: NOP4
11458: PUSH
11459: NOP4
11463: PPUSH
11464: NOP4
11468: ST_TO_ADDR
// for i = 0 to 5 do
11469: NOP4
11473: PUSH
11474: DOUBLE
11475: LD_INT 0
11477: DEC
11478: ST_TO_ADDR
11479: LD_INT 5
11481: PUSH
11482: FOR_TO
11483: IFFALSE 11595
// begin _x := ShiftX ( x , i , 3 ) ;
11485: NOP4
11489: PUSH
11490: NOP4
11494: PPUSH
11495: NOP4
11499: PPUSH
11500: LD_INT 3
11502: PPUSH
11503: NOP4
11507: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11508: NOP4
11512: PUSH
11513: NOP4
11517: PPUSH
11518: NOP4
11522: PPUSH
11523: LD_INT 3
11525: PPUSH
11526: NOP4
11530: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11531: NOP4
11535: PPUSH
11536: NOP4
11540: PPUSH
11541: NOP4
11545: NOT
11546: IFFALSE 11550
// continue ;
11548: GO 11482
// if HexInfo ( _x , _y ) = 0 then
11550: NOP4
11554: PPUSH
11555: NOP4
11559: PPUSH
11560: NOP4
11564: PUSH
11565: LD_INT 0
11567: EQUAL
11568: IFFALSE 11593
// begin ComMoveXY ( unit , _x , _y ) ;
11570: NOP4
11574: PPUSH
11575: NOP4
11579: PPUSH
11580: NOP4
11584: PPUSH
11585: NOP4
// exit ;
11589: POP
11590: POP
11591: GO 11597
// end ; end ;
11593: GO 11482
11595: POP
11596: POP
// end ;
11597: LD_VAR 0 3
11601: RET
// export function ScanBase ( side , base_area ) ; begin
11602: LD_INT 0
11604: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11605: NOP4
11609: PUSH
11610: NOP4
11614: PPUSH
11615: LD_INT 81
11617: PUSH
11618: NOP4
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PPUSH
11627: NOP4
11631: ST_TO_ADDR
// end ;
11632: LD_VAR 0 3
11636: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11637: LD_INT 0
11639: PPUSH
11640: PPUSH
11641: PPUSH
11642: PPUSH
// result := false ;
11643: NOP4
11647: PUSH
11648: LD_INT 0
11650: ST_TO_ADDR
// side := GetSide ( unit ) ;
11651: NOP4
11655: PUSH
11656: NOP4
11660: PPUSH
11661: NOP4
11665: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11666: NOP4
11670: PUSH
11671: NOP4
11675: PPUSH
11676: NOP4
11680: ST_TO_ADDR
// case nat of 1 :
11681: NOP4
11685: PUSH
11686: LD_INT 1
11688: DOUBLE
11689: EQUAL
11690: IFTRUE 11694
11692: GO 11705
11694: POP
// tech := tech_lassight ; 2 :
11695: NOP4
11699: PUSH
11700: LD_INT 12
11702: ST_TO_ADDR
11703: GO 11744
11705: LD_INT 2
11707: DOUBLE
11708: EQUAL
11709: IFTRUE 11713
11711: GO 11724
11713: POP
// tech := tech_mortar ; 3 :
11714: NOP4
11718: PUSH
11719: LD_INT 41
11721: ST_TO_ADDR
11722: GO 11744
11724: LD_INT 3
11726: DOUBLE
11727: EQUAL
11728: IFTRUE 11732
11730: GO 11743
11732: POP
// tech := tech_bazooka ; end ;
11733: NOP4
11737: PUSH
11738: LD_INT 44
11740: ST_TO_ADDR
11741: GO 11744
11743: POP
// if Researched ( side , tech ) then
11744: NOP4
11748: PPUSH
11749: NOP4
11753: PPUSH
11754: NOP4
11758: IFFALSE 11785
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11760: NOP4
11764: PUSH
11765: LD_INT 5
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: LD_INT 9
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: LIST
11778: PUSH
11779: NOP4
11783: ARRAY
11784: ST_TO_ADDR
// end ;
11785: LD_VAR 0 2
11789: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11790: LD_INT 0
11792: PPUSH
11793: PPUSH
11794: PPUSH
// if not mines then
11795: NOP4
11799: NOT
11800: IFFALSE 11804
// exit ;
11802: GO 11948
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11804: NOP4
11808: PUSH
11809: LD_INT 81
11811: PUSH
11812: NOP4
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: PUSH
11821: LD_INT 3
11823: PUSH
11824: LD_INT 21
11826: PUSH
11827: LD_INT 3
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PUSH
11838: EMPTY
11839: LIST
11840: LIST
11841: PPUSH
11842: NOP4
11846: ST_TO_ADDR
// for i in mines do
11847: NOP4
11851: PUSH
11852: NOP4
11856: PUSH
11857: FOR_IN
11858: IFFALSE 11946
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11860: NOP4
11864: PUSH
11865: LD_INT 1
11867: ARRAY
11868: PPUSH
11869: NOP4
11873: PUSH
11874: LD_INT 2
11876: ARRAY
11877: PPUSH
11878: NOP4
11882: NOT
11883: IFFALSE 11887
// continue ;
11885: GO 11857
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11887: NOP4
11891: PUSH
11892: LD_INT 1
11894: ARRAY
11895: PPUSH
11896: NOP4
11900: PUSH
11901: LD_INT 2
11903: ARRAY
11904: PPUSH
11905: NOP4
11909: PUSH
11910: NOP4
11914: IN
11915: IFFALSE 11944
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11917: NOP4
11921: PUSH
11922: LD_INT 1
11924: ARRAY
11925: PPUSH
11926: NOP4
11930: PUSH
11931: LD_INT 2
11933: ARRAY
11934: PPUSH
11935: NOP4
11939: PPUSH
11940: NOP4
// end ;
11944: GO 11857
11946: POP
11947: POP
// end ;
11948: LD_VAR 0 3
11952: RET
// export function Count ( array ) ; var i ; begin
11953: LD_INT 0
11955: PPUSH
11956: PPUSH
// result := 0 ;
11957: NOP4
11961: PUSH
11962: LD_INT 0
11964: ST_TO_ADDR
// for i in array do
11965: NOP4
11969: PUSH
11970: NOP4
11974: PUSH
11975: FOR_IN
11976: IFFALSE 12000
// if i then
11978: NOP4
11982: IFFALSE 11998
// result := result + 1 ;
11984: NOP4
11988: PUSH
11989: NOP4
11993: PUSH
11994: LD_INT 1
11996: PLUS
11997: ST_TO_ADDR
11998: GO 11975
12000: POP
12001: POP
// end ;
12002: LD_VAR 0 2
12006: RET
// export function IsEmpty ( building ) ; begin
12007: LD_INT 0
12009: PPUSH
// if not building then
12010: NOP4
12014: NOT
12015: IFFALSE 12019
// exit ;
12017: GO 12062
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12019: NOP4
12023: PUSH
12024: NOP4
12028: PUSH
12029: LD_INT 22
12031: PUSH
12032: NOP4
12036: PPUSH
12037: NOP4
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PUSH
12046: LD_INT 58
12048: PUSH
12049: EMPTY
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PPUSH
12056: NOP4
12060: IN
12061: ST_TO_ADDR
// end ;
12062: LD_VAR 0 2
12066: RET
// export function IsNotFull ( building ) ; begin
12067: LD_INT 0
12069: PPUSH
// if not building then
12070: NOP4
12074: NOT
12075: IFFALSE 12079
// exit ;
12077: GO 12098
// result := UnitsInside ( building ) < 6 ;
12079: NOP4
12083: PUSH
12084: NOP4
12088: PPUSH
12089: NOP4
12093: PUSH
12094: LD_INT 6
12096: LESS
12097: ST_TO_ADDR
// end ;
12098: LD_VAR 0 2
12102: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12103: LD_INT 0
12105: PPUSH
12106: PPUSH
12107: PPUSH
12108: PPUSH
// tmp := [ ] ;
12109: NOP4
12113: PUSH
12114: EMPTY
12115: ST_TO_ADDR
// list := [ ] ;
12116: NOP4
12120: PUSH
12121: EMPTY
12122: ST_TO_ADDR
// for i = 16 to 25 do
12123: NOP4
12127: PUSH
12128: DOUBLE
12129: LD_INT 16
12131: DEC
12132: ST_TO_ADDR
12133: LD_INT 25
12135: PUSH
12136: FOR_TO
12137: IFFALSE 12210
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12139: NOP4
12143: PUSH
12144: NOP4
12148: PUSH
12149: LD_INT 22
12151: PUSH
12152: NOP4
12156: PPUSH
12157: NOP4
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: PUSH
12166: LD_INT 91
12168: PUSH
12169: NOP4
12173: PUSH
12174: LD_INT 6
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 30
12184: PUSH
12185: NOP4
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: LIST
12198: PUSH
12199: EMPTY
12200: LIST
12201: PPUSH
12202: NOP4
12206: ADD
12207: ST_TO_ADDR
12208: GO 12136
12210: POP
12211: POP
// for i = 1 to tmp do
12212: NOP4
12216: PUSH
12217: DOUBLE
12218: LD_INT 1
12220: DEC
12221: ST_TO_ADDR
12222: NOP4
12226: PUSH
12227: FOR_TO
12228: IFFALSE 12316
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12230: NOP4
12234: PUSH
12235: NOP4
12239: PUSH
12240: NOP4
12244: PUSH
12245: NOP4
12249: ARRAY
12250: PPUSH
12251: NOP4
12255: PUSH
12256: NOP4
12260: PUSH
12261: NOP4
12265: ARRAY
12266: PPUSH
12267: NOP4
12271: PUSH
12272: NOP4
12276: PUSH
12277: NOP4
12281: ARRAY
12282: PPUSH
12283: NOP4
12287: PUSH
12288: NOP4
12292: PUSH
12293: NOP4
12297: ARRAY
12298: PPUSH
12299: NOP4
12303: PUSH
12304: EMPTY
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: PUSH
12310: EMPTY
12311: LIST
12312: ADD
12313: ST_TO_ADDR
12314: GO 12227
12316: POP
12317: POP
// result := list ;
12318: NOP4
12322: PUSH
12323: NOP4
12327: ST_TO_ADDR
// end ;
12328: LD_VAR 0 2
12332: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12333: LD_INT 0
12335: PPUSH
12336: PPUSH
12337: PPUSH
12338: PPUSH
12339: PPUSH
12340: PPUSH
12341: PPUSH
// if not factory then
12342: NOP4
12346: NOT
12347: IFFALSE 12351
// exit ;
12349: GO 12944
// if control = control_apeman then
12351: NOP4
12355: PUSH
12356: LD_INT 5
12358: EQUAL
12359: IFFALSE 12468
// begin tmp := UnitsInside ( factory ) ;
12361: NOP4
12365: PUSH
12366: NOP4
12370: PPUSH
12371: NOP4
12375: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12376: NOP4
12380: PPUSH
12381: LD_INT 25
12383: PUSH
12384: LD_INT 12
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: PPUSH
12391: NOP4
12395: NOT
12396: IFFALSE 12406
// control := control_manual ;
12398: NOP4
12402: PUSH
12403: LD_INT 1
12405: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12406: NOP4
12410: PUSH
12411: NOP4
12415: PPUSH
12416: NOP4
12420: ST_TO_ADDR
// if tmp then
12421: NOP4
12425: IFFALSE 12468
// begin for i in tmp do
12427: NOP4
12431: PUSH
12432: NOP4
12436: PUSH
12437: FOR_IN
12438: IFFALSE 12466
// if i [ 1 ] = b_ext_radio then
12440: NOP4
12444: PUSH
12445: LD_INT 1
12447: ARRAY
12448: PUSH
12449: LD_INT 22
12451: EQUAL
12452: IFFALSE 12464
// begin control := control_remote ;
12454: NOP4
12458: PUSH
12459: LD_INT 2
12461: ST_TO_ADDR
// break ;
12462: GO 12466
// end ;
12464: GO 12437
12466: POP
12467: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12468: NOP4
12472: PPUSH
12473: NOP4
12477: PPUSH
12478: NOP4
12482: PPUSH
12483: NOP4
12487: PPUSH
12488: NOP4
12492: PPUSH
12493: NOP4
12497: IFFALSE 12532
// begin result := [ chassis , engine , control , weapon ] ;
12499: NOP4
12503: PUSH
12504: NOP4
12508: PUSH
12509: NOP4
12513: PUSH
12514: NOP4
12518: PUSH
12519: NOP4
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: ST_TO_ADDR
// exit ;
12530: GO 12944
// end ; _chassis := AvailableChassisList ( factory ) ;
12532: NOP4
12536: PUSH
12537: NOP4
12541: PPUSH
12542: NOP4
12546: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12547: NOP4
12551: PUSH
12552: NOP4
12556: PPUSH
12557: NOP4
12561: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12562: NOP4
12566: PUSH
12567: NOP4
12571: PPUSH
12572: NOP4
12576: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12577: NOP4
12581: PUSH
12582: NOP4
12586: PPUSH
12587: NOP4
12591: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12592: NOP4
12596: NOT
12597: PUSH
12598: NOP4
12602: NOT
12603: OR
12604: PUSH
12605: NOP4
12609: NOT
12610: OR
12611: PUSH
12612: NOP4
12616: NOT
12617: OR
12618: IFFALSE 12653
// begin result := [ chassis , engine , control , weapon ] ;
12620: NOP4
12624: PUSH
12625: NOP4
12629: PUSH
12630: NOP4
12634: PUSH
12635: NOP4
12639: PUSH
12640: NOP4
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: ST_TO_ADDR
// exit ;
12651: GO 12944
// end ; if not chassis in _chassis then
12653: NOP4
12657: PUSH
12658: NOP4
12662: IN
12663: NOT
12664: IFFALSE 12690
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12666: NOP4
12670: PUSH
12671: NOP4
12675: PUSH
12676: LD_INT 1
12678: PPUSH
12679: NOP4
12683: PPUSH
12684: NOP4
12688: ARRAY
12689: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12690: NOP4
12694: PPUSH
12695: NOP4
12699: PPUSH
12700: NOP4
12704: NOT
12705: IFFALSE 12764
// repeat engine := _engine [ 1 ] ;
12707: NOP4
12711: PUSH
12712: NOP4
12716: PUSH
12717: LD_INT 1
12719: ARRAY
12720: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12721: NOP4
12725: PUSH
12726: NOP4
12730: PPUSH
12731: LD_INT 1
12733: PPUSH
12734: NOP4
12738: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12739: NOP4
12743: PPUSH
12744: NOP4
12748: PPUSH
12749: NOP4
12753: PUSH
12754: NOP4
12758: PUSH
12759: EMPTY
12760: EQUAL
12761: OR
12762: IFFALSE 12707
// if not control in _control then
12764: NOP4
12768: PUSH
12769: NOP4
12773: IN
12774: NOT
12775: IFFALSE 12801
// control := _control [ rand ( 1 , _control ) ] ;
12777: NOP4
12781: PUSH
12782: NOP4
12786: PUSH
12787: LD_INT 1
12789: PPUSH
12790: NOP4
12794: PPUSH
12795: NOP4
12799: ARRAY
12800: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12801: NOP4
12805: PPUSH
12806: NOP4
12810: PPUSH
12811: NOP4
12815: NOT
12816: IFFALSE 12875
// repeat weapon := _weapon [ 1 ] ;
12818: NOP4
12822: PUSH
12823: NOP4
12827: PUSH
12828: LD_INT 1
12830: ARRAY
12831: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12832: NOP4
12836: PUSH
12837: NOP4
12841: PPUSH
12842: LD_INT 1
12844: PPUSH
12845: NOP4
12849: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12850: NOP4
12854: PPUSH
12855: NOP4
12859: PPUSH
12860: NOP4
12864: PUSH
12865: NOP4
12869: PUSH
12870: EMPTY
12871: EQUAL
12872: OR
12873: IFFALSE 12818
// result := [ ] ;
12875: NOP4
12879: PUSH
12880: EMPTY
12881: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12882: NOP4
12886: PPUSH
12887: NOP4
12891: PPUSH
12892: NOP4
12896: PPUSH
12897: NOP4
12901: PPUSH
12902: NOP4
12906: PPUSH
12907: NOP4
12911: IFFALSE 12944
// result := [ chassis , engine , control , weapon ] ;
12913: NOP4
12917: PUSH
12918: NOP4
12922: PUSH
12923: NOP4
12927: PUSH
12928: NOP4
12932: PUSH
12933: NOP4
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: LIST
12942: LIST
12943: ST_TO_ADDR
// end ;
12944: LD_VAR 0 6
12948: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12949: LD_INT 0
12951: PPUSH
// if not chassis or not engine then
12952: NOP4
12956: NOT
12957: PUSH
12958: NOP4
12962: NOT
12963: OR
12964: IFFALSE 12968
// exit ;
12966: GO 13164
// case engine of engine_solar :
12968: NOP4
12972: PUSH
12973: LD_INT 2
12975: DOUBLE
12976: EQUAL
12977: IFTRUE 12981
12979: GO 13019
12981: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12982: NOP4
12986: PUSH
12987: LD_INT 11
12989: PUSH
12990: LD_INT 12
12992: PUSH
12993: LD_INT 13
12995: PUSH
12996: LD_INT 14
12998: PUSH
12999: LD_INT 1
13001: PUSH
13002: LD_INT 2
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: ST_TO_ADDR
13017: GO 13148
13019: LD_INT 1
13021: DOUBLE
13022: EQUAL
13023: IFTRUE 13027
13025: GO 13089
13027: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13028: NOP4
13032: PUSH
13033: LD_INT 11
13035: PUSH
13036: LD_INT 12
13038: PUSH
13039: LD_INT 13
13041: PUSH
13042: LD_INT 14
13044: PUSH
13045: LD_INT 1
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: LD_INT 3
13053: PUSH
13054: LD_INT 4
13056: PUSH
13057: LD_INT 5
13059: PUSH
13060: LD_INT 21
13062: PUSH
13063: LD_INT 23
13065: PUSH
13066: LD_INT 22
13068: PUSH
13069: LD_INT 24
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: LIST
13083: LIST
13084: LIST
13085: LIST
13086: ST_TO_ADDR
13087: GO 13148
13089: LD_INT 3
13091: DOUBLE
13092: EQUAL
13093: IFTRUE 13097
13095: GO 13147
13097: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13098: NOP4
13102: PUSH
13103: LD_INT 13
13105: PUSH
13106: LD_INT 14
13108: PUSH
13109: LD_INT 2
13111: PUSH
13112: LD_INT 3
13114: PUSH
13115: LD_INT 4
13117: PUSH
13118: LD_INT 5
13120: PUSH
13121: LD_INT 21
13123: PUSH
13124: LD_INT 22
13126: PUSH
13127: LD_INT 23
13129: PUSH
13130: LD_INT 24
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: ST_TO_ADDR
13145: GO 13148
13147: POP
// result := ( chassis in result ) ;
13148: NOP4
13152: PUSH
13153: NOP4
13157: PUSH
13158: NOP4
13162: IN
13163: ST_TO_ADDR
// end ;
13164: LD_VAR 0 3
13168: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13169: LD_INT 0
13171: PPUSH
// if not chassis or not weapon then
13172: NOP4
13176: NOT
13177: PUSH
13178: NOP4
13182: NOT
13183: OR
13184: IFFALSE 13188
// exit ;
13186: GO 14250
// case weapon of us_machine_gun :
13188: NOP4
13192: PUSH
13193: LD_INT 2
13195: DOUBLE
13196: EQUAL
13197: IFTRUE 13201
13199: GO 13231
13201: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13202: NOP4
13206: PUSH
13207: LD_INT 1
13209: PUSH
13210: LD_INT 2
13212: PUSH
13213: LD_INT 3
13215: PUSH
13216: LD_INT 4
13218: PUSH
13219: LD_INT 5
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: LIST
13226: LIST
13227: LIST
13228: ST_TO_ADDR
13229: GO 14234
13231: LD_INT 3
13233: DOUBLE
13234: EQUAL
13235: IFTRUE 13239
13237: GO 13269
13239: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13240: NOP4
13244: PUSH
13245: LD_INT 1
13247: PUSH
13248: LD_INT 2
13250: PUSH
13251: LD_INT 3
13253: PUSH
13254: LD_INT 4
13256: PUSH
13257: LD_INT 5
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: ST_TO_ADDR
13267: GO 14234
13269: LD_INT 11
13271: DOUBLE
13272: EQUAL
13273: IFTRUE 13277
13275: GO 13307
13277: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13278: NOP4
13282: PUSH
13283: LD_INT 1
13285: PUSH
13286: LD_INT 2
13288: PUSH
13289: LD_INT 3
13291: PUSH
13292: LD_INT 4
13294: PUSH
13295: LD_INT 5
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: LIST
13302: LIST
13303: LIST
13304: ST_TO_ADDR
13305: GO 14234
13307: LD_INT 4
13309: DOUBLE
13310: EQUAL
13311: IFTRUE 13315
13313: GO 13341
13315: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13316: NOP4
13320: PUSH
13321: LD_INT 2
13323: PUSH
13324: LD_INT 3
13326: PUSH
13327: LD_INT 4
13329: PUSH
13330: LD_INT 5
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: ST_TO_ADDR
13339: GO 14234
13341: LD_INT 5
13343: DOUBLE
13344: EQUAL
13345: IFTRUE 13349
13347: GO 13375
13349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13350: NOP4
13354: PUSH
13355: LD_INT 2
13357: PUSH
13358: LD_INT 3
13360: PUSH
13361: LD_INT 4
13363: PUSH
13364: LD_INT 5
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: ST_TO_ADDR
13373: GO 14234
13375: LD_INT 9
13377: DOUBLE
13378: EQUAL
13379: IFTRUE 13383
13381: GO 13409
13383: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13384: NOP4
13388: PUSH
13389: LD_INT 2
13391: PUSH
13392: LD_INT 3
13394: PUSH
13395: LD_INT 4
13397: PUSH
13398: LD_INT 5
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: LIST
13405: LIST
13406: ST_TO_ADDR
13407: GO 14234
13409: LD_INT 7
13411: DOUBLE
13412: EQUAL
13413: IFTRUE 13417
13415: GO 13443
13417: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13418: NOP4
13422: PUSH
13423: LD_INT 2
13425: PUSH
13426: LD_INT 3
13428: PUSH
13429: LD_INT 4
13431: PUSH
13432: LD_INT 5
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: ST_TO_ADDR
13441: GO 14234
13443: LD_INT 12
13445: DOUBLE
13446: EQUAL
13447: IFTRUE 13451
13449: GO 13477
13451: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13452: NOP4
13456: PUSH
13457: LD_INT 2
13459: PUSH
13460: LD_INT 3
13462: PUSH
13463: LD_INT 4
13465: PUSH
13466: LD_INT 5
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: LIST
13473: LIST
13474: ST_TO_ADDR
13475: GO 14234
13477: LD_INT 13
13479: DOUBLE
13480: EQUAL
13481: IFTRUE 13485
13483: GO 13511
13485: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13486: NOP4
13490: PUSH
13491: LD_INT 2
13493: PUSH
13494: LD_INT 3
13496: PUSH
13497: LD_INT 4
13499: PUSH
13500: LD_INT 5
13502: PUSH
13503: EMPTY
13504: LIST
13505: LIST
13506: LIST
13507: LIST
13508: ST_TO_ADDR
13509: GO 14234
13511: LD_INT 14
13513: DOUBLE
13514: EQUAL
13515: IFTRUE 13519
13517: GO 13537
13519: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13520: NOP4
13524: PUSH
13525: LD_INT 4
13527: PUSH
13528: LD_INT 5
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: ST_TO_ADDR
13535: GO 14234
13537: LD_INT 6
13539: DOUBLE
13540: EQUAL
13541: IFTRUE 13545
13543: GO 13563
13545: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13546: NOP4
13550: PUSH
13551: LD_INT 4
13553: PUSH
13554: LD_INT 5
13556: PUSH
13557: EMPTY
13558: LIST
13559: LIST
13560: ST_TO_ADDR
13561: GO 14234
13563: LD_INT 10
13565: DOUBLE
13566: EQUAL
13567: IFTRUE 13571
13569: GO 13589
13571: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13572: NOP4
13576: PUSH
13577: LD_INT 4
13579: PUSH
13580: LD_INT 5
13582: PUSH
13583: EMPTY
13584: LIST
13585: LIST
13586: ST_TO_ADDR
13587: GO 14234
13589: LD_INT 22
13591: DOUBLE
13592: EQUAL
13593: IFTRUE 13597
13595: GO 13623
13597: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13598: NOP4
13602: PUSH
13603: LD_INT 11
13605: PUSH
13606: LD_INT 12
13608: PUSH
13609: LD_INT 13
13611: PUSH
13612: LD_INT 14
13614: PUSH
13615: EMPTY
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: ST_TO_ADDR
13621: GO 14234
13623: LD_INT 23
13625: DOUBLE
13626: EQUAL
13627: IFTRUE 13631
13629: GO 13657
13631: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13632: NOP4
13636: PUSH
13637: LD_INT 11
13639: PUSH
13640: LD_INT 12
13642: PUSH
13643: LD_INT 13
13645: PUSH
13646: LD_INT 14
13648: PUSH
13649: EMPTY
13650: LIST
13651: LIST
13652: LIST
13653: LIST
13654: ST_TO_ADDR
13655: GO 14234
13657: LD_INT 24
13659: DOUBLE
13660: EQUAL
13661: IFTRUE 13665
13663: GO 13691
13665: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13666: NOP4
13670: PUSH
13671: LD_INT 11
13673: PUSH
13674: LD_INT 12
13676: PUSH
13677: LD_INT 13
13679: PUSH
13680: LD_INT 14
13682: PUSH
13683: EMPTY
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: ST_TO_ADDR
13689: GO 14234
13691: LD_INT 30
13693: DOUBLE
13694: EQUAL
13695: IFTRUE 13699
13697: GO 13725
13699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13700: NOP4
13704: PUSH
13705: LD_INT 11
13707: PUSH
13708: LD_INT 12
13710: PUSH
13711: LD_INT 13
13713: PUSH
13714: LD_INT 14
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: LIST
13721: LIST
13722: ST_TO_ADDR
13723: GO 14234
13725: LD_INT 25
13727: DOUBLE
13728: EQUAL
13729: IFTRUE 13733
13731: GO 13751
13733: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13734: NOP4
13738: PUSH
13739: LD_INT 13
13741: PUSH
13742: LD_INT 14
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: ST_TO_ADDR
13749: GO 14234
13751: LD_INT 27
13753: DOUBLE
13754: EQUAL
13755: IFTRUE 13759
13757: GO 13777
13759: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
13760: NOP4
13764: PUSH
13765: LD_INT 13
13767: PUSH
13768: LD_INT 14
13770: PUSH
13771: EMPTY
13772: LIST
13773: LIST
13774: ST_TO_ADDR
13775: GO 14234
13777: NOP4
13781: DOUBLE
13782: EQUAL
13783: IFTRUE 13787
13785: GO 13813
13787: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13788: NOP4
13792: PUSH
13793: LD_INT 11
13795: PUSH
13796: LD_INT 12
13798: PUSH
13799: LD_INT 13
13801: PUSH
13802: LD_INT 14
13804: PUSH
13805: EMPTY
13806: LIST
13807: LIST
13808: LIST
13809: LIST
13810: ST_TO_ADDR
13811: GO 14234
13813: LD_INT 28
13815: DOUBLE
13816: EQUAL
13817: IFTRUE 13821
13819: GO 13839
13821: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13822: NOP4
13826: PUSH
13827: LD_INT 13
13829: PUSH
13830: LD_INT 14
13832: PUSH
13833: EMPTY
13834: LIST
13835: LIST
13836: ST_TO_ADDR
13837: GO 14234
13839: LD_INT 29
13841: DOUBLE
13842: EQUAL
13843: IFTRUE 13847
13845: GO 13865
13847: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13848: NOP4
13852: PUSH
13853: LD_INT 13
13855: PUSH
13856: LD_INT 14
13858: PUSH
13859: EMPTY
13860: LIST
13861: LIST
13862: ST_TO_ADDR
13863: GO 14234
13865: LD_INT 31
13867: DOUBLE
13868: EQUAL
13869: IFTRUE 13873
13871: GO 13891
13873: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13874: NOP4
13878: PUSH
13879: LD_INT 13
13881: PUSH
13882: LD_INT 14
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: ST_TO_ADDR
13889: GO 14234
13891: LD_INT 26
13893: DOUBLE
13894: EQUAL
13895: IFTRUE 13899
13897: GO 13917
13899: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13900: NOP4
13904: PUSH
13905: LD_INT 13
13907: PUSH
13908: LD_INT 14
13910: PUSH
13911: EMPTY
13912: LIST
13913: LIST
13914: ST_TO_ADDR
13915: GO 14234
13917: LD_INT 42
13919: DOUBLE
13920: EQUAL
13921: IFTRUE 13925
13923: GO 13951
13925: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13926: NOP4
13930: PUSH
13931: LD_INT 21
13933: PUSH
13934: LD_INT 22
13936: PUSH
13937: LD_INT 23
13939: PUSH
13940: LD_INT 24
13942: PUSH
13943: EMPTY
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: ST_TO_ADDR
13949: GO 14234
13951: LD_INT 43
13953: DOUBLE
13954: EQUAL
13955: IFTRUE 13959
13957: GO 13985
13959: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13960: NOP4
13964: PUSH
13965: LD_INT 21
13967: PUSH
13968: LD_INT 22
13970: PUSH
13971: LD_INT 23
13973: PUSH
13974: LD_INT 24
13976: PUSH
13977: EMPTY
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: ST_TO_ADDR
13983: GO 14234
13985: LD_INT 44
13987: DOUBLE
13988: EQUAL
13989: IFTRUE 13993
13991: GO 14019
13993: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13994: NOP4
13998: PUSH
13999: LD_INT 21
14001: PUSH
14002: LD_INT 22
14004: PUSH
14005: LD_INT 23
14007: PUSH
14008: LD_INT 24
14010: PUSH
14011: EMPTY
14012: LIST
14013: LIST
14014: LIST
14015: LIST
14016: ST_TO_ADDR
14017: GO 14234
14019: LD_INT 45
14021: DOUBLE
14022: EQUAL
14023: IFTRUE 14027
14025: GO 14053
14027: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14028: NOP4
14032: PUSH
14033: LD_INT 21
14035: PUSH
14036: LD_INT 22
14038: PUSH
14039: LD_INT 23
14041: PUSH
14042: LD_INT 24
14044: PUSH
14045: EMPTY
14046: LIST
14047: LIST
14048: LIST
14049: LIST
14050: ST_TO_ADDR
14051: GO 14234
14053: LD_INT 49
14055: DOUBLE
14056: EQUAL
14057: IFTRUE 14061
14059: GO 14087
14061: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14062: NOP4
14066: PUSH
14067: LD_INT 21
14069: PUSH
14070: LD_INT 22
14072: PUSH
14073: LD_INT 23
14075: PUSH
14076: LD_INT 24
14078: PUSH
14079: EMPTY
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: ST_TO_ADDR
14085: GO 14234
14087: LD_INT 51
14089: DOUBLE
14090: EQUAL
14091: IFTRUE 14095
14093: GO 14121
14095: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14096: NOP4
14100: PUSH
14101: LD_INT 21
14103: PUSH
14104: LD_INT 22
14106: PUSH
14107: LD_INT 23
14109: PUSH
14110: LD_INT 24
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: ST_TO_ADDR
14119: GO 14234
14121: LD_INT 52
14123: DOUBLE
14124: EQUAL
14125: IFTRUE 14129
14127: GO 14155
14129: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14130: NOP4
14134: PUSH
14135: LD_INT 21
14137: PUSH
14138: LD_INT 22
14140: PUSH
14141: LD_INT 23
14143: PUSH
14144: LD_INT 24
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: ST_TO_ADDR
14153: GO 14234
14155: LD_INT 53
14157: DOUBLE
14158: EQUAL
14159: IFTRUE 14163
14161: GO 14181
14163: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14164: NOP4
14168: PUSH
14169: LD_INT 23
14171: PUSH
14172: LD_INT 24
14174: PUSH
14175: EMPTY
14176: LIST
14177: LIST
14178: ST_TO_ADDR
14179: GO 14234
14181: LD_INT 46
14183: DOUBLE
14184: EQUAL
14185: IFTRUE 14189
14187: GO 14207
14189: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14190: NOP4
14194: PUSH
14195: LD_INT 23
14197: PUSH
14198: LD_INT 24
14200: PUSH
14201: EMPTY
14202: LIST
14203: LIST
14204: ST_TO_ADDR
14205: GO 14234
14207: LD_INT 47
14209: DOUBLE
14210: EQUAL
14211: IFTRUE 14215
14213: GO 14233
14215: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14216: NOP4
14220: PUSH
14221: LD_INT 23
14223: PUSH
14224: LD_INT 24
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: ST_TO_ADDR
14231: GO 14234
14233: POP
// result := ( chassis in result ) ;
14234: NOP4
14238: PUSH
14239: NOP4
14243: PUSH
14244: NOP4
14248: IN
14249: ST_TO_ADDR
// end ;
14250: LD_VAR 0 3
14254: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14255: LD_INT 0
14257: PPUSH
14258: PPUSH
14259: PPUSH
14260: PPUSH
14261: PPUSH
14262: PPUSH
14263: PPUSH
// result := array ;
14264: NOP4
14268: PUSH
14269: NOP4
14273: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14274: NOP4
14278: NOT
14279: PUSH
14280: NOP4
14284: NOT
14285: OR
14286: PUSH
14287: NOP4
14291: NOT
14292: OR
14293: PUSH
14294: NOP4
14298: PUSH
14299: NOP4
14303: GREATER
14304: OR
14305: PUSH
14306: NOP4
14310: PUSH
14311: NOP4
14315: GREATER
14316: OR
14317: IFFALSE 14321
// exit ;
14319: GO 14617
// if direction then
14321: NOP4
14325: IFFALSE 14389
// begin d := 1 ;
14327: NOP4
14331: PUSH
14332: LD_INT 1
14334: ST_TO_ADDR
// if i_from > i_to then
14335: NOP4
14339: PUSH
14340: NOP4
14344: GREATER
14345: IFFALSE 14371
// length := ( array - i_from ) + i_to else
14347: NOP4
14351: PUSH
14352: NOP4
14356: PUSH
14357: NOP4
14361: MINUS
14362: PUSH
14363: NOP4
14367: PLUS
14368: ST_TO_ADDR
14369: GO 14387
// length := i_to - i_from ;
14371: NOP4
14375: PUSH
14376: NOP4
14380: PUSH
14381: NOP4
14385: MINUS
14386: ST_TO_ADDR
// end else
14387: GO 14450
// begin d := - 1 ;
14389: NOP4
14393: PUSH
14394: LD_INT 1
14396: NEG
14397: ST_TO_ADDR
// if i_from > i_to then
14398: NOP4
14402: PUSH
14403: NOP4
14407: GREATER
14408: IFFALSE 14428
// length := i_from - i_to else
14410: NOP4
14414: PUSH
14415: NOP4
14419: PUSH
14420: NOP4
14424: MINUS
14425: ST_TO_ADDR
14426: GO 14450
// length := ( array - i_to ) + i_from ;
14428: NOP4
14432: PUSH
14433: NOP4
14437: PUSH
14438: NOP4
14442: MINUS
14443: PUSH
14444: NOP4
14448: PLUS
14449: ST_TO_ADDR
// end ; if not length then
14450: NOP4
14454: NOT
14455: IFFALSE 14459
// exit ;
14457: GO 14617
// tmp := array ;
14459: NOP4
14463: PUSH
14464: NOP4
14468: ST_TO_ADDR
// for i = 1 to length do
14469: NOP4
14473: PUSH
14474: DOUBLE
14475: LD_INT 1
14477: DEC
14478: ST_TO_ADDR
14479: NOP4
14483: PUSH
14484: FOR_TO
14485: IFFALSE 14605
// begin for j = 1 to array do
14487: NOP4
14491: PUSH
14492: DOUBLE
14493: LD_INT 1
14495: DEC
14496: ST_TO_ADDR
14497: NOP4
14501: PUSH
14502: FOR_TO
14503: IFFALSE 14591
// begin k := j + d ;
14505: NOP4
14509: PUSH
14510: NOP4
14514: PUSH
14515: NOP4
14519: PLUS
14520: ST_TO_ADDR
// if k > array then
14521: NOP4
14525: PUSH
14526: NOP4
14530: GREATER
14531: IFFALSE 14541
// k := 1 ;
14533: NOP4
14537: PUSH
14538: LD_INT 1
14540: ST_TO_ADDR
// if not k then
14541: NOP4
14545: NOT
14546: IFFALSE 14558
// k := array ;
14548: NOP4
14552: PUSH
14553: NOP4
14557: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14558: NOP4
14562: PUSH
14563: NOP4
14567: PPUSH
14568: NOP4
14572: PPUSH
14573: NOP4
14577: PUSH
14578: NOP4
14582: ARRAY
14583: PPUSH
14584: NOP4
14588: ST_TO_ADDR
// end ;
14589: GO 14502
14591: POP
14592: POP
// array := tmp ;
14593: NOP4
14597: PUSH
14598: NOP4
14602: ST_TO_ADDR
// end ;
14603: GO 14484
14605: POP
14606: POP
// result := array ;
14607: NOP4
14611: PUSH
14612: NOP4
14616: ST_TO_ADDR
// end ;
14617: LD_VAR 0 5
14621: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14622: LD_INT 0
14624: PPUSH
14625: PPUSH
// result := 0 ;
14626: NOP4
14630: PUSH
14631: LD_INT 0
14633: ST_TO_ADDR
// if not array or not value in array then
14634: NOP4
14638: NOT
14639: PUSH
14640: NOP4
14644: PUSH
14645: NOP4
14649: IN
14650: NOT
14651: OR
14652: IFFALSE 14656
// exit ;
14654: GO 14710
// for i = 1 to array do
14656: NOP4
14660: PUSH
14661: DOUBLE
14662: LD_INT 1
14664: DEC
14665: ST_TO_ADDR
14666: NOP4
14670: PUSH
14671: FOR_TO
14672: IFFALSE 14708
// if value = array [ i ] then
14674: NOP4
14678: PUSH
14679: NOP4
14683: PUSH
14684: NOP4
14688: ARRAY
14689: EQUAL
14690: IFFALSE 14706
// begin result := i ;
14692: NOP4
14696: PUSH
14697: NOP4
14701: ST_TO_ADDR
// exit ;
14702: POP
14703: POP
14704: GO 14710
// end ;
14706: GO 14671
14708: POP
14709: POP
// end ;
14710: LD_VAR 0 3
14714: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14715: LD_INT 0
14717: PPUSH
// vc_chassis := chassis ;
14718: LD_ADDR_OWVAR 37
14722: PUSH
14723: NOP4
14727: ST_TO_ADDR
// vc_engine := engine ;
14728: LD_ADDR_OWVAR 39
14732: PUSH
14733: NOP4
14737: ST_TO_ADDR
// vc_control := control ;
14738: LD_ADDR_OWVAR 38
14742: PUSH
14743: NOP4
14747: ST_TO_ADDR
// vc_weapon := weapon ;
14748: LD_ADDR_OWVAR 40
14752: PUSH
14753: NOP4
14757: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14758: LD_ADDR_OWVAR 41
14762: PUSH
14763: NOP4
14767: ST_TO_ADDR
// end ;
14768: LD_VAR 0 6
14772: RET
// export function WantPlant ( unit ) ; var task ; begin
14773: LD_INT 0
14775: PPUSH
14776: PPUSH
// result := false ;
14777: NOP4
14781: PUSH
14782: LD_INT 0
14784: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14785: NOP4
14789: PUSH
14790: NOP4
14794: PPUSH
14795: NOP4
14799: ST_TO_ADDR
// if task then
14800: NOP4
14804: IFFALSE 14832
// if task [ 1 ] [ 1 ] = p then
14806: NOP4
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: PUSH
14815: LD_INT 1
14817: ARRAY
14818: PUSH
14819: LD_STRING p
14821: EQUAL
14822: IFFALSE 14832
// result := true ;
14824: NOP4
14828: PUSH
14829: LD_INT 1
14831: ST_TO_ADDR
// end ;
14832: LD_VAR 0 2
14836: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14837: LD_INT 0
14839: PPUSH
14840: PPUSH
14841: PPUSH
14842: PPUSH
// if pos < 1 then
14843: NOP4
14847: PUSH
14848: LD_INT 1
14850: LESS
14851: IFFALSE 14855
// exit ;
14853: GO 15158
// if pos = 1 then
14855: NOP4
14859: PUSH
14860: LD_INT 1
14862: EQUAL
14863: IFFALSE 14896
// result := Replace ( arr , pos [ 1 ] , value ) else
14865: NOP4
14869: PUSH
14870: NOP4
14874: PPUSH
14875: NOP4
14879: PUSH
14880: LD_INT 1
14882: ARRAY
14883: PPUSH
14884: NOP4
14888: PPUSH
14889: NOP4
14893: ST_TO_ADDR
14894: GO 15158
// begin tmp := arr ;
14896: NOP4
14900: PUSH
14901: NOP4
14905: ST_TO_ADDR
// s_arr := [ tmp ] ;
14906: NOP4
14910: PUSH
14911: NOP4
14915: PUSH
14916: EMPTY
14917: LIST
14918: ST_TO_ADDR
// for i = 1 to pos - 1 do
14919: NOP4
14923: PUSH
14924: DOUBLE
14925: LD_INT 1
14927: DEC
14928: ST_TO_ADDR
14929: NOP4
14933: PUSH
14934: LD_INT 1
14936: MINUS
14937: PUSH
14938: FOR_TO
14939: IFFALSE 14984
// begin tmp := tmp [ pos [ i ] ] ;
14941: NOP4
14945: PUSH
14946: NOP4
14950: PUSH
14951: NOP4
14955: PUSH
14956: NOP4
14960: ARRAY
14961: ARRAY
14962: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14963: NOP4
14967: PUSH
14968: NOP4
14972: PUSH
14973: NOP4
14977: PUSH
14978: EMPTY
14979: LIST
14980: ADD
14981: ST_TO_ADDR
// end ;
14982: GO 14938
14984: POP
14985: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14986: NOP4
14990: PUSH
14991: NOP4
14995: PPUSH
14996: NOP4
15000: PUSH
15001: NOP4
15005: ARRAY
15006: PPUSH
15007: NOP4
15011: PPUSH
15012: NOP4
15016: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15017: NOP4
15021: PUSH
15022: NOP4
15026: PPUSH
15027: NOP4
15031: PPUSH
15032: NOP4
15036: PPUSH
15037: NOP4
15041: ST_TO_ADDR
// for i = s_arr downto 2 do
15042: NOP4
15046: PUSH
15047: DOUBLE
15048: NOP4
15052: INC
15053: ST_TO_ADDR
15054: LD_INT 2
15056: PUSH
15057: FOR_DOWNTO
15058: IFFALSE 15142
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15060: NOP4
15064: PUSH
15065: NOP4
15069: PUSH
15070: NOP4
15074: PUSH
15075: LD_INT 1
15077: MINUS
15078: ARRAY
15079: PPUSH
15080: NOP4
15084: PUSH
15085: NOP4
15089: PUSH
15090: LD_INT 1
15092: MINUS
15093: ARRAY
15094: PPUSH
15095: NOP4
15099: PUSH
15100: NOP4
15104: ARRAY
15105: PPUSH
15106: NOP4
15110: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15111: NOP4
15115: PUSH
15116: NOP4
15120: PPUSH
15121: NOP4
15125: PUSH
15126: LD_INT 1
15128: MINUS
15129: PPUSH
15130: NOP4
15134: PPUSH
15135: NOP4
15139: ST_TO_ADDR
// end ;
15140: GO 15057
15142: POP
15143: POP
// result := s_arr [ 1 ] ;
15144: NOP4
15148: PUSH
15149: NOP4
15153: PUSH
15154: LD_INT 1
15156: ARRAY
15157: ST_TO_ADDR
// end ; end ;
15158: LD_VAR 0 4
15162: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15163: LD_INT 0
15165: PPUSH
15166: PPUSH
// if not list then
15167: NOP4
15171: NOT
15172: IFFALSE 15176
// exit ;
15174: GO 15267
// i := list [ pos1 ] ;
15176: NOP4
15180: PUSH
15181: NOP4
15185: PUSH
15186: NOP4
15190: ARRAY
15191: ST_TO_ADDR
// if not i then
15192: NOP4
15196: NOT
15197: IFFALSE 15201
// exit ;
15199: GO 15267
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15201: NOP4
15205: PUSH
15206: NOP4
15210: PPUSH
15211: NOP4
15215: PPUSH
15216: NOP4
15220: PUSH
15221: NOP4
15225: ARRAY
15226: PPUSH
15227: NOP4
15231: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15232: NOP4
15236: PUSH
15237: NOP4
15241: PPUSH
15242: NOP4
15246: PPUSH
15247: NOP4
15251: PPUSH
15252: NOP4
15256: ST_TO_ADDR
// result := list ;
15257: NOP4
15261: PUSH
15262: NOP4
15266: ST_TO_ADDR
// end ;
15267: LD_VAR 0 4
15271: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15272: LD_INT 0
15274: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15275: NOP4
15279: PUSH
15280: NOP4
15284: PPUSH
15285: NOP4
15289: PPUSH
15290: NOP4
15294: PPUSH
15295: NOP4
15299: PPUSH
15300: NOP4
15304: PPUSH
15305: NOP4
15309: PPUSH
15310: NOP4
15314: PPUSH
15315: NOP4
15319: ST_TO_ADDR
// end ;
15320: LD_VAR 0 5
15324: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15325: LD_INT 0
15327: PPUSH
15328: PPUSH
15329: PPUSH
15330: PPUSH
// if not list then
15331: NOP4
15335: NOT
15336: IFFALSE 15340
// exit ;
15338: GO 15728
// result := [ ] ;
15340: NOP4
15344: PUSH
15345: EMPTY
15346: ST_TO_ADDR
// for i in list do
15347: NOP4
15351: PUSH
15352: NOP4
15356: PUSH
15357: FOR_IN
15358: IFFALSE 15560
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15360: NOP4
15364: PUSH
15365: NOP4
15369: PPUSH
15370: NOP4
15374: PPUSH
15375: NOP4
15379: PPUSH
15380: NOP4
15384: ST_TO_ADDR
// if not result then
15385: NOP4
15389: NOT
15390: IFFALSE 15416
// result := [ [ i , tmp ] ] else
15392: NOP4
15396: PUSH
15397: NOP4
15401: PUSH
15402: NOP4
15406: PUSH
15407: EMPTY
15408: LIST
15409: LIST
15410: PUSH
15411: EMPTY
15412: LIST
15413: ST_TO_ADDR
15414: GO 15558
// begin if result [ result ] [ 2 ] < tmp then
15416: NOP4
15420: PUSH
15421: NOP4
15425: ARRAY
15426: PUSH
15427: LD_INT 2
15429: ARRAY
15430: PUSH
15431: NOP4
15435: LESS
15436: IFFALSE 15478
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15438: NOP4
15442: PUSH
15443: NOP4
15447: PPUSH
15448: NOP4
15452: PUSH
15453: LD_INT 1
15455: PLUS
15456: PPUSH
15457: NOP4
15461: PUSH
15462: NOP4
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: PPUSH
15471: NOP4
15475: ST_TO_ADDR
15476: GO 15558
// for j = 1 to result do
15478: NOP4
15482: PUSH
15483: DOUBLE
15484: LD_INT 1
15486: DEC
15487: ST_TO_ADDR
15488: NOP4
15492: PUSH
15493: FOR_TO
15494: IFFALSE 15556
// begin if tmp < result [ j ] [ 2 ] then
15496: NOP4
15500: PUSH
15501: NOP4
15505: PUSH
15506: NOP4
15510: ARRAY
15511: PUSH
15512: LD_INT 2
15514: ARRAY
15515: LESS
15516: IFFALSE 15554
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15518: NOP4
15522: PUSH
15523: NOP4
15527: PPUSH
15528: NOP4
15532: PPUSH
15533: NOP4
15537: PUSH
15538: NOP4
15542: PUSH
15543: EMPTY
15544: LIST
15545: LIST
15546: PPUSH
15547: NOP4
15551: ST_TO_ADDR
// break ;
15552: GO 15556
// end ; end ;
15554: GO 15493
15556: POP
15557: POP
// end ; end ;
15558: GO 15357
15560: POP
15561: POP
// if result and not asc then
15562: NOP4
15566: PUSH
15567: NOP4
15571: NOT
15572: AND
15573: IFFALSE 15648
// begin tmp := result ;
15575: NOP4
15579: PUSH
15580: NOP4
15584: ST_TO_ADDR
// for i = tmp downto 1 do
15585: NOP4
15589: PUSH
15590: DOUBLE
15591: NOP4
15595: INC
15596: ST_TO_ADDR
15597: LD_INT 1
15599: PUSH
15600: FOR_DOWNTO
15601: IFFALSE 15646
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15603: NOP4
15607: PUSH
15608: NOP4
15612: PPUSH
15613: NOP4
15617: PUSH
15618: NOP4
15622: MINUS
15623: PUSH
15624: LD_INT 1
15626: PLUS
15627: PPUSH
15628: NOP4
15632: PUSH
15633: NOP4
15637: ARRAY
15638: PPUSH
15639: NOP4
15643: ST_TO_ADDR
15644: GO 15600
15646: POP
15647: POP
// end ; tmp := [ ] ;
15648: NOP4
15652: PUSH
15653: EMPTY
15654: ST_TO_ADDR
// if mode then
15655: NOP4
15659: IFFALSE 15728
// begin for i = 1 to result do
15661: NOP4
15665: PUSH
15666: DOUBLE
15667: LD_INT 1
15669: DEC
15670: ST_TO_ADDR
15671: NOP4
15675: PUSH
15676: FOR_TO
15677: IFFALSE 15716
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15679: NOP4
15683: PUSH
15684: NOP4
15688: PPUSH
15689: NOP4
15693: PPUSH
15694: NOP4
15698: PUSH
15699: NOP4
15703: ARRAY
15704: PUSH
15705: LD_INT 1
15707: ARRAY
15708: PPUSH
15709: NOP4
15713: ST_TO_ADDR
15714: GO 15676
15716: POP
15717: POP
// result := tmp ;
15718: NOP4
15722: PUSH
15723: NOP4
15727: ST_TO_ADDR
// end ; end ;
15728: LD_VAR 0 6
15732: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15733: LD_INT 0
15735: PPUSH
15736: PPUSH
15737: PPUSH
15738: PPUSH
15739: PPUSH
15740: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15741: NOP4
15745: PUSH
15746: LD_INT 0
15748: PUSH
15749: LD_INT 0
15751: PUSH
15752: LD_INT 0
15754: PUSH
15755: EMPTY
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: LIST
15761: LIST
15762: ST_TO_ADDR
// if not x or not y then
15763: NOP4
15767: NOT
15768: PUSH
15769: NOP4
15773: NOT
15774: OR
15775: IFFALSE 15779
// exit ;
15777: GO 17431
// if not range then
15779: NOP4
15783: NOT
15784: IFFALSE 15794
// range := 10 ;
15786: NOP4
15790: PUSH
15791: LD_INT 10
15793: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15794: NOP4
15798: PUSH
15799: LD_INT 81
15801: PUSH
15802: NOP4
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PUSH
15811: LD_INT 92
15813: PUSH
15814: NOP4
15818: PUSH
15819: NOP4
15823: PUSH
15824: NOP4
15828: PUSH
15829: EMPTY
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: PUSH
15835: LD_INT 3
15837: PUSH
15838: LD_INT 21
15840: PUSH
15841: LD_INT 3
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: EMPTY
15853: LIST
15854: LIST
15855: LIST
15856: PPUSH
15857: NOP4
15861: ST_TO_ADDR
// if not tmp then
15862: NOP4
15866: NOT
15867: IFFALSE 15871
// exit ;
15869: GO 17431
// for i in tmp do
15871: NOP4
15875: PUSH
15876: NOP4
15880: PUSH
15881: FOR_IN
15882: IFFALSE 17406
// begin points := [ 0 , 0 , 0 ] ;
15884: NOP4
15888: PUSH
15889: LD_INT 0
15891: PUSH
15892: LD_INT 0
15894: PUSH
15895: LD_INT 0
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: LIST
15902: ST_TO_ADDR
// bpoints := 1 ;
15903: NOP4
15907: PUSH
15908: LD_INT 1
15910: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15911: NOP4
15915: PPUSH
15916: NOP4
15920: PUSH
15921: LD_INT 1
15923: DOUBLE
15924: EQUAL
15925: IFTRUE 15929
15927: GO 16507
15929: POP
// begin if GetClass ( i ) = 1 then
15930: NOP4
15934: PPUSH
15935: NOP4
15939: PUSH
15940: LD_INT 1
15942: EQUAL
15943: IFFALSE 15964
// points := [ 10 , 5 , 3 ] ;
15945: NOP4
15949: PUSH
15950: LD_INT 10
15952: PUSH
15953: LD_INT 5
15955: PUSH
15956: LD_INT 3
15958: PUSH
15959: EMPTY
15960: LIST
15961: LIST
15962: LIST
15963: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15964: NOP4
15968: PPUSH
15969: NOP4
15973: PUSH
15974: LD_INT 2
15976: PUSH
15977: LD_INT 3
15979: PUSH
15980: LD_INT 4
15982: PUSH
15983: EMPTY
15984: LIST
15985: LIST
15986: LIST
15987: IN
15988: IFFALSE 16009
// points := [ 3 , 2 , 1 ] ;
15990: NOP4
15994: PUSH
15995: LD_INT 3
15997: PUSH
15998: LD_INT 2
16000: PUSH
16001: LD_INT 1
16003: PUSH
16004: EMPTY
16005: LIST
16006: LIST
16007: LIST
16008: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16009: NOP4
16013: PPUSH
16014: NOP4
16018: PUSH
16019: LD_INT 5
16021: EQUAL
16022: IFFALSE 16043
// points := [ 130 , 5 , 2 ] ;
16024: NOP4
16028: PUSH
16029: LD_INT 130
16031: PUSH
16032: LD_INT 5
16034: PUSH
16035: LD_INT 2
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: LIST
16042: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16043: NOP4
16047: PPUSH
16048: NOP4
16052: PUSH
16053: LD_INT 8
16055: EQUAL
16056: IFFALSE 16077
// points := [ 35 , 35 , 30 ] ;
16058: NOP4
16062: PUSH
16063: LD_INT 35
16065: PUSH
16066: LD_INT 35
16068: PUSH
16069: LD_INT 30
16071: PUSH
16072: EMPTY
16073: LIST
16074: LIST
16075: LIST
16076: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16077: NOP4
16081: PPUSH
16082: NOP4
16086: PUSH
16087: LD_INT 9
16089: EQUAL
16090: IFFALSE 16111
// points := [ 20 , 55 , 40 ] ;
16092: NOP4
16096: PUSH
16097: LD_INT 20
16099: PUSH
16100: LD_INT 55
16102: PUSH
16103: LD_INT 40
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: LIST
16110: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16111: NOP4
16115: PPUSH
16116: NOP4
16120: PUSH
16121: LD_INT 12
16123: PUSH
16124: LD_INT 16
16126: PUSH
16127: EMPTY
16128: LIST
16129: LIST
16130: IN
16131: IFFALSE 16152
// points := [ 5 , 3 , 2 ] ;
16133: NOP4
16137: PUSH
16138: LD_INT 5
16140: PUSH
16141: LD_INT 3
16143: PUSH
16144: LD_INT 2
16146: PUSH
16147: EMPTY
16148: LIST
16149: LIST
16150: LIST
16151: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16152: NOP4
16156: PPUSH
16157: NOP4
16161: PUSH
16162: LD_INT 17
16164: EQUAL
16165: IFFALSE 16186
// points := [ 100 , 50 , 75 ] ;
16167: NOP4
16171: PUSH
16172: LD_INT 100
16174: PUSH
16175: LD_INT 50
16177: PUSH
16178: LD_INT 75
16180: PUSH
16181: EMPTY
16182: LIST
16183: LIST
16184: LIST
16185: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16186: NOP4
16190: PPUSH
16191: NOP4
16195: PUSH
16196: LD_INT 15
16198: EQUAL
16199: IFFALSE 16220
// points := [ 10 , 5 , 3 ] ;
16201: NOP4
16205: PUSH
16206: LD_INT 10
16208: PUSH
16209: LD_INT 5
16211: PUSH
16212: LD_INT 3
16214: PUSH
16215: EMPTY
16216: LIST
16217: LIST
16218: LIST
16219: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16220: NOP4
16224: PPUSH
16225: NOP4
16229: PUSH
16230: LD_INT 14
16232: EQUAL
16233: IFFALSE 16254
// points := [ 10 , 0 , 0 ] ;
16235: NOP4
16239: PUSH
16240: LD_INT 10
16242: PUSH
16243: LD_INT 0
16245: PUSH
16246: LD_INT 0
16248: PUSH
16249: EMPTY
16250: LIST
16251: LIST
16252: LIST
16253: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16254: NOP4
16258: PPUSH
16259: NOP4
16263: PUSH
16264: LD_INT 11
16266: EQUAL
16267: IFFALSE 16288
// points := [ 30 , 10 , 5 ] ;
16269: NOP4
16273: PUSH
16274: LD_INT 30
16276: PUSH
16277: LD_INT 10
16279: PUSH
16280: LD_INT 5
16282: PUSH
16283: EMPTY
16284: LIST
16285: LIST
16286: LIST
16287: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16288: NOP4
16292: PPUSH
16293: LD_INT 5
16295: PPUSH
16296: NOP4
16300: PUSH
16301: LD_INT 2
16303: EQUAL
16304: IFFALSE 16321
// bpoints := bpoints * 1.8 ;
16306: NOP4
16310: PUSH
16311: NOP4
16315: PUSH
16316: LD_REAL  1.80000000000000E+0000
16319: MUL
16320: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16321: NOP4
16325: PPUSH
16326: NOP4
16330: PUSH
16331: LD_INT 1
16333: PUSH
16334: LD_INT 2
16336: PUSH
16337: LD_INT 3
16339: PUSH
16340: LD_INT 4
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: LIST
16347: LIST
16348: IN
16349: PUSH
16350: NOP4
16354: PPUSH
16355: LD_INT 51
16357: PPUSH
16358: NOP4
16362: PUSH
16363: LD_INT 2
16365: EQUAL
16366: AND
16367: IFFALSE 16384
// bpoints := bpoints * 1.2 ;
16369: NOP4
16373: PUSH
16374: NOP4
16378: PUSH
16379: LD_REAL  1.20000000000000E+0000
16382: MUL
16383: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16384: NOP4
16388: PPUSH
16389: NOP4
16393: PUSH
16394: LD_INT 5
16396: PUSH
16397: LD_INT 7
16399: PUSH
16400: LD_INT 9
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: LIST
16407: IN
16408: PUSH
16409: NOP4
16413: PPUSH
16414: LD_INT 52
16416: PPUSH
16417: NOP4
16421: PUSH
16422: LD_INT 2
16424: EQUAL
16425: AND
16426: IFFALSE 16443
// bpoints := bpoints * 1.5 ;
16428: NOP4
16432: PUSH
16433: NOP4
16437: PUSH
16438: LD_REAL  1.50000000000000E+0000
16441: MUL
16442: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16443: NOP4
16447: PPUSH
16448: LD_INT 66
16450: PPUSH
16451: NOP4
16455: PUSH
16456: LD_INT 2
16458: EQUAL
16459: IFFALSE 16476
// bpoints := bpoints * 1.1 ;
16461: NOP4
16465: PUSH
16466: NOP4
16470: PUSH
16471: LD_REAL  1.10000000000000E+0000
16474: MUL
16475: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16476: NOP4
16480: PUSH
16481: NOP4
16485: PUSH
16486: NOP4
16490: PPUSH
16491: LD_INT 1
16493: PPUSH
16494: NOP4
16498: PUSH
16499: LD_REAL  1.15000000000000E+0000
16502: MUL
16503: MUL
16504: ST_TO_ADDR
// end ; unit_vehicle :
16505: GO 17335
16507: LD_INT 2
16509: DOUBLE
16510: EQUAL
16511: IFTRUE 16515
16513: GO 17323
16515: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16516: NOP4
16520: PPUSH
16521: NOP4
16525: PUSH
16526: LD_INT 2
16528: PUSH
16529: LD_INT 42
16531: PUSH
16532: LD_INT 24
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: LIST
16539: IN
16540: IFFALSE 16561
// points := [ 25 , 5 , 3 ] ;
16542: NOP4
16546: PUSH
16547: LD_INT 25
16549: PUSH
16550: LD_INT 5
16552: PUSH
16553: LD_INT 3
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: LIST
16560: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16561: NOP4
16565: PPUSH
16566: NOP4
16570: PUSH
16571: LD_INT 4
16573: PUSH
16574: LD_INT 43
16576: PUSH
16577: LD_INT 25
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: LIST
16584: IN
16585: IFFALSE 16606
// points := [ 40 , 15 , 5 ] ;
16587: NOP4
16591: PUSH
16592: LD_INT 40
16594: PUSH
16595: LD_INT 15
16597: PUSH
16598: LD_INT 5
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: LIST
16605: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16606: NOP4
16610: PPUSH
16611: NOP4
16615: PUSH
16616: LD_INT 3
16618: PUSH
16619: LD_INT 23
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: IN
16626: IFFALSE 16647
// points := [ 7 , 25 , 8 ] ;
16628: NOP4
16632: PUSH
16633: LD_INT 7
16635: PUSH
16636: LD_INT 25
16638: PUSH
16639: LD_INT 8
16641: PUSH
16642: EMPTY
16643: LIST
16644: LIST
16645: LIST
16646: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16647: NOP4
16651: PPUSH
16652: NOP4
16656: PUSH
16657: LD_INT 5
16659: PUSH
16660: LD_INT 27
16662: PUSH
16663: LD_INT 44
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: LIST
16670: IN
16671: IFFALSE 16692
// points := [ 14 , 50 , 16 ] ;
16673: NOP4
16677: PUSH
16678: LD_INT 14
16680: PUSH
16681: LD_INT 50
16683: PUSH
16684: LD_INT 16
16686: PUSH
16687: EMPTY
16688: LIST
16689: LIST
16690: LIST
16691: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16692: NOP4
16696: PPUSH
16697: NOP4
16701: PUSH
16702: LD_INT 6
16704: PUSH
16705: LD_INT 46
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: IN
16712: IFFALSE 16733
// points := [ 32 , 120 , 70 ] ;
16714: NOP4
16718: PUSH
16719: LD_INT 32
16721: PUSH
16722: LD_INT 120
16724: PUSH
16725: LD_INT 70
16727: PUSH
16728: EMPTY
16729: LIST
16730: LIST
16731: LIST
16732: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
16733: NOP4
16737: PPUSH
16738: NOP4
16742: PUSH
16743: LD_INT 7
16745: PUSH
16746: LD_INT 28
16748: PUSH
16749: LD_INT 45
16751: PUSH
16752: NOP4
16756: PUSH
16757: EMPTY
16758: LIST
16759: LIST
16760: LIST
16761: LIST
16762: IN
16763: IFFALSE 16784
// points := [ 35 , 20 , 45 ] ;
16765: NOP4
16769: PUSH
16770: LD_INT 35
16772: PUSH
16773: LD_INT 20
16775: PUSH
16776: LD_INT 45
16778: PUSH
16779: EMPTY
16780: LIST
16781: LIST
16782: LIST
16783: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16784: NOP4
16788: PPUSH
16789: NOP4
16793: PUSH
16794: LD_INT 47
16796: PUSH
16797: EMPTY
16798: LIST
16799: IN
16800: IFFALSE 16821
// points := [ 67 , 45 , 75 ] ;
16802: NOP4
16806: PUSH
16807: LD_INT 67
16809: PUSH
16810: LD_INT 45
16812: PUSH
16813: LD_INT 75
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: LIST
16820: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16821: NOP4
16825: PPUSH
16826: NOP4
16830: PUSH
16831: LD_INT 26
16833: PUSH
16834: EMPTY
16835: LIST
16836: IN
16837: IFFALSE 16858
// points := [ 120 , 30 , 80 ] ;
16839: NOP4
16843: PUSH
16844: LD_INT 120
16846: PUSH
16847: LD_INT 30
16849: PUSH
16850: LD_INT 80
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: LIST
16857: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16858: NOP4
16862: PPUSH
16863: NOP4
16867: PUSH
16868: LD_INT 22
16870: PUSH
16871: EMPTY
16872: LIST
16873: IN
16874: IFFALSE 16895
// points := [ 40 , 1 , 1 ] ;
16876: NOP4
16880: PUSH
16881: LD_INT 40
16883: PUSH
16884: LD_INT 1
16886: PUSH
16887: LD_INT 1
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: LIST
16894: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16895: NOP4
16899: PPUSH
16900: NOP4
16904: PUSH
16905: LD_INT 29
16907: PUSH
16908: EMPTY
16909: LIST
16910: IN
16911: IFFALSE 16932
// points := [ 70 , 200 , 400 ] ;
16913: NOP4
16917: PUSH
16918: LD_INT 70
16920: PUSH
16921: LD_INT 200
16923: PUSH
16924: LD_INT 400
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: LIST
16931: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16932: NOP4
16936: PPUSH
16937: NOP4
16941: PUSH
16942: LD_INT 14
16944: PUSH
16945: LD_INT 53
16947: PUSH
16948: EMPTY
16949: LIST
16950: LIST
16951: IN
16952: IFFALSE 16973
// points := [ 40 , 10 , 20 ] ;
16954: NOP4
16958: PUSH
16959: LD_INT 40
16961: PUSH
16962: LD_INT 10
16964: PUSH
16965: LD_INT 20
16967: PUSH
16968: EMPTY
16969: LIST
16970: LIST
16971: LIST
16972: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16973: NOP4
16977: PPUSH
16978: NOP4
16982: PUSH
16983: LD_INT 9
16985: PUSH
16986: EMPTY
16987: LIST
16988: IN
16989: IFFALSE 17010
// points := [ 5 , 70 , 20 ] ;
16991: NOP4
16995: PUSH
16996: LD_INT 5
16998: PUSH
16999: LD_INT 70
17001: PUSH
17002: LD_INT 20
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17010: NOP4
17014: PPUSH
17015: NOP4
17019: PUSH
17020: LD_INT 10
17022: PUSH
17023: EMPTY
17024: LIST
17025: IN
17026: IFFALSE 17047
// points := [ 35 , 110 , 70 ] ;
17028: NOP4
17032: PUSH
17033: LD_INT 35
17035: PUSH
17036: LD_INT 110
17038: PUSH
17039: LD_INT 70
17041: PUSH
17042: EMPTY
17043: LIST
17044: LIST
17045: LIST
17046: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17047: NOP4
17051: PPUSH
17052: NOP4
17056: PUSH
17057: LD_INT 25
17059: EQUAL
17060: IFFALSE 17081
// points := [ 80 , 65 , 100 ] ;
17062: NOP4
17066: PUSH
17067: LD_INT 80
17069: PUSH
17070: LD_INT 65
17072: PUSH
17073: LD_INT 100
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: LIST
17080: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17081: NOP4
17085: PPUSH
17086: NOP4
17090: PUSH
17091: LD_INT 1
17093: EQUAL
17094: IFFALSE 17129
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17096: NOP4
17100: PUSH
17101: NOP4
17105: PUSH
17106: NOP4
17110: PPUSH
17111: NOP4
17115: PPUSH
17116: LD_INT 3
17118: PPUSH
17119: NOP4
17123: PUSH
17124: LD_INT 4
17126: MUL
17127: MUL
17128: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17129: NOP4
17133: PPUSH
17134: NOP4
17138: PUSH
17139: LD_INT 2
17141: EQUAL
17142: IFFALSE 17193
// begin j := IsControledBy ( i ) ;
17144: NOP4
17148: PUSH
17149: NOP4
17153: PPUSH
17154: NOP4
17158: ST_TO_ADDR
// if j then
17159: NOP4
17163: IFFALSE 17193
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17165: NOP4
17169: PUSH
17170: NOP4
17174: PUSH
17175: NOP4
17179: PPUSH
17180: LD_INT 3
17182: PPUSH
17183: NOP4
17187: PUSH
17188: LD_INT 3
17190: MUL
17191: MUL
17192: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17193: NOP4
17197: PPUSH
17198: NOP4
17202: PUSH
17203: LD_INT 5
17205: PUSH
17206: LD_INT 6
17208: PUSH
17209: LD_INT 46
17211: PUSH
17212: LD_INT 44
17214: PUSH
17215: LD_INT 47
17217: PUSH
17218: LD_INT 45
17220: PUSH
17221: LD_INT 28
17223: PUSH
17224: LD_INT 7
17226: PUSH
17227: LD_INT 27
17229: PUSH
17230: LD_INT 29
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: LIST
17237: LIST
17238: LIST
17239: LIST
17240: LIST
17241: LIST
17242: LIST
17243: LIST
17244: IN
17245: PUSH
17246: NOP4
17250: PPUSH
17251: LD_INT 52
17253: PPUSH
17254: NOP4
17258: PUSH
17259: LD_INT 2
17261: EQUAL
17262: AND
17263: IFFALSE 17280
// bpoints := bpoints * 1.2 ;
17265: NOP4
17269: PUSH
17270: NOP4
17274: PUSH
17275: LD_REAL  1.20000000000000E+0000
17278: MUL
17279: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17280: NOP4
17284: PPUSH
17285: NOP4
17289: PUSH
17290: LD_INT 6
17292: PUSH
17293: LD_INT 46
17295: PUSH
17296: LD_INT 47
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: LIST
17303: IN
17304: IFFALSE 17321
// bpoints := bpoints * 1.2 ;
17306: NOP4
17310: PUSH
17311: NOP4
17315: PUSH
17316: LD_REAL  1.20000000000000E+0000
17319: MUL
17320: ST_TO_ADDR
// end ; unit_building :
17321: GO 17335
17323: LD_INT 3
17325: DOUBLE
17326: EQUAL
17327: IFTRUE 17331
17329: GO 17334
17331: POP
// ; end ;
17332: GO 17335
17334: POP
// for j = 1 to 3 do
17335: NOP4
17339: PUSH
17340: DOUBLE
17341: LD_INT 1
17343: DEC
17344: ST_TO_ADDR
17345: LD_INT 3
17347: PUSH
17348: FOR_TO
17349: IFFALSE 17402
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17351: NOP4
17355: PUSH
17356: NOP4
17360: PPUSH
17361: NOP4
17365: PPUSH
17366: NOP4
17370: PUSH
17371: NOP4
17375: ARRAY
17376: PUSH
17377: NOP4
17381: PUSH
17382: NOP4
17386: ARRAY
17387: PUSH
17388: NOP4
17392: MUL
17393: PLUS
17394: PPUSH
17395: NOP4
17399: ST_TO_ADDR
17400: GO 17348
17402: POP
17403: POP
// end ;
17404: GO 15881
17406: POP
17407: POP
// result := Replace ( result , 4 , tmp ) ;
17408: NOP4
17412: PUSH
17413: NOP4
17417: PPUSH
17418: LD_INT 4
17420: PPUSH
17421: NOP4
17425: PPUSH
17426: NOP4
17430: ST_TO_ADDR
// end ;
17431: LD_VAR 0 5
17435: RET
// export function DangerAtRange ( unit , range ) ; begin
17436: LD_INT 0
17438: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17439: NOP4
17443: PUSH
17444: NOP4
17448: PPUSH
17449: NOP4
17453: PPUSH
17454: NOP4
17458: PPUSH
17459: NOP4
17463: PPUSH
17464: NOP4
17468: PPUSH
17469: NOP4
17473: PPUSH
17474: NOP4
17478: PPUSH
17479: NOP4
17483: ST_TO_ADDR
// end ;
17484: LD_VAR 0 3
17488: RET
// export function DangerInArea ( side , area ) ; begin
17489: LD_INT 0
17491: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17492: NOP4
17496: PUSH
17497: NOP4
17501: PPUSH
17502: LD_INT 81
17504: PUSH
17505: NOP4
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: PPUSH
17514: NOP4
17518: ST_TO_ADDR
// end ;
17519: LD_VAR 0 3
17523: RET
// export function IsExtension ( b ) ; begin
17524: LD_INT 0
17526: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17527: NOP4
17531: PUSH
17532: NOP4
17536: PUSH
17537: LD_INT 23
17539: PUSH
17540: LD_INT 20
17542: PUSH
17543: LD_INT 22
17545: PUSH
17546: LD_INT 17
17548: PUSH
17549: LD_INT 24
17551: PUSH
17552: LD_INT 21
17554: PUSH
17555: LD_INT 19
17557: PUSH
17558: LD_INT 16
17560: PUSH
17561: LD_INT 25
17563: PUSH
17564: LD_INT 18
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: LIST
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: IN
17579: ST_TO_ADDR
// end ;
17580: LD_VAR 0 2
17584: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17585: LD_INT 0
17587: PPUSH
17588: PPUSH
17589: PPUSH
// result := [ ] ;
17590: NOP4
17594: PUSH
17595: EMPTY
17596: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17597: NOP4
17601: PUSH
17602: NOP4
17606: PPUSH
17607: LD_INT 21
17609: PUSH
17610: LD_INT 3
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: PPUSH
17617: NOP4
17621: ST_TO_ADDR
// if not tmp then
17622: NOP4
17626: NOT
17627: IFFALSE 17631
// exit ;
17629: GO 17695
// if checkLink then
17631: NOP4
17635: IFFALSE 17685
// begin for i in tmp do
17637: NOP4
17641: PUSH
17642: NOP4
17646: PUSH
17647: FOR_IN
17648: IFFALSE 17683
// if GetBase ( i ) <> base then
17650: NOP4
17654: PPUSH
17655: NOP4
17659: PUSH
17660: NOP4
17664: NONEQUAL
17665: IFFALSE 17681
// ComLinkToBase ( base , i ) ;
17667: NOP4
17671: PPUSH
17672: NOP4
17676: PPUSH
17677: NOP4
17681: GO 17647
17683: POP
17684: POP
// end ; result := tmp ;
17685: NOP4
17689: PUSH
17690: NOP4
17694: ST_TO_ADDR
// end ;
17695: LD_VAR 0 4
17699: RET
// export function ComComplete ( units , b ) ; var i ; begin
17700: LD_INT 0
17702: PPUSH
17703: PPUSH
// if not units then
17704: NOP4
17708: NOT
17709: IFFALSE 17713
// exit ;
17711: GO 17803
// for i in units do
17713: NOP4
17717: PUSH
17718: NOP4
17722: PUSH
17723: FOR_IN
17724: IFFALSE 17801
// if BuildingStatus ( b ) = bs_build then
17726: NOP4
17730: PPUSH
17731: NOP4
17735: PUSH
17736: LD_INT 1
17738: EQUAL
17739: IFFALSE 17799
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17741: NOP4
17745: PPUSH
17746: LD_STRING h
17748: PUSH
17749: NOP4
17753: PPUSH
17754: NOP4
17758: PUSH
17759: NOP4
17763: PPUSH
17764: NOP4
17768: PUSH
17769: NOP4
17773: PUSH
17774: LD_INT 0
17776: PUSH
17777: LD_INT 0
17779: PUSH
17780: LD_INT 0
17782: PUSH
17783: EMPTY
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: PUSH
17792: EMPTY
17793: LIST
17794: PPUSH
17795: NOP4
17799: GO 17723
17801: POP
17802: POP
// end ;
17803: LD_VAR 0 3
17807: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17808: LD_INT 0
17810: PPUSH
17811: PPUSH
17812: PPUSH
17813: PPUSH
17814: PPUSH
17815: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
17816: NOP4
17820: NOT
17821: PUSH
17822: NOP4
17826: PPUSH
17827: NOP4
17831: PUSH
17832: LD_INT 2
17834: NONEQUAL
17835: OR
17836: IFFALSE 17840
// exit ;
17838: GO 18156
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17840: NOP4
17844: PUSH
17845: LD_INT 22
17847: PUSH
17848: NOP4
17852: PPUSH
17853: NOP4
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: PUSH
17862: LD_INT 2
17864: PUSH
17865: LD_INT 30
17867: PUSH
17868: LD_INT 36
17870: PUSH
17871: EMPTY
17872: LIST
17873: LIST
17874: PUSH
17875: LD_INT 34
17877: PUSH
17878: LD_INT 31
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: LIST
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: PPUSH
17894: NOP4
17898: ST_TO_ADDR
// if not tmp then
17899: NOP4
17903: NOT
17904: IFFALSE 17908
// exit ;
17906: GO 18156
// result := [ ] ;
17908: NOP4
17912: PUSH
17913: EMPTY
17914: ST_TO_ADDR
// for i in tmp do
17915: NOP4
17919: PUSH
17920: NOP4
17924: PUSH
17925: FOR_IN
17926: IFFALSE 17997
// begin t := UnitsInside ( i ) ;
17928: NOP4
17932: PUSH
17933: NOP4
17937: PPUSH
17938: NOP4
17942: ST_TO_ADDR
// if t then
17943: NOP4
17947: IFFALSE 17995
// for j in t do
17949: NOP4
17953: PUSH
17954: NOP4
17958: PUSH
17959: FOR_IN
17960: IFFALSE 17993
// result := Replace ( result , result + 1 , j ) ;
17962: NOP4
17966: PUSH
17967: NOP4
17971: PPUSH
17972: NOP4
17976: PUSH
17977: LD_INT 1
17979: PLUS
17980: PPUSH
17981: NOP4
17985: PPUSH
17986: NOP4
17990: ST_TO_ADDR
17991: GO 17959
17993: POP
17994: POP
// end ;
17995: GO 17925
17997: POP
17998: POP
// if not result then
17999: NOP4
18003: NOT
18004: IFFALSE 18008
// exit ;
18006: GO 18156
// mech := result [ 1 ] ;
18008: NOP4
18012: PUSH
18013: NOP4
18017: PUSH
18018: LD_INT 1
18020: ARRAY
18021: ST_TO_ADDR
// if result > 1 then
18022: NOP4
18026: PUSH
18027: LD_INT 1
18029: GREATER
18030: IFFALSE 18142
// begin for i = 2 to result do
18032: NOP4
18036: PUSH
18037: DOUBLE
18038: LD_INT 2
18040: DEC
18041: ST_TO_ADDR
18042: NOP4
18046: PUSH
18047: FOR_TO
18048: IFFALSE 18140
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18050: NOP4
18054: PUSH
18055: NOP4
18059: PUSH
18060: NOP4
18064: ARRAY
18065: PPUSH
18066: LD_INT 3
18068: PPUSH
18069: NOP4
18073: PUSH
18074: NOP4
18078: PUSH
18079: NOP4
18083: ARRAY
18084: PPUSH
18085: NOP4
18089: MINUS
18090: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18091: NOP4
18095: PUSH
18096: NOP4
18100: PPUSH
18101: LD_INT 3
18103: PPUSH
18104: NOP4
18108: PUSH
18109: NOP4
18113: PPUSH
18114: NOP4
18118: MINUS
18119: GREATEREQUAL
18120: IFFALSE 18138
// mech := result [ i ] ;
18122: NOP4
18126: PUSH
18127: NOP4
18131: PUSH
18132: NOP4
18136: ARRAY
18137: ST_TO_ADDR
// end ;
18138: GO 18047
18140: POP
18141: POP
// end ; ComLinkTo ( vehicle , mech ) ;
18142: NOP4
18146: PPUSH
18147: NOP4
18151: PPUSH
18152: NOP4
// end ;
18156: LD_VAR 0 2
18160: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18161: LD_INT 0
18163: PPUSH
18164: PPUSH
18165: PPUSH
18166: PPUSH
18167: PPUSH
18168: PPUSH
18169: PPUSH
18170: PPUSH
18171: PPUSH
18172: PPUSH
18173: PPUSH
18174: PPUSH
18175: PPUSH
// result := [ ] ;
18176: NOP4
18180: PUSH
18181: EMPTY
18182: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18183: NOP4
18187: PPUSH
18188: NOP4
18192: PUSH
18193: LD_INT 0
18195: PUSH
18196: LD_INT 1
18198: PUSH
18199: EMPTY
18200: LIST
18201: LIST
18202: IN
18203: NOT
18204: IFFALSE 18208
// exit ;
18206: GO 19842
// if name then
18208: NOP4
18212: IFFALSE 18228
// SetBName ( base_dep , name ) ;
18214: NOP4
18218: PPUSH
18219: NOP4
18223: PPUSH
18224: NOP4
// base := GetBase ( base_dep ) ;
18228: NOP4
18232: PUSH
18233: NOP4
18237: PPUSH
18238: NOP4
18242: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18243: NOP4
18247: PUSH
18248: NOP4
18252: PPUSH
18253: NOP4
18257: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18258: NOP4
18262: PUSH
18263: NOP4
18267: PPUSH
18268: NOP4
18272: ST_TO_ADDR
// if sources then
18273: NOP4
18277: IFFALSE 18324
// for i = 1 to 3 do
18279: NOP4
18283: PUSH
18284: DOUBLE
18285: LD_INT 1
18287: DEC
18288: ST_TO_ADDR
18289: LD_INT 3
18291: PUSH
18292: FOR_TO
18293: IFFALSE 18322
// AddResourceType ( base , i , sources [ i ] ) ;
18295: NOP4
18299: PPUSH
18300: NOP4
18304: PPUSH
18305: NOP4
18309: PUSH
18310: NOP4
18314: ARRAY
18315: PPUSH
18316: NOP4
18320: GO 18292
18322: POP
18323: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18324: NOP4
18328: PUSH
18329: NOP4
18333: PPUSH
18334: NOP4
18338: PPUSH
18339: LD_INT 1
18341: PPUSH
18342: NOP4
18346: ST_TO_ADDR
// InitHc ;
18347: NOP4
// InitUc ;
18351: NOP4
// uc_side := side ;
18355: LD_ADDR_OWVAR 20
18359: PUSH
18360: NOP4
18364: ST_TO_ADDR
// uc_nation := nation ;
18365: LD_ADDR_OWVAR 21
18369: PUSH
18370: NOP4
18374: ST_TO_ADDR
// if buildings then
18375: NOP4
18379: IFFALSE 19701
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18381: NOP4
18385: PUSH
18386: NOP4
18390: PPUSH
18391: LD_INT 2
18393: PUSH
18394: LD_INT 30
18396: PUSH
18397: LD_INT 29
18399: PUSH
18400: EMPTY
18401: LIST
18402: LIST
18403: PUSH
18404: LD_INT 30
18406: PUSH
18407: LD_INT 30
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: PUSH
18414: EMPTY
18415: LIST
18416: LIST
18417: LIST
18418: PPUSH
18419: NOP4
18423: ST_TO_ADDR
// if tmp then
18424: NOP4
18428: IFFALSE 18476
// for i in tmp do
18430: NOP4
18434: PUSH
18435: NOP4
18439: PUSH
18440: FOR_IN
18441: IFFALSE 18474
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18443: NOP4
18447: PPUSH
18448: NOP4
18452: PPUSH
18453: NOP4
18457: PPUSH
18458: NOP4
18462: PPUSH
18463: NOP4
18467: PPUSH
18468: NOP4
18472: GO 18440
18474: POP
18475: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18476: NOP4
18480: PPUSH
18481: LD_INT 2
18483: PUSH
18484: LD_INT 30
18486: PUSH
18487: LD_INT 32
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: PUSH
18494: LD_INT 30
18496: PUSH
18497: LD_INT 33
18499: PUSH
18500: EMPTY
18501: LIST
18502: LIST
18503: PUSH
18504: EMPTY
18505: LIST
18506: LIST
18507: LIST
18508: PPUSH
18509: NOP4
18513: IFFALSE 18601
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18515: NOP4
18519: PUSH
18520: NOP4
18524: PPUSH
18525: LD_INT 2
18527: PUSH
18528: LD_INT 30
18530: PUSH
18531: LD_INT 32
18533: PUSH
18534: EMPTY
18535: LIST
18536: LIST
18537: PUSH
18538: LD_INT 30
18540: PUSH
18541: LD_INT 33
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: LIST
18552: PPUSH
18553: NOP4
18557: PUSH
18558: FOR_IN
18559: IFFALSE 18599
// begin if not GetBWeapon ( i ) then
18561: NOP4
18565: PPUSH
18566: NOP4
18570: NOT
18571: IFFALSE 18597
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18573: NOP4
18577: PPUSH
18578: NOP4
18582: PPUSH
18583: NOP4
18587: PPUSH
18588: NOP4
18592: PPUSH
18593: NOP4
// end ;
18597: GO 18558
18599: POP
18600: POP
// end ; for i = 1 to personel do
18601: NOP4
18605: PUSH
18606: DOUBLE
18607: LD_INT 1
18609: DEC
18610: ST_TO_ADDR
18611: NOP4
18615: PUSH
18616: FOR_TO
18617: IFFALSE 19681
// begin if i > 4 then
18619: NOP4
18623: PUSH
18624: LD_INT 4
18626: GREATER
18627: IFFALSE 18631
// break ;
18629: GO 19681
// case i of 1 :
18631: NOP4
18635: PUSH
18636: LD_INT 1
18638: DOUBLE
18639: EQUAL
18640: IFTRUE 18644
18642: GO 18724
18644: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18645: NOP4
18649: PUSH
18650: NOP4
18654: PPUSH
18655: LD_INT 22
18657: PUSH
18658: NOP4
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 58
18669: PUSH
18670: EMPTY
18671: LIST
18672: PUSH
18673: LD_INT 2
18675: PUSH
18676: LD_INT 30
18678: PUSH
18679: LD_INT 32
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: PUSH
18686: LD_INT 30
18688: PUSH
18689: LD_INT 4
18691: PUSH
18692: EMPTY
18693: LIST
18694: LIST
18695: PUSH
18696: LD_INT 30
18698: PUSH
18699: LD_INT 5
18701: PUSH
18702: EMPTY
18703: LIST
18704: LIST
18705: PUSH
18706: EMPTY
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: LIST
18716: PPUSH
18717: NOP4
18721: ST_TO_ADDR
18722: GO 18946
18724: LD_INT 2
18726: DOUBLE
18727: EQUAL
18728: IFTRUE 18732
18730: GO 18794
18732: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18733: NOP4
18737: PUSH
18738: NOP4
18742: PPUSH
18743: LD_INT 22
18745: PUSH
18746: NOP4
18750: PUSH
18751: EMPTY
18752: LIST
18753: LIST
18754: PUSH
18755: LD_INT 2
18757: PUSH
18758: LD_INT 30
18760: PUSH
18761: LD_INT 0
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 30
18770: PUSH
18771: LD_INT 1
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PPUSH
18787: NOP4
18791: ST_TO_ADDR
18792: GO 18946
18794: LD_INT 3
18796: DOUBLE
18797: EQUAL
18798: IFTRUE 18802
18800: GO 18864
18802: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18803: NOP4
18807: PUSH
18808: NOP4
18812: PPUSH
18813: LD_INT 22
18815: PUSH
18816: NOP4
18820: PUSH
18821: EMPTY
18822: LIST
18823: LIST
18824: PUSH
18825: LD_INT 2
18827: PUSH
18828: LD_INT 30
18830: PUSH
18831: LD_INT 2
18833: PUSH
18834: EMPTY
18835: LIST
18836: LIST
18837: PUSH
18838: LD_INT 30
18840: PUSH
18841: LD_INT 3
18843: PUSH
18844: EMPTY
18845: LIST
18846: LIST
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: LIST
18852: PUSH
18853: EMPTY
18854: LIST
18855: LIST
18856: PPUSH
18857: NOP4
18861: ST_TO_ADDR
18862: GO 18946
18864: LD_INT 4
18866: DOUBLE
18867: EQUAL
18868: IFTRUE 18872
18870: GO 18945
18872: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18873: NOP4
18877: PUSH
18878: NOP4
18882: PPUSH
18883: LD_INT 22
18885: PUSH
18886: NOP4
18890: PUSH
18891: EMPTY
18892: LIST
18893: LIST
18894: PUSH
18895: LD_INT 2
18897: PUSH
18898: LD_INT 30
18900: PUSH
18901: LD_INT 6
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PUSH
18908: LD_INT 30
18910: PUSH
18911: LD_INT 7
18913: PUSH
18914: EMPTY
18915: LIST
18916: LIST
18917: PUSH
18918: LD_INT 30
18920: PUSH
18921: LD_INT 8
18923: PUSH
18924: EMPTY
18925: LIST
18926: LIST
18927: PUSH
18928: EMPTY
18929: LIST
18930: LIST
18931: LIST
18932: LIST
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: PPUSH
18938: NOP4
18942: ST_TO_ADDR
18943: GO 18946
18945: POP
// if i = 1 then
18946: NOP4
18950: PUSH
18951: LD_INT 1
18953: EQUAL
18954: IFFALSE 19065
// begin tmp := [ ] ;
18956: NOP4
18960: PUSH
18961: EMPTY
18962: ST_TO_ADDR
// for j in f do
18963: NOP4
18967: PUSH
18968: NOP4
18972: PUSH
18973: FOR_IN
18974: IFFALSE 19047
// if GetBType ( j ) = b_bunker then
18976: NOP4
18980: PPUSH
18981: NOP4
18985: PUSH
18986: LD_INT 32
18988: EQUAL
18989: IFFALSE 19016
// tmp := Insert ( tmp , 1 , j ) else
18991: NOP4
18995: PUSH
18996: NOP4
19000: PPUSH
19001: LD_INT 1
19003: PPUSH
19004: NOP4
19008: PPUSH
19009: NOP4
19013: ST_TO_ADDR
19014: GO 19045
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19016: NOP4
19020: PUSH
19021: NOP4
19025: PPUSH
19026: NOP4
19030: PUSH
19031: LD_INT 1
19033: PLUS
19034: PPUSH
19035: NOP4
19039: PPUSH
19040: NOP4
19044: ST_TO_ADDR
19045: GO 18973
19047: POP
19048: POP
// if tmp then
19049: NOP4
19053: IFFALSE 19065
// f := tmp ;
19055: NOP4
19059: PUSH
19060: NOP4
19064: ST_TO_ADDR
// end ; x := personel [ i ] ;
19065: NOP4
19069: PUSH
19070: NOP4
19074: PUSH
19075: NOP4
19079: ARRAY
19080: ST_TO_ADDR
// if x = - 1 then
19081: NOP4
19085: PUSH
19086: LD_INT 1
19088: NEG
19089: EQUAL
19090: IFFALSE 19299
// begin for j in f do
19092: NOP4
19096: PUSH
19097: NOP4
19101: PUSH
19102: FOR_IN
19103: IFFALSE 19295
// repeat InitHc ;
19105: NOP4
// if GetBType ( j ) = b_barracks then
19109: NOP4
19113: PPUSH
19114: NOP4
19118: PUSH
19119: LD_INT 5
19121: EQUAL
19122: IFFALSE 19192
// begin if UnitsInside ( j ) < 3 then
19124: NOP4
19128: PPUSH
19129: NOP4
19133: PUSH
19134: LD_INT 3
19136: LESS
19137: IFFALSE 19173
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19139: LD_INT 0
19141: PPUSH
19142: LD_INT 5
19144: PUSH
19145: LD_INT 8
19147: PUSH
19148: LD_INT 9
19150: PUSH
19151: EMPTY
19152: LIST
19153: LIST
19154: LIST
19155: PUSH
19156: NOP4
19160: ARRAY
19161: PPUSH
19162: NOP4
19166: PPUSH
19167: NOP4
19171: GO 19190
// PrepareHuman ( false , i , skill ) ;
19173: LD_INT 0
19175: PPUSH
19176: NOP4
19180: PPUSH
19181: NOP4
19185: PPUSH
19186: NOP4
// end else
19190: GO 19209
// PrepareHuman ( false , i , skill ) ;
19192: LD_INT 0
19194: PPUSH
19195: NOP4
19199: PPUSH
19200: NOP4
19204: PPUSH
19205: NOP4
// un := CreateHuman ;
19209: NOP4
19213: PUSH
19214: NOP4
19218: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19219: NOP4
19223: PUSH
19224: NOP4
19228: PPUSH
19229: LD_INT 1
19231: PPUSH
19232: NOP4
19236: PPUSH
19237: NOP4
19241: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19242: NOP4
19246: PPUSH
19247: NOP4
19251: PPUSH
19252: NOP4
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19256: NOP4
19260: PPUSH
19261: NOP4
19265: PUSH
19266: LD_INT 6
19268: EQUAL
19269: PUSH
19270: NOP4
19274: PPUSH
19275: NOP4
19279: PUSH
19280: LD_INT 32
19282: PUSH
19283: LD_INT 31
19285: PUSH
19286: EMPTY
19287: LIST
19288: LIST
19289: IN
19290: OR
19291: IFFALSE 19105
19293: GO 19102
19295: POP
19296: POP
// end else
19297: GO 19679
// for j = 1 to x do
19299: NOP4
19303: PUSH
19304: DOUBLE
19305: LD_INT 1
19307: DEC
19308: ST_TO_ADDR
19309: NOP4
19313: PUSH
19314: FOR_TO
19315: IFFALSE 19677
// begin InitHc ;
19317: NOP4
// if not f then
19321: NOP4
19325: NOT
19326: IFFALSE 19415
// begin PrepareHuman ( false , i , skill ) ;
19328: LD_INT 0
19330: PPUSH
19331: NOP4
19335: PPUSH
19336: NOP4
19340: PPUSH
19341: NOP4
// un := CreateHuman ;
19345: NOP4
19349: PUSH
19350: NOP4
19354: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19355: NOP4
19359: PUSH
19360: NOP4
19364: PPUSH
19365: LD_INT 1
19367: PPUSH
19368: NOP4
19372: PPUSH
19373: NOP4
19377: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19378: NOP4
19382: PPUSH
19383: NOP4
19387: PPUSH
19388: NOP4
19392: PPUSH
19393: NOP4
19397: PPUSH
19398: NOP4
19402: PPUSH
19403: LD_INT 10
19405: PPUSH
19406: LD_INT 0
19408: PPUSH
19409: NOP4
// continue ;
19413: GO 19314
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19415: NOP4
19419: PUSH
19420: LD_INT 1
19422: ARRAY
19423: PPUSH
19424: NOP4
19428: PUSH
19429: NOP4
19433: PUSH
19434: LD_INT 1
19436: ARRAY
19437: PPUSH
19438: NOP4
19442: PUSH
19443: LD_INT 32
19445: PUSH
19446: LD_INT 31
19448: PUSH
19449: EMPTY
19450: LIST
19451: LIST
19452: IN
19453: AND
19454: PUSH
19455: NOP4
19459: PUSH
19460: LD_INT 1
19462: ARRAY
19463: PPUSH
19464: NOP4
19468: PUSH
19469: LD_INT 6
19471: EQUAL
19472: OR
19473: IFFALSE 19493
// f := Delete ( f , 1 ) ;
19475: NOP4
19479: PUSH
19480: NOP4
19484: PPUSH
19485: LD_INT 1
19487: PPUSH
19488: NOP4
19492: ST_TO_ADDR
// if not f then
19493: NOP4
19497: NOT
19498: IFFALSE 19516
// begin x := x + 2 ;
19500: NOP4
19504: PUSH
19505: NOP4
19509: PUSH
19510: LD_INT 2
19512: PLUS
19513: ST_TO_ADDR
// continue ;
19514: GO 19314
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19516: NOP4
19520: PUSH
19521: LD_INT 1
19523: ARRAY
19524: PPUSH
19525: NOP4
19529: PUSH
19530: LD_INT 5
19532: EQUAL
19533: IFFALSE 19607
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19535: NOP4
19539: PUSH
19540: LD_INT 1
19542: ARRAY
19543: PPUSH
19544: NOP4
19548: PUSH
19549: LD_INT 3
19551: LESS
19552: IFFALSE 19588
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19554: LD_INT 0
19556: PPUSH
19557: LD_INT 5
19559: PUSH
19560: LD_INT 8
19562: PUSH
19563: LD_INT 9
19565: PUSH
19566: EMPTY
19567: LIST
19568: LIST
19569: LIST
19570: PUSH
19571: NOP4
19575: ARRAY
19576: PPUSH
19577: NOP4
19581: PPUSH
19582: NOP4
19586: GO 19605
// PrepareHuman ( false , i , skill ) ;
19588: LD_INT 0
19590: PPUSH
19591: NOP4
19595: PPUSH
19596: NOP4
19600: PPUSH
19601: NOP4
// end else
19605: GO 19624
// PrepareHuman ( false , i , skill ) ;
19607: LD_INT 0
19609: PPUSH
19610: NOP4
19614: PPUSH
19615: NOP4
19619: PPUSH
19620: NOP4
// un := CreateHuman ;
19624: NOP4
19628: PUSH
19629: NOP4
19633: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19634: NOP4
19638: PUSH
19639: NOP4
19643: PPUSH
19644: LD_INT 1
19646: PPUSH
19647: NOP4
19651: PPUSH
19652: NOP4
19656: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19657: NOP4
19661: PPUSH
19662: NOP4
19666: PUSH
19667: LD_INT 1
19669: ARRAY
19670: PPUSH
19671: NOP4
// end ;
19675: GO 19314
19677: POP
19678: POP
// end ;
19679: GO 18616
19681: POP
19682: POP
// result := result ^ buildings ;
19683: NOP4
19687: PUSH
19688: NOP4
19692: PUSH
19693: NOP4
19697: ADD
19698: ST_TO_ADDR
// end else
19699: GO 19842
// begin for i = 1 to personel do
19701: NOP4
19705: PUSH
19706: DOUBLE
19707: LD_INT 1
19709: DEC
19710: ST_TO_ADDR
19711: NOP4
19715: PUSH
19716: FOR_TO
19717: IFFALSE 19840
// begin if i > 4 then
19719: NOP4
19723: PUSH
19724: LD_INT 4
19726: GREATER
19727: IFFALSE 19731
// break ;
19729: GO 19840
// x := personel [ i ] ;
19731: NOP4
19735: PUSH
19736: NOP4
19740: PUSH
19741: NOP4
19745: ARRAY
19746: ST_TO_ADDR
// if x = - 1 then
19747: NOP4
19751: PUSH
19752: LD_INT 1
19754: NEG
19755: EQUAL
19756: IFFALSE 19760
// continue ;
19758: GO 19716
// PrepareHuman ( false , i , skill ) ;
19760: LD_INT 0
19762: PPUSH
19763: NOP4
19767: PPUSH
19768: NOP4
19772: PPUSH
19773: NOP4
// un := CreateHuman ;
19777: NOP4
19781: PUSH
19782: NOP4
19786: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19787: NOP4
19791: PPUSH
19792: NOP4
19796: PPUSH
19797: NOP4
19801: PPUSH
19802: NOP4
19806: PPUSH
19807: NOP4
19811: PPUSH
19812: LD_INT 10
19814: PPUSH
19815: LD_INT 0
19817: PPUSH
19818: NOP4
// result := result ^ un ;
19822: NOP4
19826: PUSH
19827: NOP4
19831: PUSH
19832: NOP4
19836: ADD
19837: ST_TO_ADDR
// end ;
19838: GO 19716
19840: POP
19841: POP
// end ; end ;
19842: LD_VAR 0 7
19846: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19847: LD_INT 0
19849: PPUSH
19850: PPUSH
19851: PPUSH
19852: PPUSH
19853: PPUSH
19854: PPUSH
19855: PPUSH
19856: PPUSH
19857: PPUSH
19858: PPUSH
19859: PPUSH
19860: PPUSH
19861: PPUSH
19862: PPUSH
19863: PPUSH
19864: PPUSH
// result := false ;
19865: NOP4
19869: PUSH
19870: LD_INT 0
19872: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19873: NOP4
19877: NOT
19878: PUSH
19879: NOP4
19883: PPUSH
19884: NOP4
19888: PUSH
19889: LD_INT 32
19891: PUSH
19892: LD_INT 33
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: IN
19899: NOT
19900: OR
19901: IFFALSE 19905
// exit ;
19903: GO 21014
// nat := GetNation ( tower ) ;
19905: NOP4
19909: PUSH
19910: NOP4
19914: PPUSH
19915: NOP4
19919: ST_TO_ADDR
// side := GetSide ( tower ) ;
19920: NOP4
19924: PUSH
19925: NOP4
19929: PPUSH
19930: NOP4
19934: ST_TO_ADDR
// x := GetX ( tower ) ;
19935: NOP4
19939: PUSH
19940: NOP4
19944: PPUSH
19945: NOP4
19949: ST_TO_ADDR
// y := GetY ( tower ) ;
19950: NOP4
19954: PUSH
19955: NOP4
19959: PPUSH
19960: NOP4
19964: ST_TO_ADDR
// if not x or not y then
19965: NOP4
19969: NOT
19970: PUSH
19971: NOP4
19975: NOT
19976: OR
19977: IFFALSE 19981
// exit ;
19979: GO 21014
// weapon := 0 ;
19981: NOP4
19985: PUSH
19986: LD_INT 0
19988: ST_TO_ADDR
// fac_list := [ ] ;
19989: NOP4
19993: PUSH
19994: EMPTY
19995: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19996: NOP4
20000: PUSH
20001: NOP4
20005: PPUSH
20006: NOP4
20010: PPUSH
20011: NOP4
20015: PPUSH
20016: LD_INT 0
20018: PPUSH
20019: NOP4
20023: PPUSH
20024: LD_INT 30
20026: PUSH
20027: LD_INT 3
20029: PUSH
20030: EMPTY
20031: LIST
20032: LIST
20033: PPUSH
20034: NOP4
20038: ST_TO_ADDR
// if not factories then
20039: NOP4
20043: NOT
20044: IFFALSE 20048
// exit ;
20046: GO 21014
// for i in factories do
20048: NOP4
20052: PUSH
20053: NOP4
20057: PUSH
20058: FOR_IN
20059: IFFALSE 20084
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20061: NOP4
20065: PUSH
20066: NOP4
20070: PUSH
20071: NOP4
20075: PPUSH
20076: NOP4
20080: UNION
20081: ST_TO_ADDR
20082: GO 20058
20084: POP
20085: POP
// if not fac_list then
20086: NOP4
20090: NOT
20091: IFFALSE 20095
// exit ;
20093: GO 21014
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20095: NOP4
20099: PUSH
20100: LD_INT 4
20102: PUSH
20103: LD_INT 5
20105: PUSH
20106: LD_INT 9
20108: PUSH
20109: LD_INT 10
20111: PUSH
20112: LD_INT 6
20114: PUSH
20115: LD_INT 7
20117: PUSH
20118: LD_INT 11
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: LIST
20127: LIST
20128: LIST
20129: PUSH
20130: LD_INT 27
20132: PUSH
20133: LD_INT 28
20135: PUSH
20136: LD_INT 26
20138: PUSH
20139: LD_INT 30
20141: PUSH
20142: EMPTY
20143: LIST
20144: LIST
20145: LIST
20146: LIST
20147: PUSH
20148: LD_INT 43
20150: PUSH
20151: LD_INT 44
20153: PUSH
20154: LD_INT 46
20156: PUSH
20157: LD_INT 45
20159: PUSH
20160: LD_INT 47
20162: PUSH
20163: LD_INT 49
20165: PUSH
20166: EMPTY
20167: LIST
20168: LIST
20169: LIST
20170: LIST
20171: LIST
20172: LIST
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: LIST
20178: PUSH
20179: NOP4
20183: ARRAY
20184: ST_TO_ADDR
// list := list isect fac_list ;
20185: NOP4
20189: PUSH
20190: NOP4
20194: PUSH
20195: NOP4
20199: ISECT
20200: ST_TO_ADDR
// if not list then
20201: NOP4
20205: NOT
20206: IFFALSE 20210
// exit ;
20208: GO 21014
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20210: NOP4
20214: PUSH
20215: LD_INT 3
20217: EQUAL
20218: PUSH
20219: LD_INT 49
20221: PUSH
20222: NOP4
20226: IN
20227: AND
20228: PUSH
20229: LD_INT 31
20231: PPUSH
20232: NOP4
20236: PPUSH
20237: NOP4
20241: PUSH
20242: LD_INT 2
20244: EQUAL
20245: AND
20246: IFFALSE 20306
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20248: LD_INT 22
20250: PUSH
20251: NOP4
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: PUSH
20260: LD_INT 35
20262: PUSH
20263: LD_INT 49
20265: PUSH
20266: EMPTY
20267: LIST
20268: LIST
20269: PUSH
20270: LD_INT 91
20272: PUSH
20273: NOP4
20277: PUSH
20278: LD_INT 10
20280: PUSH
20281: EMPTY
20282: LIST
20283: LIST
20284: LIST
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: LIST
20290: PPUSH
20291: NOP4
20295: NOT
20296: IFFALSE 20306
// weapon := ru_time_lapser ;
20298: NOP4
20302: PUSH
20303: LD_INT 49
20305: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20306: NOP4
20310: PUSH
20311: LD_INT 1
20313: PUSH
20314: LD_INT 2
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: IN
20321: PUSH
20322: LD_INT 11
20324: PUSH
20325: NOP4
20329: IN
20330: PUSH
20331: LD_INT 30
20333: PUSH
20334: NOP4
20338: IN
20339: OR
20340: AND
20341: PUSH
20342: LD_INT 6
20344: PPUSH
20345: NOP4
20349: PPUSH
20350: NOP4
20354: PUSH
20355: LD_INT 2
20357: EQUAL
20358: AND
20359: IFFALSE 20524
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20361: LD_INT 22
20363: PUSH
20364: NOP4
20368: PUSH
20369: EMPTY
20370: LIST
20371: LIST
20372: PUSH
20373: LD_INT 2
20375: PUSH
20376: LD_INT 35
20378: PUSH
20379: LD_INT 11
20381: PUSH
20382: EMPTY
20383: LIST
20384: LIST
20385: PUSH
20386: LD_INT 35
20388: PUSH
20389: LD_INT 30
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: PUSH
20396: EMPTY
20397: LIST
20398: LIST
20399: LIST
20400: PUSH
20401: LD_INT 91
20403: PUSH
20404: NOP4
20408: PUSH
20409: LD_INT 18
20411: PUSH
20412: EMPTY
20413: LIST
20414: LIST
20415: LIST
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: PPUSH
20422: NOP4
20426: NOT
20427: PUSH
20428: LD_INT 22
20430: PUSH
20431: NOP4
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: PUSH
20440: LD_INT 2
20442: PUSH
20443: LD_INT 30
20445: PUSH
20446: LD_INT 32
20448: PUSH
20449: EMPTY
20450: LIST
20451: LIST
20452: PUSH
20453: LD_INT 30
20455: PUSH
20456: LD_INT 33
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 91
20470: PUSH
20471: NOP4
20475: PUSH
20476: LD_INT 12
20478: PUSH
20479: EMPTY
20480: LIST
20481: LIST
20482: LIST
20483: PUSH
20484: EMPTY
20485: LIST
20486: LIST
20487: LIST
20488: PUSH
20489: EMPTY
20490: LIST
20491: PPUSH
20492: NOP4
20496: PUSH
20497: LD_INT 2
20499: GREATER
20500: AND
20501: IFFALSE 20524
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20503: NOP4
20507: PUSH
20508: LD_INT 11
20510: PUSH
20511: LD_INT 30
20513: PUSH
20514: EMPTY
20515: LIST
20516: LIST
20517: PUSH
20518: NOP4
20522: ARRAY
20523: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20524: NOP4
20528: NOT
20529: PUSH
20530: LD_INT 40
20532: PPUSH
20533: NOP4
20537: PPUSH
20538: NOP4
20542: PUSH
20543: LD_INT 2
20545: EQUAL
20546: AND
20547: PUSH
20548: LD_INT 7
20550: PUSH
20551: NOP4
20555: IN
20556: PUSH
20557: LD_INT 28
20559: PUSH
20560: NOP4
20564: IN
20565: OR
20566: PUSH
20567: LD_INT 45
20569: PUSH
20570: NOP4
20574: IN
20575: OR
20576: AND
20577: IFFALSE 20831
// begin hex := GetHexInfo ( x , y ) ;
20579: NOP4
20583: PUSH
20584: NOP4
20588: PPUSH
20589: NOP4
20593: PPUSH
20594: NOP4
20598: ST_TO_ADDR
// if hex [ 1 ] then
20599: NOP4
20603: PUSH
20604: LD_INT 1
20606: ARRAY
20607: IFFALSE 20611
// exit ;
20609: GO 21014
// height := hex [ 2 ] ;
20611: NOP4
20615: PUSH
20616: NOP4
20620: PUSH
20621: LD_INT 2
20623: ARRAY
20624: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20625: NOP4
20629: PUSH
20630: LD_INT 0
20632: PUSH
20633: LD_INT 2
20635: PUSH
20636: LD_INT 3
20638: PUSH
20639: LD_INT 5
20641: PUSH
20642: EMPTY
20643: LIST
20644: LIST
20645: LIST
20646: LIST
20647: ST_TO_ADDR
// for i in tmp do
20648: NOP4
20652: PUSH
20653: NOP4
20657: PUSH
20658: FOR_IN
20659: IFFALSE 20829
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20661: NOP4
20665: PUSH
20666: NOP4
20670: PPUSH
20671: NOP4
20675: PPUSH
20676: LD_INT 5
20678: PPUSH
20679: NOP4
20683: PUSH
20684: NOP4
20688: PPUSH
20689: NOP4
20693: PPUSH
20694: LD_INT 5
20696: PPUSH
20697: NOP4
20701: PUSH
20702: EMPTY
20703: LIST
20704: LIST
20705: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20706: NOP4
20710: PUSH
20711: LD_INT 1
20713: ARRAY
20714: PPUSH
20715: NOP4
20719: PUSH
20720: LD_INT 2
20722: ARRAY
20723: PPUSH
20724: NOP4
20728: IFFALSE 20827
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20730: NOP4
20734: PUSH
20735: NOP4
20739: PUSH
20740: LD_INT 1
20742: ARRAY
20743: PPUSH
20744: NOP4
20748: PUSH
20749: LD_INT 2
20751: ARRAY
20752: PPUSH
20753: NOP4
20757: ST_TO_ADDR
// if hex [ 1 ] then
20758: NOP4
20762: PUSH
20763: LD_INT 1
20765: ARRAY
20766: IFFALSE 20770
// continue ;
20768: GO 20658
// h := hex [ 2 ] ;
20770: NOP4
20774: PUSH
20775: NOP4
20779: PUSH
20780: LD_INT 2
20782: ARRAY
20783: ST_TO_ADDR
// if h + 7 < height then
20784: NOP4
20788: PUSH
20789: LD_INT 7
20791: PLUS
20792: PUSH
20793: NOP4
20797: LESS
20798: IFFALSE 20827
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20800: NOP4
20804: PUSH
20805: LD_INT 7
20807: PUSH
20808: LD_INT 28
20810: PUSH
20811: LD_INT 45
20813: PUSH
20814: EMPTY
20815: LIST
20816: LIST
20817: LIST
20818: PUSH
20819: NOP4
20823: ARRAY
20824: ST_TO_ADDR
// break ;
20825: GO 20829
// end ; end ; end ;
20827: GO 20658
20829: POP
20830: POP
// end ; if not weapon then
20831: NOP4
20835: NOT
20836: IFFALSE 20896
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20838: NOP4
20842: PUSH
20843: NOP4
20847: PUSH
20848: LD_INT 11
20850: PUSH
20851: LD_INT 30
20853: PUSH
20854: LD_INT 49
20856: PUSH
20857: EMPTY
20858: LIST
20859: LIST
20860: LIST
20861: DIFF
20862: ST_TO_ADDR
// if not list then
20863: NOP4
20867: NOT
20868: IFFALSE 20872
// exit ;
20870: GO 21014
// weapon := list [ rand ( 1 , list ) ] ;
20872: NOP4
20876: PUSH
20877: NOP4
20881: PUSH
20882: LD_INT 1
20884: PPUSH
20885: NOP4
20889: PPUSH
20890: NOP4
20894: ARRAY
20895: ST_TO_ADDR
// end ; if weapon then
20896: NOP4
20900: IFFALSE 21014
// begin tmp := CostOfWeapon ( weapon ) ;
20902: NOP4
20906: PUSH
20907: NOP4
20911: PPUSH
20912: NOP4
20916: ST_TO_ADDR
// j := GetBase ( tower ) ;
20917: NOP4
20921: PUSH
20922: NOP4
20926: PPUSH
20927: NOP4
20931: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20932: NOP4
20936: PPUSH
20937: LD_INT 1
20939: PPUSH
20940: NOP4
20944: PUSH
20945: NOP4
20949: PUSH
20950: LD_INT 1
20952: ARRAY
20953: GREATEREQUAL
20954: PUSH
20955: NOP4
20959: PPUSH
20960: LD_INT 2
20962: PPUSH
20963: NOP4
20967: PUSH
20968: NOP4
20972: PUSH
20973: LD_INT 2
20975: ARRAY
20976: GREATEREQUAL
20977: AND
20978: PUSH
20979: NOP4
20983: PPUSH
20984: LD_INT 3
20986: PPUSH
20987: NOP4
20991: PUSH
20992: NOP4
20996: PUSH
20997: LD_INT 3
20999: ARRAY
21000: GREATEREQUAL
21001: AND
21002: IFFALSE 21014
// result := weapon ;
21004: NOP4
21008: PUSH
21009: NOP4
21013: ST_TO_ADDR
// end ; end ;
21014: LD_VAR 0 3
21018: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21019: LD_INT 0
21021: PPUSH
21022: PPUSH
// result := true ;
21023: NOP4
21027: PUSH
21028: LD_INT 1
21030: ST_TO_ADDR
// if array1 = array2 then
21031: NOP4
21035: PUSH
21036: NOP4
21040: EQUAL
21041: IFFALSE 21101
// begin for i = 1 to array1 do
21043: NOP4
21047: PUSH
21048: DOUBLE
21049: LD_INT 1
21051: DEC
21052: ST_TO_ADDR
21053: NOP4
21057: PUSH
21058: FOR_TO
21059: IFFALSE 21097
// if array1 [ i ] <> array2 [ i ] then
21061: NOP4
21065: PUSH
21066: NOP4
21070: ARRAY
21071: PUSH
21072: NOP4
21076: PUSH
21077: NOP4
21081: ARRAY
21082: NONEQUAL
21083: IFFALSE 21095
// begin result := false ;
21085: NOP4
21089: PUSH
21090: LD_INT 0
21092: ST_TO_ADDR
// break ;
21093: GO 21097
// end ;
21095: GO 21058
21097: POP
21098: POP
// end else
21099: GO 21109
// result := false ;
21101: NOP4
21105: PUSH
21106: LD_INT 0
21108: ST_TO_ADDR
// end ;
21109: LD_VAR 0 3
21113: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21114: LD_INT 0
21116: PPUSH
21117: PPUSH
// if not array1 or not array2 then
21118: NOP4
21122: NOT
21123: PUSH
21124: NOP4
21128: NOT
21129: OR
21130: IFFALSE 21134
// exit ;
21132: GO 21198
// result := true ;
21134: NOP4
21138: PUSH
21139: LD_INT 1
21141: ST_TO_ADDR
// for i = 1 to array1 do
21142: NOP4
21146: PUSH
21147: DOUBLE
21148: LD_INT 1
21150: DEC
21151: ST_TO_ADDR
21152: NOP4
21156: PUSH
21157: FOR_TO
21158: IFFALSE 21196
// if array1 [ i ] <> array2 [ i ] then
21160: NOP4
21164: PUSH
21165: NOP4
21169: ARRAY
21170: PUSH
21171: NOP4
21175: PUSH
21176: NOP4
21180: ARRAY
21181: NONEQUAL
21182: IFFALSE 21194
// begin result := false ;
21184: NOP4
21188: PUSH
21189: LD_INT 0
21191: ST_TO_ADDR
// break ;
21192: GO 21196
// end ;
21194: GO 21157
21196: POP
21197: POP
// end ;
21198: LD_VAR 0 3
21202: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21203: LD_INT 0
21205: PPUSH
21206: PPUSH
21207: PPUSH
// pom := GetBase ( fac ) ;
21208: NOP4
21212: PUSH
21213: NOP4
21217: PPUSH
21218: NOP4
21222: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21223: NOP4
21227: PUSH
21228: NOP4
21232: PUSH
21233: LD_INT 1
21235: ARRAY
21236: PPUSH
21237: NOP4
21241: PUSH
21242: LD_INT 2
21244: ARRAY
21245: PPUSH
21246: NOP4
21250: PUSH
21251: LD_INT 3
21253: ARRAY
21254: PPUSH
21255: NOP4
21259: PUSH
21260: LD_INT 4
21262: ARRAY
21263: PPUSH
21264: NOP4
21268: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21269: NOP4
21273: PUSH
21274: NOP4
21278: PPUSH
21279: LD_INT 1
21281: PPUSH
21282: NOP4
21286: PUSH
21287: NOP4
21291: PUSH
21292: LD_INT 1
21294: ARRAY
21295: GREATEREQUAL
21296: PUSH
21297: NOP4
21301: PPUSH
21302: LD_INT 2
21304: PPUSH
21305: NOP4
21309: PUSH
21310: NOP4
21314: PUSH
21315: LD_INT 2
21317: ARRAY
21318: GREATEREQUAL
21319: AND
21320: PUSH
21321: NOP4
21325: PPUSH
21326: LD_INT 3
21328: PPUSH
21329: NOP4
21333: PUSH
21334: NOP4
21338: PUSH
21339: LD_INT 3
21341: ARRAY
21342: GREATEREQUAL
21343: AND
21344: ST_TO_ADDR
// end ;
21345: LD_VAR 0 3
21349: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21350: LD_INT 0
21352: PPUSH
21353: PPUSH
21354: PPUSH
21355: PPUSH
// pom := GetBase ( building ) ;
21356: NOP4
21360: PUSH
21361: NOP4
21365: PPUSH
21366: NOP4
21370: ST_TO_ADDR
// if not pom then
21371: NOP4
21375: NOT
21376: IFFALSE 21380
// exit ;
21378: GO 21550
// btype := GetBType ( building ) ;
21380: NOP4
21384: PUSH
21385: NOP4
21389: PPUSH
21390: NOP4
21394: ST_TO_ADDR
// if btype = b_armoury then
21395: NOP4
21399: PUSH
21400: LD_INT 4
21402: EQUAL
21403: IFFALSE 21413
// btype := b_barracks ;
21405: NOP4
21409: PUSH
21410: LD_INT 5
21412: ST_TO_ADDR
// if btype = b_depot then
21413: NOP4
21417: PUSH
21418: LD_INT 0
21420: EQUAL
21421: IFFALSE 21431
// btype := b_warehouse ;
21423: NOP4
21427: PUSH
21428: LD_INT 1
21430: ST_TO_ADDR
// if btype = b_workshop then
21431: NOP4
21435: PUSH
21436: LD_INT 2
21438: EQUAL
21439: IFFALSE 21449
// btype := b_factory ;
21441: NOP4
21445: PUSH
21446: LD_INT 3
21448: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21449: NOP4
21453: PUSH
21454: NOP4
21458: PPUSH
21459: NOP4
21463: PPUSH
21464: NOP4
21468: PPUSH
21469: NOP4
21473: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21474: NOP4
21478: PUSH
21479: NOP4
21483: PPUSH
21484: LD_INT 1
21486: PPUSH
21487: NOP4
21491: PUSH
21492: NOP4
21496: PUSH
21497: LD_INT 1
21499: ARRAY
21500: GREATEREQUAL
21501: PUSH
21502: NOP4
21506: PPUSH
21507: LD_INT 2
21509: PPUSH
21510: NOP4
21514: PUSH
21515: NOP4
21519: PUSH
21520: LD_INT 2
21522: ARRAY
21523: GREATEREQUAL
21524: AND
21525: PUSH
21526: NOP4
21530: PPUSH
21531: LD_INT 3
21533: PPUSH
21534: NOP4
21538: PUSH
21539: NOP4
21543: PUSH
21544: LD_INT 3
21546: ARRAY
21547: GREATEREQUAL
21548: AND
21549: ST_TO_ADDR
// end ;
21550: LD_VAR 0 2
21554: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21555: LD_INT 0
21557: PPUSH
21558: PPUSH
21559: PPUSH
// pom := GetBase ( building ) ;
21560: NOP4
21564: PUSH
21565: NOP4
21569: PPUSH
21570: NOP4
21574: ST_TO_ADDR
// if not pom then
21575: NOP4
21579: NOT
21580: IFFALSE 21584
// exit ;
21582: GO 21685
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21584: NOP4
21588: PUSH
21589: NOP4
21593: PPUSH
21594: NOP4
21598: PPUSH
21599: NOP4
21603: PPUSH
21604: NOP4
21608: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21609: NOP4
21613: PUSH
21614: NOP4
21618: PPUSH
21619: LD_INT 1
21621: PPUSH
21622: NOP4
21626: PUSH
21627: NOP4
21631: PUSH
21632: LD_INT 1
21634: ARRAY
21635: GREATEREQUAL
21636: PUSH
21637: NOP4
21641: PPUSH
21642: LD_INT 2
21644: PPUSH
21645: NOP4
21649: PUSH
21650: NOP4
21654: PUSH
21655: LD_INT 2
21657: ARRAY
21658: GREATEREQUAL
21659: AND
21660: PUSH
21661: NOP4
21665: PPUSH
21666: LD_INT 3
21668: PPUSH
21669: NOP4
21673: PUSH
21674: NOP4
21678: PUSH
21679: LD_INT 3
21681: ARRAY
21682: GREATEREQUAL
21683: AND
21684: ST_TO_ADDR
// end ;
21685: LD_VAR 0 3
21689: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21690: LD_INT 0
21692: PPUSH
21693: PPUSH
21694: PPUSH
21695: PPUSH
21696: PPUSH
21697: PPUSH
21698: PPUSH
21699: PPUSH
21700: PPUSH
21701: PPUSH
21702: PPUSH
// result := false ;
21703: NOP4
21707: PUSH
21708: LD_INT 0
21710: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21711: NOP4
21715: NOT
21716: PUSH
21717: NOP4
21721: NOT
21722: OR
21723: PUSH
21724: NOP4
21728: NOT
21729: OR
21730: PUSH
21731: NOP4
21735: NOT
21736: OR
21737: IFFALSE 21741
// exit ;
21739: GO 22555
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21741: NOP4
21745: PUSH
21746: NOP4
21750: PPUSH
21751: NOP4
21755: PPUSH
21756: NOP4
21760: PPUSH
21761: NOP4
21765: PPUSH
21766: NOP4
21770: PUSH
21771: LD_INT 1
21773: ARRAY
21774: PPUSH
21775: NOP4
21779: PPUSH
21780: LD_INT 0
21782: PPUSH
21783: NOP4
21787: ST_TO_ADDR
// if not hexes then
21788: NOP4
21792: NOT
21793: IFFALSE 21797
// exit ;
21795: GO 22555
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21797: NOP4
21801: PUSH
21802: NOP4
21806: PPUSH
21807: LD_INT 22
21809: PUSH
21810: NOP4
21814: PPUSH
21815: NOP4
21819: PUSH
21820: EMPTY
21821: LIST
21822: LIST
21823: PUSH
21824: LD_INT 2
21826: PUSH
21827: LD_INT 30
21829: PUSH
21830: LD_INT 0
21832: PUSH
21833: EMPTY
21834: LIST
21835: LIST
21836: PUSH
21837: LD_INT 30
21839: PUSH
21840: LD_INT 1
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: PUSH
21847: EMPTY
21848: LIST
21849: LIST
21850: LIST
21851: PUSH
21852: EMPTY
21853: LIST
21854: LIST
21855: PPUSH
21856: NOP4
21860: ST_TO_ADDR
// for i = 1 to hexes do
21861: NOP4
21865: PUSH
21866: DOUBLE
21867: LD_INT 1
21869: DEC
21870: ST_TO_ADDR
21871: NOP4
21875: PUSH
21876: FOR_TO
21877: IFFALSE 22553
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21879: NOP4
21883: PUSH
21884: NOP4
21888: PUSH
21889: NOP4
21893: ARRAY
21894: PUSH
21895: LD_INT 1
21897: ARRAY
21898: PPUSH
21899: NOP4
21903: PUSH
21904: NOP4
21908: ARRAY
21909: PUSH
21910: LD_INT 2
21912: ARRAY
21913: PPUSH
21914: NOP4
21918: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21919: NOP4
21923: PUSH
21924: NOP4
21928: ARRAY
21929: PUSH
21930: LD_INT 1
21932: ARRAY
21933: PPUSH
21934: NOP4
21938: PUSH
21939: NOP4
21943: ARRAY
21944: PUSH
21945: LD_INT 2
21947: ARRAY
21948: PPUSH
21949: NOP4
21953: PUSH
21954: NOP4
21958: PUSH
21959: NOP4
21963: ARRAY
21964: PUSH
21965: LD_INT 1
21967: ARRAY
21968: PPUSH
21969: NOP4
21973: PUSH
21974: NOP4
21978: ARRAY
21979: PUSH
21980: LD_INT 2
21982: ARRAY
21983: PPUSH
21984: NOP4
21988: NOT
21989: OR
21990: PUSH
21991: NOP4
21995: PPUSH
21996: NOP4
22000: PUSH
22001: LD_INT 3
22003: EQUAL
22004: OR
22005: IFFALSE 22011
// exit ;
22007: POP
22008: POP
22009: GO 22555
// if not tmp then
22011: NOP4
22015: NOT
22016: IFFALSE 22020
// continue ;
22018: GO 21876
// result := true ;
22020: NOP4
22024: PUSH
22025: LD_INT 1
22027: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22028: NOP4
22032: PUSH
22033: NOP4
22037: PPUSH
22038: NOP4
22042: PUSH
22043: LD_INT 2
22045: EQUAL
22046: AND
22047: PUSH
22048: NOP4
22052: PPUSH
22053: NOP4
22057: PUSH
22058: LD_INT 1
22060: EQUAL
22061: AND
22062: IFFALSE 22226
// begin if IsDrivenBy ( tmp ) then
22064: NOP4
22068: PPUSH
22069: NOP4
22073: IFFALSE 22077
// continue ;
22075: GO 21876
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22077: NOP4
22081: PPUSH
22082: LD_INT 3
22084: PUSH
22085: LD_INT 60
22087: PUSH
22088: EMPTY
22089: LIST
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PUSH
22095: LD_INT 3
22097: PUSH
22098: LD_INT 55
22100: PUSH
22101: EMPTY
22102: LIST
22103: PUSH
22104: EMPTY
22105: LIST
22106: LIST
22107: PUSH
22108: EMPTY
22109: LIST
22110: LIST
22111: PPUSH
22112: NOP4
22116: IFFALSE 22224
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22118: NOP4
22122: PUSH
22123: NOP4
22127: PPUSH
22128: LD_INT 3
22130: PUSH
22131: LD_INT 60
22133: PUSH
22134: EMPTY
22135: LIST
22136: PUSH
22137: EMPTY
22138: LIST
22139: LIST
22140: PUSH
22141: LD_INT 3
22143: PUSH
22144: LD_INT 55
22146: PUSH
22147: EMPTY
22148: LIST
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: PPUSH
22158: NOP4
22162: PUSH
22163: LD_INT 1
22165: ARRAY
22166: ST_TO_ADDR
// if IsInUnit ( driver ) then
22167: NOP4
22171: PPUSH
22172: NOP4
22176: IFFALSE 22187
// ComExit ( driver ) ;
22178: NOP4
22182: PPUSH
22183: NOP4
// AddComEnterUnit ( driver , tmp ) ;
22187: NOP4
22191: PPUSH
22192: NOP4
22196: PPUSH
22197: NOP4
// AddComMoveToArea ( driver , parking ) ;
22201: NOP4
22205: PPUSH
22206: NOP4
22210: PPUSH
22211: NOP4
// AddComExitVehicle ( driver ) ;
22215: NOP4
22219: PPUSH
22220: NOP4
// end ; continue ;
22224: GO 21876
// end ; if not cleaners or not tmp in cleaners then
22226: NOP4
22230: NOT
22231: PUSH
22232: NOP4
22236: PUSH
22237: NOP4
22241: IN
22242: NOT
22243: OR
22244: IFFALSE 22551
// begin if dep then
22246: NOP4
22250: IFFALSE 22386
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22252: NOP4
22256: PUSH
22257: NOP4
22261: PUSH
22262: LD_INT 1
22264: ARRAY
22265: PPUSH
22266: NOP4
22270: PPUSH
22271: NOP4
22275: PUSH
22276: LD_INT 1
22278: ARRAY
22279: PPUSH
22280: NOP4
22284: PPUSH
22285: LD_INT 5
22287: PPUSH
22288: NOP4
22292: PUSH
22293: NOP4
22297: PUSH
22298: LD_INT 1
22300: ARRAY
22301: PPUSH
22302: NOP4
22306: PPUSH
22307: NOP4
22311: PUSH
22312: LD_INT 1
22314: ARRAY
22315: PPUSH
22316: NOP4
22320: PPUSH
22321: LD_INT 5
22323: PPUSH
22324: NOP4
22328: PUSH
22329: EMPTY
22330: LIST
22331: LIST
22332: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22333: NOP4
22337: PUSH
22338: LD_INT 1
22340: ARRAY
22341: PPUSH
22342: NOP4
22346: PUSH
22347: LD_INT 2
22349: ARRAY
22350: PPUSH
22351: NOP4
22355: IFFALSE 22386
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22357: NOP4
22361: PPUSH
22362: NOP4
22366: PUSH
22367: LD_INT 1
22369: ARRAY
22370: PPUSH
22371: NOP4
22375: PUSH
22376: LD_INT 2
22378: ARRAY
22379: PPUSH
22380: NOP4
// continue ;
22384: GO 21876
// end ; end ; r := GetDir ( tmp ) ;
22386: NOP4
22390: PUSH
22391: NOP4
22395: PPUSH
22396: NOP4
22400: ST_TO_ADDR
// if r = 5 then
22401: NOP4
22405: PUSH
22406: LD_INT 5
22408: EQUAL
22409: IFFALSE 22419
// r := 0 ;
22411: NOP4
22415: PUSH
22416: LD_INT 0
22418: ST_TO_ADDR
// for j = r to 5 do
22419: NOP4
22423: PUSH
22424: DOUBLE
22425: NOP4
22429: DEC
22430: ST_TO_ADDR
22431: LD_INT 5
22433: PUSH
22434: FOR_TO
22435: IFFALSE 22549
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22437: NOP4
22441: PUSH
22442: NOP4
22446: PPUSH
22447: NOP4
22451: PPUSH
22452: NOP4
22456: PPUSH
22457: LD_INT 2
22459: PPUSH
22460: NOP4
22464: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22465: NOP4
22469: PUSH
22470: NOP4
22474: PPUSH
22475: NOP4
22479: PPUSH
22480: NOP4
22484: PPUSH
22485: LD_INT 2
22487: PPUSH
22488: NOP4
22492: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22493: NOP4
22497: PPUSH
22498: NOP4
22502: PPUSH
22503: NOP4
22507: PUSH
22508: NOP4
22512: PPUSH
22513: NOP4
22517: PPUSH
22518: NOP4
22522: NOT
22523: AND
22524: IFFALSE 22547
// begin ComMoveXY ( tmp , _x , _y ) ;
22526: NOP4
22530: PPUSH
22531: NOP4
22535: PPUSH
22536: NOP4
22540: PPUSH
22541: NOP4
// break ;
22545: GO 22549
// end ; end ;
22547: GO 22434
22549: POP
22550: POP
// end ; end ;
22551: GO 21876
22553: POP
22554: POP
// end ;
22555: LD_VAR 0 8
22559: RET
// export function BuildingTechInvented ( side , btype ) ; begin
22560: LD_INT 0
22562: PPUSH
// result := true ;
22563: NOP4
22567: PUSH
22568: LD_INT 1
22570: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
22571: NOP4
22575: PUSH
22576: LD_INT 24
22578: DOUBLE
22579: EQUAL
22580: IFTRUE 22590
22582: LD_INT 33
22584: DOUBLE
22585: EQUAL
22586: IFTRUE 22590
22588: GO 22615
22590: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
22591: NOP4
22595: PUSH
22596: LD_INT 32
22598: PPUSH
22599: NOP4
22603: PPUSH
22604: NOP4
22608: PUSH
22609: LD_INT 2
22611: EQUAL
22612: ST_TO_ADDR
22613: GO 22935
22615: LD_INT 20
22617: DOUBLE
22618: EQUAL
22619: IFTRUE 22623
22621: GO 22648
22623: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
22624: NOP4
22628: PUSH
22629: LD_INT 6
22631: PPUSH
22632: NOP4
22636: PPUSH
22637: NOP4
22641: PUSH
22642: LD_INT 2
22644: EQUAL
22645: ST_TO_ADDR
22646: GO 22935
22648: LD_INT 22
22650: DOUBLE
22651: EQUAL
22652: IFTRUE 22662
22654: LD_INT 36
22656: DOUBLE
22657: EQUAL
22658: IFTRUE 22662
22660: GO 22687
22662: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
22663: NOP4
22667: PUSH
22668: LD_INT 15
22670: PPUSH
22671: NOP4
22675: PPUSH
22676: NOP4
22680: PUSH
22681: LD_INT 2
22683: EQUAL
22684: ST_TO_ADDR
22685: GO 22935
22687: LD_INT 30
22689: DOUBLE
22690: EQUAL
22691: IFTRUE 22695
22693: GO 22720
22695: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
22696: NOP4
22700: PUSH
22701: LD_INT 20
22703: PPUSH
22704: NOP4
22708: PPUSH
22709: NOP4
22713: PUSH
22714: LD_INT 2
22716: EQUAL
22717: ST_TO_ADDR
22718: GO 22935
22720: LD_INT 28
22722: DOUBLE
22723: EQUAL
22724: IFTRUE 22734
22726: LD_INT 21
22728: DOUBLE
22729: EQUAL
22730: IFTRUE 22734
22732: GO 22759
22734: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
22735: NOP4
22739: PUSH
22740: LD_INT 21
22742: PPUSH
22743: NOP4
22747: PPUSH
22748: NOP4
22752: PUSH
22753: LD_INT 2
22755: EQUAL
22756: ST_TO_ADDR
22757: GO 22935
22759: LD_INT 16
22761: DOUBLE
22762: EQUAL
22763: IFTRUE 22767
22765: GO 22794
22767: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
22768: NOP4
22772: PUSH
22773: NOP4
22777: PPUSH
22778: NOP4
22782: PPUSH
22783: NOP4
22787: PUSH
22788: LD_INT 2
22790: EQUAL
22791: ST_TO_ADDR
22792: GO 22935
22794: LD_INT 19
22796: DOUBLE
22797: EQUAL
22798: IFTRUE 22808
22800: LD_INT 23
22802: DOUBLE
22803: EQUAL
22804: IFTRUE 22808
22806: GO 22835
22808: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22809: NOP4
22813: PUSH
22814: NOP4
22818: PPUSH
22819: NOP4
22823: PPUSH
22824: NOP4
22828: PUSH
22829: LD_INT 2
22831: EQUAL
22832: ST_TO_ADDR
22833: GO 22935
22835: LD_INT 17
22837: DOUBLE
22838: EQUAL
22839: IFTRUE 22843
22841: GO 22868
22843: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22844: NOP4
22848: PUSH
22849: LD_INT 39
22851: PPUSH
22852: NOP4
22856: PPUSH
22857: NOP4
22861: PUSH
22862: LD_INT 2
22864: EQUAL
22865: ST_TO_ADDR
22866: GO 22935
22868: LD_INT 18
22870: DOUBLE
22871: EQUAL
22872: IFTRUE 22876
22874: GO 22901
22876: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
22877: NOP4
22881: PUSH
22882: LD_INT 40
22884: PPUSH
22885: NOP4
22889: PPUSH
22890: NOP4
22894: PUSH
22895: LD_INT 2
22897: EQUAL
22898: ST_TO_ADDR
22899: GO 22935
22901: LD_INT 27
22903: DOUBLE
22904: EQUAL
22905: IFTRUE 22909
22907: GO 22934
22909: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
22910: NOP4
22914: PUSH
22915: LD_INT 35
22917: PPUSH
22918: NOP4
22922: PPUSH
22923: NOP4
22927: PUSH
22928: LD_INT 2
22930: EQUAL
22931: ST_TO_ADDR
22932: GO 22935
22934: POP
// end ;
22935: LD_VAR 0 3
22939: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
22940: LD_INT 0
22942: PPUSH
22943: PPUSH
22944: PPUSH
22945: PPUSH
22946: PPUSH
22947: PPUSH
22948: PPUSH
22949: PPUSH
22950: PPUSH
22951: PPUSH
22952: PPUSH
// result := false ;
22953: NOP4
22957: PUSH
22958: LD_INT 0
22960: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22961: NOP4
22965: NOT
22966: PUSH
22967: NOP4
22971: PPUSH
22972: NOP4
22976: PUSH
22977: LD_INT 0
22979: PUSH
22980: LD_INT 1
22982: PUSH
22983: EMPTY
22984: LIST
22985: LIST
22986: IN
22987: NOT
22988: OR
22989: PUSH
22990: NOP4
22994: NOT
22995: OR
22996: PUSH
22997: NOP4
23001: PUSH
23002: LD_INT 0
23004: PUSH
23005: LD_INT 1
23007: PUSH
23008: LD_INT 2
23010: PUSH
23011: LD_INT 3
23013: PUSH
23014: LD_INT 4
23016: PUSH
23017: LD_INT 5
23019: PUSH
23020: EMPTY
23021: LIST
23022: LIST
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: IN
23028: NOT
23029: OR
23030: PUSH
23031: NOP4
23035: PPUSH
23036: NOP4
23040: PPUSH
23041: NOP4
23045: NOT
23046: OR
23047: IFFALSE 23051
// exit ;
23049: GO 23787
// side := GetSide ( depot ) ;
23051: NOP4
23055: PUSH
23056: NOP4
23060: PPUSH
23061: NOP4
23065: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23066: NOP4
23070: PPUSH
23071: NOP4
23075: PPUSH
23076: NOP4
23080: NOT
23081: IFFALSE 23085
// exit ;
23083: GO 23787
// pom := GetBase ( depot ) ;
23085: NOP4
23089: PUSH
23090: NOP4
23094: PPUSH
23095: NOP4
23099: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23100: NOP4
23104: PUSH
23105: NOP4
23109: PPUSH
23110: NOP4
23114: PPUSH
23115: NOP4
23119: PPUSH
23120: NOP4
23124: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23125: NOP4
23129: PPUSH
23130: LD_INT 1
23132: PPUSH
23133: NOP4
23137: PUSH
23138: NOP4
23142: PUSH
23143: LD_INT 1
23145: ARRAY
23146: GREATEREQUAL
23147: PUSH
23148: NOP4
23152: PPUSH
23153: LD_INT 2
23155: PPUSH
23156: NOP4
23160: PUSH
23161: NOP4
23165: PUSH
23166: LD_INT 2
23168: ARRAY
23169: GREATEREQUAL
23170: AND
23171: PUSH
23172: NOP4
23176: PPUSH
23177: LD_INT 3
23179: PPUSH
23180: NOP4
23184: PUSH
23185: NOP4
23189: PUSH
23190: LD_INT 3
23192: ARRAY
23193: GREATEREQUAL
23194: AND
23195: NOT
23196: IFFALSE 23200
// exit ;
23198: GO 23787
// if GetBType ( depot ) = b_depot then
23200: NOP4
23204: PPUSH
23205: NOP4
23209: PUSH
23210: LD_INT 0
23212: EQUAL
23213: IFFALSE 23225
// dist := 28 else
23215: NOP4
23219: PUSH
23220: LD_INT 28
23222: ST_TO_ADDR
23223: GO 23233
// dist := 36 ;
23225: NOP4
23229: PUSH
23230: LD_INT 36
23232: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
23233: NOP4
23237: PPUSH
23238: NOP4
23242: PPUSH
23243: NOP4
23247: PPUSH
23248: NOP4
23252: PUSH
23253: NOP4
23257: GREATER
23258: IFFALSE 23262
// exit ;
23260: GO 23787
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
23262: NOP4
23266: PUSH
23267: NOP4
23271: PPUSH
23272: NOP4
23276: PPUSH
23277: NOP4
23281: PPUSH
23282: NOP4
23286: PPUSH
23287: NOP4
23291: PPUSH
23292: NOP4
23296: PPUSH
23297: LD_INT 0
23299: PPUSH
23300: NOP4
23304: ST_TO_ADDR
// if not hexes then
23305: NOP4
23309: NOT
23310: IFFALSE 23314
// exit ;
23312: GO 23787
// hex := GetHexInfo ( x , y ) ;
23314: NOP4
23318: PUSH
23319: NOP4
23323: PPUSH
23324: NOP4
23328: PPUSH
23329: NOP4
23333: ST_TO_ADDR
// if hex [ 1 ] then
23334: NOP4
23338: PUSH
23339: LD_INT 1
23341: ARRAY
23342: IFFALSE 23346
// exit ;
23344: GO 23787
// height := hex [ 2 ] ;
23346: NOP4
23350: PUSH
23351: NOP4
23355: PUSH
23356: LD_INT 2
23358: ARRAY
23359: ST_TO_ADDR
// for i = 1 to hexes do
23360: NOP4
23364: PUSH
23365: DOUBLE
23366: LD_INT 1
23368: DEC
23369: ST_TO_ADDR
23370: NOP4
23374: PUSH
23375: FOR_TO
23376: IFFALSE 23706
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
23378: NOP4
23382: PUSH
23383: NOP4
23387: ARRAY
23388: PUSH
23389: LD_INT 1
23391: ARRAY
23392: PPUSH
23393: NOP4
23397: PUSH
23398: NOP4
23402: ARRAY
23403: PUSH
23404: LD_INT 2
23406: ARRAY
23407: PPUSH
23408: NOP4
23412: NOT
23413: PUSH
23414: NOP4
23418: PUSH
23419: NOP4
23423: ARRAY
23424: PUSH
23425: LD_INT 1
23427: ARRAY
23428: PPUSH
23429: NOP4
23433: PUSH
23434: NOP4
23438: ARRAY
23439: PUSH
23440: LD_INT 2
23442: ARRAY
23443: PPUSH
23444: NOP4
23448: PUSH
23449: LD_INT 0
23451: GREATER
23452: OR
23453: PUSH
23454: NOP4
23458: PUSH
23459: NOP4
23463: ARRAY
23464: PUSH
23465: LD_INT 1
23467: ARRAY
23468: PPUSH
23469: NOP4
23473: PUSH
23474: NOP4
23478: ARRAY
23479: PUSH
23480: LD_INT 2
23482: ARRAY
23483: PPUSH
23484: NOP4
23488: OR
23489: IFFALSE 23495
// exit ;
23491: POP
23492: POP
23493: GO 23787
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23495: NOP4
23499: PUSH
23500: NOP4
23504: PUSH
23505: NOP4
23509: ARRAY
23510: PUSH
23511: LD_INT 1
23513: ARRAY
23514: PPUSH
23515: NOP4
23519: PUSH
23520: NOP4
23524: ARRAY
23525: PUSH
23526: LD_INT 2
23528: ARRAY
23529: PPUSH
23530: NOP4
23534: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23535: NOP4
23539: PUSH
23540: LD_INT 1
23542: ARRAY
23543: PUSH
23544: NOP4
23548: PUSH
23549: LD_INT 2
23551: ARRAY
23552: PUSH
23553: NOP4
23557: PUSH
23558: LD_INT 2
23560: PLUS
23561: GREATER
23562: OR
23563: PUSH
23564: NOP4
23568: PUSH
23569: LD_INT 2
23571: ARRAY
23572: PUSH
23573: NOP4
23577: PUSH
23578: LD_INT 2
23580: MINUS
23581: LESS
23582: OR
23583: PUSH
23584: NOP4
23588: PUSH
23589: LD_INT 3
23591: ARRAY
23592: PUSH
23593: LD_INT 0
23595: PUSH
23596: LD_INT 8
23598: PUSH
23599: LD_INT 9
23601: PUSH
23602: LD_INT 10
23604: PUSH
23605: LD_INT 11
23607: PUSH
23608: LD_INT 12
23610: PUSH
23611: LD_INT 13
23613: PUSH
23614: LD_INT 16
23616: PUSH
23617: LD_INT 17
23619: PUSH
23620: LD_INT 18
23622: PUSH
23623: LD_INT 19
23625: PUSH
23626: LD_INT 20
23628: PUSH
23629: LD_INT 21
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: LIST
23637: LIST
23638: LIST
23639: LIST
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: LIST
23646: IN
23647: NOT
23648: OR
23649: PUSH
23650: NOP4
23654: PUSH
23655: LD_INT 5
23657: ARRAY
23658: NOT
23659: OR
23660: PUSH
23661: NOP4
23665: PUSH
23666: LD_INT 6
23668: ARRAY
23669: PUSH
23670: LD_INT 1
23672: PUSH
23673: LD_INT 2
23675: PUSH
23676: LD_INT 7
23678: PUSH
23679: LD_INT 9
23681: PUSH
23682: LD_INT 10
23684: PUSH
23685: LD_INT 11
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: LIST
23695: IN
23696: NOT
23697: OR
23698: IFFALSE 23704
// exit ;
23700: POP
23701: POP
23702: GO 23787
// end ;
23704: GO 23375
23706: POP
23707: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23708: NOP4
23712: PPUSH
23713: NOP4
23717: PPUSH
23718: NOP4
23722: PPUSH
23723: LD_INT 20
23725: PPUSH
23726: NOP4
23730: PUSH
23731: LD_INT 4
23733: ARRAY
23734: IFFALSE 23738
// exit ;
23736: GO 23787
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23738: NOP4
23742: PUSH
23743: LD_INT 29
23745: PUSH
23746: LD_INT 30
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: IN
23753: PUSH
23754: NOP4
23758: PPUSH
23759: NOP4
23763: PPUSH
23764: NOP4
23768: PPUSH
23769: NOP4
23773: NOT
23774: AND
23775: IFFALSE 23779
// exit ;
23777: GO 23787
// result := true ;
23779: NOP4
23783: PUSH
23784: LD_INT 1
23786: ST_TO_ADDR
// end ;
23787: LD_VAR 0 6
23791: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23792: LD_INT 0
23794: PPUSH
23795: PPUSH
23796: PPUSH
23797: PPUSH
23798: PPUSH
23799: PPUSH
23800: PPUSH
23801: PPUSH
23802: PPUSH
23803: PPUSH
23804: PPUSH
23805: PPUSH
23806: PPUSH
23807: PPUSH
23808: PPUSH
23809: PPUSH
23810: PPUSH
23811: PPUSH
23812: PPUSH
23813: PPUSH
23814: PPUSH
23815: PPUSH
23816: PPUSH
23817: PPUSH
23818: PPUSH
23819: PPUSH
23820: PPUSH
23821: PPUSH
23822: PPUSH
23823: PPUSH
23824: PPUSH
23825: PPUSH
23826: PPUSH
23827: PPUSH
23828: PPUSH
23829: PPUSH
23830: PPUSH
23831: PPUSH
23832: PPUSH
23833: PPUSH
23834: PPUSH
23835: PPUSH
23836: PPUSH
23837: PPUSH
23838: PPUSH
23839: PPUSH
23840: PPUSH
23841: PPUSH
23842: PPUSH
23843: PPUSH
23844: PPUSH
23845: PPUSH
23846: PPUSH
23847: PPUSH
23848: PPUSH
23849: PPUSH
23850: PPUSH
23851: PPUSH
// result = [ ] ;
23852: NOP4
23856: PUSH
23857: EMPTY
23858: ST_TO_ADDR
// temp_list = [ ] ;
23859: NOP4
23863: PUSH
23864: EMPTY
23865: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23866: NOP4
23870: PUSH
23871: LD_INT 0
23873: PUSH
23874: LD_INT 1
23876: PUSH
23877: LD_INT 2
23879: PUSH
23880: LD_INT 3
23882: PUSH
23883: LD_INT 4
23885: PUSH
23886: LD_INT 5
23888: PUSH
23889: EMPTY
23890: LIST
23891: LIST
23892: LIST
23893: LIST
23894: LIST
23895: LIST
23896: IN
23897: NOT
23898: PUSH
23899: NOP4
23903: PUSH
23904: LD_INT 0
23906: PUSH
23907: LD_INT 1
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: IN
23914: PUSH
23915: NOP4
23919: PUSH
23920: LD_INT 1
23922: PUSH
23923: LD_INT 2
23925: PUSH
23926: LD_INT 3
23928: PUSH
23929: EMPTY
23930: LIST
23931: LIST
23932: LIST
23933: IN
23934: NOT
23935: AND
23936: OR
23937: IFFALSE 23941
// exit ;
23939: GO 42332
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23941: NOP4
23945: PUSH
23946: LD_INT 6
23948: PUSH
23949: LD_INT 7
23951: PUSH
23952: LD_INT 8
23954: PUSH
23955: LD_INT 13
23957: PUSH
23958: LD_INT 12
23960: PUSH
23961: LD_INT 15
23963: PUSH
23964: LD_INT 11
23966: PUSH
23967: LD_INT 14
23969: PUSH
23970: LD_INT 10
23972: PUSH
23973: EMPTY
23974: LIST
23975: LIST
23976: LIST
23977: LIST
23978: LIST
23979: LIST
23980: LIST
23981: LIST
23982: LIST
23983: IN
23984: IFFALSE 23994
// btype = b_lab ;
23986: NOP4
23990: PUSH
23991: LD_INT 6
23993: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23994: NOP4
23998: PUSH
23999: LD_INT 0
24001: PUSH
24002: LD_INT 1
24004: PUSH
24005: LD_INT 2
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: LIST
24012: IN
24013: NOT
24014: PUSH
24015: NOP4
24019: PUSH
24020: LD_INT 0
24022: PUSH
24023: LD_INT 1
24025: PUSH
24026: LD_INT 2
24028: PUSH
24029: LD_INT 3
24031: PUSH
24032: LD_INT 6
24034: PUSH
24035: LD_INT 36
24037: PUSH
24038: LD_INT 4
24040: PUSH
24041: LD_INT 5
24043: PUSH
24044: LD_INT 31
24046: PUSH
24047: LD_INT 32
24049: PUSH
24050: LD_INT 33
24052: PUSH
24053: EMPTY
24054: LIST
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: LIST
24060: LIST
24061: LIST
24062: LIST
24063: LIST
24064: LIST
24065: IN
24066: NOT
24067: PUSH
24068: NOP4
24072: PUSH
24073: LD_INT 1
24075: EQUAL
24076: AND
24077: OR
24078: PUSH
24079: NOP4
24083: PUSH
24084: LD_INT 2
24086: PUSH
24087: LD_INT 3
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: IN
24094: NOT
24095: PUSH
24096: NOP4
24100: PUSH
24101: LD_INT 2
24103: EQUAL
24104: AND
24105: OR
24106: IFFALSE 24116
// mode = 0 ;
24108: NOP4
24112: PUSH
24113: LD_INT 0
24115: ST_TO_ADDR
// case mode of 0 :
24116: NOP4
24120: PUSH
24121: LD_INT 0
24123: DOUBLE
24124: EQUAL
24125: IFTRUE 24129
24127: GO 35582
24129: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24130: NOP4
24134: PUSH
24135: LD_INT 0
24137: PUSH
24138: LD_INT 0
24140: PUSH
24141: EMPTY
24142: LIST
24143: LIST
24144: PUSH
24145: LD_INT 0
24147: PUSH
24148: LD_INT 1
24150: NEG
24151: PUSH
24152: EMPTY
24153: LIST
24154: LIST
24155: PUSH
24156: LD_INT 1
24158: PUSH
24159: LD_INT 0
24161: PUSH
24162: EMPTY
24163: LIST
24164: LIST
24165: PUSH
24166: LD_INT 1
24168: PUSH
24169: LD_INT 1
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: PUSH
24176: LD_INT 0
24178: PUSH
24179: LD_INT 1
24181: PUSH
24182: EMPTY
24183: LIST
24184: LIST
24185: PUSH
24186: LD_INT 1
24188: NEG
24189: PUSH
24190: LD_INT 0
24192: PUSH
24193: EMPTY
24194: LIST
24195: LIST
24196: PUSH
24197: LD_INT 1
24199: NEG
24200: PUSH
24201: LD_INT 1
24203: NEG
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: LD_INT 1
24211: NEG
24212: PUSH
24213: LD_INT 2
24215: NEG
24216: PUSH
24217: EMPTY
24218: LIST
24219: LIST
24220: PUSH
24221: LD_INT 0
24223: PUSH
24224: LD_INT 2
24226: NEG
24227: PUSH
24228: EMPTY
24229: LIST
24230: LIST
24231: PUSH
24232: LD_INT 1
24234: PUSH
24235: LD_INT 1
24237: NEG
24238: PUSH
24239: EMPTY
24240: LIST
24241: LIST
24242: PUSH
24243: LD_INT 1
24245: PUSH
24246: LD_INT 2
24248: PUSH
24249: EMPTY
24250: LIST
24251: LIST
24252: PUSH
24253: LD_INT 0
24255: PUSH
24256: LD_INT 2
24258: PUSH
24259: EMPTY
24260: LIST
24261: LIST
24262: PUSH
24263: LD_INT 1
24265: NEG
24266: PUSH
24267: LD_INT 1
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: PUSH
24274: LD_INT 1
24276: PUSH
24277: LD_INT 3
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: LD_INT 0
24286: PUSH
24287: LD_INT 3
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: PUSH
24294: LD_INT 1
24296: NEG
24297: PUSH
24298: LD_INT 2
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PUSH
24305: EMPTY
24306: LIST
24307: LIST
24308: LIST
24309: LIST
24310: LIST
24311: LIST
24312: LIST
24313: LIST
24314: LIST
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: LIST
24320: LIST
24321: LIST
24322: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
24323: NOP4
24327: PUSH
24328: LD_INT 0
24330: PUSH
24331: LD_INT 0
24333: PUSH
24334: EMPTY
24335: LIST
24336: LIST
24337: PUSH
24338: LD_INT 0
24340: PUSH
24341: LD_INT 1
24343: NEG
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 1
24351: PUSH
24352: LD_INT 0
24354: PUSH
24355: EMPTY
24356: LIST
24357: LIST
24358: PUSH
24359: LD_INT 1
24361: PUSH
24362: LD_INT 1
24364: PUSH
24365: EMPTY
24366: LIST
24367: LIST
24368: PUSH
24369: LD_INT 0
24371: PUSH
24372: LD_INT 1
24374: PUSH
24375: EMPTY
24376: LIST
24377: LIST
24378: PUSH
24379: LD_INT 1
24381: NEG
24382: PUSH
24383: LD_INT 0
24385: PUSH
24386: EMPTY
24387: LIST
24388: LIST
24389: PUSH
24390: LD_INT 1
24392: NEG
24393: PUSH
24394: LD_INT 1
24396: NEG
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: PUSH
24402: LD_INT 1
24404: PUSH
24405: LD_INT 1
24407: NEG
24408: PUSH
24409: EMPTY
24410: LIST
24411: LIST
24412: PUSH
24413: LD_INT 2
24415: PUSH
24416: LD_INT 0
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: PUSH
24423: LD_INT 2
24425: PUSH
24426: LD_INT 1
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: PUSH
24433: LD_INT 1
24435: NEG
24436: PUSH
24437: LD_INT 1
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PUSH
24444: LD_INT 2
24446: NEG
24447: PUSH
24448: LD_INT 0
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: PUSH
24455: LD_INT 2
24457: NEG
24458: PUSH
24459: LD_INT 1
24461: NEG
24462: PUSH
24463: EMPTY
24464: LIST
24465: LIST
24466: PUSH
24467: LD_INT 2
24469: NEG
24470: PUSH
24471: LD_INT 1
24473: PUSH
24474: EMPTY
24475: LIST
24476: LIST
24477: PUSH
24478: LD_INT 3
24480: NEG
24481: PUSH
24482: LD_INT 0
24484: PUSH
24485: EMPTY
24486: LIST
24487: LIST
24488: PUSH
24489: LD_INT 3
24491: NEG
24492: PUSH
24493: LD_INT 1
24495: NEG
24496: PUSH
24497: EMPTY
24498: LIST
24499: LIST
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: LIST
24514: LIST
24515: LIST
24516: LIST
24517: LIST
24518: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24519: NOP4
24523: PUSH
24524: LD_INT 0
24526: PUSH
24527: LD_INT 0
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: PUSH
24534: LD_INT 0
24536: PUSH
24537: LD_INT 1
24539: NEG
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: LD_INT 1
24547: PUSH
24548: LD_INT 0
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: PUSH
24555: LD_INT 1
24557: PUSH
24558: LD_INT 1
24560: PUSH
24561: EMPTY
24562: LIST
24563: LIST
24564: PUSH
24565: LD_INT 0
24567: PUSH
24568: LD_INT 1
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PUSH
24575: LD_INT 1
24577: NEG
24578: PUSH
24579: LD_INT 0
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 1
24588: NEG
24589: PUSH
24590: LD_INT 1
24592: NEG
24593: PUSH
24594: EMPTY
24595: LIST
24596: LIST
24597: PUSH
24598: LD_INT 1
24600: NEG
24601: PUSH
24602: LD_INT 2
24604: NEG
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 2
24612: PUSH
24613: LD_INT 1
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 2
24622: PUSH
24623: LD_INT 2
24625: PUSH
24626: EMPTY
24627: LIST
24628: LIST
24629: PUSH
24630: LD_INT 1
24632: PUSH
24633: LD_INT 2
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: PUSH
24640: LD_INT 2
24642: NEG
24643: PUSH
24644: LD_INT 1
24646: NEG
24647: PUSH
24648: EMPTY
24649: LIST
24650: LIST
24651: PUSH
24652: LD_INT 2
24654: NEG
24655: PUSH
24656: LD_INT 2
24658: NEG
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: PUSH
24664: LD_INT 2
24666: NEG
24667: PUSH
24668: LD_INT 3
24670: NEG
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: PUSH
24676: LD_INT 3
24678: NEG
24679: PUSH
24680: LD_INT 2
24682: NEG
24683: PUSH
24684: EMPTY
24685: LIST
24686: LIST
24687: PUSH
24688: LD_INT 3
24690: NEG
24691: PUSH
24692: LD_INT 3
24694: NEG
24695: PUSH
24696: EMPTY
24697: LIST
24698: LIST
24699: PUSH
24700: EMPTY
24701: LIST
24702: LIST
24703: LIST
24704: LIST
24705: LIST
24706: LIST
24707: LIST
24708: LIST
24709: LIST
24710: LIST
24711: LIST
24712: LIST
24713: LIST
24714: LIST
24715: LIST
24716: LIST
24717: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24718: NOP4
24722: PUSH
24723: LD_INT 0
24725: PUSH
24726: LD_INT 0
24728: PUSH
24729: EMPTY
24730: LIST
24731: LIST
24732: PUSH
24733: LD_INT 0
24735: PUSH
24736: LD_INT 1
24738: NEG
24739: PUSH
24740: EMPTY
24741: LIST
24742: LIST
24743: PUSH
24744: LD_INT 1
24746: PUSH
24747: LD_INT 0
24749: PUSH
24750: EMPTY
24751: LIST
24752: LIST
24753: PUSH
24754: LD_INT 1
24756: PUSH
24757: LD_INT 1
24759: PUSH
24760: EMPTY
24761: LIST
24762: LIST
24763: PUSH
24764: LD_INT 0
24766: PUSH
24767: LD_INT 1
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 1
24776: NEG
24777: PUSH
24778: LD_INT 0
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 1
24787: NEG
24788: PUSH
24789: LD_INT 1
24791: NEG
24792: PUSH
24793: EMPTY
24794: LIST
24795: LIST
24796: PUSH
24797: LD_INT 1
24799: NEG
24800: PUSH
24801: LD_INT 2
24803: NEG
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: LD_INT 0
24811: PUSH
24812: LD_INT 2
24814: NEG
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PUSH
24820: LD_INT 1
24822: PUSH
24823: LD_INT 1
24825: NEG
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: PUSH
24831: LD_INT 1
24833: PUSH
24834: LD_INT 2
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 0
24843: PUSH
24844: LD_INT 2
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: LD_INT 1
24853: NEG
24854: PUSH
24855: LD_INT 1
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PUSH
24862: LD_INT 1
24864: NEG
24865: PUSH
24866: LD_INT 3
24868: NEG
24869: PUSH
24870: EMPTY
24871: LIST
24872: LIST
24873: PUSH
24874: LD_INT 0
24876: PUSH
24877: LD_INT 3
24879: NEG
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PUSH
24885: LD_INT 1
24887: PUSH
24888: LD_INT 2
24890: NEG
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: LIST
24907: LIST
24908: LIST
24909: LIST
24910: LIST
24911: LIST
24912: LIST
24913: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24914: NOP4
24918: PUSH
24919: LD_INT 0
24921: PUSH
24922: LD_INT 0
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PUSH
24929: LD_INT 0
24931: PUSH
24932: LD_INT 1
24934: NEG
24935: PUSH
24936: EMPTY
24937: LIST
24938: LIST
24939: PUSH
24940: LD_INT 1
24942: PUSH
24943: LD_INT 0
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: PUSH
24950: LD_INT 1
24952: PUSH
24953: LD_INT 1
24955: PUSH
24956: EMPTY
24957: LIST
24958: LIST
24959: PUSH
24960: LD_INT 0
24962: PUSH
24963: LD_INT 1
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 1
24972: NEG
24973: PUSH
24974: LD_INT 0
24976: PUSH
24977: EMPTY
24978: LIST
24979: LIST
24980: PUSH
24981: LD_INT 1
24983: NEG
24984: PUSH
24985: LD_INT 1
24987: NEG
24988: PUSH
24989: EMPTY
24990: LIST
24991: LIST
24992: PUSH
24993: LD_INT 1
24995: PUSH
24996: LD_INT 1
24998: NEG
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: PUSH
25004: LD_INT 2
25006: PUSH
25007: LD_INT 0
25009: PUSH
25010: EMPTY
25011: LIST
25012: LIST
25013: PUSH
25014: LD_INT 2
25016: PUSH
25017: LD_INT 1
25019: PUSH
25020: EMPTY
25021: LIST
25022: LIST
25023: PUSH
25024: LD_INT 1
25026: NEG
25027: PUSH
25028: LD_INT 1
25030: PUSH
25031: EMPTY
25032: LIST
25033: LIST
25034: PUSH
25035: LD_INT 2
25037: NEG
25038: PUSH
25039: LD_INT 0
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: PUSH
25046: LD_INT 2
25048: NEG
25049: PUSH
25050: LD_INT 1
25052: NEG
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: LD_INT 2
25060: PUSH
25061: LD_INT 1
25063: NEG
25064: PUSH
25065: EMPTY
25066: LIST
25067: LIST
25068: PUSH
25069: LD_INT 3
25071: PUSH
25072: LD_INT 0
25074: PUSH
25075: EMPTY
25076: LIST
25077: LIST
25078: PUSH
25079: LD_INT 3
25081: PUSH
25082: LD_INT 1
25084: PUSH
25085: EMPTY
25086: LIST
25087: LIST
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: LIST
25093: LIST
25094: LIST
25095: LIST
25096: LIST
25097: LIST
25098: LIST
25099: LIST
25100: LIST
25101: LIST
25102: LIST
25103: LIST
25104: LIST
25105: LIST
25106: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25107: NOP4
25111: PUSH
25112: LD_INT 0
25114: PUSH
25115: LD_INT 0
25117: PUSH
25118: EMPTY
25119: LIST
25120: LIST
25121: PUSH
25122: LD_INT 0
25124: PUSH
25125: LD_INT 1
25127: NEG
25128: PUSH
25129: EMPTY
25130: LIST
25131: LIST
25132: PUSH
25133: LD_INT 1
25135: PUSH
25136: LD_INT 0
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PUSH
25143: LD_INT 1
25145: PUSH
25146: LD_INT 1
25148: PUSH
25149: EMPTY
25150: LIST
25151: LIST
25152: PUSH
25153: LD_INT 0
25155: PUSH
25156: LD_INT 1
25158: PUSH
25159: EMPTY
25160: LIST
25161: LIST
25162: PUSH
25163: LD_INT 1
25165: NEG
25166: PUSH
25167: LD_INT 0
25169: PUSH
25170: EMPTY
25171: LIST
25172: LIST
25173: PUSH
25174: LD_INT 1
25176: NEG
25177: PUSH
25178: LD_INT 1
25180: NEG
25181: PUSH
25182: EMPTY
25183: LIST
25184: LIST
25185: PUSH
25186: LD_INT 1
25188: NEG
25189: PUSH
25190: LD_INT 2
25192: NEG
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: PUSH
25198: LD_INT 2
25200: PUSH
25201: LD_INT 1
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 2
25210: PUSH
25211: LD_INT 2
25213: PUSH
25214: EMPTY
25215: LIST
25216: LIST
25217: PUSH
25218: LD_INT 1
25220: PUSH
25221: LD_INT 2
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: PUSH
25228: LD_INT 2
25230: NEG
25231: PUSH
25232: LD_INT 1
25234: NEG
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: PUSH
25240: LD_INT 2
25242: NEG
25243: PUSH
25244: LD_INT 2
25246: NEG
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: PUSH
25252: LD_INT 3
25254: PUSH
25255: LD_INT 2
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PUSH
25262: LD_INT 3
25264: PUSH
25265: LD_INT 3
25267: PUSH
25268: EMPTY
25269: LIST
25270: LIST
25271: PUSH
25272: LD_INT 2
25274: PUSH
25275: LD_INT 3
25277: PUSH
25278: EMPTY
25279: LIST
25280: LIST
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: LIST
25286: LIST
25287: LIST
25288: LIST
25289: LIST
25290: LIST
25291: LIST
25292: LIST
25293: LIST
25294: LIST
25295: LIST
25296: LIST
25297: LIST
25298: LIST
25299: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25300: NOP4
25304: PUSH
25305: LD_INT 0
25307: PUSH
25308: LD_INT 0
25310: PUSH
25311: EMPTY
25312: LIST
25313: LIST
25314: PUSH
25315: LD_INT 0
25317: PUSH
25318: LD_INT 1
25320: NEG
25321: PUSH
25322: EMPTY
25323: LIST
25324: LIST
25325: PUSH
25326: LD_INT 1
25328: PUSH
25329: LD_INT 0
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: PUSH
25336: LD_INT 1
25338: PUSH
25339: LD_INT 1
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PUSH
25346: LD_INT 0
25348: PUSH
25349: LD_INT 1
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: PUSH
25356: LD_INT 1
25358: NEG
25359: PUSH
25360: LD_INT 0
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: LD_INT 1
25369: NEG
25370: PUSH
25371: LD_INT 1
25373: NEG
25374: PUSH
25375: EMPTY
25376: LIST
25377: LIST
25378: PUSH
25379: LD_INT 1
25381: NEG
25382: PUSH
25383: LD_INT 2
25385: NEG
25386: PUSH
25387: EMPTY
25388: LIST
25389: LIST
25390: PUSH
25391: LD_INT 0
25393: PUSH
25394: LD_INT 2
25396: NEG
25397: PUSH
25398: EMPTY
25399: LIST
25400: LIST
25401: PUSH
25402: LD_INT 1
25404: PUSH
25405: LD_INT 1
25407: NEG
25408: PUSH
25409: EMPTY
25410: LIST
25411: LIST
25412: PUSH
25413: LD_INT 2
25415: PUSH
25416: LD_INT 0
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PUSH
25423: LD_INT 2
25425: PUSH
25426: LD_INT 1
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: PUSH
25433: LD_INT 2
25435: PUSH
25436: LD_INT 2
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: PUSH
25443: LD_INT 1
25445: PUSH
25446: LD_INT 2
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: PUSH
25453: LD_INT 0
25455: PUSH
25456: LD_INT 2
25458: PUSH
25459: EMPTY
25460: LIST
25461: LIST
25462: PUSH
25463: LD_INT 1
25465: NEG
25466: PUSH
25467: LD_INT 1
25469: PUSH
25470: EMPTY
25471: LIST
25472: LIST
25473: PUSH
25474: LD_INT 2
25476: NEG
25477: PUSH
25478: LD_INT 0
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: LD_INT 2
25487: NEG
25488: PUSH
25489: LD_INT 1
25491: NEG
25492: PUSH
25493: EMPTY
25494: LIST
25495: LIST
25496: PUSH
25497: LD_INT 2
25499: NEG
25500: PUSH
25501: LD_INT 2
25503: NEG
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: LIST
25513: LIST
25514: LIST
25515: LIST
25516: LIST
25517: LIST
25518: LIST
25519: LIST
25520: LIST
25521: LIST
25522: LIST
25523: LIST
25524: LIST
25525: LIST
25526: LIST
25527: LIST
25528: LIST
25529: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25530: NOP4
25534: PUSH
25535: LD_INT 0
25537: PUSH
25538: LD_INT 0
25540: PUSH
25541: EMPTY
25542: LIST
25543: LIST
25544: PUSH
25545: LD_INT 0
25547: PUSH
25548: LD_INT 1
25550: NEG
25551: PUSH
25552: EMPTY
25553: LIST
25554: LIST
25555: PUSH
25556: LD_INT 1
25558: PUSH
25559: LD_INT 0
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 1
25568: PUSH
25569: LD_INT 1
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 0
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 1
25588: NEG
25589: PUSH
25590: LD_INT 0
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 1
25599: NEG
25600: PUSH
25601: LD_INT 1
25603: NEG
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: PUSH
25609: LD_INT 1
25611: NEG
25612: PUSH
25613: LD_INT 2
25615: NEG
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 0
25623: PUSH
25624: LD_INT 2
25626: NEG
25627: PUSH
25628: EMPTY
25629: LIST
25630: LIST
25631: PUSH
25632: LD_INT 1
25634: PUSH
25635: LD_INT 1
25637: NEG
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 2
25645: PUSH
25646: LD_INT 0
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 2
25655: PUSH
25656: LD_INT 1
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 2
25665: PUSH
25666: LD_INT 2
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PUSH
25673: LD_INT 1
25675: PUSH
25676: LD_INT 2
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: LD_INT 0
25685: PUSH
25686: LD_INT 2
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: PUSH
25693: LD_INT 1
25695: NEG
25696: PUSH
25697: LD_INT 1
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: LD_INT 2
25706: NEG
25707: PUSH
25708: LD_INT 0
25710: PUSH
25711: EMPTY
25712: LIST
25713: LIST
25714: PUSH
25715: LD_INT 2
25717: NEG
25718: PUSH
25719: LD_INT 1
25721: NEG
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: PUSH
25727: LD_INT 2
25729: NEG
25730: PUSH
25731: LD_INT 2
25733: NEG
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: LIST
25743: LIST
25744: LIST
25745: LIST
25746: LIST
25747: LIST
25748: LIST
25749: LIST
25750: LIST
25751: LIST
25752: LIST
25753: LIST
25754: LIST
25755: LIST
25756: LIST
25757: LIST
25758: LIST
25759: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25760: NOP4
25764: PUSH
25765: LD_INT 0
25767: PUSH
25768: LD_INT 0
25770: PUSH
25771: EMPTY
25772: LIST
25773: LIST
25774: PUSH
25775: LD_INT 0
25777: PUSH
25778: LD_INT 1
25780: NEG
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PUSH
25786: LD_INT 1
25788: PUSH
25789: LD_INT 0
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 1
25798: PUSH
25799: LD_INT 1
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 0
25808: PUSH
25809: LD_INT 1
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: LD_INT 1
25818: NEG
25819: PUSH
25820: LD_INT 0
25822: PUSH
25823: EMPTY
25824: LIST
25825: LIST
25826: PUSH
25827: LD_INT 1
25829: NEG
25830: PUSH
25831: LD_INT 1
25833: NEG
25834: PUSH
25835: EMPTY
25836: LIST
25837: LIST
25838: PUSH
25839: LD_INT 1
25841: NEG
25842: PUSH
25843: LD_INT 2
25845: NEG
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PUSH
25851: LD_INT 0
25853: PUSH
25854: LD_INT 2
25856: NEG
25857: PUSH
25858: EMPTY
25859: LIST
25860: LIST
25861: PUSH
25862: LD_INT 1
25864: PUSH
25865: LD_INT 1
25867: NEG
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 2
25875: PUSH
25876: LD_INT 0
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 2
25885: PUSH
25886: LD_INT 1
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: LD_INT 2
25895: PUSH
25896: LD_INT 2
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: LD_INT 1
25905: PUSH
25906: LD_INT 2
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PUSH
25913: LD_INT 0
25915: PUSH
25916: LD_INT 2
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: PUSH
25923: LD_INT 1
25925: NEG
25926: PUSH
25927: LD_INT 1
25929: PUSH
25930: EMPTY
25931: LIST
25932: LIST
25933: PUSH
25934: LD_INT 2
25936: NEG
25937: PUSH
25938: LD_INT 0
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: PUSH
25945: LD_INT 2
25947: NEG
25948: PUSH
25949: LD_INT 1
25951: NEG
25952: PUSH
25953: EMPTY
25954: LIST
25955: LIST
25956: PUSH
25957: LD_INT 2
25959: NEG
25960: PUSH
25961: LD_INT 2
25963: NEG
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: LIST
25973: LIST
25974: LIST
25975: LIST
25976: LIST
25977: LIST
25978: LIST
25979: LIST
25980: LIST
25981: LIST
25982: LIST
25983: LIST
25984: LIST
25985: LIST
25986: LIST
25987: LIST
25988: LIST
25989: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25990: NOP4
25994: PUSH
25995: LD_INT 0
25997: PUSH
25998: LD_INT 0
26000: PUSH
26001: EMPTY
26002: LIST
26003: LIST
26004: PUSH
26005: LD_INT 0
26007: PUSH
26008: LD_INT 1
26010: NEG
26011: PUSH
26012: EMPTY
26013: LIST
26014: LIST
26015: PUSH
26016: LD_INT 1
26018: PUSH
26019: LD_INT 0
26021: PUSH
26022: EMPTY
26023: LIST
26024: LIST
26025: PUSH
26026: LD_INT 1
26028: PUSH
26029: LD_INT 1
26031: PUSH
26032: EMPTY
26033: LIST
26034: LIST
26035: PUSH
26036: LD_INT 0
26038: PUSH
26039: LD_INT 1
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 1
26048: NEG
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PUSH
26057: LD_INT 1
26059: NEG
26060: PUSH
26061: LD_INT 1
26063: NEG
26064: PUSH
26065: EMPTY
26066: LIST
26067: LIST
26068: PUSH
26069: LD_INT 1
26071: NEG
26072: PUSH
26073: LD_INT 2
26075: NEG
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PUSH
26081: LD_INT 0
26083: PUSH
26084: LD_INT 2
26086: NEG
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 1
26094: PUSH
26095: LD_INT 1
26097: NEG
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 2
26105: PUSH
26106: LD_INT 0
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 2
26115: PUSH
26116: LD_INT 1
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 2
26125: PUSH
26126: LD_INT 2
26128: PUSH
26129: EMPTY
26130: LIST
26131: LIST
26132: PUSH
26133: LD_INT 1
26135: PUSH
26136: LD_INT 2
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 0
26145: PUSH
26146: LD_INT 2
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: PUSH
26153: LD_INT 1
26155: NEG
26156: PUSH
26157: LD_INT 1
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: PUSH
26164: LD_INT 2
26166: NEG
26167: PUSH
26168: LD_INT 0
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PUSH
26175: LD_INT 2
26177: NEG
26178: PUSH
26179: LD_INT 1
26181: NEG
26182: PUSH
26183: EMPTY
26184: LIST
26185: LIST
26186: PUSH
26187: LD_INT 2
26189: NEG
26190: PUSH
26191: LD_INT 2
26193: NEG
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: LIST
26203: LIST
26204: LIST
26205: LIST
26206: LIST
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: LIST
26216: LIST
26217: LIST
26218: LIST
26219: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26220: NOP4
26224: PUSH
26225: LD_INT 0
26227: PUSH
26228: LD_INT 0
26230: PUSH
26231: EMPTY
26232: LIST
26233: LIST
26234: PUSH
26235: LD_INT 0
26237: PUSH
26238: LD_INT 1
26240: NEG
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: PUSH
26246: LD_INT 1
26248: PUSH
26249: LD_INT 0
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: LD_INT 1
26258: PUSH
26259: LD_INT 1
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: LD_INT 0
26268: PUSH
26269: LD_INT 1
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 1
26278: NEG
26279: PUSH
26280: LD_INT 0
26282: PUSH
26283: EMPTY
26284: LIST
26285: LIST
26286: PUSH
26287: LD_INT 1
26289: NEG
26290: PUSH
26291: LD_INT 1
26293: NEG
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: PUSH
26299: LD_INT 1
26301: NEG
26302: PUSH
26303: LD_INT 2
26305: NEG
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: PUSH
26311: LD_INT 0
26313: PUSH
26314: LD_INT 2
26316: NEG
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: LD_INT 1
26324: PUSH
26325: LD_INT 1
26327: NEG
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 2
26335: PUSH
26336: LD_INT 0
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 2
26345: PUSH
26346: LD_INT 1
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: PUSH
26353: LD_INT 2
26355: PUSH
26356: LD_INT 2
26358: PUSH
26359: EMPTY
26360: LIST
26361: LIST
26362: PUSH
26363: LD_INT 1
26365: PUSH
26366: LD_INT 2
26368: PUSH
26369: EMPTY
26370: LIST
26371: LIST
26372: PUSH
26373: LD_INT 0
26375: PUSH
26376: LD_INT 2
26378: PUSH
26379: EMPTY
26380: LIST
26381: LIST
26382: PUSH
26383: LD_INT 1
26385: NEG
26386: PUSH
26387: LD_INT 1
26389: PUSH
26390: EMPTY
26391: LIST
26392: LIST
26393: PUSH
26394: LD_INT 2
26396: NEG
26397: PUSH
26398: LD_INT 0
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 2
26407: NEG
26408: PUSH
26409: LD_INT 1
26411: NEG
26412: PUSH
26413: EMPTY
26414: LIST
26415: LIST
26416: PUSH
26417: LD_INT 2
26419: NEG
26420: PUSH
26421: LD_INT 2
26423: NEG
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: LIST
26433: LIST
26434: LIST
26435: LIST
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26450: NOP4
26454: PUSH
26455: LD_INT 0
26457: PUSH
26458: LD_INT 0
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 0
26467: PUSH
26468: LD_INT 1
26470: NEG
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PUSH
26476: LD_INT 1
26478: PUSH
26479: LD_INT 0
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 1
26488: PUSH
26489: LD_INT 1
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: LD_INT 0
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 1
26508: NEG
26509: PUSH
26510: LD_INT 0
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 1
26519: NEG
26520: PUSH
26521: LD_INT 1
26523: NEG
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: LD_INT 1
26531: NEG
26532: PUSH
26533: LD_INT 2
26535: NEG
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 0
26543: PUSH
26544: LD_INT 2
26546: NEG
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PUSH
26552: LD_INT 1
26554: PUSH
26555: LD_INT 1
26557: NEG
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 2
26565: PUSH
26566: LD_INT 0
26568: PUSH
26569: EMPTY
26570: LIST
26571: LIST
26572: PUSH
26573: LD_INT 2
26575: PUSH
26576: LD_INT 1
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: LD_INT 2
26585: PUSH
26586: LD_INT 2
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PUSH
26593: LD_INT 1
26595: PUSH
26596: LD_INT 2
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: PUSH
26603: LD_INT 0
26605: PUSH
26606: LD_INT 2
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PUSH
26613: LD_INT 1
26615: NEG
26616: PUSH
26617: LD_INT 1
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 2
26626: NEG
26627: PUSH
26628: LD_INT 0
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 2
26637: NEG
26638: PUSH
26639: LD_INT 1
26641: NEG
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 2
26649: NEG
26650: PUSH
26651: LD_INT 2
26653: NEG
26654: PUSH
26655: EMPTY
26656: LIST
26657: LIST
26658: PUSH
26659: EMPTY
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26680: NOP4
26684: PUSH
26685: LD_INT 0
26687: PUSH
26688: LD_INT 0
26690: PUSH
26691: EMPTY
26692: LIST
26693: LIST
26694: PUSH
26695: LD_INT 0
26697: PUSH
26698: LD_INT 1
26700: NEG
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: LD_INT 1
26708: PUSH
26709: LD_INT 0
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 1
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 0
26728: PUSH
26729: LD_INT 1
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: PUSH
26736: LD_INT 1
26738: NEG
26739: PUSH
26740: LD_INT 0
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: PUSH
26747: LD_INT 1
26749: NEG
26750: PUSH
26751: LD_INT 1
26753: NEG
26754: PUSH
26755: EMPTY
26756: LIST
26757: LIST
26758: PUSH
26759: LD_INT 1
26761: NEG
26762: PUSH
26763: LD_INT 2
26765: NEG
26766: PUSH
26767: EMPTY
26768: LIST
26769: LIST
26770: PUSH
26771: LD_INT 0
26773: PUSH
26774: LD_INT 2
26776: NEG
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 1
26784: PUSH
26785: LD_INT 1
26787: NEG
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PUSH
26793: LD_INT 2
26795: PUSH
26796: LD_INT 0
26798: PUSH
26799: EMPTY
26800: LIST
26801: LIST
26802: PUSH
26803: LD_INT 2
26805: PUSH
26806: LD_INT 1
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PUSH
26813: LD_INT 2
26815: PUSH
26816: LD_INT 2
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PUSH
26823: LD_INT 1
26825: PUSH
26826: LD_INT 2
26828: PUSH
26829: EMPTY
26830: LIST
26831: LIST
26832: PUSH
26833: LD_INT 0
26835: PUSH
26836: LD_INT 2
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: PUSH
26843: LD_INT 1
26845: NEG
26846: PUSH
26847: LD_INT 1
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 2
26856: NEG
26857: PUSH
26858: LD_INT 0
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 2
26867: NEG
26868: PUSH
26869: LD_INT 1
26871: NEG
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 2
26879: NEG
26880: PUSH
26881: LD_INT 2
26883: NEG
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: LD_INT 2
26891: NEG
26892: PUSH
26893: LD_INT 3
26895: NEG
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 1
26903: NEG
26904: PUSH
26905: LD_INT 3
26907: NEG
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: LD_INT 1
26915: PUSH
26916: LD_INT 2
26918: NEG
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 2
26926: PUSH
26927: LD_INT 1
26929: NEG
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: LIST
26939: LIST
26940: LIST
26941: LIST
26942: LIST
26943: LIST
26944: LIST
26945: LIST
26946: LIST
26947: LIST
26948: LIST
26949: LIST
26950: LIST
26951: LIST
26952: LIST
26953: LIST
26954: LIST
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26960: NOP4
26964: PUSH
26965: LD_INT 0
26967: PUSH
26968: LD_INT 0
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 0
26977: PUSH
26978: LD_INT 1
26980: NEG
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: LD_INT 1
26988: PUSH
26989: LD_INT 0
26991: PUSH
26992: EMPTY
26993: LIST
26994: LIST
26995: PUSH
26996: LD_INT 1
26998: PUSH
26999: LD_INT 1
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 0
27008: PUSH
27009: LD_INT 1
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: PUSH
27016: LD_INT 1
27018: NEG
27019: PUSH
27020: LD_INT 0
27022: PUSH
27023: EMPTY
27024: LIST
27025: LIST
27026: PUSH
27027: LD_INT 1
27029: NEG
27030: PUSH
27031: LD_INT 1
27033: NEG
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: PUSH
27039: LD_INT 1
27041: NEG
27042: PUSH
27043: LD_INT 2
27045: NEG
27046: PUSH
27047: EMPTY
27048: LIST
27049: LIST
27050: PUSH
27051: LD_INT 0
27053: PUSH
27054: LD_INT 2
27056: NEG
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 1
27064: PUSH
27065: LD_INT 1
27067: NEG
27068: PUSH
27069: EMPTY
27070: LIST
27071: LIST
27072: PUSH
27073: LD_INT 2
27075: PUSH
27076: LD_INT 0
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 2
27085: PUSH
27086: LD_INT 1
27088: PUSH
27089: EMPTY
27090: LIST
27091: LIST
27092: PUSH
27093: LD_INT 2
27095: PUSH
27096: LD_INT 2
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: PUSH
27103: LD_INT 1
27105: PUSH
27106: LD_INT 2
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 0
27115: PUSH
27116: LD_INT 2
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PUSH
27123: LD_INT 1
27125: NEG
27126: PUSH
27127: LD_INT 1
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: PUSH
27134: LD_INT 2
27136: NEG
27137: PUSH
27138: LD_INT 0
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 2
27147: NEG
27148: PUSH
27149: LD_INT 1
27151: NEG
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: PUSH
27157: LD_INT 2
27159: NEG
27160: PUSH
27161: LD_INT 2
27163: NEG
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: LD_INT 2
27174: NEG
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 2
27182: PUSH
27183: LD_INT 1
27185: NEG
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 3
27193: PUSH
27194: LD_INT 1
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 3
27203: PUSH
27204: LD_INT 2
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: LIST
27215: LIST
27216: LIST
27217: LIST
27218: LIST
27219: LIST
27220: LIST
27221: LIST
27222: LIST
27223: LIST
27224: LIST
27225: LIST
27226: LIST
27227: LIST
27228: LIST
27229: LIST
27230: LIST
27231: LIST
27232: LIST
27233: LIST
27234: LIST
27235: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
27236: NOP4
27240: PUSH
27241: LD_INT 0
27243: PUSH
27244: LD_INT 0
27246: PUSH
27247: EMPTY
27248: LIST
27249: LIST
27250: PUSH
27251: LD_INT 0
27253: PUSH
27254: LD_INT 1
27256: NEG
27257: PUSH
27258: EMPTY
27259: LIST
27260: LIST
27261: PUSH
27262: LD_INT 1
27264: PUSH
27265: LD_INT 0
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: LD_INT 1
27274: PUSH
27275: LD_INT 1
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PUSH
27282: LD_INT 0
27284: PUSH
27285: LD_INT 1
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: LD_INT 1
27294: NEG
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: EMPTY
27300: LIST
27301: LIST
27302: PUSH
27303: LD_INT 1
27305: NEG
27306: PUSH
27307: LD_INT 1
27309: NEG
27310: PUSH
27311: EMPTY
27312: LIST
27313: LIST
27314: PUSH
27315: LD_INT 1
27317: NEG
27318: PUSH
27319: LD_INT 2
27321: NEG
27322: PUSH
27323: EMPTY
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 0
27329: PUSH
27330: LD_INT 2
27332: NEG
27333: PUSH
27334: EMPTY
27335: LIST
27336: LIST
27337: PUSH
27338: LD_INT 1
27340: PUSH
27341: LD_INT 1
27343: NEG
27344: PUSH
27345: EMPTY
27346: LIST
27347: LIST
27348: PUSH
27349: LD_INT 2
27351: PUSH
27352: LD_INT 0
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: PUSH
27359: LD_INT 2
27361: PUSH
27362: LD_INT 1
27364: PUSH
27365: EMPTY
27366: LIST
27367: LIST
27368: PUSH
27369: LD_INT 2
27371: PUSH
27372: LD_INT 2
27374: PUSH
27375: EMPTY
27376: LIST
27377: LIST
27378: PUSH
27379: LD_INT 1
27381: PUSH
27382: LD_INT 2
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: LD_INT 0
27391: PUSH
27392: LD_INT 2
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: PUSH
27399: LD_INT 1
27401: NEG
27402: PUSH
27403: LD_INT 1
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PUSH
27410: LD_INT 2
27412: NEG
27413: PUSH
27414: LD_INT 0
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 2
27423: NEG
27424: PUSH
27425: LD_INT 1
27427: NEG
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: PUSH
27433: LD_INT 2
27435: NEG
27436: PUSH
27437: LD_INT 2
27439: NEG
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 3
27447: PUSH
27448: LD_INT 1
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: LD_INT 3
27457: PUSH
27458: LD_INT 2
27460: PUSH
27461: EMPTY
27462: LIST
27463: LIST
27464: PUSH
27465: LD_INT 2
27467: PUSH
27468: LD_INT 3
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 1
27477: PUSH
27478: LD_INT 3
27480: PUSH
27481: EMPTY
27482: LIST
27483: LIST
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: LIST
27489: LIST
27490: LIST
27491: LIST
27492: LIST
27493: LIST
27494: LIST
27495: LIST
27496: LIST
27497: LIST
27498: LIST
27499: LIST
27500: LIST
27501: LIST
27502: LIST
27503: LIST
27504: LIST
27505: LIST
27506: LIST
27507: LIST
27508: LIST
27509: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27510: NOP4
27514: PUSH
27515: LD_INT 0
27517: PUSH
27518: LD_INT 0
27520: PUSH
27521: EMPTY
27522: LIST
27523: LIST
27524: PUSH
27525: LD_INT 0
27527: PUSH
27528: LD_INT 1
27530: NEG
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 1
27538: PUSH
27539: LD_INT 0
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PUSH
27546: LD_INT 1
27548: PUSH
27549: LD_INT 1
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: PUSH
27556: LD_INT 0
27558: PUSH
27559: LD_INT 1
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 1
27568: NEG
27569: PUSH
27570: LD_INT 0
27572: PUSH
27573: EMPTY
27574: LIST
27575: LIST
27576: PUSH
27577: LD_INT 1
27579: NEG
27580: PUSH
27581: LD_INT 1
27583: NEG
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: NEG
27592: PUSH
27593: LD_INT 2
27595: NEG
27596: PUSH
27597: EMPTY
27598: LIST
27599: LIST
27600: PUSH
27601: LD_INT 0
27603: PUSH
27604: LD_INT 2
27606: NEG
27607: PUSH
27608: EMPTY
27609: LIST
27610: LIST
27611: PUSH
27612: LD_INT 1
27614: PUSH
27615: LD_INT 1
27617: NEG
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: LD_INT 2
27625: PUSH
27626: LD_INT 0
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 2
27635: PUSH
27636: LD_INT 1
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PUSH
27643: LD_INT 2
27645: PUSH
27646: LD_INT 2
27648: PUSH
27649: EMPTY
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 1
27655: PUSH
27656: LD_INT 2
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: LD_INT 2
27668: PUSH
27669: EMPTY
27670: LIST
27671: LIST
27672: PUSH
27673: LD_INT 1
27675: NEG
27676: PUSH
27677: LD_INT 1
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: PUSH
27684: LD_INT 2
27686: NEG
27687: PUSH
27688: LD_INT 0
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: PUSH
27695: LD_INT 2
27697: NEG
27698: PUSH
27699: LD_INT 1
27701: NEG
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 2
27709: NEG
27710: PUSH
27711: LD_INT 2
27713: NEG
27714: PUSH
27715: EMPTY
27716: LIST
27717: LIST
27718: PUSH
27719: LD_INT 2
27721: PUSH
27722: LD_INT 3
27724: PUSH
27725: EMPTY
27726: LIST
27727: LIST
27728: PUSH
27729: LD_INT 1
27731: PUSH
27732: LD_INT 3
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: PUSH
27739: LD_INT 1
27741: NEG
27742: PUSH
27743: LD_INT 2
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: PUSH
27750: LD_INT 2
27752: NEG
27753: PUSH
27754: LD_INT 1
27756: PUSH
27757: EMPTY
27758: LIST
27759: LIST
27760: PUSH
27761: EMPTY
27762: LIST
27763: LIST
27764: LIST
27765: LIST
27766: LIST
27767: LIST
27768: LIST
27769: LIST
27770: LIST
27771: LIST
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: LIST
27777: LIST
27778: LIST
27779: LIST
27780: LIST
27781: LIST
27782: LIST
27783: LIST
27784: LIST
27785: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27786: NOP4
27790: PUSH
27791: LD_INT 0
27793: PUSH
27794: LD_INT 0
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: LD_INT 0
27803: PUSH
27804: LD_INT 1
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: LD_INT 1
27814: PUSH
27815: LD_INT 0
27817: PUSH
27818: EMPTY
27819: LIST
27820: LIST
27821: PUSH
27822: LD_INT 1
27824: PUSH
27825: LD_INT 1
27827: PUSH
27828: EMPTY
27829: LIST
27830: LIST
27831: PUSH
27832: LD_INT 0
27834: PUSH
27835: LD_INT 1
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: PUSH
27842: LD_INT 1
27844: NEG
27845: PUSH
27846: LD_INT 0
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: PUSH
27853: LD_INT 1
27855: NEG
27856: PUSH
27857: LD_INT 1
27859: NEG
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 1
27867: NEG
27868: PUSH
27869: LD_INT 2
27871: NEG
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 0
27879: PUSH
27880: LD_INT 2
27882: NEG
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 1
27890: PUSH
27891: LD_INT 1
27893: NEG
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 2
27901: PUSH
27902: LD_INT 0
27904: PUSH
27905: EMPTY
27906: LIST
27907: LIST
27908: PUSH
27909: LD_INT 2
27911: PUSH
27912: LD_INT 1
27914: PUSH
27915: EMPTY
27916: LIST
27917: LIST
27918: PUSH
27919: LD_INT 2
27921: PUSH
27922: LD_INT 2
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: PUSH
27929: LD_INT 1
27931: PUSH
27932: LD_INT 2
27934: PUSH
27935: EMPTY
27936: LIST
27937: LIST
27938: PUSH
27939: LD_INT 0
27941: PUSH
27942: LD_INT 2
27944: PUSH
27945: EMPTY
27946: LIST
27947: LIST
27948: PUSH
27949: LD_INT 1
27951: NEG
27952: PUSH
27953: LD_INT 1
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: LD_INT 2
27962: NEG
27963: PUSH
27964: LD_INT 0
27966: PUSH
27967: EMPTY
27968: LIST
27969: LIST
27970: PUSH
27971: LD_INT 2
27973: NEG
27974: PUSH
27975: LD_INT 1
27977: NEG
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 2
27985: NEG
27986: PUSH
27987: LD_INT 2
27989: NEG
27990: PUSH
27991: EMPTY
27992: LIST
27993: LIST
27994: PUSH
27995: LD_INT 1
27997: NEG
27998: PUSH
27999: LD_INT 2
28001: PUSH
28002: EMPTY
28003: LIST
28004: LIST
28005: PUSH
28006: LD_INT 2
28008: NEG
28009: PUSH
28010: LD_INT 1
28012: PUSH
28013: EMPTY
28014: LIST
28015: LIST
28016: PUSH
28017: LD_INT 3
28019: NEG
28020: PUSH
28021: LD_INT 1
28023: NEG
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: LD_INT 3
28031: NEG
28032: PUSH
28033: LD_INT 2
28035: NEG
28036: PUSH
28037: EMPTY
28038: LIST
28039: LIST
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: LIST
28045: LIST
28046: LIST
28047: LIST
28048: LIST
28049: LIST
28050: LIST
28051: LIST
28052: LIST
28053: LIST
28054: LIST
28055: LIST
28056: LIST
28057: LIST
28058: LIST
28059: LIST
28060: LIST
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28066: NOP4
28070: PUSH
28071: LD_INT 0
28073: PUSH
28074: LD_INT 0
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 0
28083: PUSH
28084: LD_INT 1
28086: NEG
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 1
28094: PUSH
28095: LD_INT 0
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 1
28104: PUSH
28105: LD_INT 1
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: PUSH
28112: LD_INT 0
28114: PUSH
28115: LD_INT 1
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 1
28124: NEG
28125: PUSH
28126: LD_INT 0
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 1
28135: NEG
28136: PUSH
28137: LD_INT 1
28139: NEG
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 1
28147: NEG
28148: PUSH
28149: LD_INT 2
28151: NEG
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: PUSH
28157: LD_INT 0
28159: PUSH
28160: LD_INT 2
28162: NEG
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: PUSH
28168: LD_INT 1
28170: PUSH
28171: LD_INT 1
28173: NEG
28174: PUSH
28175: EMPTY
28176: LIST
28177: LIST
28178: PUSH
28179: LD_INT 2
28181: PUSH
28182: LD_INT 0
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: PUSH
28189: LD_INT 2
28191: PUSH
28192: LD_INT 1
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 2
28201: PUSH
28202: LD_INT 2
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: LD_INT 1
28211: PUSH
28212: LD_INT 2
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: LD_INT 0
28221: PUSH
28222: LD_INT 2
28224: PUSH
28225: EMPTY
28226: LIST
28227: LIST
28228: PUSH
28229: LD_INT 1
28231: NEG
28232: PUSH
28233: LD_INT 1
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: LD_INT 2
28242: NEG
28243: PUSH
28244: LD_INT 0
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 2
28253: NEG
28254: PUSH
28255: LD_INT 1
28257: NEG
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 2
28265: NEG
28266: PUSH
28267: LD_INT 2
28269: NEG
28270: PUSH
28271: EMPTY
28272: LIST
28273: LIST
28274: PUSH
28275: LD_INT 2
28277: NEG
28278: PUSH
28279: LD_INT 3
28281: NEG
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 1
28289: NEG
28290: PUSH
28291: LD_INT 3
28293: NEG
28294: PUSH
28295: EMPTY
28296: LIST
28297: LIST
28298: PUSH
28299: LD_INT 3
28301: NEG
28302: PUSH
28303: LD_INT 1
28305: NEG
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: LD_INT 3
28313: NEG
28314: PUSH
28315: LD_INT 2
28317: NEG
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: LIST
28327: LIST
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: LIST
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: LIST
28339: LIST
28340: LIST
28341: LIST
28342: LIST
28343: LIST
28344: LIST
28345: LIST
28346: LIST
28347: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28348: NOP4
28352: PUSH
28353: LD_INT 0
28355: PUSH
28356: LD_INT 0
28358: PUSH
28359: EMPTY
28360: LIST
28361: LIST
28362: PUSH
28363: LD_INT 0
28365: PUSH
28366: LD_INT 1
28368: NEG
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: LD_INT 1
28376: PUSH
28377: LD_INT 0
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: PUSH
28384: LD_INT 1
28386: PUSH
28387: LD_INT 1
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: LD_INT 1
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 1
28406: NEG
28407: PUSH
28408: LD_INT 0
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 1
28417: NEG
28418: PUSH
28419: LD_INT 1
28421: NEG
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 1
28429: NEG
28430: PUSH
28431: LD_INT 2
28433: NEG
28434: PUSH
28435: EMPTY
28436: LIST
28437: LIST
28438: PUSH
28439: LD_INT 0
28441: PUSH
28442: LD_INT 2
28444: NEG
28445: PUSH
28446: EMPTY
28447: LIST
28448: LIST
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: LD_INT 1
28455: NEG
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PUSH
28461: LD_INT 2
28463: PUSH
28464: LD_INT 0
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: LD_INT 2
28473: PUSH
28474: LD_INT 1
28476: PUSH
28477: EMPTY
28478: LIST
28479: LIST
28480: PUSH
28481: LD_INT 1
28483: PUSH
28484: LD_INT 2
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 0
28493: PUSH
28494: LD_INT 2
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PUSH
28501: LD_INT 1
28503: NEG
28504: PUSH
28505: LD_INT 1
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: LD_INT 2
28514: NEG
28515: PUSH
28516: LD_INT 1
28518: NEG
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 2
28526: NEG
28527: PUSH
28528: LD_INT 2
28530: NEG
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: LD_INT 2
28538: NEG
28539: PUSH
28540: LD_INT 3
28542: NEG
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 2
28550: PUSH
28551: LD_INT 1
28553: NEG
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 3
28561: PUSH
28562: LD_INT 1
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: LD_INT 3
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 1
28581: NEG
28582: PUSH
28583: LD_INT 2
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: LD_INT 3
28592: NEG
28593: PUSH
28594: LD_INT 2
28596: NEG
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: LIST
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: LIST
28611: LIST
28612: LIST
28613: LIST
28614: LIST
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28627: NOP4
28631: PUSH
28632: LD_INT 0
28634: PUSH
28635: LD_INT 0
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PUSH
28642: LD_INT 0
28644: PUSH
28645: LD_INT 1
28647: NEG
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 1
28655: PUSH
28656: LD_INT 0
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: PUSH
28663: LD_INT 1
28665: PUSH
28666: LD_INT 1
28668: PUSH
28669: EMPTY
28670: LIST
28671: LIST
28672: PUSH
28673: LD_INT 0
28675: PUSH
28676: LD_INT 1
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: LD_INT 1
28685: NEG
28686: PUSH
28687: LD_INT 0
28689: PUSH
28690: EMPTY
28691: LIST
28692: LIST
28693: PUSH
28694: LD_INT 1
28696: NEG
28697: PUSH
28698: LD_INT 1
28700: NEG
28701: PUSH
28702: EMPTY
28703: LIST
28704: LIST
28705: PUSH
28706: LD_INT 1
28708: NEG
28709: PUSH
28710: LD_INT 2
28712: NEG
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 0
28720: PUSH
28721: LD_INT 2
28723: NEG
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: PUSH
28729: LD_INT 1
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 2
28742: PUSH
28743: LD_INT 0
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 2
28752: PUSH
28753: LD_INT 1
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: LD_INT 2
28762: PUSH
28763: LD_INT 2
28765: PUSH
28766: EMPTY
28767: LIST
28768: LIST
28769: PUSH
28770: LD_INT 1
28772: PUSH
28773: LD_INT 2
28775: PUSH
28776: EMPTY
28777: LIST
28778: LIST
28779: PUSH
28780: LD_INT 1
28782: NEG
28783: PUSH
28784: LD_INT 1
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: PUSH
28791: LD_INT 2
28793: NEG
28794: PUSH
28795: LD_INT 0
28797: PUSH
28798: EMPTY
28799: LIST
28800: LIST
28801: PUSH
28802: LD_INT 2
28804: NEG
28805: PUSH
28806: LD_INT 1
28808: NEG
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: LD_INT 1
28816: NEG
28817: PUSH
28818: LD_INT 3
28820: NEG
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: PUSH
28829: LD_INT 2
28831: NEG
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 3
28839: PUSH
28840: LD_INT 2
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 2
28849: PUSH
28850: LD_INT 3
28852: PUSH
28853: EMPTY
28854: LIST
28855: LIST
28856: PUSH
28857: LD_INT 2
28859: NEG
28860: PUSH
28861: LD_INT 1
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 3
28870: NEG
28871: PUSH
28872: LD_INT 1
28874: NEG
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: LIST
28894: LIST
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: LIST
28901: LIST
28902: LIST
28903: LIST
28904: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28905: NOP4
28909: PUSH
28910: LD_INT 0
28912: PUSH
28913: LD_INT 0
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 0
28922: PUSH
28923: LD_INT 1
28925: NEG
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: PUSH
28931: LD_INT 1
28933: PUSH
28934: LD_INT 0
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: LD_INT 1
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 0
28953: PUSH
28954: LD_INT 1
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PUSH
28961: LD_INT 1
28963: NEG
28964: PUSH
28965: LD_INT 0
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 1
28974: NEG
28975: PUSH
28976: LD_INT 1
28978: NEG
28979: PUSH
28980: EMPTY
28981: LIST
28982: LIST
28983: PUSH
28984: LD_INT 1
28986: NEG
28987: PUSH
28988: LD_INT 2
28990: NEG
28991: PUSH
28992: EMPTY
28993: LIST
28994: LIST
28995: PUSH
28996: LD_INT 1
28998: PUSH
28999: LD_INT 1
29001: NEG
29002: PUSH
29003: EMPTY
29004: LIST
29005: LIST
29006: PUSH
29007: LD_INT 2
29009: PUSH
29010: LD_INT 0
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: PUSH
29017: LD_INT 2
29019: PUSH
29020: LD_INT 1
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: PUSH
29027: LD_INT 2
29029: PUSH
29030: LD_INT 2
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: PUSH
29037: LD_INT 1
29039: PUSH
29040: LD_INT 2
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: PUSH
29047: LD_INT 0
29049: PUSH
29050: LD_INT 2
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: LD_INT 1
29059: NEG
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 2
29070: NEG
29071: PUSH
29072: LD_INT 1
29074: NEG
29075: PUSH
29076: EMPTY
29077: LIST
29078: LIST
29079: PUSH
29080: LD_INT 2
29082: NEG
29083: PUSH
29084: LD_INT 2
29086: NEG
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 2
29094: NEG
29095: PUSH
29096: LD_INT 3
29098: NEG
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 2
29106: PUSH
29107: LD_INT 1
29109: NEG
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: LD_INT 3
29117: PUSH
29118: LD_INT 1
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: LD_INT 3
29130: PUSH
29131: EMPTY
29132: LIST
29133: LIST
29134: PUSH
29135: LD_INT 1
29137: NEG
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 3
29148: NEG
29149: PUSH
29150: LD_INT 2
29152: NEG
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: LIST
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: LIST
29168: LIST
29169: LIST
29170: LIST
29171: LIST
29172: LIST
29173: LIST
29174: LIST
29175: LIST
29176: LIST
29177: LIST
29178: LIST
29179: LIST
29180: LIST
29181: LIST
29182: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29183: NOP4
29187: PUSH
29188: LD_INT 0
29190: PUSH
29191: LD_INT 0
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: PUSH
29198: LD_INT 0
29200: PUSH
29201: LD_INT 1
29203: NEG
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 1
29211: PUSH
29212: LD_INT 0
29214: PUSH
29215: EMPTY
29216: LIST
29217: LIST
29218: PUSH
29219: LD_INT 1
29221: PUSH
29222: LD_INT 1
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: PUSH
29229: LD_INT 0
29231: PUSH
29232: LD_INT 1
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: LD_INT 1
29241: NEG
29242: PUSH
29243: LD_INT 0
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: PUSH
29250: LD_INT 1
29252: NEG
29253: PUSH
29254: LD_INT 1
29256: NEG
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: NEG
29265: PUSH
29266: LD_INT 2
29268: NEG
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: LD_INT 0
29276: PUSH
29277: LD_INT 2
29279: NEG
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PUSH
29285: LD_INT 1
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 2
29298: PUSH
29299: LD_INT 1
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: PUSH
29306: LD_INT 2
29308: PUSH
29309: LD_INT 2
29311: PUSH
29312: EMPTY
29313: LIST
29314: LIST
29315: PUSH
29316: LD_INT 1
29318: PUSH
29319: LD_INT 2
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 0
29328: PUSH
29329: LD_INT 2
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 1
29338: NEG
29339: PUSH
29340: LD_INT 1
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PUSH
29347: LD_INT 2
29349: NEG
29350: PUSH
29351: LD_INT 0
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: PUSH
29358: LD_INT 2
29360: NEG
29361: PUSH
29362: LD_INT 1
29364: NEG
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: LD_INT 1
29372: NEG
29373: PUSH
29374: LD_INT 3
29376: NEG
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: PUSH
29385: LD_INT 2
29387: NEG
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 3
29395: PUSH
29396: LD_INT 2
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 2
29405: PUSH
29406: LD_INT 3
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: LD_INT 2
29415: NEG
29416: PUSH
29417: LD_INT 1
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 3
29426: NEG
29427: PUSH
29428: LD_INT 1
29430: NEG
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: LIST
29453: LIST
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: LIST
29459: LIST
29460: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29461: NOP4
29465: PUSH
29466: LD_INT 0
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 0
29478: PUSH
29479: LD_INT 1
29481: NEG
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 1
29489: PUSH
29490: LD_INT 0
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 1
29499: PUSH
29500: LD_INT 1
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 0
29509: PUSH
29510: LD_INT 1
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 1
29519: NEG
29520: PUSH
29521: LD_INT 0
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 1
29530: NEG
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 1
29542: NEG
29543: PUSH
29544: LD_INT 2
29546: NEG
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: LD_INT 1
29554: PUSH
29555: LD_INT 1
29557: NEG
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 2
29565: PUSH
29566: LD_INT 0
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PUSH
29573: LD_INT 2
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PUSH
29583: LD_INT 1
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 0
29595: PUSH
29596: LD_INT 2
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: NEG
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 2
29616: NEG
29617: PUSH
29618: LD_INT 0
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: PUSH
29625: LD_INT 2
29627: NEG
29628: PUSH
29629: LD_INT 1
29631: NEG
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 2
29639: NEG
29640: PUSH
29641: LD_INT 2
29643: NEG
29644: PUSH
29645: EMPTY
29646: LIST
29647: LIST
29648: PUSH
29649: LD_INT 2
29651: NEG
29652: PUSH
29653: LD_INT 3
29655: NEG
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: PUSH
29661: LD_INT 2
29663: PUSH
29664: LD_INT 1
29666: NEG
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 3
29674: PUSH
29675: LD_INT 1
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 1
29684: PUSH
29685: LD_INT 3
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: LD_INT 2
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 3
29705: NEG
29706: PUSH
29707: LD_INT 2
29709: NEG
29710: PUSH
29711: EMPTY
29712: LIST
29713: LIST
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: LIST
29719: LIST
29720: LIST
29721: LIST
29722: LIST
29723: LIST
29724: LIST
29725: LIST
29726: LIST
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29740: NOP4
29744: PUSH
29745: LD_INT 0
29747: PUSH
29748: LD_INT 0
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: LD_INT 0
29757: PUSH
29758: LD_INT 1
29760: NEG
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 1
29768: PUSH
29769: LD_INT 0
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 1
29778: PUSH
29779: LD_INT 1
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 0
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 1
29798: NEG
29799: PUSH
29800: LD_INT 0
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 1
29809: NEG
29810: PUSH
29811: LD_INT 1
29813: NEG
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 1
29821: NEG
29822: PUSH
29823: LD_INT 2
29825: NEG
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 0
29833: PUSH
29834: LD_INT 2
29836: NEG
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 1
29844: PUSH
29845: LD_INT 1
29847: NEG
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 2
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 2
29865: PUSH
29866: LD_INT 2
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: PUSH
29873: LD_INT 1
29875: PUSH
29876: LD_INT 2
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 1
29885: NEG
29886: PUSH
29887: LD_INT 1
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 2
29896: NEG
29897: PUSH
29898: LD_INT 0
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 2
29907: NEG
29908: PUSH
29909: LD_INT 1
29911: NEG
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: LD_INT 2
29919: NEG
29920: PUSH
29921: LD_INT 2
29923: NEG
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: NEG
29932: PUSH
29933: LD_INT 3
29935: NEG
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PUSH
29941: LD_INT 1
29943: PUSH
29944: LD_INT 2
29946: NEG
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 3
29954: PUSH
29955: LD_INT 2
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 2
29964: PUSH
29965: LD_INT 3
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 2
29974: NEG
29975: PUSH
29976: LD_INT 1
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 3
29985: NEG
29986: PUSH
29987: LD_INT 1
29989: NEG
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: LIST
30016: LIST
30017: LIST
30018: LIST
30019: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30020: NOP4
30024: PUSH
30025: LD_INT 0
30027: PUSH
30028: LD_INT 0
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 0
30037: PUSH
30038: LD_INT 1
30040: NEG
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: LD_INT 0
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: LD_INT 1
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: LD_INT 1
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 0
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 1
30089: NEG
30090: PUSH
30091: LD_INT 1
30093: NEG
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 2
30101: PUSH
30102: LD_INT 1
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 2
30111: NEG
30112: PUSH
30113: LD_INT 1
30115: NEG
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30132: NOP4
30136: PUSH
30137: LD_INT 0
30139: PUSH
30140: LD_INT 0
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 0
30149: PUSH
30150: LD_INT 1
30152: NEG
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 1
30160: PUSH
30161: LD_INT 0
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 1
30170: PUSH
30171: LD_INT 1
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 0
30180: PUSH
30181: LD_INT 1
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 1
30190: NEG
30191: PUSH
30192: LD_INT 0
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 1
30201: NEG
30202: PUSH
30203: LD_INT 1
30205: NEG
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 1
30213: NEG
30214: PUSH
30215: LD_INT 2
30217: NEG
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 1
30225: PUSH
30226: LD_INT 2
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30244: NOP4
30248: PUSH
30249: LD_INT 0
30251: PUSH
30252: LD_INT 0
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: LD_INT 1
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: LD_INT 0
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 1
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 0
30292: PUSH
30293: LD_INT 1
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 1
30302: NEG
30303: PUSH
30304: LD_INT 0
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: NEG
30314: PUSH
30315: LD_INT 1
30317: NEG
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 1
30325: PUSH
30326: LD_INT 1
30328: NEG
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: LD_INT 1
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: LIST
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30356: NOP4
30360: PUSH
30361: LD_INT 0
30363: PUSH
30364: LD_INT 0
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 0
30373: PUSH
30374: LD_INT 1
30376: NEG
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 1
30384: PUSH
30385: LD_INT 0
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: PUSH
30395: LD_INT 1
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: LD_INT 1
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: LD_INT 1
30414: NEG
30415: PUSH
30416: LD_INT 0
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 1
30425: NEG
30426: PUSH
30427: LD_INT 1
30429: NEG
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 2
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 2
30447: NEG
30448: PUSH
30449: LD_INT 1
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30468: NOP4
30472: PUSH
30473: LD_INT 0
30475: PUSH
30476: LD_INT 0
30478: PUSH
30479: EMPTY
30480: LIST
30481: LIST
30482: PUSH
30483: LD_INT 0
30485: PUSH
30486: LD_INT 1
30488: NEG
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 1
30496: PUSH
30497: LD_INT 0
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: LD_INT 1
30509: PUSH
30510: EMPTY
30511: LIST
30512: LIST
30513: PUSH
30514: LD_INT 0
30516: PUSH
30517: LD_INT 1
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: LD_INT 1
30526: NEG
30527: PUSH
30528: LD_INT 0
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: NEG
30538: PUSH
30539: LD_INT 1
30541: NEG
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 1
30549: NEG
30550: PUSH
30551: LD_INT 2
30553: NEG
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: PUSH
30562: LD_INT 2
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: LIST
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30580: NOP4
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: LD_INT 0
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PUSH
30595: LD_INT 0
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 1
30618: PUSH
30619: LD_INT 1
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 0
30628: PUSH
30629: LD_INT 1
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 1
30638: NEG
30639: PUSH
30640: LD_INT 0
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: NEG
30650: PUSH
30651: LD_INT 1
30653: NEG
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 1
30661: PUSH
30662: LD_INT 1
30664: NEG
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: NEG
30673: PUSH
30674: LD_INT 1
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30692: NOP4
30696: PUSH
30697: LD_INT 0
30699: PUSH
30700: LD_INT 0
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: LD_INT 1
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 1
30720: PUSH
30721: LD_INT 0
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 1
30730: PUSH
30731: LD_INT 1
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: LD_INT 1
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: PUSH
30748: LD_INT 1
30750: NEG
30751: PUSH
30752: LD_INT 0
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 1
30761: NEG
30762: PUSH
30763: LD_INT 1
30765: NEG
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 1
30773: NEG
30774: PUSH
30775: LD_INT 2
30777: NEG
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: LD_INT 1
30788: NEG
30789: PUSH
30790: EMPTY
30791: LIST
30792: LIST
30793: PUSH
30794: LD_INT 2
30796: PUSH
30797: LD_INT 0
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 2
30806: PUSH
30807: LD_INT 1
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: LD_INT 2
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 1
30826: PUSH
30827: LD_INT 2
30829: PUSH
30830: EMPTY
30831: LIST
30832: LIST
30833: PUSH
30834: LD_INT 1
30836: NEG
30837: PUSH
30838: LD_INT 1
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 2
30847: NEG
30848: PUSH
30849: LD_INT 0
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 2
30858: NEG
30859: PUSH
30860: LD_INT 1
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 2
30870: NEG
30871: PUSH
30872: LD_INT 2
30874: NEG
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 2
30882: NEG
30883: PUSH
30884: LD_INT 3
30886: NEG
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 2
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 3
30905: PUSH
30906: LD_INT 0
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 3
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 3
30925: PUSH
30926: LD_INT 2
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: LD_INT 3
30935: PUSH
30936: LD_INT 3
30938: PUSH
30939: EMPTY
30940: LIST
30941: LIST
30942: PUSH
30943: LD_INT 2
30945: PUSH
30946: LD_INT 3
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 2
30955: NEG
30956: PUSH
30957: LD_INT 1
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 3
30966: NEG
30967: PUSH
30968: LD_INT 0
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 3
30977: NEG
30978: PUSH
30979: LD_INT 1
30981: NEG
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 3
30989: NEG
30990: PUSH
30991: LD_INT 2
30993: NEG
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 3
31001: NEG
31002: PUSH
31003: LD_INT 3
31005: NEG
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: LIST
31015: LIST
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: LIST
31034: LIST
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: LIST
31040: LIST
31041: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31042: NOP4
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: LD_INT 0
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: LD_INT 1
31062: NEG
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 1
31070: PUSH
31071: LD_INT 0
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 1
31080: PUSH
31081: LD_INT 1
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 0
31090: PUSH
31091: LD_INT 1
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: NEG
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: NEG
31112: PUSH
31113: LD_INT 1
31115: NEG
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 1
31123: NEG
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: LD_INT 2
31138: NEG
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 1
31146: PUSH
31147: LD_INT 1
31149: NEG
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 2
31157: PUSH
31158: LD_INT 1
31160: PUSH
31161: EMPTY
31162: LIST
31163: LIST
31164: PUSH
31165: LD_INT 2
31167: PUSH
31168: LD_INT 2
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: LD_INT 2
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 0
31187: PUSH
31188: LD_INT 2
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 2
31208: NEG
31209: PUSH
31210: LD_INT 1
31212: NEG
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 2
31220: NEG
31221: PUSH
31222: LD_INT 2
31224: NEG
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 2
31232: NEG
31233: PUSH
31234: LD_INT 3
31236: NEG
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 1
31244: NEG
31245: PUSH
31246: LD_INT 3
31248: NEG
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 0
31256: PUSH
31257: LD_INT 3
31259: NEG
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PUSH
31265: LD_INT 1
31267: PUSH
31268: LD_INT 2
31270: NEG
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 3
31278: PUSH
31279: LD_INT 2
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 3
31288: PUSH
31289: LD_INT 3
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 2
31298: PUSH
31299: LD_INT 3
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 1
31308: PUSH
31309: LD_INT 3
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: LD_INT 3
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 1
31328: NEG
31329: PUSH
31330: LD_INT 2
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: LD_INT 3
31339: NEG
31340: PUSH
31341: LD_INT 2
31343: NEG
31344: PUSH
31345: EMPTY
31346: LIST
31347: LIST
31348: PUSH
31349: LD_INT 3
31351: NEG
31352: PUSH
31353: LD_INT 3
31355: NEG
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31392: NOP4
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: LD_INT 0
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: LD_INT 1
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: LD_INT 1
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 1
31450: NEG
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 1
31461: NEG
31462: PUSH
31463: LD_INT 1
31465: NEG
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: LD_INT 2
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 0
31485: PUSH
31486: LD_INT 2
31488: NEG
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 1
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 2
31507: PUSH
31508: LD_INT 0
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 2
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 1
31527: PUSH
31528: LD_INT 2
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 0
31537: PUSH
31538: LD_INT 2
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: NEG
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 2
31558: NEG
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 2
31569: NEG
31570: PUSH
31571: LD_INT 1
31573: NEG
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 1
31581: NEG
31582: PUSH
31583: LD_INT 3
31585: NEG
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: PUSH
31591: LD_INT 0
31593: PUSH
31594: LD_INT 3
31596: NEG
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 1
31604: PUSH
31605: LD_INT 2
31607: NEG
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 2
31615: PUSH
31616: LD_INT 1
31618: NEG
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: PUSH
31624: LD_INT 3
31626: PUSH
31627: LD_INT 0
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 3
31636: PUSH
31637: LD_INT 1
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 1
31646: PUSH
31647: LD_INT 3
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 0
31656: PUSH
31657: LD_INT 3
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 1
31666: NEG
31667: PUSH
31668: LD_INT 2
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 2
31677: NEG
31678: PUSH
31679: LD_INT 1
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 3
31688: NEG
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 3
31699: NEG
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31740: NOP4
31744: PUSH
31745: LD_INT 0
31747: PUSH
31748: LD_INT 0
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 0
31757: PUSH
31758: LD_INT 1
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 1
31768: PUSH
31769: LD_INT 0
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 1
31778: PUSH
31779: LD_INT 1
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: LD_INT 1
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 1
31798: NEG
31799: PUSH
31800: LD_INT 0
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: LD_INT 1
31813: NEG
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 1
31821: NEG
31822: PUSH
31823: LD_INT 2
31825: NEG
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 1
31833: PUSH
31834: LD_INT 1
31836: NEG
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 2
31844: PUSH
31845: LD_INT 0
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 2
31854: PUSH
31855: LD_INT 1
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 2
31864: PUSH
31865: LD_INT 2
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 2
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 2
31895: NEG
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 2
31906: NEG
31907: PUSH
31908: LD_INT 1
31910: NEG
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 2
31918: NEG
31919: PUSH
31920: LD_INT 2
31922: NEG
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 2
31930: NEG
31931: PUSH
31932: LD_INT 3
31934: NEG
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: LD_INT 1
31945: NEG
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 3
31953: PUSH
31954: LD_INT 0
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 3
31963: PUSH
31964: LD_INT 1
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 3
31973: PUSH
31974: LD_INT 2
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 3
31983: PUSH
31984: LD_INT 3
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 2
31993: PUSH
31994: LD_INT 3
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PUSH
32001: LD_INT 2
32003: NEG
32004: PUSH
32005: LD_INT 1
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 3
32014: NEG
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 3
32025: NEG
32026: PUSH
32027: LD_INT 1
32029: NEG
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 3
32037: NEG
32038: PUSH
32039: LD_INT 2
32041: NEG
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 3
32049: NEG
32050: PUSH
32051: LD_INT 3
32053: NEG
32054: PUSH
32055: EMPTY
32056: LIST
32057: LIST
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: LIST
32070: LIST
32071: LIST
32072: LIST
32073: LIST
32074: LIST
32075: LIST
32076: LIST
32077: LIST
32078: LIST
32079: LIST
32080: LIST
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32090: NOP4
32094: PUSH
32095: LD_INT 0
32097: PUSH
32098: LD_INT 0
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: LD_INT 0
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 1
32118: PUSH
32119: LD_INT 0
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 1
32128: PUSH
32129: LD_INT 1
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 0
32138: PUSH
32139: LD_INT 1
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: PUSH
32146: LD_INT 1
32148: NEG
32149: PUSH
32150: LD_INT 0
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 1
32159: NEG
32160: PUSH
32161: LD_INT 1
32163: NEG
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: PUSH
32169: LD_INT 1
32171: NEG
32172: PUSH
32173: LD_INT 2
32175: NEG
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 0
32183: PUSH
32184: LD_INT 2
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: LD_INT 1
32197: NEG
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 2
32205: PUSH
32206: LD_INT 1
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 2
32215: PUSH
32216: LD_INT 2
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 1
32225: PUSH
32226: LD_INT 2
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: LD_INT 2
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: NEG
32246: PUSH
32247: LD_INT 1
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: LD_INT 1
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 2
32268: NEG
32269: PUSH
32270: LD_INT 2
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 2
32280: NEG
32281: PUSH
32282: LD_INT 3
32284: NEG
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 1
32292: NEG
32293: PUSH
32294: LD_INT 3
32296: NEG
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 0
32304: PUSH
32305: LD_INT 3
32307: NEG
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: LD_INT 2
32318: NEG
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 3
32326: PUSH
32327: LD_INT 2
32329: PUSH
32330: EMPTY
32331: LIST
32332: LIST
32333: PUSH
32334: LD_INT 3
32336: PUSH
32337: LD_INT 3
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 2
32346: PUSH
32347: LD_INT 3
32349: PUSH
32350: EMPTY
32351: LIST
32352: LIST
32353: PUSH
32354: LD_INT 1
32356: PUSH
32357: LD_INT 3
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 0
32366: PUSH
32367: LD_INT 3
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 1
32376: NEG
32377: PUSH
32378: LD_INT 2
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 3
32387: NEG
32388: PUSH
32389: LD_INT 2
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 3
32399: NEG
32400: PUSH
32401: LD_INT 3
32403: NEG
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: LIST
32413: LIST
32414: LIST
32415: LIST
32416: LIST
32417: LIST
32418: LIST
32419: LIST
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: LIST
32434: LIST
32435: LIST
32436: LIST
32437: LIST
32438: LIST
32439: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32440: NOP4
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 0
32457: PUSH
32458: LD_INT 1
32460: NEG
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 1
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 1
32478: PUSH
32479: LD_INT 1
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 0
32488: PUSH
32489: LD_INT 1
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PUSH
32496: LD_INT 1
32498: NEG
32499: PUSH
32500: LD_INT 0
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: LD_INT 1
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: LD_INT 2
32525: NEG
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 0
32533: PUSH
32534: LD_INT 2
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: LD_INT 1
32547: NEG
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 2
32555: PUSH
32556: LD_INT 0
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 2
32565: PUSH
32566: LD_INT 1
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 1
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: LD_INT 2
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 1
32595: NEG
32596: PUSH
32597: LD_INT 1
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 2
32606: NEG
32607: PUSH
32608: LD_INT 0
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 2
32617: NEG
32618: PUSH
32619: LD_INT 1
32621: NEG
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 1
32629: NEG
32630: PUSH
32631: LD_INT 3
32633: NEG
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 0
32641: PUSH
32642: LD_INT 3
32644: NEG
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 1
32652: PUSH
32653: LD_INT 2
32655: NEG
32656: PUSH
32657: EMPTY
32658: LIST
32659: LIST
32660: PUSH
32661: LD_INT 2
32663: PUSH
32664: LD_INT 1
32666: NEG
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 3
32674: PUSH
32675: LD_INT 0
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 3
32684: PUSH
32685: LD_INT 1
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 1
32694: PUSH
32695: LD_INT 3
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 3
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: NEG
32715: PUSH
32716: LD_INT 2
32718: PUSH
32719: EMPTY
32720: LIST
32721: LIST
32722: PUSH
32723: LD_INT 2
32725: NEG
32726: PUSH
32727: LD_INT 1
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: LD_INT 3
32736: NEG
32737: PUSH
32738: LD_INT 0
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 3
32747: NEG
32748: PUSH
32749: LD_INT 1
32751: NEG
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: LIST
32786: LIST
32787: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32788: NOP4
32792: PUSH
32793: LD_INT 0
32795: PUSH
32796: LD_INT 0
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 0
32805: PUSH
32806: LD_INT 1
32808: NEG
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PUSH
32814: LD_INT 1
32816: PUSH
32817: LD_INT 0
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 1
32826: PUSH
32827: LD_INT 1
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 1
32846: NEG
32847: PUSH
32848: LD_INT 0
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: LD_INT 1
32861: NEG
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 1
32869: NEG
32870: PUSH
32871: LD_INT 2
32873: NEG
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PUSH
32879: LD_INT 0
32881: PUSH
32882: LD_INT 2
32884: NEG
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 1
32892: PUSH
32893: LD_INT 1
32895: NEG
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 2
32903: NEG
32904: PUSH
32905: LD_INT 1
32907: NEG
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: PUSH
32913: LD_INT 2
32915: NEG
32916: PUSH
32917: LD_INT 2
32919: NEG
32920: PUSH
32921: EMPTY
32922: LIST
32923: LIST
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32939: NOP4
32943: PUSH
32944: LD_INT 0
32946: PUSH
32947: LD_INT 0
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: PUSH
32954: LD_INT 0
32956: PUSH
32957: LD_INT 1
32959: NEG
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: LD_INT 1
32967: PUSH
32968: LD_INT 0
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 1
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 0
32987: PUSH
32988: LD_INT 1
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 1
32997: NEG
32998: PUSH
32999: LD_INT 0
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 1
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 1
33020: NEG
33021: PUSH
33022: LD_INT 2
33024: NEG
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 0
33032: PUSH
33033: LD_INT 2
33035: NEG
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 1
33043: PUSH
33044: LD_INT 1
33046: NEG
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 2
33054: PUSH
33055: LD_INT 0
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 2
33064: PUSH
33065: LD_INT 1
33067: PUSH
33068: EMPTY
33069: LIST
33070: LIST
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33086: NOP4
33090: PUSH
33091: LD_INT 0
33093: PUSH
33094: LD_INT 0
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 1
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 0
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: NEG
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 1
33155: NEG
33156: PUSH
33157: LD_INT 1
33159: NEG
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 1
33167: PUSH
33168: LD_INT 1
33170: NEG
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 2
33178: PUSH
33179: LD_INT 0
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: LD_INT 1
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 2
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: LD_INT 1
33208: PUSH
33209: LD_INT 2
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: EMPTY
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
33230: NOP4
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: LD_INT 0
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 0
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 1
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 1
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 0
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 1
33288: NEG
33289: PUSH
33290: LD_INT 0
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 1
33299: NEG
33300: PUSH
33301: LD_INT 1
33303: NEG
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 2
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 2
33321: PUSH
33322: LD_INT 2
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 1
33331: PUSH
33332: LD_INT 2
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: LD_INT 2
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 1
33351: NEG
33352: PUSH
33353: LD_INT 1
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: EMPTY
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
33374: NOP4
33378: PUSH
33379: LD_INT 0
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: LD_INT 1
33394: NEG
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: PUSH
33413: LD_INT 1
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 0
33422: PUSH
33423: LD_INT 1
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 1
33432: NEG
33433: PUSH
33434: LD_INT 0
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 1
33443: NEG
33444: PUSH
33445: LD_INT 1
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: PUSH
33456: LD_INT 2
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: LD_INT 2
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 1
33475: NEG
33476: PUSH
33477: LD_INT 1
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 2
33486: NEG
33487: PUSH
33488: LD_INT 0
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 2
33497: NEG
33498: PUSH
33499: LD_INT 1
33501: NEG
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: EMPTY
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33521: NOP4
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: LD_INT 0
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 0
33538: PUSH
33539: LD_INT 1
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: PUSH
33550: LD_INT 0
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 1
33559: PUSH
33560: LD_INT 1
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 0
33569: PUSH
33570: LD_INT 1
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 1
33579: NEG
33580: PUSH
33581: LD_INT 0
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: NEG
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 1
33602: NEG
33603: PUSH
33604: LD_INT 2
33606: NEG
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 1
33614: NEG
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 2
33625: NEG
33626: PUSH
33627: LD_INT 0
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 2
33636: NEG
33637: PUSH
33638: LD_INT 1
33640: NEG
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 2
33648: NEG
33649: PUSH
33650: LD_INT 2
33652: NEG
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: LIST
33666: LIST
33667: LIST
33668: LIST
33669: LIST
33670: LIST
33671: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33672: NOP4
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 0
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 0
33689: PUSH
33690: LD_INT 1
33692: NEG
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 1
33710: PUSH
33711: LD_INT 1
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 1
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: NEG
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 1
33741: NEG
33742: PUSH
33743: LD_INT 1
33745: NEG
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 0
33765: PUSH
33766: LD_INT 2
33768: NEG
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 2
33787: PUSH
33788: LD_INT 0
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 2
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 2
33807: PUSH
33808: LD_INT 2
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 1
33817: PUSH
33818: LD_INT 2
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 0
33827: PUSH
33828: LD_INT 2
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 1
33837: NEG
33838: PUSH
33839: LD_INT 1
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: LD_INT 2
33848: NEG
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: EMPTY
33854: LIST
33855: LIST
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: LD_INT 1
33863: NEG
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: NEG
33872: PUSH
33873: LD_INT 2
33875: NEG
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: LIST
33895: LIST
33896: LIST
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33902: NOP4
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 0
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 0
33919: PUSH
33920: LD_INT 1
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 0
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 1
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: LD_INT 1
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 1
33960: NEG
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 1
33971: NEG
33972: PUSH
33973: LD_INT 1
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 1
33983: NEG
33984: PUSH
33985: LD_INT 2
33987: NEG
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: LD_INT 2
33998: NEG
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 1
34006: PUSH
34007: LD_INT 1
34009: NEG
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 2
34017: PUSH
34018: LD_INT 0
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 2
34027: PUSH
34028: LD_INT 1
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 2
34037: PUSH
34038: LD_INT 2
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: LD_INT 1
34047: PUSH
34048: LD_INT 2
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: LD_INT 0
34057: PUSH
34058: LD_INT 2
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 1
34067: NEG
34068: PUSH
34069: LD_INT 1
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 2
34078: NEG
34079: PUSH
34080: LD_INT 0
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 2
34089: NEG
34090: PUSH
34091: LD_INT 1
34093: NEG
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 2
34101: NEG
34102: PUSH
34103: LD_INT 2
34105: NEG
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: LIST
34120: LIST
34121: LIST
34122: LIST
34123: LIST
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34132: NOP4
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 0
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 0
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 1
34170: PUSH
34171: LD_INT 1
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: LD_INT 1
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 1
34201: NEG
34202: PUSH
34203: LD_INT 1
34205: NEG
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 1
34213: NEG
34214: PUSH
34215: LD_INT 2
34217: NEG
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 0
34225: PUSH
34226: LD_INT 2
34228: NEG
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 1
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 2
34247: PUSH
34248: LD_INT 0
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 2
34257: PUSH
34258: LD_INT 1
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 2
34267: PUSH
34268: LD_INT 2
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 2
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: LD_INT 2
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 2
34308: NEG
34309: PUSH
34310: LD_INT 0
34312: PUSH
34313: EMPTY
34314: LIST
34315: LIST
34316: PUSH
34317: LD_INT 2
34319: NEG
34320: PUSH
34321: LD_INT 1
34323: NEG
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: NEG
34332: PUSH
34333: LD_INT 2
34335: NEG
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34362: NOP4
34366: PUSH
34367: LD_INT 0
34369: PUSH
34370: LD_INT 0
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 0
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 1
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 0
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: NEG
34421: PUSH
34422: LD_INT 0
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: LD_INT 1
34435: NEG
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 2
34447: NEG
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: LD_INT 2
34458: NEG
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: LD_INT 1
34469: NEG
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: LD_INT 0
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: LD_INT 1
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: LD_INT 2
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 1
34507: PUSH
34508: LD_INT 2
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 0
34517: PUSH
34518: LD_INT 2
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: LD_INT 1
34527: NEG
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 2
34538: NEG
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 2
34549: NEG
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 2
34561: NEG
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: LIST
34575: LIST
34576: LIST
34577: LIST
34578: LIST
34579: LIST
34580: LIST
34581: LIST
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34592: NOP4
34596: PUSH
34597: LD_INT 0
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 0
34609: PUSH
34610: LD_INT 1
34612: NEG
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 1
34620: PUSH
34621: LD_INT 0
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 1
34630: PUSH
34631: LD_INT 1
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 0
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 1
34650: NEG
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 1
34661: NEG
34662: PUSH
34663: LD_INT 1
34665: NEG
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 1
34673: NEG
34674: PUSH
34675: LD_INT 2
34677: NEG
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 2
34688: NEG
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 1
34696: PUSH
34697: LD_INT 1
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 2
34707: PUSH
34708: LD_INT 0
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 2
34717: PUSH
34718: LD_INT 1
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: LD_INT 2
34727: PUSH
34728: LD_INT 2
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: LD_INT 1
34737: PUSH
34738: LD_INT 2
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: LD_INT 2
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: LD_INT 1
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 2
34768: NEG
34769: PUSH
34770: LD_INT 0
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 2
34779: NEG
34780: PUSH
34781: LD_INT 1
34783: NEG
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 2
34791: NEG
34792: PUSH
34793: LD_INT 2
34795: NEG
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34822: NOP4
34826: PUSH
34827: LD_INT 0
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 0
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 1
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: LD_INT 1
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 1
34880: NEG
34881: PUSH
34882: LD_INT 0
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 1
34891: NEG
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: LD_INT 1
34903: NEG
34904: PUSH
34905: LD_INT 2
34907: NEG
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 0
34915: PUSH
34916: LD_INT 2
34918: NEG
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 1
34926: PUSH
34927: LD_INT 1
34929: NEG
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 2
34937: PUSH
34938: LD_INT 0
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: LD_INT 1
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: LD_INT 2
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: LD_INT 2
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 1
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 2
34998: NEG
34999: PUSH
35000: LD_INT 0
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: NEG
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: LIST
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35052: NOP4
35056: PUSH
35057: LD_INT 0
35059: PUSH
35060: LD_INT 0
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 0
35069: PUSH
35070: LD_INT 1
35072: NEG
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 1
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 1
35090: PUSH
35091: LD_INT 1
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 0
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: PUSH
35108: LD_INT 1
35110: NEG
35111: PUSH
35112: LD_INT 0
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: LD_INT 1
35125: NEG
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: EMPTY
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35140: NOP4
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: LD_INT 0
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 0
35157: PUSH
35158: LD_INT 1
35160: NEG
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 1
35168: PUSH
35169: LD_INT 0
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 1
35178: PUSH
35179: LD_INT 1
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 0
35188: PUSH
35189: LD_INT 1
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 1
35198: NEG
35199: PUSH
35200: LD_INT 0
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 1
35209: NEG
35210: PUSH
35211: LD_INT 1
35213: NEG
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: LIST
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35228: NOP4
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: LD_INT 0
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 0
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 1
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 0
35276: PUSH
35277: LD_INT 1
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 1
35286: NEG
35287: PUSH
35288: LD_INT 0
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 1
35297: NEG
35298: PUSH
35299: LD_INT 1
35301: NEG
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: LIST
35311: LIST
35312: LIST
35313: LIST
35314: LIST
35315: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35316: NOP4
35320: PUSH
35321: LD_INT 0
35323: PUSH
35324: LD_INT 0
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 1
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: LD_INT 1
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: LD_INT 1
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: NEG
35375: PUSH
35376: LD_INT 0
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 1
35385: NEG
35386: PUSH
35387: LD_INT 1
35389: NEG
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: LIST
35399: LIST
35400: LIST
35401: LIST
35402: LIST
35403: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35404: NOP4
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: LD_INT 0
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: LD_INT 1
35424: NEG
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: PUSH
35430: LD_INT 1
35432: PUSH
35433: LD_INT 0
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: LD_INT 1
35442: PUSH
35443: LD_INT 1
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: LD_INT 1
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 1
35462: NEG
35463: PUSH
35464: LD_INT 0
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: NEG
35474: PUSH
35475: LD_INT 1
35477: NEG
35478: PUSH
35479: EMPTY
35480: LIST
35481: LIST
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: LIST
35487: LIST
35488: LIST
35489: LIST
35490: LIST
35491: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35492: NOP4
35496: PUSH
35497: LD_INT 0
35499: PUSH
35500: LD_INT 0
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: LD_INT 1
35512: NEG
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: LD_INT 1
35520: PUSH
35521: LD_INT 0
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: PUSH
35531: LD_INT 1
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: LD_INT 1
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 1
35550: NEG
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: NEG
35562: PUSH
35563: LD_INT 1
35565: NEG
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: ST_TO_ADDR
// end ; 1 :
35580: GO 41477
35582: LD_INT 1
35584: DOUBLE
35585: EQUAL
35586: IFTRUE 35590
35588: GO 38213
35590: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35591: NOP4
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: LD_INT 3
35602: NEG
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: LD_INT 3
35613: NEG
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 2
35624: NEG
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: LIST
35634: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35635: NOP4
35639: PUSH
35640: LD_INT 2
35642: PUSH
35643: LD_INT 1
35645: NEG
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 3
35653: PUSH
35654: LD_INT 0
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 3
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: LIST
35675: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35676: NOP4
35680: PUSH
35681: LD_INT 3
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 3
35693: PUSH
35694: LD_INT 3
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 2
35703: PUSH
35704: LD_INT 3
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: LIST
35715: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35716: NOP4
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: LD_INT 3
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 0
35733: PUSH
35734: LD_INT 3
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 1
35743: NEG
35744: PUSH
35745: LD_INT 2
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: LIST
35756: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35757: NOP4
35761: PUSH
35762: LD_INT 2
35764: NEG
35765: PUSH
35766: LD_INT 1
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 3
35775: NEG
35776: PUSH
35777: LD_INT 0
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 3
35786: NEG
35787: PUSH
35788: LD_INT 1
35790: NEG
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: LIST
35800: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35801: NOP4
35805: PUSH
35806: LD_INT 2
35808: NEG
35809: PUSH
35810: LD_INT 3
35812: NEG
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 3
35820: NEG
35821: PUSH
35822: LD_INT 2
35824: NEG
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 3
35832: NEG
35833: PUSH
35834: LD_INT 3
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: EMPTY
35843: LIST
35844: LIST
35845: LIST
35846: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35847: NOP4
35851: PUSH
35852: LD_INT 1
35854: NEG
35855: PUSH
35856: LD_INT 3
35858: NEG
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: LD_INT 3
35869: NEG
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: LD_INT 1
35877: PUSH
35878: LD_INT 2
35880: NEG
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: LIST
35890: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35891: NOP4
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 1
35901: NEG
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 3
35909: PUSH
35910: LD_INT 0
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 3
35919: PUSH
35920: LD_INT 1
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: LIST
35931: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35932: NOP4
35936: PUSH
35937: LD_INT 3
35939: PUSH
35940: LD_INT 2
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 3
35949: PUSH
35950: LD_INT 3
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 2
35959: PUSH
35960: LD_INT 3
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: LIST
35971: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35972: NOP4
35976: PUSH
35977: LD_INT 1
35979: PUSH
35980: LD_INT 3
35982: PUSH
35983: EMPTY
35984: LIST
35985: LIST
35986: PUSH
35987: LD_INT 0
35989: PUSH
35990: LD_INT 3
35992: PUSH
35993: EMPTY
35994: LIST
35995: LIST
35996: PUSH
35997: LD_INT 1
35999: NEG
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: LIST
36012: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36013: NOP4
36017: PUSH
36018: LD_INT 2
36020: NEG
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 3
36031: NEG
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 3
36042: NEG
36043: PUSH
36044: LD_INT 1
36046: NEG
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: LIST
36056: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36057: NOP4
36061: PUSH
36062: LD_INT 2
36064: NEG
36065: PUSH
36066: LD_INT 3
36068: NEG
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 3
36076: NEG
36077: PUSH
36078: LD_INT 2
36080: NEG
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 3
36088: NEG
36089: PUSH
36090: LD_INT 3
36092: NEG
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: LIST
36102: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36103: NOP4
36107: PUSH
36108: LD_INT 0
36110: PUSH
36111: LD_INT 3
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 1
36121: NEG
36122: PUSH
36123: LD_INT 4
36125: NEG
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: PUSH
36134: LD_INT 3
36136: NEG
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: LIST
36146: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
36147: NOP4
36151: PUSH
36152: LD_INT 3
36154: PUSH
36155: LD_INT 0
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 3
36164: PUSH
36165: LD_INT 1
36167: NEG
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 4
36175: PUSH
36176: LD_INT 1
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: LIST
36187: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
36188: NOP4
36192: PUSH
36193: LD_INT 3
36195: PUSH
36196: LD_INT 3
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 4
36205: PUSH
36206: LD_INT 3
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 3
36215: PUSH
36216: LD_INT 4
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: LIST
36227: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
36228: NOP4
36232: PUSH
36233: LD_INT 0
36235: PUSH
36236: LD_INT 3
36238: PUSH
36239: EMPTY
36240: LIST
36241: LIST
36242: PUSH
36243: LD_INT 1
36245: PUSH
36246: LD_INT 4
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 1
36255: NEG
36256: PUSH
36257: LD_INT 3
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: LIST
36268: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
36269: NOP4
36273: PUSH
36274: LD_INT 3
36276: NEG
36277: PUSH
36278: LD_INT 0
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: LD_INT 3
36287: NEG
36288: PUSH
36289: LD_INT 1
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 4
36298: NEG
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: LIST
36312: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
36313: NOP4
36317: PUSH
36318: LD_INT 3
36320: NEG
36321: PUSH
36322: LD_INT 3
36324: NEG
36325: PUSH
36326: EMPTY
36327: LIST
36328: LIST
36329: PUSH
36330: LD_INT 3
36332: NEG
36333: PUSH
36334: LD_INT 4
36336: NEG
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 4
36344: NEG
36345: PUSH
36346: LD_INT 3
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: LIST
36358: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
36359: NOP4
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: LD_INT 3
36370: NEG
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: LD_INT 3
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 1
36389: PUSH
36390: LD_INT 2
36392: NEG
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 1
36400: NEG
36401: PUSH
36402: LD_INT 4
36404: NEG
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: LD_INT 4
36415: NEG
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 1
36423: PUSH
36424: LD_INT 3
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: LD_INT 5
36438: NEG
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: PUSH
36444: LD_INT 0
36446: PUSH
36447: LD_INT 5
36449: NEG
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 1
36457: PUSH
36458: LD_INT 4
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 1
36468: NEG
36469: PUSH
36470: LD_INT 6
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 0
36480: PUSH
36481: LD_INT 6
36483: NEG
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: LD_INT 5
36494: NEG
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36514: NOP4
36518: PUSH
36519: LD_INT 2
36521: PUSH
36522: LD_INT 1
36524: NEG
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 3
36532: PUSH
36533: LD_INT 0
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 3
36542: PUSH
36543: LD_INT 1
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 3
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 4
36563: PUSH
36564: LD_INT 0
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: LD_INT 4
36573: PUSH
36574: LD_INT 1
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 4
36583: PUSH
36584: LD_INT 1
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 5
36594: PUSH
36595: LD_INT 0
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 5
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 5
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 6
36625: PUSH
36626: LD_INT 0
36628: PUSH
36629: EMPTY
36630: LIST
36631: LIST
36632: PUSH
36633: LD_INT 6
36635: PUSH
36636: LD_INT 1
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36657: NOP4
36661: PUSH
36662: LD_INT 3
36664: PUSH
36665: LD_INT 2
36667: PUSH
36668: EMPTY
36669: LIST
36670: LIST
36671: PUSH
36672: LD_INT 3
36674: PUSH
36675: LD_INT 3
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 2
36684: PUSH
36685: LD_INT 3
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: PUSH
36692: LD_INT 4
36694: PUSH
36695: LD_INT 3
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 4
36704: PUSH
36705: LD_INT 4
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 3
36714: PUSH
36715: LD_INT 4
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 5
36724: PUSH
36725: LD_INT 4
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 5
36734: PUSH
36735: LD_INT 5
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 4
36744: PUSH
36745: LD_INT 5
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 6
36754: PUSH
36755: LD_INT 5
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 6
36764: PUSH
36765: LD_INT 6
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 5
36774: PUSH
36775: LD_INT 6
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: LIST
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36796: NOP4
36800: PUSH
36801: LD_INT 1
36803: PUSH
36804: LD_INT 3
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 0
36813: PUSH
36814: LD_INT 3
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 1
36823: NEG
36824: PUSH
36825: LD_INT 2
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 1
36834: PUSH
36835: LD_INT 4
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 0
36844: PUSH
36845: LD_INT 4
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 1
36854: NEG
36855: PUSH
36856: LD_INT 3
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 1
36865: PUSH
36866: LD_INT 5
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: LD_INT 5
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 1
36885: NEG
36886: PUSH
36887: LD_INT 4
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: LD_INT 6
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 0
36906: PUSH
36907: LD_INT 6
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 1
36916: NEG
36917: PUSH
36918: LD_INT 5
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: LIST
36929: LIST
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36939: NOP4
36943: PUSH
36944: LD_INT 2
36946: NEG
36947: PUSH
36948: LD_INT 1
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 3
36957: NEG
36958: PUSH
36959: LD_INT 0
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 3
36968: NEG
36969: PUSH
36970: LD_INT 1
36972: NEG
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 3
36980: NEG
36981: PUSH
36982: LD_INT 1
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PUSH
36989: LD_INT 4
36991: NEG
36992: PUSH
36993: LD_INT 0
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 4
37002: NEG
37003: PUSH
37004: LD_INT 1
37006: NEG
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: LD_INT 4
37014: NEG
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: LD_INT 5
37025: NEG
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 5
37036: NEG
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 5
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 6
37059: NEG
37060: PUSH
37061: LD_INT 0
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 6
37070: NEG
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: LIST
37091: LIST
37092: LIST
37093: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37094: NOP4
37098: PUSH
37099: LD_INT 2
37101: NEG
37102: PUSH
37103: LD_INT 3
37105: NEG
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 3
37113: NEG
37114: PUSH
37115: LD_INT 2
37117: NEG
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 3
37125: NEG
37126: PUSH
37127: LD_INT 3
37129: NEG
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PUSH
37135: LD_INT 3
37137: NEG
37138: PUSH
37139: LD_INT 4
37141: NEG
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 4
37149: NEG
37150: PUSH
37151: LD_INT 3
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 4
37161: NEG
37162: PUSH
37163: LD_INT 4
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 4
37173: NEG
37174: PUSH
37175: LD_INT 5
37177: NEG
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 5
37185: NEG
37186: PUSH
37187: LD_INT 4
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 5
37197: NEG
37198: PUSH
37199: LD_INT 5
37201: NEG
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 5
37209: NEG
37210: PUSH
37211: LD_INT 6
37213: NEG
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PUSH
37219: LD_INT 6
37221: NEG
37222: PUSH
37223: LD_INT 5
37225: NEG
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 6
37233: NEG
37234: PUSH
37235: LD_INT 6
37237: NEG
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: LIST
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
37257: NOP4
37261: PUSH
37262: LD_INT 0
37264: PUSH
37265: LD_INT 2
37267: NEG
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 1
37275: NEG
37276: PUSH
37277: LD_INT 3
37279: NEG
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: LD_INT 2
37290: NEG
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: LIST
37300: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
37301: NOP4
37305: PUSH
37306: LD_INT 2
37308: PUSH
37309: LD_INT 0
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 2
37318: PUSH
37319: LD_INT 1
37321: NEG
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 3
37329: PUSH
37330: LD_INT 1
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: LIST
37341: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
37342: NOP4
37346: PUSH
37347: LD_INT 2
37349: PUSH
37350: LD_INT 2
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 3
37359: PUSH
37360: LD_INT 2
37362: PUSH
37363: EMPTY
37364: LIST
37365: LIST
37366: PUSH
37367: LD_INT 2
37369: PUSH
37370: LD_INT 3
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: LIST
37381: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
37382: NOP4
37386: PUSH
37387: LD_INT 0
37389: PUSH
37390: LD_INT 2
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 1
37399: PUSH
37400: LD_INT 3
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: LD_INT 1
37409: NEG
37410: PUSH
37411: LD_INT 2
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: LIST
37422: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37423: NOP4
37427: PUSH
37428: LD_INT 2
37430: NEG
37431: PUSH
37432: LD_INT 0
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 2
37441: NEG
37442: PUSH
37443: LD_INT 1
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 3
37452: NEG
37453: PUSH
37454: LD_INT 1
37456: NEG
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: LIST
37466: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37467: NOP4
37471: PUSH
37472: LD_INT 2
37474: NEG
37475: PUSH
37476: LD_INT 2
37478: NEG
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 2
37486: NEG
37487: PUSH
37488: LD_INT 3
37490: NEG
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: LD_INT 3
37498: NEG
37499: PUSH
37500: LD_INT 2
37502: NEG
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: LIST
37512: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37513: NOP4
37517: PUSH
37518: LD_INT 2
37520: NEG
37521: PUSH
37522: LD_INT 3
37524: NEG
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 1
37532: NEG
37533: PUSH
37534: LD_INT 3
37536: NEG
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37546: NOP4
37550: PUSH
37551: LD_INT 1
37553: PUSH
37554: LD_INT 2
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: PUSH
37565: LD_INT 1
37567: NEG
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37577: NOP4
37581: PUSH
37582: LD_INT 3
37584: PUSH
37585: LD_INT 1
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 3
37594: PUSH
37595: LD_INT 2
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37606: NOP4
37610: PUSH
37611: LD_INT 2
37613: PUSH
37614: LD_INT 3
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 3
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37635: NOP4
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: LD_INT 2
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 2
37653: NEG
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37666: NOP4
37670: PUSH
37671: LD_INT 3
37673: NEG
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 3
37685: NEG
37686: PUSH
37687: LD_INT 2
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37699: NOP4
37703: PUSH
37704: LD_INT 1
37706: NEG
37707: PUSH
37708: LD_INT 3
37710: NEG
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: PUSH
37716: LD_INT 0
37718: PUSH
37719: LD_INT 3
37721: NEG
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: LD_INT 2
37732: NEG
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: LIST
37742: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37743: NOP4
37747: PUSH
37748: LD_INT 2
37750: PUSH
37751: LD_INT 1
37753: NEG
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 3
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 3
37771: PUSH
37772: LD_INT 1
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: LIST
37783: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37784: NOP4
37788: PUSH
37789: LD_INT 3
37791: PUSH
37792: LD_INT 2
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 3
37801: PUSH
37802: LD_INT 3
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: LD_INT 2
37811: PUSH
37812: LD_INT 3
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: LIST
37823: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37824: NOP4
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: LD_INT 3
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 0
37841: PUSH
37842: LD_INT 3
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: LD_INT 2
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: LIST
37864: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37865: NOP4
37869: PUSH
37870: LD_INT 2
37872: NEG
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 3
37883: NEG
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 3
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: EMPTY
37905: LIST
37906: LIST
37907: LIST
37908: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37909: NOP4
37913: PUSH
37914: LD_INT 2
37916: NEG
37917: PUSH
37918: LD_INT 3
37920: NEG
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 3
37928: NEG
37929: PUSH
37930: LD_INT 2
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 3
37940: NEG
37941: PUSH
37942: LD_INT 3
37944: NEG
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: LIST
37954: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37955: NOP4
37959: PUSH
37960: LD_INT 1
37962: NEG
37963: PUSH
37964: LD_INT 2
37966: NEG
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 0
37974: PUSH
37975: LD_INT 2
37977: NEG
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 1
37985: PUSH
37986: LD_INT 1
37988: NEG
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: LIST
37998: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37999: NOP4
38003: PUSH
38004: LD_INT 1
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: PUSH
38018: LD_INT 0
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 2
38027: PUSH
38028: LD_INT 1
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: LIST
38039: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38040: NOP4
38044: PUSH
38045: LD_INT 2
38047: PUSH
38048: LD_INT 1
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 2
38057: PUSH
38058: LD_INT 2
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 1
38067: PUSH
38068: LD_INT 2
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: LIST
38079: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38080: NOP4
38084: PUSH
38085: LD_INT 1
38087: PUSH
38088: LD_INT 2
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: LD_INT 2
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: LIST
38120: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38121: NOP4
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 2
38139: NEG
38140: PUSH
38141: LD_INT 0
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 2
38150: NEG
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: LIST
38164: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38165: NOP4
38169: PUSH
38170: LD_INT 1
38172: NEG
38173: PUSH
38174: LD_INT 2
38176: NEG
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 2
38184: NEG
38185: PUSH
38186: LD_INT 1
38188: NEG
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 2
38196: NEG
38197: PUSH
38198: LD_INT 2
38200: NEG
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: LIST
38210: ST_TO_ADDR
// end ; 2 :
38211: GO 41477
38213: LD_INT 2
38215: DOUBLE
38216: EQUAL
38217: IFTRUE 38221
38219: GO 41476
38221: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
38222: NOP4
38226: PUSH
38227: LD_INT 4
38229: PUSH
38230: LD_INT 0
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: PUSH
38237: LD_INT 4
38239: PUSH
38240: LD_INT 1
38242: NEG
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 5
38250: PUSH
38251: LD_INT 0
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 5
38260: PUSH
38261: LD_INT 1
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 4
38270: PUSH
38271: LD_INT 1
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 3
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: PUSH
38291: LD_INT 1
38293: NEG
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: LD_INT 3
38301: PUSH
38302: LD_INT 2
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 5
38312: PUSH
38313: LD_INT 2
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 3
38322: PUSH
38323: LD_INT 3
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 3
38332: PUSH
38333: LD_INT 2
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 4
38342: PUSH
38343: LD_INT 3
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 4
38352: PUSH
38353: LD_INT 4
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 3
38362: PUSH
38363: LD_INT 4
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 2
38372: PUSH
38373: LD_INT 3
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 2
38382: PUSH
38383: LD_INT 2
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 4
38392: PUSH
38393: LD_INT 2
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: LD_INT 4
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 0
38412: PUSH
38413: LD_INT 4
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: LD_INT 3
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 1
38432: PUSH
38433: LD_INT 4
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 1
38442: PUSH
38443: LD_INT 5
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: LD_INT 5
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 1
38462: NEG
38463: PUSH
38464: LD_INT 4
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: LD_INT 1
38473: NEG
38474: PUSH
38475: LD_INT 3
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: PUSH
38485: LD_INT 5
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: NEG
38495: PUSH
38496: LD_INT 3
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 3
38505: NEG
38506: PUSH
38507: LD_INT 0
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 3
38516: NEG
38517: PUSH
38518: LD_INT 1
38520: NEG
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 2
38528: NEG
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 2
38539: NEG
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 3
38550: NEG
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: LD_INT 4
38561: NEG
38562: PUSH
38563: LD_INT 0
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 4
38572: NEG
38573: PUSH
38574: LD_INT 1
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 4
38584: NEG
38585: PUSH
38586: LD_INT 2
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 2
38596: NEG
38597: PUSH
38598: LD_INT 2
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 4
38607: NEG
38608: PUSH
38609: LD_INT 4
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 4
38619: NEG
38620: PUSH
38621: LD_INT 5
38623: NEG
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 3
38631: NEG
38632: PUSH
38633: LD_INT 4
38635: NEG
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 3
38643: NEG
38644: PUSH
38645: LD_INT 3
38647: NEG
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 4
38655: NEG
38656: PUSH
38657: LD_INT 3
38659: NEG
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 5
38667: NEG
38668: PUSH
38669: LD_INT 4
38671: NEG
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 5
38679: NEG
38680: PUSH
38681: LD_INT 5
38683: NEG
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 3
38691: NEG
38692: PUSH
38693: LD_INT 5
38695: NEG
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PUSH
38701: LD_INT 5
38703: NEG
38704: PUSH
38705: LD_INT 3
38707: NEG
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: LIST
38720: LIST
38721: LIST
38722: LIST
38723: LIST
38724: LIST
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38760: NOP4
38764: PUSH
38765: LD_INT 4
38767: PUSH
38768: LD_INT 4
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 4
38777: PUSH
38778: LD_INT 3
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 5
38787: PUSH
38788: LD_INT 4
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 5
38797: PUSH
38798: LD_INT 5
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 4
38807: PUSH
38808: LD_INT 5
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 3
38817: PUSH
38818: LD_INT 4
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 3
38827: PUSH
38828: LD_INT 3
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 5
38837: PUSH
38838: LD_INT 3
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: LD_INT 3
38847: PUSH
38848: LD_INT 5
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: LD_INT 3
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: LD_INT 2
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 1
38877: PUSH
38878: LD_INT 3
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 1
38887: PUSH
38888: LD_INT 4
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 0
38897: PUSH
38898: LD_INT 4
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: LD_INT 3
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: PUSH
38916: LD_INT 1
38918: NEG
38919: PUSH
38920: LD_INT 2
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 2
38929: PUSH
38930: LD_INT 4
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 2
38939: NEG
38940: PUSH
38941: LD_INT 2
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 4
38950: NEG
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 4
38961: NEG
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 3
38973: NEG
38974: PUSH
38975: LD_INT 0
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 3
38984: NEG
38985: PUSH
38986: LD_INT 1
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 4
38995: NEG
38996: PUSH
38997: LD_INT 1
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 5
39006: NEG
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 5
39017: NEG
39018: PUSH
39019: LD_INT 1
39021: NEG
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 5
39029: NEG
39030: PUSH
39031: LD_INT 2
39033: NEG
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 3
39041: NEG
39042: PUSH
39043: LD_INT 2
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 3
39052: NEG
39053: PUSH
39054: LD_INT 3
39056: NEG
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 3
39064: NEG
39065: PUSH
39066: LD_INT 4
39068: NEG
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 2
39076: NEG
39077: PUSH
39078: LD_INT 3
39080: NEG
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 2
39088: NEG
39089: PUSH
39090: LD_INT 2
39092: NEG
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 3
39100: NEG
39101: PUSH
39102: LD_INT 2
39104: NEG
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: LD_INT 4
39112: NEG
39113: PUSH
39114: LD_INT 3
39116: NEG
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 4
39124: NEG
39125: PUSH
39126: LD_INT 4
39128: NEG
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 2
39136: NEG
39137: PUSH
39138: LD_INT 4
39140: NEG
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 4
39148: NEG
39149: PUSH
39150: LD_INT 2
39152: NEG
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 0
39160: PUSH
39161: LD_INT 4
39163: NEG
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 0
39171: PUSH
39172: LD_INT 5
39174: NEG
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: PUSH
39180: LD_INT 1
39182: PUSH
39183: LD_INT 4
39185: NEG
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 1
39193: PUSH
39194: LD_INT 3
39196: NEG
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 0
39204: PUSH
39205: LD_INT 3
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 1
39215: NEG
39216: PUSH
39217: LD_INT 4
39219: NEG
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 1
39227: NEG
39228: PUSH
39229: LD_INT 5
39231: NEG
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 2
39239: PUSH
39240: LD_INT 3
39242: NEG
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 2
39250: NEG
39251: PUSH
39252: LD_INT 5
39254: NEG
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: LIST
39273: LIST
39274: LIST
39275: LIST
39276: LIST
39277: LIST
39278: LIST
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: LIST
39299: LIST
39300: LIST
39301: LIST
39302: LIST
39303: LIST
39304: LIST
39305: LIST
39306: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
39307: NOP4
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: LD_INT 4
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 0
39324: PUSH
39325: LD_INT 3
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 1
39334: PUSH
39335: LD_INT 4
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 1
39344: PUSH
39345: LD_INT 5
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 0
39354: PUSH
39355: LD_INT 5
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 1
39364: NEG
39365: PUSH
39366: LD_INT 4
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 1
39375: NEG
39376: PUSH
39377: LD_INT 3
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 2
39386: PUSH
39387: LD_INT 5
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 2
39396: NEG
39397: PUSH
39398: LD_INT 3
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 3
39407: NEG
39408: PUSH
39409: LD_INT 0
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: LD_INT 3
39418: NEG
39419: PUSH
39420: LD_INT 1
39422: NEG
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 2
39430: NEG
39431: PUSH
39432: LD_INT 0
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 2
39441: NEG
39442: PUSH
39443: LD_INT 1
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 3
39452: NEG
39453: PUSH
39454: LD_INT 1
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 4
39463: NEG
39464: PUSH
39465: LD_INT 0
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 4
39474: NEG
39475: PUSH
39476: LD_INT 1
39478: NEG
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 4
39486: NEG
39487: PUSH
39488: LD_INT 2
39490: NEG
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 2
39498: NEG
39499: PUSH
39500: LD_INT 2
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 4
39509: NEG
39510: PUSH
39511: LD_INT 4
39513: NEG
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 4
39521: NEG
39522: PUSH
39523: LD_INT 5
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 3
39533: NEG
39534: PUSH
39535: LD_INT 4
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 3
39545: NEG
39546: PUSH
39547: LD_INT 3
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 4
39557: NEG
39558: PUSH
39559: LD_INT 3
39561: NEG
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 5
39569: NEG
39570: PUSH
39571: LD_INT 4
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 5
39581: NEG
39582: PUSH
39583: LD_INT 5
39585: NEG
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 3
39593: NEG
39594: PUSH
39595: LD_INT 5
39597: NEG
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 5
39605: NEG
39606: PUSH
39607: LD_INT 3
39609: NEG
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 0
39617: PUSH
39618: LD_INT 3
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: LD_INT 4
39631: NEG
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 1
39639: PUSH
39640: LD_INT 3
39642: NEG
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: PUSH
39648: LD_INT 1
39650: PUSH
39651: LD_INT 2
39653: NEG
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 0
39661: PUSH
39662: LD_INT 2
39664: NEG
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 1
39672: NEG
39673: PUSH
39674: LD_INT 3
39676: NEG
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 1
39684: NEG
39685: PUSH
39686: LD_INT 4
39688: NEG
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 2
39696: PUSH
39697: LD_INT 2
39699: NEG
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 2
39707: NEG
39708: PUSH
39709: LD_INT 4
39711: NEG
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 4
39719: PUSH
39720: LD_INT 0
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 4
39729: PUSH
39730: LD_INT 1
39732: NEG
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 5
39740: PUSH
39741: LD_INT 0
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 5
39750: PUSH
39751: LD_INT 1
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 4
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 3
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: PUSH
39778: LD_INT 3
39780: PUSH
39781: LD_INT 1
39783: NEG
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 3
39791: PUSH
39792: LD_INT 2
39794: NEG
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 5
39802: PUSH
39803: LD_INT 2
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: LIST
39814: LIST
39815: LIST
39816: LIST
39817: LIST
39818: LIST
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: LIST
39824: LIST
39825: LIST
39826: LIST
39827: LIST
39828: LIST
39829: LIST
39830: LIST
39831: LIST
39832: LIST
39833: LIST
39834: LIST
39835: LIST
39836: LIST
39837: LIST
39838: LIST
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: LIST
39848: LIST
39849: LIST
39850: LIST
39851: LIST
39852: LIST
39853: LIST
39854: LIST
39855: LIST
39856: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39857: NOP4
39861: PUSH
39862: LD_INT 4
39864: NEG
39865: PUSH
39866: LD_INT 0
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 4
39875: NEG
39876: PUSH
39877: LD_INT 1
39879: NEG
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: PUSH
39885: LD_INT 3
39887: NEG
39888: PUSH
39889: LD_INT 0
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 3
39898: NEG
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 4
39909: NEG
39910: PUSH
39911: LD_INT 1
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 5
39920: NEG
39921: PUSH
39922: LD_INT 0
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 5
39931: NEG
39932: PUSH
39933: LD_INT 1
39935: NEG
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 5
39943: NEG
39944: PUSH
39945: LD_INT 2
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 3
39955: NEG
39956: PUSH
39957: LD_INT 2
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 3
39966: NEG
39967: PUSH
39968: LD_INT 3
39970: NEG
39971: PUSH
39972: EMPTY
39973: LIST
39974: LIST
39975: PUSH
39976: LD_INT 3
39978: NEG
39979: PUSH
39980: LD_INT 4
39982: NEG
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 2
39990: NEG
39991: PUSH
39992: LD_INT 3
39994: NEG
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: LD_INT 2
40002: NEG
40003: PUSH
40004: LD_INT 2
40006: NEG
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 3
40014: NEG
40015: PUSH
40016: LD_INT 2
40018: NEG
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 4
40026: NEG
40027: PUSH
40028: LD_INT 3
40030: NEG
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 4
40038: NEG
40039: PUSH
40040: LD_INT 4
40042: NEG
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 2
40050: NEG
40051: PUSH
40052: LD_INT 4
40054: NEG
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 4
40062: NEG
40063: PUSH
40064: LD_INT 2
40066: NEG
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 0
40074: PUSH
40075: LD_INT 4
40077: NEG
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: LD_INT 5
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 1
40096: PUSH
40097: LD_INT 4
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 1
40107: PUSH
40108: LD_INT 3
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: LD_INT 3
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 1
40129: NEG
40130: PUSH
40131: LD_INT 4
40133: NEG
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: LD_INT 1
40141: NEG
40142: PUSH
40143: LD_INT 5
40145: NEG
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 2
40153: PUSH
40154: LD_INT 3
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 2
40164: NEG
40165: PUSH
40166: LD_INT 5
40168: NEG
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 3
40176: PUSH
40177: LD_INT 0
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 3
40186: PUSH
40187: LD_INT 1
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 4
40197: PUSH
40198: LD_INT 0
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 4
40207: PUSH
40208: LD_INT 1
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 3
40217: PUSH
40218: LD_INT 1
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 2
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 2
40237: PUSH
40238: LD_INT 1
40240: NEG
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 2
40248: PUSH
40249: LD_INT 2
40251: NEG
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 4
40259: PUSH
40260: LD_INT 2
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 4
40269: PUSH
40270: LD_INT 4
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 4
40279: PUSH
40280: LD_INT 3
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 5
40289: PUSH
40290: LD_INT 4
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 5
40299: PUSH
40300: LD_INT 5
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 4
40309: PUSH
40310: LD_INT 5
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 3
40319: PUSH
40320: LD_INT 4
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 3
40329: PUSH
40330: LD_INT 3
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 5
40339: PUSH
40340: LD_INT 3
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 3
40349: PUSH
40350: LD_INT 5
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: LIST
40375: LIST
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: LIST
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: LIST
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: LIST
40401: LIST
40402: LIST
40403: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
40404: NOP4
40408: PUSH
40409: LD_INT 4
40411: NEG
40412: PUSH
40413: LD_INT 4
40415: NEG
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 4
40423: NEG
40424: PUSH
40425: LD_INT 5
40427: NEG
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 3
40435: NEG
40436: PUSH
40437: LD_INT 4
40439: NEG
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 3
40447: NEG
40448: PUSH
40449: LD_INT 3
40451: NEG
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PUSH
40457: LD_INT 4
40459: NEG
40460: PUSH
40461: LD_INT 3
40463: NEG
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 5
40471: NEG
40472: PUSH
40473: LD_INT 4
40475: NEG
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 5
40483: NEG
40484: PUSH
40485: LD_INT 5
40487: NEG
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 3
40495: NEG
40496: PUSH
40497: LD_INT 5
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 5
40507: NEG
40508: PUSH
40509: LD_INT 3
40511: NEG
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 0
40519: PUSH
40520: LD_INT 3
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 4
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: PUSH
40542: LD_INT 3
40544: NEG
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 1
40552: PUSH
40553: LD_INT 2
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: LD_INT 0
40563: PUSH
40564: LD_INT 2
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 1
40574: NEG
40575: PUSH
40576: LD_INT 3
40578: NEG
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 1
40586: NEG
40587: PUSH
40588: LD_INT 4
40590: NEG
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 2
40598: PUSH
40599: LD_INT 2
40601: NEG
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 2
40609: NEG
40610: PUSH
40611: LD_INT 4
40613: NEG
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 4
40621: PUSH
40622: LD_INT 0
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 4
40631: PUSH
40632: LD_INT 1
40634: NEG
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 5
40642: PUSH
40643: LD_INT 0
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 5
40652: PUSH
40653: LD_INT 1
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 4
40662: PUSH
40663: LD_INT 1
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 3
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 3
40682: PUSH
40683: LD_INT 1
40685: NEG
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 3
40693: PUSH
40694: LD_INT 2
40696: NEG
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 5
40704: PUSH
40705: LD_INT 2
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: PUSH
40712: LD_INT 3
40714: PUSH
40715: LD_INT 3
40717: PUSH
40718: EMPTY
40719: LIST
40720: LIST
40721: PUSH
40722: LD_INT 3
40724: PUSH
40725: LD_INT 2
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 4
40734: PUSH
40735: LD_INT 3
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: LD_INT 4
40744: PUSH
40745: LD_INT 4
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 3
40754: PUSH
40755: LD_INT 4
40757: PUSH
40758: EMPTY
40759: LIST
40760: LIST
40761: PUSH
40762: LD_INT 2
40764: PUSH
40765: LD_INT 3
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 2
40774: PUSH
40775: LD_INT 2
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 4
40784: PUSH
40785: LD_INT 2
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: PUSH
40792: LD_INT 2
40794: PUSH
40795: LD_INT 4
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: PUSH
40802: LD_INT 0
40804: PUSH
40805: LD_INT 4
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: LD_INT 3
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 1
40824: PUSH
40825: LD_INT 4
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 5
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 0
40844: PUSH
40845: LD_INT 5
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: LD_INT 4
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: LD_INT 1
40865: NEG
40866: PUSH
40867: LD_INT 3
40869: PUSH
40870: EMPTY
40871: LIST
40872: LIST
40873: PUSH
40874: LD_INT 2
40876: PUSH
40877: LD_INT 5
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 2
40886: NEG
40887: PUSH
40888: LD_INT 3
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: LIST
40918: LIST
40919: LIST
40920: LIST
40921: LIST
40922: LIST
40923: LIST
40924: LIST
40925: LIST
40926: LIST
40927: LIST
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: LIST
40937: LIST
40938: LIST
40939: LIST
40940: LIST
40941: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40942: NOP4
40946: PUSH
40947: LD_INT 0
40949: PUSH
40950: LD_INT 4
40952: NEG
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 0
40960: PUSH
40961: LD_INT 5
40963: NEG
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 1
40971: PUSH
40972: LD_INT 4
40974: NEG
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 1
40982: PUSH
40983: LD_INT 3
40985: NEG
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 0
40993: PUSH
40994: LD_INT 3
40996: NEG
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 1
41004: NEG
41005: PUSH
41006: LD_INT 4
41008: NEG
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: LD_INT 1
41016: NEG
41017: PUSH
41018: LD_INT 5
41020: NEG
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 2
41028: PUSH
41029: LD_INT 3
41031: NEG
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 2
41039: NEG
41040: PUSH
41041: LD_INT 5
41043: NEG
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: LD_INT 0
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 3
41061: PUSH
41062: LD_INT 1
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 4
41072: PUSH
41073: LD_INT 0
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: LD_INT 4
41082: PUSH
41083: LD_INT 1
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 3
41092: PUSH
41093: LD_INT 1
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 2
41102: PUSH
41103: LD_INT 0
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: LD_INT 1
41115: NEG
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 2
41123: PUSH
41124: LD_INT 2
41126: NEG
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 4
41134: PUSH
41135: LD_INT 2
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 4
41144: PUSH
41145: LD_INT 4
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 4
41154: PUSH
41155: LD_INT 3
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 5
41164: PUSH
41165: LD_INT 4
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 5
41174: PUSH
41175: LD_INT 5
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 4
41184: PUSH
41185: LD_INT 5
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 3
41194: PUSH
41195: LD_INT 4
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 3
41204: PUSH
41205: LD_INT 3
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 5
41214: PUSH
41215: LD_INT 3
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: LD_INT 3
41224: PUSH
41225: LD_INT 5
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: PUSH
41232: LD_INT 0
41234: PUSH
41235: LD_INT 3
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: LD_INT 0
41244: PUSH
41245: LD_INT 2
41247: PUSH
41248: EMPTY
41249: LIST
41250: LIST
41251: PUSH
41252: LD_INT 1
41254: PUSH
41255: LD_INT 3
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 1
41264: PUSH
41265: LD_INT 4
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 0
41274: PUSH
41275: LD_INT 4
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 1
41284: NEG
41285: PUSH
41286: LD_INT 3
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: LD_INT 1
41295: NEG
41296: PUSH
41297: LD_INT 2
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 4
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 2
41316: NEG
41317: PUSH
41318: LD_INT 2
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 4
41327: NEG
41328: PUSH
41329: LD_INT 0
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 4
41338: NEG
41339: PUSH
41340: LD_INT 1
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 3
41350: NEG
41351: PUSH
41352: LD_INT 0
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 3
41361: NEG
41362: PUSH
41363: LD_INT 1
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 4
41372: NEG
41373: PUSH
41374: LD_INT 1
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 5
41383: NEG
41384: PUSH
41385: LD_INT 0
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 5
41394: NEG
41395: PUSH
41396: LD_INT 1
41398: NEG
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 5
41406: NEG
41407: PUSH
41408: LD_INT 2
41410: NEG
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 3
41418: NEG
41419: PUSH
41420: LD_INT 2
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: LIST
41431: LIST
41432: LIST
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: LIST
41463: LIST
41464: LIST
41465: LIST
41466: LIST
41467: LIST
41468: LIST
41469: LIST
41470: LIST
41471: LIST
41472: LIST
41473: ST_TO_ADDR
// end ; end ;
41474: GO 41477
41476: POP
// case btype of b_depot , b_warehouse :
41477: NOP4
41481: PUSH
41482: LD_INT 0
41484: DOUBLE
41485: EQUAL
41486: IFTRUE 41496
41488: LD_INT 1
41490: DOUBLE
41491: EQUAL
41492: IFTRUE 41496
41494: GO 41697
41496: POP
// case nation of nation_american :
41497: NOP4
41501: PUSH
41502: LD_INT 1
41504: DOUBLE
41505: EQUAL
41506: IFTRUE 41510
41508: GO 41566
41510: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41511: NOP4
41515: PUSH
41516: NOP4
41520: PUSH
41521: NOP4
41525: PUSH
41526: NOP4
41530: PUSH
41531: NOP4
41535: PUSH
41536: NOP4
41540: PUSH
41541: NOP4
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: PUSH
41554: NOP4
41558: PUSH
41559: LD_INT 1
41561: PLUS
41562: ARRAY
41563: ST_TO_ADDR
41564: GO 41695
41566: LD_INT 2
41568: DOUBLE
41569: EQUAL
41570: IFTRUE 41574
41572: GO 41630
41574: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41575: NOP4
41579: PUSH
41580: NOP4
41584: PUSH
41585: NOP4
41589: PUSH
41590: NOP4
41594: PUSH
41595: NOP4
41599: PUSH
41600: NOP4
41604: PUSH
41605: NOP4
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: PUSH
41618: NOP4
41622: PUSH
41623: LD_INT 1
41625: PLUS
41626: ARRAY
41627: ST_TO_ADDR
41628: GO 41695
41630: LD_INT 3
41632: DOUBLE
41633: EQUAL
41634: IFTRUE 41638
41636: GO 41694
41638: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41639: NOP4
41643: PUSH
41644: NOP4
41648: PUSH
41649: NOP4
41653: PUSH
41654: NOP4
41658: PUSH
41659: NOP4
41663: PUSH
41664: NOP4
41668: PUSH
41669: NOP4
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: PUSH
41682: NOP4
41686: PUSH
41687: LD_INT 1
41689: PLUS
41690: ARRAY
41691: ST_TO_ADDR
41692: GO 41695
41694: POP
41695: GO 42250
41697: LD_INT 2
41699: DOUBLE
41700: EQUAL
41701: IFTRUE 41711
41703: LD_INT 3
41705: DOUBLE
41706: EQUAL
41707: IFTRUE 41711
41709: GO 41767
41711: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41712: NOP4
41716: PUSH
41717: NOP4
41721: PUSH
41722: NOP4
41726: PUSH
41727: NOP4
41731: PUSH
41732: NOP4
41736: PUSH
41737: NOP4
41741: PUSH
41742: NOP4
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: PUSH
41755: NOP4
41759: PUSH
41760: LD_INT 1
41762: PLUS
41763: ARRAY
41764: ST_TO_ADDR
41765: GO 42250
41767: LD_INT 16
41769: DOUBLE
41770: EQUAL
41771: IFTRUE 41829
41773: LD_INT 17
41775: DOUBLE
41776: EQUAL
41777: IFTRUE 41829
41779: LD_INT 18
41781: DOUBLE
41782: EQUAL
41783: IFTRUE 41829
41785: LD_INT 19
41787: DOUBLE
41788: EQUAL
41789: IFTRUE 41829
41791: LD_INT 22
41793: DOUBLE
41794: EQUAL
41795: IFTRUE 41829
41797: LD_INT 20
41799: DOUBLE
41800: EQUAL
41801: IFTRUE 41829
41803: LD_INT 21
41805: DOUBLE
41806: EQUAL
41807: IFTRUE 41829
41809: LD_INT 23
41811: DOUBLE
41812: EQUAL
41813: IFTRUE 41829
41815: LD_INT 24
41817: DOUBLE
41818: EQUAL
41819: IFTRUE 41829
41821: LD_INT 25
41823: DOUBLE
41824: EQUAL
41825: IFTRUE 41829
41827: GO 41885
41829: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41830: NOP4
41834: PUSH
41835: NOP4
41839: PUSH
41840: NOP4
41844: PUSH
41845: NOP4
41849: PUSH
41850: NOP4
41854: PUSH
41855: NOP4
41859: PUSH
41860: NOP4
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: LIST
41869: LIST
41870: LIST
41871: LIST
41872: PUSH
41873: NOP4
41877: PUSH
41878: LD_INT 1
41880: PLUS
41881: ARRAY
41882: ST_TO_ADDR
41883: GO 42250
41885: LD_INT 6
41887: DOUBLE
41888: EQUAL
41889: IFTRUE 41941
41891: LD_INT 7
41893: DOUBLE
41894: EQUAL
41895: IFTRUE 41941
41897: LD_INT 8
41899: DOUBLE
41900: EQUAL
41901: IFTRUE 41941
41903: LD_INT 13
41905: DOUBLE
41906: EQUAL
41907: IFTRUE 41941
41909: LD_INT 12
41911: DOUBLE
41912: EQUAL
41913: IFTRUE 41941
41915: LD_INT 15
41917: DOUBLE
41918: EQUAL
41919: IFTRUE 41941
41921: LD_INT 11
41923: DOUBLE
41924: EQUAL
41925: IFTRUE 41941
41927: LD_INT 14
41929: DOUBLE
41930: EQUAL
41931: IFTRUE 41941
41933: LD_INT 10
41935: DOUBLE
41936: EQUAL
41937: IFTRUE 41941
41939: GO 41997
41941: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41942: NOP4
41946: PUSH
41947: NOP4
41951: PUSH
41952: NOP4
41956: PUSH
41957: NOP4
41961: PUSH
41962: NOP4
41966: PUSH
41967: NOP4
41971: PUSH
41972: NOP4
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: LIST
41981: LIST
41982: LIST
41983: LIST
41984: PUSH
41985: NOP4
41989: PUSH
41990: LD_INT 1
41992: PLUS
41993: ARRAY
41994: ST_TO_ADDR
41995: GO 42250
41997: LD_INT 36
41999: DOUBLE
42000: EQUAL
42001: IFTRUE 42005
42003: GO 42061
42005: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42006: NOP4
42010: PUSH
42011: NOP4
42015: PUSH
42016: NOP4
42020: PUSH
42021: NOP4
42025: PUSH
42026: NOP4
42030: PUSH
42031: NOP4
42035: PUSH
42036: NOP4
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: LIST
42045: LIST
42046: LIST
42047: LIST
42048: PUSH
42049: NOP4
42053: PUSH
42054: LD_INT 1
42056: PLUS
42057: ARRAY
42058: ST_TO_ADDR
42059: GO 42250
42061: LD_INT 4
42063: DOUBLE
42064: EQUAL
42065: IFTRUE 42087
42067: LD_INT 5
42069: DOUBLE
42070: EQUAL
42071: IFTRUE 42087
42073: LD_INT 34
42075: DOUBLE
42076: EQUAL
42077: IFTRUE 42087
42079: LD_INT 37
42081: DOUBLE
42082: EQUAL
42083: IFTRUE 42087
42085: GO 42143
42087: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42088: NOP4
42092: PUSH
42093: NOP4
42097: PUSH
42098: NOP4
42102: PUSH
42103: NOP4
42107: PUSH
42108: NOP4
42112: PUSH
42113: NOP4
42117: PUSH
42118: NOP4
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: LIST
42127: LIST
42128: LIST
42129: LIST
42130: PUSH
42131: NOP4
42135: PUSH
42136: LD_INT 1
42138: PLUS
42139: ARRAY
42140: ST_TO_ADDR
42141: GO 42250
42143: LD_INT 31
42145: DOUBLE
42146: EQUAL
42147: IFTRUE 42193
42149: LD_INT 32
42151: DOUBLE
42152: EQUAL
42153: IFTRUE 42193
42155: LD_INT 33
42157: DOUBLE
42158: EQUAL
42159: IFTRUE 42193
42161: LD_INT 27
42163: DOUBLE
42164: EQUAL
42165: IFTRUE 42193
42167: LD_INT 26
42169: DOUBLE
42170: EQUAL
42171: IFTRUE 42193
42173: LD_INT 28
42175: DOUBLE
42176: EQUAL
42177: IFTRUE 42193
42179: LD_INT 29
42181: DOUBLE
42182: EQUAL
42183: IFTRUE 42193
42185: LD_INT 30
42187: DOUBLE
42188: EQUAL
42189: IFTRUE 42193
42191: GO 42249
42193: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
42194: NOP4
42198: PUSH
42199: NOP4
42203: PUSH
42204: NOP4
42208: PUSH
42209: NOP4
42213: PUSH
42214: NOP4
42218: PUSH
42219: NOP4
42223: PUSH
42224: NOP4
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: PUSH
42237: NOP4
42241: PUSH
42242: LD_INT 1
42244: PLUS
42245: ARRAY
42246: ST_TO_ADDR
42247: GO 42250
42249: POP
// temp_list2 = [ ] ;
42250: NOP4
42254: PUSH
42255: EMPTY
42256: ST_TO_ADDR
// for i in temp_list do
42257: NOP4
42261: PUSH
42262: NOP4
42266: PUSH
42267: FOR_IN
42268: IFFALSE 42320
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
42270: NOP4
42274: PUSH
42275: NOP4
42279: PUSH
42280: NOP4
42284: PUSH
42285: LD_INT 1
42287: ARRAY
42288: PUSH
42289: NOP4
42293: PLUS
42294: PUSH
42295: NOP4
42299: PUSH
42300: LD_INT 2
42302: ARRAY
42303: PUSH
42304: NOP4
42308: PLUS
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: EMPTY
42315: LIST
42316: ADD
42317: ST_TO_ADDR
42318: GO 42267
42320: POP
42321: POP
// result = temp_list2 ;
42322: NOP4
42326: PUSH
42327: NOP4
42331: ST_TO_ADDR
// end ;
42332: LD_VAR 0 7
42336: RET
// export function EnemyInRange ( unit , dist ) ; begin
42337: LD_INT 0
42339: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
42340: NOP4
42344: PUSH
42345: NOP4
42349: PPUSH
42350: NOP4
42354: PPUSH
42355: NOP4
42359: PPUSH
42360: NOP4
42364: PPUSH
42365: NOP4
42369: PPUSH
42370: NOP4
42374: PPUSH
42375: NOP4
42379: PPUSH
42380: NOP4
42384: PUSH
42385: LD_INT 4
42387: ARRAY
42388: ST_TO_ADDR
// end ;
42389: LD_VAR 0 3
42393: RET
// export function PlayerSeeMe ( unit ) ; begin
42394: LD_INT 0
42396: PPUSH
// result := See ( your_side , unit ) ;
42397: NOP4
42401: PUSH
42402: NOP4
42406: PPUSH
42407: NOP4
42411: PPUSH
42412: NOP4
42416: ST_TO_ADDR
// end ;
42417: LD_VAR 0 2
42421: RET
// export function ReverseDir ( unit ) ; begin
42422: LD_INT 0
42424: PPUSH
// if not unit then
42425: NOP4
42429: NOT
42430: IFFALSE 42434
// exit ;
42432: GO 42457
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42434: NOP4
42438: PUSH
42439: NOP4
42443: PPUSH
42444: NOP4
42448: PUSH
42449: LD_INT 3
42451: PLUS
42452: PUSH
42453: LD_INT 6
42455: MOD
42456: ST_TO_ADDR
// end ;
42457: LD_VAR 0 2
42461: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
42462: LD_INT 0
42464: PPUSH
42465: PPUSH
42466: PPUSH
42467: PPUSH
42468: PPUSH
// if not hexes then
42469: NOP4
42473: NOT
42474: IFFALSE 42478
// exit ;
42476: GO 42626
// dist := 9999 ;
42478: NOP4
42482: PUSH
42483: LD_INT 9999
42485: ST_TO_ADDR
// for i = 1 to hexes do
42486: NOP4
42490: PUSH
42491: DOUBLE
42492: LD_INT 1
42494: DEC
42495: ST_TO_ADDR
42496: NOP4
42500: PUSH
42501: FOR_TO
42502: IFFALSE 42614
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
42504: NOP4
42508: PPUSH
42509: NOP4
42513: PUSH
42514: NOP4
42518: ARRAY
42519: PUSH
42520: LD_INT 1
42522: ARRAY
42523: PPUSH
42524: NOP4
42528: PUSH
42529: NOP4
42533: ARRAY
42534: PUSH
42535: LD_INT 2
42537: ARRAY
42538: PPUSH
42539: NOP4
42543: PUSH
42544: NOP4
42548: LESS
42549: IFFALSE 42612
// begin hex := hexes [ i ] ;
42551: NOP4
42555: PUSH
42556: NOP4
42560: PUSH
42561: NOP4
42565: ARRAY
42566: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42567: NOP4
42571: PUSH
42572: NOP4
42576: PPUSH
42577: NOP4
42581: PUSH
42582: NOP4
42586: ARRAY
42587: PUSH
42588: LD_INT 1
42590: ARRAY
42591: PPUSH
42592: NOP4
42596: PUSH
42597: NOP4
42601: ARRAY
42602: PUSH
42603: LD_INT 2
42605: ARRAY
42606: PPUSH
42607: NOP4
42611: ST_TO_ADDR
// end ; end ;
42612: GO 42501
42614: POP
42615: POP
// result := hex ;
42616: NOP4
42620: PUSH
42621: NOP4
42625: ST_TO_ADDR
// end ;
42626: LD_VAR 0 3
42630: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42631: LD_INT 0
42633: PPUSH
42634: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42635: NOP4
42639: NOT
42640: PUSH
42641: NOP4
42645: PUSH
42646: LD_INT 21
42648: PUSH
42649: LD_INT 2
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 23
42658: PUSH
42659: LD_INT 2
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PPUSH
42670: NOP4
42674: IN
42675: NOT
42676: OR
42677: IFFALSE 42681
// exit ;
42679: GO 42728
// for i = 1 to 3 do
42681: NOP4
42685: PUSH
42686: DOUBLE
42687: LD_INT 1
42689: DEC
42690: ST_TO_ADDR
42691: LD_INT 3
42693: PUSH
42694: FOR_TO
42695: IFFALSE 42726
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42697: NOP4
42701: PPUSH
42702: NOP4
42706: PPUSH
42707: NOP4
42711: PPUSH
42712: NOP4
42716: PPUSH
42717: LD_INT 1
42719: PPUSH
42720: NOP4
42724: GO 42694
42726: POP
42727: POP
// end ;
42728: LD_VAR 0 2
42732: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42733: LD_INT 0
42735: PPUSH
42736: PPUSH
42737: PPUSH
42738: PPUSH
42739: PPUSH
42740: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42741: NOP4
42745: NOT
42746: PUSH
42747: NOP4
42751: NOT
42752: OR
42753: PUSH
42754: NOP4
42758: PPUSH
42759: NOP4
42763: OR
42764: IFFALSE 42768
// exit ;
42766: GO 43209
// x := GetX ( enemy_unit ) ;
42768: NOP4
42772: PUSH
42773: NOP4
42777: PPUSH
42778: NOP4
42782: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42783: NOP4
42787: PUSH
42788: NOP4
42792: PPUSH
42793: NOP4
42797: ST_TO_ADDR
// if not x or not y then
42798: NOP4
42802: NOT
42803: PUSH
42804: NOP4
42808: NOT
42809: OR
42810: IFFALSE 42814
// exit ;
42812: GO 43209
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42814: NOP4
42818: PUSH
42819: NOP4
42823: PPUSH
42824: LD_INT 0
42826: PPUSH
42827: LD_INT 4
42829: PPUSH
42830: NOP4
42834: PUSH
42835: NOP4
42839: PPUSH
42840: LD_INT 0
42842: PPUSH
42843: LD_INT 4
42845: PPUSH
42846: NOP4
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: NOP4
42859: PPUSH
42860: LD_INT 1
42862: PPUSH
42863: LD_INT 4
42865: PPUSH
42866: NOP4
42870: PUSH
42871: NOP4
42875: PPUSH
42876: LD_INT 1
42878: PPUSH
42879: LD_INT 4
42881: PPUSH
42882: NOP4
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: NOP4
42895: PPUSH
42896: LD_INT 2
42898: PPUSH
42899: LD_INT 4
42901: PPUSH
42902: NOP4
42906: PUSH
42907: NOP4
42911: PPUSH
42912: LD_INT 2
42914: PPUSH
42915: LD_INT 4
42917: PPUSH
42918: NOP4
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: NOP4
42931: PPUSH
42932: LD_INT 3
42934: PPUSH
42935: LD_INT 4
42937: PPUSH
42938: NOP4
42942: PUSH
42943: NOP4
42947: PPUSH
42948: LD_INT 3
42950: PPUSH
42951: LD_INT 4
42953: PPUSH
42954: NOP4
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: NOP4
42967: PPUSH
42968: LD_INT 4
42970: PPUSH
42971: LD_INT 4
42973: PPUSH
42974: NOP4
42978: PUSH
42979: NOP4
42983: PPUSH
42984: LD_INT 4
42986: PPUSH
42987: LD_INT 4
42989: PPUSH
42990: NOP4
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: NOP4
43003: PPUSH
43004: LD_INT 5
43006: PPUSH
43007: LD_INT 4
43009: PPUSH
43010: NOP4
43014: PUSH
43015: NOP4
43019: PPUSH
43020: LD_INT 5
43022: PPUSH
43023: LD_INT 4
43025: PPUSH
43026: NOP4
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: ST_TO_ADDR
// for i = tmp downto 1 do
43043: NOP4
43047: PUSH
43048: DOUBLE
43049: NOP4
43053: INC
43054: ST_TO_ADDR
43055: LD_INT 1
43057: PUSH
43058: FOR_DOWNTO
43059: IFFALSE 43160
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43061: NOP4
43065: PUSH
43066: NOP4
43070: ARRAY
43071: PUSH
43072: LD_INT 1
43074: ARRAY
43075: PPUSH
43076: NOP4
43080: PUSH
43081: NOP4
43085: ARRAY
43086: PUSH
43087: LD_INT 2
43089: ARRAY
43090: PPUSH
43091: NOP4
43095: NOT
43096: PUSH
43097: NOP4
43101: PUSH
43102: NOP4
43106: ARRAY
43107: PUSH
43108: LD_INT 1
43110: ARRAY
43111: PPUSH
43112: NOP4
43116: PUSH
43117: NOP4
43121: ARRAY
43122: PUSH
43123: LD_INT 2
43125: ARRAY
43126: PPUSH
43127: NOP4
43131: PUSH
43132: LD_INT 0
43134: NONEQUAL
43135: OR
43136: IFFALSE 43158
// tmp := Delete ( tmp , i ) ;
43138: NOP4
43142: PUSH
43143: NOP4
43147: PPUSH
43148: NOP4
43152: PPUSH
43153: NOP4
43157: ST_TO_ADDR
43158: GO 43058
43160: POP
43161: POP
// j := GetClosestHex ( unit , tmp ) ;
43162: NOP4
43166: PUSH
43167: NOP4
43171: PPUSH
43172: NOP4
43176: PPUSH
43177: NOP4
43181: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
43182: NOP4
43186: PPUSH
43187: NOP4
43191: PUSH
43192: LD_INT 1
43194: ARRAY
43195: PPUSH
43196: NOP4
43200: PUSH
43201: LD_INT 2
43203: ARRAY
43204: PPUSH
43205: NOP4
// end ;
43209: LD_VAR 0 3
43213: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
43214: LD_INT 0
43216: PPUSH
43217: PPUSH
43218: PPUSH
// uc_side = 0 ;
43219: LD_ADDR_OWVAR 20
43223: PUSH
43224: LD_INT 0
43226: ST_TO_ADDR
// uc_nation = 0 ;
43227: LD_ADDR_OWVAR 21
43231: PUSH
43232: LD_INT 0
43234: ST_TO_ADDR
// InitHc_All ( ) ;
43235: NOP4
// InitVc ;
43239: NOP4
// if mastodonts then
43243: NOP4
43247: IFFALSE 43314
// for i = 1 to mastodonts do
43249: NOP4
43253: PUSH
43254: DOUBLE
43255: LD_INT 1
43257: DEC
43258: ST_TO_ADDR
43259: NOP4
43263: PUSH
43264: FOR_TO
43265: IFFALSE 43312
// begin vc_chassis := 31 ;
43267: LD_ADDR_OWVAR 37
43271: PUSH
43272: LD_INT 31
43274: ST_TO_ADDR
// vc_control := control_rider ;
43275: LD_ADDR_OWVAR 38
43279: PUSH
43280: LD_INT 4
43282: ST_TO_ADDR
// animal := CreateVehicle ;
43283: NOP4
43287: PUSH
43288: NOP4
43292: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43293: NOP4
43297: PPUSH
43298: NOP4
43302: PPUSH
43303: LD_INT 0
43305: PPUSH
43306: NOP4
// end ;
43310: GO 43264
43312: POP
43313: POP
// if horses then
43314: NOP4
43318: IFFALSE 43385
// for i = 1 to horses do
43320: NOP4
43324: PUSH
43325: DOUBLE
43326: LD_INT 1
43328: DEC
43329: ST_TO_ADDR
43330: NOP4
43334: PUSH
43335: FOR_TO
43336: IFFALSE 43383
// begin hc_class := 21 ;
43338: LD_ADDR_OWVAR 28
43342: PUSH
43343: LD_INT 21
43345: ST_TO_ADDR
// hc_gallery :=  ;
43346: LD_ADDR_OWVAR 33
43350: PUSH
43351: LD_STRING 
43353: ST_TO_ADDR
// animal := CreateHuman ;
43354: NOP4
43358: PUSH
43359: NOP4
43363: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43364: NOP4
43368: PPUSH
43369: NOP4
43373: PPUSH
43374: LD_INT 0
43376: PPUSH
43377: NOP4
// end ;
43381: GO 43335
43383: POP
43384: POP
// if birds then
43385: NOP4
43389: IFFALSE 43456
// for i = 1 to birds do
43391: NOP4
43395: PUSH
43396: DOUBLE
43397: LD_INT 1
43399: DEC
43400: ST_TO_ADDR
43401: NOP4
43405: PUSH
43406: FOR_TO
43407: IFFALSE 43454
// begin hc_class = 18 ;
43409: LD_ADDR_OWVAR 28
43413: PUSH
43414: LD_INT 18
43416: ST_TO_ADDR
// hc_gallery =  ;
43417: LD_ADDR_OWVAR 33
43421: PUSH
43422: LD_STRING 
43424: ST_TO_ADDR
// animal := CreateHuman ;
43425: NOP4
43429: PUSH
43430: NOP4
43434: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43435: NOP4
43439: PPUSH
43440: NOP4
43444: PPUSH
43445: LD_INT 0
43447: PPUSH
43448: NOP4
// end ;
43452: GO 43406
43454: POP
43455: POP
// if tigers then
43456: NOP4
43460: IFFALSE 43544
// for i = 1 to tigers do
43462: NOP4
43466: PUSH
43467: DOUBLE
43468: LD_INT 1
43470: DEC
43471: ST_TO_ADDR
43472: NOP4
43476: PUSH
43477: FOR_TO
43478: IFFALSE 43542
// begin hc_class = class_tiger ;
43480: LD_ADDR_OWVAR 28
43484: PUSH
43485: LD_INT 14
43487: ST_TO_ADDR
// hc_gallery =  ;
43488: LD_ADDR_OWVAR 33
43492: PUSH
43493: LD_STRING 
43495: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
43496: LD_ADDR_OWVAR 35
43500: PUSH
43501: LD_INT 7
43503: NEG
43504: PPUSH
43505: LD_INT 7
43507: PPUSH
43508: NOP4
43512: ST_TO_ADDR
// animal := CreateHuman ;
43513: NOP4
43517: PUSH
43518: NOP4
43522: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43523: NOP4
43527: PPUSH
43528: NOP4
43532: PPUSH
43533: LD_INT 0
43535: PPUSH
43536: NOP4
// end ;
43540: GO 43477
43542: POP
43543: POP
// if apemans then
43544: NOP4
43548: IFFALSE 43671
// for i = 1 to apemans do
43550: NOP4
43554: PUSH
43555: DOUBLE
43556: LD_INT 1
43558: DEC
43559: ST_TO_ADDR
43560: NOP4
43564: PUSH
43565: FOR_TO
43566: IFFALSE 43669
// begin hc_class = class_apeman ;
43568: LD_ADDR_OWVAR 28
43572: PUSH
43573: LD_INT 12
43575: ST_TO_ADDR
// hc_gallery =  ;
43576: LD_ADDR_OWVAR 33
43580: PUSH
43581: LD_STRING 
43583: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
43584: LD_ADDR_OWVAR 35
43588: PUSH
43589: LD_INT 2
43591: NEG
43592: PPUSH
43593: LD_INT 2
43595: PPUSH
43596: NOP4
43600: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
43601: LD_ADDR_OWVAR 31
43605: PUSH
43606: LD_INT 1
43608: PPUSH
43609: LD_INT 3
43611: PPUSH
43612: NOP4
43616: PUSH
43617: LD_INT 1
43619: PPUSH
43620: LD_INT 3
43622: PPUSH
43623: NOP4
43627: PUSH
43628: LD_INT 0
43630: PUSH
43631: LD_INT 0
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: LIST
43638: LIST
43639: ST_TO_ADDR
// animal := CreateHuman ;
43640: NOP4
43644: PUSH
43645: NOP4
43649: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43650: NOP4
43654: PPUSH
43655: NOP4
43659: PPUSH
43660: LD_INT 0
43662: PPUSH
43663: NOP4
// end ;
43667: GO 43565
43669: POP
43670: POP
// if enchidnas then
43671: NOP4
43675: IFFALSE 43742
// for i = 1 to enchidnas do
43677: NOP4
43681: PUSH
43682: DOUBLE
43683: LD_INT 1
43685: DEC
43686: ST_TO_ADDR
43687: NOP4
43691: PUSH
43692: FOR_TO
43693: IFFALSE 43740
// begin hc_class = 13 ;
43695: LD_ADDR_OWVAR 28
43699: PUSH
43700: LD_INT 13
43702: ST_TO_ADDR
// hc_gallery =  ;
43703: LD_ADDR_OWVAR 33
43707: PUSH
43708: LD_STRING 
43710: ST_TO_ADDR
// animal := CreateHuman ;
43711: NOP4
43715: PUSH
43716: NOP4
43720: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43721: NOP4
43725: PPUSH
43726: NOP4
43730: PPUSH
43731: LD_INT 0
43733: PPUSH
43734: NOP4
// end ;
43738: GO 43692
43740: POP
43741: POP
// if fishes then
43742: NOP4
43746: IFFALSE 43813
// for i = 1 to fishes do
43748: NOP4
43752: PUSH
43753: DOUBLE
43754: LD_INT 1
43756: DEC
43757: ST_TO_ADDR
43758: NOP4
43762: PUSH
43763: FOR_TO
43764: IFFALSE 43811
// begin hc_class = 20 ;
43766: LD_ADDR_OWVAR 28
43770: PUSH
43771: LD_INT 20
43773: ST_TO_ADDR
// hc_gallery =  ;
43774: LD_ADDR_OWVAR 33
43778: PUSH
43779: LD_STRING 
43781: ST_TO_ADDR
// animal := CreateHuman ;
43782: NOP4
43786: PUSH
43787: NOP4
43791: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43792: NOP4
43796: PPUSH
43797: NOP4
43801: PPUSH
43802: LD_INT 0
43804: PPUSH
43805: NOP4
// end ;
43809: GO 43763
43811: POP
43812: POP
// end ;
43813: LD_VAR 0 10
43817: RET
// export function WantHeal ( sci , unit ) ; begin
43818: LD_INT 0
43820: PPUSH
// if GetTaskList ( sci ) > 0 then
43821: NOP4
43825: PPUSH
43826: NOP4
43830: PUSH
43831: LD_INT 0
43833: GREATER
43834: IFFALSE 43904
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43836: NOP4
43840: PPUSH
43841: NOP4
43845: PUSH
43846: LD_INT 1
43848: ARRAY
43849: PUSH
43850: LD_INT 1
43852: ARRAY
43853: PUSH
43854: LD_STRING l
43856: EQUAL
43857: PUSH
43858: NOP4
43862: PPUSH
43863: NOP4
43867: PUSH
43868: LD_INT 1
43870: ARRAY
43871: PUSH
43872: LD_INT 4
43874: ARRAY
43875: PUSH
43876: NOP4
43880: EQUAL
43881: AND
43882: IFFALSE 43894
// result := true else
43884: NOP4
43888: PUSH
43889: LD_INT 1
43891: ST_TO_ADDR
43892: GO 43902
// result := false ;
43894: NOP4
43898: PUSH
43899: LD_INT 0
43901: ST_TO_ADDR
// end else
43902: GO 43912
// result := false ;
43904: NOP4
43908: PUSH
43909: LD_INT 0
43911: ST_TO_ADDR
// end ;
43912: LD_VAR 0 3
43916: RET
// export function HealTarget ( sci ) ; begin
43917: LD_INT 0
43919: PPUSH
// if not sci then
43920: NOP4
43924: NOT
43925: IFFALSE 43929
// exit ;
43927: GO 43994
// result := 0 ;
43929: NOP4
43933: PUSH
43934: LD_INT 0
43936: ST_TO_ADDR
// if GetTaskList ( sci ) then
43937: NOP4
43941: PPUSH
43942: NOP4
43946: IFFALSE 43994
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43948: NOP4
43952: PPUSH
43953: NOP4
43957: PUSH
43958: LD_INT 1
43960: ARRAY
43961: PUSH
43962: LD_INT 1
43964: ARRAY
43965: PUSH
43966: LD_STRING l
43968: EQUAL
43969: IFFALSE 43994
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43971: NOP4
43975: PUSH
43976: NOP4
43980: PPUSH
43981: NOP4
43985: PUSH
43986: LD_INT 1
43988: ARRAY
43989: PUSH
43990: LD_INT 4
43992: ARRAY
43993: ST_TO_ADDR
// end ;
43994: LD_VAR 0 2
43998: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43999: LD_INT 0
44001: PPUSH
44002: PPUSH
44003: PPUSH
44004: PPUSH
// if not base_units then
44005: NOP4
44009: NOT
44010: IFFALSE 44014
// exit ;
44012: GO 44101
// result := false ;
44014: NOP4
44018: PUSH
44019: LD_INT 0
44021: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44022: NOP4
44026: PUSH
44027: NOP4
44031: PPUSH
44032: LD_INT 21
44034: PUSH
44035: LD_INT 3
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PPUSH
44042: NOP4
44046: ST_TO_ADDR
// if not tmp then
44047: NOP4
44051: NOT
44052: IFFALSE 44056
// exit ;
44054: GO 44101
// for i in tmp do
44056: NOP4
44060: PUSH
44061: NOP4
44065: PUSH
44066: FOR_IN
44067: IFFALSE 44099
// begin result := EnemyInRange ( i , 22 ) ;
44069: NOP4
44073: PUSH
44074: NOP4
44078: PPUSH
44079: LD_INT 22
44081: PPUSH
44082: NOP4
44086: ST_TO_ADDR
// if result then
44087: NOP4
44091: IFFALSE 44097
// exit ;
44093: POP
44094: POP
44095: GO 44101
// end ;
44097: GO 44066
44099: POP
44100: POP
// end ;
44101: LD_VAR 0 2
44105: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
44106: LD_INT 0
44108: PPUSH
44109: PPUSH
// if not units then
44110: NOP4
44114: NOT
44115: IFFALSE 44119
// exit ;
44117: GO 44189
// result := [ ] ;
44119: NOP4
44123: PUSH
44124: EMPTY
44125: ST_TO_ADDR
// for i in units do
44126: NOP4
44130: PUSH
44131: NOP4
44135: PUSH
44136: FOR_IN
44137: IFFALSE 44187
// if GetTag ( i ) = tag then
44139: NOP4
44143: PPUSH
44144: NOP4
44148: PUSH
44149: NOP4
44153: EQUAL
44154: IFFALSE 44185
// result := Replace ( result , result + 1 , i ) ;
44156: NOP4
44160: PUSH
44161: NOP4
44165: PPUSH
44166: NOP4
44170: PUSH
44171: LD_INT 1
44173: PLUS
44174: PPUSH
44175: NOP4
44179: PPUSH
44180: NOP4
44184: ST_TO_ADDR
44185: GO 44136
44187: POP
44188: POP
// end ;
44189: LD_VAR 0 3
44193: RET
// export function IsDriver ( un ) ; begin
44194: LD_INT 0
44196: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
44197: NOP4
44201: PUSH
44202: NOP4
44206: PUSH
44207: LD_INT 55
44209: PUSH
44210: EMPTY
44211: LIST
44212: PPUSH
44213: NOP4
44217: IN
44218: ST_TO_ADDR
// end ;
44219: LD_VAR 0 2
44223: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
44224: LD_INT 0
44226: PPUSH
44227: PPUSH
// list := [ ] ;
44228: NOP4
44232: PUSH
44233: EMPTY
44234: ST_TO_ADDR
// case d of 0 :
44235: NOP4
44239: PUSH
44240: LD_INT 0
44242: DOUBLE
44243: EQUAL
44244: IFTRUE 44248
44246: GO 44381
44248: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
44249: NOP4
44253: PUSH
44254: NOP4
44258: PUSH
44259: LD_INT 4
44261: MINUS
44262: PUSH
44263: NOP4
44267: PUSH
44268: LD_INT 4
44270: MINUS
44271: PUSH
44272: LD_INT 2
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: LIST
44279: PUSH
44280: NOP4
44284: PUSH
44285: LD_INT 3
44287: MINUS
44288: PUSH
44289: NOP4
44293: PUSH
44294: LD_INT 1
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: LIST
44301: PUSH
44302: NOP4
44306: PUSH
44307: LD_INT 4
44309: PLUS
44310: PUSH
44311: NOP4
44315: PUSH
44316: LD_INT 4
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: LIST
44323: PUSH
44324: NOP4
44328: PUSH
44329: LD_INT 3
44331: PLUS
44332: PUSH
44333: NOP4
44337: PUSH
44338: LD_INT 3
44340: PLUS
44341: PUSH
44342: LD_INT 5
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: LIST
44349: PUSH
44350: NOP4
44354: PUSH
44355: NOP4
44359: PUSH
44360: LD_INT 4
44362: PLUS
44363: PUSH
44364: LD_INT 0
44366: PUSH
44367: EMPTY
44368: LIST
44369: LIST
44370: LIST
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: ST_TO_ADDR
// end ; 1 :
44379: GO 45079
44381: LD_INT 1
44383: DOUBLE
44384: EQUAL
44385: IFTRUE 44389
44387: GO 44522
44389: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
44390: NOP4
44394: PUSH
44395: NOP4
44399: PUSH
44400: NOP4
44404: PUSH
44405: LD_INT 4
44407: MINUS
44408: PUSH
44409: LD_INT 3
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: LIST
44416: PUSH
44417: NOP4
44421: PUSH
44422: LD_INT 3
44424: MINUS
44425: PUSH
44426: NOP4
44430: PUSH
44431: LD_INT 3
44433: MINUS
44434: PUSH
44435: LD_INT 2
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: LIST
44442: PUSH
44443: NOP4
44447: PUSH
44448: LD_INT 4
44450: MINUS
44451: PUSH
44452: NOP4
44456: PUSH
44457: LD_INT 1
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: LIST
44464: PUSH
44465: NOP4
44469: PUSH
44470: NOP4
44474: PUSH
44475: LD_INT 3
44477: PLUS
44478: PUSH
44479: LD_INT 0
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: LIST
44486: PUSH
44487: NOP4
44491: PUSH
44492: LD_INT 4
44494: PLUS
44495: PUSH
44496: NOP4
44500: PUSH
44501: LD_INT 4
44503: PLUS
44504: PUSH
44505: LD_INT 5
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: LIST
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: LIST
44517: LIST
44518: LIST
44519: ST_TO_ADDR
// end ; 2 :
44520: GO 45079
44522: LD_INT 2
44524: DOUBLE
44525: EQUAL
44526: IFTRUE 44530
44528: GO 44659
44530: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
44531: NOP4
44535: PUSH
44536: NOP4
44540: PUSH
44541: NOP4
44545: PUSH
44546: LD_INT 3
44548: MINUS
44549: PUSH
44550: LD_INT 3
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: LIST
44557: PUSH
44558: NOP4
44562: PUSH
44563: LD_INT 4
44565: PLUS
44566: PUSH
44567: NOP4
44571: PUSH
44572: LD_INT 4
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: LIST
44579: PUSH
44580: NOP4
44584: PUSH
44585: NOP4
44589: PUSH
44590: LD_INT 4
44592: PLUS
44593: PUSH
44594: LD_INT 0
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: LIST
44601: PUSH
44602: NOP4
44606: PUSH
44607: LD_INT 3
44609: MINUS
44610: PUSH
44611: NOP4
44615: PUSH
44616: LD_INT 1
44618: PUSH
44619: EMPTY
44620: LIST
44621: LIST
44622: LIST
44623: PUSH
44624: NOP4
44628: PUSH
44629: LD_INT 4
44631: MINUS
44632: PUSH
44633: NOP4
44637: PUSH
44638: LD_INT 4
44640: MINUS
44641: PUSH
44642: LD_INT 2
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: LIST
44649: PUSH
44650: EMPTY
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: ST_TO_ADDR
// end ; 3 :
44657: GO 45079
44659: LD_INT 3
44661: DOUBLE
44662: EQUAL
44663: IFTRUE 44667
44665: GO 44800
44667: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
44668: NOP4
44672: PUSH
44673: NOP4
44677: PUSH
44678: LD_INT 3
44680: PLUS
44681: PUSH
44682: NOP4
44686: PUSH
44687: LD_INT 4
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: LIST
44694: PUSH
44695: NOP4
44699: PUSH
44700: LD_INT 4
44702: PLUS
44703: PUSH
44704: NOP4
44708: PUSH
44709: LD_INT 4
44711: PLUS
44712: PUSH
44713: LD_INT 5
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: LIST
44720: PUSH
44721: NOP4
44725: PUSH
44726: LD_INT 4
44728: MINUS
44729: PUSH
44730: NOP4
44734: PUSH
44735: LD_INT 1
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: LIST
44742: PUSH
44743: NOP4
44747: PUSH
44748: NOP4
44752: PUSH
44753: LD_INT 4
44755: MINUS
44756: PUSH
44757: LD_INT 3
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: LIST
44764: PUSH
44765: NOP4
44769: PUSH
44770: LD_INT 3
44772: MINUS
44773: PUSH
44774: NOP4
44778: PUSH
44779: LD_INT 3
44781: MINUS
44782: PUSH
44783: LD_INT 2
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: LIST
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: ST_TO_ADDR
// end ; 4 :
44798: GO 45079
44800: LD_INT 4
44802: DOUBLE
44803: EQUAL
44804: IFTRUE 44808
44806: GO 44941
44808: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44809: NOP4
44813: PUSH
44814: NOP4
44818: PUSH
44819: NOP4
44823: PUSH
44824: LD_INT 4
44826: PLUS
44827: PUSH
44828: LD_INT 0
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: LIST
44835: PUSH
44836: NOP4
44840: PUSH
44841: LD_INT 3
44843: PLUS
44844: PUSH
44845: NOP4
44849: PUSH
44850: LD_INT 3
44852: PLUS
44853: PUSH
44854: LD_INT 5
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: LIST
44861: PUSH
44862: NOP4
44866: PUSH
44867: LD_INT 4
44869: PLUS
44870: PUSH
44871: NOP4
44875: PUSH
44876: LD_INT 4
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: LIST
44883: PUSH
44884: NOP4
44888: PUSH
44889: NOP4
44893: PUSH
44894: LD_INT 3
44896: MINUS
44897: PUSH
44898: LD_INT 3
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: LIST
44905: PUSH
44906: NOP4
44910: PUSH
44911: LD_INT 4
44913: MINUS
44914: PUSH
44915: NOP4
44919: PUSH
44920: LD_INT 4
44922: MINUS
44923: PUSH
44924: LD_INT 2
44926: PUSH
44927: EMPTY
44928: LIST
44929: LIST
44930: LIST
44931: PUSH
44932: EMPTY
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: ST_TO_ADDR
// end ; 5 :
44939: GO 45079
44941: LD_INT 5
44943: DOUBLE
44944: EQUAL
44945: IFTRUE 44949
44947: GO 45078
44949: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44950: NOP4
44954: PUSH
44955: NOP4
44959: PUSH
44960: LD_INT 4
44962: MINUS
44963: PUSH
44964: NOP4
44968: PUSH
44969: LD_INT 1
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: LIST
44976: PUSH
44977: NOP4
44981: PUSH
44982: NOP4
44986: PUSH
44987: LD_INT 4
44989: MINUS
44990: PUSH
44991: LD_INT 3
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: LIST
44998: PUSH
44999: NOP4
45003: PUSH
45004: LD_INT 4
45006: PLUS
45007: PUSH
45008: NOP4
45012: PUSH
45013: LD_INT 4
45015: PLUS
45016: PUSH
45017: LD_INT 5
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: LIST
45024: PUSH
45025: NOP4
45029: PUSH
45030: LD_INT 3
45032: PLUS
45033: PUSH
45034: NOP4
45038: PUSH
45039: LD_INT 4
45041: PUSH
45042: EMPTY
45043: LIST
45044: LIST
45045: LIST
45046: PUSH
45047: NOP4
45051: PUSH
45052: NOP4
45056: PUSH
45057: LD_INT 3
45059: PLUS
45060: PUSH
45061: LD_INT 0
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: LIST
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: ST_TO_ADDR
// end ; end ;
45076: GO 45079
45078: POP
// result := list ;
45079: NOP4
45083: PUSH
45084: NOP4
45088: ST_TO_ADDR
// end ;
45089: LD_VAR 0 4
45093: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45094: LD_INT 0
45096: PPUSH
45097: PPUSH
45098: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45099: NOP4
45103: NOT
45104: PUSH
45105: NOP4
45109: PUSH
45110: LD_INT 1
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: LD_INT 3
45118: PUSH
45119: LD_INT 4
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: IN
45128: NOT
45129: OR
45130: IFFALSE 45134
// exit ;
45132: GO 45226
// tmp := [ ] ;
45134: NOP4
45138: PUSH
45139: EMPTY
45140: ST_TO_ADDR
// for i in units do
45141: NOP4
45145: PUSH
45146: NOP4
45150: PUSH
45151: FOR_IN
45152: IFFALSE 45195
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
45154: NOP4
45158: PUSH
45159: NOP4
45163: PPUSH
45164: NOP4
45168: PUSH
45169: LD_INT 1
45171: PLUS
45172: PPUSH
45173: NOP4
45177: PPUSH
45178: NOP4
45182: PPUSH
45183: NOP4
45187: PPUSH
45188: NOP4
45192: ST_TO_ADDR
45193: GO 45151
45195: POP
45196: POP
// if not tmp then
45197: NOP4
45201: NOT
45202: IFFALSE 45206
// exit ;
45204: GO 45226
// result := SortListByListDesc ( units , tmp ) ;
45206: NOP4
45210: PUSH
45211: NOP4
45215: PPUSH
45216: NOP4
45220: PPUSH
45221: NOP4
45225: ST_TO_ADDR
// end ;
45226: LD_VAR 0 3
45230: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
45231: LD_INT 0
45233: PPUSH
45234: PPUSH
45235: PPUSH
// result := false ;
45236: NOP4
45240: PUSH
45241: LD_INT 0
45243: ST_TO_ADDR
// x := GetX ( building ) ;
45244: NOP4
45248: PUSH
45249: NOP4
45253: PPUSH
45254: NOP4
45258: ST_TO_ADDR
// y := GetY ( building ) ;
45259: NOP4
45263: PUSH
45264: NOP4
45268: PPUSH
45269: NOP4
45273: ST_TO_ADDR
// if not building or not x or not y then
45274: NOP4
45278: NOT
45279: PUSH
45280: NOP4
45284: NOT
45285: OR
45286: PUSH
45287: NOP4
45291: NOT
45292: OR
45293: IFFALSE 45297
// exit ;
45295: GO 45389
// if GetTaskList ( unit ) then
45297: NOP4
45301: PPUSH
45302: NOP4
45306: IFFALSE 45389
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45308: LD_STRING e
45310: PUSH
45311: NOP4
45315: PPUSH
45316: NOP4
45320: PUSH
45321: LD_INT 1
45323: ARRAY
45324: PUSH
45325: LD_INT 1
45327: ARRAY
45328: EQUAL
45329: PUSH
45330: NOP4
45334: PUSH
45335: NOP4
45339: PPUSH
45340: NOP4
45344: PUSH
45345: LD_INT 1
45347: ARRAY
45348: PUSH
45349: LD_INT 2
45351: ARRAY
45352: EQUAL
45353: AND
45354: PUSH
45355: NOP4
45359: PUSH
45360: NOP4
45364: PPUSH
45365: NOP4
45369: PUSH
45370: LD_INT 1
45372: ARRAY
45373: PUSH
45374: LD_INT 3
45376: ARRAY
45377: EQUAL
45378: AND
45379: IFFALSE 45389
// result := true end ;
45381: NOP4
45385: PUSH
45386: LD_INT 1
45388: ST_TO_ADDR
// end ;
45389: LD_VAR 0 3
45393: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
45394: LD_INT 0
45396: PPUSH
// result := false ;
45397: NOP4
45401: PUSH
45402: LD_INT 0
45404: ST_TO_ADDR
// if GetTaskList ( unit ) then
45405: NOP4
45409: PPUSH
45410: NOP4
45414: IFFALSE 45497
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45416: LD_STRING M
45418: PUSH
45419: NOP4
45423: PPUSH
45424: NOP4
45428: PUSH
45429: LD_INT 1
45431: ARRAY
45432: PUSH
45433: LD_INT 1
45435: ARRAY
45436: EQUAL
45437: PUSH
45438: NOP4
45442: PUSH
45443: NOP4
45447: PPUSH
45448: NOP4
45452: PUSH
45453: LD_INT 1
45455: ARRAY
45456: PUSH
45457: LD_INT 2
45459: ARRAY
45460: EQUAL
45461: AND
45462: PUSH
45463: NOP4
45467: PUSH
45468: NOP4
45472: PPUSH
45473: NOP4
45477: PUSH
45478: LD_INT 1
45480: ARRAY
45481: PUSH
45482: LD_INT 3
45484: ARRAY
45485: EQUAL
45486: AND
45487: IFFALSE 45497
// result := true ;
45489: NOP4
45493: PUSH
45494: LD_INT 1
45496: ST_TO_ADDR
// end ; end ;
45497: LD_VAR 0 4
45501: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
45502: LD_INT 0
45504: PPUSH
45505: PPUSH
45506: PPUSH
45507: PPUSH
// if not unit or not area then
45508: NOP4
45512: NOT
45513: PUSH
45514: NOP4
45518: NOT
45519: OR
45520: IFFALSE 45524
// exit ;
45522: GO 45688
// tmp := AreaToList ( area , i ) ;
45524: NOP4
45528: PUSH
45529: NOP4
45533: PPUSH
45534: NOP4
45538: PPUSH
45539: NOP4
45543: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
45544: NOP4
45548: PUSH
45549: DOUBLE
45550: LD_INT 1
45552: DEC
45553: ST_TO_ADDR
45554: NOP4
45558: PUSH
45559: LD_INT 1
45561: ARRAY
45562: PUSH
45563: FOR_TO
45564: IFFALSE 45686
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
45566: NOP4
45570: PUSH
45571: NOP4
45575: PUSH
45576: LD_INT 1
45578: ARRAY
45579: PUSH
45580: NOP4
45584: ARRAY
45585: PUSH
45586: NOP4
45590: PUSH
45591: LD_INT 2
45593: ARRAY
45594: PUSH
45595: NOP4
45599: ARRAY
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
45605: NOP4
45609: PUSH
45610: LD_INT 1
45612: ARRAY
45613: PPUSH
45614: NOP4
45618: PUSH
45619: LD_INT 2
45621: ARRAY
45622: PPUSH
45623: NOP4
45627: PUSH
45628: LD_INT 0
45630: EQUAL
45631: IFFALSE 45684
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
45633: NOP4
45637: PPUSH
45638: NOP4
45642: PUSH
45643: LD_INT 1
45645: ARRAY
45646: PPUSH
45647: NOP4
45651: PUSH
45652: LD_INT 2
45654: ARRAY
45655: PPUSH
45656: NOP4
45660: PPUSH
45661: NOP4
// result := IsPlaced ( unit ) ;
45665: NOP4
45669: PUSH
45670: NOP4
45674: PPUSH
45675: NOP4
45679: ST_TO_ADDR
// exit ;
45680: POP
45681: POP
45682: GO 45688
// end ; end ;
45684: GO 45563
45686: POP
45687: POP
// end ;
45688: LD_VAR 0 4
45692: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
45693: LD_INT 0
45695: PPUSH
45696: PPUSH
45697: PPUSH
// if not side or side > 8 then
45698: NOP4
45702: NOT
45703: PUSH
45704: NOP4
45708: PUSH
45709: LD_INT 8
45711: GREATER
45712: OR
45713: IFFALSE 45717
// exit ;
45715: GO 45904
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
45717: NOP4
45721: PUSH
45722: LD_INT 22
45724: PUSH
45725: NOP4
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PUSH
45734: LD_INT 21
45736: PUSH
45737: LD_INT 3
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: EMPTY
45745: LIST
45746: LIST
45747: PPUSH
45748: NOP4
45752: ST_TO_ADDR
// if not tmp then
45753: NOP4
45757: NOT
45758: IFFALSE 45762
// exit ;
45760: GO 45904
// enable_addtolog := true ;
45762: LD_ADDR_OWVAR 81
45766: PUSH
45767: LD_INT 1
45769: ST_TO_ADDR
// AddToLog ( [ ) ;
45770: LD_STRING [
45772: PPUSH
45773: NOP4
// for i in tmp do
45777: NOP4
45781: PUSH
45782: NOP4
45786: PUSH
45787: FOR_IN
45788: IFFALSE 45895
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45790: LD_STRING [
45792: PUSH
45793: NOP4
45797: PPUSH
45798: NOP4
45802: STR
45803: PUSH
45804: LD_STRING , 
45806: STR
45807: PUSH
45808: NOP4
45812: PPUSH
45813: NOP4
45817: STR
45818: PUSH
45819: LD_STRING , 
45821: STR
45822: PUSH
45823: NOP4
45827: PPUSH
45828: NOP4
45832: STR
45833: PUSH
45834: LD_STRING , 
45836: STR
45837: PUSH
45838: NOP4
45842: PPUSH
45843: NOP4
45847: STR
45848: PUSH
45849: LD_STRING , 
45851: STR
45852: PUSH
45853: NOP4
45857: PPUSH
45858: LD_INT 1
45860: PPUSH
45861: NOP4
45865: STR
45866: PUSH
45867: LD_STRING , 
45869: STR
45870: PUSH
45871: NOP4
45875: PPUSH
45876: LD_INT 2
45878: PPUSH
45879: NOP4
45883: STR
45884: PUSH
45885: LD_STRING ],
45887: STR
45888: PPUSH
45889: NOP4
// end ;
45893: GO 45787
45895: POP
45896: POP
// AddToLog ( ]; ) ;
45897: LD_STRING ];
45899: PPUSH
45900: NOP4
// end ;
45904: LD_VAR 0 2
45908: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45909: LD_INT 0
45911: PPUSH
45912: PPUSH
45913: PPUSH
45914: PPUSH
45915: PPUSH
// if not area or not rate or not max then
45916: NOP4
45920: NOT
45921: PUSH
45922: NOP4
45926: NOT
45927: OR
45928: PUSH
45929: NOP4
45933: NOT
45934: OR
45935: IFFALSE 45939
// exit ;
45937: GO 46131
// while 1 do
45939: LD_INT 1
45941: IFFALSE 46131
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45943: NOP4
45947: PUSH
45948: NOP4
45952: PPUSH
45953: LD_INT 1
45955: PPUSH
45956: NOP4
45960: PUSH
45961: LD_INT 10
45963: MUL
45964: ST_TO_ADDR
// r := rate / 10 ;
45965: NOP4
45969: PUSH
45970: NOP4
45974: PUSH
45975: LD_INT 10
45977: DIVREAL
45978: ST_TO_ADDR
// time := 1 1$00 ;
45979: NOP4
45983: PUSH
45984: LD_INT 2100
45986: ST_TO_ADDR
// if amount < min then
45987: NOP4
45991: PUSH
45992: NOP4
45996: LESS
45997: IFFALSE 46015
// r := r * 2 else
45999: NOP4
46003: PUSH
46004: NOP4
46008: PUSH
46009: LD_INT 2
46011: MUL
46012: ST_TO_ADDR
46013: GO 46041
// if amount > max then
46015: NOP4
46019: PUSH
46020: NOP4
46024: GREATER
46025: IFFALSE 46041
// r := r / 2 ;
46027: NOP4
46031: PUSH
46032: NOP4
46036: PUSH
46037: LD_INT 2
46039: DIVREAL
46040: ST_TO_ADDR
// time := time / r ;
46041: NOP4
46045: PUSH
46046: NOP4
46050: PUSH
46051: NOP4
46055: DIVREAL
46056: ST_TO_ADDR
// if time < 0 then
46057: NOP4
46061: PUSH
46062: LD_INT 0
46064: LESS
46065: IFFALSE 46082
// time := time * - 1 ;
46067: NOP4
46071: PUSH
46072: NOP4
46076: PUSH
46077: LD_INT 1
46079: NEG
46080: MUL
46081: ST_TO_ADDR
// wait ( time ) ;
46082: NOP4
46086: PPUSH
46087: NOP4
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
46091: LD_INT 35
46093: PPUSH
46094: LD_INT 875
46096: PPUSH
46097: NOP4
46101: PPUSH
46102: NOP4
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46106: LD_INT 1
46108: PPUSH
46109: LD_INT 5
46111: PPUSH
46112: NOP4
46116: PPUSH
46117: NOP4
46121: PPUSH
46122: LD_INT 1
46124: PPUSH
46125: NOP4
// end ;
46129: GO 45939
// end ;
46131: LD_VAR 0 5
46135: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
46136: LD_INT 0
46138: PPUSH
46139: PPUSH
46140: PPUSH
46141: PPUSH
46142: PPUSH
46143: PPUSH
46144: PPUSH
46145: PPUSH
// if not turrets or not factories then
46146: NOP4
46150: NOT
46151: PUSH
46152: NOP4
46156: NOT
46157: OR
46158: IFFALSE 46162
// exit ;
46160: GO 46469
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
46162: NOP4
46166: PUSH
46167: LD_INT 5
46169: PUSH
46170: LD_INT 6
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: PUSH
46177: LD_INT 2
46179: PUSH
46180: LD_INT 4
46182: PUSH
46183: EMPTY
46184: LIST
46185: LIST
46186: PUSH
46187: LD_INT 3
46189: PUSH
46190: LD_INT 5
46192: PUSH
46193: EMPTY
46194: LIST
46195: LIST
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 24
46204: PUSH
46205: LD_INT 25
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: PUSH
46212: LD_INT 23
46214: PUSH
46215: LD_INT 27
46217: PUSH
46218: EMPTY
46219: LIST
46220: LIST
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: PUSH
46226: LD_INT 42
46228: PUSH
46229: LD_INT 43
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 44
46238: PUSH
46239: LD_INT 46
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 45
46248: PUSH
46249: LD_INT 47
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: EMPTY
46257: LIST
46258: LIST
46259: LIST
46260: PUSH
46261: EMPTY
46262: LIST
46263: LIST
46264: LIST
46265: ST_TO_ADDR
// result := [ ] ;
46266: NOP4
46270: PUSH
46271: EMPTY
46272: ST_TO_ADDR
// for i in turrets do
46273: NOP4
46277: PUSH
46278: NOP4
46282: PUSH
46283: FOR_IN
46284: IFFALSE 46467
// begin nat := GetNation ( i ) ;
46286: NOP4
46290: PUSH
46291: NOP4
46295: PPUSH
46296: NOP4
46300: ST_TO_ADDR
// weapon := 0 ;
46301: NOP4
46305: PUSH
46306: LD_INT 0
46308: ST_TO_ADDR
// if not nat then
46309: NOP4
46313: NOT
46314: IFFALSE 46318
// continue ;
46316: GO 46283
// for j in list [ nat ] do
46318: NOP4
46322: PUSH
46323: NOP4
46327: PUSH
46328: NOP4
46332: ARRAY
46333: PUSH
46334: FOR_IN
46335: IFFALSE 46376
// if GetBWeapon ( i ) = j [ 1 ] then
46337: NOP4
46341: PPUSH
46342: NOP4
46346: PUSH
46347: NOP4
46351: PUSH
46352: LD_INT 1
46354: ARRAY
46355: EQUAL
46356: IFFALSE 46374
// begin weapon := j [ 2 ] ;
46358: NOP4
46362: PUSH
46363: NOP4
46367: PUSH
46368: LD_INT 2
46370: ARRAY
46371: ST_TO_ADDR
// break ;
46372: GO 46376
// end ;
46374: GO 46334
46376: POP
46377: POP
// if not weapon then
46378: NOP4
46382: NOT
46383: IFFALSE 46387
// continue ;
46385: GO 46283
// for k in factories do
46387: NOP4
46391: PUSH
46392: NOP4
46396: PUSH
46397: FOR_IN
46398: IFFALSE 46463
// begin weapons := AvailableWeaponList ( k ) ;
46400: NOP4
46404: PUSH
46405: NOP4
46409: PPUSH
46410: NOP4
46414: ST_TO_ADDR
// if not weapons then
46415: NOP4
46419: NOT
46420: IFFALSE 46424
// continue ;
46422: GO 46397
// if weapon in weapons then
46424: NOP4
46428: PUSH
46429: NOP4
46433: IN
46434: IFFALSE 46461
// begin result := [ i , weapon ] ;
46436: NOP4
46440: PUSH
46441: NOP4
46445: PUSH
46446: NOP4
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: ST_TO_ADDR
// exit ;
46455: POP
46456: POP
46457: POP
46458: POP
46459: GO 46469
// end ; end ;
46461: GO 46397
46463: POP
46464: POP
// end ;
46465: GO 46283
46467: POP
46468: POP
// end ;
46469: LD_VAR 0 3
46473: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
46474: LD_INT 0
46476: PPUSH
// if not side or side > 8 then
46477: NOP4
46481: NOT
46482: PUSH
46483: NOP4
46487: PUSH
46488: LD_INT 8
46490: GREATER
46491: OR
46492: IFFALSE 46496
// exit ;
46494: GO 46555
// if not range then
46496: NOP4
46500: NOT
46501: IFFALSE 46512
// range := - 12 ;
46503: NOP4
46507: PUSH
46508: LD_INT 12
46510: NEG
46511: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
46512: NOP4
46516: PPUSH
46517: NOP4
46521: PPUSH
46522: NOP4
46526: PPUSH
46527: NOP4
46531: PPUSH
46532: NOP4
// RemoveSeeing ( x , y , side ) ;
46536: NOP4
46540: PPUSH
46541: NOP4
46545: PPUSH
46546: NOP4
46550: PPUSH
46551: NOP4
// end ;
46555: LD_VAR 0 5
46559: RET
// export function Video ( mode ) ; begin
46560: LD_INT 0
46562: PPUSH
// ingame_video = mode ;
46563: LD_ADDR_OWVAR 52
46567: PUSH
46568: NOP4
46572: ST_TO_ADDR
// interface_hidden = mode ;
46573: LD_ADDR_OWVAR 54
46577: PUSH
46578: NOP4
46582: ST_TO_ADDR
// end ;
46583: LD_VAR 0 2
46587: RET
// export function Join ( array , element ) ; begin
46588: LD_INT 0
46590: PPUSH
// result := Replace ( array , array + 1 , element ) ;
46591: NOP4
46595: PUSH
46596: NOP4
46600: PPUSH
46601: NOP4
46605: PUSH
46606: LD_INT 1
46608: PLUS
46609: PPUSH
46610: NOP4
46614: PPUSH
46615: NOP4
46619: ST_TO_ADDR
// end ;
46620: LD_VAR 0 3
46624: RET
// export function JoinUnion ( array , element ) ; begin
46625: LD_INT 0
46627: PPUSH
// result := array union element ;
46628: NOP4
46632: PUSH
46633: NOP4
46637: PUSH
46638: NOP4
46642: UNION
46643: ST_TO_ADDR
// end ;
46644: LD_VAR 0 3
46648: RET
// export function GetBehemoths ( side ) ; begin
46649: LD_INT 0
46651: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
46652: NOP4
46656: PUSH
46657: LD_INT 22
46659: PUSH
46660: NOP4
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: PUSH
46669: LD_INT 31
46671: PUSH
46672: LD_INT 25
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: PUSH
46679: EMPTY
46680: LIST
46681: LIST
46682: PPUSH
46683: NOP4
46687: ST_TO_ADDR
// end ;
46688: LD_VAR 0 2
46692: RET
// export function Shuffle ( array ) ; var i , index ; begin
46693: LD_INT 0
46695: PPUSH
46696: PPUSH
46697: PPUSH
// result := [ ] ;
46698: NOP4
46702: PUSH
46703: EMPTY
46704: ST_TO_ADDR
// if not array then
46705: NOP4
46709: NOT
46710: IFFALSE 46714
// exit ;
46712: GO 46813
// Randomize ;
46714: NOP4
// for i = array downto 1 do
46718: NOP4
46722: PUSH
46723: DOUBLE
46724: NOP4
46728: INC
46729: ST_TO_ADDR
46730: LD_INT 1
46732: PUSH
46733: FOR_DOWNTO
46734: IFFALSE 46811
// begin index := rand ( 1 , array ) ;
46736: NOP4
46740: PUSH
46741: LD_INT 1
46743: PPUSH
46744: NOP4
46748: PPUSH
46749: NOP4
46753: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46754: NOP4
46758: PUSH
46759: NOP4
46763: PPUSH
46764: NOP4
46768: PUSH
46769: LD_INT 1
46771: PLUS
46772: PPUSH
46773: NOP4
46777: PUSH
46778: NOP4
46782: ARRAY
46783: PPUSH
46784: NOP4
46788: ST_TO_ADDR
// array := Delete ( array , index ) ;
46789: NOP4
46793: PUSH
46794: NOP4
46798: PPUSH
46799: NOP4
46803: PPUSH
46804: NOP4
46808: ST_TO_ADDR
// end ;
46809: GO 46733
46811: POP
46812: POP
// end ;
46813: LD_VAR 0 2
46817: RET
// export function GetBaseMaterials ( base ) ; begin
46818: LD_INT 0
46820: PPUSH
// result := [ 0 , 0 , 0 ] ;
46821: NOP4
46825: PUSH
46826: LD_INT 0
46828: PUSH
46829: LD_INT 0
46831: PUSH
46832: LD_INT 0
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: LIST
46839: ST_TO_ADDR
// if not base then
46840: NOP4
46844: NOT
46845: IFFALSE 46849
// exit ;
46847: GO 46898
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46849: NOP4
46853: PUSH
46854: NOP4
46858: PPUSH
46859: LD_INT 1
46861: PPUSH
46862: NOP4
46866: PUSH
46867: NOP4
46871: PPUSH
46872: LD_INT 2
46874: PPUSH
46875: NOP4
46879: PUSH
46880: NOP4
46884: PPUSH
46885: LD_INT 3
46887: PPUSH
46888: NOP4
46892: PUSH
46893: EMPTY
46894: LIST
46895: LIST
46896: LIST
46897: ST_TO_ADDR
// end ;
46898: LD_VAR 0 2
46902: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46903: LD_INT 0
46905: PPUSH
46906: PPUSH
// result := array ;
46907: NOP4
46911: PUSH
46912: NOP4
46916: ST_TO_ADDR
// if size > 0 then
46917: NOP4
46921: PUSH
46922: LD_INT 0
46924: GREATER
46925: IFFALSE 46971
// for i := array downto size do
46927: NOP4
46931: PUSH
46932: DOUBLE
46933: NOP4
46937: INC
46938: ST_TO_ADDR
46939: NOP4
46943: PUSH
46944: FOR_DOWNTO
46945: IFFALSE 46969
// result := Delete ( result , result ) ;
46947: NOP4
46951: PUSH
46952: NOP4
46956: PPUSH
46957: NOP4
46961: PPUSH
46962: NOP4
46966: ST_TO_ADDR
46967: GO 46944
46969: POP
46970: POP
// end ;
46971: LD_VAR 0 3
46975: RET
// export function ComExit ( unit ) ; var tmp ; begin
46976: LD_INT 0
46978: PPUSH
46979: PPUSH
// if not IsInUnit ( unit ) then
46980: NOP4
46984: PPUSH
46985: NOP4
46989: NOT
46990: IFFALSE 46994
// exit ;
46992: GO 47054
// tmp := IsInUnit ( unit ) ;
46994: NOP4
46998: PUSH
46999: NOP4
47003: PPUSH
47004: NOP4
47008: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47009: NOP4
47013: PPUSH
47014: NOP4
47018: PUSH
47019: LD_INT 2
47021: EQUAL
47022: IFFALSE 47035
// ComExitVehicle ( unit ) else
47024: NOP4
47028: PPUSH
47029: NOP4
47033: GO 47044
// ComExitBuilding ( unit ) ;
47035: NOP4
47039: PPUSH
47040: NOP4
// result := tmp ;
47044: NOP4
47048: PUSH
47049: NOP4
47053: ST_TO_ADDR
// end ;
47054: LD_VAR 0 2
47058: RET
// export function ComExitAll ( units ) ; var i ; begin
47059: LD_INT 0
47061: PPUSH
47062: PPUSH
// if not units then
47063: NOP4
47067: NOT
47068: IFFALSE 47072
// exit ;
47070: GO 47098
// for i in units do
47072: NOP4
47076: PUSH
47077: NOP4
47081: PUSH
47082: FOR_IN
47083: IFFALSE 47096
// ComExit ( i ) ;
47085: NOP4
47089: PPUSH
47090: NOP4
47094: GO 47082
47096: POP
47097: POP
// end ;
47098: LD_VAR 0 2
47102: RET
// export function ResetHc ; begin
47103: LD_INT 0
47105: PPUSH
// InitHc ;
47106: NOP4
// hc_importance := 0 ;
47110: LD_ADDR_OWVAR 32
47114: PUSH
47115: LD_INT 0
47117: ST_TO_ADDR
// end ;
47118: LD_VAR 0 1
47122: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47123: LD_INT 0
47125: PPUSH
47126: PPUSH
47127: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47128: NOP4
47132: PUSH
47133: NOP4
47137: PUSH
47138: NOP4
47142: PLUS
47143: PUSH
47144: LD_INT 2
47146: DIV
47147: ST_TO_ADDR
// if _x < 0 then
47148: NOP4
47152: PUSH
47153: LD_INT 0
47155: LESS
47156: IFFALSE 47173
// _x := _x * - 1 ;
47158: NOP4
47162: PUSH
47163: NOP4
47167: PUSH
47168: LD_INT 1
47170: NEG
47171: MUL
47172: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
47173: NOP4
47177: PUSH
47178: NOP4
47182: PUSH
47183: NOP4
47187: PLUS
47188: PUSH
47189: LD_INT 2
47191: DIV
47192: ST_TO_ADDR
// if _y < 0 then
47193: NOP4
47197: PUSH
47198: LD_INT 0
47200: LESS
47201: IFFALSE 47218
// _y := _y * - 1 ;
47203: NOP4
47207: PUSH
47208: NOP4
47212: PUSH
47213: LD_INT 1
47215: NEG
47216: MUL
47217: ST_TO_ADDR
// result := [ _x , _y ] ;
47218: NOP4
47222: PUSH
47223: NOP4
47227: PUSH
47228: NOP4
47232: PUSH
47233: EMPTY
47234: LIST
47235: LIST
47236: ST_TO_ADDR
// end ;
47237: LD_VAR 0 5
47241: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
47242: LD_INT 0
47244: PPUSH
47245: PPUSH
47246: PPUSH
47247: PPUSH
// task := GetTaskList ( unit ) ;
47248: NOP4
47252: PUSH
47253: NOP4
47257: PPUSH
47258: NOP4
47262: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
47263: NOP4
47267: NOT
47268: PUSH
47269: NOP4
47273: PPUSH
47274: NOP4
47278: PPUSH
47279: NOP4
47283: NOT
47284: AND
47285: IFFALSE 47289
// exit ;
47287: GO 47407
// if IsInArea ( unit , area ) then
47289: NOP4
47293: PPUSH
47294: NOP4
47298: PPUSH
47299: NOP4
47303: IFFALSE 47321
// begin ComMoveToArea ( unit , goAway ) ;
47305: NOP4
47309: PPUSH
47310: NOP4
47314: PPUSH
47315: NOP4
// exit ;
47319: GO 47407
// end ; if task [ 1 ] [ 1 ] <> M then
47321: NOP4
47325: PUSH
47326: LD_INT 1
47328: ARRAY
47329: PUSH
47330: LD_INT 1
47332: ARRAY
47333: PUSH
47334: LD_STRING M
47336: NONEQUAL
47337: IFFALSE 47341
// exit ;
47339: GO 47407
// x := task [ 1 ] [ 2 ] ;
47341: NOP4
47345: PUSH
47346: NOP4
47350: PUSH
47351: LD_INT 1
47353: ARRAY
47354: PUSH
47355: LD_INT 2
47357: ARRAY
47358: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
47359: NOP4
47363: PUSH
47364: NOP4
47368: PUSH
47369: LD_INT 1
47371: ARRAY
47372: PUSH
47373: LD_INT 3
47375: ARRAY
47376: ST_TO_ADDR
// if InArea ( x , y , area ) then
47377: NOP4
47381: PPUSH
47382: NOP4
47386: PPUSH
47387: NOP4
47391: PPUSH
47392: NOP4
47396: IFFALSE 47407
// ComStop ( unit ) ;
47398: NOP4
47402: PPUSH
47403: NOP4
// end ;
47407: LD_VAR 0 4
47411: RET
// export function Abs ( value ) ; begin
47412: LD_INT 0
47414: PPUSH
// result := value ;
47415: NOP4
47419: PUSH
47420: NOP4
47424: ST_TO_ADDR
// if value < 0 then
47425: NOP4
47429: PUSH
47430: LD_INT 0
47432: LESS
47433: IFFALSE 47450
// result := value * - 1 ;
47435: NOP4
47439: PUSH
47440: NOP4
47444: PUSH
47445: LD_INT 1
47447: NEG
47448: MUL
47449: ST_TO_ADDR
// end ;
47450: LD_VAR 0 2
47454: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
47455: LD_INT 0
47457: PPUSH
47458: PPUSH
47459: PPUSH
47460: PPUSH
47461: PPUSH
47462: PPUSH
47463: PPUSH
47464: PPUSH
// if not unit or not building then
47465: NOP4
47469: NOT
47470: PUSH
47471: NOP4
47475: NOT
47476: OR
47477: IFFALSE 47481
// exit ;
47479: GO 47707
// x := GetX ( building ) ;
47481: NOP4
47485: PUSH
47486: NOP4
47490: PPUSH
47491: NOP4
47495: ST_TO_ADDR
// y := GetY ( building ) ;
47496: NOP4
47500: PUSH
47501: NOP4
47505: PPUSH
47506: NOP4
47510: ST_TO_ADDR
// d := GetDir ( building ) ;
47511: NOP4
47515: PUSH
47516: NOP4
47520: PPUSH
47521: NOP4
47525: ST_TO_ADDR
// r := 4 ;
47526: NOP4
47530: PUSH
47531: LD_INT 4
47533: ST_TO_ADDR
// for i := 1 to 5 do
47534: NOP4
47538: PUSH
47539: DOUBLE
47540: LD_INT 1
47542: DEC
47543: ST_TO_ADDR
47544: LD_INT 5
47546: PUSH
47547: FOR_TO
47548: IFFALSE 47705
// begin _x := ShiftX ( x , d , r + i ) ;
47550: NOP4
47554: PUSH
47555: NOP4
47559: PPUSH
47560: NOP4
47564: PPUSH
47565: NOP4
47569: PUSH
47570: NOP4
47574: PLUS
47575: PPUSH
47576: NOP4
47580: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
47581: NOP4
47585: PUSH
47586: NOP4
47590: PPUSH
47591: NOP4
47595: PPUSH
47596: NOP4
47600: PUSH
47601: NOP4
47605: PLUS
47606: PPUSH
47607: NOP4
47611: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
47612: NOP4
47616: PPUSH
47617: NOP4
47621: PPUSH
47622: NOP4
47626: PUSH
47627: NOP4
47631: PPUSH
47632: NOP4
47636: PPUSH
47637: NOP4
47641: PPUSH
47642: NOP4
47646: PUSH
47647: LD_INT 3
47649: PUSH
47650: LD_INT 2
47652: PUSH
47653: EMPTY
47654: LIST
47655: LIST
47656: IN
47657: NOT
47658: AND
47659: IFFALSE 47703
// begin ComMoveXY ( unit , _x , _y ) ;
47661: NOP4
47665: PPUSH
47666: NOP4
47670: PPUSH
47671: NOP4
47675: PPUSH
47676: NOP4
// result := [ _x , _y ] ;
47680: NOP4
47684: PUSH
47685: NOP4
47689: PUSH
47690: NOP4
47694: PUSH
47695: EMPTY
47696: LIST
47697: LIST
47698: ST_TO_ADDR
// exit ;
47699: POP
47700: POP
47701: GO 47707
// end ; end ;
47703: GO 47547
47705: POP
47706: POP
// end ;
47707: LD_VAR 0 3
47711: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
47712: LD_INT 0
47714: PPUSH
47715: PPUSH
47716: PPUSH
// result := 0 ;
47717: NOP4
47721: PUSH
47722: LD_INT 0
47724: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
47725: NOP4
47729: PUSH
47730: LD_INT 0
47732: LESS
47733: PUSH
47734: NOP4
47738: PUSH
47739: LD_INT 8
47741: GREATER
47742: OR
47743: PUSH
47744: NOP4
47748: PUSH
47749: LD_INT 0
47751: LESS
47752: OR
47753: PUSH
47754: NOP4
47758: PUSH
47759: LD_INT 8
47761: GREATER
47762: OR
47763: IFFALSE 47767
// exit ;
47765: GO 47842
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
47767: NOP4
47771: PUSH
47772: LD_INT 22
47774: PUSH
47775: NOP4
47779: PUSH
47780: EMPTY
47781: LIST
47782: LIST
47783: PPUSH
47784: NOP4
47788: PUSH
47789: FOR_IN
47790: IFFALSE 47840
// begin un := UnitShoot ( i ) ;
47792: NOP4
47796: PUSH
47797: NOP4
47801: PPUSH
47802: NOP4
47806: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47807: NOP4
47811: PPUSH
47812: NOP4
47816: PUSH
47817: NOP4
47821: EQUAL
47822: IFFALSE 47838
// begin result := un ;
47824: NOP4
47828: PUSH
47829: NOP4
47833: ST_TO_ADDR
// exit ;
47834: POP
47835: POP
47836: GO 47842
// end ; end ;
47838: GO 47789
47840: POP
47841: POP
// end ;
47842: LD_VAR 0 3
47846: RET
// export function GetCargoBay ( units ) ; begin
47847: LD_INT 0
47849: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
47850: NOP4
47854: PUSH
47855: NOP4
47859: PPUSH
47860: LD_INT 2
47862: PUSH
47863: LD_INT 34
47865: PUSH
47866: LD_INT 12
47868: PUSH
47869: EMPTY
47870: LIST
47871: LIST
47872: PUSH
47873: LD_INT 34
47875: PUSH
47876: LD_INT 51
47878: PUSH
47879: EMPTY
47880: LIST
47881: LIST
47882: PUSH
47883: LD_INT 34
47885: PUSH
47886: LD_INT 32
47888: PUSH
47889: EMPTY
47890: LIST
47891: LIST
47892: PUSH
47893: LD_INT 34
47895: PUSH
47896: NOP4
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: LIST
47909: LIST
47910: LIST
47911: PPUSH
47912: NOP4
47916: ST_TO_ADDR
// end ;
47917: LD_VAR 0 2
47921: RET
// export function Negate ( value ) ; begin
47922: LD_INT 0
47924: PPUSH
// result := not value ;
47925: NOP4
47929: PUSH
47930: NOP4
47934: NOT
47935: ST_TO_ADDR
// end ;
47936: LD_VAR 0 2
47940: RET
// export function Inc ( value ) ; begin
47941: LD_INT 0
47943: PPUSH
// result := value + 1 ;
47944: NOP4
47948: PUSH
47949: NOP4
47953: PUSH
47954: LD_INT 1
47956: PLUS
47957: ST_TO_ADDR
// end ;
47958: LD_VAR 0 2
47962: RET
// export function Dec ( value ) ; begin
47963: LD_INT 0
47965: PPUSH
// result := value - 1 ;
47966: NOP4
47970: PUSH
47971: NOP4
47975: PUSH
47976: LD_INT 1
47978: MINUS
47979: ST_TO_ADDR
// end ;
47980: LD_VAR 0 2
47984: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
47985: LD_INT 0
47987: PPUSH
47988: PPUSH
47989: PPUSH
47990: PPUSH
47991: PPUSH
47992: PPUSH
47993: PPUSH
47994: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
47995: NOP4
47999: PPUSH
48000: NOP4
48004: PPUSH
48005: NOP4
48009: NOT
48010: PUSH
48011: NOP4
48015: PPUSH
48016: NOP4
48020: PPUSH
48021: NOP4
48025: NOT
48026: OR
48027: IFFALSE 48040
// begin result := - 1 ;
48029: NOP4
48033: PUSH
48034: LD_INT 1
48036: NEG
48037: ST_TO_ADDR
// exit ;
48038: GO 48275
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
48040: NOP4
48044: PUSH
48045: NOP4
48049: PPUSH
48050: NOP4
48054: PPUSH
48055: NOP4
48059: PPUSH
48060: NOP4
48064: PPUSH
48065: NOP4
48069: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
48070: NOP4
48074: PUSH
48075: NOP4
48079: PPUSH
48080: NOP4
48084: PPUSH
48085: NOP4
48089: PUSH
48090: LD_INT 1
48092: ARRAY
48093: PPUSH
48094: NOP4
48098: PUSH
48099: LD_INT 2
48101: ARRAY
48102: PPUSH
48103: NOP4
48107: ST_TO_ADDR
// distance := 9999 ;
48108: NOP4
48112: PUSH
48113: LD_INT 9999
48115: ST_TO_ADDR
// for i := 0 to 5 do
48116: NOP4
48120: PUSH
48121: DOUBLE
48122: LD_INT 0
48124: DEC
48125: ST_TO_ADDR
48126: LD_INT 5
48128: PUSH
48129: FOR_TO
48130: IFFALSE 48273
// begin _x := ShiftX ( x1 , i , centerDist ) ;
48132: NOP4
48136: PUSH
48137: NOP4
48141: PPUSH
48142: NOP4
48146: PPUSH
48147: NOP4
48151: PPUSH
48152: NOP4
48156: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
48157: NOP4
48161: PUSH
48162: NOP4
48166: PPUSH
48167: NOP4
48171: PPUSH
48172: NOP4
48176: PPUSH
48177: NOP4
48181: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
48182: NOP4
48186: PPUSH
48187: NOP4
48191: PPUSH
48192: NOP4
48196: NOT
48197: IFFALSE 48201
// continue ;
48199: GO 48129
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
48201: NOP4
48205: PUSH
48206: NOP4
48210: PUSH
48211: LD_INT 1
48213: ARRAY
48214: PPUSH
48215: NOP4
48219: PUSH
48220: LD_INT 2
48222: ARRAY
48223: PPUSH
48224: NOP4
48228: PPUSH
48229: NOP4
48233: PPUSH
48234: NOP4
48238: ST_TO_ADDR
// if tmp < distance then
48239: NOP4
48243: PUSH
48244: NOP4
48248: LESS
48249: IFFALSE 48271
// begin result := i ;
48251: NOP4
48255: PUSH
48256: NOP4
48260: ST_TO_ADDR
// distance := tmp ;
48261: NOP4
48265: PUSH
48266: NOP4
48270: ST_TO_ADDR
// end ; end ;
48271: GO 48129
48273: POP
48274: POP
// end ;
48275: LD_VAR 0 5
48279: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48280: LD_INT 0
48282: PPUSH
48283: PPUSH
// if not driver or not IsInUnit ( driver ) then
48284: NOP4
48288: NOT
48289: PUSH
48290: NOP4
48294: PPUSH
48295: NOP4
48299: NOT
48300: OR
48301: IFFALSE 48305
// exit ;
48303: GO 48395
// vehicle := IsInUnit ( driver ) ;
48305: NOP4
48309: PUSH
48310: NOP4
48314: PPUSH
48315: NOP4
48319: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48320: NOP4
48324: PPUSH
48325: LD_STRING \
48327: PUSH
48328: LD_INT 0
48330: PUSH
48331: LD_INT 0
48333: PUSH
48334: LD_INT 0
48336: PUSH
48337: LD_INT 0
48339: PUSH
48340: LD_INT 0
48342: PUSH
48343: LD_INT 0
48345: PUSH
48346: EMPTY
48347: LIST
48348: LIST
48349: LIST
48350: LIST
48351: LIST
48352: LIST
48353: LIST
48354: PUSH
48355: LD_STRING E
48357: PUSH
48358: LD_INT 0
48360: PUSH
48361: LD_INT 0
48363: PUSH
48364: NOP4
48368: PUSH
48369: LD_INT 0
48371: PUSH
48372: LD_INT 0
48374: PUSH
48375: LD_INT 0
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: PUSH
48387: EMPTY
48388: LIST
48389: LIST
48390: PPUSH
48391: NOP4
// end ;
48395: LD_VAR 0 2
48399: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48400: LD_INT 0
48402: PPUSH
48403: PPUSH
// if not driver or not IsInUnit ( driver ) then
48404: NOP4
48408: NOT
48409: PUSH
48410: NOP4
48414: PPUSH
48415: NOP4
48419: NOT
48420: OR
48421: IFFALSE 48425
// exit ;
48423: GO 48515
// vehicle := IsInUnit ( driver ) ;
48425: NOP4
48429: PUSH
48430: NOP4
48434: PPUSH
48435: NOP4
48439: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48440: NOP4
48444: PPUSH
48445: LD_STRING \
48447: PUSH
48448: LD_INT 0
48450: PUSH
48451: LD_INT 0
48453: PUSH
48454: LD_INT 0
48456: PUSH
48457: LD_INT 0
48459: PUSH
48460: LD_INT 0
48462: PUSH
48463: LD_INT 0
48465: PUSH
48466: EMPTY
48467: LIST
48468: LIST
48469: LIST
48470: LIST
48471: LIST
48472: LIST
48473: LIST
48474: PUSH
48475: LD_STRING E
48477: PUSH
48478: LD_INT 0
48480: PUSH
48481: LD_INT 0
48483: PUSH
48484: NOP4
48488: PUSH
48489: LD_INT 0
48491: PUSH
48492: LD_INT 0
48494: PUSH
48495: LD_INT 0
48497: PUSH
48498: EMPTY
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: LIST
48505: LIST
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PPUSH
48511: NOP4
// end ;
48515: LD_VAR 0 2
48519: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
48520: LD_INT 0
48522: PPUSH
48523: PPUSH
48524: PPUSH
// tmp := [ ] ;
48525: NOP4
48529: PUSH
48530: EMPTY
48531: ST_TO_ADDR
// for i in units do
48532: NOP4
48536: PUSH
48537: NOP4
48541: PUSH
48542: FOR_IN
48543: IFFALSE 48581
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
48545: NOP4
48549: PUSH
48550: NOP4
48554: PPUSH
48555: NOP4
48559: PUSH
48560: LD_INT 1
48562: PLUS
48563: PPUSH
48564: NOP4
48568: PPUSH
48569: NOP4
48573: PPUSH
48574: NOP4
48578: ST_TO_ADDR
48579: GO 48542
48581: POP
48582: POP
// if not tmp then
48583: NOP4
48587: NOT
48588: IFFALSE 48592
// exit ;
48590: GO 48640
// if asc then
48592: NOP4
48596: IFFALSE 48620
// result := SortListByListAsc ( units , tmp ) else
48598: NOP4
48602: PUSH
48603: NOP4
48607: PPUSH
48608: NOP4
48612: PPUSH
48613: NOP4
48617: ST_TO_ADDR
48618: GO 48640
// result := SortListByListDesc ( units , tmp ) ;
48620: NOP4
48624: PUSH
48625: NOP4
48629: PPUSH
48630: NOP4
48634: PPUSH
48635: NOP4
48639: ST_TO_ADDR
// end ;
48640: LD_VAR 0 3
48644: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
48645: LD_INT 0
48647: PPUSH
48648: PPUSH
// task := GetTaskList ( mech ) ;
48649: NOP4
48653: PUSH
48654: NOP4
48658: PPUSH
48659: NOP4
48663: ST_TO_ADDR
// if not task then
48664: NOP4
48668: NOT
48669: IFFALSE 48673
// exit ;
48671: GO 48715
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
48673: NOP4
48677: PUSH
48678: NOP4
48682: PUSH
48683: LD_INT 1
48685: ARRAY
48686: PUSH
48687: LD_INT 1
48689: ARRAY
48690: PUSH
48691: LD_STRING r
48693: EQUAL
48694: PUSH
48695: NOP4
48699: PUSH
48700: LD_INT 1
48702: ARRAY
48703: PUSH
48704: LD_INT 4
48706: ARRAY
48707: PUSH
48708: NOP4
48712: EQUAL
48713: AND
48714: ST_TO_ADDR
// end ;
48715: LD_VAR 0 3
48719: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
48720: LD_INT 0
48722: PPUSH
// SetDir ( unit , d ) ;
48723: NOP4
48727: PPUSH
48728: NOP4
48732: PPUSH
48733: NOP4
// PlaceUnitXY ( unit , x , y , mode ) ;
48737: NOP4
48741: PPUSH
48742: NOP4
48746: PPUSH
48747: NOP4
48751: PPUSH
48752: NOP4
48756: PPUSH
48757: NOP4
// end ;
48761: LD_VAR 0 6
48765: RET
// export function ToNaturalNumber ( number ) ; begin
48766: LD_INT 0
48768: PPUSH
// result := number div 1 ;
48769: NOP4
48773: PUSH
48774: NOP4
48778: PUSH
48779: LD_INT 1
48781: DIV
48782: ST_TO_ADDR
// if number < 0 then
48783: NOP4
48787: PUSH
48788: LD_INT 0
48790: LESS
48791: IFFALSE 48801
// result := 0 ;
48793: NOP4
48797: PUSH
48798: LD_INT 0
48800: ST_TO_ADDR
// end ;
48801: LD_VAR 0 2
48805: RET
// export function SortByClass ( units , class ) ; var un ; begin
48806: LD_INT 0
48808: PPUSH
48809: PPUSH
// if not units or not class then
48810: NOP4
48814: NOT
48815: PUSH
48816: NOP4
48820: NOT
48821: OR
48822: IFFALSE 48826
// exit ;
48824: GO 48921
// result := [ ] ;
48826: NOP4
48830: PUSH
48831: EMPTY
48832: ST_TO_ADDR
// for un in units do
48833: NOP4
48837: PUSH
48838: NOP4
48842: PUSH
48843: FOR_IN
48844: IFFALSE 48919
// if GetClass ( un ) = class then
48846: NOP4
48850: PPUSH
48851: NOP4
48855: PUSH
48856: NOP4
48860: EQUAL
48861: IFFALSE 48888
// result := Insert ( result , 1 , un ) else
48863: NOP4
48867: PUSH
48868: NOP4
48872: PPUSH
48873: LD_INT 1
48875: PPUSH
48876: NOP4
48880: PPUSH
48881: NOP4
48885: ST_TO_ADDR
48886: GO 48917
// result := Replace ( result , result + 1 , un ) ;
48888: NOP4
48892: PUSH
48893: NOP4
48897: PPUSH
48898: NOP4
48902: PUSH
48903: LD_INT 1
48905: PLUS
48906: PPUSH
48907: NOP4
48911: PPUSH
48912: NOP4
48916: ST_TO_ADDR
48917: GO 48843
48919: POP
48920: POP
// end ;
48921: LD_VAR 0 3
48925: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
48926: LD_INT 0
48928: PPUSH
48929: PPUSH
48930: PPUSH
48931: PPUSH
48932: PPUSH
48933: PPUSH
48934: PPUSH
// result := [ ] ;
48935: NOP4
48939: PUSH
48940: EMPTY
48941: ST_TO_ADDR
// if x - r < 0 then
48942: NOP4
48946: PUSH
48947: NOP4
48951: MINUS
48952: PUSH
48953: LD_INT 0
48955: LESS
48956: IFFALSE 48968
// min_x := 0 else
48958: NOP4
48962: PUSH
48963: LD_INT 0
48965: ST_TO_ADDR
48966: GO 48984
// min_x := x - r ;
48968: NOP4
48972: PUSH
48973: NOP4
48977: PUSH
48978: NOP4
48982: MINUS
48983: ST_TO_ADDR
// if y - r < 0 then
48984: NOP4
48988: PUSH
48989: NOP4
48993: MINUS
48994: PUSH
48995: LD_INT 0
48997: LESS
48998: IFFALSE 49010
// min_y := 0 else
49000: NOP4
49004: PUSH
49005: LD_INT 0
49007: ST_TO_ADDR
49008: GO 49026
// min_y := y - r ;
49010: NOP4
49014: PUSH
49015: NOP4
49019: PUSH
49020: NOP4
49024: MINUS
49025: ST_TO_ADDR
// max_x := x + r ;
49026: NOP4
49030: PUSH
49031: NOP4
49035: PUSH
49036: NOP4
49040: PLUS
49041: ST_TO_ADDR
// max_y := y + r ;
49042: NOP4
49046: PUSH
49047: NOP4
49051: PUSH
49052: NOP4
49056: PLUS
49057: ST_TO_ADDR
// for _x = min_x to max_x do
49058: NOP4
49062: PUSH
49063: DOUBLE
49064: NOP4
49068: DEC
49069: ST_TO_ADDR
49070: NOP4
49074: PUSH
49075: FOR_TO
49076: IFFALSE 49177
// for _y = min_y to max_y do
49078: NOP4
49082: PUSH
49083: DOUBLE
49084: NOP4
49088: DEC
49089: ST_TO_ADDR
49090: NOP4
49094: PUSH
49095: FOR_TO
49096: IFFALSE 49173
// begin if not ValidHex ( _x , _y ) then
49098: NOP4
49102: PPUSH
49103: NOP4
49107: PPUSH
49108: NOP4
49112: NOT
49113: IFFALSE 49117
// continue ;
49115: GO 49095
// if GetResourceTypeXY ( _x , _y ) then
49117: NOP4
49121: PPUSH
49122: NOP4
49126: PPUSH
49127: NOP4
49131: IFFALSE 49171
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
49133: NOP4
49137: PUSH
49138: NOP4
49142: PPUSH
49143: NOP4
49147: PUSH
49148: LD_INT 1
49150: PLUS
49151: PPUSH
49152: NOP4
49156: PUSH
49157: NOP4
49161: PUSH
49162: EMPTY
49163: LIST
49164: LIST
49165: PPUSH
49166: NOP4
49170: ST_TO_ADDR
// end ;
49171: GO 49095
49173: POP
49174: POP
49175: GO 49075
49177: POP
49178: POP
// end ;
49179: LD_VAR 0 4
49183: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
49184: LD_INT 0
49186: PPUSH
49187: PPUSH
49188: PPUSH
49189: PPUSH
49190: PPUSH
49191: PPUSH
49192: PPUSH
49193: PPUSH
// if not units then
49194: NOP4
49198: NOT
49199: IFFALSE 49203
// exit ;
49201: GO 49628
// result := UnitFilter ( units , [ f_ok ] ) ;
49203: NOP4
49207: PUSH
49208: NOP4
49212: PPUSH
49213: LD_INT 50
49215: PUSH
49216: EMPTY
49217: LIST
49218: PPUSH
49219: NOP4
49223: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
49224: NOP4
49228: PUSH
49229: NOP4
49233: PUSH
49234: LD_INT 1
49236: ARRAY
49237: PPUSH
49238: NOP4
49242: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
49243: NOP4
49247: PUSH
49248: LD_INT 29
49250: PUSH
49251: NOP4
49255: PUSH
49256: EMPTY
49257: LIST
49258: LIST
49259: ST_TO_ADDR
// if not result then
49260: NOP4
49264: NOT
49265: IFFALSE 49269
// exit ;
49267: GO 49628
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
49269: NOP4
49273: PUSH
49274: LD_INT 81
49276: PUSH
49277: NOP4
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: PPUSH
49286: NOP4
49290: ST_TO_ADDR
// for i in result do
49291: NOP4
49295: PUSH
49296: NOP4
49300: PUSH
49301: FOR_IN
49302: IFFALSE 49626
// begin tag := GetTag ( i ) + 1 ;
49304: NOP4
49308: PUSH
49309: NOP4
49313: PPUSH
49314: NOP4
49318: PUSH
49319: LD_INT 1
49321: PLUS
49322: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
49323: NOP4
49327: PUSH
49328: NOP4
49332: PPUSH
49333: NOP4
49337: PPUSH
49338: NOP4
49342: PPUSH
49343: NOP4
49347: PPUSH
49348: LD_INT 6
49350: PPUSH
49351: NOP4
49355: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
49356: NOP4
49360: PUSH
49361: NOP4
49365: PPUSH
49366: NOP4
49370: PUSH
49371: NOP4
49375: IN
49376: NOT
49377: AND
49378: IFFALSE 49417
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
49380: NOP4
49384: PPUSH
49385: NOP4
49389: PUSH
49390: LD_INT 1
49392: ARRAY
49393: PUSH
49394: LD_INT 1
49396: ARRAY
49397: PPUSH
49398: NOP4
49402: PUSH
49403: LD_INT 1
49405: ARRAY
49406: PUSH
49407: LD_INT 2
49409: ARRAY
49410: PPUSH
49411: NOP4
49415: GO 49624
// if path > tag then
49417: NOP4
49421: PUSH
49422: NOP4
49426: GREATER
49427: IFFALSE 49594
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
49429: NOP4
49433: PUSH
49434: NOP4
49438: PPUSH
49439: LD_INT 91
49441: PUSH
49442: NOP4
49446: PUSH
49447: LD_INT 12
49449: PUSH
49450: EMPTY
49451: LIST
49452: LIST
49453: LIST
49454: PPUSH
49455: NOP4
49459: ST_TO_ADDR
// if nearEnemy then
49460: NOP4
49464: IFFALSE 49492
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
49466: NOP4
49470: PPUSH
49471: NOP4
49475: PPUSH
49476: NOP4
49480: PPUSH
49481: NOP4
49485: PPUSH
49486: NOP4
49490: GO 49592
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
49492: NOP4
49496: PPUSH
49497: NOP4
49501: PUSH
49502: NOP4
49506: ARRAY
49507: PUSH
49508: LD_INT 1
49510: ARRAY
49511: PPUSH
49512: NOP4
49516: PUSH
49517: NOP4
49521: ARRAY
49522: PUSH
49523: LD_INT 2
49525: ARRAY
49526: PPUSH
49527: NOP4
49531: PUSH
49532: LD_INT 6
49534: GREATER
49535: IFFALSE 49578
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
49537: NOP4
49541: PPUSH
49542: NOP4
49546: PUSH
49547: NOP4
49551: ARRAY
49552: PUSH
49553: LD_INT 1
49555: ARRAY
49556: PPUSH
49557: NOP4
49561: PUSH
49562: NOP4
49566: ARRAY
49567: PUSH
49568: LD_INT 2
49570: ARRAY
49571: PPUSH
49572: NOP4
49576: GO 49592
// SetTag ( i , tag ) ;
49578: NOP4
49582: PPUSH
49583: NOP4
49587: PPUSH
49588: NOP4
// end else
49592: GO 49624
// if enemy then
49594: NOP4
49598: IFFALSE 49624
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
49600: NOP4
49604: PPUSH
49605: NOP4
49609: PPUSH
49610: NOP4
49614: PPUSH
49615: NOP4
49619: PPUSH
49620: NOP4
// end ;
49624: GO 49301
49626: POP
49627: POP
// end ;
49628: LD_VAR 0 3
49632: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
49633: LD_INT 0
49635: PPUSH
49636: PPUSH
49637: PPUSH
// if not unit or IsInUnit ( unit ) then
49638: NOP4
49642: NOT
49643: PUSH
49644: NOP4
49648: PPUSH
49649: NOP4
49653: OR
49654: IFFALSE 49658
// exit ;
49656: GO 49749
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
49658: NOP4
49662: PUSH
49663: NOP4
49667: PPUSH
49668: NOP4
49672: PPUSH
49673: NOP4
49677: PPUSH
49678: LD_INT 1
49680: PPUSH
49681: NOP4
49685: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
49686: NOP4
49690: PUSH
49691: NOP4
49695: PPUSH
49696: NOP4
49700: PPUSH
49701: NOP4
49705: PPUSH
49706: LD_INT 1
49708: PPUSH
49709: NOP4
49713: ST_TO_ADDR
// if ValidHex ( x , y ) then
49714: NOP4
49718: PPUSH
49719: NOP4
49723: PPUSH
49724: NOP4
49728: IFFALSE 49749
// ComTurnXY ( unit , x , y ) ;
49730: NOP4
49734: PPUSH
49735: NOP4
49739: PPUSH
49740: NOP4
49744: PPUSH
49745: NOP4
// end ;
49749: LD_VAR 0 3
49753: RET
// export function SeeUnits ( side , units ) ; var i ; begin
49754: LD_INT 0
49756: PPUSH
49757: PPUSH
// result := false ;
49758: NOP4
49762: PUSH
49763: LD_INT 0
49765: ST_TO_ADDR
// if not units then
49766: NOP4
49770: NOT
49771: IFFALSE 49775
// exit ;
49773: GO 49820
// for i in units do
49775: NOP4
49779: PUSH
49780: NOP4
49784: PUSH
49785: FOR_IN
49786: IFFALSE 49818
// if See ( side , i ) then
49788: NOP4
49792: PPUSH
49793: NOP4
49797: PPUSH
49798: NOP4
49802: IFFALSE 49816
// begin result := true ;
49804: NOP4
49808: PUSH
49809: LD_INT 1
49811: ST_TO_ADDR
// exit ;
49812: POP
49813: POP
49814: GO 49820
// end ;
49816: GO 49785
49818: POP
49819: POP
// end ;
49820: LD_VAR 0 3
49824: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
49825: LD_INT 0
49827: PPUSH
49828: PPUSH
49829: PPUSH
49830: PPUSH
// if not unit or not points then
49831: NOP4
49835: NOT
49836: PUSH
49837: NOP4
49841: NOT
49842: OR
49843: IFFALSE 49847
// exit ;
49845: GO 49937
// dist := 99999 ;
49847: NOP4
49851: PUSH
49852: LD_INT 99999
49854: ST_TO_ADDR
// for i in points do
49855: NOP4
49859: PUSH
49860: NOP4
49864: PUSH
49865: FOR_IN
49866: IFFALSE 49935
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
49868: NOP4
49872: PUSH
49873: NOP4
49877: PPUSH
49878: NOP4
49882: PUSH
49883: LD_INT 1
49885: ARRAY
49886: PPUSH
49887: NOP4
49891: PUSH
49892: LD_INT 2
49894: ARRAY
49895: PPUSH
49896: NOP4
49900: ST_TO_ADDR
// if tmpDist < dist then
49901: NOP4
49905: PUSH
49906: NOP4
49910: LESS
49911: IFFALSE 49933
// begin result := i ;
49913: NOP4
49917: PUSH
49918: NOP4
49922: ST_TO_ADDR
// dist := tmpDist ;
49923: NOP4
49927: PUSH
49928: NOP4
49932: ST_TO_ADDR
// end ; end ;
49933: GO 49865
49935: POP
49936: POP
// end ; end_of_file
49937: LD_VAR 0 3
49941: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
49942: LD_INT 0
49944: PPUSH
49945: PPUSH
// skirmish := false ;
49946: NOP4
49950: PUSH
49951: LD_INT 0
49953: ST_TO_ADDR
// debug_mc := false ;
49954: NOP4
49958: PUSH
49959: LD_INT 0
49961: ST_TO_ADDR
// mc_bases := [ ] ;
49962: NOP4
49966: PUSH
49967: EMPTY
49968: ST_TO_ADDR
// mc_sides := [ ] ;
49969: NOP4
49973: PUSH
49974: EMPTY
49975: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
49976: NOP4
49980: PUSH
49981: EMPTY
49982: ST_TO_ADDR
// mc_building_repairs := [ ] ;
49983: NOP4
49987: PUSH
49988: EMPTY
49989: ST_TO_ADDR
// mc_need_heal := [ ] ;
49990: NOP4
49994: PUSH
49995: EMPTY
49996: ST_TO_ADDR
// mc_healers := [ ] ;
49997: NOP4
50001: PUSH
50002: EMPTY
50003: ST_TO_ADDR
// mc_build_list := [ ] ;
50004: NOP4
50008: PUSH
50009: EMPTY
50010: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50011: NOP4
50015: PUSH
50016: EMPTY
50017: ST_TO_ADDR
// mc_builders := [ ] ;
50018: NOP4
50022: PUSH
50023: EMPTY
50024: ST_TO_ADDR
// mc_construct_list := [ ] ;
50025: NOP4
50029: PUSH
50030: EMPTY
50031: ST_TO_ADDR
// mc_turret_list := [ ] ;
50032: NOP4
50036: PUSH
50037: EMPTY
50038: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50039: NOP4
50043: PUSH
50044: EMPTY
50045: ST_TO_ADDR
// mc_miners := [ ] ;
50046: NOP4
50050: PUSH
50051: EMPTY
50052: ST_TO_ADDR
// mc_mines := [ ] ;
50053: NOP4
50057: PUSH
50058: EMPTY
50059: ST_TO_ADDR
// mc_minefields := [ ] ;
50060: NOP4
50064: PUSH
50065: EMPTY
50066: ST_TO_ADDR
// mc_crates := [ ] ;
50067: NOP4
50071: PUSH
50072: EMPTY
50073: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50074: NOP4
50078: PUSH
50079: EMPTY
50080: ST_TO_ADDR
// mc_crates_area := [ ] ;
50081: NOP4
50085: PUSH
50086: EMPTY
50087: ST_TO_ADDR
// mc_vehicles := [ ] ;
50088: NOP4
50092: PUSH
50093: EMPTY
50094: ST_TO_ADDR
// mc_attack := [ ] ;
50095: NOP4
50099: PUSH
50100: EMPTY
50101: ST_TO_ADDR
// mc_produce := [ ] ;
50102: NOP4
50106: PUSH
50107: EMPTY
50108: ST_TO_ADDR
// mc_defender := [ ] ;
50109: NOP4
50113: PUSH
50114: EMPTY
50115: ST_TO_ADDR
// mc_parking := [ ] ;
50116: NOP4
50120: PUSH
50121: EMPTY
50122: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50123: NOP4
50127: PUSH
50128: EMPTY
50129: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50130: NOP4
50134: PUSH
50135: EMPTY
50136: ST_TO_ADDR
// mc_scan := [ ] ;
50137: NOP4
50141: PUSH
50142: EMPTY
50143: ST_TO_ADDR
// mc_scan_area := [ ] ;
50144: NOP4
50148: PUSH
50149: EMPTY
50150: ST_TO_ADDR
// mc_tech := [ ] ;
50151: NOP4
50155: PUSH
50156: EMPTY
50157: ST_TO_ADDR
// mc_class := [ ] ;
50158: NOP4
50162: PUSH
50163: EMPTY
50164: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50165: NOP4
50169: PUSH
50170: EMPTY
50171: ST_TO_ADDR
// mc_is_defending := [ ] ;
50172: NOP4
50176: PUSH
50177: EMPTY
50178: ST_TO_ADDR
// end ;
50179: LD_VAR 0 1
50183: RET
// export function MC_Kill ( base ) ; begin
50184: LD_INT 0
50186: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50187: NOP4
50191: PUSH
50192: NOP4
50196: PPUSH
50197: NOP4
50201: PPUSH
50202: EMPTY
50203: PPUSH
50204: NOP4
50208: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50209: NOP4
50213: PUSH
50214: NOP4
50218: PPUSH
50219: NOP4
50223: PPUSH
50224: EMPTY
50225: PPUSH
50226: NOP4
50230: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50231: NOP4
50235: PUSH
50236: NOP4
50240: PPUSH
50241: NOP4
50245: PPUSH
50246: EMPTY
50247: PPUSH
50248: NOP4
50252: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50253: NOP4
50257: PUSH
50258: NOP4
50262: PPUSH
50263: NOP4
50267: PPUSH
50268: EMPTY
50269: PPUSH
50270: NOP4
50274: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50275: NOP4
50279: PUSH
50280: NOP4
50284: PPUSH
50285: NOP4
50289: PPUSH
50290: EMPTY
50291: PPUSH
50292: NOP4
50296: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50297: NOP4
50301: PUSH
50302: NOP4
50306: PPUSH
50307: NOP4
50311: PPUSH
50312: EMPTY
50313: PPUSH
50314: NOP4
50318: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50319: NOP4
50323: PUSH
50324: NOP4
50328: PPUSH
50329: NOP4
50333: PPUSH
50334: EMPTY
50335: PPUSH
50336: NOP4
50340: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50341: NOP4
50345: PUSH
50346: NOP4
50350: PPUSH
50351: NOP4
50355: PPUSH
50356: EMPTY
50357: PPUSH
50358: NOP4
50362: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50363: NOP4
50367: PUSH
50368: NOP4
50372: PPUSH
50373: NOP4
50377: PPUSH
50378: EMPTY
50379: PPUSH
50380: NOP4
50384: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50385: NOP4
50389: PUSH
50390: NOP4
50394: PPUSH
50395: NOP4
50399: PPUSH
50400: EMPTY
50401: PPUSH
50402: NOP4
50406: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50407: NOP4
50411: PUSH
50412: NOP4
50416: PPUSH
50417: NOP4
50421: PPUSH
50422: EMPTY
50423: PPUSH
50424: NOP4
50428: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
50429: NOP4
50433: PUSH
50434: NOP4
50438: PPUSH
50439: NOP4
50443: PPUSH
50444: LD_INT 0
50446: PPUSH
50447: NOP4
50451: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50452: NOP4
50456: PUSH
50457: NOP4
50461: PPUSH
50462: NOP4
50466: PPUSH
50467: EMPTY
50468: PPUSH
50469: NOP4
50473: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50474: NOP4
50478: PUSH
50479: NOP4
50483: PPUSH
50484: NOP4
50488: PPUSH
50489: EMPTY
50490: PPUSH
50491: NOP4
50495: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
50496: NOP4
50500: PUSH
50501: NOP4
50505: PPUSH
50506: NOP4
50510: PPUSH
50511: EMPTY
50512: PPUSH
50513: NOP4
50517: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
50518: NOP4
50522: PUSH
50523: NOP4
50527: PPUSH
50528: NOP4
50532: PPUSH
50533: EMPTY
50534: PPUSH
50535: NOP4
50539: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
50540: NOP4
50544: PUSH
50545: NOP4
50549: PPUSH
50550: NOP4
50554: PPUSH
50555: EMPTY
50556: PPUSH
50557: NOP4
50561: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
50562: NOP4
50566: PUSH
50567: NOP4
50571: PPUSH
50572: NOP4
50576: PPUSH
50577: EMPTY
50578: PPUSH
50579: NOP4
50583: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
50584: NOP4
50588: PUSH
50589: NOP4
50593: PPUSH
50594: NOP4
50598: PPUSH
50599: EMPTY
50600: PPUSH
50601: NOP4
50605: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
50606: NOP4
50610: PUSH
50611: NOP4
50615: PPUSH
50616: NOP4
50620: PPUSH
50621: EMPTY
50622: PPUSH
50623: NOP4
50627: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
50628: NOP4
50632: PUSH
50633: NOP4
50637: PPUSH
50638: NOP4
50642: PPUSH
50643: EMPTY
50644: PPUSH
50645: NOP4
50649: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
50650: NOP4
50654: PUSH
50655: NOP4
50659: PPUSH
50660: NOP4
50664: PPUSH
50665: EMPTY
50666: PPUSH
50667: NOP4
50671: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
50672: NOP4
50676: PUSH
50677: NOP4
50681: PPUSH
50682: NOP4
50686: PPUSH
50687: EMPTY
50688: PPUSH
50689: NOP4
50693: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
50694: NOP4
50698: PUSH
50699: NOP4
50703: PPUSH
50704: NOP4
50708: PPUSH
50709: EMPTY
50710: PPUSH
50711: NOP4
50715: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
50716: NOP4
50720: PUSH
50721: NOP4
50725: PPUSH
50726: NOP4
50730: PPUSH
50731: EMPTY
50732: PPUSH
50733: NOP4
50737: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
50738: NOP4
50742: PUSH
50743: NOP4
50747: PPUSH
50748: NOP4
50752: PPUSH
50753: EMPTY
50754: PPUSH
50755: NOP4
50759: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
50760: NOP4
50764: PUSH
50765: NOP4
50769: PPUSH
50770: NOP4
50774: PPUSH
50775: EMPTY
50776: PPUSH
50777: NOP4
50781: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
50782: NOP4
50786: PUSH
50787: NOP4
50791: PPUSH
50792: NOP4
50796: PPUSH
50797: EMPTY
50798: PPUSH
50799: NOP4
50803: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
50804: NOP4
50808: PUSH
50809: NOP4
50813: PPUSH
50814: NOP4
50818: PPUSH
50819: EMPTY
50820: PPUSH
50821: NOP4
50825: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
50826: NOP4
50830: PUSH
50831: NOP4
50835: PPUSH
50836: NOP4
50840: PPUSH
50841: EMPTY
50842: PPUSH
50843: NOP4
50847: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
50848: NOP4
50852: PUSH
50853: NOP4
50857: PPUSH
50858: NOP4
50862: PPUSH
50863: EMPTY
50864: PPUSH
50865: NOP4
50869: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
50870: NOP4
50874: PUSH
50875: NOP4
50879: PPUSH
50880: NOP4
50884: PPUSH
50885: EMPTY
50886: PPUSH
50887: NOP4
50891: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
50892: NOP4
50896: PUSH
50897: NOP4
50901: PPUSH
50902: NOP4
50906: PPUSH
50907: EMPTY
50908: PPUSH
50909: NOP4
50913: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
50914: NOP4
50918: PUSH
50919: NOP4
50923: PPUSH
50924: NOP4
50928: PPUSH
50929: EMPTY
50930: PPUSH
50931: NOP4
50935: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
50936: NOP4
50940: PUSH
50941: NOP4
50945: PPUSH
50946: NOP4
50950: PPUSH
50951: EMPTY
50952: PPUSH
50953: NOP4
50957: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
50958: NOP4
50962: PUSH
50963: NOP4
50967: PPUSH
50968: NOP4
50972: PPUSH
50973: EMPTY
50974: PPUSH
50975: NOP4
50979: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
50980: NOP4
50984: PUSH
50985: NOP4
50989: PPUSH
50990: NOP4
50994: PPUSH
50995: EMPTY
50996: PPUSH
50997: NOP4
51001: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51002: NOP4
51006: PUSH
51007: NOP4
51011: PPUSH
51012: NOP4
51016: PPUSH
51017: EMPTY
51018: PPUSH
51019: NOP4
51023: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51024: NOP4
51028: PUSH
51029: NOP4
51033: PPUSH
51034: NOP4
51038: PPUSH
51039: EMPTY
51040: PPUSH
51041: NOP4
51045: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51046: NOP4
51050: PUSH
51051: NOP4
51055: PPUSH
51056: NOP4
51060: PPUSH
51061: EMPTY
51062: PPUSH
51063: NOP4
51067: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51068: NOP4
51072: PUSH
51073: NOP4
51077: PPUSH
51078: NOP4
51082: PPUSH
51083: LD_INT 0
51085: PPUSH
51086: NOP4
51090: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
51091: NOP4
51095: PUSH
51096: NOP4
51100: PPUSH
51101: NOP4
51105: PPUSH
51106: LD_INT 0
51108: PPUSH
51109: NOP4
51113: ST_TO_ADDR
// end ;
51114: LD_VAR 0 2
51118: RET
// export function MC_Add ( side , units ) ; var base ; begin
51119: LD_INT 0
51121: PPUSH
51122: PPUSH
// base := mc_bases + 1 ;
51123: NOP4
51127: PUSH
51128: NOP4
51132: PUSH
51133: LD_INT 1
51135: PLUS
51136: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51137: NOP4
51141: PUSH
51142: NOP4
51146: PPUSH
51147: NOP4
51151: PPUSH
51152: NOP4
51156: PPUSH
51157: NOP4
51161: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51162: NOP4
51166: PUSH
51167: NOP4
51171: PPUSH
51172: NOP4
51176: PPUSH
51177: NOP4
51181: PPUSH
51182: NOP4
51186: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51187: NOP4
51191: PUSH
51192: NOP4
51196: PPUSH
51197: NOP4
51201: PPUSH
51202: EMPTY
51203: PPUSH
51204: NOP4
51208: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51209: NOP4
51213: PUSH
51214: NOP4
51218: PPUSH
51219: NOP4
51223: PPUSH
51224: EMPTY
51225: PPUSH
51226: NOP4
51230: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51231: NOP4
51235: PUSH
51236: NOP4
51240: PPUSH
51241: NOP4
51245: PPUSH
51246: EMPTY
51247: PPUSH
51248: NOP4
51252: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51253: NOP4
51257: PUSH
51258: NOP4
51262: PPUSH
51263: NOP4
51267: PPUSH
51268: EMPTY
51269: PPUSH
51270: NOP4
51274: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51275: NOP4
51279: PUSH
51280: NOP4
51284: PPUSH
51285: NOP4
51289: PPUSH
51290: EMPTY
51291: PPUSH
51292: NOP4
51296: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51297: NOP4
51301: PUSH
51302: NOP4
51306: PPUSH
51307: NOP4
51311: PPUSH
51312: EMPTY
51313: PPUSH
51314: NOP4
51318: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51319: NOP4
51323: PUSH
51324: NOP4
51328: PPUSH
51329: NOP4
51333: PPUSH
51334: EMPTY
51335: PPUSH
51336: NOP4
51340: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51341: NOP4
51345: PUSH
51346: NOP4
51350: PPUSH
51351: NOP4
51355: PPUSH
51356: EMPTY
51357: PPUSH
51358: NOP4
51362: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51363: NOP4
51367: PUSH
51368: NOP4
51372: PPUSH
51373: NOP4
51377: PPUSH
51378: EMPTY
51379: PPUSH
51380: NOP4
51384: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51385: NOP4
51389: PUSH
51390: NOP4
51394: PPUSH
51395: NOP4
51399: PPUSH
51400: EMPTY
51401: PPUSH
51402: NOP4
51406: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51407: NOP4
51411: PUSH
51412: NOP4
51416: PPUSH
51417: NOP4
51421: PPUSH
51422: LD_INT 0
51424: PPUSH
51425: NOP4
51429: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51430: NOP4
51434: PUSH
51435: NOP4
51439: PPUSH
51440: NOP4
51444: PPUSH
51445: EMPTY
51446: PPUSH
51447: NOP4
51451: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51452: NOP4
51456: PUSH
51457: NOP4
51461: PPUSH
51462: NOP4
51466: PPUSH
51467: EMPTY
51468: PPUSH
51469: NOP4
51473: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51474: NOP4
51478: PUSH
51479: NOP4
51483: PPUSH
51484: NOP4
51488: PPUSH
51489: EMPTY
51490: PPUSH
51491: NOP4
51495: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51496: NOP4
51500: PUSH
51501: NOP4
51505: PPUSH
51506: NOP4
51510: PPUSH
51511: EMPTY
51512: PPUSH
51513: NOP4
51517: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51518: NOP4
51522: PUSH
51523: NOP4
51527: PPUSH
51528: NOP4
51532: PPUSH
51533: EMPTY
51534: PPUSH
51535: NOP4
51539: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51540: NOP4
51544: PUSH
51545: NOP4
51549: PPUSH
51550: NOP4
51554: PPUSH
51555: EMPTY
51556: PPUSH
51557: NOP4
51561: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51562: NOP4
51566: PUSH
51567: NOP4
51571: PPUSH
51572: NOP4
51576: PPUSH
51577: EMPTY
51578: PPUSH
51579: NOP4
51583: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51584: NOP4
51588: PUSH
51589: NOP4
51593: PPUSH
51594: NOP4
51598: PPUSH
51599: EMPTY
51600: PPUSH
51601: NOP4
51605: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51606: NOP4
51610: PUSH
51611: NOP4
51615: PPUSH
51616: NOP4
51620: PPUSH
51621: EMPTY
51622: PPUSH
51623: NOP4
51627: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51628: NOP4
51632: PUSH
51633: NOP4
51637: PPUSH
51638: NOP4
51642: PPUSH
51643: EMPTY
51644: PPUSH
51645: NOP4
51649: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51650: NOP4
51654: PUSH
51655: NOP4
51659: PPUSH
51660: NOP4
51664: PPUSH
51665: EMPTY
51666: PPUSH
51667: NOP4
51671: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51672: NOP4
51676: PUSH
51677: NOP4
51681: PPUSH
51682: NOP4
51686: PPUSH
51687: EMPTY
51688: PPUSH
51689: NOP4
51693: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51694: NOP4
51698: PUSH
51699: NOP4
51703: PPUSH
51704: NOP4
51708: PPUSH
51709: EMPTY
51710: PPUSH
51711: NOP4
51715: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51716: NOP4
51720: PUSH
51721: NOP4
51725: PPUSH
51726: NOP4
51730: PPUSH
51731: EMPTY
51732: PPUSH
51733: NOP4
51737: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51738: NOP4
51742: PUSH
51743: NOP4
51747: PPUSH
51748: NOP4
51752: PPUSH
51753: EMPTY
51754: PPUSH
51755: NOP4
51759: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51760: NOP4
51764: PUSH
51765: NOP4
51769: PPUSH
51770: NOP4
51774: PPUSH
51775: EMPTY
51776: PPUSH
51777: NOP4
51781: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51782: NOP4
51786: PUSH
51787: NOP4
51791: PPUSH
51792: NOP4
51796: PPUSH
51797: EMPTY
51798: PPUSH
51799: NOP4
51803: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51804: NOP4
51808: PUSH
51809: NOP4
51813: PPUSH
51814: NOP4
51818: PPUSH
51819: EMPTY
51820: PPUSH
51821: NOP4
51825: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51826: NOP4
51830: PUSH
51831: NOP4
51835: PPUSH
51836: NOP4
51840: PPUSH
51841: EMPTY
51842: PPUSH
51843: NOP4
51847: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51848: NOP4
51852: PUSH
51853: NOP4
51857: PPUSH
51858: NOP4
51862: PPUSH
51863: EMPTY
51864: PPUSH
51865: NOP4
51869: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51870: NOP4
51874: PUSH
51875: NOP4
51879: PPUSH
51880: NOP4
51884: PPUSH
51885: EMPTY
51886: PPUSH
51887: NOP4
51891: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51892: NOP4
51896: PUSH
51897: NOP4
51901: PPUSH
51902: NOP4
51906: PPUSH
51907: EMPTY
51908: PPUSH
51909: NOP4
51913: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51914: NOP4
51918: PUSH
51919: NOP4
51923: PPUSH
51924: NOP4
51928: PPUSH
51929: EMPTY
51930: PPUSH
51931: NOP4
51935: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51936: NOP4
51940: PUSH
51941: NOP4
51945: PPUSH
51946: NOP4
51950: PPUSH
51951: EMPTY
51952: PPUSH
51953: NOP4
51957: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51958: NOP4
51962: PUSH
51963: NOP4
51967: PPUSH
51968: NOP4
51972: PPUSH
51973: EMPTY
51974: PPUSH
51975: NOP4
51979: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51980: NOP4
51984: PUSH
51985: NOP4
51989: PPUSH
51990: NOP4
51994: PPUSH
51995: EMPTY
51996: PPUSH
51997: NOP4
52001: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52002: NOP4
52006: PUSH
52007: NOP4
52011: PPUSH
52012: NOP4
52016: PPUSH
52017: EMPTY
52018: PPUSH
52019: NOP4
52023: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52024: NOP4
52028: PUSH
52029: NOP4
52033: PPUSH
52034: NOP4
52038: PPUSH
52039: EMPTY
52040: PPUSH
52041: NOP4
52045: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52046: NOP4
52050: PUSH
52051: NOP4
52055: PPUSH
52056: NOP4
52060: PPUSH
52061: LD_INT 0
52063: PPUSH
52064: NOP4
52068: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52069: NOP4
52073: PUSH
52074: NOP4
52078: PPUSH
52079: NOP4
52083: PPUSH
52084: LD_INT 0
52086: PPUSH
52087: NOP4
52091: ST_TO_ADDR
// result := base ;
52092: NOP4
52096: PUSH
52097: NOP4
52101: ST_TO_ADDR
// end ;
52102: LD_VAR 0 3
52106: RET
// export function MC_Start ( ) ; var i ; begin
52107: LD_INT 0
52109: PPUSH
52110: PPUSH
// for i = 1 to mc_bases do
52111: NOP4
52115: PUSH
52116: DOUBLE
52117: LD_INT 1
52119: DEC
52120: ST_TO_ADDR
52121: NOP4
52125: PUSH
52126: FOR_TO
52127: IFFALSE 53227
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52129: NOP4
52133: PUSH
52134: NOP4
52138: PPUSH
52139: NOP4
52143: PPUSH
52144: NOP4
52148: PUSH
52149: NOP4
52153: ARRAY
52154: PUSH
52155: LD_INT 0
52157: DIFF
52158: PPUSH
52159: NOP4
52163: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52164: NOP4
52168: PUSH
52169: NOP4
52173: PPUSH
52174: NOP4
52178: PPUSH
52179: EMPTY
52180: PPUSH
52181: NOP4
52185: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52186: NOP4
52190: PUSH
52191: NOP4
52195: PPUSH
52196: NOP4
52200: PPUSH
52201: EMPTY
52202: PPUSH
52203: NOP4
52207: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52208: NOP4
52212: PUSH
52213: NOP4
52217: PPUSH
52218: NOP4
52222: PPUSH
52223: EMPTY
52224: PPUSH
52225: NOP4
52229: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52230: NOP4
52234: PUSH
52235: NOP4
52239: PPUSH
52240: NOP4
52244: PPUSH
52245: EMPTY
52246: PUSH
52247: EMPTY
52248: PUSH
52249: EMPTY
52250: LIST
52251: LIST
52252: PPUSH
52253: NOP4
52257: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52258: NOP4
52262: PUSH
52263: NOP4
52267: PPUSH
52268: NOP4
52272: PPUSH
52273: EMPTY
52274: PPUSH
52275: NOP4
52279: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52280: NOP4
52284: PUSH
52285: NOP4
52289: PPUSH
52290: NOP4
52294: PPUSH
52295: EMPTY
52296: PPUSH
52297: NOP4
52301: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52302: NOP4
52306: PUSH
52307: NOP4
52311: PPUSH
52312: NOP4
52316: PPUSH
52317: EMPTY
52318: PPUSH
52319: NOP4
52323: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52324: NOP4
52328: PUSH
52329: NOP4
52333: PPUSH
52334: NOP4
52338: PPUSH
52339: EMPTY
52340: PPUSH
52341: NOP4
52345: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
52346: NOP4
52350: PUSH
52351: NOP4
52355: PPUSH
52356: NOP4
52360: PPUSH
52361: NOP4
52365: PUSH
52366: NOP4
52370: ARRAY
52371: PPUSH
52372: LD_INT 2
52374: PUSH
52375: LD_INT 30
52377: PUSH
52378: LD_INT 32
52380: PUSH
52381: EMPTY
52382: LIST
52383: LIST
52384: PUSH
52385: LD_INT 30
52387: PUSH
52388: LD_INT 33
52390: PUSH
52391: EMPTY
52392: LIST
52393: LIST
52394: PUSH
52395: EMPTY
52396: LIST
52397: LIST
52398: LIST
52399: PPUSH
52400: NOP4
52404: PPUSH
52405: NOP4
52409: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
52410: NOP4
52414: PUSH
52415: NOP4
52419: PPUSH
52420: NOP4
52424: PPUSH
52425: NOP4
52429: PUSH
52430: NOP4
52434: ARRAY
52435: PPUSH
52436: LD_INT 2
52438: PUSH
52439: LD_INT 30
52441: PUSH
52442: LD_INT 32
52444: PUSH
52445: EMPTY
52446: LIST
52447: LIST
52448: PUSH
52449: LD_INT 30
52451: PUSH
52452: LD_INT 31
52454: PUSH
52455: EMPTY
52456: LIST
52457: LIST
52458: PUSH
52459: EMPTY
52460: LIST
52461: LIST
52462: LIST
52463: PUSH
52464: LD_INT 58
52466: PUSH
52467: EMPTY
52468: LIST
52469: PUSH
52470: EMPTY
52471: LIST
52472: LIST
52473: PPUSH
52474: NOP4
52478: PPUSH
52479: NOP4
52483: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
52484: NOP4
52488: PUSH
52489: NOP4
52493: PPUSH
52494: NOP4
52498: PPUSH
52499: EMPTY
52500: PPUSH
52501: NOP4
52505: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
52506: NOP4
52510: PUSH
52511: NOP4
52515: PPUSH
52516: NOP4
52520: PPUSH
52521: EMPTY
52522: PPUSH
52523: NOP4
52527: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
52528: NOP4
52532: PUSH
52533: NOP4
52537: PPUSH
52538: NOP4
52542: PPUSH
52543: EMPTY
52544: PPUSH
52545: NOP4
52549: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
52550: NOP4
52554: PUSH
52555: NOP4
52559: PPUSH
52560: NOP4
52564: PPUSH
52565: EMPTY
52566: PPUSH
52567: NOP4
52571: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
52572: NOP4
52576: PUSH
52577: NOP4
52581: PPUSH
52582: NOP4
52586: PPUSH
52587: EMPTY
52588: PPUSH
52589: NOP4
52593: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52594: NOP4
52598: PUSH
52599: NOP4
52603: PPUSH
52604: NOP4
52608: PPUSH
52609: EMPTY
52610: PPUSH
52611: NOP4
52615: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
52616: NOP4
52620: PUSH
52621: NOP4
52625: PPUSH
52626: NOP4
52630: PPUSH
52631: EMPTY
52632: PPUSH
52633: NOP4
52637: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
52638: NOP4
52642: PUSH
52643: NOP4
52647: PPUSH
52648: NOP4
52652: PPUSH
52653: EMPTY
52654: PPUSH
52655: NOP4
52659: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52660: NOP4
52664: PUSH
52665: NOP4
52669: PPUSH
52670: NOP4
52674: PPUSH
52675: EMPTY
52676: PPUSH
52677: NOP4
52681: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
52682: NOP4
52686: PUSH
52687: NOP4
52691: PPUSH
52692: NOP4
52696: PPUSH
52697: EMPTY
52698: PPUSH
52699: NOP4
52703: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
52704: NOP4
52708: PUSH
52709: NOP4
52713: PPUSH
52714: NOP4
52718: PPUSH
52719: EMPTY
52720: PPUSH
52721: NOP4
52725: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
52726: NOP4
52730: PUSH
52731: NOP4
52735: PPUSH
52736: NOP4
52740: PPUSH
52741: LD_INT 0
52743: PPUSH
52744: NOP4
52748: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
52749: NOP4
52753: PUSH
52754: NOP4
52758: PPUSH
52759: NOP4
52763: PPUSH
52764: LD_INT 0
52766: PPUSH
52767: NOP4
52771: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52772: NOP4
52776: PUSH
52777: NOP4
52781: PPUSH
52782: NOP4
52786: PPUSH
52787: EMPTY
52788: PPUSH
52789: NOP4
52793: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
52794: NOP4
52798: PUSH
52799: NOP4
52803: PPUSH
52804: NOP4
52808: PPUSH
52809: LD_INT 0
52811: PPUSH
52812: NOP4
52816: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
52817: NOP4
52821: PUSH
52822: NOP4
52826: PPUSH
52827: NOP4
52831: PPUSH
52832: EMPTY
52833: PPUSH
52834: NOP4
52838: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
52839: NOP4
52843: PUSH
52844: NOP4
52848: PPUSH
52849: NOP4
52853: PPUSH
52854: LD_INT 0
52856: PPUSH
52857: NOP4
52861: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
52862: NOP4
52866: PUSH
52867: NOP4
52871: PPUSH
52872: NOP4
52876: PPUSH
52877: EMPTY
52878: PPUSH
52879: NOP4
52883: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
52884: NOP4
52888: PUSH
52889: NOP4
52893: PPUSH
52894: NOP4
52898: PPUSH
52899: EMPTY
52900: PPUSH
52901: NOP4
52905: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52906: NOP4
52910: PUSH
52911: NOP4
52915: PPUSH
52916: NOP4
52920: PPUSH
52921: EMPTY
52922: PPUSH
52923: NOP4
52927: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
52928: NOP4
52932: PUSH
52933: NOP4
52937: PPUSH
52938: NOP4
52942: PPUSH
52943: NOP4
52947: PUSH
52948: NOP4
52952: ARRAY
52953: PPUSH
52954: LD_INT 2
52956: PUSH
52957: LD_INT 30
52959: PUSH
52960: LD_INT 6
52962: PUSH
52963: EMPTY
52964: LIST
52965: LIST
52966: PUSH
52967: LD_INT 30
52969: PUSH
52970: LD_INT 7
52972: PUSH
52973: EMPTY
52974: LIST
52975: LIST
52976: PUSH
52977: LD_INT 30
52979: PUSH
52980: LD_INT 8
52982: PUSH
52983: EMPTY
52984: LIST
52985: LIST
52986: PUSH
52987: EMPTY
52988: LIST
52989: LIST
52990: LIST
52991: LIST
52992: PPUSH
52993: NOP4
52997: PPUSH
52998: NOP4
53002: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53003: NOP4
53007: PUSH
53008: NOP4
53012: PPUSH
53013: NOP4
53017: PPUSH
53018: EMPTY
53019: PPUSH
53020: NOP4
53024: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53025: NOP4
53029: PUSH
53030: NOP4
53034: PPUSH
53035: NOP4
53039: PPUSH
53040: EMPTY
53041: PPUSH
53042: NOP4
53046: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53047: NOP4
53051: PUSH
53052: NOP4
53056: PPUSH
53057: NOP4
53061: PPUSH
53062: EMPTY
53063: PPUSH
53064: NOP4
53068: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53069: NOP4
53073: PUSH
53074: NOP4
53078: PPUSH
53079: NOP4
53083: PPUSH
53084: EMPTY
53085: PPUSH
53086: NOP4
53090: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53091: NOP4
53095: PUSH
53096: NOP4
53100: PPUSH
53101: NOP4
53105: PPUSH
53106: EMPTY
53107: PPUSH
53108: NOP4
53112: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53113: NOP4
53117: PUSH
53118: NOP4
53122: PPUSH
53123: NOP4
53127: PPUSH
53128: EMPTY
53129: PPUSH
53130: NOP4
53134: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53135: NOP4
53139: PUSH
53140: NOP4
53144: PPUSH
53145: NOP4
53149: PPUSH
53150: EMPTY
53151: PPUSH
53152: NOP4
53156: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53157: NOP4
53161: PUSH
53162: NOP4
53166: PPUSH
53167: NOP4
53171: PPUSH
53172: EMPTY
53173: PPUSH
53174: NOP4
53178: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53179: NOP4
53183: PUSH
53184: NOP4
53188: PPUSH
53189: NOP4
53193: PPUSH
53194: LD_INT 0
53196: PPUSH
53197: NOP4
53201: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
53202: NOP4
53206: PUSH
53207: NOP4
53211: PPUSH
53212: NOP4
53216: PPUSH
53217: LD_INT 0
53219: PPUSH
53220: NOP4
53224: ST_TO_ADDR
// end ;
53225: GO 52126
53227: POP
53228: POP
// MC_InitSides ( ) ;
53229: NOP4
// MC_InitResearch ( ) ;
53233: NOP4
// CustomInitMacro ( ) ;
53237: NOP4
// skirmish := true ;
53241: NOP4
53245: PUSH
53246: LD_INT 1
53248: ST_TO_ADDR
// end ;
53249: LD_VAR 0 1
53253: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53254: LD_INT 0
53256: PPUSH
53257: PPUSH
53258: PPUSH
53259: PPUSH
53260: PPUSH
53261: PPUSH
// if not mc_bases then
53262: NOP4
53266: NOT
53267: IFFALSE 53271
// exit ;
53269: GO 53510
// for i = 1 to 8 do
53271: NOP4
53275: PUSH
53276: DOUBLE
53277: LD_INT 1
53279: DEC
53280: ST_TO_ADDR
53281: LD_INT 8
53283: PUSH
53284: FOR_TO
53285: IFFALSE 53311
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53287: NOP4
53291: PUSH
53292: NOP4
53296: PPUSH
53297: NOP4
53301: PPUSH
53302: EMPTY
53303: PPUSH
53304: NOP4
53308: ST_TO_ADDR
53309: GO 53284
53311: POP
53312: POP
// tmp := [ ] ;
53313: NOP4
53317: PUSH
53318: EMPTY
53319: ST_TO_ADDR
// for i = 1 to mc_sides do
53320: NOP4
53324: PUSH
53325: DOUBLE
53326: LD_INT 1
53328: DEC
53329: ST_TO_ADDR
53330: NOP4
53334: PUSH
53335: FOR_TO
53336: IFFALSE 53394
// if not mc_sides [ i ] in tmp then
53338: NOP4
53342: PUSH
53343: NOP4
53347: ARRAY
53348: PUSH
53349: NOP4
53353: IN
53354: NOT
53355: IFFALSE 53392
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53357: NOP4
53361: PUSH
53362: NOP4
53366: PPUSH
53367: NOP4
53371: PUSH
53372: LD_INT 1
53374: PLUS
53375: PPUSH
53376: NOP4
53380: PUSH
53381: NOP4
53385: ARRAY
53386: PPUSH
53387: NOP4
53391: ST_TO_ADDR
53392: GO 53335
53394: POP
53395: POP
// if not tmp then
53396: NOP4
53400: NOT
53401: IFFALSE 53405
// exit ;
53403: GO 53510
// for j in tmp do
53405: NOP4
53409: PUSH
53410: NOP4
53414: PUSH
53415: FOR_IN
53416: IFFALSE 53508
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
53418: NOP4
53422: PUSH
53423: LD_INT 22
53425: PUSH
53426: NOP4
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: PPUSH
53435: NOP4
53439: ST_TO_ADDR
// if not un then
53440: NOP4
53444: NOT
53445: IFFALSE 53449
// continue ;
53447: GO 53415
// nation := GetNation ( un [ 1 ] ) ;
53449: NOP4
53453: PUSH
53454: NOP4
53458: PUSH
53459: LD_INT 1
53461: ARRAY
53462: PPUSH
53463: NOP4
53467: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
53468: NOP4
53472: PUSH
53473: NOP4
53477: PPUSH
53478: NOP4
53482: PPUSH
53483: NOP4
53487: PPUSH
53488: NOP4
53492: PPUSH
53493: LD_INT 1
53495: PPUSH
53496: NOP4
53500: PPUSH
53501: NOP4
53505: ST_TO_ADDR
// end ;
53506: GO 53415
53508: POP
53509: POP
// end ;
53510: LD_VAR 0 1
53514: RET
// export function MC_InitSides ( ) ; var i ; begin
53515: LD_INT 0
53517: PPUSH
53518: PPUSH
// if not mc_bases then
53519: NOP4
53523: NOT
53524: IFFALSE 53528
// exit ;
53526: GO 53602
// for i = 1 to mc_bases do
53528: NOP4
53532: PUSH
53533: DOUBLE
53534: LD_INT 1
53536: DEC
53537: ST_TO_ADDR
53538: NOP4
53542: PUSH
53543: FOR_TO
53544: IFFALSE 53600
// if mc_bases [ i ] then
53546: NOP4
53550: PUSH
53551: NOP4
53555: ARRAY
53556: IFFALSE 53598
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
53558: NOP4
53562: PUSH
53563: NOP4
53567: PPUSH
53568: NOP4
53572: PPUSH
53573: NOP4
53577: PUSH
53578: NOP4
53582: ARRAY
53583: PUSH
53584: LD_INT 1
53586: ARRAY
53587: PPUSH
53588: NOP4
53592: PPUSH
53593: NOP4
53597: ST_TO_ADDR
53598: GO 53543
53600: POP
53601: POP
// end ;
53602: LD_VAR 0 1
53606: RET
// every 0 0$03 trigger skirmish do
53607: NOP4
53611: IFFALSE 53765
53613: GO 53615
53615: DISABLE
// begin enable ;
53616: ENABLE
// MC_CheckBuildings ( ) ;
53617: NOP4
// MC_CheckPeopleLife ( ) ;
53621: NOP4
// RaiseSailEvent ( 100 ) ;
53625: LD_INT 100
53627: PPUSH
53628: NOP4
// RaiseSailEvent ( 103 ) ;
53632: LD_INT 103
53634: PPUSH
53635: NOP4
// RaiseSailEvent ( 104 ) ;
53639: LD_INT 104
53641: PPUSH
53642: NOP4
// RaiseSailEvent ( 105 ) ;
53646: LD_INT 105
53648: PPUSH
53649: NOP4
// RaiseSailEvent ( 106 ) ;
53653: LD_INT 106
53655: PPUSH
53656: NOP4
// RaiseSailEvent ( 107 ) ;
53660: LD_INT 107
53662: PPUSH
53663: NOP4
// RaiseSailEvent ( 108 ) ;
53667: LD_INT 108
53669: PPUSH
53670: NOP4
// RaiseSailEvent ( 109 ) ;
53674: LD_INT 109
53676: PPUSH
53677: NOP4
// RaiseSailEvent ( 110 ) ;
53681: LD_INT 110
53683: PPUSH
53684: NOP4
// RaiseSailEvent ( 111 ) ;
53688: LD_INT 111
53690: PPUSH
53691: NOP4
// RaiseSailEvent ( 112 ) ;
53695: LD_INT 112
53697: PPUSH
53698: NOP4
// RaiseSailEvent ( 113 ) ;
53702: LD_INT 113
53704: PPUSH
53705: NOP4
// RaiseSailEvent ( 120 ) ;
53709: LD_INT 120
53711: PPUSH
53712: NOP4
// RaiseSailEvent ( 121 ) ;
53716: LD_INT 121
53718: PPUSH
53719: NOP4
// RaiseSailEvent ( 122 ) ;
53723: LD_INT 122
53725: PPUSH
53726: NOP4
// RaiseSailEvent ( 123 ) ;
53730: LD_INT 123
53732: PPUSH
53733: NOP4
// RaiseSailEvent ( 124 ) ;
53737: LD_INT 124
53739: PPUSH
53740: NOP4
// RaiseSailEvent ( 125 ) ;
53744: LD_INT 125
53746: PPUSH
53747: NOP4
// RaiseSailEvent ( 126 ) ;
53751: LD_INT 126
53753: PPUSH
53754: NOP4
// RaiseSailEvent ( 200 ) ;
53758: LD_INT 200
53760: PPUSH
53761: NOP4
// end ;
53765: END
// on SailEvent ( event ) do begin if event < 100 then
53766: NOP4
53770: PUSH
53771: LD_INT 100
53773: LESS
53774: IFFALSE 53785
// CustomEvent ( event ) ;
53776: NOP4
53780: PPUSH
53781: NOP4
// if event = 100 then
53785: NOP4
53789: PUSH
53790: LD_INT 100
53792: EQUAL
53793: IFFALSE 53799
// MC_ClassManager ( ) ;
53795: NOP4
// if event = 101 then
53799: NOP4
53803: PUSH
53804: LD_INT 101
53806: EQUAL
53807: IFFALSE 53813
// MC_RepairBuildings ( ) ;
53809: NOP4
// if event = 102 then
53813: NOP4
53817: PUSH
53818: LD_INT 102
53820: EQUAL
53821: IFFALSE 53827
// MC_Heal ( ) ;
53823: NOP4
// if event = 103 then
53827: NOP4
53831: PUSH
53832: LD_INT 103
53834: EQUAL
53835: IFFALSE 53841
// MC_Build ( ) ;
53837: NOP4
// if event = 104 then
53841: NOP4
53845: PUSH
53846: LD_INT 104
53848: EQUAL
53849: IFFALSE 53855
// MC_TurretWeapon ( ) ;
53851: NOP4
// if event = 105 then
53855: NOP4
53859: PUSH
53860: LD_INT 105
53862: EQUAL
53863: IFFALSE 53869
// MC_BuildUpgrade ( ) ;
53865: NOP4
// if event = 106 then
53869: NOP4
53873: PUSH
53874: LD_INT 106
53876: EQUAL
53877: IFFALSE 53883
// MC_PlantMines ( ) ;
53879: NOP4
// if event = 107 then
53883: NOP4
53887: PUSH
53888: LD_INT 107
53890: EQUAL
53891: IFFALSE 53897
// MC_CollectCrates ( ) ;
53893: NOP4
// if event = 108 then
53897: NOP4
53901: PUSH
53902: LD_INT 108
53904: EQUAL
53905: IFFALSE 53911
// MC_LinkRemoteControl ( ) ;
53907: NOP4
// if event = 109 then
53911: NOP4
53915: PUSH
53916: LD_INT 109
53918: EQUAL
53919: IFFALSE 53925
// MC_ProduceVehicle ( ) ;
53921: NOP4
// if event = 110 then
53925: NOP4
53929: PUSH
53930: LD_INT 110
53932: EQUAL
53933: IFFALSE 53939
// MC_SendAttack ( ) ;
53935: NOP4
// if event = 111 then
53939: NOP4
53943: PUSH
53944: LD_INT 111
53946: EQUAL
53947: IFFALSE 53953
// MC_Defend ( ) ;
53949: NOP4
// if event = 112 then
53953: NOP4
53957: PUSH
53958: LD_INT 112
53960: EQUAL
53961: IFFALSE 53967
// MC_Research ( ) ;
53963: NOP4
// if event = 113 then
53967: NOP4
53971: PUSH
53972: LD_INT 113
53974: EQUAL
53975: IFFALSE 53981
// MC_MinesTrigger ( ) ;
53977: NOP4
// if event = 120 then
53981: NOP4
53985: PUSH
53986: LD_INT 120
53988: EQUAL
53989: IFFALSE 53995
// MC_RepairVehicle ( ) ;
53991: NOP4
// if event = 121 then
53995: NOP4
53999: PUSH
54000: LD_INT 121
54002: EQUAL
54003: IFFALSE 54009
// MC_TameApe ( ) ;
54005: NOP4
// if event = 122 then
54009: NOP4
54013: PUSH
54014: LD_INT 122
54016: EQUAL
54017: IFFALSE 54023
// MC_ChangeApeClass ( ) ;
54019: NOP4
// if event = 123 then
54023: NOP4
54027: PUSH
54028: LD_INT 123
54030: EQUAL
54031: IFFALSE 54037
// MC_Bazooka ( ) ;
54033: NOP4
// if event = 124 then
54037: NOP4
54041: PUSH
54042: LD_INT 124
54044: EQUAL
54045: IFFALSE 54051
// MC_TeleportExit ( ) ;
54047: NOP4
// if event = 125 then
54051: NOP4
54055: PUSH
54056: LD_INT 125
54058: EQUAL
54059: IFFALSE 54065
// MC_Deposits ( ) ;
54061: NOP4
// if event = 126 then
54065: NOP4
54069: PUSH
54070: LD_INT 126
54072: EQUAL
54073: IFFALSE 54079
// MC_RemoteDriver ( ) ;
54075: NOP4
// if event = 200 then
54079: NOP4
54083: PUSH
54084: LD_INT 200
54086: EQUAL
54087: IFFALSE 54093
// MC_Idle ( ) ;
54089: NOP4
// end ;
54093: PPOPN 1
54095: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54096: LD_INT 0
54098: PPUSH
54099: PPUSH
// if not mc_bases [ base ] or not tag then
54100: NOP4
54104: PUSH
54105: NOP4
54109: ARRAY
54110: NOT
54111: PUSH
54112: NOP4
54116: NOT
54117: OR
54118: IFFALSE 54122
// exit ;
54120: GO 54186
// for i in mc_bases [ base ] union mc_ape [ base ] do
54122: NOP4
54126: PUSH
54127: NOP4
54131: PUSH
54132: NOP4
54136: ARRAY
54137: PUSH
54138: NOP4
54142: PUSH
54143: NOP4
54147: ARRAY
54148: UNION
54149: PUSH
54150: FOR_IN
54151: IFFALSE 54184
// if GetTag ( i ) = tag then
54153: NOP4
54157: PPUSH
54158: NOP4
54162: PUSH
54163: NOP4
54167: EQUAL
54168: IFFALSE 54182
// SetTag ( i , 0 ) ;
54170: NOP4
54174: PPUSH
54175: LD_INT 0
54177: PPUSH
54178: NOP4
54182: GO 54150
54184: POP
54185: POP
// end ;
54186: LD_VAR 0 3
54190: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54191: LD_INT 0
54193: PPUSH
54194: PPUSH
54195: PPUSH
54196: PPUSH
54197: PPUSH
54198: PPUSH
54199: PPUSH
54200: PPUSH
// if not mc_bases then
54201: NOP4
54205: NOT
54206: IFFALSE 54210
// exit ;
54208: GO 54668
// for i = 1 to mc_bases do
54210: NOP4
54214: PUSH
54215: DOUBLE
54216: LD_INT 1
54218: DEC
54219: ST_TO_ADDR
54220: NOP4
54224: PUSH
54225: FOR_TO
54226: IFFALSE 54666
// begin tmp := MC_ClassCheckReq ( i ) ;
54228: NOP4
54232: PUSH
54233: NOP4
54237: PPUSH
54238: NOP4
54242: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54243: NOP4
54247: PUSH
54248: NOP4
54252: PPUSH
54253: NOP4
54257: PPUSH
54258: NOP4
54262: PPUSH
54263: NOP4
54267: ST_TO_ADDR
// if not tmp then
54268: NOP4
54272: NOT
54273: IFFALSE 54277
// continue ;
54275: GO 54225
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54277: NOP4
54281: PUSH
54282: NOP4
54286: PUSH
54287: NOP4
54291: ARRAY
54292: PPUSH
54293: LD_INT 2
54295: PUSH
54296: LD_INT 30
54298: PUSH
54299: LD_INT 4
54301: PUSH
54302: EMPTY
54303: LIST
54304: LIST
54305: PUSH
54306: LD_INT 30
54308: PUSH
54309: LD_INT 5
54311: PUSH
54312: EMPTY
54313: LIST
54314: LIST
54315: PUSH
54316: EMPTY
54317: LIST
54318: LIST
54319: LIST
54320: PPUSH
54321: NOP4
54325: PUSH
54326: NOP4
54330: PUSH
54331: NOP4
54335: ARRAY
54336: PPUSH
54337: LD_INT 2
54339: PUSH
54340: LD_INT 30
54342: PUSH
54343: LD_INT 0
54345: PUSH
54346: EMPTY
54347: LIST
54348: LIST
54349: PUSH
54350: LD_INT 30
54352: PUSH
54353: LD_INT 1
54355: PUSH
54356: EMPTY
54357: LIST
54358: LIST
54359: PUSH
54360: EMPTY
54361: LIST
54362: LIST
54363: LIST
54364: PPUSH
54365: NOP4
54369: PUSH
54370: NOP4
54374: PUSH
54375: NOP4
54379: ARRAY
54380: PPUSH
54381: LD_INT 30
54383: PUSH
54384: LD_INT 3
54386: PUSH
54387: EMPTY
54388: LIST
54389: LIST
54390: PPUSH
54391: NOP4
54395: PUSH
54396: NOP4
54400: PUSH
54401: NOP4
54405: ARRAY
54406: PPUSH
54407: LD_INT 2
54409: PUSH
54410: LD_INT 30
54412: PUSH
54413: LD_INT 6
54415: PUSH
54416: EMPTY
54417: LIST
54418: LIST
54419: PUSH
54420: LD_INT 30
54422: PUSH
54423: LD_INT 7
54425: PUSH
54426: EMPTY
54427: LIST
54428: LIST
54429: PUSH
54430: LD_INT 30
54432: PUSH
54433: LD_INT 8
54435: PUSH
54436: EMPTY
54437: LIST
54438: LIST
54439: PUSH
54440: EMPTY
54441: LIST
54442: LIST
54443: LIST
54444: LIST
54445: PPUSH
54446: NOP4
54450: PUSH
54451: EMPTY
54452: LIST
54453: LIST
54454: LIST
54455: LIST
54456: ST_TO_ADDR
// for j = 1 to 4 do
54457: NOP4
54461: PUSH
54462: DOUBLE
54463: LD_INT 1
54465: DEC
54466: ST_TO_ADDR
54467: LD_INT 4
54469: PUSH
54470: FOR_TO
54471: IFFALSE 54662
// begin if not tmp [ j ] then
54473: NOP4
54477: PUSH
54478: NOP4
54482: ARRAY
54483: NOT
54484: IFFALSE 54488
// continue ;
54486: GO 54470
// for p in tmp [ j ] do
54488: NOP4
54492: PUSH
54493: NOP4
54497: PUSH
54498: NOP4
54502: ARRAY
54503: PUSH
54504: FOR_IN
54505: IFFALSE 54658
// begin if not b [ j ] then
54507: NOP4
54511: PUSH
54512: NOP4
54516: ARRAY
54517: NOT
54518: IFFALSE 54522
// break ;
54520: GO 54658
// e := 0 ;
54522: NOP4
54526: PUSH
54527: LD_INT 0
54529: ST_TO_ADDR
// for k in b [ j ] do
54530: NOP4
54534: PUSH
54535: NOP4
54539: PUSH
54540: NOP4
54544: ARRAY
54545: PUSH
54546: FOR_IN
54547: IFFALSE 54574
// if IsNotFull ( k ) then
54549: NOP4
54553: PPUSH
54554: NOP4
54558: IFFALSE 54572
// begin e := k ;
54560: NOP4
54564: PUSH
54565: NOP4
54569: ST_TO_ADDR
// break ;
54570: GO 54574
// end ;
54572: GO 54546
54574: POP
54575: POP
// if e and not UnitGoingToBuilding ( p , e ) then
54576: NOP4
54580: PUSH
54581: NOP4
54585: PPUSH
54586: NOP4
54590: PPUSH
54591: NOP4
54595: NOT
54596: AND
54597: IFFALSE 54656
// begin if IsInUnit ( p ) then
54599: NOP4
54603: PPUSH
54604: NOP4
54608: IFFALSE 54619
// ComExitBuilding ( p ) ;
54610: NOP4
54614: PPUSH
54615: NOP4
// ComEnterUnit ( p , e ) ;
54619: NOP4
54623: PPUSH
54624: NOP4
54628: PPUSH
54629: NOP4
// AddComChangeProfession ( p , j ) ;
54633: NOP4
54637: PPUSH
54638: NOP4
54642: PPUSH
54643: NOP4
// AddComExitBuilding ( p ) ;
54647: NOP4
54651: PPUSH
54652: NOP4
// end ; end ;
54656: GO 54504
54658: POP
54659: POP
// end ;
54660: GO 54470
54662: POP
54663: POP
// end ;
54664: GO 54225
54666: POP
54667: POP
// end ;
54668: LD_VAR 0 1
54672: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
54673: LD_INT 0
54675: PPUSH
54676: PPUSH
54677: PPUSH
54678: PPUSH
54679: PPUSH
54680: PPUSH
54681: PPUSH
54682: PPUSH
54683: PPUSH
54684: PPUSH
54685: PPUSH
54686: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54687: NOP4
54691: NOT
54692: PUSH
54693: NOP4
54697: PUSH
54698: NOP4
54702: ARRAY
54703: NOT
54704: OR
54705: PUSH
54706: NOP4
54710: PUSH
54711: NOP4
54715: ARRAY
54716: PPUSH
54717: LD_INT 2
54719: PUSH
54720: LD_INT 30
54722: PUSH
54723: LD_INT 0
54725: PUSH
54726: EMPTY
54727: LIST
54728: LIST
54729: PUSH
54730: LD_INT 30
54732: PUSH
54733: LD_INT 1
54735: PUSH
54736: EMPTY
54737: LIST
54738: LIST
54739: PUSH
54740: EMPTY
54741: LIST
54742: LIST
54743: LIST
54744: PPUSH
54745: NOP4
54749: NOT
54750: OR
54751: IFFALSE 54755
// exit ;
54753: GO 58258
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54755: NOP4
54759: PUSH
54760: NOP4
54764: PUSH
54765: NOP4
54769: ARRAY
54770: PPUSH
54771: LD_INT 2
54773: PUSH
54774: LD_INT 25
54776: PUSH
54777: LD_INT 1
54779: PUSH
54780: EMPTY
54781: LIST
54782: LIST
54783: PUSH
54784: LD_INT 25
54786: PUSH
54787: LD_INT 2
54789: PUSH
54790: EMPTY
54791: LIST
54792: LIST
54793: PUSH
54794: LD_INT 25
54796: PUSH
54797: LD_INT 3
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: PUSH
54804: LD_INT 25
54806: PUSH
54807: LD_INT 4
54809: PUSH
54810: EMPTY
54811: LIST
54812: LIST
54813: PUSH
54814: LD_INT 25
54816: PUSH
54817: LD_INT 5
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: PUSH
54824: LD_INT 25
54826: PUSH
54827: LD_INT 8
54829: PUSH
54830: EMPTY
54831: LIST
54832: LIST
54833: PUSH
54834: LD_INT 25
54836: PUSH
54837: LD_INT 9
54839: PUSH
54840: EMPTY
54841: LIST
54842: LIST
54843: PUSH
54844: EMPTY
54845: LIST
54846: LIST
54847: LIST
54848: LIST
54849: LIST
54850: LIST
54851: LIST
54852: LIST
54853: PPUSH
54854: NOP4
54858: ST_TO_ADDR
// if not tmp then
54859: NOP4
54863: NOT
54864: IFFALSE 54868
// exit ;
54866: GO 58258
// for i in tmp do
54868: NOP4
54872: PUSH
54873: NOP4
54877: PUSH
54878: FOR_IN
54879: IFFALSE 54910
// if GetTag ( i ) then
54881: NOP4
54885: PPUSH
54886: NOP4
54890: IFFALSE 54908
// tmp := tmp diff i ;
54892: NOP4
54896: PUSH
54897: NOP4
54901: PUSH
54902: NOP4
54906: DIFF
54907: ST_TO_ADDR
54908: GO 54878
54910: POP
54911: POP
// if not tmp then
54912: NOP4
54916: NOT
54917: IFFALSE 54921
// exit ;
54919: GO 58258
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54921: NOP4
54925: PUSH
54926: NOP4
54930: PUSH
54931: NOP4
54935: ARRAY
54936: PPUSH
54937: LD_INT 2
54939: PUSH
54940: LD_INT 25
54942: PUSH
54943: LD_INT 1
54945: PUSH
54946: EMPTY
54947: LIST
54948: LIST
54949: PUSH
54950: LD_INT 25
54952: PUSH
54953: LD_INT 5
54955: PUSH
54956: EMPTY
54957: LIST
54958: LIST
54959: PUSH
54960: LD_INT 25
54962: PUSH
54963: LD_INT 8
54965: PUSH
54966: EMPTY
54967: LIST
54968: LIST
54969: PUSH
54970: LD_INT 25
54972: PUSH
54973: LD_INT 9
54975: PUSH
54976: EMPTY
54977: LIST
54978: LIST
54979: PUSH
54980: EMPTY
54981: LIST
54982: LIST
54983: LIST
54984: LIST
54985: LIST
54986: PPUSH
54987: NOP4
54991: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
54992: NOP4
54996: PUSH
54997: NOP4
55001: PUSH
55002: NOP4
55006: ARRAY
55007: PPUSH
55008: LD_INT 25
55010: PUSH
55011: LD_INT 2
55013: PUSH
55014: EMPTY
55015: LIST
55016: LIST
55017: PPUSH
55018: NOP4
55022: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55023: NOP4
55027: PUSH
55028: NOP4
55032: PUSH
55033: NOP4
55037: ARRAY
55038: PPUSH
55039: LD_INT 25
55041: PUSH
55042: LD_INT 3
55044: PUSH
55045: EMPTY
55046: LIST
55047: LIST
55048: PPUSH
55049: NOP4
55053: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55054: NOP4
55058: PUSH
55059: NOP4
55063: PUSH
55064: NOP4
55068: ARRAY
55069: PPUSH
55070: LD_INT 25
55072: PUSH
55073: LD_INT 4
55075: PUSH
55076: EMPTY
55077: LIST
55078: LIST
55079: PUSH
55080: LD_INT 24
55082: PUSH
55083: LD_INT 251
55085: PUSH
55086: EMPTY
55087: LIST
55088: LIST
55089: PUSH
55090: EMPTY
55091: LIST
55092: LIST
55093: PPUSH
55094: NOP4
55098: ST_TO_ADDR
// if mc_is_defending [ base ] then
55099: NOP4
55103: PUSH
55104: NOP4
55108: ARRAY
55109: IFFALSE 55570
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55111: NOP4
55115: PUSH
55116: NOP4
55120: PPUSH
55121: NOP4
55125: PPUSH
55126: LD_INT 4
55128: PPUSH
55129: NOP4
55133: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55134: NOP4
55138: PUSH
55139: NOP4
55143: PUSH
55144: NOP4
55148: ARRAY
55149: PPUSH
55150: LD_INT 2
55152: PUSH
55153: LD_INT 30
55155: PUSH
55156: LD_INT 4
55158: PUSH
55159: EMPTY
55160: LIST
55161: LIST
55162: PUSH
55163: LD_INT 30
55165: PUSH
55166: LD_INT 5
55168: PUSH
55169: EMPTY
55170: LIST
55171: LIST
55172: PUSH
55173: EMPTY
55174: LIST
55175: LIST
55176: LIST
55177: PPUSH
55178: NOP4
55182: ST_TO_ADDR
// if not b then
55183: NOP4
55187: NOT
55188: IFFALSE 55192
// exit ;
55190: GO 58258
// p := [ ] ;
55192: NOP4
55196: PUSH
55197: EMPTY
55198: ST_TO_ADDR
// if sci >= 2 then
55199: NOP4
55203: PUSH
55204: LD_INT 2
55206: GREATEREQUAL
55207: IFFALSE 55238
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55209: NOP4
55213: PUSH
55214: NOP4
55218: PUSH
55219: LD_INT 1
55221: ARRAY
55222: PUSH
55223: NOP4
55227: PUSH
55228: LD_INT 2
55230: ARRAY
55231: PUSH
55232: EMPTY
55233: LIST
55234: LIST
55235: ST_TO_ADDR
55236: GO 55299
// if sci = 1 then
55238: NOP4
55242: PUSH
55243: LD_INT 1
55245: EQUAL
55246: IFFALSE 55267
// sci := [ sci [ 1 ] ] else
55248: NOP4
55252: PUSH
55253: NOP4
55257: PUSH
55258: LD_INT 1
55260: ARRAY
55261: PUSH
55262: EMPTY
55263: LIST
55264: ST_TO_ADDR
55265: GO 55299
// if sci = 0 then
55267: NOP4
55271: PUSH
55272: LD_INT 0
55274: EQUAL
55275: IFFALSE 55299
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55277: NOP4
55281: PUSH
55282: NOP4
55286: PPUSH
55287: LD_INT 4
55289: PPUSH
55290: NOP4
55294: PUSH
55295: LD_INT 1
55297: ARRAY
55298: ST_TO_ADDR
// if eng > 4 then
55299: NOP4
55303: PUSH
55304: LD_INT 4
55306: GREATER
55307: IFFALSE 55353
// for i = eng downto 4 do
55309: NOP4
55313: PUSH
55314: DOUBLE
55315: NOP4
55319: INC
55320: ST_TO_ADDR
55321: LD_INT 4
55323: PUSH
55324: FOR_DOWNTO
55325: IFFALSE 55351
// eng := eng diff eng [ i ] ;
55327: NOP4
55331: PUSH
55332: NOP4
55336: PUSH
55337: NOP4
55341: PUSH
55342: NOP4
55346: ARRAY
55347: DIFF
55348: ST_TO_ADDR
55349: GO 55324
55351: POP
55352: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55353: NOP4
55357: PUSH
55358: NOP4
55362: PUSH
55363: NOP4
55367: PUSH
55368: NOP4
55372: UNION
55373: PUSH
55374: NOP4
55378: UNION
55379: PUSH
55380: NOP4
55384: UNION
55385: DIFF
55386: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
55387: NOP4
55391: PUSH
55392: NOP4
55396: PUSH
55397: NOP4
55401: ARRAY
55402: PPUSH
55403: LD_INT 2
55405: PUSH
55406: LD_INT 30
55408: PUSH
55409: LD_INT 32
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: PUSH
55416: LD_INT 30
55418: PUSH
55419: LD_INT 31
55421: PUSH
55422: EMPTY
55423: LIST
55424: LIST
55425: PUSH
55426: EMPTY
55427: LIST
55428: LIST
55429: LIST
55430: PPUSH
55431: NOP4
55435: PUSH
55436: NOP4
55440: PUSH
55441: NOP4
55445: ARRAY
55446: PPUSH
55447: LD_INT 2
55449: PUSH
55450: LD_INT 30
55452: PUSH
55453: LD_INT 4
55455: PUSH
55456: EMPTY
55457: LIST
55458: LIST
55459: PUSH
55460: LD_INT 30
55462: PUSH
55463: LD_INT 5
55465: PUSH
55466: EMPTY
55467: LIST
55468: LIST
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: LIST
55474: PPUSH
55475: NOP4
55479: PUSH
55480: LD_INT 6
55482: MUL
55483: PLUS
55484: ST_TO_ADDR
// if bcount < tmp then
55485: NOP4
55489: PUSH
55490: NOP4
55494: LESS
55495: IFFALSE 55541
// for i = tmp downto bcount do
55497: NOP4
55501: PUSH
55502: DOUBLE
55503: NOP4
55507: INC
55508: ST_TO_ADDR
55509: NOP4
55513: PUSH
55514: FOR_DOWNTO
55515: IFFALSE 55539
// tmp := Delete ( tmp , tmp ) ;
55517: NOP4
55521: PUSH
55522: NOP4
55526: PPUSH
55527: NOP4
55531: PPUSH
55532: NOP4
55536: ST_TO_ADDR
55537: GO 55514
55539: POP
55540: POP
// result := [ tmp , 0 , 0 , p ] ;
55541: NOP4
55545: PUSH
55546: NOP4
55550: PUSH
55551: LD_INT 0
55553: PUSH
55554: LD_INT 0
55556: PUSH
55557: NOP4
55561: PUSH
55562: EMPTY
55563: LIST
55564: LIST
55565: LIST
55566: LIST
55567: ST_TO_ADDR
// exit ;
55568: GO 58258
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55570: NOP4
55574: PUSH
55575: NOP4
55579: ARRAY
55580: PPUSH
55581: LD_INT 2
55583: PUSH
55584: LD_INT 30
55586: PUSH
55587: LD_INT 6
55589: PUSH
55590: EMPTY
55591: LIST
55592: LIST
55593: PUSH
55594: LD_INT 30
55596: PUSH
55597: LD_INT 7
55599: PUSH
55600: EMPTY
55601: LIST
55602: LIST
55603: PUSH
55604: LD_INT 30
55606: PUSH
55607: LD_INT 8
55609: PUSH
55610: EMPTY
55611: LIST
55612: LIST
55613: PUSH
55614: EMPTY
55615: LIST
55616: LIST
55617: LIST
55618: LIST
55619: PPUSH
55620: NOP4
55624: NOT
55625: PUSH
55626: NOP4
55630: PUSH
55631: NOP4
55635: ARRAY
55636: PPUSH
55637: LD_INT 30
55639: PUSH
55640: LD_INT 3
55642: PUSH
55643: EMPTY
55644: LIST
55645: LIST
55646: PPUSH
55647: NOP4
55651: NOT
55652: AND
55653: IFFALSE 55725
// begin if eng = tmp then
55655: NOP4
55659: PUSH
55660: NOP4
55664: EQUAL
55665: IFFALSE 55669
// exit ;
55667: GO 58258
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
55669: NOP4
55673: PUSH
55674: NOP4
55678: PPUSH
55679: NOP4
55683: PPUSH
55684: LD_INT 1
55686: PPUSH
55687: NOP4
55691: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
55692: NOP4
55696: PUSH
55697: LD_INT 0
55699: PUSH
55700: NOP4
55704: PUSH
55705: NOP4
55709: DIFF
55710: PUSH
55711: LD_INT 0
55713: PUSH
55714: LD_INT 0
55716: PUSH
55717: EMPTY
55718: LIST
55719: LIST
55720: LIST
55721: LIST
55722: ST_TO_ADDR
// exit ;
55723: GO 58258
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55725: NOP4
55729: PUSH
55730: NOP4
55734: PUSH
55735: NOP4
55739: ARRAY
55740: ARRAY
55741: PUSH
55742: NOP4
55746: PUSH
55747: NOP4
55751: ARRAY
55752: PPUSH
55753: LD_INT 2
55755: PUSH
55756: LD_INT 30
55758: PUSH
55759: LD_INT 6
55761: PUSH
55762: EMPTY
55763: LIST
55764: LIST
55765: PUSH
55766: LD_INT 30
55768: PUSH
55769: LD_INT 7
55771: PUSH
55772: EMPTY
55773: LIST
55774: LIST
55775: PUSH
55776: LD_INT 30
55778: PUSH
55779: LD_INT 8
55781: PUSH
55782: EMPTY
55783: LIST
55784: LIST
55785: PUSH
55786: EMPTY
55787: LIST
55788: LIST
55789: LIST
55790: LIST
55791: PPUSH
55792: NOP4
55796: AND
55797: PUSH
55798: NOP4
55802: PUSH
55803: NOP4
55807: ARRAY
55808: PPUSH
55809: LD_INT 30
55811: PUSH
55812: LD_INT 3
55814: PUSH
55815: EMPTY
55816: LIST
55817: LIST
55818: PPUSH
55819: NOP4
55823: NOT
55824: AND
55825: IFFALSE 56039
// begin if sci >= 6 then
55827: NOP4
55831: PUSH
55832: LD_INT 6
55834: GREATEREQUAL
55835: IFFALSE 55839
// exit ;
55837: GO 58258
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
55839: NOP4
55843: PUSH
55844: NOP4
55848: PPUSH
55849: NOP4
55853: PPUSH
55854: LD_INT 2
55856: PPUSH
55857: NOP4
55861: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
55862: NOP4
55866: PUSH
55867: NOP4
55871: PUSH
55872: NOP4
55876: DIFF
55877: PPUSH
55878: LD_INT 4
55880: PPUSH
55881: NOP4
55885: ST_TO_ADDR
// p := [ ] ;
55886: NOP4
55890: PUSH
55891: EMPTY
55892: ST_TO_ADDR
// if sci < 6 and sort > 6 then
55893: NOP4
55897: PUSH
55898: LD_INT 6
55900: LESS
55901: PUSH
55902: NOP4
55906: PUSH
55907: LD_INT 6
55909: GREATER
55910: AND
55911: IFFALSE 55992
// begin for i = 1 to 6 - sci do
55913: NOP4
55917: PUSH
55918: DOUBLE
55919: LD_INT 1
55921: DEC
55922: ST_TO_ADDR
55923: LD_INT 6
55925: PUSH
55926: NOP4
55930: MINUS
55931: PUSH
55932: FOR_TO
55933: IFFALSE 55988
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
55935: NOP4
55939: PUSH
55940: NOP4
55944: PPUSH
55945: NOP4
55949: PUSH
55950: LD_INT 1
55952: PLUS
55953: PPUSH
55954: NOP4
55958: PUSH
55959: LD_INT 1
55961: ARRAY
55962: PPUSH
55963: NOP4
55967: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
55968: NOP4
55972: PUSH
55973: NOP4
55977: PPUSH
55978: LD_INT 1
55980: PPUSH
55981: NOP4
55985: ST_TO_ADDR
// end ;
55986: GO 55932
55988: POP
55989: POP
// end else
55990: GO 56012
// if sort then
55992: NOP4
55996: IFFALSE 56012
// p := sort [ 1 ] ;
55998: NOP4
56002: PUSH
56003: NOP4
56007: PUSH
56008: LD_INT 1
56010: ARRAY
56011: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56012: NOP4
56016: PUSH
56017: LD_INT 0
56019: PUSH
56020: LD_INT 0
56022: PUSH
56023: LD_INT 0
56025: PUSH
56026: NOP4
56030: PUSH
56031: EMPTY
56032: LIST
56033: LIST
56034: LIST
56035: LIST
56036: ST_TO_ADDR
// exit ;
56037: GO 58258
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56039: NOP4
56043: PUSH
56044: NOP4
56048: PUSH
56049: NOP4
56053: ARRAY
56054: ARRAY
56055: PUSH
56056: NOP4
56060: PUSH
56061: NOP4
56065: ARRAY
56066: PPUSH
56067: LD_INT 2
56069: PUSH
56070: LD_INT 30
56072: PUSH
56073: LD_INT 6
56075: PUSH
56076: EMPTY
56077: LIST
56078: LIST
56079: PUSH
56080: LD_INT 30
56082: PUSH
56083: LD_INT 7
56085: PUSH
56086: EMPTY
56087: LIST
56088: LIST
56089: PUSH
56090: LD_INT 30
56092: PUSH
56093: LD_INT 8
56095: PUSH
56096: EMPTY
56097: LIST
56098: LIST
56099: PUSH
56100: EMPTY
56101: LIST
56102: LIST
56103: LIST
56104: LIST
56105: PPUSH
56106: NOP4
56110: AND
56111: PUSH
56112: NOP4
56116: PUSH
56117: NOP4
56121: ARRAY
56122: PPUSH
56123: LD_INT 30
56125: PUSH
56126: LD_INT 3
56128: PUSH
56129: EMPTY
56130: LIST
56131: LIST
56132: PPUSH
56133: NOP4
56137: AND
56138: IFFALSE 56872
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56140: NOP4
56144: PUSH
56145: NOP4
56149: PPUSH
56150: NOP4
56154: PPUSH
56155: LD_INT 3
56157: PPUSH
56158: NOP4
56162: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56163: NOP4
56167: PUSH
56168: LD_INT 0
56170: PUSH
56171: LD_INT 0
56173: PUSH
56174: LD_INT 0
56176: PUSH
56177: LD_INT 0
56179: PUSH
56180: EMPTY
56181: LIST
56182: LIST
56183: LIST
56184: LIST
56185: ST_TO_ADDR
// if not eng then
56186: NOP4
56190: NOT
56191: IFFALSE 56254
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56193: NOP4
56197: PUSH
56198: NOP4
56202: PPUSH
56203: LD_INT 2
56205: PPUSH
56206: NOP4
56210: PUSH
56211: LD_INT 1
56213: ARRAY
56214: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56215: NOP4
56219: PUSH
56220: NOP4
56224: PPUSH
56225: LD_INT 2
56227: PPUSH
56228: NOP4
56232: PPUSH
56233: NOP4
56237: ST_TO_ADDR
// tmp := tmp diff p ;
56238: NOP4
56242: PUSH
56243: NOP4
56247: PUSH
56248: NOP4
56252: DIFF
56253: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56254: NOP4
56258: PUSH
56259: NOP4
56263: PUSH
56264: LD_INT 6
56266: LESS
56267: AND
56268: IFFALSE 56456
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56270: NOP4
56274: PUSH
56275: NOP4
56279: PUSH
56280: NOP4
56284: PUSH
56285: NOP4
56289: UNION
56290: DIFF
56291: PPUSH
56292: LD_INT 4
56294: PPUSH
56295: NOP4
56299: ST_TO_ADDR
// p := [ ] ;
56300: NOP4
56304: PUSH
56305: EMPTY
56306: ST_TO_ADDR
// if sort then
56307: NOP4
56311: IFFALSE 56427
// for i = 1 to 6 - sci do
56313: NOP4
56317: PUSH
56318: DOUBLE
56319: LD_INT 1
56321: DEC
56322: ST_TO_ADDR
56323: LD_INT 6
56325: PUSH
56326: NOP4
56330: MINUS
56331: PUSH
56332: FOR_TO
56333: IFFALSE 56425
// begin if i = sort then
56335: NOP4
56339: PUSH
56340: NOP4
56344: EQUAL
56345: IFFALSE 56349
// break ;
56347: GO 56425
// if GetClass ( i ) = 4 then
56349: NOP4
56353: PPUSH
56354: NOP4
56358: PUSH
56359: LD_INT 4
56361: EQUAL
56362: IFFALSE 56366
// continue ;
56364: GO 56332
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56366: NOP4
56370: PUSH
56371: NOP4
56375: PPUSH
56376: NOP4
56380: PUSH
56381: LD_INT 1
56383: PLUS
56384: PPUSH
56385: NOP4
56389: PUSH
56390: NOP4
56394: ARRAY
56395: PPUSH
56396: NOP4
56400: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56401: NOP4
56405: PUSH
56406: NOP4
56410: PUSH
56411: NOP4
56415: PUSH
56416: NOP4
56420: ARRAY
56421: DIFF
56422: ST_TO_ADDR
// end ;
56423: GO 56332
56425: POP
56426: POP
// if p then
56427: NOP4
56431: IFFALSE 56456
// result := Replace ( result , 4 , p ) ;
56433: NOP4
56437: PUSH
56438: NOP4
56442: PPUSH
56443: LD_INT 4
56445: PPUSH
56446: NOP4
56450: PPUSH
56451: NOP4
56455: ST_TO_ADDR
// end ; if tmp and mech < 6 then
56456: NOP4
56460: PUSH
56461: NOP4
56465: PUSH
56466: LD_INT 6
56468: LESS
56469: AND
56470: IFFALSE 56658
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56472: NOP4
56476: PUSH
56477: NOP4
56481: PUSH
56482: NOP4
56486: PUSH
56487: NOP4
56491: UNION
56492: DIFF
56493: PPUSH
56494: LD_INT 3
56496: PPUSH
56497: NOP4
56501: ST_TO_ADDR
// p := [ ] ;
56502: NOP4
56506: PUSH
56507: EMPTY
56508: ST_TO_ADDR
// if sort then
56509: NOP4
56513: IFFALSE 56629
// for i = 1 to 6 - mech do
56515: NOP4
56519: PUSH
56520: DOUBLE
56521: LD_INT 1
56523: DEC
56524: ST_TO_ADDR
56525: LD_INT 6
56527: PUSH
56528: NOP4
56532: MINUS
56533: PUSH
56534: FOR_TO
56535: IFFALSE 56627
// begin if i = sort then
56537: NOP4
56541: PUSH
56542: NOP4
56546: EQUAL
56547: IFFALSE 56551
// break ;
56549: GO 56627
// if GetClass ( i ) = 3 then
56551: NOP4
56555: PPUSH
56556: NOP4
56560: PUSH
56561: LD_INT 3
56563: EQUAL
56564: IFFALSE 56568
// continue ;
56566: GO 56534
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56568: NOP4
56572: PUSH
56573: NOP4
56577: PPUSH
56578: NOP4
56582: PUSH
56583: LD_INT 1
56585: PLUS
56586: PPUSH
56587: NOP4
56591: PUSH
56592: NOP4
56596: ARRAY
56597: PPUSH
56598: NOP4
56602: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56603: NOP4
56607: PUSH
56608: NOP4
56612: PUSH
56613: NOP4
56617: PUSH
56618: NOP4
56622: ARRAY
56623: DIFF
56624: ST_TO_ADDR
// end ;
56625: GO 56534
56627: POP
56628: POP
// if p then
56629: NOP4
56633: IFFALSE 56658
// result := Replace ( result , 3 , p ) ;
56635: NOP4
56639: PUSH
56640: NOP4
56644: PPUSH
56645: LD_INT 3
56647: PPUSH
56648: NOP4
56652: PPUSH
56653: NOP4
56657: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
56658: NOP4
56662: PUSH
56663: LD_INT 6
56665: GREATER
56666: PUSH
56667: NOP4
56671: PUSH
56672: LD_INT 6
56674: LESS
56675: AND
56676: IFFALSE 56870
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
56678: NOP4
56682: PUSH
56683: NOP4
56687: PUSH
56688: NOP4
56692: PUSH
56693: NOP4
56697: UNION
56698: PUSH
56699: NOP4
56703: UNION
56704: DIFF
56705: PPUSH
56706: LD_INT 2
56708: PPUSH
56709: NOP4
56713: ST_TO_ADDR
// p := [ ] ;
56714: NOP4
56718: PUSH
56719: EMPTY
56720: ST_TO_ADDR
// if sort then
56721: NOP4
56725: IFFALSE 56841
// for i = 1 to 6 - eng do
56727: NOP4
56731: PUSH
56732: DOUBLE
56733: LD_INT 1
56735: DEC
56736: ST_TO_ADDR
56737: LD_INT 6
56739: PUSH
56740: NOP4
56744: MINUS
56745: PUSH
56746: FOR_TO
56747: IFFALSE 56839
// begin if i = sort then
56749: NOP4
56753: PUSH
56754: NOP4
56758: EQUAL
56759: IFFALSE 56763
// break ;
56761: GO 56839
// if GetClass ( i ) = 2 then
56763: NOP4
56767: PPUSH
56768: NOP4
56772: PUSH
56773: LD_INT 2
56775: EQUAL
56776: IFFALSE 56780
// continue ;
56778: GO 56746
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56780: NOP4
56784: PUSH
56785: NOP4
56789: PPUSH
56790: NOP4
56794: PUSH
56795: LD_INT 1
56797: PLUS
56798: PPUSH
56799: NOP4
56803: PUSH
56804: NOP4
56808: ARRAY
56809: PPUSH
56810: NOP4
56814: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56815: NOP4
56819: PUSH
56820: NOP4
56824: PUSH
56825: NOP4
56829: PUSH
56830: NOP4
56834: ARRAY
56835: DIFF
56836: ST_TO_ADDR
// end ;
56837: GO 56746
56839: POP
56840: POP
// if p then
56841: NOP4
56845: IFFALSE 56870
// result := Replace ( result , 2 , p ) ;
56847: NOP4
56851: PUSH
56852: NOP4
56856: PPUSH
56857: LD_INT 2
56859: PPUSH
56860: NOP4
56864: PPUSH
56865: NOP4
56869: ST_TO_ADDR
// end ; exit ;
56870: GO 58258
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
56872: NOP4
56876: PUSH
56877: NOP4
56881: PUSH
56882: NOP4
56886: ARRAY
56887: ARRAY
56888: NOT
56889: PUSH
56890: NOP4
56894: PUSH
56895: NOP4
56899: ARRAY
56900: PPUSH
56901: LD_INT 30
56903: PUSH
56904: LD_INT 3
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: PPUSH
56911: NOP4
56915: AND
56916: PUSH
56917: NOP4
56921: PUSH
56922: NOP4
56926: ARRAY
56927: AND
56928: IFFALSE 57536
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
56930: NOP4
56934: PUSH
56935: NOP4
56939: PPUSH
56940: NOP4
56944: PPUSH
56945: LD_INT 5
56947: PPUSH
56948: NOP4
56952: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56953: NOP4
56957: PUSH
56958: LD_INT 0
56960: PUSH
56961: LD_INT 0
56963: PUSH
56964: LD_INT 0
56966: PUSH
56967: LD_INT 0
56969: PUSH
56970: EMPTY
56971: LIST
56972: LIST
56973: LIST
56974: LIST
56975: ST_TO_ADDR
// if sci > 1 then
56976: NOP4
56980: PUSH
56981: LD_INT 1
56983: GREATER
56984: IFFALSE 57012
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
56986: NOP4
56990: PUSH
56991: NOP4
56995: PUSH
56996: NOP4
57000: PUSH
57001: NOP4
57005: PUSH
57006: LD_INT 1
57008: ARRAY
57009: DIFF
57010: DIFF
57011: ST_TO_ADDR
// if tmp and not sci then
57012: NOP4
57016: PUSH
57017: NOP4
57021: NOT
57022: AND
57023: IFFALSE 57092
// begin sort := SortBySkill ( tmp , 4 ) ;
57025: NOP4
57029: PUSH
57030: NOP4
57034: PPUSH
57035: LD_INT 4
57037: PPUSH
57038: NOP4
57042: ST_TO_ADDR
// if sort then
57043: NOP4
57047: IFFALSE 57063
// p := sort [ 1 ] ;
57049: NOP4
57053: PUSH
57054: NOP4
57058: PUSH
57059: LD_INT 1
57061: ARRAY
57062: ST_TO_ADDR
// if p then
57063: NOP4
57067: IFFALSE 57092
// result := Replace ( result , 4 , p ) ;
57069: NOP4
57073: PUSH
57074: NOP4
57078: PPUSH
57079: LD_INT 4
57081: PPUSH
57082: NOP4
57086: PPUSH
57087: NOP4
57091: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57092: NOP4
57096: PUSH
57097: NOP4
57101: PUSH
57102: NOP4
57106: DIFF
57107: ST_TO_ADDR
// if tmp and mech < 6 then
57108: NOP4
57112: PUSH
57113: NOP4
57117: PUSH
57118: LD_INT 6
57120: LESS
57121: AND
57122: IFFALSE 57310
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57124: NOP4
57128: PUSH
57129: NOP4
57133: PUSH
57134: NOP4
57138: PUSH
57139: NOP4
57143: UNION
57144: DIFF
57145: PPUSH
57146: LD_INT 3
57148: PPUSH
57149: NOP4
57153: ST_TO_ADDR
// p := [ ] ;
57154: NOP4
57158: PUSH
57159: EMPTY
57160: ST_TO_ADDR
// if sort then
57161: NOP4
57165: IFFALSE 57281
// for i = 1 to 6 - mech do
57167: NOP4
57171: PUSH
57172: DOUBLE
57173: LD_INT 1
57175: DEC
57176: ST_TO_ADDR
57177: LD_INT 6
57179: PUSH
57180: NOP4
57184: MINUS
57185: PUSH
57186: FOR_TO
57187: IFFALSE 57279
// begin if i = sort then
57189: NOP4
57193: PUSH
57194: NOP4
57198: EQUAL
57199: IFFALSE 57203
// break ;
57201: GO 57279
// if GetClass ( i ) = 3 then
57203: NOP4
57207: PPUSH
57208: NOP4
57212: PUSH
57213: LD_INT 3
57215: EQUAL
57216: IFFALSE 57220
// continue ;
57218: GO 57186
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57220: NOP4
57224: PUSH
57225: NOP4
57229: PPUSH
57230: NOP4
57234: PUSH
57235: LD_INT 1
57237: PLUS
57238: PPUSH
57239: NOP4
57243: PUSH
57244: NOP4
57248: ARRAY
57249: PPUSH
57250: NOP4
57254: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57255: NOP4
57259: PUSH
57260: NOP4
57264: PUSH
57265: NOP4
57269: PUSH
57270: NOP4
57274: ARRAY
57275: DIFF
57276: ST_TO_ADDR
// end ;
57277: GO 57186
57279: POP
57280: POP
// if p then
57281: NOP4
57285: IFFALSE 57310
// result := Replace ( result , 3 , p ) ;
57287: NOP4
57291: PUSH
57292: NOP4
57296: PPUSH
57297: LD_INT 3
57299: PPUSH
57300: NOP4
57304: PPUSH
57305: NOP4
57309: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57310: NOP4
57314: PUSH
57315: NOP4
57319: PUSH
57320: NOP4
57324: DIFF
57325: ST_TO_ADDR
// if tmp and eng < 6 then
57326: NOP4
57330: PUSH
57331: NOP4
57335: PUSH
57336: LD_INT 6
57338: LESS
57339: AND
57340: IFFALSE 57534
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57342: NOP4
57346: PUSH
57347: NOP4
57351: PUSH
57352: NOP4
57356: PUSH
57357: NOP4
57361: UNION
57362: PUSH
57363: NOP4
57367: UNION
57368: DIFF
57369: PPUSH
57370: LD_INT 2
57372: PPUSH
57373: NOP4
57377: ST_TO_ADDR
// p := [ ] ;
57378: NOP4
57382: PUSH
57383: EMPTY
57384: ST_TO_ADDR
// if sort then
57385: NOP4
57389: IFFALSE 57505
// for i = 1 to 6 - eng do
57391: NOP4
57395: PUSH
57396: DOUBLE
57397: LD_INT 1
57399: DEC
57400: ST_TO_ADDR
57401: LD_INT 6
57403: PUSH
57404: NOP4
57408: MINUS
57409: PUSH
57410: FOR_TO
57411: IFFALSE 57503
// begin if i = sort then
57413: NOP4
57417: PUSH
57418: NOP4
57422: EQUAL
57423: IFFALSE 57427
// break ;
57425: GO 57503
// if GetClass ( i ) = 2 then
57427: NOP4
57431: PPUSH
57432: NOP4
57436: PUSH
57437: LD_INT 2
57439: EQUAL
57440: IFFALSE 57444
// continue ;
57442: GO 57410
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57444: NOP4
57448: PUSH
57449: NOP4
57453: PPUSH
57454: NOP4
57458: PUSH
57459: LD_INT 1
57461: PLUS
57462: PPUSH
57463: NOP4
57467: PUSH
57468: NOP4
57472: ARRAY
57473: PPUSH
57474: NOP4
57478: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57479: NOP4
57483: PUSH
57484: NOP4
57488: PUSH
57489: NOP4
57493: PUSH
57494: NOP4
57498: ARRAY
57499: DIFF
57500: ST_TO_ADDR
// end ;
57501: GO 57410
57503: POP
57504: POP
// if p then
57505: NOP4
57509: IFFALSE 57534
// result := Replace ( result , 2 , p ) ;
57511: NOP4
57515: PUSH
57516: NOP4
57520: PPUSH
57521: LD_INT 2
57523: PPUSH
57524: NOP4
57528: PPUSH
57529: NOP4
57533: ST_TO_ADDR
// end ; exit ;
57534: GO 58258
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
57536: NOP4
57540: PUSH
57541: NOP4
57545: PUSH
57546: NOP4
57550: ARRAY
57551: ARRAY
57552: NOT
57553: PUSH
57554: NOP4
57558: PUSH
57559: NOP4
57563: ARRAY
57564: PPUSH
57565: LD_INT 30
57567: PUSH
57568: LD_INT 3
57570: PUSH
57571: EMPTY
57572: LIST
57573: LIST
57574: PPUSH
57575: NOP4
57579: AND
57580: PUSH
57581: NOP4
57585: PUSH
57586: NOP4
57590: ARRAY
57591: NOT
57592: AND
57593: IFFALSE 58258
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
57595: NOP4
57599: PUSH
57600: NOP4
57604: PPUSH
57605: NOP4
57609: PPUSH
57610: LD_INT 6
57612: PPUSH
57613: NOP4
57617: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57618: NOP4
57622: PUSH
57623: LD_INT 0
57625: PUSH
57626: LD_INT 0
57628: PUSH
57629: LD_INT 0
57631: PUSH
57632: LD_INT 0
57634: PUSH
57635: EMPTY
57636: LIST
57637: LIST
57638: LIST
57639: LIST
57640: ST_TO_ADDR
// if sci >= 1 then
57641: NOP4
57645: PUSH
57646: LD_INT 1
57648: GREATEREQUAL
57649: IFFALSE 57671
// tmp := tmp diff sci [ 1 ] ;
57651: NOP4
57655: PUSH
57656: NOP4
57660: PUSH
57661: NOP4
57665: PUSH
57666: LD_INT 1
57668: ARRAY
57669: DIFF
57670: ST_TO_ADDR
// if tmp and not sci then
57671: NOP4
57675: PUSH
57676: NOP4
57680: NOT
57681: AND
57682: IFFALSE 57751
// begin sort := SortBySkill ( tmp , 4 ) ;
57684: NOP4
57688: PUSH
57689: NOP4
57693: PPUSH
57694: LD_INT 4
57696: PPUSH
57697: NOP4
57701: ST_TO_ADDR
// if sort then
57702: NOP4
57706: IFFALSE 57722
// p := sort [ 1 ] ;
57708: NOP4
57712: PUSH
57713: NOP4
57717: PUSH
57718: LD_INT 1
57720: ARRAY
57721: ST_TO_ADDR
// if p then
57722: NOP4
57726: IFFALSE 57751
// result := Replace ( result , 4 , p ) ;
57728: NOP4
57732: PUSH
57733: NOP4
57737: PPUSH
57738: LD_INT 4
57740: PPUSH
57741: NOP4
57745: PPUSH
57746: NOP4
57750: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57751: NOP4
57755: PUSH
57756: NOP4
57760: PUSH
57761: NOP4
57765: DIFF
57766: ST_TO_ADDR
// if tmp and mech < 6 then
57767: NOP4
57771: PUSH
57772: NOP4
57776: PUSH
57777: LD_INT 6
57779: LESS
57780: AND
57781: IFFALSE 57963
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
57783: NOP4
57787: PUSH
57788: NOP4
57792: PUSH
57793: NOP4
57797: DIFF
57798: PPUSH
57799: LD_INT 3
57801: PPUSH
57802: NOP4
57806: ST_TO_ADDR
// p := [ ] ;
57807: NOP4
57811: PUSH
57812: EMPTY
57813: ST_TO_ADDR
// if sort then
57814: NOP4
57818: IFFALSE 57934
// for i = 1 to 6 - mech do
57820: NOP4
57824: PUSH
57825: DOUBLE
57826: LD_INT 1
57828: DEC
57829: ST_TO_ADDR
57830: LD_INT 6
57832: PUSH
57833: NOP4
57837: MINUS
57838: PUSH
57839: FOR_TO
57840: IFFALSE 57932
// begin if i = sort then
57842: NOP4
57846: PUSH
57847: NOP4
57851: EQUAL
57852: IFFALSE 57856
// break ;
57854: GO 57932
// if GetClass ( i ) = 3 then
57856: NOP4
57860: PPUSH
57861: NOP4
57865: PUSH
57866: LD_INT 3
57868: EQUAL
57869: IFFALSE 57873
// continue ;
57871: GO 57839
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57873: NOP4
57877: PUSH
57878: NOP4
57882: PPUSH
57883: NOP4
57887: PUSH
57888: LD_INT 1
57890: PLUS
57891: PPUSH
57892: NOP4
57896: PUSH
57897: NOP4
57901: ARRAY
57902: PPUSH
57903: NOP4
57907: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57908: NOP4
57912: PUSH
57913: NOP4
57917: PUSH
57918: NOP4
57922: PUSH
57923: NOP4
57927: ARRAY
57928: DIFF
57929: ST_TO_ADDR
// end ;
57930: GO 57839
57932: POP
57933: POP
// if p then
57934: NOP4
57938: IFFALSE 57963
// result := Replace ( result , 3 , p ) ;
57940: NOP4
57944: PUSH
57945: NOP4
57949: PPUSH
57950: LD_INT 3
57952: PPUSH
57953: NOP4
57957: PPUSH
57958: NOP4
57962: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57963: NOP4
57967: PUSH
57968: NOP4
57972: PUSH
57973: NOP4
57977: DIFF
57978: ST_TO_ADDR
// if tmp and eng < 4 then
57979: NOP4
57983: PUSH
57984: NOP4
57988: PUSH
57989: LD_INT 4
57991: LESS
57992: AND
57993: IFFALSE 58183
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
57995: NOP4
57999: PUSH
58000: NOP4
58004: PUSH
58005: NOP4
58009: PUSH
58010: NOP4
58014: UNION
58015: DIFF
58016: PPUSH
58017: LD_INT 2
58019: PPUSH
58020: NOP4
58024: ST_TO_ADDR
// p := [ ] ;
58025: NOP4
58029: PUSH
58030: EMPTY
58031: ST_TO_ADDR
// if sort then
58032: NOP4
58036: IFFALSE 58152
// for i = 1 to 4 - eng do
58038: NOP4
58042: PUSH
58043: DOUBLE
58044: LD_INT 1
58046: DEC
58047: ST_TO_ADDR
58048: LD_INT 4
58050: PUSH
58051: NOP4
58055: MINUS
58056: PUSH
58057: FOR_TO
58058: IFFALSE 58150
// begin if i = sort then
58060: NOP4
58064: PUSH
58065: NOP4
58069: EQUAL
58070: IFFALSE 58074
// break ;
58072: GO 58150
// if GetClass ( i ) = 2 then
58074: NOP4
58078: PPUSH
58079: NOP4
58083: PUSH
58084: LD_INT 2
58086: EQUAL
58087: IFFALSE 58091
// continue ;
58089: GO 58057
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58091: NOP4
58095: PUSH
58096: NOP4
58100: PPUSH
58101: NOP4
58105: PUSH
58106: LD_INT 1
58108: PLUS
58109: PPUSH
58110: NOP4
58114: PUSH
58115: NOP4
58119: ARRAY
58120: PPUSH
58121: NOP4
58125: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58126: NOP4
58130: PUSH
58131: NOP4
58135: PUSH
58136: NOP4
58140: PUSH
58141: NOP4
58145: ARRAY
58146: DIFF
58147: ST_TO_ADDR
// end ;
58148: GO 58057
58150: POP
58151: POP
// if p then
58152: NOP4
58156: IFFALSE 58181
// result := Replace ( result , 2 , p ) ;
58158: NOP4
58162: PUSH
58163: NOP4
58167: PPUSH
58168: LD_INT 2
58170: PPUSH
58171: NOP4
58175: PPUSH
58176: NOP4
58180: ST_TO_ADDR
// end else
58181: GO 58227
// for i = eng downto 5 do
58183: NOP4
58187: PUSH
58188: DOUBLE
58189: NOP4
58193: INC
58194: ST_TO_ADDR
58195: LD_INT 5
58197: PUSH
58198: FOR_DOWNTO
58199: IFFALSE 58225
// tmp := tmp union eng [ i ] ;
58201: NOP4
58205: PUSH
58206: NOP4
58210: PUSH
58211: NOP4
58215: PUSH
58216: NOP4
58220: ARRAY
58221: UNION
58222: ST_TO_ADDR
58223: GO 58198
58225: POP
58226: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58227: NOP4
58231: PUSH
58232: NOP4
58236: PPUSH
58237: LD_INT 1
58239: PPUSH
58240: NOP4
58244: PUSH
58245: NOP4
58249: DIFF
58250: PPUSH
58251: NOP4
58255: ST_TO_ADDR
// exit ;
58256: GO 58258
// end ; end ;
58258: LD_VAR 0 2
58262: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58263: LD_INT 0
58265: PPUSH
58266: PPUSH
58267: PPUSH
// if not mc_bases then
58268: NOP4
58272: NOT
58273: IFFALSE 58277
// exit ;
58275: GO 58419
// for i = 1 to mc_bases do
58277: NOP4
58281: PUSH
58282: DOUBLE
58283: LD_INT 1
58285: DEC
58286: ST_TO_ADDR
58287: NOP4
58291: PUSH
58292: FOR_TO
58293: IFFALSE 58410
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58295: NOP4
58299: PUSH
58300: NOP4
58304: PUSH
58305: NOP4
58309: ARRAY
58310: PPUSH
58311: LD_INT 21
58313: PUSH
58314: LD_INT 3
58316: PUSH
58317: EMPTY
58318: LIST
58319: LIST
58320: PUSH
58321: LD_INT 3
58323: PUSH
58324: LD_INT 2
58326: PUSH
58327: LD_INT 30
58329: PUSH
58330: LD_INT 29
58332: PUSH
58333: EMPTY
58334: LIST
58335: LIST
58336: PUSH
58337: LD_INT 30
58339: PUSH
58340: LD_INT 30
58342: PUSH
58343: EMPTY
58344: LIST
58345: LIST
58346: PUSH
58347: EMPTY
58348: LIST
58349: LIST
58350: LIST
58351: PUSH
58352: EMPTY
58353: LIST
58354: LIST
58355: PUSH
58356: LD_INT 3
58358: PUSH
58359: LD_INT 24
58361: PUSH
58362: LD_INT 1000
58364: PUSH
58365: EMPTY
58366: LIST
58367: LIST
58368: PUSH
58369: EMPTY
58370: LIST
58371: LIST
58372: PUSH
58373: EMPTY
58374: LIST
58375: LIST
58376: LIST
58377: PPUSH
58378: NOP4
58382: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58383: NOP4
58387: PUSH
58388: NOP4
58392: PPUSH
58393: NOP4
58397: PPUSH
58398: NOP4
58402: PPUSH
58403: NOP4
58407: ST_TO_ADDR
// end ;
58408: GO 58292
58410: POP
58411: POP
// RaiseSailEvent ( 101 ) ;
58412: LD_INT 101
58414: PPUSH
58415: NOP4
// end ;
58419: LD_VAR 0 1
58423: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
58424: LD_INT 0
58426: PPUSH
58427: PPUSH
58428: PPUSH
58429: PPUSH
58430: PPUSH
58431: PPUSH
58432: PPUSH
// if not mc_bases then
58433: NOP4
58437: NOT
58438: IFFALSE 58442
// exit ;
58440: GO 59004
// for i = 1 to mc_bases do
58442: NOP4
58446: PUSH
58447: DOUBLE
58448: LD_INT 1
58450: DEC
58451: ST_TO_ADDR
58452: NOP4
58456: PUSH
58457: FOR_TO
58458: IFFALSE 58995
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
58460: NOP4
58464: PUSH
58465: NOP4
58469: PUSH
58470: NOP4
58474: ARRAY
58475: PUSH
58476: NOP4
58480: PUSH
58481: NOP4
58485: ARRAY
58486: UNION
58487: PPUSH
58488: LD_INT 21
58490: PUSH
58491: LD_INT 1
58493: PUSH
58494: EMPTY
58495: LIST
58496: LIST
58497: PUSH
58498: LD_INT 1
58500: PUSH
58501: LD_INT 3
58503: PUSH
58504: LD_INT 54
58506: PUSH
58507: EMPTY
58508: LIST
58509: PUSH
58510: EMPTY
58511: LIST
58512: LIST
58513: PUSH
58514: LD_INT 3
58516: PUSH
58517: LD_INT 24
58519: PUSH
58520: LD_INT 1000
58522: PUSH
58523: EMPTY
58524: LIST
58525: LIST
58526: PUSH
58527: EMPTY
58528: LIST
58529: LIST
58530: PUSH
58531: EMPTY
58532: LIST
58533: LIST
58534: LIST
58535: PUSH
58536: EMPTY
58537: LIST
58538: LIST
58539: PPUSH
58540: NOP4
58544: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
58545: NOP4
58549: PUSH
58550: NOP4
58554: PUSH
58555: NOP4
58559: ARRAY
58560: PPUSH
58561: LD_INT 21
58563: PUSH
58564: LD_INT 1
58566: PUSH
58567: EMPTY
58568: LIST
58569: LIST
58570: PUSH
58571: LD_INT 1
58573: PUSH
58574: LD_INT 3
58576: PUSH
58577: LD_INT 54
58579: PUSH
58580: EMPTY
58581: LIST
58582: PUSH
58583: EMPTY
58584: LIST
58585: LIST
58586: PUSH
58587: LD_INT 3
58589: PUSH
58590: LD_INT 24
58592: PUSH
58593: LD_INT 250
58595: PUSH
58596: EMPTY
58597: LIST
58598: LIST
58599: PUSH
58600: EMPTY
58601: LIST
58602: LIST
58603: PUSH
58604: EMPTY
58605: LIST
58606: LIST
58607: LIST
58608: PUSH
58609: EMPTY
58610: LIST
58611: LIST
58612: PPUSH
58613: NOP4
58617: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
58618: NOP4
58622: PUSH
58623: NOP4
58627: PUSH
58628: NOP4
58632: DIFF
58633: ST_TO_ADDR
// if not need_heal_1 then
58634: NOP4
58638: NOT
58639: IFFALSE 58672
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
58641: NOP4
58645: PUSH
58646: NOP4
58650: PPUSH
58651: NOP4
58655: PUSH
58656: LD_INT 1
58658: PUSH
58659: EMPTY
58660: LIST
58661: LIST
58662: PPUSH
58663: EMPTY
58664: PPUSH
58665: NOP4
58669: ST_TO_ADDR
58670: GO 58742
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
58672: NOP4
58676: PUSH
58677: NOP4
58681: PPUSH
58682: NOP4
58686: PUSH
58687: LD_INT 1
58689: PUSH
58690: EMPTY
58691: LIST
58692: LIST
58693: PPUSH
58694: NOP4
58698: PUSH
58699: NOP4
58703: ARRAY
58704: PUSH
58705: LD_INT 1
58707: ARRAY
58708: PPUSH
58709: LD_INT 3
58711: PUSH
58712: LD_INT 24
58714: PUSH
58715: LD_INT 1000
58717: PUSH
58718: EMPTY
58719: LIST
58720: LIST
58721: PUSH
58722: EMPTY
58723: LIST
58724: LIST
58725: PPUSH
58726: NOP4
58730: PUSH
58731: NOP4
58735: UNION
58736: PPUSH
58737: NOP4
58741: ST_TO_ADDR
// if not need_heal_2 then
58742: NOP4
58746: NOT
58747: IFFALSE 58780
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
58749: NOP4
58753: PUSH
58754: NOP4
58758: PPUSH
58759: NOP4
58763: PUSH
58764: LD_INT 2
58766: PUSH
58767: EMPTY
58768: LIST
58769: LIST
58770: PPUSH
58771: EMPTY
58772: PPUSH
58773: NOP4
58777: ST_TO_ADDR
58778: GO 58812
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
58780: NOP4
58784: PUSH
58785: NOP4
58789: PPUSH
58790: NOP4
58794: PUSH
58795: LD_INT 2
58797: PUSH
58798: EMPTY
58799: LIST
58800: LIST
58801: PPUSH
58802: NOP4
58806: PPUSH
58807: NOP4
58811: ST_TO_ADDR
// if need_heal_2 then
58812: NOP4
58816: IFFALSE 58977
// for j in need_heal_2 do
58818: NOP4
58822: PUSH
58823: NOP4
58827: PUSH
58828: FOR_IN
58829: IFFALSE 58975
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58831: NOP4
58835: PUSH
58836: NOP4
58840: PUSH
58841: NOP4
58845: ARRAY
58846: PPUSH
58847: LD_INT 2
58849: PUSH
58850: LD_INT 30
58852: PUSH
58853: LD_INT 6
58855: PUSH
58856: EMPTY
58857: LIST
58858: LIST
58859: PUSH
58860: LD_INT 30
58862: PUSH
58863: LD_INT 7
58865: PUSH
58866: EMPTY
58867: LIST
58868: LIST
58869: PUSH
58870: LD_INT 30
58872: PUSH
58873: LD_INT 8
58875: PUSH
58876: EMPTY
58877: LIST
58878: LIST
58879: PUSH
58880: LD_INT 30
58882: PUSH
58883: LD_INT 0
58885: PUSH
58886: EMPTY
58887: LIST
58888: LIST
58889: PUSH
58890: LD_INT 30
58892: PUSH
58893: LD_INT 1
58895: PUSH
58896: EMPTY
58897: LIST
58898: LIST
58899: PUSH
58900: EMPTY
58901: LIST
58902: LIST
58903: LIST
58904: LIST
58905: LIST
58906: LIST
58907: PPUSH
58908: NOP4
58912: ST_TO_ADDR
// if tmp then
58913: NOP4
58917: IFFALSE 58973
// begin k := NearestUnitToUnit ( tmp , j ) ;
58919: NOP4
58923: PUSH
58924: NOP4
58928: PPUSH
58929: NOP4
58933: PPUSH
58934: NOP4
58938: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
58939: NOP4
58943: PPUSH
58944: NOP4
58948: PPUSH
58949: NOP4
58953: PUSH
58954: LD_INT 5
58956: GREATER
58957: IFFALSE 58973
// ComMoveToNearbyEntrance ( j , k ) ;
58959: NOP4
58963: PPUSH
58964: NOP4
58968: PPUSH
58969: NOP4
// end ; end ;
58973: GO 58828
58975: POP
58976: POP
// if not need_heal_1 and not need_heal_2 then
58977: NOP4
58981: NOT
58982: PUSH
58983: NOP4
58987: NOT
58988: AND
58989: IFFALSE 58993
// continue ;
58991: GO 58457
// end ;
58993: GO 58457
58995: POP
58996: POP
// RaiseSailEvent ( 102 ) ;
58997: LD_INT 102
58999: PPUSH
59000: NOP4
// end ;
59004: LD_VAR 0 1
59008: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59009: LD_INT 0
59011: PPUSH
59012: PPUSH
59013: PPUSH
59014: PPUSH
59015: PPUSH
59016: PPUSH
59017: PPUSH
59018: PPUSH
// if not mc_bases then
59019: NOP4
59023: NOT
59024: IFFALSE 59028
// exit ;
59026: GO 59911
// for i = 1 to mc_bases do
59028: NOP4
59032: PUSH
59033: DOUBLE
59034: LD_INT 1
59036: DEC
59037: ST_TO_ADDR
59038: NOP4
59042: PUSH
59043: FOR_TO
59044: IFFALSE 59909
// begin if not mc_building_need_repair [ i ] then
59046: NOP4
59050: PUSH
59051: NOP4
59055: ARRAY
59056: NOT
59057: IFFALSE 59244
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
59059: NOP4
59063: PUSH
59064: NOP4
59068: PUSH
59069: NOP4
59073: ARRAY
59074: PPUSH
59075: LD_INT 3
59077: PUSH
59078: LD_INT 24
59080: PUSH
59081: LD_INT 1000
59083: PUSH
59084: EMPTY
59085: LIST
59086: LIST
59087: PUSH
59088: EMPTY
59089: LIST
59090: LIST
59091: PUSH
59092: LD_INT 2
59094: PUSH
59095: LD_INT 34
59097: PUSH
59098: LD_INT 13
59100: PUSH
59101: EMPTY
59102: LIST
59103: LIST
59104: PUSH
59105: LD_INT 34
59107: PUSH
59108: LD_INT 52
59110: PUSH
59111: EMPTY
59112: LIST
59113: LIST
59114: PUSH
59115: LD_INT 34
59117: PUSH
59118: NOP4
59122: PUSH
59123: EMPTY
59124: LIST
59125: LIST
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: LIST
59131: LIST
59132: PUSH
59133: EMPTY
59134: LIST
59135: LIST
59136: PPUSH
59137: NOP4
59141: ST_TO_ADDR
// if cranes then
59142: NOP4
59146: IFFALSE 59208
// for j in cranes do
59148: NOP4
59152: PUSH
59153: NOP4
59157: PUSH
59158: FOR_IN
59159: IFFALSE 59206
// if not IsInArea ( j , mc_parking [ i ] ) then
59161: NOP4
59165: PPUSH
59166: NOP4
59170: PUSH
59171: NOP4
59175: ARRAY
59176: PPUSH
59177: NOP4
59181: NOT
59182: IFFALSE 59204
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59184: NOP4
59188: PPUSH
59189: NOP4
59193: PUSH
59194: NOP4
59198: ARRAY
59199: PPUSH
59200: NOP4
59204: GO 59158
59206: POP
59207: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59208: NOP4
59212: PUSH
59213: NOP4
59217: PPUSH
59218: NOP4
59222: PPUSH
59223: EMPTY
59224: PPUSH
59225: NOP4
59229: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59230: NOP4
59234: PPUSH
59235: LD_INT 101
59237: PPUSH
59238: NOP4
// continue ;
59242: GO 59043
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59244: NOP4
59248: PUSH
59249: NOP4
59253: PPUSH
59254: NOP4
59258: PPUSH
59259: EMPTY
59260: PPUSH
59261: NOP4
59265: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59266: NOP4
59270: PPUSH
59271: LD_INT 103
59273: PPUSH
59274: NOP4
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
59278: NOP4
59282: PUSH
59283: NOP4
59287: PUSH
59288: NOP4
59292: ARRAY
59293: PUSH
59294: NOP4
59298: PUSH
59299: NOP4
59303: ARRAY
59304: UNION
59305: PPUSH
59306: LD_INT 2
59308: PUSH
59309: LD_INT 25
59311: PUSH
59312: LD_INT 2
59314: PUSH
59315: EMPTY
59316: LIST
59317: LIST
59318: PUSH
59319: LD_INT 25
59321: PUSH
59322: LD_INT 16
59324: PUSH
59325: EMPTY
59326: LIST
59327: LIST
59328: PUSH
59329: EMPTY
59330: LIST
59331: LIST
59332: LIST
59333: PUSH
59334: EMPTY
59335: LIST
59336: PPUSH
59337: NOP4
59341: ST_TO_ADDR
// if mc_need_heal [ i ] then
59342: NOP4
59346: PUSH
59347: NOP4
59351: ARRAY
59352: IFFALSE 59396
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59354: NOP4
59358: PUSH
59359: NOP4
59363: PUSH
59364: NOP4
59368: PUSH
59369: NOP4
59373: ARRAY
59374: PUSH
59375: LD_INT 1
59377: ARRAY
59378: PUSH
59379: NOP4
59383: PUSH
59384: NOP4
59388: ARRAY
59389: PUSH
59390: LD_INT 2
59392: ARRAY
59393: UNION
59394: DIFF
59395: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
59396: NOP4
59400: PUSH
59401: NOP4
59405: PUSH
59406: NOP4
59410: ARRAY
59411: PPUSH
59412: LD_INT 2
59414: PUSH
59415: LD_INT 34
59417: PUSH
59418: LD_INT 13
59420: PUSH
59421: EMPTY
59422: LIST
59423: LIST
59424: PUSH
59425: LD_INT 34
59427: PUSH
59428: LD_INT 52
59430: PUSH
59431: EMPTY
59432: LIST
59433: LIST
59434: PUSH
59435: LD_INT 34
59437: PUSH
59438: NOP4
59442: PUSH
59443: EMPTY
59444: LIST
59445: LIST
59446: PUSH
59447: EMPTY
59448: LIST
59449: LIST
59450: LIST
59451: LIST
59452: PPUSH
59453: NOP4
59457: ST_TO_ADDR
// if cranes then
59458: NOP4
59462: IFFALSE 59598
// begin for j in cranes do
59464: NOP4
59468: PUSH
59469: NOP4
59473: PUSH
59474: FOR_IN
59475: IFFALSE 59596
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
59477: NOP4
59481: PPUSH
59482: NOP4
59486: PUSH
59487: LD_INT 1000
59489: EQUAL
59490: PUSH
59491: NOP4
59495: PPUSH
59496: NOP4
59500: NOT
59501: AND
59502: IFFALSE 59536
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
59504: NOP4
59508: PPUSH
59509: NOP4
59513: PUSH
59514: NOP4
59518: ARRAY
59519: PPUSH
59520: NOP4
59524: PPUSH
59525: NOP4
59529: PPUSH
59530: NOP4
59534: GO 59594
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59536: NOP4
59540: PPUSH
59541: NOP4
59545: PUSH
59546: LD_INT 500
59548: LESS
59549: PUSH
59550: NOP4
59554: PPUSH
59555: NOP4
59559: PUSH
59560: NOP4
59564: ARRAY
59565: PPUSH
59566: NOP4
59570: NOT
59571: AND
59572: IFFALSE 59594
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59574: NOP4
59578: PPUSH
59579: NOP4
59583: PUSH
59584: NOP4
59588: ARRAY
59589: PPUSH
59590: NOP4
// end ;
59594: GO 59474
59596: POP
59597: POP
// end ; if tmp > 3 then
59598: NOP4
59602: PUSH
59603: LD_INT 3
59605: GREATER
59606: IFFALSE 59626
// tmp := ShrinkArray ( tmp , 4 ) ;
59608: NOP4
59612: PUSH
59613: NOP4
59617: PPUSH
59618: LD_INT 4
59620: PPUSH
59621: NOP4
59625: ST_TO_ADDR
// if not tmp then
59626: NOP4
59630: NOT
59631: IFFALSE 59635
// continue ;
59633: GO 59043
// for j in tmp do
59635: NOP4
59639: PUSH
59640: NOP4
59644: PUSH
59645: FOR_IN
59646: IFFALSE 59905
// begin if IsInUnit ( j ) then
59648: NOP4
59652: PPUSH
59653: NOP4
59657: IFFALSE 59668
// ComExitBuilding ( j ) ;
59659: NOP4
59663: PPUSH
59664: NOP4
// if not j in mc_building_repairs [ i ] then
59668: NOP4
59672: PUSH
59673: NOP4
59677: PUSH
59678: NOP4
59682: ARRAY
59683: IN
59684: NOT
59685: IFFALSE 59743
// begin SetTag ( j , 101 ) ;
59687: NOP4
59691: PPUSH
59692: LD_INT 101
59694: PPUSH
59695: NOP4
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
59699: NOP4
59703: PUSH
59704: NOP4
59708: PPUSH
59709: NOP4
59713: PUSH
59714: NOP4
59718: PUSH
59719: NOP4
59723: ARRAY
59724: PUSH
59725: LD_INT 1
59727: PLUS
59728: PUSH
59729: EMPTY
59730: LIST
59731: LIST
59732: PPUSH
59733: NOP4
59737: PPUSH
59738: NOP4
59742: ST_TO_ADDR
// end ; wait ( 1 ) ;
59743: LD_INT 1
59745: PPUSH
59746: NOP4
// to_repair_tmp := mc_building_need_repair [ i ] ;
59750: NOP4
59754: PUSH
59755: NOP4
59759: PUSH
59760: NOP4
59764: ARRAY
59765: ST_TO_ADDR
// if mc_scan [ i ] then
59766: NOP4
59770: PUSH
59771: NOP4
59775: ARRAY
59776: IFFALSE 59838
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
59778: NOP4
59782: PUSH
59783: NOP4
59787: PUSH
59788: NOP4
59792: ARRAY
59793: PPUSH
59794: LD_INT 3
59796: PUSH
59797: LD_INT 30
59799: PUSH
59800: LD_INT 32
59802: PUSH
59803: EMPTY
59804: LIST
59805: LIST
59806: PUSH
59807: LD_INT 30
59809: PUSH
59810: LD_INT 33
59812: PUSH
59813: EMPTY
59814: LIST
59815: LIST
59816: PUSH
59817: LD_INT 30
59819: PUSH
59820: LD_INT 31
59822: PUSH
59823: EMPTY
59824: LIST
59825: LIST
59826: PUSH
59827: EMPTY
59828: LIST
59829: LIST
59830: LIST
59831: LIST
59832: PPUSH
59833: NOP4
59837: ST_TO_ADDR
// if not to_repair_tmp then
59838: NOP4
59842: NOT
59843: IFFALSE 59847
// continue ;
59845: GO 59645
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
59847: NOP4
59851: PUSH
59852: NOP4
59856: PPUSH
59857: NOP4
59861: PPUSH
59862: NOP4
59866: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
59867: NOP4
59871: PPUSH
59872: LD_INT 16
59874: PPUSH
59875: NOP4
59879: PUSH
59880: LD_INT 4
59882: ARRAY
59883: PUSH
59884: LD_INT 10
59886: LESS
59887: IFFALSE 59903
// ComRepairBuilding ( j , to_repair ) ;
59889: NOP4
59893: PPUSH
59894: NOP4
59898: PPUSH
59899: NOP4
// end ;
59903: GO 59645
59905: POP
59906: POP
// end ;
59907: GO 59043
59909: POP
59910: POP
// end ;
59911: LD_VAR 0 1
59915: RET
// export function MC_Heal ; var i , j , tmp ; begin
59916: LD_INT 0
59918: PPUSH
59919: PPUSH
59920: PPUSH
59921: PPUSH
// if not mc_bases then
59922: NOP4
59926: NOT
59927: IFFALSE 59931
// exit ;
59929: GO 60333
// for i = 1 to mc_bases do
59931: NOP4
59935: PUSH
59936: DOUBLE
59937: LD_INT 1
59939: DEC
59940: ST_TO_ADDR
59941: NOP4
59945: PUSH
59946: FOR_TO
59947: IFFALSE 60331
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
59949: NOP4
59953: PUSH
59954: NOP4
59958: ARRAY
59959: PUSH
59960: LD_INT 1
59962: ARRAY
59963: NOT
59964: PUSH
59965: NOP4
59969: PUSH
59970: NOP4
59974: ARRAY
59975: PUSH
59976: LD_INT 2
59978: ARRAY
59979: NOT
59980: AND
59981: IFFALSE 60019
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
59983: NOP4
59987: PUSH
59988: NOP4
59992: PPUSH
59993: NOP4
59997: PPUSH
59998: EMPTY
59999: PPUSH
60000: NOP4
60004: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60005: NOP4
60009: PPUSH
60010: LD_INT 102
60012: PPUSH
60013: NOP4
// continue ;
60017: GO 59946
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60019: NOP4
60023: PUSH
60024: NOP4
60028: PUSH
60029: NOP4
60033: ARRAY
60034: PPUSH
60035: LD_INT 25
60037: PUSH
60038: LD_INT 4
60040: PUSH
60041: EMPTY
60042: LIST
60043: LIST
60044: PPUSH
60045: NOP4
60049: ST_TO_ADDR
// if not tmp then
60050: NOP4
60054: NOT
60055: IFFALSE 60059
// continue ;
60057: GO 59946
// if mc_taming [ i ] then
60059: NOP4
60063: PUSH
60064: NOP4
60068: ARRAY
60069: IFFALSE 60093
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60071: NOP4
60075: PUSH
60076: NOP4
60080: PPUSH
60081: NOP4
60085: PPUSH
60086: EMPTY
60087: PPUSH
60088: NOP4
60092: ST_TO_ADDR
// for j in tmp do
60093: NOP4
60097: PUSH
60098: NOP4
60102: PUSH
60103: FOR_IN
60104: IFFALSE 60327
// begin if IsInUnit ( j ) then
60106: NOP4
60110: PPUSH
60111: NOP4
60115: IFFALSE 60126
// ComExitBuilding ( j ) ;
60117: NOP4
60121: PPUSH
60122: NOP4
// if not j in mc_healers [ i ] then
60126: NOP4
60130: PUSH
60131: NOP4
60135: PUSH
60136: NOP4
60140: ARRAY
60141: IN
60142: NOT
60143: IFFALSE 60189
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60145: NOP4
60149: PUSH
60150: NOP4
60154: PPUSH
60155: NOP4
60159: PUSH
60160: NOP4
60164: PUSH
60165: NOP4
60169: ARRAY
60170: PUSH
60171: LD_INT 1
60173: PLUS
60174: PUSH
60175: EMPTY
60176: LIST
60177: LIST
60178: PPUSH
60179: NOP4
60183: PPUSH
60184: NOP4
60188: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60189: NOP4
60193: PPUSH
60194: NOP4
60198: PUSH
60199: LD_INT 102
60201: NONEQUAL
60202: IFFALSE 60216
// SetTag ( j , 102 ) ;
60204: NOP4
60208: PPUSH
60209: LD_INT 102
60211: PPUSH
60212: NOP4
// Wait ( 3 ) ;
60216: LD_INT 3
60218: PPUSH
60219: NOP4
// if mc_need_heal [ i ] [ 1 ] then
60223: NOP4
60227: PUSH
60228: NOP4
60232: ARRAY
60233: PUSH
60234: LD_INT 1
60236: ARRAY
60237: IFFALSE 60269
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60239: NOP4
60243: PPUSH
60244: NOP4
60248: PUSH
60249: NOP4
60253: ARRAY
60254: PUSH
60255: LD_INT 1
60257: ARRAY
60258: PUSH
60259: LD_INT 1
60261: ARRAY
60262: PPUSH
60263: NOP4
60267: GO 60325
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60269: NOP4
60273: PPUSH
60274: NOP4
60278: NOT
60279: PUSH
60280: NOP4
60284: PUSH
60285: NOP4
60289: ARRAY
60290: PUSH
60291: LD_INT 2
60293: ARRAY
60294: AND
60295: IFFALSE 60325
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60297: NOP4
60301: PPUSH
60302: NOP4
60306: PUSH
60307: NOP4
60311: ARRAY
60312: PUSH
60313: LD_INT 2
60315: ARRAY
60316: PUSH
60317: LD_INT 1
60319: ARRAY
60320: PPUSH
60321: NOP4
// end ;
60325: GO 60103
60327: POP
60328: POP
// end ;
60329: GO 59946
60331: POP
60332: POP
// end ;
60333: LD_VAR 0 1
60337: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60338: LD_INT 0
60340: PPUSH
60341: PPUSH
60342: PPUSH
60343: PPUSH
60344: PPUSH
// if not mc_bases then
60345: NOP4
60349: NOT
60350: IFFALSE 60354
// exit ;
60352: GO 61525
// for i = 1 to mc_bases do
60354: NOP4
60358: PUSH
60359: DOUBLE
60360: LD_INT 1
60362: DEC
60363: ST_TO_ADDR
60364: NOP4
60368: PUSH
60369: FOR_TO
60370: IFFALSE 61523
// begin if mc_scan [ i ] then
60372: NOP4
60376: PUSH
60377: NOP4
60381: ARRAY
60382: IFFALSE 60386
// continue ;
60384: GO 60369
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60386: NOP4
60390: PUSH
60391: NOP4
60395: ARRAY
60396: NOT
60397: PUSH
60398: NOP4
60402: PUSH
60403: NOP4
60407: ARRAY
60408: NOT
60409: AND
60410: PUSH
60411: NOP4
60415: PUSH
60416: NOP4
60420: ARRAY
60421: AND
60422: IFFALSE 60460
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60424: NOP4
60428: PUSH
60429: NOP4
60433: PPUSH
60434: NOP4
60438: PPUSH
60439: EMPTY
60440: PPUSH
60441: NOP4
60445: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60446: NOP4
60450: PPUSH
60451: LD_INT 103
60453: PPUSH
60454: NOP4
// continue ;
60458: GO 60369
// end ; if mc_construct_list [ i ] then
60460: NOP4
60464: PUSH
60465: NOP4
60469: ARRAY
60470: IFFALSE 60690
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60472: NOP4
60476: PUSH
60477: NOP4
60481: PUSH
60482: NOP4
60486: ARRAY
60487: PPUSH
60488: LD_INT 25
60490: PUSH
60491: LD_INT 2
60493: PUSH
60494: EMPTY
60495: LIST
60496: LIST
60497: PPUSH
60498: NOP4
60502: PUSH
60503: NOP4
60507: PUSH
60508: NOP4
60512: ARRAY
60513: DIFF
60514: ST_TO_ADDR
// if not tmp then
60515: NOP4
60519: NOT
60520: IFFALSE 60524
// continue ;
60522: GO 60369
// for j in tmp do
60524: NOP4
60528: PUSH
60529: NOP4
60533: PUSH
60534: FOR_IN
60535: IFFALSE 60686
// begin if not mc_builders [ i ] then
60537: NOP4
60541: PUSH
60542: NOP4
60546: ARRAY
60547: NOT
60548: IFFALSE 60606
// begin SetTag ( j , 103 ) ;
60550: NOP4
60554: PPUSH
60555: LD_INT 103
60557: PPUSH
60558: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60562: NOP4
60566: PUSH
60567: NOP4
60571: PPUSH
60572: NOP4
60576: PUSH
60577: NOP4
60581: PUSH
60582: NOP4
60586: ARRAY
60587: PUSH
60588: LD_INT 1
60590: PLUS
60591: PUSH
60592: EMPTY
60593: LIST
60594: LIST
60595: PPUSH
60596: NOP4
60600: PPUSH
60601: NOP4
60605: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60606: NOP4
60610: PPUSH
60611: NOP4
60615: IFFALSE 60626
// ComExitBuilding ( j ) ;
60617: NOP4
60621: PPUSH
60622: NOP4
// wait ( 3 ) ;
60626: LD_INT 3
60628: PPUSH
60629: NOP4
// if not mc_construct_list [ i ] then
60633: NOP4
60637: PUSH
60638: NOP4
60642: ARRAY
60643: NOT
60644: IFFALSE 60648
// break ;
60646: GO 60686
// if not HasTask ( j ) then
60648: NOP4
60652: PPUSH
60653: NOP4
60657: NOT
60658: IFFALSE 60684
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
60660: NOP4
60664: PPUSH
60665: NOP4
60669: PUSH
60670: NOP4
60674: ARRAY
60675: PUSH
60676: LD_INT 1
60678: ARRAY
60679: PPUSH
60680: NOP4
// end ;
60684: GO 60534
60686: POP
60687: POP
// end else
60688: GO 61521
// if mc_build_list [ i ] then
60690: NOP4
60694: PUSH
60695: NOP4
60699: ARRAY
60700: IFFALSE 61521
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60702: NOP4
60706: PUSH
60707: NOP4
60711: PUSH
60712: NOP4
60716: ARRAY
60717: PPUSH
60718: LD_INT 2
60720: PUSH
60721: LD_INT 30
60723: PUSH
60724: LD_INT 0
60726: PUSH
60727: EMPTY
60728: LIST
60729: LIST
60730: PUSH
60731: LD_INT 30
60733: PUSH
60734: LD_INT 1
60736: PUSH
60737: EMPTY
60738: LIST
60739: LIST
60740: PUSH
60741: EMPTY
60742: LIST
60743: LIST
60744: LIST
60745: PPUSH
60746: NOP4
60750: ST_TO_ADDR
// if depot then
60751: NOP4
60755: IFFALSE 60773
// depot := depot [ 1 ] else
60757: NOP4
60761: PUSH
60762: NOP4
60766: PUSH
60767: LD_INT 1
60769: ARRAY
60770: ST_TO_ADDR
60771: GO 60781
// depot := 0 ;
60773: NOP4
60777: PUSH
60778: LD_INT 0
60780: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
60781: NOP4
60785: PUSH
60786: NOP4
60790: ARRAY
60791: PUSH
60792: LD_INT 1
60794: ARRAY
60795: PUSH
60796: LD_INT 1
60798: ARRAY
60799: PPUSH
60800: NOP4
60804: PUSH
60805: NOP4
60809: PUSH
60810: NOP4
60814: ARRAY
60815: PPUSH
60816: LD_INT 2
60818: PUSH
60819: LD_INT 30
60821: PUSH
60822: LD_INT 2
60824: PUSH
60825: EMPTY
60826: LIST
60827: LIST
60828: PUSH
60829: LD_INT 30
60831: PUSH
60832: LD_INT 3
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: PUSH
60839: EMPTY
60840: LIST
60841: LIST
60842: LIST
60843: PPUSH
60844: NOP4
60848: NOT
60849: AND
60850: IFFALSE 60955
// begin for j = 1 to mc_build_list [ i ] do
60852: NOP4
60856: PUSH
60857: DOUBLE
60858: LD_INT 1
60860: DEC
60861: ST_TO_ADDR
60862: NOP4
60866: PUSH
60867: NOP4
60871: ARRAY
60872: PUSH
60873: FOR_TO
60874: IFFALSE 60953
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
60876: NOP4
60880: PUSH
60881: NOP4
60885: ARRAY
60886: PUSH
60887: NOP4
60891: ARRAY
60892: PUSH
60893: LD_INT 1
60895: ARRAY
60896: PUSH
60897: LD_INT 2
60899: EQUAL
60900: IFFALSE 60951
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
60902: NOP4
60906: PUSH
60907: NOP4
60911: PPUSH
60912: NOP4
60916: PPUSH
60917: NOP4
60921: PUSH
60922: NOP4
60926: ARRAY
60927: PPUSH
60928: NOP4
60932: PPUSH
60933: LD_INT 1
60935: PPUSH
60936: LD_INT 0
60938: PPUSH
60939: NOP4
60943: PPUSH
60944: NOP4
60948: ST_TO_ADDR
// break ;
60949: GO 60953
// end ;
60951: GO 60873
60953: POP
60954: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
60955: NOP4
60959: PUSH
60960: NOP4
60964: ARRAY
60965: PUSH
60966: LD_INT 1
60968: ARRAY
60969: PUSH
60970: LD_INT 1
60972: ARRAY
60973: PUSH
60974: LD_INT 0
60976: EQUAL
60977: PUSH
60978: NOP4
60982: PUSH
60983: NOP4
60987: PPUSH
60988: NOP4
60992: PUSH
60993: NOP4
60997: ARRAY
60998: PUSH
60999: LD_INT 1
61001: ARRAY
61002: PUSH
61003: LD_INT 1
61005: ARRAY
61006: PPUSH
61007: NOP4
61011: PUSH
61012: NOP4
61016: ARRAY
61017: PUSH
61018: LD_INT 1
61020: ARRAY
61021: PUSH
61022: LD_INT 2
61024: ARRAY
61025: PPUSH
61026: NOP4
61030: PUSH
61031: NOP4
61035: ARRAY
61036: PUSH
61037: LD_INT 1
61039: ARRAY
61040: PUSH
61041: LD_INT 3
61043: ARRAY
61044: PPUSH
61045: NOP4
61049: PUSH
61050: NOP4
61054: ARRAY
61055: PUSH
61056: LD_INT 1
61058: ARRAY
61059: PUSH
61060: LD_INT 4
61062: ARRAY
61063: PPUSH
61064: NOP4
61068: AND
61069: OR
61070: IFFALSE 61351
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61072: NOP4
61076: PUSH
61077: NOP4
61081: PUSH
61082: NOP4
61086: ARRAY
61087: PPUSH
61088: LD_INT 25
61090: PUSH
61091: LD_INT 2
61093: PUSH
61094: EMPTY
61095: LIST
61096: LIST
61097: PPUSH
61098: NOP4
61102: PUSH
61103: NOP4
61107: PUSH
61108: NOP4
61112: ARRAY
61113: DIFF
61114: ST_TO_ADDR
// if not tmp then
61115: NOP4
61119: NOT
61120: IFFALSE 61124
// continue ;
61122: GO 60369
// for j in tmp do
61124: NOP4
61128: PUSH
61129: NOP4
61133: PUSH
61134: FOR_IN
61135: IFFALSE 61347
// begin if not mc_builders [ i ] then
61137: NOP4
61141: PUSH
61142: NOP4
61146: ARRAY
61147: NOT
61148: IFFALSE 61206
// begin SetTag ( j , 103 ) ;
61150: NOP4
61154: PPUSH
61155: LD_INT 103
61157: PPUSH
61158: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61162: NOP4
61166: PUSH
61167: NOP4
61171: PPUSH
61172: NOP4
61176: PUSH
61177: NOP4
61181: PUSH
61182: NOP4
61186: ARRAY
61187: PUSH
61188: LD_INT 1
61190: PLUS
61191: PUSH
61192: EMPTY
61193: LIST
61194: LIST
61195: PPUSH
61196: NOP4
61200: PPUSH
61201: NOP4
61205: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61206: NOP4
61210: PPUSH
61211: NOP4
61215: IFFALSE 61226
// ComExitBuilding ( j ) ;
61217: NOP4
61221: PPUSH
61222: NOP4
// wait ( 3 ) ;
61226: LD_INT 3
61228: PPUSH
61229: NOP4
// if not mc_build_list [ i ] then
61233: NOP4
61237: PUSH
61238: NOP4
61242: ARRAY
61243: NOT
61244: IFFALSE 61248
// break ;
61246: GO 61347
// if not HasTask ( j ) then
61248: NOP4
61252: PPUSH
61253: NOP4
61257: NOT
61258: IFFALSE 61345
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61260: NOP4
61264: PPUSH
61265: NOP4
61269: PUSH
61270: NOP4
61274: ARRAY
61275: PUSH
61276: LD_INT 1
61278: ARRAY
61279: PUSH
61280: LD_INT 1
61282: ARRAY
61283: PPUSH
61284: NOP4
61288: PUSH
61289: NOP4
61293: ARRAY
61294: PUSH
61295: LD_INT 1
61297: ARRAY
61298: PUSH
61299: LD_INT 2
61301: ARRAY
61302: PPUSH
61303: NOP4
61307: PUSH
61308: NOP4
61312: ARRAY
61313: PUSH
61314: LD_INT 1
61316: ARRAY
61317: PUSH
61318: LD_INT 3
61320: ARRAY
61321: PPUSH
61322: NOP4
61326: PUSH
61327: NOP4
61331: ARRAY
61332: PUSH
61333: LD_INT 1
61335: ARRAY
61336: PUSH
61337: LD_INT 4
61339: ARRAY
61340: PPUSH
61341: NOP4
// end ;
61345: GO 61134
61347: POP
61348: POP
// end else
61349: GO 61521
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
61351: NOP4
61355: PUSH
61356: NOP4
61360: ARRAY
61361: PPUSH
61362: NOP4
61366: PUSH
61367: NOP4
61371: ARRAY
61372: PUSH
61373: LD_INT 1
61375: ARRAY
61376: PUSH
61377: LD_INT 1
61379: ARRAY
61380: PPUSH
61381: NOP4
61385: PUSH
61386: NOP4
61390: ARRAY
61391: PUSH
61392: LD_INT 1
61394: ARRAY
61395: PUSH
61396: LD_INT 2
61398: ARRAY
61399: PPUSH
61400: NOP4
61404: PUSH
61405: NOP4
61409: ARRAY
61410: PUSH
61411: LD_INT 1
61413: ARRAY
61414: PUSH
61415: LD_INT 3
61417: ARRAY
61418: PPUSH
61419: NOP4
61423: PUSH
61424: NOP4
61428: ARRAY
61429: PUSH
61430: LD_INT 1
61432: ARRAY
61433: PUSH
61434: LD_INT 4
61436: ARRAY
61437: PPUSH
61438: NOP4
61442: PUSH
61443: NOP4
61447: ARRAY
61448: PPUSH
61449: LD_INT 21
61451: PUSH
61452: LD_INT 3
61454: PUSH
61455: EMPTY
61456: LIST
61457: LIST
61458: PPUSH
61459: NOP4
61463: PPUSH
61464: EMPTY
61465: PPUSH
61466: NOP4
61470: NOT
61471: IFFALSE 61521
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61473: NOP4
61477: PUSH
61478: NOP4
61482: PPUSH
61483: NOP4
61487: PPUSH
61488: NOP4
61492: PUSH
61493: NOP4
61497: ARRAY
61498: PPUSH
61499: LD_INT 1
61501: PPUSH
61502: LD_INT 1
61504: NEG
61505: PPUSH
61506: LD_INT 0
61508: PPUSH
61509: NOP4
61513: PPUSH
61514: NOP4
61518: ST_TO_ADDR
// continue ;
61519: GO 60369
// end ; end ; end ;
61521: GO 60369
61523: POP
61524: POP
// end ;
61525: LD_VAR 0 1
61529: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
61530: LD_INT 0
61532: PPUSH
61533: PPUSH
61534: PPUSH
61535: PPUSH
61536: PPUSH
61537: PPUSH
// if not mc_bases then
61538: NOP4
61542: NOT
61543: IFFALSE 61547
// exit ;
61545: GO 61974
// for i = 1 to mc_bases do
61547: NOP4
61551: PUSH
61552: DOUBLE
61553: LD_INT 1
61555: DEC
61556: ST_TO_ADDR
61557: NOP4
61561: PUSH
61562: FOR_TO
61563: IFFALSE 61972
// begin tmp := mc_build_upgrade [ i ] ;
61565: NOP4
61569: PUSH
61570: NOP4
61574: PUSH
61575: NOP4
61579: ARRAY
61580: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
61581: NOP4
61585: PUSH
61586: NOP4
61590: PUSH
61591: NOP4
61595: ARRAY
61596: PPUSH
61597: LD_INT 2
61599: PUSH
61600: LD_INT 30
61602: PUSH
61603: LD_INT 6
61605: PUSH
61606: EMPTY
61607: LIST
61608: LIST
61609: PUSH
61610: LD_INT 30
61612: PUSH
61613: LD_INT 7
61615: PUSH
61616: EMPTY
61617: LIST
61618: LIST
61619: PUSH
61620: EMPTY
61621: LIST
61622: LIST
61623: LIST
61624: PPUSH
61625: NOP4
61629: ST_TO_ADDR
// if not tmp and not lab then
61630: NOP4
61634: NOT
61635: PUSH
61636: NOP4
61640: NOT
61641: AND
61642: IFFALSE 61646
// continue ;
61644: GO 61562
// if tmp then
61646: NOP4
61650: IFFALSE 61770
// for j in tmp do
61652: NOP4
61656: PUSH
61657: NOP4
61661: PUSH
61662: FOR_IN
61663: IFFALSE 61768
// begin if UpgradeCost ( j ) then
61665: NOP4
61669: PPUSH
61670: NOP4
61674: IFFALSE 61766
// begin ComUpgrade ( j ) ;
61676: NOP4
61680: PPUSH
61681: NOP4
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
61685: NOP4
61689: PUSH
61690: NOP4
61694: PPUSH
61695: NOP4
61699: PPUSH
61700: NOP4
61704: PUSH
61705: NOP4
61709: ARRAY
61710: PUSH
61711: NOP4
61715: DIFF
61716: PPUSH
61717: NOP4
61721: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61722: NOP4
61726: PUSH
61727: NOP4
61731: PPUSH
61732: NOP4
61736: PUSH
61737: NOP4
61741: PUSH
61742: NOP4
61746: ARRAY
61747: PUSH
61748: LD_INT 1
61750: PLUS
61751: PUSH
61752: EMPTY
61753: LIST
61754: LIST
61755: PPUSH
61756: NOP4
61760: PPUSH
61761: NOP4
61765: ST_TO_ADDR
// end ; end ;
61766: GO 61662
61768: POP
61769: POP
// if not lab or not mc_lab_upgrade [ i ] then
61770: NOP4
61774: NOT
61775: PUSH
61776: NOP4
61780: PUSH
61781: NOP4
61785: ARRAY
61786: NOT
61787: OR
61788: IFFALSE 61792
// continue ;
61790: GO 61562
// for j in lab do
61792: NOP4
61796: PUSH
61797: NOP4
61801: PUSH
61802: FOR_IN
61803: IFFALSE 61968
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
61805: NOP4
61809: PPUSH
61810: NOP4
61814: PUSH
61815: LD_INT 6
61817: PUSH
61818: LD_INT 7
61820: PUSH
61821: EMPTY
61822: LIST
61823: LIST
61824: IN
61825: PUSH
61826: NOP4
61830: PPUSH
61831: NOP4
61835: PUSH
61836: LD_INT 1
61838: NONEQUAL
61839: AND
61840: IFFALSE 61966
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
61842: NOP4
61846: PPUSH
61847: NOP4
61851: PUSH
61852: NOP4
61856: ARRAY
61857: PUSH
61858: LD_INT 1
61860: ARRAY
61861: PPUSH
61862: NOP4
61866: IFFALSE 61966
// begin ComCancel ( j ) ;
61868: NOP4
61872: PPUSH
61873: NOP4
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
61877: NOP4
61881: PPUSH
61882: NOP4
61886: PUSH
61887: NOP4
61891: ARRAY
61892: PUSH
61893: LD_INT 1
61895: ARRAY
61896: PPUSH
61897: NOP4
// if not j in mc_construct_list [ i ] then
61901: NOP4
61905: PUSH
61906: NOP4
61910: PUSH
61911: NOP4
61915: ARRAY
61916: IN
61917: NOT
61918: IFFALSE 61964
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61920: NOP4
61924: PUSH
61925: NOP4
61929: PPUSH
61930: NOP4
61934: PUSH
61935: NOP4
61939: PUSH
61940: NOP4
61944: ARRAY
61945: PUSH
61946: LD_INT 1
61948: PLUS
61949: PUSH
61950: EMPTY
61951: LIST
61952: LIST
61953: PPUSH
61954: NOP4
61958: PPUSH
61959: NOP4
61963: ST_TO_ADDR
// break ;
61964: GO 61968
// end ; end ; end ;
61966: GO 61802
61968: POP
61969: POP
// end ;
61970: GO 61562
61972: POP
61973: POP
// end ;
61974: LD_VAR 0 1
61978: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
61979: LD_INT 0
61981: PPUSH
61982: PPUSH
61983: PPUSH
61984: PPUSH
61985: PPUSH
61986: PPUSH
61987: PPUSH
61988: PPUSH
61989: PPUSH
// if not mc_bases then
61990: NOP4
61994: NOT
61995: IFFALSE 61999
// exit ;
61997: GO 62404
// for i = 1 to mc_bases do
61999: NOP4
62003: PUSH
62004: DOUBLE
62005: LD_INT 1
62007: DEC
62008: ST_TO_ADDR
62009: NOP4
62013: PUSH
62014: FOR_TO
62015: IFFALSE 62402
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62017: NOP4
62021: PUSH
62022: NOP4
62026: ARRAY
62027: NOT
62028: PUSH
62029: NOP4
62033: PUSH
62034: NOP4
62038: ARRAY
62039: PPUSH
62040: LD_INT 30
62042: PUSH
62043: LD_INT 3
62045: PUSH
62046: EMPTY
62047: LIST
62048: LIST
62049: PPUSH
62050: NOP4
62054: NOT
62055: OR
62056: IFFALSE 62060
// continue ;
62058: GO 62014
// busy := false ;
62060: NOP4
62064: PUSH
62065: LD_INT 0
62067: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62068: NOP4
62072: PUSH
62073: NOP4
62077: PUSH
62078: NOP4
62082: ARRAY
62083: PPUSH
62084: LD_INT 30
62086: PUSH
62087: LD_INT 3
62089: PUSH
62090: EMPTY
62091: LIST
62092: LIST
62093: PPUSH
62094: NOP4
62098: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62099: NOP4
62103: PUSH
62104: NOP4
62108: PUSH
62109: NOP4
62113: ARRAY
62114: PPUSH
62115: LD_INT 2
62117: PUSH
62118: LD_INT 30
62120: PUSH
62121: LD_INT 32
62123: PUSH
62124: EMPTY
62125: LIST
62126: LIST
62127: PUSH
62128: LD_INT 30
62130: PUSH
62131: LD_INT 33
62133: PUSH
62134: EMPTY
62135: LIST
62136: LIST
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: LIST
62142: PPUSH
62143: NOP4
62147: ST_TO_ADDR
// if not t then
62148: NOP4
62152: NOT
62153: IFFALSE 62157
// continue ;
62155: GO 62014
// for j in tmp do
62157: NOP4
62161: PUSH
62162: NOP4
62166: PUSH
62167: FOR_IN
62168: IFFALSE 62198
// if not BuildingStatus ( j ) = bs_idle then
62170: NOP4
62174: PPUSH
62175: NOP4
62179: PUSH
62180: LD_INT 2
62182: EQUAL
62183: NOT
62184: IFFALSE 62196
// begin busy := true ;
62186: NOP4
62190: PUSH
62191: LD_INT 1
62193: ST_TO_ADDR
// break ;
62194: GO 62198
// end ;
62196: GO 62167
62198: POP
62199: POP
// if busy then
62200: NOP4
62204: IFFALSE 62208
// continue ;
62206: GO 62014
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62208: NOP4
62212: PUSH
62213: NOP4
62217: PPUSH
62218: LD_INT 35
62220: PUSH
62221: LD_INT 0
62223: PUSH
62224: EMPTY
62225: LIST
62226: LIST
62227: PPUSH
62228: NOP4
62232: ST_TO_ADDR
// if tw then
62233: NOP4
62237: IFFALSE 62314
// begin tw := tw [ 1 ] ;
62239: NOP4
62243: PUSH
62244: NOP4
62248: PUSH
62249: LD_INT 1
62251: ARRAY
62252: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62253: NOP4
62257: PUSH
62258: NOP4
62262: PPUSH
62263: NOP4
62267: PUSH
62268: NOP4
62272: ARRAY
62273: PPUSH
62274: NOP4
62278: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62279: NOP4
62283: PUSH
62284: NOP4
62288: ARRAY
62289: IFFALSE 62312
// if not weapon in mc_allowed_tower_weapons [ i ] then
62291: NOP4
62295: PUSH
62296: NOP4
62300: PUSH
62301: NOP4
62305: ARRAY
62306: IN
62307: NOT
62308: IFFALSE 62312
// continue ;
62310: GO 62014
// end else
62312: GO 62377
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62314: NOP4
62318: PUSH
62319: NOP4
62323: PUSH
62324: NOP4
62328: ARRAY
62329: PPUSH
62330: NOP4
62334: PPUSH
62335: NOP4
62339: ST_TO_ADDR
// if not tmp2 then
62340: NOP4
62344: NOT
62345: IFFALSE 62349
// continue ;
62347: GO 62014
// tw := tmp2 [ 1 ] ;
62349: NOP4
62353: PUSH
62354: NOP4
62358: PUSH
62359: LD_INT 1
62361: ARRAY
62362: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62363: NOP4
62367: PUSH
62368: NOP4
62372: PUSH
62373: LD_INT 2
62375: ARRAY
62376: ST_TO_ADDR
// end ; if not weapon then
62377: NOP4
62381: NOT
62382: IFFALSE 62386
// continue ;
62384: GO 62014
// ComPlaceWeapon ( tw , weapon ) ;
62386: NOP4
62390: PPUSH
62391: NOP4
62395: PPUSH
62396: NOP4
// end ;
62400: GO 62014
62402: POP
62403: POP
// end ;
62404: LD_VAR 0 1
62408: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
62409: LD_INT 0
62411: PPUSH
62412: PPUSH
62413: PPUSH
62414: PPUSH
62415: PPUSH
62416: PPUSH
62417: PPUSH
// if not mc_bases then
62418: NOP4
62422: NOT
62423: IFFALSE 62427
// exit ;
62425: GO 63195
// for i = 1 to mc_bases do
62427: NOP4
62431: PUSH
62432: DOUBLE
62433: LD_INT 1
62435: DEC
62436: ST_TO_ADDR
62437: NOP4
62441: PUSH
62442: FOR_TO
62443: IFFALSE 63193
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62445: NOP4
62449: PUSH
62450: NOP4
62454: ARRAY
62455: NOT
62456: PUSH
62457: NOP4
62461: PUSH
62462: NOP4
62466: ARRAY
62467: PUSH
62468: NOP4
62472: PUSH
62473: NOP4
62477: ARRAY
62478: EQUAL
62479: OR
62480: PUSH
62481: NOP4
62485: PUSH
62486: NOP4
62490: ARRAY
62491: OR
62492: IFFALSE 62496
// continue ;
62494: GO 62442
// if mc_miners [ i ] then
62496: NOP4
62500: PUSH
62501: NOP4
62505: ARRAY
62506: IFFALSE 62880
// begin for j = mc_miners [ i ] downto 1 do
62508: NOP4
62512: PUSH
62513: DOUBLE
62514: NOP4
62518: PUSH
62519: NOP4
62523: ARRAY
62524: INC
62525: ST_TO_ADDR
62526: LD_INT 1
62528: PUSH
62529: FOR_DOWNTO
62530: IFFALSE 62878
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
62532: NOP4
62536: PUSH
62537: NOP4
62541: ARRAY
62542: PUSH
62543: NOP4
62547: ARRAY
62548: PPUSH
62549: NOP4
62553: PUSH
62554: NOP4
62558: PUSH
62559: NOP4
62563: ARRAY
62564: PUSH
62565: NOP4
62569: ARRAY
62570: PPUSH
62571: NOP4
62575: PUSH
62576: LD_INT 1
62578: NONEQUAL
62579: OR
62580: IFFALSE 62643
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
62582: NOP4
62586: PUSH
62587: NOP4
62591: PUSH
62592: NOP4
62596: ARRAY
62597: PUSH
62598: NOP4
62602: PUSH
62603: NOP4
62607: ARRAY
62608: PUSH
62609: NOP4
62613: ARRAY
62614: DIFF
62615: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
62616: NOP4
62620: PUSH
62621: NOP4
62625: PPUSH
62626: NOP4
62630: PPUSH
62631: NOP4
62635: PPUSH
62636: NOP4
62640: ST_TO_ADDR
// continue ;
62641: GO 62529
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
62643: NOP4
62647: PUSH
62648: NOP4
62652: ARRAY
62653: PUSH
62654: NOP4
62658: ARRAY
62659: PPUSH
62660: NOP4
62664: PUSH
62665: LD_INT 1
62667: EQUAL
62668: PUSH
62669: NOP4
62673: PUSH
62674: NOP4
62678: ARRAY
62679: PUSH
62680: NOP4
62684: ARRAY
62685: PPUSH
62686: NOP4
62690: NOT
62691: AND
62692: PUSH
62693: NOP4
62697: PUSH
62698: NOP4
62702: ARRAY
62703: PUSH
62704: NOP4
62708: ARRAY
62709: PPUSH
62710: NOP4
62714: NOT
62715: AND
62716: IFFALSE 62876
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
62718: NOP4
62722: PUSH
62723: NOP4
62727: ARRAY
62728: PUSH
62729: NOP4
62733: ARRAY
62734: PPUSH
62735: NOP4
62739: IFFALSE 62762
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
62741: NOP4
62745: PUSH
62746: NOP4
62750: ARRAY
62751: PUSH
62752: NOP4
62756: ARRAY
62757: PPUSH
62758: NOP4
// if not HasTask ( mc_miners [ i ] [ j ] ) then
62762: NOP4
62766: PUSH
62767: NOP4
62771: ARRAY
62772: PUSH
62773: NOP4
62777: ARRAY
62778: PPUSH
62779: NOP4
62783: NOT
62784: IFFALSE 62876
// begin r := rand ( 1 , mc_mines [ i ] ) ;
62786: NOP4
62790: PUSH
62791: LD_INT 1
62793: PPUSH
62794: NOP4
62798: PUSH
62799: NOP4
62803: ARRAY
62804: PPUSH
62805: NOP4
62809: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
62810: NOP4
62814: PUSH
62815: NOP4
62819: ARRAY
62820: PUSH
62821: NOP4
62825: ARRAY
62826: PPUSH
62827: NOP4
62831: PUSH
62832: NOP4
62836: ARRAY
62837: PUSH
62838: NOP4
62842: ARRAY
62843: PUSH
62844: LD_INT 1
62846: ARRAY
62847: PPUSH
62848: NOP4
62852: PUSH
62853: NOP4
62857: ARRAY
62858: PUSH
62859: NOP4
62863: ARRAY
62864: PUSH
62865: LD_INT 2
62867: ARRAY
62868: PPUSH
62869: LD_INT 0
62871: PPUSH
62872: NOP4
// end ; end ; end ;
62876: GO 62529
62878: POP
62879: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
62880: NOP4
62884: PUSH
62885: NOP4
62889: PUSH
62890: NOP4
62894: ARRAY
62895: PPUSH
62896: LD_INT 2
62898: PUSH
62899: LD_INT 30
62901: PUSH
62902: LD_INT 4
62904: PUSH
62905: EMPTY
62906: LIST
62907: LIST
62908: PUSH
62909: LD_INT 30
62911: PUSH
62912: LD_INT 5
62914: PUSH
62915: EMPTY
62916: LIST
62917: LIST
62918: PUSH
62919: LD_INT 30
62921: PUSH
62922: LD_INT 32
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: PUSH
62929: EMPTY
62930: LIST
62931: LIST
62932: LIST
62933: LIST
62934: PPUSH
62935: NOP4
62939: ST_TO_ADDR
// if not tmp then
62940: NOP4
62944: NOT
62945: IFFALSE 62949
// continue ;
62947: GO 62442
// list := [ ] ;
62949: NOP4
62953: PUSH
62954: EMPTY
62955: ST_TO_ADDR
// for j in tmp do
62956: NOP4
62960: PUSH
62961: NOP4
62965: PUSH
62966: FOR_IN
62967: IFFALSE 63036
// begin for k in UnitsInside ( j ) do
62969: NOP4
62973: PUSH
62974: NOP4
62978: PPUSH
62979: NOP4
62983: PUSH
62984: FOR_IN
62985: IFFALSE 63032
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
62987: NOP4
62991: PPUSH
62992: NOP4
62996: PUSH
62997: LD_INT 1
62999: EQUAL
63000: PUSH
63001: NOP4
63005: PPUSH
63006: NOP4
63010: NOT
63011: AND
63012: IFFALSE 63030
// list := list ^ k ;
63014: NOP4
63018: PUSH
63019: NOP4
63023: PUSH
63024: NOP4
63028: ADD
63029: ST_TO_ADDR
63030: GO 62984
63032: POP
63033: POP
// end ;
63034: GO 62966
63036: POP
63037: POP
// list := list diff mc_miners [ i ] ;
63038: NOP4
63042: PUSH
63043: NOP4
63047: PUSH
63048: NOP4
63052: PUSH
63053: NOP4
63057: ARRAY
63058: DIFF
63059: ST_TO_ADDR
// if not list then
63060: NOP4
63064: NOT
63065: IFFALSE 63069
// continue ;
63067: GO 62442
// k := mc_mines [ i ] - mc_miners [ i ] ;
63069: NOP4
63073: PUSH
63074: NOP4
63078: PUSH
63079: NOP4
63083: ARRAY
63084: PUSH
63085: NOP4
63089: PUSH
63090: NOP4
63094: ARRAY
63095: MINUS
63096: ST_TO_ADDR
// if k > list then
63097: NOP4
63101: PUSH
63102: NOP4
63106: GREATER
63107: IFFALSE 63119
// k := list ;
63109: NOP4
63113: PUSH
63114: NOP4
63118: ST_TO_ADDR
// for j = 1 to k do
63119: NOP4
63123: PUSH
63124: DOUBLE
63125: LD_INT 1
63127: DEC
63128: ST_TO_ADDR
63129: NOP4
63133: PUSH
63134: FOR_TO
63135: IFFALSE 63189
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63137: NOP4
63141: PUSH
63142: NOP4
63146: PPUSH
63147: NOP4
63151: PUSH
63152: NOP4
63156: PUSH
63157: NOP4
63161: ARRAY
63162: PUSH
63163: LD_INT 1
63165: PLUS
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PPUSH
63171: NOP4
63175: PUSH
63176: NOP4
63180: ARRAY
63181: PPUSH
63182: NOP4
63186: ST_TO_ADDR
63187: GO 63134
63189: POP
63190: POP
// end ;
63191: GO 62442
63193: POP
63194: POP
// end ;
63195: LD_VAR 0 1
63199: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
63200: LD_INT 0
63202: PPUSH
63203: PPUSH
63204: PPUSH
63205: PPUSH
63206: PPUSH
63207: PPUSH
63208: PPUSH
63209: PPUSH
63210: PPUSH
63211: PPUSH
63212: PPUSH
// if not mc_bases then
63213: NOP4
63217: NOT
63218: IFFALSE 63222
// exit ;
63220: GO 65045
// for i = 1 to mc_bases do
63222: NOP4
63226: PUSH
63227: DOUBLE
63228: LD_INT 1
63230: DEC
63231: ST_TO_ADDR
63232: NOP4
63236: PUSH
63237: FOR_TO
63238: IFFALSE 65043
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63240: NOP4
63244: PUSH
63245: NOP4
63249: ARRAY
63250: NOT
63251: PUSH
63252: NOP4
63256: PUSH
63257: NOP4
63261: ARRAY
63262: OR
63263: IFFALSE 63267
// continue ;
63265: GO 63237
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63267: NOP4
63271: PUSH
63272: NOP4
63276: ARRAY
63277: NOT
63278: PUSH
63279: NOP4
63283: PUSH
63284: NOP4
63288: ARRAY
63289: AND
63290: IFFALSE 63328
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63292: NOP4
63296: PUSH
63297: NOP4
63301: PPUSH
63302: NOP4
63306: PPUSH
63307: EMPTY
63308: PPUSH
63309: NOP4
63313: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63314: NOP4
63318: PPUSH
63319: LD_INT 107
63321: PPUSH
63322: NOP4
// continue ;
63326: GO 63237
// end ; target := [ ] ;
63328: NOP4
63332: PUSH
63333: EMPTY
63334: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
63335: NOP4
63339: PUSH
63340: NOP4
63344: PUSH
63345: NOP4
63349: ARRAY
63350: PUSH
63351: LD_INT 1
63353: ARRAY
63354: PPUSH
63355: NOP4
63359: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63360: NOP4
63364: PUSH
63365: NOP4
63369: PUSH
63370: NOP4
63374: ARRAY
63375: PPUSH
63376: LD_INT 2
63378: PUSH
63379: LD_INT 30
63381: PUSH
63382: LD_INT 0
63384: PUSH
63385: EMPTY
63386: LIST
63387: LIST
63388: PUSH
63389: LD_INT 30
63391: PUSH
63392: LD_INT 1
63394: PUSH
63395: EMPTY
63396: LIST
63397: LIST
63398: PUSH
63399: EMPTY
63400: LIST
63401: LIST
63402: LIST
63403: PPUSH
63404: NOP4
63408: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63409: NOP4
63413: PUSH
63414: DOUBLE
63415: NOP4
63419: PUSH
63420: NOP4
63424: ARRAY
63425: INC
63426: ST_TO_ADDR
63427: LD_INT 1
63429: PUSH
63430: FOR_DOWNTO
63431: IFFALSE 63676
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63433: NOP4
63437: PUSH
63438: NOP4
63442: ARRAY
63443: PUSH
63444: NOP4
63448: ARRAY
63449: PUSH
63450: LD_INT 2
63452: ARRAY
63453: PPUSH
63454: NOP4
63458: PUSH
63459: NOP4
63463: ARRAY
63464: PUSH
63465: NOP4
63469: ARRAY
63470: PUSH
63471: LD_INT 3
63473: ARRAY
63474: PPUSH
63475: NOP4
63479: PUSH
63480: NOP4
63484: PUSH
63485: NOP4
63489: ARRAY
63490: PUSH
63491: NOP4
63495: ARRAY
63496: PUSH
63497: LD_INT 2
63499: ARRAY
63500: PPUSH
63501: NOP4
63505: PUSH
63506: NOP4
63510: ARRAY
63511: PUSH
63512: NOP4
63516: ARRAY
63517: PUSH
63518: LD_INT 3
63520: ARRAY
63521: PPUSH
63522: NOP4
63526: PUSH
63527: LD_INT 0
63529: EQUAL
63530: AND
63531: IFFALSE 63586
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63533: NOP4
63537: PUSH
63538: NOP4
63542: PUSH
63543: NOP4
63547: ARRAY
63548: PPUSH
63549: NOP4
63553: PPUSH
63554: NOP4
63558: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63559: NOP4
63563: PUSH
63564: NOP4
63568: PPUSH
63569: NOP4
63573: PPUSH
63574: NOP4
63578: PPUSH
63579: NOP4
63583: ST_TO_ADDR
// continue ;
63584: GO 63430
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63586: NOP4
63590: PPUSH
63591: NOP4
63595: PUSH
63596: NOP4
63600: ARRAY
63601: PUSH
63602: NOP4
63606: ARRAY
63607: PUSH
63608: LD_INT 2
63610: ARRAY
63611: PPUSH
63612: NOP4
63616: PUSH
63617: NOP4
63621: ARRAY
63622: PUSH
63623: NOP4
63627: ARRAY
63628: PUSH
63629: LD_INT 3
63631: ARRAY
63632: PPUSH
63633: LD_INT 30
63635: PPUSH
63636: NOP4
63640: PUSH
63641: LD_INT 4
63643: ARRAY
63644: PUSH
63645: LD_INT 0
63647: EQUAL
63648: IFFALSE 63674
// begin target := mc_crates [ i ] [ j ] ;
63650: NOP4
63654: PUSH
63655: NOP4
63659: PUSH
63660: NOP4
63664: ARRAY
63665: PUSH
63666: NOP4
63670: ARRAY
63671: ST_TO_ADDR
// break ;
63672: GO 63676
// end ; end ;
63674: GO 63430
63676: POP
63677: POP
// if not target then
63678: NOP4
63682: NOT
63683: IFFALSE 63687
// continue ;
63685: GO 63237
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
63687: NOP4
63691: PUSH
63692: NOP4
63696: PUSH
63697: NOP4
63701: ARRAY
63702: PPUSH
63703: LD_INT 2
63705: PUSH
63706: LD_INT 3
63708: PUSH
63709: LD_INT 58
63711: PUSH
63712: EMPTY
63713: LIST
63714: PUSH
63715: EMPTY
63716: LIST
63717: LIST
63718: PUSH
63719: LD_INT 61
63721: PUSH
63722: EMPTY
63723: LIST
63724: PUSH
63725: LD_INT 33
63727: PUSH
63728: LD_INT 5
63730: PUSH
63731: EMPTY
63732: LIST
63733: LIST
63734: PUSH
63735: LD_INT 33
63737: PUSH
63738: LD_INT 3
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: PUSH
63745: EMPTY
63746: LIST
63747: LIST
63748: LIST
63749: LIST
63750: LIST
63751: PUSH
63752: LD_INT 2
63754: PUSH
63755: LD_INT 34
63757: PUSH
63758: LD_INT 32
63760: PUSH
63761: EMPTY
63762: LIST
63763: LIST
63764: PUSH
63765: LD_INT 34
63767: PUSH
63768: LD_INT 51
63770: PUSH
63771: EMPTY
63772: LIST
63773: LIST
63774: PUSH
63775: LD_INT 34
63777: PUSH
63778: LD_INT 12
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: EMPTY
63786: LIST
63787: LIST
63788: LIST
63789: LIST
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: PPUSH
63795: NOP4
63799: ST_TO_ADDR
// if not cargo then
63800: NOP4
63804: NOT
63805: IFFALSE 64511
// begin if mc_crates_collector [ i ] < 5 then
63807: NOP4
63811: PUSH
63812: NOP4
63816: ARRAY
63817: PUSH
63818: LD_INT 5
63820: LESS
63821: IFFALSE 64187
// begin if mc_ape [ i ] then
63823: NOP4
63827: PUSH
63828: NOP4
63832: ARRAY
63833: IFFALSE 63880
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
63835: NOP4
63839: PUSH
63840: NOP4
63844: PUSH
63845: NOP4
63849: ARRAY
63850: PPUSH
63851: LD_INT 25
63853: PUSH
63854: LD_INT 16
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PUSH
63861: LD_INT 24
63863: PUSH
63864: LD_INT 750
63866: PUSH
63867: EMPTY
63868: LIST
63869: LIST
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PPUSH
63875: NOP4
63879: ST_TO_ADDR
// if not tmp then
63880: NOP4
63884: NOT
63885: IFFALSE 63932
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
63887: NOP4
63891: PUSH
63892: NOP4
63896: PUSH
63897: NOP4
63901: ARRAY
63902: PPUSH
63903: LD_INT 25
63905: PUSH
63906: LD_INT 2
63908: PUSH
63909: EMPTY
63910: LIST
63911: LIST
63912: PUSH
63913: LD_INT 24
63915: PUSH
63916: LD_INT 750
63918: PUSH
63919: EMPTY
63920: LIST
63921: LIST
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PPUSH
63927: NOP4
63931: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
63932: NOP4
63936: PUSH
63937: NOP4
63941: ARRAY
63942: PUSH
63943: NOP4
63947: PUSH
63948: NOP4
63952: ARRAY
63953: PPUSH
63954: LD_INT 25
63956: PUSH
63957: LD_INT 2
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PUSH
63964: LD_INT 24
63966: PUSH
63967: LD_INT 750
63969: PUSH
63970: EMPTY
63971: LIST
63972: LIST
63973: PUSH
63974: EMPTY
63975: LIST
63976: LIST
63977: PPUSH
63978: NOP4
63982: AND
63983: PUSH
63984: NOP4
63988: PUSH
63989: LD_INT 5
63991: LESS
63992: AND
63993: IFFALSE 64075
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
63995: NOP4
63999: PUSH
64000: NOP4
64004: PUSH
64005: NOP4
64009: ARRAY
64010: PPUSH
64011: LD_INT 25
64013: PUSH
64014: LD_INT 2
64016: PUSH
64017: EMPTY
64018: LIST
64019: LIST
64020: PUSH
64021: LD_INT 24
64023: PUSH
64024: LD_INT 750
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: PUSH
64031: EMPTY
64032: LIST
64033: LIST
64034: PPUSH
64035: NOP4
64039: PUSH
64040: FOR_IN
64041: IFFALSE 64073
// begin tmp := tmp union j ;
64043: NOP4
64047: PUSH
64048: NOP4
64052: PUSH
64053: NOP4
64057: UNION
64058: ST_TO_ADDR
// if tmp >= 5 then
64059: NOP4
64063: PUSH
64064: LD_INT 5
64066: GREATEREQUAL
64067: IFFALSE 64071
// break ;
64069: GO 64073
// end ;
64071: GO 64040
64073: POP
64074: POP
// end ; if not tmp then
64075: NOP4
64079: NOT
64080: IFFALSE 64084
// continue ;
64082: GO 63237
// for j in tmp do
64084: NOP4
64088: PUSH
64089: NOP4
64093: PUSH
64094: FOR_IN
64095: IFFALSE 64185
// if not GetTag ( j ) then
64097: NOP4
64101: PPUSH
64102: NOP4
64106: NOT
64107: IFFALSE 64183
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64109: NOP4
64113: PUSH
64114: NOP4
64118: PPUSH
64119: NOP4
64123: PUSH
64124: NOP4
64128: PUSH
64129: NOP4
64133: ARRAY
64134: PUSH
64135: LD_INT 1
64137: PLUS
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: PPUSH
64143: NOP4
64147: PPUSH
64148: NOP4
64152: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64153: NOP4
64157: PPUSH
64158: LD_INT 107
64160: PPUSH
64161: NOP4
// if mc_crates_collector [ i ] >= 5 then
64165: NOP4
64169: PUSH
64170: NOP4
64174: ARRAY
64175: PUSH
64176: LD_INT 5
64178: GREATEREQUAL
64179: IFFALSE 64183
// break ;
64181: GO 64185
// end ;
64183: GO 64094
64185: POP
64186: POP
// end ; if mc_crates_collector [ i ] and target then
64187: NOP4
64191: PUSH
64192: NOP4
64196: ARRAY
64197: PUSH
64198: NOP4
64202: AND
64203: IFFALSE 64509
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64205: NOP4
64209: PUSH
64210: NOP4
64214: ARRAY
64215: PUSH
64216: NOP4
64220: PUSH
64221: LD_INT 1
64223: ARRAY
64224: LESS
64225: IFFALSE 64245
// tmp := mc_crates_collector [ i ] else
64227: NOP4
64231: PUSH
64232: NOP4
64236: PUSH
64237: NOP4
64241: ARRAY
64242: ST_TO_ADDR
64243: GO 64259
// tmp := target [ 1 ] ;
64245: NOP4
64249: PUSH
64250: NOP4
64254: PUSH
64255: LD_INT 1
64257: ARRAY
64258: ST_TO_ADDR
// k := 0 ;
64259: NOP4
64263: PUSH
64264: LD_INT 0
64266: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64267: NOP4
64271: PUSH
64272: NOP4
64276: PUSH
64277: NOP4
64281: ARRAY
64282: PUSH
64283: FOR_IN
64284: IFFALSE 64507
// begin k := k + 1 ;
64286: NOP4
64290: PUSH
64291: NOP4
64295: PUSH
64296: LD_INT 1
64298: PLUS
64299: ST_TO_ADDR
// if k > tmp then
64300: NOP4
64304: PUSH
64305: NOP4
64309: GREATER
64310: IFFALSE 64314
// break ;
64312: GO 64507
// if not GetClass ( j ) in [ 2 , 16 ] then
64314: NOP4
64318: PPUSH
64319: NOP4
64323: PUSH
64324: LD_INT 2
64326: PUSH
64327: LD_INT 16
64329: PUSH
64330: EMPTY
64331: LIST
64332: LIST
64333: IN
64334: NOT
64335: IFFALSE 64388
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64337: NOP4
64341: PUSH
64342: NOP4
64346: PPUSH
64347: NOP4
64351: PPUSH
64352: NOP4
64356: PUSH
64357: NOP4
64361: ARRAY
64362: PUSH
64363: NOP4
64367: DIFF
64368: PPUSH
64369: NOP4
64373: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64374: NOP4
64378: PPUSH
64379: LD_INT 0
64381: PPUSH
64382: NOP4
// continue ;
64386: GO 64283
// end ; if IsInUnit ( j ) then
64388: NOP4
64392: PPUSH
64393: NOP4
64397: IFFALSE 64408
// ComExitBuilding ( j ) ;
64399: NOP4
64403: PPUSH
64404: NOP4
// wait ( 3 ) ;
64408: LD_INT 3
64410: PPUSH
64411: NOP4
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
64415: NOP4
64419: PPUSH
64420: NOP4
64424: PUSH
64425: NOP4
64429: PPUSH
64430: NOP4
64434: PUSH
64435: LD_INT 2
64437: ARRAY
64438: PPUSH
64439: NOP4
64443: PUSH
64444: LD_INT 3
64446: ARRAY
64447: PPUSH
64448: LD_INT 30
64450: PPUSH
64451: NOP4
64455: PUSH
64456: LD_INT 4
64458: ARRAY
64459: AND
64460: IFFALSE 64478
// ComStandNearbyBuilding ( j , depot ) else
64462: NOP4
64466: PPUSH
64467: NOP4
64471: PPUSH
64472: NOP4
64476: GO 64505
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64478: NOP4
64482: PPUSH
64483: NOP4
64487: PUSH
64488: LD_INT 2
64490: ARRAY
64491: PPUSH
64492: NOP4
64496: PUSH
64497: LD_INT 3
64499: ARRAY
64500: PPUSH
64501: NOP4
// end ;
64505: GO 64283
64507: POP
64508: POP
// end ; end else
64509: GO 65041
// begin for j in cargo do
64511: NOP4
64515: PUSH
64516: NOP4
64520: PUSH
64521: FOR_IN
64522: IFFALSE 65039
// begin if GetTag ( j ) <> 0 then
64524: NOP4
64528: PPUSH
64529: NOP4
64533: PUSH
64534: LD_INT 0
64536: NONEQUAL
64537: IFFALSE 64541
// continue ;
64539: GO 64521
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64541: NOP4
64545: PPUSH
64546: NOP4
64550: PUSH
64551: LD_INT 1000
64553: LESS
64554: PUSH
64555: NOP4
64559: PPUSH
64560: NOP4
64564: PUSH
64565: NOP4
64569: ARRAY
64570: PPUSH
64571: NOP4
64575: NOT
64576: AND
64577: IFFALSE 64599
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64579: NOP4
64583: PPUSH
64584: NOP4
64588: PUSH
64589: NOP4
64593: ARRAY
64594: PPUSH
64595: NOP4
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64599: NOP4
64603: PPUSH
64604: NOP4
64608: PUSH
64609: LD_INT 1000
64611: LESS
64612: PUSH
64613: NOP4
64617: PPUSH
64618: NOP4
64622: PUSH
64623: NOP4
64627: ARRAY
64628: PPUSH
64629: NOP4
64633: AND
64634: IFFALSE 64638
// continue ;
64636: GO 64521
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64638: NOP4
64642: PPUSH
64643: NOP4
64647: PUSH
64648: LD_INT 2
64650: EQUAL
64651: PUSH
64652: NOP4
64656: PPUSH
64657: NOP4
64661: PUSH
64662: LD_INT 15
64664: LESS
64665: AND
64666: IFFALSE 64670
// continue ;
64668: GO 64521
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64670: NOP4
64674: PPUSH
64675: NOP4
64679: PUSH
64680: LD_INT 1
64682: EQUAL
64683: PUSH
64684: NOP4
64688: PPUSH
64689: NOP4
64693: PUSH
64694: LD_INT 10
64696: LESS
64697: AND
64698: IFFALSE 64978
// begin if not depot then
64700: NOP4
64704: NOT
64705: IFFALSE 64709
// continue ;
64707: GO 64521
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
64709: NOP4
64713: PPUSH
64714: NOP4
64718: PPUSH
64719: NOP4
64723: PPUSH
64724: NOP4
64728: PPUSH
64729: NOP4
64733: PUSH
64734: LD_INT 6
64736: LESS
64737: IFFALSE 64753
// SetFuel ( j , 100 ) else
64739: NOP4
64743: PPUSH
64744: LD_INT 100
64746: PPUSH
64747: NOP4
64751: GO 64978
// if GetFuel ( j ) = 0 then
64753: NOP4
64757: PPUSH
64758: NOP4
64762: PUSH
64763: LD_INT 0
64765: EQUAL
64766: IFFALSE 64978
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
64768: NOP4
64772: PUSH
64773: NOP4
64777: PPUSH
64778: NOP4
64782: PPUSH
64783: NOP4
64787: PUSH
64788: NOP4
64792: ARRAY
64793: PUSH
64794: NOP4
64798: DIFF
64799: PPUSH
64800: NOP4
64804: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
64805: NOP4
64809: PPUSH
64810: NOP4
64814: PUSH
64815: LD_INT 1
64817: EQUAL
64818: IFFALSE 64834
// ComExitVehicle ( IsInUnit ( j ) ) ;
64820: NOP4
64824: PPUSH
64825: NOP4
64829: PPUSH
64830: NOP4
// if GetControl ( j ) = control_remote then
64834: NOP4
64838: PPUSH
64839: NOP4
64843: PUSH
64844: LD_INT 2
64846: EQUAL
64847: IFFALSE 64858
// ComUnlink ( j ) ;
64849: NOP4
64853: PPUSH
64854: NOP4
// fac := MC_GetBuildings ( i , b_factory ) ;
64858: NOP4
64862: PUSH
64863: NOP4
64867: PPUSH
64868: LD_INT 3
64870: PPUSH
64871: NOP4
64875: ST_TO_ADDR
// if fac then
64876: NOP4
64880: IFFALSE 64976
// begin for k in fac do
64882: NOP4
64886: PUSH
64887: NOP4
64891: PUSH
64892: FOR_IN
64893: IFFALSE 64974
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
64895: NOP4
64899: PUSH
64900: NOP4
64904: PPUSH
64905: NOP4
64909: PPUSH
64910: NOP4
64914: PPUSH
64915: NOP4
64919: PPUSH
64920: NOP4
64924: PPUSH
64925: NOP4
64929: PPUSH
64930: NOP4
64934: PPUSH
64935: NOP4
64939: PPUSH
64940: NOP4
64944: PPUSH
64945: NOP4
64949: ST_TO_ADDR
// if components then
64950: NOP4
64954: IFFALSE 64972
// begin MC_InsertProduceList ( i , components ) ;
64956: NOP4
64960: PPUSH
64961: NOP4
64965: PPUSH
64966: NOP4
// break ;
64970: GO 64974
// end ; end ;
64972: GO 64892
64974: POP
64975: POP
// end ; continue ;
64976: GO 64521
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
64978: NOP4
64982: PPUSH
64983: LD_INT 1
64985: PPUSH
64986: NOP4
64990: PUSH
64991: LD_INT 100
64993: LESS
64994: PUSH
64995: NOP4
64999: PPUSH
65000: NOP4
65004: NOT
65005: AND
65006: IFFALSE 65035
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65008: NOP4
65012: PPUSH
65013: NOP4
65017: PUSH
65018: LD_INT 2
65020: ARRAY
65021: PPUSH
65022: NOP4
65026: PUSH
65027: LD_INT 3
65029: ARRAY
65030: PPUSH
65031: NOP4
// break ;
65035: GO 65039
// end ;
65037: GO 64521
65039: POP
65040: POP
// end ; end ;
65041: GO 63237
65043: POP
65044: POP
// end ;
65045: LD_VAR 0 1
65049: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65050: LD_INT 0
65052: PPUSH
65053: PPUSH
65054: PPUSH
65055: PPUSH
// if not mc_bases then
65056: NOP4
65060: NOT
65061: IFFALSE 65065
// exit ;
65063: GO 65226
// for i = 1 to mc_bases do
65065: NOP4
65069: PUSH
65070: DOUBLE
65071: LD_INT 1
65073: DEC
65074: ST_TO_ADDR
65075: NOP4
65079: PUSH
65080: FOR_TO
65081: IFFALSE 65224
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65083: NOP4
65087: PUSH
65088: NOP4
65092: PUSH
65093: NOP4
65097: ARRAY
65098: PUSH
65099: NOP4
65103: PUSH
65104: NOP4
65108: ARRAY
65109: UNION
65110: PPUSH
65111: LD_INT 33
65113: PUSH
65114: LD_INT 2
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PPUSH
65121: NOP4
65125: ST_TO_ADDR
// if tmp then
65126: NOP4
65130: IFFALSE 65222
// for j in tmp do
65132: NOP4
65136: PUSH
65137: NOP4
65141: PUSH
65142: FOR_IN
65143: IFFALSE 65220
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65145: NOP4
65149: PPUSH
65150: NOP4
65154: NOT
65155: PUSH
65156: NOP4
65160: PPUSH
65161: NOP4
65165: PUSH
65166: LD_INT 250
65168: GREATEREQUAL
65169: AND
65170: IFFALSE 65183
// Connect ( j ) else
65172: NOP4
65176: PPUSH
65177: NOP4
65181: GO 65218
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65183: NOP4
65187: PPUSH
65188: NOP4
65192: PUSH
65193: LD_INT 250
65195: LESS
65196: PUSH
65197: NOP4
65201: PPUSH
65202: NOP4
65206: AND
65207: IFFALSE 65218
// ComUnlink ( j ) ;
65209: NOP4
65213: PPUSH
65214: NOP4
65218: GO 65142
65220: POP
65221: POP
// end ;
65222: GO 65080
65224: POP
65225: POP
// end ;
65226: LD_VAR 0 1
65230: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65231: LD_INT 0
65233: PPUSH
65234: PPUSH
65235: PPUSH
65236: PPUSH
65237: PPUSH
// if not mc_bases then
65238: NOP4
65242: NOT
65243: IFFALSE 65247
// exit ;
65245: GO 65692
// for i = 1 to mc_bases do
65247: NOP4
65251: PUSH
65252: DOUBLE
65253: LD_INT 1
65255: DEC
65256: ST_TO_ADDR
65257: NOP4
65261: PUSH
65262: FOR_TO
65263: IFFALSE 65690
// begin if not mc_produce [ i ] then
65265: NOP4
65269: PUSH
65270: NOP4
65274: ARRAY
65275: NOT
65276: IFFALSE 65280
// continue ;
65278: GO 65262
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65280: NOP4
65284: PUSH
65285: NOP4
65289: PUSH
65290: NOP4
65294: ARRAY
65295: PPUSH
65296: LD_INT 30
65298: PUSH
65299: LD_INT 3
65301: PUSH
65302: EMPTY
65303: LIST
65304: LIST
65305: PPUSH
65306: NOP4
65310: ST_TO_ADDR
// if not fac then
65311: NOP4
65315: NOT
65316: IFFALSE 65320
// continue ;
65318: GO 65262
// for j in fac do
65320: NOP4
65324: PUSH
65325: NOP4
65329: PUSH
65330: FOR_IN
65331: IFFALSE 65686
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65333: NOP4
65337: PPUSH
65338: NOP4
65342: PUSH
65343: LD_INT 2
65345: NONEQUAL
65346: PUSH
65347: NOP4
65351: PPUSH
65352: LD_INT 15
65354: PPUSH
65355: NOP4
65359: PUSH
65360: LD_INT 4
65362: ARRAY
65363: OR
65364: IFFALSE 65368
// continue ;
65366: GO 65330
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65368: NOP4
65372: PPUSH
65373: NOP4
65377: PUSH
65378: NOP4
65382: ARRAY
65383: PUSH
65384: LD_INT 1
65386: ARRAY
65387: PUSH
65388: LD_INT 1
65390: ARRAY
65391: PPUSH
65392: NOP4
65396: PUSH
65397: NOP4
65401: ARRAY
65402: PUSH
65403: LD_INT 1
65405: ARRAY
65406: PUSH
65407: LD_INT 2
65409: ARRAY
65410: PPUSH
65411: NOP4
65415: PUSH
65416: NOP4
65420: ARRAY
65421: PUSH
65422: LD_INT 1
65424: ARRAY
65425: PUSH
65426: LD_INT 3
65428: ARRAY
65429: PPUSH
65430: NOP4
65434: PUSH
65435: NOP4
65439: ARRAY
65440: PUSH
65441: LD_INT 1
65443: ARRAY
65444: PUSH
65445: LD_INT 4
65447: ARRAY
65448: PPUSH
65449: NOP4
65453: PUSH
65454: NOP4
65458: PPUSH
65459: NOP4
65463: PUSH
65464: NOP4
65468: ARRAY
65469: PUSH
65470: LD_INT 1
65472: ARRAY
65473: PUSH
65474: LD_INT 1
65476: ARRAY
65477: PUSH
65478: NOP4
65482: PUSH
65483: NOP4
65487: ARRAY
65488: PUSH
65489: LD_INT 1
65491: ARRAY
65492: PUSH
65493: LD_INT 2
65495: ARRAY
65496: PUSH
65497: NOP4
65501: PUSH
65502: NOP4
65506: ARRAY
65507: PUSH
65508: LD_INT 1
65510: ARRAY
65511: PUSH
65512: LD_INT 3
65514: ARRAY
65515: PUSH
65516: NOP4
65520: PUSH
65521: NOP4
65525: ARRAY
65526: PUSH
65527: LD_INT 1
65529: ARRAY
65530: PUSH
65531: LD_INT 4
65533: ARRAY
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: LIST
65539: LIST
65540: PPUSH
65541: NOP4
65545: AND
65546: IFFALSE 65684
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65548: NOP4
65552: PPUSH
65553: NOP4
65557: PUSH
65558: NOP4
65562: ARRAY
65563: PUSH
65564: LD_INT 1
65566: ARRAY
65567: PUSH
65568: LD_INT 1
65570: ARRAY
65571: PPUSH
65572: NOP4
65576: PUSH
65577: NOP4
65581: ARRAY
65582: PUSH
65583: LD_INT 1
65585: ARRAY
65586: PUSH
65587: LD_INT 2
65589: ARRAY
65590: PPUSH
65591: NOP4
65595: PUSH
65596: NOP4
65600: ARRAY
65601: PUSH
65602: LD_INT 1
65604: ARRAY
65605: PUSH
65606: LD_INT 3
65608: ARRAY
65609: PPUSH
65610: NOP4
65614: PUSH
65615: NOP4
65619: ARRAY
65620: PUSH
65621: LD_INT 1
65623: ARRAY
65624: PUSH
65625: LD_INT 4
65627: ARRAY
65628: PPUSH
65629: NOP4
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65633: NOP4
65637: PUSH
65638: NOP4
65642: PUSH
65643: NOP4
65647: ARRAY
65648: PPUSH
65649: LD_INT 1
65651: PPUSH
65652: NOP4
65656: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65657: NOP4
65661: PUSH
65662: NOP4
65666: PPUSH
65667: NOP4
65671: PPUSH
65672: NOP4
65676: PPUSH
65677: NOP4
65681: ST_TO_ADDR
// break ;
65682: GO 65686
// end ; end ;
65684: GO 65330
65686: POP
65687: POP
// end ;
65688: GO 65262
65690: POP
65691: POP
// end ;
65692: LD_VAR 0 1
65696: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
65697: LD_INT 0
65699: PPUSH
65700: PPUSH
65701: PPUSH
// if not mc_bases then
65702: NOP4
65706: NOT
65707: IFFALSE 65711
// exit ;
65709: GO 65800
// for i = 1 to mc_bases do
65711: NOP4
65715: PUSH
65716: DOUBLE
65717: LD_INT 1
65719: DEC
65720: ST_TO_ADDR
65721: NOP4
65725: PUSH
65726: FOR_TO
65727: IFFALSE 65798
// begin if mc_attack [ i ] then
65729: NOP4
65733: PUSH
65734: NOP4
65738: ARRAY
65739: IFFALSE 65796
// begin tmp := mc_attack [ i ] [ 1 ] ;
65741: NOP4
65745: PUSH
65746: NOP4
65750: PUSH
65751: NOP4
65755: ARRAY
65756: PUSH
65757: LD_INT 1
65759: ARRAY
65760: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
65761: NOP4
65765: PUSH
65766: NOP4
65770: PPUSH
65771: NOP4
65775: PPUSH
65776: EMPTY
65777: PPUSH
65778: NOP4
65782: ST_TO_ADDR
// Attack ( tmp ) ;
65783: NOP4
65787: PPUSH
65788: NOP4
// exit ;
65792: POP
65793: POP
65794: GO 65800
// end ; end ;
65796: GO 65726
65798: POP
65799: POP
// end ;
65800: LD_VAR 0 1
65804: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
65805: LD_INT 0
65807: PPUSH
65808: PPUSH
65809: PPUSH
65810: PPUSH
65811: PPUSH
65812: PPUSH
65813: PPUSH
// if not mc_bases then
65814: NOP4
65818: NOT
65819: IFFALSE 65823
// exit ;
65821: GO 66680
// for i = 1 to mc_bases do
65823: NOP4
65827: PUSH
65828: DOUBLE
65829: LD_INT 1
65831: DEC
65832: ST_TO_ADDR
65833: NOP4
65837: PUSH
65838: FOR_TO
65839: IFFALSE 66678
// begin if not mc_bases [ i ] then
65841: NOP4
65845: PUSH
65846: NOP4
65850: ARRAY
65851: NOT
65852: IFFALSE 65856
// continue ;
65854: GO 65838
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
65856: NOP4
65860: PUSH
65861: NOP4
65865: PUSH
65866: NOP4
65870: ARRAY
65871: PUSH
65872: LD_INT 1
65874: ARRAY
65875: PPUSH
65876: NOP4
65880: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
65881: NOP4
65885: PUSH
65886: NOP4
65890: PPUSH
65891: NOP4
65895: PPUSH
65896: NOP4
65900: PUSH
65901: NOP4
65905: ARRAY
65906: PUSH
65907: LD_INT 1
65909: ARRAY
65910: PPUSH
65911: NOP4
65915: PPUSH
65916: NOP4
65920: PUSH
65921: NOP4
65925: ARRAY
65926: PPUSH
65927: NOP4
65931: PPUSH
65932: NOP4
65936: ST_TO_ADDR
// if not mc_scan [ i ] then
65937: NOP4
65941: PUSH
65942: NOP4
65946: ARRAY
65947: NOT
65948: IFFALSE 66126
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
65950: NOP4
65954: PUSH
65955: NOP4
65959: PPUSH
65960: NOP4
65964: PPUSH
65965: LD_INT 0
65967: PPUSH
65968: NOP4
65972: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65973: NOP4
65977: PUSH
65978: NOP4
65982: PUSH
65983: NOP4
65987: ARRAY
65988: PPUSH
65989: LD_INT 2
65991: PUSH
65992: LD_INT 25
65994: PUSH
65995: LD_INT 5
65997: PUSH
65998: EMPTY
65999: LIST
66000: LIST
66001: PUSH
66002: LD_INT 25
66004: PUSH
66005: LD_INT 8
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: PUSH
66012: LD_INT 25
66014: PUSH
66015: LD_INT 9
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: LIST
66026: LIST
66027: PPUSH
66028: NOP4
66032: ST_TO_ADDR
// if not tmp then
66033: NOP4
66037: NOT
66038: IFFALSE 66042
// continue ;
66040: GO 65838
// for j in tmp do
66042: NOP4
66046: PUSH
66047: NOP4
66051: PUSH
66052: FOR_IN
66053: IFFALSE 66124
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66055: NOP4
66059: PPUSH
66060: NOP4
66064: PPUSH
66065: NOP4
66069: PUSH
66070: LD_INT 5
66072: EQUAL
66073: PUSH
66074: NOP4
66078: PPUSH
66079: NOP4
66083: PUSH
66084: LD_INT 1
66086: EQUAL
66087: AND
66088: PUSH
66089: NOP4
66093: PPUSH
66094: NOP4
66098: NOT
66099: AND
66100: PUSH
66101: NOP4
66105: AND
66106: IFFALSE 66122
// ComChangeProfession ( j , class ) ;
66108: NOP4
66112: PPUSH
66113: NOP4
66117: PPUSH
66118: NOP4
66122: GO 66052
66124: POP
66125: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
66126: NOP4
66130: PUSH
66131: NOP4
66135: ARRAY
66136: PUSH
66137: NOP4
66141: PUSH
66142: NOP4
66146: ARRAY
66147: NOT
66148: AND
66149: PUSH
66150: NOP4
66154: PUSH
66155: NOP4
66159: ARRAY
66160: NOT
66161: AND
66162: PUSH
66163: NOP4
66167: PUSH
66168: NOP4
66172: ARRAY
66173: PPUSH
66174: LD_INT 50
66176: PUSH
66177: EMPTY
66178: LIST
66179: PUSH
66180: LD_INT 2
66182: PUSH
66183: LD_INT 30
66185: PUSH
66186: LD_INT 32
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PUSH
66193: LD_INT 30
66195: PUSH
66196: LD_INT 33
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: PUSH
66203: LD_INT 30
66205: PUSH
66206: LD_INT 4
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PUSH
66213: LD_INT 30
66215: PUSH
66216: LD_INT 5
66218: PUSH
66219: EMPTY
66220: LIST
66221: LIST
66222: PUSH
66223: EMPTY
66224: LIST
66225: LIST
66226: LIST
66227: LIST
66228: LIST
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PPUSH
66234: NOP4
66238: PUSH
66239: LD_INT 4
66241: LESS
66242: PUSH
66243: NOP4
66247: PUSH
66248: NOP4
66252: ARRAY
66253: PPUSH
66254: LD_INT 3
66256: PUSH
66257: LD_INT 24
66259: PUSH
66260: LD_INT 1000
66262: PUSH
66263: EMPTY
66264: LIST
66265: LIST
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: LD_INT 2
66273: PUSH
66274: LD_INT 30
66276: PUSH
66277: LD_INT 0
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PUSH
66284: LD_INT 30
66286: PUSH
66287: LD_INT 1
66289: PUSH
66290: EMPTY
66291: LIST
66292: LIST
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: LIST
66298: PUSH
66299: EMPTY
66300: LIST
66301: LIST
66302: PPUSH
66303: NOP4
66307: OR
66308: AND
66309: IFFALSE 66560
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
66311: NOP4
66315: PUSH
66316: NOP4
66320: PPUSH
66321: NOP4
66325: PPUSH
66326: LD_INT 1
66328: PPUSH
66329: NOP4
66333: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66334: NOP4
66338: PUSH
66339: NOP4
66343: PUSH
66344: NOP4
66348: ARRAY
66349: PPUSH
66350: LD_INT 2
66352: PUSH
66353: LD_INT 25
66355: PUSH
66356: LD_INT 1
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: PUSH
66363: LD_INT 25
66365: PUSH
66366: LD_INT 5
66368: PUSH
66369: EMPTY
66370: LIST
66371: LIST
66372: PUSH
66373: LD_INT 25
66375: PUSH
66376: LD_INT 8
66378: PUSH
66379: EMPTY
66380: LIST
66381: LIST
66382: PUSH
66383: LD_INT 25
66385: PUSH
66386: LD_INT 9
66388: PUSH
66389: EMPTY
66390: LIST
66391: LIST
66392: PUSH
66393: EMPTY
66394: LIST
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: PPUSH
66400: NOP4
66404: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66405: NOP4
66409: PUSH
66410: NOP4
66414: PUSH
66415: NOP4
66419: PPUSH
66420: LD_INT 18
66422: PPUSH
66423: NOP4
66427: DIFF
66428: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
66429: NOP4
66433: NOT
66434: PUSH
66435: NOP4
66439: PUSH
66440: NOP4
66444: ARRAY
66445: PPUSH
66446: LD_INT 2
66448: PUSH
66449: LD_INT 30
66451: PUSH
66452: LD_INT 4
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: LD_INT 30
66461: PUSH
66462: LD_INT 5
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: LIST
66473: PPUSH
66474: NOP4
66478: NOT
66479: AND
66480: IFFALSE 66542
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
66482: NOP4
66486: PUSH
66487: NOP4
66491: PUSH
66492: NOP4
66496: ARRAY
66497: PPUSH
66498: LD_INT 2
66500: PUSH
66501: LD_INT 25
66503: PUSH
66504: LD_INT 2
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PUSH
66511: LD_INT 25
66513: PUSH
66514: LD_INT 3
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PUSH
66521: LD_INT 25
66523: PUSH
66524: LD_INT 4
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: PPUSH
66537: NOP4
66541: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
66542: NOP4
66546: PPUSH
66547: NOP4
66551: PPUSH
66552: NOP4
// exit ;
66556: POP
66557: POP
66558: GO 66680
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
66560: NOP4
66564: PUSH
66565: NOP4
66569: ARRAY
66570: PUSH
66571: NOP4
66575: PUSH
66576: NOP4
66580: ARRAY
66581: NOT
66582: AND
66583: PUSH
66584: NOP4
66588: PUSH
66589: NOP4
66593: ARRAY
66594: AND
66595: IFFALSE 66676
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
66597: NOP4
66601: PUSH
66602: NOP4
66606: PPUSH
66607: NOP4
66611: PPUSH
66612: LD_INT 1
66614: PPUSH
66615: NOP4
66619: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
66620: NOP4
66624: PUSH
66625: NOP4
66629: PUSH
66630: NOP4
66634: ARRAY
66635: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
66636: NOP4
66640: PUSH
66641: NOP4
66645: PPUSH
66646: NOP4
66650: PPUSH
66651: EMPTY
66652: PPUSH
66653: NOP4
66657: ST_TO_ADDR
// Defend ( i , tmp ) ;
66658: NOP4
66662: PPUSH
66663: NOP4
66667: PPUSH
66668: NOP4
// exit ;
66672: POP
66673: POP
66674: GO 66680
// end ; end ;
66676: GO 65838
66678: POP
66679: POP
// end ;
66680: LD_VAR 0 1
66684: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66685: LD_INT 0
66687: PPUSH
66688: PPUSH
66689: PPUSH
66690: PPUSH
66691: PPUSH
66692: PPUSH
66693: PPUSH
66694: PPUSH
66695: PPUSH
66696: PPUSH
66697: PPUSH
// if not mc_bases then
66698: NOP4
66702: NOT
66703: IFFALSE 66707
// exit ;
66705: GO 67794
// for i = 1 to mc_bases do
66707: NOP4
66711: PUSH
66712: DOUBLE
66713: LD_INT 1
66715: DEC
66716: ST_TO_ADDR
66717: NOP4
66721: PUSH
66722: FOR_TO
66723: IFFALSE 67792
// begin tmp := mc_lab [ i ] ;
66725: NOP4
66729: PUSH
66730: NOP4
66734: PUSH
66735: NOP4
66739: ARRAY
66740: ST_TO_ADDR
// if not tmp then
66741: NOP4
66745: NOT
66746: IFFALSE 66750
// continue ;
66748: GO 66722
// idle_lab := 0 ;
66750: NOP4
66754: PUSH
66755: LD_INT 0
66757: ST_TO_ADDR
// for j in tmp do
66758: NOP4
66762: PUSH
66763: NOP4
66767: PUSH
66768: FOR_IN
66769: IFFALSE 67788
// begin researching := false ;
66771: NOP4
66775: PUSH
66776: LD_INT 0
66778: ST_TO_ADDR
// side := GetSide ( j ) ;
66779: NOP4
66783: PUSH
66784: NOP4
66788: PPUSH
66789: NOP4
66793: ST_TO_ADDR
// if not mc_tech [ side ] then
66794: NOP4
66798: PUSH
66799: NOP4
66803: ARRAY
66804: NOT
66805: IFFALSE 66809
// continue ;
66807: GO 66768
// if BuildingStatus ( j ) = bs_idle then
66809: NOP4
66813: PPUSH
66814: NOP4
66818: PUSH
66819: LD_INT 2
66821: EQUAL
66822: IFFALSE 67010
// begin if idle_lab and UnitsInside ( j ) < 6 then
66824: NOP4
66828: PUSH
66829: NOP4
66833: PPUSH
66834: NOP4
66838: PUSH
66839: LD_INT 6
66841: LESS
66842: AND
66843: IFFALSE 66914
// begin tmp2 := UnitsInside ( idle_lab ) ;
66845: NOP4
66849: PUSH
66850: NOP4
66854: PPUSH
66855: NOP4
66859: ST_TO_ADDR
// if tmp2 then
66860: NOP4
66864: IFFALSE 66906
// for x in tmp2 do
66866: NOP4
66870: PUSH
66871: NOP4
66875: PUSH
66876: FOR_IN
66877: IFFALSE 66904
// begin ComExitBuilding ( x ) ;
66879: NOP4
66883: PPUSH
66884: NOP4
// AddComEnterUnit ( x , j ) ;
66888: NOP4
66892: PPUSH
66893: NOP4
66897: PPUSH
66898: NOP4
// end ;
66902: GO 66876
66904: POP
66905: POP
// idle_lab := 0 ;
66906: NOP4
66910: PUSH
66911: LD_INT 0
66913: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
66914: NOP4
66918: PUSH
66919: NOP4
66923: PUSH
66924: NOP4
66928: ARRAY
66929: PUSH
66930: FOR_IN
66931: IFFALSE 66991
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
66933: NOP4
66937: PPUSH
66938: NOP4
66942: PPUSH
66943: NOP4
66947: PUSH
66948: NOP4
66952: PPUSH
66953: NOP4
66957: PPUSH
66958: NOP4
66962: AND
66963: IFFALSE 66989
// begin researching := true ;
66965: NOP4
66969: PUSH
66970: LD_INT 1
66972: ST_TO_ADDR
// ComResearch ( j , t ) ;
66973: NOP4
66977: PPUSH
66978: NOP4
66982: PPUSH
66983: NOP4
// break ;
66987: GO 66991
// end ;
66989: GO 66930
66991: POP
66992: POP
// if not researching then
66993: NOP4
66997: NOT
66998: IFFALSE 67010
// idle_lab := j ;
67000: NOP4
67004: PUSH
67005: NOP4
67009: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67010: NOP4
67014: PPUSH
67015: NOP4
67019: PUSH
67020: LD_INT 10
67022: EQUAL
67023: IFFALSE 67611
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67025: NOP4
67029: PUSH
67030: NOP4
67034: ARRAY
67035: NOT
67036: PUSH
67037: NOP4
67041: PUSH
67042: NOP4
67046: ARRAY
67047: NOT
67048: AND
67049: PUSH
67050: NOP4
67054: PUSH
67055: NOP4
67059: ARRAY
67060: PUSH
67061: LD_INT 1
67063: GREATER
67064: AND
67065: IFFALSE 67196
// begin ComCancel ( j ) ;
67067: NOP4
67071: PPUSH
67072: NOP4
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67076: NOP4
67080: PUSH
67081: NOP4
67085: PPUSH
67086: NOP4
67090: PPUSH
67091: NOP4
67095: PUSH
67096: NOP4
67100: ARRAY
67101: PPUSH
67102: NOP4
67106: PUSH
67107: NOP4
67111: ARRAY
67112: PUSH
67113: LD_INT 1
67115: MINUS
67116: PPUSH
67117: NOP4
67121: PUSH
67122: NOP4
67126: ARRAY
67127: PPUSH
67128: LD_INT 0
67130: PPUSH
67131: NOP4
67135: PPUSH
67136: NOP4
67140: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67141: NOP4
67145: PUSH
67146: NOP4
67150: PPUSH
67151: NOP4
67155: PPUSH
67156: NOP4
67160: PUSH
67161: NOP4
67165: ARRAY
67166: PPUSH
67167: NOP4
67171: PUSH
67172: NOP4
67176: ARRAY
67177: PPUSH
67178: LD_INT 1
67180: PPUSH
67181: LD_INT 0
67183: PPUSH
67184: NOP4
67188: PPUSH
67189: NOP4
67193: ST_TO_ADDR
// continue ;
67194: GO 66768
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67196: NOP4
67200: PUSH
67201: NOP4
67205: ARRAY
67206: PUSH
67207: NOP4
67211: PUSH
67212: NOP4
67216: ARRAY
67217: NOT
67218: AND
67219: IFFALSE 67346
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67221: NOP4
67225: PUSH
67226: NOP4
67230: PPUSH
67231: NOP4
67235: PUSH
67236: NOP4
67240: PUSH
67241: NOP4
67245: ARRAY
67246: PUSH
67247: LD_INT 1
67249: PLUS
67250: PUSH
67251: EMPTY
67252: LIST
67253: LIST
67254: PPUSH
67255: NOP4
67259: PUSH
67260: NOP4
67264: ARRAY
67265: PUSH
67266: LD_INT 1
67268: ARRAY
67269: PPUSH
67270: NOP4
67274: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67275: NOP4
67279: PUSH
67280: NOP4
67284: ARRAY
67285: PUSH
67286: LD_INT 1
67288: ARRAY
67289: PPUSH
67290: LD_INT 112
67292: PPUSH
67293: NOP4
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67297: NOP4
67301: PUSH
67302: NOP4
67306: PUSH
67307: NOP4
67311: ARRAY
67312: PPUSH
67313: LD_INT 1
67315: PPUSH
67316: NOP4
67320: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67321: NOP4
67325: PUSH
67326: NOP4
67330: PPUSH
67331: NOP4
67335: PPUSH
67336: NOP4
67340: PPUSH
67341: NOP4
67345: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67346: NOP4
67350: PUSH
67351: NOP4
67355: ARRAY
67356: PUSH
67357: NOP4
67361: PUSH
67362: NOP4
67366: ARRAY
67367: AND
67368: PUSH
67369: NOP4
67373: PUSH
67374: NOP4
67378: ARRAY
67379: PUSH
67380: LD_INT 1
67382: ARRAY
67383: PPUSH
67384: NOP4
67388: NOT
67389: AND
67390: PUSH
67391: NOP4
67395: PPUSH
67396: NOP4
67400: PUSH
67401: LD_INT 6
67403: EQUAL
67404: AND
67405: IFFALSE 67461
// begin tmp2 := UnitsInside ( j ) ;
67407: NOP4
67411: PUSH
67412: NOP4
67416: PPUSH
67417: NOP4
67421: ST_TO_ADDR
// if tmp2 = 6 then
67422: NOP4
67426: PUSH
67427: LD_INT 6
67429: EQUAL
67430: IFFALSE 67461
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67432: NOP4
67436: PUSH
67437: LD_INT 1
67439: ARRAY
67440: PPUSH
67441: LD_INT 112
67443: PPUSH
67444: NOP4
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67448: NOP4
67452: PUSH
67453: LD_INT 1
67455: ARRAY
67456: PPUSH
67457: NOP4
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67461: NOP4
67465: PUSH
67466: NOP4
67470: ARRAY
67471: PUSH
67472: NOP4
67476: PUSH
67477: NOP4
67481: ARRAY
67482: PUSH
67483: LD_INT 1
67485: ARRAY
67486: PPUSH
67487: NOP4
67491: NOT
67492: AND
67493: PUSH
67494: NOP4
67498: PUSH
67499: NOP4
67503: ARRAY
67504: PUSH
67505: LD_INT 1
67507: ARRAY
67508: PPUSH
67509: NOP4
67513: NOT
67514: AND
67515: IFFALSE 67541
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67517: NOP4
67521: PUSH
67522: NOP4
67526: ARRAY
67527: PUSH
67528: LD_INT 1
67530: ARRAY
67531: PPUSH
67532: NOP4
67536: PPUSH
67537: NOP4
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67541: NOP4
67545: PUSH
67546: NOP4
67550: ARRAY
67551: PUSH
67552: LD_INT 1
67554: ARRAY
67555: PPUSH
67556: NOP4
67560: PUSH
67561: NOP4
67565: PUSH
67566: NOP4
67570: ARRAY
67571: PUSH
67572: LD_INT 1
67574: ARRAY
67575: PPUSH
67576: NOP4
67580: PPUSH
67581: NOP4
67585: PUSH
67586: LD_INT 3
67588: NONEQUAL
67589: AND
67590: IFFALSE 67611
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67592: NOP4
67596: PUSH
67597: NOP4
67601: ARRAY
67602: PUSH
67603: LD_INT 1
67605: ARRAY
67606: PPUSH
67607: NOP4
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67611: NOP4
67615: PPUSH
67616: NOP4
67620: PUSH
67621: LD_INT 6
67623: EQUAL
67624: PUSH
67625: NOP4
67629: PUSH
67630: LD_INT 1
67632: GREATER
67633: AND
67634: IFFALSE 67786
// begin sci := [ ] ;
67636: NOP4
67640: PUSH
67641: EMPTY
67642: ST_TO_ADDR
// for x in ( tmp diff j ) do
67643: NOP4
67647: PUSH
67648: NOP4
67652: PUSH
67653: NOP4
67657: DIFF
67658: PUSH
67659: FOR_IN
67660: IFFALSE 67712
// begin if sci = 6 then
67662: NOP4
67666: PUSH
67667: LD_INT 6
67669: EQUAL
67670: IFFALSE 67674
// break ;
67672: GO 67712
// if BuildingStatus ( x ) = bs_idle then
67674: NOP4
67678: PPUSH
67679: NOP4
67683: PUSH
67684: LD_INT 2
67686: EQUAL
67687: IFFALSE 67710
// sci := sci ^ UnitsInside ( x ) ;
67689: NOP4
67693: PUSH
67694: NOP4
67698: PUSH
67699: NOP4
67703: PPUSH
67704: NOP4
67708: ADD
67709: ST_TO_ADDR
// end ;
67710: GO 67659
67712: POP
67713: POP
// if not sci then
67714: NOP4
67718: NOT
67719: IFFALSE 67723
// continue ;
67721: GO 66768
// for x in sci do
67723: NOP4
67727: PUSH
67728: NOP4
67732: PUSH
67733: FOR_IN
67734: IFFALSE 67784
// if IsInUnit ( x ) and not HasTask ( x ) then
67736: NOP4
67740: PPUSH
67741: NOP4
67745: PUSH
67746: NOP4
67750: PPUSH
67751: NOP4
67755: NOT
67756: AND
67757: IFFALSE 67782
// begin ComExitBuilding ( x ) ;
67759: NOP4
67763: PPUSH
67764: NOP4
// AddComEnterUnit ( x , j ) ;
67768: NOP4
67772: PPUSH
67773: NOP4
67777: PPUSH
67778: NOP4
// end ;
67782: GO 67733
67784: POP
67785: POP
// end ; end ;
67786: GO 66768
67788: POP
67789: POP
// end ;
67790: GO 66722
67792: POP
67793: POP
// end ;
67794: LD_VAR 0 1
67798: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67799: LD_INT 0
67801: PPUSH
67802: PPUSH
// if not mc_bases then
67803: NOP4
67807: NOT
67808: IFFALSE 67812
// exit ;
67810: GO 67893
// for i = 1 to mc_bases do
67812: NOP4
67816: PUSH
67817: DOUBLE
67818: LD_INT 1
67820: DEC
67821: ST_TO_ADDR
67822: NOP4
67826: PUSH
67827: FOR_TO
67828: IFFALSE 67891
// if mc_mines [ i ] and mc_miners [ i ] then
67830: NOP4
67834: PUSH
67835: NOP4
67839: ARRAY
67840: PUSH
67841: NOP4
67845: PUSH
67846: NOP4
67850: ARRAY
67851: AND
67852: IFFALSE 67889
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67854: NOP4
67858: PUSH
67859: NOP4
67863: ARRAY
67864: PUSH
67865: LD_INT 1
67867: ARRAY
67868: PPUSH
67869: NOP4
67873: PPUSH
67874: NOP4
67878: PUSH
67879: NOP4
67883: ARRAY
67884: PPUSH
67885: NOP4
67889: GO 67827
67891: POP
67892: POP
// end ;
67893: LD_VAR 0 1
67897: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67898: LD_INT 0
67900: PPUSH
67901: PPUSH
67902: PPUSH
67903: PPUSH
67904: PPUSH
67905: PPUSH
67906: PPUSH
67907: PPUSH
// if not mc_bases or not mc_parking then
67908: NOP4
67912: NOT
67913: PUSH
67914: NOP4
67918: NOT
67919: OR
67920: IFFALSE 67924
// exit ;
67922: GO 68634
// for i = 1 to mc_bases do
67924: NOP4
67928: PUSH
67929: DOUBLE
67930: LD_INT 1
67932: DEC
67933: ST_TO_ADDR
67934: NOP4
67938: PUSH
67939: FOR_TO
67940: IFFALSE 68632
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
67942: NOP4
67946: PUSH
67947: NOP4
67951: ARRAY
67952: NOT
67953: PUSH
67954: NOP4
67958: PUSH
67959: NOP4
67963: ARRAY
67964: NOT
67965: OR
67966: IFFALSE 67970
// continue ;
67968: GO 67939
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67970: NOP4
67974: PUSH
67975: NOP4
67979: PUSH
67980: NOP4
67984: ARRAY
67985: PUSH
67986: LD_INT 1
67988: ARRAY
67989: PPUSH
67990: NOP4
67994: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67995: NOP4
67999: PUSH
68000: NOP4
68004: PUSH
68005: NOP4
68009: ARRAY
68010: PPUSH
68011: LD_INT 30
68013: PUSH
68014: LD_INT 3
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: PPUSH
68021: NOP4
68025: ST_TO_ADDR
// if not fac then
68026: NOP4
68030: NOT
68031: IFFALSE 68082
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68033: NOP4
68037: PUSH
68038: NOP4
68042: PUSH
68043: NOP4
68047: ARRAY
68048: PPUSH
68049: LD_INT 2
68051: PUSH
68052: LD_INT 30
68054: PUSH
68055: LD_INT 0
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 30
68064: PUSH
68065: LD_INT 1
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: PUSH
68072: EMPTY
68073: LIST
68074: LIST
68075: LIST
68076: PPUSH
68077: NOP4
68081: ST_TO_ADDR
// if not fac then
68082: NOP4
68086: NOT
68087: IFFALSE 68091
// continue ;
68089: GO 67939
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68091: NOP4
68095: PUSH
68096: NOP4
68100: PUSH
68101: NOP4
68105: ARRAY
68106: PPUSH
68107: LD_INT 22
68109: PUSH
68110: NOP4
68114: PUSH
68115: EMPTY
68116: LIST
68117: LIST
68118: PUSH
68119: LD_INT 21
68121: PUSH
68122: LD_INT 2
68124: PUSH
68125: EMPTY
68126: LIST
68127: LIST
68128: PUSH
68129: LD_INT 3
68131: PUSH
68132: LD_INT 24
68134: PUSH
68135: LD_INT 1000
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: LIST
68150: PPUSH
68151: NOP4
68155: ST_TO_ADDR
// for j in fac do
68156: NOP4
68160: PUSH
68161: NOP4
68165: PUSH
68166: FOR_IN
68167: IFFALSE 68248
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68169: NOP4
68173: PUSH
68174: NOP4
68178: PUSH
68179: LD_INT 22
68181: PUSH
68182: NOP4
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 91
68193: PUSH
68194: NOP4
68198: PUSH
68199: LD_INT 15
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 21
68209: PUSH
68210: LD_INT 2
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: PUSH
68217: LD_INT 3
68219: PUSH
68220: LD_INT 24
68222: PUSH
68223: LD_INT 1000
68225: PUSH
68226: EMPTY
68227: LIST
68228: LIST
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: LIST
68238: LIST
68239: PPUSH
68240: NOP4
68244: UNION
68245: ST_TO_ADDR
68246: GO 68166
68248: POP
68249: POP
// if not vehs then
68250: NOP4
68254: NOT
68255: IFFALSE 68281
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68257: NOP4
68261: PUSH
68262: NOP4
68266: PPUSH
68267: NOP4
68271: PPUSH
68272: EMPTY
68273: PPUSH
68274: NOP4
68278: ST_TO_ADDR
// continue ;
68279: GO 67939
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68281: NOP4
68285: PUSH
68286: NOP4
68290: PUSH
68291: NOP4
68295: ARRAY
68296: PPUSH
68297: LD_INT 30
68299: PUSH
68300: LD_INT 3
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PPUSH
68307: NOP4
68311: ST_TO_ADDR
// if tmp then
68312: NOP4
68316: IFFALSE 68419
// begin for j in tmp do
68318: NOP4
68322: PUSH
68323: NOP4
68327: PUSH
68328: FOR_IN
68329: IFFALSE 68417
// for k in UnitsInside ( j ) do
68331: NOP4
68335: PUSH
68336: NOP4
68340: PPUSH
68341: NOP4
68345: PUSH
68346: FOR_IN
68347: IFFALSE 68413
// if k then
68349: NOP4
68353: IFFALSE 68411
// if not k in mc_repair_vehicle [ i ] then
68355: NOP4
68359: PUSH
68360: NOP4
68364: PUSH
68365: NOP4
68369: ARRAY
68370: IN
68371: NOT
68372: IFFALSE 68411
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68374: NOP4
68378: PUSH
68379: NOP4
68383: PPUSH
68384: NOP4
68388: PPUSH
68389: NOP4
68393: PUSH
68394: NOP4
68398: ARRAY
68399: PUSH
68400: NOP4
68404: UNION
68405: PPUSH
68406: NOP4
68410: ST_TO_ADDR
68411: GO 68346
68413: POP
68414: POP
68415: GO 68328
68417: POP
68418: POP
// end ; if not mc_repair_vehicle [ i ] then
68419: NOP4
68423: PUSH
68424: NOP4
68428: ARRAY
68429: NOT
68430: IFFALSE 68434
// continue ;
68432: GO 67939
// for j in mc_repair_vehicle [ i ] do
68434: NOP4
68438: PUSH
68439: NOP4
68443: PUSH
68444: NOP4
68448: ARRAY
68449: PUSH
68450: FOR_IN
68451: IFFALSE 68628
// begin if GetClass ( j ) <> 3 then
68453: NOP4
68457: PPUSH
68458: NOP4
68462: PUSH
68463: LD_INT 3
68465: NONEQUAL
68466: IFFALSE 68507
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68468: NOP4
68472: PUSH
68473: NOP4
68477: PPUSH
68478: NOP4
68482: PPUSH
68483: NOP4
68487: PUSH
68488: NOP4
68492: ARRAY
68493: PUSH
68494: NOP4
68498: DIFF
68499: PPUSH
68500: NOP4
68504: ST_TO_ADDR
// continue ;
68505: GO 68450
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68507: NOP4
68511: PPUSH
68512: NOP4
68516: NOT
68517: PUSH
68518: NOP4
68522: PUSH
68523: NOP4
68527: PUSH
68528: NOP4
68532: ARRAY
68533: PUSH
68534: LD_INT 1
68536: ARRAY
68537: IN
68538: NOT
68539: AND
68540: PUSH
68541: NOP4
68545: PUSH
68546: NOP4
68550: PUSH
68551: NOP4
68555: ARRAY
68556: PUSH
68557: LD_INT 2
68559: ARRAY
68560: IN
68561: NOT
68562: AND
68563: IFFALSE 68626
// begin if IsInUnit ( j ) then
68565: NOP4
68569: PPUSH
68570: NOP4
68574: IFFALSE 68587
// ComExitBuilding ( j ) else
68576: NOP4
68580: PPUSH
68581: NOP4
68585: GO 68626
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
68587: NOP4
68591: PPUSH
68592: NOP4
68596: PUSH
68597: LD_INT 1
68599: ARRAY
68600: PPUSH
68601: NOP4
68605: NOT
68606: IFFALSE 68626
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
68608: NOP4
68612: PPUSH
68613: NOP4
68617: PUSH
68618: LD_INT 1
68620: ARRAY
68621: PPUSH
68622: NOP4
// end ; end ;
68626: GO 68450
68628: POP
68629: POP
// end ;
68630: GO 67939
68632: POP
68633: POP
// end ;
68634: LD_VAR 0 1
68638: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68639: LD_INT 0
68641: PPUSH
68642: PPUSH
68643: PPUSH
68644: PPUSH
68645: PPUSH
68646: PPUSH
68647: PPUSH
68648: PPUSH
68649: PPUSH
68650: PPUSH
68651: PPUSH
// if not mc_bases then
68652: NOP4
68656: NOT
68657: IFFALSE 68661
// exit ;
68659: GO 69463
// for i = 1 to mc_bases do
68661: NOP4
68665: PUSH
68666: DOUBLE
68667: LD_INT 1
68669: DEC
68670: ST_TO_ADDR
68671: NOP4
68675: PUSH
68676: FOR_TO
68677: IFFALSE 69461
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68679: NOP4
68683: PUSH
68684: NOP4
68688: ARRAY
68689: NOT
68690: PUSH
68691: NOP4
68695: PUSH
68696: NOP4
68700: ARRAY
68701: PUSH
68702: LD_INT 1
68704: ARRAY
68705: OR
68706: PUSH
68707: NOP4
68711: PUSH
68712: NOP4
68716: ARRAY
68717: PUSH
68718: LD_INT 2
68720: ARRAY
68721: OR
68722: PUSH
68723: NOP4
68727: PUSH
68728: NOP4
68732: ARRAY
68733: PPUSH
68734: LD_INT 1
68736: PPUSH
68737: NOP4
68741: NOT
68742: OR
68743: PUSH
68744: NOP4
68748: PUSH
68749: NOP4
68753: ARRAY
68754: OR
68755: IFFALSE 68759
// continue ;
68757: GO 68676
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68759: NOP4
68763: PUSH
68764: NOP4
68768: PUSH
68769: NOP4
68773: ARRAY
68774: PPUSH
68775: LD_INT 25
68777: PUSH
68778: LD_INT 4
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 50
68787: PUSH
68788: EMPTY
68789: LIST
68790: PUSH
68791: LD_INT 3
68793: PUSH
68794: LD_INT 60
68796: PUSH
68797: EMPTY
68798: LIST
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: EMPTY
68805: LIST
68806: LIST
68807: LIST
68808: PPUSH
68809: NOP4
68813: PUSH
68814: NOP4
68818: PUSH
68819: NOP4
68823: ARRAY
68824: DIFF
68825: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68826: NOP4
68830: PUSH
68831: NOP4
68835: PUSH
68836: NOP4
68840: ARRAY
68841: PPUSH
68842: LD_INT 2
68844: PUSH
68845: LD_INT 30
68847: PUSH
68848: LD_INT 0
68850: PUSH
68851: EMPTY
68852: LIST
68853: LIST
68854: PUSH
68855: LD_INT 30
68857: PUSH
68858: LD_INT 1
68860: PUSH
68861: EMPTY
68862: LIST
68863: LIST
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: LIST
68869: PPUSH
68870: NOP4
68874: ST_TO_ADDR
// if not tmp or not dep then
68875: NOP4
68879: NOT
68880: PUSH
68881: NOP4
68885: NOT
68886: OR
68887: IFFALSE 68891
// continue ;
68889: GO 68676
// side := GetSide ( tmp [ 1 ] ) ;
68891: NOP4
68895: PUSH
68896: NOP4
68900: PUSH
68901: LD_INT 1
68903: ARRAY
68904: PPUSH
68905: NOP4
68909: ST_TO_ADDR
// dep := dep [ 1 ] ;
68910: NOP4
68914: PUSH
68915: NOP4
68919: PUSH
68920: LD_INT 1
68922: ARRAY
68923: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68924: NOP4
68928: PUSH
68929: NOP4
68933: PUSH
68934: NOP4
68938: ARRAY
68939: PPUSH
68940: LD_INT 22
68942: PUSH
68943: LD_INT 0
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: PUSH
68950: LD_INT 25
68952: PUSH
68953: LD_INT 12
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PPUSH
68964: NOP4
68968: PUSH
68969: LD_INT 22
68971: PUSH
68972: LD_INT 0
68974: PUSH
68975: EMPTY
68976: LIST
68977: LIST
68978: PUSH
68979: LD_INT 25
68981: PUSH
68982: LD_INT 12
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: LD_INT 91
68991: PUSH
68992: NOP4
68996: PUSH
68997: LD_INT 20
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: LIST
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: LIST
69009: PPUSH
69010: NOP4
69014: UNION
69015: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69016: NOP4
69020: PUSH
69021: NOP4
69025: PUSH
69026: NOP4
69030: ARRAY
69031: PPUSH
69032: LD_INT 81
69034: PUSH
69035: NOP4
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PPUSH
69044: NOP4
69048: ST_TO_ADDR
// if not apes or danger_at_area then
69049: NOP4
69053: NOT
69054: PUSH
69055: NOP4
69059: OR
69060: IFFALSE 69110
// begin if mc_taming [ i ] then
69062: NOP4
69066: PUSH
69067: NOP4
69071: ARRAY
69072: IFFALSE 69108
// begin MC_Reset ( i , 121 ) ;
69074: NOP4
69078: PPUSH
69079: LD_INT 121
69081: PPUSH
69082: NOP4
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69086: NOP4
69090: PUSH
69091: NOP4
69095: PPUSH
69096: NOP4
69100: PPUSH
69101: EMPTY
69102: PPUSH
69103: NOP4
69107: ST_TO_ADDR
// end ; continue ;
69108: GO 68676
// end ; for j in tmp do
69110: NOP4
69114: PUSH
69115: NOP4
69119: PUSH
69120: FOR_IN
69121: IFFALSE 69457
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69123: NOP4
69127: PUSH
69128: NOP4
69132: PUSH
69133: NOP4
69137: ARRAY
69138: IN
69139: NOT
69140: PUSH
69141: NOP4
69145: PUSH
69146: NOP4
69150: ARRAY
69151: PUSH
69152: LD_INT 3
69154: LESS
69155: AND
69156: IFFALSE 69214
// begin SetTag ( j , 121 ) ;
69158: NOP4
69162: PPUSH
69163: LD_INT 121
69165: PPUSH
69166: NOP4
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69170: NOP4
69174: PUSH
69175: NOP4
69179: PPUSH
69180: NOP4
69184: PUSH
69185: NOP4
69189: PUSH
69190: NOP4
69194: ARRAY
69195: PUSH
69196: LD_INT 1
69198: PLUS
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PPUSH
69204: NOP4
69208: PPUSH
69209: NOP4
69213: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69214: NOP4
69218: PUSH
69219: NOP4
69223: PUSH
69224: NOP4
69228: ARRAY
69229: IN
69230: IFFALSE 69455
// begin if GetClass ( j ) <> 4 then
69232: NOP4
69236: PPUSH
69237: NOP4
69241: PUSH
69242: LD_INT 4
69244: NONEQUAL
69245: IFFALSE 69298
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69247: NOP4
69251: PUSH
69252: NOP4
69256: PPUSH
69257: NOP4
69261: PPUSH
69262: NOP4
69266: PUSH
69267: NOP4
69271: ARRAY
69272: PUSH
69273: NOP4
69277: DIFF
69278: PPUSH
69279: NOP4
69283: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69284: NOP4
69288: PPUSH
69289: LD_INT 0
69291: PPUSH
69292: NOP4
// continue ;
69296: GO 69120
// end ; if IsInUnit ( j ) then
69298: NOP4
69302: PPUSH
69303: NOP4
69307: IFFALSE 69318
// ComExitBuilding ( j ) ;
69309: NOP4
69313: PPUSH
69314: NOP4
// ape := NearestUnitToUnit ( apes , j ) ;
69318: NOP4
69322: PUSH
69323: NOP4
69327: PPUSH
69328: NOP4
69332: PPUSH
69333: NOP4
69337: ST_TO_ADDR
// if not ape then
69338: NOP4
69342: NOT
69343: IFFALSE 69347
// break ;
69345: GO 69457
// x := GetX ( ape ) ;
69347: NOP4
69351: PUSH
69352: NOP4
69356: PPUSH
69357: NOP4
69361: ST_TO_ADDR
// y := GetY ( ape ) ;
69362: NOP4
69366: PUSH
69367: NOP4
69371: PPUSH
69372: NOP4
69376: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69377: NOP4
69381: PPUSH
69382: NOP4
69386: PPUSH
69387: NOP4
69391: NOT
69392: PUSH
69393: NOP4
69397: PPUSH
69398: NOP4
69402: PPUSH
69403: NOP4
69407: PPUSH
69408: LD_INT 20
69410: PPUSH
69411: NOP4
69415: PUSH
69416: LD_INT 4
69418: ARRAY
69419: OR
69420: IFFALSE 69424
// break ;
69422: GO 69457
// if not HasTask ( j ) then
69424: NOP4
69428: PPUSH
69429: NOP4
69433: NOT
69434: IFFALSE 69455
// ComTameXY ( j , x , y ) ;
69436: NOP4
69440: PPUSH
69441: NOP4
69445: PPUSH
69446: NOP4
69450: PPUSH
69451: NOP4
// end ; end ;
69455: GO 69120
69457: POP
69458: POP
// end ;
69459: GO 68676
69461: POP
69462: POP
// end ;
69463: LD_VAR 0 1
69467: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69468: LD_INT 0
69470: PPUSH
69471: PPUSH
69472: PPUSH
69473: PPUSH
69474: PPUSH
69475: PPUSH
69476: PPUSH
69477: PPUSH
// if not mc_bases then
69478: NOP4
69482: NOT
69483: IFFALSE 69487
// exit ;
69485: GO 70113
// for i = 1 to mc_bases do
69487: NOP4
69491: PUSH
69492: DOUBLE
69493: LD_INT 1
69495: DEC
69496: ST_TO_ADDR
69497: NOP4
69501: PUSH
69502: FOR_TO
69503: IFFALSE 70111
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69505: NOP4
69509: PUSH
69510: NOP4
69514: ARRAY
69515: NOT
69516: PUSH
69517: NOP4
69521: PUSH
69522: NOP4
69526: ARRAY
69527: PPUSH
69528: LD_INT 25
69530: PUSH
69531: LD_INT 12
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PPUSH
69538: NOP4
69542: NOT
69543: OR
69544: IFFALSE 69548
// continue ;
69546: GO 69502
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69548: NOP4
69552: PUSH
69553: NOP4
69557: PUSH
69558: NOP4
69562: ARRAY
69563: PUSH
69564: LD_INT 1
69566: ARRAY
69567: PPUSH
69568: NOP4
69572: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69573: NOP4
69577: PPUSH
69578: LD_INT 2
69580: PPUSH
69581: NOP4
69585: IFFALSE 69838
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69587: NOP4
69591: PUSH
69592: NOP4
69596: PUSH
69597: NOP4
69601: ARRAY
69602: PPUSH
69603: LD_INT 25
69605: PUSH
69606: LD_INT 16
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PPUSH
69613: NOP4
69617: ST_TO_ADDR
// if tmp < 6 then
69618: NOP4
69622: PUSH
69623: LD_INT 6
69625: LESS
69626: IFFALSE 69838
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69628: NOP4
69632: PUSH
69633: NOP4
69637: PUSH
69638: NOP4
69642: ARRAY
69643: PPUSH
69644: LD_INT 2
69646: PUSH
69647: LD_INT 30
69649: PUSH
69650: LD_INT 0
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 30
69659: PUSH
69660: LD_INT 1
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: LIST
69671: PPUSH
69672: NOP4
69676: ST_TO_ADDR
// if depot then
69677: NOP4
69681: IFFALSE 69838
// begin selected := 0 ;
69683: NOP4
69687: PUSH
69688: LD_INT 0
69690: ST_TO_ADDR
// for j in depot do
69691: NOP4
69695: PUSH
69696: NOP4
69700: PUSH
69701: FOR_IN
69702: IFFALSE 69733
// begin if UnitsInside ( j ) < 6 then
69704: NOP4
69708: PPUSH
69709: NOP4
69713: PUSH
69714: LD_INT 6
69716: LESS
69717: IFFALSE 69731
// begin selected := j ;
69719: NOP4
69723: PUSH
69724: NOP4
69728: ST_TO_ADDR
// break ;
69729: GO 69733
// end ; end ;
69731: GO 69701
69733: POP
69734: POP
// if selected then
69735: NOP4
69739: IFFALSE 69838
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69741: NOP4
69745: PUSH
69746: NOP4
69750: PUSH
69751: NOP4
69755: ARRAY
69756: PPUSH
69757: LD_INT 25
69759: PUSH
69760: LD_INT 12
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PPUSH
69767: NOP4
69771: PUSH
69772: FOR_IN
69773: IFFALSE 69836
// if not HasTask ( j ) then
69775: NOP4
69779: PPUSH
69780: NOP4
69784: NOT
69785: IFFALSE 69834
// begin if not IsInUnit ( j ) then
69787: NOP4
69791: PPUSH
69792: NOP4
69796: NOT
69797: IFFALSE 69813
// ComEnterUnit ( j , selected ) ;
69799: NOP4
69803: PPUSH
69804: NOP4
69808: PPUSH
69809: NOP4
// AddComChangeProfession ( j , 16 ) ;
69813: NOP4
69817: PPUSH
69818: LD_INT 16
69820: PPUSH
69821: NOP4
// AddComExitBuilding ( j ) ;
69825: NOP4
69829: PPUSH
69830: NOP4
// end ;
69834: GO 69772
69836: POP
69837: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69838: NOP4
69842: PPUSH
69843: LD_INT 11
69845: PPUSH
69846: NOP4
69850: IFFALSE 70109
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69852: NOP4
69856: PUSH
69857: NOP4
69861: PUSH
69862: NOP4
69866: ARRAY
69867: PPUSH
69868: LD_INT 25
69870: PUSH
69871: LD_INT 16
69873: PUSH
69874: EMPTY
69875: LIST
69876: LIST
69877: PPUSH
69878: NOP4
69882: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69883: NOP4
69887: PUSH
69888: LD_INT 6
69890: GREATEREQUAL
69891: PUSH
69892: NOP4
69896: PPUSH
69897: LD_INT 2
69899: PPUSH
69900: NOP4
69904: NOT
69905: OR
69906: IFFALSE 70109
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69908: NOP4
69912: PUSH
69913: NOP4
69917: PUSH
69918: NOP4
69922: ARRAY
69923: PPUSH
69924: LD_INT 2
69926: PUSH
69927: LD_INT 30
69929: PUSH
69930: LD_INT 4
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 30
69939: PUSH
69940: LD_INT 5
69942: PUSH
69943: EMPTY
69944: LIST
69945: LIST
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: LIST
69951: PPUSH
69952: NOP4
69956: ST_TO_ADDR
// if barracks then
69957: NOP4
69961: IFFALSE 70109
// begin selected := 0 ;
69963: NOP4
69967: PUSH
69968: LD_INT 0
69970: ST_TO_ADDR
// for j in barracks do
69971: NOP4
69975: PUSH
69976: NOP4
69980: PUSH
69981: FOR_IN
69982: IFFALSE 70013
// begin if UnitsInside ( j ) < 6 then
69984: NOP4
69988: PPUSH
69989: NOP4
69993: PUSH
69994: LD_INT 6
69996: LESS
69997: IFFALSE 70011
// begin selected := j ;
69999: NOP4
70003: PUSH
70004: NOP4
70008: ST_TO_ADDR
// break ;
70009: GO 70013
// end ; end ;
70011: GO 69981
70013: POP
70014: POP
// if selected then
70015: NOP4
70019: IFFALSE 70109
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70021: NOP4
70025: PUSH
70026: NOP4
70030: PUSH
70031: NOP4
70035: ARRAY
70036: PPUSH
70037: LD_INT 25
70039: PUSH
70040: LD_INT 12
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PPUSH
70047: NOP4
70051: PUSH
70052: FOR_IN
70053: IFFALSE 70107
// if not IsInUnit ( j ) and not HasTask ( j ) then
70055: NOP4
70059: PPUSH
70060: NOP4
70064: NOT
70065: PUSH
70066: NOP4
70070: PPUSH
70071: NOP4
70075: NOT
70076: AND
70077: IFFALSE 70105
// begin ComEnterUnit ( j , selected ) ;
70079: NOP4
70083: PPUSH
70084: NOP4
70088: PPUSH
70089: NOP4
// AddComChangeProfession ( j , 15 ) ;
70093: NOP4
70097: PPUSH
70098: LD_INT 15
70100: PPUSH
70101: NOP4
// end ;
70105: GO 70052
70107: POP
70108: POP
// end ; end ; end ; end ; end ;
70109: GO 69502
70111: POP
70112: POP
// end ;
70113: LD_VAR 0 1
70117: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70118: LD_INT 0
70120: PPUSH
70121: PPUSH
70122: PPUSH
70123: PPUSH
// if not mc_bases then
70124: NOP4
70128: NOT
70129: IFFALSE 70133
// exit ;
70131: GO 70311
// for i = 1 to mc_bases do
70133: NOP4
70137: PUSH
70138: DOUBLE
70139: LD_INT 1
70141: DEC
70142: ST_TO_ADDR
70143: NOP4
70147: PUSH
70148: FOR_TO
70149: IFFALSE 70309
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70151: NOP4
70155: PUSH
70156: NOP4
70160: PUSH
70161: NOP4
70165: ARRAY
70166: PPUSH
70167: LD_INT 25
70169: PUSH
70170: LD_INT 9
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PPUSH
70177: NOP4
70181: ST_TO_ADDR
// if not tmp then
70182: NOP4
70186: NOT
70187: IFFALSE 70191
// continue ;
70189: GO 70148
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70191: NOP4
70195: PUSH
70196: NOP4
70200: ARRAY
70201: PPUSH
70202: LD_INT 29
70204: PPUSH
70205: NOP4
70209: NOT
70210: PUSH
70211: NOP4
70215: PUSH
70216: NOP4
70220: ARRAY
70221: PPUSH
70222: LD_INT 28
70224: PPUSH
70225: NOP4
70229: NOT
70230: AND
70231: IFFALSE 70235
// continue ;
70233: GO 70148
// for j in tmp do
70235: NOP4
70239: PUSH
70240: NOP4
70244: PUSH
70245: FOR_IN
70246: IFFALSE 70305
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70248: NOP4
70252: PUSH
70253: NOP4
70257: PUSH
70258: NOP4
70262: ARRAY
70263: PUSH
70264: LD_INT 1
70266: ARRAY
70267: IN
70268: NOT
70269: PUSH
70270: NOP4
70274: PUSH
70275: NOP4
70279: PUSH
70280: NOP4
70284: ARRAY
70285: PUSH
70286: LD_INT 2
70288: ARRAY
70289: IN
70290: NOT
70291: AND
70292: IFFALSE 70303
// ComSpaceTimeShoot ( j ) ;
70294: NOP4
70298: PPUSH
70299: NOP4
70303: GO 70245
70305: POP
70306: POP
// end ;
70307: GO 70148
70309: POP
70310: POP
// end ;
70311: LD_VAR 0 1
70315: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70316: LD_INT 0
70318: PPUSH
70319: PPUSH
70320: PPUSH
70321: PPUSH
70322: PPUSH
70323: PPUSH
70324: PPUSH
70325: PPUSH
70326: PPUSH
// if not mc_bases then
70327: NOP4
70331: NOT
70332: IFFALSE 70336
// exit ;
70334: GO 70958
// for i = 1 to mc_bases do
70336: NOP4
70340: PUSH
70341: DOUBLE
70342: LD_INT 1
70344: DEC
70345: ST_TO_ADDR
70346: NOP4
70350: PUSH
70351: FOR_TO
70352: IFFALSE 70956
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70354: NOP4
70358: PUSH
70359: NOP4
70363: ARRAY
70364: NOT
70365: PUSH
70366: LD_INT 38
70368: PPUSH
70369: NOP4
70373: PUSH
70374: NOP4
70378: ARRAY
70379: PPUSH
70380: NOP4
70384: PUSH
70385: LD_INT 2
70387: NONEQUAL
70388: OR
70389: IFFALSE 70393
// continue ;
70391: GO 70351
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
70393: NOP4
70397: PUSH
70398: NOP4
70402: PUSH
70403: NOP4
70407: ARRAY
70408: PPUSH
70409: LD_INT 30
70411: PUSH
70412: LD_INT 34
70414: PUSH
70415: EMPTY
70416: LIST
70417: LIST
70418: PPUSH
70419: NOP4
70423: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
70424: NOP4
70428: PUSH
70429: NOP4
70433: PUSH
70434: NOP4
70438: ARRAY
70439: PPUSH
70440: LD_INT 25
70442: PUSH
70443: LD_INT 4
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PPUSH
70450: NOP4
70454: PPUSH
70455: LD_INT 0
70457: PPUSH
70458: NOP4
70462: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70463: NOP4
70467: NOT
70468: PUSH
70469: NOP4
70473: NOT
70474: OR
70475: PUSH
70476: NOP4
70480: PUSH
70481: NOP4
70485: ARRAY
70486: PPUSH
70487: LD_INT 124
70489: PPUSH
70490: NOP4
70494: OR
70495: IFFALSE 70499
// continue ;
70497: GO 70351
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70499: NOP4
70503: PUSH
70504: NOP4
70508: ARRAY
70509: PUSH
70510: NOP4
70514: PUSH
70515: NOP4
70519: ARRAY
70520: LESS
70521: PUSH
70522: NOP4
70526: PUSH
70527: NOP4
70531: ARRAY
70532: PUSH
70533: NOP4
70537: LESS
70538: AND
70539: IFFALSE 70954
// begin tmp := sci [ 1 ] ;
70541: NOP4
70545: PUSH
70546: NOP4
70550: PUSH
70551: LD_INT 1
70553: ARRAY
70554: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70555: NOP4
70559: PPUSH
70560: LD_INT 124
70562: PPUSH
70563: NOP4
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70567: NOP4
70571: PUSH
70572: DOUBLE
70573: NOP4
70577: PUSH
70578: NOP4
70582: ARRAY
70583: INC
70584: ST_TO_ADDR
70585: NOP4
70589: PUSH
70590: NOP4
70594: ARRAY
70595: PUSH
70596: FOR_DOWNTO
70597: IFFALSE 70940
// begin if IsInUnit ( tmp ) then
70599: NOP4
70603: PPUSH
70604: NOP4
70608: IFFALSE 70619
// ComExitBuilding ( tmp ) ;
70610: NOP4
70614: PPUSH
70615: NOP4
// repeat wait ( 0 0$1 ) ;
70619: LD_INT 35
70621: PPUSH
70622: NOP4
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70626: NOP4
70630: PPUSH
70631: NOP4
70635: NOT
70636: PUSH
70637: NOP4
70641: PPUSH
70642: NOP4
70646: NOT
70647: AND
70648: IFFALSE 70619
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70650: NOP4
70654: PUSH
70655: NOP4
70659: PPUSH
70660: NOP4
70664: PUSH
70665: NOP4
70669: PPUSH
70670: NOP4
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70679: LD_INT 35
70681: PPUSH
70682: NOP4
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70686: NOP4
70690: PUSH
70691: NOP4
70695: PUSH
70696: NOP4
70700: ARRAY
70701: PUSH
70702: NOP4
70706: ARRAY
70707: PUSH
70708: LD_INT 1
70710: ARRAY
70711: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70712: NOP4
70716: PUSH
70717: NOP4
70721: PUSH
70722: NOP4
70726: ARRAY
70727: PUSH
70728: NOP4
70732: ARRAY
70733: PUSH
70734: LD_INT 2
70736: ARRAY
70737: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70738: NOP4
70742: PPUSH
70743: LD_INT 10
70745: PPUSH
70746: NOP4
70750: PUSH
70751: LD_INT 4
70753: ARRAY
70754: IFFALSE 70792
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70756: NOP4
70760: PPUSH
70761: NOP4
70765: PUSH
70766: LD_INT 1
70768: ARRAY
70769: PPUSH
70770: NOP4
70774: PUSH
70775: LD_INT 2
70777: ARRAY
70778: PPUSH
70779: NOP4
// wait ( 0 0$10 ) ;
70783: LD_INT 350
70785: PPUSH
70786: NOP4
// end else
70790: GO 70818
// begin ComMoveXY ( tmp , x , y ) ;
70792: NOP4
70796: PPUSH
70797: NOP4
70801: PPUSH
70802: NOP4
70806: PPUSH
70807: NOP4
// wait ( 0 0$3 ) ;
70811: LD_INT 105
70813: PPUSH
70814: NOP4
// end ; until IsAt ( tmp , x , y ) ;
70818: NOP4
70822: PPUSH
70823: NOP4
70827: PPUSH
70828: NOP4
70832: PPUSH
70833: NOP4
70837: IFFALSE 70679
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70839: NOP4
70843: PPUSH
70844: NOP4
70848: PPUSH
70849: NOP4
70853: PPUSH
70854: NOP4
70858: PUSH
70859: NOP4
70863: ARRAY
70864: PPUSH
70865: NOP4
// repeat wait ( 0 0$1 ) ;
70869: LD_INT 35
70871: PPUSH
70872: NOP4
// until not HasTask ( tmp ) ;
70876: NOP4
70880: PPUSH
70881: NOP4
70885: NOT
70886: IFFALSE 70869
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70888: NOP4
70892: PUSH
70893: NOP4
70897: PPUSH
70898: NOP4
70902: PUSH
70903: NOP4
70907: PUSH
70908: NOP4
70912: ARRAY
70913: PUSH
70914: LD_INT 1
70916: PLUS
70917: PUSH
70918: EMPTY
70919: LIST
70920: LIST
70921: PPUSH
70922: NOP4
70926: PUSH
70927: NOP4
70931: ARRAY
70932: PPUSH
70933: NOP4
70937: ST_TO_ADDR
// end ;
70938: GO 70596
70940: POP
70941: POP
// MC_Reset ( i , 124 ) ;
70942: NOP4
70946: PPUSH
70947: LD_INT 124
70949: PPUSH
70950: NOP4
// end ; end ;
70954: GO 70351
70956: POP
70957: POP
// end ;
70958: LD_VAR 0 1
70962: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
70963: LD_INT 0
70965: PPUSH
70966: PPUSH
70967: PPUSH
// if not mc_bases then
70968: NOP4
70972: NOT
70973: IFFALSE 70977
// exit ;
70975: GO 71583
// for i = 1 to mc_bases do
70977: NOP4
70981: PUSH
70982: DOUBLE
70983: LD_INT 1
70985: DEC
70986: ST_TO_ADDR
70987: NOP4
70991: PUSH
70992: FOR_TO
70993: IFFALSE 71581
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70995: NOP4
70999: PUSH
71000: NOP4
71004: PUSH
71005: NOP4
71009: ARRAY
71010: PPUSH
71011: LD_INT 25
71013: PUSH
71014: LD_INT 4
71016: PUSH
71017: EMPTY
71018: LIST
71019: LIST
71020: PPUSH
71021: NOP4
71025: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71026: NOP4
71030: NOT
71031: PUSH
71032: NOP4
71036: PUSH
71037: NOP4
71041: ARRAY
71042: NOT
71043: OR
71044: PUSH
71045: NOP4
71049: PUSH
71050: NOP4
71054: ARRAY
71055: PPUSH
71056: LD_INT 2
71058: PUSH
71059: LD_INT 30
71061: PUSH
71062: LD_INT 0
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: LD_INT 30
71071: PUSH
71072: LD_INT 1
71074: PUSH
71075: EMPTY
71076: LIST
71077: LIST
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: LIST
71083: PPUSH
71084: NOP4
71088: NOT
71089: OR
71090: IFFALSE 71140
// begin if mc_deposits_finder [ i ] then
71092: NOP4
71096: PUSH
71097: NOP4
71101: ARRAY
71102: IFFALSE 71138
// begin MC_Reset ( i , 125 ) ;
71104: NOP4
71108: PPUSH
71109: LD_INT 125
71111: PPUSH
71112: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71116: NOP4
71120: PUSH
71121: NOP4
71125: PPUSH
71126: NOP4
71130: PPUSH
71131: EMPTY
71132: PPUSH
71133: NOP4
71137: ST_TO_ADDR
// end ; continue ;
71138: GO 70992
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71140: NOP4
71144: PUSH
71145: NOP4
71149: ARRAY
71150: PUSH
71151: LD_INT 1
71153: ARRAY
71154: PUSH
71155: LD_INT 3
71157: ARRAY
71158: PUSH
71159: LD_INT 1
71161: EQUAL
71162: PUSH
71163: LD_INT 20
71165: PPUSH
71166: NOP4
71170: PUSH
71171: NOP4
71175: ARRAY
71176: PPUSH
71177: NOP4
71181: PUSH
71182: LD_INT 2
71184: NONEQUAL
71185: AND
71186: IFFALSE 71236
// begin if mc_deposits_finder [ i ] then
71188: NOP4
71192: PUSH
71193: NOP4
71197: ARRAY
71198: IFFALSE 71234
// begin MC_Reset ( i , 125 ) ;
71200: NOP4
71204: PPUSH
71205: LD_INT 125
71207: PPUSH
71208: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71212: NOP4
71216: PUSH
71217: NOP4
71221: PPUSH
71222: NOP4
71226: PPUSH
71227: EMPTY
71228: PPUSH
71229: NOP4
71233: ST_TO_ADDR
// end ; continue ;
71234: GO 70992
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71236: NOP4
71240: PUSH
71241: NOP4
71245: ARRAY
71246: PUSH
71247: LD_INT 1
71249: ARRAY
71250: PUSH
71251: LD_INT 1
71253: ARRAY
71254: PPUSH
71255: NOP4
71259: PUSH
71260: NOP4
71264: ARRAY
71265: PUSH
71266: LD_INT 1
71268: ARRAY
71269: PUSH
71270: LD_INT 2
71272: ARRAY
71273: PPUSH
71274: NOP4
71278: PUSH
71279: NOP4
71283: ARRAY
71284: PPUSH
71285: NOP4
71289: IFFALSE 71332
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71291: NOP4
71295: PUSH
71296: NOP4
71300: PPUSH
71301: NOP4
71305: PPUSH
71306: NOP4
71310: PUSH
71311: NOP4
71315: ARRAY
71316: PPUSH
71317: LD_INT 1
71319: PPUSH
71320: NOP4
71324: PPUSH
71325: NOP4
71329: ST_TO_ADDR
71330: GO 71579
// begin if not mc_deposits_finder [ i ] then
71332: NOP4
71336: PUSH
71337: NOP4
71341: ARRAY
71342: NOT
71343: IFFALSE 71395
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71345: NOP4
71349: PUSH
71350: NOP4
71354: PPUSH
71355: NOP4
71359: PPUSH
71360: NOP4
71364: PUSH
71365: LD_INT 1
71367: ARRAY
71368: PUSH
71369: EMPTY
71370: LIST
71371: PPUSH
71372: NOP4
71376: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71377: NOP4
71381: PUSH
71382: LD_INT 1
71384: ARRAY
71385: PPUSH
71386: LD_INT 125
71388: PPUSH
71389: NOP4
// end else
71393: GO 71579
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
71395: NOP4
71399: PUSH
71400: NOP4
71404: ARRAY
71405: PUSH
71406: LD_INT 1
71408: ARRAY
71409: PPUSH
71410: NOP4
71414: IFFALSE 71437
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
71416: NOP4
71420: PUSH
71421: NOP4
71425: ARRAY
71426: PUSH
71427: LD_INT 1
71429: ARRAY
71430: PPUSH
71431: NOP4
71435: GO 71579
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71437: NOP4
71441: PUSH
71442: NOP4
71446: ARRAY
71447: PUSH
71448: LD_INT 1
71450: ARRAY
71451: PPUSH
71452: NOP4
71456: NOT
71457: PUSH
71458: NOP4
71462: PUSH
71463: NOP4
71467: ARRAY
71468: PUSH
71469: LD_INT 1
71471: ARRAY
71472: PPUSH
71473: NOP4
71477: PUSH
71478: NOP4
71482: ARRAY
71483: PUSH
71484: LD_INT 1
71486: ARRAY
71487: PUSH
71488: LD_INT 1
71490: ARRAY
71491: PPUSH
71492: NOP4
71496: PUSH
71497: NOP4
71501: ARRAY
71502: PUSH
71503: LD_INT 1
71505: ARRAY
71506: PUSH
71507: LD_INT 2
71509: ARRAY
71510: PPUSH
71511: NOP4
71515: PUSH
71516: LD_INT 6
71518: GREATER
71519: AND
71520: IFFALSE 71579
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71522: NOP4
71526: PUSH
71527: NOP4
71531: ARRAY
71532: PUSH
71533: LD_INT 1
71535: ARRAY
71536: PPUSH
71537: NOP4
71541: PUSH
71542: NOP4
71546: ARRAY
71547: PUSH
71548: LD_INT 1
71550: ARRAY
71551: PUSH
71552: LD_INT 1
71554: ARRAY
71555: PPUSH
71556: NOP4
71560: PUSH
71561: NOP4
71565: ARRAY
71566: PUSH
71567: LD_INT 1
71569: ARRAY
71570: PUSH
71571: LD_INT 2
71573: ARRAY
71574: PPUSH
71575: NOP4
// end ; end ; end ;
71579: GO 70992
71581: POP
71582: POP
// end ;
71583: LD_VAR 0 1
71587: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71588: LD_INT 0
71590: PPUSH
71591: PPUSH
71592: PPUSH
71593: PPUSH
71594: PPUSH
71595: PPUSH
71596: PPUSH
71597: PPUSH
71598: PPUSH
71599: PPUSH
71600: PPUSH
// if not mc_bases then
71601: NOP4
71605: NOT
71606: IFFALSE 71610
// exit ;
71608: GO 72550
// for i = 1 to mc_bases do
71610: NOP4
71614: PUSH
71615: DOUBLE
71616: LD_INT 1
71618: DEC
71619: ST_TO_ADDR
71620: NOP4
71624: PUSH
71625: FOR_TO
71626: IFFALSE 72548
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71628: NOP4
71632: PUSH
71633: NOP4
71637: ARRAY
71638: NOT
71639: PUSH
71640: NOP4
71644: PUSH
71645: NOP4
71649: ARRAY
71650: OR
71651: IFFALSE 71655
// continue ;
71653: GO 71625
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71655: NOP4
71659: PUSH
71660: NOP4
71664: PUSH
71665: NOP4
71669: ARRAY
71670: PUSH
71671: LD_INT 1
71673: ARRAY
71674: PPUSH
71675: NOP4
71679: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71680: NOP4
71684: PUSH
71685: LD_INT 3
71687: EQUAL
71688: PUSH
71689: NOP4
71693: PUSH
71694: NOP4
71698: ARRAY
71699: PUSH
71700: NOP4
71704: PUSH
71705: NOP4
71709: ARRAY
71710: UNION
71711: PPUSH
71712: LD_INT 33
71714: PUSH
71715: LD_INT 2
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PPUSH
71722: NOP4
71726: NOT
71727: OR
71728: IFFALSE 71732
// continue ;
71730: GO 71625
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71732: NOP4
71736: PUSH
71737: NOP4
71741: PUSH
71742: NOP4
71746: ARRAY
71747: PPUSH
71748: LD_INT 30
71750: PUSH
71751: LD_INT 36
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PPUSH
71758: NOP4
71762: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71763: NOP4
71767: PUSH
71768: NOP4
71772: PUSH
71773: NOP4
71777: ARRAY
71778: PPUSH
71779: LD_INT 34
71781: PUSH
71782: LD_INT 31
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: PPUSH
71789: NOP4
71793: ST_TO_ADDR
// if not cts and not mcts then
71794: NOP4
71798: NOT
71799: PUSH
71800: NOP4
71804: NOT
71805: AND
71806: IFFALSE 71810
// continue ;
71808: GO 71625
// x := cts ;
71810: NOP4
71814: PUSH
71815: NOP4
71819: ST_TO_ADDR
// if not x then
71820: NOP4
71824: NOT
71825: IFFALSE 71837
// x := mcts ;
71827: NOP4
71831: PUSH
71832: NOP4
71836: ST_TO_ADDR
// if not x then
71837: NOP4
71841: NOT
71842: IFFALSE 71846
// continue ;
71844: GO 71625
// if mc_remote_driver [ i ] then
71846: NOP4
71850: PUSH
71851: NOP4
71855: ARRAY
71856: IFFALSE 72243
// for j in mc_remote_driver [ i ] do
71858: NOP4
71862: PUSH
71863: NOP4
71867: PUSH
71868: NOP4
71872: ARRAY
71873: PUSH
71874: FOR_IN
71875: IFFALSE 72241
// begin if GetClass ( j ) <> 3 then
71877: NOP4
71881: PPUSH
71882: NOP4
71886: PUSH
71887: LD_INT 3
71889: NONEQUAL
71890: IFFALSE 71943
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71892: NOP4
71896: PUSH
71897: NOP4
71901: PPUSH
71902: NOP4
71906: PPUSH
71907: NOP4
71911: PUSH
71912: NOP4
71916: ARRAY
71917: PUSH
71918: NOP4
71922: DIFF
71923: PPUSH
71924: NOP4
71928: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71929: NOP4
71933: PPUSH
71934: LD_INT 0
71936: PPUSH
71937: NOP4
// continue ;
71941: GO 71874
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
71943: NOP4
71947: PUSH
71948: NOP4
71952: ARRAY
71953: PPUSH
71954: LD_INT 34
71956: PUSH
71957: LD_INT 31
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 58
71966: PUSH
71967: EMPTY
71968: LIST
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PPUSH
71974: NOP4
71978: PUSH
71979: NOP4
71983: PPUSH
71984: NOP4
71988: NOT
71989: AND
71990: IFFALSE 72061
// begin if IsInUnit ( j ) then
71992: NOP4
71996: PPUSH
71997: NOP4
72001: IFFALSE 72012
// ComExitBuilding ( j ) ;
72003: NOP4
72007: PPUSH
72008: NOP4
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72012: NOP4
72016: PPUSH
72017: NOP4
72021: PUSH
72022: NOP4
72026: ARRAY
72027: PPUSH
72028: LD_INT 34
72030: PUSH
72031: LD_INT 31
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 58
72040: PUSH
72041: EMPTY
72042: LIST
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PPUSH
72048: NOP4
72052: PUSH
72053: LD_INT 1
72055: ARRAY
72056: PPUSH
72057: NOP4
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72061: NOP4
72065: PPUSH
72066: NOP4
72070: NOT
72071: PUSH
72072: NOP4
72076: PPUSH
72077: NOP4
72081: PPUSH
72082: NOP4
72086: PUSH
72087: LD_INT 36
72089: NONEQUAL
72090: PUSH
72091: NOP4
72095: PPUSH
72096: NOP4
72100: NOT
72101: AND
72102: OR
72103: IFFALSE 72239
// begin if IsInUnit ( j ) then
72105: NOP4
72109: PPUSH
72110: NOP4
72114: IFFALSE 72125
// ComExitBuilding ( j ) ;
72116: NOP4
72120: PPUSH
72121: NOP4
// ct := 0 ;
72125: NOP4
72129: PUSH
72130: LD_INT 0
72132: ST_TO_ADDR
// for k in x do
72133: NOP4
72137: PUSH
72138: NOP4
72142: PUSH
72143: FOR_IN
72144: IFFALSE 72217
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72146: NOP4
72150: PPUSH
72151: NOP4
72155: PUSH
72156: LD_INT 31
72158: EQUAL
72159: PUSH
72160: NOP4
72164: PPUSH
72165: NOP4
72169: NOT
72170: AND
72171: PUSH
72172: NOP4
72176: PPUSH
72177: NOP4
72181: PUSH
72182: LD_INT 36
72184: EQUAL
72185: PUSH
72186: NOP4
72190: PPUSH
72191: NOP4
72195: PUSH
72196: LD_INT 3
72198: LESS
72199: AND
72200: OR
72201: IFFALSE 72215
// begin ct := k ;
72203: NOP4
72207: PUSH
72208: NOP4
72212: ST_TO_ADDR
// break ;
72213: GO 72217
// end ;
72215: GO 72143
72217: POP
72218: POP
// if ct then
72219: NOP4
72223: IFFALSE 72239
// ComEnterUnit ( j , ct ) ;
72225: NOP4
72229: PPUSH
72230: NOP4
72234: PPUSH
72235: NOP4
// end ; end ;
72239: GO 71874
72241: POP
72242: POP
// places := 0 ;
72243: NOP4
72247: PUSH
72248: LD_INT 0
72250: ST_TO_ADDR
// for j = 1 to x do
72251: NOP4
72255: PUSH
72256: DOUBLE
72257: LD_INT 1
72259: DEC
72260: ST_TO_ADDR
72261: NOP4
72265: PUSH
72266: FOR_TO
72267: IFFALSE 72343
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72269: NOP4
72273: PUSH
72274: NOP4
72278: ARRAY
72279: PPUSH
72280: NOP4
72284: PUSH
72285: LD_INT 31
72287: EQUAL
72288: IFFALSE 72306
// places := places + 1 else
72290: NOP4
72294: PUSH
72295: NOP4
72299: PUSH
72300: LD_INT 1
72302: PLUS
72303: ST_TO_ADDR
72304: GO 72341
// if GetBType ( x [ j ] ) = b_control_tower then
72306: NOP4
72310: PUSH
72311: NOP4
72315: ARRAY
72316: PPUSH
72317: NOP4
72321: PUSH
72322: LD_INT 36
72324: EQUAL
72325: IFFALSE 72341
// places := places + 3 ;
72327: NOP4
72331: PUSH
72332: NOP4
72336: PUSH
72337: LD_INT 3
72339: PLUS
72340: ST_TO_ADDR
72341: GO 72266
72343: POP
72344: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72345: NOP4
72349: PUSH
72350: LD_INT 0
72352: EQUAL
72353: PUSH
72354: NOP4
72358: PUSH
72359: NOP4
72363: PUSH
72364: NOP4
72368: ARRAY
72369: LESSEQUAL
72370: OR
72371: IFFALSE 72375
// continue ;
72373: GO 71625
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72375: NOP4
72379: PUSH
72380: NOP4
72384: PUSH
72385: NOP4
72389: ARRAY
72390: PPUSH
72391: LD_INT 25
72393: PUSH
72394: LD_INT 3
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PPUSH
72401: NOP4
72405: PUSH
72406: NOP4
72410: PUSH
72411: NOP4
72415: ARRAY
72416: DIFF
72417: PPUSH
72418: LD_INT 3
72420: PPUSH
72421: NOP4
72425: ST_TO_ADDR
// for j in tmp do
72426: NOP4
72430: PUSH
72431: NOP4
72435: PUSH
72436: FOR_IN
72437: IFFALSE 72472
// if GetTag ( j ) > 0 then
72439: NOP4
72443: PPUSH
72444: NOP4
72448: PUSH
72449: LD_INT 0
72451: GREATER
72452: IFFALSE 72470
// tmp := tmp diff j ;
72454: NOP4
72458: PUSH
72459: NOP4
72463: PUSH
72464: NOP4
72468: DIFF
72469: ST_TO_ADDR
72470: GO 72436
72472: POP
72473: POP
// if not tmp then
72474: NOP4
72478: NOT
72479: IFFALSE 72483
// continue ;
72481: GO 71625
// if places then
72483: NOP4
72487: IFFALSE 72546
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72489: NOP4
72493: PUSH
72494: NOP4
72498: PPUSH
72499: NOP4
72503: PPUSH
72504: NOP4
72508: PUSH
72509: NOP4
72513: ARRAY
72514: PUSH
72515: NOP4
72519: PUSH
72520: LD_INT 1
72522: ARRAY
72523: UNION
72524: PPUSH
72525: NOP4
72529: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72530: NOP4
72534: PUSH
72535: LD_INT 1
72537: ARRAY
72538: PPUSH
72539: LD_INT 126
72541: PPUSH
72542: NOP4
// end ; end ;
72546: GO 71625
72548: POP
72549: POP
// end ;
72550: LD_VAR 0 1
72554: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72555: LD_INT 0
72557: PPUSH
72558: PPUSH
72559: PPUSH
72560: PPUSH
72561: PPUSH
72562: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72563: NOP4
72567: NOT
72568: PUSH
72569: NOP4
72573: NOT
72574: OR
72575: PUSH
72576: NOP4
72580: NOT
72581: OR
72582: PUSH
72583: NOP4
72587: PUSH
72588: LD_INT 1
72590: PUSH
72591: LD_INT 2
72593: PUSH
72594: LD_INT 3
72596: PUSH
72597: LD_INT 4
72599: PUSH
72600: LD_INT 5
72602: PUSH
72603: LD_INT 8
72605: PUSH
72606: LD_INT 9
72608: PUSH
72609: LD_INT 15
72611: PUSH
72612: LD_INT 16
72614: PUSH
72615: EMPTY
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: LIST
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: IN
72626: NOT
72627: OR
72628: IFFALSE 72632
// exit ;
72630: GO 73532
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72632: NOP4
72636: PUSH
72637: NOP4
72641: PPUSH
72642: LD_INT 21
72644: PUSH
72645: LD_INT 3
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 24
72654: PUSH
72655: LD_INT 250
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PPUSH
72666: NOP4
72670: ST_TO_ADDR
// case class of 1 , 15 :
72671: NOP4
72675: PUSH
72676: LD_INT 1
72678: DOUBLE
72679: EQUAL
72680: IFTRUE 72690
72682: LD_INT 15
72684: DOUBLE
72685: EQUAL
72686: IFTRUE 72690
72688: GO 72775
72690: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72691: NOP4
72695: PUSH
72696: NOP4
72700: PPUSH
72701: LD_INT 2
72703: PUSH
72704: LD_INT 30
72706: PUSH
72707: LD_INT 32
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: LD_INT 30
72716: PUSH
72717: LD_INT 31
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PUSH
72724: EMPTY
72725: LIST
72726: LIST
72727: LIST
72728: PPUSH
72729: NOP4
72733: PUSH
72734: NOP4
72738: PPUSH
72739: LD_INT 2
72741: PUSH
72742: LD_INT 30
72744: PUSH
72745: LD_INT 4
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 30
72754: PUSH
72755: LD_INT 5
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: LIST
72766: PPUSH
72767: NOP4
72771: ADD
72772: ST_TO_ADDR
72773: GO 73021
72775: LD_INT 2
72777: DOUBLE
72778: EQUAL
72779: IFTRUE 72789
72781: LD_INT 16
72783: DOUBLE
72784: EQUAL
72785: IFTRUE 72789
72787: GO 72835
72789: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72790: NOP4
72794: PUSH
72795: NOP4
72799: PPUSH
72800: LD_INT 2
72802: PUSH
72803: LD_INT 30
72805: PUSH
72806: LD_INT 0
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: LD_INT 30
72815: PUSH
72816: LD_INT 1
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: LIST
72827: PPUSH
72828: NOP4
72832: ST_TO_ADDR
72833: GO 73021
72835: LD_INT 3
72837: DOUBLE
72838: EQUAL
72839: IFTRUE 72843
72841: GO 72889
72843: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72844: NOP4
72848: PUSH
72849: NOP4
72853: PPUSH
72854: LD_INT 2
72856: PUSH
72857: LD_INT 30
72859: PUSH
72860: LD_INT 2
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 30
72869: PUSH
72870: LD_INT 3
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: LIST
72881: PPUSH
72882: NOP4
72886: ST_TO_ADDR
72887: GO 73021
72889: LD_INT 4
72891: DOUBLE
72892: EQUAL
72893: IFTRUE 72897
72895: GO 72954
72897: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72898: NOP4
72902: PUSH
72903: NOP4
72907: PPUSH
72908: LD_INT 2
72910: PUSH
72911: LD_INT 30
72913: PUSH
72914: LD_INT 6
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: PUSH
72921: LD_INT 30
72923: PUSH
72924: LD_INT 7
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: LD_INT 30
72933: PUSH
72934: LD_INT 8
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: EMPTY
72942: LIST
72943: LIST
72944: LIST
72945: LIST
72946: PPUSH
72947: NOP4
72951: ST_TO_ADDR
72952: GO 73021
72954: LD_INT 5
72956: DOUBLE
72957: EQUAL
72958: IFTRUE 72974
72960: LD_INT 8
72962: DOUBLE
72963: EQUAL
72964: IFTRUE 72974
72966: LD_INT 9
72968: DOUBLE
72969: EQUAL
72970: IFTRUE 72974
72972: GO 73020
72974: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
72975: NOP4
72979: PUSH
72980: NOP4
72984: PPUSH
72985: LD_INT 2
72987: PUSH
72988: LD_INT 30
72990: PUSH
72991: LD_INT 4
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: LD_INT 30
73000: PUSH
73001: LD_INT 5
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: LIST
73012: PPUSH
73013: NOP4
73017: ST_TO_ADDR
73018: GO 73021
73020: POP
// if not tmp then
73021: NOP4
73025: NOT
73026: IFFALSE 73030
// exit ;
73028: GO 73532
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73030: NOP4
73034: PUSH
73035: LD_INT 1
73037: PUSH
73038: LD_INT 15
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: IN
73045: PUSH
73046: NOP4
73050: PUSH
73051: NOP4
73055: ARRAY
73056: AND
73057: IFFALSE 73213
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73059: NOP4
73063: PUSH
73064: NOP4
73068: PUSH
73069: NOP4
73073: ARRAY
73074: PUSH
73075: LD_INT 1
73077: ARRAY
73078: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73079: NOP4
73083: PUSH
73084: NOP4
73088: PUSH
73089: NOP4
73093: ARRAY
73094: IN
73095: NOT
73096: IFFALSE 73211
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73098: NOP4
73102: PUSH
73103: NOP4
73107: PPUSH
73108: NOP4
73112: PUSH
73113: NOP4
73117: PUSH
73118: NOP4
73122: ARRAY
73123: PUSH
73124: LD_INT 1
73126: PLUS
73127: PUSH
73128: EMPTY
73129: LIST
73130: LIST
73131: PPUSH
73132: NOP4
73136: PPUSH
73137: NOP4
73141: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73142: NOP4
73146: PUSH
73147: NOP4
73151: PPUSH
73152: NOP4
73156: PPUSH
73157: NOP4
73161: PUSH
73162: NOP4
73166: ARRAY
73167: PUSH
73168: NOP4
73172: DIFF
73173: PPUSH
73174: NOP4
73178: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73179: NOP4
73183: PPUSH
73184: NOP4
73188: PUSH
73189: NOP4
73193: ARRAY
73194: PUSH
73195: NOP4
73199: PUSH
73200: NOP4
73204: ARRAY
73205: ARRAY
73206: PPUSH
73207: NOP4
// end ; exit ;
73211: GO 73532
// end ; if tmp > 1 then
73213: NOP4
73217: PUSH
73218: LD_INT 1
73220: GREATER
73221: IFFALSE 73325
// for i = 2 to tmp do
73223: NOP4
73227: PUSH
73228: DOUBLE
73229: LD_INT 2
73231: DEC
73232: ST_TO_ADDR
73233: NOP4
73237: PUSH
73238: FOR_TO
73239: IFFALSE 73323
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73241: NOP4
73245: PUSH
73246: NOP4
73250: ARRAY
73251: PPUSH
73252: NOP4
73256: PUSH
73257: LD_INT 6
73259: EQUAL
73260: IFFALSE 73321
// begin x := tmp [ i ] ;
73262: NOP4
73266: PUSH
73267: NOP4
73271: PUSH
73272: NOP4
73276: ARRAY
73277: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73278: NOP4
73282: PUSH
73283: NOP4
73287: PPUSH
73288: NOP4
73292: PPUSH
73293: NOP4
73297: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73298: NOP4
73302: PUSH
73303: NOP4
73307: PPUSH
73308: LD_INT 1
73310: PPUSH
73311: NOP4
73315: PPUSH
73316: NOP4
73320: ST_TO_ADDR
// end ;
73321: GO 73238
73323: POP
73324: POP
// for i in tmp do
73325: NOP4
73329: PUSH
73330: NOP4
73334: PUSH
73335: FOR_IN
73336: IFFALSE 73405
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73338: NOP4
73342: PPUSH
73343: NOP4
73347: PUSH
73348: LD_INT 6
73350: LESS
73351: PUSH
73352: NOP4
73356: PPUSH
73357: NOP4
73361: PUSH
73362: LD_INT 31
73364: PUSH
73365: LD_INT 32
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: IN
73372: NOT
73373: AND
73374: PUSH
73375: NOP4
73379: PPUSH
73380: NOP4
73384: PUSH
73385: LD_INT 0
73387: EQUAL
73388: OR
73389: IFFALSE 73403
// begin j := i ;
73391: NOP4
73395: PUSH
73396: NOP4
73400: ST_TO_ADDR
// break ;
73401: GO 73405
// end ; end ;
73403: GO 73335
73405: POP
73406: POP
// if j then
73407: NOP4
73411: IFFALSE 73429
// ComEnterUnit ( unit , j ) else
73413: NOP4
73417: PPUSH
73418: NOP4
73422: PPUSH
73423: NOP4
73427: GO 73532
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73429: NOP4
73433: PUSH
73434: NOP4
73438: PPUSH
73439: LD_INT 2
73441: PUSH
73442: LD_INT 30
73444: PUSH
73445: LD_INT 0
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 30
73454: PUSH
73455: LD_INT 1
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: LIST
73466: PPUSH
73467: NOP4
73471: ST_TO_ADDR
// if depot then
73472: NOP4
73476: IFFALSE 73532
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73478: NOP4
73482: PUSH
73483: NOP4
73487: PPUSH
73488: NOP4
73492: PPUSH
73493: NOP4
73497: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73498: NOP4
73502: PPUSH
73503: NOP4
73507: PPUSH
73508: NOP4
73512: PUSH
73513: LD_INT 10
73515: GREATER
73516: IFFALSE 73532
// ComStandNearbyBuilding ( unit , depot ) ;
73518: NOP4
73522: PPUSH
73523: NOP4
73527: PPUSH
73528: NOP4
// end ; end ; end ;
73532: LD_VAR 0 5
73536: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73537: LD_INT 0
73539: PPUSH
73540: PPUSH
73541: PPUSH
73542: PPUSH
// if not mc_bases then
73543: NOP4
73547: NOT
73548: IFFALSE 73552
// exit ;
73550: GO 73791
// for i = 1 to mc_bases do
73552: NOP4
73556: PUSH
73557: DOUBLE
73558: LD_INT 1
73560: DEC
73561: ST_TO_ADDR
73562: NOP4
73566: PUSH
73567: FOR_TO
73568: IFFALSE 73789
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73570: NOP4
73574: PUSH
73575: NOP4
73579: PUSH
73580: NOP4
73584: ARRAY
73585: PPUSH
73586: LD_INT 21
73588: PUSH
73589: LD_INT 1
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PPUSH
73596: NOP4
73600: PUSH
73601: NOP4
73605: PUSH
73606: NOP4
73610: ARRAY
73611: UNION
73612: ST_TO_ADDR
// if not tmp then
73613: NOP4
73617: NOT
73618: IFFALSE 73622
// continue ;
73620: GO 73567
// for j in tmp do
73622: NOP4
73626: PUSH
73627: NOP4
73631: PUSH
73632: FOR_IN
73633: IFFALSE 73785
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73635: NOP4
73639: PPUSH
73640: NOP4
73644: NOT
73645: PUSH
73646: NOP4
73650: PPUSH
73651: NOP4
73655: NOT
73656: AND
73657: PUSH
73658: NOP4
73662: PPUSH
73663: NOP4
73667: NOT
73668: AND
73669: PUSH
73670: NOP4
73674: PPUSH
73675: NOP4
73679: NOT
73680: AND
73681: PUSH
73682: NOP4
73686: PUSH
73687: NOP4
73691: PUSH
73692: NOP4
73696: ARRAY
73697: PUSH
73698: LD_INT 1
73700: ARRAY
73701: IN
73702: NOT
73703: AND
73704: PUSH
73705: NOP4
73709: PUSH
73710: NOP4
73714: PUSH
73715: NOP4
73719: ARRAY
73720: PUSH
73721: LD_INT 2
73723: ARRAY
73724: IN
73725: NOT
73726: AND
73727: PUSH
73728: NOP4
73732: PUSH
73733: NOP4
73737: PUSH
73738: NOP4
73742: ARRAY
73743: IN
73744: NOT
73745: AND
73746: IFFALSE 73783
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73748: NOP4
73752: PPUSH
73753: NOP4
73757: PUSH
73758: NOP4
73762: ARRAY
73763: PPUSH
73764: NOP4
73768: PPUSH
73769: NOP4
73773: PPUSH
73774: NOP4
73778: PPUSH
73779: NOP4
// end ;
73783: GO 73632
73785: POP
73786: POP
// end ;
73787: GO 73567
73789: POP
73790: POP
// end ;
73791: LD_VAR 0 1
73795: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73796: LD_INT 0
73798: PPUSH
73799: PPUSH
73800: PPUSH
73801: PPUSH
73802: PPUSH
73803: PPUSH
// if not mc_bases [ base ] then
73804: NOP4
73808: PUSH
73809: NOP4
73813: ARRAY
73814: NOT
73815: IFFALSE 73819
// exit ;
73817: GO 74001
// tmp := [ ] ;
73819: NOP4
73823: PUSH
73824: EMPTY
73825: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73826: NOP4
73830: PUSH
73831: NOP4
73835: PPUSH
73836: LD_INT 0
73838: PPUSH
73839: NOP4
73843: ST_TO_ADDR
// if not list then
73844: NOP4
73848: NOT
73849: IFFALSE 73853
// exit ;
73851: GO 74001
// for i = 1 to amount do
73853: NOP4
73857: PUSH
73858: DOUBLE
73859: LD_INT 1
73861: DEC
73862: ST_TO_ADDR
73863: NOP4
73867: PUSH
73868: FOR_TO
73869: IFFALSE 73949
// begin x := rand ( 1 , list [ 1 ] ) ;
73871: NOP4
73875: PUSH
73876: LD_INT 1
73878: PPUSH
73879: NOP4
73883: PUSH
73884: LD_INT 1
73886: ARRAY
73887: PPUSH
73888: NOP4
73892: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73893: NOP4
73897: PUSH
73898: NOP4
73902: PPUSH
73903: NOP4
73907: PPUSH
73908: NOP4
73912: PUSH
73913: LD_INT 1
73915: ARRAY
73916: PUSH
73917: NOP4
73921: ARRAY
73922: PUSH
73923: NOP4
73927: PUSH
73928: LD_INT 2
73930: ARRAY
73931: PUSH
73932: NOP4
73936: ARRAY
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PPUSH
73942: NOP4
73946: ST_TO_ADDR
// end ;
73947: GO 73868
73949: POP
73950: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
73951: NOP4
73955: PUSH
73956: NOP4
73960: PPUSH
73961: NOP4
73965: PPUSH
73966: NOP4
73970: PPUSH
73971: NOP4
73975: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
73976: NOP4
73980: PUSH
73981: NOP4
73985: PPUSH
73986: NOP4
73990: PPUSH
73991: NOP4
73995: PPUSH
73996: NOP4
74000: ST_TO_ADDR
// end ;
74001: LD_VAR 0 4
74005: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74006: LD_INT 0
74008: PPUSH
// if not mc_bases [ base ] then
74009: NOP4
74013: PUSH
74014: NOP4
74018: ARRAY
74019: NOT
74020: IFFALSE 74024
// exit ;
74022: GO 74049
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74024: NOP4
74028: PUSH
74029: NOP4
74033: PPUSH
74034: NOP4
74038: PPUSH
74039: NOP4
74043: PPUSH
74044: NOP4
74048: ST_TO_ADDR
// end ;
74049: LD_VAR 0 3
74053: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74054: LD_INT 0
74056: PPUSH
// if not mc_bases [ base ] then
74057: NOP4
74061: PUSH
74062: NOP4
74066: ARRAY
74067: NOT
74068: IFFALSE 74072
// exit ;
74070: GO 74109
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74072: NOP4
74076: PUSH
74077: NOP4
74081: PPUSH
74082: NOP4
74086: PPUSH
74087: NOP4
74091: PUSH
74092: NOP4
74096: ARRAY
74097: PUSH
74098: NOP4
74102: UNION
74103: PPUSH
74104: NOP4
74108: ST_TO_ADDR
// end ;
74109: LD_VAR 0 3
74113: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74114: LD_INT 0
74116: PPUSH
// if not mc_bases [ base ] then
74117: NOP4
74121: PUSH
74122: NOP4
74126: ARRAY
74127: NOT
74128: IFFALSE 74132
// exit ;
74130: GO 74157
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74132: NOP4
74136: PUSH
74137: NOP4
74141: PPUSH
74142: NOP4
74146: PPUSH
74147: NOP4
74151: PPUSH
74152: NOP4
74156: ST_TO_ADDR
// end ;
74157: LD_VAR 0 3
74161: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74162: LD_INT 0
74164: PPUSH
// if not mc_bases [ base ] then
74165: NOP4
74169: PUSH
74170: NOP4
74174: ARRAY
74175: NOT
74176: IFFALSE 74180
// exit ;
74178: GO 74217
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74180: NOP4
74184: PUSH
74185: NOP4
74189: PPUSH
74190: NOP4
74194: PPUSH
74195: NOP4
74199: PUSH
74200: NOP4
74204: ARRAY
74205: PUSH
74206: NOP4
74210: ADD
74211: PPUSH
74212: NOP4
74216: ST_TO_ADDR
// end ;
74217: LD_VAR 0 3
74221: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74222: LD_INT 0
74224: PPUSH
// if not mc_bases [ base ] then
74225: NOP4
74229: PUSH
74230: NOP4
74234: ARRAY
74235: NOT
74236: IFFALSE 74240
// exit ;
74238: GO 74294
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74240: NOP4
74244: PUSH
74245: NOP4
74249: PPUSH
74250: NOP4
74254: PPUSH
74255: NOP4
74259: PPUSH
74260: NOP4
74264: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74265: NOP4
74269: PUSH
74270: NOP4
74274: PPUSH
74275: NOP4
74279: PPUSH
74280: NOP4
74284: PUSH
74285: LD_INT 0
74287: PLUS
74288: PPUSH
74289: NOP4
74293: ST_TO_ADDR
// end ;
74294: LD_VAR 0 3
74298: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74299: LD_INT 0
74301: PPUSH
// if not mc_bases [ base ] then
74302: NOP4
74306: PUSH
74307: NOP4
74311: ARRAY
74312: NOT
74313: IFFALSE 74317
// exit ;
74315: GO 74342
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74317: NOP4
74321: PUSH
74322: NOP4
74326: PPUSH
74327: NOP4
74331: PPUSH
74332: NOP4
74336: PPUSH
74337: NOP4
74341: ST_TO_ADDR
// end ;
74342: LD_VAR 0 3
74346: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74347: LD_INT 0
74349: PPUSH
74350: PPUSH
74351: PPUSH
74352: PPUSH
// if not mc_bases [ base ] then
74353: NOP4
74357: PUSH
74358: NOP4
74362: ARRAY
74363: NOT
74364: IFFALSE 74368
// exit ;
74366: GO 74433
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74368: NOP4
74372: PUSH
74373: NOP4
74377: PPUSH
74378: NOP4
74382: PUSH
74383: NOP4
74387: PUSH
74388: NOP4
74392: ARRAY
74393: PUSH
74394: LD_INT 1
74396: PLUS
74397: PUSH
74398: EMPTY
74399: LIST
74400: LIST
74401: PPUSH
74402: NOP4
74406: PUSH
74407: NOP4
74411: PUSH
74412: NOP4
74416: PUSH
74417: NOP4
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: LIST
74426: LIST
74427: PPUSH
74428: NOP4
74432: ST_TO_ADDR
// end ;
74433: LD_VAR 0 5
74437: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74438: LD_INT 0
74440: PPUSH
// if not mc_bases [ base ] then
74441: NOP4
74445: PUSH
74446: NOP4
74450: ARRAY
74451: NOT
74452: IFFALSE 74456
// exit ;
74454: GO 74481
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74456: NOP4
74460: PUSH
74461: NOP4
74465: PPUSH
74466: NOP4
74470: PPUSH
74471: NOP4
74475: PPUSH
74476: NOP4
74480: ST_TO_ADDR
// end ;
74481: LD_VAR 0 3
74485: RET
// export function MC_GetMinesField ( base ) ; begin
74486: LD_INT 0
74488: PPUSH
// result := mc_mines [ base ] ;
74489: NOP4
74493: PUSH
74494: NOP4
74498: PUSH
74499: NOP4
74503: ARRAY
74504: ST_TO_ADDR
// end ;
74505: LD_VAR 0 2
74509: RET
// export function MC_GetProduceList ( base ) ; begin
74510: LD_INT 0
74512: PPUSH
// result := mc_produce [ base ] ;
74513: NOP4
74517: PUSH
74518: NOP4
74522: PUSH
74523: NOP4
74527: ARRAY
74528: ST_TO_ADDR
// end ;
74529: LD_VAR 0 2
74533: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74534: LD_INT 0
74536: PPUSH
74537: PPUSH
// if not mc_bases then
74538: NOP4
74542: NOT
74543: IFFALSE 74547
// exit ;
74545: GO 74612
// if mc_bases [ base ] then
74547: NOP4
74551: PUSH
74552: NOP4
74556: ARRAY
74557: IFFALSE 74612
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74559: NOP4
74563: PUSH
74564: NOP4
74568: PUSH
74569: NOP4
74573: ARRAY
74574: PPUSH
74575: LD_INT 30
74577: PUSH
74578: NOP4
74582: PUSH
74583: EMPTY
74584: LIST
74585: LIST
74586: PPUSH
74587: NOP4
74591: ST_TO_ADDR
// if result then
74592: NOP4
74596: IFFALSE 74612
// result := result [ 1 ] ;
74598: NOP4
74602: PUSH
74603: NOP4
74607: PUSH
74608: LD_INT 1
74610: ARRAY
74611: ST_TO_ADDR
// end ; end ;
74612: LD_VAR 0 3
74616: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74617: LD_INT 0
74619: PPUSH
74620: PPUSH
// if not mc_bases then
74621: NOP4
74625: NOT
74626: IFFALSE 74630
// exit ;
74628: GO 74675
// if mc_bases [ base ] then
74630: NOP4
74634: PUSH
74635: NOP4
74639: ARRAY
74640: IFFALSE 74675
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74642: NOP4
74646: PUSH
74647: NOP4
74651: PUSH
74652: NOP4
74656: ARRAY
74657: PPUSH
74658: LD_INT 30
74660: PUSH
74661: NOP4
74665: PUSH
74666: EMPTY
74667: LIST
74668: LIST
74669: PPUSH
74670: NOP4
74674: ST_TO_ADDR
// end ;
74675: LD_VAR 0 3
74679: RET
// export function MC_SetTame ( base , area ) ; begin
74680: LD_INT 0
74682: PPUSH
// if not mc_bases or not base then
74683: NOP4
74687: NOT
74688: PUSH
74689: NOP4
74693: NOT
74694: OR
74695: IFFALSE 74699
// exit ;
74697: GO 74724
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74699: NOP4
74703: PUSH
74704: NOP4
74708: PPUSH
74709: NOP4
74713: PPUSH
74714: NOP4
74718: PPUSH
74719: NOP4
74723: ST_TO_ADDR
// end ;
74724: LD_VAR 0 3
74728: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74729: LD_INT 0
74731: PPUSH
74732: PPUSH
// if not mc_bases or not base then
74733: NOP4
74737: NOT
74738: PUSH
74739: NOP4
74743: NOT
74744: OR
74745: IFFALSE 74749
// exit ;
74747: GO 74851
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74749: NOP4
74753: PUSH
74754: NOP4
74758: PUSH
74759: NOP4
74763: ARRAY
74764: PPUSH
74765: LD_INT 30
74767: PUSH
74768: NOP4
74772: PUSH
74773: EMPTY
74774: LIST
74775: LIST
74776: PPUSH
74777: NOP4
74781: ST_TO_ADDR
// if not tmp then
74782: NOP4
74786: NOT
74787: IFFALSE 74791
// exit ;
74789: GO 74851
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74791: NOP4
74795: PUSH
74796: NOP4
74800: PPUSH
74801: NOP4
74805: PPUSH
74806: NOP4
74810: PUSH
74811: NOP4
74815: ARRAY
74816: PPUSH
74817: NOP4
74821: PUSH
74822: NOP4
74826: ARRAY
74827: PUSH
74828: LD_INT 1
74830: PLUS
74831: PPUSH
74832: NOP4
74836: PUSH
74837: LD_INT 1
74839: ARRAY
74840: PPUSH
74841: NOP4
74845: PPUSH
74846: NOP4
74850: ST_TO_ADDR
// end ;
74851: LD_VAR 0 3
74855: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74856: LD_INT 0
74858: PPUSH
74859: PPUSH
// if not mc_bases or not base or not kinds then
74860: NOP4
74864: NOT
74865: PUSH
74866: NOP4
74870: NOT
74871: OR
74872: PUSH
74873: NOP4
74877: NOT
74878: OR
74879: IFFALSE 74883
// exit ;
74881: GO 74944
// for i in kinds do
74883: NOP4
74887: PUSH
74888: NOP4
74892: PUSH
74893: FOR_IN
74894: IFFALSE 74942
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74896: NOP4
74900: PUSH
74901: NOP4
74905: PPUSH
74906: NOP4
74910: PUSH
74911: NOP4
74915: PUSH
74916: NOP4
74920: ARRAY
74921: PUSH
74922: LD_INT 1
74924: PLUS
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PPUSH
74930: NOP4
74934: PPUSH
74935: NOP4
74939: ST_TO_ADDR
74940: GO 74893
74942: POP
74943: POP
// end ;
74944: LD_VAR 0 3
74948: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
74949: LD_INT 0
74951: PPUSH
// if not mc_bases or not base or not areas then
74952: NOP4
74956: NOT
74957: PUSH
74958: NOP4
74962: NOT
74963: OR
74964: PUSH
74965: NOP4
74969: NOT
74970: OR
74971: IFFALSE 74975
// exit ;
74973: GO 75000
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
74975: NOP4
74979: PUSH
74980: NOP4
74984: PPUSH
74985: NOP4
74989: PPUSH
74990: NOP4
74994: PPUSH
74995: NOP4
74999: ST_TO_ADDR
// end ;
75000: LD_VAR 0 3
75004: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75005: LD_INT 0
75007: PPUSH
// if not mc_bases or not base or not teleports_exit then
75008: NOP4
75012: NOT
75013: PUSH
75014: NOP4
75018: NOT
75019: OR
75020: PUSH
75021: NOP4
75025: NOT
75026: OR
75027: IFFALSE 75031
// exit ;
75029: GO 75056
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75031: NOP4
75035: PUSH
75036: NOP4
75040: PPUSH
75041: NOP4
75045: PPUSH
75046: NOP4
75050: PPUSH
75051: NOP4
75055: ST_TO_ADDR
// end ;
75056: LD_VAR 0 3
75060: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75061: LD_INT 0
75063: PPUSH
75064: PPUSH
75065: PPUSH
// if not mc_bases or not base or not ext_list then
75066: NOP4
75070: NOT
75071: PUSH
75072: NOP4
75076: NOT
75077: OR
75078: PUSH
75079: NOP4
75083: NOT
75084: OR
75085: IFFALSE 75089
// exit ;
75087: GO 75262
// tmp := GetFacExtXYD ( x , y , d ) ;
75089: NOP4
75093: PUSH
75094: NOP4
75098: PPUSH
75099: NOP4
75103: PPUSH
75104: NOP4
75108: PPUSH
75109: NOP4
75113: ST_TO_ADDR
// if not tmp then
75114: NOP4
75118: NOT
75119: IFFALSE 75123
// exit ;
75121: GO 75262
// for i in tmp do
75123: NOP4
75127: PUSH
75128: NOP4
75132: PUSH
75133: FOR_IN
75134: IFFALSE 75260
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75136: NOP4
75140: PUSH
75141: NOP4
75145: PPUSH
75146: NOP4
75150: PPUSH
75151: NOP4
75155: PUSH
75156: NOP4
75160: ARRAY
75161: PPUSH
75162: NOP4
75166: PUSH
75167: NOP4
75171: ARRAY
75172: PUSH
75173: LD_INT 1
75175: PLUS
75176: PPUSH
75177: NOP4
75181: PUSH
75182: LD_INT 1
75184: ARRAY
75185: PUSH
75186: NOP4
75190: PUSH
75191: LD_INT 1
75193: ARRAY
75194: PUSH
75195: NOP4
75199: PUSH
75200: LD_INT 2
75202: ARRAY
75203: PUSH
75204: NOP4
75208: PUSH
75209: LD_INT 3
75211: ARRAY
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: LIST
75217: LIST
75218: PPUSH
75219: NOP4
75223: PPUSH
75224: NOP4
75228: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75229: NOP4
75233: PUSH
75234: NOP4
75238: PPUSH
75239: LD_INT 1
75241: PPUSH
75242: NOP4
75246: ST_TO_ADDR
// if not ext_list then
75247: NOP4
75251: NOT
75252: IFFALSE 75258
// exit ;
75254: POP
75255: POP
75256: GO 75262
// end ;
75258: GO 75133
75260: POP
75261: POP
// end ;
75262: LD_VAR 0 6
75266: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75267: LD_INT 0
75269: PPUSH
// if not mc_bases or not base or not weapon_list then
75270: NOP4
75274: NOT
75275: PUSH
75276: NOP4
75280: NOT
75281: OR
75282: PUSH
75283: NOP4
75287: NOT
75288: OR
75289: IFFALSE 75293
// exit ;
75291: GO 75318
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75293: NOP4
75297: PUSH
75298: NOP4
75302: PPUSH
75303: NOP4
75307: PPUSH
75308: NOP4
75312: PPUSH
75313: NOP4
75317: ST_TO_ADDR
// end ;
75318: LD_VAR 0 3
75322: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75323: LD_INT 0
75325: PPUSH
// if not mc_bases or not base or not tech_list then
75326: NOP4
75330: NOT
75331: PUSH
75332: NOP4
75336: NOT
75337: OR
75338: PUSH
75339: NOP4
75343: NOT
75344: OR
75345: IFFALSE 75349
// exit ;
75347: GO 75374
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75349: NOP4
75353: PUSH
75354: NOP4
75358: PPUSH
75359: NOP4
75363: PPUSH
75364: NOP4
75368: PPUSH
75369: NOP4
75373: ST_TO_ADDR
// end ;
75374: LD_VAR 0 3
75378: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75379: LD_INT 0
75381: PPUSH
// if not mc_bases or not parking_area or not base then
75382: NOP4
75386: NOT
75387: PUSH
75388: NOP4
75392: NOT
75393: OR
75394: PUSH
75395: NOP4
75399: NOT
75400: OR
75401: IFFALSE 75405
// exit ;
75403: GO 75430
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
75405: NOP4
75409: PUSH
75410: NOP4
75414: PPUSH
75415: NOP4
75419: PPUSH
75420: NOP4
75424: PPUSH
75425: NOP4
75429: ST_TO_ADDR
// end ;
75430: LD_VAR 0 3
75434: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75435: LD_INT 0
75437: PPUSH
// if not mc_bases or not base or not scan_area then
75438: NOP4
75442: NOT
75443: PUSH
75444: NOP4
75448: NOT
75449: OR
75450: PUSH
75451: NOP4
75455: NOT
75456: OR
75457: IFFALSE 75461
// exit ;
75459: GO 75486
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75461: NOP4
75465: PUSH
75466: NOP4
75470: PPUSH
75471: NOP4
75475: PPUSH
75476: NOP4
75480: PPUSH
75481: NOP4
75485: ST_TO_ADDR
// end ;
75486: LD_VAR 0 3
75490: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75491: LD_INT 0
75493: PPUSH
75494: PPUSH
// if not mc_bases or not base then
75495: NOP4
75499: NOT
75500: PUSH
75501: NOP4
75505: NOT
75506: OR
75507: IFFALSE 75511
// exit ;
75509: GO 75575
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75511: NOP4
75515: PUSH
75516: LD_INT 1
75518: PUSH
75519: LD_INT 2
75521: PUSH
75522: LD_INT 3
75524: PUSH
75525: LD_INT 4
75527: PUSH
75528: LD_INT 11
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75538: NOP4
75542: PUSH
75543: NOP4
75547: PPUSH
75548: NOP4
75552: PPUSH
75553: NOP4
75557: PUSH
75558: NOP4
75562: ARRAY
75563: PUSH
75564: NOP4
75568: DIFF
75569: PPUSH
75570: NOP4
75574: ST_TO_ADDR
// end ;
75575: LD_VAR 0 2
75579: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75580: LD_INT 0
75582: PPUSH
// result := mc_vehicles [ base ] ;
75583: NOP4
75587: PUSH
75588: NOP4
75592: PUSH
75593: NOP4
75597: ARRAY
75598: ST_TO_ADDR
// if onlyCombat then
75599: NOP4
75603: IFFALSE 75781
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75605: NOP4
75609: PUSH
75610: NOP4
75614: PUSH
75615: NOP4
75619: PPUSH
75620: LD_INT 2
75622: PUSH
75623: LD_INT 34
75625: PUSH
75626: LD_INT 12
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 34
75635: PUSH
75636: LD_INT 51
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 34
75645: PUSH
75646: NOP4
75650: PUSH
75651: EMPTY
75652: LIST
75653: LIST
75654: PUSH
75655: LD_INT 34
75657: PUSH
75658: LD_INT 32
75660: PUSH
75661: EMPTY
75662: LIST
75663: LIST
75664: PUSH
75665: LD_INT 34
75667: PUSH
75668: LD_INT 13
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: PUSH
75675: LD_INT 34
75677: PUSH
75678: LD_INT 52
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 34
75687: PUSH
75688: NOP4
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 34
75699: PUSH
75700: LD_INT 14
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: PUSH
75707: LD_INT 34
75709: PUSH
75710: LD_INT 53
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: PUSH
75717: LD_INT 34
75719: PUSH
75720: NOP4
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 34
75731: PUSH
75732: LD_INT 31
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PUSH
75739: LD_INT 34
75741: PUSH
75742: LD_INT 48
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 34
75751: PUSH
75752: LD_INT 8
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: LIST
75767: LIST
75768: LIST
75769: LIST
75770: LIST
75771: LIST
75772: LIST
75773: LIST
75774: PPUSH
75775: NOP4
75779: DIFF
75780: ST_TO_ADDR
// end ; end_of_file
75781: LD_VAR 0 3
75785: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75786: LD_INT 0
75788: PPUSH
75789: PPUSH
75790: PPUSH
// if not mc_bases or not skirmish then
75791: NOP4
75795: NOT
75796: PUSH
75797: NOP4
75801: NOT
75802: OR
75803: IFFALSE 75807
// exit ;
75805: GO 75972
// for i = 1 to mc_bases do
75807: NOP4
75811: PUSH
75812: DOUBLE
75813: LD_INT 1
75815: DEC
75816: ST_TO_ADDR
75817: NOP4
75821: PUSH
75822: FOR_TO
75823: IFFALSE 75970
// begin if sci in mc_bases [ i ] then
75825: NOP4
75829: PUSH
75830: NOP4
75834: PUSH
75835: NOP4
75839: ARRAY
75840: IN
75841: IFFALSE 75968
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75843: NOP4
75847: PUSH
75848: NOP4
75852: PPUSH
75853: NOP4
75857: PUSH
75858: NOP4
75862: PUSH
75863: NOP4
75867: ARRAY
75868: PUSH
75869: LD_INT 1
75871: PLUS
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PPUSH
75877: NOP4
75881: PPUSH
75882: NOP4
75886: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75887: NOP4
75891: PUSH
75892: NOP4
75896: PUSH
75897: NOP4
75901: ARRAY
75902: PPUSH
75903: LD_INT 2
75905: PUSH
75906: LD_INT 30
75908: PUSH
75909: LD_INT 0
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: PUSH
75916: LD_INT 30
75918: PUSH
75919: LD_INT 1
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: LIST
75930: PPUSH
75931: NOP4
75935: PPUSH
75936: NOP4
75940: PPUSH
75941: NOP4
75945: ST_TO_ADDR
// if tmp then
75946: NOP4
75950: IFFALSE 75966
// ComStandNearbyBuilding ( ape , tmp ) ;
75952: NOP4
75956: PPUSH
75957: NOP4
75961: PPUSH
75962: NOP4
// break ;
75966: GO 75970
// end ; end ;
75968: GO 75822
75970: POP
75971: POP
// end ;
75972: LD_VAR 0 3
75976: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
75977: LD_INT 0
75979: PPUSH
75980: PPUSH
75981: PPUSH
// if not mc_bases or not skirmish then
75982: NOP4
75986: NOT
75987: PUSH
75988: NOP4
75992: NOT
75993: OR
75994: IFFALSE 75998
// exit ;
75996: GO 76087
// for i = 1 to mc_bases do
75998: NOP4
76002: PUSH
76003: DOUBLE
76004: LD_INT 1
76006: DEC
76007: ST_TO_ADDR
76008: NOP4
76012: PUSH
76013: FOR_TO
76014: IFFALSE 76085
// begin if building in mc_busy_turret_list [ i ] then
76016: NOP4
76020: PUSH
76021: NOP4
76025: PUSH
76026: NOP4
76030: ARRAY
76031: IN
76032: IFFALSE 76083
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76034: NOP4
76038: PUSH
76039: NOP4
76043: PUSH
76044: NOP4
76048: ARRAY
76049: PUSH
76050: NOP4
76054: DIFF
76055: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76056: NOP4
76060: PUSH
76061: NOP4
76065: PPUSH
76066: NOP4
76070: PPUSH
76071: NOP4
76075: PPUSH
76076: NOP4
76080: ST_TO_ADDR
// break ;
76081: GO 76085
// end ; end ;
76083: GO 76013
76085: POP
76086: POP
// end ;
76087: LD_VAR 0 3
76091: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76092: LD_INT 0
76094: PPUSH
76095: PPUSH
76096: PPUSH
// if not mc_bases or not skirmish then
76097: NOP4
76101: NOT
76102: PUSH
76103: NOP4
76107: NOT
76108: OR
76109: IFFALSE 76113
// exit ;
76111: GO 76312
// for i = 1 to mc_bases do
76113: NOP4
76117: PUSH
76118: DOUBLE
76119: LD_INT 1
76121: DEC
76122: ST_TO_ADDR
76123: NOP4
76127: PUSH
76128: FOR_TO
76129: IFFALSE 76310
// if building in mc_bases [ i ] then
76131: NOP4
76135: PUSH
76136: NOP4
76140: PUSH
76141: NOP4
76145: ARRAY
76146: IN
76147: IFFALSE 76308
// begin tmp := mc_bases [ i ] diff building ;
76149: NOP4
76153: PUSH
76154: NOP4
76158: PUSH
76159: NOP4
76163: ARRAY
76164: PUSH
76165: NOP4
76169: DIFF
76170: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76171: NOP4
76175: PUSH
76176: NOP4
76180: PPUSH
76181: NOP4
76185: PPUSH
76186: NOP4
76190: PPUSH
76191: NOP4
76195: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76196: NOP4
76200: PUSH
76201: NOP4
76205: PUSH
76206: NOP4
76210: ARRAY
76211: IN
76212: IFFALSE 76251
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76214: NOP4
76218: PUSH
76219: NOP4
76223: PPUSH
76224: NOP4
76228: PPUSH
76229: NOP4
76233: PUSH
76234: NOP4
76238: ARRAY
76239: PUSH
76240: NOP4
76244: DIFF
76245: PPUSH
76246: NOP4
76250: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76251: NOP4
76255: PUSH
76256: NOP4
76260: PUSH
76261: NOP4
76265: ARRAY
76266: IN
76267: IFFALSE 76306
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76269: NOP4
76273: PUSH
76274: NOP4
76278: PPUSH
76279: NOP4
76283: PPUSH
76284: NOP4
76288: PUSH
76289: NOP4
76293: ARRAY
76294: PUSH
76295: NOP4
76299: DIFF
76300: PPUSH
76301: NOP4
76305: ST_TO_ADDR
// break ;
76306: GO 76310
// end ;
76308: GO 76128
76310: POP
76311: POP
// end ;
76312: LD_VAR 0 4
76316: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76317: LD_INT 0
76319: PPUSH
76320: PPUSH
76321: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76322: NOP4
76326: NOT
76327: PUSH
76328: NOP4
76332: NOT
76333: OR
76334: PUSH
76335: NOP4
76339: PUSH
76340: NOP4
76344: IN
76345: NOT
76346: OR
76347: IFFALSE 76351
// exit ;
76349: GO 76474
// for i = 1 to mc_vehicles do
76351: NOP4
76355: PUSH
76356: DOUBLE
76357: LD_INT 1
76359: DEC
76360: ST_TO_ADDR
76361: NOP4
76365: PUSH
76366: FOR_TO
76367: IFFALSE 76472
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76369: NOP4
76373: PUSH
76374: NOP4
76378: PUSH
76379: NOP4
76383: ARRAY
76384: IN
76385: PUSH
76386: NOP4
76390: PUSH
76391: NOP4
76395: PUSH
76396: NOP4
76400: ARRAY
76401: IN
76402: OR
76403: IFFALSE 76470
// begin tmp := mc_vehicles [ i ] diff old ;
76405: NOP4
76409: PUSH
76410: NOP4
76414: PUSH
76415: NOP4
76419: ARRAY
76420: PUSH
76421: NOP4
76425: DIFF
76426: ST_TO_ADDR
// tmp := tmp diff new ;
76427: NOP4
76431: PUSH
76432: NOP4
76436: PUSH
76437: NOP4
76441: DIFF
76442: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76443: NOP4
76447: PUSH
76448: NOP4
76452: PPUSH
76453: NOP4
76457: PPUSH
76458: NOP4
76462: PPUSH
76463: NOP4
76467: ST_TO_ADDR
// break ;
76468: GO 76472
// end ;
76470: GO 76366
76472: POP
76473: POP
// end ;
76474: LD_VAR 0 5
76478: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76479: LD_INT 0
76481: PPUSH
76482: PPUSH
76483: PPUSH
76484: PPUSH
// if not mc_bases or not skirmish then
76485: NOP4
76489: NOT
76490: PUSH
76491: NOP4
76495: NOT
76496: OR
76497: IFFALSE 76501
// exit ;
76499: GO 76893
// side := GetSide ( vehicle ) ;
76501: NOP4
76505: PUSH
76506: NOP4
76510: PPUSH
76511: NOP4
76515: ST_TO_ADDR
// for i = 1 to mc_bases do
76516: NOP4
76520: PUSH
76521: DOUBLE
76522: LD_INT 1
76524: DEC
76525: ST_TO_ADDR
76526: NOP4
76530: PUSH
76531: FOR_TO
76532: IFFALSE 76891
// begin if factory in mc_bases [ i ] then
76534: NOP4
76538: PUSH
76539: NOP4
76543: PUSH
76544: NOP4
76548: ARRAY
76549: IN
76550: IFFALSE 76889
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
76552: NOP4
76556: PUSH
76557: NOP4
76561: ARRAY
76562: PUSH
76563: NOP4
76567: PUSH
76568: NOP4
76572: ARRAY
76573: LESS
76574: PUSH
76575: NOP4
76579: PPUSH
76580: NOP4
76584: PUSH
76585: LD_INT 31
76587: PUSH
76588: LD_INT 32
76590: PUSH
76591: LD_INT 51
76593: PUSH
76594: NOP4
76598: PUSH
76599: LD_INT 12
76601: PUSH
76602: LD_INT 30
76604: PUSH
76605: NOP4
76609: PUSH
76610: LD_INT 11
76612: PUSH
76613: LD_INT 53
76615: PUSH
76616: LD_INT 14
76618: PUSH
76619: NOP4
76623: PUSH
76624: LD_INT 29
76626: PUSH
76627: NOP4
76631: PUSH
76632: LD_INT 13
76634: PUSH
76635: LD_INT 52
76637: PUSH
76638: NOP4
76642: PUSH
76643: LD_INT 48
76645: PUSH
76646: LD_INT 8
76648: PUSH
76649: EMPTY
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: LIST
76655: LIST
76656: LIST
76657: LIST
76658: LIST
76659: LIST
76660: LIST
76661: LIST
76662: LIST
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: IN
76669: NOT
76670: AND
76671: IFFALSE 76719
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76673: NOP4
76677: PUSH
76678: NOP4
76682: PPUSH
76683: NOP4
76687: PUSH
76688: NOP4
76692: PUSH
76693: NOP4
76697: ARRAY
76698: PUSH
76699: LD_INT 1
76701: PLUS
76702: PUSH
76703: EMPTY
76704: LIST
76705: LIST
76706: PPUSH
76707: NOP4
76711: PPUSH
76712: NOP4
76716: ST_TO_ADDR
76717: GO 76763
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76719: NOP4
76723: PUSH
76724: NOP4
76728: PPUSH
76729: NOP4
76733: PUSH
76734: NOP4
76738: PUSH
76739: NOP4
76743: ARRAY
76744: PUSH
76745: LD_INT 1
76747: PLUS
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PPUSH
76753: NOP4
76757: PPUSH
76758: NOP4
76762: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76763: NOP4
76767: PPUSH
76768: NOP4
76772: PUSH
76773: LD_INT 2
76775: EQUAL
76776: IFFALSE 76805
// begin repeat wait ( 0 0$3 ) ;
76778: LD_INT 105
76780: PPUSH
76781: NOP4
// Connect ( vehicle ) ;
76785: NOP4
76789: PPUSH
76790: NOP4
// until IsControledBy ( vehicle ) ;
76794: NOP4
76798: PPUSH
76799: NOP4
76803: IFFALSE 76778
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76805: NOP4
76809: PPUSH
76810: NOP4
76814: PUSH
76815: NOP4
76819: ARRAY
76820: PPUSH
76821: NOP4
// if GetControl ( vehicle ) <> control_manual then
76825: NOP4
76829: PPUSH
76830: NOP4
76834: PUSH
76835: LD_INT 1
76837: NONEQUAL
76838: IFFALSE 76842
// break ;
76840: GO 76891
// repeat wait ( 0 0$1 ) ;
76842: LD_INT 35
76844: PPUSH
76845: NOP4
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76849: NOP4
76853: PPUSH
76854: NOP4
76858: PUSH
76859: NOP4
76863: ARRAY
76864: PPUSH
76865: NOP4
76869: IFFALSE 76842
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76871: NOP4
76875: PPUSH
76876: NOP4
76880: PPUSH
76881: NOP4
// exit ;
76885: POP
76886: POP
76887: GO 76893
// end ; end ;
76889: GO 76531
76891: POP
76892: POP
// end ;
76893: LD_VAR 0 3
76897: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76898: LD_INT 0
76900: PPUSH
76901: PPUSH
76902: PPUSH
76903: PPUSH
// if not mc_bases or not skirmish then
76904: NOP4
76908: NOT
76909: PUSH
76910: NOP4
76914: NOT
76915: OR
76916: IFFALSE 76920
// exit ;
76918: GO 77273
// repeat wait ( 0 0$1 ) ;
76920: LD_INT 35
76922: PPUSH
76923: NOP4
// until GetResourceAmountXY ( x , y ) ;
76927: NOP4
76931: PPUSH
76932: NOP4
76936: PPUSH
76937: NOP4
76941: IFFALSE 76920
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76943: NOP4
76947: PPUSH
76948: NOP4
76952: PPUSH
76953: NOP4
76957: PUSH
76958: LD_INT 4
76960: EQUAL
76961: IFFALSE 76965
// exit ;
76963: GO 77273
// for i = 1 to mc_bases do
76965: NOP4
76969: PUSH
76970: DOUBLE
76971: LD_INT 1
76973: DEC
76974: ST_TO_ADDR
76975: NOP4
76979: PUSH
76980: FOR_TO
76981: IFFALSE 77271
// begin if mc_crates_area [ i ] then
76983: NOP4
76987: PUSH
76988: NOP4
76992: ARRAY
76993: IFFALSE 77104
// for j in mc_crates_area [ i ] do
76995: NOP4
76999: PUSH
77000: NOP4
77004: PUSH
77005: NOP4
77009: ARRAY
77010: PUSH
77011: FOR_IN
77012: IFFALSE 77102
// if InArea ( x , y , j ) then
77014: NOP4
77018: PPUSH
77019: NOP4
77023: PPUSH
77024: NOP4
77028: PPUSH
77029: NOP4
77033: IFFALSE 77100
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77035: NOP4
77039: PUSH
77040: NOP4
77044: PPUSH
77045: NOP4
77049: PUSH
77050: NOP4
77054: PUSH
77055: NOP4
77059: ARRAY
77060: PUSH
77061: LD_INT 1
77063: PLUS
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PPUSH
77069: NOP4
77073: PUSH
77074: NOP4
77078: PUSH
77079: NOP4
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: LIST
77088: PPUSH
77089: NOP4
77093: ST_TO_ADDR
// exit ;
77094: POP
77095: POP
77096: POP
77097: POP
77098: GO 77273
// end ;
77100: GO 77011
77102: POP
77103: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77104: NOP4
77108: PUSH
77109: NOP4
77113: PUSH
77114: NOP4
77118: ARRAY
77119: PPUSH
77120: LD_INT 2
77122: PUSH
77123: LD_INT 30
77125: PUSH
77126: LD_INT 0
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 30
77135: PUSH
77136: LD_INT 1
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: LIST
77147: PPUSH
77148: NOP4
77152: ST_TO_ADDR
// if not depot then
77153: NOP4
77157: NOT
77158: IFFALSE 77162
// continue ;
77160: GO 76980
// for j in depot do
77162: NOP4
77166: PUSH
77167: NOP4
77171: PUSH
77172: FOR_IN
77173: IFFALSE 77267
// if GetDistUnitXY ( j , x , y ) < 30 then
77175: NOP4
77179: PPUSH
77180: NOP4
77184: PPUSH
77185: NOP4
77189: PPUSH
77190: NOP4
77194: PUSH
77195: LD_INT 30
77197: LESS
77198: IFFALSE 77265
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77200: NOP4
77204: PUSH
77205: NOP4
77209: PPUSH
77210: NOP4
77214: PUSH
77215: NOP4
77219: PUSH
77220: NOP4
77224: ARRAY
77225: PUSH
77226: LD_INT 1
77228: PLUS
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PPUSH
77234: NOP4
77238: PUSH
77239: NOP4
77243: PUSH
77244: NOP4
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: LIST
77253: PPUSH
77254: NOP4
77258: ST_TO_ADDR
// exit ;
77259: POP
77260: POP
77261: POP
77262: POP
77263: GO 77273
// end ;
77265: GO 77172
77267: POP
77268: POP
// end ;
77269: GO 76980
77271: POP
77272: POP
// end ;
77273: LD_VAR 0 6
77277: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77278: LD_INT 0
77280: PPUSH
77281: PPUSH
77282: PPUSH
77283: PPUSH
// if not mc_bases or not skirmish then
77284: NOP4
77288: NOT
77289: PUSH
77290: NOP4
77294: NOT
77295: OR
77296: IFFALSE 77300
// exit ;
77298: GO 77577
// side := GetSide ( lab ) ;
77300: NOP4
77304: PUSH
77305: NOP4
77309: PPUSH
77310: NOP4
77314: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77315: NOP4
77319: PUSH
77320: NOP4
77324: IN
77325: NOT
77326: PUSH
77327: NOP4
77331: NOT
77332: OR
77333: PUSH
77334: NOP4
77338: NOT
77339: OR
77340: IFFALSE 77344
// exit ;
77342: GO 77577
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77344: NOP4
77348: PUSH
77349: NOP4
77353: PPUSH
77354: NOP4
77358: PPUSH
77359: NOP4
77363: PUSH
77364: NOP4
77368: ARRAY
77369: PUSH
77370: NOP4
77374: DIFF
77375: PPUSH
77376: NOP4
77380: ST_TO_ADDR
// for i = 1 to mc_bases do
77381: NOP4
77385: PUSH
77386: DOUBLE
77387: LD_INT 1
77389: DEC
77390: ST_TO_ADDR
77391: NOP4
77395: PUSH
77396: FOR_TO
77397: IFFALSE 77575
// begin if lab in mc_bases [ i ] then
77399: NOP4
77403: PUSH
77404: NOP4
77408: PUSH
77409: NOP4
77413: ARRAY
77414: IN
77415: IFFALSE 77573
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
77417: NOP4
77421: PUSH
77422: LD_INT 11
77424: PUSH
77425: LD_INT 4
77427: PUSH
77428: LD_INT 3
77430: PUSH
77431: LD_INT 2
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: LIST
77438: LIST
77439: IN
77440: PUSH
77441: NOP4
77445: PUSH
77446: NOP4
77450: ARRAY
77451: AND
77452: IFFALSE 77573
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
77454: NOP4
77458: PUSH
77459: NOP4
77463: PUSH
77464: NOP4
77468: ARRAY
77469: PUSH
77470: LD_INT 1
77472: ARRAY
77473: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77474: NOP4
77478: PUSH
77479: NOP4
77483: PPUSH
77484: NOP4
77488: PPUSH
77489: EMPTY
77490: PPUSH
77491: NOP4
77495: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77496: NOP4
77500: PPUSH
77501: LD_INT 0
77503: PPUSH
77504: NOP4
// ComExitBuilding ( tmp ) ;
77508: NOP4
77512: PPUSH
77513: NOP4
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77517: NOP4
77521: PUSH
77522: NOP4
77526: PPUSH
77527: NOP4
77531: PPUSH
77532: NOP4
77536: PUSH
77537: NOP4
77541: ARRAY
77542: PPUSH
77543: LD_INT 1
77545: PPUSH
77546: NOP4
77550: PPUSH
77551: NOP4
77555: PPUSH
77556: NOP4
77560: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77561: NOP4
77565: PPUSH
77566: LD_INT 112
77568: PPUSH
77569: NOP4
// end ; end ; end ;
77573: GO 77396
77575: POP
77576: POP
// end ;
77577: LD_VAR 0 3
77581: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77582: LD_INT 0
77584: PPUSH
77585: PPUSH
77586: PPUSH
77587: PPUSH
77588: PPUSH
77589: PPUSH
77590: PPUSH
77591: PPUSH
// if not mc_bases or not skirmish then
77592: NOP4
77596: NOT
77597: PUSH
77598: NOP4
77602: NOT
77603: OR
77604: IFFALSE 77608
// exit ;
77606: GO 78979
// for i = 1 to mc_bases do
77608: NOP4
77612: PUSH
77613: DOUBLE
77614: LD_INT 1
77616: DEC
77617: ST_TO_ADDR
77618: NOP4
77622: PUSH
77623: FOR_TO
77624: IFFALSE 78977
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77626: NOP4
77630: PUSH
77631: NOP4
77635: PUSH
77636: NOP4
77640: ARRAY
77641: IN
77642: PUSH
77643: NOP4
77647: PUSH
77648: NOP4
77652: PUSH
77653: NOP4
77657: ARRAY
77658: IN
77659: OR
77660: PUSH
77661: NOP4
77665: PUSH
77666: NOP4
77670: PUSH
77671: NOP4
77675: ARRAY
77676: IN
77677: OR
77678: PUSH
77679: NOP4
77683: PUSH
77684: NOP4
77688: PUSH
77689: NOP4
77693: ARRAY
77694: IN
77695: OR
77696: PUSH
77697: NOP4
77701: PUSH
77702: NOP4
77706: PUSH
77707: NOP4
77711: ARRAY
77712: IN
77713: OR
77714: PUSH
77715: NOP4
77719: PUSH
77720: NOP4
77724: PUSH
77725: NOP4
77729: ARRAY
77730: IN
77731: OR
77732: IFFALSE 78975
// begin if un in mc_ape [ i ] then
77734: NOP4
77738: PUSH
77739: NOP4
77743: PUSH
77744: NOP4
77748: ARRAY
77749: IN
77750: IFFALSE 77789
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77752: NOP4
77756: PUSH
77757: NOP4
77761: PPUSH
77762: NOP4
77766: PPUSH
77767: NOP4
77771: PUSH
77772: NOP4
77776: ARRAY
77777: PUSH
77778: NOP4
77782: DIFF
77783: PPUSH
77784: NOP4
77788: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77789: NOP4
77793: PUSH
77794: NOP4
77798: PUSH
77799: NOP4
77803: ARRAY
77804: IN
77805: IFFALSE 77829
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77807: NOP4
77811: PUSH
77812: NOP4
77816: PPUSH
77817: NOP4
77821: PPUSH
77822: EMPTY
77823: PPUSH
77824: NOP4
77828: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77829: NOP4
77833: PPUSH
77834: NOP4
77838: PUSH
77839: LD_INT 2
77841: EQUAL
77842: PUSH
77843: NOP4
77847: PPUSH
77848: NOP4
77852: PUSH
77853: LD_INT 20
77855: EQUAL
77856: PUSH
77857: NOP4
77861: PUSH
77862: NOP4
77866: PUSH
77867: NOP4
77871: ARRAY
77872: IN
77873: OR
77874: PUSH
77875: NOP4
77879: PPUSH
77880: NOP4
77884: PUSH
77885: LD_INT 12
77887: PUSH
77888: LD_INT 51
77890: PUSH
77891: NOP4
77895: PUSH
77896: LD_INT 32
77898: PUSH
77899: LD_INT 13
77901: PUSH
77902: LD_INT 52
77904: PUSH
77905: LD_INT 31
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: LIST
77912: LIST
77913: LIST
77914: LIST
77915: LIST
77916: IN
77917: OR
77918: AND
77919: IFFALSE 78227
// begin if un in mc_defender [ i ] then
77921: NOP4
77925: PUSH
77926: NOP4
77930: PUSH
77931: NOP4
77935: ARRAY
77936: IN
77937: IFFALSE 77976
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77939: NOP4
77943: PUSH
77944: NOP4
77948: PPUSH
77949: NOP4
77953: PPUSH
77954: NOP4
77958: PUSH
77959: NOP4
77963: ARRAY
77964: PUSH
77965: NOP4
77969: DIFF
77970: PPUSH
77971: NOP4
77975: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
77976: NOP4
77980: PUSH
77981: NOP4
77985: PPUSH
77986: LD_INT 3
77988: PPUSH
77989: NOP4
77993: ST_TO_ADDR
// if fac then
77994: NOP4
77998: IFFALSE 78227
// begin for j in fac do
78000: NOP4
78004: PUSH
78005: NOP4
78009: PUSH
78010: FOR_IN
78011: IFFALSE 78225
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78013: NOP4
78017: PUSH
78018: NOP4
78022: PPUSH
78023: NOP4
78027: PPUSH
78028: NOP4
78032: PPUSH
78033: NOP4
78037: PPUSH
78038: NOP4
78042: PPUSH
78043: NOP4
78047: PPUSH
78048: NOP4
78052: PPUSH
78053: NOP4
78057: PPUSH
78058: NOP4
78062: PPUSH
78063: NOP4
78067: ST_TO_ADDR
// if components then
78068: NOP4
78072: IFFALSE 78223
// begin if GetWeapon ( un ) = ar_control_tower then
78074: NOP4
78078: PPUSH
78079: NOP4
78083: PUSH
78084: LD_INT 31
78086: EQUAL
78087: IFFALSE 78204
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
78089: NOP4
78093: PPUSH
78094: NOP4
78098: PPUSH
78099: LD_INT 0
78101: PPUSH
78102: NOP4
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78106: NOP4
78110: PUSH
78111: NOP4
78115: PPUSH
78116: NOP4
78120: PPUSH
78121: NOP4
78125: PUSH
78126: NOP4
78130: ARRAY
78131: PUSH
78132: NOP4
78136: PPUSH
78137: NOP4
78141: DIFF
78142: PPUSH
78143: NOP4
78147: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78148: NOP4
78152: PUSH
78153: NOP4
78157: PUSH
78158: NOP4
78162: ARRAY
78163: PPUSH
78164: LD_INT 1
78166: PPUSH
78167: NOP4
78171: PPUSH
78172: NOP4
78176: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78177: NOP4
78181: PUSH
78182: NOP4
78186: PPUSH
78187: NOP4
78191: PPUSH
78192: NOP4
78196: PPUSH
78197: NOP4
78201: ST_TO_ADDR
// end else
78202: GO 78221
// MC_InsertProduceList ( i , [ components ] ) ;
78204: NOP4
78208: PPUSH
78209: NOP4
78213: PUSH
78214: EMPTY
78215: LIST
78216: PPUSH
78217: NOP4
// break ;
78221: GO 78225
// end ; end ;
78223: GO 78010
78225: POP
78226: POP
// end ; end ; if GetType ( un ) = unit_building then
78227: NOP4
78231: PPUSH
78232: NOP4
78236: PUSH
78237: LD_INT 3
78239: EQUAL
78240: IFFALSE 78643
// begin btype := GetBType ( un ) ;
78242: NOP4
78246: PUSH
78247: NOP4
78251: PPUSH
78252: NOP4
78256: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78257: NOP4
78261: PUSH
78262: LD_INT 29
78264: PUSH
78265: LD_INT 30
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: IN
78272: IFFALSE 78345
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78274: NOP4
78278: PPUSH
78279: NOP4
78283: PPUSH
78284: NOP4
78288: PPUSH
78289: NOP4
78293: PPUSH
78294: NOP4
78298: PPUSH
78299: NOP4
78303: PPUSH
78304: NOP4
78308: NOT
78309: IFFALSE 78345
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78311: NOP4
78315: PPUSH
78316: NOP4
78320: PPUSH
78321: NOP4
78325: PPUSH
78326: NOP4
78330: PPUSH
78331: NOP4
78335: PPUSH
78336: NOP4
78340: PPUSH
78341: NOP4
// end ; if btype = b_warehouse then
78345: NOP4
78349: PUSH
78350: LD_INT 1
78352: EQUAL
78353: IFFALSE 78371
// begin btype := b_depot ;
78355: NOP4
78359: PUSH
78360: LD_INT 0
78362: ST_TO_ADDR
// pos := 1 ;
78363: NOP4
78367: PUSH
78368: LD_INT 1
78370: ST_TO_ADDR
// end ; if btype = b_factory then
78371: NOP4
78375: PUSH
78376: LD_INT 3
78378: EQUAL
78379: IFFALSE 78397
// begin btype := b_workshop ;
78381: NOP4
78385: PUSH
78386: LD_INT 2
78388: ST_TO_ADDR
// pos := 1 ;
78389: NOP4
78393: PUSH
78394: LD_INT 1
78396: ST_TO_ADDR
// end ; if btype = b_barracks then
78397: NOP4
78401: PUSH
78402: LD_INT 5
78404: EQUAL
78405: IFFALSE 78415
// btype := b_armoury ;
78407: NOP4
78411: PUSH
78412: LD_INT 4
78414: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
78415: NOP4
78419: PUSH
78420: LD_INT 7
78422: PUSH
78423: LD_INT 8
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: IN
78430: IFFALSE 78440
// btype := b_lab ;
78432: NOP4
78436: PUSH
78437: LD_INT 6
78439: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
78440: NOP4
78444: PUSH
78445: NOP4
78449: PPUSH
78450: NOP4
78454: PUSH
78455: NOP4
78459: PUSH
78460: NOP4
78464: ARRAY
78465: PUSH
78466: LD_INT 1
78468: PLUS
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: PPUSH
78474: NOP4
78478: PUSH
78479: NOP4
78483: PPUSH
78484: NOP4
78488: PUSH
78489: NOP4
78493: PPUSH
78494: NOP4
78498: PUSH
78499: NOP4
78503: PPUSH
78504: NOP4
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: LIST
78513: LIST
78514: PPUSH
78515: NOP4
78519: ST_TO_ADDR
// if pos = 1 then
78520: NOP4
78524: PUSH
78525: LD_INT 1
78527: EQUAL
78528: IFFALSE 78643
// begin tmp := mc_build_list [ i ] ;
78530: NOP4
78534: PUSH
78535: NOP4
78539: PUSH
78540: NOP4
78544: ARRAY
78545: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78546: NOP4
78550: PPUSH
78551: LD_INT 2
78553: PUSH
78554: LD_INT 30
78556: PUSH
78557: LD_INT 0
78559: PUSH
78560: EMPTY
78561: LIST
78562: LIST
78563: PUSH
78564: LD_INT 30
78566: PUSH
78567: LD_INT 1
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: LIST
78578: PPUSH
78579: NOP4
78583: IFFALSE 78593
// pos := 2 ;
78585: NOP4
78589: PUSH
78590: LD_INT 2
78592: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78593: NOP4
78597: PUSH
78598: NOP4
78602: PPUSH
78603: NOP4
78607: PPUSH
78608: NOP4
78612: PPUSH
78613: NOP4
78617: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78618: NOP4
78622: PUSH
78623: NOP4
78627: PPUSH
78628: NOP4
78632: PPUSH
78633: NOP4
78637: PPUSH
78638: NOP4
78642: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78643: NOP4
78647: PUSH
78648: NOP4
78652: PUSH
78653: NOP4
78657: ARRAY
78658: IN
78659: IFFALSE 78698
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78661: NOP4
78665: PUSH
78666: NOP4
78670: PPUSH
78671: NOP4
78675: PPUSH
78676: NOP4
78680: PUSH
78681: NOP4
78685: ARRAY
78686: PUSH
78687: NOP4
78691: DIFF
78692: PPUSH
78693: NOP4
78697: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78698: NOP4
78702: PUSH
78703: NOP4
78707: PUSH
78708: NOP4
78712: ARRAY
78713: IN
78714: IFFALSE 78753
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78716: NOP4
78720: PUSH
78721: NOP4
78725: PPUSH
78726: NOP4
78730: PPUSH
78731: NOP4
78735: PUSH
78736: NOP4
78740: ARRAY
78741: PUSH
78742: NOP4
78746: DIFF
78747: PPUSH
78748: NOP4
78752: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78753: NOP4
78757: PUSH
78758: NOP4
78762: PUSH
78763: NOP4
78767: ARRAY
78768: IN
78769: IFFALSE 78808
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78771: NOP4
78775: PUSH
78776: NOP4
78780: PPUSH
78781: NOP4
78785: PPUSH
78786: NOP4
78790: PUSH
78791: NOP4
78795: ARRAY
78796: PUSH
78797: NOP4
78801: DIFF
78802: PPUSH
78803: NOP4
78807: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78808: NOP4
78812: PUSH
78813: NOP4
78817: PUSH
78818: NOP4
78822: ARRAY
78823: IN
78824: IFFALSE 78863
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78826: NOP4
78830: PUSH
78831: NOP4
78835: PPUSH
78836: NOP4
78840: PPUSH
78841: NOP4
78845: PUSH
78846: NOP4
78850: ARRAY
78851: PUSH
78852: NOP4
78856: DIFF
78857: PPUSH
78858: NOP4
78862: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78863: NOP4
78867: PUSH
78868: NOP4
78872: PUSH
78873: NOP4
78877: ARRAY
78878: IN
78879: IFFALSE 78918
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78881: NOP4
78885: PUSH
78886: NOP4
78890: PPUSH
78891: NOP4
78895: PPUSH
78896: NOP4
78900: PUSH
78901: NOP4
78905: ARRAY
78906: PUSH
78907: NOP4
78911: DIFF
78912: PPUSH
78913: NOP4
78917: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78918: NOP4
78922: PUSH
78923: NOP4
78927: PUSH
78928: NOP4
78932: ARRAY
78933: IN
78934: IFFALSE 78973
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78936: NOP4
78940: PUSH
78941: NOP4
78945: PPUSH
78946: NOP4
78950: PPUSH
78951: NOP4
78955: PUSH
78956: NOP4
78960: ARRAY
78961: PUSH
78962: NOP4
78966: DIFF
78967: PPUSH
78968: NOP4
78972: ST_TO_ADDR
// end ; break ;
78973: GO 78977
// end ;
78975: GO 77623
78977: POP
78978: POP
// end ;
78979: LD_VAR 0 2
78983: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
78984: LD_INT 0
78986: PPUSH
78987: PPUSH
78988: PPUSH
// if not mc_bases or not skirmish then
78989: NOP4
78993: NOT
78994: PUSH
78995: NOP4
78999: NOT
79000: OR
79001: IFFALSE 79005
// exit ;
79003: GO 79220
// for i = 1 to mc_bases do
79005: NOP4
79009: PUSH
79010: DOUBLE
79011: LD_INT 1
79013: DEC
79014: ST_TO_ADDR
79015: NOP4
79019: PUSH
79020: FOR_TO
79021: IFFALSE 79218
// begin if building in mc_construct_list [ i ] then
79023: NOP4
79027: PUSH
79028: NOP4
79032: PUSH
79033: NOP4
79037: ARRAY
79038: IN
79039: IFFALSE 79216
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79041: NOP4
79045: PUSH
79046: NOP4
79050: PPUSH
79051: NOP4
79055: PPUSH
79056: NOP4
79060: PUSH
79061: NOP4
79065: ARRAY
79066: PUSH
79067: NOP4
79071: DIFF
79072: PPUSH
79073: NOP4
79077: ST_TO_ADDR
// if building in mc_lab [ i ] then
79078: NOP4
79082: PUSH
79083: NOP4
79087: PUSH
79088: NOP4
79092: ARRAY
79093: IN
79094: IFFALSE 79149
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79096: NOP4
79100: PUSH
79101: NOP4
79105: PPUSH
79106: NOP4
79110: PPUSH
79111: NOP4
79115: PUSH
79116: NOP4
79120: ARRAY
79121: PPUSH
79122: LD_INT 1
79124: PPUSH
79125: NOP4
79129: PUSH
79130: NOP4
79134: ARRAY
79135: PPUSH
79136: LD_INT 0
79138: PPUSH
79139: NOP4
79143: PPUSH
79144: NOP4
79148: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79149: NOP4
79153: PUSH
79154: NOP4
79158: PUSH
79159: NOP4
79163: ARRAY
79164: IN
79165: NOT
79166: IFFALSE 79212
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79168: NOP4
79172: PUSH
79173: NOP4
79177: PPUSH
79178: NOP4
79182: PUSH
79183: NOP4
79187: PUSH
79188: NOP4
79192: ARRAY
79193: PUSH
79194: LD_INT 1
79196: PLUS
79197: PUSH
79198: EMPTY
79199: LIST
79200: LIST
79201: PPUSH
79202: NOP4
79206: PPUSH
79207: NOP4
79211: ST_TO_ADDR
// exit ;
79212: POP
79213: POP
79214: GO 79220
// end ; end ;
79216: GO 79020
79218: POP
79219: POP
// end ;
79220: LD_VAR 0 2
79224: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79225: LD_INT 0
79227: PPUSH
79228: PPUSH
79229: PPUSH
79230: PPUSH
79231: PPUSH
79232: PPUSH
79233: PPUSH
// if not mc_bases or not skirmish then
79234: NOP4
79238: NOT
79239: PUSH
79240: NOP4
79244: NOT
79245: OR
79246: IFFALSE 79250
// exit ;
79248: GO 79911
// for i = 1 to mc_bases do
79250: NOP4
79254: PUSH
79255: DOUBLE
79256: LD_INT 1
79258: DEC
79259: ST_TO_ADDR
79260: NOP4
79264: PUSH
79265: FOR_TO
79266: IFFALSE 79909
// begin if building in mc_construct_list [ i ] then
79268: NOP4
79272: PUSH
79273: NOP4
79277: PUSH
79278: NOP4
79282: ARRAY
79283: IN
79284: IFFALSE 79907
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79286: NOP4
79290: PUSH
79291: NOP4
79295: PPUSH
79296: NOP4
79300: PPUSH
79301: NOP4
79305: PUSH
79306: NOP4
79310: ARRAY
79311: PUSH
79312: NOP4
79316: DIFF
79317: PPUSH
79318: NOP4
79322: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79323: NOP4
79327: PUSH
79328: NOP4
79332: PPUSH
79333: NOP4
79337: PUSH
79338: NOP4
79342: PUSH
79343: NOP4
79347: ARRAY
79348: PUSH
79349: LD_INT 1
79351: PLUS
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PPUSH
79357: NOP4
79361: PPUSH
79362: NOP4
79366: ST_TO_ADDR
// btype := GetBType ( building ) ;
79367: NOP4
79371: PUSH
79372: NOP4
79376: PPUSH
79377: NOP4
79381: ST_TO_ADDR
// side := GetSide ( building ) ;
79382: NOP4
79386: PUSH
79387: NOP4
79391: PPUSH
79392: NOP4
79396: ST_TO_ADDR
// if btype = b_lab then
79397: NOP4
79401: PUSH
79402: LD_INT 6
79404: EQUAL
79405: IFFALSE 79455
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
79407: NOP4
79411: PUSH
79412: NOP4
79416: PPUSH
79417: NOP4
79421: PUSH
79422: NOP4
79426: PUSH
79427: NOP4
79431: ARRAY
79432: PUSH
79433: LD_INT 1
79435: PLUS
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PPUSH
79441: NOP4
79445: PPUSH
79446: NOP4
79450: ST_TO_ADDR
// exit ;
79451: POP
79452: POP
79453: GO 79911
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
79455: NOP4
79459: PUSH
79460: LD_INT 0
79462: PUSH
79463: LD_INT 2
79465: PUSH
79466: LD_INT 4
79468: PUSH
79469: EMPTY
79470: LIST
79471: LIST
79472: LIST
79473: IN
79474: IFFALSE 79598
// begin if btype = b_armoury then
79476: NOP4
79480: PUSH
79481: LD_INT 4
79483: EQUAL
79484: IFFALSE 79494
// btype := b_barracks ;
79486: NOP4
79490: PUSH
79491: LD_INT 5
79493: ST_TO_ADDR
// if btype = b_depot then
79494: NOP4
79498: PUSH
79499: LD_INT 0
79501: EQUAL
79502: IFFALSE 79512
// btype := b_warehouse ;
79504: NOP4
79508: PUSH
79509: LD_INT 1
79511: ST_TO_ADDR
// if btype = b_workshop then
79512: NOP4
79516: PUSH
79517: LD_INT 2
79519: EQUAL
79520: IFFALSE 79530
// btype := b_factory ;
79522: NOP4
79526: PUSH
79527: LD_INT 3
79529: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79530: NOP4
79534: PPUSH
79535: NOP4
79539: PPUSH
79540: NOP4
79544: PUSH
79545: LD_INT 1
79547: EQUAL
79548: IFFALSE 79594
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79550: NOP4
79554: PUSH
79555: NOP4
79559: PPUSH
79560: NOP4
79564: PUSH
79565: NOP4
79569: PUSH
79570: NOP4
79574: ARRAY
79575: PUSH
79576: LD_INT 1
79578: PLUS
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PPUSH
79584: NOP4
79588: PPUSH
79589: NOP4
79593: ST_TO_ADDR
// exit ;
79594: POP
79595: POP
79596: GO 79911
// end ; if btype in [ b_bunker , b_turret ] then
79598: NOP4
79602: PUSH
79603: LD_INT 32
79605: PUSH
79606: LD_INT 33
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: IN
79613: IFFALSE 79903
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79615: NOP4
79619: PUSH
79620: NOP4
79624: PPUSH
79625: NOP4
79629: PUSH
79630: NOP4
79634: PUSH
79635: NOP4
79639: ARRAY
79640: PUSH
79641: LD_INT 1
79643: PLUS
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PPUSH
79649: NOP4
79653: PPUSH
79654: NOP4
79658: ST_TO_ADDR
// if btype = b_bunker then
79659: NOP4
79663: PUSH
79664: LD_INT 32
79666: EQUAL
79667: IFFALSE 79903
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79669: NOP4
79673: PUSH
79674: NOP4
79678: PPUSH
79679: NOP4
79683: PUSH
79684: NOP4
79688: PUSH
79689: NOP4
79693: ARRAY
79694: PUSH
79695: LD_INT 1
79697: PLUS
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PPUSH
79703: NOP4
79707: PPUSH
79708: NOP4
79712: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79713: NOP4
79717: PUSH
79718: NOP4
79722: PUSH
79723: NOP4
79727: ARRAY
79728: PPUSH
79729: LD_INT 25
79731: PUSH
79732: LD_INT 1
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 3
79741: PUSH
79742: LD_INT 54
79744: PUSH
79745: EMPTY
79746: LIST
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: PUSH
79752: EMPTY
79753: LIST
79754: LIST
79755: PPUSH
79756: NOP4
79760: ST_TO_ADDR
// if tmp then
79761: NOP4
79765: IFFALSE 79771
// exit ;
79767: POP
79768: POP
79769: GO 79911
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79771: NOP4
79775: PUSH
79776: NOP4
79780: PUSH
79781: NOP4
79785: ARRAY
79786: PPUSH
79787: LD_INT 2
79789: PUSH
79790: LD_INT 30
79792: PUSH
79793: LD_INT 4
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 30
79802: PUSH
79803: LD_INT 5
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: LIST
79814: PPUSH
79815: NOP4
79819: ST_TO_ADDR
// if not tmp then
79820: NOP4
79824: NOT
79825: IFFALSE 79831
// exit ;
79827: POP
79828: POP
79829: GO 79911
// for j in tmp do
79831: NOP4
79835: PUSH
79836: NOP4
79840: PUSH
79841: FOR_IN
79842: IFFALSE 79901
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79844: NOP4
79848: PUSH
79849: NOP4
79853: PPUSH
79854: NOP4
79858: PPUSH
79859: LD_INT 25
79861: PUSH
79862: LD_INT 1
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PPUSH
79869: NOP4
79873: ST_TO_ADDR
// if units then
79874: NOP4
79878: IFFALSE 79899
// begin ComExitBuilding ( units [ 1 ] ) ;
79880: NOP4
79884: PUSH
79885: LD_INT 1
79887: ARRAY
79888: PPUSH
79889: NOP4
// exit ;
79893: POP
79894: POP
79895: POP
79896: POP
79897: GO 79911
// end ; end ;
79899: GO 79841
79901: POP
79902: POP
// end ; end ; exit ;
79903: POP
79904: POP
79905: GO 79911
// end ; end ;
79907: GO 79265
79909: POP
79910: POP
// end ;
79911: LD_VAR 0 2
79915: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79916: LD_INT 0
79918: PPUSH
79919: PPUSH
79920: PPUSH
79921: PPUSH
79922: PPUSH
79923: PPUSH
79924: PPUSH
// if not mc_bases or not skirmish then
79925: NOP4
79929: NOT
79930: PUSH
79931: NOP4
79935: NOT
79936: OR
79937: IFFALSE 79941
// exit ;
79939: GO 80206
// btype := GetBType ( building ) ;
79941: NOP4
79945: PUSH
79946: NOP4
79950: PPUSH
79951: NOP4
79955: ST_TO_ADDR
// x := GetX ( building ) ;
79956: NOP4
79960: PUSH
79961: NOP4
79965: PPUSH
79966: NOP4
79970: ST_TO_ADDR
// y := GetY ( building ) ;
79971: NOP4
79975: PUSH
79976: NOP4
79980: PPUSH
79981: NOP4
79985: ST_TO_ADDR
// d := GetDir ( building ) ;
79986: NOP4
79990: PUSH
79991: NOP4
79995: PPUSH
79996: NOP4
80000: ST_TO_ADDR
// for i = 1 to mc_bases do
80001: NOP4
80005: PUSH
80006: DOUBLE
80007: LD_INT 1
80009: DEC
80010: ST_TO_ADDR
80011: NOP4
80015: PUSH
80016: FOR_TO
80017: IFFALSE 80204
// begin if not mc_build_list [ i ] then
80019: NOP4
80023: PUSH
80024: NOP4
80028: ARRAY
80029: NOT
80030: IFFALSE 80034
// continue ;
80032: GO 80016
// for j := 1 to mc_build_list [ i ] do
80034: NOP4
80038: PUSH
80039: DOUBLE
80040: LD_INT 1
80042: DEC
80043: ST_TO_ADDR
80044: NOP4
80048: PUSH
80049: NOP4
80053: ARRAY
80054: PUSH
80055: FOR_TO
80056: IFFALSE 80200
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
80058: NOP4
80062: PUSH
80063: NOP4
80067: PUSH
80068: NOP4
80072: PUSH
80073: NOP4
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: PPUSH
80084: NOP4
80088: PUSH
80089: NOP4
80093: ARRAY
80094: PUSH
80095: NOP4
80099: ARRAY
80100: PPUSH
80101: NOP4
80105: IFFALSE 80198
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
80107: NOP4
80111: PUSH
80112: NOP4
80116: PPUSH
80117: NOP4
80121: PPUSH
80122: NOP4
80126: PUSH
80127: NOP4
80131: ARRAY
80132: PPUSH
80133: NOP4
80137: PPUSH
80138: NOP4
80142: PPUSH
80143: NOP4
80147: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80148: NOP4
80152: PUSH
80153: NOP4
80157: PPUSH
80158: NOP4
80162: PUSH
80163: NOP4
80167: PUSH
80168: NOP4
80172: ARRAY
80173: PUSH
80174: LD_INT 1
80176: PLUS
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PPUSH
80182: NOP4
80186: PPUSH
80187: NOP4
80191: ST_TO_ADDR
// exit ;
80192: POP
80193: POP
80194: POP
80195: POP
80196: GO 80206
// end ;
80198: GO 80055
80200: POP
80201: POP
// end ;
80202: GO 80016
80204: POP
80205: POP
// end ;
80206: LD_VAR 0 3
80210: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80211: LD_INT 0
80213: PPUSH
80214: PPUSH
80215: PPUSH
// if not mc_bases or not skirmish then
80216: NOP4
80220: NOT
80221: PUSH
80222: NOP4
80226: NOT
80227: OR
80228: IFFALSE 80232
// exit ;
80230: GO 80422
// for i = 1 to mc_bases do
80232: NOP4
80236: PUSH
80237: DOUBLE
80238: LD_INT 1
80240: DEC
80241: ST_TO_ADDR
80242: NOP4
80246: PUSH
80247: FOR_TO
80248: IFFALSE 80335
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80250: NOP4
80254: PUSH
80255: NOP4
80259: PUSH
80260: NOP4
80264: ARRAY
80265: IN
80266: PUSH
80267: NOP4
80271: PUSH
80272: NOP4
80276: PUSH
80277: NOP4
80281: ARRAY
80282: IN
80283: NOT
80284: AND
80285: IFFALSE 80333
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80287: NOP4
80291: PUSH
80292: NOP4
80296: PPUSH
80297: NOP4
80301: PUSH
80302: NOP4
80306: PUSH
80307: NOP4
80311: ARRAY
80312: PUSH
80313: LD_INT 1
80315: PLUS
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PPUSH
80321: NOP4
80325: PPUSH
80326: NOP4
80330: ST_TO_ADDR
// break ;
80331: GO 80335
// end ; end ;
80333: GO 80247
80335: POP
80336: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80337: NOP4
80341: PPUSH
80342: NOP4
80346: PUSH
80347: NOP4
80351: IN
80352: PUSH
80353: NOP4
80357: PPUSH
80358: NOP4
80362: PUSH
80363: LD_INT 5
80365: EQUAL
80366: AND
80367: PUSH
80368: NOP4
80372: PPUSH
80373: NOP4
80377: PUSH
80378: LD_INT 18
80380: NONEQUAL
80381: AND
80382: IFFALSE 80422
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80384: NOP4
80388: PPUSH
80389: NOP4
80393: PUSH
80394: LD_INT 5
80396: PUSH
80397: LD_INT 8
80399: PUSH
80400: LD_INT 9
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: LIST
80407: IN
80408: IFFALSE 80422
// SetClass ( unit , 1 ) ;
80410: NOP4
80414: PPUSH
80415: LD_INT 1
80417: PPUSH
80418: NOP4
// end ;
80422: LD_VAR 0 3
80426: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80427: LD_INT 0
80429: PPUSH
80430: PPUSH
// if not mc_bases or not skirmish then
80431: NOP4
80435: NOT
80436: PUSH
80437: NOP4
80441: NOT
80442: OR
80443: IFFALSE 80447
// exit ;
80445: GO 80563
// if GetLives ( abandoned_vehicle ) > 250 then
80447: NOP4
80451: PPUSH
80452: NOP4
80456: PUSH
80457: LD_INT 250
80459: GREATER
80460: IFFALSE 80464
// exit ;
80462: GO 80563
// for i = 1 to mc_bases do
80464: NOP4
80468: PUSH
80469: DOUBLE
80470: LD_INT 1
80472: DEC
80473: ST_TO_ADDR
80474: NOP4
80478: PUSH
80479: FOR_TO
80480: IFFALSE 80561
// begin if driver in mc_bases [ i ] then
80482: NOP4
80486: PUSH
80487: NOP4
80491: PUSH
80492: NOP4
80496: ARRAY
80497: IN
80498: IFFALSE 80559
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80500: NOP4
80504: PPUSH
80505: NOP4
80509: PUSH
80510: NOP4
80514: ARRAY
80515: PPUSH
80516: LD_INT 2
80518: PUSH
80519: LD_INT 30
80521: PUSH
80522: LD_INT 0
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: LD_INT 30
80531: PUSH
80532: LD_INT 1
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: EMPTY
80540: LIST
80541: LIST
80542: LIST
80543: PPUSH
80544: NOP4
80548: PUSH
80549: LD_INT 1
80551: ARRAY
80552: PPUSH
80553: NOP4
// break ;
80557: GO 80561
// end ; end ;
80559: GO 80479
80561: POP
80562: POP
// end ; end_of_file
80563: LD_VAR 0 5
80567: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
80568: LD_INT 0
80570: PPUSH
// ar_miner := 81 ;
80571: NOP4
80575: PUSH
80576: LD_INT 81
80578: ST_TO_ADDR
// ar_crane := 88 ;
80579: NOP4
80583: PUSH
80584: LD_INT 88
80586: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80587: NOP4
80591: PUSH
80592: LD_INT 89
80594: ST_TO_ADDR
// us_hack := 99 ;
80595: NOP4
80599: PUSH
80600: LD_INT 99
80602: ST_TO_ADDR
// us_artillery := 97 ;
80603: NOP4
80607: PUSH
80608: LD_INT 97
80610: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80611: NOP4
80615: PUSH
80616: LD_INT 91
80618: ST_TO_ADDR
// ar_mortar := 92 ;
80619: NOP4
80623: PUSH
80624: LD_INT 92
80626: ST_TO_ADDR
// ru_radar := 98 ;
80627: NOP4
80631: PUSH
80632: LD_INT 98
80634: ST_TO_ADDR
// tech_Artillery := 80 ;
80635: NOP4
80639: PUSH
80640: LD_INT 80
80642: ST_TO_ADDR
// tech_RadMat := 81 ;
80643: NOP4
80647: PUSH
80648: LD_INT 81
80650: ST_TO_ADDR
// tech_BasicTools := 82 ;
80651: NOP4
80655: PUSH
80656: LD_INT 82
80658: ST_TO_ADDR
// tech_Cargo := 83 ;
80659: NOP4
80663: PUSH
80664: LD_INT 83
80666: ST_TO_ADDR
// tech_Track := 84 ;
80667: NOP4
80671: PUSH
80672: LD_INT 84
80674: ST_TO_ADDR
// tech_Crane := 85 ;
80675: NOP4
80679: PUSH
80680: LD_INT 85
80682: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80683: NOP4
80687: PUSH
80688: LD_INT 86
80690: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80691: NOP4
80695: PUSH
80696: LD_INT 87
80698: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
80699: NOP4
80703: PUSH
80704: LD_INT 88
80706: ST_TO_ADDR
// class_mastodont := 31 ;
80707: NOP4
80711: PUSH
80712: LD_INT 31
80714: ST_TO_ADDR
// class_horse := 21 ;
80715: NOP4
80719: PUSH
80720: LD_INT 21
80722: ST_TO_ADDR
// end ;
80723: LD_VAR 0 1
80727: RET
// every 1 do
80728: GO 80730
80730: DISABLE
// InitGlobalVariables ; end_of_file
80731: NOP4
80735: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
80736: LD_INT 0
80738: PPUSH
80739: PPUSH
80740: PPUSH
80741: PPUSH
80742: PPUSH
80743: PPUSH
80744: PPUSH
80745: PPUSH
80746: PPUSH
80747: PPUSH
80748: PPUSH
80749: PPUSH
80750: PPUSH
80751: PPUSH
80752: PPUSH
80753: PPUSH
80754: PPUSH
80755: PPUSH
80756: PPUSH
80757: PPUSH
80758: PPUSH
80759: PPUSH
80760: PPUSH
80761: PPUSH
80762: PPUSH
80763: PPUSH
80764: PPUSH
80765: PPUSH
80766: PPUSH
80767: PPUSH
80768: PPUSH
80769: PPUSH
80770: PPUSH
80771: PPUSH
// if not list then
80772: NOP4
80776: NOT
80777: IFFALSE 80781
// exit ;
80779: GO 85440
// base := list [ 1 ] ;
80781: NOP4
80785: PUSH
80786: NOP4
80790: PUSH
80791: LD_INT 1
80793: ARRAY
80794: ST_TO_ADDR
// group := list [ 2 ] ;
80795: NOP4
80799: PUSH
80800: NOP4
80804: PUSH
80805: LD_INT 2
80807: ARRAY
80808: ST_TO_ADDR
// path := list [ 3 ] ;
80809: NOP4
80813: PUSH
80814: NOP4
80818: PUSH
80819: LD_INT 3
80821: ARRAY
80822: ST_TO_ADDR
// flags := list [ 4 ] ;
80823: NOP4
80827: PUSH
80828: NOP4
80832: PUSH
80833: LD_INT 4
80835: ARRAY
80836: ST_TO_ADDR
// mined := [ ] ;
80837: NOP4
80841: PUSH
80842: EMPTY
80843: ST_TO_ADDR
// bombed := [ ] ;
80844: NOP4
80848: PUSH
80849: EMPTY
80850: ST_TO_ADDR
// healers := [ ] ;
80851: NOP4
80855: PUSH
80856: EMPTY
80857: ST_TO_ADDR
// to_heal := [ ] ;
80858: NOP4
80862: PUSH
80863: EMPTY
80864: ST_TO_ADDR
// repairs := [ ] ;
80865: NOP4
80869: PUSH
80870: EMPTY
80871: ST_TO_ADDR
// to_repair := [ ] ;
80872: NOP4
80876: PUSH
80877: EMPTY
80878: ST_TO_ADDR
// if not group or not path then
80879: NOP4
80883: NOT
80884: PUSH
80885: NOP4
80889: NOT
80890: OR
80891: IFFALSE 80895
// exit ;
80893: GO 85440
// side := GetSide ( group [ 1 ] ) ;
80895: NOP4
80899: PUSH
80900: NOP4
80904: PUSH
80905: LD_INT 1
80907: ARRAY
80908: PPUSH
80909: NOP4
80913: ST_TO_ADDR
// if flags then
80914: NOP4
80918: IFFALSE 81062
// begin f_ignore_area := flags [ 1 ] ;
80920: NOP4
80924: PUSH
80925: NOP4
80929: PUSH
80930: LD_INT 1
80932: ARRAY
80933: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
80934: NOP4
80938: PUSH
80939: NOP4
80943: PUSH
80944: LD_INT 2
80946: ARRAY
80947: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
80948: NOP4
80952: PUSH
80953: NOP4
80957: PUSH
80958: LD_INT 3
80960: ARRAY
80961: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
80962: NOP4
80966: PUSH
80967: NOP4
80971: PUSH
80972: LD_INT 4
80974: ARRAY
80975: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
80976: NOP4
80980: PUSH
80981: NOP4
80985: PUSH
80986: LD_INT 5
80988: ARRAY
80989: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
80990: NOP4
80994: PUSH
80995: NOP4
80999: PUSH
81000: LD_INT 6
81002: ARRAY
81003: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
81004: NOP4
81008: PUSH
81009: NOP4
81013: PUSH
81014: LD_INT 7
81016: ARRAY
81017: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
81018: NOP4
81022: PUSH
81023: NOP4
81027: PUSH
81028: LD_INT 8
81030: ARRAY
81031: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
81032: NOP4
81036: PUSH
81037: NOP4
81041: PUSH
81042: LD_INT 9
81044: ARRAY
81045: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
81046: NOP4
81050: PUSH
81051: NOP4
81055: PUSH
81056: LD_INT 10
81058: ARRAY
81059: ST_TO_ADDR
// end else
81060: GO 81142
// begin f_ignore_area := false ;
81062: NOP4
81066: PUSH
81067: LD_INT 0
81069: ST_TO_ADDR
// f_capture := false ;
81070: NOP4
81074: PUSH
81075: LD_INT 0
81077: ST_TO_ADDR
// f_ignore_civ := false ;
81078: NOP4
81082: PUSH
81083: LD_INT 0
81085: ST_TO_ADDR
// f_murder := false ;
81086: NOP4
81090: PUSH
81091: LD_INT 0
81093: ST_TO_ADDR
// f_mines := false ;
81094: NOP4
81098: PUSH
81099: LD_INT 0
81101: ST_TO_ADDR
// f_repair := false ;
81102: NOP4
81106: PUSH
81107: LD_INT 0
81109: ST_TO_ADDR
// f_heal := false ;
81110: NOP4
81114: PUSH
81115: LD_INT 0
81117: ST_TO_ADDR
// f_spacetime := false ;
81118: NOP4
81122: PUSH
81123: LD_INT 0
81125: ST_TO_ADDR
// f_attack_depot := false ;
81126: NOP4
81130: PUSH
81131: LD_INT 0
81133: ST_TO_ADDR
// f_crawl := false ;
81134: NOP4
81138: PUSH
81139: LD_INT 0
81141: ST_TO_ADDR
// end ; if f_heal then
81142: NOP4
81146: IFFALSE 81173
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
81148: NOP4
81152: PUSH
81153: NOP4
81157: PPUSH
81158: LD_INT 25
81160: PUSH
81161: LD_INT 4
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PPUSH
81168: NOP4
81172: ST_TO_ADDR
// if f_repair then
81173: NOP4
81177: IFFALSE 81204
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
81179: NOP4
81183: PUSH
81184: NOP4
81188: PPUSH
81189: LD_INT 25
81191: PUSH
81192: LD_INT 3
81194: PUSH
81195: EMPTY
81196: LIST
81197: LIST
81198: PPUSH
81199: NOP4
81203: ST_TO_ADDR
// units_path := [ ] ;
81204: NOP4
81208: PUSH
81209: EMPTY
81210: ST_TO_ADDR
// for i = 1 to group do
81211: NOP4
81215: PUSH
81216: DOUBLE
81217: LD_INT 1
81219: DEC
81220: ST_TO_ADDR
81221: NOP4
81225: PUSH
81226: FOR_TO
81227: IFFALSE 81256
// units_path := Replace ( units_path , i , path ) ;
81229: NOP4
81233: PUSH
81234: NOP4
81238: PPUSH
81239: NOP4
81243: PPUSH
81244: NOP4
81248: PPUSH
81249: NOP4
81253: ST_TO_ADDR
81254: GO 81226
81256: POP
81257: POP
// repeat for i = group downto 1 do
81258: NOP4
81262: PUSH
81263: DOUBLE
81264: NOP4
81268: INC
81269: ST_TO_ADDR
81270: LD_INT 1
81272: PUSH
81273: FOR_DOWNTO
81274: IFFALSE 85396
// begin wait ( 5 ) ;
81276: LD_INT 5
81278: PPUSH
81279: NOP4
// tmp := [ ] ;
81283: NOP4
81287: PUSH
81288: EMPTY
81289: ST_TO_ADDR
// attacking := false ;
81290: NOP4
81294: PUSH
81295: LD_INT 0
81297: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
81298: NOP4
81302: PUSH
81303: NOP4
81307: ARRAY
81308: PPUSH
81309: NOP4
81313: PUSH
81314: NOP4
81318: PUSH
81319: NOP4
81323: ARRAY
81324: NOT
81325: OR
81326: IFFALSE 81435
// begin if GetType ( group [ i ] ) = unit_human then
81328: NOP4
81332: PUSH
81333: NOP4
81337: ARRAY
81338: PPUSH
81339: NOP4
81343: PUSH
81344: LD_INT 1
81346: EQUAL
81347: IFFALSE 81393
// begin to_heal := to_heal diff group [ i ] ;
81349: NOP4
81353: PUSH
81354: NOP4
81358: PUSH
81359: NOP4
81363: PUSH
81364: NOP4
81368: ARRAY
81369: DIFF
81370: ST_TO_ADDR
// healers := healers diff group [ i ] ;
81371: NOP4
81375: PUSH
81376: NOP4
81380: PUSH
81381: NOP4
81385: PUSH
81386: NOP4
81390: ARRAY
81391: DIFF
81392: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
81393: NOP4
81397: PUSH
81398: NOP4
81402: PPUSH
81403: NOP4
81407: PPUSH
81408: NOP4
81412: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
81413: NOP4
81417: PUSH
81418: NOP4
81422: PPUSH
81423: NOP4
81427: PPUSH
81428: NOP4
81432: ST_TO_ADDR
// continue ;
81433: GO 81273
// end ; if f_repair then
81435: NOP4
81439: IFFALSE 81928
// begin if GetType ( group [ i ] ) = unit_vehicle then
81441: NOP4
81445: PUSH
81446: NOP4
81450: ARRAY
81451: PPUSH
81452: NOP4
81456: PUSH
81457: LD_INT 2
81459: EQUAL
81460: IFFALSE 81650
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
81462: NOP4
81466: PUSH
81467: NOP4
81471: ARRAY
81472: PPUSH
81473: NOP4
81477: PUSH
81478: LD_INT 700
81480: LESS
81481: PUSH
81482: NOP4
81486: PUSH
81487: NOP4
81491: ARRAY
81492: PUSH
81493: NOP4
81497: IN
81498: NOT
81499: AND
81500: IFFALSE 81524
// to_repair := to_repair union group [ i ] ;
81502: NOP4
81506: PUSH
81507: NOP4
81511: PUSH
81512: NOP4
81516: PUSH
81517: NOP4
81521: ARRAY
81522: UNION
81523: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
81524: NOP4
81528: PUSH
81529: NOP4
81533: ARRAY
81534: PPUSH
81535: NOP4
81539: PUSH
81540: LD_INT 1000
81542: EQUAL
81543: PUSH
81544: NOP4
81548: PUSH
81549: NOP4
81553: ARRAY
81554: PUSH
81555: NOP4
81559: IN
81560: AND
81561: IFFALSE 81585
// to_repair := to_repair diff group [ i ] ;
81563: NOP4
81567: PUSH
81568: NOP4
81572: PUSH
81573: NOP4
81577: PUSH
81578: NOP4
81582: ARRAY
81583: DIFF
81584: ST_TO_ADDR
// if group [ i ] in to_repair then
81585: NOP4
81589: PUSH
81590: NOP4
81594: ARRAY
81595: PUSH
81596: NOP4
81600: IN
81601: IFFALSE 81648
// begin if not IsInArea ( group [ i ] , f_repair ) then
81603: NOP4
81607: PUSH
81608: NOP4
81612: ARRAY
81613: PPUSH
81614: NOP4
81618: PPUSH
81619: NOP4
81623: NOT
81624: IFFALSE 81646
// ComMoveToArea ( group [ i ] , f_repair ) ;
81626: NOP4
81630: PUSH
81631: NOP4
81635: ARRAY
81636: PPUSH
81637: NOP4
81641: PPUSH
81642: NOP4
// continue ;
81646: GO 81273
// end ; end else
81648: GO 81928
// if group [ i ] in repairs then
81650: NOP4
81654: PUSH
81655: NOP4
81659: ARRAY
81660: PUSH
81661: NOP4
81665: IN
81666: IFFALSE 81928
// begin if IsInUnit ( group [ i ] ) then
81668: NOP4
81672: PUSH
81673: NOP4
81677: ARRAY
81678: PPUSH
81679: NOP4
81683: IFFALSE 81751
// begin z := IsInUnit ( group [ i ] ) ;
81685: NOP4
81689: PUSH
81690: NOP4
81694: PUSH
81695: NOP4
81699: ARRAY
81700: PPUSH
81701: NOP4
81705: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81706: NOP4
81710: PUSH
81711: NOP4
81715: IN
81716: PUSH
81717: NOP4
81721: PPUSH
81722: NOP4
81726: PPUSH
81727: NOP4
81731: AND
81732: IFFALSE 81749
// ComExitVehicle ( group [ i ] ) ;
81734: NOP4
81738: PUSH
81739: NOP4
81743: ARRAY
81744: PPUSH
81745: NOP4
// end else
81749: GO 81928
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81751: NOP4
81755: PUSH
81756: NOP4
81760: PPUSH
81761: LD_INT 95
81763: PUSH
81764: NOP4
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: LD_INT 58
81775: PUSH
81776: EMPTY
81777: LIST
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: PPUSH
81783: NOP4
81787: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81788: NOP4
81792: PUSH
81793: NOP4
81797: ARRAY
81798: PPUSH
81799: NOP4
81803: NOT
81804: IFFALSE 81926
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81806: NOP4
81810: PUSH
81811: NOP4
81815: PPUSH
81816: NOP4
81820: PUSH
81821: NOP4
81825: ARRAY
81826: PPUSH
81827: NOP4
81831: ST_TO_ADDR
// if not x then
81832: NOP4
81836: NOT
81837: IFFALSE 81841
// continue ;
81839: GO 81273
// if GetLives ( x ) < 1000 then
81841: NOP4
81845: PPUSH
81846: NOP4
81850: PUSH
81851: LD_INT 1000
81853: LESS
81854: IFFALSE 81878
// ComRepairVehicle ( group [ i ] , x ) else
81856: NOP4
81860: PUSH
81861: NOP4
81865: ARRAY
81866: PPUSH
81867: NOP4
81871: PPUSH
81872: NOP4
81876: GO 81926
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
81878: NOP4
81882: PUSH
81883: NOP4
81887: PUSH
81888: NOP4
81892: ARRAY
81893: PPUSH
81894: NOP4
81898: PUSH
81899: LD_INT 1000
81901: LESS
81902: AND
81903: NOT
81904: IFFALSE 81926
// ComEnterUnit ( group [ i ] , x ) ;
81906: NOP4
81910: PUSH
81911: NOP4
81915: ARRAY
81916: PPUSH
81917: NOP4
81921: PPUSH
81922: NOP4
// end ; continue ;
81926: GO 81273
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
81928: NOP4
81932: PUSH
81933: NOP4
81937: PUSH
81938: NOP4
81942: ARRAY
81943: PPUSH
81944: NOP4
81948: PUSH
81949: LD_INT 1
81951: EQUAL
81952: AND
81953: IFFALSE 82431
// begin if group [ i ] in healers then
81955: NOP4
81959: PUSH
81960: NOP4
81964: ARRAY
81965: PUSH
81966: NOP4
81970: IN
81971: IFFALSE 82244
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
81973: NOP4
81977: PUSH
81978: NOP4
81982: ARRAY
81983: PPUSH
81984: NOP4
81988: PPUSH
81989: NOP4
81993: NOT
81994: PUSH
81995: NOP4
81999: PUSH
82000: NOP4
82004: ARRAY
82005: PPUSH
82006: NOP4
82010: NOT
82011: AND
82012: IFFALSE 82036
// ComMoveToArea ( group [ i ] , f_heal ) else
82014: NOP4
82018: PUSH
82019: NOP4
82023: ARRAY
82024: PPUSH
82025: NOP4
82029: PPUSH
82030: NOP4
82034: GO 82242
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
82036: NOP4
82040: PUSH
82041: NOP4
82045: ARRAY
82046: PPUSH
82047: NOP4
82051: PPUSH
82052: NOP4
82056: PUSH
82057: LD_INT 1000
82059: EQUAL
82060: IFFALSE 82079
// ComStop ( group [ i ] ) else
82062: NOP4
82066: PUSH
82067: NOP4
82071: ARRAY
82072: PPUSH
82073: NOP4
82077: GO 82242
// if not HasTask ( group [ i ] ) and to_heal then
82079: NOP4
82083: PUSH
82084: NOP4
82088: ARRAY
82089: PPUSH
82090: NOP4
82094: NOT
82095: PUSH
82096: NOP4
82100: AND
82101: IFFALSE 82242
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
82103: NOP4
82107: PUSH
82108: NOP4
82112: PPUSH
82113: LD_INT 3
82115: PUSH
82116: LD_INT 54
82118: PUSH
82119: EMPTY
82120: LIST
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PPUSH
82126: NOP4
82130: PPUSH
82131: NOP4
82135: PUSH
82136: NOP4
82140: ARRAY
82141: PPUSH
82142: NOP4
82146: ST_TO_ADDR
// if z then
82147: NOP4
82151: IFFALSE 82242
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
82153: LD_INT 91
82155: PUSH
82156: NOP4
82160: PUSH
82161: LD_INT 10
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 81
82171: PUSH
82172: NOP4
82176: PPUSH
82177: NOP4
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PPUSH
82190: NOP4
82194: PUSH
82195: LD_INT 0
82197: EQUAL
82198: IFFALSE 82222
// ComHeal ( group [ i ] , z ) else
82200: NOP4
82204: PUSH
82205: NOP4
82209: ARRAY
82210: PPUSH
82211: NOP4
82215: PPUSH
82216: NOP4
82220: GO 82242
// ComMoveToArea ( group [ i ] , f_heal ) ;
82222: NOP4
82226: PUSH
82227: NOP4
82231: ARRAY
82232: PPUSH
82233: NOP4
82237: PPUSH
82238: NOP4
// end ; continue ;
82242: GO 81273
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
82244: NOP4
82248: PUSH
82249: NOP4
82253: ARRAY
82254: PPUSH
82255: NOP4
82259: PUSH
82260: LD_INT 700
82262: LESS
82263: PUSH
82264: NOP4
82268: PUSH
82269: NOP4
82273: ARRAY
82274: PUSH
82275: NOP4
82279: IN
82280: NOT
82281: AND
82282: IFFALSE 82306
// to_heal := to_heal union group [ i ] ;
82284: NOP4
82288: PUSH
82289: NOP4
82293: PUSH
82294: NOP4
82298: PUSH
82299: NOP4
82303: ARRAY
82304: UNION
82305: ST_TO_ADDR
// if group [ i ] in to_heal then
82306: NOP4
82310: PUSH
82311: NOP4
82315: ARRAY
82316: PUSH
82317: NOP4
82321: IN
82322: IFFALSE 82431
// begin if GetLives ( group [ i ] ) = 1000 then
82324: NOP4
82328: PUSH
82329: NOP4
82333: ARRAY
82334: PPUSH
82335: NOP4
82339: PUSH
82340: LD_INT 1000
82342: EQUAL
82343: IFFALSE 82369
// to_heal := to_heal diff group [ i ] else
82345: NOP4
82349: PUSH
82350: NOP4
82354: PUSH
82355: NOP4
82359: PUSH
82360: NOP4
82364: ARRAY
82365: DIFF
82366: ST_TO_ADDR
82367: GO 82431
// begin if not IsInArea ( group [ i ] , to_heal ) then
82369: NOP4
82373: PUSH
82374: NOP4
82378: ARRAY
82379: PPUSH
82380: NOP4
82384: PPUSH
82385: NOP4
82389: NOT
82390: IFFALSE 82414
// ComMoveToArea ( group [ i ] , f_heal ) else
82392: NOP4
82396: PUSH
82397: NOP4
82401: ARRAY
82402: PPUSH
82403: NOP4
82407: PPUSH
82408: NOP4
82412: GO 82429
// ComHold ( group [ i ] ) ;
82414: NOP4
82418: PUSH
82419: NOP4
82423: ARRAY
82424: PPUSH
82425: NOP4
// continue ;
82429: GO 81273
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
82431: NOP4
82435: PUSH
82436: NOP4
82440: ARRAY
82441: PPUSH
82442: LD_INT 10
82444: PPUSH
82445: NOP4
82449: NOT
82450: PUSH
82451: NOP4
82455: PUSH
82456: NOP4
82460: ARRAY
82461: PUSH
82462: EMPTY
82463: EQUAL
82464: NOT
82465: AND
82466: IFFALSE 82732
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
82468: NOP4
82472: PUSH
82473: NOP4
82477: ARRAY
82478: PPUSH
82479: NOP4
82483: PUSH
82484: LD_INT 1
82486: PUSH
82487: LD_INT 2
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: IN
82494: IFFALSE 82535
// if GetFuel ( group [ i ] ) < 10 then
82496: NOP4
82500: PUSH
82501: NOP4
82505: ARRAY
82506: PPUSH
82507: NOP4
82511: PUSH
82512: LD_INT 10
82514: LESS
82515: IFFALSE 82535
// SetFuel ( group [ i ] , 12 ) ;
82517: NOP4
82521: PUSH
82522: NOP4
82526: ARRAY
82527: PPUSH
82528: LD_INT 12
82530: PPUSH
82531: NOP4
// if units_path [ i ] then
82535: NOP4
82539: PUSH
82540: NOP4
82544: ARRAY
82545: IFFALSE 82730
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82547: NOP4
82551: PUSH
82552: NOP4
82556: ARRAY
82557: PPUSH
82558: NOP4
82562: PUSH
82563: NOP4
82567: ARRAY
82568: PUSH
82569: LD_INT 1
82571: ARRAY
82572: PUSH
82573: LD_INT 1
82575: ARRAY
82576: PPUSH
82577: NOP4
82581: PUSH
82582: NOP4
82586: ARRAY
82587: PUSH
82588: LD_INT 1
82590: ARRAY
82591: PUSH
82592: LD_INT 2
82594: ARRAY
82595: PPUSH
82596: NOP4
82600: PUSH
82601: LD_INT 6
82603: GREATER
82604: IFFALSE 82679
// begin if not HasTask ( group [ i ] ) then
82606: NOP4
82610: PUSH
82611: NOP4
82615: ARRAY
82616: PPUSH
82617: NOP4
82621: NOT
82622: IFFALSE 82677
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82624: NOP4
82628: PUSH
82629: NOP4
82633: ARRAY
82634: PPUSH
82635: NOP4
82639: PUSH
82640: NOP4
82644: ARRAY
82645: PUSH
82646: LD_INT 1
82648: ARRAY
82649: PUSH
82650: LD_INT 1
82652: ARRAY
82653: PPUSH
82654: NOP4
82658: PUSH
82659: NOP4
82663: ARRAY
82664: PUSH
82665: LD_INT 1
82667: ARRAY
82668: PUSH
82669: LD_INT 2
82671: ARRAY
82672: PPUSH
82673: NOP4
// end else
82677: GO 82730
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82679: NOP4
82683: PUSH
82684: NOP4
82688: PUSH
82689: NOP4
82693: ARRAY
82694: PPUSH
82695: LD_INT 1
82697: PPUSH
82698: NOP4
82702: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82703: NOP4
82707: PUSH
82708: NOP4
82712: PPUSH
82713: NOP4
82717: PPUSH
82718: NOP4
82722: PPUSH
82723: NOP4
82727: ST_TO_ADDR
// continue ;
82728: GO 81273
// end ; end ; end else
82730: GO 85394
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82732: NOP4
82736: PUSH
82737: LD_INT 81
82739: PUSH
82740: NOP4
82744: PUSH
82745: NOP4
82749: ARRAY
82750: PPUSH
82751: NOP4
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PPUSH
82760: NOP4
82764: ST_TO_ADDR
// if not tmp then
82765: NOP4
82769: NOT
82770: IFFALSE 82774
// continue ;
82772: GO 81273
// if f_ignore_area then
82774: NOP4
82778: IFFALSE 82866
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82780: NOP4
82784: PUSH
82785: NOP4
82789: PPUSH
82790: LD_INT 3
82792: PUSH
82793: LD_INT 92
82795: PUSH
82796: NOP4
82800: PUSH
82801: LD_INT 1
82803: ARRAY
82804: PUSH
82805: NOP4
82809: PUSH
82810: LD_INT 2
82812: ARRAY
82813: PUSH
82814: NOP4
82818: PUSH
82819: LD_INT 3
82821: ARRAY
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PPUSH
82833: NOP4
82837: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82838: NOP4
82842: PUSH
82843: NOP4
82847: DIFF
82848: IFFALSE 82866
// tmp := tmp diff tmp2 ;
82850: NOP4
82854: PUSH
82855: NOP4
82859: PUSH
82860: NOP4
82864: DIFF
82865: ST_TO_ADDR
// end ; if not f_murder then
82866: NOP4
82870: NOT
82871: IFFALSE 82929
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
82873: NOP4
82877: PUSH
82878: NOP4
82882: PPUSH
82883: LD_INT 3
82885: PUSH
82886: LD_INT 50
82888: PUSH
82889: EMPTY
82890: LIST
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: PPUSH
82896: NOP4
82900: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82901: NOP4
82905: PUSH
82906: NOP4
82910: DIFF
82911: IFFALSE 82929
// tmp := tmp diff tmp2 ;
82913: NOP4
82917: PUSH
82918: NOP4
82922: PUSH
82923: NOP4
82927: DIFF
82928: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
82929: NOP4
82933: PUSH
82934: NOP4
82938: PUSH
82939: NOP4
82943: ARRAY
82944: PPUSH
82945: NOP4
82949: PPUSH
82950: LD_INT 1
82952: PPUSH
82953: LD_INT 1
82955: PPUSH
82956: NOP4
82960: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
82961: NOP4
82965: PUSH
82966: NOP4
82970: ARRAY
82971: PPUSH
82972: NOP4
82976: PUSH
82977: LD_INT 1
82979: EQUAL
82980: IFFALSE 83428
// begin if WantPlant ( group [ i ] ) then
82982: NOP4
82986: PUSH
82987: NOP4
82991: ARRAY
82992: PPUSH
82993: NOP4
82997: IFFALSE 83001
// continue ;
82999: GO 81273
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
83001: NOP4
83005: PUSH
83006: NOP4
83010: PUSH
83011: NOP4
83015: ARRAY
83016: PPUSH
83017: NOP4
83021: NOT
83022: AND
83023: PUSH
83024: NOP4
83028: PUSH
83029: LD_INT 1
83031: ARRAY
83032: PUSH
83033: NOP4
83037: PPUSH
83038: LD_INT 21
83040: PUSH
83041: LD_INT 2
83043: PUSH
83044: EMPTY
83045: LIST
83046: LIST
83047: PUSH
83048: LD_INT 58
83050: PUSH
83051: EMPTY
83052: LIST
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: PPUSH
83058: NOP4
83062: IN
83063: AND
83064: IFFALSE 83100
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
83066: NOP4
83070: PUSH
83071: NOP4
83075: ARRAY
83076: PPUSH
83077: NOP4
83081: PUSH
83082: LD_INT 1
83084: ARRAY
83085: PPUSH
83086: NOP4
// attacking := true ;
83090: NOP4
83094: PUSH
83095: LD_INT 1
83097: ST_TO_ADDR
// continue ;
83098: GO 81273
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
83100: NOP4
83104: PUSH
83105: NOP4
83109: PUSH
83110: NOP4
83114: ARRAY
83115: PPUSH
83116: NOP4
83120: PUSH
83121: LD_INT 1
83123: EQUAL
83124: AND
83125: PUSH
83126: NOP4
83130: PUSH
83131: NOP4
83135: ARRAY
83136: PPUSH
83137: NOP4
83141: PUSH
83142: LD_INT 800
83144: LESS
83145: AND
83146: PUSH
83147: NOP4
83151: PUSH
83152: NOP4
83156: ARRAY
83157: PPUSH
83158: NOP4
83162: NOT
83163: AND
83164: IFFALSE 83181
// ComCrawl ( group [ i ] ) ;
83166: NOP4
83170: PUSH
83171: NOP4
83175: ARRAY
83176: PPUSH
83177: NOP4
// if f_mines then
83181: NOP4
83185: IFFALSE 83428
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
83187: NOP4
83191: PUSH
83192: LD_INT 1
83194: ARRAY
83195: PPUSH
83196: NOP4
83200: PUSH
83201: LD_INT 3
83203: EQUAL
83204: PUSH
83205: NOP4
83209: PUSH
83210: LD_INT 1
83212: ARRAY
83213: PUSH
83214: NOP4
83218: IN
83219: NOT
83220: AND
83221: IFFALSE 83428
// begin x := GetX ( tmp [ 1 ] ) ;
83223: NOP4
83227: PUSH
83228: NOP4
83232: PUSH
83233: LD_INT 1
83235: ARRAY
83236: PPUSH
83237: NOP4
83241: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
83242: NOP4
83246: PUSH
83247: NOP4
83251: PUSH
83252: LD_INT 1
83254: ARRAY
83255: PPUSH
83256: NOP4
83260: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
83261: NOP4
83265: PUSH
83266: NOP4
83270: PUSH
83271: NOP4
83275: ARRAY
83276: PPUSH
83277: NOP4
83281: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
83282: NOP4
83286: PUSH
83287: NOP4
83291: ARRAY
83292: PPUSH
83293: NOP4
83297: PPUSH
83298: NOP4
83302: PPUSH
83303: NOP4
83307: PUSH
83308: LD_INT 1
83310: ARRAY
83311: PPUSH
83312: NOP4
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
83316: NOP4
83320: PUSH
83321: NOP4
83325: ARRAY
83326: PPUSH
83327: NOP4
83331: PPUSH
83332: NOP4
83336: PPUSH
83337: LD_INT 7
83339: PPUSH
83340: NOP4
83344: PPUSH
83345: NOP4
83349: PPUSH
83350: NOP4
83354: PPUSH
83355: LD_INT 7
83357: PPUSH
83358: NOP4
83362: PPUSH
83363: NOP4
// SetTag ( group [ i ] , 71 ) ;
83367: NOP4
83371: PUSH
83372: NOP4
83376: ARRAY
83377: PPUSH
83378: LD_INT 71
83380: PPUSH
83381: NOP4
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
83385: NOP4
83389: PUSH
83390: NOP4
83394: PPUSH
83395: NOP4
83399: PUSH
83400: LD_INT 1
83402: PLUS
83403: PPUSH
83404: NOP4
83408: PUSH
83409: LD_INT 1
83411: ARRAY
83412: PPUSH
83413: NOP4
83417: ST_TO_ADDR
// attacking := true ;
83418: NOP4
83422: PUSH
83423: LD_INT 1
83425: ST_TO_ADDR
// continue ;
83426: GO 81273
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
83428: NOP4
83432: PUSH
83433: NOP4
83437: ARRAY
83438: PPUSH
83439: NOP4
83443: PUSH
83444: LD_INT 17
83446: EQUAL
83447: PUSH
83448: NOP4
83452: PUSH
83453: NOP4
83457: ARRAY
83458: PPUSH
83459: NOP4
83463: PUSH
83464: LD_INT 71
83466: EQUAL
83467: NOT
83468: AND
83469: IFFALSE 83615
// begin attacking := false ;
83471: NOP4
83475: PUSH
83476: LD_INT 0
83478: ST_TO_ADDR
// k := 5 ;
83479: NOP4
83483: PUSH
83484: LD_INT 5
83486: ST_TO_ADDR
// if tmp < k then
83487: NOP4
83491: PUSH
83492: NOP4
83496: LESS
83497: IFFALSE 83509
// k := tmp ;
83499: NOP4
83503: PUSH
83504: NOP4
83508: ST_TO_ADDR
// for j = 1 to k do
83509: NOP4
83513: PUSH
83514: DOUBLE
83515: LD_INT 1
83517: DEC
83518: ST_TO_ADDR
83519: NOP4
83523: PUSH
83524: FOR_TO
83525: IFFALSE 83613
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
83527: NOP4
83531: PUSH
83532: NOP4
83536: ARRAY
83537: PUSH
83538: NOP4
83542: PPUSH
83543: LD_INT 58
83545: PUSH
83546: EMPTY
83547: LIST
83548: PPUSH
83549: NOP4
83553: IN
83554: NOT
83555: IFFALSE 83611
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83557: NOP4
83561: PUSH
83562: NOP4
83566: ARRAY
83567: PPUSH
83568: NOP4
83572: PUSH
83573: NOP4
83577: ARRAY
83578: PPUSH
83579: NOP4
// attacking := true ;
83583: NOP4
83587: PUSH
83588: LD_INT 1
83590: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83591: NOP4
83595: PUSH
83596: NOP4
83600: ARRAY
83601: PPUSH
83602: LD_INT 71
83604: PPUSH
83605: NOP4
// continue ;
83609: GO 83524
// end ; end ;
83611: GO 83524
83613: POP
83614: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83615: NOP4
83619: PUSH
83620: NOP4
83624: ARRAY
83625: PPUSH
83626: NOP4
83630: PUSH
83631: LD_INT 8
83633: EQUAL
83634: PUSH
83635: NOP4
83639: PUSH
83640: NOP4
83644: ARRAY
83645: PPUSH
83646: NOP4
83650: PUSH
83651: LD_INT 28
83653: PUSH
83654: LD_INT 45
83656: PUSH
83657: LD_INT 7
83659: PUSH
83660: LD_INT 47
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: IN
83669: OR
83670: IFFALSE 83926
// begin attacking := false ;
83672: NOP4
83676: PUSH
83677: LD_INT 0
83679: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83680: NOP4
83684: PUSH
83685: LD_INT 1
83687: ARRAY
83688: PPUSH
83689: NOP4
83693: PUSH
83694: LD_INT 32
83696: PUSH
83697: LD_INT 31
83699: PUSH
83700: LD_INT 33
83702: PUSH
83703: LD_INT 4
83705: PUSH
83706: LD_INT 5
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: IN
83716: IFFALSE 83902
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83718: NOP4
83722: PUSH
83723: NOP4
83727: PUSH
83728: LD_INT 1
83730: ARRAY
83731: PPUSH
83732: NOP4
83736: PPUSH
83737: NOP4
83741: PUSH
83742: LD_INT 1
83744: ARRAY
83745: PPUSH
83746: NOP4
83750: PPUSH
83751: NOP4
83755: PUSH
83756: LD_INT 1
83758: ARRAY
83759: PPUSH
83760: NOP4
83764: PPUSH
83765: NOP4
83769: PUSH
83770: LD_INT 1
83772: ARRAY
83773: PPUSH
83774: NOP4
83778: PPUSH
83779: NOP4
83783: PUSH
83784: LD_INT 1
83786: ARRAY
83787: PPUSH
83788: NOP4
83792: PPUSH
83793: LD_INT 0
83795: PPUSH
83796: NOP4
83800: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83801: NOP4
83805: PUSH
83806: NOP4
83810: PUSH
83811: NOP4
83815: ARRAY
83816: PPUSH
83817: NOP4
83821: PPUSH
83822: NOP4
83826: ST_TO_ADDR
// if j then
83827: NOP4
83831: IFFALSE 83900
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83833: NOP4
83837: PUSH
83838: LD_INT 1
83840: ARRAY
83841: PPUSH
83842: NOP4
83846: PUSH
83847: LD_INT 2
83849: ARRAY
83850: PPUSH
83851: NOP4
83855: IFFALSE 83900
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
83857: NOP4
83861: PUSH
83862: NOP4
83866: ARRAY
83867: PPUSH
83868: NOP4
83872: PUSH
83873: LD_INT 1
83875: ARRAY
83876: PPUSH
83877: NOP4
83881: PUSH
83882: LD_INT 2
83884: ARRAY
83885: PPUSH
83886: NOP4
// attacking := true ;
83890: NOP4
83894: PUSH
83895: LD_INT 1
83897: ST_TO_ADDR
// continue ;
83898: GO 81273
// end ; end else
83900: GO 83926
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83902: NOP4
83906: PUSH
83907: NOP4
83911: ARRAY
83912: PPUSH
83913: NOP4
83917: PUSH
83918: LD_INT 1
83920: ARRAY
83921: PPUSH
83922: NOP4
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
83926: NOP4
83930: PUSH
83931: NOP4
83935: ARRAY
83936: PPUSH
83937: NOP4
83941: PUSH
83942: LD_INT 11
83944: EQUAL
83945: IFFALSE 84223
// begin k := 10 ;
83947: NOP4
83951: PUSH
83952: LD_INT 10
83954: ST_TO_ADDR
// x := 0 ;
83955: NOP4
83959: PUSH
83960: LD_INT 0
83962: ST_TO_ADDR
// if tmp < k then
83963: NOP4
83967: PUSH
83968: NOP4
83972: LESS
83973: IFFALSE 83985
// k := tmp ;
83975: NOP4
83979: PUSH
83980: NOP4
83984: ST_TO_ADDR
// for j = k downto 1 do
83985: NOP4
83989: PUSH
83990: DOUBLE
83991: NOP4
83995: INC
83996: ST_TO_ADDR
83997: LD_INT 1
83999: PUSH
84000: FOR_DOWNTO
84001: IFFALSE 84076
// begin if GetType ( tmp [ j ] ) = unit_human then
84003: NOP4
84007: PUSH
84008: NOP4
84012: ARRAY
84013: PPUSH
84014: NOP4
84018: PUSH
84019: LD_INT 1
84021: EQUAL
84022: IFFALSE 84074
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
84024: NOP4
84028: PUSH
84029: NOP4
84033: ARRAY
84034: PPUSH
84035: NOP4
84039: PUSH
84040: NOP4
84044: ARRAY
84045: PPUSH
84046: NOP4
// x := tmp [ j ] ;
84050: NOP4
84054: PUSH
84055: NOP4
84059: PUSH
84060: NOP4
84064: ARRAY
84065: ST_TO_ADDR
// attacking := true ;
84066: NOP4
84070: PUSH
84071: LD_INT 1
84073: ST_TO_ADDR
// end ; end ;
84074: GO 84000
84076: POP
84077: POP
// if not x then
84078: NOP4
84082: NOT
84083: IFFALSE 84223
// begin attacking := true ;
84085: NOP4
84089: PUSH
84090: LD_INT 1
84092: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
84093: NOP4
84097: PUSH
84098: NOP4
84102: ARRAY
84103: PPUSH
84104: NOP4
84108: PPUSH
84109: NOP4
84113: PUSH
84114: NOP4
84118: ARRAY
84119: PPUSH
84120: NOP4
84124: PPUSH
84125: NOP4
84129: PUSH
84130: LD_INT 2
84132: ARRAY
84133: PUSH
84134: NOP4
84138: PUSH
84139: LD_INT 1
84141: ARRAY
84142: PPUSH
84143: NOP4
84147: PPUSH
84148: NOP4
84152: PUSH
84153: LD_INT 1
84155: ARRAY
84156: PPUSH
84157: NOP4
84161: PPUSH
84162: NOP4
84166: PUSH
84167: LD_INT 2
84169: ARRAY
84170: EQUAL
84171: IFFALSE 84199
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
84173: NOP4
84177: PUSH
84178: NOP4
84182: ARRAY
84183: PPUSH
84184: NOP4
84188: PUSH
84189: LD_INT 1
84191: ARRAY
84192: PPUSH
84193: NOP4
84197: GO 84223
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84199: NOP4
84203: PUSH
84204: NOP4
84208: ARRAY
84209: PPUSH
84210: NOP4
84214: PUSH
84215: LD_INT 1
84217: ARRAY
84218: PPUSH
84219: NOP4
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
84223: NOP4
84227: PUSH
84228: NOP4
84232: ARRAY
84233: PPUSH
84234: NOP4
84238: PUSH
84239: LD_INT 29
84241: EQUAL
84242: IFFALSE 84608
// begin if WantsToAttack ( group [ i ] ) in bombed then
84244: NOP4
84248: PUSH
84249: NOP4
84253: ARRAY
84254: PPUSH
84255: NOP4
84259: PUSH
84260: NOP4
84264: IN
84265: IFFALSE 84269
// continue ;
84267: GO 81273
// k := 8 ;
84269: NOP4
84273: PUSH
84274: LD_INT 8
84276: ST_TO_ADDR
// x := 0 ;
84277: NOP4
84281: PUSH
84282: LD_INT 0
84284: ST_TO_ADDR
// if tmp < k then
84285: NOP4
84289: PUSH
84290: NOP4
84294: LESS
84295: IFFALSE 84307
// k := tmp ;
84297: NOP4
84301: PUSH
84302: NOP4
84306: ST_TO_ADDR
// for j = 1 to k do
84307: NOP4
84311: PUSH
84312: DOUBLE
84313: LD_INT 1
84315: DEC
84316: ST_TO_ADDR
84317: NOP4
84321: PUSH
84322: FOR_TO
84323: IFFALSE 84455
// begin if GetType ( tmp [ j ] ) = unit_building then
84325: NOP4
84329: PUSH
84330: NOP4
84334: ARRAY
84335: PPUSH
84336: NOP4
84340: PUSH
84341: LD_INT 3
84343: EQUAL
84344: IFFALSE 84453
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
84346: NOP4
84350: PUSH
84351: NOP4
84355: ARRAY
84356: PUSH
84357: NOP4
84361: IN
84362: NOT
84363: PUSH
84364: NOP4
84368: PUSH
84369: NOP4
84373: ARRAY
84374: PPUSH
84375: NOP4
84379: AND
84380: IFFALSE 84453
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84382: NOP4
84386: PUSH
84387: NOP4
84391: ARRAY
84392: PPUSH
84393: NOP4
84397: PUSH
84398: NOP4
84402: ARRAY
84403: PPUSH
84404: NOP4
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
84408: NOP4
84412: PUSH
84413: NOP4
84417: PPUSH
84418: NOP4
84422: PUSH
84423: LD_INT 1
84425: PLUS
84426: PPUSH
84427: NOP4
84431: PUSH
84432: NOP4
84436: ARRAY
84437: PPUSH
84438: NOP4
84442: ST_TO_ADDR
// attacking := true ;
84443: NOP4
84447: PUSH
84448: LD_INT 1
84450: ST_TO_ADDR
// break ;
84451: GO 84455
// end ; end ;
84453: GO 84322
84455: POP
84456: POP
// if not attacking and f_attack_depot then
84457: NOP4
84461: NOT
84462: PUSH
84463: NOP4
84467: AND
84468: IFFALSE 84563
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84470: NOP4
84474: PUSH
84475: NOP4
84479: PPUSH
84480: LD_INT 2
84482: PUSH
84483: LD_INT 30
84485: PUSH
84486: LD_INT 0
84488: PUSH
84489: EMPTY
84490: LIST
84491: LIST
84492: PUSH
84493: LD_INT 30
84495: PUSH
84496: LD_INT 1
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: PUSH
84503: EMPTY
84504: LIST
84505: LIST
84506: LIST
84507: PPUSH
84508: NOP4
84512: ST_TO_ADDR
// if z then
84513: NOP4
84517: IFFALSE 84563
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
84519: NOP4
84523: PUSH
84524: NOP4
84528: ARRAY
84529: PPUSH
84530: NOP4
84534: PPUSH
84535: NOP4
84539: PUSH
84540: NOP4
84544: ARRAY
84545: PPUSH
84546: NOP4
84550: PPUSH
84551: NOP4
// attacking := true ;
84555: NOP4
84559: PUSH
84560: LD_INT 1
84562: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84563: NOP4
84567: PUSH
84568: NOP4
84572: ARRAY
84573: PPUSH
84574: NOP4
84578: PUSH
84579: LD_INT 500
84581: LESS
84582: IFFALSE 84608
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84584: NOP4
84588: PUSH
84589: NOP4
84593: ARRAY
84594: PPUSH
84595: NOP4
84599: PUSH
84600: LD_INT 1
84602: ARRAY
84603: PPUSH
84604: NOP4
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84608: NOP4
84612: PUSH
84613: NOP4
84617: ARRAY
84618: PPUSH
84619: NOP4
84623: PUSH
84624: LD_INT 49
84626: EQUAL
84627: IFFALSE 84748
// begin if not HasTask ( group [ i ] ) then
84629: NOP4
84633: PUSH
84634: NOP4
84638: ARRAY
84639: PPUSH
84640: NOP4
84644: NOT
84645: IFFALSE 84748
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84647: NOP4
84651: PUSH
84652: LD_INT 81
84654: PUSH
84655: NOP4
84659: PUSH
84660: NOP4
84664: ARRAY
84665: PPUSH
84666: NOP4
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PPUSH
84675: NOP4
84679: PPUSH
84680: NOP4
84684: PUSH
84685: NOP4
84689: ARRAY
84690: PPUSH
84691: NOP4
84695: ST_TO_ADDR
// if k then
84696: NOP4
84700: IFFALSE 84748
// if GetDistUnits ( group [ i ] , k ) > 10 then
84702: NOP4
84706: PUSH
84707: NOP4
84711: ARRAY
84712: PPUSH
84713: NOP4
84717: PPUSH
84718: NOP4
84722: PUSH
84723: LD_INT 10
84725: GREATER
84726: IFFALSE 84748
// ComMoveUnit ( group [ i ] , k ) ;
84728: NOP4
84732: PUSH
84733: NOP4
84737: ARRAY
84738: PPUSH
84739: NOP4
84743: PPUSH
84744: NOP4
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84748: NOP4
84752: PUSH
84753: NOP4
84757: ARRAY
84758: PPUSH
84759: NOP4
84763: PUSH
84764: LD_INT 250
84766: LESS
84767: PUSH
84768: NOP4
84772: PUSH
84773: NOP4
84777: ARRAY
84778: PUSH
84779: LD_INT 21
84781: PUSH
84782: LD_INT 2
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 23
84791: PUSH
84792: LD_INT 2
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PPUSH
84803: NOP4
84807: IN
84808: AND
84809: IFFALSE 84934
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84811: NOP4
84815: PUSH
84816: NOP4
84820: PUSH
84821: NOP4
84825: PUSH
84826: NOP4
84830: ARRAY
84831: DIFF
84832: PPUSH
84833: NOP4
84837: PUSH
84838: NOP4
84842: ARRAY
84843: PPUSH
84844: NOP4
84848: ST_TO_ADDR
// if not k then
84849: NOP4
84853: NOT
84854: IFFALSE 84858
// continue ;
84856: GO 81273
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
84858: NOP4
84862: PUSH
84863: LD_INT 81
84865: PUSH
84866: NOP4
84870: PUSH
84871: NOP4
84875: ARRAY
84876: PPUSH
84877: NOP4
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PPUSH
84886: NOP4
84890: IN
84891: PUSH
84892: NOP4
84896: PPUSH
84897: NOP4
84901: PUSH
84902: NOP4
84906: ARRAY
84907: PPUSH
84908: NOP4
84912: PUSH
84913: LD_INT 5
84915: LESS
84916: AND
84917: IFFALSE 84934
// ComAutodestruct ( group [ i ] ) ;
84919: NOP4
84923: PUSH
84924: NOP4
84928: ARRAY
84929: PPUSH
84930: NOP4
// end ; if f_attack_depot then
84934: NOP4
84938: IFFALSE 85050
// begin k := 6 ;
84940: NOP4
84944: PUSH
84945: LD_INT 6
84947: ST_TO_ADDR
// if tmp < k then
84948: NOP4
84952: PUSH
84953: NOP4
84957: LESS
84958: IFFALSE 84970
// k := tmp ;
84960: NOP4
84964: PUSH
84965: NOP4
84969: ST_TO_ADDR
// for j = 1 to k do
84970: NOP4
84974: PUSH
84975: DOUBLE
84976: LD_INT 1
84978: DEC
84979: ST_TO_ADDR
84980: NOP4
84984: PUSH
84985: FOR_TO
84986: IFFALSE 85048
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
84988: NOP4
84992: PPUSH
84993: NOP4
84997: PUSH
84998: LD_INT 0
85000: PUSH
85001: LD_INT 1
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: IN
85008: IFFALSE 85046
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85010: NOP4
85014: PUSH
85015: NOP4
85019: ARRAY
85020: PPUSH
85021: NOP4
85025: PUSH
85026: NOP4
85030: ARRAY
85031: PPUSH
85032: NOP4
// attacking := true ;
85036: NOP4
85040: PUSH
85041: LD_INT 1
85043: ST_TO_ADDR
// break ;
85044: GO 85048
// end ;
85046: GO 84985
85048: POP
85049: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
85050: NOP4
85054: PUSH
85055: NOP4
85059: ARRAY
85060: PPUSH
85061: NOP4
85065: PUSH
85066: NOP4
85070: NOT
85071: AND
85072: IFFALSE 85394
// begin if GetTag ( group [ i ] ) = 71 then
85074: NOP4
85078: PUSH
85079: NOP4
85083: ARRAY
85084: PPUSH
85085: NOP4
85089: PUSH
85090: LD_INT 71
85092: EQUAL
85093: IFFALSE 85134
// begin if HasTask ( group [ i ] ) then
85095: NOP4
85099: PUSH
85100: NOP4
85104: ARRAY
85105: PPUSH
85106: NOP4
85110: IFFALSE 85116
// continue else
85112: GO 81273
85114: GO 85134
// SetTag ( group [ i ] , 0 ) ;
85116: NOP4
85120: PUSH
85121: NOP4
85125: ARRAY
85126: PPUSH
85127: LD_INT 0
85129: PPUSH
85130: NOP4
// end ; k := 8 ;
85134: NOP4
85138: PUSH
85139: LD_INT 8
85141: ST_TO_ADDR
// x := 0 ;
85142: NOP4
85146: PUSH
85147: LD_INT 0
85149: ST_TO_ADDR
// if tmp < k then
85150: NOP4
85154: PUSH
85155: NOP4
85159: LESS
85160: IFFALSE 85172
// k := tmp ;
85162: NOP4
85166: PUSH
85167: NOP4
85171: ST_TO_ADDR
// for j = 1 to k do
85172: NOP4
85176: PUSH
85177: DOUBLE
85178: LD_INT 1
85180: DEC
85181: ST_TO_ADDR
85182: NOP4
85186: PUSH
85187: FOR_TO
85188: IFFALSE 85286
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
85190: NOP4
85194: PUSH
85195: NOP4
85199: ARRAY
85200: PPUSH
85201: NOP4
85205: PUSH
85206: LD_INT 1
85208: EQUAL
85209: PUSH
85210: NOP4
85214: PUSH
85215: NOP4
85219: ARRAY
85220: PPUSH
85221: NOP4
85225: PUSH
85226: LD_INT 250
85228: LESS
85229: PUSH
85230: NOP4
85234: AND
85235: PUSH
85236: NOP4
85240: NOT
85241: PUSH
85242: NOP4
85246: PUSH
85247: NOP4
85251: ARRAY
85252: PPUSH
85253: NOP4
85257: PUSH
85258: LD_INT 250
85260: GREATEREQUAL
85261: AND
85262: OR
85263: AND
85264: IFFALSE 85284
// begin x := tmp [ j ] ;
85266: NOP4
85270: PUSH
85271: NOP4
85275: PUSH
85276: NOP4
85280: ARRAY
85281: ST_TO_ADDR
// break ;
85282: GO 85286
// end ;
85284: GO 85187
85286: POP
85287: POP
// if x then
85288: NOP4
85292: IFFALSE 85316
// ComAttackUnit ( group [ i ] , x ) else
85294: NOP4
85298: PUSH
85299: NOP4
85303: ARRAY
85304: PPUSH
85305: NOP4
85309: PPUSH
85310: NOP4
85314: GO 85340
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85316: NOP4
85320: PUSH
85321: NOP4
85325: ARRAY
85326: PPUSH
85327: NOP4
85331: PUSH
85332: LD_INT 1
85334: ARRAY
85335: PPUSH
85336: NOP4
// if not HasTask ( group [ i ] ) then
85340: NOP4
85344: PUSH
85345: NOP4
85349: ARRAY
85350: PPUSH
85351: NOP4
85355: NOT
85356: IFFALSE 85394
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
85358: NOP4
85362: PUSH
85363: NOP4
85367: ARRAY
85368: PPUSH
85369: NOP4
85373: PPUSH
85374: NOP4
85378: PUSH
85379: NOP4
85383: ARRAY
85384: PPUSH
85385: NOP4
85389: PPUSH
85390: NOP4
// end ; end ; end ;
85394: GO 81273
85396: POP
85397: POP
// wait ( 0 0$2 ) ;
85398: LD_INT 70
85400: PPUSH
85401: NOP4
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
85405: NOP4
85409: NOT
85410: PUSH
85411: NOP4
85415: PUSH
85416: EMPTY
85417: EQUAL
85418: OR
85419: PUSH
85420: LD_INT 81
85422: PUSH
85423: NOP4
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PPUSH
85432: NOP4
85436: NOT
85437: OR
85438: IFFALSE 81258
// end ;
85440: LD_VAR 0 2
85444: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
85445: LD_INT 0
85447: PPUSH
85448: PPUSH
85449: PPUSH
85450: PPUSH
85451: PPUSH
85452: PPUSH
// if not base or not mc_bases [ base ] or not solds then
85453: NOP4
85457: NOT
85458: PUSH
85459: NOP4
85463: PUSH
85464: NOP4
85468: ARRAY
85469: NOT
85470: OR
85471: PUSH
85472: NOP4
85476: NOT
85477: OR
85478: IFFALSE 85482
// exit ;
85480: GO 86036
// side := mc_sides [ base ] ;
85482: NOP4
85486: PUSH
85487: NOP4
85491: PUSH
85492: NOP4
85496: ARRAY
85497: ST_TO_ADDR
// if not side then
85498: NOP4
85502: NOT
85503: IFFALSE 85507
// exit ;
85505: GO 86036
// for i in solds do
85507: NOP4
85511: PUSH
85512: NOP4
85516: PUSH
85517: FOR_IN
85518: IFFALSE 85579
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
85520: NOP4
85524: PPUSH
85525: NOP4
85529: PPUSH
85530: NOP4
85534: PUSH
85535: LD_INT 32
85537: PUSH
85538: LD_INT 31
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: IN
85545: IFFALSE 85565
// solds := solds diff i else
85547: NOP4
85551: PUSH
85552: NOP4
85556: PUSH
85557: NOP4
85561: DIFF
85562: ST_TO_ADDR
85563: GO 85577
// SetTag ( i , 18 ) ;
85565: NOP4
85569: PPUSH
85570: LD_INT 18
85572: PPUSH
85573: NOP4
85577: GO 85517
85579: POP
85580: POP
// if not solds then
85581: NOP4
85585: NOT
85586: IFFALSE 85590
// exit ;
85588: GO 86036
// repeat wait ( 0 0$2 ) ;
85590: LD_INT 70
85592: PPUSH
85593: NOP4
// enemy := mc_scan [ base ] ;
85597: NOP4
85601: PUSH
85602: NOP4
85606: PUSH
85607: NOP4
85611: ARRAY
85612: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85613: NOP4
85617: PUSH
85618: NOP4
85622: ARRAY
85623: NOT
85624: PUSH
85625: NOP4
85629: PUSH
85630: NOP4
85634: ARRAY
85635: PUSH
85636: EMPTY
85637: EQUAL
85638: OR
85639: IFFALSE 85676
// begin for i in solds do
85641: NOP4
85645: PUSH
85646: NOP4
85650: PUSH
85651: FOR_IN
85652: IFFALSE 85665
// ComStop ( i ) ;
85654: NOP4
85658: PPUSH
85659: NOP4
85663: GO 85651
85665: POP
85666: POP
// solds := [ ] ;
85667: NOP4
85671: PUSH
85672: EMPTY
85673: ST_TO_ADDR
// exit ;
85674: GO 86036
// end ; for i in solds do
85676: NOP4
85680: PUSH
85681: NOP4
85685: PUSH
85686: FOR_IN
85687: IFFALSE 86008
// begin if IsInUnit ( i ) then
85689: NOP4
85693: PPUSH
85694: NOP4
85698: IFFALSE 85709
// ComExitBuilding ( i ) ;
85700: NOP4
85704: PPUSH
85705: NOP4
// if GetLives ( i ) > 500 then
85709: NOP4
85713: PPUSH
85714: NOP4
85718: PUSH
85719: LD_INT 500
85721: GREATER
85722: IFFALSE 85775
// begin e := NearestUnitToUnit ( enemy , i ) ;
85724: NOP4
85728: PUSH
85729: NOP4
85733: PPUSH
85734: NOP4
85738: PPUSH
85739: NOP4
85743: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
85744: NOP4
85748: PPUSH
85749: NOP4
85753: PPUSH
85754: NOP4
85758: PPUSH
85759: NOP4
85763: PPUSH
85764: NOP4
85768: PPUSH
85769: NOP4
// end else
85773: GO 86006
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
85775: NOP4
85779: PPUSH
85780: NOP4
85784: PUSH
85785: NOP4
85789: ARRAY
85790: PPUSH
85791: LD_INT 2
85793: PUSH
85794: LD_INT 30
85796: PUSH
85797: LD_INT 0
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: PUSH
85804: LD_INT 30
85806: PUSH
85807: LD_INT 1
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: PUSH
85814: LD_INT 30
85816: PUSH
85817: LD_INT 6
85819: PUSH
85820: EMPTY
85821: LIST
85822: LIST
85823: PUSH
85824: EMPTY
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: PPUSH
85830: NOP4
85834: PPUSH
85835: NOP4
85839: PPUSH
85840: NOP4
85844: PPUSH
85845: NOP4
85849: PUSH
85850: LD_INT 10
85852: GREATER
85853: IFFALSE 86006
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
85855: NOP4
85859: PUSH
85860: NOP4
85864: PUSH
85865: NOP4
85869: ARRAY
85870: PPUSH
85871: LD_INT 2
85873: PUSH
85874: LD_INT 30
85876: PUSH
85877: LD_INT 0
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: PUSH
85884: LD_INT 30
85886: PUSH
85887: LD_INT 1
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 30
85896: PUSH
85897: LD_INT 6
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: PUSH
85904: EMPTY
85905: LIST
85906: LIST
85907: LIST
85908: LIST
85909: PPUSH
85910: NOP4
85914: PPUSH
85915: NOP4
85919: PPUSH
85920: NOP4
85924: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
85925: NOP4
85929: PPUSH
85930: NOP4
85934: PPUSH
85935: NOP4
85939: PPUSH
85940: LD_INT 3
85942: PPUSH
85943: LD_INT 5
85945: PPUSH
85946: NOP4
85950: PPUSH
85951: NOP4
85955: PPUSH
85956: NOP4
85960: PPUSH
85961: LD_INT 3
85963: PPUSH
85964: LD_INT 5
85966: PPUSH
85967: NOP4
85971: PPUSH
85972: NOP4
// SetTag ( i , 0 ) ;
85976: NOP4
85980: PPUSH
85981: LD_INT 0
85983: PPUSH
85984: NOP4
// solds := solds diff i ;
85988: NOP4
85992: PUSH
85993: NOP4
85997: PUSH
85998: NOP4
86002: DIFF
86003: ST_TO_ADDR
// continue ;
86004: GO 85686
// end ; end ;
86006: GO 85686
86008: POP
86009: POP
// until not solds or not enemy ;
86010: NOP4
86014: NOT
86015: PUSH
86016: NOP4
86020: NOT
86021: OR
86022: IFFALSE 85590
// MC_Reset ( base , 18 ) ;
86024: NOP4
86028: PPUSH
86029: LD_INT 18
86031: PPUSH
86032: NOP4
// end ;
86036: LD_VAR 0 3
86040: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
86041: LD_INT 0
86043: PPUSH
86044: PPUSH
86045: PPUSH
86046: PPUSH
86047: PPUSH
86048: PPUSH
86049: PPUSH
86050: PPUSH
86051: PPUSH
86052: PPUSH
86053: PPUSH
86054: PPUSH
86055: PPUSH
86056: PPUSH
86057: PPUSH
86058: PPUSH
86059: PPUSH
86060: PPUSH
86061: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86062: NOP4
86066: PUSH
86067: NOP4
86071: PUSH
86072: NOP4
86076: ARRAY
86077: PPUSH
86078: LD_INT 25
86080: PUSH
86081: LD_INT 3
86083: PUSH
86084: EMPTY
86085: LIST
86086: LIST
86087: PPUSH
86088: NOP4
86092: ST_TO_ADDR
// if mc_remote_driver [ base ] then
86093: NOP4
86097: PUSH
86098: NOP4
86102: ARRAY
86103: IFFALSE 86127
// mechs := mechs diff mc_remote_driver [ base ] ;
86105: NOP4
86109: PUSH
86110: NOP4
86114: PUSH
86115: NOP4
86119: PUSH
86120: NOP4
86124: ARRAY
86125: DIFF
86126: ST_TO_ADDR
// for i in mechs do
86127: NOP4
86131: PUSH
86132: NOP4
86136: PUSH
86137: FOR_IN
86138: IFFALSE 86173
// if GetTag ( i ) > 0 then
86140: NOP4
86144: PPUSH
86145: NOP4
86149: PUSH
86150: LD_INT 0
86152: GREATER
86153: IFFALSE 86171
// mechs := mechs diff i ;
86155: NOP4
86159: PUSH
86160: NOP4
86164: PUSH
86165: NOP4
86169: DIFF
86170: ST_TO_ADDR
86171: GO 86137
86173: POP
86174: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86175: NOP4
86179: PUSH
86180: NOP4
86184: PUSH
86185: NOP4
86189: ARRAY
86190: PPUSH
86191: LD_INT 2
86193: PUSH
86194: LD_INT 25
86196: PUSH
86197: LD_INT 1
86199: PUSH
86200: EMPTY
86201: LIST
86202: LIST
86203: PUSH
86204: LD_INT 25
86206: PUSH
86207: LD_INT 5
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: PUSH
86214: LD_INT 25
86216: PUSH
86217: LD_INT 8
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 25
86226: PUSH
86227: LD_INT 9
86229: PUSH
86230: EMPTY
86231: LIST
86232: LIST
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: PPUSH
86241: NOP4
86245: ST_TO_ADDR
// if not defenders and not solds then
86246: NOP4
86250: NOT
86251: PUSH
86252: NOP4
86256: NOT
86257: AND
86258: IFFALSE 86262
// exit ;
86260: GO 88032
// depot_under_attack := false ;
86262: NOP4
86266: PUSH
86267: LD_INT 0
86269: ST_TO_ADDR
// sold_defenders := [ ] ;
86270: NOP4
86274: PUSH
86275: EMPTY
86276: ST_TO_ADDR
// if mechs then
86277: NOP4
86281: IFFALSE 86434
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
86283: NOP4
86287: PUSH
86288: NOP4
86292: PPUSH
86293: LD_INT 21
86295: PUSH
86296: LD_INT 2
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: PPUSH
86303: NOP4
86307: PUSH
86308: FOR_IN
86309: IFFALSE 86432
// begin if GetTag ( i ) <> 20 then
86311: NOP4
86315: PPUSH
86316: NOP4
86320: PUSH
86321: LD_INT 20
86323: NONEQUAL
86324: IFFALSE 86338
// SetTag ( i , 20 ) ;
86326: NOP4
86330: PPUSH
86331: LD_INT 20
86333: PPUSH
86334: NOP4
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
86338: NOP4
86342: PPUSH
86343: NOP4
86347: PUSH
86348: LD_INT 1
86350: EQUAL
86351: PUSH
86352: NOP4
86356: PPUSH
86357: NOP4
86361: NOT
86362: AND
86363: IFFALSE 86430
// begin un := mechs [ 1 ] ;
86365: NOP4
86369: PUSH
86370: NOP4
86374: PUSH
86375: LD_INT 1
86377: ARRAY
86378: ST_TO_ADDR
// ComExit ( un ) ;
86379: NOP4
86383: PPUSH
86384: NOP4
// AddComEnterUnit ( un , i ) ;
86388: NOP4
86392: PPUSH
86393: NOP4
86397: PPUSH
86398: NOP4
// SetTag ( un , 19 ) ;
86402: NOP4
86406: PPUSH
86407: LD_INT 19
86409: PPUSH
86410: NOP4
// mechs := mechs diff un ;
86414: NOP4
86418: PUSH
86419: NOP4
86423: PUSH
86424: NOP4
86428: DIFF
86429: ST_TO_ADDR
// end ; end ;
86430: GO 86308
86432: POP
86433: POP
// if solds then
86434: NOP4
86438: IFFALSE 86497
// for i in solds do
86440: NOP4
86444: PUSH
86445: NOP4
86449: PUSH
86450: FOR_IN
86451: IFFALSE 86495
// if not GetTag ( i ) then
86453: NOP4
86457: PPUSH
86458: NOP4
86462: NOT
86463: IFFALSE 86493
// begin defenders := defenders union i ;
86465: NOP4
86469: PUSH
86470: NOP4
86474: PUSH
86475: NOP4
86479: UNION
86480: ST_TO_ADDR
// SetTag ( i , 18 ) ;
86481: NOP4
86485: PPUSH
86486: LD_INT 18
86488: PPUSH
86489: NOP4
// end ;
86493: GO 86450
86495: POP
86496: POP
// repeat wait ( 0 0$2 ) ;
86497: LD_INT 70
86499: PPUSH
86500: NOP4
// enemy := mc_scan [ base ] ;
86504: NOP4
86508: PUSH
86509: NOP4
86513: PUSH
86514: NOP4
86518: ARRAY
86519: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86520: NOP4
86524: PUSH
86525: NOP4
86529: ARRAY
86530: NOT
86531: PUSH
86532: NOP4
86536: PUSH
86537: NOP4
86541: ARRAY
86542: PUSH
86543: EMPTY
86544: EQUAL
86545: OR
86546: IFFALSE 86583
// begin for i in defenders do
86548: NOP4
86552: PUSH
86553: NOP4
86557: PUSH
86558: FOR_IN
86559: IFFALSE 86572
// ComStop ( i ) ;
86561: NOP4
86565: PPUSH
86566: NOP4
86570: GO 86558
86572: POP
86573: POP
// defenders := [ ] ;
86574: NOP4
86578: PUSH
86579: EMPTY
86580: ST_TO_ADDR
// exit ;
86581: GO 88032
// end ; for i in defenders do
86583: NOP4
86587: PUSH
86588: NOP4
86592: PUSH
86593: FOR_IN
86594: IFFALSE 87492
// begin e := NearestUnitToUnit ( enemy , i ) ;
86596: NOP4
86600: PUSH
86601: NOP4
86605: PPUSH
86606: NOP4
86610: PPUSH
86611: NOP4
86615: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86616: NOP4
86620: PUSH
86621: NOP4
86625: PUSH
86626: NOP4
86630: ARRAY
86631: PPUSH
86632: LD_INT 2
86634: PUSH
86635: LD_INT 30
86637: PUSH
86638: LD_INT 0
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: PUSH
86645: LD_INT 30
86647: PUSH
86648: LD_INT 1
86650: PUSH
86651: EMPTY
86652: LIST
86653: LIST
86654: PUSH
86655: EMPTY
86656: LIST
86657: LIST
86658: LIST
86659: PPUSH
86660: NOP4
86664: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86665: NOP4
86669: PUSH
86670: NOP4
86674: NOT
86675: PUSH
86676: NOP4
86680: PPUSH
86681: LD_INT 3
86683: PUSH
86684: LD_INT 24
86686: PUSH
86687: LD_INT 600
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PPUSH
86698: NOP4
86702: OR
86703: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86704: NOP4
86708: PPUSH
86709: NOP4
86713: PUSH
86714: LD_INT 2
86716: DOUBLE
86717: EQUAL
86718: IFTRUE 86722
86720: GO 87118
86722: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
86723: NOP4
86727: PPUSH
86728: NOP4
86732: PUSH
86733: LD_INT 1000
86735: EQUAL
86736: PUSH
86737: NOP4
86741: PPUSH
86742: NOP4
86746: PPUSH
86747: NOP4
86751: PUSH
86752: LD_INT 40
86754: LESS
86755: PUSH
86756: NOP4
86760: PPUSH
86761: NOP4
86765: PUSH
86766: NOP4
86770: ARRAY
86771: PPUSH
86772: NOP4
86776: OR
86777: AND
86778: IFFALSE 86900
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
86780: NOP4
86784: PPUSH
86785: NOP4
86789: PUSH
86790: LD_INT 1
86792: EQUAL
86793: PUSH
86794: NOP4
86798: PPUSH
86799: NOP4
86803: PUSH
86804: LD_INT 30
86806: LESS
86807: AND
86808: PUSH
86809: NOP4
86813: AND
86814: IFFALSE 86884
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
86816: NOP4
86820: PPUSH
86821: NOP4
86825: PPUSH
86826: NOP4
86830: PPUSH
86831: NOP4
86835: PPUSH
86836: NOP4
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
86840: NOP4
86844: PPUSH
86845: NOP4
86849: PPUSH
86850: NOP4
86854: PPUSH
86855: NOP4
86859: PPUSH
86860: NOP4
86864: PUSH
86865: LD_INT 6
86867: LESS
86868: IFFALSE 86882
// SetFuel ( i , 100 ) ;
86870: NOP4
86874: PPUSH
86875: LD_INT 100
86877: PPUSH
86878: NOP4
// end else
86882: GO 86898
// ComAttackUnit ( i , e ) ;
86884: NOP4
86888: PPUSH
86889: NOP4
86893: PPUSH
86894: NOP4
// end else
86898: GO 87001
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
86900: NOP4
86904: PPUSH
86905: NOP4
86909: PUSH
86910: NOP4
86914: ARRAY
86915: PPUSH
86916: NOP4
86920: NOT
86921: PUSH
86922: NOP4
86926: PPUSH
86927: NOP4
86931: PPUSH
86932: NOP4
86936: PUSH
86937: LD_INT 40
86939: GREATEREQUAL
86940: AND
86941: PUSH
86942: NOP4
86946: PPUSH
86947: NOP4
86951: PUSH
86952: LD_INT 650
86954: LESSEQUAL
86955: OR
86956: PUSH
86957: NOP4
86961: PPUSH
86962: NOP4
86966: PUSH
86967: NOP4
86971: ARRAY
86972: PPUSH
86973: NOP4
86977: NOT
86978: AND
86979: IFFALSE 87001
// ComMoveToArea ( i , mc_parking [ base ] ) ;
86981: NOP4
86985: PPUSH
86986: NOP4
86990: PUSH
86991: NOP4
86995: ARRAY
86996: PPUSH
86997: NOP4
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
87001: NOP4
87005: PPUSH
87006: NOP4
87010: PUSH
87011: LD_INT 1000
87013: LESS
87014: PUSH
87015: NOP4
87019: PPUSH
87020: NOP4
87024: PUSH
87025: LD_INT 1
87027: EQUAL
87028: AND
87029: PUSH
87030: NOP4
87034: PPUSH
87035: NOP4
87039: AND
87040: PUSH
87041: NOP4
87045: PPUSH
87046: NOP4
87050: PUSH
87051: NOP4
87055: ARRAY
87056: PPUSH
87057: NOP4
87061: AND
87062: IFFALSE 87116
// begin mech := IsDrivenBy ( i ) ;
87064: NOP4
87068: PUSH
87069: NOP4
87073: PPUSH
87074: NOP4
87078: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
87079: NOP4
87083: PPUSH
87084: NOP4
// AddComRepairVehicle ( mech , i ) ;
87088: NOP4
87092: PPUSH
87093: NOP4
87097: PPUSH
87098: NOP4
// AddComEnterUnit ( mech , i ) ;
87102: NOP4
87106: PPUSH
87107: NOP4
87111: PPUSH
87112: NOP4
// end ; end ; unit_human :
87116: GO 87463
87118: LD_INT 1
87120: DOUBLE
87121: EQUAL
87122: IFTRUE 87126
87124: GO 87462
87126: POP
// begin b := IsInUnit ( i ) ;
87127: NOP4
87131: PUSH
87132: NOP4
87136: PPUSH
87137: NOP4
87141: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
87142: NOP4
87146: PUSH
87147: NOP4
87151: NOT
87152: PUSH
87153: NOP4
87157: PPUSH
87158: NOP4
87162: PUSH
87163: LD_INT 32
87165: PUSH
87166: LD_INT 31
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: IN
87173: OR
87174: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
87175: NOP4
87179: PPUSH
87180: NOP4
87184: PUSH
87185: LD_INT 5
87187: EQUAL
87188: PUSH
87189: NOP4
87193: PPUSH
87194: NOP4
87198: PUSH
87199: LD_INT 1
87201: PUSH
87202: LD_INT 2
87204: PUSH
87205: LD_INT 3
87207: PUSH
87208: LD_INT 4
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: IN
87217: AND
87218: IFFALSE 87255
// begin class := AllowSpecClass ( i ) ;
87220: NOP4
87224: PUSH
87225: NOP4
87229: PPUSH
87230: NOP4
87234: ST_TO_ADDR
// if class then
87235: NOP4
87239: IFFALSE 87255
// ComChangeProfession ( i , class ) ;
87241: NOP4
87245: PPUSH
87246: NOP4
87250: PPUSH
87251: NOP4
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
87255: NOP4
87259: PUSH
87260: NOP4
87264: PPUSH
87265: LD_INT 21
87267: PUSH
87268: LD_INT 2
87270: PUSH
87271: EMPTY
87272: LIST
87273: LIST
87274: PPUSH
87275: NOP4
87279: PUSH
87280: LD_INT 1
87282: LESSEQUAL
87283: OR
87284: PUSH
87285: NOP4
87289: AND
87290: PUSH
87291: NOP4
87295: PUSH
87296: NOP4
87300: IN
87301: NOT
87302: AND
87303: IFFALSE 87396
// begin if b then
87305: NOP4
87309: IFFALSE 87358
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
87311: NOP4
87315: PPUSH
87316: NOP4
87320: PPUSH
87321: NOP4
87325: PPUSH
87326: NOP4
87330: PPUSH
87331: NOP4
87335: PUSH
87336: LD_INT 10
87338: LESS
87339: PUSH
87340: NOP4
87344: PPUSH
87345: NOP4
87349: PUSH
87350: LD_INT 7
87352: NONEQUAL
87353: AND
87354: IFFALSE 87358
// continue ;
87356: GO 86593
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
87358: NOP4
87362: PUSH
87363: NOP4
87367: PPUSH
87368: NOP4
87372: PUSH
87373: LD_INT 1
87375: PLUS
87376: PPUSH
87377: NOP4
87381: PPUSH
87382: NOP4
87386: ST_TO_ADDR
// ComExitBuilding ( i ) ;
87387: NOP4
87391: PPUSH
87392: NOP4
// end ; if sold_defenders then
87396: NOP4
87400: IFFALSE 87460
// if i in sold_defenders then
87402: NOP4
87406: PUSH
87407: NOP4
87411: IN
87412: IFFALSE 87460
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
87414: NOP4
87418: PPUSH
87419: NOP4
87423: NOT
87424: PUSH
87425: NOP4
87429: PPUSH
87430: NOP4
87434: PPUSH
87435: NOP4
87439: PUSH
87440: LD_INT 30
87442: LESS
87443: AND
87444: IFFALSE 87460
// ComAttackUnit ( i , e ) ;
87446: NOP4
87450: PPUSH
87451: NOP4
87455: PPUSH
87456: NOP4
// end ; end ; end ;
87460: GO 87463
87462: POP
// if IsDead ( i ) then
87463: NOP4
87467: PPUSH
87468: NOP4
87472: IFFALSE 87490
// defenders := defenders diff i ;
87474: NOP4
87478: PUSH
87479: NOP4
87483: PUSH
87484: NOP4
87488: DIFF
87489: ST_TO_ADDR
// end ;
87490: GO 86593
87492: POP
87493: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
87494: NOP4
87498: NOT
87499: PUSH
87500: NOP4
87504: NOT
87505: OR
87506: PUSH
87507: NOP4
87511: PUSH
87512: NOP4
87516: ARRAY
87517: NOT
87518: OR
87519: IFFALSE 86497
// MC_Reset ( base , 18 ) ;
87521: NOP4
87525: PPUSH
87526: LD_INT 18
87528: PPUSH
87529: NOP4
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87533: NOP4
87537: PUSH
87538: NOP4
87542: PUSH
87543: NOP4
87547: PPUSH
87548: LD_INT 2
87550: PUSH
87551: LD_INT 25
87553: PUSH
87554: LD_INT 1
87556: PUSH
87557: EMPTY
87558: LIST
87559: LIST
87560: PUSH
87561: LD_INT 25
87563: PUSH
87564: LD_INT 5
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: PUSH
87571: LD_INT 25
87573: PUSH
87574: LD_INT 8
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: PUSH
87581: LD_INT 25
87583: PUSH
87584: LD_INT 9
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: PUSH
87591: EMPTY
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: PPUSH
87598: NOP4
87602: DIFF
87603: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87604: NOP4
87608: NOT
87609: PUSH
87610: NOP4
87614: PPUSH
87615: LD_INT 21
87617: PUSH
87618: LD_INT 2
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PPUSH
87625: NOP4
87629: AND
87630: IFFALSE 87968
// begin tmp := FilterByTag ( defenders , 19 ) ;
87632: NOP4
87636: PUSH
87637: NOP4
87641: PPUSH
87642: LD_INT 19
87644: PPUSH
87645: NOP4
87649: ST_TO_ADDR
// if tmp then
87650: NOP4
87654: IFFALSE 87724
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87656: NOP4
87660: PUSH
87661: NOP4
87665: PPUSH
87666: LD_INT 25
87668: PUSH
87669: LD_INT 3
87671: PUSH
87672: EMPTY
87673: LIST
87674: LIST
87675: PPUSH
87676: NOP4
87680: ST_TO_ADDR
// if tmp then
87681: NOP4
87685: IFFALSE 87724
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87687: NOP4
87691: PUSH
87692: NOP4
87696: PPUSH
87697: NOP4
87701: PPUSH
87702: NOP4
87706: PUSH
87707: NOP4
87711: ARRAY
87712: PUSH
87713: NOP4
87717: UNION
87718: PPUSH
87719: NOP4
87723: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
87724: NOP4
87728: PPUSH
87729: LD_INT 19
87731: PPUSH
87732: NOP4
// repeat wait ( 0 0$1 ) ;
87736: LD_INT 35
87738: PPUSH
87739: NOP4
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87743: NOP4
87747: PUSH
87748: NOP4
87752: ARRAY
87753: NOT
87754: PUSH
87755: NOP4
87759: PUSH
87760: NOP4
87764: ARRAY
87765: PUSH
87766: EMPTY
87767: EQUAL
87768: OR
87769: IFFALSE 87806
// begin for i in defenders do
87771: NOP4
87775: PUSH
87776: NOP4
87780: PUSH
87781: FOR_IN
87782: IFFALSE 87795
// ComStop ( i ) ;
87784: NOP4
87788: PPUSH
87789: NOP4
87793: GO 87781
87795: POP
87796: POP
// defenders := [ ] ;
87797: NOP4
87801: PUSH
87802: EMPTY
87803: ST_TO_ADDR
// exit ;
87804: GO 88032
// end ; for i in defenders do
87806: NOP4
87810: PUSH
87811: NOP4
87815: PUSH
87816: FOR_IN
87817: IFFALSE 87906
// begin if not IsInArea ( i , mc_parking [ base ] ) then
87819: NOP4
87823: PPUSH
87824: NOP4
87828: PUSH
87829: NOP4
87833: ARRAY
87834: PPUSH
87835: NOP4
87839: NOT
87840: IFFALSE 87864
// ComMoveToArea ( i , mc_parking [ base ] ) else
87842: NOP4
87846: PPUSH
87847: NOP4
87851: PUSH
87852: NOP4
87856: ARRAY
87857: PPUSH
87858: NOP4
87862: GO 87904
// if GetControl ( i ) = control_manual then
87864: NOP4
87868: PPUSH
87869: NOP4
87873: PUSH
87874: LD_INT 1
87876: EQUAL
87877: IFFALSE 87904
// if IsDrivenBy ( i ) then
87879: NOP4
87883: PPUSH
87884: NOP4
87888: IFFALSE 87904
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
87890: NOP4
87894: PPUSH
87895: NOP4
87899: PPUSH
87900: NOP4
// end ;
87904: GO 87816
87906: POP
87907: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
87908: NOP4
87912: PPUSH
87913: LD_INT 95
87915: PUSH
87916: NOP4
87920: PUSH
87921: NOP4
87925: ARRAY
87926: PUSH
87927: EMPTY
87928: LIST
87929: LIST
87930: PPUSH
87931: NOP4
87935: PUSH
87936: NOP4
87940: EQUAL
87941: PUSH
87942: NOP4
87946: PUSH
87947: NOP4
87951: ARRAY
87952: OR
87953: PUSH
87954: NOP4
87958: PUSH
87959: NOP4
87963: ARRAY
87964: NOT
87965: OR
87966: IFFALSE 87736
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
87968: NOP4
87972: PUSH
87973: NOP4
87977: PPUSH
87978: NOP4
87982: PPUSH
87983: NOP4
87987: PPUSH
87988: LD_INT 21
87990: PUSH
87991: LD_INT 2
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PPUSH
87998: NOP4
88002: PPUSH
88003: NOP4
88007: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
88008: NOP4
88012: PPUSH
88013: LD_INT 19
88015: PPUSH
88016: NOP4
// MC_Reset ( base , 20 ) ;
88020: NOP4
88024: PPUSH
88025: LD_INT 20
88027: PPUSH
88028: NOP4
// end ; end_of_file
88032: LD_VAR 0 3
88036: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
88037: LD_INT 0
88039: PPUSH
88040: PPUSH
88041: PPUSH
88042: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
88043: NOP4
88047: PPUSH
88048: NOP4
88052: PUSH
88053: NOP4
88057: EQUAL
88058: IFFALSE 88130
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
88060: LD_INT 68
88062: PPUSH
88063: NOP4
88067: PPUSH
88068: NOP4
88072: PPUSH
88073: NOP4
88077: PUSH
88078: LD_INT 2
88080: EQUAL
88081: IFFALSE 88093
// eff := 70 else
88083: NOP4
88087: PUSH
88088: LD_INT 70
88090: ST_TO_ADDR
88091: GO 88101
// eff := 30 ;
88093: NOP4
88097: PUSH
88098: LD_INT 30
88100: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
88101: NOP4
88105: PPUSH
88106: NOP4
88110: PPUSH
88111: NOP4
88115: PPUSH
88116: NOP4
88120: PPUSH
88121: NOP4
88125: PPUSH
88126: NOP4
// end ; end ;
88130: LD_VAR 0 2
88134: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
88135: LD_INT 0
88137: PPUSH
// end ;
88138: LD_VAR 0 4
88142: RET
// export function SOS_Command ( cmd ) ; begin
88143: LD_INT 0
88145: PPUSH
// end ;
88146: LD_VAR 0 2
88150: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
88151: LD_INT 0
88153: PPUSH
// end ;
88154: LD_VAR 0 6
88158: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
88159: LD_INT 0
88161: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
88162: NOP4
88166: PUSH
88167: LD_INT 250
88169: EQUAL
88170: PUSH
88171: NOP4
88175: PPUSH
88176: NOP4
88180: PUSH
88181: NOP4
88185: EQUAL
88186: AND
88187: IFFALSE 88208
// MinerPlaceMine ( unit , x , y ) ;
88189: NOP4
88193: PPUSH
88194: NOP4
88198: PPUSH
88199: NOP4
88203: PPUSH
88204: NOP4
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
88208: NOP4
88212: PUSH
88213: LD_INT 251
88215: EQUAL
88216: PUSH
88217: NOP4
88221: PPUSH
88222: NOP4
88226: PUSH
88227: NOP4
88231: EQUAL
88232: AND
88233: IFFALSE 88254
// MinerDetonateMine ( unit , x , y ) ;
88235: NOP4
88239: PPUSH
88240: NOP4
88244: PPUSH
88245: NOP4
88249: PPUSH
88250: NOP4
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
88254: NOP4
88258: PUSH
88259: LD_INT 252
88261: EQUAL
88262: PUSH
88263: NOP4
88267: PPUSH
88268: NOP4
88272: PUSH
88273: NOP4
88277: EQUAL
88278: AND
88279: IFFALSE 88300
// MinerCreateMinefield ( unit , x , y ) ;
88281: NOP4
88285: PPUSH
88286: NOP4
88290: PPUSH
88291: NOP4
88295: PPUSH
88296: NOP4
// if cmd = 253 and GetClass ( unit ) = class_sniper then
88300: NOP4
88304: PUSH
88305: LD_INT 253
88307: EQUAL
88308: PUSH
88309: NOP4
88313: PPUSH
88314: NOP4
88318: PUSH
88319: LD_INT 5
88321: EQUAL
88322: AND
88323: IFFALSE 88344
// ComBinocular ( unit , x , y ) ;
88325: NOP4
88329: PPUSH
88330: NOP4
88334: PPUSH
88335: NOP4
88339: PPUSH
88340: NOP4
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
88344: NOP4
88348: PUSH
88349: LD_INT 254
88351: EQUAL
88352: PUSH
88353: NOP4
88357: PPUSH
88358: NOP4
88362: PUSH
88363: NOP4
88367: EQUAL
88368: AND
88369: PUSH
88370: NOP4
88374: PPUSH
88375: NOP4
88379: PUSH
88380: LD_INT 3
88382: EQUAL
88383: AND
88384: IFFALSE 88400
// HackDestroyVehicle ( unit , selectedUnit ) ;
88386: NOP4
88390: PPUSH
88391: NOP4
88395: PPUSH
88396: NOP4
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
88400: NOP4
88404: PUSH
88405: LD_INT 255
88407: EQUAL
88408: PUSH
88409: NOP4
88413: PPUSH
88414: NOP4
88418: PUSH
88419: LD_INT 14
88421: PUSH
88422: LD_INT 53
88424: PUSH
88425: EMPTY
88426: LIST
88427: LIST
88428: IN
88429: AND
88430: PUSH
88431: NOP4
88435: PPUSH
88436: NOP4
88440: PPUSH
88441: NOP4
88445: AND
88446: IFFALSE 88470
// CutTreeXYR ( unit , x , y , 12 ) ;
88448: NOP4
88452: PPUSH
88453: NOP4
88457: PPUSH
88458: NOP4
88462: PPUSH
88463: LD_INT 12
88465: PPUSH
88466: NOP4
// end ;
88470: LD_VAR 0 6
88474: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
88475: LD_INT 0
88477: PPUSH
// end ;
88478: LD_VAR 0 4
88482: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
88483: LD_INT 0
88485: PPUSH
88486: PPUSH
88487: PPUSH
88488: PPUSH
88489: PPUSH
88490: PPUSH
88491: PPUSH
88492: PPUSH
88493: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
88494: NOP4
88498: NOT
88499: PUSH
88500: NOP4
88504: PPUSH
88505: NOP4
88509: PPUSH
88510: NOP4
88514: NOT
88515: OR
88516: PUSH
88517: NOP4
88521: NOT
88522: OR
88523: IFFALSE 88527
// exit ;
88525: GO 88867
// list := [ ] ;
88527: NOP4
88531: PUSH
88532: EMPTY
88533: ST_TO_ADDR
// if x - r < 0 then
88534: NOP4
88538: PUSH
88539: NOP4
88543: MINUS
88544: PUSH
88545: LD_INT 0
88547: LESS
88548: IFFALSE 88560
// min_x := 0 else
88550: NOP4
88554: PUSH
88555: LD_INT 0
88557: ST_TO_ADDR
88558: GO 88576
// min_x := x - r ;
88560: NOP4
88564: PUSH
88565: NOP4
88569: PUSH
88570: NOP4
88574: MINUS
88575: ST_TO_ADDR
// if y - r < 0 then
88576: NOP4
88580: PUSH
88581: NOP4
88585: MINUS
88586: PUSH
88587: LD_INT 0
88589: LESS
88590: IFFALSE 88602
// min_y := 0 else
88592: NOP4
88596: PUSH
88597: LD_INT 0
88599: ST_TO_ADDR
88600: GO 88618
// min_y := y - r ;
88602: NOP4
88606: PUSH
88607: NOP4
88611: PUSH
88612: NOP4
88616: MINUS
88617: ST_TO_ADDR
// max_x := x + r ;
88618: NOP4
88622: PUSH
88623: NOP4
88627: PUSH
88628: NOP4
88632: PLUS
88633: ST_TO_ADDR
// max_y := y + r ;
88634: NOP4
88638: PUSH
88639: NOP4
88643: PUSH
88644: NOP4
88648: PLUS
88649: ST_TO_ADDR
// for _x = min_x to max_x do
88650: NOP4
88654: PUSH
88655: DOUBLE
88656: NOP4
88660: DEC
88661: ST_TO_ADDR
88662: NOP4
88666: PUSH
88667: FOR_TO
88668: IFFALSE 88785
// for _y = min_y to max_y do
88670: NOP4
88674: PUSH
88675: DOUBLE
88676: NOP4
88680: DEC
88681: ST_TO_ADDR
88682: NOP4
88686: PUSH
88687: FOR_TO
88688: IFFALSE 88781
// begin if not ValidHex ( _x , _y ) then
88690: NOP4
88694: PPUSH
88695: NOP4
88699: PPUSH
88700: NOP4
88704: NOT
88705: IFFALSE 88709
// continue ;
88707: GO 88687
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
88709: NOP4
88713: PPUSH
88714: NOP4
88718: PPUSH
88719: NOP4
88723: PUSH
88724: NOP4
88728: PPUSH
88729: NOP4
88733: PPUSH
88734: NOP4
88738: AND
88739: IFFALSE 88779
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
88741: NOP4
88745: PUSH
88746: NOP4
88750: PPUSH
88751: NOP4
88755: PUSH
88756: LD_INT 1
88758: PLUS
88759: PPUSH
88760: NOP4
88764: PUSH
88765: NOP4
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PPUSH
88774: NOP4
88778: ST_TO_ADDR
// end ;
88779: GO 88687
88781: POP
88782: POP
88783: GO 88667
88785: POP
88786: POP
// if not list then
88787: NOP4
88791: NOT
88792: IFFALSE 88796
// exit ;
88794: GO 88867
// for i in list do
88796: NOP4
88800: PUSH
88801: NOP4
88805: PUSH
88806: FOR_IN
88807: IFFALSE 88865
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88809: NOP4
88813: PPUSH
88814: LD_STRING M
88816: PUSH
88817: NOP4
88821: PUSH
88822: LD_INT 1
88824: ARRAY
88825: PUSH
88826: NOP4
88830: PUSH
88831: LD_INT 2
88833: ARRAY
88834: PUSH
88835: LD_INT 0
88837: PUSH
88838: LD_INT 0
88840: PUSH
88841: LD_INT 0
88843: PUSH
88844: LD_INT 0
88846: PUSH
88847: EMPTY
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: PUSH
88856: EMPTY
88857: LIST
88858: PPUSH
88859: NOP4
88863: GO 88806
88865: POP
88866: POP
// end ;
88867: LD_VAR 0 5
88871: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
88872: NOP4
88876: NOT
88877: IFFALSE 88927
88879: GO 88881
88881: DISABLE
// begin initHack := true ;
88882: NOP4
88886: PUSH
88887: LD_INT 1
88889: ST_TO_ADDR
// hackTanks := [ ] ;
88890: NOP4
88894: PUSH
88895: EMPTY
88896: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
88897: NOP4
88901: PUSH
88902: EMPTY
88903: ST_TO_ADDR
// hackLimit := 3 ;
88904: NOP4
88908: PUSH
88909: LD_INT 3
88911: ST_TO_ADDR
// hackDist := 12 ;
88912: NOP4
88916: PUSH
88917: LD_INT 12
88919: ST_TO_ADDR
// hackCounter := [ ] ;
88920: NOP4
88924: PUSH
88925: EMPTY
88926: ST_TO_ADDR
// end ;
88927: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
88928: NOP4
88932: PUSH
88933: LD_INT 34
88935: PUSH
88936: NOP4
88940: PUSH
88941: EMPTY
88942: LIST
88943: LIST
88944: PPUSH
88945: NOP4
88949: AND
88950: IFFALSE 89205
88952: GO 88954
88954: DISABLE
88955: LD_INT 0
88957: PPUSH
88958: PPUSH
// begin enable ;
88959: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
88960: NOP4
88964: PUSH
88965: LD_INT 34
88967: PUSH
88968: NOP4
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PPUSH
88977: NOP4
88981: PUSH
88982: FOR_IN
88983: IFFALSE 89203
// begin if not i in hackTanks then
88985: NOP4
88989: PUSH
88990: NOP4
88994: IN
88995: NOT
88996: IFFALSE 89079
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
88998: NOP4
89002: PUSH
89003: NOP4
89007: PPUSH
89008: NOP4
89012: PUSH
89013: LD_INT 1
89015: PLUS
89016: PPUSH
89017: NOP4
89021: PPUSH
89022: NOP4
89026: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
89027: NOP4
89031: PUSH
89032: NOP4
89036: PPUSH
89037: NOP4
89041: PUSH
89042: LD_INT 1
89044: PLUS
89045: PPUSH
89046: EMPTY
89047: PPUSH
89048: NOP4
89052: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
89053: NOP4
89057: PUSH
89058: NOP4
89062: PPUSH
89063: NOP4
89067: PUSH
89068: LD_INT 1
89070: PLUS
89071: PPUSH
89072: EMPTY
89073: PPUSH
89074: NOP4
89078: ST_TO_ADDR
// end ; if not IsOk ( i ) then
89079: NOP4
89083: PPUSH
89084: NOP4
89088: NOT
89089: IFFALSE 89102
// begin HackUnlinkAll ( i ) ;
89091: NOP4
89095: PPUSH
89096: NOP4
// continue ;
89100: GO 88982
// end ; HackCheckCapturedStatus ( i ) ;
89102: NOP4
89106: PPUSH
89107: NOP4
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
89111: NOP4
89115: PUSH
89116: LD_INT 81
89118: PUSH
89119: NOP4
89123: PPUSH
89124: NOP4
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: PUSH
89133: LD_INT 33
89135: PUSH
89136: LD_INT 3
89138: PUSH
89139: EMPTY
89140: LIST
89141: LIST
89142: PUSH
89143: LD_INT 91
89145: PUSH
89146: NOP4
89150: PUSH
89151: NOP4
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 50
89163: PUSH
89164: EMPTY
89165: LIST
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: PPUSH
89173: NOP4
89177: ST_TO_ADDR
// if not tmp then
89178: NOP4
89182: NOT
89183: IFFALSE 89187
// continue ;
89185: GO 88982
// HackLink ( i , tmp ) ;
89187: NOP4
89191: PPUSH
89192: NOP4
89196: PPUSH
89197: NOP4
// end ;
89201: GO 88982
89203: POP
89204: POP
// end ;
89205: PPOPN 2
89207: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
89208: LD_INT 0
89210: PPUSH
89211: PPUSH
89212: PPUSH
// if not hack in hackTanks then
89213: NOP4
89217: PUSH
89218: NOP4
89222: IN
89223: NOT
89224: IFFALSE 89228
// exit ;
89226: GO 89339
// index := GetElementIndex ( hackTanks , hack ) ;
89228: NOP4
89232: PUSH
89233: NOP4
89237: PPUSH
89238: NOP4
89242: PPUSH
89243: NOP4
89247: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
89248: NOP4
89252: PUSH
89253: NOP4
89257: ARRAY
89258: IFFALSE 89339
// begin for i in hackTanksCaptured [ index ] do
89260: NOP4
89264: PUSH
89265: NOP4
89269: PUSH
89270: NOP4
89274: ARRAY
89275: PUSH
89276: FOR_IN
89277: IFFALSE 89303
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
89279: NOP4
89283: PUSH
89284: LD_INT 1
89286: ARRAY
89287: PPUSH
89288: NOP4
89292: PUSH
89293: LD_INT 2
89295: ARRAY
89296: PPUSH
89297: NOP4
89301: GO 89276
89303: POP
89304: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
89305: NOP4
89309: PUSH
89310: NOP4
89314: PPUSH
89315: NOP4
89319: PPUSH
89320: EMPTY
89321: PPUSH
89322: NOP4
89326: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
89327: NOP4
89331: PPUSH
89332: LD_INT 0
89334: PPUSH
89335: NOP4
// end ; end ;
89339: LD_VAR 0 2
89343: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
89344: LD_INT 0
89346: PPUSH
89347: PPUSH
89348: PPUSH
// if not hack in hackTanks or not vehicles then
89349: NOP4
89353: PUSH
89354: NOP4
89358: IN
89359: NOT
89360: PUSH
89361: NOP4
89365: NOT
89366: OR
89367: IFFALSE 89371
// exit ;
89369: GO 89646
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
89371: NOP4
89375: PUSH
89376: NOP4
89380: PPUSH
89381: NOP4
89385: PPUSH
89386: LD_INT 1
89388: PPUSH
89389: LD_INT 1
89391: PPUSH
89392: NOP4
89396: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
89397: NOP4
89401: PUSH
89402: NOP4
89406: PPUSH
89407: NOP4
89411: PPUSH
89412: NOP4
89416: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
89417: NOP4
89421: PUSH
89422: NOP4
89426: ARRAY
89427: PUSH
89428: NOP4
89432: LESS
89433: IFFALSE 89622
// begin for i := 1 to vehicles do
89435: NOP4
89439: PUSH
89440: DOUBLE
89441: LD_INT 1
89443: DEC
89444: ST_TO_ADDR
89445: NOP4
89449: PUSH
89450: FOR_TO
89451: IFFALSE 89620
// begin if hackTanksCaptured [ index ] = hackLimit then
89453: NOP4
89457: PUSH
89458: NOP4
89462: ARRAY
89463: PUSH
89464: NOP4
89468: EQUAL
89469: IFFALSE 89473
// break ;
89471: GO 89620
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
89473: NOP4
89477: PUSH
89478: NOP4
89482: PPUSH
89483: NOP4
89487: PPUSH
89488: NOP4
89492: PUSH
89493: NOP4
89497: ARRAY
89498: PUSH
89499: LD_INT 1
89501: PLUS
89502: PPUSH
89503: NOP4
89507: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
89508: NOP4
89512: PUSH
89513: NOP4
89517: PPUSH
89518: NOP4
89522: PUSH
89523: NOP4
89527: PUSH
89528: NOP4
89532: ARRAY
89533: PUSH
89534: LD_INT 1
89536: PLUS
89537: PUSH
89538: EMPTY
89539: LIST
89540: LIST
89541: PPUSH
89542: NOP4
89546: PUSH
89547: NOP4
89551: ARRAY
89552: PUSH
89553: NOP4
89557: PUSH
89558: NOP4
89562: ARRAY
89563: PPUSH
89564: NOP4
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PPUSH
89573: NOP4
89577: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
89578: NOP4
89582: PUSH
89583: NOP4
89587: ARRAY
89588: PPUSH
89589: NOP4
89593: PPUSH
89594: NOP4
89598: PPUSH
89599: NOP4
// ComStop ( vehicles [ i ] ) ;
89603: NOP4
89607: PUSH
89608: NOP4
89612: ARRAY
89613: PPUSH
89614: NOP4
// end ;
89618: GO 89450
89620: POP
89621: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
89622: NOP4
89626: PPUSH
89627: NOP4
89631: PUSH
89632: NOP4
89636: ARRAY
89637: PUSH
89638: LD_INT 0
89640: PLUS
89641: PPUSH
89642: NOP4
// end ;
89646: LD_VAR 0 3
89650: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
89651: LD_INT 0
89653: PPUSH
89654: PPUSH
89655: PPUSH
89656: PPUSH
// if not hack in hackTanks then
89657: NOP4
89661: PUSH
89662: NOP4
89666: IN
89667: NOT
89668: IFFALSE 89672
// exit ;
89670: GO 89912
// index := GetElementIndex ( hackTanks , hack ) ;
89672: NOP4
89676: PUSH
89677: NOP4
89681: PPUSH
89682: NOP4
89686: PPUSH
89687: NOP4
89691: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
89692: NOP4
89696: PUSH
89697: DOUBLE
89698: NOP4
89702: PUSH
89703: NOP4
89707: ARRAY
89708: INC
89709: ST_TO_ADDR
89710: LD_INT 1
89712: PUSH
89713: FOR_DOWNTO
89714: IFFALSE 89886
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
89716: NOP4
89720: PUSH
89721: NOP4
89725: PUSH
89726: NOP4
89730: ARRAY
89731: PUSH
89732: NOP4
89736: ARRAY
89737: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
89738: NOP4
89742: PUSH
89743: LD_INT 1
89745: ARRAY
89746: PPUSH
89747: NOP4
89751: NOT
89752: PUSH
89753: NOP4
89757: PUSH
89758: LD_INT 1
89760: ARRAY
89761: PPUSH
89762: NOP4
89766: PUSH
89767: NOP4
89771: PPUSH
89772: NOP4
89776: NONEQUAL
89777: OR
89778: IFFALSE 89884
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
89780: NOP4
89784: PUSH
89785: LD_INT 1
89787: ARRAY
89788: PPUSH
89789: NOP4
89793: PUSH
89794: NOP4
89798: PUSH
89799: LD_INT 1
89801: ARRAY
89802: PPUSH
89803: NOP4
89807: PUSH
89808: NOP4
89812: PPUSH
89813: NOP4
89817: EQUAL
89818: AND
89819: IFFALSE 89843
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
89821: NOP4
89825: PUSH
89826: LD_INT 1
89828: ARRAY
89829: PPUSH
89830: NOP4
89834: PUSH
89835: LD_INT 2
89837: ARRAY
89838: PPUSH
89839: NOP4
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
89843: NOP4
89847: PUSH
89848: NOP4
89852: PPUSH
89853: NOP4
89857: PPUSH
89858: NOP4
89862: PUSH
89863: NOP4
89867: ARRAY
89868: PPUSH
89869: NOP4
89873: PPUSH
89874: NOP4
89878: PPUSH
89879: NOP4
89883: ST_TO_ADDR
// end ; end ;
89884: GO 89713
89886: POP
89887: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
89888: NOP4
89892: PPUSH
89893: NOP4
89897: PUSH
89898: NOP4
89902: ARRAY
89903: PUSH
89904: LD_INT 0
89906: PLUS
89907: PPUSH
89908: NOP4
// end ;
89912: LD_VAR 0 2
89916: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
89917: LD_INT 0
89919: PPUSH
89920: PPUSH
89921: PPUSH
89922: PPUSH
// if not hack in hackTanks then
89923: NOP4
89927: PUSH
89928: NOP4
89932: IN
89933: NOT
89934: IFFALSE 89938
// exit ;
89936: GO 90023
// index := GetElementIndex ( hackTanks , hack ) ;
89938: NOP4
89942: PUSH
89943: NOP4
89947: PPUSH
89948: NOP4
89952: PPUSH
89953: NOP4
89957: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
89958: NOP4
89962: PUSH
89963: DOUBLE
89964: LD_INT 1
89966: DEC
89967: ST_TO_ADDR
89968: NOP4
89972: PUSH
89973: NOP4
89977: ARRAY
89978: PUSH
89979: FOR_TO
89980: IFFALSE 90021
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
89982: NOP4
89986: PUSH
89987: NOP4
89991: ARRAY
89992: PUSH
89993: NOP4
89997: ARRAY
89998: PUSH
89999: LD_INT 1
90001: ARRAY
90002: PUSH
90003: NOP4
90007: EQUAL
90008: IFFALSE 90019
// KillUnit ( vehicle ) ;
90010: NOP4
90014: PPUSH
90015: NOP4
90019: GO 89979
90021: POP
90022: POP
// end ;
90023: LD_VAR 0 3
90027: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
90028: NOP4
90032: NOT
90033: IFFALSE 90068
90035: GO 90037
90037: DISABLE
// begin initMiner := true ;
90038: NOP4
90042: PUSH
90043: LD_INT 1
90045: ST_TO_ADDR
// minersList := [ ] ;
90046: NOP4
90050: PUSH
90051: EMPTY
90052: ST_TO_ADDR
// minerMinesList := [ ] ;
90053: NOP4
90057: PUSH
90058: EMPTY
90059: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
90060: NOP4
90064: PUSH
90065: LD_INT 5
90067: ST_TO_ADDR
// end ;
90068: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
90069: NOP4
90073: PUSH
90074: LD_INT 34
90076: PUSH
90077: NOP4
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: PPUSH
90086: NOP4
90090: AND
90091: IFFALSE 90554
90093: GO 90095
90095: DISABLE
90096: LD_INT 0
90098: PPUSH
90099: PPUSH
90100: PPUSH
90101: PPUSH
// begin enable ;
90102: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
90103: NOP4
90107: PUSH
90108: LD_INT 34
90110: PUSH
90111: NOP4
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PPUSH
90120: NOP4
90124: PUSH
90125: FOR_IN
90126: IFFALSE 90198
// begin if not i in minersList then
90128: NOP4
90132: PUSH
90133: NOP4
90137: IN
90138: NOT
90139: IFFALSE 90196
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
90141: NOP4
90145: PUSH
90146: NOP4
90150: PPUSH
90151: NOP4
90155: PUSH
90156: LD_INT 1
90158: PLUS
90159: PPUSH
90160: NOP4
90164: PPUSH
90165: NOP4
90169: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
90170: NOP4
90174: PUSH
90175: NOP4
90179: PPUSH
90180: NOP4
90184: PUSH
90185: LD_INT 1
90187: PLUS
90188: PPUSH
90189: EMPTY
90190: PPUSH
90191: NOP4
90195: ST_TO_ADDR
// end end ;
90196: GO 90125
90198: POP
90199: POP
// for i := minerMinesList downto 1 do
90200: NOP4
90204: PUSH
90205: DOUBLE
90206: NOP4
90210: INC
90211: ST_TO_ADDR
90212: LD_INT 1
90214: PUSH
90215: FOR_DOWNTO
90216: IFFALSE 90552
// begin if IsLive ( minersList [ i ] ) then
90218: NOP4
90222: PUSH
90223: NOP4
90227: ARRAY
90228: PPUSH
90229: NOP4
90233: IFFALSE 90261
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
90235: NOP4
90239: PUSH
90240: NOP4
90244: ARRAY
90245: PPUSH
90246: NOP4
90250: PUSH
90251: NOP4
90255: ARRAY
90256: PPUSH
90257: NOP4
// if not minerMinesList [ i ] then
90261: NOP4
90265: PUSH
90266: NOP4
90270: ARRAY
90271: NOT
90272: IFFALSE 90276
// continue ;
90274: GO 90215
// for j := minerMinesList [ i ] downto 1 do
90276: NOP4
90280: PUSH
90281: DOUBLE
90282: NOP4
90286: PUSH
90287: NOP4
90291: ARRAY
90292: INC
90293: ST_TO_ADDR
90294: LD_INT 1
90296: PUSH
90297: FOR_DOWNTO
90298: IFFALSE 90548
// begin side := GetSide ( minersList [ i ] ) ;
90300: NOP4
90304: PUSH
90305: NOP4
90309: PUSH
90310: NOP4
90314: ARRAY
90315: PPUSH
90316: NOP4
90320: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
90321: NOP4
90325: PUSH
90326: NOP4
90330: PUSH
90331: NOP4
90335: ARRAY
90336: PUSH
90337: NOP4
90341: ARRAY
90342: PUSH
90343: LD_INT 1
90345: ARRAY
90346: PPUSH
90347: NOP4
90351: PUSH
90352: NOP4
90356: ARRAY
90357: PUSH
90358: NOP4
90362: ARRAY
90363: PUSH
90364: LD_INT 2
90366: ARRAY
90367: PPUSH
90368: NOP4
90372: ST_TO_ADDR
// if not tmp then
90373: NOP4
90377: NOT
90378: IFFALSE 90382
// continue ;
90380: GO 90297
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
90382: NOP4
90386: PUSH
90387: LD_INT 81
90389: PUSH
90390: NOP4
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PPUSH
90399: NOP4
90403: IN
90404: PUSH
90405: NOP4
90409: PUSH
90410: NOP4
90414: ARRAY
90415: PUSH
90416: NOP4
90420: ARRAY
90421: PUSH
90422: LD_INT 1
90424: ARRAY
90425: PPUSH
90426: NOP4
90430: PUSH
90431: NOP4
90435: ARRAY
90436: PUSH
90437: NOP4
90441: ARRAY
90442: PUSH
90443: LD_INT 2
90445: ARRAY
90446: PPUSH
90447: NOP4
90451: AND
90452: IFFALSE 90546
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
90454: NOP4
90458: PUSH
90459: NOP4
90463: ARRAY
90464: PUSH
90465: NOP4
90469: ARRAY
90470: PUSH
90471: LD_INT 1
90473: ARRAY
90474: PPUSH
90475: NOP4
90479: PUSH
90480: NOP4
90484: ARRAY
90485: PUSH
90486: NOP4
90490: ARRAY
90491: PUSH
90492: LD_INT 2
90494: ARRAY
90495: PPUSH
90496: NOP4
90500: PPUSH
90501: NOP4
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
90505: NOP4
90509: PUSH
90510: NOP4
90514: PPUSH
90515: NOP4
90519: PPUSH
90520: NOP4
90524: PUSH
90525: NOP4
90529: ARRAY
90530: PPUSH
90531: NOP4
90535: PPUSH
90536: NOP4
90540: PPUSH
90541: NOP4
90545: ST_TO_ADDR
// end ; end ;
90546: GO 90297
90548: POP
90549: POP
// end ;
90550: GO 90215
90552: POP
90553: POP
// end ;
90554: PPOPN 4
90556: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
90557: LD_INT 0
90559: PPUSH
90560: PPUSH
// result := false ;
90561: NOP4
90565: PUSH
90566: LD_INT 0
90568: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
90569: NOP4
90573: PPUSH
90574: NOP4
90578: PUSH
90579: NOP4
90583: EQUAL
90584: NOT
90585: IFFALSE 90589
// exit ;
90587: GO 90829
// index := GetElementIndex ( minersList , unit ) ;
90589: NOP4
90593: PUSH
90594: NOP4
90598: PPUSH
90599: NOP4
90603: PPUSH
90604: NOP4
90608: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
90609: NOP4
90613: PUSH
90614: NOP4
90618: ARRAY
90619: PUSH
90620: NOP4
90624: GREATEREQUAL
90625: IFFALSE 90629
// exit ;
90627: GO 90829
// ComMoveXY ( unit , x , y ) ;
90629: NOP4
90633: PPUSH
90634: NOP4
90638: PPUSH
90639: NOP4
90643: PPUSH
90644: NOP4
// repeat wait ( 0 0$1 ) ;
90648: LD_INT 35
90650: PPUSH
90651: NOP4
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
90655: NOP4
90659: PPUSH
90660: NOP4
90664: PPUSH
90665: NOP4
90669: PPUSH
90670: NOP4
90674: NOT
90675: PUSH
90676: NOP4
90680: PPUSH
90681: NOP4
90685: AND
90686: IFFALSE 90690
// exit ;
90688: GO 90829
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
90690: NOP4
90694: PPUSH
90695: NOP4
90699: PPUSH
90700: NOP4
90704: PUSH
90705: NOP4
90709: EQUAL
90710: PUSH
90711: NOP4
90715: PPUSH
90716: NOP4
90720: NOT
90721: AND
90722: IFFALSE 90648
// PlaySoundXY ( x , y , PlantMine ) ;
90724: NOP4
90728: PPUSH
90729: NOP4
90733: PPUSH
90734: LD_STRING PlantMine
90736: PPUSH
90737: NOP4
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
90741: NOP4
90745: PPUSH
90746: NOP4
90750: PPUSH
90751: NOP4
90755: PPUSH
90756: NOP4
90760: PPUSH
90761: LD_INT 0
90763: PPUSH
90764: NOP4
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
90768: NOP4
90772: PUSH
90773: NOP4
90777: PPUSH
90778: NOP4
90782: PUSH
90783: NOP4
90787: PUSH
90788: NOP4
90792: ARRAY
90793: PUSH
90794: LD_INT 1
90796: PLUS
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: PPUSH
90802: NOP4
90806: PUSH
90807: NOP4
90811: PUSH
90812: EMPTY
90813: LIST
90814: LIST
90815: PPUSH
90816: NOP4
90820: ST_TO_ADDR
// result := true ;
90821: NOP4
90825: PUSH
90826: LD_INT 1
90828: ST_TO_ADDR
// end ;
90829: LD_VAR 0 4
90833: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
90834: LD_INT 0
90836: PPUSH
90837: PPUSH
90838: PPUSH
// if not unit in minersList then
90839: NOP4
90843: PUSH
90844: NOP4
90848: IN
90849: NOT
90850: IFFALSE 90854
// exit ;
90852: GO 91246
// index := GetElementIndex ( minersList , unit ) ;
90854: NOP4
90858: PUSH
90859: NOP4
90863: PPUSH
90864: NOP4
90868: PPUSH
90869: NOP4
90873: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
90874: NOP4
90878: PUSH
90879: DOUBLE
90880: NOP4
90884: PUSH
90885: NOP4
90889: ARRAY
90890: INC
90891: ST_TO_ADDR
90892: LD_INT 1
90894: PUSH
90895: FOR_DOWNTO
90896: IFFALSE 91057
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
90898: NOP4
90902: PUSH
90903: NOP4
90907: ARRAY
90908: PUSH
90909: NOP4
90913: ARRAY
90914: PUSH
90915: LD_INT 1
90917: ARRAY
90918: PUSH
90919: NOP4
90923: EQUAL
90924: PUSH
90925: NOP4
90929: PUSH
90930: NOP4
90934: ARRAY
90935: PUSH
90936: NOP4
90940: ARRAY
90941: PUSH
90942: LD_INT 2
90944: ARRAY
90945: PUSH
90946: NOP4
90950: EQUAL
90951: AND
90952: IFFALSE 91055
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
90954: NOP4
90958: PUSH
90959: NOP4
90963: ARRAY
90964: PUSH
90965: NOP4
90969: ARRAY
90970: PUSH
90971: LD_INT 1
90973: ARRAY
90974: PPUSH
90975: NOP4
90979: PUSH
90980: NOP4
90984: ARRAY
90985: PUSH
90986: NOP4
90990: ARRAY
90991: PUSH
90992: LD_INT 2
90994: ARRAY
90995: PPUSH
90996: NOP4
91000: PPUSH
91001: NOP4
91005: PPUSH
91006: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
91010: NOP4
91014: PUSH
91015: NOP4
91019: PPUSH
91020: NOP4
91024: PPUSH
91025: NOP4
91029: PUSH
91030: NOP4
91034: ARRAY
91035: PPUSH
91036: NOP4
91040: PPUSH
91041: NOP4
91045: PPUSH
91046: NOP4
91050: ST_TO_ADDR
// exit ;
91051: POP
91052: POP
91053: GO 91246
// end ; end ;
91055: GO 90895
91057: POP
91058: POP
// for i := minerMinesList [ index ] downto 1 do
91059: NOP4
91063: PUSH
91064: DOUBLE
91065: NOP4
91069: PUSH
91070: NOP4
91074: ARRAY
91075: INC
91076: ST_TO_ADDR
91077: LD_INT 1
91079: PUSH
91080: FOR_DOWNTO
91081: IFFALSE 91244
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
91083: NOP4
91087: PUSH
91088: NOP4
91092: ARRAY
91093: PUSH
91094: NOP4
91098: ARRAY
91099: PUSH
91100: LD_INT 1
91102: ARRAY
91103: PPUSH
91104: NOP4
91108: PUSH
91109: NOP4
91113: ARRAY
91114: PUSH
91115: NOP4
91119: ARRAY
91120: PUSH
91121: LD_INT 2
91123: ARRAY
91124: PPUSH
91125: NOP4
91129: PPUSH
91130: NOP4
91134: PPUSH
91135: NOP4
91139: PUSH
91140: LD_INT 6
91142: LESS
91143: IFFALSE 91242
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
91145: NOP4
91149: PUSH
91150: NOP4
91154: ARRAY
91155: PUSH
91156: NOP4
91160: ARRAY
91161: PUSH
91162: LD_INT 1
91164: ARRAY
91165: PPUSH
91166: NOP4
91170: PUSH
91171: NOP4
91175: ARRAY
91176: PUSH
91177: NOP4
91181: ARRAY
91182: PUSH
91183: LD_INT 2
91185: ARRAY
91186: PPUSH
91187: NOP4
91191: PPUSH
91192: NOP4
91196: PPUSH
91197: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
91201: NOP4
91205: PUSH
91206: NOP4
91210: PPUSH
91211: NOP4
91215: PPUSH
91216: NOP4
91220: PUSH
91221: NOP4
91225: ARRAY
91226: PPUSH
91227: NOP4
91231: PPUSH
91232: NOP4
91236: PPUSH
91237: NOP4
91241: ST_TO_ADDR
// end ; end ;
91242: GO 91080
91244: POP
91245: POP
// end ;
91246: LD_VAR 0 4
91250: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
91251: LD_INT 0
91253: PPUSH
91254: PPUSH
91255: PPUSH
91256: PPUSH
91257: PPUSH
91258: PPUSH
91259: PPUSH
91260: PPUSH
91261: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
91262: NOP4
91266: PPUSH
91267: NOP4
91271: PUSH
91272: NOP4
91276: EQUAL
91277: NOT
91278: PUSH
91279: NOP4
91283: PUSH
91284: NOP4
91288: IN
91289: NOT
91290: OR
91291: IFFALSE 91295
// exit ;
91293: GO 91617
// index := GetElementIndex ( minersList , unit ) ;
91295: NOP4
91299: PUSH
91300: NOP4
91304: PPUSH
91305: NOP4
91309: PPUSH
91310: NOP4
91314: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
91315: NOP4
91319: PUSH
91320: NOP4
91324: PUSH
91325: NOP4
91329: PUSH
91330: NOP4
91334: ARRAY
91335: MINUS
91336: ST_TO_ADDR
// if not minesFreeAmount then
91337: NOP4
91341: NOT
91342: IFFALSE 91346
// exit ;
91344: GO 91617
// tmp := [ ] ;
91346: NOP4
91350: PUSH
91351: EMPTY
91352: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
91353: NOP4
91357: PUSH
91358: DOUBLE
91359: LD_INT 1
91361: DEC
91362: ST_TO_ADDR
91363: NOP4
91367: PUSH
91368: FOR_TO
91369: IFFALSE 91564
// begin _d := rand ( 0 , 5 ) ;
91371: NOP4
91375: PUSH
91376: LD_INT 0
91378: PPUSH
91379: LD_INT 5
91381: PPUSH
91382: NOP4
91386: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
91387: NOP4
91391: PUSH
91392: LD_INT 2
91394: PPUSH
91395: LD_INT 6
91397: PPUSH
91398: NOP4
91402: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
91403: NOP4
91407: PUSH
91408: NOP4
91412: PPUSH
91413: NOP4
91417: PPUSH
91418: NOP4
91422: PPUSH
91423: NOP4
91427: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
91428: NOP4
91432: PUSH
91433: NOP4
91437: PPUSH
91438: NOP4
91442: PPUSH
91443: NOP4
91447: PPUSH
91448: NOP4
91452: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
91453: NOP4
91457: PPUSH
91458: NOP4
91462: PPUSH
91463: NOP4
91467: PUSH
91468: NOP4
91472: PUSH
91473: NOP4
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: NOP4
91486: IN
91487: NOT
91488: AND
91489: PUSH
91490: NOP4
91494: PPUSH
91495: NOP4
91499: PPUSH
91500: NOP4
91504: NOT
91505: AND
91506: IFFALSE 91548
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
91508: NOP4
91512: PUSH
91513: NOP4
91517: PPUSH
91518: NOP4
91522: PUSH
91523: LD_INT 1
91525: PLUS
91526: PPUSH
91527: NOP4
91531: PUSH
91532: NOP4
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PPUSH
91541: NOP4
91545: ST_TO_ADDR
91546: GO 91562
// i := i - 1 ;
91548: NOP4
91552: PUSH
91553: NOP4
91557: PUSH
91558: LD_INT 1
91560: MINUS
91561: ST_TO_ADDR
// end ;
91562: GO 91368
91564: POP
91565: POP
// for i in tmp do
91566: NOP4
91570: PUSH
91571: NOP4
91575: PUSH
91576: FOR_IN
91577: IFFALSE 91615
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
91579: NOP4
91583: PPUSH
91584: NOP4
91588: PUSH
91589: LD_INT 1
91591: ARRAY
91592: PPUSH
91593: NOP4
91597: PUSH
91598: LD_INT 2
91600: ARRAY
91601: PPUSH
91602: NOP4
91606: NOT
91607: IFFALSE 91613
// exit ;
91609: POP
91610: POP
91611: GO 91617
91613: GO 91576
91615: POP
91616: POP
// end ;
91617: LD_VAR 0 4
91621: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
91622: LD_INT 0
91624: PPUSH
91625: PPUSH
91626: PPUSH
91627: PPUSH
91628: PPUSH
91629: PPUSH
91630: PPUSH
// if not GetClass ( unit ) = class_sniper then
91631: NOP4
91635: PPUSH
91636: NOP4
91640: PUSH
91641: LD_INT 5
91643: EQUAL
91644: NOT
91645: IFFALSE 91649
// exit ;
91647: GO 92037
// dist := 8 ;
91649: NOP4
91653: PUSH
91654: LD_INT 8
91656: ST_TO_ADDR
// viewRange := 12 ;
91657: NOP4
91661: PUSH
91662: LD_INT 12
91664: ST_TO_ADDR
// side := GetSide ( unit ) ;
91665: NOP4
91669: PUSH
91670: NOP4
91674: PPUSH
91675: NOP4
91679: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
91680: LD_INT 61
91682: PPUSH
91683: NOP4
91687: PPUSH
91688: NOP4
91692: PUSH
91693: LD_INT 2
91695: EQUAL
91696: IFFALSE 91706
// viewRange := 16 ;
91698: NOP4
91702: PUSH
91703: LD_INT 16
91705: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
91706: NOP4
91710: PPUSH
91711: NOP4
91715: PPUSH
91716: NOP4
91720: PPUSH
91721: NOP4
91725: PUSH
91726: NOP4
91730: GREATER
91731: IFFALSE 91810
// begin ComMoveXY ( unit , x , y ) ;
91733: NOP4
91737: PPUSH
91738: NOP4
91742: PPUSH
91743: NOP4
91747: PPUSH
91748: NOP4
// repeat wait ( 0 0$1 ) ;
91752: LD_INT 35
91754: PPUSH
91755: NOP4
// if not UnitGoingToXY ( unit , x , y ) then
91759: NOP4
91763: PPUSH
91764: NOP4
91768: PPUSH
91769: NOP4
91773: PPUSH
91774: NOP4
91778: NOT
91779: IFFALSE 91783
// exit ;
91781: GO 92037
// until GetDistUnitXY ( unit , x , y ) < dist ;
91783: NOP4
91787: PPUSH
91788: NOP4
91792: PPUSH
91793: NOP4
91797: PPUSH
91798: NOP4
91802: PUSH
91803: NOP4
91807: LESS
91808: IFFALSE 91752
// end ; ComTurnXY ( unit , x , y ) ;
91810: NOP4
91814: PPUSH
91815: NOP4
91819: PPUSH
91820: NOP4
91824: PPUSH
91825: NOP4
// wait ( 5 ) ;
91829: LD_INT 5
91831: PPUSH
91832: NOP4
// _d := GetDir ( unit ) ;
91836: NOP4
91840: PUSH
91841: NOP4
91845: PPUSH
91846: NOP4
91850: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
91851: NOP4
91855: PUSH
91856: NOP4
91860: PPUSH
91861: NOP4
91865: PPUSH
91866: NOP4
91870: PPUSH
91871: NOP4
91875: PPUSH
91876: NOP4
91880: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
91881: NOP4
91885: PUSH
91886: NOP4
91890: PPUSH
91891: NOP4
91895: PPUSH
91896: NOP4
91900: PPUSH
91901: NOP4
91905: PPUSH
91906: NOP4
91910: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91911: NOP4
91915: PPUSH
91916: NOP4
91920: PPUSH
91921: NOP4
91925: NOT
91926: IFFALSE 91930
// exit ;
91928: GO 92037
// ComAnimCustom ( unit , 1 ) ;
91930: NOP4
91934: PPUSH
91935: LD_INT 1
91937: PPUSH
91938: NOP4
// PlaceSeeing ( _x , _y , side , viewRange ) ;
91942: NOP4
91946: PPUSH
91947: NOP4
91951: PPUSH
91952: NOP4
91956: PPUSH
91957: NOP4
91961: PPUSH
91962: NOP4
// repeat wait ( 1 ) ;
91966: LD_INT 1
91968: PPUSH
91969: NOP4
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
91973: NOP4
91977: PPUSH
91978: NOP4
91982: PUSH
91983: NOP4
91987: PPUSH
91988: NOP4
91992: OR
91993: PUSH
91994: NOP4
91998: PPUSH
91999: NOP4
92003: NOT
92004: OR
92005: PUSH
92006: NOP4
92010: PPUSH
92011: NOP4
92015: OR
92016: IFFALSE 91966
// RemoveSeeing ( _x , _y , side ) ;
92018: NOP4
92022: PPUSH
92023: NOP4
92027: PPUSH
92028: NOP4
92032: PPUSH
92033: NOP4
// end ; end_of_file
92037: LD_VAR 0 4
92041: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
92042: NOP4
92046: PUSH
92047: LD_INT 200
92049: DOUBLE
92050: GREATEREQUAL
92051: IFFALSE 92059
92053: LD_INT 299
92055: DOUBLE
92056: LESSEQUAL
92057: IFTRUE 92061
92059: GO 92093
92061: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
92062: NOP4
92066: PPUSH
92067: NOP4
92071: PPUSH
92072: NOP4
92076: PPUSH
92077: NOP4
92081: PPUSH
92082: NOP4
92086: PPUSH
92087: NOP4
92091: GO 92170
92093: LD_INT 300
92095: DOUBLE
92096: GREATEREQUAL
92097: IFFALSE 92105
92099: LD_INT 399
92101: DOUBLE
92102: LESSEQUAL
92103: IFTRUE 92107
92105: GO 92169
92107: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
92108: NOP4
92112: PPUSH
92113: NOP4
92117: PPUSH
92118: NOP4
92122: PPUSH
92123: NOP4
92127: PPUSH
92128: NOP4
92132: PPUSH
92133: NOP4
92137: PPUSH
92138: NOP4
92142: PPUSH
92143: NOP4
92147: PPUSH
92148: NOP4
92152: PPUSH
92153: NOP4
92157: PPUSH
92158: NOP4
92162: PPUSH
92163: NOP4
92167: GO 92170
92169: POP
// end ;
92170: PPOPN 11
92172: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
92173: NOP4
92177: PPUSH
92178: NOP4
92182: PPUSH
92183: NOP4
92187: PPUSH
92188: NOP4
92192: PPUSH
92193: NOP4
92197: PPUSH
92198: NOP4
// end ;
92202: PPOPN 5
92204: END
