// starting begin ResetFog ;
   0: NOP4
// InitHc ;
   4: NOP4
// InitUc ;
   8: NOP4
// InitBc ;
  12: NOP4
// InitVariables ;
  16: NOP4
// InitMultiplayer ;
  20: NOP4
// InitMacro ;
  24: NOP4
// if debug then
  28: NOP4
  32: IFFALSE 41
// FogOff ( 1 ) ;
  34: LD_INT 1
  36: PPUSH
  37: NOP4
// PrepareNature ( 3 , 3 , 0 , 2 , 2 , 1 , 5 , natureArea , waterArea ) ;
  41: LD_INT 3
  43: PPUSH
  44: LD_INT 3
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 2
  52: PPUSH
  53: LD_INT 2
  55: PPUSH
  56: LD_INT 1
  58: PPUSH
  59: LD_INT 5
  61: PPUSH
  62: LD_INT 18
  64: PPUSH
  65: LD_INT 19
  67: PPUSH
  68: NOP4
// PrepareArabian ( Multiplayer_SetBotSide ( 2 ) ) ;
  72: LD_INT 2
  74: PPUSH
  75: NOP4
  79: PPUSH
  80: NOP4
// Multiplayer_Start ;
  84: NOP4
// MC_Start ( ) ;
  88: NOP4
// Multiplayer_End ;
  92: NOP4
// end ;
  96: END
// export function CustomInitMacro ; var i ; begin
  97: LD_INT 0
  99: PPUSH
 100: PPUSH
// MC_SetMinesField ( 1 , [ 8 , 10 , 12 ] [ Difficulty ] , minefield1_left ) ;
 101: LD_INT 1
 103: PPUSH
 104: LD_INT 8
 106: PUSH
 107: LD_INT 10
 109: PUSH
 110: LD_INT 12
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: PUSH
 118: NOP4
 122: ARRAY
 123: PPUSH
 124: LD_INT 3
 126: PPUSH
 127: NOP4
// MC_SetMinesField ( 2 , [ 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 131: LD_INT 2
 133: PPUSH
 134: LD_INT 6
 136: PUSH
 137: LD_INT 8
 139: PUSH
 140: LD_INT 9
 142: PUSH
 143: EMPTY
 144: LIST
 145: LIST
 146: LIST
 147: PUSH
 148: NOP4
 152: ARRAY
 153: PPUSH
 154: LD_INT 2
 156: PPUSH
 157: NOP4
// MC_SetMinesField ( 3 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield3_left ) ;
 161: LD_INT 3
 163: PPUSH
 164: LD_INT 6
 166: PUSH
 167: LD_INT 7
 169: PUSH
 170: LD_INT 9
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: PUSH
 178: NOP4
 182: ARRAY
 183: PPUSH
 184: LD_INT 1
 186: PPUSH
 187: NOP4
// MC_SetMinesField ( 4 , [ 6 , 7 , 9 ] [ Difficulty ] , minefield4_left ) ;
 191: LD_INT 4
 193: PPUSH
 194: LD_INT 6
 196: PUSH
 197: LD_INT 7
 199: PUSH
 200: LD_INT 9
 202: PUSH
 203: EMPTY
 204: LIST
 205: LIST
 206: LIST
 207: PUSH
 208: NOP4
 212: ARRAY
 213: PPUSH
 214: LD_INT 25
 216: PPUSH
 217: NOP4
// MC_SetMinesField ( 5 , [ 4 , 5 , 6 ] [ Difficulty ] , minefield5_left ) ;
 221: LD_INT 5
 223: PPUSH
 224: LD_INT 4
 226: PUSH
 227: LD_INT 5
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: PUSH
 238: NOP4
 242: ARRAY
 243: PPUSH
 244: LD_INT 39
 246: PPUSH
 247: NOP4
// mc_parking := [ parking_north , parking_west , parking_east , parking_south , parking_north ] ;
 251: NOP4
 255: PUSH
 256: LD_INT 20
 258: PUSH
 259: LD_INT 21
 261: PUSH
 262: LD_INT 22
 264: PUSH
 265: LD_INT 24
 267: PUSH
 268: LD_INT 20
 270: PUSH
 271: EMPTY
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ area_base_north , area_base_west , area_base_east , area_base_south , area_base_north2 ] ;
 278: NOP4
 282: PUSH
 283: LD_INT 35
 285: PUSH
 286: LD_INT 34
 288: PUSH
 289: LD_INT 36
 291: PUSH
 292: LD_INT 33
 294: PUSH
 295: LD_INT 38
 297: PUSH
 298: EMPTY
 299: LIST
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: ST_TO_ADDR
// for i = 1 to 4 do
 305: NOP4
 309: PUSH
 310: DOUBLE
 311: LD_INT 1
 313: DEC
 314: ST_TO_ADDR
 315: LD_INT 4
 317: PUSH
 318: FOR_TO
 319: IFFALSE 343
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 321: NOP4
 325: PPUSH
 326: NOP4
 330: PUSH
 331: NOP4
 335: ARRAY
 336: PPUSH
 337: NOP4
 341: GO 318
 343: POP
 344: POP
// end ;
 345: LD_VAR 0 1
 349: RET
// export debug , game , side_bot , artifact_get , base_names ; function InitVariables ; begin
 350: LD_INT 0
 352: PPUSH
// debug := 1 ;
 353: NOP4
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// side_bot := 2 ;
 361: NOP4
 365: PUSH
 366: LD_INT 2
 368: ST_TO_ADDR
// artifact_get := false ;
 369: NOP4
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// base_names := [ base_a , base_b , base_c , base_d , base_e , base_f , base_g , base_h , base_i , base_j , base_k , base_l , base_m , base_n , base_o , base_p , base_r , base_s , base_t , base_u , base_w , base_x , base_y , base_z ] ;
 377: NOP4
 381: PUSH
 382: LD_STRING base_a
 384: PUSH
 385: LD_STRING base_b
 387: PUSH
 388: LD_STRING base_c
 390: PUSH
 391: LD_STRING base_d
 393: PUSH
 394: LD_STRING base_e
 396: PUSH
 397: LD_STRING base_f
 399: PUSH
 400: LD_STRING base_g
 402: PUSH
 403: LD_STRING base_h
 405: PUSH
 406: LD_STRING base_i
 408: PUSH
 409: LD_STRING base_j
 411: PUSH
 412: LD_STRING base_k
 414: PUSH
 415: LD_STRING base_l
 417: PUSH
 418: LD_STRING base_m
 420: PUSH
 421: LD_STRING base_n
 423: PUSH
 424: LD_STRING base_o
 426: PUSH
 427: LD_STRING base_p
 429: PUSH
 430: LD_STRING base_r
 432: PUSH
 433: LD_STRING base_s
 435: PUSH
 436: LD_STRING base_t
 438: PUSH
 439: LD_STRING base_u
 441: PUSH
 442: LD_STRING base_w
 444: PUSH
 445: LD_STRING base_x
 447: PUSH
 448: LD_STRING base_y
 450: PUSH
 451: LD_STRING base_z
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: LIST
 479: ST_TO_ADDR
// end ;
 480: LD_VAR 0 1
 484: RET
// every 0 0$01 trigger game and not debug_strings do
 485: NOP4
 489: PUSH
 490: NOP4
 494: NOT
 495: AND
 496: IFFALSE 512
 498: GO 500
 500: DISABLE
// begin enable ;
 501: ENABLE
// display_strings := Multiplayer_DisplayStrings ( ) ;
 502: LD_ADDR_OWVAR 47
 506: PUSH
 507: NOP4
 511: ST_TO_ADDR
// end ;
 512: END
// function Debuger ; var i ; begin
 513: LD_INT 0
 515: PPUSH
 516: PPUSH
// if not debug then
 517: NOP4
 521: NOT
 522: IFFALSE 526
// exit ;
 524: GO 598
// game_speed := 5 ;
 526: LD_ADDR_OWVAR 65
 530: PUSH
 531: LD_INT 5
 533: ST_TO_ADDR
// uc_side := 1 ;
 534: LD_ADDR_OWVAR 20
 538: PUSH
 539: LD_INT 1
 541: ST_TO_ADDR
// uc_nation := 1 ;
 542: LD_ADDR_OWVAR 21
 546: PUSH
 547: LD_INT 1
 549: ST_TO_ADDR
// for i = 1 to 10 do
 550: NOP4
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 10
 562: PUSH
 563: FOR_TO
 564: IFFALSE 596
// begin PrepareHuman ( false , 1 , 10 ) ;
 566: LD_INT 0
 568: PPUSH
 569: LD_INT 1
 571: PPUSH
 572: LD_INT 10
 574: PPUSH
 575: NOP4
// PlaceUnitArea ( CreateHuman , player_1_hum , false ) ;
 579: NOP4
 583: PPUSH
 584: LD_INT 9
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: NOP4
// end ;
 594: GO 563
 596: POP
 597: POP
// end ;
 598: LD_VAR 0 1
 602: RET
// export function CustomEvent ( event ) ; begin
 603: LD_INT 0
 605: PPUSH
// end ; end_of_file
 606: LD_VAR 0 2
 610: RET
// export multi_gametype , multi_sides , multi_side_teams , multi_nations , multi_teams , multi_spec , multi_pos_area , multi_allowed_nations , multi_bots , multi_teamgame , multi_custom_commanders , multi_settings , multi_settings_counter , multi_pep_amount , multi_skill_level , multi_crates_spawn , multi_ape_amount , multi_support , multi_commanders , multi_loosers , multi_players_amount , multi_reinforcements , multi_reinforcements_spawned ; export function InitMultiplayer ; var i , j , x , tmp ; begin
 611: LD_INT 0
 613: PPUSH
 614: PPUSH
 615: PPUSH
 616: PPUSH
 617: PPUSH
// multi_settings_counter := 6 ;
 618: NOP4
 622: PUSH
 623: LD_INT 6
 625: ST_TO_ADDR
// if multiplayer then
 626: NOP4
 630: IFFALSE 812
// begin your_side := mp_player_side ;
 632: LD_ADDR_OWVAR 2
 636: PUSH
 637: NOP4
 641: ST_TO_ADDR
// multi_gametype := mp_game_type ;
 642: NOP4
 646: PUSH
 647: NOP4
 651: ST_TO_ADDR
// multi_sides := mp_sides_positions ;
 652: NOP4
 656: PUSH
 657: NOP4
 661: ST_TO_ADDR
// multi_side_teams := mp_sides_teams ;
 662: NOP4
 666: PUSH
 667: NOP4
 671: ST_TO_ADDR
// multi_nations := mp_sides_nations ;
 672: NOP4
 676: PUSH
 677: NOP4
 681: ST_TO_ADDR
// multi_teams := [ ] ;
 682: NOP4
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// for i in mp_teams do
 689: NOP4
 693: PUSH
 694: NOP4
 698: PUSH
 699: FOR_IN
 700: IFFALSE 748
// multi_teams := ReplaceIn ( multi_teams , [ 1 , multi_teams [ 1 ] + 1 ] , i [ 1 ] ) ;
 702: NOP4
 706: PUSH
 707: NOP4
 711: PPUSH
 712: LD_INT 1
 714: PUSH
 715: NOP4
 719: PUSH
 720: LD_INT 1
 722: ARRAY
 723: PUSH
 724: LD_INT 1
 726: PLUS
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: PPUSH
 732: NOP4
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: NOP4
 745: ST_TO_ADDR
 746: GO 699
 748: POP
 749: POP
// for i = 1 to multi_settings_counter do
 750: NOP4
 754: PUSH
 755: DOUBLE
 756: LD_INT 1
 758: DEC
 759: ST_TO_ADDR
 760: NOP4
 764: PUSH
 765: FOR_TO
 766: IFFALSE 808
// multi_settings := Insert ( multi_settings , multi_settings + 1 , GetMultiplayerSetting ( i ) + 1 ) ;
 768: NOP4
 772: PUSH
 773: NOP4
 777: PPUSH
 778: NOP4
 782: PUSH
 783: LD_INT 1
 785: PLUS
 786: PPUSH
 787: NOP4
 791: PPUSH
 792: NOP4
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: PPUSH
 801: NOP4
 805: ST_TO_ADDR
 806: GO 765
 808: POP
 809: POP
// end else
 810: GO 998
// begin your_side := 1 ;
 812: LD_ADDR_OWVAR 2
 816: PUSH
 817: LD_INT 1
 819: ST_TO_ADDR
// multi_gametype := 1 ;
 820: NOP4
 824: PUSH
 825: LD_INT 1
 827: ST_TO_ADDR
// multi_sides := [ 2 , 0 , 0 , 3 , 0 , 0 , 1 , 0 ] ;
 828: NOP4
 832: PUSH
 833: LD_INT 2
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 0
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 0
 847: PUSH
 848: LD_INT 0
 850: PUSH
 851: LD_INT 1
 853: PUSH
 854: LD_INT 0
 856: PUSH
 857: EMPTY
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: ST_TO_ADDR
// multi_side_teams := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 867: NOP4
 871: PUSH
 872: LD_INT 1
 874: PUSH
 875: LD_INT 0
 877: PUSH
 878: LD_INT 0
 880: PUSH
 881: LD_INT 1
 883: PUSH
 884: LD_INT 0
 886: PUSH
 887: LD_INT 0
 889: PUSH
 890: LD_INT 1
 892: PUSH
 893: LD_INT 0
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: ST_TO_ADDR
// multi_nations := [ 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 ] ;
 906: NOP4
 910: PUSH
 911: LD_INT 1
 913: PUSH
 914: LD_INT 0
 916: PUSH
 917: LD_INT 0
 919: PUSH
 920: LD_INT 1
 922: PUSH
 923: LD_INT 0
 925: PUSH
 926: LD_INT 0
 928: PUSH
 929: LD_INT 1
 931: PUSH
 932: LD_INT 0
 934: PUSH
 935: EMPTY
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: LIST
 942: LIST
 943: LIST
 944: ST_TO_ADDR
// multi_teams := [ [ 1 , 4 , 7 ] ] ;
 945: NOP4
 949: PUSH
 950: LD_INT 1
 952: PUSH
 953: LD_INT 4
 955: PUSH
 956: LD_INT 7
 958: PUSH
 959: EMPTY
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: EMPTY
 965: LIST
 966: ST_TO_ADDR
// multi_settings := [ 2 , 2 , 1 , 3 , 1 , 1 ] ;
 967: NOP4
 971: PUSH
 972: LD_INT 2
 974: PUSH
 975: LD_INT 2
 977: PUSH
 978: LD_INT 1
 980: PUSH
 981: LD_INT 3
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: LIST
 997: ST_TO_ADDR
// end ; multi_spec := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 998: NOP4
1002: PUSH
1003: LD_INT 0
1005: PUSH
1006: LD_INT 0
1008: PUSH
1009: LD_INT 0
1011: PUSH
1012: LD_INT 0
1014: PUSH
1015: LD_INT 0
1017: PUSH
1018: LD_INT 0
1020: PUSH
1021: LD_INT 0
1023: PUSH
1024: LD_INT 0
1026: PUSH
1027: EMPTY
1028: LIST
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: ST_TO_ADDR
// multi_bots := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1037: NOP4
1041: PUSH
1042: LD_INT 0
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: LD_INT 0
1050: PUSH
1051: LD_INT 0
1053: PUSH
1054: LD_INT 0
1056: PUSH
1057: LD_INT 0
1059: PUSH
1060: LD_INT 0
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: ST_TO_ADDR
// multi_loosers := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
1076: NOP4
1080: PUSH
1081: LD_INT 0
1083: PUSH
1084: LD_INT 0
1086: PUSH
1087: LD_INT 0
1089: PUSH
1090: LD_INT 0
1092: PUSH
1093: LD_INT 0
1095: PUSH
1096: LD_INT 0
1098: PUSH
1099: LD_INT 0
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: ST_TO_ADDR
// multi_teamgame := true ;
1115: NOP4
1119: PUSH
1120: LD_INT 1
1122: ST_TO_ADDR
// multi_allowed_nations := [ 1 ] ;
1123: NOP4
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: EMPTY
1132: LIST
1133: ST_TO_ADDR
// multi_custom_commanders := true ;
1134: NOP4
1138: PUSH
1139: LD_INT 1
1141: ST_TO_ADDR
// multi_commanders := [ ] ;
1142: NOP4
1146: PUSH
1147: EMPTY
1148: ST_TO_ADDR
// multi_reinforcements := [ ] ;
1149: NOP4
1153: PUSH
1154: EMPTY
1155: ST_TO_ADDR
// multi_reinforcements_spawned := 0 ;
1156: NOP4
1160: PUSH
1161: LD_INT 0
1163: ST_TO_ADDR
// multi_players_amount := 0 ;
1164: NOP4
1168: PUSH
1169: LD_INT 0
1171: ST_TO_ADDR
// multi_pos_area := [ [ player_1_hum , player_1_veh ] , [ player_2_hum , player_2_veh ] , [ player_3_hum , player_3_veh ] ] ;
1172: NOP4
1176: PUSH
1177: LD_INT 9
1179: PUSH
1180: LD_INT 8
1182: PUSH
1183: EMPTY
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 27
1189: PUSH
1190: LD_INT 26
1192: PUSH
1193: EMPTY
1194: LIST
1195: LIST
1196: PUSH
1197: LD_INT 29
1199: PUSH
1200: LD_INT 28
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: PUSH
1207: EMPTY
1208: LIST
1209: LIST
1210: LIST
1211: ST_TO_ADDR
// for i = 1 to 8 do
1212: NOP4
1216: PUSH
1217: DOUBLE
1218: LD_INT 1
1220: DEC
1221: ST_TO_ADDR
1222: LD_INT 8
1224: PUSH
1225: FOR_TO
1226: IFFALSE 1555
// begin if Multiplayer_GetPlayerIsSpec ( i ) then
1228: NOP4
1232: PPUSH
1233: NOP4
1237: IFFALSE 1395
// begin multi_spec := Replace ( multi_spec , i , 1 ) ;
1239: NOP4
1243: PUSH
1244: NOP4
1248: PPUSH
1249: NOP4
1253: PPUSH
1254: LD_INT 1
1256: PPUSH
1257: NOP4
1261: ST_TO_ADDR
// multi_nations := Replace ( multi_nations , i , 0 ) ;
1262: NOP4
1266: PUSH
1267: NOP4
1271: PPUSH
1272: NOP4
1276: PPUSH
1277: LD_INT 0
1279: PPUSH
1280: NOP4
1284: ST_TO_ADDR
// multi_sides := Replace ( multi_sides , i , 0 ) ;
1285: NOP4
1289: PUSH
1290: NOP4
1294: PPUSH
1295: NOP4
1299: PPUSH
1300: LD_INT 0
1302: PPUSH
1303: NOP4
1307: ST_TO_ADDR
// for j = 1 to multi_teams do
1308: NOP4
1312: PUSH
1313: DOUBLE
1314: LD_INT 1
1316: DEC
1317: ST_TO_ADDR
1318: NOP4
1322: PUSH
1323: FOR_TO
1324: IFFALSE 1393
// begin if i in multi_teams [ j ] then
1326: NOP4
1330: PUSH
1331: NOP4
1335: PUSH
1336: NOP4
1340: ARRAY
1341: IN
1342: IFFALSE 1391
// begin tmp := multi_teams [ j ] diff i ;
1344: NOP4
1348: PUSH
1349: NOP4
1353: PUSH
1354: NOP4
1358: ARRAY
1359: PUSH
1360: NOP4
1364: DIFF
1365: ST_TO_ADDR
// multi_teams := Replace ( multi_teams , j , tmp ) ;
1366: NOP4
1370: PUSH
1371: NOP4
1375: PPUSH
1376: NOP4
1380: PPUSH
1381: NOP4
1385: PPUSH
1386: NOP4
1390: ST_TO_ADDR
// end ; end ;
1391: GO 1323
1393: POP
1394: POP
// end ; if multi_nations [ i ] and not multi_nations [ i ] in multi_allowed_nations then
1395: NOP4
1399: PUSH
1400: NOP4
1404: ARRAY
1405: PUSH
1406: NOP4
1410: PUSH
1411: NOP4
1415: ARRAY
1416: PUSH
1417: NOP4
1421: IN
1422: NOT
1423: AND
1424: IFFALSE 1465
// multi_nations := Replace ( multi_nations , i , multi_allowed_nations [ rand ( 1 , multi_allowed_nations ) ] ) ;
1426: NOP4
1430: PUSH
1431: NOP4
1435: PPUSH
1436: NOP4
1440: PPUSH
1441: NOP4
1445: PUSH
1446: LD_INT 1
1448: PPUSH
1449: NOP4
1453: PPUSH
1454: NOP4
1458: ARRAY
1459: PPUSH
1460: NOP4
1464: ST_TO_ADDR
// if not multi_nations [ i ] and not multi_sides [ i ] and not multi_spec [ i ] then
1465: NOP4
1469: PUSH
1470: NOP4
1474: ARRAY
1475: NOT
1476: PUSH
1477: NOP4
1481: PUSH
1482: NOP4
1486: ARRAY
1487: NOT
1488: AND
1489: PUSH
1490: NOP4
1494: PUSH
1495: NOP4
1499: ARRAY
1500: NOT
1501: AND
1502: IFFALSE 1527
// multi_bots := Replace ( multi_bots , i , 1 ) ;
1504: NOP4
1508: PUSH
1509: NOP4
1513: PPUSH
1514: NOP4
1518: PPUSH
1519: LD_INT 1
1521: PPUSH
1522: NOP4
1526: ST_TO_ADDR
// if multi_sides [ i ] then
1527: NOP4
1531: PUSH
1532: NOP4
1536: ARRAY
1537: IFFALSE 1553
// multi_players_amount := multi_players_amount + 1 ;
1539: NOP4
1543: PUSH
1544: NOP4
1548: PUSH
1549: LD_INT 1
1551: PLUS
1552: ST_TO_ADDR
// end ;
1553: GO 1225
1555: POP
1556: POP
// for i in multi_teams do
1557: NOP4
1561: PUSH
1562: NOP4
1566: PUSH
1567: FOR_IN
1568: IFFALSE 1676
// begin for j = 2 to i do
1570: NOP4
1574: PUSH
1575: DOUBLE
1576: LD_INT 2
1578: DEC
1579: ST_TO_ADDR
1580: NOP4
1584: PUSH
1585: FOR_TO
1586: IFFALSE 1672
// begin ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
1588: NOP4
1592: PUSH
1593: NOP4
1597: ARRAY
1598: PPUSH
1599: NOP4
1603: PUSH
1604: LD_INT 1
1606: ARRAY
1607: PPUSH
1608: NOP4
// for x = 1 to j - 1 do
1612: NOP4
1616: PUSH
1617: DOUBLE
1618: LD_INT 1
1620: DEC
1621: ST_TO_ADDR
1622: NOP4
1626: PUSH
1627: LD_INT 1
1629: MINUS
1630: PUSH
1631: FOR_TO
1632: IFFALSE 1668
// SetAttitude ( i [ j ] , i [ x ] , att_friend , true ) ;
1634: NOP4
1638: PUSH
1639: NOP4
1643: ARRAY
1644: PPUSH
1645: NOP4
1649: PUSH
1650: NOP4
1654: ARRAY
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 1
1661: PPUSH
1662: NOP4
1666: GO 1631
1668: POP
1669: POP
// end ;
1670: GO 1585
1672: POP
1673: POP
// end ;
1674: GO 1567
1676: POP
1677: POP
// Difficulty := [ 1 , 2 , 3 ] [ multi_settings [ 1 ] ] ;
1678: LD_ADDR_OWVAR 67
1682: PUSH
1683: LD_INT 1
1685: PUSH
1686: LD_INT 2
1688: PUSH
1689: LD_INT 3
1691: PUSH
1692: EMPTY
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: NOP4
1701: PUSH
1702: LD_INT 1
1704: ARRAY
1705: ARRAY
1706: ST_TO_ADDR
// multi_pep_amount := [ 9 , 12 , 15 , 18 ] [ multi_settings [ 2 ] ] ;
1707: NOP4
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: LD_INT 15
1720: PUSH
1721: LD_INT 18
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: LIST
1728: LIST
1729: PUSH
1730: NOP4
1734: PUSH
1735: LD_INT 2
1737: ARRAY
1738: ARRAY
1739: ST_TO_ADDR
// multi_skill_level := [ 5 , 7 , 9 ] [ multi_settings [ 3 ] ] ;
1740: NOP4
1744: PUSH
1745: LD_INT 5
1747: PUSH
1748: LD_INT 7
1750: PUSH
1751: LD_INT 9
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: NOP4
1763: PUSH
1764: LD_INT 3
1766: ARRAY
1767: ARRAY
1768: ST_TO_ADDR
// multi_crates_spawn := [ [ 6000 , 0 0$45 ] , [ 8000 , 0 0$36 ] , [ 10000 , 0 0$22 ] , [ 15000 , 0 0$22 ] ] [ multi_settings [ 4 ] ] ;
1769: NOP4
1773: PUSH
1774: LD_INT 6000
1776: PUSH
1777: LD_INT 1575
1779: PUSH
1780: EMPTY
1781: LIST
1782: LIST
1783: PUSH
1784: LD_INT 8000
1786: PUSH
1787: LD_INT 1260
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PUSH
1794: LD_INT 10000
1796: PUSH
1797: LD_INT 770
1799: PUSH
1800: EMPTY
1801: LIST
1802: LIST
1803: PUSH
1804: LD_INT 15000
1806: PUSH
1807: LD_INT 770
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: NOP4
1824: PUSH
1825: LD_INT 4
1827: ARRAY
1828: ARRAY
1829: ST_TO_ADDR
// multi_ape_amount := [ 6 , 8 , 10 ] [ multi_settings [ 5 ] ] ;
1830: NOP4
1834: PUSH
1835: LD_INT 6
1837: PUSH
1838: LD_INT 8
1840: PUSH
1841: LD_INT 10
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: NOP4
1853: PUSH
1854: LD_INT 5
1856: ARRAY
1857: ARRAY
1858: ST_TO_ADDR
// multi_support := [ 0 , 1 , 2 ] [ multi_settings [ 6 ] ] ;
1859: NOP4
1863: PUSH
1864: LD_INT 0
1866: PUSH
1867: LD_INT 1
1869: PUSH
1870: LD_INT 2
1872: PUSH
1873: EMPTY
1874: LIST
1875: LIST
1876: LIST
1877: PUSH
1878: NOP4
1882: PUSH
1883: LD_INT 6
1885: ARRAY
1886: ARRAY
1887: ST_TO_ADDR
// end ;
1888: LD_VAR 0 1
1892: RET
// export function Multiplayer_SetBotSide ( preferSide ) ; var i ; begin
1893: LD_INT 0
1895: PPUSH
1896: PPUSH
// if not preferSide in multi_sides then
1897: NOP4
1901: PUSH
1902: NOP4
1906: IN
1907: NOT
1908: IFFALSE 1922
// begin result := preferSide ;
1910: NOP4
1914: PUSH
1915: NOP4
1919: ST_TO_ADDR
// exit ;
1920: GO 1969
// end ; for i := 1 to 8 do
1922: NOP4
1926: PUSH
1927: DOUBLE
1928: LD_INT 1
1930: DEC
1931: ST_TO_ADDR
1932: LD_INT 8
1934: PUSH
1935: FOR_TO
1936: IFFALSE 1967
// if not multi_sides [ i ] then
1938: NOP4
1942: PUSH
1943: NOP4
1947: ARRAY
1948: NOT
1949: IFFALSE 1965
// begin result := i ;
1951: NOP4
1955: PUSH
1956: NOP4
1960: ST_TO_ADDR
// exit ;
1961: POP
1962: POP
1963: GO 1969
// end ;
1965: GO 1935
1967: POP
1968: POP
// end ;
1969: LD_VAR 0 2
1973: RET
// export function Multiplayer_PrepareCustomCommanders ( side , num ) ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := side ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: NOP4
1986: ST_TO_ADDR
// uc_nation := 1 ;
1987: LD_ADDR_OWVAR 21
1991: PUSH
1992: LD_INT 1
1994: ST_TO_ADDR
// hc_importance := 100 ;
1995: LD_ADDR_OWVAR 32
1999: PUSH
2000: LD_INT 100
2002: ST_TO_ADDR
// hc_class := 1 ;
2003: LD_ADDR_OWVAR 28
2007: PUSH
2008: LD_INT 1
2010: ST_TO_ADDR
// if num = 1 then
2011: NOP4
2015: PUSH
2016: LD_INT 1
2018: EQUAL
2019: IFFALSE 2101
// begin hc_gallery := us ;
2021: LD_ADDR_OWVAR 33
2025: PUSH
2026: LD_STRING us
2028: ST_TO_ADDR
// hc_face_number := 5 ;
2029: LD_ADDR_OWVAR 34
2033: PUSH
2034: LD_INT 5
2036: ST_TO_ADDR
// hc_name := John Macmilan ;
2037: LD_ADDR_OWVAR 26
2041: PUSH
2042: LD_STRING John Macmilan
2044: ST_TO_ADDR
// hc_sex := sex_male ;
2045: LD_ADDR_OWVAR 27
2049: PUSH
2050: LD_INT 1
2052: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 4 ] ;
2053: LD_ADDR_OWVAR 31
2057: PUSH
2058: LD_INT 7
2060: PUSH
2061: LD_INT 2
2063: PUSH
2064: LD_INT 4
2066: PUSH
2067: LD_INT 4
2069: PUSH
2070: EMPTY
2071: LIST
2072: LIST
2073: LIST
2074: LIST
2075: ST_TO_ADDR
// hc_attr := [ 11 , 10 ] ;
2076: LD_ADDR_OWVAR 29
2080: PUSH
2081: LD_INT 11
2083: PUSH
2084: LD_INT 10
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: ST_TO_ADDR
// result := CreateHuman ;
2091: NOP4
2095: PUSH
2096: NOP4
2100: ST_TO_ADDR
// end ; if num = 2 then
2101: NOP4
2105: PUSH
2106: LD_INT 2
2108: EQUAL
2109: IFFALSE 2191
// begin hc_gallery := us ;
2111: LD_ADDR_OWVAR 33
2115: PUSH
2116: LD_STRING us
2118: ST_TO_ADDR
// hc_face_number := 2 ;
2119: LD_ADDR_OWVAR 34
2123: PUSH
2124: LD_INT 2
2126: ST_TO_ADDR
// hc_name := Lucy Donaldson ;
2127: LD_ADDR_OWVAR 26
2131: PUSH
2132: LD_STRING Lucy Donaldson
2134: ST_TO_ADDR
// hc_sex := sex_female ;
2135: LD_ADDR_OWVAR 27
2139: PUSH
2140: LD_INT 2
2142: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 3 ] ;
2143: LD_ADDR_OWVAR 31
2147: PUSH
2148: LD_INT 6
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 4
2156: PUSH
2157: LD_INT 3
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: LIST
2165: ST_TO_ADDR
// hc_attr := [ 9 , 12 ] ;
2166: LD_ADDR_OWVAR 29
2170: PUSH
2171: LD_INT 9
2173: PUSH
2174: LD_INT 12
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: ST_TO_ADDR
// result := CreateHuman ;
2181: NOP4
2185: PUSH
2186: NOP4
2190: ST_TO_ADDR
// end ; if num = 3 then
2191: NOP4
2195: PUSH
2196: LD_INT 3
2198: EQUAL
2199: IFFALSE 2281
// begin hc_gallery := us ;
2201: LD_ADDR_OWVAR 33
2205: PUSH
2206: LD_STRING us
2208: ST_TO_ADDR
// hc_face_number := 7 ;
2209: LD_ADDR_OWVAR 34
2213: PUSH
2214: LD_INT 7
2216: ST_TO_ADDR
// hc_name := Arthur Powell ;
2217: LD_ADDR_OWVAR 26
2221: PUSH
2222: LD_STRING Arthur Powell
2224: ST_TO_ADDR
// hc_sex := sex_male ;
2225: LD_ADDR_OWVAR 27
2229: PUSH
2230: LD_INT 1
2232: ST_TO_ADDR
// hc_skills := [ 8 , 2 , 5 , 2 ] ;
2233: LD_ADDR_OWVAR 31
2237: PUSH
2238: LD_INT 8
2240: PUSH
2241: LD_INT 2
2243: PUSH
2244: LD_INT 5
2246: PUSH
2247: LD_INT 2
2249: PUSH
2250: EMPTY
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
2256: LD_ADDR_OWVAR 29
2260: PUSH
2261: LD_INT 10
2263: PUSH
2264: LD_INT 11
2266: PUSH
2267: EMPTY
2268: LIST
2269: LIST
2270: ST_TO_ADDR
// result := CreateHuman ;
2271: NOP4
2275: PUSH
2276: NOP4
2280: ST_TO_ADDR
// end ; end ;
2281: LD_VAR 0 3
2285: RET
// export function Multiplayer_PreparePlayers ( ) ; var i , j , cl , un , veh , tmp , copy , people_amount ; begin
2286: LD_INT 0
2288: PPUSH
2289: PPUSH
2290: PPUSH
2291: PPUSH
2292: PPUSH
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
// for i = 1 to 8 do
2297: NOP4
2301: PUSH
2302: DOUBLE
2303: LD_INT 1
2305: DEC
2306: ST_TO_ADDR
2307: LD_INT 8
2309: PUSH
2310: FOR_TO
2311: IFFALSE 3201
// begin if not multi_sides [ i ] then
2313: NOP4
2317: PUSH
2318: NOP4
2322: ARRAY
2323: NOT
2324: IFFALSE 2328
// continue ;
2326: GO 2310
// if multi_custom_commanders then
2328: NOP4
2332: IFFALSE 2424
// begin un := Multiplayer_PrepareCustomCommanders ( i , multi_sides [ i ] ) ;
2334: NOP4
2338: PUSH
2339: NOP4
2343: PPUSH
2344: NOP4
2348: PUSH
2349: NOP4
2353: ARRAY
2354: PPUSH
2355: NOP4
2359: ST_TO_ADDR
// multi_commanders := Insert ( multi_commanders , multi_commanders + 1 , un ) ;
2360: NOP4
2364: PUSH
2365: NOP4
2369: PPUSH
2370: NOP4
2374: PUSH
2375: LD_INT 1
2377: PLUS
2378: PPUSH
2379: NOP4
2383: PPUSH
2384: NOP4
2388: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2389: NOP4
2393: PPUSH
2394: NOP4
2398: PUSH
2399: NOP4
2403: PUSH
2404: NOP4
2408: ARRAY
2409: ARRAY
2410: PUSH
2411: LD_INT 1
2413: ARRAY
2414: PPUSH
2415: LD_INT 0
2417: PPUSH
2418: NOP4
// end else
2422: GO 2635
// begin uc_side := i ;
2424: LD_ADDR_OWVAR 20
2428: PUSH
2429: NOP4
2433: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2434: LD_ADDR_OWVAR 21
2438: PUSH
2439: NOP4
2443: PUSH
2444: NOP4
2448: ARRAY
2449: ST_TO_ADDR
// hc_importance := 100 ;
2450: LD_ADDR_OWVAR 32
2454: PUSH
2455: LD_INT 100
2457: ST_TO_ADDR
// PrepareHuman ( false , 1 , multi_skill_level ) ;
2458: LD_INT 0
2460: PPUSH
2461: LD_INT 1
2463: PPUSH
2464: NOP4
2468: PPUSH
2469: NOP4
// if multiplayer then
2473: NOP4
2477: IFFALSE 2535
// begin hc_name := mp_sides_players_names [ i ] ;
2479: LD_ADDR_OWVAR 26
2483: PUSH
2484: NOP4
2488: PUSH
2489: NOP4
2493: ARRAY
2494: ST_TO_ADDR
// hc_gallery := MULTIAVATARS ;
2495: LD_ADDR_OWVAR 33
2499: PUSH
2500: LD_STRING MULTIAVATARS
2502: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( i ) ;
2503: LD_ADDR_OWVAR 34
2507: PUSH
2508: NOP4
2512: PPUSH
2513: NOP4
2517: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( i ) ;
2518: LD_ADDR_OWVAR 27
2522: PUSH
2523: NOP4
2527: PPUSH
2528: NOP4
2532: ST_TO_ADDR
// end else
2533: GO 2567
// begin hc_gallery :=  ;
2535: LD_ADDR_OWVAR 33
2539: PUSH
2540: LD_STRING 
2542: ST_TO_ADDR
// hc_name :=  ;
2543: LD_ADDR_OWVAR 26
2547: PUSH
2548: LD_STRING 
2550: ST_TO_ADDR
// hc_sex := rand ( 1 , 2 ) ;
2551: LD_ADDR_OWVAR 27
2555: PUSH
2556: LD_INT 1
2558: PPUSH
2559: LD_INT 2
2561: PPUSH
2562: NOP4
2566: ST_TO_ADDR
// end ; un := CreateHuman ;
2567: NOP4
2571: PUSH
2572: NOP4
2576: ST_TO_ADDR
// PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
2577: NOP4
2581: PPUSH
2582: NOP4
2586: PUSH
2587: NOP4
2591: PUSH
2592: NOP4
2596: ARRAY
2597: ARRAY
2598: PUSH
2599: LD_INT 1
2601: ARRAY
2602: PPUSH
2603: LD_INT 0
2605: PPUSH
2606: NOP4
// multi_commanders := Replace ( multi_commanders , i , un ) ;
2610: NOP4
2614: PUSH
2615: NOP4
2619: PPUSH
2620: NOP4
2624: PPUSH
2625: NOP4
2629: PPUSH
2630: NOP4
2634: ST_TO_ADDR
// end ; InitHc ;
2635: NOP4
// InitUc ;
2639: NOP4
// uc_side := i ;
2643: LD_ADDR_OWVAR 20
2647: PUSH
2648: NOP4
2652: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
2653: LD_ADDR_OWVAR 21
2657: PUSH
2658: NOP4
2662: PUSH
2663: NOP4
2667: ARRAY
2668: ST_TO_ADDR
// hc_gallery :=  ;
2669: LD_ADDR_OWVAR 33
2673: PUSH
2674: LD_STRING 
2676: ST_TO_ADDR
// hc_name :=  ;
2677: LD_ADDR_OWVAR 26
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// hc_importance := 0 ;
2685: LD_ADDR_OWVAR 32
2689: PUSH
2690: LD_INT 0
2692: ST_TO_ADDR
// cl := 1 ;
2693: NOP4
2697: PUSH
2698: LD_INT 1
2700: ST_TO_ADDR
// for j = 2 to multi_pep_amount do
2701: NOP4
2705: PUSH
2706: DOUBLE
2707: LD_INT 2
2709: DEC
2710: ST_TO_ADDR
2711: NOP4
2715: PUSH
2716: FOR_TO
2717: IFFALSE 3089
// begin if ( j - 1 ) mod ( ( multi_pep_amount - 1 ) / 4 ) = 0 then
2719: NOP4
2723: PUSH
2724: LD_INT 1
2726: MINUS
2727: PUSH
2728: NOP4
2732: PUSH
2733: LD_INT 1
2735: MINUS
2736: PUSH
2737: LD_INT 4
2739: DIVREAL
2740: MOD
2741: PUSH
2742: LD_INT 0
2744: EQUAL
2745: IFFALSE 2761
// cl := cl + 1 ;
2747: NOP4
2751: PUSH
2752: NOP4
2756: PUSH
2757: LD_INT 1
2759: PLUS
2760: ST_TO_ADDR
// PrepareHuman ( false , cl , multi_skill_level ) ;
2761: LD_INT 0
2763: PPUSH
2764: NOP4
2768: PPUSH
2769: NOP4
2773: PPUSH
2774: NOP4
// un := CreateHuman ;
2778: NOP4
2782: PUSH
2783: NOP4
2787: ST_TO_ADDR
// if j > copy then
2788: NOP4
2792: PUSH
2793: NOP4
2797: GREATER
2798: IFFALSE 2827
// copy := Replace ( copy , j , un ) else
2800: NOP4
2804: PUSH
2805: NOP4
2809: PPUSH
2810: NOP4
2814: PPUSH
2815: NOP4
2819: PPUSH
2820: NOP4
2824: ST_TO_ADDR
2825: GO 2909
// begin CopySkills ( copy [ j ] , un ) ;
2827: NOP4
2831: PUSH
2832: NOP4
2836: ARRAY
2837: PPUSH
2838: NOP4
2842: PPUSH
2843: NOP4
// SetAttr ( un , attr_speed , GetAttr ( copy [ j ] , attr_speed ) ) ;
2847: NOP4
2851: PPUSH
2852: LD_INT 2
2854: PPUSH
2855: NOP4
2859: PUSH
2860: NOP4
2864: ARRAY
2865: PPUSH
2866: LD_INT 2
2868: PPUSH
2869: NOP4
2873: PPUSH
2874: NOP4
// SetAttr ( un , attr_stamina , GetAttr ( copy [ j ] , attr_stamina ) ) ;
2878: NOP4
2882: PPUSH
2883: LD_INT 1
2885: PPUSH
2886: NOP4
2890: PUSH
2891: NOP4
2895: ARRAY
2896: PPUSH
2897: LD_INT 1
2899: PPUSH
2900: NOP4
2904: PPUSH
2905: NOP4
// end ; if multi_pos_area then
2909: NOP4
2913: IFFALSE 3087
// begin if GetClass ( un ) = 3 then
2915: NOP4
2919: PPUSH
2920: NOP4
2924: PUSH
2925: LD_INT 3
2927: EQUAL
2928: IFFALSE 3054
// begin PrepareVehicle ( [ us_medium_tracked , us_medium_wheeled ] [ j mod 2 + 1 ] , engine_solar , control_manual , [ us_double_gun , us_gatling_gun , us_light_gun ] [ j mod 3 + 1 ] , 100 ) ;
2930: LD_INT 3
2932: PUSH
2933: LD_INT 2
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: PUSH
2940: NOP4
2944: PUSH
2945: LD_INT 2
2947: MOD
2948: PUSH
2949: LD_INT 1
2951: PLUS
2952: ARRAY
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: LD_INT 1
2959: PPUSH
2960: LD_INT 5
2962: PUSH
2963: LD_INT 4
2965: PUSH
2966: LD_INT 3
2968: PUSH
2969: EMPTY
2970: LIST
2971: LIST
2972: LIST
2973: PUSH
2974: NOP4
2978: PUSH
2979: LD_INT 3
2981: MOD
2982: PUSH
2983: LD_INT 1
2985: PLUS
2986: ARRAY
2987: PPUSH
2988: LD_INT 100
2990: PPUSH
2991: NOP4
// veh := CreateVehicle ;
2995: NOP4
2999: PUSH
3000: NOP4
3004: ST_TO_ADDR
// PlaceUnitArea ( veh , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
3005: NOP4
3009: PPUSH
3010: NOP4
3014: PUSH
3015: NOP4
3019: PUSH
3020: NOP4
3024: ARRAY
3025: ARRAY
3026: PUSH
3027: LD_INT 2
3029: ARRAY
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: NOP4
// PlaceHumanInUnit ( un , veh ) ;
3038: NOP4
3042: PPUSH
3043: NOP4
3047: PPUSH
3048: NOP4
// continue ;
3052: GO 2716
// end ; PlaceUnitArea ( un , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3054: NOP4
3058: PPUSH
3059: NOP4
3063: PUSH
3064: NOP4
3068: PUSH
3069: NOP4
3073: ARRAY
3074: ARRAY
3075: PUSH
3076: LD_INT 1
3078: ARRAY
3079: PPUSH
3080: LD_INT 0
3082: PPUSH
3083: NOP4
// end ; end ;
3087: GO 2716
3089: POP
3090: POP
// for j = 1 to 3 do
3091: NOP4
3095: PUSH
3096: DOUBLE
3097: LD_INT 1
3099: DEC
3100: ST_TO_ADDR
3101: LD_INT 3
3103: PUSH
3104: FOR_TO
3105: IFFALSE 3197
// begin PrepareVehicle ( [ us_medium_wheeled , us_medium_tracked ] [ rand ( 1 , 2 ) ] , engine_solar , control_computer , [ us_radar , us_rocket_launcher , us_gatling_gun ] [ j ] , 100 ) ;
3107: LD_INT 2
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 1
3119: PPUSH
3120: LD_INT 2
3122: PPUSH
3123: NOP4
3127: ARRAY
3128: PPUSH
3129: LD_INT 2
3131: PPUSH
3132: LD_INT 3
3134: PPUSH
3135: LD_INT 11
3137: PUSH
3138: LD_INT 7
3140: PUSH
3141: LD_INT 4
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PUSH
3149: NOP4
3153: ARRAY
3154: PPUSH
3155: LD_INT 100
3157: PPUSH
3158: NOP4
// PlaceUnitArea ( CreateVehicle , multi_pos_area [ multi_sides [ i ] ] [ 1 ] , false ) ;
3162: NOP4
3166: PPUSH
3167: NOP4
3171: PUSH
3172: NOP4
3176: PUSH
3177: NOP4
3181: ARRAY
3182: ARRAY
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: LD_INT 0
3190: PPUSH
3191: NOP4
// end ;
3195: GO 3104
3197: POP
3198: POP
// end ;
3199: GO 2310
3201: POP
3202: POP
// end ;
3203: LD_VAR 0 1
3207: RET
// export function Multiplayer_PrepareReinforcements ( ) ; var i , j , un , tmp ; begin
3208: LD_INT 0
3210: PPUSH
3211: PPUSH
3212: PPUSH
3213: PPUSH
3214: PPUSH
// if not multi_support then
3215: NOP4
3219: NOT
3220: IFFALSE 3224
// exit ;
3222: GO 3752
// result := [ ] ;
3224: NOP4
3228: PUSH
3229: EMPTY
3230: ST_TO_ADDR
// for i = 1 to 8 do
3231: NOP4
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 8
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3750
// begin if multi_sides [ i ] then
3247: NOP4
3251: PUSH
3252: NOP4
3256: ARRAY
3257: IFFALSE 3748
// begin tmp := [ ] ;
3259: NOP4
3263: PUSH
3264: EMPTY
3265: ST_TO_ADDR
// if multi_support = 1 then
3266: NOP4
3270: PUSH
3271: LD_INT 1
3273: EQUAL
3274: IFFALSE 3442
// begin uc_side := i ;
3276: LD_ADDR_OWVAR 20
3280: PUSH
3281: NOP4
3285: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3286: LD_ADDR_OWVAR 21
3290: PUSH
3291: NOP4
3295: PUSH
3296: NOP4
3300: ARRAY
3301: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: LD_INT 3
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 40
3316: PPUSH
3317: NOP4
// tmp := tmp ^ CreateVehicle ;
3321: NOP4
3325: PUSH
3326: NOP4
3330: PUSH
3331: NOP4
3335: ADD
3336: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_computer , us_double_gun , 40 ) ;
3337: LD_INT 2
3339: PPUSH
3340: LD_INT 1
3342: PPUSH
3343: LD_INT 3
3345: PPUSH
3346: LD_INT 5
3348: PPUSH
3349: LD_INT 40
3351: PPUSH
3352: NOP4
// tmp := tmp ^ CreateVehicle ;
3356: NOP4
3360: PUSH
3361: NOP4
3365: PUSH
3366: NOP4
3370: ADD
3371: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_gatling_gun , 40 ) ;
3372: LD_INT 2
3374: PPUSH
3375: LD_INT 3
3377: PPUSH
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 4
3383: PPUSH
3384: LD_INT 40
3386: PPUSH
3387: NOP4
// tmp := tmp ^ CreateVehicle ;
3391: NOP4
3395: PUSH
3396: NOP4
3400: PUSH
3401: NOP4
3405: ADD
3406: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_solar , control_computer , us_laser , 40 ) ;
3407: LD_INT 3
3409: PPUSH
3410: LD_INT 2
3412: PPUSH
3413: LD_INT 3
3415: PPUSH
3416: LD_INT 9
3418: PPUSH
3419: LD_INT 40
3421: PPUSH
3422: NOP4
// tmp := tmp ^ CreateVehicle ;
3426: NOP4
3430: PUSH
3431: NOP4
3435: PUSH
3436: NOP4
3440: ADD
3441: ST_TO_ADDR
// end ; if multi_support = 2 then
3442: NOP4
3446: PUSH
3447: LD_INT 2
3449: EQUAL
3450: IFFALSE 3723
// begin uc_side := i ;
3452: LD_ADDR_OWVAR 20
3456: PUSH
3457: NOP4
3461: ST_TO_ADDR
// uc_nation := multi_nations [ i ] ;
3462: LD_ADDR_OWVAR 21
3466: PUSH
3467: NOP4
3471: PUSH
3472: NOP4
3476: ARRAY
3477: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_combustion , control_computer , us_radar , 40 ) ;
3478: LD_INT 3
3480: PPUSH
3481: LD_INT 1
3483: PPUSH
3484: LD_INT 3
3486: PPUSH
3487: LD_INT 11
3489: PPUSH
3490: LD_INT 40
3492: PPUSH
3493: NOP4
// tmp := tmp ^ CreateVehicle ;
3497: NOP4
3501: PUSH
3502: NOP4
3506: PUSH
3507: NOP4
3511: ADD
3512: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 40 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 3
3521: PPUSH
3522: LD_INT 12
3524: PPUSH
3525: LD_INT 40
3527: PPUSH
3528: NOP4
// tmp := tmp ^ CreateVehicle ;
3532: NOP4
3536: PUSH
3537: NOP4
3541: PUSH
3542: NOP4
3546: ADD
3547: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_double_gun , 40 ) ;
3548: LD_INT 2
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: LD_INT 5
3559: PPUSH
3560: LD_INT 40
3562: PPUSH
3563: NOP4
// tmp := tmp ^ CreateVehicle ;
3567: NOP4
3571: PUSH
3572: NOP4
3576: PUSH
3577: NOP4
3581: ADD
3582: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3583: LD_INT 4
3585: PPUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 6
3594: PPUSH
3595: LD_INT 40
3597: PPUSH
3598: NOP4
// tmp := tmp ^ CreateVehicle ;
3602: NOP4
3606: PUSH
3607: NOP4
3611: PUSH
3612: NOP4
3616: ADD
3617: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3618: LD_INT 2
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 9
3629: PPUSH
3630: LD_INT 40
3632: PPUSH
3633: NOP4
// tmp := tmp ^ CreateVehicle ;
3637: NOP4
3641: PUSH
3642: NOP4
3646: PUSH
3647: NOP4
3651: ADD
3652: ST_TO_ADDR
// PrepareVehicle ( us_medium_wheeled , engine_siberite , control_computer , us_laser , 40 ) ;
3653: LD_INT 2
3655: PPUSH
3656: LD_INT 3
3658: PPUSH
3659: LD_INT 3
3661: PPUSH
3662: LD_INT 9
3664: PPUSH
3665: LD_INT 40
3667: PPUSH
3668: NOP4
// tmp := tmp ^ CreateVehicle ;
3672: NOP4
3676: PUSH
3677: NOP4
3681: PUSH
3682: NOP4
3686: ADD
3687: ST_TO_ADDR
// PrepareVehicle ( us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun , 40 ) ;
3688: LD_INT 4
3690: PPUSH
3691: LD_INT 1
3693: PPUSH
3694: LD_INT 3
3696: PPUSH
3697: LD_INT 6
3699: PPUSH
3700: LD_INT 40
3702: PPUSH
3703: NOP4
// tmp := tmp ^ CreateVehicle ;
3707: NOP4
3711: PUSH
3712: NOP4
3716: PUSH
3717: NOP4
3721: ADD
3722: ST_TO_ADDR
// end ; result := Insert ( result , i , tmp ) ;
3723: NOP4
3727: PUSH
3728: NOP4
3732: PPUSH
3733: NOP4
3737: PPUSH
3738: NOP4
3742: PPUSH
3743: NOP4
3747: ST_TO_ADDR
// end ; end ;
3748: GO 3244
3750: POP
3751: POP
// end ;
3752: LD_VAR 0 1
3756: RET
// export function Multiplayer_Start ( ) ; begin
3757: LD_INT 0
3759: PPUSH
// Multiplayer_PreparePlayers ( ) ;
3760: NOP4
// Multiplayer_InitPointSystem ( ) ;
3764: NOP4
// Multiplayer_RegisterCondition ( 20 ) ;
3768: LD_INT 20
3770: PPUSH
3771: NOP4
// Multiplayer_RegisterCondition ( 150 ) ;
3775: LD_INT 150
3777: PPUSH
3778: NOP4
// Multiplayer_RegisterCondition ( 5 ) ;
3782: LD_INT 5
3784: PPUSH
3785: NOP4
// Multiplayer_RegisterCondition ( - 40 ) ;
3789: LD_INT 40
3791: NEG
3792: PPUSH
3793: NOP4
// Multiplayer_RegisterCondition ( 200 ) ;
3797: LD_INT 200
3799: PPUSH
3800: NOP4
// Multiplayer_RegisterCondition ( 2 ) ;
3804: LD_INT 2
3806: PPUSH
3807: NOP4
// Multiplayer_SpawnArtifact ;
3811: NOP4
// if multi_support then
3815: NOP4
3819: IFFALSE 3831
// multi_reinforcements := Multiplayer_PrepareReinforcements ( ) ;
3821: NOP4
3825: PUSH
3826: NOP4
3830: ST_TO_ADDR
// game := true ;
3831: NOP4
3835: PUSH
3836: LD_INT 1
3838: ST_TO_ADDR
// if multi_sides [ your_side ] then
3839: NOP4
3843: PUSH
3844: NOP4
3848: ARRAY
3849: IFFALSE 3876
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , your_side ] ) [ 1 ] ) ;
3851: LD_INT 22
3853: PUSH
3854: NOP4
3858: PUSH
3859: EMPTY
3860: LIST
3861: LIST
3862: PPUSH
3863: NOP4
3867: PUSH
3868: LD_INT 1
3870: ARRAY
3871: PPUSH
3872: NOP4
// end ;
3876: LD_VAR 0 1
3880: RET
// export function Multiplayer_End ( ) ; var i , j , tmp , reinforcements_arrive ; begin
3881: LD_INT 0
3883: PPUSH
3884: PPUSH
3885: PPUSH
3886: PPUSH
3887: PPUSH
// reinforcements_arrive := 0 ;
3888: NOP4
3892: PUSH
3893: LD_INT 0
3895: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3896: LD_INT 35
3898: PPUSH
3899: NOP4
// if tick > 10 10$00 and not multi_reinforcements_spawned and multi_support = 1 then
3903: NOP4
3907: PUSH
3908: LD_INT 21000
3910: GREATER
3911: PUSH
3912: NOP4
3916: NOT
3917: AND
3918: PUSH
3919: NOP4
3923: PUSH
3924: LD_INT 1
3926: EQUAL
3927: AND
3928: IFFALSE 4123
// begin multi_reinforcements_spawned := 1 ;
3930: NOP4
3934: PUSH
3935: LD_INT 1
3937: ST_TO_ADDR
// for i = 1 to 8 do
3938: NOP4
3942: PUSH
3943: DOUBLE
3944: LD_INT 1
3946: DEC
3947: ST_TO_ADDR
3948: LD_INT 8
3950: PUSH
3951: FOR_TO
3952: IFFALSE 4111
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
3954: NOP4
3958: PUSH
3959: NOP4
3963: ARRAY
3964: PUSH
3965: NOP4
3969: PUSH
3970: NOP4
3974: ARRAY
3975: NOT
3976: AND
3977: PUSH
3978: NOP4
3982: PUSH
3983: NOP4
3987: ARRAY
3988: AND
3989: IFFALSE 4109
// begin tmp := multi_reinforcements [ i ] ;
3991: NOP4
3995: PUSH
3996: NOP4
4000: PUSH
4001: NOP4
4005: ARRAY
4006: ST_TO_ADDR
// for j = 1 to 4 do
4007: NOP4
4011: PUSH
4012: DOUBLE
4013: LD_INT 1
4015: DEC
4016: ST_TO_ADDR
4017: LD_INT 4
4019: PUSH
4020: FOR_TO
4021: IFFALSE 4082
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4023: NOP4
4027: PUSH
4028: NOP4
4032: ARRAY
4033: PPUSH
4034: NOP4
4038: PUSH
4039: NOP4
4043: PUSH
4044: NOP4
4048: ARRAY
4049: ARRAY
4050: PUSH
4051: LD_INT 2
4053: ARRAY
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: NOP4
// tmp := Delete ( tmp , 1 ) ;
4062: NOP4
4066: PUSH
4067: NOP4
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: NOP4
4079: ST_TO_ADDR
// end ;
4080: GO 4020
4082: POP
4083: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4084: NOP4
4088: PUSH
4089: NOP4
4093: PPUSH
4094: NOP4
4098: PPUSH
4099: NOP4
4103: PPUSH
4104: NOP4
4108: ST_TO_ADDR
// end ; end ;
4109: GO 3951
4111: POP
4112: POP
// reinforcements_arrive := tick ;
4113: NOP4
4117: PUSH
4118: NOP4
4122: ST_TO_ADDR
// end ; if reinforcements_arrive + 10 10$00 < tick and multi_reinforcements_spawned = 1 and multi_support = 2 then
4123: NOP4
4127: PUSH
4128: LD_INT 21000
4130: PLUS
4131: PUSH
4132: NOP4
4136: LESS
4137: PUSH
4138: NOP4
4142: PUSH
4143: LD_INT 1
4145: EQUAL
4146: AND
4147: PUSH
4148: NOP4
4152: PUSH
4153: LD_INT 2
4155: EQUAL
4156: AND
4157: IFFALSE 4342
// begin multi_reinforcements_spawned := 2 ;
4159: NOP4
4163: PUSH
4164: LD_INT 2
4166: ST_TO_ADDR
// for i = 1 to 8 do
4167: NOP4
4171: PUSH
4172: DOUBLE
4173: LD_INT 1
4175: DEC
4176: ST_TO_ADDR
4177: LD_INT 8
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4340
// begin if multi_sides [ i ] and not multi_loosers [ i ] and multi_reinforcements [ i ] then
4183: NOP4
4187: PUSH
4188: NOP4
4192: ARRAY
4193: PUSH
4194: NOP4
4198: PUSH
4199: NOP4
4203: ARRAY
4204: NOT
4205: AND
4206: PUSH
4207: NOP4
4211: PUSH
4212: NOP4
4216: ARRAY
4217: AND
4218: IFFALSE 4338
// begin tmp := multi_reinforcements [ i ] ;
4220: NOP4
4224: PUSH
4225: NOP4
4229: PUSH
4230: NOP4
4234: ARRAY
4235: ST_TO_ADDR
// for j = 1 to 3 do
4236: NOP4
4240: PUSH
4241: DOUBLE
4242: LD_INT 1
4244: DEC
4245: ST_TO_ADDR
4246: LD_INT 3
4248: PUSH
4249: FOR_TO
4250: IFFALSE 4311
// begin PlaceUnitArea ( tmp [ j ] , multi_pos_area [ multi_sides [ i ] ] [ 2 ] , false ) ;
4252: NOP4
4256: PUSH
4257: NOP4
4261: ARRAY
4262: PPUSH
4263: NOP4
4267: PUSH
4268: NOP4
4272: PUSH
4273: NOP4
4277: ARRAY
4278: ARRAY
4279: PUSH
4280: LD_INT 2
4282: ARRAY
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: NOP4
// tmp := Delete ( tmp , 1 ) ;
4291: NOP4
4295: PUSH
4296: NOP4
4300: PPUSH
4301: LD_INT 1
4303: PPUSH
4304: NOP4
4308: ST_TO_ADDR
// end ;
4309: GO 4249
4311: POP
4312: POP
// multi_reinforcements := Replace ( multi_reinforcements , i , tmp ) ;
4313: NOP4
4317: PUSH
4318: NOP4
4322: PPUSH
4323: NOP4
4327: PPUSH
4328: NOP4
4332: PPUSH
4333: NOP4
4337: ST_TO_ADDR
// end ; end ;
4338: GO 4180
4340: POP
4341: POP
// end ; if not multi_custom_commanders then
4342: NOP4
4346: NOT
4347: IFFALSE 4460
// begin for i = 1 to 8 do
4349: NOP4
4353: PUSH
4354: DOUBLE
4355: LD_INT 1
4357: DEC
4358: ST_TO_ADDR
4359: LD_INT 8
4361: PUSH
4362: FOR_TO
4363: IFFALSE 4434
// begin if FilterAllUnits ( [ f_side , i ] ) = 0 and not multi_loosers [ i ] then
4365: LD_INT 22
4367: PUSH
4368: NOP4
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PPUSH
4377: NOP4
4381: PUSH
4382: LD_INT 0
4384: EQUAL
4385: PUSH
4386: NOP4
4390: PUSH
4391: NOP4
4395: ARRAY
4396: NOT
4397: AND
4398: IFFALSE 4432
// begin multi_loosers := Replace ( multi_loosers , i , 1 ) ;
4400: NOP4
4404: PUSH
4405: NOP4
4409: PPUSH
4410: NOP4
4414: PPUSH
4415: LD_INT 1
4417: PPUSH
4418: NOP4
4422: ST_TO_ADDR
// Multiplayer_Reside ( i ) ;
4423: NOP4
4427: PPUSH
4428: NOP4
// end ; end ;
4432: GO 4362
4434: POP
4435: POP
// if Count ( multi_loosers ) = Count ( multi_sides ) then
4436: NOP4
4440: PPUSH
4441: NOP4
4445: PUSH
4446: NOP4
4450: PPUSH
4451: NOP4
4455: EQUAL
4456: IFFALSE 4460
// break ;
4458: GO 4495
// end ; until ( FilterAllUnits ( [ f_side , side_bot ] ) = 0 and game ) or not multi_commanders ;
4460: LD_INT 22
4462: PUSH
4463: NOP4
4467: PUSH
4468: EMPTY
4469: LIST
4470: LIST
4471: PPUSH
4472: NOP4
4476: PUSH
4477: LD_INT 0
4479: EQUAL
4480: PUSH
4481: NOP4
4485: AND
4486: PUSH
4487: NOP4
4491: NOT
4492: OR
4493: IFFALSE 3896
// game := false ;
4495: NOP4
4499: PUSH
4500: LD_INT 0
4502: ST_TO_ADDR
// for i = 1 to 8 do
4503: NOP4
4507: PUSH
4508: DOUBLE
4509: LD_INT 1
4511: DEC
4512: ST_TO_ADDR
4513: LD_INT 8
4515: PUSH
4516: FOR_TO
4517: IFFALSE 4553
// begin if multi_sides [ i ] then
4519: NOP4
4523: PUSH
4524: NOP4
4528: ARRAY
4529: IFFALSE 4551
// SetMultiScore ( i , multi_points [ i ] ) ;
4531: NOP4
4535: PPUSH
4536: NOP4
4540: PUSH
4541: NOP4
4545: ARRAY
4546: PPUSH
4547: NOP4
// end ;
4551: GO 4516
4553: POP
4554: POP
// if multi_loosers [ your_side ] then
4555: NOP4
4559: PUSH
4560: NOP4
4564: ARRAY
4565: IFFALSE 4573
// YouLostInMultiplayer else
4567: NOP4
4571: GO 4577
// YouWinInMultiplayer ;
4573: NOP4
// end ;
4577: LD_VAR 0 1
4581: RET
// export function Multiplayer_DisplayStrings ( ) ; var i ; begin
4582: LD_INT 0
4584: PPUSH
4585: PPUSH
// result := [ #tick , tick ] ;
4586: NOP4
4590: PUSH
4591: LD_STRING #tick
4593: PUSH
4594: NOP4
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: ST_TO_ADDR
// for i = 1 to 8 do
4603: NOP4
4607: PUSH
4608: DOUBLE
4609: LD_INT 1
4611: DEC
4612: ST_TO_ADDR
4613: LD_INT 8
4615: PUSH
4616: FOR_TO
4617: IFFALSE 4674
// begin if multi_sides [ i ] then
4619: NOP4
4623: PUSH
4624: NOP4
4628: ARRAY
4629: IFFALSE 4672
// begin result := result ^ [ #coop-points , i , i , multi_points [ i ] ] ;
4631: NOP4
4635: PUSH
4636: NOP4
4640: PUSH
4641: LD_STRING #coop-points
4643: PUSH
4644: NOP4
4648: PUSH
4649: NOP4
4653: PUSH
4654: NOP4
4658: PUSH
4659: NOP4
4663: ARRAY
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: LIST
4669: LIST
4670: ADD
4671: ST_TO_ADDR
// end ; end ;
4672: GO 4616
4674: POP
4675: POP
// end ;
4676: LD_VAR 0 1
4680: RET
// export multi_points , multi_points_conditions ; export function Multiplayer_InitPointSystem ( ) ; var i ; begin
4681: LD_INT 0
4683: PPUSH
4684: PPUSH
// multi_points := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4685: NOP4
4689: PUSH
4690: LD_INT 0
4692: PUSH
4693: LD_INT 0
4695: PUSH
4696: LD_INT 0
4698: PUSH
4699: LD_INT 0
4701: PUSH
4702: LD_INT 0
4704: PUSH
4705: LD_INT 0
4707: PUSH
4708: LD_INT 0
4710: PUSH
4711: LD_INT 0
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: ST_TO_ADDR
// multi_points_conditions := [ ] ;
4724: NOP4
4728: PUSH
4729: EMPTY
4730: ST_TO_ADDR
// end ;
4731: LD_VAR 0 1
4735: RET
// export function Multiplayer_AddPoints ( side , amount ) ; begin
4736: LD_INT 0
4738: PPUSH
// if not multi_points or not side or side > 8 then
4739: NOP4
4743: NOT
4744: PUSH
4745: NOP4
4749: NOT
4750: OR
4751: PUSH
4752: NOP4
4756: PUSH
4757: LD_INT 8
4759: GREATER
4760: OR
4761: IFFALSE 4765
// exit ;
4763: GO 4802
// multi_points := Replace ( multi_points , side , multi_points [ side ] + amount ) ;
4765: NOP4
4769: PUSH
4770: NOP4
4774: PPUSH
4775: NOP4
4779: PPUSH
4780: NOP4
4784: PUSH
4785: NOP4
4789: ARRAY
4790: PUSH
4791: NOP4
4795: PLUS
4796: PPUSH
4797: NOP4
4801: ST_TO_ADDR
// end ;
4802: LD_VAR 0 3
4806: RET
// export function Multiplayer_GetPoints ( side ) ; begin
4807: LD_INT 0
4809: PPUSH
// if not multi_points or not side or side > 8 then
4810: NOP4
4814: NOT
4815: PUSH
4816: NOP4
4820: NOT
4821: OR
4822: PUSH
4823: NOP4
4827: PUSH
4828: LD_INT 8
4830: GREATER
4831: OR
4832: IFFALSE 4836
// exit ;
4834: GO 4852
// result := multi_points [ side ] ;
4836: NOP4
4840: PUSH
4841: NOP4
4845: PUSH
4846: NOP4
4850: ARRAY
4851: ST_TO_ADDR
// end ;
4852: LD_VAR 0 2
4856: RET
// export function Multiplayer_RegisterCondition ( points ) ; begin
4857: LD_INT 0
4859: PPUSH
// multi_points_conditions := Insert ( multi_points_conditions , multi_points_conditions + 1 , points ) ;
4860: NOP4
4864: PUSH
4865: NOP4
4869: PPUSH
4870: NOP4
4874: PUSH
4875: LD_INT 1
4877: PLUS
4878: PPUSH
4879: NOP4
4883: PPUSH
4884: NOP4
4888: ST_TO_ADDR
// end ;
4889: LD_VAR 0 2
4893: RET
// export function Multiplayer_GetCondition ( id ) ; begin
4894: LD_INT 0
4896: PPUSH
// if not id then
4897: NOP4
4901: NOT
4902: IFFALSE 4906
// exit ;
4904: GO 4922
// result := multi_points_conditions [ id ] ;
4906: NOP4
4910: PUSH
4911: NOP4
4915: PUSH
4916: NOP4
4920: ARRAY
4921: ST_TO_ADDR
// end ;
4922: LD_VAR 0 2
4926: RET
// export function Multiplayer_Reside ( side ) ; var players , i , j , tmp ; begin
4927: LD_INT 0
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
4933: PPUSH
// players := [ ] ;
4934: NOP4
4938: PUSH
4939: EMPTY
4940: ST_TO_ADDR
// for i = 1 to 8 do
4941: NOP4
4945: PUSH
4946: DOUBLE
4947: LD_INT 1
4949: DEC
4950: ST_TO_ADDR
4951: LD_INT 8
4953: PUSH
4954: FOR_TO
4955: IFFALSE 5014
// begin if i = side then
4957: NOP4
4961: PUSH
4962: NOP4
4966: EQUAL
4967: IFFALSE 4971
// continue ;
4969: GO 4954
// if multi_sides [ i ] and not multi_loosers [ i ] then
4971: NOP4
4975: PUSH
4976: NOP4
4980: ARRAY
4981: PUSH
4982: NOP4
4986: PUSH
4987: NOP4
4991: ARRAY
4992: NOT
4993: AND
4994: IFFALSE 5012
// players := players ^ i ;
4996: NOP4
5000: PUSH
5001: NOP4
5005: PUSH
5006: NOP4
5010: ADD
5011: ST_TO_ADDR
// end ;
5012: GO 4954
5014: POP
5015: POP
// if not players then
5016: NOP4
5020: NOT
5021: IFFALSE 5025
// exit ;
5023: GO 5292
// if players = 1 then
5025: NOP4
5029: PUSH
5030: LD_INT 1
5032: EQUAL
5033: IFFALSE 5094
// begin for i in FilterAllUnits ( [ [ f_side , side ] , [ f_alive ] ] ) do
5035: NOP4
5039: PUSH
5040: LD_INT 22
5042: PUSH
5043: NOP4
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PUSH
5052: LD_INT 51
5054: PUSH
5055: EMPTY
5056: LIST
5057: PUSH
5058: EMPTY
5059: LIST
5060: LIST
5061: PPUSH
5062: NOP4
5066: PUSH
5067: FOR_IN
5068: IFFALSE 5090
// SetSide ( i , players [ 1 ] ) ;
5070: NOP4
5074: PPUSH
5075: NOP4
5079: PUSH
5080: LD_INT 1
5082: ARRAY
5083: PPUSH
5084: NOP4
5088: GO 5067
5090: POP
5091: POP
// end else
5092: GO 5292
// begin j := 1 ;
5094: NOP4
5098: PUSH
5099: LD_INT 1
5101: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ [ f_type , unit_human ] , [ f_alive ] ] , [ f_type , unit_vehicle ] ] ] ) do
5102: NOP4
5106: PUSH
5107: LD_INT 22
5109: PUSH
5110: NOP4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 2
5121: PUSH
5122: LD_INT 21
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 51
5134: PUSH
5135: EMPTY
5136: LIST
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: LD_INT 21
5144: PUSH
5145: LD_INT 2
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: NOP4
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5290
// begin SetSide ( i , players [ j ] ) ;
5169: NOP4
5173: PPUSH
5174: NOP4
5178: PUSH
5179: NOP4
5183: ARRAY
5184: PPUSH
5185: NOP4
// if IsDrivenBy ( i ) then
5189: NOP4
5193: PPUSH
5194: NOP4
5198: IFFALSE 5225
// SetSide ( IsDrivenBy ( i ) , players [ j ] ) ;
5200: NOP4
5204: PPUSH
5205: NOP4
5209: PPUSH
5210: NOP4
5214: PUSH
5215: NOP4
5219: ARRAY
5220: PPUSH
5221: NOP4
// if GetType ( IsInUnit ( i ) ) = unit_building then
5225: NOP4
5229: PPUSH
5230: NOP4
5234: PPUSH
5235: NOP4
5239: PUSH
5240: LD_INT 3
5242: EQUAL
5243: IFFALSE 5254
// ComExitBuilding ( i ) ;
5245: NOP4
5249: PPUSH
5250: NOP4
// j := j + 1 ;
5254: NOP4
5258: PUSH
5259: NOP4
5263: PUSH
5264: LD_INT 1
5266: PLUS
5267: ST_TO_ADDR
// if j > players then
5268: NOP4
5272: PUSH
5273: NOP4
5277: GREATER
5278: IFFALSE 5288
// j := 1 ;
5280: NOP4
5284: PUSH
5285: LD_INT 1
5287: ST_TO_ADDR
// end ;
5288: GO 5166
5290: POP
5291: POP
// end ; end ;
5292: LD_VAR 0 2
5296: RET
// export function Multiplayer_SpawnArtifact ( ) ; var i , pos ; begin
5297: LD_INT 0
5299: PPUSH
5300: PPUSH
5301: PPUSH
// pos := [ [ 5 , 10 ] , [ 120 , 2 ] , [ 101 , 8 ] , [ 27 , 4 ] ] ;
5302: NOP4
5306: PUSH
5307: LD_INT 5
5309: PUSH
5310: LD_INT 10
5312: PUSH
5313: EMPTY
5314: LIST
5315: LIST
5316: PUSH
5317: LD_INT 120
5319: PUSH
5320: LD_INT 2
5322: PUSH
5323: EMPTY
5324: LIST
5325: LIST
5326: PUSH
5327: LD_INT 101
5329: PUSH
5330: LD_INT 8
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: PUSH
5337: LD_INT 27
5339: PUSH
5340: LD_INT 4
5342: PUSH
5343: EMPTY
5344: LIST
5345: LIST
5346: PUSH
5347: EMPTY
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: ST_TO_ADDR
// i := rand ( 1 , pos ) ;
5353: NOP4
5357: PUSH
5358: LD_INT 1
5360: PPUSH
5361: NOP4
5365: PPUSH
5366: NOP4
5370: ST_TO_ADDR
// CreateResourcesXY ( mat_artifact , 5 , pos [ i ] [ 1 ] , pos [ i ] [ 2 ] , false ) ;
5371: LD_INT 4
5373: PPUSH
5374: LD_INT 5
5376: PPUSH
5377: NOP4
5381: PUSH
5382: NOP4
5386: ARRAY
5387: PUSH
5388: LD_INT 1
5390: ARRAY
5391: PPUSH
5392: NOP4
5396: PUSH
5397: NOP4
5401: ARRAY
5402: PUSH
5403: LD_INT 2
5405: ARRAY
5406: PPUSH
5407: LD_INT 0
5409: PPUSH
5410: NOP4
// end ;
5414: LD_VAR 0 1
5418: RET
// export function MultiplayerEvent_Produced ( side ) ; begin
5419: LD_INT 0
5421: PPUSH
// if not side or side > 8 then
5422: NOP4
5426: NOT
5427: PUSH
5428: NOP4
5432: PUSH
5433: LD_INT 8
5435: GREATER
5436: OR
5437: IFFALSE 5441
// exit ;
5439: GO 5458
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 6 ) ) ;
5441: NOP4
5445: PPUSH
5446: LD_INT 6
5448: PPUSH
5449: NOP4
5453: PPUSH
5454: NOP4
// end ;
5458: LD_VAR 0 2
5462: RET
// export function MultiplayerEvent_HumanLost ( side ) ; begin
5463: LD_INT 0
5465: PPUSH
// if not side or side > 8 then
5466: NOP4
5470: NOT
5471: PUSH
5472: NOP4
5476: PUSH
5477: LD_INT 8
5479: GREATER
5480: OR
5481: IFFALSE 5485
// exit ;
5483: GO 5502
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 4 ) ) ;
5485: NOP4
5489: PPUSH
5490: LD_INT 4
5492: PPUSH
5493: NOP4
5497: PPUSH
5498: NOP4
// end ;
5502: LD_VAR 0 2
5506: RET
// export function MultiplayerEvent_BuildingCompleted ( side , btype ) ; begin
5507: LD_INT 0
5509: PPUSH
// if not side or side > 8 or not btype in [ b_workshop , b_lab , b_control_tower , b_depot ] then
5510: NOP4
5514: NOT
5515: PUSH
5516: NOP4
5520: PUSH
5521: LD_INT 8
5523: GREATER
5524: OR
5525: PUSH
5526: NOP4
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 36
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: IN
5549: NOT
5550: OR
5551: IFFALSE 5555
// exit ;
5553: GO 5572
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 3 ) ) ;
5555: NOP4
5559: PPUSH
5560: LD_INT 3
5562: PPUSH
5563: NOP4
5567: PPUSH
5568: NOP4
// end ;
5572: LD_VAR 0 3
5576: RET
// export function MultiplayerEvent_UnitKilled ( un , points ) ; var side , side2 , last_shoot , nearest_unit , gained_points ; begin
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// if not un then
5585: NOP4
5589: NOT
5590: IFFALSE 5594
// exit ;
5592: GO 5818
// if not points then
5594: NOP4
5598: NOT
5599: IFFALSE 5616
// gained_points := Multiplayer_GetCondition ( 1 ) else
5601: NOP4
5605: PUSH
5606: LD_INT 1
5608: PPUSH
5609: NOP4
5613: ST_TO_ADDR
5614: GO 5626
// gained_points := points ;
5616: NOP4
5620: PUSH
5621: NOP4
5625: ST_TO_ADDR
// last_shoot := SideShoot ( un ) ;
5626: NOP4
5630: PUSH
5631: NOP4
5635: PPUSH
5636: NOP4
5640: ST_TO_ADDR
// if last_shoot > - 1 then
5641: NOP4
5645: PUSH
5646: LD_INT 1
5648: NEG
5649: GREATER
5650: IFFALSE 5662
// begin side := last_shoot ;
5652: NOP4
5656: PUSH
5657: NOP4
5661: ST_TO_ADDR
// end ; nearest_unit := NearestUnitToUnit ( all_units diff FilterAllUnits ( [ f_side , GetSide ( un ) ] ) , un ) ;
5662: NOP4
5666: PUSH
5667: NOP4
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: NOP4
5679: PPUSH
5680: NOP4
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PPUSH
5689: NOP4
5693: DIFF
5694: PPUSH
5695: NOP4
5699: PPUSH
5700: NOP4
5704: ST_TO_ADDR
// if nearest_unit then
5705: NOP4
5709: IFFALSE 5726
// side2 := GetSide ( nearest_unit ) ;
5711: NOP4
5715: PUSH
5716: NOP4
5720: PPUSH
5721: NOP4
5725: ST_TO_ADDR
// if not side and not side2 then
5726: NOP4
5730: NOT
5731: PUSH
5732: NOP4
5736: NOT
5737: AND
5738: IFFALSE 5742
// exit ;
5740: GO 5818
// if side = side2 then
5742: NOP4
5746: PUSH
5747: NOP4
5751: EQUAL
5752: IFFALSE 5770
// Multiplayer_AddPoints ( side , gained_points ) else
5754: NOP4
5758: PPUSH
5759: NOP4
5763: PPUSH
5764: NOP4
5768: GO 5818
// begin if side then
5770: NOP4
5774: IFFALSE 5794
// Multiplayer_AddPoints ( side , gained_points div 2 ) ;
5776: NOP4
5780: PPUSH
5781: NOP4
5785: PUSH
5786: LD_INT 2
5788: DIV
5789: PPUSH
5790: NOP4
// if side2 then
5794: NOP4
5798: IFFALSE 5818
// Multiplayer_AddPoints ( side2 , gained_points div 2 ) ;
5800: NOP4
5804: PPUSH
5805: NOP4
5809: PUSH
5810: LD_INT 2
5812: DIV
5813: PPUSH
5814: NOP4
// end ; end ;
5818: LD_VAR 0 3
5822: RET
// export function MultiplayerEvent_ArtifactCaptured ( side ) ; begin
5823: LD_INT 0
5825: PPUSH
// Multiplayer_AddPoints ( side , Multiplayer_GetCondition ( 2 ) ) ;
5826: NOP4
5830: PPUSH
5831: LD_INT 2
5833: PPUSH
5834: NOP4
5838: PPUSH
5839: NOP4
// end ; end_of_file
5843: LD_VAR 0 2
5847: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ( side ) ; var i , d , xy , un , un2 , skill , tmp , techs ; begin
5848: LD_INT 0
5850: PPUSH
5851: PPUSH
5852: PPUSH
5853: PPUSH
5854: PPUSH
5855: PPUSH
5856: PPUSH
5857: PPUSH
5858: PPUSH
// tmp := FilterAllUnits ( [ f_side , 2 ] ) ;
5859: NOP4
5863: PUSH
5864: LD_INT 22
5866: PUSH
5867: LD_INT 2
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: PPUSH
5874: NOP4
5878: ST_TO_ADDR
// side_bot := side ;
5879: NOP4
5883: PUSH
5884: NOP4
5888: ST_TO_ADDR
// if tmp and side <> 2 then
5889: NOP4
5893: PUSH
5894: NOP4
5898: PUSH
5899: LD_INT 2
5901: NONEQUAL
5902: AND
5903: IFFALSE 5940
// begin for i in tmp do
5905: NOP4
5909: PUSH
5910: NOP4
5914: PUSH
5915: FOR_IN
5916: IFFALSE 5934
// SetSide ( i , side ) ;
5918: NOP4
5922: PPUSH
5923: NOP4
5927: PPUSH
5928: NOP4
5932: GO 5915
5934: POP
5935: POP
// ResetFog ;
5936: NOP4
// end ; techs := [ tech_ApeAgres , tech_ApeBrain , tech_ApeNeural , tech_StimDrugs , tech_Bio1 , tech_Bio2 , tech_Weap3 , tech_RemCharge , tech_rocket , tech_SibEng , 72 , tech_Sib2 ] ;
5940: NOP4
5944: PUSH
5945: LD_INT 11
5947: PUSH
5948: LD_INT 4
5950: PUSH
5951: LD_INT 3
5953: PUSH
5954: LD_INT 5
5956: PUSH
5957: LD_INT 66
5959: PUSH
5960: LD_INT 67
5962: PUSH
5963: LD_INT 53
5965: PUSH
5966: LD_INT 18
5968: PUSH
5969: LD_INT 40
5971: PUSH
5972: LD_INT 22
5974: PUSH
5975: LD_INT 72
5977: PUSH
5978: LD_INT 55
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: ST_TO_ADDR
// for i in techs do
5995: NOP4
5999: PUSH
6000: NOP4
6004: PUSH
6005: FOR_IN
6006: IFFALSE 6027
// SetTech ( i , side , state_researched ) ;
6008: NOP4
6012: PPUSH
6013: NOP4
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: NOP4
6025: GO 6005
6027: POP
6028: POP
// skill := [ 6 , 7 , 8 ] [ Difficulty ] ;
6029: NOP4
6033: PUSH
6034: LD_INT 6
6036: PUSH
6037: LD_INT 7
6039: PUSH
6040: LD_INT 8
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: NOP4
6052: ARRAY
6053: ST_TO_ADDR
// ComLinkToBase ( [ ar_dep_e ] , 141 ) ;
6054: LD_INT 69
6056: PUSH
6057: EMPTY
6058: LIST
6059: PPUSH
6060: LD_INT 141
6062: PPUSH
6063: NOP4
// Wait ( 1 ) ;
6067: LD_INT 1
6069: PPUSH
6070: NOP4
// uc_side := side ;
6074: LD_ADDR_OWVAR 20
6078: PUSH
6079: NOP4
6083: ST_TO_ADDR
// uc_nation := 2 ;
6084: LD_ADDR_OWVAR 21
6088: PUSH
6089: LD_INT 2
6091: ST_TO_ADDR
// ar_force_north := PrepareBase ( ar_dep_n , area_base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , 4 , - 1 , 4 ] ) ;
6092: NOP4
6096: PUSH
6097: LD_INT 94
6099: PPUSH
6100: LD_INT 35
6102: PPUSH
6103: LD_STRING dammam
6105: PPUSH
6106: NOP4
6110: PPUSH
6111: LD_INT 10000
6113: PUSH
6114: LD_INT 1000
6116: PUSH
6117: LD_INT 300
6119: PUSH
6120: EMPTY
6121: LIST
6122: LIST
6123: LIST
6124: PPUSH
6125: LD_INT 12
6127: PUSH
6128: LD_INT 4
6130: PUSH
6131: LD_INT 1
6133: NEG
6134: PUSH
6135: LD_INT 4
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: PPUSH
6144: NOP4
6148: ST_TO_ADDR
// ar_force_north2 := PrepareBase ( ar_dep_n2 , area_base_north2 ,  , skill , [ 1000 , 100 , 0 ] , [ 12 , 4 , 2 , 0 ] ) ;
6149: NOP4
6153: PUSH
6154: LD_INT 122
6156: PPUSH
6157: LD_INT 38
6159: PPUSH
6160: LD_STRING 
6162: PPUSH
6163: NOP4
6167: PPUSH
6168: LD_INT 1000
6170: PUSH
6171: LD_INT 100
6173: PUSH
6174: LD_INT 0
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: PPUSH
6182: LD_INT 12
6184: PUSH
6185: LD_INT 4
6187: PUSH
6188: LD_INT 2
6190: PUSH
6191: LD_INT 0
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: LIST
6198: LIST
6199: PPUSH
6200: NOP4
6204: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , area_base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 12 , 4 , 3 , 2 ] ) ;
6205: NOP4
6209: PUSH
6210: LD_INT 45
6212: PPUSH
6213: LD_INT 34
6215: PPUSH
6216: LD_STRING jeddah
6218: PPUSH
6219: NOP4
6223: PPUSH
6224: LD_INT 700
6226: PUSH
6227: LD_INT 300
6229: PUSH
6230: LD_INT 10
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: LD_INT 12
6240: PUSH
6241: LD_INT 4
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 2
6249: PUSH
6250: EMPTY
6251: LIST
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: NOP4
6260: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , area_base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
6261: NOP4
6265: PUSH
6266: LD_INT 7
6268: PPUSH
6269: LD_INT 33
6271: PPUSH
6272: LD_STRING riyadh
6274: PPUSH
6275: NOP4
6279: PPUSH
6280: LD_INT 500
6282: PUSH
6283: LD_INT 60
6285: PUSH
6286: LD_INT 0
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: PPUSH
6294: LD_INT 4
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: LIST
6311: PPUSH
6312: NOP4
6316: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , area_base_east ,  , skill , [ 500 , 50 , 0 ] , [ 11 , 2 , 3 , 1 ] ) ;
6317: NOP4
6321: PUSH
6322: LD_INT 69
6324: PPUSH
6325: LD_INT 36
6327: PPUSH
6328: LD_STRING 
6330: PPUSH
6331: NOP4
6335: PPUSH
6336: LD_INT 500
6338: PUSH
6339: LD_INT 50
6341: PUSH
6342: LD_INT 0
6344: PUSH
6345: EMPTY
6346: LIST
6347: LIST
6348: LIST
6349: PPUSH
6350: LD_INT 11
6352: PUSH
6353: LD_INT 2
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: LD_INT 1
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: PPUSH
6368: NOP4
6372: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east , ar_force_south , ar_force_north2 ] ;
6373: NOP4
6377: PUSH
6378: NOP4
6382: PUSH
6383: NOP4
6387: PUSH
6388: NOP4
6392: PUSH
6393: NOP4
6397: PUSH
6398: NOP4
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
6410: LD_ADDR_OWVAR 37
6414: PUSH
6415: LD_INT 14
6417: ST_TO_ADDR
// vc_engine := engine_siberite ;
6418: LD_ADDR_OWVAR 39
6422: PUSH
6423: LD_INT 3
6425: ST_TO_ADDR
// vc_control := control_manual ;
6426: LD_ADDR_OWVAR 38
6430: PUSH
6431: LD_INT 1
6433: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
6434: LD_ADDR_OWVAR 40
6438: PUSH
6439: LD_INT 31
6441: ST_TO_ADDR
// for i = 1 to 5 do
6442: NOP4
6446: PUSH
6447: DOUBLE
6448: LD_INT 1
6450: DEC
6451: ST_TO_ADDR
6452: LD_INT 5
6454: PUSH
6455: FOR_TO
6456: IFFALSE 6725
// begin xy := [ [ 156 , 15 ] , [ 12 , 7 ] ] [ i mod 2 + 1 ] ;
6458: NOP4
6462: PUSH
6463: LD_INT 156
6465: PUSH
6466: LD_INT 15
6468: PUSH
6469: EMPTY
6470: LIST
6471: LIST
6472: PUSH
6473: LD_INT 12
6475: PUSH
6476: LD_INT 7
6478: PUSH
6479: EMPTY
6480: LIST
6481: LIST
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: PUSH
6487: NOP4
6491: PUSH
6492: LD_INT 2
6494: MOD
6495: PUSH
6496: LD_INT 1
6498: PLUS
6499: ARRAY
6500: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , skill ) ;
6501: LD_INT 0
6503: PPUSH
6504: LD_INT 3
6506: PPUSH
6507: NOP4
6511: PPUSH
6512: NOP4
// un := CreateVehicle ;
6516: NOP4
6520: PUSH
6521: NOP4
6525: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6526: NOP4
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: LD_INT 5
6536: PPUSH
6537: NOP4
6541: PPUSH
6542: NOP4
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
6546: NOP4
6550: PPUSH
6551: NOP4
6555: PUSH
6556: LD_INT 1
6558: ARRAY
6559: PPUSH
6560: NOP4
6564: PUSH
6565: LD_INT 2
6567: ARRAY
6568: PPUSH
6569: LD_INT 6
6571: PPUSH
6572: LD_INT 0
6574: PPUSH
6575: NOP4
// un2 := CreateHuman ;
6579: NOP4
6583: PUSH
6584: NOP4
6588: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
6589: NOP4
6593: PPUSH
6594: NOP4
6598: PPUSH
6599: NOP4
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un ) ;
6603: NOP4
6607: PUSH
6608: NOP4
6612: PPUSH
6613: NOP4
6617: PUSH
6618: LD_INT 2
6620: MOD
6621: PUSH
6622: LD_INT 1
6624: PLUS
6625: PUSH
6626: NOP4
6630: PUSH
6631: NOP4
6635: PUSH
6636: LD_INT 2
6638: MOD
6639: PUSH
6640: LD_INT 1
6642: PLUS
6643: ARRAY
6644: PUSH
6645: LD_INT 1
6647: PLUS
6648: PUSH
6649: EMPTY
6650: LIST
6651: LIST
6652: PPUSH
6653: NOP4
6657: PPUSH
6658: NOP4
6662: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i mod 2 + 1 , mc_bases [ i mod 2 + 1 ] + 1 ] , un2 ) ;
6663: NOP4
6667: PUSH
6668: NOP4
6672: PPUSH
6673: NOP4
6677: PUSH
6678: LD_INT 2
6680: MOD
6681: PUSH
6682: LD_INT 1
6684: PLUS
6685: PUSH
6686: NOP4
6690: PUSH
6691: NOP4
6695: PUSH
6696: LD_INT 2
6698: MOD
6699: PUSH
6700: LD_INT 1
6702: PLUS
6703: ARRAY
6704: PUSH
6705: LD_INT 1
6707: PLUS
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: PPUSH
6713: NOP4
6717: PPUSH
6718: NOP4
6722: ST_TO_ADDR
// end ;
6723: GO 6455
6725: POP
6726: POP
// for i in FilterAllUnits ( [ [ f_side , side_bot ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
6727: NOP4
6731: PUSH
6732: LD_INT 22
6734: PUSH
6735: NOP4
6739: PUSH
6740: EMPTY
6741: LIST
6742: LIST
6743: PUSH
6744: LD_INT 30
6746: PUSH
6747: LD_INT 31
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: PUSH
6754: LD_INT 58
6756: PUSH
6757: EMPTY
6758: LIST
6759: PUSH
6760: EMPTY
6761: LIST
6762: LIST
6763: LIST
6764: PPUSH
6765: NOP4
6769: PUSH
6770: FOR_IN
6771: IFFALSE 6896
// begin if GetBase ( i ) then
6773: NOP4
6777: PPUSH
6778: NOP4
6782: IFFALSE 6786
// continue ;
6784: GO 6770
// d := GetDir ( i ) ;
6786: NOP4
6790: PUSH
6791: NOP4
6795: PPUSH
6796: NOP4
6800: ST_TO_ADDR
// if d < 3 then
6801: NOP4
6805: PUSH
6806: LD_INT 3
6808: LESS
6809: IFFALSE 6827
// d := d + 3 else
6811: NOP4
6815: PUSH
6816: NOP4
6820: PUSH
6821: LD_INT 3
6823: PLUS
6824: ST_TO_ADDR
6825: GO 6841
// d := d - 3 ;
6827: NOP4
6831: PUSH
6832: NOP4
6836: PUSH
6837: LD_INT 3
6839: MINUS
6840: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
6841: LD_INT 0
6843: PPUSH
6844: LD_INT 8
6846: PPUSH
6847: NOP4
6851: PPUSH
6852: NOP4
// un := CreateHuman ;
6856: NOP4
6860: PUSH
6861: NOP4
6865: ST_TO_ADDR
// SetDir ( un , d ) ;
6866: NOP4
6870: PPUSH
6871: NOP4
6875: PPUSH
6876: NOP4
// PlaceHumanInUnit ( un , i ) ;
6880: NOP4
6884: PPUSH
6885: NOP4
6889: PPUSH
6890: NOP4
// end ;
6894: GO 6770
6896: POP
6897: POP
// ar_force_tmp := [ ] ;
6898: NOP4
6902: PUSH
6903: EMPTY
6904: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
6905: LD_INT 1
6907: PPUSH
6908: LD_INT 1
6910: PPUSH
6911: NOP4
6915: PPUSH
6916: NOP4
// hc_gallery := SecondCharsGal ;
6920: LD_ADDR_OWVAR 33
6924: PUSH
6925: LD_STRING SecondCharsGal
6927: ST_TO_ADDR
// hc_face_number := 4 ;
6928: LD_ADDR_OWVAR 34
6932: PUSH
6933: LD_INT 4
6935: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
6936: NOP4
6940: PUSH
6941: NOP4
6945: PPUSH
6946: LD_INT 1
6948: PPUSH
6949: NOP4
6953: PPUSH
6954: NOP4
6958: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
6959: LD_INT 2
6961: PPUSH
6962: LD_INT 4
6964: PPUSH
6965: NOP4
6969: PPUSH
6970: NOP4
// hc_gallery := SecondCharsGal ;
6974: LD_ADDR_OWVAR 33
6978: PUSH
6979: LD_STRING SecondCharsGal
6981: ST_TO_ADDR
// hc_face_number := 15 ;
6982: LD_ADDR_OWVAR 34
6986: PUSH
6987: LD_INT 15
6989: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
6990: NOP4
6994: PUSH
6995: NOP4
6999: PPUSH
7000: LD_INT 2
7002: PPUSH
7003: NOP4
7007: PPUSH
7008: NOP4
7012: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , skill ) ;
7013: LD_INT 2
7015: PPUSH
7016: LD_INT 4
7018: PPUSH
7019: NOP4
7023: PPUSH
7024: NOP4
// hc_gallery :=  ;
7028: LD_ADDR_OWVAR 33
7032: PUSH
7033: LD_STRING 
7035: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
7036: NOP4
7040: PUSH
7041: NOP4
7045: PPUSH
7046: LD_INT 3
7048: PPUSH
7049: NOP4
7053: PPUSH
7054: NOP4
7058: ST_TO_ADDR
// hc_sex := sex_male ;
7059: LD_ADDR_OWVAR 27
7063: PUSH
7064: LD_INT 1
7066: ST_TO_ADDR
// hc_class = 11 ;
7067: LD_ADDR_OWVAR 28
7071: PUSH
7072: LD_INT 11
7074: ST_TO_ADDR
// hc_gallery = sandar ;
7075: LD_ADDR_OWVAR 33
7079: PUSH
7080: LD_STRING sandar
7082: ST_TO_ADDR
// hc_face_number = 33 ;
7083: LD_ADDR_OWVAR 34
7087: PUSH
7088: LD_INT 33
7090: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
7091: LD_ADDR_OWVAR 26
7095: PUSH
7096: LD_STRING Thabit Muhair Saliba
7098: ST_TO_ADDR
// hc_skills = [ 5 , 5 , 3 , 3 ] ;
7099: LD_ADDR_OWVAR 31
7103: PUSH
7104: LD_INT 5
7106: PUSH
7107: LD_INT 5
7109: PUSH
7110: LD_INT 3
7112: PUSH
7113: LD_INT 3
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: ST_TO_ADDR
// Saliba = CreateHuman ;
7122: NOP4
7126: PUSH
7127: NOP4
7131: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
7132: NOP4
7136: PPUSH
7137: LD_INT 7
7139: PPUSH
7140: NOP4
// hc_name := Dietrich Gensher ;
7144: LD_ADDR_OWVAR 26
7148: PUSH
7149: LD_STRING Dietrich Gensher
7151: ST_TO_ADDR
// hc_class := 1 ;
7152: LD_ADDR_OWVAR 28
7156: PUSH
7157: LD_INT 1
7159: ST_TO_ADDR
// hc_gallery := sandar ;
7160: LD_ADDR_OWVAR 33
7164: PUSH
7165: LD_STRING sandar
7167: ST_TO_ADDR
// hc_face_number := 2 ;
7168: LD_ADDR_OWVAR 34
7172: PUSH
7173: LD_INT 2
7175: ST_TO_ADDR
// hc_skills := [ 10 , 6 , 5 , 4 ] ;
7176: LD_ADDR_OWVAR 31
7180: PUSH
7181: LD_INT 10
7183: PUSH
7184: LD_INT 6
7186: PUSH
7187: LD_INT 5
7189: PUSH
7190: LD_INT 4
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: LIST
7197: LIST
7198: ST_TO_ADDR
// Gensher := CreateHuman ;
7199: NOP4
7203: PUSH
7204: NOP4
7208: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
7209: NOP4
7213: PPUSH
7214: LD_INT 94
7216: PPUSH
7217: NOP4
// InitHc ;
7221: NOP4
// ar_defenders_tmp := [ [ ] , [ ] , [ ] , [ ] ] ;
7225: NOP4
7229: PUSH
7230: EMPTY
7231: PUSH
7232: EMPTY
7233: PUSH
7234: EMPTY
7235: PUSH
7236: EMPTY
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
7244: NOP4
7248: PUSH
7249: DOUBLE
7250: LD_INT 1
7252: DEC
7253: ST_TO_ADDR
7254: LD_INT 3
7256: PUSH
7257: LD_INT 3
7259: PUSH
7260: LD_INT 4
7262: PUSH
7263: EMPTY
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: NOP4
7272: ARRAY
7273: PUSH
7274: FOR_TO
7275: IFFALSE 7493
// for i = 1 to 4 do
7277: NOP4
7281: PUSH
7282: DOUBLE
7283: LD_INT 1
7285: DEC
7286: ST_TO_ADDR
7287: LD_INT 4
7289: PUSH
7290: FOR_TO
7291: IFFALSE 7489
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
7293: LD_INT 14
7295: PPUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 2
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PUSH
7306: LD_INT 1
7308: PPUSH
7309: LD_INT 2
7311: PPUSH
7312: NOP4
7316: ARRAY
7317: PPUSH
7318: LD_INT 1
7320: PUSH
7321: LD_INT 5
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: PUSH
7328: LD_INT 1
7330: PPUSH
7331: LD_INT 2
7333: PPUSH
7334: NOP4
7338: ARRAY
7339: PPUSH
7340: LD_INT 25
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: LD_INT 26
7348: PUSH
7349: LD_INT 28
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 4
7363: PPUSH
7364: NOP4
7368: ARRAY
7369: PPUSH
7370: LD_INT 100
7372: PPUSH
7373: NOP4
// un := CreateVehicle ;
7377: NOP4
7381: PUSH
7382: NOP4
7386: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
7387: NOP4
7391: PUSH
7392: NOP4
7396: PPUSH
7397: NOP4
7401: PUSH
7402: NOP4
7406: PUSH
7407: NOP4
7411: ARRAY
7412: PUSH
7413: LD_INT 1
7415: PLUS
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: PPUSH
7421: NOP4
7425: PPUSH
7426: NOP4
7430: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7431: NOP4
7435: PPUSH
7436: LD_INT 0
7438: PPUSH
7439: LD_INT 5
7441: PPUSH
7442: NOP4
7446: PPUSH
7447: NOP4
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east , parking_south ] [ i ] , false ) ;
7451: NOP4
7455: PPUSH
7456: LD_INT 20
7458: PUSH
7459: LD_INT 21
7461: PUSH
7462: LD_INT 22
7464: PUSH
7465: LD_INT 24
7467: PUSH
7468: EMPTY
7469: LIST
7470: LIST
7471: LIST
7472: LIST
7473: PUSH
7474: NOP4
7478: ARRAY
7479: PPUSH
7480: LD_INT 0
7482: PPUSH
7483: NOP4
// end ;
7487: GO 7290
7489: POP
7490: POP
7491: GO 7274
7493: POP
7494: POP
// InitHc ;
7495: NOP4
// end ;
7499: LD_VAR 0 2
7503: RET
// every 13 13$00 + 10 10$00 trigger IsOk ( ar_dep_n ) and GetSide ( ar_dep_n ) = side_bot do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
7504: LD_INT 94
7506: PPUSH
7507: NOP4
7511: PUSH
7512: LD_INT 94
7514: PPUSH
7515: NOP4
7519: PUSH
7520: NOP4
7524: EQUAL
7525: AND
7526: IFFALSE 8235
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
// begin enable ;
7543: ENABLE
// base := 1 ;
7544: NOP4
7548: PUSH
7549: LD_INT 1
7551: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
7552: NOP4
7556: PUSH
7557: LD_INT 0
7559: PUSH
7560: LD_INT 0
7562: PUSH
7563: LD_INT 0
7565: PUSH
7566: LD_INT 0
7568: PUSH
7569: LD_INT 1
7571: PUSH
7572: LD_INT 0
7574: PUSH
7575: LD_INT 0
7577: PUSH
7578: LD_INT 0
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 0
7586: PUSH
7587: EMPTY
7588: LIST
7589: LIST
7590: LIST
7591: LIST
7592: LIST
7593: LIST
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: ST_TO_ADDR
// coords := [ [ 28 , 14 ] , [ 107 , 119 ] , [ 127 , 97 ] , [ 185 , 127 ] ] ;
7599: NOP4
7603: PUSH
7604: LD_INT 28
7606: PUSH
7607: LD_INT 14
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 107
7616: PUSH
7617: LD_INT 119
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 127
7626: PUSH
7627: LD_INT 97
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 185
7636: PUSH
7637: LD_INT 127
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: LIST
7648: LIST
7649: ST_TO_ADDR
// target := 0 ;
7650: NOP4
7654: PUSH
7655: LD_INT 0
7657: ST_TO_ADDR
// x := 0 ;
7658: NOP4
7662: PUSH
7663: LD_INT 0
7665: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7666: NOP4
7670: PUSH
7671: LD_INT 14
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 2
7679: PUSH
7680: LD_INT 28
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 14
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: LD_INT 14
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: LD_INT 2
7715: PUSH
7716: LD_INT 28
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 14
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 2
7733: PUSH
7734: LD_INT 29
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: LIST
7747: LIST
7748: ST_TO_ADDR
// if Difficulty > 1 then
7749: NOP4
7753: PUSH
7754: LD_INT 1
7756: GREATER
7757: IFFALSE 7854
// for i = 1 to Difficulty + 2 do
7759: NOP4
7763: PUSH
7764: DOUBLE
7765: LD_INT 1
7767: DEC
7768: ST_TO_ADDR
7769: NOP4
7773: PUSH
7774: LD_INT 2
7776: PLUS
7777: PUSH
7778: FOR_TO
7779: IFFALSE 7852
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun , ar_selfpropelled_bomb ] [ rand ( 1 , 4 ) ] ] ) ;
7781: NOP4
7785: PUSH
7786: NOP4
7790: PPUSH
7791: NOP4
7795: PUSH
7796: LD_INT 1
7798: PLUS
7799: PPUSH
7800: LD_INT 14
7802: PUSH
7803: LD_INT 1
7805: PUSH
7806: LD_INT 2
7808: PUSH
7809: LD_INT 28
7811: PUSH
7812: LD_INT 27
7814: PUSH
7815: LD_INT 27
7817: PUSH
7818: LD_INT 29
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_INT 1
7829: PPUSH
7830: LD_INT 4
7832: PPUSH
7833: NOP4
7837: ARRAY
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: LIST
7843: LIST
7844: PPUSH
7845: NOP4
7849: ST_TO_ADDR
7850: GO 7778
7852: POP
7853: POP
// MC_SetProduceList ( base , tmp ) ;
7854: NOP4
7858: PPUSH
7859: NOP4
7863: PPUSH
7864: NOP4
// repeat wait ( 0 0$1 ) ;
7868: LD_INT 35
7870: PPUSH
7871: NOP4
// until MC_GetProduceList ( base ) = 0 ;
7875: NOP4
7879: PPUSH
7880: NOP4
7884: PUSH
7885: LD_INT 0
7887: EQUAL
7888: IFFALSE 7868
// wait ( 0 0$10 ) ;
7890: LD_INT 350
7892: PPUSH
7893: NOP4
// for i = 1 to coords do
7897: NOP4
7901: PUSH
7902: DOUBLE
7903: LD_INT 1
7905: DEC
7906: ST_TO_ADDR
7907: NOP4
7911: PUSH
7912: FOR_TO
7913: IFFALSE 8001
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
7915: NOP4
7919: PUSH
7920: NOP4
7924: PPUSH
7925: NOP4
7929: PUSH
7930: NOP4
7934: ARRAY
7935: PUSH
7936: LD_INT 1
7938: ARRAY
7939: PPUSH
7940: NOP4
7944: PUSH
7945: NOP4
7949: ARRAY
7950: PUSH
7951: LD_INT 2
7953: ARRAY
7954: PPUSH
7955: LD_INT 35
7957: PPUSH
7958: NOP4
7962: PUSH
7963: LD_INT 4
7965: ARRAY
7966: ST_TO_ADDR
// if t > x then
7967: NOP4
7971: PUSH
7972: NOP4
7976: GREATER
7977: IFFALSE 7999
// begin x := t ;
7979: NOP4
7983: PUSH
7984: NOP4
7988: ST_TO_ADDR
// target := i ;
7989: NOP4
7993: PUSH
7994: NOP4
7998: ST_TO_ADDR
// end ; end ;
7999: GO 7912
8001: POP
8002: POP
// case target of 1 :
8003: NOP4
8007: PUSH
8008: LD_INT 1
8010: DOUBLE
8011: EQUAL
8012: IFTRUE 8016
8014: GO 8048
8016: POP
// _target := [ [ 60 , 8 ] , [ 28 , 15 ] ] ; 2 :
8017: NOP4
8021: PUSH
8022: LD_INT 60
8024: PUSH
8025: LD_INT 8
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 28
8034: PUSH
8035: LD_INT 15
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: ST_TO_ADDR
8046: GO 8169
8048: LD_INT 2
8050: DOUBLE
8051: EQUAL
8052: IFTRUE 8056
8054: GO 8088
8056: POP
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ; 3 :
8057: NOP4
8061: PUSH
8062: LD_INT 52
8064: PUSH
8065: LD_INT 11
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PUSH
8072: LD_INT 76
8074: PUSH
8075: LD_INT 90
8077: PUSH
8078: EMPTY
8079: LIST
8080: LIST
8081: PUSH
8082: EMPTY
8083: LIST
8084: LIST
8085: ST_TO_ADDR
8086: GO 8169
8088: LD_INT 3
8090: DOUBLE
8091: EQUAL
8092: IFTRUE 8096
8094: GO 8128
8096: POP
// _target := [ [ 129 , 66 ] , [ 130 , 97 ] ] ; 4 :
8097: NOP4
8101: PUSH
8102: LD_INT 129
8104: PUSH
8105: LD_INT 66
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: PUSH
8112: LD_INT 130
8114: PUSH
8115: LD_INT 97
8117: PUSH
8118: EMPTY
8119: LIST
8120: LIST
8121: PUSH
8122: EMPTY
8123: LIST
8124: LIST
8125: ST_TO_ADDR
8126: GO 8169
8128: LD_INT 4
8130: DOUBLE
8131: EQUAL
8132: IFTRUE 8136
8134: GO 8168
8136: POP
// _target := [ [ 156 , 87 ] , [ 183 , 127 ] ] ; end ;
8137: NOP4
8141: PUSH
8142: LD_INT 156
8144: PUSH
8145: LD_INT 87
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: PUSH
8152: LD_INT 183
8154: PUSH
8155: LD_INT 127
8157: PUSH
8158: EMPTY
8159: LIST
8160: LIST
8161: PUSH
8162: EMPTY
8163: LIST
8164: LIST
8165: ST_TO_ADDR
8166: GO 8169
8168: POP
// if not _target then
8169: NOP4
8173: NOT
8174: IFFALSE 8205
// _target := [ [ 52 , 11 ] , [ 76 , 90 ] ] ;
8176: NOP4
8180: PUSH
8181: LD_INT 52
8183: PUSH
8184: LD_INT 11
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 76
8193: PUSH
8194: LD_INT 90
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: EMPTY
8202: LIST
8203: LIST
8204: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8205: NOP4
8209: PPUSH
8210: NOP4
8214: PUSH
8215: NOP4
8219: ARRAY
8220: PPUSH
8221: NOP4
8225: PPUSH
8226: NOP4
8230: PPUSH
8231: NOP4
// end ;
8235: PPOPN 10
8237: END
// every 13 13$00 + 10 10$00 trigger ( IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) = side_bot ) and ( multi_players_amount = 3 or IsDead ( ar_dep_n ) or GetSide ( ar_dep_n ) <> side_bot ) do var i , t , x , base , tmp , coords , flags , danger , target , _target ;
8238: LD_INT 45
8240: PPUSH
8241: NOP4
8245: PUSH
8246: LD_INT 45
8248: PPUSH
8249: NOP4
8253: PUSH
8254: NOP4
8258: EQUAL
8259: AND
8260: PUSH
8261: NOP4
8265: PUSH
8266: LD_INT 3
8268: EQUAL
8269: PUSH
8270: LD_INT 94
8272: PPUSH
8273: NOP4
8277: OR
8278: PUSH
8279: LD_INT 94
8281: PPUSH
8282: NOP4
8286: PUSH
8287: NOP4
8291: NONEQUAL
8292: OR
8293: AND
8294: IFFALSE 8880
8296: GO 8298
8298: DISABLE
8299: LD_INT 0
8301: PPUSH
8302: PPUSH
8303: PPUSH
8304: PPUSH
8305: PPUSH
8306: PPUSH
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
// begin enable ;
8311: ENABLE
// base := 2 ;
8312: NOP4
8316: PUSH
8317: LD_INT 2
8319: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
8320: NOP4
8324: PUSH
8325: LD_INT 0
8327: PUSH
8328: LD_INT 0
8330: PUSH
8331: LD_INT 0
8333: PUSH
8334: LD_INT 0
8336: PUSH
8337: LD_INT 1
8339: PUSH
8340: LD_INT 0
8342: PUSH
8343: LD_INT 0
8345: PUSH
8346: LD_INT 0
8348: PUSH
8349: LD_INT 1
8351: PUSH
8352: LD_INT 0
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: LIST
8360: LIST
8361: LIST
8362: LIST
8363: LIST
8364: LIST
8365: LIST
8366: ST_TO_ADDR
// coords := [ [ 101 , 110 ] , [ 100 , 21 ] ] ;
8367: NOP4
8371: PUSH
8372: LD_INT 101
8374: PUSH
8375: LD_INT 110
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 100
8384: PUSH
8385: LD_INT 21
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: ST_TO_ADDR
// target := 0 ;
8396: NOP4
8400: PUSH
8401: LD_INT 0
8403: ST_TO_ADDR
// x := 0 ;
8404: NOP4
8408: PUSH
8409: LD_INT 0
8411: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , ] ;
8412: NOP4
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 25
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: LIST
8475: ST_TO_ADDR
// if Difficulty > 1 then
8476: NOP4
8480: PUSH
8481: LD_INT 1
8483: GREATER
8484: IFFALSE 8579
// for i = 1 to Difficulty + 1 do
8486: NOP4
8490: PUSH
8491: DOUBLE
8492: LD_INT 1
8494: DEC
8495: ST_TO_ADDR
8496: NOP4
8500: PUSH
8501: LD_INT 1
8503: PLUS
8504: PUSH
8505: FOR_TO
8506: IFFALSE 8577
// tmp := Insert ( tmp , tmp + 1 , [ ar_half_tracked , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gun , ar_gun ] [ i mod 2 + 1 ] ] ) ;
8508: NOP4
8512: PUSH
8513: NOP4
8517: PPUSH
8518: NOP4
8522: PUSH
8523: LD_INT 1
8525: PLUS
8526: PPUSH
8527: LD_INT 14
8529: PUSH
8530: LD_INT 1
8532: PUSH
8533: LD_INT 2
8535: PUSH
8536: LD_INT 28
8538: PUSH
8539: LD_INT 27
8541: PUSH
8542: LD_INT 27
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: LIST
8549: PUSH
8550: NOP4
8554: PUSH
8555: LD_INT 2
8557: MOD
8558: PUSH
8559: LD_INT 1
8561: PLUS
8562: ARRAY
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: LIST
8568: LIST
8569: PPUSH
8570: NOP4
8574: ST_TO_ADDR
8575: GO 8505
8577: POP
8578: POP
// MC_SetProduceList ( base , tmp ) ;
8579: NOP4
8583: PPUSH
8584: NOP4
8588: PPUSH
8589: NOP4
// repeat wait ( 0 0$1 ) ;
8593: LD_INT 35
8595: PPUSH
8596: NOP4
// until MC_GetProduceList ( base ) = 0 ;
8600: NOP4
8604: PPUSH
8605: NOP4
8609: PUSH
8610: LD_INT 0
8612: EQUAL
8613: IFFALSE 8593
// wait ( 0 0$10 ) ;
8615: LD_INT 350
8617: PPUSH
8618: NOP4
// for i = 1 to coords do
8622: NOP4
8626: PUSH
8627: DOUBLE
8628: LD_INT 1
8630: DEC
8631: ST_TO_ADDR
8632: NOP4
8636: PUSH
8637: FOR_TO
8638: IFFALSE 8726
// begin t := DangerAtRangeXY ( side_bot , coords [ i ] [ 1 ] , coords [ i ] [ 2 ] , 35 ) [ 4 ] ;
8640: NOP4
8644: PUSH
8645: NOP4
8649: PPUSH
8650: NOP4
8654: PUSH
8655: NOP4
8659: ARRAY
8660: PUSH
8661: LD_INT 1
8663: ARRAY
8664: PPUSH
8665: NOP4
8669: PUSH
8670: NOP4
8674: ARRAY
8675: PUSH
8676: LD_INT 2
8678: ARRAY
8679: PPUSH
8680: LD_INT 35
8682: PPUSH
8683: NOP4
8687: PUSH
8688: LD_INT 4
8690: ARRAY
8691: ST_TO_ADDR
// if t > x then
8692: NOP4
8696: PUSH
8697: NOP4
8701: GREATER
8702: IFFALSE 8724
// begin x := t ;
8704: NOP4
8708: PUSH
8709: NOP4
8713: ST_TO_ADDR
// target := i ;
8714: NOP4
8718: PUSH
8719: NOP4
8723: ST_TO_ADDR
// end ; end ;
8724: GO 8637
8726: POP
8727: POP
// case target of 1 :
8728: NOP4
8732: PUSH
8733: LD_INT 1
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8773
8741: POP
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ; 2 :
8742: NOP4
8746: PUSH
8747: LD_INT 49
8749: PUSH
8750: LD_INT 35
8752: PUSH
8753: EMPTY
8754: LIST
8755: LIST
8756: PUSH
8757: LD_INT 76
8759: PUSH
8760: LD_INT 90
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: PUSH
8767: EMPTY
8768: LIST
8769: LIST
8770: ST_TO_ADDR
8771: GO 8814
8773: LD_INT 2
8775: DOUBLE
8776: EQUAL
8777: IFTRUE 8781
8779: GO 8813
8781: POP
// _target := [ [ 79 , 13 ] , [ 100 , 22 ] ] ; end ;
8782: NOP4
8786: PUSH
8787: LD_INT 79
8789: PUSH
8790: LD_INT 13
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: LD_INT 100
8799: PUSH
8800: LD_INT 22
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: ST_TO_ADDR
8811: GO 8814
8813: POP
// if not _target then
8814: NOP4
8818: NOT
8819: IFFALSE 8850
// _target := [ [ 49 , 35 ] , [ 76 , 90 ] ] ;
8821: NOP4
8825: PUSH
8826: LD_INT 49
8828: PUSH
8829: LD_INT 35
8831: PUSH
8832: EMPTY
8833: LIST
8834: LIST
8835: PUSH
8836: LD_INT 76
8838: PUSH
8839: LD_INT 90
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: ST_TO_ADDR
// MC_PrepareAttack ( base , mc_vehicles [ base ] , _target , flags ) ;
8850: NOP4
8854: PPUSH
8855: NOP4
8859: PUSH
8860: NOP4
8864: ARRAY
8865: PPUSH
8866: NOP4
8870: PPUSH
8871: NOP4
8875: PPUSH
8876: NOP4
// end ; end_of_file
8880: PPOPN 10
8882: END
// on ArtifactLoaded ( cargo , artifact ) do var i , j ;
8883: LD_INT 0
8885: PPUSH
8886: PPUSH
// begin if artifact_get then
8887: NOP4
8891: IFFALSE 8895
// exit ;
8893: GO 8917
// MultiplayerEvent_ArtifactCaptured ( GetSide ( cargo ) ) ;
8895: NOP4
8899: PPUSH
8900: NOP4
8904: PPUSH
8905: NOP4
// artifact_get := true ;
8909: NOP4
8913: PUSH
8914: LD_INT 1
8916: ST_TO_ADDR
// end ;
8917: PPOPN 4
8919: END
// on UnitDestroyed ( un ) do var i , side ;
8920: LD_INT 0
8922: PPUSH
8923: PPUSH
// begin side := GetSide ( un ) ;
8924: NOP4
8928: PUSH
8929: NOP4
8933: PPUSH
8934: NOP4
8938: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
8939: NOP4
8943: PUSH
8944: NOP4
8948: IN
8949: NOT
8950: PUSH
8951: NOP4
8955: PUSH
8956: NOP4
8960: ARRAY
8961: AND
8962: IFFALSE 8988
// if GetType ( un ) = unit_human then
8964: NOP4
8968: PPUSH
8969: NOP4
8973: PUSH
8974: LD_INT 1
8976: EQUAL
8977: IFFALSE 8988
// MultiplayerEvent_HumanLost ( side ) ;
8979: NOP4
8983: PPUSH
8984: NOP4
// if side in mc_sides then
8988: NOP4
8992: PUSH
8993: NOP4
8997: IN
8998: IFFALSE 9043
// if un <> Gensher then
9000: NOP4
9004: PUSH
9005: NOP4
9009: NONEQUAL
9010: IFFALSE 9026
// MultiplayerEvent_UnitKilled ( un , false ) else
9012: NOP4
9016: PPUSH
9017: LD_INT 0
9019: PPUSH
9020: NOP4
9024: GO 9043
// MultiplayerEvent_UnitKilled ( un , Multiplayer_GetCondition ( 5 ) ) ;
9026: NOP4
9030: PPUSH
9031: LD_INT 5
9033: PPUSH
9034: NOP4
9038: PPUSH
9039: NOP4
// if multi_commanders and multi_custom_commanders then
9043: NOP4
9047: PUSH
9048: NOP4
9052: AND
9053: IFFALSE 9115
// if un in multi_commanders then
9055: NOP4
9059: PUSH
9060: NOP4
9064: IN
9065: IFFALSE 9115
// begin multi_loosers := Replace ( multi_loosers , side , 1 ) ;
9067: NOP4
9071: PUSH
9072: NOP4
9076: PPUSH
9077: NOP4
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: NOP4
9089: ST_TO_ADDR
// multi_commanders := multi_commanders diff un ;
9090: NOP4
9094: PUSH
9095: NOP4
9099: PUSH
9100: NOP4
9104: DIFF
9105: ST_TO_ADDR
// Multiplayer_Reside ( side ) ;
9106: NOP4
9110: PPUSH
9111: NOP4
// end ; MCE_UnitDestroyed ( un ) ;
9115: NOP4
9119: PPUSH
9120: NOP4
// end ;
9124: PPOPN 3
9126: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9127: NOP4
9131: PPUSH
9132: NOP4
9136: PPUSH
9137: NOP4
// end ;
9141: PPOPN 2
9143: END
// on BuildingComplete ( building ) do var i , j ;
9144: LD_INT 0
9146: PPUSH
9147: PPUSH
// begin if GetSide ( building ) in mc_sides then
9148: NOP4
9152: PPUSH
9153: NOP4
9157: PUSH
9158: NOP4
9162: IN
9163: IFFALSE 9189
// MultiplayerEvent_BuildingCompleted ( GetSide ( building ) , GetBType ( building ) ) ;
9165: NOP4
9169: PPUSH
9170: NOP4
9174: PPUSH
9175: NOP4
9179: PPUSH
9180: NOP4
9184: PPUSH
9185: NOP4
// if GetBType ( building ) = b_depot and not GetSide ( building ) in mc_sides and base_names then
9189: NOP4
9193: PPUSH
9194: NOP4
9198: PUSH
9199: LD_INT 0
9201: EQUAL
9202: PUSH
9203: NOP4
9207: PPUSH
9208: NOP4
9212: PUSH
9213: NOP4
9217: IN
9218: NOT
9219: AND
9220: PUSH
9221: NOP4
9225: AND
9226: IFFALSE 9264
// begin SetBName ( building , base_names [ 1 ] ) ;
9228: NOP4
9232: PPUSH
9233: NOP4
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: NOP4
// base_names := Delete ( base_names , 1 ) ;
9246: NOP4
9250: PUSH
9251: NOP4
9255: PPUSH
9256: LD_INT 1
9258: PPUSH
9259: NOP4
9263: ST_TO_ADDR
// end ; MCE_BuildingComplete ( building ) ;
9264: NOP4
9268: PPUSH
9269: NOP4
// end ;
9273: PPOPN 3
9275: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9276: NOP4
9280: PPUSH
9281: NOP4
9285: PPUSH
9286: NOP4
// end ;
9290: PPOPN 2
9292: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9293: NOP4
9297: PPUSH
9298: NOP4
9302: PPUSH
9303: NOP4
9307: PPUSH
9308: NOP4
9312: PPUSH
9313: NOP4
9317: PPUSH
9318: NOP4
// end ;
9322: PPOPN 5
9324: END
// on VehicleConstructed ( vehicle , factory ) do var i , side , tmp ;
9325: LD_INT 0
9327: PPUSH
9328: PPUSH
9329: PPUSH
// begin side := GetSide ( vehicle ) ;
9330: NOP4
9334: PUSH
9335: NOP4
9339: PPUSH
9340: NOP4
9344: ST_TO_ADDR
// if not side in mc_sides and multi_sides [ side ] then
9345: NOP4
9349: PUSH
9350: NOP4
9354: IN
9355: NOT
9356: PUSH
9357: NOP4
9361: PUSH
9362: NOP4
9366: ARRAY
9367: AND
9368: IFFALSE 9379
// MultiplayerEvent_Produced ( side ) ;
9370: NOP4
9374: PPUSH
9375: NOP4
// MCE_VehicleConstructed ( vehicle , factory ) ;
9379: NOP4
9383: PPUSH
9384: NOP4
9388: PPUSH
9389: NOP4
// end ;
9393: PPOPN 5
9395: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9396: NOP4
9400: PPUSH
9401: NOP4
9405: PPUSH
9406: NOP4
9410: PPUSH
9411: NOP4
9415: PPUSH
9416: NOP4
// end ;
9420: PPOPN 4
9422: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9423: NOP4
9427: PPUSH
9428: NOP4
9432: PPUSH
9433: NOP4
9437: PPUSH
9438: NOP4
// end ;
9442: PPOPN 3
9444: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9445: NOP4
9449: PPUSH
9450: NOP4
9454: PPUSH
9455: NOP4
// end ;
9459: PPOPN 2
9461: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9462: NOP4
9466: PPUSH
9467: NOP4
9471: PPUSH
9472: NOP4
// end ;
9476: PPOPN 2
9478: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9479: NOP4
9483: PPUSH
9484: NOP4
9488: PPUSH
9489: NOP4
9493: PPUSH
9494: NOP4
9498: PPUSH
9499: NOP4
// end ; end_of_file
9503: PPOPN 4
9505: END
// every 0 0$20 trigger game do
9506: NOP4
9510: IFFALSE 9555
9512: GO 9514
9514: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , multi_crates_spawn [ 2 ] , multi_crates_spawn [ 1 ] ) ;
9515: LD_INT 7
9517: PUSH
9518: LD_INT 6
9520: PUSH
9521: LD_INT 4
9523: PUSH
9524: LD_INT 6
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: LIST
9531: LIST
9532: PPUSH
9533: NOP4
9537: PUSH
9538: LD_INT 2
9540: ARRAY
9541: PPUSH
9542: NOP4
9546: PUSH
9547: LD_INT 1
9549: ARRAY
9550: PPUSH
9551: NOP4
9555: END
// export function SpawnCrates ( areas , time , amount ) ; var i , x , players_areas ; begin
9556: LD_INT 0
9558: PPUSH
9559: PPUSH
9560: PPUSH
9561: PPUSH
// if not areas then
9562: NOP4
9566: NOT
9567: IFFALSE 9571
// exit ;
9569: GO 9846
// players_areas := [ crates_player_west , crates_player_south , crates_player_east ] ;
9571: NOP4
9575: PUSH
9576: LD_INT 31
9578: PUSH
9579: LD_INT 32
9581: PUSH
9582: LD_INT 30
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: LIST
9589: ST_TO_ADDR
// repeat wait ( time ) ;
9590: NOP4
9594: PPUSH
9595: NOP4
// x := 5 ;
9599: NOP4
9603: PUSH
9604: LD_INT 5
9606: ST_TO_ADDR
// if tick < [ 20 20$00 , 18 18$00 , 14 14$00 ] [ Difficulty ] then
9607: NOP4
9611: PUSH
9612: LD_INT 42000
9614: PUSH
9615: LD_INT 37800
9617: PUSH
9618: LD_INT 29400
9620: PUSH
9621: EMPTY
9622: LIST
9623: LIST
9624: LIST
9625: PUSH
9626: NOP4
9630: ARRAY
9631: LESS
9632: IFFALSE 9704
// begin for i = 1 to multi_sides do
9634: NOP4
9638: PUSH
9639: DOUBLE
9640: LD_INT 1
9642: DEC
9643: ST_TO_ADDR
9644: NOP4
9648: PUSH
9649: FOR_TO
9650: IFFALSE 9695
// if multi_sides [ i ] then
9652: NOP4
9656: PUSH
9657: NOP4
9661: ARRAY
9662: IFFALSE 9693
// CreateCratesArea ( x , players_areas [ multi_sides [ i ] ] , true ) ;
9664: NOP4
9668: PPUSH
9669: NOP4
9673: PUSH
9674: NOP4
9678: PUSH
9679: NOP4
9683: ARRAY
9684: ARRAY
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: NOP4
9693: GO 9649
9695: POP
9696: POP
// wait ( 0 0$6 ) ;
9697: LD_INT 210
9699: PPUSH
9700: NOP4
// end ; for i in areas do
9704: NOP4
9708: PUSH
9709: NOP4
9713: PUSH
9714: FOR_IN
9715: IFFALSE 9743
// begin wait ( 0 0$6 ) ;
9717: LD_INT 210
9719: PPUSH
9720: NOP4
// CreateCratesArea ( x , i , true ) ;
9724: NOP4
9728: PPUSH
9729: NOP4
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: NOP4
// end ;
9741: GO 9714
9743: POP
9744: POP
// time := time + 0 0$2 ;
9745: NOP4
9749: PUSH
9750: NOP4
9754: PUSH
9755: LD_INT 70
9757: PLUS
9758: ST_TO_ADDR
// amount := amount - x * 10 ;
9759: NOP4
9763: PUSH
9764: NOP4
9768: PUSH
9769: NOP4
9773: PUSH
9774: LD_INT 10
9776: MUL
9777: MINUS
9778: ST_TO_ADDR
// x := x - 1 ;
9779: NOP4
9783: PUSH
9784: NOP4
9788: PUSH
9789: LD_INT 1
9791: MINUS
9792: ST_TO_ADDR
// if x = 0 then
9793: NOP4
9797: PUSH
9798: LD_INT 0
9800: EQUAL
9801: IFFALSE 9811
// x := 5 ;
9803: NOP4
9807: PUSH
9808: LD_INT 5
9810: ST_TO_ADDR
// if time > 4 4$00 then
9811: NOP4
9815: PUSH
9816: LD_INT 8400
9818: GREATER
9819: IFFALSE 9829
// time := 0 0$40 ;
9821: NOP4
9825: PUSH
9826: LD_INT 1400
9828: ST_TO_ADDR
// until not game or amount <= 0 ;
9829: NOP4
9833: NOT
9834: PUSH
9835: NOP4
9839: PUSH
9840: LD_INT 0
9842: LESSEQUAL
9843: OR
9844: IFFALSE 9590
// end ; end_of_file
9846: LD_VAR 0 4
9850: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9851: LD_INT 0
9853: PPUSH
9854: PPUSH
// if exist_mode then
9855: NOP4
9859: IFFALSE 9884
// unit := CreateCharacter ( prefix & ident ) else
9861: NOP4
9865: PUSH
9866: NOP4
9870: PUSH
9871: NOP4
9875: STR
9876: PPUSH
9877: NOP4
9881: ST_TO_ADDR
9882: GO 9899
// unit := NewCharacter ( ident ) ;
9884: NOP4
9888: PUSH
9889: NOP4
9893: PPUSH
9894: NOP4
9898: ST_TO_ADDR
// result := unit ;
9899: NOP4
9903: PUSH
9904: NOP4
9908: ST_TO_ADDR
// end ;
9909: LD_VAR 0 4
9913: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9914: LD_INT 0
9916: PPUSH
9917: PPUSH
// if not side or not nation then
9918: NOP4
9922: NOT
9923: PUSH
9924: NOP4
9928: NOT
9929: OR
9930: IFFALSE 9934
// exit ;
9932: GO 10698
// case nation of nation_american :
9934: NOP4
9938: PUSH
9939: LD_INT 1
9941: DOUBLE
9942: EQUAL
9943: IFTRUE 9947
9945: GO 10161
9947: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9948: NOP4
9952: PUSH
9953: LD_INT 35
9955: PUSH
9956: LD_INT 45
9958: PUSH
9959: LD_INT 46
9961: PUSH
9962: LD_INT 47
9964: PUSH
9965: LD_INT 82
9967: PUSH
9968: LD_INT 83
9970: PUSH
9971: LD_INT 84
9973: PUSH
9974: LD_INT 85
9976: PUSH
9977: LD_INT 86
9979: PUSH
9980: LD_INT 1
9982: PUSH
9983: LD_INT 2
9985: PUSH
9986: LD_INT 6
9988: PUSH
9989: LD_INT 15
9991: PUSH
9992: LD_INT 16
9994: PUSH
9995: LD_INT 7
9997: PUSH
9998: LD_INT 12
10000: PUSH
10001: LD_INT 13
10003: PUSH
10004: LD_INT 10
10006: PUSH
10007: LD_INT 14
10009: PUSH
10010: LD_INT 20
10012: PUSH
10013: LD_INT 21
10015: PUSH
10016: LD_INT 22
10018: PUSH
10019: LD_INT 25
10021: PUSH
10022: LD_INT 32
10024: PUSH
10025: LD_INT 27
10027: PUSH
10028: LD_INT 36
10030: PUSH
10031: LD_INT 69
10033: PUSH
10034: LD_INT 39
10036: PUSH
10037: LD_INT 34
10039: PUSH
10040: LD_INT 40
10042: PUSH
10043: LD_INT 48
10045: PUSH
10046: LD_INT 49
10048: PUSH
10049: LD_INT 50
10051: PUSH
10052: LD_INT 51
10054: PUSH
10055: LD_INT 52
10057: PUSH
10058: LD_INT 53
10060: PUSH
10061: LD_INT 54
10063: PUSH
10064: LD_INT 55
10066: PUSH
10067: LD_INT 56
10069: PUSH
10070: LD_INT 57
10072: PUSH
10073: LD_INT 58
10075: PUSH
10076: LD_INT 59
10078: PUSH
10079: LD_INT 60
10081: PUSH
10082: LD_INT 61
10084: PUSH
10085: LD_INT 62
10087: PUSH
10088: LD_INT 80
10090: PUSH
10091: LD_INT 82
10093: PUSH
10094: LD_INT 83
10096: PUSH
10097: LD_INT 84
10099: PUSH
10100: LD_INT 85
10102: PUSH
10103: LD_INT 86
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: LIST
10113: LIST
10114: LIST
10115: LIST
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: LIST
10121: LIST
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: LIST
10131: LIST
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: LIST
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: LIST
10149: LIST
10150: LIST
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: LIST
10157: LIST
10158: ST_TO_ADDR
10159: GO 10622
10161: LD_INT 2
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10391
10169: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
10170: NOP4
10174: PUSH
10175: LD_INT 35
10177: PUSH
10178: LD_INT 45
10180: PUSH
10181: LD_INT 46
10183: PUSH
10184: LD_INT 47
10186: PUSH
10187: LD_INT 82
10189: PUSH
10190: LD_INT 83
10192: PUSH
10193: LD_INT 84
10195: PUSH
10196: LD_INT 85
10198: PUSH
10199: LD_INT 87
10201: PUSH
10202: LD_INT 70
10204: PUSH
10205: LD_INT 1
10207: PUSH
10208: LD_INT 11
10210: PUSH
10211: LD_INT 3
10213: PUSH
10214: LD_INT 4
10216: PUSH
10217: LD_INT 5
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 15
10225: PUSH
10226: LD_INT 18
10228: PUSH
10229: LD_INT 7
10231: PUSH
10232: LD_INT 17
10234: PUSH
10235: LD_INT 8
10237: PUSH
10238: LD_INT 20
10240: PUSH
10241: LD_INT 21
10243: PUSH
10244: LD_INT 22
10246: PUSH
10247: LD_INT 72
10249: PUSH
10250: LD_INT 26
10252: PUSH
10253: LD_INT 69
10255: PUSH
10256: LD_INT 39
10258: PUSH
10259: LD_INT 40
10261: PUSH
10262: LD_INT 41
10264: PUSH
10265: LD_INT 42
10267: PUSH
10268: LD_INT 43
10270: PUSH
10271: LD_INT 48
10273: PUSH
10274: LD_INT 49
10276: PUSH
10277: LD_INT 50
10279: PUSH
10280: LD_INT 51
10282: PUSH
10283: LD_INT 52
10285: PUSH
10286: LD_INT 53
10288: PUSH
10289: LD_INT 54
10291: PUSH
10292: LD_INT 55
10294: PUSH
10295: LD_INT 56
10297: PUSH
10298: LD_INT 60
10300: PUSH
10301: LD_INT 61
10303: PUSH
10304: LD_INT 62
10306: PUSH
10307: LD_INT 66
10309: PUSH
10310: LD_INT 67
10312: PUSH
10313: LD_INT 68
10315: PUSH
10316: LD_INT 81
10318: PUSH
10319: LD_INT 82
10321: PUSH
10322: LD_INT 83
10324: PUSH
10325: LD_INT 84
10327: PUSH
10328: LD_INT 85
10330: PUSH
10331: LD_INT 87
10333: PUSH
10334: EMPTY
10335: LIST
10336: LIST
10337: LIST
10338: LIST
10339: LIST
10340: LIST
10341: LIST
10342: LIST
10343: LIST
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: LIST
10353: LIST
10354: LIST
10355: LIST
10356: LIST
10357: LIST
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: LIST
10369: LIST
10370: LIST
10371: LIST
10372: LIST
10373: LIST
10374: LIST
10375: LIST
10376: LIST
10377: LIST
10378: LIST
10379: LIST
10380: LIST
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: ST_TO_ADDR
10389: GO 10622
10391: LD_INT 3
10393: DOUBLE
10394: EQUAL
10395: IFTRUE 10399
10397: GO 10621
10399: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
10400: NOP4
10404: PUSH
10405: LD_INT 46
10407: PUSH
10408: LD_INT 47
10410: PUSH
10411: LD_INT 1
10413: PUSH
10414: LD_INT 2
10416: PUSH
10417: LD_INT 82
10419: PUSH
10420: LD_INT 83
10422: PUSH
10423: LD_INT 84
10425: PUSH
10426: LD_INT 85
10428: PUSH
10429: LD_INT 86
10431: PUSH
10432: LD_INT 11
10434: PUSH
10435: LD_INT 9
10437: PUSH
10438: LD_INT 20
10440: PUSH
10441: LD_INT 19
10443: PUSH
10444: LD_INT 21
10446: PUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 22
10452: PUSH
10453: LD_INT 25
10455: PUSH
10456: LD_INT 28
10458: PUSH
10459: LD_INT 29
10461: PUSH
10462: LD_INT 30
10464: PUSH
10465: LD_INT 31
10467: PUSH
10468: LD_INT 37
10470: PUSH
10471: LD_INT 38
10473: PUSH
10474: LD_INT 32
10476: PUSH
10477: LD_INT 27
10479: PUSH
10480: LD_INT 33
10482: PUSH
10483: LD_INT 69
10485: PUSH
10486: LD_INT 39
10488: PUSH
10489: LD_INT 34
10491: PUSH
10492: LD_INT 40
10494: PUSH
10495: LD_INT 71
10497: PUSH
10498: LD_INT 23
10500: PUSH
10501: LD_INT 44
10503: PUSH
10504: LD_INT 48
10506: PUSH
10507: LD_INT 49
10509: PUSH
10510: LD_INT 50
10512: PUSH
10513: LD_INT 51
10515: PUSH
10516: LD_INT 52
10518: PUSH
10519: LD_INT 53
10521: PUSH
10522: LD_INT 54
10524: PUSH
10525: LD_INT 55
10527: PUSH
10528: LD_INT 56
10530: PUSH
10531: LD_INT 57
10533: PUSH
10534: LD_INT 58
10536: PUSH
10537: LD_INT 59
10539: PUSH
10540: LD_INT 63
10542: PUSH
10543: LD_INT 64
10545: PUSH
10546: LD_INT 65
10548: PUSH
10549: LD_INT 82
10551: PUSH
10552: LD_INT 83
10554: PUSH
10555: LD_INT 84
10557: PUSH
10558: LD_INT 85
10560: PUSH
10561: LD_INT 86
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: LIST
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: LIST
10577: LIST
10578: LIST
10579: LIST
10580: LIST
10581: LIST
10582: LIST
10583: LIST
10584: LIST
10585: LIST
10586: LIST
10587: LIST
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: LIST
10593: LIST
10594: LIST
10595: LIST
10596: LIST
10597: LIST
10598: LIST
10599: LIST
10600: LIST
10601: LIST
10602: LIST
10603: LIST
10604: LIST
10605: LIST
10606: LIST
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: LIST
10616: LIST
10617: LIST
10618: ST_TO_ADDR
10619: GO 10622
10621: POP
// if state > - 1 and state < 3 then
10622: NOP4
10626: PUSH
10627: LD_INT 1
10629: NEG
10630: GREATER
10631: PUSH
10632: NOP4
10636: PUSH
10637: LD_INT 3
10639: LESS
10640: AND
10641: IFFALSE 10698
// for i in result do
10643: NOP4
10647: PUSH
10648: NOP4
10652: PUSH
10653: FOR_IN
10654: IFFALSE 10696
// if GetTech ( i , side ) <> state then
10656: NOP4
10660: PPUSH
10661: NOP4
10665: PPUSH
10666: NOP4
10670: PUSH
10671: NOP4
10675: NONEQUAL
10676: IFFALSE 10694
// result := result diff i ;
10678: NOP4
10682: PUSH
10683: NOP4
10687: PUSH
10688: NOP4
10692: DIFF
10693: ST_TO_ADDR
10694: GO 10653
10696: POP
10697: POP
// end ;
10698: LD_VAR 0 4
10702: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
10703: LD_INT 0
10705: PPUSH
10706: PPUSH
10707: PPUSH
// result := true ;
10708: NOP4
10712: PUSH
10713: LD_INT 1
10715: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
10716: NOP4
10720: PUSH
10721: NOP4
10725: PPUSH
10726: NOP4
10730: ST_TO_ADDR
// if not tmp then
10731: NOP4
10735: NOT
10736: IFFALSE 10740
// exit ;
10738: GO 10789
// for i in tmp do
10740: NOP4
10744: PUSH
10745: NOP4
10749: PUSH
10750: FOR_IN
10751: IFFALSE 10787
// if GetTech ( i , side ) <> state_researched then
10753: NOP4
10757: PPUSH
10758: NOP4
10762: PPUSH
10763: NOP4
10767: PUSH
10768: LD_INT 2
10770: NONEQUAL
10771: IFFALSE 10785
// begin result := false ;
10773: NOP4
10777: PUSH
10778: LD_INT 0
10780: ST_TO_ADDR
// exit ;
10781: POP
10782: POP
10783: GO 10789
// end ;
10785: GO 10750
10787: POP
10788: POP
// end ;
10789: LD_VAR 0 3
10793: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10794: LD_INT 0
10796: PPUSH
10797: PPUSH
10798: PPUSH
10799: PPUSH
10800: PPUSH
10801: PPUSH
10802: PPUSH
10803: PPUSH
10804: PPUSH
10805: PPUSH
10806: PPUSH
10807: PPUSH
10808: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10809: NOP4
10813: NOT
10814: PUSH
10815: NOP4
10819: PPUSH
10820: NOP4
10824: PUSH
10825: LD_INT 9
10827: NONEQUAL
10828: OR
10829: IFFALSE 10833
// exit ;
10831: GO 11406
// side := GetSide ( unit ) ;
10833: NOP4
10837: PUSH
10838: NOP4
10842: PPUSH
10843: NOP4
10847: ST_TO_ADDR
// tech_space := tech_spacanom ;
10848: NOP4
10852: PUSH
10853: LD_INT 29
10855: ST_TO_ADDR
// tech_time := tech_taurad ;
10856: NOP4
10860: PUSH
10861: LD_INT 28
10863: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10864: NOP4
10868: PUSH
10869: NOP4
10873: PPUSH
10874: NOP4
10878: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10879: NOP4
10883: PPUSH
10884: NOP4
10888: PUSH
10889: LD_INT 2
10891: EQUAL
10892: IFFALSE 10896
// exit ;
10894: GO 11406
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10896: NOP4
10900: PUSH
10901: LD_INT 81
10903: PUSH
10904: NOP4
10908: PUSH
10909: EMPTY
10910: LIST
10911: LIST
10912: PUSH
10913: LD_INT 3
10915: PUSH
10916: LD_INT 21
10918: PUSH
10919: LD_INT 3
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: EMPTY
10931: LIST
10932: LIST
10933: PPUSH
10934: NOP4
10938: ST_TO_ADDR
// if not tmp then
10939: NOP4
10943: NOT
10944: IFFALSE 10948
// exit ;
10946: GO 11406
// if in_unit then
10948: NOP4
10952: IFFALSE 10976
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10954: NOP4
10958: PUSH
10959: NOP4
10963: PPUSH
10964: NOP4
10968: PPUSH
10969: NOP4
10973: ST_TO_ADDR
10974: GO 10996
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10976: NOP4
10980: PUSH
10981: NOP4
10985: PPUSH
10986: NOP4
10990: PPUSH
10991: NOP4
10995: ST_TO_ADDR
// if not enemy then
10996: NOP4
11000: NOT
11001: IFFALSE 11005
// exit ;
11003: GO 11406
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11005: NOP4
11009: PUSH
11010: NOP4
11014: PPUSH
11015: NOP4
11019: PPUSH
11020: NOP4
11024: PUSH
11025: LD_INT 13
11027: GREATER
11028: AND
11029: PUSH
11030: NOP4
11034: PPUSH
11035: NOP4
11039: PPUSH
11040: NOP4
11044: PUSH
11045: LD_INT 12
11047: GREATER
11048: OR
11049: IFFALSE 11053
// exit ;
11051: GO 11406
// missile := [ 1 ] ;
11053: NOP4
11057: PUSH
11058: LD_INT 1
11060: PUSH
11061: EMPTY
11062: LIST
11063: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11064: NOP4
11068: PPUSH
11069: NOP4
11073: PPUSH
11074: NOP4
11078: IFFALSE 11107
// missile := Insert ( missile , missile + 1 , 2 ) ;
11080: NOP4
11084: PUSH
11085: NOP4
11089: PPUSH
11090: NOP4
11094: PUSH
11095: LD_INT 1
11097: PLUS
11098: PPUSH
11099: LD_INT 2
11101: PPUSH
11102: NOP4
11106: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11107: NOP4
11111: PPUSH
11112: NOP4
11116: PPUSH
11117: NOP4
11121: PUSH
11122: NOP4
11126: PPUSH
11127: NOP4
11131: PPUSH
11132: NOP4
11136: PPUSH
11137: NOP4
11141: NOT
11142: AND
11143: IFFALSE 11172
// missile := Insert ( missile , missile + 1 , 3 ) ;
11145: NOP4
11149: PUSH
11150: NOP4
11154: PPUSH
11155: NOP4
11159: PUSH
11160: LD_INT 1
11162: PLUS
11163: PPUSH
11164: LD_INT 3
11166: PPUSH
11167: NOP4
11171: ST_TO_ADDR
// if missile < 2 then
11172: NOP4
11176: PUSH
11177: LD_INT 2
11179: LESS
11180: IFFALSE 11184
// exit ;
11182: GO 11406
// x := GetX ( enemy ) ;
11184: NOP4
11188: PUSH
11189: NOP4
11193: PPUSH
11194: NOP4
11198: ST_TO_ADDR
// y := GetY ( enemy ) ;
11199: NOP4
11203: PUSH
11204: NOP4
11208: PPUSH
11209: NOP4
11213: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
11214: NOP4
11218: PUSH
11219: NOP4
11223: PUSH
11224: LD_INT 1
11226: NEG
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: NOP4
11235: PLUS
11236: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
11237: NOP4
11241: PUSH
11242: NOP4
11246: PUSH
11247: LD_INT 1
11249: NEG
11250: PPUSH
11251: LD_INT 1
11253: PPUSH
11254: NOP4
11258: PLUS
11259: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11260: NOP4
11264: PPUSH
11265: NOP4
11269: PPUSH
11270: NOP4
11274: NOT
11275: IFFALSE 11297
// begin _x := x ;
11277: NOP4
11281: PUSH
11282: NOP4
11286: ST_TO_ADDR
// _y := y ;
11287: NOP4
11291: PUSH
11292: NOP4
11296: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
11297: NOP4
11301: PUSH
11302: LD_INT 1
11304: PPUSH
11305: NOP4
11309: PPUSH
11310: NOP4
11314: ST_TO_ADDR
// case i of 1 :
11315: NOP4
11319: PUSH
11320: LD_INT 1
11322: DOUBLE
11323: EQUAL
11324: IFTRUE 11328
11326: GO 11345
11328: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
11329: NOP4
11333: PPUSH
11334: NOP4
11338: PPUSH
11339: NOP4
11343: GO 11406
11345: LD_INT 2
11347: DOUBLE
11348: EQUAL
11349: IFTRUE 11353
11351: GO 11375
11353: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
11354: NOP4
11358: PPUSH
11359: NOP4
11363: PPUSH
11364: NOP4
11368: PPUSH
11369: NOP4
11373: GO 11406
11375: LD_INT 3
11377: DOUBLE
11378: EQUAL
11379: IFTRUE 11383
11381: GO 11405
11383: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
11384: NOP4
11388: PPUSH
11389: NOP4
11393: PPUSH
11394: NOP4
11398: PPUSH
11399: NOP4
11403: GO 11406
11405: POP
// end ;
11406: LD_VAR 0 2
11410: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
11411: LD_INT 0
11413: PPUSH
11414: PPUSH
11415: PPUSH
11416: PPUSH
11417: PPUSH
11418: PPUSH
// if not unit or not building then
11419: NOP4
11423: NOT
11424: PUSH
11425: NOP4
11429: NOT
11430: OR
11431: IFFALSE 11435
// exit ;
11433: GO 11593
// x := GetX ( building ) ;
11435: NOP4
11439: PUSH
11440: NOP4
11444: PPUSH
11445: NOP4
11449: ST_TO_ADDR
// y := GetY ( building ) ;
11450: NOP4
11454: PUSH
11455: NOP4
11459: PPUSH
11460: NOP4
11464: ST_TO_ADDR
// for i = 0 to 5 do
11465: NOP4
11469: PUSH
11470: DOUBLE
11471: LD_INT 0
11473: DEC
11474: ST_TO_ADDR
11475: LD_INT 5
11477: PUSH
11478: FOR_TO
11479: IFFALSE 11591
// begin _x := ShiftX ( x , i , 3 ) ;
11481: NOP4
11485: PUSH
11486: NOP4
11490: PPUSH
11491: NOP4
11495: PPUSH
11496: LD_INT 3
11498: PPUSH
11499: NOP4
11503: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
11504: NOP4
11508: PUSH
11509: NOP4
11513: PPUSH
11514: NOP4
11518: PPUSH
11519: LD_INT 3
11521: PPUSH
11522: NOP4
11526: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
11527: NOP4
11531: PPUSH
11532: NOP4
11536: PPUSH
11537: NOP4
11541: NOT
11542: IFFALSE 11546
// continue ;
11544: GO 11478
// if HexInfo ( _x , _y ) = 0 then
11546: NOP4
11550: PPUSH
11551: NOP4
11555: PPUSH
11556: NOP4
11560: PUSH
11561: LD_INT 0
11563: EQUAL
11564: IFFALSE 11589
// begin ComMoveXY ( unit , _x , _y ) ;
11566: NOP4
11570: PPUSH
11571: NOP4
11575: PPUSH
11576: NOP4
11580: PPUSH
11581: NOP4
// exit ;
11585: POP
11586: POP
11587: GO 11593
// end ; end ;
11589: GO 11478
11591: POP
11592: POP
// end ;
11593: LD_VAR 0 3
11597: RET
// export function ScanBase ( side , base_area ) ; begin
11598: LD_INT 0
11600: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
11601: NOP4
11605: PUSH
11606: NOP4
11610: PPUSH
11611: LD_INT 81
11613: PUSH
11614: NOP4
11618: PUSH
11619: EMPTY
11620: LIST
11621: LIST
11622: PPUSH
11623: NOP4
11627: ST_TO_ADDR
// end ;
11628: LD_VAR 0 3
11632: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
11633: LD_INT 0
11635: PPUSH
11636: PPUSH
11637: PPUSH
11638: PPUSH
// result := false ;
11639: NOP4
11643: PUSH
11644: LD_INT 0
11646: ST_TO_ADDR
// side := GetSide ( unit ) ;
11647: NOP4
11651: PUSH
11652: NOP4
11656: PPUSH
11657: NOP4
11661: ST_TO_ADDR
// nat := GetNation ( unit ) ;
11662: NOP4
11666: PUSH
11667: NOP4
11671: PPUSH
11672: NOP4
11676: ST_TO_ADDR
// case nat of 1 :
11677: NOP4
11681: PUSH
11682: LD_INT 1
11684: DOUBLE
11685: EQUAL
11686: IFTRUE 11690
11688: GO 11701
11690: POP
// tech := tech_lassight ; 2 :
11691: NOP4
11695: PUSH
11696: LD_INT 12
11698: ST_TO_ADDR
11699: GO 11740
11701: LD_INT 2
11703: DOUBLE
11704: EQUAL
11705: IFTRUE 11709
11707: GO 11720
11709: POP
// tech := tech_mortar ; 3 :
11710: NOP4
11714: PUSH
11715: LD_INT 41
11717: ST_TO_ADDR
11718: GO 11740
11720: LD_INT 3
11722: DOUBLE
11723: EQUAL
11724: IFTRUE 11728
11726: GO 11739
11728: POP
// tech := tech_bazooka ; end ;
11729: NOP4
11733: PUSH
11734: LD_INT 44
11736: ST_TO_ADDR
11737: GO 11740
11739: POP
// if Researched ( side , tech ) then
11740: NOP4
11744: PPUSH
11745: NOP4
11749: PPUSH
11750: NOP4
11754: IFFALSE 11781
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
11756: NOP4
11760: PUSH
11761: LD_INT 5
11763: PUSH
11764: LD_INT 8
11766: PUSH
11767: LD_INT 9
11769: PUSH
11770: EMPTY
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: NOP4
11779: ARRAY
11780: ST_TO_ADDR
// end ;
11781: LD_VAR 0 2
11785: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11786: LD_INT 0
11788: PPUSH
11789: PPUSH
11790: PPUSH
// if not mines then
11791: NOP4
11795: NOT
11796: IFFALSE 11800
// exit ;
11798: GO 11944
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11800: NOP4
11804: PUSH
11805: LD_INT 81
11807: PUSH
11808: NOP4
11812: PUSH
11813: EMPTY
11814: LIST
11815: LIST
11816: PUSH
11817: LD_INT 3
11819: PUSH
11820: LD_INT 21
11822: PUSH
11823: LD_INT 3
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: EMPTY
11831: LIST
11832: LIST
11833: PUSH
11834: EMPTY
11835: LIST
11836: LIST
11837: PPUSH
11838: NOP4
11842: ST_TO_ADDR
// for i in mines do
11843: NOP4
11847: PUSH
11848: NOP4
11852: PUSH
11853: FOR_IN
11854: IFFALSE 11942
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11856: NOP4
11860: PUSH
11861: LD_INT 1
11863: ARRAY
11864: PPUSH
11865: NOP4
11869: PUSH
11870: LD_INT 2
11872: ARRAY
11873: PPUSH
11874: NOP4
11878: NOT
11879: IFFALSE 11883
// continue ;
11881: GO 11853
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11883: NOP4
11887: PUSH
11888: LD_INT 1
11890: ARRAY
11891: PPUSH
11892: NOP4
11896: PUSH
11897: LD_INT 2
11899: ARRAY
11900: PPUSH
11901: NOP4
11905: PUSH
11906: NOP4
11910: IN
11911: IFFALSE 11940
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11913: NOP4
11917: PUSH
11918: LD_INT 1
11920: ARRAY
11921: PPUSH
11922: NOP4
11926: PUSH
11927: LD_INT 2
11929: ARRAY
11930: PPUSH
11931: NOP4
11935: PPUSH
11936: NOP4
// end ;
11940: GO 11853
11942: POP
11943: POP
// end ;
11944: LD_VAR 0 3
11948: RET
// export function Count ( array ) ; var i ; begin
11949: LD_INT 0
11951: PPUSH
11952: PPUSH
// result := 0 ;
11953: NOP4
11957: PUSH
11958: LD_INT 0
11960: ST_TO_ADDR
// for i in array do
11961: NOP4
11965: PUSH
11966: NOP4
11970: PUSH
11971: FOR_IN
11972: IFFALSE 11996
// if i then
11974: NOP4
11978: IFFALSE 11994
// result := result + 1 ;
11980: NOP4
11984: PUSH
11985: NOP4
11989: PUSH
11990: LD_INT 1
11992: PLUS
11993: ST_TO_ADDR
11994: GO 11971
11996: POP
11997: POP
// end ;
11998: LD_VAR 0 2
12002: RET
// export function IsEmpty ( building ) ; begin
12003: LD_INT 0
12005: PPUSH
// if not building then
12006: NOP4
12010: NOT
12011: IFFALSE 12015
// exit ;
12013: GO 12058
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12015: NOP4
12019: PUSH
12020: NOP4
12024: PUSH
12025: LD_INT 22
12027: PUSH
12028: NOP4
12032: PPUSH
12033: NOP4
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: LD_INT 58
12044: PUSH
12045: EMPTY
12046: LIST
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PPUSH
12052: NOP4
12056: IN
12057: ST_TO_ADDR
// end ;
12058: LD_VAR 0 2
12062: RET
// export function IsNotFull ( building ) ; begin
12063: LD_INT 0
12065: PPUSH
// if not building then
12066: NOP4
12070: NOT
12071: IFFALSE 12075
// exit ;
12073: GO 12094
// result := UnitsInside ( building ) < 6 ;
12075: NOP4
12079: PUSH
12080: NOP4
12084: PPUSH
12085: NOP4
12089: PUSH
12090: LD_INT 6
12092: LESS
12093: ST_TO_ADDR
// end ;
12094: LD_VAR 0 2
12098: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12099: LD_INT 0
12101: PPUSH
12102: PPUSH
12103: PPUSH
12104: PPUSH
// tmp := [ ] ;
12105: NOP4
12109: PUSH
12110: EMPTY
12111: ST_TO_ADDR
// list := [ ] ;
12112: NOP4
12116: PUSH
12117: EMPTY
12118: ST_TO_ADDR
// for i = 16 to 25 do
12119: NOP4
12123: PUSH
12124: DOUBLE
12125: LD_INT 16
12127: DEC
12128: ST_TO_ADDR
12129: LD_INT 25
12131: PUSH
12132: FOR_TO
12133: IFFALSE 12206
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
12135: NOP4
12139: PUSH
12140: NOP4
12144: PUSH
12145: LD_INT 22
12147: PUSH
12148: NOP4
12152: PPUSH
12153: NOP4
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 91
12164: PUSH
12165: NOP4
12169: PUSH
12170: LD_INT 6
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: LIST
12177: PUSH
12178: LD_INT 30
12180: PUSH
12181: NOP4
12185: PUSH
12186: EMPTY
12187: LIST
12188: LIST
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: LIST
12194: PUSH
12195: EMPTY
12196: LIST
12197: PPUSH
12198: NOP4
12202: ADD
12203: ST_TO_ADDR
12204: GO 12132
12206: POP
12207: POP
// for i = 1 to tmp do
12208: NOP4
12212: PUSH
12213: DOUBLE
12214: LD_INT 1
12216: DEC
12217: ST_TO_ADDR
12218: NOP4
12222: PUSH
12223: FOR_TO
12224: IFFALSE 12312
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
12226: NOP4
12230: PUSH
12231: NOP4
12235: PUSH
12236: NOP4
12240: PUSH
12241: NOP4
12245: ARRAY
12246: PPUSH
12247: NOP4
12251: PUSH
12252: NOP4
12256: PUSH
12257: NOP4
12261: ARRAY
12262: PPUSH
12263: NOP4
12267: PUSH
12268: NOP4
12272: PUSH
12273: NOP4
12277: ARRAY
12278: PPUSH
12279: NOP4
12283: PUSH
12284: NOP4
12288: PUSH
12289: NOP4
12293: ARRAY
12294: PPUSH
12295: NOP4
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: LIST
12304: LIST
12305: PUSH
12306: EMPTY
12307: LIST
12308: ADD
12309: ST_TO_ADDR
12310: GO 12223
12312: POP
12313: POP
// result := list ;
12314: NOP4
12318: PUSH
12319: NOP4
12323: ST_TO_ADDR
// end ;
12324: LD_VAR 0 2
12328: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
12329: LD_INT 0
12331: PPUSH
12332: PPUSH
12333: PPUSH
12334: PPUSH
12335: PPUSH
12336: PPUSH
12337: PPUSH
// if not factory then
12338: NOP4
12342: NOT
12343: IFFALSE 12347
// exit ;
12345: GO 12940
// if control = control_apeman then
12347: NOP4
12351: PUSH
12352: LD_INT 5
12354: EQUAL
12355: IFFALSE 12464
// begin tmp := UnitsInside ( factory ) ;
12357: NOP4
12361: PUSH
12362: NOP4
12366: PPUSH
12367: NOP4
12371: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
12372: NOP4
12376: PPUSH
12377: LD_INT 25
12379: PUSH
12380: LD_INT 12
12382: PUSH
12383: EMPTY
12384: LIST
12385: LIST
12386: PPUSH
12387: NOP4
12391: NOT
12392: IFFALSE 12402
// control := control_manual ;
12394: NOP4
12398: PUSH
12399: LD_INT 1
12401: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
12402: NOP4
12406: PUSH
12407: NOP4
12411: PPUSH
12412: NOP4
12416: ST_TO_ADDR
// if tmp then
12417: NOP4
12421: IFFALSE 12464
// begin for i in tmp do
12423: NOP4
12427: PUSH
12428: NOP4
12432: PUSH
12433: FOR_IN
12434: IFFALSE 12462
// if i [ 1 ] = b_ext_radio then
12436: NOP4
12440: PUSH
12441: LD_INT 1
12443: ARRAY
12444: PUSH
12445: LD_INT 22
12447: EQUAL
12448: IFFALSE 12460
// begin control := control_remote ;
12450: NOP4
12454: PUSH
12455: LD_INT 2
12457: ST_TO_ADDR
// break ;
12458: GO 12462
// end ;
12460: GO 12433
12462: POP
12463: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12464: NOP4
12468: PPUSH
12469: NOP4
12473: PPUSH
12474: NOP4
12478: PPUSH
12479: NOP4
12483: PPUSH
12484: NOP4
12488: PPUSH
12489: NOP4
12493: IFFALSE 12528
// begin result := [ chassis , engine , control , weapon ] ;
12495: NOP4
12499: PUSH
12500: NOP4
12504: PUSH
12505: NOP4
12509: PUSH
12510: NOP4
12514: PUSH
12515: NOP4
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: LIST
12524: LIST
12525: ST_TO_ADDR
// exit ;
12526: GO 12940
// end ; _chassis := AvailableChassisList ( factory ) ;
12528: NOP4
12532: PUSH
12533: NOP4
12537: PPUSH
12538: NOP4
12542: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
12543: NOP4
12547: PUSH
12548: NOP4
12552: PPUSH
12553: NOP4
12557: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
12558: NOP4
12562: PUSH
12563: NOP4
12567: PPUSH
12568: NOP4
12572: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
12573: NOP4
12577: PUSH
12578: NOP4
12582: PPUSH
12583: NOP4
12587: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
12588: NOP4
12592: NOT
12593: PUSH
12594: NOP4
12598: NOT
12599: OR
12600: PUSH
12601: NOP4
12605: NOT
12606: OR
12607: PUSH
12608: NOP4
12612: NOT
12613: OR
12614: IFFALSE 12649
// begin result := [ chassis , engine , control , weapon ] ;
12616: NOP4
12620: PUSH
12621: NOP4
12625: PUSH
12626: NOP4
12630: PUSH
12631: NOP4
12635: PUSH
12636: NOP4
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: LIST
12645: LIST
12646: ST_TO_ADDR
// exit ;
12647: GO 12940
// end ; if not chassis in _chassis then
12649: NOP4
12653: PUSH
12654: NOP4
12658: IN
12659: NOT
12660: IFFALSE 12686
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
12662: NOP4
12666: PUSH
12667: NOP4
12671: PUSH
12672: LD_INT 1
12674: PPUSH
12675: NOP4
12679: PPUSH
12680: NOP4
12684: ARRAY
12685: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
12686: NOP4
12690: PPUSH
12691: NOP4
12695: PPUSH
12696: NOP4
12700: NOT
12701: IFFALSE 12760
// repeat engine := _engine [ 1 ] ;
12703: NOP4
12707: PUSH
12708: NOP4
12712: PUSH
12713: LD_INT 1
12715: ARRAY
12716: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
12717: NOP4
12721: PUSH
12722: NOP4
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: NOP4
12734: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
12735: NOP4
12739: PPUSH
12740: NOP4
12744: PPUSH
12745: NOP4
12749: PUSH
12750: NOP4
12754: PUSH
12755: EMPTY
12756: EQUAL
12757: OR
12758: IFFALSE 12703
// if not control in _control then
12760: NOP4
12764: PUSH
12765: NOP4
12769: IN
12770: NOT
12771: IFFALSE 12797
// control := _control [ rand ( 1 , _control ) ] ;
12773: NOP4
12777: PUSH
12778: NOP4
12782: PUSH
12783: LD_INT 1
12785: PPUSH
12786: NOP4
12790: PPUSH
12791: NOP4
12795: ARRAY
12796: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12797: NOP4
12801: PPUSH
12802: NOP4
12806: PPUSH
12807: NOP4
12811: NOT
12812: IFFALSE 12871
// repeat weapon := _weapon [ 1 ] ;
12814: NOP4
12818: PUSH
12819: NOP4
12823: PUSH
12824: LD_INT 1
12826: ARRAY
12827: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12828: NOP4
12832: PUSH
12833: NOP4
12837: PPUSH
12838: LD_INT 1
12840: PPUSH
12841: NOP4
12845: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12846: NOP4
12850: PPUSH
12851: NOP4
12855: PPUSH
12856: NOP4
12860: PUSH
12861: NOP4
12865: PUSH
12866: EMPTY
12867: EQUAL
12868: OR
12869: IFFALSE 12814
// result := [ ] ;
12871: NOP4
12875: PUSH
12876: EMPTY
12877: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12878: NOP4
12882: PPUSH
12883: NOP4
12887: PPUSH
12888: NOP4
12892: PPUSH
12893: NOP4
12897: PPUSH
12898: NOP4
12902: PPUSH
12903: NOP4
12907: IFFALSE 12940
// result := [ chassis , engine , control , weapon ] ;
12909: NOP4
12913: PUSH
12914: NOP4
12918: PUSH
12919: NOP4
12923: PUSH
12924: NOP4
12928: PUSH
12929: NOP4
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: LIST
12938: LIST
12939: ST_TO_ADDR
// end ;
12940: LD_VAR 0 6
12944: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12945: LD_INT 0
12947: PPUSH
// if not chassis or not engine then
12948: NOP4
12952: NOT
12953: PUSH
12954: NOP4
12958: NOT
12959: OR
12960: IFFALSE 12964
// exit ;
12962: GO 13160
// case engine of engine_solar :
12964: NOP4
12968: PUSH
12969: LD_INT 2
12971: DOUBLE
12972: EQUAL
12973: IFTRUE 12977
12975: GO 13015
12977: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12978: NOP4
12982: PUSH
12983: LD_INT 11
12985: PUSH
12986: LD_INT 12
12988: PUSH
12989: LD_INT 13
12991: PUSH
12992: LD_INT 14
12994: PUSH
12995: LD_INT 1
12997: PUSH
12998: LD_INT 2
13000: PUSH
13001: LD_INT 3
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: LIST
13012: ST_TO_ADDR
13013: GO 13144
13015: LD_INT 1
13017: DOUBLE
13018: EQUAL
13019: IFTRUE 13023
13021: GO 13085
13023: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13024: NOP4
13028: PUSH
13029: LD_INT 11
13031: PUSH
13032: LD_INT 12
13034: PUSH
13035: LD_INT 13
13037: PUSH
13038: LD_INT 14
13040: PUSH
13041: LD_INT 1
13043: PUSH
13044: LD_INT 2
13046: PUSH
13047: LD_INT 3
13049: PUSH
13050: LD_INT 4
13052: PUSH
13053: LD_INT 5
13055: PUSH
13056: LD_INT 21
13058: PUSH
13059: LD_INT 23
13061: PUSH
13062: LD_INT 22
13064: PUSH
13065: LD_INT 24
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: LIST
13079: LIST
13080: LIST
13081: LIST
13082: ST_TO_ADDR
13083: GO 13144
13085: LD_INT 3
13087: DOUBLE
13088: EQUAL
13089: IFTRUE 13093
13091: GO 13143
13093: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13094: NOP4
13098: PUSH
13099: LD_INT 13
13101: PUSH
13102: LD_INT 14
13104: PUSH
13105: LD_INT 2
13107: PUSH
13108: LD_INT 3
13110: PUSH
13111: LD_INT 4
13113: PUSH
13114: LD_INT 5
13116: PUSH
13117: LD_INT 21
13119: PUSH
13120: LD_INT 22
13122: PUSH
13123: LD_INT 23
13125: PUSH
13126: LD_INT 24
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: ST_TO_ADDR
13141: GO 13144
13143: POP
// result := ( chassis in result ) ;
13144: NOP4
13148: PUSH
13149: NOP4
13153: PUSH
13154: NOP4
13158: IN
13159: ST_TO_ADDR
// end ;
13160: LD_VAR 0 3
13164: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
13165: LD_INT 0
13167: PPUSH
// if not chassis or not weapon then
13168: NOP4
13172: NOT
13173: PUSH
13174: NOP4
13178: NOT
13179: OR
13180: IFFALSE 13184
// exit ;
13182: GO 14210
// case weapon of us_machine_gun :
13184: NOP4
13188: PUSH
13189: LD_INT 2
13191: DOUBLE
13192: EQUAL
13193: IFTRUE 13197
13195: GO 13227
13197: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
13198: NOP4
13202: PUSH
13203: LD_INT 1
13205: PUSH
13206: LD_INT 2
13208: PUSH
13209: LD_INT 3
13211: PUSH
13212: LD_INT 4
13214: PUSH
13215: LD_INT 5
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: ST_TO_ADDR
13225: GO 14194
13227: LD_INT 3
13229: DOUBLE
13230: EQUAL
13231: IFTRUE 13235
13233: GO 13265
13235: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
13236: NOP4
13240: PUSH
13241: LD_INT 1
13243: PUSH
13244: LD_INT 2
13246: PUSH
13247: LD_INT 3
13249: PUSH
13250: LD_INT 4
13252: PUSH
13253: LD_INT 5
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: ST_TO_ADDR
13263: GO 14194
13265: LD_INT 11
13267: DOUBLE
13268: EQUAL
13269: IFTRUE 13273
13271: GO 13303
13273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
13274: NOP4
13278: PUSH
13279: LD_INT 1
13281: PUSH
13282: LD_INT 2
13284: PUSH
13285: LD_INT 3
13287: PUSH
13288: LD_INT 4
13290: PUSH
13291: LD_INT 5
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: LIST
13299: LIST
13300: ST_TO_ADDR
13301: GO 14194
13303: LD_INT 4
13305: DOUBLE
13306: EQUAL
13307: IFTRUE 13311
13309: GO 13337
13311: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
13312: NOP4
13316: PUSH
13317: LD_INT 2
13319: PUSH
13320: LD_INT 3
13322: PUSH
13323: LD_INT 4
13325: PUSH
13326: LD_INT 5
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: LIST
13333: LIST
13334: ST_TO_ADDR
13335: GO 14194
13337: LD_INT 5
13339: DOUBLE
13340: EQUAL
13341: IFTRUE 13345
13343: GO 13371
13345: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
13346: NOP4
13350: PUSH
13351: LD_INT 2
13353: PUSH
13354: LD_INT 3
13356: PUSH
13357: LD_INT 4
13359: PUSH
13360: LD_INT 5
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: ST_TO_ADDR
13369: GO 14194
13371: LD_INT 9
13373: DOUBLE
13374: EQUAL
13375: IFTRUE 13379
13377: GO 13405
13379: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
13380: NOP4
13384: PUSH
13385: LD_INT 2
13387: PUSH
13388: LD_INT 3
13390: PUSH
13391: LD_INT 4
13393: PUSH
13394: LD_INT 5
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: LIST
13401: LIST
13402: ST_TO_ADDR
13403: GO 14194
13405: LD_INT 7
13407: DOUBLE
13408: EQUAL
13409: IFTRUE 13413
13411: GO 13439
13413: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
13414: NOP4
13418: PUSH
13419: LD_INT 2
13421: PUSH
13422: LD_INT 3
13424: PUSH
13425: LD_INT 4
13427: PUSH
13428: LD_INT 5
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: LIST
13435: LIST
13436: ST_TO_ADDR
13437: GO 14194
13439: LD_INT 12
13441: DOUBLE
13442: EQUAL
13443: IFTRUE 13447
13445: GO 13473
13447: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
13448: NOP4
13452: PUSH
13453: LD_INT 2
13455: PUSH
13456: LD_INT 3
13458: PUSH
13459: LD_INT 4
13461: PUSH
13462: LD_INT 5
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: ST_TO_ADDR
13471: GO 14194
13473: LD_INT 13
13475: DOUBLE
13476: EQUAL
13477: IFTRUE 13481
13479: GO 13507
13481: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
13482: NOP4
13486: PUSH
13487: LD_INT 2
13489: PUSH
13490: LD_INT 3
13492: PUSH
13493: LD_INT 4
13495: PUSH
13496: LD_INT 5
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: LIST
13503: LIST
13504: ST_TO_ADDR
13505: GO 14194
13507: LD_INT 14
13509: DOUBLE
13510: EQUAL
13511: IFTRUE 13515
13513: GO 13533
13515: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
13516: NOP4
13520: PUSH
13521: LD_INT 4
13523: PUSH
13524: LD_INT 5
13526: PUSH
13527: EMPTY
13528: LIST
13529: LIST
13530: ST_TO_ADDR
13531: GO 14194
13533: LD_INT 6
13535: DOUBLE
13536: EQUAL
13537: IFTRUE 13541
13539: GO 13559
13541: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
13542: NOP4
13546: PUSH
13547: LD_INT 4
13549: PUSH
13550: LD_INT 5
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: ST_TO_ADDR
13557: GO 14194
13559: LD_INT 10
13561: DOUBLE
13562: EQUAL
13563: IFTRUE 13567
13565: GO 13585
13567: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
13568: NOP4
13572: PUSH
13573: LD_INT 4
13575: PUSH
13576: LD_INT 5
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: ST_TO_ADDR
13583: GO 14194
13585: LD_INT 22
13587: DOUBLE
13588: EQUAL
13589: IFTRUE 13593
13591: GO 13619
13593: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
13594: NOP4
13598: PUSH
13599: LD_INT 11
13601: PUSH
13602: LD_INT 12
13604: PUSH
13605: LD_INT 13
13607: PUSH
13608: LD_INT 14
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: ST_TO_ADDR
13617: GO 14194
13619: LD_INT 23
13621: DOUBLE
13622: EQUAL
13623: IFTRUE 13627
13625: GO 13653
13627: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
13628: NOP4
13632: PUSH
13633: LD_INT 11
13635: PUSH
13636: LD_INT 12
13638: PUSH
13639: LD_INT 13
13641: PUSH
13642: LD_INT 14
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: ST_TO_ADDR
13651: GO 14194
13653: LD_INT 24
13655: DOUBLE
13656: EQUAL
13657: IFTRUE 13661
13659: GO 13687
13661: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
13662: NOP4
13666: PUSH
13667: LD_INT 11
13669: PUSH
13670: LD_INT 12
13672: PUSH
13673: LD_INT 13
13675: PUSH
13676: LD_INT 14
13678: PUSH
13679: EMPTY
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: ST_TO_ADDR
13685: GO 14194
13687: LD_INT 30
13689: DOUBLE
13690: EQUAL
13691: IFTRUE 13695
13693: GO 13721
13695: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
13696: NOP4
13700: PUSH
13701: LD_INT 11
13703: PUSH
13704: LD_INT 12
13706: PUSH
13707: LD_INT 13
13709: PUSH
13710: LD_INT 14
13712: PUSH
13713: EMPTY
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: ST_TO_ADDR
13719: GO 14194
13721: LD_INT 25
13723: DOUBLE
13724: EQUAL
13725: IFTRUE 13729
13727: GO 13747
13729: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
13730: NOP4
13734: PUSH
13735: LD_INT 13
13737: PUSH
13738: LD_INT 14
13740: PUSH
13741: EMPTY
13742: LIST
13743: LIST
13744: ST_TO_ADDR
13745: GO 14194
13747: LD_INT 27
13749: DOUBLE
13750: EQUAL
13751: IFTRUE 13755
13753: GO 13773
13755: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13756: NOP4
13760: PUSH
13761: LD_INT 13
13763: PUSH
13764: LD_INT 14
13766: PUSH
13767: EMPTY
13768: LIST
13769: LIST
13770: ST_TO_ADDR
13771: GO 14194
13773: LD_INT 28
13775: DOUBLE
13776: EQUAL
13777: IFTRUE 13781
13779: GO 13799
13781: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13782: NOP4
13786: PUSH
13787: LD_INT 13
13789: PUSH
13790: LD_INT 14
13792: PUSH
13793: EMPTY
13794: LIST
13795: LIST
13796: ST_TO_ADDR
13797: GO 14194
13799: LD_INT 29
13801: DOUBLE
13802: EQUAL
13803: IFTRUE 13807
13805: GO 13825
13807: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13808: NOP4
13812: PUSH
13813: LD_INT 13
13815: PUSH
13816: LD_INT 14
13818: PUSH
13819: EMPTY
13820: LIST
13821: LIST
13822: ST_TO_ADDR
13823: GO 14194
13825: LD_INT 31
13827: DOUBLE
13828: EQUAL
13829: IFTRUE 13833
13831: GO 13851
13833: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13834: NOP4
13838: PUSH
13839: LD_INT 13
13841: PUSH
13842: LD_INT 14
13844: PUSH
13845: EMPTY
13846: LIST
13847: LIST
13848: ST_TO_ADDR
13849: GO 14194
13851: LD_INT 26
13853: DOUBLE
13854: EQUAL
13855: IFTRUE 13859
13857: GO 13877
13859: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13860: NOP4
13864: PUSH
13865: LD_INT 13
13867: PUSH
13868: LD_INT 14
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: ST_TO_ADDR
13875: GO 14194
13877: LD_INT 42
13879: DOUBLE
13880: EQUAL
13881: IFTRUE 13885
13883: GO 13911
13885: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13886: NOP4
13890: PUSH
13891: LD_INT 21
13893: PUSH
13894: LD_INT 22
13896: PUSH
13897: LD_INT 23
13899: PUSH
13900: LD_INT 24
13902: PUSH
13903: EMPTY
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: ST_TO_ADDR
13909: GO 14194
13911: LD_INT 43
13913: DOUBLE
13914: EQUAL
13915: IFTRUE 13919
13917: GO 13945
13919: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13920: NOP4
13924: PUSH
13925: LD_INT 21
13927: PUSH
13928: LD_INT 22
13930: PUSH
13931: LD_INT 23
13933: PUSH
13934: LD_INT 24
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: ST_TO_ADDR
13943: GO 14194
13945: LD_INT 44
13947: DOUBLE
13948: EQUAL
13949: IFTRUE 13953
13951: GO 13979
13953: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13954: NOP4
13958: PUSH
13959: LD_INT 21
13961: PUSH
13962: LD_INT 22
13964: PUSH
13965: LD_INT 23
13967: PUSH
13968: LD_INT 24
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: ST_TO_ADDR
13977: GO 14194
13979: LD_INT 45
13981: DOUBLE
13982: EQUAL
13983: IFTRUE 13987
13985: GO 14013
13987: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13988: NOP4
13992: PUSH
13993: LD_INT 21
13995: PUSH
13996: LD_INT 22
13998: PUSH
13999: LD_INT 23
14001: PUSH
14002: LD_INT 24
14004: PUSH
14005: EMPTY
14006: LIST
14007: LIST
14008: LIST
14009: LIST
14010: ST_TO_ADDR
14011: GO 14194
14013: LD_INT 49
14015: DOUBLE
14016: EQUAL
14017: IFTRUE 14021
14019: GO 14047
14021: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14022: NOP4
14026: PUSH
14027: LD_INT 21
14029: PUSH
14030: LD_INT 22
14032: PUSH
14033: LD_INT 23
14035: PUSH
14036: LD_INT 24
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: ST_TO_ADDR
14045: GO 14194
14047: LD_INT 51
14049: DOUBLE
14050: EQUAL
14051: IFTRUE 14055
14053: GO 14081
14055: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14056: NOP4
14060: PUSH
14061: LD_INT 21
14063: PUSH
14064: LD_INT 22
14066: PUSH
14067: LD_INT 23
14069: PUSH
14070: LD_INT 24
14072: PUSH
14073: EMPTY
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: ST_TO_ADDR
14079: GO 14194
14081: LD_INT 52
14083: DOUBLE
14084: EQUAL
14085: IFTRUE 14089
14087: GO 14115
14089: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14090: NOP4
14094: PUSH
14095: LD_INT 21
14097: PUSH
14098: LD_INT 22
14100: PUSH
14101: LD_INT 23
14103: PUSH
14104: LD_INT 24
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: ST_TO_ADDR
14113: GO 14194
14115: LD_INT 53
14117: DOUBLE
14118: EQUAL
14119: IFTRUE 14123
14121: GO 14141
14123: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
14124: NOP4
14128: PUSH
14129: LD_INT 23
14131: PUSH
14132: LD_INT 24
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: ST_TO_ADDR
14139: GO 14194
14141: LD_INT 46
14143: DOUBLE
14144: EQUAL
14145: IFTRUE 14149
14147: GO 14167
14149: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
14150: NOP4
14154: PUSH
14155: LD_INT 23
14157: PUSH
14158: LD_INT 24
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: ST_TO_ADDR
14165: GO 14194
14167: LD_INT 47
14169: DOUBLE
14170: EQUAL
14171: IFTRUE 14175
14173: GO 14193
14175: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14176: NOP4
14180: PUSH
14181: LD_INT 23
14183: PUSH
14184: LD_INT 24
14186: PUSH
14187: EMPTY
14188: LIST
14189: LIST
14190: ST_TO_ADDR
14191: GO 14194
14193: POP
// result := ( chassis in result ) ;
14194: NOP4
14198: PUSH
14199: NOP4
14203: PUSH
14204: NOP4
14208: IN
14209: ST_TO_ADDR
// end ;
14210: LD_VAR 0 3
14214: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
14215: LD_INT 0
14217: PPUSH
14218: PPUSH
14219: PPUSH
14220: PPUSH
14221: PPUSH
14222: PPUSH
14223: PPUSH
// result := array ;
14224: NOP4
14228: PUSH
14229: NOP4
14233: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
14234: NOP4
14238: NOT
14239: PUSH
14240: NOP4
14244: NOT
14245: OR
14246: PUSH
14247: NOP4
14251: NOT
14252: OR
14253: PUSH
14254: NOP4
14258: PUSH
14259: NOP4
14263: GREATER
14264: OR
14265: PUSH
14266: NOP4
14270: PUSH
14271: NOP4
14275: GREATER
14276: OR
14277: IFFALSE 14281
// exit ;
14279: GO 14577
// if direction then
14281: NOP4
14285: IFFALSE 14349
// begin d := 1 ;
14287: NOP4
14291: PUSH
14292: LD_INT 1
14294: ST_TO_ADDR
// if i_from > i_to then
14295: NOP4
14299: PUSH
14300: NOP4
14304: GREATER
14305: IFFALSE 14331
// length := ( array - i_from ) + i_to else
14307: NOP4
14311: PUSH
14312: NOP4
14316: PUSH
14317: NOP4
14321: MINUS
14322: PUSH
14323: NOP4
14327: PLUS
14328: ST_TO_ADDR
14329: GO 14347
// length := i_to - i_from ;
14331: NOP4
14335: PUSH
14336: NOP4
14340: PUSH
14341: NOP4
14345: MINUS
14346: ST_TO_ADDR
// end else
14347: GO 14410
// begin d := - 1 ;
14349: NOP4
14353: PUSH
14354: LD_INT 1
14356: NEG
14357: ST_TO_ADDR
// if i_from > i_to then
14358: NOP4
14362: PUSH
14363: NOP4
14367: GREATER
14368: IFFALSE 14388
// length := i_from - i_to else
14370: NOP4
14374: PUSH
14375: NOP4
14379: PUSH
14380: NOP4
14384: MINUS
14385: ST_TO_ADDR
14386: GO 14410
// length := ( array - i_to ) + i_from ;
14388: NOP4
14392: PUSH
14393: NOP4
14397: PUSH
14398: NOP4
14402: MINUS
14403: PUSH
14404: NOP4
14408: PLUS
14409: ST_TO_ADDR
// end ; if not length then
14410: NOP4
14414: NOT
14415: IFFALSE 14419
// exit ;
14417: GO 14577
// tmp := array ;
14419: NOP4
14423: PUSH
14424: NOP4
14428: ST_TO_ADDR
// for i = 1 to length do
14429: NOP4
14433: PUSH
14434: DOUBLE
14435: LD_INT 1
14437: DEC
14438: ST_TO_ADDR
14439: NOP4
14443: PUSH
14444: FOR_TO
14445: IFFALSE 14565
// begin for j = 1 to array do
14447: NOP4
14451: PUSH
14452: DOUBLE
14453: LD_INT 1
14455: DEC
14456: ST_TO_ADDR
14457: NOP4
14461: PUSH
14462: FOR_TO
14463: IFFALSE 14551
// begin k := j + d ;
14465: NOP4
14469: PUSH
14470: NOP4
14474: PUSH
14475: NOP4
14479: PLUS
14480: ST_TO_ADDR
// if k > array then
14481: NOP4
14485: PUSH
14486: NOP4
14490: GREATER
14491: IFFALSE 14501
// k := 1 ;
14493: NOP4
14497: PUSH
14498: LD_INT 1
14500: ST_TO_ADDR
// if not k then
14501: NOP4
14505: NOT
14506: IFFALSE 14518
// k := array ;
14508: NOP4
14512: PUSH
14513: NOP4
14517: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
14518: NOP4
14522: PUSH
14523: NOP4
14527: PPUSH
14528: NOP4
14532: PPUSH
14533: NOP4
14537: PUSH
14538: NOP4
14542: ARRAY
14543: PPUSH
14544: NOP4
14548: ST_TO_ADDR
// end ;
14549: GO 14462
14551: POP
14552: POP
// array := tmp ;
14553: NOP4
14557: PUSH
14558: NOP4
14562: ST_TO_ADDR
// end ;
14563: GO 14444
14565: POP
14566: POP
// result := array ;
14567: NOP4
14571: PUSH
14572: NOP4
14576: ST_TO_ADDR
// end ;
14577: LD_VAR 0 5
14581: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
14582: LD_INT 0
14584: PPUSH
14585: PPUSH
// result := 0 ;
14586: NOP4
14590: PUSH
14591: LD_INT 0
14593: ST_TO_ADDR
// if not array or not value in array then
14594: NOP4
14598: NOT
14599: PUSH
14600: NOP4
14604: PUSH
14605: NOP4
14609: IN
14610: NOT
14611: OR
14612: IFFALSE 14616
// exit ;
14614: GO 14670
// for i = 1 to array do
14616: NOP4
14620: PUSH
14621: DOUBLE
14622: LD_INT 1
14624: DEC
14625: ST_TO_ADDR
14626: NOP4
14630: PUSH
14631: FOR_TO
14632: IFFALSE 14668
// if value = array [ i ] then
14634: NOP4
14638: PUSH
14639: NOP4
14643: PUSH
14644: NOP4
14648: ARRAY
14649: EQUAL
14650: IFFALSE 14666
// begin result := i ;
14652: NOP4
14656: PUSH
14657: NOP4
14661: ST_TO_ADDR
// exit ;
14662: POP
14663: POP
14664: GO 14670
// end ;
14666: GO 14631
14668: POP
14669: POP
// end ;
14670: LD_VAR 0 3
14674: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
14675: LD_INT 0
14677: PPUSH
// vc_chassis := chassis ;
14678: LD_ADDR_OWVAR 37
14682: PUSH
14683: NOP4
14687: ST_TO_ADDR
// vc_engine := engine ;
14688: LD_ADDR_OWVAR 39
14692: PUSH
14693: NOP4
14697: ST_TO_ADDR
// vc_control := control ;
14698: LD_ADDR_OWVAR 38
14702: PUSH
14703: NOP4
14707: ST_TO_ADDR
// vc_weapon := weapon ;
14708: LD_ADDR_OWVAR 40
14712: PUSH
14713: NOP4
14717: ST_TO_ADDR
// vc_fuel_battery := fuel ;
14718: LD_ADDR_OWVAR 41
14722: PUSH
14723: NOP4
14727: ST_TO_ADDR
// end ;
14728: LD_VAR 0 6
14732: RET
// export function WantPlant ( unit ) ; var task ; begin
14733: LD_INT 0
14735: PPUSH
14736: PPUSH
// result := false ;
14737: NOP4
14741: PUSH
14742: LD_INT 0
14744: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14745: NOP4
14749: PUSH
14750: NOP4
14754: PPUSH
14755: NOP4
14759: ST_TO_ADDR
// if task then
14760: NOP4
14764: IFFALSE 14792
// if task [ 1 ] [ 1 ] = p then
14766: NOP4
14770: PUSH
14771: LD_INT 1
14773: ARRAY
14774: PUSH
14775: LD_INT 1
14777: ARRAY
14778: PUSH
14779: LD_STRING p
14781: EQUAL
14782: IFFALSE 14792
// result := true ;
14784: NOP4
14788: PUSH
14789: LD_INT 1
14791: ST_TO_ADDR
// end ;
14792: LD_VAR 0 2
14796: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14797: LD_INT 0
14799: PPUSH
14800: PPUSH
14801: PPUSH
14802: PPUSH
// if pos < 1 then
14803: NOP4
14807: PUSH
14808: LD_INT 1
14810: LESS
14811: IFFALSE 14815
// exit ;
14813: GO 15118
// if pos = 1 then
14815: NOP4
14819: PUSH
14820: LD_INT 1
14822: EQUAL
14823: IFFALSE 14856
// result := Replace ( arr , pos [ 1 ] , value ) else
14825: NOP4
14829: PUSH
14830: NOP4
14834: PPUSH
14835: NOP4
14839: PUSH
14840: LD_INT 1
14842: ARRAY
14843: PPUSH
14844: NOP4
14848: PPUSH
14849: NOP4
14853: ST_TO_ADDR
14854: GO 15118
// begin tmp := arr ;
14856: NOP4
14860: PUSH
14861: NOP4
14865: ST_TO_ADDR
// s_arr := [ tmp ] ;
14866: NOP4
14870: PUSH
14871: NOP4
14875: PUSH
14876: EMPTY
14877: LIST
14878: ST_TO_ADDR
// for i = 1 to pos - 1 do
14879: NOP4
14883: PUSH
14884: DOUBLE
14885: LD_INT 1
14887: DEC
14888: ST_TO_ADDR
14889: NOP4
14893: PUSH
14894: LD_INT 1
14896: MINUS
14897: PUSH
14898: FOR_TO
14899: IFFALSE 14944
// begin tmp := tmp [ pos [ i ] ] ;
14901: NOP4
14905: PUSH
14906: NOP4
14910: PUSH
14911: NOP4
14915: PUSH
14916: NOP4
14920: ARRAY
14921: ARRAY
14922: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14923: NOP4
14927: PUSH
14928: NOP4
14932: PUSH
14933: NOP4
14937: PUSH
14938: EMPTY
14939: LIST
14940: ADD
14941: ST_TO_ADDR
// end ;
14942: GO 14898
14944: POP
14945: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14946: NOP4
14950: PUSH
14951: NOP4
14955: PPUSH
14956: NOP4
14960: PUSH
14961: NOP4
14965: ARRAY
14966: PPUSH
14967: NOP4
14971: PPUSH
14972: NOP4
14976: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14977: NOP4
14981: PUSH
14982: NOP4
14986: PPUSH
14987: NOP4
14991: PPUSH
14992: NOP4
14996: PPUSH
14997: NOP4
15001: ST_TO_ADDR
// for i = s_arr downto 2 do
15002: NOP4
15006: PUSH
15007: DOUBLE
15008: NOP4
15012: INC
15013: ST_TO_ADDR
15014: LD_INT 2
15016: PUSH
15017: FOR_DOWNTO
15018: IFFALSE 15102
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15020: NOP4
15024: PUSH
15025: NOP4
15029: PUSH
15030: NOP4
15034: PUSH
15035: LD_INT 1
15037: MINUS
15038: ARRAY
15039: PPUSH
15040: NOP4
15044: PUSH
15045: NOP4
15049: PUSH
15050: LD_INT 1
15052: MINUS
15053: ARRAY
15054: PPUSH
15055: NOP4
15059: PUSH
15060: NOP4
15064: ARRAY
15065: PPUSH
15066: NOP4
15070: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15071: NOP4
15075: PUSH
15076: NOP4
15080: PPUSH
15081: NOP4
15085: PUSH
15086: LD_INT 1
15088: MINUS
15089: PPUSH
15090: NOP4
15094: PPUSH
15095: NOP4
15099: ST_TO_ADDR
// end ;
15100: GO 15017
15102: POP
15103: POP
// result := s_arr [ 1 ] ;
15104: NOP4
15108: PUSH
15109: NOP4
15113: PUSH
15114: LD_INT 1
15116: ARRAY
15117: ST_TO_ADDR
// end ; end ;
15118: LD_VAR 0 4
15122: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
15123: LD_INT 0
15125: PPUSH
15126: PPUSH
// if not list then
15127: NOP4
15131: NOT
15132: IFFALSE 15136
// exit ;
15134: GO 15227
// i := list [ pos1 ] ;
15136: NOP4
15140: PUSH
15141: NOP4
15145: PUSH
15146: NOP4
15150: ARRAY
15151: ST_TO_ADDR
// if not i then
15152: NOP4
15156: NOT
15157: IFFALSE 15161
// exit ;
15159: GO 15227
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
15161: NOP4
15165: PUSH
15166: NOP4
15170: PPUSH
15171: NOP4
15175: PPUSH
15176: NOP4
15180: PUSH
15181: NOP4
15185: ARRAY
15186: PPUSH
15187: NOP4
15191: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
15192: NOP4
15196: PUSH
15197: NOP4
15201: PPUSH
15202: NOP4
15206: PPUSH
15207: NOP4
15211: PPUSH
15212: NOP4
15216: ST_TO_ADDR
// result := list ;
15217: NOP4
15221: PUSH
15222: NOP4
15226: ST_TO_ADDR
// end ;
15227: LD_VAR 0 4
15231: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
15232: LD_INT 0
15234: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
15235: NOP4
15239: PUSH
15240: NOP4
15244: PPUSH
15245: NOP4
15249: PPUSH
15250: NOP4
15254: PPUSH
15255: NOP4
15259: PPUSH
15260: NOP4
15264: PPUSH
15265: NOP4
15269: PPUSH
15270: NOP4
15274: PPUSH
15275: NOP4
15279: ST_TO_ADDR
// end ;
15280: LD_VAR 0 5
15284: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
15285: LD_INT 0
15287: PPUSH
15288: PPUSH
15289: PPUSH
15290: PPUSH
// if not list then
15291: NOP4
15295: NOT
15296: IFFALSE 15300
// exit ;
15298: GO 15688
// result := [ ] ;
15300: NOP4
15304: PUSH
15305: EMPTY
15306: ST_TO_ADDR
// for i in list do
15307: NOP4
15311: PUSH
15312: NOP4
15316: PUSH
15317: FOR_IN
15318: IFFALSE 15520
// begin tmp := GetDistUnitXY ( i , x , y ) ;
15320: NOP4
15324: PUSH
15325: NOP4
15329: PPUSH
15330: NOP4
15334: PPUSH
15335: NOP4
15339: PPUSH
15340: NOP4
15344: ST_TO_ADDR
// if not result then
15345: NOP4
15349: NOT
15350: IFFALSE 15376
// result := [ [ i , tmp ] ] else
15352: NOP4
15356: PUSH
15357: NOP4
15361: PUSH
15362: NOP4
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: ST_TO_ADDR
15374: GO 15518
// begin if result [ result ] [ 2 ] < tmp then
15376: NOP4
15380: PUSH
15381: NOP4
15385: ARRAY
15386: PUSH
15387: LD_INT 2
15389: ARRAY
15390: PUSH
15391: NOP4
15395: LESS
15396: IFFALSE 15438
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
15398: NOP4
15402: PUSH
15403: NOP4
15407: PPUSH
15408: NOP4
15412: PUSH
15413: LD_INT 1
15415: PLUS
15416: PPUSH
15417: NOP4
15421: PUSH
15422: NOP4
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PPUSH
15431: NOP4
15435: ST_TO_ADDR
15436: GO 15518
// for j = 1 to result do
15438: NOP4
15442: PUSH
15443: DOUBLE
15444: LD_INT 1
15446: DEC
15447: ST_TO_ADDR
15448: NOP4
15452: PUSH
15453: FOR_TO
15454: IFFALSE 15516
// begin if tmp < result [ j ] [ 2 ] then
15456: NOP4
15460: PUSH
15461: NOP4
15465: PUSH
15466: NOP4
15470: ARRAY
15471: PUSH
15472: LD_INT 2
15474: ARRAY
15475: LESS
15476: IFFALSE 15514
// begin result := Insert ( result , j , [ i , tmp ] ) ;
15478: NOP4
15482: PUSH
15483: NOP4
15487: PPUSH
15488: NOP4
15492: PPUSH
15493: NOP4
15497: PUSH
15498: NOP4
15502: PUSH
15503: EMPTY
15504: LIST
15505: LIST
15506: PPUSH
15507: NOP4
15511: ST_TO_ADDR
// break ;
15512: GO 15516
// end ; end ;
15514: GO 15453
15516: POP
15517: POP
// end ; end ;
15518: GO 15317
15520: POP
15521: POP
// if result and not asc then
15522: NOP4
15526: PUSH
15527: NOP4
15531: NOT
15532: AND
15533: IFFALSE 15608
// begin tmp := result ;
15535: NOP4
15539: PUSH
15540: NOP4
15544: ST_TO_ADDR
// for i = tmp downto 1 do
15545: NOP4
15549: PUSH
15550: DOUBLE
15551: NOP4
15555: INC
15556: ST_TO_ADDR
15557: LD_INT 1
15559: PUSH
15560: FOR_DOWNTO
15561: IFFALSE 15606
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
15563: NOP4
15567: PUSH
15568: NOP4
15572: PPUSH
15573: NOP4
15577: PUSH
15578: NOP4
15582: MINUS
15583: PUSH
15584: LD_INT 1
15586: PLUS
15587: PPUSH
15588: NOP4
15592: PUSH
15593: NOP4
15597: ARRAY
15598: PPUSH
15599: NOP4
15603: ST_TO_ADDR
15604: GO 15560
15606: POP
15607: POP
// end ; tmp := [ ] ;
15608: NOP4
15612: PUSH
15613: EMPTY
15614: ST_TO_ADDR
// if mode then
15615: NOP4
15619: IFFALSE 15688
// begin for i = 1 to result do
15621: NOP4
15625: PUSH
15626: DOUBLE
15627: LD_INT 1
15629: DEC
15630: ST_TO_ADDR
15631: NOP4
15635: PUSH
15636: FOR_TO
15637: IFFALSE 15676
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
15639: NOP4
15643: PUSH
15644: NOP4
15648: PPUSH
15649: NOP4
15653: PPUSH
15654: NOP4
15658: PUSH
15659: NOP4
15663: ARRAY
15664: PUSH
15665: LD_INT 1
15667: ARRAY
15668: PPUSH
15669: NOP4
15673: ST_TO_ADDR
15674: GO 15636
15676: POP
15677: POP
// result := tmp ;
15678: NOP4
15682: PUSH
15683: NOP4
15687: ST_TO_ADDR
// end ; end ;
15688: LD_VAR 0 6
15692: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
15693: LD_INT 0
15695: PPUSH
15696: PPUSH
15697: PPUSH
15698: PPUSH
15699: PPUSH
15700: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
15701: NOP4
15705: PUSH
15706: LD_INT 0
15708: PUSH
15709: LD_INT 0
15711: PUSH
15712: LD_INT 0
15714: PUSH
15715: EMPTY
15716: PUSH
15717: EMPTY
15718: LIST
15719: LIST
15720: LIST
15721: LIST
15722: ST_TO_ADDR
// if not x or not y then
15723: NOP4
15727: NOT
15728: PUSH
15729: NOP4
15733: NOT
15734: OR
15735: IFFALSE 15739
// exit ;
15737: GO 17385
// if not range then
15739: NOP4
15743: NOT
15744: IFFALSE 15754
// range := 10 ;
15746: NOP4
15750: PUSH
15751: LD_INT 10
15753: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15754: NOP4
15758: PUSH
15759: LD_INT 81
15761: PUSH
15762: NOP4
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: PUSH
15771: LD_INT 92
15773: PUSH
15774: NOP4
15778: PUSH
15779: NOP4
15783: PUSH
15784: NOP4
15788: PUSH
15789: EMPTY
15790: LIST
15791: LIST
15792: LIST
15793: LIST
15794: PUSH
15795: LD_INT 3
15797: PUSH
15798: LD_INT 21
15800: PUSH
15801: LD_INT 3
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: PUSH
15808: EMPTY
15809: LIST
15810: LIST
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: LIST
15816: PPUSH
15817: NOP4
15821: ST_TO_ADDR
// if not tmp then
15822: NOP4
15826: NOT
15827: IFFALSE 15831
// exit ;
15829: GO 17385
// for i in tmp do
15831: NOP4
15835: PUSH
15836: NOP4
15840: PUSH
15841: FOR_IN
15842: IFFALSE 17360
// begin points := [ 0 , 0 , 0 ] ;
15844: NOP4
15848: PUSH
15849: LD_INT 0
15851: PUSH
15852: LD_INT 0
15854: PUSH
15855: LD_INT 0
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: LIST
15862: ST_TO_ADDR
// bpoints := 1 ;
15863: NOP4
15867: PUSH
15868: LD_INT 1
15870: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15871: NOP4
15875: PPUSH
15876: NOP4
15880: PUSH
15881: LD_INT 1
15883: DOUBLE
15884: EQUAL
15885: IFTRUE 15889
15887: GO 16467
15889: POP
// begin if GetClass ( i ) = 1 then
15890: NOP4
15894: PPUSH
15895: NOP4
15899: PUSH
15900: LD_INT 1
15902: EQUAL
15903: IFFALSE 15924
// points := [ 10 , 5 , 3 ] ;
15905: NOP4
15909: PUSH
15910: LD_INT 10
15912: PUSH
15913: LD_INT 5
15915: PUSH
15916: LD_INT 3
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: LIST
15923: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15924: NOP4
15928: PPUSH
15929: NOP4
15933: PUSH
15934: LD_INT 2
15936: PUSH
15937: LD_INT 3
15939: PUSH
15940: LD_INT 4
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: LIST
15947: IN
15948: IFFALSE 15969
// points := [ 3 , 2 , 1 ] ;
15950: NOP4
15954: PUSH
15955: LD_INT 3
15957: PUSH
15958: LD_INT 2
15960: PUSH
15961: LD_INT 1
15963: PUSH
15964: EMPTY
15965: LIST
15966: LIST
15967: LIST
15968: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15969: NOP4
15973: PPUSH
15974: NOP4
15978: PUSH
15979: LD_INT 5
15981: EQUAL
15982: IFFALSE 16003
// points := [ 130 , 5 , 2 ] ;
15984: NOP4
15988: PUSH
15989: LD_INT 130
15991: PUSH
15992: LD_INT 5
15994: PUSH
15995: LD_INT 2
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: LIST
16002: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16003: NOP4
16007: PPUSH
16008: NOP4
16012: PUSH
16013: LD_INT 8
16015: EQUAL
16016: IFFALSE 16037
// points := [ 35 , 35 , 30 ] ;
16018: NOP4
16022: PUSH
16023: LD_INT 35
16025: PUSH
16026: LD_INT 35
16028: PUSH
16029: LD_INT 30
16031: PUSH
16032: EMPTY
16033: LIST
16034: LIST
16035: LIST
16036: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16037: NOP4
16041: PPUSH
16042: NOP4
16046: PUSH
16047: LD_INT 9
16049: EQUAL
16050: IFFALSE 16071
// points := [ 20 , 55 , 40 ] ;
16052: NOP4
16056: PUSH
16057: LD_INT 20
16059: PUSH
16060: LD_INT 55
16062: PUSH
16063: LD_INT 40
16065: PUSH
16066: EMPTY
16067: LIST
16068: LIST
16069: LIST
16070: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16071: NOP4
16075: PPUSH
16076: NOP4
16080: PUSH
16081: LD_INT 12
16083: PUSH
16084: LD_INT 16
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: IN
16091: IFFALSE 16112
// points := [ 5 , 3 , 2 ] ;
16093: NOP4
16097: PUSH
16098: LD_INT 5
16100: PUSH
16101: LD_INT 3
16103: PUSH
16104: LD_INT 2
16106: PUSH
16107: EMPTY
16108: LIST
16109: LIST
16110: LIST
16111: ST_TO_ADDR
// if GetClass ( i ) = 17 then
16112: NOP4
16116: PPUSH
16117: NOP4
16121: PUSH
16122: LD_INT 17
16124: EQUAL
16125: IFFALSE 16146
// points := [ 100 , 50 , 75 ] ;
16127: NOP4
16131: PUSH
16132: LD_INT 100
16134: PUSH
16135: LD_INT 50
16137: PUSH
16138: LD_INT 75
16140: PUSH
16141: EMPTY
16142: LIST
16143: LIST
16144: LIST
16145: ST_TO_ADDR
// if GetClass ( i ) = 15 then
16146: NOP4
16150: PPUSH
16151: NOP4
16155: PUSH
16156: LD_INT 15
16158: EQUAL
16159: IFFALSE 16180
// points := [ 10 , 5 , 3 ] ;
16161: NOP4
16165: PUSH
16166: LD_INT 10
16168: PUSH
16169: LD_INT 5
16171: PUSH
16172: LD_INT 3
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: LIST
16179: ST_TO_ADDR
// if GetClass ( i ) = 14 then
16180: NOP4
16184: PPUSH
16185: NOP4
16189: PUSH
16190: LD_INT 14
16192: EQUAL
16193: IFFALSE 16214
// points := [ 10 , 0 , 0 ] ;
16195: NOP4
16199: PUSH
16200: LD_INT 10
16202: PUSH
16203: LD_INT 0
16205: PUSH
16206: LD_INT 0
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: LIST
16213: ST_TO_ADDR
// if GetClass ( i ) = 11 then
16214: NOP4
16218: PPUSH
16219: NOP4
16223: PUSH
16224: LD_INT 11
16226: EQUAL
16227: IFFALSE 16248
// points := [ 30 , 10 , 5 ] ;
16229: NOP4
16233: PUSH
16234: LD_INT 30
16236: PUSH
16237: LD_INT 10
16239: PUSH
16240: LD_INT 5
16242: PUSH
16243: EMPTY
16244: LIST
16245: LIST
16246: LIST
16247: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
16248: NOP4
16252: PPUSH
16253: LD_INT 5
16255: PPUSH
16256: NOP4
16260: PUSH
16261: LD_INT 2
16263: EQUAL
16264: IFFALSE 16281
// bpoints := bpoints * 1.8 ;
16266: NOP4
16270: PUSH
16271: NOP4
16275: PUSH
16276: LD_REAL  1.80000000000000E+0000
16279: MUL
16280: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
16281: NOP4
16285: PPUSH
16286: NOP4
16290: PUSH
16291: LD_INT 1
16293: PUSH
16294: LD_INT 2
16296: PUSH
16297: LD_INT 3
16299: PUSH
16300: LD_INT 4
16302: PUSH
16303: EMPTY
16304: LIST
16305: LIST
16306: LIST
16307: LIST
16308: IN
16309: PUSH
16310: NOP4
16314: PPUSH
16315: LD_INT 51
16317: PPUSH
16318: NOP4
16322: PUSH
16323: LD_INT 2
16325: EQUAL
16326: AND
16327: IFFALSE 16344
// bpoints := bpoints * 1.2 ;
16329: NOP4
16333: PUSH
16334: NOP4
16338: PUSH
16339: LD_REAL  1.20000000000000E+0000
16342: MUL
16343: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
16344: NOP4
16348: PPUSH
16349: NOP4
16353: PUSH
16354: LD_INT 5
16356: PUSH
16357: LD_INT 7
16359: PUSH
16360: LD_INT 9
16362: PUSH
16363: EMPTY
16364: LIST
16365: LIST
16366: LIST
16367: IN
16368: PUSH
16369: NOP4
16373: PPUSH
16374: LD_INT 52
16376: PPUSH
16377: NOP4
16381: PUSH
16382: LD_INT 2
16384: EQUAL
16385: AND
16386: IFFALSE 16403
// bpoints := bpoints * 1.5 ;
16388: NOP4
16392: PUSH
16393: NOP4
16397: PUSH
16398: LD_REAL  1.50000000000000E+0000
16401: MUL
16402: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
16403: NOP4
16407: PPUSH
16408: LD_INT 66
16410: PPUSH
16411: NOP4
16415: PUSH
16416: LD_INT 2
16418: EQUAL
16419: IFFALSE 16436
// bpoints := bpoints * 1.1 ;
16421: NOP4
16425: PUSH
16426: NOP4
16430: PUSH
16431: LD_REAL  1.10000000000000E+0000
16434: MUL
16435: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
16436: NOP4
16440: PUSH
16441: NOP4
16445: PUSH
16446: NOP4
16450: PPUSH
16451: LD_INT 1
16453: PPUSH
16454: NOP4
16458: PUSH
16459: LD_REAL  1.15000000000000E+0000
16462: MUL
16463: MUL
16464: ST_TO_ADDR
// end ; unit_vehicle :
16465: GO 17289
16467: LD_INT 2
16469: DOUBLE
16470: EQUAL
16471: IFTRUE 16475
16473: GO 17277
16475: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
16476: NOP4
16480: PPUSH
16481: NOP4
16485: PUSH
16486: LD_INT 2
16488: PUSH
16489: LD_INT 42
16491: PUSH
16492: LD_INT 24
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: LIST
16499: IN
16500: IFFALSE 16521
// points := [ 25 , 5 , 3 ] ;
16502: NOP4
16506: PUSH
16507: LD_INT 25
16509: PUSH
16510: LD_INT 5
16512: PUSH
16513: LD_INT 3
16515: PUSH
16516: EMPTY
16517: LIST
16518: LIST
16519: LIST
16520: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
16521: NOP4
16525: PPUSH
16526: NOP4
16530: PUSH
16531: LD_INT 4
16533: PUSH
16534: LD_INT 43
16536: PUSH
16537: LD_INT 25
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: LIST
16544: IN
16545: IFFALSE 16566
// points := [ 40 , 15 , 5 ] ;
16547: NOP4
16551: PUSH
16552: LD_INT 40
16554: PUSH
16555: LD_INT 15
16557: PUSH
16558: LD_INT 5
16560: PUSH
16561: EMPTY
16562: LIST
16563: LIST
16564: LIST
16565: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
16566: NOP4
16570: PPUSH
16571: NOP4
16575: PUSH
16576: LD_INT 3
16578: PUSH
16579: LD_INT 23
16581: PUSH
16582: EMPTY
16583: LIST
16584: LIST
16585: IN
16586: IFFALSE 16607
// points := [ 7 , 25 , 8 ] ;
16588: NOP4
16592: PUSH
16593: LD_INT 7
16595: PUSH
16596: LD_INT 25
16598: PUSH
16599: LD_INT 8
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: LIST
16606: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
16607: NOP4
16611: PPUSH
16612: NOP4
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: LD_INT 27
16622: PUSH
16623: LD_INT 44
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: LIST
16630: IN
16631: IFFALSE 16652
// points := [ 14 , 50 , 16 ] ;
16633: NOP4
16637: PUSH
16638: LD_INT 14
16640: PUSH
16641: LD_INT 50
16643: PUSH
16644: LD_INT 16
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: LIST
16651: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
16652: NOP4
16656: PPUSH
16657: NOP4
16661: PUSH
16662: LD_INT 6
16664: PUSH
16665: LD_INT 46
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: IN
16672: IFFALSE 16693
// points := [ 32 , 120 , 70 ] ;
16674: NOP4
16678: PUSH
16679: LD_INT 32
16681: PUSH
16682: LD_INT 120
16684: PUSH
16685: LD_INT 70
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: LIST
16692: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
16693: NOP4
16697: PPUSH
16698: NOP4
16702: PUSH
16703: LD_INT 7
16705: PUSH
16706: LD_INT 28
16708: PUSH
16709: LD_INT 45
16711: PUSH
16712: EMPTY
16713: LIST
16714: LIST
16715: LIST
16716: IN
16717: IFFALSE 16738
// points := [ 35 , 20 , 45 ] ;
16719: NOP4
16723: PUSH
16724: LD_INT 35
16726: PUSH
16727: LD_INT 20
16729: PUSH
16730: LD_INT 45
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: LIST
16737: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16738: NOP4
16742: PPUSH
16743: NOP4
16747: PUSH
16748: LD_INT 47
16750: PUSH
16751: EMPTY
16752: LIST
16753: IN
16754: IFFALSE 16775
// points := [ 67 , 45 , 75 ] ;
16756: NOP4
16760: PUSH
16761: LD_INT 67
16763: PUSH
16764: LD_INT 45
16766: PUSH
16767: LD_INT 75
16769: PUSH
16770: EMPTY
16771: LIST
16772: LIST
16773: LIST
16774: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16775: NOP4
16779: PPUSH
16780: NOP4
16784: PUSH
16785: LD_INT 26
16787: PUSH
16788: EMPTY
16789: LIST
16790: IN
16791: IFFALSE 16812
// points := [ 120 , 30 , 80 ] ;
16793: NOP4
16797: PUSH
16798: LD_INT 120
16800: PUSH
16801: LD_INT 30
16803: PUSH
16804: LD_INT 80
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16812: NOP4
16816: PPUSH
16817: NOP4
16821: PUSH
16822: LD_INT 22
16824: PUSH
16825: EMPTY
16826: LIST
16827: IN
16828: IFFALSE 16849
// points := [ 40 , 1 , 1 ] ;
16830: NOP4
16834: PUSH
16835: LD_INT 40
16837: PUSH
16838: LD_INT 1
16840: PUSH
16841: LD_INT 1
16843: PUSH
16844: EMPTY
16845: LIST
16846: LIST
16847: LIST
16848: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16849: NOP4
16853: PPUSH
16854: NOP4
16858: PUSH
16859: LD_INT 29
16861: PUSH
16862: EMPTY
16863: LIST
16864: IN
16865: IFFALSE 16886
// points := [ 70 , 200 , 400 ] ;
16867: NOP4
16871: PUSH
16872: LD_INT 70
16874: PUSH
16875: LD_INT 200
16877: PUSH
16878: LD_INT 400
16880: PUSH
16881: EMPTY
16882: LIST
16883: LIST
16884: LIST
16885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16886: NOP4
16890: PPUSH
16891: NOP4
16895: PUSH
16896: LD_INT 14
16898: PUSH
16899: LD_INT 53
16901: PUSH
16902: EMPTY
16903: LIST
16904: LIST
16905: IN
16906: IFFALSE 16927
// points := [ 40 , 10 , 20 ] ;
16908: NOP4
16912: PUSH
16913: LD_INT 40
16915: PUSH
16916: LD_INT 10
16918: PUSH
16919: LD_INT 20
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: LIST
16926: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16927: NOP4
16931: PPUSH
16932: NOP4
16936: PUSH
16937: LD_INT 9
16939: PUSH
16940: EMPTY
16941: LIST
16942: IN
16943: IFFALSE 16964
// points := [ 5 , 70 , 20 ] ;
16945: NOP4
16949: PUSH
16950: LD_INT 5
16952: PUSH
16953: LD_INT 70
16955: PUSH
16956: LD_INT 20
16958: PUSH
16959: EMPTY
16960: LIST
16961: LIST
16962: LIST
16963: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16964: NOP4
16968: PPUSH
16969: NOP4
16973: PUSH
16974: LD_INT 10
16976: PUSH
16977: EMPTY
16978: LIST
16979: IN
16980: IFFALSE 17001
// points := [ 35 , 110 , 70 ] ;
16982: NOP4
16986: PUSH
16987: LD_INT 35
16989: PUSH
16990: LD_INT 110
16992: PUSH
16993: LD_INT 70
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: LIST
17000: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17001: NOP4
17005: PPUSH
17006: NOP4
17010: PUSH
17011: LD_INT 25
17013: EQUAL
17014: IFFALSE 17035
// points := [ 80 , 65 , 100 ] ;
17016: NOP4
17020: PUSH
17021: LD_INT 80
17023: PUSH
17024: LD_INT 65
17026: PUSH
17027: LD_INT 100
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17035: NOP4
17039: PPUSH
17040: NOP4
17044: PUSH
17045: LD_INT 1
17047: EQUAL
17048: IFFALSE 17083
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17050: NOP4
17054: PUSH
17055: NOP4
17059: PUSH
17060: NOP4
17064: PPUSH
17065: NOP4
17069: PPUSH
17070: LD_INT 3
17072: PPUSH
17073: NOP4
17077: PUSH
17078: LD_INT 4
17080: MUL
17081: MUL
17082: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17083: NOP4
17087: PPUSH
17088: NOP4
17092: PUSH
17093: LD_INT 2
17095: EQUAL
17096: IFFALSE 17147
// begin j := IsControledBy ( i ) ;
17098: NOP4
17102: PUSH
17103: NOP4
17107: PPUSH
17108: NOP4
17112: ST_TO_ADDR
// if j then
17113: NOP4
17117: IFFALSE 17147
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
17119: NOP4
17123: PUSH
17124: NOP4
17128: PUSH
17129: NOP4
17133: PPUSH
17134: LD_INT 3
17136: PPUSH
17137: NOP4
17141: PUSH
17142: LD_INT 3
17144: MUL
17145: MUL
17146: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
17147: NOP4
17151: PPUSH
17152: NOP4
17156: PUSH
17157: LD_INT 5
17159: PUSH
17160: LD_INT 6
17162: PUSH
17163: LD_INT 46
17165: PUSH
17166: LD_INT 44
17168: PUSH
17169: LD_INT 47
17171: PUSH
17172: LD_INT 45
17174: PUSH
17175: LD_INT 28
17177: PUSH
17178: LD_INT 7
17180: PUSH
17181: LD_INT 27
17183: PUSH
17184: LD_INT 29
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: LIST
17191: LIST
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: LIST
17197: LIST
17198: IN
17199: PUSH
17200: NOP4
17204: PPUSH
17205: LD_INT 52
17207: PPUSH
17208: NOP4
17212: PUSH
17213: LD_INT 2
17215: EQUAL
17216: AND
17217: IFFALSE 17234
// bpoints := bpoints * 1.2 ;
17219: NOP4
17223: PUSH
17224: NOP4
17228: PUSH
17229: LD_REAL  1.20000000000000E+0000
17232: MUL
17233: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
17234: NOP4
17238: PPUSH
17239: NOP4
17243: PUSH
17244: LD_INT 6
17246: PUSH
17247: LD_INT 46
17249: PUSH
17250: LD_INT 47
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: IN
17258: IFFALSE 17275
// bpoints := bpoints * 1.2 ;
17260: NOP4
17264: PUSH
17265: NOP4
17269: PUSH
17270: LD_REAL  1.20000000000000E+0000
17273: MUL
17274: ST_TO_ADDR
// end ; unit_building :
17275: GO 17289
17277: LD_INT 3
17279: DOUBLE
17280: EQUAL
17281: IFTRUE 17285
17283: GO 17288
17285: POP
// ; end ;
17286: GO 17289
17288: POP
// for j = 1 to 3 do
17289: NOP4
17293: PUSH
17294: DOUBLE
17295: LD_INT 1
17297: DEC
17298: ST_TO_ADDR
17299: LD_INT 3
17301: PUSH
17302: FOR_TO
17303: IFFALSE 17356
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
17305: NOP4
17309: PUSH
17310: NOP4
17314: PPUSH
17315: NOP4
17319: PPUSH
17320: NOP4
17324: PUSH
17325: NOP4
17329: ARRAY
17330: PUSH
17331: NOP4
17335: PUSH
17336: NOP4
17340: ARRAY
17341: PUSH
17342: NOP4
17346: MUL
17347: PLUS
17348: PPUSH
17349: NOP4
17353: ST_TO_ADDR
17354: GO 17302
17356: POP
17357: POP
// end ;
17358: GO 15841
17360: POP
17361: POP
// result := Replace ( result , 4 , tmp ) ;
17362: NOP4
17366: PUSH
17367: NOP4
17371: PPUSH
17372: LD_INT 4
17374: PPUSH
17375: NOP4
17379: PPUSH
17380: NOP4
17384: ST_TO_ADDR
// end ;
17385: LD_VAR 0 5
17389: RET
// export function DangerAtRange ( unit , range ) ; begin
17390: LD_INT 0
17392: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
17393: NOP4
17397: PUSH
17398: NOP4
17402: PPUSH
17403: NOP4
17407: PPUSH
17408: NOP4
17412: PPUSH
17413: NOP4
17417: PPUSH
17418: NOP4
17422: PPUSH
17423: NOP4
17427: PPUSH
17428: NOP4
17432: PPUSH
17433: NOP4
17437: ST_TO_ADDR
// end ;
17438: LD_VAR 0 3
17442: RET
// export function DangerInArea ( side , area ) ; begin
17443: LD_INT 0
17445: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
17446: NOP4
17450: PUSH
17451: NOP4
17455: PPUSH
17456: LD_INT 81
17458: PUSH
17459: NOP4
17463: PUSH
17464: EMPTY
17465: LIST
17466: LIST
17467: PPUSH
17468: NOP4
17472: ST_TO_ADDR
// end ;
17473: LD_VAR 0 3
17477: RET
// export function IsExtension ( b ) ; begin
17478: LD_INT 0
17480: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
17481: NOP4
17485: PUSH
17486: NOP4
17490: PUSH
17491: LD_INT 23
17493: PUSH
17494: LD_INT 20
17496: PUSH
17497: LD_INT 22
17499: PUSH
17500: LD_INT 17
17502: PUSH
17503: LD_INT 24
17505: PUSH
17506: LD_INT 21
17508: PUSH
17509: LD_INT 19
17511: PUSH
17512: LD_INT 16
17514: PUSH
17515: LD_INT 25
17517: PUSH
17518: LD_INT 18
17520: PUSH
17521: EMPTY
17522: LIST
17523: LIST
17524: LIST
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: LIST
17530: LIST
17531: LIST
17532: IN
17533: ST_TO_ADDR
// end ;
17534: LD_VAR 0 2
17538: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
17539: LD_INT 0
17541: PPUSH
17542: PPUSH
17543: PPUSH
// result := [ ] ;
17544: NOP4
17548: PUSH
17549: EMPTY
17550: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
17551: NOP4
17555: PUSH
17556: NOP4
17560: PPUSH
17561: LD_INT 21
17563: PUSH
17564: LD_INT 3
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: PPUSH
17571: NOP4
17575: ST_TO_ADDR
// if not tmp then
17576: NOP4
17580: NOT
17581: IFFALSE 17585
// exit ;
17583: GO 17649
// if checkLink then
17585: NOP4
17589: IFFALSE 17639
// begin for i in tmp do
17591: NOP4
17595: PUSH
17596: NOP4
17600: PUSH
17601: FOR_IN
17602: IFFALSE 17637
// if GetBase ( i ) <> base then
17604: NOP4
17608: PPUSH
17609: NOP4
17613: PUSH
17614: NOP4
17618: NONEQUAL
17619: IFFALSE 17635
// ComLinkToBase ( base , i ) ;
17621: NOP4
17625: PPUSH
17626: NOP4
17630: PPUSH
17631: NOP4
17635: GO 17601
17637: POP
17638: POP
// end ; result := tmp ;
17639: NOP4
17643: PUSH
17644: NOP4
17648: ST_TO_ADDR
// end ;
17649: LD_VAR 0 4
17653: RET
// export function ComComplete ( units , b ) ; var i ; begin
17654: LD_INT 0
17656: PPUSH
17657: PPUSH
// if not units then
17658: NOP4
17662: NOT
17663: IFFALSE 17667
// exit ;
17665: GO 17757
// for i in units do
17667: NOP4
17671: PUSH
17672: NOP4
17676: PUSH
17677: FOR_IN
17678: IFFALSE 17755
// if BuildingStatus ( b ) = bs_build then
17680: NOP4
17684: PPUSH
17685: NOP4
17689: PUSH
17690: LD_INT 1
17692: EQUAL
17693: IFFALSE 17753
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
17695: NOP4
17699: PPUSH
17700: LD_STRING h
17702: PUSH
17703: NOP4
17707: PPUSH
17708: NOP4
17712: PUSH
17713: NOP4
17717: PPUSH
17718: NOP4
17722: PUSH
17723: NOP4
17727: PUSH
17728: LD_INT 0
17730: PUSH
17731: LD_INT 0
17733: PUSH
17734: LD_INT 0
17736: PUSH
17737: EMPTY
17738: LIST
17739: LIST
17740: LIST
17741: LIST
17742: LIST
17743: LIST
17744: LIST
17745: PUSH
17746: EMPTY
17747: LIST
17748: PPUSH
17749: NOP4
17753: GO 17677
17755: POP
17756: POP
// end ;
17757: LD_VAR 0 3
17761: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17762: LD_INT 0
17764: PPUSH
17765: PPUSH
17766: PPUSH
17767: PPUSH
17768: PPUSH
17769: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17770: NOP4
17774: NOT
17775: PUSH
17776: NOP4
17780: PPUSH
17781: NOP4
17785: PUSH
17786: LD_INT 2
17788: EQUAL
17789: NOT
17790: OR
17791: IFFALSE 17795
// exit ;
17793: GO 18111
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17795: NOP4
17799: PUSH
17800: LD_INT 22
17802: PUSH
17803: NOP4
17807: PPUSH
17808: NOP4
17812: PUSH
17813: EMPTY
17814: LIST
17815: LIST
17816: PUSH
17817: LD_INT 2
17819: PUSH
17820: LD_INT 30
17822: PUSH
17823: LD_INT 36
17825: PUSH
17826: EMPTY
17827: LIST
17828: LIST
17829: PUSH
17830: LD_INT 34
17832: PUSH
17833: LD_INT 31
17835: PUSH
17836: EMPTY
17837: LIST
17838: LIST
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: LIST
17844: PUSH
17845: EMPTY
17846: LIST
17847: LIST
17848: PPUSH
17849: NOP4
17853: ST_TO_ADDR
// if not tmp then
17854: NOP4
17858: NOT
17859: IFFALSE 17863
// exit ;
17861: GO 18111
// result := [ ] ;
17863: NOP4
17867: PUSH
17868: EMPTY
17869: ST_TO_ADDR
// for i in tmp do
17870: NOP4
17874: PUSH
17875: NOP4
17879: PUSH
17880: FOR_IN
17881: IFFALSE 17952
// begin t := UnitsInside ( i ) ;
17883: NOP4
17887: PUSH
17888: NOP4
17892: PPUSH
17893: NOP4
17897: ST_TO_ADDR
// if t then
17898: NOP4
17902: IFFALSE 17950
// for j in t do
17904: NOP4
17908: PUSH
17909: NOP4
17913: PUSH
17914: FOR_IN
17915: IFFALSE 17948
// result := Insert ( result , result + 1 , j ) ;
17917: NOP4
17921: PUSH
17922: NOP4
17926: PPUSH
17927: NOP4
17931: PUSH
17932: LD_INT 1
17934: PLUS
17935: PPUSH
17936: NOP4
17940: PPUSH
17941: NOP4
17945: ST_TO_ADDR
17946: GO 17914
17948: POP
17949: POP
// end ;
17950: GO 17880
17952: POP
17953: POP
// if not result then
17954: NOP4
17958: NOT
17959: IFFALSE 17963
// exit ;
17961: GO 18111
// mech := result [ 1 ] ;
17963: NOP4
17967: PUSH
17968: NOP4
17972: PUSH
17973: LD_INT 1
17975: ARRAY
17976: ST_TO_ADDR
// if result > 1 then
17977: NOP4
17981: PUSH
17982: LD_INT 1
17984: GREATER
17985: IFFALSE 18097
// for i = 2 to result do
17987: NOP4
17991: PUSH
17992: DOUBLE
17993: LD_INT 2
17995: DEC
17996: ST_TO_ADDR
17997: NOP4
18001: PUSH
18002: FOR_TO
18003: IFFALSE 18095
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18005: NOP4
18009: PUSH
18010: NOP4
18014: PUSH
18015: NOP4
18019: ARRAY
18020: PPUSH
18021: LD_INT 3
18023: PPUSH
18024: NOP4
18028: PUSH
18029: NOP4
18033: PUSH
18034: NOP4
18038: ARRAY
18039: PPUSH
18040: NOP4
18044: MINUS
18045: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18046: NOP4
18050: PUSH
18051: NOP4
18055: PPUSH
18056: LD_INT 3
18058: PPUSH
18059: NOP4
18063: PUSH
18064: NOP4
18068: PPUSH
18069: NOP4
18073: MINUS
18074: GREATEREQUAL
18075: IFFALSE 18093
// mech := result [ i ] ;
18077: NOP4
18081: PUSH
18082: NOP4
18086: PUSH
18087: NOP4
18091: ARRAY
18092: ST_TO_ADDR
// end ;
18093: GO 18002
18095: POP
18096: POP
// ComLinkTo ( vehicle , mech ) ;
18097: NOP4
18101: PPUSH
18102: NOP4
18106: PPUSH
18107: NOP4
// end ;
18111: LD_VAR 0 2
18115: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
18116: LD_INT 0
18118: PPUSH
18119: PPUSH
18120: PPUSH
18121: PPUSH
18122: PPUSH
18123: PPUSH
18124: PPUSH
18125: PPUSH
18126: PPUSH
18127: PPUSH
18128: PPUSH
18129: PPUSH
18130: PPUSH
// result := [ ] ;
18131: NOP4
18135: PUSH
18136: EMPTY
18137: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
18138: NOP4
18142: PPUSH
18143: NOP4
18147: PUSH
18148: LD_INT 0
18150: PUSH
18151: LD_INT 1
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: IN
18158: NOT
18159: IFFALSE 18163
// exit ;
18161: GO 19797
// if name then
18163: NOP4
18167: IFFALSE 18183
// SetBName ( base_dep , name ) ;
18169: NOP4
18173: PPUSH
18174: NOP4
18178: PPUSH
18179: NOP4
// base := GetBase ( base_dep ) ;
18183: NOP4
18187: PUSH
18188: NOP4
18192: PPUSH
18193: NOP4
18197: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
18198: NOP4
18202: PUSH
18203: NOP4
18207: PPUSH
18208: NOP4
18212: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
18213: NOP4
18217: PUSH
18218: NOP4
18222: PPUSH
18223: NOP4
18227: ST_TO_ADDR
// if sources then
18228: NOP4
18232: IFFALSE 18279
// for i = 1 to 3 do
18234: NOP4
18238: PUSH
18239: DOUBLE
18240: LD_INT 1
18242: DEC
18243: ST_TO_ADDR
18244: LD_INT 3
18246: PUSH
18247: FOR_TO
18248: IFFALSE 18277
// AddResourceType ( base , i , sources [ i ] ) ;
18250: NOP4
18254: PPUSH
18255: NOP4
18259: PPUSH
18260: NOP4
18264: PUSH
18265: NOP4
18269: ARRAY
18270: PPUSH
18271: NOP4
18275: GO 18247
18277: POP
18278: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
18279: NOP4
18283: PUSH
18284: NOP4
18288: PPUSH
18289: NOP4
18293: PPUSH
18294: LD_INT 1
18296: PPUSH
18297: NOP4
18301: ST_TO_ADDR
// InitHc ;
18302: NOP4
// InitUc ;
18306: NOP4
// uc_side := side ;
18310: LD_ADDR_OWVAR 20
18314: PUSH
18315: NOP4
18319: ST_TO_ADDR
// uc_nation := nation ;
18320: LD_ADDR_OWVAR 21
18324: PUSH
18325: NOP4
18329: ST_TO_ADDR
// if buildings then
18330: NOP4
18334: IFFALSE 19656
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
18336: NOP4
18340: PUSH
18341: NOP4
18345: PPUSH
18346: LD_INT 2
18348: PUSH
18349: LD_INT 30
18351: PUSH
18352: LD_INT 29
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: LD_INT 30
18361: PUSH
18362: LD_INT 30
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: LIST
18373: PPUSH
18374: NOP4
18378: ST_TO_ADDR
// if tmp then
18379: NOP4
18383: IFFALSE 18431
// for i in tmp do
18385: NOP4
18389: PUSH
18390: NOP4
18394: PUSH
18395: FOR_IN
18396: IFFALSE 18429
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
18398: NOP4
18402: PPUSH
18403: NOP4
18407: PPUSH
18408: NOP4
18412: PPUSH
18413: NOP4
18417: PPUSH
18418: NOP4
18422: PPUSH
18423: NOP4
18427: GO 18395
18429: POP
18430: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
18431: NOP4
18435: PPUSH
18436: LD_INT 2
18438: PUSH
18439: LD_INT 30
18441: PUSH
18442: LD_INT 32
18444: PUSH
18445: EMPTY
18446: LIST
18447: LIST
18448: PUSH
18449: LD_INT 30
18451: PUSH
18452: LD_INT 33
18454: PUSH
18455: EMPTY
18456: LIST
18457: LIST
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: LIST
18463: PPUSH
18464: NOP4
18468: IFFALSE 18556
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
18470: NOP4
18474: PUSH
18475: NOP4
18479: PPUSH
18480: LD_INT 2
18482: PUSH
18483: LD_INT 30
18485: PUSH
18486: LD_INT 32
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: PUSH
18493: LD_INT 30
18495: PUSH
18496: LD_INT 33
18498: PUSH
18499: EMPTY
18500: LIST
18501: LIST
18502: PUSH
18503: EMPTY
18504: LIST
18505: LIST
18506: LIST
18507: PPUSH
18508: NOP4
18512: PUSH
18513: FOR_IN
18514: IFFALSE 18554
// begin if not GetBWeapon ( i ) then
18516: NOP4
18520: PPUSH
18521: NOP4
18525: NOT
18526: IFFALSE 18552
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
18528: NOP4
18532: PPUSH
18533: NOP4
18537: PPUSH
18538: NOP4
18542: PPUSH
18543: NOP4
18547: PPUSH
18548: NOP4
// end ;
18552: GO 18513
18554: POP
18555: POP
// end ; for i = 1 to personel do
18556: NOP4
18560: PUSH
18561: DOUBLE
18562: LD_INT 1
18564: DEC
18565: ST_TO_ADDR
18566: NOP4
18570: PUSH
18571: FOR_TO
18572: IFFALSE 19636
// begin if i > 4 then
18574: NOP4
18578: PUSH
18579: LD_INT 4
18581: GREATER
18582: IFFALSE 18586
// break ;
18584: GO 19636
// case i of 1 :
18586: NOP4
18590: PUSH
18591: LD_INT 1
18593: DOUBLE
18594: EQUAL
18595: IFTRUE 18599
18597: GO 18679
18599: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
18600: NOP4
18604: PUSH
18605: NOP4
18609: PPUSH
18610: LD_INT 22
18612: PUSH
18613: NOP4
18617: PUSH
18618: EMPTY
18619: LIST
18620: LIST
18621: PUSH
18622: LD_INT 58
18624: PUSH
18625: EMPTY
18626: LIST
18627: PUSH
18628: LD_INT 2
18630: PUSH
18631: LD_INT 30
18633: PUSH
18634: LD_INT 32
18636: PUSH
18637: EMPTY
18638: LIST
18639: LIST
18640: PUSH
18641: LD_INT 30
18643: PUSH
18644: LD_INT 4
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PUSH
18651: LD_INT 30
18653: PUSH
18654: LD_INT 5
18656: PUSH
18657: EMPTY
18658: LIST
18659: LIST
18660: PUSH
18661: EMPTY
18662: LIST
18663: LIST
18664: LIST
18665: LIST
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: LIST
18671: PPUSH
18672: NOP4
18676: ST_TO_ADDR
18677: GO 18901
18679: LD_INT 2
18681: DOUBLE
18682: EQUAL
18683: IFTRUE 18687
18685: GO 18749
18687: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
18688: NOP4
18692: PUSH
18693: NOP4
18697: PPUSH
18698: LD_INT 22
18700: PUSH
18701: NOP4
18705: PUSH
18706: EMPTY
18707: LIST
18708: LIST
18709: PUSH
18710: LD_INT 2
18712: PUSH
18713: LD_INT 30
18715: PUSH
18716: LD_INT 0
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PUSH
18723: LD_INT 30
18725: PUSH
18726: LD_INT 1
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: LIST
18737: PUSH
18738: EMPTY
18739: LIST
18740: LIST
18741: PPUSH
18742: NOP4
18746: ST_TO_ADDR
18747: GO 18901
18749: LD_INT 3
18751: DOUBLE
18752: EQUAL
18753: IFTRUE 18757
18755: GO 18819
18757: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18758: NOP4
18762: PUSH
18763: NOP4
18767: PPUSH
18768: LD_INT 22
18770: PUSH
18771: NOP4
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: PUSH
18780: LD_INT 2
18782: PUSH
18783: LD_INT 30
18785: PUSH
18786: LD_INT 2
18788: PUSH
18789: EMPTY
18790: LIST
18791: LIST
18792: PUSH
18793: LD_INT 30
18795: PUSH
18796: LD_INT 3
18798: PUSH
18799: EMPTY
18800: LIST
18801: LIST
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: LIST
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PPUSH
18812: NOP4
18816: ST_TO_ADDR
18817: GO 18901
18819: LD_INT 4
18821: DOUBLE
18822: EQUAL
18823: IFTRUE 18827
18825: GO 18900
18827: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18828: NOP4
18832: PUSH
18833: NOP4
18837: PPUSH
18838: LD_INT 22
18840: PUSH
18841: NOP4
18845: PUSH
18846: EMPTY
18847: LIST
18848: LIST
18849: PUSH
18850: LD_INT 2
18852: PUSH
18853: LD_INT 30
18855: PUSH
18856: LD_INT 6
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: PUSH
18863: LD_INT 30
18865: PUSH
18866: LD_INT 7
18868: PUSH
18869: EMPTY
18870: LIST
18871: LIST
18872: PUSH
18873: LD_INT 30
18875: PUSH
18876: LD_INT 8
18878: PUSH
18879: EMPTY
18880: LIST
18881: LIST
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: LIST
18887: LIST
18888: PUSH
18889: EMPTY
18890: LIST
18891: LIST
18892: PPUSH
18893: NOP4
18897: ST_TO_ADDR
18898: GO 18901
18900: POP
// if i = 1 then
18901: NOP4
18905: PUSH
18906: LD_INT 1
18908: EQUAL
18909: IFFALSE 19020
// begin tmp := [ ] ;
18911: NOP4
18915: PUSH
18916: EMPTY
18917: ST_TO_ADDR
// for j in f do
18918: NOP4
18922: PUSH
18923: NOP4
18927: PUSH
18928: FOR_IN
18929: IFFALSE 19002
// if GetBType ( j ) = b_bunker then
18931: NOP4
18935: PPUSH
18936: NOP4
18940: PUSH
18941: LD_INT 32
18943: EQUAL
18944: IFFALSE 18971
// tmp := Insert ( tmp , 1 , j ) else
18946: NOP4
18950: PUSH
18951: NOP4
18955: PPUSH
18956: LD_INT 1
18958: PPUSH
18959: NOP4
18963: PPUSH
18964: NOP4
18968: ST_TO_ADDR
18969: GO 19000
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18971: NOP4
18975: PUSH
18976: NOP4
18980: PPUSH
18981: NOP4
18985: PUSH
18986: LD_INT 1
18988: PLUS
18989: PPUSH
18990: NOP4
18994: PPUSH
18995: NOP4
18999: ST_TO_ADDR
19000: GO 18928
19002: POP
19003: POP
// if tmp then
19004: NOP4
19008: IFFALSE 19020
// f := tmp ;
19010: NOP4
19014: PUSH
19015: NOP4
19019: ST_TO_ADDR
// end ; x := personel [ i ] ;
19020: NOP4
19024: PUSH
19025: NOP4
19029: PUSH
19030: NOP4
19034: ARRAY
19035: ST_TO_ADDR
// if x = - 1 then
19036: NOP4
19040: PUSH
19041: LD_INT 1
19043: NEG
19044: EQUAL
19045: IFFALSE 19254
// begin for j in f do
19047: NOP4
19051: PUSH
19052: NOP4
19056: PUSH
19057: FOR_IN
19058: IFFALSE 19250
// repeat InitHc ;
19060: NOP4
// if GetBType ( j ) = b_barracks then
19064: NOP4
19068: PPUSH
19069: NOP4
19073: PUSH
19074: LD_INT 5
19076: EQUAL
19077: IFFALSE 19147
// begin if UnitsInside ( j ) < 3 then
19079: NOP4
19083: PPUSH
19084: NOP4
19088: PUSH
19089: LD_INT 3
19091: LESS
19092: IFFALSE 19128
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19094: LD_INT 0
19096: PPUSH
19097: LD_INT 5
19099: PUSH
19100: LD_INT 8
19102: PUSH
19103: LD_INT 9
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: LIST
19110: PUSH
19111: NOP4
19115: ARRAY
19116: PPUSH
19117: NOP4
19121: PPUSH
19122: NOP4
19126: GO 19145
// PrepareHuman ( false , i , skill ) ;
19128: LD_INT 0
19130: PPUSH
19131: NOP4
19135: PPUSH
19136: NOP4
19140: PPUSH
19141: NOP4
// end else
19145: GO 19164
// PrepareHuman ( false , i , skill ) ;
19147: LD_INT 0
19149: PPUSH
19150: NOP4
19154: PPUSH
19155: NOP4
19159: PPUSH
19160: NOP4
// un := CreateHuman ;
19164: NOP4
19168: PUSH
19169: NOP4
19173: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19174: NOP4
19178: PUSH
19179: NOP4
19183: PPUSH
19184: LD_INT 1
19186: PPUSH
19187: NOP4
19191: PPUSH
19192: NOP4
19196: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
19197: NOP4
19201: PPUSH
19202: NOP4
19206: PPUSH
19207: NOP4
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
19211: NOP4
19215: PPUSH
19216: NOP4
19220: PUSH
19221: LD_INT 6
19223: EQUAL
19224: PUSH
19225: NOP4
19229: PPUSH
19230: NOP4
19234: PUSH
19235: LD_INT 32
19237: PUSH
19238: LD_INT 31
19240: PUSH
19241: EMPTY
19242: LIST
19243: LIST
19244: IN
19245: OR
19246: IFFALSE 19060
19248: GO 19057
19250: POP
19251: POP
// end else
19252: GO 19634
// for j = 1 to x do
19254: NOP4
19258: PUSH
19259: DOUBLE
19260: LD_INT 1
19262: DEC
19263: ST_TO_ADDR
19264: NOP4
19268: PUSH
19269: FOR_TO
19270: IFFALSE 19632
// begin InitHc ;
19272: NOP4
// if not f then
19276: NOP4
19280: NOT
19281: IFFALSE 19370
// begin PrepareHuman ( false , i , skill ) ;
19283: LD_INT 0
19285: PPUSH
19286: NOP4
19290: PPUSH
19291: NOP4
19295: PPUSH
19296: NOP4
// un := CreateHuman ;
19300: NOP4
19304: PUSH
19305: NOP4
19309: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19310: NOP4
19314: PUSH
19315: NOP4
19319: PPUSH
19320: LD_INT 1
19322: PPUSH
19323: NOP4
19327: PPUSH
19328: NOP4
19332: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19333: NOP4
19337: PPUSH
19338: NOP4
19342: PPUSH
19343: NOP4
19347: PPUSH
19348: NOP4
19352: PPUSH
19353: NOP4
19357: PPUSH
19358: LD_INT 10
19360: PPUSH
19361: LD_INT 0
19363: PPUSH
19364: NOP4
// continue ;
19368: GO 19269
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
19370: NOP4
19374: PUSH
19375: LD_INT 1
19377: ARRAY
19378: PPUSH
19379: NOP4
19383: PUSH
19384: NOP4
19388: PUSH
19389: LD_INT 1
19391: ARRAY
19392: PPUSH
19393: NOP4
19397: PUSH
19398: LD_INT 32
19400: PUSH
19401: LD_INT 31
19403: PUSH
19404: EMPTY
19405: LIST
19406: LIST
19407: IN
19408: AND
19409: PUSH
19410: NOP4
19414: PUSH
19415: LD_INT 1
19417: ARRAY
19418: PPUSH
19419: NOP4
19423: PUSH
19424: LD_INT 6
19426: EQUAL
19427: OR
19428: IFFALSE 19448
// f := Delete ( f , 1 ) ;
19430: NOP4
19434: PUSH
19435: NOP4
19439: PPUSH
19440: LD_INT 1
19442: PPUSH
19443: NOP4
19447: ST_TO_ADDR
// if not f then
19448: NOP4
19452: NOT
19453: IFFALSE 19471
// begin x := x + 2 ;
19455: NOP4
19459: PUSH
19460: NOP4
19464: PUSH
19465: LD_INT 2
19467: PLUS
19468: ST_TO_ADDR
// continue ;
19469: GO 19269
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
19471: NOP4
19475: PUSH
19476: LD_INT 1
19478: ARRAY
19479: PPUSH
19480: NOP4
19484: PUSH
19485: LD_INT 5
19487: EQUAL
19488: IFFALSE 19562
// begin if UnitsInside ( f [ 1 ] ) < 3 then
19490: NOP4
19494: PUSH
19495: LD_INT 1
19497: ARRAY
19498: PPUSH
19499: NOP4
19503: PUSH
19504: LD_INT 3
19506: LESS
19507: IFFALSE 19543
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
19509: LD_INT 0
19511: PPUSH
19512: LD_INT 5
19514: PUSH
19515: LD_INT 8
19517: PUSH
19518: LD_INT 9
19520: PUSH
19521: EMPTY
19522: LIST
19523: LIST
19524: LIST
19525: PUSH
19526: NOP4
19530: ARRAY
19531: PPUSH
19532: NOP4
19536: PPUSH
19537: NOP4
19541: GO 19560
// PrepareHuman ( false , i , skill ) ;
19543: LD_INT 0
19545: PPUSH
19546: NOP4
19550: PPUSH
19551: NOP4
19555: PPUSH
19556: NOP4
// end else
19560: GO 19579
// PrepareHuman ( false , i , skill ) ;
19562: LD_INT 0
19564: PPUSH
19565: NOP4
19569: PPUSH
19570: NOP4
19574: PPUSH
19575: NOP4
// un := CreateHuman ;
19579: NOP4
19583: PUSH
19584: NOP4
19588: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
19589: NOP4
19593: PUSH
19594: NOP4
19598: PPUSH
19599: LD_INT 1
19601: PPUSH
19602: NOP4
19606: PPUSH
19607: NOP4
19611: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
19612: NOP4
19616: PPUSH
19617: NOP4
19621: PUSH
19622: LD_INT 1
19624: ARRAY
19625: PPUSH
19626: NOP4
// end ;
19630: GO 19269
19632: POP
19633: POP
// end ;
19634: GO 18571
19636: POP
19637: POP
// result := result ^ buildings ;
19638: NOP4
19642: PUSH
19643: NOP4
19647: PUSH
19648: NOP4
19652: ADD
19653: ST_TO_ADDR
// end else
19654: GO 19797
// begin for i = 1 to personel do
19656: NOP4
19660: PUSH
19661: DOUBLE
19662: LD_INT 1
19664: DEC
19665: ST_TO_ADDR
19666: NOP4
19670: PUSH
19671: FOR_TO
19672: IFFALSE 19795
// begin if i > 4 then
19674: NOP4
19678: PUSH
19679: LD_INT 4
19681: GREATER
19682: IFFALSE 19686
// break ;
19684: GO 19795
// x := personel [ i ] ;
19686: NOP4
19690: PUSH
19691: NOP4
19695: PUSH
19696: NOP4
19700: ARRAY
19701: ST_TO_ADDR
// if x = - 1 then
19702: NOP4
19706: PUSH
19707: LD_INT 1
19709: NEG
19710: EQUAL
19711: IFFALSE 19715
// continue ;
19713: GO 19671
// PrepareHuman ( false , i , skill ) ;
19715: LD_INT 0
19717: PPUSH
19718: NOP4
19722: PPUSH
19723: NOP4
19727: PPUSH
19728: NOP4
// un := CreateHuman ;
19732: NOP4
19736: PUSH
19737: NOP4
19741: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19742: NOP4
19746: PPUSH
19747: NOP4
19751: PPUSH
19752: NOP4
19756: PPUSH
19757: NOP4
19761: PPUSH
19762: NOP4
19766: PPUSH
19767: LD_INT 10
19769: PPUSH
19770: LD_INT 0
19772: PPUSH
19773: NOP4
// result := result ^ un ;
19777: NOP4
19781: PUSH
19782: NOP4
19786: PUSH
19787: NOP4
19791: ADD
19792: ST_TO_ADDR
// end ;
19793: GO 19671
19795: POP
19796: POP
// end ; end ;
19797: LD_VAR 0 7
19801: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19802: LD_INT 0
19804: PPUSH
19805: PPUSH
19806: PPUSH
19807: PPUSH
19808: PPUSH
19809: PPUSH
19810: PPUSH
19811: PPUSH
19812: PPUSH
19813: PPUSH
19814: PPUSH
19815: PPUSH
19816: PPUSH
19817: PPUSH
19818: PPUSH
19819: PPUSH
// result := false ;
19820: NOP4
19824: PUSH
19825: LD_INT 0
19827: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19828: NOP4
19832: NOT
19833: PUSH
19834: NOP4
19838: PPUSH
19839: NOP4
19843: PUSH
19844: LD_INT 32
19846: PUSH
19847: LD_INT 33
19849: PUSH
19850: EMPTY
19851: LIST
19852: LIST
19853: IN
19854: NOT
19855: OR
19856: IFFALSE 19860
// exit ;
19858: GO 20999
// nat := GetNation ( tower ) ;
19860: NOP4
19864: PUSH
19865: NOP4
19869: PPUSH
19870: NOP4
19874: ST_TO_ADDR
// side := GetSide ( tower ) ;
19875: NOP4
19879: PUSH
19880: NOP4
19884: PPUSH
19885: NOP4
19889: ST_TO_ADDR
// x := GetX ( tower ) ;
19890: NOP4
19894: PUSH
19895: NOP4
19899: PPUSH
19900: NOP4
19904: ST_TO_ADDR
// y := GetY ( tower ) ;
19905: NOP4
19909: PUSH
19910: NOP4
19914: PPUSH
19915: NOP4
19919: ST_TO_ADDR
// if not x or not y then
19920: NOP4
19924: NOT
19925: PUSH
19926: NOP4
19930: NOT
19931: OR
19932: IFFALSE 19936
// exit ;
19934: GO 20999
// weapon := 0 ;
19936: NOP4
19940: PUSH
19941: LD_INT 0
19943: ST_TO_ADDR
// fac_list := [ ] ;
19944: NOP4
19948: PUSH
19949: EMPTY
19950: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19951: NOP4
19955: PUSH
19956: NOP4
19960: PPUSH
19961: NOP4
19965: PPUSH
19966: NOP4
19970: PPUSH
19971: LD_INT 0
19973: PPUSH
19974: NOP4
19978: PPUSH
19979: LD_INT 30
19981: PUSH
19982: LD_INT 3
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: PPUSH
19989: NOP4
19993: ST_TO_ADDR
// if not factories then
19994: NOP4
19998: NOT
19999: IFFALSE 20003
// exit ;
20001: GO 20999
// for i in factories do
20003: NOP4
20007: PUSH
20008: NOP4
20012: PUSH
20013: FOR_IN
20014: IFFALSE 20039
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20016: NOP4
20020: PUSH
20021: NOP4
20025: PUSH
20026: NOP4
20030: PPUSH
20031: NOP4
20035: UNION
20036: ST_TO_ADDR
20037: GO 20013
20039: POP
20040: POP
// if not fac_list then
20041: NOP4
20045: NOT
20046: IFFALSE 20050
// exit ;
20048: GO 20999
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20050: NOP4
20054: PUSH
20055: LD_INT 4
20057: PUSH
20058: LD_INT 5
20060: PUSH
20061: LD_INT 9
20063: PUSH
20064: LD_INT 10
20066: PUSH
20067: LD_INT 6
20069: PUSH
20070: LD_INT 7
20072: PUSH
20073: LD_INT 11
20075: PUSH
20076: EMPTY
20077: LIST
20078: LIST
20079: LIST
20080: LIST
20081: LIST
20082: LIST
20083: LIST
20084: PUSH
20085: LD_INT 27
20087: PUSH
20088: LD_INT 28
20090: PUSH
20091: LD_INT 26
20093: PUSH
20094: LD_INT 30
20096: PUSH
20097: EMPTY
20098: LIST
20099: LIST
20100: LIST
20101: LIST
20102: PUSH
20103: LD_INT 43
20105: PUSH
20106: LD_INT 44
20108: PUSH
20109: LD_INT 46
20111: PUSH
20112: LD_INT 45
20114: PUSH
20115: LD_INT 47
20117: PUSH
20118: LD_INT 49
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: LIST
20126: LIST
20127: LIST
20128: PUSH
20129: EMPTY
20130: LIST
20131: LIST
20132: LIST
20133: PUSH
20134: NOP4
20138: ARRAY
20139: ST_TO_ADDR
// for i in list do
20140: NOP4
20144: PUSH
20145: NOP4
20149: PUSH
20150: FOR_IN
20151: IFFALSE 20184
// if not i in fac_list then
20153: NOP4
20157: PUSH
20158: NOP4
20162: IN
20163: NOT
20164: IFFALSE 20182
// list := list diff i ;
20166: NOP4
20170: PUSH
20171: NOP4
20175: PUSH
20176: NOP4
20180: DIFF
20181: ST_TO_ADDR
20182: GO 20150
20184: POP
20185: POP
// if not list then
20186: NOP4
20190: NOT
20191: IFFALSE 20195
// exit ;
20193: GO 20999
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
20195: NOP4
20199: PUSH
20200: LD_INT 3
20202: EQUAL
20203: PUSH
20204: LD_INT 49
20206: PUSH
20207: NOP4
20211: IN
20212: AND
20213: PUSH
20214: LD_INT 31
20216: PPUSH
20217: NOP4
20221: PPUSH
20222: NOP4
20226: PUSH
20227: LD_INT 2
20229: EQUAL
20230: AND
20231: IFFALSE 20291
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
20233: LD_INT 22
20235: PUSH
20236: NOP4
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: PUSH
20245: LD_INT 35
20247: PUSH
20248: LD_INT 49
20250: PUSH
20251: EMPTY
20252: LIST
20253: LIST
20254: PUSH
20255: LD_INT 91
20257: PUSH
20258: NOP4
20262: PUSH
20263: LD_INT 10
20265: PUSH
20266: EMPTY
20267: LIST
20268: LIST
20269: LIST
20270: PUSH
20271: EMPTY
20272: LIST
20273: LIST
20274: LIST
20275: PPUSH
20276: NOP4
20280: NOT
20281: IFFALSE 20291
// weapon := ru_time_lapser ;
20283: NOP4
20287: PUSH
20288: LD_INT 49
20290: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
20291: NOP4
20295: PUSH
20296: LD_INT 1
20298: PUSH
20299: LD_INT 2
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: IN
20306: PUSH
20307: LD_INT 11
20309: PUSH
20310: NOP4
20314: IN
20315: PUSH
20316: LD_INT 30
20318: PUSH
20319: NOP4
20323: IN
20324: OR
20325: AND
20326: PUSH
20327: LD_INT 6
20329: PPUSH
20330: NOP4
20334: PPUSH
20335: NOP4
20339: PUSH
20340: LD_INT 2
20342: EQUAL
20343: AND
20344: IFFALSE 20509
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
20346: LD_INT 22
20348: PUSH
20349: NOP4
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: PUSH
20358: LD_INT 2
20360: PUSH
20361: LD_INT 35
20363: PUSH
20364: LD_INT 11
20366: PUSH
20367: EMPTY
20368: LIST
20369: LIST
20370: PUSH
20371: LD_INT 35
20373: PUSH
20374: LD_INT 30
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: PUSH
20381: EMPTY
20382: LIST
20383: LIST
20384: LIST
20385: PUSH
20386: LD_INT 91
20388: PUSH
20389: NOP4
20393: PUSH
20394: LD_INT 18
20396: PUSH
20397: EMPTY
20398: LIST
20399: LIST
20400: LIST
20401: PUSH
20402: EMPTY
20403: LIST
20404: LIST
20405: LIST
20406: PPUSH
20407: NOP4
20411: NOT
20412: PUSH
20413: LD_INT 22
20415: PUSH
20416: NOP4
20420: PUSH
20421: EMPTY
20422: LIST
20423: LIST
20424: PUSH
20425: LD_INT 2
20427: PUSH
20428: LD_INT 30
20430: PUSH
20431: LD_INT 32
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: PUSH
20438: LD_INT 30
20440: PUSH
20441: LD_INT 33
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: LIST
20452: PUSH
20453: LD_INT 91
20455: PUSH
20456: NOP4
20460: PUSH
20461: LD_INT 12
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: LIST
20468: PUSH
20469: EMPTY
20470: LIST
20471: LIST
20472: LIST
20473: PUSH
20474: EMPTY
20475: LIST
20476: PPUSH
20477: NOP4
20481: PUSH
20482: LD_INT 2
20484: GREATER
20485: AND
20486: IFFALSE 20509
// weapon := [ us_radar , ar_radar ] [ nat ] ;
20488: NOP4
20492: PUSH
20493: LD_INT 11
20495: PUSH
20496: LD_INT 30
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PUSH
20503: NOP4
20507: ARRAY
20508: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
20509: NOP4
20513: NOT
20514: PUSH
20515: LD_INT 40
20517: PPUSH
20518: NOP4
20522: PPUSH
20523: NOP4
20527: PUSH
20528: LD_INT 2
20530: EQUAL
20531: AND
20532: PUSH
20533: LD_INT 7
20535: PUSH
20536: NOP4
20540: IN
20541: PUSH
20542: LD_INT 28
20544: PUSH
20545: NOP4
20549: IN
20550: OR
20551: PUSH
20552: LD_INT 45
20554: PUSH
20555: NOP4
20559: IN
20560: OR
20561: AND
20562: IFFALSE 20816
// begin hex := GetHexInfo ( x , y ) ;
20564: NOP4
20568: PUSH
20569: NOP4
20573: PPUSH
20574: NOP4
20578: PPUSH
20579: NOP4
20583: ST_TO_ADDR
// if hex [ 1 ] then
20584: NOP4
20588: PUSH
20589: LD_INT 1
20591: ARRAY
20592: IFFALSE 20596
// exit ;
20594: GO 20999
// height := hex [ 2 ] ;
20596: NOP4
20600: PUSH
20601: NOP4
20605: PUSH
20606: LD_INT 2
20608: ARRAY
20609: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
20610: NOP4
20614: PUSH
20615: LD_INT 0
20617: PUSH
20618: LD_INT 2
20620: PUSH
20621: LD_INT 3
20623: PUSH
20624: LD_INT 5
20626: PUSH
20627: EMPTY
20628: LIST
20629: LIST
20630: LIST
20631: LIST
20632: ST_TO_ADDR
// for i in tmp do
20633: NOP4
20637: PUSH
20638: NOP4
20642: PUSH
20643: FOR_IN
20644: IFFALSE 20814
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
20646: NOP4
20650: PUSH
20651: NOP4
20655: PPUSH
20656: NOP4
20660: PPUSH
20661: LD_INT 5
20663: PPUSH
20664: NOP4
20668: PUSH
20669: NOP4
20673: PPUSH
20674: NOP4
20678: PPUSH
20679: LD_INT 5
20681: PPUSH
20682: NOP4
20686: PUSH
20687: EMPTY
20688: LIST
20689: LIST
20690: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
20691: NOP4
20695: PUSH
20696: LD_INT 1
20698: ARRAY
20699: PPUSH
20700: NOP4
20704: PUSH
20705: LD_INT 2
20707: ARRAY
20708: PPUSH
20709: NOP4
20713: IFFALSE 20812
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
20715: NOP4
20719: PUSH
20720: NOP4
20724: PUSH
20725: LD_INT 1
20727: ARRAY
20728: PPUSH
20729: NOP4
20733: PUSH
20734: LD_INT 2
20736: ARRAY
20737: PPUSH
20738: NOP4
20742: ST_TO_ADDR
// if hex [ 1 ] then
20743: NOP4
20747: PUSH
20748: LD_INT 1
20750: ARRAY
20751: IFFALSE 20755
// continue ;
20753: GO 20643
// h := hex [ 2 ] ;
20755: NOP4
20759: PUSH
20760: NOP4
20764: PUSH
20765: LD_INT 2
20767: ARRAY
20768: ST_TO_ADDR
// if h + 7 < height then
20769: NOP4
20773: PUSH
20774: LD_INT 7
20776: PLUS
20777: PUSH
20778: NOP4
20782: LESS
20783: IFFALSE 20812
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20785: NOP4
20789: PUSH
20790: LD_INT 7
20792: PUSH
20793: LD_INT 28
20795: PUSH
20796: LD_INT 45
20798: PUSH
20799: EMPTY
20800: LIST
20801: LIST
20802: LIST
20803: PUSH
20804: NOP4
20808: ARRAY
20809: ST_TO_ADDR
// break ;
20810: GO 20814
// end ; end ; end ;
20812: GO 20643
20814: POP
20815: POP
// end ; if not weapon then
20816: NOP4
20820: NOT
20821: IFFALSE 20881
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20823: NOP4
20827: PUSH
20828: NOP4
20832: PUSH
20833: LD_INT 11
20835: PUSH
20836: LD_INT 30
20838: PUSH
20839: LD_INT 49
20841: PUSH
20842: EMPTY
20843: LIST
20844: LIST
20845: LIST
20846: DIFF
20847: ST_TO_ADDR
// if not list then
20848: NOP4
20852: NOT
20853: IFFALSE 20857
// exit ;
20855: GO 20999
// weapon := list [ rand ( 1 , list ) ] ;
20857: NOP4
20861: PUSH
20862: NOP4
20866: PUSH
20867: LD_INT 1
20869: PPUSH
20870: NOP4
20874: PPUSH
20875: NOP4
20879: ARRAY
20880: ST_TO_ADDR
// end ; if weapon then
20881: NOP4
20885: IFFALSE 20999
// begin tmp := CostOfWeapon ( weapon ) ;
20887: NOP4
20891: PUSH
20892: NOP4
20896: PPUSH
20897: NOP4
20901: ST_TO_ADDR
// j := GetBase ( tower ) ;
20902: NOP4
20906: PUSH
20907: NOP4
20911: PPUSH
20912: NOP4
20916: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20917: NOP4
20921: PPUSH
20922: LD_INT 1
20924: PPUSH
20925: NOP4
20929: PUSH
20930: NOP4
20934: PUSH
20935: LD_INT 1
20937: ARRAY
20938: GREATEREQUAL
20939: PUSH
20940: NOP4
20944: PPUSH
20945: LD_INT 2
20947: PPUSH
20948: NOP4
20952: PUSH
20953: NOP4
20957: PUSH
20958: LD_INT 2
20960: ARRAY
20961: GREATEREQUAL
20962: AND
20963: PUSH
20964: NOP4
20968: PPUSH
20969: LD_INT 3
20971: PPUSH
20972: NOP4
20976: PUSH
20977: NOP4
20981: PUSH
20982: LD_INT 3
20984: ARRAY
20985: GREATEREQUAL
20986: AND
20987: IFFALSE 20999
// result := weapon ;
20989: NOP4
20993: PUSH
20994: NOP4
20998: ST_TO_ADDR
// end ; end ;
20999: LD_VAR 0 3
21003: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21004: LD_INT 0
21006: PPUSH
21007: PPUSH
// result := true ;
21008: NOP4
21012: PUSH
21013: LD_INT 1
21015: ST_TO_ADDR
// if array1 = array2 then
21016: NOP4
21020: PUSH
21021: NOP4
21025: EQUAL
21026: IFFALSE 21086
// begin for i = 1 to array1 do
21028: NOP4
21032: PUSH
21033: DOUBLE
21034: LD_INT 1
21036: DEC
21037: ST_TO_ADDR
21038: NOP4
21042: PUSH
21043: FOR_TO
21044: IFFALSE 21082
// if array1 [ i ] <> array2 [ i ] then
21046: NOP4
21050: PUSH
21051: NOP4
21055: ARRAY
21056: PUSH
21057: NOP4
21061: PUSH
21062: NOP4
21066: ARRAY
21067: NONEQUAL
21068: IFFALSE 21080
// begin result := false ;
21070: NOP4
21074: PUSH
21075: LD_INT 0
21077: ST_TO_ADDR
// break ;
21078: GO 21082
// end ;
21080: GO 21043
21082: POP
21083: POP
// end else
21084: GO 21094
// result := false ;
21086: NOP4
21090: PUSH
21091: LD_INT 0
21093: ST_TO_ADDR
// end ;
21094: LD_VAR 0 3
21098: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21099: LD_INT 0
21101: PPUSH
21102: PPUSH
// if not array1 or not array2 then
21103: NOP4
21107: NOT
21108: PUSH
21109: NOP4
21113: NOT
21114: OR
21115: IFFALSE 21119
// exit ;
21117: GO 21183
// result := true ;
21119: NOP4
21123: PUSH
21124: LD_INT 1
21126: ST_TO_ADDR
// for i = 1 to array1 do
21127: NOP4
21131: PUSH
21132: DOUBLE
21133: LD_INT 1
21135: DEC
21136: ST_TO_ADDR
21137: NOP4
21141: PUSH
21142: FOR_TO
21143: IFFALSE 21181
// if array1 [ i ] <> array2 [ i ] then
21145: NOP4
21149: PUSH
21150: NOP4
21154: ARRAY
21155: PUSH
21156: NOP4
21160: PUSH
21161: NOP4
21165: ARRAY
21166: NONEQUAL
21167: IFFALSE 21179
// begin result := false ;
21169: NOP4
21173: PUSH
21174: LD_INT 0
21176: ST_TO_ADDR
// break ;
21177: GO 21181
// end ;
21179: GO 21142
21181: POP
21182: POP
// end ;
21183: LD_VAR 0 3
21187: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
21188: LD_INT 0
21190: PPUSH
21191: PPUSH
21192: PPUSH
// pom := GetBase ( fac ) ;
21193: NOP4
21197: PUSH
21198: NOP4
21202: PPUSH
21203: NOP4
21207: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
21208: NOP4
21212: PUSH
21213: NOP4
21217: PUSH
21218: LD_INT 1
21220: ARRAY
21221: PPUSH
21222: NOP4
21226: PUSH
21227: LD_INT 2
21229: ARRAY
21230: PPUSH
21231: NOP4
21235: PUSH
21236: LD_INT 3
21238: ARRAY
21239: PPUSH
21240: NOP4
21244: PUSH
21245: LD_INT 4
21247: ARRAY
21248: PPUSH
21249: NOP4
21253: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21254: NOP4
21258: PUSH
21259: NOP4
21263: PPUSH
21264: LD_INT 1
21266: PPUSH
21267: NOP4
21271: PUSH
21272: NOP4
21276: PUSH
21277: LD_INT 1
21279: ARRAY
21280: GREATEREQUAL
21281: PUSH
21282: NOP4
21286: PPUSH
21287: LD_INT 2
21289: PPUSH
21290: NOP4
21294: PUSH
21295: NOP4
21299: PUSH
21300: LD_INT 2
21302: ARRAY
21303: GREATEREQUAL
21304: AND
21305: PUSH
21306: NOP4
21310: PPUSH
21311: LD_INT 3
21313: PPUSH
21314: NOP4
21318: PUSH
21319: NOP4
21323: PUSH
21324: LD_INT 3
21326: ARRAY
21327: GREATEREQUAL
21328: AND
21329: ST_TO_ADDR
// end ;
21330: LD_VAR 0 3
21334: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
21335: LD_INT 0
21337: PPUSH
21338: PPUSH
21339: PPUSH
21340: PPUSH
// pom := GetBase ( building ) ;
21341: NOP4
21345: PUSH
21346: NOP4
21350: PPUSH
21351: NOP4
21355: ST_TO_ADDR
// if not pom then
21356: NOP4
21360: NOT
21361: IFFALSE 21365
// exit ;
21363: GO 21535
// btype := GetBType ( building ) ;
21365: NOP4
21369: PUSH
21370: NOP4
21374: PPUSH
21375: NOP4
21379: ST_TO_ADDR
// if btype = b_armoury then
21380: NOP4
21384: PUSH
21385: LD_INT 4
21387: EQUAL
21388: IFFALSE 21398
// btype := b_barracks ;
21390: NOP4
21394: PUSH
21395: LD_INT 5
21397: ST_TO_ADDR
// if btype = b_depot then
21398: NOP4
21402: PUSH
21403: LD_INT 0
21405: EQUAL
21406: IFFALSE 21416
// btype := b_warehouse ;
21408: NOP4
21412: PUSH
21413: LD_INT 1
21415: ST_TO_ADDR
// if btype = b_workshop then
21416: NOP4
21420: PUSH
21421: LD_INT 2
21423: EQUAL
21424: IFFALSE 21434
// btype := b_factory ;
21426: NOP4
21430: PUSH
21431: LD_INT 3
21433: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21434: NOP4
21438: PUSH
21439: NOP4
21443: PPUSH
21444: NOP4
21448: PPUSH
21449: NOP4
21453: PPUSH
21454: NOP4
21458: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21459: NOP4
21463: PUSH
21464: NOP4
21468: PPUSH
21469: LD_INT 1
21471: PPUSH
21472: NOP4
21476: PUSH
21477: NOP4
21481: PUSH
21482: LD_INT 1
21484: ARRAY
21485: GREATEREQUAL
21486: PUSH
21487: NOP4
21491: PPUSH
21492: LD_INT 2
21494: PPUSH
21495: NOP4
21499: PUSH
21500: NOP4
21504: PUSH
21505: LD_INT 2
21507: ARRAY
21508: GREATEREQUAL
21509: AND
21510: PUSH
21511: NOP4
21515: PPUSH
21516: LD_INT 3
21518: PPUSH
21519: NOP4
21523: PUSH
21524: NOP4
21528: PUSH
21529: LD_INT 3
21531: ARRAY
21532: GREATEREQUAL
21533: AND
21534: ST_TO_ADDR
// end ;
21535: LD_VAR 0 2
21539: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
21540: LD_INT 0
21542: PPUSH
21543: PPUSH
21544: PPUSH
// pom := GetBase ( building ) ;
21545: NOP4
21549: PUSH
21550: NOP4
21554: PPUSH
21555: NOP4
21559: ST_TO_ADDR
// if not pom then
21560: NOP4
21564: NOT
21565: IFFALSE 21569
// exit ;
21567: GO 21670
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
21569: NOP4
21573: PUSH
21574: NOP4
21578: PPUSH
21579: NOP4
21583: PPUSH
21584: NOP4
21588: PPUSH
21589: NOP4
21593: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
21594: NOP4
21598: PUSH
21599: NOP4
21603: PPUSH
21604: LD_INT 1
21606: PPUSH
21607: NOP4
21611: PUSH
21612: NOP4
21616: PUSH
21617: LD_INT 1
21619: ARRAY
21620: GREATEREQUAL
21621: PUSH
21622: NOP4
21626: PPUSH
21627: LD_INT 2
21629: PPUSH
21630: NOP4
21634: PUSH
21635: NOP4
21639: PUSH
21640: LD_INT 2
21642: ARRAY
21643: GREATEREQUAL
21644: AND
21645: PUSH
21646: NOP4
21650: PPUSH
21651: LD_INT 3
21653: PPUSH
21654: NOP4
21658: PUSH
21659: NOP4
21663: PUSH
21664: LD_INT 3
21666: ARRAY
21667: GREATEREQUAL
21668: AND
21669: ST_TO_ADDR
// end ;
21670: LD_VAR 0 3
21674: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
21675: LD_INT 0
21677: PPUSH
21678: PPUSH
21679: PPUSH
21680: PPUSH
21681: PPUSH
21682: PPUSH
21683: PPUSH
21684: PPUSH
21685: PPUSH
21686: PPUSH
21687: PPUSH
// result := false ;
21688: NOP4
21692: PUSH
21693: LD_INT 0
21695: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
21696: NOP4
21700: NOT
21701: PUSH
21702: NOP4
21706: NOT
21707: OR
21708: PUSH
21709: NOP4
21713: NOT
21714: OR
21715: PUSH
21716: NOP4
21720: NOT
21721: OR
21722: IFFALSE 21726
// exit ;
21724: GO 22540
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
21726: NOP4
21730: PUSH
21731: NOP4
21735: PPUSH
21736: NOP4
21740: PPUSH
21741: NOP4
21745: PPUSH
21746: NOP4
21750: PPUSH
21751: NOP4
21755: PUSH
21756: LD_INT 1
21758: ARRAY
21759: PPUSH
21760: NOP4
21764: PPUSH
21765: LD_INT 0
21767: PPUSH
21768: NOP4
21772: ST_TO_ADDR
// if not hexes then
21773: NOP4
21777: NOT
21778: IFFALSE 21782
// exit ;
21780: GO 22540
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21782: NOP4
21786: PUSH
21787: NOP4
21791: PPUSH
21792: LD_INT 22
21794: PUSH
21795: NOP4
21799: PPUSH
21800: NOP4
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: LD_INT 2
21811: PUSH
21812: LD_INT 30
21814: PUSH
21815: LD_INT 0
21817: PUSH
21818: EMPTY
21819: LIST
21820: LIST
21821: PUSH
21822: LD_INT 30
21824: PUSH
21825: LD_INT 1
21827: PUSH
21828: EMPTY
21829: LIST
21830: LIST
21831: PUSH
21832: EMPTY
21833: LIST
21834: LIST
21835: LIST
21836: PUSH
21837: EMPTY
21838: LIST
21839: LIST
21840: PPUSH
21841: NOP4
21845: ST_TO_ADDR
// for i = 1 to hexes do
21846: NOP4
21850: PUSH
21851: DOUBLE
21852: LD_INT 1
21854: DEC
21855: ST_TO_ADDR
21856: NOP4
21860: PUSH
21861: FOR_TO
21862: IFFALSE 22538
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21864: NOP4
21868: PUSH
21869: NOP4
21873: PUSH
21874: NOP4
21878: ARRAY
21879: PUSH
21880: LD_INT 1
21882: ARRAY
21883: PPUSH
21884: NOP4
21888: PUSH
21889: NOP4
21893: ARRAY
21894: PUSH
21895: LD_INT 2
21897: ARRAY
21898: PPUSH
21899: NOP4
21903: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21904: NOP4
21908: PUSH
21909: NOP4
21913: ARRAY
21914: PUSH
21915: LD_INT 1
21917: ARRAY
21918: PPUSH
21919: NOP4
21923: PUSH
21924: NOP4
21928: ARRAY
21929: PUSH
21930: LD_INT 2
21932: ARRAY
21933: PPUSH
21934: NOP4
21938: PUSH
21939: NOP4
21943: PUSH
21944: NOP4
21948: ARRAY
21949: PUSH
21950: LD_INT 1
21952: ARRAY
21953: PPUSH
21954: NOP4
21958: PUSH
21959: NOP4
21963: ARRAY
21964: PUSH
21965: LD_INT 2
21967: ARRAY
21968: PPUSH
21969: NOP4
21973: NOT
21974: OR
21975: PUSH
21976: NOP4
21980: PPUSH
21981: NOP4
21985: PUSH
21986: LD_INT 3
21988: EQUAL
21989: OR
21990: IFFALSE 21996
// exit ;
21992: POP
21993: POP
21994: GO 22540
// if not tmp then
21996: NOP4
22000: NOT
22001: IFFALSE 22005
// continue ;
22003: GO 21861
// result := true ;
22005: NOP4
22009: PUSH
22010: LD_INT 1
22012: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22013: NOP4
22017: PUSH
22018: NOP4
22022: PPUSH
22023: NOP4
22027: PUSH
22028: LD_INT 2
22030: EQUAL
22031: AND
22032: PUSH
22033: NOP4
22037: PPUSH
22038: NOP4
22042: PUSH
22043: LD_INT 1
22045: EQUAL
22046: AND
22047: IFFALSE 22211
// begin if IsDrivenBy ( tmp ) then
22049: NOP4
22053: PPUSH
22054: NOP4
22058: IFFALSE 22062
// continue ;
22060: GO 21861
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22062: NOP4
22066: PPUSH
22067: LD_INT 3
22069: PUSH
22070: LD_INT 60
22072: PUSH
22073: EMPTY
22074: LIST
22075: PUSH
22076: EMPTY
22077: LIST
22078: LIST
22079: PUSH
22080: LD_INT 3
22082: PUSH
22083: LD_INT 55
22085: PUSH
22086: EMPTY
22087: LIST
22088: PUSH
22089: EMPTY
22090: LIST
22091: LIST
22092: PUSH
22093: EMPTY
22094: LIST
22095: LIST
22096: PPUSH
22097: NOP4
22101: IFFALSE 22209
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22103: NOP4
22107: PUSH
22108: NOP4
22112: PPUSH
22113: LD_INT 3
22115: PUSH
22116: LD_INT 60
22118: PUSH
22119: EMPTY
22120: LIST
22121: PUSH
22122: EMPTY
22123: LIST
22124: LIST
22125: PUSH
22126: LD_INT 3
22128: PUSH
22129: LD_INT 55
22131: PUSH
22132: EMPTY
22133: LIST
22134: PUSH
22135: EMPTY
22136: LIST
22137: LIST
22138: PUSH
22139: EMPTY
22140: LIST
22141: LIST
22142: PPUSH
22143: NOP4
22147: PUSH
22148: LD_INT 1
22150: ARRAY
22151: ST_TO_ADDR
// if IsInUnit ( driver ) then
22152: NOP4
22156: PPUSH
22157: NOP4
22161: IFFALSE 22172
// ComExit ( driver ) ;
22163: NOP4
22167: PPUSH
22168: NOP4
// AddComEnterUnit ( driver , tmp ) ;
22172: NOP4
22176: PPUSH
22177: NOP4
22181: PPUSH
22182: NOP4
// AddComMoveToArea ( driver , parking ) ;
22186: NOP4
22190: PPUSH
22191: NOP4
22195: PPUSH
22196: NOP4
// AddComExitVehicle ( driver ) ;
22200: NOP4
22204: PPUSH
22205: NOP4
// end ; continue ;
22209: GO 21861
// end ; if not cleaners or not tmp in cleaners then
22211: NOP4
22215: NOT
22216: PUSH
22217: NOP4
22221: PUSH
22222: NOP4
22226: IN
22227: NOT
22228: OR
22229: IFFALSE 22536
// begin if dep then
22231: NOP4
22235: IFFALSE 22371
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
22237: NOP4
22241: PUSH
22242: NOP4
22246: PUSH
22247: LD_INT 1
22249: ARRAY
22250: PPUSH
22251: NOP4
22255: PPUSH
22256: NOP4
22260: PUSH
22261: LD_INT 1
22263: ARRAY
22264: PPUSH
22265: NOP4
22269: PPUSH
22270: LD_INT 5
22272: PPUSH
22273: NOP4
22277: PUSH
22278: NOP4
22282: PUSH
22283: LD_INT 1
22285: ARRAY
22286: PPUSH
22287: NOP4
22291: PPUSH
22292: NOP4
22296: PUSH
22297: LD_INT 1
22299: ARRAY
22300: PPUSH
22301: NOP4
22305: PPUSH
22306: LD_INT 5
22308: PPUSH
22309: NOP4
22313: PUSH
22314: EMPTY
22315: LIST
22316: LIST
22317: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
22318: NOP4
22322: PUSH
22323: LD_INT 1
22325: ARRAY
22326: PPUSH
22327: NOP4
22331: PUSH
22332: LD_INT 2
22334: ARRAY
22335: PPUSH
22336: NOP4
22340: IFFALSE 22371
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
22342: NOP4
22346: PPUSH
22347: NOP4
22351: PUSH
22352: LD_INT 1
22354: ARRAY
22355: PPUSH
22356: NOP4
22360: PUSH
22361: LD_INT 2
22363: ARRAY
22364: PPUSH
22365: NOP4
// continue ;
22369: GO 21861
// end ; end ; r := GetDir ( tmp ) ;
22371: NOP4
22375: PUSH
22376: NOP4
22380: PPUSH
22381: NOP4
22385: ST_TO_ADDR
// if r = 5 then
22386: NOP4
22390: PUSH
22391: LD_INT 5
22393: EQUAL
22394: IFFALSE 22404
// r := 0 ;
22396: NOP4
22400: PUSH
22401: LD_INT 0
22403: ST_TO_ADDR
// for j = r to 5 do
22404: NOP4
22408: PUSH
22409: DOUBLE
22410: NOP4
22414: DEC
22415: ST_TO_ADDR
22416: LD_INT 5
22418: PUSH
22419: FOR_TO
22420: IFFALSE 22534
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
22422: NOP4
22426: PUSH
22427: NOP4
22431: PPUSH
22432: NOP4
22436: PPUSH
22437: NOP4
22441: PPUSH
22442: LD_INT 2
22444: PPUSH
22445: NOP4
22449: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
22450: NOP4
22454: PUSH
22455: NOP4
22459: PPUSH
22460: NOP4
22464: PPUSH
22465: NOP4
22469: PPUSH
22470: LD_INT 2
22472: PPUSH
22473: NOP4
22477: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
22478: NOP4
22482: PPUSH
22483: NOP4
22487: PPUSH
22488: NOP4
22492: PUSH
22493: NOP4
22497: PPUSH
22498: NOP4
22502: PPUSH
22503: NOP4
22507: NOT
22508: AND
22509: IFFALSE 22532
// begin ComMoveXY ( tmp , _x , _y ) ;
22511: NOP4
22515: PPUSH
22516: NOP4
22520: PPUSH
22521: NOP4
22525: PPUSH
22526: NOP4
// break ;
22530: GO 22534
// end ; end ;
22532: GO 22419
22534: POP
22535: POP
// end ; end ;
22536: GO 21861
22538: POP
22539: POP
// end ;
22540: LD_VAR 0 8
22544: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
22545: LD_INT 0
22547: PPUSH
22548: PPUSH
22549: PPUSH
22550: PPUSH
22551: PPUSH
22552: PPUSH
22553: PPUSH
22554: PPUSH
22555: PPUSH
22556: PPUSH
// result := false ;
22557: NOP4
22561: PUSH
22562: LD_INT 0
22564: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22565: NOP4
22569: NOT
22570: PUSH
22571: NOP4
22575: PPUSH
22576: NOP4
22580: PUSH
22581: LD_INT 0
22583: PUSH
22584: LD_INT 1
22586: PUSH
22587: EMPTY
22588: LIST
22589: LIST
22590: IN
22591: NOT
22592: OR
22593: PUSH
22594: NOP4
22598: NOT
22599: OR
22600: PUSH
22601: NOP4
22605: PUSH
22606: LD_INT 0
22608: PUSH
22609: LD_INT 1
22611: PUSH
22612: LD_INT 2
22614: PUSH
22615: LD_INT 3
22617: PUSH
22618: LD_INT 4
22620: PUSH
22621: LD_INT 5
22623: PUSH
22624: EMPTY
22625: LIST
22626: LIST
22627: LIST
22628: LIST
22629: LIST
22630: LIST
22631: IN
22632: NOT
22633: OR
22634: PUSH
22635: NOP4
22639: PPUSH
22640: NOP4
22644: PPUSH
22645: NOP4
22649: NOT
22650: OR
22651: IFFALSE 22655
// exit ;
22653: GO 23372
// pom := GetBase ( depot ) ;
22655: NOP4
22659: PUSH
22660: NOP4
22664: PPUSH
22665: NOP4
22669: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
22670: NOP4
22674: PUSH
22675: NOP4
22679: PPUSH
22680: NOP4
22684: PPUSH
22685: NOP4
22689: PPUSH
22690: NOP4
22694: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
22695: NOP4
22699: PPUSH
22700: LD_INT 1
22702: PPUSH
22703: NOP4
22707: PUSH
22708: NOP4
22712: PUSH
22713: LD_INT 1
22715: ARRAY
22716: GREATEREQUAL
22717: PUSH
22718: NOP4
22722: PPUSH
22723: LD_INT 2
22725: PPUSH
22726: NOP4
22730: PUSH
22731: NOP4
22735: PUSH
22736: LD_INT 2
22738: ARRAY
22739: GREATEREQUAL
22740: AND
22741: PUSH
22742: NOP4
22746: PPUSH
22747: LD_INT 3
22749: PPUSH
22750: NOP4
22754: PUSH
22755: NOP4
22759: PUSH
22760: LD_INT 3
22762: ARRAY
22763: GREATEREQUAL
22764: AND
22765: NOT
22766: IFFALSE 22770
// exit ;
22768: GO 23372
// if GetBType ( depot ) = b_depot then
22770: NOP4
22774: PPUSH
22775: NOP4
22779: PUSH
22780: LD_INT 0
22782: EQUAL
22783: IFFALSE 22795
// dist := 28 else
22785: NOP4
22789: PUSH
22790: LD_INT 28
22792: ST_TO_ADDR
22793: GO 22803
// dist := 36 ;
22795: NOP4
22799: PUSH
22800: LD_INT 36
22802: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
22803: NOP4
22807: PPUSH
22808: NOP4
22812: PPUSH
22813: NOP4
22817: PPUSH
22818: NOP4
22822: PUSH
22823: NOP4
22827: GREATER
22828: IFFALSE 22832
// exit ;
22830: GO 23372
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
22832: NOP4
22836: PUSH
22837: NOP4
22841: PPUSH
22842: NOP4
22846: PPUSH
22847: NOP4
22851: PPUSH
22852: NOP4
22856: PPUSH
22857: NOP4
22861: PPUSH
22862: NOP4
22866: PPUSH
22867: LD_INT 0
22869: PPUSH
22870: NOP4
22874: ST_TO_ADDR
// if not hexes then
22875: NOP4
22879: NOT
22880: IFFALSE 22884
// exit ;
22882: GO 23372
// hex := GetHexInfo ( x , y ) ;
22884: NOP4
22888: PUSH
22889: NOP4
22893: PPUSH
22894: NOP4
22898: PPUSH
22899: NOP4
22903: ST_TO_ADDR
// if hex [ 1 ] then
22904: NOP4
22908: PUSH
22909: LD_INT 1
22911: ARRAY
22912: IFFALSE 22916
// exit ;
22914: GO 23372
// height := hex [ 2 ] ;
22916: NOP4
22920: PUSH
22921: NOP4
22925: PUSH
22926: LD_INT 2
22928: ARRAY
22929: ST_TO_ADDR
// for i = 1 to hexes do
22930: NOP4
22934: PUSH
22935: DOUBLE
22936: LD_INT 1
22938: DEC
22939: ST_TO_ADDR
22940: NOP4
22944: PUSH
22945: FOR_TO
22946: IFFALSE 23276
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
22948: NOP4
22952: PUSH
22953: NOP4
22957: ARRAY
22958: PUSH
22959: LD_INT 1
22961: ARRAY
22962: PPUSH
22963: NOP4
22967: PUSH
22968: NOP4
22972: ARRAY
22973: PUSH
22974: LD_INT 2
22976: ARRAY
22977: PPUSH
22978: NOP4
22982: NOT
22983: PUSH
22984: NOP4
22988: PUSH
22989: NOP4
22993: ARRAY
22994: PUSH
22995: LD_INT 1
22997: ARRAY
22998: PPUSH
22999: NOP4
23003: PUSH
23004: NOP4
23008: ARRAY
23009: PUSH
23010: LD_INT 2
23012: ARRAY
23013: PPUSH
23014: NOP4
23018: PUSH
23019: LD_INT 0
23021: GREATER
23022: OR
23023: PUSH
23024: NOP4
23028: PUSH
23029: NOP4
23033: ARRAY
23034: PUSH
23035: LD_INT 1
23037: ARRAY
23038: PPUSH
23039: NOP4
23043: PUSH
23044: NOP4
23048: ARRAY
23049: PUSH
23050: LD_INT 2
23052: ARRAY
23053: PPUSH
23054: NOP4
23058: OR
23059: IFFALSE 23065
// exit ;
23061: POP
23062: POP
23063: GO 23372
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23065: NOP4
23069: PUSH
23070: NOP4
23074: PUSH
23075: NOP4
23079: ARRAY
23080: PUSH
23081: LD_INT 1
23083: ARRAY
23084: PPUSH
23085: NOP4
23089: PUSH
23090: NOP4
23094: ARRAY
23095: PUSH
23096: LD_INT 2
23098: ARRAY
23099: PPUSH
23100: NOP4
23104: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
23105: NOP4
23109: PUSH
23110: LD_INT 1
23112: ARRAY
23113: PUSH
23114: NOP4
23118: PUSH
23119: LD_INT 2
23121: ARRAY
23122: PUSH
23123: NOP4
23127: PUSH
23128: LD_INT 2
23130: PLUS
23131: GREATER
23132: OR
23133: PUSH
23134: NOP4
23138: PUSH
23139: LD_INT 2
23141: ARRAY
23142: PUSH
23143: NOP4
23147: PUSH
23148: LD_INT 2
23150: MINUS
23151: LESS
23152: OR
23153: PUSH
23154: NOP4
23158: PUSH
23159: LD_INT 3
23161: ARRAY
23162: PUSH
23163: LD_INT 0
23165: PUSH
23166: LD_INT 8
23168: PUSH
23169: LD_INT 9
23171: PUSH
23172: LD_INT 10
23174: PUSH
23175: LD_INT 11
23177: PUSH
23178: LD_INT 12
23180: PUSH
23181: LD_INT 13
23183: PUSH
23184: LD_INT 16
23186: PUSH
23187: LD_INT 17
23189: PUSH
23190: LD_INT 18
23192: PUSH
23193: LD_INT 19
23195: PUSH
23196: LD_INT 20
23198: PUSH
23199: LD_INT 21
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: LIST
23206: LIST
23207: LIST
23208: LIST
23209: LIST
23210: LIST
23211: LIST
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: IN
23217: NOT
23218: OR
23219: PUSH
23220: NOP4
23224: PUSH
23225: LD_INT 5
23227: ARRAY
23228: NOT
23229: OR
23230: PUSH
23231: NOP4
23235: PUSH
23236: LD_INT 6
23238: ARRAY
23239: PUSH
23240: LD_INT 1
23242: PUSH
23243: LD_INT 2
23245: PUSH
23246: LD_INT 7
23248: PUSH
23249: LD_INT 9
23251: PUSH
23252: LD_INT 10
23254: PUSH
23255: LD_INT 11
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: IN
23266: NOT
23267: OR
23268: IFFALSE 23274
// exit ;
23270: POP
23271: POP
23272: GO 23372
// end ;
23274: GO 22945
23276: POP
23277: POP
// side := GetSide ( depot ) ;
23278: NOP4
23282: PUSH
23283: NOP4
23287: PPUSH
23288: NOP4
23292: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
23293: NOP4
23297: PPUSH
23298: NOP4
23302: PPUSH
23303: NOP4
23307: PPUSH
23308: LD_INT 20
23310: PPUSH
23311: NOP4
23315: PUSH
23316: LD_INT 4
23318: ARRAY
23319: IFFALSE 23323
// exit ;
23321: GO 23372
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
23323: NOP4
23327: PUSH
23328: LD_INT 29
23330: PUSH
23331: LD_INT 30
23333: PUSH
23334: EMPTY
23335: LIST
23336: LIST
23337: IN
23338: PUSH
23339: NOP4
23343: PPUSH
23344: NOP4
23348: PPUSH
23349: NOP4
23353: PPUSH
23354: NOP4
23358: NOT
23359: AND
23360: IFFALSE 23364
// exit ;
23362: GO 23372
// result := true ;
23364: NOP4
23368: PUSH
23369: LD_INT 1
23371: ST_TO_ADDR
// end ;
23372: LD_VAR 0 6
23376: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23377: LD_INT 0
23379: PPUSH
23380: PPUSH
23381: PPUSH
23382: PPUSH
23383: PPUSH
23384: PPUSH
23385: PPUSH
23386: PPUSH
23387: PPUSH
23388: PPUSH
23389: PPUSH
23390: PPUSH
23391: PPUSH
23392: PPUSH
23393: PPUSH
23394: PPUSH
23395: PPUSH
23396: PPUSH
23397: PPUSH
23398: PPUSH
23399: PPUSH
23400: PPUSH
23401: PPUSH
23402: PPUSH
23403: PPUSH
23404: PPUSH
23405: PPUSH
23406: PPUSH
23407: PPUSH
23408: PPUSH
23409: PPUSH
23410: PPUSH
23411: PPUSH
23412: PPUSH
23413: PPUSH
23414: PPUSH
23415: PPUSH
23416: PPUSH
23417: PPUSH
23418: PPUSH
23419: PPUSH
23420: PPUSH
23421: PPUSH
23422: PPUSH
23423: PPUSH
23424: PPUSH
23425: PPUSH
23426: PPUSH
23427: PPUSH
23428: PPUSH
23429: PPUSH
23430: PPUSH
23431: PPUSH
23432: PPUSH
23433: PPUSH
23434: PPUSH
23435: PPUSH
23436: PPUSH
// result = [ ] ;
23437: NOP4
23441: PUSH
23442: EMPTY
23443: ST_TO_ADDR
// temp_list = [ ] ;
23444: NOP4
23448: PUSH
23449: EMPTY
23450: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23451: NOP4
23455: PUSH
23456: LD_INT 0
23458: PUSH
23459: LD_INT 1
23461: PUSH
23462: LD_INT 2
23464: PUSH
23465: LD_INT 3
23467: PUSH
23468: LD_INT 4
23470: PUSH
23471: LD_INT 5
23473: PUSH
23474: EMPTY
23475: LIST
23476: LIST
23477: LIST
23478: LIST
23479: LIST
23480: LIST
23481: IN
23482: NOT
23483: PUSH
23484: NOP4
23488: PUSH
23489: LD_INT 0
23491: PUSH
23492: LD_INT 1
23494: PUSH
23495: EMPTY
23496: LIST
23497: LIST
23498: IN
23499: PUSH
23500: NOP4
23504: PUSH
23505: LD_INT 1
23507: PUSH
23508: LD_INT 2
23510: PUSH
23511: LD_INT 3
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: LIST
23518: IN
23519: NOT
23520: AND
23521: OR
23522: IFFALSE 23526
// exit ;
23524: GO 41917
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23526: NOP4
23530: PUSH
23531: LD_INT 6
23533: PUSH
23534: LD_INT 7
23536: PUSH
23537: LD_INT 8
23539: PUSH
23540: LD_INT 13
23542: PUSH
23543: LD_INT 12
23545: PUSH
23546: LD_INT 15
23548: PUSH
23549: LD_INT 11
23551: PUSH
23552: LD_INT 14
23554: PUSH
23555: LD_INT 10
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: LIST
23562: LIST
23563: LIST
23564: LIST
23565: LIST
23566: LIST
23567: LIST
23568: IN
23569: IFFALSE 23579
// btype = b_lab ;
23571: NOP4
23575: PUSH
23576: LD_INT 6
23578: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23579: NOP4
23583: PUSH
23584: LD_INT 0
23586: PUSH
23587: LD_INT 1
23589: PUSH
23590: LD_INT 2
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: LIST
23597: IN
23598: NOT
23599: PUSH
23600: NOP4
23604: PUSH
23605: LD_INT 0
23607: PUSH
23608: LD_INT 1
23610: PUSH
23611: LD_INT 2
23613: PUSH
23614: LD_INT 3
23616: PUSH
23617: LD_INT 6
23619: PUSH
23620: LD_INT 36
23622: PUSH
23623: LD_INT 4
23625: PUSH
23626: LD_INT 5
23628: PUSH
23629: LD_INT 31
23631: PUSH
23632: LD_INT 32
23634: PUSH
23635: LD_INT 33
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: LIST
23646: LIST
23647: LIST
23648: LIST
23649: LIST
23650: IN
23651: NOT
23652: PUSH
23653: NOP4
23657: PUSH
23658: LD_INT 1
23660: EQUAL
23661: AND
23662: OR
23663: PUSH
23664: NOP4
23668: PUSH
23669: LD_INT 2
23671: PUSH
23672: LD_INT 3
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: IN
23679: NOT
23680: PUSH
23681: NOP4
23685: PUSH
23686: LD_INT 2
23688: EQUAL
23689: AND
23690: OR
23691: IFFALSE 23701
// mode = 0 ;
23693: NOP4
23697: PUSH
23698: LD_INT 0
23700: ST_TO_ADDR
// case mode of 0 :
23701: NOP4
23705: PUSH
23706: LD_INT 0
23708: DOUBLE
23709: EQUAL
23710: IFTRUE 23714
23712: GO 35167
23714: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
23715: NOP4
23719: PUSH
23720: LD_INT 0
23722: PUSH
23723: LD_INT 0
23725: PUSH
23726: EMPTY
23727: LIST
23728: LIST
23729: PUSH
23730: LD_INT 0
23732: PUSH
23733: LD_INT 1
23735: NEG
23736: PUSH
23737: EMPTY
23738: LIST
23739: LIST
23740: PUSH
23741: LD_INT 1
23743: PUSH
23744: LD_INT 0
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: PUSH
23751: LD_INT 1
23753: PUSH
23754: LD_INT 1
23756: PUSH
23757: EMPTY
23758: LIST
23759: LIST
23760: PUSH
23761: LD_INT 0
23763: PUSH
23764: LD_INT 1
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: PUSH
23771: LD_INT 1
23773: NEG
23774: PUSH
23775: LD_INT 0
23777: PUSH
23778: EMPTY
23779: LIST
23780: LIST
23781: PUSH
23782: LD_INT 1
23784: NEG
23785: PUSH
23786: LD_INT 1
23788: NEG
23789: PUSH
23790: EMPTY
23791: LIST
23792: LIST
23793: PUSH
23794: LD_INT 1
23796: NEG
23797: PUSH
23798: LD_INT 2
23800: NEG
23801: PUSH
23802: EMPTY
23803: LIST
23804: LIST
23805: PUSH
23806: LD_INT 0
23808: PUSH
23809: LD_INT 2
23811: NEG
23812: PUSH
23813: EMPTY
23814: LIST
23815: LIST
23816: PUSH
23817: LD_INT 1
23819: PUSH
23820: LD_INT 1
23822: NEG
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PUSH
23828: LD_INT 1
23830: PUSH
23831: LD_INT 2
23833: PUSH
23834: EMPTY
23835: LIST
23836: LIST
23837: PUSH
23838: LD_INT 0
23840: PUSH
23841: LD_INT 2
23843: PUSH
23844: EMPTY
23845: LIST
23846: LIST
23847: PUSH
23848: LD_INT 1
23850: NEG
23851: PUSH
23852: LD_INT 1
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: PUSH
23859: LD_INT 1
23861: PUSH
23862: LD_INT 3
23864: PUSH
23865: EMPTY
23866: LIST
23867: LIST
23868: PUSH
23869: LD_INT 0
23871: PUSH
23872: LD_INT 3
23874: PUSH
23875: EMPTY
23876: LIST
23877: LIST
23878: PUSH
23879: LD_INT 1
23881: NEG
23882: PUSH
23883: LD_INT 2
23885: PUSH
23886: EMPTY
23887: LIST
23888: LIST
23889: PUSH
23890: EMPTY
23891: LIST
23892: LIST
23893: LIST
23894: LIST
23895: LIST
23896: LIST
23897: LIST
23898: LIST
23899: LIST
23900: LIST
23901: LIST
23902: LIST
23903: LIST
23904: LIST
23905: LIST
23906: LIST
23907: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
23908: NOP4
23912: PUSH
23913: LD_INT 0
23915: PUSH
23916: LD_INT 0
23918: PUSH
23919: EMPTY
23920: LIST
23921: LIST
23922: PUSH
23923: LD_INT 0
23925: PUSH
23926: LD_INT 1
23928: NEG
23929: PUSH
23930: EMPTY
23931: LIST
23932: LIST
23933: PUSH
23934: LD_INT 1
23936: PUSH
23937: LD_INT 0
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PUSH
23944: LD_INT 1
23946: PUSH
23947: LD_INT 1
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: PUSH
23954: LD_INT 0
23956: PUSH
23957: LD_INT 1
23959: PUSH
23960: EMPTY
23961: LIST
23962: LIST
23963: PUSH
23964: LD_INT 1
23966: NEG
23967: PUSH
23968: LD_INT 0
23970: PUSH
23971: EMPTY
23972: LIST
23973: LIST
23974: PUSH
23975: LD_INT 1
23977: NEG
23978: PUSH
23979: LD_INT 1
23981: NEG
23982: PUSH
23983: EMPTY
23984: LIST
23985: LIST
23986: PUSH
23987: LD_INT 1
23989: PUSH
23990: LD_INT 1
23992: NEG
23993: PUSH
23994: EMPTY
23995: LIST
23996: LIST
23997: PUSH
23998: LD_INT 2
24000: PUSH
24001: LD_INT 0
24003: PUSH
24004: EMPTY
24005: LIST
24006: LIST
24007: PUSH
24008: LD_INT 2
24010: PUSH
24011: LD_INT 1
24013: PUSH
24014: EMPTY
24015: LIST
24016: LIST
24017: PUSH
24018: LD_INT 1
24020: NEG
24021: PUSH
24022: LD_INT 1
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 2
24031: NEG
24032: PUSH
24033: LD_INT 0
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: PUSH
24040: LD_INT 2
24042: NEG
24043: PUSH
24044: LD_INT 1
24046: NEG
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: PUSH
24052: LD_INT 2
24054: NEG
24055: PUSH
24056: LD_INT 1
24058: PUSH
24059: EMPTY
24060: LIST
24061: LIST
24062: PUSH
24063: LD_INT 3
24065: NEG
24066: PUSH
24067: LD_INT 0
24069: PUSH
24070: EMPTY
24071: LIST
24072: LIST
24073: PUSH
24074: LD_INT 3
24076: NEG
24077: PUSH
24078: LD_INT 1
24080: NEG
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: PUSH
24086: EMPTY
24087: LIST
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: LIST
24094: LIST
24095: LIST
24096: LIST
24097: LIST
24098: LIST
24099: LIST
24100: LIST
24101: LIST
24102: LIST
24103: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24104: NOP4
24108: PUSH
24109: LD_INT 0
24111: PUSH
24112: LD_INT 0
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: PUSH
24119: LD_INT 0
24121: PUSH
24122: LD_INT 1
24124: NEG
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: PUSH
24130: LD_INT 1
24132: PUSH
24133: LD_INT 0
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PUSH
24140: LD_INT 1
24142: PUSH
24143: LD_INT 1
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: LD_INT 0
24152: PUSH
24153: LD_INT 1
24155: PUSH
24156: EMPTY
24157: LIST
24158: LIST
24159: PUSH
24160: LD_INT 1
24162: NEG
24163: PUSH
24164: LD_INT 0
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PUSH
24171: LD_INT 1
24173: NEG
24174: PUSH
24175: LD_INT 1
24177: NEG
24178: PUSH
24179: EMPTY
24180: LIST
24181: LIST
24182: PUSH
24183: LD_INT 1
24185: NEG
24186: PUSH
24187: LD_INT 2
24189: NEG
24190: PUSH
24191: EMPTY
24192: LIST
24193: LIST
24194: PUSH
24195: LD_INT 2
24197: PUSH
24198: LD_INT 1
24200: PUSH
24201: EMPTY
24202: LIST
24203: LIST
24204: PUSH
24205: LD_INT 2
24207: PUSH
24208: LD_INT 2
24210: PUSH
24211: EMPTY
24212: LIST
24213: LIST
24214: PUSH
24215: LD_INT 1
24217: PUSH
24218: LD_INT 2
24220: PUSH
24221: EMPTY
24222: LIST
24223: LIST
24224: PUSH
24225: LD_INT 2
24227: NEG
24228: PUSH
24229: LD_INT 1
24231: NEG
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: PUSH
24237: LD_INT 2
24239: NEG
24240: PUSH
24241: LD_INT 2
24243: NEG
24244: PUSH
24245: EMPTY
24246: LIST
24247: LIST
24248: PUSH
24249: LD_INT 2
24251: NEG
24252: PUSH
24253: LD_INT 3
24255: NEG
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: PUSH
24261: LD_INT 3
24263: NEG
24264: PUSH
24265: LD_INT 2
24267: NEG
24268: PUSH
24269: EMPTY
24270: LIST
24271: LIST
24272: PUSH
24273: LD_INT 3
24275: NEG
24276: PUSH
24277: LD_INT 3
24279: NEG
24280: PUSH
24281: EMPTY
24282: LIST
24283: LIST
24284: PUSH
24285: EMPTY
24286: LIST
24287: LIST
24288: LIST
24289: LIST
24290: LIST
24291: LIST
24292: LIST
24293: LIST
24294: LIST
24295: LIST
24296: LIST
24297: LIST
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
24303: NOP4
24307: PUSH
24308: LD_INT 0
24310: PUSH
24311: LD_INT 0
24313: PUSH
24314: EMPTY
24315: LIST
24316: LIST
24317: PUSH
24318: LD_INT 0
24320: PUSH
24321: LD_INT 1
24323: NEG
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: LD_INT 1
24331: PUSH
24332: LD_INT 0
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: LD_INT 1
24341: PUSH
24342: LD_INT 1
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 0
24351: PUSH
24352: LD_INT 1
24354: PUSH
24355: EMPTY
24356: LIST
24357: LIST
24358: PUSH
24359: LD_INT 1
24361: NEG
24362: PUSH
24363: LD_INT 0
24365: PUSH
24366: EMPTY
24367: LIST
24368: LIST
24369: PUSH
24370: LD_INT 1
24372: NEG
24373: PUSH
24374: LD_INT 1
24376: NEG
24377: PUSH
24378: EMPTY
24379: LIST
24380: LIST
24381: PUSH
24382: LD_INT 1
24384: NEG
24385: PUSH
24386: LD_INT 2
24388: NEG
24389: PUSH
24390: EMPTY
24391: LIST
24392: LIST
24393: PUSH
24394: LD_INT 0
24396: PUSH
24397: LD_INT 2
24399: NEG
24400: PUSH
24401: EMPTY
24402: LIST
24403: LIST
24404: PUSH
24405: LD_INT 1
24407: PUSH
24408: LD_INT 1
24410: NEG
24411: PUSH
24412: EMPTY
24413: LIST
24414: LIST
24415: PUSH
24416: LD_INT 1
24418: PUSH
24419: LD_INT 2
24421: PUSH
24422: EMPTY
24423: LIST
24424: LIST
24425: PUSH
24426: LD_INT 0
24428: PUSH
24429: LD_INT 2
24431: PUSH
24432: EMPTY
24433: LIST
24434: LIST
24435: PUSH
24436: LD_INT 1
24438: NEG
24439: PUSH
24440: LD_INT 1
24442: PUSH
24443: EMPTY
24444: LIST
24445: LIST
24446: PUSH
24447: LD_INT 1
24449: NEG
24450: PUSH
24451: LD_INT 3
24453: NEG
24454: PUSH
24455: EMPTY
24456: LIST
24457: LIST
24458: PUSH
24459: LD_INT 0
24461: PUSH
24462: LD_INT 3
24464: NEG
24465: PUSH
24466: EMPTY
24467: LIST
24468: LIST
24469: PUSH
24470: LD_INT 1
24472: PUSH
24473: LD_INT 2
24475: NEG
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: LIST
24485: LIST
24486: LIST
24487: LIST
24488: LIST
24489: LIST
24490: LIST
24491: LIST
24492: LIST
24493: LIST
24494: LIST
24495: LIST
24496: LIST
24497: LIST
24498: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24499: NOP4
24503: PUSH
24504: LD_INT 0
24506: PUSH
24507: LD_INT 0
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 0
24516: PUSH
24517: LD_INT 1
24519: NEG
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PUSH
24525: LD_INT 1
24527: PUSH
24528: LD_INT 0
24530: PUSH
24531: EMPTY
24532: LIST
24533: LIST
24534: PUSH
24535: LD_INT 1
24537: PUSH
24538: LD_INT 1
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: PUSH
24545: LD_INT 0
24547: PUSH
24548: LD_INT 1
24550: PUSH
24551: EMPTY
24552: LIST
24553: LIST
24554: PUSH
24555: LD_INT 1
24557: NEG
24558: PUSH
24559: LD_INT 0
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PUSH
24566: LD_INT 1
24568: NEG
24569: PUSH
24570: LD_INT 1
24572: NEG
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PUSH
24578: LD_INT 1
24580: PUSH
24581: LD_INT 1
24583: NEG
24584: PUSH
24585: EMPTY
24586: LIST
24587: LIST
24588: PUSH
24589: LD_INT 2
24591: PUSH
24592: LD_INT 0
24594: PUSH
24595: EMPTY
24596: LIST
24597: LIST
24598: PUSH
24599: LD_INT 2
24601: PUSH
24602: LD_INT 1
24604: PUSH
24605: EMPTY
24606: LIST
24607: LIST
24608: PUSH
24609: LD_INT 1
24611: NEG
24612: PUSH
24613: LD_INT 1
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 2
24622: NEG
24623: PUSH
24624: LD_INT 0
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: LD_INT 2
24633: NEG
24634: PUSH
24635: LD_INT 1
24637: NEG
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: PUSH
24643: LD_INT 2
24645: PUSH
24646: LD_INT 1
24648: NEG
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: PUSH
24654: LD_INT 3
24656: PUSH
24657: LD_INT 0
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: PUSH
24664: LD_INT 3
24666: PUSH
24667: LD_INT 1
24669: PUSH
24670: EMPTY
24671: LIST
24672: LIST
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: LIST
24678: LIST
24679: LIST
24680: LIST
24681: LIST
24682: LIST
24683: LIST
24684: LIST
24685: LIST
24686: LIST
24687: LIST
24688: LIST
24689: LIST
24690: LIST
24691: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
24692: NOP4
24696: PUSH
24697: LD_INT 0
24699: PUSH
24700: LD_INT 0
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: LD_INT 0
24709: PUSH
24710: LD_INT 1
24712: NEG
24713: PUSH
24714: EMPTY
24715: LIST
24716: LIST
24717: PUSH
24718: LD_INT 1
24720: PUSH
24721: LD_INT 0
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: PUSH
24728: LD_INT 1
24730: PUSH
24731: LD_INT 1
24733: PUSH
24734: EMPTY
24735: LIST
24736: LIST
24737: PUSH
24738: LD_INT 0
24740: PUSH
24741: LD_INT 1
24743: PUSH
24744: EMPTY
24745: LIST
24746: LIST
24747: PUSH
24748: LD_INT 1
24750: NEG
24751: PUSH
24752: LD_INT 0
24754: PUSH
24755: EMPTY
24756: LIST
24757: LIST
24758: PUSH
24759: LD_INT 1
24761: NEG
24762: PUSH
24763: LD_INT 1
24765: NEG
24766: PUSH
24767: EMPTY
24768: LIST
24769: LIST
24770: PUSH
24771: LD_INT 1
24773: NEG
24774: PUSH
24775: LD_INT 2
24777: NEG
24778: PUSH
24779: EMPTY
24780: LIST
24781: LIST
24782: PUSH
24783: LD_INT 2
24785: PUSH
24786: LD_INT 1
24788: PUSH
24789: EMPTY
24790: LIST
24791: LIST
24792: PUSH
24793: LD_INT 2
24795: PUSH
24796: LD_INT 2
24798: PUSH
24799: EMPTY
24800: LIST
24801: LIST
24802: PUSH
24803: LD_INT 1
24805: PUSH
24806: LD_INT 2
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: PUSH
24813: LD_INT 2
24815: NEG
24816: PUSH
24817: LD_INT 1
24819: NEG
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 2
24827: NEG
24828: PUSH
24829: LD_INT 2
24831: NEG
24832: PUSH
24833: EMPTY
24834: LIST
24835: LIST
24836: PUSH
24837: LD_INT 3
24839: PUSH
24840: LD_INT 2
24842: PUSH
24843: EMPTY
24844: LIST
24845: LIST
24846: PUSH
24847: LD_INT 3
24849: PUSH
24850: LD_INT 3
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: PUSH
24857: LD_INT 2
24859: PUSH
24860: LD_INT 3
24862: PUSH
24863: EMPTY
24864: LIST
24865: LIST
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: LIST
24871: LIST
24872: LIST
24873: LIST
24874: LIST
24875: LIST
24876: LIST
24877: LIST
24878: LIST
24879: LIST
24880: LIST
24881: LIST
24882: LIST
24883: LIST
24884: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24885: NOP4
24889: PUSH
24890: LD_INT 0
24892: PUSH
24893: LD_INT 0
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PUSH
24900: LD_INT 0
24902: PUSH
24903: LD_INT 1
24905: NEG
24906: PUSH
24907: EMPTY
24908: LIST
24909: LIST
24910: PUSH
24911: LD_INT 1
24913: PUSH
24914: LD_INT 0
24916: PUSH
24917: EMPTY
24918: LIST
24919: LIST
24920: PUSH
24921: LD_INT 1
24923: PUSH
24924: LD_INT 1
24926: PUSH
24927: EMPTY
24928: LIST
24929: LIST
24930: PUSH
24931: LD_INT 0
24933: PUSH
24934: LD_INT 1
24936: PUSH
24937: EMPTY
24938: LIST
24939: LIST
24940: PUSH
24941: LD_INT 1
24943: NEG
24944: PUSH
24945: LD_INT 0
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PUSH
24952: LD_INT 1
24954: NEG
24955: PUSH
24956: LD_INT 1
24958: NEG
24959: PUSH
24960: EMPTY
24961: LIST
24962: LIST
24963: PUSH
24964: LD_INT 1
24966: NEG
24967: PUSH
24968: LD_INT 2
24970: NEG
24971: PUSH
24972: EMPTY
24973: LIST
24974: LIST
24975: PUSH
24976: LD_INT 0
24978: PUSH
24979: LD_INT 2
24981: NEG
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PUSH
24987: LD_INT 1
24989: PUSH
24990: LD_INT 1
24992: NEG
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PUSH
24998: LD_INT 2
25000: PUSH
25001: LD_INT 0
25003: PUSH
25004: EMPTY
25005: LIST
25006: LIST
25007: PUSH
25008: LD_INT 2
25010: PUSH
25011: LD_INT 1
25013: PUSH
25014: EMPTY
25015: LIST
25016: LIST
25017: PUSH
25018: LD_INT 2
25020: PUSH
25021: LD_INT 2
25023: PUSH
25024: EMPTY
25025: LIST
25026: LIST
25027: PUSH
25028: LD_INT 1
25030: PUSH
25031: LD_INT 2
25033: PUSH
25034: EMPTY
25035: LIST
25036: LIST
25037: PUSH
25038: LD_INT 0
25040: PUSH
25041: LD_INT 2
25043: PUSH
25044: EMPTY
25045: LIST
25046: LIST
25047: PUSH
25048: LD_INT 1
25050: NEG
25051: PUSH
25052: LD_INT 1
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: LD_INT 2
25061: NEG
25062: PUSH
25063: LD_INT 0
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: PUSH
25070: LD_INT 2
25072: NEG
25073: PUSH
25074: LD_INT 1
25076: NEG
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 2
25084: NEG
25085: PUSH
25086: LD_INT 2
25088: NEG
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: PUSH
25094: EMPTY
25095: LIST
25096: LIST
25097: LIST
25098: LIST
25099: LIST
25100: LIST
25101: LIST
25102: LIST
25103: LIST
25104: LIST
25105: LIST
25106: LIST
25107: LIST
25108: LIST
25109: LIST
25110: LIST
25111: LIST
25112: LIST
25113: LIST
25114: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25115: NOP4
25119: PUSH
25120: LD_INT 0
25122: PUSH
25123: LD_INT 0
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: PUSH
25130: LD_INT 0
25132: PUSH
25133: LD_INT 1
25135: NEG
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PUSH
25141: LD_INT 1
25143: PUSH
25144: LD_INT 0
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: PUSH
25151: LD_INT 1
25153: PUSH
25154: LD_INT 1
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: PUSH
25161: LD_INT 0
25163: PUSH
25164: LD_INT 1
25166: PUSH
25167: EMPTY
25168: LIST
25169: LIST
25170: PUSH
25171: LD_INT 1
25173: NEG
25174: PUSH
25175: LD_INT 0
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 1
25184: NEG
25185: PUSH
25186: LD_INT 1
25188: NEG
25189: PUSH
25190: EMPTY
25191: LIST
25192: LIST
25193: PUSH
25194: LD_INT 1
25196: NEG
25197: PUSH
25198: LD_INT 2
25200: NEG
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: PUSH
25206: LD_INT 0
25208: PUSH
25209: LD_INT 2
25211: NEG
25212: PUSH
25213: EMPTY
25214: LIST
25215: LIST
25216: PUSH
25217: LD_INT 1
25219: PUSH
25220: LD_INT 1
25222: NEG
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: PUSH
25228: LD_INT 2
25230: PUSH
25231: LD_INT 0
25233: PUSH
25234: EMPTY
25235: LIST
25236: LIST
25237: PUSH
25238: LD_INT 2
25240: PUSH
25241: LD_INT 1
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: LD_INT 2
25250: PUSH
25251: LD_INT 2
25253: PUSH
25254: EMPTY
25255: LIST
25256: LIST
25257: PUSH
25258: LD_INT 1
25260: PUSH
25261: LD_INT 2
25263: PUSH
25264: EMPTY
25265: LIST
25266: LIST
25267: PUSH
25268: LD_INT 0
25270: PUSH
25271: LD_INT 2
25273: PUSH
25274: EMPTY
25275: LIST
25276: LIST
25277: PUSH
25278: LD_INT 1
25280: NEG
25281: PUSH
25282: LD_INT 1
25284: PUSH
25285: EMPTY
25286: LIST
25287: LIST
25288: PUSH
25289: LD_INT 2
25291: NEG
25292: PUSH
25293: LD_INT 0
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 2
25302: NEG
25303: PUSH
25304: LD_INT 1
25306: NEG
25307: PUSH
25308: EMPTY
25309: LIST
25310: LIST
25311: PUSH
25312: LD_INT 2
25314: NEG
25315: PUSH
25316: LD_INT 2
25318: NEG
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: LIST
25328: LIST
25329: LIST
25330: LIST
25331: LIST
25332: LIST
25333: LIST
25334: LIST
25335: LIST
25336: LIST
25337: LIST
25338: LIST
25339: LIST
25340: LIST
25341: LIST
25342: LIST
25343: LIST
25344: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25345: NOP4
25349: PUSH
25350: LD_INT 0
25352: PUSH
25353: LD_INT 0
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: LD_INT 0
25362: PUSH
25363: LD_INT 1
25365: NEG
25366: PUSH
25367: EMPTY
25368: LIST
25369: LIST
25370: PUSH
25371: LD_INT 1
25373: PUSH
25374: LD_INT 0
25376: PUSH
25377: EMPTY
25378: LIST
25379: LIST
25380: PUSH
25381: LD_INT 1
25383: PUSH
25384: LD_INT 1
25386: PUSH
25387: EMPTY
25388: LIST
25389: LIST
25390: PUSH
25391: LD_INT 0
25393: PUSH
25394: LD_INT 1
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: PUSH
25401: LD_INT 1
25403: NEG
25404: PUSH
25405: LD_INT 0
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 1
25414: NEG
25415: PUSH
25416: LD_INT 1
25418: NEG
25419: PUSH
25420: EMPTY
25421: LIST
25422: LIST
25423: PUSH
25424: LD_INT 1
25426: NEG
25427: PUSH
25428: LD_INT 2
25430: NEG
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: PUSH
25436: LD_INT 0
25438: PUSH
25439: LD_INT 2
25441: NEG
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: PUSH
25447: LD_INT 1
25449: PUSH
25450: LD_INT 1
25452: NEG
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: LD_INT 2
25460: PUSH
25461: LD_INT 0
25463: PUSH
25464: EMPTY
25465: LIST
25466: LIST
25467: PUSH
25468: LD_INT 2
25470: PUSH
25471: LD_INT 1
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: PUSH
25478: LD_INT 2
25480: PUSH
25481: LD_INT 2
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: PUSH
25488: LD_INT 1
25490: PUSH
25491: LD_INT 2
25493: PUSH
25494: EMPTY
25495: LIST
25496: LIST
25497: PUSH
25498: LD_INT 0
25500: PUSH
25501: LD_INT 2
25503: PUSH
25504: EMPTY
25505: LIST
25506: LIST
25507: PUSH
25508: LD_INT 1
25510: NEG
25511: PUSH
25512: LD_INT 1
25514: PUSH
25515: EMPTY
25516: LIST
25517: LIST
25518: PUSH
25519: LD_INT 2
25521: NEG
25522: PUSH
25523: LD_INT 0
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 2
25532: NEG
25533: PUSH
25534: LD_INT 1
25536: NEG
25537: PUSH
25538: EMPTY
25539: LIST
25540: LIST
25541: PUSH
25542: LD_INT 2
25544: NEG
25545: PUSH
25546: LD_INT 2
25548: NEG
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: EMPTY
25555: LIST
25556: LIST
25557: LIST
25558: LIST
25559: LIST
25560: LIST
25561: LIST
25562: LIST
25563: LIST
25564: LIST
25565: LIST
25566: LIST
25567: LIST
25568: LIST
25569: LIST
25570: LIST
25571: LIST
25572: LIST
25573: LIST
25574: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25575: NOP4
25579: PUSH
25580: LD_INT 0
25582: PUSH
25583: LD_INT 0
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: LD_INT 0
25592: PUSH
25593: LD_INT 1
25595: NEG
25596: PUSH
25597: EMPTY
25598: LIST
25599: LIST
25600: PUSH
25601: LD_INT 1
25603: PUSH
25604: LD_INT 0
25606: PUSH
25607: EMPTY
25608: LIST
25609: LIST
25610: PUSH
25611: LD_INT 1
25613: PUSH
25614: LD_INT 1
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 0
25623: PUSH
25624: LD_INT 1
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 1
25633: NEG
25634: PUSH
25635: LD_INT 0
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 1
25644: NEG
25645: PUSH
25646: LD_INT 1
25648: NEG
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: LD_INT 1
25656: NEG
25657: PUSH
25658: LD_INT 2
25660: NEG
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: PUSH
25666: LD_INT 0
25668: PUSH
25669: LD_INT 2
25671: NEG
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: PUSH
25677: LD_INT 1
25679: PUSH
25680: LD_INT 1
25682: NEG
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 2
25690: PUSH
25691: LD_INT 0
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 2
25700: PUSH
25701: LD_INT 1
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: LD_INT 2
25710: PUSH
25711: LD_INT 2
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PUSH
25718: LD_INT 1
25720: PUSH
25721: LD_INT 2
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: PUSH
25728: LD_INT 0
25730: PUSH
25731: LD_INT 2
25733: PUSH
25734: EMPTY
25735: LIST
25736: LIST
25737: PUSH
25738: LD_INT 1
25740: NEG
25741: PUSH
25742: LD_INT 1
25744: PUSH
25745: EMPTY
25746: LIST
25747: LIST
25748: PUSH
25749: LD_INT 2
25751: NEG
25752: PUSH
25753: LD_INT 0
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: LD_INT 2
25762: NEG
25763: PUSH
25764: LD_INT 1
25766: NEG
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: PUSH
25772: LD_INT 2
25774: NEG
25775: PUSH
25776: LD_INT 2
25778: NEG
25779: PUSH
25780: EMPTY
25781: LIST
25782: LIST
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: LIST
25788: LIST
25789: LIST
25790: LIST
25791: LIST
25792: LIST
25793: LIST
25794: LIST
25795: LIST
25796: LIST
25797: LIST
25798: LIST
25799: LIST
25800: LIST
25801: LIST
25802: LIST
25803: LIST
25804: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25805: NOP4
25809: PUSH
25810: LD_INT 0
25812: PUSH
25813: LD_INT 0
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 0
25822: PUSH
25823: LD_INT 1
25825: NEG
25826: PUSH
25827: EMPTY
25828: LIST
25829: LIST
25830: PUSH
25831: LD_INT 1
25833: PUSH
25834: LD_INT 0
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: PUSH
25841: LD_INT 1
25843: PUSH
25844: LD_INT 1
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: PUSH
25851: LD_INT 0
25853: PUSH
25854: LD_INT 1
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PUSH
25861: LD_INT 1
25863: NEG
25864: PUSH
25865: LD_INT 0
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: PUSH
25872: LD_INT 1
25874: NEG
25875: PUSH
25876: LD_INT 1
25878: NEG
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 1
25886: NEG
25887: PUSH
25888: LD_INT 2
25890: NEG
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: PUSH
25896: LD_INT 0
25898: PUSH
25899: LD_INT 2
25901: NEG
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 1
25909: PUSH
25910: LD_INT 1
25912: NEG
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PUSH
25918: LD_INT 2
25920: PUSH
25921: LD_INT 0
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: LD_INT 2
25930: PUSH
25931: LD_INT 1
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_INT 2
25940: PUSH
25941: LD_INT 2
25943: PUSH
25944: EMPTY
25945: LIST
25946: LIST
25947: PUSH
25948: LD_INT 1
25950: PUSH
25951: LD_INT 2
25953: PUSH
25954: EMPTY
25955: LIST
25956: LIST
25957: PUSH
25958: LD_INT 0
25960: PUSH
25961: LD_INT 2
25963: PUSH
25964: EMPTY
25965: LIST
25966: LIST
25967: PUSH
25968: LD_INT 1
25970: NEG
25971: PUSH
25972: LD_INT 1
25974: PUSH
25975: EMPTY
25976: LIST
25977: LIST
25978: PUSH
25979: LD_INT 2
25981: NEG
25982: PUSH
25983: LD_INT 0
25985: PUSH
25986: EMPTY
25987: LIST
25988: LIST
25989: PUSH
25990: LD_INT 2
25992: NEG
25993: PUSH
25994: LD_INT 1
25996: NEG
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: PUSH
26002: LD_INT 2
26004: NEG
26005: PUSH
26006: LD_INT 2
26008: NEG
26009: PUSH
26010: EMPTY
26011: LIST
26012: LIST
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: LIST
26018: LIST
26019: LIST
26020: LIST
26021: LIST
26022: LIST
26023: LIST
26024: LIST
26025: LIST
26026: LIST
26027: LIST
26028: LIST
26029: LIST
26030: LIST
26031: LIST
26032: LIST
26033: LIST
26034: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26035: NOP4
26039: PUSH
26040: LD_INT 0
26042: PUSH
26043: LD_INT 0
26045: PUSH
26046: EMPTY
26047: LIST
26048: LIST
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: LD_INT 1
26055: NEG
26056: PUSH
26057: EMPTY
26058: LIST
26059: LIST
26060: PUSH
26061: LD_INT 1
26063: PUSH
26064: LD_INT 0
26066: PUSH
26067: EMPTY
26068: LIST
26069: LIST
26070: PUSH
26071: LD_INT 1
26073: PUSH
26074: LD_INT 1
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PUSH
26081: LD_INT 0
26083: PUSH
26084: LD_INT 1
26086: PUSH
26087: EMPTY
26088: LIST
26089: LIST
26090: PUSH
26091: LD_INT 1
26093: NEG
26094: PUSH
26095: LD_INT 0
26097: PUSH
26098: EMPTY
26099: LIST
26100: LIST
26101: PUSH
26102: LD_INT 1
26104: NEG
26105: PUSH
26106: LD_INT 1
26108: NEG
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: LD_INT 1
26116: NEG
26117: PUSH
26118: LD_INT 2
26120: NEG
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: PUSH
26126: LD_INT 0
26128: PUSH
26129: LD_INT 2
26131: NEG
26132: PUSH
26133: EMPTY
26134: LIST
26135: LIST
26136: PUSH
26137: LD_INT 1
26139: PUSH
26140: LD_INT 1
26142: NEG
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: LD_INT 2
26150: PUSH
26151: LD_INT 0
26153: PUSH
26154: EMPTY
26155: LIST
26156: LIST
26157: PUSH
26158: LD_INT 2
26160: PUSH
26161: LD_INT 1
26163: PUSH
26164: EMPTY
26165: LIST
26166: LIST
26167: PUSH
26168: LD_INT 2
26170: PUSH
26171: LD_INT 2
26173: PUSH
26174: EMPTY
26175: LIST
26176: LIST
26177: PUSH
26178: LD_INT 1
26180: PUSH
26181: LD_INT 2
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 0
26190: PUSH
26191: LD_INT 2
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: LD_INT 1
26200: NEG
26201: PUSH
26202: LD_INT 1
26204: PUSH
26205: EMPTY
26206: LIST
26207: LIST
26208: PUSH
26209: LD_INT 2
26211: NEG
26212: PUSH
26213: LD_INT 0
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: PUSH
26220: LD_INT 2
26222: NEG
26223: PUSH
26224: LD_INT 1
26226: NEG
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 2
26234: NEG
26235: PUSH
26236: LD_INT 2
26238: NEG
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: LIST
26251: LIST
26252: LIST
26253: LIST
26254: LIST
26255: LIST
26256: LIST
26257: LIST
26258: LIST
26259: LIST
26260: LIST
26261: LIST
26262: LIST
26263: LIST
26264: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
26265: NOP4
26269: PUSH
26270: LD_INT 0
26272: PUSH
26273: LD_INT 0
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: LD_INT 0
26282: PUSH
26283: LD_INT 1
26285: NEG
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: LD_INT 1
26293: PUSH
26294: LD_INT 0
26296: PUSH
26297: EMPTY
26298: LIST
26299: LIST
26300: PUSH
26301: LD_INT 1
26303: PUSH
26304: LD_INT 1
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: PUSH
26311: LD_INT 0
26313: PUSH
26314: LD_INT 1
26316: PUSH
26317: EMPTY
26318: LIST
26319: LIST
26320: PUSH
26321: LD_INT 1
26323: NEG
26324: PUSH
26325: LD_INT 0
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 1
26334: NEG
26335: PUSH
26336: LD_INT 1
26338: NEG
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 1
26346: NEG
26347: PUSH
26348: LD_INT 2
26350: NEG
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: LD_INT 0
26358: PUSH
26359: LD_INT 2
26361: NEG
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: LD_INT 1
26369: PUSH
26370: LD_INT 1
26372: NEG
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: LD_INT 2
26380: PUSH
26381: LD_INT 0
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 2
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: LD_INT 2
26400: PUSH
26401: LD_INT 2
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PUSH
26408: LD_INT 1
26410: PUSH
26411: LD_INT 2
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: LD_INT 0
26420: PUSH
26421: LD_INT 2
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 1
26430: NEG
26431: PUSH
26432: LD_INT 1
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: PUSH
26439: LD_INT 2
26441: NEG
26442: PUSH
26443: LD_INT 0
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: PUSH
26450: LD_INT 2
26452: NEG
26453: PUSH
26454: LD_INT 1
26456: NEG
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 2
26464: NEG
26465: PUSH
26466: LD_INT 2
26468: NEG
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: PUSH
26474: LD_INT 2
26476: NEG
26477: PUSH
26478: LD_INT 3
26480: NEG
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 1
26488: NEG
26489: PUSH
26490: LD_INT 3
26492: NEG
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: LD_INT 1
26500: PUSH
26501: LD_INT 2
26503: NEG
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 2
26511: PUSH
26512: LD_INT 1
26514: NEG
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: LIST
26524: LIST
26525: LIST
26526: LIST
26527: LIST
26528: LIST
26529: LIST
26530: LIST
26531: LIST
26532: LIST
26533: LIST
26534: LIST
26535: LIST
26536: LIST
26537: LIST
26538: LIST
26539: LIST
26540: LIST
26541: LIST
26542: LIST
26543: LIST
26544: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26545: NOP4
26549: PUSH
26550: LD_INT 0
26552: PUSH
26553: LD_INT 0
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: PUSH
26560: LD_INT 0
26562: PUSH
26563: LD_INT 1
26565: NEG
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 1
26573: PUSH
26574: LD_INT 0
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: PUSH
26581: LD_INT 1
26583: PUSH
26584: LD_INT 1
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: LD_INT 0
26593: PUSH
26594: LD_INT 1
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PUSH
26601: LD_INT 1
26603: NEG
26604: PUSH
26605: LD_INT 0
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 1
26614: NEG
26615: PUSH
26616: LD_INT 1
26618: NEG
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 1
26626: NEG
26627: PUSH
26628: LD_INT 2
26630: NEG
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: PUSH
26636: LD_INT 0
26638: PUSH
26639: LD_INT 2
26641: NEG
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PUSH
26647: LD_INT 1
26649: PUSH
26650: LD_INT 1
26652: NEG
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: LD_INT 2
26660: PUSH
26661: LD_INT 0
26663: PUSH
26664: EMPTY
26665: LIST
26666: LIST
26667: PUSH
26668: LD_INT 2
26670: PUSH
26671: LD_INT 1
26673: PUSH
26674: EMPTY
26675: LIST
26676: LIST
26677: PUSH
26678: LD_INT 2
26680: PUSH
26681: LD_INT 2
26683: PUSH
26684: EMPTY
26685: LIST
26686: LIST
26687: PUSH
26688: LD_INT 1
26690: PUSH
26691: LD_INT 2
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 0
26700: PUSH
26701: LD_INT 2
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: PUSH
26708: LD_INT 1
26710: NEG
26711: PUSH
26712: LD_INT 1
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 2
26721: NEG
26722: PUSH
26723: LD_INT 0
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: PUSH
26730: LD_INT 2
26732: NEG
26733: PUSH
26734: LD_INT 1
26736: NEG
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: PUSH
26742: LD_INT 2
26744: NEG
26745: PUSH
26746: LD_INT 2
26748: NEG
26749: PUSH
26750: EMPTY
26751: LIST
26752: LIST
26753: PUSH
26754: LD_INT 1
26756: PUSH
26757: LD_INT 2
26759: NEG
26760: PUSH
26761: EMPTY
26762: LIST
26763: LIST
26764: PUSH
26765: LD_INT 2
26767: PUSH
26768: LD_INT 1
26770: NEG
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: LD_INT 3
26778: PUSH
26779: LD_INT 1
26781: PUSH
26782: EMPTY
26783: LIST
26784: LIST
26785: PUSH
26786: LD_INT 3
26788: PUSH
26789: LD_INT 2
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: LIST
26800: LIST
26801: LIST
26802: LIST
26803: LIST
26804: LIST
26805: LIST
26806: LIST
26807: LIST
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
26821: NOP4
26825: PUSH
26826: LD_INT 0
26828: PUSH
26829: LD_INT 0
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 0
26838: PUSH
26839: LD_INT 1
26841: NEG
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PUSH
26847: LD_INT 1
26849: PUSH
26850: LD_INT 0
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 1
26859: PUSH
26860: LD_INT 1
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 0
26869: PUSH
26870: LD_INT 1
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 1
26879: NEG
26880: PUSH
26881: LD_INT 0
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: PUSH
26888: LD_INT 1
26890: NEG
26891: PUSH
26892: LD_INT 1
26894: NEG
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 1
26902: NEG
26903: PUSH
26904: LD_INT 2
26906: NEG
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 0
26914: PUSH
26915: LD_INT 2
26917: NEG
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: LD_INT 1
26925: PUSH
26926: LD_INT 1
26928: NEG
26929: PUSH
26930: EMPTY
26931: LIST
26932: LIST
26933: PUSH
26934: LD_INT 2
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: LD_INT 2
26946: PUSH
26947: LD_INT 1
26949: PUSH
26950: EMPTY
26951: LIST
26952: LIST
26953: PUSH
26954: LD_INT 2
26956: PUSH
26957: LD_INT 2
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PUSH
26964: LD_INT 1
26966: PUSH
26967: LD_INT 2
26969: PUSH
26970: EMPTY
26971: LIST
26972: LIST
26973: PUSH
26974: LD_INT 0
26976: PUSH
26977: LD_INT 2
26979: PUSH
26980: EMPTY
26981: LIST
26982: LIST
26983: PUSH
26984: LD_INT 1
26986: NEG
26987: PUSH
26988: LD_INT 1
26990: PUSH
26991: EMPTY
26992: LIST
26993: LIST
26994: PUSH
26995: LD_INT 2
26997: NEG
26998: PUSH
26999: LD_INT 0
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 2
27008: NEG
27009: PUSH
27010: LD_INT 1
27012: NEG
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: PUSH
27018: LD_INT 2
27020: NEG
27021: PUSH
27022: LD_INT 2
27024: NEG
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 3
27032: PUSH
27033: LD_INT 1
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: PUSH
27040: LD_INT 3
27042: PUSH
27043: LD_INT 2
27045: PUSH
27046: EMPTY
27047: LIST
27048: LIST
27049: PUSH
27050: LD_INT 2
27052: PUSH
27053: LD_INT 3
27055: PUSH
27056: EMPTY
27057: LIST
27058: LIST
27059: PUSH
27060: LD_INT 1
27062: PUSH
27063: LD_INT 3
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: PUSH
27070: EMPTY
27071: LIST
27072: LIST
27073: LIST
27074: LIST
27075: LIST
27076: LIST
27077: LIST
27078: LIST
27079: LIST
27080: LIST
27081: LIST
27082: LIST
27083: LIST
27084: LIST
27085: LIST
27086: LIST
27087: LIST
27088: LIST
27089: LIST
27090: LIST
27091: LIST
27092: LIST
27093: LIST
27094: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
27095: NOP4
27099: PUSH
27100: LD_INT 0
27102: PUSH
27103: LD_INT 0
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 0
27112: PUSH
27113: LD_INT 1
27115: NEG
27116: PUSH
27117: EMPTY
27118: LIST
27119: LIST
27120: PUSH
27121: LD_INT 1
27123: PUSH
27124: LD_INT 0
27126: PUSH
27127: EMPTY
27128: LIST
27129: LIST
27130: PUSH
27131: LD_INT 1
27133: PUSH
27134: LD_INT 1
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: LD_INT 0
27143: PUSH
27144: LD_INT 1
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 1
27153: NEG
27154: PUSH
27155: LD_INT 0
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: PUSH
27162: LD_INT 1
27164: NEG
27165: PUSH
27166: LD_INT 1
27168: NEG
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PUSH
27174: LD_INT 1
27176: NEG
27177: PUSH
27178: LD_INT 2
27180: NEG
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: LD_INT 0
27188: PUSH
27189: LD_INT 2
27191: NEG
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_INT 1
27199: PUSH
27200: LD_INT 1
27202: NEG
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PUSH
27208: LD_INT 2
27210: PUSH
27211: LD_INT 0
27213: PUSH
27214: EMPTY
27215: LIST
27216: LIST
27217: PUSH
27218: LD_INT 2
27220: PUSH
27221: LD_INT 1
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: PUSH
27228: LD_INT 2
27230: PUSH
27231: LD_INT 2
27233: PUSH
27234: EMPTY
27235: LIST
27236: LIST
27237: PUSH
27238: LD_INT 1
27240: PUSH
27241: LD_INT 2
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 0
27250: PUSH
27251: LD_INT 2
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 1
27260: NEG
27261: PUSH
27262: LD_INT 1
27264: PUSH
27265: EMPTY
27266: LIST
27267: LIST
27268: PUSH
27269: LD_INT 2
27271: NEG
27272: PUSH
27273: LD_INT 0
27275: PUSH
27276: EMPTY
27277: LIST
27278: LIST
27279: PUSH
27280: LD_INT 2
27282: NEG
27283: PUSH
27284: LD_INT 1
27286: NEG
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: LD_INT 2
27294: NEG
27295: PUSH
27296: LD_INT 2
27298: NEG
27299: PUSH
27300: EMPTY
27301: LIST
27302: LIST
27303: PUSH
27304: LD_INT 2
27306: PUSH
27307: LD_INT 3
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 1
27316: PUSH
27317: LD_INT 3
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PUSH
27324: LD_INT 1
27326: NEG
27327: PUSH
27328: LD_INT 2
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 2
27337: NEG
27338: PUSH
27339: LD_INT 1
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: PUSH
27346: EMPTY
27347: LIST
27348: LIST
27349: LIST
27350: LIST
27351: LIST
27352: LIST
27353: LIST
27354: LIST
27355: LIST
27356: LIST
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27371: NOP4
27375: PUSH
27376: LD_INT 0
27378: PUSH
27379: LD_INT 0
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: PUSH
27386: LD_INT 0
27388: PUSH
27389: LD_INT 1
27391: NEG
27392: PUSH
27393: EMPTY
27394: LIST
27395: LIST
27396: PUSH
27397: LD_INT 1
27399: PUSH
27400: LD_INT 0
27402: PUSH
27403: EMPTY
27404: LIST
27405: LIST
27406: PUSH
27407: LD_INT 1
27409: PUSH
27410: LD_INT 1
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 0
27419: PUSH
27420: LD_INT 1
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: PUSH
27427: LD_INT 1
27429: NEG
27430: PUSH
27431: LD_INT 0
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: PUSH
27438: LD_INT 1
27440: NEG
27441: PUSH
27442: LD_INT 1
27444: NEG
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: PUSH
27450: LD_INT 1
27452: NEG
27453: PUSH
27454: LD_INT 2
27456: NEG
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: LD_INT 0
27464: PUSH
27465: LD_INT 2
27467: NEG
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: PUSH
27473: LD_INT 1
27475: PUSH
27476: LD_INT 1
27478: NEG
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: PUSH
27484: LD_INT 2
27486: PUSH
27487: LD_INT 0
27489: PUSH
27490: EMPTY
27491: LIST
27492: LIST
27493: PUSH
27494: LD_INT 2
27496: PUSH
27497: LD_INT 1
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 2
27506: PUSH
27507: LD_INT 2
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 1
27516: PUSH
27517: LD_INT 2
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 0
27526: PUSH
27527: LD_INT 2
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 1
27536: NEG
27537: PUSH
27538: LD_INT 1
27540: PUSH
27541: EMPTY
27542: LIST
27543: LIST
27544: PUSH
27545: LD_INT 2
27547: NEG
27548: PUSH
27549: LD_INT 0
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: PUSH
27556: LD_INT 2
27558: NEG
27559: PUSH
27560: LD_INT 1
27562: NEG
27563: PUSH
27564: EMPTY
27565: LIST
27566: LIST
27567: PUSH
27568: LD_INT 2
27570: NEG
27571: PUSH
27572: LD_INT 2
27574: NEG
27575: PUSH
27576: EMPTY
27577: LIST
27578: LIST
27579: PUSH
27580: LD_INT 1
27582: NEG
27583: PUSH
27584: LD_INT 2
27586: PUSH
27587: EMPTY
27588: LIST
27589: LIST
27590: PUSH
27591: LD_INT 2
27593: NEG
27594: PUSH
27595: LD_INT 1
27597: PUSH
27598: EMPTY
27599: LIST
27600: LIST
27601: PUSH
27602: LD_INT 3
27604: NEG
27605: PUSH
27606: LD_INT 1
27608: NEG
27609: PUSH
27610: EMPTY
27611: LIST
27612: LIST
27613: PUSH
27614: LD_INT 3
27616: NEG
27617: PUSH
27618: LD_INT 2
27620: NEG
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: LIST
27630: LIST
27631: LIST
27632: LIST
27633: LIST
27634: LIST
27635: LIST
27636: LIST
27637: LIST
27638: LIST
27639: LIST
27640: LIST
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: LIST
27649: LIST
27650: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27651: NOP4
27655: PUSH
27656: LD_INT 0
27658: PUSH
27659: LD_INT 0
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PUSH
27666: LD_INT 0
27668: PUSH
27669: LD_INT 1
27671: NEG
27672: PUSH
27673: EMPTY
27674: LIST
27675: LIST
27676: PUSH
27677: LD_INT 1
27679: PUSH
27680: LD_INT 0
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: PUSH
27687: LD_INT 1
27689: PUSH
27690: LD_INT 1
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PUSH
27697: LD_INT 0
27699: PUSH
27700: LD_INT 1
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 1
27709: NEG
27710: PUSH
27711: LD_INT 0
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: PUSH
27718: LD_INT 1
27720: NEG
27721: PUSH
27722: LD_INT 1
27724: NEG
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: PUSH
27730: LD_INT 1
27732: NEG
27733: PUSH
27734: LD_INT 2
27736: NEG
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: LD_INT 0
27744: PUSH
27745: LD_INT 2
27747: NEG
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: PUSH
27753: LD_INT 1
27755: PUSH
27756: LD_INT 1
27758: NEG
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: PUSH
27764: LD_INT 2
27766: PUSH
27767: LD_INT 0
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 2
27776: PUSH
27777: LD_INT 1
27779: PUSH
27780: EMPTY
27781: LIST
27782: LIST
27783: PUSH
27784: LD_INT 2
27786: PUSH
27787: LD_INT 2
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: LD_INT 1
27796: PUSH
27797: LD_INT 2
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 0
27806: PUSH
27807: LD_INT 2
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 1
27816: NEG
27817: PUSH
27818: LD_INT 1
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: LD_INT 2
27827: NEG
27828: PUSH
27829: LD_INT 0
27831: PUSH
27832: EMPTY
27833: LIST
27834: LIST
27835: PUSH
27836: LD_INT 2
27838: NEG
27839: PUSH
27840: LD_INT 1
27842: NEG
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 2
27850: NEG
27851: PUSH
27852: LD_INT 2
27854: NEG
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PUSH
27860: LD_INT 2
27862: NEG
27863: PUSH
27864: LD_INT 3
27866: NEG
27867: PUSH
27868: EMPTY
27869: LIST
27870: LIST
27871: PUSH
27872: LD_INT 1
27874: NEG
27875: PUSH
27876: LD_INT 3
27878: NEG
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 3
27886: NEG
27887: PUSH
27888: LD_INT 1
27890: NEG
27891: PUSH
27892: EMPTY
27893: LIST
27894: LIST
27895: PUSH
27896: LD_INT 3
27898: NEG
27899: PUSH
27900: LD_INT 2
27902: NEG
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: LIST
27920: LIST
27921: LIST
27922: LIST
27923: LIST
27924: LIST
27925: LIST
27926: LIST
27927: LIST
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27933: NOP4
27937: PUSH
27938: LD_INT 0
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: EMPTY
27945: LIST
27946: LIST
27947: PUSH
27948: LD_INT 0
27950: PUSH
27951: LD_INT 1
27953: NEG
27954: PUSH
27955: EMPTY
27956: LIST
27957: LIST
27958: PUSH
27959: LD_INT 1
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: LD_INT 1
27974: PUSH
27975: EMPTY
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 0
27981: PUSH
27982: LD_INT 1
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 1
27991: NEG
27992: PUSH
27993: LD_INT 0
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: PUSH
28000: LD_INT 1
28002: NEG
28003: PUSH
28004: LD_INT 1
28006: NEG
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 1
28014: NEG
28015: PUSH
28016: LD_INT 2
28018: NEG
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PUSH
28024: LD_INT 0
28026: PUSH
28027: LD_INT 2
28029: NEG
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 1
28037: PUSH
28038: LD_INT 1
28040: NEG
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: LD_INT 2
28048: PUSH
28049: LD_INT 0
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 2
28058: PUSH
28059: LD_INT 1
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 1
28068: PUSH
28069: LD_INT 2
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: LD_INT 0
28078: PUSH
28079: LD_INT 2
28081: PUSH
28082: EMPTY
28083: LIST
28084: LIST
28085: PUSH
28086: LD_INT 1
28088: NEG
28089: PUSH
28090: LD_INT 1
28092: PUSH
28093: EMPTY
28094: LIST
28095: LIST
28096: PUSH
28097: LD_INT 2
28099: NEG
28100: PUSH
28101: LD_INT 1
28103: NEG
28104: PUSH
28105: EMPTY
28106: LIST
28107: LIST
28108: PUSH
28109: LD_INT 2
28111: NEG
28112: PUSH
28113: LD_INT 2
28115: NEG
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PUSH
28121: LD_INT 2
28123: NEG
28124: PUSH
28125: LD_INT 3
28127: NEG
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 2
28135: PUSH
28136: LD_INT 1
28138: NEG
28139: PUSH
28140: EMPTY
28141: LIST
28142: LIST
28143: PUSH
28144: LD_INT 3
28146: PUSH
28147: LD_INT 1
28149: PUSH
28150: EMPTY
28151: LIST
28152: LIST
28153: PUSH
28154: LD_INT 1
28156: PUSH
28157: LD_INT 3
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: PUSH
28164: LD_INT 1
28166: NEG
28167: PUSH
28168: LD_INT 2
28170: PUSH
28171: EMPTY
28172: LIST
28173: LIST
28174: PUSH
28175: LD_INT 3
28177: NEG
28178: PUSH
28179: LD_INT 2
28181: NEG
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: LIST
28194: LIST
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28212: NOP4
28216: PUSH
28217: LD_INT 0
28219: PUSH
28220: LD_INT 0
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 0
28229: PUSH
28230: LD_INT 1
28232: NEG
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 1
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 1
28250: PUSH
28251: LD_INT 1
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: LD_INT 1
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 1
28270: NEG
28271: PUSH
28272: LD_INT 0
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PUSH
28279: LD_INT 1
28281: NEG
28282: PUSH
28283: LD_INT 1
28285: NEG
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 1
28293: NEG
28294: PUSH
28295: LD_INT 2
28297: NEG
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 0
28305: PUSH
28306: LD_INT 2
28308: NEG
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: PUSH
28314: LD_INT 1
28316: PUSH
28317: LD_INT 1
28319: NEG
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 2
28327: PUSH
28328: LD_INT 0
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PUSH
28335: LD_INT 2
28337: PUSH
28338: LD_INT 1
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 2
28347: PUSH
28348: LD_INT 2
28350: PUSH
28351: EMPTY
28352: LIST
28353: LIST
28354: PUSH
28355: LD_INT 1
28357: PUSH
28358: LD_INT 2
28360: PUSH
28361: EMPTY
28362: LIST
28363: LIST
28364: PUSH
28365: LD_INT 1
28367: NEG
28368: PUSH
28369: LD_INT 1
28371: PUSH
28372: EMPTY
28373: LIST
28374: LIST
28375: PUSH
28376: LD_INT 2
28378: NEG
28379: PUSH
28380: LD_INT 0
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: LD_INT 2
28389: NEG
28390: PUSH
28391: LD_INT 1
28393: NEG
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: PUSH
28399: LD_INT 1
28401: NEG
28402: PUSH
28403: LD_INT 3
28405: NEG
28406: PUSH
28407: EMPTY
28408: LIST
28409: LIST
28410: PUSH
28411: LD_INT 1
28413: PUSH
28414: LD_INT 2
28416: NEG
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PUSH
28422: LD_INT 3
28424: PUSH
28425: LD_INT 2
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: LD_INT 2
28434: PUSH
28435: LD_INT 3
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PUSH
28442: LD_INT 2
28444: NEG
28445: PUSH
28446: LD_INT 1
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: LD_INT 3
28455: NEG
28456: PUSH
28457: LD_INT 1
28459: NEG
28460: PUSH
28461: EMPTY
28462: LIST
28463: LIST
28464: PUSH
28465: EMPTY
28466: LIST
28467: LIST
28468: LIST
28469: LIST
28470: LIST
28471: LIST
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: LIST
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28490: NOP4
28494: PUSH
28495: LD_INT 0
28497: PUSH
28498: LD_INT 0
28500: PUSH
28501: EMPTY
28502: LIST
28503: LIST
28504: PUSH
28505: LD_INT 0
28507: PUSH
28508: LD_INT 1
28510: NEG
28511: PUSH
28512: EMPTY
28513: LIST
28514: LIST
28515: PUSH
28516: LD_INT 1
28518: PUSH
28519: LD_INT 0
28521: PUSH
28522: EMPTY
28523: LIST
28524: LIST
28525: PUSH
28526: LD_INT 1
28528: PUSH
28529: LD_INT 1
28531: PUSH
28532: EMPTY
28533: LIST
28534: LIST
28535: PUSH
28536: LD_INT 0
28538: PUSH
28539: LD_INT 1
28541: PUSH
28542: EMPTY
28543: LIST
28544: LIST
28545: PUSH
28546: LD_INT 1
28548: NEG
28549: PUSH
28550: LD_INT 0
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PUSH
28557: LD_INT 1
28559: NEG
28560: PUSH
28561: LD_INT 1
28563: NEG
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 1
28571: NEG
28572: PUSH
28573: LD_INT 2
28575: NEG
28576: PUSH
28577: EMPTY
28578: LIST
28579: LIST
28580: PUSH
28581: LD_INT 1
28583: PUSH
28584: LD_INT 1
28586: NEG
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 2
28594: PUSH
28595: LD_INT 0
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 2
28604: PUSH
28605: LD_INT 1
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 2
28614: PUSH
28615: LD_INT 2
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 1
28624: PUSH
28625: LD_INT 2
28627: PUSH
28628: EMPTY
28629: LIST
28630: LIST
28631: PUSH
28632: LD_INT 0
28634: PUSH
28635: LD_INT 2
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PUSH
28642: LD_INT 1
28644: NEG
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 2
28655: NEG
28656: PUSH
28657: LD_INT 1
28659: NEG
28660: PUSH
28661: EMPTY
28662: LIST
28663: LIST
28664: PUSH
28665: LD_INT 2
28667: NEG
28668: PUSH
28669: LD_INT 2
28671: NEG
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: NEG
28680: PUSH
28681: LD_INT 3
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 2
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 3
28702: PUSH
28703: LD_INT 1
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 1
28712: PUSH
28713: LD_INT 3
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 1
28722: NEG
28723: PUSH
28724: LD_INT 2
28726: PUSH
28727: EMPTY
28728: LIST
28729: LIST
28730: PUSH
28731: LD_INT 3
28733: NEG
28734: PUSH
28735: LD_INT 2
28737: NEG
28738: PUSH
28739: EMPTY
28740: LIST
28741: LIST
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: LIST
28747: LIST
28748: LIST
28749: LIST
28750: LIST
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28768: NOP4
28772: PUSH
28773: LD_INT 0
28775: PUSH
28776: LD_INT 0
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: LD_INT 0
28785: PUSH
28786: LD_INT 1
28788: NEG
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: LD_INT 1
28796: PUSH
28797: LD_INT 0
28799: PUSH
28800: EMPTY
28801: LIST
28802: LIST
28803: PUSH
28804: LD_INT 1
28806: PUSH
28807: LD_INT 1
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: LD_INT 0
28816: PUSH
28817: LD_INT 1
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PUSH
28824: LD_INT 1
28826: NEG
28827: PUSH
28828: LD_INT 0
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PUSH
28835: LD_INT 1
28837: NEG
28838: PUSH
28839: LD_INT 1
28841: NEG
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 1
28849: NEG
28850: PUSH
28851: LD_INT 2
28853: NEG
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: PUSH
28859: LD_INT 0
28861: PUSH
28862: LD_INT 2
28864: NEG
28865: PUSH
28866: EMPTY
28867: LIST
28868: LIST
28869: PUSH
28870: LD_INT 1
28872: PUSH
28873: LD_INT 1
28875: NEG
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 2
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 2
28893: PUSH
28894: LD_INT 2
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 1
28903: PUSH
28904: LD_INT 2
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 0
28913: PUSH
28914: LD_INT 2
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 1
28923: NEG
28924: PUSH
28925: LD_INT 1
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: PUSH
28932: LD_INT 2
28934: NEG
28935: PUSH
28936: LD_INT 0
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: PUSH
28943: LD_INT 2
28945: NEG
28946: PUSH
28947: LD_INT 1
28949: NEG
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 1
28957: NEG
28958: PUSH
28959: LD_INT 3
28961: NEG
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 1
28969: PUSH
28970: LD_INT 2
28972: NEG
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PUSH
28978: LD_INT 3
28980: PUSH
28981: LD_INT 2
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: PUSH
28988: LD_INT 2
28990: PUSH
28991: LD_INT 3
28993: PUSH
28994: EMPTY
28995: LIST
28996: LIST
28997: PUSH
28998: LD_INT 2
29000: NEG
29001: PUSH
29002: LD_INT 1
29004: PUSH
29005: EMPTY
29006: LIST
29007: LIST
29008: PUSH
29009: LD_INT 3
29011: NEG
29012: PUSH
29013: LD_INT 1
29015: NEG
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: PUSH
29021: EMPTY
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29046: NOP4
29050: PUSH
29051: LD_INT 0
29053: PUSH
29054: LD_INT 0
29056: PUSH
29057: EMPTY
29058: LIST
29059: LIST
29060: PUSH
29061: LD_INT 0
29063: PUSH
29064: LD_INT 1
29066: NEG
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 1
29074: PUSH
29075: LD_INT 0
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 1
29084: PUSH
29085: LD_INT 1
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 0
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 1
29104: NEG
29105: PUSH
29106: LD_INT 0
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: LD_INT 1
29115: NEG
29116: PUSH
29117: LD_INT 1
29119: NEG
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 1
29127: NEG
29128: PUSH
29129: LD_INT 2
29131: NEG
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 1
29139: PUSH
29140: LD_INT 1
29142: NEG
29143: PUSH
29144: EMPTY
29145: LIST
29146: LIST
29147: PUSH
29148: LD_INT 2
29150: PUSH
29151: LD_INT 0
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: LD_INT 2
29160: PUSH
29161: LD_INT 1
29163: PUSH
29164: EMPTY
29165: LIST
29166: LIST
29167: PUSH
29168: LD_INT 1
29170: PUSH
29171: LD_INT 2
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 0
29180: PUSH
29181: LD_INT 2
29183: PUSH
29184: EMPTY
29185: LIST
29186: LIST
29187: PUSH
29188: LD_INT 1
29190: NEG
29191: PUSH
29192: LD_INT 1
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PUSH
29199: LD_INT 2
29201: NEG
29202: PUSH
29203: LD_INT 0
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 2
29212: NEG
29213: PUSH
29214: LD_INT 1
29216: NEG
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 2
29224: NEG
29225: PUSH
29226: LD_INT 2
29228: NEG
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 2
29236: NEG
29237: PUSH
29238: LD_INT 3
29240: NEG
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: LD_INT 2
29248: PUSH
29249: LD_INT 1
29251: NEG
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 3
29259: PUSH
29260: LD_INT 1
29262: PUSH
29263: EMPTY
29264: LIST
29265: LIST
29266: PUSH
29267: LD_INT 1
29269: PUSH
29270: LD_INT 3
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PUSH
29277: LD_INT 1
29279: NEG
29280: PUSH
29281: LD_INT 2
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: LD_INT 3
29290: NEG
29291: PUSH
29292: LD_INT 2
29294: NEG
29295: PUSH
29296: EMPTY
29297: LIST
29298: LIST
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: LIST
29304: LIST
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29325: NOP4
29329: PUSH
29330: LD_INT 0
29332: PUSH
29333: LD_INT 0
29335: PUSH
29336: EMPTY
29337: LIST
29338: LIST
29339: PUSH
29340: LD_INT 0
29342: PUSH
29343: LD_INT 1
29345: NEG
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: PUSH
29351: LD_INT 1
29353: PUSH
29354: LD_INT 0
29356: PUSH
29357: EMPTY
29358: LIST
29359: LIST
29360: PUSH
29361: LD_INT 1
29363: PUSH
29364: LD_INT 1
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 0
29373: PUSH
29374: LD_INT 1
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 1
29383: NEG
29384: PUSH
29385: LD_INT 0
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: LD_INT 1
29394: NEG
29395: PUSH
29396: LD_INT 1
29398: NEG
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 1
29406: NEG
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 0
29418: PUSH
29419: LD_INT 2
29421: NEG
29422: PUSH
29423: EMPTY
29424: LIST
29425: LIST
29426: PUSH
29427: LD_INT 1
29429: PUSH
29430: LD_INT 1
29432: NEG
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: LD_INT 2
29440: PUSH
29441: LD_INT 1
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: LD_INT 2
29450: PUSH
29451: LD_INT 2
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 1
29460: PUSH
29461: LD_INT 2
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 1
29470: NEG
29471: PUSH
29472: LD_INT 1
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 2
29481: NEG
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 2
29492: NEG
29493: PUSH
29494: LD_INT 1
29496: NEG
29497: PUSH
29498: EMPTY
29499: LIST
29500: LIST
29501: PUSH
29502: LD_INT 2
29504: NEG
29505: PUSH
29506: LD_INT 2
29508: NEG
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: LD_INT 3
29520: NEG
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 1
29528: PUSH
29529: LD_INT 2
29531: NEG
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 3
29539: PUSH
29540: LD_INT 2
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 2
29549: PUSH
29550: LD_INT 3
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 2
29559: NEG
29560: PUSH
29561: LD_INT 1
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 3
29570: NEG
29571: PUSH
29572: LD_INT 1
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: LIST
29584: LIST
29585: LIST
29586: LIST
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29605: NOP4
29609: PUSH
29610: LD_INT 0
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 0
29622: PUSH
29623: LD_INT 1
29625: NEG
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: LD_INT 1
29633: PUSH
29634: LD_INT 0
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: LD_INT 1
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: PUSH
29651: LD_INT 0
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: PUSH
29661: LD_INT 1
29663: NEG
29664: PUSH
29665: LD_INT 0
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 1
29674: NEG
29675: PUSH
29676: LD_INT 1
29678: NEG
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 2
29686: PUSH
29687: LD_INT 1
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 2
29696: NEG
29697: PUSH
29698: LD_INT 1
29700: NEG
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PUSH
29706: EMPTY
29707: LIST
29708: LIST
29709: LIST
29710: LIST
29711: LIST
29712: LIST
29713: LIST
29714: LIST
29715: LIST
29716: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29717: NOP4
29721: PUSH
29722: LD_INT 0
29724: PUSH
29725: LD_INT 0
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 0
29734: PUSH
29735: LD_INT 1
29737: NEG
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 1
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 1
29755: PUSH
29756: LD_INT 1
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 0
29765: PUSH
29766: LD_INT 1
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 1
29775: NEG
29776: PUSH
29777: LD_INT 0
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 1
29786: NEG
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 1
29798: NEG
29799: PUSH
29800: LD_INT 2
29802: NEG
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 1
29810: PUSH
29811: LD_INT 2
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: LIST
29828: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29829: NOP4
29833: PUSH
29834: LD_INT 0
29836: PUSH
29837: LD_INT 0
29839: PUSH
29840: EMPTY
29841: LIST
29842: LIST
29843: PUSH
29844: LD_INT 0
29846: PUSH
29847: LD_INT 1
29849: NEG
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: PUSH
29855: LD_INT 1
29857: PUSH
29858: LD_INT 0
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 1
29867: PUSH
29868: LD_INT 1
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 0
29877: PUSH
29878: LD_INT 1
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: LD_INT 0
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: LD_INT 1
29898: NEG
29899: PUSH
29900: LD_INT 1
29902: NEG
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 1
29910: PUSH
29911: LD_INT 1
29913: NEG
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PUSH
29919: LD_INT 1
29921: NEG
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: LIST
29934: LIST
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: LIST
29940: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29941: NOP4
29945: PUSH
29946: LD_INT 0
29948: PUSH
29949: LD_INT 0
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 0
29958: PUSH
29959: LD_INT 1
29961: NEG
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 1
29969: PUSH
29970: LD_INT 0
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 1
29979: PUSH
29980: LD_INT 1
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 0
29989: PUSH
29990: LD_INT 1
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 1
29999: NEG
30000: PUSH
30001: LD_INT 0
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 1
30010: NEG
30011: PUSH
30012: LD_INT 1
30014: NEG
30015: PUSH
30016: EMPTY
30017: LIST
30018: LIST
30019: PUSH
30020: LD_INT 2
30022: PUSH
30023: LD_INT 1
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 2
30032: NEG
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30053: NOP4
30057: PUSH
30058: LD_INT 0
30060: PUSH
30061: LD_INT 0
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PUSH
30068: LD_INT 0
30070: PUSH
30071: LD_INT 1
30073: NEG
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 1
30081: PUSH
30082: LD_INT 0
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 1
30091: PUSH
30092: LD_INT 1
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 0
30101: PUSH
30102: LD_INT 1
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 1
30111: NEG
30112: PUSH
30113: LD_INT 0
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 1
30122: NEG
30123: PUSH
30124: LD_INT 1
30126: NEG
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 1
30134: NEG
30135: PUSH
30136: LD_INT 2
30138: NEG
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: LD_INT 1
30146: PUSH
30147: LD_INT 2
30149: PUSH
30150: EMPTY
30151: LIST
30152: LIST
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
30165: NOP4
30169: PUSH
30170: LD_INT 0
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 0
30182: PUSH
30183: LD_INT 1
30185: NEG
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: LD_INT 1
30193: PUSH
30194: LD_INT 0
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 1
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 0
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 1
30223: NEG
30224: PUSH
30225: LD_INT 0
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: PUSH
30232: LD_INT 1
30234: NEG
30235: PUSH
30236: LD_INT 1
30238: NEG
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 1
30246: PUSH
30247: LD_INT 1
30249: NEG
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: LD_INT 1
30257: NEG
30258: PUSH
30259: LD_INT 1
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: LIST
30270: LIST
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30277: NOP4
30281: PUSH
30282: LD_INT 0
30284: PUSH
30285: LD_INT 0
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: LD_INT 0
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 1
30315: PUSH
30316: LD_INT 1
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: LD_INT 1
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 1
30335: NEG
30336: PUSH
30337: LD_INT 0
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: LD_INT 1
30350: NEG
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 1
30358: NEG
30359: PUSH
30360: LD_INT 2
30362: NEG
30363: PUSH
30364: EMPTY
30365: LIST
30366: LIST
30367: PUSH
30368: LD_INT 1
30370: PUSH
30371: LD_INT 1
30373: NEG
30374: PUSH
30375: EMPTY
30376: LIST
30377: LIST
30378: PUSH
30379: LD_INT 2
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 2
30391: PUSH
30392: LD_INT 1
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 2
30401: PUSH
30402: LD_INT 2
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 1
30411: PUSH
30412: LD_INT 2
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 1
30421: NEG
30422: PUSH
30423: LD_INT 1
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 2
30432: NEG
30433: PUSH
30434: LD_INT 0
30436: PUSH
30437: EMPTY
30438: LIST
30439: LIST
30440: PUSH
30441: LD_INT 2
30443: NEG
30444: PUSH
30445: LD_INT 1
30447: NEG
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 2
30455: NEG
30456: PUSH
30457: LD_INT 2
30459: NEG
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 2
30467: NEG
30468: PUSH
30469: LD_INT 3
30471: NEG
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 2
30479: PUSH
30480: LD_INT 1
30482: NEG
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 3
30490: PUSH
30491: LD_INT 0
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: LD_INT 3
30500: PUSH
30501: LD_INT 1
30503: PUSH
30504: EMPTY
30505: LIST
30506: LIST
30507: PUSH
30508: LD_INT 3
30510: PUSH
30511: LD_INT 2
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 3
30520: PUSH
30521: LD_INT 3
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 2
30530: PUSH
30531: LD_INT 3
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 2
30540: NEG
30541: PUSH
30542: LD_INT 1
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 3
30551: NEG
30552: PUSH
30553: LD_INT 0
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: LD_INT 3
30562: NEG
30563: PUSH
30564: LD_INT 1
30566: NEG
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 3
30574: NEG
30575: PUSH
30576: LD_INT 2
30578: NEG
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: LD_INT 3
30586: NEG
30587: PUSH
30588: LD_INT 3
30590: NEG
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30627: NOP4
30631: PUSH
30632: LD_INT 0
30634: PUSH
30635: LD_INT 0
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 0
30644: PUSH
30645: LD_INT 1
30647: NEG
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: LD_INT 0
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 1
30665: PUSH
30666: LD_INT 1
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: LD_INT 1
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: LD_INT 0
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PUSH
30694: LD_INT 1
30696: NEG
30697: PUSH
30698: LD_INT 1
30700: NEG
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 1
30708: NEG
30709: PUSH
30710: LD_INT 2
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 0
30720: PUSH
30721: LD_INT 2
30723: NEG
30724: PUSH
30725: EMPTY
30726: LIST
30727: LIST
30728: PUSH
30729: LD_INT 1
30731: PUSH
30732: LD_INT 1
30734: NEG
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 2
30742: PUSH
30743: LD_INT 1
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 2
30752: PUSH
30753: LD_INT 2
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: LD_INT 2
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: PUSH
30770: LD_INT 0
30772: PUSH
30773: LD_INT 2
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: NEG
30783: PUSH
30784: LD_INT 1
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 2
30793: NEG
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 2
30805: NEG
30806: PUSH
30807: LD_INT 2
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 2
30817: NEG
30818: PUSH
30819: LD_INT 3
30821: NEG
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 1
30829: NEG
30830: PUSH
30831: LD_INT 3
30833: NEG
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: PUSH
30839: LD_INT 0
30841: PUSH
30842: LD_INT 3
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: LD_INT 2
30855: NEG
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 3
30863: PUSH
30864: LD_INT 2
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 3
30873: PUSH
30874: LD_INT 3
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 2
30883: PUSH
30884: LD_INT 3
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 1
30893: PUSH
30894: LD_INT 3
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 0
30903: PUSH
30904: LD_INT 3
30906: PUSH
30907: EMPTY
30908: LIST
30909: LIST
30910: PUSH
30911: LD_INT 1
30913: NEG
30914: PUSH
30915: LD_INT 2
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: PUSH
30922: LD_INT 3
30924: NEG
30925: PUSH
30926: LD_INT 2
30928: NEG
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 3
30936: NEG
30937: PUSH
30938: LD_INT 3
30940: NEG
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: LIST
30954: LIST
30955: LIST
30956: LIST
30957: LIST
30958: LIST
30959: LIST
30960: LIST
30961: LIST
30962: LIST
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30977: NOP4
30981: PUSH
30982: LD_INT 0
30984: PUSH
30985: LD_INT 0
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 0
30994: PUSH
30995: LD_INT 1
30997: NEG
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 1
31005: PUSH
31006: LD_INT 0
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 0
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: NEG
31036: PUSH
31037: LD_INT 0
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: LD_INT 1
31046: NEG
31047: PUSH
31048: LD_INT 1
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 1
31058: NEG
31059: PUSH
31060: LD_INT 2
31062: NEG
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 0
31070: PUSH
31071: LD_INT 2
31073: NEG
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 1
31081: PUSH
31082: LD_INT 1
31084: NEG
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 2
31092: PUSH
31093: LD_INT 0
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: LD_INT 1
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 1
31112: PUSH
31113: LD_INT 2
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 0
31122: PUSH
31123: LD_INT 2
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 1
31132: NEG
31133: PUSH
31134: LD_INT 1
31136: PUSH
31137: EMPTY
31138: LIST
31139: LIST
31140: PUSH
31141: LD_INT 2
31143: NEG
31144: PUSH
31145: LD_INT 0
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 2
31154: NEG
31155: PUSH
31156: LD_INT 1
31158: NEG
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 1
31166: NEG
31167: PUSH
31168: LD_INT 3
31170: NEG
31171: PUSH
31172: EMPTY
31173: LIST
31174: LIST
31175: PUSH
31176: LD_INT 0
31178: PUSH
31179: LD_INT 3
31181: NEG
31182: PUSH
31183: EMPTY
31184: LIST
31185: LIST
31186: PUSH
31187: LD_INT 1
31189: PUSH
31190: LD_INT 2
31192: NEG
31193: PUSH
31194: EMPTY
31195: LIST
31196: LIST
31197: PUSH
31198: LD_INT 2
31200: PUSH
31201: LD_INT 1
31203: NEG
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 3
31211: PUSH
31212: LD_INT 0
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 3
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: PUSH
31232: LD_INT 3
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 0
31241: PUSH
31242: LD_INT 3
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 1
31251: NEG
31252: PUSH
31253: LD_INT 2
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PUSH
31260: LD_INT 2
31262: NEG
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 3
31273: NEG
31274: PUSH
31275: LD_INT 0
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 3
31284: NEG
31285: PUSH
31286: LD_INT 1
31288: NEG
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: LIST
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31325: NOP4
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: LD_INT 0
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 0
31342: PUSH
31343: LD_INT 1
31345: NEG
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 1
31353: PUSH
31354: LD_INT 0
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: LD_INT 1
31363: PUSH
31364: LD_INT 1
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 0
31373: PUSH
31374: LD_INT 1
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 1
31383: NEG
31384: PUSH
31385: LD_INT 0
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PUSH
31392: LD_INT 1
31394: NEG
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: LD_INT 1
31406: NEG
31407: PUSH
31408: LD_INT 2
31410: NEG
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: PUSH
31416: LD_INT 1
31418: PUSH
31419: LD_INT 1
31421: NEG
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: LD_INT 2
31429: PUSH
31430: LD_INT 0
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 2
31439: PUSH
31440: LD_INT 1
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 2
31449: PUSH
31450: LD_INT 2
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: LD_INT 1
31459: PUSH
31460: LD_INT 2
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 1
31469: NEG
31470: PUSH
31471: LD_INT 1
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 2
31480: NEG
31481: PUSH
31482: LD_INT 0
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: LD_INT 2
31491: NEG
31492: PUSH
31493: LD_INT 1
31495: NEG
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 2
31503: NEG
31504: PUSH
31505: LD_INT 2
31507: NEG
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: LD_INT 2
31515: NEG
31516: PUSH
31517: LD_INT 3
31519: NEG
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 2
31527: PUSH
31528: LD_INT 1
31530: NEG
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 3
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 3
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 3
31558: PUSH
31559: LD_INT 2
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 3
31568: PUSH
31569: LD_INT 3
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 2
31578: PUSH
31579: LD_INT 3
31581: PUSH
31582: EMPTY
31583: LIST
31584: LIST
31585: PUSH
31586: LD_INT 2
31588: NEG
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 3
31599: NEG
31600: PUSH
31601: LD_INT 0
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 3
31610: NEG
31611: PUSH
31612: LD_INT 1
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 3
31622: NEG
31623: PUSH
31624: LD_INT 2
31626: NEG
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 3
31634: NEG
31635: PUSH
31636: LD_INT 3
31638: NEG
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: EMPTY
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31675: NOP4
31679: PUSH
31680: LD_INT 0
31682: PUSH
31683: LD_INT 0
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: LD_INT 1
31695: NEG
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 1
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 1
31713: PUSH
31714: LD_INT 1
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: LD_INT 1
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 1
31733: NEG
31734: PUSH
31735: LD_INT 0
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PUSH
31742: LD_INT 1
31744: NEG
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: LD_INT 1
31756: NEG
31757: PUSH
31758: LD_INT 2
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 0
31768: PUSH
31769: LD_INT 2
31771: NEG
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 1
31779: PUSH
31780: LD_INT 1
31782: NEG
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: LD_INT 2
31790: PUSH
31791: LD_INT 1
31793: PUSH
31794: EMPTY
31795: LIST
31796: LIST
31797: PUSH
31798: LD_INT 2
31800: PUSH
31801: LD_INT 2
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 1
31810: PUSH
31811: LD_INT 2
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 0
31820: PUSH
31821: LD_INT 2
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 1
31830: NEG
31831: PUSH
31832: LD_INT 1
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 2
31841: NEG
31842: PUSH
31843: LD_INT 1
31845: NEG
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: LD_INT 2
31853: NEG
31854: PUSH
31855: LD_INT 2
31857: NEG
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 2
31865: NEG
31866: PUSH
31867: LD_INT 3
31869: NEG
31870: PUSH
31871: EMPTY
31872: LIST
31873: LIST
31874: PUSH
31875: LD_INT 1
31877: NEG
31878: PUSH
31879: LD_INT 3
31881: NEG
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: PUSH
31887: LD_INT 0
31889: PUSH
31890: LD_INT 3
31892: NEG
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: LD_INT 1
31900: PUSH
31901: LD_INT 2
31903: NEG
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PUSH
31909: LD_INT 3
31911: PUSH
31912: LD_INT 2
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 3
31921: PUSH
31922: LD_INT 3
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 2
31931: PUSH
31932: LD_INT 3
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 1
31941: PUSH
31942: LD_INT 3
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 0
31951: PUSH
31952: LD_INT 3
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 1
31961: NEG
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 3
31972: NEG
31973: PUSH
31974: LD_INT 2
31976: NEG
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: LD_INT 3
31984: NEG
31985: PUSH
31986: LD_INT 3
31988: NEG
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: LIST
31998: LIST
31999: LIST
32000: LIST
32001: LIST
32002: LIST
32003: LIST
32004: LIST
32005: LIST
32006: LIST
32007: LIST
32008: LIST
32009: LIST
32010: LIST
32011: LIST
32012: LIST
32013: LIST
32014: LIST
32015: LIST
32016: LIST
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32025: NOP4
32029: PUSH
32030: LD_INT 0
32032: PUSH
32033: LD_INT 0
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 0
32042: PUSH
32043: LD_INT 1
32045: NEG
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: LD_INT 1
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 1
32063: PUSH
32064: LD_INT 1
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 0
32073: PUSH
32074: LD_INT 1
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 1
32083: NEG
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 1
32094: NEG
32095: PUSH
32096: LD_INT 1
32098: NEG
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 1
32106: NEG
32107: PUSH
32108: LD_INT 2
32110: NEG
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 0
32118: PUSH
32119: LD_INT 2
32121: NEG
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 1
32129: PUSH
32130: LD_INT 1
32132: NEG
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 2
32140: PUSH
32141: LD_INT 0
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 2
32150: PUSH
32151: LD_INT 1
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: PUSH
32158: LD_INT 1
32160: PUSH
32161: LD_INT 2
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 0
32170: PUSH
32171: LD_INT 2
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: LD_INT 1
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 2
32191: NEG
32192: PUSH
32193: LD_INT 0
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 2
32202: NEG
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 1
32214: NEG
32215: PUSH
32216: LD_INT 3
32218: NEG
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: LD_INT 3
32229: NEG
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: PUSH
32235: LD_INT 1
32237: PUSH
32238: LD_INT 2
32240: NEG
32241: PUSH
32242: EMPTY
32243: LIST
32244: LIST
32245: PUSH
32246: LD_INT 2
32248: PUSH
32249: LD_INT 1
32251: NEG
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: LD_INT 3
32259: PUSH
32260: LD_INT 0
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 3
32269: PUSH
32270: LD_INT 1
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 1
32279: PUSH
32280: LD_INT 3
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 0
32289: PUSH
32290: LD_INT 3
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: LD_INT 2
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 2
32310: NEG
32311: PUSH
32312: LD_INT 1
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 3
32321: NEG
32322: PUSH
32323: LD_INT 0
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 3
32332: NEG
32333: PUSH
32334: LD_INT 1
32336: NEG
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: LIST
32346: LIST
32347: LIST
32348: LIST
32349: LIST
32350: LIST
32351: LIST
32352: LIST
32353: LIST
32354: LIST
32355: LIST
32356: LIST
32357: LIST
32358: LIST
32359: LIST
32360: LIST
32361: LIST
32362: LIST
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: LIST
32371: LIST
32372: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32373: NOP4
32377: PUSH
32378: LD_INT 0
32380: PUSH
32381: LD_INT 0
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 0
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 1
32401: PUSH
32402: LD_INT 0
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: LD_INT 1
32411: PUSH
32412: LD_INT 1
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 0
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 1
32431: NEG
32432: PUSH
32433: LD_INT 0
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 1
32442: NEG
32443: PUSH
32444: LD_INT 1
32446: NEG
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 1
32454: NEG
32455: PUSH
32456: LD_INT 2
32458: NEG
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 0
32466: PUSH
32467: LD_INT 2
32469: NEG
32470: PUSH
32471: EMPTY
32472: LIST
32473: LIST
32474: PUSH
32475: LD_INT 1
32477: PUSH
32478: LD_INT 1
32480: NEG
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 2
32488: NEG
32489: PUSH
32490: LD_INT 1
32492: NEG
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 2
32500: NEG
32501: PUSH
32502: LD_INT 2
32504: NEG
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32524: NOP4
32528: PUSH
32529: LD_INT 0
32531: PUSH
32532: LD_INT 0
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 0
32541: PUSH
32542: LD_INT 1
32544: NEG
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 1
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: PUSH
32563: LD_INT 1
32565: PUSH
32566: EMPTY
32567: LIST
32568: LIST
32569: PUSH
32570: LD_INT 0
32572: PUSH
32573: LD_INT 1
32575: PUSH
32576: EMPTY
32577: LIST
32578: LIST
32579: PUSH
32580: LD_INT 1
32582: NEG
32583: PUSH
32584: LD_INT 0
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 1
32593: NEG
32594: PUSH
32595: LD_INT 1
32597: NEG
32598: PUSH
32599: EMPTY
32600: LIST
32601: LIST
32602: PUSH
32603: LD_INT 1
32605: NEG
32606: PUSH
32607: LD_INT 2
32609: NEG
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 0
32617: PUSH
32618: LD_INT 2
32620: NEG
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 1
32628: PUSH
32629: LD_INT 1
32631: NEG
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 2
32639: PUSH
32640: LD_INT 0
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 2
32649: PUSH
32650: LD_INT 1
32652: PUSH
32653: EMPTY
32654: LIST
32655: LIST
32656: PUSH
32657: EMPTY
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
32671: NOP4
32675: PUSH
32676: LD_INT 0
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 0
32688: PUSH
32689: LD_INT 1
32691: NEG
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 1
32699: PUSH
32700: LD_INT 0
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 1
32709: PUSH
32710: LD_INT 1
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: LD_INT 0
32719: PUSH
32720: LD_INT 1
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: LD_INT 0
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 1
32740: NEG
32741: PUSH
32742: LD_INT 1
32744: NEG
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: LD_INT 1
32755: NEG
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 2
32763: PUSH
32764: LD_INT 0
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: LD_INT 2
32773: PUSH
32774: LD_INT 1
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 2
32783: PUSH
32784: LD_INT 2
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 1
32793: PUSH
32794: LD_INT 2
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: LIST
32805: LIST
32806: LIST
32807: LIST
32808: LIST
32809: LIST
32810: LIST
32811: LIST
32812: LIST
32813: LIST
32814: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32815: NOP4
32819: PUSH
32820: LD_INT 0
32822: PUSH
32823: LD_INT 0
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 0
32832: PUSH
32833: LD_INT 1
32835: NEG
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 1
32843: PUSH
32844: LD_INT 0
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: LD_INT 1
32853: PUSH
32854: LD_INT 1
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 0
32863: PUSH
32864: LD_INT 1
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 1
32873: NEG
32874: PUSH
32875: LD_INT 0
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 1
32884: NEG
32885: PUSH
32886: LD_INT 1
32888: NEG
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 2
32896: PUSH
32897: LD_INT 1
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: LD_INT 2
32906: PUSH
32907: LD_INT 2
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 1
32916: PUSH
32917: LD_INT 2
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 0
32926: PUSH
32927: LD_INT 2
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 1
32936: NEG
32937: PUSH
32938: LD_INT 1
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: LIST
32952: LIST
32953: LIST
32954: LIST
32955: LIST
32956: LIST
32957: LIST
32958: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32959: NOP4
32963: PUSH
32964: LD_INT 0
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: PUSH
32974: LD_INT 0
32976: PUSH
32977: LD_INT 1
32979: NEG
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 1
32987: PUSH
32988: LD_INT 0
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 1
32997: PUSH
32998: LD_INT 1
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 0
33007: PUSH
33008: LD_INT 1
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 1
33017: NEG
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 1
33028: NEG
33029: PUSH
33030: LD_INT 1
33032: NEG
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: LD_INT 2
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 0
33050: PUSH
33051: LD_INT 2
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 1
33060: NEG
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 0
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 2
33082: NEG
33083: PUSH
33084: LD_INT 1
33086: NEG
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: LIST
33096: LIST
33097: LIST
33098: LIST
33099: LIST
33100: LIST
33101: LIST
33102: LIST
33103: LIST
33104: LIST
33105: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33106: NOP4
33110: PUSH
33111: LD_INT 0
33113: PUSH
33114: LD_INT 0
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: LD_INT 1
33126: NEG
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: LD_INT 0
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: PUSH
33145: LD_INT 1
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 0
33154: PUSH
33155: LD_INT 1
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 1
33164: NEG
33165: PUSH
33166: LD_INT 0
33168: PUSH
33169: EMPTY
33170: LIST
33171: LIST
33172: PUSH
33173: LD_INT 1
33175: NEG
33176: PUSH
33177: LD_INT 1
33179: NEG
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 1
33187: NEG
33188: PUSH
33189: LD_INT 2
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 1
33199: NEG
33200: PUSH
33201: LD_INT 1
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 2
33210: NEG
33211: PUSH
33212: LD_INT 0
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 2
33221: NEG
33222: PUSH
33223: LD_INT 1
33225: NEG
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: LD_INT 2
33237: NEG
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: LIST
33247: LIST
33248: LIST
33249: LIST
33250: LIST
33251: LIST
33252: LIST
33253: LIST
33254: LIST
33255: LIST
33256: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33257: NOP4
33261: PUSH
33262: LD_INT 0
33264: PUSH
33265: LD_INT 0
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: LD_INT 1
33277: NEG
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: PUSH
33283: LD_INT 1
33285: PUSH
33286: LD_INT 0
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: LD_INT 1
33298: PUSH
33299: EMPTY
33300: LIST
33301: LIST
33302: PUSH
33303: LD_INT 0
33305: PUSH
33306: LD_INT 1
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PUSH
33313: LD_INT 1
33315: NEG
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 1
33326: NEG
33327: PUSH
33328: LD_INT 1
33330: NEG
33331: PUSH
33332: EMPTY
33333: LIST
33334: LIST
33335: PUSH
33336: LD_INT 1
33338: NEG
33339: PUSH
33340: LD_INT 2
33342: NEG
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 0
33350: PUSH
33351: LD_INT 2
33353: NEG
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: LD_INT 1
33364: NEG
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: LD_INT 2
33372: PUSH
33373: LD_INT 0
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 2
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 2
33392: PUSH
33393: LD_INT 2
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 2
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 0
33412: PUSH
33413: LD_INT 2
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 1
33422: NEG
33423: PUSH
33424: LD_INT 1
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 2
33433: NEG
33434: PUSH
33435: LD_INT 0
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 2
33444: NEG
33445: PUSH
33446: LD_INT 1
33448: NEG
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 2
33456: NEG
33457: PUSH
33458: LD_INT 2
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33487: NOP4
33491: PUSH
33492: LD_INT 0
33494: PUSH
33495: LD_INT 0
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 0
33504: PUSH
33505: LD_INT 1
33507: NEG
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 1
33515: PUSH
33516: LD_INT 0
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PUSH
33523: LD_INT 1
33525: PUSH
33526: LD_INT 1
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 0
33535: PUSH
33536: LD_INT 1
33538: PUSH
33539: EMPTY
33540: LIST
33541: LIST
33542: PUSH
33543: LD_INT 1
33545: NEG
33546: PUSH
33547: LD_INT 0
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 1
33556: NEG
33557: PUSH
33558: LD_INT 1
33560: NEG
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: NEG
33569: PUSH
33570: LD_INT 2
33572: NEG
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 0
33580: PUSH
33581: LD_INT 2
33583: NEG
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 1
33591: PUSH
33592: LD_INT 1
33594: NEG
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 2
33602: PUSH
33603: LD_INT 0
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 2
33612: PUSH
33613: LD_INT 1
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 2
33622: PUSH
33623: LD_INT 2
33625: PUSH
33626: EMPTY
33627: LIST
33628: LIST
33629: PUSH
33630: LD_INT 1
33632: PUSH
33633: LD_INT 2
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 0
33642: PUSH
33643: LD_INT 2
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 1
33652: NEG
33653: PUSH
33654: LD_INT 1
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 2
33663: NEG
33664: PUSH
33665: LD_INT 0
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 2
33674: NEG
33675: PUSH
33676: LD_INT 1
33678: NEG
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 2
33686: NEG
33687: PUSH
33688: LD_INT 2
33690: NEG
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33717: NOP4
33721: PUSH
33722: LD_INT 0
33724: PUSH
33725: LD_INT 0
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: LD_INT 1
33737: NEG
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 1
33745: PUSH
33746: LD_INT 0
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 1
33755: PUSH
33756: LD_INT 1
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 0
33765: PUSH
33766: LD_INT 1
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PUSH
33773: LD_INT 1
33775: NEG
33776: PUSH
33777: LD_INT 0
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: LD_INT 1
33790: NEG
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: LD_INT 2
33802: NEG
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: LD_INT 2
33813: NEG
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 1
33821: PUSH
33822: LD_INT 1
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 2
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 2
33842: PUSH
33843: LD_INT 1
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 2
33852: PUSH
33853: LD_INT 2
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 1
33862: PUSH
33863: LD_INT 2
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: LD_INT 0
33872: PUSH
33873: LD_INT 2
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: LD_INT 1
33882: NEG
33883: PUSH
33884: LD_INT 1
33886: PUSH
33887: EMPTY
33888: LIST
33889: LIST
33890: PUSH
33891: LD_INT 2
33893: NEG
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 2
33904: NEG
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: PUSH
33914: LD_INT 2
33916: NEG
33917: PUSH
33918: LD_INT 2
33920: NEG
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: LIST
33945: LIST
33946: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33947: NOP4
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: LD_INT 0
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 0
33964: PUSH
33965: LD_INT 1
33967: NEG
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 1
33975: PUSH
33976: LD_INT 0
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 1
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: LD_INT 1
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 1
34005: NEG
34006: PUSH
34007: LD_INT 0
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 1
34016: NEG
34017: PUSH
34018: LD_INT 1
34020: NEG
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: LD_INT 1
34028: NEG
34029: PUSH
34030: LD_INT 2
34032: NEG
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: LD_INT 0
34040: PUSH
34041: LD_INT 2
34043: NEG
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 1
34051: PUSH
34052: LD_INT 1
34054: NEG
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 2
34062: PUSH
34063: LD_INT 0
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 2
34072: PUSH
34073: LD_INT 1
34075: PUSH
34076: EMPTY
34077: LIST
34078: LIST
34079: PUSH
34080: LD_INT 2
34082: PUSH
34083: LD_INT 2
34085: PUSH
34086: EMPTY
34087: LIST
34088: LIST
34089: PUSH
34090: LD_INT 1
34092: PUSH
34093: LD_INT 2
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 1
34112: NEG
34113: PUSH
34114: LD_INT 1
34116: PUSH
34117: EMPTY
34118: LIST
34119: LIST
34120: PUSH
34121: LD_INT 2
34123: NEG
34124: PUSH
34125: LD_INT 0
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 2
34134: NEG
34135: PUSH
34136: LD_INT 1
34138: NEG
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 2
34146: NEG
34147: PUSH
34148: LD_INT 2
34150: NEG
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: EMPTY
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: LIST
34173: LIST
34174: LIST
34175: LIST
34176: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34177: NOP4
34181: PUSH
34182: LD_INT 0
34184: PUSH
34185: LD_INT 0
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: LD_INT 1
34197: NEG
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: PUSH
34206: LD_INT 0
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: LD_INT 1
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 0
34225: PUSH
34226: LD_INT 1
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 1
34235: NEG
34236: PUSH
34237: LD_INT 0
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: LD_INT 1
34250: NEG
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 1
34258: NEG
34259: PUSH
34260: LD_INT 2
34262: NEG
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: LD_INT 0
34270: PUSH
34271: LD_INT 2
34273: NEG
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 1
34281: PUSH
34282: LD_INT 1
34284: NEG
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 2
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 2
34302: PUSH
34303: LD_INT 1
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 2
34312: PUSH
34313: LD_INT 2
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 1
34322: PUSH
34323: LD_INT 2
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 0
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: LD_INT 1
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: PUSH
34351: LD_INT 2
34353: NEG
34354: PUSH
34355: LD_INT 0
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 2
34364: NEG
34365: PUSH
34366: LD_INT 1
34368: NEG
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 2
34376: NEG
34377: PUSH
34378: LD_INT 2
34380: NEG
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34407: NOP4
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: LD_INT 0
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: LD_INT 0
34424: PUSH
34425: LD_INT 1
34427: NEG
34428: PUSH
34429: EMPTY
34430: LIST
34431: LIST
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: LD_INT 0
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: LD_INT 1
34445: PUSH
34446: LD_INT 1
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: LD_INT 1
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 1
34465: NEG
34466: PUSH
34467: LD_INT 0
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: NEG
34477: PUSH
34478: LD_INT 1
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 1
34488: NEG
34489: PUSH
34490: LD_INT 2
34492: NEG
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 0
34500: PUSH
34501: LD_INT 2
34503: NEG
34504: PUSH
34505: EMPTY
34506: LIST
34507: LIST
34508: PUSH
34509: LD_INT 1
34511: PUSH
34512: LD_INT 1
34514: NEG
34515: PUSH
34516: EMPTY
34517: LIST
34518: LIST
34519: PUSH
34520: LD_INT 2
34522: PUSH
34523: LD_INT 0
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 2
34532: PUSH
34533: LD_INT 1
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 2
34542: PUSH
34543: LD_INT 2
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PUSH
34550: LD_INT 1
34552: PUSH
34553: LD_INT 2
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 0
34562: PUSH
34563: LD_INT 2
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 1
34572: NEG
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 2
34583: NEG
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 2
34594: NEG
34595: PUSH
34596: LD_INT 1
34598: NEG
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 2
34606: NEG
34607: PUSH
34608: LD_INT 2
34610: NEG
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34637: NOP4
34641: PUSH
34642: LD_INT 0
34644: PUSH
34645: LD_INT 0
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: PUSH
34666: LD_INT 0
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 1
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 1
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 1
34695: NEG
34696: PUSH
34697: LD_INT 0
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34725: NOP4
34729: PUSH
34730: LD_INT 0
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 0
34742: PUSH
34743: LD_INT 1
34745: NEG
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 1
34753: PUSH
34754: LD_INT 0
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 1
34763: PUSH
34764: LD_INT 1
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: LD_INT 1
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 1
34783: NEG
34784: PUSH
34785: LD_INT 0
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: PUSH
34792: LD_INT 1
34794: NEG
34795: PUSH
34796: LD_INT 1
34798: NEG
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: EMPTY
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34813: NOP4
34817: PUSH
34818: LD_INT 0
34820: PUSH
34821: LD_INT 0
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 0
34830: PUSH
34831: LD_INT 1
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: PUSH
34842: LD_INT 0
34844: PUSH
34845: EMPTY
34846: LIST
34847: LIST
34848: PUSH
34849: LD_INT 1
34851: PUSH
34852: LD_INT 1
34854: PUSH
34855: EMPTY
34856: LIST
34857: LIST
34858: PUSH
34859: LD_INT 0
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 1
34871: NEG
34872: PUSH
34873: LD_INT 0
34875: PUSH
34876: EMPTY
34877: LIST
34878: LIST
34879: PUSH
34880: LD_INT 1
34882: NEG
34883: PUSH
34884: LD_INT 1
34886: NEG
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34901: NOP4
34905: PUSH
34906: LD_INT 0
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 0
34918: PUSH
34919: LD_INT 1
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: PUSH
34930: LD_INT 0
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 1
34939: PUSH
34940: LD_INT 1
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: LD_INT 1
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 1
34959: NEG
34960: PUSH
34961: LD_INT 0
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: LD_INT 1
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: EMPTY
34981: LIST
34982: LIST
34983: LIST
34984: LIST
34985: LIST
34986: LIST
34987: LIST
34988: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34989: NOP4
34993: PUSH
34994: LD_INT 0
34996: PUSH
34997: LD_INT 0
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 0
35006: PUSH
35007: LD_INT 1
35009: NEG
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 1
35017: PUSH
35018: LD_INT 0
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 1
35027: PUSH
35028: LD_INT 1
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 0
35037: PUSH
35038: LD_INT 1
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 1
35047: NEG
35048: PUSH
35049: LD_INT 0
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 1
35058: NEG
35059: PUSH
35060: LD_INT 1
35062: NEG
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35077: NOP4
35081: PUSH
35082: LD_INT 0
35084: PUSH
35085: LD_INT 0
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: LD_INT 1
35097: NEG
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: PUSH
35103: LD_INT 1
35105: PUSH
35106: LD_INT 0
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 1
35115: PUSH
35116: LD_INT 1
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: LD_INT 0
35125: PUSH
35126: LD_INT 1
35128: PUSH
35129: EMPTY
35130: LIST
35131: LIST
35132: PUSH
35133: LD_INT 1
35135: NEG
35136: PUSH
35137: LD_INT 0
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: NEG
35147: PUSH
35148: LD_INT 1
35150: NEG
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: ST_TO_ADDR
// end ; 1 :
35165: GO 41062
35167: LD_INT 1
35169: DOUBLE
35170: EQUAL
35171: IFTRUE 35175
35173: GO 37798
35175: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35176: NOP4
35180: PUSH
35181: LD_INT 1
35183: NEG
35184: PUSH
35185: LD_INT 3
35187: NEG
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: LD_INT 3
35198: NEG
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: LD_INT 2
35209: NEG
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: LIST
35219: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35220: NOP4
35224: PUSH
35225: LD_INT 2
35227: PUSH
35228: LD_INT 1
35230: NEG
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 3
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 3
35248: PUSH
35249: LD_INT 1
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: LIST
35260: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35261: NOP4
35265: PUSH
35266: LD_INT 3
35268: PUSH
35269: LD_INT 2
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 3
35278: PUSH
35279: LD_INT 3
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 2
35288: PUSH
35289: LD_INT 3
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: LIST
35300: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35301: NOP4
35305: PUSH
35306: LD_INT 1
35308: PUSH
35309: LD_INT 3
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: LD_INT 3
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 1
35328: NEG
35329: PUSH
35330: LD_INT 2
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: LIST
35341: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35342: NOP4
35346: PUSH
35347: LD_INT 2
35349: NEG
35350: PUSH
35351: LD_INT 1
35353: PUSH
35354: EMPTY
35355: LIST
35356: LIST
35357: PUSH
35358: LD_INT 3
35360: NEG
35361: PUSH
35362: LD_INT 0
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 3
35371: NEG
35372: PUSH
35373: LD_INT 1
35375: NEG
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: LIST
35385: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35386: NOP4
35390: PUSH
35391: LD_INT 2
35393: NEG
35394: PUSH
35395: LD_INT 3
35397: NEG
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 3
35405: NEG
35406: PUSH
35407: LD_INT 2
35409: NEG
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 3
35417: NEG
35418: PUSH
35419: LD_INT 3
35421: NEG
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: LIST
35431: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35432: NOP4
35436: PUSH
35437: LD_INT 1
35439: NEG
35440: PUSH
35441: LD_INT 3
35443: NEG
35444: PUSH
35445: EMPTY
35446: LIST
35447: LIST
35448: PUSH
35449: LD_INT 0
35451: PUSH
35452: LD_INT 3
35454: NEG
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 1
35462: PUSH
35463: LD_INT 2
35465: NEG
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: LIST
35475: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35476: NOP4
35480: PUSH
35481: LD_INT 2
35483: PUSH
35484: LD_INT 1
35486: NEG
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 3
35494: PUSH
35495: LD_INT 0
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PUSH
35502: LD_INT 3
35504: PUSH
35505: LD_INT 1
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: LIST
35516: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35517: NOP4
35521: PUSH
35522: LD_INT 3
35524: PUSH
35525: LD_INT 2
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 3
35534: PUSH
35535: LD_INT 3
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 2
35544: PUSH
35545: LD_INT 3
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: LIST
35556: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35557: NOP4
35561: PUSH
35562: LD_INT 1
35564: PUSH
35565: LD_INT 3
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 0
35574: PUSH
35575: LD_INT 3
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: NEG
35585: PUSH
35586: LD_INT 2
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: LIST
35597: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35598: NOP4
35602: PUSH
35603: LD_INT 2
35605: NEG
35606: PUSH
35607: LD_INT 1
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 3
35616: NEG
35617: PUSH
35618: LD_INT 0
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: PUSH
35625: LD_INT 3
35627: NEG
35628: PUSH
35629: LD_INT 1
35631: NEG
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: LIST
35641: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35642: NOP4
35646: PUSH
35647: LD_INT 2
35649: NEG
35650: PUSH
35651: LD_INT 3
35653: NEG
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 3
35661: NEG
35662: PUSH
35663: LD_INT 2
35665: NEG
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 3
35673: NEG
35674: PUSH
35675: LD_INT 3
35677: NEG
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: LIST
35687: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
35688: NOP4
35692: PUSH
35693: LD_INT 0
35695: PUSH
35696: LD_INT 3
35698: NEG
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: LD_INT 4
35710: NEG
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 1
35718: PUSH
35719: LD_INT 3
35721: NEG
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: LIST
35731: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
35732: NOP4
35736: PUSH
35737: LD_INT 3
35739: PUSH
35740: LD_INT 0
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 3
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 4
35760: PUSH
35761: LD_INT 1
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: LIST
35772: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
35773: NOP4
35777: PUSH
35778: LD_INT 3
35780: PUSH
35781: LD_INT 3
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 4
35790: PUSH
35791: LD_INT 3
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 3
35800: PUSH
35801: LD_INT 4
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: LIST
35812: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
35813: NOP4
35817: PUSH
35818: LD_INT 0
35820: PUSH
35821: LD_INT 3
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 1
35830: PUSH
35831: LD_INT 4
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 1
35840: NEG
35841: PUSH
35842: LD_INT 3
35844: PUSH
35845: EMPTY
35846: LIST
35847: LIST
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: LIST
35853: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
35854: NOP4
35858: PUSH
35859: LD_INT 3
35861: NEG
35862: PUSH
35863: LD_INT 0
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 3
35872: NEG
35873: PUSH
35874: LD_INT 1
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 4
35883: NEG
35884: PUSH
35885: LD_INT 1
35887: NEG
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: LIST
35897: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
35898: NOP4
35902: PUSH
35903: LD_INT 3
35905: NEG
35906: PUSH
35907: LD_INT 3
35909: NEG
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 3
35917: NEG
35918: PUSH
35919: LD_INT 4
35921: NEG
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: LD_INT 4
35929: NEG
35930: PUSH
35931: LD_INT 3
35933: NEG
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: LIST
35943: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
35944: NOP4
35948: PUSH
35949: LD_INT 1
35951: NEG
35952: PUSH
35953: LD_INT 3
35955: NEG
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: LD_INT 3
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: PUSH
35975: LD_INT 2
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 1
35985: NEG
35986: PUSH
35987: LD_INT 4
35989: NEG
35990: PUSH
35991: EMPTY
35992: LIST
35993: LIST
35994: PUSH
35995: LD_INT 0
35997: PUSH
35998: LD_INT 4
36000: NEG
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 1
36008: PUSH
36009: LD_INT 3
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 1
36019: NEG
36020: PUSH
36021: LD_INT 5
36023: NEG
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 0
36031: PUSH
36032: LD_INT 5
36034: NEG
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 1
36042: PUSH
36043: LD_INT 4
36045: NEG
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 1
36053: NEG
36054: PUSH
36055: LD_INT 6
36057: NEG
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 0
36065: PUSH
36066: LD_INT 6
36068: NEG
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 1
36076: PUSH
36077: LD_INT 5
36079: NEG
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
36099: NOP4
36103: PUSH
36104: LD_INT 2
36106: PUSH
36107: LD_INT 1
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 3
36117: PUSH
36118: LD_INT 0
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 3
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 3
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 4
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 4
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 4
36168: PUSH
36169: LD_INT 1
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 5
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 5
36189: PUSH
36190: LD_INT 1
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 5
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 6
36210: PUSH
36211: LD_INT 0
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 6
36220: PUSH
36221: LD_INT 1
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: LIST
36232: LIST
36233: LIST
36234: LIST
36235: LIST
36236: LIST
36237: LIST
36238: LIST
36239: LIST
36240: LIST
36241: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
36242: NOP4
36246: PUSH
36247: LD_INT 3
36249: PUSH
36250: LD_INT 2
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 3
36259: PUSH
36260: LD_INT 3
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 2
36269: PUSH
36270: LD_INT 3
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 4
36279: PUSH
36280: LD_INT 3
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 4
36289: PUSH
36290: LD_INT 4
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 3
36299: PUSH
36300: LD_INT 4
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 5
36309: PUSH
36310: LD_INT 4
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PUSH
36317: LD_INT 5
36319: PUSH
36320: LD_INT 5
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 4
36329: PUSH
36330: LD_INT 5
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: LD_INT 6
36339: PUSH
36340: LD_INT 5
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 6
36349: PUSH
36350: LD_INT 6
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 5
36359: PUSH
36360: LD_INT 6
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36381: NOP4
36385: PUSH
36386: LD_INT 1
36388: PUSH
36389: LD_INT 3
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 0
36398: PUSH
36399: LD_INT 3
36401: PUSH
36402: EMPTY
36403: LIST
36404: LIST
36405: PUSH
36406: LD_INT 1
36408: NEG
36409: PUSH
36410: LD_INT 2
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: PUSH
36420: LD_INT 4
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 4
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: LD_INT 3
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: PUSH
36451: LD_INT 5
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: LD_INT 5
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 1
36470: NEG
36471: PUSH
36472: LD_INT 4
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: PUSH
36482: LD_INT 6
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: LD_INT 6
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 1
36501: NEG
36502: PUSH
36503: LD_INT 5
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36524: NOP4
36528: PUSH
36529: LD_INT 2
36531: NEG
36532: PUSH
36533: LD_INT 1
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 3
36542: NEG
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 3
36553: NEG
36554: PUSH
36555: LD_INT 1
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 3
36565: NEG
36566: PUSH
36567: LD_INT 1
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 4
36576: NEG
36577: PUSH
36578: LD_INT 0
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 4
36587: NEG
36588: PUSH
36589: LD_INT 1
36591: NEG
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 4
36599: NEG
36600: PUSH
36601: LD_INT 1
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 5
36610: NEG
36611: PUSH
36612: LD_INT 0
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 5
36621: NEG
36622: PUSH
36623: LD_INT 1
36625: NEG
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 5
36633: NEG
36634: PUSH
36635: LD_INT 1
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 6
36644: NEG
36645: PUSH
36646: LD_INT 0
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 6
36655: NEG
36656: PUSH
36657: LD_INT 1
36659: NEG
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
36679: NOP4
36683: PUSH
36684: LD_INT 2
36686: NEG
36687: PUSH
36688: LD_INT 3
36690: NEG
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 3
36698: NEG
36699: PUSH
36700: LD_INT 2
36702: NEG
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 3
36710: NEG
36711: PUSH
36712: LD_INT 3
36714: NEG
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 3
36722: NEG
36723: PUSH
36724: LD_INT 4
36726: NEG
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 4
36734: NEG
36735: PUSH
36736: LD_INT 3
36738: NEG
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 4
36746: NEG
36747: PUSH
36748: LD_INT 4
36750: NEG
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 4
36758: NEG
36759: PUSH
36760: LD_INT 5
36762: NEG
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 5
36770: NEG
36771: PUSH
36772: LD_INT 4
36774: NEG
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 5
36782: NEG
36783: PUSH
36784: LD_INT 5
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 5
36794: NEG
36795: PUSH
36796: LD_INT 6
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 6
36806: NEG
36807: PUSH
36808: LD_INT 5
36810: NEG
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 6
36818: NEG
36819: PUSH
36820: LD_INT 6
36822: NEG
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
36842: NOP4
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: LD_INT 2
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 1
36860: NEG
36861: PUSH
36862: LD_INT 3
36864: NEG
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: LD_INT 1
36872: PUSH
36873: LD_INT 2
36875: NEG
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: LIST
36885: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
36886: NOP4
36890: PUSH
36891: LD_INT 2
36893: PUSH
36894: LD_INT 0
36896: PUSH
36897: EMPTY
36898: LIST
36899: LIST
36900: PUSH
36901: LD_INT 2
36903: PUSH
36904: LD_INT 1
36906: NEG
36907: PUSH
36908: EMPTY
36909: LIST
36910: LIST
36911: PUSH
36912: LD_INT 3
36914: PUSH
36915: LD_INT 1
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: LIST
36926: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
36927: NOP4
36931: PUSH
36932: LD_INT 2
36934: PUSH
36935: LD_INT 2
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 3
36944: PUSH
36945: LD_INT 2
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 2
36954: PUSH
36955: LD_INT 3
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: LIST
36966: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
36967: NOP4
36971: PUSH
36972: LD_INT 0
36974: PUSH
36975: LD_INT 2
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: PUSH
36982: LD_INT 1
36984: PUSH
36985: LD_INT 3
36987: PUSH
36988: EMPTY
36989: LIST
36990: LIST
36991: PUSH
36992: LD_INT 1
36994: NEG
36995: PUSH
36996: LD_INT 2
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: LIST
37007: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37008: NOP4
37012: PUSH
37013: LD_INT 2
37015: NEG
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: LD_INT 2
37026: NEG
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 3
37037: NEG
37038: PUSH
37039: LD_INT 1
37041: NEG
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: LIST
37051: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
37052: NOP4
37056: PUSH
37057: LD_INT 2
37059: NEG
37060: PUSH
37061: LD_INT 2
37063: NEG
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 2
37071: NEG
37072: PUSH
37073: LD_INT 3
37075: NEG
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 3
37083: NEG
37084: PUSH
37085: LD_INT 2
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: LIST
37097: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
37098: NOP4
37102: PUSH
37103: LD_INT 2
37105: NEG
37106: PUSH
37107: LD_INT 3
37109: NEG
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: LD_INT 3
37121: NEG
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
37131: NOP4
37135: PUSH
37136: LD_INT 1
37138: PUSH
37139: LD_INT 2
37141: NEG
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 2
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: EMPTY
37155: LIST
37156: LIST
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
37162: NOP4
37166: PUSH
37167: LD_INT 3
37169: PUSH
37170: LD_INT 1
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 3
37179: PUSH
37180: LD_INT 2
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
37191: NOP4
37195: PUSH
37196: LD_INT 2
37198: PUSH
37199: LD_INT 3
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PUSH
37206: LD_INT 1
37208: PUSH
37209: LD_INT 3
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
37220: NOP4
37224: PUSH
37225: LD_INT 1
37227: NEG
37228: PUSH
37229: LD_INT 2
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: PUSH
37236: LD_INT 2
37238: NEG
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
37251: NOP4
37255: PUSH
37256: LD_INT 3
37258: NEG
37259: PUSH
37260: LD_INT 1
37262: NEG
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 3
37270: NEG
37271: PUSH
37272: LD_INT 2
37274: NEG
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37284: NOP4
37288: PUSH
37289: LD_INT 1
37291: NEG
37292: PUSH
37293: LD_INT 3
37295: NEG
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 0
37303: PUSH
37304: LD_INT 3
37306: NEG
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 1
37314: PUSH
37315: LD_INT 2
37317: NEG
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: LIST
37327: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37328: NOP4
37332: PUSH
37333: LD_INT 2
37335: PUSH
37336: LD_INT 1
37338: NEG
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 3
37346: PUSH
37347: LD_INT 0
37349: PUSH
37350: EMPTY
37351: LIST
37352: LIST
37353: PUSH
37354: LD_INT 3
37356: PUSH
37357: LD_INT 1
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: LIST
37368: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37369: NOP4
37373: PUSH
37374: LD_INT 3
37376: PUSH
37377: LD_INT 2
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 3
37386: PUSH
37387: LD_INT 3
37389: PUSH
37390: EMPTY
37391: LIST
37392: LIST
37393: PUSH
37394: LD_INT 2
37396: PUSH
37397: LD_INT 3
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: LIST
37408: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37409: NOP4
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: LD_INT 3
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: LD_INT 0
37426: PUSH
37427: LD_INT 3
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 1
37436: NEG
37437: PUSH
37438: LD_INT 2
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: LIST
37449: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37450: NOP4
37454: PUSH
37455: LD_INT 2
37457: NEG
37458: PUSH
37459: LD_INT 1
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: PUSH
37466: LD_INT 3
37468: NEG
37469: PUSH
37470: LD_INT 0
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PUSH
37477: LD_INT 3
37479: NEG
37480: PUSH
37481: LD_INT 1
37483: NEG
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: LIST
37493: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37494: NOP4
37498: PUSH
37499: LD_INT 2
37501: NEG
37502: PUSH
37503: LD_INT 3
37505: NEG
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 3
37513: NEG
37514: PUSH
37515: LD_INT 2
37517: NEG
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 3
37525: NEG
37526: PUSH
37527: LD_INT 3
37529: NEG
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: LIST
37539: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37540: NOP4
37544: PUSH
37545: LD_INT 1
37547: NEG
37548: PUSH
37549: LD_INT 2
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: LD_INT 2
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: PUSH
37571: LD_INT 1
37573: NEG
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: EMPTY
37580: LIST
37581: LIST
37582: LIST
37583: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37584: NOP4
37588: PUSH
37589: LD_INT 1
37591: PUSH
37592: LD_INT 1
37594: NEG
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 2
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 2
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: LIST
37624: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37625: NOP4
37629: PUSH
37630: LD_INT 2
37632: PUSH
37633: LD_INT 1
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 2
37642: PUSH
37643: LD_INT 2
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 1
37652: PUSH
37653: LD_INT 2
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: LIST
37664: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37665: NOP4
37669: PUSH
37670: LD_INT 1
37672: PUSH
37673: LD_INT 2
37675: PUSH
37676: EMPTY
37677: LIST
37678: LIST
37679: PUSH
37680: LD_INT 0
37682: PUSH
37683: LD_INT 2
37685: PUSH
37686: EMPTY
37687: LIST
37688: LIST
37689: PUSH
37690: LD_INT 1
37692: NEG
37693: PUSH
37694: LD_INT 1
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: LIST
37705: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37706: NOP4
37710: PUSH
37711: LD_INT 1
37713: NEG
37714: PUSH
37715: LD_INT 1
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 2
37724: NEG
37725: PUSH
37726: LD_INT 0
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 2
37735: NEG
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: LIST
37749: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37750: NOP4
37754: PUSH
37755: LD_INT 1
37757: NEG
37758: PUSH
37759: LD_INT 2
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 2
37769: NEG
37770: PUSH
37771: LD_INT 1
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 2
37781: NEG
37782: PUSH
37783: LD_INT 2
37785: NEG
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: LIST
37795: ST_TO_ADDR
// end ; 2 :
37796: GO 41062
37798: LD_INT 2
37800: DOUBLE
37801: EQUAL
37802: IFTRUE 37806
37804: GO 41061
37806: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
37807: NOP4
37811: PUSH
37812: LD_INT 4
37814: PUSH
37815: LD_INT 0
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 4
37824: PUSH
37825: LD_INT 1
37827: NEG
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 5
37835: PUSH
37836: LD_INT 0
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 5
37845: PUSH
37846: LD_INT 1
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 4
37855: PUSH
37856: LD_INT 1
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 3
37865: PUSH
37866: LD_INT 0
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 3
37875: PUSH
37876: LD_INT 1
37878: NEG
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 3
37886: PUSH
37887: LD_INT 2
37889: NEG
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 5
37897: PUSH
37898: LD_INT 2
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 3
37907: PUSH
37908: LD_INT 3
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 3
37917: PUSH
37918: LD_INT 2
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 4
37927: PUSH
37928: LD_INT 3
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 4
37937: PUSH
37938: LD_INT 4
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: LD_INT 4
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 2
37957: PUSH
37958: LD_INT 3
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 2
37967: PUSH
37968: LD_INT 2
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 4
37977: PUSH
37978: LD_INT 2
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 2
37987: PUSH
37988: LD_INT 4
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 0
37997: PUSH
37998: LD_INT 4
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 0
38007: PUSH
38008: LD_INT 3
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 1
38017: PUSH
38018: LD_INT 4
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 1
38027: PUSH
38028: LD_INT 5
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 0
38037: PUSH
38038: LD_INT 5
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 1
38047: NEG
38048: PUSH
38049: LD_INT 4
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 3
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 2
38069: PUSH
38070: LD_INT 5
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 2
38079: NEG
38080: PUSH
38081: LD_INT 3
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 3
38090: NEG
38091: PUSH
38092: LD_INT 0
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 3
38101: NEG
38102: PUSH
38103: LD_INT 1
38105: NEG
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 2
38113: NEG
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 2
38124: NEG
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 3
38135: NEG
38136: PUSH
38137: LD_INT 1
38139: PUSH
38140: EMPTY
38141: LIST
38142: LIST
38143: PUSH
38144: LD_INT 4
38146: NEG
38147: PUSH
38148: LD_INT 0
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: LD_INT 4
38157: NEG
38158: PUSH
38159: LD_INT 1
38161: NEG
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PUSH
38167: LD_INT 4
38169: NEG
38170: PUSH
38171: LD_INT 2
38173: NEG
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 2
38181: NEG
38182: PUSH
38183: LD_INT 2
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: PUSH
38190: LD_INT 4
38192: NEG
38193: PUSH
38194: LD_INT 4
38196: NEG
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 4
38204: NEG
38205: PUSH
38206: LD_INT 5
38208: NEG
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 3
38216: NEG
38217: PUSH
38218: LD_INT 4
38220: NEG
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PUSH
38226: LD_INT 3
38228: NEG
38229: PUSH
38230: LD_INT 3
38232: NEG
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 4
38240: NEG
38241: PUSH
38242: LD_INT 3
38244: NEG
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 5
38252: NEG
38253: PUSH
38254: LD_INT 4
38256: NEG
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 5
38264: NEG
38265: PUSH
38266: LD_INT 5
38268: NEG
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 3
38276: NEG
38277: PUSH
38278: LD_INT 5
38280: NEG
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 5
38288: NEG
38289: PUSH
38290: LD_INT 3
38292: NEG
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: LIST
38302: LIST
38303: LIST
38304: LIST
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: LIST
38310: LIST
38311: LIST
38312: LIST
38313: LIST
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
38345: NOP4
38349: PUSH
38350: LD_INT 4
38352: PUSH
38353: LD_INT 4
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 4
38362: PUSH
38363: LD_INT 3
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 5
38372: PUSH
38373: LD_INT 4
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 5
38382: PUSH
38383: LD_INT 5
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 4
38392: PUSH
38393: LD_INT 5
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 3
38402: PUSH
38403: LD_INT 4
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 3
38412: PUSH
38413: LD_INT 3
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 5
38422: PUSH
38423: LD_INT 3
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: PUSH
38430: LD_INT 3
38432: PUSH
38433: LD_INT 5
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 0
38442: PUSH
38443: LD_INT 3
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 0
38452: PUSH
38453: LD_INT 2
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: LD_INT 3
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 1
38472: PUSH
38473: LD_INT 4
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 0
38482: PUSH
38483: LD_INT 4
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: LD_INT 1
38492: NEG
38493: PUSH
38494: LD_INT 3
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: LD_INT 1
38503: NEG
38504: PUSH
38505: LD_INT 2
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 2
38514: PUSH
38515: LD_INT 4
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 2
38524: NEG
38525: PUSH
38526: LD_INT 2
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 4
38535: NEG
38536: PUSH
38537: LD_INT 0
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PUSH
38544: LD_INT 4
38546: NEG
38547: PUSH
38548: LD_INT 1
38550: NEG
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 3
38558: NEG
38559: PUSH
38560: LD_INT 0
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 3
38569: NEG
38570: PUSH
38571: LD_INT 1
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: PUSH
38578: LD_INT 4
38580: NEG
38581: PUSH
38582: LD_INT 1
38584: PUSH
38585: EMPTY
38586: LIST
38587: LIST
38588: PUSH
38589: LD_INT 5
38591: NEG
38592: PUSH
38593: LD_INT 0
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 5
38602: NEG
38603: PUSH
38604: LD_INT 1
38606: NEG
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 5
38614: NEG
38615: PUSH
38616: LD_INT 2
38618: NEG
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 3
38626: NEG
38627: PUSH
38628: LD_INT 2
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 3
38637: NEG
38638: PUSH
38639: LD_INT 3
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 3
38649: NEG
38650: PUSH
38651: LD_INT 4
38653: NEG
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 2
38661: NEG
38662: PUSH
38663: LD_INT 3
38665: NEG
38666: PUSH
38667: EMPTY
38668: LIST
38669: LIST
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: LD_INT 2
38677: NEG
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 3
38685: NEG
38686: PUSH
38687: LD_INT 2
38689: NEG
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 4
38697: NEG
38698: PUSH
38699: LD_INT 3
38701: NEG
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 4
38709: NEG
38710: PUSH
38711: LD_INT 4
38713: NEG
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 2
38721: NEG
38722: PUSH
38723: LD_INT 4
38725: NEG
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 4
38733: NEG
38734: PUSH
38735: LD_INT 2
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 0
38745: PUSH
38746: LD_INT 4
38748: NEG
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 0
38756: PUSH
38757: LD_INT 5
38759: NEG
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 1
38767: PUSH
38768: LD_INT 4
38770: NEG
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 1
38778: PUSH
38779: LD_INT 3
38781: NEG
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: LD_INT 3
38792: NEG
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 1
38800: NEG
38801: PUSH
38802: LD_INT 4
38804: NEG
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 1
38812: NEG
38813: PUSH
38814: LD_INT 5
38816: NEG
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: LD_INT 2
38824: PUSH
38825: LD_INT 3
38827: NEG
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 2
38835: NEG
38836: PUSH
38837: LD_INT 5
38839: NEG
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: LIST
38849: LIST
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: LIST
38855: LIST
38856: LIST
38857: LIST
38858: LIST
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: LIST
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
38892: NOP4
38896: PUSH
38897: LD_INT 0
38899: PUSH
38900: LD_INT 4
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 0
38909: PUSH
38910: LD_INT 3
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: LD_INT 4
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 1
38929: PUSH
38930: LD_INT 5
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 0
38939: PUSH
38940: LD_INT 5
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: NEG
38950: PUSH
38951: LD_INT 4
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: NEG
38961: PUSH
38962: LD_INT 3
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 2
38971: PUSH
38972: LD_INT 5
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 2
38981: NEG
38982: PUSH
38983: LD_INT 3
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 3
38992: NEG
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 3
39003: NEG
39004: PUSH
39005: LD_INT 1
39007: NEG
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 2
39015: NEG
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 2
39026: NEG
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 3
39037: NEG
39038: PUSH
39039: LD_INT 1
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 4
39048: NEG
39049: PUSH
39050: LD_INT 0
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: LD_INT 4
39059: NEG
39060: PUSH
39061: LD_INT 1
39063: NEG
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 4
39071: NEG
39072: PUSH
39073: LD_INT 2
39075: NEG
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 2
39083: NEG
39084: PUSH
39085: LD_INT 2
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: LD_INT 4
39094: NEG
39095: PUSH
39096: LD_INT 4
39098: NEG
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 4
39106: NEG
39107: PUSH
39108: LD_INT 5
39110: NEG
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: LD_INT 3
39118: NEG
39119: PUSH
39120: LD_INT 4
39122: NEG
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 3
39130: NEG
39131: PUSH
39132: LD_INT 3
39134: NEG
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: LD_INT 4
39142: NEG
39143: PUSH
39144: LD_INT 3
39146: NEG
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 5
39154: NEG
39155: PUSH
39156: LD_INT 4
39158: NEG
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 5
39166: NEG
39167: PUSH
39168: LD_INT 5
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 3
39178: NEG
39179: PUSH
39180: LD_INT 5
39182: NEG
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: LD_INT 5
39190: NEG
39191: PUSH
39192: LD_INT 3
39194: NEG
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: LD_INT 3
39205: NEG
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 0
39213: PUSH
39214: LD_INT 4
39216: NEG
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: LD_INT 3
39227: NEG
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: LD_INT 1
39235: PUSH
39236: LD_INT 2
39238: NEG
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PUSH
39244: LD_INT 0
39246: PUSH
39247: LD_INT 2
39249: NEG
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 1
39257: NEG
39258: PUSH
39259: LD_INT 3
39261: NEG
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 1
39269: NEG
39270: PUSH
39271: LD_INT 4
39273: NEG
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 2
39281: PUSH
39282: LD_INT 2
39284: NEG
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 4
39296: NEG
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 4
39304: PUSH
39305: LD_INT 0
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 4
39314: PUSH
39315: LD_INT 1
39317: NEG
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: LD_INT 5
39325: PUSH
39326: LD_INT 0
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 5
39335: PUSH
39336: LD_INT 1
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 4
39345: PUSH
39346: LD_INT 1
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 3
39355: PUSH
39356: LD_INT 0
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 3
39365: PUSH
39366: LD_INT 1
39368: NEG
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 3
39376: PUSH
39377: LD_INT 2
39379: NEG
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 5
39387: PUSH
39388: LD_INT 2
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: EMPTY
39396: LIST
39397: LIST
39398: LIST
39399: LIST
39400: LIST
39401: LIST
39402: LIST
39403: LIST
39404: LIST
39405: LIST
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: LIST
39413: LIST
39414: LIST
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: LIST
39422: LIST
39423: LIST
39424: LIST
39425: LIST
39426: LIST
39427: LIST
39428: LIST
39429: LIST
39430: LIST
39431: LIST
39432: LIST
39433: LIST
39434: LIST
39435: LIST
39436: LIST
39437: LIST
39438: LIST
39439: LIST
39440: LIST
39441: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39442: NOP4
39446: PUSH
39447: LD_INT 4
39449: NEG
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 4
39460: NEG
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 3
39472: NEG
39473: PUSH
39474: LD_INT 0
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PUSH
39481: LD_INT 3
39483: NEG
39484: PUSH
39485: LD_INT 1
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 4
39494: NEG
39495: PUSH
39496: LD_INT 1
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 5
39505: NEG
39506: PUSH
39507: LD_INT 0
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 5
39516: NEG
39517: PUSH
39518: LD_INT 1
39520: NEG
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 5
39528: NEG
39529: PUSH
39530: LD_INT 2
39532: NEG
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: LD_INT 3
39540: NEG
39541: PUSH
39542: LD_INT 2
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 3
39551: NEG
39552: PUSH
39553: LD_INT 3
39555: NEG
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 3
39563: NEG
39564: PUSH
39565: LD_INT 4
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 2
39575: NEG
39576: PUSH
39577: LD_INT 3
39579: NEG
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: PUSH
39585: LD_INT 2
39587: NEG
39588: PUSH
39589: LD_INT 2
39591: NEG
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 3
39599: NEG
39600: PUSH
39601: LD_INT 2
39603: NEG
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 4
39611: NEG
39612: PUSH
39613: LD_INT 3
39615: NEG
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 4
39623: NEG
39624: PUSH
39625: LD_INT 4
39627: NEG
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 2
39635: NEG
39636: PUSH
39637: LD_INT 4
39639: NEG
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 4
39647: NEG
39648: PUSH
39649: LD_INT 2
39651: NEG
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 0
39659: PUSH
39660: LD_INT 4
39662: NEG
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 0
39670: PUSH
39671: LD_INT 5
39673: NEG
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 1
39681: PUSH
39682: LD_INT 4
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 1
39692: PUSH
39693: LD_INT 3
39695: NEG
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 0
39703: PUSH
39704: LD_INT 3
39706: NEG
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: LD_INT 4
39718: NEG
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 1
39726: NEG
39727: PUSH
39728: LD_INT 5
39730: NEG
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 2
39738: PUSH
39739: LD_INT 3
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 2
39749: NEG
39750: PUSH
39751: LD_INT 5
39753: NEG
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 3
39761: PUSH
39762: LD_INT 0
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 3
39771: PUSH
39772: LD_INT 1
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 4
39782: PUSH
39783: LD_INT 0
39785: PUSH
39786: EMPTY
39787: LIST
39788: LIST
39789: PUSH
39790: LD_INT 4
39792: PUSH
39793: LD_INT 1
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 3
39802: PUSH
39803: LD_INT 1
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: PUSH
39810: LD_INT 2
39812: PUSH
39813: LD_INT 0
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 2
39822: PUSH
39823: LD_INT 1
39825: NEG
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 2
39833: PUSH
39834: LD_INT 2
39836: NEG
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 4
39844: PUSH
39845: LD_INT 2
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 4
39854: PUSH
39855: LD_INT 4
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 4
39864: PUSH
39865: LD_INT 3
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 5
39874: PUSH
39875: LD_INT 4
39877: PUSH
39878: EMPTY
39879: LIST
39880: LIST
39881: PUSH
39882: LD_INT 5
39884: PUSH
39885: LD_INT 5
39887: PUSH
39888: EMPTY
39889: LIST
39890: LIST
39891: PUSH
39892: LD_INT 4
39894: PUSH
39895: LD_INT 5
39897: PUSH
39898: EMPTY
39899: LIST
39900: LIST
39901: PUSH
39902: LD_INT 3
39904: PUSH
39905: LD_INT 4
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: LD_INT 3
39914: PUSH
39915: LD_INT 3
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 5
39924: PUSH
39925: LD_INT 3
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 3
39934: PUSH
39935: LD_INT 5
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
39989: NOP4
39993: PUSH
39994: LD_INT 4
39996: NEG
39997: PUSH
39998: LD_INT 4
40000: NEG
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 4
40008: NEG
40009: PUSH
40010: LD_INT 5
40012: NEG
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 3
40020: NEG
40021: PUSH
40022: LD_INT 4
40024: NEG
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 3
40032: NEG
40033: PUSH
40034: LD_INT 3
40036: NEG
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 4
40044: NEG
40045: PUSH
40046: LD_INT 3
40048: NEG
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 5
40056: NEG
40057: PUSH
40058: LD_INT 4
40060: NEG
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 5
40068: NEG
40069: PUSH
40070: LD_INT 5
40072: NEG
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 3
40080: NEG
40081: PUSH
40082: LD_INT 5
40084: NEG
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 5
40092: NEG
40093: PUSH
40094: LD_INT 3
40096: NEG
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 0
40104: PUSH
40105: LD_INT 3
40107: NEG
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 0
40115: PUSH
40116: LD_INT 4
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 1
40126: PUSH
40127: LD_INT 3
40129: NEG
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 1
40137: PUSH
40138: LD_INT 2
40140: NEG
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 0
40148: PUSH
40149: LD_INT 2
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: NEG
40160: PUSH
40161: LD_INT 3
40163: NEG
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 1
40171: NEG
40172: PUSH
40173: LD_INT 4
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 2
40183: PUSH
40184: LD_INT 2
40186: NEG
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 2
40194: NEG
40195: PUSH
40196: LD_INT 4
40198: NEG
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 4
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 4
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 5
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 5
40237: PUSH
40238: LD_INT 1
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 4
40247: PUSH
40248: LD_INT 1
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 3
40257: PUSH
40258: LD_INT 0
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 3
40267: PUSH
40268: LD_INT 1
40270: NEG
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 3
40278: PUSH
40279: LD_INT 2
40281: NEG
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 5
40289: PUSH
40290: LD_INT 2
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 3
40299: PUSH
40300: LD_INT 3
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 3
40309: PUSH
40310: LD_INT 2
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 4
40319: PUSH
40320: LD_INT 3
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: PUSH
40327: LD_INT 4
40329: PUSH
40330: LD_INT 4
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 3
40339: PUSH
40340: LD_INT 4
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 2
40349: PUSH
40350: LD_INT 3
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: LD_INT 2
40359: PUSH
40360: LD_INT 2
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: PUSH
40367: LD_INT 4
40369: PUSH
40370: LD_INT 2
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 2
40379: PUSH
40380: LD_INT 4
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: LD_INT 0
40389: PUSH
40390: LD_INT 4
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: LD_INT 3
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: LD_INT 1
40409: PUSH
40410: LD_INT 4
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 1
40419: PUSH
40420: LD_INT 5
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 0
40429: PUSH
40430: LD_INT 5
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 1
40439: NEG
40440: PUSH
40441: LD_INT 4
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: NEG
40451: PUSH
40452: LD_INT 3
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 2
40461: PUSH
40462: LD_INT 5
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 2
40471: NEG
40472: PUSH
40473: LD_INT 3
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: LIST
40489: LIST
40490: LIST
40491: LIST
40492: LIST
40493: LIST
40494: LIST
40495: LIST
40496: LIST
40497: LIST
40498: LIST
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: LIST
40513: LIST
40514: LIST
40515: LIST
40516: LIST
40517: LIST
40518: LIST
40519: LIST
40520: LIST
40521: LIST
40522: LIST
40523: LIST
40524: LIST
40525: LIST
40526: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40527: NOP4
40531: PUSH
40532: LD_INT 0
40534: PUSH
40535: LD_INT 4
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 0
40545: PUSH
40546: LD_INT 5
40548: NEG
40549: PUSH
40550: EMPTY
40551: LIST
40552: LIST
40553: PUSH
40554: LD_INT 1
40556: PUSH
40557: LD_INT 4
40559: NEG
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: PUSH
40565: LD_INT 1
40567: PUSH
40568: LD_INT 3
40570: NEG
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 0
40578: PUSH
40579: LD_INT 3
40581: NEG
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 1
40589: NEG
40590: PUSH
40591: LD_INT 4
40593: NEG
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 1
40601: NEG
40602: PUSH
40603: LD_INT 5
40605: NEG
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 2
40613: PUSH
40614: LD_INT 3
40616: NEG
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 2
40624: NEG
40625: PUSH
40626: LD_INT 5
40628: NEG
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 3
40636: PUSH
40637: LD_INT 0
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: PUSH
40644: LD_INT 3
40646: PUSH
40647: LD_INT 1
40649: NEG
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 4
40657: PUSH
40658: LD_INT 0
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 4
40667: PUSH
40668: LD_INT 1
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 3
40677: PUSH
40678: LD_INT 1
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 2
40687: PUSH
40688: LD_INT 0
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 2
40697: PUSH
40698: LD_INT 1
40700: NEG
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 2
40708: PUSH
40709: LD_INT 2
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 4
40719: PUSH
40720: LD_INT 2
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 4
40729: PUSH
40730: LD_INT 4
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 4
40739: PUSH
40740: LD_INT 3
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 5
40749: PUSH
40750: LD_INT 4
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 5
40759: PUSH
40760: LD_INT 5
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 4
40769: PUSH
40770: LD_INT 5
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 3
40779: PUSH
40780: LD_INT 4
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: PUSH
40787: LD_INT 3
40789: PUSH
40790: LD_INT 3
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 5
40799: PUSH
40800: LD_INT 3
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 3
40809: PUSH
40810: LD_INT 5
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: LD_INT 3
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 0
40829: PUSH
40830: LD_INT 2
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 1
40839: PUSH
40840: LD_INT 3
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 1
40849: PUSH
40850: LD_INT 4
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 0
40859: PUSH
40860: LD_INT 4
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 1
40869: NEG
40870: PUSH
40871: LD_INT 3
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 1
40880: NEG
40881: PUSH
40882: LD_INT 2
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 2
40891: PUSH
40892: LD_INT 4
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: LD_INT 2
40901: NEG
40902: PUSH
40903: LD_INT 2
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 4
40912: NEG
40913: PUSH
40914: LD_INT 0
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 4
40923: NEG
40924: PUSH
40925: LD_INT 1
40927: NEG
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 3
40935: NEG
40936: PUSH
40937: LD_INT 0
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 3
40946: NEG
40947: PUSH
40948: LD_INT 1
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 4
40957: NEG
40958: PUSH
40959: LD_INT 1
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 5
40968: NEG
40969: PUSH
40970: LD_INT 0
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 5
40979: NEG
40980: PUSH
40981: LD_INT 1
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 5
40991: NEG
40992: PUSH
40993: LD_INT 2
40995: NEG
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: LD_INT 3
41003: NEG
41004: PUSH
41005: LD_INT 2
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: LIST
41033: LIST
41034: LIST
41035: LIST
41036: LIST
41037: LIST
41038: LIST
41039: LIST
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: ST_TO_ADDR
// end ; end ;
41059: GO 41062
41061: POP
// case btype of b_depot , b_warehouse :
41062: NOP4
41066: PUSH
41067: LD_INT 0
41069: DOUBLE
41070: EQUAL
41071: IFTRUE 41081
41073: LD_INT 1
41075: DOUBLE
41076: EQUAL
41077: IFTRUE 41081
41079: GO 41282
41081: POP
// case nation of nation_american :
41082: NOP4
41086: PUSH
41087: LD_INT 1
41089: DOUBLE
41090: EQUAL
41091: IFTRUE 41095
41093: GO 41151
41095: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
41096: NOP4
41100: PUSH
41101: NOP4
41105: PUSH
41106: NOP4
41110: PUSH
41111: NOP4
41115: PUSH
41116: NOP4
41120: PUSH
41121: NOP4
41125: PUSH
41126: NOP4
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: LIST
41135: LIST
41136: LIST
41137: LIST
41138: PUSH
41139: NOP4
41143: PUSH
41144: LD_INT 1
41146: PLUS
41147: ARRAY
41148: ST_TO_ADDR
41149: GO 41280
41151: LD_INT 2
41153: DOUBLE
41154: EQUAL
41155: IFTRUE 41159
41157: GO 41215
41159: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
41160: NOP4
41164: PUSH
41165: NOP4
41169: PUSH
41170: NOP4
41174: PUSH
41175: NOP4
41179: PUSH
41180: NOP4
41184: PUSH
41185: NOP4
41189: PUSH
41190: NOP4
41194: PUSH
41195: EMPTY
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: PUSH
41203: NOP4
41207: PUSH
41208: LD_INT 1
41210: PLUS
41211: ARRAY
41212: ST_TO_ADDR
41213: GO 41280
41215: LD_INT 3
41217: DOUBLE
41218: EQUAL
41219: IFTRUE 41223
41221: GO 41279
41223: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
41224: NOP4
41228: PUSH
41229: NOP4
41233: PUSH
41234: NOP4
41238: PUSH
41239: NOP4
41243: PUSH
41244: NOP4
41248: PUSH
41249: NOP4
41253: PUSH
41254: NOP4
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: LIST
41266: PUSH
41267: NOP4
41271: PUSH
41272: LD_INT 1
41274: PLUS
41275: ARRAY
41276: ST_TO_ADDR
41277: GO 41280
41279: POP
41280: GO 41835
41282: LD_INT 2
41284: DOUBLE
41285: EQUAL
41286: IFTRUE 41296
41288: LD_INT 3
41290: DOUBLE
41291: EQUAL
41292: IFTRUE 41296
41294: GO 41352
41296: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
41297: NOP4
41301: PUSH
41302: NOP4
41306: PUSH
41307: NOP4
41311: PUSH
41312: NOP4
41316: PUSH
41317: NOP4
41321: PUSH
41322: NOP4
41326: PUSH
41327: NOP4
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: LIST
41336: LIST
41337: LIST
41338: LIST
41339: PUSH
41340: NOP4
41344: PUSH
41345: LD_INT 1
41347: PLUS
41348: ARRAY
41349: ST_TO_ADDR
41350: GO 41835
41352: LD_INT 16
41354: DOUBLE
41355: EQUAL
41356: IFTRUE 41414
41358: LD_INT 17
41360: DOUBLE
41361: EQUAL
41362: IFTRUE 41414
41364: LD_INT 18
41366: DOUBLE
41367: EQUAL
41368: IFTRUE 41414
41370: LD_INT 19
41372: DOUBLE
41373: EQUAL
41374: IFTRUE 41414
41376: LD_INT 22
41378: DOUBLE
41379: EQUAL
41380: IFTRUE 41414
41382: LD_INT 20
41384: DOUBLE
41385: EQUAL
41386: IFTRUE 41414
41388: LD_INT 21
41390: DOUBLE
41391: EQUAL
41392: IFTRUE 41414
41394: LD_INT 23
41396: DOUBLE
41397: EQUAL
41398: IFTRUE 41414
41400: LD_INT 24
41402: DOUBLE
41403: EQUAL
41404: IFTRUE 41414
41406: LD_INT 25
41408: DOUBLE
41409: EQUAL
41410: IFTRUE 41414
41412: GO 41470
41414: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41415: NOP4
41419: PUSH
41420: NOP4
41424: PUSH
41425: NOP4
41429: PUSH
41430: NOP4
41434: PUSH
41435: NOP4
41439: PUSH
41440: NOP4
41444: PUSH
41445: NOP4
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: PUSH
41458: NOP4
41462: PUSH
41463: LD_INT 1
41465: PLUS
41466: ARRAY
41467: ST_TO_ADDR
41468: GO 41835
41470: LD_INT 6
41472: DOUBLE
41473: EQUAL
41474: IFTRUE 41526
41476: LD_INT 7
41478: DOUBLE
41479: EQUAL
41480: IFTRUE 41526
41482: LD_INT 8
41484: DOUBLE
41485: EQUAL
41486: IFTRUE 41526
41488: LD_INT 13
41490: DOUBLE
41491: EQUAL
41492: IFTRUE 41526
41494: LD_INT 12
41496: DOUBLE
41497: EQUAL
41498: IFTRUE 41526
41500: LD_INT 15
41502: DOUBLE
41503: EQUAL
41504: IFTRUE 41526
41506: LD_INT 11
41508: DOUBLE
41509: EQUAL
41510: IFTRUE 41526
41512: LD_INT 14
41514: DOUBLE
41515: EQUAL
41516: IFTRUE 41526
41518: LD_INT 10
41520: DOUBLE
41521: EQUAL
41522: IFTRUE 41526
41524: GO 41582
41526: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41527: NOP4
41531: PUSH
41532: NOP4
41536: PUSH
41537: NOP4
41541: PUSH
41542: NOP4
41546: PUSH
41547: NOP4
41551: PUSH
41552: NOP4
41556: PUSH
41557: NOP4
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: LIST
41566: LIST
41567: LIST
41568: LIST
41569: PUSH
41570: NOP4
41574: PUSH
41575: LD_INT 1
41577: PLUS
41578: ARRAY
41579: ST_TO_ADDR
41580: GO 41835
41582: LD_INT 36
41584: DOUBLE
41585: EQUAL
41586: IFTRUE 41590
41588: GO 41646
41590: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
41591: NOP4
41595: PUSH
41596: NOP4
41600: PUSH
41601: NOP4
41605: PUSH
41606: NOP4
41610: PUSH
41611: NOP4
41615: PUSH
41616: NOP4
41620: PUSH
41621: NOP4
41625: PUSH
41626: EMPTY
41627: LIST
41628: LIST
41629: LIST
41630: LIST
41631: LIST
41632: LIST
41633: PUSH
41634: NOP4
41638: PUSH
41639: LD_INT 1
41641: PLUS
41642: ARRAY
41643: ST_TO_ADDR
41644: GO 41835
41646: LD_INT 4
41648: DOUBLE
41649: EQUAL
41650: IFTRUE 41672
41652: LD_INT 5
41654: DOUBLE
41655: EQUAL
41656: IFTRUE 41672
41658: LD_INT 34
41660: DOUBLE
41661: EQUAL
41662: IFTRUE 41672
41664: LD_INT 37
41666: DOUBLE
41667: EQUAL
41668: IFTRUE 41672
41670: GO 41728
41672: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
41673: NOP4
41677: PUSH
41678: NOP4
41682: PUSH
41683: NOP4
41687: PUSH
41688: NOP4
41692: PUSH
41693: NOP4
41697: PUSH
41698: NOP4
41702: PUSH
41703: NOP4
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: LIST
41712: LIST
41713: LIST
41714: LIST
41715: PUSH
41716: NOP4
41720: PUSH
41721: LD_INT 1
41723: PLUS
41724: ARRAY
41725: ST_TO_ADDR
41726: GO 41835
41728: LD_INT 31
41730: DOUBLE
41731: EQUAL
41732: IFTRUE 41778
41734: LD_INT 32
41736: DOUBLE
41737: EQUAL
41738: IFTRUE 41778
41740: LD_INT 33
41742: DOUBLE
41743: EQUAL
41744: IFTRUE 41778
41746: LD_INT 27
41748: DOUBLE
41749: EQUAL
41750: IFTRUE 41778
41752: LD_INT 26
41754: DOUBLE
41755: EQUAL
41756: IFTRUE 41778
41758: LD_INT 28
41760: DOUBLE
41761: EQUAL
41762: IFTRUE 41778
41764: LD_INT 29
41766: DOUBLE
41767: EQUAL
41768: IFTRUE 41778
41770: LD_INT 30
41772: DOUBLE
41773: EQUAL
41774: IFTRUE 41778
41776: GO 41834
41778: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
41779: NOP4
41783: PUSH
41784: NOP4
41788: PUSH
41789: NOP4
41793: PUSH
41794: NOP4
41798: PUSH
41799: NOP4
41803: PUSH
41804: NOP4
41808: PUSH
41809: NOP4
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: PUSH
41822: NOP4
41826: PUSH
41827: LD_INT 1
41829: PLUS
41830: ARRAY
41831: ST_TO_ADDR
41832: GO 41835
41834: POP
// temp_list2 = [ ] ;
41835: NOP4
41839: PUSH
41840: EMPTY
41841: ST_TO_ADDR
// for i in temp_list do
41842: NOP4
41846: PUSH
41847: NOP4
41851: PUSH
41852: FOR_IN
41853: IFFALSE 41905
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
41855: NOP4
41859: PUSH
41860: NOP4
41864: PUSH
41865: NOP4
41869: PUSH
41870: LD_INT 1
41872: ARRAY
41873: PUSH
41874: NOP4
41878: PLUS
41879: PUSH
41880: NOP4
41884: PUSH
41885: LD_INT 2
41887: ARRAY
41888: PUSH
41889: NOP4
41893: PLUS
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: EMPTY
41900: LIST
41901: ADD
41902: ST_TO_ADDR
41903: GO 41852
41905: POP
41906: POP
// result = temp_list2 ;
41907: NOP4
41911: PUSH
41912: NOP4
41916: ST_TO_ADDR
// end ;
41917: LD_VAR 0 7
41921: RET
// export function EnemyInRange ( unit , dist ) ; begin
41922: LD_INT 0
41924: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
41925: NOP4
41929: PUSH
41930: NOP4
41934: PPUSH
41935: NOP4
41939: PPUSH
41940: NOP4
41944: PPUSH
41945: NOP4
41949: PPUSH
41950: NOP4
41954: PPUSH
41955: NOP4
41959: PPUSH
41960: NOP4
41964: PPUSH
41965: NOP4
41969: PUSH
41970: LD_INT 4
41972: ARRAY
41973: ST_TO_ADDR
// end ;
41974: LD_VAR 0 3
41978: RET
// export function PlayerSeeMe ( unit ) ; begin
41979: LD_INT 0
41981: PPUSH
// result := See ( your_side , unit ) ;
41982: NOP4
41986: PUSH
41987: NOP4
41991: PPUSH
41992: NOP4
41996: PPUSH
41997: NOP4
42001: ST_TO_ADDR
// end ;
42002: LD_VAR 0 2
42006: RET
// export function ReverseDir ( unit ) ; begin
42007: LD_INT 0
42009: PPUSH
// if not unit then
42010: NOP4
42014: NOT
42015: IFFALSE 42019
// exit ;
42017: GO 42042
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
42019: NOP4
42023: PUSH
42024: NOP4
42028: PPUSH
42029: NOP4
42033: PUSH
42034: LD_INT 3
42036: PLUS
42037: PUSH
42038: LD_INT 6
42040: MOD
42041: ST_TO_ADDR
// end ;
42042: LD_VAR 0 2
42046: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
42047: LD_INT 0
42049: PPUSH
42050: PPUSH
42051: PPUSH
42052: PPUSH
42053: PPUSH
// if not hexes then
42054: NOP4
42058: NOT
42059: IFFALSE 42063
// exit ;
42061: GO 42211
// dist := 9999 ;
42063: NOP4
42067: PUSH
42068: LD_INT 9999
42070: ST_TO_ADDR
// for i = 1 to hexes do
42071: NOP4
42075: PUSH
42076: DOUBLE
42077: LD_INT 1
42079: DEC
42080: ST_TO_ADDR
42081: NOP4
42085: PUSH
42086: FOR_TO
42087: IFFALSE 42199
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
42089: NOP4
42093: PPUSH
42094: NOP4
42098: PUSH
42099: NOP4
42103: ARRAY
42104: PUSH
42105: LD_INT 1
42107: ARRAY
42108: PPUSH
42109: NOP4
42113: PUSH
42114: NOP4
42118: ARRAY
42119: PUSH
42120: LD_INT 2
42122: ARRAY
42123: PPUSH
42124: NOP4
42128: PUSH
42129: NOP4
42133: LESS
42134: IFFALSE 42197
// begin hex := hexes [ i ] ;
42136: NOP4
42140: PUSH
42141: NOP4
42145: PUSH
42146: NOP4
42150: ARRAY
42151: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42152: NOP4
42156: PUSH
42157: NOP4
42161: PPUSH
42162: NOP4
42166: PUSH
42167: NOP4
42171: ARRAY
42172: PUSH
42173: LD_INT 1
42175: ARRAY
42176: PPUSH
42177: NOP4
42181: PUSH
42182: NOP4
42186: ARRAY
42187: PUSH
42188: LD_INT 2
42190: ARRAY
42191: PPUSH
42192: NOP4
42196: ST_TO_ADDR
// end ; end ;
42197: GO 42086
42199: POP
42200: POP
// result := hex ;
42201: NOP4
42205: PUSH
42206: NOP4
42210: ST_TO_ADDR
// end ;
42211: LD_VAR 0 3
42215: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
42216: LD_INT 0
42218: PPUSH
42219: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
42220: NOP4
42224: NOT
42225: PUSH
42226: NOP4
42230: PUSH
42231: LD_INT 21
42233: PUSH
42234: LD_INT 2
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 23
42243: PUSH
42244: LD_INT 2
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PPUSH
42255: NOP4
42259: IN
42260: NOT
42261: OR
42262: IFFALSE 42266
// exit ;
42264: GO 42313
// for i = 1 to 3 do
42266: NOP4
42270: PUSH
42271: DOUBLE
42272: LD_INT 1
42274: DEC
42275: ST_TO_ADDR
42276: LD_INT 3
42278: PUSH
42279: FOR_TO
42280: IFFALSE 42311
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
42282: NOP4
42286: PPUSH
42287: NOP4
42291: PPUSH
42292: NOP4
42296: PPUSH
42297: NOP4
42301: PPUSH
42302: LD_INT 1
42304: PPUSH
42305: NOP4
42309: GO 42279
42311: POP
42312: POP
// end ;
42313: LD_VAR 0 2
42317: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
42318: LD_INT 0
42320: PPUSH
42321: PPUSH
42322: PPUSH
42323: PPUSH
42324: PPUSH
42325: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
42326: NOP4
42330: NOT
42331: PUSH
42332: NOP4
42336: NOT
42337: OR
42338: PUSH
42339: NOP4
42343: PPUSH
42344: NOP4
42348: OR
42349: IFFALSE 42353
// exit ;
42351: GO 42794
// x := GetX ( enemy_unit ) ;
42353: NOP4
42357: PUSH
42358: NOP4
42362: PPUSH
42363: NOP4
42367: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42368: NOP4
42372: PUSH
42373: NOP4
42377: PPUSH
42378: NOP4
42382: ST_TO_ADDR
// if not x or not y then
42383: NOP4
42387: NOT
42388: PUSH
42389: NOP4
42393: NOT
42394: OR
42395: IFFALSE 42399
// exit ;
42397: GO 42794
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42399: NOP4
42403: PUSH
42404: NOP4
42408: PPUSH
42409: LD_INT 0
42411: PPUSH
42412: LD_INT 4
42414: PPUSH
42415: NOP4
42419: PUSH
42420: NOP4
42424: PPUSH
42425: LD_INT 0
42427: PPUSH
42428: LD_INT 4
42430: PPUSH
42431: NOP4
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: NOP4
42444: PPUSH
42445: LD_INT 1
42447: PPUSH
42448: LD_INT 4
42450: PPUSH
42451: NOP4
42455: PUSH
42456: NOP4
42460: PPUSH
42461: LD_INT 1
42463: PPUSH
42464: LD_INT 4
42466: PPUSH
42467: NOP4
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: NOP4
42480: PPUSH
42481: LD_INT 2
42483: PPUSH
42484: LD_INT 4
42486: PPUSH
42487: NOP4
42491: PUSH
42492: NOP4
42496: PPUSH
42497: LD_INT 2
42499: PPUSH
42500: LD_INT 4
42502: PPUSH
42503: NOP4
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: NOP4
42516: PPUSH
42517: LD_INT 3
42519: PPUSH
42520: LD_INT 4
42522: PPUSH
42523: NOP4
42527: PUSH
42528: NOP4
42532: PPUSH
42533: LD_INT 3
42535: PPUSH
42536: LD_INT 4
42538: PPUSH
42539: NOP4
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: NOP4
42552: PPUSH
42553: LD_INT 4
42555: PPUSH
42556: LD_INT 4
42558: PPUSH
42559: NOP4
42563: PUSH
42564: NOP4
42568: PPUSH
42569: LD_INT 4
42571: PPUSH
42572: LD_INT 4
42574: PPUSH
42575: NOP4
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: NOP4
42588: PPUSH
42589: LD_INT 5
42591: PPUSH
42592: LD_INT 4
42594: PPUSH
42595: NOP4
42599: PUSH
42600: NOP4
42604: PPUSH
42605: LD_INT 5
42607: PPUSH
42608: LD_INT 4
42610: PPUSH
42611: NOP4
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: LIST
42627: ST_TO_ADDR
// for i = tmp downto 1 do
42628: NOP4
42632: PUSH
42633: DOUBLE
42634: NOP4
42638: INC
42639: ST_TO_ADDR
42640: LD_INT 1
42642: PUSH
42643: FOR_DOWNTO
42644: IFFALSE 42745
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
42646: NOP4
42650: PUSH
42651: NOP4
42655: ARRAY
42656: PUSH
42657: LD_INT 1
42659: ARRAY
42660: PPUSH
42661: NOP4
42665: PUSH
42666: NOP4
42670: ARRAY
42671: PUSH
42672: LD_INT 2
42674: ARRAY
42675: PPUSH
42676: NOP4
42680: NOT
42681: PUSH
42682: NOP4
42686: PUSH
42687: NOP4
42691: ARRAY
42692: PUSH
42693: LD_INT 1
42695: ARRAY
42696: PPUSH
42697: NOP4
42701: PUSH
42702: NOP4
42706: ARRAY
42707: PUSH
42708: LD_INT 2
42710: ARRAY
42711: PPUSH
42712: NOP4
42716: PUSH
42717: LD_INT 0
42719: NONEQUAL
42720: OR
42721: IFFALSE 42743
// tmp := Delete ( tmp , i ) ;
42723: NOP4
42727: PUSH
42728: NOP4
42732: PPUSH
42733: NOP4
42737: PPUSH
42738: NOP4
42742: ST_TO_ADDR
42743: GO 42643
42745: POP
42746: POP
// j := GetClosestHex ( unit , tmp ) ;
42747: NOP4
42751: PUSH
42752: NOP4
42756: PPUSH
42757: NOP4
42761: PPUSH
42762: NOP4
42766: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
42767: NOP4
42771: PPUSH
42772: NOP4
42776: PUSH
42777: LD_INT 1
42779: ARRAY
42780: PPUSH
42781: NOP4
42785: PUSH
42786: LD_INT 2
42788: ARRAY
42789: PPUSH
42790: NOP4
// end ;
42794: LD_VAR 0 3
42798: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
42799: LD_INT 0
42801: PPUSH
42802: PPUSH
42803: PPUSH
// uc_side = 0 ;
42804: LD_ADDR_OWVAR 20
42808: PUSH
42809: LD_INT 0
42811: ST_TO_ADDR
// uc_nation = 0 ;
42812: LD_ADDR_OWVAR 21
42816: PUSH
42817: LD_INT 0
42819: ST_TO_ADDR
// InitHc_All ( ) ;
42820: NOP4
// InitVc ;
42824: NOP4
// if mastodonts then
42828: NOP4
42832: IFFALSE 42899
// for i = 1 to mastodonts do
42834: NOP4
42838: PUSH
42839: DOUBLE
42840: LD_INT 1
42842: DEC
42843: ST_TO_ADDR
42844: NOP4
42848: PUSH
42849: FOR_TO
42850: IFFALSE 42897
// begin vc_chassis := 31 ;
42852: LD_ADDR_OWVAR 37
42856: PUSH
42857: LD_INT 31
42859: ST_TO_ADDR
// vc_control := control_rider ;
42860: LD_ADDR_OWVAR 38
42864: PUSH
42865: LD_INT 4
42867: ST_TO_ADDR
// animal := CreateVehicle ;
42868: NOP4
42872: PUSH
42873: NOP4
42877: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42878: NOP4
42882: PPUSH
42883: NOP4
42887: PPUSH
42888: LD_INT 0
42890: PPUSH
42891: NOP4
// end ;
42895: GO 42849
42897: POP
42898: POP
// if horses then
42899: NOP4
42903: IFFALSE 42970
// for i = 1 to horses do
42905: NOP4
42909: PUSH
42910: DOUBLE
42911: LD_INT 1
42913: DEC
42914: ST_TO_ADDR
42915: NOP4
42919: PUSH
42920: FOR_TO
42921: IFFALSE 42968
// begin hc_class := 21 ;
42923: LD_ADDR_OWVAR 28
42927: PUSH
42928: LD_INT 21
42930: ST_TO_ADDR
// hc_gallery :=  ;
42931: LD_ADDR_OWVAR 33
42935: PUSH
42936: LD_STRING 
42938: ST_TO_ADDR
// animal := CreateHuman ;
42939: NOP4
42943: PUSH
42944: NOP4
42948: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42949: NOP4
42953: PPUSH
42954: NOP4
42958: PPUSH
42959: LD_INT 0
42961: PPUSH
42962: NOP4
// end ;
42966: GO 42920
42968: POP
42969: POP
// if birds then
42970: NOP4
42974: IFFALSE 43041
// for i = 1 to birds do
42976: NOP4
42980: PUSH
42981: DOUBLE
42982: LD_INT 1
42984: DEC
42985: ST_TO_ADDR
42986: NOP4
42990: PUSH
42991: FOR_TO
42992: IFFALSE 43039
// begin hc_class = 18 ;
42994: LD_ADDR_OWVAR 28
42998: PUSH
42999: LD_INT 18
43001: ST_TO_ADDR
// hc_gallery =  ;
43002: LD_ADDR_OWVAR 33
43006: PUSH
43007: LD_STRING 
43009: ST_TO_ADDR
// animal := CreateHuman ;
43010: NOP4
43014: PUSH
43015: NOP4
43019: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43020: NOP4
43024: PPUSH
43025: NOP4
43029: PPUSH
43030: LD_INT 0
43032: PPUSH
43033: NOP4
// end ;
43037: GO 42991
43039: POP
43040: POP
// if tigers then
43041: NOP4
43045: IFFALSE 43129
// for i = 1 to tigers do
43047: NOP4
43051: PUSH
43052: DOUBLE
43053: LD_INT 1
43055: DEC
43056: ST_TO_ADDR
43057: NOP4
43061: PUSH
43062: FOR_TO
43063: IFFALSE 43127
// begin hc_class = class_tiger ;
43065: LD_ADDR_OWVAR 28
43069: PUSH
43070: LD_INT 14
43072: ST_TO_ADDR
// hc_gallery =  ;
43073: LD_ADDR_OWVAR 33
43077: PUSH
43078: LD_STRING 
43080: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
43081: LD_ADDR_OWVAR 35
43085: PUSH
43086: LD_INT 7
43088: NEG
43089: PPUSH
43090: LD_INT 7
43092: PPUSH
43093: NOP4
43097: ST_TO_ADDR
// animal := CreateHuman ;
43098: NOP4
43102: PUSH
43103: NOP4
43107: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43108: NOP4
43112: PPUSH
43113: NOP4
43117: PPUSH
43118: LD_INT 0
43120: PPUSH
43121: NOP4
// end ;
43125: GO 43062
43127: POP
43128: POP
// if apemans then
43129: NOP4
43133: IFFALSE 43256
// for i = 1 to apemans do
43135: NOP4
43139: PUSH
43140: DOUBLE
43141: LD_INT 1
43143: DEC
43144: ST_TO_ADDR
43145: NOP4
43149: PUSH
43150: FOR_TO
43151: IFFALSE 43254
// begin hc_class = class_apeman ;
43153: LD_ADDR_OWVAR 28
43157: PUSH
43158: LD_INT 12
43160: ST_TO_ADDR
// hc_gallery =  ;
43161: LD_ADDR_OWVAR 33
43165: PUSH
43166: LD_STRING 
43168: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
43169: LD_ADDR_OWVAR 35
43173: PUSH
43174: LD_INT 5
43176: NEG
43177: PPUSH
43178: LD_INT 5
43180: PPUSH
43181: NOP4
43185: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
43186: LD_ADDR_OWVAR 31
43190: PUSH
43191: LD_INT 1
43193: PPUSH
43194: LD_INT 3
43196: PPUSH
43197: NOP4
43201: PUSH
43202: LD_INT 1
43204: PPUSH
43205: LD_INT 3
43207: PPUSH
43208: NOP4
43212: PUSH
43213: LD_INT 0
43215: PUSH
43216: LD_INT 0
43218: PUSH
43219: EMPTY
43220: LIST
43221: LIST
43222: LIST
43223: LIST
43224: ST_TO_ADDR
// animal := CreateHuman ;
43225: NOP4
43229: PUSH
43230: NOP4
43234: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43235: NOP4
43239: PPUSH
43240: NOP4
43244: PPUSH
43245: LD_INT 0
43247: PPUSH
43248: NOP4
// end ;
43252: GO 43150
43254: POP
43255: POP
// if enchidnas then
43256: NOP4
43260: IFFALSE 43327
// for i = 1 to enchidnas do
43262: NOP4
43266: PUSH
43267: DOUBLE
43268: LD_INT 1
43270: DEC
43271: ST_TO_ADDR
43272: NOP4
43276: PUSH
43277: FOR_TO
43278: IFFALSE 43325
// begin hc_class = 13 ;
43280: LD_ADDR_OWVAR 28
43284: PUSH
43285: LD_INT 13
43287: ST_TO_ADDR
// hc_gallery =  ;
43288: LD_ADDR_OWVAR 33
43292: PUSH
43293: LD_STRING 
43295: ST_TO_ADDR
// animal := CreateHuman ;
43296: NOP4
43300: PUSH
43301: NOP4
43305: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
43306: NOP4
43310: PPUSH
43311: NOP4
43315: PPUSH
43316: LD_INT 0
43318: PPUSH
43319: NOP4
// end ;
43323: GO 43277
43325: POP
43326: POP
// if fishes then
43327: NOP4
43331: IFFALSE 43398
// for i = 1 to fishes do
43333: NOP4
43337: PUSH
43338: DOUBLE
43339: LD_INT 1
43341: DEC
43342: ST_TO_ADDR
43343: NOP4
43347: PUSH
43348: FOR_TO
43349: IFFALSE 43396
// begin hc_class = 20 ;
43351: LD_ADDR_OWVAR 28
43355: PUSH
43356: LD_INT 20
43358: ST_TO_ADDR
// hc_gallery =  ;
43359: LD_ADDR_OWVAR 33
43363: PUSH
43364: LD_STRING 
43366: ST_TO_ADDR
// animal := CreateHuman ;
43367: NOP4
43371: PUSH
43372: NOP4
43376: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43377: NOP4
43381: PPUSH
43382: NOP4
43386: PPUSH
43387: LD_INT 0
43389: PPUSH
43390: NOP4
// end ;
43394: GO 43348
43396: POP
43397: POP
// end ;
43398: LD_VAR 0 10
43402: RET
// export function WantHeal ( sci , unit ) ; begin
43403: LD_INT 0
43405: PPUSH
// if GetTaskList ( sci ) > 0 then
43406: NOP4
43410: PPUSH
43411: NOP4
43415: PUSH
43416: LD_INT 0
43418: GREATER
43419: IFFALSE 43489
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43421: NOP4
43425: PPUSH
43426: NOP4
43430: PUSH
43431: LD_INT 1
43433: ARRAY
43434: PUSH
43435: LD_INT 1
43437: ARRAY
43438: PUSH
43439: LD_STRING l
43441: EQUAL
43442: PUSH
43443: NOP4
43447: PPUSH
43448: NOP4
43452: PUSH
43453: LD_INT 1
43455: ARRAY
43456: PUSH
43457: LD_INT 4
43459: ARRAY
43460: PUSH
43461: NOP4
43465: EQUAL
43466: AND
43467: IFFALSE 43479
// result := true else
43469: NOP4
43473: PUSH
43474: LD_INT 1
43476: ST_TO_ADDR
43477: GO 43487
// result := false ;
43479: NOP4
43483: PUSH
43484: LD_INT 0
43486: ST_TO_ADDR
// end else
43487: GO 43497
// result := false ;
43489: NOP4
43493: PUSH
43494: LD_INT 0
43496: ST_TO_ADDR
// end ;
43497: LD_VAR 0 3
43501: RET
// export function HealTarget ( sci ) ; begin
43502: LD_INT 0
43504: PPUSH
// if not sci then
43505: NOP4
43509: NOT
43510: IFFALSE 43514
// exit ;
43512: GO 43579
// result := 0 ;
43514: NOP4
43518: PUSH
43519: LD_INT 0
43521: ST_TO_ADDR
// if GetTaskList ( sci ) then
43522: NOP4
43526: PPUSH
43527: NOP4
43531: IFFALSE 43579
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43533: NOP4
43537: PPUSH
43538: NOP4
43542: PUSH
43543: LD_INT 1
43545: ARRAY
43546: PUSH
43547: LD_INT 1
43549: ARRAY
43550: PUSH
43551: LD_STRING l
43553: EQUAL
43554: IFFALSE 43579
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43556: NOP4
43560: PUSH
43561: NOP4
43565: PPUSH
43566: NOP4
43570: PUSH
43571: LD_INT 1
43573: ARRAY
43574: PUSH
43575: LD_INT 4
43577: ARRAY
43578: ST_TO_ADDR
// end ;
43579: LD_VAR 0 2
43583: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43584: LD_INT 0
43586: PPUSH
43587: PPUSH
43588: PPUSH
43589: PPUSH
// if not base_units then
43590: NOP4
43594: NOT
43595: IFFALSE 43599
// exit ;
43597: GO 43686
// result := false ;
43599: NOP4
43603: PUSH
43604: LD_INT 0
43606: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
43607: NOP4
43611: PUSH
43612: NOP4
43616: PPUSH
43617: LD_INT 21
43619: PUSH
43620: LD_INT 3
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PPUSH
43627: NOP4
43631: ST_TO_ADDR
// if not tmp then
43632: NOP4
43636: NOT
43637: IFFALSE 43641
// exit ;
43639: GO 43686
// for i in tmp do
43641: NOP4
43645: PUSH
43646: NOP4
43650: PUSH
43651: FOR_IN
43652: IFFALSE 43684
// begin result := EnemyInRange ( i , 22 ) ;
43654: NOP4
43658: PUSH
43659: NOP4
43663: PPUSH
43664: LD_INT 22
43666: PPUSH
43667: NOP4
43671: ST_TO_ADDR
// if result then
43672: NOP4
43676: IFFALSE 43682
// exit ;
43678: POP
43679: POP
43680: GO 43686
// end ;
43682: GO 43651
43684: POP
43685: POP
// end ;
43686: LD_VAR 0 2
43690: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
43691: LD_INT 0
43693: PPUSH
43694: PPUSH
// if not units then
43695: NOP4
43699: NOT
43700: IFFALSE 43704
// exit ;
43702: GO 43774
// result := [ ] ;
43704: NOP4
43708: PUSH
43709: EMPTY
43710: ST_TO_ADDR
// for i in units do
43711: NOP4
43715: PUSH
43716: NOP4
43720: PUSH
43721: FOR_IN
43722: IFFALSE 43772
// if GetTag ( i ) = tag then
43724: NOP4
43728: PPUSH
43729: NOP4
43733: PUSH
43734: NOP4
43738: EQUAL
43739: IFFALSE 43770
// result := Insert ( result , result + 1 , i ) ;
43741: NOP4
43745: PUSH
43746: NOP4
43750: PPUSH
43751: NOP4
43755: PUSH
43756: LD_INT 1
43758: PLUS
43759: PPUSH
43760: NOP4
43764: PPUSH
43765: NOP4
43769: ST_TO_ADDR
43770: GO 43721
43772: POP
43773: POP
// end ;
43774: LD_VAR 0 3
43778: RET
// export function IsDriver ( un ) ; begin
43779: LD_INT 0
43781: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
43782: NOP4
43786: PUSH
43787: NOP4
43791: PUSH
43792: LD_INT 55
43794: PUSH
43795: EMPTY
43796: LIST
43797: PPUSH
43798: NOP4
43802: IN
43803: ST_TO_ADDR
// end ;
43804: LD_VAR 0 2
43808: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
43809: LD_INT 0
43811: PPUSH
43812: PPUSH
// list := [ ] ;
43813: NOP4
43817: PUSH
43818: EMPTY
43819: ST_TO_ADDR
// case d of 0 :
43820: NOP4
43824: PUSH
43825: LD_INT 0
43827: DOUBLE
43828: EQUAL
43829: IFTRUE 43833
43831: GO 43966
43833: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
43834: NOP4
43838: PUSH
43839: NOP4
43843: PUSH
43844: LD_INT 4
43846: MINUS
43847: PUSH
43848: NOP4
43852: PUSH
43853: LD_INT 4
43855: MINUS
43856: PUSH
43857: LD_INT 2
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: LIST
43864: PUSH
43865: NOP4
43869: PUSH
43870: LD_INT 3
43872: MINUS
43873: PUSH
43874: NOP4
43878: PUSH
43879: LD_INT 1
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: LIST
43886: PUSH
43887: NOP4
43891: PUSH
43892: LD_INT 4
43894: PLUS
43895: PUSH
43896: NOP4
43900: PUSH
43901: LD_INT 4
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: LIST
43908: PUSH
43909: NOP4
43913: PUSH
43914: LD_INT 3
43916: PLUS
43917: PUSH
43918: NOP4
43922: PUSH
43923: LD_INT 3
43925: PLUS
43926: PUSH
43927: LD_INT 5
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: LIST
43934: PUSH
43935: NOP4
43939: PUSH
43940: NOP4
43944: PUSH
43945: LD_INT 4
43947: PLUS
43948: PUSH
43949: LD_INT 0
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: LIST
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: ST_TO_ADDR
// end ; 1 :
43964: GO 44664
43966: LD_INT 1
43968: DOUBLE
43969: EQUAL
43970: IFTRUE 43974
43972: GO 44107
43974: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
43975: NOP4
43979: PUSH
43980: NOP4
43984: PUSH
43985: NOP4
43989: PUSH
43990: LD_INT 4
43992: MINUS
43993: PUSH
43994: LD_INT 3
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: LIST
44001: PUSH
44002: NOP4
44006: PUSH
44007: LD_INT 3
44009: MINUS
44010: PUSH
44011: NOP4
44015: PUSH
44016: LD_INT 3
44018: MINUS
44019: PUSH
44020: LD_INT 2
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: LIST
44027: PUSH
44028: NOP4
44032: PUSH
44033: LD_INT 4
44035: MINUS
44036: PUSH
44037: NOP4
44041: PUSH
44042: LD_INT 1
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: LIST
44049: PUSH
44050: NOP4
44054: PUSH
44055: NOP4
44059: PUSH
44060: LD_INT 3
44062: PLUS
44063: PUSH
44064: LD_INT 0
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: LIST
44071: PUSH
44072: NOP4
44076: PUSH
44077: LD_INT 4
44079: PLUS
44080: PUSH
44081: NOP4
44085: PUSH
44086: LD_INT 4
44088: PLUS
44089: PUSH
44090: LD_INT 5
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: LIST
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: ST_TO_ADDR
// end ; 2 :
44105: GO 44664
44107: LD_INT 2
44109: DOUBLE
44110: EQUAL
44111: IFTRUE 44115
44113: GO 44244
44115: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
44116: NOP4
44120: PUSH
44121: NOP4
44125: PUSH
44126: NOP4
44130: PUSH
44131: LD_INT 3
44133: MINUS
44134: PUSH
44135: LD_INT 3
44137: PUSH
44138: EMPTY
44139: LIST
44140: LIST
44141: LIST
44142: PUSH
44143: NOP4
44147: PUSH
44148: LD_INT 4
44150: PLUS
44151: PUSH
44152: NOP4
44156: PUSH
44157: LD_INT 4
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: LIST
44164: PUSH
44165: NOP4
44169: PUSH
44170: NOP4
44174: PUSH
44175: LD_INT 4
44177: PLUS
44178: PUSH
44179: LD_INT 0
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: LIST
44186: PUSH
44187: NOP4
44191: PUSH
44192: LD_INT 3
44194: MINUS
44195: PUSH
44196: NOP4
44200: PUSH
44201: LD_INT 1
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: LIST
44208: PUSH
44209: NOP4
44213: PUSH
44214: LD_INT 4
44216: MINUS
44217: PUSH
44218: NOP4
44222: PUSH
44223: LD_INT 4
44225: MINUS
44226: PUSH
44227: LD_INT 2
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: LIST
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: ST_TO_ADDR
// end ; 3 :
44242: GO 44664
44244: LD_INT 3
44246: DOUBLE
44247: EQUAL
44248: IFTRUE 44252
44250: GO 44385
44252: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
44253: NOP4
44257: PUSH
44258: NOP4
44262: PUSH
44263: LD_INT 3
44265: PLUS
44266: PUSH
44267: NOP4
44271: PUSH
44272: LD_INT 4
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: LIST
44279: PUSH
44280: NOP4
44284: PUSH
44285: LD_INT 4
44287: PLUS
44288: PUSH
44289: NOP4
44293: PUSH
44294: LD_INT 4
44296: PLUS
44297: PUSH
44298: LD_INT 5
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: LIST
44305: PUSH
44306: NOP4
44310: PUSH
44311: LD_INT 4
44313: MINUS
44314: PUSH
44315: NOP4
44319: PUSH
44320: LD_INT 1
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: LIST
44327: PUSH
44328: NOP4
44332: PUSH
44333: NOP4
44337: PUSH
44338: LD_INT 4
44340: MINUS
44341: PUSH
44342: LD_INT 3
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: LIST
44349: PUSH
44350: NOP4
44354: PUSH
44355: LD_INT 3
44357: MINUS
44358: PUSH
44359: NOP4
44363: PUSH
44364: LD_INT 3
44366: MINUS
44367: PUSH
44368: LD_INT 2
44370: PUSH
44371: EMPTY
44372: LIST
44373: LIST
44374: LIST
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: ST_TO_ADDR
// end ; 4 :
44383: GO 44664
44385: LD_INT 4
44387: DOUBLE
44388: EQUAL
44389: IFTRUE 44393
44391: GO 44526
44393: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44394: NOP4
44398: PUSH
44399: NOP4
44403: PUSH
44404: NOP4
44408: PUSH
44409: LD_INT 4
44411: PLUS
44412: PUSH
44413: LD_INT 0
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: LIST
44420: PUSH
44421: NOP4
44425: PUSH
44426: LD_INT 3
44428: PLUS
44429: PUSH
44430: NOP4
44434: PUSH
44435: LD_INT 3
44437: PLUS
44438: PUSH
44439: LD_INT 5
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: LIST
44446: PUSH
44447: NOP4
44451: PUSH
44452: LD_INT 4
44454: PLUS
44455: PUSH
44456: NOP4
44460: PUSH
44461: LD_INT 4
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: LIST
44468: PUSH
44469: NOP4
44473: PUSH
44474: NOP4
44478: PUSH
44479: LD_INT 3
44481: MINUS
44482: PUSH
44483: LD_INT 3
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: LIST
44490: PUSH
44491: NOP4
44495: PUSH
44496: LD_INT 4
44498: MINUS
44499: PUSH
44500: NOP4
44504: PUSH
44505: LD_INT 4
44507: MINUS
44508: PUSH
44509: LD_INT 2
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: LIST
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: LIST
44523: ST_TO_ADDR
// end ; 5 :
44524: GO 44664
44526: LD_INT 5
44528: DOUBLE
44529: EQUAL
44530: IFTRUE 44534
44532: GO 44663
44534: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44535: NOP4
44539: PUSH
44540: NOP4
44544: PUSH
44545: LD_INT 4
44547: MINUS
44548: PUSH
44549: NOP4
44553: PUSH
44554: LD_INT 1
44556: PUSH
44557: EMPTY
44558: LIST
44559: LIST
44560: LIST
44561: PUSH
44562: NOP4
44566: PUSH
44567: NOP4
44571: PUSH
44572: LD_INT 4
44574: MINUS
44575: PUSH
44576: LD_INT 3
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: LIST
44583: PUSH
44584: NOP4
44588: PUSH
44589: LD_INT 4
44591: PLUS
44592: PUSH
44593: NOP4
44597: PUSH
44598: LD_INT 4
44600: PLUS
44601: PUSH
44602: LD_INT 5
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: LIST
44609: PUSH
44610: NOP4
44614: PUSH
44615: LD_INT 3
44617: PLUS
44618: PUSH
44619: NOP4
44623: PUSH
44624: LD_INT 4
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: LIST
44631: PUSH
44632: NOP4
44636: PUSH
44637: NOP4
44641: PUSH
44642: LD_INT 3
44644: PLUS
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: LIST
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: LIST
44660: ST_TO_ADDR
// end ; end ;
44661: GO 44664
44663: POP
// result := list ;
44664: NOP4
44668: PUSH
44669: NOP4
44673: ST_TO_ADDR
// end ;
44674: LD_VAR 0 4
44678: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
44679: LD_INT 0
44681: PPUSH
44682: PPUSH
44683: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
44684: NOP4
44688: NOT
44689: PUSH
44690: NOP4
44694: PUSH
44695: LD_INT 1
44697: PUSH
44698: LD_INT 2
44700: PUSH
44701: LD_INT 3
44703: PUSH
44704: LD_INT 4
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: LIST
44711: LIST
44712: IN
44713: NOT
44714: OR
44715: IFFALSE 44719
// exit ;
44717: GO 44811
// tmp := [ ] ;
44719: NOP4
44723: PUSH
44724: EMPTY
44725: ST_TO_ADDR
// for i in units do
44726: NOP4
44730: PUSH
44731: NOP4
44735: PUSH
44736: FOR_IN
44737: IFFALSE 44780
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
44739: NOP4
44743: PUSH
44744: NOP4
44748: PPUSH
44749: NOP4
44753: PUSH
44754: LD_INT 1
44756: PLUS
44757: PPUSH
44758: NOP4
44762: PPUSH
44763: NOP4
44767: PPUSH
44768: NOP4
44772: PPUSH
44773: NOP4
44777: ST_TO_ADDR
44778: GO 44736
44780: POP
44781: POP
// if not tmp then
44782: NOP4
44786: NOT
44787: IFFALSE 44791
// exit ;
44789: GO 44811
// result := SortListByListDesc ( units , tmp ) ;
44791: NOP4
44795: PUSH
44796: NOP4
44800: PPUSH
44801: NOP4
44805: PPUSH
44806: NOP4
44810: ST_TO_ADDR
// end ;
44811: LD_VAR 0 3
44815: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
44816: LD_INT 0
44818: PPUSH
44819: PPUSH
44820: PPUSH
// result := false ;
44821: NOP4
44825: PUSH
44826: LD_INT 0
44828: ST_TO_ADDR
// x := GetX ( building ) ;
44829: NOP4
44833: PUSH
44834: NOP4
44838: PPUSH
44839: NOP4
44843: ST_TO_ADDR
// y := GetY ( building ) ;
44844: NOP4
44848: PUSH
44849: NOP4
44853: PPUSH
44854: NOP4
44858: ST_TO_ADDR
// if not building or not x or not y then
44859: NOP4
44863: NOT
44864: PUSH
44865: NOP4
44869: NOT
44870: OR
44871: PUSH
44872: NOP4
44876: NOT
44877: OR
44878: IFFALSE 44882
// exit ;
44880: GO 44974
// if GetTaskList ( unit ) then
44882: NOP4
44886: PPUSH
44887: NOP4
44891: IFFALSE 44974
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44893: LD_STRING e
44895: PUSH
44896: NOP4
44900: PPUSH
44901: NOP4
44905: PUSH
44906: LD_INT 1
44908: ARRAY
44909: PUSH
44910: LD_INT 1
44912: ARRAY
44913: EQUAL
44914: PUSH
44915: NOP4
44919: PUSH
44920: NOP4
44924: PPUSH
44925: NOP4
44929: PUSH
44930: LD_INT 1
44932: ARRAY
44933: PUSH
44934: LD_INT 2
44936: ARRAY
44937: EQUAL
44938: AND
44939: PUSH
44940: NOP4
44944: PUSH
44945: NOP4
44949: PPUSH
44950: NOP4
44954: PUSH
44955: LD_INT 1
44957: ARRAY
44958: PUSH
44959: LD_INT 3
44961: ARRAY
44962: EQUAL
44963: AND
44964: IFFALSE 44974
// result := true end ;
44966: NOP4
44970: PUSH
44971: LD_INT 1
44973: ST_TO_ADDR
// end ;
44974: LD_VAR 0 3
44978: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
44979: LD_INT 0
44981: PPUSH
// result := false ;
44982: NOP4
44986: PUSH
44987: LD_INT 0
44989: ST_TO_ADDR
// if GetTaskList ( unit ) then
44990: NOP4
44994: PPUSH
44995: NOP4
44999: IFFALSE 45082
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
45001: LD_STRING M
45003: PUSH
45004: NOP4
45008: PPUSH
45009: NOP4
45013: PUSH
45014: LD_INT 1
45016: ARRAY
45017: PUSH
45018: LD_INT 1
45020: ARRAY
45021: EQUAL
45022: PUSH
45023: NOP4
45027: PUSH
45028: NOP4
45032: PPUSH
45033: NOP4
45037: PUSH
45038: LD_INT 1
45040: ARRAY
45041: PUSH
45042: LD_INT 2
45044: ARRAY
45045: EQUAL
45046: AND
45047: PUSH
45048: NOP4
45052: PUSH
45053: NOP4
45057: PPUSH
45058: NOP4
45062: PUSH
45063: LD_INT 1
45065: ARRAY
45066: PUSH
45067: LD_INT 3
45069: ARRAY
45070: EQUAL
45071: AND
45072: IFFALSE 45082
// result := true ;
45074: NOP4
45078: PUSH
45079: LD_INT 1
45081: ST_TO_ADDR
// end ; end ;
45082: LD_VAR 0 4
45086: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
45087: LD_INT 0
45089: PPUSH
45090: PPUSH
45091: PPUSH
45092: PPUSH
// if not unit or not area then
45093: NOP4
45097: NOT
45098: PUSH
45099: NOP4
45103: NOT
45104: OR
45105: IFFALSE 45109
// exit ;
45107: GO 45273
// tmp := AreaToList ( area , i ) ;
45109: NOP4
45113: PUSH
45114: NOP4
45118: PPUSH
45119: NOP4
45123: PPUSH
45124: NOP4
45128: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
45129: NOP4
45133: PUSH
45134: DOUBLE
45135: LD_INT 1
45137: DEC
45138: ST_TO_ADDR
45139: NOP4
45143: PUSH
45144: LD_INT 1
45146: ARRAY
45147: PUSH
45148: FOR_TO
45149: IFFALSE 45271
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
45151: NOP4
45155: PUSH
45156: NOP4
45160: PUSH
45161: LD_INT 1
45163: ARRAY
45164: PUSH
45165: NOP4
45169: ARRAY
45170: PUSH
45171: NOP4
45175: PUSH
45176: LD_INT 2
45178: ARRAY
45179: PUSH
45180: NOP4
45184: ARRAY
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
45190: NOP4
45194: PUSH
45195: LD_INT 1
45197: ARRAY
45198: PPUSH
45199: NOP4
45203: PUSH
45204: LD_INT 2
45206: ARRAY
45207: PPUSH
45208: NOP4
45212: PUSH
45213: LD_INT 0
45215: EQUAL
45216: IFFALSE 45269
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
45218: NOP4
45222: PPUSH
45223: NOP4
45227: PUSH
45228: LD_INT 1
45230: ARRAY
45231: PPUSH
45232: NOP4
45236: PUSH
45237: LD_INT 2
45239: ARRAY
45240: PPUSH
45241: NOP4
45245: PPUSH
45246: NOP4
// result := IsPlaced ( unit ) ;
45250: NOP4
45254: PUSH
45255: NOP4
45259: PPUSH
45260: NOP4
45264: ST_TO_ADDR
// exit ;
45265: POP
45266: POP
45267: GO 45273
// end ; end ;
45269: GO 45148
45271: POP
45272: POP
// end ;
45273: LD_VAR 0 4
45277: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
45278: LD_INT 0
45280: PPUSH
45281: PPUSH
45282: PPUSH
// if not side or side > 8 then
45283: NOP4
45287: NOT
45288: PUSH
45289: NOP4
45293: PUSH
45294: LD_INT 8
45296: GREATER
45297: OR
45298: IFFALSE 45302
// exit ;
45300: GO 45489
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
45302: NOP4
45306: PUSH
45307: LD_INT 22
45309: PUSH
45310: NOP4
45314: PUSH
45315: EMPTY
45316: LIST
45317: LIST
45318: PUSH
45319: LD_INT 21
45321: PUSH
45322: LD_INT 3
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PUSH
45329: EMPTY
45330: LIST
45331: LIST
45332: PPUSH
45333: NOP4
45337: ST_TO_ADDR
// if not tmp then
45338: NOP4
45342: NOT
45343: IFFALSE 45347
// exit ;
45345: GO 45489
// enable_addtolog := true ;
45347: LD_ADDR_OWVAR 81
45351: PUSH
45352: LD_INT 1
45354: ST_TO_ADDR
// AddToLog ( [ ) ;
45355: LD_STRING [
45357: PPUSH
45358: NOP4
// for i in tmp do
45362: NOP4
45366: PUSH
45367: NOP4
45371: PUSH
45372: FOR_IN
45373: IFFALSE 45480
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45375: LD_STRING [
45377: PUSH
45378: NOP4
45382: PPUSH
45383: NOP4
45387: STR
45388: PUSH
45389: LD_STRING , 
45391: STR
45392: PUSH
45393: NOP4
45397: PPUSH
45398: NOP4
45402: STR
45403: PUSH
45404: LD_STRING , 
45406: STR
45407: PUSH
45408: NOP4
45412: PPUSH
45413: NOP4
45417: STR
45418: PUSH
45419: LD_STRING , 
45421: STR
45422: PUSH
45423: NOP4
45427: PPUSH
45428: NOP4
45432: STR
45433: PUSH
45434: LD_STRING , 
45436: STR
45437: PUSH
45438: NOP4
45442: PPUSH
45443: LD_INT 1
45445: PPUSH
45446: NOP4
45450: STR
45451: PUSH
45452: LD_STRING , 
45454: STR
45455: PUSH
45456: NOP4
45460: PPUSH
45461: LD_INT 2
45463: PPUSH
45464: NOP4
45468: STR
45469: PUSH
45470: LD_STRING ],
45472: STR
45473: PPUSH
45474: NOP4
// end ;
45478: GO 45372
45480: POP
45481: POP
// AddToLog ( ]; ) ;
45482: LD_STRING ];
45484: PPUSH
45485: NOP4
// end ;
45489: LD_VAR 0 2
45493: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45494: LD_INT 0
45496: PPUSH
45497: PPUSH
45498: PPUSH
45499: PPUSH
45500: PPUSH
// if not area or not rate or not max then
45501: NOP4
45505: NOT
45506: PUSH
45507: NOP4
45511: NOT
45512: OR
45513: PUSH
45514: NOP4
45518: NOT
45519: OR
45520: IFFALSE 45524
// exit ;
45522: GO 45716
// while 1 do
45524: LD_INT 1
45526: IFFALSE 45716
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45528: NOP4
45532: PUSH
45533: NOP4
45537: PPUSH
45538: LD_INT 1
45540: PPUSH
45541: NOP4
45545: PUSH
45546: LD_INT 10
45548: MUL
45549: ST_TO_ADDR
// r := rate / 10 ;
45550: NOP4
45554: PUSH
45555: NOP4
45559: PUSH
45560: LD_INT 10
45562: DIVREAL
45563: ST_TO_ADDR
// time := 1 1$00 ;
45564: NOP4
45568: PUSH
45569: LD_INT 2100
45571: ST_TO_ADDR
// if amount < min then
45572: NOP4
45576: PUSH
45577: NOP4
45581: LESS
45582: IFFALSE 45600
// r := r * 2 else
45584: NOP4
45588: PUSH
45589: NOP4
45593: PUSH
45594: LD_INT 2
45596: MUL
45597: ST_TO_ADDR
45598: GO 45626
// if amount > max then
45600: NOP4
45604: PUSH
45605: NOP4
45609: GREATER
45610: IFFALSE 45626
// r := r / 2 ;
45612: NOP4
45616: PUSH
45617: NOP4
45621: PUSH
45622: LD_INT 2
45624: DIVREAL
45625: ST_TO_ADDR
// time := time / r ;
45626: NOP4
45630: PUSH
45631: NOP4
45635: PUSH
45636: NOP4
45640: DIVREAL
45641: ST_TO_ADDR
// if time < 0 then
45642: NOP4
45646: PUSH
45647: LD_INT 0
45649: LESS
45650: IFFALSE 45667
// time := time * - 1 ;
45652: NOP4
45656: PUSH
45657: NOP4
45661: PUSH
45662: LD_INT 1
45664: NEG
45665: MUL
45666: ST_TO_ADDR
// wait ( time ) ;
45667: NOP4
45671: PPUSH
45672: NOP4
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
45676: LD_INT 35
45678: PPUSH
45679: LD_INT 875
45681: PPUSH
45682: NOP4
45686: PPUSH
45687: NOP4
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
45691: LD_INT 1
45693: PPUSH
45694: LD_INT 5
45696: PPUSH
45697: NOP4
45701: PPUSH
45702: NOP4
45706: PPUSH
45707: LD_INT 1
45709: PPUSH
45710: NOP4
// end ;
45714: GO 45524
// end ;
45716: LD_VAR 0 5
45720: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
45721: LD_INT 0
45723: PPUSH
45724: PPUSH
45725: PPUSH
45726: PPUSH
45727: PPUSH
45728: PPUSH
45729: PPUSH
45730: PPUSH
// if not turrets or not factories then
45731: NOP4
45735: NOT
45736: PUSH
45737: NOP4
45741: NOT
45742: OR
45743: IFFALSE 45747
// exit ;
45745: GO 46054
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
45747: NOP4
45751: PUSH
45752: LD_INT 5
45754: PUSH
45755: LD_INT 6
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 2
45764: PUSH
45765: LD_INT 4
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 3
45774: PUSH
45775: LD_INT 5
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 24
45789: PUSH
45790: LD_INT 25
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 23
45799: PUSH
45800: LD_INT 27
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 42
45813: PUSH
45814: LD_INT 43
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 44
45823: PUSH
45824: LD_INT 46
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 45
45833: PUSH
45834: LD_INT 47
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: LIST
45845: PUSH
45846: EMPTY
45847: LIST
45848: LIST
45849: LIST
45850: ST_TO_ADDR
// result := [ ] ;
45851: NOP4
45855: PUSH
45856: EMPTY
45857: ST_TO_ADDR
// for i in turrets do
45858: NOP4
45862: PUSH
45863: NOP4
45867: PUSH
45868: FOR_IN
45869: IFFALSE 46052
// begin nat := GetNation ( i ) ;
45871: NOP4
45875: PUSH
45876: NOP4
45880: PPUSH
45881: NOP4
45885: ST_TO_ADDR
// weapon := 0 ;
45886: NOP4
45890: PUSH
45891: LD_INT 0
45893: ST_TO_ADDR
// if not nat then
45894: NOP4
45898: NOT
45899: IFFALSE 45903
// continue ;
45901: GO 45868
// for j in list [ nat ] do
45903: NOP4
45907: PUSH
45908: NOP4
45912: PUSH
45913: NOP4
45917: ARRAY
45918: PUSH
45919: FOR_IN
45920: IFFALSE 45961
// if GetBWeapon ( i ) = j [ 1 ] then
45922: NOP4
45926: PPUSH
45927: NOP4
45931: PUSH
45932: NOP4
45936: PUSH
45937: LD_INT 1
45939: ARRAY
45940: EQUAL
45941: IFFALSE 45959
// begin weapon := j [ 2 ] ;
45943: NOP4
45947: PUSH
45948: NOP4
45952: PUSH
45953: LD_INT 2
45955: ARRAY
45956: ST_TO_ADDR
// break ;
45957: GO 45961
// end ;
45959: GO 45919
45961: POP
45962: POP
// if not weapon then
45963: NOP4
45967: NOT
45968: IFFALSE 45972
// continue ;
45970: GO 45868
// for k in factories do
45972: NOP4
45976: PUSH
45977: NOP4
45981: PUSH
45982: FOR_IN
45983: IFFALSE 46048
// begin weapons := AvailableWeaponList ( k ) ;
45985: NOP4
45989: PUSH
45990: NOP4
45994: PPUSH
45995: NOP4
45999: ST_TO_ADDR
// if not weapons then
46000: NOP4
46004: NOT
46005: IFFALSE 46009
// continue ;
46007: GO 45982
// if weapon in weapons then
46009: NOP4
46013: PUSH
46014: NOP4
46018: IN
46019: IFFALSE 46046
// begin result := [ i , weapon ] ;
46021: NOP4
46025: PUSH
46026: NOP4
46030: PUSH
46031: NOP4
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: ST_TO_ADDR
// exit ;
46040: POP
46041: POP
46042: POP
46043: POP
46044: GO 46054
// end ; end ;
46046: GO 45982
46048: POP
46049: POP
// end ;
46050: GO 45868
46052: POP
46053: POP
// end ;
46054: LD_VAR 0 3
46058: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
46059: LD_INT 0
46061: PPUSH
// if not side or side > 8 then
46062: NOP4
46066: NOT
46067: PUSH
46068: NOP4
46072: PUSH
46073: LD_INT 8
46075: GREATER
46076: OR
46077: IFFALSE 46081
// exit ;
46079: GO 46140
// if not range then
46081: NOP4
46085: NOT
46086: IFFALSE 46097
// range := - 12 ;
46088: NOP4
46092: PUSH
46093: LD_INT 12
46095: NEG
46096: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
46097: NOP4
46101: PPUSH
46102: NOP4
46106: PPUSH
46107: NOP4
46111: PPUSH
46112: NOP4
46116: PPUSH
46117: NOP4
// RemoveSeeing ( x , y , side ) ;
46121: NOP4
46125: PPUSH
46126: NOP4
46130: PPUSH
46131: NOP4
46135: PPUSH
46136: NOP4
// end ;
46140: LD_VAR 0 5
46144: RET
// export function Video ( mode ) ; begin
46145: LD_INT 0
46147: PPUSH
// ingame_video = mode ;
46148: LD_ADDR_OWVAR 52
46152: PUSH
46153: NOP4
46157: ST_TO_ADDR
// interface_hidden = mode ;
46158: LD_ADDR_OWVAR 54
46162: PUSH
46163: NOP4
46167: ST_TO_ADDR
// end ;
46168: LD_VAR 0 2
46172: RET
// export function Join ( array , element ) ; begin
46173: LD_INT 0
46175: PPUSH
// result := Replace ( array , array + 1 , element ) ;
46176: NOP4
46180: PUSH
46181: NOP4
46185: PPUSH
46186: NOP4
46190: PUSH
46191: LD_INT 1
46193: PLUS
46194: PPUSH
46195: NOP4
46199: PPUSH
46200: NOP4
46204: ST_TO_ADDR
// end ;
46205: LD_VAR 0 3
46209: RET
// export function JoinUnion ( array , element ) ; begin
46210: LD_INT 0
46212: PPUSH
// result := array union element ;
46213: NOP4
46217: PUSH
46218: NOP4
46222: PUSH
46223: NOP4
46227: UNION
46228: ST_TO_ADDR
// end ;
46229: LD_VAR 0 3
46233: RET
// export function GetBehemoths ( side ) ; begin
46234: LD_INT 0
46236: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
46237: NOP4
46241: PUSH
46242: LD_INT 22
46244: PUSH
46245: NOP4
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 31
46256: PUSH
46257: LD_INT 25
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: PPUSH
46268: NOP4
46272: ST_TO_ADDR
// end ;
46273: LD_VAR 0 2
46277: RET
// export function Shuffle ( array ) ; var i , index ; begin
46278: LD_INT 0
46280: PPUSH
46281: PPUSH
46282: PPUSH
// result := [ ] ;
46283: NOP4
46287: PUSH
46288: EMPTY
46289: ST_TO_ADDR
// if not array then
46290: NOP4
46294: NOT
46295: IFFALSE 46299
// exit ;
46297: GO 46398
// Randomize ;
46299: NOP4
// for i = array downto 1 do
46303: NOP4
46307: PUSH
46308: DOUBLE
46309: NOP4
46313: INC
46314: ST_TO_ADDR
46315: LD_INT 1
46317: PUSH
46318: FOR_DOWNTO
46319: IFFALSE 46396
// begin index := rand ( 1 , array ) ;
46321: NOP4
46325: PUSH
46326: LD_INT 1
46328: PPUSH
46329: NOP4
46333: PPUSH
46334: NOP4
46338: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
46339: NOP4
46343: PUSH
46344: NOP4
46348: PPUSH
46349: NOP4
46353: PUSH
46354: LD_INT 1
46356: PLUS
46357: PPUSH
46358: NOP4
46362: PUSH
46363: NOP4
46367: ARRAY
46368: PPUSH
46369: NOP4
46373: ST_TO_ADDR
// array := Delete ( array , index ) ;
46374: NOP4
46378: PUSH
46379: NOP4
46383: PPUSH
46384: NOP4
46388: PPUSH
46389: NOP4
46393: ST_TO_ADDR
// end ;
46394: GO 46318
46396: POP
46397: POP
// end ;
46398: LD_VAR 0 2
46402: RET
// export function GetBaseMaterials ( base ) ; begin
46403: LD_INT 0
46405: PPUSH
// result := [ 0 , 0 , 0 ] ;
46406: NOP4
46410: PUSH
46411: LD_INT 0
46413: PUSH
46414: LD_INT 0
46416: PUSH
46417: LD_INT 0
46419: PUSH
46420: EMPTY
46421: LIST
46422: LIST
46423: LIST
46424: ST_TO_ADDR
// if not base then
46425: NOP4
46429: NOT
46430: IFFALSE 46434
// exit ;
46432: GO 46483
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46434: NOP4
46438: PUSH
46439: NOP4
46443: PPUSH
46444: LD_INT 1
46446: PPUSH
46447: NOP4
46451: PUSH
46452: NOP4
46456: PPUSH
46457: LD_INT 2
46459: PPUSH
46460: NOP4
46464: PUSH
46465: NOP4
46469: PPUSH
46470: LD_INT 3
46472: PPUSH
46473: NOP4
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: LIST
46482: ST_TO_ADDR
// end ;
46483: LD_VAR 0 2
46487: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46488: LD_INT 0
46490: PPUSH
46491: PPUSH
// result := array ;
46492: NOP4
46496: PUSH
46497: NOP4
46501: ST_TO_ADDR
// if size > 0 then
46502: NOP4
46506: PUSH
46507: LD_INT 0
46509: GREATER
46510: IFFALSE 46556
// for i := array downto size do
46512: NOP4
46516: PUSH
46517: DOUBLE
46518: NOP4
46522: INC
46523: ST_TO_ADDR
46524: NOP4
46528: PUSH
46529: FOR_DOWNTO
46530: IFFALSE 46554
// result := Delete ( result , result ) ;
46532: NOP4
46536: PUSH
46537: NOP4
46541: PPUSH
46542: NOP4
46546: PPUSH
46547: NOP4
46551: ST_TO_ADDR
46552: GO 46529
46554: POP
46555: POP
// end ;
46556: LD_VAR 0 3
46560: RET
// export function ComExit ( unit ) ; var tmp ; begin
46561: LD_INT 0
46563: PPUSH
46564: PPUSH
// if not IsInUnit ( unit ) then
46565: NOP4
46569: PPUSH
46570: NOP4
46574: NOT
46575: IFFALSE 46579
// exit ;
46577: GO 46639
// tmp := IsInUnit ( unit ) ;
46579: NOP4
46583: PUSH
46584: NOP4
46588: PPUSH
46589: NOP4
46593: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
46594: NOP4
46598: PPUSH
46599: NOP4
46603: PUSH
46604: LD_INT 2
46606: EQUAL
46607: IFFALSE 46620
// ComExitVehicle ( unit ) else
46609: NOP4
46613: PPUSH
46614: NOP4
46618: GO 46629
// ComExitBuilding ( unit ) ;
46620: NOP4
46624: PPUSH
46625: NOP4
// result := tmp ;
46629: NOP4
46633: PUSH
46634: NOP4
46638: ST_TO_ADDR
// end ;
46639: LD_VAR 0 2
46643: RET
// export function ComExitAll ( units ) ; var i ; begin
46644: LD_INT 0
46646: PPUSH
46647: PPUSH
// if not units then
46648: NOP4
46652: NOT
46653: IFFALSE 46657
// exit ;
46655: GO 46683
// for i in units do
46657: NOP4
46661: PUSH
46662: NOP4
46666: PUSH
46667: FOR_IN
46668: IFFALSE 46681
// ComExit ( i ) ;
46670: NOP4
46674: PPUSH
46675: NOP4
46679: GO 46667
46681: POP
46682: POP
// end ;
46683: LD_VAR 0 2
46687: RET
// export function ResetHc ; begin
46688: LD_INT 0
46690: PPUSH
// InitHc ;
46691: NOP4
// hc_importance := 0 ;
46695: LD_ADDR_OWVAR 32
46699: PUSH
46700: LD_INT 0
46702: ST_TO_ADDR
// end ;
46703: LD_VAR 0 1
46707: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
46708: LD_INT 0
46710: PPUSH
46711: PPUSH
46712: PPUSH
// _x := ( x1 + x2 ) div 2 ;
46713: NOP4
46717: PUSH
46718: NOP4
46722: PUSH
46723: NOP4
46727: PLUS
46728: PUSH
46729: LD_INT 2
46731: DIV
46732: ST_TO_ADDR
// if _x < 0 then
46733: NOP4
46737: PUSH
46738: LD_INT 0
46740: LESS
46741: IFFALSE 46758
// _x := _x * - 1 ;
46743: NOP4
46747: PUSH
46748: NOP4
46752: PUSH
46753: LD_INT 1
46755: NEG
46756: MUL
46757: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
46758: NOP4
46762: PUSH
46763: NOP4
46767: PUSH
46768: NOP4
46772: PLUS
46773: PUSH
46774: LD_INT 2
46776: DIV
46777: ST_TO_ADDR
// if _y < 0 then
46778: NOP4
46782: PUSH
46783: LD_INT 0
46785: LESS
46786: IFFALSE 46803
// _y := _y * - 1 ;
46788: NOP4
46792: PUSH
46793: NOP4
46797: PUSH
46798: LD_INT 1
46800: NEG
46801: MUL
46802: ST_TO_ADDR
// result := [ _x , _y ] ;
46803: NOP4
46807: PUSH
46808: NOP4
46812: PUSH
46813: NOP4
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: ST_TO_ADDR
// end ;
46822: LD_VAR 0 5
46826: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
46827: LD_INT 0
46829: PPUSH
46830: PPUSH
46831: PPUSH
46832: PPUSH
// task := GetTaskList ( unit ) ;
46833: NOP4
46837: PUSH
46838: NOP4
46842: PPUSH
46843: NOP4
46847: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
46848: NOP4
46852: NOT
46853: PUSH
46854: NOP4
46858: PPUSH
46859: NOP4
46863: PPUSH
46864: NOP4
46868: NOT
46869: AND
46870: IFFALSE 46874
// exit ;
46872: GO 46992
// if IsInArea ( unit , area ) then
46874: NOP4
46878: PPUSH
46879: NOP4
46883: PPUSH
46884: NOP4
46888: IFFALSE 46906
// begin ComMoveToArea ( unit , goAway ) ;
46890: NOP4
46894: PPUSH
46895: NOP4
46899: PPUSH
46900: NOP4
// exit ;
46904: GO 46992
// end ; if task [ 1 ] [ 1 ] <> M then
46906: NOP4
46910: PUSH
46911: LD_INT 1
46913: ARRAY
46914: PUSH
46915: LD_INT 1
46917: ARRAY
46918: PUSH
46919: LD_STRING M
46921: NONEQUAL
46922: IFFALSE 46926
// exit ;
46924: GO 46992
// x := task [ 1 ] [ 2 ] ;
46926: NOP4
46930: PUSH
46931: NOP4
46935: PUSH
46936: LD_INT 1
46938: ARRAY
46939: PUSH
46940: LD_INT 2
46942: ARRAY
46943: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
46944: NOP4
46948: PUSH
46949: NOP4
46953: PUSH
46954: LD_INT 1
46956: ARRAY
46957: PUSH
46958: LD_INT 3
46960: ARRAY
46961: ST_TO_ADDR
// if InArea ( x , y , area ) then
46962: NOP4
46966: PPUSH
46967: NOP4
46971: PPUSH
46972: NOP4
46976: PPUSH
46977: NOP4
46981: IFFALSE 46992
// ComStop ( unit ) ;
46983: NOP4
46987: PPUSH
46988: NOP4
// end ;
46992: LD_VAR 0 4
46996: RET
// export function Abs ( value ) ; begin
46997: LD_INT 0
46999: PPUSH
// result := value ;
47000: NOP4
47004: PUSH
47005: NOP4
47009: ST_TO_ADDR
// if value < 0 then
47010: NOP4
47014: PUSH
47015: LD_INT 0
47017: LESS
47018: IFFALSE 47035
// result := value * - 1 ;
47020: NOP4
47024: PUSH
47025: NOP4
47029: PUSH
47030: LD_INT 1
47032: NEG
47033: MUL
47034: ST_TO_ADDR
// end ;
47035: LD_VAR 0 2
47039: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
47040: LD_INT 0
47042: PPUSH
47043: PPUSH
47044: PPUSH
47045: PPUSH
47046: PPUSH
47047: PPUSH
47048: PPUSH
47049: PPUSH
// if not unit or not building then
47050: NOP4
47054: NOT
47055: PUSH
47056: NOP4
47060: NOT
47061: OR
47062: IFFALSE 47066
// exit ;
47064: GO 47292
// x := GetX ( building ) ;
47066: NOP4
47070: PUSH
47071: NOP4
47075: PPUSH
47076: NOP4
47080: ST_TO_ADDR
// y := GetY ( building ) ;
47081: NOP4
47085: PUSH
47086: NOP4
47090: PPUSH
47091: NOP4
47095: ST_TO_ADDR
// d := GetDir ( building ) ;
47096: NOP4
47100: PUSH
47101: NOP4
47105: PPUSH
47106: NOP4
47110: ST_TO_ADDR
// r := 4 ;
47111: NOP4
47115: PUSH
47116: LD_INT 4
47118: ST_TO_ADDR
// for i := 1 to 5 do
47119: NOP4
47123: PUSH
47124: DOUBLE
47125: LD_INT 1
47127: DEC
47128: ST_TO_ADDR
47129: LD_INT 5
47131: PUSH
47132: FOR_TO
47133: IFFALSE 47290
// begin _x := ShiftX ( x , d , r + i ) ;
47135: NOP4
47139: PUSH
47140: NOP4
47144: PPUSH
47145: NOP4
47149: PPUSH
47150: NOP4
47154: PUSH
47155: NOP4
47159: PLUS
47160: PPUSH
47161: NOP4
47165: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
47166: NOP4
47170: PUSH
47171: NOP4
47175: PPUSH
47176: NOP4
47180: PPUSH
47181: NOP4
47185: PUSH
47186: NOP4
47190: PLUS
47191: PPUSH
47192: NOP4
47196: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
47197: NOP4
47201: PPUSH
47202: NOP4
47206: PPUSH
47207: NOP4
47211: PUSH
47212: NOP4
47216: PPUSH
47217: NOP4
47221: PPUSH
47222: NOP4
47226: PPUSH
47227: NOP4
47231: PUSH
47232: LD_INT 3
47234: PUSH
47235: LD_INT 2
47237: PUSH
47238: EMPTY
47239: LIST
47240: LIST
47241: IN
47242: NOT
47243: AND
47244: IFFALSE 47288
// begin ComMoveXY ( unit , _x , _y ) ;
47246: NOP4
47250: PPUSH
47251: NOP4
47255: PPUSH
47256: NOP4
47260: PPUSH
47261: NOP4
// result := [ _x , _y ] ;
47265: NOP4
47269: PUSH
47270: NOP4
47274: PUSH
47275: NOP4
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: ST_TO_ADDR
// exit ;
47284: POP
47285: POP
47286: GO 47292
// end ; end ;
47288: GO 47132
47290: POP
47291: POP
// end ;
47292: LD_VAR 0 3
47296: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
47297: LD_INT 0
47299: PPUSH
47300: PPUSH
47301: PPUSH
// result := 0 ;
47302: NOP4
47306: PUSH
47307: LD_INT 0
47309: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
47310: NOP4
47314: PUSH
47315: LD_INT 0
47317: LESS
47318: PUSH
47319: NOP4
47323: PUSH
47324: LD_INT 8
47326: GREATER
47327: OR
47328: PUSH
47329: NOP4
47333: PUSH
47334: LD_INT 0
47336: LESS
47337: OR
47338: PUSH
47339: NOP4
47343: PUSH
47344: LD_INT 8
47346: GREATER
47347: OR
47348: IFFALSE 47352
// exit ;
47350: GO 47427
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
47352: NOP4
47356: PUSH
47357: LD_INT 22
47359: PUSH
47360: NOP4
47364: PUSH
47365: EMPTY
47366: LIST
47367: LIST
47368: PPUSH
47369: NOP4
47373: PUSH
47374: FOR_IN
47375: IFFALSE 47425
// begin un := UnitShoot ( i ) ;
47377: NOP4
47381: PUSH
47382: NOP4
47386: PPUSH
47387: NOP4
47391: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47392: NOP4
47396: PPUSH
47397: NOP4
47401: PUSH
47402: NOP4
47406: EQUAL
47407: IFFALSE 47423
// begin result := un ;
47409: NOP4
47413: PUSH
47414: NOP4
47418: ST_TO_ADDR
// exit ;
47419: POP
47420: POP
47421: GO 47427
// end ; end ;
47423: GO 47374
47425: POP
47426: POP
// end ;
47427: LD_VAR 0 3
47431: RET
// export function GetCargoBay ( units ) ; begin
47432: LD_INT 0
47434: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
47435: NOP4
47439: PUSH
47440: NOP4
47444: PPUSH
47445: LD_INT 2
47447: PUSH
47448: LD_INT 34
47450: PUSH
47451: LD_INT 12
47453: PUSH
47454: EMPTY
47455: LIST
47456: LIST
47457: PUSH
47458: LD_INT 34
47460: PUSH
47461: LD_INT 51
47463: PUSH
47464: EMPTY
47465: LIST
47466: LIST
47467: PUSH
47468: LD_INT 34
47470: PUSH
47471: LD_INT 32
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 34
47480: PUSH
47481: NOP4
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: PPUSH
47497: NOP4
47501: ST_TO_ADDR
// end ; end_of_file
47502: LD_VAR 0 2
47506: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
47507: LD_INT 0
47509: PPUSH
47510: PPUSH
// skirmish := false ;
47511: NOP4
47515: PUSH
47516: LD_INT 0
47518: ST_TO_ADDR
// debug_mc := false ;
47519: NOP4
47523: PUSH
47524: LD_INT 0
47526: ST_TO_ADDR
// mc_bases := [ ] ;
47527: NOP4
47531: PUSH
47532: EMPTY
47533: ST_TO_ADDR
// mc_sides := [ ] ;
47534: NOP4
47538: PUSH
47539: EMPTY
47540: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
47541: NOP4
47545: PUSH
47546: EMPTY
47547: ST_TO_ADDR
// mc_building_repairs := [ ] ;
47548: NOP4
47552: PUSH
47553: EMPTY
47554: ST_TO_ADDR
// mc_need_heal := [ ] ;
47555: NOP4
47559: PUSH
47560: EMPTY
47561: ST_TO_ADDR
// mc_healers := [ ] ;
47562: NOP4
47566: PUSH
47567: EMPTY
47568: ST_TO_ADDR
// mc_build_list := [ ] ;
47569: NOP4
47573: PUSH
47574: EMPTY
47575: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
47576: NOP4
47580: PUSH
47581: EMPTY
47582: ST_TO_ADDR
// mc_builders := [ ] ;
47583: NOP4
47587: PUSH
47588: EMPTY
47589: ST_TO_ADDR
// mc_construct_list := [ ] ;
47590: NOP4
47594: PUSH
47595: EMPTY
47596: ST_TO_ADDR
// mc_turret_list := [ ] ;
47597: NOP4
47601: PUSH
47602: EMPTY
47603: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
47604: NOP4
47608: PUSH
47609: EMPTY
47610: ST_TO_ADDR
// mc_miners := [ ] ;
47611: NOP4
47615: PUSH
47616: EMPTY
47617: ST_TO_ADDR
// mc_mines := [ ] ;
47618: NOP4
47622: PUSH
47623: EMPTY
47624: ST_TO_ADDR
// mc_minefields := [ ] ;
47625: NOP4
47629: PUSH
47630: EMPTY
47631: ST_TO_ADDR
// mc_crates := [ ] ;
47632: NOP4
47636: PUSH
47637: EMPTY
47638: ST_TO_ADDR
// mc_crates_collector := [ ] ;
47639: NOP4
47643: PUSH
47644: EMPTY
47645: ST_TO_ADDR
// mc_crates_area := [ ] ;
47646: NOP4
47650: PUSH
47651: EMPTY
47652: ST_TO_ADDR
// mc_vehicles := [ ] ;
47653: NOP4
47657: PUSH
47658: EMPTY
47659: ST_TO_ADDR
// mc_attack := [ ] ;
47660: NOP4
47664: PUSH
47665: EMPTY
47666: ST_TO_ADDR
// mc_produce := [ ] ;
47667: NOP4
47671: PUSH
47672: EMPTY
47673: ST_TO_ADDR
// mc_defender := [ ] ;
47674: NOP4
47678: PUSH
47679: EMPTY
47680: ST_TO_ADDR
// mc_parking := [ ] ;
47681: NOP4
47685: PUSH
47686: EMPTY
47687: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
47688: NOP4
47692: PUSH
47693: EMPTY
47694: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
47695: NOP4
47699: PUSH
47700: EMPTY
47701: ST_TO_ADDR
// mc_scan := [ ] ;
47702: NOP4
47706: PUSH
47707: EMPTY
47708: ST_TO_ADDR
// mc_scan_area := [ ] ;
47709: NOP4
47713: PUSH
47714: EMPTY
47715: ST_TO_ADDR
// mc_tech := [ ] ;
47716: NOP4
47720: PUSH
47721: EMPTY
47722: ST_TO_ADDR
// mc_class := [ ] ;
47723: NOP4
47727: PUSH
47728: EMPTY
47729: ST_TO_ADDR
// mc_class_case_use := [ ] ;
47730: NOP4
47734: PUSH
47735: EMPTY
47736: ST_TO_ADDR
// mc_is_defending := [ ] ;
47737: NOP4
47741: PUSH
47742: EMPTY
47743: ST_TO_ADDR
// end ;
47744: LD_VAR 0 1
47748: RET
// export function MC_Kill ( base ) ; begin
47749: LD_INT 0
47751: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
47752: NOP4
47756: PUSH
47757: NOP4
47761: PPUSH
47762: NOP4
47766: PPUSH
47767: EMPTY
47768: PPUSH
47769: NOP4
47773: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
47774: NOP4
47778: PUSH
47779: NOP4
47783: PPUSH
47784: NOP4
47788: PPUSH
47789: EMPTY
47790: PPUSH
47791: NOP4
47795: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
47796: NOP4
47800: PUSH
47801: NOP4
47805: PPUSH
47806: NOP4
47810: PPUSH
47811: EMPTY
47812: PPUSH
47813: NOP4
47817: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
47818: NOP4
47822: PUSH
47823: NOP4
47827: PPUSH
47828: NOP4
47832: PPUSH
47833: EMPTY
47834: PPUSH
47835: NOP4
47839: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
47840: NOP4
47844: PUSH
47845: NOP4
47849: PPUSH
47850: NOP4
47854: PPUSH
47855: EMPTY
47856: PPUSH
47857: NOP4
47861: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
47862: NOP4
47866: PUSH
47867: NOP4
47871: PPUSH
47872: NOP4
47876: PPUSH
47877: EMPTY
47878: PPUSH
47879: NOP4
47883: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
47884: NOP4
47888: PUSH
47889: NOP4
47893: PPUSH
47894: NOP4
47898: PPUSH
47899: EMPTY
47900: PPUSH
47901: NOP4
47905: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
47906: NOP4
47910: PUSH
47911: NOP4
47915: PPUSH
47916: NOP4
47920: PPUSH
47921: EMPTY
47922: PPUSH
47923: NOP4
47927: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
47928: NOP4
47932: PUSH
47933: NOP4
47937: PPUSH
47938: NOP4
47942: PPUSH
47943: EMPTY
47944: PPUSH
47945: NOP4
47949: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
47950: NOP4
47954: PUSH
47955: NOP4
47959: PPUSH
47960: NOP4
47964: PPUSH
47965: EMPTY
47966: PPUSH
47967: NOP4
47971: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
47972: NOP4
47976: PUSH
47977: NOP4
47981: PPUSH
47982: NOP4
47986: PPUSH
47987: EMPTY
47988: PPUSH
47989: NOP4
47993: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
47994: NOP4
47998: PUSH
47999: NOP4
48003: PPUSH
48004: NOP4
48008: PPUSH
48009: LD_INT 0
48011: PPUSH
48012: NOP4
48016: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48017: NOP4
48021: PUSH
48022: NOP4
48026: PPUSH
48027: NOP4
48031: PPUSH
48032: EMPTY
48033: PPUSH
48034: NOP4
48038: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48039: NOP4
48043: PUSH
48044: NOP4
48048: PPUSH
48049: NOP4
48053: PPUSH
48054: EMPTY
48055: PPUSH
48056: NOP4
48060: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
48061: NOP4
48065: PUSH
48066: NOP4
48070: PPUSH
48071: NOP4
48075: PPUSH
48076: EMPTY
48077: PPUSH
48078: NOP4
48082: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
48083: NOP4
48087: PUSH
48088: NOP4
48092: PPUSH
48093: NOP4
48097: PPUSH
48098: EMPTY
48099: PPUSH
48100: NOP4
48104: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
48105: NOP4
48109: PUSH
48110: NOP4
48114: PPUSH
48115: NOP4
48119: PPUSH
48120: EMPTY
48121: PPUSH
48122: NOP4
48126: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
48127: NOP4
48131: PUSH
48132: NOP4
48136: PPUSH
48137: NOP4
48141: PPUSH
48142: EMPTY
48143: PPUSH
48144: NOP4
48148: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
48149: NOP4
48153: PUSH
48154: NOP4
48158: PPUSH
48159: NOP4
48163: PPUSH
48164: EMPTY
48165: PPUSH
48166: NOP4
48170: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
48171: NOP4
48175: PUSH
48176: NOP4
48180: PPUSH
48181: NOP4
48185: PPUSH
48186: EMPTY
48187: PPUSH
48188: NOP4
48192: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
48193: NOP4
48197: PUSH
48198: NOP4
48202: PPUSH
48203: NOP4
48207: PPUSH
48208: EMPTY
48209: PPUSH
48210: NOP4
48214: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
48215: NOP4
48219: PUSH
48220: NOP4
48224: PPUSH
48225: NOP4
48229: PPUSH
48230: EMPTY
48231: PPUSH
48232: NOP4
48236: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
48237: NOP4
48241: PUSH
48242: NOP4
48246: PPUSH
48247: NOP4
48251: PPUSH
48252: EMPTY
48253: PPUSH
48254: NOP4
48258: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
48259: NOP4
48263: PUSH
48264: NOP4
48268: PPUSH
48269: NOP4
48273: PPUSH
48274: EMPTY
48275: PPUSH
48276: NOP4
48280: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
48281: NOP4
48285: PUSH
48286: NOP4
48290: PPUSH
48291: NOP4
48295: PPUSH
48296: EMPTY
48297: PPUSH
48298: NOP4
48302: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
48303: NOP4
48307: PUSH
48308: NOP4
48312: PPUSH
48313: NOP4
48317: PPUSH
48318: EMPTY
48319: PPUSH
48320: NOP4
48324: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
48325: NOP4
48329: PUSH
48330: NOP4
48334: PPUSH
48335: NOP4
48339: PPUSH
48340: EMPTY
48341: PPUSH
48342: NOP4
48346: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
48347: NOP4
48351: PUSH
48352: NOP4
48356: PPUSH
48357: NOP4
48361: PPUSH
48362: EMPTY
48363: PPUSH
48364: NOP4
48368: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
48369: NOP4
48373: PUSH
48374: NOP4
48378: PPUSH
48379: NOP4
48383: PPUSH
48384: EMPTY
48385: PPUSH
48386: NOP4
48390: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48391: NOP4
48395: PUSH
48396: NOP4
48400: PPUSH
48401: NOP4
48405: PPUSH
48406: EMPTY
48407: PPUSH
48408: NOP4
48412: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48413: NOP4
48417: PUSH
48418: NOP4
48422: PPUSH
48423: NOP4
48427: PPUSH
48428: EMPTY
48429: PPUSH
48430: NOP4
48434: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
48435: NOP4
48439: PUSH
48440: NOP4
48444: PPUSH
48445: NOP4
48449: PPUSH
48450: EMPTY
48451: PPUSH
48452: NOP4
48456: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48457: NOP4
48461: PUSH
48462: NOP4
48466: PPUSH
48467: NOP4
48471: PPUSH
48472: EMPTY
48473: PPUSH
48474: NOP4
48478: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48479: NOP4
48483: PUSH
48484: NOP4
48488: PPUSH
48489: NOP4
48493: PPUSH
48494: EMPTY
48495: PPUSH
48496: NOP4
48500: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48501: NOP4
48505: PUSH
48506: NOP4
48510: PPUSH
48511: NOP4
48515: PPUSH
48516: EMPTY
48517: PPUSH
48518: NOP4
48522: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48523: NOP4
48527: PUSH
48528: NOP4
48532: PPUSH
48533: NOP4
48537: PPUSH
48538: EMPTY
48539: PPUSH
48540: NOP4
48544: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48545: NOP4
48549: PUSH
48550: NOP4
48554: PPUSH
48555: NOP4
48559: PPUSH
48560: EMPTY
48561: PPUSH
48562: NOP4
48566: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
48567: NOP4
48571: PUSH
48572: NOP4
48576: PPUSH
48577: NOP4
48581: PPUSH
48582: EMPTY
48583: PPUSH
48584: NOP4
48588: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
48589: NOP4
48593: PUSH
48594: NOP4
48598: PPUSH
48599: NOP4
48603: PPUSH
48604: EMPTY
48605: PPUSH
48606: NOP4
48610: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
48611: NOP4
48615: PUSH
48616: NOP4
48620: PPUSH
48621: NOP4
48625: PPUSH
48626: EMPTY
48627: PPUSH
48628: NOP4
48632: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
48633: NOP4
48637: PUSH
48638: NOP4
48642: PPUSH
48643: NOP4
48647: PPUSH
48648: LD_INT 0
48650: PPUSH
48651: NOP4
48655: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
48656: NOP4
48660: PUSH
48661: NOP4
48665: PPUSH
48666: NOP4
48670: PPUSH
48671: LD_INT 0
48673: PPUSH
48674: NOP4
48678: ST_TO_ADDR
// end ;
48679: LD_VAR 0 2
48683: RET
// export function MC_Add ( side , units ) ; var base ; begin
48684: LD_INT 0
48686: PPUSH
48687: PPUSH
// base := mc_bases + 1 ;
48688: NOP4
48692: PUSH
48693: NOP4
48697: PUSH
48698: LD_INT 1
48700: PLUS
48701: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
48702: NOP4
48706: PUSH
48707: NOP4
48711: PPUSH
48712: NOP4
48716: PPUSH
48717: NOP4
48721: PPUSH
48722: NOP4
48726: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
48727: NOP4
48731: PUSH
48732: NOP4
48736: PPUSH
48737: NOP4
48741: PPUSH
48742: NOP4
48746: PPUSH
48747: NOP4
48751: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
48752: NOP4
48756: PUSH
48757: NOP4
48761: PPUSH
48762: NOP4
48766: PPUSH
48767: EMPTY
48768: PPUSH
48769: NOP4
48773: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
48774: NOP4
48778: PUSH
48779: NOP4
48783: PPUSH
48784: NOP4
48788: PPUSH
48789: EMPTY
48790: PPUSH
48791: NOP4
48795: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
48796: NOP4
48800: PUSH
48801: NOP4
48805: PPUSH
48806: NOP4
48810: PPUSH
48811: EMPTY
48812: PPUSH
48813: NOP4
48817: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
48818: NOP4
48822: PUSH
48823: NOP4
48827: PPUSH
48828: NOP4
48832: PPUSH
48833: EMPTY
48834: PPUSH
48835: NOP4
48839: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
48840: NOP4
48844: PUSH
48845: NOP4
48849: PPUSH
48850: NOP4
48854: PPUSH
48855: EMPTY
48856: PPUSH
48857: NOP4
48861: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48862: NOP4
48866: PUSH
48867: NOP4
48871: PPUSH
48872: NOP4
48876: PPUSH
48877: EMPTY
48878: PPUSH
48879: NOP4
48883: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
48884: NOP4
48888: PUSH
48889: NOP4
48893: PPUSH
48894: NOP4
48898: PPUSH
48899: EMPTY
48900: PPUSH
48901: NOP4
48905: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
48906: NOP4
48910: PUSH
48911: NOP4
48915: PPUSH
48916: NOP4
48920: PPUSH
48921: EMPTY
48922: PPUSH
48923: NOP4
48927: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
48928: NOP4
48932: PUSH
48933: NOP4
48937: PPUSH
48938: NOP4
48942: PPUSH
48943: EMPTY
48944: PPUSH
48945: NOP4
48949: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48950: NOP4
48954: PUSH
48955: NOP4
48959: PPUSH
48960: NOP4
48964: PPUSH
48965: EMPTY
48966: PPUSH
48967: NOP4
48971: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
48972: NOP4
48976: PUSH
48977: NOP4
48981: PPUSH
48982: NOP4
48986: PPUSH
48987: LD_INT 0
48989: PPUSH
48990: NOP4
48994: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48995: NOP4
48999: PUSH
49000: NOP4
49004: PPUSH
49005: NOP4
49009: PPUSH
49010: EMPTY
49011: PPUSH
49012: NOP4
49016: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
49017: NOP4
49021: PUSH
49022: NOP4
49026: PPUSH
49027: NOP4
49031: PPUSH
49032: EMPTY
49033: PPUSH
49034: NOP4
49038: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
49039: NOP4
49043: PUSH
49044: NOP4
49048: PPUSH
49049: NOP4
49053: PPUSH
49054: EMPTY
49055: PPUSH
49056: NOP4
49060: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
49061: NOP4
49065: PUSH
49066: NOP4
49070: PPUSH
49071: NOP4
49075: PPUSH
49076: EMPTY
49077: PPUSH
49078: NOP4
49082: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
49083: NOP4
49087: PUSH
49088: NOP4
49092: PPUSH
49093: NOP4
49097: PPUSH
49098: EMPTY
49099: PPUSH
49100: NOP4
49104: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
49105: NOP4
49109: PUSH
49110: NOP4
49114: PPUSH
49115: NOP4
49119: PPUSH
49120: EMPTY
49121: PPUSH
49122: NOP4
49126: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
49127: NOP4
49131: PUSH
49132: NOP4
49136: PPUSH
49137: NOP4
49141: PPUSH
49142: EMPTY
49143: PPUSH
49144: NOP4
49148: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
49149: NOP4
49153: PUSH
49154: NOP4
49158: PPUSH
49159: NOP4
49163: PPUSH
49164: EMPTY
49165: PPUSH
49166: NOP4
49170: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
49171: NOP4
49175: PUSH
49176: NOP4
49180: PPUSH
49181: NOP4
49185: PPUSH
49186: EMPTY
49187: PPUSH
49188: NOP4
49192: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
49193: NOP4
49197: PUSH
49198: NOP4
49202: PPUSH
49203: NOP4
49207: PPUSH
49208: EMPTY
49209: PPUSH
49210: NOP4
49214: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
49215: NOP4
49219: PUSH
49220: NOP4
49224: PPUSH
49225: NOP4
49229: PPUSH
49230: EMPTY
49231: PPUSH
49232: NOP4
49236: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
49237: NOP4
49241: PUSH
49242: NOP4
49246: PPUSH
49247: NOP4
49251: PPUSH
49252: EMPTY
49253: PPUSH
49254: NOP4
49258: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
49259: NOP4
49263: PUSH
49264: NOP4
49268: PPUSH
49269: NOP4
49273: PPUSH
49274: EMPTY
49275: PPUSH
49276: NOP4
49280: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
49281: NOP4
49285: PUSH
49286: NOP4
49290: PPUSH
49291: NOP4
49295: PPUSH
49296: EMPTY
49297: PPUSH
49298: NOP4
49302: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
49303: NOP4
49307: PUSH
49308: NOP4
49312: PPUSH
49313: NOP4
49317: PPUSH
49318: EMPTY
49319: PPUSH
49320: NOP4
49324: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
49325: NOP4
49329: PUSH
49330: NOP4
49334: PPUSH
49335: NOP4
49339: PPUSH
49340: EMPTY
49341: PPUSH
49342: NOP4
49346: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
49347: NOP4
49351: PUSH
49352: NOP4
49356: PPUSH
49357: NOP4
49361: PPUSH
49362: EMPTY
49363: PPUSH
49364: NOP4
49368: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
49369: NOP4
49373: PUSH
49374: NOP4
49378: PPUSH
49379: NOP4
49383: PPUSH
49384: EMPTY
49385: PPUSH
49386: NOP4
49390: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
49391: NOP4
49395: PUSH
49396: NOP4
49400: PPUSH
49401: NOP4
49405: PPUSH
49406: EMPTY
49407: PPUSH
49408: NOP4
49412: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
49413: NOP4
49417: PUSH
49418: NOP4
49422: PPUSH
49423: NOP4
49427: PPUSH
49428: EMPTY
49429: PPUSH
49430: NOP4
49434: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
49435: NOP4
49439: PUSH
49440: NOP4
49444: PPUSH
49445: NOP4
49449: PPUSH
49450: EMPTY
49451: PPUSH
49452: NOP4
49456: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
49457: NOP4
49461: PUSH
49462: NOP4
49466: PPUSH
49467: NOP4
49471: PPUSH
49472: EMPTY
49473: PPUSH
49474: NOP4
49478: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
49479: NOP4
49483: PUSH
49484: NOP4
49488: PPUSH
49489: NOP4
49493: PPUSH
49494: EMPTY
49495: PPUSH
49496: NOP4
49500: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
49501: NOP4
49505: PUSH
49506: NOP4
49510: PPUSH
49511: NOP4
49515: PPUSH
49516: EMPTY
49517: PPUSH
49518: NOP4
49522: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
49523: NOP4
49527: PUSH
49528: NOP4
49532: PPUSH
49533: NOP4
49537: PPUSH
49538: EMPTY
49539: PPUSH
49540: NOP4
49544: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49545: NOP4
49549: PUSH
49550: NOP4
49554: PPUSH
49555: NOP4
49559: PPUSH
49560: EMPTY
49561: PPUSH
49562: NOP4
49566: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49567: NOP4
49571: PUSH
49572: NOP4
49576: PPUSH
49577: NOP4
49581: PPUSH
49582: EMPTY
49583: PPUSH
49584: NOP4
49588: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49589: NOP4
49593: PUSH
49594: NOP4
49598: PPUSH
49599: NOP4
49603: PPUSH
49604: EMPTY
49605: PPUSH
49606: NOP4
49610: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49611: NOP4
49615: PUSH
49616: NOP4
49620: PPUSH
49621: NOP4
49625: PPUSH
49626: LD_INT 0
49628: PPUSH
49629: NOP4
49633: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
49634: NOP4
49638: PUSH
49639: NOP4
49643: PPUSH
49644: NOP4
49648: PPUSH
49649: LD_INT 0
49651: PPUSH
49652: NOP4
49656: ST_TO_ADDR
// result := base ;
49657: NOP4
49661: PUSH
49662: NOP4
49666: ST_TO_ADDR
// end ;
49667: LD_VAR 0 3
49671: RET
// export function MC_Start ( ) ; var i ; begin
49672: LD_INT 0
49674: PPUSH
49675: PPUSH
// for i = 1 to mc_bases do
49676: NOP4
49680: PUSH
49681: DOUBLE
49682: LD_INT 1
49684: DEC
49685: ST_TO_ADDR
49686: NOP4
49690: PUSH
49691: FOR_TO
49692: IFFALSE 50769
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
49694: NOP4
49698: PUSH
49699: NOP4
49703: PPUSH
49704: NOP4
49708: PPUSH
49709: NOP4
49713: PUSH
49714: NOP4
49718: ARRAY
49719: PUSH
49720: LD_INT 0
49722: DIFF
49723: PPUSH
49724: NOP4
49728: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
49729: NOP4
49733: PUSH
49734: NOP4
49738: PPUSH
49739: NOP4
49743: PPUSH
49744: EMPTY
49745: PPUSH
49746: NOP4
49750: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49751: NOP4
49755: PUSH
49756: NOP4
49760: PPUSH
49761: NOP4
49765: PPUSH
49766: EMPTY
49767: PPUSH
49768: NOP4
49772: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
49773: NOP4
49777: PUSH
49778: NOP4
49782: PPUSH
49783: NOP4
49787: PPUSH
49788: EMPTY
49789: PPUSH
49790: NOP4
49794: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
49795: NOP4
49799: PUSH
49800: NOP4
49804: PPUSH
49805: NOP4
49809: PPUSH
49810: EMPTY
49811: PUSH
49812: EMPTY
49813: PUSH
49814: EMPTY
49815: LIST
49816: LIST
49817: PPUSH
49818: NOP4
49822: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
49823: NOP4
49827: PUSH
49828: NOP4
49832: PPUSH
49833: NOP4
49837: PPUSH
49838: EMPTY
49839: PPUSH
49840: NOP4
49844: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
49845: NOP4
49849: PUSH
49850: NOP4
49854: PPUSH
49855: NOP4
49859: PPUSH
49860: EMPTY
49861: PPUSH
49862: NOP4
49866: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
49867: NOP4
49871: PUSH
49872: NOP4
49876: PPUSH
49877: NOP4
49881: PPUSH
49882: EMPTY
49883: PPUSH
49884: NOP4
49888: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
49889: NOP4
49893: PUSH
49894: NOP4
49898: PPUSH
49899: NOP4
49903: PPUSH
49904: EMPTY
49905: PPUSH
49906: NOP4
49910: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
49911: NOP4
49915: PUSH
49916: NOP4
49920: PPUSH
49921: NOP4
49925: PPUSH
49926: NOP4
49930: PUSH
49931: NOP4
49935: ARRAY
49936: PPUSH
49937: LD_INT 2
49939: PUSH
49940: LD_INT 30
49942: PUSH
49943: LD_INT 32
49945: PUSH
49946: EMPTY
49947: LIST
49948: LIST
49949: PUSH
49950: LD_INT 30
49952: PUSH
49953: LD_INT 33
49955: PUSH
49956: EMPTY
49957: LIST
49958: LIST
49959: PUSH
49960: EMPTY
49961: LIST
49962: LIST
49963: LIST
49964: PPUSH
49965: NOP4
49969: PPUSH
49970: NOP4
49974: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
49975: NOP4
49979: PUSH
49980: NOP4
49984: PPUSH
49985: NOP4
49989: PPUSH
49990: NOP4
49994: PUSH
49995: NOP4
49999: ARRAY
50000: PPUSH
50001: LD_INT 2
50003: PUSH
50004: LD_INT 30
50006: PUSH
50007: LD_INT 32
50009: PUSH
50010: EMPTY
50011: LIST
50012: LIST
50013: PUSH
50014: LD_INT 30
50016: PUSH
50017: LD_INT 31
50019: PUSH
50020: EMPTY
50021: LIST
50022: LIST
50023: PUSH
50024: EMPTY
50025: LIST
50026: LIST
50027: LIST
50028: PUSH
50029: LD_INT 58
50031: PUSH
50032: EMPTY
50033: LIST
50034: PUSH
50035: EMPTY
50036: LIST
50037: LIST
50038: PPUSH
50039: NOP4
50043: PPUSH
50044: NOP4
50048: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
50049: NOP4
50053: PUSH
50054: NOP4
50058: PPUSH
50059: NOP4
50063: PPUSH
50064: EMPTY
50065: PPUSH
50066: NOP4
50070: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
50071: NOP4
50075: PUSH
50076: NOP4
50080: PPUSH
50081: NOP4
50085: PPUSH
50086: EMPTY
50087: PPUSH
50088: NOP4
50092: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
50093: NOP4
50097: PUSH
50098: NOP4
50102: PPUSH
50103: NOP4
50107: PPUSH
50108: EMPTY
50109: PPUSH
50110: NOP4
50114: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
50115: NOP4
50119: PUSH
50120: NOP4
50124: PPUSH
50125: NOP4
50129: PPUSH
50130: EMPTY
50131: PPUSH
50132: NOP4
50136: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
50137: NOP4
50141: PUSH
50142: NOP4
50146: PPUSH
50147: NOP4
50151: PPUSH
50152: EMPTY
50153: PPUSH
50154: NOP4
50158: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50159: NOP4
50163: PUSH
50164: NOP4
50168: PPUSH
50169: NOP4
50173: PPUSH
50174: EMPTY
50175: PPUSH
50176: NOP4
50180: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
50181: NOP4
50185: PUSH
50186: NOP4
50190: PPUSH
50191: NOP4
50195: PPUSH
50196: EMPTY
50197: PPUSH
50198: NOP4
50202: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
50203: NOP4
50207: PUSH
50208: NOP4
50212: PPUSH
50213: NOP4
50217: PPUSH
50218: EMPTY
50219: PPUSH
50220: NOP4
50224: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50225: NOP4
50229: PUSH
50230: NOP4
50234: PPUSH
50235: NOP4
50239: PPUSH
50240: EMPTY
50241: PPUSH
50242: NOP4
50246: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
50247: NOP4
50251: PUSH
50252: NOP4
50256: PPUSH
50257: NOP4
50261: PPUSH
50262: EMPTY
50263: PPUSH
50264: NOP4
50268: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
50269: NOP4
50273: PUSH
50274: NOP4
50278: PPUSH
50279: NOP4
50283: PPUSH
50284: EMPTY
50285: PPUSH
50286: NOP4
50290: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
50291: NOP4
50295: PUSH
50296: NOP4
50300: PPUSH
50301: NOP4
50305: PPUSH
50306: LD_INT 0
50308: PPUSH
50309: NOP4
50313: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
50314: NOP4
50318: PUSH
50319: NOP4
50323: PPUSH
50324: NOP4
50328: PPUSH
50329: LD_INT 0
50331: PPUSH
50332: NOP4
50336: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
50337: NOP4
50341: PUSH
50342: NOP4
50346: PPUSH
50347: NOP4
50351: PPUSH
50352: EMPTY
50353: PPUSH
50354: NOP4
50358: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
50359: NOP4
50363: PUSH
50364: NOP4
50368: PPUSH
50369: NOP4
50373: PPUSH
50374: LD_INT 0
50376: PPUSH
50377: NOP4
50381: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
50382: NOP4
50386: PUSH
50387: NOP4
50391: PPUSH
50392: NOP4
50396: PPUSH
50397: EMPTY
50398: PPUSH
50399: NOP4
50403: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
50404: NOP4
50408: PUSH
50409: NOP4
50413: PPUSH
50414: NOP4
50418: PPUSH
50419: LD_INT 0
50421: PPUSH
50422: NOP4
50426: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
50427: NOP4
50431: PUSH
50432: NOP4
50436: PPUSH
50437: NOP4
50441: PPUSH
50442: EMPTY
50443: PPUSH
50444: NOP4
50448: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50449: NOP4
50453: PUSH
50454: NOP4
50458: PPUSH
50459: NOP4
50463: PPUSH
50464: EMPTY
50465: PPUSH
50466: NOP4
50470: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50471: NOP4
50475: PUSH
50476: NOP4
50480: PPUSH
50481: NOP4
50485: PPUSH
50486: EMPTY
50487: PPUSH
50488: NOP4
50492: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
50493: NOP4
50497: PUSH
50498: NOP4
50502: PPUSH
50503: NOP4
50507: PPUSH
50508: NOP4
50512: PUSH
50513: NOP4
50517: ARRAY
50518: PPUSH
50519: LD_INT 2
50521: PUSH
50522: LD_INT 30
50524: PUSH
50525: LD_INT 6
50527: PUSH
50528: EMPTY
50529: LIST
50530: LIST
50531: PUSH
50532: LD_INT 30
50534: PUSH
50535: LD_INT 7
50537: PUSH
50538: EMPTY
50539: LIST
50540: LIST
50541: PUSH
50542: LD_INT 30
50544: PUSH
50545: LD_INT 8
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: PUSH
50552: EMPTY
50553: LIST
50554: LIST
50555: LIST
50556: LIST
50557: PPUSH
50558: NOP4
50562: PPUSH
50563: NOP4
50567: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
50568: NOP4
50572: PUSH
50573: NOP4
50577: PPUSH
50578: NOP4
50582: PPUSH
50583: EMPTY
50584: PPUSH
50585: NOP4
50589: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
50590: NOP4
50594: PUSH
50595: NOP4
50599: PPUSH
50600: NOP4
50604: PPUSH
50605: EMPTY
50606: PPUSH
50607: NOP4
50611: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
50612: NOP4
50616: PUSH
50617: NOP4
50621: PPUSH
50622: NOP4
50626: PPUSH
50627: EMPTY
50628: PPUSH
50629: NOP4
50633: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
50634: NOP4
50638: PUSH
50639: NOP4
50643: PPUSH
50644: NOP4
50648: PPUSH
50649: EMPTY
50650: PPUSH
50651: NOP4
50655: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50656: NOP4
50660: PUSH
50661: NOP4
50665: PPUSH
50666: NOP4
50670: PPUSH
50671: EMPTY
50672: PPUSH
50673: NOP4
50677: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
50678: NOP4
50682: PUSH
50683: NOP4
50687: PPUSH
50688: NOP4
50692: PPUSH
50693: EMPTY
50694: PPUSH
50695: NOP4
50699: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
50700: NOP4
50704: PUSH
50705: NOP4
50709: PPUSH
50710: NOP4
50714: PPUSH
50715: EMPTY
50716: PPUSH
50717: NOP4
50721: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
50722: NOP4
50726: PUSH
50727: NOP4
50731: PPUSH
50732: NOP4
50736: PPUSH
50737: EMPTY
50738: PPUSH
50739: NOP4
50743: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
50744: NOP4
50748: PUSH
50749: NOP4
50753: PPUSH
50754: NOP4
50758: PPUSH
50759: LD_INT 0
50761: PPUSH
50762: NOP4
50766: ST_TO_ADDR
// end ;
50767: GO 49691
50769: POP
50770: POP
// MC_InitSides ( ) ;
50771: NOP4
// MC_InitResearch ( ) ;
50775: NOP4
// CustomInitMacro ( ) ;
50779: NOP4
// skirmish := true ;
50783: NOP4
50787: PUSH
50788: LD_INT 1
50790: ST_TO_ADDR
// end ;
50791: LD_VAR 0 1
50795: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
50796: LD_INT 0
50798: PPUSH
50799: PPUSH
50800: PPUSH
50801: PPUSH
50802: PPUSH
50803: PPUSH
// if not mc_bases then
50804: NOP4
50808: NOT
50809: IFFALSE 50813
// exit ;
50811: GO 51052
// for i = 1 to 8 do
50813: NOP4
50817: PUSH
50818: DOUBLE
50819: LD_INT 1
50821: DEC
50822: ST_TO_ADDR
50823: LD_INT 8
50825: PUSH
50826: FOR_TO
50827: IFFALSE 50853
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
50829: NOP4
50833: PUSH
50834: NOP4
50838: PPUSH
50839: NOP4
50843: PPUSH
50844: EMPTY
50845: PPUSH
50846: NOP4
50850: ST_TO_ADDR
50851: GO 50826
50853: POP
50854: POP
// tmp := [ ] ;
50855: NOP4
50859: PUSH
50860: EMPTY
50861: ST_TO_ADDR
// for i = 1 to mc_sides do
50862: NOP4
50866: PUSH
50867: DOUBLE
50868: LD_INT 1
50870: DEC
50871: ST_TO_ADDR
50872: NOP4
50876: PUSH
50877: FOR_TO
50878: IFFALSE 50936
// if not mc_sides [ i ] in tmp then
50880: NOP4
50884: PUSH
50885: NOP4
50889: ARRAY
50890: PUSH
50891: NOP4
50895: IN
50896: NOT
50897: IFFALSE 50934
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
50899: NOP4
50903: PUSH
50904: NOP4
50908: PPUSH
50909: NOP4
50913: PUSH
50914: LD_INT 1
50916: PLUS
50917: PPUSH
50918: NOP4
50922: PUSH
50923: NOP4
50927: ARRAY
50928: PPUSH
50929: NOP4
50933: ST_TO_ADDR
50934: GO 50877
50936: POP
50937: POP
// if not tmp then
50938: NOP4
50942: NOT
50943: IFFALSE 50947
// exit ;
50945: GO 51052
// for j in tmp do
50947: NOP4
50951: PUSH
50952: NOP4
50956: PUSH
50957: FOR_IN
50958: IFFALSE 51050
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
50960: NOP4
50964: PUSH
50965: LD_INT 22
50967: PUSH
50968: NOP4
50972: PUSH
50973: EMPTY
50974: LIST
50975: LIST
50976: PPUSH
50977: NOP4
50981: ST_TO_ADDR
// if not un then
50982: NOP4
50986: NOT
50987: IFFALSE 50991
// continue ;
50989: GO 50957
// nation := GetNation ( un [ 1 ] ) ;
50991: NOP4
50995: PUSH
50996: NOP4
51000: PUSH
51001: LD_INT 1
51003: ARRAY
51004: PPUSH
51005: NOP4
51009: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
51010: NOP4
51014: PUSH
51015: NOP4
51019: PPUSH
51020: NOP4
51024: PPUSH
51025: NOP4
51029: PPUSH
51030: NOP4
51034: PPUSH
51035: LD_INT 1
51037: PPUSH
51038: NOP4
51042: PPUSH
51043: NOP4
51047: ST_TO_ADDR
// end ;
51048: GO 50957
51050: POP
51051: POP
// end ;
51052: LD_VAR 0 1
51056: RET
// export function MC_InitSides ( ) ; var i ; begin
51057: LD_INT 0
51059: PPUSH
51060: PPUSH
// if not mc_bases then
51061: NOP4
51065: NOT
51066: IFFALSE 51070
// exit ;
51068: GO 51144
// for i = 1 to mc_bases do
51070: NOP4
51074: PUSH
51075: DOUBLE
51076: LD_INT 1
51078: DEC
51079: ST_TO_ADDR
51080: NOP4
51084: PUSH
51085: FOR_TO
51086: IFFALSE 51142
// if mc_bases [ i ] then
51088: NOP4
51092: PUSH
51093: NOP4
51097: ARRAY
51098: IFFALSE 51140
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
51100: NOP4
51104: PUSH
51105: NOP4
51109: PPUSH
51110: NOP4
51114: PPUSH
51115: NOP4
51119: PUSH
51120: NOP4
51124: ARRAY
51125: PUSH
51126: LD_INT 1
51128: ARRAY
51129: PPUSH
51130: NOP4
51134: PPUSH
51135: NOP4
51139: ST_TO_ADDR
51140: GO 51085
51142: POP
51143: POP
// end ;
51144: LD_VAR 0 1
51148: RET
// every 0 0$03 trigger skirmish do
51149: NOP4
51153: IFFALSE 51307
51155: GO 51157
51157: DISABLE
// begin enable ;
51158: ENABLE
// MC_CheckBuildings ( ) ;
51159: NOP4
// MC_CheckPeopleLife ( ) ;
51163: NOP4
// RaiseSailEvent ( 100 ) ;
51167: LD_INT 100
51169: PPUSH
51170: NOP4
// RaiseSailEvent ( 103 ) ;
51174: LD_INT 103
51176: PPUSH
51177: NOP4
// RaiseSailEvent ( 104 ) ;
51181: LD_INT 104
51183: PPUSH
51184: NOP4
// RaiseSailEvent ( 105 ) ;
51188: LD_INT 105
51190: PPUSH
51191: NOP4
// RaiseSailEvent ( 106 ) ;
51195: LD_INT 106
51197: PPUSH
51198: NOP4
// RaiseSailEvent ( 107 ) ;
51202: LD_INT 107
51204: PPUSH
51205: NOP4
// RaiseSailEvent ( 108 ) ;
51209: LD_INT 108
51211: PPUSH
51212: NOP4
// RaiseSailEvent ( 109 ) ;
51216: LD_INT 109
51218: PPUSH
51219: NOP4
// RaiseSailEvent ( 110 ) ;
51223: LD_INT 110
51225: PPUSH
51226: NOP4
// RaiseSailEvent ( 111 ) ;
51230: LD_INT 111
51232: PPUSH
51233: NOP4
// RaiseSailEvent ( 112 ) ;
51237: LD_INT 112
51239: PPUSH
51240: NOP4
// RaiseSailEvent ( 113 ) ;
51244: LD_INT 113
51246: PPUSH
51247: NOP4
// RaiseSailEvent ( 120 ) ;
51251: LD_INT 120
51253: PPUSH
51254: NOP4
// RaiseSailEvent ( 121 ) ;
51258: LD_INT 121
51260: PPUSH
51261: NOP4
// RaiseSailEvent ( 122 ) ;
51265: LD_INT 122
51267: PPUSH
51268: NOP4
// RaiseSailEvent ( 123 ) ;
51272: LD_INT 123
51274: PPUSH
51275: NOP4
// RaiseSailEvent ( 124 ) ;
51279: LD_INT 124
51281: PPUSH
51282: NOP4
// RaiseSailEvent ( 125 ) ;
51286: LD_INT 125
51288: PPUSH
51289: NOP4
// RaiseSailEvent ( 126 ) ;
51293: LD_INT 126
51295: PPUSH
51296: NOP4
// RaiseSailEvent ( 200 ) ;
51300: LD_INT 200
51302: PPUSH
51303: NOP4
// end ;
51307: END
// on SailEvent ( event ) do begin if event < 100 then
51308: NOP4
51312: PUSH
51313: LD_INT 100
51315: LESS
51316: IFFALSE 51327
// CustomEvent ( event ) ;
51318: NOP4
51322: PPUSH
51323: NOP4
// if event = 100 then
51327: NOP4
51331: PUSH
51332: LD_INT 100
51334: EQUAL
51335: IFFALSE 51341
// MC_ClassManager ( ) ;
51337: NOP4
// if event = 101 then
51341: NOP4
51345: PUSH
51346: LD_INT 101
51348: EQUAL
51349: IFFALSE 51355
// MC_RepairBuildings ( ) ;
51351: NOP4
// if event = 102 then
51355: NOP4
51359: PUSH
51360: LD_INT 102
51362: EQUAL
51363: IFFALSE 51369
// MC_Heal ( ) ;
51365: NOP4
// if event = 103 then
51369: NOP4
51373: PUSH
51374: LD_INT 103
51376: EQUAL
51377: IFFALSE 51383
// MC_Build ( ) ;
51379: NOP4
// if event = 104 then
51383: NOP4
51387: PUSH
51388: LD_INT 104
51390: EQUAL
51391: IFFALSE 51397
// MC_TurretWeapon ( ) ;
51393: NOP4
// if event = 105 then
51397: NOP4
51401: PUSH
51402: LD_INT 105
51404: EQUAL
51405: IFFALSE 51411
// MC_BuildUpgrade ( ) ;
51407: NOP4
// if event = 106 then
51411: NOP4
51415: PUSH
51416: LD_INT 106
51418: EQUAL
51419: IFFALSE 51425
// MC_PlantMines ( ) ;
51421: NOP4
// if event = 107 then
51425: NOP4
51429: PUSH
51430: LD_INT 107
51432: EQUAL
51433: IFFALSE 51439
// MC_CollectCrates ( ) ;
51435: NOP4
// if event = 108 then
51439: NOP4
51443: PUSH
51444: LD_INT 108
51446: EQUAL
51447: IFFALSE 51453
// MC_LinkRemoteControl ( ) ;
51449: NOP4
// if event = 109 then
51453: NOP4
51457: PUSH
51458: LD_INT 109
51460: EQUAL
51461: IFFALSE 51467
// MC_ProduceVehicle ( ) ;
51463: NOP4
// if event = 110 then
51467: NOP4
51471: PUSH
51472: LD_INT 110
51474: EQUAL
51475: IFFALSE 51481
// MC_SendAttack ( ) ;
51477: NOP4
// if event = 111 then
51481: NOP4
51485: PUSH
51486: LD_INT 111
51488: EQUAL
51489: IFFALSE 51495
// MC_Defend ( ) ;
51491: NOP4
// if event = 112 then
51495: NOP4
51499: PUSH
51500: LD_INT 112
51502: EQUAL
51503: IFFALSE 51509
// MC_Research ( ) ;
51505: NOP4
// if event = 113 then
51509: NOP4
51513: PUSH
51514: LD_INT 113
51516: EQUAL
51517: IFFALSE 51523
// MC_MinesTrigger ( ) ;
51519: NOP4
// if event = 120 then
51523: NOP4
51527: PUSH
51528: LD_INT 120
51530: EQUAL
51531: IFFALSE 51537
// MC_RepairVehicle ( ) ;
51533: NOP4
// if event = 121 then
51537: NOP4
51541: PUSH
51542: LD_INT 121
51544: EQUAL
51545: IFFALSE 51551
// MC_TameApe ( ) ;
51547: NOP4
// if event = 122 then
51551: NOP4
51555: PUSH
51556: LD_INT 122
51558: EQUAL
51559: IFFALSE 51565
// MC_ChangeApeClass ( ) ;
51561: NOP4
// if event = 123 then
51565: NOP4
51569: PUSH
51570: LD_INT 123
51572: EQUAL
51573: IFFALSE 51579
// MC_Bazooka ( ) ;
51575: NOP4
// if event = 124 then
51579: NOP4
51583: PUSH
51584: LD_INT 124
51586: EQUAL
51587: IFFALSE 51593
// MC_TeleportExit ( ) ;
51589: NOP4
// if event = 125 then
51593: NOP4
51597: PUSH
51598: LD_INT 125
51600: EQUAL
51601: IFFALSE 51607
// MC_Deposits ( ) ;
51603: NOP4
// if event = 126 then
51607: NOP4
51611: PUSH
51612: LD_INT 126
51614: EQUAL
51615: IFFALSE 51621
// MC_RemoteDriver ( ) ;
51617: NOP4
// if event = 200 then
51621: NOP4
51625: PUSH
51626: LD_INT 200
51628: EQUAL
51629: IFFALSE 51635
// MC_Idle ( ) ;
51631: NOP4
// end ;
51635: PPOPN 1
51637: END
// export function MC_Reset ( base , tag ) ; var i ; begin
51638: LD_INT 0
51640: PPUSH
51641: PPUSH
// if not mc_bases [ base ] or not tag then
51642: NOP4
51646: PUSH
51647: NOP4
51651: ARRAY
51652: NOT
51653: PUSH
51654: NOP4
51658: NOT
51659: OR
51660: IFFALSE 51664
// exit ;
51662: GO 51728
// for i in mc_bases [ base ] union mc_ape [ base ] do
51664: NOP4
51668: PUSH
51669: NOP4
51673: PUSH
51674: NOP4
51678: ARRAY
51679: PUSH
51680: NOP4
51684: PUSH
51685: NOP4
51689: ARRAY
51690: UNION
51691: PUSH
51692: FOR_IN
51693: IFFALSE 51726
// if GetTag ( i ) = tag then
51695: NOP4
51699: PPUSH
51700: NOP4
51704: PUSH
51705: NOP4
51709: EQUAL
51710: IFFALSE 51724
// SetTag ( i , 0 ) ;
51712: NOP4
51716: PPUSH
51717: LD_INT 0
51719: PPUSH
51720: NOP4
51724: GO 51692
51726: POP
51727: POP
// end ;
51728: LD_VAR 0 3
51732: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
51733: LD_INT 0
51735: PPUSH
51736: PPUSH
51737: PPUSH
51738: PPUSH
51739: PPUSH
51740: PPUSH
51741: PPUSH
51742: PPUSH
// if not mc_bases then
51743: NOP4
51747: NOT
51748: IFFALSE 51752
// exit ;
51750: GO 52210
// for i = 1 to mc_bases do
51752: NOP4
51756: PUSH
51757: DOUBLE
51758: LD_INT 1
51760: DEC
51761: ST_TO_ADDR
51762: NOP4
51766: PUSH
51767: FOR_TO
51768: IFFALSE 52208
// begin tmp := MC_ClassCheckReq ( i ) ;
51770: NOP4
51774: PUSH
51775: NOP4
51779: PPUSH
51780: NOP4
51784: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
51785: NOP4
51789: PUSH
51790: NOP4
51794: PPUSH
51795: NOP4
51799: PPUSH
51800: NOP4
51804: PPUSH
51805: NOP4
51809: ST_TO_ADDR
// if not tmp then
51810: NOP4
51814: NOT
51815: IFFALSE 51819
// continue ;
51817: GO 51767
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
51819: NOP4
51823: PUSH
51824: NOP4
51828: PUSH
51829: NOP4
51833: ARRAY
51834: PPUSH
51835: LD_INT 2
51837: PUSH
51838: LD_INT 30
51840: PUSH
51841: LD_INT 4
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: PUSH
51848: LD_INT 30
51850: PUSH
51851: LD_INT 5
51853: PUSH
51854: EMPTY
51855: LIST
51856: LIST
51857: PUSH
51858: EMPTY
51859: LIST
51860: LIST
51861: LIST
51862: PPUSH
51863: NOP4
51867: PUSH
51868: NOP4
51872: PUSH
51873: NOP4
51877: ARRAY
51878: PPUSH
51879: LD_INT 2
51881: PUSH
51882: LD_INT 30
51884: PUSH
51885: LD_INT 0
51887: PUSH
51888: EMPTY
51889: LIST
51890: LIST
51891: PUSH
51892: LD_INT 30
51894: PUSH
51895: LD_INT 1
51897: PUSH
51898: EMPTY
51899: LIST
51900: LIST
51901: PUSH
51902: EMPTY
51903: LIST
51904: LIST
51905: LIST
51906: PPUSH
51907: NOP4
51911: PUSH
51912: NOP4
51916: PUSH
51917: NOP4
51921: ARRAY
51922: PPUSH
51923: LD_INT 30
51925: PUSH
51926: LD_INT 3
51928: PUSH
51929: EMPTY
51930: LIST
51931: LIST
51932: PPUSH
51933: NOP4
51937: PUSH
51938: NOP4
51942: PUSH
51943: NOP4
51947: ARRAY
51948: PPUSH
51949: LD_INT 2
51951: PUSH
51952: LD_INT 30
51954: PUSH
51955: LD_INT 6
51957: PUSH
51958: EMPTY
51959: LIST
51960: LIST
51961: PUSH
51962: LD_INT 30
51964: PUSH
51965: LD_INT 7
51967: PUSH
51968: EMPTY
51969: LIST
51970: LIST
51971: PUSH
51972: LD_INT 30
51974: PUSH
51975: LD_INT 8
51977: PUSH
51978: EMPTY
51979: LIST
51980: LIST
51981: PUSH
51982: EMPTY
51983: LIST
51984: LIST
51985: LIST
51986: LIST
51987: PPUSH
51988: NOP4
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: LIST
51997: LIST
51998: ST_TO_ADDR
// for j = 1 to 4 do
51999: NOP4
52003: PUSH
52004: DOUBLE
52005: LD_INT 1
52007: DEC
52008: ST_TO_ADDR
52009: LD_INT 4
52011: PUSH
52012: FOR_TO
52013: IFFALSE 52204
// begin if not tmp [ j ] then
52015: NOP4
52019: PUSH
52020: NOP4
52024: ARRAY
52025: NOT
52026: IFFALSE 52030
// continue ;
52028: GO 52012
// for p in tmp [ j ] do
52030: NOP4
52034: PUSH
52035: NOP4
52039: PUSH
52040: NOP4
52044: ARRAY
52045: PUSH
52046: FOR_IN
52047: IFFALSE 52200
// begin if not b [ j ] then
52049: NOP4
52053: PUSH
52054: NOP4
52058: ARRAY
52059: NOT
52060: IFFALSE 52064
// break ;
52062: GO 52200
// e := 0 ;
52064: NOP4
52068: PUSH
52069: LD_INT 0
52071: ST_TO_ADDR
// for k in b [ j ] do
52072: NOP4
52076: PUSH
52077: NOP4
52081: PUSH
52082: NOP4
52086: ARRAY
52087: PUSH
52088: FOR_IN
52089: IFFALSE 52116
// if IsNotFull ( k ) then
52091: NOP4
52095: PPUSH
52096: NOP4
52100: IFFALSE 52114
// begin e := k ;
52102: NOP4
52106: PUSH
52107: NOP4
52111: ST_TO_ADDR
// break ;
52112: GO 52116
// end ;
52114: GO 52088
52116: POP
52117: POP
// if e and not UnitGoingToBuilding ( p , e ) then
52118: NOP4
52122: PUSH
52123: NOP4
52127: PPUSH
52128: NOP4
52132: PPUSH
52133: NOP4
52137: NOT
52138: AND
52139: IFFALSE 52198
// begin if IsInUnit ( p ) then
52141: NOP4
52145: PPUSH
52146: NOP4
52150: IFFALSE 52161
// ComExitBuilding ( p ) ;
52152: NOP4
52156: PPUSH
52157: NOP4
// ComEnterUnit ( p , e ) ;
52161: NOP4
52165: PPUSH
52166: NOP4
52170: PPUSH
52171: NOP4
// AddComChangeProfession ( p , j ) ;
52175: NOP4
52179: PPUSH
52180: NOP4
52184: PPUSH
52185: NOP4
// AddComExitBuilding ( p ) ;
52189: NOP4
52193: PPUSH
52194: NOP4
// end ; end ;
52198: GO 52046
52200: POP
52201: POP
// end ;
52202: GO 52012
52204: POP
52205: POP
// end ;
52206: GO 51767
52208: POP
52209: POP
// end ;
52210: LD_VAR 0 1
52214: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
52215: LD_INT 0
52217: PPUSH
52218: PPUSH
52219: PPUSH
52220: PPUSH
52221: PPUSH
52222: PPUSH
52223: PPUSH
52224: PPUSH
52225: PPUSH
52226: PPUSH
52227: PPUSH
52228: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
52229: NOP4
52233: NOT
52234: PUSH
52235: NOP4
52239: PUSH
52240: NOP4
52244: ARRAY
52245: NOT
52246: OR
52247: PUSH
52248: NOP4
52252: PUSH
52253: NOP4
52257: ARRAY
52258: PPUSH
52259: LD_INT 2
52261: PUSH
52262: LD_INT 30
52264: PUSH
52265: LD_INT 0
52267: PUSH
52268: EMPTY
52269: LIST
52270: LIST
52271: PUSH
52272: LD_INT 30
52274: PUSH
52275: LD_INT 1
52277: PUSH
52278: EMPTY
52279: LIST
52280: LIST
52281: PUSH
52282: EMPTY
52283: LIST
52284: LIST
52285: LIST
52286: PPUSH
52287: NOP4
52291: NOT
52292: OR
52293: IFFALSE 52297
// exit ;
52295: GO 55800
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52297: NOP4
52301: PUSH
52302: NOP4
52306: PUSH
52307: NOP4
52311: ARRAY
52312: PPUSH
52313: LD_INT 2
52315: PUSH
52316: LD_INT 25
52318: PUSH
52319: LD_INT 1
52321: PUSH
52322: EMPTY
52323: LIST
52324: LIST
52325: PUSH
52326: LD_INT 25
52328: PUSH
52329: LD_INT 2
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: PUSH
52336: LD_INT 25
52338: PUSH
52339: LD_INT 3
52341: PUSH
52342: EMPTY
52343: LIST
52344: LIST
52345: PUSH
52346: LD_INT 25
52348: PUSH
52349: LD_INT 4
52351: PUSH
52352: EMPTY
52353: LIST
52354: LIST
52355: PUSH
52356: LD_INT 25
52358: PUSH
52359: LD_INT 5
52361: PUSH
52362: EMPTY
52363: LIST
52364: LIST
52365: PUSH
52366: LD_INT 25
52368: PUSH
52369: LD_INT 8
52371: PUSH
52372: EMPTY
52373: LIST
52374: LIST
52375: PUSH
52376: LD_INT 25
52378: PUSH
52379: LD_INT 9
52381: PUSH
52382: EMPTY
52383: LIST
52384: LIST
52385: PUSH
52386: EMPTY
52387: LIST
52388: LIST
52389: LIST
52390: LIST
52391: LIST
52392: LIST
52393: LIST
52394: LIST
52395: PPUSH
52396: NOP4
52400: ST_TO_ADDR
// if not tmp then
52401: NOP4
52405: NOT
52406: IFFALSE 52410
// exit ;
52408: GO 55800
// for i in tmp do
52410: NOP4
52414: PUSH
52415: NOP4
52419: PUSH
52420: FOR_IN
52421: IFFALSE 52452
// if GetTag ( i ) then
52423: NOP4
52427: PPUSH
52428: NOP4
52432: IFFALSE 52450
// tmp := tmp diff i ;
52434: NOP4
52438: PUSH
52439: NOP4
52443: PUSH
52444: NOP4
52448: DIFF
52449: ST_TO_ADDR
52450: GO 52420
52452: POP
52453: POP
// if not tmp then
52454: NOP4
52458: NOT
52459: IFFALSE 52463
// exit ;
52461: GO 55800
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52463: NOP4
52467: PUSH
52468: NOP4
52472: PUSH
52473: NOP4
52477: ARRAY
52478: PPUSH
52479: LD_INT 2
52481: PUSH
52482: LD_INT 25
52484: PUSH
52485: LD_INT 1
52487: PUSH
52488: EMPTY
52489: LIST
52490: LIST
52491: PUSH
52492: LD_INT 25
52494: PUSH
52495: LD_INT 5
52497: PUSH
52498: EMPTY
52499: LIST
52500: LIST
52501: PUSH
52502: LD_INT 25
52504: PUSH
52505: LD_INT 8
52507: PUSH
52508: EMPTY
52509: LIST
52510: LIST
52511: PUSH
52512: LD_INT 25
52514: PUSH
52515: LD_INT 9
52517: PUSH
52518: EMPTY
52519: LIST
52520: LIST
52521: PUSH
52522: EMPTY
52523: LIST
52524: LIST
52525: LIST
52526: LIST
52527: LIST
52528: PPUSH
52529: NOP4
52533: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
52534: NOP4
52538: PUSH
52539: NOP4
52543: PUSH
52544: NOP4
52548: ARRAY
52549: PPUSH
52550: LD_INT 25
52552: PUSH
52553: LD_INT 2
52555: PUSH
52556: EMPTY
52557: LIST
52558: LIST
52559: PPUSH
52560: NOP4
52564: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52565: NOP4
52569: PUSH
52570: NOP4
52574: PUSH
52575: NOP4
52579: ARRAY
52580: PPUSH
52581: LD_INT 25
52583: PUSH
52584: LD_INT 3
52586: PUSH
52587: EMPTY
52588: LIST
52589: LIST
52590: PPUSH
52591: NOP4
52595: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
52596: NOP4
52600: PUSH
52601: NOP4
52605: PUSH
52606: NOP4
52610: ARRAY
52611: PPUSH
52612: LD_INT 25
52614: PUSH
52615: LD_INT 4
52617: PUSH
52618: EMPTY
52619: LIST
52620: LIST
52621: PUSH
52622: LD_INT 24
52624: PUSH
52625: LD_INT 251
52627: PUSH
52628: EMPTY
52629: LIST
52630: LIST
52631: PUSH
52632: EMPTY
52633: LIST
52634: LIST
52635: PPUSH
52636: NOP4
52640: ST_TO_ADDR
// if mc_scan [ base ] then
52641: NOP4
52645: PUSH
52646: NOP4
52650: ARRAY
52651: IFFALSE 53112
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
52653: NOP4
52657: PUSH
52658: NOP4
52662: PPUSH
52663: NOP4
52667: PPUSH
52668: LD_INT 4
52670: PPUSH
52671: NOP4
52675: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52676: NOP4
52680: PUSH
52681: NOP4
52685: PUSH
52686: NOP4
52690: ARRAY
52691: PPUSH
52692: LD_INT 2
52694: PUSH
52695: LD_INT 30
52697: PUSH
52698: LD_INT 4
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: PUSH
52705: LD_INT 30
52707: PUSH
52708: LD_INT 5
52710: PUSH
52711: EMPTY
52712: LIST
52713: LIST
52714: PUSH
52715: EMPTY
52716: LIST
52717: LIST
52718: LIST
52719: PPUSH
52720: NOP4
52724: ST_TO_ADDR
// if not b then
52725: NOP4
52729: NOT
52730: IFFALSE 52734
// exit ;
52732: GO 55800
// p := [ ] ;
52734: NOP4
52738: PUSH
52739: EMPTY
52740: ST_TO_ADDR
// if sci >= 2 then
52741: NOP4
52745: PUSH
52746: LD_INT 2
52748: GREATEREQUAL
52749: IFFALSE 52780
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
52751: NOP4
52755: PUSH
52756: NOP4
52760: PUSH
52761: LD_INT 1
52763: ARRAY
52764: PUSH
52765: NOP4
52769: PUSH
52770: LD_INT 2
52772: ARRAY
52773: PUSH
52774: EMPTY
52775: LIST
52776: LIST
52777: ST_TO_ADDR
52778: GO 52841
// if sci = 1 then
52780: NOP4
52784: PUSH
52785: LD_INT 1
52787: EQUAL
52788: IFFALSE 52809
// sci := [ sci [ 1 ] ] else
52790: NOP4
52794: PUSH
52795: NOP4
52799: PUSH
52800: LD_INT 1
52802: ARRAY
52803: PUSH
52804: EMPTY
52805: LIST
52806: ST_TO_ADDR
52807: GO 52841
// if sci = 0 then
52809: NOP4
52813: PUSH
52814: LD_INT 0
52816: EQUAL
52817: IFFALSE 52841
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
52819: NOP4
52823: PUSH
52824: NOP4
52828: PPUSH
52829: LD_INT 4
52831: PPUSH
52832: NOP4
52836: PUSH
52837: LD_INT 1
52839: ARRAY
52840: ST_TO_ADDR
// if eng > 4 then
52841: NOP4
52845: PUSH
52846: LD_INT 4
52848: GREATER
52849: IFFALSE 52895
// for i = eng downto 4 do
52851: NOP4
52855: PUSH
52856: DOUBLE
52857: NOP4
52861: INC
52862: ST_TO_ADDR
52863: LD_INT 4
52865: PUSH
52866: FOR_DOWNTO
52867: IFFALSE 52893
// eng := eng diff eng [ i ] ;
52869: NOP4
52873: PUSH
52874: NOP4
52878: PUSH
52879: NOP4
52883: PUSH
52884: NOP4
52888: ARRAY
52889: DIFF
52890: ST_TO_ADDR
52891: GO 52866
52893: POP
52894: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
52895: NOP4
52899: PUSH
52900: NOP4
52904: PUSH
52905: NOP4
52909: PUSH
52910: NOP4
52914: UNION
52915: PUSH
52916: NOP4
52920: UNION
52921: PUSH
52922: NOP4
52926: UNION
52927: DIFF
52928: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
52929: NOP4
52933: PUSH
52934: NOP4
52938: PUSH
52939: NOP4
52943: ARRAY
52944: PPUSH
52945: LD_INT 2
52947: PUSH
52948: LD_INT 30
52950: PUSH
52951: LD_INT 32
52953: PUSH
52954: EMPTY
52955: LIST
52956: LIST
52957: PUSH
52958: LD_INT 30
52960: PUSH
52961: LD_INT 31
52963: PUSH
52964: EMPTY
52965: LIST
52966: LIST
52967: PUSH
52968: EMPTY
52969: LIST
52970: LIST
52971: LIST
52972: PPUSH
52973: NOP4
52977: PUSH
52978: NOP4
52982: PUSH
52983: NOP4
52987: ARRAY
52988: PPUSH
52989: LD_INT 2
52991: PUSH
52992: LD_INT 30
52994: PUSH
52995: LD_INT 4
52997: PUSH
52998: EMPTY
52999: LIST
53000: LIST
53001: PUSH
53002: LD_INT 30
53004: PUSH
53005: LD_INT 5
53007: PUSH
53008: EMPTY
53009: LIST
53010: LIST
53011: PUSH
53012: EMPTY
53013: LIST
53014: LIST
53015: LIST
53016: PPUSH
53017: NOP4
53021: PUSH
53022: LD_INT 6
53024: MUL
53025: PLUS
53026: ST_TO_ADDR
// if bcount < tmp then
53027: NOP4
53031: PUSH
53032: NOP4
53036: LESS
53037: IFFALSE 53083
// for i = tmp downto bcount do
53039: NOP4
53043: PUSH
53044: DOUBLE
53045: NOP4
53049: INC
53050: ST_TO_ADDR
53051: NOP4
53055: PUSH
53056: FOR_DOWNTO
53057: IFFALSE 53081
// tmp := Delete ( tmp , tmp ) ;
53059: NOP4
53063: PUSH
53064: NOP4
53068: PPUSH
53069: NOP4
53073: PPUSH
53074: NOP4
53078: ST_TO_ADDR
53079: GO 53056
53081: POP
53082: POP
// result := [ tmp , 0 , 0 , p ] ;
53083: NOP4
53087: PUSH
53088: NOP4
53092: PUSH
53093: LD_INT 0
53095: PUSH
53096: LD_INT 0
53098: PUSH
53099: NOP4
53103: PUSH
53104: EMPTY
53105: LIST
53106: LIST
53107: LIST
53108: LIST
53109: ST_TO_ADDR
// exit ;
53110: GO 55800
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53112: NOP4
53116: PUSH
53117: NOP4
53121: ARRAY
53122: PPUSH
53123: LD_INT 2
53125: PUSH
53126: LD_INT 30
53128: PUSH
53129: LD_INT 6
53131: PUSH
53132: EMPTY
53133: LIST
53134: LIST
53135: PUSH
53136: LD_INT 30
53138: PUSH
53139: LD_INT 7
53141: PUSH
53142: EMPTY
53143: LIST
53144: LIST
53145: PUSH
53146: LD_INT 30
53148: PUSH
53149: LD_INT 8
53151: PUSH
53152: EMPTY
53153: LIST
53154: LIST
53155: PUSH
53156: EMPTY
53157: LIST
53158: LIST
53159: LIST
53160: LIST
53161: PPUSH
53162: NOP4
53166: NOT
53167: PUSH
53168: NOP4
53172: PUSH
53173: NOP4
53177: ARRAY
53178: PPUSH
53179: LD_INT 30
53181: PUSH
53182: LD_INT 3
53184: PUSH
53185: EMPTY
53186: LIST
53187: LIST
53188: PPUSH
53189: NOP4
53193: NOT
53194: AND
53195: IFFALSE 53267
// begin if eng = tmp then
53197: NOP4
53201: PUSH
53202: NOP4
53206: EQUAL
53207: IFFALSE 53211
// exit ;
53209: GO 55800
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
53211: NOP4
53215: PUSH
53216: NOP4
53220: PPUSH
53221: NOP4
53225: PPUSH
53226: LD_INT 1
53228: PPUSH
53229: NOP4
53233: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
53234: NOP4
53238: PUSH
53239: LD_INT 0
53241: PUSH
53242: NOP4
53246: PUSH
53247: NOP4
53251: DIFF
53252: PUSH
53253: LD_INT 0
53255: PUSH
53256: LD_INT 0
53258: PUSH
53259: EMPTY
53260: LIST
53261: LIST
53262: LIST
53263: LIST
53264: ST_TO_ADDR
// exit ;
53265: GO 55800
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53267: NOP4
53271: PUSH
53272: NOP4
53276: PUSH
53277: NOP4
53281: ARRAY
53282: ARRAY
53283: PUSH
53284: NOP4
53288: PUSH
53289: NOP4
53293: ARRAY
53294: PPUSH
53295: LD_INT 2
53297: PUSH
53298: LD_INT 30
53300: PUSH
53301: LD_INT 6
53303: PUSH
53304: EMPTY
53305: LIST
53306: LIST
53307: PUSH
53308: LD_INT 30
53310: PUSH
53311: LD_INT 7
53313: PUSH
53314: EMPTY
53315: LIST
53316: LIST
53317: PUSH
53318: LD_INT 30
53320: PUSH
53321: LD_INT 8
53323: PUSH
53324: EMPTY
53325: LIST
53326: LIST
53327: PUSH
53328: EMPTY
53329: LIST
53330: LIST
53331: LIST
53332: LIST
53333: PPUSH
53334: NOP4
53338: AND
53339: PUSH
53340: NOP4
53344: PUSH
53345: NOP4
53349: ARRAY
53350: PPUSH
53351: LD_INT 30
53353: PUSH
53354: LD_INT 3
53356: PUSH
53357: EMPTY
53358: LIST
53359: LIST
53360: PPUSH
53361: NOP4
53365: NOT
53366: AND
53367: IFFALSE 53581
// begin if sci >= 6 then
53369: NOP4
53373: PUSH
53374: LD_INT 6
53376: GREATEREQUAL
53377: IFFALSE 53381
// exit ;
53379: GO 55800
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
53381: NOP4
53385: PUSH
53386: NOP4
53390: PPUSH
53391: NOP4
53395: PPUSH
53396: LD_INT 2
53398: PPUSH
53399: NOP4
53403: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
53404: NOP4
53408: PUSH
53409: NOP4
53413: PUSH
53414: NOP4
53418: DIFF
53419: PPUSH
53420: LD_INT 4
53422: PPUSH
53423: NOP4
53427: ST_TO_ADDR
// p := [ ] ;
53428: NOP4
53432: PUSH
53433: EMPTY
53434: ST_TO_ADDR
// if sci < 6 and sort > 6 then
53435: NOP4
53439: PUSH
53440: LD_INT 6
53442: LESS
53443: PUSH
53444: NOP4
53448: PUSH
53449: LD_INT 6
53451: GREATER
53452: AND
53453: IFFALSE 53534
// begin for i = 1 to 6 - sci do
53455: NOP4
53459: PUSH
53460: DOUBLE
53461: LD_INT 1
53463: DEC
53464: ST_TO_ADDR
53465: LD_INT 6
53467: PUSH
53468: NOP4
53472: MINUS
53473: PUSH
53474: FOR_TO
53475: IFFALSE 53530
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
53477: NOP4
53481: PUSH
53482: NOP4
53486: PPUSH
53487: NOP4
53491: PUSH
53492: LD_INT 1
53494: PLUS
53495: PPUSH
53496: NOP4
53500: PUSH
53501: LD_INT 1
53503: ARRAY
53504: PPUSH
53505: NOP4
53509: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
53510: NOP4
53514: PUSH
53515: NOP4
53519: PPUSH
53520: LD_INT 1
53522: PPUSH
53523: NOP4
53527: ST_TO_ADDR
// end ;
53528: GO 53474
53530: POP
53531: POP
// end else
53532: GO 53554
// if sort then
53534: NOP4
53538: IFFALSE 53554
// p := sort [ 1 ] ;
53540: NOP4
53544: PUSH
53545: NOP4
53549: PUSH
53550: LD_INT 1
53552: ARRAY
53553: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
53554: NOP4
53558: PUSH
53559: LD_INT 0
53561: PUSH
53562: LD_INT 0
53564: PUSH
53565: LD_INT 0
53567: PUSH
53568: NOP4
53572: PUSH
53573: EMPTY
53574: LIST
53575: LIST
53576: LIST
53577: LIST
53578: ST_TO_ADDR
// exit ;
53579: GO 55800
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53581: NOP4
53585: PUSH
53586: NOP4
53590: PUSH
53591: NOP4
53595: ARRAY
53596: ARRAY
53597: PUSH
53598: NOP4
53602: PUSH
53603: NOP4
53607: ARRAY
53608: PPUSH
53609: LD_INT 2
53611: PUSH
53612: LD_INT 30
53614: PUSH
53615: LD_INT 6
53617: PUSH
53618: EMPTY
53619: LIST
53620: LIST
53621: PUSH
53622: LD_INT 30
53624: PUSH
53625: LD_INT 7
53627: PUSH
53628: EMPTY
53629: LIST
53630: LIST
53631: PUSH
53632: LD_INT 30
53634: PUSH
53635: LD_INT 8
53637: PUSH
53638: EMPTY
53639: LIST
53640: LIST
53641: PUSH
53642: EMPTY
53643: LIST
53644: LIST
53645: LIST
53646: LIST
53647: PPUSH
53648: NOP4
53652: AND
53653: PUSH
53654: NOP4
53658: PUSH
53659: NOP4
53663: ARRAY
53664: PPUSH
53665: LD_INT 30
53667: PUSH
53668: LD_INT 3
53670: PUSH
53671: EMPTY
53672: LIST
53673: LIST
53674: PPUSH
53675: NOP4
53679: AND
53680: IFFALSE 54414
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
53682: NOP4
53686: PUSH
53687: NOP4
53691: PPUSH
53692: NOP4
53696: PPUSH
53697: LD_INT 3
53699: PPUSH
53700: NOP4
53704: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53705: NOP4
53709: PUSH
53710: LD_INT 0
53712: PUSH
53713: LD_INT 0
53715: PUSH
53716: LD_INT 0
53718: PUSH
53719: LD_INT 0
53721: PUSH
53722: EMPTY
53723: LIST
53724: LIST
53725: LIST
53726: LIST
53727: ST_TO_ADDR
// if not eng then
53728: NOP4
53732: NOT
53733: IFFALSE 53796
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
53735: NOP4
53739: PUSH
53740: NOP4
53744: PPUSH
53745: LD_INT 2
53747: PPUSH
53748: NOP4
53752: PUSH
53753: LD_INT 1
53755: ARRAY
53756: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
53757: NOP4
53761: PUSH
53762: NOP4
53766: PPUSH
53767: LD_INT 2
53769: PPUSH
53770: NOP4
53774: PPUSH
53775: NOP4
53779: ST_TO_ADDR
// tmp := tmp diff p ;
53780: NOP4
53784: PUSH
53785: NOP4
53789: PUSH
53790: NOP4
53794: DIFF
53795: ST_TO_ADDR
// end ; if tmp and sci < 6 then
53796: NOP4
53800: PUSH
53801: NOP4
53805: PUSH
53806: LD_INT 6
53808: LESS
53809: AND
53810: IFFALSE 53998
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
53812: NOP4
53816: PUSH
53817: NOP4
53821: PUSH
53822: NOP4
53826: PUSH
53827: NOP4
53831: UNION
53832: DIFF
53833: PPUSH
53834: LD_INT 4
53836: PPUSH
53837: NOP4
53841: ST_TO_ADDR
// p := [ ] ;
53842: NOP4
53846: PUSH
53847: EMPTY
53848: ST_TO_ADDR
// if sort then
53849: NOP4
53853: IFFALSE 53969
// for i = 1 to 6 - sci do
53855: NOP4
53859: PUSH
53860: DOUBLE
53861: LD_INT 1
53863: DEC
53864: ST_TO_ADDR
53865: LD_INT 6
53867: PUSH
53868: NOP4
53872: MINUS
53873: PUSH
53874: FOR_TO
53875: IFFALSE 53967
// begin if i = sort then
53877: NOP4
53881: PUSH
53882: NOP4
53886: EQUAL
53887: IFFALSE 53891
// break ;
53889: GO 53967
// if GetClass ( i ) = 4 then
53891: NOP4
53895: PPUSH
53896: NOP4
53900: PUSH
53901: LD_INT 4
53903: EQUAL
53904: IFFALSE 53908
// continue ;
53906: GO 53874
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53908: NOP4
53912: PUSH
53913: NOP4
53917: PPUSH
53918: NOP4
53922: PUSH
53923: LD_INT 1
53925: PLUS
53926: PPUSH
53927: NOP4
53931: PUSH
53932: NOP4
53936: ARRAY
53937: PPUSH
53938: NOP4
53942: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53943: NOP4
53947: PUSH
53948: NOP4
53952: PUSH
53953: NOP4
53957: PUSH
53958: NOP4
53962: ARRAY
53963: DIFF
53964: ST_TO_ADDR
// end ;
53965: GO 53874
53967: POP
53968: POP
// if p then
53969: NOP4
53973: IFFALSE 53998
// result := Replace ( result , 4 , p ) ;
53975: NOP4
53979: PUSH
53980: NOP4
53984: PPUSH
53985: LD_INT 4
53987: PPUSH
53988: NOP4
53992: PPUSH
53993: NOP4
53997: ST_TO_ADDR
// end ; if tmp and mech < 6 then
53998: NOP4
54002: PUSH
54003: NOP4
54007: PUSH
54008: LD_INT 6
54010: LESS
54011: AND
54012: IFFALSE 54200
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54014: NOP4
54018: PUSH
54019: NOP4
54023: PUSH
54024: NOP4
54028: PUSH
54029: NOP4
54033: UNION
54034: DIFF
54035: PPUSH
54036: LD_INT 3
54038: PPUSH
54039: NOP4
54043: ST_TO_ADDR
// p := [ ] ;
54044: NOP4
54048: PUSH
54049: EMPTY
54050: ST_TO_ADDR
// if sort then
54051: NOP4
54055: IFFALSE 54171
// for i = 1 to 6 - mech do
54057: NOP4
54061: PUSH
54062: DOUBLE
54063: LD_INT 1
54065: DEC
54066: ST_TO_ADDR
54067: LD_INT 6
54069: PUSH
54070: NOP4
54074: MINUS
54075: PUSH
54076: FOR_TO
54077: IFFALSE 54169
// begin if i = sort then
54079: NOP4
54083: PUSH
54084: NOP4
54088: EQUAL
54089: IFFALSE 54093
// break ;
54091: GO 54169
// if GetClass ( i ) = 3 then
54093: NOP4
54097: PPUSH
54098: NOP4
54102: PUSH
54103: LD_INT 3
54105: EQUAL
54106: IFFALSE 54110
// continue ;
54108: GO 54076
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54110: NOP4
54114: PUSH
54115: NOP4
54119: PPUSH
54120: NOP4
54124: PUSH
54125: LD_INT 1
54127: PLUS
54128: PPUSH
54129: NOP4
54133: PUSH
54134: NOP4
54138: ARRAY
54139: PPUSH
54140: NOP4
54144: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54145: NOP4
54149: PUSH
54150: NOP4
54154: PUSH
54155: NOP4
54159: PUSH
54160: NOP4
54164: ARRAY
54165: DIFF
54166: ST_TO_ADDR
// end ;
54167: GO 54076
54169: POP
54170: POP
// if p then
54171: NOP4
54175: IFFALSE 54200
// result := Replace ( result , 3 , p ) ;
54177: NOP4
54181: PUSH
54182: NOP4
54186: PPUSH
54187: LD_INT 3
54189: PPUSH
54190: NOP4
54194: PPUSH
54195: NOP4
54199: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
54200: NOP4
54204: PUSH
54205: LD_INT 6
54207: GREATER
54208: PUSH
54209: NOP4
54213: PUSH
54214: LD_INT 6
54216: LESS
54217: AND
54218: IFFALSE 54412
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54220: NOP4
54224: PUSH
54225: NOP4
54229: PUSH
54230: NOP4
54234: PUSH
54235: NOP4
54239: UNION
54240: PUSH
54241: NOP4
54245: UNION
54246: DIFF
54247: PPUSH
54248: LD_INT 2
54250: PPUSH
54251: NOP4
54255: ST_TO_ADDR
// p := [ ] ;
54256: NOP4
54260: PUSH
54261: EMPTY
54262: ST_TO_ADDR
// if sort then
54263: NOP4
54267: IFFALSE 54383
// for i = 1 to 6 - eng do
54269: NOP4
54273: PUSH
54274: DOUBLE
54275: LD_INT 1
54277: DEC
54278: ST_TO_ADDR
54279: LD_INT 6
54281: PUSH
54282: NOP4
54286: MINUS
54287: PUSH
54288: FOR_TO
54289: IFFALSE 54381
// begin if i = sort then
54291: NOP4
54295: PUSH
54296: NOP4
54300: EQUAL
54301: IFFALSE 54305
// break ;
54303: GO 54381
// if GetClass ( i ) = 2 then
54305: NOP4
54309: PPUSH
54310: NOP4
54314: PUSH
54315: LD_INT 2
54317: EQUAL
54318: IFFALSE 54322
// continue ;
54320: GO 54288
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54322: NOP4
54326: PUSH
54327: NOP4
54331: PPUSH
54332: NOP4
54336: PUSH
54337: LD_INT 1
54339: PLUS
54340: PPUSH
54341: NOP4
54345: PUSH
54346: NOP4
54350: ARRAY
54351: PPUSH
54352: NOP4
54356: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54357: NOP4
54361: PUSH
54362: NOP4
54366: PUSH
54367: NOP4
54371: PUSH
54372: NOP4
54376: ARRAY
54377: DIFF
54378: ST_TO_ADDR
// end ;
54379: GO 54288
54381: POP
54382: POP
// if p then
54383: NOP4
54387: IFFALSE 54412
// result := Replace ( result , 2 , p ) ;
54389: NOP4
54393: PUSH
54394: NOP4
54398: PPUSH
54399: LD_INT 2
54401: PPUSH
54402: NOP4
54406: PPUSH
54407: NOP4
54411: ST_TO_ADDR
// end ; exit ;
54412: GO 55800
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
54414: NOP4
54418: PUSH
54419: NOP4
54423: PUSH
54424: NOP4
54428: ARRAY
54429: ARRAY
54430: NOT
54431: PUSH
54432: NOP4
54436: PUSH
54437: NOP4
54441: ARRAY
54442: PPUSH
54443: LD_INT 30
54445: PUSH
54446: LD_INT 3
54448: PUSH
54449: EMPTY
54450: LIST
54451: LIST
54452: PPUSH
54453: NOP4
54457: AND
54458: PUSH
54459: NOP4
54463: PUSH
54464: NOP4
54468: ARRAY
54469: AND
54470: IFFALSE 55078
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
54472: NOP4
54476: PUSH
54477: NOP4
54481: PPUSH
54482: NOP4
54486: PPUSH
54487: LD_INT 5
54489: PPUSH
54490: NOP4
54494: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54495: NOP4
54499: PUSH
54500: LD_INT 0
54502: PUSH
54503: LD_INT 0
54505: PUSH
54506: LD_INT 0
54508: PUSH
54509: LD_INT 0
54511: PUSH
54512: EMPTY
54513: LIST
54514: LIST
54515: LIST
54516: LIST
54517: ST_TO_ADDR
// if sci > 1 then
54518: NOP4
54522: PUSH
54523: LD_INT 1
54525: GREATER
54526: IFFALSE 54554
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
54528: NOP4
54532: PUSH
54533: NOP4
54537: PUSH
54538: NOP4
54542: PUSH
54543: NOP4
54547: PUSH
54548: LD_INT 1
54550: ARRAY
54551: DIFF
54552: DIFF
54553: ST_TO_ADDR
// if tmp and not sci then
54554: NOP4
54558: PUSH
54559: NOP4
54563: NOT
54564: AND
54565: IFFALSE 54634
// begin sort := SortBySkill ( tmp , 4 ) ;
54567: NOP4
54571: PUSH
54572: NOP4
54576: PPUSH
54577: LD_INT 4
54579: PPUSH
54580: NOP4
54584: ST_TO_ADDR
// if sort then
54585: NOP4
54589: IFFALSE 54605
// p := sort [ 1 ] ;
54591: NOP4
54595: PUSH
54596: NOP4
54600: PUSH
54601: LD_INT 1
54603: ARRAY
54604: ST_TO_ADDR
// if p then
54605: NOP4
54609: IFFALSE 54634
// result := Replace ( result , 4 , p ) ;
54611: NOP4
54615: PUSH
54616: NOP4
54620: PPUSH
54621: LD_INT 4
54623: PPUSH
54624: NOP4
54628: PPUSH
54629: NOP4
54633: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54634: NOP4
54638: PUSH
54639: NOP4
54643: PUSH
54644: NOP4
54648: DIFF
54649: ST_TO_ADDR
// if tmp and mech < 6 then
54650: NOP4
54654: PUSH
54655: NOP4
54659: PUSH
54660: LD_INT 6
54662: LESS
54663: AND
54664: IFFALSE 54852
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54666: NOP4
54670: PUSH
54671: NOP4
54675: PUSH
54676: NOP4
54680: PUSH
54681: NOP4
54685: UNION
54686: DIFF
54687: PPUSH
54688: LD_INT 3
54690: PPUSH
54691: NOP4
54695: ST_TO_ADDR
// p := [ ] ;
54696: NOP4
54700: PUSH
54701: EMPTY
54702: ST_TO_ADDR
// if sort then
54703: NOP4
54707: IFFALSE 54823
// for i = 1 to 6 - mech do
54709: NOP4
54713: PUSH
54714: DOUBLE
54715: LD_INT 1
54717: DEC
54718: ST_TO_ADDR
54719: LD_INT 6
54721: PUSH
54722: NOP4
54726: MINUS
54727: PUSH
54728: FOR_TO
54729: IFFALSE 54821
// begin if i = sort then
54731: NOP4
54735: PUSH
54736: NOP4
54740: EQUAL
54741: IFFALSE 54745
// break ;
54743: GO 54821
// if GetClass ( i ) = 3 then
54745: NOP4
54749: PPUSH
54750: NOP4
54754: PUSH
54755: LD_INT 3
54757: EQUAL
54758: IFFALSE 54762
// continue ;
54760: GO 54728
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54762: NOP4
54766: PUSH
54767: NOP4
54771: PPUSH
54772: NOP4
54776: PUSH
54777: LD_INT 1
54779: PLUS
54780: PPUSH
54781: NOP4
54785: PUSH
54786: NOP4
54790: ARRAY
54791: PPUSH
54792: NOP4
54796: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54797: NOP4
54801: PUSH
54802: NOP4
54806: PUSH
54807: NOP4
54811: PUSH
54812: NOP4
54816: ARRAY
54817: DIFF
54818: ST_TO_ADDR
// end ;
54819: GO 54728
54821: POP
54822: POP
// if p then
54823: NOP4
54827: IFFALSE 54852
// result := Replace ( result , 3 , p ) ;
54829: NOP4
54833: PUSH
54834: NOP4
54838: PPUSH
54839: LD_INT 3
54841: PPUSH
54842: NOP4
54846: PPUSH
54847: NOP4
54851: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54852: NOP4
54856: PUSH
54857: NOP4
54861: PUSH
54862: NOP4
54866: DIFF
54867: ST_TO_ADDR
// if tmp and eng < 6 then
54868: NOP4
54872: PUSH
54873: NOP4
54877: PUSH
54878: LD_INT 6
54880: LESS
54881: AND
54882: IFFALSE 55076
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54884: NOP4
54888: PUSH
54889: NOP4
54893: PUSH
54894: NOP4
54898: PUSH
54899: NOP4
54903: UNION
54904: PUSH
54905: NOP4
54909: UNION
54910: DIFF
54911: PPUSH
54912: LD_INT 2
54914: PPUSH
54915: NOP4
54919: ST_TO_ADDR
// p := [ ] ;
54920: NOP4
54924: PUSH
54925: EMPTY
54926: ST_TO_ADDR
// if sort then
54927: NOP4
54931: IFFALSE 55047
// for i = 1 to 6 - eng do
54933: NOP4
54937: PUSH
54938: DOUBLE
54939: LD_INT 1
54941: DEC
54942: ST_TO_ADDR
54943: LD_INT 6
54945: PUSH
54946: NOP4
54950: MINUS
54951: PUSH
54952: FOR_TO
54953: IFFALSE 55045
// begin if i = sort then
54955: NOP4
54959: PUSH
54960: NOP4
54964: EQUAL
54965: IFFALSE 54969
// break ;
54967: GO 55045
// if GetClass ( i ) = 2 then
54969: NOP4
54973: PPUSH
54974: NOP4
54978: PUSH
54979: LD_INT 2
54981: EQUAL
54982: IFFALSE 54986
// continue ;
54984: GO 54952
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54986: NOP4
54990: PUSH
54991: NOP4
54995: PPUSH
54996: NOP4
55000: PUSH
55001: LD_INT 1
55003: PLUS
55004: PPUSH
55005: NOP4
55009: PUSH
55010: NOP4
55014: ARRAY
55015: PPUSH
55016: NOP4
55020: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55021: NOP4
55025: PUSH
55026: NOP4
55030: PUSH
55031: NOP4
55035: PUSH
55036: NOP4
55040: ARRAY
55041: DIFF
55042: ST_TO_ADDR
// end ;
55043: GO 54952
55045: POP
55046: POP
// if p then
55047: NOP4
55051: IFFALSE 55076
// result := Replace ( result , 2 , p ) ;
55053: NOP4
55057: PUSH
55058: NOP4
55062: PPUSH
55063: LD_INT 2
55065: PPUSH
55066: NOP4
55070: PPUSH
55071: NOP4
55075: ST_TO_ADDR
// end ; exit ;
55076: GO 55800
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
55078: NOP4
55082: PUSH
55083: NOP4
55087: PUSH
55088: NOP4
55092: ARRAY
55093: ARRAY
55094: NOT
55095: PUSH
55096: NOP4
55100: PUSH
55101: NOP4
55105: ARRAY
55106: PPUSH
55107: LD_INT 30
55109: PUSH
55110: LD_INT 3
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: PPUSH
55117: NOP4
55121: AND
55122: PUSH
55123: NOP4
55127: PUSH
55128: NOP4
55132: ARRAY
55133: NOT
55134: AND
55135: IFFALSE 55800
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
55137: NOP4
55141: PUSH
55142: NOP4
55146: PPUSH
55147: NOP4
55151: PPUSH
55152: LD_INT 6
55154: PPUSH
55155: NOP4
55159: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
55160: NOP4
55164: PUSH
55165: LD_INT 0
55167: PUSH
55168: LD_INT 0
55170: PUSH
55171: LD_INT 0
55173: PUSH
55174: LD_INT 0
55176: PUSH
55177: EMPTY
55178: LIST
55179: LIST
55180: LIST
55181: LIST
55182: ST_TO_ADDR
// if sci >= 1 then
55183: NOP4
55187: PUSH
55188: LD_INT 1
55190: GREATEREQUAL
55191: IFFALSE 55213
// tmp := tmp diff sci [ 1 ] ;
55193: NOP4
55197: PUSH
55198: NOP4
55202: PUSH
55203: NOP4
55207: PUSH
55208: LD_INT 1
55210: ARRAY
55211: DIFF
55212: ST_TO_ADDR
// if tmp and not sci then
55213: NOP4
55217: PUSH
55218: NOP4
55222: NOT
55223: AND
55224: IFFALSE 55293
// begin sort := SortBySkill ( tmp , 4 ) ;
55226: NOP4
55230: PUSH
55231: NOP4
55235: PPUSH
55236: LD_INT 4
55238: PPUSH
55239: NOP4
55243: ST_TO_ADDR
// if sort then
55244: NOP4
55248: IFFALSE 55264
// p := sort [ 1 ] ;
55250: NOP4
55254: PUSH
55255: NOP4
55259: PUSH
55260: LD_INT 1
55262: ARRAY
55263: ST_TO_ADDR
// if p then
55264: NOP4
55268: IFFALSE 55293
// result := Replace ( result , 4 , p ) ;
55270: NOP4
55274: PUSH
55275: NOP4
55279: PPUSH
55280: LD_INT 4
55282: PPUSH
55283: NOP4
55287: PPUSH
55288: NOP4
55292: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
55293: NOP4
55297: PUSH
55298: NOP4
55302: PUSH
55303: NOP4
55307: DIFF
55308: ST_TO_ADDR
// if tmp and mech < 6 then
55309: NOP4
55313: PUSH
55314: NOP4
55318: PUSH
55319: LD_INT 6
55321: LESS
55322: AND
55323: IFFALSE 55505
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
55325: NOP4
55329: PUSH
55330: NOP4
55334: PUSH
55335: NOP4
55339: DIFF
55340: PPUSH
55341: LD_INT 3
55343: PPUSH
55344: NOP4
55348: ST_TO_ADDR
// p := [ ] ;
55349: NOP4
55353: PUSH
55354: EMPTY
55355: ST_TO_ADDR
// if sort then
55356: NOP4
55360: IFFALSE 55476
// for i = 1 to 6 - mech do
55362: NOP4
55366: PUSH
55367: DOUBLE
55368: LD_INT 1
55370: DEC
55371: ST_TO_ADDR
55372: LD_INT 6
55374: PUSH
55375: NOP4
55379: MINUS
55380: PUSH
55381: FOR_TO
55382: IFFALSE 55474
// begin if i = sort then
55384: NOP4
55388: PUSH
55389: NOP4
55393: EQUAL
55394: IFFALSE 55398
// break ;
55396: GO 55474
// if GetClass ( i ) = 3 then
55398: NOP4
55402: PPUSH
55403: NOP4
55407: PUSH
55408: LD_INT 3
55410: EQUAL
55411: IFFALSE 55415
// continue ;
55413: GO 55381
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55415: NOP4
55419: PUSH
55420: NOP4
55424: PPUSH
55425: NOP4
55429: PUSH
55430: LD_INT 1
55432: PLUS
55433: PPUSH
55434: NOP4
55438: PUSH
55439: NOP4
55443: ARRAY
55444: PPUSH
55445: NOP4
55449: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55450: NOP4
55454: PUSH
55455: NOP4
55459: PUSH
55460: NOP4
55464: PUSH
55465: NOP4
55469: ARRAY
55470: DIFF
55471: ST_TO_ADDR
// end ;
55472: GO 55381
55474: POP
55475: POP
// if p then
55476: NOP4
55480: IFFALSE 55505
// result := Replace ( result , 3 , p ) ;
55482: NOP4
55486: PUSH
55487: NOP4
55491: PPUSH
55492: LD_INT 3
55494: PPUSH
55495: NOP4
55499: PPUSH
55500: NOP4
55504: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
55505: NOP4
55509: PUSH
55510: NOP4
55514: PUSH
55515: NOP4
55519: DIFF
55520: ST_TO_ADDR
// if tmp and eng < 4 then
55521: NOP4
55525: PUSH
55526: NOP4
55530: PUSH
55531: LD_INT 4
55533: LESS
55534: AND
55535: IFFALSE 55725
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
55537: NOP4
55541: PUSH
55542: NOP4
55546: PUSH
55547: NOP4
55551: PUSH
55552: NOP4
55556: UNION
55557: DIFF
55558: PPUSH
55559: LD_INT 2
55561: PPUSH
55562: NOP4
55566: ST_TO_ADDR
// p := [ ] ;
55567: NOP4
55571: PUSH
55572: EMPTY
55573: ST_TO_ADDR
// if sort then
55574: NOP4
55578: IFFALSE 55694
// for i = 1 to 4 - eng do
55580: NOP4
55584: PUSH
55585: DOUBLE
55586: LD_INT 1
55588: DEC
55589: ST_TO_ADDR
55590: LD_INT 4
55592: PUSH
55593: NOP4
55597: MINUS
55598: PUSH
55599: FOR_TO
55600: IFFALSE 55692
// begin if i = sort then
55602: NOP4
55606: PUSH
55607: NOP4
55611: EQUAL
55612: IFFALSE 55616
// break ;
55614: GO 55692
// if GetClass ( i ) = 2 then
55616: NOP4
55620: PPUSH
55621: NOP4
55625: PUSH
55626: LD_INT 2
55628: EQUAL
55629: IFFALSE 55633
// continue ;
55631: GO 55599
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55633: NOP4
55637: PUSH
55638: NOP4
55642: PPUSH
55643: NOP4
55647: PUSH
55648: LD_INT 1
55650: PLUS
55651: PPUSH
55652: NOP4
55656: PUSH
55657: NOP4
55661: ARRAY
55662: PPUSH
55663: NOP4
55667: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55668: NOP4
55672: PUSH
55673: NOP4
55677: PUSH
55678: NOP4
55682: PUSH
55683: NOP4
55687: ARRAY
55688: DIFF
55689: ST_TO_ADDR
// end ;
55690: GO 55599
55692: POP
55693: POP
// if p then
55694: NOP4
55698: IFFALSE 55723
// result := Replace ( result , 2 , p ) ;
55700: NOP4
55704: PUSH
55705: NOP4
55709: PPUSH
55710: LD_INT 2
55712: PPUSH
55713: NOP4
55717: PPUSH
55718: NOP4
55722: ST_TO_ADDR
// end else
55723: GO 55769
// for i = eng downto 5 do
55725: NOP4
55729: PUSH
55730: DOUBLE
55731: NOP4
55735: INC
55736: ST_TO_ADDR
55737: LD_INT 5
55739: PUSH
55740: FOR_DOWNTO
55741: IFFALSE 55767
// tmp := tmp union eng [ i ] ;
55743: NOP4
55747: PUSH
55748: NOP4
55752: PUSH
55753: NOP4
55757: PUSH
55758: NOP4
55762: ARRAY
55763: UNION
55764: ST_TO_ADDR
55765: GO 55740
55767: POP
55768: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
55769: NOP4
55773: PUSH
55774: NOP4
55778: PPUSH
55779: LD_INT 1
55781: PPUSH
55782: NOP4
55786: PUSH
55787: NOP4
55791: DIFF
55792: PPUSH
55793: NOP4
55797: ST_TO_ADDR
// exit ;
55798: GO 55800
// end ; end ;
55800: LD_VAR 0 2
55804: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
55805: LD_INT 0
55807: PPUSH
55808: PPUSH
55809: PPUSH
// if not mc_bases then
55810: NOP4
55814: NOT
55815: IFFALSE 55819
// exit ;
55817: GO 55925
// for i = 1 to mc_bases do
55819: NOP4
55823: PUSH
55824: DOUBLE
55825: LD_INT 1
55827: DEC
55828: ST_TO_ADDR
55829: NOP4
55833: PUSH
55834: FOR_TO
55835: IFFALSE 55916
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55837: NOP4
55841: PUSH
55842: NOP4
55846: PUSH
55847: NOP4
55851: ARRAY
55852: PPUSH
55853: LD_INT 21
55855: PUSH
55856: LD_INT 3
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: PUSH
55863: LD_INT 3
55865: PUSH
55866: LD_INT 24
55868: PUSH
55869: LD_INT 1000
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: PUSH
55876: EMPTY
55877: LIST
55878: LIST
55879: PUSH
55880: EMPTY
55881: LIST
55882: LIST
55883: PPUSH
55884: NOP4
55888: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
55889: NOP4
55893: PUSH
55894: NOP4
55898: PPUSH
55899: NOP4
55903: PPUSH
55904: NOP4
55908: PPUSH
55909: NOP4
55913: ST_TO_ADDR
// end ;
55914: GO 55834
55916: POP
55917: POP
// RaiseSailEvent ( 101 ) ;
55918: LD_INT 101
55920: PPUSH
55921: NOP4
// end ;
55925: LD_VAR 0 1
55929: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
55930: LD_INT 0
55932: PPUSH
55933: PPUSH
55934: PPUSH
55935: PPUSH
55936: PPUSH
55937: PPUSH
55938: PPUSH
// if not mc_bases then
55939: NOP4
55943: NOT
55944: IFFALSE 55948
// exit ;
55946: GO 56510
// for i = 1 to mc_bases do
55948: NOP4
55952: PUSH
55953: DOUBLE
55954: LD_INT 1
55956: DEC
55957: ST_TO_ADDR
55958: NOP4
55962: PUSH
55963: FOR_TO
55964: IFFALSE 56501
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
55966: NOP4
55970: PUSH
55971: NOP4
55975: PUSH
55976: NOP4
55980: ARRAY
55981: PUSH
55982: NOP4
55986: PUSH
55987: NOP4
55991: ARRAY
55992: UNION
55993: PPUSH
55994: LD_INT 21
55996: PUSH
55997: LD_INT 1
55999: PUSH
56000: EMPTY
56001: LIST
56002: LIST
56003: PUSH
56004: LD_INT 1
56006: PUSH
56007: LD_INT 3
56009: PUSH
56010: LD_INT 54
56012: PUSH
56013: EMPTY
56014: LIST
56015: PUSH
56016: EMPTY
56017: LIST
56018: LIST
56019: PUSH
56020: LD_INT 3
56022: PUSH
56023: LD_INT 24
56025: PUSH
56026: LD_INT 1000
56028: PUSH
56029: EMPTY
56030: LIST
56031: LIST
56032: PUSH
56033: EMPTY
56034: LIST
56035: LIST
56036: PUSH
56037: EMPTY
56038: LIST
56039: LIST
56040: LIST
56041: PUSH
56042: EMPTY
56043: LIST
56044: LIST
56045: PPUSH
56046: NOP4
56050: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
56051: NOP4
56055: PUSH
56056: NOP4
56060: PUSH
56061: NOP4
56065: ARRAY
56066: PPUSH
56067: LD_INT 21
56069: PUSH
56070: LD_INT 1
56072: PUSH
56073: EMPTY
56074: LIST
56075: LIST
56076: PUSH
56077: LD_INT 1
56079: PUSH
56080: LD_INT 3
56082: PUSH
56083: LD_INT 54
56085: PUSH
56086: EMPTY
56087: LIST
56088: PUSH
56089: EMPTY
56090: LIST
56091: LIST
56092: PUSH
56093: LD_INT 3
56095: PUSH
56096: LD_INT 24
56098: PUSH
56099: LD_INT 250
56101: PUSH
56102: EMPTY
56103: LIST
56104: LIST
56105: PUSH
56106: EMPTY
56107: LIST
56108: LIST
56109: PUSH
56110: EMPTY
56111: LIST
56112: LIST
56113: LIST
56114: PUSH
56115: EMPTY
56116: LIST
56117: LIST
56118: PPUSH
56119: NOP4
56123: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
56124: NOP4
56128: PUSH
56129: NOP4
56133: PUSH
56134: NOP4
56138: DIFF
56139: ST_TO_ADDR
// if not need_heal_1 then
56140: NOP4
56144: NOT
56145: IFFALSE 56178
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
56147: NOP4
56151: PUSH
56152: NOP4
56156: PPUSH
56157: NOP4
56161: PUSH
56162: LD_INT 1
56164: PUSH
56165: EMPTY
56166: LIST
56167: LIST
56168: PPUSH
56169: EMPTY
56170: PPUSH
56171: NOP4
56175: ST_TO_ADDR
56176: GO 56248
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
56178: NOP4
56182: PUSH
56183: NOP4
56187: PPUSH
56188: NOP4
56192: PUSH
56193: LD_INT 1
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: PPUSH
56200: NOP4
56204: PUSH
56205: NOP4
56209: ARRAY
56210: PUSH
56211: LD_INT 1
56213: ARRAY
56214: PPUSH
56215: LD_INT 3
56217: PUSH
56218: LD_INT 24
56220: PUSH
56221: LD_INT 1000
56223: PUSH
56224: EMPTY
56225: LIST
56226: LIST
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: PPUSH
56232: NOP4
56236: PUSH
56237: NOP4
56241: UNION
56242: PPUSH
56243: NOP4
56247: ST_TO_ADDR
// if not need_heal_2 then
56248: NOP4
56252: NOT
56253: IFFALSE 56286
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
56255: NOP4
56259: PUSH
56260: NOP4
56264: PPUSH
56265: NOP4
56269: PUSH
56270: LD_INT 2
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: PPUSH
56277: EMPTY
56278: PPUSH
56279: NOP4
56283: ST_TO_ADDR
56284: GO 56318
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
56286: NOP4
56290: PUSH
56291: NOP4
56295: PPUSH
56296: NOP4
56300: PUSH
56301: LD_INT 2
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: PPUSH
56308: NOP4
56312: PPUSH
56313: NOP4
56317: ST_TO_ADDR
// if need_heal_2 then
56318: NOP4
56322: IFFALSE 56483
// for j in need_heal_2 do
56324: NOP4
56328: PUSH
56329: NOP4
56333: PUSH
56334: FOR_IN
56335: IFFALSE 56481
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56337: NOP4
56341: PUSH
56342: NOP4
56346: PUSH
56347: NOP4
56351: ARRAY
56352: PPUSH
56353: LD_INT 2
56355: PUSH
56356: LD_INT 30
56358: PUSH
56359: LD_INT 6
56361: PUSH
56362: EMPTY
56363: LIST
56364: LIST
56365: PUSH
56366: LD_INT 30
56368: PUSH
56369: LD_INT 7
56371: PUSH
56372: EMPTY
56373: LIST
56374: LIST
56375: PUSH
56376: LD_INT 30
56378: PUSH
56379: LD_INT 8
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: PUSH
56386: LD_INT 30
56388: PUSH
56389: LD_INT 0
56391: PUSH
56392: EMPTY
56393: LIST
56394: LIST
56395: PUSH
56396: LD_INT 30
56398: PUSH
56399: LD_INT 1
56401: PUSH
56402: EMPTY
56403: LIST
56404: LIST
56405: PUSH
56406: EMPTY
56407: LIST
56408: LIST
56409: LIST
56410: LIST
56411: LIST
56412: LIST
56413: PPUSH
56414: NOP4
56418: ST_TO_ADDR
// if tmp then
56419: NOP4
56423: IFFALSE 56479
// begin k := NearestUnitToUnit ( tmp , j ) ;
56425: NOP4
56429: PUSH
56430: NOP4
56434: PPUSH
56435: NOP4
56439: PPUSH
56440: NOP4
56444: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
56445: NOP4
56449: PPUSH
56450: NOP4
56454: PPUSH
56455: NOP4
56459: PUSH
56460: LD_INT 5
56462: GREATER
56463: IFFALSE 56479
// ComMoveToNearbyEntrance ( j , k ) ;
56465: NOP4
56469: PPUSH
56470: NOP4
56474: PPUSH
56475: NOP4
// end ; end ;
56479: GO 56334
56481: POP
56482: POP
// if not need_heal_1 and not need_heal_2 then
56483: NOP4
56487: NOT
56488: PUSH
56489: NOP4
56493: NOT
56494: AND
56495: IFFALSE 56499
// continue ;
56497: GO 55963
// end ;
56499: GO 55963
56501: POP
56502: POP
// RaiseSailEvent ( 102 ) ;
56503: LD_INT 102
56505: PPUSH
56506: NOP4
// end ;
56510: LD_VAR 0 1
56514: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
56515: LD_INT 0
56517: PPUSH
56518: PPUSH
56519: PPUSH
56520: PPUSH
56521: PPUSH
56522: PPUSH
56523: PPUSH
56524: PPUSH
// if not mc_bases then
56525: NOP4
56529: NOT
56530: IFFALSE 56534
// exit ;
56532: GO 57395
// for i = 1 to mc_bases do
56534: NOP4
56538: PUSH
56539: DOUBLE
56540: LD_INT 1
56542: DEC
56543: ST_TO_ADDR
56544: NOP4
56548: PUSH
56549: FOR_TO
56550: IFFALSE 57393
// begin if not mc_building_need_repair [ i ] then
56552: NOP4
56556: PUSH
56557: NOP4
56561: ARRAY
56562: NOT
56563: IFFALSE 56750
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
56565: NOP4
56569: PUSH
56570: NOP4
56574: PUSH
56575: NOP4
56579: ARRAY
56580: PPUSH
56581: LD_INT 3
56583: PUSH
56584: LD_INT 24
56586: PUSH
56587: LD_INT 1000
56589: PUSH
56590: EMPTY
56591: LIST
56592: LIST
56593: PUSH
56594: EMPTY
56595: LIST
56596: LIST
56597: PUSH
56598: LD_INT 2
56600: PUSH
56601: LD_INT 34
56603: PUSH
56604: LD_INT 13
56606: PUSH
56607: EMPTY
56608: LIST
56609: LIST
56610: PUSH
56611: LD_INT 34
56613: PUSH
56614: LD_INT 52
56616: PUSH
56617: EMPTY
56618: LIST
56619: LIST
56620: PUSH
56621: LD_INT 34
56623: PUSH
56624: NOP4
56628: PUSH
56629: EMPTY
56630: LIST
56631: LIST
56632: PUSH
56633: EMPTY
56634: LIST
56635: LIST
56636: LIST
56637: LIST
56638: PUSH
56639: EMPTY
56640: LIST
56641: LIST
56642: PPUSH
56643: NOP4
56647: ST_TO_ADDR
// if cranes then
56648: NOP4
56652: IFFALSE 56714
// for j in cranes do
56654: NOP4
56658: PUSH
56659: NOP4
56663: PUSH
56664: FOR_IN
56665: IFFALSE 56712
// if not IsInArea ( j , mc_parking [ i ] ) then
56667: NOP4
56671: PPUSH
56672: NOP4
56676: PUSH
56677: NOP4
56681: ARRAY
56682: PPUSH
56683: NOP4
56687: NOT
56688: IFFALSE 56710
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56690: NOP4
56694: PPUSH
56695: NOP4
56699: PUSH
56700: NOP4
56704: ARRAY
56705: PPUSH
56706: NOP4
56710: GO 56664
56712: POP
56713: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56714: NOP4
56718: PUSH
56719: NOP4
56723: PPUSH
56724: NOP4
56728: PPUSH
56729: EMPTY
56730: PPUSH
56731: NOP4
56735: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
56736: NOP4
56740: PPUSH
56741: LD_INT 101
56743: PPUSH
56744: NOP4
// continue ;
56748: GO 56549
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
56750: NOP4
56754: PUSH
56755: NOP4
56759: PPUSH
56760: NOP4
56764: PPUSH
56765: EMPTY
56766: PPUSH
56767: NOP4
56771: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
56772: NOP4
56776: PPUSH
56777: LD_INT 103
56779: PPUSH
56780: NOP4
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
56784: NOP4
56788: PUSH
56789: NOP4
56793: PUSH
56794: NOP4
56798: ARRAY
56799: PUSH
56800: NOP4
56804: PUSH
56805: NOP4
56809: ARRAY
56810: UNION
56811: PPUSH
56812: LD_INT 2
56814: PUSH
56815: LD_INT 25
56817: PUSH
56818: LD_INT 2
56820: PUSH
56821: EMPTY
56822: LIST
56823: LIST
56824: PUSH
56825: LD_INT 25
56827: PUSH
56828: LD_INT 16
56830: PUSH
56831: EMPTY
56832: LIST
56833: LIST
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: LIST
56839: PUSH
56840: EMPTY
56841: LIST
56842: PPUSH
56843: NOP4
56847: PUSH
56848: NOP4
56852: PUSH
56853: NOP4
56857: ARRAY
56858: PUSH
56859: LD_INT 1
56861: ARRAY
56862: PUSH
56863: NOP4
56867: PUSH
56868: NOP4
56872: ARRAY
56873: PUSH
56874: LD_INT 2
56876: ARRAY
56877: UNION
56878: DIFF
56879: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
56880: NOP4
56884: PUSH
56885: NOP4
56889: PUSH
56890: NOP4
56894: ARRAY
56895: PPUSH
56896: LD_INT 2
56898: PUSH
56899: LD_INT 34
56901: PUSH
56902: LD_INT 13
56904: PUSH
56905: EMPTY
56906: LIST
56907: LIST
56908: PUSH
56909: LD_INT 34
56911: PUSH
56912: LD_INT 52
56914: PUSH
56915: EMPTY
56916: LIST
56917: LIST
56918: PUSH
56919: LD_INT 34
56921: PUSH
56922: NOP4
56926: PUSH
56927: EMPTY
56928: LIST
56929: LIST
56930: PUSH
56931: EMPTY
56932: LIST
56933: LIST
56934: LIST
56935: LIST
56936: PPUSH
56937: NOP4
56941: ST_TO_ADDR
// if cranes then
56942: NOP4
56946: IFFALSE 57082
// begin for j in cranes do
56948: NOP4
56952: PUSH
56953: NOP4
56957: PUSH
56958: FOR_IN
56959: IFFALSE 57080
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
56961: NOP4
56965: PPUSH
56966: NOP4
56970: PUSH
56971: LD_INT 1000
56973: EQUAL
56974: PUSH
56975: NOP4
56979: PPUSH
56980: NOP4
56984: NOT
56985: AND
56986: IFFALSE 57020
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
56988: NOP4
56992: PPUSH
56993: NOP4
56997: PUSH
56998: NOP4
57002: ARRAY
57003: PPUSH
57004: NOP4
57008: PPUSH
57009: NOP4
57013: PPUSH
57014: NOP4
57018: GO 57078
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
57020: NOP4
57024: PPUSH
57025: NOP4
57029: PUSH
57030: LD_INT 500
57032: LESS
57033: PUSH
57034: NOP4
57038: PPUSH
57039: NOP4
57043: PUSH
57044: NOP4
57048: ARRAY
57049: PPUSH
57050: NOP4
57054: NOT
57055: AND
57056: IFFALSE 57078
// ComMoveToArea ( j , mc_parking [ i ] ) ;
57058: NOP4
57062: PPUSH
57063: NOP4
57067: PUSH
57068: NOP4
57072: ARRAY
57073: PPUSH
57074: NOP4
// end ;
57078: GO 56958
57080: POP
57081: POP
// end ; if tmp > 3 then
57082: NOP4
57086: PUSH
57087: LD_INT 3
57089: GREATER
57090: IFFALSE 57110
// tmp := ShrinkArray ( tmp , 4 ) ;
57092: NOP4
57096: PUSH
57097: NOP4
57101: PPUSH
57102: LD_INT 4
57104: PPUSH
57105: NOP4
57109: ST_TO_ADDR
// if not tmp then
57110: NOP4
57114: NOT
57115: IFFALSE 57119
// continue ;
57117: GO 56549
// for j in tmp do
57119: NOP4
57123: PUSH
57124: NOP4
57128: PUSH
57129: FOR_IN
57130: IFFALSE 57389
// begin if IsInUnit ( j ) then
57132: NOP4
57136: PPUSH
57137: NOP4
57141: IFFALSE 57152
// ComExitBuilding ( j ) ;
57143: NOP4
57147: PPUSH
57148: NOP4
// if not j in mc_building_repairs [ i ] then
57152: NOP4
57156: PUSH
57157: NOP4
57161: PUSH
57162: NOP4
57166: ARRAY
57167: IN
57168: NOT
57169: IFFALSE 57227
// begin SetTag ( j , 101 ) ;
57171: NOP4
57175: PPUSH
57176: LD_INT 101
57178: PPUSH
57179: NOP4
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
57183: NOP4
57187: PUSH
57188: NOP4
57192: PPUSH
57193: NOP4
57197: PUSH
57198: NOP4
57202: PUSH
57203: NOP4
57207: ARRAY
57208: PUSH
57209: LD_INT 1
57211: PLUS
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: PPUSH
57217: NOP4
57221: PPUSH
57222: NOP4
57226: ST_TO_ADDR
// end ; wait ( 1 ) ;
57227: LD_INT 1
57229: PPUSH
57230: NOP4
// to_repair_tmp := mc_building_need_repair [ i ] ;
57234: NOP4
57238: PUSH
57239: NOP4
57243: PUSH
57244: NOP4
57248: ARRAY
57249: ST_TO_ADDR
// if mc_scan [ i ] then
57250: NOP4
57254: PUSH
57255: NOP4
57259: ARRAY
57260: IFFALSE 57322
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
57262: NOP4
57266: PUSH
57267: NOP4
57271: PUSH
57272: NOP4
57276: ARRAY
57277: PPUSH
57278: LD_INT 3
57280: PUSH
57281: LD_INT 30
57283: PUSH
57284: LD_INT 32
57286: PUSH
57287: EMPTY
57288: LIST
57289: LIST
57290: PUSH
57291: LD_INT 30
57293: PUSH
57294: LD_INT 33
57296: PUSH
57297: EMPTY
57298: LIST
57299: LIST
57300: PUSH
57301: LD_INT 30
57303: PUSH
57304: LD_INT 31
57306: PUSH
57307: EMPTY
57308: LIST
57309: LIST
57310: PUSH
57311: EMPTY
57312: LIST
57313: LIST
57314: LIST
57315: LIST
57316: PPUSH
57317: NOP4
57321: ST_TO_ADDR
// if not to_repair_tmp then
57322: NOP4
57326: NOT
57327: IFFALSE 57331
// continue ;
57329: GO 57129
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
57331: NOP4
57335: PUSH
57336: NOP4
57340: PPUSH
57341: NOP4
57345: PPUSH
57346: NOP4
57350: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
57351: NOP4
57355: PPUSH
57356: LD_INT 16
57358: PPUSH
57359: NOP4
57363: PUSH
57364: LD_INT 4
57366: ARRAY
57367: PUSH
57368: LD_INT 10
57370: LESS
57371: IFFALSE 57387
// ComRepairBuilding ( j , to_repair ) ;
57373: NOP4
57377: PPUSH
57378: NOP4
57382: PPUSH
57383: NOP4
// end ;
57387: GO 57129
57389: POP
57390: POP
// end ;
57391: GO 56549
57393: POP
57394: POP
// end ;
57395: LD_VAR 0 1
57399: RET
// export function MC_Heal ; var i , j , tmp ; begin
57400: LD_INT 0
57402: PPUSH
57403: PPUSH
57404: PPUSH
57405: PPUSH
// if not mc_bases then
57406: NOP4
57410: NOT
57411: IFFALSE 57415
// exit ;
57413: GO 57817
// for i = 1 to mc_bases do
57415: NOP4
57419: PUSH
57420: DOUBLE
57421: LD_INT 1
57423: DEC
57424: ST_TO_ADDR
57425: NOP4
57429: PUSH
57430: FOR_TO
57431: IFFALSE 57815
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
57433: NOP4
57437: PUSH
57438: NOP4
57442: ARRAY
57443: PUSH
57444: LD_INT 1
57446: ARRAY
57447: NOT
57448: PUSH
57449: NOP4
57453: PUSH
57454: NOP4
57458: ARRAY
57459: PUSH
57460: LD_INT 2
57462: ARRAY
57463: NOT
57464: AND
57465: IFFALSE 57503
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
57467: NOP4
57471: PUSH
57472: NOP4
57476: PPUSH
57477: NOP4
57481: PPUSH
57482: EMPTY
57483: PPUSH
57484: NOP4
57488: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
57489: NOP4
57493: PPUSH
57494: LD_INT 102
57496: PPUSH
57497: NOP4
// continue ;
57501: GO 57430
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57503: NOP4
57507: PUSH
57508: NOP4
57512: PUSH
57513: NOP4
57517: ARRAY
57518: PPUSH
57519: LD_INT 25
57521: PUSH
57522: LD_INT 4
57524: PUSH
57525: EMPTY
57526: LIST
57527: LIST
57528: PPUSH
57529: NOP4
57533: ST_TO_ADDR
// if not tmp then
57534: NOP4
57538: NOT
57539: IFFALSE 57543
// continue ;
57541: GO 57430
// if mc_taming [ i ] then
57543: NOP4
57547: PUSH
57548: NOP4
57552: ARRAY
57553: IFFALSE 57577
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57555: NOP4
57559: PUSH
57560: NOP4
57564: PPUSH
57565: NOP4
57569: PPUSH
57570: EMPTY
57571: PPUSH
57572: NOP4
57576: ST_TO_ADDR
// for j in tmp do
57577: NOP4
57581: PUSH
57582: NOP4
57586: PUSH
57587: FOR_IN
57588: IFFALSE 57811
// begin if IsInUnit ( j ) then
57590: NOP4
57594: PPUSH
57595: NOP4
57599: IFFALSE 57610
// ComExitBuilding ( j ) ;
57601: NOP4
57605: PPUSH
57606: NOP4
// if not j in mc_healers [ i ] then
57610: NOP4
57614: PUSH
57615: NOP4
57619: PUSH
57620: NOP4
57624: ARRAY
57625: IN
57626: NOT
57627: IFFALSE 57673
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
57629: NOP4
57633: PUSH
57634: NOP4
57638: PPUSH
57639: NOP4
57643: PUSH
57644: NOP4
57648: PUSH
57649: NOP4
57653: ARRAY
57654: PUSH
57655: LD_INT 1
57657: PLUS
57658: PUSH
57659: EMPTY
57660: LIST
57661: LIST
57662: PPUSH
57663: NOP4
57667: PPUSH
57668: NOP4
57672: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
57673: NOP4
57677: PPUSH
57678: NOP4
57682: PUSH
57683: LD_INT 102
57685: NONEQUAL
57686: IFFALSE 57700
// SetTag ( j , 102 ) ;
57688: NOP4
57692: PPUSH
57693: LD_INT 102
57695: PPUSH
57696: NOP4
// Wait ( 3 ) ;
57700: LD_INT 3
57702: PPUSH
57703: NOP4
// if mc_need_heal [ i ] [ 1 ] then
57707: NOP4
57711: PUSH
57712: NOP4
57716: ARRAY
57717: PUSH
57718: LD_INT 1
57720: ARRAY
57721: IFFALSE 57753
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
57723: NOP4
57727: PPUSH
57728: NOP4
57732: PUSH
57733: NOP4
57737: ARRAY
57738: PUSH
57739: LD_INT 1
57741: ARRAY
57742: PUSH
57743: LD_INT 1
57745: ARRAY
57746: PPUSH
57747: NOP4
57751: GO 57809
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
57753: NOP4
57757: PPUSH
57758: NOP4
57762: NOT
57763: PUSH
57764: NOP4
57768: PUSH
57769: NOP4
57773: ARRAY
57774: PUSH
57775: LD_INT 2
57777: ARRAY
57778: AND
57779: IFFALSE 57809
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
57781: NOP4
57785: PPUSH
57786: NOP4
57790: PUSH
57791: NOP4
57795: ARRAY
57796: PUSH
57797: LD_INT 2
57799: ARRAY
57800: PUSH
57801: LD_INT 1
57803: ARRAY
57804: PPUSH
57805: NOP4
// end ;
57809: GO 57587
57811: POP
57812: POP
// end ;
57813: GO 57430
57815: POP
57816: POP
// end ;
57817: LD_VAR 0 1
57821: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
57822: LD_INT 0
57824: PPUSH
57825: PPUSH
57826: PPUSH
57827: PPUSH
57828: PPUSH
// if not mc_bases then
57829: NOP4
57833: NOT
57834: IFFALSE 57838
// exit ;
57836: GO 59009
// for i = 1 to mc_bases do
57838: NOP4
57842: PUSH
57843: DOUBLE
57844: LD_INT 1
57846: DEC
57847: ST_TO_ADDR
57848: NOP4
57852: PUSH
57853: FOR_TO
57854: IFFALSE 59007
// begin if mc_scan [ i ] then
57856: NOP4
57860: PUSH
57861: NOP4
57865: ARRAY
57866: IFFALSE 57870
// continue ;
57868: GO 57853
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
57870: NOP4
57874: PUSH
57875: NOP4
57879: ARRAY
57880: NOT
57881: PUSH
57882: NOP4
57886: PUSH
57887: NOP4
57891: ARRAY
57892: NOT
57893: AND
57894: PUSH
57895: NOP4
57899: PUSH
57900: NOP4
57904: ARRAY
57905: AND
57906: IFFALSE 57944
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
57908: NOP4
57912: PUSH
57913: NOP4
57917: PPUSH
57918: NOP4
57922: PPUSH
57923: EMPTY
57924: PPUSH
57925: NOP4
57929: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
57930: NOP4
57934: PPUSH
57935: LD_INT 103
57937: PPUSH
57938: NOP4
// continue ;
57942: GO 57853
// end ; if mc_construct_list [ i ] then
57944: NOP4
57948: PUSH
57949: NOP4
57953: ARRAY
57954: IFFALSE 58174
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
57956: NOP4
57960: PUSH
57961: NOP4
57965: PUSH
57966: NOP4
57970: ARRAY
57971: PPUSH
57972: LD_INT 25
57974: PUSH
57975: LD_INT 2
57977: PUSH
57978: EMPTY
57979: LIST
57980: LIST
57981: PPUSH
57982: NOP4
57986: PUSH
57987: NOP4
57991: PUSH
57992: NOP4
57996: ARRAY
57997: DIFF
57998: ST_TO_ADDR
// if not tmp then
57999: NOP4
58003: NOT
58004: IFFALSE 58008
// continue ;
58006: GO 57853
// for j in tmp do
58008: NOP4
58012: PUSH
58013: NOP4
58017: PUSH
58018: FOR_IN
58019: IFFALSE 58170
// begin if not mc_builders [ i ] then
58021: NOP4
58025: PUSH
58026: NOP4
58030: ARRAY
58031: NOT
58032: IFFALSE 58090
// begin SetTag ( j , 103 ) ;
58034: NOP4
58038: PPUSH
58039: LD_INT 103
58041: PPUSH
58042: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58046: NOP4
58050: PUSH
58051: NOP4
58055: PPUSH
58056: NOP4
58060: PUSH
58061: NOP4
58065: PUSH
58066: NOP4
58070: ARRAY
58071: PUSH
58072: LD_INT 1
58074: PLUS
58075: PUSH
58076: EMPTY
58077: LIST
58078: LIST
58079: PPUSH
58080: NOP4
58084: PPUSH
58085: NOP4
58089: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58090: NOP4
58094: PPUSH
58095: NOP4
58099: IFFALSE 58110
// ComExitBuilding ( j ) ;
58101: NOP4
58105: PPUSH
58106: NOP4
// wait ( 3 ) ;
58110: LD_INT 3
58112: PPUSH
58113: NOP4
// if not mc_construct_list [ i ] then
58117: NOP4
58121: PUSH
58122: NOP4
58126: ARRAY
58127: NOT
58128: IFFALSE 58132
// break ;
58130: GO 58170
// if not HasTask ( j ) then
58132: NOP4
58136: PPUSH
58137: NOP4
58141: NOT
58142: IFFALSE 58168
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
58144: NOP4
58148: PPUSH
58149: NOP4
58153: PUSH
58154: NOP4
58158: ARRAY
58159: PUSH
58160: LD_INT 1
58162: ARRAY
58163: PPUSH
58164: NOP4
// end ;
58168: GO 58018
58170: POP
58171: POP
// end else
58172: GO 59005
// if mc_build_list [ i ] then
58174: NOP4
58178: PUSH
58179: NOP4
58183: ARRAY
58184: IFFALSE 59005
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58186: NOP4
58190: PUSH
58191: NOP4
58195: PUSH
58196: NOP4
58200: ARRAY
58201: PPUSH
58202: LD_INT 2
58204: PUSH
58205: LD_INT 30
58207: PUSH
58208: LD_INT 0
58210: PUSH
58211: EMPTY
58212: LIST
58213: LIST
58214: PUSH
58215: LD_INT 30
58217: PUSH
58218: LD_INT 1
58220: PUSH
58221: EMPTY
58222: LIST
58223: LIST
58224: PUSH
58225: EMPTY
58226: LIST
58227: LIST
58228: LIST
58229: PPUSH
58230: NOP4
58234: ST_TO_ADDR
// if depot then
58235: NOP4
58239: IFFALSE 58257
// depot := depot [ 1 ] else
58241: NOP4
58245: PUSH
58246: NOP4
58250: PUSH
58251: LD_INT 1
58253: ARRAY
58254: ST_TO_ADDR
58255: GO 58265
// depot := 0 ;
58257: NOP4
58261: PUSH
58262: LD_INT 0
58264: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
58265: NOP4
58269: PUSH
58270: NOP4
58274: ARRAY
58275: PUSH
58276: LD_INT 1
58278: ARRAY
58279: PUSH
58280: LD_INT 1
58282: ARRAY
58283: PPUSH
58284: NOP4
58288: PUSH
58289: NOP4
58293: PUSH
58294: NOP4
58298: ARRAY
58299: PPUSH
58300: LD_INT 2
58302: PUSH
58303: LD_INT 30
58305: PUSH
58306: LD_INT 2
58308: PUSH
58309: EMPTY
58310: LIST
58311: LIST
58312: PUSH
58313: LD_INT 30
58315: PUSH
58316: LD_INT 3
58318: PUSH
58319: EMPTY
58320: LIST
58321: LIST
58322: PUSH
58323: EMPTY
58324: LIST
58325: LIST
58326: LIST
58327: PPUSH
58328: NOP4
58332: NOT
58333: AND
58334: IFFALSE 58439
// begin for j = 1 to mc_build_list [ i ] do
58336: NOP4
58340: PUSH
58341: DOUBLE
58342: LD_INT 1
58344: DEC
58345: ST_TO_ADDR
58346: NOP4
58350: PUSH
58351: NOP4
58355: ARRAY
58356: PUSH
58357: FOR_TO
58358: IFFALSE 58437
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
58360: NOP4
58364: PUSH
58365: NOP4
58369: ARRAY
58370: PUSH
58371: NOP4
58375: ARRAY
58376: PUSH
58377: LD_INT 1
58379: ARRAY
58380: PUSH
58381: LD_INT 2
58383: EQUAL
58384: IFFALSE 58435
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
58386: NOP4
58390: PUSH
58391: NOP4
58395: PPUSH
58396: NOP4
58400: PPUSH
58401: NOP4
58405: PUSH
58406: NOP4
58410: ARRAY
58411: PPUSH
58412: NOP4
58416: PPUSH
58417: LD_INT 1
58419: PPUSH
58420: LD_INT 0
58422: PPUSH
58423: NOP4
58427: PPUSH
58428: NOP4
58432: ST_TO_ADDR
// break ;
58433: GO 58437
// end ;
58435: GO 58357
58437: POP
58438: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
58439: NOP4
58443: PUSH
58444: NOP4
58448: ARRAY
58449: PUSH
58450: LD_INT 1
58452: ARRAY
58453: PUSH
58454: LD_INT 1
58456: ARRAY
58457: PUSH
58458: LD_INT 0
58460: EQUAL
58461: PUSH
58462: NOP4
58466: PUSH
58467: NOP4
58471: PPUSH
58472: NOP4
58476: PUSH
58477: NOP4
58481: ARRAY
58482: PUSH
58483: LD_INT 1
58485: ARRAY
58486: PUSH
58487: LD_INT 1
58489: ARRAY
58490: PPUSH
58491: NOP4
58495: PUSH
58496: NOP4
58500: ARRAY
58501: PUSH
58502: LD_INT 1
58504: ARRAY
58505: PUSH
58506: LD_INT 2
58508: ARRAY
58509: PPUSH
58510: NOP4
58514: PUSH
58515: NOP4
58519: ARRAY
58520: PUSH
58521: LD_INT 1
58523: ARRAY
58524: PUSH
58525: LD_INT 3
58527: ARRAY
58528: PPUSH
58529: NOP4
58533: PUSH
58534: NOP4
58538: ARRAY
58539: PUSH
58540: LD_INT 1
58542: ARRAY
58543: PUSH
58544: LD_INT 4
58546: ARRAY
58547: PPUSH
58548: NOP4
58552: AND
58553: OR
58554: IFFALSE 58835
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58556: NOP4
58560: PUSH
58561: NOP4
58565: PUSH
58566: NOP4
58570: ARRAY
58571: PPUSH
58572: LD_INT 25
58574: PUSH
58575: LD_INT 2
58577: PUSH
58578: EMPTY
58579: LIST
58580: LIST
58581: PPUSH
58582: NOP4
58586: PUSH
58587: NOP4
58591: PUSH
58592: NOP4
58596: ARRAY
58597: DIFF
58598: ST_TO_ADDR
// if not tmp then
58599: NOP4
58603: NOT
58604: IFFALSE 58608
// continue ;
58606: GO 57853
// for j in tmp do
58608: NOP4
58612: PUSH
58613: NOP4
58617: PUSH
58618: FOR_IN
58619: IFFALSE 58831
// begin if not mc_builders [ i ] then
58621: NOP4
58625: PUSH
58626: NOP4
58630: ARRAY
58631: NOT
58632: IFFALSE 58690
// begin SetTag ( j , 103 ) ;
58634: NOP4
58638: PPUSH
58639: LD_INT 103
58641: PPUSH
58642: NOP4
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58646: NOP4
58650: PUSH
58651: NOP4
58655: PPUSH
58656: NOP4
58660: PUSH
58661: NOP4
58665: PUSH
58666: NOP4
58670: ARRAY
58671: PUSH
58672: LD_INT 1
58674: PLUS
58675: PUSH
58676: EMPTY
58677: LIST
58678: LIST
58679: PPUSH
58680: NOP4
58684: PPUSH
58685: NOP4
58689: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58690: NOP4
58694: PPUSH
58695: NOP4
58699: IFFALSE 58710
// ComExitBuilding ( j ) ;
58701: NOP4
58705: PPUSH
58706: NOP4
// wait ( 3 ) ;
58710: LD_INT 3
58712: PPUSH
58713: NOP4
// if not mc_build_list [ i ] then
58717: NOP4
58721: PUSH
58722: NOP4
58726: ARRAY
58727: NOT
58728: IFFALSE 58732
// break ;
58730: GO 58831
// if not HasTask ( j ) then
58732: NOP4
58736: PPUSH
58737: NOP4
58741: NOT
58742: IFFALSE 58829
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
58744: NOP4
58748: PPUSH
58749: NOP4
58753: PUSH
58754: NOP4
58758: ARRAY
58759: PUSH
58760: LD_INT 1
58762: ARRAY
58763: PUSH
58764: LD_INT 1
58766: ARRAY
58767: PPUSH
58768: NOP4
58772: PUSH
58773: NOP4
58777: ARRAY
58778: PUSH
58779: LD_INT 1
58781: ARRAY
58782: PUSH
58783: LD_INT 2
58785: ARRAY
58786: PPUSH
58787: NOP4
58791: PUSH
58792: NOP4
58796: ARRAY
58797: PUSH
58798: LD_INT 1
58800: ARRAY
58801: PUSH
58802: LD_INT 3
58804: ARRAY
58805: PPUSH
58806: NOP4
58810: PUSH
58811: NOP4
58815: ARRAY
58816: PUSH
58817: LD_INT 1
58819: ARRAY
58820: PUSH
58821: LD_INT 4
58823: ARRAY
58824: PPUSH
58825: NOP4
// end ;
58829: GO 58618
58831: POP
58832: POP
// end else
58833: GO 59005
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
58835: NOP4
58839: PUSH
58840: NOP4
58844: ARRAY
58845: PPUSH
58846: NOP4
58850: PUSH
58851: NOP4
58855: ARRAY
58856: PUSH
58857: LD_INT 1
58859: ARRAY
58860: PUSH
58861: LD_INT 1
58863: ARRAY
58864: PPUSH
58865: NOP4
58869: PUSH
58870: NOP4
58874: ARRAY
58875: PUSH
58876: LD_INT 1
58878: ARRAY
58879: PUSH
58880: LD_INT 2
58882: ARRAY
58883: PPUSH
58884: NOP4
58888: PUSH
58889: NOP4
58893: ARRAY
58894: PUSH
58895: LD_INT 1
58897: ARRAY
58898: PUSH
58899: LD_INT 3
58901: ARRAY
58902: PPUSH
58903: NOP4
58907: PUSH
58908: NOP4
58912: ARRAY
58913: PUSH
58914: LD_INT 1
58916: ARRAY
58917: PUSH
58918: LD_INT 4
58920: ARRAY
58921: PPUSH
58922: NOP4
58926: PUSH
58927: NOP4
58931: ARRAY
58932: PPUSH
58933: LD_INT 21
58935: PUSH
58936: LD_INT 3
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: PPUSH
58943: NOP4
58947: PPUSH
58948: EMPTY
58949: PPUSH
58950: NOP4
58954: NOT
58955: IFFALSE 59005
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
58957: NOP4
58961: PUSH
58962: NOP4
58966: PPUSH
58967: NOP4
58971: PPUSH
58972: NOP4
58976: PUSH
58977: NOP4
58981: ARRAY
58982: PPUSH
58983: LD_INT 1
58985: PPUSH
58986: LD_INT 1
58988: NEG
58989: PPUSH
58990: LD_INT 0
58992: PPUSH
58993: NOP4
58997: PPUSH
58998: NOP4
59002: ST_TO_ADDR
// continue ;
59003: GO 57853
// end ; end ; end ;
59005: GO 57853
59007: POP
59008: POP
// end ;
59009: LD_VAR 0 1
59013: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
59014: LD_INT 0
59016: PPUSH
59017: PPUSH
59018: PPUSH
59019: PPUSH
59020: PPUSH
59021: PPUSH
// if not mc_bases then
59022: NOP4
59026: NOT
59027: IFFALSE 59031
// exit ;
59029: GO 59458
// for i = 1 to mc_bases do
59031: NOP4
59035: PUSH
59036: DOUBLE
59037: LD_INT 1
59039: DEC
59040: ST_TO_ADDR
59041: NOP4
59045: PUSH
59046: FOR_TO
59047: IFFALSE 59456
// begin tmp := mc_build_upgrade [ i ] ;
59049: NOP4
59053: PUSH
59054: NOP4
59058: PUSH
59059: NOP4
59063: ARRAY
59064: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
59065: NOP4
59069: PUSH
59070: NOP4
59074: PUSH
59075: NOP4
59079: ARRAY
59080: PPUSH
59081: LD_INT 2
59083: PUSH
59084: LD_INT 30
59086: PUSH
59087: LD_INT 6
59089: PUSH
59090: EMPTY
59091: LIST
59092: LIST
59093: PUSH
59094: LD_INT 30
59096: PUSH
59097: LD_INT 7
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: PUSH
59104: EMPTY
59105: LIST
59106: LIST
59107: LIST
59108: PPUSH
59109: NOP4
59113: ST_TO_ADDR
// if not tmp and not lab then
59114: NOP4
59118: NOT
59119: PUSH
59120: NOP4
59124: NOT
59125: AND
59126: IFFALSE 59130
// continue ;
59128: GO 59046
// if tmp then
59130: NOP4
59134: IFFALSE 59254
// for j in tmp do
59136: NOP4
59140: PUSH
59141: NOP4
59145: PUSH
59146: FOR_IN
59147: IFFALSE 59252
// begin if UpgradeCost ( j ) then
59149: NOP4
59153: PPUSH
59154: NOP4
59158: IFFALSE 59250
// begin ComUpgrade ( j ) ;
59160: NOP4
59164: PPUSH
59165: NOP4
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
59169: NOP4
59173: PUSH
59174: NOP4
59178: PPUSH
59179: NOP4
59183: PPUSH
59184: NOP4
59188: PUSH
59189: NOP4
59193: ARRAY
59194: PUSH
59195: NOP4
59199: DIFF
59200: PPUSH
59201: NOP4
59205: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
59206: NOP4
59210: PUSH
59211: NOP4
59215: PPUSH
59216: NOP4
59220: PUSH
59221: NOP4
59225: PUSH
59226: NOP4
59230: ARRAY
59231: PUSH
59232: LD_INT 1
59234: PLUS
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: PPUSH
59240: NOP4
59244: PPUSH
59245: NOP4
59249: ST_TO_ADDR
// end ; end ;
59250: GO 59146
59252: POP
59253: POP
// if not lab or not mc_lab_upgrade [ i ] then
59254: NOP4
59258: NOT
59259: PUSH
59260: NOP4
59264: PUSH
59265: NOP4
59269: ARRAY
59270: NOT
59271: OR
59272: IFFALSE 59276
// continue ;
59274: GO 59046
// for j in lab do
59276: NOP4
59280: PUSH
59281: NOP4
59285: PUSH
59286: FOR_IN
59287: IFFALSE 59452
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
59289: NOP4
59293: PPUSH
59294: NOP4
59298: PUSH
59299: LD_INT 6
59301: PUSH
59302: LD_INT 7
59304: PUSH
59305: EMPTY
59306: LIST
59307: LIST
59308: IN
59309: PUSH
59310: NOP4
59314: PPUSH
59315: NOP4
59319: PUSH
59320: LD_INT 1
59322: NONEQUAL
59323: AND
59324: IFFALSE 59450
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
59326: NOP4
59330: PPUSH
59331: NOP4
59335: PUSH
59336: NOP4
59340: ARRAY
59341: PUSH
59342: LD_INT 1
59344: ARRAY
59345: PPUSH
59346: NOP4
59350: IFFALSE 59450
// begin ComCancel ( j ) ;
59352: NOP4
59356: PPUSH
59357: NOP4
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
59361: NOP4
59365: PPUSH
59366: NOP4
59370: PUSH
59371: NOP4
59375: ARRAY
59376: PUSH
59377: LD_INT 1
59379: ARRAY
59380: PPUSH
59381: NOP4
// if not j in mc_construct_list [ i ] then
59385: NOP4
59389: PUSH
59390: NOP4
59394: PUSH
59395: NOP4
59399: ARRAY
59400: IN
59401: NOT
59402: IFFALSE 59448
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
59404: NOP4
59408: PUSH
59409: NOP4
59413: PPUSH
59414: NOP4
59418: PUSH
59419: NOP4
59423: PUSH
59424: NOP4
59428: ARRAY
59429: PUSH
59430: LD_INT 1
59432: PLUS
59433: PUSH
59434: EMPTY
59435: LIST
59436: LIST
59437: PPUSH
59438: NOP4
59442: PPUSH
59443: NOP4
59447: ST_TO_ADDR
// break ;
59448: GO 59452
// end ; end ; end ;
59450: GO 59286
59452: POP
59453: POP
// end ;
59454: GO 59046
59456: POP
59457: POP
// end ;
59458: LD_VAR 0 1
59462: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
59463: LD_INT 0
59465: PPUSH
59466: PPUSH
59467: PPUSH
59468: PPUSH
59469: PPUSH
59470: PPUSH
59471: PPUSH
59472: PPUSH
59473: PPUSH
// if not mc_bases then
59474: NOP4
59478: NOT
59479: IFFALSE 59483
// exit ;
59481: GO 59888
// for i = 1 to mc_bases do
59483: NOP4
59487: PUSH
59488: DOUBLE
59489: LD_INT 1
59491: DEC
59492: ST_TO_ADDR
59493: NOP4
59497: PUSH
59498: FOR_TO
59499: IFFALSE 59886
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
59501: NOP4
59505: PUSH
59506: NOP4
59510: ARRAY
59511: NOT
59512: PUSH
59513: NOP4
59517: PUSH
59518: NOP4
59522: ARRAY
59523: PPUSH
59524: LD_INT 30
59526: PUSH
59527: LD_INT 3
59529: PUSH
59530: EMPTY
59531: LIST
59532: LIST
59533: PPUSH
59534: NOP4
59538: NOT
59539: OR
59540: IFFALSE 59544
// continue ;
59542: GO 59498
// busy := false ;
59544: NOP4
59548: PUSH
59549: LD_INT 0
59551: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59552: NOP4
59556: PUSH
59557: NOP4
59561: PUSH
59562: NOP4
59566: ARRAY
59567: PPUSH
59568: LD_INT 30
59570: PUSH
59571: LD_INT 3
59573: PUSH
59574: EMPTY
59575: LIST
59576: LIST
59577: PPUSH
59578: NOP4
59582: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
59583: NOP4
59587: PUSH
59588: NOP4
59592: PUSH
59593: NOP4
59597: ARRAY
59598: PPUSH
59599: LD_INT 2
59601: PUSH
59602: LD_INT 30
59604: PUSH
59605: LD_INT 32
59607: PUSH
59608: EMPTY
59609: LIST
59610: LIST
59611: PUSH
59612: LD_INT 30
59614: PUSH
59615: LD_INT 33
59617: PUSH
59618: EMPTY
59619: LIST
59620: LIST
59621: PUSH
59622: EMPTY
59623: LIST
59624: LIST
59625: LIST
59626: PPUSH
59627: NOP4
59631: ST_TO_ADDR
// if not t then
59632: NOP4
59636: NOT
59637: IFFALSE 59641
// continue ;
59639: GO 59498
// for j in tmp do
59641: NOP4
59645: PUSH
59646: NOP4
59650: PUSH
59651: FOR_IN
59652: IFFALSE 59682
// if not BuildingStatus ( j ) = bs_idle then
59654: NOP4
59658: PPUSH
59659: NOP4
59663: PUSH
59664: LD_INT 2
59666: EQUAL
59667: NOT
59668: IFFALSE 59680
// begin busy := true ;
59670: NOP4
59674: PUSH
59675: LD_INT 1
59677: ST_TO_ADDR
// break ;
59678: GO 59682
// end ;
59680: GO 59651
59682: POP
59683: POP
// if busy then
59684: NOP4
59688: IFFALSE 59692
// continue ;
59690: GO 59498
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
59692: NOP4
59696: PUSH
59697: NOP4
59701: PPUSH
59702: LD_INT 35
59704: PUSH
59705: LD_INT 0
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: PPUSH
59712: NOP4
59716: ST_TO_ADDR
// if tw then
59717: NOP4
59721: IFFALSE 59798
// begin tw := tw [ 1 ] ;
59723: NOP4
59727: PUSH
59728: NOP4
59732: PUSH
59733: LD_INT 1
59735: ARRAY
59736: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
59737: NOP4
59741: PUSH
59742: NOP4
59746: PPUSH
59747: NOP4
59751: PUSH
59752: NOP4
59756: ARRAY
59757: PPUSH
59758: NOP4
59762: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
59763: NOP4
59767: PUSH
59768: NOP4
59772: ARRAY
59773: IFFALSE 59796
// if not weapon in mc_allowed_tower_weapons [ i ] then
59775: NOP4
59779: PUSH
59780: NOP4
59784: PUSH
59785: NOP4
59789: ARRAY
59790: IN
59791: NOT
59792: IFFALSE 59796
// continue ;
59794: GO 59498
// end else
59796: GO 59861
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
59798: NOP4
59802: PUSH
59803: NOP4
59807: PUSH
59808: NOP4
59812: ARRAY
59813: PPUSH
59814: NOP4
59818: PPUSH
59819: NOP4
59823: ST_TO_ADDR
// if not tmp2 then
59824: NOP4
59828: NOT
59829: IFFALSE 59833
// continue ;
59831: GO 59498
// tw := tmp2 [ 1 ] ;
59833: NOP4
59837: PUSH
59838: NOP4
59842: PUSH
59843: LD_INT 1
59845: ARRAY
59846: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
59847: NOP4
59851: PUSH
59852: NOP4
59856: PUSH
59857: LD_INT 2
59859: ARRAY
59860: ST_TO_ADDR
// end ; if not weapon then
59861: NOP4
59865: NOT
59866: IFFALSE 59870
// continue ;
59868: GO 59498
// ComPlaceWeapon ( tw , weapon ) ;
59870: NOP4
59874: PPUSH
59875: NOP4
59879: PPUSH
59880: NOP4
// end ;
59884: GO 59498
59886: POP
59887: POP
// end ;
59888: LD_VAR 0 1
59892: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
59893: LD_INT 0
59895: PPUSH
59896: PPUSH
59897: PPUSH
59898: PPUSH
59899: PPUSH
59900: PPUSH
59901: PPUSH
// if not mc_bases then
59902: NOP4
59906: NOT
59907: IFFALSE 59911
// exit ;
59909: GO 60679
// for i = 1 to mc_bases do
59911: NOP4
59915: PUSH
59916: DOUBLE
59917: LD_INT 1
59919: DEC
59920: ST_TO_ADDR
59921: NOP4
59925: PUSH
59926: FOR_TO
59927: IFFALSE 60677
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
59929: NOP4
59933: PUSH
59934: NOP4
59938: ARRAY
59939: NOT
59940: PUSH
59941: NOP4
59945: PUSH
59946: NOP4
59950: ARRAY
59951: PUSH
59952: NOP4
59956: PUSH
59957: NOP4
59961: ARRAY
59962: EQUAL
59963: OR
59964: PUSH
59965: NOP4
59969: PUSH
59970: NOP4
59974: ARRAY
59975: OR
59976: IFFALSE 59980
// continue ;
59978: GO 59926
// if mc_miners [ i ] then
59980: NOP4
59984: PUSH
59985: NOP4
59989: ARRAY
59990: IFFALSE 60364
// begin for j = mc_miners [ i ] downto 1 do
59992: NOP4
59996: PUSH
59997: DOUBLE
59998: NOP4
60002: PUSH
60003: NOP4
60007: ARRAY
60008: INC
60009: ST_TO_ADDR
60010: LD_INT 1
60012: PUSH
60013: FOR_DOWNTO
60014: IFFALSE 60362
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
60016: NOP4
60020: PUSH
60021: NOP4
60025: ARRAY
60026: PUSH
60027: NOP4
60031: ARRAY
60032: PPUSH
60033: NOP4
60037: PUSH
60038: NOP4
60042: PUSH
60043: NOP4
60047: ARRAY
60048: PUSH
60049: NOP4
60053: ARRAY
60054: PPUSH
60055: NOP4
60059: PUSH
60060: LD_INT 1
60062: NONEQUAL
60063: OR
60064: IFFALSE 60127
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
60066: NOP4
60070: PUSH
60071: NOP4
60075: PUSH
60076: NOP4
60080: ARRAY
60081: PUSH
60082: NOP4
60086: PUSH
60087: NOP4
60091: ARRAY
60092: PUSH
60093: NOP4
60097: ARRAY
60098: DIFF
60099: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
60100: NOP4
60104: PUSH
60105: NOP4
60109: PPUSH
60110: NOP4
60114: PPUSH
60115: NOP4
60119: PPUSH
60120: NOP4
60124: ST_TO_ADDR
// continue ;
60125: GO 60013
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
60127: NOP4
60131: PUSH
60132: NOP4
60136: ARRAY
60137: PUSH
60138: NOP4
60142: ARRAY
60143: PPUSH
60144: NOP4
60148: PUSH
60149: LD_INT 1
60151: EQUAL
60152: PUSH
60153: NOP4
60157: PUSH
60158: NOP4
60162: ARRAY
60163: PUSH
60164: NOP4
60168: ARRAY
60169: PPUSH
60170: NOP4
60174: NOT
60175: AND
60176: PUSH
60177: NOP4
60181: PUSH
60182: NOP4
60186: ARRAY
60187: PUSH
60188: NOP4
60192: ARRAY
60193: PPUSH
60194: NOP4
60198: NOT
60199: AND
60200: IFFALSE 60360
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
60202: NOP4
60206: PUSH
60207: NOP4
60211: ARRAY
60212: PUSH
60213: NOP4
60217: ARRAY
60218: PPUSH
60219: NOP4
60223: IFFALSE 60246
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
60225: NOP4
60229: PUSH
60230: NOP4
60234: ARRAY
60235: PUSH
60236: NOP4
60240: ARRAY
60241: PPUSH
60242: NOP4
// if not HasTask ( mc_miners [ i ] [ j ] ) then
60246: NOP4
60250: PUSH
60251: NOP4
60255: ARRAY
60256: PUSH
60257: NOP4
60261: ARRAY
60262: PPUSH
60263: NOP4
60267: NOT
60268: IFFALSE 60360
// begin r := rand ( 1 , mc_mines [ i ] ) ;
60270: NOP4
60274: PUSH
60275: LD_INT 1
60277: PPUSH
60278: NOP4
60282: PUSH
60283: NOP4
60287: ARRAY
60288: PPUSH
60289: NOP4
60293: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
60294: NOP4
60298: PUSH
60299: NOP4
60303: ARRAY
60304: PUSH
60305: NOP4
60309: ARRAY
60310: PPUSH
60311: NOP4
60315: PUSH
60316: NOP4
60320: ARRAY
60321: PUSH
60322: NOP4
60326: ARRAY
60327: PUSH
60328: LD_INT 1
60330: ARRAY
60331: PPUSH
60332: NOP4
60336: PUSH
60337: NOP4
60341: ARRAY
60342: PUSH
60343: NOP4
60347: ARRAY
60348: PUSH
60349: LD_INT 2
60351: ARRAY
60352: PPUSH
60353: LD_INT 0
60355: PPUSH
60356: NOP4
// end ; end ; end ;
60360: GO 60013
60362: POP
60363: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
60364: NOP4
60368: PUSH
60369: NOP4
60373: PUSH
60374: NOP4
60378: ARRAY
60379: PPUSH
60380: LD_INT 2
60382: PUSH
60383: LD_INT 30
60385: PUSH
60386: LD_INT 4
60388: PUSH
60389: EMPTY
60390: LIST
60391: LIST
60392: PUSH
60393: LD_INT 30
60395: PUSH
60396: LD_INT 5
60398: PUSH
60399: EMPTY
60400: LIST
60401: LIST
60402: PUSH
60403: LD_INT 30
60405: PUSH
60406: LD_INT 32
60408: PUSH
60409: EMPTY
60410: LIST
60411: LIST
60412: PUSH
60413: EMPTY
60414: LIST
60415: LIST
60416: LIST
60417: LIST
60418: PPUSH
60419: NOP4
60423: ST_TO_ADDR
// if not tmp then
60424: NOP4
60428: NOT
60429: IFFALSE 60433
// continue ;
60431: GO 59926
// list := [ ] ;
60433: NOP4
60437: PUSH
60438: EMPTY
60439: ST_TO_ADDR
// for j in tmp do
60440: NOP4
60444: PUSH
60445: NOP4
60449: PUSH
60450: FOR_IN
60451: IFFALSE 60520
// begin for k in UnitsInside ( j ) do
60453: NOP4
60457: PUSH
60458: NOP4
60462: PPUSH
60463: NOP4
60467: PUSH
60468: FOR_IN
60469: IFFALSE 60516
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
60471: NOP4
60475: PPUSH
60476: NOP4
60480: PUSH
60481: LD_INT 1
60483: EQUAL
60484: PUSH
60485: NOP4
60489: PPUSH
60490: NOP4
60494: NOT
60495: AND
60496: IFFALSE 60514
// list := list ^ k ;
60498: NOP4
60502: PUSH
60503: NOP4
60507: PUSH
60508: NOP4
60512: ADD
60513: ST_TO_ADDR
60514: GO 60468
60516: POP
60517: POP
// end ;
60518: GO 60450
60520: POP
60521: POP
// list := list diff mc_miners [ i ] ;
60522: NOP4
60526: PUSH
60527: NOP4
60531: PUSH
60532: NOP4
60536: PUSH
60537: NOP4
60541: ARRAY
60542: DIFF
60543: ST_TO_ADDR
// if not list then
60544: NOP4
60548: NOT
60549: IFFALSE 60553
// continue ;
60551: GO 59926
// k := mc_mines [ i ] - mc_miners [ i ] ;
60553: NOP4
60557: PUSH
60558: NOP4
60562: PUSH
60563: NOP4
60567: ARRAY
60568: PUSH
60569: NOP4
60573: PUSH
60574: NOP4
60578: ARRAY
60579: MINUS
60580: ST_TO_ADDR
// if k > list then
60581: NOP4
60585: PUSH
60586: NOP4
60590: GREATER
60591: IFFALSE 60603
// k := list ;
60593: NOP4
60597: PUSH
60598: NOP4
60602: ST_TO_ADDR
// for j = 1 to k do
60603: NOP4
60607: PUSH
60608: DOUBLE
60609: LD_INT 1
60611: DEC
60612: ST_TO_ADDR
60613: NOP4
60617: PUSH
60618: FOR_TO
60619: IFFALSE 60673
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
60621: NOP4
60625: PUSH
60626: NOP4
60630: PPUSH
60631: NOP4
60635: PUSH
60636: NOP4
60640: PUSH
60641: NOP4
60645: ARRAY
60646: PUSH
60647: LD_INT 1
60649: PLUS
60650: PUSH
60651: EMPTY
60652: LIST
60653: LIST
60654: PPUSH
60655: NOP4
60659: PUSH
60660: NOP4
60664: ARRAY
60665: PPUSH
60666: NOP4
60670: ST_TO_ADDR
60671: GO 60618
60673: POP
60674: POP
// end ;
60675: GO 59926
60677: POP
60678: POP
// end ;
60679: LD_VAR 0 1
60683: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
60684: LD_INT 0
60686: PPUSH
60687: PPUSH
60688: PPUSH
60689: PPUSH
60690: PPUSH
60691: PPUSH
60692: PPUSH
60693: PPUSH
60694: PPUSH
60695: PPUSH
// if not mc_bases then
60696: NOP4
60700: NOT
60701: IFFALSE 60705
// exit ;
60703: GO 62455
// for i = 1 to mc_bases do
60705: NOP4
60709: PUSH
60710: DOUBLE
60711: LD_INT 1
60713: DEC
60714: ST_TO_ADDR
60715: NOP4
60719: PUSH
60720: FOR_TO
60721: IFFALSE 62453
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
60723: NOP4
60727: PUSH
60728: NOP4
60732: ARRAY
60733: NOT
60734: PUSH
60735: NOP4
60739: PUSH
60740: NOP4
60744: ARRAY
60745: OR
60746: IFFALSE 60750
// continue ;
60748: GO 60720
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
60750: NOP4
60754: PUSH
60755: NOP4
60759: ARRAY
60760: NOT
60761: PUSH
60762: NOP4
60766: PUSH
60767: NOP4
60771: ARRAY
60772: AND
60773: IFFALSE 60811
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60775: NOP4
60779: PUSH
60780: NOP4
60784: PPUSH
60785: NOP4
60789: PPUSH
60790: EMPTY
60791: PPUSH
60792: NOP4
60796: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
60797: NOP4
60801: PPUSH
60802: LD_INT 107
60804: PPUSH
60805: NOP4
// continue ;
60809: GO 60720
// end ; target := [ ] ;
60811: NOP4
60815: PUSH
60816: EMPTY
60817: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
60818: NOP4
60822: PUSH
60823: DOUBLE
60824: NOP4
60828: PUSH
60829: NOP4
60833: ARRAY
60834: INC
60835: ST_TO_ADDR
60836: LD_INT 1
60838: PUSH
60839: FOR_DOWNTO
60840: IFFALSE 61100
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
60842: NOP4
60846: PUSH
60847: NOP4
60851: ARRAY
60852: PUSH
60853: NOP4
60857: ARRAY
60858: PUSH
60859: LD_INT 2
60861: ARRAY
60862: PPUSH
60863: NOP4
60867: PUSH
60868: NOP4
60872: ARRAY
60873: PUSH
60874: NOP4
60878: ARRAY
60879: PUSH
60880: LD_INT 3
60882: ARRAY
60883: PPUSH
60884: NOP4
60888: PUSH
60889: NOP4
60893: PUSH
60894: NOP4
60898: ARRAY
60899: PUSH
60900: NOP4
60904: ARRAY
60905: PUSH
60906: LD_INT 2
60908: ARRAY
60909: PPUSH
60910: NOP4
60914: PUSH
60915: NOP4
60919: ARRAY
60920: PUSH
60921: NOP4
60925: ARRAY
60926: PUSH
60927: LD_INT 3
60929: ARRAY
60930: PPUSH
60931: NOP4
60935: PUSH
60936: LD_INT 0
60938: EQUAL
60939: AND
60940: IFFALSE 60995
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
60942: NOP4
60946: PUSH
60947: NOP4
60951: PUSH
60952: NOP4
60956: ARRAY
60957: PPUSH
60958: NOP4
60962: PPUSH
60963: NOP4
60967: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
60968: NOP4
60972: PUSH
60973: NOP4
60977: PPUSH
60978: NOP4
60982: PPUSH
60983: NOP4
60987: PPUSH
60988: NOP4
60992: ST_TO_ADDR
// continue ;
60993: GO 60839
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
60995: NOP4
60999: PUSH
61000: NOP4
61004: ARRAY
61005: PUSH
61006: LD_INT 1
61008: ARRAY
61009: PPUSH
61010: NOP4
61014: PPUSH
61015: NOP4
61019: PUSH
61020: NOP4
61024: ARRAY
61025: PUSH
61026: NOP4
61030: ARRAY
61031: PUSH
61032: LD_INT 2
61034: ARRAY
61035: PPUSH
61036: NOP4
61040: PUSH
61041: NOP4
61045: ARRAY
61046: PUSH
61047: NOP4
61051: ARRAY
61052: PUSH
61053: LD_INT 3
61055: ARRAY
61056: PPUSH
61057: LD_INT 30
61059: PPUSH
61060: NOP4
61064: PUSH
61065: LD_INT 4
61067: ARRAY
61068: PUSH
61069: LD_INT 0
61071: EQUAL
61072: IFFALSE 61098
// begin target := mc_crates [ i ] [ j ] ;
61074: NOP4
61078: PUSH
61079: NOP4
61083: PUSH
61084: NOP4
61088: ARRAY
61089: PUSH
61090: NOP4
61094: ARRAY
61095: ST_TO_ADDR
// break ;
61096: GO 61100
// end ; end ;
61098: GO 60839
61100: POP
61101: POP
// if not target then
61102: NOP4
61106: NOT
61107: IFFALSE 61111
// continue ;
61109: GO 60720
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
61111: NOP4
61115: PUSH
61116: NOP4
61120: PUSH
61121: NOP4
61125: ARRAY
61126: PPUSH
61127: LD_INT 2
61129: PUSH
61130: LD_INT 3
61132: PUSH
61133: LD_INT 58
61135: PUSH
61136: EMPTY
61137: LIST
61138: PUSH
61139: EMPTY
61140: LIST
61141: LIST
61142: PUSH
61143: LD_INT 61
61145: PUSH
61146: EMPTY
61147: LIST
61148: PUSH
61149: LD_INT 33
61151: PUSH
61152: LD_INT 5
61154: PUSH
61155: EMPTY
61156: LIST
61157: LIST
61158: PUSH
61159: LD_INT 33
61161: PUSH
61162: LD_INT 3
61164: PUSH
61165: EMPTY
61166: LIST
61167: LIST
61168: PUSH
61169: EMPTY
61170: LIST
61171: LIST
61172: LIST
61173: LIST
61174: LIST
61175: PUSH
61176: LD_INT 2
61178: PUSH
61179: LD_INT 34
61181: PUSH
61182: LD_INT 32
61184: PUSH
61185: EMPTY
61186: LIST
61187: LIST
61188: PUSH
61189: LD_INT 34
61191: PUSH
61192: LD_INT 51
61194: PUSH
61195: EMPTY
61196: LIST
61197: LIST
61198: PUSH
61199: LD_INT 34
61201: PUSH
61202: LD_INT 12
61204: PUSH
61205: EMPTY
61206: LIST
61207: LIST
61208: PUSH
61209: EMPTY
61210: LIST
61211: LIST
61212: LIST
61213: LIST
61214: PUSH
61215: EMPTY
61216: LIST
61217: LIST
61218: PPUSH
61219: NOP4
61223: ST_TO_ADDR
// if not cargo then
61224: NOP4
61228: NOT
61229: IFFALSE 61872
// begin if mc_crates_collector [ i ] < 5 then
61231: NOP4
61235: PUSH
61236: NOP4
61240: ARRAY
61241: PUSH
61242: LD_INT 5
61244: LESS
61245: IFFALSE 61611
// begin if mc_ape [ i ] then
61247: NOP4
61251: PUSH
61252: NOP4
61256: ARRAY
61257: IFFALSE 61304
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
61259: NOP4
61263: PUSH
61264: NOP4
61268: PUSH
61269: NOP4
61273: ARRAY
61274: PPUSH
61275: LD_INT 25
61277: PUSH
61278: LD_INT 16
61280: PUSH
61281: EMPTY
61282: LIST
61283: LIST
61284: PUSH
61285: LD_INT 24
61287: PUSH
61288: LD_INT 750
61290: PUSH
61291: EMPTY
61292: LIST
61293: LIST
61294: PUSH
61295: EMPTY
61296: LIST
61297: LIST
61298: PPUSH
61299: NOP4
61303: ST_TO_ADDR
// if not tmp then
61304: NOP4
61308: NOT
61309: IFFALSE 61356
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
61311: NOP4
61315: PUSH
61316: NOP4
61320: PUSH
61321: NOP4
61325: ARRAY
61326: PPUSH
61327: LD_INT 25
61329: PUSH
61330: LD_INT 2
61332: PUSH
61333: EMPTY
61334: LIST
61335: LIST
61336: PUSH
61337: LD_INT 24
61339: PUSH
61340: LD_INT 750
61342: PUSH
61343: EMPTY
61344: LIST
61345: LIST
61346: PUSH
61347: EMPTY
61348: LIST
61349: LIST
61350: PPUSH
61351: NOP4
61355: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
61356: NOP4
61360: PUSH
61361: NOP4
61365: ARRAY
61366: PUSH
61367: NOP4
61371: PUSH
61372: NOP4
61376: ARRAY
61377: PPUSH
61378: LD_INT 25
61380: PUSH
61381: LD_INT 2
61383: PUSH
61384: EMPTY
61385: LIST
61386: LIST
61387: PUSH
61388: LD_INT 24
61390: PUSH
61391: LD_INT 750
61393: PUSH
61394: EMPTY
61395: LIST
61396: LIST
61397: PUSH
61398: EMPTY
61399: LIST
61400: LIST
61401: PPUSH
61402: NOP4
61406: AND
61407: PUSH
61408: NOP4
61412: PUSH
61413: LD_INT 5
61415: LESS
61416: AND
61417: IFFALSE 61499
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
61419: NOP4
61423: PUSH
61424: NOP4
61428: PUSH
61429: NOP4
61433: ARRAY
61434: PPUSH
61435: LD_INT 25
61437: PUSH
61438: LD_INT 2
61440: PUSH
61441: EMPTY
61442: LIST
61443: LIST
61444: PUSH
61445: LD_INT 24
61447: PUSH
61448: LD_INT 750
61450: PUSH
61451: EMPTY
61452: LIST
61453: LIST
61454: PUSH
61455: EMPTY
61456: LIST
61457: LIST
61458: PPUSH
61459: NOP4
61463: PUSH
61464: FOR_IN
61465: IFFALSE 61497
// begin tmp := tmp union j ;
61467: NOP4
61471: PUSH
61472: NOP4
61476: PUSH
61477: NOP4
61481: UNION
61482: ST_TO_ADDR
// if tmp >= 5 then
61483: NOP4
61487: PUSH
61488: LD_INT 5
61490: GREATEREQUAL
61491: IFFALSE 61495
// break ;
61493: GO 61497
// end ;
61495: GO 61464
61497: POP
61498: POP
// end ; if not tmp then
61499: NOP4
61503: NOT
61504: IFFALSE 61508
// continue ;
61506: GO 60720
// for j in tmp do
61508: NOP4
61512: PUSH
61513: NOP4
61517: PUSH
61518: FOR_IN
61519: IFFALSE 61609
// if not GetTag ( j ) then
61521: NOP4
61525: PPUSH
61526: NOP4
61530: NOT
61531: IFFALSE 61607
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
61533: NOP4
61537: PUSH
61538: NOP4
61542: PPUSH
61543: NOP4
61547: PUSH
61548: NOP4
61552: PUSH
61553: NOP4
61557: ARRAY
61558: PUSH
61559: LD_INT 1
61561: PLUS
61562: PUSH
61563: EMPTY
61564: LIST
61565: LIST
61566: PPUSH
61567: NOP4
61571: PPUSH
61572: NOP4
61576: ST_TO_ADDR
// SetTag ( j , 107 ) ;
61577: NOP4
61581: PPUSH
61582: LD_INT 107
61584: PPUSH
61585: NOP4
// if mc_crates_collector [ i ] >= 5 then
61589: NOP4
61593: PUSH
61594: NOP4
61598: ARRAY
61599: PUSH
61600: LD_INT 5
61602: GREATEREQUAL
61603: IFFALSE 61607
// break ;
61605: GO 61609
// end ;
61607: GO 61518
61609: POP
61610: POP
// end ; if mc_crates_collector [ i ] and target then
61611: NOP4
61615: PUSH
61616: NOP4
61620: ARRAY
61621: PUSH
61622: NOP4
61626: AND
61627: IFFALSE 61870
// begin if mc_crates_collector [ i ] < target [ 1 ] then
61629: NOP4
61633: PUSH
61634: NOP4
61638: ARRAY
61639: PUSH
61640: NOP4
61644: PUSH
61645: LD_INT 1
61647: ARRAY
61648: LESS
61649: IFFALSE 61669
// tmp := mc_crates_collector [ i ] else
61651: NOP4
61655: PUSH
61656: NOP4
61660: PUSH
61661: NOP4
61665: ARRAY
61666: ST_TO_ADDR
61667: GO 61683
// tmp := target [ 1 ] ;
61669: NOP4
61673: PUSH
61674: NOP4
61678: PUSH
61679: LD_INT 1
61681: ARRAY
61682: ST_TO_ADDR
// k := 0 ;
61683: NOP4
61687: PUSH
61688: LD_INT 0
61690: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
61691: NOP4
61695: PUSH
61696: NOP4
61700: PUSH
61701: NOP4
61705: ARRAY
61706: PUSH
61707: FOR_IN
61708: IFFALSE 61868
// begin k := k + 1 ;
61710: NOP4
61714: PUSH
61715: NOP4
61719: PUSH
61720: LD_INT 1
61722: PLUS
61723: ST_TO_ADDR
// if k > tmp then
61724: NOP4
61728: PUSH
61729: NOP4
61733: GREATER
61734: IFFALSE 61738
// break ;
61736: GO 61868
// if not GetClass ( j ) in [ 2 , 16 ] then
61738: NOP4
61742: PPUSH
61743: NOP4
61747: PUSH
61748: LD_INT 2
61750: PUSH
61751: LD_INT 16
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: IN
61758: NOT
61759: IFFALSE 61812
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
61761: NOP4
61765: PUSH
61766: NOP4
61770: PPUSH
61771: NOP4
61775: PPUSH
61776: NOP4
61780: PUSH
61781: NOP4
61785: ARRAY
61786: PUSH
61787: NOP4
61791: DIFF
61792: PPUSH
61793: NOP4
61797: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61798: NOP4
61802: PPUSH
61803: LD_INT 0
61805: PPUSH
61806: NOP4
// continue ;
61810: GO 61707
// end ; if IsInUnit ( j ) then
61812: NOP4
61816: PPUSH
61817: NOP4
61821: IFFALSE 61832
// ComExitBuilding ( j ) ;
61823: NOP4
61827: PPUSH
61828: NOP4
// wait ( 3 ) ;
61832: LD_INT 3
61834: PPUSH
61835: NOP4
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61839: NOP4
61843: PPUSH
61844: NOP4
61848: PUSH
61849: LD_INT 2
61851: ARRAY
61852: PPUSH
61853: NOP4
61857: PUSH
61858: LD_INT 3
61860: ARRAY
61861: PPUSH
61862: NOP4
// end ;
61866: GO 61707
61868: POP
61869: POP
// end ; end else
61870: GO 62451
// begin for j in cargo do
61872: NOP4
61876: PUSH
61877: NOP4
61881: PUSH
61882: FOR_IN
61883: IFFALSE 62449
// begin if GetTag ( j ) <> 0 then
61885: NOP4
61889: PPUSH
61890: NOP4
61894: PUSH
61895: LD_INT 0
61897: NONEQUAL
61898: IFFALSE 61902
// continue ;
61900: GO 61882
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
61902: NOP4
61906: PPUSH
61907: NOP4
61911: PUSH
61912: LD_INT 1000
61914: LESS
61915: PUSH
61916: NOP4
61920: PPUSH
61921: NOP4
61925: PUSH
61926: NOP4
61930: ARRAY
61931: PPUSH
61932: NOP4
61936: NOT
61937: AND
61938: IFFALSE 61960
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61940: NOP4
61944: PPUSH
61945: NOP4
61949: PUSH
61950: NOP4
61954: ARRAY
61955: PPUSH
61956: NOP4
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
61960: NOP4
61964: PPUSH
61965: NOP4
61969: PUSH
61970: LD_INT 1000
61972: LESS
61973: PUSH
61974: NOP4
61978: PPUSH
61979: NOP4
61983: PUSH
61984: NOP4
61988: ARRAY
61989: PPUSH
61990: NOP4
61994: AND
61995: IFFALSE 61999
// continue ;
61997: GO 61882
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
61999: NOP4
62003: PPUSH
62004: NOP4
62008: PUSH
62009: LD_INT 2
62011: EQUAL
62012: PUSH
62013: NOP4
62017: PPUSH
62018: NOP4
62022: PUSH
62023: LD_INT 15
62025: LESS
62026: AND
62027: IFFALSE 62031
// continue ;
62029: GO 61882
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
62031: NOP4
62035: PPUSH
62036: NOP4
62040: PUSH
62041: LD_INT 1
62043: EQUAL
62044: PUSH
62045: NOP4
62049: PPUSH
62050: NOP4
62054: PUSH
62055: LD_INT 10
62057: LESS
62058: AND
62059: IFFALSE 62388
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62061: NOP4
62065: PUSH
62066: NOP4
62070: PUSH
62071: NOP4
62075: ARRAY
62076: PPUSH
62077: LD_INT 2
62079: PUSH
62080: LD_INT 30
62082: PUSH
62083: LD_INT 0
62085: PUSH
62086: EMPTY
62087: LIST
62088: LIST
62089: PUSH
62090: LD_INT 30
62092: PUSH
62093: LD_INT 1
62095: PUSH
62096: EMPTY
62097: LIST
62098: LIST
62099: PUSH
62100: EMPTY
62101: LIST
62102: LIST
62103: LIST
62104: PPUSH
62105: NOP4
62109: ST_TO_ADDR
// if not depot then
62110: NOP4
62114: NOT
62115: IFFALSE 62119
// continue ;
62117: GO 61882
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
62119: NOP4
62123: PPUSH
62124: NOP4
62128: PPUSH
62129: NOP4
62133: PPUSH
62134: NOP4
62138: PPUSH
62139: NOP4
62143: PUSH
62144: LD_INT 6
62146: LESS
62147: IFFALSE 62163
// SetFuel ( j , 100 ) else
62149: NOP4
62153: PPUSH
62154: LD_INT 100
62156: PPUSH
62157: NOP4
62161: GO 62388
// if GetFuel ( j ) = 0 then
62163: NOP4
62167: PPUSH
62168: NOP4
62172: PUSH
62173: LD_INT 0
62175: EQUAL
62176: IFFALSE 62388
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
62178: NOP4
62182: PUSH
62183: NOP4
62187: PPUSH
62188: NOP4
62192: PPUSH
62193: NOP4
62197: PUSH
62198: NOP4
62202: ARRAY
62203: PUSH
62204: NOP4
62208: DIFF
62209: PPUSH
62210: NOP4
62214: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
62215: NOP4
62219: PPUSH
62220: NOP4
62224: PUSH
62225: LD_INT 1
62227: EQUAL
62228: IFFALSE 62244
// ComExitVehicle ( IsInUnit ( j ) ) ;
62230: NOP4
62234: PPUSH
62235: NOP4
62239: PPUSH
62240: NOP4
// if GetControl ( j ) = control_remote then
62244: NOP4
62248: PPUSH
62249: NOP4
62253: PUSH
62254: LD_INT 2
62256: EQUAL
62257: IFFALSE 62268
// ComUnlink ( j ) ;
62259: NOP4
62263: PPUSH
62264: NOP4
// fac := MC_GetBuildings ( i , b_factory ) ;
62268: NOP4
62272: PUSH
62273: NOP4
62277: PPUSH
62278: LD_INT 3
62280: PPUSH
62281: NOP4
62285: ST_TO_ADDR
// if fac then
62286: NOP4
62290: IFFALSE 62386
// begin for k in fac do
62292: NOP4
62296: PUSH
62297: NOP4
62301: PUSH
62302: FOR_IN
62303: IFFALSE 62384
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
62305: NOP4
62309: PUSH
62310: NOP4
62314: PPUSH
62315: NOP4
62319: PPUSH
62320: NOP4
62324: PPUSH
62325: NOP4
62329: PPUSH
62330: NOP4
62334: PPUSH
62335: NOP4
62339: PPUSH
62340: NOP4
62344: PPUSH
62345: NOP4
62349: PPUSH
62350: NOP4
62354: PPUSH
62355: NOP4
62359: ST_TO_ADDR
// if components then
62360: NOP4
62364: IFFALSE 62382
// begin MC_InsertProduceList ( i , components ) ;
62366: NOP4
62370: PPUSH
62371: NOP4
62375: PPUSH
62376: NOP4
// break ;
62380: GO 62384
// end ; end ;
62382: GO 62302
62384: POP
62385: POP
// end ; continue ;
62386: GO 61882
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
62388: NOP4
62392: PPUSH
62393: LD_INT 1
62395: PPUSH
62396: NOP4
62400: PUSH
62401: LD_INT 100
62403: LESS
62404: PUSH
62405: NOP4
62409: PPUSH
62410: NOP4
62414: NOT
62415: AND
62416: IFFALSE 62445
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
62418: NOP4
62422: PPUSH
62423: NOP4
62427: PUSH
62428: LD_INT 2
62430: ARRAY
62431: PPUSH
62432: NOP4
62436: PUSH
62437: LD_INT 3
62439: ARRAY
62440: PPUSH
62441: NOP4
// break ;
62445: GO 62449
// end ;
62447: GO 61882
62449: POP
62450: POP
// end ; end ;
62451: GO 60720
62453: POP
62454: POP
// end ;
62455: LD_VAR 0 1
62459: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
62460: LD_INT 0
62462: PPUSH
62463: PPUSH
62464: PPUSH
62465: PPUSH
// if not mc_bases then
62466: NOP4
62470: NOT
62471: IFFALSE 62475
// exit ;
62473: GO 62636
// for i = 1 to mc_bases do
62475: NOP4
62479: PUSH
62480: DOUBLE
62481: LD_INT 1
62483: DEC
62484: ST_TO_ADDR
62485: NOP4
62489: PUSH
62490: FOR_TO
62491: IFFALSE 62634
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
62493: NOP4
62497: PUSH
62498: NOP4
62502: PUSH
62503: NOP4
62507: ARRAY
62508: PUSH
62509: NOP4
62513: PUSH
62514: NOP4
62518: ARRAY
62519: UNION
62520: PPUSH
62521: LD_INT 33
62523: PUSH
62524: LD_INT 2
62526: PUSH
62527: EMPTY
62528: LIST
62529: LIST
62530: PPUSH
62531: NOP4
62535: ST_TO_ADDR
// if tmp then
62536: NOP4
62540: IFFALSE 62632
// for j in tmp do
62542: NOP4
62546: PUSH
62547: NOP4
62551: PUSH
62552: FOR_IN
62553: IFFALSE 62630
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
62555: NOP4
62559: PPUSH
62560: NOP4
62564: NOT
62565: PUSH
62566: NOP4
62570: PPUSH
62571: NOP4
62575: PUSH
62576: LD_INT 250
62578: GREATEREQUAL
62579: AND
62580: IFFALSE 62593
// Connect ( j ) else
62582: NOP4
62586: PPUSH
62587: NOP4
62591: GO 62628
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
62593: NOP4
62597: PPUSH
62598: NOP4
62602: PUSH
62603: LD_INT 250
62605: LESS
62606: PUSH
62607: NOP4
62611: PPUSH
62612: NOP4
62616: AND
62617: IFFALSE 62628
// ComUnlink ( j ) ;
62619: NOP4
62623: PPUSH
62624: NOP4
62628: GO 62552
62630: POP
62631: POP
// end ;
62632: GO 62490
62634: POP
62635: POP
// end ;
62636: LD_VAR 0 1
62640: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
62641: LD_INT 0
62643: PPUSH
62644: PPUSH
62645: PPUSH
62646: PPUSH
62647: PPUSH
// if not mc_bases then
62648: NOP4
62652: NOT
62653: IFFALSE 62657
// exit ;
62655: GO 63102
// for i = 1 to mc_bases do
62657: NOP4
62661: PUSH
62662: DOUBLE
62663: LD_INT 1
62665: DEC
62666: ST_TO_ADDR
62667: NOP4
62671: PUSH
62672: FOR_TO
62673: IFFALSE 63100
// begin if not mc_produce [ i ] then
62675: NOP4
62679: PUSH
62680: NOP4
62684: ARRAY
62685: NOT
62686: IFFALSE 62690
// continue ;
62688: GO 62672
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62690: NOP4
62694: PUSH
62695: NOP4
62699: PUSH
62700: NOP4
62704: ARRAY
62705: PPUSH
62706: LD_INT 30
62708: PUSH
62709: LD_INT 3
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: PPUSH
62716: NOP4
62720: ST_TO_ADDR
// if not fac then
62721: NOP4
62725: NOT
62726: IFFALSE 62730
// continue ;
62728: GO 62672
// for j in fac do
62730: NOP4
62734: PUSH
62735: NOP4
62739: PUSH
62740: FOR_IN
62741: IFFALSE 63096
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
62743: NOP4
62747: PPUSH
62748: NOP4
62752: PUSH
62753: LD_INT 2
62755: NONEQUAL
62756: PUSH
62757: NOP4
62761: PPUSH
62762: LD_INT 15
62764: PPUSH
62765: NOP4
62769: PUSH
62770: LD_INT 4
62772: ARRAY
62773: OR
62774: IFFALSE 62778
// continue ;
62776: GO 62740
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
62778: NOP4
62782: PPUSH
62783: NOP4
62787: PUSH
62788: NOP4
62792: ARRAY
62793: PUSH
62794: LD_INT 1
62796: ARRAY
62797: PUSH
62798: LD_INT 1
62800: ARRAY
62801: PPUSH
62802: NOP4
62806: PUSH
62807: NOP4
62811: ARRAY
62812: PUSH
62813: LD_INT 1
62815: ARRAY
62816: PUSH
62817: LD_INT 2
62819: ARRAY
62820: PPUSH
62821: NOP4
62825: PUSH
62826: NOP4
62830: ARRAY
62831: PUSH
62832: LD_INT 1
62834: ARRAY
62835: PUSH
62836: LD_INT 3
62838: ARRAY
62839: PPUSH
62840: NOP4
62844: PUSH
62845: NOP4
62849: ARRAY
62850: PUSH
62851: LD_INT 1
62853: ARRAY
62854: PUSH
62855: LD_INT 4
62857: ARRAY
62858: PPUSH
62859: NOP4
62863: PUSH
62864: NOP4
62868: PPUSH
62869: NOP4
62873: PUSH
62874: NOP4
62878: ARRAY
62879: PUSH
62880: LD_INT 1
62882: ARRAY
62883: PUSH
62884: LD_INT 1
62886: ARRAY
62887: PUSH
62888: NOP4
62892: PUSH
62893: NOP4
62897: ARRAY
62898: PUSH
62899: LD_INT 1
62901: ARRAY
62902: PUSH
62903: LD_INT 2
62905: ARRAY
62906: PUSH
62907: NOP4
62911: PUSH
62912: NOP4
62916: ARRAY
62917: PUSH
62918: LD_INT 1
62920: ARRAY
62921: PUSH
62922: LD_INT 3
62924: ARRAY
62925: PUSH
62926: NOP4
62930: PUSH
62931: NOP4
62935: ARRAY
62936: PUSH
62937: LD_INT 1
62939: ARRAY
62940: PUSH
62941: LD_INT 4
62943: ARRAY
62944: PUSH
62945: EMPTY
62946: LIST
62947: LIST
62948: LIST
62949: LIST
62950: PPUSH
62951: NOP4
62955: AND
62956: IFFALSE 63094
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
62958: NOP4
62962: PPUSH
62963: NOP4
62967: PUSH
62968: NOP4
62972: ARRAY
62973: PUSH
62974: LD_INT 1
62976: ARRAY
62977: PUSH
62978: LD_INT 1
62980: ARRAY
62981: PPUSH
62982: NOP4
62986: PUSH
62987: NOP4
62991: ARRAY
62992: PUSH
62993: LD_INT 1
62995: ARRAY
62996: PUSH
62997: LD_INT 2
62999: ARRAY
63000: PPUSH
63001: NOP4
63005: PUSH
63006: NOP4
63010: ARRAY
63011: PUSH
63012: LD_INT 1
63014: ARRAY
63015: PUSH
63016: LD_INT 3
63018: ARRAY
63019: PPUSH
63020: NOP4
63024: PUSH
63025: NOP4
63029: ARRAY
63030: PUSH
63031: LD_INT 1
63033: ARRAY
63034: PUSH
63035: LD_INT 4
63037: ARRAY
63038: PPUSH
63039: NOP4
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
63043: NOP4
63047: PUSH
63048: NOP4
63052: PUSH
63053: NOP4
63057: ARRAY
63058: PPUSH
63059: LD_INT 1
63061: PPUSH
63062: NOP4
63066: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63067: NOP4
63071: PUSH
63072: NOP4
63076: PPUSH
63077: NOP4
63081: PPUSH
63082: NOP4
63086: PPUSH
63087: NOP4
63091: ST_TO_ADDR
// break ;
63092: GO 63096
// end ; end ;
63094: GO 62740
63096: POP
63097: POP
// end ;
63098: GO 62672
63100: POP
63101: POP
// end ;
63102: LD_VAR 0 1
63106: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
63107: LD_INT 0
63109: PPUSH
63110: PPUSH
63111: PPUSH
// if not mc_bases then
63112: NOP4
63116: NOT
63117: IFFALSE 63121
// exit ;
63119: GO 63210
// for i = 1 to mc_bases do
63121: NOP4
63125: PUSH
63126: DOUBLE
63127: LD_INT 1
63129: DEC
63130: ST_TO_ADDR
63131: NOP4
63135: PUSH
63136: FOR_TO
63137: IFFALSE 63208
// begin if mc_attack [ i ] then
63139: NOP4
63143: PUSH
63144: NOP4
63148: ARRAY
63149: IFFALSE 63206
// begin tmp := mc_attack [ i ] [ 1 ] ;
63151: NOP4
63155: PUSH
63156: NOP4
63160: PUSH
63161: NOP4
63165: ARRAY
63166: PUSH
63167: LD_INT 1
63169: ARRAY
63170: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63171: NOP4
63175: PUSH
63176: NOP4
63180: PPUSH
63181: NOP4
63185: PPUSH
63186: EMPTY
63187: PPUSH
63188: NOP4
63192: ST_TO_ADDR
// Attack ( tmp ) ;
63193: NOP4
63197: PPUSH
63198: NOP4
// exit ;
63202: POP
63203: POP
63204: GO 63210
// end ; end ;
63206: GO 63136
63208: POP
63209: POP
// end ;
63210: LD_VAR 0 1
63214: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
63215: LD_INT 0
63217: PPUSH
63218: PPUSH
63219: PPUSH
63220: PPUSH
63221: PPUSH
63222: PPUSH
63223: PPUSH
// if not mc_bases then
63224: NOP4
63228: NOT
63229: IFFALSE 63233
// exit ;
63231: GO 63932
// for i = 1 to mc_bases do
63233: NOP4
63237: PUSH
63238: DOUBLE
63239: LD_INT 1
63241: DEC
63242: ST_TO_ADDR
63243: NOP4
63247: PUSH
63248: FOR_TO
63249: IFFALSE 63930
// begin if not mc_bases [ i ] then
63251: NOP4
63255: PUSH
63256: NOP4
63260: ARRAY
63261: NOT
63262: IFFALSE 63266
// continue ;
63264: GO 63248
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
63266: NOP4
63270: PUSH
63271: NOP4
63275: PUSH
63276: NOP4
63280: ARRAY
63281: PUSH
63282: LD_INT 1
63284: ARRAY
63285: PPUSH
63286: NOP4
63290: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
63291: NOP4
63295: PUSH
63296: NOP4
63300: PPUSH
63301: NOP4
63305: PPUSH
63306: NOP4
63310: PUSH
63311: NOP4
63315: ARRAY
63316: PUSH
63317: LD_INT 1
63319: ARRAY
63320: PPUSH
63321: NOP4
63325: PPUSH
63326: NOP4
63330: PUSH
63331: NOP4
63335: ARRAY
63336: PPUSH
63337: NOP4
63341: PPUSH
63342: NOP4
63346: ST_TO_ADDR
// if not mc_scan [ i ] then
63347: NOP4
63351: PUSH
63352: NOP4
63356: ARRAY
63357: NOT
63358: IFFALSE 63536
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63360: NOP4
63364: PUSH
63365: NOP4
63369: PUSH
63370: NOP4
63374: ARRAY
63375: PPUSH
63376: LD_INT 2
63378: PUSH
63379: LD_INT 25
63381: PUSH
63382: LD_INT 5
63384: PUSH
63385: EMPTY
63386: LIST
63387: LIST
63388: PUSH
63389: LD_INT 25
63391: PUSH
63392: LD_INT 8
63394: PUSH
63395: EMPTY
63396: LIST
63397: LIST
63398: PUSH
63399: LD_INT 25
63401: PUSH
63402: LD_INT 9
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: EMPTY
63410: LIST
63411: LIST
63412: LIST
63413: LIST
63414: PPUSH
63415: NOP4
63419: ST_TO_ADDR
// if not tmp then
63420: NOP4
63424: NOT
63425: IFFALSE 63429
// continue ;
63427: GO 63248
// for j in tmp do
63429: NOP4
63433: PUSH
63434: NOP4
63438: PUSH
63439: FOR_IN
63440: IFFALSE 63511
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
63442: NOP4
63446: PPUSH
63447: NOP4
63451: PPUSH
63452: NOP4
63456: PUSH
63457: LD_INT 5
63459: EQUAL
63460: PUSH
63461: NOP4
63465: PPUSH
63466: NOP4
63470: PUSH
63471: LD_INT 1
63473: EQUAL
63474: AND
63475: PUSH
63476: NOP4
63480: PPUSH
63481: NOP4
63485: NOT
63486: AND
63487: PUSH
63488: NOP4
63492: AND
63493: IFFALSE 63509
// ComChangeProfession ( j , class ) ;
63495: NOP4
63499: PPUSH
63500: NOP4
63504: PPUSH
63505: NOP4
63509: GO 63439
63511: POP
63512: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
63513: NOP4
63517: PUSH
63518: NOP4
63522: PPUSH
63523: NOP4
63527: PPUSH
63528: LD_INT 0
63530: PPUSH
63531: NOP4
63535: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
63536: NOP4
63540: PUSH
63541: NOP4
63545: ARRAY
63546: PUSH
63547: NOP4
63551: PUSH
63552: NOP4
63556: ARRAY
63557: NOT
63558: AND
63559: PUSH
63560: NOP4
63564: PUSH
63565: NOP4
63569: ARRAY
63570: NOT
63571: AND
63572: PUSH
63573: NOP4
63577: PUSH
63578: NOP4
63582: ARRAY
63583: PPUSH
63584: LD_INT 30
63586: PUSH
63587: LD_INT 32
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: PPUSH
63594: NOP4
63598: NOT
63599: AND
63600: PUSH
63601: NOP4
63605: PUSH
63606: NOP4
63610: ARRAY
63611: PPUSH
63612: LD_INT 2
63614: PUSH
63615: LD_INT 30
63617: PUSH
63618: LD_INT 4
63620: PUSH
63621: EMPTY
63622: LIST
63623: LIST
63624: PUSH
63625: LD_INT 30
63627: PUSH
63628: LD_INT 5
63630: PUSH
63631: EMPTY
63632: LIST
63633: LIST
63634: PUSH
63635: EMPTY
63636: LIST
63637: LIST
63638: LIST
63639: PPUSH
63640: NOP4
63644: NOT
63645: AND
63646: IFFALSE 63801
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63648: NOP4
63652: PUSH
63653: NOP4
63657: PUSH
63658: NOP4
63662: ARRAY
63663: PPUSH
63664: LD_INT 2
63666: PUSH
63667: LD_INT 25
63669: PUSH
63670: LD_INT 1
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: PUSH
63677: LD_INT 25
63679: PUSH
63680: LD_INT 5
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: LD_INT 25
63689: PUSH
63690: LD_INT 8
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 25
63699: PUSH
63700: LD_INT 9
63702: PUSH
63703: EMPTY
63704: LIST
63705: LIST
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: LIST
63711: LIST
63712: LIST
63713: PPUSH
63714: NOP4
63718: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
63719: NOP4
63723: PUSH
63724: NOP4
63728: PUSH
63729: NOP4
63733: PPUSH
63734: LD_INT 18
63736: PPUSH
63737: NOP4
63741: DIFF
63742: ST_TO_ADDR
// if tmp then
63743: NOP4
63747: IFFALSE 63801
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
63749: NOP4
63753: PUSH
63754: NOP4
63758: PPUSH
63759: NOP4
63763: PPUSH
63764: LD_INT 1
63766: PPUSH
63767: NOP4
63771: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
63772: NOP4
63776: PPUSH
63777: NOP4
63781: PPUSH
63782: NOP4
63786: PUSH
63787: NOP4
63791: ARRAY
63792: PPUSH
63793: NOP4
// exit ;
63797: POP
63798: POP
63799: GO 63932
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
63801: NOP4
63805: PUSH
63806: NOP4
63810: ARRAY
63811: PUSH
63812: NOP4
63816: PUSH
63817: NOP4
63821: ARRAY
63822: NOT
63823: AND
63824: PUSH
63825: NOP4
63829: PUSH
63830: NOP4
63834: ARRAY
63835: AND
63836: IFFALSE 63928
// begin tmp := mc_defender [ i ] ;
63838: NOP4
63842: PUSH
63843: NOP4
63847: PUSH
63848: NOP4
63852: ARRAY
63853: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63854: NOP4
63858: PUSH
63859: NOP4
63863: PPUSH
63864: NOP4
63868: PPUSH
63869: EMPTY
63870: PPUSH
63871: NOP4
63875: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
63876: NOP4
63880: PUSH
63881: NOP4
63885: PPUSH
63886: NOP4
63890: PPUSH
63891: LD_INT 1
63893: PPUSH
63894: NOP4
63898: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
63899: NOP4
63903: PPUSH
63904: NOP4
63908: PPUSH
63909: NOP4
63913: PUSH
63914: NOP4
63918: ARRAY
63919: PPUSH
63920: NOP4
// exit ;
63924: POP
63925: POP
63926: GO 63932
// end ; end ;
63928: GO 63248
63930: POP
63931: POP
// end ;
63932: LD_VAR 0 1
63936: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
63937: LD_INT 0
63939: PPUSH
63940: PPUSH
63941: PPUSH
63942: PPUSH
63943: PPUSH
63944: PPUSH
63945: PPUSH
63946: PPUSH
63947: PPUSH
63948: PPUSH
63949: PPUSH
// if not mc_bases then
63950: NOP4
63954: NOT
63955: IFFALSE 63959
// exit ;
63957: GO 65046
// for i = 1 to mc_bases do
63959: NOP4
63963: PUSH
63964: DOUBLE
63965: LD_INT 1
63967: DEC
63968: ST_TO_ADDR
63969: NOP4
63973: PUSH
63974: FOR_TO
63975: IFFALSE 65044
// begin tmp := mc_lab [ i ] ;
63977: NOP4
63981: PUSH
63982: NOP4
63986: PUSH
63987: NOP4
63991: ARRAY
63992: ST_TO_ADDR
// if not tmp then
63993: NOP4
63997: NOT
63998: IFFALSE 64002
// continue ;
64000: GO 63974
// idle_lab := 0 ;
64002: NOP4
64006: PUSH
64007: LD_INT 0
64009: ST_TO_ADDR
// for j in tmp do
64010: NOP4
64014: PUSH
64015: NOP4
64019: PUSH
64020: FOR_IN
64021: IFFALSE 65040
// begin researching := false ;
64023: NOP4
64027: PUSH
64028: LD_INT 0
64030: ST_TO_ADDR
// side := GetSide ( j ) ;
64031: NOP4
64035: PUSH
64036: NOP4
64040: PPUSH
64041: NOP4
64045: ST_TO_ADDR
// if not mc_tech [ side ] then
64046: NOP4
64050: PUSH
64051: NOP4
64055: ARRAY
64056: NOT
64057: IFFALSE 64061
// continue ;
64059: GO 64020
// if BuildingStatus ( j ) = bs_idle then
64061: NOP4
64065: PPUSH
64066: NOP4
64070: PUSH
64071: LD_INT 2
64073: EQUAL
64074: IFFALSE 64262
// begin if idle_lab and UnitsInside ( j ) < 6 then
64076: NOP4
64080: PUSH
64081: NOP4
64085: PPUSH
64086: NOP4
64090: PUSH
64091: LD_INT 6
64093: LESS
64094: AND
64095: IFFALSE 64166
// begin tmp2 := UnitsInside ( idle_lab ) ;
64097: NOP4
64101: PUSH
64102: NOP4
64106: PPUSH
64107: NOP4
64111: ST_TO_ADDR
// if tmp2 then
64112: NOP4
64116: IFFALSE 64158
// for x in tmp2 do
64118: NOP4
64122: PUSH
64123: NOP4
64127: PUSH
64128: FOR_IN
64129: IFFALSE 64156
// begin ComExitBuilding ( x ) ;
64131: NOP4
64135: PPUSH
64136: NOP4
// AddComEnterUnit ( x , j ) ;
64140: NOP4
64144: PPUSH
64145: NOP4
64149: PPUSH
64150: NOP4
// end ;
64154: GO 64128
64156: POP
64157: POP
// idle_lab := 0 ;
64158: NOP4
64162: PUSH
64163: LD_INT 0
64165: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
64166: NOP4
64170: PUSH
64171: NOP4
64175: PUSH
64176: NOP4
64180: ARRAY
64181: PUSH
64182: FOR_IN
64183: IFFALSE 64243
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
64185: NOP4
64189: PPUSH
64190: NOP4
64194: PPUSH
64195: NOP4
64199: PUSH
64200: NOP4
64204: PPUSH
64205: NOP4
64209: PPUSH
64210: NOP4
64214: AND
64215: IFFALSE 64241
// begin researching := true ;
64217: NOP4
64221: PUSH
64222: LD_INT 1
64224: ST_TO_ADDR
// ComResearch ( j , t ) ;
64225: NOP4
64229: PPUSH
64230: NOP4
64234: PPUSH
64235: NOP4
// break ;
64239: GO 64243
// end ;
64241: GO 64182
64243: POP
64244: POP
// if not researching then
64245: NOP4
64249: NOT
64250: IFFALSE 64262
// idle_lab := j ;
64252: NOP4
64256: PUSH
64257: NOP4
64261: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
64262: NOP4
64266: PPUSH
64267: NOP4
64271: PUSH
64272: LD_INT 10
64274: EQUAL
64275: IFFALSE 64863
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
64277: NOP4
64281: PUSH
64282: NOP4
64286: ARRAY
64287: NOT
64288: PUSH
64289: NOP4
64293: PUSH
64294: NOP4
64298: ARRAY
64299: NOT
64300: AND
64301: PUSH
64302: NOP4
64306: PUSH
64307: NOP4
64311: ARRAY
64312: PUSH
64313: LD_INT 1
64315: GREATER
64316: AND
64317: IFFALSE 64448
// begin ComCancel ( j ) ;
64319: NOP4
64323: PPUSH
64324: NOP4
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
64328: NOP4
64332: PUSH
64333: NOP4
64337: PPUSH
64338: NOP4
64342: PPUSH
64343: NOP4
64347: PUSH
64348: NOP4
64352: ARRAY
64353: PPUSH
64354: NOP4
64358: PUSH
64359: NOP4
64363: ARRAY
64364: PUSH
64365: LD_INT 1
64367: MINUS
64368: PPUSH
64369: NOP4
64373: PUSH
64374: NOP4
64378: ARRAY
64379: PPUSH
64380: LD_INT 0
64382: PPUSH
64383: NOP4
64387: PPUSH
64388: NOP4
64392: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
64393: NOP4
64397: PUSH
64398: NOP4
64402: PPUSH
64403: NOP4
64407: PPUSH
64408: NOP4
64412: PUSH
64413: NOP4
64417: ARRAY
64418: PPUSH
64419: NOP4
64423: PUSH
64424: NOP4
64428: ARRAY
64429: PPUSH
64430: LD_INT 1
64432: PPUSH
64433: LD_INT 0
64435: PPUSH
64436: NOP4
64440: PPUSH
64441: NOP4
64445: ST_TO_ADDR
// continue ;
64446: GO 64020
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
64448: NOP4
64452: PUSH
64453: NOP4
64457: ARRAY
64458: PUSH
64459: NOP4
64463: PUSH
64464: NOP4
64468: ARRAY
64469: NOT
64470: AND
64471: IFFALSE 64598
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
64473: NOP4
64477: PUSH
64478: NOP4
64482: PPUSH
64483: NOP4
64487: PUSH
64488: NOP4
64492: PUSH
64493: NOP4
64497: ARRAY
64498: PUSH
64499: LD_INT 1
64501: PLUS
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: PPUSH
64507: NOP4
64511: PUSH
64512: NOP4
64516: ARRAY
64517: PUSH
64518: LD_INT 1
64520: ARRAY
64521: PPUSH
64522: NOP4
64526: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
64527: NOP4
64531: PUSH
64532: NOP4
64536: ARRAY
64537: PUSH
64538: LD_INT 1
64540: ARRAY
64541: PPUSH
64542: LD_INT 112
64544: PPUSH
64545: NOP4
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
64549: NOP4
64553: PUSH
64554: NOP4
64558: PUSH
64559: NOP4
64563: ARRAY
64564: PPUSH
64565: LD_INT 1
64567: PPUSH
64568: NOP4
64572: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
64573: NOP4
64577: PUSH
64578: NOP4
64582: PPUSH
64583: NOP4
64587: PPUSH
64588: NOP4
64592: PPUSH
64593: NOP4
64597: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
64598: NOP4
64602: PUSH
64603: NOP4
64607: ARRAY
64608: PUSH
64609: NOP4
64613: PUSH
64614: NOP4
64618: ARRAY
64619: AND
64620: PUSH
64621: NOP4
64625: PUSH
64626: NOP4
64630: ARRAY
64631: PUSH
64632: LD_INT 1
64634: ARRAY
64635: PPUSH
64636: NOP4
64640: NOT
64641: AND
64642: PUSH
64643: NOP4
64647: PPUSH
64648: NOP4
64652: PUSH
64653: LD_INT 6
64655: EQUAL
64656: AND
64657: IFFALSE 64713
// begin tmp2 := UnitsInside ( j ) ;
64659: NOP4
64663: PUSH
64664: NOP4
64668: PPUSH
64669: NOP4
64673: ST_TO_ADDR
// if tmp2 = 6 then
64674: NOP4
64678: PUSH
64679: LD_INT 6
64681: EQUAL
64682: IFFALSE 64713
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
64684: NOP4
64688: PUSH
64689: LD_INT 1
64691: ARRAY
64692: PPUSH
64693: LD_INT 112
64695: PPUSH
64696: NOP4
// ComExitBuilding ( tmp2 [ 1 ] ) ;
64700: NOP4
64704: PUSH
64705: LD_INT 1
64707: ARRAY
64708: PPUSH
64709: NOP4
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
64713: NOP4
64717: PUSH
64718: NOP4
64722: ARRAY
64723: PUSH
64724: NOP4
64728: PUSH
64729: NOP4
64733: ARRAY
64734: PUSH
64735: LD_INT 1
64737: ARRAY
64738: PPUSH
64739: NOP4
64743: NOT
64744: AND
64745: PUSH
64746: NOP4
64750: PUSH
64751: NOP4
64755: ARRAY
64756: PUSH
64757: LD_INT 1
64759: ARRAY
64760: PPUSH
64761: NOP4
64765: NOT
64766: AND
64767: IFFALSE 64793
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
64769: NOP4
64773: PUSH
64774: NOP4
64778: ARRAY
64779: PUSH
64780: LD_INT 1
64782: ARRAY
64783: PPUSH
64784: NOP4
64788: PPUSH
64789: NOP4
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
64793: NOP4
64797: PUSH
64798: NOP4
64802: ARRAY
64803: PUSH
64804: LD_INT 1
64806: ARRAY
64807: PPUSH
64808: NOP4
64812: PUSH
64813: NOP4
64817: PUSH
64818: NOP4
64822: ARRAY
64823: PUSH
64824: LD_INT 1
64826: ARRAY
64827: PPUSH
64828: NOP4
64832: PPUSH
64833: NOP4
64837: PUSH
64838: LD_INT 3
64840: NONEQUAL
64841: AND
64842: IFFALSE 64863
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
64844: NOP4
64848: PUSH
64849: NOP4
64853: ARRAY
64854: PUSH
64855: LD_INT 1
64857: ARRAY
64858: PPUSH
64859: NOP4
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
64863: NOP4
64867: PPUSH
64868: NOP4
64872: PUSH
64873: LD_INT 6
64875: EQUAL
64876: PUSH
64877: NOP4
64881: PUSH
64882: LD_INT 1
64884: GREATER
64885: AND
64886: IFFALSE 65038
// begin sci := [ ] ;
64888: NOP4
64892: PUSH
64893: EMPTY
64894: ST_TO_ADDR
// for x in ( tmp diff j ) do
64895: NOP4
64899: PUSH
64900: NOP4
64904: PUSH
64905: NOP4
64909: DIFF
64910: PUSH
64911: FOR_IN
64912: IFFALSE 64964
// begin if sci = 6 then
64914: NOP4
64918: PUSH
64919: LD_INT 6
64921: EQUAL
64922: IFFALSE 64926
// break ;
64924: GO 64964
// if BuildingStatus ( x ) = bs_idle then
64926: NOP4
64930: PPUSH
64931: NOP4
64935: PUSH
64936: LD_INT 2
64938: EQUAL
64939: IFFALSE 64962
// sci := sci ^ UnitsInside ( x ) ;
64941: NOP4
64945: PUSH
64946: NOP4
64950: PUSH
64951: NOP4
64955: PPUSH
64956: NOP4
64960: ADD
64961: ST_TO_ADDR
// end ;
64962: GO 64911
64964: POP
64965: POP
// if not sci then
64966: NOP4
64970: NOT
64971: IFFALSE 64975
// continue ;
64973: GO 64020
// for x in sci do
64975: NOP4
64979: PUSH
64980: NOP4
64984: PUSH
64985: FOR_IN
64986: IFFALSE 65036
// if IsInUnit ( x ) and not HasTask ( x ) then
64988: NOP4
64992: PPUSH
64993: NOP4
64997: PUSH
64998: NOP4
65002: PPUSH
65003: NOP4
65007: NOT
65008: AND
65009: IFFALSE 65034
// begin ComExitBuilding ( x ) ;
65011: NOP4
65015: PPUSH
65016: NOP4
// AddComEnterUnit ( x , j ) ;
65020: NOP4
65024: PPUSH
65025: NOP4
65029: PPUSH
65030: NOP4
// end ;
65034: GO 64985
65036: POP
65037: POP
// end ; end ;
65038: GO 64020
65040: POP
65041: POP
// end ;
65042: GO 63974
65044: POP
65045: POP
// end ;
65046: LD_VAR 0 1
65050: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
65051: LD_INT 0
65053: PPUSH
65054: PPUSH
// if not mc_bases then
65055: NOP4
65059: NOT
65060: IFFALSE 65064
// exit ;
65062: GO 65145
// for i = 1 to mc_bases do
65064: NOP4
65068: PUSH
65069: DOUBLE
65070: LD_INT 1
65072: DEC
65073: ST_TO_ADDR
65074: NOP4
65078: PUSH
65079: FOR_TO
65080: IFFALSE 65143
// if mc_mines [ i ] and mc_miners [ i ] then
65082: NOP4
65086: PUSH
65087: NOP4
65091: ARRAY
65092: PUSH
65093: NOP4
65097: PUSH
65098: NOP4
65102: ARRAY
65103: AND
65104: IFFALSE 65141
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
65106: NOP4
65110: PUSH
65111: NOP4
65115: ARRAY
65116: PUSH
65117: LD_INT 1
65119: ARRAY
65120: PPUSH
65121: NOP4
65125: PPUSH
65126: NOP4
65130: PUSH
65131: NOP4
65135: ARRAY
65136: PPUSH
65137: NOP4
65141: GO 65079
65143: POP
65144: POP
// end ;
65145: LD_VAR 0 1
65149: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
65150: LD_INT 0
65152: PPUSH
65153: PPUSH
65154: PPUSH
65155: PPUSH
65156: PPUSH
65157: PPUSH
65158: PPUSH
65159: PPUSH
// if not mc_bases or not mc_parking then
65160: NOP4
65164: NOT
65165: PUSH
65166: NOP4
65170: NOT
65171: OR
65172: IFFALSE 65176
// exit ;
65174: GO 65875
// for i = 1 to mc_bases do
65176: NOP4
65180: PUSH
65181: DOUBLE
65182: LD_INT 1
65184: DEC
65185: ST_TO_ADDR
65186: NOP4
65190: PUSH
65191: FOR_TO
65192: IFFALSE 65873
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
65194: NOP4
65198: PUSH
65199: NOP4
65203: ARRAY
65204: NOT
65205: PUSH
65206: NOP4
65210: PUSH
65211: NOP4
65215: ARRAY
65216: NOT
65217: OR
65218: IFFALSE 65222
// continue ;
65220: GO 65191
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65222: NOP4
65226: PUSH
65227: NOP4
65231: PUSH
65232: NOP4
65236: ARRAY
65237: PUSH
65238: LD_INT 1
65240: ARRAY
65241: PPUSH
65242: NOP4
65246: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65247: NOP4
65251: PUSH
65252: NOP4
65256: PUSH
65257: NOP4
65261: ARRAY
65262: PPUSH
65263: LD_INT 30
65265: PUSH
65266: LD_INT 3
65268: PUSH
65269: EMPTY
65270: LIST
65271: LIST
65272: PPUSH
65273: NOP4
65277: ST_TO_ADDR
// if not fac then
65278: NOP4
65282: NOT
65283: IFFALSE 65334
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65285: NOP4
65289: PUSH
65290: NOP4
65294: PUSH
65295: NOP4
65299: ARRAY
65300: PPUSH
65301: LD_INT 2
65303: PUSH
65304: LD_INT 30
65306: PUSH
65307: LD_INT 0
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: LD_INT 30
65316: PUSH
65317: LD_INT 1
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: LIST
65328: PPUSH
65329: NOP4
65333: ST_TO_ADDR
// if not fac then
65334: NOP4
65338: NOT
65339: IFFALSE 65343
// continue ;
65341: GO 65191
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65343: NOP4
65347: PUSH
65348: NOP4
65352: PUSH
65353: NOP4
65357: ARRAY
65358: PPUSH
65359: LD_INT 22
65361: PUSH
65362: NOP4
65366: PUSH
65367: EMPTY
65368: LIST
65369: LIST
65370: PUSH
65371: LD_INT 21
65373: PUSH
65374: LD_INT 2
65376: PUSH
65377: EMPTY
65378: LIST
65379: LIST
65380: PUSH
65381: LD_INT 3
65383: PUSH
65384: LD_INT 24
65386: PUSH
65387: LD_INT 1000
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: PUSH
65398: EMPTY
65399: LIST
65400: LIST
65401: LIST
65402: PPUSH
65403: NOP4
65407: ST_TO_ADDR
// for j in fac do
65408: NOP4
65412: PUSH
65413: NOP4
65417: PUSH
65418: FOR_IN
65419: IFFALSE 65500
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65421: NOP4
65425: PUSH
65426: NOP4
65430: PUSH
65431: LD_INT 22
65433: PUSH
65434: NOP4
65438: PUSH
65439: EMPTY
65440: LIST
65441: LIST
65442: PUSH
65443: LD_INT 91
65445: PUSH
65446: NOP4
65450: PUSH
65451: LD_INT 15
65453: PUSH
65454: EMPTY
65455: LIST
65456: LIST
65457: LIST
65458: PUSH
65459: LD_INT 21
65461: PUSH
65462: LD_INT 2
65464: PUSH
65465: EMPTY
65466: LIST
65467: LIST
65468: PUSH
65469: LD_INT 3
65471: PUSH
65472: LD_INT 24
65474: PUSH
65475: LD_INT 1000
65477: PUSH
65478: EMPTY
65479: LIST
65480: LIST
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: PPUSH
65492: NOP4
65496: UNION
65497: ST_TO_ADDR
65498: GO 65418
65500: POP
65501: POP
// if not vehs then
65502: NOP4
65506: NOT
65507: IFFALSE 65533
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
65509: NOP4
65513: PUSH
65514: NOP4
65518: PPUSH
65519: NOP4
65523: PPUSH
65524: EMPTY
65525: PPUSH
65526: NOP4
65530: ST_TO_ADDR
// continue ;
65531: GO 65191
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65533: NOP4
65537: PUSH
65538: NOP4
65542: PUSH
65543: NOP4
65547: ARRAY
65548: PPUSH
65549: LD_INT 30
65551: PUSH
65552: LD_INT 3
65554: PUSH
65555: EMPTY
65556: LIST
65557: LIST
65558: PPUSH
65559: NOP4
65563: ST_TO_ADDR
// if tmp then
65564: NOP4
65568: IFFALSE 65671
// begin for j in tmp do
65570: NOP4
65574: PUSH
65575: NOP4
65579: PUSH
65580: FOR_IN
65581: IFFALSE 65669
// for k in UnitsInside ( j ) do
65583: NOP4
65587: PUSH
65588: NOP4
65592: PPUSH
65593: NOP4
65597: PUSH
65598: FOR_IN
65599: IFFALSE 65665
// if k then
65601: NOP4
65605: IFFALSE 65663
// if not k in mc_repair_vehicle [ i ] then
65607: NOP4
65611: PUSH
65612: NOP4
65616: PUSH
65617: NOP4
65621: ARRAY
65622: IN
65623: NOT
65624: IFFALSE 65663
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
65626: NOP4
65630: PUSH
65631: NOP4
65635: PPUSH
65636: NOP4
65640: PPUSH
65641: NOP4
65645: PUSH
65646: NOP4
65650: ARRAY
65651: PUSH
65652: NOP4
65656: UNION
65657: PPUSH
65658: NOP4
65662: ST_TO_ADDR
65663: GO 65598
65665: POP
65666: POP
65667: GO 65580
65669: POP
65670: POP
// end ; if not mc_repair_vehicle [ i ] then
65671: NOP4
65675: PUSH
65676: NOP4
65680: ARRAY
65681: NOT
65682: IFFALSE 65686
// continue ;
65684: GO 65191
// for j in mc_repair_vehicle [ i ] do
65686: NOP4
65690: PUSH
65691: NOP4
65695: PUSH
65696: NOP4
65700: ARRAY
65701: PUSH
65702: FOR_IN
65703: IFFALSE 65869
// begin if GetClass ( j ) <> 3 then
65705: NOP4
65709: PPUSH
65710: NOP4
65714: PUSH
65715: LD_INT 3
65717: NONEQUAL
65718: IFFALSE 65759
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
65720: NOP4
65724: PUSH
65725: NOP4
65729: PPUSH
65730: NOP4
65734: PPUSH
65735: NOP4
65739: PUSH
65740: NOP4
65744: ARRAY
65745: PUSH
65746: NOP4
65750: DIFF
65751: PPUSH
65752: NOP4
65756: ST_TO_ADDR
// continue ;
65757: GO 65702
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
65759: NOP4
65763: PPUSH
65764: NOP4
65768: NOT
65769: PUSH
65770: NOP4
65774: PUSH
65775: NOP4
65779: PUSH
65780: NOP4
65784: ARRAY
65785: PUSH
65786: LD_INT 1
65788: ARRAY
65789: IN
65790: NOT
65791: AND
65792: PUSH
65793: NOP4
65797: PUSH
65798: NOP4
65802: PUSH
65803: NOP4
65807: ARRAY
65808: PUSH
65809: LD_INT 2
65811: ARRAY
65812: IN
65813: NOT
65814: AND
65815: IFFALSE 65867
// begin if IsInUnit ( j ) then
65817: NOP4
65821: PPUSH
65822: NOP4
65826: IFFALSE 65837
// ComExitBuilding ( j ) ;
65828: NOP4
65832: PPUSH
65833: NOP4
// if not HasTask ( j ) then
65837: NOP4
65841: PPUSH
65842: NOP4
65846: NOT
65847: IFFALSE 65867
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
65849: NOP4
65853: PPUSH
65854: NOP4
65858: PUSH
65859: LD_INT 1
65861: ARRAY
65862: PPUSH
65863: NOP4
// end ; end ;
65867: GO 65702
65869: POP
65870: POP
// end ;
65871: GO 65191
65873: POP
65874: POP
// end ;
65875: LD_VAR 0 1
65879: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
65880: LD_INT 0
65882: PPUSH
65883: PPUSH
65884: PPUSH
65885: PPUSH
65886: PPUSH
65887: PPUSH
65888: PPUSH
65889: PPUSH
65890: PPUSH
65891: PPUSH
65892: PPUSH
// if not mc_bases then
65893: NOP4
65897: NOT
65898: IFFALSE 65902
// exit ;
65900: GO 66704
// for i = 1 to mc_bases do
65902: NOP4
65906: PUSH
65907: DOUBLE
65908: LD_INT 1
65910: DEC
65911: ST_TO_ADDR
65912: NOP4
65916: PUSH
65917: FOR_TO
65918: IFFALSE 66702
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
65920: NOP4
65924: PUSH
65925: NOP4
65929: ARRAY
65930: NOT
65931: PUSH
65932: NOP4
65936: PUSH
65937: NOP4
65941: ARRAY
65942: PUSH
65943: LD_INT 1
65945: ARRAY
65946: OR
65947: PUSH
65948: NOP4
65952: PUSH
65953: NOP4
65957: ARRAY
65958: PUSH
65959: LD_INT 2
65961: ARRAY
65962: OR
65963: PUSH
65964: NOP4
65968: PUSH
65969: NOP4
65973: ARRAY
65974: PPUSH
65975: LD_INT 1
65977: PPUSH
65978: NOP4
65982: NOT
65983: OR
65984: PUSH
65985: NOP4
65989: PUSH
65990: NOP4
65994: ARRAY
65995: OR
65996: IFFALSE 66000
// continue ;
65998: GO 65917
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
66000: NOP4
66004: PUSH
66005: NOP4
66009: PUSH
66010: NOP4
66014: ARRAY
66015: PPUSH
66016: LD_INT 25
66018: PUSH
66019: LD_INT 4
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 50
66028: PUSH
66029: EMPTY
66030: LIST
66031: PUSH
66032: LD_INT 3
66034: PUSH
66035: LD_INT 60
66037: PUSH
66038: EMPTY
66039: LIST
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: LIST
66049: PPUSH
66050: NOP4
66054: PUSH
66055: NOP4
66059: PUSH
66060: NOP4
66064: ARRAY
66065: DIFF
66066: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66067: NOP4
66071: PUSH
66072: NOP4
66076: PUSH
66077: NOP4
66081: ARRAY
66082: PPUSH
66083: LD_INT 2
66085: PUSH
66086: LD_INT 30
66088: PUSH
66089: LD_INT 0
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 30
66098: PUSH
66099: LD_INT 1
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: EMPTY
66107: LIST
66108: LIST
66109: LIST
66110: PPUSH
66111: NOP4
66115: ST_TO_ADDR
// if not tmp or not dep then
66116: NOP4
66120: NOT
66121: PUSH
66122: NOP4
66126: NOT
66127: OR
66128: IFFALSE 66132
// continue ;
66130: GO 65917
// side := GetSide ( tmp [ 1 ] ) ;
66132: NOP4
66136: PUSH
66137: NOP4
66141: PUSH
66142: LD_INT 1
66144: ARRAY
66145: PPUSH
66146: NOP4
66150: ST_TO_ADDR
// dep := dep [ 1 ] ;
66151: NOP4
66155: PUSH
66156: NOP4
66160: PUSH
66161: LD_INT 1
66163: ARRAY
66164: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
66165: NOP4
66169: PUSH
66170: NOP4
66174: PUSH
66175: NOP4
66179: ARRAY
66180: PPUSH
66181: LD_INT 22
66183: PUSH
66184: LD_INT 0
66186: PUSH
66187: EMPTY
66188: LIST
66189: LIST
66190: PUSH
66191: LD_INT 25
66193: PUSH
66194: LD_INT 12
66196: PUSH
66197: EMPTY
66198: LIST
66199: LIST
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PPUSH
66205: NOP4
66209: PUSH
66210: LD_INT 22
66212: PUSH
66213: LD_INT 0
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PUSH
66220: LD_INT 25
66222: PUSH
66223: LD_INT 12
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 91
66232: PUSH
66233: NOP4
66237: PUSH
66238: LD_INT 20
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: LIST
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: LIST
66250: PPUSH
66251: NOP4
66255: UNION
66256: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
66257: NOP4
66261: PUSH
66262: NOP4
66266: PUSH
66267: NOP4
66271: ARRAY
66272: PPUSH
66273: LD_INT 81
66275: PUSH
66276: NOP4
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PPUSH
66285: NOP4
66289: ST_TO_ADDR
// if not apes or danger_at_area then
66290: NOP4
66294: NOT
66295: PUSH
66296: NOP4
66300: OR
66301: IFFALSE 66351
// begin if mc_taming [ i ] then
66303: NOP4
66307: PUSH
66308: NOP4
66312: ARRAY
66313: IFFALSE 66349
// begin MC_Reset ( i , 121 ) ;
66315: NOP4
66319: PPUSH
66320: LD_INT 121
66322: PPUSH
66323: NOP4
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66327: NOP4
66331: PUSH
66332: NOP4
66336: PPUSH
66337: NOP4
66341: PPUSH
66342: EMPTY
66343: PPUSH
66344: NOP4
66348: ST_TO_ADDR
// end ; continue ;
66349: GO 65917
// end ; for j in tmp do
66351: NOP4
66355: PUSH
66356: NOP4
66360: PUSH
66361: FOR_IN
66362: IFFALSE 66698
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
66364: NOP4
66368: PUSH
66369: NOP4
66373: PUSH
66374: NOP4
66378: ARRAY
66379: IN
66380: NOT
66381: PUSH
66382: NOP4
66386: PUSH
66387: NOP4
66391: ARRAY
66392: PUSH
66393: LD_INT 3
66395: LESS
66396: AND
66397: IFFALSE 66455
// begin SetTag ( j , 121 ) ;
66399: NOP4
66403: PPUSH
66404: LD_INT 121
66406: PPUSH
66407: NOP4
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
66411: NOP4
66415: PUSH
66416: NOP4
66420: PPUSH
66421: NOP4
66425: PUSH
66426: NOP4
66430: PUSH
66431: NOP4
66435: ARRAY
66436: PUSH
66437: LD_INT 1
66439: PLUS
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: PPUSH
66445: NOP4
66449: PPUSH
66450: NOP4
66454: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
66455: NOP4
66459: PUSH
66460: NOP4
66464: PUSH
66465: NOP4
66469: ARRAY
66470: IN
66471: IFFALSE 66696
// begin if GetClass ( j ) <> 4 then
66473: NOP4
66477: PPUSH
66478: NOP4
66482: PUSH
66483: LD_INT 4
66485: NONEQUAL
66486: IFFALSE 66539
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
66488: NOP4
66492: PUSH
66493: NOP4
66497: PPUSH
66498: NOP4
66502: PPUSH
66503: NOP4
66507: PUSH
66508: NOP4
66512: ARRAY
66513: PUSH
66514: NOP4
66518: DIFF
66519: PPUSH
66520: NOP4
66524: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66525: NOP4
66529: PPUSH
66530: LD_INT 0
66532: PPUSH
66533: NOP4
// continue ;
66537: GO 66361
// end ; if IsInUnit ( j ) then
66539: NOP4
66543: PPUSH
66544: NOP4
66548: IFFALSE 66559
// ComExitBuilding ( j ) ;
66550: NOP4
66554: PPUSH
66555: NOP4
// ape := NearestUnitToUnit ( apes , j ) ;
66559: NOP4
66563: PUSH
66564: NOP4
66568: PPUSH
66569: NOP4
66573: PPUSH
66574: NOP4
66578: ST_TO_ADDR
// if not ape then
66579: NOP4
66583: NOT
66584: IFFALSE 66588
// break ;
66586: GO 66698
// x := GetX ( ape ) ;
66588: NOP4
66592: PUSH
66593: NOP4
66597: PPUSH
66598: NOP4
66602: ST_TO_ADDR
// y := GetY ( ape ) ;
66603: NOP4
66607: PUSH
66608: NOP4
66612: PPUSH
66613: NOP4
66617: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66618: NOP4
66622: PPUSH
66623: NOP4
66627: PPUSH
66628: NOP4
66632: NOT
66633: PUSH
66634: NOP4
66638: PPUSH
66639: NOP4
66643: PPUSH
66644: NOP4
66648: PPUSH
66649: LD_INT 20
66651: PPUSH
66652: NOP4
66656: PUSH
66657: LD_INT 4
66659: ARRAY
66660: OR
66661: IFFALSE 66665
// break ;
66663: GO 66698
// if not HasTask ( j ) then
66665: NOP4
66669: PPUSH
66670: NOP4
66674: NOT
66675: IFFALSE 66696
// ComTameXY ( j , x , y ) ;
66677: NOP4
66681: PPUSH
66682: NOP4
66686: PPUSH
66687: NOP4
66691: PPUSH
66692: NOP4
// end ; end ;
66696: GO 66361
66698: POP
66699: POP
// end ;
66700: GO 65917
66702: POP
66703: POP
// end ;
66704: LD_VAR 0 1
66708: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
66709: LD_INT 0
66711: PPUSH
66712: PPUSH
66713: PPUSH
66714: PPUSH
66715: PPUSH
66716: PPUSH
66717: PPUSH
66718: PPUSH
// if not mc_bases then
66719: NOP4
66723: NOT
66724: IFFALSE 66728
// exit ;
66726: GO 67354
// for i = 1 to mc_bases do
66728: NOP4
66732: PUSH
66733: DOUBLE
66734: LD_INT 1
66736: DEC
66737: ST_TO_ADDR
66738: NOP4
66742: PUSH
66743: FOR_TO
66744: IFFALSE 67352
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
66746: NOP4
66750: PUSH
66751: NOP4
66755: ARRAY
66756: NOT
66757: PUSH
66758: NOP4
66762: PUSH
66763: NOP4
66767: ARRAY
66768: PPUSH
66769: LD_INT 25
66771: PUSH
66772: LD_INT 12
66774: PUSH
66775: EMPTY
66776: LIST
66777: LIST
66778: PPUSH
66779: NOP4
66783: NOT
66784: OR
66785: IFFALSE 66789
// continue ;
66787: GO 66743
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
66789: NOP4
66793: PUSH
66794: NOP4
66798: PUSH
66799: NOP4
66803: ARRAY
66804: PUSH
66805: LD_INT 1
66807: ARRAY
66808: PPUSH
66809: NOP4
66813: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
66814: NOP4
66818: PPUSH
66819: LD_INT 2
66821: PPUSH
66822: NOP4
66826: IFFALSE 67079
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66828: NOP4
66832: PUSH
66833: NOP4
66837: PUSH
66838: NOP4
66842: ARRAY
66843: PPUSH
66844: LD_INT 25
66846: PUSH
66847: LD_INT 16
66849: PUSH
66850: EMPTY
66851: LIST
66852: LIST
66853: PPUSH
66854: NOP4
66858: ST_TO_ADDR
// if tmp < 6 then
66859: NOP4
66863: PUSH
66864: LD_INT 6
66866: LESS
66867: IFFALSE 67079
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66869: NOP4
66873: PUSH
66874: NOP4
66878: PUSH
66879: NOP4
66883: ARRAY
66884: PPUSH
66885: LD_INT 2
66887: PUSH
66888: LD_INT 30
66890: PUSH
66891: LD_INT 0
66893: PUSH
66894: EMPTY
66895: LIST
66896: LIST
66897: PUSH
66898: LD_INT 30
66900: PUSH
66901: LD_INT 1
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: PUSH
66908: EMPTY
66909: LIST
66910: LIST
66911: LIST
66912: PPUSH
66913: NOP4
66917: ST_TO_ADDR
// if depot then
66918: NOP4
66922: IFFALSE 67079
// begin selected := 0 ;
66924: NOP4
66928: PUSH
66929: LD_INT 0
66931: ST_TO_ADDR
// for j in depot do
66932: NOP4
66936: PUSH
66937: NOP4
66941: PUSH
66942: FOR_IN
66943: IFFALSE 66974
// begin if UnitsInside ( j ) < 6 then
66945: NOP4
66949: PPUSH
66950: NOP4
66954: PUSH
66955: LD_INT 6
66957: LESS
66958: IFFALSE 66972
// begin selected := j ;
66960: NOP4
66964: PUSH
66965: NOP4
66969: ST_TO_ADDR
// break ;
66970: GO 66974
// end ; end ;
66972: GO 66942
66974: POP
66975: POP
// if selected then
66976: NOP4
66980: IFFALSE 67079
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66982: NOP4
66986: PUSH
66987: NOP4
66991: PUSH
66992: NOP4
66996: ARRAY
66997: PPUSH
66998: LD_INT 25
67000: PUSH
67001: LD_INT 12
67003: PUSH
67004: EMPTY
67005: LIST
67006: LIST
67007: PPUSH
67008: NOP4
67012: PUSH
67013: FOR_IN
67014: IFFALSE 67077
// if not HasTask ( j ) then
67016: NOP4
67020: PPUSH
67021: NOP4
67025: NOT
67026: IFFALSE 67075
// begin if not IsInUnit ( j ) then
67028: NOP4
67032: PPUSH
67033: NOP4
67037: NOT
67038: IFFALSE 67054
// ComEnterUnit ( j , selected ) ;
67040: NOP4
67044: PPUSH
67045: NOP4
67049: PPUSH
67050: NOP4
// AddComChangeProfession ( j , 16 ) ;
67054: NOP4
67058: PPUSH
67059: LD_INT 16
67061: PPUSH
67062: NOP4
// AddComExitBuilding ( j ) ;
67066: NOP4
67070: PPUSH
67071: NOP4
// end ;
67075: GO 67013
67077: POP
67078: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
67079: NOP4
67083: PPUSH
67084: LD_INT 11
67086: PPUSH
67087: NOP4
67091: IFFALSE 67350
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
67093: NOP4
67097: PUSH
67098: NOP4
67102: PUSH
67103: NOP4
67107: ARRAY
67108: PPUSH
67109: LD_INT 25
67111: PUSH
67112: LD_INT 16
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PPUSH
67119: NOP4
67123: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
67124: NOP4
67128: PUSH
67129: LD_INT 6
67131: GREATEREQUAL
67132: PUSH
67133: NOP4
67137: PPUSH
67138: LD_INT 2
67140: PPUSH
67141: NOP4
67145: NOT
67146: OR
67147: IFFALSE 67350
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
67149: NOP4
67153: PUSH
67154: NOP4
67158: PUSH
67159: NOP4
67163: ARRAY
67164: PPUSH
67165: LD_INT 2
67167: PUSH
67168: LD_INT 30
67170: PUSH
67171: LD_INT 4
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 30
67180: PUSH
67181: LD_INT 5
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: LIST
67192: PPUSH
67193: NOP4
67197: ST_TO_ADDR
// if barracks then
67198: NOP4
67202: IFFALSE 67350
// begin selected := 0 ;
67204: NOP4
67208: PUSH
67209: LD_INT 0
67211: ST_TO_ADDR
// for j in barracks do
67212: NOP4
67216: PUSH
67217: NOP4
67221: PUSH
67222: FOR_IN
67223: IFFALSE 67254
// begin if UnitsInside ( j ) < 6 then
67225: NOP4
67229: PPUSH
67230: NOP4
67234: PUSH
67235: LD_INT 6
67237: LESS
67238: IFFALSE 67252
// begin selected := j ;
67240: NOP4
67244: PUSH
67245: NOP4
67249: ST_TO_ADDR
// break ;
67250: GO 67254
// end ; end ;
67252: GO 67222
67254: POP
67255: POP
// if selected then
67256: NOP4
67260: IFFALSE 67350
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
67262: NOP4
67266: PUSH
67267: NOP4
67271: PUSH
67272: NOP4
67276: ARRAY
67277: PPUSH
67278: LD_INT 25
67280: PUSH
67281: LD_INT 12
67283: PUSH
67284: EMPTY
67285: LIST
67286: LIST
67287: PPUSH
67288: NOP4
67292: PUSH
67293: FOR_IN
67294: IFFALSE 67348
// if not IsInUnit ( j ) and not HasTask ( j ) then
67296: NOP4
67300: PPUSH
67301: NOP4
67305: NOT
67306: PUSH
67307: NOP4
67311: PPUSH
67312: NOP4
67316: NOT
67317: AND
67318: IFFALSE 67346
// begin ComEnterUnit ( j , selected ) ;
67320: NOP4
67324: PPUSH
67325: NOP4
67329: PPUSH
67330: NOP4
// AddComChangeProfession ( j , 15 ) ;
67334: NOP4
67338: PPUSH
67339: LD_INT 15
67341: PPUSH
67342: NOP4
// end ;
67346: GO 67293
67348: POP
67349: POP
// end ; end ; end ; end ; end ;
67350: GO 66743
67352: POP
67353: POP
// end ;
67354: LD_VAR 0 1
67358: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
67359: LD_INT 0
67361: PPUSH
67362: PPUSH
67363: PPUSH
67364: PPUSH
// if not mc_bases then
67365: NOP4
67369: NOT
67370: IFFALSE 67374
// exit ;
67372: GO 67552
// for i = 1 to mc_bases do
67374: NOP4
67378: PUSH
67379: DOUBLE
67380: LD_INT 1
67382: DEC
67383: ST_TO_ADDR
67384: NOP4
67388: PUSH
67389: FOR_TO
67390: IFFALSE 67550
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
67392: NOP4
67396: PUSH
67397: NOP4
67401: PUSH
67402: NOP4
67406: ARRAY
67407: PPUSH
67408: LD_INT 25
67410: PUSH
67411: LD_INT 9
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PPUSH
67418: NOP4
67422: ST_TO_ADDR
// if not tmp then
67423: NOP4
67427: NOT
67428: IFFALSE 67432
// continue ;
67430: GO 67389
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
67432: NOP4
67436: PUSH
67437: NOP4
67441: ARRAY
67442: PPUSH
67443: LD_INT 29
67445: PPUSH
67446: NOP4
67450: NOT
67451: PUSH
67452: NOP4
67456: PUSH
67457: NOP4
67461: ARRAY
67462: PPUSH
67463: LD_INT 28
67465: PPUSH
67466: NOP4
67470: NOT
67471: AND
67472: IFFALSE 67476
// continue ;
67474: GO 67389
// for j in tmp do
67476: NOP4
67480: PUSH
67481: NOP4
67485: PUSH
67486: FOR_IN
67487: IFFALSE 67546
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
67489: NOP4
67493: PUSH
67494: NOP4
67498: PUSH
67499: NOP4
67503: ARRAY
67504: PUSH
67505: LD_INT 1
67507: ARRAY
67508: IN
67509: NOT
67510: PUSH
67511: NOP4
67515: PUSH
67516: NOP4
67520: PUSH
67521: NOP4
67525: ARRAY
67526: PUSH
67527: LD_INT 2
67529: ARRAY
67530: IN
67531: NOT
67532: AND
67533: IFFALSE 67544
// ComSpaceTimeShoot ( j ) ;
67535: NOP4
67539: PPUSH
67540: NOP4
67544: GO 67486
67546: POP
67547: POP
// end ;
67548: GO 67389
67550: POP
67551: POP
// end ;
67552: LD_VAR 0 1
67556: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
67557: LD_INT 0
67559: PPUSH
67560: PPUSH
67561: PPUSH
67562: PPUSH
67563: PPUSH
67564: PPUSH
67565: PPUSH
67566: PPUSH
67567: PPUSH
// if not mc_bases then
67568: NOP4
67572: NOT
67573: IFFALSE 67577
// exit ;
67575: GO 68199
// for i = 1 to mc_bases do
67577: NOP4
67581: PUSH
67582: DOUBLE
67583: LD_INT 1
67585: DEC
67586: ST_TO_ADDR
67587: NOP4
67591: PUSH
67592: FOR_TO
67593: IFFALSE 68197
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
67595: NOP4
67599: PUSH
67600: NOP4
67604: ARRAY
67605: NOT
67606: PUSH
67607: LD_INT 38
67609: PPUSH
67610: NOP4
67614: PUSH
67615: NOP4
67619: ARRAY
67620: PPUSH
67621: NOP4
67625: PUSH
67626: LD_INT 2
67628: NONEQUAL
67629: OR
67630: IFFALSE 67634
// continue ;
67632: GO 67592
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
67634: NOP4
67638: PUSH
67639: NOP4
67643: PUSH
67644: NOP4
67648: ARRAY
67649: PPUSH
67650: LD_INT 30
67652: PUSH
67653: LD_INT 34
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PPUSH
67660: NOP4
67664: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
67665: NOP4
67669: PUSH
67670: NOP4
67674: PUSH
67675: NOP4
67679: ARRAY
67680: PPUSH
67681: LD_INT 25
67683: PUSH
67684: LD_INT 4
67686: PUSH
67687: EMPTY
67688: LIST
67689: LIST
67690: PPUSH
67691: NOP4
67695: PPUSH
67696: LD_INT 0
67698: PPUSH
67699: NOP4
67703: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
67704: NOP4
67708: NOT
67709: PUSH
67710: NOP4
67714: NOT
67715: OR
67716: PUSH
67717: NOP4
67721: PUSH
67722: NOP4
67726: ARRAY
67727: PPUSH
67728: LD_INT 124
67730: PPUSH
67731: NOP4
67735: OR
67736: IFFALSE 67740
// continue ;
67738: GO 67592
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
67740: NOP4
67744: PUSH
67745: NOP4
67749: ARRAY
67750: PUSH
67751: NOP4
67755: PUSH
67756: NOP4
67760: ARRAY
67761: LESS
67762: PUSH
67763: NOP4
67767: PUSH
67768: NOP4
67772: ARRAY
67773: PUSH
67774: NOP4
67778: LESS
67779: AND
67780: IFFALSE 68195
// begin tmp := sci [ 1 ] ;
67782: NOP4
67786: PUSH
67787: NOP4
67791: PUSH
67792: LD_INT 1
67794: ARRAY
67795: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
67796: NOP4
67800: PPUSH
67801: LD_INT 124
67803: PPUSH
67804: NOP4
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
67808: NOP4
67812: PUSH
67813: DOUBLE
67814: NOP4
67818: PUSH
67819: NOP4
67823: ARRAY
67824: INC
67825: ST_TO_ADDR
67826: NOP4
67830: PUSH
67831: NOP4
67835: ARRAY
67836: PUSH
67837: FOR_DOWNTO
67838: IFFALSE 68181
// begin if IsInUnit ( tmp ) then
67840: NOP4
67844: PPUSH
67845: NOP4
67849: IFFALSE 67860
// ComExitBuilding ( tmp ) ;
67851: NOP4
67855: PPUSH
67856: NOP4
// repeat wait ( 0 0$1 ) ;
67860: LD_INT 35
67862: PPUSH
67863: NOP4
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
67867: NOP4
67871: PPUSH
67872: NOP4
67876: NOT
67877: PUSH
67878: NOP4
67882: PPUSH
67883: NOP4
67887: NOT
67888: AND
67889: IFFALSE 67860
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
67891: NOP4
67895: PUSH
67896: NOP4
67900: PPUSH
67901: NOP4
67905: PUSH
67906: NOP4
67910: PPUSH
67911: NOP4
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
67920: LD_INT 35
67922: PPUSH
67923: NOP4
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
67927: NOP4
67931: PUSH
67932: NOP4
67936: PUSH
67937: NOP4
67941: ARRAY
67942: PUSH
67943: NOP4
67947: ARRAY
67948: PUSH
67949: LD_INT 1
67951: ARRAY
67952: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
67953: NOP4
67957: PUSH
67958: NOP4
67962: PUSH
67963: NOP4
67967: ARRAY
67968: PUSH
67969: NOP4
67973: ARRAY
67974: PUSH
67975: LD_INT 2
67977: ARRAY
67978: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
67979: NOP4
67983: PPUSH
67984: LD_INT 10
67986: PPUSH
67987: NOP4
67991: PUSH
67992: LD_INT 4
67994: ARRAY
67995: IFFALSE 68033
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
67997: NOP4
68001: PPUSH
68002: NOP4
68006: PUSH
68007: LD_INT 1
68009: ARRAY
68010: PPUSH
68011: NOP4
68015: PUSH
68016: LD_INT 2
68018: ARRAY
68019: PPUSH
68020: NOP4
// wait ( 0 0$10 ) ;
68024: LD_INT 350
68026: PPUSH
68027: NOP4
// end else
68031: GO 68059
// begin ComMoveXY ( tmp , x , y ) ;
68033: NOP4
68037: PPUSH
68038: NOP4
68042: PPUSH
68043: NOP4
68047: PPUSH
68048: NOP4
// wait ( 0 0$3 ) ;
68052: LD_INT 105
68054: PPUSH
68055: NOP4
// end ; until IsAt ( tmp , x , y ) ;
68059: NOP4
68063: PPUSH
68064: NOP4
68068: PPUSH
68069: NOP4
68073: PPUSH
68074: NOP4
68078: IFFALSE 67920
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
68080: NOP4
68084: PPUSH
68085: NOP4
68089: PPUSH
68090: NOP4
68094: PPUSH
68095: NOP4
68099: PUSH
68100: NOP4
68104: ARRAY
68105: PPUSH
68106: NOP4
// repeat wait ( 0 0$1 ) ;
68110: LD_INT 35
68112: PPUSH
68113: NOP4
// until not HasTask ( tmp ) ;
68117: NOP4
68121: PPUSH
68122: NOP4
68126: NOT
68127: IFFALSE 68110
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
68129: NOP4
68133: PUSH
68134: NOP4
68138: PPUSH
68139: NOP4
68143: PUSH
68144: NOP4
68148: PUSH
68149: NOP4
68153: ARRAY
68154: PUSH
68155: LD_INT 1
68157: PLUS
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PPUSH
68163: NOP4
68167: PUSH
68168: NOP4
68172: ARRAY
68173: PPUSH
68174: NOP4
68178: ST_TO_ADDR
// end ;
68179: GO 67837
68181: POP
68182: POP
// MC_Reset ( i , 124 ) ;
68183: NOP4
68187: PPUSH
68188: LD_INT 124
68190: PPUSH
68191: NOP4
// end ; end ;
68195: GO 67592
68197: POP
68198: POP
// end ;
68199: LD_VAR 0 1
68203: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
68204: LD_INT 0
68206: PPUSH
68207: PPUSH
68208: PPUSH
// if not mc_bases then
68209: NOP4
68213: NOT
68214: IFFALSE 68218
// exit ;
68216: GO 68824
// for i = 1 to mc_bases do
68218: NOP4
68222: PUSH
68223: DOUBLE
68224: LD_INT 1
68226: DEC
68227: ST_TO_ADDR
68228: NOP4
68232: PUSH
68233: FOR_TO
68234: IFFALSE 68822
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
68236: NOP4
68240: PUSH
68241: NOP4
68245: PUSH
68246: NOP4
68250: ARRAY
68251: PPUSH
68252: LD_INT 25
68254: PUSH
68255: LD_INT 4
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PPUSH
68262: NOP4
68266: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68267: NOP4
68271: NOT
68272: PUSH
68273: NOP4
68277: PUSH
68278: NOP4
68282: ARRAY
68283: NOT
68284: OR
68285: PUSH
68286: NOP4
68290: PUSH
68291: NOP4
68295: ARRAY
68296: PPUSH
68297: LD_INT 2
68299: PUSH
68300: LD_INT 30
68302: PUSH
68303: LD_INT 0
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: LD_INT 30
68312: PUSH
68313: LD_INT 1
68315: PUSH
68316: EMPTY
68317: LIST
68318: LIST
68319: PUSH
68320: EMPTY
68321: LIST
68322: LIST
68323: LIST
68324: PPUSH
68325: NOP4
68329: NOT
68330: OR
68331: IFFALSE 68381
// begin if mc_deposits_finder [ i ] then
68333: NOP4
68337: PUSH
68338: NOP4
68342: ARRAY
68343: IFFALSE 68379
// begin MC_Reset ( i , 125 ) ;
68345: NOP4
68349: PPUSH
68350: LD_INT 125
68352: PPUSH
68353: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
68357: NOP4
68361: PUSH
68362: NOP4
68366: PPUSH
68367: NOP4
68371: PPUSH
68372: EMPTY
68373: PPUSH
68374: NOP4
68378: ST_TO_ADDR
// end ; continue ;
68379: GO 68233
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
68381: NOP4
68385: PUSH
68386: NOP4
68390: ARRAY
68391: PUSH
68392: LD_INT 1
68394: ARRAY
68395: PUSH
68396: LD_INT 3
68398: ARRAY
68399: PUSH
68400: LD_INT 1
68402: EQUAL
68403: PUSH
68404: LD_INT 20
68406: PPUSH
68407: NOP4
68411: PUSH
68412: NOP4
68416: ARRAY
68417: PPUSH
68418: NOP4
68422: PUSH
68423: LD_INT 2
68425: NONEQUAL
68426: AND
68427: IFFALSE 68477
// begin if mc_deposits_finder [ i ] then
68429: NOP4
68433: PUSH
68434: NOP4
68438: ARRAY
68439: IFFALSE 68475
// begin MC_Reset ( i , 125 ) ;
68441: NOP4
68445: PPUSH
68446: LD_INT 125
68448: PPUSH
68449: NOP4
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
68453: NOP4
68457: PUSH
68458: NOP4
68462: PPUSH
68463: NOP4
68467: PPUSH
68468: EMPTY
68469: PPUSH
68470: NOP4
68474: ST_TO_ADDR
// end ; continue ;
68475: GO 68233
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
68477: NOP4
68481: PUSH
68482: NOP4
68486: ARRAY
68487: PUSH
68488: LD_INT 1
68490: ARRAY
68491: PUSH
68492: LD_INT 1
68494: ARRAY
68495: PPUSH
68496: NOP4
68500: PUSH
68501: NOP4
68505: ARRAY
68506: PUSH
68507: LD_INT 1
68509: ARRAY
68510: PUSH
68511: LD_INT 2
68513: ARRAY
68514: PPUSH
68515: NOP4
68519: PUSH
68520: NOP4
68524: ARRAY
68525: PPUSH
68526: NOP4
68530: IFFALSE 68573
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
68532: NOP4
68536: PUSH
68537: NOP4
68541: PPUSH
68542: NOP4
68546: PPUSH
68547: NOP4
68551: PUSH
68552: NOP4
68556: ARRAY
68557: PPUSH
68558: LD_INT 1
68560: PPUSH
68561: NOP4
68565: PPUSH
68566: NOP4
68570: ST_TO_ADDR
68571: GO 68820
// begin if not mc_deposits_finder [ i ] then
68573: NOP4
68577: PUSH
68578: NOP4
68582: ARRAY
68583: NOT
68584: IFFALSE 68636
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
68586: NOP4
68590: PUSH
68591: NOP4
68595: PPUSH
68596: NOP4
68600: PPUSH
68601: NOP4
68605: PUSH
68606: LD_INT 1
68608: ARRAY
68609: PUSH
68610: EMPTY
68611: LIST
68612: PPUSH
68613: NOP4
68617: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
68618: NOP4
68622: PUSH
68623: LD_INT 1
68625: ARRAY
68626: PPUSH
68627: LD_INT 125
68629: PPUSH
68630: NOP4
// end else
68634: GO 68820
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
68636: NOP4
68640: PUSH
68641: NOP4
68645: ARRAY
68646: PUSH
68647: LD_INT 1
68649: ARRAY
68650: PPUSH
68651: NOP4
68655: IFFALSE 68678
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
68657: NOP4
68661: PUSH
68662: NOP4
68666: ARRAY
68667: PUSH
68668: LD_INT 1
68670: ARRAY
68671: PPUSH
68672: NOP4
68676: GO 68820
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
68678: NOP4
68682: PUSH
68683: NOP4
68687: ARRAY
68688: PUSH
68689: LD_INT 1
68691: ARRAY
68692: PPUSH
68693: NOP4
68697: NOT
68698: PUSH
68699: NOP4
68703: PUSH
68704: NOP4
68708: ARRAY
68709: PUSH
68710: LD_INT 1
68712: ARRAY
68713: PPUSH
68714: NOP4
68718: PUSH
68719: NOP4
68723: ARRAY
68724: PUSH
68725: LD_INT 1
68727: ARRAY
68728: PUSH
68729: LD_INT 1
68731: ARRAY
68732: PPUSH
68733: NOP4
68737: PUSH
68738: NOP4
68742: ARRAY
68743: PUSH
68744: LD_INT 1
68746: ARRAY
68747: PUSH
68748: LD_INT 2
68750: ARRAY
68751: PPUSH
68752: NOP4
68756: PUSH
68757: LD_INT 6
68759: GREATER
68760: AND
68761: IFFALSE 68820
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
68763: NOP4
68767: PUSH
68768: NOP4
68772: ARRAY
68773: PUSH
68774: LD_INT 1
68776: ARRAY
68777: PPUSH
68778: NOP4
68782: PUSH
68783: NOP4
68787: ARRAY
68788: PUSH
68789: LD_INT 1
68791: ARRAY
68792: PUSH
68793: LD_INT 1
68795: ARRAY
68796: PPUSH
68797: NOP4
68801: PUSH
68802: NOP4
68806: ARRAY
68807: PUSH
68808: LD_INT 1
68810: ARRAY
68811: PUSH
68812: LD_INT 2
68814: ARRAY
68815: PPUSH
68816: NOP4
// end ; end ; end ;
68820: GO 68233
68822: POP
68823: POP
// end ;
68824: LD_VAR 0 1
68828: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
68829: LD_INT 0
68831: PPUSH
68832: PPUSH
68833: PPUSH
68834: PPUSH
68835: PPUSH
68836: PPUSH
68837: PPUSH
68838: PPUSH
68839: PPUSH
68840: PPUSH
68841: PPUSH
// if not mc_bases then
68842: NOP4
68846: NOT
68847: IFFALSE 68851
// exit ;
68849: GO 69791
// for i = 1 to mc_bases do
68851: NOP4
68855: PUSH
68856: DOUBLE
68857: LD_INT 1
68859: DEC
68860: ST_TO_ADDR
68861: NOP4
68865: PUSH
68866: FOR_TO
68867: IFFALSE 69789
// begin if not mc_bases [ i ] or mc_scan [ i ] then
68869: NOP4
68873: PUSH
68874: NOP4
68878: ARRAY
68879: NOT
68880: PUSH
68881: NOP4
68885: PUSH
68886: NOP4
68890: ARRAY
68891: OR
68892: IFFALSE 68896
// continue ;
68894: GO 68866
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
68896: NOP4
68900: PUSH
68901: NOP4
68905: PUSH
68906: NOP4
68910: ARRAY
68911: PUSH
68912: LD_INT 1
68914: ARRAY
68915: PPUSH
68916: NOP4
68920: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
68921: NOP4
68925: PUSH
68926: LD_INT 3
68928: EQUAL
68929: PUSH
68930: NOP4
68934: PUSH
68935: NOP4
68939: ARRAY
68940: PUSH
68941: NOP4
68945: PUSH
68946: NOP4
68950: ARRAY
68951: UNION
68952: PPUSH
68953: LD_INT 33
68955: PUSH
68956: LD_INT 2
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PPUSH
68963: NOP4
68967: NOT
68968: OR
68969: IFFALSE 68973
// continue ;
68971: GO 68866
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
68973: NOP4
68977: PUSH
68978: NOP4
68982: PUSH
68983: NOP4
68987: ARRAY
68988: PPUSH
68989: LD_INT 30
68991: PUSH
68992: LD_INT 36
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: PPUSH
68999: NOP4
69003: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
69004: NOP4
69008: PUSH
69009: NOP4
69013: PUSH
69014: NOP4
69018: ARRAY
69019: PPUSH
69020: LD_INT 34
69022: PUSH
69023: LD_INT 31
69025: PUSH
69026: EMPTY
69027: LIST
69028: LIST
69029: PPUSH
69030: NOP4
69034: ST_TO_ADDR
// if not cts and not mcts then
69035: NOP4
69039: NOT
69040: PUSH
69041: NOP4
69045: NOT
69046: AND
69047: IFFALSE 69051
// continue ;
69049: GO 68866
// x := cts ;
69051: NOP4
69055: PUSH
69056: NOP4
69060: ST_TO_ADDR
// if not x then
69061: NOP4
69065: NOT
69066: IFFALSE 69078
// x := mcts ;
69068: NOP4
69072: PUSH
69073: NOP4
69077: ST_TO_ADDR
// if not x then
69078: NOP4
69082: NOT
69083: IFFALSE 69087
// continue ;
69085: GO 68866
// if mc_remote_driver [ i ] then
69087: NOP4
69091: PUSH
69092: NOP4
69096: ARRAY
69097: IFFALSE 69484
// for j in mc_remote_driver [ i ] do
69099: NOP4
69103: PUSH
69104: NOP4
69108: PUSH
69109: NOP4
69113: ARRAY
69114: PUSH
69115: FOR_IN
69116: IFFALSE 69482
// begin if GetClass ( j ) <> 3 then
69118: NOP4
69122: PPUSH
69123: NOP4
69127: PUSH
69128: LD_INT 3
69130: NONEQUAL
69131: IFFALSE 69184
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
69133: NOP4
69137: PUSH
69138: NOP4
69142: PPUSH
69143: NOP4
69147: PPUSH
69148: NOP4
69152: PUSH
69153: NOP4
69157: ARRAY
69158: PUSH
69159: NOP4
69163: DIFF
69164: PPUSH
69165: NOP4
69169: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69170: NOP4
69174: PPUSH
69175: LD_INT 0
69177: PPUSH
69178: NOP4
// continue ;
69182: GO 69115
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
69184: NOP4
69188: PUSH
69189: NOP4
69193: ARRAY
69194: PPUSH
69195: LD_INT 34
69197: PUSH
69198: LD_INT 31
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 58
69207: PUSH
69208: EMPTY
69209: LIST
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PPUSH
69215: NOP4
69219: PUSH
69220: NOP4
69224: PPUSH
69225: NOP4
69229: NOT
69230: AND
69231: IFFALSE 69302
// begin if IsInUnit ( j ) then
69233: NOP4
69237: PPUSH
69238: NOP4
69242: IFFALSE 69253
// ComExitBuilding ( j ) ;
69244: NOP4
69248: PPUSH
69249: NOP4
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
69253: NOP4
69257: PPUSH
69258: NOP4
69262: PUSH
69263: NOP4
69267: ARRAY
69268: PPUSH
69269: LD_INT 34
69271: PUSH
69272: LD_INT 31
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PUSH
69279: LD_INT 58
69281: PUSH
69282: EMPTY
69283: LIST
69284: PUSH
69285: EMPTY
69286: LIST
69287: LIST
69288: PPUSH
69289: NOP4
69293: PUSH
69294: LD_INT 1
69296: ARRAY
69297: PPUSH
69298: NOP4
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
69302: NOP4
69306: PPUSH
69307: NOP4
69311: NOT
69312: PUSH
69313: NOP4
69317: PPUSH
69318: NOP4
69322: PPUSH
69323: NOP4
69327: PUSH
69328: LD_INT 36
69330: NONEQUAL
69331: PUSH
69332: NOP4
69336: PPUSH
69337: NOP4
69341: NOT
69342: AND
69343: OR
69344: IFFALSE 69480
// begin if IsInUnit ( j ) then
69346: NOP4
69350: PPUSH
69351: NOP4
69355: IFFALSE 69366
// ComExitBuilding ( j ) ;
69357: NOP4
69361: PPUSH
69362: NOP4
// ct := 0 ;
69366: NOP4
69370: PUSH
69371: LD_INT 0
69373: ST_TO_ADDR
// for k in x do
69374: NOP4
69378: PUSH
69379: NOP4
69383: PUSH
69384: FOR_IN
69385: IFFALSE 69458
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
69387: NOP4
69391: PPUSH
69392: NOP4
69396: PUSH
69397: LD_INT 31
69399: EQUAL
69400: PUSH
69401: NOP4
69405: PPUSH
69406: NOP4
69410: NOT
69411: AND
69412: PUSH
69413: NOP4
69417: PPUSH
69418: NOP4
69422: PUSH
69423: LD_INT 36
69425: EQUAL
69426: PUSH
69427: NOP4
69431: PPUSH
69432: NOP4
69436: PUSH
69437: LD_INT 3
69439: LESS
69440: AND
69441: OR
69442: IFFALSE 69456
// begin ct := k ;
69444: NOP4
69448: PUSH
69449: NOP4
69453: ST_TO_ADDR
// break ;
69454: GO 69458
// end ;
69456: GO 69384
69458: POP
69459: POP
// if ct then
69460: NOP4
69464: IFFALSE 69480
// ComEnterUnit ( j , ct ) ;
69466: NOP4
69470: PPUSH
69471: NOP4
69475: PPUSH
69476: NOP4
// end ; end ;
69480: GO 69115
69482: POP
69483: POP
// places := 0 ;
69484: NOP4
69488: PUSH
69489: LD_INT 0
69491: ST_TO_ADDR
// for j = 1 to x do
69492: NOP4
69496: PUSH
69497: DOUBLE
69498: LD_INT 1
69500: DEC
69501: ST_TO_ADDR
69502: NOP4
69506: PUSH
69507: FOR_TO
69508: IFFALSE 69584
// if GetWeapon ( x [ j ] ) = ar_control_tower then
69510: NOP4
69514: PUSH
69515: NOP4
69519: ARRAY
69520: PPUSH
69521: NOP4
69525: PUSH
69526: LD_INT 31
69528: EQUAL
69529: IFFALSE 69547
// places := places + 1 else
69531: NOP4
69535: PUSH
69536: NOP4
69540: PUSH
69541: LD_INT 1
69543: PLUS
69544: ST_TO_ADDR
69545: GO 69582
// if GetBType ( x [ j ] ) = b_control_tower then
69547: NOP4
69551: PUSH
69552: NOP4
69556: ARRAY
69557: PPUSH
69558: NOP4
69562: PUSH
69563: LD_INT 36
69565: EQUAL
69566: IFFALSE 69582
// places := places + 3 ;
69568: NOP4
69572: PUSH
69573: NOP4
69577: PUSH
69578: LD_INT 3
69580: PLUS
69581: ST_TO_ADDR
69582: GO 69507
69584: POP
69585: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
69586: NOP4
69590: PUSH
69591: LD_INT 0
69593: EQUAL
69594: PUSH
69595: NOP4
69599: PUSH
69600: NOP4
69604: PUSH
69605: NOP4
69609: ARRAY
69610: LESSEQUAL
69611: OR
69612: IFFALSE 69616
// continue ;
69614: GO 68866
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
69616: NOP4
69620: PUSH
69621: NOP4
69625: PUSH
69626: NOP4
69630: ARRAY
69631: PPUSH
69632: LD_INT 25
69634: PUSH
69635: LD_INT 3
69637: PUSH
69638: EMPTY
69639: LIST
69640: LIST
69641: PPUSH
69642: NOP4
69646: PUSH
69647: NOP4
69651: PUSH
69652: NOP4
69656: ARRAY
69657: DIFF
69658: PPUSH
69659: LD_INT 3
69661: PPUSH
69662: NOP4
69666: ST_TO_ADDR
// for j in tmp do
69667: NOP4
69671: PUSH
69672: NOP4
69676: PUSH
69677: FOR_IN
69678: IFFALSE 69713
// if GetTag ( j ) > 0 then
69680: NOP4
69684: PPUSH
69685: NOP4
69689: PUSH
69690: LD_INT 0
69692: GREATER
69693: IFFALSE 69711
// tmp := tmp diff j ;
69695: NOP4
69699: PUSH
69700: NOP4
69704: PUSH
69705: NOP4
69709: DIFF
69710: ST_TO_ADDR
69711: GO 69677
69713: POP
69714: POP
// if not tmp then
69715: NOP4
69719: NOT
69720: IFFALSE 69724
// continue ;
69722: GO 68866
// if places then
69724: NOP4
69728: IFFALSE 69787
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
69730: NOP4
69734: PUSH
69735: NOP4
69739: PPUSH
69740: NOP4
69744: PPUSH
69745: NOP4
69749: PUSH
69750: NOP4
69754: ARRAY
69755: PUSH
69756: NOP4
69760: PUSH
69761: LD_INT 1
69763: ARRAY
69764: UNION
69765: PPUSH
69766: NOP4
69770: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
69771: NOP4
69775: PUSH
69776: LD_INT 1
69778: ARRAY
69779: PPUSH
69780: LD_INT 126
69782: PPUSH
69783: NOP4
// end ; end ;
69787: GO 68866
69789: POP
69790: POP
// end ;
69791: LD_VAR 0 1
69795: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
69796: LD_INT 0
69798: PPUSH
69799: PPUSH
69800: PPUSH
69801: PPUSH
69802: PPUSH
69803: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
69804: NOP4
69808: NOT
69809: PUSH
69810: NOP4
69814: NOT
69815: OR
69816: PUSH
69817: NOP4
69821: NOT
69822: OR
69823: PUSH
69824: NOP4
69828: PUSH
69829: LD_INT 1
69831: PUSH
69832: LD_INT 2
69834: PUSH
69835: LD_INT 3
69837: PUSH
69838: LD_INT 4
69840: PUSH
69841: LD_INT 5
69843: PUSH
69844: LD_INT 8
69846: PUSH
69847: LD_INT 9
69849: PUSH
69850: LD_INT 15
69852: PUSH
69853: LD_INT 16
69855: PUSH
69856: EMPTY
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: IN
69867: NOT
69868: OR
69869: IFFALSE 69873
// exit ;
69871: GO 70773
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
69873: NOP4
69877: PUSH
69878: NOP4
69882: PPUSH
69883: LD_INT 21
69885: PUSH
69886: LD_INT 3
69888: PUSH
69889: EMPTY
69890: LIST
69891: LIST
69892: PUSH
69893: LD_INT 24
69895: PUSH
69896: LD_INT 250
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PPUSH
69907: NOP4
69911: ST_TO_ADDR
// case class of 1 , 15 :
69912: NOP4
69916: PUSH
69917: LD_INT 1
69919: DOUBLE
69920: EQUAL
69921: IFTRUE 69931
69923: LD_INT 15
69925: DOUBLE
69926: EQUAL
69927: IFTRUE 69931
69929: GO 70016
69931: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
69932: NOP4
69936: PUSH
69937: NOP4
69941: PPUSH
69942: LD_INT 2
69944: PUSH
69945: LD_INT 30
69947: PUSH
69948: LD_INT 32
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 30
69957: PUSH
69958: LD_INT 31
69960: PUSH
69961: EMPTY
69962: LIST
69963: LIST
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: LIST
69969: PPUSH
69970: NOP4
69974: PUSH
69975: NOP4
69979: PPUSH
69980: LD_INT 2
69982: PUSH
69983: LD_INT 30
69985: PUSH
69986: LD_INT 4
69988: PUSH
69989: EMPTY
69990: LIST
69991: LIST
69992: PUSH
69993: LD_INT 30
69995: PUSH
69996: LD_INT 5
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: LIST
70007: PPUSH
70008: NOP4
70012: ADD
70013: ST_TO_ADDR
70014: GO 70262
70016: LD_INT 2
70018: DOUBLE
70019: EQUAL
70020: IFTRUE 70030
70022: LD_INT 16
70024: DOUBLE
70025: EQUAL
70026: IFTRUE 70030
70028: GO 70076
70030: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
70031: NOP4
70035: PUSH
70036: NOP4
70040: PPUSH
70041: LD_INT 2
70043: PUSH
70044: LD_INT 30
70046: PUSH
70047: LD_INT 0
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: PUSH
70054: LD_INT 30
70056: PUSH
70057: LD_INT 1
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: LIST
70068: PPUSH
70069: NOP4
70073: ST_TO_ADDR
70074: GO 70262
70076: LD_INT 3
70078: DOUBLE
70079: EQUAL
70080: IFTRUE 70084
70082: GO 70130
70084: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
70085: NOP4
70089: PUSH
70090: NOP4
70094: PPUSH
70095: LD_INT 2
70097: PUSH
70098: LD_INT 30
70100: PUSH
70101: LD_INT 2
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 30
70110: PUSH
70111: LD_INT 3
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: LIST
70122: PPUSH
70123: NOP4
70127: ST_TO_ADDR
70128: GO 70262
70130: LD_INT 4
70132: DOUBLE
70133: EQUAL
70134: IFTRUE 70138
70136: GO 70195
70138: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
70139: NOP4
70143: PUSH
70144: NOP4
70148: PPUSH
70149: LD_INT 2
70151: PUSH
70152: LD_INT 30
70154: PUSH
70155: LD_INT 6
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: PUSH
70162: LD_INT 30
70164: PUSH
70165: LD_INT 7
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: PUSH
70172: LD_INT 30
70174: PUSH
70175: LD_INT 8
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: PPUSH
70188: NOP4
70192: ST_TO_ADDR
70193: GO 70262
70195: LD_INT 5
70197: DOUBLE
70198: EQUAL
70199: IFTRUE 70215
70201: LD_INT 8
70203: DOUBLE
70204: EQUAL
70205: IFTRUE 70215
70207: LD_INT 9
70209: DOUBLE
70210: EQUAL
70211: IFTRUE 70215
70213: GO 70261
70215: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
70216: NOP4
70220: PUSH
70221: NOP4
70225: PPUSH
70226: LD_INT 2
70228: PUSH
70229: LD_INT 30
70231: PUSH
70232: LD_INT 4
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: LD_INT 30
70241: PUSH
70242: LD_INT 5
70244: PUSH
70245: EMPTY
70246: LIST
70247: LIST
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: LIST
70253: PPUSH
70254: NOP4
70258: ST_TO_ADDR
70259: GO 70262
70261: POP
// if not tmp then
70262: NOP4
70266: NOT
70267: IFFALSE 70271
// exit ;
70269: GO 70773
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
70271: NOP4
70275: PUSH
70276: LD_INT 1
70278: PUSH
70279: LD_INT 15
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: IN
70286: PUSH
70287: NOP4
70291: PUSH
70292: NOP4
70296: ARRAY
70297: AND
70298: IFFALSE 70454
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
70300: NOP4
70304: PUSH
70305: NOP4
70309: PUSH
70310: NOP4
70314: ARRAY
70315: PUSH
70316: LD_INT 1
70318: ARRAY
70319: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
70320: NOP4
70324: PUSH
70325: NOP4
70329: PUSH
70330: NOP4
70334: ARRAY
70335: IN
70336: NOT
70337: IFFALSE 70452
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
70339: NOP4
70343: PUSH
70344: NOP4
70348: PPUSH
70349: NOP4
70353: PUSH
70354: NOP4
70358: PUSH
70359: NOP4
70363: ARRAY
70364: PUSH
70365: LD_INT 1
70367: PLUS
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PPUSH
70373: NOP4
70377: PPUSH
70378: NOP4
70382: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
70383: NOP4
70387: PUSH
70388: NOP4
70392: PPUSH
70393: NOP4
70397: PPUSH
70398: NOP4
70402: PUSH
70403: NOP4
70407: ARRAY
70408: PUSH
70409: NOP4
70413: DIFF
70414: PPUSH
70415: NOP4
70419: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
70420: NOP4
70424: PPUSH
70425: NOP4
70429: PUSH
70430: NOP4
70434: ARRAY
70435: PUSH
70436: NOP4
70440: PUSH
70441: NOP4
70445: ARRAY
70446: ARRAY
70447: PPUSH
70448: NOP4
// end ; exit ;
70452: GO 70773
// end ; if tmp > 1 then
70454: NOP4
70458: PUSH
70459: LD_INT 1
70461: GREATER
70462: IFFALSE 70566
// for i = 2 to tmp do
70464: NOP4
70468: PUSH
70469: DOUBLE
70470: LD_INT 2
70472: DEC
70473: ST_TO_ADDR
70474: NOP4
70478: PUSH
70479: FOR_TO
70480: IFFALSE 70564
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
70482: NOP4
70486: PUSH
70487: NOP4
70491: ARRAY
70492: PPUSH
70493: NOP4
70497: PUSH
70498: LD_INT 6
70500: EQUAL
70501: IFFALSE 70562
// begin x := tmp [ i ] ;
70503: NOP4
70507: PUSH
70508: NOP4
70512: PUSH
70513: NOP4
70517: ARRAY
70518: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
70519: NOP4
70523: PUSH
70524: NOP4
70528: PPUSH
70529: NOP4
70533: PPUSH
70534: NOP4
70538: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
70539: NOP4
70543: PUSH
70544: NOP4
70548: PPUSH
70549: LD_INT 1
70551: PPUSH
70552: NOP4
70556: PPUSH
70557: NOP4
70561: ST_TO_ADDR
// end ;
70562: GO 70479
70564: POP
70565: POP
// for i in tmp do
70566: NOP4
70570: PUSH
70571: NOP4
70575: PUSH
70576: FOR_IN
70577: IFFALSE 70646
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
70579: NOP4
70583: PPUSH
70584: NOP4
70588: PUSH
70589: LD_INT 6
70591: LESS
70592: PUSH
70593: NOP4
70597: PPUSH
70598: NOP4
70602: PUSH
70603: LD_INT 31
70605: PUSH
70606: LD_INT 32
70608: PUSH
70609: EMPTY
70610: LIST
70611: LIST
70612: IN
70613: NOT
70614: AND
70615: PUSH
70616: NOP4
70620: PPUSH
70621: NOP4
70625: PUSH
70626: LD_INT 0
70628: EQUAL
70629: OR
70630: IFFALSE 70644
// begin j := i ;
70632: NOP4
70636: PUSH
70637: NOP4
70641: ST_TO_ADDR
// break ;
70642: GO 70646
// end ; end ;
70644: GO 70576
70646: POP
70647: POP
// if j then
70648: NOP4
70652: IFFALSE 70670
// ComEnterUnit ( unit , j ) else
70654: NOP4
70658: PPUSH
70659: NOP4
70663: PPUSH
70664: NOP4
70668: GO 70773
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70670: NOP4
70674: PUSH
70675: NOP4
70679: PPUSH
70680: LD_INT 2
70682: PUSH
70683: LD_INT 30
70685: PUSH
70686: LD_INT 0
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: LD_INT 30
70695: PUSH
70696: LD_INT 1
70698: PUSH
70699: EMPTY
70700: LIST
70701: LIST
70702: PUSH
70703: EMPTY
70704: LIST
70705: LIST
70706: LIST
70707: PPUSH
70708: NOP4
70712: ST_TO_ADDR
// if depot then
70713: NOP4
70717: IFFALSE 70773
// begin depot := NearestUnitToUnit ( depot , unit ) ;
70719: NOP4
70723: PUSH
70724: NOP4
70728: PPUSH
70729: NOP4
70733: PPUSH
70734: NOP4
70738: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
70739: NOP4
70743: PPUSH
70744: NOP4
70748: PPUSH
70749: NOP4
70753: PUSH
70754: LD_INT 10
70756: GREATER
70757: IFFALSE 70773
// ComStandNearbyBuilding ( unit , depot ) ;
70759: NOP4
70763: PPUSH
70764: NOP4
70768: PPUSH
70769: NOP4
// end ; end ; end ;
70773: LD_VAR 0 5
70777: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
70778: LD_INT 0
70780: PPUSH
70781: PPUSH
70782: PPUSH
70783: PPUSH
// if not mc_bases then
70784: NOP4
70788: NOT
70789: IFFALSE 70793
// exit ;
70791: GO 71032
// for i = 1 to mc_bases do
70793: NOP4
70797: PUSH
70798: DOUBLE
70799: LD_INT 1
70801: DEC
70802: ST_TO_ADDR
70803: NOP4
70807: PUSH
70808: FOR_TO
70809: IFFALSE 71030
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
70811: NOP4
70815: PUSH
70816: NOP4
70820: PUSH
70821: NOP4
70825: ARRAY
70826: PPUSH
70827: LD_INT 21
70829: PUSH
70830: LD_INT 1
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PPUSH
70837: NOP4
70841: PUSH
70842: NOP4
70846: PUSH
70847: NOP4
70851: ARRAY
70852: UNION
70853: ST_TO_ADDR
// if not tmp then
70854: NOP4
70858: NOT
70859: IFFALSE 70863
// continue ;
70861: GO 70808
// for j in tmp do
70863: NOP4
70867: PUSH
70868: NOP4
70872: PUSH
70873: FOR_IN
70874: IFFALSE 71026
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
70876: NOP4
70880: PPUSH
70881: NOP4
70885: NOT
70886: PUSH
70887: NOP4
70891: PPUSH
70892: NOP4
70896: NOT
70897: AND
70898: PUSH
70899: NOP4
70903: PPUSH
70904: NOP4
70908: NOT
70909: AND
70910: PUSH
70911: NOP4
70915: PPUSH
70916: NOP4
70920: NOT
70921: AND
70922: PUSH
70923: NOP4
70927: PUSH
70928: NOP4
70932: PUSH
70933: NOP4
70937: ARRAY
70938: PUSH
70939: LD_INT 1
70941: ARRAY
70942: IN
70943: NOT
70944: AND
70945: PUSH
70946: NOP4
70950: PUSH
70951: NOP4
70955: PUSH
70956: NOP4
70960: ARRAY
70961: PUSH
70962: LD_INT 2
70964: ARRAY
70965: IN
70966: NOT
70967: AND
70968: PUSH
70969: NOP4
70973: PUSH
70974: NOP4
70978: PUSH
70979: NOP4
70983: ARRAY
70984: IN
70985: NOT
70986: AND
70987: IFFALSE 71024
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
70989: NOP4
70993: PPUSH
70994: NOP4
70998: PUSH
70999: NOP4
71003: ARRAY
71004: PPUSH
71005: NOP4
71009: PPUSH
71010: NOP4
71014: PPUSH
71015: NOP4
71019: PPUSH
71020: NOP4
// end ;
71024: GO 70873
71026: POP
71027: POP
// end ;
71028: GO 70808
71030: POP
71031: POP
// end ;
71032: LD_VAR 0 1
71036: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
71037: LD_INT 0
71039: PPUSH
71040: PPUSH
71041: PPUSH
71042: PPUSH
71043: PPUSH
71044: PPUSH
// if not mc_bases [ base ] then
71045: NOP4
71049: PUSH
71050: NOP4
71054: ARRAY
71055: NOT
71056: IFFALSE 71060
// exit ;
71058: GO 71242
// tmp := [ ] ;
71060: NOP4
71064: PUSH
71065: EMPTY
71066: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
71067: NOP4
71071: PUSH
71072: NOP4
71076: PPUSH
71077: LD_INT 0
71079: PPUSH
71080: NOP4
71084: ST_TO_ADDR
// if not list then
71085: NOP4
71089: NOT
71090: IFFALSE 71094
// exit ;
71092: GO 71242
// for i = 1 to amount do
71094: NOP4
71098: PUSH
71099: DOUBLE
71100: LD_INT 1
71102: DEC
71103: ST_TO_ADDR
71104: NOP4
71108: PUSH
71109: FOR_TO
71110: IFFALSE 71190
// begin x := rand ( 1 , list [ 1 ] ) ;
71112: NOP4
71116: PUSH
71117: LD_INT 1
71119: PPUSH
71120: NOP4
71124: PUSH
71125: LD_INT 1
71127: ARRAY
71128: PPUSH
71129: NOP4
71133: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
71134: NOP4
71138: PUSH
71139: NOP4
71143: PPUSH
71144: NOP4
71148: PPUSH
71149: NOP4
71153: PUSH
71154: LD_INT 1
71156: ARRAY
71157: PUSH
71158: NOP4
71162: ARRAY
71163: PUSH
71164: NOP4
71168: PUSH
71169: LD_INT 2
71171: ARRAY
71172: PUSH
71173: NOP4
71177: ARRAY
71178: PUSH
71179: EMPTY
71180: LIST
71181: LIST
71182: PPUSH
71183: NOP4
71187: ST_TO_ADDR
// end ;
71188: GO 71109
71190: POP
71191: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
71192: NOP4
71196: PUSH
71197: NOP4
71201: PPUSH
71202: NOP4
71206: PPUSH
71207: NOP4
71211: PPUSH
71212: NOP4
71216: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
71217: NOP4
71221: PUSH
71222: NOP4
71226: PPUSH
71227: NOP4
71231: PPUSH
71232: NOP4
71236: PPUSH
71237: NOP4
71241: ST_TO_ADDR
// end ;
71242: LD_VAR 0 4
71246: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
71247: LD_INT 0
71249: PPUSH
// if not mc_bases [ base ] then
71250: NOP4
71254: PUSH
71255: NOP4
71259: ARRAY
71260: NOT
71261: IFFALSE 71265
// exit ;
71263: GO 71290
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
71265: NOP4
71269: PUSH
71270: NOP4
71274: PPUSH
71275: NOP4
71279: PPUSH
71280: NOP4
71284: PPUSH
71285: NOP4
71289: ST_TO_ADDR
// end ;
71290: LD_VAR 0 3
71294: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
71295: LD_INT 0
71297: PPUSH
// if not mc_bases [ base ] then
71298: NOP4
71302: PUSH
71303: NOP4
71307: ARRAY
71308: NOT
71309: IFFALSE 71313
// exit ;
71311: GO 71350
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
71313: NOP4
71317: PUSH
71318: NOP4
71322: PPUSH
71323: NOP4
71327: PPUSH
71328: NOP4
71332: PUSH
71333: NOP4
71337: ARRAY
71338: PUSH
71339: NOP4
71343: UNION
71344: PPUSH
71345: NOP4
71349: ST_TO_ADDR
// end ;
71350: LD_VAR 0 3
71354: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
71355: LD_INT 0
71357: PPUSH
// if not mc_bases [ base ] then
71358: NOP4
71362: PUSH
71363: NOP4
71367: ARRAY
71368: NOT
71369: IFFALSE 71373
// exit ;
71371: GO 71398
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
71373: NOP4
71377: PUSH
71378: NOP4
71382: PPUSH
71383: NOP4
71387: PPUSH
71388: NOP4
71392: PPUSH
71393: NOP4
71397: ST_TO_ADDR
// end ;
71398: LD_VAR 0 3
71402: RET
// export function MC_InsertProduceList ( base , components ) ; begin
71403: LD_INT 0
71405: PPUSH
// if not mc_bases [ base ] then
71406: NOP4
71410: PUSH
71411: NOP4
71415: ARRAY
71416: NOT
71417: IFFALSE 71421
// exit ;
71419: GO 71458
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
71421: NOP4
71425: PUSH
71426: NOP4
71430: PPUSH
71431: NOP4
71435: PPUSH
71436: NOP4
71440: PUSH
71441: NOP4
71445: ARRAY
71446: PUSH
71447: NOP4
71451: ADD
71452: PPUSH
71453: NOP4
71457: ST_TO_ADDR
// end ;
71458: LD_VAR 0 3
71462: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
71463: LD_INT 0
71465: PPUSH
// if not mc_bases [ base ] then
71466: NOP4
71470: PUSH
71471: NOP4
71475: ARRAY
71476: NOT
71477: IFFALSE 71481
// exit ;
71479: GO 71535
// mc_defender := Replace ( mc_defender , base , deflist ) ;
71481: NOP4
71485: PUSH
71486: NOP4
71490: PPUSH
71491: NOP4
71495: PPUSH
71496: NOP4
71500: PPUSH
71501: NOP4
71505: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
71506: NOP4
71510: PUSH
71511: NOP4
71515: PPUSH
71516: NOP4
71520: PPUSH
71521: NOP4
71525: PUSH
71526: LD_INT 0
71528: PLUS
71529: PPUSH
71530: NOP4
71534: ST_TO_ADDR
// end ;
71535: LD_VAR 0 3
71539: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
71540: LD_INT 0
71542: PPUSH
// if not mc_bases [ base ] then
71543: NOP4
71547: PUSH
71548: NOP4
71552: ARRAY
71553: NOT
71554: IFFALSE 71558
// exit ;
71556: GO 71583
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
71558: NOP4
71562: PUSH
71563: NOP4
71567: PPUSH
71568: NOP4
71572: PPUSH
71573: NOP4
71577: PPUSH
71578: NOP4
71582: ST_TO_ADDR
// end ;
71583: LD_VAR 0 3
71587: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
71588: LD_INT 0
71590: PPUSH
71591: PPUSH
71592: PPUSH
71593: PPUSH
// if not mc_bases [ base ] then
71594: NOP4
71598: PUSH
71599: NOP4
71603: ARRAY
71604: NOT
71605: IFFALSE 71609
// exit ;
71607: GO 71674
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
71609: NOP4
71613: PUSH
71614: NOP4
71618: PPUSH
71619: NOP4
71623: PUSH
71624: NOP4
71628: PUSH
71629: NOP4
71633: ARRAY
71634: PUSH
71635: LD_INT 1
71637: PLUS
71638: PUSH
71639: EMPTY
71640: LIST
71641: LIST
71642: PPUSH
71643: NOP4
71647: PUSH
71648: NOP4
71652: PUSH
71653: NOP4
71657: PUSH
71658: NOP4
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: PPUSH
71669: NOP4
71673: ST_TO_ADDR
// end ;
71674: LD_VAR 0 5
71678: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
71679: LD_INT 0
71681: PPUSH
// if not mc_bases [ base ] then
71682: NOP4
71686: PUSH
71687: NOP4
71691: ARRAY
71692: NOT
71693: IFFALSE 71697
// exit ;
71695: GO 71722
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
71697: NOP4
71701: PUSH
71702: NOP4
71706: PPUSH
71707: NOP4
71711: PPUSH
71712: NOP4
71716: PPUSH
71717: NOP4
71721: ST_TO_ADDR
// end ;
71722: LD_VAR 0 3
71726: RET
// export function MC_GetMinesField ( base ) ; begin
71727: LD_INT 0
71729: PPUSH
// result := mc_mines [ base ] ;
71730: NOP4
71734: PUSH
71735: NOP4
71739: PUSH
71740: NOP4
71744: ARRAY
71745: ST_TO_ADDR
// end ;
71746: LD_VAR 0 2
71750: RET
// export function MC_GetProduceList ( base ) ; begin
71751: LD_INT 0
71753: PPUSH
// result := mc_produce [ base ] ;
71754: NOP4
71758: PUSH
71759: NOP4
71763: PUSH
71764: NOP4
71768: ARRAY
71769: ST_TO_ADDR
// end ;
71770: LD_VAR 0 2
71774: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
71775: LD_INT 0
71777: PPUSH
71778: PPUSH
// if not mc_bases then
71779: NOP4
71783: NOT
71784: IFFALSE 71788
// exit ;
71786: GO 71853
// if mc_bases [ base ] then
71788: NOP4
71792: PUSH
71793: NOP4
71797: ARRAY
71798: IFFALSE 71853
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71800: NOP4
71804: PUSH
71805: NOP4
71809: PUSH
71810: NOP4
71814: ARRAY
71815: PPUSH
71816: LD_INT 30
71818: PUSH
71819: NOP4
71823: PUSH
71824: EMPTY
71825: LIST
71826: LIST
71827: PPUSH
71828: NOP4
71832: ST_TO_ADDR
// if result then
71833: NOP4
71837: IFFALSE 71853
// result := result [ 1 ] ;
71839: NOP4
71843: PUSH
71844: NOP4
71848: PUSH
71849: LD_INT 1
71851: ARRAY
71852: ST_TO_ADDR
// end ; end ;
71853: LD_VAR 0 3
71857: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
71858: LD_INT 0
71860: PPUSH
71861: PPUSH
// if not mc_bases then
71862: NOP4
71866: NOT
71867: IFFALSE 71871
// exit ;
71869: GO 71916
// if mc_bases [ base ] then
71871: NOP4
71875: PUSH
71876: NOP4
71880: ARRAY
71881: IFFALSE 71916
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71883: NOP4
71887: PUSH
71888: NOP4
71892: PUSH
71893: NOP4
71897: ARRAY
71898: PPUSH
71899: LD_INT 30
71901: PUSH
71902: NOP4
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PPUSH
71911: NOP4
71915: ST_TO_ADDR
// end ;
71916: LD_VAR 0 3
71920: RET
// export function MC_SetTame ( base , area ) ; begin
71921: LD_INT 0
71923: PPUSH
// if not mc_bases or not base then
71924: NOP4
71928: NOT
71929: PUSH
71930: NOP4
71934: NOT
71935: OR
71936: IFFALSE 71940
// exit ;
71938: GO 71965
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
71940: NOP4
71944: PUSH
71945: NOP4
71949: PPUSH
71950: NOP4
71954: PPUSH
71955: NOP4
71959: PPUSH
71960: NOP4
71964: ST_TO_ADDR
// end ;
71965: LD_VAR 0 3
71969: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
71970: LD_INT 0
71972: PPUSH
71973: PPUSH
// if not mc_bases or not base then
71974: NOP4
71978: NOT
71979: PUSH
71980: NOP4
71984: NOT
71985: OR
71986: IFFALSE 71990
// exit ;
71988: GO 72092
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71990: NOP4
71994: PUSH
71995: NOP4
71999: PUSH
72000: NOP4
72004: ARRAY
72005: PPUSH
72006: LD_INT 30
72008: PUSH
72009: NOP4
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PPUSH
72018: NOP4
72022: ST_TO_ADDR
// if not tmp then
72023: NOP4
72027: NOT
72028: IFFALSE 72032
// exit ;
72030: GO 72092
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
72032: NOP4
72036: PUSH
72037: NOP4
72041: PPUSH
72042: NOP4
72046: PPUSH
72047: NOP4
72051: PUSH
72052: NOP4
72056: ARRAY
72057: PPUSH
72058: NOP4
72062: PUSH
72063: NOP4
72067: ARRAY
72068: PUSH
72069: LD_INT 1
72071: PLUS
72072: PPUSH
72073: NOP4
72077: PUSH
72078: LD_INT 1
72080: ARRAY
72081: PPUSH
72082: NOP4
72086: PPUSH
72087: NOP4
72091: ST_TO_ADDR
// end ;
72092: LD_VAR 0 3
72096: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
72097: LD_INT 0
72099: PPUSH
72100: PPUSH
// if not mc_bases or not base or not kinds then
72101: NOP4
72105: NOT
72106: PUSH
72107: NOP4
72111: NOT
72112: OR
72113: PUSH
72114: NOP4
72118: NOT
72119: OR
72120: IFFALSE 72124
// exit ;
72122: GO 72185
// for i in kinds do
72124: NOP4
72128: PUSH
72129: NOP4
72133: PUSH
72134: FOR_IN
72135: IFFALSE 72183
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
72137: NOP4
72141: PUSH
72142: NOP4
72146: PPUSH
72147: NOP4
72151: PUSH
72152: NOP4
72156: PUSH
72157: NOP4
72161: ARRAY
72162: PUSH
72163: LD_INT 1
72165: PLUS
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PPUSH
72171: NOP4
72175: PPUSH
72176: NOP4
72180: ST_TO_ADDR
72181: GO 72134
72183: POP
72184: POP
// end ;
72185: LD_VAR 0 3
72189: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
72190: LD_INT 0
72192: PPUSH
// if not mc_bases or not base or not areas then
72193: NOP4
72197: NOT
72198: PUSH
72199: NOP4
72203: NOT
72204: OR
72205: PUSH
72206: NOP4
72210: NOT
72211: OR
72212: IFFALSE 72216
// exit ;
72214: GO 72241
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
72216: NOP4
72220: PUSH
72221: NOP4
72225: PPUSH
72226: NOP4
72230: PPUSH
72231: NOP4
72235: PPUSH
72236: NOP4
72240: ST_TO_ADDR
// end ;
72241: LD_VAR 0 3
72245: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
72246: LD_INT 0
72248: PPUSH
// if not mc_bases or not base or not teleports_exit then
72249: NOP4
72253: NOT
72254: PUSH
72255: NOP4
72259: NOT
72260: OR
72261: PUSH
72262: NOP4
72266: NOT
72267: OR
72268: IFFALSE 72272
// exit ;
72270: GO 72297
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
72272: NOP4
72276: PUSH
72277: NOP4
72281: PPUSH
72282: NOP4
72286: PPUSH
72287: NOP4
72291: PPUSH
72292: NOP4
72296: ST_TO_ADDR
// end ;
72297: LD_VAR 0 3
72301: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
72302: LD_INT 0
72304: PPUSH
72305: PPUSH
72306: PPUSH
// if not mc_bases or not base or not ext_list then
72307: NOP4
72311: NOT
72312: PUSH
72313: NOP4
72317: NOT
72318: OR
72319: PUSH
72320: NOP4
72324: NOT
72325: OR
72326: IFFALSE 72330
// exit ;
72328: GO 72503
// tmp := GetFacExtXYD ( x , y , d ) ;
72330: NOP4
72334: PUSH
72335: NOP4
72339: PPUSH
72340: NOP4
72344: PPUSH
72345: NOP4
72349: PPUSH
72350: NOP4
72354: ST_TO_ADDR
// if not tmp then
72355: NOP4
72359: NOT
72360: IFFALSE 72364
// exit ;
72362: GO 72503
// for i in tmp do
72364: NOP4
72368: PUSH
72369: NOP4
72373: PUSH
72374: FOR_IN
72375: IFFALSE 72501
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
72377: NOP4
72381: PUSH
72382: NOP4
72386: PPUSH
72387: NOP4
72391: PPUSH
72392: NOP4
72396: PUSH
72397: NOP4
72401: ARRAY
72402: PPUSH
72403: NOP4
72407: PUSH
72408: NOP4
72412: ARRAY
72413: PUSH
72414: LD_INT 1
72416: PLUS
72417: PPUSH
72418: NOP4
72422: PUSH
72423: LD_INT 1
72425: ARRAY
72426: PUSH
72427: NOP4
72431: PUSH
72432: LD_INT 1
72434: ARRAY
72435: PUSH
72436: NOP4
72440: PUSH
72441: LD_INT 2
72443: ARRAY
72444: PUSH
72445: NOP4
72449: PUSH
72450: LD_INT 3
72452: ARRAY
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: PPUSH
72460: NOP4
72464: PPUSH
72465: NOP4
72469: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
72470: NOP4
72474: PUSH
72475: NOP4
72479: PPUSH
72480: LD_INT 1
72482: PPUSH
72483: NOP4
72487: ST_TO_ADDR
// if not ext_list then
72488: NOP4
72492: NOT
72493: IFFALSE 72499
// exit ;
72495: POP
72496: POP
72497: GO 72503
// end ;
72499: GO 72374
72501: POP
72502: POP
// end ;
72503: LD_VAR 0 6
72507: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
72508: LD_INT 0
72510: PPUSH
// if not mc_bases or not base or not weapon_list then
72511: NOP4
72515: NOT
72516: PUSH
72517: NOP4
72521: NOT
72522: OR
72523: PUSH
72524: NOP4
72528: NOT
72529: OR
72530: IFFALSE 72534
// exit ;
72532: GO 72559
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
72534: NOP4
72538: PUSH
72539: NOP4
72543: PPUSH
72544: NOP4
72548: PPUSH
72549: NOP4
72553: PPUSH
72554: NOP4
72558: ST_TO_ADDR
// end ;
72559: LD_VAR 0 3
72563: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
72564: LD_INT 0
72566: PPUSH
// if not mc_bases or not base or not tech_list then
72567: NOP4
72571: NOT
72572: PUSH
72573: NOP4
72577: NOT
72578: OR
72579: PUSH
72580: NOP4
72584: NOT
72585: OR
72586: IFFALSE 72590
// exit ;
72588: GO 72615
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
72590: NOP4
72594: PUSH
72595: NOP4
72599: PPUSH
72600: NOP4
72604: PPUSH
72605: NOP4
72609: PPUSH
72610: NOP4
72614: ST_TO_ADDR
// end ;
72615: LD_VAR 0 3
72619: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
72620: LD_INT 0
72622: PPUSH
// if not mc_bases or not parking_area or not base then
72623: NOP4
72627: NOT
72628: PUSH
72629: NOP4
72633: NOT
72634: OR
72635: PUSH
72636: NOP4
72640: NOT
72641: OR
72642: IFFALSE 72646
// exit ;
72644: GO 72671
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
72646: NOP4
72650: PUSH
72651: NOP4
72655: PPUSH
72656: NOP4
72660: PPUSH
72661: NOP4
72665: PPUSH
72666: NOP4
72670: ST_TO_ADDR
// end ;
72671: LD_VAR 0 3
72675: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
72676: LD_INT 0
72678: PPUSH
// if not mc_bases or not base or not scan_area then
72679: NOP4
72683: NOT
72684: PUSH
72685: NOP4
72689: NOT
72690: OR
72691: PUSH
72692: NOP4
72696: NOT
72697: OR
72698: IFFALSE 72702
// exit ;
72700: GO 72727
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
72702: NOP4
72706: PUSH
72707: NOP4
72711: PPUSH
72712: NOP4
72716: PPUSH
72717: NOP4
72721: PPUSH
72722: NOP4
72726: ST_TO_ADDR
// end ;
72727: LD_VAR 0 3
72731: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
72732: LD_INT 0
72734: PPUSH
72735: PPUSH
// if not mc_bases or not base then
72736: NOP4
72740: NOT
72741: PUSH
72742: NOP4
72746: NOT
72747: OR
72748: IFFALSE 72752
// exit ;
72750: GO 72816
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
72752: NOP4
72756: PUSH
72757: LD_INT 1
72759: PUSH
72760: LD_INT 2
72762: PUSH
72763: LD_INT 3
72765: PUSH
72766: LD_INT 4
72768: PUSH
72769: LD_INT 11
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
72779: NOP4
72783: PUSH
72784: NOP4
72788: PPUSH
72789: NOP4
72793: PPUSH
72794: NOP4
72798: PUSH
72799: NOP4
72803: ARRAY
72804: PUSH
72805: NOP4
72809: DIFF
72810: PPUSH
72811: NOP4
72815: ST_TO_ADDR
// end ;
72816: LD_VAR 0 2
72820: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
72821: LD_INT 0
72823: PPUSH
// result := mc_vehicles [ base ] ;
72824: NOP4
72828: PUSH
72829: NOP4
72833: PUSH
72834: NOP4
72838: ARRAY
72839: ST_TO_ADDR
// if onlyCombat then
72840: NOP4
72844: IFFALSE 73022
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
72846: NOP4
72850: PUSH
72851: NOP4
72855: PUSH
72856: NOP4
72860: PPUSH
72861: LD_INT 2
72863: PUSH
72864: LD_INT 34
72866: PUSH
72867: LD_INT 12
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 34
72876: PUSH
72877: LD_INT 51
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 34
72886: PUSH
72887: NOP4
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PUSH
72896: LD_INT 34
72898: PUSH
72899: LD_INT 32
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 34
72908: PUSH
72909: LD_INT 13
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 34
72918: PUSH
72919: LD_INT 52
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 34
72928: PUSH
72929: NOP4
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 34
72940: PUSH
72941: LD_INT 14
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 34
72950: PUSH
72951: LD_INT 53
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: LD_INT 34
72960: PUSH
72961: NOP4
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: PUSH
72970: LD_INT 34
72972: PUSH
72973: LD_INT 31
72975: PUSH
72976: EMPTY
72977: LIST
72978: LIST
72979: PUSH
72980: LD_INT 34
72982: PUSH
72983: LD_INT 48
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: LD_INT 34
72992: PUSH
72993: LD_INT 8
72995: PUSH
72996: EMPTY
72997: LIST
72998: LIST
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: PPUSH
73016: NOP4
73020: DIFF
73021: ST_TO_ADDR
// end ; end_of_file
73022: LD_VAR 0 3
73026: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
73027: LD_INT 0
73029: PPUSH
73030: PPUSH
73031: PPUSH
// if not mc_bases or not skirmish then
73032: NOP4
73036: NOT
73037: PUSH
73038: NOP4
73042: NOT
73043: OR
73044: IFFALSE 73048
// exit ;
73046: GO 73213
// for i = 1 to mc_bases do
73048: NOP4
73052: PUSH
73053: DOUBLE
73054: LD_INT 1
73056: DEC
73057: ST_TO_ADDR
73058: NOP4
73062: PUSH
73063: FOR_TO
73064: IFFALSE 73211
// begin if sci in mc_bases [ i ] then
73066: NOP4
73070: PUSH
73071: NOP4
73075: PUSH
73076: NOP4
73080: ARRAY
73081: IN
73082: IFFALSE 73209
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
73084: NOP4
73088: PUSH
73089: NOP4
73093: PPUSH
73094: NOP4
73098: PUSH
73099: NOP4
73103: PUSH
73104: NOP4
73108: ARRAY
73109: PUSH
73110: LD_INT 1
73112: PLUS
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PPUSH
73118: NOP4
73122: PPUSH
73123: NOP4
73127: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
73128: NOP4
73132: PUSH
73133: NOP4
73137: PUSH
73138: NOP4
73142: ARRAY
73143: PPUSH
73144: LD_INT 2
73146: PUSH
73147: LD_INT 30
73149: PUSH
73150: LD_INT 0
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 30
73159: PUSH
73160: LD_INT 1
73162: PUSH
73163: EMPTY
73164: LIST
73165: LIST
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: LIST
73171: PPUSH
73172: NOP4
73176: PPUSH
73177: NOP4
73181: PPUSH
73182: NOP4
73186: ST_TO_ADDR
// if tmp then
73187: NOP4
73191: IFFALSE 73207
// ComStandNearbyBuilding ( ape , tmp ) ;
73193: NOP4
73197: PPUSH
73198: NOP4
73202: PPUSH
73203: NOP4
// break ;
73207: GO 73211
// end ; end ;
73209: GO 73063
73211: POP
73212: POP
// end ;
73213: LD_VAR 0 3
73217: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
73218: LD_INT 0
73220: PPUSH
73221: PPUSH
73222: PPUSH
// if not mc_bases or not skirmish then
73223: NOP4
73227: NOT
73228: PUSH
73229: NOP4
73233: NOT
73234: OR
73235: IFFALSE 73239
// exit ;
73237: GO 73328
// for i = 1 to mc_bases do
73239: NOP4
73243: PUSH
73244: DOUBLE
73245: LD_INT 1
73247: DEC
73248: ST_TO_ADDR
73249: NOP4
73253: PUSH
73254: FOR_TO
73255: IFFALSE 73326
// begin if building in mc_busy_turret_list [ i ] then
73257: NOP4
73261: PUSH
73262: NOP4
73266: PUSH
73267: NOP4
73271: ARRAY
73272: IN
73273: IFFALSE 73324
// begin tmp := mc_busy_turret_list [ i ] diff building ;
73275: NOP4
73279: PUSH
73280: NOP4
73284: PUSH
73285: NOP4
73289: ARRAY
73290: PUSH
73291: NOP4
73295: DIFF
73296: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
73297: NOP4
73301: PUSH
73302: NOP4
73306: PPUSH
73307: NOP4
73311: PPUSH
73312: NOP4
73316: PPUSH
73317: NOP4
73321: ST_TO_ADDR
// break ;
73322: GO 73326
// end ; end ;
73324: GO 73254
73326: POP
73327: POP
// end ;
73328: LD_VAR 0 3
73332: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
73333: LD_INT 0
73335: PPUSH
73336: PPUSH
73337: PPUSH
// if not mc_bases or not skirmish then
73338: NOP4
73342: NOT
73343: PUSH
73344: NOP4
73348: NOT
73349: OR
73350: IFFALSE 73354
// exit ;
73352: GO 73553
// for i = 1 to mc_bases do
73354: NOP4
73358: PUSH
73359: DOUBLE
73360: LD_INT 1
73362: DEC
73363: ST_TO_ADDR
73364: NOP4
73368: PUSH
73369: FOR_TO
73370: IFFALSE 73551
// if building in mc_bases [ i ] then
73372: NOP4
73376: PUSH
73377: NOP4
73381: PUSH
73382: NOP4
73386: ARRAY
73387: IN
73388: IFFALSE 73549
// begin tmp := mc_bases [ i ] diff building ;
73390: NOP4
73394: PUSH
73395: NOP4
73399: PUSH
73400: NOP4
73404: ARRAY
73405: PUSH
73406: NOP4
73410: DIFF
73411: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
73412: NOP4
73416: PUSH
73417: NOP4
73421: PPUSH
73422: NOP4
73426: PPUSH
73427: NOP4
73431: PPUSH
73432: NOP4
73436: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
73437: NOP4
73441: PUSH
73442: NOP4
73446: PUSH
73447: NOP4
73451: ARRAY
73452: IN
73453: IFFALSE 73492
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
73455: NOP4
73459: PUSH
73460: NOP4
73464: PPUSH
73465: NOP4
73469: PPUSH
73470: NOP4
73474: PUSH
73475: NOP4
73479: ARRAY
73480: PUSH
73481: NOP4
73485: DIFF
73486: PPUSH
73487: NOP4
73491: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
73492: NOP4
73496: PUSH
73497: NOP4
73501: PUSH
73502: NOP4
73506: ARRAY
73507: IN
73508: IFFALSE 73547
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
73510: NOP4
73514: PUSH
73515: NOP4
73519: PPUSH
73520: NOP4
73524: PPUSH
73525: NOP4
73529: PUSH
73530: NOP4
73534: ARRAY
73535: PUSH
73536: NOP4
73540: DIFF
73541: PPUSH
73542: NOP4
73546: ST_TO_ADDR
// break ;
73547: GO 73551
// end ;
73549: GO 73369
73551: POP
73552: POP
// end ;
73553: LD_VAR 0 4
73557: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
73558: LD_INT 0
73560: PPUSH
73561: PPUSH
73562: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
73563: NOP4
73567: NOT
73568: PUSH
73569: NOP4
73573: NOT
73574: OR
73575: PUSH
73576: NOP4
73580: PUSH
73581: NOP4
73585: IN
73586: NOT
73587: OR
73588: IFFALSE 73592
// exit ;
73590: GO 73715
// for i = 1 to mc_vehicles do
73592: NOP4
73596: PUSH
73597: DOUBLE
73598: LD_INT 1
73600: DEC
73601: ST_TO_ADDR
73602: NOP4
73606: PUSH
73607: FOR_TO
73608: IFFALSE 73713
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
73610: NOP4
73614: PUSH
73615: NOP4
73619: PUSH
73620: NOP4
73624: ARRAY
73625: IN
73626: PUSH
73627: NOP4
73631: PUSH
73632: NOP4
73636: PUSH
73637: NOP4
73641: ARRAY
73642: IN
73643: OR
73644: IFFALSE 73711
// begin tmp := mc_vehicles [ i ] diff old ;
73646: NOP4
73650: PUSH
73651: NOP4
73655: PUSH
73656: NOP4
73660: ARRAY
73661: PUSH
73662: NOP4
73666: DIFF
73667: ST_TO_ADDR
// tmp := tmp diff new ;
73668: NOP4
73672: PUSH
73673: NOP4
73677: PUSH
73678: NOP4
73682: DIFF
73683: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
73684: NOP4
73688: PUSH
73689: NOP4
73693: PPUSH
73694: NOP4
73698: PPUSH
73699: NOP4
73703: PPUSH
73704: NOP4
73708: ST_TO_ADDR
// break ;
73709: GO 73713
// end ;
73711: GO 73607
73713: POP
73714: POP
// end ;
73715: LD_VAR 0 5
73719: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
73720: LD_INT 0
73722: PPUSH
73723: PPUSH
73724: PPUSH
73725: PPUSH
// if not mc_bases or not skirmish then
73726: NOP4
73730: NOT
73731: PUSH
73732: NOP4
73736: NOT
73737: OR
73738: IFFALSE 73742
// exit ;
73740: GO 74125
// side := GetSide ( vehicle ) ;
73742: NOP4
73746: PUSH
73747: NOP4
73751: PPUSH
73752: NOP4
73756: ST_TO_ADDR
// for i = 1 to mc_bases do
73757: NOP4
73761: PUSH
73762: DOUBLE
73763: LD_INT 1
73765: DEC
73766: ST_TO_ADDR
73767: NOP4
73771: PUSH
73772: FOR_TO
73773: IFFALSE 74123
// begin if factory in mc_bases [ i ] then
73775: NOP4
73779: PUSH
73780: NOP4
73784: PUSH
73785: NOP4
73789: ARRAY
73790: IN
73791: IFFALSE 74121
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
73793: NOP4
73797: PUSH
73798: NOP4
73802: ARRAY
73803: PUSH
73804: NOP4
73808: PUSH
73809: NOP4
73813: ARRAY
73814: LESS
73815: PUSH
73816: NOP4
73820: PPUSH
73821: NOP4
73825: PUSH
73826: LD_INT 31
73828: PUSH
73829: LD_INT 32
73831: PUSH
73832: LD_INT 51
73834: PUSH
73835: NOP4
73839: PUSH
73840: LD_INT 12
73842: PUSH
73843: LD_INT 30
73845: PUSH
73846: NOP4
73850: PUSH
73851: LD_INT 11
73853: PUSH
73854: LD_INT 53
73856: PUSH
73857: LD_INT 14
73859: PUSH
73860: NOP4
73864: PUSH
73865: LD_INT 29
73867: PUSH
73868: NOP4
73872: PUSH
73873: LD_INT 13
73875: PUSH
73876: LD_INT 52
73878: PUSH
73879: NOP4
73883: PUSH
73884: LD_INT 48
73886: PUSH
73887: LD_INT 8
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: IN
73910: NOT
73911: AND
73912: IFFALSE 73960
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
73914: NOP4
73918: PUSH
73919: NOP4
73923: PPUSH
73924: NOP4
73928: PUSH
73929: NOP4
73933: PUSH
73934: NOP4
73938: ARRAY
73939: PUSH
73940: LD_INT 1
73942: PLUS
73943: PUSH
73944: EMPTY
73945: LIST
73946: LIST
73947: PPUSH
73948: NOP4
73952: PPUSH
73953: NOP4
73957: ST_TO_ADDR
73958: GO 74004
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
73960: NOP4
73964: PUSH
73965: NOP4
73969: PPUSH
73970: NOP4
73974: PUSH
73975: NOP4
73979: PUSH
73980: NOP4
73984: ARRAY
73985: PUSH
73986: LD_INT 1
73988: PLUS
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PPUSH
73994: NOP4
73998: PPUSH
73999: NOP4
74003: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
74004: NOP4
74008: PPUSH
74009: NOP4
74013: PUSH
74014: LD_INT 2
74016: EQUAL
74017: IFFALSE 74037
// begin repeat wait ( 0 0$1 ) ;
74019: LD_INT 35
74021: PPUSH
74022: NOP4
// until IsControledBy ( vehicle ) ;
74026: NOP4
74030: PPUSH
74031: NOP4
74035: IFFALSE 74019
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
74037: NOP4
74041: PPUSH
74042: NOP4
74046: PUSH
74047: NOP4
74051: ARRAY
74052: PPUSH
74053: NOP4
// if GetControl ( vehicle ) <> control_manual then
74057: NOP4
74061: PPUSH
74062: NOP4
74066: PUSH
74067: LD_INT 1
74069: NONEQUAL
74070: IFFALSE 74074
// break ;
74072: GO 74123
// repeat wait ( 0 0$1 ) ;
74074: LD_INT 35
74076: PPUSH
74077: NOP4
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
74081: NOP4
74085: PPUSH
74086: NOP4
74090: PUSH
74091: NOP4
74095: ARRAY
74096: PPUSH
74097: NOP4
74101: IFFALSE 74074
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
74103: NOP4
74107: PPUSH
74108: NOP4
74112: PPUSH
74113: NOP4
// exit ;
74117: POP
74118: POP
74119: GO 74125
// end ; end ;
74121: GO 73772
74123: POP
74124: POP
// end ;
74125: LD_VAR 0 3
74129: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
74130: LD_INT 0
74132: PPUSH
74133: PPUSH
74134: PPUSH
74135: PPUSH
// if not mc_bases or not skirmish then
74136: NOP4
74140: NOT
74141: PUSH
74142: NOP4
74146: NOT
74147: OR
74148: IFFALSE 74152
// exit ;
74150: GO 74505
// repeat wait ( 0 0$1 ) ;
74152: LD_INT 35
74154: PPUSH
74155: NOP4
// until GetResourceAmountXY ( x , y ) ;
74159: NOP4
74163: PPUSH
74164: NOP4
74168: PPUSH
74169: NOP4
74173: IFFALSE 74152
// if GetResourceTypeXY ( x , y ) = mat_artefact then
74175: NOP4
74179: PPUSH
74180: NOP4
74184: PPUSH
74185: NOP4
74189: PUSH
74190: LD_INT 4
74192: EQUAL
74193: IFFALSE 74197
// exit ;
74195: GO 74505
// for i = 1 to mc_bases do
74197: NOP4
74201: PUSH
74202: DOUBLE
74203: LD_INT 1
74205: DEC
74206: ST_TO_ADDR
74207: NOP4
74211: PUSH
74212: FOR_TO
74213: IFFALSE 74503
// begin if mc_crates_area [ i ] then
74215: NOP4
74219: PUSH
74220: NOP4
74224: ARRAY
74225: IFFALSE 74336
// for j in mc_crates_area [ i ] do
74227: NOP4
74231: PUSH
74232: NOP4
74236: PUSH
74237: NOP4
74241: ARRAY
74242: PUSH
74243: FOR_IN
74244: IFFALSE 74334
// if InArea ( x , y , j ) then
74246: NOP4
74250: PPUSH
74251: NOP4
74255: PPUSH
74256: NOP4
74260: PPUSH
74261: NOP4
74265: IFFALSE 74332
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
74267: NOP4
74271: PUSH
74272: NOP4
74276: PPUSH
74277: NOP4
74281: PUSH
74282: NOP4
74286: PUSH
74287: NOP4
74291: ARRAY
74292: PUSH
74293: LD_INT 1
74295: PLUS
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: PPUSH
74301: NOP4
74305: PUSH
74306: NOP4
74310: PUSH
74311: NOP4
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: LIST
74320: PPUSH
74321: NOP4
74325: ST_TO_ADDR
// exit ;
74326: POP
74327: POP
74328: POP
74329: POP
74330: GO 74505
// end ;
74332: GO 74243
74334: POP
74335: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74336: NOP4
74340: PUSH
74341: NOP4
74345: PUSH
74346: NOP4
74350: ARRAY
74351: PPUSH
74352: LD_INT 2
74354: PUSH
74355: LD_INT 30
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 30
74367: PUSH
74368: LD_INT 1
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: LIST
74379: PPUSH
74380: NOP4
74384: ST_TO_ADDR
// if not depot then
74385: NOP4
74389: NOT
74390: IFFALSE 74394
// continue ;
74392: GO 74212
// for j in depot do
74394: NOP4
74398: PUSH
74399: NOP4
74403: PUSH
74404: FOR_IN
74405: IFFALSE 74499
// if GetDistUnitXY ( j , x , y ) < 30 then
74407: NOP4
74411: PPUSH
74412: NOP4
74416: PPUSH
74417: NOP4
74421: PPUSH
74422: NOP4
74426: PUSH
74427: LD_INT 30
74429: LESS
74430: IFFALSE 74497
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
74432: NOP4
74436: PUSH
74437: NOP4
74441: PPUSH
74442: NOP4
74446: PUSH
74447: NOP4
74451: PUSH
74452: NOP4
74456: ARRAY
74457: PUSH
74458: LD_INT 1
74460: PLUS
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PPUSH
74466: NOP4
74470: PUSH
74471: NOP4
74475: PUSH
74476: NOP4
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: LIST
74485: PPUSH
74486: NOP4
74490: ST_TO_ADDR
// exit ;
74491: POP
74492: POP
74493: POP
74494: POP
74495: GO 74505
// end ;
74497: GO 74404
74499: POP
74500: POP
// end ;
74501: GO 74212
74503: POP
74504: POP
// end ;
74505: LD_VAR 0 6
74509: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
74510: LD_INT 0
74512: PPUSH
74513: PPUSH
74514: PPUSH
74515: PPUSH
// if not mc_bases or not skirmish then
74516: NOP4
74520: NOT
74521: PUSH
74522: NOP4
74526: NOT
74527: OR
74528: IFFALSE 74532
// exit ;
74530: GO 74809
// side := GetSide ( lab ) ;
74532: NOP4
74536: PUSH
74537: NOP4
74541: PPUSH
74542: NOP4
74546: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
74547: NOP4
74551: PUSH
74552: NOP4
74556: IN
74557: NOT
74558: PUSH
74559: NOP4
74563: NOT
74564: OR
74565: PUSH
74566: NOP4
74570: NOT
74571: OR
74572: IFFALSE 74576
// exit ;
74574: GO 74809
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
74576: NOP4
74580: PUSH
74581: NOP4
74585: PPUSH
74586: NOP4
74590: PPUSH
74591: NOP4
74595: PUSH
74596: NOP4
74600: ARRAY
74601: PUSH
74602: NOP4
74606: DIFF
74607: PPUSH
74608: NOP4
74612: ST_TO_ADDR
// for i = 1 to mc_bases do
74613: NOP4
74617: PUSH
74618: DOUBLE
74619: LD_INT 1
74621: DEC
74622: ST_TO_ADDR
74623: NOP4
74627: PUSH
74628: FOR_TO
74629: IFFALSE 74807
// begin if lab in mc_bases [ i ] then
74631: NOP4
74635: PUSH
74636: NOP4
74640: PUSH
74641: NOP4
74645: ARRAY
74646: IN
74647: IFFALSE 74805
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
74649: NOP4
74653: PUSH
74654: LD_INT 11
74656: PUSH
74657: LD_INT 4
74659: PUSH
74660: LD_INT 3
74662: PUSH
74663: LD_INT 2
74665: PUSH
74666: EMPTY
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: IN
74672: PUSH
74673: NOP4
74677: PUSH
74678: NOP4
74682: ARRAY
74683: AND
74684: IFFALSE 74805
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
74686: NOP4
74690: PUSH
74691: NOP4
74695: PUSH
74696: NOP4
74700: ARRAY
74701: PUSH
74702: LD_INT 1
74704: ARRAY
74705: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74706: NOP4
74710: PUSH
74711: NOP4
74715: PPUSH
74716: NOP4
74720: PPUSH
74721: EMPTY
74722: PPUSH
74723: NOP4
74727: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
74728: NOP4
74732: PPUSH
74733: LD_INT 0
74735: PPUSH
74736: NOP4
// ComExitBuilding ( tmp ) ;
74740: NOP4
74744: PPUSH
74745: NOP4
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
74749: NOP4
74753: PUSH
74754: NOP4
74758: PPUSH
74759: NOP4
74763: PPUSH
74764: NOP4
74768: PUSH
74769: NOP4
74773: ARRAY
74774: PPUSH
74775: LD_INT 1
74777: PPUSH
74778: NOP4
74782: PPUSH
74783: NOP4
74787: PPUSH
74788: NOP4
74792: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
74793: NOP4
74797: PPUSH
74798: LD_INT 112
74800: PPUSH
74801: NOP4
// end ; end ; end ;
74805: GO 74628
74807: POP
74808: POP
// end ;
74809: LD_VAR 0 3
74813: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
74814: LD_INT 0
74816: PPUSH
74817: PPUSH
74818: PPUSH
74819: PPUSH
74820: PPUSH
74821: PPUSH
74822: PPUSH
74823: PPUSH
// if not mc_bases or not skirmish then
74824: NOP4
74828: NOT
74829: PUSH
74830: NOP4
74834: NOT
74835: OR
74836: IFFALSE 74840
// exit ;
74838: GO 76211
// for i = 1 to mc_bases do
74840: NOP4
74844: PUSH
74845: DOUBLE
74846: LD_INT 1
74848: DEC
74849: ST_TO_ADDR
74850: NOP4
74854: PUSH
74855: FOR_TO
74856: IFFALSE 76209
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
74858: NOP4
74862: PUSH
74863: NOP4
74867: PUSH
74868: NOP4
74872: ARRAY
74873: IN
74874: PUSH
74875: NOP4
74879: PUSH
74880: NOP4
74884: PUSH
74885: NOP4
74889: ARRAY
74890: IN
74891: OR
74892: PUSH
74893: NOP4
74897: PUSH
74898: NOP4
74902: PUSH
74903: NOP4
74907: ARRAY
74908: IN
74909: OR
74910: PUSH
74911: NOP4
74915: PUSH
74916: NOP4
74920: PUSH
74921: NOP4
74925: ARRAY
74926: IN
74927: OR
74928: PUSH
74929: NOP4
74933: PUSH
74934: NOP4
74938: PUSH
74939: NOP4
74943: ARRAY
74944: IN
74945: OR
74946: PUSH
74947: NOP4
74951: PUSH
74952: NOP4
74956: PUSH
74957: NOP4
74961: ARRAY
74962: IN
74963: OR
74964: IFFALSE 76207
// begin if un in mc_ape [ i ] then
74966: NOP4
74970: PUSH
74971: NOP4
74975: PUSH
74976: NOP4
74980: ARRAY
74981: IN
74982: IFFALSE 75021
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
74984: NOP4
74988: PUSH
74989: NOP4
74993: PPUSH
74994: NOP4
74998: PPUSH
74999: NOP4
75003: PUSH
75004: NOP4
75008: ARRAY
75009: PUSH
75010: NOP4
75014: DIFF
75015: PPUSH
75016: NOP4
75020: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
75021: NOP4
75025: PUSH
75026: NOP4
75030: PUSH
75031: NOP4
75035: ARRAY
75036: IN
75037: IFFALSE 75061
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
75039: NOP4
75043: PUSH
75044: NOP4
75048: PPUSH
75049: NOP4
75053: PPUSH
75054: EMPTY
75055: PPUSH
75056: NOP4
75060: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
75061: NOP4
75065: PPUSH
75066: NOP4
75070: PUSH
75071: LD_INT 2
75073: EQUAL
75074: PUSH
75075: NOP4
75079: PPUSH
75080: NOP4
75084: PUSH
75085: LD_INT 20
75087: EQUAL
75088: PUSH
75089: NOP4
75093: PUSH
75094: NOP4
75098: PUSH
75099: NOP4
75103: ARRAY
75104: IN
75105: OR
75106: PUSH
75107: NOP4
75111: PPUSH
75112: NOP4
75116: PUSH
75117: LD_INT 12
75119: PUSH
75120: LD_INT 51
75122: PUSH
75123: NOP4
75127: PUSH
75128: LD_INT 32
75130: PUSH
75131: LD_INT 13
75133: PUSH
75134: LD_INT 52
75136: PUSH
75137: LD_INT 31
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: LIST
75144: LIST
75145: LIST
75146: LIST
75147: LIST
75148: IN
75149: OR
75150: AND
75151: IFFALSE 75459
// begin if un in mc_defender [ i ] then
75153: NOP4
75157: PUSH
75158: NOP4
75162: PUSH
75163: NOP4
75167: ARRAY
75168: IN
75169: IFFALSE 75208
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
75171: NOP4
75175: PUSH
75176: NOP4
75180: PPUSH
75181: NOP4
75185: PPUSH
75186: NOP4
75190: PUSH
75191: NOP4
75195: ARRAY
75196: PUSH
75197: NOP4
75201: DIFF
75202: PPUSH
75203: NOP4
75207: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
75208: NOP4
75212: PUSH
75213: NOP4
75217: PPUSH
75218: LD_INT 3
75220: PPUSH
75221: NOP4
75225: ST_TO_ADDR
// if fac then
75226: NOP4
75230: IFFALSE 75459
// begin for j in fac do
75232: NOP4
75236: PUSH
75237: NOP4
75241: PUSH
75242: FOR_IN
75243: IFFALSE 75457
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
75245: NOP4
75249: PUSH
75250: NOP4
75254: PPUSH
75255: NOP4
75259: PPUSH
75260: NOP4
75264: PPUSH
75265: NOP4
75269: PPUSH
75270: NOP4
75274: PPUSH
75275: NOP4
75279: PPUSH
75280: NOP4
75284: PPUSH
75285: NOP4
75289: PPUSH
75290: NOP4
75294: PPUSH
75295: NOP4
75299: ST_TO_ADDR
// if components then
75300: NOP4
75304: IFFALSE 75455
// begin if GetWeapon ( un ) = ar_control_tower then
75306: NOP4
75310: PPUSH
75311: NOP4
75315: PUSH
75316: LD_INT 31
75318: EQUAL
75319: IFFALSE 75436
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
75321: NOP4
75325: PPUSH
75326: NOP4
75330: PPUSH
75331: LD_INT 0
75333: PPUSH
75334: NOP4
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
75338: NOP4
75342: PUSH
75343: NOP4
75347: PPUSH
75348: NOP4
75352: PPUSH
75353: NOP4
75357: PUSH
75358: NOP4
75362: ARRAY
75363: PUSH
75364: NOP4
75368: PPUSH
75369: NOP4
75373: DIFF
75374: PPUSH
75375: NOP4
75379: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
75380: NOP4
75384: PUSH
75385: NOP4
75389: PUSH
75390: NOP4
75394: ARRAY
75395: PPUSH
75396: LD_INT 1
75398: PPUSH
75399: NOP4
75403: PPUSH
75404: NOP4
75408: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
75409: NOP4
75413: PUSH
75414: NOP4
75418: PPUSH
75419: NOP4
75423: PPUSH
75424: NOP4
75428: PPUSH
75429: NOP4
75433: ST_TO_ADDR
// end else
75434: GO 75453
// MC_InsertProduceList ( i , [ components ] ) ;
75436: NOP4
75440: PPUSH
75441: NOP4
75445: PUSH
75446: EMPTY
75447: LIST
75448: PPUSH
75449: NOP4
// break ;
75453: GO 75457
// end ; end ;
75455: GO 75242
75457: POP
75458: POP
// end ; end ; if GetType ( un ) = unit_building then
75459: NOP4
75463: PPUSH
75464: NOP4
75468: PUSH
75469: LD_INT 3
75471: EQUAL
75472: IFFALSE 75875
// begin btype := GetBType ( un ) ;
75474: NOP4
75478: PUSH
75479: NOP4
75483: PPUSH
75484: NOP4
75488: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
75489: NOP4
75493: PUSH
75494: LD_INT 29
75496: PUSH
75497: LD_INT 30
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: IN
75504: IFFALSE 75577
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
75506: NOP4
75510: PPUSH
75511: NOP4
75515: PPUSH
75516: NOP4
75520: PPUSH
75521: NOP4
75525: PPUSH
75526: NOP4
75530: PPUSH
75531: NOP4
75535: PPUSH
75536: NOP4
75540: NOT
75541: IFFALSE 75577
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
75543: NOP4
75547: PPUSH
75548: NOP4
75552: PPUSH
75553: NOP4
75557: PPUSH
75558: NOP4
75562: PPUSH
75563: NOP4
75567: PPUSH
75568: NOP4
75572: PPUSH
75573: NOP4
// end ; if btype = b_warehouse then
75577: NOP4
75581: PUSH
75582: LD_INT 1
75584: EQUAL
75585: IFFALSE 75603
// begin btype := b_depot ;
75587: NOP4
75591: PUSH
75592: LD_INT 0
75594: ST_TO_ADDR
// pos := 1 ;
75595: NOP4
75599: PUSH
75600: LD_INT 1
75602: ST_TO_ADDR
// end ; if btype = b_factory then
75603: NOP4
75607: PUSH
75608: LD_INT 3
75610: EQUAL
75611: IFFALSE 75629
// begin btype := b_workshop ;
75613: NOP4
75617: PUSH
75618: LD_INT 2
75620: ST_TO_ADDR
// pos := 1 ;
75621: NOP4
75625: PUSH
75626: LD_INT 1
75628: ST_TO_ADDR
// end ; if btype = b_barracks then
75629: NOP4
75633: PUSH
75634: LD_INT 5
75636: EQUAL
75637: IFFALSE 75647
// btype := b_armoury ;
75639: NOP4
75643: PUSH
75644: LD_INT 4
75646: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
75647: NOP4
75651: PUSH
75652: LD_INT 7
75654: PUSH
75655: LD_INT 8
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: IN
75662: IFFALSE 75672
// btype := b_lab ;
75664: NOP4
75668: PUSH
75669: LD_INT 6
75671: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
75672: NOP4
75676: PUSH
75677: NOP4
75681: PPUSH
75682: NOP4
75686: PUSH
75687: NOP4
75691: PUSH
75692: NOP4
75696: ARRAY
75697: PUSH
75698: LD_INT 1
75700: PLUS
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PPUSH
75706: NOP4
75710: PUSH
75711: NOP4
75715: PPUSH
75716: NOP4
75720: PUSH
75721: NOP4
75725: PPUSH
75726: NOP4
75730: PUSH
75731: NOP4
75735: PPUSH
75736: NOP4
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: LIST
75745: LIST
75746: PPUSH
75747: NOP4
75751: ST_TO_ADDR
// if pos = 1 then
75752: NOP4
75756: PUSH
75757: LD_INT 1
75759: EQUAL
75760: IFFALSE 75875
// begin tmp := mc_build_list [ i ] ;
75762: NOP4
75766: PUSH
75767: NOP4
75771: PUSH
75772: NOP4
75776: ARRAY
75777: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75778: NOP4
75782: PPUSH
75783: LD_INT 2
75785: PUSH
75786: LD_INT 30
75788: PUSH
75789: LD_INT 0
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_INT 30
75798: PUSH
75799: LD_INT 1
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: LIST
75810: PPUSH
75811: NOP4
75815: IFFALSE 75825
// pos := 2 ;
75817: NOP4
75821: PUSH
75822: LD_INT 2
75824: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
75825: NOP4
75829: PUSH
75830: NOP4
75834: PPUSH
75835: NOP4
75839: PPUSH
75840: NOP4
75844: PPUSH
75845: NOP4
75849: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
75850: NOP4
75854: PUSH
75855: NOP4
75859: PPUSH
75860: NOP4
75864: PPUSH
75865: NOP4
75869: PPUSH
75870: NOP4
75874: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
75875: NOP4
75879: PUSH
75880: NOP4
75884: PUSH
75885: NOP4
75889: ARRAY
75890: IN
75891: IFFALSE 75930
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
75893: NOP4
75897: PUSH
75898: NOP4
75902: PPUSH
75903: NOP4
75907: PPUSH
75908: NOP4
75912: PUSH
75913: NOP4
75917: ARRAY
75918: PUSH
75919: NOP4
75923: DIFF
75924: PPUSH
75925: NOP4
75929: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
75930: NOP4
75934: PUSH
75935: NOP4
75939: PUSH
75940: NOP4
75944: ARRAY
75945: IN
75946: IFFALSE 75985
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
75948: NOP4
75952: PUSH
75953: NOP4
75957: PPUSH
75958: NOP4
75962: PPUSH
75963: NOP4
75967: PUSH
75968: NOP4
75972: ARRAY
75973: PUSH
75974: NOP4
75978: DIFF
75979: PPUSH
75980: NOP4
75984: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
75985: NOP4
75989: PUSH
75990: NOP4
75994: PUSH
75995: NOP4
75999: ARRAY
76000: IN
76001: IFFALSE 76040
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
76003: NOP4
76007: PUSH
76008: NOP4
76012: PPUSH
76013: NOP4
76017: PPUSH
76018: NOP4
76022: PUSH
76023: NOP4
76027: ARRAY
76028: PUSH
76029: NOP4
76033: DIFF
76034: PPUSH
76035: NOP4
76039: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
76040: NOP4
76044: PUSH
76045: NOP4
76049: PUSH
76050: NOP4
76054: ARRAY
76055: IN
76056: IFFALSE 76095
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
76058: NOP4
76062: PUSH
76063: NOP4
76067: PPUSH
76068: NOP4
76072: PPUSH
76073: NOP4
76077: PUSH
76078: NOP4
76082: ARRAY
76083: PUSH
76084: NOP4
76088: DIFF
76089: PPUSH
76090: NOP4
76094: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
76095: NOP4
76099: PUSH
76100: NOP4
76104: PUSH
76105: NOP4
76109: ARRAY
76110: IN
76111: IFFALSE 76150
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
76113: NOP4
76117: PUSH
76118: NOP4
76122: PPUSH
76123: NOP4
76127: PPUSH
76128: NOP4
76132: PUSH
76133: NOP4
76137: ARRAY
76138: PUSH
76139: NOP4
76143: DIFF
76144: PPUSH
76145: NOP4
76149: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
76150: NOP4
76154: PUSH
76155: NOP4
76159: PUSH
76160: NOP4
76164: ARRAY
76165: IN
76166: IFFALSE 76205
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
76168: NOP4
76172: PUSH
76173: NOP4
76177: PPUSH
76178: NOP4
76182: PPUSH
76183: NOP4
76187: PUSH
76188: NOP4
76192: ARRAY
76193: PUSH
76194: NOP4
76198: DIFF
76199: PPUSH
76200: NOP4
76204: ST_TO_ADDR
// end ; break ;
76205: GO 76209
// end ;
76207: GO 74855
76209: POP
76210: POP
// end ;
76211: LD_VAR 0 2
76215: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
76216: LD_INT 0
76218: PPUSH
76219: PPUSH
76220: PPUSH
// if not mc_bases or not skirmish then
76221: NOP4
76225: NOT
76226: PUSH
76227: NOP4
76231: NOT
76232: OR
76233: IFFALSE 76237
// exit ;
76235: GO 76452
// for i = 1 to mc_bases do
76237: NOP4
76241: PUSH
76242: DOUBLE
76243: LD_INT 1
76245: DEC
76246: ST_TO_ADDR
76247: NOP4
76251: PUSH
76252: FOR_TO
76253: IFFALSE 76450
// begin if building in mc_construct_list [ i ] then
76255: NOP4
76259: PUSH
76260: NOP4
76264: PUSH
76265: NOP4
76269: ARRAY
76270: IN
76271: IFFALSE 76448
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
76273: NOP4
76277: PUSH
76278: NOP4
76282: PPUSH
76283: NOP4
76287: PPUSH
76288: NOP4
76292: PUSH
76293: NOP4
76297: ARRAY
76298: PUSH
76299: NOP4
76303: DIFF
76304: PPUSH
76305: NOP4
76309: ST_TO_ADDR
// if building in mc_lab [ i ] then
76310: NOP4
76314: PUSH
76315: NOP4
76319: PUSH
76320: NOP4
76324: ARRAY
76325: IN
76326: IFFALSE 76381
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
76328: NOP4
76332: PUSH
76333: NOP4
76337: PPUSH
76338: NOP4
76342: PPUSH
76343: NOP4
76347: PUSH
76348: NOP4
76352: ARRAY
76353: PPUSH
76354: LD_INT 1
76356: PPUSH
76357: NOP4
76361: PUSH
76362: NOP4
76366: ARRAY
76367: PPUSH
76368: LD_INT 0
76370: PPUSH
76371: NOP4
76375: PPUSH
76376: NOP4
76380: ST_TO_ADDR
// if not building in mc_bases [ i ] then
76381: NOP4
76385: PUSH
76386: NOP4
76390: PUSH
76391: NOP4
76395: ARRAY
76396: IN
76397: NOT
76398: IFFALSE 76444
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
76400: NOP4
76404: PUSH
76405: NOP4
76409: PPUSH
76410: NOP4
76414: PUSH
76415: NOP4
76419: PUSH
76420: NOP4
76424: ARRAY
76425: PUSH
76426: LD_INT 1
76428: PLUS
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: PPUSH
76434: NOP4
76438: PPUSH
76439: NOP4
76443: ST_TO_ADDR
// exit ;
76444: POP
76445: POP
76446: GO 76452
// end ; end ;
76448: GO 76252
76450: POP
76451: POP
// end ;
76452: LD_VAR 0 2
76456: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
76457: LD_INT 0
76459: PPUSH
76460: PPUSH
76461: PPUSH
76462: PPUSH
76463: PPUSH
76464: PPUSH
76465: PPUSH
// if not mc_bases or not skirmish then
76466: NOP4
76470: NOT
76471: PUSH
76472: NOP4
76476: NOT
76477: OR
76478: IFFALSE 76482
// exit ;
76480: GO 77143
// for i = 1 to mc_bases do
76482: NOP4
76486: PUSH
76487: DOUBLE
76488: LD_INT 1
76490: DEC
76491: ST_TO_ADDR
76492: NOP4
76496: PUSH
76497: FOR_TO
76498: IFFALSE 77141
// begin if building in mc_construct_list [ i ] then
76500: NOP4
76504: PUSH
76505: NOP4
76509: PUSH
76510: NOP4
76514: ARRAY
76515: IN
76516: IFFALSE 77139
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
76518: NOP4
76522: PUSH
76523: NOP4
76527: PPUSH
76528: NOP4
76532: PPUSH
76533: NOP4
76537: PUSH
76538: NOP4
76542: ARRAY
76543: PUSH
76544: NOP4
76548: DIFF
76549: PPUSH
76550: NOP4
76554: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
76555: NOP4
76559: PUSH
76560: NOP4
76564: PPUSH
76565: NOP4
76569: PUSH
76570: NOP4
76574: PUSH
76575: NOP4
76579: ARRAY
76580: PUSH
76581: LD_INT 1
76583: PLUS
76584: PUSH
76585: EMPTY
76586: LIST
76587: LIST
76588: PPUSH
76589: NOP4
76593: PPUSH
76594: NOP4
76598: ST_TO_ADDR
// btype := GetBType ( building ) ;
76599: NOP4
76603: PUSH
76604: NOP4
76608: PPUSH
76609: NOP4
76613: ST_TO_ADDR
// side := GetSide ( building ) ;
76614: NOP4
76618: PUSH
76619: NOP4
76623: PPUSH
76624: NOP4
76628: ST_TO_ADDR
// if btype = b_lab then
76629: NOP4
76633: PUSH
76634: LD_INT 6
76636: EQUAL
76637: IFFALSE 76687
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
76639: NOP4
76643: PUSH
76644: NOP4
76648: PPUSH
76649: NOP4
76653: PUSH
76654: NOP4
76658: PUSH
76659: NOP4
76663: ARRAY
76664: PUSH
76665: LD_INT 1
76667: PLUS
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PPUSH
76673: NOP4
76677: PPUSH
76678: NOP4
76682: ST_TO_ADDR
// exit ;
76683: POP
76684: POP
76685: GO 77143
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
76687: NOP4
76691: PUSH
76692: LD_INT 0
76694: PUSH
76695: LD_INT 2
76697: PUSH
76698: LD_INT 4
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: LIST
76705: IN
76706: IFFALSE 76830
// begin if btype = b_armoury then
76708: NOP4
76712: PUSH
76713: LD_INT 4
76715: EQUAL
76716: IFFALSE 76726
// btype := b_barracks ;
76718: NOP4
76722: PUSH
76723: LD_INT 5
76725: ST_TO_ADDR
// if btype = b_depot then
76726: NOP4
76730: PUSH
76731: LD_INT 0
76733: EQUAL
76734: IFFALSE 76744
// btype := b_warehouse ;
76736: NOP4
76740: PUSH
76741: LD_INT 1
76743: ST_TO_ADDR
// if btype = b_workshop then
76744: NOP4
76748: PUSH
76749: LD_INT 2
76751: EQUAL
76752: IFFALSE 76762
// btype := b_factory ;
76754: NOP4
76758: PUSH
76759: LD_INT 3
76761: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
76762: NOP4
76766: PPUSH
76767: NOP4
76771: PPUSH
76772: NOP4
76776: PUSH
76777: LD_INT 1
76779: EQUAL
76780: IFFALSE 76826
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
76782: NOP4
76786: PUSH
76787: NOP4
76791: PPUSH
76792: NOP4
76796: PUSH
76797: NOP4
76801: PUSH
76802: NOP4
76806: ARRAY
76807: PUSH
76808: LD_INT 1
76810: PLUS
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PPUSH
76816: NOP4
76820: PPUSH
76821: NOP4
76825: ST_TO_ADDR
// exit ;
76826: POP
76827: POP
76828: GO 77143
// end ; if btype in [ b_bunker , b_turret ] then
76830: NOP4
76834: PUSH
76835: LD_INT 32
76837: PUSH
76838: LD_INT 33
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: IN
76845: IFFALSE 77135
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
76847: NOP4
76851: PUSH
76852: NOP4
76856: PPUSH
76857: NOP4
76861: PUSH
76862: NOP4
76866: PUSH
76867: NOP4
76871: ARRAY
76872: PUSH
76873: LD_INT 1
76875: PLUS
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PPUSH
76881: NOP4
76885: PPUSH
76886: NOP4
76890: ST_TO_ADDR
// if btype = b_bunker then
76891: NOP4
76895: PUSH
76896: LD_INT 32
76898: EQUAL
76899: IFFALSE 77135
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76901: NOP4
76905: PUSH
76906: NOP4
76910: PPUSH
76911: NOP4
76915: PUSH
76916: NOP4
76920: PUSH
76921: NOP4
76925: ARRAY
76926: PUSH
76927: LD_INT 1
76929: PLUS
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PPUSH
76935: NOP4
76939: PPUSH
76940: NOP4
76944: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
76945: NOP4
76949: PUSH
76950: NOP4
76954: PUSH
76955: NOP4
76959: ARRAY
76960: PPUSH
76961: LD_INT 25
76963: PUSH
76964: LD_INT 1
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: PUSH
76971: LD_INT 3
76973: PUSH
76974: LD_INT 54
76976: PUSH
76977: EMPTY
76978: LIST
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PPUSH
76988: NOP4
76992: ST_TO_ADDR
// if tmp then
76993: NOP4
76997: IFFALSE 77003
// exit ;
76999: POP
77000: POP
77001: GO 77143
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
77003: NOP4
77007: PUSH
77008: NOP4
77012: PUSH
77013: NOP4
77017: ARRAY
77018: PPUSH
77019: LD_INT 2
77021: PUSH
77022: LD_INT 30
77024: PUSH
77025: LD_INT 4
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: LD_INT 30
77034: PUSH
77035: LD_INT 5
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: LIST
77046: PPUSH
77047: NOP4
77051: ST_TO_ADDR
// if not tmp then
77052: NOP4
77056: NOT
77057: IFFALSE 77063
// exit ;
77059: POP
77060: POP
77061: GO 77143
// for j in tmp do
77063: NOP4
77067: PUSH
77068: NOP4
77072: PUSH
77073: FOR_IN
77074: IFFALSE 77133
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
77076: NOP4
77080: PUSH
77081: NOP4
77085: PPUSH
77086: NOP4
77090: PPUSH
77091: LD_INT 25
77093: PUSH
77094: LD_INT 1
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PPUSH
77101: NOP4
77105: ST_TO_ADDR
// if units then
77106: NOP4
77110: IFFALSE 77131
// begin ComExitBuilding ( units [ 1 ] ) ;
77112: NOP4
77116: PUSH
77117: LD_INT 1
77119: ARRAY
77120: PPUSH
77121: NOP4
// exit ;
77125: POP
77126: POP
77127: POP
77128: POP
77129: GO 77143
// end ; end ;
77131: GO 77073
77133: POP
77134: POP
// end ; end ; exit ;
77135: POP
77136: POP
77137: GO 77143
// end ; end ;
77139: GO 76497
77141: POP
77142: POP
// end ;
77143: LD_VAR 0 2
77147: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
77148: LD_INT 0
77150: PPUSH
77151: PPUSH
77152: PPUSH
77153: PPUSH
77154: PPUSH
77155: PPUSH
77156: PPUSH
// if not mc_bases or not skirmish then
77157: NOP4
77161: NOT
77162: PUSH
77163: NOP4
77167: NOT
77168: OR
77169: IFFALSE 77173
// exit ;
77171: GO 77404
// btype := GetBType ( building ) ;
77173: NOP4
77177: PUSH
77178: NOP4
77182: PPUSH
77183: NOP4
77187: ST_TO_ADDR
// x := GetX ( building ) ;
77188: NOP4
77192: PUSH
77193: NOP4
77197: PPUSH
77198: NOP4
77202: ST_TO_ADDR
// y := GetY ( building ) ;
77203: NOP4
77207: PUSH
77208: NOP4
77212: PPUSH
77213: NOP4
77217: ST_TO_ADDR
// d := GetDir ( building ) ;
77218: NOP4
77222: PUSH
77223: NOP4
77227: PPUSH
77228: NOP4
77232: ST_TO_ADDR
// for i = 1 to mc_bases do
77233: NOP4
77237: PUSH
77238: DOUBLE
77239: LD_INT 1
77241: DEC
77242: ST_TO_ADDR
77243: NOP4
77247: PUSH
77248: FOR_TO
77249: IFFALSE 77402
// begin if not mc_build_list [ i ] then
77251: NOP4
77255: PUSH
77256: NOP4
77260: ARRAY
77261: NOT
77262: IFFALSE 77266
// continue ;
77264: GO 77248
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
77266: NOP4
77270: PUSH
77271: NOP4
77275: PUSH
77276: NOP4
77280: PUSH
77281: NOP4
77285: PUSH
77286: EMPTY
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: PPUSH
77292: NOP4
77296: PUSH
77297: NOP4
77301: ARRAY
77302: PUSH
77303: LD_INT 1
77305: ARRAY
77306: PPUSH
77307: NOP4
77311: IFFALSE 77400
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
77313: NOP4
77317: PUSH
77318: NOP4
77322: PPUSH
77323: NOP4
77327: PPUSH
77328: NOP4
77332: PUSH
77333: NOP4
77337: ARRAY
77338: PPUSH
77339: LD_INT 1
77341: PPUSH
77342: NOP4
77346: PPUSH
77347: NOP4
77351: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
77352: NOP4
77356: PUSH
77357: NOP4
77361: PPUSH
77362: NOP4
77366: PUSH
77367: NOP4
77371: PUSH
77372: NOP4
77376: ARRAY
77377: PUSH
77378: LD_INT 1
77380: PLUS
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PPUSH
77386: NOP4
77390: PPUSH
77391: NOP4
77395: ST_TO_ADDR
// exit ;
77396: POP
77397: POP
77398: GO 77404
// end ; end ;
77400: GO 77248
77402: POP
77403: POP
// end ;
77404: LD_VAR 0 3
77408: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
77409: LD_INT 0
77411: PPUSH
77412: PPUSH
77413: PPUSH
// if not mc_bases or not skirmish then
77414: NOP4
77418: NOT
77419: PUSH
77420: NOP4
77424: NOT
77425: OR
77426: IFFALSE 77430
// exit ;
77428: GO 77620
// for i = 1 to mc_bases do
77430: NOP4
77434: PUSH
77435: DOUBLE
77436: LD_INT 1
77438: DEC
77439: ST_TO_ADDR
77440: NOP4
77444: PUSH
77445: FOR_TO
77446: IFFALSE 77533
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
77448: NOP4
77452: PUSH
77453: NOP4
77457: PUSH
77458: NOP4
77462: ARRAY
77463: IN
77464: PUSH
77465: NOP4
77469: PUSH
77470: NOP4
77474: PUSH
77475: NOP4
77479: ARRAY
77480: IN
77481: NOT
77482: AND
77483: IFFALSE 77531
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
77485: NOP4
77489: PUSH
77490: NOP4
77494: PPUSH
77495: NOP4
77499: PUSH
77500: NOP4
77504: PUSH
77505: NOP4
77509: ARRAY
77510: PUSH
77511: LD_INT 1
77513: PLUS
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PPUSH
77519: NOP4
77523: PPUSH
77524: NOP4
77528: ST_TO_ADDR
// break ;
77529: GO 77533
// end ; end ;
77531: GO 77445
77533: POP
77534: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
77535: NOP4
77539: PPUSH
77540: NOP4
77544: PUSH
77545: NOP4
77549: IN
77550: PUSH
77551: NOP4
77555: PPUSH
77556: NOP4
77560: PUSH
77561: LD_INT 5
77563: EQUAL
77564: AND
77565: PUSH
77566: NOP4
77570: PPUSH
77571: NOP4
77575: PUSH
77576: LD_INT 18
77578: NONEQUAL
77579: AND
77580: IFFALSE 77620
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
77582: NOP4
77586: PPUSH
77587: NOP4
77591: PUSH
77592: LD_INT 5
77594: PUSH
77595: LD_INT 8
77597: PUSH
77598: LD_INT 9
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: LIST
77605: IN
77606: IFFALSE 77620
// SetClass ( unit , 1 ) ;
77608: NOP4
77612: PPUSH
77613: LD_INT 1
77615: PPUSH
77616: NOP4
// end ;
77620: LD_VAR 0 3
77624: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
77625: LD_INT 0
77627: PPUSH
77628: PPUSH
// if not mc_bases or not skirmish then
77629: NOP4
77633: NOT
77634: PUSH
77635: NOP4
77639: NOT
77640: OR
77641: IFFALSE 77645
// exit ;
77643: GO 77761
// if GetLives ( abandoned_vehicle ) > 250 then
77645: NOP4
77649: PPUSH
77650: NOP4
77654: PUSH
77655: LD_INT 250
77657: GREATER
77658: IFFALSE 77662
// exit ;
77660: GO 77761
// for i = 1 to mc_bases do
77662: NOP4
77666: PUSH
77667: DOUBLE
77668: LD_INT 1
77670: DEC
77671: ST_TO_ADDR
77672: NOP4
77676: PUSH
77677: FOR_TO
77678: IFFALSE 77759
// begin if driver in mc_bases [ i ] then
77680: NOP4
77684: PUSH
77685: NOP4
77689: PUSH
77690: NOP4
77694: ARRAY
77695: IN
77696: IFFALSE 77757
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
77698: NOP4
77702: PPUSH
77703: NOP4
77707: PUSH
77708: NOP4
77712: ARRAY
77713: PPUSH
77714: LD_INT 2
77716: PUSH
77717: LD_INT 30
77719: PUSH
77720: LD_INT 0
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 30
77729: PUSH
77730: LD_INT 1
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: LIST
77741: PPUSH
77742: NOP4
77746: PUSH
77747: LD_INT 1
77749: ARRAY
77750: PPUSH
77751: NOP4
// break ;
77755: GO 77759
// end ; end ;
77757: GO 77677
77759: POP
77760: POP
// end ; end_of_file
77761: LD_VAR 0 5
77765: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
77766: LD_INT 0
77768: PPUSH
// ar_miner := 81 ;
77769: NOP4
77773: PUSH
77774: LD_INT 81
77776: ST_TO_ADDR
// ar_crane := 88 ;
77777: NOP4
77781: PUSH
77782: LD_INT 88
77784: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
77785: NOP4
77789: PUSH
77790: LD_INT 89
77792: ST_TO_ADDR
// us_hack := 99 ;
77793: NOP4
77797: PUSH
77798: LD_INT 99
77800: ST_TO_ADDR
// us_artillery := 97 ;
77801: NOP4
77805: PUSH
77806: LD_INT 97
77808: ST_TO_ADDR
// ar_bio_bomb := 91 ;
77809: NOP4
77813: PUSH
77814: LD_INT 91
77816: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
77817: NOP4
77821: PUSH
77822: LD_INT 92
77824: ST_TO_ADDR
// ru_radar := 98 ;
77825: NOP4
77829: PUSH
77830: LD_INT 98
77832: ST_TO_ADDR
// tech_Artillery := 80 ;
77833: NOP4
77837: PUSH
77838: LD_INT 80
77840: ST_TO_ADDR
// tech_RadMat := 81 ;
77841: NOP4
77845: PUSH
77846: LD_INT 81
77848: ST_TO_ADDR
// tech_BasicTools := 82 ;
77849: NOP4
77853: PUSH
77854: LD_INT 82
77856: ST_TO_ADDR
// tech_Cargo := 83 ;
77857: NOP4
77861: PUSH
77862: LD_INT 83
77864: ST_TO_ADDR
// tech_Track := 84 ;
77865: NOP4
77869: PUSH
77870: LD_INT 84
77872: ST_TO_ADDR
// tech_Crane := 85 ;
77873: NOP4
77877: PUSH
77878: LD_INT 85
77880: ST_TO_ADDR
// tech_Bulldozer := 86 ;
77881: NOP4
77885: PUSH
77886: LD_INT 86
77888: ST_TO_ADDR
// tech_Hovercraft := 87 ;
77889: NOP4
77893: PUSH
77894: LD_INT 87
77896: ST_TO_ADDR
// end ;
77897: LD_VAR 0 1
77901: RET
// every 1 do
77902: GO 77904
77904: DISABLE
// InitGlobalVariables ; end_of_file
77905: NOP4
77909: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
77910: LD_INT 0
77912: PPUSH
77913: PPUSH
77914: PPUSH
77915: PPUSH
77916: PPUSH
77917: PPUSH
77918: PPUSH
77919: PPUSH
77920: PPUSH
77921: PPUSH
77922: PPUSH
77923: PPUSH
77924: PPUSH
77925: PPUSH
77926: PPUSH
77927: PPUSH
77928: PPUSH
77929: PPUSH
77930: PPUSH
77931: PPUSH
77932: PPUSH
77933: PPUSH
77934: PPUSH
77935: PPUSH
77936: PPUSH
77937: PPUSH
77938: PPUSH
77939: PPUSH
77940: PPUSH
77941: PPUSH
77942: PPUSH
77943: PPUSH
77944: PPUSH
77945: PPUSH
// if not list then
77946: NOP4
77950: NOT
77951: IFFALSE 77955
// exit ;
77953: GO 82614
// base := list [ 1 ] ;
77955: NOP4
77959: PUSH
77960: NOP4
77964: PUSH
77965: LD_INT 1
77967: ARRAY
77968: ST_TO_ADDR
// group := list [ 2 ] ;
77969: NOP4
77973: PUSH
77974: NOP4
77978: PUSH
77979: LD_INT 2
77981: ARRAY
77982: ST_TO_ADDR
// path := list [ 3 ] ;
77983: NOP4
77987: PUSH
77988: NOP4
77992: PUSH
77993: LD_INT 3
77995: ARRAY
77996: ST_TO_ADDR
// flags := list [ 4 ] ;
77997: NOP4
78001: PUSH
78002: NOP4
78006: PUSH
78007: LD_INT 4
78009: ARRAY
78010: ST_TO_ADDR
// mined := [ ] ;
78011: NOP4
78015: PUSH
78016: EMPTY
78017: ST_TO_ADDR
// bombed := [ ] ;
78018: NOP4
78022: PUSH
78023: EMPTY
78024: ST_TO_ADDR
// healers := [ ] ;
78025: NOP4
78029: PUSH
78030: EMPTY
78031: ST_TO_ADDR
// to_heal := [ ] ;
78032: NOP4
78036: PUSH
78037: EMPTY
78038: ST_TO_ADDR
// repairs := [ ] ;
78039: NOP4
78043: PUSH
78044: EMPTY
78045: ST_TO_ADDR
// to_repair := [ ] ;
78046: NOP4
78050: PUSH
78051: EMPTY
78052: ST_TO_ADDR
// if not group or not path then
78053: NOP4
78057: NOT
78058: PUSH
78059: NOP4
78063: NOT
78064: OR
78065: IFFALSE 78069
// exit ;
78067: GO 82614
// side := GetSide ( group [ 1 ] ) ;
78069: NOP4
78073: PUSH
78074: NOP4
78078: PUSH
78079: LD_INT 1
78081: ARRAY
78082: PPUSH
78083: NOP4
78087: ST_TO_ADDR
// if flags then
78088: NOP4
78092: IFFALSE 78236
// begin f_ignore_area := flags [ 1 ] ;
78094: NOP4
78098: PUSH
78099: NOP4
78103: PUSH
78104: LD_INT 1
78106: ARRAY
78107: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
78108: NOP4
78112: PUSH
78113: NOP4
78117: PUSH
78118: LD_INT 2
78120: ARRAY
78121: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
78122: NOP4
78126: PUSH
78127: NOP4
78131: PUSH
78132: LD_INT 3
78134: ARRAY
78135: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
78136: NOP4
78140: PUSH
78141: NOP4
78145: PUSH
78146: LD_INT 4
78148: ARRAY
78149: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
78150: NOP4
78154: PUSH
78155: NOP4
78159: PUSH
78160: LD_INT 5
78162: ARRAY
78163: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
78164: NOP4
78168: PUSH
78169: NOP4
78173: PUSH
78174: LD_INT 6
78176: ARRAY
78177: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
78178: NOP4
78182: PUSH
78183: NOP4
78187: PUSH
78188: LD_INT 7
78190: ARRAY
78191: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
78192: NOP4
78196: PUSH
78197: NOP4
78201: PUSH
78202: LD_INT 8
78204: ARRAY
78205: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
78206: NOP4
78210: PUSH
78211: NOP4
78215: PUSH
78216: LD_INT 9
78218: ARRAY
78219: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
78220: NOP4
78224: PUSH
78225: NOP4
78229: PUSH
78230: LD_INT 10
78232: ARRAY
78233: ST_TO_ADDR
// end else
78234: GO 78316
// begin f_ignore_area := false ;
78236: NOP4
78240: PUSH
78241: LD_INT 0
78243: ST_TO_ADDR
// f_capture := false ;
78244: NOP4
78248: PUSH
78249: LD_INT 0
78251: ST_TO_ADDR
// f_ignore_civ := false ;
78252: NOP4
78256: PUSH
78257: LD_INT 0
78259: ST_TO_ADDR
// f_murder := false ;
78260: NOP4
78264: PUSH
78265: LD_INT 0
78267: ST_TO_ADDR
// f_mines := false ;
78268: NOP4
78272: PUSH
78273: LD_INT 0
78275: ST_TO_ADDR
// f_repair := false ;
78276: NOP4
78280: PUSH
78281: LD_INT 0
78283: ST_TO_ADDR
// f_heal := false ;
78284: NOP4
78288: PUSH
78289: LD_INT 0
78291: ST_TO_ADDR
// f_spacetime := false ;
78292: NOP4
78296: PUSH
78297: LD_INT 0
78299: ST_TO_ADDR
// f_attack_depot := false ;
78300: NOP4
78304: PUSH
78305: LD_INT 0
78307: ST_TO_ADDR
// f_crawl := false ;
78308: NOP4
78312: PUSH
78313: LD_INT 0
78315: ST_TO_ADDR
// end ; if f_heal then
78316: NOP4
78320: IFFALSE 78347
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
78322: NOP4
78326: PUSH
78327: NOP4
78331: PPUSH
78332: LD_INT 25
78334: PUSH
78335: LD_INT 4
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PPUSH
78342: NOP4
78346: ST_TO_ADDR
// if f_repair then
78347: NOP4
78351: IFFALSE 78378
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
78353: NOP4
78357: PUSH
78358: NOP4
78362: PPUSH
78363: LD_INT 25
78365: PUSH
78366: LD_INT 3
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: PPUSH
78373: NOP4
78377: ST_TO_ADDR
// units_path := [ ] ;
78378: NOP4
78382: PUSH
78383: EMPTY
78384: ST_TO_ADDR
// for i = 1 to group do
78385: NOP4
78389: PUSH
78390: DOUBLE
78391: LD_INT 1
78393: DEC
78394: ST_TO_ADDR
78395: NOP4
78399: PUSH
78400: FOR_TO
78401: IFFALSE 78430
// units_path := Replace ( units_path , i , path ) ;
78403: NOP4
78407: PUSH
78408: NOP4
78412: PPUSH
78413: NOP4
78417: PPUSH
78418: NOP4
78422: PPUSH
78423: NOP4
78427: ST_TO_ADDR
78428: GO 78400
78430: POP
78431: POP
// repeat for i = group downto 1 do
78432: NOP4
78436: PUSH
78437: DOUBLE
78438: NOP4
78442: INC
78443: ST_TO_ADDR
78444: LD_INT 1
78446: PUSH
78447: FOR_DOWNTO
78448: IFFALSE 82570
// begin wait ( 5 ) ;
78450: LD_INT 5
78452: PPUSH
78453: NOP4
// tmp := [ ] ;
78457: NOP4
78461: PUSH
78462: EMPTY
78463: ST_TO_ADDR
// attacking := false ;
78464: NOP4
78468: PUSH
78469: LD_INT 0
78471: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
78472: NOP4
78476: PUSH
78477: NOP4
78481: ARRAY
78482: PPUSH
78483: NOP4
78487: PUSH
78488: NOP4
78492: PUSH
78493: NOP4
78497: ARRAY
78498: NOT
78499: OR
78500: IFFALSE 78609
// begin if GetType ( group [ i ] ) = unit_human then
78502: NOP4
78506: PUSH
78507: NOP4
78511: ARRAY
78512: PPUSH
78513: NOP4
78517: PUSH
78518: LD_INT 1
78520: EQUAL
78521: IFFALSE 78567
// begin to_heal := to_heal diff group [ i ] ;
78523: NOP4
78527: PUSH
78528: NOP4
78532: PUSH
78533: NOP4
78537: PUSH
78538: NOP4
78542: ARRAY
78543: DIFF
78544: ST_TO_ADDR
// healers := healers diff group [ i ] ;
78545: NOP4
78549: PUSH
78550: NOP4
78554: PUSH
78555: NOP4
78559: PUSH
78560: NOP4
78564: ARRAY
78565: DIFF
78566: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
78567: NOP4
78571: PUSH
78572: NOP4
78576: PPUSH
78577: NOP4
78581: PPUSH
78582: NOP4
78586: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
78587: NOP4
78591: PUSH
78592: NOP4
78596: PPUSH
78597: NOP4
78601: PPUSH
78602: NOP4
78606: ST_TO_ADDR
// continue ;
78607: GO 78447
// end ; if f_repair then
78609: NOP4
78613: IFFALSE 79102
// begin if GetType ( group [ i ] ) = unit_vehicle then
78615: NOP4
78619: PUSH
78620: NOP4
78624: ARRAY
78625: PPUSH
78626: NOP4
78630: PUSH
78631: LD_INT 2
78633: EQUAL
78634: IFFALSE 78824
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
78636: NOP4
78640: PUSH
78641: NOP4
78645: ARRAY
78646: PPUSH
78647: NOP4
78651: PUSH
78652: LD_INT 700
78654: LESS
78655: PUSH
78656: NOP4
78660: PUSH
78661: NOP4
78665: ARRAY
78666: PUSH
78667: NOP4
78671: IN
78672: NOT
78673: AND
78674: IFFALSE 78698
// to_repair := to_repair union group [ i ] ;
78676: NOP4
78680: PUSH
78681: NOP4
78685: PUSH
78686: NOP4
78690: PUSH
78691: NOP4
78695: ARRAY
78696: UNION
78697: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78698: NOP4
78702: PUSH
78703: NOP4
78707: ARRAY
78708: PPUSH
78709: NOP4
78713: PUSH
78714: LD_INT 1000
78716: EQUAL
78717: PUSH
78718: NOP4
78722: PUSH
78723: NOP4
78727: ARRAY
78728: PUSH
78729: NOP4
78733: IN
78734: AND
78735: IFFALSE 78759
// to_repair := to_repair diff group [ i ] ;
78737: NOP4
78741: PUSH
78742: NOP4
78746: PUSH
78747: NOP4
78751: PUSH
78752: NOP4
78756: ARRAY
78757: DIFF
78758: ST_TO_ADDR
// if group [ i ] in to_repair then
78759: NOP4
78763: PUSH
78764: NOP4
78768: ARRAY
78769: PUSH
78770: NOP4
78774: IN
78775: IFFALSE 78822
// begin if not IsInArea ( group [ i ] , f_repair ) then
78777: NOP4
78781: PUSH
78782: NOP4
78786: ARRAY
78787: PPUSH
78788: NOP4
78792: PPUSH
78793: NOP4
78797: NOT
78798: IFFALSE 78820
// ComMoveToArea ( group [ i ] , f_repair ) ;
78800: NOP4
78804: PUSH
78805: NOP4
78809: ARRAY
78810: PPUSH
78811: NOP4
78815: PPUSH
78816: NOP4
// continue ;
78820: GO 78447
// end ; end else
78822: GO 79102
// if group [ i ] in repairs then
78824: NOP4
78828: PUSH
78829: NOP4
78833: ARRAY
78834: PUSH
78835: NOP4
78839: IN
78840: IFFALSE 79102
// begin if IsInUnit ( group [ i ] ) then
78842: NOP4
78846: PUSH
78847: NOP4
78851: ARRAY
78852: PPUSH
78853: NOP4
78857: IFFALSE 78925
// begin z := IsInUnit ( group [ i ] ) ;
78859: NOP4
78863: PUSH
78864: NOP4
78868: PUSH
78869: NOP4
78873: ARRAY
78874: PPUSH
78875: NOP4
78879: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
78880: NOP4
78884: PUSH
78885: NOP4
78889: IN
78890: PUSH
78891: NOP4
78895: PPUSH
78896: NOP4
78900: PPUSH
78901: NOP4
78905: AND
78906: IFFALSE 78923
// ComExitVehicle ( group [ i ] ) ;
78908: NOP4
78912: PUSH
78913: NOP4
78917: ARRAY
78918: PPUSH
78919: NOP4
// end else
78923: GO 79102
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
78925: NOP4
78929: PUSH
78930: NOP4
78934: PPUSH
78935: LD_INT 95
78937: PUSH
78938: NOP4
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 58
78949: PUSH
78950: EMPTY
78951: LIST
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PPUSH
78957: NOP4
78961: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
78962: NOP4
78966: PUSH
78967: NOP4
78971: ARRAY
78972: PPUSH
78973: NOP4
78977: NOT
78978: IFFALSE 79100
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
78980: NOP4
78984: PUSH
78985: NOP4
78989: PPUSH
78990: NOP4
78994: PUSH
78995: NOP4
78999: ARRAY
79000: PPUSH
79001: NOP4
79005: ST_TO_ADDR
// if not x then
79006: NOP4
79010: NOT
79011: IFFALSE 79015
// continue ;
79013: GO 78447
// if GetLives ( x ) < 1000 then
79015: NOP4
79019: PPUSH
79020: NOP4
79024: PUSH
79025: LD_INT 1000
79027: LESS
79028: IFFALSE 79052
// ComRepairVehicle ( group [ i ] , x ) else
79030: NOP4
79034: PUSH
79035: NOP4
79039: ARRAY
79040: PPUSH
79041: NOP4
79045: PPUSH
79046: NOP4
79050: GO 79100
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
79052: NOP4
79056: PUSH
79057: NOP4
79061: PUSH
79062: NOP4
79066: ARRAY
79067: PPUSH
79068: NOP4
79072: PUSH
79073: LD_INT 1000
79075: LESS
79076: AND
79077: NOT
79078: IFFALSE 79100
// ComEnterUnit ( group [ i ] , x ) ;
79080: NOP4
79084: PUSH
79085: NOP4
79089: ARRAY
79090: PPUSH
79091: NOP4
79095: PPUSH
79096: NOP4
// end ; continue ;
79100: GO 78447
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
79102: NOP4
79106: PUSH
79107: NOP4
79111: PUSH
79112: NOP4
79116: ARRAY
79117: PPUSH
79118: NOP4
79122: PUSH
79123: LD_INT 1
79125: EQUAL
79126: AND
79127: IFFALSE 79605
// begin if group [ i ] in healers then
79129: NOP4
79133: PUSH
79134: NOP4
79138: ARRAY
79139: PUSH
79140: NOP4
79144: IN
79145: IFFALSE 79418
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
79147: NOP4
79151: PUSH
79152: NOP4
79156: ARRAY
79157: PPUSH
79158: NOP4
79162: PPUSH
79163: NOP4
79167: NOT
79168: PUSH
79169: NOP4
79173: PUSH
79174: NOP4
79178: ARRAY
79179: PPUSH
79180: NOP4
79184: NOT
79185: AND
79186: IFFALSE 79210
// ComMoveToArea ( group [ i ] , f_heal ) else
79188: NOP4
79192: PUSH
79193: NOP4
79197: ARRAY
79198: PPUSH
79199: NOP4
79203: PPUSH
79204: NOP4
79208: GO 79416
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
79210: NOP4
79214: PUSH
79215: NOP4
79219: ARRAY
79220: PPUSH
79221: NOP4
79225: PPUSH
79226: NOP4
79230: PUSH
79231: LD_INT 1000
79233: EQUAL
79234: IFFALSE 79253
// ComStop ( group [ i ] ) else
79236: NOP4
79240: PUSH
79241: NOP4
79245: ARRAY
79246: PPUSH
79247: NOP4
79251: GO 79416
// if not HasTask ( group [ i ] ) and to_heal then
79253: NOP4
79257: PUSH
79258: NOP4
79262: ARRAY
79263: PPUSH
79264: NOP4
79268: NOT
79269: PUSH
79270: NOP4
79274: AND
79275: IFFALSE 79416
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
79277: NOP4
79281: PUSH
79282: NOP4
79286: PPUSH
79287: LD_INT 3
79289: PUSH
79290: LD_INT 54
79292: PUSH
79293: EMPTY
79294: LIST
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PPUSH
79300: NOP4
79304: PPUSH
79305: NOP4
79309: PUSH
79310: NOP4
79314: ARRAY
79315: PPUSH
79316: NOP4
79320: ST_TO_ADDR
// if z then
79321: NOP4
79325: IFFALSE 79416
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
79327: LD_INT 91
79329: PUSH
79330: NOP4
79334: PUSH
79335: LD_INT 10
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: LIST
79342: PUSH
79343: LD_INT 81
79345: PUSH
79346: NOP4
79350: PPUSH
79351: NOP4
79355: PUSH
79356: EMPTY
79357: LIST
79358: LIST
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PPUSH
79364: NOP4
79368: PUSH
79369: LD_INT 0
79371: EQUAL
79372: IFFALSE 79396
// ComHeal ( group [ i ] , z ) else
79374: NOP4
79378: PUSH
79379: NOP4
79383: ARRAY
79384: PPUSH
79385: NOP4
79389: PPUSH
79390: NOP4
79394: GO 79416
// ComMoveToArea ( group [ i ] , f_heal ) ;
79396: NOP4
79400: PUSH
79401: NOP4
79405: ARRAY
79406: PPUSH
79407: NOP4
79411: PPUSH
79412: NOP4
// end ; continue ;
79416: GO 78447
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
79418: NOP4
79422: PUSH
79423: NOP4
79427: ARRAY
79428: PPUSH
79429: NOP4
79433: PUSH
79434: LD_INT 700
79436: LESS
79437: PUSH
79438: NOP4
79442: PUSH
79443: NOP4
79447: ARRAY
79448: PUSH
79449: NOP4
79453: IN
79454: NOT
79455: AND
79456: IFFALSE 79480
// to_heal := to_heal union group [ i ] ;
79458: NOP4
79462: PUSH
79463: NOP4
79467: PUSH
79468: NOP4
79472: PUSH
79473: NOP4
79477: ARRAY
79478: UNION
79479: ST_TO_ADDR
// if group [ i ] in to_heal then
79480: NOP4
79484: PUSH
79485: NOP4
79489: ARRAY
79490: PUSH
79491: NOP4
79495: IN
79496: IFFALSE 79605
// begin if GetLives ( group [ i ] ) = 1000 then
79498: NOP4
79502: PUSH
79503: NOP4
79507: ARRAY
79508: PPUSH
79509: NOP4
79513: PUSH
79514: LD_INT 1000
79516: EQUAL
79517: IFFALSE 79543
// to_heal := to_heal diff group [ i ] else
79519: NOP4
79523: PUSH
79524: NOP4
79528: PUSH
79529: NOP4
79533: PUSH
79534: NOP4
79538: ARRAY
79539: DIFF
79540: ST_TO_ADDR
79541: GO 79605
// begin if not IsInArea ( group [ i ] , to_heal ) then
79543: NOP4
79547: PUSH
79548: NOP4
79552: ARRAY
79553: PPUSH
79554: NOP4
79558: PPUSH
79559: NOP4
79563: NOT
79564: IFFALSE 79588
// ComMoveToArea ( group [ i ] , f_heal ) else
79566: NOP4
79570: PUSH
79571: NOP4
79575: ARRAY
79576: PPUSH
79577: NOP4
79581: PPUSH
79582: NOP4
79586: GO 79603
// ComHold ( group [ i ] ) ;
79588: NOP4
79592: PUSH
79593: NOP4
79597: ARRAY
79598: PPUSH
79599: NOP4
// continue ;
79603: GO 78447
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
79605: NOP4
79609: PUSH
79610: NOP4
79614: ARRAY
79615: PPUSH
79616: LD_INT 10
79618: PPUSH
79619: NOP4
79623: NOT
79624: PUSH
79625: NOP4
79629: PUSH
79630: NOP4
79634: ARRAY
79635: PUSH
79636: EMPTY
79637: EQUAL
79638: NOT
79639: AND
79640: IFFALSE 79906
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
79642: NOP4
79646: PUSH
79647: NOP4
79651: ARRAY
79652: PPUSH
79653: NOP4
79657: PUSH
79658: LD_INT 1
79660: PUSH
79661: LD_INT 2
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: IN
79668: IFFALSE 79709
// if GetFuel ( group [ i ] ) < 10 then
79670: NOP4
79674: PUSH
79675: NOP4
79679: ARRAY
79680: PPUSH
79681: NOP4
79685: PUSH
79686: LD_INT 10
79688: LESS
79689: IFFALSE 79709
// SetFuel ( group [ i ] , 12 ) ;
79691: NOP4
79695: PUSH
79696: NOP4
79700: ARRAY
79701: PPUSH
79702: LD_INT 12
79704: PPUSH
79705: NOP4
// if units_path [ i ] then
79709: NOP4
79713: PUSH
79714: NOP4
79718: ARRAY
79719: IFFALSE 79904
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
79721: NOP4
79725: PUSH
79726: NOP4
79730: ARRAY
79731: PPUSH
79732: NOP4
79736: PUSH
79737: NOP4
79741: ARRAY
79742: PUSH
79743: LD_INT 1
79745: ARRAY
79746: PUSH
79747: LD_INT 1
79749: ARRAY
79750: PPUSH
79751: NOP4
79755: PUSH
79756: NOP4
79760: ARRAY
79761: PUSH
79762: LD_INT 1
79764: ARRAY
79765: PUSH
79766: LD_INT 2
79768: ARRAY
79769: PPUSH
79770: NOP4
79774: PUSH
79775: LD_INT 6
79777: GREATER
79778: IFFALSE 79853
// begin if not HasTask ( group [ i ] ) then
79780: NOP4
79784: PUSH
79785: NOP4
79789: ARRAY
79790: PPUSH
79791: NOP4
79795: NOT
79796: IFFALSE 79851
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
79798: NOP4
79802: PUSH
79803: NOP4
79807: ARRAY
79808: PPUSH
79809: NOP4
79813: PUSH
79814: NOP4
79818: ARRAY
79819: PUSH
79820: LD_INT 1
79822: ARRAY
79823: PUSH
79824: LD_INT 1
79826: ARRAY
79827: PPUSH
79828: NOP4
79832: PUSH
79833: NOP4
79837: ARRAY
79838: PUSH
79839: LD_INT 1
79841: ARRAY
79842: PUSH
79843: LD_INT 2
79845: ARRAY
79846: PPUSH
79847: NOP4
// end else
79851: GO 79904
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
79853: NOP4
79857: PUSH
79858: NOP4
79862: PUSH
79863: NOP4
79867: ARRAY
79868: PPUSH
79869: LD_INT 1
79871: PPUSH
79872: NOP4
79876: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
79877: NOP4
79881: PUSH
79882: NOP4
79886: PPUSH
79887: NOP4
79891: PPUSH
79892: NOP4
79896: PPUSH
79897: NOP4
79901: ST_TO_ADDR
// continue ;
79902: GO 78447
// end ; end ; end else
79904: GO 82568
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
79906: NOP4
79910: PUSH
79911: LD_INT 81
79913: PUSH
79914: NOP4
79918: PUSH
79919: NOP4
79923: ARRAY
79924: PPUSH
79925: NOP4
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PPUSH
79934: NOP4
79938: ST_TO_ADDR
// if not tmp then
79939: NOP4
79943: NOT
79944: IFFALSE 79948
// continue ;
79946: GO 78447
// if f_ignore_area then
79948: NOP4
79952: IFFALSE 80040
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
79954: NOP4
79958: PUSH
79959: NOP4
79963: PPUSH
79964: LD_INT 3
79966: PUSH
79967: LD_INT 92
79969: PUSH
79970: NOP4
79974: PUSH
79975: LD_INT 1
79977: ARRAY
79978: PUSH
79979: NOP4
79983: PUSH
79984: LD_INT 2
79986: ARRAY
79987: PUSH
79988: NOP4
79992: PUSH
79993: LD_INT 3
79995: ARRAY
79996: PUSH
79997: EMPTY
79998: LIST
79999: LIST
80000: LIST
80001: LIST
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PPUSH
80007: NOP4
80011: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
80012: NOP4
80016: PUSH
80017: NOP4
80021: DIFF
80022: IFFALSE 80040
// tmp := tmp diff tmp2 ;
80024: NOP4
80028: PUSH
80029: NOP4
80033: PUSH
80034: NOP4
80038: DIFF
80039: ST_TO_ADDR
// end ; if not f_murder then
80040: NOP4
80044: NOT
80045: IFFALSE 80103
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
80047: NOP4
80051: PUSH
80052: NOP4
80056: PPUSH
80057: LD_INT 3
80059: PUSH
80060: LD_INT 50
80062: PUSH
80063: EMPTY
80064: LIST
80065: PUSH
80066: EMPTY
80067: LIST
80068: LIST
80069: PPUSH
80070: NOP4
80074: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
80075: NOP4
80079: PUSH
80080: NOP4
80084: DIFF
80085: IFFALSE 80103
// tmp := tmp diff tmp2 ;
80087: NOP4
80091: PUSH
80092: NOP4
80096: PUSH
80097: NOP4
80101: DIFF
80102: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
80103: NOP4
80107: PUSH
80108: NOP4
80112: PUSH
80113: NOP4
80117: ARRAY
80118: PPUSH
80119: NOP4
80123: PPUSH
80124: LD_INT 1
80126: PPUSH
80127: LD_INT 1
80129: PPUSH
80130: NOP4
80134: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
80135: NOP4
80139: PUSH
80140: NOP4
80144: ARRAY
80145: PPUSH
80146: NOP4
80150: PUSH
80151: LD_INT 1
80153: EQUAL
80154: IFFALSE 80602
// begin if WantPlant ( group [ i ] ) then
80156: NOP4
80160: PUSH
80161: NOP4
80165: ARRAY
80166: PPUSH
80167: NOP4
80171: IFFALSE 80175
// continue ;
80173: GO 78447
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
80175: NOP4
80179: PUSH
80180: NOP4
80184: PUSH
80185: NOP4
80189: ARRAY
80190: PPUSH
80191: NOP4
80195: NOT
80196: AND
80197: PUSH
80198: NOP4
80202: PUSH
80203: LD_INT 1
80205: ARRAY
80206: PUSH
80207: NOP4
80211: PPUSH
80212: LD_INT 21
80214: PUSH
80215: LD_INT 2
80217: PUSH
80218: EMPTY
80219: LIST
80220: LIST
80221: PUSH
80222: LD_INT 58
80224: PUSH
80225: EMPTY
80226: LIST
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PPUSH
80232: NOP4
80236: IN
80237: AND
80238: IFFALSE 80274
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
80240: NOP4
80244: PUSH
80245: NOP4
80249: ARRAY
80250: PPUSH
80251: NOP4
80255: PUSH
80256: LD_INT 1
80258: ARRAY
80259: PPUSH
80260: NOP4
// attacking := true ;
80264: NOP4
80268: PUSH
80269: LD_INT 1
80271: ST_TO_ADDR
// continue ;
80272: GO 78447
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
80274: NOP4
80278: PUSH
80279: NOP4
80283: PUSH
80284: NOP4
80288: ARRAY
80289: PPUSH
80290: NOP4
80294: PUSH
80295: LD_INT 1
80297: EQUAL
80298: AND
80299: PUSH
80300: NOP4
80304: PUSH
80305: NOP4
80309: ARRAY
80310: PPUSH
80311: NOP4
80315: PUSH
80316: LD_INT 800
80318: LESS
80319: AND
80320: PUSH
80321: NOP4
80325: PUSH
80326: NOP4
80330: ARRAY
80331: PPUSH
80332: NOP4
80336: NOT
80337: AND
80338: IFFALSE 80355
// ComCrawl ( group [ i ] ) ;
80340: NOP4
80344: PUSH
80345: NOP4
80349: ARRAY
80350: PPUSH
80351: NOP4
// if f_mines then
80355: NOP4
80359: IFFALSE 80602
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
80361: NOP4
80365: PUSH
80366: LD_INT 1
80368: ARRAY
80369: PPUSH
80370: NOP4
80374: PUSH
80375: LD_INT 3
80377: EQUAL
80378: PUSH
80379: NOP4
80383: PUSH
80384: LD_INT 1
80386: ARRAY
80387: PUSH
80388: NOP4
80392: IN
80393: NOT
80394: AND
80395: IFFALSE 80602
// begin x := GetX ( tmp [ 1 ] ) ;
80397: NOP4
80401: PUSH
80402: NOP4
80406: PUSH
80407: LD_INT 1
80409: ARRAY
80410: PPUSH
80411: NOP4
80415: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
80416: NOP4
80420: PUSH
80421: NOP4
80425: PUSH
80426: LD_INT 1
80428: ARRAY
80429: PPUSH
80430: NOP4
80434: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
80435: NOP4
80439: PUSH
80440: NOP4
80444: PUSH
80445: NOP4
80449: ARRAY
80450: PPUSH
80451: NOP4
80455: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
80456: NOP4
80460: PUSH
80461: NOP4
80465: ARRAY
80466: PPUSH
80467: NOP4
80471: PPUSH
80472: NOP4
80476: PPUSH
80477: NOP4
80481: PUSH
80482: LD_INT 1
80484: ARRAY
80485: PPUSH
80486: NOP4
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
80490: NOP4
80494: PUSH
80495: NOP4
80499: ARRAY
80500: PPUSH
80501: NOP4
80505: PPUSH
80506: NOP4
80510: PPUSH
80511: LD_INT 7
80513: PPUSH
80514: NOP4
80518: PPUSH
80519: NOP4
80523: PPUSH
80524: NOP4
80528: PPUSH
80529: LD_INT 7
80531: PPUSH
80532: NOP4
80536: PPUSH
80537: NOP4
// SetTag ( group [ i ] , 71 ) ;
80541: NOP4
80545: PUSH
80546: NOP4
80550: ARRAY
80551: PPUSH
80552: LD_INT 71
80554: PPUSH
80555: NOP4
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
80559: NOP4
80563: PUSH
80564: NOP4
80568: PPUSH
80569: NOP4
80573: PUSH
80574: LD_INT 1
80576: PLUS
80577: PPUSH
80578: NOP4
80582: PUSH
80583: LD_INT 1
80585: ARRAY
80586: PPUSH
80587: NOP4
80591: ST_TO_ADDR
// attacking := true ;
80592: NOP4
80596: PUSH
80597: LD_INT 1
80599: ST_TO_ADDR
// continue ;
80600: GO 78447
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
80602: NOP4
80606: PUSH
80607: NOP4
80611: ARRAY
80612: PPUSH
80613: NOP4
80617: PUSH
80618: LD_INT 17
80620: EQUAL
80621: PUSH
80622: NOP4
80626: PUSH
80627: NOP4
80631: ARRAY
80632: PPUSH
80633: NOP4
80637: PUSH
80638: LD_INT 71
80640: EQUAL
80641: NOT
80642: AND
80643: IFFALSE 80789
// begin attacking := false ;
80645: NOP4
80649: PUSH
80650: LD_INT 0
80652: ST_TO_ADDR
// k := 5 ;
80653: NOP4
80657: PUSH
80658: LD_INT 5
80660: ST_TO_ADDR
// if tmp < k then
80661: NOP4
80665: PUSH
80666: NOP4
80670: LESS
80671: IFFALSE 80683
// k := tmp ;
80673: NOP4
80677: PUSH
80678: NOP4
80682: ST_TO_ADDR
// for j = 1 to k do
80683: NOP4
80687: PUSH
80688: DOUBLE
80689: LD_INT 1
80691: DEC
80692: ST_TO_ADDR
80693: NOP4
80697: PUSH
80698: FOR_TO
80699: IFFALSE 80787
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80701: NOP4
80705: PUSH
80706: NOP4
80710: ARRAY
80711: PUSH
80712: NOP4
80716: PPUSH
80717: LD_INT 58
80719: PUSH
80720: EMPTY
80721: LIST
80722: PPUSH
80723: NOP4
80727: IN
80728: NOT
80729: IFFALSE 80785
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80731: NOP4
80735: PUSH
80736: NOP4
80740: ARRAY
80741: PPUSH
80742: NOP4
80746: PUSH
80747: NOP4
80751: ARRAY
80752: PPUSH
80753: NOP4
// attacking := true ;
80757: NOP4
80761: PUSH
80762: LD_INT 1
80764: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
80765: NOP4
80769: PUSH
80770: NOP4
80774: ARRAY
80775: PPUSH
80776: LD_INT 71
80778: PPUSH
80779: NOP4
// continue ;
80783: GO 80698
// end ; end ;
80785: GO 80698
80787: POP
80788: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
80789: NOP4
80793: PUSH
80794: NOP4
80798: ARRAY
80799: PPUSH
80800: NOP4
80804: PUSH
80805: LD_INT 8
80807: EQUAL
80808: PUSH
80809: NOP4
80813: PUSH
80814: NOP4
80818: ARRAY
80819: PPUSH
80820: NOP4
80824: PUSH
80825: LD_INT 28
80827: PUSH
80828: LD_INT 45
80830: PUSH
80831: LD_INT 7
80833: PUSH
80834: LD_INT 47
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: LIST
80841: LIST
80842: IN
80843: OR
80844: IFFALSE 81100
// begin attacking := false ;
80846: NOP4
80850: PUSH
80851: LD_INT 0
80853: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
80854: NOP4
80858: PUSH
80859: LD_INT 1
80861: ARRAY
80862: PPUSH
80863: NOP4
80867: PUSH
80868: LD_INT 32
80870: PUSH
80871: LD_INT 31
80873: PUSH
80874: LD_INT 33
80876: PUSH
80877: LD_INT 4
80879: PUSH
80880: LD_INT 5
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: LIST
80887: LIST
80888: LIST
80889: IN
80890: IFFALSE 81076
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
80892: NOP4
80896: PUSH
80897: NOP4
80901: PUSH
80902: LD_INT 1
80904: ARRAY
80905: PPUSH
80906: NOP4
80910: PPUSH
80911: NOP4
80915: PUSH
80916: LD_INT 1
80918: ARRAY
80919: PPUSH
80920: NOP4
80924: PPUSH
80925: NOP4
80929: PUSH
80930: LD_INT 1
80932: ARRAY
80933: PPUSH
80934: NOP4
80938: PPUSH
80939: NOP4
80943: PUSH
80944: LD_INT 1
80946: ARRAY
80947: PPUSH
80948: NOP4
80952: PPUSH
80953: NOP4
80957: PUSH
80958: LD_INT 1
80960: ARRAY
80961: PPUSH
80962: NOP4
80966: PPUSH
80967: LD_INT 0
80969: PPUSH
80970: NOP4
80974: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
80975: NOP4
80979: PUSH
80980: NOP4
80984: PUSH
80985: NOP4
80989: ARRAY
80990: PPUSH
80991: NOP4
80995: PPUSH
80996: NOP4
81000: ST_TO_ADDR
// if j then
81001: NOP4
81005: IFFALSE 81074
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
81007: NOP4
81011: PUSH
81012: LD_INT 1
81014: ARRAY
81015: PPUSH
81016: NOP4
81020: PUSH
81021: LD_INT 2
81023: ARRAY
81024: PPUSH
81025: NOP4
81029: IFFALSE 81074
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
81031: NOP4
81035: PUSH
81036: NOP4
81040: ARRAY
81041: PPUSH
81042: NOP4
81046: PUSH
81047: LD_INT 1
81049: ARRAY
81050: PPUSH
81051: NOP4
81055: PUSH
81056: LD_INT 2
81058: ARRAY
81059: PPUSH
81060: NOP4
// attacking := true ;
81064: NOP4
81068: PUSH
81069: LD_INT 1
81071: ST_TO_ADDR
// continue ;
81072: GO 78447
// end ; end else
81074: GO 81100
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81076: NOP4
81080: PUSH
81081: NOP4
81085: ARRAY
81086: PPUSH
81087: NOP4
81091: PUSH
81092: LD_INT 1
81094: ARRAY
81095: PPUSH
81096: NOP4
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
81100: NOP4
81104: PUSH
81105: NOP4
81109: ARRAY
81110: PPUSH
81111: NOP4
81115: PUSH
81116: LD_INT 11
81118: EQUAL
81119: IFFALSE 81397
// begin k := 10 ;
81121: NOP4
81125: PUSH
81126: LD_INT 10
81128: ST_TO_ADDR
// x := 0 ;
81129: NOP4
81133: PUSH
81134: LD_INT 0
81136: ST_TO_ADDR
// if tmp < k then
81137: NOP4
81141: PUSH
81142: NOP4
81146: LESS
81147: IFFALSE 81159
// k := tmp ;
81149: NOP4
81153: PUSH
81154: NOP4
81158: ST_TO_ADDR
// for j = k downto 1 do
81159: NOP4
81163: PUSH
81164: DOUBLE
81165: NOP4
81169: INC
81170: ST_TO_ADDR
81171: LD_INT 1
81173: PUSH
81174: FOR_DOWNTO
81175: IFFALSE 81250
// begin if GetType ( tmp [ j ] ) = unit_human then
81177: NOP4
81181: PUSH
81182: NOP4
81186: ARRAY
81187: PPUSH
81188: NOP4
81192: PUSH
81193: LD_INT 1
81195: EQUAL
81196: IFFALSE 81248
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
81198: NOP4
81202: PUSH
81203: NOP4
81207: ARRAY
81208: PPUSH
81209: NOP4
81213: PUSH
81214: NOP4
81218: ARRAY
81219: PPUSH
81220: NOP4
// x := tmp [ j ] ;
81224: NOP4
81228: PUSH
81229: NOP4
81233: PUSH
81234: NOP4
81238: ARRAY
81239: ST_TO_ADDR
// attacking := true ;
81240: NOP4
81244: PUSH
81245: LD_INT 1
81247: ST_TO_ADDR
// end ; end ;
81248: GO 81174
81250: POP
81251: POP
// if not x then
81252: NOP4
81256: NOT
81257: IFFALSE 81397
// begin attacking := true ;
81259: NOP4
81263: PUSH
81264: LD_INT 1
81266: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
81267: NOP4
81271: PUSH
81272: NOP4
81276: ARRAY
81277: PPUSH
81278: NOP4
81282: PPUSH
81283: NOP4
81287: PUSH
81288: NOP4
81292: ARRAY
81293: PPUSH
81294: NOP4
81298: PPUSH
81299: NOP4
81303: PUSH
81304: LD_INT 2
81306: ARRAY
81307: PUSH
81308: NOP4
81312: PUSH
81313: LD_INT 1
81315: ARRAY
81316: PPUSH
81317: NOP4
81321: PPUSH
81322: NOP4
81326: PUSH
81327: LD_INT 1
81329: ARRAY
81330: PPUSH
81331: NOP4
81335: PPUSH
81336: NOP4
81340: PUSH
81341: LD_INT 2
81343: ARRAY
81344: EQUAL
81345: IFFALSE 81373
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
81347: NOP4
81351: PUSH
81352: NOP4
81356: ARRAY
81357: PPUSH
81358: NOP4
81362: PUSH
81363: LD_INT 1
81365: ARRAY
81366: PPUSH
81367: NOP4
81371: GO 81397
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81373: NOP4
81377: PUSH
81378: NOP4
81382: ARRAY
81383: PPUSH
81384: NOP4
81388: PUSH
81389: LD_INT 1
81391: ARRAY
81392: PPUSH
81393: NOP4
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
81397: NOP4
81401: PUSH
81402: NOP4
81406: ARRAY
81407: PPUSH
81408: NOP4
81412: PUSH
81413: LD_INT 29
81415: EQUAL
81416: IFFALSE 81782
// begin if WantsToAttack ( group [ i ] ) in bombed then
81418: NOP4
81422: PUSH
81423: NOP4
81427: ARRAY
81428: PPUSH
81429: NOP4
81433: PUSH
81434: NOP4
81438: IN
81439: IFFALSE 81443
// continue ;
81441: GO 78447
// k := 8 ;
81443: NOP4
81447: PUSH
81448: LD_INT 8
81450: ST_TO_ADDR
// x := 0 ;
81451: NOP4
81455: PUSH
81456: LD_INT 0
81458: ST_TO_ADDR
// if tmp < k then
81459: NOP4
81463: PUSH
81464: NOP4
81468: LESS
81469: IFFALSE 81481
// k := tmp ;
81471: NOP4
81475: PUSH
81476: NOP4
81480: ST_TO_ADDR
// for j = 1 to k do
81481: NOP4
81485: PUSH
81486: DOUBLE
81487: LD_INT 1
81489: DEC
81490: ST_TO_ADDR
81491: NOP4
81495: PUSH
81496: FOR_TO
81497: IFFALSE 81629
// begin if GetType ( tmp [ j ] ) = unit_building then
81499: NOP4
81503: PUSH
81504: NOP4
81508: ARRAY
81509: PPUSH
81510: NOP4
81514: PUSH
81515: LD_INT 3
81517: EQUAL
81518: IFFALSE 81627
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
81520: NOP4
81524: PUSH
81525: NOP4
81529: ARRAY
81530: PUSH
81531: NOP4
81535: IN
81536: NOT
81537: PUSH
81538: NOP4
81542: PUSH
81543: NOP4
81547: ARRAY
81548: PPUSH
81549: NOP4
81553: AND
81554: IFFALSE 81627
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81556: NOP4
81560: PUSH
81561: NOP4
81565: ARRAY
81566: PPUSH
81567: NOP4
81571: PUSH
81572: NOP4
81576: ARRAY
81577: PPUSH
81578: NOP4
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
81582: NOP4
81586: PUSH
81587: NOP4
81591: PPUSH
81592: NOP4
81596: PUSH
81597: LD_INT 1
81599: PLUS
81600: PPUSH
81601: NOP4
81605: PUSH
81606: NOP4
81610: ARRAY
81611: PPUSH
81612: NOP4
81616: ST_TO_ADDR
// attacking := true ;
81617: NOP4
81621: PUSH
81622: LD_INT 1
81624: ST_TO_ADDR
// break ;
81625: GO 81629
// end ; end ;
81627: GO 81496
81629: POP
81630: POP
// if not attacking and f_attack_depot then
81631: NOP4
81635: NOT
81636: PUSH
81637: NOP4
81641: AND
81642: IFFALSE 81737
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81644: NOP4
81648: PUSH
81649: NOP4
81653: PPUSH
81654: LD_INT 2
81656: PUSH
81657: LD_INT 30
81659: PUSH
81660: LD_INT 0
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: PUSH
81667: LD_INT 30
81669: PUSH
81670: LD_INT 1
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: LIST
81681: PPUSH
81682: NOP4
81686: ST_TO_ADDR
// if z then
81687: NOP4
81691: IFFALSE 81737
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81693: NOP4
81697: PUSH
81698: NOP4
81702: ARRAY
81703: PPUSH
81704: NOP4
81708: PPUSH
81709: NOP4
81713: PUSH
81714: NOP4
81718: ARRAY
81719: PPUSH
81720: NOP4
81724: PPUSH
81725: NOP4
// attacking := true ;
81729: NOP4
81733: PUSH
81734: LD_INT 1
81736: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
81737: NOP4
81741: PUSH
81742: NOP4
81746: ARRAY
81747: PPUSH
81748: NOP4
81752: PUSH
81753: LD_INT 500
81755: LESS
81756: IFFALSE 81782
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81758: NOP4
81762: PUSH
81763: NOP4
81767: ARRAY
81768: PPUSH
81769: NOP4
81773: PUSH
81774: LD_INT 1
81776: ARRAY
81777: PPUSH
81778: NOP4
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
81782: NOP4
81786: PUSH
81787: NOP4
81791: ARRAY
81792: PPUSH
81793: NOP4
81797: PUSH
81798: LD_INT 49
81800: EQUAL
81801: IFFALSE 81922
// begin if not HasTask ( group [ i ] ) then
81803: NOP4
81807: PUSH
81808: NOP4
81812: ARRAY
81813: PPUSH
81814: NOP4
81818: NOT
81819: IFFALSE 81922
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
81821: NOP4
81825: PUSH
81826: LD_INT 81
81828: PUSH
81829: NOP4
81833: PUSH
81834: NOP4
81838: ARRAY
81839: PPUSH
81840: NOP4
81844: PUSH
81845: EMPTY
81846: LIST
81847: LIST
81848: PPUSH
81849: NOP4
81853: PPUSH
81854: NOP4
81858: PUSH
81859: NOP4
81863: ARRAY
81864: PPUSH
81865: NOP4
81869: ST_TO_ADDR
// if k then
81870: NOP4
81874: IFFALSE 81922
// if GetDistUnits ( group [ i ] , k ) > 10 then
81876: NOP4
81880: PUSH
81881: NOP4
81885: ARRAY
81886: PPUSH
81887: NOP4
81891: PPUSH
81892: NOP4
81896: PUSH
81897: LD_INT 10
81899: GREATER
81900: IFFALSE 81922
// ComMoveUnit ( group [ i ] , k ) ;
81902: NOP4
81906: PUSH
81907: NOP4
81911: ARRAY
81912: PPUSH
81913: NOP4
81917: PPUSH
81918: NOP4
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81922: NOP4
81926: PUSH
81927: NOP4
81931: ARRAY
81932: PPUSH
81933: NOP4
81937: PUSH
81938: LD_INT 250
81940: LESS
81941: PUSH
81942: NOP4
81946: PUSH
81947: NOP4
81951: ARRAY
81952: PUSH
81953: LD_INT 21
81955: PUSH
81956: LD_INT 2
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: PUSH
81963: LD_INT 23
81965: PUSH
81966: LD_INT 2
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PPUSH
81977: NOP4
81981: IN
81982: AND
81983: IFFALSE 82108
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
81985: NOP4
81989: PUSH
81990: NOP4
81994: PUSH
81995: NOP4
81999: PUSH
82000: NOP4
82004: ARRAY
82005: DIFF
82006: PPUSH
82007: NOP4
82011: PUSH
82012: NOP4
82016: ARRAY
82017: PPUSH
82018: NOP4
82022: ST_TO_ADDR
// if not k then
82023: NOP4
82027: NOT
82028: IFFALSE 82032
// continue ;
82030: GO 78447
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
82032: NOP4
82036: PUSH
82037: LD_INT 81
82039: PUSH
82040: NOP4
82044: PUSH
82045: NOP4
82049: ARRAY
82050: PPUSH
82051: NOP4
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PPUSH
82060: NOP4
82064: IN
82065: PUSH
82066: NOP4
82070: PPUSH
82071: NOP4
82075: PUSH
82076: NOP4
82080: ARRAY
82081: PPUSH
82082: NOP4
82086: PUSH
82087: LD_INT 5
82089: LESS
82090: AND
82091: IFFALSE 82108
// ComAutodestruct ( group [ i ] ) ;
82093: NOP4
82097: PUSH
82098: NOP4
82102: ARRAY
82103: PPUSH
82104: NOP4
// end ; if f_attack_depot then
82108: NOP4
82112: IFFALSE 82224
// begin k := 6 ;
82114: NOP4
82118: PUSH
82119: LD_INT 6
82121: ST_TO_ADDR
// if tmp < k then
82122: NOP4
82126: PUSH
82127: NOP4
82131: LESS
82132: IFFALSE 82144
// k := tmp ;
82134: NOP4
82138: PUSH
82139: NOP4
82143: ST_TO_ADDR
// for j = 1 to k do
82144: NOP4
82148: PUSH
82149: DOUBLE
82150: LD_INT 1
82152: DEC
82153: ST_TO_ADDR
82154: NOP4
82158: PUSH
82159: FOR_TO
82160: IFFALSE 82222
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
82162: NOP4
82166: PPUSH
82167: NOP4
82171: PUSH
82172: LD_INT 0
82174: PUSH
82175: LD_INT 1
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: IN
82182: IFFALSE 82220
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82184: NOP4
82188: PUSH
82189: NOP4
82193: ARRAY
82194: PPUSH
82195: NOP4
82199: PUSH
82200: NOP4
82204: ARRAY
82205: PPUSH
82206: NOP4
// attacking := true ;
82210: NOP4
82214: PUSH
82215: LD_INT 1
82217: ST_TO_ADDR
// break ;
82218: GO 82222
// end ;
82220: GO 82159
82222: POP
82223: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
82224: NOP4
82228: PUSH
82229: NOP4
82233: ARRAY
82234: PPUSH
82235: NOP4
82239: PUSH
82240: NOP4
82244: NOT
82245: AND
82246: IFFALSE 82568
// begin if GetTag ( group [ i ] ) = 71 then
82248: NOP4
82252: PUSH
82253: NOP4
82257: ARRAY
82258: PPUSH
82259: NOP4
82263: PUSH
82264: LD_INT 71
82266: EQUAL
82267: IFFALSE 82308
// begin if HasTask ( group [ i ] ) then
82269: NOP4
82273: PUSH
82274: NOP4
82278: ARRAY
82279: PPUSH
82280: NOP4
82284: IFFALSE 82290
// continue else
82286: GO 78447
82288: GO 82308
// SetTag ( group [ i ] , 0 ) ;
82290: NOP4
82294: PUSH
82295: NOP4
82299: ARRAY
82300: PPUSH
82301: LD_INT 0
82303: PPUSH
82304: NOP4
// end ; k := 8 ;
82308: NOP4
82312: PUSH
82313: LD_INT 8
82315: ST_TO_ADDR
// x := 0 ;
82316: NOP4
82320: PUSH
82321: LD_INT 0
82323: ST_TO_ADDR
// if tmp < k then
82324: NOP4
82328: PUSH
82329: NOP4
82333: LESS
82334: IFFALSE 82346
// k := tmp ;
82336: NOP4
82340: PUSH
82341: NOP4
82345: ST_TO_ADDR
// for j = 1 to k do
82346: NOP4
82350: PUSH
82351: DOUBLE
82352: LD_INT 1
82354: DEC
82355: ST_TO_ADDR
82356: NOP4
82360: PUSH
82361: FOR_TO
82362: IFFALSE 82460
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
82364: NOP4
82368: PUSH
82369: NOP4
82373: ARRAY
82374: PPUSH
82375: NOP4
82379: PUSH
82380: LD_INT 1
82382: EQUAL
82383: PUSH
82384: NOP4
82388: PUSH
82389: NOP4
82393: ARRAY
82394: PPUSH
82395: NOP4
82399: PUSH
82400: LD_INT 250
82402: LESS
82403: PUSH
82404: NOP4
82408: AND
82409: PUSH
82410: NOP4
82414: NOT
82415: PUSH
82416: NOP4
82420: PUSH
82421: NOP4
82425: ARRAY
82426: PPUSH
82427: NOP4
82431: PUSH
82432: LD_INT 250
82434: GREATEREQUAL
82435: AND
82436: OR
82437: AND
82438: IFFALSE 82458
// begin x := tmp [ j ] ;
82440: NOP4
82444: PUSH
82445: NOP4
82449: PUSH
82450: NOP4
82454: ARRAY
82455: ST_TO_ADDR
// break ;
82456: GO 82460
// end ;
82458: GO 82361
82460: POP
82461: POP
// if x then
82462: NOP4
82466: IFFALSE 82490
// ComAttackUnit ( group [ i ] , x ) else
82468: NOP4
82472: PUSH
82473: NOP4
82477: ARRAY
82478: PPUSH
82479: NOP4
82483: PPUSH
82484: NOP4
82488: GO 82514
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82490: NOP4
82494: PUSH
82495: NOP4
82499: ARRAY
82500: PPUSH
82501: NOP4
82505: PUSH
82506: LD_INT 1
82508: ARRAY
82509: PPUSH
82510: NOP4
// if not HasTask ( group [ i ] ) then
82514: NOP4
82518: PUSH
82519: NOP4
82523: ARRAY
82524: PPUSH
82525: NOP4
82529: NOT
82530: IFFALSE 82568
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
82532: NOP4
82536: PUSH
82537: NOP4
82541: ARRAY
82542: PPUSH
82543: NOP4
82547: PPUSH
82548: NOP4
82552: PUSH
82553: NOP4
82557: ARRAY
82558: PPUSH
82559: NOP4
82563: PPUSH
82564: NOP4
// end ; end ; end ;
82568: GO 78447
82570: POP
82571: POP
// wait ( 0 0$2 ) ;
82572: LD_INT 70
82574: PPUSH
82575: NOP4
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
82579: NOP4
82583: NOT
82584: PUSH
82585: NOP4
82589: PUSH
82590: EMPTY
82591: EQUAL
82592: OR
82593: PUSH
82594: LD_INT 81
82596: PUSH
82597: NOP4
82601: PUSH
82602: EMPTY
82603: LIST
82604: LIST
82605: PPUSH
82606: NOP4
82610: NOT
82611: OR
82612: IFFALSE 78432
// end ;
82614: LD_VAR 0 2
82618: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
82619: LD_INT 0
82621: PPUSH
82622: PPUSH
82623: PPUSH
82624: PPUSH
82625: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
82626: NOP4
82630: NOT
82631: PUSH
82632: NOP4
82636: PUSH
82637: NOP4
82641: ARRAY
82642: NOT
82643: OR
82644: PUSH
82645: NOP4
82649: NOT
82650: OR
82651: PUSH
82652: NOP4
82656: NOT
82657: OR
82658: IFFALSE 82662
// exit ;
82660: GO 83175
// side := mc_sides [ base ] ;
82662: NOP4
82666: PUSH
82667: NOP4
82671: PUSH
82672: NOP4
82676: ARRAY
82677: ST_TO_ADDR
// if not side then
82678: NOP4
82682: NOT
82683: IFFALSE 82687
// exit ;
82685: GO 83175
// for i in solds do
82687: NOP4
82691: PUSH
82692: NOP4
82696: PUSH
82697: FOR_IN
82698: IFFALSE 82759
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
82700: NOP4
82704: PPUSH
82705: NOP4
82709: PPUSH
82710: NOP4
82714: PUSH
82715: LD_INT 32
82717: PUSH
82718: LD_INT 31
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: IN
82725: IFFALSE 82745
// solds := solds diff i else
82727: NOP4
82731: PUSH
82732: NOP4
82736: PUSH
82737: NOP4
82741: DIFF
82742: ST_TO_ADDR
82743: GO 82757
// SetTag ( i , 18 ) ;
82745: NOP4
82749: PPUSH
82750: LD_INT 18
82752: PPUSH
82753: NOP4
82757: GO 82697
82759: POP
82760: POP
// if not solds then
82761: NOP4
82765: NOT
82766: IFFALSE 82770
// exit ;
82768: GO 83175
// repeat wait ( 0 0$2 ) ;
82770: LD_INT 70
82772: PPUSH
82773: NOP4
// enemy := ScanBase ( side , area ) ;
82777: NOP4
82781: PUSH
82782: NOP4
82786: PPUSH
82787: NOP4
82791: PPUSH
82792: NOP4
82796: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82797: NOP4
82801: PUSH
82802: NOP4
82806: ARRAY
82807: NOT
82808: PUSH
82809: NOP4
82813: PUSH
82814: NOP4
82818: ARRAY
82819: PUSH
82820: EMPTY
82821: EQUAL
82822: OR
82823: IFFALSE 82860
// begin for i in solds do
82825: NOP4
82829: PUSH
82830: NOP4
82834: PUSH
82835: FOR_IN
82836: IFFALSE 82849
// ComStop ( i ) ;
82838: NOP4
82842: PPUSH
82843: NOP4
82847: GO 82835
82849: POP
82850: POP
// solds := [ ] ;
82851: NOP4
82855: PUSH
82856: EMPTY
82857: ST_TO_ADDR
// exit ;
82858: GO 83175
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
82860: NOP4
82864: NOT
82865: PUSH
82866: NOP4
82870: PUSH
82871: LD_INT 3
82873: GREATER
82874: OR
82875: PUSH
82876: NOP4
82880: PUSH
82881: NOP4
82885: ARRAY
82886: OR
82887: IFFALSE 82928
// begin for i in solds do
82889: NOP4
82893: PUSH
82894: NOP4
82898: PUSH
82899: FOR_IN
82900: IFFALSE 82924
// if HasTask ( i ) then
82902: NOP4
82906: PPUSH
82907: NOP4
82911: IFFALSE 82922
// ComStop ( i ) ;
82913: NOP4
82917: PPUSH
82918: NOP4
82922: GO 82899
82924: POP
82925: POP
// break ;
82926: GO 83163
// end ; for i in solds do
82928: NOP4
82932: PUSH
82933: NOP4
82937: PUSH
82938: FOR_IN
82939: IFFALSE 83155
// begin if IsInUnit ( i ) then
82941: NOP4
82945: PPUSH
82946: NOP4
82950: IFFALSE 82961
// ComExitBuilding ( i ) ;
82952: NOP4
82956: PPUSH
82957: NOP4
// if GetLives ( i ) > 333 then
82961: NOP4
82965: PPUSH
82966: NOP4
82970: PUSH
82971: LD_INT 333
82973: GREATER
82974: IFFALSE 83002
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
82976: NOP4
82980: PPUSH
82981: NOP4
82985: PPUSH
82986: NOP4
82990: PPUSH
82991: NOP4
82995: PPUSH
82996: NOP4
83000: GO 83153
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
83002: NOP4
83006: PUSH
83007: NOP4
83011: PUSH
83012: NOP4
83016: ARRAY
83017: PPUSH
83018: LD_INT 2
83020: PUSH
83021: LD_INT 30
83023: PUSH
83024: LD_INT 0
83026: PUSH
83027: EMPTY
83028: LIST
83029: LIST
83030: PUSH
83031: LD_INT 30
83033: PUSH
83034: LD_INT 1
83036: PUSH
83037: EMPTY
83038: LIST
83039: LIST
83040: PUSH
83041: LD_INT 30
83043: PUSH
83044: LD_INT 6
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: PPUSH
83057: NOP4
83061: PPUSH
83062: NOP4
83066: PPUSH
83067: NOP4
83071: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
83072: NOP4
83076: PPUSH
83077: NOP4
83081: PPUSH
83082: NOP4
83086: PPUSH
83087: LD_INT 3
83089: PPUSH
83090: LD_INT 5
83092: PPUSH
83093: NOP4
83097: PPUSH
83098: NOP4
83102: PPUSH
83103: NOP4
83107: PPUSH
83108: LD_INT 3
83110: PPUSH
83111: LD_INT 5
83113: PPUSH
83114: NOP4
83118: PPUSH
83119: NOP4
// SetTag ( i , 0 ) ;
83123: NOP4
83127: PPUSH
83128: LD_INT 0
83130: PPUSH
83131: NOP4
// solds := solds diff i ;
83135: NOP4
83139: PUSH
83140: NOP4
83144: PUSH
83145: NOP4
83149: DIFF
83150: ST_TO_ADDR
// continue ;
83151: GO 82938
// end ; end ;
83153: GO 82938
83155: POP
83156: POP
// until solds ;
83157: NOP4
83161: IFFALSE 82770
// MC_Reset ( base , 18 ) ;
83163: NOP4
83167: PPUSH
83168: LD_INT 18
83170: PPUSH
83171: NOP4
// end ;
83175: LD_VAR 0 4
83179: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
83180: LD_INT 0
83182: PPUSH
83183: PPUSH
83184: PPUSH
83185: PPUSH
83186: PPUSH
83187: PPUSH
83188: PPUSH
83189: PPUSH
83190: PPUSH
83191: PPUSH
83192: PPUSH
83193: PPUSH
83194: PPUSH
83195: PPUSH
83196: PPUSH
83197: PPUSH
83198: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
83199: NOP4
83203: PUSH
83204: NOP4
83208: PUSH
83209: NOP4
83213: ARRAY
83214: PPUSH
83215: LD_INT 25
83217: PUSH
83218: LD_INT 3
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PPUSH
83225: NOP4
83229: ST_TO_ADDR
// if mc_remote_driver [ base ] then
83230: NOP4
83234: PUSH
83235: NOP4
83239: ARRAY
83240: IFFALSE 83264
// mechs := mechs diff mc_remote_driver [ base ] ;
83242: NOP4
83246: PUSH
83247: NOP4
83251: PUSH
83252: NOP4
83256: PUSH
83257: NOP4
83261: ARRAY
83262: DIFF
83263: ST_TO_ADDR
// for i in mechs do
83264: NOP4
83268: PUSH
83269: NOP4
83273: PUSH
83274: FOR_IN
83275: IFFALSE 83310
// if GetTag ( i ) > 0 then
83277: NOP4
83281: PPUSH
83282: NOP4
83286: PUSH
83287: LD_INT 0
83289: GREATER
83290: IFFALSE 83308
// mechs := mechs diff i ;
83292: NOP4
83296: PUSH
83297: NOP4
83301: PUSH
83302: NOP4
83306: DIFF
83307: ST_TO_ADDR
83308: GO 83274
83310: POP
83311: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
83312: NOP4
83316: PUSH
83317: NOP4
83321: PUSH
83322: NOP4
83326: ARRAY
83327: PPUSH
83328: LD_INT 2
83330: PUSH
83331: LD_INT 25
83333: PUSH
83334: LD_INT 1
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 25
83343: PUSH
83344: LD_INT 5
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PUSH
83351: LD_INT 25
83353: PUSH
83354: LD_INT 8
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 25
83363: PUSH
83364: LD_INT 9
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: EMPTY
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: PPUSH
83378: NOP4
83382: ST_TO_ADDR
// if not defenders and not solds then
83383: NOP4
83387: NOT
83388: PUSH
83389: NOP4
83393: NOT
83394: AND
83395: IFFALSE 83399
// exit ;
83397: GO 85089
// depot_under_attack := false ;
83399: NOP4
83403: PUSH
83404: LD_INT 0
83406: ST_TO_ADDR
// sold_defenders := [ ] ;
83407: NOP4
83411: PUSH
83412: EMPTY
83413: ST_TO_ADDR
// if mechs then
83414: NOP4
83418: IFFALSE 83571
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
83420: NOP4
83424: PUSH
83425: NOP4
83429: PPUSH
83430: LD_INT 21
83432: PUSH
83433: LD_INT 2
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PPUSH
83440: NOP4
83444: PUSH
83445: FOR_IN
83446: IFFALSE 83569
// begin if GetTag ( i ) <> 20 then
83448: NOP4
83452: PPUSH
83453: NOP4
83457: PUSH
83458: LD_INT 20
83460: NONEQUAL
83461: IFFALSE 83475
// SetTag ( i , 20 ) ;
83463: NOP4
83467: PPUSH
83468: LD_INT 20
83470: PPUSH
83471: NOP4
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
83475: NOP4
83479: PPUSH
83480: NOP4
83484: PUSH
83485: LD_INT 1
83487: EQUAL
83488: PUSH
83489: NOP4
83493: PPUSH
83494: NOP4
83498: NOT
83499: AND
83500: IFFALSE 83567
// begin un := mechs [ 1 ] ;
83502: NOP4
83506: PUSH
83507: NOP4
83511: PUSH
83512: LD_INT 1
83514: ARRAY
83515: ST_TO_ADDR
// ComExit ( un ) ;
83516: NOP4
83520: PPUSH
83521: NOP4
// AddComEnterUnit ( un , i ) ;
83525: NOP4
83529: PPUSH
83530: NOP4
83534: PPUSH
83535: NOP4
// SetTag ( un , 19 ) ;
83539: NOP4
83543: PPUSH
83544: LD_INT 19
83546: PPUSH
83547: NOP4
// mechs := mechs diff un ;
83551: NOP4
83555: PUSH
83556: NOP4
83560: PUSH
83561: NOP4
83565: DIFF
83566: ST_TO_ADDR
// end ; end ;
83567: GO 83445
83569: POP
83570: POP
// if solds then
83571: NOP4
83575: IFFALSE 83634
// for i in solds do
83577: NOP4
83581: PUSH
83582: NOP4
83586: PUSH
83587: FOR_IN
83588: IFFALSE 83632
// if not GetTag ( i ) then
83590: NOP4
83594: PPUSH
83595: NOP4
83599: NOT
83600: IFFALSE 83630
// begin defenders := defenders union i ;
83602: NOP4
83606: PUSH
83607: NOP4
83611: PUSH
83612: NOP4
83616: UNION
83617: ST_TO_ADDR
// SetTag ( i , 18 ) ;
83618: NOP4
83622: PPUSH
83623: LD_INT 18
83625: PPUSH
83626: NOP4
// end ;
83630: GO 83587
83632: POP
83633: POP
// repeat wait ( 0 0$2 ) ;
83634: LD_INT 70
83636: PPUSH
83637: NOP4
// enemy := mc_scan [ base ] ;
83641: NOP4
83645: PUSH
83646: NOP4
83650: PUSH
83651: NOP4
83655: ARRAY
83656: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83657: NOP4
83661: PUSH
83662: NOP4
83666: ARRAY
83667: NOT
83668: PUSH
83669: NOP4
83673: PUSH
83674: NOP4
83678: ARRAY
83679: PUSH
83680: EMPTY
83681: EQUAL
83682: OR
83683: IFFALSE 83720
// begin for i in defenders do
83685: NOP4
83689: PUSH
83690: NOP4
83694: PUSH
83695: FOR_IN
83696: IFFALSE 83709
// ComStop ( i ) ;
83698: NOP4
83702: PPUSH
83703: NOP4
83707: GO 83695
83709: POP
83710: POP
// defenders := [ ] ;
83711: NOP4
83715: PUSH
83716: EMPTY
83717: ST_TO_ADDR
// exit ;
83718: GO 85089
// end ; for i in defenders do
83720: NOP4
83724: PUSH
83725: NOP4
83729: PUSH
83730: FOR_IN
83731: IFFALSE 84549
// begin e := NearestUnitToUnit ( enemy , i ) ;
83733: NOP4
83737: PUSH
83738: NOP4
83742: PPUSH
83743: NOP4
83747: PPUSH
83748: NOP4
83752: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83753: NOP4
83757: PUSH
83758: NOP4
83762: PUSH
83763: NOP4
83767: ARRAY
83768: PPUSH
83769: LD_INT 2
83771: PUSH
83772: LD_INT 30
83774: PUSH
83775: LD_INT 0
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 30
83784: PUSH
83785: LD_INT 1
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: EMPTY
83793: LIST
83794: LIST
83795: LIST
83796: PPUSH
83797: NOP4
83801: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
83802: NOP4
83806: PUSH
83807: NOP4
83811: NOT
83812: PUSH
83813: NOP4
83817: PPUSH
83818: LD_INT 3
83820: PUSH
83821: LD_INT 24
83823: PUSH
83824: LD_INT 600
83826: PUSH
83827: EMPTY
83828: LIST
83829: LIST
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PPUSH
83835: NOP4
83839: OR
83840: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
83841: NOP4
83845: PPUSH
83846: NOP4
83850: PUSH
83851: LD_INT 2
83853: DOUBLE
83854: EQUAL
83855: IFTRUE 83859
83857: GO 84255
83859: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
83860: NOP4
83864: PPUSH
83865: NOP4
83869: PUSH
83870: LD_INT 1000
83872: EQUAL
83873: PUSH
83874: NOP4
83878: PPUSH
83879: NOP4
83883: PPUSH
83884: NOP4
83888: PUSH
83889: LD_INT 40
83891: LESS
83892: PUSH
83893: NOP4
83897: PPUSH
83898: NOP4
83902: PUSH
83903: NOP4
83907: ARRAY
83908: PPUSH
83909: NOP4
83913: OR
83914: AND
83915: IFFALSE 84037
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
83917: NOP4
83921: PPUSH
83922: NOP4
83926: PUSH
83927: LD_INT 1
83929: EQUAL
83930: PUSH
83931: NOP4
83935: PPUSH
83936: NOP4
83940: PUSH
83941: LD_INT 30
83943: LESS
83944: AND
83945: PUSH
83946: NOP4
83950: AND
83951: IFFALSE 84021
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
83953: NOP4
83957: PPUSH
83958: NOP4
83962: PPUSH
83963: NOP4
83967: PPUSH
83968: NOP4
83972: PPUSH
83973: NOP4
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
83977: NOP4
83981: PPUSH
83982: NOP4
83986: PPUSH
83987: NOP4
83991: PPUSH
83992: NOP4
83996: PPUSH
83997: NOP4
84001: PUSH
84002: LD_INT 6
84004: LESS
84005: IFFALSE 84019
// SetFuel ( i , 100 ) ;
84007: NOP4
84011: PPUSH
84012: LD_INT 100
84014: PPUSH
84015: NOP4
// end else
84019: GO 84035
// ComAttackUnit ( i , e ) ;
84021: NOP4
84025: PPUSH
84026: NOP4
84030: PPUSH
84031: NOP4
// end else
84035: GO 84138
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
84037: NOP4
84041: PPUSH
84042: NOP4
84046: PUSH
84047: NOP4
84051: ARRAY
84052: PPUSH
84053: NOP4
84057: NOT
84058: PUSH
84059: NOP4
84063: PPUSH
84064: NOP4
84068: PPUSH
84069: NOP4
84073: PUSH
84074: LD_INT 40
84076: GREATEREQUAL
84077: AND
84078: PUSH
84079: NOP4
84083: PPUSH
84084: NOP4
84088: PUSH
84089: LD_INT 650
84091: LESSEQUAL
84092: OR
84093: PUSH
84094: NOP4
84098: PPUSH
84099: NOP4
84103: PUSH
84104: NOP4
84108: ARRAY
84109: PPUSH
84110: NOP4
84114: NOT
84115: AND
84116: IFFALSE 84138
// ComMoveToArea ( i , mc_parking [ base ] ) ;
84118: NOP4
84122: PPUSH
84123: NOP4
84127: PUSH
84128: NOP4
84132: ARRAY
84133: PPUSH
84134: NOP4
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
84138: NOP4
84142: PPUSH
84143: NOP4
84147: PUSH
84148: LD_INT 1000
84150: LESS
84151: PUSH
84152: NOP4
84156: PPUSH
84157: NOP4
84161: PUSH
84162: LD_INT 1
84164: EQUAL
84165: AND
84166: PUSH
84167: NOP4
84171: PPUSH
84172: NOP4
84176: AND
84177: PUSH
84178: NOP4
84182: PPUSH
84183: NOP4
84187: PUSH
84188: NOP4
84192: ARRAY
84193: PPUSH
84194: NOP4
84198: AND
84199: IFFALSE 84253
// begin mech := IsDrivenBy ( i ) ;
84201: NOP4
84205: PUSH
84206: NOP4
84210: PPUSH
84211: NOP4
84215: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
84216: NOP4
84220: PPUSH
84221: NOP4
// AddComRepairVehicle ( mech , i ) ;
84225: NOP4
84229: PPUSH
84230: NOP4
84234: PPUSH
84235: NOP4
// AddComEnterUnit ( mech , i ) ;
84239: NOP4
84243: PPUSH
84244: NOP4
84248: PPUSH
84249: NOP4
// end ; end ; unit_human :
84253: GO 84520
84255: LD_INT 1
84257: DOUBLE
84258: EQUAL
84259: IFTRUE 84263
84261: GO 84519
84263: POP
// begin b := IsInUnit ( i ) ;
84264: NOP4
84268: PUSH
84269: NOP4
84273: PPUSH
84274: NOP4
84278: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
84279: NOP4
84283: PUSH
84284: NOP4
84288: NOT
84289: PUSH
84290: NOP4
84294: PPUSH
84295: NOP4
84299: PUSH
84300: LD_INT 32
84302: PUSH
84303: LD_INT 31
84305: PUSH
84306: EMPTY
84307: LIST
84308: LIST
84309: IN
84310: OR
84311: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
84312: NOP4
84316: PUSH
84317: NOP4
84321: PPUSH
84322: LD_INT 21
84324: PUSH
84325: LD_INT 2
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PPUSH
84332: NOP4
84336: PUSH
84337: LD_INT 1
84339: LESSEQUAL
84340: OR
84341: PUSH
84342: NOP4
84346: AND
84347: PUSH
84348: NOP4
84352: PUSH
84353: NOP4
84357: IN
84358: NOT
84359: AND
84360: IFFALSE 84453
// begin if b then
84362: NOP4
84366: IFFALSE 84415
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
84368: NOP4
84372: PPUSH
84373: NOP4
84377: PPUSH
84378: NOP4
84382: PPUSH
84383: NOP4
84387: PPUSH
84388: NOP4
84392: PUSH
84393: LD_INT 10
84395: LESS
84396: PUSH
84397: NOP4
84401: PPUSH
84402: NOP4
84406: PUSH
84407: LD_INT 7
84409: NONEQUAL
84410: AND
84411: IFFALSE 84415
// continue ;
84413: GO 83730
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
84415: NOP4
84419: PUSH
84420: NOP4
84424: PPUSH
84425: NOP4
84429: PUSH
84430: LD_INT 1
84432: PLUS
84433: PPUSH
84434: NOP4
84438: PPUSH
84439: NOP4
84443: ST_TO_ADDR
// ComExitBuilding ( i ) ;
84444: NOP4
84448: PPUSH
84449: NOP4
// end ; if sold_defenders then
84453: NOP4
84457: IFFALSE 84517
// if i in sold_defenders then
84459: NOP4
84463: PUSH
84464: NOP4
84468: IN
84469: IFFALSE 84517
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
84471: NOP4
84475: PPUSH
84476: NOP4
84480: NOT
84481: PUSH
84482: NOP4
84486: PPUSH
84487: NOP4
84491: PPUSH
84492: NOP4
84496: PUSH
84497: LD_INT 30
84499: LESS
84500: AND
84501: IFFALSE 84517
// ComAttackUnit ( i , e ) ;
84503: NOP4
84507: PPUSH
84508: NOP4
84512: PPUSH
84513: NOP4
// end ; end ; end ;
84517: GO 84520
84519: POP
// if IsDead ( i ) then
84520: NOP4
84524: PPUSH
84525: NOP4
84529: IFFALSE 84547
// defenders := defenders diff i ;
84531: NOP4
84535: PUSH
84536: NOP4
84540: PUSH
84541: NOP4
84545: DIFF
84546: ST_TO_ADDR
// end ;
84547: GO 83730
84549: POP
84550: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
84551: NOP4
84555: NOT
84556: PUSH
84557: NOP4
84561: NOT
84562: OR
84563: PUSH
84564: NOP4
84568: PUSH
84569: NOP4
84573: ARRAY
84574: NOT
84575: OR
84576: IFFALSE 83634
// MC_Reset ( base , 18 ) ;
84578: NOP4
84582: PPUSH
84583: LD_INT 18
84585: PPUSH
84586: NOP4
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
84590: NOP4
84594: PUSH
84595: NOP4
84599: PUSH
84600: NOP4
84604: PPUSH
84605: LD_INT 2
84607: PUSH
84608: LD_INT 25
84610: PUSH
84611: LD_INT 1
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 25
84620: PUSH
84621: LD_INT 5
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 25
84630: PUSH
84631: LD_INT 8
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: PUSH
84638: LD_INT 25
84640: PUSH
84641: LD_INT 9
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: PUSH
84648: EMPTY
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: PPUSH
84655: NOP4
84659: DIFF
84660: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
84661: NOP4
84665: NOT
84666: PUSH
84667: NOP4
84671: PPUSH
84672: LD_INT 21
84674: PUSH
84675: LD_INT 2
84677: PUSH
84678: EMPTY
84679: LIST
84680: LIST
84681: PPUSH
84682: NOP4
84686: AND
84687: IFFALSE 85025
// begin tmp := FilterByTag ( defenders , 19 ) ;
84689: NOP4
84693: PUSH
84694: NOP4
84698: PPUSH
84699: LD_INT 19
84701: PPUSH
84702: NOP4
84706: ST_TO_ADDR
// if tmp then
84707: NOP4
84711: IFFALSE 84781
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
84713: NOP4
84717: PUSH
84718: NOP4
84722: PPUSH
84723: LD_INT 25
84725: PUSH
84726: LD_INT 3
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PPUSH
84733: NOP4
84737: ST_TO_ADDR
// if tmp then
84738: NOP4
84742: IFFALSE 84781
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
84744: NOP4
84748: PUSH
84749: NOP4
84753: PPUSH
84754: NOP4
84758: PPUSH
84759: NOP4
84763: PUSH
84764: NOP4
84768: ARRAY
84769: PUSH
84770: NOP4
84774: UNION
84775: PPUSH
84776: NOP4
84780: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
84781: NOP4
84785: PPUSH
84786: LD_INT 19
84788: PPUSH
84789: NOP4
// repeat wait ( 0 0$1 ) ;
84793: LD_INT 35
84795: PPUSH
84796: NOP4
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84800: NOP4
84804: PUSH
84805: NOP4
84809: ARRAY
84810: NOT
84811: PUSH
84812: NOP4
84816: PUSH
84817: NOP4
84821: ARRAY
84822: PUSH
84823: EMPTY
84824: EQUAL
84825: OR
84826: IFFALSE 84863
// begin for i in defenders do
84828: NOP4
84832: PUSH
84833: NOP4
84837: PUSH
84838: FOR_IN
84839: IFFALSE 84852
// ComStop ( i ) ;
84841: NOP4
84845: PPUSH
84846: NOP4
84850: GO 84838
84852: POP
84853: POP
// defenders := [ ] ;
84854: NOP4
84858: PUSH
84859: EMPTY
84860: ST_TO_ADDR
// exit ;
84861: GO 85089
// end ; for i in defenders do
84863: NOP4
84867: PUSH
84868: NOP4
84872: PUSH
84873: FOR_IN
84874: IFFALSE 84963
// begin if not IsInArea ( i , mc_parking [ base ] ) then
84876: NOP4
84880: PPUSH
84881: NOP4
84885: PUSH
84886: NOP4
84890: ARRAY
84891: PPUSH
84892: NOP4
84896: NOT
84897: IFFALSE 84921
// ComMoveToArea ( i , mc_parking [ base ] ) else
84899: NOP4
84903: PPUSH
84904: NOP4
84908: PUSH
84909: NOP4
84913: ARRAY
84914: PPUSH
84915: NOP4
84919: GO 84961
// if GetControl ( i ) = control_manual then
84921: NOP4
84925: PPUSH
84926: NOP4
84930: PUSH
84931: LD_INT 1
84933: EQUAL
84934: IFFALSE 84961
// if IsDrivenBy ( i ) then
84936: NOP4
84940: PPUSH
84941: NOP4
84945: IFFALSE 84961
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
84947: NOP4
84951: PPUSH
84952: NOP4
84956: PPUSH
84957: NOP4
// end ;
84961: GO 84873
84963: POP
84964: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
84965: NOP4
84969: PPUSH
84970: LD_INT 95
84972: PUSH
84973: NOP4
84977: PUSH
84978: NOP4
84982: ARRAY
84983: PUSH
84984: EMPTY
84985: LIST
84986: LIST
84987: PPUSH
84988: NOP4
84992: PUSH
84993: NOP4
84997: EQUAL
84998: PUSH
84999: NOP4
85003: PUSH
85004: NOP4
85008: ARRAY
85009: OR
85010: PUSH
85011: NOP4
85015: PUSH
85016: NOP4
85020: ARRAY
85021: NOT
85022: OR
85023: IFFALSE 84793
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
85025: NOP4
85029: PUSH
85030: NOP4
85034: PPUSH
85035: NOP4
85039: PPUSH
85040: NOP4
85044: PPUSH
85045: LD_INT 21
85047: PUSH
85048: LD_INT 2
85050: PUSH
85051: EMPTY
85052: LIST
85053: LIST
85054: PPUSH
85055: NOP4
85059: PPUSH
85060: NOP4
85064: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
85065: NOP4
85069: PPUSH
85070: LD_INT 19
85072: PPUSH
85073: NOP4
// MC_Reset ( base , 20 ) ;
85077: NOP4
85081: PPUSH
85082: LD_INT 20
85084: PPUSH
85085: NOP4
// end ; end_of_file
85089: LD_VAR 0 4
85093: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
85094: LD_INT 0
85096: PPUSH
85097: PPUSH
85098: PPUSH
85099: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
85100: NOP4
85104: PPUSH
85105: NOP4
85109: PUSH
85110: NOP4
85114: EQUAL
85115: IFFALSE 85187
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
85117: LD_INT 68
85119: PPUSH
85120: NOP4
85124: PPUSH
85125: NOP4
85129: PPUSH
85130: NOP4
85134: PUSH
85135: LD_INT 2
85137: EQUAL
85138: IFFALSE 85150
// eff := 70 else
85140: NOP4
85144: PUSH
85145: LD_INT 70
85147: ST_TO_ADDR
85148: GO 85158
// eff := 30 ;
85150: NOP4
85154: PUSH
85155: LD_INT 30
85157: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
85158: NOP4
85162: PPUSH
85163: NOP4
85167: PPUSH
85168: NOP4
85172: PPUSH
85173: NOP4
85177: PPUSH
85178: NOP4
85182: PPUSH
85183: NOP4
// end ; end ;
85187: LD_VAR 0 2
85191: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
85192: LD_INT 0
85194: PPUSH
// end ;
85195: LD_VAR 0 4
85199: RET
// export function SOS_Command ( cmd ) ; begin
85200: LD_INT 0
85202: PPUSH
// end ;
85203: LD_VAR 0 2
85207: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
85208: LD_INT 0
85210: PPUSH
// if cmd = 121 then
85211: NOP4
85215: PUSH
85216: LD_INT 121
85218: EQUAL
85219: IFFALSE 85221
// end ;
85221: LD_VAR 0 6
85225: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
85226: LD_INT 0
85228: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
85229: NOP4
85233: PUSH
85234: LD_INT 250
85236: EQUAL
85237: PUSH
85238: NOP4
85242: PPUSH
85243: NOP4
85247: PUSH
85248: NOP4
85252: EQUAL
85253: AND
85254: IFFALSE 85275
// MinerPlaceMine ( unit , x , y ) ;
85256: NOP4
85260: PPUSH
85261: NOP4
85265: PPUSH
85266: NOP4
85270: PPUSH
85271: NOP4
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
85275: NOP4
85279: PUSH
85280: LD_INT 251
85282: EQUAL
85283: PUSH
85284: NOP4
85288: PPUSH
85289: NOP4
85293: PUSH
85294: NOP4
85298: EQUAL
85299: AND
85300: IFFALSE 85321
// MinerDetonateMine ( unit , x , y ) ;
85302: NOP4
85306: PPUSH
85307: NOP4
85311: PPUSH
85312: NOP4
85316: PPUSH
85317: NOP4
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
85321: NOP4
85325: PUSH
85326: LD_INT 252
85328: EQUAL
85329: PUSH
85330: NOP4
85334: PPUSH
85335: NOP4
85339: PUSH
85340: NOP4
85344: EQUAL
85345: AND
85346: IFFALSE 85367
// MinerCreateMinefield ( unit , x , y ) ;
85348: NOP4
85352: PPUSH
85353: NOP4
85357: PPUSH
85358: NOP4
85362: PPUSH
85363: NOP4
// if cmd = 253 and GetClass ( unit ) = class_sniper then
85367: NOP4
85371: PUSH
85372: LD_INT 253
85374: EQUAL
85375: PUSH
85376: NOP4
85380: PPUSH
85381: NOP4
85385: PUSH
85386: LD_INT 5
85388: EQUAL
85389: AND
85390: IFFALSE 85411
// ComBinocular ( unit , x , y ) ;
85392: NOP4
85396: PPUSH
85397: NOP4
85401: PPUSH
85402: NOP4
85406: PPUSH
85407: NOP4
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
85411: NOP4
85415: PUSH
85416: LD_INT 254
85418: EQUAL
85419: PUSH
85420: NOP4
85424: PPUSH
85425: NOP4
85429: PUSH
85430: NOP4
85434: EQUAL
85435: AND
85436: PUSH
85437: NOP4
85441: PPUSH
85442: NOP4
85446: PUSH
85447: LD_INT 3
85449: EQUAL
85450: AND
85451: IFFALSE 85467
// HackDestroyVehicle ( unit , selectedUnit ) ;
85453: NOP4
85457: PPUSH
85458: NOP4
85462: PPUSH
85463: NOP4
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
85467: NOP4
85471: PUSH
85472: LD_INT 255
85474: EQUAL
85475: PUSH
85476: NOP4
85480: PPUSH
85481: NOP4
85485: PUSH
85486: LD_INT 14
85488: PUSH
85489: LD_INT 53
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: IN
85496: AND
85497: PUSH
85498: NOP4
85502: PPUSH
85503: NOP4
85507: PPUSH
85508: NOP4
85512: AND
85513: IFFALSE 85537
// CutTreeXYR ( unit , x , y , 12 ) ;
85515: NOP4
85519: PPUSH
85520: NOP4
85524: PPUSH
85525: NOP4
85529: PPUSH
85530: LD_INT 12
85532: PPUSH
85533: NOP4
// end ;
85537: LD_VAR 0 6
85541: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
85542: LD_INT 0
85544: PPUSH
// end ;
85545: LD_VAR 0 4
85549: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
85550: LD_INT 0
85552: PPUSH
85553: PPUSH
85554: PPUSH
85555: PPUSH
85556: PPUSH
85557: PPUSH
85558: PPUSH
85559: PPUSH
85560: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
85561: NOP4
85565: NOT
85566: PUSH
85567: NOP4
85571: PPUSH
85572: NOP4
85576: PPUSH
85577: NOP4
85581: NOT
85582: OR
85583: PUSH
85584: NOP4
85588: NOT
85589: OR
85590: IFFALSE 85594
// exit ;
85592: GO 85934
// list := [ ] ;
85594: NOP4
85598: PUSH
85599: EMPTY
85600: ST_TO_ADDR
// if x - r < 0 then
85601: NOP4
85605: PUSH
85606: NOP4
85610: MINUS
85611: PUSH
85612: LD_INT 0
85614: LESS
85615: IFFALSE 85627
// min_x := 0 else
85617: NOP4
85621: PUSH
85622: LD_INT 0
85624: ST_TO_ADDR
85625: GO 85643
// min_x := x - r ;
85627: NOP4
85631: PUSH
85632: NOP4
85636: PUSH
85637: NOP4
85641: MINUS
85642: ST_TO_ADDR
// if y - r < 0 then
85643: NOP4
85647: PUSH
85648: NOP4
85652: MINUS
85653: PUSH
85654: LD_INT 0
85656: LESS
85657: IFFALSE 85669
// min_y := 0 else
85659: NOP4
85663: PUSH
85664: LD_INT 0
85666: ST_TO_ADDR
85667: GO 85685
// min_y := y - r ;
85669: NOP4
85673: PUSH
85674: NOP4
85678: PUSH
85679: NOP4
85683: MINUS
85684: ST_TO_ADDR
// max_x := x + r ;
85685: NOP4
85689: PUSH
85690: NOP4
85694: PUSH
85695: NOP4
85699: PLUS
85700: ST_TO_ADDR
// max_y := y + r ;
85701: NOP4
85705: PUSH
85706: NOP4
85710: PUSH
85711: NOP4
85715: PLUS
85716: ST_TO_ADDR
// for _x = min_x to max_x do
85717: NOP4
85721: PUSH
85722: DOUBLE
85723: NOP4
85727: DEC
85728: ST_TO_ADDR
85729: NOP4
85733: PUSH
85734: FOR_TO
85735: IFFALSE 85852
// for _y = min_y to max_y do
85737: NOP4
85741: PUSH
85742: DOUBLE
85743: NOP4
85747: DEC
85748: ST_TO_ADDR
85749: NOP4
85753: PUSH
85754: FOR_TO
85755: IFFALSE 85848
// begin if not ValidHex ( _x , _y ) then
85757: NOP4
85761: PPUSH
85762: NOP4
85766: PPUSH
85767: NOP4
85771: NOT
85772: IFFALSE 85776
// continue ;
85774: GO 85754
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
85776: NOP4
85780: PPUSH
85781: NOP4
85785: PPUSH
85786: NOP4
85790: PUSH
85791: NOP4
85795: PPUSH
85796: NOP4
85800: PPUSH
85801: NOP4
85805: AND
85806: IFFALSE 85846
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
85808: NOP4
85812: PUSH
85813: NOP4
85817: PPUSH
85818: NOP4
85822: PUSH
85823: LD_INT 1
85825: PLUS
85826: PPUSH
85827: NOP4
85831: PUSH
85832: NOP4
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: PPUSH
85841: NOP4
85845: ST_TO_ADDR
// end ;
85846: GO 85754
85848: POP
85849: POP
85850: GO 85734
85852: POP
85853: POP
// if not list then
85854: NOP4
85858: NOT
85859: IFFALSE 85863
// exit ;
85861: GO 85934
// for i in list do
85863: NOP4
85867: PUSH
85868: NOP4
85872: PUSH
85873: FOR_IN
85874: IFFALSE 85932
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
85876: NOP4
85880: PPUSH
85881: LD_STRING M
85883: PUSH
85884: NOP4
85888: PUSH
85889: LD_INT 1
85891: ARRAY
85892: PUSH
85893: NOP4
85897: PUSH
85898: LD_INT 2
85900: ARRAY
85901: PUSH
85902: LD_INT 0
85904: PUSH
85905: LD_INT 0
85907: PUSH
85908: LD_INT 0
85910: PUSH
85911: LD_INT 0
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: PUSH
85923: EMPTY
85924: LIST
85925: PPUSH
85926: NOP4
85930: GO 85873
85932: POP
85933: POP
// end ;
85934: LD_VAR 0 5
85938: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
85939: NOP4
85943: NOT
85944: IFFALSE 85994
85946: GO 85948
85948: DISABLE
// begin initHack := true ;
85949: NOP4
85953: PUSH
85954: LD_INT 1
85956: ST_TO_ADDR
// hackTanks := [ ] ;
85957: NOP4
85961: PUSH
85962: EMPTY
85963: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
85964: NOP4
85968: PUSH
85969: EMPTY
85970: ST_TO_ADDR
// hackLimit := 3 ;
85971: NOP4
85975: PUSH
85976: LD_INT 3
85978: ST_TO_ADDR
// hackDist := 12 ;
85979: NOP4
85983: PUSH
85984: LD_INT 12
85986: ST_TO_ADDR
// hackCounter := [ ] ;
85987: NOP4
85991: PUSH
85992: EMPTY
85993: ST_TO_ADDR
// end ;
85994: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
85995: NOP4
85999: PUSH
86000: LD_INT 34
86002: PUSH
86003: NOP4
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PPUSH
86012: NOP4
86016: AND
86017: IFFALSE 86272
86019: GO 86021
86021: DISABLE
86022: LD_INT 0
86024: PPUSH
86025: PPUSH
// begin enable ;
86026: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
86027: NOP4
86031: PUSH
86032: LD_INT 34
86034: PUSH
86035: NOP4
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PPUSH
86044: NOP4
86048: PUSH
86049: FOR_IN
86050: IFFALSE 86270
// begin if not i in hackTanks then
86052: NOP4
86056: PUSH
86057: NOP4
86061: IN
86062: NOT
86063: IFFALSE 86146
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
86065: NOP4
86069: PUSH
86070: NOP4
86074: PPUSH
86075: NOP4
86079: PUSH
86080: LD_INT 1
86082: PLUS
86083: PPUSH
86084: NOP4
86088: PPUSH
86089: NOP4
86093: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
86094: NOP4
86098: PUSH
86099: NOP4
86103: PPUSH
86104: NOP4
86108: PUSH
86109: LD_INT 1
86111: PLUS
86112: PPUSH
86113: EMPTY
86114: PPUSH
86115: NOP4
86119: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
86120: NOP4
86124: PUSH
86125: NOP4
86129: PPUSH
86130: NOP4
86134: PUSH
86135: LD_INT 1
86137: PLUS
86138: PPUSH
86139: EMPTY
86140: PPUSH
86141: NOP4
86145: ST_TO_ADDR
// end ; if not IsOk ( i ) then
86146: NOP4
86150: PPUSH
86151: NOP4
86155: NOT
86156: IFFALSE 86169
// begin HackUnlinkAll ( i ) ;
86158: NOP4
86162: PPUSH
86163: NOP4
// continue ;
86167: GO 86049
// end ; HackCheckCapturedStatus ( i ) ;
86169: NOP4
86173: PPUSH
86174: NOP4
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
86178: NOP4
86182: PUSH
86183: LD_INT 81
86185: PUSH
86186: NOP4
86190: PPUSH
86191: NOP4
86195: PUSH
86196: EMPTY
86197: LIST
86198: LIST
86199: PUSH
86200: LD_INT 33
86202: PUSH
86203: LD_INT 3
86205: PUSH
86206: EMPTY
86207: LIST
86208: LIST
86209: PUSH
86210: LD_INT 91
86212: PUSH
86213: NOP4
86217: PUSH
86218: NOP4
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: LIST
86227: PUSH
86228: LD_INT 50
86230: PUSH
86231: EMPTY
86232: LIST
86233: PUSH
86234: EMPTY
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: PPUSH
86240: NOP4
86244: ST_TO_ADDR
// if not tmp then
86245: NOP4
86249: NOT
86250: IFFALSE 86254
// continue ;
86252: GO 86049
// HackLink ( i , tmp ) ;
86254: NOP4
86258: PPUSH
86259: NOP4
86263: PPUSH
86264: NOP4
// end ;
86268: GO 86049
86270: POP
86271: POP
// end ;
86272: PPOPN 2
86274: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
86275: LD_INT 0
86277: PPUSH
86278: PPUSH
86279: PPUSH
// if not hack in hackTanks then
86280: NOP4
86284: PUSH
86285: NOP4
86289: IN
86290: NOT
86291: IFFALSE 86295
// exit ;
86293: GO 86406
// index := GetElementIndex ( hackTanks , hack ) ;
86295: NOP4
86299: PUSH
86300: NOP4
86304: PPUSH
86305: NOP4
86309: PPUSH
86310: NOP4
86314: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
86315: NOP4
86319: PUSH
86320: NOP4
86324: ARRAY
86325: IFFALSE 86406
// begin for i in hackTanksCaptured [ index ] do
86327: NOP4
86331: PUSH
86332: NOP4
86336: PUSH
86337: NOP4
86341: ARRAY
86342: PUSH
86343: FOR_IN
86344: IFFALSE 86370
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
86346: NOP4
86350: PUSH
86351: LD_INT 1
86353: ARRAY
86354: PPUSH
86355: NOP4
86359: PUSH
86360: LD_INT 2
86362: ARRAY
86363: PPUSH
86364: NOP4
86368: GO 86343
86370: POP
86371: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
86372: NOP4
86376: PUSH
86377: NOP4
86381: PPUSH
86382: NOP4
86386: PPUSH
86387: EMPTY
86388: PPUSH
86389: NOP4
86393: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
86394: NOP4
86398: PPUSH
86399: LD_INT 0
86401: PPUSH
86402: NOP4
// end ; end ;
86406: LD_VAR 0 2
86410: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
86411: LD_INT 0
86413: PPUSH
86414: PPUSH
86415: PPUSH
// if not hack in hackTanks or not vehicles then
86416: NOP4
86420: PUSH
86421: NOP4
86425: IN
86426: NOT
86427: PUSH
86428: NOP4
86432: NOT
86433: OR
86434: IFFALSE 86438
// exit ;
86436: GO 86713
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
86438: NOP4
86442: PUSH
86443: NOP4
86447: PPUSH
86448: NOP4
86452: PPUSH
86453: LD_INT 1
86455: PPUSH
86456: LD_INT 1
86458: PPUSH
86459: NOP4
86463: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
86464: NOP4
86468: PUSH
86469: NOP4
86473: PPUSH
86474: NOP4
86478: PPUSH
86479: NOP4
86483: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
86484: NOP4
86488: PUSH
86489: NOP4
86493: ARRAY
86494: PUSH
86495: NOP4
86499: LESS
86500: IFFALSE 86689
// begin for i := 1 to vehicles do
86502: NOP4
86506: PUSH
86507: DOUBLE
86508: LD_INT 1
86510: DEC
86511: ST_TO_ADDR
86512: NOP4
86516: PUSH
86517: FOR_TO
86518: IFFALSE 86687
// begin if hackTanksCaptured [ index ] = hackLimit then
86520: NOP4
86524: PUSH
86525: NOP4
86529: ARRAY
86530: PUSH
86531: NOP4
86535: EQUAL
86536: IFFALSE 86540
// break ;
86538: GO 86687
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
86540: NOP4
86544: PUSH
86545: NOP4
86549: PPUSH
86550: NOP4
86554: PPUSH
86555: NOP4
86559: PUSH
86560: NOP4
86564: ARRAY
86565: PUSH
86566: LD_INT 1
86568: PLUS
86569: PPUSH
86570: NOP4
86574: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
86575: NOP4
86579: PUSH
86580: NOP4
86584: PPUSH
86585: NOP4
86589: PUSH
86590: NOP4
86594: PUSH
86595: NOP4
86599: ARRAY
86600: PUSH
86601: LD_INT 1
86603: PLUS
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: PPUSH
86609: NOP4
86613: PUSH
86614: NOP4
86618: ARRAY
86619: PUSH
86620: NOP4
86624: PUSH
86625: NOP4
86629: ARRAY
86630: PPUSH
86631: NOP4
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PPUSH
86640: NOP4
86644: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
86645: NOP4
86649: PUSH
86650: NOP4
86654: ARRAY
86655: PPUSH
86656: NOP4
86660: PPUSH
86661: NOP4
86665: PPUSH
86666: NOP4
// ComStop ( vehicles [ i ] ) ;
86670: NOP4
86674: PUSH
86675: NOP4
86679: ARRAY
86680: PPUSH
86681: NOP4
// end ;
86685: GO 86517
86687: POP
86688: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86689: NOP4
86693: PPUSH
86694: NOP4
86698: PUSH
86699: NOP4
86703: ARRAY
86704: PUSH
86705: LD_INT 0
86707: PLUS
86708: PPUSH
86709: NOP4
// end ;
86713: LD_VAR 0 3
86717: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
86718: LD_INT 0
86720: PPUSH
86721: PPUSH
86722: PPUSH
86723: PPUSH
// if not hack in hackTanks then
86724: NOP4
86728: PUSH
86729: NOP4
86733: IN
86734: NOT
86735: IFFALSE 86739
// exit ;
86737: GO 86979
// index := GetElementIndex ( hackTanks , hack ) ;
86739: NOP4
86743: PUSH
86744: NOP4
86748: PPUSH
86749: NOP4
86753: PPUSH
86754: NOP4
86758: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
86759: NOP4
86763: PUSH
86764: DOUBLE
86765: NOP4
86769: PUSH
86770: NOP4
86774: ARRAY
86775: INC
86776: ST_TO_ADDR
86777: LD_INT 1
86779: PUSH
86780: FOR_DOWNTO
86781: IFFALSE 86953
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
86783: NOP4
86787: PUSH
86788: NOP4
86792: PUSH
86793: NOP4
86797: ARRAY
86798: PUSH
86799: NOP4
86803: ARRAY
86804: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
86805: NOP4
86809: PUSH
86810: LD_INT 1
86812: ARRAY
86813: PPUSH
86814: NOP4
86818: NOT
86819: PUSH
86820: NOP4
86824: PUSH
86825: LD_INT 1
86827: ARRAY
86828: PPUSH
86829: NOP4
86833: PUSH
86834: NOP4
86838: PPUSH
86839: NOP4
86843: NONEQUAL
86844: OR
86845: IFFALSE 86951
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
86847: NOP4
86851: PUSH
86852: LD_INT 1
86854: ARRAY
86855: PPUSH
86856: NOP4
86860: PUSH
86861: NOP4
86865: PUSH
86866: LD_INT 1
86868: ARRAY
86869: PPUSH
86870: NOP4
86874: PUSH
86875: NOP4
86879: PPUSH
86880: NOP4
86884: EQUAL
86885: AND
86886: IFFALSE 86910
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
86888: NOP4
86892: PUSH
86893: LD_INT 1
86895: ARRAY
86896: PPUSH
86897: NOP4
86901: PUSH
86902: LD_INT 2
86904: ARRAY
86905: PPUSH
86906: NOP4
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
86910: NOP4
86914: PUSH
86915: NOP4
86919: PPUSH
86920: NOP4
86924: PPUSH
86925: NOP4
86929: PUSH
86930: NOP4
86934: ARRAY
86935: PPUSH
86936: NOP4
86940: PPUSH
86941: NOP4
86945: PPUSH
86946: NOP4
86950: ST_TO_ADDR
// end ; end ;
86951: GO 86780
86953: POP
86954: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86955: NOP4
86959: PPUSH
86960: NOP4
86964: PUSH
86965: NOP4
86969: ARRAY
86970: PUSH
86971: LD_INT 0
86973: PLUS
86974: PPUSH
86975: NOP4
// end ;
86979: LD_VAR 0 2
86983: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
86984: LD_INT 0
86986: PPUSH
86987: PPUSH
86988: PPUSH
86989: PPUSH
// if not hack in hackTanks then
86990: NOP4
86994: PUSH
86995: NOP4
86999: IN
87000: NOT
87001: IFFALSE 87005
// exit ;
87003: GO 87090
// index := GetElementIndex ( hackTanks , hack ) ;
87005: NOP4
87009: PUSH
87010: NOP4
87014: PPUSH
87015: NOP4
87019: PPUSH
87020: NOP4
87024: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
87025: NOP4
87029: PUSH
87030: DOUBLE
87031: LD_INT 1
87033: DEC
87034: ST_TO_ADDR
87035: NOP4
87039: PUSH
87040: NOP4
87044: ARRAY
87045: PUSH
87046: FOR_TO
87047: IFFALSE 87088
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
87049: NOP4
87053: PUSH
87054: NOP4
87058: ARRAY
87059: PUSH
87060: NOP4
87064: ARRAY
87065: PUSH
87066: LD_INT 1
87068: ARRAY
87069: PUSH
87070: NOP4
87074: EQUAL
87075: IFFALSE 87086
// KillUnit ( vehicle ) ;
87077: NOP4
87081: PPUSH
87082: NOP4
87086: GO 87046
87088: POP
87089: POP
// end ;
87090: LD_VAR 0 3
87094: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
87095: NOP4
87099: NOT
87100: IFFALSE 87135
87102: GO 87104
87104: DISABLE
// begin initMiner := true ;
87105: NOP4
87109: PUSH
87110: LD_INT 1
87112: ST_TO_ADDR
// minersList := [ ] ;
87113: NOP4
87117: PUSH
87118: EMPTY
87119: ST_TO_ADDR
// minerMinesList := [ ] ;
87120: NOP4
87124: PUSH
87125: EMPTY
87126: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
87127: NOP4
87131: PUSH
87132: LD_INT 5
87134: ST_TO_ADDR
// end ;
87135: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
87136: NOP4
87140: PUSH
87141: LD_INT 34
87143: PUSH
87144: NOP4
87148: PUSH
87149: EMPTY
87150: LIST
87151: LIST
87152: PPUSH
87153: NOP4
87157: AND
87158: IFFALSE 87621
87160: GO 87162
87162: DISABLE
87163: LD_INT 0
87165: PPUSH
87166: PPUSH
87167: PPUSH
87168: PPUSH
// begin enable ;
87169: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
87170: NOP4
87174: PUSH
87175: LD_INT 34
87177: PUSH
87178: NOP4
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: PPUSH
87187: NOP4
87191: PUSH
87192: FOR_IN
87193: IFFALSE 87265
// begin if not i in minersList then
87195: NOP4
87199: PUSH
87200: NOP4
87204: IN
87205: NOT
87206: IFFALSE 87263
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
87208: NOP4
87212: PUSH
87213: NOP4
87217: PPUSH
87218: NOP4
87222: PUSH
87223: LD_INT 1
87225: PLUS
87226: PPUSH
87227: NOP4
87231: PPUSH
87232: NOP4
87236: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
87237: NOP4
87241: PUSH
87242: NOP4
87246: PPUSH
87247: NOP4
87251: PUSH
87252: LD_INT 1
87254: PLUS
87255: PPUSH
87256: EMPTY
87257: PPUSH
87258: NOP4
87262: ST_TO_ADDR
// end end ;
87263: GO 87192
87265: POP
87266: POP
// for i := minerMinesList downto 1 do
87267: NOP4
87271: PUSH
87272: DOUBLE
87273: NOP4
87277: INC
87278: ST_TO_ADDR
87279: LD_INT 1
87281: PUSH
87282: FOR_DOWNTO
87283: IFFALSE 87619
// begin if IsLive ( minersList [ i ] ) then
87285: NOP4
87289: PUSH
87290: NOP4
87294: ARRAY
87295: PPUSH
87296: NOP4
87300: IFFALSE 87328
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
87302: NOP4
87306: PUSH
87307: NOP4
87311: ARRAY
87312: PPUSH
87313: NOP4
87317: PUSH
87318: NOP4
87322: ARRAY
87323: PPUSH
87324: NOP4
// if not minerMinesList [ i ] then
87328: NOP4
87332: PUSH
87333: NOP4
87337: ARRAY
87338: NOT
87339: IFFALSE 87343
// continue ;
87341: GO 87282
// for j := minerMinesList [ i ] downto 1 do
87343: NOP4
87347: PUSH
87348: DOUBLE
87349: NOP4
87353: PUSH
87354: NOP4
87358: ARRAY
87359: INC
87360: ST_TO_ADDR
87361: LD_INT 1
87363: PUSH
87364: FOR_DOWNTO
87365: IFFALSE 87615
// begin side := GetSide ( minersList [ i ] ) ;
87367: NOP4
87371: PUSH
87372: NOP4
87376: PUSH
87377: NOP4
87381: ARRAY
87382: PPUSH
87383: NOP4
87387: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
87388: NOP4
87392: PUSH
87393: NOP4
87397: PUSH
87398: NOP4
87402: ARRAY
87403: PUSH
87404: NOP4
87408: ARRAY
87409: PUSH
87410: LD_INT 1
87412: ARRAY
87413: PPUSH
87414: NOP4
87418: PUSH
87419: NOP4
87423: ARRAY
87424: PUSH
87425: NOP4
87429: ARRAY
87430: PUSH
87431: LD_INT 2
87433: ARRAY
87434: PPUSH
87435: NOP4
87439: ST_TO_ADDR
// if not tmp then
87440: NOP4
87444: NOT
87445: IFFALSE 87449
// continue ;
87447: GO 87364
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
87449: NOP4
87453: PUSH
87454: LD_INT 81
87456: PUSH
87457: NOP4
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: PPUSH
87466: NOP4
87470: IN
87471: PUSH
87472: NOP4
87476: PUSH
87477: NOP4
87481: ARRAY
87482: PUSH
87483: NOP4
87487: ARRAY
87488: PUSH
87489: LD_INT 1
87491: ARRAY
87492: PPUSH
87493: NOP4
87497: PUSH
87498: NOP4
87502: ARRAY
87503: PUSH
87504: NOP4
87508: ARRAY
87509: PUSH
87510: LD_INT 2
87512: ARRAY
87513: PPUSH
87514: NOP4
87518: AND
87519: IFFALSE 87613
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
87521: NOP4
87525: PUSH
87526: NOP4
87530: ARRAY
87531: PUSH
87532: NOP4
87536: ARRAY
87537: PUSH
87538: LD_INT 1
87540: ARRAY
87541: PPUSH
87542: NOP4
87546: PUSH
87547: NOP4
87551: ARRAY
87552: PUSH
87553: NOP4
87557: ARRAY
87558: PUSH
87559: LD_INT 2
87561: ARRAY
87562: PPUSH
87563: NOP4
87567: PPUSH
87568: NOP4
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
87572: NOP4
87576: PUSH
87577: NOP4
87581: PPUSH
87582: NOP4
87586: PPUSH
87587: NOP4
87591: PUSH
87592: NOP4
87596: ARRAY
87597: PPUSH
87598: NOP4
87602: PPUSH
87603: NOP4
87607: PPUSH
87608: NOP4
87612: ST_TO_ADDR
// end ; end ;
87613: GO 87364
87615: POP
87616: POP
// end ;
87617: GO 87282
87619: POP
87620: POP
// end ;
87621: PPOPN 4
87623: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
87624: LD_INT 0
87626: PPUSH
87627: PPUSH
// result := false ;
87628: NOP4
87632: PUSH
87633: LD_INT 0
87635: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
87636: NOP4
87640: PPUSH
87641: NOP4
87645: PUSH
87646: NOP4
87650: EQUAL
87651: NOT
87652: IFFALSE 87656
// exit ;
87654: GO 87896
// index := GetElementIndex ( minersList , unit ) ;
87656: NOP4
87660: PUSH
87661: NOP4
87665: PPUSH
87666: NOP4
87670: PPUSH
87671: NOP4
87675: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
87676: NOP4
87680: PUSH
87681: NOP4
87685: ARRAY
87686: PUSH
87687: NOP4
87691: GREATEREQUAL
87692: IFFALSE 87696
// exit ;
87694: GO 87896
// ComMoveXY ( unit , x , y ) ;
87696: NOP4
87700: PPUSH
87701: NOP4
87705: PPUSH
87706: NOP4
87710: PPUSH
87711: NOP4
// repeat wait ( 0 0$1 ) ;
87715: LD_INT 35
87717: PPUSH
87718: NOP4
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
87722: NOP4
87726: PPUSH
87727: NOP4
87731: PPUSH
87732: NOP4
87736: PPUSH
87737: NOP4
87741: NOT
87742: PUSH
87743: NOP4
87747: PPUSH
87748: NOP4
87752: AND
87753: IFFALSE 87757
// exit ;
87755: GO 87896
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
87757: NOP4
87761: PPUSH
87762: NOP4
87766: PPUSH
87767: NOP4
87771: PUSH
87772: NOP4
87776: EQUAL
87777: PUSH
87778: NOP4
87782: PPUSH
87783: NOP4
87787: NOT
87788: AND
87789: IFFALSE 87715
// PlaySoundXY ( x , y , PlantMine ) ;
87791: NOP4
87795: PPUSH
87796: NOP4
87800: PPUSH
87801: LD_STRING PlantMine
87803: PPUSH
87804: NOP4
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
87808: NOP4
87812: PPUSH
87813: NOP4
87817: PPUSH
87818: NOP4
87822: PPUSH
87823: NOP4
87827: PPUSH
87828: LD_INT 0
87830: PPUSH
87831: NOP4
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
87835: NOP4
87839: PUSH
87840: NOP4
87844: PPUSH
87845: NOP4
87849: PUSH
87850: NOP4
87854: PUSH
87855: NOP4
87859: ARRAY
87860: PUSH
87861: LD_INT 1
87863: PLUS
87864: PUSH
87865: EMPTY
87866: LIST
87867: LIST
87868: PPUSH
87869: NOP4
87873: PUSH
87874: NOP4
87878: PUSH
87879: EMPTY
87880: LIST
87881: LIST
87882: PPUSH
87883: NOP4
87887: ST_TO_ADDR
// result := true ;
87888: NOP4
87892: PUSH
87893: LD_INT 1
87895: ST_TO_ADDR
// end ;
87896: LD_VAR 0 4
87900: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
87901: LD_INT 0
87903: PPUSH
87904: PPUSH
87905: PPUSH
// if not unit in minersList then
87906: NOP4
87910: PUSH
87911: NOP4
87915: IN
87916: NOT
87917: IFFALSE 87921
// exit ;
87919: GO 88313
// index := GetElementIndex ( minersList , unit ) ;
87921: NOP4
87925: PUSH
87926: NOP4
87930: PPUSH
87931: NOP4
87935: PPUSH
87936: NOP4
87940: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
87941: NOP4
87945: PUSH
87946: DOUBLE
87947: NOP4
87951: PUSH
87952: NOP4
87956: ARRAY
87957: INC
87958: ST_TO_ADDR
87959: LD_INT 1
87961: PUSH
87962: FOR_DOWNTO
87963: IFFALSE 88124
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
87965: NOP4
87969: PUSH
87970: NOP4
87974: ARRAY
87975: PUSH
87976: NOP4
87980: ARRAY
87981: PUSH
87982: LD_INT 1
87984: ARRAY
87985: PUSH
87986: NOP4
87990: EQUAL
87991: PUSH
87992: NOP4
87996: PUSH
87997: NOP4
88001: ARRAY
88002: PUSH
88003: NOP4
88007: ARRAY
88008: PUSH
88009: LD_INT 2
88011: ARRAY
88012: PUSH
88013: NOP4
88017: EQUAL
88018: AND
88019: IFFALSE 88122
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
88021: NOP4
88025: PUSH
88026: NOP4
88030: ARRAY
88031: PUSH
88032: NOP4
88036: ARRAY
88037: PUSH
88038: LD_INT 1
88040: ARRAY
88041: PPUSH
88042: NOP4
88046: PUSH
88047: NOP4
88051: ARRAY
88052: PUSH
88053: NOP4
88057: ARRAY
88058: PUSH
88059: LD_INT 2
88061: ARRAY
88062: PPUSH
88063: NOP4
88067: PPUSH
88068: NOP4
88072: PPUSH
88073: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
88077: NOP4
88081: PUSH
88082: NOP4
88086: PPUSH
88087: NOP4
88091: PPUSH
88092: NOP4
88096: PUSH
88097: NOP4
88101: ARRAY
88102: PPUSH
88103: NOP4
88107: PPUSH
88108: NOP4
88112: PPUSH
88113: NOP4
88117: ST_TO_ADDR
// exit ;
88118: POP
88119: POP
88120: GO 88313
// end ; end ;
88122: GO 87962
88124: POP
88125: POP
// for i := minerMinesList [ index ] downto 1 do
88126: NOP4
88130: PUSH
88131: DOUBLE
88132: NOP4
88136: PUSH
88137: NOP4
88141: ARRAY
88142: INC
88143: ST_TO_ADDR
88144: LD_INT 1
88146: PUSH
88147: FOR_DOWNTO
88148: IFFALSE 88311
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
88150: NOP4
88154: PUSH
88155: NOP4
88159: ARRAY
88160: PUSH
88161: NOP4
88165: ARRAY
88166: PUSH
88167: LD_INT 1
88169: ARRAY
88170: PPUSH
88171: NOP4
88175: PUSH
88176: NOP4
88180: ARRAY
88181: PUSH
88182: NOP4
88186: ARRAY
88187: PUSH
88188: LD_INT 2
88190: ARRAY
88191: PPUSH
88192: NOP4
88196: PPUSH
88197: NOP4
88201: PPUSH
88202: NOP4
88206: PUSH
88207: LD_INT 6
88209: LESS
88210: IFFALSE 88309
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
88212: NOP4
88216: PUSH
88217: NOP4
88221: ARRAY
88222: PUSH
88223: NOP4
88227: ARRAY
88228: PUSH
88229: LD_INT 1
88231: ARRAY
88232: PPUSH
88233: NOP4
88237: PUSH
88238: NOP4
88242: ARRAY
88243: PUSH
88244: NOP4
88248: ARRAY
88249: PUSH
88250: LD_INT 2
88252: ARRAY
88253: PPUSH
88254: NOP4
88258: PPUSH
88259: NOP4
88263: PPUSH
88264: NOP4
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
88268: NOP4
88272: PUSH
88273: NOP4
88277: PPUSH
88278: NOP4
88282: PPUSH
88283: NOP4
88287: PUSH
88288: NOP4
88292: ARRAY
88293: PPUSH
88294: NOP4
88298: PPUSH
88299: NOP4
88303: PPUSH
88304: NOP4
88308: ST_TO_ADDR
// end ; end ;
88309: GO 88147
88311: POP
88312: POP
// end ;
88313: LD_VAR 0 4
88317: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
88318: LD_INT 0
88320: PPUSH
88321: PPUSH
88322: PPUSH
88323: PPUSH
88324: PPUSH
88325: PPUSH
88326: PPUSH
88327: PPUSH
88328: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
88329: NOP4
88333: PPUSH
88334: NOP4
88338: PUSH
88339: NOP4
88343: EQUAL
88344: NOT
88345: PUSH
88346: NOP4
88350: PUSH
88351: NOP4
88355: IN
88356: NOT
88357: OR
88358: IFFALSE 88362
// exit ;
88360: GO 88684
// index := GetElementIndex ( minersList , unit ) ;
88362: NOP4
88366: PUSH
88367: NOP4
88371: PPUSH
88372: NOP4
88376: PPUSH
88377: NOP4
88381: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
88382: NOP4
88386: PUSH
88387: NOP4
88391: PUSH
88392: NOP4
88396: PUSH
88397: NOP4
88401: ARRAY
88402: MINUS
88403: ST_TO_ADDR
// if not minesFreeAmount then
88404: NOP4
88408: NOT
88409: IFFALSE 88413
// exit ;
88411: GO 88684
// tmp := [ ] ;
88413: NOP4
88417: PUSH
88418: EMPTY
88419: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
88420: NOP4
88424: PUSH
88425: DOUBLE
88426: LD_INT 1
88428: DEC
88429: ST_TO_ADDR
88430: NOP4
88434: PUSH
88435: FOR_TO
88436: IFFALSE 88631
// begin _d := rand ( 0 , 5 ) ;
88438: NOP4
88442: PUSH
88443: LD_INT 0
88445: PPUSH
88446: LD_INT 5
88448: PPUSH
88449: NOP4
88453: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
88454: NOP4
88458: PUSH
88459: LD_INT 2
88461: PPUSH
88462: LD_INT 6
88464: PPUSH
88465: NOP4
88469: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
88470: NOP4
88474: PUSH
88475: NOP4
88479: PPUSH
88480: NOP4
88484: PPUSH
88485: NOP4
88489: PPUSH
88490: NOP4
88494: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
88495: NOP4
88499: PUSH
88500: NOP4
88504: PPUSH
88505: NOP4
88509: PPUSH
88510: NOP4
88514: PPUSH
88515: NOP4
88519: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
88520: NOP4
88524: PPUSH
88525: NOP4
88529: PPUSH
88530: NOP4
88534: PUSH
88535: NOP4
88539: PUSH
88540: NOP4
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: NOP4
88553: IN
88554: NOT
88555: AND
88556: PUSH
88557: NOP4
88561: PPUSH
88562: NOP4
88566: PPUSH
88567: NOP4
88571: NOT
88572: AND
88573: IFFALSE 88615
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
88575: NOP4
88579: PUSH
88580: NOP4
88584: PPUSH
88585: NOP4
88589: PUSH
88590: LD_INT 1
88592: PLUS
88593: PPUSH
88594: NOP4
88598: PUSH
88599: NOP4
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: PPUSH
88608: NOP4
88612: ST_TO_ADDR
88613: GO 88629
// i := i - 1 ;
88615: NOP4
88619: PUSH
88620: NOP4
88624: PUSH
88625: LD_INT 1
88627: MINUS
88628: ST_TO_ADDR
// end ;
88629: GO 88435
88631: POP
88632: POP
// for i in tmp do
88633: NOP4
88637: PUSH
88638: NOP4
88642: PUSH
88643: FOR_IN
88644: IFFALSE 88682
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
88646: NOP4
88650: PPUSH
88651: NOP4
88655: PUSH
88656: LD_INT 1
88658: ARRAY
88659: PPUSH
88660: NOP4
88664: PUSH
88665: LD_INT 2
88667: ARRAY
88668: PPUSH
88669: NOP4
88673: NOT
88674: IFFALSE 88680
// exit ;
88676: POP
88677: POP
88678: GO 88684
88680: GO 88643
88682: POP
88683: POP
// end ;
88684: LD_VAR 0 4
88688: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
88689: LD_INT 0
88691: PPUSH
88692: PPUSH
88693: PPUSH
88694: PPUSH
88695: PPUSH
88696: PPUSH
88697: PPUSH
// if not GetClass ( unit ) = class_sniper then
88698: NOP4
88702: PPUSH
88703: NOP4
88707: PUSH
88708: LD_INT 5
88710: EQUAL
88711: NOT
88712: IFFALSE 88716
// exit ;
88714: GO 89104
// dist := 8 ;
88716: NOP4
88720: PUSH
88721: LD_INT 8
88723: ST_TO_ADDR
// viewRange := 12 ;
88724: NOP4
88728: PUSH
88729: LD_INT 12
88731: ST_TO_ADDR
// side := GetSide ( unit ) ;
88732: NOP4
88736: PUSH
88737: NOP4
88741: PPUSH
88742: NOP4
88746: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
88747: LD_INT 61
88749: PPUSH
88750: NOP4
88754: PPUSH
88755: NOP4
88759: PUSH
88760: LD_INT 2
88762: EQUAL
88763: IFFALSE 88773
// viewRange := 16 ;
88765: NOP4
88769: PUSH
88770: LD_INT 16
88772: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
88773: NOP4
88777: PPUSH
88778: NOP4
88782: PPUSH
88783: NOP4
88787: PPUSH
88788: NOP4
88792: PUSH
88793: NOP4
88797: GREATER
88798: IFFALSE 88877
// begin ComMoveXY ( unit , x , y ) ;
88800: NOP4
88804: PPUSH
88805: NOP4
88809: PPUSH
88810: NOP4
88814: PPUSH
88815: NOP4
// repeat wait ( 0 0$1 ) ;
88819: LD_INT 35
88821: PPUSH
88822: NOP4
// if not UnitGoingToXY ( unit , x , y ) then
88826: NOP4
88830: PPUSH
88831: NOP4
88835: PPUSH
88836: NOP4
88840: PPUSH
88841: NOP4
88845: NOT
88846: IFFALSE 88850
// exit ;
88848: GO 89104
// until GetDistUnitXY ( unit , x , y ) < dist ;
88850: NOP4
88854: PPUSH
88855: NOP4
88859: PPUSH
88860: NOP4
88864: PPUSH
88865: NOP4
88869: PUSH
88870: NOP4
88874: LESS
88875: IFFALSE 88819
// end ; ComTurnXY ( unit , x , y ) ;
88877: NOP4
88881: PPUSH
88882: NOP4
88886: PPUSH
88887: NOP4
88891: PPUSH
88892: NOP4
// wait ( 5 ) ;
88896: LD_INT 5
88898: PPUSH
88899: NOP4
// _d := GetDir ( unit ) ;
88903: NOP4
88907: PUSH
88908: NOP4
88912: PPUSH
88913: NOP4
88917: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
88918: NOP4
88922: PUSH
88923: NOP4
88927: PPUSH
88928: NOP4
88932: PPUSH
88933: NOP4
88937: PPUSH
88938: NOP4
88942: PPUSH
88943: NOP4
88947: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
88948: NOP4
88952: PUSH
88953: NOP4
88957: PPUSH
88958: NOP4
88962: PPUSH
88963: NOP4
88967: PPUSH
88968: NOP4
88972: PPUSH
88973: NOP4
88977: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88978: NOP4
88982: PPUSH
88983: NOP4
88987: PPUSH
88988: NOP4
88992: NOT
88993: IFFALSE 88997
// exit ;
88995: GO 89104
// ComAnimCustom ( unit , 1 ) ;
88997: NOP4
89001: PPUSH
89002: LD_INT 1
89004: PPUSH
89005: NOP4
// PlaceSeeing ( _x , _y , side , viewRange ) ;
89009: NOP4
89013: PPUSH
89014: NOP4
89018: PPUSH
89019: NOP4
89023: PPUSH
89024: NOP4
89028: PPUSH
89029: NOP4
// repeat wait ( 1 ) ;
89033: LD_INT 1
89035: PPUSH
89036: NOP4
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
89040: NOP4
89044: PPUSH
89045: NOP4
89049: PUSH
89050: NOP4
89054: PPUSH
89055: NOP4
89059: OR
89060: PUSH
89061: NOP4
89065: PPUSH
89066: NOP4
89070: NOT
89071: OR
89072: PUSH
89073: NOP4
89077: PPUSH
89078: NOP4
89082: OR
89083: IFFALSE 89033
// RemoveSeeing ( _x , _y , side ) ;
89085: NOP4
89089: PPUSH
89090: NOP4
89094: PPUSH
89095: NOP4
89099: PPUSH
89100: NOP4
// end ; end_of_file
89104: LD_VAR 0 4
89108: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
89109: NOP4
89113: PUSH
89114: LD_INT 200
89116: DOUBLE
89117: GREATEREQUAL
89118: IFFALSE 89126
89120: LD_INT 299
89122: DOUBLE
89123: LESSEQUAL
89124: IFTRUE 89128
89126: GO 89160
89128: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
89129: NOP4
89133: PPUSH
89134: NOP4
89138: PPUSH
89139: NOP4
89143: PPUSH
89144: NOP4
89148: PPUSH
89149: NOP4
89153: PPUSH
89154: NOP4
89158: GO 89237
89160: LD_INT 300
89162: DOUBLE
89163: GREATEREQUAL
89164: IFFALSE 89172
89166: LD_INT 399
89168: DOUBLE
89169: LESSEQUAL
89170: IFTRUE 89174
89172: GO 89236
89174: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
89175: NOP4
89179: PPUSH
89180: NOP4
89184: PPUSH
89185: NOP4
89189: PPUSH
89190: NOP4
89194: PPUSH
89195: NOP4
89199: PPUSH
89200: NOP4
89204: PPUSH
89205: NOP4
89209: PPUSH
89210: NOP4
89214: PPUSH
89215: NOP4
89219: PPUSH
89220: NOP4
89224: PPUSH
89225: NOP4
89229: PPUSH
89230: NOP4
89234: GO 89237
89236: POP
// end ;
89237: PPOPN 11
89239: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
89240: NOP4
89244: PPUSH
89245: NOP4
89249: PPUSH
89250: NOP4
89254: PPUSH
89255: NOP4
89259: PPUSH
89260: NOP4
89264: PPUSH
89265: NOP4
// end ;
89269: PPOPN 5
89271: END
